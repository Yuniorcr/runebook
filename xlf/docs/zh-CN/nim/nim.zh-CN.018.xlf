<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="nim">
    <body>
      <group id="nim">
        <trans-unit id="b087f456c58a0b1e2bb211a477a678bd99fae255" translate="yes" xml:space="preserve">
          <source>The default build of a project is a &lt;span id=&quot;debug-build_1&quot;&gt;debug build&lt;/span&gt;. To compile a &lt;span id=&quot;release-build_1&quot;&gt;release build&lt;/span&gt; define the &lt;code&gt;release&lt;/code&gt; symbol:</source>
          <target state="translated">项目的默认构建是&lt;span id=&quot;debug-build_1&quot;&gt;调试构建&lt;/span&gt;。要编译&lt;span id=&quot;release-build_1&quot;&gt;发布版本，请&lt;/span&gt;定义 &lt;code&gt;release&lt;/code&gt; 符号：</target>
        </trans-unit>
        <trans-unit id="d12eb915f38cd1b959d9b90e29441cd8da7737ff" translate="yes" xml:space="preserve">
          <source>The default calling convention is &lt;code&gt;nimcall&lt;/code&gt;, unless it is an inner proc (a proc inside of a proc). For an inner proc an analysis is performed whether it accesses its environment. If it does so, it has the calling convention &lt;code&gt;closure&lt;/code&gt;, otherwise it has the calling convention &lt;code&gt;nimcall&lt;/code&gt;.</source>
          <target state="translated">默认的调用约定是 &lt;code&gt;nimcall&lt;/code&gt; ，除非它是一个内部proc（proc内部的proc）。对于内部过程，将执行是否访问其环境的分析。如果这样做，它将具有调用约定 &lt;code&gt;closure&lt;/code&gt; ，否则将具有调用约定 &lt;code&gt;nimcall&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ce8c7b7d3265aaf66366428beeb806323db1c873" translate="yes" xml:space="preserve">
          <source>The default compiler is defined at the top of &lt;code&gt;config\nim.cfg&lt;/code&gt;. Changing this setting affects the compiler used by &lt;code&gt;koch&lt;/code&gt; to (re)build Nim.</source>
          <target state="translated">默认编译器在 &lt;code&gt;config\nim.cfg&lt;/code&gt; 的顶部定义。更改此设置会影响 &lt;code&gt;koch&lt;/code&gt; 用来（重新）构建Nim 的编译器。</target>
        </trans-unit>
        <trans-unit id="e96baa512c39f7d0782817e5f034412a054f571f" translate="yes" xml:space="preserve">
          <source>The default configuration (&lt;code&gt;trim=true&lt;/code&gt; and &lt;code&gt;precision=10&lt;/code&gt;) shows the &lt;strong&gt;shortest&lt;/strong&gt; form that precisely (up to a maximum of 10 decimal places) displays the value. For example, 4.100000 will be displayed as 4.1 (which is mathematically identical) whereas 4.1000003 will be displayed as 4.1000003.</source>
          <target state="translated">默认配置（ &lt;code&gt;trim=true&lt;/code&gt; 和 &lt;code&gt;precision=10&lt;/code&gt; ）显示精确显示该值的&lt;strong&gt;最短&lt;/strong&gt;形式（最多10个小数位）。例如，4.100000将显示为4.1（在数学上是相同的），而4.1000003将显示为4.1000003。</target>
        </trans-unit>
        <trans-unit id="2fb29e1efca282ec617c93b0148451d02698d52e" translate="yes" xml:space="preserve">
          <source>The default configuration (&lt;em&gt;trim=true&lt;/em&gt; and &lt;em&gt;precision=10&lt;/em&gt;) shows the &lt;strong&gt;shortest&lt;/strong&gt; form that precisely (up to a maximum of 10 decimal places) displays the value. For example, 4.100000 will be displayed as 4.1 (which is mathematically identical) whereas 4.1000003 will be displayed as 4.1000003.</source>
          <target state="translated">默认配置（&lt;em&gt;trim = true&lt;/em&gt;和&lt;em&gt;precision = 10&lt;/em&gt;）显示精确显示该值的&lt;strong&gt;最短&lt;/strong&gt;形式（最多10个小数位）。例如，4.100000将显示为4.1（在数学上是相同的），而4.1000003将显示为4.1000003。</target>
        </trans-unit>
        <trans-unit id="7d91717c8150be3c817688d172359eebf60c9b3f" translate="yes" xml:space="preserve">
          <source>The default float type is &lt;code&gt;float&lt;/code&gt;. In the current implementation, &lt;code&gt;float&lt;/code&gt; is always 64-bits.</source>
          <target state="translated">默认的float类型是 &lt;code&gt;float&lt;/code&gt; 。在当前的实现中， &lt;code&gt;float&lt;/code&gt; 始终为64位。</target>
        </trans-unit>
        <trans-unit id="2c1049ba9351f416eaad2423d6f9c80998361c05" translate="yes" xml:space="preserve">
          <source>The default for symbols of entity &lt;code&gt;type&lt;/code&gt;, &lt;code&gt;var&lt;/code&gt;, &lt;code&gt;let&lt;/code&gt; and &lt;code&gt;const&lt;/code&gt; is &lt;code&gt;gensym&lt;/code&gt; and for &lt;code&gt;proc&lt;/code&gt;, &lt;code&gt;iterator&lt;/code&gt;, &lt;code&gt;converter&lt;/code&gt;, &lt;code&gt;template&lt;/code&gt;, &lt;code&gt;macro&lt;/code&gt; is &lt;code&gt;inject&lt;/code&gt;. However, if the name of the entity is passed as a template parameter, it is an inject'ed symbol:</source>
          <target state="translated">对于实体的符号的默认 &lt;code&gt;type&lt;/code&gt; ， &lt;code&gt;var&lt;/code&gt; ， &lt;code&gt;let&lt;/code&gt; 和 &lt;code&gt;const&lt;/code&gt; 是 &lt;code&gt;gensym&lt;/code&gt; 和 &lt;code&gt;proc&lt;/code&gt; ， &lt;code&gt;iterator&lt;/code&gt; ， &lt;code&gt;converter&lt;/code&gt; ， &lt;code&gt;template&lt;/code&gt; ， &lt;code&gt;macro&lt;/code&gt; 是 &lt;code&gt;inject&lt;/code&gt; 。但是，如果实体名称作为模板参数传递，则它是注入符号：</target>
        </trans-unit>
        <trans-unit id="33bc5ba68d5a4770f91c0f77bf490ba64a1ebdf4" translate="yes" xml:space="preserve">
          <source>The default format string.</source>
          <target state="translated">默认格式字符串。</target>
        </trans-unit>
        <trans-unit id="c2e82f3dbf50ec4aead0f830c3d860bcc03915a0" translate="yes" xml:space="preserve">
          <source>The default integer type is &lt;code&gt;int&lt;/code&gt;. Integer literals can have a &lt;em&gt;type suffix&lt;/em&gt; to specify a non-default integer type:</source>
          <target state="translated">默认整数类型为 &lt;code&gt;int&lt;/code&gt; 。整数文字可以具有&lt;em&gt;类型后缀&lt;/em&gt;以指定非默认整数类型：</target>
        </trans-unit>
        <trans-unit id="d7d511fa0f4131e89caffa53b1340e8da32540ee" translate="yes" xml:space="preserve">
          <source>The default is to write a stacktrace to &lt;code&gt;stderr&lt;/code&gt; and then call &lt;code&gt;quit(1)&lt;/code&gt;. Unstable API.</source>
          <target state="translated">默认是将堆栈跟踪写入 &lt;code&gt;stderr&lt;/code&gt; ，然后调用 &lt;code&gt;quit(1)&lt;/code&gt; 。API不稳定。</target>
        </trans-unit>
        <trans-unit id="0de79cd39665eebcab7f9383b18124da290c9e6c" translate="yes" xml:space="preserve">
          <source>The default mode is case sensitive.</source>
          <target state="translated">默认模式是区分大小写的。</target>
        </trans-unit>
        <trans-unit id="a938a7c0d5ddba81851d8d833ea57ac0a05a8458" translate="yes" xml:space="preserve">
          <source>The deprecated pragma is used to mark a symbol as deprecated:</source>
          <target state="translated">废弃的pragma用于标记一个符号为废弃的符号。</target>
        </trans-unit>
        <trans-unit id="762aa45b2aaec5e503b1dacdc6bb91a55cf5531c" translate="yes" xml:space="preserve">
          <source>The details of the inference algorithm are currently undocumented.</source>
          <target state="translated">推理算法的细节目前还没有记录。</target>
        </trans-unit>
        <trans-unit id="4e221c70b35d4c508839b98e3971cbeac27b698e" translate="yes" xml:space="preserve">
          <source>The detected command line token.</source>
          <target state="translated">检测到的命令行标记。</target>
        </trans-unit>
        <trans-unit id="e86d1f1124b9d68611440bacc4bff7bcfe2f6e0a" translate="yes" xml:space="preserve">
          <source>The difference between 1.0 and the smallest number greater than 1.0 that can be represented in a 32-bit floating-point type.</source>
          <target state="translated">1.0和大于1.0的最小数字之间的差值,可以用32位浮点类型表示。</target>
        </trans-unit>
        <trans-unit id="afc1aa22832c69c45d0caa9362039ca2a87d5b07" translate="yes" xml:space="preserve">
          <source>The difference between 1.0 and the smallest number greater than 1.0 that can be represented in a 64-bit floating-point type.</source>
          <target state="translated">1.0和大于1.0的最小数字之间的差值,可以用64位浮点类型表示。</target>
        </trans-unit>
        <trans-unit id="8d3ea0a55b18000a3ec2d6587062c904d3e896cd" translate="yes" xml:space="preserve">
          <source>The difference between &lt;code&gt;let&lt;/code&gt; and &lt;code&gt;const&lt;/code&gt; is: &lt;code&gt;let&lt;/code&gt; introduces a variable that can not be re-assigned, &lt;code&gt;const&lt;/code&gt; means &quot;enforce compile time evaluation and put it into a data section&quot;:</source>
          <target state="translated">&lt;code&gt;let&lt;/code&gt; 和 &lt;code&gt;const&lt;/code&gt; 之间的区别是： &lt;code&gt;let&lt;/code&gt; 引入了一个无法重新分配的变量， &lt;code&gt;const&lt;/code&gt; 的意思是&amp;ldquo;强制执行编译时评估并将其放入数据部分&amp;rdquo;：</target>
        </trans-unit>
        <trans-unit id="0a74b6801170bf0f38a336281fab4bfa8303a82a" translate="yes" xml:space="preserve">
          <source>The difference of two sets is represented mathematically as &lt;em&gt;A B&lt;/em&gt; and is the set of all objects that are members of &lt;em&gt;s1&lt;/em&gt; and not members of &lt;em&gt;s2&lt;/em&gt;. Example:</source>
          <target state="translated">两组的差在数学上用&lt;em&gt;AB&lt;/em&gt;表示，是&lt;em&gt;s1的&lt;/em&gt;成员而不是&lt;em&gt;s2&lt;/em&gt;的所有对象的集合。例：</target>
        </trans-unit>
        <trans-unit id="5d27f497247a1d668b9eedd90ebdd41b0705bd43" translate="yes" xml:space="preserve">
          <source>The difference of two sets is represented mathematically as &lt;em&gt;A ∖ B&lt;/em&gt; and is the set of all objects that are members of &lt;code&gt;s1&lt;/code&gt; and not members of &lt;code&gt;s2&lt;/code&gt;.</source>
          <target state="translated">两组的差在数学上表示为&lt;em&gt;A∖B，&lt;/em&gt;并且是属于 &lt;code&gt;s1&lt;/code&gt; 而不是 &lt;code&gt;s2&lt;/code&gt; 的所有对象的集合。</target>
        </trans-unit>
        <trans-unit id="7bfc8212e64434b0ef38e7d2b1ac70082312d54c" translate="yes" xml:space="preserve">
          <source>The difference with regards to the &lt;a href=&quot;#excl,HashSet%5BA%5D,A&quot;&gt;excl proc&lt;/a&gt; is that this proc returns &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;key&lt;/code&gt; was missing from &lt;code&gt;s&lt;/code&gt;. The proc will return &lt;code&gt;false&lt;/code&gt; if &lt;code&gt;key&lt;/code&gt; was in &lt;code&gt;s&lt;/code&gt; and it was removed during this call.</source>
          <target state="translated">关于&lt;a href=&quot;#excl,HashSet%5BA%5D,A&quot;&gt;excl proc&lt;/a&gt;的区别在于，如果 &lt;code&gt;s&lt;/code&gt; 中缺少 &lt;code&gt;key&lt;/code&gt; ，则此proc返回 &lt;code&gt;true&lt;/code&gt; 。如果 &lt;code&gt;key&lt;/code&gt; 在 &lt;code&gt;s&lt;/code&gt; 中,并且在此调用期间已将其删除，则proc将返回 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="37119833f19f914acaa770542dc626979be221e3" translate="yes" xml:space="preserve">
          <source>The difference with regards to the &lt;a href=&quot;#excl,IntSet,int&quot;&gt;excl proc&lt;/a&gt; is that this proc returns &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;key&lt;/code&gt; was missing from &lt;code&gt;s&lt;/code&gt;. The proc will return &lt;code&gt;false&lt;/code&gt; if &lt;code&gt;key&lt;/code&gt; was in &lt;code&gt;s&lt;/code&gt; and it was removed during this call.</source>
          <target state="translated">关于&lt;a href=&quot;#excl,IntSet,int&quot;&gt;excl proc&lt;/a&gt;的区别在于，如果 &lt;code&gt;s&lt;/code&gt; 中缺少 &lt;code&gt;key&lt;/code&gt; ，则此proc返回 &lt;code&gt;true&lt;/code&gt; 。如果 &lt;code&gt;key&lt;/code&gt; 在 &lt;code&gt;s&lt;/code&gt; 中,并且在此调用期间已将其删除，则proc将返回 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3b1b787f9dec43bac1fc4feaec6e737341d9ef05" translate="yes" xml:space="preserve">
          <source>The difference with regards to the &lt;a href=&quot;#excl,OrderedSet%5BA%5D,A&quot;&gt;excl proc&lt;/a&gt; is that this proc returns &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;key&lt;/code&gt; was missing from &lt;code&gt;s&lt;/code&gt;. The proc will return &lt;code&gt;false&lt;/code&gt; if &lt;code&gt;key&lt;/code&gt; was in &lt;code&gt;s&lt;/code&gt; and it was removed during this call.</source>
          <target state="translated">关于&lt;a href=&quot;#excl,OrderedSet%5BA%5D,A&quot;&gt;excl proc&lt;/a&gt;的区别在于，如果 &lt;code&gt;s&lt;/code&gt; 中缺少 &lt;code&gt;key&lt;/code&gt; ，则此proc返回 &lt;code&gt;true&lt;/code&gt; 。如果 &lt;code&gt;key&lt;/code&gt; 在 &lt;code&gt;s&lt;/code&gt; 中,并且在此调用期间已将其删除，则proc将返回 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7c0c41b3f142cacbbcc66573b8adaf31d489334d" translate="yes" xml:space="preserve">
          <source>The difference with regards to the &lt;a href=&quot;#excl,TOrderedSet%5BA%5D,A&quot;&gt;excl()&lt;/a&gt; proc is that this proc returns &lt;em&gt;true&lt;/em&gt; if &lt;em&gt;key&lt;/em&gt; was not present in &lt;em&gt;s&lt;/em&gt;. Example:</source>
          <target state="translated">关于&lt;a href=&quot;#excl,TOrderedSet%5BA%5D,A&quot;&gt;excl（）&lt;/a&gt; proc 的区别在于，如果&lt;em&gt;s&lt;/em&gt;中不存在&lt;em&gt;key&lt;/em&gt;，则此proc返回&lt;em&gt;true&lt;/em&gt;。例：&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d1de829e0ca997f038aa2fbccf312c02165e0cb7" translate="yes" xml:space="preserve">
          <source>The difference with regards to the &lt;a href=&quot;#excl,TSet%5BA%5D,A&quot;&gt;excl()&lt;/a&gt; proc is that this proc returns &lt;em&gt;true&lt;/em&gt; if &lt;em&gt;key&lt;/em&gt; was not present in &lt;em&gt;s&lt;/em&gt;. Example:</source>
          <target state="translated">关于&lt;a href=&quot;#excl,TSet%5BA%5D,A&quot;&gt;excl（）&lt;/a&gt; proc 的区别在于，如果&lt;em&gt;s&lt;/em&gt;中不存在&lt;em&gt;key&lt;/em&gt;，则此proc返回&lt;em&gt;true&lt;/em&gt;。例：&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a71957eb2547d4bfa9f2683522934ebe61aa6db3" translate="yes" xml:space="preserve">
          <source>The difference with regards to the &lt;a href=&quot;#incl,HashSet%5BA%5D,A&quot;&gt;incl proc&lt;/a&gt; is that this proc returns &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;s&lt;/code&gt; already contained &lt;code&gt;key&lt;/code&gt;. The proc will return &lt;code&gt;false&lt;/code&gt; if &lt;code&gt;key&lt;/code&gt; was added as a new value to &lt;code&gt;s&lt;/code&gt; during this call.</source>
          <target state="translated">关于&lt;a href=&quot;#incl,HashSet%5BA%5D,A&quot;&gt;incl proc&lt;/a&gt;的区别在于，如果 &lt;code&gt;s&lt;/code&gt; 已经包含 &lt;code&gt;key&lt;/code&gt; ，则此proc返回 &lt;code&gt;true&lt;/code&gt; 。如果在此调用期间将 &lt;code&gt;key&lt;/code&gt; 作为新值添加到 &lt;code&gt;s&lt;/code&gt; ，则proc将返回 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="38fff35f03a020121f5216e964c1f14d3d44390d" translate="yes" xml:space="preserve">
          <source>The difference with regards to the &lt;a href=&quot;#incl,IntSet,int&quot;&gt;incl proc&lt;/a&gt; is that this proc returns &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;s&lt;/code&gt; already contained &lt;code&gt;key&lt;/code&gt;. The proc will return &lt;code&gt;false&lt;/code&gt; if &lt;code&gt;key&lt;/code&gt; was added as a new value to &lt;code&gt;s&lt;/code&gt; during this call.</source>
          <target state="translated">关于&lt;a href=&quot;#incl,IntSet,int&quot;&gt;incl proc&lt;/a&gt;的区别在于，如果 &lt;code&gt;s&lt;/code&gt; 已经包含 &lt;code&gt;key&lt;/code&gt; ，则此proc返回 &lt;code&gt;true&lt;/code&gt; 。如果在此调用期间将 &lt;code&gt;key&lt;/code&gt; 作为新值添加到 &lt;code&gt;s&lt;/code&gt; ，则proc将返回 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="773605a369d8054b7c253cee632444088b29e946" translate="yes" xml:space="preserve">
          <source>The difference with regards to the &lt;a href=&quot;#incl,OrderedSet%5BA%5D,A&quot;&gt;incl proc&lt;/a&gt; is that this proc returns &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;s&lt;/code&gt; already contained &lt;code&gt;key&lt;/code&gt;. The proc will return false if &lt;code&gt;key&lt;/code&gt; was added as a new value to &lt;code&gt;s&lt;/code&gt; during this call.</source>
          <target state="translated">关于&lt;a href=&quot;#incl,OrderedSet%5BA%5D,A&quot;&gt;incl proc&lt;/a&gt;的区别在于，如果 &lt;code&gt;s&lt;/code&gt; 已经包含 &lt;code&gt;key&lt;/code&gt; ，则此proc返回 &lt;code&gt;true&lt;/code&gt; 。如果在此调用期间将 &lt;code&gt;key&lt;/code&gt; 作为新值添加到 &lt;code&gt;s&lt;/code&gt; ，则proc将返回false 。</target>
        </trans-unit>
        <trans-unit id="18b21997787778562d6aa4adbaf236a4acd894b9" translate="yes" xml:space="preserve">
          <source>The difference with regards to the &lt;a href=&quot;#incl,TOrderedSet%5BA%5D,A&quot;&gt;incl()&lt;/a&gt; proc is that this proc returns &lt;em&gt;true&lt;/em&gt; if &lt;em&gt;key&lt;/em&gt; was already present in &lt;em&gt;s&lt;/em&gt;. The proc will return false if &lt;em&gt;key&lt;/em&gt; was added as a new value to &lt;em&gt;s&lt;/em&gt; during this call. Example:</source>
          <target state="translated">关于&lt;a href=&quot;#incl,TOrderedSet%5BA%5D,A&quot;&gt;incl（）&lt;/a&gt; proc 的区别是，如果&lt;em&gt;s&lt;/em&gt;中已经存在&lt;em&gt;key&lt;/em&gt;，则此proc返回&lt;em&gt;true&lt;/em&gt;。如果在此调用期间将&lt;em&gt;key&lt;/em&gt;作为新值添加到&lt;em&gt;s&lt;/em&gt;，则proc将返回false 。例：&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9b85f52a313da4c653da005f49f49e563663ab9e" translate="yes" xml:space="preserve">
          <source>The difference with regards to the &lt;a href=&quot;#incl,TSet%5BA%5D,A&quot;&gt;incl()&lt;/a&gt; proc is that this proc returns &lt;em&gt;true&lt;/em&gt; if &lt;em&gt;key&lt;/em&gt; was already present in &lt;em&gt;s&lt;/em&gt;. The proc will return false if &lt;em&gt;key&lt;/em&gt; was added as a new value to &lt;em&gt;s&lt;/em&gt; during this call. Example:</source>
          <target state="translated">关于&lt;a href=&quot;#incl,TSet%5BA%5D,A&quot;&gt;incl（）&lt;/a&gt; proc 的区别是，如果&lt;em&gt;s&lt;/em&gt;中已经存在&lt;em&gt;key&lt;/em&gt;，则此proc返回&lt;em&gt;true&lt;/em&gt;。如果在此调用期间将&lt;em&gt;key&lt;/em&gt;作为新值添加到&lt;em&gt;s&lt;/em&gt;，则proc将返回false 。例：&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="220030e8b435e84f93ba209fa1bb4177a255c969" translate="yes" xml:space="preserve">
          <source>The different format patterns that are supported are documented below.</source>
          <target state="translated">支持的不同格式模式记录如下。</target>
        </trans-unit>
        <trans-unit id="d7d6c6dc11f53e07d9cdc8acaebc2671f78a141c" translate="yes" xml:space="preserve">
          <source>The direct embedding of assembler code into Nim code is supported by the unsafe &lt;code&gt;asm&lt;/code&gt; statement. Identifiers in the assembler code that refer to Nim identifiers shall be enclosed in a special character which can be specified in the statement's pragmas. The default special character is &lt;code&gt;'`'&lt;/code&gt;:</source>
          <target state="translated">不安全的 &lt;code&gt;asm&lt;/code&gt; 语句支持将汇编程序代码直接嵌入到Nim代码中。汇编程序代码中引用Nim标识符的标识符必须用特殊字符括起来，该特殊字符可以在语句的编译指示中指定。默认的特殊字符是 &lt;code&gt;'`'&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="0c22272ea471a90f449580f65ef97314fc75ce82" translate="yes" xml:space="preserve">
          <source>The directory may contain several subdirectories that do not exist yet. The full path is created. If this fails, &lt;code&gt;OSError&lt;/code&gt; is raised.</source>
          <target state="translated">该目录可能包含几个尚不存在的子目录。完整路径已创建。如果失败，则引发 &lt;code&gt;OSError&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="79c14e4edc4e62d3b50ec111744e90c76fe6415b" translate="yes" xml:space="preserve">
          <source>The directory may contain several subdirectories that do not exist yet. The full path is created. If this fails, &lt;em&gt;OSError&lt;/em&gt; is raised. It does &lt;strong&gt;not&lt;/strong&gt; fail if the directory already exists because for most usages this does not indicate an error.</source>
          <target state="translated">该目录可能包含几个尚不存在的子目录。完整路径已创建。如果失败，则引发&lt;em&gt;OSError&lt;/em&gt;。它并&lt;strong&gt;没有&lt;/strong&gt;，如果该目录已经存在，因为大多数情况的使用，这并不表示错误失败。</target>
        </trans-unit>
        <trans-unit id="3d9c316616578336f1d520853682d58bf4e6eb88" translate="yes" xml:space="preserve">
          <source>The dispatcher acts as a kind of event loop. You must call &lt;code&gt;poll&lt;/code&gt; on it (or a function which does so for you such as &lt;code&gt;waitFor&lt;/code&gt; or &lt;code&gt;runForever&lt;/code&gt;) in order to poll for any outstanding events. The underlying implementation is based on epoll on Linux, IO Completion Ports on Windows and select on other operating systems.</source>
          <target state="translated">调度程序充当一种事件循环。您必须对它调用 &lt;code&gt;poll&lt;/code&gt; （或为您调用poll的函数，例如 &lt;code&gt;waitFor&lt;/code&gt; 或 &lt;code&gt;runForever&lt;/code&gt; ）才能轮询任何未完成的事件。基础实现基于Linux上的epoll，Windows上的IO完成端口以及其他操作系统上的select。</target>
        </trans-unit>
        <trans-unit id="2fe9a5fd03163afe0a124e1e905c51d6abb0bdfb" translate="yes" xml:space="preserve">
          <source>The distance in amount of elements that the data should be rotated. Can be negative, can be any number.</source>
          <target state="translated">数据应该旋转的元素数量的距离。可以是负数,可以是任何数字。</target>
        </trans-unit>
        <trans-unit id="ad786784a7a091bc39b8e45514e333722de53121" translate="yes" xml:space="preserve">
          <source>The documentation consists of several documents:</source>
          <target state="translated">该文件由若干文件组成。</target>
        </trans-unit>
        <trans-unit id="160bf45ca85f5c6209e555ecebe6d41157683d3c" translate="yes" xml:space="preserve">
          <source>The documentation generator is aware of these examples and considers them part of the &lt;code&gt;##&lt;/code&gt; doc comment. As the last step of documentation generation each runnableExample is put in its own file &lt;code&gt;$file_examples$i.nim&lt;/code&gt;, compiled and tested. The collected examples are put into their own module to ensure the examples do not refer to non-exported symbols.</source>
          <target state="translated">文档生成器知道这些示例，并将其视为 &lt;code&gt;##&lt;/code&gt; doc注释的一部分。作为文档生成的最后一步，每个runnableExample放入其自己的文件 &lt;code&gt;$file_examples$i.nim&lt;/code&gt; ，进行编译和测试。收集的示例将放入其自己的模块中，以确保示例不引用未导出的符号。</target>
        </trans-unit>
        <trans-unit id="37bdec1f204951850d37528255d2ee12a6d8560b" translate="yes" xml:space="preserve">
          <source>The documentation generator is aware of these examples and considers them part of the &lt;code&gt;##&lt;/code&gt; doc comment. As the last step of documentation generation the examples are put into an &lt;code&gt;$file_example.nim&lt;/code&gt; file, compiled and tested. The collected examples are put into their own module to ensure the examples do not refer to non-exported symbols.</source>
          <target state="translated">文档生成器了解这些示例，并将其视为 &lt;code&gt;##&lt;/code&gt; doc注释的一部分。作为生成文档的最后一步，将示例放入 &lt;code&gt;$file_example.nim&lt;/code&gt; 文件中，进行编译和测试。收集的示例将放入其自己的模块中，以确保示例不引用未导出的符号。</target>
        </trans-unit>
        <trans-unit id="1d6f51cc7af628cca8e6d65688dcf5a3aea1a258" translate="yes" xml:space="preserve">
          <source>The effect system (&lt;code&gt;raises: []&lt;/code&gt;) does not work with async procedures.</source>
          <target state="translated">效果系统（ &lt;code&gt;raises: []&lt;/code&gt; ）不适用于异步过程。</target>
        </trans-unit>
        <trans-unit id="1bcfc8f90f78962fe572628e18093e7b6be852bf" translate="yes" xml:space="preserve">
          <source>The element at index &lt;code&gt;slice.a + dist - 1&lt;/code&gt; will be at &lt;code&gt;slice.b&lt;/code&gt;.</source>
          <target state="translated">索引 &lt;code&gt;slice.a + dist - 1&lt;/code&gt; 处的元素将位于 &lt;code&gt;slice.b&lt;/code&gt; 处。</target>
        </trans-unit>
        <trans-unit id="897357254109912a2abd5ead8a14e0dc57992f7f" translate="yes" xml:space="preserve">
          <source>The element at index &lt;code&gt;slice.a + dist&lt;/code&gt; will be at index &lt;code&gt;slice.a&lt;/code&gt;.</source>
          <target state="translated">位于index &lt;code&gt;slice.a + dist&lt;/code&gt; 处的元素将位于index &lt;code&gt;slice.a&lt;/code&gt; 处。</target>
        </trans-unit>
        <trans-unit id="670537769ac6c87d8dae3f8f255038a616b07e05" translate="yes" xml:space="preserve">
          <source>The element at index &lt;code&gt;slice.a&lt;/code&gt; will be at &lt;code&gt;slice.b + 1 - dist&lt;/code&gt;.</source>
          <target state="translated">索引 &lt;code&gt;slice.a&lt;/code&gt; 处的元素将位于 &lt;code&gt;slice.b + 1 - dist&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b68a5f4232d630fa057b4a20b989568ebd93ae53" translate="yes" xml:space="preserve">
          <source>The element at index &lt;code&gt;slice.b&lt;/code&gt; will be at &lt;code&gt;slice.a + dist -1&lt;/code&gt;.</source>
          <target state="translated">索引 &lt;code&gt;slice.b&lt;/code&gt; 处的元素将位于 &lt;code&gt;slice.a + dist -1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="aded9e6b8b6079e27b489e1f2a3fd8422a03e391" translate="yes" xml:space="preserve">
          <source>The employed static analysis is limited and only concerned with local variables; however, object and tuple fields are treated as separate entities:</source>
          <target state="translated">所采用的静态分析是有限的,只涉及局部变量;然而,对象和元组字段被作为单独的实体处理。</target>
        </trans-unit>
        <trans-unit id="c5c6ad0fa17f28cab354438579a552a5a86576fc" translate="yes" xml:space="preserve">
          <source>The empty &lt;a href=&quot;#procedures-discard-statement&quot;&gt;discard statement&lt;/a&gt; is a &lt;em&gt;do nothing&lt;/em&gt; statement. The compiler knows that a case statement with an else part cannot fail and thus the error disappears. Note that it is impossible to cover all possible string values: that is why string cases always need an &lt;code&gt;else&lt;/code&gt; branch.</source>
          <target state="translated">空的&lt;a href=&quot;#procedures-discard-statement&quot;&gt;废弃语句&lt;/a&gt;是&amp;ldquo; &lt;em&gt;不执行&amp;rdquo;&lt;/em&gt;语句。编译器知道带有else部分的case语句不会失败，因此错误消失了。注意，不可能覆盖所有可能的字符串值：这就是为什么字符串大小写总是需要 &lt;code&gt;else&lt;/code&gt; 分支的原因。</target>
        </trans-unit>
        <trans-unit id="b0d537489684ccaa630656ec96401b6693a6022d" translate="yes" xml:space="preserve">
          <source>The empty &lt;code&gt;[]&lt;/code&gt; subscript notation can be used to &lt;em&gt;derefer&lt;/em&gt; a reference, meaning to retrieve the item the reference points to. The &lt;code&gt;.&lt;/code&gt; (access a tuple/object field operator) and &lt;code&gt;[]&lt;/code&gt; (array/string/sequence index operator) operators perform implicit dereferencing operations for reference types:</source>
          <target state="translated">空的 &lt;code&gt;[]&lt;/code&gt; 下标符号可用于&lt;em&gt;取消&lt;/em&gt;引用参考，表示检索引用指向的项目。的 &lt;code&gt;.&lt;/code&gt; （访问元组/对象字段运算符）和 &lt;code&gt;[]&lt;/code&gt; （数组/字符串/序列索引运算符）运算符对引用类型执行隐式解引用操作：</target>
        </trans-unit>
        <trans-unit id="ffc8ff3a5600abff18d1541feff45aa3dbf706b3" translate="yes" xml:space="preserve">
          <source>The empty &lt;code&gt;except&lt;/code&gt; part is executed if there is an exception that is not explicitly listed. It is similar to an &lt;code&gt;else&lt;/code&gt; part in &lt;code&gt;if&lt;/code&gt; statements.</source>
          <target state="translated">如果存在未明确列出的异常，则将执行空的 &lt;code&gt;except&lt;/code&gt; 部分。它类似于 &lt;code&gt;if&lt;/code&gt; 语句中的 &lt;code&gt;else&lt;/code&gt; 部分。</target>
        </trans-unit>
        <trans-unit id="65c91587bac500ac8c7817439d895663e0f5eef7" translate="yes" xml:space="preserve">
          <source>The empty &lt;span id=&quot;except_1&quot;&gt;except&lt;/span&gt; clause is executed if there is an exception that is not listed otherwise. It is similar to an &lt;code&gt;else&lt;/code&gt; clause in &lt;code&gt;if&lt;/code&gt; statements.</source>
          <target state="translated">如果存在例外（否则未列出），则执行空的&lt;span id=&quot;except_1&quot;&gt;except&lt;/span&gt;子句。它类似于 &lt;code&gt;if&lt;/code&gt; 语句中的 &lt;code&gt;else&lt;/code&gt; 子句。</target>
        </trans-unit>
        <trans-unit id="0c1d4d209aa8e17c99e2eb2160eabae179a2322b" translate="yes" xml:space="preserve">
          <source>The empty table can be written &lt;code&gt;{:}&lt;/code&gt; (in contrast to the empty set which is &lt;code&gt;{}&lt;/code&gt;) which is thus another way to write as the empty array constructor &lt;code&gt;[]&lt;/code&gt;. This slightly unusual way of supporting tables has lots of advantages:</source>
          <target state="translated">空表可以写成 &lt;code&gt;{:}&lt;/code&gt; （与空集 &lt;code&gt;{}&lt;/code&gt; 相比），这是写成空数组构造函数 &lt;code&gt;[]&lt;/code&gt; 的另一种方式。这种稍微不寻常的表支持方式有很多优点：</target>
        </trans-unit>
        <trans-unit id="530e09898cb17b92f8f440dddf479da4d55cb727" translate="yes" xml:space="preserve">
          <source>The endianness of the target CPU. This is a valuable piece of information for low-level code only. This works thanks to compiler magic.</source>
          <target state="translated">目标CPU的endianness。这是一个有价值的信息,只适用于低级代码。这要归功于编译器的魔法。</target>
        </trans-unit>
        <trans-unit id="b0113abbcfc987b657ff5c91825dbc9c2097913c" translate="yes" xml:space="preserve">
          <source>The error code can be retrieved using the &lt;a href=&quot;#osLastError&quot;&gt;osLastError proc&lt;/a&gt;.</source>
          <target state="translated">可以使用&lt;a href=&quot;#osLastError&quot;&gt;osLastError proc&lt;/a&gt;检索错误代码。</target>
        </trans-unit>
        <trans-unit id="64a046b2305ba9ca93a6dc63513571f740cfbd0a" translate="yes" xml:space="preserve">
          <source>The error function</source>
          <target state="translated">错误函数</target>
        </trans-unit>
        <trans-unit id="07d3a0d65c780c53b944c8f6088eecf4c5ac94f3" translate="yes" xml:space="preserve">
          <source>The example also shows that a proc's body can consist of a single expression whose value is then returned implicitly.</source>
          <target state="translated">这个例子还表明,proc的主体可以由一个表达式组成,然后隐式返回其值。</target>
        </trans-unit>
        <trans-unit id="1ee7135c60a97c9109575a0365bdcd4548a56a80" translate="yes" xml:space="preserve">
          <source>The example is silly, since a vector is better modelled by a tuple which already provides &lt;code&gt;v[]&lt;/code&gt; access.</source>
          <target state="translated">这个例子很愚蠢，因为向量已经由提供 &lt;code&gt;v[]&lt;/code&gt; 访问的元组更好地建模了。</target>
        </trans-unit>
        <trans-unit id="5c91aee76f225823a200aa2713bba977502db3e5" translate="yes" xml:space="preserve">
          <source>The example shows a generic binary tree. Depending on context, the brackets are used either to introduce type parameters or to instantiate a generic proc, iterator or type. As the example shows, generics work with overloading: the best match of &lt;code&gt;add&lt;/code&gt; is used. The built-in &lt;code&gt;add&lt;/code&gt; procedure for sequences is not hidden and is used in the &lt;code&gt;preorder&lt;/code&gt; iterator.</source>
          <target state="translated">该示例显示了通用的二叉树。根据上下文，方括号用于引入类型参数或实例化通用proc，迭代器或类型。如示例所示，泛型可用于重载：使用 &lt;code&gt;add&lt;/code&gt; 的最佳匹配。序列的内置 &lt;code&gt;add&lt;/code&gt; 过程未隐藏，而是在 &lt;code&gt;preorder&lt;/code&gt; 迭代器中使用。</target>
        </trans-unit>
        <trans-unit id="f68d69ad3fae0ae0b097e4eebbbc1987f9438cae" translate="yes" xml:space="preserve">
          <source>The example uses a while loop to keep asking the users for their name, as long as the user types in nothing (only presses RETURN).</source>
          <target state="translated">这个例子使用了一个 while 循环,只要用户不输入任何内容(只按 RETURN),就会一直询问用户的名字。</target>
        </trans-unit>
        <trans-unit id="9e69f04e6b758773caa47fda144764cd2b769f26" translate="yes" xml:space="preserve">
          <source>The exception is &lt;em&gt;consumed&lt;/em&gt; in an &lt;code&gt;except&lt;/code&gt; part. If an exception is not handled, it is propagated through the call stack. This means that often the rest of the procedure - that is not within a &lt;code&gt;finally&lt;/code&gt; clause - is not executed (if an exception occurs).</source>
          <target state="translated">唯一的例外是&lt;em&gt;消耗&lt;/em&gt;在 &lt;code&gt;except&lt;/code&gt; 部分。如果未处理异常，它将通过调用堆栈传播。这意味着通常不会执行过程的其余部分（不在 &lt;code&gt;finally&lt;/code&gt; 子句中）（如果发生异常）。</target>
        </trans-unit>
        <trans-unit id="ff3ed48d6f7129871b8222e272bcbad9f0531ac9" translate="yes" xml:space="preserve">
          <source>The exception is &lt;em&gt;consumed&lt;/em&gt; in an exception handler. However, an exception handler may raise another exception. If the exception is not handled, it is propagated through the call stack. This means that often the rest of the procedure - that is not within a &lt;code&gt;finally&lt;/code&gt; clause - is not executed (if an exception occurs).</source>
          <target state="translated">唯一的例外是&lt;em&gt;消耗&lt;/em&gt;在异常处理。但是，异常处理程序可能会引发另一个异常。如果未处理该异常，它将通过调用堆栈传播。这意味着通常不会执行过程的其余部分（不在 &lt;code&gt;finally&lt;/code&gt; 子句中）（如果发生异常）。</target>
        </trans-unit>
        <trans-unit id="c1d798ae9282ab3c90cac1e64ce5600a12ced505" translate="yes" xml:space="preserve">
          <source>The exception tracking is part of Nim's &lt;span id=&quot;effect-system_1&quot;&gt;effect system&lt;/span&gt;. Raising an exception is an &lt;em&gt;effect&lt;/em&gt;. Other effects can also be defined. A user defined effect is a means to &lt;em&gt;tag&lt;/em&gt; a routine and to perform checks against this tag:</source>
          <target state="translated">异常跟踪是Nim &lt;span id=&quot;effect-system_1&quot;&gt;效果系统的一部分&lt;/span&gt;。引发例外是一种&lt;em&gt;效果&lt;/em&gt;。也可以定义其他效果。用户定义的效果是一种&lt;em&gt;标记&lt;/em&gt;例程并对该标记执行检查的方法：</target>
        </trans-unit>
        <trans-unit id="f4d218a789a1df54f173c0ece34a43f3b86bc503" translate="yes" xml:space="preserve">
          <source>The exception tree is defined in the &lt;a href=&quot;system&quot;&gt;system&lt;/a&gt; module. Every exception inherits from &lt;code&gt;system.Exception&lt;/code&gt;. Exceptions that indicate programming bugs inherit from &lt;code&gt;system.Defect&lt;/code&gt; (which is a subtype of &lt;code&gt;Exception&lt;/code&gt;) and are stricly speaking not catchable as they can also be mapped to an operation that terminates the whole process. Exceptions that indicate any other runtime error that can be caught inherit from &lt;code&gt;system.CatchableError&lt;/code&gt; (which is a subtype of &lt;code&gt;Exception&lt;/code&gt;).</source>
          <target state="translated">异常树在&lt;a href=&quot;system&quot;&gt;系统&lt;/a&gt;模块中定义。每个异常都从 &lt;code&gt;system.Exception&lt;/code&gt; 继承。指示编程错误的异常继承自 &lt;code&gt;system.Defect&lt;/code&gt; （这是 &lt;code&gt;Exception&lt;/code&gt; 的子类型），并且严格来讲不能捕获，因为它们也可以映射到终止整个过程的操作。指示可以捕获的任何其他运行时错误的 &lt;code&gt;Exception&lt;/code&gt; 将从 &lt;code&gt;system.CatchableError&lt;/code&gt; （这是Exception的子类型）继承。</target>
        </trans-unit>
        <trans-unit id="f15c73f143df8ff81817805b3e6f84eb0426975c" translate="yes" xml:space="preserve">
          <source>The exception tree is defined in the &lt;a href=&quot;system&quot;&gt;system&lt;/a&gt; module. Every exception inherits from &lt;code&gt;system.Exception&lt;/code&gt;. Exceptions that indicate programming bugs inherit from &lt;code&gt;system.Defect&lt;/code&gt; (which is a subtype of &lt;code&gt;Exception&lt;/code&gt;) and are strictly speaking not catchable as they can also be mapped to an operation that terminates the whole process. If panics are turned into exceptions, these exceptions inherit from &lt;code&gt;Defect&lt;/code&gt;.</source>
          <target state="translated">异常树在&lt;a href=&quot;system&quot;&gt;系统&lt;/a&gt;模块中定义。每个异常都继承自 &lt;code&gt;system.Exception&lt;/code&gt; 。表示编程错误的异常继承自 &lt;code&gt;system.Defect&lt;/code&gt; （这是 &lt;code&gt;Exception&lt;/code&gt; 的子类型），严格来讲是无法捕获的，因为它们也可以映射到终止整个过程的操作。如果将恐慌化为异常，则这些异常将从 &lt;code&gt;Defect&lt;/code&gt; 继承。</target>
        </trans-unit>
        <trans-unit id="c146fcf11a72b2f53363e7dce3057eecf8d03ff2" translate="yes" xml:space="preserve">
          <source>The expected stdlib location is /usr/lib/nim</source>
          <target state="translated">预期的stdlib位置是/usr/lib/nim。</target>
        </trans-unit>
        <trans-unit id="aca7c3dc848479331fda2f9d22be2cc3a93d781c" translate="yes" xml:space="preserve">
          <source>The experimental &lt;span id=&quot;nodestroy_1&quot;&gt;nodestroy&lt;/span&gt; pragma inhibits hook injections. This can be used to specialize the object traversal in order to avoid deep recursions:</source>
          <target state="translated">实验性&lt;span id=&quot;nodestroy_1&quot;&gt;结节杂物&lt;/span&gt;抑制钩子注射。这可用于专门化对象遍历，以避免深度递归：</target>
        </trans-unit>
        <trans-unit id="8eb9fe59b5acee224134869a4fa8ee343bb10bba" translate="yes" xml:space="preserve">
          <source>The expression &lt;code&gt;x&lt;/code&gt; in &lt;code&gt;x.f&lt;/code&gt; needs to be semantically checked (that means symbol lookup and type checking) before it can be decided that it needs to be rewritten to &lt;code&gt;f(x)&lt;/code&gt;. Therefore the dot syntax has some limitations when it is used to invoke templates/macros:</source>
          <target state="translated">表达式 &lt;code&gt;x&lt;/code&gt; 在 &lt;code&gt;x.f&lt;/code&gt; 需要被检查语义（即手段符号查找和类型检查）之前，可以决定它需要被重写为 &lt;code&gt;f(x)&lt;/code&gt; 。因此，点语法在用于调用模板/宏时会受到一些限制：</target>
        </trans-unit>
        <trans-unit id="3c2dc4422e351229d30e8efd52e83f860015cd51" translate="yes" xml:space="preserve">
          <source>The extended means that comments starting with &lt;code&gt;#&lt;/code&gt; and whitespace are ignored.</source>
          <target state="translated">扩展意味着将忽略以 &lt;code&gt;#&lt;/code&gt; 和空格开头的注释。</target>
        </trans-unit>
        <trans-unit id="5d1f3451fa30a273a7f6aed76323af4d8616546f" translate="yes" xml:space="preserve">
          <source>The extended means that comments starting with &lt;em&gt;#&lt;/em&gt; and whitespace are ignored.</source>
          <target state="translated">扩展意味着将忽略以&lt;em&gt;＃&lt;/em&gt;和空格开头的注释。</target>
        </trans-unit>
        <trans-unit id="8c41536248444b965e36bdfac662bfb214beac07" translate="yes" xml:space="preserve">
          <source>The factory &lt;code&gt;proc&lt;/code&gt;, as an ordinary procedure, can be recursive. The above macro allows such recursion to look much like a recursive iterator would. For example:</source>
          <target state="translated">作为普通过程，工厂 &lt;code&gt;proc&lt;/code&gt; 可以是递归的。上面的宏允许这种递归看起来很像递归迭代器。例如：</target>
        </trans-unit>
        <trans-unit id="12b4cab5727b122b7b1ec87cba8d2831f9aab5a6" translate="yes" xml:space="preserve">
          <source>The field identifiers inside a tuple or object definition are valid in the following places:</source>
          <target state="translated">元组或对象定义中的字段标识符在以下地方有效。</target>
        </trans-unit>
        <trans-unit id="dd916f7a49d8a7ac10551fea591882cb2dbe45da" translate="yes" xml:space="preserve">
          <source>The file &lt;code&gt;examples/htmlrefs.nim&lt;/code&gt; demonstrates how to use the XML parser to accomplish another simple task: To determine all the links an HTML document contains.</source>
          <target state="translated">文件 &lt;code&gt;examples/htmlrefs.nim&lt;/code&gt; 演示了如何使用XML解析器完成另一个简单的任务：确定HTML文档包含的所有链接。</target>
        </trans-unit>
        <trans-unit id="20888f5db03e3bbd07212160a3014e7495057d4b" translate="yes" xml:space="preserve">
          <source>The file &lt;code&gt;examples/htmltitle.nim&lt;/code&gt; demonstrates how to use the XML parser to accomplish a simple task: To determine the title of an HTML document.</source>
          <target state="translated">文件 &lt;code&gt;examples/htmltitle.nim&lt;/code&gt; 演示了如何使用XML解析器来完成一个简单的任务：确定HTML文档的标题。</target>
        </trans-unit>
        <trans-unit id="787b89eaa57a97560754c43aa4b06898c7b48aec" translate="yes" xml:space="preserve">
          <source>The file extension of a script file. For example: &quot;&quot; for POSIX, &quot;bat&quot; on Windows.</source>
          <target state="translated">脚本文件的文件扩展名。例如:POSIX的&quot;&quot;,Windows的 &quot;bat&quot;。&quot;&quot;代表POSIX,&quot;bat &quot;代表Windows。</target>
        </trans-unit>
        <trans-unit id="bd4b48d3252daafd834db9d87104d9a48291a53c" translate="yes" xml:space="preserve">
          <source>The file extension of a script file. For example: &lt;code&gt;&quot;&quot;&lt;/code&gt; for POSIX, &lt;code&gt;&quot;bat&quot;&lt;/code&gt; on Windows.</source>
          <target state="translated">脚本文件的文件扩展名。例如： &lt;code&gt;&quot;&quot;&lt;/code&gt; 用于POSIX，在Windows上为 &lt;code&gt;&quot;bat&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8875b78032e0936292139b8d9ad9a639776438c6" translate="yes" xml:space="preserve">
          <source>The file extension of native executables. For example: &quot;&quot; for POSIX, &quot;exe&quot; on Windows.</source>
          <target state="translated">本机可执行文件的文件扩展名。例如,POSIX的&quot;&quot;,Windows的 &quot;exe&quot;。POSIX的&quot;&quot;,Windows的 &quot;exe&quot;。</target>
        </trans-unit>
        <trans-unit id="3bcdd9264e0657c8e586f2111814ceedf968b16d" translate="yes" xml:space="preserve">
          <source>The file extension of native executables. For example: &lt;code&gt;&quot;&quot;&lt;/code&gt; for POSIX, &lt;code&gt;&quot;exe&quot;&lt;/code&gt; on Windows (without a dot).</source>
          <target state="translated">本机可执行文件的文件扩展名。例如： &lt;code&gt;&quot;&quot;&lt;/code&gt; 为POSIX， &lt;code&gt;&quot;exe&quot;&lt;/code&gt; 在Windows（没有点）。</target>
        </trans-unit>
        <trans-unit id="7d4d66cbed56a81621a70d0c80cfeafaeea567fd" translate="yes" xml:space="preserve">
          <source>The file handle associated with &lt;code&gt;f&lt;/code&gt; won't be inheritable.</source>
          <target state="translated">与 &lt;code&gt;f&lt;/code&gt; 关联的文件句柄将不可继承。</target>
        </trans-unit>
        <trans-unit id="185628c3622bd8c0f63cb10b192be0d0211b8807" translate="yes" xml:space="preserve">
          <source>The file handle associated with the resulting &lt;code&gt;File&lt;/code&gt; is not inheritable.</source>
          <target state="translated">与结果 &lt;code&gt;File&lt;/code&gt; 关联的文件句柄不可继承。</target>
        </trans-unit>
        <trans-unit id="aa1522384259bb7f728de722e2a3a3b90755fa75" translate="yes" xml:space="preserve">
          <source>The file mode when opening a file.</source>
          <target state="translated">打开文件时的文件模式。</target>
        </trans-unit>
        <trans-unit id="b0d5634247976656f5fce2a230b840835d3dfc38" translate="yes" xml:space="preserve">
          <source>The file you want to perform the query on. Usually you will pass in the same value as &lt;strong&gt;proj.nim&lt;/strong&gt;.</source>
          <target state="translated">您要对其执行查询的文件。通常，您将传递与&lt;strong&gt;proj.nim&lt;/strong&gt;相同的值。</target>
        </trans-unit>
        <trans-unit id="d49d4484596c8b0e0159eb69ef8f9c586d3b72f8" translate="yes" xml:space="preserve">
          <source>The filter transforms this into:</source>
          <target state="translated">滤波器将其转化为。</target>
        </trans-unit>
        <trans-unit id="ca2479d6b8b610f51a5a98ec6a8fac67b9578c0a" translate="yes" xml:space="preserve">
          <source>The final layer is the async await transformation. This allows you to write asynchronous code in a synchronous style and works similar to C#'s await. The transformation works by converting any async procedures into an iterator.</source>
          <target state="translated">最后一层是async await转换。这允许你以同步的风格编写异步代码,其工作原理类似于C#的 await。该转换通过将任何异步过程转换为迭代器来工作。</target>
        </trans-unit>
        <trans-unit id="92e24af529f18eee0612283d52e69f9a932a8269" translate="yes" xml:space="preserve">
          <source>The first command runs the Nim compiler with three special options to avoid generating a &lt;code&gt;main()&lt;/code&gt; function in the generated files, avoid linking the object files into a final binary, and explicitly generate a header file for C integration. All the generated files are placed into the &lt;code&gt;nimcache&lt;/code&gt; directory. That's why the next command compiles the &lt;code&gt;maths.c&lt;/code&gt; source plus all the &lt;code&gt;.c&lt;/code&gt; files form &lt;code&gt;nimcache&lt;/code&gt;. In addition to this path, you also have to tell the C compiler where to find Nim's &lt;code&gt;nimbase.h&lt;/code&gt; header file.</source>
          <target state="translated">第一个命令使用三个特殊选项运行Nim编译器，以避免在生成的文件中生成 &lt;code&gt;main()&lt;/code&gt; 函数，避免将目标文件链接到最终二进制文件中，并显式生成用于C集成的头文件。所有生成的文件都放置在 &lt;code&gt;nimcache&lt;/code&gt; 目录中。这就是为什么下 &lt;code&gt;maths.c&lt;/code&gt; 命令会编译maths.c源代码以及所有 &lt;code&gt;.c&lt;/code&gt; 文件形式 &lt;code&gt;nimcache&lt;/code&gt; 的原因。除了此路径外，您还必须告诉C编译器在哪里可以找到Nim的 &lt;code&gt;nimbase.h&lt;/code&gt; 头文件。</target>
        </trans-unit>
        <trans-unit id="341e06b43aea4d82833edd740a767d94b3ccabcf" translate="yes" xml:space="preserve">
          <source>The first command runs the Nim compiler with three special options to avoid generating a &lt;code&gt;main()&lt;/code&gt; function in the generated files, avoid linking the object files into a final binary, and explicitly generate a header file for C integration. All the generated files are placed into the &lt;code&gt;nimcache&lt;/code&gt; directory. That's why the next command compiles the &lt;code&gt;maths.c&lt;/code&gt; source plus all the &lt;code&gt;.c&lt;/code&gt; files from &lt;code&gt;nimcache&lt;/code&gt;. In addition to this path, you also have to tell the C compiler where to find Nim's &lt;code&gt;nimbase.h&lt;/code&gt; header file.</source>
          <target state="translated">第一条命令使用三个特殊选项运行Nim编译器，以避免在生成的文件中生成 &lt;code&gt;main()&lt;/code&gt; 函数，避免将目标文件链接到最终二进制文件中，并显式生成用于C集成的头文件。所有生成的文件都放置在 &lt;code&gt;nimcache&lt;/code&gt; 目录中。这就是为什么下 &lt;code&gt;maths.c&lt;/code&gt; 命令会编译maths.c源代码以及nimcache中的所有 &lt;code&gt;.c&lt;/code&gt; 文件的 &lt;code&gt;nimcache&lt;/code&gt; 。除了此路径外，您还必须告诉C编译器在哪里可以找到Nim的 &lt;code&gt;nimbase.h&lt;/code&gt; 头文件。</target>
        </trans-unit>
        <trans-unit id="2e1aabe2958ba075f566d5962b4d499e691da35a" translate="yes" xml:space="preserve">
          <source>The first line indicates the main project file.</source>
          <target state="translated">第一行表示主项目文件。</target>
        </trans-unit>
        <trans-unit id="1e2c5da607ae89a09ea180cc662ffe2d3288f940" translate="yes" xml:space="preserve">
          <source>The first one is to treat Android as a simple Linux and use &lt;a href=&quot;https://wiki.termux.com&quot;&gt;Termux&lt;/a&gt; to connect and run the Nim compiler directly on android as if it was Linux. These programs are console-only programs that can't be distributed in the Play Store.</source>
          <target state="translated">第一个方法是将Android视为简单的Linux，并使用&lt;a href=&quot;https://wiki.termux.com&quot;&gt;Termux&lt;/a&gt;在Linux上直接在android上连接并运行Nim编译器。这些程序是仅限控制台的程序，无法在Play商店中分发。</target>
        </trans-unit>
        <trans-unit id="d583c04d3d5573e56b1c04f936fe5a844700a2bc" translate="yes" xml:space="preserve">
          <source>The first pass over the AST computes the lifetime of each local variable based on a notion of an &quot;abstract time&quot;, in the implementation it's a simple integer that is incremented for every visited node.</source>
          <target state="translated">第一遍过AST根据一个 &quot;抽象时间 &quot;的概念计算每个局部变量的寿命,在实现中,它是一个简单的整数,每访问一个节点就递增一次。</target>
        </trans-unit>
        <trans-unit id="070b4e293fffd6ce73b8fe7be23fcf1de6e8b78b" translate="yes" xml:space="preserve">
          <source>The first program</source>
          <target state="translated">第一个项目</target>
        </trans-unit>
        <trans-unit id="d0b3d98d639136123acdde78f568ba55378801a8" translate="yes" xml:space="preserve">
          <source>The first thing to note is that all callable types have at least a comma, even if they don't have any parameters. If there are parameters, they are represented by their types and will be comma separated. To the plain symbol a suffix may be added depending on the type of the callable:</source>
          <target state="translated">首先要注意的是,所有的可调用类型都至少有一个逗号,即使它们没有任何参数。如果有参数,它们由它们的类型来表示,并且会用逗号来分隔。根据可调用类型的不同,可以在普通符号上添加一个后缀。</target>
        </trans-unit>
        <trans-unit id="4999312ef44c80455b502761b700c78c2fa7ee69" translate="yes" xml:space="preserve">
          <source>The first thing you will always need to do in order to start using sockets, is to create a new instance of the &lt;code&gt;Socket&lt;/code&gt; type using the &lt;code&gt;newSocket&lt;/code&gt; procedure.</source>
          <target state="translated">为了开始使用套接字，您始终需要做的第一件事是使用 &lt;code&gt;newSocket&lt;/code&gt; 过程创建 &lt;code&gt;Socket&lt;/code&gt; 类型的新实例。</target>
        </trans-unit>
        <trans-unit id="492b47655f6079de4ef1caff7c3c1bff381df22c" translate="yes" xml:space="preserve">
          <source>The first version uses &lt;em&gt;cmp&lt;/em&gt; to compare the elements. The expected return values are the same as that of system.cmp. The second version uses the default comparison function &lt;em&gt;cmp&lt;/em&gt;.</source>
          <target state="translated">第一个版本使用&lt;em&gt;cmp&lt;/em&gt;比较元素。预期的返回值与system.cmp相同。第二个版本使用默认的比较功能&lt;em&gt;cmp&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="f04db68a5b3cac0d3a181a32ee15094e36574928" translate="yes" xml:space="preserve">
          <source>The following Nim code:</source>
          <target state="translated">以下是Nim代码。</target>
        </trans-unit>
        <trans-unit id="7ffd87a515c30c8b2fec87be6689a08608b581e5" translate="yes" xml:space="preserve">
          <source>The following algorithm (in pseudo-code) determines whether two types are equal with no respect to &lt;code&gt;distinct&lt;/code&gt; types. For brevity the cycle check with an auxiliary set &lt;code&gt;s&lt;/code&gt; is omitted:</source>
          <target state="translated">以下算法（用伪代码）确定两种类型是否相等，而与 &lt;code&gt;distinct&lt;/code&gt; 类型无关。为简便起见，省略了带有辅助集 &lt;code&gt;s&lt;/code&gt; 的循环检查：</target>
        </trans-unit>
        <trans-unit id="2b6b9f3bad755134a23b880abde4691304772a2d" translate="yes" xml:space="preserve">
          <source>The following built-in procs cannot be overloaded for reasons of implementation simplicity (they require specialized semantic checking):</source>
          <target state="translated">由于实现简单的原因,以下内置的procs不能被重载(它们需要专门的语义检查)。</target>
        </trans-unit>
        <trans-unit id="6090c7cb57b21b2858f8d3bdfeddde8fc3e0c835" translate="yes" xml:space="preserve">
          <source>The following builtin procs cannot be overloaded for reasons of implementation simplicity (they require specialized semantic checking):</source>
          <target state="translated">由于实现简单的原因,以下内置的procs不能被重载(它们需要专门的语义检查)。</target>
        </trans-unit>
        <trans-unit id="d491fd2b65326bcc2d9548ada2c065f112cca208" translate="yes" xml:space="preserve">
          <source>The following code:</source>
          <target state="translated">以下代码:</target>
        </trans-unit>
        <trans-unit id="9e6abf51c6a7caaa00936172c084814413d0375a" translate="yes" xml:space="preserve">
          <source>The following dot operators are available:</source>
          <target state="translated">以下是可用的点运算符。</target>
        </trans-unit>
        <trans-unit id="1f9399cc07df619ba3888f0184c84cb8878ae0a4" translate="yes" xml:space="preserve">
          <source>The following example below demonstrates this pattern:</source>
          <target state="translated">下面的例子展示了这种模式。</target>
        </trans-unit>
        <trans-unit id="64478c18e3d0e98035bc04ab8a881a14b95dcc0f" translate="yes" xml:space="preserve">
          <source>The following example demonstrates a simple chat server.</source>
          <target state="translated">下面的例子演示了一个简单的聊天服务器。</target>
        </trans-unit>
        <trans-unit id="0f231e3e3462123dc4c8a24dcb21c49c8592a8ba" translate="yes" xml:space="preserve">
          <source>The following example demonstrates loading a function called 'greet' from a library that is determined at runtime based upon a language choice. If the library fails to load or the function 'greet' is not found, it quits with a failure error code.</source>
          <target state="translated">下面的例子演示了从一个库中加载一个名为'greet'的函数,这个函数是在运行时根据语言选择确定的。如果库加载失败或没有找到函数'greet',它将以失败的错误代码退出。</target>
        </trans-unit>
        <trans-unit id="1d58b86348511b493c86a97949db3309ab3fe22e" translate="yes" xml:space="preserve">
          <source>The following example demonstrates logging to three different handlers simultaneously:</source>
          <target state="translated">下面的例子演示了同时记录到三个不同的处理程序。</target>
        </trans-unit>
        <trans-unit id="eabb5a4203a8be2bb32e537097dda5d6aafcb2a1" translate="yes" xml:space="preserve">
          <source>The following example illustrates how to use format strings:</source>
          <target state="translated">下面的例子说明了如何使用格式字符串。</target>
        </trans-unit>
        <trans-unit id="18893dd703fa2cec1ca572616dda266323fe737a" translate="yes" xml:space="preserve">
          <source>The following example illustrates the difference between having an empty &lt;code&gt;shortNoVal&lt;/code&gt; and &lt;code&gt;longNoVal&lt;/code&gt;, which is the default, and providing arguments for those two parameters:</source>
          <target state="translated">以下示例说明了默认为空的 &lt;code&gt;shortNoVal&lt;/code&gt; 和 &lt;code&gt;longNoVal&lt;/code&gt; 与为这两个参数提供参数之间的区别：</target>
        </trans-unit>
        <trans-unit id="cf3bc2b5c483a0603436689403c8ba9fb562644c" translate="yes" xml:space="preserve">
          <source>The following example implements a powerful &lt;code&gt;debug&lt;/code&gt; command that accepts a variable number of arguments:</source>
          <target state="translated">以下示例实现了功能强大的 &lt;code&gt;debug&lt;/code&gt; 命令，该命令接受可变数量的参数：</target>
        </trans-unit>
        <trans-unit id="4f734436e3f885c81c0eadfbb6a2b481609c6a63" translate="yes" xml:space="preserve">
          <source>The following example outlines a macro that generates a lexical analyzer from regular expressions:</source>
          <target state="translated">下面的例子概述了一个从正则表达式生成词法分析器的宏。</target>
        </trans-unit>
        <trans-unit id="c9696dddb17da694c08a2a139f76f69dd6a84a76" translate="yes" xml:space="preserve">
          <source>The following example shows a generic binary tree can be modeled:</source>
          <target state="translated">下面的例子显示了一个通用的二叉树可以被建模。</target>
        </trans-unit>
        <trans-unit id="13db42d616e29834b46f311e3a54ec91b9956d97" translate="yes" xml:space="preserve">
          <source>The following example shows a generic binary tree can be modelled:</source>
          <target state="translated">下面的例子显示了一个通用的二叉树可以被建模。</target>
        </trans-unit>
        <trans-unit id="873ce1a1fdbf3cb02ed243f39b15af534c75db54" translate="yes" xml:space="preserve">
          <source>The following example shows how some form of hoisting can be implemented:</source>
          <target state="translated">下面的例子展示了如何实现某种形式的吊装。</target>
        </trans-unit>
        <trans-unit id="a71a0ac5c57a9a249cd9d88a6571b08a6d33aaff" translate="yes" xml:space="preserve">
          <source>The following example shows how some simple partial evaluation can be implemented with term rewriting:</source>
          <target state="translated">下面的例子展示了如何用术语改写来实现一些简单的局部评价。</target>
        </trans-unit>
        <trans-unit id="49a73336f3c49f017bc0c2b05195fd5ec881be73" translate="yes" xml:space="preserve">
          <source>The following examples will generate documentation for the below contrived &lt;em&gt;Nim&lt;/em&gt; module, aptly named 'sample.nim'</source>
          <target state="translated">以下示例将为以下人为设计的&lt;em&gt;Nim&lt;/em&gt;模块生成文档，恰当地命名为&amp;ldquo; sample.nim&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="bca8bd37c432e705556c08bdad3554df72311569" translate="yes" xml:space="preserve">
          <source>The following floating point types are pre-defined:</source>
          <target state="translated">以下是预先定义的浮点类型。</target>
        </trans-unit>
        <trans-unit id="be3a0eb96a85f116081ffd032fe5b5b0838714d7" translate="yes" xml:space="preserve">
          <source>The following floating-point types are pre-defined:</source>
          <target state="translated">以下是预先定义的浮点类型。</target>
        </trans-unit>
        <trans-unit id="8bad09cb370d8f3f8c755d03410041bf9dcfd47b" translate="yes" xml:space="preserve">
          <source>The following is a simple example of two different ways to use channels: blocking and non-blocking.</source>
          <target state="translated">下面以简单的例子说明渠道的两种不同使用方式:阻塞和非阻塞。</target>
        </trans-unit>
        <trans-unit id="e001b72ea1919b9c8b5454d3e5745443232dfc3d" translate="yes" xml:space="preserve">
          <source>The following keywords are reserved and cannot be used as identifiers:</source>
          <target state="translated">以下关键词是保留的,不能作为标识符使用。</target>
        </trans-unit>
        <trans-unit id="7a481f800b73584de7da49ba29d51edc5e8e325d" translate="yes" xml:space="preserve">
          <source>The following nim code:</source>
          <target state="translated">以下是nim代码。</target>
        </trans-unit>
        <trans-unit id="6a498725f77daa319527cf92f4474c6333dfd7c1" translate="yes" xml:space="preserve">
          <source>The following paragraphs are mostly a reminder for myself. Things to keep in mind:</source>
          <target state="translated">以下几段主要是提醒自己。要记住的事情。</target>
        </trans-unit>
        <trans-unit id="1bcea16918645347b321c14f6902806d2e446d68" translate="yes" xml:space="preserve">
          <source>The following platforms are seldomly tested:</source>
          <target state="translated">以下平台很少测试。</target>
        </trans-unit>
        <trans-unit id="61304b559e87418b6d1e3732c6eb734eea6a3b9b" translate="yes" xml:space="preserve">
          <source>The following section defines several relations on types that are needed to describe the type checking done by the compiler.</source>
          <target state="translated">下面一节定义了几个关于类型的关系,这些关系是描述编译器进行类型检查所需要的。</target>
        </trans-unit>
        <trans-unit id="5ffd86ef8c75a76e081502cef8cf82ac80736c9f" translate="yes" xml:space="preserve">
          <source>The following section is an outline of the algorithm that the current implementation uses. The algorithm performs two traversals over the AST of the procedure or global section of code that uses a view variable. No fixpoint iterations are performed, the complexity of the analysis is O(N) where N is the number of nodes of the AST.</source>
          <target state="translated">下面一节是当前实现所使用的算法的概要。该算法在使用视图变量的过程或全局代码部分的AST上执行两次遍历。不进行 fixpoint 迭代,分析的复杂度为 O(N),其中 N 是 AST 的节点数。</target>
        </trans-unit>
        <trans-unit id="9926ea103ae5593a38a4d6fb91b32805b8670e76" translate="yes" xml:space="preserve">
          <source>The following sections define the expected output for each kind of symbol for which idetools returns valid output.</source>
          <target state="translated">以下部分定义了idetools返回有效输出的每一种符号的预期输出。</target>
        </trans-unit>
        <trans-unit id="6af8e1a2f34a50e4507418236b89fc3d2ccf3867" translate="yes" xml:space="preserve">
          <source>The following sections describe the use of each of the metacharacters.</source>
          <target state="translated">下面的章节将描述每个元字符的使用。</target>
        </trans-unit>
        <trans-unit id="525a807668897271f1a9b9de59f3fdf8f64551a7" translate="yes" xml:space="preserve">
          <source>The following strings denote other tokens:</source>
          <target state="translated">以下字符串表示其他令牌。</target>
        </trans-unit>
        <trans-unit id="b83acdde1dcacc8ae9aed7b53848613c608c4a6c" translate="yes" xml:space="preserve">
          <source>The following syntax is supported when arguments for the &lt;code&gt;shortNoVal&lt;/code&gt; and &lt;code&gt;longNoVal&lt;/code&gt; parameters, which are &lt;a href=&quot;#shortnoval-and-longnoval&quot;&gt;described later&lt;/a&gt;, are not provided:</source>
          <target state="translated">当不提供&lt;a href=&quot;#shortnoval-and-longnoval&quot;&gt;稍后描述&lt;/a&gt;的 &lt;code&gt;shortNoVal&lt;/code&gt; 和 &lt;code&gt;longNoVal&lt;/code&gt; 参数的参数时，支持以下语法：</target>
        </trans-unit>
        <trans-unit id="2286a2e09a0398e8afb0291269b5daa96c5798f3" translate="yes" xml:space="preserve">
          <source>The following variables, which must be prefixed with a dollar sign (&lt;code&gt;$&lt;/code&gt;), are available:</source>
          <target state="translated">可以使用以下变量，这些变量必须以美元符号（ &lt;code&gt;$&lt;/code&gt; ）为前缀：</target>
        </trans-unit>
        <trans-unit id="fb3d56eb3ea6e9604bb48a3710981f35773bad09" translate="yes" xml:space="preserve">
          <source>The format string to turn a filename into a &lt;span id=&quot;dll_1&quot;&gt;DLL&lt;/span&gt; file (also called &lt;span id=&quot;shared-object_1&quot;&gt;shared object&lt;/span&gt; on some operating systems).</source>
          <target state="translated">将文件名转换为&lt;span id=&quot;dll_1&quot;&gt;DLL&lt;/span&gt;文件的格式字符串（在某些操作系统上也称为&lt;span id=&quot;shared-object_1&quot;&gt;共享&lt;/span&gt;&lt;span id=&quot;dll_1&quot;&gt;库&lt;/span&gt;）。</target>
        </trans-unit>
        <trans-unit id="addcd5e79876ecd72925b40fce572a37877dd825" translate="yes" xml:space="preserve">
          <source>The format string used by a logger can be specified by providing the &lt;code&gt;fmtStr&lt;/code&gt; argument when creating the logger or by setting its &lt;code&gt;fmtStr&lt;/code&gt; field afterward. If not specified, the &lt;a href=&quot;#defaultFmtStr&quot;&gt;default format string&lt;/a&gt; is used.</source>
          <target state="translated">记录器使用的格式字符串可以通过在创建记录器时提供 &lt;code&gt;fmtStr&lt;/code&gt; 参数或随后设置其 &lt;code&gt;fmtStr&lt;/code&gt; 字段来指定。如果未指定，则使用&lt;a href=&quot;#defaultFmtStr&quot;&gt;默认格式字符串&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e0651b47a0b75f9bee920150d8eee4c5416bccac" translate="yes" xml:space="preserve">
          <source>The fourth column will be the empty string if the iterator is being defined, since at that point in the file the parser hasn't processed the full line yet. The signature will be returned complete in posterior instances of the iterator.</source>
          <target state="translated">如果正在定义迭代器,第四列将是空字符串,因为在文件的那个点上,解析器还没有处理完整的行。在迭代器的后置实例中,签名将被完整返回。</target>
        </trans-unit>
        <trans-unit id="44fc97c45a76e00051690505a1a829c9f330d1aa" translate="yes" xml:space="preserve">
          <source>The fourth column will be the empty string if the macro is being defined, since at that point in the file the parser hasn't processed the full line yet. The signature will be returned complete in posterior instances of the macro.</source>
          <target state="translated">如果正在定义宏,第四列将是空字符串,因为在文件的那个点上,解析器还没有处理完整的行。在宏的后置实例中,签名将被完整地返回。</target>
        </trans-unit>
        <trans-unit id="d08eba1a7248e709a58efba0473c7cce761f8eca" translate="yes" xml:space="preserve">
          <source>The fourth column will be the empty string if the method is being defined, since at that point in the file the parser hasn't processed the full line yet. The signature will be returned complete in posterior instances of the method.</source>
          <target state="translated">如果正在定义方法,第四列将是空字符串,因为在文件的这一点上,解析器还没有处理完整的行。在该方法的后置实例中,签名将被完整地返回。</target>
        </trans-unit>
        <trans-unit id="9cac080ce5d18f814923daa287cef0ac2f3d19be" translate="yes" xml:space="preserve">
          <source>The fourth column will be the empty string if the proc is being defined, since at that point in the file the parser hasn't processed the full line yet. The signature will be returned complete in posterior instances of the proc.</source>
          <target state="translated">如果正在定义proc,第四列将是空字符串,因为在文件中的这一点上,解析器还没有处理完整的行。在proc的后置实例中,签名将被完整地返回。</target>
        </trans-unit>
        <trans-unit id="54e7544248ea9ef4bea128a267709875e2c3f3de" translate="yes" xml:space="preserve">
          <source>The fourth column will be the empty string if the template is being defined, since at that point in the file the parser hasn't processed the full line yet. The signature will be returned complete in posterior instances of the template.</source>
          <target state="translated">如果正在定义模板,第四列将是空字符串,因为在文件的这一点上,解析器还没有处理完整的行。在模板的后置实例中,签名将被完整地返回。</target>
        </trans-unit>
        <trans-unit id="55c1deefa556120681916d6951582e608271f06c" translate="yes" xml:space="preserve">
          <source>The fourth use of backslash is for certain &lt;span id=&quot;simple-assertions_1&quot;&gt;simple assertions&lt;/span&gt;. An assertion specifies a condition that has to be met at a particular point in a match, without consuming any characters from the subject string. The use of subpatterns for more complicated assertions is described below. The backslashed assertions are::</source>
          <target state="translated">反斜杠的第四种用法是用于某些&lt;span id=&quot;simple-assertions_1&quot;&gt;简单的断言&lt;/span&gt;。断言指定必须在匹配中的特定点满足条件，而不会消耗主题字符串中的任何字符。子模式用于更复杂的断言的描述如下。反斜杠断言是：</target>
        </trans-unit>
        <trans-unit id="870186741ca6e1d444f360ccba4f4fded87a39e7" translate="yes" xml:space="preserve">
          <source>The fractional part of duration, as a duration.</source>
          <target state="translated">持续时间的小数部分,作为持续时间。</target>
        </trans-unit>
        <trans-unit id="6cf4e08c8caff96d4a84112d274637767f157c27" translate="yes" xml:space="preserve">
          <source>The frame itself.</source>
          <target state="translated">框架本身。</target>
        </trans-unit>
        <trans-unit id="5c0be66077b85b0c6e6e17698732ef4f6a86fec6" translate="yes" xml:space="preserve">
          <source>The freed memory must belong to its allocating thread! Use &lt;a href=&quot;#deallocShared,pointer&quot;&gt;deallocShared&lt;/a&gt; to deallocate from a shared heap.</source>
          <target state="translated">释放的内存必须属于其分配线程！使用&lt;a href=&quot;#deallocShared,pointer&quot;&gt;deallocShared&lt;/a&gt;从共享堆中取消分配。</target>
        </trans-unit>
        <trans-unit id="4f2b0c3709a2752c88fc8474be143cd0204e9b79" translate="yes" xml:space="preserve">
          <source>The full output can be seen here: &lt;a href=&quot;docgen_sample&quot;&gt;docgen_sample.html&lt;/a&gt;. It runs after semantic checking, and includes pragmas attached implicitly by the compiler.</source>
          <target state="translated">完整的输出可以在这里看到：&lt;a href=&quot;docgen_sample&quot;&gt;docgen_sample.html&lt;/a&gt;。它在语义检查之后运行，并包含编译器隐式附加的编译指示。</target>
        </trans-unit>
        <trans-unit id="552ab82c6faae30ed9dbac63563f851d644aaccd" translate="yes" xml:space="preserve">
          <source>The functionality implemented by &lt;code&gt;HttpClient&lt;/code&gt; and &lt;code&gt;AsyncHttpClient&lt;/code&gt; is the same, so you can use whichever one suits you best in the examples shown here.</source>
          <target state="translated">&lt;code&gt;HttpClient&lt;/code&gt; 和 &lt;code&gt;AsyncHttpClient&lt;/code&gt; 实现的功能是相同的，因此您可以在此处显示的示例中使用最适合的一种。</target>
        </trans-unit>
        <trans-unit id="59835708b577fecda7c831ca2458e4c628fc710f" translate="yes" xml:space="preserve">
          <source>The future stream is completed (this means that no more data will be written).</source>
          <target state="translated">未来的流已经完成(这意味着不会再有数据被写入)。</target>
        </trans-unit>
        <trans-unit id="87b1c3994092b48e69bbad0698b780ef6e90d0cf" translate="yes" xml:space="preserve">
          <source>The future will complete when the connection is successfully accepted.</source>
          <target state="translated">当连接成功接受后,未来将完成。</target>
        </trans-unit>
        <trans-unit id="9be33b21289a1eef5808366623258d9dbcbaa46c" translate="yes" xml:space="preserve">
          <source>The gamma function</source>
          <target state="translated">伽马函数</target>
        </trans-unit>
        <trans-unit id="7a4585c32f1f4c6914153a2005cd46dd9de070e8" translate="yes" xml:space="preserve">
          <source>The gamma function &lt;strong&gt;Deprecated since version 0.19.0&lt;/strong&gt;: Use &lt;code&gt;gamma&lt;/code&gt; instead.</source>
          <target state="translated">&lt;strong&gt;从0.19.0版开始不推荐&lt;/strong&gt;使用 &lt;code&gt;gamma&lt;/code&gt; 函数：请改用gamma。</target>
        </trans-unit>
        <trans-unit id="15c99de4a4957bd4f07f1a6a1fb166d741fab63e" translate="yes" xml:space="preserve">
          <source>The garbage collectors' way of measuring time uses (see &lt;code&gt;lib/system/timers.nim&lt;/code&gt; for the implementation):</source>
          <target state="translated">垃圾收集器测量时间使用的方式（有关实现，请参见 &lt;code&gt;lib/system/timers.nim&lt;/code&gt; ）：</target>
        </trans-unit>
        <trans-unit id="da16bec30ab8a97eb878d0183e447bbc8ee7a461" translate="yes" xml:space="preserve">
          <source>The general form of a standard format specifier is:</source>
          <target state="translated">标准格式指定器的一般形式是:</target>
        </trans-unit>
        <trans-unit id="d90e9f49ac507c92c04a7f7808d9f7f219ca411c" translate="yes" xml:space="preserve">
          <source>The general pattern in &lt;code&gt;=copy&lt;/code&gt; looks like:</source>
          <target state="translated">&lt;code&gt;=copy&lt;/code&gt; 中的一般模式如下所示：</target>
        </trans-unit>
        <trans-unit id="91909254b57a3654840f57e5570e9d7ddb4f1d0c" translate="yes" xml:space="preserve">
          <source>The general pattern in &lt;code&gt;=destroy&lt;/code&gt; looks like:</source>
          <target state="translated">&lt;code&gt;=destroy&lt;/code&gt; 中的一般模式如下所示：</target>
        </trans-unit>
        <trans-unit id="9c207d0cccf70d71e7fd5c3d827d8d82b10e6a4a" translate="yes" xml:space="preserve">
          <source>The general pattern in &lt;code&gt;=sink&lt;/code&gt; looks like:</source>
          <target state="translated">&lt;code&gt;=sink&lt;/code&gt; 中的常规模式如下所示：</target>
        </trans-unit>
        <trans-unit id="c09a581cb8f65c3c5d14cf7a67dcb119a964cc82" translate="yes" xml:space="preserve">
          <source>The generated C code will not have any explicit calling convention and thus use the C compiler's default calling convention. This is needed because Nim's default calling convention for procedures is &lt;code&gt;fastcall&lt;/code&gt; to improve speed.</source>
          <target state="translated">生成的C代码将没有任何显式的调用约定，因此将使用C编译器的默认调用约定。这是必需的，因为Nim对过程的默认调用约定是 &lt;code&gt;fastcall&lt;/code&gt; 以提高速度。</target>
        </trans-unit>
        <trans-unit id="b7379e59f2bd87fdbadd32039106a54f883a446d" translate="yes" xml:space="preserve">
          <source>The generated HTML for some of these wrappers is so huge that it is not contained in the distribution. You can then find them on the website.</source>
          <target state="translated">其中一些包装器生成的HTML非常庞大,所以不包含在发行版中。然后你可以在网站上找到它们。</target>
        </trans-unit>
        <trans-unit id="7e4e87c93eeee97828c02dc3485e82bbf4f6dbd4" translate="yes" xml:space="preserve">
          <source>The generated async procedures use the &lt;code&gt;async&lt;/code&gt; macro, whereas the generated synchronous procedures simply strip off the &lt;code&gt;await&lt;/code&gt; calls.</source>
          <target state="translated">生成的异步过程使用 &lt;code&gt;async&lt;/code&gt; 宏，而生成的同步过程仅剥离 &lt;code&gt;await&lt;/code&gt; 调用。</target>
        </trans-unit>
        <trans-unit id="aa03edbbdb0c3d938f260d58cb5ca2f51408059e" translate="yes" xml:space="preserve">
          <source>The generated files that Nim produces all go into a subdirectory called &lt;code&gt;nimcache&lt;/code&gt;. Its full path is</source>
          <target state="translated">Nim生成的生成文件全部进入一个名为 &lt;code&gt;nimcache&lt;/code&gt; 的子目录。其完整路径是</target>
        </trans-unit>
        <trans-unit id="4c785c59836bb83ab636f8a5d0cda606ab17c5e4" translate="yes" xml:space="preserve">
          <source>The generated index. &lt;strong&gt;Index + (Ctrl+F) == Joy&lt;/strong&gt;</source>
          <target state="translated">生成的索引。&lt;strong&gt;索引+（Ctrl + F）== Joy&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f790d93cc82c110db5a7f7d8300334c9fc7c8808" translate="yes" xml:space="preserve">
          <source>The getrlimit() system call gets resource limits.</source>
          <target state="translated">系统调用getrlimit()获取资源限制。</target>
        </trans-unit>
        <trans-unit id="037ac60a6022509a63de6a9810813d645bcec667" translate="yes" xml:space="preserve">
          <source>The global log filter is actually a thread-local variable, so it needs to be set in each thread that uses this module.</source>
          <target state="translated">全局日志过滤器实际上是一个线程本地变量,所以需要在每个使用该模块的线程中进行设置。</target>
        </trans-unit>
        <trans-unit id="dba6185483a07591222dc085893c06cb1d77fd81" translate="yes" xml:space="preserve">
          <source>The good news is not much has changed! First, we need to change the handling of the input parameter (line 3). In the dynamic version the &lt;code&gt;readCfgAtRuntime&lt;/code&gt; proc receives a string parameter. However, in the macro version it is also declared as string, but this is the &lt;em&gt;outside&lt;/em&gt; interface of the macro. When the macro is run, it actually gets a &lt;code&gt;PNimNode&lt;/code&gt; object instead of a string, and we have to call the &lt;a href=&quot;macros#strVal&quot;&gt;strVal proc&lt;/a&gt; (line 5) from the &lt;a href=&quot;macros&quot;&gt;macros module&lt;/a&gt; to obtain the string being passed in to the macro.</source>
          <target state="translated">好消息没有太大改变！首先，我们需要更改输入参数的处理（第3行）。在动态版本中， &lt;code&gt;readCfgAtRuntime&lt;/code&gt; proc接收一个字符串参数。但是，在宏版本中，它也声明为字符串，但这是宏的&lt;em&gt;外部&lt;/em&gt;接口。运行宏时，它实际上获得了一个 &lt;code&gt;PNimNode&lt;/code&gt; 对象而不是字符串，并且我们必须从&lt;a href=&quot;macros&quot;&gt;宏模块中&lt;/a&gt;调用&lt;a href=&quot;macros#strVal&quot;&gt;strVal proc&lt;/a&gt;（第5行），以获取要传递给宏的字符串。</target>
        </trans-unit>
        <trans-unit id="14f57dccb74a2123a9f5546e3bebaee4e90cb289" translate="yes" xml:space="preserve">
          <source>The grammar's start symbol is &lt;code&gt;module&lt;/code&gt;.</source>
          <target state="translated">语法的开始符号是 &lt;code&gt;module&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c6743543c75d60b9f024c8d8ce6011899979a9a7" translate="yes" xml:space="preserve">
          <source>The greetings program consists of 3 statements that are executed sequentially. Only the most primitive programs can get away with that: branching and looping are needed too.</source>
          <target state="translated">问候程序由3条语句组成,依次执行。只有最原始的程序才能摆脱这种情况:也需要分支和循环。</target>
        </trans-unit>
        <trans-unit id="ac70a8fca453e797498ff8e165be78d4d719a059" translate="yes" xml:space="preserve">
          <source>The guard does not need to be of any particular type. It is flexible enough to model low level lockfree mechanisms:</source>
          <target state="translated">保护装置不需要是任何特定类型的。它足够灵活,可以模拟低级无锁机制。</target>
        </trans-unit>
        <trans-unit id="d0d6ece26593eceae5133245593e5e87cf3e06f3" translate="yes" xml:space="preserve">
          <source>The handling of a backslash followed by a digit other than 0 is complicated. Outside a character class, PCRE reads it and any following digits as a decimal number. If the number is less than 10, or if there have been at least that many previous capturing left parentheses in the expression, the entire sequence is taken as a back reference. A description of how this works is given later, following the discussion of parenthesized subpatterns.</source>
          <target state="translated">处理反斜杠后面的数字而不是0的处理方法很复杂。在字符类之外,PCRE将它和后面的任何数字作为十进制数读取。如果这个数字小于10,或者在表达式中至少有那么多之前的捕获左小括号,整个序列就会被当作后参考。后面在讨论小括号子模式后,将对这一工作原理进行描述。</target>
        </trans-unit>
        <trans-unit id="5f48d8244b80a669bed1a5d54a7009aee304b1e6" translate="yes" xml:space="preserve">
          <source>The heap dump feature is still in its infancy, but it already proved useful for us, so it might be useful for you. To get a heap dump, compile with &lt;code&gt;-d:nimTypeNames&lt;/code&gt; and call &lt;code&gt;dumpNumberOfInstances&lt;/code&gt; at a strategic place in your program. This produces a list of the used types in your program and for every type the total amount of object instances for this type as well as the total amount of bytes these instances take up. This list is currently unsorted! You need to use external shell script hacking to sort it.</source>
          <target state="translated">堆转储功能仍处于起步阶段，但已证明对我们有用，因此可能对您有用。要获取堆转储，请使用 &lt;code&gt;-d:nimTypeNames&lt;/code&gt; 进行编译，然后在程序中的重要位置调用 &lt;code&gt;dumpNumberOfInstances&lt;/code&gt; 。这将生成程序中使用的类型的列表，对于每种类型，此类型的对象实例的总数以及这些实例所占用的字节总数。该列表目前未排序！您需要使用外部Shell脚本黑客对其进行排序。</target>
        </trans-unit>
        <trans-unit id="a0b88ec5fc66250e8218fe5157065e3562f9959e" translate="yes" xml:space="preserve">
          <source>The heap dump feature is still in its infancy, but it already proved useful for us, so it might be useful for you. To get a heap dump, compile with &lt;code&gt;-d:nimTypeNames&lt;/code&gt; and call &lt;code&gt;dumpNumberOfInstances&lt;/code&gt; at a strategic place in your program. This produces a list of used types in your program and for every type the total amount of object instances for this type as well as the total amount of bytes these instances take up. This list is currently unsorted! You need to use external shell script hacking to sort it.</source>
          <target state="translated">堆转储功能仍处于起步阶段，但已证明对我们有用，因此可能对您有用。要获取堆转储，请使用 &lt;code&gt;-d:nimTypeNames&lt;/code&gt; 进行编译，然后在程序中的重要位置调用 &lt;code&gt;dumpNumberOfInstances&lt;/code&gt; 。这将生成程序中已使用类型的列表，对于每种类型，此类型的对象实例总数以及这些实例占用的字节总数将为您提供清单。该列表目前未排序！您需要使用外部Shell脚本黑客对其进行排序。</target>
        </trans-unit>
        <trans-unit id="50e42170b04192c54cd732656dcd94cd8243444d" translate="yes" xml:space="preserve">
          <source>The highest (absolute) return value of all processes is returned. Runs &lt;code&gt;beforeRunEvent&lt;/code&gt; before running each command.</source>
          <target state="translated">返回所有进程的最高（绝对）返回值。在运行每个命令之前运行 &lt;code&gt;beforeRunEvent&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4b5e3bf19f9b933b2e60a2ad18d610252c1b05a5" translate="yes" xml:space="preserve">
          <source>The hooks of a tuple type &lt;code&gt;(A, B, ...)&lt;/code&gt; are generated by lifting the hooks of the involved types &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;B&lt;/code&gt;, ... to the tuple type. In other words, a copy &lt;code&gt;x = y&lt;/code&gt; is implemented as &lt;code&gt;x[0] = y[0]; x[1] = y[1]; ...&lt;/code&gt;, likewise for &lt;code&gt;=sink&lt;/code&gt; and &lt;code&gt;=destroy&lt;/code&gt;.</source>
          <target state="translated">元组类型 &lt;code&gt;(A, B, ...)&lt;/code&gt; 的钩子是通过将涉及的类型 &lt;code&gt;A&lt;/code&gt; ， &lt;code&gt;B&lt;/code&gt; ，...的钩子提升到元组类型而生成的。换句话说，将副本 &lt;code&gt;x = y&lt;/code&gt; 实现为 &lt;code&gt;x[0] = y[0]; x[1] = y[1]; ...&lt;/code&gt; ，同样适用于 &lt;code&gt;=sink&lt;/code&gt; 和 &lt;code&gt;=destroy&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="eddf728b23d010d05fee2b18ba2bee9bcf3ad561" translate="yes" xml:space="preserve">
          <source>The hostname of the client that made the request.</source>
          <target state="translated">发出请求的客户端的主机名。</target>
        </trans-unit>
        <trans-unit id="ae4bd9577099eefd3ac234c48f0755b6cae28779" translate="yes" xml:space="preserve">
          <source>The hours in one digit if possible, ranging from 0-23.</source>
          <target state="translated">如果可能的话,小时数为一位数,范围为0-23。</target>
        </trans-unit>
        <trans-unit id="508ac3f8b6d5beb7c16ecbb475b705dc160e6aea" translate="yes" xml:space="preserve">
          <source>The hours in one digit if possible. Ranging from 1-12.</source>
          <target state="translated">如果可能的话,小时数为一位数。从1-12不等。</target>
        </trans-unit>
        <trans-unit id="6e46e361665712eacbeb9a335f8ac314ff87abf9" translate="yes" xml:space="preserve">
          <source>The hours in two digits always. 0 is prepended if the hour is one digit.</source>
          <target state="translated">小时数总是两位数。如果小时数是一位数,则在前面加上0。</target>
        </trans-unit>
        <trans-unit id="35c9e4c595e71cdcb96dde240197d1b8a79fe6b5" translate="yes" xml:space="preserve">
          <source>The hours in two digits always. If the hour is one digit 0 is prepended.</source>
          <target state="translated">小时数始终为两位数。如果小时数是一位数,则在前面加上0。</target>
        </trans-unit>
        <trans-unit id="8756b39644a0477a0c2e1fe04a5c8675b5957021" translate="yes" xml:space="preserve">
          <source>The hours in two digits always. If the hour is one digit, 0 is prepended.</source>
          <target state="translated">小时数始终为两位数。如果小时数是一位数,则在前面加上0。</target>
        </trans-unit>
        <trans-unit id="0d9394e30e2a196f91ca01b9ff5b59502413c00a" translate="yes" xml:space="preserve">
          <source>The identifiers following the &lt;code&gt;concept&lt;/code&gt; keyword represent instances of the currently matched type. You can apply any of the standard type modifiers such as &lt;code&gt;var&lt;/code&gt;, &lt;code&gt;ref&lt;/code&gt;, &lt;code&gt;ptr&lt;/code&gt; and &lt;code&gt;static&lt;/code&gt; to denote a more specific type of instance. You can also apply the &lt;code&gt;type&lt;/code&gt; modifier to create a named instance of the type itself:</source>
          <target state="translated">&lt;code&gt;concept&lt;/code&gt; 关键字后面的标识符表示当前匹配类型的实例。您可以应用任何标准类型修饰符，例如 &lt;code&gt;var&lt;/code&gt; ， &lt;code&gt;ref&lt;/code&gt; ， &lt;code&gt;ptr&lt;/code&gt; 和 &lt;code&gt;static&lt;/code&gt; 来表示实例的更特定类型。您还可以应用 &lt;code&gt;type&lt;/code&gt; 修饰符来创建类型本身的命名实例：</target>
        </trans-unit>
        <trans-unit id="dcaf88b5d30ee42061a975ec06cd4f726da65a81" translate="yes" xml:space="preserve">
          <source>The identifiers following the &lt;code&gt;concept&lt;/code&gt; keyword represent instances of the currently matched type. You can apply any of the standard type modifiers such as &lt;code&gt;var&lt;/code&gt;, &lt;code&gt;ref&lt;/code&gt;, &lt;code&gt;ptr&lt;/code&gt; and &lt;code&gt;static&lt;/code&gt; to denote a more specific type of instance. You can also apply the &lt;em&gt;type&lt;/em&gt; modifier to create a named instance of the type itself:</source>
          <target state="translated">&lt;code&gt;concept&lt;/code&gt; 关键字后面的标识符表示当前匹配类型的实例。您可以应用任何标准类型修饰符，例如 &lt;code&gt;var&lt;/code&gt; ， &lt;code&gt;ref&lt;/code&gt; ， &lt;code&gt;ptr&lt;/code&gt; 和 &lt;code&gt;static&lt;/code&gt; 来表示实例的更特定类型。您还可以应用&lt;em&gt;类型&lt;/em&gt;修饰符创建类型本身的命名实例：</target>
        </trans-unit>
        <trans-unit id="866a5085cacac6b94172240b1efcb741ff5bdf86" translate="yes" xml:space="preserve">
          <source>The identity hash. I.e. &lt;code&gt;hashIdentity(x) = x&lt;/code&gt;.</source>
          <target state="translated">身份哈希。即 &lt;code&gt;hashIdentity(x) = x&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bbb5916fc4882a2710c89523611ae3521f422971" translate="yes" xml:space="preserve">
          <source>The idetools command can be run as a compiler service (CAAS), where you first launch the compiler and it will stay online as a server, accepting queries in a telnet like fashion. The advantage of staying on is that for many queries the compiler can cache the results of the compilation, and subsequent queries should be fast in the millisecond range, thus being responsive enough for IDEs.</source>
          <target state="translated">idetools命令可以以编译器服务(CAAS)的方式运行,你首先启动编译器,它就会作为服务器保持在线,以类似telnet的方式接受查询。保持在线的好处是,对于很多查询,编译器可以缓存编译结果,后续的查询速度应该在毫秒级,因此对于IDE来说,响应速度足够快。</target>
        </trans-unit>
        <trans-unit id="79d04054b05925070544c64b6a10b2d6f82716f2" translate="yes" xml:space="preserve">
          <source>The if statement is one way to branch the control flow:</source>
          <target state="translated">if语句是分支控制流的一种方式。</target>
        </trans-unit>
        <trans-unit id="186aff351d775e0607553eab0c0008691860c0dc" translate="yes" xml:space="preserve">
          <source>The imaginary unit. &amp;radic;-1.</source>
          <target state="translated">虚数单位。&amp;radic;-1。</target>
        </trans-unit>
        <trans-unit id="5e0323c86252bd503934591b5f403aa76daecc18" translate="yes" xml:space="preserve">
          <source>The immediate pragma is obsolete. See &lt;a href=&quot;#templates-typed-vs-untyped-parameters&quot;&gt;Typed vs untyped parameters&lt;/a&gt;.</source>
          <target state="translated">眼前的实用主义已过时。请参见带&lt;a href=&quot;#templates-typed-vs-untyped-parameters&quot;&gt;类型参数与无类型参数&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2e0e8535555370a430de44e05424a154580b342b" translate="yes" xml:space="preserve">
          <source>The immediate pragma is obsolete. See &lt;a href=&quot;#typed-vs-untyped-parameters&quot;&gt;Typed vs untyped parameters&lt;/a&gt;.</source>
          <target state="translated">立即的实用性已过时。请参见&lt;a href=&quot;#typed-vs-untyped-parameters&quot;&gt;类型化参数与非类型化参数&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7fc80eb338f0f7897699f01c0d17e46fc45536bb" translate="yes" xml:space="preserve">
          <source>The implementation aligns the fields for best access performance. The alignment is compatible with the way the C compiler does it.</source>
          <target state="translated">该实现将字段对齐以获得最佳访问性能。这种对齐方式与C编译器的方式兼容。</target>
        </trans-unit>
        <trans-unit id="294358e6a281776103afaeb5e6074dc4ee530170" translate="yes" xml:space="preserve">
          <source>The implementation aligns the fields for the best access performance. The alignment is compatible with the way the C compiler does it.</source>
          <target state="translated">该实现将字段对齐以获得最佳访问性能。这种对齐方式与C编译器的方式兼容。</target>
        </trans-unit>
        <trans-unit id="a9335f13c424aeabf870c93de05f27167c506276" translate="yes" xml:space="preserve">
          <source>The implementation currently provides the following possible options (various others may be added later).</source>
          <target state="translated">目前的实施方案提供了以下可能的选择(以后可能会增加其他各种选择):</target>
        </trans-unit>
        <trans-unit id="c3d620a68814993a0e566de11d8cdb73db09b126" translate="yes" xml:space="preserve">
          <source>The implementation of the compilation cache is tricky: There are lots of issues to be solved for the front- and backend.</source>
          <target state="translated">编译缓存的实现很棘手:前后端都有很多问题需要解决。</target>
        </trans-unit>
        <trans-unit id="c05e5029b48899e6e6d2a69b1f77e63ebf121b7d" translate="yes" xml:space="preserve">
          <source>The implicit initialization can be also prevented by the &lt;span id=&quot;requiresinit_1&quot;&gt;requiresInit&lt;/span&gt; type pragma. The compiler requires an explicit initialization for the object and all of its fields. However it does a &lt;span id=&quot;control-flow-analysis_1&quot;&gt;control flow analysis&lt;/span&gt; to prove the variable has been initialized and does not rely on syntactic properties:</source>
          <target state="translated">还可以通过&lt;span id=&quot;requiresinit_1&quot;&gt;requireInit&lt;/span&gt;类型编译指示来防止隐式初始化。编译器要求对对象及其所有字段进行显式初始化。但是，它进行&lt;span id=&quot;control-flow-analysis_1&quot;&gt;控制流分析&lt;/span&gt;以证明变量已初始化，并且不依赖语法属性：</target>
        </trans-unit>
        <trans-unit id="041f7a809d44d21475e39cf4f429bf17b9449128" translate="yes" xml:space="preserve">
          <source>The implicit initialization can be also prevented by the &lt;span id=&quot;requiresinit_1&quot;&gt;requiresInit&lt;/span&gt; type pragma. The compiler requires an explicit initialization for the object and all of its fields. However, it does a &lt;span id=&quot;control-flow-analysis_1&quot;&gt;control flow analysis&lt;/span&gt; to prove the variable has been initialized and does not rely on syntactic properties:</source>
          <target state="translated">还可以通过&lt;span id=&quot;requiresinit_1&quot;&gt;requireInit&lt;/span&gt;类型编译指示来防止隐式初始化。编译器需要对对象及其所有字段进行显式初始化。但是，它进行&lt;span id=&quot;control-flow-analysis_1&quot;&gt;控制流分析&lt;/span&gt;以证明变量已初始化，并且不依赖语法属性：</target>
        </trans-unit>
        <trans-unit id="6bee0de5240bc2aece39314fb5444f70f1444362" translate="yes" xml:space="preserve">
          <source>The implicit initialization can be avoided for optimization reasons with the &lt;span id=&quot;noinit_1&quot;&gt;noinit&lt;/span&gt; pragma:</source>
          <target state="translated">出于优化原因，可以使用&lt;span id=&quot;noinit_1&quot;&gt;noinit&lt;/span&gt;编译指示来避免隐式初始化：</target>
        </trans-unit>
        <trans-unit id="3b7fd6facf0715e6c58bb9982e48c189f4d6d0c2" translate="yes" xml:space="preserve">
          <source>The indentation handling is implemented as follows: The lexer annotates the following token with the preceding number of spaces; indentation is not a separate token. This trick allows parsing of Nim with only 1 token of lookahead.</source>
          <target state="translated">缩进处理的实现方式如下。词典会用前面的空格数来注释下面的标记;缩进不是一个单独的标记。这个技巧允许只用1个lookahead标记来解析Nim。</target>
        </trans-unit>
        <trans-unit id="beff0881d78e8e065e276388970843e17443daff" translate="yes" xml:space="preserve">
          <source>The index generation tools try to differentiate between documentation generated from &lt;code&gt;.nim&lt;/code&gt; files and documentation generated from &lt;code&gt;.txt&lt;/code&gt; or &lt;code&gt;.rst&lt;/code&gt; files. The former are always closely related to source code and consist mainly of API entries. The latter are generic documents meant for human reading.</source>
          <target state="translated">索引生成工具尝试区分从 &lt;code&gt;.nim&lt;/code&gt; 文件生成的文档和从 &lt;code&gt;.txt&lt;/code&gt; 或 &lt;code&gt;.rst&lt;/code&gt; 文件生成的文档。前者始终与源代码密切相关，并且主要由API条目组成。后者是供人类阅读的通用文档。</target>
        </trans-unit>
        <trans-unit id="6306cc92a3bed777b6c141274a3bc860eba5a71d" translate="yes" xml:space="preserve">
          <source>The index won't be written to disk unless you call &lt;a href=&quot;#writeIndexFile&quot;&gt;writeIndexFile()&lt;/a&gt;. The purpose of the index is documented in the &lt;a href=&quot;docgen#index-switch&quot;&gt;docgen tools guide&lt;/a&gt;.</source>
          <target state="translated">除非您调用&lt;a href=&quot;#writeIndexFile&quot;&gt;writeIndexFile（），&lt;/a&gt;否则索引不会写入磁盘。索引的目的已在&lt;a href=&quot;docgen#index-switch&quot;&gt;docgen工具指南&lt;/a&gt;中进行了说明。</target>
        </trans-unit>
        <trans-unit id="94bc31946d2cd011244938f6920b84d9ad9961d9" translate="yes" xml:space="preserve">
          <source>The index won't be written to disk unless you call &lt;a href=&quot;#writeIndexFile,RstGenerator,string&quot;&gt;writeIndexFile()&lt;/a&gt;. The purpose of the index is documented in the &lt;a href=&quot;https://nim-lang.org/docs/docgen.html#related-options-index-switch&quot;&gt;docgen tools guide&lt;/a&gt;.</source>
          <target state="translated">除非您调用&lt;a href=&quot;#writeIndexFile,RstGenerator,string&quot;&gt;writeIndexFile（），&lt;/a&gt;否则索引不会写入磁盘。索引的目的已在&lt;a href=&quot;https://nim-lang.org/docs/docgen.html#related-options-index-switch&quot;&gt;docgen工具指南&lt;/a&gt;中进行了说明。</target>
        </trans-unit>
        <trans-unit id="6bcd5411b31ff678f2d8be730a52fa311b3d1c92" translate="yes" xml:space="preserve">
          <source>The indices of the element range that should be rotated.</source>
          <target state="translated">应该旋转的元素范围的指数。</target>
        </trans-unit>
        <trans-unit id="7771da68e022b74bd5731922346ef2df52d2b53c" translate="yes" xml:space="preserve">
          <source>The inference for read/write tracking is analogous to the inference for exception tracking.</source>
          <target state="translated">读/写跟踪的推理类似于异常跟踪的推理。</target>
        </trans-unit>
        <trans-unit id="8d228a4803537313b1b78b37775bd1778df6dcc5" translate="yes" xml:space="preserve">
          <source>The inference for tag tracking is analogous to the inference for exception tracking.</source>
          <target state="translated">标签跟踪的推理类似于异常跟踪的推理。</target>
        </trans-unit>
        <trans-unit id="f5fb44e48abd9154517dcc0228213cb6390a548c" translate="yes" xml:space="preserve">
          <source>The inline convention means the the caller should not call the procedure, but inline its code directly. Note that Nim does not inline, but leaves this to the C compiler; it generates &lt;code&gt;__inline&lt;/code&gt; procedures. This is only a hint for the compiler: it may completely ignore it and it may inline procedures that are not marked as &lt;code&gt;inline&lt;/code&gt;.</source>
          <target state="translated">内联约定意味着调用者不应调用该过程，而应直接内联其代码。请注意，Nim不内联，而是将其留给C编译器使用。它生成 &lt;code&gt;__inline&lt;/code&gt; 程序。这只是对编译器的提示：它可能会完全忽略它，并且可能会嵌入未标记为 &lt;code&gt;inline&lt;/code&gt; 的内联过程。</target>
        </trans-unit>
        <trans-unit id="07ea325a19c222cc3708d3f67c25509be2bcbf07" translate="yes" xml:space="preserve">
          <source>The input containers can be of different types. If one container is shorter, the remaining items in the longer container are discarded.</source>
          <target state="translated">输入容器可以是不同类型的。如果一个容器较短,较长容器中的剩余物品将被丢弃。</target>
        </trans-unit>
        <trans-unit id="a0e8a627ab18ca245222565836c8b78837c0f702" translate="yes" xml:space="preserve">
          <source>The interaction between threads and exceptions is simple: A &lt;em&gt;handled&lt;/em&gt; exception in one thread cannot affect any other thread. However, an &lt;em&gt;unhandled&lt;/em&gt; exception in one thread terminates the whole &lt;em&gt;process&lt;/em&gt;!</source>
          <target state="translated">线程与异常之间的交互很简单：一个线程中的已&lt;em&gt;处理&lt;/em&gt;异常不会影响任何其他线程。但是，一个线程中&lt;em&gt;未处理的&lt;/em&gt;异常会终止整个&lt;em&gt;过程&lt;/em&gt;！</target>
        </trans-unit>
        <trans-unit id="a3f5985cf8e619dcc28842b0431cc6a248880914" translate="yes" xml:space="preserve">
          <source>The interesting thing is that our macro does not return a runtime &lt;a href=&quot;tables#Table&quot;&gt;Table&lt;/a&gt; object. Instead, it builds up Nim source code into the &lt;code&gt;source&lt;/code&gt; variable. For each line of the configuration file a &lt;code&gt;const&lt;/code&gt; variable will be generated (line 15). To avoid conflicts we prefix these variables with &lt;code&gt;cfg&lt;/code&gt;. In essence, what the compiler is doing is replacing the line calling the macro with the following snippet of code:</source>
          <target state="translated">有趣的是，我们的宏不返回运行时&lt;a href=&quot;tables#Table&quot;&gt;Table&lt;/a&gt;对象。而是将Nim源代码构建到 &lt;code&gt;source&lt;/code&gt; 变量中。对于配置文件的每一行，将生成一个 &lt;code&gt;const&lt;/code&gt; 变量（第15行）。为了避免冲突，我们在这些变量前加上 &lt;code&gt;cfg&lt;/code&gt; 。本质上，编译器正在做的是用以下代码片段替换调用宏的行：</target>
        </trans-unit>
        <trans-unit id="7fda431dba2bcff15441a32a1ff7eabe4a0fcf00" translate="yes" xml:space="preserve">
          <source>The internal documentation describes how the compiler is implemented. Read this if you want to hack the compiler.</source>
          <target state="translated">内部文档描述了编译器是如何实现的。如果你想破解编译器,请阅读这个文件。</target>
        </trans-unit>
        <trans-unit id="1452e6f81083a81acdb84eb68518f3f09d626249" translate="yes" xml:space="preserve">
          <source>The intersection of two sets is represented mathematically as &lt;em&gt;A &amp;cap; B&lt;/em&gt; and is the set of all objects that are members of &lt;code&gt;s1&lt;/code&gt; and &lt;code&gt;s2&lt;/code&gt; at the same time.</source>
          <target state="translated">两组的交集在数学上表示为&lt;em&gt;A&amp;cap;B，&lt;/em&gt;并且是同时属于 &lt;code&gt;s1&lt;/code&gt; 和 &lt;code&gt;s2&lt;/code&gt; 的所有对象的集合。</target>
        </trans-unit>
        <trans-unit id="3e39595327b5d15b7987f46c8523802d25b3413e" translate="yes" xml:space="preserve">
          <source>The intersection of two sets is represented mathematically as &lt;em&gt;A &amp;cap; B&lt;/em&gt; and is the set of all objects that are members of &lt;em&gt;s1&lt;/em&gt; and &lt;em&gt;s2&lt;/em&gt; at the same time. Example:</source>
          <target state="translated">两组的交集在数学上用&lt;em&gt;A&amp;cap;B&lt;/em&gt;表示，并且是同时属于&lt;em&gt;s1&lt;/em&gt;和&lt;em&gt;s2&lt;/em&gt;的所有对象的集合。例：</target>
        </trans-unit>
        <trans-unit id="0bac8e37845bee3e0695f85e57beaf804a472bb1" translate="yes" xml:space="preserve">
          <source>The jump function for the generator.</source>
          <target state="translated">发电机的跳转功能。</target>
        </trans-unit>
        <trans-unit id="ea2460c0b5417fd480903274412d643b12ea3569" translate="yes" xml:space="preserve">
          <source>The language constructs are explained using an extended BNF, in which &lt;code&gt;(a)*&lt;/code&gt; means 0 or more &lt;code&gt;a&lt;/code&gt;'s, &lt;code&gt;a+&lt;/code&gt; means 1 or more &lt;code&gt;a&lt;/code&gt;'s, and &lt;code&gt;(a)?&lt;/code&gt; means an optional &lt;em&gt;a&lt;/em&gt;. Parentheses may be used to group elements.</source>
          <target state="translated">使用扩展的BNF来解释语言结构，其中 &lt;code&gt;(a)*&lt;/code&gt; 表示0或多个 &lt;code&gt;a&lt;/code&gt; ， &lt;code&gt;a+&lt;/code&gt; 表示1或多个 &lt;code&gt;a&lt;/code&gt; ，并且 &lt;code&gt;(a)?&lt;/code&gt; 表示可选&lt;em&gt;的&lt;/em&gt;。括号可用于对元素进行分组。</target>
        </trans-unit>
        <trans-unit id="5fa17fe926761d71195e28d1150f004609551f7f" translate="yes" xml:space="preserve">
          <source>The largest positive number that can be represented in a 32-bit floating-point type.</source>
          <target state="translated">用32位浮点类型表示的最大正数。</target>
        </trans-unit>
        <trans-unit id="df1bceb0b90a5c84eca91bbd3d5e55dc6f933514" translate="yes" xml:space="preserve">
          <source>The largest positive number that can be represented in a 64-bit floating-point type.</source>
          <target state="translated">64位浮点类型中可以表示的最大正数。</target>
        </trans-unit>
        <trans-unit id="910c1473620a01923d2bc965b1cb67bc12d9a347" translate="yes" xml:space="preserve">
          <source>The last statement of &lt;code&gt;body&lt;/code&gt; has special syntax that specifies the collection's add operation. Use &lt;code&gt;{e}&lt;/code&gt; for set's &lt;code&gt;incl&lt;/code&gt;, &lt;code&gt;{k: v}&lt;/code&gt; for table's &lt;code&gt;[]=&lt;/code&gt; and &lt;code&gt;e&lt;/code&gt; for seq's &lt;code&gt;add&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;body&lt;/code&gt; 的最后一个语句具有特殊的语法，用于指定集合的​​添加操作。将 &lt;code&gt;{e}&lt;/code&gt; 用于集合的 &lt;code&gt;incl&lt;/code&gt; ，将 &lt;code&gt;{k: v}&lt;/code&gt; 用于表的 &lt;code&gt;[]=&lt;/code&gt; ，将 &lt;code&gt;e&lt;/code&gt; 用于seq的 &lt;code&gt;add&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c6b90ce83aefcb334988e56d2cf302f465c1ef2d" translate="yes" xml:space="preserve">
          <source>The last two digits of the year. When parsing, the current century is assumed.</source>
          <target state="translated">年份的最后两位数字。在解析时,假设当前的世纪。</target>
        </trans-unit>
        <trans-unit id="cbf5dbfc21433db13ae75eecfb40f44883518b3c" translate="yes" xml:space="preserve">
          <source>The last two parameters specify the certificate file path and the key file path, a server socket will most likely not work without these.</source>
          <target state="translated">最后两个参数指定了证书文件路径和密钥文件路径,服务器套接字如果没有这两个参数,很可能无法工作。</target>
        </trans-unit>
        <trans-unit id="d738ffb3d9772102e7dddad8f87eb9e66e116402" translate="yes" xml:space="preserve">
          <source>The last two parameters specify the certificate file path and the key file path, a server socket will most likely not work without these. Certificates can be generated using the following command: &lt;code&gt;openssl req -x509 -nodes -days 365 -newkey rsa:1024 -keyout mycert.pem -out mycert.pem&lt;/code&gt;.</source>
          <target state="translated">最后两个参数指定证书文件路径和密钥文件路径，没有这些，服务器套接字很可能无法工作。可以使用以下命令生成证书： &lt;code&gt;openssl req -x509 -nodes -days 365 -newkey rsa:1024 -keyout mycert.pem -out mycert.pem&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="22883001fe945b433749aff495f00df528dc3c12" translate="yes" xml:space="preserve">
          <source>The let statement</source>
          <target state="translated">Let语句</target>
        </trans-unit>
        <trans-unit id="d0faa7666c0de3db04b2c000430e78a9499fe142" translate="yes" xml:space="preserve">
          <source>The letter 'l' should not be used as an identifier.</source>
          <target state="translated">字母 &quot;l &quot;不应作为标识符使用。</target>
        </trans-unit>
        <trans-unit id="e1a4f72b5fdcd674f6a9f4458b16b275e31bc2a1" translate="yes" xml:space="preserve">
          <source>The library uses a simple naming scheme that makes use of common abbreviations to keep the names short but meaningful.</source>
          <target state="translated">该库使用了一个简单的命名方案,利用常见的缩写,使名称简短而有意义。</target>
        </trans-unit>
        <trans-unit id="03449ea33dc1c4c4ed0647ce0ae2f4b3f5ab6c04" translate="yes" xml:space="preserve">
          <source>The library uses a simple naming scheme that makes use of common abbreviations to keep the names short but meaningful. Since version 0.8.2 many symbols have been renamed to fit this scheme. The ultimate goal is that the programmer can &lt;em&gt;guess&lt;/em&gt; a name.</source>
          <target state="translated">该库使用一种简单的命名方案，该方案使用常见的缩写来使名称简短但有意义。从版本0.8.2开始，已将许多符号重命名以适合此方案。最终目标是程序员可以&lt;em&gt;猜出&lt;/em&gt;一个名字。</target>
        </trans-unit>
        <trans-unit id="e9fa62619261048f21f9083a33a88350d8f41816" translate="yes" xml:space="preserve">
          <source>The lifetime of &lt;code&gt;v&lt;/code&gt; must not exceed &lt;code&gt;b&lt;/code&gt;'s lifetime. Note: The lifetime of a parameter is the complete proc body.</source>
          <target state="translated">&lt;code&gt;v&lt;/code&gt; 的生存期不能超过 &lt;code&gt;b&lt;/code&gt; 的生存期。注意：参数的生存期是完整的proc主体。</target>
        </trans-unit>
        <trans-unit id="b593bd8a0a8e61e207ea44310ff8458416c946da" translate="yes" xml:space="preserve">
          <source>The list of registered handlers is also a thread-local variable. If a handler will be used in multiple threads, it needs to be registered in each of those threads.</source>
          <target state="translated">注册的处理程序列表也是一个线程本地变量。如果一个处理程序将在多个线程中使用,那么它需要在每个线程中注册。</target>
        </trans-unit>
        <trans-unit id="81b15f3b8be0db527b2dd32e57b3edc710545648" translate="yes" xml:space="preserve">
          <source>The listed pragmas here can be used to override the code generation options for a proc/method/converter.</source>
          <target state="translated">这里列出的实用名词可以用来覆盖proc/method/converter的代码生成选项。</target>
        </trans-unit>
        <trans-unit id="c515c4489fec51db2bb23bd53fd52c5cb33b8c63" translate="yes" xml:space="preserve">
          <source>The logger that was created above logs to the console, but this module also provides loggers that log to files, such as the &lt;a href=&quot;#FileLogger&quot;&gt;FileLogger&lt;/a&gt;. Creating custom loggers is also possible by inheriting from the &lt;a href=&quot;#Logger&quot;&gt;Logger&lt;/a&gt; type.</source>
          <target state="translated">上面创建的记录器将记录到控制台，但是此模块还提供记录到文件（例如&lt;a href=&quot;#FileLogger&quot;&gt;FileLogger）的&lt;/a&gt;记录器。通过从&lt;a href=&quot;#Logger&quot;&gt;Logger&lt;/a&gt;类型继承，还可以创建自定义记录器。</target>
        </trans-unit>
        <trans-unit id="d6ba5327d8647bd7ed894bcffd2bb86402f1c550" translate="yes" xml:space="preserve">
          <source>The lower bound of an array or sequence may be received by the built-in proc &lt;code&gt;low()&lt;/code&gt;, the higher bound by &lt;code&gt;high()&lt;/code&gt;. The length may be received by &lt;code&gt;len()&lt;/code&gt;. &lt;code&gt;low()&lt;/code&gt; for a sequence or an open array always returns 0, as this is the first valid index. One can append elements to a sequence with the &lt;code&gt;add()&lt;/code&gt; proc or the &lt;code&gt;&amp;amp;&lt;/code&gt; operator, and remove (and get) the last element of a sequence with the &lt;code&gt;pop()&lt;/code&gt; proc.</source>
          <target state="translated">数组或序列的下限可由内置的proc &lt;code&gt;low()&lt;/code&gt; 接收，上限由 &lt;code&gt;high()&lt;/code&gt; 接收。该长度可以由 &lt;code&gt;len()&lt;/code&gt; 接收。序列或开放数组的 &lt;code&gt;low()&lt;/code&gt; 始终返回0，因为这是第一个有效索引。可以使用 &lt;code&gt;add()&lt;/code&gt; proc或 &lt;code&gt;&amp;amp;&lt;/code&gt; 运算符将元素追加到序列中，并使用 &lt;code&gt;pop()&lt;/code&gt; proc 删除（并获取）序列的最后一个元素。</target>
        </trans-unit>
        <trans-unit id="5734f010cce3ed3e6eb9ebff7381b95381124003" translate="yes" xml:space="preserve">
          <source>The macro call expands to:</source>
          <target state="translated">宏调用扩展到。</target>
        </trans-unit>
        <trans-unit id="ba15c60c9b85487537b51042f4adcf6c970f986b" translate="yes" xml:space="preserve">
          <source>The manual mentions that &lt;a href=&quot;manual#cstring-type&quot;&gt;Nim strings are implicitly convertible to cstrings&lt;/a&gt; which makes interaction usually painless. Most C functions accepting a Nim string converted to a &lt;code&gt;cstring&lt;/code&gt; will likely not need to keep this string around and by the time they return the string won't be needed any more. However, for the rare cases where a Nim string has to be preserved and made available to the C backend as a &lt;code&gt;cstring&lt;/code&gt;, you will need to manually prevent the string data from being freed with &lt;a href=&quot;system#GC_ref&quot;&gt;GC_ref&lt;/a&gt; and &lt;a href=&quot;system#GC_unref&quot;&gt;GC_unref&lt;/a&gt;.</source>
          <target state="translated">该手册提到&lt;a href=&quot;manual#cstring-type&quot;&gt;Nim字符串可以隐式转换为cstring&lt;/a&gt;，这通常使交互变得轻松。大多数接受将Nim字符串转换为 &lt;code&gt;cstring&lt;/code&gt; 的 C函数都可能不需要保留该字符串，并且在它们返回时不再需要该字符串。但是，在极少数情况下，必须保留Nim字符串并以 &lt;code&gt;cstring&lt;/code&gt; 的形式提供给C后端，您需要手动防止使用&lt;a href=&quot;system#GC_ref&quot;&gt;GC_ref&lt;/a&gt;和&lt;a href=&quot;system#GC_unref&quot;&gt;GC_unref&lt;/a&gt;释放字符串数据。</target>
        </trans-unit>
        <trans-unit id="a4e04e7f0f6d6096c8019755aeb455838200906b" translate="yes" xml:space="preserve">
          <source>The manual mentions that &lt;a href=&quot;manual#types-cstring-type&quot;&gt;Nim strings are implicitly convertible to cstrings&lt;/a&gt; which makes interaction usually painless. Most C functions accepting a Nim string converted to a &lt;code&gt;cstring&lt;/code&gt; will likely not need to keep this string around and by the time they return the string won't be needed anymore. However, for the rare cases where a Nim string has to be preserved and made available to the C backend as a &lt;code&gt;cstring&lt;/code&gt;, you will need to manually prevent the string data from being freed with &lt;a href=&quot;system#GC_ref,string&quot;&gt;GC_ref&lt;/a&gt; and &lt;a href=&quot;system#GC_unref,string&quot;&gt;GC_unref&lt;/a&gt;.</source>
          <target state="translated">该手册提到&lt;a href=&quot;manual#types-cstring-type&quot;&gt;Nim字符串可以隐式转换为cstring&lt;/a&gt;，这通常使交互变得轻松。大多数接受将Nim字符串转换为 &lt;code&gt;cstring&lt;/code&gt; 的C函数都可能不需要保留该字符串，并且在它们返回该字符串时，将不再需要该字符串。但是，在极少数情况下，必须保留Nim字符串并以 &lt;code&gt;cstring&lt;/code&gt; 的形式提供给C后端，您需要手动防止使用&lt;a href=&quot;system#GC_ref,string&quot;&gt;GC_ref&lt;/a&gt;和&lt;a href=&quot;system#GC_unref,string&quot;&gt;GC_unref&lt;/a&gt;释放字符串数据。</target>
        </trans-unit>
        <trans-unit id="d055cba0dbcd824c3d51d9d663b957c1d43495ed" translate="yes" xml:space="preserve">
          <source>The matched dot operators can be symbols of any callable kind (procs, templates and macros), depending on the desired effect:</source>
          <target state="translated">匹配的点运算符可以是任何可调用种类的符号(procs、模板和宏),这取决于所需的效果。</target>
        </trans-unit>
        <trans-unit id="aa302af914c04b9a452351c8217335cf34464abe" translate="yes" xml:space="preserve">
          <source>The matching AST must be a call/apply expression.</source>
          <target state="translated">匹配的AST必须是一个调用/应用表达式。</target>
        </trans-unit>
        <trans-unit id="0b44d6a083a904cecf3aef26278e11886b2e549d" translate="yes" xml:space="preserve">
          <source>The matching AST must be an lvalue.</source>
          <target state="translated">匹配的AST必须是一个l值。</target>
        </trans-unit>
        <trans-unit id="9fac33d3e99596d75ad6eeca948e5afafcf536ac" translate="yes" xml:space="preserve">
          <source>The matching AST must have a side effect.</source>
          <target state="translated">匹配的AST必须有副作用。</target>
        </trans-unit>
        <trans-unit id="62342d8683b403d83a8513c785f6aafa6bfbd8b4" translate="yes" xml:space="preserve">
          <source>The matching AST must have no side effect.</source>
          <target state="translated">匹配的AST必须没有副作用。</target>
        </trans-unit>
        <trans-unit id="5661a426b593f52c0ca7fa90eafc833175b21253" translate="yes" xml:space="preserve">
          <source>The matching AST must have the specified kind. (Example: &lt;code&gt;nkIfStmt&lt;/code&gt; denotes an &lt;code&gt;if&lt;/code&gt; statement.)</source>
          <target state="translated">匹配的AST必须具有指定的种类。（示例： &lt;code&gt;nkIfStmt&lt;/code&gt; 表示一个 &lt;code&gt;if&lt;/code&gt; 语句。）</target>
        </trans-unit>
        <trans-unit id="eb0f0fe081b64818b6b3016af8a01416e217ed1f" translate="yes" xml:space="preserve">
          <source>The matching is performed after the compiler performed some optimizations like constant folding, so the following does not work:</source>
          <target state="translated">匹配是在编译器进行了一些优化后进行的,比如恒定的折叠,所以下面就不能用了。</target>
        </trans-unit>
        <trans-unit id="25c9e6f14aaa1c25059b8a65928452c58ffeac86" translate="yes" xml:space="preserve">
          <source>The matching node has no children.</source>
          <target state="translated">匹配的节点没有子节点。</target>
        </trans-unit>
        <trans-unit id="3bee02bd8ec9e041895cdd7f8534811610597c81" translate="yes" xml:space="preserve">
          <source>The matching node is a literal like &quot;abc&quot;, 12.</source>
          <target state="translated">匹配的节点是像 &quot;abc &quot;这样的文字,12.</target>
        </trans-unit>
        <trans-unit id="721eb0da3439ce9f34194a03def0ba45ab30e608" translate="yes" xml:space="preserve">
          <source>The matching node must be a symbol (a bound identifier).</source>
          <target state="translated">匹配的节点必须是一个符号(绑定标识符)。</target>
        </trans-unit>
        <trans-unit id="be1a3bab050b769c30c8177fd935188143910209" translate="yes" xml:space="preserve">
          <source>The matching node must be an identifier (an unbound identifier).</source>
          <target state="translated">匹配的节点必须是一个标识符(非绑定标识符)。</target>
        </trans-unit>
        <trans-unit id="4f8a620db21ad017e74d603c8e4851fa5f18d228" translate="yes" xml:space="preserve">
          <source>The maximum content-length that will be read for the body.</source>
          <target state="translated">读取正文的最大内容长度。</target>
        </trans-unit>
        <trans-unit id="c950d90d5b11970c79ac7afd395e119a17d543c0" translate="yes" xml:space="preserve">
          <source>The maximum file size limit that &lt;code&gt;staticRead&lt;/code&gt; and &lt;code&gt;slurp&lt;/code&gt; can read is near or equal to the &lt;em&gt;free&lt;/em&gt; memory of the device you are using to compile.</source>
          <target state="translated">最大文件大小限制 &lt;code&gt;staticRead&lt;/code&gt; 和 &lt;code&gt;slurp&lt;/code&gt; 可以读取接近或等于&lt;em&gt;免费&lt;/em&gt;使用的是编译器的内存。</target>
        </trans-unit>
        <trans-unit id="eddb524c9857d48d426ebc459d6731f3dbdd9f9e" translate="yes" xml:space="preserve">
          <source>The maximum redirects can be set with the &lt;code&gt;maxRedirects&lt;/code&gt; of &lt;code&gt;int&lt;/code&gt; type, it specifies the maximum amount of redirects to follow, it defaults to &lt;code&gt;5&lt;/code&gt;, you can set it to &lt;code&gt;0&lt;/code&gt; to disable redirects.</source>
          <target state="translated">最大重定向可以与设置 &lt;code&gt;maxRedirects&lt;/code&gt; 的 &lt;code&gt;int&lt;/code&gt; 类型时，它指定重定向的最大量跟随，则默认为 &lt;code&gt;5&lt;/code&gt; ，则可以将其设置为 &lt;code&gt;0&lt;/code&gt; ，以禁止重新导向。</target>
        </trans-unit>
        <trans-unit id="d3ed4b73757fde9ceb2aef3183ba998698e7a6f6" translate="yes" xml:space="preserve">
          <source>The maximum value of &lt;code&gt;x&lt;/code&gt;. &lt;code&gt;T&lt;/code&gt; needs to have a &lt;code&gt;&amp;lt;&lt;/code&gt; operator.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 的最大值。 &lt;code&gt;T&lt;/code&gt; 需要有一个 &lt;code&gt;&amp;lt;&lt;/code&gt; 运算符。</target>
        </trans-unit>
        <trans-unit id="43fd98d19fce24bd57a3a5dd301ed84cfd20f560" translate="yes" xml:space="preserve">
          <source>The maximum value of &lt;em&gt;x&lt;/em&gt;. &lt;code&gt;T&lt;/code&gt; needs to have a &lt;code&gt;&amp;lt;&lt;/code&gt; operator.</source>
          <target state="translated">&lt;em&gt;x&lt;/em&gt;的最大值。 &lt;code&gt;T&lt;/code&gt; 需要有一个 &lt;code&gt;&amp;lt;&lt;/code&gt; 运算符。</target>
        </trans-unit>
        <trans-unit id="5d2d6e30267d2820d060080987be5a5b7a4f91f3" translate="yes" xml:space="preserve">
          <source>The maximum value of two integers.</source>
          <target state="translated">两个整数的最大值。</target>
        </trans-unit>
        <trans-unit id="ea3e62d4781ad1dfcb8a4591e57dc4622e4ae0f5" translate="yes" xml:space="preserve">
          <source>The memory management for Nim's standard &lt;code&gt;string&lt;/code&gt; and &lt;code&gt;seq&lt;/code&gt; types as well as other standard collections is performed via so-called &quot;Lifetime-tracking hooks&quot; or &quot;type-bound operators&quot;. There are 3 different hooks for each (generic or concrete) object type &lt;code&gt;T&lt;/code&gt; (&lt;code&gt;T&lt;/code&gt; can also be a &lt;code&gt;distinct&lt;/code&gt; type) that are called implicitly by the compiler.</source>
          <target state="translated">Nim的标准 &lt;code&gt;string&lt;/code&gt; 和 &lt;code&gt;seq&lt;/code&gt; 类型以及其他标准集合的内存管理是通过所谓的&amp;ldquo;生命周期跟踪挂钩&amp;rdquo;或&amp;ldquo;类型绑定运算符&amp;rdquo;执行的。每种（通用或具体）对象类型 &lt;code&gt;T&lt;/code&gt; （都有 &lt;code&gt;T&lt;/code&gt; ，也可以是 &lt;code&gt;distinct&lt;/code&gt; 类型）有3个不同的钩子，它们由编译器隐式调用。</target>
        </trans-unit>
        <trans-unit id="bb9b388505eb1fb774570095acc72dd570fedb16" translate="yes" xml:space="preserve">
          <source>The method call syntax conflicts with explicit generic instantiations: &lt;code&gt;p[T](x)&lt;/code&gt; cannot be written as &lt;code&gt;x.p[T]&lt;/code&gt; because &lt;code&gt;x.p[T]&lt;/code&gt; is always parsed as &lt;code&gt;(x.p)[T]&lt;/code&gt;.</source>
          <target state="translated">方法调用语法与显式泛型实例化冲突： &lt;code&gt;p[T](x)&lt;/code&gt; 不能写为 &lt;code&gt;x.p[T]&lt;/code&gt; 因为 &lt;code&gt;x.p[T]&lt;/code&gt; 始终被解析为 &lt;code&gt;(x.p)[T]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e29a37d51a470bd093573ef80de02da80f8ae42c" translate="yes" xml:space="preserve">
          <source>The minimum value of &lt;code&gt;x&lt;/code&gt;. &lt;code&gt;T&lt;/code&gt; needs to have a &lt;code&gt;&amp;lt;&lt;/code&gt; operator.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 的最小值。 &lt;code&gt;T&lt;/code&gt; 需要有一个 &lt;code&gt;&amp;lt;&lt;/code&gt; 运算符。</target>
        </trans-unit>
        <trans-unit id="a0ef8bda90a06a0c3f6e30dace9ed42593b23481" translate="yes" xml:space="preserve">
          <source>The minimum value of &lt;em&gt;x&lt;/em&gt;. &lt;code&gt;T&lt;/code&gt; needs to have a &lt;code&gt;&amp;lt;&lt;/code&gt; operator.</source>
          <target state="translated">&lt;em&gt;x&lt;/em&gt;的最小值。 &lt;code&gt;T&lt;/code&gt; 需要有一个 &lt;code&gt;&amp;lt;&lt;/code&gt; 运算符。</target>
        </trans-unit>
        <trans-unit id="6382aa6ed7dc87e04b1c5dfd0efac1c3cf2ff114" translate="yes" xml:space="preserve">
          <source>The minimum value of two integers.</source>
          <target state="translated">两个整数的最小值。</target>
        </trans-unit>
        <trans-unit id="42618bccaa1614ff3af2e91f3ca07f6ebdc8c5aa" translate="yes" xml:space="preserve">
          <source>The minutes in 1 digit if possible.</source>
          <target state="translated">如果可能的话,分钟数为1位数。</target>
        </trans-unit>
        <trans-unit id="8120849383a0dce81fbc77edaa154da4bae069f9" translate="yes" xml:space="preserve">
          <source>The minutes in one digit if possible.</source>
          <target state="translated">如果可能的话,分钟数为一位数。</target>
        </trans-unit>
        <trans-unit id="5a6835c438c5815928aa2df14ad04c857ef1631d" translate="yes" xml:space="preserve">
          <source>The module contains a default Rand state for convenience. It corresponds to the default random number generator's state. The default Rand state always starts with the same values, but the &lt;a href=&quot;#randomize&quot;&gt;randomize proc&lt;/a&gt; can be used to seed the default generator with a value based on the current time.</source>
          <target state="translated">为了方便起见，该模块包含默认的兰德状态。它对应于默认随机数生成器的状态。默认的Rand状态始终以相同的值开头，但是可以使用&lt;a href=&quot;#randomize&quot;&gt;randomize proc&lt;/a&gt;将基于当前时间的值作为默认生成器的种子。</target>
        </trans-unit>
        <trans-unit id="5990e415167b1e53c0b5e58fc592b231b04e133e" translate="yes" xml:space="preserve">
          <source>The module will fallback to pure nim procs incase the backend is not supported. You can also use the flag &lt;code&gt;noIntrinsicsBitOpts&lt;/code&gt; to disable compiler intrinsics.</source>
          <target state="translated">如果不支持后端，该模块将回退到纯nim proc。您还可以使用标志 &lt;code&gt;noIntrinsicsBitOpts&lt;/code&gt; 禁用编译器内部函数。</target>
        </trans-unit>
        <trans-unit id="b3095d9956a51342dd5a97c0ff4d61f08e5b0b7f" translate="yes" xml:space="preserve">
          <source>The module will fallback to pure nim procs incase the backend is not supported. You can also use the flag &lt;em&gt;noIntrinsicsBitOpts&lt;/em&gt; to disable compiler intrinsics.</source>
          <target state="translated">如果不支持后端，该模块将回退到纯nim proc。您还可以使用标志&lt;em&gt;noIntrinsicsBitOpts&lt;/em&gt;禁用编译器内部函数。</target>
        </trans-unit>
        <trans-unit id="cd9fc72b4ada2f752486fbb515d1c9c09d7aa8f3" translate="yes" xml:space="preserve">
          <source>The month as an enum, the ordinal value is in the range 1 to 12.</source>
          <target state="translated">月份作为一个枚举,序数值的范围是1到12。</target>
        </trans-unit>
        <trans-unit id="8e065869153c9cf19339eeb5fe17bfa8010a6236" translate="yes" xml:space="preserve">
          <source>The month in one digit if possible.</source>
          <target state="translated">如果可能的话,月份以一位数表示。</target>
        </trans-unit>
        <trans-unit id="8ffdd973b77981374afa6bab23748caa6eb3c1fe" translate="yes" xml:space="preserve">
          <source>The month in two digits always. 0 is prepended if the month value is one digit.</source>
          <target state="translated">月份总是以两位数表示。如果月份值是一位数,则在前面加上0。</target>
        </trans-unit>
        <trans-unit id="8eb37896b3a59b2013774ad8a8bc6115389438f2" translate="yes" xml:space="preserve">
          <source>The month in two digits always. 0 is prepended.</source>
          <target state="translated">月份总是以两位数表示。0为前缀。</target>
        </trans-unit>
        <trans-unit id="9b7d512c82e7ce84b958ad19e901783b62720ac2" translate="yes" xml:space="preserve">
          <source>The most important reason for RTTI. Generating traversal procedures produces bigger code and is likely to be slower on modern hardware as dynamic procedure binding is hard to predict.</source>
          <target state="translated">RTTI的最重要原因。生成遍历过程会产生更大的代码,而且在现代硬件上可能会更慢,因为动态过程绑定很难预测。</target>
        </trans-unit>
        <trans-unit id="cf6c2e2953025ff455ecd8b6b1f063d8970db911" translate="yes" xml:space="preserve">
          <source>The most reliable way to handle exceptions is to use &lt;code&gt;yield&lt;/code&gt; on a future then check the future's &lt;code&gt;failed&lt;/code&gt; property. For example:</source>
          <target state="translated">处理异常的最可靠方法是在 &lt;code&gt;yield&lt;/code&gt; 上使用yield，然后检查Future的 &lt;code&gt;failed&lt;/code&gt; 属性。例如：</target>
        </trans-unit>
        <trans-unit id="abac663a9e4ad29972ddcc95fc577538bbcbd3dd" translate="yes" xml:space="preserve">
          <source>The most significant difference between these commands is that if you look into the &lt;code&gt;nimcache&lt;/code&gt; directory you will find &lt;code&gt;.c&lt;/code&gt;, &lt;code&gt;.cpp&lt;/code&gt; or &lt;code&gt;.m&lt;/code&gt; files, other than that all of them will produce a native binary for your project. This allows you to take the generated code and place it directly into a project using any of these languages. Here are some typical command line invocations:</source>
          <target state="translated">这些命令之间最显着的区别是，如果查看 &lt;code&gt;nimcache&lt;/code&gt; 目录，则会找到 &lt;code&gt;.c&lt;/code&gt; ， &lt;code&gt;.cpp&lt;/code&gt; 或 &lt;code&gt;.m&lt;/code&gt; 文件，除此之外，所有这些文件都会为您的项目生成本机二进制文件。这使您可以采用生成的代码，并使用任何这些语言将其直接放入项目中。以下是一些典型的命令行调用：</target>
        </trans-unit>
        <trans-unit id="a72f50212d0085eb823c7d6f12ded16312fb8518" translate="yes" xml:space="preserve">
          <source>The most significant difference between these commands is that if you look into the &lt;code&gt;nimcache&lt;/code&gt; directory you will find &lt;code&gt;.c&lt;/code&gt;, &lt;code&gt;.cpp&lt;/code&gt; or &lt;code&gt;.m&lt;/code&gt; files, other than that all of them will produce a native binary for your project. This allows you to take the generated code and place it directly into a project using any of these languages. Here are some typical command- line invocations:</source>
          <target state="translated">这些命令之间最显着的区别是，如果查看 &lt;code&gt;nimcache&lt;/code&gt; 目录，则会找到 &lt;code&gt;.c&lt;/code&gt; ， &lt;code&gt;.cpp&lt;/code&gt; 或 &lt;code&gt;.m&lt;/code&gt; 文件，除此之外，所有这些文件都会为您的项目生成本机二进制文件。这使您可以采用生成的代码，并使用这些语言中的任何一种将其直接放置到项目中。以下是一些典型的命令行调用：</target>
        </trans-unit>
        <trans-unit id="69f05063edc5202ee9c72c0096b575ad8468f147" translate="yes" xml:space="preserve">
          <source>The name of the timezone.</source>
          <target state="translated">时区的名称。</target>
        </trans-unit>
        <trans-unit id="ec06ca30d3763f24610615079488aee1dec49148" translate="yes" xml:space="preserve">
          <source>The need to check for self-assignments and also the need to destroy previous objects inside &lt;code&gt;=copy&lt;/code&gt; and &lt;code&gt;=sink&lt;/code&gt; is a strong indicator to treat &lt;code&gt;system.swap&lt;/code&gt; as a builtin primitive of its own that simply swaps every field in the involved objects via &lt;code&gt;copyMem&lt;/code&gt; or a comparable mechanism. In other words, &lt;code&gt;swap(a, b)&lt;/code&gt; is &lt;strong&gt;not&lt;/strong&gt; implemented as &lt;code&gt;let tmp = move(b); b = move(a); a = move(tmp)&lt;/code&gt;.</source>
          <target state="translated">需要检查自我分配，还需要销毁 &lt;code&gt;=copy&lt;/code&gt; 和 &lt;code&gt;=sink&lt;/code&gt; 中的先前对象，这是将 &lt;code&gt;system.swap&lt;/code&gt; 视为其自身的内置原语的强大指示器，它可以简单地通过 &lt;code&gt;copyMem&lt;/code&gt; 或一种可比的机制。换言之， &lt;code&gt;swap(a, b)&lt;/code&gt; 是&lt;strong&gt;未&lt;/strong&gt;实现为 &lt;code&gt;let tmp = move(b); b = move(a); a = move(tmp)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f458d384ea0910910144b31e2bb7acec5965f32b" translate="yes" xml:space="preserve">
          <source>The normal &lt;code&gt;import&lt;/code&gt; statement will bring in all exported symbols. These can be limited by naming symbols which should be excluded with the &lt;code&gt;except&lt;/code&gt; qualifier.</source>
          <target state="translated">正常的 &lt;code&gt;import&lt;/code&gt; 语句将引入所有导出的符号。这些可以通过命名符号来加以限制，这些符号应被排除在限定符 &lt;code&gt;except&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="629262f7b72a57e5a72d86066221973769332f9a" translate="yes" xml:space="preserve">
          <source>The normal operation mode is called &lt;code&gt;ProcRun&lt;/code&gt; and it involves starting a process for each command or query, similar to running manually the Nim compiler from the commandline. The &lt;code&gt;CaasRun&lt;/code&gt; mode starts a server process to answer all queries. The &lt;code&gt;SymbolProcRun&lt;/code&gt; mode is used by compiler developers. This means that running all tests involves processing all &lt;code&gt;*.txt&lt;/code&gt; files three times, which can be quite time consuming.</source>
          <target state="translated">正常操作模式称为 &lt;code&gt;ProcRun&lt;/code&gt; ，它涉及为每个命令或查询启动一个过程，类似于从命令行手动运行Nim编译器。该 &lt;code&gt;CaasRun&lt;/code&gt; 模式启动一个服务器进程来回答所有问题。该 &lt;code&gt;SymbolProcRun&lt;/code&gt; 模式由编译器开发人员使用。这意味着运行所有测试涉及对所有 &lt;code&gt;*.txt&lt;/code&gt; 文件进行三次处理，这可能非常耗时。</target>
        </trans-unit>
        <trans-unit id="4bae69dda155aa8a4d14da3a2fc6579a9ca759df" translate="yes" xml:space="preserve">
          <source>The notation &lt;code&gt;x[i]&lt;/code&gt; can be used to access the i-th element of &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;x[i]&lt;/code&gt; 表示法可用于访问 &lt;code&gt;x&lt;/code&gt; 的第i个元素。</target>
        </trans-unit>
        <trans-unit id="658eabb7c8362bd8ccc2db983d207e849c519eb7" translate="yes" xml:space="preserve">
          <source>The notation &lt;code&gt;x[i]&lt;/code&gt; is used to access the i-th element of &lt;code&gt;x&lt;/code&gt;. Array access is always bounds checked (at compile-time or at runtime). These checks can be disabled via pragmas or invoking the compiler with the &lt;code&gt;--bound_checks:off&lt;/code&gt; command line switch.</source>
          <target state="translated">&lt;code&gt;x[i]&lt;/code&gt; 表示法用于访问 &lt;code&gt;x&lt;/code&gt; 的第i个元素。始终对数组访问进行边界检查（在编译时或运行时）。可以通过编译指示或使用 &lt;code&gt;--bound_checks:off&lt;/code&gt; 命令行开关调用编译器来禁用这些检查。</target>
        </trans-unit>
        <trans-unit id="84253c85ff2fe63ceae34cee869e8056c8618b6f" translate="yes" xml:space="preserve">
          <source>The notation used for a PEG is similar to that of EBNF:</source>
          <target state="translated">PEG使用的符号与EBNF类似。</target>
        </trans-unit>
        <trans-unit id="35c5176abc505099c32f5f56c77ef46929971143" translate="yes" xml:space="preserve">
          <source>The number of bytes belonging to 's[i]' including following combining characters.</source>
          <target state="translated">属于's[i]'的字节数,包括以下组合字符。</target>
        </trans-unit>
        <trans-unit id="0766850e8af24901ac224e38448b654947018953" translate="yes" xml:space="preserve">
          <source>The number of bytes belonging to byte index &lt;code&gt;s[i]&lt;/code&gt;, including following combining code unit.</source>
          <target state="translated">属于字节索引 &lt;code&gt;s[i]&lt;/code&gt; 的字节数，包括以下组合代码单元。</target>
        </trans-unit>
        <trans-unit id="d9a065c415acb39bca6dfbf84627b78c96bd774e" translate="yes" xml:space="preserve">
          <source>The number of days since January 1, in the range 0 to 365.</source>
          <target state="translated">1月1日以来的天数,范围为0至365天。</target>
        </trans-unit>
        <trans-unit id="9c4bc3865db45d046e1df4ff74764ae23a55e1d4" translate="yes" xml:space="preserve">
          <source>The number of hours past midnight, in the range 0 to 23.</source>
          <target state="translated">午夜过后的小时数,范围为0至23。</target>
        </trans-unit>
        <trans-unit id="f52a4ac082994b235155e44e2290132cb04c90c6" translate="yes" xml:space="preserve">
          <source>The number of minutes after the hour, in the range 0 to 59.</source>
          <target state="translated">小时后的分钟数,范围是0到59。</target>
        </trans-unit>
        <trans-unit id="f3348856fb20c7700d32dbefabea6931ef860b4c" translate="yes" xml:space="preserve">
          <source>The number of nanoseconds after the second, in the range 0 to 999_999_999.</source>
          <target state="translated">秒后的纳秒数,范围为0~999_999_999。</target>
        </trans-unit>
        <trans-unit id="50e92dae4acdb9d413c25e9143865ccec7ea6c1c" translate="yes" xml:space="preserve">
          <source>The number of seconds after the minute, in the range 0 to 59.</source>
          <target state="translated">分钟后的秒数,范围为0至59。</target>
        </trans-unit>
        <trans-unit id="67410fb726aaa716bc56a897729095f56b009d39" translate="yes" xml:space="preserve">
          <source>The numbers count the number of objects in all GC heaps, they refer to all running threads, not only to the current thread. (The current thread would be the thread that calls &lt;code&gt;dumpNumberOfInstances&lt;/code&gt;.) This might change in later versions.</source>
          <target state="translated">这些数字计算所有GC堆中的对象数量，它们引用所有正在运行的线程，而不仅是当前线程。（当前线程将是调用 &lt;code&gt;dumpNumberOfInstances&lt;/code&gt; 的线程。）在更高版本中，这可能会更改。</target>
        </trans-unit>
        <trans-unit id="06fbf19ead5eb4522c5f0e525c80f22c80dfd57c" translate="yes" xml:space="preserve">
          <source>The numbers count the number of objects in all garbage collector heaps, they refer to all running threads, not only to the current thread. (The current thread would be the thread that calls &lt;code&gt;dumpNumberOfInstances&lt;/code&gt;.) This might change in later versions.</source>
          <target state="translated">这些数字用于统计所有垃圾收集器堆中的对象数，它们引用所有正在运行的线程，而不仅仅是当前线程。（当前线程将是调用 &lt;code&gt;dumpNumberOfInstances&lt;/code&gt; 的线程。）在更高版本中，这可能会更改。</target>
        </trans-unit>
        <trans-unit id="943d32e77792f1b379a556185254f33101e23b55" translate="yes" xml:space="preserve">
          <source>The numerical identifier is just a random number. The number gets assigned according to the section and position of the symbol in the file being processed and you should not rely on it being constant: if you add or remove a symbol the numbers may shuffle around.</source>
          <target state="translated">数字标识符只是一个随机数。数字会根据文件中符号的部分和位置进行分配,您不应该依赖它的恒定性:如果您添加或删除一个符号,数字可能会随机变化。</target>
        </trans-unit>
        <trans-unit id="727a603933eb24259acf39e94c54b8c8c69ecf4d" translate="yes" xml:space="preserve">
          <source>The occasional use of idetools is acceptable for things like definitions, where the user puts the cursor on a symbol or double clicks it and after a second or two the IDE displays where that symbol is defined. Such latencies would be terrible for features like symbol suggestion, plus why wait at all if we can avoid it?</source>
          <target state="translated">偶尔使用idetools是可以接受的,比如定义,用户把光标放在一个符号上或者双击它,一两秒钟后IDE就会显示出这个符号被定义的位置。这样的延迟对于像符号建议这样的功能来说是很糟糕的,另外,如果我们能避免这样的延迟,为什么还要等待呢?</target>
        </trans-unit>
        <trans-unit id="25d3919cb8bebc916c007785d723e89c51ae1b68" translate="yes" xml:space="preserve">
          <source>The offset in seconds west of UTC, including any offset due to DST. Note that the sign of this number is the opposite of the one in a formatted offset string like &lt;code&gt;+01:00&lt;/code&gt; (which would be equivalent to the UTC offset &lt;code&gt;-3600&lt;/code&gt;).</source>
          <target state="translated">UTC以西的秒数偏移量，包括由于DST引起的任何偏移量。请注意，该数字的符号与格式偏移字符串（如 &lt;code&gt;+01:00&lt;/code&gt; )相对应（与UTC偏移 &lt;code&gt;-3600&lt;/code&gt; 等效）。</target>
        </trans-unit>
        <trans-unit id="37994ecd43903ca9e4ef6ac25795c9cd0cb6d035" translate="yes" xml:space="preserve">
          <source>The only case where things aren't as easy is when the garbage collector needs some assembler tweaking to work. The standard version of the GC uses C's &lt;code&gt;setjmp&lt;/code&gt; function to store all registers on the hardware stack. It may be necessary that the new platform needs to replace this generic code by some assembler code.</source>
          <target state="translated">唯一不那么容易的情况是，垃圾收集器需要一些汇编器调整才能工作。GC的标准版本使用C的 &lt;code&gt;setjmp&lt;/code&gt; 函数将所有寄存器存储在硬件堆栈上。新平台可能需要用某些汇编代码替换该通用代码。</target>
        </trans-unit>
        <trans-unit id="e2f49d4957d979510c6bf361e27282ecac40ce06" translate="yes" xml:space="preserve">
          <source>The only difference between the contents of that file and the values provided by this proc is the &lt;code&gt;doc.file&lt;/code&gt; variable. The &lt;code&gt;doc.file&lt;/code&gt; variable of the configuration file contains HTML to build standalone pages, while this proc returns just the content for procs like &lt;code&gt;rstToHtml&lt;/code&gt; to generate the bare minimum HTML.</source>
          <target state="translated">该文件的内容与该proc提供的值之间的唯一区别是 &lt;code&gt;doc.file&lt;/code&gt; 变量。配置文件的 &lt;code&gt;doc.file&lt;/code&gt; 变量包含用于构建独立页面的HTML，而此proc仅返回诸如 &lt;code&gt;rstToHtml&lt;/code&gt; 之类的proc内容以生成最少的HTML。</target>
        </trans-unit>
        <trans-unit id="66d1058ab09e19fbf4fbe3d6ea05970103c3b41c" translate="yes" xml:space="preserve">
          <source>The only operations that are affected by the &lt;code&gt;floatChecks&lt;/code&gt; pragma are the &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;/&lt;/code&gt; operators for floating point types.</source>
          <target state="translated">唯一受 &lt;code&gt;floatChecks&lt;/code&gt; 编译指示影响的运算是浮点类型的 &lt;code&gt;+&lt;/code&gt; ， &lt;code&gt;-&lt;/code&gt; ， &lt;code&gt;*&lt;/code&gt; ， &lt;code&gt;/&lt;/code&gt; 运算符。</target>
        </trans-unit>
        <trans-unit id="899d5fc602ad3db90bd279ddd77881c1cca58eeb" translate="yes" xml:space="preserve">
          <source>The only operations that are affected by the &lt;code&gt;floatChecks&lt;/code&gt; pragma are the &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;/&lt;/code&gt; operators for floating-point types.</source>
          <target state="translated">唯一受 &lt;code&gt;floatChecks&lt;/code&gt; 编译指示影响的操作是浮点类型的 &lt;code&gt;+&lt;/code&gt; ， &lt;code&gt;-&lt;/code&gt; ， &lt;code&gt;*&lt;/code&gt; ， &lt;code&gt;/&lt;/code&gt; 运算符。</target>
        </trans-unit>
        <trans-unit id="168d790e853cbd9034f71729f2476481319d159c" translate="yes" xml:space="preserve">
          <source>The openarray type cannot be nested: multidimensional openarrays are not supported because this is seldom needed and cannot be done efficiently.</source>
          <target state="translated">openarray类型不能嵌套:不支持多维openarray,因为很少需要这样做,而且不能有效地完成。</target>
        </trans-unit>
        <trans-unit id="c4e0647a4c89f8b16abd9dcace05bac8931235f1" translate="yes" xml:space="preserve">
          <source>The operation is performed atomically and other operations on the table will be blocked while the &lt;code&gt;mapper&lt;/code&gt; is invoked, so it should be short and simple.</source>
          <target state="translated">该操作是原子执行的，并且在调用 &lt;code&gt;mapper&lt;/code&gt; 将阻止对表的其他操作，因此它应该简短而简单。</target>
        </trans-unit>
        <trans-unit id="83ab7b4d2bb2233e5f2fab96873b663a53e9e12f" translate="yes" xml:space="preserve">
          <source>The operation produced a result that cannot be represented with infinite precision -- for example: &lt;code&gt;2.0 / 3.0, log(1.1)&lt;/code&gt;</source>
          <target state="translated">该操作产生的结果无法无限精确地表示-例如： &lt;code&gt;2.0 / 3.0, log(1.1)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8377f7d618fcf4075ebaa21071b51f158edf57be" translate="yes" xml:space="preserve">
          <source>The operation produced a result that exceeds the range of the exponent.</source>
          <target state="translated">操作产生的结果超过了指数的范围。</target>
        </trans-unit>
        <trans-unit id="33f13b87dbb9bcf04674b0e7829c348aac46fcd6" translate="yes" xml:space="preserve">
          <source>The operation produced a result that is too small to be represented as a normal number.</source>
          <target state="translated">操作产生的结果太小,无法用普通数表示。</target>
        </trans-unit>
        <trans-unit id="941ce1be2e887859312d9d5ab72c51d7733f52a5" translate="yes" xml:space="preserve">
          <source>The operator's precedence is determined by its first character. The details can be found in the manual.</source>
          <target state="translated">操作员的优先级由其第一个字符决定。详细内容可以在手册中找到。</target>
        </trans-unit>
        <trans-unit id="c0e839d05d73521d7af47a856f782f7c30977b0c" translate="yes" xml:space="preserve">
          <source>The operators &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;**&lt;/code&gt;, &lt;code&gt;|&lt;/code&gt;, &lt;code&gt;~&lt;/code&gt; have a special meaning in patterns if they are written in infix notation.</source>
          <target state="translated">运算符 &lt;code&gt;*&lt;/code&gt; ， &lt;code&gt;**&lt;/code&gt; ， &lt;code&gt;|&lt;/code&gt; ， &lt;code&gt;~&lt;/code&gt; 如果以后缀符号表示，则在模式中具有特殊含义。</target>
        </trans-unit>
        <trans-unit id="bf012723c5a2a5eb3b690eb90475c06700cb84be" translate="yes" xml:space="preserve">
          <source>The operators &lt;code&gt;not, and, or, xor, &amp;lt;, &amp;lt;=, &amp;gt;, &amp;gt;=, !=, ==&lt;/code&gt; are defined for the bool type. The &lt;code&gt;and&lt;/code&gt; and &lt;code&gt;or&lt;/code&gt; operators perform short-circuit evaluation. For example:</source>
          <target state="translated">为布尔类型定义了运算符 &lt;code&gt;not, and, or, xor, &amp;lt;, &amp;lt;=, &amp;gt;, &amp;gt;=, !=, ==&lt;/code&gt; 。的 &lt;code&gt;and&lt;/code&gt; 和 &lt;code&gt;or&lt;/code&gt; 运算符执行短路评价。例如：</target>
        </trans-unit>
        <trans-unit id="5a6dbe81c71ecdddbb102d68881f2f73beabe16e" translate="yes" xml:space="preserve">
          <source>The operators &lt;code&gt;not, and, or, xor, &amp;lt;, &amp;lt;=, &amp;gt;, &amp;gt;=, !=, ==&lt;/code&gt; are defined for the bool type. The &lt;code&gt;and&lt;/code&gt; and &lt;code&gt;or&lt;/code&gt; operators perform short-cut evaluation. Example:</source>
          <target state="translated">为布尔类型定义了运算符 &lt;code&gt;not, and, or, xor, &amp;lt;, &amp;lt;=, &amp;gt;, &amp;gt;=, !=, ==&lt;/code&gt; 。在 &lt;code&gt;and&lt;/code&gt; 和 &lt;code&gt;or&lt;/code&gt; 运营商进行快捷的评估。例：</target>
        </trans-unit>
        <trans-unit id="81caedce7ab00b1fe39f7b3ec76b901fbe2f933f" translate="yes" xml:space="preserve">
          <source>The optional 'fill' character defines the character to be used to pad the field to the minimum width. The fill character, if present, must be followed by an alignment flag.</source>
          <target state="translated">可选的 &quot;填充 &quot;字符定义了用于填充字段到最小宽度的字符。填充字符如果存在,必须在后面加上对齐标志。</target>
        </trans-unit>
        <trans-unit id="61a4c0792ebff9a51436a6a10512fd4b427609a0" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;shortNoVal&lt;/code&gt; and &lt;code&gt;longNoVal&lt;/code&gt; parameters present in &lt;a href=&quot;#initOptParser,string,set%5Bchar%5D,seq%5Bstring%5D&quot;&gt;initOptParser&lt;/a&gt; are for specifying which short and long options do not accept values.</source>
          <target state="translated">可选 &lt;code&gt;shortNoVal&lt;/code&gt; 和 &lt;code&gt;longNoVal&lt;/code&gt; 出现在参数&lt;a href=&quot;#initOptParser,string,set%5Bchar%5D,seq%5Bstring%5D&quot;&gt;initOptParser&lt;/a&gt;是指定哪些短期和长期的选项不接受值。</target>
        </trans-unit>
        <trans-unit id="e4b3a59de6d012b18e22a8e7a284e6db58df1867" translate="yes" xml:space="preserve">
          <source>The optional align flag can be one of the following:</source>
          <target state="translated">可选的对齐标志可以是以下之一。</target>
        </trans-unit>
        <trans-unit id="a0e3a6522c824ed95aa3e1f8fe8ce4a5f4f147b1" translate="yes" xml:space="preserve">
          <source>The order of the (key,value)-pairs is preserved, thus it is easy to support ordered dicts with for example &lt;code&gt;{key: val}.newOrderedTable&lt;/code&gt;.</source>
          <target state="translated">（键，值）对的顺序得以保留，因此很容易通过例如 &lt;code&gt;{key: val}.newOrderedTable&lt;/code&gt; 支持有序字典。</target>
        </trans-unit>
        <trans-unit id="429f542ce113c15e57f01af974550e0e5b305975" translate="yes" xml:space="preserve">
          <source>The order of the replacements does matter. Earlier replacements are preferred over later replacements in the argument list.</source>
          <target state="translated">替换的顺序确实很重要。在参数列表中,较早的替换优于较晚的替换。</target>
        </trans-unit>
        <trans-unit id="3108768a24a46c2d1623f6a7352dae8089ca7973" translate="yes" xml:space="preserve">
          <source>The ordinary assignment in Nim conceptually copies the values. The &lt;code&gt;=copy&lt;/code&gt; hook is called for assignments that couldn't be transformed into &lt;code&gt;=sink&lt;/code&gt; operations.</source>
          <target state="translated">Nim中的普通分配从概念上复制了这些值。该 &lt;code&gt;=copy&lt;/code&gt; 挂钩将被不能被转化为作业 &lt;code&gt;=sink&lt;/code&gt; 操作。</target>
        </trans-unit>
        <trans-unit id="dacff1821dbef72a128b774b46c26a9e053a10c5" translate="yes" xml:space="preserve">
          <source>The original module name is then not accessible. The notations &lt;code&gt;path/to/module&lt;/code&gt; or &lt;code&gt;&quot;path/to/module&quot;&lt;/code&gt; can be used to refer to a module in subdirectories:</source>
          <target state="translated">这样就无法访问原始模块名称。 &lt;code&gt;path/to/module&lt;/code&gt; 或 &lt;code&gt;&quot;path/to/module&quot;&lt;/code&gt; 符号可用于引用子目录中的模块：</target>
        </trans-unit>
        <trans-unit id="6f7414b6f4b65521aaf6120245a6e651f68d1e5a" translate="yes" xml:space="preserve">
          <source>The original string is returned if &lt;code&gt;width&lt;/code&gt; is less than or equal to &lt;code&gt;s.len&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;width&lt;/code&gt; 小于或等于 &lt;code&gt;s.len&lt;/code&gt; ,则返回原始字符串。</target>
        </trans-unit>
        <trans-unit id="cc86fbbfca2829ffbb5ee4206b27f3d101a719c7" translate="yes" xml:space="preserve">
          <source>The original string is returned if &lt;em&gt;width&lt;/em&gt; is less than or equal to &lt;em&gt;s.len&lt;/em&gt;.</source>
          <target state="translated">如果&lt;em&gt;width&lt;/em&gt;小于或等于&lt;em&gt;s.len，&lt;/em&gt;则返回原始字符串。</target>
        </trans-unit>
        <trans-unit id="56fcfadb9f1701723ceb4fcaae9d90dddc612821" translate="yes" xml:space="preserve">
          <source>The other reason is that the dirty file can appear anywhere on disk (e.g. in tmpfs), but it must be treated as having a path matching the original module when it comes to usage of relative paths, etc. Queries, however, will refer to the dirty module name in their answers instead of the normal filename.</source>
          <target state="translated">另一个原因是,dirty文件可以出现在磁盘的任何地方(如tmpfs中),但在使用相对路径等问题上,必须将其视为具有与原始模块相匹配的路径。然而,查询会在答案中引用脏文件的模块名,而不是正常的文件名。</target>
        </trans-unit>
        <trans-unit id="d25c28b6460c3b06db65db14b1f5007e28412aff" translate="yes" xml:space="preserve">
          <source>The outcome of the &lt;a href=&quot;math#cumsum,openArray%5BT%5D&quot;&gt;cumsum&lt;/a&gt; proc and the return value of the &lt;a href=&quot;math#cumsummed,openArray%5BT%5D&quot;&gt;cumsummed&lt;/a&gt; proc, which are both in the math module, can be used as the &lt;code&gt;cdf&lt;/code&gt; argument.</source>
          <target state="translated">会议的成果&lt;a href=&quot;math#cumsum,openArray%5BT%5D&quot;&gt;cumsum&lt;/a&gt; PROC和返回值&lt;a href=&quot;math#cumsummed,openArray%5BT%5D&quot;&gt;cumsummed&lt;/a&gt; PROC，这两者都是数学模块中，可被用作 &lt;code&gt;cdf&lt;/code&gt; 参数。</target>
        </trans-unit>
        <trans-unit id="81362a99790f1d4f0fa145c5d4c8a309f3b532a8" translate="yes" xml:space="preserve">
          <source>The output for HTML and LaTeX comes from the &lt;code&gt;config/nimdoc.cfg&lt;/code&gt; and &lt;code&gt;config/nimdoc.tex.cfg&lt;/code&gt; configuration files. You can add and modify these files to your project to change the look of docgen output.</source>
          <target state="translated">HTML和LaTeX的输出来自 &lt;code&gt;config/nimdoc.cfg&lt;/code&gt; 和 &lt;code&gt;config/nimdoc.tex.cfg&lt;/code&gt; 配置文件。您可以在项目中添加和修改这些文件，以更改docgen输出的外观。</target>
        </trans-unit>
        <trans-unit id="5fab1111abe4336bbc798351e8ca9549d09746d9" translate="yes" xml:space="preserve">
          <source>The output is twice the input long. No prefix like &lt;code&gt;0x&lt;/code&gt; is generated.</source>
          <target state="translated">输出是输入长度的两倍。不会生成像 &lt;code&gt;0x&lt;/code&gt; 这样的前缀。</target>
        </trans-unit>
        <trans-unit id="533631499bbd1d8be6ff4dcee292a72b882cc3f0" translate="yes" xml:space="preserve">
          <source>The output verbosity of the tests.</source>
          <target state="translated">测试的输出语气。</target>
        </trans-unit>
        <trans-unit id="608798a73678f1416a011aa2b8e46d174cf55393" translate="yes" xml:space="preserve">
          <source>The parallel statement is the preferred mechanism to introduce parallelism in a Nim program. A subset of the Nim language is valid within a &lt;code&gt;parallel&lt;/code&gt; section. This subset is checked during semantic analysis to be free of data races. A sophisticated &lt;span id=&quot;disjoint-checker_1&quot;&gt;disjoint checker&lt;/span&gt; ensures that no data races are possible even though shared memory is extensively supported!</source>
          <target state="translated">并行语句是在Nim程序中引入并行性的首选机制。 Nim语言的子集在 &lt;code&gt;parallel&lt;/code&gt; 部分内有效。在语义分析过程中检查了此子集，使其没有数据竞争。复杂的&lt;span id=&quot;disjoint-checker_1&quot;&gt;脱节检查器&lt;/span&gt;可确保即使广泛支持共享内存也不会发生数据争用！</target>
        </trans-unit>
        <trans-unit id="461db813bbace1635974b27e6126d38b9c4ee9ad" translate="yes" xml:space="preserve">
          <source>The parallel statement is the preferred mechanism to introduce parallelism in a Nim program. A subset of the Nim language is valid within a &lt;code&gt;parallel&lt;/code&gt; section. This subset is checked to be free of data races at compile time. A sophisticated &lt;span id=&quot;disjoint-checker_1&quot;&gt;disjoint checker&lt;/span&gt; ensures that no data races are possible even though shared memory is extensively supported!</source>
          <target state="translated">并行语句是在Nim程序中引入并行性的首选机制。Nim语言的子集在 &lt;code&gt;parallel&lt;/code&gt; 部分内有效。在编译时检查此子集是否没有数据争用。复杂的&lt;span id=&quot;disjoint-checker_1&quot;&gt;脱节检查器&lt;/span&gt;可确保即使广泛支持共享内存也无法进行数据竞争！</target>
        </trans-unit>
        <trans-unit id="c93630ff32d61caf48c2f2e72e2c5aa9f904f95c" translate="yes" xml:space="preserve">
          <source>The parameters are in reverse order! &lt;code&gt;a in b&lt;/code&gt; is a template for &lt;code&gt;contains(b, a)&lt;/code&gt;. This is because the unification algorithm that Nim uses for overload resolution works from left to right. But for the &lt;code&gt;in&lt;/code&gt; operator that would be the wrong direction for this piece of code:</source>
          <target state="translated">参数是相反的顺序！ &lt;code&gt;a in b&lt;/code&gt; 是 &lt;code&gt;contains(b, a)&lt;/code&gt; 的模板。这是因为Nim用于重载解析的统一算法从左到右起作用。但是对于 &lt;code&gt;in&lt;/code&gt; 运算符，这将是这段代码的错误方向：</target>
        </trans-unit>
        <trans-unit id="d785f95df44f47948246d72ae65b3b0c993eb38c" translate="yes" xml:space="preserve">
          <source>The parameters' types can be ordinary types or the meta types &lt;code&gt;untyped&lt;/code&gt;, &lt;code&gt;typed&lt;/code&gt;, or &lt;code&gt;type&lt;/code&gt;. &lt;code&gt;type&lt;/code&gt; suggests that only a type symbol may be given as an argument, and &lt;code&gt;untyped&lt;/code&gt; means symbol lookups and type resolution is not performed before the expression is passed to the template.</source>
          <target state="translated">参数的类型可以是普通类型，也可以是 &lt;code&gt;untyped&lt;/code&gt; ， &lt;code&gt;typed&lt;/code&gt; 或 &lt;code&gt;type&lt;/code&gt; 的元类型。 &lt;code&gt;type&lt;/code&gt; 表示只能将类型符号作为自变量，而 &lt;code&gt;untyped&lt;/code&gt; 表示在将表达式传递到模板之前不执行符号查找和类型解析。</target>
        </trans-unit>
        <trans-unit id="2bbf11b9701162a2035c4b55918733e64b1b5f9b" translate="yes" xml:space="preserve">
          <source>The parser object.</source>
          <target state="translated">解析器对象。</target>
        </trans-unit>
        <trans-unit id="81b1f54dcfe838ac2e0c59b6f42dae3e0756b1fe" translate="yes" xml:space="preserve">
          <source>The parser uses a stack of indentation levels: the stack consists of integers counting the spaces. The indentation information is queried at strategic places in the parser but ignored otherwise: The pseudo terminal &lt;code&gt;IND{&amp;gt;}&lt;/code&gt; denotes an indentation that consists of more spaces than the entry at the top of the stack; &lt;code&gt;IND{=}&lt;/code&gt; an indentation that has the same number of spaces. &lt;code&gt;DED&lt;/code&gt; is another pseudo terminal that describes the &lt;em&gt;action&lt;/em&gt; of popping a value from the stack, &lt;code&gt;IND{&amp;gt;}&lt;/code&gt; then implies to push onto the stack.</source>
          <target state="translated">解析器使用缩进级别的堆栈：该堆栈由计算空格的整数组成。缩进信息是在解析器中的关键位置查询的，但否则将被忽略：伪终端 &lt;code&gt;IND{&amp;gt;}&lt;/code&gt; 表示一个缩进，它比堆栈顶部的条目包含更多的空间； &lt;code&gt;IND{=}&lt;/code&gt; 具有相同数量空格的缩进。 &lt;code&gt;DED&lt;/code&gt; 是另一个伪终端，描述了从堆栈中弹出一个值的&lt;em&gt;动作&lt;/em&gt;，然后 &lt;code&gt;IND{&amp;gt;}&lt;/code&gt; 表示压入堆栈。</target>
        </trans-unit>
        <trans-unit id="abe385c190c44ec425b363f1b29f850fc6d40616" translate="yes" xml:space="preserve">
          <source>The parser uses a stack of indentation levels: the stack consists of integers counting the spaces. The indentation information is queried at strategic places in the parser but ignored otherwise: The pseudo-terminal &lt;code&gt;IND{&amp;gt;}&lt;/code&gt; denotes an indentation that consists of more spaces than the entry at the top of the stack; &lt;code&gt;IND{=}&lt;/code&gt; an indentation that has the same number of spaces. &lt;code&gt;DED&lt;/code&gt; is another pseudo terminal that describes the &lt;em&gt;action&lt;/em&gt; of popping a value from the stack, &lt;code&gt;IND{&amp;gt;}&lt;/code&gt; then implies to push onto the stack.</source>
          <target state="translated">解析器使用缩进级别的堆栈：该堆栈由对空格进行计数的整数组成。缩进信息是在解析器中的关键位置查询的，否则将被忽略：伪终端 &lt;code&gt;IND{&amp;gt;}&lt;/code&gt; 表示缩进所包含的空间比堆栈顶部的条目多。 &lt;code&gt;IND{=}&lt;/code&gt; 具有相同空格数的缩进。 &lt;code&gt;DED&lt;/code&gt; 是另一个伪终端，它描述了从堆栈中弹出一个值的&lt;em&gt;动作&lt;/em&gt;，然后 &lt;code&gt;IND{&amp;gt;}&lt;/code&gt; 表示压入堆栈。</target>
        </trans-unit>
        <trans-unit id="b75d284a399469fffe0947c898a06ce009bcfbbc" translate="yes" xml:space="preserve">
          <source>The passed file handle will no longer be inheritable.</source>
          <target state="translated">通过的文件句柄将不再是可继承的。</target>
        </trans-unit>
        <trans-unit id="7f9027f1cfc9029d9bab0ad3b282e7849cb03b34" translate="yes" xml:space="preserve">
          <source>The path analysis is &lt;strong&gt;currently unsound&lt;/strong&gt;, but that doesn't make it useless. Two paths are considered equivalent if they are syntactically the same.</source>
          <target state="translated">路径分析&lt;strong&gt;目前尚不完善&lt;/strong&gt;，但这并没有使它失效。如果两条路径在语法上相同，则认为它们是等效的。</target>
        </trans-unit>
        <trans-unit id="0bbaeda5d44901c81ebec10bdd7c6c2aed094901" translate="yes" xml:space="preserve">
          <source>The path returned by this proc is set at compile time.</source>
          <target state="translated">该proc返回的路径是在编译时设置的。</target>
        </trans-unit>
        <trans-unit id="a17327de092c7c00324e920e1dec0a84488b2def" translate="yes" xml:space="preserve">
          <source>The path returned by this template is set at compile time.</source>
          <target state="translated">该模板返回的路径是在编译时设置的。</target>
        </trans-unit>
        <trans-unit id="e21fa755d2f9dd13f4c401361fe48cbd80c4ec20" translate="yes" xml:space="preserve">
          <source>The plain name of a symbol is a simplified version of its fully exported signature. Variables or constants have the same plain name symbol as their complex name. The plain name for procs, templates, and other callable types will be their unquoted value after removing parameters, return types and pragmas. The plain name allows short and nice linking of symbols which works unless you have a module with collisions due to overloading.</source>
          <target state="translated">符号的纯名是其完全导出的签名的简化版本。变量或常量的明文名符号与它们的复杂名称相同。procs、模板和其他可调用类型的纯名将是去除参数、返回类型和语法后的未引号值。纯名允许短而好的符号链接,这很有效,除非你的模块由于重载而产生碰撞。</target>
        </trans-unit>
        <trans-unit id="14e09d7c794944bac489c1fb890465f3395a7739" translate="yes" xml:space="preserve">
          <source>The portion matched by &lt;code&gt;sep&lt;/code&gt; is not returned.</source>
          <target state="translated">由 &lt;code&gt;sep&lt;/code&gt; 匹配的部分不返回。</target>
        </trans-unit>
        <trans-unit id="5905889f12b10a582b5de19496532d186574a39d" translate="yes" xml:space="preserve">
          <source>The pragmas listed here can be used to optionally accept values from the -d/--define option at compile time.</source>
          <target state="translated">这里列出的实用名词可以在编译时选择性地接受来自-d/--define选项的值。</target>
        </trans-unit>
        <trans-unit id="15d21bc5558df5db984c197f09719a14cdbc33c2" translate="yes" xml:space="preserve">
          <source>The predicate needs to be an expression using the &lt;code&gt;it&lt;/code&gt; variable for testing, like: &lt;code&gt;countIt(@[1, 2, 3], it &amp;gt; 2)&lt;/code&gt;.</source>
          <target state="translated">谓词必须是使用 &lt;code&gt;it&lt;/code&gt; 变量进行测试的表达式，例如： &lt;code&gt;countIt(@[1, 2, 3], it &amp;gt; 2)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f4c1f5ea59e38f8446c010800e904b6889b2d6f5" translate="yes" xml:space="preserve">
          <source>The problem here is that the compiler already decided that &lt;code&gt;something()&lt;/code&gt; as an iterator is not callable in this context before &lt;code&gt;toSeq&lt;/code&gt; gets its chance to convert it into a sequence.</source>
          <target state="translated">这里的问题是，编译器已经确定，在 &lt;code&gt;toSeq&lt;/code&gt; 获得将其转换为序列的机会之前，不能在此上下文中调用 &lt;code&gt;something()&lt;/code&gt; 作为迭代器。</target>
        </trans-unit>
        <trans-unit id="9efd7fdcbe1a2580f7c97b1293f83d8747130a12" translate="yes" xml:space="preserve">
          <source>The proc &lt;code&gt;getSourceLanguage&lt;/code&gt; can get the language &lt;code&gt;enum&lt;/code&gt; from a string:</source>
          <target state="translated">proc &lt;code&gt;getSourceLanguage&lt;/code&gt; 可以从字符串获取语​​言 &lt;code&gt;enum&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="1413d5988b205726c716a63467c96b038a113fd1" translate="yes" xml:space="preserve">
          <source>The proc &lt;code&gt;quit(QuitSuccess)&lt;/code&gt; is called implicitly when your nim program finishes without incident for platforms where this is the expected behavior. A raised unhandled exception is equivalent to calling &lt;code&gt;quit(QuitFailure)&lt;/code&gt;.</source>
          <target state="translated">当您的nim程序完成而对这是预期行为的平台没有意外时，将隐式调用proc &lt;code&gt;quit(QuitSuccess)&lt;/code&gt; 。引发的未处理异常等效于调用 &lt;code&gt;quit(QuitFailure)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7e2d3b14bba8ee482acb489760d42aaa50f22724" translate="yes" xml:space="preserve">
          <source>The proc is meant to parse the Cookie header set by a client, not the &quot;Set-Cookie&quot; header set by servers.</source>
          <target state="translated">这个proc是用来解析客户端设置的Cookie头,而不是服务器设置的 &quot;Set-Cookie &quot;头。</target>
        </trans-unit>
        <trans-unit id="b711effa5493572608721c0ecb5734464843d0bf" translate="yes" xml:space="preserve">
          <source>The procedure has been designed so that its output is usable for many different common syntaxes.</source>
          <target state="translated">这个过程的设计使得它的输出可以用于许多不同的常用语法。</target>
        </trans-unit>
        <trans-unit id="37ebd1b54b6f7339d68d2b35085cae9b111d5bdc" translate="yes" xml:space="preserve">
          <source>The procedure has been designed so that its output is usable for many different common syntaxes. &lt;strong&gt;Note&lt;/strong&gt;: This is not correct for producing Ansi C code!</source>
          <target state="translated">该过程经过设计，使其输出可用于许多不同的通用语法。&lt;strong&gt;注意&lt;/strong&gt;：这对于生成Ansi C代码是不正确的！</target>
        </trans-unit>
        <trans-unit id="888e3f99a533bb35f9c99bb61e235d2938bc6ca0" translate="yes" xml:space="preserve">
          <source>The produced &lt;code&gt;finally&lt;/code&gt; section can be a single section that is wrapped around the complete routine body.</source>
          <target state="translated">&lt;code&gt;finally&lt;/code&gt; 生成的部分可以是单个部分，它包裹在整个常规主体中。</target>
        </trans-unit>
        <trans-unit id="0aa4a16f221969c520c65e78c146e6b52b5ba0e3" translate="yes" xml:space="preserve">
          <source>The produced &lt;code&gt;finally&lt;/code&gt; section is wrapped around the enclosing scope.</source>
          <target state="translated">产生的 &lt;code&gt;finally&lt;/code&gt; 部分被包裹在封闭范围内。</target>
        </trans-unit>
        <trans-unit id="d70d2b5b4c0766ea2a1f51de97640c064876e562" translate="yes" xml:space="preserve">
          <source>The program should output something similar to this, but keep in mind that exact results may vary in the real world:</source>
          <target state="translated">程序应该输出类似于这样的东西,但请记住,确切的结果可能在现实世界中有所不同。</target>
        </trans-unit>
        <trans-unit id="e4ed2941bc29e9113b49ab22213c1bd08c56b866" translate="yes" xml:space="preserve">
          <source>The progress of either a file upload or a file download can be checked by specifying a &lt;code&gt;onProgressChanged&lt;/code&gt; procedure to the &lt;code&gt;store&lt;/code&gt; or &lt;code&gt;retrFile&lt;/code&gt; procedures.</source>
          <target state="translated">通过向 &lt;code&gt;store&lt;/code&gt; 或 &lt;code&gt;retrFile&lt;/code&gt; 过程指定 &lt;code&gt;onProgressChanged&lt;/code&gt; 过程，可以检查文件上传或文件下载的进度。</target>
        </trans-unit>
        <trans-unit id="f15f5453e331e56f9b69a6e72ccfba467ab59e8f" translate="yes" xml:space="preserve">
          <source>The project makes use of a deprecated config file.</source>
          <target state="translated">该项目使用了一个过时的配置文件。</target>
        </trans-unit>
        <trans-unit id="c7aa2521596d9cb923517dba0d10349946353eba" translate="yes" xml:space="preserve">
          <source>The prototype of this hook for a type &lt;code&gt;T&lt;/code&gt; needs to be:</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; 型钩子的原型需要为：</target>
        </trans-unit>
        <trans-unit id="620c5eb2026cba7aa4895fcb3b5e5d494f483084" translate="yes" xml:space="preserve">
          <source>The reason for this is that &lt;code&gt;DivByZeroDefect&lt;/code&gt; inherits from &lt;code&gt;Defect&lt;/code&gt; and with &lt;code&gt;--panics:on&lt;/code&gt; Defects become unrecoverable errors. (Since version 1.4 of the language.)</source>
          <target state="translated">原因是 &lt;code&gt;DivByZeroDefect&lt;/code&gt; 继承自 &lt;code&gt;Defect&lt;/code&gt; 并带有 &lt;code&gt;--panics:on&lt;/code&gt; 缺陷成为不可恢复的错误。（自该语言的1.4版本开始。）</target>
        </trans-unit>
        <trans-unit id="93069592ba4d6f8e60f9caaf9f5719067988adf0" translate="yes" xml:space="preserve">
          <source>The reason for this is that code like</source>
          <target state="translated">原因是,像</target>
        </trans-unit>
        <trans-unit id="a9881783f395bf3db49786bb66c14efa31cbb346" translate="yes" xml:space="preserve">
          <source>The reason is that sets are implemented as high performance bit vectors. Attempting to declare a set with a larger type will result in an error:</source>
          <target state="translated">原因是集合是作为高性能的位向量来实现的。试图声明一个较大类型的集合会导致错误。</target>
        </trans-unit>
        <trans-unit id="0151e7d00a06bf727dbd72da71ba5ce97b155194" translate="yes" xml:space="preserve">
          <source>The reason is that the compiler already transformed the 1 into &quot;1&quot; for the &lt;code&gt;echo&lt;/code&gt; statement. However, a term rewriting macro should not change the semantics anyway. In fact they can be deactivated with the &lt;code&gt;--patterns:off&lt;/code&gt; command line option or temporarily with the &lt;code&gt;patterns&lt;/code&gt; pragma.</source>
          <target state="translated">原因是编译器已经为 &lt;code&gt;echo&lt;/code&gt; 语句将1转换为&amp;ldquo; 1&amp;rdquo; 。但是，术语重写宏无论如何都不应更改语义。实际上，可以使用 &lt;code&gt;--patterns:off&lt;/code&gt; 命令行选项将其停用，也可以使用 &lt;code&gt;patterns&lt;/code&gt; 编译指示将其暂时禁用。</target>
        </trans-unit>
        <trans-unit id="944e6805f1095e70b434b5bd328b942c9eebd4e8" translate="yes" xml:space="preserve">
          <source>The reasoning is as follows:</source>
          <target state="translated">其理由如下:</target>
        </trans-unit>
        <trans-unit id="f950b9dc37be83169d340916b25b6ad1600d2a00" translate="yes" xml:space="preserve">
          <source>The reimplementation of this code as a compile time proc will allow us to get rid of the &lt;code&gt;data.cfg&lt;/code&gt; file we would need to distribute along the binary, plus if the information is really constant, it doesn't make from a logical point of view to have it &lt;em&gt;mutable&lt;/em&gt; in a global variable, it would be better if it was a constant. Finally, and likely the most valuable feature, we can implement some verification at compile time. You could think of this as a &lt;em&gt;better unit testing&lt;/em&gt;, since it is impossible to obtain a binary unless everything is correct, preventing you to ship to users a broken program which won't start because a small critical file is missing or its contents changed by mistake to something invalid.</source>
          <target state="translated">将此代码重新实现为编译时proc，将使我们摆脱需要沿着二进制文件分发的 &lt;code&gt;data.cfg&lt;/code&gt; 文件，此外，如果信息确实是恒定的，那么从逻辑的角度来看，它不是必需的。有它&lt;em&gt;可变&lt;/em&gt;的全局变量，它会更好，如果它是一个常数。最后，也是最有价值的功能，我们可以在编译时实施一些验证。您可以将其视为&lt;em&gt;更好的单元测试&lt;/em&gt;，因为除非一切正确，否则不可能获得二进制文件，从而阻止您将损坏的程序交付给用户，该程序由于缺少关键文件太小或内容被更改而无法启动。犯错误</target>
        </trans-unit>
        <trans-unit id="bd941de653f278721095a2c43367c41906f6489e" translate="yes" xml:space="preserve">
          <source>The relationship of type to suffix is made by the proc &lt;code&gt;complexName&lt;/code&gt; in the &lt;code&gt;compiler/docgen.nim&lt;/code&gt; file. Here are some examples of complex names for symbols in the &lt;a href=&quot;system&quot;&gt;system module&lt;/a&gt;.</source>
          <target state="translated">型的以后缀的关系由PROC制成 &lt;code&gt;complexName&lt;/code&gt; 在 &lt;code&gt;compiler/docgen.nim&lt;/code&gt; 文件。这是&lt;a href=&quot;system&quot;&gt;系统模块中&lt;/a&gt;符号的复杂名称的一些示例。</target>
        </trans-unit>
        <trans-unit id="2bf0a82f5d893e438a2023ce750bc90f2a128096" translate="yes" xml:space="preserve">
          <source>The removal of existing files.</source>
          <target state="translated">删除现有文件;</target>
        </trans-unit>
        <trans-unit id="d6fd935f249c62b7608872cee19d42012edb0e86" translate="yes" xml:space="preserve">
          <source>The replace filter replaces substrings in each line.</source>
          <target state="translated">替换过滤器替换每行中的子串。</target>
        </trans-unit>
        <trans-unit id="28a78280047d22a351983c3a0d358b7203f54114" translate="yes" xml:space="preserve">
          <source>The representation of the &lt;code&gt;if&lt;/code&gt; expression is subtle, but easy to traverse.</source>
          <target state="translated">&lt;code&gt;if&lt;/code&gt; 表达式的表示形式很细微，但易于遍历。</target>
        </trans-unit>
        <trans-unit id="73836858e4d8022cd4c46c9283cbdf6cfe3ad8c7" translate="yes" xml:space="preserve">
          <source>The representation of the if statement is subtle, but easy to traverse. If there is no &lt;code&gt;else&lt;/code&gt; branch, no &lt;code&gt;nnkElse&lt;/code&gt; child exists.</source>
          <target state="translated">if语句的表示形式很微妙，但易于遍历。如果没有 &lt;code&gt;else&lt;/code&gt; 分支，则不存在 &lt;code&gt;nnkElse&lt;/code&gt; 子级。</target>
        </trans-unit>
        <trans-unit id="28c784e74f236c4964b6fd6d91fbb0a37256995f" translate="yes" xml:space="preserve">
          <source>The response's body stream is read synchronously.</source>
          <target state="translated">响应的主体流是同步读取的。</target>
        </trans-unit>
        <trans-unit id="989aceedc601a5b9a5742f1d14477507d7adf53d" translate="yes" xml:space="preserve">
          <source>The rest of the line is treated as a &lt;a href=&quot;re&quot;&gt;regular expression&lt;/a&gt;, so be careful escaping metacharacters like parenthesis.</source>
          <target state="translated">该行的其余部分被视为&lt;a href=&quot;re&quot;&gt;正则表达式&lt;/a&gt;，因此请小心转义圆括号之类的元字符。</target>
        </trans-unit>
        <trans-unit id="2f33b7db5192f55bbe370f8f53fab1a2ed0374f8" translate="yes" xml:space="preserve">
          <source>The result is truncated to fit into the result. This implements modulo arithmetic. No overflow errors are possible.</source>
          <target state="translated">结果被截断以适应结果。这实现了模数运算。不可能出现溢出错误。</target>
        </trans-unit>
        <trans-unit id="6de3479f33b83e39dae126f685d1475edff6c449" translate="yes" xml:space="preserve">
          <source>The resulting client socket is automatically registered to the dispatcher.</source>
          <target state="translated">由此产生的客户端套接字会自动注册到调度器。</target>
        </trans-unit>
        <trans-unit id="e81240f3c82766aef65cfde973adbe5730fdaa4e" translate="yes" xml:space="preserve">
          <source>The resulting client will inherit any properties of the server socket. For example: whether the socket is buffered or not.</source>
          <target state="translated">产生的客户端将继承服务器套接字的任何属性。例如:套接字是否被缓冲。</target>
        </trans-unit>
        <trans-unit id="58ccf12c816dba29cdb297d2baa539dbf718b0fd" translate="yes" xml:space="preserve">
          <source>The resulting state is independent of the default random number generator's state.</source>
          <target state="translated">所产生的状态与默认的随机数发生器的状态无关。</target>
        </trans-unit>
        <trans-unit id="6c9657a81f7e4e22d5602d19a05daddbb0eed4ab" translate="yes" xml:space="preserve">
          <source>The resulting string is always &lt;code&gt;len&lt;/code&gt; characters long. No leading &lt;code&gt;0b&lt;/code&gt; prefix is generated.</source>
          <target state="translated">结果字符串始终为 &lt;code&gt;len&lt;/code&gt; 个字符长。不会产生前导 &lt;code&gt;0b&lt;/code&gt; 前缀。</target>
        </trans-unit>
        <trans-unit id="a10dea8f7818ed973be79228742dcbd3138884e8" translate="yes" xml:space="preserve">
          <source>The resulting string is always &lt;code&gt;len&lt;/code&gt; characters long. No leading &lt;code&gt;0o&lt;/code&gt; prefix is generated.</source>
          <target state="translated">结果字符串始终为 &lt;code&gt;len&lt;/code&gt; 个字符长。不会产生前导 &lt;code&gt;0o&lt;/code&gt; 前缀。</target>
        </trans-unit>
        <trans-unit id="1d0eda4f937e942666810677280a88be73c7577b" translate="yes" xml:space="preserve">
          <source>The resulting string is always &lt;em&gt;len&lt;/em&gt; characters long. No leading &lt;code&gt;0b&lt;/code&gt; prefix is generated.</source>
          <target state="translated">结果字符串始终为&lt;em&gt;len个&lt;/em&gt;字符长。不会产生前导 &lt;code&gt;0b&lt;/code&gt; 前缀。</target>
        </trans-unit>
        <trans-unit id="ea3fa6f05db7b82f91043df8507510ba9b2c0af9" translate="yes" xml:space="preserve">
          <source>The resulting string is always &lt;em&gt;len&lt;/em&gt; characters long. No leading &lt;code&gt;0o&lt;/code&gt; prefix is generated.</source>
          <target state="translated">结果字符串始终为&lt;em&gt;len个&lt;/em&gt;字符长。不会产生前导 &lt;code&gt;0o&lt;/code&gt; 前缀。</target>
        </trans-unit>
        <trans-unit id="098958bf62961ccbbf03810cab1ba165ee727606" translate="yes" xml:space="preserve">
          <source>The resulting string is prefixed with &lt;code&gt;prefix&lt;/code&gt; and suffixed with &lt;code&gt;suffix&lt;/code&gt;. Both may be empty strings.</source>
          <target state="translated">结果字符串以 &lt;code&gt;prefix&lt;/code&gt; 为前缀，并以 &lt;code&gt;suffix&lt;/code&gt; 为后缀。两者都可能是空字符串。</target>
        </trans-unit>
        <trans-unit id="45fdb218e0bbadf017f51aea11eb54c54acabed2" translate="yes" xml:space="preserve">
          <source>The resulting string is prefixed with &lt;em&gt;prefix&lt;/em&gt; and suffixed with &lt;em&gt;suffix&lt;/em&gt;. Both may be empty strings.</source>
          <target state="translated">结果字符串以&lt;em&gt;prefix&lt;/em&gt;为前缀，并以&lt;em&gt;suffix为后缀&lt;/em&gt;。两者都可能是空字符串。</target>
        </trans-unit>
        <trans-unit id="403899c0e7f32ab870cef66df940fa7e27c170e3" translate="yes" xml:space="preserve">
          <source>The resulting string may not have a leading zero. Its length is always exactly 3.</source>
          <target state="translated">由此产生的字符串可能没有前导零。它的长度总是正好是3。</target>
        </trans-unit>
        <trans-unit id="f871e21f4ae6359465f4618b9a615e3d90900a7c" translate="yes" xml:space="preserve">
          <source>The resulting string will be exactly &lt;code&gt;len&lt;/code&gt; characters long. No prefix like &lt;code&gt;0x&lt;/code&gt; is generated. &lt;code&gt;x&lt;/code&gt; is treated as an unsigned value.</source>
          <target state="translated">结果字符串将恰好为 &lt;code&gt;len&lt;/code&gt; 个字符长。不会生成像 &lt;code&gt;0x&lt;/code&gt; 这样的前缀。 &lt;code&gt;x&lt;/code&gt; 被视为无符号值。</target>
        </trans-unit>
        <trans-unit id="30afb7397e54c9840f15c6ce3837b090cbb826dc" translate="yes" xml:space="preserve">
          <source>The resulting string will be exactly &lt;em&gt;len&lt;/em&gt; characters long. No prefix like &lt;code&gt;0x&lt;/code&gt; is generated. &lt;em&gt;x&lt;/em&gt; is treated as an unsigned value.</source>
          <target state="translated">结果字符串将恰好为&lt;em&gt;len个&lt;/em&gt;字符。不会生成像 &lt;code&gt;0x&lt;/code&gt; 这样的前缀。&lt;em&gt;x&lt;/em&gt;被视为无符号值。</target>
        </trans-unit>
        <trans-unit id="6ff39b06bbdb4341a3c2836e93082f26a34a7bb4" translate="yes" xml:space="preserve">
          <source>The resulting string will be minimally &lt;code&gt;minchars&lt;/code&gt; characters long. This is achieved by adding leading zeros.</source>
          <target state="translated">结果字符串的长度最少为 &lt;code&gt;minchars&lt;/code&gt; 个字符。这可以通过添加前导零来实现。</target>
        </trans-unit>
        <trans-unit id="f90efc9f77052cc77655df5707232ad9216984b9" translate="yes" xml:space="preserve">
          <source>The resulting string will be minimally &lt;em&gt;minchars&lt;/em&gt; characters long. This is achieved by adding leading zeros.</source>
          <target state="translated">结果字符串的长度最少为&lt;em&gt;minchars个&lt;/em&gt;字符。这可以通过添加前导零来实现。</target>
        </trans-unit>
        <trans-unit id="a48658314c6de6bf50c3ec96a319b4bcbf46bc4f" translate="yes" xml:space="preserve">
          <source>The return value can be ignored implicitly if the called proc/iterator has been declared with the &lt;code&gt;discardable&lt;/code&gt; pragma:</source>
          <target state="translated">如果已使用 &lt;code&gt;discardable&lt;/code&gt; 编译指示声明了被调用的proc / iterator，则可以隐式忽略返回值：</target>
        </trans-unit>
        <trans-unit id="67bd9c724c4f982734f839921c898bc019482c8d" translate="yes" xml:space="preserve">
          <source>The return value can be ignored implicitly if the called proc/iterator has been declared with the &lt;span id=&quot;discardable_1&quot;&gt;discardable&lt;/span&gt; pragma:</source>
          <target state="translated">如果已使用&lt;span id=&quot;discardable_1&quot;&gt;可放弃的&lt;/span&gt;编译指示声明了被调用的proc / iterator，则可以隐式忽略返回值：</target>
        </trans-unit>
        <trans-unit id="25d8ae7e238e57b8ff1a3ae56dc183c30b437cea" translate="yes" xml:space="preserve">
          <source>The return value is represented inside the body of a routine as the special &lt;span id=&quot;result_3&quot;&gt;result&lt;/span&gt; variable. This allows for a mechanism much like C++'s &quot;named return value optimization&quot; (&lt;span id=&quot;nrvo_1&quot;&gt;NRVO&lt;/span&gt;). NRVO means that the stores to &lt;code&gt;result&lt;/code&gt; inside &lt;code&gt;p&lt;/code&gt; directly affect the destination &lt;code&gt;dest&lt;/code&gt; in &lt;code&gt;let/var dest = p(args)&lt;/code&gt; (definition of &lt;code&gt;dest&lt;/code&gt;) and also in &lt;code&gt;dest = p(args)&lt;/code&gt; (assignment to &lt;code&gt;dest&lt;/code&gt;). This is achieved by rewriting &lt;code&gt;dest = p(args)&lt;/code&gt; to &lt;code&gt;p'(args, dest)&lt;/code&gt; where &lt;code&gt;p'&lt;/code&gt; is a variation of &lt;code&gt;p&lt;/code&gt; that returns &lt;code&gt;void&lt;/code&gt; and receives a hidden mutable parameter representing &lt;code&gt;result&lt;/code&gt;.</source>
          <target state="translated">返回值在例程的内部表示为特殊&lt;span id=&quot;result_3&quot;&gt;结果&lt;/span&gt;变量。这允许一种类似于C ++的&amp;ldquo;命名返回值优化&amp;rdquo;（&lt;span id=&quot;nrvo_1&quot;&gt;NRVO&lt;/span&gt;）的机制。 NRVO意味着对存储 &lt;code&gt;result&lt;/code&gt; 内部 &lt;code&gt;p&lt;/code&gt; 直接影响目的地 &lt;code&gt;dest&lt;/code&gt; 中 &lt;code&gt;let/var dest = p(args)&lt;/code&gt; （定义 &lt;code&gt;dest&lt;/code&gt; ）以及在 &lt;code&gt;dest = p(args)&lt;/code&gt; （分配到 &lt;code&gt;dest&lt;/code&gt; ）。这是通过将 &lt;code&gt;dest = p(args)&lt;/code&gt; 重写为 &lt;code&gt;p'(args, dest)&lt;/code&gt; ，其中 &lt;code&gt;p'&lt;/code&gt; 是 &lt;code&gt;p&lt;/code&gt; 的返回 &lt;code&gt;void&lt;/code&gt; 值的变体并接收表示 &lt;code&gt;result&lt;/code&gt; 的隐藏可变参数。</target>
        </trans-unit>
        <trans-unit id="756b0797d628461ffc91c206ce4262901afa5425" translate="yes" xml:space="preserve">
          <source>The returned &lt;code&gt;StringTableRef&lt;/code&gt; contains the parameters used by the HTML engine to build the final output. For information on what these parameters are and their purpose, please look up the file &lt;code&gt;config/nimdoc.cfg&lt;/code&gt; bundled with the compiler.</source>
          <target state="translated">返回的 &lt;code&gt;StringTableRef&lt;/code&gt; 包含HTML引擎用来构建最终输出的参数。有关这些参数的含义及其用途的信息，请查找与编译器捆绑在一起的文件 &lt;code&gt;config/nimdoc.cfg&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6d314e6c213f7dc11b7be0a941b6f5bc49b81919" translate="yes" xml:space="preserve">
          <source>The returned Future will complete once all data has been written to the specified file.</source>
          <target state="translated">一旦所有数据被写入指定文件,返回的Future将完成。</target>
        </trans-unit>
        <trans-unit id="08ac274d072334662c000b3093ec54665996d6d3" translate="yes" xml:space="preserve">
          <source>The returned string will have a rune-length of &lt;code&gt;count&lt;/code&gt;.</source>
          <target state="translated">返回的字符串将具有一个 &lt;code&gt;count&lt;/code&gt; 的符文长度。</target>
        </trans-unit>
        <trans-unit id="218ffc3b441a9be3f8e18751df3ec6089a753864" translate="yes" xml:space="preserve">
          <source>The root of Nim's object hierarchy.</source>
          <target state="translated">Nim的对象层次结构的根。</target>
        </trans-unit>
        <trans-unit id="64043b281b98efb8bb51554afb42ae2b90889a5c" translate="yes" xml:space="preserve">
          <source>The rope's length.</source>
          <target state="translated">绳子的长度。</target>
        </trans-unit>
        <trans-unit id="d420b4d0177cf52670fb1bd5d6c63c44491d8117" translate="yes" xml:space="preserve">
          <source>The rules for compile-time computability are:</source>
          <target state="translated">编译时可计算性的规则是:</target>
        </trans-unit>
        <trans-unit id="698e091efe4e128cb702c79882a2f45f056f90d7" translate="yes" xml:space="preserve">
          <source>The same action can also be performed asynchronously, simply use the &lt;code&gt;AsyncHttpClient&lt;/code&gt;:</source>
          <target state="translated">也可以异步执行相同的操作，只需使用 &lt;code&gt;AsyncHttpClient&lt;/code&gt; 即可：</target>
        </trans-unit>
        <trans-unit id="cf055ae5d7a11813fee9e56f81604099749907aa" translate="yes" xml:space="preserve">
          <source>The same as &lt;a href=&quot;#*,HashSet%5BA%5D,HashSet%5BA%5D&quot;&gt;s1 * s2&lt;/a&gt;.</source>
          <target state="translated">与&lt;a href=&quot;#*,HashSet%5BA%5D,HashSet%5BA%5D&quot;&gt;s1 * s2&lt;/a&gt;相同。</target>
        </trans-unit>
        <trans-unit id="c57a0f5b14742d12c24988b74a643647d6e014cc" translate="yes" xml:space="preserve">
          <source>The same as &lt;a href=&quot;#*,IntSet,IntSet&quot;&gt;s1 * s2&lt;/a&gt;.</source>
          <target state="translated">与&lt;a href=&quot;#*,IntSet,IntSet&quot;&gt;s1 * s2&lt;/a&gt;相同。</target>
        </trans-unit>
        <trans-unit id="59178c6fa7f1c2f8547f8456a1befc217b20ce51" translate="yes" xml:space="preserve">
          <source>The same as &lt;a href=&quot;#+,HashSet%5BA%5D,HashSet%5BA%5D&quot;&gt;s1 + s2&lt;/a&gt;.</source>
          <target state="translated">与&lt;a href=&quot;#+,HashSet%5BA%5D,HashSet%5BA%5D&quot;&gt;s1 + s2&lt;/a&gt;相同。</target>
        </trans-unit>
        <trans-unit id="78c0ab47b65053cfe4fbb0c1f52fae0d0a057a41" translate="yes" xml:space="preserve">
          <source>The same as &lt;a href=&quot;#+,IntSet,IntSet&quot;&gt;s1 + s2&lt;/a&gt;.</source>
          <target state="translated">与&lt;a href=&quot;#+,IntSet,IntSet&quot;&gt;s1 + s2&lt;/a&gt;相同。</target>
        </trans-unit>
        <trans-unit id="c286bec2a1c010ec13fa9455c84850edbfabf8eb" translate="yes" xml:space="preserve">
          <source>The same as &lt;a href=&quot;#-+-,HashSet%5BA%5D,HashSet%5BA%5D&quot;&gt;s1 -+- s2&lt;/a&gt;.</source>
          <target state="translated">与&lt;a href=&quot;#-+-,HashSet%5BA%5D,HashSet%5BA%5D&quot;&gt;s1-+-s2相同&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="61d2fb012b48cb0f33fa8dd5795c16758b107e2e" translate="yes" xml:space="preserve">
          <source>The same as &lt;a href=&quot;#-,HashSet%5BA%5D,HashSet%5BA%5D&quot;&gt;s1 - s2&lt;/a&gt;.</source>
          <target state="translated">与&lt;a href=&quot;#-,HashSet%5BA%5D,HashSet%5BA%5D&quot;&gt;s1-s2&lt;/a&gt;相同。</target>
        </trans-unit>
        <trans-unit id="94a04f27a87dc64a5b3af5f2bfeab96ab2befb96" translate="yes" xml:space="preserve">
          <source>The same as &lt;a href=&quot;#-,IntSet,IntSet&quot;&gt;s1 - s2&lt;/a&gt;.</source>
          <target state="translated">与&lt;a href=&quot;#-,IntSet,IntSet&quot;&gt;s1-s2&lt;/a&gt;相同。</target>
        </trans-unit>
        <trans-unit id="d403d0a3158f7f9caf11718e934542bcbbcbf185" translate="yes" xml:space="preserve">
          <source>The same as &lt;a href=&quot;#escape,string&quot;&gt;result.add(escape(s))&lt;/a&gt;, but more efficient.</source>
          <target state="translated">与&lt;a href=&quot;#escape,string&quot;&gt;result.add（escape（s））相同&lt;/a&gt;，但效率更高。</target>
        </trans-unit>
        <trans-unit id="55203671983834678f68df32a8f13dbf4dfa1cb5" translate="yes" xml:space="preserve">
          <source>The same as &lt;a href=&quot;#joinPath,string,string&quot;&gt;joinPath(head, tail) proc&lt;/a&gt;, but works with any number of directory parts.</source>
          <target state="translated">与&lt;a href=&quot;#joinPath,string,string&quot;&gt;joinPath（head，tail）proc相同&lt;/a&gt;，但可用于任意数量的目录部分。</target>
        </trans-unit>
        <trans-unit id="a036f8c2bc8d6fd4f9810b2d917dd44dc9677256" translate="yes" xml:space="preserve">
          <source>The same as &lt;a href=&quot;#joinPath,string,string&quot;&gt;joinPath(head, tail) proc&lt;/a&gt;.</source>
          <target state="translated">与&lt;a href=&quot;#joinPath,string,string&quot;&gt;joinPath（head，tail）proc相同&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4d8108fe45337e2b675ce1f770f1401249335850" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;add(s, formatstr % a)&lt;/code&gt;, but more efficient.</source>
          <target state="translated">与 &lt;code&gt;add(s, formatstr % a)&lt;/code&gt; ，但效率更高。</target>
        </trans-unit>
        <trans-unit id="eea3f061ff9424cd86d52bd3cac8dfd6e94a7529" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;joinPath(head, tail)&lt;/code&gt;</source>
          <target state="translated">与 &lt;code&gt;joinPath(head, tail)&lt;/code&gt; 相同（头，尾）</target>
        </trans-unit>
        <trans-unit id="c4562377386ad596a9d2e194a9741b56a7124917" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;parentDir(head) / tail&lt;/code&gt; unless there is no parent directory. Then &lt;code&gt;head / tail&lt;/code&gt; is performed instead.</source>
          <target state="translated">除非没有父目录，否则与 &lt;code&gt;parentDir(head) / tail&lt;/code&gt; 相同。然后执行 &lt;code&gt;head / tail&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="10d5f7b5b9b4599f963f76e595b9d0bc51dbc7a3" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;parentDir(head) / tail&lt;/code&gt;, unless there is no parent directory. Then &lt;code&gt;head / tail&lt;/code&gt; is performed instead.</source>
          <target state="translated">除非没有父目录，否则与 &lt;code&gt;parentDir(head) / tail&lt;/code&gt; 相同。然后执行 &lt;code&gt;head / tail&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="896b7a919e5c694aa0a0d238075545c1cae1c488" translate="yes" xml:space="preserve">
          <source>The same as &lt;em&gt;joinPath(head, tail)&lt;/em&gt;, but works with any number of directory parts. You need to pass at least one element or the proc will assert in debug builds and crash on release builds.</source>
          <target state="translated">与&lt;em&gt;joinPath（head，tail）相同&lt;/em&gt;，但可用于任意数量的目录部分。您需要传递至少一个元素，否则proc将在调试版本中声明并在发行版本中崩溃。</target>
        </trans-unit>
        <trans-unit id="25fcdd3704177b32025508d9d8dc540fb2c73caa" translate="yes" xml:space="preserve">
          <source>The same as the &lt;a href=&quot;#rsplit.i,string,char,int&quot;&gt;rsplit iterator&lt;/a&gt;, but is a proc that returns a sequence of substrings.</source>
          <target state="translated">与&lt;a href=&quot;#rsplit.i,string,char,int&quot;&gt;rsplit迭代器&lt;/a&gt;相同，但是是一个proc，它返回一系列子字符串。</target>
        </trans-unit>
        <trans-unit id="db09ba6be055ec25fc71a3c77b55d883dbb50574" translate="yes" xml:space="preserve">
          <source>The same as the &lt;a href=&quot;#rsplit.i,string,set%5Bchar%5D,int&quot;&gt;rsplit iterator&lt;/a&gt;, but is a proc that returns a sequence of substrings.</source>
          <target state="translated">与&lt;a href=&quot;#rsplit.i,string,set%5Bchar%5D,int&quot;&gt;rsplit迭代器&lt;/a&gt;相同，但是是一个proc，它返回一系列子字符串。</target>
        </trans-unit>
        <trans-unit id="872080f867045c7487dbf61ec0245aa4502cb8a8" translate="yes" xml:space="preserve">
          <source>The same as the &lt;a href=&quot;#rsplit.i,string,string,int&quot;&gt;rsplit iterator&lt;/a&gt;, but is a proc that returns a sequence of substrings.</source>
          <target state="translated">与&lt;a href=&quot;#rsplit.i,string,string,int&quot;&gt;rsplit迭代器&lt;/a&gt;相同，但是是一个proc，它返回一系列子字符串。</target>
        </trans-unit>
        <trans-unit id="0508e509b698b4d6f0cf31d5f5b62a59d7f990ff" translate="yes" xml:space="preserve">
          <source>The same as the &lt;a href=&quot;#rsplit.i,string,string,int,bool&quot;&gt;rsplit iterator&lt;/a&gt;, but is a proc that returns a sequence of substrings.</source>
          <target state="translated">与&lt;a href=&quot;#rsplit.i,string,string,int,bool&quot;&gt;rsplit迭代器&lt;/a&gt;相同，但是是一个可返回子字符串序列的proc。</target>
        </trans-unit>
        <trans-unit id="b05c9b483502198e61912440774377608b767850" translate="yes" xml:space="preserve">
          <source>The same as the &lt;a href=&quot;#split.i,string,Rune,int&quot;&gt;split iterator&lt;/a&gt;, but is a proc that returns a sequence of substrings.</source>
          <target state="translated">与&lt;a href=&quot;#split.i,string,Rune,int&quot;&gt;split迭代器&lt;/a&gt;相同，但是是一个可返回一系列子字符串的proc。</target>
        </trans-unit>
        <trans-unit id="488ed57d23acd7e77b2caaf8042dc1813401cb26" translate="yes" xml:space="preserve">
          <source>The same as the &lt;a href=&quot;#split.i,string,char,int&quot;&gt;split iterator&lt;/a&gt; (see its documentation), but is a proc that returns a sequence of substrings.</source>
          <target state="translated">与&lt;a href=&quot;#split.i,string,char,int&quot;&gt;拆分迭代器&lt;/a&gt;相同（请参见其文档），但是是一个可返回一系列子字符串的proc。</target>
        </trans-unit>
        <trans-unit id="6e5fe058f47f2922444e3cdf8a11480b26b2bdc0" translate="yes" xml:space="preserve">
          <source>The same as the &lt;a href=&quot;#split.i,string,char,int&quot;&gt;split iterator&lt;/a&gt;, but is a proc that returns a sequence of substrings.</source>
          <target state="translated">与&lt;a href=&quot;#split.i,string,char,int&quot;&gt;split迭代器&lt;/a&gt;相同，但是是一个proc，它返回一系列子字符串。</target>
        </trans-unit>
        <trans-unit id="80aaf3a3a6c939a3044bf2ae3e445580283d1045" translate="yes" xml:space="preserve">
          <source>The same as the &lt;a href=&quot;#split.i,string,openArray%5BRune%5D,int&quot;&gt;split iterator&lt;/a&gt;, but is a proc that returns a sequence of substrings.</source>
          <target state="translated">与&lt;a href=&quot;#split.i,string,openArray%5BRune%5D,int&quot;&gt;split迭代器&lt;/a&gt;相同，但是是一个可返回一系列子字符串的proc。</target>
        </trans-unit>
        <trans-unit id="3c7e1196d1ae854b5b7db4b886b04c7902d49fd4" translate="yes" xml:space="preserve">
          <source>The same as the &lt;a href=&quot;#split.i,string,set%5Bchar%5D,int&quot;&gt;split iterator&lt;/a&gt; (see its documentation), but is a proc that returns a sequence of substrings.</source>
          <target state="translated">与&lt;a href=&quot;#split.i,string,set%5Bchar%5D,int&quot;&gt;拆分迭代器&lt;/a&gt;相同（请参见其文档），但是是一个可返回一系列子字符串的proc。</target>
        </trans-unit>
        <trans-unit id="55216d0743f38afb17e58bb0b29813f0ebcc2b0b" translate="yes" xml:space="preserve">
          <source>The same as the &lt;a href=&quot;#split.i,string,set%5Bchar%5D,int&quot;&gt;split iterator&lt;/a&gt;, but is a proc that returns a sequence of substrings.</source>
          <target state="translated">与&lt;a href=&quot;#split.i,string,set%5Bchar%5D,int&quot;&gt;split迭代器&lt;/a&gt;相同，但是是一个proc，它返回一系列子字符串。</target>
        </trans-unit>
        <trans-unit id="c568df5237500459922db2d4a0ccbe43081cd83d" translate="yes" xml:space="preserve">
          <source>The same as the &lt;a href=&quot;#splitLines.i,string&quot;&gt;splitLines iterator&lt;/a&gt; (see its documentation), but is a proc that returns a sequence of substrings.</source>
          <target state="translated">与&lt;a href=&quot;#splitLines.i,string&quot;&gt;splitLines迭代器&lt;/a&gt;相同（请参见其文档），但是是一个可返回一系列子字符串的proc。</target>
        </trans-unit>
        <trans-unit id="f6bd26725a590268da07c53a69dedbe58085e4ed" translate="yes" xml:space="preserve">
          <source>The same as the &lt;a href=&quot;#splitLines.i,string&quot;&gt;splitLines&lt;/a&gt; iterator, but is a proc that returns a sequence of substrings.</source>
          <target state="translated">与&lt;a href=&quot;#splitLines.i,string&quot;&gt;splitLines&lt;/a&gt;迭代器相同，但是是一个可返回一系列子字符串的proc。</target>
        </trans-unit>
        <trans-unit id="40c1516e7e4a0fb4ec604559d5cf4d9baa2aacc6" translate="yes" xml:space="preserve">
          <source>The same as the &lt;a href=&quot;#splitWhitespace.i,string&quot;&gt;splitWhitespace&lt;/a&gt; iterator, but is a proc that returns a sequence of substrings.</source>
          <target state="translated">与&lt;a href=&quot;#splitWhitespace.i,string&quot;&gt;splitWhitespace&lt;/a&gt;迭代器相同，但是是一个可返回一系列子字符串的proc。</target>
        </trans-unit>
        <trans-unit id="9f1418168f1b08c4b0979b645260ef3e9404a43e" translate="yes" xml:space="preserve">
          <source>The same as the &lt;a href=&quot;#splitWhitespace.i,string,int&quot;&gt;splitWhitespace iterator&lt;/a&gt; (see its documentation), but is a proc that returns a sequence of substrings.</source>
          <target state="translated">与&lt;a href=&quot;#splitWhitespace.i,string,int&quot;&gt;splitWhitespace迭代器&lt;/a&gt;相同（请参见其文档），但是是一个可返回一系列子字符串的proc。</target>
        </trans-unit>
        <trans-unit id="155ce31bc857a624f4b637a724b282d2d7a0299b" translate="yes" xml:space="preserve">
          <source>The same as the &lt;a href=&quot;#splitWhitespace.i,string,int&quot;&gt;splitWhitespace&lt;/a&gt; iterator, but is a proc that returns a sequence of substrings.</source>
          <target state="translated">与&lt;a href=&quot;#splitWhitespace.i,string,int&quot;&gt;splitWhitespace&lt;/a&gt;迭代器相同，但是是一个可返回子字符串序列的proc。</target>
        </trans-unit>
        <trans-unit id="054a8e23aeaf85595c411958cf0af98d8322986e" translate="yes" xml:space="preserve">
          <source>The same could have been achieved by manually iterating over a container and increasing each key's value with &lt;a href=&quot;#inc,CountTable%5BA%5D,A,Positive&quot;&gt;inc proc&lt;/a&gt;:</source>
          <target state="translated">通过在容器上进行手动迭代并使用&lt;a href=&quot;#inc,CountTable%5BA%5D,A,Positive&quot;&gt;inc proc&lt;/a&gt;增加每个键的值，可以实现相同的目的：</target>
        </trans-unit>
        <trans-unit id="10f55c7794b6e447d4540977b35266563d3b8496" translate="yes" xml:space="preserve">
          <source>The same syntax applies to &lt;code&gt;iterator&lt;/code&gt; (with &lt;code&gt;nnkIteratorTy&lt;/code&gt;), but &lt;em&gt;does not&lt;/em&gt; apply to &lt;code&gt;converter&lt;/code&gt; or &lt;code&gt;template&lt;/code&gt;.</source>
          <target state="translated">相同的语法适用于 &lt;code&gt;iterator&lt;/code&gt; （带 &lt;code&gt;nnkIteratorTy&lt;/code&gt; ），但&lt;em&gt;并不&lt;/em&gt;适用于 &lt;code&gt;converter&lt;/code&gt; 或 &lt;code&gt;template&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8f2b58b4e423bfdce9cdf95cfb670ae8ff6353ae" translate="yes" xml:space="preserve">
          <source>The scanp macro</source>
          <target state="translated">Scanp 宏</target>
        </trans-unit>
        <trans-unit id="f71ea994a694d8297117d2c188599f3f7350c59a" translate="yes" xml:space="preserve">
          <source>The scope of the view does not matter:</source>
          <target state="translated">观点的范围并不重要。</target>
        </trans-unit>
        <trans-unit id="f812cc23782ffcc0d24f9418349fe228156d6e09" translate="yes" xml:space="preserve">
          <source>The second operator of &lt;code&gt;*&lt;/code&gt; must be a parameter; it is used to gather all the arguments. The expression &lt;code&gt;&quot;my&quot; &amp;amp;&amp;amp; (space &amp;amp; &quot;awe&quot; &amp;amp;&amp;amp; &quot;some &quot; ) &amp;amp;&amp;amp; &quot;concat&quot;&lt;/code&gt; is passed to &lt;code&gt;optConc&lt;/code&gt; in &lt;code&gt;a&lt;/code&gt; as a special list (of kind &lt;code&gt;nkArgList&lt;/code&gt;) which is flattened into a call expression; thus the invocation of &lt;code&gt;optConc&lt;/code&gt; produces:</source>
          <target state="translated">&lt;code&gt;*&lt;/code&gt; 的第二个运算符必须是参数；它用于收集所有参数。表达式 &lt;code&gt;&quot;my&quot; &amp;amp;&amp;amp; (space &amp;amp; &quot;awe&quot; &amp;amp;&amp;amp; &quot;some &quot; ) &amp;amp;&amp;amp; &quot;concat&quot;&lt;/code&gt; 作为特殊列表（类型为 &lt;code&gt;nkArgList&lt;/code&gt; ）传递给 &lt;code&gt;optConc&lt;/code&gt; ， &lt;code&gt;a&lt;/code&gt; 列表被扁平化为调用表达式；因此，调用 &lt;code&gt;optConc&lt;/code&gt; 会产生：</target>
        </trans-unit>
        <trans-unit id="1c86c735cf43c50791d8029b9f0a87ffd482fd7f" translate="yes" xml:space="preserve">
          <source>The second operator of &lt;em&gt;*&lt;/em&gt; must be a parameter; it is used to gather all the arguments. The expression &lt;code&gt;&quot;my&quot; &amp;amp;&amp;amp; (space &amp;amp; &quot;awe&quot; &amp;amp;&amp;amp; &quot;some &quot; ) &amp;amp;&amp;amp; &quot;concat&quot;&lt;/code&gt; is passed to &lt;code&gt;optConc&lt;/code&gt; in &lt;code&gt;a&lt;/code&gt; as a special list (of kind &lt;code&gt;nkArgList&lt;/code&gt;) which is flattened into a call expression; thus the invocation of &lt;code&gt;optConc&lt;/code&gt; produces:</source>
          <target state="translated">&lt;em&gt;*&lt;/em&gt;的第二个运算符必须是参数；它用于收集所有参数。表达式 &lt;code&gt;&quot;my&quot; &amp;amp;&amp;amp; (space &amp;amp; &quot;awe&quot; &amp;amp;&amp;amp; &quot;some &quot; ) &amp;amp;&amp;amp; &quot;concat&quot;&lt;/code&gt; 作为特殊列表（类型为 &lt;code&gt;nkArgList&lt;/code&gt; ）传递给 &lt;code&gt;optConc&lt;/code&gt; ， &lt;code&gt;a&lt;/code&gt; 列表被扁平化为调用表达式；因此，调用 &lt;code&gt;optConc&lt;/code&gt; 会产生：</target>
        </trans-unit>
        <trans-unit id="5ae0df5a264f4266cdb5160062cd0aaa33125c37" translate="yes" xml:space="preserve">
          <source>The sequence is required to have at least a single element. Debug versions of your program will assert in this situation but release versions will happily go ahead. If the sequence has a single element it will be returned without applying &lt;code&gt;operation&lt;/code&gt;.</source>
          <target state="translated">该序列必须至少包含一个元素。在这种情况下，您的程序的调试版本会有效，但发行版本会很高兴继续进行。如果序列有一个单一的元素，它将不应用返回 &lt;code&gt;operation&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="de05e83beaaac1f274966bd69ab8d48a0491b166" translate="yes" xml:space="preserve">
          <source>The set type models the mathematical notion of a set. The set's basetype can only be an ordinal type of a certain size, namely:</source>
          <target state="translated">集合类型是集的数学概念的模型。集的基型只能是一定大小的序型,即:</target>
        </trans-unit>
        <trans-unit id="aa01d82d61dfce28cfeda16c5bd80e4dbed31204" translate="yes" xml:space="preserve">
          <source>The setrlimit() system calls sets resource limits.</source>
          <target state="translated">setrlimit()系统调用设置资源限制。</target>
        </trans-unit>
        <trans-unit id="ab78f0eb24b2a7eb5c7e5cc08857a1e481515b9a" translate="yes" xml:space="preserve">
          <source>The shallow copy only changes the semantics for sequences and strings (and types which contain those).</source>
          <target state="translated">浅层拷贝只改变了序列和字符串(以及包含这些类型的类型)的语义。</target>
        </trans-unit>
        <trans-unit id="2b11bf3cb2bd50300b9f5b036f32f39ad404f4b8" translate="yes" xml:space="preserve">
          <source>The signature has to be:</source>
          <target state="translated">签名必须是:</target>
        </trans-unit>
        <trans-unit id="10ae4b49d52a242d61113b259ec4828eb2835c64" translate="yes" xml:space="preserve">
          <source>The simple case of &lt;code&gt;x = x&lt;/code&gt; cannot be turned into &lt;code&gt;=sink(x, x); wasMoved(x)&lt;/code&gt; because that would lose &lt;code&gt;x&lt;/code&gt;'s value. The solution is that simple self-assignments are simply transformed into an empty statement that does nothing.</source>
          <target state="translated">&lt;code&gt;x = x&lt;/code&gt; 的简单情况不能变成 &lt;code&gt;=sink(x, x); wasMoved(x)&lt;/code&gt; 因为那样会丢失 &lt;code&gt;x&lt;/code&gt; 的值。解决方案是将简单的自我分配简单地转换为不执行任何操作的空语句。</target>
        </trans-unit>
        <trans-unit id="2bed7f833a05e8210ed42f0ce7ddfee8765659dd" translate="yes" xml:space="preserve">
          <source>The size of the bool type is one byte.</source>
          <target state="translated">bool类型的大小是一个字节。</target>
        </trans-unit>
        <trans-unit id="d6a8c97ed2a17dc44a3f97e1801a8e2cbc5ffe6e" translate="yes" xml:space="preserve">
          <source>The smallest positive (nonzero) number that can be represented in a 32-bit floating-point type.</source>
          <target state="translated">可以用32位浮点类型表示的最小正数(非零)。</target>
        </trans-unit>
        <trans-unit id="37339a476e0f2e7116d49064ea767be2f3f7d153" translate="yes" xml:space="preserve">
          <source>The smallest positive (nonzero) number that can be represented in a 64-bit floating-point type.</source>
          <target state="translated">可以用64位浮点类型表示的最小正数(非零)。</target>
        </trans-unit>
        <trans-unit id="0f3394967223653ae65cfbae0dc744d9696343e6" translate="yes" xml:space="preserve">
          <source>The socket file path is operating system specific and distribution specific, additional configuration may or may not be needed on your &lt;code&gt;postgresql.conf&lt;/code&gt;. The Postgres server must be on the same computer and only works for Unix-like operating systems.</source>
          <target state="translated">套接字文件路径是特定于操作系统和特定于发行版的，您的 &lt;code&gt;postgresql.conf&lt;/code&gt; 可能需要或可能不需要其他配置。Postgres服务器必须位于同一台计算机上，并且仅适用于类似Unix的操作系统。</target>
        </trans-unit>
        <trans-unit id="dc5780ad9a486e96ea340daaaf93bd9d64035e65" translate="yes" xml:space="preserve">
          <source>The solution is to &lt;strong&gt;re-play&lt;/strong&gt; the module's top level statements. This solves the problem without having to special case the logic that fills the internal seqs which are affected by the pragmas.</source>
          <target state="translated">解决方案是&lt;strong&gt;重新播放&lt;/strong&gt;模块的顶级语句。这样就解决了问题，而无需特殊情况下填充由编译指示影响的内部序列的逻辑。</target>
        </trans-unit>
        <trans-unit id="15c408b85fe2405afe9a50555d39cb72fd864c66" translate="yes" xml:space="preserve">
          <source>The solution is to define &lt;code&gt;proc `=destroy`[T](f: var Foo[T])&lt;/code&gt; before it is used. The compiler generates implicit hooks for all types in &lt;em&gt;strategic places&lt;/em&gt; so that an explicitly provided hook that comes too &quot;late&quot; can be detected reliably. These &lt;em&gt;strategic places&lt;/em&gt; have been derived from the rewrite rules and are as follows:</source>
          <target state="translated">解决方案是在使用 &lt;code&gt;proc `=destroy`[T](f: var Foo[T])&lt;/code&gt; 之前定义它。编译器为&lt;em&gt;关键位置的&lt;/em&gt;所有类型生成隐式钩子，以便可以可靠地检测到&amp;ldquo;太迟&amp;rdquo;的显式提供的钩子。这些&lt;em&gt;策略性位置&lt;/em&gt;是根据重写规则得出的，如下所示：</target>
        </trans-unit>
        <trans-unit id="9449ed4a1afa5ff8ca6796adc72142c21a9e0e84" translate="yes" xml:space="preserve">
          <source>The source line that triggered a diagnostic message.</source>
          <target state="translated">触发诊断信息的源行。</target>
        </trans-unit>
        <trans-unit id="799e7aa051d179767ffba8160a4bb2cdfa09b721" translate="yes" xml:space="preserve">
          <source>The special &lt;code&gt;result&lt;/code&gt; variable.</source>
          <target state="translated">特殊 &lt;code&gt;result&lt;/code&gt; 变量。</target>
        </trans-unit>
        <trans-unit id="68b5ebd6f219423fa1db061ea18fb296f76e1f9f" translate="yes" xml:space="preserve">
          <source>The square brackets &lt;code&gt;[]&lt;/code&gt; indicate an optional element.</source>
          <target state="translated">方括号 &lt;code&gt;[]&lt;/code&gt; 表示可选元素。</target>
        </trans-unit>
        <trans-unit id="f2a70efe37ccaad3ecc8b9b1191dbd149f70e953" translate="yes" xml:space="preserve">
          <source>The standard distribution ships with the following tools:</source>
          <target state="translated">标准发行版附带以下工具:</target>
        </trans-unit>
        <trans-unit id="c14ddf17075fee8f053a24cb7922aea2d8242099" translate="yes" xml:space="preserve">
          <source>The standard error stream.</source>
          <target state="translated">标准误差流。</target>
        </trans-unit>
        <trans-unit id="25a87846c6350f9b0dad73c8670fb5c7a560abfc" translate="yes" xml:space="preserve">
          <source>The standard input stream.</source>
          <target state="translated">标准输入流。</target>
        </trans-unit>
        <trans-unit id="0c3f75a49135f9016942ef1a6c30dd582e32a67d" translate="yes" xml:space="preserve">
          <source>The standard library can be avoided to a point where C code generation for 16bit micro controllers is feasible. Use the &lt;span id=&quot;standalone_1&quot;&gt;standalone&lt;/span&gt; target (&lt;code&gt;--os:standalone&lt;/code&gt;) for a bare bones standard library that lacks any OS features.</source>
          <target state="translated">可以避免在16位微控制器的C代码生成可行的情况下使用标准库。对于没有任何操作系统功能的基本标准库，请使用&lt;span id=&quot;standalone_1&quot;&gt;独立&lt;/span&gt;目标（ &lt;code&gt;--os:standalone&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="3bbcfca9d43af60421b59aa297f2843d4ff476d7" translate="yes" xml:space="preserve">
          <source>The standard library supports a growing number of &lt;code&gt;useX&lt;/code&gt; conditional defines affecting how some features are implemented. This section tries to give a complete list.</source>
          <target state="translated">标准库支持越来越多的 &lt;code&gt;useX&lt;/code&gt; 条件定义，这些条件定义影响实现某些功能的方式。本节尝试给出完整的列表。</target>
        </trans-unit>
        <trans-unit id="3a9e602747062d7eede03400aa4e39b2ccb593c6" translate="yes" xml:space="preserve">
          <source>The standard output stream.</source>
          <target state="translated">标准输出流。</target>
        </trans-unit>
        <trans-unit id="e587b063e208685c74c0b90958dc5ab40a14e654" translate="yes" xml:space="preserve">
          <source>The statements after the &lt;code&gt;try&lt;/code&gt; are executed in sequential order unless an exception &lt;code&gt;e&lt;/code&gt; is raised. If the exception type of &lt;code&gt;e&lt;/code&gt; matches any listed in an &lt;code&gt;except&lt;/code&gt; clause the corresponding statements are executed. The statements following the &lt;code&gt;except&lt;/code&gt; clauses are called &lt;span id=&quot;exception-handlers_1&quot;&gt;exception handlers&lt;/span&gt;.</source>
          <target state="translated">&lt;code&gt;try&lt;/code&gt; 后的语句将按顺序执行，除非引发异常 &lt;code&gt;e&lt;/code&gt; 。如果 &lt;code&gt;e&lt;/code&gt; 的异常类型与 &lt;code&gt;except&lt;/code&gt; 子句中列出的任何异常类型匹配，则将执行相应的语句。 &lt;code&gt;except&lt;/code&gt; 子句后面的语句称为&lt;span id=&quot;exception-handlers_1&quot;&gt;异常处理程序&lt;/span&gt;。</target>
        </trans-unit>
        <trans-unit id="5e42bdb57f1a751ebb6ae75640b75ab4a37accc2" translate="yes" xml:space="preserve">
          <source>The statements after the &lt;code&gt;try&lt;/code&gt; are executed unless an exception is raised. Then the appropriate &lt;code&gt;except&lt;/code&gt; part is executed.</source>
          <target state="translated">除非引发异常，否则将执行 &lt;code&gt;try&lt;/code&gt; 之后的语句。然后执行适当的 &lt;code&gt;except&lt;/code&gt; 部分。</target>
        </trans-unit>
        <trans-unit id="1f3324ba035483cd423641c95748bc8274785628" translate="yes" xml:space="preserve">
          <source>The statements do not open a new scope.</source>
          <target state="translated">这些语句不会打开一个新的范围。</target>
        </trans-unit>
        <trans-unit id="885e9c28443dfee3e864ed46b2792fa6eef8a60c" translate="yes" xml:space="preserve">
          <source>The statements that belong to the expression that evaluated to true are translated by the compiler, the other statements are not checked for semantics! However, each condition is checked for semantics.</source>
          <target state="translated">属于表达式的语句,评价为真的语句会被编译器翻译,其他语句不进行语义检查!但每个条件都会进行语义检查。但是,每个条件都会进行语义检查。</target>
        </trans-unit>
        <trans-unit id="e6d4574c29f988390f3a56cfec01b716ffdcfb61" translate="yes" xml:space="preserve">
          <source>The statements within a branch do not open a new scope.</source>
          <target state="translated">分支内的语句不会打开一个新的范围。</target>
        </trans-unit>
        <trans-unit id="4e30151d5e9f17c8b266d5c2ebc2ca35ea0c04ba" translate="yes" xml:space="preserve">
          <source>The status of a test when it is done.</source>
          <target state="translated">测试完成后的状态。</target>
        </trans-unit>
        <trans-unit id="fd60c4990adcd88d94b2b574d1d8c68d1fefb098" translate="yes" xml:space="preserve">
          <source>The stdlib API is designed to be &lt;strong&gt;easy to use&lt;/strong&gt; and consistent. Ease of use is measured by the number of calls to achieve a concrete high level action. The ultimate goal is that the programmer can &lt;em&gt;guess&lt;/em&gt; a name.</source>
          <target state="translated">stdlib API设计为&lt;strong&gt;易于使用&lt;/strong&gt;且一致。易用性是通过达到具体的高级别操作的呼叫次数来衡量的。最终目标是程序员可以&lt;em&gt;猜出&lt;/em&gt;一个名字。</target>
        </trans-unit>
        <trans-unit id="10b2a953237a037ac2265ff58952966ca750b340" translate="yes" xml:space="preserve">
          <source>The stdtmpl filter provides a simple templating engine for Nim. The filter uses a line based parser: Lines prefixed with a &lt;em&gt;meta character&lt;/em&gt; (default: &lt;code&gt;#&lt;/code&gt;) contain Nim code, other lines are verbatim. Because indentation-based parsing is not suited for a templating engine, control flow statements need &lt;code&gt;end X&lt;/code&gt; delimiters.</source>
          <target state="translated">stdtmpl过滤器为Nim提供了一个简单的模板引擎。筛选器使用基于行的解析器：带有&lt;em&gt;元字符&lt;/em&gt;（默认值： &lt;code&gt;#&lt;/code&gt; ）的行包含Nim代码，其他行是逐字的。由于基于缩进的解析不适用于模板引擎，因此控制流语句需要使用 &lt;code&gt;end X&lt;/code&gt; 定界符。</target>
        </trans-unit>
        <trans-unit id="e5d4338933c9dd8ab3f051eed916bf14cdb0d76c" translate="yes" xml:space="preserve">
          <source>The strategy the GC should use for the application.</source>
          <target state="translated">(a)理事会在申请中应采用的战略;</target>
        </trans-unit>
        <trans-unit id="d853705ac2e16ddbf20df344526fe76e5bbe1d6b" translate="yes" xml:space="preserve">
          <source>The string literal passed to &lt;code&gt;exportc&lt;/code&gt; can be a format string:</source>
          <target state="translated">传递给 &lt;code&gt;exportc&lt;/code&gt; 的字符串文字可以是格式字符串：</target>
        </trans-unit>
        <trans-unit id="bc021537db9d4c37bc85c30ff44582b67a30832c" translate="yes" xml:space="preserve">
          <source>The string literal passed to &lt;code&gt;importc&lt;/code&gt; can be a format string:</source>
          <target state="translated">传递给 &lt;code&gt;importc&lt;/code&gt; 的字符串文字可以是格式字符串：</target>
        </trans-unit>
        <trans-unit id="05489799940a31c90df60dd618dd0c7f6fe09df5" translate="yes" xml:space="preserve">
          <source>The stringify operator for a CString argument. Returns &lt;code&gt;x&lt;/code&gt; converted to a string.</source>
          <target state="translated">CString参数的stringify运算符。返回 &lt;code&gt;x&lt;/code&gt; 转换为字符串。</target>
        </trans-unit>
        <trans-unit id="4d2a1a53ec06666d804727e437f2a83c5ef106f3" translate="yes" xml:space="preserve">
          <source>The stringify operator for a CString argument. Returns &lt;em&gt;x&lt;/em&gt; converted to a string.</source>
          <target state="translated">CString参数的stringify运算符。返回&lt;em&gt;x&lt;/em&gt;转换为字符串。</target>
        </trans-unit>
        <trans-unit id="7a06837bf4de8313fb2e9c2730a787782961e97b" translate="yes" xml:space="preserve">
          <source>The stringify operator for a boolean argument. Returns &lt;code&gt;x&lt;/code&gt; converted to the string &quot;false&quot; or &quot;true&quot;.</source>
          <target state="translated">布尔参数的stringify运算符。返回 &lt;code&gt;x&lt;/code&gt; 转换为字符串&amp;ldquo; false&amp;rdquo;或&amp;ldquo; true&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="c484fec0f015605339671fc06ee766d4baaf377e" translate="yes" xml:space="preserve">
          <source>The stringify operator for a boolean argument. Returns &lt;em&gt;x&lt;/em&gt; converted to the string &quot;false&quot; or &quot;true&quot;.</source>
          <target state="translated">布尔参数的stringify运算符。返回&lt;em&gt;x&lt;/em&gt;转换为字符串&amp;ldquo; false&amp;rdquo;或&amp;ldquo; true&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="97314c01ab906677fa54e8f600a637d1ff872572" translate="yes" xml:space="preserve">
          <source>The stringify operator for a character argument. Returns &lt;code&gt;x&lt;/code&gt; converted to a string.</source>
          <target state="translated">字符参数的stringify运算符。返回 &lt;code&gt;x&lt;/code&gt; 转换为字符串。</target>
        </trans-unit>
        <trans-unit id="a992e6797c902629fdda65b889cba064825234dc" translate="yes" xml:space="preserve">
          <source>The stringify operator for a character argument. Returns &lt;em&gt;x&lt;/em&gt; converted to a string.</source>
          <target state="translated">字符参数的stringify运算符。返回&lt;em&gt;x&lt;/em&gt;转换为字符串。</target>
        </trans-unit>
        <trans-unit id="c2e8846dafca6b75fda15855933500c8558f80ec" translate="yes" xml:space="preserve">
          <source>The stringify operator for a float argument. Returns &lt;code&gt;x&lt;/code&gt; converted to a decimal string.</source>
          <target state="translated">float参数的stringify运算符。返回 &lt;code&gt;x&lt;/code&gt; 转换为十进制字符串。</target>
        </trans-unit>
        <trans-unit id="89e3fe4dd1865173eb89990a7d7f5be7c43387f1" translate="yes" xml:space="preserve">
          <source>The stringify operator for a float argument. Returns &lt;em&gt;x&lt;/em&gt; converted to a decimal string.</source>
          <target state="translated">float参数的stringify运算符。返回&lt;em&gt;x&lt;/em&gt;转换为十进制字符串。</target>
        </trans-unit>
        <trans-unit id="896f93db18d37ef803d588829b7730d608bde104" translate="yes" xml:space="preserve">
          <source>The stringify operator for a string argument. Returns &lt;code&gt;x&lt;/code&gt; as it is. This operator is useful for generic code, so that &lt;code&gt;$expr&lt;/code&gt; also works if &lt;code&gt;expr&lt;/code&gt; is already a string.</source>
          <target state="translated">字符串参数的stringify运算符。照原样返回 &lt;code&gt;x&lt;/code&gt; 。该运算符对于通用代码很有用，因此，如果 &lt;code&gt;expr&lt;/code&gt; 已经是字符串，则 &lt;code&gt;$expr&lt;/code&gt; 也可以使用。</target>
        </trans-unit>
        <trans-unit id="c0db5c9df492c1a8b3dd9a2a95f9cef2f3e526af" translate="yes" xml:space="preserve">
          <source>The stringify operator for a string argument. Returns &lt;em&gt;x&lt;/em&gt; as it is. This operator is useful for generic code, so that &lt;code&gt;$expr&lt;/code&gt; also works if &lt;code&gt;expr&lt;/code&gt; is already a string.</source>
          <target state="translated">字符串参数的stringify运算符。按原样返回&lt;em&gt;x&lt;/em&gt;。该运算符对通用代码很有用，因此，如果 &lt;code&gt;expr&lt;/code&gt; 已经是字符串，则 &lt;code&gt;$expr&lt;/code&gt; 也可以使用。</target>
        </trans-unit>
        <trans-unit id="d96bb71e7e76d2204fee18b469a16a8c12a66807" translate="yes" xml:space="preserve">
          <source>The stringify operator for an enumeration argument. This works for any enumeration type thanks to compiler magic.</source>
          <target state="translated">枚举参数的stringify操作符。由于编译器的魔力,它适用于任何枚举类型。</target>
        </trans-unit>
        <trans-unit id="3ee7503135fe164e7c14568404ab5024b8abba0c" translate="yes" xml:space="preserve">
          <source>The stringify operator for an enumeration argument. This works for any enumeration type thanks to compiler magic. If a &lt;code&gt;$&lt;/code&gt; operator for a concrete enumeration is provided, this is used instead. (In other words: &lt;em&gt;Overwriting&lt;/em&gt; is possible.)</source>
          <target state="translated">枚举参数的stringify运算符。多亏了编译器的魔力，该方法适用于任何枚举类型。如果提供 &lt;code&gt;$&lt;/code&gt; 用于具体枚举的$运算符，则使用$运算符。（换句话说：可以&lt;em&gt;覆盖&lt;/em&gt;。）</target>
        </trans-unit>
        <trans-unit id="be489908ae882068231cbc7ae61f4debc3aca159" translate="yes" xml:space="preserve">
          <source>The stringify operator for an integer argument. Returns &lt;code&gt;x&lt;/code&gt; converted to a decimal string.</source>
          <target state="translated">整数参数的stringify运算符。返回 &lt;code&gt;x&lt;/code&gt; 转换为十进制字符串。</target>
        </trans-unit>
        <trans-unit id="2df8dc0dea2441955def02eb0211ebe5babe803f" translate="yes" xml:space="preserve">
          <source>The stringify operator for an integer argument. Returns &lt;code&gt;x&lt;/code&gt; converted to a decimal string. &lt;code&gt;$&lt;/code&gt; is Nim's general way of spelling &lt;span id=&quot;tostring_1&quot;&gt;toString&lt;/span&gt;.</source>
          <target state="translated">整数参数的stringify运算符。返回 &lt;code&gt;x&lt;/code&gt; 转换为十进制字符串。 &lt;code&gt;$&lt;/code&gt; 是Nim拼写&lt;span id=&quot;tostring_1&quot;&gt;toString&lt;/span&gt;的通用方法。</target>
        </trans-unit>
        <trans-unit id="e386bfe78072559f8bbde8532560130a6e7ea6ed" translate="yes" xml:space="preserve">
          <source>The stringify operator for an integer argument. Returns &lt;em&gt;x&lt;/em&gt; converted to a decimal string.</source>
          <target state="translated">整数参数的stringify运算符。返回&lt;em&gt;x&lt;/em&gt;转换为十进制字符串。</target>
        </trans-unit>
        <trans-unit id="606e2a47ef9a1510fef08559a8704f9cc52bd2a6" translate="yes" xml:space="preserve">
          <source>The stringify operator for an integer argument. Returns &lt;em&gt;x&lt;/em&gt; converted to a decimal string. &lt;code&gt;$&lt;/code&gt; is Nim's general way of spelling &lt;span id=&quot;tostring_1&quot;&gt;toString&lt;/span&gt;.</source>
          <target state="translated">整数参数的stringify运算符。返回&lt;em&gt;x&lt;/em&gt;转换为十进制字符串。 &lt;code&gt;$&lt;/code&gt; 是Nim拼写&lt;span id=&quot;tostring_1&quot;&gt;toString&lt;/span&gt;的通用方法。</target>
        </trans-unit>
        <trans-unit id="a3505dd46d9ecade26aad746ee7fe8677daef894" translate="yes" xml:space="preserve">
          <source>The stringify operator for an unsigned integer argument. Returns &lt;code&gt;x&lt;/code&gt; converted to a decimal string.</source>
          <target state="translated">无符号整数参数的stringify运算符。返回 &lt;code&gt;x&lt;/code&gt; 转换为十进制字符串。</target>
        </trans-unit>
        <trans-unit id="df81e6c55f80fcc8fa6ae2e9828d9cd7028b723f" translate="yes" xml:space="preserve">
          <source>The strip filter simply removes leading and trailing whitespace from each line.</source>
          <target state="translated">条形过滤器简单地从每一行中删除前导和后导的空白。</target>
        </trans-unit>
        <trans-unit id="8354da2777d5d9c0570db388afcea4a685a09419" translate="yes" xml:space="preserve">
          <source>The subexpression after the colon (&lt;code&gt;arg&lt;/code&gt; in &lt;code&gt;&amp;amp;&quot;{key} is {value:arg} {{z}}&quot;&lt;/code&gt;) is an optional argument passed to &lt;code&gt;format&lt;/code&gt;.</source>
          <target state="translated">冒号后的子表达式（ &lt;code&gt;arg&lt;/code&gt; 在 &lt;code&gt;&amp;amp;&quot;{key} is {value:arg} {{z}}&quot;&lt;/code&gt; ）是传递到一个可选的参数 &lt;code&gt;format&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9a624d4584bba9b7ac9d39da2c584be5b0d22cc6" translate="yes" xml:space="preserve">
          <source>The subexpression after the colon (&lt;code&gt;arg&lt;/code&gt; in &lt;code&gt;&amp;amp;&quot;{key} is {value:arg} {{z}}&quot;&lt;/code&gt;) is optional. It will be passed as the last argument to &lt;code&gt;formatValue&lt;/code&gt;. When the colon with the subexpression it is left out, an empty string will be taken instead.</source>
          <target state="translated">冒号后的子表达式（ &lt;code&gt;arg&lt;/code&gt; 在 &lt;code&gt;&amp;amp;&quot;{key} is {value:arg} {{z}}&quot;&lt;/code&gt; ）是可选的。它将作为最后一个参数传递给 &lt;code&gt;formatValue&lt;/code&gt; 。当带有子表达式的冒号被忽略时，将改为使用空字符串。</target>
        </trans-unit>
        <trans-unit id="085f167d1954a66b4d663e11ef8c099c5beed236" translate="yes" xml:space="preserve">
          <source>The subset is in fact the full language with the following restrictions / changes:</source>
          <target state="translated">该子集实际上是完整的语言,但有以下限制/变化。</target>
        </trans-unit>
        <trans-unit id="13d7858966cc6cd5e4db4c4d41318b516b21b8a4" translate="yes" xml:space="preserve">
          <source>The substitution character introduces a Nim expression &lt;em&gt;e&lt;/em&gt; within the string literal. &lt;em&gt;e&lt;/em&gt; is converted to a string with the &lt;em&gt;toString&lt;/em&gt; operation which defaults to &lt;code&gt;$&lt;/code&gt;. For strong type checking, set &lt;code&gt;toString&lt;/code&gt; to the empty string. &lt;em&gt;e&lt;/em&gt; must match this PEG pattern:</source>
          <target state="translated">替换字符在字符串文字中引入了Nim表达式&lt;em&gt;e&lt;/em&gt;。&lt;em&gt;e&lt;/em&gt;使用&lt;em&gt;toString&lt;/em&gt;操作转换为字符串，默认为 &lt;code&gt;$&lt;/code&gt; 。为了进行强类型检查，请将 &lt;code&gt;toString&lt;/code&gt; 设置为空字符串。&lt;em&gt;e&lt;/em&gt;必须匹配此PEG模式：</target>
        </trans-unit>
        <trans-unit id="167b71fcfef3ed3730604fc6b40f66159f634c79" translate="yes" xml:space="preserve">
          <source>The substitution variables (the thing after the &lt;code&gt;$&lt;/code&gt;) are enumerated from 1 to &lt;code&gt;a.len&lt;/code&gt;. To produce a verbatim &lt;code&gt;$&lt;/code&gt;, use &lt;code&gt;$$&lt;/code&gt;. The notation &lt;code&gt;$#&lt;/code&gt; can be used to refer to the next substitution variable:</source>
          <target state="translated">替换变量（ &lt;code&gt;$&lt;/code&gt; 之后的值）从1枚举到 &lt;code&gt;a.len&lt;/code&gt; 。要产生逐字 &lt;code&gt;$&lt;/code&gt; ，请使用 &lt;code&gt;$$&lt;/code&gt; 。 &lt;code&gt;$#&lt;/code&gt; 符号可用于引用下一个替换变量：</target>
        </trans-unit>
        <trans-unit id="d363d1e70588dfd25d1127db5f03a916d9f112a5" translate="yes" xml:space="preserve">
          <source>The suite will run the individual test cases in the order in which they were listed. With default global settings the above code prints:</source>
          <target state="translated">该套件将按照列出的顺序运行各个测试用例。在默认的全局设置下,打印上述代码。</target>
        </trans-unit>
        <trans-unit id="58f6801df2beac64305a6335b8896742f456c35c" translate="yes" xml:space="preserve">
          <source>The supplied &lt;code&gt;fd&lt;/code&gt;'s non-blocking state will be enabled implicitly.</source>
          <target state="translated">提供的 &lt;code&gt;fd&lt;/code&gt; 的非阻塞状态将隐式启用。</target>
        </trans-unit>
        <trans-unit id="80f2150ae39427c1e80e64b88f0a9a85b61d40f9" translate="yes" xml:space="preserve">
          <source>The symbol binding rules in generics are slightly subtle: There are &quot;open&quot; and &quot;closed&quot; symbols. A &quot;closed&quot; symbol cannot be re-bound in the instantiation context, an &quot;open&quot; symbol can. Per default overloaded symbols are open and every other symbol is closed.</source>
          <target state="translated">属类中的符号绑定规则略显微妙:符号有 &quot;开放 &quot;和 &quot;封闭 &quot;之分。一个 &quot;封闭的 &quot;符号不能在实例化上下文中重新绑定,一个 &quot;开放的 &quot;符号可以。默认情况下,重载符号是开放的,其他符号都是封闭的。</target>
        </trans-unit>
        <trans-unit id="1b8df85fe6e5d00af794928d133e0df6b4e79a93" translate="yes" xml:space="preserve">
          <source>The symbol's &lt;code&gt;ast&lt;/code&gt; field is loaded lazily, on demand. This is where most savings come from, only the shallow outer AST is reconstructed immediately.</source>
          <target state="translated">符号的 &lt;code&gt;ast&lt;/code&gt; 字段按需延迟加载。这是大多数节省的地方，只有立即重建浅外部AST。</target>
        </trans-unit>
        <trans-unit id="7bb33000c4f3d80804f12a993711548c0361f873" translate="yes" xml:space="preserve">
          <source>The symmetric difference of two sets is represented mathematically as &lt;em&gt;A △ B&lt;/em&gt; or &lt;em&gt;A ⊖ B&lt;/em&gt; and is the set of all objects that are members of &lt;code&gt;s1&lt;/code&gt; or &lt;code&gt;s2&lt;/code&gt; but not both at the same time.</source>
          <target state="translated">两组的对称差在数学上表示为&lt;em&gt;A△B&lt;/em&gt;或&lt;em&gt;A⊖B，&lt;/em&gt;并且是 &lt;code&gt;s1&lt;/code&gt; 或 &lt;code&gt;s2&lt;/code&gt; 的成员但不是同时属于两个的所有对象的集合。</target>
        </trans-unit>
        <trans-unit id="9db37ffc32ca144aebdbca14546aec93600a111e" translate="yes" xml:space="preserve">
          <source>The symmetric difference of two sets is represented mathematically as &lt;em&gt;A △ B&lt;/em&gt; or &lt;em&gt;A ⊖ B&lt;/em&gt; and is the set of all objects that are members of &lt;em&gt;s1&lt;/em&gt; or &lt;em&gt;s2&lt;/em&gt; but not both at the same time. Example:</source>
          <target state="translated">两组的对称差在数学上表示为&lt;em&gt;A△B&lt;/em&gt;或&lt;em&gt;A⊖B，&lt;/em&gt;并且是&lt;em&gt;s1&lt;/em&gt;或&lt;em&gt;s2的&lt;/em&gt;成员但不是同时属于两个的所有对象的集合。例：</target>
        </trans-unit>
        <trans-unit id="bf1dfb4076eebef85539bee43d7712db3fbf93bc" translate="yes" xml:space="preserve">
          <source>The syntax &lt;code&gt;-d:flag&lt;/code&gt; is actually just a shortcut for &lt;code&gt;-d:flag=true&lt;/code&gt;.</source>
          <target state="translated">语法 &lt;code&gt;-d:flag&lt;/code&gt; 实际上只是 &lt;code&gt;-d:flag=true&lt;/code&gt; 的快捷方式。</target>
        </trans-unit>
        <trans-unit id="b6a7467e652ab7936684b0f288dffd1681193ff3" translate="yes" xml:space="preserve">
          <source>The syntax &lt;code&gt;import dir / [moduleA, moduleB]&lt;/code&gt; can be used to import multiple modules from the same directory.</source>
          <target state="translated">语法 &lt;code&gt;import dir / [moduleA, moduleB]&lt;/code&gt; 可用于从同一目录导入多个模块。</target>
        </trans-unit>
        <trans-unit id="b40da33c17602bee643c7f4057eb8022801e2460" translate="yes" xml:space="preserve">
          <source>The syntax for iterators is similar to procs, but with &lt;code&gt;nnkIteratorDef&lt;/code&gt; replacing &lt;code&gt;nnkProcDef&lt;/code&gt;.</source>
          <target state="translated">迭代器的语法与procs类似，但是用 &lt;code&gt;nnkIteratorDef&lt;/code&gt; 代替 &lt;code&gt;nnkProcDef&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5e8fda84a4ffe40d2120509d7a72b690281067e4" translate="yes" xml:space="preserve">
          <source>The syntax for nested arrays (multidimensional) in other languages is a matter of appending more brackets because usually each dimension is restricted to the same index type as the others. In Nim you can have different dimensions with different index types, so the nesting syntax is slightly different. Building on the previous example where a level is defined as an array of enums indexed by yet another enum, we can add the following lines to add a light tower type subdivided in height levels accessed through their integer index:</source>
          <target state="translated">在其他语言中,嵌套数组(多维)的语法就是多加括号的问题,因为通常每个维度都被限制在与其他维度相同的索引类型。在Nim中,你可以拥有不同的维度和不同的索引类型,所以嵌套语法略有不同。在上一个例子的基础上,级别被定义为一个由又一个枚举索引的数组,我们可以添加下面的行来添加一个通过其整数索引访问的高度级别细分的光塔类型。</target>
        </trans-unit>
        <trans-unit id="0fc163c5356858c1953a68e20f8853fbed990195" translate="yes" xml:space="preserve">
          <source>The syntax for type conversions is &lt;code&gt;destination_type(expression_to_convert)&lt;/code&gt; (like an ordinary call):</source>
          <target state="translated">类型转换的语法是 &lt;code&gt;destination_type(expression_to_convert)&lt;/code&gt; （类似于普通调用）：</target>
        </trans-unit>
        <trans-unit id="2f95970b03c93b55b855c3143404ffb154e93738" translate="yes" xml:space="preserve">
          <source>The syntax of &lt;code&gt;case&lt;/code&gt; in an object declaration follows closely the syntax of the &lt;code&gt;case&lt;/code&gt; statement: The branches in a &lt;code&gt;case&lt;/code&gt; section may be indented too.</source>
          <target state="translated">对象声明中 &lt;code&gt;case&lt;/code&gt; 的语法紧跟 &lt;code&gt;case&lt;/code&gt; 语句的语法： &lt;code&gt;case&lt;/code&gt; 部分中的分支也可以缩进。</target>
        </trans-unit>
        <trans-unit id="8df91b05c23f64188bd8503b3710389f5709acad" translate="yes" xml:space="preserve">
          <source>The syntax to &lt;em&gt;invoke&lt;/em&gt; a template is the same as calling a procedure.</source>
          <target state="translated">&lt;em&gt;调用&lt;/em&gt;模板的语法与&lt;em&gt;调用过程&lt;/em&gt;的语法相同。</target>
        </trans-unit>
        <trans-unit id="379a9e1787c2fb57f06adcc397630994d8088c6e" translate="yes" xml:space="preserve">
          <source>The syntax tree</source>
          <target state="translated">语法树</target>
        </trans-unit>
        <trans-unit id="f8025e01a9219586f4ea9ca1e8fe9cf0b016b7a2" translate="yes" xml:space="preserve">
          <source>The syntax tree consists of nodes which may have an arbitrary number of children. Types and symbols are represented by other nodes, because they may contain cycles. The AST changes its shape after semantic checking. This is needed to make life easier for the code generators. See the &quot;ast&quot; module for the type definitions. The &lt;a href=&quot;macros&quot;&gt;macros&lt;/a&gt; module contains many examples how the AST represents each syntactic structure.</source>
          <target state="translated">语法树由可以具有任意数量的子代的节点组成。类型和符号由其他节点表示，因为它们可能包含循环。AST在语义检查后更改其形状。为了使代码生成器的工作更轻松，这是必需的。有关类型定义，请参见&amp;ldquo; ast&amp;rdquo;模块。该&lt;a href=&quot;macros&quot;&gt;宏&lt;/a&gt;模块包含了许多例子AST如何表示每个语法结构。</target>
        </trans-unit>
        <trans-unit id="6a68b38eeb844e67ce71f2a27d7dff2458540f69" translate="yes" xml:space="preserve">
          <source>The syntax, style, and rest of the ecosystem is the same as for compiled Nim, that means there is nothing new to learn, no context switch for developers.</source>
          <target state="translated">语法、风格和生态系统的其他部分与编译后的Nim是一样的,这意味着没有什么新的东西需要学习,对开发者来说没有上下文切换。</target>
        </trans-unit>
        <trans-unit id="46885e1cfadfc4a010003eabca5811146f7c040a" translate="yes" xml:space="preserve">
          <source>The syscall convention is the same as &lt;code&gt;__syscall&lt;/code&gt; in C. It is used for interrupts.</source>
          <target state="translated">syscall约定与C中的 &lt;code&gt;__syscall&lt;/code&gt; 相同。它用于中断。</target>
        </trans-unit>
        <trans-unit id="7428da08d4a9d661f397c8cd676c7d6536a3f09d" translate="yes" xml:space="preserve">
          <source>The system module defines several common functions for working with strings, such as:</source>
          <target state="translated">系统模块定义了几个常用的处理字符串的函数,比如。</target>
        </trans-unit>
        <trans-unit id="875f0d04dda05e55df0efe79df7f90f4cebd2211" translate="yes" xml:space="preserve">
          <source>The system module defines several common functions, such as:</source>
          <target state="translated">该系统模块定义了几个常用功能,如:</target>
        </trans-unit>
        <trans-unit id="dc67a1994589801e1401cb7812a58cafb42f5561" translate="yes" xml:space="preserve">
          <source>The target type of a cast must be a concrete type, for instance, a target type that is a type class (which is non-concrete) would be invalid:</source>
          <target state="translated">投放的目标类型必须是一个具体的类型,例如,目标类型是一个类型类(它是非具体的)将是无效的。</target>
        </trans-unit>
        <trans-unit id="a3f6bdaaf4d5477f1c500a92aa3e349f56e0070d" translate="yes" xml:space="preserve">
          <source>The temp command builds the Nim compiler but with a different final name (&lt;code&gt;nim_temp&lt;/code&gt;), so it doesn't overwrite your normal compiler. You can use this command to test different options, the same you would issue for the &lt;a href=&quot;#boot-command&quot;&gt;boot command&lt;/a&gt;.</source>
          <target state="translated">temp命令将构建Nim编译器，但使用不同的最终名称（ &lt;code&gt;nim_temp&lt;/code&gt; ），因此它不会覆盖您的常规编译器。您可以使用此命令测试不同的选项，与对&lt;a href=&quot;#boot-command&quot;&gt;boot命令&lt;/a&gt;发出的选项相同。</target>
        </trans-unit>
        <trans-unit id="0acf88d3c9384a4ead50fb1f94ad815480237488" translate="yes" xml:space="preserve">
          <source>The temp command builds the Nim compiler but with a different final name (&lt;code&gt;nim_temp&lt;/code&gt;), so it doesn't overwrite your normal compiler. You can use this command to test different options, the same you would issue for the &lt;a href=&quot;#commands-boot-command&quot;&gt;boot command&lt;/a&gt;.</source>
          <target state="translated">temp命令将构建Nim编译器，但使用不同的最终名称（ &lt;code&gt;nim_temp&lt;/code&gt; ），因此它不会覆盖您的常规编译器。您可以使用此命令测试不同的选项，与对&lt;a href=&quot;#commands-boot-command&quot;&gt;boot命令&lt;/a&gt;发出的选项相同。</target>
        </trans-unit>
        <trans-unit id="3df22e7a1794dd0ef985c2174f0bd9d90ca21bb9" translate="yes" xml:space="preserve">
          <source>The template engine is quite flexible. It is easy to produce a procedure that writes the template code directly to a file:</source>
          <target state="translated">模板引擎是相当灵活的。很容易制作一个过程,将模板代码直接写入文件。</target>
        </trans-unit>
        <trans-unit id="5d144a85c6f59928edd7f189f3b6401e2a927278" translate="yes" xml:space="preserve">
          <source>The template injects the &lt;code&gt;it&lt;/code&gt; variable which you can use directly in an expression.</source>
          <target state="translated">模板将注入 &lt;code&gt;it&lt;/code&gt; 变量，您可以直接在表达式中使用它。</target>
        </trans-unit>
        <trans-unit id="9b23f79ed77cf3b0ae3ac2cd0d6a1fd2ff5bea88" translate="yes" xml:space="preserve">
          <source>The template injects the &lt;code&gt;it&lt;/code&gt; variable which you can use directly in an expression. Example:</source>
          <target state="translated">模板将注入 &lt;code&gt;it&lt;/code&gt; 变量，您可以直接在表达式中使用它。例：</target>
        </trans-unit>
        <trans-unit id="71559554774a606802fa41138d874a38d2c3c673" translate="yes" xml:space="preserve">
          <source>The template injects the &lt;code&gt;it&lt;/code&gt; variable which you can use directly in an expression. The expression has to return the same type as the sequence you are mutating.</source>
          <target state="translated">模板将注入 &lt;code&gt;it&lt;/code&gt; 变量，您可以直接在表达式中使用它。表达式必须返回与您要突变的序列相同的类型。</target>
        </trans-unit>
        <trans-unit id="7e6285ee4f6bf81ff2cc725be672e1b5b5dc8943" translate="yes" xml:space="preserve">
          <source>The template injects the &lt;code&gt;it&lt;/code&gt; variable which you can use directly in an expression. You also need to pass as &lt;em&gt;typ&lt;/em&gt; the type of the expression, since the new returned sequence can have a different type than the original.</source>
          <target state="translated">模板将注入 &lt;code&gt;it&lt;/code&gt; 变量，您可以直接在表达式中使用它。您还需要通过为&lt;em&gt;典型值&lt;/em&gt;表达式的类型，因为新的返回序列可以有不同的类型比原来的。</target>
        </trans-unit>
        <trans-unit id="a708a430f68cec5b9b3fed13a7aade1b333cf36a" translate="yes" xml:space="preserve">
          <source>The terminating zero cannot be accessed unless the string is converted to the &lt;code&gt;cstring&lt;/code&gt; type first. The terminating zero assures that this conversion can be done in O(1) and without any allocations.</source>
          <target state="translated">除非先将字符串转换为 &lt;code&gt;cstring&lt;/code&gt; 类型，否则不能访问终止零。终止零确保可以在O（1）中完成此转换，而无需进行任何分配。</target>
        </trans-unit>
        <trans-unit id="6f48e150aa0a5a53af6ca79d3b6ba9e7f7657bf6" translate="yes" xml:space="preserve">
          <source>The test status and name is printed after any output or traceback.</source>
          <target state="translated">测试状态和名称会在任何输出或回溯后打印出来。</target>
        </trans-unit>
        <trans-unit id="526c72c6f1f64cc3b20092dd199d521f48bbae6b" translate="yes" xml:space="preserve">
          <source>The third and last way to write string literals are &lt;em&gt;long string literals&lt;/em&gt;. They are written with three quotes: &lt;code&gt;&quot;&quot;&quot; ... &quot;&quot;&quot;&lt;/code&gt;; they can span over multiple lines and the &lt;code&gt;\&lt;/code&gt; is not an escape character either. They are very useful for embedding HTML code templates for example.</source>
          <target state="translated">写字符串文字的第三种也是最后一种方式是&lt;em&gt;长字符串文字&lt;/em&gt;。它们用三个引号引起来： &lt;code&gt;&quot;&quot;&quot; ... &quot;&quot;&quot;&lt;/code&gt; ; 它们可以跨越多行，并且 &lt;code&gt;\&lt;/code&gt; 也不是转义字符。例如，它们对于嵌入HTML代码模板非常有用。</target>
        </trans-unit>
        <trans-unit id="c7d0bff946245f3196ff3fec3eab7b5f9ec10e1f" translate="yes" xml:space="preserve">
          <source>The third use of backslash is for specifying &lt;span id=&quot;generic-character-types_1&quot;&gt;generic character types&lt;/span&gt;. The following are always recognized:</source>
          <target state="translated">反斜杠的第三种用法是用于指定&lt;span id=&quot;generic-character-types_1&quot;&gt;通用字符类型&lt;/span&gt;。始终公认以下几点：</target>
        </trans-unit>
        <trans-unit id="92af40aeb29e6640bb9de3b1e1701b722a26794f" translate="yes" xml:space="preserve">
          <source>The time (in UTC) of compilation as a string of the form &lt;code&gt;HH:MM:SS&lt;/code&gt;. This works thanks to compiler magic.</source>
          <target state="translated">以 &lt;code&gt;HH:MM:SS&lt;/code&gt; 形式的字符串的编译时间（以UTC为单位）。这要归功于编译器的魔力。</target>
        </trans-unit>
        <trans-unit id="e60cef0a4060f4db69c965773dac830d6f50b6aa" translate="yes" xml:space="preserve">
          <source>The timezone represented as an implementation of &lt;code&gt;Timezone&lt;/code&gt;.</source>
          <target state="translated">时区表示为 &lt;code&gt;Timezone&lt;/code&gt; 的实现。</target>
        </trans-unit>
        <trans-unit id="716122720506770b96f97a3949c5f63d216ca318" translate="yes" xml:space="preserve">
          <source>The trailing newline character(s) are removed from the iterated lines. Example:</source>
          <target state="translated">从迭代行中删除尾部的换行符。例子:</target>
        </trans-unit>
        <trans-unit id="088f34b2b9f2860def75b9865d8fa88192adf164" translate="yes" xml:space="preserve">
          <source>The type coercion &lt;code&gt;static(x)&lt;/code&gt; can be used to force the compile-time evaluation of the given expression &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">强制类型 &lt;code&gt;static(x)&lt;/code&gt; 可用于强制执行给定表达式 &lt;code&gt;x&lt;/code&gt; 的编译时评估。</target>
        </trans-unit>
        <trans-unit id="4ed681a392a0c61fb28eee2975db81a956d2924e" translate="yes" xml:space="preserve">
          <source>The type conversion &lt;code&gt;T(a)&lt;/code&gt; is an L-value if &lt;code&gt;a&lt;/code&gt; is an L-value and &lt;code&gt;typeEqualsOrDistinct(T, type(a))&lt;/code&gt; holds.</source>
          <target state="translated">如果 &lt;code&gt;a&lt;/code&gt; 为L值且 &lt;code&gt;typeEqualsOrDistinct(T, type(a))&lt;/code&gt; 成立，则类型转换 &lt;code&gt;T(a)&lt;/code&gt; 为L值。</target>
        </trans-unit>
        <trans-unit id="1b02430bf6ab116f5610a3e7f89fda5b3e78e5ab" translate="yes" xml:space="preserve">
          <source>The type conversion &lt;code&gt;T(a)&lt;/code&gt; is an L-value if &lt;code&gt;a&lt;/code&gt; is an L-value and &lt;code&gt;typeEqualsOrDistinct(T, typeof(a))&lt;/code&gt; holds.</source>
          <target state="translated">如果 &lt;code&gt;a&lt;/code&gt; 为L值且 &lt;code&gt;typeEqualsOrDistinct(T, typeof(a))&lt;/code&gt; 成立，则类型转换 &lt;code&gt;T(a)&lt;/code&gt; 为L值。</target>
        </trans-unit>
        <trans-unit id="f7007f414d9f07ec9d9545e70f77c0fb11e2655f" translate="yes" xml:space="preserve">
          <source>The type of a parameter may be prefixed with the &lt;code&gt;var&lt;/code&gt; keyword:</source>
          <target state="translated">参数的类型可以以 &lt;code&gt;var&lt;/code&gt; 关键字为前缀：</target>
        </trans-unit>
        <trans-unit id="b4149e9c761a9c5b1d817b72b94a54f51db12381" translate="yes" xml:space="preserve">
          <source>The type representing a file handle.</source>
          <target state="translated">代表文件句柄的类型。</target>
        </trans-unit>
        <trans-unit id="9b4854aa3e47cfa3fa7a0d71ef4763a784b0d2a7" translate="yes" xml:space="preserve">
          <source>The type suffixes are:</source>
          <target state="translated">类型后缀为:</target>
        </trans-unit>
        <trans-unit id="4006d5cc88fdabea98a514a10633d32480b50418" translate="yes" xml:space="preserve">
          <source>The types &lt;code&gt;var T&lt;/code&gt; and &lt;code&gt;typedesc[T]&lt;/code&gt; cannot be inferred in a generic instantiation. The following is not allowed:</source>
          <target state="translated">不能在通用实例中推断类型 &lt;code&gt;var T&lt;/code&gt; 和 &lt;code&gt;typedesc[T]&lt;/code&gt; 。不允许以下内容：</target>
        </trans-unit>
        <trans-unit id="6068d66d8caf9d0bc5e346b69b06b7e22f85d91a" translate="yes" xml:space="preserve">
          <source>The types &lt;code&gt;var T&lt;/code&gt;, &lt;code&gt;out T&lt;/code&gt; and &lt;code&gt;typedesc[T]&lt;/code&gt; cannot be inferred in a generic instantiation. The following is not allowed:</source>
          <target state="translated">不能在泛型实例化中推断类型 &lt;code&gt;var T&lt;/code&gt; ， &lt;code&gt;out T&lt;/code&gt; 和 &lt;code&gt;typedesc[T]&lt;/code&gt; 。不允许以下内容：</target>
        </trans-unit>
        <trans-unit id="15965d3cd0f4bb804b8212dddb5431bf9b84d441" translate="yes" xml:space="preserve">
          <source>The typical compiler usage involves using the &lt;code&gt;compile&lt;/code&gt; or &lt;code&gt;c&lt;/code&gt; command to transform a &lt;code&gt;.nim&lt;/code&gt; file into one or more &lt;code&gt;.c&lt;/code&gt; files which are then compiled with the platform's C compiler into a static binary. However there are other commands to compile to C++, Objective-C or Javascript. More details can be read in the &lt;a href=&quot;backends&quot;&gt;Nim Backend Integration document&lt;/a&gt;.</source>
          <target state="translated">典型的编译器用法包括使用 &lt;code&gt;compile&lt;/code&gt; 或 &lt;code&gt;c&lt;/code&gt; 命令将 &lt;code&gt;.nim&lt;/code&gt; 文件转换为一个或多个 &lt;code&gt;.c&lt;/code&gt; 文件，然后使用平台的C编译器将其编译为静态二进制文件。但是，还有其他命令可以编译为C ++，Objective-C或Javascript。更多详细信息，请参阅&lt;a href=&quot;backends&quot;&gt;Nim后端集成文档&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="733da35309da1a0adc926cfeed7cf9e4972229fa" translate="yes" xml:space="preserve">
          <source>The typical compiler usage involves using the &lt;code&gt;compile&lt;/code&gt; or &lt;code&gt;c&lt;/code&gt; command to transform a &lt;code&gt;.nim&lt;/code&gt; file into one or more &lt;code&gt;.c&lt;/code&gt; files which are then compiled with the platform's C compiler into a static binary. However, there are other commands to compile to C++, Objective-C, or JavaScript. More details can be read in the &lt;a href=&quot;backends&quot;&gt;Nim Backend Integration document&lt;/a&gt;.</source>
          <target state="translated">典型的编译器用法包括使用 &lt;code&gt;compile&lt;/code&gt; 或 &lt;code&gt;c&lt;/code&gt; 命令将 &lt;code&gt;.nim&lt;/code&gt; 文件转换为一个或多个 &lt;code&gt;.c&lt;/code&gt; 文件，然后使用平台的C编译器将其编译为静态二进制文件。但是，还有其他命令可以编译为C ++，Objective-C或JavaScript。有关更多详细信息，请参阅《&lt;a href=&quot;backends&quot;&gt;Nim后端集成》文档&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0930f393d96d3e129dbb5d95324e49f12cf8fc32" translate="yes" xml:space="preserve">
          <source>The typical usage scenario for this option is to call it after the user has typed the dot character for &lt;a href=&quot;https://nim-lang.org/docs/tut2.html#object-oriented-programming-method-call-syntax&quot;&gt;the object oriented call syntax&lt;/a&gt;. Idetools will try to return the suggestions sorted first by scope (from innermost to outermost) and then by item name.</source>
          <target state="translated">此选项的典型用法是在用户键入&lt;a href=&quot;https://nim-lang.org/docs/tut2.html#object-oriented-programming-method-call-syntax&quot;&gt;面向对象的调用语法&lt;/a&gt;的点字符后调用它。Idetools将尝试返回建议，这些建议首先按范围（从最内到最外）排序，然后按项目名称排序。</target>
        </trans-unit>
        <trans-unit id="4dc757b9810b94b3278b6f78815badc1d4f6fdea" translate="yes" xml:space="preserve">
          <source>The typical usage scenario for this option is to call it after the user has typed the dot character for &lt;a href=&quot;https://nim-lang.org/docs/tut2.html#object-oriented-programming-method-call-syntax&quot;&gt;the object oriented call syntax&lt;/a&gt;. Nimsuggest will try to return the suggestions sorted first by scope (from innermost to outermost) and then by item name.</source>
          <target state="translated">此选项的典型用法是在用户键入&lt;a href=&quot;https://nim-lang.org/docs/tut2.html#object-oriented-programming-method-call-syntax&quot;&gt;面向对象的调用语法&lt;/a&gt;的点字符后调用它。Nimsuggest将尝试返回建议，这些建议首先按范围（从最内到最外）排序，然后按项目名称排序。</target>
        </trans-unit>
        <trans-unit id="2323beee7c184cc654539984a6ab3af180da6e48" translate="yes" xml:space="preserve">
          <source>The typical usage scenario for this option is to call it after the user has typed the dot character for &lt;a href=&quot;tut2#method-call-syntax&quot;&gt;the object oriented call syntax&lt;/a&gt;. Idetools will try to return the suggestions sorted first by scope (from innermost to outermost) and then by item name.</source>
          <target state="translated">此选项的典型用法是在用户键入&lt;a href=&quot;tut2#method-call-syntax&quot;&gt;面向对象的调用语法&lt;/a&gt;的点字符后调用它。Idetools将尝试返回建议，这些建议首先按范围（从最内到最外）排序，然后按项目名称排序。</target>
        </trans-unit>
        <trans-unit id="b45de376a3cd2738b15e943470c78ad94bed4791" translate="yes" xml:space="preserve">
          <source>The typical usage scenario for this option is to call it after the user has typed the dot character for &lt;a href=&quot;tut2#method-call-syntax&quot;&gt;the object oriented call syntax&lt;/a&gt;. Nimsuggest will try to return the suggestions sorted first by scope (from innermost to outermost) and then by item name.</source>
          <target state="translated">此选项的典型用法是在用户键入&lt;a href=&quot;tut2#method-call-syntax&quot;&gt;面向对象的调用语法&lt;/a&gt;的点字符后调用它。Nimsuggest将尝试返回建议，这些建议首先按范围（从最内到最外）排序，然后按项目名称排序。</target>
        </trans-unit>
        <trans-unit id="22208dbaa100422606e56c7e131a653bc370939f" translate="yes" xml:space="preserve">
          <source>The union of two sets is represented mathematically as &lt;em&gt;A &amp;cup; B&lt;/em&gt; and is the set of all objects that are members of &lt;code&gt;s1&lt;/code&gt;, &lt;code&gt;s2&lt;/code&gt; or both.</source>
          <target state="translated">两组的并集在数学上用&lt;em&gt;A&amp;cup;B&lt;/em&gt;表示，并且是 &lt;code&gt;s1&lt;/code&gt; ， &lt;code&gt;s2&lt;/code&gt; 或这两个成员的所有对象的集合。</target>
        </trans-unit>
        <trans-unit id="c1bb924a06b99256d96c42fb02e7ceffd0f6c417" translate="yes" xml:space="preserve">
          <source>The union of two sets is represented mathematically as &lt;em&gt;A &amp;cup; B&lt;/em&gt; and is the set of all objects that are members of &lt;em&gt;s1&lt;/em&gt;, &lt;em&gt;s2&lt;/em&gt; or both. Example:</source>
          <target state="translated">两组的并集在数学上用&lt;em&gt;A&amp;cup;B&lt;/em&gt;表示，并且是&lt;em&gt;s1&lt;/em&gt;，&lt;em&gt;s2&lt;/em&gt;或这两个成员的所有对象的集合。例：</target>
        </trans-unit>
        <trans-unit id="d8d1d1447b153afdb0a97fd8b87918bc4140f680" translate="yes" xml:space="preserve">
          <source>The unit of the parameters &lt;code&gt;maxPauseInUs&lt;/code&gt; and &lt;code&gt;us&lt;/code&gt; is microseconds.</source>
          <target state="translated">参数 &lt;code&gt;maxPauseInUs&lt;/code&gt; 和 &lt;code&gt;us&lt;/code&gt; 的单位是微秒。</target>
        </trans-unit>
        <trans-unit id="ebb55c959a3f02d3eea1dc9ff808f8bb2abaea44" translate="yes" xml:space="preserve">
          <source>The unsafeAddr operator</source>
          <target state="translated">unsafeAddr运算符</target>
        </trans-unit>
        <trans-unit id="0ef21f06b17eb379f0787340a289e02dd9482513" translate="yes" xml:space="preserve">
          <source>The upload of new files.</source>
          <target state="translated">新文件的上传。</target>
        </trans-unit>
        <trans-unit id="ffb9dbd8c79b78dedb57dfcf3aa60f5d7e195511" translate="yes" xml:space="preserve">
          <source>The usage of &lt;code&gt;concept&lt;/code&gt; (experimental) is similar to objects.</source>
          <target state="translated">&lt;code&gt;concept&lt;/code&gt; （实验性）的用法类似于对象。</target>
        </trans-unit>
        <trans-unit id="f9c91fbc8283b9f203886fd420138f36678da171" translate="yes" xml:space="preserve">
          <source>The use of &lt;code&gt;{.inject.}&lt;/code&gt; here is necessary again because of template expansion order and hygienic templates. But since we generally want to keep the hygienicness of &lt;code&gt;myTemplate&lt;/code&gt;, and we do not want &lt;code&gt;arg1&lt;/code&gt; to be injected into the context where &lt;code&gt;myTemplate&lt;/code&gt; is expanded, everything is wrapped in a &lt;code&gt;block&lt;/code&gt;.</source>
          <target state="translated">由于模板扩展顺序和卫生模板，再次需要在此处使用 &lt;code&gt;{.inject.}&lt;/code&gt; 。但是，由于我们通常希望保持 &lt;code&gt;myTemplate&lt;/code&gt; 的卫生性，并且我们不希望将 &lt;code&gt;arg1&lt;/code&gt; 注入 &lt;code&gt;myTemplate&lt;/code&gt; 扩展的上下文中，因此所有内容都包装在一个 &lt;code&gt;block&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="8c1da7cd5635c8ed575ed2f00199382fa74a25aa" translate="yes" xml:space="preserve">
          <source>The use of wrappers that use FFI and/or &lt;code&gt;cast&lt;/code&gt; is also disallowed. Note that these wrappers include the ones in the standard libraries.</source>
          <target state="translated">使用包装的是使用FFI和/或 &lt;code&gt;cast&lt;/code&gt; 也不允许。请注意，这些包装包含标准库中的包装。</target>
        </trans-unit>
        <trans-unit id="9a559c657b3e94a5a3b4f28ede4f3e541e9898aa" translate="yes" xml:space="preserve">
          <source>The user guide lists command line arguments, special features of the compiler, etc.</source>
          <target state="translated">用户指南列出了命令行参数、编译器的特殊功能等。</target>
        </trans-unit>
        <trans-unit id="aec3c4c08d9fd434b6b3b95d1925acd83f75de3e" translate="yes" xml:space="preserve">
          <source>The using statement provides syntactic convenience in modules where the same parameter names and types are used over and over. Instead of:</source>
          <target state="translated">在模块中,如果重复使用相同的参数名称和类型,那么using语句提供了语法上的便利。取而代之的是:</target>
        </trans-unit>
        <trans-unit id="99d6383e434dd62dcbce9c98ef86b8da04045406" translate="yes" xml:space="preserve">
          <source>The values of the returned enum should be pretty self explanatory:</source>
          <target state="translated">返回的枚举值应该是非常自明的。</target>
        </trans-unit>
        <trans-unit id="e580cb29ada1c872bcbdfbf5d59c299cb8b1209f" translate="yes" xml:space="preserve">
          <source>The var statement</source>
          <target state="translated">变量语句</target>
        </trans-unit>
        <trans-unit id="44981de5f0080cccfda5bafeb275d3e5b51b6196" translate="yes" xml:space="preserve">
          <source>The var statement declares a new local or global variable:</source>
          <target state="translated">var语句声明了一个新的局部或全局变量。</target>
        </trans-unit>
        <trans-unit id="a7fb42712b4a095b6edcf947d23562ccc99a3384" translate="yes" xml:space="preserve">
          <source>The variable &lt;code&gt;i&lt;/code&gt; is implicitly declared by the &lt;code&gt;for&lt;/code&gt; loop and has the type &lt;code&gt;int&lt;/code&gt;, because that is what &lt;a href=&quot;system#countup&quot;&gt;countup&lt;/a&gt; returns. &lt;code&gt;i&lt;/code&gt; runs through the values 1, 2, .., 10. Each value is &lt;code&gt;echo&lt;/code&gt;-ed. This code does the same:</source>
          <target state="translated">变量 &lt;code&gt;i&lt;/code&gt; 由 &lt;code&gt;for&lt;/code&gt; 循环隐式声明，并且类型为 &lt;code&gt;int&lt;/code&gt; ，因为那是&lt;a href=&quot;system#countup&quot;&gt;countup&lt;/a&gt;返回的内容。 &lt;code&gt;i&lt;/code&gt; 遍历值1、2，..，10。每个值都 &lt;code&gt;echo&lt;/code&gt; 。此代码执行相同的操作：</target>
        </trans-unit>
        <trans-unit id="8964df6ead4489b7696bee7b0f5aec240db046f0" translate="yes" xml:space="preserve">
          <source>The variables are compared with &lt;code&gt;cmpIgnoreStyle&lt;/code&gt;. &lt;code&gt;ValueError&lt;/code&gt; is raised if an ill-formed format string has been passed to the &lt;code&gt;%&lt;/code&gt; operator.</source>
          <target state="translated">将变量与 &lt;code&gt;cmpIgnoreStyle&lt;/code&gt; 进行比较。如果格式错误的格式字符串已传递给 &lt;code&gt;%&lt;/code&gt; 运算符，则会引发 &lt;code&gt;ValueError&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bc84debb5dc6452e51fb2c78cf8623fbed79f8ac" translate="yes" xml:space="preserve">
          <source>The variables are compared with &lt;em&gt;cmpIgnoreStyle&lt;/em&gt;. &lt;em&gt;ValueError&lt;/em&gt; is raised if an ill-formed format string has been passed to the &lt;em&gt;%&lt;/em&gt; operator.</source>
          <target state="translated">将变量与&lt;em&gt;cmpIgnoreStyle&lt;/em&gt;进行比较。如果格式错误的格式字符串已传递给&lt;em&gt;％&lt;/em&gt;运算符，则会引发&lt;em&gt;ValueError&lt;/em&gt;。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="61b57a2d911fc71f98fcabf040635de38c8494ca" translate="yes" xml:space="preserve">
          <source>The version uses &lt;code&gt;cmp&lt;/code&gt; to compare the elements. The expected return values are the same as that of &lt;code&gt;system.cmp&lt;/code&gt;.</source>
          <target state="translated">该版本使用 &lt;code&gt;cmp&lt;/code&gt; 比较元素。期望的返回值与 &lt;code&gt;system.cmp&lt;/code&gt; 相同。</target>
        </trans-unit>
        <trans-unit id="d66e53fcdb4e533daa1d776499d5013cc08f8baa" translate="yes" xml:space="preserve">
          <source>The version uses the default comparison function &lt;code&gt;cmp&lt;/code&gt;.</source>
          <target state="translated">该版本使用默认的比较功能 &lt;code&gt;cmp&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2fa9f6f05c0209f1598bd49966b81632306fcee5" translate="yes" xml:space="preserve">
          <source>The while statement is a simple looping construct:</source>
          <target state="translated">while语句是一个简单的循环结构。</target>
        </trans-unit>
        <trans-unit id="4123d4bcf088a88feae5646d2165ec90f62ac31f" translate="yes" xml:space="preserve">
          <source>The workaround for this is to bind the template argument to a new local variable.</source>
          <target state="translated">这方面的变通方法是将模板参数绑定到一个新的本地变量。</target>
        </trans-unit>
        <trans-unit id="aba71dc483d2c43f3b09cfa11f1f0b476cc3d1fd" translate="yes" xml:space="preserve">
          <source>The year without any padding. Is always positive, even when the year is BC.</source>
          <target state="translated">没有任何铺垫的年份。是永远的正能量,即使是BC年。</target>
        </trans-unit>
        <trans-unit id="ab38f01dd3bc85831012f0bac4816fc3e75b4486" translate="yes" xml:space="preserve">
          <source>The year without any padding. Will be negative when the year is BC.</source>
          <target state="translated">年,没有任何填充物。当年份为BC时将为负数。</target>
        </trans-unit>
        <trans-unit id="07d07d0ea9f8d13f35a29277409b0f19348eb8f7" translate="yes" xml:space="preserve">
          <source>The year, padded to at least four digits. Is always positive, even when the year is BC. When the year is more than four digits, '+' is prepended.</source>
          <target state="translated">年,至少要垫到四位数。始终是正数,即使年份是BC。当年份超过四位数时,会在前面加上'+'。</target>
        </trans-unit>
        <trans-unit id="b9dbc322d029aa3d6f32b6486bd07eb9329bc1da" translate="yes" xml:space="preserve">
          <source>The year, padded to at least four digits. Will be negative when the year is BC. When the year is more than four digits, '+' is prepended unless the year is BC.</source>
          <target state="translated">年份,至少垫到四位数。当年份是BC时,将为负数。当年份超过四位数时,除非年份是BC,否则会在前面加上'+'。</target>
        </trans-unit>
        <trans-unit id="b039a29b58c22bdb2915a3acea080780142c1b28" translate="yes" xml:space="preserve">
          <source>The year, padded to atleast four digits. Is always positive, even when the year is BC. When the year is more than four digits, '+' is prepended.</source>
          <target state="translated">年份,至少要垫到四位数。始终是正数,即使年份是BC。当年份超过四位数时,前面加'+'。</target>
        </trans-unit>
        <trans-unit id="2f78eca394ea113bd4e29e67d3fec4d4e88e2b66" translate="yes" xml:space="preserve">
          <source>The year, padded to atleast four digits. Will be negative when the year is BC. When the year is more than four digits, '+' is prepended unless the year is BC.</source>
          <target state="translated">年份,至少垫到四位数。当年份是BC时,将为负数。当年份超过四位数时,除非年份是BC,否则会在前面加上'+'。</target>
        </trans-unit>
        <trans-unit id="511ad266e7726ce686aa356a227a5ffd4428485f" translate="yes" xml:space="preserve">
          <source>The year, using astronomical year numbering (meaning that before year 1 is year 0, then year -1 and so on).</source>
          <target state="translated">年,采用天文年号(即1年之前是0年,然后是-1年,以此类推)。</target>
        </trans-unit>
        <trans-unit id="7ff8ad7505b8b464009361f8dda42aba0d8ec846" translate="yes" xml:space="preserve">
          <source>Then calls &lt;a href=&quot;#readAll&quot;&gt;readAll&lt;/a&gt; and closes the file afterwards. Returns the string. Raises an IO exception in case of an error. If you need to call this inside a compile time macro you can use &lt;a href=&quot;#staticRead&quot;&gt;staticRead&lt;/a&gt;.</source>
          <target state="translated">然后调用&lt;a href=&quot;#readAll&quot;&gt;readAll&lt;/a&gt;并随后关闭文件。返回字符串。发生错误时引发IO异常。如果需要在编译时宏中调用此&lt;a href=&quot;#staticRead&quot;&gt;函数，则&lt;/a&gt;可以使用staticRead。</target>
        </trans-unit>
        <trans-unit id="030aaf6f2fc0e5a5cf064da69f557632a5c59e9e" translate="yes" xml:space="preserve">
          <source>Then module &lt;code&gt;A&lt;/code&gt; (that depends on &lt;code&gt;B&lt;/code&gt; and &lt;code&gt;G&lt;/code&gt;) is compiled and &lt;code&gt;B&lt;/code&gt; and &lt;code&gt;G&lt;/code&gt; are left unchanged. &lt;code&gt;A&lt;/code&gt; requires &lt;code&gt;G.P2&lt;/code&gt;.</source>
          <target state="translated">然后，编译模块 &lt;code&gt;A&lt;/code&gt; （取决于 &lt;code&gt;B&lt;/code&gt; 和 &lt;code&gt;G&lt;/code&gt; ），并且 &lt;code&gt;B&lt;/code&gt; 和 &lt;code&gt;G&lt;/code&gt; 保持不变。 &lt;code&gt;A&lt;/code&gt; 需要 &lt;code&gt;G.P2&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0ade512072594e8264ff592564aff0e3bc992458" translate="yes" xml:space="preserve">
          <source>Then module &lt;code&gt;B&lt;/code&gt; is compiled that requires &lt;code&gt;G.P1&lt;/code&gt;. Ok, no problem, &lt;code&gt;G.P1&lt;/code&gt; is loaded from the symbol file and &lt;code&gt;G.c&lt;/code&gt; now contains &lt;code&gt;G.P1&lt;/code&gt;.</source>
          <target state="translated">然后模块 &lt;code&gt;B&lt;/code&gt; 编译需要 &lt;code&gt;G.P1&lt;/code&gt; 。OK，没问题， &lt;code&gt;G.P1&lt;/code&gt; 从符号文件加载和 &lt;code&gt;G.c&lt;/code&gt; 现在包含 &lt;code&gt;G.P1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="43a70a722d347238a21f07b6a20009bf20f06664" translate="yes" xml:space="preserve">
          <source>Then move the C code and the compile script &lt;code&gt;compile_myproject.sh&lt;/code&gt; to your Linux i386 machine and run the script.</source>
          <target state="translated">然后将C代码和编译脚本 &lt;code&gt;compile_myproject.sh&lt;/code&gt; 移至Linux i386计算机并运行该脚本。</target>
        </trans-unit>
        <trans-unit id="7f5c1a564b56a99b8a9432588eb7749f18de807c" translate="yes" xml:space="preserve">
          <source>Then there is also the integer literal type. This is a specific type that is implicitly convertible into the requested type if the requested type can hold the value. For this to work, the type needs to know the concrete value of the literal. For example an expression &lt;code&gt;321&lt;/code&gt; will be of type &lt;code&gt;int literal(321)&lt;/code&gt;. This type is implicitly convertible to all integer types and ranges that contain the value &lt;code&gt;321&lt;/code&gt;. That would be all builtin integer types except &lt;code&gt;uint8&lt;/code&gt; and &lt;code&gt;int8&lt;/code&gt; where &lt;code&gt;321&lt;/code&gt; would be out of range. When this literal type is assigned to a new &lt;code&gt;var&lt;/code&gt; or &lt;code&gt;let&lt;/code&gt; variable, it's type will be resolved to just &lt;code&gt;int&lt;/code&gt;, not &lt;code&gt;int literal(321)&lt;/code&gt; unlike constants. A constant keeps the full &lt;code&gt;int literal(321)&lt;/code&gt; type. Here is an example where that difference matters.</source>
          <target state="translated">然后还有整数文字类型。这是一种特殊类型，如果请求的类型可以保存该值，则可以隐式转换为请求的类型。为此，类型需要知道文字的具体值。例如，表达式 &lt;code&gt;321&lt;/code&gt; 的类型为 &lt;code&gt;int literal(321)&lt;/code&gt; 。此类型可以隐式转换为包含值 &lt;code&gt;321&lt;/code&gt; 的所有整数类型和范围。除了 &lt;code&gt;uint8&lt;/code&gt; 和 &lt;code&gt;int8&lt;/code&gt; (其中 &lt;code&gt;321&lt;/code&gt; 超出范围）之外，所有内置整数类型都将包含在内。当将此文字类型分配给新的 &lt;code&gt;var&lt;/code&gt; 或 &lt;code&gt;let&lt;/code&gt; 变量时，其类型将解析为 &lt;code&gt;int&lt;/code&gt; ，而不是 &lt;code&gt;int literal(321)&lt;/code&gt; 与常量不同。常量保留完整的 &lt;code&gt;int literal(321)&lt;/code&gt; 类型。这是一个差异很重要的示例。</target>
        </trans-unit>
        <trans-unit id="e3224338d78f50a303f4e2d270b284e3310633b0" translate="yes" xml:space="preserve">
          <source>There are 2 kinds of iterators in Nim: &lt;em&gt;inline&lt;/em&gt; and &lt;em&gt;closure&lt;/em&gt; iterators. An &lt;span id=&quot;inline-iterator_1&quot;&gt;inline iterator&lt;/span&gt; is an iterator that's always inlined by the compiler leading to zero overhead for the abstraction, but may result in a heavy increase in code size.</source>
          <target state="translated">Nim中有2种迭代器：&lt;em&gt;内联&lt;/em&gt;迭代器和&lt;em&gt;闭包&lt;/em&gt;迭代器。一个&lt;span id=&quot;inline-iterator_1&quot;&gt;内嵌迭代器&lt;/span&gt;是总是由编译器导致零开销抽象内联的迭代器，但可能会导致代码大小一个沉重的增加。</target>
        </trans-unit>
        <trans-unit id="23f5d4391872d1d0618203f6cd8356fa03af48c8" translate="yes" xml:space="preserve">
          <source>There are 2 kinds of iterators in Nim: &lt;em&gt;inline&lt;/em&gt; and &lt;em&gt;closure&lt;/em&gt; iterators. An &lt;span id=&quot;inline-iterator_1&quot;&gt;inline iterator&lt;/span&gt; is an iterator that's always inlined by the compiler leading to zero overhead for the abstraction, but may result in a heavy increase in code size. Inline iterators are second class citizens; They can be passed as parameters only to other inlining code facilities like templates, macros and other inline iterators.</source>
          <target state="translated">Nim中有2种迭代器：&lt;em&gt;内联&lt;/em&gt;迭代器和&lt;em&gt;闭包&lt;/em&gt;迭代器。一个&lt;span id=&quot;inline-iterator_1&quot;&gt;内嵌迭代器&lt;/span&gt;是总是由编译器导致零开销抽象内联的迭代器，但可能会导致代码大小一个沉重的增加。内联迭代器是二等公民。它们只能作为参数传递给其他内联代码工具，例如模板，宏和其他内联迭代器。</target>
        </trans-unit>
        <trans-unit id="2204cd4df928fb544bb442ca84cde7bf3009d982" translate="yes" xml:space="preserve">
          <source>There are 3 operations that are bound to a type:</source>
          <target state="translated">有3种操作可以绑定到一个类型。</target>
        </trans-unit>
        <trans-unit id="6e58d330c906290a3a72d9bf31c8b364392ece8e" translate="yes" xml:space="preserve">
          <source>There are 4 operations that are bound to a type:</source>
          <target state="translated">有4种操作可以绑定到一个类型。</target>
        </trans-unit>
        <trans-unit id="7a602bfe3df3ce7f6d337cd11a7c7400db183b00" translate="yes" xml:space="preserve">
          <source>There are a few details to keep in mind when using this module within multiple threads:</source>
          <target state="translated">在多线程中使用该模块时,有几个细节需要注意。</target>
        </trans-unit>
        <trans-unit id="a85b79c160e40ebe8ffa7f8d4d317c2a9bf28239" translate="yes" xml:space="preserve">
          <source>There are a few things that don't work because the DevkitPro libraries don't support them. They are:</source>
          <target state="translated">由于 DevkitPro 库不支持,有一些东西无法使用。它们是:</target>
        </trans-unit>
        <trans-unit id="0ab99b54c858ac8f9d51bf5e5fe33ce55f9ff7f8" translate="yes" xml:space="preserve">
          <source>There are also raw string literals that are preceded with the letter &lt;code&gt;r&lt;/code&gt; (or &lt;code&gt;R&lt;/code&gt;) and are delimited by matching double quotes (just like ordinary string literals) and do not interpret the escape sequences. This is especially convenient for regular expressions or Windows paths:</source>
          <target state="translated">也有原始字符串文字，其前面带有字母 &lt;code&gt;r&lt;/code&gt; （或 &lt;code&gt;R&lt;/code&gt; ），并由匹配的双引号分隔（就像普通的字符串文字一样），并且不解释转义序列。这对于正则表达式或Windows路径特别方便：</target>
        </trans-unit>
        <trans-unit id="ca885d10f37134acc825e1d0fd4f729e20b0c53b" translate="yes" xml:space="preserve">
          <source>There are currently only two options for verify mode; one is &lt;code&gt;CVerifyNone&lt;/code&gt; and with it certificates will not be verified the other is &lt;code&gt;CVerifyPeer&lt;/code&gt; and certificates will be verified for it, &lt;code&gt;CVerifyPeer&lt;/code&gt; is the safest choice.</source>
          <target state="translated">当前只有两种验证模式选项；一个是 &lt;code&gt;CVerifyNone&lt;/code&gt; ，它将不验证证书，另一个是 &lt;code&gt;CVerifyPeer&lt;/code&gt; ,并且将为此验证证书， &lt;code&gt;CVerifyPeer&lt;/code&gt; 是最安全的选择。</target>
        </trans-unit>
        <trans-unit id="699fd27aa890266a888c5272db783bacf977a6e2" translate="yes" xml:space="preserve">
          <source>There are limitations on what Nim code can be executed at compile time; see &lt;a href=&quot;#restrictions-on-compileminustime-execution&quot;&gt;Restrictions on Compile-Time Execution&lt;/a&gt; for details. It's a static error if the compiler cannot execute the block at compile time.</source>
          <target state="translated">在编译时可以执行什么Nim代码有一些限制。有关详细信息，请参见&lt;a href=&quot;#restrictions-on-compileminustime-execution&quot;&gt;编译时执行限制&lt;/a&gt;。如果编译器无法在编译时执行该块，则这是一个静态错误。</target>
        </trans-unit>
        <trans-unit id="b9bd1745d20224197bc6b19e361674c1fbfbfeef" translate="yes" xml:space="preserve">
          <source>There are multiple ways to get around this, including the use of the &lt;code&gt;&amp;amp;&lt;/code&gt; operator:</source>
          <target state="translated">有多种解决方法，包括使用 &lt;code&gt;&amp;amp;&lt;/code&gt; 运算符：</target>
        </trans-unit>
        <trans-unit id="dfad946c72305fa2959afdaad8dd73249e24fab2" translate="yes" xml:space="preserve">
          <source>There are no constraints for the &lt;code&gt;constructor&lt;/code&gt; AST, it works for nested tuples of arrays of sets etc.</source>
          <target state="translated">&lt;code&gt;constructor&lt;/code&gt; AST 没有任何限制，它适用于集合数组的嵌套元组等。</target>
        </trans-unit>
        <trans-unit id="cf947740d972fdc4f2ebc7b27221b71dc35fbb9e" translate="yes" xml:space="preserve">
          <source>There are no specialized &lt;code&gt;insert&lt;/code&gt;, &lt;code&gt;delete&lt;/code&gt;, &lt;code&gt;add&lt;/code&gt; and &lt;code&gt;contains&lt;/code&gt; procedures for &lt;code&gt;seq[Rune]&lt;/code&gt; in this module because the generic variants of these procedures in the system module already work with it.</source>
          <target state="translated">该模块中没有专门的 &lt;code&gt;seq[Rune]&lt;/code&gt; &lt;code&gt;insert&lt;/code&gt; ， &lt;code&gt;delete&lt;/code&gt; ， &lt;code&gt;add&lt;/code&gt; 和 &lt;code&gt;contains&lt;/code&gt; 过程，因为系统模块中这些过程的通用变体已经可以使用。</target>
        </trans-unit>
        <trans-unit id="7bda84e8a64a9ee0766ebd2e91b0b1fc8bcb50a8" translate="yes" xml:space="preserve">
          <source>There are several different types of hash tables available:</source>
          <target state="translated">有几种不同类型的哈希表可供选择。</target>
        </trans-unit>
        <trans-unit id="3e9b3d4d5566426791f36142323c5dcdbd575538" translate="yes" xml:space="preserve">
          <source>There are several node kinds that are used for semantic checking or code generation. These are accessible from this module, but should not be used. Other node kinds are especially designed to make AST manipulations easier. These are explained here.</source>
          <target state="translated">有几种节点类型用于语义检查或代码生成。这些都可以从这个模块中访问,但不应该被使用。其他的节点种类是为了使AST操作更容易而特别设计的。在这里对这些节点进行了解释。</target>
        </trans-unit>
        <trans-unit id="3dc14568c01dd285d589a27b7cb9cd2809008967" translate="yes" xml:space="preserve">
          <source>There are six logging levels: debug, info, notice, warn, error, and fatal. They are described in more detail within the &lt;a href=&quot;#Level&quot;&gt;Level enum's documentation&lt;/a&gt;. A message is logged if its level is at or above both the logger's &lt;code&gt;levelThreshold&lt;/code&gt; field and the global log filter. The latter can be changed with the &lt;a href=&quot;#setLogFilter,Level&quot;&gt;setLogFilter proc&lt;/a&gt;.</source>
          <target state="translated">有六个日志记录级别：调试，信息，通知，警告，错误和致命。它们在&lt;a href=&quot;#Level&quot;&gt;Level枚举的文档&lt;/a&gt;中有更详细的描述。如果消息的级别等于或高于记录器的 &lt;code&gt;levelThreshold&lt;/code&gt; 字段和全局日志过滤器，则会记录一条消息。后者可以使用&lt;a href=&quot;#setLogFilter,Level&quot;&gt;setLogFilter proc&lt;/a&gt;进行更改。</target>
        </trans-unit>
        <trans-unit id="aca8d001ba881fc8c54bf7d03fbbb467af017be5" translate="yes" xml:space="preserve">
          <source>There are three options for verify mode: &lt;code&gt;CVerifyNone&lt;/code&gt;: certificates are not verified; &lt;code&gt;CVerifyPeer&lt;/code&gt;: certificates are verified; &lt;code&gt;CVerifyPeerUseEnvVars&lt;/code&gt;: certificates are verified and the optional environment variables SSL_CERT_FILE and SSL_CERT_DIR are also used to locate certificates</source>
          <target state="translated">验证模式有三个选项： &lt;code&gt;CVerifyNone&lt;/code&gt; ：不验证证书；不验证证书。 &lt;code&gt;CVerifyPeer&lt;/code&gt; ：证书已验证； &lt;code&gt;CVerifyPeerUseEnvVars&lt;/code&gt; ：验证证书，并且还使用可选的环境变量SSL_CERT_FILE和SSL_CERT_DIR来定位证书</target>
        </trans-unit>
        <trans-unit id="70805ca564aa8b928a6ee8c36e9ffa0c1565c921" translate="yes" xml:space="preserve">
          <source>There are two different sets of metacharacters: those that are recognized anywhere in the pattern except within square brackets, and those that are recognized in square brackets. Outside square brackets, the metacharacters are as follows:</source>
          <target state="translated">有两组不同的元字符:除方括号内的元字符外,图案中任何地方都能识别的元字符,以及方括号内的元字符。方括号外的元字符如下。</target>
        </trans-unit>
        <trans-unit id="9518223ac809befff3867df05b169ff12200b863" translate="yes" xml:space="preserve">
          <source>There are two pseudo directories:</source>
          <target state="translated">有两个伪目录。</target>
        </trans-unit>
        <trans-unit id="8e9491c4554d1cf539e490b9c71cd03f4f655289" translate="yes" xml:space="preserve">
          <source>There are two ways to compile for Android: terminal programs (Termux) and with the NDK (Android Native Development Kit).</source>
          <target state="translated">Android的编译有两种方式:终端程序(Termux)和使用NDK(Android Native Development Kit)。</target>
        </trans-unit>
        <trans-unit id="b6623c5091377da7e54f379e771f12aab4eb9ebe" translate="yes" xml:space="preserve">
          <source>There are two ways to construct a PEG in Nim code:</source>
          <target state="translated">在Nim代码中,有两种方法可以构建PEG。</target>
        </trans-unit>
        <trans-unit id="089b0a2a4fc8aac4d751cf1e71645f608e78c87d" translate="yes" xml:space="preserve">
          <source>There are two ways to invoke a macro:</source>
          <target state="translated">有两种方法可以调用宏。</target>
        </trans-unit>
        <trans-unit id="720936a505c479b6845bfb796080ccd89a044a7d" translate="yes" xml:space="preserve">
          <source>There are two ways to write a macro, either &lt;em&gt;generating&lt;/em&gt; Nim source code and letting the compiler parse it, or creating manually an abstract syntax tree (AST) which you feed to the compiler. In order to build the AST one needs to know how the Nim concrete syntax is converted to an abstract syntax tree (AST). The AST is documented in the &lt;a href=&quot;macros&quot;&gt;macros&lt;/a&gt; module.</source>
          <target state="translated">有两种编写宏的方法，要么&lt;em&gt;生成&lt;/em&gt; Nim源代码并让编译器对其进行解析，要么手动创建要馈送到编译器的抽象语法树（AST）。为了构建AST，需要知道如何将Nim具体语法转换为抽象语法树（AST）。AST记录在&lt;a href=&quot;macros&quot;&gt;宏&lt;/a&gt;模块中。</target>
        </trans-unit>
        <trans-unit id="f9bcbe7393ec87f587011e8d840878f558c1f97b" translate="yes" xml:space="preserve">
          <source>There can be zero or more &lt;code&gt;elif&lt;/code&gt; parts, and the &lt;code&gt;else&lt;/code&gt; part is optional. The keyword &lt;code&gt;elif&lt;/code&gt; is short for &lt;code&gt;else if&lt;/code&gt;, and is useful to avoid excessive indentation. (The &lt;code&gt;&quot;&quot;&lt;/code&gt; is the empty string. It contains no characters.)</source>
          <target state="translated">可以有零个或多个 &lt;code&gt;elif&lt;/code&gt; 部分，而 &lt;code&gt;else&lt;/code&gt; 部分是可选的。关键字 &lt;code&gt;elif&lt;/code&gt; 是 &lt;code&gt;else if&lt;/code&gt; 缩写，对于避免缩进过多很有用。（ &lt;code&gt;&quot;&quot;&lt;/code&gt; 为空字符串。不包含任何字符。）</target>
        </trans-unit>
        <trans-unit id="a3d437f79271578914f708f4086005edd9d04476" translate="yes" xml:space="preserve">
          <source>There exists a literal for each numerical type that is defined. The suffix starting with an apostrophe (''') is called a &lt;span id=&quot;type-suffix_1&quot;&gt;type suffix&lt;/span&gt;. Literals without a type suffix are of an integer type unless the literal contains a dot or &lt;code&gt;E|e&lt;/code&gt; in which case it is of type &lt;code&gt;float&lt;/code&gt;. This integer type is &lt;code&gt;int&lt;/code&gt; if the literal is in the range &lt;code&gt;low(i32)..high(i32)&lt;/code&gt;, otherwise it is &lt;code&gt;int64&lt;/code&gt;. For notational convenience, the apostrophe of a type suffix is optional if it is not ambiguous (only hexadecimal floating-point literals with a type suffix can be ambiguous).</source>
          <target state="translated">每个定义的数字类型都有一个文字。以撇号（'''）开头的后缀称为&lt;span id=&quot;type-suffix_1&quot;&gt;类型后缀&lt;/span&gt;。没有类型后缀的文字是整数类型，除非文字包含点或 &lt;code&gt;E|e&lt;/code&gt; 在这种情况下，它是 &lt;code&gt;float&lt;/code&gt; 类型。如果文字范围在 &lt;code&gt;low(i32)..high(i32)&lt;/code&gt; 范围内，则此整数类型为 &lt;code&gt;int&lt;/code&gt; ，否则为 &lt;code&gt;int64&lt;/code&gt; 。为了符号上的方便，如果类型后缀不是模棱两可的，则后缀的撇号是可选的（只有带有类型后缀的十六进制浮点文字可以是模棱两可的）。</target>
        </trans-unit>
        <trans-unit id="77cfdf22bf86043f8acee986bff271197e1936f9" translate="yes" xml:space="preserve">
          <source>There exists a literal for each numerical type that is defined. The suffix starting with an apostrophe (''') is called a &lt;span id=&quot;type-suffix_1&quot;&gt;type suffix&lt;/span&gt;. Literals without a type suffix are of an integer type, unless the literal contains a dot or &lt;code&gt;E|e&lt;/code&gt; in which case it is of type &lt;code&gt;float&lt;/code&gt;. This integer type is &lt;code&gt;int&lt;/code&gt; if the literal is in the range &lt;code&gt;low(i32)..high(i32)&lt;/code&gt;, otherwise it is &lt;code&gt;int64&lt;/code&gt;. For notational convenience the apostrophe of a type suffix is optional if it is not ambiguous (only hexadecimal floating point literals with a type suffix can be ambiguous).</source>
          <target state="translated">每个定义的数字类型都有一个文字。以撇号（'''）开头的后缀称为&lt;span id=&quot;type-suffix_1&quot;&gt;类型后缀&lt;/span&gt;。没有类型后缀的文字是整数类型，除非文字包含点或 &lt;code&gt;E|e&lt;/code&gt; 在这种情况下，它是 &lt;code&gt;float&lt;/code&gt; 类型。如果文字范围在 &lt;code&gt;low(i32)..high(i32)&lt;/code&gt; 范围内，则此整数类型为 &lt;code&gt;int&lt;/code&gt; ，否则为 &lt;code&gt;int64&lt;/code&gt; 。为了符号上的方便，如果类型后缀不是模棱两可的，则单引号是可选的（只有带有类型后缀的十六进制浮点文字可以是模棱两可的）。</target>
        </trans-unit>
        <trans-unit id="90fe0ee868ac44e50e7a55bf1d6f6587b14d23c1" translate="yes" xml:space="preserve">
          <source>There is a syntactic sugar for calling routines: The syntax &lt;code&gt;obj.method(args)&lt;/code&gt; can be used instead of &lt;code&gt;method(obj, args)&lt;/code&gt;. If there are no remaining arguments, the parentheses can be omitted: &lt;code&gt;obj.len&lt;/code&gt; (instead of &lt;code&gt;len(obj)&lt;/code&gt;).</source>
          <target state="translated">调用例程有一个语法糖：可以使用语法 &lt;code&gt;obj.method(args)&lt;/code&gt; 代替 &lt;code&gt;method(obj, args)&lt;/code&gt; 。如果没有剩余的参数，则可以省略括号： &lt;code&gt;obj.len&lt;/code&gt; （而不是 &lt;code&gt;len(obj)&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="809686a502cf19e841efede0ad4446dfca6c035b" translate="yes" xml:space="preserve">
          <source>There is an analysis that checks that &lt;code&gt;counters[i].L&lt;/code&gt; is the lock that corresponds to the protected location &lt;code&gt;counters[i].v&lt;/code&gt;. This analysis is called &lt;span id=&quot;path-analysis_1&quot;&gt;path analysis&lt;/span&gt; because it deals with paths to locations like &lt;code&gt;obj.field[i].fieldB[j]&lt;/code&gt;.</source>
          <target state="translated">有一种分析检查 &lt;code&gt;counters[i].L&lt;/code&gt; 是与受保护的位置 &lt;code&gt;counters[i].v&lt;/code&gt; 对应的锁。该分析称为&lt;span id=&quot;path-analysis_1&quot;&gt;路径分析，&lt;/span&gt;因为它处理的是 &lt;code&gt;obj.field[i].fieldB[j]&lt;/code&gt; 类的位置的路径。</target>
        </trans-unit>
        <trans-unit id="9be47a2e7d24c1f78266ccdbd346bb776f9d13ab" translate="yes" xml:space="preserve">
          <source>There is another consideration. Nim has flexible type identification for its procs. Even though &lt;code&gt;proc(a: int, b: int)&lt;/code&gt; and &lt;code&gt;proc(a, b: int)&lt;/code&gt; are equivalent in the code, the AST is a little different for the latter.</source>
          <target state="translated">还有另一个考虑。Nim的proc具有灵活的类型标识。即使 &lt;code&gt;proc(a: int, b: int)&lt;/code&gt; 和 &lt;code&gt;proc(a, b: int)&lt;/code&gt; 在代码中是等效的，但AST对于后者来说还是有些不同。</target>
        </trans-unit>
        <trans-unit id="ef0bece8693cc3f6cf7cc996e5ec28c503f5ee8c" translate="yes" xml:space="preserve">
          <source>There is no need to check for &lt;code&gt;cmdEnd&lt;/code&gt; while iterating.</source>
          <target state="translated">迭代时无需检查 &lt;code&gt;cmdEnd&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="37a21bfca1dc8f206e73873a032f9f2495f5c004" translate="yes" xml:space="preserve">
          <source>These are the major type classes:</source>
          <target state="translated">这些都是主要的类型类。</target>
        </trans-unit>
        <trans-unit id="c9f26df48cd633ca6dc9c4a4cfdeb29e86e918f9" translate="yes" xml:space="preserve">
          <source>These assertions may not appear in character classes (but note that &lt;code&gt;\b&lt;/code&gt; has a different meaning, namely the backspace character, inside a character class).</source>
          <target state="translated">这些断言可能不会出现在字符类中（但请注意 &lt;code&gt;\b&lt;/code&gt; 具有不同的含义，即字符类内部的退格字符）。</target>
        </trans-unit>
        <trans-unit id="74dbc337c7d11370d75e44ba74f2cb86ce0accdc" translate="yes" xml:space="preserve">
          <source>These character type sequences can appear both inside and outside character classes. They each match one character of the appropriate type. If the current matching point is at the end of the subject string, all of them fail, since there is no character to match.</source>
          <target state="translated">这些字符类型序列可以出现在字符类内部和外部。它们各自匹配一个相应类型的字符。如果当前的匹配点在主题字符串的末尾,那么所有的匹配都会失败,因为没有字符可匹配。</target>
        </trans-unit>
        <trans-unit id="121cd2b220ceffc68b4f037b698a6ce125bbb7d9" translate="yes" xml:space="preserve">
          <source>These directives tell c2nim that it should annotate every proc (or proc type) with the &lt;code&gt;stdcall&lt;/code&gt; / &lt;code&gt;cdecl&lt;/code&gt; calling convention.</source>
          <target state="translated">这些指令告诉c2nim，它应该使用 &lt;code&gt;stdcall&lt;/code&gt; / &lt;code&gt;cdecl&lt;/code&gt; 调用约定来注释每个proc（或proc类型）。</target>
        </trans-unit>
        <trans-unit id="defe996f8d7935ccd354c5fcc6274f5321b86ee2" translate="yes" xml:space="preserve">
          <source>These examples all use the default random number generator. The &lt;a href=&quot;#Rand&quot;&gt;Rand type&lt;/a&gt; represents the state of a random number generator. For convenience, this module contains a default Rand state that corresponds to the default random number generator. Most procs in this module which do not take in a Rand parameter, including those called in the above examples, use the default generator. Those procs are &lt;strong&gt;not&lt;/strong&gt; thread-safe.</source>
          <target state="translated">这些示例都使用默认的随机数生成器。的&lt;a href=&quot;#Rand&quot;&gt;兰德类型&lt;/a&gt;表示随机数生成器的状态。为了方便起见，该模块包含一个默认的Rand状态，该状态与默认的随机数生成器相对应。此模块中的大多数不带Rand参数的proc（包括在以上示例中调用的proc）都使用默认生成器。这些过程&lt;strong&gt;不是&lt;/strong&gt;线程安全的。</target>
        </trans-unit>
        <trans-unit id="3448534ab91afc28628316690fa8a8d7be286ead" translate="yes" xml:space="preserve">
          <source>These features also work for declarations like &lt;code&gt;#if defined(SYMBOL)&lt;/code&gt; and boolean combinations of such declarations.</source>
          <target state="translated">这些功能还适用于诸如 &lt;code&gt;#if defined(SYMBOL)&lt;/code&gt; 之类的声明以及此类声明的布尔组合。</target>
        </trans-unit>
        <trans-unit id="ac3f7d81f9ef3ace4ce8ec9e07e91300c660430c" translate="yes" xml:space="preserve">
          <source>These integer types are pre-defined:</source>
          <target state="translated">这些整数类型是预先定义的。</target>
        </trans-unit>
        <trans-unit id="99ab24068b59d19aa34809cf736b37f6dd349129" translate="yes" xml:space="preserve">
          <source>These keywords are also operators: &lt;code&gt;and or not xor shl shr div mod in notin is isnot of as from&lt;/code&gt;.</source>
          <target state="translated">这些关键字也是运算符： &lt;code&gt;and or not xor shl shr div mod in notin is isnot of as from&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="55066fb4694c635ce07b74e97002d73c6ea9c5d5" translate="yes" xml:space="preserve">
          <source>These keywords are also operators: &lt;code&gt;and or not xor shl shr div mod in notin is isnot of&lt;/code&gt;.</source>
          <target state="translated">这些关键字也是运算符： &lt;code&gt;and or not xor shl shr div mod in notin is isnot of&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="38f129b5e4464e0480827e37320803bf08418860" translate="yes" xml:space="preserve">
          <source>These matching categories have a priority: An exact match is better than a literal match and that is better than a generic match etc. In the following &lt;code&gt;count(p, m)&lt;/code&gt; counts the number of matches of the matching category &lt;code&gt;m&lt;/code&gt; for the routine &lt;code&gt;p&lt;/code&gt;.</source>
          <target state="translated">这些匹配类别具有优先级：精确匹配优于文字匹配，也优于泛型匹配等。在以下 &lt;code&gt;count(p, m)&lt;/code&gt; 中，为例程 &lt;code&gt;p&lt;/code&gt; 计算匹配类别 &lt;code&gt;m&lt;/code&gt; 的匹配数。</target>
        </trans-unit>
        <trans-unit id="6f68cbc9b1069e256838107b36cf58486fce6b38" translate="yes" xml:space="preserve">
          <source>These numbers are usually only for the running thread, not for the whole heap, with the exception of &lt;code&gt;--gc:boehm&lt;/code&gt; and &lt;code&gt;--gc:go&lt;/code&gt;.</source>
          <target state="translated">这些数字通常仅适用于正在运行的线程，而不适用于整个堆，-- &lt;code&gt;--gc:boehm&lt;/code&gt; 和 &lt;code&gt;--gc:go&lt;/code&gt; 除外。</target>
        </trans-unit>
        <trans-unit id="d6be02e33307dc5ed705daa9fb25cdf4cc144412" translate="yes" xml:space="preserve">
          <source>These operations are supported by sets:</source>
          <target state="translated">这些操作都得到了集的支持。</target>
        </trans-unit>
        <trans-unit id="cde2e097c323766072e20c648ae133aff15ec9e4" translate="yes" xml:space="preserve">
          <source>These operations can be &lt;em&gt;overridden&lt;/em&gt; instead of &lt;em&gt;overloaded&lt;/em&gt;. This means the implementation is automatically lifted to structured types. For instance if type &lt;code&gt;T&lt;/code&gt; has an overridden assignment operator &lt;code&gt;=&lt;/code&gt; this operator is also used for assignments of the type &lt;code&gt;seq[T]&lt;/code&gt;. Since these operations are bound to a type they have to be bound to a nominal type for reasons of simplicity of implementation: This means an overridden &lt;code&gt;deepCopy&lt;/code&gt; for &lt;code&gt;ref T&lt;/code&gt; is really bound to &lt;code&gt;T&lt;/code&gt; and not to &lt;code&gt;ref T&lt;/code&gt;. This also means that one cannot override &lt;code&gt;deepCopy&lt;/code&gt; for both &lt;code&gt;ptr T&lt;/code&gt; and &lt;code&gt;ref T&lt;/code&gt; at the same time; instead a helper distinct or object type has to be used for one pointer type.</source>
          <target state="translated">这些操作可以被&lt;em&gt;覆盖&lt;/em&gt;而不是被&lt;em&gt;重载&lt;/em&gt;。这意味着实现会自动提升为结构化类型。例如，如果类型 &lt;code&gt;T&lt;/code&gt; 具有重写的赋值运算符 &lt;code&gt;=&lt;/code&gt; ,则此运算符也用于 &lt;code&gt;seq[T]&lt;/code&gt; 类型的赋值。由于这些操作绑定到一个类型，他们必须被绑定到一个标称类型实现简单的原因：这意味着一个重写的 &lt;code&gt;deepCopy&lt;/code&gt; 对 &lt;code&gt;ref T&lt;/code&gt; 真的势必 &lt;code&gt;T&lt;/code&gt; ，而不是 &lt;code&gt;ref T&lt;/code&gt; 。这也意味着无法 &lt;code&gt;deepCopy&lt;/code&gt; 为 &lt;code&gt;ptr T&lt;/code&gt; 和 &lt;code&gt;ref T&lt;/code&gt; 覆盖deepCopy。与此同时; 相反，必须将一个辅助对象或对象类型用于一种指针类型。</target>
        </trans-unit>
        <trans-unit id="6299dd429eaf3e5782e3b62dbebbf950dd6652fe" translate="yes" xml:space="preserve">
          <source>These procs may not be imported by a module. You can import them directly for debugging:</source>
          <target state="translated">这些程序不能由模块导入。你可以直接导入它们进行调试。</target>
        </trans-unit>
        <trans-unit id="6b2944d8a6fb10906fbe7ddce83dab9ed4b20716" translate="yes" xml:space="preserve">
          <source>These procs provide a &quot;best effort&quot; real-time guarantee; in particular the cycle collector is not aware of deadlines. Deactivate it to get more predictable real-time behaviour. Tests show that a 1ms max pause time will be met in almost all cases on modern CPUs (with the cycle collector disabled).</source>
          <target state="translated">这些程序提供了一个 &quot;尽最大努力 &quot;的实时保证;特别是循环收集器不知道截止日期。停用它可以获得更多可预测的实时行为。测试表明,在现代CPU上,几乎所有情况下都能满足1ms的最大暂停时间(禁用周期收集器)。</target>
        </trans-unit>
        <trans-unit id="d058bd216e6b19e493d9e6bac8c481c3e459bccb" translate="yes" xml:space="preserve">
          <source>These procs provide a &quot;best effort&quot; realtime guarantee; in particular the cycle collector is not aware of deadlines yet. Deactivate it to get more predictable realtime behaviour. Tests show that a 2ms max pause time will be met in almost all cases on modern CPUs (with the cycle collector disabled).</source>
          <target state="translated">这些procs提供了一个 &quot;尽力 &quot;的实时保证;特别是循环收集器还不知道截止日期。停用它可以获得更多可预测的实时行为。测试表明,在现代CPU上,几乎所有情况下都能满足2ms的最大暂停时间(禁用循环收集器)。</target>
        </trans-unit>
        <trans-unit id="30e9bd52ae679ca98f3066fcb8847b5f10bc445a" translate="yes" xml:space="preserve">
          <source>These rules ensure that the construction is tied to a variable and can easily be destructed at its scope exit. Later versions of the language will improve the support of destructors.</source>
          <target state="translated">这些规则确保了构造与变量绑定,并且可以在其作用域退出时轻松地被反编译。该语言的以后版本将改进对析构器的支持。</target>
        </trans-unit>
        <trans-unit id="c2e945da53bb4b2f455a09e7679d83624a41491a" translate="yes" xml:space="preserve">
          <source>These rules will only be enforced for contributions to the Nim codebase and official projects, such as the Nim compiler, the standard library, and the various official tools such as C2Nim.</source>
          <target state="translated">这些规则只适用于对Nim代码库和官方项目的贡献,如Nim编译器、标准库和各种官方工具,如C2Nim。</target>
        </trans-unit>
        <trans-unit id="20ac174437fbb360f6e0d2c7d84e935dee5e35b6" translate="yes" xml:space="preserve">
          <source>These templates need to be named &lt;code&gt;atom&lt;/code&gt; and &lt;code&gt;nxt&lt;/code&gt;. &lt;code&gt;atom&lt;/code&gt; should be overloaded to handle both single characters and sets of character.</source>
          <target state="translated">这些模板需要命名为 &lt;code&gt;atom&lt;/code&gt; 和 &lt;code&gt;nxt&lt;/code&gt; 。应该重载 &lt;code&gt;atom&lt;/code&gt; 以处理单个字符和字符集。</target>
        </trans-unit>
        <trans-unit id="e15bd991ab50e168df4221760f8fc062679bfd84" translate="yes" xml:space="preserve">
          <source>These three kinds of tokens are enumerated in the &lt;a href=&quot;#CmdLineKind&quot;&gt;CmdLineKind enum&lt;/a&gt;.</source>
          <target state="translated">这三种令牌在&lt;a href=&quot;#CmdLineKind&quot;&gt;CmdLineKind枚举中枚举&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="feeffd43778c20cf3fc45000f1736b9d3dd71d0f" translate="yes" xml:space="preserve">
          <source>These two procs are the two modus operandi of the real-time garbage collector:</source>
          <target state="translated">这两个procs是实时垃圾收集器的两个操作模式。</target>
        </trans-unit>
        <trans-unit id="b1388617e7ec8cadd15c7db56c0366fdc608c12a" translate="yes" xml:space="preserve">
          <source>These two procs are the two modus operandi of the realtime GC:</source>
          <target state="translated">这两个procs是实时GC的两个操作模式。</target>
        </trans-unit>
        <trans-unit id="fcd0654223087b53e78c4c1fc707eb12347ccb71" translate="yes" xml:space="preserve">
          <source>This HTTP server has not been designed to be used in production, but for testing applications locally. Because of this, when deploying your application in production you should use a reverse proxy (for example nginx) instead of allowing users to connect directly to this server.</source>
          <target state="translated">这个HTTP服务器并不是被设计用于生产,而是用于本地测试应用程序。正因为如此,当在生产中部署应用程序时,你应该使用反向代理(例如nginx),而不是让用户直接连接到这个服务器。</target>
        </trans-unit>
        <trans-unit id="1d97cf346f8ff44e70f702c406d7880c63dc3778" translate="yes" xml:space="preserve">
          <source>This HTTP server has not been designed to be used in production, but for testing applications locally. Because of this, when deploying your application you should use a reverse proxy (for example nginx) instead of allowing users to connect directly to this server.</source>
          <target state="translated">这个HTTP服务器并不是被设计用于生产,而是用于本地测试应用程序。正因为如此,当部署你的应用程序时,你应该使用一个反向代理(例如nginx),而不是让用户直接连接到这个服务器。</target>
        </trans-unit>
        <trans-unit id="0ff934bf75567640acf83ce1e9399ceeeffb3152" translate="yes" xml:space="preserve">
          <source>This Module implements types and macros to facilitate the wrapping of, and interaction with JavaScript libraries. Using the provided types &lt;code&gt;JsObject&lt;/code&gt; and &lt;code&gt;JsAssoc&lt;/code&gt; together with the provided macros allows for smoother interfacing with JavaScript, allowing for example quick and easy imports of JavaScript variables:</source>
          <target state="translated">该模块实现类型和宏，以促进JavaScript库的包装和与之交互。通过使用提供的类型 &lt;code&gt;JsObject&lt;/code&gt; 和 &lt;code&gt;JsAssoc&lt;/code&gt; 以及提供的宏，可以更流畅地与JavaScript交互，例如可以快速，轻松地导入JavaScript变量：</target>
        </trans-unit>
        <trans-unit id="4c9473d766d312db31a1b340bc58dd29fe1c84c3" translate="yes" xml:space="preserve">
          <source>This allows the &lt;code&gt;in&lt;/code&gt; operator: &lt;code&gt;a.contains(item)&lt;/code&gt; is the same as &lt;code&gt;item in a&lt;/code&gt;.</source>
          <target state="translated">这允许 &lt;code&gt;in&lt;/code&gt; 运算符： &lt;code&gt;a.contains(item)&lt;/code&gt; 与中的 &lt;code&gt;item in a&lt;/code&gt; 相同。</target>
        </trans-unit>
        <trans-unit id="358531b90c868b5aa1914c45c295c0b938277040" translate="yes" xml:space="preserve">
          <source>This allows the GC to perform some work for up to &lt;code&gt;us&lt;/code&gt; time. This is useful to call in a main loop to ensure the GC can do its work. To bind all GC activity to a &lt;code&gt;GC_step&lt;/code&gt; call, deactivate the GC with &lt;code&gt;GC_disable&lt;/code&gt; at program startup. If &lt;code&gt;strongAdvice&lt;/code&gt; is set to &lt;code&gt;true&lt;/code&gt;, GC will be forced to perform collection cycle. Otherwise, GC may decide not to do anything, if there is not much garbage to collect. You may also specify the current stack size via &lt;code&gt;stackSize&lt;/code&gt; parameter. It can improve performance, when you know that there are no unique Nim references below certain point on the stack. Make sure the size you specify is greater than the potential worst case size.</source>
          <target state="translated">这使GC可以执行一些工作，而这要花费 &lt;code&gt;us&lt;/code&gt; 最多的时间。调用主循环以确保GC可以完成其工作非常有用。要将所有GC活动绑定到 &lt;code&gt;GC_step&lt;/code&gt; 调用， &lt;code&gt;GC_disable&lt;/code&gt; 在程序启动时使用GC_disable禁用GC 。如果将 &lt;code&gt;strongAdvice&lt;/code&gt; 设置为 &lt;code&gt;true&lt;/code&gt; ，将强制GC执行收集周期。否则，如果没有太多垃圾可以收集，GC可能会决定不采取任何措施。您也可以通过 &lt;code&gt;stackSize&lt;/code&gt; 参数指定当前的堆栈大小。当您知道在堆栈上的特定点以下没有唯一的Nim引用时，它可以提高性能。确保您指定的大小大于潜在的最坏情况的大小。</target>
        </trans-unit>
        <trans-unit id="2bd372177757f2122848f7b55d70ddc516c7db4f" translate="yes" xml:space="preserve">
          <source>This allows the garbage collector to perform some work for up to &lt;code&gt;us&lt;/code&gt; time. This is useful to call in the main loop to ensure the garbage collector can do its work. To bind all garbage collector activity to a &lt;code&gt;GC_step&lt;/code&gt; call, deactivate the garbage collector with &lt;code&gt;GC_disable&lt;/code&gt; at program startup. If &lt;code&gt;strongAdvice&lt;/code&gt; is set to &lt;code&gt;true&lt;/code&gt;, then the garbage collector will be forced to perform the collection cycle. Otherwise, the garbage collector may decide not to do anything, if there is not much garbage to collect. You may also specify the current stack size via &lt;code&gt;stackSize&lt;/code&gt; parameter. It can improve performance when you know that there are no unique Nim references below a certain point on the stack. Make sure the size you specify is greater than the potential worst-case size.</source>
          <target state="translated">这使垃圾收集器可以执行一些工作，而这要花费 &lt;code&gt;us&lt;/code&gt; 最多的时间。调用主循环以确保垃圾收集器可以完成其工作，这很有用。要将所有垃圾收集器活动绑定到 &lt;code&gt;GC_step&lt;/code&gt; 调用， &lt;code&gt;GC_disable&lt;/code&gt; 在程序启动时使用GC_disable禁用垃圾收集器。如果将 &lt;code&gt;strongAdvice&lt;/code&gt; 设置为 &lt;code&gt;true&lt;/code&gt; ，那么垃圾收集器将被强制执行收集周期。否则，如果没有太多的垃圾要收集，则垃圾收集器可能会决定不执行任何操作。您也可以通过 &lt;code&gt;stackSize&lt;/code&gt; 指定当前的堆栈大小范围。当您知道堆栈中某个特定点以下没有唯一的Nim引用时，它可以提高性能。确保您指定的大小大于潜在的最坏情况的大小。</target>
        </trans-unit>
        <trans-unit id="89e916ac1adfc72c259e0e62a432899799f46cd9" translate="yes" xml:space="preserve">
          <source>This allows the usage of &lt;code&gt;in&lt;/code&gt; operator.</source>
          <target state="translated">这允许使用 &lt;code&gt;in&lt;/code&gt; 运算符。</target>
        </trans-unit>
        <trans-unit id="f44902b035eecd212cbee979b0a89c76d9b13672" translate="yes" xml:space="preserve">
          <source>This also means that it is not possible to write a literal in an unchecked AST that will after sem checking just be of type &lt;code&gt;int&lt;/code&gt; and not implicitly convertible to other integer types. This only works for all integer types that are not &lt;code&gt;int&lt;/code&gt;.</source>
          <target state="translated">这也意味着不可能在未经检查的AST中写入文字，该文字将在sem检查之后只是 &lt;code&gt;int&lt;/code&gt; 类型，并且不能隐式转换为其他整数类型。这仅适用于所有非 &lt;code&gt;int&lt;/code&gt; 的整数类型。</target>
        </trans-unit>
        <trans-unit id="992f03b78bcf1d185430a70aa05788b70938c9a1" translate="yes" xml:space="preserve">
          <source>This blocks until a message has arrived! You may use &lt;a href=&quot;#peek,Channel%5BTMsg%5D&quot;&gt;peek proc&lt;/a&gt; to avoid the blocking.</source>
          <target state="translated">这将阻止，直到消息到达为止！您可以使用&lt;a href=&quot;#peek,Channel%5BTMsg%5D&quot;&gt;peek proc&lt;/a&gt;来避免阻塞。</target>
        </trans-unit>
        <trans-unit id="11b2e587ffff759ed345a7138f93f32e7018411a" translate="yes" xml:space="preserve">
          <source>This calls &lt;code&gt;match&lt;/code&gt; with an implicit declared &lt;code&gt;matches&lt;/code&gt; array that can be used in the scope of the &lt;code&gt;=~&lt;/code&gt; call:</source>
          <target state="translated">该调用使用一个可在 &lt;code&gt;=~&lt;/code&gt; 调用范围内使用的隐式声明的 &lt;code&gt;matches&lt;/code&gt; 数组进行 &lt;code&gt;match&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="91e68c05bbcd84956d6a939da42a4d1620388308" translate="yes" xml:space="preserve">
          <source>This can be accomplished with the &lt;code&gt;#discardableprefix&lt;/code&gt; directive. As its name suggests functions of the given prefix(es) that have non-void return type get annotated with &lt;code&gt;.discardable&lt;/code&gt;:</source>
          <target state="translated">这可以通过 &lt;code&gt;#discardableprefix&lt;/code&gt; 指令来完成。顾名思义，具有非空返回类型的给定前缀的函数将使用 &lt;code&gt;.discardable&lt;/code&gt; 进行注释：</target>
        </trans-unit>
        <trans-unit id="993037ecc6a7a9266978b1b72316c93245910c17" translate="yes" xml:space="preserve">
          <source>This can be avoided by distinguishing strings that contain SQL from strings that don't. Distinct types provide a means to introduce a new string type &lt;code&gt;SQL&lt;/code&gt; that is incompatible with &lt;code&gt;string&lt;/code&gt;:</source>
          <target state="translated">可以通过将包含SQL的字符串与不包含SQL的字符串区分开来避免这种情况。不同类型提供了一种引入新字符串类型 &lt;code&gt;SQL&lt;/code&gt; 的方法，该SQL与 &lt;code&gt;string&lt;/code&gt; 不兼容：</target>
        </trans-unit>
        <trans-unit id="e0f58418896b0318ad50111ccb458545bca077f8" translate="yes" xml:space="preserve">
          <source>This can be fixed by explicitly using &lt;code&gt;return&lt;/code&gt;:</source>
          <target state="translated">这可以通过显式使用 &lt;code&gt;return&lt;/code&gt; 来解决：</target>
        </trans-unit>
        <trans-unit id="de90335a89d6a027e12fb152c891c86ef2f05f70" translate="yes" xml:space="preserve">
          <source>This can be used to check whether a library provides a certain feature or not:</source>
          <target state="translated">这可以用来检查一个库是否提供了某个功能。</target>
        </trans-unit>
        <trans-unit id="9a87a7c0c14223cb397afe2f968231607dd88a29" translate="yes" xml:space="preserve">
          <source>This can be useful when you have a value that can be present or not. The absence of a value is often represented by &lt;code&gt;nil&lt;/code&gt;, but it is not always available, nor is it always a good solution.</source>
          <target state="translated">当您有一个可以存在或不存在的值时，这将很有用。缺少值通常用 &lt;code&gt;nil&lt;/code&gt; 表示，但它并不总是可用，也不总是一个好的解决方案。</target>
        </trans-unit>
        <trans-unit id="3b2e2827e1dd9cc8f707a6716c04839c0c09dae0" translate="yes" xml:space="preserve">
          <source>This checks 0-9 ASCII characters only.</source>
          <target state="translated">此项仅检查0-9 ASCII字符。</target>
        </trans-unit>
        <trans-unit id="b3ae4abe96c6abb652268187695385d740f80fff" translate="yes" xml:space="preserve">
          <source>This checks 0-9 ASCII characters only. Returns true if all characters in &lt;em&gt;s&lt;/em&gt; are numeric and there is at least one character in &lt;em&gt;s&lt;/em&gt;.</source>
          <target state="translated">这仅检查0-9 ASCII字符。返回true如果在所有字符&lt;em&gt;小号&lt;/em&gt;是数字并有至少一个字符的&lt;em&gt;小号&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="b117d9b50603d6a49490348238bc1594481a404a" translate="yes" xml:space="preserve">
          <source>This checks ASCII characters only.</source>
          <target state="translated">此项仅检查ASCII字符。</target>
        </trans-unit>
        <trans-unit id="21d99d6543b30de8fb262a673a04b6b39bf07b1e" translate="yes" xml:space="preserve">
          <source>This checks ASCII characters only. Use &lt;a href=&quot;unicode&quot;&gt;Unicode module&lt;/a&gt; for UTF-8 support.</source>
          <target state="translated">这仅检查ASCII字符。使用&lt;a href=&quot;unicode&quot;&gt;Unicode模块&lt;/a&gt;提供UTF-8支持。</target>
        </trans-unit>
        <trans-unit id="cbc954298ac0dfb73fe360b4e03334044ae90394" translate="yes" xml:space="preserve">
          <source>This checks a-z, A-Z ASCII characters only.</source>
          <target state="translated">该功能仅检查a-z、A-Z ASCII字符。</target>
        </trans-unit>
        <trans-unit id="27f5c2b32f5e5afe9cd3e0adefb2a5846fa92f48" translate="yes" xml:space="preserve">
          <source>This checks a-z, A-Z ASCII characters only. Returns true if all characters in &lt;em&gt;s&lt;/em&gt; are alphabetic and there is at least one character in &lt;em&gt;s&lt;/em&gt;.</source>
          <target state="translated">这仅检查z，AZ ASCII字符。返回true如果在所有字符&lt;em&gt;小号&lt;/em&gt;是字母和至少有一个字符的&lt;em&gt;小号&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="78cfd4a754ca378bfad60ee60fd52a76f4ce74da" translate="yes" xml:space="preserve">
          <source>This checks a-z, A-Z ASCII characters only. Use &lt;a href=&quot;unicode&quot;&gt;Unicode module&lt;/a&gt; for UTF-8 support.</source>
          <target state="translated">这仅检查z，AZ ASCII字符。使用&lt;a href=&quot;unicode&quot;&gt;Unicode模块&lt;/a&gt;提供UTF-8支持。</target>
        </trans-unit>
        <trans-unit id="37c461ad96b6496c8497bea23444e5f754d29e62" translate="yes" xml:space="preserve">
          <source>This checks a-z, A-Z, 0-9 ASCII characters only.</source>
          <target state="translated">此项只检查a-z,A-Z,0-9 ASCII字符。</target>
        </trans-unit>
        <trans-unit id="7dc2aa227843f2651d01fb29a6a47bedb18d9c19" translate="yes" xml:space="preserve">
          <source>This checks a-z, A-Z, 0-9 ASCII characters only. Returns true if all characters in &lt;em&gt;s&lt;/em&gt; are alpanumeric and there is at least one character in &lt;em&gt;s&lt;/em&gt;.</source>
          <target state="translated">这仅检查az，AZ，0-9 ASCII字符。返回true如果在所有字符&lt;em&gt;小号&lt;/em&gt;是alpanumeric并且至少有一个字符的&lt;em&gt;小号&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="fcb243522dd9085ea31f048f6623532706ee946c" translate="yes" xml:space="preserve">
          <source>This code demonstrates how you can iterate over all the tags in an HTML file and write back the modified version. In this case we look for hyperlinks ending with the extension &lt;code&gt;.rst&lt;/code&gt; and convert them to &lt;code&gt;.html&lt;/code&gt;.</source>
          <target state="translated">此代码演示了如何遍历HTML文件中的所有标记并写回修改后的版本。在这种情况下，我们将查找扩展名为 &lt;code&gt;.rst&lt;/code&gt; 的超链接，并将其转换为 &lt;code&gt;.html&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="67e26f346f2ccd3c86198d382ef1609a459caeec" translate="yes" xml:space="preserve">
          <source>This code has a shortcoming: if &lt;code&gt;debug&lt;/code&gt; is set to false someday, the quite expensive &lt;code&gt;$&lt;/code&gt; and &lt;code&gt;&amp;amp;&lt;/code&gt; operations are still performed! (The argument evaluation for procedures is &lt;em&gt;eager&lt;/em&gt;).</source>
          <target state="translated">此代码有一个缺点：如果某天将 &lt;code&gt;debug&lt;/code&gt; 设置为false，则仍然会执行相当昂贵的 &lt;code&gt;$&lt;/code&gt; 和 &lt;code&gt;&amp;amp;&lt;/code&gt; 操作！（过程的论证评估很&lt;em&gt;热切&lt;/em&gt;）。</target>
        </trans-unit>
        <trans-unit id="ddf8456d90256ef6813274665679598a51d6b207" translate="yes" xml:space="preserve">
          <source>This complements &lt;a href=&quot;#escape&quot;&gt;escape&lt;/a&gt; as it performs the opposite operations.</source>
          <target state="translated">这补充了&lt;a href=&quot;#escape&quot;&gt;逃逸，&lt;/a&gt;因为它执行相反的操作。</target>
        </trans-unit>
        <trans-unit id="448d34e4eec8002bcc63da9cb6384f1b398a912a" translate="yes" xml:space="preserve">
          <source>This complements &lt;a href=&quot;#escape,string,string,string&quot;&gt;escape proc&lt;/a&gt; as it performs the opposite operations.</source>
          <target state="translated">这补充了&lt;a href=&quot;#escape,string,string,string&quot;&gt;转义过程，&lt;/a&gt;因为它执行相反的操作。</target>
        </trans-unit>
        <trans-unit id="eb30b5d51da059f03be346551003a62694c6e6c0" translate="yes" xml:space="preserve">
          <source>This condition holds:</source>
          <target state="translated">这个条件成立。</target>
        </trans-unit>
        <trans-unit id="81ebbfabdc2c9ddc216dc2043c4b3f433dfa4f83" translate="yes" xml:space="preserve">
          <source>This constant is used to determine whether the destination platform is fully supported by &lt;code&gt;ioselectors&lt;/code&gt; module.</source>
          <target state="translated">该常数用于确定 &lt;code&gt;ioselectors&lt;/code&gt; 模块是否完全支持目标平台。</target>
        </trans-unit>
        <trans-unit id="ec88b8f870dd5f6a3d62cb955fdcb976315090ca" translate="yes" xml:space="preserve">
          <source>This convenience proc parses any input string using rst markup (it doesn't have to be a full document!) and returns an embeddable piece of HTML. The proc is meant to be used in &lt;em&gt;online&lt;/em&gt; environments without access to a meaningful filesystem, and therefore rst &lt;code&gt;include&lt;/code&gt; like directives won't work. For an explanation of the &lt;code&gt;config&lt;/code&gt; parameter see the &lt;code&gt;initRstGenerator&lt;/code&gt; proc. Example:</source>
          <target state="translated">此便利过程使用rst标记解析任何输入字符串（不必是完整的文档！），并返回可嵌入的HTML。该proc旨在用于&lt;em&gt;在线&lt;/em&gt;环境中，而无需访问有意义的文件系统，因此，第一个 &lt;code&gt;include&lt;/code&gt; like指令将不起作用。有关 &lt;code&gt;config&lt;/code&gt; 参数的说明，请参见 &lt;code&gt;initRstGenerator&lt;/code&gt; proc。例：</target>
        </trans-unit>
        <trans-unit id="4f4da908d1b690f8e981e01fff23cd3d08db0df4" translate="yes" xml:space="preserve">
          <source>This creates a new &lt;a href=&quot;#OptParser&quot;&gt;OptParser&lt;/a&gt;. If no command line arguments are provided, the real command line as provided by the &lt;code&gt;os&lt;/code&gt; module is retrieved instead.</source>
          <target state="translated">这将创建一个新的&lt;a href=&quot;#OptParser&quot;&gt;OptParser&lt;/a&gt;。如果未提供命令行参数，则将检索 &lt;code&gt;os&lt;/code&gt; 模块提供的实际命令行。</target>
        </trans-unit>
        <trans-unit id="bf9772d9f40d4b88270d7bfcc87701c67c1f206a" translate="yes" xml:space="preserve">
          <source>This directive tells c2nim that it should annotate every proc that resulted from a C function prototype with the &lt;code&gt;dynlib&lt;/code&gt; pragma:</source>
          <target state="translated">该指令告诉c2nim，它应该标注每一个进程内起因于C函数原型与 &lt;code&gt;dynlib&lt;/code&gt; 编译：</target>
        </trans-unit>
        <trans-unit id="4603ae97d0bef34ab983059dfa901c4651d6c5d6" translate="yes" xml:space="preserve">
          <source>This document aims to be a precise specification about how move semantics and destructors work in Nim.</source>
          <target state="translated">本文档旨在精确规范Nim中的移动语义和析构器的工作方式。</target>
        </trans-unit>
        <trans-unit id="dc11ca4313f42aaa8eb535d6e6150b0aedbf3be6" translate="yes" xml:space="preserve">
          <source>This document describes Nim's standard library.</source>
          <target state="translated">本文档介绍了Nim的标准库。</target>
        </trans-unit>
        <trans-unit id="344be4f4ba38b24d4eb5d528848beeb4bd8811eb" translate="yes" xml:space="preserve">
          <source>This document describes features of Nim that are to be considered experimental. Some of these are not covered by the &lt;code&gt;.experimental&lt;/code&gt; pragma or &lt;code&gt;--experimental&lt;/code&gt; switch because they are already behind a special syntax and one may want to use Nim libraries using these features without using them oneself.</source>
          <target state="translated">本文档介绍了Nim的功能，这些功能应视为实验性功能。其中一些没有被 &lt;code&gt;.experimental&lt;/code&gt; pragma或 &lt;code&gt;--experimental&lt;/code&gt; 开关覆盖，因为它们已经在一种特殊语法的后面，并且人们可能想使用具有这些功能的Nim库而不自己使用它们。</target>
        </trans-unit>
        <trans-unit id="501826eded96f905ab59473404c85f59f07e601c" translate="yes" xml:space="preserve">
          <source>This document describes how the GC works and how to tune it for (soft) &lt;span id=&quot;realtime-systems_1&quot;&gt;realtime systems&lt;/span&gt;.</source>
          <target state="translated">本文档介绍了GC的工作方式以及如何针对（软）&lt;span id=&quot;realtime-systems_1&quot;&gt;实时系统&lt;/span&gt;对其进行调整。</target>
        </trans-unit>
        <trans-unit id="82487ee5532813ed5f7833504e199d69e4451b0b" translate="yes" xml:space="preserve">
          <source>This document describes how the multi-paradigm memory management strategies work. How to tune the garbage collectors for your needs, like (soft) &lt;span id=&quot;realtime-systems_1&quot;&gt;realtime systems&lt;/span&gt;, and how the memory management strategies that are not garbage collectors work.</source>
          <target state="translated">本文档介绍了多范式内存管理策略的工作方式。如何调整垃圾收集器以满足您的需求（例如（软）&lt;span id=&quot;realtime-systems_1&quot;&gt;实时系统）&lt;/span&gt;，以及不是垃圾收集器的内存管理策略如何工作。</target>
        </trans-unit>
        <trans-unit id="a1436145ee6291786c4efda6509df54038a00ce9" translate="yes" xml:space="preserve">
          <source>This document describes the &lt;span id=&quot;documentation-generation-tools_1&quot;&gt;documentation generation tools&lt;/span&gt; built into the &lt;a href=&quot;nimc&quot;&gt;Nim compiler&lt;/a&gt;, which can generate HTML and JSON output from input .nim files and projects, as well as HTML and LaTeX from input RST (reStructuredText) files. The output documentation will include module dependencies (&lt;code&gt;import&lt;/code&gt;), any top-level documentation comments (##), and exported symbols (*), including procedures, types, and variables.</source>
          <target state="translated">本文档介绍了&lt;a href=&quot;nimc&quot;&gt;Nim编译器中&lt;/a&gt;内置的&lt;span id=&quot;documentation-generation-tools_1&quot;&gt;文档生成工具&lt;/span&gt;，该&lt;span id=&quot;documentation-generation-tools_1&quot;&gt;工具&lt;/span&gt;可以从输入.nim文件和项目生成HTML和JSON输出，以及从输入RST（reStructuredText）文件生成HTML和LaTeX。输出文档将包括模块依赖项（ &lt;code&gt;import&lt;/code&gt; ），任何顶级文档注释（##）和导出的符号（*），包括过程，类型和变量。</target>
        </trans-unit>
        <trans-unit id="876d6f96c63ad0dcba59ff24b243aebd3e783be3" translate="yes" xml:space="preserve">
          <source>This document describes the lexis, the syntax, and the semantics of Nim.</source>
          <target state="translated">本文档描述了Nim的词法、语法和语义。</target>
        </trans-unit>
        <trans-unit id="052a5aaf43125762195ce8979a78fa337c691660" translate="yes" xml:space="preserve">
          <source>This document describes the lexis, the syntax, and the semantics of the Nim language.</source>
          <target state="translated">本文档描述了Nim语言的词法、语法和语义。</target>
        </trans-unit>
        <trans-unit id="601f8c6b34793396897c345b490ce1360453f6a5" translate="yes" xml:space="preserve">
          <source>This document describes the upcoming Nim runtime which does not use classical GC algorithms anymore but is based on destructors and move semantics. The new runtime's advantages are that Nim programs become oblivious to the involved heap sizes and programs are easier to write to make effective use of multi-core machines. As a nice bonus, files and sockets and the like will not require manual &lt;code&gt;close&lt;/code&gt; calls anymore.</source>
          <target state="translated">本文档描述了即将到来的Nim运行时，该运行时不再使用经典的GC算法，而是基于析构函数和移动语义。新的运行时的优点是Nim程序不必考虑所涉及的堆大小，并且程序更易于编写以有效利用多核计算机。很好的好处是，文件和套接字等不再需要手动 &lt;code&gt;close&lt;/code&gt; 调用。</target>
        </trans-unit>
        <trans-unit id="beb13f15afd5992eb20356ca76c23dc066a055b6" translate="yes" xml:space="preserve">
          <source>This document describes the usage of the &lt;em&gt;Nim compiler&lt;/em&gt; on the different supported platforms. It is not a definition of the Nim programming language (therefore is the &lt;a href=&quot;manual&quot;&gt;manual&lt;/a&gt;).</source>
          <target state="translated">本文档介绍了&lt;em&gt;Nim编译器&lt;/em&gt;在不同支持平台上的用法。它不是Nim编程语言的定义（因此是&lt;a href=&quot;manual&quot;&gt;手册&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="ee46bbf1bf7e5279f84d46353ef02a9266df1275" translate="yes" xml:space="preserve">
          <source>This document describes the usage of the &lt;em&gt;Nim compiler&lt;/em&gt; on the different supported platforms. It is not a definition of the Nim programming language (which is covered in the &lt;a href=&quot;manual&quot;&gt;manual&lt;/a&gt;).</source>
          <target state="translated">本文档介绍了&lt;em&gt;Nim编译器&lt;/em&gt;在不同支持平台上的用法。它不是Nim编程语言的定义（本&lt;a href=&quot;manual&quot;&gt;手册中&lt;/a&gt;介绍了该语言）。</target>
        </trans-unit>
        <trans-unit id="3cb274ef505ac7161b2d0c10daf0e239378a408c" translate="yes" xml:space="preserve">
          <source>This document is a tutorial for the advanced constructs of the &lt;em&gt;Nim&lt;/em&gt; programming language. &lt;strong&gt;Note that this document is somewhat obsolete as the&lt;/strong&gt;&lt;a href=&quot;manual&quot;&gt;manual&lt;/a&gt;&lt;strong&gt;contains many more examples of the advanced language features.&lt;/strong&gt;</source>
          <target state="translated">本文档是有关&lt;em&gt;Nim&lt;/em&gt;编程语言的高级构造的教程。&lt;strong&gt;请注意，该文档已过时，因为该&lt;/strong&gt;&lt;a href=&quot;manual&quot;&gt;手册&lt;/a&gt;&lt;strong&gt;包含了更多高级语言功能的示例。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="51cc327eea029a9a74f8f2656806b1a3582d4c70" translate="yes" xml:space="preserve">
          <source>This document is a tutorial for the programming language &lt;em&gt;Nim&lt;/em&gt;. This tutorial assumes that you are familiar with basic programming concepts like variables, types or statements but is kept very basic. The &lt;a href=&quot;manual&quot;&gt;manual&lt;/a&gt; contains many more examples of the advanced language features. All code examples in this tutorial, as well as the ones found in the rest of Nim's documentation, follow the &lt;a href=&quot;nep1&quot;&gt;Nim style guide&lt;/a&gt;.</source>
          <target state="translated">本文档是&lt;em&gt;Nim&lt;/em&gt;编程语言的教程。本教程假定您熟悉基本的编程概念，例如变量，类型或语句，但始终保持非常基础。该&lt;a href=&quot;manual&quot;&gt;手册&lt;/a&gt;包含更多高级语言功能的示例。本教程中的所有代码示例以及Nim其余文档中提供的示例均遵循&lt;a href=&quot;nep1&quot;&gt;Nim样式指南&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="dc36e0a51521723c2d17399937c4b8017c6cb9b6" translate="yes" xml:space="preserve">
          <source>This document will guide you through the available options. If you want to look at practical examples of idetools support you can look at the test files found in the &lt;a href=&quot;#test-suite&quot;&gt;Test suite&lt;/a&gt; or &lt;a href=&quot;https://github.com/Araq/Nim/wiki/Editor-Support&quot;&gt;various editor integrations&lt;/a&gt; already available.</source>
          <target state="translated">本文档将指导您完成可用的选项。如果要查看idetools支持的实际示例，可以查看在&lt;a href=&quot;#test-suite&quot;&gt;测试套件中&lt;/a&gt;找到的测试文件或&lt;a href=&quot;https://github.com/Araq/Nim/wiki/Editor-Support&quot;&gt;各种&lt;/a&gt;可用的编辑器集成。</target>
        </trans-unit>
        <trans-unit id="b50c7c6fe53ac393a7c7fac0b0acdac2132c3be2" translate="yes" xml:space="preserve">
          <source>This document will guide you through the available options. If you want to look at practical examples of nimsuggest support you can look at the &lt;a href=&quot;https://github.com/Araq/Nim/wiki/Editor-Support&quot;&gt;various editor integrations&lt;/a&gt; already available.</source>
          <target state="translated">本文档将指导您完成可用的选项。如果您想查看最灵活的支持的实际示例，可以查看已经可用的&lt;a href=&quot;https://github.com/Araq/Nim/wiki/Editor-Support&quot;&gt;各种编辑器集成&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a42362fd0fdb024567fc8917a8d4c8e5c41a8857" translate="yes" xml:space="preserve">
          <source>This doesn't do anything if &lt;code&gt;key&lt;/code&gt; is already in &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;key&lt;/code&gt; 已经在 &lt;code&gt;s&lt;/code&gt; 中,则不会执行任何操作。</target>
        </trans-unit>
        <trans-unit id="20177f379121698f488e5c0b5ae0c546e34cb464" translate="yes" xml:space="preserve">
          <source>This doesn't do anything if &lt;code&gt;key&lt;/code&gt; is not found in &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">如果在 &lt;code&gt;s&lt;/code&gt; 中找不到 &lt;code&gt;key&lt;/code&gt; 则此操作不会执行任何操作。</target>
        </trans-unit>
        <trans-unit id="9463da66a61d4818bd3012c1d824f16d76b55047" translate="yes" xml:space="preserve">
          <source>This doesn't do anything if &lt;em&gt;key&lt;/em&gt; is already in &lt;em&gt;s&lt;/em&gt;. Example:</source>
          <target state="translated">如果&lt;em&gt;key&lt;/em&gt;已经在&lt;em&gt;s中，&lt;/em&gt;则不会执行任何操作。例：</target>
        </trans-unit>
        <trans-unit id="2d74bf1bd66d315281b8b850d55664417bfed9ea" translate="yes" xml:space="preserve">
          <source>This doesn't do anything if &lt;em&gt;key&lt;/em&gt; is not found in &lt;em&gt;s&lt;/em&gt;. Example:</source>
          <target state="translated">如果在&lt;em&gt;s中&lt;/em&gt;找不到&lt;em&gt;密钥，&lt;/em&gt;则此操作不会执行任何操作。例：&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="04208e500a8d87248355c319f0fd4502fe85e0e8" translate="yes" xml:space="preserve">
          <source>This example demonstrates the usage of the W3 HTML Validator, it uses &lt;code&gt;multipart/form-data&lt;/code&gt; as the &lt;code&gt;Content-Type&lt;/code&gt; to send the HTML to be validated to the server.</source>
          <target state="translated">此示例演示了W3 HTML验证程序的用法，它使用 &lt;code&gt;multipart/form-data&lt;/code&gt; 作为 &lt;code&gt;Content-Type&lt;/code&gt; 将要验证的HTML发送到服务器。</target>
        </trans-unit>
        <trans-unit id="dfa1b9eabc9505799b820ee46f8953f4c8f974ac" translate="yes" xml:space="preserve">
          <source>This example shows a procedure named &lt;code&gt;yes&lt;/code&gt; that asks the user a &lt;code&gt;question&lt;/code&gt; and returns true if they answered &quot;yes&quot; (or something similar) and returns false if they answered &quot;no&quot; (or something similar). A &lt;code&gt;return&lt;/code&gt; statement leaves the procedure (and therefore the while loop) immediately. The &lt;code&gt;(question: string): bool&lt;/code&gt; syntax describes that the procedure expects a parameter named &lt;code&gt;question&lt;/code&gt; of type &lt;code&gt;string&lt;/code&gt; and returns a value of type &lt;code&gt;bool&lt;/code&gt;. The &lt;code&gt;bool&lt;/code&gt; type is built-in: the only valid values for &lt;code&gt;bool&lt;/code&gt; are &lt;code&gt;true&lt;/code&gt; and &lt;code&gt;false&lt;/code&gt;. The conditions in if or while statements must be of type &lt;code&gt;bool&lt;/code&gt;.</source>
          <target state="translated">此示例显示了一个名为 &lt;code&gt;yes&lt;/code&gt; 的过程，该过程询问用户一个 &lt;code&gt;question&lt;/code&gt; ，如果用户回答&amp;ldquo;是&amp;rdquo;（或类似的结果），则返回true；如果用户回答&amp;ldquo;否&amp;rdquo;（或类似的结果），则返回false。一个 &lt;code&gt;return&lt;/code&gt; 语句立即离开的过程（并因此while循环）。的 &lt;code&gt;(question: string): bool&lt;/code&gt; 语法描述了该过程需要一个命名参数 &lt;code&gt;question&lt;/code&gt; 类型的 &lt;code&gt;string&lt;/code&gt; 并返回类型的值 &lt;code&gt;bool&lt;/code&gt; 。在 &lt;code&gt;bool&lt;/code&gt; 类型内置：为唯一有效值 &lt;code&gt;bool&lt;/code&gt; 是 &lt;code&gt;true&lt;/code&gt; 和 &lt;code&gt;false&lt;/code&gt; 。if或while语句中的条件必须为 &lt;code&gt;bool&lt;/code&gt; 类型。</target>
        </trans-unit>
        <trans-unit id="419751183c50edae04b9814dec67dc7101cf22a4" translate="yes" xml:space="preserve">
          <source>This example uses HTTP GET to retrieve &lt;code&gt;http://google.com&lt;/code&gt;:</source>
          <target state="translated">本示例使用HTTP GET检索 &lt;code&gt;http://google.com&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="c530469f8ff4d36d8c0d58dcb3d2f3b70e61c1b6" translate="yes" xml:space="preserve">
          <source>This example will create an HTTP server on port 8080. The server will respond to all requests with a &lt;code&gt;200 OK&lt;/code&gt; response code and &quot;Hello World&quot; as the response body.</source>
          <target state="translated">本示例将在端口8080上创建一个HTTP服务器。该服务器将使用 &lt;code&gt;200 OK&lt;/code&gt; 响应代码和&amp;ldquo; Hello World&amp;rdquo;作为响应正文来响应所有请求。</target>
        </trans-unit>
        <trans-unit id="82f9bd61449ea276e7ba79a6b51086b4f68f04d2" translate="yes" xml:space="preserve">
          <source>This exception is raised when a string parameter contains an illegal character</source>
          <target state="translated">当一个字符串参数中包含一个非法字符时,就会引发这个异常。</target>
        </trans-unit>
        <trans-unit id="49884cc4168ac3b56e2f36bd32448ca533036aba" translate="yes" xml:space="preserve">
          <source>This feature is still under development. In the future it will allow an IDE to evaluate an expression in the context of the currently running/debugged user project.</source>
          <target state="translated">这个功能仍在开发中。在未来,它将允许IDE在当前运行/调试的用户项目的上下文中评估一个表达式。</target>
        </trans-unit>
        <trans-unit id="718ecf2ca622cda3af52f68c05ddd3883f87e430" translate="yes" xml:space="preserve">
          <source>This file implements features required for IDE support.</source>
          <target state="translated">这个文件实现了IDE支持所需的功能。</target>
        </trans-unit>
        <trans-unit id="ef6fc55e019f2e067eb3af4f08888a5e5eab4d20" translate="yes" xml:space="preserve">
          <source>This file implements the new evaluation engine for Nim code. An instruction is 1-3 int32s in memory, it is a register based VM.</source>
          <target state="translated">这个文件实现了Nim代码的新评估引擎。一条指令在内存中是1-3条int32,它是一个基于寄存器的虚拟机。</target>
        </trans-unit>
        <trans-unit id="baae068151a80870f517a9c80fabe195a66afe5b" translate="yes" xml:space="preserve">
          <source>This function checks for events on all the delegates in the &lt;em&gt;PDispatcher&lt;/em&gt;. It then proceeds to call the correct event handler.</source>
          <target state="translated">此函数检查&lt;em&gt;PDispatcher中&lt;/em&gt;所有委托上的&lt;em&gt;事件&lt;/em&gt;。然后，它将继续调用正确的事件处理程序。</target>
        </trans-unit>
        <trans-unit id="ef0b456d31d45682c8880248481ad8c2632bf2f5" translate="yes" xml:space="preserve">
          <source>This function is NOT reliable. Floating point numbers cannot hold non integer decimals precisely. If &lt;code&gt;places&lt;/code&gt; is 0 (or omitted), round to the nearest integral value following normal mathematical rounding rules (e.g. &lt;code&gt;round(54.5) -&amp;gt; 55.0&lt;/code&gt;). If &lt;code&gt;places&lt;/code&gt; is greater than 0, round to the given number of decimal places, e.g. &lt;code&gt;round(54.346, 2) -&amp;gt; 54.350000000000001421&amp;hellip;&lt;/code&gt;. If &lt;code&gt;places&lt;/code&gt; is negative, round to the left of the decimal place, e.g. &lt;code&gt;round(537.345, -1) -&amp;gt; 540.0&lt;/code&gt;</source>
          <target state="translated">此功能不可靠。浮点数不能精确地包含非整数小数。如果 &lt;code&gt;places&lt;/code&gt; 为0（或省略），则遵循正常的数学舍入规则将舍入到最接近的整数值（例如， &lt;code&gt;round(54.5) -&amp;gt; 55.0&lt;/code&gt; ）。如果 &lt;code&gt;places&lt;/code&gt; 大于0，则舍入到给定的小数位数，例如 &lt;code&gt;round(54.346, 2) -&amp;gt; 54.350000000000001421&amp;hellip;&lt;/code&gt; 。如果 &lt;code&gt;places&lt;/code&gt; 为负，则四舍五入到小数点左边，例如， &lt;code&gt;round(537.345, -1) -&amp;gt; 540.0&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0c4a4220996badd8db70594d8b36b935a69870fd" translate="yes" xml:space="preserve">
          <source>This function is available only when &lt;code&gt;--threads:on&lt;/code&gt; and &lt;code&gt;--tlsEmulation:off&lt;/code&gt; switches are used</source>
          <target state="translated">仅当使用 &lt;code&gt;--threads:on&lt;/code&gt; 和 &lt;code&gt;--tlsEmulation:off&lt;/code&gt; 开关时，此功能才可用</target>
        </trans-unit>
        <trans-unit id="4390f3f69d4871fa4d3972e4b499717ab1b670b2" translate="yes" xml:space="preserve">
          <source>This function is not implemented on all platform, test for availability with &lt;code&gt;declared() &amp;lt;system.html#declared,untyped&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">并非在所有平台上都实现此功能，请使用 &lt;code&gt;declared() &amp;lt;system.html#declared,untyped&amp;gt;&lt;/code&gt; 测试可用性。</target>
        </trans-unit>
        <trans-unit id="c640f2d135e1c682951e71cb417036f1e1dabc6c" translate="yes" xml:space="preserve">
          <source>This function returns &lt;code&gt;True&lt;/code&gt; if there are file descriptors that are still open, otherwise &lt;code&gt;False&lt;/code&gt;. File descriptors that have been closed are immediately removed from the dispatcher automatically.</source>
          <target state="translated">如果仍有文件描述符处于打开状态，则此函数返回 &lt;code&gt;True&lt;/code&gt; ，否则返回 &lt;code&gt;False&lt;/code&gt; 。已关闭的文件描述符会立即自动从调度程序中删除。</target>
        </trans-unit>
        <trans-unit id="80da17632a4719e714bb180d2505b06fb4c81b21" translate="yes" xml:space="preserve">
          <source>This function will lookup the IP address of a hostname.</source>
          <target state="translated">该功能将查询一个主机名的IP地址。</target>
        </trans-unit>
        <trans-unit id="888f45de89db87248b6c42a8441e4fc3f923719d" translate="yes" xml:space="preserve">
          <source>This function will lookup the hostname of an IP Address.</source>
          <target state="translated">该功能将查询一个IP地址的主机名。</target>
        </trans-unit>
        <trans-unit id="9ba85512a6c5538eb44a83be7203148f1393be22" translate="yes" xml:space="preserve">
          <source>This function will raise an EOS exception when a socket error occurs.</source>
          <target state="translated">当发生套接字错误时,该函数将引发一个EOS异常。</target>
        </trans-unit>
        <trans-unit id="83d0d0f248054169b861c6becec14e8bc119b1fc" translate="yes" xml:space="preserve">
          <source>This function will remove the data that was returned from the underlying &lt;code&gt;FutureStream&lt;/code&gt;.</source>
          <target state="translated">此函数将删除从基础 &lt;code&gt;FutureStream&lt;/code&gt; 返回的数据。</target>
        </trans-unit>
        <trans-unit id="48be562c3c3e831dca5c27c76a3332e0fe473cb4" translate="yes" xml:space="preserve">
          <source>This function will throw an EOS exception when an error occurs.</source>
          <target state="translated">当发生错误时,该函数将抛出一个EOS异常。</target>
        </trans-unit>
        <trans-unit id="0d0f4a3f3c929a542ada2a33db6e38abd1059abb" translate="yes" xml:space="preserve">
          <source>This function will throw an EOS exception when an error occurs. A value lower than 0 is never returned.</source>
          <target state="translated">当发生错误时,该函数将抛出一个EOS异常。小于0的值不会返回。</target>
        </trans-unit>
        <trans-unit id="5d8f3e9799faf34cc137a492d6f553e08eafcb4b" translate="yes" xml:space="preserve">
          <source>This function will throw an OSError exception when an error occurs.</source>
          <target state="translated">当发生错误时,该函数将抛出一个OSError异常。</target>
        </trans-unit>
        <trans-unit id="125d21a7a8629f951aed2b4a51171c5e5038ef0b" translate="yes" xml:space="preserve">
          <source>This function will throw an OSError exception when an error occurs. A value lower than 0 is never returned.</source>
          <target state="translated">当发生错误时,该函数将抛出一个OSError异常。小于0的值不会返回。</target>
        </trans-unit>
        <trans-unit id="dc4ca2ac4f720e72b5b82cc411b68835f82a7af2" translate="yes" xml:space="preserve">
          <source>This happens for calculations whose results are too large to fit in the provided bits.</source>
          <target state="translated">这种情况会发生在计算结果太大而无法容纳在所提供的位上的情况下。</target>
        </trans-unit>
        <trans-unit id="f7d396147bbaee5b1e555360e29d6e7950ec2165" translate="yes" xml:space="preserve">
          <source>This has NOT yet been (extensively) tested against ODBC drivers for Teradata, Oracle, Sybase, MSSqlvSvr, et. al. databases.</source>
          <target state="translated">这还没有针对Teradata、Oracle、Sybase、MSSqlvSvr等数据库的ODBC驱动进行(广泛)测试。</target>
        </trans-unit>
        <trans-unit id="0cd633329a7f1f5e683279f4817767b6e858402b" translate="yes" xml:space="preserve">
          <source>This has further consequences:</source>
          <target state="translated">这就产生了进一步的后果。</target>
        </trans-unit>
        <trans-unit id="a80811f797327311abf9b8bb44734abd6ccfea15" translate="yes" xml:space="preserve">
          <source>This implementation calls &lt;code&gt;math.randomize()&lt;/code&gt; for the first call of &lt;code&gt;genOid&lt;/code&gt;.</source>
          <target state="translated">此实现为 &lt;code&gt;genOid&lt;/code&gt; 的首次调用调用 &lt;code&gt;math.randomize()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d16330d38656e17d5127ab390f1fa9fa82609de7" translate="yes" xml:space="preserve">
          <source>This is &lt;a href=&quot;#getAppFilename&quot;&gt;getAppFilename()&lt;/a&gt; at compile time.</source>
          <target state="translated">这是在编译时的&lt;a href=&quot;#getAppFilename&quot;&gt;getAppFilename（）&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e59b97830c5bd0f5ff50a358d8f4e2f7574886e8" translate="yes" xml:space="preserve">
          <source>This is &lt;strong&gt;unsafe&lt;/strong&gt; as it allocates an object of the passed &lt;code&gt;size&lt;/code&gt;. This should only be used for optimization purposes when you know what you're doing!</source>
          <target state="translated">这是&lt;strong&gt;不安全的，&lt;/strong&gt;因为它分配了传递 &lt;code&gt;size&lt;/code&gt; 的对象。仅当您知道自己在做什么时，才可以将其用于优化目的！</target>
        </trans-unit>
        <trans-unit id="cb1152982ee72cd4dc2acc598e6a1878a3cb306d" translate="yes" xml:space="preserve">
          <source>This is a lower level proc and not something that you typically would need to call when using this module. One exception to this is if you are implementing any &lt;a href=&quot;https://en.wikipedia.org/wiki/Extended_SMTP&quot;&gt;SMTP extensions&lt;/a&gt;.</source>
          <target state="translated">这是一个较低级别的过程，而不是使用此模块时通常需要调用的过程。一个例外是，如果您要实现任何&lt;a href=&quot;https://en.wikipedia.org/wiki/Extended_SMTP&quot;&gt;SMTP扩展&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="291d5e1a5495802c3c84e77e045ae2f53bfb5167" translate="yes" xml:space="preserve">
          <source>This is a part of &lt;code&gt;system.nim&lt;/code&gt;, you should not manually import it.</source>
          <target state="translated">这是 &lt;code&gt;system.nim&lt;/code&gt; 的一部分，您不应该手动导入它。</target>
        </trans-unit>
        <trans-unit id="b58c523ddb24f9724b2d75ac0236939620e83491" translate="yes" xml:space="preserve">
          <source>This is a raw POSIX interface module. It does not not provide any convenience: cstrings are used instead of proper Nim strings and return codes indicate errors. If you want exceptions and a proper Nim-like interface, use the OS module or write a wrapper.</source>
          <target state="translated">这是一个原始的POSIX接口模块,它并没有提供任何便利:使用cstrings代替正确的Nim字符串,并且返回代码表示错误。它并没有提供任何便利性:用cstrings代替正确的Nim字符串,并且返回代码表示错误。如果你想得到异常和类似Nim的接口,请使用OS模块或写一个包装器。</target>
        </trans-unit>
        <trans-unit id="0e187a8e9e9b4d53c523d572ffaa0449d8fd615b" translate="yes" xml:space="preserve">
          <source>This is a simple syntactic transformation into:</source>
          <target state="translated">这是一个简单的句法转换为。</target>
        </trans-unit>
        <trans-unit id="baffe5aa2ca431a951c22f6627b3195c4e8e9257" translate="yes" xml:space="preserve">
          <source>This is a wrapper proc around &lt;a href=&quot;#copyFile&quot;&gt;copyFile()&lt;/a&gt;, &lt;a href=&quot;#getFilePermissions&quot;&gt;getFilePermissions()&lt;/a&gt; and &lt;a href=&quot;#setFilePermissions&quot;&gt;setFilePermissions()&lt;/a&gt; on non Windows platform. On Windows this proc is just a wrapper for &lt;a href=&quot;#copyFile&quot;&gt;copyFile()&lt;/a&gt; since that proc already copies attributes.</source>
          <target state="translated">这是在非Windows平台上围绕&lt;a href=&quot;#copyFile&quot;&gt;copyFile（）&lt;/a&gt;，&lt;a href=&quot;#getFilePermissions&quot;&gt;getFilePermissions（）&lt;/a&gt;和&lt;a href=&quot;#setFilePermissions&quot;&gt;setFilePermissions（）&lt;/a&gt;的包装过程。在Windows上，此proc只是&lt;a href=&quot;#copyFile&quot;&gt;copyFile（）&lt;/a&gt;的包装，因为该proc已经复制了属性。</target>
        </trans-unit>
        <trans-unit id="e7889b59af2f2b66c7a5250872376894c99e6798" translate="yes" xml:space="preserve">
          <source>This is a wrapper proc around &lt;a href=&quot;#copyFile,string,string&quot;&gt;copyFile&lt;/a&gt;, &lt;a href=&quot;#getFilePermissions,string&quot;&gt;getFilePermissions&lt;/a&gt; and &lt;a href=&quot;#setFilePermissions,string,set%5BFilePermission%5D&quot;&gt;setFilePermissions&lt;/a&gt; procs on non-Windows platforms.</source>
          <target state="translated">这是在非Windows平台上围绕&lt;a href=&quot;#copyFile,string,string&quot;&gt;copyFile&lt;/a&gt;，&lt;a href=&quot;#getFilePermissions,string&quot;&gt;getFilePermissions&lt;/a&gt;和&lt;a href=&quot;#setFilePermissions,string,set%5BFilePermission%5D&quot;&gt;setFilePermissions&lt;/a&gt; proc的包装过程。</target>
        </trans-unit>
        <trans-unit id="3a603ff59d56a2ac3e9b3c36a052ac4a5c2114b5" translate="yes" xml:space="preserve">
          <source>This is all single threaded, fully non-blocking and does give you a lot of control. In theory you should be able to work with any of these layers interchangeably (as long as you only care about non-Windows platforms).</source>
          <target state="translated">这都是单线程的,完全非阻塞的,而且确实给了你很多控制权。理论上,你应该可以和这些层中的任何一层互换工作(只要你只关心非Windows平台)。</target>
        </trans-unit>
        <trans-unit id="106552ab99d75903f8f7507280b5c7f154edc971" translate="yes" xml:space="preserve">
          <source>This is also used by the code generator for the implementation of &lt;code&gt;spawn&lt;/code&gt;.</source>
          <target state="translated">代码生成器还将其用于 &lt;code&gt;spawn&lt;/code&gt; 的实现。</target>
        </trans-unit>
        <trans-unit id="2cad2e5f3a65e247d00d9f14abfba38cdd1e9778" translate="yes" xml:space="preserve">
          <source>This is an &lt;code&gt;O(1)&lt;/code&gt; operation.</source>
          <target state="translated">这是一个 &lt;code&gt;O(1)&lt;/code&gt; 操作。</target>
        </trans-unit>
        <trans-unit id="edfd16ee323a671ecdfb12c816b6de91a9a9a32f" translate="yes" xml:space="preserve">
          <source>This is an &lt;code&gt;O(n)&lt;/code&gt; operation.</source>
          <target state="translated">这是一个 &lt;code&gt;O(n)&lt;/code&gt; 操作。</target>
        </trans-unit>
        <trans-unit id="eb775bab32177650720f4b9d9b75ca0579c501f6" translate="yes" xml:space="preserve">
          <source>This is an alias for &lt;a href=&quot;#staticExec&quot;&gt;staticExec&lt;/a&gt;.</source>
          <target state="translated">这是&lt;a href=&quot;#staticExec&quot;&gt;staticExec&lt;/a&gt;的别名。</target>
        </trans-unit>
        <trans-unit id="cac9bcfc62c9f2dfc091188b39f1cd9d2776d953" translate="yes" xml:space="preserve">
          <source>This is an alias for &lt;a href=&quot;#staticExec,string,string,string&quot;&gt;staticExec&lt;/a&gt;.</source>
          <target state="translated">这是&lt;a href=&quot;#staticExec,string,string,string&quot;&gt;staticExec&lt;/a&gt;的别名。</target>
        </trans-unit>
        <trans-unit id="f14a0c9a9b72673d11d5220860a7e2d032297599" translate="yes" xml:space="preserve">
          <source>This is an alias for &lt;a href=&quot;#staticRead&quot;&gt;staticRead&lt;/a&gt;.</source>
          <target state="translated">这是&lt;a href=&quot;#staticRead&quot;&gt;staticRead&lt;/a&gt;的别名。</target>
        </trans-unit>
        <trans-unit id="f27f252061898e3dc51b007922c3601c40f37b56" translate="yes" xml:space="preserve">
          <source>This is an alias for &lt;a href=&quot;#staticRead,string&quot;&gt;staticRead&lt;/a&gt;.</source>
          <target state="translated">这是&lt;a href=&quot;#staticRead,string&quot;&gt;staticRead&lt;/a&gt;的别名。</target>
        </trans-unit>
        <trans-unit id="597d82c31bdafce1e17f3e095745fae4aa8f063d" translate="yes" xml:space="preserve">
          <source>This is an alias for &lt;code&gt;uint8&lt;/code&gt;, that is an unsigned integer, 8 bits wide.</source>
          <target state="translated">这是 &lt;code&gt;uint8&lt;/code&gt; 的别名，它是8位宽的无符号整数。</target>
        </trans-unit>
        <trans-unit id="e39548494ffeefbdea437a44fba01f90cd710d14" translate="yes" xml:space="preserve">
          <source>This is an convenience iterator for iterating over command line arguments. This creates a new OptParser. See the above &lt;code&gt;getopt(var OptParser)&lt;/code&gt; example for using default empty &lt;code&gt;NoVal&lt;/code&gt; parameters. This example is for the same option keys as that example but here option key-value separators become optional for command users:</source>
          <target state="translated">这是用于迭代命令行参数的便捷迭代器。这将创建一个新的OptParser。有关使用默认的空 &lt;code&gt;NoVal&lt;/code&gt; 参数的信息，请参见上面的 &lt;code&gt;getopt(var OptParser)&lt;/code&gt; 示例。该示例与该示例使用相同的选项键，但此处选项键值分隔符对于命令用户变为可选：</target>
        </trans-unit>
        <trans-unit id="e447530d06e7e3f0eb38b06f1ec7e2d1eabe95e8" translate="yes" xml:space="preserve">
          <source>This is an convenience iterator for iterating over the given OptParser object. Example:</source>
          <target state="translated">这是一个方便的迭代器,用于迭代给定的OptParser对象。例子:</target>
        </trans-unit>
        <trans-unit id="46521745d7cb0cedd54b67fe6c5b314fc7bf2b49" translate="yes" xml:space="preserve">
          <source>This is an example of a configuration file.</source>
          <target state="translated">这是一个配置文件的例子。</target>
        </trans-unit>
        <trans-unit id="bb8b17fc24c398ee4adf40c48e79b2a6ab176591" translate="yes" xml:space="preserve">
          <source>This is an example of a third party module that uses macros and templates to translate text strings on unmodified NimScript:</source>
          <target state="translated">这是一个第三方模块的例子,它使用宏和模板在未修改的NimScript上翻译文本字符串。</target>
        </trans-unit>
        <trans-unit id="37d57d5e9e40ed277e61d9e1d580ae63f60ceef5" translate="yes" xml:space="preserve">
          <source>This is an internal helper module. Do not use.</source>
          <target state="translated">这是一个内部辅助模块。请勿使用。</target>
        </trans-unit>
        <trans-unit id="8621b33d7505ff2f752c63fce71661a8f7e46de8" translate="yes" xml:space="preserve">
          <source>This is best explained by an example:</source>
          <target state="translated">这一点用一个例子来解释是最好的。</target>
        </trans-unit>
        <trans-unit id="303d755730efc75b448e0367fb111543fb211df2" translate="yes" xml:space="preserve">
          <source>This is best illustrated by an example:</source>
          <target state="translated">这一点通过一个例子得到了最好的说明。</target>
        </trans-unit>
        <trans-unit id="46f5b0f3810fc00217f071160db6bcce0f78c6fb" translate="yes" xml:space="preserve">
          <source>This is binary compatible to the type &lt;code&gt;char**&lt;/code&gt; in &lt;em&gt;C&lt;/em&gt;. The array's high value is large enough to disable bounds checking in practice. Use &lt;a href=&quot;#cstringArrayToSeq,cstringArray,Natural&quot;&gt;cstringArrayToSeq proc&lt;/a&gt; to convert it into a &lt;code&gt;seq[string]&lt;/code&gt;.</source>
          <target state="translated">这与&lt;em&gt;C中的&lt;/em&gt; &lt;code&gt;char**&lt;/code&gt; 类型二进制兼容。实际上，数组的高值足以禁用边界检查。使用&lt;a href=&quot;#cstringArrayToSeq,cstringArray,Natural&quot;&gt;cstringArrayToSeq proc&lt;/a&gt;将其转换为 &lt;code&gt;seq[string]&lt;/code&gt; 。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6d07b0945aa6279aac37be60460c485fcc1ff52f" translate="yes" xml:space="preserve">
          <source>This is binary compatible to the type &lt;code&gt;char**&lt;/code&gt; in &lt;em&gt;C&lt;/em&gt;. The array's high value is large enough to disable bounds checking in practice. Use &lt;em&gt;cstringArrayToSeq&lt;/em&gt; to convert it into a &lt;code&gt;seq[string]&lt;/code&gt;.</source>
          <target state="translated">这与&lt;em&gt;C中的&lt;/em&gt; &lt;code&gt;char**&lt;/code&gt; 类型二进制兼容。实际上，数组的高值足以禁用边界检查。使用&lt;em&gt;cstringArrayToSeq&lt;/em&gt;将其转换为 &lt;code&gt;seq[string]&lt;/code&gt; 。&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="0d8e0f1f729f18e2e3789687a0b726bb73204855" translate="yes" xml:space="preserve">
          <source>This is different from the &lt;a href=&quot;system#div,int,int&quot;&gt;system.div&lt;/a&gt; operator, which is defined as &lt;code&gt;trunc(x / y)&lt;/code&gt;. That is, &lt;code&gt;div&lt;/code&gt; rounds towards &lt;code&gt;0&lt;/code&gt; and &lt;code&gt;floorDiv&lt;/code&gt; rounds down.</source>
          <target state="translated">这与&lt;a href=&quot;system#div,int,int&quot;&gt;system.div&lt;/a&gt;运算符不同，后者定义为 &lt;code&gt;trunc(x / y)&lt;/code&gt; 。也就是说， &lt;code&gt;div&lt;/code&gt; &lt;code&gt;floorDiv&lt;/code&gt; 为 &lt;code&gt;0&lt;/code&gt; ，floorDiv取整。</target>
        </trans-unit>
        <trans-unit id="0bd38078b21b67094ebb387df8cff1e550ab3259" translate="yes" xml:space="preserve">
          <source>This is done using the &lt;code&gt;to&lt;/code&gt; macro. Take a look at &lt;a href=&quot;#to.m,JsonNode,typedesc&quot;&gt;its documentation&lt;/a&gt; to see an example of its use.</source>
          <target state="translated">这是使用 &lt;code&gt;to&lt;/code&gt; 宏完成的。查看&lt;a href=&quot;#to.m,JsonNode,typedesc&quot;&gt;其文档&lt;/a&gt;以查看其用法示例。</target>
        </trans-unit>
        <trans-unit id="0e255e0fbf090e03656557a6058c22d1d0988d1e" translate="yes" xml:space="preserve">
          <source>This is effectively the value of the &quot;Content-Length&quot; header.</source>
          <target state="translated">这实际上是 &quot;Content-Length &quot;头的值。</target>
        </trans-unit>
        <trans-unit id="ed8e6faffed9f4240c98845eace9c4ed1fe9f2f0" translate="yes" xml:space="preserve">
          <source>This is effectively the value of the &quot;Content-Type&quot; header.</source>
          <target state="translated">这实际上是 &quot;Content-Type &quot;头的值。</target>
        </trans-unit>
        <trans-unit id="86b65d9de6d29645204c64f1e3d019cece2fb6d2" translate="yes" xml:space="preserve">
          <source>This is effectively the value of the &quot;Last-Modified&quot; header.</source>
          <target state="translated">这实际上是 &quot;Last-Modified &quot;头的值。</target>
        </trans-unit>
        <trans-unit id="d640ae92e84a970ee42165aaa5616bc83d8747c3" translate="yes" xml:space="preserve">
          <source>This is equivalent to &lt;code&gt;s = @[]; setlen(s, len)&lt;/code&gt;, but more efficient since no reallocation is needed.</source>
          <target state="translated">这等效于 &lt;code&gt;s = @[]; setlen(s, len)&lt;/code&gt; ，但效率更高，因为不需要重新分配。</target>
        </trans-unit>
        <trans-unit id="ae97abc8c2bdcefb0d913bd908e2fc80b7fe31b2" translate="yes" xml:space="preserve">
          <source>This is equivalent to &lt;code&gt;var&lt;/code&gt;, but with &lt;code&gt;nnkLetSection&lt;/code&gt; rather than &lt;code&gt;nnkVarSection&lt;/code&gt;.</source>
          <target state="translated">这等效于 &lt;code&gt;var&lt;/code&gt; ，但是使用 &lt;code&gt;nnkLetSection&lt;/code&gt; 而不是 &lt;code&gt;nnkVarSection&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="36d6a591729274afeef549b79cbc02b07d624ba3" translate="yes" xml:space="preserve">
          <source>This is equivalent to &lt;span id=&quot;inet-ntoa_1&quot;&gt;inet_ntoa&lt;/span&gt;.</source>
          <target state="translated">这等效于&lt;span id=&quot;inet-ntoa_1&quot;&gt;inet_ntoa&lt;/span&gt;。</target>
        </trans-unit>
        <trans-unit id="31be46f14ea5182185d28153c71f2103de5579e6" translate="yes" xml:space="preserve">
          <source>This is high-level interface for &lt;span id=&quot;getpeername_1&quot;&gt;getpeername&lt;/span&gt;.</source>
          <target state="translated">这是&lt;span id=&quot;getpeername_1&quot;&gt;getpeername&lt;/span&gt;的高级接口。</target>
        </trans-unit>
        <trans-unit id="2074516e24b0521a08ed457d7f66ebecf4eb273e" translate="yes" xml:space="preserve">
          <source>This is high-level interface for &lt;span id=&quot;getsockname_1&quot;&gt;getsockname&lt;/span&gt;.</source>
          <target state="translated">这是&lt;span id=&quot;getsockname_1&quot;&gt;getsockname&lt;/span&gt;的高级接口。</target>
        </trans-unit>
        <trans-unit id="5365fcbec705681207add66f8f3d448223f0b9f4" translate="yes" xml:space="preserve">
          <source>This is intended for commands like check or parse which will work on the main project file unless explicitly given a specific file argument</source>
          <target state="translated">这是为像检查或解析这样的命令设计的,除非明确给出一个特定的文件参数,否则这些命令将在主项目文件上工作。</target>
        </trans-unit>
        <trans-unit id="4cca37ce9a619c91bf0a3b8b5b0129b402048ee0" translate="yes" xml:space="preserve">
          <source>This is not &lt;code&gt;pure&lt;/code&gt; mechanism for Windows Completion Ports (IOCP), so if you can avoid it, please do it. Use &lt;code&gt;addRead&lt;/code&gt; only if really need it (main usecase is adaptation of unix-like libraries to be asynchronous on Windows).</source>
          <target state="translated">这不是Windows完成端口（IOCP）的 &lt;code&gt;pure&lt;/code&gt; 机制，因此，如果可以避免，请执行此操作。仅在真正需要时才使用 &lt;code&gt;addRead&lt;/code&gt; （主要用例是将类Unix的库改编为在Windows上是异步的）。</target>
        </trans-unit>
        <trans-unit id="ca31998cd06c4abd11a107dae0b2105838b8be7f" translate="yes" xml:space="preserve">
          <source>This is not &lt;code&gt;pure&lt;/code&gt; mechanism for Windows Completion Ports (IOCP), so if you can avoid it, please do it. Use &lt;code&gt;addWrite&lt;/code&gt; only if really need it (main usecase is adaptation of unix-like libraries to be asynchronous on Windows).</source>
          <target state="translated">这不是Windows完成端口（IOCP）的 &lt;code&gt;pure&lt;/code&gt; 机制，因此，如果可以避免，请执行此操作。仅在确实需要时才使用 &lt;code&gt;addWrite&lt;/code&gt; （主要用例是将类Unix的库改编为在Windows上是异步的）。</target>
        </trans-unit>
        <trans-unit id="3ddf14a4425a7355cc2a2fa04844ca91c2768874" translate="yes" xml:space="preserve">
          <source>This is not &lt;code&gt;pure&lt;/code&gt; mechanism for Windows Completion Ports (IOCP), so if you can avoid it, please do it. Use &lt;em&gt;addRead&lt;/em&gt; only if really need it (main usecase is adaptation of unix-like libraries to be asynchronous on Windows).</source>
          <target state="translated">这不是Windows完成端口（IOCP）的 &lt;code&gt;pure&lt;/code&gt; 机制，因此，如果可以避免，请执行此操作。仅在确实需要时才使用&lt;em&gt;addRead&lt;/em&gt;（主要用例是将类Unix的库改编为在Windows上异步）。</target>
        </trans-unit>
        <trans-unit id="55bde4657459bdfc7c019b27a4bfe5a2e63714bd" translate="yes" xml:space="preserve">
          <source>This is not &lt;code&gt;pure&lt;/code&gt; mechanism for Windows Completion Ports (IOCP), so if you can avoid it, please do it. Use &lt;em&gt;addWrite&lt;/em&gt; only if really need it (main usecase is adaptation of unix-like libraries to be asynchronous on Windows).</source>
          <target state="translated">这不是Windows完成端口（IOCP）的 &lt;code&gt;pure&lt;/code&gt; 机制，因此，如果可以避免，请执行此操作。仅在确实需要时才使用&lt;em&gt;addWrite&lt;/em&gt;（主要用例是将类Unix的库改编为在Windows上是异步的）。</target>
        </trans-unit>
        <trans-unit id="628008d53ae8c66db6ea85a99a23fa3a10da5be9" translate="yes" xml:space="preserve">
          <source>This is not as efficient as turning a fixed length array into a sequence as it always copies every element of &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">这并不像转动固定长度阵列成序列，因为它总是副本中的每个元素作为高效 &lt;code&gt;a&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="35bb6096521d3fc312bed6cb0cb52cdf4b61e4a1" translate="yes" xml:space="preserve">
          <source>This is not guaranteed for the &lt;code&gt;times.Time&lt;/code&gt; type! This means that the &lt;code&gt;MonoTime&lt;/code&gt; should be used when measuring durations of time with high precision.</source>
          <target state="translated">不能保证使用 &lt;code&gt;times.Time&lt;/code&gt; 类型！这意味着在 &lt;code&gt;MonoTime&lt;/code&gt; 测量持续时间时应使用MonoTime。</target>
        </trans-unit>
        <trans-unit id="99100dfb2d46cb56adf22ab9dcf180bb5b0d4d9b" translate="yes" xml:space="preserve">
          <source>This is not the same AST for all uses of &lt;code&gt;var&lt;/code&gt;. See &lt;a href=&quot;macros#statements-procedure-declaration&quot;&gt;Procedure declaration&lt;/a&gt; for details.</source>
          <target state="translated">对于 &lt;code&gt;var&lt;/code&gt; 的所有使用，这不是同一个AST 。有关详细信息，请参见&lt;a href=&quot;macros#statements-procedure-declaration&quot;&gt;过程声明&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="55e873a8f9ecb0f52084031638cec01f7691b7b6" translate="yes" xml:space="preserve">
          <source>This is not the same AST for all uses of &lt;code&gt;var&lt;/code&gt;. See [Procedure declaration](&lt;a href=&quot;http://nim-lang.org/docs/macros.html#statements-procedure-declaration&quot;&gt;http://nim-lang.org/docs/macros.html#statements-procedure-declaration&lt;/a&gt;) for details.</source>
          <target state="translated">对于 &lt;code&gt;var&lt;/code&gt; 的所有使用，这不是同一个AST 。有关详细信息，请参见[过程声明]（&lt;a href=&quot;http://nim-lang.org/docs/macros.html#statements-procedure-declaration&quot;&gt;http://nim-lang.org/docs/macros.html#statements-procedure-declaration&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="c2a7fe82c8947dd52185c1702a90b9db33146699" translate="yes" xml:space="preserve">
          <source>This is not the syntax for assignment when combined with &lt;code&gt;var&lt;/code&gt;, &lt;code&gt;let&lt;/code&gt;, or &lt;code&gt;const&lt;/code&gt;.</source>
          <target state="translated">与 &lt;code&gt;var&lt;/code&gt; ， &lt;code&gt;let&lt;/code&gt; 或 &lt;code&gt;const&lt;/code&gt; 结合使用时，这不是分配的语法。</target>
        </trans-unit>
        <trans-unit id="4ffa6f30e8b92ee2b75fd9ae9e7c977be41a4837" translate="yes" xml:space="preserve">
          <source>This is not to be confused with &lt;a href=&quot;system#currentSourcePath.t&quot;&gt;system.currentSourcePath&lt;/a&gt; which returns the path of the source file containing that template call.</source>
          <target state="translated">请勿将它与&lt;a href=&quot;system#currentSourcePath.t&quot;&gt;system.currentSourcePath&lt;/a&gt;混淆，后者会返​​回包含该模板调用的源文件的路径。</target>
        </trans-unit>
        <trans-unit id="7b56f8d625d177685d852e8e5c0f45517f46c5cd" translate="yes" xml:space="preserve">
          <source>This is often better than disabling all warnings at once.</source>
          <target state="translated">这往往比一次性禁用所有警告要好。</target>
        </trans-unit>
        <trans-unit id="8a1f35c0ffc0ce49e85232a6bb768ebe237c3d29" translate="yes" xml:space="preserve">
          <source>This is often more efficient than &lt;code&gt;tmp = a; a = b; b = tmp&lt;/code&gt;. Particularly useful for sorting algorithms.</source>
          <target state="translated">这通常比 &lt;code&gt;tmp = a; a = b; b = tmp&lt;/code&gt; 更有效。a = b; b = tmp。对于排序算法特别有用。</target>
        </trans-unit>
        <trans-unit id="4d6f926873c2b638a1222cdb189469c5136966c2" translate="yes" xml:space="preserve">
          <source>This is often the same as the &lt;code&gt;head&lt;/code&gt; result of &lt;code&gt;splitPath&lt;/code&gt;. If there is no parent, &quot;&quot; is returned.</source>
          <target state="translated">这通常与 &lt;code&gt;splitPath&lt;/code&gt; 的 &lt;code&gt;head&lt;/code&gt; 结果相同。如果没有父母，则返回&amp;ldquo;&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="5387b23d1544c30a7bae7f5ad7dd90a3bed36ca1" translate="yes" xml:space="preserve">
          <source>This is often useful for generating some code where the items need to be &lt;em&gt;separated&lt;/em&gt; by &lt;code&gt;sep&lt;/code&gt;. &lt;code&gt;sep&lt;/code&gt; is only added if &lt;code&gt;dest&lt;/code&gt; is longer than &lt;code&gt;startLen&lt;/code&gt;. The following example creates a string describing an array of integers.</source>
          <target state="translated">这对于生成一些需要用 &lt;code&gt;sep&lt;/code&gt; &lt;em&gt;分隔&lt;/em&gt;项目的代码通常很有用。仅当 &lt;code&gt;dest&lt;/code&gt; 大于 &lt;code&gt;startLen&lt;/code&gt; 时才添加 &lt;code&gt;sep&lt;/code&gt; 。下面的示例创建一个描述整数数组的字符串。</target>
        </trans-unit>
        <trans-unit id="18b3f09919cd0742fbd659728142a828b4c8270a" translate="yes" xml:space="preserve">
          <source>This is often useful for generating some code where the items need to be &lt;em&gt;separated&lt;/em&gt; by &lt;em&gt;sep&lt;/em&gt;. &lt;em&gt;sep&lt;/em&gt; is only added if &lt;em&gt;dest&lt;/em&gt; is longer than &lt;em&gt;startLen&lt;/em&gt;. The following example creates a string describing an array of integers.</source>
          <target state="translated">这对于生成一些需要用&lt;em&gt;sep &lt;/em&gt;&lt;em&gt;分隔&lt;/em&gt;项目的代码通常很有用。仅当&lt;em&gt;dest&lt;/em&gt;大于&lt;em&gt;startLen&lt;/em&gt;时才添加&lt;em&gt;sep&lt;/em&gt;。下面的示例创建一个描述整数数组的字符串。&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1ce17a7f7111b242071cf2276a295e1114c27396" translate="yes" xml:space="preserve">
          <source>This is only needed if you need to implement a hash proc for a new datatype.</source>
          <target state="translated">只有当你需要为一个新的数据类型实现一个哈希proc时才需要这个。</target>
        </trans-unit>
        <trans-unit id="9c4b5a1ec53f980e2c0f3189011ffcb0ab0d3401" translate="yes" xml:space="preserve">
          <source>This is only of interest if you want to write a custom &lt;code&gt;format&lt;/code&gt; proc that should support the standard format specifiers. If &lt;code&gt;ignoreUnknownSuffix&lt;/code&gt; is true, an unknown suffix after the &lt;code&gt;type&lt;/code&gt; field is not an error.</source>
          <target state="translated">仅当您要编写应支持标准格式说明符的自定义 &lt;code&gt;format&lt;/code&gt; proc时，这才有意义。如果 &lt;code&gt;ignoreUnknownSuffix&lt;/code&gt; 为true，则 &lt;code&gt;type&lt;/code&gt; 字段后的未知后缀不是错误。</target>
        </trans-unit>
        <trans-unit id="e9b2fa085ecd9ffb0144806ddc4d77c951b5b385" translate="yes" xml:space="preserve">
          <source>This is only raised if the &lt;a href=&quot;segfaults&quot;&gt;segfaults module&lt;/a&gt; was imported!</source>
          <target state="translated">仅当导入了&lt;a href=&quot;segfaults&quot;&gt;segfaults模块&lt;/a&gt;时才会引发此问题！</target>
        </trans-unit>
        <trans-unit id="19846465c46a33495b53f4086a71823a95381c03" translate="yes" xml:space="preserve">
          <source>This is only raised if the &lt;code&gt;segfaults.nim&lt;/code&gt; module was imported!</source>
          <target state="translated">仅当导入了 &lt;code&gt;segfaults.nim&lt;/code&gt; 模块时才会引发此问题！</target>
        </trans-unit>
        <trans-unit id="fe15c448cc2638c08d44452df9bc1535305d8381" translate="yes" xml:space="preserve">
          <source>This is only used for speed hacks.</source>
          <target state="translated">这只用于速度黑客。</target>
        </trans-unit>
        <trans-unit id="6fb1edaaf90d1400f49467187534983c2fef435b" translate="yes" xml:space="preserve">
          <source>This is only useful for optimization purposes.</source>
          <target state="translated">这只对优化目的有用。</target>
        </trans-unit>
        <trans-unit id="88b8e0f949b1068c1e1a8a842d9da6796b501f9c" translate="yes" xml:space="preserve">
          <source>This is only useful if the program is compiled as a dynamic library via the &lt;code&gt;--app:lib&lt;/code&gt; command line option. This pragma only has an effect for the code generation on the Windows target, so when this pragma is forgotten and the dynamic library is only tested on Mac and/or Linux, there won't be an error. On Windows this pragma adds &lt;code&gt;__declspec(dllexport)&lt;/code&gt; to the function declaration.</source>
          <target state="translated">仅当通过 &lt;code&gt;--app:lib&lt;/code&gt; 命令行选项将程序编译为动态库时，此功能才有用。该编译指示仅对Windows目标上的代码生成有效，因此，当忘记该编译指示并且仅在Mac和/或Linux上对动态库进行测试时，不会出现错误。在Windows上，此杂注将 &lt;code&gt;__declspec(dllexport)&lt;/code&gt; 添加到函数声明中。</target>
        </trans-unit>
        <trans-unit id="1c92294cd2a2dc37d3a8cc6e8c5557f50f24e7aa" translate="yes" xml:space="preserve">
          <source>This is only useful if the program is compiled as a dynamic library via the &lt;code&gt;--app:lib&lt;/code&gt; command-line option.</source>
          <target state="translated">仅当通过 &lt;code&gt;--app:lib&lt;/code&gt; 命令行选项将程序编译为动态库时，此功能才有用。</target>
        </trans-unit>
        <trans-unit id="d812993dd18329bdd5b49f464355b81590a6389c" translate="yes" xml:space="preserve">
          <source>This is optional.</source>
          <target state="translated">这是可选的。</target>
        </trans-unit>
        <trans-unit id="f402c8f3279ea5adad0c54031820826de8af43c8" translate="yes" xml:space="preserve">
          <source>This is overridden by some tools (namely nimsuggest) via the &lt;code&gt;conf.prefixDir&lt;/code&gt; field.</source>
          <target state="translated">某些工具（即nimsuggest）通过 &lt;code&gt;conf.prefixDir&lt;/code&gt; 字段将其覆盖。</target>
        </trans-unit>
        <trans-unit id="9d41adf425cb818275923d0842af48d38ad37604" translate="yes" xml:space="preserve">
          <source>This is quite fast as it does not rely on any debug or runtime information. Note that in contrast to what the official signature says, the return type is &lt;em&gt;not&lt;/em&gt;&lt;code&gt;RootObj&lt;/code&gt; but a tuple of a structure that depends on the current scope. Example:</source>
          <target state="translated">这非常快，因为它不依赖任何调试或运行时信息。请注意，与官方签名相反，返回类型&lt;em&gt;不是&lt;/em&gt; &lt;code&gt;RootObj&lt;/code&gt; ,而是取决于当前范围的结构的元组。例子：</target>
        </trans-unit>
        <trans-unit id="624193289805ef01288ef5a655555f1018d6592e" translate="yes" xml:space="preserve">
          <source>This is roughly equivalent to the &lt;code&gt;async&lt;/code&gt; keyword in JavaScript code.</source>
          <target state="translated">这大致相当于JavaScript代码中的 &lt;code&gt;async&lt;/code&gt; 关键字。</target>
        </trans-unit>
        <trans-unit id="f551bed65fae9c1f7ad990939d07645246c92238" translate="yes" xml:space="preserve">
          <source>This is roughly the same as &lt;code&gt;trunc(x/y)&lt;/code&gt;.</source>
          <target state="translated">这与 &lt;code&gt;trunc(x/y)&lt;/code&gt; 大致相同。</target>
        </trans-unit>
        <trans-unit id="3575fcfddeaf3d18e36c701dd650fc2ec44479fc" translate="yes" xml:space="preserve">
          <source>This is same as &lt;code&gt;x - floorDiv(x, y) * y&lt;/code&gt;. This proc behaves the same as the &lt;code&gt;%&lt;/code&gt; operator in python.</source>
          <target state="translated">这与 &lt;code&gt;x - floorDiv(x, y) * y&lt;/code&gt; 。此proc的行为与python中的 &lt;code&gt;%&lt;/code&gt; 运算符相同。</target>
        </trans-unit>
        <trans-unit id="6c1d93ee2a8f74ad1e5b652d12e6c5278be5cb25" translate="yes" xml:space="preserve">
          <source>This is similar to &lt;code&gt;splitPath(path).head&lt;/code&gt; when &lt;code&gt;path&lt;/code&gt; doesn't end in a dir separator, but also takes care of path normalizations. The remainder can be obtained with &lt;a href=&quot;#lastPathPart,string&quot;&gt;lastPathPart(path) proc&lt;/a&gt;.</source>
          <target state="translated">这与 &lt;code&gt;splitPath(path).head&lt;/code&gt; 相似，当 &lt;code&gt;path&lt;/code&gt; 不在目录分隔符中结尾时，但还要注意路径的规范化。其余的可以通过&lt;a href=&quot;#lastPathPart,string&quot;&gt;lastPathPart（path）proc获得&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="24c992b9dfa7d27ecf9f025660223103e48bc1e8" translate="yes" xml:space="preserve">
          <source>This is synced from Nimble's version module.</source>
          <target state="translated">这是从Nimble的版本模块同步过来的。</target>
        </trans-unit>
        <trans-unit id="256bc61e58ad13a05d91f1a1bf2ae4f72005afe4" translate="yes" xml:space="preserve">
          <source>This is the concrete lookup algorithm that &lt;code&gt;&amp;amp;&lt;/code&gt; uses:</source>
          <target state="translated">这是 &lt;code&gt;&amp;amp;&lt;/code&gt; 使用的具体查找算法：</target>
        </trans-unit>
        <trans-unit id="36c2f5442839943020ad05dd2166b1d0f12b01e5" translate="yes" xml:space="preserve">
          <source>This is the high-level version of the above &lt;code&gt;sendTo&lt;/code&gt; function.</source>
          <target state="translated">这是上述 &lt;code&gt;sendTo&lt;/code&gt; 函数的高级版本。</target>
        </trans-unit>
        <trans-unit id="97bde134c3168ba7edefb1ec35ba4786bc969108" translate="yes" xml:space="preserve">
          <source>This is the in-place version of &lt;a href=&quot;#+,HashSet%5BA%5D,HashSet%5BA%5D&quot;&gt;s + other&lt;/a&gt;.</source>
          <target state="translated">这是&lt;a href=&quot;#+,HashSet%5BA%5D,HashSet%5BA%5D&quot;&gt;s + other&lt;/a&gt;的就地版本。</target>
        </trans-unit>
        <trans-unit id="ac4020d4e844ba19f46420bb9db474d77805335e" translate="yes" xml:space="preserve">
          <source>This is the in-place version of &lt;a href=&quot;#+,IntSet,IntSet&quot;&gt;s + other&lt;/a&gt;.</source>
          <target state="translated">这是&lt;a href=&quot;#+,IntSet,IntSet&quot;&gt;s + other&lt;/a&gt;的就地版本。</target>
        </trans-unit>
        <trans-unit id="b8710ddc5d8320cf19ea0e54c6b92bf35660f23f" translate="yes" xml:space="preserve">
          <source>This is the in-place version of &lt;a href=&quot;#-,HashSet%5BA%5D,HashSet%5BA%5D&quot;&gt;s - other&lt;/a&gt;.</source>
          <target state="translated">这是&lt;a href=&quot;#-,HashSet%5BA%5D,HashSet%5BA%5D&quot;&gt;s-other&lt;/a&gt;的就地版本。</target>
        </trans-unit>
        <trans-unit id="f37cf86ebf53b471461d913dd3976253d3ba7da4" translate="yes" xml:space="preserve">
          <source>This is the in-place version of &lt;a href=&quot;#-,IntSet,IntSet&quot;&gt;s - other&lt;/a&gt;.</source>
          <target state="translated">这是&lt;a href=&quot;#-,IntSet,IntSet&quot;&gt;s-other&lt;/a&gt;的就地版本。</target>
        </trans-unit>
        <trans-unit id="4826edc58b175eebfbf7081691448d2931000418" translate="yes" xml:space="preserve">
          <source>This is the jump function for the generator. It is equivalent to 2^64 calls to next(); it can be used to generate 2^64 non-overlapping subsequences for parallel computations.</source>
          <target state="translated">这是生成器的跳转函数,相当于2^64次调用next();它可以用来生成2^64个不重叠的子序列,用于并行计算。它相当于2^64次对next()的调用;它可以用来生成2^64次非重叠的子序列,用于并行计算。</target>
        </trans-unit>
        <trans-unit id="6d2f0ff4e73777d01102bb217c8397c6cddd4b22" translate="yes" xml:space="preserve">
          <source>This is the main &lt;em&gt;project&lt;/em&gt; filename. Most of the time you will pass in the same as &lt;strong&gt;FILE&lt;/strong&gt;, but for bigger projects this is the file which is used as main entry point for the program, the one which users compile to generate a final binary.</source>
          <target state="translated">这是主&lt;em&gt;项目&lt;/em&gt;文件名。在大多数情况下，您将传递与&lt;strong&gt;FILE&lt;/strong&gt;相同的&lt;strong&gt;文件&lt;/strong&gt;，但是对于较大的项目，这是用作程序的主要入口点的文件，用户可以编译该文件以生成最终的二进制文件。</target>
        </trans-unit>
        <trans-unit id="60a0c5c21aaa578b306725a8da9b601c4bd7d709" translate="yes" xml:space="preserve">
          <source>This is the name of the module or include file the query refers to.</source>
          <target state="translated">这是该查询引用的模块或包含文件的名称。</target>
        </trans-unit>
        <trans-unit id="c110d8ea0aa1384440227425443ae86a6ce178fd" translate="yes" xml:space="preserve">
          <source>This is the safecall convention as specified by Microsoft. The generated C procedure is declared with the &lt;code&gt;__safecall&lt;/code&gt; keyword. The word &lt;em&gt;safe&lt;/em&gt; refers to the fact that all hardware registers shall be pushed to the hardware stack.</source>
          <target state="translated">这是Microsoft指定的safecall约定。生成的C过程使用 &lt;code&gt;__safecall&lt;/code&gt; 关键字声明。这个词&lt;em&gt;安全&lt;/em&gt;指的是所有的硬件寄存器应推到硬件堆栈。</target>
        </trans-unit>
        <trans-unit id="31f95bc8194c8e476931e06554d37b68be940444" translate="yes" xml:space="preserve">
          <source>This is the same as &lt;code&gt;formatstr % [a]&lt;/code&gt; (see &lt;a href=&quot;#%25,string,openArray%5Bstring%5D&quot;&gt;% proc&lt;/a&gt;).</source>
          <target state="translated">这与 &lt;code&gt;formatstr % [a]&lt;/code&gt; （请参阅&lt;a href=&quot;#%25,string,openArray%5Bstring%5D&quot;&gt;％proc&lt;/a&gt;）相同。</target>
        </trans-unit>
        <trans-unit id="17370dc7ee3b0fe9dd442daf544baba9de37a9cc" translate="yes" xml:space="preserve">
          <source>This is the same as &lt;code&gt;formatstr % [a]&lt;/code&gt;.</source>
          <target state="translated">这与 &lt;code&gt;formatstr % [a]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="70a3bf31e3a4defa18a1d9c74fc782d763f566f3" translate="yes" xml:space="preserve">
          <source>This is the same as &lt;code&gt;formatstr % a&lt;/code&gt; (see &lt;a href=&quot;#%25,string,openArray%5Bstring%5D&quot;&gt;% proc&lt;/a&gt;) except that it supports auto stringification.</source>
          <target state="translated">除了支持自动字符串 &lt;code&gt;formatstr % a&lt;/code&gt; ，它与formatstr％a（请参阅&lt;a href=&quot;#%25,string,openArray%5Bstring%5D&quot;&gt;％proc&lt;/a&gt;）相同。</target>
        </trans-unit>
        <trans-unit id="5f5ff4983f3a23d7cc3be988cf86d83e4cd1f019" translate="yes" xml:space="preserve">
          <source>This is the same as &lt;code&gt;formatstr % a&lt;/code&gt; except that it supports auto stringification.</source>
          <target state="translated">这与 &lt;code&gt;formatstr % a&lt;/code&gt; 相同，除了它支持自动字符串化。</target>
        </trans-unit>
        <trans-unit id="01a5b235024b77996dea512c125137d383106839" translate="yes" xml:space="preserve">
          <source>This is the same as &lt;code&gt;len(splitLines(s))&lt;/code&gt;, but much more efficient because it doesn't modify the string creating temporal objects. Every &lt;a href=&quot;manual#character-literals&quot;&gt;character literal&lt;/a&gt; newline combination (CR, LF, CR-LF) is supported.</source>
          <target state="translated">这与 &lt;code&gt;len(splitLines(s))&lt;/code&gt; 相同，但是效率更高，因为它不会修改创建临时对象的字符串。支持每个&lt;a href=&quot;manual#character-literals&quot;&gt;字符文字&lt;/a&gt;换行符组合（CR，LF，CR-LF）。</target>
        </trans-unit>
        <trans-unit id="8d22f203eebe945efff26b7c0264ae6e58250798" translate="yes" xml:space="preserve">
          <source>This is the same as &lt;code&gt;len(splitLines(s))&lt;/code&gt;, but much more efficient because it doesn't modify the string creating temporal objects. Every &lt;a href=&quot;manual#lexical-analysis-character-literals&quot;&gt;character literal&lt;/a&gt; newline combination (CR, LF, CR-LF) is supported.</source>
          <target state="translated">这与 &lt;code&gt;len(splitLines(s))&lt;/code&gt; 相同，但是效率更高，因为它不会修改创建临时对象的字符串。支持每个&lt;a href=&quot;manual#lexical-analysis-character-literals&quot;&gt;字符文字&lt;/a&gt;换行符组合（CR，LF，CR-LF）。</target>
        </trans-unit>
        <trans-unit id="0badd9ad97e90a77853a8cbcdf1b0629e7129eff" translate="yes" xml:space="preserve">
          <source>This is the same as &lt;code&gt;name &amp;amp; ext&lt;/code&gt; from &lt;a href=&quot;#splitFile,string&quot;&gt;splitFile(path) proc&lt;/a&gt;.</source>
          <target state="translated">这是相同的 &lt;code&gt;name &amp;amp; ext&lt;/code&gt; 从&lt;a href=&quot;#splitFile,string&quot;&gt;splitFile（路径）PROC&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d339aebbd92622e7b2312aac755921a2fe584d45" translate="yes" xml:space="preserve">
          <source>This is the same as &lt;code&gt;x - (x div y) * y&lt;/code&gt;.</source>
          <target state="translated">这与 &lt;code&gt;x - (x div y) * y&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1888a678959ca4ae304b888c79aa8550425de069" translate="yes" xml:space="preserve">
          <source>This is the same as &lt;code&gt;x = x + {y}&lt;/code&gt;, but it might be more efficient.</source>
          <target state="translated">这与 &lt;code&gt;x = x + {y}&lt;/code&gt; ，但是可能更有效。</target>
        </trans-unit>
        <trans-unit id="3ae92e2d2df7af56345a63b06cbc0c4803a8fe53" translate="yes" xml:space="preserve">
          <source>This is the same as &lt;code&gt;x = x - {y}&lt;/code&gt;, but it might be more efficient.</source>
          <target state="translated">这与 &lt;code&gt;x = x - {y}&lt;/code&gt; ，但是可能更有效。</target>
        </trans-unit>
        <trans-unit id="82a366ac081a365e2c46179906b192a6a0e436be" translate="yes" xml:space="preserve">
          <source>This is the same as the type &lt;code&gt;char&lt;/code&gt; in &lt;em&gt;C&lt;/em&gt;.</source>
          <target state="translated">这是相同的类型 &lt;code&gt;char&lt;/code&gt; 在&lt;em&gt;&amp;Ccedil;&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="2698b8a90aa68f611a0ef1370a3ab044cd78c8a1" translate="yes" xml:space="preserve">
          <source>This is the same as the type &lt;code&gt;double&lt;/code&gt; in &lt;em&gt;C&lt;/em&gt;.</source>
          <target state="translated">这是相同的类型 &lt;code&gt;double&lt;/code&gt; 中&lt;em&gt;&amp;Ccedil;&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="32b6f8ca0c7194eb4b06ee5d7e525de947b0dfd5" translate="yes" xml:space="preserve">
          <source>This is the same as the type &lt;code&gt;float&lt;/code&gt; in &lt;em&gt;C&lt;/em&gt;.</source>
          <target state="translated">这是相同的类型 &lt;code&gt;float&lt;/code&gt; 在&lt;em&gt;&amp;Ccedil;&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="1a9d8dde930868443d859228ae0d07c7a292dfc2" translate="yes" xml:space="preserve">
          <source>This is the same as the type &lt;code&gt;int&lt;/code&gt; in &lt;em&gt;C&lt;/em&gt;.</source>
          <target state="translated">这是相同的类型 &lt;code&gt;int&lt;/code&gt; 在&lt;em&gt;C ^&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="89b75f0da7ac2537212723421db03228b32fdc6c" translate="yes" xml:space="preserve">
          <source>This is the same as the type &lt;code&gt;long double&lt;/code&gt; in &lt;em&gt;C&lt;/em&gt;. This C type is not supported by Nim's code generator.</source>
          <target state="translated">这是相同的类型 &lt;code&gt;long double&lt;/code&gt; 在&lt;em&gt;&amp;Ccedil;&lt;/em&gt;。Nim的代码生成器不支持此C类型。</target>
        </trans-unit>
        <trans-unit id="a37990dbd3eb06078ca83a8a56a6c3bd79234e4f" translate="yes" xml:space="preserve">
          <source>This is the same as the type &lt;code&gt;long long&lt;/code&gt; in &lt;em&gt;C&lt;/em&gt;.</source>
          <target state="translated">这是相同的类型 &lt;code&gt;long long&lt;/code&gt; 在&lt;em&gt;&amp;Ccedil;&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="1069dac8f5d3d5aa1a18361c4ff3f9b241cbf315" translate="yes" xml:space="preserve">
          <source>This is the same as the type &lt;code&gt;long&lt;/code&gt; in &lt;em&gt;C&lt;/em&gt;.</source>
          <target state="translated">这是相同的类型 &lt;code&gt;long&lt;/code&gt; 在&lt;em&gt;&amp;Ccedil;&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="7f6dc406a78e144191704d8486e22dc8fbe652f6" translate="yes" xml:space="preserve">
          <source>This is the same as the type &lt;code&gt;short&lt;/code&gt; in &lt;em&gt;C&lt;/em&gt;.</source>
          <target state="translated">这是相同的类型 &lt;code&gt;short&lt;/code&gt; 于&lt;em&gt;&amp;Ccedil;&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="e4c3756c51223d58c50aef0d5dbf74eeee747dd1" translate="yes" xml:space="preserve">
          <source>This is the same as the type &lt;code&gt;signed char&lt;/code&gt; in &lt;em&gt;C&lt;/em&gt;.</source>
          <target state="translated">这是作为类型相同 &lt;code&gt;signed char&lt;/code&gt; 在&lt;em&gt;&amp;Ccedil;&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="3bf874f74960f31038430fb144d0f39aa055b895" translate="yes" xml:space="preserve">
          <source>This is the same as the type &lt;code&gt;size_t&lt;/code&gt; in &lt;em&gt;C&lt;/em&gt;.</source>
          <target state="translated">这是相同的类型 &lt;code&gt;size_t&lt;/code&gt; 在&lt;em&gt;&amp;Ccedil;&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="df1c839c0f570919cf81eef346ac2a1dbb8ad2c9" translate="yes" xml:space="preserve">
          <source>This is the same as the type &lt;code&gt;unsigned char&lt;/code&gt; in &lt;em&gt;C&lt;/em&gt;.</source>
          <target state="translated">这是一样的类型 &lt;code&gt;unsigned char&lt;/code&gt; 在&lt;em&gt;&amp;Ccedil;&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="32542074871fb6c497f5c1eb6606f80b3822a88a" translate="yes" xml:space="preserve">
          <source>This is the same as the type &lt;code&gt;unsigned int&lt;/code&gt; in &lt;em&gt;C&lt;/em&gt;.</source>
          <target state="translated">这是一样的类型 &lt;code&gt;unsigned int&lt;/code&gt; 在&lt;em&gt;&amp;Ccedil;&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="36b8d34561a415968642b59c4b4b326317e48753" translate="yes" xml:space="preserve">
          <source>This is the same as the type &lt;code&gt;unsigned long long&lt;/code&gt; in &lt;em&gt;C&lt;/em&gt;.</source>
          <target state="translated">这是相同的类型 &lt;code&gt;unsigned long long&lt;/code&gt; 在&lt;em&gt;&amp;Ccedil;&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="0aa9bfe67b304447b5a2bcc627f38a17da1684d8" translate="yes" xml:space="preserve">
          <source>This is the same as the type &lt;code&gt;unsigned long&lt;/code&gt; in &lt;em&gt;C&lt;/em&gt;.</source>
          <target state="translated">这是相同的类型 &lt;code&gt;unsigned long&lt;/code&gt; 在&lt;em&gt;&amp;Ccedil;&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="cca46f57d68aae82238b145830c6ebed78c459d0" translate="yes" xml:space="preserve">
          <source>This is the same as the type &lt;code&gt;unsigned short&lt;/code&gt; in &lt;em&gt;C&lt;/em&gt;.</source>
          <target state="translated">这是相同的类型 &lt;code&gt;unsigned short&lt;/code&gt; 于&lt;em&gt;&amp;Ccedil;&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="7ec63cde9c899b1832f254d3a218fb0fdefa84a7" translate="yes" xml:space="preserve">
          <source>This is the same interface that is implemented for other databases.</source>
          <target state="translated">这和其他数据库实现的接口是一样的。</target>
        </trans-unit>
        <trans-unit id="e8c042bee5c7ca8787fc37bf633177ab6f1481ae" translate="yes" xml:space="preserve">
          <source>This is the stdcall convention as specified by Microsoft. The generated C procedure is declared with the &lt;code&gt;__stdcall&lt;/code&gt; keyword.</source>
          <target state="translated">这是Microsoft指定的stdcall约定。生成的C过程使用 &lt;code&gt;__stdcall&lt;/code&gt; 关键字声明。</target>
        </trans-unit>
        <trans-unit id="f2276f3847dd82156bd01096eddf53801bbc1da1" translate="yes" xml:space="preserve">
          <source>This is thiscall calling convention as specified by Microsoft, used on C++ class member functions on the x86 architecture</source>
          <target state="translated">这是微软指定的thiscall调用惯例,用于x86架构上的C++类成员函数。</target>
        </trans-unit>
        <trans-unit id="0d76cb52dda63a7debd58296187c89613b5d29c5" translate="yes" xml:space="preserve">
          <source>This is translated to a call to the &lt;code&gt;schema&lt;/code&gt; macro with a &lt;code&gt;nnkTypeDef&lt;/code&gt; AST node capturing both the left-hand side and right-hand side of the definition. The macro can return a potentially modified &lt;code&gt;nnkTypeDef&lt;/code&gt; tree which will replace the original row in the type section.</source>
          <target state="translated">这被转换为对具有 &lt;code&gt;nnkTypeDef&lt;/code&gt; AST节点的 &lt;code&gt;schema&lt;/code&gt; 宏的调用，该AST节点同时捕获了定义的左侧和右侧。宏可以返回可能会修改的 &lt;code&gt;nnkTypeDef&lt;/code&gt; 树，它将替换类型部分中的原始行。</target>
        </trans-unit>
        <trans-unit id="2b006c0a74e5f0b534a0cf75365ae7eaf0121b5e" translate="yes" xml:space="preserve">
          <source>This is translated to:</source>
          <target state="translated">此译为:</target>
        </trans-unit>
        <trans-unit id="39524a8c34f8678cfa0e73ee87c4662e966e0a89" translate="yes" xml:space="preserve">
          <source>This is used, for example, in the &lt;code&gt;bindSym&lt;/code&gt; examples &lt;a href=&quot;manual#macros-bindsym&quot;&gt;here&lt;/a&gt; and with &lt;code&gt;re&quot;some regexp&quot;&lt;/code&gt; in the regular expression module.</source>
          <target state="translated">例如，这在&lt;a href=&quot;manual#macros-bindsym&quot;&gt;此处&lt;/a&gt;的 &lt;code&gt;bindSym&lt;/code&gt; 示例中使用，在正则表达式模块中与 &lt;code&gt;re&quot;some regexp&quot;&lt;/code&gt; 一起使用。</target>
        </trans-unit>
        <trans-unit id="193cec7a7162a70eca01c095ac18043a02af9656" translate="yes" xml:space="preserve">
          <source>This is used, for example, in the &lt;code&gt;bindSym&lt;/code&gt; examples [here](&lt;a href=&quot;http://nim-lang.org/docs/manual.html#macros-bindsym&quot;&gt;http://nim-lang.org/docs/manual.html#macros-bindsym&lt;/a&gt;) and with &lt;code&gt;re&quot;some regexp&quot;&lt;/code&gt; in the regular expression module.</source>
          <target state="translated">例如，在 &lt;code&gt;bindSym&lt;/code&gt; 示例[here]（&lt;a href=&quot;http://nim-lang.org/docs/manual.html#macros-bindsym&quot;&gt;http://nim-lang.org/docs/manual.html#macros-bindsym&lt;/a&gt;）和正则表达式模块中带有 &lt;code&gt;re&quot;some regexp&quot;&lt;/code&gt; 情况下使用此方法。</target>
        </trans-unit>
        <trans-unit id="ca3384cc6ee2a6305631e3401a802d6acf72b3b1" translate="yes" xml:space="preserve">
          <source>This is useful for writing generic algorithms without performance loss. This generic implementation uses the &lt;code&gt;==&lt;/code&gt; and &lt;code&gt;&amp;lt;&lt;/code&gt; operators.</source>
          <target state="translated">这对于编写没有性能损失的通用算法很有用。此通用实现使用 &lt;code&gt;==&lt;/code&gt; 和 &lt;code&gt;&amp;lt;&lt;/code&gt; 运算符。</target>
        </trans-unit>
        <trans-unit id="5c869caa2cb0e2a4566d33db6c594392aa3e88fd" translate="yes" xml:space="preserve">
          <source>This is useful if you want to copy or save files across Windows, Linux, Mac, etc. You can pass full paths as argument too, but func only checks filenames. It uses &lt;code&gt;invalidFilenameChars&lt;/code&gt;, &lt;code&gt;invalidFilenames&lt;/code&gt; and &lt;code&gt;maxLen&lt;/code&gt; to verify the specified &lt;code&gt;filename&lt;/code&gt;.</source>
          <target state="translated">如果要跨Windows，Linux，Mac等复制或保存文件，这很有用。您也可以将完整路径作为参数传递，但是func仅检查文件名。它使用 &lt;code&gt;invalidFilenameChars&lt;/code&gt; ， &lt;code&gt;invalidFilenames&lt;/code&gt; 和 &lt;code&gt;maxLen&lt;/code&gt; 来验证指定的 &lt;code&gt;filename&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a54a83cbed83c0f42bf0a73af1d5e007c04a1c74" translate="yes" xml:space="preserve">
          <source>This is useful when one overloaded &lt;code&gt;hash&lt;/code&gt; and &lt;code&gt;==&lt;/code&gt; but still needs reference semantics for sharing.</source>
          <target state="translated">当一个重载的 &lt;code&gt;hash&lt;/code&gt; 和 &lt;code&gt;==&lt;/code&gt; 但仍需要引用语义进行共享时，此功能很有用。</target>
        </trans-unit>
        <trans-unit id="814be46e563ada83f9262b5e8d3fa69226b5320b" translate="yes" xml:space="preserve">
          <source>This is very fast, but potentially dangerous. Use this iterator only if you require &lt;strong&gt;ALL&lt;/strong&gt; the rows.</source>
          <target state="translated">这是非常快的，但是有潜在的危险。仅在需要&lt;strong&gt;所有&lt;/strong&gt;行时才使用此迭代器。</target>
        </trans-unit>
        <trans-unit id="134eddc978c41c43c45ed9c6b1ceb47614d9e60b" translate="yes" xml:space="preserve">
          <source>This isn't the same as &lt;code&gt;size_t&lt;/code&gt; in &lt;em&gt;C&lt;/em&gt;. Don't use it.</source>
          <target state="translated">这是不一样 &lt;code&gt;size_t&lt;/code&gt; 在&lt;em&gt;&amp;Ccedil;&lt;/em&gt;。不要使用它。</target>
        </trans-unit>
        <trans-unit id="cd0fbed086855b31d79192247a84655610b15079" translate="yes" xml:space="preserve">
          <source>This library relies on the header files of your C compiler. The resulting C code will just &lt;code&gt;#include &amp;lt;XYZ.h&amp;gt;&lt;/code&gt; and &lt;em&gt;not&lt;/em&gt; define the symbols declared here.</source>
          <target state="translated">该库依赖于C编译器的头文件。生成的C代码将仅 &lt;code&gt;#include &amp;lt;XYZ.h&amp;gt;&lt;/code&gt; ，&lt;em&gt;而不&lt;/em&gt;定义此处声明的符号。</target>
        </trans-unit>
        <trans-unit id="31048b78d2181ce88fb6bfd891a52408cadc9fbf" translate="yes" xml:space="preserve">
          <source>This macro also allows for (otherwise in-place) function chaining.</source>
          <target state="translated">这个宏还允许(其他地方的)函数链。</target>
        </trans-unit>
        <trans-unit id="b8bd537d709836e793cec8da49a638fdf122f928" translate="yes" xml:space="preserve">
          <source>This makes it easy to delete all generated files.</source>
          <target state="translated">这样就可以轻松删除所有生成的文件。</target>
        </trans-unit>
        <trans-unit id="352e8583e6de97b799c5da9ed3e4a4e5b04d179b" translate="yes" xml:space="preserve">
          <source>This makes it easy to delete all generated files. Files generated in this directory follow a naming logic which you can read about in the &lt;a href=&quot;backends#nimcache-naming-logic&quot;&gt;Nim Backend Integration document&lt;/a&gt;.</source>
          <target state="translated">这样可以轻松删除所有生成的文件。在该目录中生成的文件遵循命名逻辑，您可以在&lt;a href=&quot;backends#nimcache-naming-logic&quot;&gt;Nim Backend Integration文档中&lt;/a&gt;阅读该命名逻辑。</target>
        </trans-unit>
        <trans-unit id="e986bf4a76bcf2a2515dce45f1d6c7ca80702bc0" translate="yes" xml:space="preserve">
          <source>This means that &quot;borrowed&quot; views can be written naturally and without explicit pointer indirections:</source>
          <target state="translated">这意味着 &quot;借用 &quot;的视图可以自然而然地编写,而不需要明确的指针内向。</target>
        </trans-unit>
        <trans-unit id="f4e5b1294716a2171951a03c64eda20f357eb30a" translate="yes" xml:space="preserve">
          <source>This means that any &lt;code&gt;%xx&lt;/code&gt; (where &lt;code&gt;xx&lt;/code&gt; denotes a hexadecimal value) are converted to the character with ordinal number &lt;code&gt;xx&lt;/code&gt;, and every other character is carried over. If &lt;code&gt;xx&lt;/code&gt; is not a valid hexadecimal value, it is left intact.</source>
          <target state="translated">这意味着任何 &lt;code&gt;%xx&lt;/code&gt; （其中 &lt;code&gt;xx&lt;/code&gt; 表示一个十六进制值）都将转换为序号为 &lt;code&gt;xx&lt;/code&gt; 的字符，并且每个其他字符都会被保留。如果 &lt;code&gt;xx&lt;/code&gt; 不是有效的十六进制值，则将其保留完整。</target>
        </trans-unit>
        <trans-unit id="052067fc6ee68fa2f9dbd0b6a372e7c4df39a2b8" translate="yes" xml:space="preserve">
          <source>This means that any &lt;code&gt;'%xx'&lt;/code&gt; (where &lt;code&gt;xx&lt;/code&gt; denotes a hexadecimal value) are converted to the character with ordinal number &lt;code&gt;xx&lt;/code&gt;, and every other character is carried over.</source>
          <target state="translated">这意味着任何 &lt;code&gt;'%xx'&lt;/code&gt; （其中 &lt;code&gt;xx&lt;/code&gt; 表示一个十六进制值）都将转换为序号为 &lt;code&gt;xx&lt;/code&gt; 的字符，并且每隔一个字符都会被保留。</target>
        </trans-unit>
        <trans-unit id="20eaeefb7ad0f37cbcfe130963c8445b739d8936" translate="yes" xml:space="preserve">
          <source>This means that characters in the set &lt;code&gt;{'a'..'z', 'A'..'Z', '0'..'9', '-', '.', '_', '~'}&lt;/code&gt; are carried over to the result. All other characters are encoded as &lt;code&gt;%xx&lt;/code&gt; where &lt;code&gt;xx&lt;/code&gt; denotes its hexadecimal value.</source>
          <target state="translated">这意味着集合 &lt;code&gt;{'a'..'z', 'A'..'Z', '0'..'9', '-', '.', '_', '~'}&lt;/code&gt; 保留到结果中。所有其他字符均编码为 &lt;code&gt;%xx&lt;/code&gt; ，其中 &lt;code&gt;xx&lt;/code&gt; 表示其十六进制值。</target>
        </trans-unit>
        <trans-unit id="a119e88cdea67075391ab49a84997ba0f8df61b5" translate="yes" xml:space="preserve">
          <source>This means that characters in the set &lt;code&gt;{'a'..'z', 'A'..'Z', '0'..'9', '-', '.', '_', '~'}&lt;/code&gt; are carried over to the result. All other characters are encoded as &lt;code&gt;''%xx'&lt;/code&gt; where &lt;code&gt;xx&lt;/code&gt; denotes its hexadecimal value.</source>
          <target state="translated">这意味着集合 &lt;code&gt;{'a'..'z', 'A'..'Z', '0'..'9', '-', '.', '_', '~'}&lt;/code&gt; 结转到结果。所有其他字符均编码为 &lt;code&gt;''%xx'&lt;/code&gt; ，其中 &lt;code&gt;xx&lt;/code&gt; 表示其十六进制值。</target>
        </trans-unit>
        <trans-unit id="40b048bf83553881e511d74bd63cac489f70ae5d" translate="yes" xml:space="preserve">
          <source>This means that the slashes inside the base URI's path as well as reference URI's path affect the resulting URI.</source>
          <target state="translated">这意味着基础URI路径和引用URI路径中的斜线会影响结果的URI。</target>
        </trans-unit>
        <trans-unit id="922850b50b784f0baf0fafd0fe540e7582cac936" translate="yes" xml:space="preserve">
          <source>This means that the slashes inside the base URIs path as well as reference URIs path affect the resulting URI.</source>
          <target state="translated">这意味着基础URIs路径和引用URIs路径中的斜线会影响结果的URI。</target>
        </trans-unit>
        <trans-unit id="d681cd1b517c30b7e61efd9d0f2710e753e51a4c" translate="yes" xml:space="preserve">
          <source>This means that when for some reason a procedure needs a disambiguation through the module name, the call needs to be written in function call syntax.</source>
          <target state="translated">这意味着,当某个过程由于某种原因需要通过模块名称进行歧义时,需要用函数调用语法来编写调用。</target>
        </trans-unit>
        <trans-unit id="4ef6d8c1596a849e1d58fe82a1e6a88d8d08fefb" translate="yes" xml:space="preserve">
          <source>This means the following compiles (for now) even though it really should not:</source>
          <target state="translated">这意味着下面的编译(目前),尽管它确实不应该。</target>
        </trans-unit>
        <trans-unit id="10445172840b8572e10f6fbc77991aa94729820e" translate="yes" xml:space="preserve">
          <source>This mechanism will be used by most data structures that support shared memory like channels to implement thread safe automatic memory management.</source>
          <target state="translated">这种机制将被大多数支持共享内存的数据结构(如通道)使用,以实现线程安全的自动内存管理。</target>
        </trans-unit>
        <trans-unit id="5cce8e43b46c329ab2a3787ae9c0cae31bce9579" translate="yes" xml:space="preserve">
          <source>This method call syntax is not restricted to objects, it can be used for any type:</source>
          <target state="translated">这种方法调用语法不限于对象,它可以用于任何类型。</target>
        </trans-unit>
        <trans-unit id="c18ebc20a57311d93348b03173ca9377d2b87fe3" translate="yes" xml:space="preserve">
          <source>This method call syntax is not restricted to objects, it can be used to supply any type of first argument for procedures:</source>
          <target state="translated">这种方法调用语法并不限于对象,它可以用来为程序提供任何类型的第一个参数。</target>
        </trans-unit>
        <trans-unit id="7ec21e93e0cf3038676cfddb7994789208b8b989" translate="yes" xml:space="preserve">
          <source>This method ignores the list of registered handlers.</source>
          <target state="translated">本方法忽略注册的处理程序列表。</target>
        </trans-unit>
        <trans-unit id="b86fc0ee3a63db9a4d667e5e9867b56be701b07c" translate="yes" xml:space="preserve">
          <source>This method is not available for the JavaScript backend.</source>
          <target state="translated">该方法对JavaScript后台不可用。</target>
        </trans-unit>
        <trans-unit id="c4f76b4fe4da8b8424258ff632b4b8aba97934a0" translate="yes" xml:space="preserve">
          <source>This modifies &lt;code&gt;s&lt;/code&gt; itself, it does not return a copy.</source>
          <target state="translated">这本身会修改 &lt;code&gt;s&lt;/code&gt; ，但不会返回副本。</target>
        </trans-unit>
        <trans-unit id="56f6408118ba81283de7ac109aa7b480ef6c069c" translate="yes" xml:space="preserve">
          <source>This modifies &lt;code&gt;x&lt;/code&gt; itself, it does not return a copy.</source>
          <target state="translated">这会修改 &lt;code&gt;x&lt;/code&gt; 本身，但不会返回副本。</target>
        </trans-unit>
        <trans-unit id="e8a743fd1b7ce29c9eafd7535f1bcb06655400ac" translate="yes" xml:space="preserve">
          <source>This modifies &lt;em&gt;s&lt;/em&gt; itself, it does not return a copy.</source>
          <target state="translated">这本身会修改&lt;em&gt;s&lt;/em&gt;，但不会返回副本。</target>
        </trans-unit>
        <trans-unit id="399957ae50c4d50ec5409505af7d5ec3350ca32a" translate="yes" xml:space="preserve">
          <source>This modifies the internal list that kept the insertion order, so insertion order is lost after this call but key lookup and insertions remain possible after &lt;code&gt;sort&lt;/code&gt; (in contrast to the &lt;a href=&quot;#sort,CountTable%5BA%5D&quot;&gt;sort proc&lt;/a&gt; for count tables).</source>
          <target state="translated">这会修改保留插入顺序的内部列表，因此在此调用后插入顺序会丢失，但 &lt;code&gt;sort&lt;/code&gt; 后仍可以进行键查找和插入（与计数表的&lt;a href=&quot;#sort,CountTable%5BA%5D&quot;&gt;排序过程&lt;/a&gt;相反）。</target>
        </trans-unit>
        <trans-unit id="7b2c1b5b7b769344ec6ebabe55a749624b20d2f0" translate="yes" xml:space="preserve">
          <source>This modifies the internal list that kept the insertion order, so insertion order is lost after this call but key lookup and insertions remain possible after &lt;code&gt;sort&lt;/code&gt; (in contrast to the &lt;a href=&quot;#sort,CountTableRef%5BA%5D&quot;&gt;sort proc&lt;/a&gt; for count tables).</source>
          <target state="translated">这会修改保留插入顺序的内部列表，因此在此调用后插入顺序会丢失，但 &lt;code&gt;sort&lt;/code&gt; 后仍可以进行键查找和插入（与计数表的&lt;a href=&quot;#sort,CountTableRef%5BA%5D&quot;&gt;排序过程&lt;/a&gt;相反）。</target>
        </trans-unit>
        <trans-unit id="da5bab7c7f53e383fb7fd313b6d6578109127b68" translate="yes" xml:space="preserve">
          <source>This module &lt;strong&gt;partially&lt;/strong&gt; implements an FTP client as specified by &lt;a href=&quot;http://tools.ietf.org/html/rfc959&quot;&gt;RFC 959&lt;/a&gt;.</source>
          <target state="translated">此模块&lt;strong&gt;部分&lt;/strong&gt;实现&lt;a href=&quot;http://tools.ietf.org/html/rfc959&quot;&gt;RFC 959&lt;/a&gt;指定的FTP客户端。</target>
        </trans-unit>
        <trans-unit id="353b9d1b799c5ad1bd4a492759bb6ea40d16c6be" translate="yes" xml:space="preserve">
          <source>This module allows high-level and efficient I/O multiplexing.</source>
          <target state="translated">该模块可以实现高层次、高效率的I/O复用。</target>
        </trans-unit>
        <trans-unit id="77582b104bbd815cba00372c32475601c25cf527" translate="yes" xml:space="preserve">
          <source>This module allows you to access fields in a parsed JSON object in two different ways, one of them is described in this section.</source>
          <target state="translated">该模块允许你以两种不同的方式访问解析JSON对象中的字段,其中一种方式将在本节中描述。</target>
        </trans-unit>
        <trans-unit id="b3498eb6ea3bb3348c1e6a56f205dc1cc756e769" translate="yes" xml:space="preserve">
          <source>This module also implements a &lt;code&gt;scanp&lt;/code&gt; macro, which syntax somewhat resembles an EBNF or PEG grammar, except that it uses Nim's expression syntax and so has to use prefix instead of postfix operators.</source>
          <target state="translated">该模块还实现了 &lt;code&gt;scanp&lt;/code&gt; 宏，其语法有点类似于EBNF或PEG语法，只是它使用Nim的表达式语法，因此必须使用前缀而不是后缀运算符。</target>
        </trans-unit>
        <trans-unit id="ef44ae92a94357463ee874a1523c9d291e715eef" translate="yes" xml:space="preserve">
          <source>This module also implements the protocol used to format messages, as specified by RFC 2822.</source>
          <target state="translated">该模块还实现了RFC 2822规定的用于格式化消息的协议。</target>
        </trans-unit>
        <trans-unit id="e13b1625e61f884e29573a44e8b33b49a44a5992" translate="yes" xml:space="preserve">
          <source>This module builds upon that, providing additional functionality in form of procedures, iterators and templates for strings.</source>
          <target state="translated">该模块在此基础上,以程序、迭代器和字符串模板的形式提供额外的功能。</target>
        </trans-unit>
        <trans-unit id="5cdfcb3c036a119b924e511faf70eaedadc90ee4" translate="yes" xml:space="preserve">
          <source>This module builds upon that, providing additional functionality in form of procs, iterators and templates inspired by functional programming languages.</source>
          <target state="translated">该模块在此基础上,以procs、迭代器和受函数式编程语言启发的模板的形式提供附加功能。</target>
        </trans-unit>
        <trans-unit id="f47e628756db21f739b926daba1d8817fcf31162" translate="yes" xml:space="preserve">
          <source>This module can also be used to comfortably create JSON using the &lt;code&gt;%*&lt;/code&gt; operator:</source>
          <target state="translated">此模块还可以用于使用 &lt;code&gt;%*&lt;/code&gt; 运算符轻松地创建JSON ：</target>
        </trans-unit>
        <trans-unit id="7a5d643a068677170a94b694f4f1ab9c3fa2652e" translate="yes" xml:space="preserve">
          <source>This module can also be used to comfortably create JSON using the &lt;em&gt;%*&lt;/em&gt; operator:</source>
          <target state="translated">此模块还可用于使用&lt;em&gt;％*&lt;/em&gt;运算符轻松地创建JSON ：</target>
        </trans-unit>
        <trans-unit id="5ac6344a11b0cec8bee2e186a1f2d87c14205cf3" translate="yes" xml:space="preserve">
          <source>This module contains 'typeAllowed' and friends which check for invalid types like 'openArray[var int]'.</source>
          <target state="translated">这个模块包含'typeAllowed'和检查无效类型的朋友,比如'openArray[var int]'。</target>
        </trans-unit>
        <trans-unit id="d6e7d195d331b7d6c15e12922caec76c1b942621" translate="yes" xml:space="preserve">
          <source>This module contains Nim's support for locks and condition vars.</source>
          <target state="translated">该模块包含Nim对锁和条件变量的支持。</target>
        </trans-unit>
        <trans-unit id="762c0c406df7455c202f1f73c29bbcaf2e671b58" translate="yes" xml:space="preserve">
          <source>This module contains Nim's support for reentrant locks.</source>
          <target state="translated">这个模块包含了Nim对再入锁的支持。</target>
        </trans-unit>
        <trans-unit id="51e2b2a3ac1f926c532ebca53a22c529f45f34b9" translate="yes" xml:space="preserve">
          <source>This module contains SSL configuration parameters obtained from &lt;a href=&quot;https://wiki.mozilla.org/Security/Server_Side_TLS&quot;&gt;Mozilla OpSec&lt;/a&gt;.</source>
          <target state="translated">该模块包含从&lt;a href=&quot;https://wiki.mozilla.org/Security/Server_Side_TLS&quot;&gt;Mozilla OpSec&lt;/a&gt;获得的SSL配置参数。</target>
        </trans-unit>
        <trans-unit id="40ca976fb8b35eb3df922d2b5066e9569252023d" translate="yes" xml:space="preserve">
          <source>This module contains a &lt;span id=&quot;scanf_1&quot;&gt;scanf&lt;/span&gt; macro that can be used for extracting substrings from an input string. This is often easier than regular expressions. Some examples as an appetizer:</source>
          <target state="translated">该模块包含一个&lt;span id=&quot;scanf_1&quot;&gt;scanf&lt;/span&gt;宏，可用于从输入字符串中提取子字符串。这通常比正则表达式容易。作为开胃菜的一些例子：</target>
        </trans-unit>
        <trans-unit id="1489dea58f0e2e175da913a82f51d717b857c72e" translate="yes" xml:space="preserve">
          <source>This module contains a few procedures to control the &lt;em&gt;terminal&lt;/em&gt; (also called &lt;em&gt;console&lt;/em&gt;). On UNIX, the implementation simply uses ANSI escape sequences and does not depend on any other module, on Windows it uses the Windows API. Changing the style is permanent even after program termination! Use the code &lt;code&gt;system.addQuitProc(resetAttributes)&lt;/code&gt; to restore the defaults. Similarly, if you hide the cursor, make sure to unhide it with &lt;code&gt;showCursor&lt;/code&gt; before quitting.</source>
          <target state="translated">该模块包含一些控制&lt;em&gt;终端&lt;/em&gt;（也称为&lt;em&gt;console&lt;/em&gt;）的过程。在UNIX上，该实现仅使用ANSI转义序列，并且不依赖于任何其他模块，在Windows上，它使用Windows API。即使终止程序，更改样式也是永久的！使用代码 &lt;code&gt;system.addQuitProc(resetAttributes)&lt;/code&gt; 恢复默认值。同样，如果您隐藏光标，请确保在退出之前使用 &lt;code&gt;showCursor&lt;/code&gt; 取消隐藏它。</target>
        </trans-unit>
        <trans-unit id="7e93f8f54a9484fe22dcb778e11ee50ae595038e" translate="yes" xml:space="preserve">
          <source>This module contains a simple persistent id generator.</source>
          <target state="translated">该模块包含一个简单的持久化id生成器。</target>
        </trans-unit>
        <trans-unit id="859cd9a84610a4573796c23e8584dde691268fe4" translate="yes" xml:space="preserve">
          <source>This module contains an algorithm to wordwrap a Unicode string.</source>
          <target state="translated">这个模块包含了一个对Unicode字符串进行文字包装的算法。</target>
        </trans-unit>
        <trans-unit id="1f440cc00bf2a40f36bf90840926be53d2b4581f" translate="yes" xml:space="preserve">
          <source>This module contains basic operating system facilities like retrieving environment variables, reading command line arguments, working with directories, running shell commands, etc.</source>
          <target state="translated">该模块包含基本的操作系统设施,如检索环境变量、读取命令行参数、使用目录、运行shell命令等。</target>
        </trans-unit>
        <trans-unit id="aebeafbfc315baffdf1e6869390c403d1c5a4946" translate="yes" xml:space="preserve">
          <source>This module contains code for generating volatile loads and stores, which are useful in embedded and systems programming.</source>
          <target state="translated">该模块包含了生成易失性负载和存储的代码,这在嵌入式和系统编程中很有用。</target>
        </trans-unit>
        <trans-unit id="f8484eb3bf4310e5df9a41c735476490885f266c" translate="yes" xml:space="preserve">
          <source>This module contains helpers for parsing tokens, numbers, identifiers, etc.</source>
          <target state="translated">该模块包含解析标记、数字、标识符等的助手。</target>
        </trans-unit>
        <trans-unit id="f6e5ce3fb2f04f76809ea7a033742e832b442a1c" translate="yes" xml:space="preserve">
          <source>This module contains helpers for parsing tokens, numbers, integers, floats, identifiers, etc.</source>
          <target state="translated">这个模块包含了解析标记、数字、整数、浮点数、标识符等的助手。</target>
        </trans-unit>
        <trans-unit id="86de046f7b616971dd6062d8ab76fb2ee06ec285" translate="yes" xml:space="preserve">
          <source>This module contains helpers that deal with different byte orders (&lt;span id=&quot;endian_1&quot;&gt;endian&lt;/span&gt;).</source>
          <target state="translated">此模块包含处理不同字节顺序（&lt;span id=&quot;endian_1&quot;&gt;endian&lt;/span&gt;）的帮助程序。</target>
        </trans-unit>
        <trans-unit id="3507a070fad07c9f9b3947b600282a6e5783a4cf" translate="yes" xml:space="preserve">
          <source>This module contains procs for &lt;span id=&quot;serialization_1&quot;&gt;serialization&lt;/span&gt; and &lt;span id=&quot;deseralization_1&quot;&gt;deseralization&lt;/span&gt; of arbitrary Nim data structures. The serialization format uses &lt;span id=&quot;json_1&quot;&gt;JSON&lt;/span&gt;. Warning: The serialization format could change in future!</source>
          <target state="translated">该模块包含用于对任意Nim数据结构进行&lt;span id=&quot;serialization_1&quot;&gt;序列化&lt;/span&gt;和&lt;span id=&quot;deseralization_1&quot;&gt;反&lt;/span&gt;&lt;span id=&quot;serialization_1&quot;&gt;序列化的&lt;/span&gt;&lt;span id=&quot;deseralization_1&quot;&gt;proc&lt;/span&gt;。序列化格式使用&lt;span id=&quot;json_1&quot;&gt;JSON&lt;/span&gt;。警告：序列化格式将来可能会更改！</target>
        </trans-unit>
        <trans-unit id="5f95162e9e6ccb749f85b72f9199f205223155d1" translate="yes" xml:space="preserve">
          <source>This module contains procs for &lt;span id=&quot;serialization_1&quot;&gt;serialization&lt;/span&gt; and &lt;span id=&quot;deserialization_1&quot;&gt;deserialization&lt;/span&gt; of arbitrary Nim data structures. The serialization format uses &lt;span id=&quot;json_1&quot;&gt;JSON&lt;/span&gt;.</source>
          <target state="translated">该模块包含用于对任意Nim数据结构进行&lt;span id=&quot;serialization_1&quot;&gt;序列化&lt;/span&gt;和&lt;span id=&quot;deserialization_1&quot;&gt;反&lt;/span&gt;&lt;span id=&quot;serialization_1&quot;&gt;序列化&lt;/span&gt;的proc。序列化格式使用&lt;span id=&quot;json_1&quot;&gt;JSON&lt;/span&gt;。</target>
        </trans-unit>
        <trans-unit id="371318c1a0161f22d8f2e0f2e50fa5c06ee82a39" translate="yes" xml:space="preserve">
          <source>This module contains routines and types for dealing with time using a proleptic Gregorian calendar. It's also available for the &lt;a href=&quot;backends#the-javascript-target&quot;&gt;JavaScript target&lt;/a&gt;.</source>
          <target state="translated">该模块包含用于使用多事历公历处理时间的例程和类型。它也可用于&lt;a href=&quot;backends#the-javascript-target&quot;&gt;JavaScript target&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="681edb1a4152d4c5c1a28a26efed7538442ba878" translate="yes" xml:space="preserve">
          <source>This module contains support for a &lt;span id=&quot;rope_1&quot;&gt;rope&lt;/span&gt; data type. Ropes can represent very long strings efficiently; especially concatenation is done in O(1) instead of O(n). They are essentially concatenation trees that are only flattened when converting to a native Nim string. The empty string is represented by &lt;code&gt;nil&lt;/code&gt;. Ropes are immutable and subtrees can be shared without copying. Leaves can be cached for better memory efficiency at the cost of runtime efficiency.</source>
          <target state="translated">该模块包含对&lt;span id=&quot;rope_1&quot;&gt;绳索&lt;/span&gt;数据类型的支持。绳索可以有效地代表很长的弦；特别是串联是在O（1）而不是O（n）中完成的。它们本质上是串联树，仅在转换为本地Nim字符串时才被展平。空字符串由 &lt;code&gt;nil&lt;/code&gt; 表示。绳索是不可变的，子树可以共享而无需复制。可以缓存叶以提高内存效率，但要以运行时效率为代价。</target>
        </trans-unit>
        <trans-unit id="b376b4ebaaab23249fc9320639fee9fdc18842d7" translate="yes" xml:space="preserve">
          <source>This module contains the &lt;code&gt;TMsgKind&lt;/code&gt; enum as well as the &lt;code&gt;TLineInfo&lt;/code&gt; object.</source>
          <target state="translated">该模块包含 &lt;code&gt;TMsgKind&lt;/code&gt; 枚举以及 &lt;code&gt;TLineInfo&lt;/code&gt; 对象。</target>
        </trans-unit>
        <trans-unit id="b8814cd36c6aae34db1d0386489c78e9dbe808ff" translate="yes" xml:space="preserve">
          <source>This module contains the data structures for the C code generation phase.</source>
          <target state="translated">该模块包含C代码生成阶段的数据结构。</target>
        </trans-unit>
        <trans-unit id="f5b114c265f10b8a271d8de9414b2aacb4dde589" translate="yes" xml:space="preserve">
          <source>This module contains the data structures for the semantic checking phase.</source>
          <target state="translated">本模块包含语义检查阶段的数据结构。</target>
        </trans-unit>
        <trans-unit id="48a18d40233e79f25223ec93664005a48f943242" translate="yes" xml:space="preserve">
          <source>This module contains the interface to the compiler's abstract syntax tree (&lt;span id=&quot;ast_1&quot;&gt;AST&lt;/span&gt;). Macros operate on this tree.</source>
          <target state="translated">此模块包含编译器抽象语法树（&lt;span id=&quot;ast_1&quot;&gt;AST&lt;/span&gt;）的接口。宏在此树上运行。</target>
        </trans-unit>
        <trans-unit id="94973e879d7e0d952c022e954deb2fbb3c8e206b" translate="yes" xml:space="preserve">
          <source>This module contains the type definitions for the new evaluation engine. An instruction is 1-3 int32s in memory, it is a register based VM.</source>
          <target state="translated">该模块包含新的评估引擎的类型定义。一条指令在内存中是1-3条int32,它是一个基于寄存器的虚拟机。</target>
        </trans-unit>
        <trans-unit id="4a11c4dcef359935de61e37ffe6d34cb9d89068f" translate="yes" xml:space="preserve">
          <source>This module contains various string matchers for email addresses, etc.</source>
          <target state="translated">该模块包含各种电子邮件地址的字符串匹配器等。</target>
        </trans-unit>
        <trans-unit id="dc6f5f3c4d5eabca058f0bb06a0585786c4d3b49" translate="yes" xml:space="preserve">
          <source>This module contains various string utility routines that are uncommonly used in comparison to &lt;a href=&quot;strutils&quot;&gt;strutils&lt;/a&gt;.</source>
          <target state="translated">该模块包含各种字符串实用程序例程，这些例程与&lt;a href=&quot;strutils&quot;&gt;strutils&lt;/a&gt;相比不常用。</target>
        </trans-unit>
        <trans-unit id="4d2fcdeecb346421f24a622468611b1e35012c38" translate="yes" xml:space="preserve">
          <source>This module contains various string utility routines. See the module &lt;a href=&quot;re&quot;&gt;re&lt;/a&gt; for regular expression support. See the module &lt;a href=&quot;pegs&quot;&gt;pegs&lt;/a&gt; for PEG support. This module is available for the &lt;a href=&quot;backends#the-javascript-target&quot;&gt;JavaScript target&lt;/a&gt;.</source>
          <target state="translated">该模块包含各种字符串实用程序例程。有关正则表达式的支持，请参见模块&lt;a href=&quot;re&quot;&gt;re&lt;/a&gt;。有关PEG的支持，请参见模块&lt;a href=&quot;pegs&quot;&gt;钉&lt;/a&gt;。该模块可用于&lt;a href=&quot;backends#the-javascript-target&quot;&gt;JavaScript目标&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="47c439c96c86563186d79ec7720605588cc9ed86" translate="yes" xml:space="preserve">
          <source>This module defines compile-time reflection procs for working with types</source>
          <target state="translated">本模块定义了编译时的反射程序,用于处理类型</target>
        </trans-unit>
        <trans-unit id="60144eff5e3a9e63fbb73c5a6a2dab67f8c5d761" translate="yes" xml:space="preserve">
          <source>This module defines compile-time reflection procs for working with types.</source>
          <target state="translated">本模块定义了用于处理类型的编译时反射procs。</target>
        </trans-unit>
        <trans-unit id="0c756bd0d905b898b07e1bbf5dac867ce5994db8" translate="yes" xml:space="preserve">
          <source>This module does not implement any ORM features such as mapping the types from the schema. Instead, a &lt;code&gt;seq[string]&lt;/code&gt; is returned for each row.</source>
          <target state="translated">该模块不实现任何ORM功能，例如从架构映射类型。而是为每行返回 &lt;code&gt;seq[string]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0de4eb1c72ff111a775ba8d7bcc00cdb24085f9e" translate="yes" xml:space="preserve">
          <source>This module implements URI parsing as specified by RFC 3986.</source>
          <target state="translated">该模块实现了RFC 3986所规定的URI解析。</target>
        </trans-unit>
        <trans-unit id="27f7329a9231fa9eb3dabedee0d7ec09c071c36c" translate="yes" xml:space="preserve">
          <source>This module implements XML DOM Level 2 Core specification (&lt;a href=&quot;http://www.w3.org/TR/2000/REC-DOM-Level-2-Core-20001113/core.html&quot;&gt;http://www.w3.org/TR/2000/REC-DOM-Level-2-Core-20001113/core.html&lt;/a&gt;)</source>
          <target state="translated">该模块实现了XML DOM 2级核心规范（&lt;a href=&quot;http://www.w3.org/TR/2000/REC-DOM-Level-2-Core-20001113/core.html&quot;&gt;http://www.w3.org/TR/2000/REC-DOM-Level-2-Core-20001113/core.html&lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="1270c3451976ca2c6dbe064b63a8c754c870a12f" translate="yes" xml:space="preserve">
          <source>This module implements a &lt;span id=&quot;crit-bit-tree_1&quot;&gt;crit bit tree&lt;/span&gt; which is an efficient container for a sorted set of strings, or for a sorted mapping of strings. Based on the excellent paper by Adam Langley. (A crit bit tree is a form of &lt;span id=&quot;radix-tree_1&quot;&gt;radix tree&lt;/span&gt; or &lt;span id=&quot;patricia-trie_1&quot;&gt;patricia trie&lt;/span&gt;.)</source>
          <target state="translated">该模块实现了关键&lt;span id=&quot;crit-bit-tree_1&quot;&gt;位树&lt;/span&gt;，它是排序字符串集或字符串映射映射的有效容器。基于亚当&amp;middot;兰利的出色论文。（暴击树是&lt;span id=&quot;radix-tree_1&quot;&gt;基数树&lt;/span&gt;或&lt;span id=&quot;patricia-trie_1&quot;&gt;patricia trie的&lt;/span&gt;一种形式。）</target>
        </trans-unit>
        <trans-unit id="d33fc50e3ca1debee0d3e81969fe922a6c7f125b" translate="yes" xml:space="preserve">
          <source>This module implements a &lt;span id=&quot;restructuredtext_1&quot;&gt;reStructuredText&lt;/span&gt; parser. A large subset is implemented. Some features of the &lt;span id=&quot;markdown_1&quot;&gt;markdown&lt;/span&gt; wiki syntax are also supported.</source>
          <target state="translated">该模块实现了&lt;span id=&quot;restructuredtext_1&quot;&gt;reStructuredText&lt;/span&gt;解析器。实现了很大的子集。还支持&lt;span id=&quot;markdown_1&quot;&gt;markdown&lt;/span&gt; Wiki语法的某些功能。</target>
        </trans-unit>
        <trans-unit id="6977f3d46bd112fbaa438f57a03c83e720c94436" translate="yes" xml:space="preserve">
          <source>This module implements a base object of a lexer with efficient buffer handling. Only at line endings checks are necessary if the buffer needs refilling.</source>
          <target state="translated">这个模块实现了一个具有高效缓冲区处理能力的词典基础对象。只有在行结束时才需要检查是否需要重新填充缓冲区。</target>
        </trans-unit>
        <trans-unit id="df7211c34a2ecd3f4fc0d583c3ad6e78e895ee92" translate="yes" xml:space="preserve">
          <source>This module implements a base64 encoder and decoder.</source>
          <target state="translated">该模块实现了一个base64编码器和解码器。</target>
        </trans-unit>
        <trans-unit id="6081002e18d54466e7c5566ce284e757eba696e6" translate="yes" xml:space="preserve">
          <source>This module implements a generator of HTML/Latex from &lt;span id=&quot;restructuredtext_1&quot;&gt;reStructuredText&lt;/span&gt; (see &lt;a href=&quot;http://docutils.sourceforge.net/rst.html&quot;&gt;http://docutils.sourceforge.net/rst.html&lt;/a&gt; for information on this markup syntax) and is used by the compiler's &lt;a href=&quot;docgen&quot;&gt;docgen tools&lt;/a&gt;.</source>
          <target state="translated">该模块从&lt;span id=&quot;restructuredtext_1&quot;&gt;reStructuredText&lt;/span&gt;实现HTML / Latex的生成器（有关此标记语法的信息，请参见&lt;a href=&quot;http://docutils.sourceforge.net/rst.html&quot;&gt;http://docutils.sourceforge.net/rst.html&lt;/a&gt;），并且由编译器的&lt;a href=&quot;docgen&quot;&gt;docgen工具使用&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="17f9d509be6ad16b77fcf94001ab38bee17334b5" translate="yes" xml:space="preserve">
          <source>This module implements a generator of HTML/Latex from &lt;span id=&quot;restructuredtext_1&quot;&gt;reStructuredText&lt;/span&gt; (see &lt;a href=&quot;http://docutils.sourceforge.net/rst.html&quot;&gt;http://docutils.sourceforge.net/rst.html&lt;/a&gt; for information on this markup syntax) and is used by the compiler's &lt;a href=&quot;https://nim-lang.org/docs/docgen.html&quot;&gt;docgen tools&lt;/a&gt;.</source>
          <target state="translated">该模块从&lt;span id=&quot;restructuredtext_1&quot;&gt;reStructuredText&lt;/span&gt;实现HTML / Latex的生成器（有关此标记语法的信息，请参见&lt;a href=&quot;http://docutils.sourceforge.net/rst.html&quot;&gt;http://docutils.sourceforge.net/rst.html&lt;/a&gt;），并且由编译器的&lt;a href=&quot;https://nim-lang.org/docs/docgen.html&quot;&gt;docgen工具使用&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2e24ad7c182e7005c7758742478f3329d0f6132c" translate="yes" xml:space="preserve">
          <source>This module implements a helper for a thread pool to determine whether creating a thread is a good idea.</source>
          <target state="translated">该模块实现了一个线程池的帮助器,用于判断创建线程是否是一个好主意。</target>
        </trans-unit>
        <trans-unit id="454ce041e8ff19cc3f47caab96d62276cdca14fe" translate="yes" xml:space="preserve">
          <source>This module implements a high performance asynchronous HTTP server.</source>
          <target state="translated">该模块实现了一个高性能的异步HTTP服务器。</target>
        </trans-unit>
        <trans-unit id="55bdd10c5a5f89322ba8a15e1873d103379babdc" translate="yes" xml:space="preserve">
          <source>This module implements a high-level asynchronous sockets API based on the asynchronous dispatcher defined in the &lt;code&gt;asyncdispatch&lt;/code&gt; module.</source>
          <target state="translated">该模块基于 &lt;code&gt;asyncdispatch&lt;/code&gt; 模块中定义的异步调度程序实现高级异步套接字API 。</target>
        </trans-unit>
        <trans-unit id="141c50103e76c15b79b0d58835babe4f607c974d" translate="yes" xml:space="preserve">
          <source>This module implements a high-level cross-platform sockets interface. The procedures implemented in this module are primarily for blocking sockets. For asynchronous non-blocking sockets use the &lt;code&gt;asyncnet&lt;/code&gt; module together with the &lt;code&gt;asyncdispatch&lt;/code&gt; module.</source>
          <target state="translated">该模块实现了高级的跨平台套接字接口。此模块中实现的过程主要用于阻止套接字。对于异步无阻塞套接字，请使用 &lt;code&gt;asyncnet&lt;/code&gt; 模块和 &lt;code&gt;asyncdispatch&lt;/code&gt; 模块。</target>
        </trans-unit>
        <trans-unit id="db9ba48b68fd354aaa5fc20475e579aac2d2654d" translate="yes" xml:space="preserve">
          <source>This module implements a json parser. It is used and exported by the &lt;code&gt;json&lt;/code&gt; standard library module, but can also be used in its own right.</source>
          <target state="translated">此模块实现json解析器。它由 &lt;code&gt;json&lt;/code&gt; 标准库模块使用和导出，但也可以单独使用。</target>
        </trans-unit>
        <trans-unit id="b1fdd4da540e62b9188383b60a46eeb260182e77" translate="yes" xml:space="preserve">
          <source>This module implements a low-level cross-platform sockets interface. Look at the &lt;code&gt;net&lt;/code&gt; module for the higher-level version.</source>
          <target state="translated">该模块实现了一个低级别的跨平台套接字接口。在 &lt;code&gt;net&lt;/code&gt; 模块中查找更高版本的模块。</target>
        </trans-unit>
        <trans-unit id="ffb0db7a5f8cb3e13d15cfbadb31dc0a731e0b20" translate="yes" xml:space="preserve">
          <source>This module implements a mimetypes database</source>
          <target state="translated">该模块实现了一个mimetypes数据库。</target>
        </trans-unit>
        <trans-unit id="52c7b497a1d812a7103e93d248b7ce30058bcc07" translate="yes" xml:space="preserve">
          <source>This module implements a series of low level methods for bit manipulation.</source>
          <target state="translated">该模块实现了一系列低级的位操作方法。</target>
        </trans-unit>
        <trans-unit id="369970703d77f45ce74f0890d99dc3ad540cefb1" translate="yes" xml:space="preserve">
          <source>This module implements a series of low level methods for bit manipulation. By default, this module use compiler intrinsics to improve performance on supported compilers: &lt;code&gt;GCC&lt;/code&gt;, &lt;code&gt;LLVM_GCC&lt;/code&gt;, &lt;code&gt;CLANG&lt;/code&gt;, &lt;code&gt;VCC&lt;/code&gt;, &lt;code&gt;ICC&lt;/code&gt;.</source>
          <target state="translated">该模块实现了一系列用于位操作的低级方法。默认情况下，此模块使用编译器内部函数来提高支持的编译器的性能： &lt;code&gt;GCC&lt;/code&gt; ， &lt;code&gt;LLVM_GCC&lt;/code&gt; ， &lt;code&gt;CLANG&lt;/code&gt; ， &lt;code&gt;VCC&lt;/code&gt; ， &lt;code&gt;ICC&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6a72068a61f0ac219b08c124ba6a885d3d706a6f" translate="yes" xml:space="preserve">
          <source>This module implements a simple &lt;span id=&quot;xml_1&quot;&gt;XML&lt;/span&gt; and &lt;span id=&quot;html_1&quot;&gt;HTML&lt;/span&gt; code generator. Each commonly used HTML tag has a corresponding macro that generates a string with its HTML representation.</source>
          <target state="translated">该模块实现了一个简单的&lt;span id=&quot;xml_1&quot;&gt;XML&lt;/span&gt;和&lt;span id=&quot;html_1&quot;&gt;HTML&lt;/span&gt;代码生成器。每个常用的HTML标记都有一个相应的宏，该宏生成带有HTML表示形式的字符串。</target>
        </trans-unit>
        <trans-unit id="85bfb7ff9d532c8dadfbbeaebbf969dd68bafa42" translate="yes" xml:space="preserve">
          <source>This module implements a simple HTTP client that can be used to retrieve webpages and other data.</source>
          <target state="translated">该模块实现了一个简单的HTTP客户端,可以用来检索网页和其他数据。</target>
        </trans-unit>
        <trans-unit id="042f483a9df711dab36503622086bf978deae7dc" translate="yes" xml:space="preserve">
          <source>This module implements a simple high performance &lt;span id=&quot;csv_1&quot;&gt;CSV&lt;/span&gt; (&lt;span id=&quot;comma-separated-value_1&quot;&gt;comma separated value&lt;/span&gt;) parser.</source>
          <target state="translated">该模块实现了一个简单的高性能&lt;span id=&quot;csv_1&quot;&gt;CSV&lt;/span&gt;（&lt;span id=&quot;comma-separated-value_1&quot;&gt;逗号分隔值&lt;/span&gt;）解析器。</target>
        </trans-unit>
        <trans-unit id="79501d3f5ff57c410bf937ebfdaefd4be7b9f7d2" translate="yes" xml:space="preserve">
          <source>This module implements a simple high performance &lt;span id=&quot;json_1&quot;&gt;JSON&lt;/span&gt; parser. JSON (JavaScript Object Notation) is a lightweight data-interchange format that is easy for humans to read and write (unlike XML). It is easy for machines to parse and generate. JSON is based on a subset of the JavaScript Programming Language, Standard ECMA-262 3rd Edition - December 1999.</source>
          <target state="translated">该模块实现了一个简单的高性能&lt;span id=&quot;json_1&quot;&gt;JSON&lt;/span&gt;解析器。 JSON（JavaScript对象表示法）是一种轻量级的数据交换格式，人类易于读写（与XML不同）。机器很容易解析和生成。 JSON基于JavaScript编程语言（标准ECMA-262第三版-1999年12月）的子集。</target>
        </trans-unit>
        <trans-unit id="06a978a90f444ab2e371ab0e33c92d28de7bff58" translate="yes" xml:space="preserve">
          <source>This module implements a simple high performance &lt;span id=&quot;xml_1&quot;&gt;XML&lt;/span&gt; / &lt;span id=&quot;html_1&quot;&gt;HTML&lt;/span&gt; parser. The only encoding that is supported is UTF-8. The parser has been designed to be somewhat error correcting, so that even most &quot;wild HTML&quot; found on the web can be parsed with it. &lt;strong&gt;Note:&lt;/strong&gt; This parser does not check that each &lt;code&gt;&amp;lt;tag&amp;gt;&lt;/code&gt; has a corresponding &lt;code&gt;&amp;lt;/tag&amp;gt;&lt;/code&gt;! These checks have do be implemented by the client code for various reasons:</source>
          <target state="translated">该模块实现了一个简单的高性能&lt;span id=&quot;xml_1&quot;&gt;XML&lt;/span&gt; / &lt;span id=&quot;html_1&quot;&gt;HTML&lt;/span&gt;解析器。支持的唯一编码是UTF-8。该解析器经过精心设计，可以进行一些纠错，因此即使在网络上找到的大多数&amp;ldquo;野生HTML&amp;rdquo;也可以使用它进行解析。&lt;strong&gt;注意：&lt;/strong&gt;该解析器不会检查每个 &lt;code&gt;&amp;lt;tag&amp;gt;&lt;/code&gt; 是否具有对应的 &lt;code&gt;&amp;lt;/tag&amp;gt;&lt;/code&gt; ！出于各种原因，客户端代码确实实现了这些检查：</target>
        </trans-unit>
        <trans-unit id="a0c65178c960a4c67a65aebfc6e35293749e48ed" translate="yes" xml:space="preserve">
          <source>This module implements a simple logger.</source>
          <target state="translated">该模块实现了一个简单的记录器。</target>
        </trans-unit>
        <trans-unit id="48947ec421a5467d0d646e322ab81e8c9a02a691" translate="yes" xml:space="preserve">
          <source>This module implements a simple logger. It has been designed to be as simple as possible to avoid bloat, if this library does not fulfill your needs, write your own.</source>
          <target state="translated">这个模块实现了一个简单的记录器。它的设计尽量简单以避免臃肿,如果这个库不能满足你的需求,可以自己写。</target>
        </trans-unit>
        <trans-unit id="3dadb028527d802791d6f87341aff532946953c1" translate="yes" xml:space="preserve">
          <source>This module implements a simple proc for opening URLs with the user's default browser.</source>
          <target state="translated">该模块实现了一个简单的程序,用于用用户的默认浏览器打开URL。</target>
        </trans-unit>
        <trans-unit id="7fb049b95846bb771385f79aa14ac44a91216509" translate="yes" xml:space="preserve">
          <source>This module implements a small wrapper for some needed Win API procedures, so that the Nim compiler does not depend on the huge Windows module.</source>
          <target state="translated">这个模块为一些需要的Win API过程实现了一个小的封装器,这样Nim编译器就不需要依赖庞大的Windows模块了。</target>
        </trans-unit>
        <trans-unit id="5ac84b13286763d5a846ef3e91168372a188a0b8" translate="yes" xml:space="preserve">
          <source>This module implements an AST for the &lt;span id=&quot;restructuredtext_1&quot;&gt;reStructuredText&lt;/span&gt; parser.</source>
          <target state="translated">此模块为&lt;span id=&quot;restructuredtext_1&quot;&gt;reStructuredText&lt;/span&gt;解析器实现AST 。</target>
        </trans-unit>
        <trans-unit id="be080849cfa6c4b49c9b095ad65b6fcaae6e195d" translate="yes" xml:space="preserve">
          <source>This module implements an advanced facility for executing OS processes and process communication.</source>
          <target state="translated">该模块实现了执行OS进程和进程通信的高级设施。</target>
        </trans-unit>
        <trans-unit id="0ecce61f14e63c77639e9bbde5141d17de0e240e" translate="yes" xml:space="preserve">
          <source>This module implements an algorithm to compute the &lt;span id=&quot;edit-distance_1&quot;&gt;edit distance&lt;/span&gt; between two Unicode strings.</source>
          <target state="translated">该模块实现了一种算法，用于计算两个Unicode字符串之间的&lt;span id=&quot;edit-distance_1&quot;&gt;编辑距离&lt;/span&gt;。</target>
        </trans-unit>
        <trans-unit id="4019f34ee73cf2afc6617ad82d4cc99b8a1651c5" translate="yes" xml:space="preserve">
          <source>This module implements an asynchronous FTP client. It allows you to connect to an FTP server and perform operations on it such as for example:</source>
          <target state="translated">该模块实现了一个异步FTP客户端。它允许你连接到一个FTP服务器,并对其进行操作,例如。</target>
        </trans-unit>
        <trans-unit id="13879d8d10926994138f177a507809351445a9d4" translate="yes" xml:space="preserve">
          <source>This module implements an asynchronous event loop together with asynchronous sockets which use this event loop. It is akin to Python's asyncore module. Many modules that use sockets have an implementation for this module, those modules should all have a &lt;code&gt;register&lt;/code&gt; function which you should use to add the desired objects to a dispatcher which you created so that you can receive the events associated with that module's object.</source>
          <target state="translated">此模块与使用此事件循环的异步套接字一起实现异步事件循环。它类似于Python的asyncore模块。许多使用套接字的模块都有该模块的实现，这些模块都应具有 &lt;code&gt;register&lt;/code&gt; 功能，您应使用该功能将所需的对象添加到创建的调度程序中，以便可以接收与该模块的对象关联的事件。</target>
        </trans-unit>
        <trans-unit id="631695dd25ee11fd41bde8946a743e509c7a762f" translate="yes" xml:space="preserve">
          <source>This module implements an interface to Nim's &lt;span id=&quot;runtime-type-information_1&quot;&gt;runtime type information&lt;/span&gt; (&lt;span id=&quot;rtti_1&quot;&gt;RTTI&lt;/span&gt;). Note that even though &lt;code&gt;Any&lt;/code&gt; and its operations hide the nasty low level details from its clients, it remains inherently unsafe!</source>
          <target state="translated">该模块实现了Nim的&lt;span id=&quot;runtime-type-information_1&quot;&gt;运行时类型信息&lt;/span&gt;（&lt;span id=&quot;rtti_1&quot;&gt;RTTI&lt;/span&gt;）的接口。请注意，即使 &lt;code&gt;Any&lt;/code&gt; 及其操作向其客户隐藏了令人讨厌的低级详细信息，但它本质上仍然不安全！</target>
        </trans-unit>
        <trans-unit id="a745aa0375a74f7df55bc17c9183f618e2e8312e" translate="yes" xml:space="preserve">
          <source>This module implements an interface to Nim's &lt;span id=&quot;runtime-type-information_1&quot;&gt;runtime type information&lt;/span&gt; (&lt;span id=&quot;rtti_1&quot;&gt;RTTI&lt;/span&gt;). See the &lt;a href=&quot;marshal&quot;&gt;marshal&lt;/a&gt; module for an example of what this module allows you to do.</source>
          <target state="translated">该模块实现了Nim的&lt;span id=&quot;runtime-type-information_1&quot;&gt;运行时类型信息&lt;/span&gt;（&lt;span id=&quot;rtti_1&quot;&gt;RTTI&lt;/span&gt;）的接口。有关该模块允许您执行的操作的示例，请参见&lt;a href=&quot;marshal&quot;&gt;元帅&lt;/a&gt;模块。</target>
        </trans-unit>
        <trans-unit id="743043f366d434da8a30113b7bbb02a151e1774b" translate="yes" xml:space="preserve">
          <source>This module implements asynchronous IO. This includes a dispatcher, a &lt;code&gt;Future&lt;/code&gt; type implementation, and an &lt;code&gt;async&lt;/code&gt; macro which allows asynchronous code to be written in a synchronous style with the &lt;code&gt;await&lt;/code&gt; keyword.</source>
          <target state="translated">该模块实现异步IO。这包括一个调度程序，一个 &lt;code&gt;Future&lt;/code&gt; 类型的实现以及一个 &lt;code&gt;async&lt;/code&gt; 宏，该宏允许使用 &lt;code&gt;await&lt;/code&gt; 关键字以同步方式编写异步代码。</target>
        </trans-unit>
        <trans-unit id="ff0fc0b254406eef01f02b40f3655696591bd82c" translate="yes" xml:space="preserve">
          <source>This module implements asynchronous file reading and writing.</source>
          <target state="translated">该模块实现了异步文件读写。</target>
        </trans-unit>
        <trans-unit id="be0a15236b06fa556c56498d41940c7197453f73" translate="yes" xml:space="preserve">
          <source>This module implements boilerplate to make unit testing easy.</source>
          <target state="translated">该模块实现了锅炉模板,使单元测试变得简单。</target>
        </trans-unit>
        <trans-unit id="909c88835454bdf5c0519702c5f2c7e4a9275b55" translate="yes" xml:space="preserve">
          <source>This module implements code generation for methods.</source>
          <target state="translated">该模块实现了方法的代码生成。</target>
        </trans-unit>
        <trans-unit id="fdb823571314137136b672c316a1e4f9478ba59e" translate="yes" xml:space="preserve">
          <source>This module implements color handling for Nim.</source>
          <target state="translated">该模块实现了Nim的颜色处理。</target>
        </trans-unit>
        <trans-unit id="5bb52bf0d87731597af09d97960c22d019bf58d4" translate="yes" xml:space="preserve">
          <source>This module implements color handling for Nim. It is used by the &lt;code&gt;graphics&lt;/code&gt; module.</source>
          <target state="translated">此模块为Nim实现颜色处理。 &lt;code&gt;graphics&lt;/code&gt; 模块使用它。</target>
        </trans-unit>
        <trans-unit id="7b8921996b5c256e40c5e6c977e3725a0386307f" translate="yes" xml:space="preserve">
          <source>This module implements common simple lowerings.</source>
          <target state="translated">该模块实现了常见的简单降低。</target>
        </trans-unit>
        <trans-unit id="7729efb631e2eb7bcfa9fd3c15327853bf181948" translate="yes" xml:space="preserve">
          <source>This module implements complex numbers.</source>
          <target state="translated">该模块实现了复数。</target>
        </trans-unit>
        <trans-unit id="aeaf9342dd5833ed552b5a2102d34b6d6ec873cf" translate="yes" xml:space="preserve">
          <source>This module implements complex numbers. Complex numbers are currently implemented as generic on a 64-bit or 32-bit float.</source>
          <target state="translated">这个模块实现了复数。复数目前是在64位或32位的浮点数上实现的通用数。</target>
        </trans-unit>
        <trans-unit id="42fb167dafb36722d30f92f4593ecfc130a3dae2" translate="yes" xml:space="preserve">
          <source>This module implements efficient computations of hash values for diverse Nim types. All the procs are based on these two building blocks:</source>
          <target state="translated">这个模块实现了对不同Nim类型的哈希值的高效计算。所有的程序都是基于这两个构件。</target>
        </trans-unit>
        <trans-unit id="94a7c29bf4d442270eb47c16d094dbac2bb71a71" translate="yes" xml:space="preserve">
          <source>This module implements helper procs for CGI applications. Example:</source>
          <target state="translated">该模块实现了CGI应用程序的辅助程序。例子:本模块实现了CGI应用程序的辅助程序。</target>
        </trans-unit>
        <trans-unit id="06e4f877dc2f02ff6d7623b1d21e1442d6e6e0aa" translate="yes" xml:space="preserve">
          <source>This module implements helper procs for SCGI applications. Example:</source>
          <target state="translated">该模块实现了SCGI应用程序的帮助程序。例子:</target>
        </trans-unit>
        <trans-unit id="00f7e73405ca98ef55459bd8cb137c930c54ce67" translate="yes" xml:space="preserve">
          <source>This module implements helper procs for parsing Cookies.</source>
          <target state="translated">该模块实现了解析Cookies的辅助程序。</target>
        </trans-unit>
        <trans-unit id="0d7dad71176a5274e0ff15c36d8d42475024e144" translate="yes" xml:space="preserve">
          <source>This module implements helpers for the macro cache.</source>
          <target state="translated">该模块实现了宏缓存的帮助程序。</target>
        </trans-unit>
        <trans-unit id="6b7aa9306839a9e2f1eb10857736527eb56ecd2a" translate="yes" xml:space="preserve">
          <source>This module implements lifting for type-bound operations (&lt;code&gt;=sink&lt;/code&gt;, &lt;code&gt;=&lt;/code&gt;, &lt;code&gt;=destroy&lt;/code&gt;, &lt;code&gt;=deepCopy&lt;/code&gt;).</source>
          <target state="translated">此模块为类型绑定操作（ &lt;code&gt;=sink&lt;/code&gt; ， &lt;code&gt;=&lt;/code&gt; ， &lt;code&gt;=destroy&lt;/code&gt; ， &lt;code&gt;=deepCopy&lt;/code&gt; ）实现提升。</target>
        </trans-unit>
        <trans-unit id="5aa51e0bbdd73802dae08d36a67835190e007e6d" translate="yes" xml:space="preserve">
          <source>This module implements nice syntactic sugar based on Nim's macro system.</source>
          <target state="translated">这个模块基于Nim的宏系统实现了不错的语法糖。</target>
        </trans-unit>
        <trans-unit id="605fb43c6c6ebd7d6234f48fb476d48d8bab0b46" translate="yes" xml:space="preserve">
          <source>This module implements operations for the built-in &lt;span id=&quot;seq_1&quot;&gt;seq&lt;/span&gt; type which were inspired by functional programming languages.</source>
          <target state="translated">此模块实现了受功能编程语言启发的内置&lt;span id=&quot;seq_1&quot;&gt;seq&lt;/span&gt;类型的操作。</target>
        </trans-unit>
        <trans-unit id="03602f44dc99d2a2f1feb228793b9d5dc7bd7cfd" translate="yes" xml:space="preserve">
          <source>This module implements portable sockets, it supports a mix of different types of sockets. Sockets are buffered by default meaning that data will be received in &lt;code&gt;BufferSize&lt;/code&gt; (4000) sized chunks, buffering behaviour can be disabled by setting the &lt;code&gt;buffered&lt;/code&gt; parameter when calling the &lt;code&gt;socket&lt;/code&gt; function to &lt;em&gt;false&lt;/em&gt;. Be aware that some functions may not yet support buffered sockets (mainly the recvFrom function).</source>
          <target state="translated">该模块实现了便携式插座，它支持多种不同类型的插座。默认情况下，套接字是缓冲的，这意味着将以 &lt;code&gt;BufferSize&lt;/code&gt; （4000）大小的块接收数据，可以通过在将 &lt;code&gt;socket&lt;/code&gt; 函数设置为&lt;em&gt;false&lt;/em&gt;时设置 &lt;code&gt;buffered&lt;/code&gt; 参数来禁用缓冲行为。请注意，某些功能可能尚不支持缓冲套接字（主要是recvFrom函数）。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1e03448c70f64476d8a1af87251f0850a190b56c" translate="yes" xml:space="preserve">
          <source>This module implements procs to determine the number of CPUs / cores.</source>
          <target state="translated">该模块实现了确定CPU/核数的程序。</target>
        </trans-unit>
        <trans-unit id="75d697bfa5c4fe5f66a9e6c4166274beadef8e27" translate="yes" xml:space="preserve">
          <source>This module implements rational numbers, consisting of a numerator &lt;code&gt;num&lt;/code&gt; and a denominator &lt;code&gt;den&lt;/code&gt;, both of type int. The denominator can not be 0.</source>
          <target state="translated">此模块实现有理数，它们由int类型的分子 &lt;code&gt;num&lt;/code&gt; 和分母 &lt;code&gt;den&lt;/code&gt; 组成。分母不能为0。</target>
        </trans-unit>
        <trans-unit id="4b020312c18d7f1e3e79c3c6ff8a468feda67a72" translate="yes" xml:space="preserve">
          <source>This module implements rational numbers, consisting of a numerator &lt;em&gt;num&lt;/em&gt; and a denominator &lt;em&gt;den&lt;/em&gt;, both of type int. The denominator can not be 0.</source>
          <target state="translated">此模块实现有理数，它们由分子&lt;em&gt;num&lt;/em&gt;和分母&lt;em&gt;den组成&lt;/em&gt;，均为整数类型。分母不能为0。</target>
        </trans-unit>
        <trans-unit id="5cf5cab5d8bf4f6c2215c0c3d51c3ca1a3596a21" translate="yes" xml:space="preserve">
          <source>This module implements semantic checking for calls.this module does the semantic checking of statementsThis module does the semantic transformation of the fields* iterators.This module implements Nim's object construction rules.</source>
          <target state="translated">这个模块实现了对调用的语义检查.这个模块做了语句的语义检查这个模块做了字段*迭代器的语义转换.这个模块实现了Nim的对象构造规则。</target>
        </trans-unit>
        <trans-unit id="88fdbdda66a11d9e4dcd5f67ececbd1313751a08" translate="yes" xml:space="preserve">
          <source>This module implements some common generic algorithms.</source>
          <target state="translated">本模块实现了一些常见的通用算法。</target>
        </trans-unit>
        <trans-unit id="15596de96df6a5d16f5a2c6304d05b802e3f3dd2" translate="yes" xml:space="preserve">
          <source>This module implements stream wrapper.</source>
          <target state="translated">该模块实现了流包装器。</target>
        </trans-unit>
        <trans-unit id="b6360fdb1a0d14929ad9c3c0a54011a7ceeb73b7" translate="yes" xml:space="preserve">
          <source>This module implements the '.liftLocals' pragma.</source>
          <target state="translated">这个模块实现了'.liftLocals'pragma。</target>
        </trans-unit>
        <trans-unit id="e11c7939e3afe546c05d00ad6b841be9456fe883" translate="yes" xml:space="preserve">
          <source>This module implements the 'implies' relation for guards.</source>
          <target state="translated">这个模块实现了警卫的 &quot;暗示 &quot;关系。</target>
        </trans-unit>
        <trans-unit id="324900edca6f658b4339cf4b65eb81ff95b693e9" translate="yes" xml:space="preserve">
          <source>This module implements the C code generator.This include file contains the logic to produce constant string and seq literals. The code here is responsible that &lt;code&gt;const x = [&quot;a&quot;, &quot;b&quot;]&lt;/code&gt; works without hidden runtime creation code. The price is that seqs and strings are not purely a library implementation.Generates traversal procs for the C backend.Code specialization instead of the old, incredibly slow 'genericReset' implementation.Thread var support for crappy architectures that lack native support for thread local storage. (&lt;strong&gt;Thank you Mac OS X!&lt;/strong&gt;)</source>
          <target state="translated">这个模块实现了C代码生成器，这个包含文件包含了产生常量字符串和seq文字的逻辑。此处的代码负责 &lt;code&gt;const x = [&quot;a&quot;, &quot;b&quot;]&lt;/code&gt; 运行而无需隐藏的运行时创建代码。代价是seqs和字符串不是纯粹的库实现。为C后端生成遍历proc。代码专业化而不是旧的，令人难以置信的缓慢的'genericReset'实现。 。（&lt;strong&gt;谢谢Mac OS X！&lt;/strong&gt;）</target>
        </trans-unit>
        <trans-unit id="5033575ad43160cfe00aa6032cd8e72c2229f7f9" translate="yes" xml:space="preserve">
          <source>This module implements the SMTP client protocol as specified by RFC 5321, this can be used to send mail to any SMTP Server.</source>
          <target state="translated">该模块实现了RFC 5321指定的SMTP客户端协议,可用于向任何SMTP服务器发送邮件。</target>
        </trans-unit>
        <trans-unit id="0a6a93e5b19faa7bc126c3e2fc94d788bde65745" translate="yes" xml:space="preserve">
          <source>This module implements the ability to access symbols from shared libraries. On POSIX this uses the &lt;code&gt;dlsym&lt;/code&gt; mechanism, on Windows &lt;code&gt;LoadLibrary&lt;/code&gt;.</source>
          <target state="translated">该模块实现了从共享库访问符号的功能。在POSIX上，此方法在Windows &lt;code&gt;LoadLibrary&lt;/code&gt; 上使用 &lt;code&gt;dlsym&lt;/code&gt; 机制。</target>
        </trans-unit>
        <trans-unit id="a3873bd4d455f4aaaae3cbab2055aa96d93f86ba" translate="yes" xml:space="preserve">
          <source>This module implements the basics for Linux distribution (&quot;distro&quot;) detection and the OS's native package manager. Its primary purpose is to produce output for Nimble packages like:</source>
          <target state="translated">这个模块实现了Linux发行版(&quot;distro&quot;)检测和操作系统本地包管理器的基本功能。它的主要目的是为Nimble包产生输出,如:。</target>
        </trans-unit>
        <trans-unit id="a0923959ce15bcdc564ea4a58b3ac4fecf2023c6" translate="yes" xml:space="preserve">
          <source>This module implements the canonalization for the various caching mechanisms.</source>
          <target state="translated">该模块实现了各种缓存机制的加农化。</target>
        </trans-unit>
        <trans-unit id="b07a4bf44a78d1d257e8619bf8a77573a5a9c90b" translate="yes" xml:space="preserve">
          <source>This module implements the code generator for the VM.</source>
          <target state="translated">该模块实现了虚拟机的代码生成器。</target>
        </trans-unit>
        <trans-unit id="7a38d94bda812e8dfd26d5856d7d5a0ebec8243b" translate="yes" xml:space="preserve">
          <source>This module implements the generation of &lt;code&gt;.ndi&lt;/code&gt; files for better debugging support of Nim code. &quot;ndi&quot; stands for &quot;Nim debug info&quot;.</source>
          <target state="translated">该模块实现了 &lt;code&gt;.ndi&lt;/code&gt; 文件的生成，以更好地支持Nim代码的调试。&amp;ldquo; ndi&amp;rdquo;代表&amp;ldquo; Nim调试信息&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="b6156a97839b4290df6ebce6deed6bed5a01d783" translate="yes" xml:space="preserve">
          <source>This module implements the merge operation of 2 different C files. This is needed for incremental compilation.</source>
          <target state="translated">该模块实现了2个不同C文件的合并操作。这是增量编译所需要的。</target>
        </trans-unit>
        <trans-unit id="d10dd027360f5be6d220e9a48b8828a68cc03c43" translate="yes" xml:space="preserve">
          <source>This module implements the module graph data structure. The module graph represents a complete Nim project. Single modules can either be kept in RAM or stored in a Sqlite database.</source>
          <target state="translated">该模块实现了模块图数据结构。模块图代表一个完整的Nim项目。单个模块既可以保存在RAM中,也可以保存在Sqlite数据库中。</target>
        </trans-unit>
        <trans-unit id="870290fb4763d9ca97f463a24d11a0f61a137a38" translate="yes" xml:space="preserve">
          <source>This module implements the passes functionality. A pass must implement the &lt;code&gt;TPass&lt;/code&gt; interface.</source>
          <target state="translated">此模块实现通行证功能。通行证必须实现 &lt;code&gt;TPass&lt;/code&gt; 接口。</target>
        </trans-unit>
        <trans-unit id="5fcd3512a3ab958ff6ee67f05599b41b02ebd9df" translate="yes" xml:space="preserve">
          <source>This module implements the pattern matching features for term rewriting macro support.</source>
          <target state="translated">该模块实现了模式匹配功能,用于术语改写宏支持。</target>
        </trans-unit>
        <trans-unit id="70367e3386c4a0bfa37a82d45a19f9a7ed417f54" translate="yes" xml:space="preserve">
          <source>This module implements the signature matching for resolving the call to overloaded procs, generic procs and operators.</source>
          <target state="translated">该模块实现了用于解析重载procs、通用procs和操作符调用的签名匹配。</target>
        </trans-unit>
        <trans-unit id="2b7af9f244bfd95dc4b59560e53168beb2ea1039" translate="yes" xml:space="preserve">
          <source>This module implements the style checker.</source>
          <target state="translated">该模块实现了样式检查器。</target>
        </trans-unit>
        <trans-unit id="bf87db50efeea8af15f9c9cb3ade6f25c05a723d" translate="yes" xml:space="preserve">
          <source>This module implements the symbol importing mechanism.</source>
          <target state="translated">该模块实现了符号导入机制。</target>
        </trans-unit>
        <trans-unit id="eb5c7b7b5304374db892e2c02470b732730375fb" translate="yes" xml:space="preserve">
          <source>This module implements threadpool's &lt;code&gt;spawn&lt;/code&gt;.</source>
          <target state="translated">该模块实现线程池的 &lt;code&gt;spawn&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="15b881f434ad53307745d9873f33cc83cdf48e46" translate="yes" xml:space="preserve">
          <source>This module implements types and macros for writing asynchronous code for the JS backend. It provides tools for interaction with JavaScript async API-s and libraries, writing async procedures in Nim and converting callback-based code to promises.</source>
          <target state="translated">该模块实现了为JS后端编写异步代码的类型和宏,它提供了与JavaScript异步API和库交互的工具,在Nim中编写异步过程,并将基于回调的代码转换为承诺。它提供了与JavaScript异步API和库交互的工具,在Nim中编写异步过程,并将基于回调的代码转换为承诺。</target>
        </trans-unit>
        <trans-unit id="96a223a86302396be5588794d00dcc5a992fb05a" translate="yes" xml:space="preserve">
          <source>This module implements types which encapsulate an optional value.</source>
          <target state="translated">本模块实现了封装可选值的类型。</target>
        </trans-unit>
        <trans-unit id="8b05223d9ca6772d764f5fcaadb7295f47ed88d6" translate="yes" xml:space="preserve">
          <source>This module is a sample.</source>
          <target state="translated">这个模块是一个样本。</target>
        </trans-unit>
        <trans-unit id="a2a203baf067681d5e0468d7220606f23e9f491a" translate="yes" xml:space="preserve">
          <source>This module is also compatible with other backends: &lt;code&gt;Javascript&lt;/code&gt;, &lt;code&gt;Nimscript&lt;/code&gt; as well as the &lt;code&gt;compiletime VM&lt;/code&gt;.</source>
          <target state="translated">该模块还与其他后端兼容： &lt;code&gt;Javascript&lt;/code&gt; ， &lt;code&gt;Nimscript&lt;/code&gt; 以及 &lt;code&gt;compiletime VM&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f3531490dbe3e2f25dede9c41e4fcef79b629cad" translate="yes" xml:space="preserve">
          <source>This module is available for the &lt;a href=&quot;backends#backends-the-javascript-target&quot;&gt;JavaScript target&lt;/a&gt;.</source>
          <target state="translated">该模块可用于&lt;a href=&quot;backends#backends-the-javascript-target&quot;&gt;JavaScript目标&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="99ac486e597f76fa9f3aeade5377d8139863cf06" translate="yes" xml:space="preserve">
          <source>This module is based on Python's Unidecode module by Tomaz Solc, which in turn is based on the &lt;code&gt;Text::Unidecode&lt;/code&gt; Perl module by Sean M. Burke (&lt;a href=&quot;http://search.cpan.org/~sburke/Text-Unidecode-0.04/lib/Text/Unidecode.pm&quot;&gt;http://search.cpan.org/~sburke/Text-Unidecode-0.04/lib/Text/Unidecode.pm&lt;/a&gt; ).</source>
          <target state="translated">该模块基于Tomaz Solc的Python的Unidecode模块，而该模块又基于Sean M. Burke的 &lt;code&gt;Text::Unidecode&lt;/code&gt; Perl模块（&lt;a href=&quot;http://search.cpan.org/~sburke/Text-Unidecode-0.04/lib/Text/Unidecode.pm&quot;&gt;http://search.cpan.org/~sburke/Text-Unidecode-0.04/ lib / Text / Unidecode.pm&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="12453f55babdb4a27c1f7e732c0c542926e9cbdc" translate="yes" xml:space="preserve">
          <source>This module is experimental and its interface may change.</source>
          <target state="translated">这个模块是实验性的,它的界面可能会改变。</target>
        </trans-unit>
        <trans-unit id="bcaffb7c268575c15a197b066d88f31f66ee5014" translate="yes" xml:space="preserve">
          <source>This module is for compiler internal use only. For reliable error messages and range checks, the compiler needs a data type that can hold all from &lt;code&gt;low(BiggestInt)&lt;/code&gt; to &lt;code&gt;high(BiggestUInt)&lt;/code&gt;, This type is for that purpose.</source>
          <target state="translated">该模块仅供编译器内部使用。为了获得可靠的错误消息和范围检查，编译器需要一个数据类型，该数据类型可以容纳从 &lt;code&gt;low(BiggestInt)&lt;/code&gt; 到 &lt;code&gt;high(BiggestUInt)&lt;/code&gt; 的所有数据，此类型用于该目的。</target>
        </trans-unit>
        <trans-unit id="c5689b667695647b8ab8ef22840d0cdf1b5bb67f" translate="yes" xml:space="preserve">
          <source>This module is implemented by providing a wrapper around the &lt;a href=&quot;http://www.pcre.org&quot;&gt;PCRE (Perl-Compatible Regular Expressions)&lt;/a&gt; C library. This means that your application will depend on the PCRE library's licence when using this module, which should not be a problem though. PCRE's licence follows:</source>
          <target state="translated">通过围绕&lt;a href=&quot;http://www.pcre.org&quot;&gt;PCRE（与Perl兼容的正则表达式）&lt;/a&gt; C库提供包装器来实现此模块。这意味着您的应用程序在使用此模块时将取决于PCRE库的许可证，但这应该不是问题。PCRE的许可证如下：</target>
        </trans-unit>
        <trans-unit id="edd45a27ac656172236276c240c2474c18a6f78e" translate="yes" xml:space="preserve">
          <source>This module needs the data file &quot;unidecode.dat&quot; to work: This file is embedded as a resource into your application by default. But you an also define the symbol &lt;code&gt;--define:noUnidecodeTable&lt;/code&gt; during compile time and use the &lt;code&gt;loadUnidecodeTable&lt;/code&gt; proc to initialize this module.</source>
          <target state="translated">该模块需要数据文件&amp;ldquo; unidecode.dat&amp;rdquo;起作用：默认情况下，该文件作为资源嵌入到您的应用程序中。但是您也可以在编译期间定义符号 &lt;code&gt;--define:noUnidecodeTable&lt;/code&gt; ，并使用 &lt;code&gt;loadUnidecodeTable&lt;/code&gt; proc初始化此模块。</target>
        </trans-unit>
        <trans-unit id="22fccb6a29ddaf211868c4b8302f35490b759841" translate="yes" xml:space="preserve">
          <source>This module offers implementations of common binary operations like &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;/&lt;/code&gt; and comparison operations, which work for mixed float/int operands. All operations convert the integer operand into the type of the float operand. For numerical expressions, the return type is always the type of the float involved in the expression, i.e., there is no auto conversion from float32 to float64.</source>
          <target state="translated">该模块提供了常见的二进制操作（例如 &lt;code&gt;+&lt;/code&gt; ， &lt;code&gt;-&lt;/code&gt; ， &lt;code&gt;*&lt;/code&gt; 和 &lt;code&gt;/&lt;/code&gt; )的实现，这些操作适用于混合的float / int操作数。所有操作都将整数操作数转换为浮点操作数的类型。对于数字表达式，返回类型始终是表达式中涉及的float的类型，即，没有从float32到float64的自动转换。</target>
        </trans-unit>
        <trans-unit id="cda1d94b3b5a9dcfb70f16a91a3ec170b750b323" translate="yes" xml:space="preserve">
          <source>This module offers implementations of common binary operations like &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;/&lt;/code&gt; and comparison operations, which work for mixed float/int operands. All operations convert the integer operand into the type of the float operand. For numerical expressions, the return type is always the type of the float involved in the expresssion, i.e., there is no auto conversion from float32 to float64.</source>
          <target state="translated">该模块提供了常见的二进制操作（例如 &lt;code&gt;+&lt;/code&gt; ， &lt;code&gt;-&lt;/code&gt; ， &lt;code&gt;*&lt;/code&gt; 和 &lt;code&gt;/&lt;/code&gt; )的实现，这些操作适用于混合的float / int操作数。所有操作都将整数操作数转换为浮点操作数的类型。对于数字表达式，返回类型始终是表达式中涉及的float的类型，即，没有从float32到float64的自动转换。</target>
        </trans-unit>
        <trans-unit id="f3267cc83830f712bb14c086f0878bf139791739" translate="yes" xml:space="preserve">
          <source>This module only exists to generate docs for the compiler.</source>
          <target state="translated">这个模块只存在于为编译器生成文档。</target>
        </trans-unit>
        <trans-unit id="7396f239f24da0a4e4690ab1044ff64d650f1306" translate="yes" xml:space="preserve">
          <source>This module parses a XML Document into a XML DOM Document representation.</source>
          <target state="translated">该模块将一个XML文档解析成一个XML DOM文档表示。</target>
        </trans-unit>
        <trans-unit id="a9bcdabb8e24bc9cc089f0f13411ad03a03519bc" translate="yes" xml:space="preserve">
          <source>This module parses an HTML document and creates its XML tree representation. It is supposed to handle the &lt;em&gt;wild&lt;/em&gt; HTML the real world uses.</source>
          <target state="translated">该模块解析HTML文档并创建其XML树表示形式。它应该处理现实世界使用的&lt;em&gt;狂野&lt;/em&gt; HTML。</target>
        </trans-unit>
        <trans-unit id="6cd96ee218d8bf4a40ad0320da8cac9d72214020" translate="yes" xml:space="preserve">
          <source>This module parses an XML document and creates its XML tree representation.</source>
          <target state="translated">该模块解析XML文档并创建其XML树表示。</target>
        </trans-unit>
        <trans-unit id="9092d7288554b84b5306c5e4d5f8c8a0d7f59d2c" translate="yes" xml:space="preserve">
          <source>This module provides a stream interface and two implementations thereof: the &lt;a href=&quot;#FileStream&quot;&gt;FileStream&lt;/a&gt; and the &lt;a href=&quot;#StringStream&quot;&gt;StringStream&lt;/a&gt; which implement the stream interface for Nim file objects (&lt;code&gt;File&lt;/code&gt;) and strings.</source>
          <target state="translated">此模块提供流接口及其两种实现：&lt;a href=&quot;#FileStream&quot;&gt;FileStream&lt;/a&gt;和&lt;a href=&quot;#StringStream&quot;&gt;StringStream&lt;/a&gt;，它们实现Nim文件对象（ &lt;code&gt;File&lt;/code&gt; ）和字符串的流接口。</target>
        </trans-unit>
        <trans-unit id="9a07c876b6cd8245c5dfacca935fec67d4db93ff" translate="yes" xml:space="preserve">
          <source>This module provides a stream interface and two implementations thereof: the &lt;em&gt;FileStream&lt;/em&gt; and the &lt;em&gt;StringStream&lt;/em&gt; which implement the stream interface for Nim file objects (&lt;em&gt;File&lt;/em&gt;) and strings. Other modules may provide other implementations for this standard stream interface.</source>
          <target state="translated">该模块提供了一个流接口及其两种实现：&lt;em&gt;FileStream&lt;/em&gt;和&lt;em&gt;StringStream&lt;/em&gt;，它们实现了Nim文件对象（&lt;em&gt;File&lt;/em&gt;）和字符串的流接口。其他模块可以为此标准流接口提供其他实现。</target>
        </trans-unit>
        <trans-unit id="4ab8f9a52d2829796af73473cde494f332d9e364" translate="yes" xml:space="preserve">
          <source>This module provides an easy to use sockets-style nim interface to the OpenSSL library.</source>
          <target state="translated">该模块为OpenSSL库提供了一个易于使用的套接字风格的nim接口。</target>
        </trans-unit>
        <trans-unit id="49dbd9ba77d32ac31376544311a3b10bed584209" translate="yes" xml:space="preserve">
          <source>This module provides both a synchronous and asynchronous implementation. The asynchronous implementation requires you to use the &lt;code&gt;asyncFTPClient&lt;/code&gt; function. You are then required to register the &lt;code&gt;AsyncFTPClient&lt;/code&gt; with a asyncio dispatcher using the &lt;code&gt;register&lt;/code&gt; function. Take a look at the asyncio module documentation for more information.</source>
          <target state="translated">该模块提供同步和异步实现。异步实现要求您使用 &lt;code&gt;asyncFTPClient&lt;/code&gt; 函数。然后，您需要注册 &lt;code&gt;AsyncFTPClient&lt;/code&gt; 使用的一个ASYNCIO调度 &lt;code&gt;register&lt;/code&gt; 功能。查看asyncio模块文档以获取更多信息。</target>
        </trans-unit>
        <trans-unit id="ce590e4e5a122965a43db23fbb2cb01e20c16510" translate="yes" xml:space="preserve">
          <source>This module provides support for &lt;span id=&quot;memory-mapped-files_1&quot;&gt;memory mapped files&lt;/span&gt; (Posix's &lt;span id=&quot;mmap_1&quot;&gt;mmap&lt;/span&gt;) on the different operating systems.</source>
          <target state="translated">该模块支持不同操作系统上的&lt;span id=&quot;memory-mapped-files_1&quot;&gt;内存映射文件&lt;/span&gt;（Posix的&lt;span id=&quot;mmap_1&quot;&gt;mmap&lt;/span&gt;）。</target>
        </trans-unit>
        <trans-unit id="65c4c619ae2b38e38065fa4fe9a46d6bc185ed6a" translate="yes" xml:space="preserve">
          <source>This module provides support to handle the Unicode UTF-8 encoding.</source>
          <target state="translated">该模块提供了处理Unicode UTF-8编码的支持。</target>
        </trans-unit>
        <trans-unit id="f60f9e4146057e2aadde33d2726a83b70d00ccbc" translate="yes" xml:space="preserve">
          <source>This module provides the standard Nim command line parser. It supports one convenience iterator over all command line options and some lower-level features.</source>
          <target state="translated">该模块提供了标准的Nim命令行解析器。它支持一个方便的迭代器,覆盖所有命令行选项和一些低级功能。</target>
        </trans-unit>
        <trans-unit id="be630a10c2306e1da8b699aa549bd1507ce73a7f" translate="yes" xml:space="preserve">
          <source>This module supports helper routines for working with &lt;code&gt;cstring&lt;/code&gt; without having to convert &lt;code&gt;cstring&lt;/code&gt; to &lt;code&gt;string&lt;/code&gt; in order to save allocations.</source>
          <target state="translated">该模块支持使用 &lt;code&gt;cstring&lt;/code&gt; 的帮助程序例程，而不必将 &lt;code&gt;cstring&lt;/code&gt; 转换为 &lt;code&gt;string&lt;/code&gt; 以节省分配。</target>
        </trans-unit>
        <trans-unit id="5a7ff45a67a6ab46e7d1fb35b3306305d6ba07fa" translate="yes" xml:space="preserve">
          <source>This module wraps core JavaScript functions.</source>
          <target state="translated">该模块封装了JavaScript的核心功能。</target>
        </trans-unit>
        <trans-unit id="0f7196bd18c3887a77199794d0417e3686fb88b6" translate="yes" xml:space="preserve">
          <source>This modules registers a signal handler that turns access violations / segfaults into a &lt;code&gt;NilAccessDefect&lt;/code&gt; exception. To be able to catch a NilAccessDefect all you have to do is to import this module.</source>
          <target state="translated">此模块注册一个信号处理程序，该处理程序将访问冲突/ segfaults转换为 &lt;code&gt;NilAccessDefect&lt;/code&gt; 异常。为了能够捕获到NilAccessDefect，您所需要做的就是导入此模块。</target>
        </trans-unit>
        <trans-unit id="5b840bfc815d3caad906fc572e9454af313da4d0" translate="yes" xml:space="preserve">
          <source>This modules registers a signal handler that turns access violations / segfaults into a &lt;code&gt;NilAccessError&lt;/code&gt; exception. To be able to catch a NilAccessError all you have to do is to import this module.</source>
          <target state="translated">此模块注册一个信号处理程序，该处理程序将访问冲突/ segfaults转换为 &lt;code&gt;NilAccessError&lt;/code&gt; 异常。为了捕获NilAccessError，您要做的就是导入此模块。</target>
        </trans-unit>
        <trans-unit id="fee1833b4c51904885c4305b4d12a4e1e8ea0e21" translate="yes" xml:space="preserve">
          <source>This most often useful for constructing sequences with the array constructor: &lt;code&gt;@[1, 2, 3]&lt;/code&gt; has the type &lt;code&gt;seq[int]&lt;/code&gt;, while &lt;code&gt;[1, 2, 3]&lt;/code&gt; has the type &lt;code&gt;array[0..2, int]&lt;/code&gt;.</source>
          <target state="translated">这对于使用数组构造函数构造序列最有用： &lt;code&gt;@[1, 2, 3]&lt;/code&gt; 的类型为 &lt;code&gt;seq[int]&lt;/code&gt; ，而 &lt;code&gt;[1, 2, 3]&lt;/code&gt; 的类型的类型为 &lt;code&gt;array[0..2, int]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6390ea355bcccac1df3928830a46c0fa9200368c" translate="yes" xml:space="preserve">
          <source>This must be called on an unconnected socket; an SSL session will be started when the socket is connected.</source>
          <target state="translated">这必须在未连接的套接字上调用;当套接字被连接时,SSL会话将被启动。</target>
        </trans-unit>
        <trans-unit id="0dc417a03ed217016727b05e73fb23e9635c5936" translate="yes" xml:space="preserve">
          <source>This needs to be called to set &lt;code&gt;x&lt;/code&gt;'s runtime object type field.</source>
          <target state="translated">需要调用它来设置 &lt;code&gt;x&lt;/code&gt; 的运行时对象类型字段。</target>
        </trans-unit>
        <trans-unit id="e08443e3f06cf9773785c99d4ad98608f4e9eebf" translate="yes" xml:space="preserve">
          <source>This operator computes the difference of two sets.</source>
          <target state="translated">这个运算符计算两个集合的差。</target>
        </trans-unit>
        <trans-unit id="f79ed7bc0326a97f82d04a96b028c6113002f150" translate="yes" xml:space="preserve">
          <source>This operator computes the intersection of two sets.</source>
          <target state="translated">这个运算符计算两个集合的交点。</target>
        </trans-unit>
        <trans-unit id="9a4b0639403e85faa9616f997f6d194f55eeab89" translate="yes" xml:space="preserve">
          <source>This operator computes the union of two sets.</source>
          <target state="translated">这个运算符计算两个集合的结合。</target>
        </trans-unit>
        <trans-unit id="b046c8a4096963070b190a5e641fbd439e8358a7" translate="yes" xml:space="preserve">
          <source>This operator is the assignment operator. Note that in the contexts &lt;code&gt;result = expr&lt;/code&gt;, &lt;code&gt;parameter = defaultValue&lt;/code&gt; or for parameter passing no assignment is performed. For a type &lt;code&gt;T&lt;/code&gt; that has an overloaded assignment operator &lt;code&gt;var v = T()&lt;/code&gt; is rewritten to &lt;code&gt;var v: T; v = T()&lt;/code&gt;; in other words &lt;code&gt;var&lt;/code&gt; and &lt;code&gt;let&lt;/code&gt; contexts do count as assignments.</source>
          <target state="translated">该运算符是赋值运算符。请注意，在 &lt;code&gt;result = expr&lt;/code&gt; ， &lt;code&gt;parameter = defaultValue&lt;/code&gt; 的上下文中，或者对于参数传递，不执行任何赋值。对于具有重载赋值运算符的类型 &lt;code&gt;T&lt;/code&gt; ，将 &lt;code&gt;var v = T()&lt;/code&gt; 重写为 &lt;code&gt;var v: T; v = T()&lt;/code&gt; ; 换句话说， &lt;code&gt;var&lt;/code&gt; 和 &lt;code&gt;let&lt;/code&gt; 上下文确实算作分配。</target>
        </trans-unit>
        <trans-unit id="c815aa40abb9bedda70e19c6d2ad3999d74da028" translate="yes" xml:space="preserve">
          <source>This operator will be matched against assignments to missing fields.</source>
          <target state="translated">该运算符将与缺失字段的赋值相匹配。</target>
        </trans-unit>
        <trans-unit id="877c6b770d02ce2daf96f01b490c8ab96ed58851" translate="yes" xml:space="preserve">
          <source>This operator will be matched against both field accesses and method calls.</source>
          <target state="translated">该操作符将与字段访问和方法调用相匹配。</target>
        </trans-unit>
        <trans-unit id="8eb5171b4785a372e6e7687e57e17ace11b78ea3" translate="yes" xml:space="preserve">
          <source>This operator will be matched exclusively against method calls. It has higher precedence than the &lt;code&gt;.&lt;/code&gt; operator and this allows one to handle expressions like &lt;code&gt;x.y&lt;/code&gt; and &lt;code&gt;x.y()&lt;/code&gt; differently if one is interfacing with a scripting language for example.</source>
          <target state="translated">该运算符将专门与方法调用匹配。它具有比更高的优先级 &lt;code&gt;.&lt;/code&gt; 运算符，例如，如果它与脚本语言接口，则允许以不同的方式处理 &lt;code&gt;x.y&lt;/code&gt; 和 &lt;code&gt;x.y()&lt;/code&gt; 这样的表达式。</target>
        </trans-unit>
        <trans-unit id="99c71fe5d49c4e442130e8d4e9b6e7107de926b7" translate="yes" xml:space="preserve">
          <source>This operator will be matched exclusively against method calls. It has higher precedence than the &lt;em&gt;.&lt;/em&gt; operator and this allows one to handle expressions like &lt;em&gt;x.y&lt;/em&gt; and &lt;em&gt;x.y()&lt;/em&gt; differently if one is interfacing with a scripting language for example.</source>
          <target state="translated">该运算符将专门与方法调用匹配。它具有比更高的优先级&lt;em&gt;。&lt;/em&gt;运算符，例如，如果与脚本语言接口，则允许以不同的方式处理&lt;em&gt;xy&lt;/em&gt;和&lt;em&gt;xy（）&lt;/em&gt;等表达式。</target>
        </trans-unit>
        <trans-unit id="fdce8c1c9dd850ca032055512e1bd9d5a06936f2" translate="yes" xml:space="preserve">
          <source>This page provide hints on distributing Nim using OS packages.</source>
          <target state="translated">本页提供了使用操作系统软件包发布Nim的提示。</target>
        </trans-unit>
        <trans-unit id="c195c31e5829f87707abb98358a691d8131229a7" translate="yes" xml:space="preserve">
          <source>This passes the expression &lt;code&gt;x + y * z - x&lt;/code&gt; to the &lt;code&gt;optM&lt;/code&gt; macro as an &lt;code&gt;nnkArgList&lt;/code&gt; node containing:</source>
          <target state="translated">这会将表达式 &lt;code&gt;x + y * z - x&lt;/code&gt; 作为 &lt;code&gt;nnkArgList&lt;/code&gt; 节点传递给 &lt;code&gt;optM&lt;/code&gt; 宏，该节点包含：</target>
        </trans-unit>
        <trans-unit id="779a96266029c48032a8abc57497d759ae90622e" translate="yes" xml:space="preserve">
          <source>This pragma can also take in an optional warning string to relay to developers.</source>
          <target state="translated">这个pragma也可以接受一个可选的警告字符串来传递给开发者。</target>
        </trans-unit>
        <trans-unit id="b75ce5f723cf09cb35bbfecf4010bd348d284353" translate="yes" xml:space="preserve">
          <source>This pragma has no effect on the JS backend.</source>
          <target state="translated">这个pragma对JS后台没有影响。</target>
        </trans-unit>
        <trans-unit id="b2bac99517eec01add92d42595b9d17d1a79dbd9" translate="yes" xml:space="preserve">
          <source>This proc adds the necessary Content-Length header.</source>
          <target state="translated">本程序添加必要的Content-Length头。</target>
        </trans-unit>
        <trans-unit id="7b6638b54fd693beeb9b92d654723a7cc066942f" translate="yes" xml:space="preserve">
          <source>This proc also handles redirection</source>
          <target state="translated">这个过程也处理重定向</target>
        </trans-unit>
        <trans-unit id="bec96c78d9187ae27072063a2599e2d8041f75b3" translate="yes" xml:space="preserve">
          <source>This proc also handles redirection.</source>
          <target state="translated">这个过程也处理重定向。</target>
        </trans-unit>
        <trans-unit id="17bc78789836f23c301ac5b842a1060d7a4db4c3" translate="yes" xml:space="preserve">
          <source>This proc behaves the same as the &lt;code&gt;%&lt;/code&gt; operator in Python.</source>
          <target state="translated">此proc的行为与Python中的 &lt;code&gt;%&lt;/code&gt; 运算符相同。</target>
        </trans-unit>
        <trans-unit id="3938ad51042cbaba9e98c935176fa62ab2de2077" translate="yes" xml:space="preserve">
          <source>This proc can be used to create tree structures on the fly (sometimes called &lt;span id=&quot;autovivification_1&quot;&gt;autovivification&lt;/span&gt;):</source>
          <target state="translated">此proc可用于动态创建树结构（有时称为&lt;span id=&quot;autovivification_1&quot;&gt;autovivification&lt;/span&gt;）：</target>
        </trans-unit>
        <trans-unit id="d26c6b6b611681b46566a5e4a79f3225cadc8212" translate="yes" xml:space="preserve">
          <source>This proc doesn't perform any normalization! For example, &lt;code&gt;initTimeInterval(hours = 24)&lt;/code&gt; and &lt;code&gt;initTimeInterval(days = 1)&lt;/code&gt; are not equal.</source>
          <target state="translated">此proc不执行任何规范化！例如， &lt;code&gt;initTimeInterval(hours = 24)&lt;/code&gt; 和 &lt;code&gt;initTimeInterval(days = 1)&lt;/code&gt; 不相等。</target>
        </trans-unit>
        <trans-unit id="3940a36413be40e433cc94d22655956da42c2d56" translate="yes" xml:space="preserve">
          <source>This proc doesn't raise an exception on error, beware.</source>
          <target state="translated">这个proc在出错时不会引发异常,小心。</target>
        </trans-unit>
        <trans-unit id="ebb824dcf7f8bb590cee2ba4a4f3a5cbd9ae6dff" translate="yes" xml:space="preserve">
          <source>This proc expects to be passed as &lt;code&gt;n&lt;/code&gt; the parameters of any callable. The string output is meant for the HTML renderer. If there are no parameters, the empty string is returned. The parameters will be joined by &lt;code&gt;sep&lt;/code&gt; but other characters may appear too, like &lt;code&gt;[]&lt;/code&gt; or &lt;code&gt;|&lt;/code&gt;.</source>
          <target state="translated">该proc希望作为 &lt;code&gt;n&lt;/code&gt; 的任何可调用参数传递。字符串输出用于HTML渲染器。如果没有参数，则返回空字符串。参数将由 &lt;code&gt;sep&lt;/code&gt; 联接，但其他字符也可能出现，例如 &lt;code&gt;[]&lt;/code&gt; 或 &lt;code&gt;|&lt;/code&gt; 。。</target>
        </trans-unit>
        <trans-unit id="f135f77463cef43ee9fac9055909ade3fefb1c63" translate="yes" xml:space="preserve">
          <source>This proc is equivalent to 2^64 calls to &lt;a href=&quot;#next,Rand&quot;&gt;next&lt;/a&gt;, and it can be used to generate 2^64 non-overlapping subsequences for parallel computations.</source>
          <target state="translated">此proc等效于&lt;a href=&quot;#next,Rand&quot;&gt;next的&lt;/a&gt;2 ^ 64个调用，它可用于生成2 ^ 64个非重叠的子序列以进行并行计算。</target>
        </trans-unit>
        <trans-unit id="350b35231bf552e3848fa0167786f99d3c79a8be" translate="yes" xml:space="preserve">
          <source>This proc is mostly useful for meta programming (eg. &lt;code&gt;assert&lt;/code&gt; template) to retrieve information about the current filename and line number. Example:</source>
          <target state="translated">这个过程对于元编程（例如 &lt;code&gt;assert&lt;/code&gt; 模板）检索有关当前文件名和行号的信息最有用。例：</target>
        </trans-unit>
        <trans-unit id="bf91fb862b9ad244ab7a7fe8893c5ec5d0d1450b" translate="yes" xml:space="preserve">
          <source>This proc is normally used with connectionless sockets (UDP sockets).</source>
          <target state="translated">这个过程通常用于无连接套接字(UDP套接字)。</target>
        </trans-unit>
        <trans-unit id="2da63af19bd44e5c45f60183bb9599bcc8b3d3e9" translate="yes" xml:space="preserve">
          <source>This proc is wrapped by the &lt;a href=&quot;#expandTilde,string&quot;&gt;expandTilde proc&lt;/a&gt; for the convenience of processing paths coming from user configuration files.</source>
          <target state="translated">这个proc被&lt;a href=&quot;#expandTilde,string&quot;&gt;expandTilde proc&lt;/a&gt;包装，以方便处理来自用户配置文件的路径。</target>
        </trans-unit>
        <trans-unit id="8bc13541eec5a8625bb4f501795d54288285926d" translate="yes" xml:space="preserve">
          <source>This proc is wrapped by the expandTilde proc for the convenience of processing paths coming from user configuration files.</source>
          <target state="translated">为了方便处理来自用户配置文件的路径,该 proc 被 expandTilde proc 包裹。</target>
        </trans-unit>
        <trans-unit id="5e959921234b63d76dbef4bc106055bfeccf3fc5" translate="yes" xml:space="preserve">
          <source>This proc must be called before any other usage of &lt;code&gt;t&lt;/code&gt;.</source>
          <target state="translated">必须在 &lt;code&gt;t&lt;/code&gt; 的任何其他用法之前调用此proc 。</target>
        </trans-unit>
        <trans-unit id="7ad8173dbe5f7a8294af8a1a1ddc4730d7ef3e88" translate="yes" xml:space="preserve">
          <source>This proc only needs to be called once, and it should be called before the first usage of procs from this module that use the default random number generator.</source>
          <target state="translated">这个proc只需要被调用一次,并且应该在第一次使用这个模块中使用默认随机数生成器的proc之前被调用。</target>
        </trans-unit>
        <trans-unit id="333b238bdf3008bb02960b98a410ac4836f3911d" translate="yes" xml:space="preserve">
          <source>This proc sends &lt;code&gt;data&lt;/code&gt; to the specified &lt;code&gt;address&lt;/code&gt;, which may be an IP address or a hostname, if a hostname is specified this function will try each IP of that hostname.</source>
          <target state="translated">此过程将 &lt;code&gt;data&lt;/code&gt; 发送到指定的 &lt;code&gt;address&lt;/code&gt; ，该地址可以是IP地址或主机名，如果指定了主机名，则此功能将尝试该主机名的每个IP。</target>
        </trans-unit>
        <trans-unit id="938649feb3030899c2e766999d5b87bd8659f3c6" translate="yes" xml:space="preserve">
          <source>This proc sends &lt;code&gt;data&lt;/code&gt; to the specified &lt;code&gt;address&lt;/code&gt;, which may be an IP address or a hostname. If a hostname is specified this function will try each IP of that hostname. The returned future will complete once all data has been sent.</source>
          <target state="translated">此proc将 &lt;code&gt;data&lt;/code&gt; 发送到指定的 &lt;code&gt;address&lt;/code&gt; ，该地址可以是IP地址或主机名。如果指定了主机名，则此功能将尝试该主机名的每个IP。发送完所有数据后，返回的未来将完成。</target>
        </trans-unit>
        <trans-unit id="71ed4d34f9d82a4db2eb217526e348dc0895635d" translate="yes" xml:space="preserve">
          <source>This proc uses the default random number generator. Thus, it is &lt;strong&gt;not&lt;/strong&gt; thread-safe.</source>
          <target state="translated">此过程使用默认的随机数生成器。因此，它&lt;strong&gt;不是&lt;/strong&gt;线程安全的。</target>
        </trans-unit>
        <trans-unit id="47eaf268233c731f7c482448d362f14c34db36aa" translate="yes" xml:space="preserve">
          <source>This proc will assert if the node is not of the expected type. The empty string will be returned as a minimum. Any value in the rst will be stripped form leading/trailing whitespace.</source>
          <target state="translated">如果节点不是预期的类型,该 proc 将断言。空字符串将作为最小值返回。rst中的任何值都会被去掉前导/尾部的空白。</target>
        </trans-unit>
        <trans-unit id="bdafab7045ac0766f9e79ee5dc6b8e55ba43a53a" translate="yes" xml:space="preserve">
          <source>This proc will first scan &lt;code&gt;dir&lt;/code&gt; for index files with the &lt;code&gt;.idx&lt;/code&gt; extension previously created by commands like &lt;code&gt;nim doc|rst2html&lt;/code&gt; which use the &lt;code&gt;--index:on&lt;/code&gt; switch. These index files are the result of calls to &lt;a href=&quot;#setIndexTerm,RstGenerator,string,string,string,string,string&quot;&gt;setIndexTerm()&lt;/a&gt; and &lt;a href=&quot;#writeIndexFile,RstGenerator,string&quot;&gt;writeIndexFile()&lt;/a&gt;, so they are simple tab separated files.</source>
          <target state="translated">此proc将首先在 &lt;code&gt;dir&lt;/code&gt; 中扫描带有 &lt;code&gt;.idx&lt;/code&gt; 扩展名的索引文件，该文件先前由使用 &lt;code&gt;--index:on&lt;/code&gt; 开关的 &lt;code&gt;nim doc|rst2html&lt;/code&gt; 类的命令创建。这些索引文件是对&lt;a href=&quot;#setIndexTerm,RstGenerator,string,string,string,string,string&quot;&gt;setIndexTerm（）&lt;/a&gt;和&lt;a href=&quot;#writeIndexFile,RstGenerator,string&quot;&gt;writeIndexFile（）&lt;/a&gt;的调用的结果，因此它们是用制表符分隔的简单文件。</target>
        </trans-unit>
        <trans-unit id="626f1119535b21954263807e2c460288c1806626" translate="yes" xml:space="preserve">
          <source>This proc will first scan &lt;em&gt;dir&lt;/em&gt; for index files with the &lt;code&gt;.idx&lt;/code&gt; extension previously created by commands like &lt;code&gt;nim doc|rst2html&lt;/code&gt; which use the &lt;code&gt;--index:on&lt;/code&gt; switch. These index files are the result of calls to &lt;a href=&quot;#setIndexTerm&quot;&gt;setIndexTerm()&lt;/a&gt; and &lt;a href=&quot;#writeIndexFile&quot;&gt;writeIndexFile()&lt;/a&gt;, so they are simple tab separated files.</source>
          <target state="translated">此proc将首先在&lt;em&gt;dir&lt;/em&gt;中扫描带有 &lt;code&gt;.idx&lt;/code&gt; 扩展名的索引文件，该文件先前由使用 &lt;code&gt;--index:on&lt;/code&gt; 开关的 &lt;code&gt;nim doc|rst2html&lt;/code&gt; 类的命令创建。这些索引文件是对&lt;a href=&quot;#setIndexTerm&quot;&gt;setIndexTerm（）&lt;/a&gt;和&lt;a href=&quot;#writeIndexFile&quot;&gt;writeIndexFile（）&lt;/a&gt;的调用的结果，因此它们是用制表符分隔的简单文件。</target>
        </trans-unit>
        <trans-unit id="a4394af6524fbdf2935a5287c6e403358c97c2f3" translate="yes" xml:space="preserve">
          <source>This proc will return true if given two alternative hard-linked or sym-linked paths to the same file or directory.</source>
          <target state="translated">如果给定两个指向同一文件或目录的硬链接或符号链接路径,这个执行程序将返回true。</target>
        </trans-unit>
        <trans-unit id="9fa999fcdc85222ac9f9bda4589a9a95ca91d7d4" translate="yes" xml:space="preserve">
          <source>This proc works similarly to &lt;a href=&quot;#sample,Rand,openArray%5BT%5D,openArray%5BU%5D&quot;&gt;sample[T, U](Rand, openArray[T], openArray[U])&lt;/a&gt;. See that proc's documentation for more details.</source>
          <target state="translated">此proc的工作方式类似于&lt;a href=&quot;#sample,Rand,openArray%5BT%5D,openArray%5BU%5D&quot;&gt;sample [T，U]（Rand，openArray [T]，openArray [U]）&lt;/a&gt;。有关更多详细信息，请参见该proc的文档。</target>
        </trans-unit>
        <trans-unit id="93c1f778626a828d02676e44a9e588073cc53bdc" translate="yes" xml:space="preserve">
          <source>This procedure causes any unwritten data for that stream to be delivered to the host environment to be written to the file.</source>
          <target state="translated">这个过程会使该流的任何未写入的数据被送到主机环境中,写到文件中。</target>
        </trans-unit>
        <trans-unit id="3a80f4b7504eb42e35ef57671474e7f95b75a669" translate="yes" xml:space="preserve">
          <source>This procedure encodes a string according to MIME spec.</source>
          <target state="translated">这个过程根据MIME规范对一个字符串进行编码。</target>
        </trans-unit>
        <trans-unit id="5ab576674f0fae9f5c2db872b47e1b80cc3065ba" translate="yes" xml:space="preserve">
          <source>This procedure encodes a string.</source>
          <target state="translated">这个过程对一个字符串进行编码。</target>
        </trans-unit>
        <trans-unit id="c324daca0847c9b512385b859ab2363a1841f9c6" translate="yes" xml:space="preserve">
          <source>This procedure encodes an openarray (array or sequence) of either integers or characters.</source>
          <target state="translated">这个过程对整数或字符的openarray(数组或序列)进行编码。</target>
        </trans-unit>
        <trans-unit id="dadefb2f162797b5b8e737417830e0aaa5615a6d" translate="yes" xml:space="preserve">
          <source>This procedure exists only for optimization purposes; the same effect can be achieved with the &lt;code&gt;&amp;amp;&lt;/code&gt; operator or with &lt;code&gt;add&lt;/code&gt;.</source>
          <target state="translated">此过程仅出于优化目的而存在。使用 &lt;code&gt;&amp;amp;&lt;/code&gt; 运算符或使用 &lt;code&gt;add&lt;/code&gt; 可以达到相同的效果。</target>
        </trans-unit>
        <trans-unit id="c31397687949c9dfdee06b359b12e24a49c3d9c7" translate="yes" xml:space="preserve">
          <source>This procedure is not guaranteed to be available for all platforms. Test for availability with &lt;a href=&quot;#declared&quot;&gt;declared()&lt;/a&gt;.</source>
          <target state="translated">不能保证此过程适用于所有平台。使用&lt;a href=&quot;#declared&quot;&gt;clarified（）&lt;/a&gt;测试可用性。</target>
        </trans-unit>
        <trans-unit id="ca4fef9f6de3ef8d675cc867d40c13213fa9353a" translate="yes" xml:space="preserve">
          <source>This procedure is not guaranteed to be available for all platforms. Test for availability with &lt;code&gt;declared() &amp;lt;system.html#declared,untyped&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">不能保证此过程适用于所有平台。使用 &lt;code&gt;declared() &amp;lt;system.html#declared,untyped&amp;gt;&lt;/code&gt; 测试可用性。</target>
        </trans-unit>
        <trans-unit id="ebba0aeda7a3e7c849c8d97ba20a2191682f9515" translate="yes" xml:space="preserve">
          <source>This procedure is perfect for saving streamed data to a file without wasting memory.</source>
          <target state="translated">这个过程非常适合将流媒体数据保存到文件中而不浪费内存。</target>
        </trans-unit>
        <trans-unit id="d1f961f21ff0a84bd8db8e05ca89330dfa9923ef" translate="yes" xml:space="preserve">
          <source>This procedure is useful for converting &lt;code&gt;Duration&lt;/code&gt; values to strings.</source>
          <target state="translated">此过程对于将 &lt;code&gt;Duration&lt;/code&gt; 值转换为字符串很有用。</target>
        </trans-unit>
        <trans-unit id="520fb6fa62d760ce421de4aaa2f6105b1555063b" translate="yes" xml:space="preserve">
          <source>This procedure is useful for converting &lt;code&gt;TimeInterval&lt;/code&gt; values to strings. E.g. then you need to implement custom interval printing</source>
          <target state="translated">此过程对于将 &lt;code&gt;TimeInterval&lt;/code&gt; 值转换为字符串很有用。例如，您需要实施自定义间隔打印</target>
        </trans-unit>
        <trans-unit id="52e91210394e398f992437bda6d4effa40dcc4a1" translate="yes" xml:space="preserve">
          <source>This procedure is useful in the event when an OS call fails. In that case this procedure will return the error code describing the reason why the OS call failed. The &lt;code&gt;OSErrorMsg&lt;/code&gt; procedure can then be used to convert this code into a string.</source>
          <target state="translated">如果OS调用失败，此过程将很有用。在这种情况下，此过程将返回错误代码，该错误代码描述了OS调用失败的原因。该 &lt;code&gt;OSErrorMsg&lt;/code&gt; 然后程序可以使用这个代码转换为字符串。</target>
        </trans-unit>
        <trans-unit id="70517cf24694c69da8efa582ddd657d7197346ed" translate="yes" xml:space="preserve">
          <source>This procedure uses httpClient values such as &lt;code&gt;client.maxRedirects&lt;/code&gt;.</source>
          <target state="translated">此过程使用httpClient值，例如 &lt;code&gt;client.maxRedirects&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0479019038d3102021d1669951bf95b837b91563" translate="yes" xml:space="preserve">
          <source>This procedure will &lt;strong&gt;not&lt;/strong&gt; close the client socket.</source>
          <target state="translated">此过程&lt;strong&gt;不会&lt;/strong&gt;关闭客户端套接字。</target>
        </trans-unit>
        <trans-unit id="2c9c22aaa48bc7cddb7839a6f9a879afc83e6b75" translate="yes" xml:space="preserve">
          <source>This procedure will also create a brand new file descriptor for this socket.</source>
          <target state="translated">这个过程还将为这个socket创建一个全新的文件描述符。</target>
        </trans-unit>
        <trans-unit id="1288ff1149ba87d487f19440b9d10966e30531a7" translate="yes" xml:space="preserve">
          <source>This procedure will follow redirects up to a maximum number of redirects specified in &lt;code&gt;client.maxRedirects&lt;/code&gt;.</source>
          <target state="translated">此过程将遵循重定向，直到 &lt;code&gt;client.maxRedirects&lt;/code&gt; 中指定的最大重定向数。</target>
        </trans-unit>
        <trans-unit id="7a5c3737642080f0e83823f3dcd1cc4baeb39760" translate="yes" xml:space="preserve">
          <source>This procedure will immediately return, it will not block until a connection is made. It is up to the caller to make sure the connection has been established by checking (using &lt;code&gt;select&lt;/code&gt;) whether the socket is writeable.</source>
          <target state="translated">该过程将立即返回，直到建立连接后它才会阻塞。调用方可以通过检查（使用 &lt;code&gt;select&lt;/code&gt; ）套接字是否可写来确保已建立连接。</target>
        </trans-unit>
        <trans-unit id="8185dc4f223c6b697125a69fc7c20cfa4abf8f29" translate="yes" xml:space="preserve">
          <source>This procedure will resolve symlinks.</source>
          <target state="translated">这个过程将解析符号链接。</target>
        </trans-unit>
        <trans-unit id="014cae8b1a1962b4f1faa243de196e5e656ee26d" translate="yes" xml:space="preserve">
          <source>This provides higher efficiency than the &lt;code&gt;pretty&lt;/code&gt; procedure as it does &lt;strong&gt;not&lt;/strong&gt; attempt to format the resulting JSON to make it human readable.</source>
          <target state="translated">与 &lt;code&gt;pretty&lt;/code&gt; 过程相比，这提供了更高的效率，因为它&lt;strong&gt;没有&lt;/strong&gt;尝试格式化结果JSON以使其易于阅读。</target>
        </trans-unit>
        <trans-unit id="526a6ce57682bfa6e8b959cd6e81435a72cdfc8d" translate="yes" xml:space="preserve">
          <source>This quickly gets tedious. The implementations are trivial and the compiler should not generate all this code only to optimize it away later - after all &lt;code&gt;+&lt;/code&gt; for dollars should produce the same binary code as &lt;code&gt;+&lt;/code&gt; for ints. The pragma &lt;span id=&quot;borrow_1&quot;&gt;borrow&lt;/span&gt; has been designed to solve this problem; in principle it generates the above trivial implementations:</source>
          <target state="translated">这很快变得乏味。的实现是琐碎和编译器不应该产生这些代码后来才优化它了-毕竟 &lt;code&gt;+&lt;/code&gt; 对美元应该产生相同的二进制代码 &lt;code&gt;+&lt;/code&gt; 为整数。杂项&lt;span id=&quot;borrow_1&quot;&gt;借用&lt;/span&gt;旨在解决此问题。原则上，它生成上述琐碎的实现：</target>
        </trans-unit>
        <trans-unit id="77e02d73fd63a6b9ecbe38066eb72908681331b1" translate="yes" xml:space="preserve">
          <source>This quickly gets tedious. The implementations are trivial and the compiler should not generate all this code only to optimize it away later - after all &lt;code&gt;+&lt;/code&gt; for dollars should produce the same binary code as &lt;code&gt;+&lt;/code&gt; for ints. The pragma &lt;span id=&quot;borrow_1&quot;&gt;borrow&lt;/span&gt; has been designed to solve this problem; in principle, it generates the above trivial implementations:</source>
          <target state="translated">这很快变得乏味。这些实现很简单，编译器不应生成所有这些代码，而只是稍后再对其进行优化-毕竟，对于美元， &lt;code&gt;+&lt;/code&gt; 应生成与用于int的 &lt;code&gt;+&lt;/code&gt; 相同的二进制代码。杂项&lt;span id=&quot;borrow_1&quot;&gt;借用&lt;/span&gt;旨在解决此问题。原则上，它生成上述琐碎的实现：</target>
        </trans-unit>
        <trans-unit id="b47005e240c8afd6e1584cbc26a7622dbbbd1d07" translate="yes" xml:space="preserve">
          <source>This rather unorthodox way to do identifier comparisons is called &lt;span id=&quot;partial-case-insensitivity_1&quot;&gt;partial case insensitivity&lt;/span&gt; and has some advantages over the conventional case sensitivity:</source>
          <target state="translated">这种进行标识符比较的不合常规的方法称为&lt;span id=&quot;partial-case-insensitivity_1&quot;&gt;不区分大小写&lt;/span&gt;，并且相对于常规&lt;span id=&quot;partial-case-insensitivity_1&quot;&gt;区分大小写&lt;/span&gt;具有一些优点：</target>
        </trans-unit>
        <trans-unit id="601b78ebce6eee9b81f17aee5fe0af4dacad523a" translate="yes" xml:space="preserve">
          <source>This rather unorthodox way to do identifier comparisons is called &lt;span id=&quot;partial-caseminusinsensitivity_1&quot;&gt;partial case-insensitivity&lt;/span&gt; and has some advantages over the conventional case sensitivity:</source>
          <target state="translated">这种进行标识符比较&lt;span id=&quot;partial-caseminusinsensitivity_1&quot;&gt;的不合&lt;/span&gt;常规的方法称为&lt;span id=&quot;partial-caseminusinsensitivity_1&quot;&gt;不区分大小写&lt;/span&gt;，并且相对于常规&lt;span id=&quot;partial-caseminusinsensitivity_1&quot;&gt;的区分大小写&lt;/span&gt;具有一些优点：</target>
        </trans-unit>
        <trans-unit id="24ed54e7055d8ae85d9b5529ed324762a3d069ea" translate="yes" xml:space="preserve">
          <source>This requires the OpenSSL library, fortunately it's widely used and installed on many operating systems. httpclient will use SSL automatically if you give any of the functions a url with the &lt;code&gt;https&lt;/code&gt; schema, for example: &lt;code&gt;https://github.com/&lt;/code&gt;.</source>
          <target state="translated">这需要OpenSSL库，幸运的是，它已被广泛使用并安装在许多操作系统上。如果为任何功能提供带有 &lt;code&gt;https&lt;/code&gt; 架构的url，则httpclient将自动使用SSL ，例如： &lt;code&gt;https://github.com/&lt;/code&gt; : //github.com/。</target>
        </trans-unit>
        <trans-unit id="3909002e9ad606364e490e6f4e79bacb7e050226" translate="yes" xml:space="preserve">
          <source>This retrieves ALL rows into memory before iterating through the rows. Large dataset queries will impact on memory usage.</source>
          <target state="translated">这将在迭代行之前将所有行检索到内存中。大数据集查询会影响内存使用。</target>
        </trans-unit>
        <trans-unit id="096ad9b3f2bcb1230451399427a373a8d336f90f" translate="yes" xml:space="preserve">
          <source>This returns &lt;strong&gt;only&lt;/strong&gt; the parameters. If you want to get the application executable filename, call &lt;a href=&quot;#getAppFilename&quot;&gt;getAppFilename()&lt;/a&gt;.</source>
          <target state="translated">这&lt;strong&gt;仅&lt;/strong&gt;返回参数。如果要获取应用程序可执行文件的文件名，请调用&lt;a href=&quot;#getAppFilename&quot;&gt;getAppFilename（）&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="aa9d6a77d63381c1d09d47733e42419e7a92f6c1" translate="yes" xml:space="preserve">
          <source>This section can only help you with the last item.</source>
          <target state="translated">这一部分只能帮你解决最后一项。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
