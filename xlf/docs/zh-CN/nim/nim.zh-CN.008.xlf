<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="nim">
    <body>
      <group id="nim">
        <trans-unit id="c4af36b03e871c9cae4428903b9bca8534e6953e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deprecated since version 0.9.2&lt;/strong&gt;: This function is not safe for use.</source>
          <target state="translated">&lt;strong&gt;从0.9.2版开始&lt;/strong&gt;不推荐使用：此功能不安全。</target>
        </trans-unit>
        <trans-unit id="fface47b088c778a2f4e77c02bf19ee55d18a8e2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deprecated:&lt;/strong&gt; use &lt;code&gt;fromWinTime&lt;/code&gt; instead.</source>
          <target state="translated">&lt;strong&gt;不推荐使用：&lt;/strong&gt;改用 &lt;code&gt;fromWinTime&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="06ec99b3afe2ae2cbe0edda32125eccea758f261" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deprecated:&lt;/strong&gt; use &lt;code&gt;toWinTime&lt;/code&gt; instead.</source>
          <target state="translated">&lt;strong&gt;Deprecated:&lt;/strong&gt; use &lt;code&gt;toWinTime&lt;/code&gt; instead.</target>
        </trans-unit>
        <trans-unit id="3a884be761dae54201f8aa530278b417918acce3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deprecated:&lt;/strong&gt; use &lt;em&gt;hasKey&lt;/em&gt; instead.</source>
          <target state="translated">&lt;strong&gt;不推荐使用：&lt;/strong&gt;改用&lt;em&gt;hasKey&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="a22c0c29442195e4011e17d60edeee2f5d85fcea" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Disclaimer&lt;/strong&gt;: This code is not well tested, may be very unsafe and prone to security vulnerabilities.</source>
          <target state="translated">&lt;strong&gt;免责声明&lt;/strong&gt;：此代码未经严格测试，可能非常不安全，并且容易出现安全漏洞。</target>
        </trans-unit>
        <trans-unit id="6ffe4dc5c4fc52ea3ea1e3a20dd64567380feece" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Do not use this module for cryptographic purposes!&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;不要将此模块用于加密目的！&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f928ed32bee5c29af52b00bc30f99ce156242335" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Docstring&lt;/strong&gt;: always the empty string.</source>
          <target state="translated">&lt;strong&gt;Docstring&lt;/strong&gt;：始终为空字符串。</target>
        </trans-unit>
        <trans-unit id="d4209dbb40d9185067bcb8ce189cd1c6eed7f25e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Docstring&lt;/strong&gt;: docstring if available.</source>
          <target state="translated">&lt;strong&gt;docstring&lt;/strong&gt;：docstring（如果可用）。</target>
        </trans-unit>
        <trans-unit id="c0dd9bb9e04f64f6f60578b64bf64464fec710d9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Error&lt;/strong&gt; - error conditions that the application can recover from</source>
          <target state="translated">&lt;strong&gt;错误&lt;/strong&gt;-应用程序可以从中恢复的错误条件</target>
        </trans-unit>
        <trans-unit id="4168878b06eaa6917a0f012585506612f5054ea6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Example:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1bc0a5d67820f61786ae04d054caabfe5bd3f6ff" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Examples:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Examples:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="15f078e82171a8efcc97da8037079287adaefb70" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Fatal&lt;/strong&gt; - fatal errors that prevent the application from continuing</source>
          <target state="translated">&lt;strong&gt;致命&lt;/strong&gt;-导致应用程序无法继续运行的致命错误</target>
        </trans-unit>
        <trans-unit id="73e5c6a20cafb8203519ae745e546e8bb3f10e1f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Fourth column&lt;/strong&gt;: always the empty string.</source>
          <target state="translated">&lt;strong&gt;第四列&lt;/strong&gt;：始终为空字符串。</target>
        </trans-unit>
        <trans-unit id="160ef9d36bed422272b88e68bd931cde20c08000" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Fourth column&lt;/strong&gt;: enum type grouping other enum fields.</source>
          <target state="translated">&lt;strong&gt;第四列&lt;/strong&gt;：将其他枚举字段分组的枚举类型。</target>
        </trans-unit>
        <trans-unit id="be7ebe20c5b6aef98f77a13140c9b09bb67359f6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Fourth column&lt;/strong&gt;: signature of the iterator including return type.</source>
          <target state="translated">&lt;strong&gt;第四列&lt;/strong&gt;：迭代器的签名，包括返回类型。</target>
        </trans-unit>
        <trans-unit id="c6c20f7dbb204753d2338c8585a984c7c7fa8c25" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Fourth column&lt;/strong&gt;: signature of the macro including return type.</source>
          <target state="translated">&lt;strong&gt;第四列&lt;/strong&gt;：宏的签名，包括返回类型。</target>
        </trans-unit>
        <trans-unit id="b6771fb30bab96fd8cf5d95cfd5b7411f13b3c15" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Fourth column&lt;/strong&gt;: signature of the method including return type.</source>
          <target state="translated">&lt;strong&gt;第四列&lt;/strong&gt;：方法的签名，包括返回类型。</target>
        </trans-unit>
        <trans-unit id="8779f27a30500300592c1fbc44c5a869259d7284" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Fourth column&lt;/strong&gt;: signature of the proc including return type.</source>
          <target state="translated">&lt;strong&gt;第四列&lt;/strong&gt;：proc的签名，包括返回类型。</target>
        </trans-unit>
        <trans-unit id="5b4c52d33a04c0f32a87d9b5783e815726a1d81e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Fourth column&lt;/strong&gt;: signature of the template including return type.</source>
          <target state="translated">&lt;strong&gt;第四列&lt;/strong&gt;：模板的签名，包括返回类型。</target>
        </trans-unit>
        <trans-unit id="4dfd102fd6fbe96ece65dd9c1d384e0f16912006" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Fourth column&lt;/strong&gt;: the type of the const value.</source>
          <target state="translated">&lt;strong&gt;第四列&lt;/strong&gt;：const值的类型。</target>
        </trans-unit>
        <trans-unit id="63fb555122e12cadcd219b4c04854752ec0ed9fa" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Fourth column&lt;/strong&gt;: the type of the let variable.</source>
          <target state="translated">&lt;strong&gt;第四列&lt;/strong&gt;：let变量的类型。</target>
        </trans-unit>
        <trans-unit id="20edb7c031a399a27ff6ff092cecc38f0cd151a7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Fourth column&lt;/strong&gt;: the type of the parameter.</source>
          <target state="translated">&lt;strong&gt;第四列&lt;/strong&gt;：参数的类型。</target>
        </trans-unit>
        <trans-unit id="d1c0d7dfb4af3e8e26314132e3d53473279ebfe5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Fourth column&lt;/strong&gt;: the type of the result.</source>
          <target state="translated">&lt;strong&gt;第四列&lt;/strong&gt;：结果的类型。</target>
        </trans-unit>
        <trans-unit id="c558e48e401e6265a17ebeab90f8b20f1f7e1e47" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Fourth column&lt;/strong&gt;: the type of the var.</source>
          <target state="translated">&lt;strong&gt;第四列&lt;/strong&gt;：var的类型。</target>
        </trans-unit>
        <trans-unit id="9384cc6e440487319d842110001333299d831093" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Fourth column&lt;/strong&gt;: the type.</source>
          <target state="translated">&lt;strong&gt;第四栏&lt;/strong&gt;：类型。</target>
        </trans-unit>
        <trans-unit id="329b7e3326c98503c949ca9d39330b0e1c6794bd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Fourth column&lt;/strong&gt;: type of the var.</source>
          <target state="translated">&lt;strong&gt;第四栏&lt;/strong&gt;：var的类型。</target>
        </trans-unit>
        <trans-unit id="978f10cfc82df92effeee967159555f49c21c819" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Future directions&lt;/strong&gt;: GC'ed memory should be allowed in unchecked arrays and there should be an explicit annotation of how the GC is to determine the runtime size of the array.</source>
          <target state="translated">&lt;strong&gt;未来发展方向&lt;/strong&gt;：未经检查的数组中应允许使用GC的内存，并且应该明确说明GC如何确定数组的运行时大小。</target>
        </trans-unit>
        <trans-unit id="150871409dc1ef45a59e74d4be5900fd8cf45ddc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Future directions&lt;/strong&gt;: GC'ed memory should be allowed in unions and the GC should scan unions conservatively.</source>
          <target state="translated">&lt;strong&gt;将来的方向&lt;/strong&gt;：应允许在联合中使用GC的内存，并且GC应保守地扫描联合。</target>
        </trans-unit>
        <trans-unit id="5f1330a349c9dedfd2b8b17d35746d232592d00d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Future directions&lt;/strong&gt;: The &lt;code&gt;acyclic&lt;/code&gt; pragma may become a property of a &lt;code&gt;ref&lt;/code&gt; type:</source>
          <target state="translated">&lt;strong&gt;未来发展方向&lt;/strong&gt;： &lt;code&gt;acyclic&lt;/code&gt; 编译指示可能会成为 &lt;code&gt;ref&lt;/code&gt; 类型的属性：</target>
        </trans-unit>
        <trans-unit id="9a4c8f25dfeefcc10f7c8b1211a9ccc00288df9b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Future directions&lt;/strong&gt;: Using GC'ed memory in packed pragma will result in a static error. Usage with inheritance should be defined and documented.</source>
          <target state="translated">&lt;strong&gt;将来的方向&lt;/strong&gt;：在打包的编译指示中使用GC的内存将导致静态错误。带有继承的用法应进行定义和记录。</target>
        </trans-unit>
        <trans-unit id="75d19ae59ec3e06e328ace922bad09261db8a6c1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Future directions&lt;/strong&gt;: Using GC'ed memory in packed pragma will result in compile-time error. Usage with inheritance should be defined and documented.</source>
          <target state="translated">&lt;strong&gt;未来发展方向&lt;/strong&gt;：在打包的编译指示中使用GC的内存将导致编译时错误。带有继承的用法应定义并记录下来。</target>
        </trans-unit>
        <trans-unit id="02ec565bd2b833f4e079a16ceaa88628a37485b1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Hint:&lt;/strong&gt; With &lt;code&gt;--hint[codeBegin]:on&lt;/code&gt; or &lt;code&gt;--verbosity:2&lt;/code&gt; (or higher) while compiling or &lt;code&gt;nim check&lt;/code&gt;, Nim lists the processed code after each filter application.</source>
          <target state="translated">&lt;strong&gt;提示：&lt;/strong&gt;使用 &lt;code&gt;--hint[codeBegin]:on&lt;/code&gt; 或 &lt;code&gt;--verbosity:2&lt;/code&gt; （或更高版本）进行编译或 &lt;code&gt;nim check&lt;/code&gt; ，Nim会在每个过滤器应用程序后列出已处理的代码。</target>
        </trans-unit>
        <trans-unit id="b59417140c3fc6f7e2c17f2c777a2f509360e62e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Hint:&lt;/strong&gt; With &lt;code&gt;--hint[codeBegin]:on```or ``--verbosity:2&lt;/code&gt; (or higher) Nim lists the processed code after each filter application.</source>
          <target state="translated">&lt;strong&gt;提示：&lt;/strong&gt;使用 &lt;code&gt;--hint[codeBegin]:on```or ``--verbosity:2&lt;/code&gt; （或更高版本）&amp;rdquo; Nim会在每个过滤器应用程序后列出已处理的代码。</target>
        </trans-unit>
        <trans-unit id="b2b402acffec017e9e1d08158fe3bc6834d4ccb1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;If duplicate keys were added, this may need to be called multiple times.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;如果添加了重复的密钥，则可能需要多次调用。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5e3461ae9a0b84542c802ba567999b3faa5afdc0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Important:&lt;/strong&gt; The &lt;code&gt;[]&lt;/code&gt; operator will raise an exception when the specified field does not exist.</source>
          <target state="translated">&lt;strong&gt;重要提示：&lt;/strong&gt;如果指定的字段不存在，则 &lt;code&gt;[]&lt;/code&gt; 运算符将引发异常。</target>
        </trans-unit>
        <trans-unit id="46a3d06a2ac66b0299dc868e1e5f195e4b08f76c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Info&lt;/strong&gt; - anything associated with normal operation and without any particular importance</source>
          <target state="translated">&lt;strong&gt;信息&lt;/strong&gt;-与正常操作相关且没有任何特别重要性的任何信息</target>
        </trans-unit>
        <trans-unit id="00641ee780415a4fe5e346e4872088e6dc38287d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;JS note:&lt;/strong&gt;&lt;code&gt;buffer&lt;/code&gt; is treated as a &lt;code&gt;ptr string&lt;/code&gt; and read between &lt;code&gt;0..&amp;lt;bufLen&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;JS注意：&lt;/strong&gt; &lt;code&gt;buffer&lt;/code&gt; 被视为 &lt;code&gt;ptr string&lt;/code&gt; 并且在 &lt;code&gt;0..&amp;lt;bufLen&lt;/code&gt; 之间读取。</target>
        </trans-unit>
        <trans-unit id="0570a04d10f01c787204df1793c74a673b8d7e99" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;JS note:&lt;/strong&gt;&lt;code&gt;buffer&lt;/code&gt; is treated as a &lt;code&gt;ptr string&lt;/code&gt; and written to between &lt;code&gt;0..&amp;lt;bufLen&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;JS注意：&lt;/strong&gt; &lt;code&gt;buffer&lt;/code&gt; 被视为 &lt;code&gt;ptr string&lt;/code&gt; 并写入 &lt;code&gt;0..&amp;lt;bufLen&lt;/code&gt; 之间。</target>
        </trans-unit>
        <trans-unit id="f555042911466061dac7f6fee69c396fc92108dd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Known limitations:&lt;/strong&gt; In the JavaScript target, global variables using the &lt;code&gt;codegenDecl&lt;/code&gt; pragma will be re-initialized on each reload. Please guard the initialization with a &lt;em&gt;once&lt;/em&gt; block to work-around this.</source>
          <target state="translated">&lt;strong&gt;已知限制：&lt;/strong&gt;在JavaScript目标中，将在每次重新加载时重新初始化使用 &lt;code&gt;codegenDecl&lt;/code&gt; 编译指示的全局变量。请通过&lt;em&gt;一次代码&lt;/em&gt;块保护初始化，以解决此问题。</target>
        </trans-unit>
        <trans-unit id="5911ff88eb68bebee7d71b3a0d7b01ad6e208cea" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NOTE&lt;/strong&gt;: Nim currently does not detect these!</source>
          <target state="translated">&lt;strong&gt;注意&lt;/strong&gt;：Nim当前无法检测到这些！</target>
        </trans-unit>
        <trans-unit id="3082097f9021d41c1a42dcf5d23ffc66ad1979a1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NOTE&lt;/strong&gt;: The behaviour might change in future versions as it is not clear what &quot;&lt;em&gt;wild&lt;/em&gt; HTML the real world uses&quot; really implies.</source>
          <target state="translated">&lt;strong&gt;注意&lt;/strong&gt;：该行为在将来的版本中可能会更改，因为尚不清楚&amp;ldquo;现实世界使用的&lt;em&gt;狂野&lt;/em&gt;HTML&amp;rdquo;的含义是什么。</target>
        </trans-unit>
        <trans-unit id="65dcf051b0f8d4d6b70a92dd10d98dbbb05e7cdd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Note:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="140047e96ac4c58f01e73270812c9a51624feb38" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; At the moment hot code reloading is supported only in JavaScript projects.</source>
          <target state="translated">&lt;strong&gt;注意：&lt;/strong&gt;目前，仅JavaScript项目支持热代码重载。</target>
        </trans-unit>
        <trans-unit id="16f3b81d60ef5438aad137b2307d09cc9f71b096" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; Breaking the &lt;code&gt;fastRows()&lt;/code&gt; iterator during a loop will cause the next database query to raise a &lt;code&gt;DbError&lt;/code&gt; exception &lt;code&gt;unable to close due to ...&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;注意：&lt;/strong&gt;在循环期间中断 &lt;code&gt;fastRows()&lt;/code&gt; 迭代器将导致下一个数据库查询引发 &lt;code&gt;DbError&lt;/code&gt; 异常 &lt;code&gt;unable to close due to ...&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="61e6136be66e5bf74c87880dc268f56f9861dc81" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; Channels are designed for the &lt;code&gt;Thread&lt;/code&gt; type. They are unstable when used with &lt;code&gt;spawn&lt;/code&gt;</source>
          <target state="translated">&lt;strong&gt;注意：&lt;/strong&gt;通道是为 &lt;code&gt;Thread&lt;/code&gt; 类型设计的。与 &lt;code&gt;spawn&lt;/code&gt; 一起使用时它们不稳定</target>
        </trans-unit>
        <trans-unit id="0d9dcf701f94adaa5a4d2bbfbd098d67fc7ddc8a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; Channels cannot be passed between threads. Use globals or pass them by &lt;code&gt;ptr&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;注意：&lt;/strong&gt;无法在线程之间传递通道。使用全局变量或通过 &lt;code&gt;ptr&lt;/code&gt; 传递它们。</target>
        </trans-unit>
        <trans-unit id="a5ae990ae2793f586640459d0853bfff28f07ff8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; Comment statement will be ignored.</source>
          <target state="translated">&lt;strong&gt;注意：&lt;/strong&gt; Comment语句将被忽略。</target>
        </trans-unit>
        <trans-unit id="6c08afa96cbaa181efd240626cdc35ba72be35dc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; Does not work for NimScript.</source>
          <target state="translated">&lt;strong&gt;注意：&lt;/strong&gt;不适用于NimScript。</target>
        </trans-unit>
        <trans-unit id="d4b69032440a3760c06332bd2946743c6dc04769" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; Each delegate has a task associated with it. This gets called after each select() call, if you set timeout to &lt;code&gt;-1&lt;/code&gt; the tasks will only be executed after one or more file descriptors becomes readable or writeable.</source>
          <target state="translated">&lt;strong&gt;注意：&lt;/strong&gt;每个委托都有一个与之关联的任务。每次select（）调用之后都会调用此方法，如果将超时设置为 &lt;code&gt;-1&lt;/code&gt; ，则仅在一个或多个文件描述符变为可读或可写之后才执行任务。</target>
        </trans-unit>
        <trans-unit id="7f378938581797df4e574611774903888f75a977" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; For leap years, start date is assumed to be 1 AD. counts the number of leap years up to January 1st of a given year. Keep in mind that if specified year is a leap year, the leap day has not happened before January 1st of that year.</source>
          <target state="translated">&lt;strong&gt;注意：&lt;/strong&gt;对于leap年，开始日期假定为1 AD。计算到给定年份的1月1日为止的leap年数。请记住，如果指定的年份是a年，则day年在该年的1月1日之前不会发生。</target>
        </trans-unit>
        <trans-unit id="02ebb094e834ec378d8bae7a318f260891645141" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; If you need a version of &lt;code&gt;exec&lt;/code&gt; that returns the exit code and text output of the command, you can use &lt;a href=&quot;system#gorgeEx,string,string,string&quot;&gt;system.gorgeEx&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;注意：&lt;/strong&gt;如果需要版本的 &lt;code&gt;exec&lt;/code&gt; 返回命令的退出代码和文本输出，则可以使用&lt;a href=&quot;system#gorgeEx,string,string,string&quot;&gt;system.gorgeEx&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8234ec32d945f2b0f03239d1b0eaae84f70df2af" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; If you want to provide async ability to your module please do not use the &lt;code&gt;Delegate&lt;/code&gt; object, instead use &lt;code&gt;AsyncSocket&lt;/code&gt;. It is possible that in the future this type's fields will not be exported therefore breaking your code.</source>
          <target state="translated">&lt;strong&gt;注意：&lt;/strong&gt;如果要为模块提供异步功能，请不要使用 &lt;code&gt;Delegate&lt;/code&gt; 对象，而应使用 &lt;code&gt;AsyncSocket&lt;/code&gt; 。将来有可能不会导出此类型的字段，因此会破坏您的代码。</target>
        </trans-unit>
        <trans-unit id="e85ae0701fc3f9c17e3733cbce315301d09131af" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; Import &lt;code&gt;packages/docutils/highlite&lt;/code&gt; to use this module</source>
          <target state="translated">&lt;strong&gt;注意：&lt;/strong&gt;导入 &lt;code&gt;packages/docutils/highlite&lt;/code&gt; 以使用此模块</target>
        </trans-unit>
        <trans-unit id="843c2b3ee7e629c2441a4dd24c956ffe976de720" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; Import &lt;code&gt;packages/docutils/rst&lt;/code&gt; to use this module</source>
          <target state="translated">&lt;strong&gt;注意：&lt;/strong&gt;导入 &lt;code&gt;packages/docutils/rst&lt;/code&gt; 以使用此模块</target>
        </trans-unit>
        <trans-unit id="e76b1b31d6a0fcc3a95e3171e746bb3a3ca3998e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; Import &lt;code&gt;packages/docutils/rstast&lt;/code&gt; to use this module</source>
          <target state="translated">&lt;strong&gt;注意：&lt;/strong&gt;导入 &lt;code&gt;packages/docutils/rstast&lt;/code&gt; 以使用此模块</target>
        </trans-unit>
        <trans-unit id="42ab66a9d8c71c977571af7a1c3cae030aeb63a8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; Import &lt;code&gt;packages/docutils/rstgen&lt;/code&gt; to use this module</source>
          <target state="translated">&lt;strong&gt;注意：&lt;/strong&gt;导入 &lt;code&gt;packages/docutils/rstgen&lt;/code&gt; 以使用此模块</target>
        </trans-unit>
        <trans-unit id="2474d53657db59741f090272c72d5eb8c30f27da" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; Import &lt;code&gt;std/sha1&lt;/code&gt; to use this module</source>
          <target state="translated">&lt;strong&gt;注意：&lt;/strong&gt;导入 &lt;code&gt;std/sha1&lt;/code&gt; 以使用此模块</target>
        </trans-unit>
        <trans-unit id="6066c5e1dbc1c07031004fde7afa16f36e8afe0b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; Most modules have tasks which need to be ran regularly, this is why you should not call &lt;code&gt;poll&lt;/code&gt; with a infinite timeout, or even a very long one. In most cases the default timeout is fine.</source>
          <target state="translated">&lt;strong&gt;注意：&lt;/strong&gt;大多数模块都有需要定期运行的任务，这就是为什么您不应以无限超时甚至很长的超时调用 &lt;code&gt;poll&lt;/code&gt; 。在大多数情况下，默认超时是可以的。</target>
        </trans-unit>
        <trans-unit id="197712af8474ad67fa3deb053cf4d10c7db7a328" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; Not available for JS backend.</source>
          <target state="translated">&lt;strong&gt;注意：&lt;/strong&gt;不适用于JS后端。</target>
        </trans-unit>
        <trans-unit id="add59de22ea186db4c63840851e7cf0d92d2b537" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; Not available for JS backend. Use &lt;a href=&quot;#peekStr,Stream,int&quot;&gt;peekStr&lt;/a&gt; for now.</source>
          <target state="translated">&lt;strong&gt;注意：&lt;/strong&gt;不适用于JS后端。现在使用&lt;a href=&quot;#peekStr,Stream,int&quot;&gt;peekStr&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a295c2c96fbc8a7f45e187ef6bfaedb02e5b3937" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; Not available for JS backend. Use &lt;a href=&quot;#readStr,Stream,int&quot;&gt;readStr&lt;/a&gt; for now.</source>
          <target state="translated">&lt;strong&gt;注意：&lt;/strong&gt;不适用于JS后端。现在使用&lt;a href=&quot;#readStr,Stream,int&quot;&gt;readStr&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="61879707f76ebc05d6254a26c8af524bb7cf85ea" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; Not available for JS backend. Use &lt;a href=&quot;#write,Stream,string&quot;&gt;write(Stream, string)&lt;/a&gt; for now.</source>
          <target state="translated">&lt;strong&gt;注意：&lt;/strong&gt;不适用于JS后端。现在使用&lt;a href=&quot;#write,Stream,string&quot;&gt;write（Stream，string）&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0f5f90a42c28a76d9ac73c0f1962a68a45b56af5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; On the JS backend this currently counts UTF-16 code points instead of bytes at runtime (not at compile time). For now, if you need the byte length of the UTF-8 encoding, convert to string with &lt;code&gt;$&lt;/code&gt; first then call &lt;code&gt;len&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;注意：&lt;/strong&gt;在JS后端上，当前在运行时（而不是在编译时）计算UTF-16代码点而不是字节。现在，如果您需要UTF-8编码的字节长度，请先使用 &lt;code&gt;$&lt;/code&gt; 转换为字符串，然后调用 &lt;code&gt;len&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e5f3a93e6b5389328dfe4d50a2a108b926a73e41" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; Only error and fatal messages will cause the output buffer to be flushed immediately. Use the &lt;a href=&quot;io#flushFile,File&quot;&gt;flushFile proc&lt;/a&gt; to flush the buffer manually if needed.</source>
          <target state="translated">&lt;strong&gt;注意：&lt;/strong&gt;只有错误和致命消息才会导致立即清除输出缓冲区。如果需要，请使用&lt;a href=&quot;io#flushFile,File&quot;&gt;flushFile proc&lt;/a&gt;手动刷新缓冲区。</target>
        </trans-unit>
        <trans-unit id="0ed2d4766f9364afd4bd59bed6474d34be992a49" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; Only the &lt;code&gt;connection&lt;/code&gt; parameter is used for &lt;code&gt;sqlite&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;注意：&lt;/strong&gt;只有 &lt;code&gt;connection&lt;/code&gt; 参数用于 &lt;code&gt;sqlite&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0e05f6628a4d37e39425527e3fad105da1952478" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; Starting from Nim 0.20, to use multi-methods one must explicitly pass &lt;code&gt;--multimethods:on&lt;/code&gt; when compiling.</source>
          <target state="translated">&lt;strong&gt;注意：&lt;/strong&gt;从Nim 0.20开始，要使用多种方法，必须在编译时显式传递 &lt;code&gt;--multimethods:on&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4f92aa536204e6eaef641a2e69451b390e74e1bb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; The &lt;em&gt;project file name&lt;/em&gt; is the name of the &lt;code&gt;.nim&lt;/code&gt; file that is passed as a command line argument to the compiler.</source>
          <target state="translated">&lt;strong&gt;注：&lt;/strong&gt;该&lt;em&gt;项目文件名&lt;/em&gt;是名 &lt;code&gt;.nim&lt;/code&gt; 被作为命令行参数传递到编译器的文件。</target>
        </trans-unit>
        <trans-unit id="bde269deb8be545b32a64412683066eff50f652a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; The &lt;em&gt;project file name&lt;/em&gt; is the name of the &lt;code&gt;.nim&lt;/code&gt; file that is passed as a command-line argument to the compiler.</source>
          <target state="translated">&lt;strong&gt;注：&lt;/strong&gt;该&lt;em&gt;项目文件名&lt;/em&gt;是名 &lt;code&gt;.nim&lt;/code&gt; 被作为命令行参数传递到编译器的文件。</target>
        </trans-unit>
        <trans-unit id="2a72b0f5ef54ecdf16cb26a40bdbef5872800692" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; The API of FutureStream is still new and so has a higher likelihood of changing in the future.</source>
          <target state="translated">&lt;strong&gt;注意：&lt;/strong&gt; FutureStream的API仍然是新的，因此将来更改的可能性更高。</target>
        </trans-unit>
        <trans-unit id="fe5b130db131453d8df37e590c01fe6f08bec9e5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; The behaviour of this procedure changed in version 0.14.0. To get a list of usages and to restore the old behaviour of this procedure, compile with the &lt;code&gt;-d:nimJsonGet&lt;/code&gt; flag.</source>
          <target state="translated">&lt;strong&gt;注意：&lt;/strong&gt;此过程的行为在版本0.14.0中已更改。要获取用法列表并恢复该过程的旧行为，请使用 &lt;code&gt;-d:nimJsonGet&lt;/code&gt; 标志进行编译。</target>
        </trans-unit>
        <trans-unit id="b68055c0d51d611257c884fc1743a259d12fc766" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; The current implementation of message passing does not work with cyclic data structures.</source>
          <target state="translated">&lt;strong&gt;注意：&lt;/strong&gt;消息传递的当前实现不适用于循环数据结构。</target>
        </trans-unit>
        <trans-unit id="c072da5e00ce440c3b93018b2a1ef17e9ee5503c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; The current implementation of message passing does not work with cyclic data structures. &lt;strong&gt;Note:&lt;/strong&gt; Channels cannot be passed between threads. Use globals or pass them by &lt;em&gt;ptr&lt;/em&gt;.</source>
          <target state="translated">&lt;strong&gt;注意：&lt;/strong&gt;消息传递的当前实现不适用于循环数据结构。&lt;strong&gt;注意：&lt;/strong&gt;无法在线程之间传递通道。使用全局变量或通过&lt;em&gt;ptr&lt;/em&gt;传递它们。</target>
        </trans-unit>
        <trans-unit id="c053963c70f97a8b2121caf302c6833bc53f2f10" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; The encoding cannot be changed once it's been set. According to SQLite3 documentation, any attempt to change the encoding after the database is created will be silently ignored.</source>
          <target state="translated">&lt;strong&gt;注意：&lt;/strong&gt;编码一旦设置便无法更改。根据SQLite3文档，在创建数据库后更改编码的任何尝试都将被忽略。</target>
        </trans-unit>
        <trans-unit id="b999dbe7ed39e219e124bd0949367e2e3d56fe13" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; The resulting &lt;code&gt;XmlNode&lt;/code&gt; already uses the &lt;code&gt;clientData&lt;/code&gt; field, so it cannot be used by clients of this library.</source>
          <target state="translated">&lt;strong&gt;注意：&lt;/strong&gt;生成的 &lt;code&gt;XmlNode&lt;/code&gt; 已经使用了 &lt;code&gt;clientData&lt;/code&gt; 字段，因此该库的客户端无法使用它。</target>
        </trans-unit>
        <trans-unit id="eb469a558a1fb80f9ffa7a37d87dd2f9adc314d8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; The server may return multiple lines of coded replies.</source>
          <target state="translated">&lt;strong&gt;注意：&lt;/strong&gt;服务器可能会返回多行编码的答复。</target>
        </trans-unit>
        <trans-unit id="0d1eacb2a91de8906a2993f50f4d1523095b2af2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; There are no postfix operators in Nim. However, the &lt;code&gt;nnkPostfix&lt;/code&gt; node is used for the &lt;em&gt;asterisk export marker&lt;/em&gt;&lt;code&gt;*&lt;/code&gt;:</source>
          <target state="translated">&lt;strong&gt;注意：&lt;/strong&gt; Nim中没有后缀运算符。但是， &lt;code&gt;nnkPostfix&lt;/code&gt; 节点用于&lt;em&gt;星号导出标记&lt;/em&gt; &lt;code&gt;*&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="2f905a6d385133393b2c96347260edc54f46375a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; This does not preserve the new line characters used in &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;注意：&lt;/strong&gt;这不会保留 &lt;code&gt;s&lt;/code&gt; 中使用的换行符。</target>
        </trans-unit>
        <trans-unit id="b7811fa53cf7abdc675dfee2447ec973dd431ac0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; This function is not supported on &lt;code&gt;Windows&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;注意：&lt;/strong&gt; &lt;code&gt;Windows&lt;/code&gt; 不支持此功能。</target>
        </trans-unit>
        <trans-unit id="10e606a3da78b8e2b189b92aa03f1f5e54c1d549" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; This function is supported only by BSD and MacOSX.</source>
          <target state="translated">&lt;strong&gt;注意：&lt;/strong&gt;仅BSD和MacOSX支持此功能。</target>
        </trans-unit>
        <trans-unit id="cc104a0e857b282ec998816c0f3e015bee2d1e8b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; This is an experimental feature. It can be enabled with &lt;code&gt;{.experimental: &quot;notnil&quot;}&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;注意：&lt;/strong&gt;这是一个实验性功能。可以使用 &lt;code&gt;{.experimental: &quot;notnil&quot;}&lt;/code&gt; 启用它。</target>
        </trans-unit>
        <trans-unit id="a504100a18ce5297ff0a5435681c490ac8437f44" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; This is not very efficient.</source>
          <target state="translated">&lt;strong&gt;注意：&lt;/strong&gt;这不是很有效。</target>
        </trans-unit>
        <trans-unit id="e60296ba87e29cbb2d2d722997e0bc1d53551519" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; This logger is not available for the JavaScript backend.</source>
          <target state="translated">&lt;strong&gt;注意：&lt;/strong&gt;此记录器不适用于JavaScript后端。</target>
        </trans-unit>
        <trans-unit id="b24c06d6eed7edbd4cef00490b4db7c0ca199c4f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; This module currently only supports select(), this is limited by FD_SETSIZE, which is usually 1024. So you may only be able to use 1024 sockets at a time.</source>
          <target state="translated">&lt;strong&gt;注意：&lt;/strong&gt;该模块当前仅支持select（），这受FD_SETSIZE限制，通常为1024。因此，您一次只能使用1024个套接字。</target>
        </trans-unit>
        <trans-unit id="be757c0b40131a488a140d8d6a5f654644bde753" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; This proc is not available for SSL sockets.</source>
          <target state="translated">&lt;strong&gt;注意：&lt;/strong&gt;此过程不适用于SSL套接字。</target>
        </trans-unit>
        <trans-unit id="bada7c4bc2eb5a9723fa1a4e5f0977c09eb2e93e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; This proc is not available for the JavaScript backend.</source>
          <target state="translated">&lt;strong&gt;注意：&lt;/strong&gt;此过程不适用于JavaScript后端。</target>
        </trans-unit>
        <trans-unit id="72097e11d6435758e6d11a17ddc9ef4aaa3827e7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; This proc is not available in the JavaScript backend.</source>
          <target state="translated">&lt;strong&gt;注意：&lt;/strong&gt;此过程在JavaScript后端中不可用。</target>
        </trans-unit>
        <trans-unit id="e78137b9e08d95e0c1988f940939d1041367f9b3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; This uses different hashing algorithm than &lt;code&gt;hash(string)&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;注意：&lt;/strong&gt;这使用与 &lt;code&gt;hash(string)&lt;/code&gt; 不同的哈希算法。</target>
        </trans-unit>
        <trans-unit id="a4b46072c825ede32e475a77de0b13f39275d7ae" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; This will allocate a new &lt;code&gt;Mimetypes&lt;/code&gt; database every time you call it, you can pass your own via the &lt;code&gt;mimeDb&lt;/code&gt; parameter to avoid this.</source>
          <target state="translated">&lt;strong&gt;注意：&lt;/strong&gt;这将在每次调用它时分配一个新的 &lt;code&gt;Mimetypes&lt;/code&gt; 数据库，您可以通过 &lt;code&gt;mimeDb&lt;/code&gt; 参数传递自己的数据库来避免这种情况。</target>
        </trans-unit>
        <trans-unit id="8996a73c32006599330b4aacfeffcd8eabd847e9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; Under POSIX OS's, the returned time may actually be the time at which the file's attribute's were last modified. See &lt;a href=&quot;https://github.com/nim-lang/Nim/issues/1058&quot;&gt;here&lt;/a&gt; for details.</source>
          <target state="translated">&lt;strong&gt;注意：&lt;/strong&gt;在POSIX OS的情况下，返回的时间实际上可能是文件属性的最后修改时间。有关详细信息，请参见&lt;a href=&quot;https://github.com/nim-lang/Nim/issues/1058&quot;&gt;此处&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="08f986989f7c1fa9c2cfa29fe4aab7353d67faf6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; Use it only when you are &lt;strong&gt;absolutely sure&lt;/strong&gt; the value is present (e.g. after checking &lt;a href=&quot;#isSome,Option%5BT%5D&quot;&gt;isSome&lt;/a&gt;). Generally, using &lt;a href=&quot;#get,Option%5BT%5D&quot;&gt;get proc&lt;/a&gt; is preferred.</source>
          <target state="translated">&lt;strong&gt;注意：&lt;/strong&gt;仅当您&lt;strong&gt;完全确定&lt;/strong&gt;存在该值时才使用它（例如，在检查&lt;a href=&quot;#isSome,Option%5BT%5D&quot;&gt;isSome之后&lt;/a&gt;）。通常，首选使用&lt;a href=&quot;#get,Option%5BT%5D&quot;&gt;get proc&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4326e562047392c7a998b1d78e1b1453866d2345" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; You may wish to use the high-level version of this function which is defined below.</source>
          <target state="translated">&lt;strong&gt;注意：&lt;/strong&gt;您可能希望使用下面定义的此功能的高级版本。</target>
        </trans-unit>
        <trans-unit id="a987f98d420623ba5755baff3ce3a93970a01567" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; You need to run asynchronous examples in an async proc otherwise you will get an &lt;code&gt;Undeclared identifier: 'await'&lt;/code&gt; error.</source>
          <target state="translated">&lt;strong&gt;注意：&lt;/strong&gt;您需要在异步proc中运行异步示例，否则您将得到 &lt;code&gt;Undeclared identifier: 'await'&lt;/code&gt; 错误。</target>
        </trans-unit>
        <trans-unit id="18f7852fedb7919a22f8ce639864908dfafb58b1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; You will need to run asynchronous examples in an async proc otherwise you will get an &lt;code&gt;Undeclared identifier: 'await'&lt;/code&gt; error.</source>
          <target state="translated">&lt;strong&gt;注意：&lt;/strong&gt;您将需要在异步proc中运行异步示例，否则将获得 &lt;code&gt;Undeclared identifier: 'await'&lt;/code&gt; 错误。</target>
        </trans-unit>
        <trans-unit id="a7f5ae0bae2a97db2cc21e767ee5806933143eee" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; to serialize &lt;code&gt;x&lt;/code&gt; to JSON use &lt;code&gt;$(%x)&lt;/code&gt; from the &lt;code&gt;json&lt;/code&gt; module.</source>
          <target state="translated">&lt;strong&gt;注：&lt;/strong&gt;序列化 &lt;code&gt;x&lt;/code&gt; 到JSON使用 &lt;code&gt;$(%x)&lt;/code&gt; 从 &lt;code&gt;json&lt;/code&gt; 模块。</target>
        </trans-unit>
        <trans-unit id="bec8ba034600835b90eb455003ce0ac16f8f5171" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt;&lt;code&gt;getCurrentException()&lt;/code&gt; and &lt;code&gt;getCurrentExceptionMsg()&lt;/code&gt; are not available for imported exceptions from C++. One needs to use the &lt;code&gt;except ImportedException as x:&lt;/code&gt; syntax and rely on functionality of the &lt;code&gt;x&lt;/code&gt; object to get exception details.</source>
          <target state="translated">&lt;strong&gt;注意：&lt;/strong&gt; &lt;code&gt;getCurrentException()&lt;/code&gt; 和 &lt;code&gt;getCurrentExceptionMsg()&lt;/code&gt; 不适用于从C ++导入的异常。需要使用 &lt;code&gt;except ImportedException as x:&lt;/code&gt; 语法，并依赖 &lt;code&gt;x&lt;/code&gt; 对象的功能来获取异常详细信息。</target>
        </trans-unit>
        <trans-unit id="f2cd00a05c4e51c80b150666326157914820525e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Note&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e153549d82bb0553e51565bc85af72f16648f194" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: &lt;a href=&quot;c2nim&quot;&gt;c2nim&lt;/a&gt; can parse a large subset of C++ and knows about the &lt;code&gt;importcpp&lt;/code&gt; pragma pattern language. It is not necessary to know all the details described here.</source>
          <target state="translated">&lt;strong&gt;注意&lt;/strong&gt;：&lt;a href=&quot;c2nim&quot;&gt;c2nim&lt;/a&gt;可以解析C ++的较大子集，并且了解 &lt;code&gt;importcpp&lt;/code&gt; 编译模式语言。不必知道这里描述的所有细节。</target>
        </trans-unit>
        <trans-unit id="628a6cfa36ef34d2672ec1af4c7d21e0c80f03df" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: &lt;a href=&quot;https://github.com/nim-lang/c2nim/blob/master/doc/c2nim.rst&quot;&gt;c2nim&lt;/a&gt; can parse a large subset of C++ and knows about the &lt;code&gt;importcpp&lt;/code&gt; pragma pattern language. It is not necessary to know all the details described here.</source>
          <target state="translated">&lt;strong&gt;注意&lt;/strong&gt;：&lt;a href=&quot;https://github.com/nim-lang/c2nim/blob/master/doc/c2nim.rst&quot;&gt;c2nim&lt;/a&gt;可以解析C ++的较大子集，并且了解 &lt;code&gt;importcpp&lt;/code&gt; 杂注模式语言。不必知道这里描述的所有细节。</target>
        </trans-unit>
        <trans-unit id="f77e21e8d0104eaa0e42efbc8c62a054445fe5af" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: &lt;a href=&quot;manual#syntax-precedence&quot;&gt;Operator precedence&lt;/a&gt; is different than in &lt;em&gt;C&lt;/em&gt;.</source>
          <target state="translated">&lt;strong&gt;注意&lt;/strong&gt;：&lt;a href=&quot;manual#syntax-precedence&quot;&gt;运算符优先级&lt;/a&gt;与&lt;em&gt;C中的&lt;/em&gt;不同。</target>
        </trans-unit>
        <trans-unit id="c35a1cbcb5dda710b9a8fceaddc79fa8711972fc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: &lt;code&gt;--experimental:views&lt;/code&gt; is more effective with &lt;code&gt;--experimental:strictFuncs&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;注意&lt;/strong&gt;：-- &lt;code&gt;--experimental:views&lt;/code&gt; 与 &lt;code&gt;--experimental:strictFuncs&lt;/code&gt; 比较有效。</target>
        </trans-unit>
        <trans-unit id="2058773cc31994be378f849d22fa2b6e5de64f38" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: &lt;code&gt;=sink&lt;/code&gt; does not need to check for self-assignments. How self-assignments are handled is explained later in this document.</source>
          <target state="translated">&lt;strong&gt;注意&lt;/strong&gt;： &lt;code&gt;=sink&lt;/code&gt; 不需要检查自我分配。本文档稍后将说明如何处理自赋值。</target>
        </trans-unit>
        <trans-unit id="752ddb5d050c961f8013cbe90d4ad9d26a7ee13a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: &lt;code&gt;client&lt;/code&gt; must be initialised (with &lt;code&gt;new&lt;/code&gt;), this function makes no effort to initialise the &lt;code&gt;client&lt;/code&gt; variable.</source>
          <target state="translated">&lt;strong&gt;注意&lt;/strong&gt;：必须初始化 &lt;code&gt;client&lt;/code&gt; （使用 &lt;code&gt;new&lt;/code&gt; ），此功能不会初始化 &lt;code&gt;client&lt;/code&gt; 变量。</target>
        </trans-unit>
        <trans-unit id="449eaada440261e910e8e598da9c4ed1cfb68e61" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: &lt;code&gt;client&lt;/code&gt; needs to be initialised.</source>
          <target state="translated">&lt;strong&gt;注意&lt;/strong&gt;： &lt;code&gt;client&lt;/code&gt; 需要初始化。</target>
        </trans-unit>
        <trans-unit id="ed6c907ecc726f3524b1431bfea1378d7d591f2d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: &lt;code&gt;data&lt;/code&gt; must be initialised.</source>
          <target state="translated">&lt;strong&gt;注意&lt;/strong&gt;： &lt;code&gt;data&lt;/code&gt; 必须初始化。</target>
        </trans-unit>
        <trans-unit id="64c21c25b25fb13a012539ce3d92a2f60ed66909" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: &lt;code&gt;typeof(x)&lt;/code&gt; can for historical reasons also be written as &lt;code&gt;type(x)&lt;/code&gt; but &lt;code&gt;type(x)&lt;/code&gt; is discouraged.</source>
          <target state="translated">&lt;strong&gt;注意&lt;/strong&gt;：出于历史原因， &lt;code&gt;typeof(x)&lt;/code&gt; 也可以写为 &lt;code&gt;type(x)&lt;/code&gt; ,但不建议使用 &lt;code&gt;type(x)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="79f23d79481e20b54cf233e31f8767bbf0d80411" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: &lt;code&gt;var&lt;/code&gt; parameters are never necessary for efficient parameter passing. Since non-var parameters cannot be modified the compiler is always free to pass arguments by reference if it considers it can speed up execution.</source>
          <target state="translated">&lt;strong&gt;注意&lt;/strong&gt;： &lt;code&gt;var&lt;/code&gt; 参数对于有效的参数传递从不需要。由于不能修改非var参数，因此编译器如果认为可以加快执行速度，则始终可以按引用传递参数。</target>
        </trans-unit>
        <trans-unit id="917b6bc95e7e2268d07e2f344f8fb05732bc1b22" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: A &lt;code&gt;dynlib&lt;/code&gt; import can be overridden with the &lt;code&gt;--dynlibOverride:name&lt;/code&gt; command line option. The Compiler User Guide contains further information.</source>
          <target state="translated">&lt;strong&gt;注意&lt;/strong&gt;：可以使用 &lt;code&gt;--dynlibOverride:name&lt;/code&gt; 命令行选项覆盖 &lt;code&gt;dynlib&lt;/code&gt; 导入。《编译器用户指南》包含更多信息。</target>
        </trans-unit>
        <trans-unit id="aea57afb484ca3b2ae950510502c02d6d6d1b317" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: A &lt;code&gt;dynlib&lt;/code&gt; import can be overridden with the &lt;code&gt;--dynlibOverride:name&lt;/code&gt; command-line option. The Compiler User Guide contains further information.</source>
          <target state="translated">&lt;strong&gt;注意&lt;/strong&gt;：可以使用 &lt;code&gt;--dynlibOverride:name&lt;/code&gt; 命令行选项覆盖 &lt;code&gt;dynlib&lt;/code&gt; 导入。《编译器用户指南》包含更多信息。</target>
        </trans-unit>
        <trans-unit id="d69e89fc6e4fabdd63d8a15033a0affd20ea60f8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: According to HTTP/1.1 specification, the reason phrase is</source>
          <target state="translated">&lt;strong&gt;注意&lt;/strong&gt;：根据HTTP / 1.1规范，原因短语为</target>
        </trans-unit>
        <trans-unit id="a4c0c0109f9323e091c1b8f19f86e88886ea759e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: An &lt;span id=&quot;unresolved_1&quot;&gt;unresolved&lt;/span&gt; expression is an expression for which no symbol lookups and no type checking have been performed.</source>
          <target state="translated">&lt;strong&gt;注意&lt;/strong&gt;：&lt;span id=&quot;unresolved_1&quot;&gt;未解析的&lt;/span&gt;表达式是&lt;span id=&quot;unresolved_1&quot;&gt;未&lt;/span&gt;执行任何符号查找和类型检查的表达式。</target>
        </trans-unit>
        <trans-unit id="19158a8ced28ef096d6d098faea99e938f8aea45" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: As a special syntactic extension if the whole PEG is only a single expression, identifiers are not interpreted as non-terminals, but are interpreted as verbatim string:</source>
          <target state="translated">&lt;strong&gt;注意&lt;/strong&gt;：如果整个PEG仅是单个表达式，则作为特殊的语法扩展，标识符不会解释为非终结符，而是解释为逐字字符串：</target>
        </trans-unit>
        <trans-unit id="a646964958fc81cca21d1deac84d2ec91d7e8349" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: Assignments, moves, and destruction are specified in the &lt;a href=&quot;destructors&quot;&gt;destructors&lt;/a&gt; document.</source>
          <target state="translated">&lt;strong&gt;注意&lt;/strong&gt;：分配，移动和销毁在&lt;a href=&quot;destructors&quot;&gt;析构函数&lt;/a&gt;文档中指定。</target>
        </trans-unit>
        <trans-unit id="394b8821bf33b16092eceec91b4261c0182b2ffd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: Code reordering is experimental and must be enabled via the &lt;code&gt;{.experimental.}&lt;/code&gt; pragma.</source>
          <target state="translated">&lt;strong&gt;注意&lt;/strong&gt;：代码重新排序是实验性的，必须通过 &lt;code&gt;{.experimental.}&lt;/code&gt; 编译指示启用。</target>
        </trans-unit>
        <trans-unit id="15d3410cbe9aaa0f2ff2edaf757af2c7376b1329" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: Compile time evaluation is not (yet) supported for methods.</source>
          <target state="translated">&lt;strong&gt;注意&lt;/strong&gt;：方法尚不支持编译时间评估。</target>
        </trans-unit>
        <trans-unit id="1e9fb916a488d76befb6f270dcbc01bbe526c18b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: Compile-time execution is not (yet) supported for methods.</source>
          <target state="translated">&lt;strong&gt;注意&lt;/strong&gt;：方法尚不支持编译时执行。</target>
        </trans-unit>
        <trans-unit id="1ec4927b4c9fc829236a51cac7723591db8396a7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: Composition (&lt;em&gt;has-a&lt;/em&gt; relation) is often preferable to inheritance (&lt;em&gt;is-a&lt;/em&gt; relation) for simple code reuse. Since objects are value types in Nim, composition is as efficient as inheritance.</source>
          <target state="translated">&lt;strong&gt;注意&lt;/strong&gt;：对于简单的代码重用，组合（&lt;em&gt;具有-&lt;/em&gt;关系）通常优于继承（&lt;em&gt;具有-&lt;/em&gt;关系）。由于对象是Nim中的值类型，因此组合与继承一样有效。</target>
        </trans-unit>
        <trans-unit id="0f588e4000ab499174937baf99ba9de907f81477" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: Concepts are still in development.</source>
          <target state="translated">&lt;strong&gt;注意&lt;/strong&gt;：概念仍在开发中。</target>
        </trans-unit>
        <trans-unit id="af0cb2698b6f62001c812557400b5666b24c541b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: Currently exceptions are not propagated between &lt;code&gt;spawn&lt;/code&gt;'ed tasks!</source>
          <target state="translated">&lt;strong&gt;注意&lt;/strong&gt;：目前，异常不会在 &lt;code&gt;spawn&lt;/code&gt; 任务之间传播！</target>
        </trans-unit>
        <trans-unit id="d265fbeed3ef479118f8bab7a4ed8678ac73bc47" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: Currently the assignment operator &lt;code&gt;=&lt;/code&gt; for &lt;code&gt;IntSet&lt;/code&gt; performs some rather meaningless shallow copy. Since Nim currently does not allow the assignment operator to be overloaded, use &lt;a href=&quot;#assign,IntSet,IntSet&quot;&gt;assign proc&lt;/a&gt; to get a deep copy.</source>
          <target state="translated">&lt;strong&gt;注意&lt;/strong&gt;：当前， &lt;code&gt;IntSet&lt;/code&gt; 的赋值运算符 &lt;code&gt;=&lt;/code&gt; 执行一些相当无意义的浅表复制。由于Nim当前不允许重载赋值运算符，因此请使用&lt;a href=&quot;#assign,IntSet,IntSet&quot;&gt;assign proc&lt;/a&gt;来获取深层副本。</target>
        </trans-unit>
        <trans-unit id="e593de705b48a873244d353e72e0630bbbf7e8ed" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: Currently the compiler recognizes but ignores this pragma.</source>
          <target state="translated">&lt;strong&gt;注意&lt;/strong&gt;：当前，编译器可以识别但忽略此编译指示。</target>
        </trans-unit>
        <trans-unit id="1b2d5b76dbe4b87b85248e2c9cb6a142ec8c770f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: Currently the creation of &lt;code&gt;nimrtl.dll&lt;/code&gt; with thread support has never been tested and is unlikely to work!</source>
          <target state="translated">&lt;strong&gt;注意&lt;/strong&gt;：目前， &lt;code&gt;nimrtl.dll&lt;/code&gt; 带有线程支持的nimrtl.dll的创建进行过测试，因此不太可能成功！</target>
        </trans-unit>
        <trans-unit id="fb2822c93615d44b3b3cc5966ff533ff418b8724" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: Destructors are still experimental and the spec might change significantly in order to incorporate an escape analysis.</source>
          <target state="translated">&lt;strong&gt;注意&lt;/strong&gt;：析构函数仍处于实验阶段，为了合并逃逸分析，规格可能会发生重大变化。</target>
        </trans-unit>
        <trans-unit id="ee1ed6db845c184364f8097a01163d56d39e9c4d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: Dot operators are still experimental and so need to be enabled via &lt;code&gt;{.experimental: &quot;dotOperators&quot;.}&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;注意&lt;/strong&gt;：点运算符仍处于试验阶段，因此需要通过 &lt;code&gt;{.experimental: &quot;dotOperators&quot;.}&lt;/code&gt; 启用。</target>
        </trans-unit>
        <trans-unit id="d670368c6c2f5f22dc63498bef9e5233133587fd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: For Nim 1.0.x and older version, &lt;code&gt;zip&lt;/code&gt; returned a seq of named tuple with fields &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;. For Nim versions 1.1.x and newer, &lt;code&gt;zip&lt;/code&gt; returns a seq of unnamed tuples.</source>
          <target state="translated">&lt;strong&gt;注意&lt;/strong&gt;：对于Nim 1.0.x和更早版本， &lt;code&gt;zip&lt;/code&gt; 返回了一个名为tuple的序列，其中包含字段 &lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;b&lt;/code&gt; 。对于Nim 1.1.x及更高版本， &lt;code&gt;zip&lt;/code&gt; 返回未命名元组的序列。</target>
        </trans-unit>
        <trans-unit id="76687951273781b82f6f05a64604534fc897b54a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: For SSL sockets, the &lt;code&gt;handshake&lt;/code&gt; procedure must be called whenever the socket successfully connects to a server.</source>
          <target state="translated">&lt;strong&gt;注意&lt;/strong&gt;：对于SSL套接字，只要套接字成功连接到服务器，就必须调用 &lt;code&gt;handshake&lt;/code&gt; 过程。</target>
        </trans-unit>
        <trans-unit id="91e3db899bae0bbfb9a7d3d39b2d7c168b6e2d11" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: For historical reasons &lt;code&gt;stmt&lt;/code&gt; is an alias for &lt;code&gt;typed&lt;/code&gt; and &lt;code&gt;expr&lt;/code&gt; an alias for &lt;code&gt;untyped&lt;/code&gt;, but new code should use the newer, clearer names.</source>
          <target state="translated">&lt;strong&gt;注意&lt;/strong&gt;：由于历史原因， &lt;code&gt;stmt&lt;/code&gt; 是 &lt;code&gt;typed&lt;/code&gt; 的别名， &lt;code&gt;expr&lt;/code&gt; 是 &lt;code&gt;untyped&lt;/code&gt; 的别名，但是新代码应使用更新，更清晰的名称。</target>
        </trans-unit>
        <trans-unit id="c1eaf1a79f9ecb1c0d26ea4d5f7c22f8781d75d9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: For historical reasons &lt;code&gt;stmt&lt;/code&gt; was an alias for &lt;code&gt;typed&lt;/code&gt; and &lt;code&gt;expr&lt;/code&gt; was an alias for &lt;code&gt;untyped&lt;/code&gt;, but they are removed.</source>
          <target state="translated">&lt;strong&gt;注意&lt;/strong&gt;：由于历史原因， &lt;code&gt;stmt&lt;/code&gt; 是 &lt;code&gt;typed&lt;/code&gt; 的别名，而 &lt;code&gt;expr&lt;/code&gt; 是 &lt;code&gt;untyped&lt;/code&gt; 的别名，但是将其删除。</target>
        </trans-unit>
        <trans-unit id="35fa8c02b68bd348136724f65366d5d42363838f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: For historical reasons &lt;code&gt;varargs[expr]&lt;/code&gt; is not equivalent to &lt;code&gt;varargs[untyped]&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;注意&lt;/strong&gt;：由于历史原因， &lt;code&gt;varargs[expr]&lt;/code&gt; 不等同于 &lt;code&gt;varargs[untyped]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f4acf53db39aa60c86dd41398806d083a1a38011" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: Historically the operations were unchecked and the conversions were sometimes checked but starting with the revision 1.0.4 of this document and the language implementation the conversions too are now &lt;em&gt;always unchecked&lt;/em&gt;.</source>
          <target state="translated">&lt;strong&gt;注意&lt;/strong&gt;：从历史上看，不对操作进行检查，有时对转换进行检查，但是从本文档的1.0.4版和语言实现开始，现在也&lt;em&gt;始终不对&lt;/em&gt;转换进行&lt;em&gt;检查&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="cfadb62af1d09f91ea948f6071b29e23cceab2f5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: In general, the &lt;em&gt;define&lt;/em&gt; switches can also be set in NimScripts using &lt;code&gt;switch&lt;/code&gt; or &lt;code&gt;--&lt;/code&gt;, as shown in above examples. Only the &lt;code&gt;release&lt;/code&gt; define (&lt;code&gt;-d:release&lt;/code&gt;) cannot be set in NimScripts.</source>
          <target state="translated">&lt;strong&gt;注意&lt;/strong&gt;：通常，如上例所示，还可以使用 &lt;code&gt;switch&lt;/code&gt; 或 &lt;code&gt;--&lt;/code&gt; 在NimScripts中设置&lt;em&gt;定义&lt;/em&gt;开关。只有 &lt;code&gt;release&lt;/code&gt; 定义（ &lt;code&gt;-d:release&lt;/code&gt; ）不能在NimScripts设置。</target>
        </trans-unit>
        <trans-unit id="6a6d221cb0526b5b0ecc418d504b0327381bfb9b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: Instead of &lt;code&gt;unittest.nim&lt;/code&gt;, please consider to use the &lt;code&gt;testament&lt;/code&gt; tool which offers process isolation for your tests. Also &lt;code&gt;when isMainModule: doAssert conditionHere&lt;/code&gt; is usually a much simpler solution for testing purposes.</source>
          <target state="translated">&lt;strong&gt;注意&lt;/strong&gt;：请考虑使用 &lt;code&gt;testament&lt;/code&gt; 工具代替 &lt;code&gt;unittest.nim&lt;/code&gt; ，该工具为您的测试提供流程隔离。同样 &lt;code&gt;when isMainModule: doAssert conditionHere&lt;/code&gt; 这里通常是用于测试目的的简单得多的解决方案。</target>
        </trans-unit>
        <trans-unit id="8e02a608054219b27095b71a1aa9165e80b92873" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: Nim computes a SHA1 checksum and only recompiles the file if it has changed. One can use the &lt;code&gt;-f&lt;/code&gt; command-line option to force the recompilation of the file.</source>
          <target state="translated">&lt;strong&gt;注意&lt;/strong&gt;：Nim将计算SHA1校验和，并且仅在文件已更改时才重新编译。可以使用 &lt;code&gt;-f&lt;/code&gt; 命令行选项来强制重新编译文件。</target>
        </trans-unit>
        <trans-unit id="9cc5314fa7beb1755c498007976fd6bffd4a8741" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: Nim computes a SHA1 checksum and only recompiles the file if it has changed. You can use the &lt;code&gt;-f&lt;/code&gt; command line option to force recompilation of the file.</source>
          <target state="translated">&lt;strong&gt;注意&lt;/strong&gt;：Nim计算SHA1校验和，并且仅在文件已更改时才重新编译。您可以使用 &lt;code&gt;-f&lt;/code&gt; 命令行选项来强制重新编译文件。</target>
        </trans-unit>
        <trans-unit id="5388196ac73187f231ad39b82fb913ddc94a4bed" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: Nim currently does not detect these!</source>
          <target state="translated">&lt;strong&gt;注意&lt;/strong&gt;：Nim当前无法检测到这些！</target>
        </trans-unit>
        <trans-unit id="1271bb2722e7587eff37d0ec7806e796871dfb12" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: Openarrays can only be used for parameters.</source>
          <target state="translated">&lt;strong&gt;注意&lt;/strong&gt;：Openarray仅可用于参数。</target>
        </trans-unit>
        <trans-unit id="69090e5eea8eeff4b4d6ed39bda4ed8ea1e00303" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: Passing variables to the &lt;code&gt;dynlib&lt;/code&gt; pragma will fail at runtime because of order of initialization problems.</source>
          <target state="translated">&lt;strong&gt;注意&lt;/strong&gt;：由于初始化问题的顺序，将变量传递给 &lt;code&gt;dynlib&lt;/code&gt; 编译指示将在运行时失败。</target>
        </trans-unit>
        <trans-unit id="3d949419e5e8c75fc524d73127b46fd0d96b06e2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: Patterns like &lt;code&gt;libtcl(|8.5|8.4).so&lt;/code&gt; are only supported in constant strings, because they are precompiled.</source>
          <target state="translated">&lt;strong&gt;注意&lt;/strong&gt;：像 &lt;code&gt;libtcl(|8.5|8.4).so&lt;/code&gt; 这样的模式仅在常量字符串中受支持，因为它们已预编译。</target>
        </trans-unit>
        <trans-unit id="5c87c54173a7af7c54802abf0f3667ebc67c0bd5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: Read/write tracking is not yet implemented!</source>
          <target state="translated">&lt;strong&gt;注意&lt;/strong&gt;：尚未执行读/写跟踪！</target>
        </trans-unit>
        <trans-unit id="2f5d2ff34eda59be2af772bbe3e60f574635b531" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: Starting from Nim 0.20, generic methods are deprecated.</source>
          <target state="translated">&lt;strong&gt;注意&lt;/strong&gt;：从Nim 0.20开始，不赞成使用通用方法。</target>
        </trans-unit>
        <trans-unit id="935e75468fab30bc8f181842cd16bcdfa062c5e1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: The &lt;code&gt;.this&lt;/code&gt; pragma is deprecated and should not be used anymore.</source>
          <target state="translated">&lt;strong&gt;注意&lt;/strong&gt;： &lt;code&gt;.this&lt;/code&gt; 编译指示已被弃用，不应再使用。</target>
        </trans-unit>
        <trans-unit id="6bf5dca9c21d9d5aa4df461a3ff745da6884616f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: The &lt;code&gt;finalizer&lt;/code&gt; refers to the type &lt;code&gt;T&lt;/code&gt;, not to the object! This means that for each object of type &lt;code&gt;T&lt;/code&gt; the finalizer will be called!</source>
          <target state="translated">&lt;strong&gt;注意&lt;/strong&gt;： &lt;code&gt;finalizer&lt;/code&gt; 引用类型 &lt;code&gt;T&lt;/code&gt; ，而不是对象！这意味着对于每个 &lt;code&gt;T&lt;/code&gt; 类型的对象，终结器将被调用！</target>
        </trans-unit>
        <trans-unit id="e111e86a91d15663eda5e4e58e22260484c13d8f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: The &lt;code&gt;to&lt;/code&gt; and &lt;code&gt;$$&lt;/code&gt; operations are available at compile-time!</source>
          <target state="translated">&lt;strong&gt;注意&lt;/strong&gt;： &lt;code&gt;to&lt;/code&gt; 和 &lt;code&gt;$$&lt;/code&gt; 操作在编译时可用！</target>
        </trans-unit>
        <trans-unit id="03d9a64e63cab477a98b846aee1c6abff8cf07a7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: The Nim compiler prior to version 1 was more lenient about this requirement. Use the &lt;code&gt;--useVersion:0.19&lt;/code&gt; switch for a transition period.</source>
          <target state="translated">&lt;strong&gt;注意&lt;/strong&gt;：版本1之前的Nim编译器对此要求更为宽容。在过渡期间使用 &lt;code&gt;--useVersion:0.19&lt;/code&gt; 开关。</target>
        </trans-unit>
        <trans-unit id="032415bc42f7c2c0c686c44717cb2657050a5b9d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: The aliasing restrictions are currently not enforced by the implementation and need to be fleshed out further.</source>
          <target state="translated">&lt;strong&gt;注意&lt;/strong&gt;：混叠限制当前未由实现强制实施，需要进一步充实。</target>
        </trans-unit>
        <trans-unit id="1f9fdb234ef8ab9ea0cd0ee243a725c77f4c3646" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: The asynchronous implementation is only asynchronous for long file transfers, calls to functions which use the command socket will block.</source>
          <target state="translated">&lt;strong&gt;注意&lt;/strong&gt;：异步实现仅对于长文件传输是异步的，使用命令套接字的函数调用将被阻止。</target>
        </trans-unit>
        <trans-unit id="21b5006b1c5b3e0551182aafd1ac04017eed31d3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: The data types declared here have &lt;em&gt;value semantics&lt;/em&gt;: This means that &lt;code&gt;=&lt;/code&gt; performs a copy of the set.</source>
          <target state="translated">&lt;strong&gt;注意&lt;/strong&gt;：这里声明的数据类型具有&lt;em&gt;值语义&lt;/em&gt;：这意味着 &lt;code&gt;=&lt;/code&gt; 执行该集合的副本。</target>
        </trans-unit>
        <trans-unit id="280898b023d47a8c9d92f2a9764ba5070e544d38" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: The example only works because the memory is initialized to zero (&lt;code&gt;alloc0&lt;/code&gt; instead of &lt;code&gt;alloc&lt;/code&gt; does this): &lt;code&gt;d.s&lt;/code&gt; is thus initialized to binary zero which the string assignment can handle. One needs to know low level details like this when mixing garbage collected data with unmanaged memory.</source>
          <target state="translated">&lt;strong&gt;注意&lt;/strong&gt;：该示例仅起作用，因为内存已初始化为零（用 &lt;code&gt;alloc0&lt;/code&gt; 而不是 &lt;code&gt;alloc&lt;/code&gt; 进行此操作）：因此， &lt;code&gt;d.s&lt;/code&gt; 初始化为字符串赋值可以处理的二进制零。将垃圾收集的数据与非托管内存混合时，需要了解这样的低级详细信息。</target>
        </trans-unit>
        <trans-unit id="0029ff03975d512a536084038b6c01735900bacd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: The example only works because the memory is initialized to zero (&lt;code&gt;alloc0&lt;/code&gt; instead of &lt;code&gt;alloc&lt;/code&gt; does this): &lt;code&gt;d.s&lt;/code&gt; is thus initialized to binary zero which the string assignment can handle. One needs to know low-level details like this when mixing garbage-collected data with unmanaged memory.</source>
          <target state="translated">&lt;strong&gt;注意&lt;/strong&gt;：该示例仅起作用，因为内存已初始化为零（用 &lt;code&gt;alloc0&lt;/code&gt; 而不是 &lt;code&gt;alloc&lt;/code&gt; 进行此操作）：因此， &lt;code&gt;d.s&lt;/code&gt; 初始化为字符串赋值可以处理的二进制零。在将垃圾收集的数据与非托管内存混合时，需要了解诸如此类的低级详细信息。</target>
        </trans-unit>
        <trans-unit id="f70c58fd6b5bff5d5008569af769d29c9fc79ae2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: The experimental features of Nim are covered &lt;a href=&quot;manual_experimental&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;注意&lt;/strong&gt;：&lt;a href=&quot;manual_experimental&quot;&gt;此处&lt;/a&gt;介绍Nim的实验功能。</target>
        </trans-unit>
        <trans-unit id="0bc930249dbf7dab3ed38153c8153f17bf2fbf3e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: The precise result values depend on the used C runtime library and can differ between operating systems!</source>
          <target state="translated">&lt;strong&gt;注意&lt;/strong&gt;：精确的结果值取决于使用的C运行时库，并且在不同的操作系统之间可能会有所不同！</target>
        </trans-unit>
        <trans-unit id="47964f4e63f9364071ab4aeb6d699ff7f8c08bcd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: There are also &lt;code&gt;--assumedef&lt;/code&gt; and &lt;code&gt;--assumendef&lt;/code&gt; command line options that can be used for the same purpose.</source>
          <target state="translated">&lt;strong&gt;注意&lt;/strong&gt;：还有 &lt;code&gt;--assumedef&lt;/code&gt; 和 &lt;code&gt;--assumendef&lt;/code&gt; 命令行选项可用于相同目的。</target>
        </trans-unit>
        <trans-unit id="beec5a850cfc6f7745e1b0ecb5a58d4d3717ffad" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: There are also &lt;code&gt;--prefix&lt;/code&gt; and &lt;code&gt;--suffix&lt;/code&gt; command line options that can be used for the same purpose.</source>
          <target state="translated">&lt;strong&gt;注意&lt;/strong&gt;：还有 &lt;code&gt;--prefix&lt;/code&gt; 和 &lt;code&gt;--suffix&lt;/code&gt; 命令行选项可用于相同目的。</target>
        </trans-unit>
        <trans-unit id="69ba15cf193dfbb62171a2742d239684c78daa69" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: There are also &lt;code&gt;--stdcall&lt;/code&gt; and &lt;code&gt;--cdecl&lt;/code&gt; command line options that can be used for the same purpose.</source>
          <target state="translated">&lt;strong&gt;注意&lt;/strong&gt;：还有 &lt;code&gt;--stdcall&lt;/code&gt; 和 &lt;code&gt;--cdecl&lt;/code&gt; 命令行选项可用于相同目的。</target>
        </trans-unit>
        <trans-unit id="6eae5a3b83fbed6b6c57ab8bbef30bd246b16faa" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: There are two approaches to parameter substitution support by this module.</source>
          <target state="translated">&lt;strong&gt;注意&lt;/strong&gt;：此模块有两种方法支持参数替换。</target>
        </trans-unit>
        <trans-unit id="ee188be1bbae9b44b94cfc6f97f02261fdde6c36" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: There are two different allowed implementation strategies:</source>
          <target state="translated">&lt;strong&gt;注意&lt;/strong&gt;：有两种不同的允许实施策略：</target>
        </trans-unit>
        <trans-unit id="a5a42997a6733b871213621a8b95f824a807c7b7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: There is also a &lt;code&gt;--dynlib&lt;/code&gt; command line option that can be used for the same purpose.</source>
          <target state="translated">&lt;strong&gt;注意&lt;/strong&gt;：还有 &lt;code&gt;--dynlib&lt;/code&gt; 命令行选项可用于相同目的。</target>
        </trans-unit>
        <trans-unit id="7af996a9b1410d0551b826fcf6f31d2982be4597" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: There is also a &lt;code&gt;--header&lt;/code&gt; command line option that can be used for the same purpose.</source>
          <target state="translated">&lt;strong&gt;注意&lt;/strong&gt;：还有一个 &lt;code&gt;--header&lt;/code&gt; 命令行选项可用于相同目的。</target>
        </trans-unit>
        <trans-unit id="0f6e6a5551e301a9206be409821f73e8efe724ae" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: There is also a &lt;code&gt;--skipcomments&lt;/code&gt; command line option that can be used for the same purpose.</source>
          <target state="translated">&lt;strong&gt;注意&lt;/strong&gt;：还有一个 &lt;code&gt;--skipcomments&lt;/code&gt; 命令行选项可用于相同目的。</target>
        </trans-unit>
        <trans-unit id="24001770e3fa5f62c6de4221e4016da922b0b6b6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: There is also a &lt;code&gt;--skipinclude&lt;/code&gt; command line option that can be used for the same purpose.</source>
          <target state="translated">&lt;strong&gt;注意&lt;/strong&gt;：还有一个 &lt;code&gt;--skipinclude&lt;/code&gt; 命令行选项可用于相同目的。</target>
        </trans-unit>
        <trans-unit id="2a3d0067cf0a534d5914217a3b18410a03771aa4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: There is also a &lt;code&gt;--typeprefixes&lt;/code&gt; command line option that can be used for the same purpose.</source>
          <target state="translated">&lt;strong&gt;注意&lt;/strong&gt;：还有一个 &lt;code&gt;--typeprefixes&lt;/code&gt; 命令行选项可用于相同目的。</target>
        </trans-unit>
        <trans-unit id="e18e21cf48841adbc9777187ae8968f7fba53e98" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: This document is a draft! Several of Nim's features may need more precise wording. This manual is constantly evolving into a proper specification.</source>
          <target state="translated">&lt;strong&gt;注意&lt;/strong&gt;：本文档为草稿！Nim的某些功能可能需要更精确的措辞。本手册不断发展成为适当的规格。</target>
        </trans-unit>
        <trans-unit id="2aa2ab11076fb4ba0e0d90bade6f9b388734484a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: This fails to count to &lt;code&gt;high(int)&lt;/code&gt; if T = int for efficiency reasons.</source>
          <target state="translated">&lt;strong&gt;注意&lt;/strong&gt;：出于效率原因，如果T = int，则此计数不能计入 &lt;code&gt;high(int)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="567715e1f13e193fbfbf1198cf956b11412e00c3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: This fails to count to &lt;code&gt;low(int)&lt;/code&gt; if T = int for efficiency reasons.</source>
          <target state="translated">&lt;strong&gt;注意&lt;/strong&gt;：由于效率原因，如果T = int，则此计数不能计入 &lt;code&gt;low(int)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3533bf7103759fe5e503b595e40df4e4b28e6da3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: This is &lt;strong&gt;not correct&lt;/strong&gt; for producing Ansi C code!</source>
          <target state="translated">&lt;strong&gt;注意&lt;/strong&gt;：这对于生成Ansi C代码是&lt;strong&gt;不正确&lt;/strong&gt;的！</target>
        </trans-unit>
        <trans-unit id="054e7ea2fe4b0d2089c5eb61f38663920957149a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: This is a low-level function, you may be interested in the higher level versions of this function which are also named &lt;code&gt;recv&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;注意&lt;/strong&gt;：这是一个低级函数，您可能对该函数的更高版本（也称为 &lt;code&gt;recv&lt;/code&gt; )感兴趣。</target>
        </trans-unit>
        <trans-unit id="5282ba94e7660dfc3a29bcd1eed3c48d245d27d9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: This is a low-level version of &lt;code&gt;send&lt;/code&gt;. You likely should use the version below.</source>
          <target state="translated">&lt;strong&gt;注意&lt;/strong&gt;：这是 &lt;code&gt;send&lt;/code&gt; 的低级版本。您可能应该使用以下版本。</target>
        </trans-unit>
        <trans-unit id="ed9daeb8e2aec5a4f06a14063ad786a38c80a1d8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: This is dangerous to use as it encourages races. It's much better to use &lt;a href=&quot;#tryRecv,Channel%5BTMsg%5D&quot;&gt;tryRecv proc&lt;/a&gt; instead.</source>
          <target state="translated">&lt;strong&gt;注意&lt;/strong&gt;：使用此方法很危险，因为它会鼓励比赛。最好改用&lt;a href=&quot;#tryRecv,Channel%5BTMsg%5D&quot;&gt;tryRecv proc&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a3557f4c5da279c0358c73497195e9e969d921ea" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: This is part of the system module. Do not import it directly. To activate thread support compile with the &lt;code&gt;--threads:on&lt;/code&gt; command line switch.</source>
          <target state="translated">&lt;strong&gt;注意&lt;/strong&gt;：这是系统模块的一部分。不要直接导入。要激活线程支持，请使用 &lt;code&gt;--threads:on&lt;/code&gt; 命令行开关进行编译。</target>
        </trans-unit>
        <trans-unit id="49259d4a9dac22acd343c8e255eecad4c524a642" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: This is part of the system module. Do not import it directly. To activate thread support you need to compile with the &lt;code&gt;--threads:on&lt;/code&gt; command line switch.</source>
          <target state="translated">&lt;strong&gt;注意&lt;/strong&gt;：这是系统模块的一部分。不要直接导入。要激活线程支持，您需要使用 &lt;code&gt;--threads:on&lt;/code&gt; 命令行开关进行编译。</target>
        </trans-unit>
        <trans-unit id="a69e35e7b9f3081695456106f46697c03ffedd82" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: This module is deprecated since version 0.11.3. You should use the async version of this module &lt;a href=&quot;asyncftpclient&quot;&gt;asyncftpclient&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;注意&lt;/strong&gt;：从0.11.3版本开始不推荐使用此模块。您应该使用此模块的异步版本&lt;a href=&quot;asyncftpclient&quot;&gt;asyncftpclient&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d2aa27f677d4a034cdeb59f9e8f5be392614db71" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: This pragma should only be used by procs which consist solely of assembler statements.</source>
          <target state="translated">&lt;strong&gt;注意&lt;/strong&gt;：此编译指示只能由仅由汇编程序语句组成的proc使用。</target>
        </trans-unit>
        <trans-unit id="c3942176661636505e686cd1e170c9c2c66c7838" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: This pragma will not exist for the LLVM backend.</source>
          <target state="translated">&lt;strong&gt;注意&lt;/strong&gt;：LLVM后端不存在此杂&lt;strong&gt;注&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="d247c6d12bb22bba349cec5690833cc3a153b0fe" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: This proc is only occasionally useful, better use the &lt;a href=&quot;parseopt&quot;&gt;parseopt module&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;注意&lt;/strong&gt;：此proc仅偶尔使用，最好使用&lt;a href=&quot;parseopt&quot;&gt;parseopt模块&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e370238e58db64e0d5e09298f252112f6df12b8b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: This procedure is mostly used for testing. You likely want to use &lt;code&gt;asyncnet.recvLine&lt;/code&gt; instead.</source>
          <target state="translated">&lt;strong&gt;注意&lt;/strong&gt;：此过程主要用于测试。您可能想改用 &lt;code&gt;asyncnet.recvLine&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="322b2c09d6ee80b4e8d9ee5e387bb8ede9f8c9b0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: This procedure will &lt;strong&gt;NOT&lt;/strong&gt; register &lt;code&gt;fd&lt;/code&gt; with the global async dispatcher. You need to do this manually. If you have used &lt;code&gt;newAsyncNativeSocket&lt;/code&gt; to create &lt;code&gt;fd&lt;/code&gt; then it's already registered.</source>
          <target state="translated">&lt;strong&gt;注&lt;/strong&gt;：此过程将&lt;strong&gt;不&lt;/strong&gt;注册 &lt;code&gt;fd&lt;/code&gt; 与全球异步调度。您需要手动执行此操作。如果您已使用 &lt;code&gt;newAsyncNativeSocket&lt;/code&gt; 创建 &lt;code&gt;fd&lt;/code&gt; ,则该fd已被注册。</target>
        </trans-unit>
        <trans-unit id="69d44c4cf9df913ee690fbbedde86b19492609d3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: This results in non-deterministic behaviour and should be avoided.</source>
          <target state="translated">&lt;strong&gt;注意&lt;/strong&gt;：这会导致不确定的行为，应避免使用。</target>
        </trans-unit>
        <trans-unit id="518d5e4c7535845c8e9c442146b53d59a9b2f210" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: This section describes the current implementation. This part of the language specification will be changed. See &lt;a href=&quot;https://github.com/nim-lang/RFCs/issues/230&quot;&gt;https://github.com/nim-lang/RFCs/issues/230&lt;/a&gt; for more information.</source>
          <target state="translated">&lt;strong&gt;注意&lt;/strong&gt;：本节描述当前的实现。语言规范的这一部分将被更改。有关更多信息，请参见&lt;a href=&quot;https://github.com/nim-lang/RFCs/issues/230&quot;&gt;https://github.com/nim-lang/RFCs/issues/230&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d932869f99df24b8242ec488c4a11db3770fcfc1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: This will not work for the LLVM backend.</source>
          <target state="translated">&lt;strong&gt;注意&lt;/strong&gt;：这不适用于LLVM后端。</target>
        </trans-unit>
        <trans-unit id="36372381e9ac840b308a26506bae63970c747486" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: This will set &lt;code&gt;sock&lt;/code&gt; to be non-blocking.</source>
          <target state="translated">&lt;strong&gt;注意&lt;/strong&gt;：这会将 &lt;code&gt;sock&lt;/code&gt; 设置为非阻塞。</target>
        </trans-unit>
        <trans-unit id="d2b79b4545224be391a1d3f8ef925b80e4e045ef" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: Unless otherwise indicated, these features are not to be removed, but refined and overhauled.</source>
          <target state="translated">&lt;strong&gt;注意&lt;/strong&gt;：除非另有说明，否则不要删除这些功能，而是对其进行完善和大修。</target>
        </trans-unit>
        <trans-unit id="639f9874d8270608fdc7d69cf3882e85dfa3e245" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: When you use it to write a wrapper for a C library, you should always check that the original library does never write to data behind the pointer that is returned from this procedure.</source>
          <target state="translated">&lt;strong&gt;注意&lt;/strong&gt;：使用它编写C库的包装时，应始终检查原始库是否永远不会在此过程返回的指针后面写入数据。</target>
        </trans-unit>
        <trans-unit id="8563457a94cb48f3c140f57c68dfa33fbbbe81a8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: paths are not normalized to determine &lt;code&gt;isHidden&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;注意&lt;/strong&gt;：路径未规范化以确定 &lt;code&gt;isHidden&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1223df2703569d7a264f78da6a04381483fe3ce4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: static[T] is still in development.</source>
          <target state="translated">&lt;strong&gt;注意&lt;/strong&gt;：static [T]仍在开发中。</target>
        </trans-unit>
        <trans-unit id="cfc7fae090374e3f5581cc6d980013b1b5608dd9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: this proc does not exist while using the JS backend.</source>
          <target state="translated">&lt;strong&gt;注意&lt;/strong&gt;：使用JS后端时，此proc不存在。</target>
        </trans-unit>
        <trans-unit id="ef937726101d6bbf1ea792d981c362dd127505c0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Notes:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Notes:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e42fbe4240560deae4f59c3edc3b41aa2d7beba4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Notes&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Notes&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c903f2c52589e7acc68bf776349122058e049fc2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Notice&lt;/strong&gt; - more important information that users should be notified about</source>
          <target state="translated">&lt;strong&gt;注意&lt;/strong&gt;-应向用户通知更多重要信息</target>
        </trans-unit>
        <trans-unit id="3999835082895c400051c08efff687fac9d5116a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Performance note&lt;/strong&gt;: Nim does not produce a virtual method table, but generates dispatch trees. This avoids the expensive indirect branch for method calls and enables inlining. However, other optimizations like compile time evaluation or dead code elimination do not work with methods.</source>
          <target state="translated">&lt;strong&gt;性能说明&lt;/strong&gt;：Nim不会生成虚拟方法表，但会生成调度树。这避免了方法调用的昂贵的间接分支，并启用了内联。但是，其他优化（例如编译时评估或消除无效代码）不适用于这些方法。</target>
        </trans-unit>
        <trans-unit id="264a251f5075a4fdc9f3139ede36b3cff78c8711" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Please do not use this&lt;/strong&gt;: On Android, it currently returns &lt;code&gt;getHomeDir()&lt;/code&gt;, and on other Unix based systems it can cause security problems too. That said, you can override this implementation by adding &lt;code&gt;-d:tempDir=mytempname&lt;/code&gt; to your compiler invocation.</source>
          <target state="translated">&lt;strong&gt;请不要使用此方法&lt;/strong&gt;：在Android上，它当前返回 &lt;code&gt;getHomeDir()&lt;/code&gt; ，而在其他基于Unix的系统上，它也可能导致安全问题。也就是说，您可以通过在编译器调用中添加 &lt;code&gt;-d:tempDir=mytempname&lt;/code&gt; 来覆盖此实现。</target>
        </trans-unit>
        <trans-unit id="23e826b6b4ecba08efbc3138c61cefb888e1c674" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Please do not use this&lt;/strong&gt;: On Android, it currently returns &lt;code&gt;getHomeDir()&lt;/code&gt;, and on other Unix based systems it can cause security problems too. That said, you can override this implementation by adding &lt;code&gt;-d:tempDir=mytempname&lt;/code&gt; to your compiler invokation.</source>
          <target state="translated">&lt;strong&gt;请不要使用此方法&lt;/strong&gt;：在Android上，它当前返回 &lt;code&gt;getHomeDir()&lt;/code&gt; ，而在其他基于Unix的系统上，它也可能导致安全问题。也就是说，您可以通过在编译器调用中添加 &lt;code&gt;-d:tempDir=mytempname&lt;/code&gt; 来覆盖此实现。</target>
        </trans-unit>
        <trans-unit id="270d375af3bf0ef2adcd5f8fc2f75af783697ee1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Restriction&lt;/strong&gt;: For objects their type is &lt;strong&gt;not&lt;/strong&gt; serialized. This means essentially that it does not work if the object has some other runtime type than its compiletime type.</source>
          <target state="translated">&lt;strong&gt;限制&lt;/strong&gt;：对于对象，其类型&lt;strong&gt;未&lt;/strong&gt;序列化。这实际上意味着，如果对象具有其编译时类型以外的其他运行时类型，则该对象将不起作用。</target>
        </trans-unit>
        <trans-unit id="af53126db5be4c8aab90d27d5734b3708b192d3e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Restriction&lt;/strong&gt;: For objects their type is &lt;strong&gt;not&lt;/strong&gt; serialized. This means essentially that it does not work if the object has some other runtime type than its compiletime type:</source>
          <target state="translated">&lt;strong&gt;限制&lt;/strong&gt;：对于对象，其类型&lt;strong&gt;未&lt;/strong&gt;序列化。从本质上讲，这意味着如果对象具有不同于其编译时类型的其他运行时类型，则它将不起作用：</target>
        </trans-unit>
        <trans-unit id="551e0b7660ec60a1ba024654ebf85dd6e11ea8a2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;See also:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;也可以看看：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7186d0046c17a6da25a9438f95b74f4eee397d1f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;See also&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;另请参阅&lt;/strong&gt;：</target>
        </trans-unit>
        <trans-unit id="1d6c6b236d8abec1257912f6c53339b4b244db44" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Since&lt;/strong&gt; version 1.2.</source>
          <target state="translated">&lt;strong&gt;从&lt;/strong&gt;1.2版开始。</target>
        </trans-unit>
        <trans-unit id="ca02299d53be025106a7089f4b7c5750dcd3dd98" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Since&lt;/strong&gt;: Version 1.2.</source>
          <target state="translated">&lt;strong&gt;从&lt;/strong&gt;：1.2版开始。</target>
        </trans-unit>
        <trans-unit id="92e0079e41a5b0f8de60d18697948189f4c07fdd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Style note&lt;/strong&gt;: For code readability, it is the best idea to use the least powerful programming construct that still suffices. So the &quot;check list&quot; is:</source>
          <target state="translated">&lt;strong&gt;样式说明&lt;/strong&gt;：为了使代码易于阅读，最好的方法是使用仍然足够满足要求的功能最弱的编程结构。因此，&amp;ldquo;检查清单&amp;rdquo;为：</target>
        </trans-unit>
        <trans-unit id="fe1515dd837d06ebdfb95963f4b433b9a9c3985a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Third column&lt;/strong&gt;: module + [n scope nesting] + const name.</source>
          <target state="translated">&lt;strong&gt;第三列&lt;/strong&gt;：模块+ [n作用域嵌套] + const名称。</target>
        </trans-unit>
        <trans-unit id="89fa1ce97e4b1a8bbc8a7bdf79f0c84b5531d6c9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Third column&lt;/strong&gt;: module + [n scope nesting] + enum type + enum field name.</source>
          <target state="translated">&lt;strong&gt;第三列&lt;/strong&gt;：模块+ [n范围嵌套] +枚举类型+枚举字段名称。</target>
        </trans-unit>
        <trans-unit id="44cc69c566e0009f6ccc0fbac4d3567a0268b727" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Third column&lt;/strong&gt;: module + [n scope nesting] + iterator name.</source>
          <target state="translated">&lt;strong&gt;第三列&lt;/strong&gt;：模块+ [n作用域嵌套] +迭代器名称。</target>
        </trans-unit>
        <trans-unit id="821988216adbe7cd1954ec0da5648027ef8dc44d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Third column&lt;/strong&gt;: module + [n scope nesting] + let name.</source>
          <target state="translated">&lt;strong&gt;第三列&lt;/strong&gt;：模块+ [n范围嵌套] +让名称。</target>
        </trans-unit>
        <trans-unit id="57a25e461776b40d157a649de93257f5fe549d65" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Third column&lt;/strong&gt;: module + [n scope nesting] + macro name.</source>
          <target state="translated">&lt;strong&gt;第三列&lt;/strong&gt;：模块+ [n作用域嵌套] +宏名称。</target>
        </trans-unit>
        <trans-unit id="3166d2d68e6f9702d538e16e0e365a37f0f31329" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Third column&lt;/strong&gt;: module + [n scope nesting] + method name.</source>
          <target state="translated">&lt;strong&gt;第三列&lt;/strong&gt;：模块+ [n范围嵌套] +方法名称。</target>
        </trans-unit>
        <trans-unit id="061167cd91100dd105e9d11351199c7b83c16430" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Third column&lt;/strong&gt;: module + [n scope nesting] + name.</source>
          <target state="translated">&lt;strong&gt;第三列&lt;/strong&gt;：模块+ [n作用域嵌套] +名称。</target>
        </trans-unit>
        <trans-unit id="acf85825d2dfb7a2233737f8ada9679976415f1a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Third column&lt;/strong&gt;: module + [n scope nesting] + param name.</source>
          <target state="translated">&lt;strong&gt;第三列&lt;/strong&gt;：模块+ [n范围嵌套] +参数名称。</target>
        </trans-unit>
        <trans-unit id="546e3a8202699c79b7b925592249d4072a1845aa" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Third column&lt;/strong&gt;: module + [n scope nesting] + proc name.</source>
          <target state="translated">&lt;strong&gt;第三列&lt;/strong&gt;：模块+ [n作用域嵌套] + proc名称。</target>
        </trans-unit>
        <trans-unit id="e1aaee074e6af2e4ed1a60de85b378cc36322c99" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Third column&lt;/strong&gt;: module + [n scope nesting] + result.</source>
          <target state="translated">&lt;strong&gt;第三列&lt;/strong&gt;：模块+ [n范围嵌套] +结果。</target>
        </trans-unit>
        <trans-unit id="ca9583e48baa25b1239a744bd75804685b9425dd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Third column&lt;/strong&gt;: module + [n scope nesting] + template name.</source>
          <target state="translated">&lt;strong&gt;第三列&lt;/strong&gt;：模块+ [n作用域嵌套] +模板名称。</target>
        </trans-unit>
        <trans-unit id="e445dd6209bef0d057963888553bf05a22332bbe" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Third column&lt;/strong&gt;: module + [n scope nesting] + type name.</source>
          <target state="translated">&lt;strong&gt;第三列&lt;/strong&gt;：模块+ [n作用域嵌套] +类型名称。</target>
        </trans-unit>
        <trans-unit id="0e96cb006b66e97d61d546d8e4a627270ae7af33" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Third column&lt;/strong&gt;: module + [n scope nesting] + var name.</source>
          <target state="translated">&lt;strong&gt;第三列&lt;/strong&gt;：模块+ [n作用域嵌套] + var名称。</target>
        </trans-unit>
        <trans-unit id="b3006c2816bec11bab560e7a41a6685d7e93896b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;This can introduce duplicate keys into the table!&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;这样可以在表中引入重复的键！&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2af56b1d80809997309a7af75799485c7602c39f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;This function returns nil in case of failure.&lt;/strong&gt; To prevent unexpected behavior and ensure proper error handling, use &lt;a href=&quot;#openFileStream,string,FileMode,int&quot;&gt;openFileStream proc&lt;/a&gt; instead.</source>
          <target state="translated">&lt;strong&gt;如果失败，此函数返回nil。&lt;/strong&gt;为了防止意外行为并确保正确的错误处理，请改用&lt;a href=&quot;#openFileStream,string,FileMode,int&quot;&gt;openFileStream proc&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="96622873fb587ed595611ae4d0e283ece6697a93" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;This is deprecated and should not be used&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt;不推荐使用此方法，不应使用它&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="10a71a1eac5a42f1dd6af4ba8a70a197d215c43e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;This is destructive! You must not modify `t` afterwards!&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;这是破坏性的！之后，您一定不能修改`t`！&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a662d6054458a0060ff420609cf598e4d55cd58c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;This proc is deprecated&lt;/strong&gt;, use this one instead:</source>
          <target state="translated">&lt;strong&gt;不推荐&lt;/strong&gt;使用&lt;strong&gt;此proc&lt;/strong&gt;，请改用&lt;strong&gt;此proc&lt;/strong&gt;：</target>
        </trans-unit>
        <trans-unit id="cf55f81e21c6bb396948994d75bed92009d6333c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;This procedure is dangerous!&lt;/strong&gt; If one forgets to free the memory a leak occurs; if one tries to access freed memory (or just freeing it twice!) a core dump may happen or other memory may be corrupted.</source>
          <target state="translated">&lt;strong&gt;此过程很危险！&lt;/strong&gt;如果忘记了释放内存，就会发生泄漏；如果尝试访问已释放的内存（或仅将其释放两次！），则可能发生核心转储或其他内存已损坏。</target>
        </trans-unit>
        <trans-unit id="5a9df7eca11b12855add51f036ea9d3d1ea8ae1f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Usage in JavaScript projects:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;在JavaScript项目中的用法：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f768badd17da7a214c1ade1aa6c0fd2496dfda9d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;WARNING:&lt;/strong&gt; If the process has not finished executing, this will forcibly terminate the process. Doing so may result in zombie processes and &lt;a href=&quot;http://stackoverflow.com/questions/27021641/how-to-fix-request-failed-on-channel-0&quot;&gt;pty leaks&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;警告：&lt;/strong&gt;如果该进程尚未完成执行，则将强制终止该进程。这样做可能会导致僵尸进程和&lt;a href=&quot;http://stackoverflow.com/questions/27021641/how-to-fix-request-failed-on-channel-0&quot;&gt;pty泄漏&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="50465587dfd75b16c359e7f658dcbcaeabb41165" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;WARNING:&lt;/strong&gt; If the process has not finished executing, this will forcibly terminate the process. Doing so may result in zombie processes and &lt;a href=&quot;https://stackoverflow.com/questions/27021641/how-to-fix-request-failed-on-channel-0&quot;&gt;pty leaks&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;警告：&lt;/strong&gt;如果该进程尚未完成执行，则将强制终止该进程。这样做可能会导致僵尸进程和&lt;a href=&quot;https://stackoverflow.com/questions/27021641/how-to-fix-request-failed-on-channel-0&quot;&gt;pty泄漏&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="94d394e5f72cbfd85f56d413e8a616ed5c6c4fe9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;WARNING:&lt;/strong&gt; This function uses &lt;code&gt;poEvalCommand&lt;/code&gt; by default for backwards compatibility. Make sure to pass options explicitly.</source>
          <target state="translated">&lt;strong&gt;警告：&lt;/strong&gt;默认情况下，此函数使用 &lt;code&gt;poEvalCommand&lt;/code&gt; 以获得向后兼容性。确保明确传递选项。</target>
        </trans-unit>
        <trans-unit id="90ebcd1c15404fdc059702927e729624fbd89690" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;WARNING:&lt;/strong&gt; This is destructive! Once sorted, you must not modify &lt;code&gt;t&lt;/code&gt; afterwards!</source>
          <target state="translated">&lt;strong&gt;警告：&lt;/strong&gt;这是破坏性的！排序后，您不得在以后修改 &lt;code&gt;t&lt;/code&gt; ！</target>
        </trans-unit>
        <trans-unit id="214cc33166124094f55a1446237ae8c582fe5355" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;WARNING&lt;/strong&gt;: Be careful when using &lt;code&gt;waitForExit&lt;/code&gt; for processes created without &lt;code&gt;poParentStreams&lt;/code&gt; because they may fill output buffers, causing deadlock.</source>
          <target state="translated">&lt;strong&gt;警告&lt;/strong&gt;：对没有 &lt;code&gt;poParentStreams&lt;/code&gt; 创建的进程使用 &lt;code&gt;waitForExit&lt;/code&gt; 时要小心，因为它们可能会填满输出缓冲区，从而导致死锁。</target>
        </trans-unit>
        <trans-unit id="ec82fc02e8902673947cd6ed288467c5cc50a706" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;WARNING&lt;/strong&gt;: The returned &lt;code&gt;FileHandle&lt;/code&gt; should not be closed manually as it is closed when closing the Process &lt;code&gt;p&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;警告&lt;/strong&gt;：返回的 &lt;code&gt;FileHandle&lt;/code&gt; 不应手动关闭，因为它在关闭进程 &lt;code&gt;p&lt;/code&gt; 时已关闭。</target>
        </trans-unit>
        <trans-unit id="e6de0d179490809d7ea1f625bb02e6fd588f97e8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;WARNING&lt;/strong&gt;: The returned &lt;code&gt;Stream&lt;/code&gt; should not be closed manually as it is closed when closing the Process &lt;code&gt;p&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;警告&lt;/strong&gt;：返回的 &lt;code&gt;Stream&lt;/code&gt; 不应手动关闭，因为在关闭Process &lt;code&gt;p&lt;/code&gt; 时将其关闭。</target>
        </trans-unit>
        <trans-unit id="e4316d6405c9f4c9d98f6e1f272b469fd25904ba" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;WARNING&lt;/strong&gt;: Use it with caution. If &lt;code&gt;buf&lt;/code&gt; refers to GC'ed object, you must use GC_ref/GC_unref calls to avoid early freeing of the buffer.</source>
          <target state="translated">&lt;strong&gt;警告&lt;/strong&gt;：请谨慎使用。如果 &lt;code&gt;buf&lt;/code&gt; 引用了GC的对象，则必须使用GC_ref / GC_unref调用，以避免提早释放缓冲区。</target>
        </trans-unit>
        <trans-unit id="7f0c0c1f448cb428d097bb93a464a6218e766d86" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warn&lt;/strong&gt; - impending problems that require some attention</source>
          <target state="translated">&lt;strong&gt;警告&lt;/strong&gt;-迫在眉睫的问题，需要引起注意</target>
        </trans-unit>
        <trans-unit id="251436bcf1a85c83d8711b39296fe259fc9d0256" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Warning:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5f8f9514a22b55ff9c78136da9ef8a81f67b0108" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; If the process has not finished executing, this will forcibly terminate the process. Doing so may result in zombie processes and &lt;a href=&quot;http://stackoverflow.com/questions/27021641/how-to-fix-request-failed-on-channel-0&quot;&gt;pty leaks&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;警告：&lt;/strong&gt;如果进程尚未完成执行，将强制终止进程。这样做可能会导致僵尸进程和&lt;a href=&quot;http://stackoverflow.com/questions/27021641/how-to-fix-request-failed-on-channel-0&quot;&gt;pty泄漏&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7648a978c3c5b08aa7a942fe439314fcbbd9e17c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; It's not recommended to use &lt;code&gt;between&lt;/code&gt; for &lt;code&gt;DateTime's&lt;/code&gt; in different &lt;code&gt;TimeZone's&lt;/code&gt;. &lt;code&gt;a + between(a, b) == b&lt;/code&gt; is only guaranteed when &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; are in UTC.</source>
          <target state="translated">&lt;strong&gt;警告：&lt;/strong&gt;这不是推荐使用 &lt;code&gt;between&lt;/code&gt; 的 &lt;code&gt;DateTime's&lt;/code&gt; 在不同的 &lt;code&gt;TimeZone's&lt;/code&gt; 。仅当 &lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;b&lt;/code&gt; 在UTC中时，才能保证 &lt;code&gt;a + between(a, b) == b&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d0a52c8fdc83d67244f36d1e45904b31b08be93b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; Since version 0.10.2 this module is deprecated. Use the &lt;a href=&quot;net&quot;&gt;net&lt;/a&gt; or the &lt;a href=&quot;nativesockets&quot;&gt;nativesockets&lt;/a&gt; module instead.</source>
          <target state="translated">&lt;strong&gt;警告：&lt;/strong&gt;从版本0.10.2开始，不建议使用此模块。请使用&lt;a href=&quot;net&quot;&gt;net&lt;/a&gt;或&lt;a href=&quot;nativesockets&quot;&gt;nativesockets&lt;/a&gt;模块。</target>
        </trans-unit>
        <trans-unit id="9968b14e6044d19bea13d96a6048dbd5746bc726" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; The &lt;code&gt;total&lt;/code&gt; reported by httpclient may be 0 in some cases.</source>
          <target state="translated">&lt;strong&gt;警告：&lt;/strong&gt;在某些情况下，httpclient报告的 &lt;code&gt;total&lt;/code&gt; 可能为0。</target>
        </trans-unit>
        <trans-unit id="24b0c00e568f6b8e8da0f3bc2db0c76c857a200b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; The API of this module is unstable, and therefore is subject to change.</source>
          <target state="translated">&lt;strong&gt;警告：&lt;/strong&gt;此模块的API不稳定，因此可能会发生变化。</target>
        </trans-unit>
        <trans-unit id="70b2c2817205cf64dbba280341fa333ac9b060f3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; The buffer &lt;code&gt;a&lt;/code&gt; must be pre-allocated. This can be done using, for example, &lt;code&gt;newString&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;警告：&lt;/strong&gt;必须预先分配缓冲区 &lt;code&gt;a&lt;/code&gt; 。可以使用例如 &lt;code&gt;newString&lt;/code&gt; 完成此操作。</target>
        </trans-unit>
        <trans-unit id="9d0af0517916216290aedd9e00253fb0aa629d1c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; The buffer &lt;em&gt;a&lt;/em&gt; must be pre-allocated. This can be done using, for example, &lt;code&gt;newString&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;警告：&lt;/strong&gt;必须预先分配缓冲区&lt;em&gt;a&lt;/em&gt;。可以使用例如 &lt;code&gt;newString&lt;/code&gt; 完成此操作。</target>
        </trans-unit>
        <trans-unit id="0520baa64a72e7ee0281b0ddd067f506549b20a5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; The global list of handlers is a thread var, this means that the handlers must be re-added in each thread. &lt;strong&gt;Warning:&lt;/strong&gt; When logging on disk or console, only error and fatal messages are flushed out immediately. Use flushFile() where needed.</source>
          <target state="translated">&lt;strong&gt;警告：&lt;/strong&gt;处理程序的全局列表是线程var，这意味着必须在每个线程中重新添加处理程序。&lt;strong&gt;警告：&lt;/strong&gt;登录磁盘或控制台时，仅立即清除错误和致命消息。在需要的地方使用flushFile（）。</target>
        </trans-unit>
        <trans-unit id="f29b72a26be8d8706c4ec16fe1124964415b5b80" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; The global log filter is a thread-local variable. If logging is being performed in multiple threads, this proc should be called in each thread unless it is intended that different threads should log at different logging levels.</source>
          <target state="translated">&lt;strong&gt;警告：&lt;/strong&gt;全局日志过滤器是线程局部变量。如果在多个线程中执行日志记录，则应在每个线程中调用此proc，除非打算让不同的线程在不同的日志记录级别进行日志记录。</target>
        </trans-unit>
        <trans-unit id="d380c8f716c8c691b16583d7c78a4ee17fba7411" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; The list of handlers is a thread-local variable. If the given handler will be used in multiple threads, this proc should be called in each of those threads.</source>
          <target state="translated">&lt;strong&gt;警告：&lt;/strong&gt;处理程序列表是线程局部变量。如果给定的处理程序将在多个线程中使用，则应在每个线程中调用此proc。</target>
        </trans-unit>
        <trans-unit id="1de5e055501cd9543ed70f0688cbf30ac70cdc1a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; This function does not yet have a buffered implementation, so when &lt;code&gt;socket&lt;/code&gt; is buffered the non-buffered implementation will be used. Therefore if &lt;code&gt;socket&lt;/code&gt; contains something in its buffer this function will make no effort to return it.</source>
          <target state="translated">&lt;strong&gt;警告：&lt;/strong&gt;该函数尚无缓冲实现，因此当 &lt;code&gt;socket&lt;/code&gt; 被缓冲时，将使用非缓冲实现。因此，如果 &lt;code&gt;socket&lt;/code&gt; 在其缓冲区中包含某些内容，则该函数将不做任何努力来返回它。</target>
        </trans-unit>
        <trans-unit id="854f87e513637b6e9a5ac650c51cff41b8f768e0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; This module is deprecated since version 0.10.2. Use the brand new &lt;a href=&quot;asyncdispatch&quot;&gt;asyncdispatch&lt;/a&gt; module together with the &lt;a href=&quot;asyncnet&quot;&gt;asyncnet&lt;/a&gt; module.</source>
          <target state="translated">&lt;strong&gt;警告：&lt;/strong&gt;从版本0.10.2开始不推荐使用此模块。使用全新的&lt;a href=&quot;asyncdispatch&quot;&gt;asyncdispatch&lt;/a&gt;与模块一起&lt;a href=&quot;asyncnet&quot;&gt;asyncnet&lt;/a&gt;模块。</target>
        </trans-unit>
        <trans-unit id="aa0b3c2a66d1cb7f1d4a063b94c4ce6ca1f2543b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; This module is deprecated since version 0.14.0.</source>
          <target state="translated">&lt;strong&gt;警告：&lt;/strong&gt;从版本0.14.0开始不推荐使用此模块。</target>
        </trans-unit>
        <trans-unit id="7eb0dfd155d4b6f3b53e214b0ecc3fdf13f08633" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; This module is deprecated, use the SSL procedures defined in the &lt;code&gt;net&lt;/code&gt; module instead.</source>
          <target state="translated">&lt;strong&gt;警告：&lt;/strong&gt;不建议使用此模块，请改用 &lt;code&gt;net&lt;/code&gt; 模块中定义的SSL过程。</target>
        </trans-unit>
        <trans-unit id="5c5666a07ce3875934c4c4fc973b2a781936f5f9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; This module only supports the old asynchronous interface. You may wish to use the &lt;a href=&quot;asynchttpserver&quot;&gt;asynchttpserver&lt;/a&gt; instead for web applications.</source>
          <target state="translated">&lt;strong&gt;警告：&lt;/strong&gt;此模块仅支持旧的异步接口。您可能希望对Web应用程序使用&lt;a href=&quot;asynchttpserver&quot;&gt;asynchttpserver&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5cb55c6cefeda87fc389ece105c077ef731ae16e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; This procedure appears to be broken for SSL connections as of Nim v1.0.2. Consider using the other &lt;code&gt;connect&lt;/code&gt; procedure. See &lt;a href=&quot;https://github.com/nim-lang/Nim/issues/15215&quot;&gt;https://github.com/nim-lang/Nim/issues/15215&lt;/a&gt; for more info.</source>
          <target state="translated">&lt;strong&gt;警告：&lt;/strong&gt;从Nim v1.0.2开始，此过程似乎无法用于SSL连接。考虑使用其他 &lt;code&gt;connect&lt;/code&gt; 过程。有关更多信息，请参见&lt;a href=&quot;https://github.com/nim-lang/Nim/issues/15215&quot;&gt;https://github.com/nim-lang/Nim/issues/15215&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="53266ecbd11ce935a7868dc21f59beb46ccb3aaa" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; When using SSL with non-blocking sockets, it is best to use the acceptAddrSSL procedure as this procedure will most likely block.</source>
          <target state="translated">&lt;strong&gt;警告：&lt;/strong&gt;将SSL与非阻塞套接字一起使用时，最好使用acceptAddrSSL过程，因为此过程很可能会阻塞。</target>
        </trans-unit>
        <trans-unit id="808a8a1028dc1fed134e205c55ec27d7dd5b23fd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning&lt;/strong&gt;: &lt;code&gt;recvLine&lt;/code&gt; on unbuffered sockets assumes that the protocol uses &lt;code&gt;\r\L&lt;/code&gt; to delimit a new line.</source>
          <target state="translated">&lt;strong&gt;警告&lt;/strong&gt;：无缓冲套接字上的 &lt;code&gt;recvLine&lt;/code&gt; 假定协议使用 &lt;code&gt;\r\L&lt;/code&gt; 分隔新行。</target>
        </trans-unit>
        <trans-unit id="ac11ca7b54f8ac76331d539b39687d412032a370" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning&lt;/strong&gt;: &lt;code&gt;recvLineInto&lt;/code&gt; on unbuffered sockets assumes that the protocol uses &lt;code&gt;\r\L&lt;/code&gt; to delimit a new line.</source>
          <target state="translated">&lt;strong&gt;警告&lt;/strong&gt;：无缓冲套接字上的 &lt;code&gt;recvLineInto&lt;/code&gt; 假定协议使用 &lt;code&gt;\r\L&lt;/code&gt; 分隔新行。</target>
        </trans-unit>
        <trans-unit id="5d163b20a95cadf02bed8abe7ed680f87b2b48bd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning&lt;/strong&gt;: Be careful when using waitForExit for processes created without poParentStreams because they may fill output buffers, causing deadlock.</source>
          <target state="translated">&lt;strong&gt;警告&lt;/strong&gt;：对没有poParentStreams创建的进程使用waitForExit时要小心，因为它们可能会填充输出缓冲区，从而导致死锁。</target>
        </trans-unit>
        <trans-unit id="0163b79bd484845ef77cdbb23264a20232b50266" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning&lt;/strong&gt;: If &lt;code&gt;state&lt;/code&gt; is set incorrectly the resulting &lt;code&gt;AsyncSocket&lt;/code&gt; object may not work properly.</source>
          <target state="translated">&lt;strong&gt;警告&lt;/strong&gt;：如果 &lt;code&gt;state&lt;/code&gt; 设置不正确，则生成的 &lt;code&gt;AsyncSocket&lt;/code&gt; 对象可能无法正常工作。</target>
        </trans-unit>
        <trans-unit id="a95d9701c19c6c0c221e25db304c7abf3d95c719" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning&lt;/strong&gt;: Modifying the directory structure while the iterator is traversing may result in undefined behavior!</source>
          <target state="translated">&lt;strong&gt;警告&lt;/strong&gt;：遍历迭代器时修改目录结构可能导致不确定的行为！</target>
        </trans-unit>
        <trans-unit id="6f6766ee200b64744878c681dde8b968c6f670b4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning&lt;/strong&gt;: Only the &lt;code&gt;SafeDisconn&lt;/code&gt; flag is currently supported.</source>
          <target state="translated">&lt;strong&gt;警告&lt;/strong&gt;：目前仅支持 &lt;code&gt;SafeDisconn&lt;/code&gt; 标志。</target>
        </trans-unit>
        <trans-unit id="5179a287236e2707d51c8ae92986184ef63e00df" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning&lt;/strong&gt;: Only use this if you know what you are doing.</source>
          <target state="translated">&lt;strong&gt;警告&lt;/strong&gt;：仅当您知道自己在做什么时才使用此功能。</target>
        </trans-unit>
        <trans-unit id="054c5e069a1dfb7566a7270fedaaf23823866854" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning&lt;/strong&gt;: Ordinary application code should never set this hook! You better know what you do when setting this.</source>
          <target state="translated">&lt;strong&gt;警告&lt;/strong&gt;：普通应用程序代码永远不要设置此钩子！您最好知道在设置此功能时的操作。</target>
        </trans-unit>
        <trans-unit id="b8ef80f1f143a1f7de2004bb4e9cee1fed78e787" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning&lt;/strong&gt;: Some OS's (such as Microsoft Windows) restrict the creation of symlinks to root users (administrators).</source>
          <target state="translated">&lt;strong&gt;警告&lt;/strong&gt;：某些操作系统（例如Microsoft Windows）将创建符号链接限制为root用户（管理员）。</target>
        </trans-unit>
        <trans-unit id="1f61c1a4fea430f13537ed29d0765d587962a8f4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning&lt;/strong&gt;: Some OS's restrict the creation of hard links to root users (administrators).</source>
          <target state="translated">&lt;strong&gt;警告&lt;/strong&gt;：某些操作系统限制了对根用户（管理员）的硬链接的创建。</target>
        </trans-unit>
        <trans-unit id="f9012f1b5937f6027293c08f92583d61921af08c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning&lt;/strong&gt;: The &lt;code&gt;Peek&lt;/code&gt; flag is not yet implemented.</source>
          <target state="translated">&lt;strong&gt;警告&lt;/strong&gt;： &lt;code&gt;Peek&lt;/code&gt; 标志尚未实现。</target>
        </trans-unit>
        <trans-unit id="e86c259d83ff7290e4d751971a6fa6a8870f2e71" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning&lt;/strong&gt;: The &lt;code&gt;Peek&lt;/code&gt; socket flag is not supported on Windows.</source>
          <target state="translated">&lt;strong&gt;警告&lt;/strong&gt;：Windows不支持 &lt;code&gt;Peek&lt;/code&gt; 套接字标志。</target>
        </trans-unit>
        <trans-unit id="b0d46006d11f4bceceb4d4e08b148768200fa533" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning&lt;/strong&gt;: The &lt;code&gt;tmpl&lt;/code&gt; argument is written to by &lt;code&gt;mkstemp&lt;/code&gt; and thus can't be a string literal. If in doubt make a copy of the cstring before passing it in.</source>
          <target state="translated">&lt;strong&gt;警告&lt;/strong&gt;： &lt;code&gt;tmpl&lt;/code&gt; 参数由 &lt;code&gt;mkstemp&lt;/code&gt; 写入，因此不能为字符串文字。如有疑问，请在传递cstring之前对其进行复制。</target>
        </trans-unit>
        <trans-unit id="eb7cc1052b9ce8bdf39d06ce2f6b9a8915a89398" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning&lt;/strong&gt;: The &lt;code&gt;tmpl&lt;/code&gt; argument is written to by &lt;code&gt;mkstemps&lt;/code&gt; and thus can't be a string literal. If in doubt make a copy of the cstring before passing it in.</source>
          <target state="translated">&lt;strong&gt;警告&lt;/strong&gt;： &lt;code&gt;tmpl&lt;/code&gt; 参数由 &lt;code&gt;mkstemps&lt;/code&gt; 写入，因此不能为字符串文字。如有疑问，请在传递cstring之前对其进行复制。</target>
        </trans-unit>
        <trans-unit id="67b4583abc34f87fcf6eff4869eef2bfd28629d8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning&lt;/strong&gt;: The &lt;em&gt;tmpl&lt;/em&gt; argument is written to by &lt;em&gt;mkstemp&lt;/em&gt; and thus can't be a string literal. If in doubt copy the string before passing it.</source>
          <target state="translated">&lt;strong&gt;警告&lt;/strong&gt;：&lt;em&gt;tmpl&lt;/em&gt;参数由&lt;em&gt;mkstemp&lt;/em&gt;写入，因此不能是字符串文字。如有疑问，请在传递字符串之前将其复制。</target>
        </trans-unit>
        <trans-unit id="4f1192c1f109469e4dd7487e335279c8c6787f60" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning&lt;/strong&gt;: The behaviour of this procedure varies between Windows and POSIX systems. On Windows some OS calls can reset the error code to &lt;code&gt;0&lt;/code&gt; causing this procedure to return &lt;code&gt;0&lt;/code&gt;. It is therefore advised to call this procedure immediately after an OS call fails. On POSIX systems this is not a problem.</source>
          <target state="translated">&lt;strong&gt;警告&lt;/strong&gt;：此过程的行为在Windows和POSIX系统之间有所不同。在Windows上，某些OS调用可以将错误代码重置为 &lt;code&gt;0&lt;/code&gt; ,从而导致该过程返回 &lt;code&gt;0&lt;/code&gt; 。因此，建议在OS调用失败后立即调用此过程。在POSIX系统上，这不是问题。</target>
        </trans-unit>
        <trans-unit id="eae8834fd1ff75f9c078051184e01727261e31cb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning&lt;/strong&gt;: The resulting &lt;code&gt;ptr AddrInfo&lt;/code&gt; must be freed using &lt;code&gt;freeAddrInfo&lt;/code&gt;!</source>
          <target state="translated">&lt;strong&gt;警告&lt;/strong&gt;：必须使用 &lt;code&gt;freeAddrInfo&lt;/code&gt; 释放生成的 &lt;code&gt;ptr AddrInfo&lt;/code&gt; AddrInfo！</target>
        </trans-unit>
        <trans-unit id="9e788c203930a853b492baa9fb790e0baaa6f689" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning&lt;/strong&gt;: The returned &lt;em&gt;FileHandle&lt;/em&gt; should not be closed manually as it is closed when closing the Process &lt;code&gt;p&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;警告&lt;/strong&gt;：返回的&lt;em&gt;FileHandle&lt;/em&gt;不应手动关闭，因为在关闭进程 &lt;code&gt;p&lt;/code&gt; 时将其关闭。</target>
        </trans-unit>
        <trans-unit id="35816baa23c24b5f9e80530b286a99de07763458" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning&lt;/strong&gt;: The returned &lt;em&gt;Stream&lt;/em&gt; should not be closed manually as it is closed when closing the Process &lt;code&gt;p&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;警告&lt;/strong&gt;：返回的&lt;em&gt;Stream&lt;/em&gt;不应手动关闭，因为在关闭Process &lt;code&gt;p&lt;/code&gt; 时将其关闭。</target>
        </trans-unit>
        <trans-unit id="070d8f77f83eff23785cd22229e7c7593a9f015a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning&lt;/strong&gt;: This assumes that lines are delimited by &lt;code&gt;\r\L&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;警告&lt;/strong&gt;：这假定行由 &lt;code&gt;\r\L&lt;/code&gt; 分隔。</target>
        </trans-unit>
        <trans-unit id="a9df6a23fa581b51ba2e0e996ce854f48568ec52" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning&lt;/strong&gt;: This function may give unexpected or completely wrong results on Windows.</source>
          <target state="translated">&lt;strong&gt;警告&lt;/strong&gt;：此功能可能会在Windows上导致意外或完全错误的结果。</target>
        </trans-unit>
        <trans-unit id="016fcff66b49f260c1c428fc4a770e9ba587d905" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning&lt;/strong&gt;: This module uses &lt;code&gt;immediate&lt;/code&gt; macros which are known to cause problems. Do yourself a favor and import the module as &lt;code&gt;from htmlgen import nil&lt;/code&gt; and then fully qualify the macros.</source>
          <target state="translated">&lt;strong&gt;警告&lt;/strong&gt;：此模块使用已知会导致问题的 &lt;code&gt;immediate&lt;/code&gt; 宏。帮个忙， &lt;code&gt;from htmlgen import nil&lt;/code&gt; 导入模块，然后完全限定宏。</target>
        </trans-unit>
        <trans-unit id="13fc508dd2164cb6be6b2b2f5043fed79efd1dd8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning&lt;/strong&gt;: This really transforms the 'for' and unrolls the loop. The current implementation also has a bug that affects symbol binding in the loop body.</source>
          <target state="translated">&lt;strong&gt;警告&lt;/strong&gt;：这确实会改变&amp;ldquo; for&amp;rdquo;并展开循环。当前的实现还有一个错误会影响循环主体中的符号绑定。</target>
        </trans-unit>
        <trans-unit id="06b71636d61a389fc8acb40152f2835585e38044" translate="yes" xml:space="preserve">
          <source>A &quot;move&quot; can be regarded as an optimized copy operation. If the source of the copy operation is not used afterward, the copy can be replaced by a move. This document uses the notation &lt;code&gt;lastReadOf(x)&lt;/code&gt; to describe that &lt;code&gt;x&lt;/code&gt; is not used afterwards. This property is computed by a static control flow analysis but can also be enforced by using &lt;code&gt;system.move&lt;/code&gt; explicitly.</source>
          <target state="translated">&amp;ldquo;移动&amp;rdquo;可以看作是优化的复制操作。如果此后未使用复制操作的源，则可以通过移动来替换副本。本文档使用符号 &lt;code&gt;lastReadOf(x)&lt;/code&gt; 来描述之后不再使用 &lt;code&gt;x&lt;/code&gt; 。此属性是通过静态控制流分析计算的，但也可以通过显式使用 &lt;code&gt;system.move&lt;/code&gt; 强制实施。</target>
        </trans-unit>
        <trans-unit id="1ee8bac63489b4b65f1d77d36e0156115bbf2067" translate="yes" xml:space="preserve">
          <source>A &quot;word&quot; character is an underscore or any character less than 256 that is a letter or digit. The definition of letters and digits is controlled by PCRE's low-valued character tables, and may vary if locale-specific matching is taking place (see &quot;Locale support&quot; in the pcreapi page). For example, in the &quot;fr_FR&quot; (French) locale, some character codes greater than 128 are used for accented letters, and these are matched by &lt;code&gt;\w&lt;/code&gt;.</source>
          <target state="translated">&amp;ldquo;单词&amp;rdquo;字符是下划线或小于256的任何字母或数字字符。字母和数字的定义由PCRE的低值字符表控制，如果进行特定于语言环境的匹配，则可能会有所不同（请参阅pcreapi页中的&amp;ldquo;语言环境支持&amp;rdquo;）。例如，在&amp;ldquo; fr_FR&amp;rdquo;（法语）语言环境中，某些大于128的字符代码用于带重音的字母，并且这些字符由 &lt;code&gt;\w&lt;/code&gt; 匹配。</target>
        </trans-unit>
        <trans-unit id="6f72d8972b6598297117d18b7db8ef83c968a530" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;$&lt;/code&gt; proc is defined for cstrings that returns a string. Thus to get a nim string from a cstring:</source>
          <target state="translated">一个 &lt;code&gt;$&lt;/code&gt; PROC是返回一个字符串cstrings定义。因此，要从cstring中获取一个nim字符串：</target>
        </trans-unit>
        <trans-unit id="6f987a9c7bda1ba368e820346dd66c8e5c89eaa6" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;=destroy&lt;/code&gt; hook frees the object's associated memory and releases other associated resources. Variables are destroyed via this hook when they go out of scope or when the routine they were declared in is about to return.</source>
          <target state="translated">甲 &lt;code&gt;=destroy&lt;/code&gt; 钩释放该对象的相关联的存储器和版本的其它相关联的资源。当变量超出范围或在声明它们的例程即将返回时，将通过此钩子将其销毁。</target>
        </trans-unit>
        <trans-unit id="c295c049a3b9376266f8a5946db064e42c05591f" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;=sink&lt;/code&gt; hook moves an object around, the resources are stolen from the source and passed to the destination. It is ensured that the source's destructor does not free the resources afterward by setting the object to its default value (the value the object's state started in). Setting an object &lt;code&gt;x&lt;/code&gt; back to its default value is written as &lt;code&gt;wasMoved(x)&lt;/code&gt;. When not provided the compiler is using a combination of &lt;code&gt;=destroy&lt;/code&gt; and &lt;code&gt;copyMem&lt;/code&gt; instead. This is efficient hence users rarely need to implement their own &lt;code&gt;=sink&lt;/code&gt; operator, it is enough to provide &lt;code&gt;=destroy&lt;/code&gt; and &lt;code&gt;=copy&lt;/code&gt;, compiler will take care of the rest.</source>
          <target state="translated">一个 &lt;code&gt;=sink&lt;/code&gt; 钩子在对象周围移动，资源被从源中窃取并传递到目的地。通过将对象设置为其默认值（对象状态开始时的值），可以确保源的析构函数之后不会释放资源。将对象 &lt;code&gt;x&lt;/code&gt; 设置回其默认值的方式写为 &lt;code&gt;wasMoved(x)&lt;/code&gt; 。如果未提供，则编译器将使用 &lt;code&gt;=destroy&lt;/code&gt; 和 &lt;code&gt;copyMem&lt;/code&gt; 的组合。这是有效的，因此用户很少需要实现自己的 &lt;code&gt;=sink&lt;/code&gt; 运算符，足以提供 &lt;code&gt;=destroy&lt;/code&gt; 和 &lt;code&gt;=copy&lt;/code&gt; ，编译器将负责其余工作。</target>
        </trans-unit>
        <trans-unit id="ade5cfc4633d231cd947fd6c046bf9c49c277b02" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;Duration&lt;/code&gt; represents a duration of time stored as seconds and nanoseconds. A &lt;code&gt;Duration&lt;/code&gt; is always fully normalized, so &lt;code&gt;initDuration(hours = 1)&lt;/code&gt; and &lt;code&gt;initDuration(minutes = 60)&lt;/code&gt; are equivalent.</source>
          <target state="translated">甲 &lt;code&gt;Duration&lt;/code&gt; 表示存储为秒和纳秒的持续时间。甲 &lt;code&gt;Duration&lt;/code&gt; 总是完全标准化，所以 &lt;code&gt;initDuration(hours = 1)&lt;/code&gt; 和 &lt;code&gt;initDuration(minutes = 60)&lt;/code&gt; 是等效的。</target>
        </trans-unit>
        <trans-unit id="aaba2403682a17469ecab3c6f2cc502e7be26d2b" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;HttpRequestError&lt;/code&gt; will be raised if the server responds with a client error (status code 4xx) or a server error (status code 5xx).</source>
          <target state="translated">一个 &lt;code&gt;HttpRequestError&lt;/code&gt; 将提高如果服务器响应与客户端错误（状态码4XX）或服务器错误（状态码5XX）。</target>
        </trans-unit>
        <trans-unit id="9bb8bd75e1a9a8ff5a43663da64ab547afc1c568" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;Source Code Filter (SCF)&lt;/code&gt; transforms the input character stream to an in-memory output stream before parsing. A filter can be used to provide templating systems or preprocessors.</source>
          <target state="translated">甲 &lt;code&gt;Source Code Filter (SCF)&lt;/code&gt; 分析之前输入字符流转换到内存中的输出流。过滤器可用于提供模板系统或预处理器。</target>
        </trans-unit>
        <trans-unit id="42f2546ed8f58cd59935336003ee6db78fbf89d1" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;TimeInterval&lt;/code&gt; represents an amount of time expressed in calendar units, for example &quot;1 year and 2 days&quot;. Since some units cannot be normalized (the length of a year is different for leap years for example), the &lt;code&gt;TimeInterval&lt;/code&gt; type uses separate fields for every unit. The &lt;code&gt;TimeInterval&lt;/code&gt;'s returned from this module generally don't normalize &lt;strong&gt;anything&lt;/strong&gt;, so even units that could be normalized (like seconds, milliseconds and so on) are left untouched.</source>
          <target state="translated">甲 &lt;code&gt;TimeInterval&lt;/code&gt; 所表示的日历单位表示的时间量，例如，&amp;ldquo;1年2日&amp;rdquo;。由于某些单位无法归一化（例如，leap年的 &lt;code&gt;TimeInterval&lt;/code&gt; 不同），因此TimeInterval类型为每个单位使用单独的字段。从此模块返回的 &lt;code&gt;TimeInterval&lt;/code&gt; 通常不会对&lt;strong&gt;任何内容&lt;/strong&gt;进行标准化，因此即使可以标准化的单位（如秒，毫秒等）也不会受到影响。</target>
        </trans-unit>
        <trans-unit id="d81d68641d8bf3ceba1aef0cf067b5ab815956a7" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;ValueError&lt;/code&gt; exception will be raised if the value is not an integer.</source>
          <target state="translated">一个 &lt;code&gt;ValueError&lt;/code&gt; 异常，如果该值不为整数，将引发异常。</target>
        </trans-unit>
        <trans-unit id="ae6545e69126352cc398c36e028a5f279a82dab9" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;block expression&lt;/code&gt; is almost like a block statement, but it is an expression that uses the last expression under the block as the value. It is similar to the statement list expression, but the statement list expression does not open a new block scope.</source>
          <target state="translated">阿 &lt;code&gt;block expression&lt;/code&gt; 是几乎像一个块语句，但它是可利用该区块作为值下的最后一个表达式的表达式。它类似于语句列表表达式，但是语句列表表达式不会打开新的块作用域。</target>
        </trans-unit>
        <trans-unit id="49a6495aba25fcc0345009a64738a98f0c760abf" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;block&lt;/code&gt; doesn't need an name, in which case &lt;code&gt;nnkEmpty&lt;/code&gt; is used.</source>
          <target state="translated">阿 &lt;code&gt;block&lt;/code&gt; 不需要一个名字，在这种情况下 &lt;code&gt;nnkEmpty&lt;/code&gt; 被使用。</target>
        </trans-unit>
        <trans-unit id="bde4d27b77941b8a2e8d7b668c0d8b482525e40c" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;closure&lt;/code&gt; proc var can call ordinary procs of the default Nim calling convention. But not the other way round! A closure is implemented as a &lt;code&gt;tuple[prc, env]&lt;/code&gt;. &lt;code&gt;env&lt;/code&gt; can be nil implying a call without a closure. This means that a call through a closure generates an &lt;code&gt;if&lt;/code&gt; but the interoperability is worth the cost of the &lt;code&gt;if&lt;/code&gt;. Thunk generation would be possible too, but it's slightly more effort to implement.</source>
          <target state="translated">一个 &lt;code&gt;closure&lt;/code&gt; PROC VAR可以调用默认稔调用约定的普通特效。但不是相反！闭包实现为 &lt;code&gt;tuple[prc, env]&lt;/code&gt; 。 &lt;code&gt;env&lt;/code&gt; 可以为nil，表示不带闭包的调用。这意味着通过闭包进行的调用会生成 &lt;code&gt;if&lt;/code&gt; ,但互操作性值得 &lt;code&gt;if&lt;/code&gt; 的代价。大规模生成也是可能的，但是实现起来要付出更多的努力。</target>
        </trans-unit>
        <trans-unit id="46ca6bf4504c12b38f73b70158bd4cc5686ceec6" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;continue&lt;/code&gt; statement leads to the immediate next iteration of the surrounding loop construct. It is only allowed within a loop. A continue statement is syntactic sugar for a nested block:</source>
          <target state="translated">一个 &lt;code&gt;continue&lt;/code&gt; 语句导致周围循环结构的立即下一次迭代。仅允许在循环内进行。连续语句是嵌套块的语法糖：</target>
        </trans-unit>
        <trans-unit id="c715fe380645376748f587a6b825be1c5374aad4" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;distinct&lt;/code&gt; type is a new type derived from a &lt;span id=&quot;base-type_1&quot;&gt;base type&lt;/span&gt; that is incompatible with its base type. In particular, it is an essential property of a distinct type that it &lt;strong&gt;does not&lt;/strong&gt; imply a subtype relation between it and its base type. Explicit type conversions from a distinct type to its base type and vice versa are allowed. See also &lt;code&gt;distinctBase&lt;/code&gt; to get the reverse operation.</source>
          <target state="translated">阿 &lt;code&gt;distinct&lt;/code&gt; 类型是从衍生的新类型&lt;span id=&quot;base-type_1&quot;&gt;的基本类型&lt;/span&gt;是与它的基类型不兼容。特别是，它是独特类型的基本属性，&lt;strong&gt;并不&lt;/strong&gt;意味着它与其基本类型之间存在子类型关系。允许从独特类型到其基本类型的显式类型转换，反之亦然。另请参见 &lt;code&gt;distinctBase&lt;/code&gt; 以获取相反的操作。</target>
        </trans-unit>
        <trans-unit id="fa532fc8ce7dbe2864f24cd2a27ac73e6fc36afd" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;distinct&lt;/code&gt; type is new type derived from a &lt;span id=&quot;base-type_1&quot;&gt;base type&lt;/span&gt; that is incompatible with its base type. In particular, it is an essential property of a distinct type that it &lt;strong&gt;does not&lt;/strong&gt; imply a subtype relation between it and its base type. Explicit type conversions from a distinct type to its base type and vice versa are allowed. See also &lt;code&gt;distinctBase&lt;/code&gt; to get the reverse operation.</source>
          <target state="translated">阿 &lt;code&gt;distinct&lt;/code&gt; 类型是从派生新型&lt;span id=&quot;base-type_1&quot;&gt;碱型&lt;/span&gt;，其与它的基类型不兼容。特别是，它是独特类型的基本属性，&lt;strong&gt;并不&lt;/strong&gt;意味着它与其基本类型之间存在子类型关系。允许从不同类型到基本类型的显式类型转换，反之亦然。另请参见 &lt;code&gt;distinctBase&lt;/code&gt; 以获取相反的操作。</target>
        </trans-unit>
        <trans-unit id="e436402133516571641a8daf812bf61340c32403" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;flowVar&lt;/code&gt; only supports one call to &lt;code&gt;blockUntilAny&lt;/code&gt; at the same time. That means if you &lt;code&gt;blockUntilAny([a,b])&lt;/code&gt; and &lt;code&gt;blockUntilAny([b,c])&lt;/code&gt; the second call will only block until &lt;code&gt;c&lt;/code&gt;. If there is no &lt;code&gt;flowVar&lt;/code&gt; left to be able to wait on, -1 is returned.</source>
          <target state="translated">一个 &lt;code&gt;flowVar&lt;/code&gt; 只支持一个呼叫 &lt;code&gt;blockUntilAny&lt;/code&gt; 在同一时间。这意味着，如果您将 &lt;code&gt;blockUntilAny([a,b])&lt;/code&gt; 和 &lt;code&gt;blockUntilAny([b,c])&lt;/code&gt; 阻塞，则第二次调用将一直阻塞到 &lt;code&gt;c&lt;/code&gt; 为止。如果没有 &lt;code&gt;flowVar&lt;/code&gt; 可以等待，则返回-1。</target>
        </trans-unit>
        <trans-unit id="fec0b8e4f99548ff52eae3d0e8ec4be16fcde6a4" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;let&lt;/code&gt; statement declares new local and global &lt;span id=&quot;single-assignment_1&quot;&gt;single assignment&lt;/span&gt; variables and binds a value to them. The syntax is the same as that of the &lt;code&gt;var&lt;/code&gt; statement, except that the keyword &lt;code&gt;var&lt;/code&gt; is replaced by the keyword &lt;code&gt;let&lt;/code&gt;. Let variables are not l-values and can thus not be passed to &lt;code&gt;var&lt;/code&gt; parameters nor can their address be taken. They cannot be assigned new values.</source>
          <target state="translated">一个 &lt;code&gt;let&lt;/code&gt; 语句声明新的本地和全局&lt;span id=&quot;single-assignment_1&quot;&gt;单赋值&lt;/span&gt;的变量并绑定一个值给他们。语法与 &lt;code&gt;var&lt;/code&gt; 语句的语法相同，只是关键字 &lt;code&gt;var&lt;/code&gt; 被关键字 &lt;code&gt;let&lt;/code&gt; 代替。设变量不是l值，因此不能传递给 &lt;code&gt;var&lt;/code&gt; 参数，也不能获取其地址。无法为它们分配新值。</target>
        </trans-unit>
        <trans-unit id="8fe78b3a2821fa1451c04e1ee9b03eb161700c9d" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;raises&lt;/code&gt; list can also be attached to a proc type. This affects type compatibility:</source>
          <target state="translated">一个 &lt;code&gt;raises&lt;/code&gt; 名单也可以连接到一个PROC类型。这会影响类型兼容性：</target>
        </trans-unit>
        <trans-unit id="c8cb08453579d0f15d45b19ab781ad1eab51f587" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;varargs&lt;/code&gt; parameter is an openarray parameter that additionally allows to pass a variable number of arguments to a procedure. The compiler converts the list of arguments to an array implicitly:</source>
          <target state="translated">甲 &lt;code&gt;varargs&lt;/code&gt; 参数是openarray参数另外允许的参数个数可变传递给程序。编译器将参数列表隐式转换为数组：</target>
        </trans-unit>
        <trans-unit id="9932ed67f0c5e1f713b0339fd155b7567d8b4c9b" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;varargs&lt;/code&gt; parameter is like an openarray parameter. However, it is also a means to implement passing a variable number of arguments to a procedure. The compiler converts the list of arguments to an array automatically:</source>
          <target state="translated">甲 &lt;code&gt;varargs&lt;/code&gt; 的参数是像一个openarray参数。但是，这也是一种实现将可变数量的参数传递给过程的方法。编译器自动将参数列表转换为数组：</target>
        </trans-unit>
        <trans-unit id="e982b06375e4d6cb9864cbab229ee93da8102df8" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;$&lt;/em&gt; proc is defined for cstrings that returns a string. Thus to get a nim string from a cstring:</source>
          <target state="translated">一个&lt;em&gt;$&lt;/em&gt; PROC是返回一个字符串cstrings定义。因此，要从cstring获取一个nim字符串：</target>
        </trans-unit>
        <trans-unit id="4924981c6cf86467817a6848ae253feb1dd3d357" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;Source Code Filter&lt;/em&gt; transforms the input character stream to an in-memory output stream before parsing. A filter can be used to provide templating systems or preprocessors.</source>
          <target state="translated">甲&lt;em&gt;源代码筛选&lt;/em&gt;分析之前的输入字符流转换到内存中的输出流。过滤器可用于提供模板系统或预处理器。</target>
        </trans-unit>
        <trans-unit id="ffbb84a506b05cba8d617634fff9481c23abd0eb" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;mutable&lt;/em&gt; view type is a type that is or contains a &lt;code&gt;var T&lt;/code&gt; type. An &lt;em&gt;immutable&lt;/em&gt; view type is a view type that is not a mutable view type.</source>
          <target state="translated">甲&lt;em&gt;可变&lt;/em&gt;视图类型是一类是或含有一个 &lt;code&gt;var T&lt;/code&gt; 类型。一个&lt;em&gt;不可变的&lt;/em&gt;视图类型是不是一个可变视图型的图型。</target>
        </trans-unit>
        <trans-unit id="787f1149d9267dbcf887509536779010033aad01" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;subex&lt;/em&gt; (&lt;em&gt;Substitution Expression&lt;/em&gt;) represents an advanced string substitution. In contrast to a &lt;span id=&quot;regex_1&quot;&gt;regex&lt;/span&gt; which deals with string analysis, a &lt;em&gt;subex&lt;/em&gt; deals with string synthesis.</source>
          <target state="translated">甲&lt;em&gt;SUBEX&lt;/em&gt;（&lt;em&gt;替换表达式&lt;/em&gt;）表示的高级字符串替换。相反，一个&lt;span id=&quot;regex_1&quot;&gt;正则表达式&lt;/span&gt;，其与串分析，一个涉及&lt;em&gt;SUBEX&lt;/em&gt;与串合成交易。</target>
        </trans-unit>
        <trans-unit id="4f993e9d9aed0b9d20403070d843afd35df22c0c" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;view&lt;/em&gt; is a symbol (a let, var, const, etc.) that has a view type.</source>
          <target state="translated">甲&lt;em&gt;视图&lt;/em&gt;是一个符号（一让，VAR，常量等），其具有的图型。</target>
        </trans-unit>
        <trans-unit id="889eb097f34d2cb2326af79e37dd19352cd4b767" translate="yes" xml:space="preserve">
          <source>A &lt;span id=&quot;checked-runtime-error_1&quot;&gt;checked runtime error&lt;/span&gt; is an error that the implementation detects and reports at runtime. The method for reporting such errors is via &lt;em&gt;raising exceptions&lt;/em&gt; or &lt;em&gt;dying with a fatal error&lt;/em&gt;. However, the implementation provides a means to disable these runtime checks. See the section &lt;a href=&quot;#pragmas&quot;&gt;pragmas&lt;/a&gt; for details.</source>
          <target state="translated">已&lt;span id=&quot;checked-runtime-error_1&quot;&gt;检查的运行时错误&lt;/span&gt;是实现在运行时检测并报告的错误。报告此类错误的方法是通过&lt;em&gt;引发异常&lt;/em&gt;或&lt;em&gt;死于致命错误&lt;/em&gt;。但是，该实现提供了一种禁用这些运行时检查的方法。有关详细信息，请参见部分&lt;a href=&quot;#pragmas&quot;&gt;编译指示&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3632d0ab374d6b5b4b41b8c40814ec08f6ffd800" translate="yes" xml:space="preserve">
          <source>A &lt;span id=&quot;constant-expression_1&quot;&gt;constant expression&lt;/span&gt; is an expression whose value can be computed during a semantic analysis of the code in which it appears. It is never an l-value and never has side effects. Constant expressions are not limited to the capabilities of semantic analysis, such as constant folding; they can use all Nim language features that are supported for compile-time execution. Since constant expressions can be used as an input to semantic analysis (such as for defining array bounds), this flexibility requires the compiler to interleave semantic analysis and compile-time code execution.</source>
          <target state="translated">甲&lt;span id=&quot;constant-expression_1&quot;&gt;常量表达式&lt;/span&gt;是其值可以在其中出现它的代码的语义分析期间计算的表达式。它永远不会是l值，也永远不会有副作用。常量表达式不限于语义分析功能，例如常量折叠；他们可以使用编译时执行支持的所有Nim语言功能。由于常量表达式可以用作语义分析的输入（例如用于定义数组边界），因此这种灵活性要求编译器交织​​语义分析和编译时代码执行。</target>
        </trans-unit>
        <trans-unit id="d97460e671a1b963a40ec5d11fe647ad12dd7e11" translate="yes" xml:space="preserve">
          <source>A &lt;span id=&quot;constant_1&quot;&gt;constant&lt;/span&gt; is a symbol that is bound to the value of a constant expression. Constant expressions are restricted to depend only on the following categories of values and operations, because these are either built into the language or declared and evaluated before semantic analysis of the constant expression:</source>
          <target state="translated">甲&lt;span id=&quot;constant_1&quot;&gt;常数&lt;/span&gt;是结合于常量表达式的值的符号。常量表达式被限制为仅依赖于以下类别的值和运算，因为它们要么内置于语言中，要么在对常量表达式进行语义分析之前进行声明和评估：</target>
        </trans-unit>
        <trans-unit id="31c99118ea561948c45f870ebd2c2cce4b7b646d" translate="yes" xml:space="preserve">
          <source>A &lt;span id=&quot;guard_1&quot;&gt;guard&lt;/span&gt; annotation is introduced to prevent data races.</source>
          <target state="translated">一个&lt;span id=&quot;guard_1&quot;&gt;后卫&lt;/span&gt;注释介绍，以防止数据的比赛。</target>
        </trans-unit>
        <trans-unit id="386e659d1429b589f185720a9d5bf0ba95205db0" translate="yes" xml:space="preserve">
          <source>A &lt;span id=&quot;narrowing-type-conversion_1&quot;&gt;narrowing type conversion&lt;/span&gt; converts a larger to a smaller type (for example &lt;code&gt;int32 -&amp;gt; int16&lt;/code&gt;. A &lt;span id=&quot;widening-type-conversion_1&quot;&gt;widening type conversion&lt;/span&gt; converts a smaller type to a larger type (for example &lt;code&gt;int16 -&amp;gt; int32&lt;/code&gt;). In Nim only widening type conversions are &lt;em&gt;implicit&lt;/em&gt;:</source>
          <target state="translated">甲&lt;span id=&quot;narrowing-type-conversion_1&quot;&gt;变窄类型转换&lt;/span&gt;转换到一个较小的类型（例如较大 &lt;code&gt;int32 -&amp;gt; int16&lt;/code&gt; 甲。&lt;span id=&quot;widening-type-conversion_1&quot;&gt;加宽型转换&lt;/span&gt;器将较小的类型为较大的类型（例如 &lt;code&gt;int16 -&amp;gt; int32&lt;/code&gt; ）在稔仅扩大类型转换。&lt;em&gt;隐式&lt;/em&gt;：</target>
        </trans-unit>
        <trans-unit id="3955b81b785f4e1f5618c3fd25368b3b2f30c5e6" translate="yes" xml:space="preserve">
          <source>A &lt;span id=&quot;panic_1&quot;&gt;panic&lt;/span&gt; is an error that the implementation detects and reports at runtime. The method for reporting such errors is via &lt;em&gt;raising exceptions&lt;/em&gt; or &lt;em&gt;dying with a fatal error&lt;/em&gt;. However, the implementation provides a means to disable these &lt;span id=&quot;runtime-checks_1&quot;&gt;runtime checks&lt;/span&gt;. See the section &lt;a href=&quot;#pragmas&quot;&gt;pragmas&lt;/a&gt; for details.</source>
          <target state="translated">一个&lt;span id=&quot;panic_1&quot;&gt;恐慌&lt;/span&gt;是一个错误，执行检测，并在运行报告。报告此类错误的方法是通过&lt;em&gt;引发异常&lt;/em&gt;或&lt;em&gt;死于致命错误&lt;/em&gt;。但是，该实现提供了一种禁用这些&lt;span id=&quot;runtime-checks_1&quot;&gt;运行时检查的方法&lt;/span&gt;。有关详细信息，请参见部分&lt;a href=&quot;#pragmas&quot;&gt;编译指示&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="387048b351545e7cdb57e945c46d2fba04806529" translate="yes" xml:space="preserve">
          <source>A &lt;span id=&quot;static-error_1&quot;&gt;static error&lt;/span&gt; is an error that the implementation detects before program execution. Unless explicitly classified, an error is a static error.</source>
          <target state="translated">一个&lt;span id=&quot;static-error_1&quot;&gt;静态的错误&lt;/span&gt;是，执行程序执行前检测到错误。除非明确分类，否则错误是静态错误。</target>
        </trans-unit>
        <trans-unit id="130e98a36d1ad0d5fa779c624d02b3795704ff33" translate="yes" xml:space="preserve">
          <source>A Distinct type allows for the creation of new type that &quot;does not imply a subtype relationship between it and its base type&quot;. You must &lt;strong&gt;explicitly&lt;/strong&gt; define all behaviour for the distinct type. To help with this, both the distinct type and its base type can cast from one type to the other. Examples are provided in the &lt;a href=&quot;manual#types-distinct-type&quot;&gt;manual&lt;/a&gt;.</source>
          <target state="translated">Distinct类型允许创建新类型，该新类型&amp;ldquo;并不意味着它与其基本类型之间存在子类型关系&amp;rdquo;。您必须为不同类型&lt;strong&gt;明确&lt;/strong&gt;定义所有行为。为了解决这个问题，独特类型及其基本类型都可以从一种类型转换为另一种类型。&lt;a href=&quot;manual#types-distinct-type&quot;&gt;手册&lt;/a&gt;中提供了示例。</target>
        </trans-unit>
        <trans-unit id="79b065193cd9e9953658e8235e333843b91d5cf1" translate="yes" xml:space="preserve">
          <source>A Nim &lt;code&gt;string&lt;/code&gt; is implicitly convertible to &lt;code&gt;cstring&lt;/code&gt; for convenience. If a Nim string is passed to a C-style variadic proc, it is implicitly converted to &lt;code&gt;cstring&lt;/code&gt; too:</source>
          <target state="translated">为方便起见，Nim &lt;code&gt;string&lt;/code&gt; 可隐式转换为 &lt;code&gt;cstring&lt;/code&gt; 。如果将Nim字符串传递给C风格的可变参数proc，它也会隐式转换为 &lt;code&gt;cstring&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="065a0f8b65d9d6ed85af9b0b240cf7b0af451235" translate="yes" xml:space="preserve">
          <source>A Nim &lt;span id=&quot;program_1&quot;&gt;program&lt;/span&gt; consists of one or more text &lt;span id=&quot;source-files_1&quot;&gt;source files&lt;/span&gt; containing Nim code. It is processed by a Nim &lt;span id=&quot;compiler_1&quot;&gt;compiler&lt;/span&gt; into an &lt;span id=&quot;executable_1&quot;&gt;executable&lt;/span&gt;. The nature of this executable depends on the compiler implementation; it may, for example, be a native binary or JavaScript source code.</source>
          <target state="translated">Nim&lt;span id=&quot;program_1&quot;&gt;程序&lt;/span&gt;由一个或多个包含Nim代码的文本&lt;span id=&quot;source-files_1&quot;&gt;源文件&lt;/span&gt;组成。它由Nim&lt;span id=&quot;compiler_1&quot;&gt;编译器处理&lt;/span&gt;为&lt;span id=&quot;executable_1&quot;&gt;可执行文件&lt;/span&gt;。该可执行文件的性质取决于编译器的实现。例如，它可以是本地二进制或JavaScript源代码。</target>
        </trans-unit>
        <trans-unit id="69460fedc7d49aa8bfd391ea3c8be3ae26318394" translate="yes" xml:space="preserve">
          <source>A Nim procedure is asynchronous when it includes the &lt;code&gt;{.async.}&lt;/code&gt; pragma. It should always have a &lt;code&gt;Future[T]&lt;/code&gt; return type or not have a return type at all. A &lt;code&gt;Future[void]&lt;/code&gt; return type is assumed by default.</source>
          <target state="translated">当Nim过程包含 &lt;code&gt;{.async.}&lt;/code&gt; 编译指示时，它是异步的。它应该始终具有 &lt;code&gt;Future[T]&lt;/code&gt; 返回类型，或者根本不具有返回类型。默认情况下，假定使用 &lt;code&gt;Future[void]&lt;/code&gt; 返回类型。</target>
        </trans-unit>
        <trans-unit id="0bd52730a119bb22be3969f6811e2133725811be" translate="yes" xml:space="preserve">
          <source>A Nim program specifies a computation that acts on a memory consisting of components called &lt;span id=&quot;locations_1&quot;&gt;locations&lt;/span&gt;. A variable is basically a name for a location. Each variable and location is of a certain &lt;span id=&quot;type_1&quot;&gt;type&lt;/span&gt;. The variable's type is called &lt;span id=&quot;static-type_1&quot;&gt;static type&lt;/span&gt;, the location's type is called &lt;span id=&quot;dynamic-type_1&quot;&gt;dynamic type&lt;/span&gt;. If the static type is not the same as the dynamic type, it is a super-type or subtype of the dynamic type.</source>
          <target state="translated">Nim程序指定一种运算，该运算将作用于由称为&lt;span id=&quot;locations_1&quot;&gt;location&lt;/span&gt;的组件组成的内存中。变量基本上是位置的名称。每个变量和位置都是某种&lt;span id=&quot;type_1&quot;&gt;类型&lt;/span&gt;。变量的类型称为&lt;span id=&quot;static-type_1&quot;&gt;静态类型&lt;/span&gt;，位置的类型称为&lt;span id=&quot;dynamic-type_1&quot;&gt;动态类型&lt;/span&gt;。如果静态类型与动态类型不同，则它是动态类型的超类型或子类型。</target>
        </trans-unit>
        <trans-unit id="4d649a9b73eb1b75df006205a78131f546ab13c9" translate="yes" xml:space="preserve">
          <source>A PEG (Parsing expression grammar) is a simple deterministic grammar, that can be directly used for parsing. The current implementation has been designed as a more powerful replacement for regular expressions. UTF-8 is supported.</source>
          <target state="translated">PEG(Parsing expression grammar)是一种简单的确定性语法,可以直接用于解析。目前的实现已经被设计为更强大的正则表达式的替代品。支持UTF-8。</target>
        </trans-unit>
        <trans-unit id="8f7d9cb77b19d82ede8da7ec5e4ab6a8a699b484" translate="yes" xml:space="preserve">
          <source>A Rune may be composed with other Runes to a character on the screen. &lt;code&gt;RuneImpl&lt;/code&gt; is the underlying type used to store Runes, currently &lt;code&gt;int32&lt;/code&gt;.</source>
          <target state="translated">符文可以与其他符文组合成屏幕上的角色。 &lt;code&gt;RuneImpl&lt;/code&gt; 是用于存储符文的基础类型，当前为 &lt;code&gt;int32&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="97903ec287c9679803a5cf8de4f08e59be7ecca6" translate="yes" xml:space="preserve">
          <source>A Uniform Resource Identifier (URI) provides a simple and extensible means for identifying a resource. A URI can be further classified as a locator, a name, or both. The term &amp;ldquo;Uniform Resource Locator&amp;rdquo; (URL) refers to the subset of URIs.</source>
          <target state="translated">统一资源标识符（URI）提供了一种简单且可扩展的方式来标识资源。URI可以进一步分类为定位符，名称或两者。术语&amp;ldquo;统一资源定位符&amp;rdquo;（URL）指的是URI的子集。</target>
        </trans-unit>
        <trans-unit id="33b07af826ffc1642e9db6c9aa9ff6e43b9cc68a" translate="yes" xml:space="preserve">
          <source>A application-level error condition. For example, some user input generated an exception. The application will continue to run, but functionality or data was impacted, possibly visible to users.</source>
          <target state="translated">一个应用程序级别的错误条件。例如,一些用户输入产生了一个异常。应用程序将继续运行,但功能或数据受到影响,可能对用户可见。</target>
        </trans-unit>
        <trans-unit id="5d9beef18f6feec8ed926e501f6bc8ef50b29384" translate="yes" xml:space="preserve">
          <source>A application-level fatal condition. FATAL usually means that the application cannot go on and will exit (but this logging event will not do that for you).</source>
          <target state="translated">一个应用程序级别的致命条件。FATAL通常意味着应用程序无法继续运行并将退出(但这个日志事件不会为你做这件事)。</target>
        </trans-unit>
        <trans-unit id="0bc66569c7f749a991c86255655ab99ac30e86d5" translate="yes" xml:space="preserve">
          <source>A backslash followed by a letter is a built-in macro, otherwise it is used for ordinary escaping:</source>
          <target state="translated">字母后面的反斜杠是内置宏,否则用于普通转义。</target>
        </trans-unit>
        <trans-unit id="519b373c181ee8d4be473dddf120c85a8c41428c" translate="yes" xml:space="preserve">
          <source>A block can be left prematurely with a &lt;code&gt;break&lt;/code&gt; statement. The break statement can leave a &lt;code&gt;while&lt;/code&gt;, &lt;code&gt;for&lt;/code&gt;, or a &lt;code&gt;block&lt;/code&gt; statement. It leaves the innermost construct, unless a label of a block is given:</source>
          <target state="translated">可以使用 &lt;code&gt;break&lt;/code&gt; 语句过早地保留一个块。break语句可以保留 &lt;code&gt;while&lt;/code&gt; ， &lt;code&gt;for&lt;/code&gt; 或 &lt;code&gt;block&lt;/code&gt; 语句。除非给出块的标签，否则它将保留最内部的构造：</target>
        </trans-unit>
        <trans-unit id="2b2a65f3fbb55054c3c60c9c8e9467f1ea4b9e04" translate="yes" xml:space="preserve">
          <source>A bool is one byte long and it is &lt;code&gt;true&lt;/code&gt; for every non-zero (&lt;code&gt;0000_0000&lt;/code&gt;) value. Raises &lt;code&gt;IOError&lt;/code&gt; if an error occurred.</source>
          <target state="translated">布尔值是一个字节长，并且对于每个非零（ &lt;code&gt;0000_0000&lt;/code&gt; ）值都是 &lt;code&gt;true&lt;/code&gt; 。如果发生错误，则引发 &lt;code&gt;IOError&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="07808673548482e5392b9784984fdab8e702d49d" translate="yes" xml:space="preserve">
          <source>A borrow operation ends with the last usage of the view variable.</source>
          <target state="translated">一个借贷操作以视图变量的最后一次使用结束。</target>
        </trans-unit>
        <trans-unit id="f3a07d2cefd27e89258e2ff6a670ec933e438f77" translate="yes" xml:space="preserve">
          <source>A borrow starts with one of the following:</source>
          <target state="translated">借款的开头有以下几种情况之一。</target>
        </trans-unit>
        <trans-unit id="8018e99c199800e7c1d485e8e8e1d2de44558695" translate="yes" xml:space="preserve">
          <source>A call to an asynchronous procedure usually needs &lt;code&gt;await&lt;/code&gt; to wait for the completion of the &lt;code&gt;Future&lt;/code&gt;.</source>
          <target state="translated">对异步过程的调用通常需要 &lt;code&gt;await&lt;/code&gt; 以等待 &lt;code&gt;Future&lt;/code&gt; 的完成。</target>
        </trans-unit>
        <trans-unit id="92b34eeb7a8a85759a8e5d4110adc50791d4f3f3" translate="yes" xml:space="preserve">
          <source>A cast expression &lt;code&gt;cast[T](e)&lt;/code&gt; is a path expression.</source>
          <target state="translated">强制转换表达式 &lt;code&gt;cast[T](e)&lt;/code&gt; 是路径表达式。</target>
        </trans-unit>
        <trans-unit id="5c103f838d5fa5d3771bb4e300b47d90516af782" translate="yes" xml:space="preserve">
          <source>A character is not a Unicode character but a single byte. The reason for this is efficiency: for the overwhelming majority of use-cases, the resulting programs will still handle UTF-8 properly as UTF-8 was specially designed for this. Another reason is that Nim can thus support &lt;code&gt;array[char, int]&lt;/code&gt; or &lt;code&gt;set[char]&lt;/code&gt; efficiently as many algorithms rely on this feature. The &lt;code&gt;Rune&lt;/code&gt; type is used for Unicode characters, it can represent any Unicode character. &lt;code&gt;Rune&lt;/code&gt; is declared in the &lt;a href=&quot;unicode&quot;&gt;unicode module&lt;/a&gt;.</source>
          <target state="translated">字符不是Unicode字符，而是一个字节。原因是效率：对于绝大多数用例，由于UTF-8是为此专门设计的，因此生成的程序仍将正确处理UTF-8。另一个原因是，由于许多算法都依赖此功能 &lt;code&gt;array[char, int]&lt;/code&gt; 因此Nim可以有效地支持array [char，int]或 &lt;code&gt;set[char]&lt;/code&gt; 。的 &lt;code&gt;Rune&lt;/code&gt; 类型用于Unicode字符，它可以代表任何Unicode字符。 &lt;code&gt;Rune&lt;/code&gt; 在&lt;a href=&quot;unicode&quot;&gt;unicode模块中&lt;/a&gt;声明。</target>
        </trans-unit>
        <trans-unit id="6bd1dcf8b598ce13fe780f11e538b4c3679116e3" translate="yes" xml:space="preserve">
          <source>A character is not an Unicode character but a single byte. The reason for this is efficiency: for the overwhelming majority of use-cases, the resulting programs will still handle UTF-8 properly as UTF-8 was specially designed for this. Another reason is that Nim can thus support &lt;code&gt;array[char, int]&lt;/code&gt; or &lt;code&gt;set[char]&lt;/code&gt; efficiently as many algorithms rely on this feature. The &lt;em&gt;Rune&lt;/em&gt; type is used for Unicode characters, it can represent any Unicode character. &lt;code&gt;Rune&lt;/code&gt; is declared in the &lt;a href=&quot;unicode&quot;&gt;unicode module&lt;/a&gt;.</source>
          <target state="translated">字符不是Unicode字符，而是单个字节。原因是效率：对于绝大多数用例，由于UTF-8是为此专门设计的，因此生成的程序仍将正确处理UTF-8。另一个原因是Nim可以有效地支持 &lt;code&gt;array[char, int]&lt;/code&gt; 或 &lt;code&gt;set[char]&lt;/code&gt; 因为许多算法都依赖此功能。的&lt;em&gt;符文&lt;/em&gt;类型用于Unicode字符，它可以代表任何Unicode字符。 &lt;code&gt;Rune&lt;/code&gt; 在&lt;a href=&quot;unicode&quot;&gt;unicode模块中&lt;/a&gt;声明。</target>
        </trans-unit>
        <trans-unit id="02438431477b9f284f329a8125ca2c9ad9d3544e" translate="yes" xml:space="preserve">
          <source>A color stored as RGB, e.g. &lt;code&gt;0xff00cc&lt;/code&gt;.</source>
          <target state="translated">存储为RGB的颜色，例如 &lt;code&gt;0xff00cc&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="464ccfc3644339c90fe83b96ac6cc6d2ac6904e3" translate="yes" xml:space="preserve">
          <source>A command-line switch &lt;code&gt;--FOO&lt;/code&gt; is written as &lt;code&gt;switch(&quot;FOO&quot;)&lt;/code&gt; in NimScript. Similarly, command-line &lt;code&gt;--FOO:VAL&lt;/code&gt; translates to &lt;code&gt;switch(&quot;FOO&quot;, &quot;VAL&quot;)&lt;/code&gt;.</source>
          <target state="translated">命令行开关 &lt;code&gt;--FOO&lt;/code&gt; 在NimScript中写为 &lt;code&gt;switch(&quot;FOO&quot;)&lt;/code&gt; 。类似地，命令行 &lt;code&gt;--FOO:VAL&lt;/code&gt; 转换为 &lt;code&gt;switch(&quot;FOO&quot;, &quot;VAL&quot;)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="27a21ba557cb1102184eb887daf5fb2f0ee516b2" translate="yes" xml:space="preserve">
          <source>A compile-time error will be produced if the supplied type is not generic.</source>
          <target state="translated">如果提供的类型不是通用的,将产生一个编译时错误。</target>
        </trans-unit>
        <trans-unit id="9e63142b740226a78a46d8a1af8bf22743ac95c8" translate="yes" xml:space="preserve">
          <source>A config file was loaded.</source>
          <target state="translated">一个配置文件被加载。</target>
        </trans-unit>
        <trans-unit id="4e0bfb8692e714161fc85476e6dc2bea3acca4aa" translate="yes" xml:space="preserve">
          <source>A const section declares constants whose values are constant expressions:</source>
          <target state="translated">常量部分声明常量,其值是常量表达式。</target>
        </trans-unit>
        <trans-unit id="61b8c94d978f3588a0582bb78409af7deb66813e" translate="yes" xml:space="preserve">
          <source>A constant array/seq/object/tuple constructor.</source>
          <target state="translated">一个常数组/序列/对象/元组构造函数。</target>
        </trans-unit>
        <trans-unit id="0064db9e288278b0376c2e5e320a96dacd41e609" translate="yes" xml:space="preserve">
          <source>A constant expression can contain code blocks that may internally use all Nim features supported at compile time (as detailed in the next section below). Within such a code block, it is possible to declare variables and then later read and update them, or declare variables and pass them to procedures that modify them. However, the code in such a block must still adhere to the restrictions listed above for referencing values and operations outside the block.</source>
          <target state="translated">一个常量表达式可以包含代码块,这些代码块可以在内部使用编译时支持的所有Nim特性(详见下面下一节)。在这样的代码块中,可以声明变量,然后再读取和更新它们,或者声明变量并将它们传递给修改它们的程序。但是,这种代码块中的代码仍然必须遵守上面列出的限制,以便在代码块之外引用值和操作。</target>
        </trans-unit>
        <trans-unit id="9d676346fde6cb6856b2edfe8fcc862ca9818983" translate="yes" xml:space="preserve">
          <source>A contains element e</source>
          <target state="translated">A包含要素e</target>
        </trans-unit>
        <trans-unit id="a97fa9396c800de48716801c7cc433f027d4fd9e" translate="yes" xml:space="preserve">
          <source>A convenience proc for:</source>
          <target state="translated">一个方便的程序,用于:</target>
        </trans-unit>
        <trans-unit id="be06b381f65f6401540a9a933e32c54008aff8d5" translate="yes" xml:space="preserve">
          <source>A convenience proc that runs the &lt;code&gt;command&lt;/code&gt;, and returns its &lt;code&gt;output&lt;/code&gt; and &lt;code&gt;exitCode&lt;/code&gt;. &lt;code&gt;env&lt;/code&gt; and &lt;code&gt;workingDir&lt;/code&gt; params behave as for &lt;code&gt;startProcess&lt;/code&gt;. If &lt;code&gt;input.len &amp;gt; 0&lt;/code&gt;, it is passed as stdin.</source>
          <target state="translated">运行 &lt;code&gt;command&lt;/code&gt; 并返回其 &lt;code&gt;output&lt;/code&gt; 和 &lt;code&gt;exitCode&lt;/code&gt; 的便捷proc 。 &lt;code&gt;env&lt;/code&gt; 和 &lt;code&gt;workingDir&lt;/code&gt; 参数的行为与 &lt;code&gt;startProcess&lt;/code&gt; 相同。如果 &lt;code&gt;input.len &amp;gt; 0&lt;/code&gt; ，则将其作为stdin传递。</target>
        </trans-unit>
        <trans-unit id="cacfb1ec37d6c63df0aece0717105dfb5b1e961d" translate="yes" xml:space="preserve">
          <source>A convenience procedure that executes &lt;code&gt;command&lt;/code&gt; with &lt;code&gt;startProcess&lt;/code&gt; and returns its output as a string.</source>
          <target state="translated">一个方便的过程，该过程使用 &lt;code&gt;startProcess&lt;/code&gt; 执行 &lt;code&gt;command&lt;/code&gt; 并以字符串形式返回其输出。</target>
        </trans-unit>
        <trans-unit id="cd669926d307684088d5ef478be7b22480b9a5f4" translate="yes" xml:space="preserve">
          <source>A convenience procedure that executes &lt;code&gt;command&lt;/code&gt; with &lt;code&gt;startProcess&lt;/code&gt; and returns its output as a string. WARNING: this function uses poEvalCommand by default for backward compatibility. Make sure to pass options explicitly.</source>
          <target state="translated">一个方便的过程，该过程使用 &lt;code&gt;startProcess&lt;/code&gt; 执行 &lt;code&gt;command&lt;/code&gt; 并以字符串形式返回其输出。警告：默认情况下，此函数使用poEvalCommand以获得向后兼容性。确保明确传递选项。</target>
        </trans-unit>
        <trans-unit id="d5eda57047be93a6d8ede446c939b622a61fcad5" translate="yes" xml:space="preserve">
          <source>A convention is that exceptions should be raised in &lt;em&gt;exceptional&lt;/em&gt; cases: For example, if a file cannot be opened, this should not raise an exception since this is quite common (the file may not exist).</source>
          <target state="translated">约定在&lt;em&gt;特殊&lt;/em&gt;情况下应引发&lt;em&gt;异常&lt;/em&gt;：例如，如果无法打开文件，则不应引发异常，因为这很常见（文件可能不存在）。</target>
        </trans-unit>
        <trans-unit id="9dc4e7e8a36779be1253db430e17a3ece42f97f6" translate="yes" xml:space="preserve">
          <source>A converter can also be explicitly invoked for improved readability. Note that implicit converter chaining is not supported: If there is a converter from type A to type B and from type B to type C the implicit conversion from A to C is not provided.</source>
          <target state="translated">为了提高可读性,也可以显式调用转换器。注意,不支持隐式转换器链。如果有一个从A型到B型和从B型到C型的转换器,则不提供从A到C的隐式转换。</target>
        </trans-unit>
        <trans-unit id="0fabf98da32833f2ac2d72c57027f686f2dbd28b" translate="yes" xml:space="preserve">
          <source>A converter is like an ordinary proc except that it enhances the &quot;implicitly convertible&quot; type relation (see &lt;a href=&quot;#type-relations-convertible-relation&quot;&gt;Convertible relation&lt;/a&gt;):</source>
          <target state="translated">转换器与普通proc相似，除了它增强了&amp;ldquo;隐式可转换&amp;rdquo;类型关系（请参阅&lt;a href=&quot;#type-relations-convertible-relation&quot;&gt;Convertible关系&lt;/a&gt;）：</target>
        </trans-unit>
        <trans-unit id="ff0115af818672bc6f62e11d492d4642e32f4663" translate="yes" xml:space="preserve">
          <source>A converter is similar to a proc.</source>
          <target state="translated">转换器类似于一个程序。</target>
        </trans-unit>
        <trans-unit id="95b68e940e0a6eefa4655d5db413050f4aee06c6" translate="yes" xml:space="preserve">
          <source>A curly expression with commas in it like &lt;code&gt;{x, argA, argB}&lt;/code&gt; could be transformed to &lt;code&gt;format(x, argA, argB, res)&lt;/code&gt; in order to support formatters that do not need to parse a custom language within a custom language but instead prefer to use Nim's existing syntax. This also helps in readability since there is only so much you can cram into single letter DSLs.</source>
          <target state="translated">可以将其中带有逗号的卷曲表达式（如 &lt;code&gt;{x, argA, argB}&lt;/code&gt; 转换为 &lt;code&gt;format(x, argA, argB, res)&lt;/code&gt; ，以支持不需要在自定义语言中解析自定义语言的格式化程序，而更喜欢使用Nim的现有语法。这也有助于提高可读性，因为您只能塞入单字母DSL。</target>
        </trans-unit>
        <trans-unit id="dfc4ab3114e21dfe437697844b567a3fec4ddcb5" translate="yes" xml:space="preserve">
          <source>A curly expression with commas in it like &lt;code&gt;{x, argA, argB}&lt;/code&gt; could be transformed to &lt;code&gt;formatValue(result, x, argA, argB)&lt;/code&gt; in order to support formatters that do not need to parse a custom language within a custom language but instead prefer to use Nim's existing syntax. This also helps in readability since there is only so much you can cram into single letter DSLs.</source>
          <target state="translated">可以将其中带有逗号的卷曲表达式（如 &lt;code&gt;{x, argA, argB}&lt;/code&gt; 转换为 &lt;code&gt;formatValue(result, x, argA, argB)&lt;/code&gt; ，以支持不需要在自定义语言中解析自定义语言的格式化程序，而更喜欢使用Nim的现有语法。这也有助于提高可读性，因为您只能塞入单字母DSL。</target>
        </trans-unit>
        <trans-unit id="e3fa03d2d9ca46b9edc2c32896fd2039415253ab" translate="yes" xml:space="preserve">
          <source>A data flow variable.</source>
          <target state="translated">一个数据流变量。</target>
        </trans-unit>
        <trans-unit id="af339bf252ebc6686a22fa957452c6666fabae1d" translate="yes" xml:space="preserve">
          <source>A destructible context is currently only the following:</source>
          <target state="translated">可破坏的上下文目前只有以下几种。</target>
        </trans-unit>
        <trans-unit id="a4828b4e1e76af08cdc61d3da41001844c8e7647" translate="yes" xml:space="preserve">
          <source>A destructor is attached to the type it destructs; expressions of this type can then only be used in &lt;em&gt;destructible contexts&lt;/em&gt; and as parameters:</source>
          <target state="translated">析构函数附加到其析构的类型；然后，这种类型的表达式只能在可&lt;em&gt;破坏的上下文中&lt;/em&gt;用作参数：</target>
        </trans-unit>
        <trans-unit id="5433f8711be01e7d00dc897cddea4967983783a7" translate="yes" xml:space="preserve">
          <source>A destructor must have a single parameter with a concrete type (the name of a generic type is allowed too). The name of the destructor has to be &lt;code&gt;=destroy&lt;/code&gt;.</source>
          <target state="translated">析构函数必须具有一个带有具体类型的参数（也可以使用通用类型的名称）。析构函数的名称必须为 &lt;code&gt;=destroy&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b51be317d37d0d9e5679921ffa2c4f39470a9227" translate="yes" xml:space="preserve">
          <source>A directory can also be a so called &quot;pseudo directory&quot;. They can be used to avoid ambiguity when there are multiple modules with the same path.</source>
          <target state="translated">一个目录也可以是一个所谓的 &quot;伪目录&quot;。当有多个模块的路径相同时,可以用它们来避免歧义。</target>
        </trans-unit>
        <trans-unit id="ba9a4b41df6580ad5e8acb6a3c21939ab2ed47ab" translate="yes" xml:space="preserve">
          <source>A directory can also be a so-called &quot;pseudo directory&quot;. They can be used to avoid ambiguity when there are multiple modules with the same path.</source>
          <target state="translated">一个目录也可以是一个所谓的 &quot;伪目录&quot;。当有多个模块的路径相同时,可以用它们来避免歧义。</target>
        </trans-unit>
        <trans-unit id="95e50b8a4c29848e0e58c481e1f4e2be74e28e1a" translate="yes" xml:space="preserve">
          <source>A distinct string type that is &lt;span id=&quot;tainted_1&quot;&gt;tainted&lt;/span&gt;, see &lt;a href=&quot;manual_experimental#taint-mode&quot;&gt;taint mode&lt;/a&gt; for details. It is an alias for &lt;code&gt;string&lt;/code&gt; if the taint mode is not turned on.</source>
          <target state="translated">一种受&lt;span id=&quot;tainted_1&quot;&gt;污染的&lt;/span&gt;独特字符串类型，有关详细信息，请参见&lt;a href=&quot;manual_experimental#taint-mode&quot;&gt;污染模式&lt;/a&gt;。如果未打开异味模式，则它是 &lt;code&gt;string&lt;/code&gt; 的别名。</target>
        </trans-unit>
        <trans-unit id="2010acb176bc59e66e9596fccd16c6be234aa62b" translate="yes" xml:space="preserve">
          <source>A distinct type can be used to model different physical &lt;span id=&quot;units_1&quot;&gt;units&lt;/span&gt; with a numerical base type, for example. The following example models currencies.</source>
          <target state="translated">例如，可以使用不同的类型对具有数字基类型的不同物理&lt;span id=&quot;units_1&quot;&gt;单位&lt;/span&gt;进行建模。以下示例对货币建模。</target>
        </trans-unit>
        <trans-unit id="5b70baaf6a3c1cf02cffd9a4c12db14e78c7e2e0" translate="yes" xml:space="preserve">
          <source>A distinct type is an ordinal type if its base type is an ordinal type.</source>
          <target state="translated">如果一个独特类型的基类型是一个序类型,那么它就是一个序类型。</target>
        </trans-unit>
        <trans-unit id="0dcbf503ecd251b550b20573f306de222e9f6e39" translate="yes" xml:space="preserve">
          <source>A does not contain element e</source>
          <target state="translated">A不包含元素e</target>
        </trans-unit>
        <trans-unit id="7339291827f4b694e439170ba77d07b22a6ba2d9" translate="yes" xml:space="preserve">
          <source>A dot following the hash &lt;code&gt;#.&lt;/code&gt; indicates that the call should use C++'s dot or arrow notation.</source>
          <target state="translated">井号 &lt;code&gt;#.&lt;/code&gt; 之后的点。指示该调用应使用C ++的点或箭头表示法。</target>
        </trans-unit>
        <trans-unit id="91daa2e8d1d787e2cb1cebec501d70a447fbdd47" translate="yes" xml:space="preserve">
          <source>A double quotation mark preceded by a backslash (&quot;) is interpreted as a literal double quotation mark character (&quot;).</source>
          <target state="translated">双引号前的反斜杠(&quot;)被解释为字面的双引号字符(&quot;)。</target>
        </trans-unit>
        <trans-unit id="5b983689cc856655c0945357d3fc5752f335fd52" translate="yes" xml:space="preserve">
          <source>A double-ended queue backed with a ringed seq buffer.</source>
          <target state="translated">一个环形seq缓冲区支持的双端队列。</target>
        </trans-unit>
        <trans-unit id="37b3c8d877a1796e2ce2b752a84672e2b698b73f" translate="yes" xml:space="preserve">
          <source>A doubly linked list.</source>
          <target state="translated">双重联系的名单。</target>
        </trans-unit>
        <trans-unit id="dc610ca5779e2c4149fb2f04ff29af536258d4e9" translate="yes" xml:space="preserve">
          <source>A doubly linked ring.</source>
          <target state="translated">一个双联环。</target>
        </trans-unit>
        <trans-unit id="5ca1163da7023e239f0374687ad85cf02cf7bedd" translate="yes" xml:space="preserve">
          <source>A faster approach if you don't need to run the full bootstrapping implied by &lt;code&gt;koch boot&lt;/code&gt;, is the following:</source>
          <target state="translated">如果您不需要运行 &lt;code&gt;koch boot&lt;/code&gt; 暗示的完整引导程序，则可以采用以下更快的方法：</target>
        </trans-unit>
        <trans-unit id="fec95403df4da1203b32ec4a5895c4b2f97d7469" translate="yes" xml:space="preserve">
          <source>A file stream object.</source>
          <target state="translated">一个文件流对象。</target>
        </trans-unit>
        <trans-unit id="01ed7c56b187204e313f1f9d97ebfebcc0fecee3" translate="yes" xml:space="preserve">
          <source>A for loop variable.</source>
          <target state="translated">一个for循环变量。</target>
        </trans-unit>
        <trans-unit id="be05d01928ee989b51c293af8a8ced991ffc3f8b" translate="yes" xml:space="preserve">
          <source>A formal parameter of &lt;code&gt;p&lt;/code&gt;. Note that this does not cover parameters of inner procs.</source>
          <target state="translated">&lt;code&gt;p&lt;/code&gt; 的形式参数。请注意，这不包括内部proc的参数。</target>
        </trans-unit>
        <trans-unit id="b4530327f82b08f79eb5415f2f6266f23e82dea1" translate="yes" xml:space="preserve">
          <source>A friendlier version of &lt;code&gt;initRational&lt;/code&gt;. Example usage:</source>
          <target state="translated">一个更友好的版本 &lt;code&gt;initRational&lt;/code&gt; 。用法示例：</target>
        </trans-unit>
        <trans-unit id="7d654b825945bd5f2a34963e2ce499f362a2a00c" translate="yes" xml:space="preserve">
          <source>A friendlier version of &lt;em&gt;initRational&lt;/em&gt;. Example usage:</source>
          <target state="translated">一个更友好的&lt;em&gt;initRational&lt;/em&gt;版本。用法示例：</target>
        </trans-unit>
        <trans-unit id="d411518da35d7d553e49043b1323d3beb87db97b" translate="yes" xml:space="preserve">
          <source>A generic hash set that remembers insertion order.</source>
          <target state="translated">一个记住插入顺序的通用哈希集。</target>
        </trans-unit>
        <trans-unit id="e82bc7694d12c8d0a1eda93534f23d36363f6058" translate="yes" xml:space="preserve">
          <source>A generic hash set.</source>
          <target state="translated">一个通用的哈希集。</target>
        </trans-unit>
        <trans-unit id="bc808d927cb66e18ab41120dbc8ca9a77184e013" translate="yes" xml:space="preserve">
          <source>A global &lt;code&gt;let&lt;/code&gt; or &lt;code&gt;const&lt;/code&gt;.</source>
          <target state="translated">全局 &lt;code&gt;let&lt;/code&gt; 或 &lt;code&gt;const&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="320cebf4d78ce3c1be14804824f001c260bf7a66" translate="yes" xml:space="preserve">
          <source>A global or thread local variable (or a location derived from such a location) can only passed to a parameter of a &lt;code&gt;.noSideEffect&lt;/code&gt; proc.</source>
          <target state="translated">全局或线程局部变量（或从该位置派生的位置）只能传递给 &lt;code&gt;.noSideEffect&lt;/code&gt; proc的参数。</target>
        </trans-unit>
        <trans-unit id="2ffca0b13c686c6b15efaaaca93d32f1c984c75c" translate="yes" xml:space="preserve">
          <source>A good start is to use the &lt;code&gt;any&lt;/code&gt; operating target together with the &lt;code&gt;malloc&lt;/code&gt; memory allocator and the &lt;code&gt;arc&lt;/code&gt; garbage collector. For example:</source>
          <target state="translated">一个好的开始是将 &lt;code&gt;any&lt;/code&gt; 操作目标与 &lt;code&gt;malloc&lt;/code&gt; 内存分配器和 &lt;code&gt;arc&lt;/code&gt; 垃圾收集器一起使用。例如：</target>
        </trans-unit>
        <trans-unit id="a81ac463f2bf0a449eb382ce5892e833e89db3c5" translate="yes" xml:space="preserve">
          <source>A handle that can be used to get a row's column text on demand.</source>
          <target state="translated">一个句柄,可用于根据需求获取行的列文本。</target>
        </trans-unit>
        <trans-unit id="9e98d244bf1a5c7aeeae52fd19acf41b5eb1f418" translate="yes" xml:space="preserve">
          <source>A hash &lt;code&gt;#&lt;/code&gt; symbol is replaced by the first or next argument.</source>
          <target state="translated">井号 &lt;code&gt;#&lt;/code&gt; 符号将替换为第一个或下一个参数。</target>
        </trans-unit>
        <trans-unit id="9d4597dbb40515320cfb7ba4a5ab9fff9f4b8d6f" translate="yes" xml:space="preserve">
          <source>A hash value. Hash tables using these values should always have a size of a power of two and can use the &lt;code&gt;and&lt;/code&gt; operator instead of &lt;code&gt;mod&lt;/code&gt; for truncation of the hash value.</source>
          <target state="translated">哈希值。使用这些值的哈希表的大小应始终为2的幂，并且可以使用 &lt;code&gt;and&lt;/code&gt; 运算符而不是 &lt;code&gt;mod&lt;/code&gt; 来截断哈希值。</target>
        </trans-unit>
        <trans-unit id="149c44455ceb35c4ee96ca72b2281853444910fc" translate="yes" xml:space="preserve">
          <source>A heap queue, commonly known as a priority queue.</source>
          <target state="translated">堆队列,俗称优先队列。</target>
        </trans-unit>
        <trans-unit id="a53f6ddc26d79601afed6742fbd39fc945dc2d24" translate="yes" xml:space="preserve">
          <source>A helper for wrapping callback-based functions into promises and async procedures</source>
          <target state="translated">用于将基于回调的函数封装到承诺和异步过程中的辅助工具</target>
        </trans-unit>
        <trans-unit id="1cfeb2fc1a7aa8005e527ab8a5293d0f37aa50de" translate="yes" xml:space="preserve">
          <source>A higher level &lt;code&gt;ODBC&lt;/code&gt; database wrapper.</source>
          <target state="translated">更高级别的 &lt;code&gt;ODBC&lt;/code&gt; 数据库包装器。</target>
        </trans-unit>
        <trans-unit id="8f2cac0c1f19b93707af84e96c8e8344199be1d8" translate="yes" xml:space="preserve">
          <source>A higher level &lt;em&gt;ODBC&lt;/em&gt; database wrapper.</source>
          <target state="translated">更高级别的&lt;em&gt;ODBC&lt;/em&gt;数据库包装器。</target>
        </trans-unit>
        <trans-unit id="d7086b8bccfe459c43887557d6fccf6aaa7324be" translate="yes" xml:space="preserve">
          <source>A higher level &lt;span id=&quot;mysql_1&quot;&gt;mySQL&lt;/span&gt; database wrapper. The same interface is implemented for other databases too.</source>
          <target state="translated">更高级别的&lt;span id=&quot;mysql_1&quot;&gt;mySQL&lt;/span&gt;数据库包装器。其他数据库也实现了相同的接口。</target>
        </trans-unit>
        <trans-unit id="7ed449265b711e313a4301b54cee15ef550acdbf" translate="yes" xml:space="preserve">
          <source>A higher level &lt;span id=&quot;postgresql_1&quot;&gt;PostgreSQL&lt;/span&gt; database wrapper. This interface is implemented for other databases also.</source>
          <target state="translated">更高级别的&lt;span id=&quot;postgresql_1&quot;&gt;PostgreSQL&lt;/span&gt;数据库包装器。该接口也为其他数据库实现。</target>
        </trans-unit>
        <trans-unit id="18d9c046b2d8f8fc8c6daccb16db460900a01a66" translate="yes" xml:space="preserve">
          <source>A higher level &lt;span id=&quot;sqlite_1&quot;&gt;SQLite&lt;/span&gt; database wrapper. This interface is implemented for other databases too.</source>
          <target state="translated">更高级别的&lt;span id=&quot;sqlite_1&quot;&gt;SQLite&lt;/span&gt;数据库包装器。该接口也为其他数据库实现。</target>
        </trans-unit>
        <trans-unit id="17cc08bc05f9e3c22bbf4a01b73d4951016af63c" translate="yes" xml:space="preserve">
          <source>A label (used in &lt;code&gt;block&lt;/code&gt; statements).</source>
          <target state="translated">标签（在 &lt;code&gt;block&lt;/code&gt; 语句中使用）。</target>
        </trans-unit>
        <trans-unit id="89265eb4f02e06930cfb5c35dd5f76b04d9c0a16" translate="yes" xml:space="preserve">
          <source>A last tip when writing a macro: if you are not sure the AST you are building looks ok, you may be tempted to use the &lt;code&gt;dumpTree&lt;/code&gt; macro. But you can't use it &lt;em&gt;inside&lt;/em&gt; the macro you are writting/debugging. Instead &lt;code&gt;echo&lt;/code&gt; the string generated by &lt;a href=&quot;macros#treeRepr&quot;&gt;treeRepr&lt;/a&gt;. If at the end of the this example you add &lt;code&gt;echo treeRepr(result)&lt;/code&gt; you should get the same output as using the &lt;code&gt;dumpTree&lt;/code&gt; macro, but of course you can call that at any point of the macro where you might be having troubles.</source>
          <target state="translated">编写宏时的最后一个提示：如果不确定要构建的AST看起来还不错，则可能会想使用 &lt;code&gt;dumpTree&lt;/code&gt; 宏。但是您不能&lt;em&gt;在&lt;/em&gt;要编写/调试的宏中使用它。而是 &lt;code&gt;echo&lt;/code&gt; 显&lt;a href=&quot;macros#treeRepr&quot;&gt;treeRepr&lt;/a&gt;生成的字符串。如果在本示例的最后添加了 &lt;code&gt;echo treeRepr(result)&lt;/code&gt; ，则应该获得与使用 &lt;code&gt;dumpTree&lt;/code&gt; 宏相同的输出，但是当然可以在可能遇到麻烦的宏的任何位置调用它。</target>
        </trans-unit>
        <trans-unit id="e62c0496669da44a5936805a3cdfee1fe957384a" translate="yes" xml:space="preserve">
          <source>A leaf of the AST often corresponds to a terminal symbol in the concrete syntax. Note that the default &lt;code&gt;float&lt;/code&gt; in Nim maps to &lt;code&gt;float64&lt;/code&gt; such that the default AST for a float is &lt;code&gt;nnkFloat64Lit&lt;/code&gt; as below.</source>
          <target state="translated">AST的叶子通常在具体语法中对应于终端符号。请注意，Nim 中的默认 &lt;code&gt;float&lt;/code&gt; 映射到 &lt;code&gt;float64&lt;/code&gt; ，使得浮点数的默认AST为 &lt;code&gt;nnkFloat64Lit&lt;/code&gt; ，如下所示。</target>
        </trans-unit>
        <trans-unit id="ca1d57971d26f802ed23be891e23648148c8e483" translate="yes" xml:space="preserve">
          <source>A line of text may be delimited by &lt;code&gt;CR&lt;/code&gt;, &lt;code&gt;LF&lt;/code&gt; or &lt;code&gt;CRLF&lt;/code&gt;. The newline character(s) are not part of the returned string. Returns &lt;code&gt;false&lt;/code&gt; if the end of the file has been reached, &lt;code&gt;true&lt;/code&gt; otherwise. If &lt;code&gt;false&lt;/code&gt; is returned &lt;code&gt;line&lt;/code&gt; contains no new data.</source>
          <target state="translated">一行文字可以用 &lt;code&gt;CR&lt;/code&gt; ， &lt;code&gt;LF&lt;/code&gt; 或 &lt;code&gt;CRLF&lt;/code&gt; 分隔。换行符不属于返回字符串的一部分。如果已到达文件末尾，则返回 &lt;code&gt;false&lt;/code&gt; ，否则返回 &lt;code&gt;true&lt;/code&gt; 。如果返回 &lt;code&gt;false&lt;/code&gt; ,则该 &lt;code&gt;line&lt;/code&gt; 包含任何新数据。</target>
        </trans-unit>
        <trans-unit id="581948684a5ccce62ab36b49581dc62c13de2828" translate="yes" xml:space="preserve">
          <source>A line of text may be delimited by &lt;code&gt;LF&lt;/code&gt; or &lt;code&gt;CRLF&lt;/code&gt;. The newline character(s) are not part of the returned string. Returns &lt;code&gt;false&lt;/code&gt; if the end of the file has been reached, &lt;code&gt;true&lt;/code&gt; otherwise. If &lt;code&gt;false&lt;/code&gt; is returned &lt;code&gt;line&lt;/code&gt; contains no new data.</source>
          <target state="translated">一行文字可以用 &lt;code&gt;LF&lt;/code&gt; 或 &lt;code&gt;CRLF&lt;/code&gt; 分隔。换行符不属于返回字符串的一部分。如果已到达文件末尾，则返回 &lt;code&gt;false&lt;/code&gt; ，否则返回 &lt;code&gt;true&lt;/code&gt; 。如果返回 &lt;code&gt;false&lt;/code&gt; ,则该 &lt;code&gt;line&lt;/code&gt; 包含任何新数据。</target>
        </trans-unit>
        <trans-unit id="68a5c4a0e6620a00360c556904f05a47c92cf341" translate="yes" xml:space="preserve">
          <source>A local &lt;code&gt;var&lt;/code&gt; or &lt;code&gt;let&lt;/code&gt; or &lt;code&gt;const&lt;/code&gt; of &lt;code&gt;p&lt;/code&gt;. Note that this does not cover locals of inner procs.</source>
          <target state="translated">本地 &lt;code&gt;var&lt;/code&gt; 或 &lt;code&gt;let&lt;/code&gt; 或 &lt;code&gt;const&lt;/code&gt; 的 &lt;code&gt;p&lt;/code&gt; 。请注意，这并不涵盖内部proc的本地语言。</target>
        </trans-unit>
        <trans-unit id="f6c3ae6180bd4456adc133775e78037d9dbc3bb3" translate="yes" xml:space="preserve">
          <source>A local variable of a view type &lt;em&gt;borrows&lt;/em&gt; from the locations and it is statically enforced that the view does not outlive the location it was borrowed from.</source>
          <target state="translated">视图类型的局部变量是从这些位置&lt;em&gt;借用的&lt;/em&gt;，并且静态地强制该视图不超过从其借用的位置。</target>
        </trans-unit>
        <trans-unit id="6a4f1963c6d5c717eedc6061f40a2aad389a69ee" translate="yes" xml:space="preserve">
          <source>A local variable of a view type can borrow from a location derived from a parameter, another local variable, a global &lt;code&gt;const&lt;/code&gt; or &lt;code&gt;let&lt;/code&gt; symbol or a thread-local &lt;code&gt;var&lt;/code&gt; or &lt;code&gt;let&lt;/code&gt;.</source>
          <target state="translated">视图类型的局部变量可以从参数派生的位置，另一个局部变量，全局 &lt;code&gt;const&lt;/code&gt; 或 &lt;code&gt;let&lt;/code&gt; 符号或线程局部 &lt;code&gt;var&lt;/code&gt; 或 &lt;code&gt;let&lt;/code&gt; 借用。</target>
        </trans-unit>
        <trans-unit id="af284b25e3830a68d5e3016b0dc1d22187bec97a" translate="yes" xml:space="preserve">
          <source>A local variable shadows another local variable of an outer scope.</source>
          <target state="translated">一个局部变量对外部作用域的另一个局部变量进行了遮挡。</target>
        </trans-unit>
        <trans-unit id="de6bcdccdc5c7e0b1b4816e44fb7d53da0a609cf" translate="yes" xml:space="preserve">
          <source>A location derived from &lt;code&gt;source&lt;/code&gt; is then defined as a path expression that has &lt;code&gt;source&lt;/code&gt; as the owner. A path expression &lt;code&gt;e&lt;/code&gt; is defined recursively:</source>
          <target state="translated">然后，将从 &lt;code&gt;source&lt;/code&gt; 派生的位置定义为以 &lt;code&gt;source&lt;/code&gt; 为所有者的路径表达式。路径表达式 &lt;code&gt;e&lt;/code&gt; 递归定义：</target>
        </trans-unit>
        <trans-unit id="967771f695ceb39091660c735188c9512c3f76d5" translate="yes" xml:space="preserve">
          <source>A logger that writes log messages to a file while performing log rotation.</source>
          <target state="translated">在进行日志轮换的同时,将日志信息写入文件的记录器。</target>
        </trans-unit>
        <trans-unit id="b1a7205870823565c52ef4c52be7d4fff3d9573c" translate="yes" xml:space="preserve">
          <source>A logger that writes log messages to a file.</source>
          <target state="translated">一个将日志信息写入文件的记录器。</target>
        </trans-unit>
        <trans-unit id="9b1885737ecb72a367c6c34335e96773c3da6a62" translate="yes" xml:space="preserve">
          <source>A logger that writes log messages to the console.</source>
          <target state="translated">一个向控制台写入日志信息的记录器。</target>
        </trans-unit>
        <trans-unit id="91fde29a5bcb0f41a42b7a89bca04718dd4f756c" translate="yes" xml:space="preserve">
          <source>A macro is a special function that is executed at compile time. Normally the input for a macro is an abstract syntax tree (AST) of the code that is passed to it. The macro can then do transformations on it and return the transformed AST. This can be used to add custom language features and implement &lt;span id=&quot;domainminusspecific-languages_1&quot;&gt;domain-specific languages&lt;/span&gt;.</source>
          <target state="translated">宏是在编译时执行的特殊功能。通常，宏的输入是传递给它的代码的抽象语法树（AST）。然后宏可以对其进行转换并返回转换后的AST。这可用于添加自定义语言功能并实现&lt;span id=&quot;domainminusspecific-languages_1&quot;&gt;特定于域的语言&lt;/span&gt;。</target>
        </trans-unit>
        <trans-unit id="d15ac9d0ba716c535ed2ce2885c3b9d90285db47" translate="yes" xml:space="preserve">
          <source>A macro is a special function that is executed at compile-time. Normally the input for a macro is an abstract syntax tree (AST) of the code that is passed to it. The macro can then do transformations on it and return the transformed AST. The transformed AST is then passed to the compiler as if the macro invocation would have been replaced by its result in the source code. This can be used to implement &lt;span id=&quot;domain-specific-languages_1&quot;&gt;domain specific languages&lt;/span&gt;.</source>
          <target state="translated">宏是在编译时执行的特殊功能。通常，宏的输入是传递给它的代码的抽象语法树（AST）。然后宏可以对其进行转换并返回转换后的AST。然后将转换后的AST传递给编译器，就好像宏调用将被源代码中的结果替换一样。这可以用来实现&lt;span id=&quot;domain-specific-languages_1&quot;&gt;特定领域的语言&lt;/span&gt;。</target>
        </trans-unit>
        <trans-unit id="2320939f622f35d906ef2dffec7b8d388f8158e3" translate="yes" xml:space="preserve">
          <source>A macro that needs to be called &lt;span id=&quot;match_1&quot;&gt;match&lt;/span&gt; can be used to rewrite &lt;code&gt;case&lt;/code&gt; statements in order to implement &lt;span id=&quot;pattern-matching_1&quot;&gt;pattern matching&lt;/span&gt; for certain types. The following example implements a simplistic form of pattern matching for tuples, leveraging the existing equality operator for tuples (as provided in &lt;code&gt;system.==&lt;/code&gt;):</source>
          <target state="translated">可以将需要调用&lt;span id=&quot;match_1&quot;&gt;match的&lt;/span&gt;宏用于重写 &lt;code&gt;case&lt;/code&gt; 语句，以实现某些类型的&lt;span id=&quot;pattern-matching_1&quot;&gt;模式匹配&lt;/span&gt;。以下示例为元组实现了模式匹配的简化形式，利用了元组的现有相等运算符（如 &lt;code&gt;system.==&lt;/code&gt; 所提供）：</target>
        </trans-unit>
        <trans-unit id="c4a6d2ce7ae67ff08002aecf71f9b696f9005b38" translate="yes" xml:space="preserve">
          <source>A macro that takes as its only input parameter an expression of the special type &lt;code&gt;system.ForLoopStmt&lt;/code&gt; can rewrite the entirety of a &lt;code&gt;for&lt;/code&gt; loop:</source>
          <target state="translated">一个将特殊类型 &lt;code&gt;system.ForLoopStmt&lt;/code&gt; 的表达式作为唯一输入参数的宏。ForLoopStmt可以重写整个 &lt;code&gt;for&lt;/code&gt; 循环：</target>
        </trans-unit>
        <trans-unit id="d8df2d80cd89e184b1f75f28697093931c58d398" translate="yes" xml:space="preserve">
          <source>A module alias can be introduced via the &lt;code&gt;as&lt;/code&gt; keyword:</source>
          <target state="translated">可以通过 &lt;code&gt;as&lt;/code&gt; 关键字引入模块别名：</target>
        </trans-unit>
        <trans-unit id="d4afefca445f32ee9a9bac5a6c407d25bf9bc289" translate="yes" xml:space="preserve">
          <source>A module's top-level statements are executed at the start of the program. This can be used to initialize complex data structures for example.</source>
          <target state="translated">一个模块的顶层语句是在程序开始时执行的。例如,这可以用来初始化复杂的数据结构。</target>
        </trans-unit>
        <trans-unit id="2b9f547cf5da6cf041f0968e82f074d18fced352" translate="yes" xml:space="preserve">
          <source>A more verbose format string.</source>
          <target state="translated">一个比较啰嗦的格式字符串。</target>
        </trans-unit>
        <trans-unit id="d1e4a688e683942c8ad5fb732b7301d65e5d80ef" translate="yes" xml:space="preserve">
          <source>A mutable view can borrow from a mutable location, an immutable view can borrow from both a mutable or an immutable location.</source>
          <target state="translated">可变的视图可以借用可变的位置,不可变的视图可以借用可变或不可变的位置。</target>
        </trans-unit>
        <trans-unit id="a99c0a025e79be3ef687fadc0cc6086e9682f6fb" translate="yes" xml:space="preserve">
          <source>A new &lt;code&gt;main&lt;/code&gt; async procedure must be declared to allow the use of the &lt;code&gt;await&lt;/code&gt; keyword. The connection will complete asynchronously and the client will be connected after the &lt;code&gt;await ftp.connect()&lt;/code&gt; call.</source>
          <target state="translated">必须声明一个新的 &lt;code&gt;main&lt;/code&gt; 异步过程以允许使用 &lt;code&gt;await&lt;/code&gt; 关键字。连接将异步完成，并且将在 &lt;code&gt;await ftp.connect()&lt;/code&gt; 调用之后连接客户端。</target>
        </trans-unit>
        <trans-unit id="0e04b575e1abdecefebfd435f79a2eb878c9a4af" translate="yes" xml:space="preserve">
          <source>A new entry will be added to the index using the format &lt;code&gt;term&amp;lt;tab&amp;gt;file#id&lt;/code&gt;. The file part will come from the &lt;code&gt;htmlFile&lt;/code&gt; parameter.</source>
          <target state="translated">将使用 &lt;code&gt;term&amp;lt;tab&amp;gt;file#id&lt;/code&gt; 格式将新条目添加到索引。文件部分将来自 &lt;code&gt;htmlFile&lt;/code&gt; 参数。</target>
        </trans-unit>
        <trans-unit id="b4f09c089b0b64dd84f87655d31d40b67c7f610c" translate="yes" xml:space="preserve">
          <source>A new entry will be added to the index using the format &lt;code&gt;term&amp;lt;tab&amp;gt;file#id&lt;/code&gt;. The file part will come from the &lt;em&gt;htmlFile&lt;/em&gt; parameter.</source>
          <target state="translated">将使用 &lt;code&gt;term&amp;lt;tab&amp;gt;file#id&lt;/code&gt; 格式将新条目添加到索引。文件部分将来自&lt;em&gt;htmlFile&lt;/em&gt;参数。</target>
        </trans-unit>
        <trans-unit id="503fc2fb8da50eec2dc57fabea1722757a7c3f4b" translate="yes" xml:space="preserve">
          <source>A node a doubly linked list consists of.</source>
          <target state="translated">一个节点一个双链接列表包括:</target>
        </trans-unit>
        <trans-unit id="acf45682c2b0a00aed4a954df976fbf3f14b1755" translate="yes" xml:space="preserve">
          <source>A node a singly linked list consists of.</source>
          <target state="translated">一个节点一个单一链接的列表包括:</target>
        </trans-unit>
        <trans-unit id="fc67102da94ccd07b62bc7ef2e58c87c378eee76" translate="yes" xml:space="preserve">
          <source>A non-error message that may indicate a potential problem rising or impacted performance.</source>
          <target state="translated">可能表明潜在问题上升或影响性能的非错误信息。</target>
        </trans-unit>
        <trans-unit id="25460adb88b704ee96f5be8babcbcef40eb101b1" translate="yes" xml:space="preserve">
          <source>A parallel section can be used to execute a block in parallel.</source>
          <target state="translated">并行部分可以用来并行执行一个块。</target>
        </trans-unit>
        <trans-unit id="911a5ad83db128f4812253b45faa46d98027ca72" translate="yes" xml:space="preserve">
          <source>A parameter &lt;code&gt;p&lt;/code&gt; in a template is even substituted in the expression &lt;code&gt;x.p&lt;/code&gt;. Thus template arguments can be used as field names and a global symbol can be shadowed by the same argument name even when fully qualified:</source>
          <target state="translated">模板中的参数 &lt;code&gt;p&lt;/code&gt; 甚至被替换为表达式 &lt;code&gt;x.p&lt;/code&gt; 。因此，模板参数可以用作字段名称，并且即使在完全限定的情况下，全局符号也可以由相同的参数名称覆盖：</target>
        </trans-unit>
        <trans-unit id="b19cf459adbb632e3345bc4ce82a5563aa028fe2" translate="yes" xml:space="preserve">
          <source>A parameter may be declared with a default value which is used if the caller does not provide a value for the argument.</source>
          <target state="translated">一个参数可以声明一个默认值,如果调用者没有为参数提供一个值,那么这个值就会被使用。</target>
        </trans-unit>
        <trans-unit id="ed0815dccd26d3ba56f0da6c46ce7039b02d5cc0" translate="yes" xml:space="preserve">
          <source>A parameter of type &lt;code&gt;typedesc&lt;/code&gt; is itself usable as a type. If it is used as a type, it's the underlying type. (In other words, one level of &quot;typedesc&quot;-ness is stripped off:</source>
          <target state="translated">&lt;code&gt;typedesc&lt;/code&gt; 类型的参数本身可用作类型。如果将其用作类型，则为基础类型。（换句话说，剥夺了一层&amp;ldquo; typedesc&amp;rdquo; -ness：</target>
        </trans-unit>
        <trans-unit id="cd0e5a46bea204df5866abc8071f4ce20c751ed1" translate="yes" xml:space="preserve">
          <source>A parameter of type &lt;code&gt;untyped&lt;/code&gt; always matches any argument (as long as there is any argument passed to it).</source>
          <target state="translated">类型为 &lt;code&gt;untyped&lt;/code&gt; 的参数始终匹配任何参数（只要传递了任何参数）。</target>
        </trans-unit>
        <trans-unit id="dbc7adf040bff90855d92e494801c3ab8308d57e" translate="yes" xml:space="preserve">
          <source>A pattern expression can be bound to a pattern parameter via the &lt;code&gt;expr{param}&lt;/code&gt; notation:</source>
          <target state="translated">可以通过 &lt;code&gt;expr{param}&lt;/code&gt; 表示法将模式表达式绑定到模式参数：</target>
        </trans-unit>
        <trans-unit id="8d9da87b86afb0dda3edfe16aedb515e092f61c8" translate="yes" xml:space="preserve">
          <source>A pattern like &lt;code&gt;v[] = value&lt;/code&gt; or &lt;code&gt;v.field = value&lt;/code&gt; marks &lt;code&gt;G(v)&lt;/code&gt; as mutated. After the second pass a set of disjoint graphs was computed.</source>
          <target state="translated">类似于 &lt;code&gt;v[] = value&lt;/code&gt; 或 &lt;code&gt;v.field = value&lt;/code&gt; &lt;code&gt;G(v)&lt;/code&gt; 标记为已突变。在第二遍之后，计算了一组不相交的图。</target>
        </trans-unit>
        <trans-unit id="b7da0c1938417b6de5ea835934b0645328e2b773" translate="yes" xml:space="preserve">
          <source>A possible common use case for &lt;code&gt;rsplit&lt;/code&gt; is path manipulation, particularly on systems that don't use a common delimiter.</source>
          <target state="translated">&lt;code&gt;rsplit&lt;/code&gt; 可能的常见用例是路径操纵，尤其是在不使用公共定界符的系统上。</target>
        </trans-unit>
        <trans-unit id="84dbef3c0526b967ebfd2aa664f1b6a0e87d7f54" translate="yes" xml:space="preserve">
          <source>A possible common use case for &lt;em&gt;rsplit&lt;/em&gt; is path manipulation, particularly on systems that don't use a common delimiter.</source>
          <target state="translated">&lt;em&gt;rsplit&lt;/em&gt;可能的常见用例是路径操纵，尤其是在不使用公共定界符的系统上。</target>
        </trans-unit>
        <trans-unit id="468ffea579d79393dcb2eb8fd23d5f70574b0406" translate="yes" xml:space="preserve">
          <source>A proc can be marked with the &lt;code&gt;asmNoStackFrame&lt;/code&gt; pragma to tell the compiler it should not generate a stack frame for the proc. There are also no exit statements like &lt;code&gt;return result;&lt;/code&gt; generated and the generated C function is declared as &lt;code&gt;__declspec(naked)&lt;/code&gt; or &lt;code&gt;__attribute__((naked))&lt;/code&gt; (depending on the used C compiler).</source>
          <target state="translated">可以使用 &lt;code&gt;asmNoStackFrame&lt;/code&gt; 编译指示标记proc，以告知编译器不应为proc生成堆栈帧。也没有退出语句，例如 &lt;code&gt;return result;&lt;/code&gt; 生成并且生成的C函数声明为 &lt;code&gt;__declspec(naked)&lt;/code&gt; 或 &lt;code&gt;__attribute__((naked))&lt;/code&gt; （取决于所使用的C编译器）。</target>
        </trans-unit>
        <trans-unit id="552722100e5b68806260a435d2f96223b24f84ed" translate="yes" xml:space="preserve">
          <source>A proc defined as &lt;code&gt;f=&lt;/code&gt; (with the trailing &lt;code&gt;=&lt;/code&gt;) is called a &lt;span id=&quot;setter_1&quot;&gt;setter&lt;/span&gt;. A setter can be called explicitly via the common backticks notation:</source>
          <target state="translated">定义为 &lt;code&gt;f=&lt;/code&gt; （带有尾随 &lt;code&gt;=&lt;/code&gt; ）的proc称为&lt;span id=&quot;setter_1&quot;&gt;setter&lt;/span&gt;。可以通过常见的反引号表示法显式调用setter：</target>
        </trans-unit>
        <trans-unit id="451fbc26f5ae1ee9316fb78b0e6ca76aa2f9e794" translate="yes" xml:space="preserve">
          <source>A proc that is executed as a new thread of execution should be marked by the &lt;code&gt;thread&lt;/code&gt; pragma for reasons of readability. The compiler checks for violations of the &lt;span id=&quot;no-heap-sharing-restriction_1&quot;&gt;no heap sharing restriction&lt;/span&gt;: This restriction implies that it is invalid to construct a data structure that consists of memory allocated from different (thread local) heaps.</source>
          <target state="translated">出于可读性考虑，应将执行为新执行线程的proc标记为 &lt;code&gt;thread&lt;/code&gt; 编译指示。编译器检查是否违反了&lt;span id=&quot;no-heap-sharing-restriction_1&quot;&gt;无堆共享限制&lt;/span&gt;：该限制意味着构造由不同（线程本地）堆分配的内存组成的数据结构是无效的。</target>
        </trans-unit>
        <trans-unit id="31ee225123a881826db3daa3362c06b25bf61005" translate="yes" xml:space="preserve">
          <source>A proc that is executed as a new thread of execution should be marked by the &lt;code&gt;thread&lt;/code&gt; pragma for reasons of readability. The compiler checks for violations of the &lt;span id=&quot;no-heap-sharing-restriction_1&quot;&gt;no heap sharing restriction&lt;/span&gt;: This restriction implies that it is invalid to construct a data structure that consists of memory allocated from different (thread-local) heaps.</source>
          <target state="translated">出于可读性原因，应将执行为新执行线程的proc标记为 &lt;code&gt;thread&lt;/code&gt; 杂注。编译器检查是否违反了&lt;span id=&quot;no-heap-sharing-restriction_1&quot;&gt;无堆共享限制&lt;/span&gt;：该限制意味着构造由不同（线程本地）堆分配的内存组成的数据结构是无效的。</target>
        </trans-unit>
        <trans-unit id="c8f7a283eb6acfde98dfa18ad4771346a71dcb69" translate="yes" xml:space="preserve">
          <source>A proc, converter or iterator may return a &lt;code&gt;var&lt;/code&gt; type which means that the returned value is an l-value and can be modified by the caller:</source>
          <target state="translated">proc，converter或iterator可能返回 &lt;code&gt;var&lt;/code&gt; 类型，这意味着返回的值是l值，并且可以由调用方修改：</target>
        </trans-unit>
        <trans-unit id="367fd0ee661d0f037657253ea1206098af391bb7" translate="yes" xml:space="preserve">
          <source>A proc, converter, or iterator may return a &lt;code&gt;var&lt;/code&gt; type which means that the returned value is an l-value and can be modified by the caller:</source>
          <target state="translated">proc，转换器或迭代器可能返回 &lt;code&gt;var&lt;/code&gt; 类型，这意味着返回的值是l值，并且可以由调用方修改：</target>
        </trans-unit>
        <trans-unit id="4ba9d6d1f4765955e60cabd2afda1cfb0cacfe70" translate="yes" xml:space="preserve">
          <source>A procedural type is a (somewhat abstract) pointer to a procedure. &lt;code&gt;nil&lt;/code&gt; is an allowed value for a variable of a procedural type. Nim uses procedural types to achieve &lt;span id=&quot;functional_1&quot;&gt;functional&lt;/span&gt; programming techniques.</source>
          <target state="translated">过程类型是指向过程的（有点抽象）指针。 &lt;code&gt;nil&lt;/code&gt; 是过程类型变量的允许值。Nim使用过程类型来实现&lt;span id=&quot;functional_1&quot;&gt;功能&lt;/span&gt;编程技术。</target>
        </trans-unit>
        <trans-unit id="dbca622df4cb9e116b8115ae0a141864eed44cd7" translate="yes" xml:space="preserve">
          <source>A procedural type is internally a pointer to a procedure. &lt;code&gt;nil&lt;/code&gt; is an allowed value for variables of a procedural type. Nim uses procedural types to achieve &lt;span id=&quot;functional_1&quot;&gt;functional&lt;/span&gt; programming techniques.</source>
          <target state="translated">过程类型在内部是指向过程的指针。 &lt;code&gt;nil&lt;/code&gt; 是过程类型变量的允许值。Nim使用过程类型来实现&lt;span id=&quot;functional_1&quot;&gt;功能&lt;/span&gt;编程技术。</target>
        </trans-unit>
        <trans-unit id="bf770f6e5979c1f778e9340dd0cdb848252fa2f0" translate="yes" xml:space="preserve">
          <source>A procedure may call itself recursively.</source>
          <target state="translated">一个过程可以递归地调用自己。</target>
        </trans-unit>
        <trans-unit id="198d46da979417aa29b92d0cafdd5b26b6aa26bb" translate="yes" xml:space="preserve">
          <source>A procedure that returns a value has an implicit &lt;code&gt;result&lt;/code&gt; variable declared that represents the return value. A &lt;code&gt;return&lt;/code&gt; statement with no expression is a shorthand for &lt;code&gt;return result&lt;/code&gt;. The &lt;code&gt;result&lt;/code&gt; value is always returned automatically at the end of a procedure if there is no &lt;code&gt;return&lt;/code&gt; statement at the exit.</source>
          <target state="translated">返回值的过程具有声明的隐式 &lt;code&gt;result&lt;/code&gt; 变量，该变量表示返回值。一 &lt;code&gt;return&lt;/code&gt; 不带表达式语句是一种简写 &lt;code&gt;return result&lt;/code&gt; 。该 &lt;code&gt;result&lt;/code&gt; 值总是自动在程序结束时，如果没有返回 &lt;code&gt;return&lt;/code&gt; 出口处的语句。</target>
        </trans-unit>
        <trans-unit id="4479e2a3631b65d0dd4c690b9db368a8f3b1652a" translate="yes" xml:space="preserve">
          <source>A project can also have a project specific configuration file named &lt;code&gt;$project.nim.cfg&lt;/code&gt; that resides in the same directory as &lt;code&gt;$project.nim&lt;/code&gt;. This file can be skipped with the &lt;code&gt;--skipProjCfg&lt;/code&gt; command line option.</source>
          <target state="translated">一个项目也可以有一个名为项目的具体配置文件 &lt;code&gt;$project.nim.cfg&lt;/code&gt; 驻留在同一目录 &lt;code&gt;$project.nim&lt;/code&gt; 。可以使用 &lt;code&gt;--skipProjCfg&lt;/code&gt; 命令行选项跳过此文件。</target>
        </trans-unit>
        <trans-unit id="c839c97c3ceb25609fba06432f83144cef5a572e" translate="yes" xml:space="preserve">
          <source>A project can also have a project specific configuration file named &lt;code&gt;$project.nims&lt;/code&gt; that resides in the same directory as &lt;code&gt;$project.nim&lt;/code&gt;. This file can be skipped with the same &lt;code&gt;--skipProjCfg&lt;/code&gt; command line option.</source>
          <target state="translated">一个项目也可以有一个名为项目的具体配置文件 &lt;code&gt;$project.nims&lt;/code&gt; 驻留在同一目录 &lt;code&gt;$project.nim&lt;/code&gt; 。可以使用相同的 &lt;code&gt;--skipProjCfg&lt;/code&gt; 命令行选项跳过此文件。</target>
        </trans-unit>
        <trans-unit id="f75c52d2971823fc8165afd59430cb71ab2e4981" translate="yes" xml:space="preserve">
          <source>A project can also have a project-specific configuration file named &lt;code&gt;$project.nim.cfg&lt;/code&gt; that resides in the same directory as &lt;code&gt;$project.nim&lt;/code&gt;. This file can be skipped with the &lt;code&gt;--skipProjCfg&lt;/code&gt; command-line option.</source>
          <target state="translated">一个项目也可以有一个名为项目特定的配置文件 &lt;code&gt;$project.nim.cfg&lt;/code&gt; 驻留在同一目录 &lt;code&gt;$project.nim&lt;/code&gt; 。可以使用 &lt;code&gt;--skipProjCfg&lt;/code&gt; 命令行选项跳过此文件。</target>
        </trans-unit>
        <trans-unit id="e60afd1721ef96b7c6739e2759b02cb38c2c2d8c" translate="yes" xml:space="preserve">
          <source>A proxy can be specified as a param to any of the procedures defined in this module. To do this, use the &lt;code&gt;newProxy&lt;/code&gt; constructor. Unfortunately, only basic authentication is supported at the moment.</source>
          <target state="translated">可以将代理指定为该模块中定义的任何过程的参数。为此，请使用 &lt;code&gt;newProxy&lt;/code&gt; 构造函数。不幸的是，目前仅支持基本身份验证。</target>
        </trans-unit>
        <trans-unit id="df4503ea30137e4c7e9a09a528fd25af20fa134a" translate="yes" xml:space="preserve">
          <source>A range with all bit positions for type &lt;code&gt;T&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; 类型所有位位置的范围</target>
        </trans-unit>
        <trans-unit id="eac1d47b4a0730fb9551845dd67bf5ea00259685" translate="yes" xml:space="preserve">
          <source>A regular expression is a pattern that is matched against a subject string from left to right. Most characters stand for themselves in a pattern, and match the corresponding characters in the subject. As a trivial example, the pattern:</source>
          <target state="translated">正则表达式是一种从左到右与主题字符串匹配的模式。大多数字符在模式中代表自己,并与主题中的相应字符相匹配。举个简单的例子,模式。</target>
        </trans-unit>
        <trans-unit id="5df947512d73d9e3cb7375e44d4a39fd584e964d" translate="yes" xml:space="preserve">
          <source>A routine &lt;code&gt;p&lt;/code&gt; matches better than a routine &lt;code&gt;q&lt;/code&gt; if the following algorithm returns true:</source>
          <target state="translated">如果以下算法返回true，则例程 &lt;code&gt;p&lt;/code&gt; 与例程 &lt;code&gt;q&lt;/code&gt; 的匹配更好：</target>
        </trans-unit>
        <trans-unit id="97aab15d52550bb71a657dbacc087e3c7b88fc5c" translate="yes" xml:space="preserve">
          <source>A row in a CSV file.</source>
          <target state="translated">CSV文件中的一行。</target>
        </trans-unit>
        <trans-unit id="ecbfe11a28e5b832e2b506efe04714f8406548dc" translate="yes" xml:space="preserve">
          <source>A row of a dataset. &lt;code&gt;NULL&lt;/code&gt; database values will be converted to an empty string.</source>
          <target state="translated">数据集的一行。 &lt;code&gt;NULL&lt;/code&gt; 数据库值将转换为空字符串。</target>
        </trans-unit>
        <trans-unit id="fdff97566890f772e04c8438a24bb2cbb00af4bb" translate="yes" xml:space="preserve">
          <source>A second use of backslash provides a way of encoding non-printing characters in patterns in a visible manner. There is no restriction on the appearance of non-printing characters, apart from the binary zero that terminates a pattern, but when a pattern is being prepared by text editing, it is usually easier to use one of the following escape sequences than the binary character it represents::</source>
          <target state="translated">反斜杠的第二种用法提供了一种以可见的方式对模式中的非打印字符进行编码的方法。除了终止图案的二进制零之外,对非打印字符的出现没有任何限制,但当通过文本编辑准备一个图案时,通常使用以下转义序列之一比使用它所代表的二进制字符更容易:。</target>
        </trans-unit>
        <trans-unit id="3eac564020abe821a021c684a0c7e182c5615b2f" translate="yes" xml:space="preserve">
          <source>A section you should use to mark &lt;span id=&quot;runnable-example_1&quot;&gt;runnable example&lt;/span&gt; code with.</source>
          <target state="translated">您应该用来标记&lt;span id=&quot;runnable-example_1&quot;&gt;可运行示例&lt;/span&gt;代码的部分。</target>
        </trans-unit>
        <trans-unit id="d3b57f32de0396cba5ad9e9d00b3af349a475164" translate="yes" xml:space="preserve">
          <source>A sequence may be passed to a parameter that is of type &lt;em&gt;open array&lt;/em&gt;.</source>
          <target state="translated">可以将序列传递给&lt;em&gt;open array&lt;/em&gt;类型的参数。</target>
        </trans-unit>
        <trans-unit id="42f4d3d39137f32b8ca5b909c4ff4309a61d6eac" translate="yes" xml:space="preserve">
          <source>A sequence may be passed to an openarray parameter.</source>
          <target state="translated">序列可以传递给openarray参数。</target>
        </trans-unit>
        <trans-unit id="a1283ce9a305bc0127c452736c5aee8b37c6837f" translate="yes" xml:space="preserve">
          <source>A set of directories and files from the &lt;a href=&quot;ssl_certs&quot;&gt;ssl_certs&lt;/a&gt; module are scanned to locate CA certificates.</source>
          <target state="translated">扫描&lt;a href=&quot;ssl_certs&quot;&gt;ssl_certs&lt;/a&gt;模块中的一组目录和文件以找到CA证书。</target>
        </trans-unit>
        <trans-unit id="c7df348109f7ffdcfedc0d707be86ae26a07b32b" translate="yes" xml:space="preserve">
          <source>A set of helpers for the POSIX module. Raw interfaces are in the other posix*.nim files.</source>
          <target state="translated">一组POSIX模块的帮助程序。原始接口在其他posix*.nim文件中。</target>
        </trans-unit>
        <trans-unit id="e9939043c42e4aaaff588930f28e3fb87a4c1d18" translate="yes" xml:space="preserve">
          <source>A set with all the possible characters.</source>
          <target state="translated">一个包含所有可能的字符的集合。</target>
        </trans-unit>
        <trans-unit id="13fa5f0ea96be473acaa7e27bc838b91426d27e9" translate="yes" xml:space="preserve">
          <source>A shared GC'ed heap might be provided.</source>
          <target state="translated">可以提供一个共享的GC'ed堆。</target>
        </trans-unit>
        <trans-unit id="3cdd59cb6410981768f626d0dcabdc2c7390dce3" translate="yes" xml:space="preserve">
          <source>A shortcut for &lt;code&gt;.. ^&lt;/code&gt; to avoid the common gotcha that a space between '..' and '^' is required.</source>
          <target state="translated">&lt;code&gt;.. ^&lt;/code&gt; 的快捷方式，以避免常见的陷阱，即&amp;ldquo; ..&amp;rdquo;和&amp;ldquo; ^&amp;rdquo;之间必须有空格。</target>
        </trans-unit>
        <trans-unit id="eb2fa7060937552b7002d27f41621d3222ab840b" translate="yes" xml:space="preserve">
          <source>A shortcut for &lt;code&gt;a .. pred(b)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;a .. pred(b)&lt;/code&gt; 快捷方式。</target>
        </trans-unit>
        <trans-unit id="ec47097465bebcf2aecd8163b65ad782e31f3d56" translate="yes" xml:space="preserve">
          <source>A shortcut for &lt;code&gt;switch(astToStr(key), astToStr(val))&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;switch(astToStr(key), astToStr(val))&lt;/code&gt; 快捷方式。</target>
        </trans-unit>
        <trans-unit id="f58bd32b1554568ba7e0b99deb8afcbae405c442" translate="yes" xml:space="preserve">
          <source>A shortcut for &lt;code&gt;switch(astToStr(key)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;switch(astToStr(key)&lt;/code&gt; 的快捷方式。</target>
        </trans-unit>
        <trans-unit id="14501c8e78d3950cf5ec56e87d1f764a6e487a66" translate="yes" xml:space="preserve">
          <source>A shortcut version to assign in let blocks.</source>
          <target state="translated">让块中分配的快捷版。</target>
        </trans-unit>
        <trans-unit id="7dd308d11ae6fe6d7f3bfcc6857d7ef9411ab7fa" translate="yes" xml:space="preserve">
          <source>A shorthand for &lt;code&gt;echo(errormsg); quit(errorcode)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;echo(errormsg); quit(errorcode)&lt;/code&gt; 简写；退出（错误代码）。</target>
        </trans-unit>
        <trans-unit id="af38f1c5146159966de284e8a35e5d86d3ab12b9" translate="yes" xml:space="preserve">
          <source>A shorthand for:</source>
          <target state="translated">简称:</target>
        </trans-unit>
        <trans-unit id="dac4b4b7dce5d63bf65005785b5b8b3dd2313f8a" translate="yes" xml:space="preserve">
          <source>A similar thing happens with C code invoking Nim code which returns a &lt;code&gt;cstring&lt;/code&gt;. Consider the following proc:</source>
          <target state="translated">C代码调用Nim代码返回 &lt;code&gt;cstring&lt;/code&gt; 时,也会发生类似的情况。考虑以下过程：</target>
        </trans-unit>
        <trans-unit id="c9daeb78be195c0138e8f11066e2c9965268a883" translate="yes" xml:space="preserve">
          <source>A simple XML tree generator.</source>
          <target state="translated">一个简单的XML树生成器。</target>
        </trans-unit>
        <trans-unit id="a48f6996b6131883f1b9650bc68f70d8d02303fe" translate="yes" xml:space="preserve">
          <source>A simple XML tree. More efficient and simpler than the DOM.</source>
          <target state="translated">一个简单的XML树。比DOM更高效、更简单。</target>
        </trans-unit>
        <trans-unit id="d71dc8f8837a2ef4b3dfcb01d114a06fb9448305" translate="yes" xml:space="preserve">
          <source>A simple barrier to wait for all &lt;code&gt;spawn&lt;/code&gt;'ed tasks.</source>
          <target state="translated">等待所有 &lt;code&gt;spawn&lt;/code&gt; 任务的简单障碍。</target>
        </trans-unit>
        <trans-unit id="b881695a1cfe6f9170c0ac327d2994cb87b8beb2" translate="yes" xml:space="preserve">
          <source>A single &lt;code&gt;&quot;*&quot;&lt;/code&gt; can be used for globbing.</source>
          <target state="translated">单个 &lt;code&gt;&quot;*&quot;&lt;/code&gt; 可用于通配符。</target>
        </trans-unit>
        <trans-unit id="9113f6bde0396b300681395640f8679539962f2e" translate="yes" xml:space="preserve">
          <source>A singly linked list.</source>
          <target state="translated">单一链接的清单。</target>
        </trans-unit>
        <trans-unit id="6e84aababe949578ad498d01fd5372a6a6b7c3c7" translate="yes" xml:space="preserve">
          <source>A singly linked ring.</source>
          <target state="translated">一个单联环。</target>
        </trans-unit>
        <trans-unit id="0e14c42493cdbd0ec02152b489b1433c8bd84c95" translate="yes" xml:space="preserve">
          <source>A sink parameter &lt;em&gt;may&lt;/em&gt; be consumed once in the proc's body but doesn't have to be consumed at all. The reason for this is that signatures like &lt;code&gt;proc put(t: var Table; k: sink Key, v: sink Value)&lt;/code&gt; should be possible without any further overloads and &lt;code&gt;put&lt;/code&gt; might not take ownership of &lt;code&gt;k&lt;/code&gt; if &lt;code&gt;k&lt;/code&gt; already exists in the table. Sink parameters enable an affine type system, not a linear type system.</source>
          <target state="translated">一个接收器参数&lt;em&gt;可以&lt;/em&gt;在proc的主体中使用一次，但根本不需要使用。这样做的原因是这样的签名 &lt;code&gt;proc put(t: var Table; k: sink Key, v: sink Value)&lt;/code&gt; 应该没有任何进一步的过载是可能的， &lt;code&gt;put&lt;/code&gt; 可能无法取得其所有权 &lt;code&gt;k&lt;/code&gt; 如果 &lt;code&gt;k&lt;/code&gt; 表中已经存在。接收器参数启用仿射类型系统，而不是线性类型系统。</target>
        </trans-unit>
        <trans-unit id="1a46cd68f2f2846ae726246b12281b2435629226" translate="yes" xml:space="preserve">
          <source>A small example:</source>
          <target state="translated">一个小例子。</target>
        </trans-unit>
        <trans-unit id="4b36d665dd33efefb1f4f6b8f221af140b9aa4bd" translate="yes" xml:space="preserve">
          <source>A special type that marks a macro as a &lt;span id=&quot;forminusloop-macro_1&quot;&gt;for-loop macro&lt;/span&gt;. See &lt;a href=&quot;manual#macros-for-loop-macro&quot;&gt;&quot;For Loop Macro&quot;&lt;/a&gt;.</source>
          <target state="translated">一种特殊类型，将宏标记为&lt;span id=&quot;forminusloop-macro_1&quot;&gt;for循环macro&lt;/span&gt;。请参见&lt;a href=&quot;manual#macros-for-loop-macro&quot;&gt;&amp;ldquo;对于循环宏&amp;rdquo;&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="17eb06b5b98ef723497f736d4beb2106d493fd2b" translate="yes" xml:space="preserve">
          <source>A static statement/expression can be used to enforce compile time evaluation explicitly. Enforced compile time evaluation can even evaluate code that has side effects:</source>
          <target state="translated">静态声明/表达式可以用来显式地执行编译时评估。强制编译时评估甚至可以评估有副作用的代码。</target>
        </trans-unit>
        <trans-unit id="2ea07adf0c3c6173a16c7ff5ec0740d4e2076eed" translate="yes" xml:space="preserve">
          <source>A static statement/expression explicitly requires compile-time execution. Even some code that has side effects is permitted in a static block:</source>
          <target state="translated">静态语句/表达式明确要求编译时执行。即使是一些有副作用的代码,在静态块中也是允许的。</target>
        </trans-unit>
        <trans-unit id="2ba79287d30f6d88058ea5ca43075dd128b9c975" translate="yes" xml:space="preserve">
          <source>A stream that encapsulates a &lt;code&gt;File&lt;/code&gt;.</source>
          <target state="translated">封装 &lt;code&gt;File&lt;/code&gt; 的流。</target>
        </trans-unit>
        <trans-unit id="ea0e50485f55cced7b7f2403d6ad63028a5ecfa3" translate="yes" xml:space="preserve">
          <source>A stream that encapsulates a string.</source>
          <target state="translated">一个封装了字符串的流。</target>
        </trans-unit>
        <trans-unit id="ae845c480c00f456835854fa492599a456d01a85" translate="yes" xml:space="preserve">
          <source>A strict or proper subset &lt;code&gt;s1&lt;/code&gt; has all of its elements in &lt;code&gt;s2&lt;/code&gt;, but &lt;code&gt;s2&lt;/code&gt; has more elements than &lt;code&gt;s1&lt;/code&gt;.</source>
          <target state="translated">严格或适当的子集 &lt;code&gt;s1&lt;/code&gt; 在 &lt;code&gt;s2&lt;/code&gt; 中具有所有元素，但是 &lt;code&gt;s2&lt;/code&gt; 的元素比 &lt;code&gt;s1&lt;/code&gt; 更多。</target>
        </trans-unit>
        <trans-unit id="c07ac55f0c8dacc1a4b7bdbadb598be3ff7f8076" translate="yes" xml:space="preserve">
          <source>A strict or proper subset &lt;code&gt;s&lt;/code&gt; has all of its members in &lt;code&gt;t&lt;/code&gt; but &lt;code&gt;t&lt;/code&gt; has more elements than &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">严格或适当的子集 &lt;code&gt;s&lt;/code&gt; 的所有成员都在 &lt;code&gt;t&lt;/code&gt; 中,但 &lt;code&gt;t&lt;/code&gt; 的元素比 &lt;code&gt;s&lt;/code&gt; 多。</target>
        </trans-unit>
        <trans-unit id="199e49a636b52dd8fc54e3a6e1efcead4078f2f5" translate="yes" xml:space="preserve">
          <source>A strict or proper subset &lt;code&gt;x&lt;/code&gt; has all of its members in &lt;code&gt;y&lt;/code&gt; but &lt;code&gt;y&lt;/code&gt; has more elements than &lt;code&gt;y&lt;/code&gt;.</source>
          <target state="translated">严格或适当的子集 &lt;code&gt;x&lt;/code&gt; 的所有成员都在 &lt;code&gt;y&lt;/code&gt; 中,但是 &lt;code&gt;y&lt;/code&gt; 的元素多于 &lt;code&gt;y&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="793061e8f68073a7cc2b6e8e7cb7430e9cb435af" translate="yes" xml:space="preserve">
          <source>A strict or proper subset &lt;em&gt;s&lt;/em&gt; has all of its members in &lt;em&gt;t&lt;/em&gt; but &lt;em&gt;t&lt;/em&gt; has more elements than &lt;em&gt;s&lt;/em&gt;. Example:</source>
          <target state="translated">严格或适当的子集&lt;em&gt;s的&lt;/em&gt;所有成员都在&lt;em&gt;t中，&lt;/em&gt;但&lt;em&gt;t的&lt;/em&gt;元素比&lt;em&gt;s多&lt;/em&gt;。例：</target>
        </trans-unit>
        <trans-unit id="84bd2c736b9807ca808a9e28613b62ce10e34a6b" translate="yes" xml:space="preserve">
          <source>A string stream object.</source>
          <target state="translated">一个字符串流对象。</target>
        </trans-unit>
        <trans-unit id="692f4550479e6001b1a436a04309e4819905d924" translate="yes" xml:space="preserve">
          <source>A string surrounded by double quotation marks (&quot;string&quot;) is interpreted as a single argument, regardless of white space contained within. A quoted string can be embedded in an argument.</source>
          <target state="translated">由双引号(&quot;string&quot;)包围的字符串被解释为一个单一的参数,而不考虑其中包含的空白。引用的字符串可以嵌入一个参数中。</target>
        </trans-unit>
        <trans-unit id="70d4dbc60f1b3759a9a0ebe1370ea93bf97755e2" translate="yes" xml:space="preserve">
          <source>A string that describes the application type. Possible values: &lt;code&gt;&quot;console&quot;&lt;/code&gt;, &lt;code&gt;&quot;gui&quot;&lt;/code&gt;, &lt;code&gt;&quot;lib&quot;&lt;/code&gt;.</source>
          <target state="translated">描述应用程序类型的字符串。可能的值： &lt;code&gt;&quot;console&quot;&lt;/code&gt; ， &lt;code&gt;&quot;gui&quot;&lt;/code&gt; ， &lt;code&gt;&quot;lib&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="149db672045eac6dc65b46c1ba2493351adf8191" translate="yes" xml:space="preserve">
          <source>A string that describes the host CPU.</source>
          <target state="translated">描述主机CPU的字符串。</target>
        </trans-unit>
        <trans-unit id="585e2446a22a413fa5de5778d298c8f86485b6f4" translate="yes" xml:space="preserve">
          <source>A string that describes the host operating system.</source>
          <target state="translated">描述主机操作系统的字符串。</target>
        </trans-unit>
        <trans-unit id="ebec3b61b900cc32aa099451f2c6e12dd07c334c" translate="yes" xml:space="preserve">
          <source>A string variable is initialized with the empty string &lt;code&gt;&quot;&quot;&lt;/code&gt;.</source>
          <target state="translated">字符串变量使用空字符串 &lt;code&gt;&quot;&quot;&lt;/code&gt; 初始化。</target>
        </trans-unit>
        <trans-unit id="c3a00e56e1710bd679d0173c57dab6fbeebbe31b" translate="yes" xml:space="preserve">
          <source>A subrange type has the same size as its base type (&lt;code&gt;int&lt;/code&gt; in the Subrange example).</source>
          <target state="translated">子范围类型与其基本类型的大小相同（子范围示例中的 &lt;code&gt;int&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="7a08933979326f8850950a1173db1b99805f1785" translate="yes" xml:space="preserve">
          <source>A subrange type is a range of values from an integer or enumeration type (the base type). Example:</source>
          <target state="translated">子范围类型是指从整数或枚举类型(基础类型)中提取的值的范围。例子:&quot;子范围 &quot;是指从整数或枚举类型(基类型)中提取的数值范围。</target>
        </trans-unit>
        <trans-unit id="5216761dae1ae277a963814830873f1da9e08d5b" translate="yes" xml:space="preserve">
          <source>A subrange type is a range of values from an ordinal or floating point type (the base type). To define a subrange type, one must specify it's limiting values: the lowest and highest value of the type:</source>
          <target state="translated">子范围类型是指一个序数或浮点类型(基本类型)的值范围。要定义一个子范围类型,必须指定它的极限值:该类型的最低值和最高值。</target>
        </trans-unit>
        <trans-unit id="3f24fd7c42fe941770b40eb0bc219b80b82d9b14" translate="yes" xml:space="preserve">
          <source>A subrange type is a range of values from an ordinal or floating-point type (the base type). To define a subrange type, one must specify its limiting values -- the lowest and highest value of the type. For example:</source>
          <target state="translated">子范围类型是指一个序数或浮点类型(基本类型)的数值范围。要定义一个子范围类型,必须指定其极限值--该类型的最低值和最高值。例如</target>
        </trans-unit>
        <trans-unit id="fa613e17f732dd0c25c531cfb02c7803d1c28c45" translate="yes" xml:space="preserve">
          <source>A subset &lt;code&gt;s1&lt;/code&gt; has all of its elements in &lt;code&gt;s2&lt;/code&gt;, and &lt;code&gt;s2&lt;/code&gt; doesn't necessarily have more elements than &lt;code&gt;s1&lt;/code&gt;. That is, &lt;code&gt;s1&lt;/code&gt; can be equal to &lt;code&gt;s2&lt;/code&gt;.</source>
          <target state="translated">子集 &lt;code&gt;s1&lt;/code&gt; 的所有元素都在 &lt;code&gt;s2&lt;/code&gt; 中，而 &lt;code&gt;s2&lt;/code&gt; 的元素不一定比 &lt;code&gt;s1&lt;/code&gt; 多。即， &lt;code&gt;s1&lt;/code&gt; 可以等于 &lt;code&gt;s2&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="aae915dc513f286fedae6cff5178a0c89a9f424a" translate="yes" xml:space="preserve">
          <source>A subset &lt;code&gt;s&lt;/code&gt; has all of its members in &lt;code&gt;t&lt;/code&gt; and &lt;code&gt;t&lt;/code&gt; doesn't necessarily have more members than &lt;code&gt;s&lt;/code&gt;. That is, &lt;code&gt;s&lt;/code&gt; can be equal to &lt;code&gt;t&lt;/code&gt;.</source>
          <target state="translated">子集 &lt;code&gt;s&lt;/code&gt; 的所有成员都在 &lt;code&gt;t&lt;/code&gt; 中,而 &lt;code&gt;t&lt;/code&gt; 的成员不必多于 &lt;code&gt;s&lt;/code&gt; 。也就是说， &lt;code&gt;s&lt;/code&gt; 可以等于 &lt;code&gt;t&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4105f2c4e0ac639778e46c5d4f3636e4328d553a" translate="yes" xml:space="preserve">
          <source>A subset &lt;code&gt;x&lt;/code&gt; has all of its members in &lt;code&gt;y&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; doesn't necessarily have more members than &lt;code&gt;x&lt;/code&gt;. That is, &lt;code&gt;x&lt;/code&gt; can be equal to &lt;code&gt;y&lt;/code&gt;.</source>
          <target state="translated">子集 &lt;code&gt;x&lt;/code&gt; 的所有成员都在 &lt;code&gt;y&lt;/code&gt; 中,而 &lt;code&gt;y&lt;/code&gt; 的成员不必多于 &lt;code&gt;x&lt;/code&gt; 。也就是说， &lt;code&gt;x&lt;/code&gt; 可以等于 &lt;code&gt;y&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="05319ab331bb8be9fb80a1ea2da5bff936f37a01" translate="yes" xml:space="preserve">
          <source>A subset &lt;em&gt;s&lt;/em&gt; has all of its members in &lt;em&gt;t&lt;/em&gt; and &lt;em&gt;t&lt;/em&gt; doesn't necessarily have more members than &lt;em&gt;s&lt;/em&gt;. That is, &lt;em&gt;s&lt;/em&gt; can be equal to &lt;em&gt;t&lt;/em&gt;. Example:</source>
          <target state="translated">子集&lt;em&gt;s的&lt;/em&gt;所有成员都在&lt;em&gt;t中，&lt;/em&gt;而&lt;em&gt;t的&lt;/em&gt;成员不必多于&lt;em&gt;s&lt;/em&gt;。也就是说，&lt;em&gt;s&lt;/em&gt;可以等于&lt;em&gt;t&lt;/em&gt;。例：</target>
        </trans-unit>
        <trans-unit id="23fcaa56fd8e693a2e943e96baf6a166ee24925f" translate="yes" xml:space="preserve">
          <source>A subtle issue with procedural types is that the calling convention of the procedure influences the type compatibility: procedural types are only compatible if they have the same calling convention. As a special extension, a procedure of the calling convention &lt;code&gt;nimcall&lt;/code&gt; can be passed to a parameter that expects a proc of the calling convention &lt;code&gt;closure&lt;/code&gt;.</source>
          <target state="translated">过程类型的一个细微问题是过程的调用约定会影响类型兼容性：过程类型只有在具有相同的调用约定时才兼容。作为特殊扩展，可以将调用约定 &lt;code&gt;nimcall&lt;/code&gt; 的过程传递给期望调用约定 &lt;code&gt;closure&lt;/code&gt; proc的参数。</target>
        </trans-unit>
        <trans-unit id="33ba9ca12af44d34318811768b34fc09edc238c4" translate="yes" xml:space="preserve">
          <source>A subtle issue with procedural types is that the calling convention of the procedure influences the type compatibility: procedural types are only compatible if they have the same calling convention. The different calling conventions are listed in the &lt;a href=&quot;manual#types-procedural-type&quot;&gt;manual&lt;/a&gt;.</source>
          <target state="translated">过程类型的一个细微问题是过程的调用约定会影响类型兼容性：过程类型只有在具有相同的调用约定时才兼容。&lt;a href=&quot;manual#types-procedural-type&quot;&gt;手册&lt;/a&gt;中列出了不同的调用约定。</target>
        </trans-unit>
        <trans-unit id="b1fea738d80cf9eb7066f6737496184c2e3dc962" translate="yes" xml:space="preserve">
          <source>A successful dereferencing operation &lt;code&gt;p[]&lt;/code&gt; implies that &lt;code&gt;p&lt;/code&gt; is not nil. This can be exploited by the implementation to optimize code like:</source>
          <target state="translated">成功的解引用操作 &lt;code&gt;p[]&lt;/code&gt; 表示 &lt;code&gt;p&lt;/code&gt; 不为零。实现可以利用它来优化代码，例如：</target>
        </trans-unit>
        <trans-unit id="a98d0d55b4f56cd1973186508a85d670c67f313d" translate="yes" xml:space="preserve">
          <source>A symbol can be forced to be open by a &lt;span id=&quot;mixin_1&quot;&gt;mixin&lt;/span&gt; declaration:</source>
          <target state="translated">可以通过&lt;span id=&quot;mixin_1&quot;&gt;mixin&lt;/span&gt;声明强制打开符号：</target>
        </trans-unit>
        <trans-unit id="0462b1952d8449154ce73caf7ef4db9422926829" translate="yes" xml:space="preserve">
          <source>A symbol of a module &lt;em&gt;can&lt;/em&gt; be &lt;em&gt;qualified&lt;/em&gt; with the &lt;code&gt;module.symbol&lt;/code&gt; syntax. And if a symbol is ambiguous, it &lt;em&gt;must&lt;/em&gt; be qualified. A symbol is ambiguous if it is defined in two (or more) different modules and both modules are imported by a third one:</source>
          <target state="translated">&lt;em&gt;可以&lt;/em&gt;使用 &lt;code&gt;module.symbol&lt;/code&gt; 语法来&lt;em&gt;限定&lt;/em&gt;模块的符号。如果符号不明确，则&lt;em&gt;必须&lt;/em&gt;将其限定。如果符号在两个（或多个）不同的模块中定义并且两个模块均由第三个模块导入，则该符号是不明确的：&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b3a7ad38688e4496bf760973d6609aeb8d3bfad8" translate="yes" xml:space="preserve">
          <source>A symbol which is a &lt;code&gt;let&lt;/code&gt; variable.</source>
          <target state="translated">一个符号，它是一个 &lt;code&gt;let&lt;/code&gt; 变量。</target>
        </trans-unit>
        <trans-unit id="25afae3a203b27eb5151fb8ba040656c33e3555a" translate="yes" xml:space="preserve">
          <source>A symbol which is a constant.</source>
          <target state="translated">一个符号,它是一个常数。</target>
        </trans-unit>
        <trans-unit id="18336a58e1597be288809ec54b26b76e902b5f18" translate="yes" xml:space="preserve">
          <source>A symbol which is a converter.</source>
          <target state="translated">一个符号,它是一个转换器。</target>
        </trans-unit>
        <trans-unit id="34e5a133463d35676b1ce7b0d26dcb4084186353" translate="yes" xml:space="preserve">
          <source>A symbol which is a field in a tuple or an object.</source>
          <target state="translated">一个符号,它是元组或对象中的一个字段。</target>
        </trans-unit>
        <trans-unit id="dbc7ff0193694a8a6df3edaa4feafaf08a548d9c" translate="yes" xml:space="preserve">
          <source>A symbol which is a field in an enumeration.</source>
          <target state="translated">符号是枚举中的一个字段。</target>
        </trans-unit>
        <trans-unit id="b0f4c02b65e3aca97fa198aef1b1d7f8f50540e1" translate="yes" xml:space="preserve">
          <source>A symbol which is a generic parameter.</source>
          <target state="translated">符号是一个通用参数。</target>
        </trans-unit>
        <trans-unit id="cee1e54f067d3a3df195ebd26b86fefccf9d512a" translate="yes" xml:space="preserve">
          <source>A symbol which is a macro.</source>
          <target state="translated">一个符号,它是一个宏。</target>
        </trans-unit>
        <trans-unit id="8ba65c84aa50b6b4fa8d3cfd3055d6bba8e59df2" translate="yes" xml:space="preserve">
          <source>A symbol which is a method.</source>
          <target state="translated">一个符号,它是一种方法。</target>
        </trans-unit>
        <trans-unit id="397a59c937f508b55f4f508768e9f30b05e604a7" translate="yes" xml:space="preserve">
          <source>A symbol which is a module.</source>
          <target state="translated">一个符号,它是一个模块。</target>
        </trans-unit>
        <trans-unit id="2ebe7a11b22366113570683c1b68d2ed707218ec" translate="yes" xml:space="preserve">
          <source>A symbol which is a parameter.</source>
          <target state="translated">作为参数的符号。</target>
        </trans-unit>
        <trans-unit id="28496412faf0d454dab9dc1a6af576954c0a1ed5" translate="yes" xml:space="preserve">
          <source>A symbol which is a proc.</source>
          <target state="translated">一个符号,它是一个程序。</target>
        </trans-unit>
        <trans-unit id="b83a50e7c38bef4fa30f012bba6b90bc90afc9ea" translate="yes" xml:space="preserve">
          <source>A symbol which is a template.</source>
          <target state="translated">一个符号,它是一个模板。</target>
        </trans-unit>
        <trans-unit id="3462dea1dd2d1f68df6439bcca6ca7bca98f2daf" translate="yes" xml:space="preserve">
          <source>A symbol which is a type.</source>
          <target state="translated">是一种类型的符号。</target>
        </trans-unit>
        <trans-unit id="2a1357b126b87914b1b6f8a549043e8db1b4ede2" translate="yes" xml:space="preserve">
          <source>A symbol which is a variable.</source>
          <target state="translated">符号是一个变量。</target>
        </trans-unit>
        <trans-unit id="2d0634ee6e934140b8250f79b8ba8901843ddbb9" translate="yes" xml:space="preserve">
          <source>A symbol which is an iterator.</source>
          <target state="translated">是一个迭代器的符号。</target>
        </trans-unit>
        <trans-unit id="4e393c2bf071d79fe321a01e0a6eea1010d9f40a" translate="yes" xml:space="preserve">
          <source>A system call for device-specific input/output operations and other operations which cannot be expressed by regular system calls</source>
          <target state="translated">系统调用,用于特定设备的输入/输出操作,以及其他不能用常规系统调用表达的操作。</target>
        </trans-unit>
        <trans-unit id="fc9ce8dd56e57484f7771a0858bc6ea64b79d22b" translate="yes" xml:space="preserve">
          <source>A table constructor is syntactic sugar for an array constructor:</source>
          <target state="translated">表构造函数是数组构造函数的语法糖。</target>
        </trans-unit>
        <trans-unit id="4a7a5f8021ef6500926b1cb58e60a0f63620d3dd" translate="yes" xml:space="preserve">
          <source>A table literal can be put into a &lt;code&gt;const&lt;/code&gt; section and the compiler can easily put it into the executable's data section just like it can for arrays and the generated data section requires a minimal amount of memory.</source>
          <target state="translated">可以将表文字放入 &lt;code&gt;const&lt;/code&gt; 节中，并且编译器可以轻松地将其放入可执行文件的数据节中，就像对数组一样，并且生成的数据节所需的内存最少。</target>
        </trans-unit>
        <trans-unit id="cfef19ba2df017b1840fca787af14959a3b9fbf8" translate="yes" xml:space="preserve">
          <source>A tag has to be a type name. A &lt;code&gt;tags&lt;/code&gt; list - like a &lt;code&gt;raises&lt;/code&gt; list - can also be attached to a proc type. This affects type compatibility.</source>
          <target state="translated">标签必须是类型名称。一个 &lt;code&gt;tags&lt;/code&gt; 列表-就像一个 &lt;code&gt;raises&lt;/code&gt; 名单-也可以连接到一个PROC类型。这会影响类型兼容性。</target>
        </trans-unit>
        <trans-unit id="c7c12a1bbcf06851adacdd13e78109f4548a353d" translate="yes" xml:space="preserve">
          <source>A template is a &lt;span id=&quot;hygienic_1&quot;&gt;hygienic&lt;/span&gt; macro and so opens a new scope. Most symbols are bound from the definition scope of the template:</source>
          <target state="translated">模板是一个&lt;span id=&quot;hygienic_1&quot;&gt;卫生&lt;/span&gt;宏，因此打开了一个新的作用域。大多数符号受模板定义范围的约束：</target>
        </trans-unit>
        <trans-unit id="3d0909aebdac7146ab483112e0cffc46ee0650d8" translate="yes" xml:space="preserve">
          <source>A template is a simple form of a macro: It is a simple substitution mechanism that operates on Nim's abstract syntax trees. It is processed in the semantic pass of the compiler.</source>
          <target state="translated">模板是宏的一种简单形式,它是一种简单的替换机制,在Nim的抽象语法树上运行。它是一种简单的替换机制,在Nim的抽象语法树上运行。它在编译器的语义通道中被处理。</target>
        </trans-unit>
        <trans-unit id="4957f2f98151d72020ad997ae5b0177dbfe8bd70" translate="yes" xml:space="preserve">
          <source>A template where every parameter is &lt;code&gt;untyped&lt;/code&gt; is called an &lt;span id=&quot;immediate_1&quot;&gt;immediate&lt;/span&gt; template. For historical reasons templates can be explicitly annotated with an &lt;code&gt;immediate&lt;/code&gt; pragma and then these templates do not take part in overloading resolution and the parameters' types are &lt;em&gt;ignored&lt;/em&gt; by the compiler. Explicit immediate templates are now deprecated.</source>
          <target state="translated">每个参数都没有 &lt;code&gt;untyped&lt;/code&gt; 的模板称为&lt;span id=&quot;immediate_1&quot;&gt;立即&lt;/span&gt;模板。由于历史原因，可以使用 &lt;code&gt;immediate&lt;/code&gt; 编译指示显式地注释模板，然后这些模板不参与重载分辨率，并且编译器将&lt;em&gt;忽略&lt;/em&gt;参数的类型。显式立即模板现已弃用。</target>
        </trans-unit>
        <trans-unit id="2c5c46bd6cd44a46ae88e10ca57070a21a6c5dbc" translate="yes" xml:space="preserve">
          <source>A test suite is a series of one or more related tests sharing a common fixture (&lt;code&gt;setup&lt;/code&gt;, &lt;code&gt;teardown&lt;/code&gt;). The fixture is executed for EACH test.</source>
          <target state="translated">一个测试套件是一系列的一个或多个相关测试，它们共享一个通用的夹具（ &lt;code&gt;setup&lt;/code&gt; ， &lt;code&gt;teardown&lt;/code&gt; ）。执行夹具以进行EACH测试。</target>
        </trans-unit>
        <trans-unit id="f697950925359df8943281d389dcc452af1b91bb" translate="yes" xml:space="preserve">
          <source>A thread is destructed when the &lt;code&gt;.thread&lt;/code&gt; proc returns normally or when it raises an exception. Note that unhandled exceptions in a thread nevertheless cause the whole process to die.</source>
          <target state="translated">当 &lt;code&gt;.thread&lt;/code&gt; proc正常返回或引发异常时，线程将被破坏。请注意，线程中未处理的异常仍然会导致整个过程终止。</target>
        </trans-unit>
        <trans-unit id="31bf8aebbb82c9b930fd2c075ab23a6c84bd7bab" translate="yes" xml:space="preserve">
          <source>A thread proc is passed to &lt;code&gt;createThread&lt;/code&gt; or &lt;code&gt;spawn&lt;/code&gt; and invoked indirectly; so the &lt;code&gt;thread&lt;/code&gt; pragma implies &lt;code&gt;procvar&lt;/code&gt;.</source>
          <target state="translated">线程proc被传递给 &lt;code&gt;createThread&lt;/code&gt; 或 &lt;code&gt;spawn&lt;/code&gt; 并间接调用；因此 &lt;code&gt;thread&lt;/code&gt; &lt;code&gt;procvar&lt;/code&gt; 注意味着procvar。</target>
        </trans-unit>
        <trans-unit id="c0f8163c51d43eedc6caebe9eaa4ac659b3f787e" translate="yes" xml:space="preserve">
          <source>A thread-local &lt;code&gt;var&lt;/code&gt; or &lt;code&gt;let&lt;/code&gt;.</source>
          <target state="translated">线程局部 &lt;code&gt;var&lt;/code&gt; 或 &lt;code&gt;let&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="41bb5d8b499e01e5a1190386e45f8f1ab3dfd432" translate="yes" xml:space="preserve">
          <source>A thunk would need to call 'returnsDefaultCC[i]' somehow and that would require an &lt;em&gt;additional&lt;/em&gt; closure generation... Ok, not really, but it requires to pass the function to call. So we'd end up with 2 indirect calls instead of one. Another much more severe problem which this solution is that it's not GC-safe to pass a proc pointer around via a generic &lt;code&gt;ref&lt;/code&gt; type.</source>
          <target state="translated">一个笨拙的人将需要以某种方式调用&amp;ldquo; returnsDefaultCC [i]&amp;rdquo;，这将需要&lt;em&gt;额外的&lt;/em&gt;闭包生成...好的，不是真的，但是它需要传递该函数以进行调用。因此，我们最终将进行两次间接调用，而不是一次。该解决方案的另一个更为严重的问题是，通过通用的 &lt;code&gt;ref&lt;/code&gt; 类型传递proc指针并不安全。</target>
        </trans-unit>
        <trans-unit id="a3b8fb864073dd8b8ee82885b71745cbd42bd751" translate="yes" xml:space="preserve">
          <source>A timeout can be specified in milliseconds, if data is not received within the specified time a TimeoutError exception will be raised.</source>
          <target state="translated">超时时间可以以毫秒为单位指定,如果在指定的时间内没有收到数据,就会引发超时错误异常。</target>
        </trans-unit>
        <trans-unit id="a71df16ade8aee765ef43a13e09747416cdfc482" translate="yes" xml:space="preserve">
          <source>A timeout can be specified in milliseconds, if data is not received within the specified time an ETimeout exception will be raised.</source>
          <target state="translated">可以以毫秒为单位指定超时时间,如果在指定时间内没有收到数据,将引发ETimeout异常。</target>
        </trans-unit>
        <trans-unit id="43dcf2374a63395e293bd9039f8d75e19cabb5f4" translate="yes" xml:space="preserve">
          <source>A timeout may be specified in milliseconds, if enough data is not received within the time specified a TimeoutError exception will be raised.</source>
          <target state="translated">超时时间可以以毫秒为单位指定,如果在指定的时间内没有收到足够的数据,就会引发超时错误异常。</target>
        </trans-unit>
        <trans-unit id="9b5284b25f36831bd8cd3b0848696b52af7ef955" translate="yes" xml:space="preserve">
          <source>A timeout may be specified in milliseconds, if enough data is not received within the time specified an ETimeout exception will be raised.</source>
          <target state="translated">超时可以以毫秒为单位指定,如果在指定的时间内没有收到足够的数据,将引发ETimeout异常。</target>
        </trans-unit>
        <trans-unit id="b206d5f711dced99df1aa8e9ea0d1479edc748b9" translate="yes" xml:space="preserve">
          <source>A timeout may be specified in milliseconds, if enough data is not received within the time specified an TimeoutError exception will be raised.</source>
          <target state="translated">超时时间可以以毫秒为单位指定,如果在指定的时间内没有收到足够的数据,就会引发超时错误异常。</target>
        </trans-unit>
        <trans-unit id="5a5e0bec046a288f45da3539bee961bd4b7e1bc5" translate="yes" xml:space="preserve">
          <source>A tuple type defines various named &lt;em&gt;fields&lt;/em&gt; and an &lt;em&gt;order&lt;/em&gt; of the fields. The constructor &lt;code&gt;()&lt;/code&gt; can be used to construct tuples. The order of the fields in the constructor must match the order in the tuple's definition. Different tuple-types are &lt;em&gt;equivalent&lt;/em&gt; if they specify fields of the same type and of the same name in the same order.</source>
          <target state="translated">元组类型定义各种命名&lt;em&gt;字段&lt;/em&gt;和&lt;em&gt;字段&lt;/em&gt;&lt;em&gt;顺序&lt;/em&gt;。构造函数 &lt;code&gt;()&lt;/code&gt; 可用于构造元组。构造函数中字段的顺序必须与元组定义中的顺序匹配。如果不同的元组类型以相同的顺序指定相同类型和相同名称的字段，则它们是&lt;em&gt;等效的&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="5e6444b3f99eb953e87888c66966bcbc524ea4f4" translate="yes" xml:space="preserve">
          <source>A tuple with one unnamed field can be constructed with the parentheses and a trailing comma:</source>
          <target state="translated">一个有一个未命名字段的元组可以用括号和尾部的逗号来构造。</target>
        </trans-unit>
        <trans-unit id="14170c2ff1e7de54f4e2348d1e871df1403c7064" translate="yes" xml:space="preserve">
          <source>A type &lt;code&gt;a&lt;/code&gt; is &lt;strong&gt;explicitly&lt;/strong&gt; convertible to type &lt;code&gt;b&lt;/code&gt; iff the following algorithm returns true:</source>
          <target state="translated">如果以下算法返回true，则类型 &lt;code&gt;a&lt;/code&gt; 可&lt;strong&gt;显式&lt;/strong&gt;转换为类型 &lt;code&gt;b&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="0e266a33b4be68e2d75b658bf09d5fcd023a82b7" translate="yes" xml:space="preserve">
          <source>A type &lt;code&gt;a&lt;/code&gt; is &lt;strong&gt;implicitly&lt;/strong&gt; convertible to type &lt;code&gt;b&lt;/code&gt; iff the following algorithm returns true:</source>
          <target state="translated">如果以下算法返回true，则类型 &lt;code&gt;a&lt;/code&gt; 可以&lt;strong&gt;隐式&lt;/strong&gt;转换为类型 &lt;code&gt;b&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="7dc18dc1dcffe82a8fb4389b39ff6e417d37bfc5" translate="yes" xml:space="preserve">
          <source>A type class can be used directly as the parameter's type.</source>
          <target state="translated">可以直接使用类型类作为参数的类型。</target>
        </trans-unit>
        <trans-unit id="506a88b6ff206893ad4b7e57e9c4e7e99b518ff4" translate="yes" xml:space="preserve">
          <source>A type class is a special pseudo-type that can be used to match against types in the context of overload resolution or the &lt;code&gt;is&lt;/code&gt; operator. Nim supports the following built-in type classes:</source>
          <target state="translated">类型类是一种特殊的伪类型，可以在重载解析或 &lt;code&gt;is&lt;/code&gt; 运算符的上下文中与类型进行匹配。Nim支持以下内置类型类：</target>
        </trans-unit>
        <trans-unit id="d889810de0813b3ec269aad080ce51f23f302bb5" translate="yes" xml:space="preserve">
          <source>A type conversion &lt;code&gt;T(e)&lt;/code&gt; is a path expression.</source>
          <target state="translated">类型转换 &lt;code&gt;T(e)&lt;/code&gt; 是路径表达式。</target>
        </trans-unit>
        <trans-unit id="a1e248a89a87db7e3a826b410d2791efe05a16bd" translate="yes" xml:space="preserve">
          <source>A type representing a directory stream.</source>
          <target state="translated">一种代表目录流的类型。</target>
        </trans-unit>
        <trans-unit id="ec2661446eb8287aeb52ad012da364775c3dbaac" translate="yes" xml:space="preserve">
          <source>A type section begins with the &lt;code&gt;type&lt;/code&gt; keyword. It contains multiple type definitions. A type definition binds a type to a name. Type definitions can be recursive or even mutually recursive. Mutually recursive types are only possible within a single &lt;code&gt;type&lt;/code&gt; section. Nominal types like &lt;code&gt;objects&lt;/code&gt; or &lt;code&gt;enums&lt;/code&gt; can only be defined in a &lt;code&gt;type&lt;/code&gt; section.</source>
          <target state="translated">类型部分以 &lt;code&gt;type&lt;/code&gt; 关键字开头。它包含多个类型定义。类型定义将类型绑定到名称。类型定义可以是递归的，甚至可以是相互递归的。相互递归类型只能在单个 &lt;code&gt;type&lt;/code&gt; 部分中使用。诸如 &lt;code&gt;objects&lt;/code&gt; 或 &lt;code&gt;enums&lt;/code&gt; 类的标称类型只能在 &lt;code&gt;type&lt;/code&gt; 部分中定义。</target>
        </trans-unit>
        <trans-unit id="be7a9f47604f0611af9fa5403b9d09653a88c565" translate="yes" xml:space="preserve">
          <source>A type specialized version of &lt;code&gt;..&amp;lt;&lt;/code&gt; for convenience so that mixing integer types works better.</source>
          <target state="translated">为方便起见， &lt;code&gt;..&amp;lt;&lt;/code&gt; 的类型专用版本使混合整数类型更好地工作。</target>
        </trans-unit>
        <trans-unit id="0511cf3cc72e09256f19cf736ca74f42546431bf" translate="yes" xml:space="preserve">
          <source>A type specialized version of &lt;code&gt;..&lt;/code&gt; for convenience so that mixing integer types work better.</source>
          <target state="translated">为了方便起见， &lt;code&gt;..&lt;/code&gt; 的类型专用版本，以便混合整数类型更好地工作。</target>
        </trans-unit>
        <trans-unit id="9ebdff8f30923670788ff9aaae0394936cf6a032" translate="yes" xml:space="preserve">
          <source>A type specialized version of &lt;code&gt;..&lt;/code&gt; for convenience so that mixing integer types works better.</source>
          <target state="translated">为了方便起见， &lt;code&gt;..&lt;/code&gt; 的类型专用版本使混合整数类型更好地工作。</target>
        </trans-unit>
        <trans-unit id="104ce833879be4ffac814c9243c526f5122867af" translate="yes" xml:space="preserve">
          <source>A valid identifier starts with a character of the set &lt;code&gt;IdentStartChars&lt;/code&gt; and is followed by any number of characters of the set &lt;code&gt;IdentChars&lt;/code&gt;.</source>
          <target state="translated">一个有效的标识符与该集合的字符开始 &lt;code&gt;IdentStartChars&lt;/code&gt; 和后跟任何数量的所述组的字符 &lt;code&gt;IdentChars&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1aca1ed394a97d0358e43ad02e64f2e9f0dad035" translate="yes" xml:space="preserve">
          <source>A valid identifier starts with a character of the set &lt;em&gt;IdentStartChars&lt;/em&gt; and is followed by any number of characters of the set &lt;em&gt;IdentChars&lt;/em&gt;.</source>
          <target state="translated">一个有效的标识符与该集合的字符开始&lt;em&gt;IdentStartChars&lt;/em&gt;和后跟任何数量的所述组的字符&lt;em&gt;IdentChars&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="7e7d8bd354c4774606fc14c89770f32a756c621c" translate="yes" xml:space="preserve">
          <source>A value of type &lt;code&gt;Option[T]&lt;/code&gt; either contains a value &lt;code&gt;x&lt;/code&gt; (represented as &lt;code&gt;some(x)&lt;/code&gt;) or is empty (&lt;code&gt;none(T)&lt;/code&gt;).</source>
          <target state="translated">类型为 &lt;code&gt;Option[T]&lt;/code&gt; 的值要么包含值 &lt;code&gt;x&lt;/code&gt; （表示为 &lt;code&gt;some(x)&lt;/code&gt; ），要么为空（ &lt;code&gt;none(T)&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="d0abd94780a5ea8e9be893452be742a7ec90a256" translate="yes" xml:space="preserve">
          <source>A value of type &lt;code&gt;Option[T]&lt;/code&gt; either contains a value &lt;em&gt;x&lt;/em&gt; (represented as &lt;code&gt;some(x)&lt;/code&gt;) or is empty (&lt;code&gt;none(T)&lt;/code&gt;).</source>
          <target state="translated">类型 &lt;code&gt;Option[T]&lt;/code&gt; 的值要么包含值&lt;em&gt;x&lt;/em&gt;（表示为 &lt;code&gt;some(x)&lt;/code&gt; ），要么为空（ &lt;code&gt;none(T)&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="061691c897942e6f7639e5b9fc01836fcff953a0" translate="yes" xml:space="preserve">
          <source>A variable can be marked with the &lt;code&gt;threadvar&lt;/code&gt; pragma, which makes it a &lt;span id=&quot;threadminuslocal_1&quot;&gt;thread-local&lt;/span&gt; variable; Additionally, this implies all the effects of the &lt;code&gt;global&lt;/code&gt; pragma.</source>
          <target state="translated">可以用 &lt;code&gt;threadvar&lt;/code&gt; pragma 标记变量，这使它成为&lt;span id=&quot;threadminuslocal_1&quot;&gt;线程局部&lt;/span&gt;变量。此外，这意味着 &lt;code&gt;global&lt;/code&gt; 编译指示的所有影响。</target>
        </trans-unit>
        <trans-unit id="c765eca0341d3fd35e0459d767a19482d988b83b" translate="yes" xml:space="preserve">
          <source>A variable length integer encoding implementation inspired by SQLite.</source>
          <target state="translated">一个受SQLite启发的可变长度整数编码实现。</target>
        </trans-unit>
        <trans-unit id="6cf2d03ae6a2d13d0af73951ec3e536467f5ec85" translate="yes" xml:space="preserve">
          <source>A variable of a structured type can hold multiple values at the same time. Structured types can be nested to unlimited levels. Arrays, sequences, tuples, objects and sets belong to the structured types.</source>
          <target state="translated">一个结构化类型的变量可以同时容纳多个值。结构化类型可以无限地嵌套。数组、序列、元组、对象和集合都属于结构化类型。</target>
        </trans-unit>
        <trans-unit id="615d13569c878522ca7102777ce66d9126a9f4e3" translate="yes" xml:space="preserve">
          <source>A variable of a structured type can hold multiple values at the same time. Structured types can be nested to unlimited levels. Arrays, sequences, tuples, objects, and sets belong to the structured types.</source>
          <target state="translated">一个结构化类型的变量可以同时容纳多个值。结构化类型可以无限地嵌套。数组、序列、元组、对象和集合都属于结构化类型。</target>
        </trans-unit>
        <trans-unit id="383eca27423209815099effeedb639e0e4c860fc" translate="yes" xml:space="preserve">
          <source>A variable of a tuple or object type is a heterogeneous storage container. A tuple or object defines various named &lt;em&gt;fields&lt;/em&gt; of a type. A tuple also defines a lexicographic &lt;em&gt;order&lt;/em&gt; of the fields. Tuples are meant to be heterogeneous storage types with few abstractions. The &lt;code&gt;()&lt;/code&gt; syntax can be used to construct tuples. The order of the fields in the constructor must match the order of the tuple's definition. Different tuple-types are &lt;em&gt;equivalent&lt;/em&gt; if they specify the same fields of the same type in the same order. The &lt;em&gt;names&lt;/em&gt; of the fields also have to be identical.</source>
          <target state="translated">元组或对象类型的变量是异构存储容器。元组或对象定义类型的各种命名&lt;em&gt;字段&lt;/em&gt;。元组还定义字段的字典&lt;em&gt;顺序&lt;/em&gt;。元组是具有很少抽象的异构存储类型。在 &lt;code&gt;()&lt;/code&gt; 的语法可以被用来构造元组。构造函数中字段的顺序必须与元组定义的顺序匹配。如果不同的元组类型以相同的顺序指定相同类型的相同字段，则它们是&lt;em&gt;等效的&lt;/em&gt;。该&lt;em&gt;名称&lt;/em&gt;字段也必须是相同的。</target>
        </trans-unit>
        <trans-unit id="c3f3d14f490e58bdf5285ce0bef4d7745002ec1a" translate="yes" xml:space="preserve">
          <source>A variable of a tuple or object type is a heterogeneous storage container. A tuple or object defines various named &lt;em&gt;fields&lt;/em&gt; of a type. A tuple also defines an &lt;em&gt;order&lt;/em&gt; of the fields. Tuples are meant for heterogeneous storage types with no overhead and few abstraction possibilities. The constructor &lt;code&gt;()&lt;/code&gt; can be used to construct tuples. The order of the fields in the constructor must match the order of the tuple's definition. Different tuple-types are &lt;em&gt;equivalent&lt;/em&gt; if they specify the same fields of the same type in the same order. The &lt;em&gt;names&lt;/em&gt; of the fields also have to be identical.</source>
          <target state="translated">元组或对象类型的变量是异构存储容器。元组或对象定义类型的各种命名&lt;em&gt;字段&lt;/em&gt;。元组还定义字段的&lt;em&gt;顺序&lt;/em&gt;。元组用于异构存储类型，没有开销，并且抽象的可能性很小。构造函数 &lt;code&gt;()&lt;/code&gt; 可用于构造元组。构造函数中字段的顺序必须与元组定义的顺序匹配。如果不同的元组类型以相同的顺序指定相同类型的相同字段，则它们是&lt;em&gt;等效的&lt;/em&gt;。该&lt;em&gt;名称&lt;/em&gt;字段也必须是相同的。</target>
        </trans-unit>
        <trans-unit id="7bdc1f89d378b40222906883361628b1181e0aa3" translate="yes" xml:space="preserve">
          <source>A variable of an enumeration type can only be assigned one of the enumeration's specified values. These values are a set of ordered symbols. Each symbol is mapped to an integer value internally. The first symbol is represented at runtime by 0, the second by 1 and so on. For example:</source>
          <target state="translated">一个枚举类型的变量只能被分配给枚举的指定值之一。这些值是一组有序的符号。每个符号在内部被映射到一个整数值。第一个符号在运行时用0表示,第二个符号用1表示,以此类推。例如</target>
        </trans-unit>
        <trans-unit id="03eb03003aebc272b7eb136b33ffcf55da04a588" translate="yes" xml:space="preserve">
          <source>A variant of &lt;code&gt;connect&lt;/code&gt; for non-blocking sockets.</source>
          <target state="translated">非阻塞套接字的 &lt;code&gt;connect&lt;/code&gt; 变体。</target>
        </trans-unit>
        <trans-unit id="b2257c4803acf9cbae2e6013d672e5f7d0b8ca99" translate="yes" xml:space="preserve">
          <source>A view &lt;code&gt;v&lt;/code&gt; can borrow from multiple different locations. However, the borrow is always the full span of &lt;code&gt;v&lt;/code&gt;'s lifetime and every location that is borrowed from is sealed during &lt;code&gt;v&lt;/code&gt;'s lifetime.</source>
          <target state="translated">视图 &lt;code&gt;v&lt;/code&gt; 可以从多个不同的位置借用。但是，借用始终是 &lt;code&gt;v&lt;/code&gt; 整个生命周期的全部，并且从借用的每个位置在 &lt;code&gt;v&lt;/code&gt; 的整个生命周期都被密封。</target>
        </trans-unit>
        <trans-unit id="0e7b23280919cdb8b9ed6ba03f16d8dec6e0d684" translate="yes" xml:space="preserve">
          <source>A view cannot be used for a read or a write access before it was assigned to.</source>
          <target state="translated">视图在被分配到之前,不能用于读或写访问。</target>
        </trans-unit>
        <trans-unit id="7eaa38aea35d4e613cc0cdbe4d2bcd6d5ae28f65" translate="yes" xml:space="preserve">
          <source>A view type is a type that is or contains one of the following types:</source>
          <target state="translated">视图类型是一种类型,是或包含以下类型之一。</target>
        </trans-unit>
        <trans-unit id="16154a4c78506d48d05de09fc2c147e545ffe199" translate="yes" xml:space="preserve">
          <source>A warning is a non-error message that may indicate impending problems or degraded performance.</source>
          <target state="translated">警告是一种非错误信息,可能表明即将发生的问题或性能下降。</target>
        </trans-unit>
        <trans-unit id="71ed9093f7d2c5cbb9aa8a3933ec4cb522e39e48" translate="yes" xml:space="preserve">
          <source>A while (for) statement introduces an implicit block. Identifiers are only visible within the block they have been declared. The &lt;code&gt;block&lt;/code&gt; statement can be used to open a new block explicitly:</source>
          <target state="translated">while（for）语句引入隐式块。标识符仅在声明它们的块内可见。该 &lt;code&gt;block&lt;/code&gt; 语句可以用来显式地打开一个新的模块：</target>
        </trans-unit>
        <trans-unit id="bc56783853877b4342018f4f4752a7c166237a4d" translate="yes" xml:space="preserve">
          <source>A word boundary is a position in the subject string where the current character and the previous character do not both match &lt;code&gt;\w&lt;/code&gt; or &lt;code&gt;\W&lt;/code&gt; (i.e. one matches &lt;code&gt;\w&lt;/code&gt; and the other matches &lt;code&gt;\W&lt;/code&gt;), or the start or end of the string if the first or last character matches &lt;code&gt;\w&lt;/code&gt;, respectively.</source>
          <target state="translated">单词边界是主题字符串中当前字符和前一个字符都不都匹配 &lt;code&gt;\w&lt;/code&gt; 或 &lt;code&gt;\W&lt;/code&gt; （即，一个匹配 &lt;code&gt;\w&lt;/code&gt; ，另一个匹配 &lt;code&gt;\W&lt;/code&gt; ），或者字符串的开头或结尾，如果第一个或最后一个字符分别与 &lt;code&gt;\w&lt;/code&gt; 匹配。</target>
        </trans-unit>
        <trans-unit id="469aae2fa20a5b364724db93849620fbab87ad21" translate="yes" xml:space="preserve">
          <source>API naming design</source>
          <target state="translated">API命名设计</target>
        </trans-unit>
        <trans-unit id="36215f7f26fcbc8102d12ecfe6c77120c8396238" translate="yes" xml:space="preserve">
          <source>API symbols</source>
          <target state="translated">API符号</target>
        </trans-unit>
        <trans-unit id="8257a9cef2fe7db39639531c88970335f2c53c77" translate="yes" xml:space="preserve">
          <source>ARC</source>
          <target state="translated">ARC</target>
        </trans-unit>
        <trans-unit id="6e86868dfa064831def0a9a32949fcd3f02c8b05" translate="yes" xml:space="preserve">
          <source>AST based overloading</source>
          <target state="translated">基于AST的超载</target>
        </trans-unit>
        <trans-unit id="b08670d9d509dc53f0d69a06ccafcdfc0680021a" translate="yes" xml:space="preserve">
          <source>AST:</source>
          <target state="translated">AST:</target>
        </trans-unit>
        <trans-unit id="ed89ae3b78e13637e55b85c4b03f6daaccfcbc6b" translate="yes" xml:space="preserve">
          <source>Abbreviated three-letter form of the month.</source>
          <target state="translated">缩写的三个字母形式的月份。</target>
        </trans-unit>
        <trans-unit id="02befbd420c9754ded8c9a688a174615ddafd2a6" translate="yes" xml:space="preserve">
          <source>About this document</source>
          <target state="translated">关于本文件</target>
        </trans-unit>
        <trans-unit id="82b42258d7c7bb21ed3bb91a405d2c8d359a3934" translate="yes" xml:space="preserve">
          <source>AbsoluteDir:</source>
          <target state="translated">AbsoluteDir:</target>
        </trans-unit>
        <trans-unit id="0bcb5dbfb40a4d52e65b989317809bb509a54006" translate="yes" xml:space="preserve">
          <source>AbsoluteFile:</source>
          <target state="translated">AbsoluteFile:</target>
        </trans-unit>
        <trans-unit id="d79da395b5d7a09c6439a5f2660d8c568186ab7e" translate="yes" xml:space="preserve">
          <source>Abstract</source>
          <target state="translated">Abstract</target>
        </trans-unit>
        <trans-unit id="1b33443d15e91efce2e27797d2c769792a4be765" translate="yes" xml:space="preserve">
          <source>Abstract base class for all exceptions that Nim's runtime raises but that are strictly uncatchable as they can also be mapped to a &lt;code&gt;quit&lt;/code&gt; / &lt;code&gt;trap&lt;/code&gt; / &lt;code&gt;exit&lt;/code&gt; operation.</source>
          <target state="translated">Nim的运行时引发的所有异常的抽象基类，这些异常严格不可 &lt;code&gt;trap&lt;/code&gt; 因为它们也可以映射到 &lt;code&gt;quit&lt;/code&gt; / trap / &lt;code&gt;exit&lt;/code&gt; 操作。</target>
        </trans-unit>
        <trans-unit id="07ade5cd2426cf2d96d9f115a542fdf23ea73fb2" translate="yes" xml:space="preserve">
          <source>Abstract class for all exceptions that are catchable.</source>
          <target state="translated">所有可捕获的异常的抽象类。</target>
        </trans-unit>
        <trans-unit id="3f4e6a4ec9f1c43c4563924339bce51ceb8eb0af" translate="yes" xml:space="preserve">
          <source>Accepts a block of nim code and prints the parsed abstract syntax tree using the &lt;code&gt;astGenRepr&lt;/code&gt; proc. Printing is done &lt;em&gt;at compile time&lt;/em&gt;.</source>
          <target state="translated">接受一个nim代码块，并使用 &lt;code&gt;astGenRepr&lt;/code&gt; proc打印已解析的抽象语法树。打印&lt;em&gt;在编译时&lt;/em&gt;完成。</target>
        </trans-unit>
        <trans-unit id="e09ba72f81ab5a839d563be4983123e765b18fc8" translate="yes" xml:space="preserve">
          <source>Accepts a block of nim code and prints the parsed abstract syntax tree using the &lt;code&gt;lispRepr&lt;/code&gt; proc. Printing is done &lt;em&gt;at compile time&lt;/em&gt;.</source>
          <target state="translated">接受一个nim代码块，并使用 &lt;code&gt;lispRepr&lt;/code&gt; proc打印已解析的抽象语法树。打印&lt;em&gt;在编译时&lt;/em&gt;完成。</target>
        </trans-unit>
        <trans-unit id="9d87fb77e58949f4a3af1708d01b460d4e3d3dc1" translate="yes" xml:space="preserve">
          <source>Accepts a block of nim code and prints the parsed abstract syntax tree using the &lt;code&gt;treeRepr&lt;/code&gt; proc. Printing is done &lt;em&gt;at compile time&lt;/em&gt;.</source>
          <target state="translated">接受一个nim代码块，并使用 &lt;code&gt;treeRepr&lt;/code&gt; proc打印已解析的抽象语法树。打印&lt;em&gt;在编译时&lt;/em&gt;完成。</target>
        </trans-unit>
        <trans-unit id="1cf35ec1eeb0cdf41c798e53ae7c4bdbcf3c6e03" translate="yes" xml:space="preserve">
          <source>Accepts a block of nim code and prints the parsed abstract syntax tree using the &lt;em&gt;astGenRepr&lt;/em&gt; function. Printing is done &lt;em&gt;at compile time&lt;/em&gt;.</source>
          <target state="translated">接受一个nim代码块，并使用&lt;em&gt;astGenRepr&lt;/em&gt;函数打印已解析的抽象语法树。打印&lt;em&gt;在编译时&lt;/em&gt;完成。</target>
        </trans-unit>
        <trans-unit id="7c6e301f36546045d51728adbff6b973b0918094" translate="yes" xml:space="preserve">
          <source>Accepts a block of nim code and prints the parsed abstract syntax tree using the &lt;em&gt;lispRepr&lt;/em&gt; function. Printing is done &lt;em&gt;at compile time&lt;/em&gt;.</source>
          <target state="translated">接受一个nim代码块，并使用&lt;em&gt;lispRepr&lt;/em&gt;函数打印已解析的抽象语法树。打印&lt;em&gt;在编译时&lt;/em&gt;完成。</target>
        </trans-unit>
        <trans-unit id="7eb919c05e9f3591e4b18f0af2d7cce492e0545f" translate="yes" xml:space="preserve">
          <source>Accepts a block of nim code and prints the parsed abstract syntax tree using the &lt;em&gt;treeRepr&lt;/em&gt; function. Printing is done &lt;em&gt;at compile time&lt;/em&gt;.</source>
          <target state="translated">接受一个nim代码块，并使用&lt;em&gt;treeRepr&lt;/em&gt;函数打印已解析的抽象语法树。打印&lt;em&gt;在编译时&lt;/em&gt;完成。</target>
        </trans-unit>
        <trans-unit id="ce207f0652d5a79c6fb92d9892844f64c3c7bc7f" translate="yes" xml:space="preserve">
          <source>Accepts a new client connection.</source>
          <target state="translated">接受一个新的客户端连接。</target>
        </trans-unit>
        <trans-unit id="142256b8872d5b2f49b7b35629597dff2e50c2c2" translate="yes" xml:space="preserve">
          <source>Accepts a new connection. Returns a future containing the client socket corresponding to that connection and the remote address of the client.</source>
          <target state="translated">接受一个新的连接。返回一个包含该连接对应的客户端套接字和客户端远程地址的未来。</target>
        </trans-unit>
        <trans-unit id="0612c97d4b20e5af1b9ee2e86992dd16c29c8cbf" translate="yes" xml:space="preserve">
          <source>Accepts a new connection. Returns a future containing the client socket corresponding to that connection and the remote address of the client. The future will complete when the connection is successfully accepted.</source>
          <target state="translated">接受一个新的连接。返回一个future,包含该连接对应的客户端套接字和客户端的远程地址。当连接被成功接受时,未来将完成。</target>
        </trans-unit>
        <trans-unit id="de10becfb867ce7d8a57fe498147c24ce2fed31f" translate="yes" xml:space="preserve">
          <source>Accepts a new connection. Returns a future containing the client socket corresponding to that connection.</source>
          <target state="translated">接受一个新的连接。返回一个包含该连接对应的客户端套接字的未来。</target>
        </trans-unit>
        <trans-unit id="fd2156945d294c5977e8484e2589d72a67377e8e" translate="yes" xml:space="preserve">
          <source>Accepts a new connection. Returns a future containing the client socket corresponding to that connection. If &lt;code&gt;inheritable&lt;/code&gt; is false (the default), the resulting client socket will not be inheritable by child processes. The future will complete when the connection is successfully accepted.</source>
          <target state="translated">接受新的连接。返回一个包含与该连接相对应的客户端套接字的future。如果 &lt;code&gt;inheritable&lt;/code&gt; 为false（默认设置），则生成的客户端套接字将不能被子进程继承。成功接受连接后，将来将完成。</target>
        </trans-unit>
        <trans-unit id="bb38da96bcf63ef07293cca8f7fae610327e435b" translate="yes" xml:space="preserve">
          <source>Accepts a new connection. Returns a future containing the client socket corresponding to that connection. The future will complete when the connection is successfully accepted.</source>
          <target state="translated">接受一个新的连接。返回一个包含该连接对应的客户端套接字的future。当连接被成功接受时,未来将完成。</target>
        </trans-unit>
        <trans-unit id="deb7592ffcf1beaf11244155535faaf11982362b" translate="yes" xml:space="preserve">
          <source>Accepts a node of kind &lt;code&gt;nnkSym&lt;/code&gt; and returns its owner's symbol. The meaning of 'owner' depends on &lt;code&gt;sym&lt;/code&gt;'s &lt;code&gt;NimSymKind&lt;/code&gt; and declaration context. For top level declarations this is an &lt;code&gt;nskModule&lt;/code&gt; symbol, for proc local variables an &lt;code&gt;nskProc&lt;/code&gt; symbol, for enum/object fields an &lt;code&gt;nskType&lt;/code&gt; symbol, etc. For symbols without an owner, &lt;code&gt;nil&lt;/code&gt; is returned.</source>
          <target state="translated">接受类型为 &lt;code&gt;nnkSym&lt;/code&gt; 的节点并返回其所有者的符号。&amp;ldquo;所有者&amp;rdquo;的含义取决于 &lt;code&gt;sym&lt;/code&gt; 的 &lt;code&gt;NimSymKind&lt;/code&gt; 和声明上下文。对于顶级声明，这是一个 &lt;code&gt;nskModule&lt;/code&gt; 符号，对于proc局部变量是一个 &lt;code&gt;nskProc&lt;/code&gt; 符号，对于枚举/对象字段是一个 &lt;code&gt;nskType&lt;/code&gt; 符号，等等。对于没有所有者的符号，将返回 &lt;code&gt;nil&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="33dc09425d5909c6371181a754cfc69bb0dffcb5" translate="yes" xml:space="preserve">
          <source>Accepts a single request. Write an explicit loop around this proc so that errors can be handled properly.</source>
          <target state="translated">接受一个请求。围绕这个proc写一个显式循环,以便正确处理错误。</target>
        </trans-unit>
        <trans-unit id="6813381cdc37c15725205e39fd4619d20653f02f" translate="yes" xml:space="preserve">
          <source>Accepts an instantiated generic type and returns its uninstantiated form.</source>
          <target state="translated">接受一个实例化的通用类型,并返回其未实例化的形式。</target>
        </trans-unit>
        <trans-unit id="faf4ef0e56229453f96a306fcf1a0f1923d413de" translate="yes" xml:space="preserve">
          <source>Acceses a specified &lt;em&gt;entry&lt;/em&gt; from the current row.</source>
          <target state="translated">在当前行中访问指定的&lt;em&gt;条目&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="1af3cc3329098e5826bfbbeb60f9d9bd983e292a" translate="yes" xml:space="preserve">
          <source>Access URI item</source>
          <target state="translated">访问URI项目</target>
        </trans-unit>
        <trans-unit id="f9e9dd7a48db03f7a1f9615c265496ab948af3da" translate="yes" xml:space="preserve">
          <source>Access the currently matched character</source>
          <target state="translated">访问当前匹配的字符</target>
        </trans-unit>
        <trans-unit id="9e2f25bad75994a6d0402acd174ffe98487bb1e8" translate="yes" xml:space="preserve">
          <source>Access the i-th element of &lt;em&gt;deq&lt;/em&gt; and returns a mutable reference to it.</source>
          <target state="translated">访问&lt;em&gt;deq&lt;/em&gt;的第i个元素，并返回对其的可变引用。</target>
        </trans-unit>
        <trans-unit id="b235504e101d141812cbd31b5736348cbd949d54" translate="yes" xml:space="preserve">
          <source>Access the i-th element of &lt;em&gt;deq&lt;/em&gt; by order from first to last. deq[0] is the first, deq[^1] is the last.</source>
          <target state="translated">按&lt;em&gt;从头到尾&lt;/em&gt;的顺序访问&lt;em&gt;deq&lt;/em&gt;的第i个元素。deq [0]是第一个，deq [^ 1]是最后一个。</target>
        </trans-unit>
        <trans-unit id="8b33d8dee700b0371d3e740bce3869834048d0ab" translate="yes" xml:space="preserve">
          <source>Accesses a specified &lt;code&gt;entry&lt;/code&gt; from the current row.</source>
          <target state="translated">从当前行访问指定的 &lt;code&gt;entry&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="27bdd5381d9fed61828adf89a00b3a554f8c9b97" translate="yes" xml:space="preserve">
          <source>Accesses the backwards indexed i-th element.</source>
          <target state="translated">访问向后索引的第i个元素。</target>
        </trans-unit>
        <trans-unit id="c40814a4680dc13930b702b75b874a15a540cd44" translate="yes" xml:space="preserve">
          <source>Accesses the i-th element of &lt;code&gt;deq&lt;/code&gt; and return a mutable reference to it.</source>
          <target state="translated">访问 &lt;code&gt;deq&lt;/code&gt; 的第i个元素并返回对其的可变引用。</target>
        </trans-unit>
        <trans-unit id="4224433220776a7cd401842ee32aaee48826f9f3" translate="yes" xml:space="preserve">
          <source>Accesses the i-th element of &lt;code&gt;deq&lt;/code&gt;.</source>
          <target state="translated">访问 &lt;code&gt;deq&lt;/code&gt; 的第i个元素。</target>
        </trans-unit>
        <trans-unit id="8383ecf2951ae26619d64ffe472323e3628beb48" translate="yes" xml:space="preserve">
          <source>Accesses the i-th element of &lt;code&gt;heap&lt;/code&gt;.</source>
          <target state="translated">访问 &lt;code&gt;heap&lt;/code&gt; 的第i个元素。</target>
        </trans-unit>
        <trans-unit id="b9157430212e0fe0ab310f60c200c7494abe11f3" translate="yes" xml:space="preserve">
          <source>Accessor for an any &lt;code&gt;x&lt;/code&gt; that represents an array or a sequence.</source>
          <target state="translated">代表数组或序列的任何 &lt;code&gt;x&lt;/code&gt; 的访问器。</target>
        </trans-unit>
        <trans-unit id="c47d1e40dccddf8bf9622ec7b3c9e44c4af97584" translate="yes" xml:space="preserve">
          <source>Accumulator</source>
          <target state="translated">Accumulator</target>
        </trans-unit>
        <trans-unit id="737a162e2ca0961109be76dcbc40928b7272da0a" translate="yes" xml:space="preserve">
          <source>Acquires the given lock and then executes the code.</source>
          <target state="translated">获取给定的锁,然后执行代码。</target>
        </trans-unit>
        <trans-unit id="e94c5bb8f50ed78a7cd750db454d2af3ae23df56" translate="yes" xml:space="preserve">
          <source>Acquires the given lock, executes the statements in body and releases the lock after the statements finish executing.</source>
          <target state="translated">获取给定的锁,执行正文中的语句,语句执行完毕后释放锁。</target>
        </trans-unit>
        <trans-unit id="1a3e3046bdb90198f8603411233d3c6451ca3f0a" translate="yes" xml:space="preserve">
          <source>Acquires the given lock.</source>
          <target state="translated">获得指定的锁。</target>
        </trans-unit>
        <trans-unit id="d2f9d48fe60d96f7c86fe92fea51a30eef86ea2a" translate="yes" xml:space="preserve">
          <source>Acts in a similar fashion to the &lt;em&gt;recvLine&lt;/em&gt; in the sockets module. Returns false when no data is available to be read. &lt;em&gt;Line&lt;/em&gt; must be initialized and not nil!</source>
          <target state="translated">行为与套接字模块中的&lt;em&gt;recvLine&lt;/em&gt;相似。当没有数据可读取时返回false。&lt;em&gt;行&lt;/em&gt;必须初始化，不能为nil！</target>
        </trans-unit>
        <trans-unit id="05cb0e3d96a9a97e0426bf235a612402b2cea3d4" translate="yes" xml:space="preserve">
          <source>Add &lt;code&gt;ident&lt;/code&gt; to &lt;code&gt;dest&lt;/code&gt; if it is not present. This is intended for use with pragmas.</source>
          <target state="translated">如果不存在，则将 &lt;code&gt;ident&lt;/code&gt; 添加到 &lt;code&gt;dest&lt;/code&gt; 。这旨在用于编译指示。</target>
        </trans-unit>
        <trans-unit id="b05779dfde7404de32c688c1c9a48959dd22bdd2" translate="yes" xml:space="preserve">
          <source>Add &lt;em&gt;y&lt;/em&gt; to &lt;em&gt;x&lt;/em&gt;.</source>
          <target state="translated">将&lt;em&gt;y&lt;/em&gt;添加到&lt;em&gt;x&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="4feee750a058b68182288ba271fbda6845aca1fd" translate="yes" xml:space="preserve">
          <source>Add &lt;em&gt;y&lt;/em&gt; to the complex number &lt;em&gt;x&lt;/em&gt;.</source>
          <target state="translated">将&lt;em&gt;y&lt;/em&gt;加到复数&lt;em&gt;x上&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="c680f465bd9dc1e03f6e6d6ea7255c81ff7a44a5" translate="yes" xml:space="preserve">
          <source>Add a duration of time to a &lt;code&gt;Time&lt;/code&gt;.</source>
          <target state="translated">将持续时间添加到 &lt;code&gt;Time&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="9fa2d1e935ee54d15d98822bf8df93e7a3580d69" translate="yes" xml:space="preserve">
          <source>Add a file to the multipart data &lt;code&gt;p&lt;/code&gt;, specifying filename, contentType and content manually.</source>
          <target state="translated">将文件添加到多部分数据 &lt;code&gt;p&lt;/code&gt; 中，手动指定文件名，contentType和内容。</target>
        </trans-unit>
        <trans-unit id="0329e59f93f564c5dfc0e70569d15fb9e15a73e3" translate="yes" xml:space="preserve">
          <source>Add a file to the multipart data &lt;em&gt;p&lt;/em&gt;, specifying filename, contentType and content manually.</source>
          <target state="translated">将文件添加到多部分数据&lt;em&gt;p中&lt;/em&gt;，手动指定文件名，contentType和内容。</target>
        </trans-unit>
        <trans-unit id="08fdfd4c11aa155b46a85fcf36cf6b5ef01faf49" translate="yes" xml:space="preserve">
          <source>Add a list of multipart entries to the multipart data &lt;code&gt;p&lt;/code&gt;. All values are added without a filename and without a content type.</source>
          <target state="translated">将多部分条目列表添加到多部分数据 &lt;code&gt;p&lt;/code&gt; 中。所有值的添加都没有文件名和内容类型。</target>
        </trans-unit>
        <trans-unit id="eec5847211247b4fd74ccdc819e2406c975b05b5" translate="yes" xml:space="preserve">
          <source>Add a list of multipart entries to the multipart data &lt;em&gt;p&lt;/em&gt;. All values are added without a filename and without a content type.</source>
          <target state="translated">将多部分条目列表添加到多部分数据&lt;em&gt;p中&lt;/em&gt;。所有值的添加都没有文件名和内容类型。</target>
        </trans-unit>
        <trans-unit id="8716036a11430485de8c4308a7013612cbed93c8" translate="yes" xml:space="preserve">
          <source>Add a multipart entry to the multipart data &lt;code&gt;p&lt;/code&gt;. The value is added without a filename and without a content type.</source>
          <target state="translated">将多部分条目添加到多部分数据 &lt;code&gt;p&lt;/code&gt; 。该值添加时没有文件名，也没有内容类型。</target>
        </trans-unit>
        <trans-unit id="798a336ba2abb70a55f061577e20dced31fde63c" translate="yes" xml:space="preserve">
          <source>Add a multipart entry to the multipart data &lt;em&gt;p&lt;/em&gt;. The value is added without a filename and without a content type.</source>
          <target state="translated">将多部分条目添加到多部分数据&lt;em&gt;p&lt;/em&gt;。该值添加时没有文件名，也没有内容类型。</target>
        </trans-unit>
        <trans-unit id="f905661c323f469aafe9d05538fcce090acb423d" translate="yes" xml:space="preserve">
          <source>Add a value to the multipart data.</source>
          <target state="translated">为多部分数据添加一个值。</target>
        </trans-unit>
        <trans-unit id="f04550fc57e117bf8d9e7db6f83bdeafaba0d38d" translate="yes" xml:space="preserve">
          <source>Add a value to the multipart data. Raises a &lt;em&gt;ValueError&lt;/em&gt; exception if &lt;em&gt;name&lt;/em&gt;, &lt;em&gt;filename&lt;/em&gt; or &lt;em&gt;contentType&lt;/em&gt; contain newline characters.</source>
          <target state="translated">向多部分数据添加一个值。如果&lt;em&gt;name&lt;/em&gt;，&lt;em&gt;filename&lt;/em&gt;或&lt;em&gt;contentType&lt;/em&gt;包含换行符，则引发&lt;em&gt;ValueError&lt;/em&gt;异常。&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="772b15743a6941c602fc6966a8c9ad76de348c4b" translate="yes" xml:space="preserve">
          <source>Add an &lt;em&gt;item&lt;/em&gt; to the beginning of the &lt;em&gt;deq&lt;/em&gt;.</source>
          <target state="translated">在&lt;em&gt;deq&lt;/em&gt;的开头添加一个&lt;em&gt;项目&lt;/em&gt;。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2f6d2bfa601515402b5cd9a27e6de27a42f1ae49" translate="yes" xml:space="preserve">
          <source>Add an &lt;em&gt;item&lt;/em&gt; to the end of the &lt;em&gt;deq&lt;/em&gt;.</source>
          <target state="translated">在&lt;em&gt;deq&lt;/em&gt;的末尾添加一个&lt;em&gt;项目&lt;/em&gt;。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="4795b951a509e1ad114b904fea7f85d924a8b442" translate="yes" xml:space="preserve">
          <source>Add an item to the sequence</source>
          <target state="translated">在序列中添加一个项目</target>
        </trans-unit>
        <trans-unit id="f07bbced7392ce2be35b14f1ec60bf9e70357bb9" translate="yes" xml:space="preserve">
          <source>Add character to the string</source>
          <target state="translated">在字符串中添加字符</target>
        </trans-unit>
        <trans-unit id="804dca14340f9191ea44cbc9a5b612d3b7b60531" translate="yes" xml:space="preserve">
          <source>Add complex &lt;em&gt;x&lt;/em&gt; to float &lt;em&gt;y&lt;/em&gt;.</source>
          <target state="translated">将复数&lt;em&gt;x&lt;/em&gt;加到浮点&lt;em&gt;y上&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="91af401e69eb5db85492da365b587bfdcdd3c94f" translate="yes" xml:space="preserve">
          <source>Add files to a multipart data object. The file will be opened from your disk, read and sent with the automatically determined MIME type. Raises an &lt;em&gt;IOError&lt;/em&gt; if the file cannot be opened or reading fails. To manually specify file content, filename and MIME type, use &lt;em&gt;[]=&lt;/em&gt; instead.</source>
          <target state="translated">将文件添加到多部分数据对象。该文件将从您的磁盘打开，以自动确定的MIME类型读取和发送。如果无法打开文件或读取失败，则引发&lt;em&gt;IOError&lt;/em&gt;。要手动指定文件内容，文件名和MIME类型，请改用&lt;em&gt;[] =&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="52402dfdf42abb7b53517707a59330538bafd910" translate="yes" xml:space="preserve">
          <source>Add files to a multipart data object. The files will be streamed from disk when the request is being made. When &lt;code&gt;stream&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;, the files are instead read into memory, but beware this is very memory ineffecient even for small files. The MIME types will automatically be determined. Raises an &lt;code&gt;IOError&lt;/code&gt; if the file cannot be opened or reading fails. To manually specify file content, filename and MIME type, use &lt;code&gt;[]=&lt;/code&gt; instead.</source>
          <target state="translated">将文件添加到多部分数据对象。发出请求时，将从磁盘上流式传输文件。当 &lt;code&gt;stream&lt;/code&gt; 为 &lt;code&gt;false&lt;/code&gt; 时，文件将被读取到内存中，但是请注意，即使对于小文件，这也是非常低效的内存。MIME类型将自动确定。如果无法打开文件或读取失败，则引发 &lt;code&gt;IOError&lt;/code&gt; 。要手动指定文件内容，文件名和MIME类型，请改用 &lt;code&gt;[]=&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="406ccec3a46c7096b360cd3465737a8b535aea4c" translate="yes" xml:space="preserve">
          <source>Add float &lt;em&gt;x&lt;/em&gt; to complex &lt;em&gt;y&lt;/em&gt;.</source>
          <target state="translated">将float &lt;em&gt;x&lt;/em&gt;添加到&lt;em&gt;y&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="505c6693913fe1565ef1c731c3ebc737609d4c48" translate="yes" xml:space="preserve">
          <source>Add ident to dest if it is not present. This is intended for use with pragmas.</source>
          <target state="translated">如果不存在,则在 dest 中添加 ident。这是为了与实用名词一起使用。</target>
        </trans-unit>
        <trans-unit id="ed6a96e38077149fb1f9acfe217b88923300d176" translate="yes" xml:space="preserve">
          <source>Add int &lt;code&gt;x&lt;/code&gt; to rational &lt;code&gt;y&lt;/code&gt;.</source>
          <target state="translated">将int &lt;code&gt;x&lt;/code&gt; 加到有理 &lt;code&gt;y&lt;/code&gt; 上。</target>
        </trans-unit>
        <trans-unit id="7f82f0fe426d7f18de6a09b1fee81b37ab4f8907" translate="yes" xml:space="preserve">
          <source>Add int &lt;code&gt;y&lt;/code&gt; to rational &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">将int &lt;code&gt;y&lt;/code&gt; 添加到有理 &lt;code&gt;x&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b50017805b1b6fc4f451182d9127fec897f8b761" translate="yes" xml:space="preserve">
          <source>Add int &lt;em&gt;x&lt;/em&gt; to rational &lt;em&gt;y&lt;/em&gt;.</source>
          <target state="translated">将int &lt;em&gt;x&lt;/em&gt;添加到有理&lt;em&gt;y&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="9fd52413273ba8dedf3c71352a83c577246c8699" translate="yes" xml:space="preserve">
          <source>Add int &lt;em&gt;y&lt;/em&gt; to rational &lt;em&gt;x&lt;/em&gt;.</source>
          <target state="translated">将int &lt;em&gt;y&lt;/em&gt;添加到有理&lt;em&gt;x&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="cfd9da0bd8b02d4be1a67e73526e14e1ec6c2189" translate="yes" xml:space="preserve">
          <source>Add rational &lt;code&gt;x&lt;/code&gt; to int &lt;code&gt;y&lt;/code&gt;.</source>
          <target state="translated">将有理 &lt;code&gt;x&lt;/code&gt; 加到int &lt;code&gt;y&lt;/code&gt; 上。</target>
        </trans-unit>
        <trans-unit id="c52d3037755de98e3ad893c88823ad9c9de430f5" translate="yes" xml:space="preserve">
          <source>Add rational &lt;code&gt;y&lt;/code&gt; to rational &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">将有理 &lt;code&gt;y&lt;/code&gt; 添加到有理 &lt;code&gt;x&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f18a8ab635db264a0fe3a0922ec6560932edcddf" translate="yes" xml:space="preserve">
          <source>Add rational &lt;em&gt;x&lt;/em&gt; to int &lt;em&gt;y&lt;/em&gt;.</source>
          <target state="translated">将有理数&lt;em&gt;x&lt;/em&gt;添加到int &lt;em&gt;y&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="2aa6c134ddb31344adb0018507fd22c268b0cb12" translate="yes" xml:space="preserve">
          <source>Add rational &lt;em&gt;y&lt;/em&gt; to rational &lt;em&gt;x&lt;/em&gt;.</source>
          <target state="translated">将有理&lt;em&gt;y&lt;/em&gt;添加到有理&lt;em&gt;x&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="d1747c4bec3777bff15f92b0cac11995facbb754" translate="yes" xml:space="preserve">
          <source>Add two complex numbers.</source>
          <target state="translated">加两个复数。</target>
        </trans-unit>
        <trans-unit id="10e886ac53c1940ea63eb1399092efb3e0175be5" translate="yes" xml:space="preserve">
          <source>Add two durations together.</source>
          <target state="translated">将两个期限加在一起。</target>
        </trans-unit>
        <trans-unit id="918bdd0b6e0ab8c7e512d1c14637656e65c676d4" translate="yes" xml:space="preserve">
          <source>Add two rational numbers.</source>
          <target state="translated">加两个有理数。</target>
        </trans-unit>
        <trans-unit id="f9f4e2a4ee342e53c003797651594c460da995fd" translate="yes" xml:space="preserve">
          <source>Adding a method to a class the programmer has no control over is impossible or needs ugly workarounds.</source>
          <target state="translated">在程序员无法控制的类中添加一个方法是不可能的,或者需要丑陋的变通方法。</target>
        </trans-unit>
        <trans-unit id="2025ebd7978991464bc4c04e553287e1846aa3ca" translate="yes" xml:space="preserve">
          <source>Additional Features</source>
          <target state="translated">附加功能</target>
        </trans-unit>
        <trans-unit id="050d53ae9db89d00328e7590301c21bc8b18552a" translate="yes" xml:space="preserve">
          <source>Additional compilation switches</source>
          <target state="translated">额外的编译开关</target>
        </trans-unit>
        <trans-unit id="40896bd1d7fb4e2d2b859f8c06ae9aa5ebd3ac5f" translate="yes" xml:space="preserve">
          <source>Additional documentation about Nim's GC and how to operate it in a</source>
          <target state="translated">关于Nim的GC的附加文件以及如何操作它。</target>
        </trans-unit>
        <trans-unit id="69fde59a7b9ef81d45e08f2d1fd9df14f9421393" translate="yes" xml:space="preserve">
          <source>Additional documentation about Nim's multi-paradigm memory management strategies</source>
          <target state="translated">关于Nim的多范式内存管理策略的其他文档。</target>
        </trans-unit>
        <trans-unit id="a15fa56393dfeea6e8ddbb0e0c2a6f3cc24b93de" translate="yes" xml:space="preserve">
          <source>Additional resources</source>
          <target state="translated">补充资源</target>
        </trans-unit>
        <trans-unit id="fa4703ed512a421e9e9ab95be1747cd7af75bcd9" translate="yes" xml:space="preserve">
          <source>Additionally adds the enclosed text to the index as a term. Since we are interested in different instances of the same term to have different entries, a table is used to keep track of the amount of times a term has previously appeared to give a different identifier value for each.</source>
          <target state="translated">另外将所附的文本作为一个术语添加到索引中。由于我们对同一术语的不同实例有不同的条目感兴趣,所以用一个表来跟踪一个术语以前出现的次数,以便为每个术语给出不同的标识符值。</target>
        </trans-unit>
        <trans-unit id="683593bbc9f4d0095e1a329b2a170a4f6b64749a" translate="yes" xml:space="preserve">
          <source>Additionally adds the encosed text to the index as a term. Since we are interested in different instances of the same term to have different entries, a table is used to keep track of the amount of times a term has previously appeared to give a different identifier value for each.</source>
          <target state="translated">另外将封装的文本作为一个术语添加到索引中。由于我们对同一术语的不同实例有不同的条目感兴趣,所以用一个表来跟踪一个术语以前出现的次数,以便为每个术语给出不同的标识符值。</target>
        </trans-unit>
        <trans-unit id="83025bdbec6a244fe913cb7d0ff67dac39e81e46" translate="yes" xml:space="preserve">
          <source>Additionally, you may pass a value along with the symbol: &lt;code&gt;-d:x=y&lt;/code&gt; which may be used in conjunction with the &lt;a href=&quot;manual#implementation-specific-pragmas-compile-time-define-pragmas&quot;&gt;compile time define pragmas&lt;/a&gt; to override symbols during build time.</source>
          <target state="translated">此外，您可以将值与符号一起传递： &lt;code&gt;-d:x=y&lt;/code&gt; ，可以将其与&lt;a href=&quot;manual#implementation-specific-pragmas-compile-time-define-pragmas&quot;&gt;编译时定义编译指示&lt;/a&gt;结合使用，以在构建期间覆盖符号。</target>
        </trans-unit>
        <trans-unit id="dad02ecd7c3a4cabf030c764e9da2c30f5fe41ab" translate="yes" xml:space="preserve">
          <source>Additionally, you may pass a value along with the symbol: &lt;code&gt;-d:x=y&lt;/code&gt; which may be used in conjunction with the &lt;a href=&quot;manual#implementation-specific-pragmas-compileminustime-define-pragmas&quot;&gt;compile-time define pragmas&lt;/a&gt; to override symbols during build time.</source>
          <target state="translated">此外，您可以将值与符号一起传递： &lt;code&gt;-d:x=y&lt;/code&gt; ，可以将其与&lt;a href=&quot;manual#implementation-specific-pragmas-compileminustime-define-pragmas&quot;&gt;编译时定义编译指示&lt;/a&gt;结合使用，以在构建期间覆盖符号。</target>
        </trans-unit>
        <trans-unit id="c9cc91072a9c61406bb688685c655da8fcf1e11e" translate="yes" xml:space="preserve">
          <source>Addr operator</source>
          <target state="translated">地址运营商</target>
        </trans-unit>
        <trans-unit id="e6513e72133cdea4324350e6d4ade50552f0fa2a" translate="yes" xml:space="preserve">
          <source>Adds &lt;code&gt;arg&lt;/code&gt; as a &lt;code&gt;Node&lt;/code&gt; to the &lt;code&gt;NList&lt;/code&gt; If a node with the same name is already present in this map, it is replaced by the new one.</source>
          <target state="translated">将 &lt;code&gt;arg&lt;/code&gt; 作为 &lt;code&gt;Node&lt;/code&gt; 添加到 &lt;code&gt;NList&lt;/code&gt; 如果此映射中已经存在具有相同名称的节点，则将其替换为新的节点。</target>
        </trans-unit>
        <trans-unit id="3ccd506aab4757f17ef51ce2016ba1b428279190" translate="yes" xml:space="preserve">
          <source>Adds &lt;code&gt;b&lt;/code&gt; to the rope &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">将 &lt;code&gt;b&lt;/code&gt; 添加到绳索 &lt;code&gt;a&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="9cc159ea3eeee439600098843b572bf5bf9add55" translate="yes" xml:space="preserve">
          <source>Adds &lt;code&gt;child&lt;/code&gt; to a JArray node &lt;code&gt;father&lt;/code&gt;.</source>
          <target state="translated">将 &lt;code&gt;child&lt;/code&gt; 添加到JArray节点 &lt;code&gt;father&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c0973ea96bcd93e616194aea6ada7ee253f95770" translate="yes" xml:space="preserve">
          <source>Adds &lt;code&gt;handler&lt;/code&gt; to the list of handlers.</source>
          <target state="translated">将 &lt;code&gt;handler&lt;/code&gt; 添加到处理程序列表中。</target>
        </trans-unit>
        <trans-unit id="09af7b91c6e7df51cd37d298bdc37f650d040831" translate="yes" xml:space="preserve">
          <source>Adds &lt;code&gt;interval&lt;/code&gt; to &lt;code&gt;dt&lt;/code&gt;. Components from &lt;code&gt;interval&lt;/code&gt; are added in the order of their size, i.e first the &lt;code&gt;years&lt;/code&gt; component, then the &lt;code&gt;months&lt;/code&gt; component and so on. The returned &lt;code&gt;DateTime&lt;/code&gt; will have the same timezone as the input.</source>
          <target state="translated">将 &lt;code&gt;interval&lt;/code&gt; 添加到 &lt;code&gt;dt&lt;/code&gt; 。来自 &lt;code&gt;interval&lt;/code&gt; 分量按其大小顺序添加，即首先是 &lt;code&gt;years&lt;/code&gt; 分量，然后是 &lt;code&gt;months&lt;/code&gt; 分量，依此类推。返回的 &lt;code&gt;DateTime&lt;/code&gt; 将具有与输入相同的时区。</target>
        </trans-unit>
        <trans-unit id="ba0aaaa96c74c1cea684996ea930d05d8a0077c9" translate="yes" xml:space="preserve">
          <source>Adds &lt;code&gt;interval&lt;/code&gt; to &lt;code&gt;dt&lt;/code&gt;. Components from &lt;code&gt;interval&lt;/code&gt; are added in the order of their size, i.e. first the &lt;code&gt;years&lt;/code&gt; component, then the &lt;code&gt;months&lt;/code&gt; component and so on. The returned &lt;code&gt;DateTime&lt;/code&gt; will have the same timezone as the input.</source>
          <target state="translated">将 &lt;code&gt;interval&lt;/code&gt; 添加到 &lt;code&gt;dt&lt;/code&gt; 。来自 &lt;code&gt;interval&lt;/code&gt; 分量按其大小顺序添加，即首先是 &lt;code&gt;years&lt;/code&gt; 分量，然后是 &lt;code&gt;months&lt;/code&gt; 分量，依此类推。返回的 &lt;code&gt;DateTime&lt;/code&gt; 将具有与输入相同的时区。</target>
        </trans-unit>
        <trans-unit id="18926f976110c5ffe1e4f4c98001f1d15ef90526" translate="yes" xml:space="preserve">
          <source>Adds &lt;code&gt;interval&lt;/code&gt; to &lt;code&gt;time&lt;/code&gt;. If &lt;code&gt;interval&lt;/code&gt; contains any years, months, weeks or days the operation is performed in the local timezone.</source>
          <target state="translated">添加 &lt;code&gt;interval&lt;/code&gt; 到 &lt;code&gt;time&lt;/code&gt; 。如果 &lt;code&gt;interval&lt;/code&gt; 包含任何年，月，周或天，则在本地时区执行操作。</target>
        </trans-unit>
        <trans-unit id="b3703e66f4731d1cd49994e51655ed816fcd0462" translate="yes" xml:space="preserve">
          <source>Adds &lt;code&gt;mimetype&lt;/code&gt; to the &lt;code&gt;mimedb&lt;/code&gt;.</source>
          <target state="translated">添加 &lt;code&gt;mimetype&lt;/code&gt; 的 &lt;code&gt;mimedb&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="68ab57cbe5dd2927ab80b8168f0ae9bf78358be1" translate="yes" xml:space="preserve">
          <source>Adds &lt;code&gt;mimetype&lt;/code&gt; to the &lt;code&gt;mimedb&lt;/code&gt;. &lt;code&gt;mimetype&lt;/code&gt; and &lt;code&gt;ext&lt;/code&gt; are lowercased before registering on &lt;code&gt;mimedb&lt;/code&gt;.</source>
          <target state="translated">将 &lt;code&gt;mimetype&lt;/code&gt; 添加到 &lt;code&gt;mimedb&lt;/code&gt; 。在 &lt;code&gt;mimedb&lt;/code&gt; 上注册之前， &lt;code&gt;mimetype&lt;/code&gt; 和 &lt;code&gt;ext&lt;/code&gt; 是小写的。</target>
        </trans-unit>
        <trans-unit id="d55bd8510c4909907c3b0b1b51f22ef8bfe1dc23" translate="yes" xml:space="preserve">
          <source>Adds &lt;code&gt;y&lt;/code&gt; to &lt;code&gt;x&lt;/code&gt; unless &lt;code&gt;x&lt;/code&gt; is not yet initalized; in that case, &lt;code&gt;x&lt;/code&gt; becomes &lt;code&gt;y&lt;/code&gt;</source>
          <target state="translated">除非 &lt;code&gt;x&lt;/code&gt; 尚未初始化，否则将 &lt;code&gt;y&lt;/code&gt; 加到 &lt;code&gt;x&lt;/code&gt; 上；在这种情况下， &lt;code&gt;x&lt;/code&gt; 变成 &lt;code&gt;y&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="08dd7691271b1b3cf31cdaad9abf0dd1ed892c5b" translate="yes" xml:space="preserve">
          <source>Adds &lt;code&gt;y&lt;/code&gt; to &lt;code&gt;x&lt;/code&gt; unless &lt;code&gt;x&lt;/code&gt; is not yet initialized; in that case, &lt;code&gt;x&lt;/code&gt; becomes &lt;code&gt;@[y]&lt;/code&gt;</source>
          <target state="translated">除非 &lt;code&gt;x&lt;/code&gt; 尚未初始化，否则将 &lt;code&gt;y&lt;/code&gt; 加到 &lt;code&gt;x&lt;/code&gt; 上；在这种情况下， &lt;code&gt;x&lt;/code&gt; 变成 &lt;code&gt;@[y]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="627474e018ec81cf49c8143b28ab86561ce7ccef" translate="yes" xml:space="preserve">
          <source>Adds &lt;code&gt;y&lt;/code&gt; to &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">将 &lt;code&gt;y&lt;/code&gt; 加到 &lt;code&gt;x&lt;/code&gt; 上。</target>
        </trans-unit>
        <trans-unit id="910ee17a6a799e67a937708e73b9aedb33f3b0aa" translate="yes" xml:space="preserve">
          <source>Adds &lt;code&gt;y&lt;/code&gt; to &lt;code&gt;x&lt;/code&gt;. If &lt;code&gt;x&lt;/code&gt; is &lt;code&gt;nil&lt;/code&gt; it is initialized to &lt;code&gt;&quot;&quot;&lt;/code&gt;</source>
          <target state="translated">将 &lt;code&gt;y&lt;/code&gt; 加到 &lt;code&gt;x&lt;/code&gt; 上。如果 &lt;code&gt;x&lt;/code&gt; 是 &lt;code&gt;nil&lt;/code&gt; 它被初始化为 &lt;code&gt;&quot;&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f4d013d42946fcbe3af0f01b7362386e1eb7f928" translate="yes" xml:space="preserve">
          <source>Adds &lt;em&gt;child&lt;/em&gt; to a JArray node &lt;em&gt;father&lt;/em&gt;.</source>
          <target state="translated">将&lt;em&gt;子项&lt;/em&gt;添加到JArray节点&lt;em&gt;父亲&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="277d7264e0b31954fb3f91658c21ef53fbc9f98b" translate="yes" xml:space="preserve">
          <source>Adds &lt;em&gt;child&lt;/em&gt; to a SList node &lt;em&gt;father&lt;/em&gt;.</source>
          <target state="translated">将&lt;em&gt;子级&lt;/em&gt;添加到SList节点&lt;em&gt;父亲&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="282a03494ac60232eca16c10011aa2a3e77244c0" translate="yes" xml:space="preserve">
          <source>Adds &lt;em&gt;interval&lt;/em&gt; to &lt;em&gt;time&lt;/em&gt;. If &lt;em&gt;interval&lt;/em&gt; contains any years, months, weeks or days the operation is performed in the local timezone.</source>
          <target state="translated">添加&lt;em&gt;间隔&lt;/em&gt;到&lt;em&gt;时&lt;/em&gt;。如果&lt;em&gt;间隔&lt;/em&gt;包含任何年，月，周或天，则在当地时区执行操作。</target>
        </trans-unit>
        <trans-unit id="50a3a76c2750845cf7f87e40704907335f25674d" translate="yes" xml:space="preserve">
          <source>Adds a &lt;code&gt;term&lt;/code&gt; to the index using the specified hyperlink identifier.</source>
          <target state="translated">使用指定的超链接标识符将 &lt;code&gt;term&lt;/code&gt; 添加到索引。</target>
        </trans-unit>
        <trans-unit id="168959e8e3da827112e6480f035af90769452610" translate="yes" xml:space="preserve">
          <source>Adds a &lt;em&gt;term&lt;/em&gt; to the index using the specified hyperlink identifier.</source>
          <target state="translated">使用指定的超链接标识符将&lt;em&gt;术语&lt;/em&gt;添加到索引。</target>
        </trans-unit>
        <trans-unit id="8e1762576390fbc36fed4423af342fdafc7b01f4" translate="yes" xml:space="preserve">
          <source>Adds a char to string &lt;code&gt;s&lt;/code&gt; and applies the following escaping:</source>
          <target state="translated">向字符串 &lt;code&gt;s&lt;/code&gt; 添加一个char并应用以下转义：</target>
        </trans-unit>
        <trans-unit id="46517870669c98767730789efc1c2a63afe0fd37" translate="yes" xml:space="preserve">
          <source>Adds a char to string &lt;em&gt;s&lt;/em&gt; and applies the following escaping:</source>
          <target state="translated">向字符串&lt;em&gt;s&lt;/em&gt;添加一个char 并应用以下转义：</target>
        </trans-unit>
        <trans-unit id="a165d6cb7b186d7181d788e17f736e5c34a3bc93" translate="yes" xml:space="preserve">
          <source>Adds a complex number to a real number.</source>
          <target state="translated">将复数加到实数上。</target>
        </trans-unit>
        <trans-unit id="827e14fb735a5d5b595e3196ad328aaf6dce5348" translate="yes" xml:space="preserve">
          <source>Adds a logger to the list of registered handlers.</source>
          <target state="translated">将记录器添加到注册处理程序列表中。</target>
        </trans-unit>
        <trans-unit id="1f8aac4240d0d2f3105af4d844dbcb2abbdecf97" translate="yes" xml:space="preserve">
          <source>Adds a new attribute node, if an attribute with the localName and namespaceURI of &lt;code&gt;newAttr&lt;/code&gt; is present, it is replaced by the new one and the replaced attribute is returned, otherwise &lt;code&gt;nil&lt;/code&gt; is returned.</source>
          <target state="translated">添加一个新的属性节点，如果存在具有 &lt;code&gt;newAttr&lt;/code&gt; 的localName和namespaceURI的属性，则将其替换为新属性节点，并返回被替换的属性，否则返回 &lt;code&gt;nil&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="49966f2ea34f557267d410935160fd5454f498db" translate="yes" xml:space="preserve">
          <source>Adds a new attribute node, if an attribute with the same &lt;em&gt;nodeName&lt;/em&gt; is present, it is replaced by the new one and the replaced attribute is returned, otherwise &lt;code&gt;nil&lt;/code&gt; is returned.</source>
          <target state="translated">添加一个新的属性节点，如果存在具有相同&lt;em&gt;nodeName&lt;/em&gt;的属性，则将其替换为新属性节点，并返回被替换的属性，否则返回 &lt;code&gt;nil&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8d941c7f90a962f0302be00a817bf48658be8c09" translate="yes" xml:space="preserve">
          <source>Adds a new attribute, as specified by &lt;code&gt;name&lt;/code&gt; and &lt;code&gt;value&lt;/code&gt; If an attribute with that name is already present in the element, its value is changed to be that of the value parameter Raises the EInvalidCharacterErr if the specified &lt;code&gt;name&lt;/code&gt; contains illegal characters</source>
          <target state="translated">添加由 &lt;code&gt;name&lt;/code&gt; 和 &lt;code&gt;value&lt;/code&gt; 指定的新属性如果元素中已经存在具有该名称的属性，则其值将更改为value参数的值。如果指定的 &lt;code&gt;name&lt;/code&gt; 包含非法字符，则引发EInvalidCharacterErr</target>
        </trans-unit>
        <trans-unit id="70b9921234cbd8dc467e865419512e1db5aa80e1" translate="yes" xml:space="preserve">
          <source>Adds a new attribute, as specified by &lt;code&gt;namespaceURI&lt;/code&gt;, &lt;code&gt;localName&lt;/code&gt; and &lt;code&gt;value&lt;/code&gt;.</source>
          <target state="translated">添加一个新的属性，如 &lt;code&gt;namespaceURI&lt;/code&gt; ， &lt;code&gt;localName&lt;/code&gt; 和 &lt;code&gt;value&lt;/code&gt; 所指定。</target>
        </trans-unit>
        <trans-unit id="175780a3fa3d64a9dc7aa37e3d80ca0adc76b294" translate="yes" xml:space="preserve">
          <source>Adds a node using its &lt;code&gt;namespaceURI&lt;/code&gt; and &lt;code&gt;localName&lt;/code&gt;</source>
          <target state="translated">使用其 &lt;code&gt;namespaceURI&lt;/code&gt; 和 &lt;code&gt;localName&lt;/code&gt; 添加节点</target>
        </trans-unit>
        <trans-unit id="445dea116e47b26077f13f1c8b729d6b93e3f403" translate="yes" xml:space="preserve">
          <source>Adds a real number to a complex number.</source>
          <target state="translated">将一个实数加到一个复数上。</target>
        </trans-unit>
        <trans-unit id="cd52d911dfccd80297cfd1bc6c1ca03cb53214c3" translate="yes" xml:space="preserve">
          <source>Adds a rune &lt;code&gt;c&lt;/code&gt; to a string &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">将符文 &lt;code&gt;c&lt;/code&gt; 添加到字符串 &lt;code&gt;s&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="d25b62bec6486d33ddc3794772773f41d17aed10" translate="yes" xml:space="preserve">
          <source>Adds a separator to &lt;code&gt;dest&lt;/code&gt; only if its length is bigger than &lt;code&gt;startLen&lt;/code&gt;.</source>
          <target state="translated">仅当分隔符的长度大于 &lt;code&gt;startLen&lt;/code&gt; 时,才将分隔符添加到 &lt;code&gt;dest&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="71b9366e5b895a616623ffad66668f7f54484c12" translate="yes" xml:space="preserve">
          <source>Adds a separator to &lt;em&gt;dest&lt;/em&gt; only if its length is bigger than &lt;em&gt;startLen&lt;/em&gt;.</source>
          <target state="translated">仅当其长度大于&lt;em&gt;startLen时，&lt;/em&gt;才将分隔符添加到&lt;em&gt;dest中&lt;/em&gt;。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9d30fd10baf4621b3f993d8f268f3318fa55aa89" translate="yes" xml:space="preserve">
          <source>Adds an &lt;code&gt;item&lt;/code&gt; to the beginning of the &lt;code&gt;deq&lt;/code&gt;.</source>
          <target state="translated">在 &lt;code&gt;deq&lt;/code&gt; 的开头添加一个 &lt;code&gt;item&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ee7abee7fa26cb127bb76dc8029b992785bf6db7" translate="yes" xml:space="preserve">
          <source>Adds an &lt;code&gt;item&lt;/code&gt; to the end of the &lt;code&gt;deq&lt;/code&gt;.</source>
          <target state="translated">在 &lt;code&gt;deq&lt;/code&gt; 的末尾添加一个 &lt;code&gt;item&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ee4ae4071a72fe5abb9dd7a95222ae4b3f3aedff" translate="yes" xml:space="preserve">
          <source>Adds each child of &lt;code&gt;children&lt;/code&gt; to the &lt;code&gt;father&lt;/code&gt; node. Returns the &lt;code&gt;father&lt;/code&gt; node so that calls can be nested.</source>
          <target state="translated">每个孩子增加 &lt;code&gt;children&lt;/code&gt; 的 &lt;code&gt;father&lt;/code&gt; 节点。返回 &lt;code&gt;father&lt;/code&gt; 节点，以便可以嵌套调用。</target>
        </trans-unit>
        <trans-unit id="719fea5dd090dc5f35241a78b628149a3f6e753c" translate="yes" xml:space="preserve">
          <source>Adds each child of &lt;em&gt;children&lt;/em&gt; to the &lt;em&gt;father&lt;/em&gt; node. Returns the &lt;em&gt;father&lt;/em&gt; node so that calls can be nested.</source>
          <target state="translated">每个孩子增加&lt;em&gt;孩子&lt;/em&gt;的&lt;em&gt;父亲&lt;/em&gt;节点。返回&lt;em&gt;父&lt;/em&gt;节点，以便可以嵌套调用。</target>
        </trans-unit>
        <trans-unit id="77594e2b861c1fa8f8e68498df51e03371d37a9b" translate="yes" xml:space="preserve">
          <source>Adds pragma to routine definition</source>
          <target state="translated">在例程定义中添加pragma。</target>
        </trans-unit>
        <trans-unit id="22ef025c8852052c63014722234d4f7dac516082" translate="yes" xml:space="preserve">
          <source>Adds pragma to routine definition.</source>
          <target state="translated">在例程定义中添加pragma。</target>
        </trans-unit>
        <trans-unit id="cc8d34a8c593fa5ef656e634dd29a0f526f1bbcb" translate="yes" xml:space="preserve">
          <source>Adds the &lt;code&gt;child&lt;/code&gt; to the &lt;code&gt;father&lt;/code&gt; node. Returns the father node so that calls can be nested.</source>
          <target state="translated">将 &lt;code&gt;child&lt;/code&gt; 添加到 &lt;code&gt;father&lt;/code&gt; 节点。返回父节点，以便可以嵌套调用。</target>
        </trans-unit>
        <trans-unit id="392b56977e8236b6698f4ca58ac6c2f28d25c68f" translate="yes" xml:space="preserve">
          <source>Adds the &lt;em&gt;child&lt;/em&gt; to the &lt;em&gt;father&lt;/em&gt; node. Returns the father node so that calls can be nested.</source>
          <target state="translated">将&lt;em&gt;子级&lt;/em&gt;添加到&lt;em&gt;父级&lt;/em&gt;节点。返回父节点，以便可以嵌套调用。</target>
        </trans-unit>
        <trans-unit id="4be1f166b02d308f1b99389ad08b9ecee806fca1" translate="yes" xml:space="preserve">
          <source>Adds the callbacks proc to be called when the future completes.</source>
          <target state="translated">增加了未来完成时调用的回调proc。</target>
        </trans-unit>
        <trans-unit id="b7b6993ff7221b5e90540fdce800099548168a68" translate="yes" xml:space="preserve">
          <source>Adds the child &lt;code&gt;son&lt;/code&gt; to &lt;code&gt;father&lt;/code&gt;.</source>
          <target state="translated">把孩子的 &lt;code&gt;son&lt;/code&gt; 为 &lt;code&gt;father&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dbc36a9f78ad151e4f4390f8743161fab423645f" translate="yes" xml:space="preserve">
          <source>Adds the file extension &lt;code&gt;ext&lt;/code&gt; to &lt;code&gt;filename&lt;/code&gt;, unless &lt;code&gt;filename&lt;/code&gt; already has an extension.</source>
          <target state="translated">将文件扩展名 &lt;code&gt;ext&lt;/code&gt; 添加到 &lt;code&gt;filename&lt;/code&gt; ，除非 &lt;code&gt;filename&lt;/code&gt; 已经具有扩展名。</target>
        </trans-unit>
        <trans-unit id="087cbeb9fcc85f71b469524d8a7510230c6f6abc" translate="yes" xml:space="preserve">
          <source>Adds the file extension &lt;em&gt;ext&lt;/em&gt; to &lt;em&gt;filename&lt;/em&gt;, unless &lt;em&gt;filename&lt;/em&gt; already has an extension.</source>
          <target state="translated">将文件扩展名&lt;em&gt;ext&lt;/em&gt;添加到&lt;em&gt;filename&lt;/em&gt;，除非&lt;em&gt;filename&lt;/em&gt;已经具有扩展名。</target>
        </trans-unit>
        <trans-unit id="38e43d237023eab5acc2b848d42530e464a0a37f" translate="yes" xml:space="preserve">
          <source>Adds the node newChild to the end of the list of children of this node. If the newChild is already in the tree, it is first removed.</source>
          <target state="translated">将节点newChild添加到这个节点的子节点列表的最后。如果newChild已经在树中,则先将其删除。</target>
        </trans-unit>
        <trans-unit id="2a72a2ff357c75992d2d25db54f40e31c444189e" translate="yes" xml:space="preserve">
          <source>Adds the specified value to the specified key. Appends to any existing values associated with the key.</source>
          <target state="translated">将指定的值添加到指定的键中。将指定的值添加到与键相关联的任何现有值中。</target>
        </trans-unit>
        <trans-unit id="8dfc81b4ba54feaa93081bccdec5f9016c933c3e" translate="yes" xml:space="preserve">
          <source>Adds the textual representation of &lt;code&gt;n&lt;/code&gt; to string &lt;code&gt;result&lt;/code&gt;.</source>
          <target state="translated">将 &lt;code&gt;n&lt;/code&gt; 的文本表示形式添加到字符串 &lt;code&gt;result&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dcb76173f8b3f736f04cf7a85a76442e3061c9f2" translate="yes" xml:space="preserve">
          <source>Adds two &lt;code&gt;TimeInterval&lt;/code&gt; objects together.</source>
          <target state="translated">将两个 &lt;code&gt;TimeInterval&lt;/code&gt; 对象添加在一起。</target>
        </trans-unit>
        <trans-unit id="f072b38e848ec11710252f90b744bfddeaabbd97" translate="yes" xml:space="preserve">
          <source>Adds two colors.</source>
          <target state="translated">增加了两种颜色。</target>
        </trans-unit>
        <trans-unit id="31c598fdad0049851912b65e101e0082a5d1544c" translate="yes" xml:space="preserve">
          <source>Adds two complex numbers.</source>
          <target state="translated">加两个复数。</target>
        </trans-unit>
        <trans-unit id="0cd028f03aa8100d6b3d714eae3d5348fe823a2f" translate="yes" xml:space="preserve">
          <source>Adds/registers a quit procedure.</source>
          <target state="translated">添加/注册一个退出程序。</target>
        </trans-unit>
        <trans-unit id="a371aa854f23fe7005ac2c85dbb7004b42d9769b" translate="yes" xml:space="preserve">
          <source>Adds/registers a quit procedure. Each call to &lt;code&gt;addExitProc&lt;/code&gt; registers another quit procedure. They are executed on a last-in, first-out basis.</source>
          <target state="translated">添加/注册退出程序。每个对 &lt;code&gt;addExitProc&lt;/code&gt; 的调用都会注册另一个退出过程。它们以后进先出的方式执行。</target>
        </trans-unit>
        <trans-unit id="5090ef07df2944062324712ca6950298e056c7f1" translate="yes" xml:space="preserve">
          <source>Adopting type for gui inspector in a game engine:</source>
          <target state="translated">在游戏引擎中采用gui检查器的类型。</target>
        </trans-unit>
        <trans-unit id="cd58779782de2792380285200da5a98425f86d02" translate="yes" xml:space="preserve">
          <source>Advanced command line switches are:</source>
          <target state="translated">高级命令行开关是:</target>
        </trans-unit>
        <trans-unit id="b6c601805a77e86b61625eba41bd959b73c2bb59" translate="yes" xml:space="preserve">
          <source>Advanced command-line switches are:</source>
          <target state="translated">高级命令行开关是。</target>
        </trans-unit>
        <trans-unit id="7a3a43835953e413f721f837036117df744dbd00" translate="yes" xml:space="preserve">
          <source>Advanced commands:</source>
          <target state="translated">高级命令。</target>
        </trans-unit>
        <trans-unit id="21604196a5b5f020863aebeb14786b98a2ec02e1" translate="yes" xml:space="preserve">
          <source>Advanced options:</source>
          <target state="translated">高级选项。</target>
        </trans-unit>
        <trans-unit id="f1c748b61ceca05da788dea58f761592f09389bc" translate="yes" xml:space="preserve">
          <source>Advanced types</source>
          <target state="translated">高级类型</target>
        </trans-unit>
        <trans-unit id="4eaa54faaeebcdcf16ca6cecc39180523a7c29ea" translate="yes" xml:space="preserve">
          <source>After &lt;code&gt;\0&lt;/code&gt; up to two further octal digits are read. In both cases, if there are fewer than two digits, just those that are present are used. Thus the sequence &lt;code&gt;\0\x\07&lt;/code&gt; specifies two binary zeros followed by a BEL character (code value 7). Make sure you supply two digits after the initial zero if the pattern character that follows is itself an octal digit.</source>
          <target state="translated">之后 &lt;code&gt;\0&lt;/code&gt; 最多两个八进制数字被读取。在这两种情况下，如果少于两位数，则仅使用存在的那些。因此，序列 &lt;code&gt;\0\x\07&lt;/code&gt; 指定两个二进制零，后跟一个BEL字符（代码值7）。如果后面的图案字符本身是八进制数字，请确保在初始零之后提供两位数字。</target>
        </trans-unit>
        <trans-unit id="c71390a639ed6627641b3cfd1f9a329a5cc9c625" translate="yes" xml:space="preserve">
          <source>After &lt;code&gt;\x&lt;/code&gt;, from zero to two hexadecimal digits are read (letters can be in upper or lower case). In UTF-8 mode, any number of hexadecimal digits may appear between &lt;code&gt;\x{&lt;/code&gt; and &lt;code&gt;}&lt;/code&gt;, but the value of the character code must be less than 2**31 (that is, the maximum hexadecimal value is 7FFFFFFF). If characters other than hexadecimal digits appear between &lt;code&gt;\x{&lt;/code&gt; and &lt;code&gt;}&lt;/code&gt;, or if there is no terminating &lt;code&gt;}&lt;/code&gt;, this form of escape is not recognized. Instead, the initial &lt;code&gt;\x&lt;/code&gt; will be interpreted as a basic hexadecimal escape, with no following digits, giving a character whose value is zero.</source>
          <target state="translated">在 &lt;code&gt;\x&lt;/code&gt; ，读取从零到两个十六进制数字（字母可以大写或小写）。在UTF-8模式下， &lt;code&gt;\x{&lt;/code&gt; 和 &lt;code&gt;}&lt;/code&gt; 之间可以出现任意数量的十六进制数字，但是字符代码的值必须小于2 ** 31（即，最大十六进制值为7FFFFFFF）。如果 &lt;code&gt;\x{&lt;/code&gt; 和 &lt;code&gt;}&lt;/code&gt; 之间出现十六进制数字以外的字符，或者没有终止符 &lt;code&gt;}&lt;/code&gt; ，则无法识别这种转义形式。取而代之的是，初始 &lt;code&gt;\x&lt;/code&gt; 将被解释为基本的十六进制转义符，没有后续数字，从而给出一个值为零的字符。</target>
        </trans-unit>
        <trans-unit id="622cf30c89947b71767229b80f2f6c86dfa76768" translate="yes" xml:space="preserve">
          <source>After a connection is made you can use the &lt;code&gt;store&lt;/code&gt; procedure to upload a new file to the FTP server. Make sure to check you are in the correct working directory before you do so with the &lt;code&gt;pwd&lt;/code&gt; procedure, you can also instead specify an absolute path.</source>
          <target state="translated">建立连接后，您可以使用 &lt;code&gt;store&lt;/code&gt; 过程将新文件上传到FTP服务器。使用 &lt;code&gt;pwd&lt;/code&gt; 过程进行操作之前，请确保检查您是否位于正确的工作目录中，也可以指定绝对路径。</target>
        </trans-unit>
        <trans-unit id="7520b5bf7b6ddd9d8aee836c25d8c005e080b0bf" translate="yes" xml:space="preserve">
          <source>After an initial build via &lt;code&gt;sh build_all.sh&lt;/code&gt; on posix or &lt;code&gt;build_all.bat&lt;/code&gt; on windows, you can rebuild the compiler as follows:</source>
          <target state="translated">通过posix上的 &lt;code&gt;sh build_all.sh&lt;/code&gt; 或 &lt;code&gt;build_all.bat&lt;/code&gt; 上的build_all.bat进行初始构建后，可以按以下方式重建编译器：</target>
        </trans-unit>
        <trans-unit id="f73d43ab167cd4ac21b418e91451904852662e79" translate="yes" xml:space="preserve">
          <source>After compilation is finished you will hopefully end up with the nim compiler in the &lt;code&gt;bin&lt;/code&gt; directory. You can add Nim's &lt;code&gt;bin&lt;/code&gt; directory to your &lt;code&gt;$PATH&lt;/code&gt; or use the &lt;a href=&quot;#install-command&quot;&gt;install command&lt;/a&gt; to place it where it will be found.</source>
          <target state="translated">编译完成后，您希望可以在 &lt;code&gt;bin&lt;/code&gt; 目录中使用nim编译器。您可以将Nim的 &lt;code&gt;bin&lt;/code&gt; 目录添加到 &lt;code&gt;$PATH&lt;/code&gt; 或使用&lt;a href=&quot;#install-command&quot;&gt;install命令&lt;/a&gt;将其放置在将其找到的位置。</target>
        </trans-unit>
        <trans-unit id="b98934419b5d22ede24344e6f44c8aa22099b672" translate="yes" xml:space="preserve">
          <source>After compilation is finished you will hopefully end up with the nim compiler in the &lt;code&gt;bin&lt;/code&gt; directory. You can add Nim's &lt;code&gt;bin&lt;/code&gt; directory to your &lt;code&gt;$PATH&lt;/code&gt; or use the install command to place it where it will be found.</source>
          <target state="translated">编译完成后，您希望可以在 &lt;code&gt;bin&lt;/code&gt; 目录中使用nim编译器。您可以将Nim的 &lt;code&gt;bin&lt;/code&gt; 目录添加到 &lt;code&gt;$PATH&lt;/code&gt; 或使用install命令将其放置在将其找到的位置。</target>
        </trans-unit>
        <trans-unit id="6b90d285522bd240c9268803fc6cb7830c0b81db" translate="yes" xml:space="preserve">
          <source>After doing this, use either the &lt;a href=&quot;#log.t,Level,varargs%5Bstring,%5D&quot;&gt;log template&lt;/a&gt; or one of the level-specific templates, such as the &lt;a href=&quot;#error.t,varargs%5Bstring,%5D&quot;&gt;error template&lt;/a&gt;, to log messages to all registered handlers at once.</source>
          <target state="translated">完成此操作后，使用&lt;a href=&quot;#log.t,Level,varargs%5Bstring,%5D&quot;&gt;日志模板&lt;/a&gt;或特定于级别的模板之一（例如&lt;a href=&quot;#error.t,varargs%5Bstring,%5D&quot;&gt;错误模板&lt;/a&gt;）一次将消息记录到所有已注册的处理程序。</target>
        </trans-unit>
        <trans-unit id="7e10a07a137ad912e35e4faef7ca70acb747eef5" translate="yes" xml:space="preserve">
          <source>After the &lt;code&gt;from&lt;/code&gt; statement a module name follows followed by an &lt;code&gt;import&lt;/code&gt; to list the symbols one likes to use without explicit full qualification:</source>
          <target state="translated">在 &lt;code&gt;from&lt;/code&gt; 语句之后，模块名称后跟一个 &lt;code&gt;import&lt;/code&gt; 以列出无需显式完全限定就可以使用的符号：</target>
        </trans-unit>
        <trans-unit id="cac28c3a1b2e93e9b8fde6caccc0941a6a14a30c" translate="yes" xml:space="preserve">
          <source>After the &lt;code&gt;from&lt;/code&gt; statement, a module name follows followed by an &lt;code&gt;import&lt;/code&gt; to list the symbols one likes to use without explicit full qualification:</source>
          <target state="translated">在 &lt;code&gt;from&lt;/code&gt; 语句之后，模块名称后跟一个 &lt;code&gt;import&lt;/code&gt; 以列出无需显式完全限定就可以使用的符号：</target>
        </trans-unit>
        <trans-unit id="4f797b80df1f8d64852f55b778851d191514b53d" translate="yes" xml:space="preserve">
          <source>After the &lt;code&gt;import&lt;/code&gt; statement a list of module names can follow or a single module name followed by an &lt;code&gt;except&lt;/code&gt; list to prevent some symbols to be imported:</source>
          <target state="translated">在 &lt;code&gt;import&lt;/code&gt; 语句之后，可以跟随一个模块名称列表，或者紧跟一个模块名称列表，然后是一个 &lt;code&gt;except&lt;/code&gt; 列表，以防止导入某些符号：</target>
        </trans-unit>
        <trans-unit id="ee8f6842719daac0ef2d06cdb2e7fa5bd3d11c84" translate="yes" xml:space="preserve">
          <source>After the execution of &lt;code&gt;handleRequest&lt;/code&gt; the client socket will be closed automatically unless it has already been closed.</source>
          <target state="translated">执行 &lt;code&gt;handleRequest&lt;/code&gt; 之后，除非已关闭客户端套接字，否则它将自动关闭。</target>
        </trans-unit>
        <trans-unit id="cf6dcadff9cc79e46d3555b76c916fb3ed022d34" translate="yes" xml:space="preserve">
          <source>After you add &lt;code&gt;hash&lt;/code&gt; and &lt;code&gt;==&lt;/code&gt; for your custom type everything will work. Currently however &lt;code&gt;hash&lt;/code&gt; for objects is not defined, whereas &lt;code&gt;system.==&lt;/code&gt; for objects does exist and performs a &quot;deep&quot; comparison (every field is compared) which is usually what you want. So in the following example implementing only &lt;code&gt;hash&lt;/code&gt; suffices:</source>
          <target state="translated">在为您的自定义类型添加 &lt;code&gt;hash&lt;/code&gt; 和 &lt;code&gt;==&lt;/code&gt; 之后，所有内容都将起作用。但是，当前没有定义对象的 &lt;code&gt;hash&lt;/code&gt; ，而确实存在对象的 &lt;code&gt;system.==&lt;/code&gt; 并执行通常想要的&amp;ldquo;深度&amp;rdquo;比较（比较每个字段）。因此，在下面的示例中，仅实现 &lt;code&gt;hash&lt;/code&gt; 就足够了：</target>
        </trans-unit>
        <trans-unit id="8cc281a6f4ada76b68a3f2185149f5df48ef5084" translate="yes" xml:space="preserve">
          <source>After you add &lt;code&gt;hash&lt;/code&gt; and &lt;code&gt;==&lt;/code&gt; for your custom type everything will work. Currently, however, &lt;code&gt;hash&lt;/code&gt; for objects is not defined, whereas &lt;code&gt;system.==&lt;/code&gt; for objects does exist and performs a &quot;deep&quot; comparison (every field is compared) which is usually what you want. So in the following example implementing only &lt;code&gt;hash&lt;/code&gt; suffices:</source>
          <target state="translated">在为您的自定义类型添加 &lt;code&gt;hash&lt;/code&gt; 和 &lt;code&gt;==&lt;/code&gt; 后，所有内容都将起作用。但是，当前没有定义对象的 &lt;code&gt;hash&lt;/code&gt; ，而确实存在对象的 &lt;code&gt;system.==&lt;/code&gt; 并执行通常想要的&amp;ldquo;深度&amp;rdquo;比较（比较每个字段）。因此，在下面的示例中，仅实现 &lt;code&gt;hash&lt;/code&gt; 就足够了：</target>
        </trans-unit>
        <trans-unit id="c3ae9a42c0ef5d71d82ed6ff94ea44fa57d69eaa" translate="yes" xml:space="preserve">
          <source>After you create a socket with the &lt;code&gt;newSocket&lt;/code&gt; procedure, you can create a TCP server by calling the &lt;code&gt;bindAddr&lt;/code&gt; and &lt;code&gt;listen&lt;/code&gt; procedures.</source>
          <target state="translated">使用 &lt;code&gt;newSocket&lt;/code&gt; 过程创建套接字后，可以通过调用 &lt;code&gt;bindAddr&lt;/code&gt; 和 &lt;code&gt;listen&lt;/code&gt; 过程来创建TCP服务器。</target>
        </trans-unit>
        <trans-unit id="19f5c4359047c1c4029762b09cefac6ce55773f8" translate="yes" xml:space="preserve">
          <source>After you create a socket with the &lt;code&gt;newSocket&lt;/code&gt; procedure, you can easily connect it to a server running at a known hostname (or IP address) and port. To do so over TCP, use the example below.</source>
          <target state="translated">使用 &lt;code&gt;newSocket&lt;/code&gt; 过程创建套接字后，可以轻松地将其连接到以已知主机名（或IP地址）和端口运行的服务器。要通过TCP进行操作，请使用以下示例。</target>
        </trans-unit>
        <trans-unit id="5458c4cb0f05f3f6ed419b885d419d370bdf563e" translate="yes" xml:space="preserve">
          <source>Again, if you are wrapping a library which &lt;em&gt;mallocs&lt;/em&gt; and &lt;em&gt;frees&lt;/em&gt; data structures, you need to expose the appropriate &lt;em&gt;free&lt;/em&gt; function to Nim so you can clean it up. And of course, once cleaned you should avoid accessing it from Nim (or C for that matter). Typically C data structures have their own &lt;code&gt;malloc_structure&lt;/code&gt; and &lt;code&gt;free_structure&lt;/code&gt; specific functions, so wrapping these for the Nim side should be enough.</source>
          <target state="translated">同样，如果要包装一个&lt;em&gt;malloc&lt;/em&gt;并&lt;em&gt;释放&lt;/em&gt;数据结构的库，&lt;em&gt;则&lt;/em&gt;需要向Nim 公开适当的&lt;em&gt;free&lt;/em&gt;函数，以便对其进行清理。当然，一旦清理，就应该避免从Nim（或C）访问它。通常，C数据结构具有其自己的 &lt;code&gt;malloc_structure&lt;/code&gt; 和 &lt;code&gt;free_structure&lt;/code&gt; 特定函数，因此将它们包装在Nim端应该足够了。</target>
        </trans-unit>
        <trans-unit id="70904e7446445a141b33be68742af96a43be4694" translate="yes" xml:space="preserve">
          <source>Again, it is important to remember that this module must &lt;strong&gt;not&lt;/strong&gt; be used for cryptographic applications.</source>
          <target state="translated">同样，重要的是要记住，该模块&lt;strong&gt;不得&lt;/strong&gt;用于加密应用程序。</target>
        </trans-unit>
        <trans-unit id="02f02485ab679a9031f461bdbd3edab48ea42a79" translate="yes" xml:space="preserve">
          <source>Algorithm</source>
          <target state="translated">Algorithm</target>
        </trans-unit>
        <trans-unit id="67e15eb99dc0e473c962d6a494d00e048e9f6fc6" translate="yes" xml:space="preserve">
          <source>Algorithms</source>
          <target state="translated">Algorithms</target>
        </trans-unit>
        <trans-unit id="efc77c93e7dd9a47f78383fadbb6286c01811a32" translate="yes" xml:space="preserve">
          <source>Alias for &lt;a href=&quot;#contains,CritBitTree%5BT%5D,string&quot;&gt;contains&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#contains,CritBitTree%5BT%5D,string&quot;&gt;包含的&lt;/a&gt;别名。</target>
        </trans-unit>
        <trans-unit id="2def8d1f86d78a731890a66e16deb2b5e1ea4254" translate="yes" xml:space="preserve">
          <source>Alias for &lt;a href=&quot;#difference&quot;&gt;difference(s1, s2)&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#difference&quot;&gt;差异的&lt;/a&gt;别名（s1，s2）。</target>
        </trans-unit>
        <trans-unit id="997fbf4291c46ae1426159d92973a99aacd62a7b" translate="yes" xml:space="preserve">
          <source>Alias for &lt;a href=&quot;#difference,HashSet%5BA%5D,HashSet%5BA%5D&quot;&gt;difference(s1, s2)&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#difference,HashSet%5BA%5D,HashSet%5BA%5D&quot;&gt;差异（s1，s2）的&lt;/a&gt;别名。</target>
        </trans-unit>
        <trans-unit id="fd0fe019adf9a60e369fc1066982e05411ae595c" translate="yes" xml:space="preserve">
          <source>Alias for &lt;a href=&quot;#difference,IntSet,IntSet&quot;&gt;difference(s1, s2)&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#difference,IntSet,IntSet&quot;&gt;差异（s1，s2）的&lt;/a&gt;别名。</target>
        </trans-unit>
        <trans-unit id="f4a02e1746a71e7fb0864cabf7b39376b3a63a1f" translate="yes" xml:space="preserve">
          <source>Alias for &lt;a href=&quot;#intersection&quot;&gt;intersection(s1, s2)&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#intersection&quot;&gt;交集（s1，s2）的&lt;/a&gt;别名。</target>
        </trans-unit>
        <trans-unit id="8a0a9bed41fa9dc82d2411813ba4cd5aaf2c196c" translate="yes" xml:space="preserve">
          <source>Alias for &lt;a href=&quot;#intersection,HashSet%5BA%5D,HashSet%5BA%5D&quot;&gt;intersection(s1, s2)&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#intersection,HashSet%5BA%5D,HashSet%5BA%5D&quot;&gt;交集（s1，s2）的&lt;/a&gt;别名。</target>
        </trans-unit>
        <trans-unit id="c1cd0398b440416c926e7804be57c89537c5981d" translate="yes" xml:space="preserve">
          <source>Alias for &lt;a href=&quot;#intersection,IntSet,IntSet&quot;&gt;intersection(s1, s2)&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#intersection,IntSet,IntSet&quot;&gt;交集（s1，s2）的&lt;/a&gt;别名。</target>
        </trans-unit>
        <trans-unit id="16d760c200e2de1ecfe11a45e3c9ba9e00d49b55" translate="yes" xml:space="preserve">
          <source>Alias for &lt;a href=&quot;#len,HashSet%5BA%5D&quot;&gt;len()&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#len,HashSet%5BA%5D&quot;&gt;len（）的&lt;/a&gt;别名。</target>
        </trans-unit>
        <trans-unit id="b55ee14251fac7a554607f3d394b09fff77a9156" translate="yes" xml:space="preserve">
          <source>Alias for &lt;a href=&quot;#len,IntSet&quot;&gt;len()&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#len,IntSet&quot;&gt;len（）的&lt;/a&gt;别名。</target>
        </trans-unit>
        <trans-unit id="5157075fe8e50531bece1fec7fce7a27b73dc5c7" translate="yes" xml:space="preserve">
          <source>Alias for &lt;a href=&quot;#len,OrderedSet%5BA%5D&quot;&gt;len()&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#len,OrderedSet%5BA%5D&quot;&gt;len（）的&lt;/a&gt;别名。</target>
        </trans-unit>
        <trans-unit id="7e2391f38322eb20263936b3bfa8fc3471e6b69b" translate="yes" xml:space="preserve">
          <source>Alias for &lt;a href=&quot;#len,TOrderedSet%5BA%5D&quot;&gt;len()&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#len,TOrderedSet%5BA%5D&quot;&gt;len（）的&lt;/a&gt;别名。</target>
        </trans-unit>
        <trans-unit id="d86fe62b7538063ec7bfae9f6c08a83088df2cff" translate="yes" xml:space="preserve">
          <source>Alias for &lt;a href=&quot;#len,TSet%5BA%5D&quot;&gt;len()&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#len,TSet%5BA%5D&quot;&gt;len（）的&lt;/a&gt;别名。</target>
        </trans-unit>
        <trans-unit id="c369c41a51b721ffa0c36f0a38f36d5f3fe90653" translate="yes" xml:space="preserve">
          <source>Alias for &lt;a href=&quot;#none,typedesc&quot;&gt;none(T) proc&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#none,typedesc&quot;&gt;none（T）proc的&lt;/a&gt;别名。</target>
        </trans-unit>
        <trans-unit id="41b739a23c6fc05ac36095d9dd959eb84d6a5a1f" translate="yes" xml:space="preserve">
          <source>Alias for &lt;a href=&quot;#symmetricDifference&quot;&gt;symmetricDifference(s1, s2)&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#symmetricDifference&quot;&gt;symmetricDifference（s1，s2）的&lt;/a&gt;别名。</target>
        </trans-unit>
        <trans-unit id="0aec4506722e668f1f0e0f5f768a71ec370a8b5c" translate="yes" xml:space="preserve">
          <source>Alias for &lt;a href=&quot;#symmetricDifference,HashSet%5BA%5D,HashSet%5BA%5D&quot;&gt;symmetricDifference(s1, s2)&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#symmetricDifference,HashSet%5BA%5D,HashSet%5BA%5D&quot;&gt;symmetricDifference（s1，s2）的&lt;/a&gt;别名。</target>
        </trans-unit>
        <trans-unit id="f3db9334116c6d200d159599181aa97f7e9eee70" translate="yes" xml:space="preserve">
          <source>Alias for &lt;a href=&quot;#union&quot;&gt;union(s1, s2)&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#union&quot;&gt;union（s1，s2）的&lt;/a&gt;别名。</target>
        </trans-unit>
        <trans-unit id="d05f525a9d5842ca8247f623c979e431534b00c1" translate="yes" xml:space="preserve">
          <source>Alias for &lt;a href=&quot;#union,HashSet%5BA%5D,HashSet%5BA%5D&quot;&gt;union(s1, s2)&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#union,HashSet%5BA%5D,HashSet%5BA%5D&quot;&gt;union（s1，s2）的&lt;/a&gt;别名。</target>
        </trans-unit>
        <trans-unit id="629615d6f5a705c8f7b1097b7a9400f5bd7a5892" translate="yes" xml:space="preserve">
          <source>Alias for &lt;a href=&quot;#union,IntSet,IntSet&quot;&gt;union(s1, s2)&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#union,IntSet,IntSet&quot;&gt;union（s1，s2）的&lt;/a&gt;别名。</target>
        </trans-unit>
        <trans-unit id="9fdf5629aa63f19dadb3054a1faf88668b0ab6e7" translate="yes" xml:space="preserve">
          <source>Alias for &lt;code&gt;console.error()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;console.error()&lt;/code&gt; 的别名。</target>
        </trans-unit>
        <trans-unit id="93d508bd2bfc8a4302e90cc6be8d6bc7082ef911" translate="yes" xml:space="preserve">
          <source>Alias for &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">别名为 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8b5be6f17bdfd8cbcd14d0c4aa54788e9e3d34a0" translate="yes" xml:space="preserve">
          <source>Alias for &lt;code&gt;none(T)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;none(T)&lt;/code&gt; 的别名。</target>
        </trans-unit>
        <trans-unit id="dc3c3212c96ed5a75a219cf8a8294e101e81f4cb" translate="yes" xml:space="preserve">
          <source>Alias for &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; 别名。</target>
        </trans-unit>
        <trans-unit id="1e4bb070d318337002207d7bc63945ccae6f4f29" translate="yes" xml:space="preserve">
          <source>Alias for a pair of 32-bit floats.</source>
          <target state="translated">一对32位浮点数的别称。</target>
        </trans-unit>
        <trans-unit id="453247eb19c6fe7d3343d1380efdd939f40a7501" translate="yes" xml:space="preserve">
          <source>Alias for a pair of 64-bit floats.</source>
          <target state="translated">一对64位浮点数的别称。</target>
        </trans-unit>
        <trans-unit id="0e270057d243cf6c2e5a8adbee3e84192193ba53" translate="yes" xml:space="preserve">
          <source>Alias for for &lt;a href=&quot;#countSetBits,SomeInteger&quot;&gt;countSetBits&lt;/a&gt;. (Hamming weight.)</source>
          <target state="translated">&lt;a href=&quot;#countSetBits,SomeInteger&quot;&gt;countSetBits的&lt;/a&gt;别名。（重锤）</target>
        </trans-unit>
        <trans-unit id="880b74f9b1a7d4cf4585f8c8f387bcb20192549a" translate="yes" xml:space="preserve">
          <source>Alias for for countSetBits (Hamming weight.)</source>
          <target state="translated">countSetBits的别名(Hamming weight.)</target>
        </trans-unit>
        <trans-unit id="0232e77b936af53c5f4048ee8a964113bbf4f364" translate="yes" xml:space="preserve">
          <source>Alias for system.`$`(t) since Nim v0.20.</source>
          <target state="translated">自Nim v0.20以来,system.`$`(t)的别称。</target>
        </trans-unit>
        <trans-unit id="1f9a23ac422f0e5443e01e349d57322e73288849" translate="yes" xml:space="preserve">
          <source>Alias for the operating system specific &lt;em&gt;&quot;open&quot;&lt;/em&gt; command, &lt;code&gt;&quot;open&quot;&lt;/code&gt; on OSX, MacOS and Windows, &lt;code&gt;&quot;xdg-open&quot;&lt;/code&gt; on Linux, BSD, etc.</source>
          <target state="translated">别名操作系统特定的&lt;em&gt;&amp;ldquo;打开&amp;rdquo;&lt;/em&gt;命令， &lt;code&gt;&quot;open&quot;&lt;/code&gt; 的OSX，MacOS和Windows的 &lt;code&gt;&quot;xdg-open&quot;&lt;/code&gt; 在Linux，BSD等。</target>
        </trans-unit>
        <trans-unit id="d3c9714cd11c037506385dd8c632916016f242a7" translate="yes" xml:space="preserve">
          <source>Alias for:</source>
          <target state="translated">别名:</target>
        </trans-unit>
        <trans-unit id="568b052b7299aeec47ddd0e00e34376220e78ab0" translate="yes" xml:space="preserve">
          <source>Alias of &lt;a href=&quot;#hasKey,CountTable%5BA%5D,A&quot;&gt;hasKey proc&lt;/a&gt; for use with the &lt;code&gt;in&lt;/code&gt; operator.</source>
          <target state="translated">&lt;a href=&quot;#hasKey,CountTable%5BA%5D,A&quot;&gt;hasKey proc的&lt;/a&gt;别名，用于 &lt;code&gt;in&lt;/code&gt; 运算符。</target>
        </trans-unit>
        <trans-unit id="1d53854d9ed55920dfe9c1a5678e23d027f6249b" translate="yes" xml:space="preserve">
          <source>Alias of &lt;a href=&quot;#hasKey,CountTableRef%5BA%5D,A&quot;&gt;hasKey proc&lt;/a&gt; for use with the &lt;code&gt;in&lt;/code&gt; operator.</source>
          <target state="translated">&lt;a href=&quot;#hasKey,CountTableRef%5BA%5D,A&quot;&gt;hasKey proc的&lt;/a&gt;别名，用于 &lt;code&gt;in&lt;/code&gt; 运算符。</target>
        </trans-unit>
        <trans-unit id="24e959366fea593503a150254ae712bd5a394741" translate="yes" xml:space="preserve">
          <source>Alias of &lt;a href=&quot;#hasKey,OrderedTable%5BA,B%5D,A&quot;&gt;hasKey proc&lt;/a&gt; for use with the &lt;code&gt;in&lt;/code&gt; operator.</source>
          <target state="translated">&lt;a href=&quot;#hasKey,OrderedTable%5BA,B%5D,A&quot;&gt;hasKey proc的&lt;/a&gt;别名，用于 &lt;code&gt;in&lt;/code&gt; 运算符。</target>
        </trans-unit>
        <trans-unit id="2bd1850ce1081e214177d4dcf503b3402bc74744" translate="yes" xml:space="preserve">
          <source>Alias of &lt;a href=&quot;#hasKey,OrderedTableRef%5BA,B%5D,A&quot;&gt;hasKey proc&lt;/a&gt; for use with the &lt;code&gt;in&lt;/code&gt; operator.</source>
          <target state="translated">&lt;a href=&quot;#hasKey,OrderedTableRef%5BA,B%5D,A&quot;&gt;hasKey proc的&lt;/a&gt;别名，用于 &lt;code&gt;in&lt;/code&gt; 运算符。</target>
        </trans-unit>
        <trans-unit id="4c1e8c7884ac872c79a473784dcb87beaaeb14a0" translate="yes" xml:space="preserve">
          <source>Alias of &lt;a href=&quot;#hasKey,StringTableRef,string&quot;&gt;hasKey proc&lt;/a&gt; for use with the &lt;code&gt;in&lt;/code&gt; operator.</source>
          <target state="translated">&lt;a href=&quot;#hasKey,StringTableRef,string&quot;&gt;hasKey proc的&lt;/a&gt;别名，用于 &lt;code&gt;in&lt;/code&gt; 运算符。</target>
        </trans-unit>
        <trans-unit id="d7ca8c0e914d0f5f1ed59231302c5f6d54c04075" translate="yes" xml:space="preserve">
          <source>Alias of &lt;a href=&quot;#hasKey,Table%5BA,B%5D,A&quot;&gt;hasKey proc&lt;/a&gt; for use with the &lt;code&gt;in&lt;/code&gt; operator.</source>
          <target state="translated">&lt;a href=&quot;#hasKey,Table%5BA,B%5D,A&quot;&gt;hasKey proc的&lt;/a&gt;别名，用于 &lt;code&gt;in&lt;/code&gt; 运算符。</target>
        </trans-unit>
        <trans-unit id="d0102eabf21c6e45c1d28c47e4050dd577036f88" translate="yes" xml:space="preserve">
          <source>Alias of &lt;a href=&quot;#hasKey,TableRef%5BA,B%5D,A&quot;&gt;hasKey proc&lt;/a&gt; for use with the &lt;code&gt;in&lt;/code&gt; operator.</source>
          <target state="translated">&lt;a href=&quot;#hasKey,TableRef%5BA,B%5D,A&quot;&gt;hasKey proc的&lt;/a&gt;别名，用于 &lt;code&gt;in&lt;/code&gt; 运算符。</target>
        </trans-unit>
        <trans-unit id="dff4b15fdc5cd6b2d3a14ee08df536409dc7010c" translate="yes" xml:space="preserve">
          <source>Alias to type less.</source>
          <target state="translated">别名要少打。</target>
        </trans-unit>
        <trans-unit id="104cb8eefb7ba374e6a7fdf3bfea02d072081428" translate="yes" xml:space="preserve">
          <source>Aliasing restrictions in parameter passing</source>
          <target state="translated">参数传递中的重命名限制</target>
        </trans-unit>
        <trans-unit id="23b284ccdbe19f7425cb58124eb1637a94d50595" translate="yes" xml:space="preserve">
          <source>Align pragma</source>
          <target state="translated">对齐pragma</target>
        </trans-unit>
        <trans-unit id="2feaf49576ccc73f2b86d27faa6075fa943090f4" translate="yes" xml:space="preserve">
          <source>Aligns &lt;code&gt;s&lt;/code&gt; using &lt;code&gt;fill&lt;/code&gt; char. This is only of interest if you want to write a custom &lt;code&gt;format&lt;/code&gt; proc that should support the standard format specifiers.</source>
          <target state="translated">对齐 &lt;code&gt;s&lt;/code&gt; 使用 &lt;code&gt;fill&lt;/code&gt; 字符。仅当您要编写支持标准格式说明符的自定义 &lt;code&gt;format&lt;/code&gt; proc时，这才有意义。</target>
        </trans-unit>
        <trans-unit id="4bcede847bb2505de2a000f871a53d72f1a799bb" translate="yes" xml:space="preserve">
          <source>Aligns a string &lt;code&gt;s&lt;/code&gt; with &lt;code&gt;padding&lt;/code&gt;, so that it is of length &lt;code&gt;count&lt;/code&gt;.</source>
          <target state="translated">将字符串 &lt;code&gt;s&lt;/code&gt; 与 &lt;code&gt;padding&lt;/code&gt; 对齐，使其具有长度 &lt;code&gt;count&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4a373b51ddb20415acc6f2cab49e7a886d4418f7" translate="yes" xml:space="preserve">
          <source>Aligns a string &lt;em&gt;s&lt;/em&gt; with &lt;em&gt;padding&lt;/em&gt;, so that it is of length &lt;em&gt;count&lt;/em&gt;.</source>
          <target state="translated">将字符串&lt;em&gt;s&lt;/em&gt;与&lt;em&gt;填充&lt;/em&gt;对齐，使其具有长度&lt;em&gt;计数&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="6628bfc03620870ce42f4844ffc52e6eca7e2b68" translate="yes" xml:space="preserve">
          <source>Aligns a unicode string &lt;code&gt;s&lt;/code&gt; with &lt;code&gt;padding&lt;/code&gt;, so that it has a rune-length of &lt;code&gt;count&lt;/code&gt;.</source>
          <target state="translated">将unicode字符串 &lt;code&gt;s&lt;/code&gt; 与 &lt;code&gt;padding&lt;/code&gt; 对齐，使其符文长度为 &lt;code&gt;count&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="18f77fc6c5026c1d2d103f3b97daf7c1dbd054f5" translate="yes" xml:space="preserve">
          <source>All &lt;code&gt;db_*&lt;/code&gt; modules support the same form of parameter substitution. That is, using the &lt;code&gt;?&lt;/code&gt; (question mark) to signify the place where a value should be placed. For example:</source>
          <target state="translated">所有 &lt;code&gt;db_*&lt;/code&gt; 模块都支持相同形式的参数替换。也就是说，使用 &lt;code&gt;?&lt;/code&gt; （问号）表示应放置值的位置。例如：</target>
        </trans-unit>
        <trans-unit id="9552063c6dac2a0b2b6f80dd47ebd5c82800945e" translate="yes" xml:space="preserve">
          <source>All Nim source files are in the UTF-8 encoding (or its ASCII subset). Other encodings are not supported. Any of the standard platform line termination sequences can be used - the Unix form using ASCII LF (linefeed), the Windows form using the ASCII sequence CR LF (return followed by linefeed), or the old Macintosh form using the ASCII CR (return) character. All of these forms can be used equally, regardless of platform.</source>
          <target state="translated">所有Nim源文件均采用UTF-8编码(或其ASCII子集)。不支持其他编码。可以使用任何一种标准平台的行终止序列--Unix形式使用ASCII LF(换行),Windows形式使用ASCII序列CR LF(回车后换行),或者旧的Macintosh形式使用ASCII CR(回车)字符。所有这些表格都可以平等地使用,不受平台的影响。</target>
        </trans-unit>
        <trans-unit id="53be8359eb31c3bb37cefb8008e50675ad0c6bce" translate="yes" xml:space="preserve">
          <source>All Nim source files are in the UTF-8 encoding (or its ASCII subset). Other encodings are not supported. Any of the standard platform line termination sequences can be used - the Unix form using ASCII LF (linefeed), the Windows form using the ASCII sequence CR LF (return followed by linefeed), or the old Macintosh form using the ASCII CR (return) character. All of these forms can be used equally, regardless of the platform.</source>
          <target state="translated">所有Nim源文件均采用UTF-8编码(或其ASCII子集)。不支持其他编码。可以使用任何一种标准平台的行终止序列--Unix形式使用ASCII LF(换行),Windows形式使用ASCII序列CR LF(回车后换行),或者旧的Macintosh形式使用ASCII CR(回车)字符。所有这些表格都可以平等地使用,无论平台如何。</target>
        </trans-unit>
        <trans-unit id="2c0abd1c94e3986f0fc217d43c9ce2e325e352e8" translate="yes" xml:space="preserve">
          <source>All asynchronous functions returning a &lt;code&gt;Future&lt;/code&gt; will not block. They will not however return immediately. An asynchronous function will have code which will be executed before an asynchronous request is made, in most cases this code sets up the request.</source>
          <target state="translated">所有返回 &lt;code&gt;Future&lt;/code&gt; 的异步函数都不会阻塞。但是他们不会立即返回。异步函数将具有将在发出异步请求之前执行的代码，在大多数情况下，该代码将建立请求。</target>
        </trans-unit>
        <trans-unit id="00b074df2678b416192356b1a38a849d3da057dd" translate="yes" xml:space="preserve">
          <source>All expressions have a type that is known during semantic analysis. Nim is statically typed. One can declare new types, which is in essence defining an identifier that can be used to denote this custom type.</source>
          <target state="translated">所有的表达式都有一个类型,这个类型在语义分析过程中是已知的。Nim是静态类型的。人们可以声明新的类型,这实质上是定义了一个标识符,可以用来表示这个自定义类型。</target>
        </trans-unit>
        <trans-unit id="987c15958bc12d3f55c911e8dc5fec4777c6bc5e" translate="yes" xml:space="preserve">
          <source>All expressions have a type which is known at compile time. Nim is statically typed. One can declare new types, which is in essence defining an identifier that can be used to denote this custom type.</source>
          <target state="translated">所有的表达式都有一个在编译时已知的类型。Nim是静态类型的。人们可以声明新的类型,这实质上是定义了一个标识符,可以用来表示这个自定义类型。</target>
        </trans-unit>
        <trans-unit id="92809bea6792f7ae6e88db1176236402c1b49d41" translate="yes" xml:space="preserve">
          <source>All fields will have the same sign.</source>
          <target state="translated">所有字段都有相同的符号。</target>
        </trans-unit>
        <trans-unit id="f984cab28f61b914c2bd533b03fae6756c4294ad" translate="yes" xml:space="preserve">
          <source>All identifiers of a module are valid from the point of declaration until the end of the module. Identifiers from indirectly dependent modules are &lt;em&gt;not&lt;/em&gt; available. The &lt;span id=&quot;system_1&quot;&gt;system&lt;/span&gt; module is automatically imported in every module.</source>
          <target state="translated">从声明到模块结束，模块的所有标识符均有效。间接依赖模块的标识符&lt;em&gt;不可&lt;/em&gt;用。该&lt;span id=&quot;system_1&quot;&gt;系统&lt;/span&gt;模块，每个模块中自动导入。</target>
        </trans-unit>
        <trans-unit id="2b758e4da2df5099c4fcdcedcd68afb1e4873ff9" translate="yes" xml:space="preserve">
          <source>All macros and templates can also be used as pragmas. They can be attached to routines (procs, iterators, etc), type names, or type expressions. The compiler will perform the following simple syntactic transformations:</source>
          <target state="translated">所有的宏和模板也可以作为实用名词使用。它们可以被附加到例程(procs、迭代器等)、类型名或类型表达式上。编译器将执行以下简单的语法转换。</target>
        </trans-unit>
        <trans-unit id="cded9aa9ab6801c06f94e1f6e9e5425ed01952a5" translate="yes" xml:space="preserve">
          <source>All of the available idetools commands require you to specify a query location through the &lt;code&gt;--track&lt;/code&gt; or &lt;code&gt;--trackDirty&lt;/code&gt; switches. The general idetools invocations are:</source>
          <target state="translated">所有可用的idetools命令都要求您通过 &lt;code&gt;--track&lt;/code&gt; 或 &lt;code&gt;--trackDirty&lt;/code&gt; 开关指定查询位置。常规idetool调用为：</target>
        </trans-unit>
        <trans-unit id="433f618d4804b96035339cf390e19dd47ccae945" translate="yes" xml:space="preserve">
          <source>All procedures of this module use this type. Procedures don't directly use &lt;a href=&quot;#StreamObj&quot;&gt;StreamObj&lt;/a&gt;.</source>
          <target state="translated">该模块的所有过程均使用此类型。过程不直接使用&lt;a href=&quot;#StreamObj&quot;&gt;StreamObj&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="96cbbecb3e99c48c7b4fe7081d99be9e034325bf" translate="yes" xml:space="preserve">
          <source>All string literals are of the type &lt;code&gt;string&lt;/code&gt;. A string in Nim is very similar to a sequence of characters. However, strings in Nim are both zero-terminated and have a length field. One can retrieve the length with the builtin &lt;code&gt;len&lt;/code&gt; procedure; the length never counts the terminating zero.</source>
          <target state="translated">所有字符串文字均属于 &lt;code&gt;string&lt;/code&gt; 类型。Nim中的字符串与字符序列非常相似。但是，Nim中的字符串都以零结尾并且具有长度字段。可以使用内置的 &lt;code&gt;len&lt;/code&gt; 程序检索长度；长度永远不会计入终止零。</target>
        </trans-unit>
        <trans-unit id="c6b1a1f14d43339564b33e2a129f631ca1f3956e" translate="yes" xml:space="preserve">
          <source>All the &lt;code&gt;tests/caas/*.txt&lt;/code&gt; files encode a session with the compiler:</source>
          <target state="translated">所有的 &lt;code&gt;tests/caas/*.txt&lt;/code&gt; 文件都编码与编译器的会话：</target>
        </trans-unit>
        <trans-unit id="674be9ae4a283b604e5d55618b959feb8ee26d62" translate="yes" xml:space="preserve">
          <source>All the characters that count as whitespace (space, tab, vertical tab, carriage return, new line, form feed)</source>
          <target state="translated">所有算作空白的字符(空格、制表符、垂直制表符、回车、换行、换页)。</target>
        </trans-unit>
        <trans-unit id="d7d265f3de6bf8deede109e19dc230beea86f266" translate="yes" xml:space="preserve">
          <source>All the characters that count as whitespace.</source>
          <target state="translated">所有算作空白的字符。</target>
        </trans-unit>
        <trans-unit id="0858ffb5249b4b454db4fc31e3311bb8f257c071" translate="yes" xml:space="preserve">
          <source>All the comparison operators can be used with enumeration types.</source>
          <target state="translated">所有的比较运算符都可以和枚举类型一起使用。</target>
        </trans-unit>
        <trans-unit id="6c891dcf4573456ce1e2da5262b50d0a08307027" translate="yes" xml:space="preserve">
          <source>All the operations have to perform efficiently. Because a Cellset can become huge a hash table alone is not suitable for this.</source>
          <target state="translated">所有的操作都必须有效地执行。因为一个Cellset可能会变得很大,单单一个哈希表是不适合的。</target>
        </trans-unit>
        <trans-unit id="d7919c15f302a782639503db1ddcfd789a925698" translate="yes" xml:space="preserve">
          <source>All the sequences that define a single byte value or a single UTF-8 character (in UTF-8 mode) can be used both inside and outside character classes. In addition, inside a character class, the sequence &lt;code&gt;\b&lt;/code&gt; is interpreted as the backspace character (hex 08), and the sequence &lt;code&gt;\X&lt;/code&gt; is interpreted as the character &quot;X&quot;. Outside a character class, these sequences have different meanings (see below).</source>
          <target state="translated">定义单个字节值或单个UTF-8字符（在UTF-8模式下）的所有序列都可以在内部和外部字符类中使用。另外，在字符类内部，序列 &lt;code&gt;\b&lt;/code&gt; 被解释为退格字符（十六进制08），而序列 &lt;code&gt;\X&lt;/code&gt; 被解释为字符&amp;ldquo; X&amp;rdquo;。在字符类之外，这些序列具有不同的含义（请参见下文）。</target>
        </trans-unit>
        <trans-unit id="169951f4b6d1d7f1a4b31b9a082c85cf7bcb2136" translate="yes" xml:space="preserve">
          <source>All top level constants or types appearing within the concept body are accessible through the dot operator in procs where the concept was successfully matched to a concrete type:</source>
          <target state="translated">所有出现在概念体中的顶层常量或类型都可以通过点运算符在概念与具体类型成功匹配的procs中访问。</target>
        </trans-unit>
        <trans-unit id="3c975cb1e2ba6e75d38b206700dca326fdb354fc" translate="yes" xml:space="preserve">
          <source>All types for that &lt;code&gt;nil&lt;/code&gt; is a valid value can be annotated to exclude &lt;code&gt;nil&lt;/code&gt; as a valid value with the &lt;code&gt;not nil&lt;/code&gt; annotation:</source>
          <target state="translated">该 &lt;code&gt;nil&lt;/code&gt; 是有效值的所有类型都可以使用 &lt;code&gt;not nil&lt;/code&gt; 注释进行注释，以将 &lt;code&gt;nil&lt;/code&gt; 排除为有效值：</target>
        </trans-unit>
        <trans-unit id="92ecd37f4fed9b99ae21b4e468d434ca109d4a8c" translate="yes" xml:space="preserve">
          <source>All types for which &lt;code&gt;nil&lt;/code&gt; is a valid value can be annotated with the &lt;code&gt;not nil&lt;/code&gt; annotation to exclude &lt;code&gt;nil&lt;/code&gt; as a valid value:</source>
          <target state="translated">可以使用 &lt;code&gt;not nil&lt;/code&gt; 注释对所有 &lt;code&gt;nil&lt;/code&gt; 是有效值的类型进行注释，以将 &lt;code&gt;nil&lt;/code&gt; 排除为有效值：</target>
        </trans-unit>
        <trans-unit id="0f502b4a3c8124f068d8f4c024865eb1ab5a1cf4" translate="yes" xml:space="preserve">
          <source>Allocates a new memory block on the shared heap with at least &lt;code&gt;T.sizeof * size&lt;/code&gt; bytes.</source>
          <target state="translated">在共享堆上分配至少 &lt;code&gt;T.sizeof * size&lt;/code&gt; 个字节的新内存块。</target>
        </trans-unit>
        <trans-unit id="9b20fff58bbd0e44f2a2e2e6eb582620afd21c21" translate="yes" xml:space="preserve">
          <source>Allocates a new memory block on the shared heap with at least &lt;code&gt;size&lt;/code&gt; bytes.</source>
          <target state="translated">在共享堆上分配至少具有 &lt;code&gt;size&lt;/code&gt; 字节的新内存块。</target>
        </trans-unit>
        <trans-unit id="35f5a857e75063995215816821d0f1770f35f73c" translate="yes" xml:space="preserve">
          <source>Allocates a new memory block with at least &lt;code&gt;T.sizeof * size&lt;/code&gt; bytes.</source>
          <target state="translated">用至少 &lt;code&gt;T.sizeof * size&lt;/code&gt; 字节分配一个新的内存块。</target>
        </trans-unit>
        <trans-unit id="54289ede638acbe864667fd63428f7048731c3e6" translate="yes" xml:space="preserve">
          <source>Allocates a new memory block with at least &lt;code&gt;size&lt;/code&gt; bytes.</source>
          <target state="translated">分配至少具有 &lt;code&gt;size&lt;/code&gt; 字节的新存储块。</target>
        </trans-unit>
        <trans-unit id="ac79cefc92c75eb439b3995e551d8211d527174a" translate="yes" xml:space="preserve">
          <source>AllowCommonBase:</source>
          <target state="translated">AllowCommonBase:</target>
        </trans-unit>
        <trans-unit id="e1533f097a691960fb636e648fa3a6a10f49cb06" translate="yes" xml:space="preserve">
          <source>Allowed types for &lt;code&gt;T&lt;/code&gt; are integers, floats, and enums without holes.</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; 的允许类型是不带孔的整数，浮点数和枚举。</target>
        </trans-unit>
        <trans-unit id="dfa2aa3af7fa08673515debab6b959324fc3ac7e" translate="yes" xml:space="preserve">
          <source>Allows you to override the behaviour of your application when CTRL+C is pressed. Only one such hook is supported.</source>
          <target state="translated">允许你覆盖你的应用程序在按下CTRL+C时的行为。只支持一个这样的钩子。</target>
        </trans-unit>
        <trans-unit id="712e713171e76aececc409bac7c3780f3eb452be" translate="yes" xml:space="preserve">
          <source>Also known as (in other languages)</source>
          <target state="translated">又称(其他语言)</target>
        </trans-unit>
        <trans-unit id="ab3670407090c86340b7a0b2e617c282de436932" translate="yes" xml:space="preserve">
          <source>Also see &lt;code&gt;dumpAstGen&lt;/code&gt; and &lt;code&gt;dumpLisp&lt;/code&gt;.</source>
          <target state="translated">另请参见 &lt;code&gt;dumpAstGen&lt;/code&gt; 和 &lt;code&gt;dumpLisp&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2407067910847be1a5da2135b6ce96e939f954b3" translate="yes" xml:space="preserve">
          <source>Also see &lt;code&gt;dumpAstGen&lt;/code&gt; and &lt;code&gt;dumpTree&lt;/code&gt;.</source>
          <target state="translated">另请参见 &lt;code&gt;dumpAstGen&lt;/code&gt; 和 &lt;code&gt;dumpTree&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b29cad5adcb6a93f7398629c014ec484347ea3bc" translate="yes" xml:space="preserve">
          <source>Also see &lt;code&gt;dumpTree&lt;/code&gt; and &lt;code&gt;dumpLisp&lt;/code&gt;.</source>
          <target state="translated">另请参见 &lt;code&gt;dumpTree&lt;/code&gt; 和 &lt;code&gt;dumpLisp&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="029f6357cfa5fa54f588a79c60e26072ee6dc04a" translate="yes" xml:space="preserve">
          <source>Also, you won't find raw &lt;code&gt;\n&lt;/code&gt; characters breaking the one answer per line format. Instead you will need to parse sequences in the form &lt;code&gt;\xHH&lt;/code&gt;, where &lt;em&gt;HH&lt;/em&gt; is a hexadecimal value (e.g. newlines generate the sequence &lt;code&gt;\x0A&lt;/code&gt;).</source>
          <target state="translated">此外，您不会发现原始 &lt;code&gt;\n&lt;/code&gt; 字符会破坏每种行格式的一个答案。相反，您将需要解析 &lt;code&gt;\xHH&lt;/code&gt; 形式的序列，其中&lt;em&gt;HH&lt;/em&gt;是一个十六进制值（例如，换行符生成序列 &lt;code&gt;\x0A&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="4521b364cb9ce19f839632eb99d99bb31f52f57b" translate="yes" xml:space="preserve">
          <source>Alternate version of the above.</source>
          <target state="translated">以上的备选版本。</target>
        </trans-unit>
        <trans-unit id="3b74e96e489cf616e54374e5e92ff3290101f441" translate="yes" xml:space="preserve">
          <source>Alternative</source>
          <target state="translated">Alternative</target>
        </trans-unit>
        <trans-unit id="d29cbcd3570c897268db2aa03ceca37c4f9af02e" translate="yes" xml:space="preserve">
          <source>Alternatively, it is possible to use &lt;code&gt;getCurrentException&lt;/code&gt; to retrieve the exception that has been raised:</source>
          <target state="translated">或者，可以使用 &lt;code&gt;getCurrentException&lt;/code&gt; 检索已引发的异常：</target>
        </trans-unit>
        <trans-unit id="24a6f9561b6fb31bcce22dd9eefb7cb23c8efb12" translate="yes" xml:space="preserve">
          <source>Alternatively, the &lt;code&gt;distinct&lt;/code&gt; type modifier can be applied to the type class to allow each param matching the type class to bind to a different type. Such type classes are called &lt;span id=&quot;bind-many_1&quot;&gt;bind many&lt;/span&gt; types.</source>
          <target state="translated">或者，可以将 &lt;code&gt;distinct&lt;/code&gt; 类型修饰符应用于类型类，以允许与该类型类匹配的每个参数绑定到不同的类型。这样的类型类称为&lt;span id=&quot;bind-many_1&quot;&gt;绑定许多&lt;/span&gt;类型。</target>
        </trans-unit>
        <trans-unit id="c5c9b8d75bae0a4e7883c1afe39fba029a2a402f" translate="yes" xml:space="preserve">
          <source>Alternatively, the &lt;em&gt;type&lt;/em&gt; operator can be used over the proc params for similar effect when anonymous or distinct type classes are used.</source>
          <target state="translated">另外，当使用匿名或不同类型的类时，可以在proc参数上使用&lt;em&gt;类型&lt;/em&gt;运算符，以获得相似的效果。</target>
        </trans-unit>
        <trans-unit id="5b30b701e37924ad0c27b052555995c52f8814d1" translate="yes" xml:space="preserve">
          <source>Although Nim supports a variety of code and formatting styles, it is nevertheless beneficial that certain community efforts, such as the standard library, should follow a consistent set of style guidelines when suitable. This enhancement proposal aims to list a series of guidelines that the standard library should follow.</source>
          <target state="translated">虽然Nim支持各种代码和格式化风格,但在合适的情况下,某些社区的工作(如标准库)应该遵循一套一致的风格准则,这是有益的。本增强提案旨在列出一系列标准库应该遵循的准则。</target>
        </trans-unit>
        <trans-unit id="cd0ad178d074aad3f70271e85d87e8380aa9e712" translate="yes" xml:space="preserve">
          <source>Although the &lt;code&gt;times&lt;/code&gt; module supports nanosecond time resolution, the resolution used by &lt;code&gt;getTime()&lt;/code&gt; depends on the platform and backend (JS is limited to millisecond precision).</source>
          <target state="translated">尽管 &lt;code&gt;times&lt;/code&gt; 模块支持纳秒级的时间分辨率，但 &lt;code&gt;getTime()&lt;/code&gt; 使用的分辨率取决于平台和后端（JS限于毫秒级精度）。</target>
        </trans-unit>
        <trans-unit id="e818f14ba9bbedb672b0a658dcc233bb37218e4d" translate="yes" xml:space="preserve">
          <source>Although the types use nanosecond time resolution, the underlying resolution used by &lt;code&gt;getTime()&lt;/code&gt; depends on the platform and backend (JS is limited to millisecond precision).</source>
          <target state="translated">尽管这些类型使用纳秒级的时间分辨率，但 &lt;code&gt;getTime()&lt;/code&gt; 使用的基础分辨率取决于平台和后端（JS限于毫秒精度）。</target>
        </trans-unit>
        <trans-unit id="a1980deb423f91e0ac3552e894ae9e6ff761680b" translate="yes" xml:space="preserve">
          <source>Although this module has &lt;code&gt;seq&lt;/code&gt; in its name, it implements operations not only for &lt;span id=&quot;seq_1&quot;&gt;seq&lt;/span&gt; type, but for three built-in container types under the &lt;code&gt;openArray&lt;/code&gt; umbrella:</source>
          <target state="translated">虽然这个模块 &lt;code&gt;seq&lt;/code&gt; 在它的名字，它实现了业务不仅为&lt;span id=&quot;seq_1&quot;&gt;序列&lt;/span&gt;类型，但对于三个内置的下容器类型 &lt;code&gt;openArray&lt;/code&gt; 伞：</target>
        </trans-unit>
        <trans-unit id="d3c0c9ff9b3e9a28a9649fc31261da1cd44edd57" translate="yes" xml:space="preserve">
          <source>Although use of whitespace for stylistic reasons other than the ones endorsed by this guide are allowed, careful thought should be put into such practices. Not all editors support automatic alignment of code sections, and re-aligning long sections of code by hand can quickly become tedious.</source>
          <target state="translated">虽然除了本指南所认可的原因外,允许出于风格上的原因使用空白,但应仔细考虑这种做法。并非所有的编辑器都支持代码部分的自动对齐,用手重新对齐长长的代码部分会很快变得乏味。</target>
        </trans-unit>
        <trans-unit id="91fc7a21703d6509e49f44ea9f9faec24ea18eb4" translate="yes" xml:space="preserve">
          <source>Always spawns a new task on the worker thread with &lt;code&gt;id&lt;/code&gt;, so that the &lt;code&gt;call&lt;/code&gt; is &lt;strong&gt;always&lt;/strong&gt; executed on the thread.</source>
          <target state="translated">总是滋生与工作线程上一个新的任务 &lt;code&gt;id&lt;/code&gt; ，使 &lt;code&gt;call&lt;/code&gt; 时&lt;strong&gt;总是&lt;/strong&gt;线程上执行。</target>
        </trans-unit>
        <trans-unit id="4cb3dbed99e04b239b1de48db1267c46da599c66" translate="yes" xml:space="preserve">
          <source>Always spawns a new task, so that the &lt;code&gt;call&lt;/code&gt; is never executed on the calling thread.</source>
          <target state="translated">始终产生新任务，以使 &lt;code&gt;call&lt;/code&gt; 永远不会在调用线程上执行。</target>
        </trans-unit>
        <trans-unit id="614ddcbf931903423c230b8f0212d11059c5ec82" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;ValueError&lt;/code&gt; exception will be thrown if no exception exists in the specified Future.</source>
          <target state="translated">一个 &lt;code&gt;ValueError&lt;/code&gt; 异常，如果在指定的未来存在不例外，将引发异常。</target>
        </trans-unit>
        <trans-unit id="ef24e3c1b8f7b901d42c45e46f29ceddb0745dc1" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;export&lt;/code&gt; statement can be used for symbol forwarding so that client modules don't need to import a module's dependencies:</source>
          <target state="translated">一个 &lt;code&gt;export&lt;/code&gt; 语句可以用于符号转发功能，即客户端模块不需要导入一个模块的依赖关系：</target>
        </trans-unit>
        <trans-unit id="f25fd35f79132b361f9e115a28ec0aeef24ee99a" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;if expression&lt;/code&gt; is almost like an if statement, but it is an expression. This feature is similar to &lt;code&gt;ternary operators&lt;/code&gt; in other languages. Example:</source>
          <target state="translated">一个 &lt;code&gt;if expression&lt;/code&gt; 是几乎就像if语句，但它是一个表达式。此功能类似于其他语言中的 &lt;code&gt;ternary operators&lt;/code&gt; 。例子：</target>
        </trans-unit>
        <trans-unit id="73a35d34d5220f34295669a5c8b933dc1ceedeca" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;untyped&lt;/code&gt; parameter means that symbol lookups and type resolution is not performed before the expression is passed to the template. This means that for example &lt;em&gt;undeclared&lt;/em&gt; identifiers can be passed to the template:</source>
          <target state="translated">一个 &lt;code&gt;untyped&lt;/code&gt; 那个符号的查找和类型分辨率不表达之前执行参数的装置被传递给模板。这意味着例如可以将&lt;em&gt;未声明的&lt;/em&gt;标识符传递给模板：</target>
        </trans-unit>
        <trans-unit id="bae34c49da483225476ede34178ee0a4cd7dbb4e" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;if expression&lt;/em&gt; is almost like an if statement, but it is an expression. Example:</source>
          <target state="translated">一个&lt;em&gt;如果表达式&lt;/em&gt;是几乎就像if语句，但它是一个表达式。例：</target>
        </trans-unit>
        <trans-unit id="6913655373469dbc7b3bf423a90b3116ade5a64c" translate="yes" xml:space="preserve">
          <source>An &lt;span id=&quot;identifier_1&quot;&gt;identifier&lt;/span&gt; is a symbol declared as a name for a variable, type, procedure, etc. The region of the program over which a declaration applies is called the &lt;span id=&quot;scope_1&quot;&gt;scope&lt;/span&gt; of the declaration. Scopes can be nested. The meaning of an identifier is determined by the smallest enclosing scope in which the identifier is declared unless overloading resolution rules suggest otherwise.</source>
          <target state="translated">一个&lt;span id=&quot;identifier_1&quot;&gt;标识符&lt;/span&gt;是声明为一个变量，类型，顺序的名称等在其上声明适用被称为节目的区域中的符号&lt;span id=&quot;scope_1&quot;&gt;范围&lt;/span&gt;的声明的。范围可以嵌套。标识符的含义由声明该标识符的最小包围范围确定，除非超载解析规则另有建议。</target>
        </trans-unit>
        <trans-unit id="061ca26b5cf33352ffc7a1f211f8bce9704c6837" translate="yes" xml:space="preserve">
          <source>An &lt;span id=&quot;unchecked-runtime-error_1&quot;&gt;unchecked runtime error&lt;/span&gt; is an error that is not guaranteed to be detected and can cause the subsequent behavior of the computation to be arbitrary. Unchecked runtime errors cannot occur if only &lt;span id=&quot;safe_1&quot;&gt;safe&lt;/span&gt; language features are used and if no runtime checks are disabled.</source>
          <target state="translated">一个&lt;span id=&quot;unchecked-runtime-error_1&quot;&gt;未经检查的运行时错误&lt;/span&gt;是不能保证要被检测和可导致计算的后续行为是任意一个错误。如果仅使用&lt;span id=&quot;safe_1&quot;&gt;安全&lt;/span&gt;语言功能并且未禁用任何运行时检查，则不会发生未经检查的运行时错误。</target>
        </trans-unit>
        <trans-unit id="27d850be93dc755d2b65d8e923239958da9648c2" translate="yes" xml:space="preserve">
          <source>An &lt;span id=&quot;unchecked-runtime-error_1&quot;&gt;unchecked runtime error&lt;/span&gt; is an error that is not guaranteed to be detected, and can cause the subsequent behavior of the computation to be arbitrary. Unchecked runtime errors cannot occur if only &lt;span id=&quot;safe_1&quot;&gt;safe&lt;/span&gt; language features are used.</source>
          <target state="translated">一个&lt;span id=&quot;unchecked-runtime-error_1&quot;&gt;未经检查的运行时错误&lt;/span&gt;是不能保证被检测到，并且可能导致所述计算的后续行为是任意一个错误。如果仅使用&lt;span id=&quot;safe_1&quot;&gt;安全&lt;/span&gt;语言功能，则不会发生未经检查的运行时错误。</target>
        </trans-unit>
        <trans-unit id="d086f48ed32221353a34e9e09e19fc50d2b08517" translate="yes" xml:space="preserve">
          <source>An EOS (or ESSL if socket is an SSL socket) exception is raised if an error occurs.</source>
          <target state="translated">如果发生错误,会引发一个EOS(如果套接字是SSL套接字,则为ESL)异常。</target>
        </trans-unit>
        <trans-unit id="fad595a4ff6c034a05915aa77a9cf525f3217cd5" translate="yes" xml:space="preserve">
          <source>An EOS exception will be raised in the case of a socket error.</source>
          <target state="translated">当出现套接字错误时,将引发EOS异常。</target>
        </trans-unit>
        <trans-unit id="a41070b200aa0a43fc8f9636da9beacac7babdfd" translate="yes" xml:space="preserve">
          <source>An OS-dependent trailing slash is always present at the end of the returned string: &lt;code&gt;\&lt;/code&gt; on Windows and &lt;code&gt;/&lt;/code&gt; on all other OSs.</source>
          <target state="translated">在返回的字符串的末尾始终存在与OS相关的尾部斜杠：Windows上的 &lt;code&gt;\&lt;/code&gt; 和所有其他OS上的 &lt;code&gt;/&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3690729b1f993aa06abd14818e2a3ebd8ae6f4b1" translate="yes" xml:space="preserve">
          <source>An OS-dependent trailing slash is always present at the end of the returned string; &lt;em&gt;` on Windows and `/&lt;/em&gt; on all other OSs.</source>
          <target state="translated">返回字符串的末尾始终存在与OS相关的尾部斜杠；&lt;em&gt;Windows上的`和&lt;/em&gt;其他所有操作系统上的&lt;em&gt;`/&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="77a75598b28ac56217ca4e4f23642a8de53aad21" translate="yes" xml:space="preserve">
          <source>An OSError exception will be raised in the case of a socket error.</source>
          <target state="translated">当出现套接字错误时,将引发一个OSError异常。</target>
        </trans-unit>
        <trans-unit id="fcebf55778fdd55bc0aef73bf199c5931d349101" translate="yes" xml:space="preserve">
          <source>An OpenSSL-compatible list of secure ciphers for &lt;code&gt;intermediate&lt;/code&gt; compatibility per Mozilla's recommendations.</source>
          <target state="translated">根据Mozilla的建议， &lt;code&gt;intermediate&lt;/code&gt; 与OpenSSL兼容的安全密码列表，以实现中间兼容性。</target>
        </trans-unit>
        <trans-unit id="b18dbf60b64cda66a330d893f00943a347f1aec0" translate="yes" xml:space="preserve">
          <source>An OpenSSL-compatible list of secure ciphers for &lt;code&gt;modern&lt;/code&gt; compatibility per Mozilla's recommendations.</source>
          <target state="translated">根据Mozilla的建议，提供与OpenSSL兼容的安全密码列表，以实现 &lt;code&gt;modern&lt;/code&gt; 兼容性。</target>
        </trans-unit>
        <trans-unit id="58e9fa120e4714aa850b21cb9c6254a6941df14a" translate="yes" xml:space="preserve">
          <source>An OpenSSL-compatible list of secure ciphers for &lt;code&gt;old&lt;/code&gt; compatibility per Mozilla's recommendations.</source>
          <target state="translated">一个与OpenSSL兼容的安全密码列表，用于根据Mozilla的建议实现 &lt;code&gt;old&lt;/code&gt; 兼容性。</target>
        </trans-unit>
        <trans-unit id="ac3e1e808c3ac2cd8bce70c2071d873e2b0a45d7" translate="yes" xml:space="preserve">
          <source>An SQL statement that is passed from Nim to an SQL database might be modeled as a string. However, using string templates and filling in the values is vulnerable to the famous &lt;span id=&quot;sql-injection-attack_1&quot;&gt;SQL injection attack&lt;/span&gt;:</source>
          <target state="translated">从Nim传递到SQL数据库的SQL语句可以建模为字符串。但是，使用字符串模板并填充值很容易受到著名的&lt;span id=&quot;sql-injection-attack_1&quot;&gt;SQL注入攻击的攻击&lt;/span&gt;：</target>
        </trans-unit>
        <trans-unit id="cb3c7dd4ccfc76b560ed8bea7cb91f6e590b5de7" translate="yes" xml:space="preserve">
          <source>An SQL statement that is passed from Nim to an SQL database might be modelled as a string. However, using string templates and filling in the values is vulnerable to the famous &lt;span id=&quot;sql-injection-attack_1&quot;&gt;SQL injection attack&lt;/span&gt;:</source>
          <target state="translated">从Nim传递到SQL数据库的SQL语句可以建模为字符串。但是，使用字符串模板并填充值很容易受到著名的&lt;span id=&quot;sql-injection-attack_1&quot;&gt;SQL注入攻击的攻击&lt;/span&gt;：</target>
        </trans-unit>
        <trans-unit id="5abe3bd69e1de1da07178a2dcf83b8a0e9e325db" translate="yes" xml:space="preserve">
          <source>An XML tree consisting of XML nodes.</source>
          <target state="translated">由XML节点组成的XML树。</target>
        </trans-unit>
        <trans-unit id="cbd2fa1e084904d43296b92e52e48ff7123e1dd7" translate="yes" xml:space="preserve">
          <source>An address &lt;code&gt;addr e&lt;/code&gt;, &lt;code&gt;unsafeAddr e&lt;/code&gt; is a path expression.</source>
          <target state="translated">地址 &lt;code&gt;addr e&lt;/code&gt; ， &lt;code&gt;unsafeAddr e&lt;/code&gt; 是路径表达式。</target>
        </trans-unit>
        <trans-unit id="7795a2e689db190d98598b1e86b20a8411fd21d9" translate="yes" xml:space="preserve">
          <source>An alias for &lt;a href=&quot;#copyNimTree,NimNode&quot;&gt;copyNimTree&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#copyNimTree,NimNode&quot;&gt;copyNimTree&lt;/a&gt;的别名。</target>
        </trans-unit>
        <trans-unit id="ae9093985afcfa2beb7d11ea5796b36f8e9f0e1e" translate="yes" xml:space="preserve">
          <source>An alias for &lt;a href=&quot;#toUTF8,Rune&quot;&gt;toUTF8&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#toUTF8,Rune&quot;&gt;toUTF8&lt;/a&gt;的别名。</target>
        </trans-unit>
        <trans-unit id="d6b5b2a52bea6b4b6255ab33c977d4534669e142" translate="yes" xml:space="preserve">
          <source>An alias for &lt;code&gt;&amp;amp;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&amp;amp;&lt;/code&gt; 的别名。</target>
        </trans-unit>
        <trans-unit id="f00085e2b37649dce2a25cb412e211917fdc7f3a" translate="yes" xml:space="preserve">
          <source>An alias for &lt;code&gt;HSlice[T, T]&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;HSlice[T, T]&lt;/code&gt; 的别名。</target>
        </trans-unit>
        <trans-unit id="0aafd9574ef1f09f128ef8bee0667f414aed2e4d" translate="yes" xml:space="preserve">
          <source>An alias for &lt;code&gt;card(x)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;card(x)&lt;/code&gt; 的别名。</target>
        </trans-unit>
        <trans-unit id="959b4a587a6c12a87ac5b29c9adffb9fc202ff33" translate="yes" xml:space="preserve">
          <source>An alias for &lt;code&gt;countup(a, b, 1)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;countup(a, b, 1)&lt;/code&gt; 的别名。</target>
        </trans-unit>
        <trans-unit id="21f8477f1f960888a217819d2f42f5938ea92f4e" translate="yes" xml:space="preserve">
          <source>An alias for &lt;code&gt;ptr float32&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ptr float32&lt;/code&gt; 的别名。</target>
        </trans-unit>
        <trans-unit id="6f0d0c1d9f0d46bf4db307164d8c963a24877861" translate="yes" xml:space="preserve">
          <source>An alias for &lt;code&gt;ptr float64&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ptr float64&lt;/code&gt; 的别名。</target>
        </trans-unit>
        <trans-unit id="9f71273341163aba9e8123c101abbac1d7b95268" translate="yes" xml:space="preserve">
          <source>An alias for &lt;code&gt;ptr int32&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ptr int32&lt;/code&gt; 的别名。</target>
        </trans-unit>
        <trans-unit id="e7ce91b4a997d2fb64eebe61b0642c3424992e0b" translate="yes" xml:space="preserve">
          <source>An alias for &lt;code&gt;ptr int64&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ptr int64&lt;/code&gt; 的别名。</target>
        </trans-unit>
        <trans-unit id="544692451d460228f4efd605a86e7c0dab8a35ee" translate="yes" xml:space="preserve">
          <source>An alias for &lt;em&gt;countup(a, b, 1)&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;countup（a，b，1）&lt;/em&gt;的别名。</target>
        </trans-unit>
        <trans-unit id="936583901537efa6474af706c7cbc7258cf9502a" translate="yes" xml:space="preserve">
          <source>An alias for &lt;em&gt;name&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;name&lt;/em&gt;的别名。</target>
        </trans-unit>
        <trans-unit id="f0b1a1ef6cada9bfa0dc5126e5bf955852c7a8cf" translate="yes" xml:space="preserve">
          <source>An alias for a string to string mapping.</source>
          <target state="translated">字符串到字符串映射的别称。</target>
        </trans-unit>
        <trans-unit id="d96ad4829046669ed22f88ed72333f46e46f422a" translate="yes" xml:space="preserve">
          <source>An alias for copyNimTree().</source>
          <target state="translated">copyNimTree()的别名。</target>
        </trans-unit>
        <trans-unit id="002f21bee61c35000fab0c465633c7a8f89a5b1a" translate="yes" xml:space="preserve">
          <source>An alternative character used by the operating system to separate pathname components, or the same as &lt;a href=&quot;#DirSep&quot;&gt;DirSep&lt;/a&gt; if only one separator character exists. This is set to &lt;code&gt;'/'&lt;/code&gt; on Windows systems where &lt;a href=&quot;#DirSep&quot;&gt;DirSep&lt;/a&gt; is a backslash (&lt;code&gt;'\'&lt;/code&gt;).</source>
          <target state="translated">操作系统用来分隔路径名组件的替代字符，如果仅存在一个分隔符，则与&lt;a href=&quot;#DirSep&quot;&gt;DirSep&lt;/a&gt;相同。在&lt;a href=&quot;#DirSep&quot;&gt;DirSep&lt;/a&gt;是反斜杠（ &lt;code&gt;'\'&lt;/code&gt; ）的Windows系统上，此设置为 &lt;code&gt;'/'&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2bb4f7d6ba1dc1ca472b28bc42274504e162f7f7" translate="yes" xml:space="preserve">
          <source>An alternative character used by the operating system to separate pathname components, or the same as &lt;em&gt;DirSep&lt;/em&gt; if only one separator character exists. This is set to '/' on Windows systems where &lt;em&gt;DirSep&lt;/em&gt; is a backslash.</source>
          <target state="translated">操作系统用来分隔路径名组件的替代字符&lt;em&gt;；&lt;/em&gt;如果仅存在一个分隔符，则与&lt;em&gt;DirSep&lt;/em&gt;相同。在&lt;em&gt;DirSep&lt;/em&gt;是反斜杠的Windows系统上，将其设置为&amp;ldquo; /&amp;rdquo; 。</target>
        </trans-unit>
        <trans-unit id="b10f9786df0315b28bef975ab41acecfb36800af" translate="yes" xml:space="preserve">
          <source>An apostrophe &lt;code&gt;'&lt;/code&gt; followed by an integer &lt;code&gt;i&lt;/code&gt; in the range 0..9 is replaced by the i'th parameter &lt;em&gt;type&lt;/em&gt;. The 0th position is the result type. This can be used to pass types to C++ function templates. Between the &lt;code&gt;'&lt;/code&gt; and the digit an asterisk can be used to get to the base type of the type. (So it &quot;takes away a star&quot; from the type; &lt;code&gt;T*&lt;/code&gt; becomes &lt;code&gt;T&lt;/code&gt;.) Two stars can be used to get to the element type of the element type etc.</source>
          <target state="translated">第i个参数&lt;em&gt;类型&lt;/em&gt;替换了 &lt;code&gt;'&lt;/code&gt; 0'.9 后跟一个整数 &lt;code&gt;i&lt;/code&gt; 的撇号'。第0个位置是结果类型。这可用于将类型传递给C ++函数模板。在 &lt;code&gt;'&lt;/code&gt; 和数字之间，可以使用星号获取该类型的基本类型。 （因此它从类型中&amp;ldquo;夺走了一颗星星； &lt;code&gt;T*&lt;/code&gt; 变为 &lt;code&gt;T&lt;/code&gt; 。&amp;rdquo;）可以使用两颗星星来获取元素类型等的元素类型。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c03a36e70e10adf9514f0958ccf602427aab976e" translate="yes" xml:space="preserve">
          <source>An apostrophe &lt;code&gt;'&lt;/code&gt; followed by an integer &lt;code&gt;i&lt;/code&gt; in the range 0..9 is replaced by the i'th parameter &lt;em&gt;type&lt;/em&gt;. The 0th position is the result type. This can be used to pass types to C++ function templates. Between the &lt;code&gt;'&lt;/code&gt; and the digit, an asterisk can be used to get to the base type of the type. (So it &quot;takes away a star&quot; from the type; &lt;code&gt;T*&lt;/code&gt; becomes &lt;code&gt;T&lt;/code&gt;.) Two stars can be used to get to the element type of the element type etc.</source>
          <target state="translated">第i个参数&lt;em&gt;类型&lt;/em&gt;替换了一个撇号 &lt;code&gt;'&lt;/code&gt; ,后跟0..9范围内的整数 &lt;code&gt;i&lt;/code&gt; 。第0个位置是结果类型。这可用于将类型传递给C ++函数模板。在 &lt;code&gt;'&lt;/code&gt; 和数字之间，可以使用星号获取该类型的基本类型。（因此它从类型中&amp;ldquo;夺走了一颗星星； &lt;code&gt;T*&lt;/code&gt; 变为 &lt;code&gt;T&lt;/code&gt; 。&amp;rdquo;）可以使用两颗星星来获取元素类型等的元素类型。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="bb824cc35be0f255f85608320e99c712d9187e72" translate="yes" xml:space="preserve">
          <source>An array constructor can have explicit indexes for readability:</source>
          <target state="translated">数组构造函数可以有显式索引,以便于读取。</target>
        </trans-unit>
        <trans-unit id="dcf4f417901eafdc569fc787f5454f9027073421" translate="yes" xml:space="preserve">
          <source>An array is a simple fixed length container. Each element in an array has the same type. The array's index type can be any ordinal type.</source>
          <target state="translated">数组是一个简单的固定长度容器。数组中的每个元素都有相同的类型。数组的索引类型可以是任何序数类型。</target>
        </trans-unit>
        <trans-unit id="2bb0838f1de59fe1b1009e5516379cb480056e4d" translate="yes" xml:space="preserve">
          <source>An array type can be defined using the &lt;code&gt;array[size, T]&lt;/code&gt; syntax, or using &lt;code&gt;array[lo..hi, T]&lt;/code&gt; for arrays that start at an index other than zero.</source>
          <target state="translated">可以使用 &lt;code&gt;array[size, T]&lt;/code&gt; 语法定义数组类型，也可以使用从索引非零开始的数组使用 &lt;code&gt;array[lo..hi, T]&lt;/code&gt; 定义数组类型。</target>
        </trans-unit>
        <trans-unit id="00d1d57ff3f35fb4d74599ef1b920f45e23521b6" translate="yes" xml:space="preserve">
          <source>An asynchronous procedure is marked using the &lt;code&gt;{.async.}&lt;/code&gt; pragma. When marking a procedure with the &lt;code&gt;{.async.}&lt;/code&gt; pragma it must have a &lt;code&gt;Future[T]&lt;/code&gt; return type or no return type at all. If you do not specify a return type then &lt;code&gt;Future[void]&lt;/code&gt; is assumed.</source>
          <target state="translated">异步过程使用 &lt;code&gt;{.async.}&lt;/code&gt; 编译指示。在使用 &lt;code&gt;{.async.}&lt;/code&gt; 注标记过程时，它必须具有 &lt;code&gt;Future[T]&lt;/code&gt; 返回类型或根本没有返回类型。如果未指定返回类型，则将使用 &lt;code&gt;Future[void]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="00cfb3b823850859ac087c9650335459fba3693e" translate="yes" xml:space="preserve">
          <source>An at symbol &lt;code&gt;@&lt;/code&gt; is replaced by the remaining arguments, separated by commas.</source>
          <target state="translated">&lt;code&gt;@&lt;/code&gt; 符号会被其余参数替换，并用逗号分隔。</target>
        </trans-unit>
        <trans-unit id="c7fb5b882232e37ef9e5f09cc9c28ae067b4a127" translate="yes" xml:space="preserve">
          <source>An efficient set of &lt;code&gt;int&lt;/code&gt; implemented as a sparse bit set.</source>
          <target state="translated">一个有效的 &lt;code&gt;int&lt;/code&gt; 集，实现为稀疏位集。</target>
        </trans-unit>
        <trans-unit id="4b2e033ba877aaf8286b45d11a814ea58fa8eced" translate="yes" xml:space="preserve">
          <source>An efficient string substitution operator &lt;a href=&quot;#%25,string,StringTableRef,set%5BFormatFlag%5D&quot;&gt;%&lt;/a&gt; for the string table is also provided.</source>
          <target state="translated">还提供了有效的字符串表字符串替换运算符&lt;a href=&quot;#%25,string,StringTableRef,set%5BFormatFlag%5D&quot;&gt;％&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e0a7ceb8146505e07f088182b71243011ca4cc3a" translate="yes" xml:space="preserve">
          <source>An empty &lt;code&gt;discard&lt;/code&gt; statement is often used as a null statement:</source>
          <target state="translated">空的 &lt;code&gt;discard&lt;/code&gt; 语句通常用作null语句：</target>
        </trans-unit>
        <trans-unit id="63b984f97355b1726a5cf0fa4b3612ccc2253bdc" translate="yes" xml:space="preserve">
          <source>An empty &lt;code&gt;raises&lt;/code&gt; list (&lt;code&gt;raises: []&lt;/code&gt;) means that no exception may be raised:</source>
          <target state="translated">空的 &lt;code&gt;raises&lt;/code&gt; 列表（ &lt;code&gt;raises: []&lt;/code&gt; ）表示不会引发任何异常：</target>
        </trans-unit>
        <trans-unit id="3d47e32abe2e2402012d539378c2021368794e6d" translate="yes" xml:space="preserve">
          <source>An empty subscript &lt;code&gt;[]&lt;/code&gt; notation can be used to de-refer a reference, the &lt;code&gt;addr&lt;/code&gt; procedure returns the address of an item. An address is always an untraced reference. Thus the usage of &lt;code&gt;addr&lt;/code&gt; is an &lt;em&gt;unsafe&lt;/em&gt; feature.</source>
          <target state="translated">空下标 &lt;code&gt;[]&lt;/code&gt; 表示法可用于取消引用引用， &lt;code&gt;addr&lt;/code&gt; 过程返回项的地址。地址始终是未跟踪的引用。因此，使用 &lt;code&gt;addr&lt;/code&gt; 是&lt;em&gt;不安全的&lt;/em&gt;功能。</target>
        </trans-unit>
        <trans-unit id="03f5c98cab13364c0bdb7873271e1f3fbcb787f2" translate="yes" xml:space="preserve">
          <source>An empty subscript &lt;code&gt;[]&lt;/code&gt; notation can be used to derefer a reference, the &lt;code&gt;addr&lt;/code&gt; procedure returns the address of an item. An address is always an untraced reference. Thus the usage of &lt;code&gt;addr&lt;/code&gt; is an &lt;em&gt;unsafe&lt;/em&gt; feature.</source>
          <target state="translated">空的下标 &lt;code&gt;[]&lt;/code&gt; 表示法可用于取消引用， &lt;code&gt;addr&lt;/code&gt; 过程返回项的地址。地址始终是未跟踪的引用。因此，使用 &lt;code&gt;addr&lt;/code&gt; 是&lt;em&gt;不安全的&lt;/em&gt;功能。</target>
        </trans-unit>
        <trans-unit id="fd0163ff197f89984c82c49af75d8bfe8b3b9a66" translate="yes" xml:space="preserve">
          <source>An enum can be marked with the &lt;code&gt;pure&lt;/code&gt; pragma so that it's fields are added to a special module specific hidden scope that is only queried as the last attempt. Only non-ambiguous symbols are added to this scope. But one can always access these via type qualification written as &lt;code&gt;MyEnum.value&lt;/code&gt;:</source>
          <target state="translated">枚举可以用 &lt;code&gt;pure&lt;/code&gt; pragma 标记，以便将其字段添加到特定于模块的特殊隐藏范围，该范围仅在最后一次尝试时才查询。仅将明确的符号添加到此范围。但是，人们总是可以通过写为 &lt;code&gt;MyEnum.value&lt;/code&gt; 的类型限定条件来访问它们：</target>
        </trans-unit>
        <trans-unit id="eaad6be6b078620419d11201c663302e39f56608" translate="yes" xml:space="preserve">
          <source>An enum can be marked with the &lt;code&gt;pure&lt;/code&gt; pragma so that its fields are added to a special module-specific hidden scope that is only queried as the last attempt. Only non-ambiguous symbols are added to this scope. But one can always access these via type qualification written as &lt;code&gt;MyEnum.value&lt;/code&gt;:</source>
          <target state="translated">可以用 &lt;code&gt;pure&lt;/code&gt; 编译指示符标记枚举，以便将其字段添加到特定于模块的特殊隐藏范围，该范围仅在最后一次尝试时才查询。仅无歧义的符号添加到此范围。但是，人们总是可以通过写为 &lt;code&gt;MyEnum.value&lt;/code&gt; 的类型限定条件来访问它们：</target>
        </trans-unit>
        <trans-unit id="390d5ff2cbaae78dc0fa4290b4e9610666cc8fdf" translate="yes" xml:space="preserve">
          <source>An enum type can be marked as &lt;code&gt;pure&lt;/code&gt;. Then access of its fields always requires full qualification.</source>
          <target state="translated">枚举类型可以标记为 &lt;code&gt;pure&lt;/code&gt; 。然后，访问其字段始终需要完全资格。</target>
        </trans-unit>
        <trans-unit id="367c78270c2f231073a0357927182872afdf0f63" translate="yes" xml:space="preserve">
          <source>An enum which hold event types</source>
          <target state="translated">一个包含事件类型的枚举</target>
        </trans-unit>
        <trans-unit id="4dcfd8f767ff68c968ba90d84fa6dca78b2ac575" translate="yes" xml:space="preserve">
          <source>An enumeration's symbol can be qualified to avoid ambiguities: &lt;code&gt;Direction.south&lt;/code&gt;.</source>
          <target state="translated">可以对枚举的符号进行限定以避免歧义： &lt;code&gt;Direction.south&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="83a58494419b1a3e524ebfb95e03913553034371" translate="yes" xml:space="preserve">
          <source>An example &lt;code&gt;handleAccept&lt;/code&gt; follows:</source>
          <target state="translated">示例 &lt;code&gt;handleAccept&lt;/code&gt; 如下：</target>
        </trans-unit>
        <trans-unit id="e19bbd77ddbc01db0ebc7ba2f0156d47d7b3cf8a" translate="yes" xml:space="preserve">
          <source>An example of a third party NimScript that can be used as a project-agnostic tool.</source>
          <target state="translated">第三方NimScript的一个例子,它可以作为一个项目无关的工具使用。</target>
        </trans-unit>
        <trans-unit id="f481ad49809e7c27b79d2e6d830283b22c04c1f7" translate="yes" xml:space="preserve">
          <source>An example:</source>
          <target state="translated">一个例子:</target>
        </trans-unit>
        <trans-unit id="e9998341fd216c991313f370f4227cc960a0fb79" translate="yes" xml:space="preserve">
          <source>An exception that is raised if a parsing error occurs.</source>
          <target state="translated">如果发生解析错误,会引发异常。</target>
        </trans-unit>
        <trans-unit id="993744896fbb24a8143d61db93a5b797f2af5f88" translate="yes" xml:space="preserve">
          <source>An explicit ordered enum can have &lt;em&gt;holes&lt;/em&gt;:</source>
          <target state="translated">一个显式的有序枚举可以有&lt;em&gt;漏洞&lt;/em&gt;：</target>
        </trans-unit>
        <trans-unit id="a5f3c80df868038bd59209ddaecef0136b0eb492" translate="yes" xml:space="preserve">
          <source>An exported helper proc that parses the &quot;standard format specifiers&quot;, as specified by the grammar:</source>
          <target state="translated">一个导出的帮助程序,用于解析语法指定的 &quot;标准格式指定符&quot;。</target>
        </trans-unit>
        <trans-unit id="1740d5d24639d030a6825021bc6785735bbaf14c" translate="yes" xml:space="preserve">
          <source>An expression &lt;code&gt;b&lt;/code&gt; can be assigned to an expression &lt;code&gt;a&lt;/code&gt; iff &lt;code&gt;a&lt;/code&gt; is an &lt;code&gt;l-value&lt;/code&gt; and &lt;code&gt;isImplicitlyConvertible(b.typ, a.typ)&lt;/code&gt; holds.</source>
          <target state="translated">的表达式 &lt;code&gt;b&lt;/code&gt; 可以被分配到一个表达 &lt;code&gt;a&lt;/code&gt; 当且仅当 &lt;code&gt;a&lt;/code&gt; 是 &lt;code&gt;l-value&lt;/code&gt; 和 &lt;code&gt;isImplicitlyConvertible(b.typ, a.typ)&lt;/code&gt; 成立。</target>
        </trans-unit>
        <trans-unit id="129cc9980afbc0b6d02dd90e59a7e2eac8eb8d2f" translate="yes" xml:space="preserve">
          <source>An expression &lt;code&gt;b&lt;/code&gt; can be assigned to an expression &lt;code&gt;a&lt;/code&gt; iff &lt;code&gt;a&lt;/code&gt; is an &lt;em&gt;l-value&lt;/em&gt; and &lt;code&gt;isImplicitlyConvertible(b.typ, a.typ)&lt;/code&gt; holds.</source>
          <target state="translated">的表达式 &lt;code&gt;b&lt;/code&gt; 可以被分配到一个表达 &lt;code&gt;a&lt;/code&gt; 当且仅当 &lt;code&gt;a&lt;/code&gt; 是&lt;em&gt;L值&lt;/em&gt;和 &lt;code&gt;isImplicitlyConvertible(b.typ, a.typ)&lt;/code&gt; 成立。</target>
        </trans-unit>
        <trans-unit id="7d2a0ca1f92482471cb1498e046b1a61df5075bd" translate="yes" xml:space="preserve">
          <source>An expression like &lt;code&gt;&amp;amp;&quot;{key} is {value:arg} {{z}}&quot;&lt;/code&gt; is transformed into:</source>
          <target state="translated">像 &lt;code&gt;&amp;amp;&quot;{key} is {value:arg} {{z}}&quot;&lt;/code&gt; 这样的表达式将转换为：</target>
        </trans-unit>
        <trans-unit id="76b9af7a299b61f177bed7560a19266b0bd700fc" translate="yes" xml:space="preserve">
          <source>An expression specifies a computation that produces a value or location. Expressions that produce locations are called &lt;span id=&quot;lminusvalues_1&quot;&gt;l-values&lt;/span&gt;. An l-value can denote either a location or the value the location contains, depending on the context.</source>
          <target state="translated">表达式指定产生值或位置的计算。产生位置的表达式称为&lt;span id=&quot;lminusvalues_1&quot;&gt;l值&lt;/span&gt;。一个l值可以表示一个位置或该位置包含的值，具体取决于上下文。</target>
        </trans-unit>
        <trans-unit id="5cf1e65690ce8b0321d174674e5faf95e0f45bd9" translate="yes" xml:space="preserve">
          <source>An expression specifies a computation that produces a value or location. Expressions that produce locations are called &lt;span id=&quot;lminusvalues_1&quot;&gt;l-values&lt;/span&gt;. An l-value can denote either a location or the value the location contains, depending on the context. Expressions whose values can be determined statically are called &lt;span id=&quot;constant-expressions_1&quot;&gt;constant expressions&lt;/span&gt;; they are never l-values.</source>
          <target state="translated">表达式指定产生值或位置的计算。产生位置的表达式称为&lt;span id=&quot;lminusvalues_1&quot;&gt;l值&lt;/span&gt;。一个l值可以表示一个位置或该位置包含的值，具体取决于上下文。其值可以静态确定的&lt;span id=&quot;constant-expressions_1&quot;&gt;表达式&lt;/span&gt;称为&lt;span id=&quot;constant-expressions_1&quot;&gt;常量表达式&lt;/span&gt; ; 它们永远不是l值。</target>
        </trans-unit>
        <trans-unit id="1e306939f1b61ed5f05365a4a82b6e0e9f803e5d" translate="yes" xml:space="preserve">
          <source>An if expression always results in a value, so the &lt;code&gt;else&lt;/code&gt; part is required. &lt;code&gt;Elif&lt;/code&gt; parts are also allowed.</source>
          <target state="translated">if表达式始终会产生一个值，因此 &lt;code&gt;else&lt;/code&gt; 部分是必需的。 &lt;code&gt;Elif&lt;/code&gt; 部分也允许。</target>
        </trans-unit>
        <trans-unit id="52bb3e3582fbbd15c8e7dfa59ed8c1522b97dbbb" translate="yes" xml:space="preserve">
          <source>An implementation is allowed, but not required to implement even more move optimizations (and the current implementation does not).</source>
          <target state="translated">允许实施,但不要求实施更多的移动优化(当前实施没有)。</target>
        </trans-unit>
        <trans-unit id="55f00c59e69693d5b27bf05aeea67c1b5656b713" translate="yes" xml:space="preserve">
          <source>An implementation should always use the maximum precision available to evaluate floating pointer values at compile time; this means expressions like &lt;code&gt;0.09'f32 + 0.01'f32 == 0.09'f64 + 0.01'f64&lt;/code&gt; are true.</source>
          <target state="translated">在编译时，实现应始终使用最大的精度来评估浮动指针值。这意味着像 &lt;code&gt;0.09'f32 + 0.01'f32 == 0.09'f64 + 0.01'f64&lt;/code&gt; 这样的表达式为真。</target>
        </trans-unit>
        <trans-unit id="d6942353b7235c1c4c99f2905af32ba03130a9b6" translate="yes" xml:space="preserve">
          <source>An implementation should always use the maximum precision available to evaluate floating pointer values during semantic analysis; this means expressions like &lt;code&gt;0.09'f32 + 0.01'f32 == 0.09'f64 + 0.01'f64&lt;/code&gt; that are evaluating during constant folding are true.</source>
          <target state="translated">在语义分析期间，实现应始终使用最大的精度来评估浮动指针值。这意味着在恒定折叠期间求值的表达式如 &lt;code&gt;0.09'f32 + 0.01'f32 == 0.09'f64 + 0.01'f64&lt;/code&gt; 是正确的。</target>
        </trans-unit>
        <trans-unit id="92ea9795e8ce3c7c45d40d4ccbcfe9496b8bf2f5" translate="yes" xml:space="preserve">
          <source>An input and an output parameter should not be aliased.</source>
          <target state="translated">一个输入和一个输出参数不应该被别名。</target>
        </trans-unit>
        <trans-unit id="17e0a9097c3ec985d934476c81741a7015f09640" translate="yes" xml:space="preserve">
          <source>An input parameter should not be aliased with a global or thread local variable updated by the called proc.</source>
          <target state="translated">输入参数不应该与被调用的proc更新的全局或线程局部变量进行别名。</target>
        </trans-unit>
        <trans-unit id="4faf8ef86d99d8f87188a85418d2cafbed7c672a" translate="yes" xml:space="preserve">
          <source>An integer with the column you are going to query. For the compiler columns start at &lt;strong&gt;0&lt;/strong&gt;.</source>
          <target state="translated">您要查询的列的整数。对于编译器，列从&lt;strong&gt;0&lt;/strong&gt;开始。</target>
        </trans-unit>
        <trans-unit id="7140df7bbe5e3e07dff6576529cef23b438e6cf3" translate="yes" xml:space="preserve">
          <source>An integer with the column you are going to query. For the compiler columns start at zero, so the first column will be &lt;strong&gt;0&lt;/strong&gt; and the last in an 80 column terminal will be &lt;strong&gt;79&lt;/strong&gt;.</source>
          <target state="translated">您要查询的列的整数。对于编译器，列从零开始，因此第一列将为&lt;strong&gt;0&lt;/strong&gt;，而80列终端的最后一列将为&lt;strong&gt;79&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="58c18cab7c4720f0e3aa95f69ca0b844006c41f0" translate="yes" xml:space="preserve">
          <source>An integer with the line you are going to query. For the compiler lines start at &lt;strong&gt;1&lt;/strong&gt;.</source>
          <target state="translated">您要查询的行的整数。对于编译器行，从&lt;strong&gt;1&lt;/strong&gt;开始。</target>
        </trans-unit>
        <trans-unit id="fd63b4dca2c3b56a63f528ea8506804126dab43c" translate="yes" xml:space="preserve">
          <source>An iterator is similar to a procedure, except that it can be called in the context of a &lt;code&gt;for&lt;/code&gt; loop. Iterators provide a way to specify the iteration over an abstract type. A key role in the execution of a &lt;code&gt;for&lt;/code&gt; loop plays the &lt;code&gt;yield&lt;/code&gt; statement in the called iterator. Whenever a &lt;code&gt;yield&lt;/code&gt; statement is reached the data is bound to the &lt;code&gt;for&lt;/code&gt; loop variables and control continues in the body of the &lt;code&gt;for&lt;/code&gt; loop. The iterator's local variables and execution state are automatically saved between calls. Example:</source>
          <target state="translated">迭代器类似于过程，不同之处在于可以在 &lt;code&gt;for&lt;/code&gt; 循环的上下文中调用它。迭代器提供了一种在抽象类型上指定迭代的方法。 &lt;code&gt;for&lt;/code&gt; 循环执行中的关键作用是在称为迭代器的 &lt;code&gt;yield&lt;/code&gt; 语句中。每当到达 &lt;code&gt;yield&lt;/code&gt; 语句时，数据就会绑定到 &lt;code&gt;for&lt;/code&gt; 循环变量，并且控制将继续在 &lt;code&gt;for&lt;/code&gt; 循环的主体中进行。迭代器的局部变量和执行状态在两次调用之间自动保存。例：</target>
        </trans-unit>
        <trans-unit id="24cf8c2497716b71cb65c781ec360d22d18214d5" translate="yes" xml:space="preserve">
          <source>An l-value matches &lt;code&gt;var T&lt;/code&gt; and &lt;code&gt;out T&lt;/code&gt; equally well, hence the following is ambiguous:</source>
          <target state="translated">l值对 &lt;code&gt;var T&lt;/code&gt; 和 &lt;code&gt;out T&lt;/code&gt; 的匹配良好，因此以下含义不明确：</target>
        </trans-unit>
        <trans-unit id="1f5ff3abd757e3cba00a39f18b56b5fb6446a8c0" translate="yes" xml:space="preserve">
          <source>An object type can be marked with the &lt;code&gt;pure&lt;/code&gt; pragma so that its type field which is used for runtime type identification is omitted. This used to be necessary for binary compatibility with other compiled languages.</source>
          <target state="translated">可以用 &lt;code&gt;pure&lt;/code&gt; 编译指示符标记对象类型，以便省略用于运行时类型标识的对象类型字段。这对于与其他编译语言进行二进制兼容性是必需的。</target>
        </trans-unit>
        <trans-unit id="2e8278ca51d6d95aa64a5e6c057a546e2ca28c42" translate="yes" xml:space="preserve">
          <source>An object which holds descriptors to be checked for read/write status</source>
          <target state="translated">一个存放描述符的对象,用于检查读/写状态。</target>
        </trans-unit>
        <trans-unit id="3274465cde86ef19fbd6e85a8dde25fac63bf653" translate="yes" xml:space="preserve">
          <source>An object which holds result for descriptor</source>
          <target state="translated">为描述符保存结果的对象</target>
        </trans-unit>
        <trans-unit id="e62ca354a533c308819dea987dbbf454b1323735" translate="yes" xml:space="preserve">
          <source>An object which holds user defined event</source>
          <target state="translated">一个持有用户定义事件的对象</target>
        </trans-unit>
        <trans-unit id="004526c446f1ac6d78516b74ee9cfa40b5941993" translate="yes" xml:space="preserve">
          <source>An optional timeout can be specified in milliseconds, if reading from the</source>
          <target state="translated">可以指定一个可选的超时时间,如果从</target>
        </trans-unit>
        <trans-unit id="aa761af15969e50c3fbec49ad3e2f8409cbdbbc6" translate="yes" xml:space="preserve">
          <source>An optional timeout can be specified in milliseconds, if skipping the bytes takes longer than specified a TimeoutError exception will be raised.</source>
          <target state="translated">可以指定一个可选的超时时间,单位是毫秒,如果跳过字节的时间比指定的时间长,就会引发一个TimeoutError异常。</target>
        </trans-unit>
        <trans-unit id="be0cf6034a987ab54cdc28a91621a1407148ad61" translate="yes" xml:space="preserve">
          <source>An optional timeout can be specified in milliseconds, if skipping the bytes takes longer than specified an ETimeout exception will be raised.</source>
          <target state="translated">可以指定一个可选的超时时间,单位是毫秒,如果跳过字节的时间比指定的时间长,将引发一个ETimeout异常。</target>
        </trans-unit>
        <trans-unit id="1436ea667171f8c043927d94a1771aba02c31130" translate="yes" xml:space="preserve">
          <source>An optional type that stores its value and state separately in a boolean.</source>
          <target state="translated">一个可选的类型,将其值和状态分别存储在一个布尔值中。</target>
        </trans-unit>
        <trans-unit id="b067be400ecce95bf0995a66c8c39a2c3b939878" translate="yes" xml:space="preserve">
          <source>An output parameter should never be aliased with a global or thread local variable referenced by the called proc.</source>
          <target state="translated">输出参数绝对不能与被调用的proc引用的全局变量或线程局部变量进行别名。</target>
        </trans-unit>
        <trans-unit id="1492892ce7573ee3544c47d10217feac9a1ffe27" translate="yes" xml:space="preserve">
          <source>Anchor: Matches at the end of the input. No character is consumed. Same as &lt;code&gt;!.&lt;/code&gt;.</source>
          <target state="translated">锚点：在输入末尾匹配。不会消耗任何字符。与 &lt;code&gt;!.&lt;/code&gt; 相同。。</target>
        </trans-unit>
        <trans-unit id="28501d5ba1b7346ee45610593888631bf0f75364" translate="yes" xml:space="preserve">
          <source>Anchor: Matches at the start of the input. No character is consumed.</source>
          <target state="translated">锚。匹配在输入的开始。不消耗字符。</target>
        </trans-unit>
        <trans-unit id="d5b80e8f8af7973d49e632e415ee520559b6880c" translate="yes" xml:space="preserve">
          <source>And &lt;code&gt;main&lt;/code&gt; imports &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;foo/x&lt;/code&gt; is imported. If &lt;code&gt;other&lt;/code&gt; imports &lt;code&gt;x&lt;/code&gt; then both &lt;code&gt;$lib/x.nim&lt;/code&gt; and &lt;code&gt;$lib/bar/x.nim&lt;/code&gt; match and so the compiler should reject it. Currently however this check is not implemented and instead the first matching file is used.</source>
          <target state="translated">并且 &lt;code&gt;main&lt;/code&gt; 导入 &lt;code&gt;x&lt;/code&gt; ， &lt;code&gt;foo/x&lt;/code&gt; 被导入。如果 &lt;code&gt;other&lt;/code&gt; 输入 &lt;code&gt;x&lt;/code&gt; 则 &lt;code&gt;$lib/x.nim&lt;/code&gt; 和 &lt;code&gt;$lib/bar/x.nim&lt;/code&gt; 匹配，因此编译器应拒绝它。但是，当前尚未执行此检查，而是使用了第一个匹配文件。</target>
        </trans-unit>
        <trans-unit id="6086412d7affac9b3c25d84027f831a4864be34b" translate="yes" xml:space="preserve">
          <source>And &lt;code&gt;main&lt;/code&gt; imports &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;foo/x&lt;/code&gt; is imported. If &lt;code&gt;other&lt;/code&gt; imports &lt;code&gt;x&lt;/code&gt; then both &lt;code&gt;$lib/x.nim&lt;/code&gt; and &lt;code&gt;$lib/bar/x.nim&lt;/code&gt; match but &lt;code&gt;$lib/x.nim&lt;/code&gt; is used as it is the first match.</source>
          <target state="translated">并且 &lt;code&gt;main&lt;/code&gt; 导入 &lt;code&gt;x&lt;/code&gt; ， &lt;code&gt;foo/x&lt;/code&gt; 被导入。如果 &lt;code&gt;other&lt;/code&gt; 输入 &lt;code&gt;x&lt;/code&gt; ,则 &lt;code&gt;$lib/x.nim&lt;/code&gt; 和 &lt;code&gt;$lib/bar/x.nim&lt;/code&gt; 匹配，但是使用 &lt;code&gt;$lib/x.nim&lt;/code&gt; ，因为这是第一个匹配项。</target>
        </trans-unit>
        <trans-unit id="242f34bf16bfc5e83d5742e55f63b87c019f679a" translate="yes" xml:space="preserve">
          <source>And copy the executable somewhere in your &lt;code&gt;$PATH&lt;/code&gt;.</source>
          <target state="translated">并将可执行文件复制到 &lt;code&gt;$PATH&lt;/code&gt; 某个位置。</target>
        </trans-unit>
        <trans-unit id="83dda4bc1c55dc87decca365a7ad42665d8106b1" translate="yes" xml:space="preserve">
          <source>And for a debug version compatible with GDB:</source>
          <target state="translated">而对于与GDB兼容的调试版本。</target>
        </trans-unit>
        <trans-unit id="514cf3e6609f00e815263ec4ce18e84d001f501a" translate="yes" xml:space="preserve">
          <source>And predicate: Indicate success if expression &lt;code&gt;E&lt;/code&gt; matches the text ahead; otherwise indicate failure. Do not consume any text.</source>
          <target state="translated">并断言：如果表达式 &lt;code&gt;E&lt;/code&gt; 与前面的文本匹配，则表明成功；如果表达式E与前面的文本匹配，则表明成功；否则表示失败。不要消耗任何文字。</target>
        </trans-unit>
        <trans-unit id="4e8296500ed287ca2f86dd1c2fab187b68fe5d29" translate="yes" xml:space="preserve">
          <source>And predicate: Indicate success if expression &lt;em&gt;E&lt;/em&gt; matches the text ahead; otherwise indicate failure. Do not consume any text.</source>
          <target state="translated">和谓词：如果表达式&lt;em&gt;E&lt;/em&gt;与前面的文本匹配，则表明成功；否则表示失败。不要消耗任何文字。</target>
        </trans-unit>
        <trans-unit id="47b8afc9ca38e34f60b039e58bc4522a4fe464da" translate="yes" xml:space="preserve">
          <source>And so is::</source>
          <target state="translated">所以是:。</target>
        </trans-unit>
        <trans-unit id="dd21179e471067255e31c8a35037ea42bc51b5d1" translate="yes" xml:space="preserve">
          <source>And the following code:</source>
          <target state="translated">还有下面的代码。</target>
        </trans-unit>
        <trans-unit id="13074a21c761f8c2e18dbd0487b69e0b1f687b80" translate="yes" xml:space="preserve">
          <source>Android 10.0</source>
          <target state="translated">安卓10.0</target>
        </trans-unit>
        <trans-unit id="bced9cc08c3939a0e0d679456c7b2c96155e69fa" translate="yes" xml:space="preserve">
          <source>Android 2.3</source>
          <target state="translated">Android 2.3</target>
        </trans-unit>
        <trans-unit id="8ab464014c26dbdf5f702390fa9ab23c39f0578d" translate="yes" xml:space="preserve">
          <source>Android 4.4.2</source>
          <target state="translated">Android 4.4.2</target>
        </trans-unit>
        <trans-unit id="529975d2ca1b9c8b1f9dc8715723302d776e3685" translate="yes" xml:space="preserve">
          <source>Annotating procs with raised exceptions</source>
          <target state="translated">对带有突起异常的procs进行注释</target>
        </trans-unit>
        <trans-unit id="1372df72c3414caae306a6854fbd73da2739c232" translate="yes" xml:space="preserve">
          <source>Anonymous Procs</source>
          <target state="translated">匿名程序</target>
        </trans-unit>
        <trans-unit id="fc69ddcac99b9b9a8d29c74edd5dd97109c0f888" translate="yes" xml:space="preserve">
          <source>Another common example is this:</source>
          <target state="translated">另一个常见的例子是这样的。</target>
        </trans-unit>
        <trans-unit id="46de23dafaa5135d298c4e6932bfd58f0a55fcd3" translate="yes" xml:space="preserve">
          <source>Another way is to make Nim invoke a cross compiler toolchain:</source>
          <target state="translated">另一种方法是让Nim调用一个交叉编译器工具链。</target>
        </trans-unit>
        <trans-unit id="220b3fd15cb7730c1f91330b6bd071c4acf9137b" translate="yes" xml:space="preserve">
          <source>Another way to branch is provided by the case statement. A case statement is a multi-branch:</source>
          <target state="translated">另一种分支方式是由case语句提供的。一个case语句就是一个多分支。</target>
        </trans-unit>
        <trans-unit id="b109a7f72d501d6581c64b2e20010ee624b143d1" translate="yes" xml:space="preserve">
          <source>Another way to do the same without &lt;code&gt;when&lt;/code&gt; is to leave the task of picking the appropriate code to a secondary proc which you overload for each field type and pass the &lt;em&gt;value&lt;/em&gt; to.</source>
          <target state="translated">另一种方法就是不一样 &lt;code&gt;when&lt;/code&gt; 是离开挑选合适的代码到你重载为每个字段类型的次级PROC的任务，并通过&lt;em&gt;价值&lt;/em&gt;来。</target>
        </trans-unit>
        <trans-unit id="cdcc64fe4174864c656f8d5ecbd49e1c1178af4e" translate="yes" xml:space="preserve">
          <source>Another way to look at the method call syntax is that it provides the missing postfix notation.</source>
          <target state="translated">另一种看待方法调用语法的方法是,它提供了缺失的postfix符号。</target>
        </trans-unit>
        <trans-unit id="a741689c8b0db1dc353a46642a34688e7e01c9fe" translate="yes" xml:space="preserve">
          <source>Any Unicode character: If there is an UTF-8 character ahead, consume it and indicate success. Otherwise indicate failure.</source>
          <target state="translated">任何Unicode字符。如果前面有一个UTF-8字符,则消耗它并表示成功。否则表示失败。</target>
        </trans-unit>
        <trans-unit id="5778ef8422665afffa8cd59a1ebfe6af7a70d367" translate="yes" xml:space="preserve">
          <source>Any character: If there is a character ahead, consume it and indicate success. Otherwise (that is, at the end of input) indicate failure.</source>
          <target state="translated">任何角色。如果前面有一个字符,就把它吃掉,并表示成功。否则(即在输入结束时)表示失败。</target>
        </trans-unit>
        <trans-unit id="7358bbc6ca3777f85150f64affeb40b274702a17" translate="yes" xml:space="preserve">
          <source>Any comments which are preceded by a double-hash (##), are interpreted as documentation. Comments are parsed as RST (see &lt;a href=&quot;http://docutils.sourceforge.net/docs/user/rst/quickref.html&quot;&gt;reference&lt;/a&gt;), providing Nim module authors the ability to easily generate richly formatted documentation with only their well-documented code.</source>
          <target state="translated">任何以双哈希（##）开头的注释均被解释为文档。注释被解析为RST（请参阅&lt;a href=&quot;http://docutils.sourceforge.net/docs/user/rst/quickref.html&quot;&gt;参考资料&lt;/a&gt;），从而使Nim模块作者仅使用他们有据可查的代码即可轻松生成格式丰富的文档。</target>
        </trans-unit>
        <trans-unit id="7a0e7fbfcaa080ee5b3ea5abcdb110b3936f6cd0" translate="yes" xml:space="preserve">
          <source>Any mutation to an object does count as a side effect if that object is reachable via a parameter that is not declared as a &lt;code&gt;var&lt;/code&gt; parameter.</source>
          <target state="translated">如果通过未声明为 &lt;code&gt;var&lt;/code&gt; 参数的参数可以访问该对象，则对该对象的任何突变都将被视为副作用。</target>
        </trans-unit>
        <trans-unit id="9e859eb61aa46455ae8439cc09bd7c3fb497c718" translate="yes" xml:space="preserve">
          <source>Any operator can be called like an ordinary proc with the '&lt;code&gt;opr&lt;/code&gt;' notation. (Thus an operator can have more than two parameters):</source>
          <target state="translated">任何运算符都可以像带有&amp;ldquo; &lt;code&gt;opr&lt;/code&gt; &amp;rdquo;符号的普通proc一样被调用。（因此，操作员可以具有两个以上的参数）：</target>
        </trans-unit>
        <trans-unit id="91e820fd709a7f87728034af624c9132692282ae" translate="yes" xml:space="preserve">
          <source>Any operator can be called like an ordinary proc with the '&lt;em&gt;opr&lt;/em&gt;' notation. (Thus an operator can have more than two parameters):</source>
          <target state="translated">任何运算符都可以像带有&amp;ldquo; &lt;em&gt;opr&lt;/em&gt; &amp;rdquo;符号的普通proc一样被调用。（因此，操作员可以具有两个以上的参数）：</target>
        </trans-unit>
        <trans-unit id="28a8d44708b00ee5f8ab5f8950f4590e672372e9" translate="yes" xml:space="preserve">
          <source>Any previously stored value will be overwritten.</source>
          <target state="translated">任何先前存储的值都会被覆盖。</target>
        </trans-unit>
        <trans-unit id="85cdc7b1f239ca6691d5ad4bd7ee32149be2368a" translate="yes" xml:space="preserve">
          <source>Any statements following the &lt;code&gt;defer&lt;/code&gt; in the current block will be considered to be in an implicit try block:</source>
          <target state="translated">在当前块中，在 &lt;code&gt;defer&lt;/code&gt; 之后的所有语句都将被视为在隐式try块中：</target>
        </trans-unit>
        <trans-unit id="f6cede9c40103cfeb38206a514d0e207b6286657" translate="yes" xml:space="preserve">
          <source>Any user defined destructors</source>
          <target state="translated">任何用户定义的析构器</target>
        </trans-unit>
        <trans-unit id="e21dc240e738fabd5754c4089fede48b262d0589" translate="yes" xml:space="preserve">
          <source>AnyPath:</source>
          <target state="translated">AnyPath:</target>
        </trans-unit>
        <trans-unit id="474bae604f6e9971bd49456c68cefe4610021141" translate="yes" xml:space="preserve">
          <source>Apart from &lt;code&gt;spawn&lt;/code&gt; and &lt;code&gt;parallel&lt;/code&gt; Nim also provides all the common low level concurrency mechanisms like locks, atomic intrinsics or condition variables.</source>
          <target state="translated">除了 &lt;code&gt;spawn&lt;/code&gt; 和 &lt;code&gt;parallel&lt;/code&gt; Nim还提供所有常见的低级并发机制，例如锁，原子内在函数或条件变量。</target>
        </trans-unit>
        <trans-unit id="562f1ef0862bc54a9d91c121544eee328c801e91" translate="yes" xml:space="preserve">
          <source>Apart from a few built-in keyword operators such as &lt;code&gt;and&lt;/code&gt;, &lt;code&gt;or&lt;/code&gt;, &lt;code&gt;not&lt;/code&gt;, operators always consist of these characters: &lt;code&gt;+ - * \ / &amp;lt; &amp;gt; = @ $ ~ &amp;amp; % ! ? ^ . |&lt;/code&gt;</source>
          <target state="translated">除了少数内置关键字运营商，如 &lt;code&gt;and&lt;/code&gt; ， &lt;code&gt;or&lt;/code&gt; ， &lt;code&gt;not&lt;/code&gt; ，运营商总是由这些字符： &lt;code&gt;+ - * \ / &amp;lt; &amp;gt; = @ $ ~ &amp;amp; % ! ? ^ . |&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bfe80b93d1b3cc277c929cdfd0838f7556135094" translate="yes" xml:space="preserve">
          <source>Apart from built-in operations like array indexing, memory allocation, etc. the &lt;code&gt;raise&lt;/code&gt; statement is the only way to raise an exception.</source>
          <target state="translated">除了诸如数组索引，内存分配等内置操作外， &lt;code&gt;raise&lt;/code&gt; 语句是引发异常的唯一方法。</target>
        </trans-unit>
        <trans-unit id="7dc1626458ca624671bbd7eb79e937465433fdf8" translate="yes" xml:space="preserve">
          <source>Apart from strings you can also encode lists of integers or characters:</source>
          <target state="translated">除了字符串,你还可以对整数或字符的列表进行编码。</target>
        </trans-unit>
        <trans-unit id="aafd7f63cf0cf31a35bff642569ecbe5c87f627c" translate="yes" xml:space="preserve">
          <source>Apart from the minimal syntactic sugar the language core does not need to know about tables.</source>
          <target state="translated">除了最起码的语法糖,语言核心不需要知道表。</target>
        </trans-unit>
        <trans-unit id="e3b1dd548816f4827df0bad613bad688c2eb8bbe" translate="yes" xml:space="preserve">
          <source>Apo:</source>
          <target state="translated">Apo:</target>
        </trans-unit>
        <trans-unit id="16fba008b8a30cf646cf2acebb7e1cdfbd153d1f" translate="yes" xml:space="preserve">
          <source>Appends (adds to the end) a node &lt;code&gt;n&lt;/code&gt; to &lt;code&gt;L&lt;/code&gt;. Efficiency: O(1).</source>
          <target state="translated">附加（增加的端部）的节点 &lt;code&gt;n&lt;/code&gt; 到 &lt;code&gt;L&lt;/code&gt; 。效率：O（1）。</target>
        </trans-unit>
        <trans-unit id="e000dd9fba3be7dd379ffde7cc907cf28fd4ddd2" translate="yes" xml:space="preserve">
          <source>Appends (adds to the end) a value to &lt;code&gt;L&lt;/code&gt;. Efficiency: O(1).</source>
          <target state="translated">附加（增加的端部）的值到 &lt;code&gt;L&lt;/code&gt; 。效率：O（1）。</target>
        </trans-unit>
        <trans-unit id="feb580856272ad85df8745f41fd2d502b274c0be" translate="yes" xml:space="preserve">
          <source>Appends &lt;code&gt;x&lt;/code&gt; to string &lt;code&gt;s&lt;/code&gt; in place, applying quoting and escaping if &lt;code&gt;x&lt;/code&gt; is a string or char.</source>
          <target state="translated">将 &lt;code&gt;x&lt;/code&gt; 附加在适当的字符串 &lt;code&gt;s&lt;/code&gt; 上，如果 &lt;code&gt;x&lt;/code&gt; 是字符串或char ，则应用引号和转义。</target>
        </trans-unit>
        <trans-unit id="c406699971968f882acde68ff17c4b9e61930126" translate="yes" xml:space="preserve">
          <source>Appends &lt;code&gt;y&lt;/code&gt; to &lt;code&gt;x&lt;/code&gt; in place.</source>
          <target state="translated">将 &lt;code&gt;y&lt;/code&gt; 附加到 &lt;code&gt;x&lt;/code&gt; 的适当位置。</target>
        </trans-unit>
        <trans-unit id="86d0496a927c4a27939c0fe3200738c8416afc23" translate="yes" xml:space="preserve">
          <source>Appends &lt;em&gt;x&lt;/em&gt; to string &lt;em&gt;s&lt;/em&gt; in place, applying quoting and escaping if &lt;em&gt;x&lt;/em&gt; is a string or char. See &lt;a href=&quot;system#addEscapedChar&quot;&gt;addEscapedChar&lt;/a&gt; for the escaping scheme. When &lt;em&gt;x&lt;/em&gt; is a string, characters in the range &lt;code&gt;{\128..\255}&lt;/code&gt; are never escaped so that multibyte UTF-8 characters are untouched (note that this behavior is different from &lt;code&gt;addEscapedChar&lt;/code&gt;).</source>
          <target state="translated">将&lt;em&gt;x&lt;/em&gt;附加在适当的字符串&lt;em&gt;s&lt;/em&gt;上，如果&lt;em&gt;x&lt;/em&gt;是字符串或char ，则应用引号和转义。有关转义方案，请参见&lt;a href=&quot;system#addEscapedChar&quot;&gt;addEscapedChar&lt;/a&gt;。当&lt;em&gt;x&lt;/em&gt;是字符串时，永远不会转义 &lt;code&gt;{\128..\255}&lt;/code&gt; 范围内的字符，以便不影响多字节UTF-8字符（请注意，此行为不同于 &lt;code&gt;addEscapedChar&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="646ba0c86d2da62ac809b41c7876c8d4d437f4fd" translate="yes" xml:space="preserve">
          <source>Appends &lt;em&gt;y&lt;/em&gt; to &lt;em&gt;x&lt;/em&gt; in place</source>
          <target state="translated">追加&lt;em&gt;&amp;Yuml;&lt;/em&gt;以&lt;em&gt;X&lt;/em&gt;代替</target>
        </trans-unit>
        <trans-unit id="5a44cb6e95afb57a187dfd7f616458540348a25f" translate="yes" xml:space="preserve">
          <source>Appends element y to the end of the sequence.</source>
          <target state="translated">将元素y添加到序列的末端。</target>
        </trans-unit>
        <trans-unit id="621c0cff6d7cb368d8e84f223d0bb258c1851898" translate="yes" xml:space="preserve">
          <source>Appends element y to the end of the sequence. Requires copying of the sequence</source>
          <target state="translated">将元素y添加到序列的末端。需要复制序列</target>
        </trans-unit>
        <trans-unit id="b911c2df77e9ea1d563e4a7ebb6593fb8d45a3d3" translate="yes" xml:space="preserve">
          <source>Appends in place to a string.</source>
          <target state="translated">对一个字符串进行原地追加。</target>
        </trans-unit>
        <trans-unit id="4b93e2750d5e019c95354307daa55b9ae9ae1eb1" translate="yes" xml:space="preserve">
          <source>Appends url to url.</source>
          <target state="translated">将url附加到url上。</target>
        </trans-unit>
        <trans-unit id="41334dc65163a83119249bdd2d0725382bf90b0b" translate="yes" xml:space="preserve">
          <source>Applies &lt;code&gt;op&lt;/code&gt; to each of the &lt;strong&gt;atomic&lt;/strong&gt; literals like &lt;code&gt;3&lt;/code&gt; or &lt;code&gt;&quot;abc&quot;&lt;/code&gt; in the specified &lt;code&gt;constructor&lt;/code&gt; AST. This can be used to map every array element to some target type:</source>
          <target state="translated">将 &lt;code&gt;op&lt;/code&gt; 应用于指定 &lt;code&gt;constructor&lt;/code&gt; AST中的每个&lt;strong&gt;原子&lt;/strong&gt;文字，如 &lt;code&gt;3&lt;/code&gt; 或 &lt;code&gt;&quot;abc&quot;&lt;/code&gt; 。这可以用于将每个数组元素映射到某种目标类型：</target>
        </trans-unit>
        <trans-unit id="7427ab152044cf1b6551f68794438b07d3820483" translate="yes" xml:space="preserve">
          <source>Applies &lt;code&gt;op&lt;/code&gt; to every item in &lt;code&gt;s&lt;/code&gt; modifying it directly.</source>
          <target state="translated">将 &lt;code&gt;op&lt;/code&gt; 应用于 &lt;code&gt;s&lt;/code&gt; 中的每个项目，直接对其进行修改。</target>
        </trans-unit>
        <trans-unit id="8b39b7cf4b0a60e8defe6d54cb8868dcdb0f1e4b" translate="yes" xml:space="preserve">
          <source>Applies &lt;em&gt;op&lt;/em&gt; to every item in &lt;em&gt;s&lt;/em&gt; modifying it directly.</source>
          <target state="translated">将&lt;em&gt;op&lt;/em&gt;应用于&lt;em&gt;s中的&lt;/em&gt;每个项目，直接对其进行修改。</target>
        </trans-unit>
        <trans-unit id="f7f98f61e331b2c9c311f3be85b2d106e23d53da" translate="yes" xml:space="preserve">
          <source>Applies a &lt;code&gt;callback&lt;/code&gt; function to the value of the &lt;code&gt;Option&lt;/code&gt; and returns an &lt;code&gt;Option&lt;/code&gt; containing the new value.</source>
          <target state="translated">将 &lt;code&gt;callback&lt;/code&gt; 函数应用于 &lt;code&gt;Option&lt;/code&gt; 的值，并返回包含新值的 &lt;code&gt;Option&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="08e08e73f7d5cf1f2868300bfffc38afeef31e63" translate="yes" xml:space="preserve">
          <source>Applies a &lt;code&gt;callback&lt;/code&gt; function to the value of the &lt;code&gt;Option&lt;/code&gt;, if it has one.</source>
          <target state="translated">将 &lt;code&gt;callback&lt;/code&gt; 函数应用于 &lt;code&gt;Option&lt;/code&gt; 的值（如果有）。</target>
        </trans-unit>
        <trans-unit id="2070a04b99b90c4dbdf3f880dc817f26a106e8a6" translate="yes" xml:space="preserve">
          <source>Applies a &lt;code&gt;callback&lt;/code&gt; to the value of the &lt;code&gt;Option&lt;/code&gt;.</source>
          <target state="translated">将 &lt;code&gt;callback&lt;/code&gt; 应用于 &lt;code&gt;Option&lt;/code&gt; 的值。</target>
        </trans-unit>
        <trans-unit id="47c68a697222d8231db69fecdc76aa3f8118fca0" translate="yes" xml:space="preserve">
          <source>Applies a callback to the value in this Option</source>
          <target state="translated">将回调应用于此选项中的值。</target>
        </trans-unit>
        <trans-unit id="1f6c6510cdda5cd1b191679d2ebcc3574091831b" translate="yes" xml:space="preserve">
          <source>Applies a callback to the value in this Option and returns an option containing the new value. If this option is None, None will be returned</source>
          <target state="translated">对该选项中的值进行回调,并返回一个包含新值的选项。如果该选项为None,则返回None。</target>
        </trans-unit>
        <trans-unit id="4405334856a221170be55f8b9f5688d6a0be9c57" translate="yes" xml:space="preserve">
          <source>Applies a callback to the value in this Option and returns an option containing the new value. If this option is None, None will be returned. Similar to &lt;code&gt;map&lt;/code&gt;, with the difference that the callback returns an Option, not a raw value. This allows multiple procs with a signature of &lt;code&gt;A -&amp;gt; Option[B]&lt;/code&gt; (including A = B) to be chained together.</source>
          <target state="translated">将回调应用于此Option中的值，并返回包含新值的选项。如果此选项为None，则将返回None。与 &lt;code&gt;map&lt;/code&gt; 相似，区别在于回调返回的是Option而不是原始值。这允许将具有 &lt;code&gt;A -&amp;gt; Option[B]&lt;/code&gt; （包括A = B）签名的多个proc 链接在一起。</target>
        </trans-unit>
        <trans-unit id="465dd40623dd93f42a5f03dcd0c6972a66643b81" translate="yes" xml:space="preserve">
          <source>Applies a callback to the value in this Option. If the callback returns &lt;em&gt;true&lt;/em&gt;, the option is returned as a Some. If it returns false, it is returned as a None.</source>
          <target state="translated">将回调应用于此Option中的值。如果回调返回&lt;em&gt;true&lt;/em&gt;，则该选项作为Some返回。如果返回false，则返回None。</target>
        </trans-unit>
        <trans-unit id="31b8834506fb3b7c5be5a3ce85e8e0c3db7c0b3f" translate="yes" xml:space="preserve">
          <source>Arguments are delimited by white space, which is either a space or a tab.</source>
          <target state="translated">参数以空格为界,可以是空格,也可以是制表符。</target>
        </trans-unit>
        <trans-unit id="401bb179f3db6b973c284e019e2540619d382218" translate="yes" xml:space="preserve">
          <source>Arguments that are passed to a &lt;code&gt;varargs&lt;/code&gt; parameter are wrapped in an array constructor expression. This is why &lt;code&gt;debug&lt;/code&gt; iterates over all of &lt;code&gt;n&lt;/code&gt;'s children.</source>
          <target state="translated">传递给 &lt;code&gt;varargs&lt;/code&gt; 参数的参数包装在数组构造函数表达式中。这就是为什么 &lt;code&gt;debug&lt;/code&gt; 迭代所有 &lt;code&gt;n&lt;/code&gt; 个孩子的原因。</target>
        </trans-unit>
        <trans-unit id="a0478ca5f4c068ca3ac12f9474f6a15865ce9053" translate="yes" xml:space="preserve">
          <source>Arguments:</source>
          <target state="translated">Arguments:</target>
        </trans-unit>
        <trans-unit id="b52ce1191681712b4198292245b2069cf1dabb8f" translate="yes" xml:space="preserve">
          <source>Arguments: arguments are passed to the program being run (if --run option is selected)</source>
          <target state="translated">参数:参数被传递给正在运行的程序(如果选择了 --run 选项)。</target>
        </trans-unit>
        <trans-unit id="97e74f9d45593e231dbfcd8bbedd9ba97fed0f07" translate="yes" xml:space="preserve">
          <source>Arguments: everything that does not start with a &lt;code&gt;-&lt;/code&gt;</source>
          <target state="translated">参数：所有不以 &lt;code&gt;-&lt;/code&gt; 开头的内容</target>
        </trans-unit>
        <trans-unit id="e1d45cd50bdc4c8b3af4b806662501ca8c8c618d" translate="yes" xml:space="preserve">
          <source>Arithmetic shift right</source>
          <target state="translated">算术右移</target>
        </trans-unit>
        <trans-unit id="5ee11c97923cbdc76a30506f7fe7c019daafaf0b" translate="yes" xml:space="preserve">
          <source>Arithmetic with a &lt;code&gt;Duration&lt;/code&gt; is very fast, especially when used with the &lt;code&gt;Time&lt;/code&gt; type, since it only involves basic arithmetic. Because &lt;code&gt;Duration&lt;/code&gt; is more performant and easier to understand it should generally preferred.</source>
          <target state="translated">带有 &lt;code&gt;Duration&lt;/code&gt; 算术非常快，尤其是与&amp;ldquo; &lt;code&gt;Time&lt;/code&gt; 类型一起使用时，因为它仅涉及基本算术。由于 &lt;code&gt;Duration&lt;/code&gt; 性能更高且更易于理解，因此通常应首选持续时间。</target>
        </trans-unit>
        <trans-unit id="11cd140e4798311075ab97986a6059d3cb376d6c" translate="yes" xml:space="preserve">
          <source>Arithmetic with a &lt;code&gt;TimeInterval&lt;/code&gt; can be very slow, because it requires timezone information.</source>
          <target state="translated">使用 &lt;code&gt;TimeInterval&lt;/code&gt; 进行算术可能会非常慢，因为它需要时区信息。</target>
        </trans-unit>
        <trans-unit id="52bae2349fbad4ef35978d796cfe4b7d32461d9e" translate="yes" xml:space="preserve">
          <source>Array access operator &lt;code&gt;[]&lt;/code&gt;</source>
          <target state="translated">数组访问运算符 &lt;code&gt;[]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="935c34e59be520dab8667587be24775c6b59c8e5" translate="yes" xml:space="preserve">
          <source>Array and sequence types</source>
          <target state="translated">阵列和序列类型</target>
        </trans-unit>
        <trans-unit id="021b6564b992d622f4a204a912f2a5e5c8fe3e98" translate="yes" xml:space="preserve">
          <source>Array of strings representing each logging level.</source>
          <target state="translated">代表每个记录级别的字符串数组。</target>
        </trans-unit>
        <trans-unit id="b66b4ebd826229d404911b2c9ca9b59007c74879" translate="yes" xml:space="preserve">
          <source>Array with no bounds checking</source>
          <target state="translated">无边界检查的阵列</target>
        </trans-unit>
        <trans-unit id="b90cc9bfd23567a2ff5ba1f00e7c63ca6da8755e" translate="yes" xml:space="preserve">
          <source>Arrays</source>
          <target state="translated">Arrays</target>
        </trans-unit>
        <trans-unit id="163d5347d88f0665232159d0fcd2e115c3d58bb8" translate="yes" xml:space="preserve">
          <source>Arrays are a homogeneous type, meaning that each element in the array has the same type. Arrays always have a fixed length specified as a constant expression (except for open arrays). They can be indexed by any ordinal type. A parameter &lt;code&gt;A&lt;/code&gt; may be an &lt;em&gt;open array&lt;/em&gt;, in which case it is indexed by integers from 0 to &lt;code&gt;len(A)-1&lt;/code&gt;. An array expression may be constructed by the array constructor &lt;code&gt;[]&lt;/code&gt;. The element type of this array expression is inferred from the type of the first element. All other elements need to be implicitly convertible to this type.</source>
          <target state="translated">数组是同构类型，这意味着数组中的每个元素都具有相同的类型。数组始终具有固定长度，该长度指定为常量表达式（开放数组除外）。它们可以按任何序数类型进行索引。参数 &lt;code&gt;A&lt;/code&gt; 可以是一个&lt;em&gt;开放数组&lt;/em&gt;，在这种情况下，它由0到 &lt;code&gt;len(A)-1&lt;/code&gt; 的整数索引。数组表达式可以由数组构造函数 &lt;code&gt;[]&lt;/code&gt; 构造。该数组表达式的元素类型是从第一个元素的类型推断出来的。所有其他元素都需要隐式转换为该类型。</target>
        </trans-unit>
        <trans-unit id="7c78840740ada4caee391a3c7d72b96b3524a2c8" translate="yes" xml:space="preserve">
          <source>Arrays are a homogeneous type, meaning that each element in the array has the same type. Arrays always have a fixed length which is specified at compile time (except for open arrays). They can be indexed by any ordinal type. A parameter &lt;code&gt;A&lt;/code&gt; may be an &lt;em&gt;open array&lt;/em&gt;, in which case it is indexed by integers from 0 to &lt;code&gt;len(A)-1&lt;/code&gt;. An array expression may be constructed by the array constructor &lt;code&gt;[]&lt;/code&gt;. The element type of this array expression is inferred from the type of the first element. All other elements need to be implicitly convertable to this type.</source>
          <target state="translated">数组是同构类型，这意味着数组中的每个元素都具有相同的类型。数组始终具有在编译时指定的固定长度（开放数组除外）。它们可以按任何序数类型索引。参数 &lt;code&gt;A&lt;/code&gt; 可以是一个&lt;em&gt;开放数组&lt;/em&gt;，在这种情况下，它由0到 &lt;code&gt;len(A)-1&lt;/code&gt; 的整数索引。数组表达式可以由数组构造函数 &lt;code&gt;[]&lt;/code&gt; 构造。该数组表达式的元素类型是从第一个元素的类型推断出来的。所有其他元素都需要隐式转换为该类型。</target>
        </trans-unit>
        <trans-unit id="07316b5238311cac8e4fe1961ee02c15801cb68e" translate="yes" xml:space="preserve">
          <source>Arrays are always bounds checked (at compile-time or at runtime). These checks can be disabled via pragmas or invoking the compiler with the &lt;code&gt;--boundChecks:off&lt;/code&gt; command line switch.</source>
          <target state="translated">总是对数组进行边界检查（在编译时或运行时）。可以通过编译指示或使用 &lt;code&gt;--boundChecks:off&lt;/code&gt; 命令行开关调用编译器来禁用这些检查。</target>
        </trans-unit>
        <trans-unit id="0b249479bb7b274c06e387f76a3026cd4f886624" translate="yes" xml:space="preserve">
          <source>Arrays are always bounds checked (statically or at runtime). These checks can be disabled via pragmas or invoking the compiler with the &lt;code&gt;--boundChecks:off&lt;/code&gt; command-line switch.</source>
          <target state="translated">总是对数组进行边界检查（静态地或在运行时）。可以通过编译指示或使用 &lt;code&gt;--boundChecks:off&lt;/code&gt; 命令行开关调用编译器来禁用这些检查。</target>
        </trans-unit>
        <trans-unit id="5f5ec03ff46845d078f8cf64b1238f79972295a5" translate="yes" xml:space="preserve">
          <source>Arrays are value types, like any other Nim type. The assignment operator copies the whole array contents.</source>
          <target state="translated">数组和其他Nim类型一样,都是值类型。赋值操作符可以复制整个数组的内容。</target>
        </trans-unit>
        <trans-unit id="025a9e98dcb0da2dd59c51da809f12fce4980b2a" translate="yes" xml:space="preserve">
          <source>Arrays can be constructed using &lt;code&gt;[]&lt;/code&gt;:</source>
          <target state="translated">可以使用 &lt;code&gt;[]&lt;/code&gt; 构造数组：</target>
        </trans-unit>
        <trans-unit id="c735544485e105956e388f5a452d2502051ca6e1" translate="yes" xml:space="preserve">
          <source>Artifact being compiled.</source>
          <target state="translated">正在编纂的文物。</target>
        </trans-unit>
        <trans-unit id="b17b6441237c52d21208d5d89f06d445715567fb" translate="yes" xml:space="preserve">
          <source>As &lt;code&gt;let&lt;/code&gt; statements are immutable after creation they need to define a value when they are declared. The only exception to this is if the &lt;code&gt;{.importc.}&lt;/code&gt; pragma (or any of the other &lt;code&gt;importX&lt;/code&gt; pragmas) is applied, in this case the value is expected to come from native code, typically a C/C++ &lt;code&gt;const&lt;/code&gt;.</source>
          <target state="translated">由于 &lt;code&gt;let&lt;/code&gt; 语句在创建后是不可变的，因此需要在声明它们时定义一个值。唯一的例外是如果应用了 &lt;code&gt;{.importc.}&lt;/code&gt; 编译指示（或任何其他 &lt;code&gt;importX&lt;/code&gt; 编译指示），则在这种情况下，该值应来自本机代码，通常是C / C ++ &lt;code&gt;const&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2681d14f693853cb31e8a490d26bf55ce9311d0e" translate="yes" xml:space="preserve">
          <source>As a regular expression &lt;code&gt;\[.*\]&lt;/code&gt; matches the longest possible text between &lt;code&gt;'['&lt;/code&gt; and &lt;code&gt;']'&lt;/code&gt;. As a PEG it never matches anything, because a PEG is deterministic: &lt;code&gt;.*&lt;/code&gt; consumes the rest of the input, so &lt;code&gt;\]&lt;/code&gt; never matches. As a PEG this needs to be written as: &lt;code&gt;\[ ( !\] . )* \]&lt;/code&gt; (or &lt;code&gt;\[ @ \]&lt;/code&gt;).</source>
          <target state="translated">作为正则表达式 &lt;code&gt;\[.*\]&lt;/code&gt; 匹配 &lt;code&gt;'['&lt;/code&gt; 和 &lt;code&gt;']'&lt;/code&gt; 之间的最长文本。作为PEG，它永远不会匹配任何内容，因为PEG是确定性的： &lt;code&gt;.*&lt;/code&gt; 会消耗其余的输入，因此 &lt;code&gt;\]&lt;/code&gt; 不会匹配。作为PEG，它需要写为： &lt;code&gt;\[ ( !\] . )* \]&lt;/code&gt; （或 &lt;code&gt;\[ @ \]&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="7df1f297110a6ac1f59d3ba4423b992aff7687da" translate="yes" xml:space="preserve">
          <source>As a result of using optimized function/intrinsics some functions can return undefined results if the input is invalid. You can use the flag &lt;code&gt;noUndefinedBitOpts&lt;/code&gt; to force predictable behaviour for all input, causing a small performance hit.</source>
          <target state="translated">由于使用了优化的函数/内部函数，因此如果输入无效，则某些函数可能会返回未定义的结果。您可以使用标志 &lt;code&gt;noUndefinedBitOpts&lt;/code&gt; 对所有输入强制执行可预测的行为，从而降低性能。</target>
        </trans-unit>
        <trans-unit id="7d98662c0a3a8c4fd899d63977fd61a1ce489676" translate="yes" xml:space="preserve">
          <source>As a result of using optimized function/intrinsics some functions can return undefined results if the input is invalid. You can use the flag &lt;em&gt;noUndefinedBitOpts&lt;/em&gt; to force predictable behaviour for all input, causing a small performance hit.</source>
          <target state="translated">由于使用了优化的函数/内部函数，因此如果输入无效，某些函数可能会返回未定义的结果。您可以使用标志&lt;em&gt;noUndefinedBitOpts&lt;/em&gt;对所有输入强制执行可预测的行为，从而降低性能。</target>
        </trans-unit>
        <trans-unit id="1664c8e0b3003ab199f6ca491156febd8a7827ee" translate="yes" xml:space="preserve">
          <source>As a rule of thumb, indentation within expressions is allowed after operators, an open parenthesis and after commas.</source>
          <target state="translated">根据经验,在表达式中,允许在运算符、开括号和逗号之后进行缩进。</target>
        </trans-unit>
        <trans-unit id="cb2355cab9186efd1c7ad2a36b7f8184f95dac01" translate="yes" xml:space="preserve">
          <source>As a side note, if you choose to use infix operators in a prefix form, the AST behaves as a &lt;a href=&quot;#callsslashexpressions-call-with&quot;&gt;parenthetical function call&lt;/a&gt; with &lt;code&gt;nnkAccQuoted&lt;/code&gt;, as follows:</source>
          <target state="translated">附带说明一下，如果您选择以前缀形式使用中缀运算符，则AST的行为类似于带有 &lt;code&gt;nnkAccQuoted&lt;/code&gt; 的&lt;a href=&quot;#callsslashexpressions-call-with&quot;&gt;括号函数调用&lt;/a&gt;，如下所示：</target>
        </trans-unit>
        <trans-unit id="1bbf2a9820bf41bcc3ae860ff3066a54791d55a8" translate="yes" xml:space="preserve">
          <source>As a side note, if you choose to use infix operators in a prefix form, the AST behaves as a [parenthetical function call](./macros.html#calls-expressions-call-with) with &lt;code&gt;nnkAccQuoted&lt;/code&gt;, as follows:</source>
          <target state="translated">附带说明一下，如果您选择以前缀形式使用中缀运算符，则AST的行为与[nk附加函数调用]（./ macros.html＃calls-expressions-call-with）和 &lt;code&gt;nnkAccQuoted&lt;/code&gt; 相同，如下所示：</target>
        </trans-unit>
        <trans-unit id="15211f47465417179a8c67c3321dc2d1d401fb39" translate="yes" xml:space="preserve">
          <source>As a special more convenient notation, proc expressions involved in procedure calls can use the &lt;code&gt;do&lt;/code&gt; keyword:</source>
          <target state="translated">作为一种更方便的特殊表示法，过程调用中涉及的proc表达式可以使用 &lt;code&gt;do&lt;/code&gt; 关键字：</target>
        </trans-unit>
        <trans-unit id="dd6443d8544f4bb56ab3cab6062600d72a758fbe" translate="yes" xml:space="preserve">
          <source>As a special rule to keep backward compatibility with older versions of the &lt;code&gt;importcpp&lt;/code&gt; pragma, if there is no special pattern character (any of &lt;code&gt;# ' @&lt;/code&gt;) at all, C++'s dot or arrow notation is assumed, so the above example can also be written as:</source>
          <target state="translated">作为保持与较早版本的 &lt;code&gt;importcpp&lt;/code&gt; pragma的向后兼容性的特殊规则，如果根本没有特殊的模式字符（任何 &lt;code&gt;# ' @&lt;/code&gt; ），则假定使用C ++的点或箭头符号，因此上述示例也可以写成：</target>
        </trans-unit>
        <trans-unit id="ce683dd181064064b72fd86d9d3e2b66acc2d7ce" translate="yes" xml:space="preserve">
          <source>As a special rule to keep backwards compatibility with older versions of the &lt;code&gt;importcpp&lt;/code&gt; pragma, if there is no special pattern character (any of &lt;code&gt;# ' @&lt;/code&gt;) at all, C++'s dot or arrow notation is assumed, so the above example can also be written as:</source>
          <target state="translated">作为保持与较早版本的 &lt;code&gt;importcpp&lt;/code&gt; pragma的向后兼容性的特殊规则，如果根本没有特殊的模式字符（任何 &lt;code&gt;# ' @&lt;/code&gt; ），则假定使用C ++的点或箭头符号，因此上述示例也可以写成：</target>
        </trans-unit>
        <trans-unit id="ab91135276bb9fc3a4864b2e8e2281ee4c12f22b" translate="yes" xml:space="preserve">
          <source>As a special rule, the discriminator kind can also be bounded using a &lt;code&gt;case&lt;/code&gt; statement. If possible values of the discriminator variable in a &lt;code&gt;case&lt;/code&gt; statement branch are a subset of discriminator values for the selected object branch, the initialization is considered valid. This analysis only works for immutable discriminators of an ordinal type and disregards &lt;code&gt;elif&lt;/code&gt; branches. For discriminator values with a &lt;code&gt;range&lt;/code&gt; type, the compiler checks if the entire range of possible values for the discriminator value is valid for the chosen object branch.</source>
          <target state="translated">作为特殊规则，鉴别符类型也可以使用 &lt;code&gt;case&lt;/code&gt; 语句来界定。如果 &lt;code&gt;case&lt;/code&gt; 语句分支中鉴别符变量的可能值是所选对象分支鉴别符值的子集，则认为初始化有效。此分析仅适用于序数类型的不可变鉴别符，而忽略了 &lt;code&gt;elif&lt;/code&gt; 分支。对于具有 &lt;code&gt;range&lt;/code&gt; 类型的鉴别器值，编译器将检查鉴别器值的所有可能值范围是否对所选对象分支有效。</target>
        </trans-unit>
        <trans-unit id="afa79fbae0eabebb420b9fe3f09c01088cf66351" translate="yes" xml:space="preserve">
          <source>As a special rule, when the value of &lt;code&gt;decodePlus&lt;/code&gt; is true, &lt;code&gt;'+'&lt;/code&gt; characters are converted to a space.</source>
          <target state="translated">作为一条特殊规则，当 &lt;code&gt;decodePlus&lt;/code&gt; 的值为true时， &lt;code&gt;'+'&lt;/code&gt; 字符将转换为空格。</target>
        </trans-unit>
        <trans-unit id="06f5de0278a73571ad2478819c0ab63c92da4626" translate="yes" xml:space="preserve">
          <source>As a special rule, when the value of &lt;code&gt;decodePlus&lt;/code&gt; is true, &lt;code&gt;+&lt;/code&gt; characters are converted to a space.</source>
          <target state="translated">作为一条特殊规则，当 &lt;code&gt;decodePlus&lt;/code&gt; 的值为true时， &lt;code&gt;+&lt;/code&gt; 字符将转换为空格。</target>
        </trans-unit>
        <trans-unit id="1b120a7d9f07026a29d56a412d87eb19ed8fa37b" translate="yes" xml:space="preserve">
          <source>As a special rule, when the value of &lt;code&gt;usePlus&lt;/code&gt; is true, spaces are encoded as &lt;code&gt;'+'&lt;/code&gt; instead of &lt;code&gt;'%20'&lt;/code&gt;.</source>
          <target state="translated">作为特殊规则，当 &lt;code&gt;usePlus&lt;/code&gt; 的值为true时，空格编码为 &lt;code&gt;'+'&lt;/code&gt; 而不是 &lt;code&gt;'%20'&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4ee4923f840cd34187586ac353af674c377642d5" translate="yes" xml:space="preserve">
          <source>As a special rule, when the value of &lt;code&gt;usePlus&lt;/code&gt; is true, spaces are encoded as &lt;code&gt;+&lt;/code&gt; instead of &lt;code&gt;%20&lt;/code&gt;.</source>
          <target state="translated">作为一条特殊规则，当 &lt;code&gt;usePlus&lt;/code&gt; 的值为true时，空格将编码为 &lt;code&gt;+&lt;/code&gt; 而不是 &lt;code&gt;%20&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="babff93920d51965108f37a93de33ae42b21d0fb" translate="yes" xml:space="preserve">
          <source>As a special semantic extension, an expression in an &lt;code&gt;of&lt;/code&gt; branch of a case statement may evaluate to a set or array constructor; the set or array is then expanded into a list of its elements:</source>
          <target state="translated">作为特殊的语义扩展，case语句的 &lt;code&gt;of&lt;/code&gt; 分支中的表达式可以求值为set或array构造函数；然后将集合或数组扩展为其元素列表：</target>
        </trans-unit>
        <trans-unit id="c8b38ae2d66cb902bbb85a37572813974cd63162" translate="yes" xml:space="preserve">
          <source>As a special semantic rule, &lt;code&gt;x&lt;/code&gt; may also be a type identifier (&lt;code&gt;sizeof(int)&lt;/code&gt; is valid).</source>
          <target state="translated">作为特殊的语义规则， &lt;code&gt;x&lt;/code&gt; 也可以是类型标识符（ &lt;code&gt;sizeof(int)&lt;/code&gt; 有效）。</target>
        </trans-unit>
        <trans-unit id="4d5091f848f3ac37cf5086fc6521ba43800396a9" translate="yes" xml:space="preserve">
          <source>As a special semantic rule, &lt;code&gt;x&lt;/code&gt; may also be a type identifier.</source>
          <target state="translated">作为特殊的语义规则， &lt;code&gt;x&lt;/code&gt; 也可以是类型标识符。</target>
        </trans-unit>
        <trans-unit id="d1d6a828142c8108ac0deb4cc6c8484c64faae27" translate="yes" xml:space="preserve">
          <source>As a special semantic rule, the built-in &lt;a href=&quot;system#debugEcho&quot;&gt;debugEcho&lt;/a&gt; pretends to be free of side effects, so that it can be used for debugging routines marked as &lt;code&gt;noSideEffect&lt;/code&gt;.</source>
          <target state="translated">作为特殊的语义规则，内置的&lt;a href=&quot;system#debugEcho&quot;&gt;debugEcho&lt;/a&gt;假装没有副作用，因此可用于调试标记为 &lt;code&gt;noSideEffect&lt;/code&gt; 的例程。</target>
        </trans-unit>
        <trans-unit id="849da20fcec3e5d33e7eb20a85880af3bc7ff686" translate="yes" xml:space="preserve">
          <source>As a special semantic rule, the built-in &lt;a href=&quot;system#debugEcho,varargs%5Btyped,%5D&quot;&gt;debugEcho&lt;/a&gt; pretends to be free of side effects, so that it can be used for debugging routines marked as &lt;code&gt;noSideEffect&lt;/code&gt;.</source>
          <target state="translated">作为特殊的语义规则，内置的&lt;a href=&quot;system#debugEcho,varargs%5Btyped,%5D&quot;&gt;debugEcho&lt;/a&gt;假装没有副作用，因此可用于调试标记为 &lt;code&gt;noSideEffect&lt;/code&gt; 的例程。</target>
        </trans-unit>
        <trans-unit id="71489e93932a05f2ea411285eaceb3bbe24614d1" translate="yes" xml:space="preserve">
          <source>As a syntactical extension &lt;code&gt;object&lt;/code&gt; types can be anonymous if declared in a type section via the &lt;code&gt;ref object&lt;/code&gt; or &lt;code&gt;ptr object&lt;/code&gt; notations. This feature is useful if an object should only gain reference semantics:</source>
          <target state="translated">作为语法扩展，如果在类型部分中通过 &lt;code&gt;ref object&lt;/code&gt; 或 &lt;code&gt;ptr object&lt;/code&gt; 符号声明，则 &lt;code&gt;object&lt;/code&gt; 类型可以是匿名的。如果对象仅应获得参考语义，则此功能很有用：</target>
        </trans-unit>
        <trans-unit id="7859c8bf7a7bf8df21005d62f29109f1c4a9707d" translate="yes" xml:space="preserve">
          <source>As a top level statement, the experimental pragma enables a feature for the rest of the module it's enabled in. This is problematic for macro and generic instantiations that cross a module scope. Currently these usages have to be put into a &lt;code&gt;.push/pop&lt;/code&gt; environment:</source>
          <target state="translated">作为顶层声明，实验性编译指示为启用该模块的其余模块启用了一项功能。这对于跨模块范围的宏和通用实例化来说是有问题的。目前，这些用法必须放入 &lt;code&gt;.push/pop&lt;/code&gt; 环境中：</target>
        </trans-unit>
        <trans-unit id="d8025bfa9773e094890bd5bb7bb9e170916e809b" translate="yes" xml:space="preserve">
          <source>As a top-level statement, the experimental pragma enables a feature for the rest of the module it's enabled in. This is problematic for macro and generic instantiations that cross a module scope. Currently, these usages have to be put into a &lt;code&gt;.push/pop&lt;/code&gt; environment:</source>
          <target state="translated">作为顶层声明，实验性编译指示为启用该模块的其余模块启用了功能。这对于跨模块作用域的宏和通用实例化来说是有问题的。当前，这些用法必须放入 &lt;code&gt;.push/pop&lt;/code&gt; 环境中：</target>
        </trans-unit>
        <trans-unit id="1cc9ba3f444ef5f2a70c370287d23a7b3c9d81c8" translate="yes" xml:space="preserve">
          <source>As an example,</source>
          <target state="translated">举个例子:</target>
        </trans-unit>
        <trans-unit id="7e62fd99966b92a3fd4bf5d979b50660343f0f5e" translate="yes" xml:space="preserve">
          <source>As an example, consider the amount of time between these two timestamps, both in the same timezone:</source>
          <target state="translated">举个例子,考虑这两个时间戳之间的时间量,它们都在同一个时区。</target>
        </trans-unit>
        <trans-unit id="fa0458d772e5450c5837302b3171366024dd5c0f" translate="yes" xml:space="preserve">
          <source>As an example, the following would not compile:</source>
          <target state="translated">举个例子,以下内容无法编译。</target>
        </trans-unit>
        <trans-unit id="0b935a3e149eeb28ead79ccda5acf74a96cba2bc" translate="yes" xml:space="preserve">
          <source>As can be manually verified, this transformation is correct for self-assignments.</source>
          <target state="translated">经人工验证,可以看出,这种变换是正确的,适合于自我赋值。</target>
        </trans-unit>
        <trans-unit id="4faf2cad17e66616bc46eb370913033cba7d7ffe" translate="yes" xml:space="preserve">
          <source>As can be seen from the example, C's macros with parameters are mapped to Nim's templates. This mapping is the best one can do, but it is of course not accurate: Nim's templates operate on syntax trees whereas C's macros work on the token level. c2nim cannot translate any macro that contains the &lt;code&gt;##&lt;/code&gt; token concatenation operator.</source>
          <target state="translated">从示例中可以看出，带有参数的C宏被映射到Nim的模板。这种映射是最好的映射，但是它当然不准确：Nim的模板在语法树上运行，而C的宏在令牌级别上运行。c2nim无法转换任何包含 &lt;code&gt;##&lt;/code&gt; 令牌串联运算符的宏。</target>
        </trans-unit>
        <trans-unit id="cdca03b57c9a9c02d929b545595c9b2375041559" translate="yes" xml:space="preserve">
          <source>As can be seen from the example, an advantage to an object hierarchy is that no casting between different object types is needed. Yet, access to invalid object fields raises an exception.</source>
          <target state="translated">从这个例子可以看出,对象层次结构的一个优点是不需要在不同的对象类型之间进行转换。然而,访问无效的对象字段会引起异常。</target>
        </trans-unit>
        <trans-unit id="033710d5a2d1054844b9448ca63a783fde847ed0" translate="yes" xml:space="preserve">
          <source>As can be seen from the example, it is possible to both specify a field's ordinal value and its string value by using a tuple. It is also possible to only specify one of them.</source>
          <target state="translated">从这个例子中可以看出,通过使用元组,既可以指定字段的序数值,也可以指定其字符串值。也可以只指定其中之一。</target>
        </trans-unit>
        <trans-unit id="f2059474be6954912aa2a1f6469b45737b7e11f5" translate="yes" xml:space="preserve">
          <source>As can be seen from the example, this solution is hardly sufficient and should eventually be replaced by a better solution.</source>
          <target state="translated">从例子中可以看出,这种解决方案很难满足需要,最终应该被更好的解决方案所取代。</target>
        </trans-unit>
        <trans-unit id="33db679c8421cd1a5bcfed816339b58d55a90cf0" translate="yes" xml:space="preserve">
          <source>As can be seen from the examples, strings are matched verbatim except for substrings starting with &lt;code&gt;$&lt;/code&gt;. These constructions are available:</source>
          <target state="translated">从示例中可以看出，字符串以逐字匹配，但以 &lt;code&gt;$&lt;/code&gt; 开头的子字符串除外。这些结构可用：</target>
        </trans-unit>
        <trans-unit id="3690ed0de51a088f748c4a5d9756e00f903b6456" translate="yes" xml:space="preserve">
          <source>As can be seen in the example, base methods have to be annotated with the &lt;span id=&quot;base_1&quot;&gt;base&lt;/span&gt; pragma. The &lt;code&gt;base&lt;/code&gt; pragma also acts as a reminder for the programmer that a base method &lt;code&gt;m&lt;/code&gt; is used as the foundation to determine all the effects that a call to &lt;code&gt;m&lt;/code&gt; might cause.</source>
          <target state="translated">从示例中可以看出，基本方法必须使用&lt;span id=&quot;base_1&quot;&gt;基本&lt;/span&gt;编译指示进行注释。所述 &lt;code&gt;base&lt;/code&gt; 编译还用作一个基方法程序员提醒 &lt;code&gt;m&lt;/code&gt; 被用作基础来确定对呼叫的所有效果 &lt;code&gt;m&lt;/code&gt; 可能导致。</target>
        </trans-unit>
        <trans-unit id="46e0fb06d3ebb9d87d99780ce68838895081e9f4" translate="yes" xml:space="preserve">
          <source>As can be seen in the example, this new variant allows for custom flags that are passed to the C compiler when the file is recompiled.</source>
          <target state="translated">从这个例子中可以看出,这个新的变体允许自定义标志,当文件被重新编译时,这些标志会传递给C编译器。</target>
        </trans-unit>
        <trans-unit id="a5a364bd18b5eaef7b5722d6cd78c85c92bfa5dd" translate="yes" xml:space="preserve">
          <source>As can be seen in the productions, numerical constants can contain underscores for readability. Integer and floating point literals may be given in decimal (no prefix), binary (prefix &lt;code&gt;0b&lt;/code&gt;), octal (prefix &lt;code&gt;0o&lt;/code&gt;) and hexadecimal (prefix &lt;code&gt;0x&lt;/code&gt;) notation.</source>
          <target state="translated">从产品中可以看出，数字常数可以包含下划线以提高可读性。整数和浮点文字可以以十进制（无前缀），二进制（前缀 &lt;code&gt;0b&lt;/code&gt; ），八进制（前缀 &lt;code&gt;0o&lt;/code&gt; ）和十六进制（前缀 &lt;code&gt;0x&lt;/code&gt; ）表示。</target>
        </trans-unit>
        <trans-unit id="c68ceacc6a8938d2e2de6c4f8059959bc6ce1693" translate="yes" xml:space="preserve">
          <source>As can be seen in the productions, numerical constants can contain underscores for readability. Integer and floating-point literals may be given in decimal (no prefix), binary (prefix &lt;code&gt;0b&lt;/code&gt;), octal (prefix &lt;code&gt;0o&lt;/code&gt;), and hexadecimal (prefix &lt;code&gt;0x&lt;/code&gt;) notation.</source>
          <target state="translated">从产品中可以看出，数字常数可以包含下划线以提高可读性。整数和浮点文字可以用十进制（无前缀），二进制（前缀 &lt;code&gt;0b&lt;/code&gt; ），八进制（前缀 &lt;code&gt;0o&lt;/code&gt; ）和十六进制（前缀 &lt;code&gt;0x&lt;/code&gt; ）表示。</target>
        </trans-unit>
        <trans-unit id="7dad921df2b5a3cd443f8e5461c7a9ccced2c050" translate="yes" xml:space="preserve">
          <source>As can been seen from the example, an advantage to an object hierarchy is that no casting between different object types is needed. Yet, access to invalid object fields raises an exception.</source>
          <target state="translated">从这个例子中可以看出,对象层次结构的一个优点是不需要在不同对象类型之间进行转换。然而,访问无效的对象字段会引起异常。</target>
        </trans-unit>
        <trans-unit id="86acee0719e4df42b833d89f9ce00671880b3bee" translate="yes" xml:space="preserve">
          <source>As can been seen from the example, an advantage to an object hierarchy is that no conversion between different object types is needed. Yet, access to invalid object fields raises an exception.</source>
          <target state="translated">从这个例子可以看出,对象层次结构的一个优点是不需要在不同的对象类型之间进行转换。然而,访问无效的对象字段会引起异常。</target>
        </trans-unit>
        <trans-unit id="8bd2dc16961a30c8b20a5aa5ef6562993b9d9ea9" translate="yes" xml:space="preserve">
          <source>As case statements perform compile-time exhaustiveness checks, the value in every &lt;code&gt;of&lt;/code&gt; branch must be known at compile time. This fact is also exploited to generate more performant code.</source>
          <target state="translated">作为case语句执行编译时全面性检查，在每一个的值 &lt;code&gt;of&lt;/code&gt; 分支必须在编译时是已知的。这个事实也被用来生成更多性能代码。</target>
        </trans-unit>
        <trans-unit id="a3cf4fdd8a46537cb17ba2fc74bca88aa30a4384" translate="yes" xml:space="preserve">
          <source>As convention this proc will split index files into two categories: documentation and API. API indices will be all joined together into a single big sorted index, making the bulk of the final index. This is good for API documentation because many symbols are repated in different modules. On the other hand, documentation indices are essentially table of contents plus a few special markers. These documents will be rendered in a separate section which tries to maintain the order and hierarchy of the symbols in the index file.</source>
          <target state="translated">按照惯例,这个proc将把索引文件分成两类:文档和API。API索引将全部加入到一个大的排序索引中,成为最终索引的主体。这对于API文档来说是很好的,因为很多符号会在不同的模块中重复出现。另一方面,文档索引基本上是目录加上一些特殊标记。这些文档将在一个单独的部分中呈现,它试图保持索引文件中符号的顺序和层次。</target>
        </trans-unit>
        <trans-unit id="c36898bdeea6eb9e3e341ac71004ffc85ade807c" translate="yes" xml:space="preserve">
          <source>As convention this proc will split index files into two categories: documentation and API. API indices will be all joined together into a single big sorted index, making the bulk of the final index. This is good for API documentation because many symbols are repeated in different modules. On the other hand, documentation indices are essentially table of contents plus a few special markers. These documents will be rendered in a separate section which tries to maintain the order and hierarchy of the symbols in the index file.</source>
          <target state="translated">按照惯例,这个proc将把索引文件分成两类:文档和API。API索引将全部加入到一个大的排序索引中,成为最终索引的主体。这对于API文档来说是很好的,因为很多符号在不同的模块中是重复的。另一方面,文档索引本质上是目录加上一些特殊标记。这些文档将在一个单独的部分中呈现,它试图保持索引文件中符号的顺序和层次。</target>
        </trans-unit>
        <trans-unit id="e35fce15f7b6d0e8ddfe4a222398b9462fecc9a2" translate="yes" xml:space="preserve">
          <source>As in generics symbol binding can be influenced via &lt;code&gt;mixin&lt;/code&gt; or &lt;code&gt;bind&lt;/code&gt; statements.</source>
          <target state="translated">与泛型中的符号绑定一样，可以通过 &lt;code&gt;mixin&lt;/code&gt; 或 &lt;code&gt;bind&lt;/code&gt; 语句影响绑定。</target>
        </trans-unit>
        <trans-unit id="0887bf802c49a565d93917f60c9350172010518c" translate="yes" xml:space="preserve">
          <source>As it can be seen, for an &lt;code&gt;of&lt;/code&gt; branch a comma separated list of values is also allowed.</source>
          <target state="translated">如可以看到的，对于一个 &lt;code&gt;of&lt;/code&gt; 分支以逗号分隔的值的列表也被允许。</target>
        </trans-unit>
        <trans-unit id="026e19060b7027adb0d7fdc31274d77b9a547e42" translate="yes" xml:space="preserve">
          <source>As long as a type &lt;code&gt;T&lt;/code&gt; is incomplete &lt;code&gt;sizeof(T)&lt;/code&gt; or &quot;runtime type information&quot; for &lt;code&gt;T&lt;/code&gt; is not available.</source>
          <target state="translated">只要类型 &lt;code&gt;T&lt;/code&gt; 是不完整 &lt;code&gt;sizeof(T)&lt;/code&gt; 或&amp;ldquo;运行时类型信息&amp;rdquo; &lt;code&gt;T&lt;/code&gt; 不可用。</target>
        </trans-unit>
        <trans-unit id="abcbb5924227bd04c281ecaaed135860652d02cc" translate="yes" xml:space="preserve">
          <source>As long as a type &lt;code&gt;T&lt;/code&gt; is incomplete, neither &lt;code&gt;sizeof(T)&lt;/code&gt; nor runtime type information for &lt;code&gt;T&lt;/code&gt; is available.</source>
          <target state="translated">只要类型 &lt;code&gt;T&lt;/code&gt; 是不完整的，既不 &lt;code&gt;sizeof(T)&lt;/code&gt; 也没有运行时类型信息为 &lt;code&gt;T&lt;/code&gt; 是可用的。</target>
        </trans-unit>
        <trans-unit id="2dca63b7a6f1fd2e2ca6e65f781d803b65614773" translate="yes" xml:space="preserve">
          <source>As long as you don't use the threadvar emulation Nim uses native thread variables, of which you get a fresh version whenever you create a thread. You can then attach a GC to this thread via</source>
          <target state="translated">只要你不使用 threadvar 仿真,Nim 就会使用本机线程变量,每当你创建一个线程时,都会得到一个新的版本。然后,你就可以通过</target>
        </trans-unit>
        <trans-unit id="26a74fa3cef27390dd0524bd6f48c70bfa5b9b01" translate="yes" xml:space="preserve">
          <source>As many &lt;code&gt;nnkIdent&lt;/code&gt; appear as there are pragmas between &lt;code&gt;{..}&lt;/code&gt;. Note that the declaration of new pragmas is essentially the same:</source>
          <target state="translated">与 &lt;code&gt;{..}&lt;/code&gt; 之间存在 &lt;code&gt;nnkIdent&lt;/code&gt; 出现了多少nnkIdent。请注意，新编译指示的声明本质上是相同的：</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
