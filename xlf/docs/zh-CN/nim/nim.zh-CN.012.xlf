<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="nim">
    <body>
      <group id="nim">
        <trans-unit id="089b0a2a4fc8aac4d751cf1e71645f608e78c87d" translate="yes" xml:space="preserve">
          <source>There are two ways to invoke a macro:</source>
          <target state="translated">有两种方法可以调用宏。</target>
        </trans-unit>
        <trans-unit id="720936a505c479b6845bfb796080ccd89a044a7d" translate="yes" xml:space="preserve">
          <source>There are two ways to write a macro, either &lt;em&gt;generating&lt;/em&gt; Nim source code and letting the compiler parse it, or creating manually an abstract syntax tree (AST) which you feed to the compiler. In order to build the AST one needs to know how the Nim concrete syntax is converted to an abstract syntax tree (AST). The AST is documented in the &lt;a href=&quot;macros&quot;&gt;macros&lt;/a&gt; module.</source>
          <target state="translated">有两种编写宏的方法，要么&lt;em&gt;生成&lt;/em&gt; Nim源代码并让编译器对其进行解析，要么手动创建要馈送到编译器的抽象语法树（AST）。为了构建AST，需要知道如何将Nim具体语法转换为抽象语法树（AST）。AST记录在&lt;a href=&quot;macros&quot;&gt;宏&lt;/a&gt;模块中。</target>
        </trans-unit>
        <trans-unit id="f9bcbe7393ec87f587011e8d840878f558c1f97b" translate="yes" xml:space="preserve">
          <source>There can be zero or more &lt;code&gt;elif&lt;/code&gt; parts, and the &lt;code&gt;else&lt;/code&gt; part is optional. The keyword &lt;code&gt;elif&lt;/code&gt; is short for &lt;code&gt;else if&lt;/code&gt;, and is useful to avoid excessive indentation. (The &lt;code&gt;&quot;&quot;&lt;/code&gt; is the empty string. It contains no characters.)</source>
          <target state="translated">可以有零个或多个 &lt;code&gt;elif&lt;/code&gt; 部分，而 &lt;code&gt;else&lt;/code&gt; 部分是可选的。关键字 &lt;code&gt;elif&lt;/code&gt; 是 &lt;code&gt;else if&lt;/code&gt; 缩写，对于避免缩进过多很有用。（ &lt;code&gt;&quot;&quot;&lt;/code&gt; 为空字符串。不包含任何字符。）</target>
        </trans-unit>
        <trans-unit id="77cfdf22bf86043f8acee986bff271197e1936f9" translate="yes" xml:space="preserve">
          <source>There exists a literal for each numerical type that is defined. The suffix starting with an apostrophe (''') is called a &lt;span id=&quot;type-suffix_1&quot;&gt;type suffix&lt;/span&gt;. Literals without a type suffix are of an integer type, unless the literal contains a dot or &lt;code&gt;E|e&lt;/code&gt; in which case it is of type &lt;code&gt;float&lt;/code&gt;. This integer type is &lt;code&gt;int&lt;/code&gt; if the literal is in the range &lt;code&gt;low(i32)..high(i32)&lt;/code&gt;, otherwise it is &lt;code&gt;int64&lt;/code&gt;. For notational convenience the apostrophe of a type suffix is optional if it is not ambiguous (only hexadecimal floating point literals with a type suffix can be ambiguous).</source>
          <target state="translated">每个定义的数字类型都有一个文字。以撇号（'''）开头的后缀称为&lt;span id=&quot;type-suffix_1&quot;&gt;类型后缀&lt;/span&gt;。没有类型后缀的文字是整数类型，除非文字包含点或 &lt;code&gt;E|e&lt;/code&gt; 在这种情况下，它是 &lt;code&gt;float&lt;/code&gt; 类型。如果文字范围在 &lt;code&gt;low(i32)..high(i32)&lt;/code&gt; 范围内，则此整数类型为 &lt;code&gt;int&lt;/code&gt; ，否则为 &lt;code&gt;int64&lt;/code&gt; 。为了符号上的方便，如果类型后缀不是模棱两可的，则单引号是可选的（只有带有类型后缀的十六进制浮点文字可以是模棱两可的）。</target>
        </trans-unit>
        <trans-unit id="90fe0ee868ac44e50e7a55bf1d6f6587b14d23c1" translate="yes" xml:space="preserve">
          <source>There is a syntactic sugar for calling routines: The syntax &lt;code&gt;obj.method(args)&lt;/code&gt; can be used instead of &lt;code&gt;method(obj, args)&lt;/code&gt;. If there are no remaining arguments, the parentheses can be omitted: &lt;code&gt;obj.len&lt;/code&gt; (instead of &lt;code&gt;len(obj)&lt;/code&gt;).</source>
          <target state="translated">调用例程有一个语法糖：可以使用语法 &lt;code&gt;obj.method(args)&lt;/code&gt; 代替 &lt;code&gt;method(obj, args)&lt;/code&gt; 。如果没有剩余的参数，则可以省略括号： &lt;code&gt;obj.len&lt;/code&gt; （而不是 &lt;code&gt;len(obj)&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="809686a502cf19e841efede0ad4446dfca6c035b" translate="yes" xml:space="preserve">
          <source>There is an analysis that checks that &lt;code&gt;counters[i].L&lt;/code&gt; is the lock that corresponds to the protected location &lt;code&gt;counters[i].v&lt;/code&gt;. This analysis is called &lt;span id=&quot;path-analysis_1&quot;&gt;path analysis&lt;/span&gt; because it deals with paths to locations like &lt;code&gt;obj.field[i].fieldB[j]&lt;/code&gt;.</source>
          <target state="translated">有一种分析检查 &lt;code&gt;counters[i].L&lt;/code&gt; 是与受保护的位置 &lt;code&gt;counters[i].v&lt;/code&gt; 对应的锁。该分析称为&lt;span id=&quot;path-analysis_1&quot;&gt;路径分析，&lt;/span&gt;因为它处理的是 &lt;code&gt;obj.field[i].fieldB[j]&lt;/code&gt; 类的位置的路径。</target>
        </trans-unit>
        <trans-unit id="9be47a2e7d24c1f78266ccdbd346bb776f9d13ab" translate="yes" xml:space="preserve">
          <source>There is another consideration. Nim has flexible type identification for its procs. Even though &lt;code&gt;proc(a: int, b: int)&lt;/code&gt; and &lt;code&gt;proc(a, b: int)&lt;/code&gt; are equivalent in the code, the AST is a little different for the latter.</source>
          <target state="translated">还有另一个考虑。Nim的proc具有灵活的类型标识。即使 &lt;code&gt;proc(a: int, b: int)&lt;/code&gt; 和 &lt;code&gt;proc(a, b: int)&lt;/code&gt; 在代码中是等效的，但AST对于后者来说还是有些不同。</target>
        </trans-unit>
        <trans-unit id="37a21bfca1dc8f206e73873a032f9f2495f5c004" translate="yes" xml:space="preserve">
          <source>These are the major type classes:</source>
          <target state="translated">这些都是主要的类型类。</target>
        </trans-unit>
        <trans-unit id="c9f26df48cd633ca6dc9c4a4cfdeb29e86e918f9" translate="yes" xml:space="preserve">
          <source>These assertions may not appear in character classes (but note that &lt;code&gt;\b&lt;/code&gt; has a different meaning, namely the backspace character, inside a character class).</source>
          <target state="translated">这些断言可能不会出现在字符类中（但请注意 &lt;code&gt;\b&lt;/code&gt; 具有不同的含义，即字符类内部的退格字符）。</target>
        </trans-unit>
        <trans-unit id="74dbc337c7d11370d75e44ba74f2cb86ce0accdc" translate="yes" xml:space="preserve">
          <source>These character type sequences can appear both inside and outside character classes. They each match one character of the appropriate type. If the current matching point is at the end of the subject string, all of them fail, since there is no character to match.</source>
          <target state="translated">这些字符类型序列可以出现在字符类内部和外部。它们各自匹配一个相应类型的字符。如果当前的匹配点在主题字符串的末尾,那么所有的匹配都会失败,因为没有字符可匹配。</target>
        </trans-unit>
        <trans-unit id="121cd2b220ceffc68b4f037b698a6ce125bbb7d9" translate="yes" xml:space="preserve">
          <source>These directives tell c2nim that it should annotate every proc (or proc type) with the &lt;code&gt;stdcall&lt;/code&gt; / &lt;code&gt;cdecl&lt;/code&gt; calling convention.</source>
          <target state="translated">这些指令告诉c2nim，它应该使用 &lt;code&gt;stdcall&lt;/code&gt; / &lt;code&gt;cdecl&lt;/code&gt; 调用约定来注释每个proc（或proc类型）。</target>
        </trans-unit>
        <trans-unit id="3448534ab91afc28628316690fa8a8d7be286ead" translate="yes" xml:space="preserve">
          <source>These features also work for declarations like &lt;code&gt;#if defined(SYMBOL)&lt;/code&gt; and boolean combinations of such declarations.</source>
          <target state="translated">这些功能还适用于诸如 &lt;code&gt;#if defined(SYMBOL)&lt;/code&gt; 之类的声明以及此类声明的布尔组合。</target>
        </trans-unit>
        <trans-unit id="ac3f7d81f9ef3ace4ce8ec9e07e91300c660430c" translate="yes" xml:space="preserve">
          <source>These integer types are pre-defined:</source>
          <target state="translated">这些整数类型是预先定义的。</target>
        </trans-unit>
        <trans-unit id="55066fb4694c635ce07b74e97002d73c6ea9c5d5" translate="yes" xml:space="preserve">
          <source>These keywords are also operators: &lt;code&gt;and or not xor shl shr div mod in notin is isnot of&lt;/code&gt;.</source>
          <target state="translated">这些关键字也是运算符： &lt;code&gt;and or not xor shl shr div mod in notin is isnot of&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="38f129b5e4464e0480827e37320803bf08418860" translate="yes" xml:space="preserve">
          <source>These matching categories have a priority: An exact match is better than a literal match and that is better than a generic match etc. In the following &lt;code&gt;count(p, m)&lt;/code&gt; counts the number of matches of the matching category &lt;code&gt;m&lt;/code&gt; for the routine &lt;code&gt;p&lt;/code&gt;.</source>
          <target state="translated">这些匹配类别具有优先级：精确匹配优于文字匹配，也优于泛型匹配等。在以下 &lt;code&gt;count(p, m)&lt;/code&gt; 中，为例程 &lt;code&gt;p&lt;/code&gt; 计算匹配类别 &lt;code&gt;m&lt;/code&gt; 的匹配数。</target>
        </trans-unit>
        <trans-unit id="d6be02e33307dc5ed705daa9fb25cdf4cc144412" translate="yes" xml:space="preserve">
          <source>These operations are supported by sets:</source>
          <target state="translated">这些操作都得到了集的支持。</target>
        </trans-unit>
        <trans-unit id="cde2e097c323766072e20c648ae133aff15ec9e4" translate="yes" xml:space="preserve">
          <source>These operations can be &lt;em&gt;overridden&lt;/em&gt; instead of &lt;em&gt;overloaded&lt;/em&gt;. This means the implementation is automatically lifted to structured types. For instance if type &lt;code&gt;T&lt;/code&gt; has an overridden assignment operator &lt;code&gt;=&lt;/code&gt; this operator is also used for assignments of the type &lt;code&gt;seq[T]&lt;/code&gt;. Since these operations are bound to a type they have to be bound to a nominal type for reasons of simplicity of implementation: This means an overridden &lt;code&gt;deepCopy&lt;/code&gt; for &lt;code&gt;ref T&lt;/code&gt; is really bound to &lt;code&gt;T&lt;/code&gt; and not to &lt;code&gt;ref T&lt;/code&gt;. This also means that one cannot override &lt;code&gt;deepCopy&lt;/code&gt; for both &lt;code&gt;ptr T&lt;/code&gt; and &lt;code&gt;ref T&lt;/code&gt; at the same time; instead a helper distinct or object type has to be used for one pointer type.</source>
          <target state="translated">这些操作可以被&lt;em&gt;覆盖&lt;/em&gt;而不是被&lt;em&gt;重载&lt;/em&gt;。这意味着实现会自动提升为结构化类型。例如，如果类型 &lt;code&gt;T&lt;/code&gt; 具有重写的赋值运算符 &lt;code&gt;=&lt;/code&gt; ,则此运算符也用于 &lt;code&gt;seq[T]&lt;/code&gt; 类型的赋值。由于这些操作绑定到一个类型，他们必须被绑定到一个标称类型实现简单的原因：这意味着一个重写的 &lt;code&gt;deepCopy&lt;/code&gt; 对 &lt;code&gt;ref T&lt;/code&gt; 真的势必 &lt;code&gt;T&lt;/code&gt; ，而不是 &lt;code&gt;ref T&lt;/code&gt; 。这也意味着无法 &lt;code&gt;deepCopy&lt;/code&gt; 为 &lt;code&gt;ptr T&lt;/code&gt; 和 &lt;code&gt;ref T&lt;/code&gt; 覆盖deepCopy。与此同时; 相反，必须将一个辅助对象或对象类型用于一种指针类型。</target>
        </trans-unit>
        <trans-unit id="d058bd216e6b19e493d9e6bac8c481c3e459bccb" translate="yes" xml:space="preserve">
          <source>These procs provide a &quot;best effort&quot; realtime guarantee; in particular the cycle collector is not aware of deadlines yet. Deactivate it to get more predictable realtime behaviour. Tests show that a 2ms max pause time will be met in almost all cases on modern CPUs (with the cycle collector disabled).</source>
          <target state="translated">这些procs提供了一个 &quot;尽力 &quot;的实时保证;特别是循环收集器还不知道截止日期。停用它可以获得更多可预测的实时行为。测试表明,在现代CPU上,几乎所有情况下都能满足2ms的最大暂停时间(禁用循环收集器)。</target>
        </trans-unit>
        <trans-unit id="30e9bd52ae679ca98f3066fcb8847b5f10bc445a" translate="yes" xml:space="preserve">
          <source>These rules ensure that the construction is tied to a variable and can easily be destructed at its scope exit. Later versions of the language will improve the support of destructors.</source>
          <target state="translated">这些规则确保了构造与变量绑定,并且可以在其作用域退出时轻松地被反编译。该语言的以后版本将改进对析构器的支持。</target>
        </trans-unit>
        <trans-unit id="c2e945da53bb4b2f455a09e7679d83624a41491a" translate="yes" xml:space="preserve">
          <source>These rules will only be enforced for contributions to the Nim codebase and official projects, such as the Nim compiler, the standard library, and the various official tools such as C2Nim.</source>
          <target state="translated">这些规则只适用于对Nim代码库和官方项目的贡献,如Nim编译器、标准库和各种官方工具,如C2Nim。</target>
        </trans-unit>
        <trans-unit id="20ac174437fbb360f6e0d2c7d84e935dee5e35b6" translate="yes" xml:space="preserve">
          <source>These templates need to be named &lt;code&gt;atom&lt;/code&gt; and &lt;code&gt;nxt&lt;/code&gt;. &lt;code&gt;atom&lt;/code&gt; should be overloaded to handle both single characters and sets of character.</source>
          <target state="translated">这些模板需要命名为 &lt;code&gt;atom&lt;/code&gt; 和 &lt;code&gt;nxt&lt;/code&gt; 。应该重载 &lt;code&gt;atom&lt;/code&gt; 以处理单个字符和字符集。</target>
        </trans-unit>
        <trans-unit id="b1388617e7ec8cadd15c7db56c0366fdc608c12a" translate="yes" xml:space="preserve">
          <source>These two procs are the two modus operandi of the realtime GC:</source>
          <target state="translated">这两个procs是实时GC的两个操作模式。</target>
        </trans-unit>
        <trans-unit id="1d97cf346f8ff44e70f702c406d7880c63dc3778" translate="yes" xml:space="preserve">
          <source>This HTTP server has not been designed to be used in production, but for testing applications locally. Because of this, when deploying your application you should use a reverse proxy (for example nginx) instead of allowing users to connect directly to this server.</source>
          <target state="translated">这个HTTP服务器并不是被设计用于生产,而是用于本地测试应用程序。正因为如此,当部署你的应用程序时,你应该使用一个反向代理(例如nginx),而不是让用户直接连接到这个服务器。</target>
        </trans-unit>
        <trans-unit id="0ff934bf75567640acf83ce1e9399ceeeffb3152" translate="yes" xml:space="preserve">
          <source>This Module implements types and macros to facilitate the wrapping of, and interaction with JavaScript libraries. Using the provided types &lt;code&gt;JsObject&lt;/code&gt; and &lt;code&gt;JsAssoc&lt;/code&gt; together with the provided macros allows for smoother interfacing with JavaScript, allowing for example quick and easy imports of JavaScript variables:</source>
          <target state="translated">该模块实现类型和宏，以促进JavaScript库的包装和与之交互。通过使用提供的类型 &lt;code&gt;JsObject&lt;/code&gt; 和 &lt;code&gt;JsAssoc&lt;/code&gt; 以及提供的宏，可以更流畅地与JavaScript交互，例如可以快速，轻松地导入JavaScript变量：</target>
        </trans-unit>
        <trans-unit id="358531b90c868b5aa1914c45c295c0b938277040" translate="yes" xml:space="preserve">
          <source>This allows the GC to perform some work for up to &lt;code&gt;us&lt;/code&gt; time. This is useful to call in a main loop to ensure the GC can do its work. To bind all GC activity to a &lt;code&gt;GC_step&lt;/code&gt; call, deactivate the GC with &lt;code&gt;GC_disable&lt;/code&gt; at program startup. If &lt;code&gt;strongAdvice&lt;/code&gt; is set to &lt;code&gt;true&lt;/code&gt;, GC will be forced to perform collection cycle. Otherwise, GC may decide not to do anything, if there is not much garbage to collect. You may also specify the current stack size via &lt;code&gt;stackSize&lt;/code&gt; parameter. It can improve performance, when you know that there are no unique Nim references below certain point on the stack. Make sure the size you specify is greater than the potential worst case size.</source>
          <target state="translated">这使GC可以执行一些工作，而这要花费 &lt;code&gt;us&lt;/code&gt; 最多的时间。调用主循环以确保GC可以完成其工作非常有用。要将所有GC活动绑定到 &lt;code&gt;GC_step&lt;/code&gt; 调用， &lt;code&gt;GC_disable&lt;/code&gt; 在程序启动时使用GC_disable禁用GC 。如果将 &lt;code&gt;strongAdvice&lt;/code&gt; 设置为 &lt;code&gt;true&lt;/code&gt; ，将强制GC执行收集周期。否则，如果没有太多垃圾可以收集，GC可能会决定不采取任何措施。您也可以通过 &lt;code&gt;stackSize&lt;/code&gt; 参数指定当前的堆栈大小。当您知道在堆栈上的特定点以下没有唯一的Nim引用时，它可以提高性能。确保您指定的大小大于潜在的最坏情况的大小。</target>
        </trans-unit>
        <trans-unit id="11b2e587ffff759ed345a7138f93f32e7018411a" translate="yes" xml:space="preserve">
          <source>This calls &lt;code&gt;match&lt;/code&gt; with an implicit declared &lt;code&gt;matches&lt;/code&gt; array that can be used in the scope of the &lt;code&gt;=~&lt;/code&gt; call:</source>
          <target state="translated">该调用使用一个可在 &lt;code&gt;=~&lt;/code&gt; 调用范围内使用的隐式声明的 &lt;code&gt;matches&lt;/code&gt; 数组进行 &lt;code&gt;match&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="91e68c05bbcd84956d6a939da42a4d1620388308" translate="yes" xml:space="preserve">
          <source>This can be accomplished with the &lt;code&gt;#discardableprefix&lt;/code&gt; directive. As its name suggests functions of the given prefix(es) that have non-void return type get annotated with &lt;code&gt;.discardable&lt;/code&gt;:</source>
          <target state="translated">这可以通过 &lt;code&gt;#discardableprefix&lt;/code&gt; 指令来完成。顾名思义，具有非空返回类型的给定前缀的函数将使用 &lt;code&gt;.discardable&lt;/code&gt; 进行注释：</target>
        </trans-unit>
        <trans-unit id="993037ecc6a7a9266978b1b72316c93245910c17" translate="yes" xml:space="preserve">
          <source>This can be avoided by distinguishing strings that contain SQL from strings that don't. Distinct types provide a means to introduce a new string type &lt;code&gt;SQL&lt;/code&gt; that is incompatible with &lt;code&gt;string&lt;/code&gt;:</source>
          <target state="translated">可以通过将包含SQL的字符串与不包含SQL的字符串区分开来避免这种情况。不同类型提供了一种引入新字符串类型 &lt;code&gt;SQL&lt;/code&gt; 的方法，该SQL与 &lt;code&gt;string&lt;/code&gt; 不兼容：</target>
        </trans-unit>
        <trans-unit id="9a87a7c0c14223cb397afe2f968231607dd88a29" translate="yes" xml:space="preserve">
          <source>This can be useful when you have a value that can be present or not. The absence of a value is often represented by &lt;code&gt;nil&lt;/code&gt;, but it is not always available, nor is it always a good solution.</source>
          <target state="translated">当您有一个可以存在或不存在的值时，这将很有用。缺少值通常用 &lt;code&gt;nil&lt;/code&gt; 表示，但它并不总是可用，也不总是一个好的解决方案。</target>
        </trans-unit>
        <trans-unit id="3b2e2827e1dd9cc8f707a6716c04839c0c09dae0" translate="yes" xml:space="preserve">
          <source>This checks 0-9 ASCII characters only.</source>
          <target state="translated">此项仅检查0-9 ASCII字符。</target>
        </trans-unit>
        <trans-unit id="b3ae4abe96c6abb652268187695385d740f80fff" translate="yes" xml:space="preserve">
          <source>This checks 0-9 ASCII characters only. Returns true if all characters in &lt;em&gt;s&lt;/em&gt; are numeric and there is at least one character in &lt;em&gt;s&lt;/em&gt;.</source>
          <target state="translated">这仅检查0-9 ASCII字符。返回true如果在所有字符&lt;em&gt;小号&lt;/em&gt;是数字并有至少一个字符的&lt;em&gt;小号&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="b117d9b50603d6a49490348238bc1594481a404a" translate="yes" xml:space="preserve">
          <source>This checks ASCII characters only.</source>
          <target state="translated">此项仅检查ASCII字符。</target>
        </trans-unit>
        <trans-unit id="cbc954298ac0dfb73fe360b4e03334044ae90394" translate="yes" xml:space="preserve">
          <source>This checks a-z, A-Z ASCII characters only.</source>
          <target state="translated">该功能仅检查a-z、A-Z ASCII字符。</target>
        </trans-unit>
        <trans-unit id="27f5c2b32f5e5afe9cd3e0adefb2a5846fa92f48" translate="yes" xml:space="preserve">
          <source>This checks a-z, A-Z ASCII characters only. Returns true if all characters in &lt;em&gt;s&lt;/em&gt; are alphabetic and there is at least one character in &lt;em&gt;s&lt;/em&gt;.</source>
          <target state="translated">这仅检查z，AZ ASCII字符。返回true如果在所有字符&lt;em&gt;小号&lt;/em&gt;是字母和至少有一个字符的&lt;em&gt;小号&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="37c461ad96b6496c8497bea23444e5f754d29e62" translate="yes" xml:space="preserve">
          <source>This checks a-z, A-Z, 0-9 ASCII characters only.</source>
          <target state="translated">此项只检查a-z,A-Z,0-9 ASCII字符。</target>
        </trans-unit>
        <trans-unit id="7dc2aa227843f2651d01fb29a6a47bedb18d9c19" translate="yes" xml:space="preserve">
          <source>This checks a-z, A-Z, 0-9 ASCII characters only. Returns true if all characters in &lt;em&gt;s&lt;/em&gt; are alpanumeric and there is at least one character in &lt;em&gt;s&lt;/em&gt;.</source>
          <target state="translated">这仅检查az，AZ，0-9 ASCII字符。返回true如果在所有字符&lt;em&gt;小号&lt;/em&gt;是alpanumeric并且至少有一个字符的&lt;em&gt;小号&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="fcb243522dd9085ea31f048f6623532706ee946c" translate="yes" xml:space="preserve">
          <source>This code demonstrates how you can iterate over all the tags in an HTML file and write back the modified version. In this case we look for hyperlinks ending with the extension &lt;code&gt;.rst&lt;/code&gt; and convert them to &lt;code&gt;.html&lt;/code&gt;.</source>
          <target state="translated">此代码演示了如何遍历HTML文件中的所有标记并写回修改后的版本。在这种情况下，我们将查找扩展名为 &lt;code&gt;.rst&lt;/code&gt; 的超链接，并将其转换为 &lt;code&gt;.html&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="67e26f346f2ccd3c86198d382ef1609a459caeec" translate="yes" xml:space="preserve">
          <source>This code has a shortcoming: if &lt;code&gt;debug&lt;/code&gt; is set to false someday, the quite expensive &lt;code&gt;$&lt;/code&gt; and &lt;code&gt;&amp;amp;&lt;/code&gt; operations are still performed! (The argument evaluation for procedures is &lt;em&gt;eager&lt;/em&gt;).</source>
          <target state="translated">此代码有一个缺点：如果某天将 &lt;code&gt;debug&lt;/code&gt; 设置为false，则仍然会执行相当昂贵的 &lt;code&gt;$&lt;/code&gt; 和 &lt;code&gt;&amp;amp;&lt;/code&gt; 操作！（过程的论证评估很&lt;em&gt;热切&lt;/em&gt;）。</target>
        </trans-unit>
        <trans-unit id="ddf8456d90256ef6813274665679598a51d6b207" translate="yes" xml:space="preserve">
          <source>This complements &lt;a href=&quot;#escape&quot;&gt;escape&lt;/a&gt; as it performs the opposite operations.</source>
          <target state="translated">这补充了&lt;a href=&quot;#escape&quot;&gt;逃逸，&lt;/a&gt;因为它执行相反的操作。</target>
        </trans-unit>
        <trans-unit id="eb30b5d51da059f03be346551003a62694c6e6c0" translate="yes" xml:space="preserve">
          <source>This condition holds:</source>
          <target state="translated">这个条件成立。</target>
        </trans-unit>
        <trans-unit id="81ebbfabdc2c9ddc216dc2043c4b3f433dfa4f83" translate="yes" xml:space="preserve">
          <source>This constant is used to determine whether the destination platform is fully supported by &lt;code&gt;ioselectors&lt;/code&gt; module.</source>
          <target state="translated">该常数用于确定 &lt;code&gt;ioselectors&lt;/code&gt; 模块是否完全支持目标平台。</target>
        </trans-unit>
        <trans-unit id="ec88b8f870dd5f6a3d62cb955fdcb976315090ca" translate="yes" xml:space="preserve">
          <source>This convenience proc parses any input string using rst markup (it doesn't have to be a full document!) and returns an embeddable piece of HTML. The proc is meant to be used in &lt;em&gt;online&lt;/em&gt; environments without access to a meaningful filesystem, and therefore rst &lt;code&gt;include&lt;/code&gt; like directives won't work. For an explanation of the &lt;code&gt;config&lt;/code&gt; parameter see the &lt;code&gt;initRstGenerator&lt;/code&gt; proc. Example:</source>
          <target state="translated">此便利过程使用rst标记解析任何输入字符串（不必是完整的文档！），并返回可嵌入的HTML。该proc旨在用于&lt;em&gt;在线&lt;/em&gt;环境中，而无需访问有意义的文件系统，因此，第一个 &lt;code&gt;include&lt;/code&gt; like指令将不起作用。有关 &lt;code&gt;config&lt;/code&gt; 参数的说明，请参见 &lt;code&gt;initRstGenerator&lt;/code&gt; proc。例：</target>
        </trans-unit>
        <trans-unit id="bf9772d9f40d4b88270d7bfcc87701c67c1f206a" translate="yes" xml:space="preserve">
          <source>This directive tells c2nim that it should annotate every proc that resulted from a C function prototype with the &lt;code&gt;dynlib&lt;/code&gt; pragma:</source>
          <target state="translated">该指令告诉c2nim，它应该标注每一个进程内起因于C函数原型与 &lt;code&gt;dynlib&lt;/code&gt; 编译：</target>
        </trans-unit>
        <trans-unit id="dc11ca4313f42aaa8eb535d6e6150b0aedbf3be6" translate="yes" xml:space="preserve">
          <source>This document describes Nim's standard library.</source>
          <target state="translated">本文档介绍了Nim的标准库。</target>
        </trans-unit>
        <trans-unit id="501826eded96f905ab59473404c85f59f07e601c" translate="yes" xml:space="preserve">
          <source>This document describes how the GC works and how to tune it for (soft) &lt;span id=&quot;realtime-systems_1&quot;&gt;realtime systems&lt;/span&gt;.</source>
          <target state="translated">本文档介绍了GC的工作方式以及如何针对（软）&lt;span id=&quot;realtime-systems_1&quot;&gt;实时系统&lt;/span&gt;对其进行调整。</target>
        </trans-unit>
        <trans-unit id="a1436145ee6291786c4efda6509df54038a00ce9" translate="yes" xml:space="preserve">
          <source>This document describes the &lt;span id=&quot;documentation-generation-tools_1&quot;&gt;documentation generation tools&lt;/span&gt; built into the &lt;a href=&quot;nimc&quot;&gt;Nim compiler&lt;/a&gt;, which can generate HTML and JSON output from input .nim files and projects, as well as HTML and LaTeX from input RST (reStructuredText) files. The output documentation will include module dependencies (&lt;code&gt;import&lt;/code&gt;), any top-level documentation comments (##), and exported symbols (*), including procedures, types, and variables.</source>
          <target state="translated">本文档介绍了&lt;a href=&quot;nimc&quot;&gt;Nim编译器中&lt;/a&gt;内置的&lt;span id=&quot;documentation-generation-tools_1&quot;&gt;文档生成工具&lt;/span&gt;，该&lt;span id=&quot;documentation-generation-tools_1&quot;&gt;工具&lt;/span&gt;可以从输入.nim文件和项目生成HTML和JSON输出，以及从输入RST（reStructuredText）文件生成HTML和LaTeX。输出文档将包括模块依赖项（ &lt;code&gt;import&lt;/code&gt; ），任何顶级文档注释（##）和导出的符号（*），包括过程，类型和变量。</target>
        </trans-unit>
        <trans-unit id="876d6f96c63ad0dcba59ff24b243aebd3e783be3" translate="yes" xml:space="preserve">
          <source>This document describes the lexis, the syntax, and the semantics of Nim.</source>
          <target state="translated">本文档描述了Nim的词法、语法和语义。</target>
        </trans-unit>
        <trans-unit id="beb13f15afd5992eb20356ca76c23dc066a055b6" translate="yes" xml:space="preserve">
          <source>This document describes the usage of the &lt;em&gt;Nim compiler&lt;/em&gt; on the different supported platforms. It is not a definition of the Nim programming language (therefore is the &lt;a href=&quot;manual&quot;&gt;manual&lt;/a&gt;).</source>
          <target state="translated">本文档介绍了&lt;em&gt;Nim编译器&lt;/em&gt;在不同支持平台上的用法。它不是Nim编程语言的定义（因此是&lt;a href=&quot;manual&quot;&gt;手册&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="3cb274ef505ac7161b2d0c10daf0e239378a408c" translate="yes" xml:space="preserve">
          <source>This document is a tutorial for the advanced constructs of the &lt;em&gt;Nim&lt;/em&gt; programming language. &lt;strong&gt;Note that this document is somewhat obsolete as the&lt;/strong&gt;&lt;a href=&quot;manual&quot;&gt;manual&lt;/a&gt;&lt;strong&gt;contains many more examples of the advanced language features.&lt;/strong&gt;</source>
          <target state="translated">本文档是有关&lt;em&gt;Nim&lt;/em&gt;编程语言的高级构造的教程。&lt;strong&gt;请注意，该文档已过时，因为该&lt;/strong&gt;&lt;a href=&quot;manual&quot;&gt;手册&lt;/a&gt;&lt;strong&gt;包含了更多高级语言功能的示例。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="51cc327eea029a9a74f8f2656806b1a3582d4c70" translate="yes" xml:space="preserve">
          <source>This document is a tutorial for the programming language &lt;em&gt;Nim&lt;/em&gt;. This tutorial assumes that you are familiar with basic programming concepts like variables, types or statements but is kept very basic. The &lt;a href=&quot;manual&quot;&gt;manual&lt;/a&gt; contains many more examples of the advanced language features. All code examples in this tutorial, as well as the ones found in the rest of Nim's documentation, follow the &lt;a href=&quot;nep1&quot;&gt;Nim style guide&lt;/a&gt;.</source>
          <target state="translated">本文档是&lt;em&gt;Nim&lt;/em&gt;编程语言的教程。本教程假定您熟悉基本的编程概念，例如变量，类型或语句，但始终保持非常基础。该&lt;a href=&quot;manual&quot;&gt;手册&lt;/a&gt;包含更多高级语言功能的示例。本教程中的所有代码示例以及Nim其余文档中提供的示例均遵循&lt;a href=&quot;nep1&quot;&gt;Nim样式指南&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="dc36e0a51521723c2d17399937c4b8017c6cb9b6" translate="yes" xml:space="preserve">
          <source>This document will guide you through the available options. If you want to look at practical examples of idetools support you can look at the test files found in the &lt;a href=&quot;#test-suite&quot;&gt;Test suite&lt;/a&gt; or &lt;a href=&quot;https://github.com/Araq/Nim/wiki/Editor-Support&quot;&gt;various editor integrations&lt;/a&gt; already available.</source>
          <target state="translated">本文档将指导您完成可用的选项。如果要查看idetools支持的实际示例，可以查看在&lt;a href=&quot;#test-suite&quot;&gt;测试套件中&lt;/a&gt;找到的测试文件或&lt;a href=&quot;https://github.com/Araq/Nim/wiki/Editor-Support&quot;&gt;各种&lt;/a&gt;可用的编辑器集成。</target>
        </trans-unit>
        <trans-unit id="b50c7c6fe53ac393a7c7fac0b0acdac2132c3be2" translate="yes" xml:space="preserve">
          <source>This document will guide you through the available options. If you want to look at practical examples of nimsuggest support you can look at the &lt;a href=&quot;https://github.com/Araq/Nim/wiki/Editor-Support&quot;&gt;various editor integrations&lt;/a&gt; already available.</source>
          <target state="translated">本文档将指导您完成可用的选项。如果您想查看最灵活的支持的实际示例，可以查看已经可用的&lt;a href=&quot;https://github.com/Araq/Nim/wiki/Editor-Support&quot;&gt;各种编辑器集成&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9463da66a61d4818bd3012c1d824f16d76b55047" translate="yes" xml:space="preserve">
          <source>This doesn't do anything if &lt;em&gt;key&lt;/em&gt; is already in &lt;em&gt;s&lt;/em&gt;. Example:</source>
          <target state="translated">如果&lt;em&gt;key&lt;/em&gt;已经在&lt;em&gt;s中，&lt;/em&gt;则不会执行任何操作。例：</target>
        </trans-unit>
        <trans-unit id="2d74bf1bd66d315281b8b850d55664417bfed9ea" translate="yes" xml:space="preserve">
          <source>This doesn't do anything if &lt;em&gt;key&lt;/em&gt; is not found in &lt;em&gt;s&lt;/em&gt;. Example:</source>
          <target state="translated">如果在&lt;em&gt;s中&lt;/em&gt;找不到&lt;em&gt;密钥，&lt;/em&gt;则此操作不会执行任何操作。例：&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="04208e500a8d87248355c319f0fd4502fe85e0e8" translate="yes" xml:space="preserve">
          <source>This example demonstrates the usage of the W3 HTML Validator, it uses &lt;code&gt;multipart/form-data&lt;/code&gt; as the &lt;code&gt;Content-Type&lt;/code&gt; to send the HTML to be validated to the server.</source>
          <target state="translated">此示例演示了W3 HTML验证程序的用法，它使用 &lt;code&gt;multipart/form-data&lt;/code&gt; 作为 &lt;code&gt;Content-Type&lt;/code&gt; 将要验证的HTML发送到服务器。</target>
        </trans-unit>
        <trans-unit id="dfa1b9eabc9505799b820ee46f8953f4c8f974ac" translate="yes" xml:space="preserve">
          <source>This example shows a procedure named &lt;code&gt;yes&lt;/code&gt; that asks the user a &lt;code&gt;question&lt;/code&gt; and returns true if they answered &quot;yes&quot; (or something similar) and returns false if they answered &quot;no&quot; (or something similar). A &lt;code&gt;return&lt;/code&gt; statement leaves the procedure (and therefore the while loop) immediately. The &lt;code&gt;(question: string): bool&lt;/code&gt; syntax describes that the procedure expects a parameter named &lt;code&gt;question&lt;/code&gt; of type &lt;code&gt;string&lt;/code&gt; and returns a value of type &lt;code&gt;bool&lt;/code&gt;. The &lt;code&gt;bool&lt;/code&gt; type is built-in: the only valid values for &lt;code&gt;bool&lt;/code&gt; are &lt;code&gt;true&lt;/code&gt; and &lt;code&gt;false&lt;/code&gt;. The conditions in if or while statements must be of type &lt;code&gt;bool&lt;/code&gt;.</source>
          <target state="translated">此示例显示了一个名为 &lt;code&gt;yes&lt;/code&gt; 的过程，该过程询问用户一个 &lt;code&gt;question&lt;/code&gt; ，如果用户回答&amp;ldquo;是&amp;rdquo;（或类似的结果），则返回true；如果用户回答&amp;ldquo;否&amp;rdquo;（或类似的结果），则返回false。一个 &lt;code&gt;return&lt;/code&gt; 语句立即离开的过程（并因此while循环）。的 &lt;code&gt;(question: string): bool&lt;/code&gt; 语法描述了该过程需要一个命名参数 &lt;code&gt;question&lt;/code&gt; 类型的 &lt;code&gt;string&lt;/code&gt; 并返回类型的值 &lt;code&gt;bool&lt;/code&gt; 。在 &lt;code&gt;bool&lt;/code&gt; 类型内置：为唯一有效值 &lt;code&gt;bool&lt;/code&gt; 是 &lt;code&gt;true&lt;/code&gt; 和 &lt;code&gt;false&lt;/code&gt; 。if或while语句中的条件必须为 &lt;code&gt;bool&lt;/code&gt; 类型。</target>
        </trans-unit>
        <trans-unit id="419751183c50edae04b9814dec67dc7101cf22a4" translate="yes" xml:space="preserve">
          <source>This example uses HTTP GET to retrieve &lt;code&gt;http://google.com&lt;/code&gt;:</source>
          <target state="translated">本示例使用HTTP GET检索 &lt;code&gt;http://google.com&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="c530469f8ff4d36d8c0d58dcb3d2f3b70e61c1b6" translate="yes" xml:space="preserve">
          <source>This example will create an HTTP server on port 8080. The server will respond to all requests with a &lt;code&gt;200 OK&lt;/code&gt; response code and &quot;Hello World&quot; as the response body.</source>
          <target state="translated">本示例将在端口8080上创建一个HTTP服务器。该服务器将使用 &lt;code&gt;200 OK&lt;/code&gt; 响应代码和&amp;ldquo; Hello World&amp;rdquo;作为响应正文来响应所有请求。</target>
        </trans-unit>
        <trans-unit id="82f9bd61449ea276e7ba79a6b51086b4f68f04d2" translate="yes" xml:space="preserve">
          <source>This exception is raised when a string parameter contains an illegal character</source>
          <target state="translated">当一个字符串参数中包含一个非法字符时,就会引发这个异常。</target>
        </trans-unit>
        <trans-unit id="49884cc4168ac3b56e2f36bd32448ca533036aba" translate="yes" xml:space="preserve">
          <source>This feature is still under development. In the future it will allow an IDE to evaluate an expression in the context of the currently running/debugged user project.</source>
          <target state="translated">这个功能仍在开发中。在未来,它将允许IDE在当前运行/调试的用户项目的上下文中评估一个表达式。</target>
        </trans-unit>
        <trans-unit id="baae068151a80870f517a9c80fabe195a66afe5b" translate="yes" xml:space="preserve">
          <source>This function checks for events on all the delegates in the &lt;em&gt;PDispatcher&lt;/em&gt;. It then proceeds to call the correct event handler.</source>
          <target state="translated">此函数检查&lt;em&gt;PDispatcher中&lt;/em&gt;所有委托上的&lt;em&gt;事件&lt;/em&gt;。然后，它将继续调用正确的事件处理程序。</target>
        </trans-unit>
        <trans-unit id="c640f2d135e1c682951e71cb417036f1e1dabc6c" translate="yes" xml:space="preserve">
          <source>This function returns &lt;code&gt;True&lt;/code&gt; if there are file descriptors that are still open, otherwise &lt;code&gt;False&lt;/code&gt;. File descriptors that have been closed are immediately removed from the dispatcher automatically.</source>
          <target state="translated">如果仍有文件描述符处于打开状态，则此函数返回 &lt;code&gt;True&lt;/code&gt; ，否则返回 &lt;code&gt;False&lt;/code&gt; 。已关闭的文件描述符会立即自动从调度程序中删除。</target>
        </trans-unit>
        <trans-unit id="80da17632a4719e714bb180d2505b06fb4c81b21" translate="yes" xml:space="preserve">
          <source>This function will lookup the IP address of a hostname.</source>
          <target state="translated">该功能将查询一个主机名的IP地址。</target>
        </trans-unit>
        <trans-unit id="888f45de89db87248b6c42a8441e4fc3f923719d" translate="yes" xml:space="preserve">
          <source>This function will lookup the hostname of an IP Address.</source>
          <target state="translated">该功能将查询一个IP地址的主机名。</target>
        </trans-unit>
        <trans-unit id="9ba85512a6c5538eb44a83be7203148f1393be22" translate="yes" xml:space="preserve">
          <source>This function will raise an EOS exception when a socket error occurs.</source>
          <target state="translated">当发生套接字错误时,该函数将引发一个EOS异常。</target>
        </trans-unit>
        <trans-unit id="83d0d0f248054169b861c6becec14e8bc119b1fc" translate="yes" xml:space="preserve">
          <source>This function will remove the data that was returned from the underlying &lt;code&gt;FutureStream&lt;/code&gt;.</source>
          <target state="translated">此函数将删除从基础 &lt;code&gt;FutureStream&lt;/code&gt; 返回的数据。</target>
        </trans-unit>
        <trans-unit id="48be562c3c3e831dca5c27c76a3332e0fe473cb4" translate="yes" xml:space="preserve">
          <source>This function will throw an EOS exception when an error occurs.</source>
          <target state="translated">当发生错误时,该函数将抛出一个EOS异常。</target>
        </trans-unit>
        <trans-unit id="0d0f4a3f3c929a542ada2a33db6e38abd1059abb" translate="yes" xml:space="preserve">
          <source>This function will throw an EOS exception when an error occurs. A value lower than 0 is never returned.</source>
          <target state="translated">当发生错误时,该函数将抛出一个EOS异常。小于0的值不会返回。</target>
        </trans-unit>
        <trans-unit id="125d21a7a8629f951aed2b4a51171c5e5038ef0b" translate="yes" xml:space="preserve">
          <source>This function will throw an OSError exception when an error occurs. A value lower than 0 is never returned.</source>
          <target state="translated">当发生错误时,该函数将抛出一个OSError异常。小于0的值不会返回。</target>
        </trans-unit>
        <trans-unit id="dc4ca2ac4f720e72b5b82cc411b68835f82a7af2" translate="yes" xml:space="preserve">
          <source>This happens for calculations whose results are too large to fit in the provided bits.</source>
          <target state="translated">这种情况会发生在计算结果太大而无法容纳在所提供的位上的情况下。</target>
        </trans-unit>
        <trans-unit id="f7d396147bbaee5b1e555360e29d6e7950ec2165" translate="yes" xml:space="preserve">
          <source>This has NOT yet been (extensively) tested against ODBC drivers for Teradata, Oracle, Sybase, MSSqlvSvr, et. al. databases.</source>
          <target state="translated">这还没有针对Teradata、Oracle、Sybase、MSSqlvSvr等数据库的ODBC驱动进行(广泛)测试。</target>
        </trans-unit>
        <trans-unit id="a80811f797327311abf9b8bb44734abd6ccfea15" translate="yes" xml:space="preserve">
          <source>This implementation calls &lt;code&gt;math.randomize()&lt;/code&gt; for the first call of &lt;code&gt;genOid&lt;/code&gt;.</source>
          <target state="translated">此实现为 &lt;code&gt;genOid&lt;/code&gt; 的首次调用调用 &lt;code&gt;math.randomize()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b58c523ddb24f9724b2d75ac0236939620e83491" translate="yes" xml:space="preserve">
          <source>This is a raw POSIX interface module. It does not not provide any convenience: cstrings are used instead of proper Nim strings and return codes indicate errors. If you want exceptions and a proper Nim-like interface, use the OS module or write a wrapper.</source>
          <target state="translated">这是一个原始的POSIX接口模块,它并没有提供任何便利:使用cstrings代替正确的Nim字符串,并且返回代码表示错误。它并没有提供任何便利性:用cstrings代替正确的Nim字符串,并且返回代码表示错误。如果你想得到异常和类似Nim的接口,请使用OS模块或写一个包装器。</target>
        </trans-unit>
        <trans-unit id="0e187a8e9e9b4d53c523d572ffaa0449d8fd615b" translate="yes" xml:space="preserve">
          <source>This is a simple syntactic transformation into:</source>
          <target state="translated">这是一个简单的句法转换为。</target>
        </trans-unit>
        <trans-unit id="baffe5aa2ca431a951c22f6627b3195c4e8e9257" translate="yes" xml:space="preserve">
          <source>This is a wrapper proc around &lt;a href=&quot;#copyFile&quot;&gt;copyFile()&lt;/a&gt;, &lt;a href=&quot;#getFilePermissions&quot;&gt;getFilePermissions()&lt;/a&gt; and &lt;a href=&quot;#setFilePermissions&quot;&gt;setFilePermissions()&lt;/a&gt; on non Windows platform. On Windows this proc is just a wrapper for &lt;a href=&quot;#copyFile&quot;&gt;copyFile()&lt;/a&gt; since that proc already copies attributes.</source>
          <target state="translated">这是在非Windows平台上围绕&lt;a href=&quot;#copyFile&quot;&gt;copyFile（）&lt;/a&gt;，&lt;a href=&quot;#getFilePermissions&quot;&gt;getFilePermissions（）&lt;/a&gt;和&lt;a href=&quot;#setFilePermissions&quot;&gt;setFilePermissions（）&lt;/a&gt;的包装过程。在Windows上，此proc只是&lt;a href=&quot;#copyFile&quot;&gt;copyFile（）&lt;/a&gt;的包装，因为该proc已经复制了属性。</target>
        </trans-unit>
        <trans-unit id="3a603ff59d56a2ac3e9b3c36a052ac4a5c2114b5" translate="yes" xml:space="preserve">
          <source>This is all single threaded, fully non-blocking and does give you a lot of control. In theory you should be able to work with any of these layers interchangeably (as long as you only care about non-Windows platforms).</source>
          <target state="translated">这都是单线程的,完全非阻塞的,而且确实给了你很多控制权。理论上,你应该可以和这些层中的任何一层互换工作(只要你只关心非Windows平台)。</target>
        </trans-unit>
        <trans-unit id="eb775bab32177650720f4b9d9b75ca0579c501f6" translate="yes" xml:space="preserve">
          <source>This is an alias for &lt;a href=&quot;#staticExec&quot;&gt;staticExec&lt;/a&gt;.</source>
          <target state="translated">这是&lt;a href=&quot;#staticExec&quot;&gt;staticExec&lt;/a&gt;的别名。</target>
        </trans-unit>
        <trans-unit id="f14a0c9a9b72673d11d5220860a7e2d032297599" translate="yes" xml:space="preserve">
          <source>This is an alias for &lt;a href=&quot;#staticRead&quot;&gt;staticRead&lt;/a&gt;.</source>
          <target state="translated">这是&lt;a href=&quot;#staticRead&quot;&gt;staticRead&lt;/a&gt;的别名。</target>
        </trans-unit>
        <trans-unit id="e39548494ffeefbdea437a44fba01f90cd710d14" translate="yes" xml:space="preserve">
          <source>This is an convenience iterator for iterating over command line arguments. This creates a new OptParser. See the above &lt;code&gt;getopt(var OptParser)&lt;/code&gt; example for using default empty &lt;code&gt;NoVal&lt;/code&gt; parameters. This example is for the same option keys as that example but here option key-value separators become optional for command users:</source>
          <target state="translated">这是用于迭代命令行参数的便捷迭代器。这将创建一个新的OptParser。有关使用默认的空 &lt;code&gt;NoVal&lt;/code&gt; 参数的信息，请参见上面的 &lt;code&gt;getopt(var OptParser)&lt;/code&gt; 示例。该示例与该示例使用相同的选项键，但此处选项键值分隔符对于命令用户变为可选：</target>
        </trans-unit>
        <trans-unit id="e447530d06e7e3f0eb38b06f1ec7e2d1eabe95e8" translate="yes" xml:space="preserve">
          <source>This is an convenience iterator for iterating over the given OptParser object. Example:</source>
          <target state="translated">这是一个方便的迭代器,用于迭代给定的OptParser对象。例子:</target>
        </trans-unit>
        <trans-unit id="46521745d7cb0cedd54b67fe6c5b314fc7bf2b49" translate="yes" xml:space="preserve">
          <source>This is an example of a configuration file.</source>
          <target state="translated">这是一个配置文件的例子。</target>
        </trans-unit>
        <trans-unit id="8621b33d7505ff2f752c63fce71661a8f7e46de8" translate="yes" xml:space="preserve">
          <source>This is best explained by an example:</source>
          <target state="translated">这一点用一个例子来解释是最好的。</target>
        </trans-unit>
        <trans-unit id="303d755730efc75b448e0367fb111543fb211df2" translate="yes" xml:space="preserve">
          <source>This is best illustrated by an example:</source>
          <target state="translated">这一点通过一个例子得到了最好的说明。</target>
        </trans-unit>
        <trans-unit id="6d07b0945aa6279aac37be60460c485fcc1ff52f" translate="yes" xml:space="preserve">
          <source>This is binary compatible to the type &lt;code&gt;char**&lt;/code&gt; in &lt;em&gt;C&lt;/em&gt;. The array's high value is large enough to disable bounds checking in practice. Use &lt;em&gt;cstringArrayToSeq&lt;/em&gt; to convert it into a &lt;code&gt;seq[string]&lt;/code&gt;.</source>
          <target state="translated">这与&lt;em&gt;C中的&lt;/em&gt; &lt;code&gt;char**&lt;/code&gt; 类型二进制兼容。实际上，数组的高值足以禁用边界检查。使用&lt;em&gt;cstringArrayToSeq&lt;/em&gt;将其转换为 &lt;code&gt;seq[string]&lt;/code&gt; 。&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="0bd38078b21b67094ebb387df8cff1e550ab3259" translate="yes" xml:space="preserve">
          <source>This is done using the &lt;code&gt;to&lt;/code&gt; macro. Take a look at &lt;a href=&quot;#to.m,JsonNode,typedesc&quot;&gt;its documentation&lt;/a&gt; to see an example of its use.</source>
          <target state="translated">这是使用 &lt;code&gt;to&lt;/code&gt; 宏完成的。查看&lt;a href=&quot;#to.m,JsonNode,typedesc&quot;&gt;其文档&lt;/a&gt;以查看其用法示例。</target>
        </trans-unit>
        <trans-unit id="0e255e0fbf090e03656557a6058c22d1d0988d1e" translate="yes" xml:space="preserve">
          <source>This is effectively the value of the &quot;Content-Length&quot; header.</source>
          <target state="translated">这实际上是 &quot;Content-Length &quot;头的值。</target>
        </trans-unit>
        <trans-unit id="ed8e6faffed9f4240c98845eace9c4ed1fe9f2f0" translate="yes" xml:space="preserve">
          <source>This is effectively the value of the &quot;Content-Type&quot; header.</source>
          <target state="translated">这实际上是 &quot;Content-Type &quot;头的值。</target>
        </trans-unit>
        <trans-unit id="86b65d9de6d29645204c64f1e3d019cece2fb6d2" translate="yes" xml:space="preserve">
          <source>This is effectively the value of the &quot;Last-Modified&quot; header.</source>
          <target state="translated">这实际上是 &quot;Last-Modified &quot;头的值。</target>
        </trans-unit>
        <trans-unit id="ae97abc8c2bdcefb0d913bd908e2fc80b7fe31b2" translate="yes" xml:space="preserve">
          <source>This is equivalent to &lt;code&gt;var&lt;/code&gt;, but with &lt;code&gt;nnkLetSection&lt;/code&gt; rather than &lt;code&gt;nnkVarSection&lt;/code&gt;.</source>
          <target state="translated">这等效于 &lt;code&gt;var&lt;/code&gt; ，但是使用 &lt;code&gt;nnkLetSection&lt;/code&gt; 而不是 &lt;code&gt;nnkVarSection&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="36d6a591729274afeef549b79cbc02b07d624ba3" translate="yes" xml:space="preserve">
          <source>This is equivalent to &lt;span id=&quot;inet-ntoa_1&quot;&gt;inet_ntoa&lt;/span&gt;.</source>
          <target state="translated">这等效于&lt;span id=&quot;inet-ntoa_1&quot;&gt;inet_ntoa&lt;/span&gt;。</target>
        </trans-unit>
        <trans-unit id="31be46f14ea5182185d28153c71f2103de5579e6" translate="yes" xml:space="preserve">
          <source>This is high-level interface for &lt;span id=&quot;getpeername_1&quot;&gt;getpeername&lt;/span&gt;.</source>
          <target state="translated">这是&lt;span id=&quot;getpeername_1&quot;&gt;getpeername&lt;/span&gt;的高级接口。</target>
        </trans-unit>
        <trans-unit id="2074516e24b0521a08ed457d7f66ebecf4eb273e" translate="yes" xml:space="preserve">
          <source>This is high-level interface for &lt;span id=&quot;getsockname_1&quot;&gt;getsockname&lt;/span&gt;.</source>
          <target state="translated">这是&lt;span id=&quot;getsockname_1&quot;&gt;getsockname&lt;/span&gt;的高级接口。</target>
        </trans-unit>
        <trans-unit id="3ddf14a4425a7355cc2a2fa04844ca91c2768874" translate="yes" xml:space="preserve">
          <source>This is not &lt;code&gt;pure&lt;/code&gt; mechanism for Windows Completion Ports (IOCP), so if you can avoid it, please do it. Use &lt;em&gt;addRead&lt;/em&gt; only if really need it (main usecase is adaptation of unix-like libraries to be asynchronous on Windows).</source>
          <target state="translated">这不是Windows完成端口（IOCP）的 &lt;code&gt;pure&lt;/code&gt; 机制，因此，如果可以避免，请执行此操作。仅在确实需要时才使用&lt;em&gt;addRead&lt;/em&gt;（主要用例是将类Unix的库改编为在Windows上异步）。</target>
        </trans-unit>
        <trans-unit id="55bde4657459bdfc7c019b27a4bfe5a2e63714bd" translate="yes" xml:space="preserve">
          <source>This is not &lt;code&gt;pure&lt;/code&gt; mechanism for Windows Completion Ports (IOCP), so if you can avoid it, please do it. Use &lt;em&gt;addWrite&lt;/em&gt; only if really need it (main usecase is adaptation of unix-like libraries to be asynchronous on Windows).</source>
          <target state="translated">这不是Windows完成端口（IOCP）的 &lt;code&gt;pure&lt;/code&gt; 机制，因此，如果可以避免，请执行此操作。仅在确实需要时才使用&lt;em&gt;addWrite&lt;/em&gt;（主要用例是将类Unix的库改编为在Windows上是异步的）。</target>
        </trans-unit>
        <trans-unit id="55e873a8f9ecb0f52084031638cec01f7691b7b6" translate="yes" xml:space="preserve">
          <source>This is not the same AST for all uses of &lt;code&gt;var&lt;/code&gt;. See [Procedure declaration](&lt;a href=&quot;http://nim-lang.org/docs/macros.html#statements-procedure-declaration&quot;&gt;http://nim-lang.org/docs/macros.html#statements-procedure-declaration&lt;/a&gt;) for details.</source>
          <target state="translated">对于 &lt;code&gt;var&lt;/code&gt; 的所有使用，这不是同一个AST 。有关详细信息，请参见[过程声明]（&lt;a href=&quot;http://nim-lang.org/docs/macros.html#statements-procedure-declaration&quot;&gt;http://nim-lang.org/docs/macros.html#statements-procedure-declaration&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="c2a7fe82c8947dd52185c1702a90b9db33146699" translate="yes" xml:space="preserve">
          <source>This is not the syntax for assignment when combined with &lt;code&gt;var&lt;/code&gt;, &lt;code&gt;let&lt;/code&gt;, or &lt;code&gt;const&lt;/code&gt;.</source>
          <target state="translated">与 &lt;code&gt;var&lt;/code&gt; ， &lt;code&gt;let&lt;/code&gt; 或 &lt;code&gt;const&lt;/code&gt; 结合使用时，这不是分配的语法。</target>
        </trans-unit>
        <trans-unit id="7b56f8d625d177685d852e8e5c0f45517f46c5cd" translate="yes" xml:space="preserve">
          <source>This is often better than disabling all warnings at once.</source>
          <target state="translated">这往往比一次性禁用所有警告要好。</target>
        </trans-unit>
        <trans-unit id="4d6f926873c2b638a1222cdb189469c5136966c2" translate="yes" xml:space="preserve">
          <source>This is often the same as the &lt;code&gt;head&lt;/code&gt; result of &lt;code&gt;splitPath&lt;/code&gt;. If there is no parent, &quot;&quot; is returned.</source>
          <target state="translated">这通常与 &lt;code&gt;splitPath&lt;/code&gt; 的 &lt;code&gt;head&lt;/code&gt; 结果相同。如果没有父母，则返回&amp;ldquo;&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="18b3f09919cd0742fbd659728142a828b4c8270a" translate="yes" xml:space="preserve">
          <source>This is often useful for generating some code where the items need to be &lt;em&gt;separated&lt;/em&gt; by &lt;em&gt;sep&lt;/em&gt;. &lt;em&gt;sep&lt;/em&gt; is only added if &lt;em&gt;dest&lt;/em&gt; is longer than &lt;em&gt;startLen&lt;/em&gt;. The following example creates a string describing an array of integers.</source>
          <target state="translated">这对于生成一些需要用&lt;em&gt;sep &lt;/em&gt;&lt;em&gt;分隔&lt;/em&gt;项目的代码通常很有用。仅当&lt;em&gt;dest&lt;/em&gt;大于&lt;em&gt;startLen&lt;/em&gt;时才添加&lt;em&gt;sep&lt;/em&gt;。下面的示例创建一个描述整数数组的字符串。&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9c4b5a1ec53f980e2c0f3189011ffcb0ab0d3401" translate="yes" xml:space="preserve">
          <source>This is only of interest if you want to write a custom &lt;code&gt;format&lt;/code&gt; proc that should support the standard format specifiers. If &lt;code&gt;ignoreUnknownSuffix&lt;/code&gt; is true, an unknown suffix after the &lt;code&gt;type&lt;/code&gt; field is not an error.</source>
          <target state="translated">仅当您要编写应支持标准格式说明符的自定义 &lt;code&gt;format&lt;/code&gt; proc时，这才有意义。如果 &lt;code&gt;ignoreUnknownSuffix&lt;/code&gt; 为true，则 &lt;code&gt;type&lt;/code&gt; 字段后的未知后缀不是错误。</target>
        </trans-unit>
        <trans-unit id="19846465c46a33495b53f4086a71823a95381c03" translate="yes" xml:space="preserve">
          <source>This is only raised if the &lt;code&gt;segfaults.nim&lt;/code&gt; module was imported!</source>
          <target state="translated">仅当导入了 &lt;code&gt;segfaults.nim&lt;/code&gt; 模块时才会引发此问题！</target>
        </trans-unit>
        <trans-unit id="88b8e0f949b1068c1e1a8a842d9da6796b501f9c" translate="yes" xml:space="preserve">
          <source>This is only useful if the program is compiled as a dynamic library via the &lt;code&gt;--app:lib&lt;/code&gt; command line option. This pragma only has an effect for the code generation on the Windows target, so when this pragma is forgotten and the dynamic library is only tested on Mac and/or Linux, there won't be an error. On Windows this pragma adds &lt;code&gt;__declspec(dllexport)&lt;/code&gt; to the function declaration.</source>
          <target state="translated">仅当通过 &lt;code&gt;--app:lib&lt;/code&gt; 命令行选项将程序编译为动态库时，此功能才有用。该编译指示仅对Windows目标上的代码生成有效，因此，当忘记该编译指示并且仅在Mac和/或Linux上对动态库进行测试时，不会出现错误。在Windows上，此杂注将 &lt;code&gt;__declspec(dllexport)&lt;/code&gt; 添加到函数声明中。</target>
        </trans-unit>
        <trans-unit id="d812993dd18329bdd5b49f464355b81590a6389c" translate="yes" xml:space="preserve">
          <source>This is optional.</source>
          <target state="translated">这是可选的。</target>
        </trans-unit>
        <trans-unit id="624193289805ef01288ef5a655555f1018d6592e" translate="yes" xml:space="preserve">
          <source>This is roughly equivalent to the &lt;code&gt;async&lt;/code&gt; keyword in JavaScript code.</source>
          <target state="translated">这大致相当于JavaScript代码中的 &lt;code&gt;async&lt;/code&gt; 关键字。</target>
        </trans-unit>
        <trans-unit id="3575fcfddeaf3d18e36c701dd650fc2ec44479fc" translate="yes" xml:space="preserve">
          <source>This is same as &lt;code&gt;x - floorDiv(x, y) * y&lt;/code&gt;. This proc behaves the same as the &lt;code&gt;%&lt;/code&gt; operator in python.</source>
          <target state="translated">这与 &lt;code&gt;x - floorDiv(x, y) * y&lt;/code&gt; 。此proc的行为与python中的 &lt;code&gt;%&lt;/code&gt; 运算符相同。</target>
        </trans-unit>
        <trans-unit id="256bc61e58ad13a05d91f1a1bf2ae4f72005afe4" translate="yes" xml:space="preserve">
          <source>This is the concrete lookup algorithm that &lt;code&gt;&amp;amp;&lt;/code&gt; uses:</source>
          <target state="translated">这是 &lt;code&gt;&amp;amp;&lt;/code&gt; 使用的具体查找算法：</target>
        </trans-unit>
        <trans-unit id="36c2f5442839943020ad05dd2166b1d0f12b01e5" translate="yes" xml:space="preserve">
          <source>This is the high-level version of the above &lt;code&gt;sendTo&lt;/code&gt; function.</source>
          <target state="translated">这是上述 &lt;code&gt;sendTo&lt;/code&gt; 函数的高级版本。</target>
        </trans-unit>
        <trans-unit id="4826edc58b175eebfbf7081691448d2931000418" translate="yes" xml:space="preserve">
          <source>This is the jump function for the generator. It is equivalent to 2^64 calls to next(); it can be used to generate 2^64 non-overlapping subsequences for parallel computations.</source>
          <target state="translated">这是生成器的跳转函数,相当于2^64次调用next();它可以用来生成2^64个不重叠的子序列,用于并行计算。它相当于2^64次对next()的调用;它可以用来生成2^64次非重叠的子序列,用于并行计算。</target>
        </trans-unit>
        <trans-unit id="6d2f0ff4e73777d01102bb217c8397c6cddd4b22" translate="yes" xml:space="preserve">
          <source>This is the main &lt;em&gt;project&lt;/em&gt; filename. Most of the time you will pass in the same as &lt;strong&gt;FILE&lt;/strong&gt;, but for bigger projects this is the file which is used as main entry point for the program, the one which users compile to generate a final binary.</source>
          <target state="translated">这是主&lt;em&gt;项目&lt;/em&gt;文件名。在大多数情况下，您将传递与&lt;strong&gt;FILE&lt;/strong&gt;相同的&lt;strong&gt;文件&lt;/strong&gt;，但是对于较大的项目，这是用作程序的主要入口点的文件，用户可以编译该文件以生成最终的二进制文件。</target>
        </trans-unit>
        <trans-unit id="60a0c5c21aaa578b306725a8da9b601c4bd7d709" translate="yes" xml:space="preserve">
          <source>This is the name of the module or include file the query refers to.</source>
          <target state="translated">这是该查询引用的模块或包含文件的名称。</target>
        </trans-unit>
        <trans-unit id="c110d8ea0aa1384440227425443ae86a6ce178fd" translate="yes" xml:space="preserve">
          <source>This is the safecall convention as specified by Microsoft. The generated C procedure is declared with the &lt;code&gt;__safecall&lt;/code&gt; keyword. The word &lt;em&gt;safe&lt;/em&gt; refers to the fact that all hardware registers shall be pushed to the hardware stack.</source>
          <target state="translated">这是Microsoft指定的safecall约定。生成的C过程使用 &lt;code&gt;__safecall&lt;/code&gt; 关键字声明。这个词&lt;em&gt;安全&lt;/em&gt;指的是所有的硬件寄存器应推到硬件堆栈。</target>
        </trans-unit>
        <trans-unit id="17370dc7ee3b0fe9dd442daf544baba9de37a9cc" translate="yes" xml:space="preserve">
          <source>This is the same as &lt;code&gt;formatstr % [a]&lt;/code&gt;.</source>
          <target state="translated">这与 &lt;code&gt;formatstr % [a]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5f5ff4983f3a23d7cc3be988cf86d83e4cd1f019" translate="yes" xml:space="preserve">
          <source>This is the same as &lt;code&gt;formatstr % a&lt;/code&gt; except that it supports auto stringification.</source>
          <target state="translated">这与 &lt;code&gt;formatstr % a&lt;/code&gt; 相同，除了它支持自动字符串化。</target>
        </trans-unit>
        <trans-unit id="01a5b235024b77996dea512c125137d383106839" translate="yes" xml:space="preserve">
          <source>This is the same as &lt;code&gt;len(splitLines(s))&lt;/code&gt;, but much more efficient because it doesn't modify the string creating temporal objects. Every &lt;a href=&quot;manual#character-literals&quot;&gt;character literal&lt;/a&gt; newline combination (CR, LF, CR-LF) is supported.</source>
          <target state="translated">这与 &lt;code&gt;len(splitLines(s))&lt;/code&gt; 相同，但是效率更高，因为它不会修改创建临时对象的字符串。支持每个&lt;a href=&quot;manual#character-literals&quot;&gt;字符文字&lt;/a&gt;换行符组合（CR，LF，CR-LF）。</target>
        </trans-unit>
        <trans-unit id="82a366ac081a365e2c46179906b192a6a0e436be" translate="yes" xml:space="preserve">
          <source>This is the same as the type &lt;code&gt;char&lt;/code&gt; in &lt;em&gt;C&lt;/em&gt;.</source>
          <target state="translated">这是相同的类型 &lt;code&gt;char&lt;/code&gt; 在&lt;em&gt;&amp;Ccedil;&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="2698b8a90aa68f611a0ef1370a3ab044cd78c8a1" translate="yes" xml:space="preserve">
          <source>This is the same as the type &lt;code&gt;double&lt;/code&gt; in &lt;em&gt;C&lt;/em&gt;.</source>
          <target state="translated">这是相同的类型 &lt;code&gt;double&lt;/code&gt; 中&lt;em&gt;&amp;Ccedil;&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="32b6f8ca0c7194eb4b06ee5d7e525de947b0dfd5" translate="yes" xml:space="preserve">
          <source>This is the same as the type &lt;code&gt;float&lt;/code&gt; in &lt;em&gt;C&lt;/em&gt;.</source>
          <target state="translated">这是相同的类型 &lt;code&gt;float&lt;/code&gt; 在&lt;em&gt;&amp;Ccedil;&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="1a9d8dde930868443d859228ae0d07c7a292dfc2" translate="yes" xml:space="preserve">
          <source>This is the same as the type &lt;code&gt;int&lt;/code&gt; in &lt;em&gt;C&lt;/em&gt;.</source>
          <target state="translated">这是相同的类型 &lt;code&gt;int&lt;/code&gt; 在&lt;em&gt;C ^&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="89b75f0da7ac2537212723421db03228b32fdc6c" translate="yes" xml:space="preserve">
          <source>This is the same as the type &lt;code&gt;long double&lt;/code&gt; in &lt;em&gt;C&lt;/em&gt;. This C type is not supported by Nim's code generator.</source>
          <target state="translated">这是相同的类型 &lt;code&gt;long double&lt;/code&gt; 在&lt;em&gt;&amp;Ccedil;&lt;/em&gt;。Nim的代码生成器不支持此C类型。</target>
        </trans-unit>
        <trans-unit id="a37990dbd3eb06078ca83a8a56a6c3bd79234e4f" translate="yes" xml:space="preserve">
          <source>This is the same as the type &lt;code&gt;long long&lt;/code&gt; in &lt;em&gt;C&lt;/em&gt;.</source>
          <target state="translated">这是相同的类型 &lt;code&gt;long long&lt;/code&gt; 在&lt;em&gt;&amp;Ccedil;&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="1069dac8f5d3d5aa1a18361c4ff3f9b241cbf315" translate="yes" xml:space="preserve">
          <source>This is the same as the type &lt;code&gt;long&lt;/code&gt; in &lt;em&gt;C&lt;/em&gt;.</source>
          <target state="translated">这是相同的类型 &lt;code&gt;long&lt;/code&gt; 在&lt;em&gt;&amp;Ccedil;&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="7f6dc406a78e144191704d8486e22dc8fbe652f6" translate="yes" xml:space="preserve">
          <source>This is the same as the type &lt;code&gt;short&lt;/code&gt; in &lt;em&gt;C&lt;/em&gt;.</source>
          <target state="translated">这是相同的类型 &lt;code&gt;short&lt;/code&gt; 于&lt;em&gt;&amp;Ccedil;&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="e4c3756c51223d58c50aef0d5dbf74eeee747dd1" translate="yes" xml:space="preserve">
          <source>This is the same as the type &lt;code&gt;signed char&lt;/code&gt; in &lt;em&gt;C&lt;/em&gt;.</source>
          <target state="translated">这是作为类型相同 &lt;code&gt;signed char&lt;/code&gt; 在&lt;em&gt;&amp;Ccedil;&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="3bf874f74960f31038430fb144d0f39aa055b895" translate="yes" xml:space="preserve">
          <source>This is the same as the type &lt;code&gt;size_t&lt;/code&gt; in &lt;em&gt;C&lt;/em&gt;.</source>
          <target state="translated">这是相同的类型 &lt;code&gt;size_t&lt;/code&gt; 在&lt;em&gt;&amp;Ccedil;&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="df1c839c0f570919cf81eef346ac2a1dbb8ad2c9" translate="yes" xml:space="preserve">
          <source>This is the same as the type &lt;code&gt;unsigned char&lt;/code&gt; in &lt;em&gt;C&lt;/em&gt;.</source>
          <target state="translated">这是一样的类型 &lt;code&gt;unsigned char&lt;/code&gt; 在&lt;em&gt;&amp;Ccedil;&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="32542074871fb6c497f5c1eb6606f80b3822a88a" translate="yes" xml:space="preserve">
          <source>This is the same as the type &lt;code&gt;unsigned int&lt;/code&gt; in &lt;em&gt;C&lt;/em&gt;.</source>
          <target state="translated">这是一样的类型 &lt;code&gt;unsigned int&lt;/code&gt; 在&lt;em&gt;&amp;Ccedil;&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="36b8d34561a415968642b59c4b4b326317e48753" translate="yes" xml:space="preserve">
          <source>This is the same as the type &lt;code&gt;unsigned long long&lt;/code&gt; in &lt;em&gt;C&lt;/em&gt;.</source>
          <target state="translated">这是相同的类型 &lt;code&gt;unsigned long long&lt;/code&gt; 在&lt;em&gt;&amp;Ccedil;&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="0aa9bfe67b304447b5a2bcc627f38a17da1684d8" translate="yes" xml:space="preserve">
          <source>This is the same as the type &lt;code&gt;unsigned long&lt;/code&gt; in &lt;em&gt;C&lt;/em&gt;.</source>
          <target state="translated">这是相同的类型 &lt;code&gt;unsigned long&lt;/code&gt; 在&lt;em&gt;&amp;Ccedil;&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="cca46f57d68aae82238b145830c6ebed78c459d0" translate="yes" xml:space="preserve">
          <source>This is the same as the type &lt;code&gt;unsigned short&lt;/code&gt; in &lt;em&gt;C&lt;/em&gt;.</source>
          <target state="translated">这是相同的类型 &lt;code&gt;unsigned short&lt;/code&gt; 于&lt;em&gt;&amp;Ccedil;&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="7ec63cde9c899b1832f254d3a218fb0fdefa84a7" translate="yes" xml:space="preserve">
          <source>This is the same interface that is implemented for other databases.</source>
          <target state="translated">这和其他数据库实现的接口是一样的。</target>
        </trans-unit>
        <trans-unit id="193cec7a7162a70eca01c095ac18043a02af9656" translate="yes" xml:space="preserve">
          <source>This is used, for example, in the &lt;code&gt;bindSym&lt;/code&gt; examples [here](&lt;a href=&quot;http://nim-lang.org/docs/manual.html#macros-bindsym&quot;&gt;http://nim-lang.org/docs/manual.html#macros-bindsym&lt;/a&gt;) and with &lt;code&gt;re&quot;some regexp&quot;&lt;/code&gt; in the regular expression module.</source>
          <target state="translated">例如，在 &lt;code&gt;bindSym&lt;/code&gt; 示例[here]（&lt;a href=&quot;http://nim-lang.org/docs/manual.html#macros-bindsym&quot;&gt;http://nim-lang.org/docs/manual.html#macros-bindsym&lt;/a&gt;）和正则表达式模块中带有 &lt;code&gt;re&quot;some regexp&quot;&lt;/code&gt; 情况下使用此方法。</target>
        </trans-unit>
        <trans-unit id="814be46e563ada83f9262b5e8d3fa69226b5320b" translate="yes" xml:space="preserve">
          <source>This is very fast, but potentially dangerous. Use this iterator only if you require &lt;strong&gt;ALL&lt;/strong&gt; the rows.</source>
          <target state="translated">这是非常快的，但是有潜在的危险。仅在需要&lt;strong&gt;所有&lt;/strong&gt;行时才使用此迭代器。</target>
        </trans-unit>
        <trans-unit id="cd0fbed086855b31d79192247a84655610b15079" translate="yes" xml:space="preserve">
          <source>This library relies on the header files of your C compiler. The resulting C code will just &lt;code&gt;#include &amp;lt;XYZ.h&amp;gt;&lt;/code&gt; and &lt;em&gt;not&lt;/em&gt; define the symbols declared here.</source>
          <target state="translated">该库依赖于C编译器的头文件。生成的C代码将仅 &lt;code&gt;#include &amp;lt;XYZ.h&amp;gt;&lt;/code&gt; ，&lt;em&gt;而不&lt;/em&gt;定义此处声明的符号。</target>
        </trans-unit>
        <trans-unit id="352e8583e6de97b799c5da9ed3e4a4e5b04d179b" translate="yes" xml:space="preserve">
          <source>This makes it easy to delete all generated files. Files generated in this directory follow a naming logic which you can read about in the &lt;a href=&quot;backends#nimcache-naming-logic&quot;&gt;Nim Backend Integration document&lt;/a&gt;.</source>
          <target state="translated">这样可以轻松删除所有生成的文件。在该目录中生成的文件遵循命名逻辑，您可以在&lt;a href=&quot;backends#nimcache-naming-logic&quot;&gt;Nim Backend Integration文档中&lt;/a&gt;阅读该命名逻辑。</target>
        </trans-unit>
        <trans-unit id="052067fc6ee68fa2f9dbd0b6a372e7c4df39a2b8" translate="yes" xml:space="preserve">
          <source>This means that any &lt;code&gt;'%xx'&lt;/code&gt; (where &lt;code&gt;xx&lt;/code&gt; denotes a hexadecimal value) are converted to the character with ordinal number &lt;code&gt;xx&lt;/code&gt;, and every other character is carried over.</source>
          <target state="translated">这意味着任何 &lt;code&gt;'%xx'&lt;/code&gt; （其中 &lt;code&gt;xx&lt;/code&gt; 表示一个十六进制值）都将转换为序号为 &lt;code&gt;xx&lt;/code&gt; 的字符，并且每隔一个字符都会被保留。</target>
        </trans-unit>
        <trans-unit id="a119e88cdea67075391ab49a84997ba0f8df61b5" translate="yes" xml:space="preserve">
          <source>This means that characters in the set &lt;code&gt;{'a'..'z', 'A'..'Z', '0'..'9', '-', '.', '_', '~'}&lt;/code&gt; are carried over to the result. All other characters are encoded as &lt;code&gt;''%xx'&lt;/code&gt; where &lt;code&gt;xx&lt;/code&gt; denotes its hexadecimal value.</source>
          <target state="translated">这意味着集合 &lt;code&gt;{'a'..'z', 'A'..'Z', '0'..'9', '-', '.', '_', '~'}&lt;/code&gt; 结转到结果。所有其他字符均编码为 &lt;code&gt;''%xx'&lt;/code&gt; ，其中 &lt;code&gt;xx&lt;/code&gt; 表示其十六进制值。</target>
        </trans-unit>
        <trans-unit id="40b048bf83553881e511d74bd63cac489f70ae5d" translate="yes" xml:space="preserve">
          <source>This means that the slashes inside the base URI's path as well as reference URI's path affect the resulting URI.</source>
          <target state="translated">这意味着基础URI路径和引用URI路径中的斜线会影响结果的URI。</target>
        </trans-unit>
        <trans-unit id="4ef6d8c1596a849e1d58fe82a1e6a88d8d08fefb" translate="yes" xml:space="preserve">
          <source>This means the following compiles (for now) even though it really should not:</source>
          <target state="translated">这意味着下面的编译(目前),尽管它确实不应该。</target>
        </trans-unit>
        <trans-unit id="10445172840b8572e10f6fbc77991aa94729820e" translate="yes" xml:space="preserve">
          <source>This mechanism will be used by most data structures that support shared memory like channels to implement thread safe automatic memory management.</source>
          <target state="translated">这种机制将被大多数支持共享内存的数据结构(如通道)使用,以实现线程安全的自动内存管理。</target>
        </trans-unit>
        <trans-unit id="5cce8e43b46c329ab2a3787ae9c0cae31bce9579" translate="yes" xml:space="preserve">
          <source>This method call syntax is not restricted to objects, it can be used for any type:</source>
          <target state="translated">这种方法调用语法不限于对象,它可以用于任何类型。</target>
        </trans-unit>
        <trans-unit id="c18ebc20a57311d93348b03173ca9377d2b87fe3" translate="yes" xml:space="preserve">
          <source>This method call syntax is not restricted to objects, it can be used to supply any type of first argument for procedures:</source>
          <target state="translated">这种方法调用语法并不限于对象,它可以用来为程序提供任何类型的第一个参数。</target>
        </trans-unit>
        <trans-unit id="e8a743fd1b7ce29c9eafd7535f1bcb06655400ac" translate="yes" xml:space="preserve">
          <source>This modifies &lt;em&gt;s&lt;/em&gt; itself, it does not return a copy.</source>
          <target state="translated">这本身会修改&lt;em&gt;s&lt;/em&gt;，但不会返回副本。</target>
        </trans-unit>
        <trans-unit id="da5bab7c7f53e383fb7fd313b6d6578109127b68" translate="yes" xml:space="preserve">
          <source>This module &lt;strong&gt;partially&lt;/strong&gt; implements an FTP client as specified by &lt;a href=&quot;http://tools.ietf.org/html/rfc959&quot;&gt;RFC 959&lt;/a&gt;.</source>
          <target state="translated">此模块&lt;strong&gt;部分&lt;/strong&gt;实现&lt;a href=&quot;http://tools.ietf.org/html/rfc959&quot;&gt;RFC 959&lt;/a&gt;指定的FTP客户端。</target>
        </trans-unit>
        <trans-unit id="353b9d1b799c5ad1bd4a492759bb6ea40d16c6be" translate="yes" xml:space="preserve">
          <source>This module allows high-level and efficient I/O multiplexing.</source>
          <target state="translated">该模块可以实现高层次、高效率的I/O复用。</target>
        </trans-unit>
        <trans-unit id="77582b104bbd815cba00372c32475601c25cf527" translate="yes" xml:space="preserve">
          <source>This module allows you to access fields in a parsed JSON object in two different ways, one of them is described in this section.</source>
          <target state="translated">该模块允许你以两种不同的方式访问解析JSON对象中的字段,其中一种方式将在本节中描述。</target>
        </trans-unit>
        <trans-unit id="b3498eb6ea3bb3348c1e6a56f205dc1cc756e769" translate="yes" xml:space="preserve">
          <source>This module also implements a &lt;code&gt;scanp&lt;/code&gt; macro, which syntax somewhat resembles an EBNF or PEG grammar, except that it uses Nim's expression syntax and so has to use prefix instead of postfix operators.</source>
          <target state="translated">该模块还实现了 &lt;code&gt;scanp&lt;/code&gt; 宏，其语法有点类似于EBNF或PEG语法，只是它使用Nim的表达式语法，因此必须使用前缀而不是后缀运算符。</target>
        </trans-unit>
        <trans-unit id="ef44ae92a94357463ee874a1523c9d291e715eef" translate="yes" xml:space="preserve">
          <source>This module also implements the protocol used to format messages, as specified by RFC 2822.</source>
          <target state="translated">该模块还实现了RFC 2822规定的用于格式化消息的协议。</target>
        </trans-unit>
        <trans-unit id="7a5d643a068677170a94b694f4f1ab9c3fa2652e" translate="yes" xml:space="preserve">
          <source>This module can also be used to comfortably create JSON using the &lt;em&gt;%*&lt;/em&gt; operator:</source>
          <target state="translated">此模块还可用于使用&lt;em&gt;％*&lt;/em&gt;运算符轻松地创建JSON ：</target>
        </trans-unit>
        <trans-unit id="d6e7d195d331b7d6c15e12922caec76c1b942621" translate="yes" xml:space="preserve">
          <source>This module contains Nim's support for locks and condition vars.</source>
          <target state="translated">该模块包含Nim对锁和条件变量的支持。</target>
        </trans-unit>
        <trans-unit id="762c0c406df7455c202f1f73c29bbcaf2e671b58" translate="yes" xml:space="preserve">
          <source>This module contains Nim's support for reentrant locks.</source>
          <target state="translated">这个模块包含了Nim对再入锁的支持。</target>
        </trans-unit>
        <trans-unit id="40ca976fb8b35eb3df922d2b5066e9569252023d" translate="yes" xml:space="preserve">
          <source>This module contains a &lt;span id=&quot;scanf_1&quot;&gt;scanf&lt;/span&gt; macro that can be used for extracting substrings from an input string. This is often easier than regular expressions. Some examples as an appetizer:</source>
          <target state="translated">该模块包含一个&lt;span id=&quot;scanf_1&quot;&gt;scanf&lt;/span&gt;宏，可用于从输入字符串中提取子字符串。这通常比正则表达式容易。作为开胃菜的一些例子：</target>
        </trans-unit>
        <trans-unit id="1489dea58f0e2e175da913a82f51d717b857c72e" translate="yes" xml:space="preserve">
          <source>This module contains a few procedures to control the &lt;em&gt;terminal&lt;/em&gt; (also called &lt;em&gt;console&lt;/em&gt;). On UNIX, the implementation simply uses ANSI escape sequences and does not depend on any other module, on Windows it uses the Windows API. Changing the style is permanent even after program termination! Use the code &lt;code&gt;system.addQuitProc(resetAttributes)&lt;/code&gt; to restore the defaults. Similarly, if you hide the cursor, make sure to unhide it with &lt;code&gt;showCursor&lt;/code&gt; before quitting.</source>
          <target state="translated">该模块包含一些控制&lt;em&gt;终端&lt;/em&gt;（也称为&lt;em&gt;console&lt;/em&gt;）的过程。在UNIX上，该实现仅使用ANSI转义序列，并且不依赖于任何其他模块，在Windows上，它使用Windows API。即使终止程序，更改样式也是永久的！使用代码 &lt;code&gt;system.addQuitProc(resetAttributes)&lt;/code&gt; 恢复默认值。同样，如果您隐藏光标，请确保在退出之前使用 &lt;code&gt;showCursor&lt;/code&gt; 取消隐藏它。</target>
        </trans-unit>
        <trans-unit id="1f440cc00bf2a40f36bf90840926be53d2b4581f" translate="yes" xml:space="preserve">
          <source>This module contains basic operating system facilities like retrieving environment variables, reading command line arguments, working with directories, running shell commands, etc.</source>
          <target state="translated">该模块包含基本的操作系统设施,如检索环境变量、读取命令行参数、使用目录、运行shell命令等。</target>
        </trans-unit>
        <trans-unit id="f8484eb3bf4310e5df9a41c735476490885f266c" translate="yes" xml:space="preserve">
          <source>This module contains helpers for parsing tokens, numbers, identifiers, etc.</source>
          <target state="translated">该模块包含解析标记、数字、标识符等的助手。</target>
        </trans-unit>
        <trans-unit id="86de046f7b616971dd6062d8ab76fb2ee06ec285" translate="yes" xml:space="preserve">
          <source>This module contains helpers that deal with different byte orders (&lt;span id=&quot;endian_1&quot;&gt;endian&lt;/span&gt;).</source>
          <target state="translated">此模块包含处理不同字节顺序（&lt;span id=&quot;endian_1&quot;&gt;endian&lt;/span&gt;）的帮助程序。</target>
        </trans-unit>
        <trans-unit id="3507a070fad07c9f9b3947b600282a6e5783a4cf" translate="yes" xml:space="preserve">
          <source>This module contains procs for &lt;span id=&quot;serialization_1&quot;&gt;serialization&lt;/span&gt; and &lt;span id=&quot;deseralization_1&quot;&gt;deseralization&lt;/span&gt; of arbitrary Nim data structures. The serialization format uses &lt;span id=&quot;json_1&quot;&gt;JSON&lt;/span&gt;. Warning: The serialization format could change in future!</source>
          <target state="translated">该模块包含用于对任意Nim数据结构进行&lt;span id=&quot;serialization_1&quot;&gt;序列化&lt;/span&gt;和&lt;span id=&quot;deseralization_1&quot;&gt;反&lt;/span&gt;&lt;span id=&quot;serialization_1&quot;&gt;序列化的&lt;/span&gt;&lt;span id=&quot;deseralization_1&quot;&gt;proc&lt;/span&gt;。序列化格式使用&lt;span id=&quot;json_1&quot;&gt;JSON&lt;/span&gt;。警告：序列化格式将来可能会更改！</target>
        </trans-unit>
        <trans-unit id="371318c1a0161f22d8f2e0f2e50fa5c06ee82a39" translate="yes" xml:space="preserve">
          <source>This module contains routines and types for dealing with time using a proleptic Gregorian calendar. It's also available for the &lt;a href=&quot;backends#the-javascript-target&quot;&gt;JavaScript target&lt;/a&gt;.</source>
          <target state="translated">该模块包含用于使用多事历公历处理时间的例程和类型。它也可用于&lt;a href=&quot;backends#the-javascript-target&quot;&gt;JavaScript target&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="681edb1a4152d4c5c1a28a26efed7538442ba878" translate="yes" xml:space="preserve">
          <source>This module contains support for a &lt;span id=&quot;rope_1&quot;&gt;rope&lt;/span&gt; data type. Ropes can represent very long strings efficiently; especially concatenation is done in O(1) instead of O(n). They are essentially concatenation trees that are only flattened when converting to a native Nim string. The empty string is represented by &lt;code&gt;nil&lt;/code&gt;. Ropes are immutable and subtrees can be shared without copying. Leaves can be cached for better memory efficiency at the cost of runtime efficiency.</source>
          <target state="translated">该模块包含对&lt;span id=&quot;rope_1&quot;&gt;绳索&lt;/span&gt;数据类型的支持。绳索可以有效地代表很长的弦；特别是串联是在O（1）而不是O（n）中完成的。它们本质上是串联树，仅在转换为本地Nim字符串时才被展平。空字符串由 &lt;code&gt;nil&lt;/code&gt; 表示。绳索是不可变的，子树可以共享而无需复制。可以缓存叶以提高内存效率，但要以运行时效率为代价。</target>
        </trans-unit>
        <trans-unit id="48a18d40233e79f25223ec93664005a48f943242" translate="yes" xml:space="preserve">
          <source>This module contains the interface to the compiler's abstract syntax tree (&lt;span id=&quot;ast_1&quot;&gt;AST&lt;/span&gt;). Macros operate on this tree.</source>
          <target state="translated">此模块包含编译器抽象语法树（&lt;span id=&quot;ast_1&quot;&gt;AST&lt;/span&gt;）的接口。宏在此树上运行。</target>
        </trans-unit>
        <trans-unit id="4a11c4dcef359935de61e37ffe6d34cb9d89068f" translate="yes" xml:space="preserve">
          <source>This module contains various string matchers for email addresses, etc.</source>
          <target state="translated">该模块包含各种电子邮件地址的字符串匹配器等。</target>
        </trans-unit>
        <trans-unit id="dc6f5f3c4d5eabca058f0bb06a0585786c4d3b49" translate="yes" xml:space="preserve">
          <source>This module contains various string utility routines that are uncommonly used in comparison to &lt;a href=&quot;strutils&quot;&gt;strutils&lt;/a&gt;.</source>
          <target state="translated">该模块包含各种字符串实用程序例程，这些例程与&lt;a href=&quot;strutils&quot;&gt;strutils&lt;/a&gt;相比不常用。</target>
        </trans-unit>
        <trans-unit id="4d2fcdeecb346421f24a622468611b1e35012c38" translate="yes" xml:space="preserve">
          <source>This module contains various string utility routines. See the module &lt;a href=&quot;re&quot;&gt;re&lt;/a&gt; for regular expression support. See the module &lt;a href=&quot;pegs&quot;&gt;pegs&lt;/a&gt; for PEG support. This module is available for the &lt;a href=&quot;backends#the-javascript-target&quot;&gt;JavaScript target&lt;/a&gt;.</source>
          <target state="translated">该模块包含各种字符串实用程序例程。有关正则表达式的支持，请参见模块&lt;a href=&quot;re&quot;&gt;re&lt;/a&gt;。有关PEG的支持，请参见模块&lt;a href=&quot;pegs&quot;&gt;钉&lt;/a&gt;。该模块可用于&lt;a href=&quot;backends#the-javascript-target&quot;&gt;JavaScript目标&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="47c439c96c86563186d79ec7720605588cc9ed86" translate="yes" xml:space="preserve">
          <source>This module defines compile-time reflection procs for working with types</source>
          <target state="translated">本模块定义了编译时的反射程序,用于处理类型</target>
        </trans-unit>
        <trans-unit id="0de4eb1c72ff111a775ba8d7bcc00cdb24085f9e" translate="yes" xml:space="preserve">
          <source>This module implements URI parsing as specified by RFC 3986.</source>
          <target state="translated">该模块实现了RFC 3986所规定的URI解析。</target>
        </trans-unit>
        <trans-unit id="27f7329a9231fa9eb3dabedee0d7ec09c071c36c" translate="yes" xml:space="preserve">
          <source>This module implements XML DOM Level 2 Core specification (&lt;a href=&quot;http://www.w3.org/TR/2000/REC-DOM-Level-2-Core-20001113/core.html&quot;&gt;http://www.w3.org/TR/2000/REC-DOM-Level-2-Core-20001113/core.html&lt;/a&gt;)</source>
          <target state="translated">该模块实现了XML DOM 2级核心规范（&lt;a href=&quot;http://www.w3.org/TR/2000/REC-DOM-Level-2-Core-20001113/core.html&quot;&gt;http://www.w3.org/TR/2000/REC-DOM-Level-2-Core-20001113/core.html&lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="1270c3451976ca2c6dbe064b63a8c754c870a12f" translate="yes" xml:space="preserve">
          <source>This module implements a &lt;span id=&quot;crit-bit-tree_1&quot;&gt;crit bit tree&lt;/span&gt; which is an efficient container for a sorted set of strings, or for a sorted mapping of strings. Based on the excellent paper by Adam Langley. (A crit bit tree is a form of &lt;span id=&quot;radix-tree_1&quot;&gt;radix tree&lt;/span&gt; or &lt;span id=&quot;patricia-trie_1&quot;&gt;patricia trie&lt;/span&gt;.)</source>
          <target state="translated">该模块实现了关键&lt;span id=&quot;crit-bit-tree_1&quot;&gt;位树&lt;/span&gt;，它是排序字符串集或字符串映射映射的有效容器。基于亚当&amp;middot;兰利的出色论文。（暴击树是&lt;span id=&quot;radix-tree_1&quot;&gt;基数树&lt;/span&gt;或&lt;span id=&quot;patricia-trie_1&quot;&gt;patricia trie的&lt;/span&gt;一种形式。）</target>
        </trans-unit>
        <trans-unit id="d33fc50e3ca1debee0d3e81969fe922a6c7f125b" translate="yes" xml:space="preserve">
          <source>This module implements a &lt;span id=&quot;restructuredtext_1&quot;&gt;reStructuredText&lt;/span&gt; parser. A large subset is implemented. Some features of the &lt;span id=&quot;markdown_1&quot;&gt;markdown&lt;/span&gt; wiki syntax are also supported.</source>
          <target state="translated">该模块实现了&lt;span id=&quot;restructuredtext_1&quot;&gt;reStructuredText&lt;/span&gt;解析器。实现了很大的子集。还支持&lt;span id=&quot;markdown_1&quot;&gt;markdown&lt;/span&gt; Wiki语法的某些功能。</target>
        </trans-unit>
        <trans-unit id="6977f3d46bd112fbaa438f57a03c83e720c94436" translate="yes" xml:space="preserve">
          <source>This module implements a base object of a lexer with efficient buffer handling. Only at line endings checks are necessary if the buffer needs refilling.</source>
          <target state="translated">这个模块实现了一个具有高效缓冲区处理能力的词典基础对象。只有在行结束时才需要检查是否需要重新填充缓冲区。</target>
        </trans-unit>
        <trans-unit id="df7211c34a2ecd3f4fc0d583c3ad6e78e895ee92" translate="yes" xml:space="preserve">
          <source>This module implements a base64 encoder and decoder.</source>
          <target state="translated">该模块实现了一个base64编码器和解码器。</target>
        </trans-unit>
        <trans-unit id="6081002e18d54466e7c5566ce284e757eba696e6" translate="yes" xml:space="preserve">
          <source>This module implements a generator of HTML/Latex from &lt;span id=&quot;restructuredtext_1&quot;&gt;reStructuredText&lt;/span&gt; (see &lt;a href=&quot;http://docutils.sourceforge.net/rst.html&quot;&gt;http://docutils.sourceforge.net/rst.html&lt;/a&gt; for information on this markup syntax) and is used by the compiler's &lt;a href=&quot;docgen&quot;&gt;docgen tools&lt;/a&gt;.</source>
          <target state="translated">该模块从&lt;span id=&quot;restructuredtext_1&quot;&gt;reStructuredText&lt;/span&gt;实现HTML / Latex的生成器（有关此标记语法的信息，请参见&lt;a href=&quot;http://docutils.sourceforge.net/rst.html&quot;&gt;http://docutils.sourceforge.net/rst.html&lt;/a&gt;），并且由编译器的&lt;a href=&quot;docgen&quot;&gt;docgen工具使用&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2e24ad7c182e7005c7758742478f3329d0f6132c" translate="yes" xml:space="preserve">
          <source>This module implements a helper for a thread pool to determine whether creating a thread is a good idea.</source>
          <target state="translated">该模块实现了一个线程池的帮助器,用于判断创建线程是否是一个好主意。</target>
        </trans-unit>
        <trans-unit id="454ce041e8ff19cc3f47caab96d62276cdca14fe" translate="yes" xml:space="preserve">
          <source>This module implements a high performance asynchronous HTTP server.</source>
          <target state="translated">该模块实现了一个高性能的异步HTTP服务器。</target>
        </trans-unit>
        <trans-unit id="55bdd10c5a5f89322ba8a15e1873d103379babdc" translate="yes" xml:space="preserve">
          <source>This module implements a high-level asynchronous sockets API based on the asynchronous dispatcher defined in the &lt;code&gt;asyncdispatch&lt;/code&gt; module.</source>
          <target state="translated">该模块基于 &lt;code&gt;asyncdispatch&lt;/code&gt; 模块中定义的异步调度程序实现高级异步套接字API 。</target>
        </trans-unit>
        <trans-unit id="141c50103e76c15b79b0d58835babe4f607c974d" translate="yes" xml:space="preserve">
          <source>This module implements a high-level cross-platform sockets interface. The procedures implemented in this module are primarily for blocking sockets. For asynchronous non-blocking sockets use the &lt;code&gt;asyncnet&lt;/code&gt; module together with the &lt;code&gt;asyncdispatch&lt;/code&gt; module.</source>
          <target state="translated">该模块实现了高级的跨平台套接字接口。此模块中实现的过程主要用于阻止套接字。对于异步无阻塞套接字，请使用 &lt;code&gt;asyncnet&lt;/code&gt; 模块和 &lt;code&gt;asyncdispatch&lt;/code&gt; 模块。</target>
        </trans-unit>
        <trans-unit id="db9ba48b68fd354aaa5fc20475e579aac2d2654d" translate="yes" xml:space="preserve">
          <source>This module implements a json parser. It is used and exported by the &lt;code&gt;json&lt;/code&gt; standard library module, but can also be used in its own right.</source>
          <target state="translated">此模块实现json解析器。它由 &lt;code&gt;json&lt;/code&gt; 标准库模块使用和导出，但也可以单独使用。</target>
        </trans-unit>
        <trans-unit id="b1fdd4da540e62b9188383b60a46eeb260182e77" translate="yes" xml:space="preserve">
          <source>This module implements a low-level cross-platform sockets interface. Look at the &lt;code&gt;net&lt;/code&gt; module for the higher-level version.</source>
          <target state="translated">该模块实现了一个低级别的跨平台套接字接口。在 &lt;code&gt;net&lt;/code&gt; 模块中查找更高版本的模块。</target>
        </trans-unit>
        <trans-unit id="ffb0db7a5f8cb3e13d15cfbadb31dc0a731e0b20" translate="yes" xml:space="preserve">
          <source>This module implements a mimetypes database</source>
          <target state="translated">该模块实现了一个mimetypes数据库。</target>
        </trans-unit>
        <trans-unit id="369970703d77f45ce74f0890d99dc3ad540cefb1" translate="yes" xml:space="preserve">
          <source>This module implements a series of low level methods for bit manipulation. By default, this module use compiler intrinsics to improve performance on supported compilers: &lt;code&gt;GCC&lt;/code&gt;, &lt;code&gt;LLVM_GCC&lt;/code&gt;, &lt;code&gt;CLANG&lt;/code&gt;, &lt;code&gt;VCC&lt;/code&gt;, &lt;code&gt;ICC&lt;/code&gt;.</source>
          <target state="translated">该模块实现了一系列用于位操作的低级方法。默认情况下，此模块使用编译器内部函数来提高支持的编译器的性能： &lt;code&gt;GCC&lt;/code&gt; ， &lt;code&gt;LLVM_GCC&lt;/code&gt; ， &lt;code&gt;CLANG&lt;/code&gt; ， &lt;code&gt;VCC&lt;/code&gt; ， &lt;code&gt;ICC&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6a72068a61f0ac219b08c124ba6a885d3d706a6f" translate="yes" xml:space="preserve">
          <source>This module implements a simple &lt;span id=&quot;xml_1&quot;&gt;XML&lt;/span&gt; and &lt;span id=&quot;html_1&quot;&gt;HTML&lt;/span&gt; code generator. Each commonly used HTML tag has a corresponding macro that generates a string with its HTML representation.</source>
          <target state="translated">该模块实现了一个简单的&lt;span id=&quot;xml_1&quot;&gt;XML&lt;/span&gt;和&lt;span id=&quot;html_1&quot;&gt;HTML&lt;/span&gt;代码生成器。每个常用的HTML标记都有一个相应的宏，该宏生成带有HTML表示形式的字符串。</target>
        </trans-unit>
        <trans-unit id="85bfb7ff9d532c8dadfbbeaebbf969dd68bafa42" translate="yes" xml:space="preserve">
          <source>This module implements a simple HTTP client that can be used to retrieve webpages and other data.</source>
          <target state="translated">该模块实现了一个简单的HTTP客户端,可以用来检索网页和其他数据。</target>
        </trans-unit>
        <trans-unit id="042f483a9df711dab36503622086bf978deae7dc" translate="yes" xml:space="preserve">
          <source>This module implements a simple high performance &lt;span id=&quot;csv_1&quot;&gt;CSV&lt;/span&gt; (&lt;span id=&quot;comma-separated-value_1&quot;&gt;comma separated value&lt;/span&gt;) parser.</source>
          <target state="translated">该模块实现了一个简单的高性能&lt;span id=&quot;csv_1&quot;&gt;CSV&lt;/span&gt;（&lt;span id=&quot;comma-separated-value_1&quot;&gt;逗号分隔值&lt;/span&gt;）解析器。</target>
        </trans-unit>
        <trans-unit id="79501d3f5ff57c410bf937ebfdaefd4be7b9f7d2" translate="yes" xml:space="preserve">
          <source>This module implements a simple high performance &lt;span id=&quot;json_1&quot;&gt;JSON&lt;/span&gt; parser. JSON (JavaScript Object Notation) is a lightweight data-interchange format that is easy for humans to read and write (unlike XML). It is easy for machines to parse and generate. JSON is based on a subset of the JavaScript Programming Language, Standard ECMA-262 3rd Edition - December 1999.</source>
          <target state="translated">该模块实现了一个简单的高性能&lt;span id=&quot;json_1&quot;&gt;JSON&lt;/span&gt;解析器。 JSON（JavaScript对象表示法）是一种轻量级的数据交换格式，人类易于读写（与XML不同）。机器很容易解析和生成。 JSON基于JavaScript编程语言（标准ECMA-262第三版-1999年12月）的子集。</target>
        </trans-unit>
        <trans-unit id="06a978a90f444ab2e371ab0e33c92d28de7bff58" translate="yes" xml:space="preserve">
          <source>This module implements a simple high performance &lt;span id=&quot;xml_1&quot;&gt;XML&lt;/span&gt; / &lt;span id=&quot;html_1&quot;&gt;HTML&lt;/span&gt; parser. The only encoding that is supported is UTF-8. The parser has been designed to be somewhat error correcting, so that even most &quot;wild HTML&quot; found on the web can be parsed with it. &lt;strong&gt;Note:&lt;/strong&gt; This parser does not check that each &lt;code&gt;&amp;lt;tag&amp;gt;&lt;/code&gt; has a corresponding &lt;code&gt;&amp;lt;/tag&amp;gt;&lt;/code&gt;! These checks have do be implemented by the client code for various reasons:</source>
          <target state="translated">该模块实现了一个简单的高性能&lt;span id=&quot;xml_1&quot;&gt;XML&lt;/span&gt; / &lt;span id=&quot;html_1&quot;&gt;HTML&lt;/span&gt;解析器。支持的唯一编码是UTF-8。该解析器经过精心设计，可以进行一些纠错，因此即使在网络上找到的大多数&amp;ldquo;野生HTML&amp;rdquo;也可以使用它进行解析。&lt;strong&gt;注意：&lt;/strong&gt;该解析器不会检查每个 &lt;code&gt;&amp;lt;tag&amp;gt;&lt;/code&gt; 是否具有对应的 &lt;code&gt;&amp;lt;/tag&amp;gt;&lt;/code&gt; ！出于各种原因，客户端代码确实实现了这些检查：</target>
        </trans-unit>
        <trans-unit id="48947ec421a5467d0d646e322ab81e8c9a02a691" translate="yes" xml:space="preserve">
          <source>This module implements a simple logger. It has been designed to be as simple as possible to avoid bloat, if this library does not fulfill your needs, write your own.</source>
          <target state="translated">这个模块实现了一个简单的记录器。它的设计尽量简单以避免臃肿,如果这个库不能满足你的需求,可以自己写。</target>
        </trans-unit>
        <trans-unit id="3dadb028527d802791d6f87341aff532946953c1" translate="yes" xml:space="preserve">
          <source>This module implements a simple proc for opening URLs with the user's default browser.</source>
          <target state="translated">该模块实现了一个简单的程序,用于用用户的默认浏览器打开URL。</target>
        </trans-unit>
        <trans-unit id="7fb049b95846bb771385f79aa14ac44a91216509" translate="yes" xml:space="preserve">
          <source>This module implements a small wrapper for some needed Win API procedures, so that the Nim compiler does not depend on the huge Windows module.</source>
          <target state="translated">这个模块为一些需要的Win API过程实现了一个小的封装器,这样Nim编译器就不需要依赖庞大的Windows模块了。</target>
        </trans-unit>
        <trans-unit id="5ac84b13286763d5a846ef3e91168372a188a0b8" translate="yes" xml:space="preserve">
          <source>This module implements an AST for the &lt;span id=&quot;restructuredtext_1&quot;&gt;reStructuredText&lt;/span&gt; parser.</source>
          <target state="translated">此模块为&lt;span id=&quot;restructuredtext_1&quot;&gt;reStructuredText&lt;/span&gt;解析器实现AST 。</target>
        </trans-unit>
        <trans-unit id="be080849cfa6c4b49c9b095ad65b6fcaae6e195d" translate="yes" xml:space="preserve">
          <source>This module implements an advanced facility for executing OS processes and process communication.</source>
          <target state="translated">该模块实现了执行OS进程和进程通信的高级设施。</target>
        </trans-unit>
        <trans-unit id="4019f34ee73cf2afc6617ad82d4cc99b8a1651c5" translate="yes" xml:space="preserve">
          <source>This module implements an asynchronous FTP client. It allows you to connect to an FTP server and perform operations on it such as for example:</source>
          <target state="translated">该模块实现了一个异步FTP客户端。它允许你连接到一个FTP服务器,并对其进行操作,例如。</target>
        </trans-unit>
        <trans-unit id="13879d8d10926994138f177a507809351445a9d4" translate="yes" xml:space="preserve">
          <source>This module implements an asynchronous event loop together with asynchronous sockets which use this event loop. It is akin to Python's asyncore module. Many modules that use sockets have an implementation for this module, those modules should all have a &lt;code&gt;register&lt;/code&gt; function which you should use to add the desired objects to a dispatcher which you created so that you can receive the events associated with that module's object.</source>
          <target state="translated">此模块与使用此事件循环的异步套接字一起实现异步事件循环。它类似于Python的asyncore模块。许多使用套接字的模块都有该模块的实现，这些模块都应具有 &lt;code&gt;register&lt;/code&gt; 功能，您应使用该功能将所需的对象添加到创建的调度程序中，以便可以接收与该模块的对象关联的事件。</target>
        </trans-unit>
        <trans-unit id="631695dd25ee11fd41bde8946a743e509c7a762f" translate="yes" xml:space="preserve">
          <source>This module implements an interface to Nim's &lt;span id=&quot;runtime-type-information_1&quot;&gt;runtime type information&lt;/span&gt; (&lt;span id=&quot;rtti_1&quot;&gt;RTTI&lt;/span&gt;). Note that even though &lt;code&gt;Any&lt;/code&gt; and its operations hide the nasty low level details from its clients, it remains inherently unsafe!</source>
          <target state="translated">该模块实现了Nim的&lt;span id=&quot;runtime-type-information_1&quot;&gt;运行时类型信息&lt;/span&gt;（&lt;span id=&quot;rtti_1&quot;&gt;RTTI&lt;/span&gt;）的接口。请注意，即使 &lt;code&gt;Any&lt;/code&gt; 及其操作向其客户隐藏了令人讨厌的低级详细信息，但它本质上仍然不安全！</target>
        </trans-unit>
        <trans-unit id="743043f366d434da8a30113b7bbb02a151e1774b" translate="yes" xml:space="preserve">
          <source>This module implements asynchronous IO. This includes a dispatcher, a &lt;code&gt;Future&lt;/code&gt; type implementation, and an &lt;code&gt;async&lt;/code&gt; macro which allows asynchronous code to be written in a synchronous style with the &lt;code&gt;await&lt;/code&gt; keyword.</source>
          <target state="translated">该模块实现异步IO。这包括一个调度程序，一个 &lt;code&gt;Future&lt;/code&gt; 类型的实现以及一个 &lt;code&gt;async&lt;/code&gt; 宏，该宏允许使用 &lt;code&gt;await&lt;/code&gt; 关键字以同步方式编写异步代码。</target>
        </trans-unit>
        <trans-unit id="ff0fc0b254406eef01f02b40f3655696591bd82c" translate="yes" xml:space="preserve">
          <source>This module implements asynchronous file reading and writing.</source>
          <target state="translated">该模块实现了异步文件读写。</target>
        </trans-unit>
        <trans-unit id="be0a15236b06fa556c56498d41940c7197453f73" translate="yes" xml:space="preserve">
          <source>This module implements boilerplate to make unit testing easy.</source>
          <target state="translated">该模块实现了锅炉模板,使单元测试变得简单。</target>
        </trans-unit>
        <trans-unit id="5bb52bf0d87731597af09d97960c22d019bf58d4" translate="yes" xml:space="preserve">
          <source>This module implements color handling for Nim. It is used by the &lt;code&gt;graphics&lt;/code&gt; module.</source>
          <target state="translated">此模块为Nim实现颜色处理。 &lt;code&gt;graphics&lt;/code&gt; 模块使用它。</target>
        </trans-unit>
        <trans-unit id="7729efb631e2eb7bcfa9fd3c15327853bf181948" translate="yes" xml:space="preserve">
          <source>This module implements complex numbers.</source>
          <target state="translated">该模块实现了复数。</target>
        </trans-unit>
        <trans-unit id="42fb167dafb36722d30f92f4593ecfc130a3dae2" translate="yes" xml:space="preserve">
          <source>This module implements efficient computations of hash values for diverse Nim types. All the procs are based on these two building blocks:</source>
          <target state="translated">这个模块实现了对不同Nim类型的哈希值的高效计算。所有的程序都是基于这两个构件。</target>
        </trans-unit>
        <trans-unit id="94a7c29bf4d442270eb47c16d094dbac2bb71a71" translate="yes" xml:space="preserve">
          <source>This module implements helper procs for CGI applications. Example:</source>
          <target state="translated">该模块实现了CGI应用程序的辅助程序。例子:本模块实现了CGI应用程序的辅助程序。</target>
        </trans-unit>
        <trans-unit id="06e4f877dc2f02ff6d7623b1d21e1442d6e6e0aa" translate="yes" xml:space="preserve">
          <source>This module implements helper procs for SCGI applications. Example:</source>
          <target state="translated">该模块实现了SCGI应用程序的帮助程序。例子:</target>
        </trans-unit>
        <trans-unit id="00f7e73405ca98ef55459bd8cb137c930c54ce67" translate="yes" xml:space="preserve">
          <source>This module implements helper procs for parsing Cookies.</source>
          <target state="translated">该模块实现了解析Cookies的辅助程序。</target>
        </trans-unit>
        <trans-unit id="5aa51e0bbdd73802dae08d36a67835190e007e6d" translate="yes" xml:space="preserve">
          <source>This module implements nice syntactic sugar based on Nim's macro system.</source>
          <target state="translated">这个模块基于Nim的宏系统实现了不错的语法糖。</target>
        </trans-unit>
        <trans-unit id="605fb43c6c6ebd7d6234f48fb476d48d8bab0b46" translate="yes" xml:space="preserve">
          <source>This module implements operations for the built-in &lt;span id=&quot;seq_1&quot;&gt;seq&lt;/span&gt; type which were inspired by functional programming languages.</source>
          <target state="translated">此模块实现了受功能编程语言启发的内置&lt;span id=&quot;seq_1&quot;&gt;seq&lt;/span&gt;类型的操作。</target>
        </trans-unit>
        <trans-unit id="03602f44dc99d2a2f1feb228793b9d5dc7bd7cfd" translate="yes" xml:space="preserve">
          <source>This module implements portable sockets, it supports a mix of different types of sockets. Sockets are buffered by default meaning that data will be received in &lt;code&gt;BufferSize&lt;/code&gt; (4000) sized chunks, buffering behaviour can be disabled by setting the &lt;code&gt;buffered&lt;/code&gt; parameter when calling the &lt;code&gt;socket&lt;/code&gt; function to &lt;em&gt;false&lt;/em&gt;. Be aware that some functions may not yet support buffered sockets (mainly the recvFrom function).</source>
          <target state="translated">该模块实现了便携式插座，它支持多种不同类型的插座。默认情况下，套接字是缓冲的，这意味着将以 &lt;code&gt;BufferSize&lt;/code&gt; （4000）大小的块接收数据，可以通过在将 &lt;code&gt;socket&lt;/code&gt; 函数设置为&lt;em&gt;false&lt;/em&gt;时设置 &lt;code&gt;buffered&lt;/code&gt; 参数来禁用缓冲行为。请注意，某些功能可能尚不支持缓冲套接字（主要是recvFrom函数）。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1e03448c70f64476d8a1af87251f0850a190b56c" translate="yes" xml:space="preserve">
          <source>This module implements procs to determine the number of CPUs / cores.</source>
          <target state="translated">该模块实现了确定CPU/核数的程序。</target>
        </trans-unit>
        <trans-unit id="4b020312c18d7f1e3e79c3c6ff8a468feda67a72" translate="yes" xml:space="preserve">
          <source>This module implements rational numbers, consisting of a numerator &lt;em&gt;num&lt;/em&gt; and a denominator &lt;em&gt;den&lt;/em&gt;, both of type int. The denominator can not be 0.</source>
          <target state="translated">此模块实现有理数，它们由分子&lt;em&gt;num&lt;/em&gt;和分母&lt;em&gt;den组成&lt;/em&gt;，均为整数类型。分母不能为0。</target>
        </trans-unit>
        <trans-unit id="88fdbdda66a11d9e4dcd5f67ececbd1313751a08" translate="yes" xml:space="preserve">
          <source>This module implements some common generic algorithms.</source>
          <target state="translated">本模块实现了一些常见的通用算法。</target>
        </trans-unit>
        <trans-unit id="5033575ad43160cfe00aa6032cd8e72c2229f7f9" translate="yes" xml:space="preserve">
          <source>This module implements the SMTP client protocol as specified by RFC 5321, this can be used to send mail to any SMTP Server.</source>
          <target state="translated">该模块实现了RFC 5321指定的SMTP客户端协议,可用于向任何SMTP服务器发送邮件。</target>
        </trans-unit>
        <trans-unit id="0a6a93e5b19faa7bc126c3e2fc94d788bde65745" translate="yes" xml:space="preserve">
          <source>This module implements the ability to access symbols from shared libraries. On POSIX this uses the &lt;code&gt;dlsym&lt;/code&gt; mechanism, on Windows &lt;code&gt;LoadLibrary&lt;/code&gt;.</source>
          <target state="translated">该模块实现了从共享库访问符号的功能。在POSIX上，此方法在Windows &lt;code&gt;LoadLibrary&lt;/code&gt; 上使用 &lt;code&gt;dlsym&lt;/code&gt; 机制。</target>
        </trans-unit>
        <trans-unit id="a3873bd4d455f4aaaae3cbab2055aa96d93f86ba" translate="yes" xml:space="preserve">
          <source>This module implements the basics for Linux distribution (&quot;distro&quot;) detection and the OS's native package manager. Its primary purpose is to produce output for Nimble packages like:</source>
          <target state="translated">这个模块实现了Linux发行版(&quot;distro&quot;)检测和操作系统本地包管理器的基本功能。它的主要目的是为Nimble包产生输出,如:。</target>
        </trans-unit>
        <trans-unit id="15b881f434ad53307745d9873f33cc83cdf48e46" translate="yes" xml:space="preserve">
          <source>This module implements types and macros for writing asynchronous code for the JS backend. It provides tools for interaction with JavaScript async API-s and libraries, writing async procedures in Nim and converting callback-based code to promises.</source>
          <target state="translated">该模块实现了为JS后端编写异步代码的类型和宏,它提供了与JavaScript异步API和库交互的工具,在Nim中编写异步过程,并将基于回调的代码转换为承诺。它提供了与JavaScript异步API和库交互的工具,在Nim中编写异步过程,并将基于回调的代码转换为承诺。</target>
        </trans-unit>
        <trans-unit id="96a223a86302396be5588794d00dcc5a992fb05a" translate="yes" xml:space="preserve">
          <source>This module implements types which encapsulate an optional value.</source>
          <target state="translated">本模块实现了封装可选值的类型。</target>
        </trans-unit>
        <trans-unit id="8b05223d9ca6772d764f5fcaadb7295f47ed88d6" translate="yes" xml:space="preserve">
          <source>This module is a sample.</source>
          <target state="translated">这个模块是一个样本。</target>
        </trans-unit>
        <trans-unit id="a2a203baf067681d5e0468d7220606f23e9f491a" translate="yes" xml:space="preserve">
          <source>This module is also compatible with other backends: &lt;code&gt;Javascript&lt;/code&gt;, &lt;code&gt;Nimscript&lt;/code&gt; as well as the &lt;code&gt;compiletime VM&lt;/code&gt;.</source>
          <target state="translated">该模块还与其他后端兼容： &lt;code&gt;Javascript&lt;/code&gt; ， &lt;code&gt;Nimscript&lt;/code&gt; 以及 &lt;code&gt;compiletime VM&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c5689b667695647b8ab8ef22840d0cdf1b5bb67f" translate="yes" xml:space="preserve">
          <source>This module is implemented by providing a wrapper around the &lt;a href=&quot;http://www.pcre.org&quot;&gt;PCRE (Perl-Compatible Regular Expressions)&lt;/a&gt; C library. This means that your application will depend on the PCRE library's licence when using this module, which should not be a problem though. PCRE's licence follows:</source>
          <target state="translated">通过围绕&lt;a href=&quot;http://www.pcre.org&quot;&gt;PCRE（与Perl兼容的正则表达式）&lt;/a&gt; C库提供包装器来实现此模块。这意味着您的应用程序在使用此模块时将取决于PCRE库的许可证，但这应该不是问题。PCRE的许可证如下：</target>
        </trans-unit>
        <trans-unit id="cda1d94b3b5a9dcfb70f16a91a3ec170b750b323" translate="yes" xml:space="preserve">
          <source>This module offers implementations of common binary operations like &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;/&lt;/code&gt; and comparison operations, which work for mixed float/int operands. All operations convert the integer operand into the type of the float operand. For numerical expressions, the return type is always the type of the float involved in the expresssion, i.e., there is no auto conversion from float32 to float64.</source>
          <target state="translated">该模块提供了常见的二进制操作（例如 &lt;code&gt;+&lt;/code&gt; ， &lt;code&gt;-&lt;/code&gt; ， &lt;code&gt;*&lt;/code&gt; 和 &lt;code&gt;/&lt;/code&gt; )的实现，这些操作适用于混合的float / int操作数。所有操作都将整数操作数转换为浮点操作数的类型。对于数字表达式，返回类型始终是表达式中涉及的float的类型，即，没有从float32到float64的自动转换。</target>
        </trans-unit>
        <trans-unit id="7396f239f24da0a4e4690ab1044ff64d650f1306" translate="yes" xml:space="preserve">
          <source>This module parses a XML Document into a XML DOM Document representation.</source>
          <target state="translated">该模块将一个XML文档解析成一个XML DOM文档表示。</target>
        </trans-unit>
        <trans-unit id="a9bcdabb8e24bc9cc089f0f13411ad03a03519bc" translate="yes" xml:space="preserve">
          <source>This module parses an HTML document and creates its XML tree representation. It is supposed to handle the &lt;em&gt;wild&lt;/em&gt; HTML the real world uses.</source>
          <target state="translated">该模块解析HTML文档并创建其XML树表示形式。它应该处理现实世界使用的&lt;em&gt;狂野&lt;/em&gt; HTML。</target>
        </trans-unit>
        <trans-unit id="6cd96ee218d8bf4a40ad0320da8cac9d72214020" translate="yes" xml:space="preserve">
          <source>This module parses an XML document and creates its XML tree representation.</source>
          <target state="translated">该模块解析XML文档并创建其XML树表示。</target>
        </trans-unit>
        <trans-unit id="9a07c876b6cd8245c5dfacca935fec67d4db93ff" translate="yes" xml:space="preserve">
          <source>This module provides a stream interface and two implementations thereof: the &lt;em&gt;FileStream&lt;/em&gt; and the &lt;em&gt;StringStream&lt;/em&gt; which implement the stream interface for Nim file objects (&lt;em&gt;File&lt;/em&gt;) and strings. Other modules may provide other implementations for this standard stream interface.</source>
          <target state="translated">该模块提供了一个流接口及其两种实现：&lt;em&gt;FileStream&lt;/em&gt;和&lt;em&gt;StringStream&lt;/em&gt;，它们实现了Nim文件对象（&lt;em&gt;File&lt;/em&gt;）和字符串的流接口。其他模块可以为此标准流接口提供其他实现。</target>
        </trans-unit>
        <trans-unit id="4ab8f9a52d2829796af73473cde494f332d9e364" translate="yes" xml:space="preserve">
          <source>This module provides an easy to use sockets-style nim interface to the OpenSSL library.</source>
          <target state="translated">该模块为OpenSSL库提供了一个易于使用的套接字风格的nim接口。</target>
        </trans-unit>
        <trans-unit id="49dbd9ba77d32ac31376544311a3b10bed584209" translate="yes" xml:space="preserve">
          <source>This module provides both a synchronous and asynchronous implementation. The asynchronous implementation requires you to use the &lt;code&gt;asyncFTPClient&lt;/code&gt; function. You are then required to register the &lt;code&gt;AsyncFTPClient&lt;/code&gt; with a asyncio dispatcher using the &lt;code&gt;register&lt;/code&gt; function. Take a look at the asyncio module documentation for more information.</source>
          <target state="translated">该模块提供同步和异步实现。异步实现要求您使用 &lt;code&gt;asyncFTPClient&lt;/code&gt; 函数。然后，您需要注册 &lt;code&gt;AsyncFTPClient&lt;/code&gt; 使用的一个ASYNCIO调度 &lt;code&gt;register&lt;/code&gt; 功能。查看asyncio模块文档以获取更多信息。</target>
        </trans-unit>
        <trans-unit id="ce590e4e5a122965a43db23fbb2cb01e20c16510" translate="yes" xml:space="preserve">
          <source>This module provides support for &lt;span id=&quot;memory-mapped-files_1&quot;&gt;memory mapped files&lt;/span&gt; (Posix's &lt;span id=&quot;mmap_1&quot;&gt;mmap&lt;/span&gt;) on the different operating systems.</source>
          <target state="translated">该模块支持不同操作系统上的&lt;span id=&quot;memory-mapped-files_1&quot;&gt;内存映射文件&lt;/span&gt;（Posix的&lt;span id=&quot;mmap_1&quot;&gt;mmap&lt;/span&gt;）。</target>
        </trans-unit>
        <trans-unit id="65c4c619ae2b38e38065fa4fe9a46d6bc185ed6a" translate="yes" xml:space="preserve">
          <source>This module provides support to handle the Unicode UTF-8 encoding.</source>
          <target state="translated">该模块提供了处理Unicode UTF-8编码的支持。</target>
        </trans-unit>
        <trans-unit id="f60f9e4146057e2aadde33d2726a83b70d00ccbc" translate="yes" xml:space="preserve">
          <source>This module provides the standard Nim command line parser. It supports one convenience iterator over all command line options and some lower-level features.</source>
          <target state="translated">该模块提供了标准的Nim命令行解析器。它支持一个方便的迭代器,覆盖所有命令行选项和一些低级功能。</target>
        </trans-unit>
        <trans-unit id="be630a10c2306e1da8b699aa549bd1507ce73a7f" translate="yes" xml:space="preserve">
          <source>This module supports helper routines for working with &lt;code&gt;cstring&lt;/code&gt; without having to convert &lt;code&gt;cstring&lt;/code&gt; to &lt;code&gt;string&lt;/code&gt; in order to save allocations.</source>
          <target state="translated">该模块支持使用 &lt;code&gt;cstring&lt;/code&gt; 的帮助程序例程，而不必将 &lt;code&gt;cstring&lt;/code&gt; 转换为 &lt;code&gt;string&lt;/code&gt; 以节省分配。</target>
        </trans-unit>
        <trans-unit id="5a7ff45a67a6ab46e7d1fb35b3306305d6ba07fa" translate="yes" xml:space="preserve">
          <source>This module wraps core JavaScript functions.</source>
          <target state="translated">该模块封装了JavaScript的核心功能。</target>
        </trans-unit>
        <trans-unit id="5b840bfc815d3caad906fc572e9454af313da4d0" translate="yes" xml:space="preserve">
          <source>This modules registers a signal handler that turns access violations / segfaults into a &lt;code&gt;NilAccessError&lt;/code&gt; exception. To be able to catch a NilAccessError all you have to do is to import this module.</source>
          <target state="translated">此模块注册一个信号处理程序，该处理程序将访问冲突/ segfaults转换为 &lt;code&gt;NilAccessError&lt;/code&gt; 异常。为了捕获NilAccessError，您要做的就是导入此模块。</target>
        </trans-unit>
        <trans-unit id="6390ea355bcccac1df3928830a46c0fa9200368c" translate="yes" xml:space="preserve">
          <source>This must be called on an unconnected socket; an SSL session will be started when the socket is connected.</source>
          <target state="translated">这必须在未连接的套接字上调用;当套接字被连接时,SSL会话将被启动。</target>
        </trans-unit>
        <trans-unit id="e08443e3f06cf9773785c99d4ad98608f4e9eebf" translate="yes" xml:space="preserve">
          <source>This operator computes the difference of two sets.</source>
          <target state="translated">这个运算符计算两个集合的差。</target>
        </trans-unit>
        <trans-unit id="f79ed7bc0326a97f82d04a96b028c6113002f150" translate="yes" xml:space="preserve">
          <source>This operator computes the intersection of two sets.</source>
          <target state="translated">这个运算符计算两个集合的交点。</target>
        </trans-unit>
        <trans-unit id="9a4b0639403e85faa9616f997f6d194f55eeab89" translate="yes" xml:space="preserve">
          <source>This operator computes the union of two sets.</source>
          <target state="translated">这个运算符计算两个集合的结合。</target>
        </trans-unit>
        <trans-unit id="b046c8a4096963070b190a5e641fbd439e8358a7" translate="yes" xml:space="preserve">
          <source>This operator is the assignment operator. Note that in the contexts &lt;code&gt;result = expr&lt;/code&gt;, &lt;code&gt;parameter = defaultValue&lt;/code&gt; or for parameter passing no assignment is performed. For a type &lt;code&gt;T&lt;/code&gt; that has an overloaded assignment operator &lt;code&gt;var v = T()&lt;/code&gt; is rewritten to &lt;code&gt;var v: T; v = T()&lt;/code&gt;; in other words &lt;code&gt;var&lt;/code&gt; and &lt;code&gt;let&lt;/code&gt; contexts do count as assignments.</source>
          <target state="translated">该运算符是赋值运算符。请注意，在 &lt;code&gt;result = expr&lt;/code&gt; ， &lt;code&gt;parameter = defaultValue&lt;/code&gt; 的上下文中，或者对于参数传递，不执行任何赋值。对于具有重载赋值运算符的类型 &lt;code&gt;T&lt;/code&gt; ，将 &lt;code&gt;var v = T()&lt;/code&gt; 重写为 &lt;code&gt;var v: T; v = T()&lt;/code&gt; ; 换句话说， &lt;code&gt;var&lt;/code&gt; 和 &lt;code&gt;let&lt;/code&gt; 上下文确实算作分配。</target>
        </trans-unit>
        <trans-unit id="c815aa40abb9bedda70e19c6d2ad3999d74da028" translate="yes" xml:space="preserve">
          <source>This operator will be matched against assignments to missing fields.</source>
          <target state="translated">该运算符将与缺失字段的赋值相匹配。</target>
        </trans-unit>
        <trans-unit id="877c6b770d02ce2daf96f01b490c8ab96ed58851" translate="yes" xml:space="preserve">
          <source>This operator will be matched against both field accesses and method calls.</source>
          <target state="translated">该操作符将与字段访问和方法调用相匹配。</target>
        </trans-unit>
        <trans-unit id="99c71fe5d49c4e442130e8d4e9b6e7107de926b7" translate="yes" xml:space="preserve">
          <source>This operator will be matched exclusively against method calls. It has higher precedence than the &lt;em&gt;.&lt;/em&gt; operator and this allows one to handle expressions like &lt;em&gt;x.y&lt;/em&gt; and &lt;em&gt;x.y()&lt;/em&gt; differently if one is interfacing with a scripting language for example.</source>
          <target state="translated">该运算符将专门与方法调用匹配。它具有比更高的优先级&lt;em&gt;。&lt;/em&gt;运算符，例如，如果与脚本语言接口，则允许以不同的方式处理&lt;em&gt;xy&lt;/em&gt;和&lt;em&gt;xy（）&lt;/em&gt;等表达式。</target>
        </trans-unit>
        <trans-unit id="c195c31e5829f87707abb98358a691d8131229a7" translate="yes" xml:space="preserve">
          <source>This passes the expression &lt;code&gt;x + y * z - x&lt;/code&gt; to the &lt;code&gt;optM&lt;/code&gt; macro as an &lt;code&gt;nnkArgList&lt;/code&gt; node containing:</source>
          <target state="translated">这会将表达式 &lt;code&gt;x + y * z - x&lt;/code&gt; 作为 &lt;code&gt;nnkArgList&lt;/code&gt; 节点传递给 &lt;code&gt;optM&lt;/code&gt; 宏，该节点包含：</target>
        </trans-unit>
        <trans-unit id="779a96266029c48032a8abc57497d759ae90622e" translate="yes" xml:space="preserve">
          <source>This pragma can also take in an optional warning string to relay to developers.</source>
          <target state="translated">这个pragma也可以接受一个可选的警告字符串来传递给开发者。</target>
        </trans-unit>
        <trans-unit id="b2bac99517eec01add92d42595b9d17d1a79dbd9" translate="yes" xml:space="preserve">
          <source>This proc adds the necessary Content-Length header.</source>
          <target state="translated">本程序添加必要的Content-Length头。</target>
        </trans-unit>
        <trans-unit id="7b6638b54fd693beeb9b92d654723a7cc066942f" translate="yes" xml:space="preserve">
          <source>This proc also handles redirection</source>
          <target state="translated">这个过程也处理重定向</target>
        </trans-unit>
        <trans-unit id="bec96c78d9187ae27072063a2599e2d8041f75b3" translate="yes" xml:space="preserve">
          <source>This proc also handles redirection.</source>
          <target state="translated">这个过程也处理重定向。</target>
        </trans-unit>
        <trans-unit id="3938ad51042cbaba9e98c935176fa62ab2de2077" translate="yes" xml:space="preserve">
          <source>This proc can be used to create tree structures on the fly (sometimes called &lt;span id=&quot;autovivification_1&quot;&gt;autovivification&lt;/span&gt;):</source>
          <target state="translated">此proc可用于动态创建树结构（有时称为&lt;span id=&quot;autovivification_1&quot;&gt;autovivification&lt;/span&gt;）：</target>
        </trans-unit>
        <trans-unit id="350b35231bf552e3848fa0167786f99d3c79a8be" translate="yes" xml:space="preserve">
          <source>This proc is mostly useful for meta programming (eg. &lt;code&gt;assert&lt;/code&gt; template) to retrieve information about the current filename and line number. Example:</source>
          <target state="translated">这个过程对于元编程（例如 &lt;code&gt;assert&lt;/code&gt; 模板）检索有关当前文件名和行号的信息最有用。例：</target>
        </trans-unit>
        <trans-unit id="8bc13541eec5a8625bb4f501795d54288285926d" translate="yes" xml:space="preserve">
          <source>This proc is wrapped by the expandTilde proc for the convenience of processing paths coming from user configuration files.</source>
          <target state="translated">为了方便处理来自用户配置文件的路径,该 proc 被 expandTilde proc 包裹。</target>
        </trans-unit>
        <trans-unit id="333b238bdf3008bb02960b98a410ac4836f3911d" translate="yes" xml:space="preserve">
          <source>This proc sends &lt;code&gt;data&lt;/code&gt; to the specified &lt;code&gt;address&lt;/code&gt;, which may be an IP address or a hostname, if a hostname is specified this function will try each IP of that hostname.</source>
          <target state="translated">此过程将 &lt;code&gt;data&lt;/code&gt; 发送到指定的 &lt;code&gt;address&lt;/code&gt; ，该地址可以是IP地址或主机名，如果指定了主机名，则此功能将尝试该主机名的每个IP。</target>
        </trans-unit>
        <trans-unit id="47eaf268233c731f7c482448d362f14c34db36aa" translate="yes" xml:space="preserve">
          <source>This proc will assert if the node is not of the expected type. The empty string will be returned as a minimum. Any value in the rst will be stripped form leading/trailing whitespace.</source>
          <target state="translated">如果节点不是预期的类型,该 proc 将断言。空字符串将作为最小值返回。rst中的任何值都会被去掉前导/尾部的空白。</target>
        </trans-unit>
        <trans-unit id="626f1119535b21954263807e2c460288c1806626" translate="yes" xml:space="preserve">
          <source>This proc will first scan &lt;em&gt;dir&lt;/em&gt; for index files with the &lt;code&gt;.idx&lt;/code&gt; extension previously created by commands like &lt;code&gt;nim doc|rst2html&lt;/code&gt; which use the &lt;code&gt;--index:on&lt;/code&gt; switch. These index files are the result of calls to &lt;a href=&quot;#setIndexTerm&quot;&gt;setIndexTerm()&lt;/a&gt; and &lt;a href=&quot;#writeIndexFile&quot;&gt;writeIndexFile()&lt;/a&gt;, so they are simple tab separated files.</source>
          <target state="translated">此proc将首先在&lt;em&gt;dir&lt;/em&gt;中扫描带有 &lt;code&gt;.idx&lt;/code&gt; 扩展名的索引文件，该文件先前由使用 &lt;code&gt;--index:on&lt;/code&gt; 开关的 &lt;code&gt;nim doc|rst2html&lt;/code&gt; 类的命令创建。这些索引文件是对&lt;a href=&quot;#setIndexTerm&quot;&gt;setIndexTerm（）&lt;/a&gt;和&lt;a href=&quot;#writeIndexFile&quot;&gt;writeIndexFile（）&lt;/a&gt;的调用的结果，因此它们是用制表符分隔的简单文件。</target>
        </trans-unit>
        <trans-unit id="a4394af6524fbdf2935a5287c6e403358c97c2f3" translate="yes" xml:space="preserve">
          <source>This proc will return true if given two alternative hard-linked or sym-linked paths to the same file or directory.</source>
          <target state="translated">如果给定两个指向同一文件或目录的硬链接或符号链接路径,这个执行程序将返回true。</target>
        </trans-unit>
        <trans-unit id="5ab576674f0fae9f5c2db872b47e1b80cc3065ba" translate="yes" xml:space="preserve">
          <source>This procedure encodes a string.</source>
          <target state="translated">这个过程对一个字符串进行编码。</target>
        </trans-unit>
        <trans-unit id="c324daca0847c9b512385b859ab2363a1841f9c6" translate="yes" xml:space="preserve">
          <source>This procedure encodes an openarray (array or sequence) of either integers or characters.</source>
          <target state="translated">这个过程对整数或字符的openarray(数组或序列)进行编码。</target>
        </trans-unit>
        <trans-unit id="ebba0aeda7a3e7c849c8d97ba20a2191682f9515" translate="yes" xml:space="preserve">
          <source>This procedure is perfect for saving streamed data to a file without wasting memory.</source>
          <target state="translated">这个过程非常适合将流媒体数据保存到文件中而不浪费内存。</target>
        </trans-unit>
        <trans-unit id="d1f961f21ff0a84bd8db8e05ca89330dfa9923ef" translate="yes" xml:space="preserve">
          <source>This procedure is useful for converting &lt;code&gt;Duration&lt;/code&gt; values to strings.</source>
          <target state="translated">此过程对于将 &lt;code&gt;Duration&lt;/code&gt; 值转换为字符串很有用。</target>
        </trans-unit>
        <trans-unit id="520fb6fa62d760ce421de4aaa2f6105b1555063b" translate="yes" xml:space="preserve">
          <source>This procedure is useful for converting &lt;code&gt;TimeInterval&lt;/code&gt; values to strings. E.g. then you need to implement custom interval printing</source>
          <target state="translated">此过程对于将 &lt;code&gt;TimeInterval&lt;/code&gt; 值转换为字符串很有用。例如，您需要实施自定义间隔打印</target>
        </trans-unit>
        <trans-unit id="0479019038d3102021d1669951bf95b837b91563" translate="yes" xml:space="preserve">
          <source>This procedure will &lt;strong&gt;not&lt;/strong&gt; close the client socket.</source>
          <target state="translated">此过程&lt;strong&gt;不会&lt;/strong&gt;关闭客户端套接字。</target>
        </trans-unit>
        <trans-unit id="2c9c22aaa48bc7cddb7839a6f9a879afc83e6b75" translate="yes" xml:space="preserve">
          <source>This procedure will also create a brand new file descriptor for this socket.</source>
          <target state="translated">这个过程还将为这个socket创建一个全新的文件描述符。</target>
        </trans-unit>
        <trans-unit id="1288ff1149ba87d487f19440b9d10966e30531a7" translate="yes" xml:space="preserve">
          <source>This procedure will follow redirects up to a maximum number of redirects specified in &lt;code&gt;client.maxRedirects&lt;/code&gt;.</source>
          <target state="translated">此过程将遵循重定向，直到 &lt;code&gt;client.maxRedirects&lt;/code&gt; 中指定的最大重定向数。</target>
        </trans-unit>
        <trans-unit id="7a5c3737642080f0e83823f3dcd1cc4baeb39760" translate="yes" xml:space="preserve">
          <source>This procedure will immediately return, it will not block until a connection is made. It is up to the caller to make sure the connection has been established by checking (using &lt;code&gt;select&lt;/code&gt;) whether the socket is writeable.</source>
          <target state="translated">该过程将立即返回，直到建立连接后它才会阻塞。调用方可以通过检查（使用 &lt;code&gt;select&lt;/code&gt; ）套接字是否可写来确保已建立连接。</target>
        </trans-unit>
        <trans-unit id="8185dc4f223c6b697125a69fc7c20cfa4abf8f29" translate="yes" xml:space="preserve">
          <source>This procedure will resolve symlinks.</source>
          <target state="translated">这个过程将解析符号链接。</target>
        </trans-unit>
        <trans-unit id="014cae8b1a1962b4f1faa243de196e5e656ee26d" translate="yes" xml:space="preserve">
          <source>This provides higher efficiency than the &lt;code&gt;pretty&lt;/code&gt; procedure as it does &lt;strong&gt;not&lt;/strong&gt; attempt to format the resulting JSON to make it human readable.</source>
          <target state="translated">与 &lt;code&gt;pretty&lt;/code&gt; 过程相比，这提供了更高的效率，因为它&lt;strong&gt;没有&lt;/strong&gt;尝试格式化结果JSON以使其易于阅读。</target>
        </trans-unit>
        <trans-unit id="526a6ce57682bfa6e8b959cd6e81435a72cdfc8d" translate="yes" xml:space="preserve">
          <source>This quickly gets tedious. The implementations are trivial and the compiler should not generate all this code only to optimize it away later - after all &lt;code&gt;+&lt;/code&gt; for dollars should produce the same binary code as &lt;code&gt;+&lt;/code&gt; for ints. The pragma &lt;span id=&quot;borrow_1&quot;&gt;borrow&lt;/span&gt; has been designed to solve this problem; in principle it generates the above trivial implementations:</source>
          <target state="translated">这很快变得乏味。的实现是琐碎和编译器不应该产生这些代码后来才优化它了-毕竟 &lt;code&gt;+&lt;/code&gt; 对美元应该产生相同的二进制代码 &lt;code&gt;+&lt;/code&gt; 为整数。杂项&lt;span id=&quot;borrow_1&quot;&gt;借用&lt;/span&gt;旨在解决此问题。原则上，它生成上述琐碎的实现：</target>
        </trans-unit>
        <trans-unit id="b47005e240c8afd6e1584cbc26a7622dbbbd1d07" translate="yes" xml:space="preserve">
          <source>This rather unorthodox way to do identifier comparisons is called &lt;span id=&quot;partial-case-insensitivity_1&quot;&gt;partial case insensitivity&lt;/span&gt; and has some advantages over the conventional case sensitivity:</source>
          <target state="translated">这种进行标识符比较的不合常规的方法称为&lt;span id=&quot;partial-case-insensitivity_1&quot;&gt;不区分大小写&lt;/span&gt;，并且相对于常规&lt;span id=&quot;partial-case-insensitivity_1&quot;&gt;区分大小写&lt;/span&gt;具有一些优点：</target>
        </trans-unit>
        <trans-unit id="24ed54e7055d8ae85d9b5529ed324762a3d069ea" translate="yes" xml:space="preserve">
          <source>This requires the OpenSSL library, fortunately it's widely used and installed on many operating systems. httpclient will use SSL automatically if you give any of the functions a url with the &lt;code&gt;https&lt;/code&gt; schema, for example: &lt;code&gt;https://github.com/&lt;/code&gt;.</source>
          <target state="translated">这需要OpenSSL库，幸运的是，它已被广泛使用并安装在许多操作系统上。如果为任何功能提供带有 &lt;code&gt;https&lt;/code&gt; 架构的url，则httpclient将自动使用SSL ，例如： &lt;code&gt;https://github.com/&lt;/code&gt; : //github.com/。</target>
        </trans-unit>
        <trans-unit id="3909002e9ad606364e490e6f4e79bacb7e050226" translate="yes" xml:space="preserve">
          <source>This retrieves ALL rows into memory before iterating through the rows. Large dataset queries will impact on memory usage.</source>
          <target state="translated">这将在迭代行之前将所有行检索到内存中。大数据集查询会影响内存使用。</target>
        </trans-unit>
        <trans-unit id="096ad9b3f2bcb1230451399427a373a8d336f90f" translate="yes" xml:space="preserve">
          <source>This returns &lt;strong&gt;only&lt;/strong&gt; the parameters. If you want to get the application executable filename, call &lt;a href=&quot;#getAppFilename&quot;&gt;getAppFilename()&lt;/a&gt;.</source>
          <target state="translated">这&lt;strong&gt;仅&lt;/strong&gt;返回参数。如果要获取应用程序可执行文件的文件名，请调用&lt;a href=&quot;#getAppFilename&quot;&gt;getAppFilename（）&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="aa9d6a77d63381c1d09d47733e42419e7a92f6c1" translate="yes" xml:space="preserve">
          <source>This section can only help you with the last item.</source>
          <target state="translated">这一部分只能帮你解决最后一项。</target>
        </trans-unit>
        <trans-unit id="7e30a1e9a0acdfc19a0c0083bbed66bee81f8c64" translate="yes" xml:space="preserve">
          <source>This section deals with the basic built-in types and the operations that are available for them in detail.</source>
          <target state="translated">本节详细介绍了基本的内置类型和对它们的操作。</target>
        </trans-unit>
        <trans-unit id="39b66580a9224160aed4a56da61d43fa2a3bbf6f" translate="yes" xml:space="preserve">
          <source>This section describes Nim's additional features that are not listed in the Nim manual. Some of the features here only make sense for the C code generator and are subject to change.</source>
          <target state="translated">本节介绍Nim的附加功能,这些功能在Nim手册中没有列出。这里的一些功能只对C代码生成器有意义,可能会有变化。</target>
        </trans-unit>
        <trans-unit id="cbfa8ca764ad8bfb7ab8cb634f105e3b8af514a0" translate="yes" xml:space="preserve">
          <source>This section describes additional pragmas that the current Nim implementation supports but which should not be seen as part of the language specification.</source>
          <target state="translated">本节描述了当前Nim实现所支持的额外的语法,但这些语法不应被视为语言规范的一部分。</target>
        </trans-unit>
        <trans-unit id="a3df74b1ff5eebb36ece2e259d2d5e805032af28" translate="yes" xml:space="preserve">
          <source>This section describes how the AST is modelled with Nim's type system. The AST consists of nodes (&lt;code&gt;NimNode&lt;/code&gt;) with a variable number of children. Each node has a field named &lt;code&gt;kind&lt;/code&gt; which describes what the node contains:</source>
          <target state="translated">本节介绍如何使用Nim的类型系统对AST进行建模。AST由具有可变数量的子代的节点（ &lt;code&gt;NimNode&lt;/code&gt; ）组成。每个节点都有一个名为 &lt;code&gt;kind&lt;/code&gt; 的字段，它描述该节点包含的内容：</target>
        </trans-unit>
        <trans-unit id="b28cfadb305f94e005219763b91c53ae1a57afd3" translate="yes" xml:space="preserve">
          <source>This section lists Nim's standard syntax. How the parser handles the indentation is already described in the &lt;a href=&quot;#lexical-analysis&quot;&gt;Lexical Analysis&lt;/a&gt; section.</source>
          <target state="translated">本节列出了Nim的标准语法。&lt;a href=&quot;#lexical-analysis&quot;&gt;词法分析&lt;/a&gt;部分已经描述了解析器如何处理缩进。</target>
        </trans-unit>
        <trans-unit id="2dd3a9a0b54b906c2f17ac03b05d99470504a894" translate="yes" xml:space="preserve">
          <source>This should be called on a connected socket, and will perform an SSL handshake immediately.</source>
          <target state="translated">这应该在连接的套接字上被调用,并将立即执行SSL握手。</target>
        </trans-unit>
        <trans-unit id="f33d2aee12f9e4445c80f6903f9125cbac15130e" translate="yes" xml:space="preserve">
          <source>This should be used instead of &lt;code&gt;discard&lt;/code&gt; to discard void futures.</source>
          <target state="translated">应该使用它代替 &lt;code&gt;discard&lt;/code&gt; 来丢弃无效的期货。</target>
        </trans-unit>
        <trans-unit id="79d43e8081cd2738e9c8a30d0556e7afa9f98284" translate="yes" xml:space="preserve">
          <source>This should produce roughly this code:</source>
          <target state="translated">这应该会产生大致这样的代码。</target>
        </trans-unit>
        <trans-unit id="5a4682779a113516e431fc633b78e3eb5afe0b69" translate="yes" xml:space="preserve">
          <source>This symbol takes a string as its value, like &lt;code&gt;--define:tempDir:/some/temp/path&lt;/code&gt; to override the temporary directory returned by &lt;code&gt;os.getTempDir()&lt;/code&gt;. The value &lt;strong&gt;should&lt;/strong&gt; end with a directory separator character. (Relevant for the Android platform)</source>
          <target state="translated">该符号将字符串作为其值，例如 &lt;code&gt;--define:tempDir:/some/temp/path&lt;/code&gt; 来覆盖 &lt;code&gt;os.getTempDir()&lt;/code&gt; 返回的临时目录。该值&lt;strong&gt;应&lt;/strong&gt;以目录分隔符结尾。（与Android平台相关）</target>
        </trans-unit>
        <trans-unit id="9b990f66ca4d7aa57f0cf0dd33176a666917f9d2" translate="yes" xml:space="preserve">
          <source>This symbol takes a string as its value, like &lt;code&gt;--define:useShPath:/opt/sh/bin/sh&lt;/code&gt; to override the path for the &lt;code&gt;sh&lt;/code&gt; binary, in cases where it is not located in the default location &lt;code&gt;/bin/sh&lt;/code&gt;.</source>
          <target state="translated">该符号将字符串作为其值，例如 &lt;code&gt;--define:useShPath:/opt/sh/bin/sh&lt;/code&gt; ,以覆盖 &lt;code&gt;sh&lt;/code&gt; 二进制文件的路径（如果它不在默认位置 &lt;code&gt;/bin/sh&lt;/code&gt; 中)。</target>
        </trans-unit>
        <trans-unit id="beb8c91cc0539e7ac1fcb6913e444dfab0dfc651" translate="yes" xml:space="preserve">
          <source>This the stdcall convention as specified by Microsoft. The generated C procedure is declared with the &lt;code&gt;__stdcall&lt;/code&gt; keyword.</source>
          <target state="translated">这是Microsoft指定的stdcall约定。生成的C过程使用 &lt;code&gt;__stdcall&lt;/code&gt; 关键字声明。</target>
        </trans-unit>
        <trans-unit id="40a29bb19075988ba4154f245cf61264e6c3403b" translate="yes" xml:space="preserve">
          <source>This trait is similar to &lt;em&gt;genericHead&lt;/em&gt;, but instead of producing error for non-generic types, it will just return them unmodified.</source>
          <target state="translated">此特征类似于&lt;em&gt;genericHead&lt;/em&gt;，但是不会对非泛型类型产生错误，而是将它们返回未修改状态。</target>
        </trans-unit>
        <trans-unit id="31b73c4d12f30a07a08773a16f4683aba0e028b0" translate="yes" xml:space="preserve">
          <source>This trait returns true iff the type &lt;code&gt;t&lt;/code&gt; is safe to use for &lt;span id=&quot;copymem_1&quot;&gt;copyMem&lt;/span&gt;. Other languages name a type like these &lt;span id=&quot;blob_1&quot;&gt;blob&lt;/span&gt;.</source>
          <target state="translated">如果 &lt;code&gt;t&lt;/code&gt; 类型可安全用于&lt;span id=&quot;copymem_1&quot;&gt;copyMem，&lt;/span&gt;则此特征返回true 。其他语言也使用类似这些&lt;span id=&quot;blob_1&quot;&gt;blob的&lt;/span&gt;名称。</target>
        </trans-unit>
        <trans-unit id="3824e56a10ede7c713ffb39e26e88a788482118a" translate="yes" xml:space="preserve">
          <source>This transformation is only done if the varargs parameter is the last parameter in the procedure header. It is also possible to perform type conversions in this context:</source>
          <target state="translated">只有当varargs参数是存储过程头的最后一个参数时,才会进行这种转换。在这种情况下也可以进行类型转换。</target>
        </trans-unit>
        <trans-unit id="66d1986229bd95fd619538b360b3cc3585eddf09" translate="yes" xml:space="preserve">
          <source>This type contains a description of a person</source>
          <target state="translated">此类型包含对一个人的描述</target>
        </trans-unit>
        <trans-unit id="c4d9daad0926694b235ad99d9f58721fb3438862" translate="yes" xml:space="preserve">
          <source>This uses the &lt;span id=&quot;levenshtein_1&quot;&gt;Levenshtein&lt;/span&gt; distance algorithm with only a linear memory overhead.</source>
          <target state="translated">这使用了&lt;span id=&quot;levenshtein_1&quot;&gt;Levenshtein&lt;/span&gt;距离算法，并且仅具有线性内存开销。</target>
        </trans-unit>
        <trans-unit id="4922584a12b79a219eaa16925bbb909743a91e2e" translate="yes" xml:space="preserve">
          <source>This uses the algorithm specified in &lt;a href=&quot;http://tools.ietf.org/html/rfc3986#section-5.2.2&quot;&gt;section 5.2.2 of RFC 3986&lt;/a&gt;.</source>
          <target state="translated">这使用&lt;a href=&quot;http://tools.ietf.org/html/rfc3986#section-5.2.2&quot;&gt;RFC 3986第5.2.2节中&lt;/a&gt;指定的算法。</target>
        </trans-unit>
        <trans-unit id="e3e216d34b156aa03e46b15d955959dbcd959d74" translate="yes" xml:space="preserve">
          <source>This uses the configuration defined in &lt;code&gt;config\nim.cfg&lt;/code&gt; for &lt;code&gt;lvm_gcc&lt;/code&gt;.</source>
          <target state="translated">这将使用 &lt;code&gt;config\nim.cfg&lt;/code&gt; 为 &lt;code&gt;lvm_gcc&lt;/code&gt; 定义的配置。</target>
        </trans-unit>
        <trans-unit id="5505a00f1063702f80a5818b1a5c8c32d61e3710" translate="yes" xml:space="preserve">
          <source>This version of &lt;code&gt;foldl&lt;/code&gt; gets a starting parameter. This makes it possible to accumulate the sequence into a different type than the sequence elements.</source>
          <target state="translated">此版本的 &lt;code&gt;foldl&lt;/code&gt; 获得一个起始参数。这使得可以将序列累积为与序列元素不同的类型。</target>
        </trans-unit>
        <trans-unit id="7bac1b6d0db41715df5581bb4825ea90b0b4190f" translate="yes" xml:space="preserve">
          <source>This will generate a file called &lt;code&gt;switchhomebrew.elf&lt;/code&gt; which can then be turned into an nro file with the &lt;code&gt;elf2nro&lt;/code&gt; tool in the DevkitPro release. Examples can be found at &lt;a href=&quot;https://github.com/jyapayne/nim-libnx.git&quot;&gt;the nim-libnx github repo&lt;/a&gt;.</source>
          <target state="translated">这将生成一个名为 &lt;code&gt;switchhomebrew.elf&lt;/code&gt; 的文件，然后可以使用DevkitPro版本中的 &lt;code&gt;elf2nro&lt;/code&gt; 工具将其转换为nro文件。可以在&lt;a href=&quot;https://github.com/jyapayne/nim-libnx.git&quot;&gt;nim-libnx github repo上&lt;/a&gt;找到示例。</target>
        </trans-unit>
        <trans-unit id="26136905c2efd9e1d537dc87f61ea998287f6a6d" translate="yes" xml:space="preserve">
          <source>This will generate an index of all the exported symbols in the input Nim module, and put it into a neighboring file with the extension of &lt;code&gt;.idx&lt;/code&gt;. The index file is line oriented (newlines have to be escaped). Each line represents a tab separated record of several columns, the first two mandatory, the rest optional. See the &lt;a href=&quot;#index-idx-file-format&quot;&gt;Index (idx) file format&lt;/a&gt; section for details.</source>
          <target state="translated">这将在输入Nim模块中生成所有导出符号的索引，并将其放入扩展名为 &lt;code&gt;.idx&lt;/code&gt; 的相邻文件中。索引文件是面向行的（必须换行）。每行代表一个由标签分隔的几列记录，前两列为必填项，其余为可选项。有关详细信息，请参见&lt;a href=&quot;#index-idx-file-format&quot;&gt;索引（idx）文件格式&lt;/a&gt;部分。</target>
        </trans-unit>
        <trans-unit id="8ead03785f5fb54bd6190bd855d00357524e06d3" translate="yes" xml:space="preserve">
          <source>This will provide Hints in the compiler output either every time the concept is not matched or only on the particular call-site.</source>
          <target state="translated">这将在编译器输出中提供Hints,可以是每次概念不匹配,也可以是只在特定的call-site上。</target>
        </trans-unit>
        <trans-unit id="aa4705d432fb1b0185c67d13ccff0749b0afd34e" translate="yes" xml:space="preserve">
          <source>This will raise &lt;code&gt;ValueError&lt;/code&gt; if &lt;code&gt;future&lt;/code&gt; is finished.</source>
          <target state="translated">如果 &lt;code&gt;future&lt;/code&gt; 完成，这将引发 &lt;code&gt;ValueError&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="77dd0890df14804d1f6f5c6ad7d8c663331e013e" translate="yes" xml:space="preserve">
          <source>This will recursively generate documentation of all nim modules imported into the input module that belong to the Nimble package that &lt;code&gt;filename.nim&lt;/code&gt; belongs to.</source>
          <target state="translated">这将递归地生成所有导入到输入模块中的，属于 &lt;code&gt;filename.nim&lt;/code&gt; 所属的Nimble软件包的nim模块的文档。</target>
        </trans-unit>
        <trans-unit id="01e5c517031f780132f7de304e80ce21fd6382d8" translate="yes" xml:space="preserve">
          <source>This works only for the letters &lt;code&gt;A-Z&lt;/code&gt;.</source>
          <target state="translated">这仅适用于字母 &lt;code&gt;A-Z&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8cd34efcb73d9e9a4a38033e49417a668da60801" translate="yes" xml:space="preserve">
          <source>This works only for the letters &lt;code&gt;A-Z&lt;/code&gt;. See &lt;a href=&quot;unicode#toLower&quot;&gt;unicode.toLower&lt;/a&gt; for a version that works for any Unicode character.</source>
          <target state="translated">这仅适用于字母 &lt;code&gt;A-Z&lt;/code&gt; 。有关适用于任何Unicode字符的版本，请参见&lt;a href=&quot;unicode#toLower&quot;&gt;unicode.toLower&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3189c7fd9700aaadbf4a4dd6af6df7937cf0b2d7" translate="yes" xml:space="preserve">
          <source>This works only for the letters &lt;code&gt;A-Z&lt;/code&gt;. See &lt;a href=&quot;unicode#toUpper&quot;&gt;unicode.toUpper&lt;/a&gt; for a version that works for any Unicode character.</source>
          <target state="translated">这仅适用于字母 &lt;code&gt;A-Z&lt;/code&gt; 。有关适用于任何Unicode字符的版本，请参见&lt;a href=&quot;unicode#toUpper&quot;&gt;unicode.toUpper&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="fc168569a3d857e9b97041d394676d2e416f6807" translate="yes" xml:space="preserve">
          <source>This would be any of the other idetools available options, like &lt;code&gt;--def&lt;/code&gt; or &lt;code&gt;--suggest&lt;/code&gt; explained in the following sections.</source>
          <target state="translated">这将是任何其他idetools的可用选项，如 &lt;code&gt;--def&lt;/code&gt; 或 &lt;code&gt;--suggest&lt;/code&gt; 在下面的章节解释。</target>
        </trans-unit>
        <trans-unit id="3974135028a38a44142b8af58d9f501e1acc3c71" translate="yes" xml:space="preserve">
          <source>This zero copy, memchr-limited interface is probably the fastest way to iterate over line-like records in a file. However, returned (data,size) objects are not Nim strings, bounds checked Nim arrays, or even terminated C strings. So, care is required to access the data (e.g., think C mem* functions, not str* functions).</source>
          <target state="translated">这个零拷贝、memchr-limited的接口可能是在文件中迭代类似行的记录的最快方法。然而,返回的(data,size)对象不是Nim字符串,不是bounds检查的Nim数组,甚至不是终止的C字符串。所以,访问数据时需要谨慎(例如,考虑C mem*函数,而不是str*函数)。</target>
        </trans-unit>
        <trans-unit id="3f848317832fae19e0085de9e23738862798395f" translate="yes" xml:space="preserve">
          <source>Though it should be pretty obvious what the program does, I will explain the syntax: statements which are not indented are executed when the program starts. Indentation is Nim's way of grouping statements. Indentation is done with spaces only, tabulators are not allowed.</source>
          <target state="translated">虽然程序的作用应该很明显,但我还是要解释一下语法:程序启动时,没有缩进的语句会被执行。缩进是Nim对语句进行分组的方式。缩进只用空格,不允许使用制表符。</target>
        </trans-unit>
        <trans-unit id="6d02e1b27f5da6165217ae6af04fef8718253485" translate="yes" xml:space="preserve">
          <source>Though the Nim Standard Library is still evolving, it is already quite usable. It is divided into &lt;em&gt;pure libraries&lt;/em&gt;, &lt;em&gt;impure libraries&lt;/em&gt; and &lt;em&gt;wrappers&lt;/em&gt;.</source>
          <target state="translated">尽管Nim标准库仍在发展中，但已经相当有用。它分为&lt;em&gt;纯库&lt;/em&gt;，&lt;em&gt;不纯库&lt;/em&gt;和&lt;em&gt;包装器&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="b4cc7e4d5579d2abc9a379f6ffd100e925cda3b1" translate="yes" xml:space="preserve">
          <source>Thread coordination</source>
          <target state="translated">线程协调</target>
        </trans-unit>
        <trans-unit id="59a7e2e5a99004361b87c2d5390e14c75d8f283e" translate="yes" xml:space="preserve">
          <source>Thread pragma</source>
          <target state="translated">线程pragma</target>
        </trans-unit>
        <trans-unit id="bb1d54b91c07f35c7604f3ddd4b6f833468ea9ba" translate="yes" xml:space="preserve">
          <source>Thread support for Nim. &lt;strong&gt;Note&lt;/strong&gt;: This is part of the system module. Do not import it directly. To activate thread support you need to compile with the &lt;code&gt;--threads:on&lt;/code&gt; command line switch.</source>
          <target state="translated">对Nim的线程支持。&lt;strong&gt;注意&lt;/strong&gt;：这是系统模块的一部分。不要直接导入。要激活线程支持，您需要使用 &lt;code&gt;--threads:on&lt;/code&gt; 命令行开关进行编译。</target>
        </trans-unit>
        <trans-unit id="bb12e8aaaecc434fd51e448fe7669bced1bdd107" translate="yes" xml:space="preserve">
          <source>Threads</source>
          <target state="translated">Threads</target>
        </trans-unit>
        <trans-unit id="efcacaedc288d5f1ee9e06293407eb061bd561ea" translate="yes" xml:space="preserve">
          <source>Threads and exceptions</source>
          <target state="translated">线程和例外情况</target>
        </trans-unit>
        <trans-unit id="9e9af3f7a423d176c8e989c93a406d4e77eaeeca" translate="yes" xml:space="preserve">
          <source>Threadvar pragma</source>
          <target state="translated">线程var pragma</target>
        </trans-unit>
        <trans-unit id="7c599a1317d70c1913cfd27374ce0f1835f7e408" translate="yes" xml:space="preserve">
          <source>Three characters indicating the type of returned answer (e.g. &lt;code&gt;def&lt;/code&gt; for definition, &lt;code&gt;sug&lt;/code&gt; for suggestion, etc).</source>
          <target state="translated">三个字符指示返回的答案的类型（例如，定义为 &lt;code&gt;def&lt;/code&gt; ， &lt;code&gt;sug&lt;/code&gt; 为sug等）。</target>
        </trans-unit>
        <trans-unit id="cb0fdc12f844b31a8cf54439d51d7813e5ece7c9" translate="yes" xml:space="preserve">
          <source>Three characters indicating the type of returned answer (e.g. def for definition, &lt;code&gt;sug&lt;/code&gt; for suggestion, etc).</source>
          <target state="translated">三个字符指示返回的答案的类型（例如，定义为def， &lt;code&gt;sug&lt;/code&gt; 为sug等）。</target>
        </trans-unit>
        <trans-unit id="04a4b67d34c6ea267e9e2aa731f12d8004957357" translate="yes" xml:space="preserve">
          <source>Three letter string which indicates the day of the week.</source>
          <target state="translated">三个字母串,表示一周的日子。</target>
        </trans-unit>
        <trans-unit id="166b5ad7cdc1ddb77e376400c9f9b2e942b944d7" translate="yes" xml:space="preserve">
          <source>Through the &lt;code&gt;-d:x&lt;/code&gt; or &lt;code&gt;--define:x&lt;/code&gt; switch you can define compile time symbols for conditional compilation. The defined switches can be checked in source code with the &lt;a href=&quot;manual#when-statement&quot;&gt;when statement&lt;/a&gt; and &lt;a href=&quot;system#defined&quot;&gt;defined proc&lt;/a&gt;. The typical use of this switch is to enable builds in release mode (&lt;code&gt;-d:release&lt;/code&gt;) where certain safety checks are omitted for better performance. Another common use is the &lt;code&gt;-d:ssl&lt;/code&gt; switch to activate SSL sockets.</source>
          <target state="translated">通过 &lt;code&gt;-d:x&lt;/code&gt; 或 &lt;code&gt;--define:x&lt;/code&gt; 开关，您可以定义条件编译的编译时间符号。可以使用&lt;a href=&quot;manual#when-statement&quot;&gt;when语句&lt;/a&gt;和&lt;a href=&quot;system#defined&quot;&gt;proc&lt;/a&gt;来在源代码中检查已定义的开关。此开关的典型用法是在释放模式（ &lt;code&gt;-d:release&lt;/code&gt; ）中启用构建，在此模式中，为了确保更好的性能，省略了某些安全检查。另一个常见用途是 &lt;code&gt;-d:ssl&lt;/code&gt; 开关，用于激活SSL套接字。</target>
        </trans-unit>
        <trans-unit id="053686996ea91f5f0bd8bfc5be9311b2dfb9563b" translate="yes" xml:space="preserve">
          <source>Through the &lt;code&gt;nimsuggest&lt;/code&gt; tool, any IDE can query a &lt;code&gt;.nim&lt;/code&gt; source file and obtain useful information like definition of symbols or suggestions for completion.</source>
          <target state="translated">通过 &lt;code&gt;nimsuggest&lt;/code&gt; 工具，任何IDE都可以查询 &lt;code&gt;.nim&lt;/code&gt; 源文件并获得有用的信息，例如符号定义或完成建议。</target>
        </trans-unit>
        <trans-unit id="645311b7482290ae055f08a018122a58f2c3b9eb" translate="yes" xml:space="preserve">
          <source>Through the use of the optional &lt;code&gt;{.raises.}&lt;/code&gt; pragma you can specify that a proc is meant to raise a specific set of exceptions, or none at all. If the &lt;code&gt;{.raises.}&lt;/code&gt; pragma is used, the compiler will verify that this is true. For instance, if you specify that a proc raises &lt;code&gt;IOError&lt;/code&gt;, and at some point it (or one of the procs it calls) starts raising a new exception the compiler will prevent that proc from compiling. Usage example:</source>
          <target state="translated">通过使用可选的 &lt;code&gt;{.raises.}&lt;/code&gt; 编译指示，您可以指定proc旨在引发一组特定的异常，或者根本不引发。如果使用 &lt;code&gt;{.raises.}&lt;/code&gt; 编译指示，编译器将验证这是正确的。例如，如果您指定proc引发 &lt;code&gt;IOError&lt;/code&gt; ，并且在某个点（或它调用的proc 之一）开始引发新的异常，则编译器将阻止该proc进行编译。用法示例：</target>
        </trans-unit>
        <trans-unit id="7e4ee67f0e9e151a472bd4d369d44933d3da7821" translate="yes" xml:space="preserve">
          <source>Thrown in the &lt;code&gt;getContent&lt;/code&gt; proc and &lt;code&gt;postContent&lt;/code&gt; proc, when the server returns an error</source>
          <target state="translated">服务器返回错误时，将其抛出于 &lt;code&gt;getContent&lt;/code&gt; proc和 &lt;code&gt;postContent&lt;/code&gt; proc中</target>
        </trans-unit>
        <trans-unit id="37977e3077bc9851c1ffd00107b486f2f8f09038" translate="yes" xml:space="preserve">
          <source>Thus the checks would have been very difficult to implement properly with little benefit, especially since they are simple to implement in the client. The client should use the &lt;em&gt;errorMsgExpected&lt;/em&gt; proc to generate a nice error message that fits the other error messages this library creates.</source>
          <target state="translated">因此，检查将很难以很少的好处正确地实施，尤其是因为它们在客户端中易于实施。客户端应使用&lt;em&gt;errorMsgExpected&lt;/em&gt; proc生成适合该库创建的其他错误消息的错误消息。</target>
        </trans-unit>
        <trans-unit id="d39bb08fac5f6360feb78a680d458fc658579909" translate="yes" xml:space="preserve">
          <source>Thus they act more like keywords than like ordinary identifiers; unlike a keyword however, a redefinition may &lt;span id=&quot;shadow_1&quot;&gt;shadow&lt;/span&gt; the definition in the &lt;code&gt;system&lt;/code&gt; module. From this list the following should not be written in dot notation &lt;code&gt;x.f&lt;/code&gt; since &lt;code&gt;x&lt;/code&gt; cannot be type checked before it gets passed to &lt;code&gt;f&lt;/code&gt;:</source>
          <target state="translated">因此，它们的行为更像是关键字，而不是普通的标识符。但是，与关键字不同，重新定义可能会&lt;span id=&quot;shadow_1&quot;&gt;影响&lt;/span&gt; &lt;code&gt;system&lt;/code&gt; 模块中的定义。在此列表中，以下内容不应以点符号 &lt;code&gt;x.f&lt;/code&gt; 书写，因为 &lt;code&gt;x&lt;/code&gt; 在传递给 &lt;code&gt;f&lt;/code&gt; 之前无法进行类型检查：</target>
        </trans-unit>
        <trans-unit id="0ee323ffc9625d6bc28b4f8cc717e26ebd77ac1a" translate="yes" xml:space="preserve">
          <source>Thus, north &amp;lt; east &amp;lt; south &amp;lt; west. The comparison operators can be used with enumeration types. Instead of &lt;code&gt;north&lt;/code&gt; etc, the enum value can also be qualified with the enum type that it resides in, &lt;code&gt;Direction.north&lt;/code&gt;.</source>
          <target state="translated">因此，北&amp;lt;东&amp;lt;南&amp;lt;西。比较运算符可以与枚举类型一起使用。代替 &lt;code&gt;north&lt;/code&gt; 等，枚举值还可以使用其驻留的枚举类型 &lt;code&gt;Direction.north&lt;/code&gt; 限定。</target>
        </trans-unit>
        <trans-unit id="1b4b8a59ee4623c1899387bf6de6586afc3a5dc2" translate="yes" xml:space="preserve">
          <source>Time components are subtracted one-by-one, see output:</source>
          <target state="translated">时间分量逐一减去,见输出。</target>
        </trans-unit>
        <trans-unit id="3fb812b32f09c8031753f69acac0c61789f34460" translate="yes" xml:space="preserve">
          <source>Time effect.</source>
          <target state="translated">时间效应。</target>
        </trans-unit>
        <trans-unit id="ec3ccfa05db1ce4bb37a133e936dac6618864488" translate="yes" xml:space="preserve">
          <source>Time measurement</source>
          <target state="translated">时间测量</target>
        </trans-unit>
        <trans-unit id="f4fb52fb2152cd12040e0a822c3f35572a335a53" translate="yes" xml:space="preserve">
          <source>TimeInterval of &lt;code&gt;d&lt;/code&gt; days.</source>
          <target state="translated">&lt;code&gt;d&lt;/code&gt; 天的时间间隔。</target>
        </trans-unit>
        <trans-unit id="45493a2f2864af1ad59f4e6002d36f0afb4f0012" translate="yes" xml:space="preserve">
          <source>TimeInterval of &lt;code&gt;h&lt;/code&gt; hours.</source>
          <target state="translated">&lt;code&gt;h&lt;/code&gt; 小时的TimeInterval 。</target>
        </trans-unit>
        <trans-unit id="48a2bec4e7d8f08615b4a69538e1d873fd8cabd4" translate="yes" xml:space="preserve">
          <source>TimeInterval of &lt;code&gt;m&lt;/code&gt; minutes.</source>
          <target state="translated">的TimeInterval所 &lt;code&gt;m&lt;/code&gt; 分钟。</target>
        </trans-unit>
        <trans-unit id="fd8b1b84cf164e73ebf16147dec8fe94eb87b149" translate="yes" xml:space="preserve">
          <source>TimeInterval of &lt;code&gt;m&lt;/code&gt; months.</source>
          <target state="translated">&lt;code&gt;m&lt;/code&gt; 个月的时间间隔。</target>
        </trans-unit>
        <trans-unit id="2e35c45093c4c75c76cc0ad1730384cf89bc1aab" translate="yes" xml:space="preserve">
          <source>TimeInterval of &lt;code&gt;micros&lt;/code&gt; microseconds.</source>
          <target state="translated">的TimeInterval所 &lt;code&gt;micros&lt;/code&gt; 微秒。</target>
        </trans-unit>
        <trans-unit id="571851bb6763be044dfb20a43ad6453fa502f0ca" translate="yes" xml:space="preserve">
          <source>TimeInterval of &lt;code&gt;ms&lt;/code&gt; milliseconds.</source>
          <target state="translated">&lt;code&gt;ms&lt;/code&gt; 的 TimeInterval 毫秒。</target>
        </trans-unit>
        <trans-unit id="a0a7b6a6e6dabdcbf91694569154f0821829247a" translate="yes" xml:space="preserve">
          <source>TimeInterval of &lt;code&gt;nanos&lt;/code&gt; nanoseconds.</source>
          <target state="translated">的TimeInterval所 &lt;code&gt;nanos&lt;/code&gt; 纳秒。</target>
        </trans-unit>
        <trans-unit id="843631ff0523a6f86df81cbca0448371ae88177c" translate="yes" xml:space="preserve">
          <source>TimeInterval of &lt;code&gt;s&lt;/code&gt; seconds.</source>
          <target state="translated">&lt;code&gt;s&lt;/code&gt; 秒的TimeInterval 。</target>
        </trans-unit>
        <trans-unit id="bdc17d9ec9d80bdf5f4294a7ade05be0d237182e" translate="yes" xml:space="preserve">
          <source>TimeInterval of &lt;code&gt;w&lt;/code&gt; weeks.</source>
          <target state="translated">&lt;code&gt;w&lt;/code&gt; 周的TimeInterval 。</target>
        </trans-unit>
        <trans-unit id="77b05f6f1a5def9a860eb63a1be452d2e901c363" translate="yes" xml:space="preserve">
          <source>TimeInterval of &lt;code&gt;y&lt;/code&gt; years.</source>
          <target state="translated">&lt;code&gt;y&lt;/code&gt; 年的时间间隔。</target>
        </trans-unit>
        <trans-unit id="27a4f2c5a6aa7d957af2668e0ec53e32944aba26" translate="yes" xml:space="preserve">
          <source>Timeouts</source>
          <target state="translated">Timeouts</target>
        </trans-unit>
        <trans-unit id="49563f216566fe13f36b6d6f96d904d2f0012073" translate="yes" xml:space="preserve">
          <source>Timezone interface for supporting &lt;code&gt;DateTime&lt;/code&gt;'s of arbritary timezones. The &lt;code&gt;times&lt;/code&gt; module only supplies implementations for the systems local time and UTC.</source>
          <target state="translated">时区接口，用于支持世界时区的 &lt;code&gt;DateTime&lt;/code&gt; 。本 &lt;code&gt;times&lt;/code&gt; 模块为系统的本地时间和UTC只有用品的实现。</target>
        </trans-unit>
        <trans-unit id="005f759cb3d18c4ae00a285a0712a53038aa8ad6" translate="yes" xml:space="preserve">
          <source>To &lt;em&gt;invoke&lt;/em&gt; a template, call it like a procedure.</source>
          <target state="translated">要&lt;em&gt;调用&lt;/em&gt;模板，请像过程一样调用它。</target>
        </trans-unit>
        <trans-unit id="6ce1339a3fbb20d91263c5b8ca905cfc7af9e20c" translate="yes" xml:space="preserve">
          <source>To access multiple values of a key, use the overloaded &lt;code&gt;[]&lt;/code&gt; below or to get all of them access the &lt;code&gt;table&lt;/code&gt; field directly.</source>
          <target state="translated">要访问一个键的多个值，请使用下面的重载 &lt;code&gt;[]&lt;/code&gt; 或让它们全部直接访问 &lt;code&gt;table&lt;/code&gt; 字段。</target>
        </trans-unit>
        <trans-unit id="1a8854509b79b921922ff284c021ca2226c66887" translate="yes" xml:space="preserve">
          <source>To allocate a new traced object, the built-in procedure &lt;code&gt;new&lt;/code&gt; has to be used. To deal with untraced memory, the procedures &lt;code&gt;alloc&lt;/code&gt;, &lt;code&gt;dealloc&lt;/code&gt; and &lt;code&gt;realloc&lt;/code&gt; can be used. The documentation of the system module contains further information.</source>
          <target state="translated">要分配新的跟踪对象，必须使用内置过程 &lt;code&gt;new&lt;/code&gt; 。要处理未跟踪的内存，可以使用 &lt;code&gt;alloc&lt;/code&gt; ， &lt;code&gt;dealloc&lt;/code&gt; 和 &lt;code&gt;realloc&lt;/code&gt; 过程。系统模块的文档包含更多信息。</target>
        </trans-unit>
        <trans-unit id="74b75bdb6d108ccec959da5a9406fd4ee6f129b2" translate="yes" xml:space="preserve">
          <source>To allocate a new traced object, the built-in procedure &lt;code&gt;new&lt;/code&gt; must be used. To deal with untraced memory, the procedures &lt;code&gt;alloc&lt;/code&gt;, &lt;code&gt;dealloc&lt;/code&gt; and &lt;code&gt;realloc&lt;/code&gt; can be used. The &lt;a href=&quot;system&quot;&gt;system&lt;/a&gt; module's documentation contains further details.</source>
          <target state="translated">要分配新的跟踪对象，必须使用内置过程 &lt;code&gt;new&lt;/code&gt; 。要处理未跟踪的内存，可以使用 &lt;code&gt;alloc&lt;/code&gt; ， &lt;code&gt;dealloc&lt;/code&gt; 和 &lt;code&gt;realloc&lt;/code&gt; 过程。该&lt;a href=&quot;system&quot;&gt;系统&lt;/a&gt;模块的文档包含更多细节。</target>
        </trans-unit>
        <trans-unit id="e078eeb299e1530ea0a1c7ae42a41d998f5aecf7" translate="yes" xml:space="preserve">
          <source>To be documented.</source>
          <target state="translated">有待记录。</target>
        </trans-unit>
        <trans-unit id="fb4aa18bea852a508605d53caeef9c5f926d90dc" translate="yes" xml:space="preserve">
          <source>To be the most efficient, make sure &lt;em&gt;s&lt;/em&gt; is preallocated with an additional amount equal to the byte length of &lt;em&gt;c&lt;/em&gt;.</source>
          <target state="translated">为了使效率最高，请确保预先分配了&lt;em&gt;s&lt;/em&gt;，该额外数量等于&lt;em&gt;c&lt;/em&gt;的字节长度。</target>
        </trans-unit>
        <trans-unit id="e2e8cced600feca55a223908d10e5130220dfada" translate="yes" xml:space="preserve">
          <source>To be used when diffing times. Consider using &lt;em&gt;between&lt;/em&gt; instead.</source>
          <target state="translated">时差时使用。考虑改用&lt;em&gt;之间&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="9599c6de97f8d0342f31be2e0d82a6fa8e679162" translate="yes" xml:space="preserve">
          <source>To be written.</source>
          <target state="translated">待写。</target>
        </trans-unit>
        <trans-unit id="11e63287bf2192ba9bdf47d785bd859bfea604a0" translate="yes" xml:space="preserve">
          <source>To call a procedure that returns a value just for its side effects and ignoring its return value, a &lt;code&gt;discard&lt;/code&gt; statement &lt;strong&gt;must&lt;/strong&gt; be used. Nim does not allow silently throwing away a return value:</source>
          <target state="translated">若要调用仅出于副作用而返回值的过程，而忽略其返回值，则&lt;strong&gt;必须&lt;/strong&gt;使用 &lt;code&gt;discard&lt;/code&gt; 语句。Nim不允许静默丢弃返回值：&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="cbd6812cedca0f8d3ecee1c4880b1874c327d444" translate="yes" xml:space="preserve">
          <source>To change the compiler from the default compiler (at the command line):</source>
          <target state="translated">要改变默认编译器的编译器(在命令行)。</target>
        </trans-unit>
        <trans-unit id="78e14482cffd7a387356de093fd85fe0f7385173" translate="yes" xml:space="preserve">
          <source>To compile a Nim module into a &lt;code&gt;.js&lt;/code&gt; file use the &lt;code&gt;js&lt;/code&gt; command; the default is a &lt;code&gt;.js&lt;/code&gt; file that is supposed to be referenced in an &lt;code&gt;.html&lt;/code&gt; file. However, you can also run the code with &lt;span id=&quot;nodejs_1&quot;&gt;nodejs&lt;/span&gt; (&lt;a href=&quot;http://nodejs.org&quot;&gt;http://nodejs.org&lt;/a&gt;):</source>
          <target state="translated">要将Nim模块编译成 &lt;code&gt;.js&lt;/code&gt; 文件，请使用 &lt;code&gt;js&lt;/code&gt; 命令；默认值为 &lt;code&gt;.js&lt;/code&gt; 文件，该文件应在 &lt;code&gt;.html&lt;/code&gt; 文件中引用。但是，您也可以使用&lt;span id=&quot;nodejs_1&quot;&gt;nodejs&lt;/span&gt;（&lt;a href=&quot;http://nodejs.org&quot;&gt;http://nodejs.org&lt;/a&gt;）运行代码：</target>
        </trans-unit>
        <trans-unit id="94b72107dca9af29a5cf8e0cbfd67507a7bbcd4c" translate="yes" xml:space="preserve">
          <source>To compile a release version use:</source>
          <target state="translated">要编译一个发行版,请使用。</target>
        </trans-unit>
        <trans-unit id="50dace50e38237573560e76fd9fe662d2da1a4dc" translate="yes" xml:space="preserve">
          <source>To compute power between integers, use &lt;em&gt;^&lt;/em&gt; e.g. 2 ^ 6</source>
          <target state="translated">要计算整数之间的幂，请使用&lt;em&gt;^&lt;/em&gt;例如2 ^ 6</target>
        </trans-unit>
        <trans-unit id="40d351e4cf238073c675c29349e5026ed8e407aa" translate="yes" xml:space="preserve">
          <source>To create a new compiler for each run, use &lt;code&gt;koch temp&lt;/code&gt;:</source>
          <target state="translated">要为每次运行创建一个新的编译器，请使用 &lt;code&gt;koch temp&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="55053d7dbb6eec73712afca1d06925e6eb2fac3c" translate="yes" xml:space="preserve">
          <source>To cross compile, use for example:</source>
          <target state="translated">要交叉编译,请使用例如。</target>
        </trans-unit>
        <trans-unit id="25e0b2d9936526053d98cae64c97e80a452c5953" translate="yes" xml:space="preserve">
          <source>To decode a base64 encoded data string simply call the &lt;code&gt;decode&lt;/code&gt; procedure:</source>
          <target state="translated">要解码base64编码的数据字符串，只需调用 &lt;code&gt;decode&lt;/code&gt; 过程：</target>
        </trans-unit>
        <trans-unit id="ff5be3702ce16d9f83c4069146c2c5cbe57cdba3" translate="yes" xml:space="preserve">
          <source>To define a new operator enclose the operator in backticks &quot;``&quot;:</source>
          <target state="translated">要定义一个新的运算符,请用反号&quot;``&quot;括起来。</target>
        </trans-unit>
        <trans-unit id="bb15e30b9d578a4da7a5878df01aeed724c88088" translate="yes" xml:space="preserve">
          <source>To define new commands like &lt;a href=&quot;system#echo&quot;&gt;echo&lt;/a&gt; and &lt;a href=&quot;system#readLine,File&quot;&gt;readLine&lt;/a&gt; in the examples, the concept of a &lt;em&gt;procedure&lt;/em&gt; is needed. (Some languages call them &lt;em&gt;methods&lt;/em&gt; or &lt;em&gt;functions&lt;/em&gt;.) In Nim new procedures are defined with the &lt;code&gt;proc&lt;/code&gt; keyword:</source>
          <target state="translated">为了在示例中定义新命令，例如&lt;a href=&quot;system#echo&quot;&gt;echo&lt;/a&gt;和&lt;a href=&quot;system#readLine,File&quot;&gt;readLine&lt;/a&gt;，需要&lt;em&gt;过程&lt;/em&gt;的概念。（某些语言称它们为&lt;em&gt;方法&lt;/em&gt;或&lt;em&gt;函数&lt;/em&gt;。）在Nim中，新过程使用 &lt;code&gt;proc&lt;/code&gt; 关键字定义：</target>
        </trans-unit>
        <trans-unit id="3fb3cbb5f800fd3864fa68084a11d47c5e74ac25" translate="yes" xml:space="preserve">
          <source>To differentiate between a documentation and API file a convention is used: indices which contain one entry without the HTML hash character (#) will be considered &lt;em&gt;documentation&lt;/em&gt;, since this hash-less entry is the explicit title of the document. Indices without this explicit entry will be considered &lt;em&gt;generated API&lt;/em&gt; extracted out of a source &lt;code&gt;.nim&lt;/code&gt; file.</source>
          <target state="translated">为了区分文档和API文件，使用了一种约定：包含一个没有HTML哈希字符（＃）的条目的索引将被视为&lt;em&gt;文档&lt;/em&gt;，因为该无哈希条目是文档的显式标题。没有此显式条目的索引将被视为从源 &lt;code&gt;.nim&lt;/code&gt; 文件中提取的&lt;em&gt;生成的API&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="42c41b02b95231a84de881a8a918eb15cfd5edbe" translate="yes" xml:space="preserve">
          <source>To differentiate both types (documents and APIs), the index generator will add to the index of documents an entry with the title of the document. Since the title is the topmost element, it will be added with a second field containing just the filename without any HTML anchor. By convention this entry without anchor is the &lt;em&gt;title entry&lt;/em&gt;, and since entries in the index file are added as they are scanned, the title entry will be the first line. The title for APIs is not present because it can be generated concatenating the name of the file to the word &lt;strong&gt;Module&lt;/strong&gt;.</source>
          <target state="translated">为了区分两种类型（文档和API），索引生成器将在文档索引中添加带有文档标题的条目。由于标题是最顶层的元素，因此将添加第二个字段，该字段仅包含文件名而没有任何HTML锚。按照惯例，没有锚点的该条目是&lt;em&gt;标题条目&lt;/em&gt;，并且由于索引文件中的条目是在扫描时添加的，因此标题条目将是第一行。 API的标题不存在，因为可以将文件名与&lt;strong&gt;Module&lt;/strong&gt;单词连接起来生成它。</target>
        </trans-unit>
        <trans-unit id="2ee4e0702447b58e78b6bb613d5d237b6836e9f3" translate="yes" xml:space="preserve">
          <source>To enable realtime support, the symbol &lt;span id=&quot;userealtimegc_1&quot;&gt;useRealtimeGC&lt;/span&gt; needs to be defined via &lt;code&gt;--define:useRealtimeGC&lt;/code&gt; (you can put this into your config file as well). With this switch the GC supports the following operations:</source>
          <target state="translated">要启用实时支持，需要通过 &lt;code&gt;--define:useRealtimeGC&lt;/code&gt; 定义符号&lt;span id=&quot;userealtimegc_1&quot;&gt;useRealtimeGC&lt;/span&gt;（您也可以将其放入配置文件中）。通过此开关，GC支持以下操作：</target>
        </trans-unit>
        <trans-unit id="7636be4ab67a90f1533c1be5ea8689d1d192cf03" translate="yes" xml:space="preserve">
          <source>To enable thread support the &lt;code&gt;--threads:on&lt;/code&gt; command line switch needs to be used. The &lt;code&gt;system&lt;/code&gt; module then contains several threading primitives. See the &lt;a href=&quot;threads&quot;&gt;threads&lt;/a&gt; and &lt;a href=&quot;channels&quot;&gt;channels&lt;/a&gt; modules for the low level thread API. There are also high level parallelism constructs available. See &lt;a href=&quot;#parallel-spawn&quot;&gt;spawn&lt;/a&gt; for further details.</source>
          <target state="translated">要启用线程支持，需要使用 &lt;code&gt;--threads:on&lt;/code&gt; 命令行开关。然后， &lt;code&gt;system&lt;/code&gt; 模块包含几个线程原语。请参阅&lt;a href=&quot;threads&quot;&gt;线程&lt;/a&gt;和&lt;a href=&quot;channels&quot;&gt;通道&lt;/a&gt;模块以获取低级线程API。也有高级并行性构造可用。有关更多详细信息，请参见&lt;a href=&quot;#parallel-spawn&quot;&gt;生成&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="eb0f5e0bd57a707dc272d6bdaa13536fe61b6dd8" translate="yes" xml:space="preserve">
          <source>To find the name of a nimble package the compiler searches for a &lt;code&gt;*.nimble&lt;/code&gt; file in the parent directory hierarchy of whatever module you are compiling. Even if you are in a subdirectory of your project, a parent &lt;code&gt;*.nimble&lt;/code&gt; file will influence the naming of the nimcache name. This means that on Unix systems creating the file &lt;code&gt;~/foo.nimble&lt;/code&gt; will automatically prefix all nimcache files not part of another package with the string &lt;code&gt;foo_&lt;/code&gt;.</source>
          <target state="translated">要查找灵活包的名称，编译器会在要编译的任何模块的父目录层次结构中搜索 &lt;code&gt;*.nimble&lt;/code&gt; 文件。即使您位于项目的子目录中，父 &lt;code&gt;*.nimble&lt;/code&gt; 文件也会影响nimcache名称的命名。这意味着在Unix系统上，创建文件 &lt;code&gt;~/foo.nimble&lt;/code&gt; 将自动为所有不属于另一个软件包的nimcache文件添加前缀 &lt;code&gt;foo_&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8ab93f39bb400a5b2494d8a733289a48baa43e8f" translate="yes" xml:space="preserve">
          <source>To force a full collection call &lt;code&gt;GC_fullCollect&lt;/code&gt;. Note that it is generally better to let the GC do its work and not enforce a full collection.</source>
          <target state="translated">要强制进行完整收集，请调用 &lt;code&gt;GC_fullCollect&lt;/code&gt; 。请注意，通常最好让GC进行工作而不执行完整的收集。</target>
        </trans-unit>
        <trans-unit id="83582671ff318357a306f2d73afcc6c6193db0e5" translate="yes" xml:space="preserve">
          <source>To generate an AST we would need to intimately know the structures used by the Nim compiler exposed in the &lt;a href=&quot;macros&quot;&gt;macros module&lt;/a&gt;, which at first look seems a daunting task. But we can use as helper shortcut the &lt;a href=&quot;macros#dumpTree&quot;&gt;dumpTree macro&lt;/a&gt;, which is used as a statement macro instead of an expression macro. Since we know that we want to generate a bunch of &lt;code&gt;const&lt;/code&gt; symbols we can create the following source file and compile it to see what the compiler &lt;em&gt;expects&lt;/em&gt; from us:</source>
          <target state="translated">要生成AST，我们需要充分了解&lt;a href=&quot;macros&quot;&gt;宏模块中&lt;/a&gt;公开的Nim编译器使用的结构，乍一看这似乎是一项艰巨的任务。但是我们可以使用&lt;a href=&quot;macros#dumpTree&quot;&gt;dumpTree宏&lt;/a&gt;作为辅助快捷方式，该宏用作语句宏而不是表达式宏。由于我们知道要生成一堆 &lt;code&gt;const&lt;/code&gt; 符号，因此可以创建以下源文件并进行编译，以查看编译器对我们的&lt;em&gt;期望&lt;/em&gt;：</target>
        </trans-unit>
        <trans-unit id="48e80bf64e7a28669c506f4ab558d9ed800f9037" translate="yes" xml:space="preserve">
          <source>To get rid of hygiene in templates, one can use the &lt;span id=&quot;dirty_1&quot;&gt;dirty&lt;/span&gt; pragma for a template. &lt;code&gt;inject&lt;/code&gt; and &lt;code&gt;gensym&lt;/code&gt; have no effect in &lt;code&gt;dirty&lt;/code&gt; templates.</source>
          <target state="translated">为了摆脱模板中的卫生问题，可以使用&lt;span id=&quot;dirty_1&quot;&gt;肮脏的&lt;/span&gt;编译指示作为模板。 &lt;code&gt;inject&lt;/code&gt; 和 &lt;code&gt;gensym&lt;/code&gt; 在 &lt;code&gt;dirty&lt;/code&gt; 模板中无效。</target>
        </trans-unit>
        <trans-unit id="825f3a2ffb603c43346bb1ea2785b67acec3d702" translate="yes" xml:space="preserve">
          <source>To give a footstart to writing macros we will show now how to turn your typical dynamic code into something that compiles statically. For the exercise we will use the following snippet of code as the starting point:</source>
          <target state="translated">为了给大家提供一个编写宏的起点,我们现在将展示如何将典型的动态代码转化为静态编译的代码。在这个练习中,我们将使用以下代码片段作为起点。</target>
        </trans-unit>
        <trans-unit id="34a57ad28acbc5e4b10960f2e801cd4aa99747b3" translate="yes" xml:space="preserve">
          <source>To link against &lt;code&gt;nimrtl.dll&lt;/code&gt; use the command:</source>
          <target state="translated">要链接到 &lt;code&gt;nimrtl.dll&lt;/code&gt; ,请使用以下命令：</target>
        </trans-unit>
        <trans-unit id="2039b927dcf641bab171f78845015d45672f1c9e" translate="yes" xml:space="preserve">
          <source>To make the &lt;code&gt;createWindow&lt;/code&gt; proc easier to use it should provide &lt;em&gt;default values&lt;/em&gt;; these are values that are used as arguments if the caller does not specify them:</source>
          <target state="translated">为了使 &lt;code&gt;createWindow&lt;/code&gt; proc易于使用，它应该提供&lt;em&gt;默认值&lt;/em&gt; ; 这些是在调用方未指定的情况下用作参数的值：</target>
        </trans-unit>
        <trans-unit id="f8a5b8288b3fecf0f566c82b883159042530cd8e" translate="yes" xml:space="preserve">
          <source>To make the compiler output code for a 16bit target use the &lt;code&gt;--cpu:avr&lt;/code&gt; target.</source>
          <target state="translated">要使编译器为16位目标输出代码，请使用 &lt;code&gt;--cpu:avr&lt;/code&gt; 目标。</target>
        </trans-unit>
        <trans-unit id="50bfd9dce33230fbb2c8127c3c5a8cde5dbf040a" translate="yes" xml:space="preserve">
          <source>To override the compiler's gcsafety analysis a &lt;code&gt;{.gcsafe.}&lt;/code&gt; pragma block can be used:</source>
          <target state="translated">要覆盖编译器的gcsafety分析，可以使用 &lt;code&gt;{.gcsafe.}&lt;/code&gt; 编译指示块：</target>
        </trans-unit>
        <trans-unit id="fdd77706967ab0eca2f0aba7e8dc6a7369cc5358" translate="yes" xml:space="preserve">
          <source>To pass a block of statements to a template, use 'untyped' for the last parameter:</source>
          <target state="translated">要将语句块传递给模板,最后一个参数使用'untyped'。</target>
        </trans-unit>
        <trans-unit id="ae1d6bbadfa15e666e4a5bc97ac5b074bba176ef" translate="yes" xml:space="preserve">
          <source>To prevent confusing code there is a parsing limitation; if the &lt;code&gt;try&lt;/code&gt; follows a &lt;code&gt;(&lt;/code&gt; it has to be written as a one liner:</source>
          <target state="translated">为了避免混淆代码，存在解析限制。如果 &lt;code&gt;try&lt;/code&gt; 遵循a &lt;code&gt;(&lt;/code&gt; 必须将其写成一个衬纸：</target>
        </trans-unit>
        <trans-unit id="cee8374e17ee5570d2e73eb9424e263793331053" translate="yes" xml:space="preserve">
          <source>To produce a single &lt;code&gt;&quot;&lt;/code&gt; within a raw string literal, it has to be doubled:</source>
          <target state="translated">要在原始字符串文字中生成单个 &lt;code&gt;&quot;&lt;/code&gt; ，必须将其加倍：</target>
        </trans-unit>
        <trans-unit id="a67c70af6b5e6b03d2581b5a5c05f83968ba3a74" translate="yes" xml:space="preserve">
          <source>To produce a single substitution character it has to be doubled: &lt;code&gt;$$&lt;/code&gt; produces &lt;code&gt;$&lt;/code&gt;.</source>
          <target state="translated">要产生单个替换字符，必须将其加倍： &lt;code&gt;$$&lt;/code&gt; 产生 &lt;code&gt;$&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6149c77815fef9fc27e4a6217efcefadefe95220" translate="yes" xml:space="preserve">
          <source>To remove this event you should use the &lt;code&gt;delHandleWrite&lt;/code&gt; function. It is advised to use that function instead of just setting the event to &lt;code&gt;proc (s: AsyncSocket) = nil&lt;/code&gt; as that would mean that that function would be called constantly.</source>
          <target state="translated">要删除此事件，应使用 &lt;code&gt;delHandleWrite&lt;/code&gt; 函数。建议使用该函数，而不仅仅是将事件设置为 &lt;code&gt;proc (s: AsyncSocket) = nil&lt;/code&gt; ，因为这意味着该函数将被不断调用。</target>
        </trans-unit>
        <trans-unit id="f4dc2bd124108bb715e2125357f3ca8cff675a9b" translate="yes" xml:space="preserve">
          <source>To retrieve the value of &lt;code&gt;&quot;key&quot;&lt;/code&gt; you can do the following:</source>
          <target state="translated">要检索 &lt;code&gt;&quot;key&quot;&lt;/code&gt; 的值，您可以执行以下操作：</target>
        </trans-unit>
        <trans-unit id="9c2272069ae83ac24e5887939db19d33d7075a38" translate="yes" xml:space="preserve">
          <source>To see a list of Nimble's packages, check out &lt;a href=&quot;https://nimble.directory/&quot;&gt;https://nimble.directory/&lt;/a&gt; or the &lt;a href=&quot;https://github.com/nim-lang/packages&quot;&gt;packages repos&lt;/a&gt; on GitHub.</source>
          <target state="translated">要查看Nimble软件包的列表，请查看&lt;a href=&quot;https://nimble.directory/&quot;&gt;https://nimble.directory/&lt;/a&gt;或GitHub上的&lt;a href=&quot;https://github.com/nim-lang/packages&quot;&gt;软件包回购&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e4bb591463a2bf5bfe74be5c756dd27d755e4b62" translate="yes" xml:space="preserve">
          <source>To specify the AST for the different Nim constructs, the notation &lt;code&gt;nodekind(son1, son2, ...)&lt;/code&gt; or &lt;code&gt;nodekind(value)&lt;/code&gt; or &lt;code&gt;nodekind(field=value)&lt;/code&gt; is used.</source>
          <target state="translated">为了为不同的Nim构造指定AST，使用了记号 &lt;code&gt;nodekind(son1, son2, ...)&lt;/code&gt; 或 &lt;code&gt;nodekind(value)&lt;/code&gt; 或 &lt;code&gt;nodekind(field=value)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b23947ec0494a83fa76619311a6fe3ef2b338db4" translate="yes" xml:space="preserve">
          <source>To the end of the tuple/object definition.</source>
          <target state="translated">到元组/对象定义的结尾。</target>
        </trans-unit>
        <trans-unit id="9f79e9096a797c7afc08420ab23a519537e4fb67" translate="yes" xml:space="preserve">
          <source>To understand some of the different ways of specifying the indices of strings, arrays, sequences, etc., it must be remembered that Nim uses zero-based indices.</source>
          <target state="translated">要了解一些指定字符串、数组、序列等的不同方式,必须记住Nim使用基于零的索引。</target>
        </trans-unit>
        <trans-unit id="596784d34744359d8630e6bf6d5a5b5ef239775c" translate="yes" xml:space="preserve">
          <source>To unpack raw bytes look at the &lt;a href=&quot;streams&quot;&gt;streams&lt;/a&gt; module.</source>
          <target state="translated">要解压缩原始字节，请查看&lt;a href=&quot;streams&quot;&gt;streams&lt;/a&gt;模块。</target>
        </trans-unit>
        <trans-unit id="9dd0e4773e807b447d8759bcce32b13725171fb1" translate="yes" xml:space="preserve">
          <source>To use</source>
          <target state="translated">要使用</target>
        </trans-unit>
        <trans-unit id="92fa9c66bf6fe6910167c4b6d93b8e2ef5d6e2c3" translate="yes" xml:space="preserve">
          <source>To use a filter for a source file the &lt;code&gt;#?&lt;/code&gt; notation is used:</source>
          <target state="translated">要对源文件使用过滤器，请使用 &lt;code&gt;#?&lt;/code&gt; 使用的符号：</target>
        </trans-unit>
        <trans-unit id="0fd3786ffe14095836ecde08c5a7353e00f84790" translate="yes" xml:space="preserve">
          <source>To use threadsafe version of this module, it needs to be compiled with both &lt;code&gt;-d:threadsafe&lt;/code&gt; and &lt;code&gt;--threads:on&lt;/code&gt; options.</source>
          <target state="translated">要使用此模块的线程安全版本，需要同时使用 &lt;code&gt;-d:threadsafe&lt;/code&gt; 和 &lt;code&gt;--threads:on&lt;/code&gt; 选项进行编译。</target>
        </trans-unit>
        <trans-unit id="31052631155b690d2c6d4d6d38ee09a1e1936e39" translate="yes" xml:space="preserve">
          <source>To verify that idetools is working properly there are files in the &lt;code&gt;tests/caas/&lt;/code&gt; directory which provide unit testing. If you find odd idetools behaviour and are able to reproduce it, you are welcome to report it as a bug and add a test to the suite to avoid future regressions.</source>
          <target state="translated">为了验证idetools是否正常工作，在 &lt;code&gt;tests/caas/&lt;/code&gt; 目录中有一些文件提供单元测试。如果您发现异常的idetools行为并能够重现它，欢迎您将其报告为bug并在套件中添加测试，以免将来出现退化。</target>
        </trans-unit>
        <trans-unit id="93e9f1bbe8f37ac15cd7d8886750a127655bd140" translate="yes" xml:space="preserve">
          <source>To wrap native code, take a look at the &lt;a href=&quot;c2nim&quot;&gt;c2nim tool&lt;/a&gt; which helps with the process of scanning and transforming header files into a Nim interface.</source>
          <target state="translated">要包装本机代码，请看一下&lt;a href=&quot;c2nim&quot;&gt;c2nim工具&lt;/a&gt;，该工具有助于将头文件扫描并将其转换为Nim界面。</target>
        </trans-unit>
        <trans-unit id="c4b661fcccef784df68a5a22da94f9a1df408bd3" translate="yes" xml:space="preserve">
          <source>To write macros, one needs to know how the Nim concrete syntax is converted to an AST.</source>
          <target state="translated">要写宏,需要知道Nim具体语法如何转换为AST。</target>
        </trans-unit>
        <trans-unit id="5b94544fc25d4f617242b0db05703f0c24a3b42d" translate="yes" xml:space="preserve">
          <source>Tokenizes the string &lt;em&gt;s&lt;/em&gt; into substrings for interpolation purposes.</source>
          <target state="translated">将字符串&lt;em&gt;s&lt;/em&gt;标记为子字符串以进行插值。</target>
        </trans-unit>
        <trans-unit id="9dabecffbc85d3462b703f6f51a8d742d3888dc3" translate="yes" xml:space="preserve">
          <source>Tokenizes the string &lt;em&gt;s&lt;/em&gt; into substrings.</source>
          <target state="translated">将字符串&lt;em&gt;s&lt;/em&gt;标记为子字符串。</target>
        </trans-unit>
        <trans-unit id="4df68215c8e8bc621359763d151b72a86c6da974" translate="yes" xml:space="preserve">
          <source>Tools available with Nim</source>
          <target state="translated">Nim提供的工具</target>
        </trans-unit>
        <trans-unit id="58446c7f2b2e4db0f99d43b03101c0a822d287a4" translate="yes" xml:space="preserve">
          <source>Tools documentation</source>
          <target state="translated">工具文件</target>
        </trans-unit>
        <trans-unit id="1fe5db2636efc921cd0bb4e6546d660babab9b05" translate="yes" xml:space="preserve">
          <source>Top level &lt;code&gt;defer&lt;/code&gt; statements are not supported since it's unclear what such a statement should refer to.</source>
          <target state="translated">不支持顶级 &lt;code&gt;defer&lt;/code&gt; 语句，因为尚不清楚该语句应引用什么。</target>
        </trans-unit>
        <trans-unit id="cb14fa6e0884cf02668ea33f83561399f74d1358" translate="yes" xml:space="preserve">
          <source>Top level accesses to &lt;code&gt;gdata&lt;/code&gt; are always allowed so that it can be initialized conveniently. It is &lt;em&gt;assumed&lt;/em&gt; (but not enforced) that every top level statement is executed before any concurrent action happens.</source>
          <target state="translated">始终允许对 &lt;code&gt;gdata&lt;/code&gt; 的顶级访问，以便可以方便地对其进行初始化。它&lt;em&gt;假定&lt;/em&gt;（但并非强制）任何并发行动发生之前每个顶级语句被执行。</target>
        </trans-unit>
        <trans-unit id="8aac1979dafc6f8136821295c2c76ca0331a0e00" translate="yes" xml:space="preserve">
          <source>Traced references are declared with the &lt;strong&gt;ref&lt;/strong&gt; keyword, untraced references are declared with the &lt;strong&gt;ptr&lt;/strong&gt; keyword. In general, a &lt;em&gt;ptr T&lt;/em&gt; is implicitly convertible to the &lt;em&gt;pointer&lt;/em&gt; type.</source>
          <target state="translated">跟踪引用使用&lt;strong&gt;ref&lt;/strong&gt;关键字声明，未跟踪引用使用&lt;strong&gt;ptr&lt;/strong&gt;关键字声明。通常，&lt;em&gt;ptr T&lt;/em&gt;可隐式转换为&lt;em&gt;指针&lt;/em&gt;类型。</target>
        </trans-unit>
        <trans-unit id="0e0c2775cf7c51f8a1bb67ce0e0ab81a950538e4" translate="yes" xml:space="preserve">
          <source>Traced references are declared with the &lt;strong&gt;ref&lt;/strong&gt; keyword; untraced references are declared with the &lt;strong&gt;ptr&lt;/strong&gt; keyword.</source>
          <target state="translated">跟踪的引用使用&lt;strong&gt;ref&lt;/strong&gt;关键字声明；未跟踪的引用使用&lt;strong&gt;ptr&lt;/strong&gt;关键字声明。</target>
        </trans-unit>
        <trans-unit id="a1fc498182e45877c7d386bad77456516385d934" translate="yes" xml:space="preserve">
          <source>Traditional select function. This function will return the number of sockets that are ready to be read from, written to, or which have errors. If there are none; 0 is returned. &lt;code&gt;Timeout&lt;/code&gt; is in milliseconds and -1 can be specified for no timeout.</source>
          <target state="translated">传统选择功能。该函数将返回准备读取，写入或有错误的套接字的数量。如果没有的话；返回0。 &lt;code&gt;Timeout&lt;/code&gt; 以毫秒为单位，并且可以将-1指定为无超时。</target>
        </trans-unit>
        <trans-unit id="cb7b92acc9a145b44981e2aafa578d392367d9b9" translate="yes" xml:space="preserve">
          <source>Transforms any iterator into a sequence.</source>
          <target state="translated">将任何迭代器转换为序列。</target>
        </trans-unit>
        <trans-unit id="ab31ee25d07a8f9d5ddc9927e74c06ef43d27b4f" translate="yes" xml:space="preserve">
          <source>Translates words in a string using the &lt;em&gt;replacements&lt;/em&gt; proc to substitute words inside &lt;em&gt;s&lt;/em&gt; with their replacements</source>
          <target state="translated">翻译使用字符串中的单词&lt;em&gt;替换&lt;/em&gt; PROC替代中的单词&lt;em&gt;小号&lt;/em&gt;与他们的替代品</target>
        </trans-unit>
        <trans-unit id="a7c36d78b13e6dda8f6d500d67c359740cbced46" translate="yes" xml:space="preserve">
          <source>Traverses the node and gets the given value. If any of the indexes do not exist, returns &lt;code&gt;nil&lt;/code&gt;. Also returns &lt;code&gt;nil&lt;/code&gt; if one of the intermediate data structures is not an array.</source>
          <target state="translated">遍历节点并获得给定值。如果任何索引都不存在，则返回 &lt;code&gt;nil&lt;/code&gt; 。如果中间数据结构之一不是数组，则还返回 &lt;code&gt;nil&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3793e0cbf6a67e24ccddc9cfe73cf06db3bff8f2" translate="yes" xml:space="preserve">
          <source>Traverses the node and gets the given value. If any of the keys do not exist, returns &lt;code&gt;nil&lt;/code&gt;. Also returns &lt;code&gt;nil&lt;/code&gt; if one of the intermediate data structures is not an object.</source>
          <target state="translated">遍历节点并获得给定值。如果任何键都不存在，则返回 &lt;code&gt;nil&lt;/code&gt; 。如果中间数据结构之一不是对象，则还返回 &lt;code&gt;nil&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9165124d411bbca6b0b36e2cf0040381f82a3771" translate="yes" xml:space="preserve">
          <source>Traverses the node and tries to set the value at the given location to &lt;code&gt;value&lt;/code&gt;. If any of the keys are missing, they are added.</source>
          <target state="translated">遍历该节点，并尝试将给定位置的值设置为 &lt;code&gt;value&lt;/code&gt; 。如果缺少任何键，则会添加它们。</target>
        </trans-unit>
        <trans-unit id="156e25a6b8cf8a864963e049e7d35bac34d38d59" translate="yes" xml:space="preserve">
          <source>Tries to acquire the given lock. Returns &lt;em&gt;true&lt;/em&gt; on success.</source>
          <target state="translated">尝试获取给定的锁。成功返回&lt;em&gt;true&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="468da52d5869ae376d9b95725718bd6ff03dd727" translate="yes" xml:space="preserve">
          <source>Tries to execute the query and returns true if successful, false otherwise.</source>
          <target state="translated">尝试执行查询,如果成功则返回true,否则返回false。</target>
        </trans-unit>
        <trans-unit id="e6f0489b14e1e492e61e5c98226d96a5ae8a905f" translate="yes" xml:space="preserve">
          <source>Tries to receive a message from the channel &lt;em&gt;c&lt;/em&gt;, but this can fail for all sort of reasons, including contention. If it fails, it returns &lt;code&gt;(false, default(msg))&lt;/code&gt; otherwise it returns &lt;code&gt;(true, msg)&lt;/code&gt;.</source>
          <target state="translated">尝试从通道&lt;em&gt;c&lt;/em&gt;接收消息，但这可能由于各种原因而失败，包括争用。如果失败，则返回 &lt;code&gt;(false, default(msg))&lt;/code&gt; 否则返回 &lt;code&gt;(true, msg)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="59e8185659254fff6635dee26e78e5d85bff42cc" translate="yes" xml:space="preserve">
          <source>Tries to reset browser state and writes &lt;em&gt;data&lt;/em&gt; to stdout in &amp;lt;plaintext&amp;gt; tag.</source>
          <target state="translated">尝试重置浏览器状态并将&lt;em&gt;数据&lt;/em&gt;写入&amp;lt;plaintext&amp;gt;标记中的stdout。</target>
        </trans-unit>
        <trans-unit id="1d1f450205803ed460a630c26002dda1d5353960" translate="yes" xml:space="preserve">
          <source>Tries to send a message to a thread. &lt;em&gt;msg&lt;/em&gt; is deeply copied. Doesn't block. Returns &lt;em&gt;false&lt;/em&gt; if the message was not sent because number of pending items in the channel exceeded &lt;em&gt;maxItems&lt;/em&gt;.</source>
          <target state="translated">尝试将消息发送到线程。&lt;em&gt;味精&lt;/em&gt;被深深复制。不会阻止。如果由于通道中的未决项目数超过&lt;em&gt;maxItems&lt;/em&gt;而未发送消息，则返回&lt;em&gt;false&lt;/em&gt;。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="8c7db82aabe0ec4b37ab6dba207f6dfa98f250d7" translate="yes" xml:space="preserve">
          <source>Trigger event &lt;code&gt;ev&lt;/code&gt;.</source>
          <target state="translated">触发事件 &lt;code&gt;ev&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6a3c207482b9595dc0f6457a13d2f1e61c56e381" translate="yes" xml:space="preserve">
          <source>Trim trailing zeros from a formatted floating point value (&lt;em&gt;x&lt;/em&gt;). Modifies the passed value.</source>
          <target state="translated">从格式化的浮点值（&lt;em&gt;x&lt;/em&gt;）修剪尾随零。修改传递的值。</target>
        </trans-unit>
        <trans-unit id="afddc6dcc2da91db52e6db34c078cda6ecf5a529" translate="yes" xml:space="preserve">
          <source>Triple quoted string literals</source>
          <target state="translated">三引号的字符串文字</target>
        </trans-unit>
        <trans-unit id="245ceee2586082dc5a73679c70b42d08a85510ee" translate="yes" xml:space="preserve">
          <source>Truncates &lt;em&gt;x&lt;/em&gt; to the decimal point</source>
          <target state="translated">将&lt;em&gt;x&lt;/em&gt;截断到小数点</target>
        </trans-unit>
        <trans-unit id="02715c4b7ff15274f4612905c77b4bda81876e45" translate="yes" xml:space="preserve">
          <source>Try can also be used as an expression; the type of the &lt;code&gt;try&lt;/code&gt; branch then needs to fit the types of &lt;code&gt;except&lt;/code&gt; branches, but the type of the &lt;code&gt;finally&lt;/code&gt; branch always has to be &lt;code&gt;void&lt;/code&gt;:</source>
          <target state="translated">try也可以用作表达式；然后， &lt;code&gt;try&lt;/code&gt; 分支的类型需要适合 &lt;code&gt;except&lt;/code&gt; 分支的类型，但是 &lt;code&gt;finally&lt;/code&gt; 分支的类型必须始终为 &lt;code&gt;void&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="a7af062d7b75f8335dbdc49667ebc20f3bbd46f5" translate="yes" xml:space="preserve">
          <source>Try expression</source>
          <target state="translated">尝试表达</target>
        </trans-unit>
        <trans-unit id="f526bd18e3a74520efcc9c43abfaeabfe401e20b" translate="yes" xml:space="preserve">
          <source>Try statement</source>
          <target state="translated">试试声明</target>
        </trans-unit>
        <trans-unit id="8fb959bb7d8da3f5b1a99088eb043845c557941e" translate="yes" xml:space="preserve">
          <source>Tuple or object scope</source>
          <target state="translated">元组或对象范围</target>
        </trans-unit>
        <trans-unit id="3f99aa09c1ddebfc55f57b61f023038ddf8cd672" translate="yes" xml:space="preserve">
          <source>Tuple unpacking</source>
          <target state="translated">元组拆包</target>
        </trans-unit>
        <trans-unit id="538a8ce3fbdcaee00a14353bd57bcf3600c6e0d0" translate="yes" xml:space="preserve">
          <source>Tuples</source>
          <target state="translated">Tuples</target>
        </trans-unit>
        <trans-unit id="b3e2bebd3f6bc134f276b0e73ccd708819d73bd3" translate="yes" xml:space="preserve">
          <source>Tuples and object types</source>
          <target state="translated">图元组和对象类型</target>
        </trans-unit>
        <trans-unit id="4591fb7e2e6af521b3d77017031f788c69e63561" translate="yes" xml:space="preserve">
          <source>Tuples can be &lt;em&gt;unpacked&lt;/em&gt; during variable assignment (and only then!). This can be handy to assign directly the fields of the tuples to individually named variables. An example of this is the &lt;a href=&quot;os#splitFile&quot;&gt;splitFile&lt;/a&gt; proc from the &lt;a href=&quot;os&quot;&gt;os module&lt;/a&gt; which returns the directory, name and extension of a path at the same time. For tuple unpacking to work you must use parentheses around the values you want to assign the unpacking to, otherwise you will be assigning the same value to all the individual variables! For example:</source>
          <target state="translated">元组可以在变量赋值期间&lt;em&gt;解包&lt;/em&gt;（只有这样！）。将元组的字段直接分配给单独命名的变量可能很方便。一个示例是&lt;a href=&quot;os&quot;&gt;os模块中&lt;/a&gt;的&lt;a href=&quot;os#splitFile&quot;&gt;splitFile&lt;/a&gt; proc，它同时返回路径的目录，名称和扩展名。为了使元组拆包正常工作，必须在要为其分配拆包的值周围使用括号，否则，您将为所有单个变量分配相同的值！例如：</target>
        </trans-unit>
        <trans-unit id="8352a113514bb2d5c1a998e7f4b0ab2c15a44826" translate="yes" xml:space="preserve">
          <source>Tuples which are longer than one line should indent their parameters to align with the parameters above it.</source>
          <target state="translated">长于一行的图元组应将其参数缩进,以便与上面的参数对齐。</target>
        </trans-unit>
        <trans-unit id="9b346e4953356d44049c162bd3c503c985bc5b32" translate="yes" xml:space="preserve">
          <source>Turn a deque into its string representation.</source>
          <target state="translated">将一个deque变成其字符串表示。</target>
        </trans-unit>
        <trans-unit id="8743e385990daa129ed7fd77c0aab253383cfcf0" translate="yes" xml:space="preserve">
          <source>Turn a rational number into a string.</source>
          <target state="translated">把一个有理数变成一个字符串。</target>
        </trans-unit>
        <trans-unit id="6530f1075ffd79f7adf57fbf48c454fea802b4a4" translate="yes" xml:space="preserve">
          <source>Turning the &lt;code&gt;log&lt;/code&gt; proc into a template solves this problem:</source>
          <target state="translated">将 &lt;code&gt;log&lt;/code&gt; proc转换为模板可以解决此问题：</target>
        </trans-unit>
        <trans-unit id="8bcf0ab5d7d983b90173092de9a62442f37e633f" translate="yes" xml:space="preserve">
          <source>Turns a regular function call into an invocation of the JavaScript's &lt;em&gt;new&lt;/em&gt; operator</source>
          <target state="translated">将常规函数调用转换为对JavaScript &lt;em&gt;新&lt;/em&gt;操作符的调用</target>
        </trans-unit>
        <trans-unit id="fd4a9c5e9fbeb1731e11e217df10a5e9df4c2462" translate="yes" xml:space="preserve">
          <source>Turns off runtime checks and turns on the optimizer.</source>
          <target state="translated">关闭运行时检查,打开优化器。</target>
        </trans-unit>
        <trans-unit id="8f84b7302f8b2c0acedd7493fcbdb678ea820d7e" translate="yes" xml:space="preserve">
          <source>Turns the code generation for all runtime checks on or off.</source>
          <target state="translated">打开或关闭所有运行时检查的代码生成。</target>
        </trans-unit>
        <trans-unit id="8359c50c168a0d32c1676689b7b9be53909574c9" translate="yes" xml:space="preserve">
          <source>Turns the code generation for array bound checks on or off.</source>
          <target state="translated">打开或关闭数组绑定检查的代码生成。</target>
        </trans-unit>
        <trans-unit id="78de984f73e6a96b608abf84f509342b6416676c" translate="yes" xml:space="preserve">
          <source>Turns the code generation for assertions on or off.</source>
          <target state="translated">打开或关闭断言的代码生成。</target>
        </trans-unit>
        <trans-unit id="f85728da201c7e87406c7977edcd7efb848370e2" translate="yes" xml:space="preserve">
          <source>Turns the code generation for nil pointer checks on or off.</source>
          <target state="translated">打开或关闭零指针检查的代码生成。</target>
        </trans-unit>
        <trans-unit id="7443a6fe5c166cf5312e85d734da57674e23a9ea" translate="yes" xml:space="preserve">
          <source>Turns the code generation for over- or underflow checks on or off.</source>
          <target state="translated">打开或关闭溢出或欠流检查的代码生成。</target>
        </trans-unit>
        <trans-unit id="634d9e7817c9bcc8bdbbd8305a699f04a3c9ba2f" translate="yes" xml:space="preserve">
          <source>Turns the hint messages of the compiler on or off.</source>
          <target state="translated">打开或关闭编译器的提示信息。</target>
        </trans-unit>
        <trans-unit id="96dcbf296f2f4c34221163dd4a790e8efb28f099" translate="yes" xml:space="preserve">
          <source>Turns the term rewriting templates/macros on or off.</source>
          <target state="translated">开启或关闭术语重写模板/宏。</target>
        </trans-unit>
        <trans-unit id="f31cc462c8ec7105eb07e2c1b5bb943c21db3b4d" translate="yes" xml:space="preserve">
          <source>Turns the warning messages of the compiler on or off.</source>
          <target state="translated">打开或关闭编译器的警告信息。</target>
        </trans-unit>
        <trans-unit id="2701a94c0eb55cbd958a87dff3e959673ff1bf53" translate="yes" xml:space="preserve">
          <source>Tutorial</source>
          <target state="translated">Tutorial</target>
        </trans-unit>
        <trans-unit id="779de5f9680bb0a0d05277f00d89d734c054b346" translate="yes" xml:space="preserve">
          <source>Tutorial (part I)</source>
          <target state="translated">教程(第一部分)</target>
        </trans-unit>
        <trans-unit id="e8a76eed53f23547280f2ddf6517628c83064326" translate="yes" xml:space="preserve">
          <source>Tutorial (part II)</source>
          <target state="translated">教程(第二部分)</target>
        </trans-unit>
        <trans-unit id="e5778f261d1733e81971ab8e088ac48fafe7c0eb" translate="yes" xml:space="preserve">
          <source>Tweaking the GC</source>
          <target state="translated">调整GC</target>
        </trans-unit>
        <trans-unit id="778080b9d6142ab857443b50014ddb8d3ccd44e2" translate="yes" xml:space="preserve">
          <source>Two &lt;code&gt;Timezone&lt;/code&gt;'s are considered equal if their name is equal.</source>
          <target state="translated">如果两个 &lt;code&gt;Timezone&lt;/code&gt; 的名称相等，则认为它们相等。</target>
        </trans-unit>
        <trans-unit id="6a865c6e91cc1b9c8041b930bdded2be0556b0e5" translate="yes" xml:space="preserve">
          <source>Two identifiers are considered equal if the following algorithm returns true:</source>
          <target state="translated">如果以下算法返回真,则认为两个标识符相等。</target>
        </trans-unit>
        <trans-unit id="6298e080874877d7a98b594edb938f20831dfff6" translate="yes" xml:space="preserve">
          <source>Two spaces should be used for indentation of blocks; tabstops are not allowed (the compiler enforces this). Using spaces means that the appearance of code is more consistent across editors. Unlike spaces, tabstop width varies across editors, and not all editors provide means of changing this width.</source>
          <target state="translated">块的缩进应该使用两个空格;不允许使用tabstops(编译器强制执行)。使用空格意味着代码的外观在不同的编辑器中更加一致。与空格不同的是,tabstop的宽度在不同的编辑器中是不同的,而且不是所有的编辑器都提供了改变这个宽度的方法。</target>
        </trans-unit>
        <trans-unit id="3deb7456519697ecf4eefc455516c969a3681bae" translate="yes" xml:space="preserve">
          <source>Type</source>
          <target state="translated">Type</target>
        </trans-unit>
        <trans-unit id="1e4286f84aa2ec1726d2f29d48fef0c9bf605e85" translate="yes" xml:space="preserve">
          <source>Type Classes</source>
          <target state="translated">类型类</target>
        </trans-unit>
        <trans-unit id="5e1573953474c6c0a25673b1f064154b46a8a93e" translate="yes" xml:space="preserve">
          <source>Type Conversion</source>
          <target state="translated">类型转换</target>
        </trans-unit>
        <trans-unit id="c0eb387e477546545eec601f050672bd06c02038" translate="yes" xml:space="preserve">
          <source>Type Suffix</source>
          <target state="translated">类型后缀</target>
        </trans-unit>
        <trans-unit id="517963ffe8430bed0d4f132dcd51c0d4eb3001b7" translate="yes" xml:space="preserve">
          <source>Type bound operations</source>
          <target state="translated">类型约束操作</target>
        </trans-unit>
        <trans-unit id="b2ce942200cd4ed497c93d87123ffa3584d50070" translate="yes" xml:space="preserve">
          <source>Type casts</source>
          <target state="translated">铸型</target>
        </trans-unit>
        <trans-unit id="bf3e880739673e946c25d0dedcde2653a7c48216" translate="yes" xml:space="preserve">
          <source>Type casts are a crude mechanism to interpret the bit pattern of an expression as if it would be of another type. Type casts are only needed for low-level programming and are inherently unsafe.</source>
          <target state="translated">类型转换是一种粗略的机制,用来解释一个表达式的位模式,好像它是另一种类型。类型转换只需要在低级编程中使用,而且本质上是不安全的。</target>
        </trans-unit>
        <trans-unit id="f21eb352df05ecea6a3a588dc0c8590e21dbccc2" translate="yes" xml:space="preserve">
          <source>Type classes can be combined using the standard boolean operators to form more complex type classes:</source>
          <target state="translated">类型类可以使用标准的布尔运算符组合成更复杂的类型类。</target>
        </trans-unit>
        <trans-unit id="08d7f20ec3a1f2c32685f21a24578ef7bfd33afb" translate="yes" xml:space="preserve">
          <source>Type conversions</source>
          <target state="translated">类型转换</target>
        </trans-unit>
        <trans-unit id="7893cb518df1f3e86b37b8f2c89bf262fddc71ea" translate="yes" xml:space="preserve">
          <source>Type conversions are a much more polite way to convert a type into another: They preserve the abstract &lt;em&gt;value&lt;/em&gt;, not necessarily the &lt;em&gt;bit-pattern&lt;/em&gt;. If a type conversion is not possible, the compiler complains or an exception is raised.</source>
          <target state="translated">类型转换是一种将类型转换为另一种的更为礼貌的方式：它们保留抽象&lt;em&gt;值&lt;/em&gt;，而不必保留&lt;em&gt;位模式&lt;/em&gt;。如果无法进行类型转换，则编译器会抱怨或引发异常。</target>
        </trans-unit>
        <trans-unit id="d227e4926b1f493d28e95f292386e3a242d08693" translate="yes" xml:space="preserve">
          <source>Type conversions are compile-time computable.</source>
          <target state="translated">类型转换是编译时可计算的。</target>
        </trans-unit>
        <trans-unit id="705eb0947010d2f2d419bb724e3d94cb8a2e7780" translate="yes" xml:space="preserve">
          <source>Type equality</source>
          <target state="translated">平等类型</target>
        </trans-unit>
        <trans-unit id="ad5ad7af6975f8633efeb665458c5b9ad70586b8" translate="yes" xml:space="preserve">
          <source>Type equality modulo type distinction</source>
          <target state="translated">类型平等模数类型区分</target>
        </trans-unit>
        <trans-unit id="c5a4537d409bc84d0e6885dd98224efa069a4125" translate="yes" xml:space="preserve">
          <source>Type identifiers should be in PascalCase. All other identifiers should be in camelCase with the exception of constants which &lt;strong&gt;may&lt;/strong&gt; use PascalCase but are not required to.</source>
          <target state="translated">类型标识符应在PascalCase中。所有其他标识符都应位于camelCase中，但&lt;strong&gt;可以&lt;/strong&gt;使用PascalCase但并非必需的常量除外。</target>
        </trans-unit>
        <trans-unit id="0f50bbe8baba25a1929146d13b1d95279794e199" translate="yes" xml:space="preserve">
          <source>Type of the symbol. This can be &lt;code&gt;skProc&lt;/code&gt;, &lt;code&gt;skLet&lt;/code&gt;, and just about any of the enums defined in the module &lt;code&gt;compiler/ast.nim&lt;/code&gt;.</source>
          <target state="translated">符号的类型。这可以是 &lt;code&gt;skProc&lt;/code&gt; ， &lt;code&gt;skLet&lt;/code&gt; ，以及几乎任何在模块 &lt;code&gt;compiler/ast.nim&lt;/code&gt; 定义的枚举。</target>
        </trans-unit>
        <trans-unit id="cbabd93da3123882a924672c6250533f840354ef" translate="yes" xml:space="preserve">
          <source>Type relations</source>
          <target state="translated">类型关系</target>
        </trans-unit>
        <trans-unit id="f8b2d40508694dd4577a697d9c6b4c5f2e3511da" translate="yes" xml:space="preserve">
          <source>Type section</source>
          <target state="translated">类型部分</target>
        </trans-unit>
        <trans-unit id="19ed3f78d17ddb423376e5e7d24d9be0086053f6" translate="yes" xml:space="preserve">
          <source>Type sections</source>
          <target state="translated">栏目类型</target>
        </trans-unit>
        <trans-unit id="a919a22549142ebb39423637cf5e8cc1b5dc6cbb" translate="yes" xml:space="preserve">
          <source>Type that describes &quot;standard format specifiers&quot;.</source>
          <target state="translated">描述 &quot;标准格式规定者 &quot;的类型。</target>
        </trans-unit>
        <trans-unit id="33ed1febf2dc93666a9e94d3bca2653e2f2eba89" translate="yes" xml:space="preserve">
          <source>Type/signature. For variables and enums this will contain the type of the symbol, for procs, methods and templates this will contain the full unique signature (e.g. &lt;code&gt;proc (File)&lt;/code&gt;).</source>
          <target state="translated">类型/签名。对于变量和枚举，它将包含符号的类型；对于procs，方法和模板，它将包含完整的唯一签名（例如 &lt;code&gt;proc (File)&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="5204c9867a362caf0bea9525b902dfe2dc066c0b" translate="yes" xml:space="preserve">
          <source>Typed future.</source>
          <target state="translated">键入未来。</target>
        </trans-unit>
        <trans-unit id="a1cf3d18ff7e16dcb6cdb495e43f6f5c061a5575" translate="yes" xml:space="preserve">
          <source>Typed vs untyped parameters</source>
          <target state="translated">类型参数与非类型参数</target>
        </trans-unit>
        <trans-unit id="93b9e289e2842469d001eccf7ad5d79f3c302dc9" translate="yes" xml:space="preserve">
          <source>Types</source>
          <target state="translated">Types</target>
        </trans-unit>
        <trans-unit id="5720ec6d00feb96f366d8679918ecb98f50f66f7" translate="yes" xml:space="preserve">
          <source>UDP is a connectionless protocol, so UDP sockets don't have to explicitly call the &lt;code&gt;connect&lt;/code&gt; procedure. They can simply start sending data immediately.</source>
          <target state="translated">UDP是无连接协议，因此UDP套接字不必显式调用 &lt;code&gt;connect&lt;/code&gt; 过程。他们可以简单地立即开始发送数据。</target>
        </trans-unit>
        <trans-unit id="9248393d371f6ac0d6c435085d705c597add4700" translate="yes" xml:space="preserve">
          <source>UNIX domain socket.</source>
          <target state="translated">UNIX域套接字。</target>
        </trans-unit>
        <trans-unit id="5994d61577cd9a76d59a20c617c73875837d1477" translate="yes" xml:space="preserve">
          <source>UNIX specific</source>
          <target state="translated">UNIX专用</target>
        </trans-unit>
        <trans-unit id="d9b8776f6733aef4d62e2f6de4be839fb81aa572" translate="yes" xml:space="preserve">
          <source>Unary &lt;em&gt;+&lt;/em&gt; operator for an integer. Has no effect.</source>
          <target state="translated">一元&lt;em&gt;+&lt;/em&gt;运算符，用于整数。没有效果。</target>
        </trans-unit>
        <trans-unit id="eb73268790c9b1bb4d1863a2400ec7e0bd4b9f82" translate="yes" xml:space="preserve">
          <source>Unary &lt;em&gt;-&lt;/em&gt; operator for an integer. Negates &lt;em&gt;x&lt;/em&gt;.</source>
          <target state="translated">一元运算符&lt;em&gt;-&lt;/em&gt;整数运算符。取反&lt;em&gt;x&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="70afc8908f864590618bb835ddbe12b01425b489" translate="yes" xml:space="preserve">
          <source>Unary minus for complex numbers.</source>
          <target state="translated">复数的单数减法。</target>
        </trans-unit>
        <trans-unit id="2b26f2db358e2b9c8ee6c1ec77a16447b17be07f" translate="yes" xml:space="preserve">
          <source>Unary minus for rational numbers.</source>
          <target state="translated">有理数的单利减法。</target>
        </trans-unit>
        <trans-unit id="26886835eb6cc81330ad426b552f908727e34bfa" translate="yes" xml:space="preserve">
          <source>Unary operators always bind stronger than any binary operator: &lt;code&gt;$a + b&lt;/code&gt; is &lt;code&gt;($a) + b&lt;/code&gt; and not &lt;code&gt;$(a + b)&lt;/code&gt;.</source>
          <target state="translated">一元运算符的绑定总是强于任何二元运算符： &lt;code&gt;$a + b&lt;/code&gt; 是 &lt;code&gt;($a) + b&lt;/code&gt; 而不是 &lt;code&gt;$(a + b)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="15caf31c9aaa57bf878b33c847d4e21c87bdd599" translate="yes" xml:space="preserve">
          <source>Unbound static params will be inferred from expressions involving the &lt;em&gt;==&lt;/em&gt; operator and also when types dependent on them are being matched:</source>
          <target state="translated">未绑定的静态参数将从涉及&lt;em&gt;==&lt;/em&gt;运算符的表达式以及与它们依赖的类型匹配时进行推断：</target>
        </trans-unit>
        <trans-unit id="3eb24ca63e88421d2f543a770d935d8deff96d75" translate="yes" xml:space="preserve">
          <source>Unbound types can appear both as params to calls such as &lt;em&gt;s.push(T)&lt;/em&gt; and on the right-hand side of the &lt;code&gt;is&lt;/code&gt; operator in cases such as &lt;em&gt;x.pop is T&lt;/em&gt; and &lt;em&gt;x.data is seq[T]&lt;/em&gt;.</source>
          <target state="translated">在&lt;em&gt;x.pop为T&lt;/em&gt;而&lt;em&gt;x.data为seq [T]的&lt;/em&gt;情况下，未绑定类型既可以作为&lt;em&gt;s.push（T）之类的&lt;/em&gt;调用的参数，也可以作为 &lt;code&gt;is&lt;/code&gt; 运算符的右侧出现。&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a277ebe87b91b0033079926c198a2b95dd5a89ed" translate="yes" xml:space="preserve">
          <source>Unchecked pragma</source>
          <target state="translated">未选中的原则</target>
        </trans-unit>
        <trans-unit id="780b27a9e0cd026ae3df440893ad4cc13c021cef" translate="yes" xml:space="preserve">
          <source>Under Windows, &lt;code&gt;ShellExecute&lt;/code&gt; is used. Under Mac OS X the &lt;code&gt;open&lt;/code&gt; command is used. Under Unix, it is checked if &lt;code&gt;xdg-open&lt;/code&gt; exists and used if it does. Otherwise the environment variable &lt;code&gt;BROWSER&lt;/code&gt; is used to determine the default browser to use.</source>
          <target state="translated">在Windows下，使用 &lt;code&gt;ShellExecute&lt;/code&gt; 。在Mac OS X下，使用 &lt;code&gt;open&lt;/code&gt; 命令。在Unix下，检查 &lt;code&gt;xdg-open&lt;/code&gt; 是否存在，如果存在则使用xdg-open。否则，环境变量 &lt;code&gt;BROWSER&lt;/code&gt; 用于确定要使用的默认浏览器。</target>
        </trans-unit>
        <trans-unit id="edbf8b89716eab57348a639af00765efe9e3f101" translate="yes" xml:space="preserve">
          <source>Underflow: operation produces a result that is too small to be represented as a normal number, for example, MINDOUBLE * MINDOUBLE.</source>
          <target state="translated">下溢:操作产生的结果太小,无法用普通数表示,例如:MINDOUBLE*MINDOUBLE。</target>
        </trans-unit>
        <trans-unit id="9ec38b8f74e8905e6cb3c56b8e4d8603f3e7c7d9" translate="yes" xml:space="preserve">
          <source>Unescapes a string &lt;em&gt;s&lt;/em&gt;.</source>
          <target state="translated">取消转义字符串&lt;em&gt;s&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="e2b681f3dab8eeb99f700c878d07af066931b521" translate="yes" xml:space="preserve">
          <source>Unfortunately optimizations are hard to get right and even the tiny example is &lt;strong&gt;wrong&lt;/strong&gt;:</source>
          <target state="translated">不幸的是，优化很难实现，甚至很小的例子也是&lt;strong&gt;错误的&lt;/strong&gt;：</target>
        </trans-unit>
        <trans-unit id="979fe2a9e37e36b1d1a6a4517ab5b601b5d48fdb" translate="yes" xml:space="preserve">
          <source>Unfortunately the semantics of the try statement may not always be correct, and occasionally the compilation may fail altogether. As such it is better to use the former style when possible.</source>
          <target state="translated">遗憾的是,try语句的语义可能并不总是正确的,偶尔编译也可能完全失败。因此,在可能的情况下,最好使用前一种风格。</target>
        </trans-unit>
        <trans-unit id="fab317435de1ae8699f1bac973f0926492ea1744" translate="yes" xml:space="preserve">
          <source>Unfortunately, &lt;code&gt;d + 12.Dollar&lt;/code&gt; is not allowed either, because &lt;code&gt;+&lt;/code&gt; is defined for &lt;code&gt;int&lt;/code&gt; (among others), not for &lt;code&gt;Dollar&lt;/code&gt;. So a &lt;code&gt;+&lt;/code&gt; for dollars needs to be defined:</source>
          <target state="translated">不幸的是， &lt;code&gt;d + 12.Dollar&lt;/code&gt; 也是不允许的，因为 &lt;code&gt;+&lt;/code&gt; 是为 &lt;code&gt;int&lt;/code&gt; （以及其他类型）而不是 &lt;code&gt;Dollar&lt;/code&gt; 定义的。因此，需要定义美元的 &lt;code&gt;+&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="257828b764d9609e93e07a012bbe1f755b3e4143" translate="yes" xml:space="preserve">
          <source>Unicast link-local address.</source>
          <target state="translated">单播链接本地地址。</target>
        </trans-unit>
        <trans-unit id="db89ced902c1b469d3ee6d37350cad15573da1b7" translate="yes" xml:space="preserve">
          <source>Unicast site-local address.</source>
          <target state="translated">单播站点本地地址。</target>
        </trans-unit>
        <trans-unit id="20432d22d5eb062ea9c2106c1c80aefa6d897164" translate="yes" xml:space="preserve">
          <source>Unindents each line in &lt;code&gt;s&lt;/code&gt; by &lt;code&gt;count&lt;/code&gt; amount of &lt;code&gt;padding&lt;/code&gt;.</source>
          <target state="translated">Unindents在每一行 &lt;code&gt;s&lt;/code&gt; 通过 &lt;code&gt;count&lt;/code&gt; 的量 &lt;code&gt;padding&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="924d62607597504901be1ad3edea9517a5c76a1f" translate="yes" xml:space="preserve">
          <source>Union pragma</source>
          <target state="translated">联盟原则</target>
        </trans-unit>
        <trans-unit id="9fa0003b8a6b26c8afe5d3f50a8127082e93fdb8" translate="yes" xml:space="preserve">
          <source>Unknown file type.</source>
          <target state="translated">文件类型不明。</target>
        </trans-unit>
        <trans-unit id="60d54b69a2b42e57628182cdd2fb4ccd4dc4e49e" translate="yes" xml:space="preserve">
          <source>Unless marked with the &lt;em&gt;{.pure.}&lt;/em&gt; pragma, members of enums should have an identifying prefix, such as an abbreviation of the enum's name.</source>
          <target state="translated">除非用&lt;em&gt;{.pure。}实用程序&lt;/em&gt;标记，否则枚举成员应具有标识前缀，例如枚举名称的缩写。</target>
        </trans-unit>
        <trans-unit id="7d1db02d8fefccbf077d86e2884c344faded7045" translate="yes" xml:space="preserve">
          <source>Unless you explicitly use the &lt;code&gt;-o:filename.js&lt;/code&gt; switch as mentioned in the previous examples, the compiler will create a &lt;code&gt;filename.js&lt;/code&gt; file in the &lt;code&gt;nimcache&lt;/code&gt; directory using the name of your input nim file. There are no other temporary files generated, the output is always a single self contained &lt;code&gt;.js&lt;/code&gt; file.</source>
          <target state="translated">除非您如先前示例中所述显式使用 &lt;code&gt;-o:filename.js&lt;/code&gt; 开关，否则编译器将使用输入nim文件的名称在 &lt;code&gt;nimcache&lt;/code&gt; 目录中创建 &lt;code&gt;filename.js&lt;/code&gt; 文件。没有其他临时文件生成，输出始终是一个自包含的 &lt;code&gt;.js&lt;/code&gt; 文件。</target>
        </trans-unit>
        <trans-unit id="555ac3aebe10e2203997f49b6308860e82f3cf38" translate="yes" xml:space="preserve">
          <source>Unless your application has very specific requirements and solely targets JavaScript, you should be using the relevant functions in the &lt;code&gt;math&lt;/code&gt;, &lt;code&gt;json&lt;/code&gt;, and &lt;code&gt;times&lt;/code&gt; stdlib modules instead.</source>
          <target state="translated">除非您的应用程序有非常特定的要求，并且仅针对JavaScript，否则您应该在 &lt;code&gt;math&lt;/code&gt; ， &lt;code&gt;json&lt;/code&gt; 和 &lt;code&gt;times&lt;/code&gt; stdlib模块中使用相关功能。</target>
        </trans-unit>
        <trans-unit id="0c8a103bee5df59c3c762061b4c9d13541d1ab2e" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;read&lt;/code&gt;, this function will not raise an exception if the Future has not been finished.</source>
          <target state="translated">与 &lt;code&gt;read&lt;/code&gt; 不同，如果Future未完成，则此函数不会引发异常。</target>
        </trans-unit>
        <trans-unit id="86d3c06510e1a9b072a372d11ed5099a19477622" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;sockets.recvLine&lt;/code&gt; this function will raise an EOS or ESSL exception if an error occurs.</source>
          <target state="translated">与 &lt;code&gt;sockets.recvLine&lt;/code&gt; 不同，如果发生错误，此函数将引发EOS或ESSL异常。</target>
        </trans-unit>
        <trans-unit id="e750c92c37341f3392054d626734256f8a0787c9" translate="yes" xml:space="preserve">
          <source>Unlike &lt;span id=&quot;argc_1&quot;&gt;argc&lt;/span&gt; in C, if your binary was called without parameters this will return zero. You can query each individual paramater with &lt;a href=&quot;#paramStr&quot;&gt;paramStr()&lt;/a&gt; or retrieve all of them in one go with &lt;a href=&quot;#commandLineParams&quot;&gt;commandLineParams()&lt;/a&gt;.</source>
          <target state="translated">与C中的&lt;span id=&quot;argc_1&quot;&gt;argc&lt;/span&gt;不同，如果不使用参数调用二进制文件，则它将返回零。您可以使用&lt;a href=&quot;#paramStr&quot;&gt;paramStr（）&lt;/a&gt;查询每个参数，也可以使用&lt;a href=&quot;#commandLineParams&quot;&gt;commandLineParams（）&lt;/a&gt;一次性检索所有参数。</target>
        </trans-unit>
        <trans-unit id="834e7e344f224920e087953eb402fca07a2f1f3c" translate="yes" xml:space="preserve">
          <source>Unlike other IO operations this is guaranteed to be thread-safe as &lt;code&gt;echo&lt;/code&gt; is very often used for debugging convenience. If you want to use &lt;code&gt;echo&lt;/code&gt; inside a &lt;a href=&quot;manual#pragmas-nosideeffect-pragma&quot;&gt;proc without side effects&lt;/a&gt; you can use &lt;a href=&quot;#debugEcho&quot;&gt;debugEcho&lt;/a&gt; instead.</source>
          <target state="translated">与其他IO操作不同，这保证了线程安全，因为 &lt;code&gt;echo&lt;/code&gt; 经常用于调试方便。如果要在&lt;a href=&quot;manual#pragmas-nosideeffect-pragma&quot;&gt;proc&lt;/a&gt;内部使用 &lt;code&gt;echo&lt;/code&gt; 而没有副作用，则可以改用&lt;a href=&quot;#debugEcho&quot;&gt;debugEcho&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="22870d2d3c9ed068f87598a420f675c1914b8e0c" translate="yes" xml:space="preserve">
          <source>Unlike the &lt;em&gt;proc&lt;/em&gt; version, the predicate needs to be an expression using the &lt;code&gt;it&lt;/code&gt; variable for testing, like: &lt;code&gt;filterIt(&quot;abcxyz&quot;, it == 'x')&lt;/code&gt;.</source>
          <target state="translated">与&lt;em&gt;proc&lt;/em&gt;版本不同，谓词必须是使用 &lt;code&gt;it&lt;/code&gt; 变量进行测试的表达式，例如： &lt;code&gt;filterIt(&quot;abcxyz&quot;, it == 'x')&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7abf83a8fb810b07df5666c0186be330c1d74dbb" translate="yes" xml:space="preserve">
          <source>Unlike the &lt;em&gt;proc&lt;/em&gt; version, the predicate needs to be an expression using the &lt;code&gt;it&lt;/code&gt; variable for testing, like: &lt;code&gt;keepItIf(&quot;abcxyz&quot;, it == 'x')&lt;/code&gt;.</source>
          <target state="translated">与&lt;em&gt;proc&lt;/em&gt;版本不同，谓词必须是使用 &lt;code&gt;it&lt;/code&gt; 变量进行测试的表达式，例如： &lt;code&gt;keepItIf(&quot;abcxyz&quot;, it == 'x')&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e21aec3b4730e3f9365e0105b5ee932445d7a6ca" translate="yes" xml:space="preserve">
          <source>Unmarshalling JSON into a type</source>
          <target state="translated">将JSON解读为一个类型。</target>
        </trans-unit>
        <trans-unit id="274fd6abb97e41f164eb1ef8fe9181521b3bcfb9" translate="yes" xml:space="preserve">
          <source>Unregisters &lt;code&gt;fd&lt;/code&gt;.</source>
          <target state="translated">注销 &lt;code&gt;fd&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cc5d6ca9aa56c6378bdd4192beb1a23d43d8436b" translate="yes" xml:space="preserve">
          <source>Unregisters deleg &lt;code&gt;deleg&lt;/code&gt; from dispatcher &lt;code&gt;d&lt;/code&gt;.</source>
          <target state="translated">从调度程序 &lt;code&gt;d&lt;/code&gt; 注销deleg &lt;code&gt;deleg&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="da32f8ccff4f9629c24e55368ee80c187804e943" translate="yes" xml:space="preserve">
          <source>Unregisters event &lt;code&gt;ev&lt;/code&gt;.</source>
          <target state="translated">注销事件 &lt;code&gt;ev&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fcde071a887a5fe31b2a030c3e5fa7b13b8951b5" translate="yes" xml:space="preserve">
          <source>Unregisters file/socket descriptor &lt;code&gt;fd&lt;/code&gt; from selector &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">从选择器 &lt;code&gt;s&lt;/code&gt; 注销文件/套接字描述符 &lt;code&gt;fd&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="289ac9aad529193af73566b90baf875386cf6586" translate="yes" xml:space="preserve">
          <source>Unregisters user-defined event &lt;code&gt;ev&lt;/code&gt; from selector &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">从选择器 &lt;code&gt;s&lt;/code&gt; 注销用户定义的事件 &lt;code&gt;ev&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ce62d653fe1244a4a172cf34cf9ff901d873cb95" translate="yes" xml:space="preserve">
          <source>Unsigned operations all wrap around; they cannot lead to over- or under-flow errors.</source>
          <target state="translated">无符号操作都是环绕的,它们不能导致过流或欠流错误。</target>
        </trans-unit>
        <trans-unit id="793e97a099a191f13d3623cc72e9fcc4ea98314f" translate="yes" xml:space="preserve">
          <source>Unspecified address.</source>
          <target state="translated">地址不详。</target>
        </trans-unit>
        <trans-unit id="c2eed1f531c71d473a16fbfc4bdc992980d7fde4" translate="yes" xml:space="preserve">
          <source>Untyped future.</source>
          <target state="translated">无型的未来。</target>
        </trans-unit>
        <trans-unit id="338a06f904b267724d0e4a6607e91229e8bd5122" translate="yes" xml:space="preserve">
          <source>Unused symbols in the code.</source>
          <target state="translated">代码中未使用的符号。</target>
        </trans-unit>
        <trans-unit id="b761e5e6e2982b87d1d1ce7451421af2e056fcdd" translate="yes" xml:space="preserve">
          <source>Update file/socket descriptor &lt;code&gt;fd&lt;/code&gt;, registered in selector &lt;code&gt;s&lt;/code&gt; with new events set &lt;code&gt;event&lt;/code&gt;.</source>
          <target state="translated">使用新事件集 &lt;code&gt;event&lt;/code&gt; 更新在选择器 &lt;code&gt;s&lt;/code&gt; 中注册的文件/套接字描述符 &lt;code&gt;fd&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="90ac74192ba332a2e96c10e6e3a98aa5ef90a38c" translate="yes" xml:space="preserve">
          <source>Uploading a new file</source>
          <target state="translated">上传新文件</target>
        </trans-unit>
        <trans-unit id="8437e83622dcd6616eee43bc0f900abcc44066bc" translate="yes" xml:space="preserve">
          <source>Uploads &lt;code&gt;file&lt;/code&gt; to &lt;code&gt;dest&lt;/code&gt; on the remote FTP server. Usage of this function asynchronously is recommended to view the progress of the download. The &lt;code&gt;EvStore&lt;/code&gt; event is passed to the specified &lt;code&gt;handleEvent&lt;/code&gt; function when the upload is finished, and the &lt;code&gt;filename&lt;/code&gt; field will be equal to &lt;code&gt;file&lt;/code&gt;.</source>
          <target state="translated">将 &lt;code&gt;file&lt;/code&gt; 上传到远程FTP服务器上的 &lt;code&gt;dest&lt;/code&gt; 。建议异步使用此功能以查看下载进度。该 &lt;code&gt;EvStore&lt;/code&gt; 事件被传递到指定 &lt;code&gt;handleEvent&lt;/code&gt; 功能，当上传完成后，和 &lt;code&gt;filename&lt;/code&gt; 现场将等于 &lt;code&gt;file&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="37b7ab0e221278f7b19c0e2120c647473f14e9c5" translate="yes" xml:space="preserve">
          <source>Usage of &lt;code&gt;shallow&lt;/code&gt; is always safe once you know the string won't be modified anymore, similar to Ruby's &lt;span id=&quot;freeze_1&quot;&gt;freeze&lt;/span&gt;.</source>
          <target state="translated">一旦您知道不再修改字符串，就象使用Ruby的&lt;span id=&quot;freeze_1&quot;&gt;freeze一样&lt;/span&gt;，使用 &lt;code&gt;shallow&lt;/code&gt; 始终是安全的。&lt;span id=&quot;freeze_1&quot;&gt;&lt;/span&gt;</target>
        </trans-unit>
        <trans-unit id="861a0e430ffac5e4ae6e11b7a947f2c32d388cf4" translate="yes" xml:space="preserve">
          <source>Usage:</source>
          <target state="translated">Usage:</target>
        </trans-unit>
        <trans-unit id="e50c56f66708798022fbc1f1eb983ee9aeeb0b23" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;#init,HashSet%5BA%5D,int&quot;&gt;init()&lt;/a&gt; or &lt;a href=&quot;#initSet&quot;&gt;initSet[type]()&lt;/a&gt; before calling other procs on it.</source>
          <target state="translated">在调用其他&lt;a href=&quot;#initSet&quot;&gt;proc&lt;/a&gt;之前，请使用&lt;a href=&quot;#init,HashSet%5BA%5D,int&quot;&gt;init（）&lt;/a&gt;或initSet [type]（）。</target>
        </trans-unit>
        <trans-unit id="c1b9c2cf3847d0d4137fb09319498c7a48280b4c" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;#init,OrderedSet%5BA%5D,int&quot;&gt;init()&lt;/a&gt; or &lt;a href=&quot;#initOrderedSet&quot;&gt;initOrderedSet[type]()&lt;/a&gt; before calling other procs on it.</source>
          <target state="translated">在调用其他&lt;a href=&quot;#initOrderedSet&quot;&gt;proc&lt;/a&gt;之前，请使用&lt;a href=&quot;#init,OrderedSet%5BA%5D,int&quot;&gt;init（）&lt;/a&gt;或initOrderedSet [type]（）。</target>
        </trans-unit>
        <trans-unit id="069c6a70b51730b216fe49517948e5c25ee3f68d" translate="yes" xml:space="preserve">
          <source>Use CamelCase, not underscored_identifiers.</source>
          <target state="translated">使用CamelCase,而不是undcored_identifiers。</target>
        </trans-unit>
        <trans-unit id="c0419552b8b43316dc697b19a811e19aebbdcdf2" translate="yes" xml:space="preserve">
          <source>Use a proc when possible, only using the more powerful facilities of macros, templates, iterators, and converters when necessary.</source>
          <target state="translated">尽可能的使用proc,只有在必要的时候才使用宏、模板、迭代器和转换器等更强大的设施。</target>
        </trans-unit>
        <trans-unit id="ee29cb81b4a1c27e3913f57892fcf63971ad6672" translate="yes" xml:space="preserve">
          <source>Use a space after a colon, but not before it.</source>
          <target state="translated">在冒号后使用空格,但不能在冒号前使用。</target>
        </trans-unit>
        <trans-unit id="6eaeb50702c4af6019f309c53108d48c5e121d67" translate="yes" xml:space="preserve">
          <source>Use an ordinary proc/iterator, if possible.</source>
          <target state="translated">如果可能的话,使用普通的proc/iterator。</target>
        </trans-unit>
        <trans-unit id="18016a67bd4f948da9845d49f07cb8371b4ab483" translate="yes" xml:space="preserve">
          <source>Use setjmp backend.</source>
          <target state="translated">使用setjmp后台。</target>
        </trans-unit>
        <trans-unit id="f72ae5e3053e46a037835089c157a676efe9253b" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;let&lt;/code&gt; statement (not the &lt;code&gt;var&lt;/code&gt; statement) when declaring variables that do not change within their scope. Using the &lt;code&gt;let&lt;/code&gt; statement ensures that variables remain immutable, and gives those who read the code a better idea of the code's purpose.</source>
          <target state="translated">声明在其范围内不变的变量时，请使用 &lt;code&gt;let&lt;/code&gt; 语句（而不是 &lt;code&gt;var&lt;/code&gt; 语句）。使用 &lt;code&gt;let&lt;/code&gt; 语句可确保变量保持不变，并使阅读代码的人更好地了解代码的用途。</target>
        </trans-unit>
        <trans-unit id="66274d10986776dc87f06f202d0f3cb8c3fe3937" translate="yes" xml:space="preserve">
          <source>Use the linenoise library for interactive mode (not needed on Windows).</source>
          <target state="translated">使用linenoise库来实现交互模式(在Windows上不需要)。</target>
        </trans-unit>
        <trans-unit id="fa6549bd6999bce5cb0be51276ff5b08c60300d9" translate="yes" xml:space="preserve">
          <source>Use this if you want to use asyncio's dispatcher.</source>
          <target state="translated">如果你想使用asyncio的调度器,请使用这个。</target>
        </trans-unit>
        <trans-unit id="fc79ccd7635f50d22e57841cdbe2adc22f78a697" translate="yes" xml:space="preserve">
          <source>Use this overload if one of the enums specified above does not contain what you need.</source>
          <target state="translated">如果上面指定的一个枚举没有包含你需要的内容,请使用这个重载。</target>
        </trans-unit>
        <trans-unit id="865aa831216ca96d4d105c4dd19b7daa3f190a58" translate="yes" xml:space="preserve">
          <source>Use this proc to determine quickly if a 'spawn' or a direct call is preferable. If it returns 'true' a 'spawn' may make sense. In general it is not necessary to call this directly; use 'spawnX' instead.</source>
          <target state="translated">使用此 proc 快速确定是使用'产卵'还是直接调用比较好。如果它返回'true','产卵'可能是有意义的。一般来说,没有必要直接调用这个程序,可以使用'spawnX'代替。</target>
        </trans-unit>
        <trans-unit id="61bc2b4499c7c25fe666bf75531910175755c00e" translate="yes" xml:space="preserve">
          <source>Use uClibc instead of libc. (Relevant for Unix-like OSes)</source>
          <target state="translated">用uClibc代替libc。(适用于类Unix操作系统)</target>
        </trans-unit>
        <trans-unit id="5f211d2e480794537e3020e2cfb5c46539ca8d42" translate="yes" xml:space="preserve">
          <source>Use ucontext backend.</source>
          <target state="translated">使用ucontext后台。</target>
        </trans-unit>
        <trans-unit id="9e128770cbe82e55e9551991395c199aea047021" translate="yes" xml:space="preserve">
          <source>Used by &lt;code&gt;asynchttpserver&lt;/code&gt; and &lt;code&gt;httpclient&lt;/code&gt; internally and should not be used by you.</source>
          <target state="translated">由 &lt;code&gt;asynchttpserver&lt;/code&gt; 和 &lt;code&gt;httpclient&lt;/code&gt; 在内部使用，您不应使用。</target>
        </trans-unit>
        <trans-unit id="ff8732bc6e9c0c3e17ad4cc39e7b18e2c8e01853" translate="yes" xml:space="preserve">
          <source>Used in scanp for the matching of atoms (usually chars).</source>
          <target state="translated">在scanp中用于匹配原子(通常是字符)。</target>
        </trans-unit>
        <trans-unit id="b02c3c02a1cba6f1b623a143ee4ff49577aeda10" translate="yes" xml:space="preserve">
          <source>Useful if performing parallel analysis of data series and need to re-combine parallel result sets</source>
          <target state="translated">如果对数据序列进行并行分析,并需要重新梳理并行结果集,则非常有用。</target>
        </trans-unit>
        <trans-unit id="d51e8109e780dfdf6a418dbd0475739d284873d7" translate="yes" xml:space="preserve">
          <source>Useful when creating a closure in a loop to capture local loop variables by their current iteration values. Example:</source>
          <target state="translated">当在循环中创建闭环时很有用,可以通过当前的迭代值捕获局部循环变量。例子:</target>
        </trans-unit>
        <trans-unit id="9f8a2389a20ca0752aa9e95093515517e90e194c" translate="yes" xml:space="preserve">
          <source>User</source>
          <target state="translated">User</target>
        </trans-unit>
        <trans-unit id="e62ab5dd60dc7797b971e6696b18be2c527a419c" translate="yes" xml:space="preserve">
          <source>User definable matchers</source>
          <target state="translated">用户可定义匹配器</target>
        </trans-unit>
        <trans-unit id="cdb81abb7fd49094ec59b4c3147077b637691ca6" translate="yes" xml:space="preserve">
          <source>User defined matcher. Uses the proc &lt;code&gt;foo&lt;/code&gt; to perform the match. See below for more details.</source>
          <target state="translated">用户定义的匹配器。使用proc &lt;code&gt;foo&lt;/code&gt; 进行匹配。请参阅下面的更多细节。</target>
        </trans-unit>
        <trans-unit id="b935fbc2614493a2c4b14ccf26901cbcb010eb56" translate="yes" xml:space="preserve">
          <source>User defined operators are allowed. Nothing stops you from defining your own &lt;code&gt;@!?+~&lt;/code&gt; operator, but doing so may reduce readability.</source>
          <target state="translated">允许用户定义运算符。没有什么可以阻止您定义自己的 &lt;code&gt;@!?+~&lt;/code&gt; 运算符，但是这样做可能会降低可读性。</target>
        </trans-unit>
        <trans-unit id="fa8f45c91aea8077d8fc0d06a397a16ed0dc1c79" translate="yes" xml:space="preserve">
          <source>User-defined generic types may also be covariant with respect to some of their parameters. By default, all generic params are considered invariant, but you may choose the apply the prefix modifier &lt;code&gt;in&lt;/code&gt; to a parameter to make it contravariant or &lt;code&gt;out&lt;/code&gt; to make it covariant:</source>
          <target state="translated">用户定义的通用类型在某些参数上也可能是协变的。默认情况下，所有通用PARAMS被认为是不变的，但你可以选择适用的前缀修饰 &lt;code&gt;in&lt;/code&gt; 一个参数，使其逆变或 &lt;code&gt;out&lt;/code&gt; ，使之协变：</target>
        </trans-unit>
        <trans-unit id="cce325aeace53a2b93d052357d730389323d4341" translate="yes" xml:space="preserve">
          <source>UserRaw</source>
          <target state="translated">UserRaw</target>
        </trans-unit>
        <trans-unit id="e300487a9b9ba07551dbd02395ad2f5ceb2cd7ff" translate="yes" xml:space="preserve">
          <source>Uses &lt;em&gt;default&lt;/em&gt; for an invalid value in &lt;em&gt;s&lt;/em&gt;. The comparison is done in a style insensitive way.</source>
          <target state="translated">对&lt;em&gt;s中&lt;/em&gt;的无效值使用&lt;em&gt;default&lt;/em&gt;。比较是通过对样式不敏感的方式完成的。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="91247aefaea76611ed3be253ec73d5452247797e" translate="yes" xml:space="preserve">
          <source>Uses the state to compute a new &lt;code&gt;uint64&lt;/code&gt; random number.</source>
          <target state="translated">使用状态来计算新的 &lt;code&gt;uint64&lt;/code&gt; 随机数。</target>
        </trans-unit>
        <trans-unit id="82312a15160a4eb2e934bf4a7bfbfafc8e93262e" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;from math as m import pow&lt;/code&gt; works identically to the &lt;code&gt;as&lt;/code&gt; modifier with the &lt;code&gt;import&lt;/code&gt; statement, but wrapped in &lt;code&gt;nnkFromStmt&lt;/code&gt;.</source>
          <target state="translated">使用 &lt;code&gt;from math as m import pow&lt;/code&gt; 与使用 &lt;code&gt;import&lt;/code&gt; 语句的 &lt;code&gt;as&lt;/code&gt; 修饰符相同，但包装在 &lt;code&gt;nnkFromStmt&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="434eb8681f8aae0fc0009510a5ce82ae4ac62f77" translate="yes" xml:space="preserve">
          <source>Using HTTP POST</source>
          <target state="translated">使用HTTP POST</target>
        </trans-unit>
        <trans-unit id="597d5caf1abedf8be885d6b02a498c8313c21cab" translate="yes" xml:space="preserve">
          <source>Using an &lt;code&gt;enum&lt;/code&gt; is similar to using an &lt;code&gt;object&lt;/code&gt;.</source>
          <target state="translated">使用 &lt;code&gt;enum&lt;/code&gt; 类似于使用 &lt;code&gt;object&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6d2077b1edc67aa09ddf48ed8fc866598362c96a" translate="yes" xml:space="preserve">
          <source>Using statement</source>
          <target state="translated">使用声明</target>
        </trans-unit>
        <trans-unit id="9c0ffb656f43cb27f5cdd45b79d0245f11508098" translate="yes" xml:space="preserve">
          <source>Usually the result of using the &lt;a href=&quot;#assert&quot;&gt;assert() template&lt;/a&gt;.</source>
          <target state="translated">通常是使用&lt;a href=&quot;#assert&quot;&gt;assert（）模板的结果&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c8b613dc5bf77d7eebd40398bbfcda8a848bcf8f" translate="yes" xml:space="preserve">
          <source>Usually to pass a block of code to a template the parameter that accepts the block needs to be of type &lt;code&gt;untyped&lt;/code&gt;. Because symbol lookups are then delayed until template instantiation time:</source>
          <target state="translated">通常，要将代码块传递给模板，接受代码块的参数必须是 &lt;code&gt;untyped&lt;/code&gt; 类型。因为符号查找随后会延迟到模板实例化时间：</target>
        </trans-unit>
        <trans-unit id="8dce170de238b1feda2ecd9674ea3ca0d068fbcb" translate="yes" xml:space="preserve">
          <source>Value</source>
          <target state="translated">Value</target>
        </trans-unit>
        <trans-unit id="94caea3c7c64ca00d9ac21ea83a77703d0e697ae" translate="yes" xml:space="preserve">
          <source>Var parameters</source>
          <target state="translated">变量参数</target>
        </trans-unit>
        <trans-unit id="f94fe3891ba9b2a70b6f7c93dcf19ff406473182" translate="yes" xml:space="preserve">
          <source>Var return type</source>
          <target state="translated">变量返回类型</target>
        </trans-unit>
        <trans-unit id="ed0b2dfd47bbac896a3b7fa7c65e08461b5b0de0" translate="yes" xml:space="preserve">
          <source>Var section</source>
          <target state="translated">Var部分</target>
        </trans-unit>
        <trans-unit id="914863c14c6479013852278b1f8b3334db12b752" translate="yes" xml:space="preserve">
          <source>Var statement</source>
          <target state="translated">Var statement</target>
        </trans-unit>
        <trans-unit id="add491eaab149ea45f6c1fe0151b0684f58a9169" translate="yes" xml:space="preserve">
          <source>Var statements declare new local and global variables and initialize them. A comma separated list of variables can be used to specify variables of the same type:</source>
          <target state="translated">Var 语句声明新的局部和全局变量并初始化它们。可以使用逗号分隔的变量列表来指定相同类型的变量。</target>
        </trans-unit>
        <trans-unit id="2a8aad770addffb7c9ee321a2ae20d74343b6752" translate="yes" xml:space="preserve">
          <source>Varargs</source>
          <target state="translated">Varargs</target>
        </trans-unit>
        <trans-unit id="7d9fcf6d5d84f212e746c0dd60f0871afacbb237" translate="yes" xml:space="preserve">
          <source>Varargs matching</source>
          <target state="translated">Varargs匹配</target>
        </trans-unit>
        <trans-unit id="1e1a470ac65b2238b82d8d8713eb8a548a3249ba" translate="yes" xml:space="preserve">
          <source>Varargs of untyped</source>
          <target state="translated">无类型的 Varargs</target>
        </trans-unit>
        <trans-unit id="77559312e7c433e8e5ee29c1bb6cbeca9a08ec04" translate="yes" xml:space="preserve">
          <source>Varargs pragma</source>
          <target state="translated">Varargs pragma</target>
        </trans-unit>
        <trans-unit id="805fa97816cdbe137bc65aece5e19b6969589e6d" translate="yes" xml:space="preserve">
          <source>Variables can also be reordered as well. Variables that are &lt;em&gt;initialized&lt;/em&gt; (i.e. variables that have their declaration and assignment combined in a single statement) can have their entire initialization statement reordered. Be wary of what code is executed at the top level:</source>
          <target state="translated">变量也可以重新排序。这是变量&lt;em&gt;初始化&lt;/em&gt;可以有自己的整个初始化语句重新排序（即有他们的声明和分配组合在一个声明中即变量）。警惕在顶层执行什么代码：</target>
        </trans-unit>
        <trans-unit id="f285e0b395df604d798c7e2bb2b23e2eae4f1e8f" translate="yes" xml:space="preserve">
          <source>Variant of &lt;code&gt;recvFrom&lt;/code&gt; for non-blocking sockets. Unlike &lt;code&gt;recvFrom&lt;/code&gt;, this function will raise an EOS error whenever a socket error occurs.</source>
          <target state="translated">&lt;code&gt;recvFrom&lt;/code&gt; 的变体，用于非阻塞套接字。与 &lt;code&gt;recvFrom&lt;/code&gt; 不同，此函数将在发生套接字错误时引发EOS错误。</target>
        </trans-unit>
        <trans-unit id="37a9cbeb25f6e324f126507ad323389964644919" translate="yes" xml:space="preserve">
          <source>Variant of select with only a read and write list.</source>
          <target state="translated">select的变体,只有一个读写列表。</target>
        </trans-unit>
        <trans-unit id="b9069e323599df5d27b7c9d2e68cb81566e2b60e" translate="yes" xml:space="preserve">
          <source>Vars</source>
          <target state="translated">Vars</target>
        </trans-unit>
        <trans-unit id="c0e92bae9fcb6a7281bd801df9748260bc15749f" translate="yes" xml:space="preserve">
          <source>Verbatim string match for back reference.</source>
          <target state="translated">逐字逐句的字符串匹配,供后面参考。</target>
        </trans-unit>
        <trans-unit id="be6cf59698ac3aaae8c44d3c15b6e3e4cda4c5a2" translate="yes" xml:space="preserve">
          <source>Verbatim string match: Use this to override a global &lt;code&gt;\i&lt;/code&gt; or &lt;code&gt;\y&lt;/code&gt; modifier.</source>
          <target state="translated">逐字字符串匹配：使用此选项可以覆盖全局 &lt;code&gt;\i&lt;/code&gt; 或 &lt;code&gt;\y&lt;/code&gt; 修饰符。</target>
        </trans-unit>
        <trans-unit id="f0f86f02d25018ae2892b7bd1afddf0b541788d2" translate="yes" xml:space="preserve">
          <source>Verbosity levels</source>
          <target state="translated">口语水平</target>
        </trans-unit>
        <trans-unit id="c12b4e999b16e9b02d25b9fcdd67d4fd655e16ae" translate="yes" xml:space="preserve">
          <source>Verify if a statement or a list of statements is true. A helpful error message and set checkpoints are printed out on failure (if &lt;code&gt;outputLevel&lt;/code&gt; is not &lt;code&gt;PRINT_NONE&lt;/code&gt;). Example:</source>
          <target state="translated">验证语句或语句列表是否为真。失败时会打印出有用的错误消息和设置的检查点（如果 &lt;code&gt;outputLevel&lt;/code&gt; 不是 &lt;code&gt;PRINT_NONE&lt;/code&gt; ）。例：</target>
        </trans-unit>
        <trans-unit id="bf92590226e4f935af31645efa1ac42d722021ca" translate="yes" xml:space="preserve">
          <source>Version of &lt;code&gt;getTypeImpl&lt;/code&gt; which takes a &lt;code&gt;typedesc&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;getTypeImpl&lt;/code&gt; 的版本，它带有 &lt;code&gt;typedesc&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="57aa9247bf27c4880a6334aaec93af41db7006d4" translate="yes" xml:space="preserve">
          <source>Version of &lt;code&gt;getTypeInst&lt;/code&gt; which takes a &lt;code&gt;typedesc&lt;/code&gt;.</source>
          <target state="translated">采用 &lt;code&gt;typedesc&lt;/code&gt; 的 &lt;code&gt;getTypeInst&lt;/code&gt; 的版本。</target>
        </trans-unit>
        <trans-unit id="858b1e6c9eca4cf7c78fcd8fab9318b40196ab03" translate="yes" xml:space="preserve">
          <source>Viceversa, one can also use &lt;code&gt;#assumendef SYMBOL&lt;/code&gt; to declare that &lt;code&gt;SYMBOL&lt;/code&gt; should be considered not defined, and hence skip &lt;code&gt;#ifdef SYMBOL&lt;/code&gt; sections.</source>
          <target state="translated">反之亦然，还可以使用 &lt;code&gt;#assumendef SYMBOL&lt;/code&gt; 来声明 &lt;code&gt;SYMBOL&lt;/code&gt; 应被视为没有定义，因此跳过 &lt;code&gt;#ifdef SYMBOL&lt;/code&gt; 部分。</target>
        </trans-unit>
        <trans-unit id="f9b4a6297c88554060939c3b1d4cb2536eb7bee3" translate="yes" xml:space="preserve">
          <source>Void context</source>
          <target state="translated">虚无背景</target>
        </trans-unit>
        <trans-unit id="e8f5359cab08d3573121923f7436c0f33fc92629" translate="yes" xml:space="preserve">
          <source>Void type</source>
          <target state="translated">虚空型</target>
        </trans-unit>
        <trans-unit id="962f34b2afbbced77fbbf76af036107dbe53ad9d" translate="yes" xml:space="preserve">
          <source>Volatile pragma</source>
          <target state="translated">挥发性原则</target>
        </trans-unit>
        <trans-unit id="a1c74f4c3dc47b71577d22318b41d7984b1abbb7" translate="yes" xml:space="preserve">
          <source>Waiting for a subprocess to finish. A subprocess can be started, but right now it can't be waited on, which sort of makes subprocesses a bit hard to use</source>
          <target state="translated">等待一个子进程完成。子进程可以启动,但现在不能等待,这也算是让子进程有点难受吧</target>
        </trans-unit>
        <trans-unit id="e74d0d5b2aa91ca4f2eda490c658dd7df90ccca2" translate="yes" xml:space="preserve">
          <source>Waits for completion events and processes them. Raises &lt;code&gt;ValueError&lt;/code&gt; if there are no pending operations. In contrast to &lt;code&gt;poll&lt;/code&gt; this processes as many events as are available.</source>
          <target state="translated">等待完成事件并处理它们。如果没有挂起的操作，则引发 &lt;code&gt;ValueError&lt;/code&gt; 。与 &lt;code&gt;poll&lt;/code&gt; 相反，此过程将处理尽可能多的事件。</target>
        </trans-unit>
        <trans-unit id="8c6c37027d7f2e6c6ab4b80a9728bdfd41e4de6e" translate="yes" xml:space="preserve">
          <source>Waits for completion events and processes them. Raises &lt;code&gt;ValueError&lt;/code&gt; if there are no pending operations. This runs the underlying OS &lt;span id=&quot;epoll_1&quot;&gt;epoll&lt;/span&gt; or &lt;span id=&quot;kqueue_1&quot;&gt;kqueue&lt;/span&gt; primitive only once.</source>
          <target state="translated">等待完成事件并处理它们。如果没有挂起的操作，则引发 &lt;code&gt;ValueError&lt;/code&gt; 。这仅会运行基础OS &lt;span id=&quot;epoll_1&quot;&gt;epoll&lt;/span&gt;或&lt;span id=&quot;kqueue_1&quot;&gt;kqueue&lt;/span&gt;原语一次。</target>
        </trans-unit>
        <trans-unit id="7309ba8763f2cd6a0b2e52be4a1bdf5400867492" translate="yes" xml:space="preserve">
          <source>Waits for events registered in selector &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">等待在选择器 &lt;code&gt;s&lt;/code&gt; 中注册的事件。</target>
        </trans-unit>
        <trans-unit id="a009040341eedf69627aff9b5c29bf4b8425403d" translate="yes" xml:space="preserve">
          <source>Walking is recursive. &lt;em&gt;filters&lt;/em&gt; controls the behaviour of the iterator:</source>
          <target state="translated">步行是递归的。&lt;em&gt;过滤器&lt;/em&gt;控制迭代器的行为：</target>
        </trans-unit>
        <trans-unit id="8fd311d8cb591a6fc0622efcf10ea3ea470116f2" translate="yes" xml:space="preserve">
          <source>Walks over all parent directories of a given &lt;em&gt;path&lt;/em&gt;</source>
          <target state="translated">遍历给定&lt;em&gt;路径的&lt;/em&gt;所有父目录&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1f61ac580a8669e5f5ddb85827db56efd269d4d4" translate="yes" xml:space="preserve">
          <source>Warning: This function may block. Especially on directories with many files, because a full list of file names must be retrieved.</source>
          <target state="translated">警告:这个功能可能会被阻塞。特别是对于有很多文件的目录,因为必须检索完整的文件名列表。</target>
        </trans-unit>
        <trans-unit id="99a2a483409f9e01cee9aa93831fe0f06d054b92" translate="yes" xml:space="preserve">
          <source>Warning: This really transforms the 'for' and unrolls the loop. The current implementation also has a bug that affects symbol binding in the loop body.</source>
          <target state="translated">警告:这真的是改变了 &quot;for &quot;并展开了循环。这实际上是转换了 &quot;for &quot;并展开了循环。目前的实现还有一个影响循环体中符号绑定的bug。</target>
        </trans-unit>
        <trans-unit id="7412166e831c66d50243ea6b997febce22e1c0db" translate="yes" xml:space="preserve">
          <source>Warning: URL-encoded and Unicode attempts at directory traversal are not detected. Triple dot is not handled.</source>
          <target state="translated">警告:未检测到URL编码和Unicode的目录遍历尝试。未检测到URL编码和Unicode的目录遍历尝试。不处理三点符号。</target>
        </trans-unit>
        <trans-unit id="f0e0c14f084e128be516580f7f46caa6b881111d" translate="yes" xml:space="preserve">
          <source>We already know the type information as a graph in the compiler. Thus we need to serialize this graph as RTTI for C code generation. Look at the file &lt;code&gt;lib/system/hti.nim&lt;/code&gt; for more information.</source>
          <target state="translated">我们已经知道类型信息是编译器中的图形。因此，我们需要将此图序列化为RTTI以生成C代码。查看文件 &lt;code&gt;lib/system/hti.nim&lt;/code&gt; 以获得更多信息。</target>
        </trans-unit>
        <trans-unit id="7b2d825d8ef9b527c8f3ffcca749e04b73530ffc" translate="yes" xml:space="preserve">
          <source>We cache generic instantiations and need to ensure this caching works well with the incremental compilation feature. Since the cache is attached to the &lt;code&gt;PSym&lt;/code&gt; datastructure, it should work without any special logic.</source>
          <target state="translated">我们缓存通用实例化，并且需要确保此缓存与增量编译功能一起正常工作。由于缓存是附加到 &lt;code&gt;PSym&lt;/code&gt; 数据结构的，因此它应该可以在没有任何特殊逻辑的情况下工作。</target>
        </trans-unit>
        <trans-unit id="7bf6af0d4d4b7bb7491ad339f0cd6b4eecccde3c" translate="yes" xml:space="preserve">
          <source>We call a proc &lt;code&gt;p&lt;/code&gt;&lt;span id=&quot;gc-safe_1&quot;&gt;GC safe&lt;/span&gt; when it doesn't access any global variable that contains GC'ed memory (&lt;code&gt;string&lt;/code&gt;, &lt;code&gt;seq&lt;/code&gt;, &lt;code&gt;ref&lt;/code&gt; or a closure) either directly or indirectly through a call to a GC unsafe proc.</source>
          <target state="translated">当proc &lt;code&gt;p&lt;/code&gt; &lt;span id=&quot;gc-safe_1&quot;&gt;GC&lt;/span&gt;不能通过调用GC不安全proc来直接或间接访问包含&lt;span id=&quot;gc-safe_1&quot;&gt;GC&lt;/span&gt;内存（ &lt;code&gt;string&lt;/code&gt; ， &lt;code&gt;seq&lt;/code&gt; ， &lt;code&gt;ref&lt;/code&gt; 或闭包）的任何全局变量时，将其称为安全。</target>
        </trans-unit>
        <trans-unit id="ba455d231bded2509ebd8f9d1e8763309c843c4f" translate="yes" xml:space="preserve">
          <source>We can &quot;replay&quot; &lt;code&gt;stCode.add&lt;/code&gt; only if the values of &lt;code&gt;st&lt;/code&gt; and &lt;code&gt;apicall&lt;/code&gt; are known. And even then a hash table's &lt;code&gt;add&lt;/code&gt; with its hashing mechanism is too hard to replay.</source>
          <target state="translated">仅当知道 &lt;code&gt;st&lt;/code&gt; 和 &lt;code&gt;apicall&lt;/code&gt; 的值时，我们才能&amp;ldquo;重播&amp;rdquo; &lt;code&gt;stCode.add&lt;/code&gt; 。即使这样，哈希表的 &lt;code&gt;add&lt;/code&gt; 及其哈希机制仍然很难重放。</target>
        </trans-unit>
        <trans-unit id="f6c15cc4bcae38711205717122d00cbaec2e62f3" translate="yes" xml:space="preserve">
          <source>We can achieve this using the &lt;code&gt;bindMethod&lt;/code&gt; macro:</source>
          <target state="translated">我们可以使用 &lt;code&gt;bindMethod&lt;/code&gt; 宏实现此目的：</target>
        </trans-unit>
        <trans-unit id="31fc4caa6ec680ff0de718216907b6b39698fd69" translate="yes" xml:space="preserve">
          <source>We cannot duplicate 'a' if it denotes an expression that has a side effect! Fortunately Nim supports side effect analysis:</source>
          <target state="translated">如果'a'表示一个有副作用的表达式,我们就不能重复'a'! 幸运的是,Nim支持副作用分析。</target>
        </trans-unit>
        <trans-unit id="cc498265cc3ceafbd88456ff11eb0a32bb180e8f" translate="yes" xml:space="preserve">
          <source>We could get rid of nesting environments by always inlining inner anon procs. More useful is escape analysis and stack allocation of the environment, however.</source>
          <target state="translated">我们可以通过总是内联内部的anon procs来摆脱嵌套环境。然而,更有用的是环境的逃逸分析和堆栈分配。</target>
        </trans-unit>
        <trans-unit id="e11914dec9459002787db2ce90468c35fd15a6ab" translate="yes" xml:space="preserve">
          <source>We have already seen the simple &lt;code&gt;import&lt;/code&gt; statement that just imports all exported symbols. An alternative that only imports listed symbols is the &lt;code&gt;from import&lt;/code&gt; statement:</source>
          <target state="translated">我们已经看到了简单的 &lt;code&gt;import&lt;/code&gt; 语句，它仅导入所有导出的符号。仅导入列出的符号的替代方法是 &lt;code&gt;from import&lt;/code&gt; 语句：</target>
        </trans-unit>
        <trans-unit id="59c4a855c5c497242383a03a1f691a7e5a85ba0a" translate="yes" xml:space="preserve">
          <source>We have to decide at runtime whether the reference is on the stack or not. The generated code looks roughly like this:</source>
          <target state="translated">我们必须在运行时决定引用是否在栈上。生成的代码大致是这样的。</target>
        </trans-unit>
        <trans-unit id="cf92005b68f4a7df3a08d2ee2fa3d3d923557d80" translate="yes" xml:space="preserve">
          <source>We need an API that hides the complex aliasing problems by not relying on Nim's global variables. The obvious solution is to use string keys instead of global variables:</source>
          <target state="translated">我们需要一个API,通过不依赖Nim的全局变量来隐藏复杂的别名问题。显而易见的解决方案是使用字符串键来代替全局变量。</target>
        </trans-unit>
        <trans-unit id="6c36085b01e4f6e8f59835097cfb83f524dc4b57" translate="yes" xml:space="preserve">
          <source>We start the tour with a modified &quot;hello world&quot; program:</source>
          <target state="translated">我们以修改后的 &quot;hello world &quot;节目开始参观。</target>
        </trans-unit>
        <trans-unit id="41e38ed24e3a1be9264a0daea556df68c3aba5e6" translate="yes" xml:space="preserve">
          <source>We store a module's AST of a successful semantic check in a SQLite database. There are plenty of features that require a sub sequence to be re-applied, for example:</source>
          <target state="translated">我们将一个模块的成功语义检查的AST存储在SQLite数据库中。例如,有很多功能需要重新应用子序列。</target>
        </trans-unit>
        <trans-unit id="2a8ba9ee33c2a6fb270c2b9858e20ee9e6e1de37" translate="yes" xml:space="preserve">
          <source>We use a mixture of bitset and hash table for this. The hash table maps &lt;em&gt;pages&lt;/em&gt; to a page descriptor. The page descriptor contains a bit for any possible cell address within this page. So including a cell is done as follows:</source>
          <target state="translated">为此，我们使用了位集和哈希表的混合。哈希表将&lt;em&gt;页面&lt;/em&gt;映射到页面描述符。页面描述符包含该页面内任何可能的单元地址的位。因此，包含单元格的操作如下：</target>
        </trans-unit>
        <trans-unit id="aab20012d1620f5b85c5c37ea977935d4f505aea" translate="yes" xml:space="preserve">
          <source>We want to generate roughly this JavaScript:</source>
          <target state="translated">我们要生成大概这个JavaScript。</target>
        </trans-unit>
        <trans-unit id="113b69b591d6182bb037d0575303c945f53858ae" translate="yes" xml:space="preserve">
          <source>What is happening here is that the types used for table keys require to have a &lt;code&gt;hash()&lt;/code&gt; proc which will convert them to a &lt;a href=&quot;hashes#Hash&quot;&gt;Hash&lt;/a&gt; value, and the compiler is listing all the hash functions it knows. Additionally there has to be a &lt;code&gt;==&lt;/code&gt; operator that provides the same semantics as its corresponding &lt;code&gt;hash&lt;/code&gt; proc.</source>
          <target state="translated">这里发生的是，用于表键的类型需要具有 &lt;code&gt;hash()&lt;/code&gt; proc，它将把它们转换为&lt;a href=&quot;hashes#Hash&quot;&gt;Hash&lt;/a&gt;值，并且编译器将列出它知道的所有哈希函数。另外，必须有一个 &lt;code&gt;==&lt;/code&gt; 运算符，该运算符提供与其对应的 &lt;code&gt;hash&lt;/code&gt; 相同的语义。</target>
        </trans-unit>
        <trans-unit id="7366e079f6ffab6bc9ad768b8631449c4256e61f" translate="yes" xml:space="preserve">
          <source>What most programming languages call &lt;span id=&quot;methods_1&quot;&gt;methods&lt;/span&gt; or &lt;span id=&quot;functions_1&quot;&gt;functions&lt;/span&gt; are called &lt;span id=&quot;procedures_1&quot;&gt;procedures&lt;/span&gt; in Nim. A procedure declaration consists of an identifier, zero or more formal parameters, a return value type and a block of code. Formal parameters are declared as a list of identifiers separated by either comma or semicolon. A parameter is given a type by &lt;code&gt;: typename&lt;/code&gt;. The type applies to all parameters immediately before it, until either the beginning of the parameter list, a semicolon separator or an already typed parameter, is reached. The semicolon can be used to make separation of types and subsequent identifiers more distinct.</source>
          <target state="translated">在Nim中，大多数编程语言将其称为&lt;span id=&quot;methods_1&quot;&gt;方法&lt;/span&gt;或&lt;span id=&quot;functions_1&quot;&gt;函数&lt;/span&gt;的&lt;span id=&quot;procedures_1&quot;&gt;过程&lt;/span&gt;称为&lt;span id=&quot;procedures_1&quot;&gt;过程&lt;/span&gt;。过程声明由标识符，零个或多个形式参数，返回值类型和代码块组成。形式参数声明为标识符列表，以逗号或分号分隔。参数的类型为 &lt;code&gt;: typename&lt;/code&gt; 。该类型适用于紧接其之前的所有参数，直到到达参数列表的开头，分号分隔符或已经键入的参数。分号可用于使类型分离和后续标识符更加明显。</target>
        </trans-unit>
        <trans-unit id="8dcfff2350bc510e79fd004ac68bd4cb1f311382" translate="yes" xml:space="preserve">
          <source>What optimizers really need to do is a &lt;em&gt;canonicalization&lt;/em&gt;:</source>
          <target state="translated">优化器真正需要做的是&lt;em&gt;规范化&lt;/em&gt;：</target>
        </trans-unit>
        <trans-unit id="93ccfee40ae325efd18fb6ffe045c18cb229f18f" translate="yes" xml:space="preserve">
          <source>What seem to be C code generation problems is often a bug resulting from not producing prototypes, so that some types default to &lt;code&gt;cint&lt;/code&gt;. Testing without the &lt;code&gt;-w&lt;/code&gt; option helps!</source>
          <target state="translated">C代码生成问题似乎通常是由于不生成原型而导致的错误，因此某些类型默认为 &lt;code&gt;cint&lt;/code&gt; 。不带 &lt;code&gt;-w&lt;/code&gt; 选项的测试会有所帮助！</target>
        </trans-unit>
        <trans-unit id="06f4a3ec696cf15db4c5199b757938fbcc68be19" translate="yes" xml:space="preserve">
          <source>When 0 is returned the socket's connection has been closed.</source>
          <target state="translated">当返回0时,插座的连接已经关闭。</target>
        </trans-unit>
        <trans-unit id="5309ac6e6a926e840908775be647c2028a478adb" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;&quot;&quot;&lt;/code&gt; is returned the socket's connection has been closed.</source>
          <target state="translated">当 &lt;code&gt;&quot;&quot;&lt;/code&gt; 返回插座的连接已关闭。</target>
        </trans-unit>
        <trans-unit id="017a1cdbf43acad895afedf8019b709fbd1b8c09" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;T&lt;/code&gt; is a ref type then the resulting type will be &lt;code&gt;T&lt;/code&gt;, otherwise it will be &lt;code&gt;ref T&lt;/code&gt;.</source>
          <target state="translated">当 &lt;code&gt;T&lt;/code&gt; 是REF类型然后将所得的类型将是 &lt;code&gt;T&lt;/code&gt; ，否则这将是 &lt;code&gt;ref T&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a82a67761bf009b1ccc17019d024dead497b2c8c" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;importcpp&lt;/code&gt; is applied to an enum type the numerical enum values are annotated with the C++ enum type, like in this example: &lt;code&gt;((TheCppEnum)(3))&lt;/code&gt;. (This turned out to be the simplest way to implement it.)</source>
          <target state="translated">将 &lt;code&gt;importcpp&lt;/code&gt; 应用于枚举类型时，数字枚举值将使用C ++枚举类型进行注释，例如在本示例中： &lt;code&gt;((TheCppEnum)(3))&lt;/code&gt; 。（这是实现它的最简单方法。）</target>
        </trans-unit>
        <trans-unit id="46a139f37abab95c9bed1e71a37e9ff86bb1b47c" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;shortNoVal&lt;/code&gt;/&lt;code&gt;longNoVal&lt;/code&gt; are non-empty then the ':' and '=' above are still accepted, but become optional. Note that these option key sets must be updated along with the set of option keys taking no value, but keys which do take values need no special updates as their set evolves.</source>
          <target state="translated">当 &lt;code&gt;shortNoVal&lt;/code&gt; / &lt;code&gt;longNoVal&lt;/code&gt; 为非空时，上面的'：'和'='仍被接受，但变为可选。请注意，这些选项键集必须与不带任何值的选项键集一起进行更新，但是带有值的键随着其设置的演变而无需进行特殊更新。</target>
        </trans-unit>
        <trans-unit id="9c515c96ec96f99594496b1328f30048f3de0cd1" translate="yes" xml:space="preserve">
          <source>When &lt;em&gt;followSymlink&lt;/em&gt; is true, symlinks are followed and the information retrieved is information related to the symlink's target. Otherwise, information on the symlink itself is retrieved.</source>
          <target state="translated">当&lt;em&gt;followSymlink&lt;/em&gt;为true时，将遵循符号链接，并且检索到的信息是与符号链接的目标有关的信息。否则，将检索有关符号链接本身的信息。</target>
        </trans-unit>
        <trans-unit id="de4680275e7c901d5f3833c727cc99c5fb135e40" translate="yes" xml:space="preserve">
          <source>When Nim encounters an expression that cannot be resolved by the standard overload resolution rules, the current scope will be searched for a dot operator that can be matched against a re-written form of the expression, where the unknown field or proc name is passed to an &lt;code&gt;untyped&lt;/code&gt; parameter:</source>
          <target state="translated">当Nim遇到标准重载解析规则无法解析的表达式时，将在当前作用域中搜索一个点运算符，该运算符可与表达式的重写形式匹配，将未知字段或proc名称传递给该表达式一个 &lt;code&gt;untyped&lt;/code&gt; 参数：</target>
        </trans-unit>
        <trans-unit id="e2eaaa4e3170b1469cf0690081d49d1771a1d85a" translate="yes" xml:space="preserve">
          <source>When OpenSSL is dynamically linked, the wrapper provides partial forward and backward compatibility for OpenSSL versions above and below 1.1.0</source>
          <target state="translated">当OpenSSL被动态链接时,包装器为OpenSSL 1.1.0以上和1.1.0以下的版本提供了部分前向和后向兼容性。</target>
        </trans-unit>
        <trans-unit id="9ae81d2c9c4d1fafceab9a15e0a86562d3247333" translate="yes" xml:space="preserve">
          <source>When a generic type is instantiated with a type class instead of a concrete type, this results in another more specific type class:</source>
          <target state="translated">当一个通用类型用类型类而不是具体类型实例化时,就会产生另一个更具体的类型类。</target>
        </trans-unit>
        <trans-unit id="e2b7ee84914a1420903931986e31a5241d62b138" translate="yes" xml:space="preserve">
          <source>When a procedure uses the special &lt;code&gt;var&lt;/code&gt; type return variable, the result is different from that of a var section.</source>
          <target state="translated">当过程使用特殊的 &lt;code&gt;var&lt;/code&gt; 类型返回变量时，结果与var节的结果不同。</target>
        </trans-unit>
        <trans-unit id="97b4b802a770e586e56855a558c28871a136f5e3" translate="yes" xml:space="preserve">
          <source>When a request is made by a client the specified callback will be called.</source>
          <target state="translated">当客户端发出请求时,将调用指定的回调。</target>
        </trans-unit>
        <trans-unit id="c1a7a3d1dd71e0b4cf302372876e2f1c5cc12058" translate="yes" xml:space="preserve">
          <source>When a request is made to a different hostname, the current connection will be closed.</source>
          <target state="translated">当向不同的主机名发出请求时,当前连接将被关闭。</target>
        </trans-unit>
        <trans-unit id="c3a07f0075ab0a45bf34eaf52dac74c940e4d650" translate="yes" xml:space="preserve">
          <source>When a socket in &lt;code&gt;readfds&lt;/code&gt; is ready to be read from then a non-zero value will be returned specifying the count of the sockets which can be read from. The sockets which can be read from will also be removed from &lt;code&gt;readfds&lt;/code&gt;.</source>
          <target state="translated">当 &lt;code&gt;readfds&lt;/code&gt; 中的套接字准备好从中读取时，将返回一个非零值，该值指定可以读取的套接字数。可以读取的套接字也将从 &lt;code&gt;readfds&lt;/code&gt; 中删除。</target>
        </trans-unit>
        <trans-unit id="f2377e8684393b2ce892159f2a4e80c538b1e3d8" translate="yes" xml:space="preserve">
          <source>When a socket in &lt;code&gt;writefds&lt;/code&gt; is ready to be written to then a non-zero value will be returned specifying the count of the sockets which can be written to. The sockets which &lt;strong&gt;cannot&lt;/strong&gt; be written to will also be removed from &lt;code&gt;writefds&lt;/code&gt;.</source>
          <target state="translated">当 &lt;code&gt;writefds&lt;/code&gt; 中的套接字准备好被写入时，将返回一个非零值，指定可以写入的套接字数。&lt;strong&gt;无法&lt;/strong&gt;写入的套接字也将从 &lt;code&gt;writefds&lt;/code&gt; 中删除。</target>
        </trans-unit>
        <trans-unit id="43add50714f33e02f97cb791ebd99cd5319627ba" translate="yes" xml:space="preserve">
          <source>When a socket in &lt;code&gt;writefds&lt;/code&gt; is ready to be written to then a non-zero value will be returned specifying the count of the sockets which can be written to. The sockets which can be written to will also be removed from &lt;code&gt;writefds&lt;/code&gt;.</source>
          <target state="translated">当 &lt;code&gt;writefds&lt;/code&gt; 中的套接字准备好被写入时，将返回一个非零值，该值指定可以写入的套接字数。可以写入的套接字也将从 &lt;code&gt;writefds&lt;/code&gt; 中删除。</target>
        </trans-unit>
        <trans-unit id="39bcbf0203513201bce5ea953d3b4e8ffa73d031" translate="yes" xml:space="preserve">
          <source>When adding a test case to the suite it is a good idea to write a few comments about what the test is meant to verify.</source>
          <target state="translated">当把测试用例添加到套件中时,最好写一些关于测试要验证的注释。</target>
        </trans-unit>
        <trans-unit id="fc850e7757d223791640269bd02d07871233442e" translate="yes" xml:space="preserve">
          <source>When both in-place mutation and 'returns transformed copy' are available the latter is a past participle of the former:</source>
          <target state="translated">当原位突变和'返回转化副本'都可以使用时,后者是前者的过去分词。</target>
        </trans-unit>
        <trans-unit id="8d7871f40dcafcdf1db9af282909ed84f0a0d5c2" translate="yes" xml:space="preserve">
          <source>When expression</source>
          <target state="translated">当表达方式</target>
        </trans-unit>
        <trans-unit id="5390519091e9974a31ed036eaeb0253339bd37ca" translate="yes" xml:space="preserve">
          <source>When multiple type params are present, they will bind freely to different types. To force a bind-once behavior one can use an explicit generic param:</source>
          <target state="translated">当多个类型参数存在时,它们将自由地绑定到不同的类型。要强制执行绑定行为,可以使用一个显式的通用参数。</target>
        </trans-unit>
        <trans-unit id="020893f63cc1aaaba0f76060df95101dd9c22483" translate="yes" xml:space="preserve">
          <source>When naming types that come in value, pointer, and reference varieties, use a regular name for the variety that is to be used the most, and add a &quot;Obj&quot;, &quot;Ref&quot;, or &quot;Ptr&quot; suffix for the other varieties. If there is no single variety that will be used the most, add the suffixes to the pointer variants only. The same applies to C/C++ wrappers.</source>
          <target state="translated">当对有值、指针和引用品种的类型进行命名时,对使用最多的品种使用常规名称,对其他品种添加 &quot;Obj&quot;、&quot;Ref &quot;或 &quot;Ptr &quot;后缀。如果没有一个将被使用最多的品种,就只给指针变种加后缀。这同样适用于C/C++包装器。</target>
        </trans-unit>
        <trans-unit id="1225645594c00f94369b8ea3ee23053edbf83ba3" translate="yes" xml:space="preserve">
          <source>When nimvm statement</source>
          <target state="translated">当nimvm语句</target>
        </trans-unit>
        <trans-unit id="fda49f871e7ef45866bd4f710af7f4927e2c1a8d" translate="yes" xml:space="preserve">
          <source>When option values begin with ':' or '=' they need to be doubled up (as in &lt;code&gt;--delim::&lt;/code&gt;) or alternated (as in &lt;code&gt;--delim=:&lt;/code&gt;).</source>
          <target state="translated">当选项值以'：'或'='开头时，它们需要加倍（如 &lt;code&gt;--delim::&lt;/code&gt; 或交替使用（如 &lt;code&gt;--delim=:&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4bbb0504613b19518d968c26eceaaa8391745e36" translate="yes" xml:space="preserve">
          <source>When socket is non-blocking and no data is available on the socket, &lt;code&gt;-1&lt;/code&gt; will be returned and &lt;code&gt;data&lt;/code&gt; will be &lt;code&gt;&quot;&quot;&lt;/code&gt;.</source>
          <target state="translated">当套接字处于非阻塞状态并且套接字上没有可用数据时，将返回 &lt;code&gt;-1&lt;/code&gt; ,并且 &lt;code&gt;data&lt;/code&gt; 将为 &lt;code&gt;&quot;&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3c99b697aa205b3dce70845af926b4da0b0718d3" translate="yes" xml:space="preserve">
          <source>When statement</source>
          <target state="translated">当声明</target>
        </trans-unit>
        <trans-unit id="bd80507fb2abefe95238353b2a9a7cfba726d9d1" translate="yes" xml:space="preserve">
          <source>When the 'returns transformed copy' version already exists like &lt;code&gt;strutils.replace&lt;/code&gt; an in-place version should get an &lt;code&gt;-In&lt;/code&gt; suffix (&lt;code&gt;replaceIn&lt;/code&gt; for this example).</source>
          <target state="translated">当&amp;ldquo;返回转换后的副本&amp;rdquo;版本已经存在，例如 &lt;code&gt;strutils.replace&lt;/code&gt; 时，就地版本应获得 &lt;code&gt;-In&lt;/code&gt; 后缀（此示例为 &lt;code&gt;replaceIn&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="ee41ae36de358d86d21ea16751455620675ba69a" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;NimMain()&lt;/code&gt; function is called Nim initializes the garbage collector to the current thread, which is usually the main thread of your application. If your C code later spawns a different thread and calls Nim code, the garbage collector will fail to work properly and you will crash.</source>
          <target state="translated">当 &lt;code&gt;NimMain()&lt;/code&gt; 函数被调用初始化稔垃圾收集到当前线程，这通常是应用程序的主线程。如果以后您的C代码产生另一个线程并调用Nim代码，则垃圾收集器将无法正常工作，并且您将崩溃。</target>
        </trans-unit>
        <trans-unit id="daad49e43f5115581c4b76d4a507c298160c9cb2" translate="yes" xml:space="preserve">
          <source>When the concept type is matched against a concrete type, the unbound type parameters are inferred from the body of the concept in a way that closely resembles the way generic parameters of callable symbols are inferred on call sites.</source>
          <target state="translated">当概念类型与具体类型相匹配时,未绑定的类型参数是从概念主体中推断出来的,其方式与可调用符号的通用参数在调用站点上的推断方式非常相似。</target>
        </trans-unit>
        <trans-unit id="cd24854ac2b1bea3f20fcea6158974c3a2524eb3" translate="yes" xml:space="preserve">
          <source>When the designated generic parameter is used to instantiate a pointer-like type as in the case of &lt;em&gt;AnnotatedPtr&lt;/em&gt; above, the resulting generic type will also have pointer-like covariance:</source>
          <target state="translated">当使用指定的泛型参数实例化类似上述&lt;em&gt;AnnotatedPtr&lt;/em&gt;的指针类型时，所得的泛型类型也将具有类似指针的协方差：</target>
        </trans-unit>
        <trans-unit id="c835f980849f2df2e29fb8df8dab183460e5e580" translate="yes" xml:space="preserve">
          <source>When the exported symbol is another module, all of its definitions will be forwarded. You can use an &lt;code&gt;except&lt;/code&gt; list to exclude some of the symbols.</source>
          <target state="translated">当导出的符号是另一个模块时，将转发其所有定义。您可以使用 &lt;code&gt;except&lt;/code&gt; 列表来排除某些符号。</target>
        </trans-unit>
        <trans-unit id="cf92696d3f2ea1ae3634b81406709cbcffab8999" translate="yes" xml:space="preserve">
          <source>When the matched type within a concept is directly tested against a different concept, we say that the outer concept is a refinement of the inner concept and thus it is more-specific. When both concepts are matched in a call during overload resolution, Nim will assign a higher precedence to the most specific one. As an alternative way of defining concept refinements, you can use the object inheritance syntax involving the &lt;code&gt;of&lt;/code&gt; keyword:</source>
          <target state="translated">当一个概念中的匹配类型直接针对另一个概念进行测试时，我们说外部概念是内部概念的改进，因此它是更具体的。在过载解决期间的呼叫中将两个概念都匹配时，Nim将为最特定的优先级分配更高的优先级。作为定义概念优化的另一种方法，可以使用涉及关键字 &lt;code&gt;of&lt;/code&gt; 的对象继承语法：</target>
        </trans-unit>
        <trans-unit id="254e2ddbd3dd05fc683e34f1716f23a33c331fe1" translate="yes" xml:space="preserve">
          <source>When the process has finished executing, cleanup related handles.</source>
          <target state="translated">进程执行完毕后,清理相关句柄。</target>
        </trans-unit>
        <trans-unit id="efe7cb68f3a591e4c2d4dcbbc522f1614fc7e0f0" translate="yes" xml:space="preserve">
          <source>When used as a table constructor, the syntax is different.</source>
          <target state="translated">当作为表构造函数使用时,语法是不同的。</target>
        </trans-unit>
        <trans-unit id="aaaf6332aae7b182e062b2664c8075404ebd76b7" translate="yes" xml:space="preserve">
          <source>When used for matching, keep in mind that likewise scanf, no backtracking is performed.</source>
          <target state="translated">当用于匹配时,请记住,同样scanf,不进行回溯。</target>
        </trans-unit>
        <trans-unit id="5f917a7650b1a36cb2a4a1c6a6acf808f3f394e5" translate="yes" xml:space="preserve">
          <source>When used within a generic proc, a separate unique global variable will be created for each instantiation of the proc. The order of initialization of the created global variables within a module is not defined, but all of them will be initialized after any top-level variables in their originating module and before any variable in a module that imports it.</source>
          <target state="translated">当在通用proc中使用时,将为proc的每个实例创建一个单独的唯一的全局变量。模块内创建的全局变量的初始化顺序没有定义,但是所有的全局变量都将在其原模块中的任何顶层变量之后、在导入模块中的任何变量之前被初始化。</target>
        </trans-unit>
        <trans-unit id="56d07aa5bc818ad3ec9bad7f3accf7a490ff3025" translate="yes" xml:space="preserve">
          <source>When using types from C headers, add checks that compare what's in the Nim file with what's in the C header (requires a C compiler with _Static_assert support, like any C11 compiler)</source>
          <target state="translated">当使用C头中的类型时,添加检查,将Nim文件中的类型与C头中的类型进行比较(需要一个支持_Static_assert的C编译器,就像任何C11编译器一样)。</target>
        </trans-unit>
        <trans-unit id="54f14056818f81ec01f7058b5fdd03ac34cc67b2" translate="yes" xml:space="preserve">
          <source>When you are making an imported module accessible by modules that import yours, the &lt;code&gt;export&lt;/code&gt; syntax is pretty straightforward.</source>
          <target state="translated">当您使导入的模块可供导入您的模块访问的模块时， &lt;code&gt;export&lt;/code&gt; 语法非常简单。</target>
        </trans-unit>
        <trans-unit id="08835fa964ca44a302c76938b48f30469a0f0a5b" translate="yes" xml:space="preserve">
          <source>When you iterate over objects with different field types you have to use the compile time &lt;code&gt;when&lt;/code&gt; instead of a runtime &lt;code&gt;if&lt;/code&gt; to select the code you want to run for each type. To perform the comparison use the &lt;a href=&quot;manual#generics-is-operator&quot;&gt;is operator&lt;/a&gt;. Example:</source>
          <target state="translated">当您遍历具有不同字段类型的对象时， &lt;code&gt;if&lt;/code&gt; 要选择每种类型要运行的代码，则必须使用编译时间 &lt;code&gt;when&lt;/code&gt; 而不是运行时。要进行比较，请使用&lt;a href=&quot;manual#generics-is-operator&quot;&gt;is运算符&lt;/a&gt;。例：</target>
        </trans-unit>
        <trans-unit id="3c6b91dbf30c6480d506d993a62a2e5ede60b7e6" translate="yes" xml:space="preserve">
          <source>When you pass the &lt;code&gt;docSeeSrcUrl&lt;/code&gt; switch to docgen, after each documented item in your source code the hyper link &lt;em&gt;See source&lt;/em&gt; will appear pointing to the implementation of that item on a GitHub repository. You can click the link to see the implementation of the item.</source>
          <target state="translated">当您将 &lt;code&gt;docSeeSrcUrl&lt;/code&gt; 开关传递给docgen时，在源代码中每个记录的项目之后，超链接&lt;em&gt;See源&lt;/em&gt;将出现，指向GitHub存储库上该项目的实现。您可以单击链接以查看该项目的实施。</target>
        </trans-unit>
        <trans-unit id="a18a97667681fbb7bac72211a2b07123eb883bd7" translate="yes" xml:space="preserve">
          <source>When you run the &lt;code&gt;rst2html&lt;/code&gt; command, all sections in the RST document will get an anchor you can hyper link to. Usually you can guess the anchor lower casing the section title and replacing spaces with dashes, and in any case you can get it from the table of contents. But when you run the &lt;code&gt;doc&lt;/code&gt; or &lt;code&gt;doc2&lt;/code&gt; commands to generate API documentation, some symbol get one or two anchors at the same time: a numerical identifier, or a plain name plus a complex name.</source>
          <target state="translated">当您运行 &lt;code&gt;rst2html&lt;/code&gt; 命令时，RST文档中的所有部分都会获得一个锚点，您可以对其进行超链接。通常，您可以猜测锚定下部外壳的部分标题，并用破折号代替空格，无论如何，您都可以从目录中获得它。但是，当您运行 &lt;code&gt;doc&lt;/code&gt; 或 &lt;code&gt;doc2&lt;/code&gt; 命令生成API文档时，某些符号会同时获得一个或两个锚点：一个数字标识符，或者一个纯名称加一个复数名称。</target>
        </trans-unit>
        <trans-unit id="1ce4c6ad2b222c2702bd12ce14dc109cc99b9422" translate="yes" xml:space="preserve">
          <source>Whenever a user creates a specialized object, implementation of this procedure provides for &lt;code&gt;string&lt;/code&gt; representation.</source>
          <target state="translated">每当用户创建专用对象时，此过程的实现都会提供 &lt;code&gt;string&lt;/code&gt; 表示形式。</target>
        </trans-unit>
        <trans-unit id="4e4cc3bb373e7618b80ba75c42e4df4653d3d72e" translate="yes" xml:space="preserve">
          <source>Whenever you use any of these pragmas you need to integrate native code into your final binary. In the case of JavaScript this is no problem at all, the same html file which hosts the generated JavaScript will likely provide other JavaScript functions which you are importing with &lt;code&gt;importc&lt;/code&gt;.</source>
          <target state="translated">无论何时使用这些编译指示，都需要将本机代码集成到最终二进制文件中。在使用JavaScript的情况下，这完全没有问题，托管生成的JavaScript的同一个html文件可能会提供您要使用 &lt;code&gt;importc&lt;/code&gt; 导入的其他JavaScript函数。</target>
        </trans-unit>
        <trans-unit id="aeeaa58356082edb9c3248aa2f5880d152480e90" translate="yes" xml:space="preserve">
          <source>Where we are currently connected.</source>
          <target state="translated">我们目前连接的地方。</target>
        </trans-unit>
        <trans-unit id="46461b4ca7f105357f8fd52e913f10563d7fe3fd" translate="yes" xml:space="preserve">
          <source>Whether a checked runtime error results in an exception or in a fatal error at runtime is implementation specific. Thus the following program is always invalid:</source>
          <target state="translated">检查的运行时错误在运行时是导致异常还是导致致命错误是具体的实现。因此下面的程序总是无效的。</target>
        </trans-unit>
        <trans-unit id="7602811bf6ae08bd5e22293258701c16580af8be" translate="yes" xml:space="preserve">
          <source>Whether a symbol that is declared in a template is exposed to the instantiation scope is controlled by the &lt;span id=&quot;inject_1&quot;&gt;inject&lt;/span&gt; and &lt;span id=&quot;gensym_1&quot;&gt;gensym&lt;/span&gt; pragmas: gensym'ed symbols are not exposed but inject'ed are.</source>
          <target state="translated">模板中声明的符号是否暴露于实例化范围由&lt;span id=&quot;inject_1&quot;&gt;inject&lt;/span&gt;和&lt;span id=&quot;gensym_1&quot;&gt;gensym&lt;/span&gt;编译指示控制：gensym标记的符号不公开，而inject'ed符号公开。</target>
        </trans-unit>
        <trans-unit id="855714febc5eeb00b339faa0d12bd25d89659cb1" translate="yes" xml:space="preserve">
          <source>Whether an operator is used a prefix operator is also affected by preceding whitespace (this parsing change was introduced with version 0.13.0):</source>
          <target state="translated">一个操作符是否使用前缀操作符也会受到前面空格的影响(这个解析变化是在0.13.0版本中引入的)。</target>
        </trans-unit>
        <trans-unit id="6d41ff5608431c17e7d0fc23a167d921f5683a39" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;$p.name&lt;/code&gt; can also be used, the &lt;code&gt;$&lt;/code&gt; operation on a string does nothing. Note that we cannot rely on automatic conversion from an &lt;code&gt;int&lt;/code&gt; to a &lt;code&gt;string&lt;/code&gt; like we can for the &lt;code&gt;echo&lt;/code&gt; proc.</source>
          <target state="translated">虽然也可以使用 &lt;code&gt;$p.name&lt;/code&gt; ，但对字符串的 &lt;code&gt;$&lt;/code&gt; 操作无效。注意，我们不能像 &lt;code&gt;echo&lt;/code&gt; proc 那样依赖于从 &lt;code&gt;int&lt;/code&gt; 到 &lt;code&gt;string&lt;/code&gt; 自动转换。</target>
        </trans-unit>
        <trans-unit id="837197cffaa6ba949530b17e33bcba42ef50a34d" translate="yes" xml:space="preserve">
          <source>While Nim's support for object oriented programming (OOP) is minimalistic, powerful OOP techniques can be used. OOP is seen as &lt;em&gt;one&lt;/em&gt; way to design a program, not &lt;em&gt;the only&lt;/em&gt; way. Often a procedural approach leads to simpler and more efficient code. In particular, preferring composition over inheritance is often the better design.</source>
          <target state="translated">尽管Nim对面向对象编程（OOP）的支持非常简单，但可以使用强大的OOP技术。OOP被视为设计程序的&lt;em&gt;一种&lt;/em&gt;方法，而不是&lt;em&gt;唯一的&lt;/em&gt;方法。程序方法通常会导致更简单，更有效的代码。特别是，首选组合而不是继承通常是更好的设计。</target>
        </trans-unit>
        <trans-unit id="3fff640cbdad99fe09274abee24df7bbf25d0561" translate="yes" xml:space="preserve">
          <source>While at the language level a method is differentiated from others by the parameters and return value, the signature of the method returned by idetools returns also the pragmas for the method.</source>
          <target state="translated">在语言层面上,一个方法与其他方法的区别在于参数和返回值,而idetools返回的方法的签名也会返回该方法的语法。</target>
        </trans-unit>
        <trans-unit id="562bd6173e445712f1af66a953e8986ba0c2374d" translate="yes" xml:space="preserve">
          <source>While at the language level a proc is differentiated from others by the parameters and return value, the signature of the proc returned by idetools returns also the pragmas for the proc.</source>
          <target state="translated">虽然在语言层面上,一个proc与其他proc的区别在于参数和返回值,但idetools返回的proc的签名也会返回proc的pragmas。</target>
        </trans-unit>
        <trans-unit id="daec9332bd403083c7c81ec7ddda4c8cfb83913d" translate="yes" xml:space="preserve">
          <source>While macros enable advanced compile-time code transformations, they cannot change Nim's syntax. However, this is no real restriction because Nim's syntax is flexible enough anyway.</source>
          <target state="translated">虽然宏可以实现高级的编译时代码转换,但它们不能改变Nim的语法。然而,这并不是真正的限制,因为无论如何,Nim的语法已经足够灵活。</target>
        </trans-unit>
        <trans-unit id="2ec95ebb740e8da659961135df7e65656f864a68" translate="yes" xml:space="preserve">
          <source>While similar to the &lt;span id=&quot;caller-info_1&quot;&gt;caller info&lt;/span&gt; of other languages, it is determined at compile time.</source>
          <target state="translated">尽管与其他语言的&lt;span id=&quot;caller-info_1&quot;&gt;调用者信息&lt;/span&gt;类似，但它是在编译时确定的。</target>
        </trans-unit>
        <trans-unit id="ab874ba2e993f09c0db307995f9d97ec18bcd164" translate="yes" xml:space="preserve">
          <source>While statement</source>
          <target state="translated">而声明</target>
        </trans-unit>
        <trans-unit id="441460d8bae7a87fe7d9e0c8e6f1dc6c4fb048ac" translate="yes" xml:space="preserve">
          <source>Whole routines (procs, iterators etc.) can also be passed to a template or a macro via the pragma notation:</source>
          <target state="translated">整个例程(procs、迭代器等)也可以通过pragma符号传递给模板或宏。</target>
        </trans-unit>
        <trans-unit id="455cc265958fecb1e713d605b1e591a53e7b0eb7" translate="yes" xml:space="preserve">
          <source>Whole routines can also be annotated with a &lt;code&gt;locks&lt;/code&gt; pragma that takes a lock level. This then means that the routine may acquire locks of up to this level. This is essential so that procs can be called within a &lt;code&gt;locks&lt;/code&gt; section:</source>
          <target state="translated">整个例程也可以使用采用锁定级别的 &lt;code&gt;locks&lt;/code&gt; 编译注解。然后，这意味着例程可以获取高达此级别的锁。这是必不可少的，因此可以在 &lt;code&gt;locks&lt;/code&gt; 部分中调用proc ：</target>
        </trans-unit>
        <trans-unit id="34796431c4136a13fc1a272537e43a27d56433b1" translate="yes" xml:space="preserve">
          <source>Windows specific</source>
          <target state="translated">窗口专用</target>
        </trans-unit>
        <trans-unit id="f082c74fae11cd24ce038c421b38da0f7f03aa4d" translate="yes" xml:space="preserve">
          <source>Windows: this is still supported despite Windows platform not having this convention; also, both &lt;code&gt;~/&lt;/code&gt; and &lt;code&gt;~\&lt;/code&gt; are handled.</source>
          <target state="translated">Windows：尽管Windows平台没有此约定，但仍支持此功能；同样， &lt;code&gt;~/&lt;/code&gt; 和 &lt;code&gt;~\&lt;/code&gt; 都被处理。</target>
        </trans-unit>
        <trans-unit id="b10d3f7f20c0f9046a906444b8a60a2f35498a01" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;except&lt;/code&gt;, we get &lt;code&gt;nnkImportExceptStmt&lt;/code&gt;.</source>
          <target state="translated">使用 &lt;code&gt;except&lt;/code&gt; ，我们得到 &lt;code&gt;nnkImportExceptStmt&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b4974a309f4c94a4f9d5a2467682e0908cb7a682" translate="yes" xml:space="preserve">
          <source>With parenthesis and semicolons &lt;code&gt;(;)&lt;/code&gt; you can use statements where only an expression is allowed:</source>
          <target state="translated">使用括号和分号 &lt;code&gt;(;)&lt;/code&gt; ，可以在仅允许表达式的地方使用语句：</target>
        </trans-unit>
        <trans-unit id="6d171ddc79243587420ce2e420c38a86ca6d787e" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;--run&lt;/code&gt;&lt;a href=&quot;nimc#compiler-usage-command-line-switches&quot;&gt;switch&lt;/a&gt; Nim executes the file automatically after compilation. You can give your program command line arguments by appending them after the filename:</source>
          <target state="translated">Nim 使用 &lt;code&gt;--run&lt;/code&gt; &lt;a href=&quot;nimc#compiler-usage-command-line-switches&quot;&gt;开关&lt;/a&gt;在编译后自动执行文件。您可以通过在文件名后附加参数来给程序命令行参数：</target>
        </trans-unit>
        <trans-unit id="4cd482d4d9faa3aac000c3242487f0f59daaef12" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;dynlib&lt;/code&gt; pragma a procedure can also be exported to a dynamic library. The pragma then has no argument and has to be used in conjunction with the &lt;code&gt;exportc&lt;/code&gt; pragma:</source>
          <target state="translated">使用 &lt;code&gt;dynlib&lt;/code&gt; 编译指示，也可以将过程导出到动态库。然后，该编译指示没有参数，必须与 &lt;code&gt;exportc&lt;/code&gt; 编译指示一起使用：</target>
        </trans-unit>
        <trans-unit id="023454d8e1cf65bbb06463e1b3d0c36017c3e388" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;dynlib&lt;/code&gt; pragma a procedure or a variable can be imported from a dynamic library (&lt;code&gt;.dll&lt;/code&gt; files for Windows, &lt;code&gt;lib*.so&lt;/code&gt; files for UNIX). The non-optional argument has to be the name of the dynamic library:</source>
          <target state="translated">使用 &lt;code&gt;dynlib&lt;/code&gt; 编译指示，可以从动态库（对于Windows的 &lt;code&gt;.dll&lt;/code&gt; 文件，对于UNIX的 &lt;code&gt;lib*.so&lt;/code&gt; 文件）中导入过程或变量。非可选参数必须是动态库的名称：</target>
        </trans-unit>
        <trans-unit id="d9ed0ac91dffc6d43c92455d3eaf4fb792201cb9" translate="yes" xml:space="preserve">
          <source>With these two files in place, you can run &lt;code&gt;nim c -r calculator.nim&lt;/code&gt; and the Nim compiler will compile the &lt;code&gt;logic.c&lt;/code&gt; file in addition to &lt;code&gt;calculator.nim&lt;/code&gt; and link both into an executable, which outputs &lt;code&gt;10&lt;/code&gt; when run. Another way to link the C file statically and get the same effect would be remove the line with the &lt;code&gt;compile&lt;/code&gt; pragma and run the following typical Unix commands:</source>
          <target state="translated">有了这两个文件，你可以运行 &lt;code&gt;nim c -r calculator.nim&lt;/code&gt; 和稔编译器编译 &lt;code&gt;logic.c&lt;/code&gt; 文件除了 &lt;code&gt;calculator.nim&lt;/code&gt; 和链接都为可执行文件，它输出 &lt;code&gt;10&lt;/code&gt; 运行时。静态链接C文件并获得相同效果的另一种方法是，删除带有 &lt;code&gt;compile&lt;/code&gt; 实用程序的行并运行以下典型的Unix命令：</target>
        </trans-unit>
        <trans-unit id="32f010be8a21b14dff05310dc71f698e090ed9c5" translate="yes" xml:space="preserve">
          <source>With this notation we can now easily define the core of the grammar: A block of statements (simplified example):</source>
          <target state="translated">有了这个符号,我们现在可以很容易地定义语法的核心:一个语句块(简化的例子)。</target>
        </trans-unit>
        <trans-unit id="0036fe9e484a381c94e7a2817c459b4a03ab955b" translate="yes" xml:space="preserve">
          <source>With this output we have a better idea of what kind of input the compiler expects. We need to generate a list of statements. For each constant the source code generates a &lt;code&gt;ConstSection&lt;/code&gt; and a &lt;code&gt;ConstDef&lt;/code&gt;. If we were to move all the constants to a single &lt;code&gt;const&lt;/code&gt; block we would see only a single &lt;code&gt;ConstSection&lt;/code&gt; with three children.</source>
          <target state="translated">通过此输出，我们可以更好地了解编译器需要哪种输入。我们需要生成一个语句列表。对于每个常量，源代码都会生成一个 &lt;code&gt;ConstSection&lt;/code&gt; 和一个 &lt;code&gt;ConstDef&lt;/code&gt; 。如果将所有常量移动到单个 &lt;code&gt;const&lt;/code&gt; 块，则只会看到带有三个子代的单个 &lt;code&gt;ConstSection&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fae6de82250865ee469a39f7ecbc1836e2a60ef6" translate="yes" xml:space="preserve">
          <source>Within a &lt;code&gt;parallel&lt;/code&gt; section sometimes the &lt;code&gt;FlowVar[T]&lt;/code&gt; is eliminated to &lt;code&gt;T&lt;/code&gt;. This happens when &lt;code&gt;T&lt;/code&gt; does not contain any GC'ed memory. The compiler can ensure the location in &lt;code&gt;location = spawn f(...)&lt;/code&gt; is not read prematurely within a &lt;code&gt;parallel&lt;/code&gt; section and so there is no need for the overhead of an indirection via &lt;code&gt;FlowVar[T]&lt;/code&gt; to ensure correctness.</source>
          <target state="translated">内的 &lt;code&gt;parallel&lt;/code&gt; 部有时 &lt;code&gt;FlowVar[T]&lt;/code&gt; 被消除到 &lt;code&gt;T&lt;/code&gt; 。当 &lt;code&gt;T&lt;/code&gt; 不包含任何GC'ed内存时，就会发生这种情况。编译器可以确保在 &lt;code&gt;parallel&lt;/code&gt; 段内未过早读取 &lt;code&gt;location = spawn f(...)&lt;/code&gt; 中的位置，因此不需要通过 &lt;code&gt;FlowVar[T]&lt;/code&gt; 进行间接调用以确保正确性。</target>
        </trans-unit>
        <trans-unit id="1f36950618b8748e3741661dd8fec794ecb08261" translate="yes" xml:space="preserve">
          <source>Within an &lt;code&gt;except&lt;/code&gt; clause, it is possible to use &lt;code&gt;getCurrentException&lt;/code&gt; to retrieve the exception that has been raised:</source>
          <target state="translated">在 &lt;code&gt;except&lt;/code&gt; 子句中，可以使用 &lt;code&gt;getCurrentException&lt;/code&gt; 检索已引发的异常：</target>
        </trans-unit>
        <trans-unit id="c6ae57f97edbcd123ef0194b0d49cf9ec52d7039" translate="yes" xml:space="preserve">
          <source>Within the concept body, types can appear in positions where ordinary values and parameters are expected. This provides a more convenient way to check for the presence of callable symbols with specific signatures:</source>
          <target state="translated">在概念体中,类型可以出现在普通值和参数的位置。这提供了一种更方便的方式来检查是否存在具有特定签名的可调用符号。</target>
        </trans-unit>
        <trans-unit id="7765888ff783f01e496adca7f847d2e186e708cb" translate="yes" xml:space="preserve">
          <source>Without the &lt;code&gt;GCunref&lt;/code&gt; call the memory allocated for the &lt;code&gt;d.s&lt;/code&gt; string would never be freed. The example also demonstrates two important features for low level programming: the &lt;code&gt;sizeof&lt;/code&gt; proc returns the size of a type or value in bytes. The &lt;code&gt;cast&lt;/code&gt; operator can circumvent the type system: the compiler is forced to treat the result of the &lt;code&gt;alloc0&lt;/code&gt; call (which returns an untyped pointer) as if it would have the type &lt;code&gt;ptr Data&lt;/code&gt;. Casting should only be done if it is unavoidable: it breaks type safety and bugs can lead to mysterious crashes.</source>
          <target state="translated">没有 &lt;code&gt;GCunref&lt;/code&gt; 调用，为 &lt;code&gt;d.s&lt;/code&gt; 字符串分配的内存将永远不会释放。该示例还演示了低级编程的两个重要功能： &lt;code&gt;sizeof&lt;/code&gt; proc返回以字节为单位的类型或值的大小。该 &lt;code&gt;cast&lt;/code&gt; 运营商可以规避类型系统：编译器被强制治疗的结果 &lt;code&gt;alloc0&lt;/code&gt; 调用（它返回一个无类型指针），就好像它会类型 &lt;code&gt;ptr Data&lt;/code&gt; 。仅在不可避免的情况下才应进行强制转换：它会破坏类型安全性，并且错误可能导致神秘的崩溃。</target>
        </trans-unit>
        <trans-unit id="e39a9ca07a5dddf13d83fab735c567da3357a0bf" translate="yes" xml:space="preserve">
          <source>Word wraps &lt;em&gt;s&lt;/em&gt;.</source>
          <target state="translated">自动换行&lt;em&gt;s&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="6962ff8c9e27a68a644675d133701514aae2e762" translate="yes" xml:space="preserve">
          <source>Would output:</source>
          <target state="translated">会输出。</target>
        </trans-unit>
        <trans-unit id="436516f371b709f69cf997c54adc4f028f9eebcd" translate="yes" xml:space="preserve">
          <source>Wrapper around &lt;a href=&quot;#init,TOrderedSet%5BA%5D,int&quot;&gt;init()&lt;/a&gt; for initialization of ordered hash sets.</source>
          <target state="translated">围绕&lt;a href=&quot;#init,TOrderedSet%5BA%5D,int&quot;&gt;init（）的&lt;/a&gt;包装器，用于初始化有序哈希集。</target>
        </trans-unit>
        <trans-unit id="aef47240f283c974795c0afe97ed4a86669acef1" translate="yes" xml:space="preserve">
          <source>Wrapper around &lt;a href=&quot;#init,TSet%5BA%5D,int&quot;&gt;init()&lt;/a&gt; for initialization of hash sets.</source>
          <target state="translated">用于初始化哈希集的&lt;a href=&quot;#init,TSet%5BA%5D,int&quot;&gt;init（）&lt;/a&gt;周围的包装器。</target>
        </trans-unit>
        <trans-unit id="0d365d3fa59d526a0f2809a9f61b0028c5e94b10" translate="yes" xml:space="preserve">
          <source>Wrappers</source>
          <target state="translated">Wrappers</target>
        </trans-unit>
        <trans-unit id="533cb09f4efea84d68d3be20e42d0338fe89c618" translate="yes" xml:space="preserve">
          <source>Wrapping constructors</source>
          <target state="translated">包裹构造体</target>
        </trans-unit>
        <trans-unit id="11cdbcadb273848cfeb799098c4c21e8db2e9d40" translate="yes" xml:space="preserve">
          <source>Wrapping destructors</source>
          <target state="translated">包裹破坏者</target>
        </trans-unit>
        <trans-unit id="9c3c9e84480e553d08468d0746063eeb3c7f119f" translate="yes" xml:space="preserve">
          <source>Wraps a connected socket in an SSL context. This function effectively turns &lt;code&gt;socket&lt;/code&gt; into an SSL socket. &lt;code&gt;hostname&lt;/code&gt; should be specified so that the client knows which hostname the server certificate should be validated against.</source>
          <target state="translated">在SSL上下文中包装已连接的套接字。此功能有效地将 &lt;code&gt;socket&lt;/code&gt; 转换为SSL套接字。应该指定 &lt;code&gt;hostname&lt;/code&gt; 以便客户端知道应该对服务器证书进行验证的主机名。</target>
        </trans-unit>
        <trans-unit id="9ddc5519e19aff7c9640076ae420da42486453ed" translate="yes" xml:space="preserve">
          <source>Wraps a socket in an SSL context. This function effectively turns &lt;code&gt;socket&lt;/code&gt; into an SSL socket.</source>
          <target state="translated">在SSL上下文中包装套接字。此功能有效地将 &lt;code&gt;socket&lt;/code&gt; 转换为SSL套接字。</target>
        </trans-unit>
        <trans-unit id="02cc7fed3b72e2c8ac3c8047c2bf9e4c909ccdc0" translate="yes" xml:space="preserve">
          <source>Wraps an already initialized &lt;code&gt;Socket&lt;/code&gt; into a AsyncSocket. This is useful if you want to use an already connected Socket as an asynchronous AsyncSocket in asyncio's event loop.</source>
          <target state="translated">将已经初始化的 &lt;code&gt;Socket&lt;/code&gt; 包装到AsyncSocket中。如果要在asyncio的事件循环中将已连接的Socket用作异步AsyncSocket，这将很有用。</target>
        </trans-unit>
        <trans-unit id="f942433295c32b403eab1ccdf7cdbcb2774f2494" translate="yes" xml:space="preserve">
          <source>Writes &lt;code&gt;data&lt;/code&gt; to the file specified asynchronously.</source>
          <target state="translated">将 &lt;code&gt;data&lt;/code&gt; 写入异步指定的文件。</target>
        </trans-unit>
        <trans-unit id="7c97819e5811aa1e2b05fd1d97141d7dc4900644" translate="yes" xml:space="preserve">
          <source>Writes &lt;code&gt;size&lt;/code&gt; bytes from &lt;code&gt;buf&lt;/code&gt; to the file specified asynchronously.</source>
          <target state="translated">将 &lt;code&gt;size&lt;/code&gt; 字节从 &lt;code&gt;buf&lt;/code&gt; 写入异步指定的文件。</target>
        </trans-unit>
        <trans-unit id="897e1a9e1ed791afbff422f3f8123f94d65ede78" translate="yes" xml:space="preserve">
          <source>Writes &lt;em&gt;data&lt;/em&gt; to the socket.</source>
          <target state="translated">将&lt;em&gt;数据&lt;/em&gt;写入套接字。</target>
        </trans-unit>
        <trans-unit id="90e3f5c8aacd0969383d67b232c4242e0fbab6cf" translate="yes" xml:space="preserve">
          <source>Writes a value to the file &lt;em&gt;f&lt;/em&gt;. May throw an IO exception.</source>
          <target state="translated">将值写入文件&lt;em&gt;f&lt;/em&gt;。可能会引发IO异常。</target>
        </trans-unit>
        <trans-unit id="06b82505d585d59b7b931841c5790d2d061a18cf" translate="yes" xml:space="preserve">
          <source>Writes and flushes the parameters to the standard output.</source>
          <target state="translated">将参数写入并刷新到标准输出。</target>
        </trans-unit>
        <trans-unit id="9fe62811850204f6989910a722d883718ece800c" translate="yes" xml:space="preserve">
          <source>Writes data to the specified future stream as the file is read.</source>
          <target state="translated">在读取文件时将数据写入指定的未来流。</target>
        </trans-unit>
        <trans-unit id="b92242dea02e29327d993eb1cc3297777dff63be" translate="yes" xml:space="preserve">
          <source>Writes into &lt;code&gt;result&lt;/code&gt; the rst ast &lt;code&gt;n&lt;/code&gt; using the &lt;code&gt;d&lt;/code&gt; configuration.</source>
          <target state="translated">使用 &lt;code&gt;d&lt;/code&gt; 配置将第一个ast &lt;code&gt;n&lt;/code&gt; 写入 &lt;code&gt;result&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8f25f4df96580649fbf61c73bf96f72aec9e3b5f" translate="yes" xml:space="preserve">
          <source>Writes the contents of the table to string. Note: Comment statement will be ignored.</source>
          <target state="translated">将表的内容写成字符串。注:注释语句将被忽略。</target>
        </trans-unit>
        <trans-unit id="ba6e3b9c400f1eef44b307552759341bc86ee5ce" translate="yes" xml:space="preserve">
          <source>Writes the contents of the table to the specified configuration file. Note: Comment statement will be ignored.</source>
          <target state="translated">将表的内容写到指定的配置文件中。注:注释语句将被忽略。</target>
        </trans-unit>
        <trans-unit id="943a3e5523074ab2149addf7bbeb0fa3c3bf1c09" translate="yes" xml:space="preserve">
          <source>Writes the contents of the table to the specified stream</source>
          <target state="translated">将表的内容写入指定的流。</target>
        </trans-unit>
        <trans-unit id="6cd9e881510f9be093ebe517fe9b4aa83cc82a0a" translate="yes" xml:space="preserve">
          <source>Writes the current index buffer to the specified output file.</source>
          <target state="translated">将当前的索引缓冲区写入指定的输出文件。</target>
        </trans-unit>
        <trans-unit id="4dd32587819be16f41963d9f477e3a15c30356f1" translate="yes" xml:space="preserve">
          <source>Writes the given RST node as JSON that is in the form</source>
          <target state="translated">将给定的RST节点写成JSON格式,即</target>
        </trans-unit>
        <trans-unit id="3bbbda5ef7f0ace5ebf184908b2e7da636d8527f" translate="yes" xml:space="preserve">
          <source>Writes the list of registered foreign deps to stdout.</source>
          <target state="translated">将已注册的外国代表名单写入stdout。</target>
        </trans-unit>
        <trans-unit id="0cfd7a39f362d2a77758e5c07bcd311bfabd3290" translate="yes" xml:space="preserve">
          <source>Writes the specified value inside the specified future stream.</source>
          <target state="translated">将指定的值写入指定的未来流中。</target>
        </trans-unit>
        <trans-unit id="b8255ac21cf77099d0f6ff9ac6e846fb5cdb0fda" translate="yes" xml:space="preserve">
          <source>Writes the string:</source>
          <target state="translated">写出字符串。</target>
        </trans-unit>
        <trans-unit id="2914acbe1102d062a4f2393594889f72ba0c206e" translate="yes" xml:space="preserve">
          <source>Writes the text &lt;em&gt;txt&lt;/em&gt; in a given &lt;em&gt;style&lt;/em&gt; to stdout.</source>
          <target state="translated">将给定&lt;em&gt;样式&lt;/em&gt;的文本&lt;em&gt;txt&lt;/em&gt;写入stdout。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="273726bd38de7eff2c09ffae11f809aa1fb0834f" translate="yes" xml:space="preserve">
          <source>Written by Philip Hazel</source>
          <target state="translated">作者:Philip Hazel</target>
        </trans-unit>
        <trans-unit id="f7b03e2f61abd9d04fffa15c8355e3436931a0ae" translate="yes" xml:space="preserve">
          <source>XDeclaredButNotUsed</source>
          <target state="translated">XDeclaredButNotUsed</target>
        </trans-unit>
        <trans-unit id="d647f348ffbbc7a4d48d8ae4bec579637ae0ee51" translate="yes" xml:space="preserve">
          <source>XML Processing</source>
          <target state="translated">XML处理</target>
        </trans-unit>
        <trans-unit id="d850dd17ecf96df39630839c6d073caf7cb5fb52" translate="yes" xml:space="preserve">
          <source>Yield every (position, value) of &lt;em&gt;deq&lt;/em&gt;.</source>
          <target state="translated">产生&lt;em&gt;deq的&lt;/em&gt;每个（位置，值）。</target>
        </trans-unit>
        <trans-unit id="755dd97240e42a3dc4431ff54cbcde0d38f93331" translate="yes" xml:space="preserve">
          <source>Yield every element of &lt;em&gt;deq&lt;/em&gt;.</source>
          <target state="translated">产生&lt;em&gt;deq的&lt;/em&gt;每个元素。</target>
        </trans-unit>
        <trans-unit id="b0ca75af94090e37bbf9398ee1de83cc580bdc1c" translate="yes" xml:space="preserve">
          <source>Yield statement</source>
          <target state="translated">产量报表</target>
        </trans-unit>
        <trans-unit id="d4f3a56dbd00c322681bd3d8cb3a2e92bba08be1" translate="yes" xml:space="preserve">
          <source>Yields all matching &lt;em&gt;substrings&lt;/em&gt; of &lt;code&gt;s&lt;/code&gt; that match &lt;code&gt;pattern&lt;/code&gt;.</source>
          <target state="translated">得到所有匹配的&lt;em&gt;子串&lt;/em&gt;的 &lt;code&gt;s&lt;/code&gt; 那场比赛 &lt;code&gt;pattern&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5dbe19c48460bbfdb0a7ecb4ffe08a0ee9cd8526" translate="yes" xml:space="preserve">
          <source>Yields all matching &lt;em&gt;substrings&lt;/em&gt; of &lt;em&gt;s&lt;/em&gt; that match &lt;em&gt;pattern&lt;/em&gt;.</source>
          <target state="translated">得到所有匹配的&lt;em&gt;子串&lt;/em&gt;的&lt;em&gt;小号&lt;/em&gt;那场比赛&lt;em&gt;模式&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="26171d2547797d7b792e1c5b0afcc0cbe263ef92" translate="yes" xml:space="preserve">
          <source>Yields each key, value pair.</source>
          <target state="translated">产生每个键、值对。</target>
        </trans-unit>
        <trans-unit id="2d7e3fc8749812999838907214d1eb8450309265" translate="yes" xml:space="preserve">
          <source>Yields the &lt;em&gt;keys&lt;/em&gt; in a JsAssoc.</source>
          <target state="translated">产生JsAssoc中的&lt;em&gt;密钥&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="a2417d997628d8ba1aefeea2d89fe75654c22728" translate="yes" xml:space="preserve">
          <source>Yields the &lt;em&gt;names&lt;/em&gt; of each field in a JsObject.</source>
          <target state="translated">产生JsObject中每个字段的&lt;em&gt;名称&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="93956d196d887cc0861e43d2a531388eaa74a029" translate="yes" xml:space="preserve">
          <source>Yields the &lt;em&gt;values&lt;/em&gt; in a JsAssoc.</source>
          <target state="translated">产生JsAssoc中的&lt;em&gt;值&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="1f1a656995365fee941d9a0f7f934014284b0f0a" translate="yes" xml:space="preserve">
          <source>Yields the &lt;em&gt;values&lt;/em&gt; of each field in a JsObject, wrapped into a JsObject.</source>
          <target state="translated">产生包装在JsObject中的JsObject中每个字段的&lt;em&gt;值&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="3fe8766634b03a0c571dde2851555af85b82423a" translate="yes" xml:space="preserve">
          <source>Yields the child nodes of a &lt;em&gt;Peg&lt;/em&gt; variant object where present.</source>
          <target state="translated">产生&lt;em&gt;Peg&lt;/em&gt;变体对象的子节点（如果存在）。</target>
        </trans-unit>
        <trans-unit id="d8ec21b096062ab66fc1c72aaf6915c5df074b73" translate="yes" xml:space="preserve">
          <source>Yields the indices and child nodes of a &lt;em&gt;Peg&lt;/em&gt; variant object where present.</source>
          <target state="translated">产生&lt;em&gt;Peg&lt;/em&gt;变体对象的索引和子节点（如果存在）。</target>
        </trans-unit>
        <trans-unit id="9787a201226a9a90fb295daca65242e9806ef392" translate="yes" xml:space="preserve">
          <source>Yields tuples of type &lt;code&gt;(K, V)&lt;/code&gt;, with the first entry being a &lt;em&gt;key&lt;/em&gt; in the JsAssoc and the second being its corresponding value.</source>
          <target state="translated">产生类型 &lt;code&gt;(K, V)&lt;/code&gt; 元组，第一个条目是JsAssoc中的&lt;em&gt;键&lt;/em&gt;，第二个条目是其对应的值。</target>
        </trans-unit>
        <trans-unit id="0d5fe99d112e72e96635690ca13742e71ee3b251" translate="yes" xml:space="preserve">
          <source>Yields tuples of type &lt;code&gt;(cstring, JsObject)&lt;/code&gt;, with the first entry being the &lt;em&gt;name&lt;/em&gt; of a fields in the JsObject and the second being its value wrapped into a JsObject.</source>
          <target state="translated">产生类型 &lt;code&gt;(cstring, JsObject)&lt;/code&gt; 元组，第一个条目是JsObject中字段的&lt;em&gt;名称&lt;/em&gt;，第二个条目是包装在JsObject中的值。</target>
        </trans-unit>
        <trans-unit id="e0096f64ab9c850e6d8688547c2fb784796e80a1" translate="yes" xml:space="preserve">
          <source>You can also create a &lt;code&gt;RstGenerator&lt;/code&gt; structure and populate it with the other lower level methods to finally build complete documents. This requires many options and tweaking, but you are not limited to snippets and can generate &lt;a href=&quot;https://en.wikipedia.org/wiki/LaTeX&quot;&gt;LaTeX documents&lt;/a&gt; too.</source>
          <target state="translated">您还可以创建一个 &lt;code&gt;RstGenerator&lt;/code&gt; 结构，并使用其他较低级别的方法填充该结构，以最终构建完整的文档。这需要许多选项和调整，但您不仅限于代码片段，还可以生成&lt;a href=&quot;https://en.wikipedia.org/wiki/LaTeX&quot;&gt;LaTeX文档&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3d188ca0a71a4ddf286451e750b7f8f446c7afd4" translate="yes" xml:space="preserve">
          <source>You can also make post requests with custom headers. This example sets &lt;code&gt;Content-Type&lt;/code&gt; to &lt;code&gt;application/json&lt;/code&gt; and uses a json object for the body</source>
          <target state="translated">您还可以使用自定义标题发出帖子请求。本示例将 &lt;code&gt;Content-Type&lt;/code&gt; 设置为 &lt;code&gt;application/json&lt;/code&gt; 并为主体使用json对象</target>
        </trans-unit>
        <trans-unit id="7714759afec1609cb47128c6129eb72d509b791d" translate="yes" xml:space="preserve">
          <source>You can also use the &lt;a href=&quot;#procedures-discard-statement&quot;&gt;discard statement&lt;/a&gt; together with &lt;em&gt;long string literals&lt;/em&gt; to create block comments:</source>
          <target state="translated">您还可以将&lt;a href=&quot;#procedures-discard-statement&quot;&gt;throw语句&lt;/a&gt;与&lt;em&gt;长字符串文字&lt;/em&gt;一起使用以创建块注释：</target>
        </trans-unit>
        <trans-unit id="97084a1faa8455f2406ffb033740ec1bfec72684" translate="yes" xml:space="preserve">
          <source>You can also use the convenience procedures called &lt;code&gt;milliseconds&lt;/code&gt;, &lt;code&gt;seconds&lt;/code&gt;, &lt;code&gt;minutes&lt;/code&gt;, &lt;code&gt;hours&lt;/code&gt;, &lt;code&gt;days&lt;/code&gt;, &lt;code&gt;months&lt;/code&gt;, and &lt;code&gt;years&lt;/code&gt;.</source>
          <target state="translated">您还可以使用称为 &lt;code&gt;milliseconds&lt;/code&gt; ， &lt;code&gt;seconds&lt;/code&gt; ， &lt;code&gt;minutes&lt;/code&gt; ， &lt;code&gt;hours&lt;/code&gt; ， &lt;code&gt;days&lt;/code&gt; ， &lt;code&gt;months&lt;/code&gt; 和 &lt;code&gt;years&lt;/code&gt; 的便捷过程。</target>
        </trans-unit>
        <trans-unit id="ac3b8da731d961b104b75c9c69b89b7521fd2d57" translate="yes" xml:space="preserve">
          <source>You can call &lt;code&gt;GC_SetMaxPause&lt;/code&gt; at program startup and then each triggered GC run tries to not take longer than &lt;code&gt;maxPause&lt;/code&gt; time. However, it is possible (and common) that the work is nevertheless not evenly distributed as each call to &lt;code&gt;new&lt;/code&gt; can trigger the GC and thus take &lt;code&gt;maxPause&lt;/code&gt; time.</source>
          <target state="translated">您可以在程序启动时调用 &lt;code&gt;GC_SetMaxPause&lt;/code&gt; ，然后每次触发的GC运行都尝试不超过 &lt;code&gt;maxPause&lt;/code&gt; 时间。但是，由于每次对 &lt;code&gt;new&lt;/code&gt; 的调用都可能触发GC并因此花费 &lt;code&gt;maxPause&lt;/code&gt; 时间，因此工作有可能（而且很普遍）分布不均匀。</target>
        </trans-unit>
        <trans-unit id="409fedb343fbf4112734b304e207a767c54d9c6f" translate="yes" xml:space="preserve">
          <source>You can call this proc on a previously initialized hash set, which will discard all its values. This might be more convenient than iterating over existing values and calling &lt;a href=&quot;#excl,TSet%5BA%5D,A&quot;&gt;excl()&lt;/a&gt; on them. Example:</source>
          <target state="translated">您可以在先前初始化的哈希集上调用此proc，该哈希集将丢弃其所有值。这可能比遍历现有值并在其上调用&lt;a href=&quot;#excl,TSet%5BA%5D,A&quot;&gt;excl（）&lt;/a&gt;更方便。例：</target>
        </trans-unit>
        <trans-unit id="b94d52a9f40f9d3456df4a8df7e7eb81a57a523b" translate="yes" xml:space="preserve">
          <source>You can call this proc on a previously initialized ordered hash set to discard its values. At the moment this is the only proc to remove elements from an ordered hash set. Example:</source>
          <target state="translated">你可以在一个先前初始化的有序哈希集上调用这个 proc 来丢弃它的值。目前,这是唯一一个从有序哈希集中删除元素的 proc。例子:在一个有序的哈希集中,你可以调用这个 proc 来删除元素。</target>
        </trans-unit>
        <trans-unit id="d5a15a89c8527958b5725cea61c34db20ebbeafb" translate="yes" xml:space="preserve">
          <source>You can find examples of client/server communication in the idetools tests found in the &lt;a href=&quot;#test-suite&quot;&gt;Test suite&lt;/a&gt;.</source>
          <target state="translated">您可以在&amp;ldquo; &lt;a href=&quot;#test-suite&quot;&gt;测试套件&amp;rdquo;&lt;/a&gt;中的idetools测试中找到客户端/服务器通信的示例。</target>
        </trans-unit>
        <trans-unit id="d157a3f2f7ccab099eb8d42373b8eee643ec59fc" translate="yes" xml:space="preserve">
          <source>You can force the evaluation of a certain expression at compile-time by coercing it to a corresponding &lt;code&gt;static&lt;/code&gt; type:</source>
          <target state="translated">您可以通过将某个表达式强制为相应的 &lt;code&gt;static&lt;/code&gt; 类型来强制对其求值：</target>
        </trans-unit>
        <trans-unit id="0fbd4752c2519417bd7580131c8b434b52acfe30" translate="yes" xml:space="preserve">
          <source>You can generate HTML output through the convenience proc &lt;code&gt;rstToHtml&lt;/code&gt;, which provided an input string with rst markup returns a string with the generated HTML. The final output is meant to be embedded inside a full document you provide yourself, so it won't contain the usual &lt;code&gt;&amp;lt;header&amp;gt;&lt;/code&gt; or &lt;code&gt;&amp;lt;body&amp;gt;&lt;/code&gt; parts.</source>
          <target state="translated">您可以通过便捷性proc &lt;code&gt;rstToHtml&lt;/code&gt; 生成HTML输出，该过程提供带有rst标记的输入字符串，返回包含生成的HTML的字符串。最终输出应嵌入到您提供的完整文档中，因此不会包含通常的 &lt;code&gt;&amp;lt;header&amp;gt;&lt;/code&gt; 或 &lt;code&gt;&amp;lt;body&amp;gt;&lt;/code&gt; 部分。</target>
        </trans-unit>
        <trans-unit id="db428874c2fa95de5693e83c0a003d99482e25e7" translate="yes" xml:space="preserve">
          <source>You can import the &lt;a href=&quot;rstgen&quot;&gt;packages/docutils/rstgen module&lt;/a&gt; in your programs if you want to reuse the compiler's documentation generation procs.</source>
          <target state="translated">如果要重复使用编译器的文档生成过程，可以在&lt;a href=&quot;rstgen&quot;&gt;程序&lt;/a&gt;中导入packages / docutils / rstgen模块。</target>
        </trans-unit>
        <trans-unit id="26dd058177b18bbce0e1976ca233b4444e8bfaa9" translate="yes" xml:space="preserve">
          <source>You can inline adhoc comparison procs with the &lt;a href=&quot;manual#procedures-do-notation&quot;&gt;do notation&lt;/a&gt;. Example:</source>
          <target state="translated">您可以使用&lt;a href=&quot;manual#procedures-do-notation&quot;&gt;do表示法&lt;/a&gt;内嵌即席比较过程。例：</target>
        </trans-unit>
        <trans-unit id="f9ee456de749cd07f777df2dbfca526efcaac8de" translate="yes" xml:space="preserve">
          <source>You can make one overload matching with a constraint and one without, and the one with a constraint will have precedence, and so you can handle both cases differently.</source>
          <target state="translated">你可以让一个有约束的重载匹配和一个没有约束的重载匹配,有约束的重载会有优先权,所以你可以对两种情况进行不同的处理。</target>
        </trans-unit>
        <trans-unit id="a3e0b3e912356fd0eb7d1dfb77943e7ce6efb8f9" translate="yes" xml:space="preserve">
          <source>You can obtain the type of a given expression by constructing a &lt;code&gt;type&lt;/code&gt; value from it (in many other languages this is known as the &lt;span id=&quot;typeof_1&quot;&gt;typeof&lt;/span&gt; operator):</source>
          <target state="translated">您可以通过构造给定表达式的 &lt;code&gt;type&lt;/code&gt; 值来获得给定表达式的类型（在许多其他语言中，这称为&lt;span id=&quot;typeof_1&quot;&gt;typeof&lt;/span&gt;运算符）：</target>
        </trans-unit>
        <trans-unit id="fef0a20f2b09c4d9edfa4d02db9759a10ded5a2e" translate="yes" xml:space="preserve">
          <source>You can of course use GDB or Visual Studio to debug the compiler (via &lt;code&gt;--debuginfo --lineDir:on&lt;/code&gt;). However, there are also lots of procs that aid in debugging:</source>
          <target state="translated">当然，您可以使用GDB或Visual Studio调试编译器（通过 &lt;code&gt;--debuginfo --lineDir:on&lt;/code&gt; ）。但是，也有很多proc有助于调试：</target>
        </trans-unit>
        <trans-unit id="3f1dcc44050776a85f416ff13b391cd7420a7ea6" translate="yes" xml:space="preserve">
          <source>You can pass a block of statements as the last argument to a template following the special &lt;code&gt;:&lt;/code&gt; syntax:</source>
          <target state="translated">您可以按照特殊的 &lt;code&gt;:&lt;/code&gt; 语法将语句块作为最后一个参数传递给模板：</target>
        </trans-unit>
        <trans-unit id="3235ae291f967014004169d6dd7919accac84950" translate="yes" xml:space="preserve">
          <source>You can then begin accepting connections using the &lt;code&gt;accept&lt;/code&gt; procedure.</source>
          <target state="translated">然后，您可以使用 &lt;code&gt;accept&lt;/code&gt; 过程开始接受连接。</target>
        </trans-unit>
        <trans-unit id="229f698a5d2a1c44c1f9b047aaac16d395d3ac54" translate="yes" xml:space="preserve">
          <source>You can use &lt;code&gt;#discardableprefix &quot;&quot;&lt;/code&gt; to &lt;em&gt;always&lt;/em&gt; add the &lt;code&gt;.discardable&lt;/code&gt; pragma since every name starts with the empty string prefix.</source>
          <target state="translated">您可以使用 &lt;code&gt;#discardableprefix &quot;&quot;&lt;/code&gt; 来&lt;em&gt;始终&lt;/em&gt;添加 &lt;code&gt;.discardable&lt;/code&gt; 编译，因为每一个名字开始与空字符串前缀。</target>
        </trans-unit>
        <trans-unit id="522e6e68fd4224a4e7b5d122bef202f975c7268d" translate="yes" xml:space="preserve">
          <source>You can use either &lt;code&gt;fmt&lt;/code&gt; or the unary &lt;code&gt;&amp;amp;&lt;/code&gt; operator for formatting. The difference between them is subtle but important.</source>
          <target state="translated">您可以使用 &lt;code&gt;fmt&lt;/code&gt; 或一元 &lt;code&gt;&amp;amp;&lt;/code&gt; 运算符进行格式化。它们之间的区别微妙但重要。</target>
        </trans-unit>
        <trans-unit id="f6db4f8bc927328b58f5dd31eba7cffedc758cc6" translate="yes" xml:space="preserve">
          <source>You can use this as a tool to explore the Nim's abstract syntax tree and to discover what kind of nodes must be created to represent a certain expression/statement.</source>
          <target state="translated">你可以用这个工具来探索Nim的抽象语法树,并发现必须创建什么样的节点来表示某个表达式/语句。</target>
        </trans-unit>
        <trans-unit id="0ddf568174dd61d7a80305dc0a3e7df19330c174" translate="yes" xml:space="preserve">
          <source>You can use this as a tool to write macros quicker by writing example outputs and then copying the snippets into the macro for modification.</source>
          <target state="translated">你可以利用这个工具,通过编写示例输出,然后将片段复制到宏中进行修改,从而更快地编写宏。</target>
        </trans-unit>
        <trans-unit id="d1c2d59459a913b746b98925a2a3fc29f24dc533" translate="yes" xml:space="preserve">
          <source>You can use this proc to decorate a branch condition. On certain platforms this can help the processor predict better which branch is going to be run. Example:</source>
          <target state="translated">你可以使用这个 proc 来装饰一个分支条件。在某些平台上,这可以帮助处理器更好地预测将要运行的分支。例如</target>
        </trans-unit>
        <trans-unit id="a34048e340fae2cd8a9b340afd693e3e0e20b294" translate="yes" xml:space="preserve">
          <source>You can use this proc to transform the elements from a set. Example:</source>
          <target state="translated">你可以使用这个 proc 来转换一个集合中的元素。例子</target>
        </trans-unit>
        <trans-unit id="a91b944ee43ceb5d18d013c159338cbb935b2855" translate="yes" xml:space="preserve">
          <source>You can use this template to decorate a branch condition. On certain platforms this can help the processor predict better which branch is going to be run. Example:</source>
          <target state="translated">你可以使用这个模板来装饰一个分支条件。在某些平台上,这可以帮助处理器更好地预测将要运行的分支。例如</target>
        </trans-unit>
        <trans-unit id="786f4a9c940aa7c5a0838e96623ddf57a6935a80" translate="yes" xml:space="preserve">
          <source>You can verify this yourself adding the line &lt;code&gt;echo source&lt;/code&gt; somewhere at the end of the macro and compiling the program. Another difference is that instead of calling the usual &lt;a href=&quot;system#quit&quot;&gt;quit proc&lt;/a&gt; to abort (which we could still call) this version calls the &lt;a href=&quot;macros#error&quot;&gt;error proc&lt;/a&gt; (line 14). The &lt;code&gt;error&lt;/code&gt; proc has the same behavior as &lt;code&gt;quit&lt;/code&gt; but will dump also the source and file line information where the error happened, making it easier for the programmer to find where compilation failed. In this situation it would point to the line invoking the macro, but &lt;strong&gt;not&lt;/strong&gt; the line of &lt;code&gt;data.cfg&lt;/code&gt; we are processing, that's something the macro itself would need to control.</source>
          <target state="translated">您可以自己验证这一点，将行 &lt;code&gt;echo source&lt;/code&gt; 添加到宏末尾的某个位置并编译程序。另一个区别是，此版本不是调用通常的&lt;a href=&quot;system#quit&quot;&gt;退出proc&lt;/a&gt;来终止（我们仍然可以调用），而是调用&lt;a href=&quot;macros#error&quot;&gt;错误proc&lt;/a&gt;（第14行）。该 &lt;code&gt;error&lt;/code&gt; PROC具有相同的行为与 &lt;code&gt;quit&lt;/code&gt; 也将转储在错误发生的源文件和行信息，使它更容易为程序员寻找到编译失败。在这种情况下，它将指向调用宏的行，而&lt;strong&gt;不是&lt;/strong&gt;我们正在处理的 &lt;code&gt;data.cfg&lt;/code&gt; 行，这是宏本身需要控制的东西。</target>
        </trans-unit>
        <trans-unit id="5b1927317fdc7e6a2effb5166b6eaa7c316bb014" translate="yes" xml:space="preserve">
          <source>You may add a constraint to the resulting type to trigger a compile-time error if the expression doesn't have the expected type:</source>
          <target state="translated">如果表达式没有预期的类型,你可以给生成的类型添加一个约束,以触发编译时错误。</target>
        </trans-unit>
        <trans-unit id="6f30ee997aa1c1a9a827cafb053cce15b31f0463" translate="yes" xml:space="preserve">
          <source>You may specify a callback procedure to be called during an HTTP request. This callback will be executed every second with information about the progress of the HTTP request.</source>
          <target state="translated">你可以指定一个在HTTP请求期间被调用的回调过程。这个回调过程将每隔一秒执行一次,并提供HTTP请求的进度信息。</target>
        </trans-unit>
        <trans-unit id="5dd8d98d03acf607976a61f844d04f595a458ee9" translate="yes" xml:space="preserve">
          <source>You must create a new SSL context with the &lt;code&gt;newContext&lt;/code&gt; function defined in the &lt;code&gt;net&lt;/code&gt; module. You may then call &lt;code&gt;wrapSocket&lt;/code&gt; on your socket using the newly created SSL context to get an SSL socket.</source>
          <target state="translated">您必须使用 &lt;code&gt;net&lt;/code&gt; 模块中定义的 &lt;code&gt;newContext&lt;/code&gt; 函数创建一个新的SSL上下文。然后，您可以使用新创建的SSL上下文在套接字上调用 &lt;code&gt;wrapSocket&lt;/code&gt; 以获取SSL套接字。</target>
        </trans-unit>
        <trans-unit id="b36e9e49af8f68c7f3865ace300bab1eeae94fdd" translate="yes" xml:space="preserve">
          <source>You need to call this before using a &lt;code&gt;RstGenerator&lt;/code&gt; with any other procs in this module. Pass a non &lt;code&gt;nil&lt;/code&gt;&lt;code&gt;StringTableRef&lt;/code&gt; value as &lt;em&gt;config&lt;/em&gt; with parameters used by the HTML output generator. If you don't know what to use, pass the results of the &lt;em&gt;defaultConfig() &amp;lt;#defaultConfig&amp;gt;_&lt;/em&gt; proc.</source>
          <target state="translated">在将 &lt;code&gt;RstGenerator&lt;/code&gt; 与该模块中的任何其他proc一起使用之前，需要调用此函数。通过HTML输出生成器使用的参数，将非 &lt;code&gt;nil&lt;/code&gt; &lt;code&gt;StringTableRef&lt;/code&gt; 值作为&lt;em&gt;配置&lt;/em&gt;传递。如果您不知道要使用什么，请传递&lt;em&gt;defaultConfig（）&amp;lt;#defaultConfig&amp;gt; _&lt;/em&gt; proc的结果。</target>
        </trans-unit>
        <trans-unit id="c6aec2725098b8ffc1761bd9c7f7b9f1682bf6e2" translate="yes" xml:space="preserve">
          <source>You previously need to add entries to the index with the &lt;a href=&quot;#setIndexTerm&quot;&gt;setIndexTerm()&lt;/a&gt; proc. If the index is empty the file won't be created.</source>
          <target state="translated">以前，您需要使用&lt;a href=&quot;#setIndexTerm&quot;&gt;setIndexTerm（）过程&lt;/a&gt;将条目添加到索引。如果索引为空，则不会创建文件。</target>
        </trans-unit>
        <trans-unit id="7d047869868e7ac2dd137df50888c63412be12d0" translate="yes" xml:space="preserve">
          <source>You should send this before sending your HTML page, for example.</source>
          <target state="translated">例如,你应该在发送HTML页面之前发送这个。</target>
        </trans-unit>
        <trans-unit id="3d103567ee18cb5218c37709ddcec0d6177298f4" translate="yes" xml:space="preserve">
          <source>You will also have to compile with &lt;code&gt;ssl&lt;/code&gt; defined like so: &lt;code&gt;nim c -d:ssl ...&lt;/code&gt;.</source>
          <target state="translated">您也将有编译 &lt;code&gt;ssl&lt;/code&gt; 像这样定义的： &lt;code&gt;nim c -d:ssl ...&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="058062ffe3d7415398c63db4c4c474b3de0c89a9" translate="yes" xml:space="preserve">
          <source>Zero or One</source>
          <target state="translated">零或一</target>
        </trans-unit>
        <trans-unit id="42ff50143f9dda79f19f7750e8d1e6ebfb6a9117" translate="yes" xml:space="preserve">
          <source>Zero or more</source>
          <target state="translated">零或更多</target>
        </trans-unit>
        <trans-unit id="5a0e6558a1175af4a938d82662dd24b2fa417681" translate="yes" xml:space="preserve">
          <source>Zero or more: Apply expression &lt;em&gt;E&lt;/em&gt; repeatedly to match the text ahead, as long as it succeeds. Consume the matched text (if any). Always indicate success.</source>
          <target state="translated">零个或多个：只要成功，就重复应用表达式&lt;em&gt;E&lt;/em&gt;以匹配前面的文本。使用匹配的文本（如果有）。总是表明成功。</target>
        </trans-unit>
        <trans-unit id="88a721c45ae571dec5e2aa89e2c4b85966c95f70" translate="yes" xml:space="preserve">
          <source>Zero or one: If expression &lt;em&gt;E&lt;/em&gt; matches the text ahead, consume it. Always indicate success.</source>
          <target state="translated">零或一：如果表达式&lt;em&gt;E&lt;/em&gt;与前面的文本匹配，请使用它。总是表明成功。</target>
        </trans-unit>
        <trans-unit id="2af78455018bdfce1224f9a413429c8d1cf682b3" translate="yes" xml:space="preserve">
          <source>Zero value for durations. Useful for comparisons.</source>
          <target state="translated">持续时间为零值。对比较有用。</target>
        </trans-unit>
        <trans-unit id="6060a4786b6be76ff108ebceec44d2daa4c15f06" translate="yes" xml:space="preserve">
          <source>Zero-indexed counting have two shortcuts &lt;code&gt;..&amp;lt;&lt;/code&gt; and &lt;code&gt;..^&lt;/code&gt; to simplify counting to one less than the higher index:</source>
          <target state="translated">零索引计数具有两个快捷方式 &lt;code&gt;..&amp;lt;&lt;/code&gt; 和 &lt;code&gt;..^&lt;/code&gt; ,可将计数简化为比高索引少一：</target>
        </trans-unit>
        <trans-unit id="be19fd422dffae7a0636938f97b2aa24b5cb13a9" translate="yes" xml:space="preserve">
          <source>[default(T), ...]</source>
          <target state="translated">[默认值（T），...]</target>
        </trans-unit>
        <trans-unit id="a6181759dbfbc1d13cea8897bba860e1cd1f1b7f" translate="yes" xml:space="preserve">
          <source>a channel for thread communication</source>
          <target state="translated">沟通渠道</target>
        </trans-unit>
        <trans-unit id="ceb1c4b07f128179a3a629f3d8297730fe20d8c2" translate="yes" xml:space="preserve">
          <source>a color stored as RGB</source>
          <target state="translated">储色</target>
        </trans-unit>
        <trans-unit id="d0b439a1db8b1636f87a882db4e959779e8dfe6b" translate="yes" xml:space="preserve">
          <source>a compiled regular expression</source>
          <target state="translated">正则表达式</target>
        </trans-unit>
        <trans-unit id="446a499c83ee189e881728b9614bb1c610b42820" translate="yes" xml:space="preserve">
          <source>a complex number, consisting of a real and an imaginary part</source>
          <target state="translated">虚实复数</target>
        </trans-unit>
        <trans-unit id="d4c0dd8cbb911234aafd65e42ebe2e16d8dd9a13" translate="yes" xml:space="preserve">
          <source>a convenience proc that runs the &lt;em&gt;command&lt;/em&gt;, grabs all its output and exit code and returns both.</source>
          <target state="translated">运行&lt;em&gt;命令&lt;/em&gt;的便利proc，获取其所有输出和退出代码并返回两者。</target>
        </trans-unit>
        <trans-unit id="3d1d312821fd56659d05a796c0721e1a9ac1ecd1" translate="yes" xml:space="preserve">
          <source>a convenience procedure for:</source>
          <target state="translated">方便程序,用于:</target>
        </trans-unit>
        <trans-unit id="697ab90ee8ea779b4e9d7e4d582cc0de7bbcb857" translate="yes" xml:space="preserve">
          <source>a data flow variable</source>
          <target state="translated">数据流变量</target>
        </trans-unit>
        <trans-unit id="236302a21803b39674181eb1c1e1dad827d987da" translate="yes" xml:space="preserve">
          <source>a distinct string type that is &lt;span id=&quot;tainted_1&quot;&gt;tainted&lt;/span&gt;, see &lt;a href=&quot;manual#taint-mode&quot;&gt;taint mode&lt;/a&gt; for details. It is an alias for &lt;code&gt;string&lt;/code&gt; if the taint mode is not turned on.</source>
          <target state="translated">一种受&lt;span id=&quot;tainted_1&quot;&gt;污染&lt;/span&gt;的独特字符串类型，有关详细信息，请参见&lt;a href=&quot;manual#taint-mode&quot;&gt;污染模式&lt;/a&gt;。如果未打开异味模式，则它是 &lt;code&gt;string&lt;/code&gt; 的别名。</target>
        </trans-unit>
        <trans-unit id="24c60b77672236b3310392791c9159e7da691559" translate="yes" xml:space="preserve">
          <source>a doubly linked list</source>
          <target state="translated">双联单</target>
        </trans-unit>
        <trans-unit id="92f8d2cb7eddeae18a8926cceebe9ab14e904d46" translate="yes" xml:space="preserve">
          <source>a doubly linked ring</source>
          <target state="translated">双联环</target>
        </trans-unit>
        <trans-unit id="9667a5641fafbc88c7babe208bd484588610acb6" translate="yes" xml:space="preserve">
          <source>a handle that can be</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c673f94589cd025a94f4df85ea7cbc620e46a6b6" translate="yes" xml:space="preserve">
          <source>a handle that can be used to get a row's column text on demand</source>
          <target state="translated">一个句柄,可用于根据需求获取行的列文本。</target>
        </trans-unit>
        <trans-unit id="9e35a0ed419e04673fabc57db7de755c9a5158d9" translate="yes" xml:space="preserve">
          <source>a handle to a dynamically loaded library</source>
          <target state="translated">一个动态加载库的句柄</target>
        </trans-unit>
        <trans-unit id="727eb5fb1890186a7705b301c37bcb5a3a011c04" translate="yes" xml:space="preserve">
          <source>a hash value; hash tables using these values should always have a size of a power of two and can use the &lt;code&gt;and&lt;/code&gt; operator instead of &lt;code&gt;mod&lt;/code&gt; for truncation of the hash value.</source>
          <target state="translated">哈希值；使用这些值的哈希表应始终具有2的幂的大小，并且可以使用 &lt;code&gt;and&lt;/code&gt; 运算符而不是 &lt;code&gt;mod&lt;/code&gt; 来截断哈希值。</target>
        </trans-unit>
        <trans-unit id="fb7c3a20e1c58ee4786768f999120ebe9f74132e" translate="yes" xml:space="preserve">
          <source>a identifier for the prepared queries</source>
          <target state="translated">准备查询的标识符</target>
        </trans-unit>
        <trans-unit id="e15266dcad2adbaa4f2ad63108ef729cf76beda5" translate="yes" xml:space="preserve">
          <source>a node a doubly linked list consists of</source>
          <target state="translated">一个节点一个双链路的列表包括</target>
        </trans-unit>
        <trans-unit id="5ba782577875c08c01d890dce7e8dd4aecffd0bd" translate="yes" xml:space="preserve">
          <source>a node a singly linked list consists of</source>
          <target state="translated">节点 单一链接的列表包括</target>
        </trans-unit>
        <trans-unit id="c5092df10e1c3e85e7d83e22f3d8ff19de9aee98" translate="yes" xml:space="preserve">
          <source>a parallel section can be used to execute a block in parallel. &lt;code&gt;body&lt;/code&gt; has to be in a DSL that is a particular subset of the language. Please refer to the manual for further information.</source>
          <target state="translated">并行部分可用于并行执行块。 &lt;code&gt;body&lt;/code&gt; 必须位于该语言的特定子集的DSL中。请参阅手册以获取更多信息。</target>
        </trans-unit>
        <trans-unit id="b464620548b26647c2039d50b3534a202b2e5405" translate="yes" xml:space="preserve">
          <source>a rational number, consisting of a numerator and denominator</source>
          <target state="translated">有理数,由分子和分母组成。</target>
        </trans-unit>
        <trans-unit id="69540ea7fe9bd9fdc5e24939d260de6bfcf3083e" translate="yes" xml:space="preserve">
          <source>a row in a CSV file</source>
          <target state="translated">一行</target>
        </trans-unit>
        <trans-unit id="a5ec37625145ddf6373e511cf4b862af7fe73b7a" translate="yes" xml:space="preserve">
          <source>a row of a dataset. NULL database values will be converted to nil.</source>
          <target state="translated">数据集的一行。NULL数据库值将被转换为nil。</target>
        </trans-unit>
        <trans-unit id="db9fa41fb39e8c2391daf5b73b38611f05be5128" translate="yes" xml:space="preserve">
          <source>a shortcut for '.. ^' to avoid the common gotcha that a space between '..' and '^' is required.</source>
          <target state="translated">的快捷方式,以避免'.^'的快捷方式,以避免'...'和'^'之间需要空格的常见错误。</target>
        </trans-unit>
        <trans-unit id="302bd8c00ad8f3e86bc63558821e98698620a746" translate="yes" xml:space="preserve">
          <source>a shortcut for 'a .. (when b is BackwardsIndex: succ(b) else: pred(b))'.</source>
          <target state="translated">a ...(当b是BackwardsIndex时:succ(b)否则:pred(b))的快捷方式。</target>
        </trans-unit>
        <trans-unit id="440e2c2edfe2d93548694539384ebaec70e26a08" translate="yes" xml:space="preserve">
          <source>a shorthand for &lt;code&gt;echo(errormsg); quit(errorcode)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;echo(errormsg); quit(errorcode)&lt;/code&gt; 的简写；退出（错误代码）。</target>
        </trans-unit>
        <trans-unit id="f1ea92069e80f9a3e02b527138ba54f9fbd0ee56" translate="yes" xml:space="preserve">
          <source>a simple barrier to wait for all spawn'ed tasks. If you need more elaborate waiting, you have to use an explicit barrier.</source>
          <target state="translated">一个简单的屏障,用来等待所有的 spawn'ed 任务。如果你需要更复杂的等待,你必须使用一个显式屏障。</target>
        </trans-unit>
        <trans-unit id="0c6d3caa14558753d210d77ea2d36fd6a1513d28" translate="yes" xml:space="preserve">
          <source>a single backslash</source>
          <target state="translated">反斜线</target>
        </trans-unit>
        <trans-unit id="837f51c3591f8b2d4452f90b5ddbc53e912a5c22" translate="yes" xml:space="preserve">
          <source>a singly linked list</source>
          <target state="translated">单链表</target>
        </trans-unit>
        <trans-unit id="216912de21be007513f346fea51719c0bc9710bb" translate="yes" xml:space="preserve">
          <source>a singly linked ring</source>
          <target state="translated">单联环</target>
        </trans-unit>
        <trans-unit id="fca33daf462dcc183c16697e01011fdb26d89e19" translate="yes" xml:space="preserve">
          <source>a standard ASCII identifier: &lt;code&gt;[a-zA-Z_][a-zA-Z_0-9]*&lt;/code&gt;</source>
          <target state="translated">标准ASCII标识符： &lt;code&gt;[a-zA-Z_][a-zA-Z_0-9]*&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0d78f86643008d4db0ec1bb8602ad193b2839d13" translate="yes" xml:space="preserve">
          <source>a stream that encapsulates a &lt;em&gt;File&lt;/em&gt;</source>
          <target state="translated">封装&lt;em&gt;文件&lt;/em&gt;的流&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="11c6c55b76ac43aa1bd1841c6cca1606179fd844" translate="yes" xml:space="preserve">
          <source>a stream that encapsulates a &lt;em&gt;MemFile&lt;/em&gt;</source>
          <target state="translated">封装&lt;em&gt;MemFile&lt;/em&gt;的流&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b86e6a991d0bca4656b36ada97342374f6e9a343" translate="yes" xml:space="preserve">
          <source>a stream that encapsulates a string</source>
          <target state="translated">串流</target>
        </trans-unit>
        <trans-unit id="43bd8c81bc8b1cc0db1629419cf49867fb9cbc47" translate="yes" xml:space="preserve">
          <source>a string that describes the application type. Possible values: &quot;console&quot;, &quot;gui&quot;, &quot;lib&quot;.</source>
          <target state="translated">描述应用程序类型的字符串。可能的值是:&quot; console&quot;、&quot;gui&quot;、&quot;lib&quot;。&quot;console&quot;、&quot;gui&quot;、&quot;lib&quot;。</target>
        </trans-unit>
        <trans-unit id="78097f72ab7bfacc92af44cb293dd8fef3e05b08" translate="yes" xml:space="preserve">
          <source>a string that describes the host CPU. Possible values: &quot;i386&quot;, &quot;alpha&quot;, &quot;powerpc&quot;, &quot;powerpc64&quot;, &quot;powerpc64el&quot;, &quot;sparc&quot;, &quot;amd64&quot;, &quot;mips&quot;, &quot;mipsel&quot;, &quot;arm&quot;, &quot;arm64&quot;, &quot;mips64&quot;, &quot;mips64el&quot;, &quot;riscv64&quot;.</source>
          <target state="translated">描述主机CPU的字符串。可能的值是:&quot;i386&quot;、&quot;alpha&quot;、&quot;powerpc&quot;、&quot;powerpc64&quot;、&quot;powerpc64el&quot;、&quot;sparc&quot;、&quot;amd64&quot;、&quot;mips&quot;。&quot;i386&quot;、&quot;alpha&quot;、&quot;powerpc&quot;、&quot;powerpc64&quot;、&quot;powerpc64el&quot;、&quot;sparc&quot;、&quot;amd64&quot;、&quot;mips&quot;、&quot;mipsel&quot;、&quot;arm&quot;、&quot;arm64&quot;、&quot;mips64&quot;、&quot;mips64el&quot;、&quot;riscv64&quot;。</target>
        </trans-unit>
        <trans-unit id="2904b6a5abddd9d8deb65901f6588cd84e307512" translate="yes" xml:space="preserve">
          <source>a string that describes the host operating system. Possible values: &quot;windows&quot;, &quot;macosx&quot;, &quot;linux&quot;, &quot;netbsd&quot;, &quot;freebsd&quot;, &quot;openbsd&quot;, &quot;solaris&quot;, &quot;aix&quot;, &quot;haiku&quot;, &quot;standalone&quot;.</source>
          <target state="translated">描述主机操作系统的字符串。可能的值是:&quot;windows&quot;、&quot;macosx&quot;、&quot;linux&quot;、&quot;netbsd&quot;、&quot;freebsd&quot;、&quot;openbsd&quot;、&quot;solaris&quot;、&quot;aix&quot;。&quot;windows&quot;、&quot;macosx&quot;、&quot;linux&quot;、&quot;netbsd&quot;、&quot;freebsd&quot;、&quot;openbsd&quot;、&quot;solaris&quot;、&quot;aix&quot;、&quot;haiku&quot;、&quot;standalone&quot;。</target>
        </trans-unit>
        <trans-unit id="5c43be61e01495675e75b60bd73d6e649f9ba570" translate="yes" xml:space="preserve">
          <source>a superset of datatypes that might be supported.</source>
          <target state="translated">可能被支持的数据类型的超集。</target>
        </trans-unit>
        <trans-unit id="dd596fb483edcb41239e2551baec03a2edb03189" translate="yes" xml:space="preserve">
          <source>abstract logger; the base type of all loggers</source>
          <target state="translated">抽象记录仪;所有记录仪的基本类型。</target>
        </trans-unit>
        <trans-unit id="4731f8a1ebe230c0bedc849397e5106693c2e5fe" translate="yes" xml:space="preserve">
          <source>accepts a single string argument and treats it as nim code that should be inserted verbatim in the program Example:</source>
          <target state="translated">接受一个单一的字符串参数,并将其视为应逐字插入程序中的nim代码。</target>
        </trans-unit>
        <trans-unit id="f104b049910f12d603b0f4b7c5560b09c7ab62fa" translate="yes" xml:space="preserve">
          <source>accepts node of kind nnkSym and returns its owner's symbol. result is also mnde of kind nnkSym if owner exists otherwise nnkNilLit is returned</source>
          <target state="translated">如果所有者存在,结果也是 nnkSym 的 mnde 类型,否则返回 nnkNilLit。</target>
        </trans-unit>
        <trans-unit id="beb500ee45bc07d7f3123c3ca655180cc9023baf" translate="yes" xml:space="preserve">
          <source>accessor for an any &lt;em&gt;x&lt;/em&gt; that represents an array or a sequence.</source>
          <target state="translated">代表数组或序列的任何&lt;em&gt;x&lt;/em&gt;的访问器。</target>
        </trans-unit>
        <trans-unit id="3641386853a01ac8136dde5cb98616d8122c4f64" translate="yes" xml:space="preserve">
          <source>activate 'see source' for doc and doc2 commands (see doc.item.seesrc in config/nimdoc.cfg)</source>
          <target state="translated">激活 doc 和 doc2 命令的 'see source' (参见 config/nimdoc.cfg 中的 doc.item.seerc)</target>
        </trans-unit>
        <trans-unit id="b2f4817d8ea2f060465d17fd1e0c9621ca128ab6" translate="yes" xml:space="preserve">
          <source>acyclic pragma</source>
          <target state="translated">非环形格言</target>
        </trans-unit>
        <trans-unit id="58d1bbce297de3c304a9fefc3b483181872a5c6b" translate="yes" xml:space="preserve">
          <source>add</source>
          <target state="translated">add</target>
        </trans-unit>
        <trans-unit id="be654d44da0556a5cfc0c3960f4b0e5d8c7691a8" translate="yes" xml:space="preserve">
          <source>add RunningRegress &lt;em&gt;b&lt;/em&gt; to &lt;em&gt;a&lt;/em&gt;</source>
          <target state="translated">将RunningRegress &lt;em&gt;b&lt;/em&gt;添加到&lt;em&gt;a&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="38f3963a1c27dc57f14b32ec31702841246839ac" translate="yes" xml:space="preserve">
          <source>add a path for Nimble support</source>
          <target state="translated">添加Nimble支持路径</target>
        </trans-unit>
        <trans-unit id="e52b43b0c3ff4c80cba13b5fbe245ef430bb9267" translate="yes" xml:space="preserve">
          <source>add a second RunningStats &lt;em&gt;b&lt;/em&gt; to &lt;em&gt;a&lt;/em&gt;</source>
          <target state="translated">添加第二个RunningStats &lt;em&gt;b&lt;/em&gt;到&lt;em&gt;一个&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c15cd5c97ee3e7837ac1a6c57b0ec58e743aa0cf" translate="yes" xml:space="preserve">
          <source>add an automatically imported module</source>
          <target state="translated">添加自动导入模块</target>
        </trans-unit>
        <trans-unit id="d006e72468553c812ce58018ffee86b98a1de727" translate="yes" xml:space="preserve">
          <source>add an automatically included module</source>
          <target state="translated">自动加入模块</target>
        </trans-unit>
        <trans-unit id="1a8ccf0416a8d5978779e3ecf6029e129bf6622d" translate="yes" xml:space="preserve">
          <source>add path to search paths</source>
          <target state="translated">添加路径到搜索路径</target>
        </trans-unit>
        <trans-unit id="00ff37c92cbfa69ed6d8a1ee9a213181f165d944" translate="yes" xml:space="preserve">
          <source>additional packages for the distribution</source>
          <target state="translated">用于分发的附加包</target>
        </trans-unit>
        <trans-unit id="6743cab27b3049919b02e0ba0d3ffe4227363a60" translate="yes" xml:space="preserve">
          <source>additional signed integer types of XX bits use this naming scheme (example: int16 is a 16 bit wide integer). The current implementation supports &lt;code&gt;int8&lt;/code&gt;, &lt;code&gt;int16&lt;/code&gt;, &lt;code&gt;int32&lt;/code&gt;, &lt;code&gt;int64&lt;/code&gt;. Literals of these types have the suffix 'iXX.</source>
          <target state="translated">XX位的其他带符号整数类型使用此命名方案（例如：int16是16位宽的整数）。当前实现支持 &lt;code&gt;int8&lt;/code&gt; ， &lt;code&gt;int16&lt;/code&gt; ， &lt;code&gt;int32&lt;/code&gt; ， &lt;code&gt;int64&lt;/code&gt; 。这些类型的文字后缀为'iXX。</target>
        </trans-unit>
        <trans-unit id="635d7e51a3815812414d121a44ae70a4032af75d" translate="yes" xml:space="preserve">
          <source>additional unsigned integer types of XX bits use this naming scheme (example: uint16 is a 16 bit wide unsigned integer). The current implementation supports &lt;code&gt;uint8&lt;/code&gt;, &lt;code&gt;uint16&lt;/code&gt;, &lt;code&gt;uint32&lt;/code&gt;, &lt;code&gt;uint64&lt;/code&gt;. Literals of these types have the suffix 'uXX. Unsigned operations all wrap around; they cannot lead to over- or underflow errors.</source>
          <target state="translated">XX位的其他无符号整数类型使用此命名方案（例如：uint16是16位宽的无符号整数）。当前的实现支持 &lt;code&gt;uint8&lt;/code&gt; ， &lt;code&gt;uint16&lt;/code&gt; ， &lt;code&gt;uint32&lt;/code&gt; ， &lt;code&gt;uint64&lt;/code&gt; 。这些类型的文字后缀为'uXX。所有未签名的操作都环绕；它们不会导致上溢或下溢错误。</target>
        </trans-unit>
        <trans-unit id="38c0eb29005c66f68f255094fa7f2452b189e538" translate="yes" xml:space="preserve">
          <source>adds &lt;em&gt;b&lt;/em&gt; to the rope &lt;em&gt;a&lt;/em&gt;.</source>
          <target state="translated">将&lt;em&gt;b&lt;/em&gt;添加到绳子&lt;em&gt;a上&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="a82969e97be5f2882f61b8d06bb03c94458061e4" translate="yes" xml:space="preserve">
          <source>adds the child &lt;em&gt;son&lt;/em&gt; to &lt;em&gt;father&lt;/em&gt;.</source>
          <target state="translated">把孩子的&lt;em&gt;儿子加&lt;/em&gt;为&lt;em&gt;父亲&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="aeb5b52f9e214a298005774ba529cab866982f54" translate="yes" xml:space="preserve">
          <source>adds the textual representation of &lt;em&gt;n&lt;/em&gt; to &lt;em&gt;result&lt;/em&gt;.</source>
          <target state="translated">将&lt;em&gt;n&lt;/em&gt;的文本表示形式添加到&lt;em&gt;result&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="93091c2d09b2ad7ca8e9bacf9c97757310394cf5" translate="yes" xml:space="preserve">
          <source>adds two colors: This uses saturated artithmetic, so that each color component cannot overflow (255 is used as a maximum).</source>
          <target state="translated">增加两种颜色。这使用了饱和艺术运算,所以每个颜色成分不能溢出(最大使用255)。</target>
        </trans-unit>
        <trans-unit id="70b840f37b0e8955863eaaf0c39b4e8bc2494a84" translate="yes" xml:space="preserve">
          <source>after lookup pass: &lt;code&gt;nnkSym(strVal = &quot;myIdentifier&quot;, ...)&lt;/code&gt;</source>
          <target state="translated">查找通过后： &lt;code&gt;nnkSym(strVal = &quot;myIdentifier&quot;, ...)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e108a968cadd854d13bc3b3948ea2ed2074a6ca1" translate="yes" xml:space="preserve">
          <source>alarm, that is, the BEL character (hex 07)</source>
          <target state="translated">报警,即BEL字符(十六进制07)</target>
        </trans-unit>
        <trans-unit id="9a53b0819e7b65cebdd2f94ad43011ac678d3fc3" translate="yes" xml:space="preserve">
          <source>algorithm</source>
          <target state="translated">algorithm</target>
        </trans-unit>
        <trans-unit id="6bcdc475a77368f9553c2f9b16d757fb113a0b27" translate="yes" xml:space="preserve">
          <source>algorithm.*</source>
          <target state="translated">algorithm.*</target>
        </trans-unit>
        <trans-unit id="eed67bfcd90ff2bde24b027a916e8dc6179bc669" translate="yes" xml:space="preserve">
          <source>algorithms for containers of AST nodes; converting the AST to YAML; the symbol table</source>
          <target state="translated">AST节点容器的算法;将AST转换为YAML;符号表。</target>
        </trans-unit>
        <trans-unit id="e6d0b03f10de095d5459cdb68303b689612deebd" translate="yes" xml:space="preserve">
          <source>alias for &lt;code&gt;false&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;false&lt;/code&gt; 别名</target>
        </trans-unit>
        <trans-unit id="c337d5a49dab1e36919aec1df636ec82dc97cc9d" translate="yes" xml:space="preserve">
          <source>alias for &lt;code&gt;true&lt;/code&gt;</source>
          <target state="translated">别名为 &lt;code&gt;true&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="132044e5591404c5419f7b9d0b83a9c482aa7d34" translate="yes" xml:space="preserve">
          <source>alias for &lt;em&gt;contains&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;包含的&lt;/em&gt;别名。</target>
        </trans-unit>
        <trans-unit id="b9d18988fa4de8a2b53ca8aa8f2745d9d349db6f" translate="yes" xml:space="preserve">
          <source>alias for &lt;em&gt;len() &amp;lt;#len&amp;gt;&lt;/em&gt; _.</source>
          <target state="translated">&lt;em&gt;len（）&amp;lt;#len&amp;gt;&lt;/em&gt; _的别名。</target>
        </trans-unit>
        <trans-unit id="52c4fff4212b87f102c0a1b2e9144a46079b9947" translate="yes" xml:space="preserve">
          <source>alias of &lt;em&gt;hasKey&lt;/em&gt; for use with the &lt;em&gt;in&lt;/em&gt; operator.</source>
          <target state="translated">&lt;em&gt;hasKey的&lt;/em&gt;别名，用于&lt;em&gt;in&lt;/em&gt;运算符。</target>
        </trans-unit>
        <trans-unit id="6dcb694c7648187b986a6c25cb54ec3810cea88e" translate="yes" xml:space="preserve">
          <source>all of the expressions within the body can be compiled for the tested type</source>
          <target state="translated">体内的所有表达式都可以为被测试的类型编译。</target>
        </trans-unit>
        <trans-unit id="7d63dd6433be0a0577b6741e68292848325c9c42" translate="yes" xml:space="preserve">
          <source>all statically evaluable boolean expressions in the body must be true</source>
          <target state="translated">所有在正文中的可静态评估的布尔表达式必须为真。</target>
        </trans-unit>
        <trans-unit id="1ec845402601c65b31a01099140d022e5011c2c8" translate="yes" xml:space="preserve">
          <source>allocates a new memory block on the shared heap with at least &lt;code&gt;T.sizeof * size&lt;/code&gt; bytes. The block has to be freed with &lt;code&gt;resizeShared(block, 0)&lt;/code&gt; or &lt;code&gt;freeShared(block)&lt;/code&gt;. The block is initialized with all bytes containing zero, so it is somewhat safer than &lt;code&gt;createSharedU&lt;/code&gt;.</source>
          <target state="translated">在共享堆上分配至少 &lt;code&gt;T.sizeof * size&lt;/code&gt; 个字节的新内存块。必须使用 &lt;code&gt;resizeShared(block, 0)&lt;/code&gt; 或 &lt;code&gt;freeShared(block)&lt;/code&gt; 释放该块。该块使用所有包含零的字节初始化，因此它比 &lt;code&gt;createSharedU&lt;/code&gt; 更安全。</target>
        </trans-unit>
        <trans-unit id="e189b8a859afa5cb84762353f1f6ad86c61ac06e" translate="yes" xml:space="preserve">
          <source>allocates a new memory block on the shared heap with at least &lt;code&gt;T.sizeof * size&lt;/code&gt; bytes. The block has to be freed with &lt;code&gt;resizeShared(block, 0)&lt;/code&gt; or &lt;code&gt;freeShared(block)&lt;/code&gt;. The block is not initialized, so reading from it before writing to it is undefined behaviour!</source>
          <target state="translated">在共享堆上分配至少 &lt;code&gt;T.sizeof * size&lt;/code&gt; 个字节的新内存块。必须使用 &lt;code&gt;resizeShared(block, 0)&lt;/code&gt; 或 &lt;code&gt;freeShared(block)&lt;/code&gt; 释放该块。该块未初始化，因此在写入之前对其进行读取是未定义的行为！</target>
        </trans-unit>
        <trans-unit id="f51a8d093a0a153f627e0b13d8e7a71628d6e3e9" translate="yes" xml:space="preserve">
          <source>allocates a new memory block with at least &lt;code&gt;T.sizeof * size&lt;/code&gt; bytes. The block has to be freed with &lt;code&gt;resize(block, 0)&lt;/code&gt; or &lt;code&gt;dealloc(block)&lt;/code&gt;. The block is initialized with all bytes containing zero, so it is somewhat safer than &lt;code&gt;createU&lt;/code&gt;. The allocated memory belongs to its allocating thread! Use &lt;em&gt;createShared&lt;/em&gt; to allocate from a shared heap.</source>
          <target state="translated">分配至少具有 &lt;code&gt;T.sizeof * size&lt;/code&gt; 字节的新内存块。必须使用 &lt;code&gt;resize(block, 0)&lt;/code&gt; 或 &lt;code&gt;dealloc(block)&lt;/code&gt; 释放该块。该块使用所有包含零的字节初始化，因此它比 &lt;code&gt;createU&lt;/code&gt; 更安全。分配的内存属于其分配线程！使用&lt;em&gt;createShared&lt;/em&gt;从共享堆进行分配。</target>
        </trans-unit>
        <trans-unit id="7137e112b520cb32d8116151366b12c17c968247" translate="yes" xml:space="preserve">
          <source>allocates a new memory block with at least &lt;code&gt;T.sizeof * size&lt;/code&gt; bytes. The block has to be freed with &lt;code&gt;resize(block, 0)&lt;/code&gt; or &lt;code&gt;dealloc(block)&lt;/code&gt;. The block is not initialized, so reading from it before writing to it is undefined behaviour! The allocated memory belongs to its allocating thread! Use &lt;em&gt;createSharedU&lt;/em&gt; to allocate from a shared heap.</source>
          <target state="translated">分配至少具有 &lt;code&gt;T.sizeof * size&lt;/code&gt; 字节的新内存块。必须使用 &lt;code&gt;resize(block, 0)&lt;/code&gt; 或 &lt;code&gt;dealloc(block)&lt;/code&gt; 释放该块。该块未初始化，因此在写入之前对其进行读取是未定义的行为！分配的内存属于其分配线程！使用&lt;em&gt;createSharedU&lt;/em&gt;从共享堆进行分配。</target>
        </trans-unit>
        <trans-unit id="9815fc8c2a8f4e1b35d4236d3fae99d3efd09869" translate="yes" xml:space="preserve">
          <source>allow 'nil' for strings/seqs for backwards compatibility</source>
          <target state="translated">为了向后兼容,允许字符串/序列使用 &quot;nil&quot;。</target>
        </trans-unit>
        <trans-unit id="0c910f64af961b17f44fd191ab90b296114ff3dc" translate="yes" xml:space="preserve">
          <source>allowed values</source>
          <target state="translated">允许值</target>
        </trans-unit>
        <trans-unit id="22f4fb40fbecf39d7d66ff344324ffd2846591d9" translate="yes" xml:space="preserve">
          <source>allows you to override the behaviour of your application when CTRL+C is pressed. Only one such hook is supported.</source>
          <target state="translated">允许你覆盖你的应用程序在按下CTRL+C时的行为。只支持一个这样的钩子。</target>
        </trans-unit>
        <trans-unit id="2aa389cc2795b6479735978661974371833e7c52" translate="yes" xml:space="preserve">
          <source>also used for &lt;em&gt;number of elements&lt;/em&gt;</source>
          <target state="translated">也用于&lt;em&gt;元素数量&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9c561cc052fbc5ffee282dada5fc957da9fd5710" translate="yes" xml:space="preserve">
          <source>always spawns a new task on the worker thread with &lt;code&gt;id&lt;/code&gt;, so that the 'call' is &lt;strong&gt;always&lt;/strong&gt; executed on the thread. 'call' has to be proc call 'p(...)' where 'p' is gcsafe and has a return type that is either 'void' or compatible with &lt;code&gt;FlowVar[T]&lt;/code&gt;.</source>
          <target state="translated">总是在具有 &lt;code&gt;id&lt;/code&gt; 的工作线程上产生一个新任务，以便&lt;strong&gt;始终&lt;/strong&gt;在线程上执行&amp;ldquo;调用&amp;rdquo; 。'call'必须是proc call'p（...）'，其中'p'是gcsafe，返回类型为'void'或与 &lt;code&gt;FlowVar[T]&lt;/code&gt; 兼容。</target>
        </trans-unit>
        <trans-unit id="8e037d1639b289c4e26bbc0c30ba6c431ce37c71" translate="yes" xml:space="preserve">
          <source>always spawns a new task, so that the 'call' is never executed on the calling thread. 'call' has to be proc call 'p(...)' where 'p' is gcsafe and has a return type that is either 'void' or compatible with &lt;code&gt;FlowVar[T]&lt;/code&gt;.</source>
          <target state="translated">总是产生新任务，因此永远不会在调用线程上执行&amp;ldquo;调用&amp;rdquo;。'call'必须是proc call'p（...）'，其中'p'是gcsafe，返回类型为'void'或与 &lt;code&gt;FlowVar[T]&lt;/code&gt; 兼容。</target>
        </trans-unit>
        <trans-unit id="151cee3c709c4d5822ef05a1ddc9a86502399266" translate="yes" xml:space="preserve">
          <source>an OID</source>
          <target state="translated">身份证</target>
        </trans-unit>
        <trans-unit id="73b05bc5523a49f0f729d013bc15436c3ee98c1f" translate="yes" xml:space="preserve">
          <source>an RST node</source>
          <target state="translated">节点</target>
        </trans-unit>
        <trans-unit id="8967ed81f37b78d187297570cfc0e002da7729e1" translate="yes" xml:space="preserve">
          <source>an RST node's description</source>
          <target state="translated">RST节点的描述</target>
        </trans-unit>
        <trans-unit id="71f5a9f32717a289921a20d9fc40fd3c347dad8b" translate="yes" xml:space="preserve">
          <source>an SQL abstract syntax tree node</source>
          <target state="translated">抽象语法树节点</target>
        </trans-unit>
        <trans-unit id="12310d9e38855a443de673725c022b73aa6accc6" translate="yes" xml:space="preserve">
          <source>an SQL query string</source>
          <target state="translated">SQL查询字符串</target>
        </trans-unit>
        <trans-unit id="58be42ab5ccf2b1d725354c664c1c9d1a049d853" translate="yes" xml:space="preserve">
          <source>an XML tree consists of &lt;code&gt;XmlNode&lt;/code&gt;'s.</source>
          <target state="translated">XML树由 &lt;code&gt;XmlNode&lt;/code&gt; 组成。</target>
        </trans-unit>
        <trans-unit id="a5805b81014eb065b07422ecce776bf0b349369e" translate="yes" xml:space="preserve">
          <source>an accumulator for regression calculations</source>
          <target state="translated">累加器</target>
        </trans-unit>
        <trans-unit id="bf87688aab1c6a062b31f453c9e7a123a6caf3f9" translate="yes" xml:space="preserve">
          <source>an accumulator for statistical data</source>
          <target state="translated">累加器</target>
        </trans-unit>
        <trans-unit id="a6e3ed0ced08ee631b0c37319f38559b39c3d487" translate="yes" xml:space="preserve">
          <source>an alias for 'send'.</source>
          <target state="translated">发送 &quot;的别称。</target>
        </trans-unit>
        <trans-unit id="17954bd5b900ea1471af9e6fe5da9f60619dfdcd" translate="yes" xml:space="preserve">
          <source>an alias for &lt;code&gt;HSlice[T, T]&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;HSlice[T, T]&lt;/code&gt; 的别名</target>
        </trans-unit>
        <trans-unit id="a019f449e8c64bbc587d53abf7ab099d0b97f6df" translate="yes" xml:space="preserve">
          <source>an alias for &lt;code&gt;ptr float32&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;ptr float32&lt;/code&gt; 的别名</target>
        </trans-unit>
        <trans-unit id="5e2bb9d99dad820df32fdfaf8060a4fd7276110f" translate="yes" xml:space="preserve">
          <source>an alias for &lt;code&gt;ptr float64&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;ptr float64&lt;/code&gt; 的别名</target>
        </trans-unit>
        <trans-unit id="359d828cee8b2007c3b07024f2b7d2dc9826bae9" translate="yes" xml:space="preserve">
          <source>an alias for &lt;code&gt;ptr int32&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;ptr int32&lt;/code&gt; 的别名</target>
        </trans-unit>
        <trans-unit id="7d65af0e89de7e9f7a3b4e8b4b9ff1129722fe22" translate="yes" xml:space="preserve">
          <source>an alias for &lt;code&gt;ptr int64&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;ptr int64&lt;/code&gt; 的别名</target>
        </trans-unit>
        <trans-unit id="7403e6d178a09880f3e0b23ff146897e53d7b447" translate="yes" xml:space="preserve">
          <source>an alias for &lt;em&gt;renderSQL&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;renderSQL&lt;/em&gt;的别名。</target>
        </trans-unit>
        <trans-unit id="4fa0108528af89e539fdd667d14f686cfe81e4f7" translate="yes" xml:space="preserve">
          <source>an alias for a string to string mapping</source>
          <target state="translated">字符串到字符串映射的别称。</target>
        </trans-unit>
        <trans-unit id="d8fe8bbb61c09319ee708a5efe7f650df5413428" translate="yes" xml:space="preserve">
          <source>an efficient set of 'int' implemented as a sparse bit set</source>
          <target state="translated">一个有效的'int'集,作为一个稀疏的比特集来实现。</target>
        </trans-unit>
        <trans-unit id="1a1e58ab7b0394cdaa4e08d47a7393a2573f3745" translate="yes" xml:space="preserve">
          <source>an implementation may define additional floating point types of XX bits using this naming scheme (example: float64 is a 64 bit wide float). The current implementation supports &lt;code&gt;float32&lt;/code&gt; and &lt;code&gt;float64&lt;/code&gt;. Literals of these types have the suffix 'fXX.</source>
          <target state="translated">一个实现可以使用此命名方案定义XX位的其他浮点类型（例如：float64是64位宽的float）。当前的实现支持 &lt;code&gt;float32&lt;/code&gt; 和 &lt;code&gt;float64&lt;/code&gt; 。这些类型的文字后缀为'fXX。</target>
        </trans-unit>
        <trans-unit id="13eb2e0ea344dca8fcab57fcf80481e8456bdaa0" translate="yes" xml:space="preserve">
          <source>and this code:</source>
          <target state="translated">和这个代码。</target>
        </trans-unit>
        <trans-unit id="773bac1f038c7261c06dd562d3e88c52d6186053" translate="yes" xml:space="preserve">
          <source>any &quot;non-word&quot; character</source>
          <target state="translated">非字</target>
        </trans-unit>
        <trans-unit id="a5b4f6becbf49b5f440097b76eb71086cbdb2a8c" translate="yes" xml:space="preserve">
          <source>any &quot;non-word&quot; character: &lt;code&gt;[^a-zA-Z0-9_]&lt;/code&gt;</source>
          <target state="translated">任何&amp;ldquo;非单词&amp;rdquo;字符： &lt;code&gt;[^a-zA-Z0-9_]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cbb1ab3493a026534f33f9de86e501fbba10bf1d" translate="yes" xml:space="preserve">
          <source>any &quot;word&quot; character</source>
          <target state="translated">任意一个 &quot;字 &quot;字</target>
        </trans-unit>
        <trans-unit id="0fb3dd67a147ef444359e89f1fc469598768826b" translate="yes" xml:space="preserve">
          <source>any &quot;word&quot; character: &lt;code&gt;[a-zA-Z0-9_]&lt;/code&gt;</source>
          <target state="translated">任何&amp;ldquo;单词&amp;rdquo;字符： &lt;code&gt;[a-zA-Z0-9_]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e2af7fa85d682cfca6869619ab12b089bbedc11f" translate="yes" xml:space="preserve">
          <source>any &lt;code&gt;ptr&lt;/code&gt; type</source>
          <target state="translated">任何 &lt;code&gt;ptr&lt;/code&gt; 类型</target>
        </trans-unit>
        <trans-unit id="d2a9ba0f67e27b921ff5c5a3f8c8c8532b81e663" translate="yes" xml:space="preserve">
          <source>any &lt;code&gt;ref&lt;/code&gt; type</source>
          <target state="translated">任何 &lt;code&gt;ref&lt;/code&gt; 类型</target>
        </trans-unit>
        <trans-unit id="c7f1406c1ae257c6a54cb24a67577fb91c8f2c42" translate="yes" xml:space="preserve">
          <source>any &lt;code&gt;var&lt;/code&gt; type</source>
          <target state="translated">任何 &lt;code&gt;var&lt;/code&gt; 类型</target>
        </trans-unit>
        <trans-unit id="45fb85b69ad14c45a89c623c70f23fe60fc970f3" translate="yes" xml:space="preserve">
          <source>any Unicode letter</source>
          <target state="translated">任何Unicode字母</target>
        </trans-unit>
        <trans-unit id="2b58475581e603ea596720d3da0600db8eac7452" translate="yes" xml:space="preserve">
          <source>any Unicode lowercase letter</source>
          <target state="translated">任何Unicode小写字母</target>
        </trans-unit>
        <trans-unit id="82a7803e43dc40a6d18691e4eb445841b8f4c29b" translate="yes" xml:space="preserve">
          <source>any Unicode title letter</source>
          <target state="translated">任何Unicode字母</target>
        </trans-unit>
        <trans-unit id="1e096fd7f4d038d278b9e42fe47340a4ac798fe8" translate="yes" xml:space="preserve">
          <source>any Unicode uppercase letter</source>
          <target state="translated">任何Unicode大写字母</target>
        </trans-unit>
        <trans-unit id="02c23e11023caa64175fc2b4a61c25bfa1946f6c" translate="yes" xml:space="preserve">
          <source>any Unicode whitespace character</source>
          <target state="translated">任何Unicode空白字符</target>
        </trans-unit>
        <trans-unit id="776b72d37856a0495e69540bbde0cf0ff74423cc" translate="yes" xml:space="preserve">
          <source>any array type</source>
          <target state="translated">任何数组类型</target>
        </trans-unit>
        <trans-unit id="3dab8eeada09e9b30b6ff5265a5dbaa8bead2a0b" translate="yes" xml:space="preserve">
          <source>any character that is not a decimal digit</source>
          <target state="translated">非小数点后的字符</target>
        </trans-unit>
        <trans-unit id="a1d38d834aca2863b3c8638b5d1049f11e10d0fe" translate="yes" xml:space="preserve">
          <source>any character that is not a decimal digit: &lt;code&gt;[^0-9]&lt;/code&gt;</source>
          <target state="translated">不是十进制数字的任何字符： &lt;code&gt;[^0-9]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="05628852de66b9fc9ab7ccc2a7684852507b683f" translate="yes" xml:space="preserve">
          <source>any character that is not a whitespace character</source>
          <target state="translated">非空格符的字符</target>
        </trans-unit>
        <trans-unit id="aeda72fde51bc293b14210dc49ac340fc60f0430" translate="yes" xml:space="preserve">
          <source>any character that is not a whitespace character: &lt;code&gt;[^ \9-\13]&lt;/code&gt;</source>
          <target state="translated">不是空格字符的任何字符： &lt;code&gt;[^ \9-\13]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f6634b62c48237338c00b5331263af4c43b87aa5" translate="yes" xml:space="preserve">
          <source>any decimal digit</source>
          <target state="translated">小数</target>
        </trans-unit>
        <trans-unit id="a67f2ee53694f9eaecce9d4b927adc516269ad42" translate="yes" xml:space="preserve">
          <source>any decimal digit: &lt;code&gt;[0-9]&lt;/code&gt;</source>
          <target state="translated">任何十进制数字： &lt;code&gt;[0-9]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1baab2f1eb74d608d7489859dab98499b03128ba" translate="yes" xml:space="preserve">
          <source>any distinct type</source>
          <target state="translated">无独有偶</target>
        </trans-unit>
        <trans-unit id="0cfd2075dc39382d468083735e1e4b96a0c2fe87" translate="yes" xml:space="preserve">
          <source>any enumeration</source>
          <target state="translated">任意列举</target>
        </trans-unit>
        <trans-unit id="632b027e713f7c77c2851530c3e2eb699d27fabb" translate="yes" xml:space="preserve">
          <source>any float</source>
          <target state="translated">任意浮动</target>
        </trans-unit>
        <trans-unit id="0516ce3580fe749675be3f049693cbea215fb083" translate="yes" xml:space="preserve">
          <source>any integer type</source>
          <target state="translated">任何整数类型</target>
        </trans-unit>
        <trans-unit id="ab2a2e239e83a015601c8e253eccb6d928207ec2" translate="yes" xml:space="preserve">
          <source>any newline combination: &lt;code&gt;\10 / \13\10 / \13&lt;/code&gt;</source>
          <target state="translated">任何换行符组合： &lt;code&gt;\10 / \13\10 / \13&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4743987c929c0cf7879ba69db4234c28b1936fe3" translate="yes" xml:space="preserve">
          <source>any object type</source>
          <target state="translated">任何对象类型</target>
        </trans-unit>
        <trans-unit id="51da33275128bfada93b7fe172db417cdf661eec" translate="yes" xml:space="preserve">
          <source>any proc type</source>
          <target state="translated">任何类型</target>
        </trans-unit>
        <trans-unit id="d1ef1ac0f2fbb95f7d03f6c0575d2f6dd7cd44f5" translate="yes" xml:space="preserve">
          <source>any seq type</source>
          <target state="translated">任何序列类型</target>
        </trans-unit>
        <trans-unit id="0ca9d57461d96f1e214aceba70e2030f0db409c0" translate="yes" xml:space="preserve">
          <source>any set type</source>
          <target state="translated">任意组合</target>
        </trans-unit>
        <trans-unit id="389a6d11b9875f6eb40c37282ad62cbe5608844a" translate="yes" xml:space="preserve">
          <source>any tuple type</source>
          <target state="translated">任何元组类型</target>
        </trans-unit>
        <trans-unit id="a28c54bd6aac059f8e4c1e9241bd9772b3d2a3a4" translate="yes" xml:space="preserve">
          <source>any type</source>
          <target state="translated">任何类型</target>
        </trans-unit>
        <trans-unit id="c9d581aa43044fba53f841ae21b312c1199cc2b2" translate="yes" xml:space="preserve">
          <source>any whitespace character</source>
          <target state="translated">任何空格字符</target>
        </trans-unit>
        <trans-unit id="cbf727596d66c6d08060fb873659c9e83d971bd3" translate="yes" xml:space="preserve">
          <source>any whitespace character: &lt;code&gt;[ \9-\13]&lt;/code&gt;</source>
          <target state="translated">任何空格字符： &lt;code&gt;[ \9-\13]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7d1043473d55bfa90e8530d35801d4e381bc69f0" translate="yes" xml:space="preserve">
          <source>app</source>
          <target state="translated">app</target>
        </trans-unit>
        <trans-unit id="db43bff34c78044870bc6b1ae2aa16902bb1bb8a" translate="yes" xml:space="preserve">
          <source>append</source>
          <target state="translated">append</target>
        </trans-unit>
        <trans-unit id="cf3ddbcb7cec2d2b9107f401606a80be88e173b3" translate="yes" xml:space="preserve">
          <source>appends a node &lt;em&gt;n&lt;/em&gt; to &lt;em&gt;L&lt;/em&gt;. Efficiency: O(1).</source>
          <target state="translated">附加一个节点&lt;em&gt;&amp;Ntilde;&lt;/em&gt;到&lt;em&gt;大号&lt;/em&gt;。效率：O（1）。</target>
        </trans-unit>
        <trans-unit id="394e90fc9086476ea2cc168904377cfdcaa95a5d" translate="yes" xml:space="preserve">
          <source>appends a value to &lt;em&gt;L&lt;/em&gt;. Efficiency: O(1).</source>
          <target state="translated">向&lt;em&gt;L&lt;/em&gt;附加一个值。效率：O（1）。</target>
        </trans-unit>
        <trans-unit id="d2005cc206ccbfdedf2be43a200cb050c538bdb5" translate="yes" xml:space="preserve">
          <source>application</source>
          <target state="translated">application</target>
        </trans-unit>
        <trans-unit id="06f720f81922363e28ffa5b9ea6b297a7c4ab084" translate="yes" xml:space="preserve">
          <source>applies &lt;code&gt;op&lt;/code&gt; to each of the &lt;strong&gt;atomic&lt;/strong&gt; literals like &lt;code&gt;3&lt;/code&gt; or &lt;code&gt;&quot;abc&quot;&lt;/code&gt; in the specified &lt;code&gt;constructor&lt;/code&gt; AST. This can be used to map every array element to some target type:</source>
          <target state="translated">将 &lt;code&gt;op&lt;/code&gt; 应用于指定 &lt;code&gt;constructor&lt;/code&gt; AST 中的每个&lt;strong&gt;原子&lt;/strong&gt;文字，如 &lt;code&gt;3&lt;/code&gt; 或 &lt;code&gt;&quot;abc&quot;&lt;/code&gt; 。这可以用于将每个数组元素映射到某种目标类型：</target>
        </trans-unit>
        <trans-unit id="04d6e2b300911995efa37b6707fdc02975a3021c" translate="yes" xml:space="preserve">
          <source>arg</source>
          <target state="translated">arg</target>
        </trans-unit>
        <trans-unit id="0f3802314d747bbc5016897875185c3a9fae57bf" translate="yes" xml:space="preserve">
          <source>argument</source>
          <target state="translated">argument</target>
        </trans-unit>
        <trans-unit id="601e3eae2caedfbe9867984df72affd5041c6f4a" translate="yes" xml:space="preserve">
          <source>argument - everything else</source>
          <target state="translated">争论--其他一切</target>
        </trans-unit>
        <trans-unit id="f8e5f3a667a852442823e459834bf798ce874870" translate="yes" xml:space="preserve">
          <source>arguments are passed to the program being run (if --run option is selected)</source>
          <target state="translated">参数被传递给正在运行的程序(如果选择了 --run 选项)。</target>
        </trans-unit>
        <trans-unit id="4390dce9df5136301038fcbfda456cfcefc40c26" translate="yes" xml:space="preserve">
          <source>array[0..., T]</source>
          <target state="translated">数组[0...,T]</target>
        </trans-unit>
        <trans-unit id="bb9cf9882aa44ffb9a28e49e4ea13eac493f1cf0" translate="yes" xml:space="preserve">
          <source>asmNoStackFrame pragma</source>
          <target state="translated">asmNoStackFrame pragma.</target>
        </trans-unit>
        <trans-unit id="e4a3803e63cafb4f45ce4da3b304606b0fb38156" translate="yes" xml:space="preserve">
          <source>assert end of string (or line, in multiline mode)</source>
          <target state="translated">断言字符串末尾</target>
        </trans-unit>
        <trans-unit id="2ab20e2dbc2d81949482cd67a19fb67418198995" translate="yes" xml:space="preserve">
          <source>assert start of string (or line, in multiline mode)</source>
          <target state="translated">断言字符串的开始(或行,在多行模式下)</target>
        </trans-unit>
        <trans-unit id="60544f107576aa75a3a16e2a4d455e8086f18203" translate="yes" xml:space="preserve">
          <source>assertion</source>
          <target state="translated">assertion</target>
        </trans-unit>
        <trans-unit id="120d25e6303ae7ca2cb354c13abcd5b71dbbd209" translate="yes" xml:space="preserve">
          <source>assertions</source>
          <target state="translated">assertions</target>
        </trans-unit>
        <trans-unit id="c24c0248770ae98831f8a654310d4c2e07514c61" translate="yes" xml:space="preserve">
          <source>ast</source>
          <target state="translated">ast</target>
        </trans-unit>
        <trans-unit id="7df52e645ceca43324a23db842d9058d2f5b083c" translate="yes" xml:space="preserve">
          <source>astalgo</source>
          <target state="translated">astalgo</target>
        </trans-unit>
        <trans-unit id="d59f43e7438cb25036fc655f0b8670b2f9530645" translate="yes" xml:space="preserve">
          <source>asyncdispatch</source>
          <target state="translated">asyncdispatch</target>
        </trans-unit>
        <trans-unit id="f3ccc3ccdfaaada264ca2c52da2860d14a1e629f" translate="yes" xml:space="preserve">
          <source>asyncdispatch.==</source>
          <target state="translated">asyncdispatch.==</target>
        </trans-unit>
        <trans-unit id="a4ab9637ac3aba19be3efe076a9fd74a9d4bf5ae" translate="yes" xml:space="preserve">
          <source>asyncfile</source>
          <target state="translated">asyncfile</target>
        </trans-unit>
        <trans-unit id="f215ff0b50d562a4f699305c138254c53a7e4e76" translate="yes" xml:space="preserve">
          <source>asyncftpclient</source>
          <target state="translated">asyncftpclient</target>
        </trans-unit>
        <trans-unit id="912d9cb1030b5696868d7cd061a1f1913fd22e54" translate="yes" xml:space="preserve">
          <source>asyncftpclient.cd()</source>
          <target state="translated">asyncftpclient.cd()</target>
        </trans-unit>
        <trans-unit id="7f9858036c96a49dead41c657601f55292eeb21b" translate="yes" xml:space="preserve">
          <source>asyncfutures</source>
          <target state="translated">asyncfutures</target>
        </trans-unit>
        <trans-unit id="6fac5c1c38ee66b71705a8698bdb25cd0c55009b" translate="yes" xml:space="preserve">
          <source>asyncfutures.$</source>
          <target state="translated">asyncfutures.$</target>
        </trans-unit>
        <trans-unit id="3e25c511c4dd4dd67c7bb70f3470a114aca1109f" translate="yes" xml:space="preserve">
          <source>asyncfutures.and</source>
          <target state="translated">asyncfutures.and</target>
        </trans-unit>
        <trans-unit id="b3959400d1c4f914e1d0d15e24d018f0b4bcd01d" translate="yes" xml:space="preserve">
          <source>asyncfutures.or</source>
          <target state="translated">asyncfutures.or</target>
        </trans-unit>
        <trans-unit id="16b484f4702399914b9685ac4a149df758f56412" translate="yes" xml:space="preserve">
          <source>asynchttpserver</source>
          <target state="translated">asynchttpserver</target>
        </trans-unit>
        <trans-unit id="4f5a0f016913fc4a169af7be4ea530a3a7d60ba2" translate="yes" xml:space="preserve">
          <source>asyncio</source>
          <target state="translated">asyncio</target>
        </trans-unit>
        <trans-unit id="df0aa08a1e718db729ddd29b35fcf08213931136" translate="yes" xml:space="preserve">
          <source>asyncjs</source>
          <target state="translated">asyncjs</target>
        </trans-unit>
        <trans-unit id="d7be09696c087802d819cf4a88b019da986579ce" translate="yes" xml:space="preserve">
          <source>asyncnet</source>
          <target state="translated">asyncnet</target>
        </trans-unit>
        <trans-unit id="f336018a344567452110d592d1db5dbd92b0c34e" translate="yes" xml:space="preserve">
          <source>asyncstreams</source>
          <target state="translated">asyncstreams</target>
        </trans-unit>
        <trans-unit id="d22d106d3ca7becc36b58971d80a432e61af2893" translate="yes" xml:space="preserve">
          <source>atomic decrement of &lt;em&gt;memLoc&lt;/em&gt;. Returns the value after the operation.</source>
          <target state="translated">&lt;em&gt;memLoc的&lt;/em&gt;原子减量。返回操作后的值。</target>
        </trans-unit>
        <trans-unit id="6cb8bb6a0a59b21438db5000a63cc7abf3e9ce50" translate="yes" xml:space="preserve">
          <source>atomic increment of &lt;em&gt;memLoc&lt;/em&gt;. Returns the value after the operation.</source>
          <target state="translated">&lt;em&gt;memLoc的&lt;/em&gt;原子增量。返回操作后的值。</target>
        </trans-unit>
        <trans-unit id="b4e16c009563ab7ba71f544cdf093ed49bacede5" translate="yes" xml:space="preserve">
          <source>awaits any of the given flowVars. Returns the index of one flowVar for which a value arrived. A flowVar only supports one call to 'blockUntilAny' at the same time. That means if you blockUntilAny([a,b]) and blockUntilAny([b,c]) the second call will only blockUntil 'c'. If there is no flowVar left to be able to wait on, -1 is returned. &lt;strong&gt;Note&lt;/strong&gt;: This results in non-deterministic behaviour and should be avoided.</source>
          <target state="translated">等待任何给定的flowVars。返回值到达的一个flowVar的索引。flowVar仅支持一次同时调用&amp;ldquo; blockUntilAny&amp;rdquo;。这意味着，如果您将blockUntilAny（[a，b]）和blockUntilAny（[b，c]）阻塞，则第二次调用将仅阻塞Until'c'。如果没有flowVar可以等待，则返回-1。&lt;strong&gt;注意&lt;/strong&gt;：这会导致不确定的行为，应避免使用。</target>
        </trans-unit>
        <trans-unit id="7090537b7970d7792c2dede512e03be486ed1bbd" translate="yes" xml:space="preserve">
          <source>base effect class; each effect should inherit from &lt;em&gt;RootEffect&lt;/em&gt; unless you know what you doing.</source>
          <target state="translated">基本效果类 除非您知道自己在做什么，否则每个效果都应继承自&lt;em&gt;RootEffect&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="5ee727532b654c2d8318a0ca08971ba3017603d9" translate="yes" xml:space="preserve">
          <source>base name of $app</source>
          <target state="translated">$app的基本名称</target>
        </trans-unit>
        <trans-unit id="8095e159699116466e36cbafd09e1d845f29f2b9" translate="yes" xml:space="preserve">
          <source>base64</source>
          <target state="translated">base64</target>
        </trans-unit>
        <trans-unit id="933558877f8bde9f7da0e625bdd25791b3547276" translate="yes" xml:space="preserve">
          <source>be case insensitive</source>
          <target state="translated">不分大小写</target>
        </trans-unit>
        <trans-unit id="dbb99f9bee10af60b73c09287e19cf7ad76dc789" translate="yes" xml:space="preserve">
          <source>be style insensitive</source>
          <target state="translated">不识时务</target>
        </trans-unit>
        <trans-unit id="801fe5e4f0fe1c70c018f3c5364c1f0b8fcf0a8a" translate="yes" xml:space="preserve">
          <source>be verbose: list every processed file</source>
          <target state="translated">啰嗦:列出每个处理过的文件</target>
        </trans-unit>
        <trans-unit id="3077737626efcafd4a2545cfe7e2173b4b04bc26" translate="yes" xml:space="preserve">
          <source>binary &lt;span id=&quot;slice_1&quot;&gt;slice&lt;/span&gt; operator that constructs an interval &lt;code&gt;[a, b]&lt;/code&gt;, both &lt;em&gt;a&lt;/em&gt; and &lt;em&gt;b&lt;/em&gt; are inclusive. Slices can also be used in the set constructor and in ordinal case statements, but then they are special-cased by the compiler.</source>
          <target state="translated">二进制&lt;span id=&quot;slice_1&quot;&gt;切片&lt;/span&gt;操作者构造一个间隔 &lt;code&gt;[a, b]&lt;/code&gt; ，二者&lt;em&gt;一个&lt;/em&gt;和&lt;em&gt;b&lt;/em&gt;是包括性的。切片也可以在set构造函数和有序case语句中使用，但随后它们由编译器进行特殊处理。</target>
        </trans-unit>
        <trans-unit id="94314a375a1c191f6ec01cc5b56e090a1db926cd" translate="yes" xml:space="preserve">
          <source>binary search for &lt;em&gt;key&lt;/em&gt; in &lt;em&gt;a&lt;/em&gt;. Returns -1 if not found.</source>
          <target state="translated">二进制搜索&lt;em&gt;键&lt;/em&gt;的&lt;em&gt;一个&lt;/em&gt;。如果找不到，则返回-1。</target>
        </trans-unit>
        <trans-unit id="09f0ceb4bf6383ebb1575eaa16ca08001738d7ed" translate="yes" xml:space="preserve">
          <source>binds an address/port number to a socket. Use address string in dotted decimal form like &quot;a.b.c.d&quot; or leave &quot;&quot; for any address.</source>
          <target state="translated">将地址/端口号绑定到套接字上。使用点阵十进制形式的地址字符串,如 &quot;a.b.c.d&quot;,或者留下&quot;&quot;表示任何地址。</target>
        </trans-unit>
        <trans-unit id="261e13cf94256fe14fb6c0700e4c3d15134a8a30" translate="yes" xml:space="preserve">
          <source>bitops</source>
          <target state="translated">bitops</target>
        </trans-unit>
        <trans-unit id="7ad3fef702b9b384e080a1dce5ae02d05c8c779a" translate="yes" xml:space="preserve">
          <source>bitwise OR of all supported exceptions</source>
          <target state="translated">所有支持的异常情况的位数OR</target>
        </trans-unit>
        <trans-unit id="b3bba832afd7bfee6a1ca7c4f0b72b17cde4452a" translate="yes" xml:space="preserve">
          <source>blocks until the &lt;code&gt;fv&lt;/code&gt; is available and then passes its value to &lt;code&gt;action&lt;/code&gt;. Note that due to Nim's parameter passing semantics this means that &lt;code&gt;T&lt;/code&gt; doesn't need to be copied and so &lt;code&gt;awaitAndThen&lt;/code&gt; can sometimes be more efficient than &lt;code&gt;^&lt;/code&gt;.</source>
          <target state="translated">阻塞直到 &lt;code&gt;fv&lt;/code&gt; 可用，然后将其值传递给 &lt;code&gt;action&lt;/code&gt; 。请注意，由于Nim的参数传递语义，这意味着不需要复制 &lt;code&gt;T&lt;/code&gt; ，因此 &lt;code&gt;awaitAndThen&lt;/code&gt; 有时可能比 &lt;code&gt;^&lt;/code&gt; 更有效。</target>
        </trans-unit>
        <trans-unit id="78af78bb4f4770be9ef1a285ca4b35516a2d260f" translate="yes" xml:space="preserve">
          <source>blocks until the value is available and then returns this value.</source>
          <target state="translated">块,直到值可用,然后返回这个值。</target>
        </trans-unit>
        <trans-unit id="5039d155a71c0a5f7a2b2654ad49cb7ee47a8980" translate="yes" xml:space="preserve">
          <source>bool</source>
          <target state="translated">bool</target>
        </trans-unit>
        <trans-unit id="3daef215d98d13fb11fb7258f01189d95d388907" translate="yes" xml:space="preserve">
          <source>boot command</source>
          <target state="translated">开机命令</target>
        </trans-unit>
        <trans-unit id="8e0e7d8f03334fea42f0fb9d4b102d890dd2bfeb" translate="yes" xml:space="preserve">
          <source>boundChecks</source>
          <target state="translated">boundChecks</target>
        </trans-unit>
        <trans-unit id="e7ab5809a76e914befcdd4f875ea24d6858e2e97" translate="yes" xml:space="preserve">
          <source>browsers</source>
          <target state="translated">browsers</target>
        </trans-unit>
        <trans-unit id="ab4c6d55c9b8536daa06dcfdad3b709bba8cfcf9" translate="yes" xml:space="preserve">
          <source>buffer handling of the lexical analyser</source>
          <target state="translated">词法分析器的缓冲区处理</target>
        </trans-unit>
        <trans-unit id="3df0e93dd5f8bcbff09fd72f31c5b11e2f8df128" translate="yes" xml:space="preserve">
          <source>build an index for the whole documentation</source>
          <target state="translated">为整个文档建立一个索引</target>
        </trans-unit>
        <trans-unit id="c1d8fc3d3a068b5b94c44c9da7a309885eca0117" translate="yes" xml:space="preserve">
          <source>buildIndex</source>
          <target state="translated">buildIndex</target>
        </trans-unit>
        <trans-unit id="7899851775abcb391fbb3611e14c5806b38f217d" translate="yes" xml:space="preserve">
          <source>built-in 8 bit character type (unsigned)</source>
          <target state="translated">内置8位字符类型(无符号)</target>
        </trans-unit>
        <trans-unit id="3a8158c3d07cf2a1168a5614f07c2fd4e364863c" translate="yes" xml:space="preserve">
          <source>built-in boolean type</source>
          <target state="translated">内置布尔型</target>
        </trans-unit>
        <trans-unit id="bdd6c8ca21c7bae842be59eef266709361858cd3" translate="yes" xml:space="preserve">
          <source>built-in cstring (&lt;em&gt;compatible string&lt;/em&gt;) type</source>
          <target state="translated">内置cstring（&lt;em&gt;兼容字符串&lt;/em&gt;）类型</target>
        </trans-unit>
        <trans-unit id="a744f5b9df007ccb6c80b67e250a9db549faa597" translate="yes" xml:space="preserve">
          <source>built-in generic traced pointer type</source>
          <target state="translated">内置通用跟踪指针类型</target>
        </trans-unit>
        <trans-unit id="e977564d9044849b00d8e6d8f43daedcb02c9365" translate="yes" xml:space="preserve">
          <source>built-in generic untraced pointer type</source>
          <target state="translated">内置通用无痕指针类型</target>
        </trans-unit>
        <trans-unit id="7492624ece266053123dd38ceccde7c465df2727" translate="yes" xml:space="preserve">
          <source>built-in pointer type, use the &lt;code&gt;addr&lt;/code&gt; operator to get a pointer to a variable</source>
          <target state="translated">内置指针类型，使用 &lt;code&gt;addr&lt;/code&gt; 运算符获取指向变量的指针</target>
        </trans-unit>
        <trans-unit id="6ffd7b6d3b34b66311cba6e4f638cbd97cdde3e8" translate="yes" xml:space="preserve">
          <source>built-in string type</source>
          <target state="translated">内置字符串型</target>
        </trans-unit>
        <trans-unit id="2ba10a874b60e75db318a913365334b1eb96194b" translate="yes" xml:space="preserve">
          <source>builtin &lt;span id=&quot;roof_1&quot;&gt;roof&lt;/span&gt; operator that can be used for convenient array access. &lt;code&gt;a[^x]&lt;/code&gt; is a shortcut for &lt;code&gt;a[a.len-x]&lt;/code&gt;.</source>
          <target state="translated">内置&lt;span id=&quot;roof_1&quot;&gt;屋顶&lt;/span&gt;操作器，可用于方便的阵列访问。 &lt;code&gt;a[^x]&lt;/code&gt; 是 &lt;code&gt;a[a.len-x]&lt;/code&gt; 的快捷方式。</target>
        </trans-unit>
        <trans-unit id="3426efad09c70f3da2870ce5a1d60001e80166ec" translate="yes" xml:space="preserve">
          <source>c2nim</source>
          <target state="translated">c2nim</target>
        </trans-unit>
        <trans-unit id="56aa317711bf6e70a709f0b77b32eb3731f7f2b7" translate="yes" xml:space="preserve">
          <source>c2nim &lt;em&gt;processes&lt;/em&gt;&lt;code&gt;#ifdef C2NIM&lt;/code&gt; and &lt;code&gt;#ifndef C2NIM&lt;/code&gt; directives, but other &lt;code&gt;#if[def]&lt;/code&gt; directives are &lt;em&gt;translated&lt;/em&gt; into Nim's &lt;code&gt;when&lt;/code&gt; construct:</source>
          <target state="translated">c2nim &lt;em&gt;处理&lt;/em&gt; &lt;code&gt;#ifdef C2NIM&lt;/code&gt; 和 &lt;code&gt;#ifndef C2NIM&lt;/code&gt; 伪指令，但是其他 &lt;code&gt;#if[def]&lt;/code&gt; 伪指令 &lt;code&gt;when&lt;/code&gt; 构造时被&lt;em&gt;转换&lt;/em&gt;为Nim的：</target>
        </trans-unit>
        <trans-unit id="eb1aa66b99c882e1d48f845dbf6ed8a475c6027f" translate="yes" xml:space="preserve">
          <source>c2nim User's manual</source>
          <target state="translated">c2nim用户手册</target>
        </trans-unit>
        <trans-unit id="8db503e64e7c067961c76a4f4ace96ea232a5bac" translate="yes" xml:space="preserve">
          <source>c2nim can be configured to skip certain &lt;code&gt;#ifdef&lt;/code&gt; or &lt;code&gt;#ifndef&lt;/code&gt; sections. If a directive &lt;code&gt;#assumedef SYMBOL``is found, c2nim will assume that the symbol ``SYMBOL&lt;/code&gt; is defined, and thus skip &lt;code&gt;#ifndef SYMBOL&lt;/code&gt; sections. The same happens if &lt;code&gt;SYMBOL&lt;/code&gt; is actually defined with a &lt;code&gt;#def&lt;/code&gt; directive.</source>
          <target state="translated">可以将c2nim配置为跳过某些 &lt;code&gt;#ifdef&lt;/code&gt; 或 &lt;code&gt;#ifndef&lt;/code&gt; 部分。如果 &lt;code&gt;#assumedef SYMBOL``is found, c2nim will assume that the symbol ``SYMBOL&lt;/code&gt; 指令#assumedef SYMBOL``，则c2nim将假定已定义符号``SYMBOL''，从而跳过 &lt;code&gt;#ifndef SYMBOL&lt;/code&gt; 节。如果 &lt;code&gt;SYMBOL&lt;/code&gt; 实际上是使用 &lt;code&gt;#def&lt;/code&gt; 指令定义的，则会发生相同的情况。</target>
        </trans-unit>
        <trans-unit id="ef0874a87826f5ff53f6c6bf9ffc5cfffc28c348" translate="yes" xml:space="preserve">
          <source>c2nim does not do any name mangling by default. However the &lt;code&gt;#prefix&lt;/code&gt; and &lt;code&gt;#suffix&lt;/code&gt; directives can be used to strip prefixes and suffixes from the identifiers in the C code:</source>
          <target state="translated">默认情况下，c2nim不进行任何名称处理。但是， &lt;code&gt;#prefix&lt;/code&gt; 和 &lt;code&gt;#suffix&lt;/code&gt; 指令可用于从C代码中的标识符中去除前缀和后缀：</target>
        </trans-unit>
        <trans-unit id="99da162adf79f0a46dd9c3d7234d5d0ec8a77afe" translate="yes" xml:space="preserve">
          <source>c2nim is a tool to translate Ansi C code to Nim. The output is human-readable Nim code that is meant to be tweaked by hand after the translation process. c2nim is no real compiler!</source>
          <target state="translated">c2nim是一个将Ansi C代码翻译成Nim的工具。c2nim不是真正的编译器!它的输出是人类可读的Nim代码,在翻译过程结束后,可以手工调整。</target>
        </trans-unit>
        <trans-unit id="8088a888559eda6c07415159a9479d5d21a3cce5" translate="yes" xml:space="preserve">
          <source>c2nim is meant to translate fragments of C code and thus does not follow include files. c2nim cannot parse all of Ansi C and many constructs cannot be represented in Nim: for example &lt;span id=&quot;duff-s-device_1&quot;&gt;duff's device&lt;/span&gt; cannot be translated to Nim.</source>
          <target state="translated">c2nim用于翻译C代码的片段，因此不包含文件。c2nim无法解析所有的Ansi C，许多构造无法用Nim表示：例如&lt;span id=&quot;duff-s-device_1&quot;&gt;duff的设备&lt;/span&gt;无法转换为Nim。</target>
        </trans-unit>
        <trans-unit id="b902834ab99b1e7d9ffa6d4609d2deeb057ee1ea" translate="yes" xml:space="preserve">
          <source>c2nim is preliminary meant to translate C header files. Because of this, the preprocessor is part of the parser. For example:</source>
          <target state="translated">c2nim 是用来翻译 C 语言头文件的预处理程序。正因为如此,预处理程序是解析器的一部分。例如</target>
        </trans-unit>
        <trans-unit id="e09728599d3a33821bbaf9009c7a4ce84e73c3f8" translate="yes" xml:space="preserve">
          <source>c2nim's preprocessor supports special directives that affect how the output is generated. They should be put into a &lt;code&gt;#ifdef C2NIM&lt;/code&gt; section so that ordinary C compilers ignore them.</source>
          <target state="translated">c2nim的预处理器支持特殊指令，这些指令会影响生成输出的方式。应该将它们放在 &lt;code&gt;#ifdef C2NIM&lt;/code&gt; 节中，以便普通C编译器将其忽略。</target>
        </trans-unit>
        <trans-unit id="04fbf5840ac1e9a5a1ceabb535b114715c54e34e" translate="yes" xml:space="preserve">
          <source>call this before starting to send your HTML data to &lt;em&gt;stdout&lt;/em&gt;. This implements this part of the CGI protocol:</source>
          <target state="translated">在开始将HTML数据发送到&lt;em&gt;stdout&lt;/em&gt;之前，请调用此方法。这实现了CGI协议的这一部分：</target>
        </trans-unit>
        <trans-unit id="76c6e4c322f4edd978f4612f2138812be9dde505" translate="yes" xml:space="preserve">
          <source>callconv</source>
          <target state="translated">callconv</target>
        </trans-unit>
        <trans-unit id="acd79879f7dc678d227bb41344bcf33ae5d53c48" translate="yes" xml:space="preserve">
          <source>can be used in a &lt;code&gt;try&lt;/code&gt; statement to setup a Lisp-like &lt;span id=&quot;condition-system_1&quot;&gt;condition system&lt;/span&gt;: This prevents the 'raise' statement to raise an exception but instead calls &lt;code&gt;action&lt;/code&gt;. If &lt;code&gt;action&lt;/code&gt; returns false, the exception has been handled and does not propagate further through the call stack.</source>
          <target state="translated">可以在 &lt;code&gt;try&lt;/code&gt; 语句中使用以建立类似Lisp的&lt;span id=&quot;condition-system_1&quot;&gt;条件系统&lt;/span&gt;：这可以防止'raise'语句引发异常，而是调用 &lt;code&gt;action&lt;/code&gt; 。如果 &lt;code&gt;action&lt;/code&gt; 返回false，则说明异常已得到处理，不会在调用堆栈中进一步传播。</target>
        </trans-unit>
        <trans-unit id="64a41c147d5237aaf5ea8d854a3e539b0855f6c2" translate="yes" xml:space="preserve">
          <source>can be used to determine an enum compile-time option. Example:</source>
          <target state="translated">可以用来确定一个枚举的编译时选项。例子:</target>
        </trans-unit>
        <trans-unit id="61bb814d0133b5fa4ff07d98a4f44ea9363df079" translate="yes" xml:space="preserve">
          <source>can be used to determine an on|off compile-time option. Example:</source>
          <target state="translated">可以用来确定一个开启-关闭编译时的选项。例子:</target>
        </trans-unit>
        <trans-unit id="97f7f9e367f1d1a60f63849acd516acbb9199cfe" translate="yes" xml:space="preserve">
          <source>can be used to determine if a first class iterator has finished.</source>
          <target state="translated">可以用来判断一级迭代器是否已经完成。</target>
        </trans-unit>
        <trans-unit id="35f22b9fbdbfca494dfb5fb443b40304f53942dc" translate="yes" xml:space="preserve">
          <source>can be used to ignore the whole code block</source>
          <target state="translated">可以用来忽略整个代码块。</target>
        </trans-unit>
        <trans-unit id="4de80ae5dfae7c9854dc8a8f5fc199837369b492" translate="yes" xml:space="preserve">
          <source>can represent any nim value; NOTE: the wrapped value can be modified with its wrapper! This means that &lt;code&gt;Any&lt;/code&gt; keeps a non-traced pointer to its wrapped value and &lt;strong&gt;must not&lt;/strong&gt; live longer than its wrapped value.</source>
          <target state="translated">可以代表任何nim值；注意：可以使用包装器修改包装的值！这意味着 &lt;code&gt;Any&lt;/code&gt; 保持指向其包装值的非跟踪指针，并且生存期&lt;strong&gt;不得&lt;/strong&gt;超过其包装值。</target>
        </trans-unit>
        <trans-unit id="ac4be5ac63e1ea62640409f639b010b9fb479c5b" translate="yes" xml:space="preserve">
          <source>cap</source>
          <target state="translated">cap</target>
        </trans-unit>
        <trans-unit id="7cb1f56d3fbe09e809244fc8e13671cd876e3860" translate="yes" xml:space="preserve">
          <source>capacity</source>
          <target state="translated">capacity</target>
        </trans-unit>
        <trans-unit id="0f2ba5867e198e37d5e93f508ce79d5a1539c992" translate="yes" xml:space="preserve">
          <source>carriage return (hex 0D)</source>
          <target state="translated">回车</target>
        </trans-unit>
        <trans-unit id="00d49cc01704e5289e3b5794a9e5737d299ed928" translate="yes" xml:space="preserve">
          <source>cast[T](0); this may be an invalid value</source>
          <target state="translated">cast[T](0);这可能是一个无效的值</target>
        </trans-unit>
        <trans-unit id="066cf57dd5805ecd80ecc03cc26eb4b65a6ce47f" translate="yes" xml:space="preserve">
          <source>casting and other unsafe operations (&lt;code&gt;cast&lt;/code&gt; operator, &lt;code&gt;zeroMem&lt;/code&gt;, etc.)</source>
          <target state="translated">铸造等不安全的操作（ &lt;code&gt;cast&lt;/code&gt; 运营商， &lt;code&gt;zeroMem&lt;/code&gt; 等）</target>
        </trans-unit>
        <trans-unit id="6ed337e48425488d145f2d21babd664982100114" translate="yes" xml:space="preserve">
          <source>ccgexprs</source>
          <target state="translated">ccgexprs</target>
        </trans-unit>
        <trans-unit id="a44bb7c205ea7486d510ad850c061dbe6beb50e4" translate="yes" xml:space="preserve">
          <source>ccgstmts</source>
          <target state="translated">ccgstmts</target>
        </trans-unit>
        <trans-unit id="d918fc219f81cb04127cae18afe532825260c4f8" translate="yes" xml:space="preserve">
          <source>ccgtypes</source>
          <target state="translated">ccgtypes</target>
        </trans-unit>
        <trans-unit id="956d838ceaa5b452bd3b5c3f5e88f3843af0a219" translate="yes" xml:space="preserve">
          <source>ccgutils</source>
          <target state="translated">ccgutils</target>
        </trans-unit>
        <trans-unit id="4cbc897d2b77bba922b5e4a4b6494b5592aecb7b" translate="yes" xml:space="preserve">
          <source>cdecl|...</source>
          <target state="translated">cdecl|...</target>
        </trans-unit>
        <trans-unit id="6ed7efe0ffdee78d655e5ad60691472f0fb43b1c" translate="yes" xml:space="preserve">
          <source>cfg</source>
          <target state="translated">cfg</target>
        </trans-unit>
        <trans-unit id="8f3d60cfea547e1e20ad21fbc5cec120d1862ae2" translate="yes" xml:space="preserve">
          <source>cgen</source>
          <target state="translated">cgen</target>
        </trans-unit>
        <trans-unit id="27b4d0f8ee1e61a07904f1afd558aa878973f2d1" translate="yes" xml:space="preserve">
          <source>cgi</source>
          <target state="translated">cgi</target>
        </trans-unit>
        <trans-unit id="3536f72ac0ec1d785e357fed37a3e83c4bc651e2" translate="yes" xml:space="preserve">
          <source>channels</source>
          <target state="translated">channels</target>
        </trans-unit>
        <trans-unit id="71fafc4e2fc1e47e234762a96b80512b6b5534c2" translate="yes" xml:space="preserve">
          <source>char</source>
          <target state="translated">char</target>
        </trans-unit>
        <trans-unit id="f0db3fa401aea04b711d6f1f3630552eaaee8e59" translate="yes" xml:space="preserve">
          <source>character</source>
          <target state="translated">character</target>
        </trans-unit>
        <trans-unit id="48236e5e509429b8fc8cd4a0ae77085dbfcc11bf" translate="yes" xml:space="preserve">
          <source>character type</source>
          <target state="translated">字型</target>
        </trans-unit>
        <trans-unit id="d3b61a14ecbe64faf1953c4b4664c690480394da" translate="yes" xml:space="preserve">
          <source>character with hex code hh</source>
          <target state="translated">汉字</target>
        </trans-unit>
        <trans-unit id="013c472ea5d09f54bdfb3cde32d29f19d9443d0d" translate="yes" xml:space="preserve">
          <source>character with octal code ddd, or backreference</source>
          <target state="translated">八进制字符</target>
        </trans-unit>
        <trans-unit id="d56d985300d4b52eb6e189be006f44f8d23c5ec9" translate="yes" xml:space="preserve">
          <source>check</source>
          <target state="translated">check</target>
        </trans-unit>
        <trans-unit id="7354fb826ffdc2403867a40dc983e0214220b565" translate="yes" xml:space="preserve">
          <source>checks</source>
          <target state="translated">checks</target>
        </trans-unit>
        <trans-unit id="e7a6d680b00692d32ffb421968f88c3acd4d4604" translate="yes" xml:space="preserve">
          <source>checks if more data can be read from &lt;em&gt;f&lt;/em&gt;. Returns true if all data has been read.</source>
          <target state="translated">检查是否可以从&lt;em&gt;f&lt;/em&gt;读取更多数据。如果已读取所有数据，则返回true。</target>
        </trans-unit>
        <trans-unit id="177feaf5a875f904bbb216efc1577b958b584596" translate="yes" xml:space="preserve">
          <source>checks if two MD5Digest values are identical</source>
          <target state="translated">检查两个MD5Digest值是否相同。</target>
        </trans-unit>
        <trans-unit id="d25b4520323ca9a79f3b710c170ab0e174922924" translate="yes" xml:space="preserve">
          <source>checks that &lt;em&gt;n&lt;/em&gt; has a number of children in the range &lt;code&gt;min..max&lt;/code&gt;. If this is not the case, compilation aborts with an error message. This is useful for writing macros that check its number of arguments.</source>
          <target state="translated">检查&lt;em&gt;n&lt;/em&gt;是否具有在 &lt;code&gt;min..max&lt;/code&gt; 范围内的子代数。如果不是这种情况，编译将中止并显示一条错误消息。这对于编写检查其参数数量的宏很有用。</target>
        </trans-unit>
        <trans-unit id="098639b92545c1cc7038eba5da7047eed275e435" translate="yes" xml:space="preserve">
          <source>checks that &lt;em&gt;n&lt;/em&gt; has at least &lt;em&gt;min&lt;/em&gt; children. If this is not the case, compilation aborts with an error message. This is useful for writing macros that check its number of arguments.</source>
          <target state="translated">检查&lt;em&gt;n&lt;/em&gt;是否至少有&lt;em&gt;min个&lt;/em&gt;孩子。如果不是这种情况，编译将中止并显示一条错误消息。这对于编写检查其参数数量的宏很有用。</target>
        </trans-unit>
        <trans-unit id="5b1353b044cd6fe2ded4431b6429efece035e17d" translate="yes" xml:space="preserve">
          <source>checks that &lt;em&gt;n&lt;/em&gt; has exactly &lt;em&gt;len&lt;/em&gt; children. If this is not the case, compilation aborts with an error message. This is useful for writing macros that check its number of arguments.</source>
          <target state="translated">检查&lt;em&gt;n&lt;/em&gt;是否正好有&lt;em&gt;len个&lt;/em&gt;孩子。如果不是这种情况，编译将中止并显示一条错误消息。这对于编写检查其参数数量的宏很有用。</target>
        </trans-unit>
        <trans-unit id="639633341d390ded8cc566e2bd59883ca9297e04" translate="yes" xml:space="preserve">
          <source>checks that &lt;em&gt;n&lt;/em&gt; is of kind &lt;em&gt;k&lt;/em&gt;. If this is not the case, compilation aborts with an error message. This is useful for writing macros that check the AST that is passed to them.</source>
          <target state="translated">检查&lt;em&gt;n&lt;/em&gt;是否为&lt;em&gt;k&lt;/em&gt;。如果不是这种情况，编译将中止并显示一条错误消息。这对于编写检查传递给它们的AST的宏很有用。</target>
        </trans-unit>
        <trans-unit id="17a80360b0c2de946b73432febb8a8236386a56f" translate="yes" xml:space="preserve">
          <source>checks the project for syntax and semantic</source>
          <target state="translated">检查项目的语法和语义</target>
        </trans-unit>
        <trans-unit id="e1d05dd5fd34693c4c55667580ded2aa7a8d5750" translate="yes" xml:space="preserve">
          <source>closes a channel &lt;em&gt;c&lt;/em&gt; and frees its associated resources.</source>
          <target state="translated">关闭通道&lt;em&gt;c&lt;/em&gt;并释放其关联的资源。</target>
        </trans-unit>
        <trans-unit id="5eb3e1e39f61035591b3e8c17ebf406a1739f2b7" translate="yes" xml:space="preserve">
          <source>closes a socket.</source>
          <target state="translated">关闭一个插座。</target>
        </trans-unit>
        <trans-unit id="8e46f7c4a19cd40725edd182f3cd8f28ae9a059a" translate="yes" xml:space="preserve">
          <source>closes the base lexer. This closes &lt;em&gt;L&lt;/em&gt;'s associated stream too.</source>
          <target state="translated">关闭基本词法分析器。这也关闭了&lt;em&gt;L&lt;/em&gt;的关联流。</target>
        </trans-unit>
        <trans-unit id="77d4c6e46a63f2ddf2ac5a0df3677c8d62a6a9d2" translate="yes" xml:space="preserve">
          <source>closes the connection.</source>
          <target state="translated">关闭连接。</target>
        </trans-unit>
        <trans-unit id="26adbf3fe5e8990bfd8ef4e529580b38a378a37e" translate="yes" xml:space="preserve">
          <source>closes the database connection.</source>
          <target state="translated">关闭数据库连接。</target>
        </trans-unit>
        <trans-unit id="4120af6f6fd3307319d8128138e2d5a62e11a37b" translate="yes" xml:space="preserve">
          <source>closes the memory mapped file &lt;em&gt;f&lt;/em&gt;. All changes are written back to the file system, if &lt;em&gt;f&lt;/em&gt; was opened with write access.</source>
          <target state="translated">关闭内存映射文件&lt;em&gt;f&lt;/em&gt;。如果使用写访问权限打开了&lt;em&gt;f&lt;/em&gt;，则所有更改都将写回到文件系统中。</target>
        </trans-unit>
        <trans-unit id="beffe895fa1092a7b803bd012ab87b6a4c03d2fd" translate="yes" xml:space="preserve">
          <source>closes the parser &lt;em&gt;c&lt;/em&gt; and its associated input stream.</source>
          <target state="translated">关闭解析器&lt;em&gt;c&lt;/em&gt;及其关联的输入流。</target>
        </trans-unit>
        <trans-unit id="11ebaec8140d9f72f4fe56335e3b4891498ef0ed" translate="yes" xml:space="preserve">
          <source>closes the parser &lt;em&gt;my&lt;/em&gt; and its associated input stream.</source>
          <target state="translated">关闭解析器&lt;em&gt;my&lt;/em&gt;及其关联的输入流。</target>
        </trans-unit>
        <trans-unit id="a547a7b24d66447bd198c99f42ae102ec2439542" translate="yes" xml:space="preserve">
          <source>closes the stream &lt;em&gt;s&lt;/em&gt;.</source>
          <target state="translated">关闭流&lt;em&gt;s&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="abac36149cf8b0e18d680ad240a392fc875517bc" translate="yes" xml:space="preserve">
          <source>cmd</source>
          <target state="translated">cmd</target>
        </trans-unit>
        <trans-unit id="ba6c06e4be30524ef0009a48aabf7d270581932f" translate="yes" xml:space="preserve">
          <source>cmp</source>
          <target state="translated">cmp</target>
        </trans-unit>
        <trans-unit id="46f0655e0e5194dcf502c9a8497c27816f875ba0" translate="yes" xml:space="preserve">
          <source>col is preferred, inconsistent right now</source>
          <target state="translated">col是首选,现在不一致</target>
        </trans-unit>
        <trans-unit id="250140b29dbd97cfe8b655b2383464509f00c6c2" translate="yes" xml:space="preserve">
          <source>col, column</source>
          <target state="translated">纵队</target>
        </trans-unit>
        <trans-unit id="f8bd696759805b9098f9e13be67d2b248c7619d0" translate="yes" xml:space="preserve">
          <source>colors</source>
          <target state="translated">colors</target>
        </trans-unit>
        <trans-unit id="f6b885e57915547b46349da5eefcd8162aa0866f" translate="yes" xml:space="preserve">
          <source>colors.$</source>
          <target state="translated">colors.$</target>
        </trans-unit>
        <trans-unit id="5e51764cc9d08861492f3fb1123a9530f62d59ad" translate="yes" xml:space="preserve">
          <source>colors.+</source>
          <target state="translated">colors.+</target>
        </trans-unit>
        <trans-unit id="a1a8cffa299a42401148e5848a3c6c1a3b78afb3" translate="yes" xml:space="preserve">
          <source>colors.-</source>
          <target state="translated">colors.-</target>
        </trans-unit>
        <trans-unit id="fb154583fb54c6f87d3d451d313d8be3a9e052bc" translate="yes" xml:space="preserve">
          <source>colors.==</source>
          <target state="translated">colors.==</target>
        </trans-unit>
        <trans-unit id="aa60230ab00282b5a1f3f1993b2d1c503e7d15a5" translate="yes" xml:space="preserve">
          <source>column</source>
          <target state="translated">column</target>
        </trans-unit>
        <trans-unit id="0d87d4fd5d052a9ff08c67b6976edc291f8ed99a" translate="yes" xml:space="preserve">
          <source>combine two &lt;em&gt;RunningRegress&lt;/em&gt; objects.</source>
          <target state="translated">合并两个&lt;em&gt;RunningRegress&lt;/em&gt;对象。</target>
        </trans-unit>
        <trans-unit id="a280c806fc0084662fe9dca88f44bbf8cf35fd56" translate="yes" xml:space="preserve">
          <source>combine two RunningStats.</source>
          <target state="translated">结合两个RunningStats。</target>
        </trans-unit>
        <trans-unit id="1925f793093581c47a5c6b2e414506b1cbae280d" translate="yes" xml:space="preserve">
          <source>command</source>
          <target state="translated">command</target>
        </trans-unit>
        <trans-unit id="f0461049bdae4983b14331cd824bc8faf678eada" translate="yes" xml:space="preserve">
          <source>commands that can be expressed as arguments</source>
          <target state="translated">可以作为参数的命令</target>
        </trans-unit>
        <trans-unit id="b64ca250f492e3f0444ad32b68be5f60a163bede" translate="yes" xml:space="preserve">
          <source>compare</source>
          <target state="translated">compare</target>
        </trans-unit>
        <trans-unit id="7e5186f1a9bd2895ed93cde0ae3e0ec0ee7ebb52" translate="yes" xml:space="preserve">
          <source>compares the memory blocks &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;. &lt;code&gt;size&lt;/code&gt; bytes will be compared. If the blocks are equal, true is returned, false otherwise. Like any procedure dealing with raw memory this is &lt;em&gt;unsafe&lt;/em&gt;.</source>
          <target state="translated">比较内存块 &lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;b&lt;/code&gt; 。将比较 &lt;code&gt;size&lt;/code&gt; 字节。如果块相等，则返回true，否则返回false。像处理原始内存的任何过程一样，这是&lt;em&gt;不安全的&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="094f6cd976e09fdf5710aaa012b7929b4e78b25a" translate="yes" xml:space="preserve">
          <source>compares two Nim identifiers &lt;strong&gt;Deprecated since version 0.18.1&lt;/strong&gt;; Use &lt;code&gt;==&lt;/code&gt; on &lt;code&gt;NimNode&lt;/code&gt; instead.</source>
          <target state="translated">比较&lt;strong&gt;从版本0.18.1开始不推荐使用的&lt;/strong&gt;两个Nim标识符; 在 &lt;code&gt;NimNode&lt;/code&gt; 上使用 &lt;code&gt;==&lt;/code&gt; 代替。</target>
        </trans-unit>
        <trans-unit id="3ed73a329c036ce3614aca85e565d7d2fa0479e4" translate="yes" xml:space="preserve">
          <source>compares two Nim nodes</source>
          <target state="translated">比较两个Nim节点</target>
        </trans-unit>
        <trans-unit id="cbc77019ddb9328367826ce155ee14c3fd23e382" translate="yes" xml:space="preserve">
          <source>compares two Nim nodes' types. Return true if the types are the same, eg. true when comparing alias with original type.</source>
          <target state="translated">比较两个Nim节点的类型。如果类型相同,返回true,例如,比较别名和原始类型时返回true。</target>
        </trans-unit>
        <trans-unit id="0dada719b7810e8fcd804a5047d3800c1e54b166" translate="yes" xml:space="preserve">
          <source>compares two Nim symbols &lt;strong&gt;Deprecated since version 0.18.1&lt;/strong&gt;; Use ```==`(NimNode,NimNode)`` instead.</source>
          <target state="translated">比较&lt;strong&gt;从版本0.18.1开始不推荐使用的&lt;/strong&gt;两个Nim符号; 使用`==`（NimNode，NimNode）``代替。</target>
        </trans-unit>
        <trans-unit id="0270a597009f086e4304658a9db86f15ed03e1cd" translate="yes" xml:space="preserve">
          <source>compares two colors.</source>
          <target state="translated">比较两种颜色。</target>
        </trans-unit>
        <trans-unit id="aa49b126d01b5a52b6416ad070faca0bf610e606" translate="yes" xml:space="preserve">
          <source>compilation option pragmas</source>
          <target state="translated">编译选项实用程序</target>
        </trans-unit>
        <trans-unit id="41b955d23f05ae5bdd0badb05a3faaf15c898d9f" translate="yes" xml:space="preserve">
          <source>compile Nim and generated files but do not link</source>
          <target state="translated">编译Nim和生成的文件,但不链接。</target>
        </trans-unit>
        <trans-unit id="ae36f560a64362393c0fb549afa5f8cdb5c4ba64" translate="yes" xml:space="preserve">
          <source>compile Nim files only; do not assemble or link</source>
          <target state="translated">只编译Nim文件,不要组装或链接。</target>
        </trans-unit>
        <trans-unit id="e87b469fe2f2263e06847de7d293924f49076024" translate="yes" xml:space="preserve">
          <source>compile project to C++ code</source>
          <target state="translated">将项目编译成C++代码</target>
        </trans-unit>
        <trans-unit id="be598bb766c710b889d68de039dbe949bb919e59" translate="yes" xml:space="preserve">
          <source>compile project to Javascript</source>
          <target state="translated">将项目编译成Javascript</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
