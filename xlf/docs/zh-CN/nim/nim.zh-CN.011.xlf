<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="nim">
    <body>
      <group id="nim">
        <trans-unit id="eb68ce2fa4474dfa498dc8618e15328f34f957b8" translate="yes" xml:space="preserve">
          <source>For cross compilation, the compiler invokes a C compiler named like &lt;code&gt;$cpu.$os.$cc&lt;/code&gt; (for example arm.linux.gcc) and the configuration system is used to provide meaningful defaults. For example for &lt;code&gt;ARM&lt;/code&gt; your configuration file should contain something like:</source>
          <target state="translated">对于交叉编译，编译器将调用名为 &lt;code&gt;$cpu.$os.$cc&lt;/code&gt; （例如arm.linux.gcc）的C编译器，并使用配置系统提供有意义的默认值。例如对于 &lt;code&gt;ARM&lt;/code&gt; ,您的配置文件应包含以下内容：</target>
        </trans-unit>
        <trans-unit id="bfddb4fd4901c9377aa65c5c53f4fed568adddec" translate="yes" xml:space="preserve">
          <source>For determining a &lt;code&gt;raises&lt;/code&gt; list, the &lt;code&gt;raise&lt;/code&gt; and &lt;code&gt;try&lt;/code&gt; statements of &lt;code&gt;p&lt;/code&gt; are taken into consideration.</source>
          <target state="translated">为了确定 &lt;code&gt;raises&lt;/code&gt; 列表，要考虑 &lt;code&gt;p&lt;/code&gt; 的 &lt;code&gt;raise&lt;/code&gt; 和 &lt;code&gt;try&lt;/code&gt; 语句。</target>
        </trans-unit>
        <trans-unit id="f6433d7fa88d46fa2ef63d15b0a2f1c232846783" translate="yes" xml:space="preserve">
          <source>For each input line we have to create a constant definition (&lt;code&gt;nnkConstDef&lt;/code&gt;) and wrap it inside a constant section (&lt;code&gt;nnkConstSection&lt;/code&gt;). Once these variables are created, we fill them hierarchichally (line 17) like the previous AST dump tree showed: the constant definition is a child of the section definition, and the constant definition has an identifier node, an empty node (we let the compiler figure out the type), and a string literal with the value.</source>
          <target state="translated">对于每条输入行，我们必须创建一个常量定义（ &lt;code&gt;nnkConstDef&lt;/code&gt; ）并将其包装在常量部分（ &lt;code&gt;nnkConstSection&lt;/code&gt; ）中。一旦创建了这些变量，我们就按照上一幅AST转储树所示层次化地填充它们（第17行）：常量定义是节定义的子级，并且常量定义有一个标识符节点，一个空节点（我们让编译器找出类型），以及带有值的字符串文字。</target>
        </trans-unit>
        <trans-unit id="e2287df8e6ff8f1fcddd131d03355087c8ef363b" translate="yes" xml:space="preserve">
          <source>For each token, the parser's &lt;code&gt;kind&lt;/code&gt;, &lt;code&gt;key&lt;/code&gt;, and &lt;code&gt;val&lt;/code&gt; fields give information about that token. If the token is a long or short option, &lt;code&gt;key&lt;/code&gt; is the option's name, and &lt;code&gt;val&lt;/code&gt; is either the option's value, if provided, or the empty string. For arguments, the &lt;code&gt;key&lt;/code&gt; field contains the argument itself, and &lt;code&gt;val&lt;/code&gt; is unused. To check if the end of the command line has been reached, check if &lt;code&gt;kind&lt;/code&gt; is equal to &lt;code&gt;cmdEnd&lt;/code&gt;.</source>
          <target state="translated">对于每个令牌，解析器的 &lt;code&gt;kind&lt;/code&gt; ， &lt;code&gt;key&lt;/code&gt; 和 &lt;code&gt;val&lt;/code&gt; 字段提供有关该令牌的信息。如果令牌是多头或空头选项，则 &lt;code&gt;key&lt;/code&gt; 是选项的名称， &lt;code&gt;val&lt;/code&gt; 是选项的值（如果提供）或空字符串。对于参数， &lt;code&gt;key&lt;/code&gt; 字段包含参数本身，而 &lt;code&gt;val&lt;/code&gt; 未使用。要检查是否已到达命令行末尾，请检查 &lt;code&gt;kind&lt;/code&gt; 是否等于 &lt;code&gt;cmdEnd&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5d10f6f6e4da7bf81dd537bc78c82cd345945246" translate="yes" xml:space="preserve">
          <source>For easier interoperability with other compiled languages such as C, retrieving the address of a &lt;code&gt;let&lt;/code&gt; variable, a parameter or a &lt;code&gt;for&lt;/code&gt; loop variable, the &lt;code&gt;unsafeAddr&lt;/code&gt; operation can be used:</source>
          <target state="translated">为了更轻松地与其他编译语言（例如C）互操作，检索 &lt;code&gt;let&lt;/code&gt; 变量，参数或 &lt;code&gt;for&lt;/code&gt; 循环变量的地址，可以使用 &lt;code&gt;unsafeAddr&lt;/code&gt; 操作：</target>
        </trans-unit>
        <trans-unit id="da10bc47ce513830b3757fe3c7440fcd62b179cc" translate="yes" xml:space="preserve">
          <source>For either value of &lt;code&gt;skipNonAlpha&lt;/code&gt;, returns false if &lt;code&gt;s&lt;/code&gt; is an empty string.</source>
          <target state="translated">对于 &lt;code&gt;skipNonAlpha&lt;/code&gt; 的任一值，如果 &lt;code&gt;s&lt;/code&gt; 为空字符串，则返回false 。</target>
        </trans-unit>
        <trans-unit id="e6c82f147503f7c257ef61cf3047e2f8c4af476c" translate="yes" xml:space="preserve">
          <source>For every other call the analysis can determine an exact &lt;code&gt;raises&lt;/code&gt; list.</source>
          <target state="translated">对于其他每个呼叫，分析都可以确定确切的 &lt;code&gt;raises&lt;/code&gt; 列表。</target>
        </trans-unit>
        <trans-unit id="8e42e98d89a815e38e97e54961734d238a0763f7" translate="yes" xml:space="preserve">
          <source>For every sink parameter &lt;code&gt;x: sink T&lt;/code&gt; the hooks are generated for &lt;code&gt;typeof(x)&lt;/code&gt;.</source>
          <target state="translated">对于每个接收器参数 &lt;code&gt;x: sink T&lt;/code&gt; ，都会为 &lt;code&gt;typeof(x)&lt;/code&gt; 生成钩子。</target>
        </trans-unit>
        <trans-unit id="6dc513bae3196a45b6b788484cf2f9e6b9080fd1" translate="yes" xml:space="preserve">
          <source>For example C++'s &lt;code&gt;new&lt;/code&gt; operator can be &quot;imported&quot; like this:</source>
          <target state="translated">例如，可以像这样&amp;ldquo;导入&amp;rdquo; C ++的 &lt;code&gt;new&lt;/code&gt; 运算符：</target>
        </trans-unit>
        <trans-unit id="d6943604d0d0031805c4f8cff45ec5239cbec0ac" translate="yes" xml:space="preserve">
          <source>For example on Unix:</source>
          <target state="translated">例如在Unix上。</target>
        </trans-unit>
        <trans-unit id="f46fb3e3b7fdfb1c1f5746b7c3c0d924a5276a3a" translate="yes" xml:space="preserve">
          <source>For example, assume a &lt;code&gt;dir1/foo.nim&lt;/code&gt; that imports a &lt;code&gt;dir2/bar.nim&lt;/code&gt;, have the &lt;code&gt;bar.nim&lt;/code&gt; print out both &lt;code&gt;getProjectPath&lt;/code&gt; and &lt;code&gt;currentSourcePath&lt;/code&gt; outputs.</source>
          <target state="translated">例如，假设 &lt;code&gt;dir1/foo.nim&lt;/code&gt; 导入了 &lt;code&gt;dir2/bar.nim&lt;/code&gt; ，让 &lt;code&gt;bar.nim&lt;/code&gt; 打印出 &lt;code&gt;getProjectPath&lt;/code&gt; 和 &lt;code&gt;currentSourcePath&lt;/code&gt; 输出。</target>
        </trans-unit>
        <trans-unit id="f5093f5246247862415343535a3ea8cef3834a0c" translate="yes" xml:space="preserve">
          <source>For example, if a system had &lt;code&gt;#&lt;/code&gt; as a delimiter, you could do the following to get the tail of the path:</source>
          <target state="translated">例如，如果系统使用 &lt;code&gt;#&lt;/code&gt; 作为分隔符，则可以执行以下操作以获取路径的结尾：</target>
        </trans-unit>
        <trans-unit id="8da3513cd0ef136598e40fc41ccc6496e8f86d48" translate="yes" xml:space="preserve">
          <source>For example, if a system had &lt;em&gt;#&lt;/em&gt; as a delimiter, you could do the following to get the tail of the path:</source>
          <target state="translated">例如，如果系统使用&lt;em&gt;＃&lt;/em&gt;作为分隔符，则可以执行以下操作以获取路径的结尾：</target>
        </trans-unit>
        <trans-unit id="0f1d5711f93558dbbd9946c13e3cca40ecd81c0d" translate="yes" xml:space="preserve">
          <source>For example, if you want to match a &lt;code&gt;*&lt;/code&gt; character, you write &lt;code&gt;\*&lt;/code&gt; in the pattern. This escaping action applies whether or not the following character would otherwise be interpreted as a metacharacter, so it is always safe to precede a non-alphanumeric with backslash to specify that it stands for itself. In particular, if you want to match a backslash, you write &lt;code&gt;\\&lt;/code&gt;.</source>
          <target state="translated">例如，如果要匹配 &lt;code&gt;*&lt;/code&gt; 字符，则在模式中写 &lt;code&gt;\*&lt;/code&gt; 。无论是否将以下字符解释为元字符，都会使用此转义操作，因此始终可以安全地在非字母数字前加反斜杠以指定其代表自身。特别是，如果要匹配反斜杠，请编写 &lt;code&gt;\\&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6bd116d8eecb1742f2aba0e90a0ed111f48feff3" translate="yes" xml:space="preserve">
          <source>For example, the closest to string &quot;&amp;Auml;u&amp;szlig;erst&quot; in ASCII is &quot;Ausserst&quot;. Some information is lost in this transformation, of course, since several Unicode strings can be transformed in the same ASCII representation. So this is a strictly one-way transformation. However a human reader will probably still be able to guess what original string was meant from the context.</source>
          <target state="translated">例如，在ASCII中最接近字符串&amp;ldquo;&amp;Auml;u&amp;szlig;erst&amp;rdquo;的是&amp;ldquo; Ausserst&amp;rdquo;。当然，由于可以用相同的ASCII表示形式转换几个Unicode字符串，因此在此转换中会丢失一些信息。因此，这是严格的单向转换。但是，人类读者仍可能能够从上下文中猜测出原始字符串的含义。</target>
        </trans-unit>
        <trans-unit id="06e8063e111c73956a53cf7043ebd6ff7c73d1a5" translate="yes" xml:space="preserve">
          <source>For example, to generate code for an &lt;span id=&quot;avr_1&quot;&gt;AVR&lt;/span&gt; processor use this command:</source>
          <target state="translated">例如，要为&lt;span id=&quot;avr_1&quot;&gt;AVR&lt;/span&gt;处理器生成代码，请使用以下命令：</target>
        </trans-unit>
        <trans-unit id="d524a00442ffaa71bfebe71d2798beae54e3c6ce" translate="yes" xml:space="preserve">
          <source>For example, with the above mentioned config:</source>
          <target state="translated">例如,有了上面提到的配置。</target>
        </trans-unit>
        <trans-unit id="cf8b8ee94d7ddff05e2d63d37354e348a9214764" translate="yes" xml:space="preserve">
          <source>For example, with the above-mentioned config:</source>
          <target state="translated">例如,通过上述配置。</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">例如:</target>
        </trans-unit>
        <trans-unit id="5a979257c11b99f6ef8da4c81ce4f3101724cf59" translate="yes" xml:space="preserve">
          <source>For example: &quot;..&quot; for POSIX or &quot;::&quot; for the classic Macintosh.</source>
          <target state="translated">例如:&quot;...&quot;代表POSIX,&quot;::&quot;代表经典的Macintosh。&quot;...&quot;代表POSIX,&quot;::&quot;代表经典的Macintosh。</target>
        </trans-unit>
        <trans-unit id="ce7ab614d3eacbc0791f3fe3e19af3be1ce99832" translate="yes" xml:space="preserve">
          <source>For example: '.' for POSIX or ':' for the classic Macintosh.</source>
          <target state="translated">例如:'.'代表POSIX,':'代表经典的Macintosh。</target>
        </trans-unit>
        <trans-unit id="172466eb39b138ca652f86c39241cd5c5c16e5f7" translate="yes" xml:space="preserve">
          <source>For example: &lt;code&gt;&quot;..&quot;&lt;/code&gt; for POSIX or &lt;code&gt;&quot;::&quot;&lt;/code&gt; for the classic Macintosh.</source>
          <target state="translated">例如： &lt;code&gt;&quot;..&quot;&lt;/code&gt; 用于POSIX，或 &lt;code&gt;&quot;::&quot;&lt;/code&gt; 用于经典Macintosh。</target>
        </trans-unit>
        <trans-unit id="5ce80f490c4d109b88a7ecf30197ac040d2d1c3b" translate="yes" xml:space="preserve">
          <source>For example: &lt;code&gt;'.'&lt;/code&gt; for POSIX or &lt;code&gt;':'&lt;/code&gt; for the classic Macintosh.</source>
          <target state="translated">例如： &lt;code&gt;'.'&lt;/code&gt; 对于POSIX，或者对于传统的Macintosh，则为 &lt;code&gt;':'&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="037a4a3add4baf2d3ff924d7337a1bbfa00ace3f" translate="yes" xml:space="preserve">
          <source>For examples take a look at the documentation for the modules implementing asynchronous IO. A good place to start is the &lt;a href=&quot;asyncnet&quot;&gt;asyncnet module&lt;/a&gt;.</source>
          <target state="translated">例如，请查看实现异步IO的模块的文档。一个不错的起点是&lt;a href=&quot;asyncnet&quot;&gt;asyncnet模块&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b1ebac78a3bbe3bfe99348fb588221f4bfac3c17" translate="yes" xml:space="preserve">
          <source>For files an alias for &lt;code&gt;write&lt;/code&gt;. If not specialized further, an alias for &lt;code&gt;add&lt;/code&gt;.</source>
          <target state="translated">对于文件，为 &lt;code&gt;write&lt;/code&gt; 的别名。如果不进一步专门化，则为 &lt;code&gt;add&lt;/code&gt; 的别名。</target>
        </trans-unit>
        <trans-unit id="989db3b42bc31c2bbd7704de97b6f57d5c9afe15" translate="yes" xml:space="preserve">
          <source>For functional style programming you have different options at your disposal:</source>
          <target state="translated">对于函数式编程,你可以有不同的选择。</target>
        </trans-unit>
        <trans-unit id="cc3abbf1f795d4e9d5c1784083fe048325a83d84" translate="yes" xml:space="preserve">
          <source>For functional style programming you may want to pass &lt;a href=&quot;manual#procedures-anonymous-procs&quot;&gt;anonymous procs&lt;/a&gt; to procs like &lt;code&gt;filter&lt;/code&gt; to reduce typing. Anonymous procs can use &lt;a href=&quot;manual#procedures-do-notation&quot;&gt;the special do notation&lt;/a&gt; which is more convenient in certain situations.</source>
          <target state="translated">对于函数式编程，您可能需要将&lt;a href=&quot;manual#procedures-anonymous-procs&quot;&gt;匿名proc&lt;/a&gt;传递给诸如 &lt;code&gt;filter&lt;/code&gt; 之类的 proc 以减少键入。匿名proc可以使用&lt;a href=&quot;manual#procedures-do-notation&quot;&gt;特殊的do表示法&lt;/a&gt;，在某些情况下更方便。</target>
        </trans-unit>
        <trans-unit id="87503a2c24062ef64c2113839dd981902727d48c" translate="yes" xml:space="preserve">
          <source>For further details, see &lt;a href=&quot;#type-relations-convertible-relation&quot;&gt;Convertible relation&lt;/a&gt;.</source>
          <target state="translated">有关更多详细信息，请参见&lt;a href=&quot;#type-relations-convertible-relation&quot;&gt;可转换关系&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="13b313d692ee716b5f8b3276fdd70745f9ead2a0" translate="yes" xml:space="preserve">
          <source>For high-level wrappers specialized for Linux and BSDs see: &lt;a href=&quot;posix_utils&quot;&gt;posix_utils&lt;/a&gt;</source>
          <target state="translated">有关专用于Linux和BSD的高级包装器，请参见：&lt;a href=&quot;posix_utils&quot;&gt;posix_utils&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="23b7041567e33cbc564ac905e83c0e92b5fee08b" translate="yes" xml:space="preserve">
          <source>For instance,</source>
          <target state="translated">例如:</target>
        </trans-unit>
        <trans-unit id="0f62f66675d36a6676ee88d1387217b9a0cb3dbf" translate="yes" xml:space="preserve">
          <source>For instance, the following directive</source>
          <target state="translated">例如,以下指令</target>
        </trans-unit>
        <trans-unit id="ebee772072092b992aca9c6d2cc8fa41fdbcc537" translate="yes" xml:space="preserve">
          <source>For internal usage. Do not use.</source>
          <target state="translated">供内部使用。请勿使用。</target>
        </trans-unit>
        <trans-unit id="283fb548dad94e8eb61f71a2d771205400c5b6df" translate="yes" xml:space="preserve">
          <source>For interoperability with C see also the &lt;a href=&quot;manual#implementation-specific-pragmas-bitsize-pragma&quot;&gt;bitsize pragma&lt;/a&gt;.</source>
          <target state="translated">有关与C的互操作性，另请参见&lt;a href=&quot;manual#implementation-specific-pragmas-bitsize-pragma&quot;&gt;bitssize编译指示&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8770baa4a92dda2f0c75267da1bf45a501c6f548" translate="yes" xml:space="preserve">
          <source>For iterators, a component of a tuple return type can have a &lt;code&gt;var&lt;/code&gt; type too:</source>
          <target state="translated">对于迭代器，元组返回类型的组件也可以具有 &lt;code&gt;var&lt;/code&gt; 类型：</target>
        </trans-unit>
        <trans-unit id="1bec3615cf893c57a0cbb546697b4dd32edca860" translate="yes" xml:space="preserve">
          <source>For let variables the same pragmas are available as for ordinary variables.</source>
          <target state="translated">对于let变量,可以使用与普通变量相同的实用方法。</target>
        </trans-unit>
        <trans-unit id="49a6ab6b290c8e19b29832308355873e4c0d7ae9" translate="yes" xml:space="preserve">
          <source>For let variables, the same pragmas are available as for ordinary variables.</source>
          <target state="translated">对于let变量,可以使用与普通变量相同的实用程序。</target>
        </trans-unit>
        <trans-unit id="49cb65cc68c3fe05d8b7330df0cdf8005318cfe1" translate="yes" xml:space="preserve">
          <source>For loggers that log to a console or to files, only error and fatal messages will cause their output buffers to be flushed immediately. Use the &lt;a href=&quot;io#flushFile,File&quot;&gt;flushFile proc&lt;/a&gt; to flush the buffer manually if needed.</source>
          <target state="translated">对于登录到控制台或文件的记录器，仅错误和致命消息会导致其输出缓冲区立即被刷新。如果需要，请使用&lt;a href=&quot;io#flushFile,File&quot;&gt;flushFile proc&lt;/a&gt;手动刷新缓冲区。</target>
        </trans-unit>
        <trans-unit id="3e60368696919ec36aed35327857c6a7975842e7" translate="yes" xml:space="preserve">
          <source>For loop macro</source>
          <target state="translated">循环宏</target>
        </trans-unit>
        <trans-unit id="7ec1a5d2526c1a701579992b7f06bf43e3a282a0" translate="yes" xml:space="preserve">
          <source>For loop macros</source>
          <target state="translated">对于循环宏</target>
        </trans-unit>
        <trans-unit id="4c0c7feb9fa0ff4f152b87b5bc78bff622fe2f93" translate="yes" xml:space="preserve">
          <source>For more information read &lt;a href=&quot;http://www.unix.com/man-page/posix/3/utimes/&quot;&gt;http://www.unix.com/man-page/posix/3/utimes/&lt;/a&gt;.</source>
          <target state="translated">有关更多信息，请阅读&lt;a href=&quot;http://www.unix.com/man-page/posix/3/utimes/&quot;&gt;http://www.unix.com/man-page/posix/3/utimes/&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="26999bb874354b41edf984406af868ff0453d287" translate="yes" xml:space="preserve">
          <source>For more procedures dealing with &lt;code&gt;typedesc&lt;/code&gt;, see &lt;a href=&quot;typetraits&quot;&gt;typetraits module&lt;/a&gt;.</source>
          <target state="translated">有关处理 &lt;code&gt;typedesc&lt;/code&gt; 的更多过程，请参见&lt;a href=&quot;typetraits&quot;&gt;typetraits模块&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b270b757b3673b1757f055c08aa37dc2ffdc3b3a" translate="yes" xml:space="preserve">
          <source>For most applications using &lt;code&gt;asyncnet&lt;/code&gt; is the way to go as it builds over all the layers, providing some extra features such as buffering.</source>
          <target state="translated">对于大多数使用 &lt;code&gt;asyncnet&lt;/code&gt; 的应用程序来说，它是一种遍历所有层的方法，它提供了一些额外的功能，例如缓冲。</target>
        </trans-unit>
        <trans-unit id="b855e8d2a69b94fb603cd76d8ffd3b97477d2b9d" translate="yes" xml:space="preserve">
          <source>For most purposes you do not need to worry about the &lt;code&gt;Delegate&lt;/code&gt; type. The &lt;code&gt;AsyncSocket&lt;/code&gt; is what you are after. It's a reference to the &lt;code&gt;AsyncSocketObj&lt;/code&gt; object. This object defines events which you should overwrite by your own procedures.</source>
          <target state="translated">对于大多数目的，您不必担心 &lt;code&gt;Delegate&lt;/code&gt; 类型。该 &lt;code&gt;AsyncSocket&lt;/code&gt; 是你所追求的。它是对 &lt;code&gt;AsyncSocketObj&lt;/code&gt; 对象的引用。该对象定义事件，您应通过自己的过程覆盖这些事件。</target>
        </trans-unit>
        <trans-unit id="82c56a62c887a5008858ef06fc31221465f85713" translate="yes" xml:space="preserve">
          <source>For non ordinal types it is not possible to list every possible value and so these always require an &lt;code&gt;else&lt;/code&gt; part.</source>
          <target state="translated">对于非序数类型，不可能列出每个可能的值，因此，这些总是需要 &lt;code&gt;else&lt;/code&gt; 部分。</target>
        </trans-unit>
        <trans-unit id="829c51c0d379c6a48e2d4b80c8983380a75c1843" translate="yes" xml:space="preserve">
          <source>For non-ordinal types, it is not possible to list every possible value and so these always require an &lt;code&gt;else&lt;/code&gt; part.</source>
          <target state="translated">对于非普通类型，不可能列出所有可能的值，因此这些总是需要 &lt;code&gt;else&lt;/code&gt; 部分。</target>
        </trans-unit>
        <trans-unit id="f2b8bbe837ee8842537829c10888fa08ecf522a6" translate="yes" xml:space="preserve">
          <source>For now, a closure iterator cannot be evaluated at compile time.</source>
          <target state="translated">目前,闭包迭代器不能在编译时被评估。</target>
        </trans-unit>
        <trans-unit id="60442f2e1ea7e96188f7e824d5499a2b5d0cca4e" translate="yes" xml:space="preserve">
          <source>For now, a closure iterator cannot be executed at compile time.</source>
          <target state="translated">目前,在编译时不能执行闭包迭代器。</target>
        </trans-unit>
        <trans-unit id="25d429d625fe5e6a8fac368190dac2b15a574c80" translate="yes" xml:space="preserve">
          <source>For object oriented programming, the syntax &lt;code&gt;obj.method(args)&lt;/code&gt; can be used instead of &lt;code&gt;method(obj, args)&lt;/code&gt;. The parentheses can be omitted if there are no remaining arguments: &lt;code&gt;obj.len&lt;/code&gt; (instead of &lt;code&gt;len(obj)&lt;/code&gt;).</source>
          <target state="translated">对于面向对象的编程，可以使用语法 &lt;code&gt;obj.method(args)&lt;/code&gt; 代替 &lt;code&gt;method(obj, args)&lt;/code&gt; 。如果没有剩余参数，则可以省略括号： &lt;code&gt;obj.len&lt;/code&gt; （而不是 &lt;code&gt;len(obj)&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="dfb03b9201a2dc62164a5ee1c24ca9a191e921f2" translate="yes" xml:space="preserve">
          <source>For object-oriented programming, the syntax &lt;code&gt;obj.method(args)&lt;/code&gt; can be used instead of &lt;code&gt;method(obj, args)&lt;/code&gt;. The parentheses can be omitted if there are no remaining arguments: &lt;code&gt;obj.len&lt;/code&gt; (instead of &lt;code&gt;len(obj)&lt;/code&gt;).</source>
          <target state="translated">对于面向对象的编程，可以使用语法 &lt;code&gt;obj.method(args)&lt;/code&gt; 代替 &lt;code&gt;method(obj, args)&lt;/code&gt; 。如果没有剩余参数，则可以省略括号： &lt;code&gt;obj.len&lt;/code&gt; （而不是 &lt;code&gt;len(obj)&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="e047dc8cf0cf0c6f8e9fbc9b5e9a48f6934f18d4" translate="yes" xml:space="preserve">
          <source>For parameters it currently creates implicitly generic routines:</source>
          <target state="translated">对于参数,目前它创建的是隐式通用例程。</target>
        </trans-unit>
        <trans-unit id="0381d3dfe342faa183e25e1ee71de71a0859eee8" translate="yes" xml:space="preserve">
          <source>For procedures $1 is the return type of the procedure, $2 is the name of the procedure and $3 is the parameter list.</source>
          <target state="translated">对于存储过程,1是存储过程的返回类型,2是存储过程的名称,3是参数列表。</target>
        </trans-unit>
        <trans-unit id="34556ac1ba7d733468b2f993f99301502888774e" translate="yes" xml:space="preserve">
          <source>For reasons of type safety and implementation simplicity the expression that &lt;code&gt;spawn&lt;/code&gt; takes is restricted:</source>
          <target state="translated">出于类型安全和实现简单的原因， &lt;code&gt;spawn&lt;/code&gt; 的表达式受到限制：</target>
        </trans-unit>
        <trans-unit id="531f693384cd4ad63c34772dfec0f60d10560ced" translate="yes" xml:space="preserve">
          <source>For server sockets the only event you need to worry about is the &lt;code&gt;handleAccept&lt;/code&gt; event, in your handleAccept proc you should call &lt;code&gt;accept&lt;/code&gt; on the server socket which will give you the client which is connecting. You should then set any events that you want to use on that client and add it to your dispatcher using the &lt;code&gt;register&lt;/code&gt; procedure.</source>
          <target state="translated">对于服务器套接字，您唯一需要担心的事件是 &lt;code&gt;handleAccept&lt;/code&gt; 事件，在handleAccept proc中，您应该在服务器套接字上调用 &lt;code&gt;accept&lt;/code&gt; ，这将为您提供正在连接的客户端。然后，您应该设置要在该客户端上使用的所有事件，并使用 &lt;code&gt;register&lt;/code&gt; 过程将其添加到调度程序中。</target>
        </trans-unit>
        <trans-unit id="38d9bef073eca3a25be73089c4f87edb342cf60c" translate="yes" xml:space="preserve">
          <source>For statement</source>
          <target state="translated">对于声明</target>
        </trans-unit>
        <trans-unit id="98762f11c3ec90831e05ecce839645b778fc2401" translate="yes" xml:space="preserve">
          <source>For strict functions it is then enforced that there is no graph that is both mutated and has an element that is an immutable parameter (that is a parameter that is not of type &lt;code&gt;var T&lt;/code&gt;).</source>
          <target state="translated">对于严格的函数，然后强制执行以下操作：不存在既被突变又具有不可变参数（即不属于 &lt;code&gt;var T&lt;/code&gt; 类型的参数）的元素的图。</target>
        </trans-unit>
        <trans-unit id="50e66b9d8bd4ebf421c876d84099cdc2470a333b" translate="yes" xml:space="preserve">
          <source>For strings and numeric types the optional argument is a so-called &quot;standard format specifier&quot;.</source>
          <target state="translated">对于字符串和数字类型,可选的参数是所谓的 &quot;标准格式指定器&quot;。</target>
        </trans-unit>
        <trans-unit id="b2b62c1266c113a9bc445db1d2caf01166f03f95" translate="yes" xml:space="preserve">
          <source>For targets with very restricted memory, it might be beneficial to pass some additional flags to both the Nim compiler and the C compiler and/or linker to optimize the build for size. For example, the following flags can be used when targeting a gcc compiler:</source>
          <target state="translated">对于内存非常受限的目标,向Nim编译器和C编译器和/或链接器传递一些额外的标志,以优化构建的大小,这可能是有益的。例如,当目标是gcc编译器时,可以使用以下标志。</target>
        </trans-unit>
        <trans-unit id="5118253ef90c345c13ce011297a04d47555e82ea" translate="yes" xml:space="preserve">
          <source>For the &lt;code&gt;NimNode&lt;/code&gt; type, the &lt;code&gt;[]&lt;/code&gt; operator has been overloaded: &lt;code&gt;n[i]&lt;/code&gt; is &lt;code&gt;n&lt;/code&gt;'s &lt;code&gt;i&lt;/code&gt;-th child.</source>
          <target state="translated">对于 &lt;code&gt;NimNode&lt;/code&gt; 类型， &lt;code&gt;[]&lt;/code&gt; 运算符已重载： &lt;code&gt;n[i]&lt;/code&gt; 是 &lt;code&gt;n&lt;/code&gt; 的第 &lt;code&gt;i&lt;/code&gt; 个子元素。</target>
        </trans-unit>
        <trans-unit id="5b23d075b9b8ec0ab77df3a4277b9163e7d757d8" translate="yes" xml:space="preserve">
          <source>For the &lt;code&gt;standalone&lt;/code&gt; target one needs to provide a file &lt;code&gt;panicoverride.nim&lt;/code&gt;. See &lt;code&gt;tests/manyloc/standalone/panicoverride.nim&lt;/code&gt; for an example implementation. Additionally, users should specify the amount of heap space to use with the &lt;code&gt;-d:StandaloneHeapSize=&amp;lt;size&amp;gt;&lt;/code&gt; command line switch. Note that the total heap size will be &lt;code&gt;&amp;lt;size&amp;gt; * sizeof(float64)&lt;/code&gt;.</source>
          <target state="translated">对于 &lt;code&gt;standalone&lt;/code&gt; 目标，需要提供一个文件 &lt;code&gt;panicoverride.nim&lt;/code&gt; 。有关示例实现，请参见 &lt;code&gt;tests/manyloc/standalone/panicoverride.nim&lt;/code&gt; 。此外，用户应指定 &lt;code&gt;-d:StandaloneHeapSize=&amp;lt;size&amp;gt;&lt;/code&gt; 命令行开关要使用的堆空间量。请注意，总堆大小将为 &lt;code&gt;&amp;lt;size&amp;gt; * sizeof(float64)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9bd447b4c81354efb7aa284920ba753a6e07ea3a" translate="yes" xml:space="preserve">
          <source>For the JavaScript backend, log messages are written to the console, and &lt;code&gt;useStderr&lt;/code&gt; is ignored.</source>
          <target state="translated">对于JavaScript后端，日志消息被写入控制台，而 &lt;code&gt;useStderr&lt;/code&gt; 被忽略。</target>
        </trans-unit>
        <trans-unit id="df5b6b1186df78078d05adfad602fa92baed5303" translate="yes" xml:space="preserve">
          <source>For the duration of the borrow operation, no mutations to the borrowed locations may be performed except via the potentially mutable view that borrowed from the location. The borrowed location is said to be &lt;em&gt;sealed&lt;/em&gt; during the borrow.</source>
          <target state="translated">在借阅操作期间，除非通过从该位置借来的潜在可变视图，否则不得对借入位置进行任何更改。据说借用的地点在借用期间是&lt;em&gt;密封&lt;/em&gt;的。</target>
        </trans-unit>
        <trans-unit id="e28f94973a02fa8efb6d2d9f2bdf6b84f68ef4a9" translate="yes" xml:space="preserve">
          <source>For the purposes of code generation, all static params are treated as generic params - the proc will be compiled separately for each unique supplied value (or combination of values).</source>
          <target state="translated">为了生成代码的目的,所有静态参数都被视为通用参数--proc将为每一个独特的提供值(或值的组合)单独编译。</target>
        </trans-unit>
        <trans-unit id="c2c74c1ee472ad29842c87cdf299a669bad39ffc" translate="yes" xml:space="preserve">
          <source>For third party pragmas, it depends on its implementation but uses the same syntax.</source>
          <target state="translated">对于第三方实用名词,它取决于其实现,但使用相同的语法。</target>
        </trans-unit>
        <trans-unit id="7a599903250272239a970ef2b91cb9fbc4cc7a6e" translate="yes" xml:space="preserve">
          <source>For this kind of query the IDE will most likely ignore all the type/signature info provided by Nimsuggest and concentrate on the filename, line and column position of the multiple returned answers.</source>
          <target state="translated">对于这种查询,IDE很可能会忽略Nimsuggest提供的所有类型/签名信息,而专注于多个返回答案的文件名、行和列的位置。</target>
        </trans-unit>
        <trans-unit id="21e8a16f7bac8ed1e3af0648dd4af16f400ffa1b" translate="yes" xml:space="preserve">
          <source>For this kind of query the IDE will most likely ignore all the type/signature info provided by idetools and concentrate on the filename, line and column position of the multiple returned answers.</source>
          <target state="translated">对于这种查询,IDE很可能会忽略idetools提供的所有类型/签名信息,而专注于多个返回答案的文件名、行和列的位置。</target>
        </trans-unit>
        <trans-unit id="4f2a830522144ce433b177e154438fbea54f01ba" translate="yes" xml:space="preserve">
          <source>For unbuffered sockets this function makes no effort to read all the data requested. It will return as much data as the operating system gives it.</source>
          <target state="translated">对于无缓冲的套接字,这个函数不会努力读取所有请求的数据。它将返回操作系统所提供的数据。</target>
        </trans-unit>
        <trans-unit id="acc44d22bdd9ff1a4f672371a2d978f27524f187" translate="yes" xml:space="preserve">
          <source>For unlimited queue set &lt;code&gt;maxItems&lt;/code&gt; to 0.</source>
          <target state="translated">对于无限队列，请将 &lt;code&gt;maxItems&lt;/code&gt; 设置为0。</target>
        </trans-unit>
        <trans-unit id="f29c22d667f2c9809200dc3c652631cb432b95f9" translate="yes" xml:space="preserve">
          <source>For variables $1 in the format string represents the type of the variable and $2 is the name of the variable.</source>
          <target state="translated">对于变量来说,格式字符串中的1元代表变量的类型,2元是变量的名称。</target>
        </trans-unit>
        <trans-unit id="d0acef1b99b298eedf58333627b04e7ade8e069b" translate="yes" xml:space="preserve">
          <source>For variables, $1 in the format string represents the type of the variable and $2 is the name of the variable.</source>
          <target state="translated">对于变量,格式字符串中的1元代表变量的类型,2元是变量的名称。</target>
        </trans-unit>
        <trans-unit id="0f11073e7aacef9a5488a1392bb54a53d57c2a8f" translate="yes" xml:space="preserve">
          <source>Forces a full garbage collection pass. Ordinary code does not need to call this (and should not).</source>
          <target state="translated">强制进行一次完整的垃圾收集。普通代码不需要调用这个(也不应该)。</target>
        </trans-unit>
        <trans-unit id="b57f0c15791c6915cb3fe418d16a695f3e93406f" translate="yes" xml:space="preserve">
          <source>Forces the field to be centered within the available space.</source>
          <target state="translated">强制将字段置于可用空间的中心。</target>
        </trans-unit>
        <trans-unit id="d7b27b7009675d9666afa3d1598bf15fcf934615" translate="yes" xml:space="preserve">
          <source>Forces the field to be left-aligned within the available space. (This is the default for strings.)</source>
          <target state="translated">强制字段在可用空间内左对齐。(这是字符串的默认值。)</target>
        </trans-unit>
        <trans-unit id="5401c23ac1c35518b24a7af9c1a0f66703531dae" translate="yes" xml:space="preserve">
          <source>Forces the field to be right-aligned within the available space. (This is the default for numbers.)</source>
          <target state="translated">强制要求字段在可用空间内右对齐。(对于数字来说,这是默认的。)</target>
        </trans-unit>
        <trans-unit id="5e823a3f6053e51d24188588d1235d16fdedb5e9" translate="yes" xml:space="preserve">
          <source>Foreign function interface</source>
          <target state="translated">外来函数接口</target>
        </trans-unit>
        <trans-unit id="62f5fffe14b79a85984464c3815f9c99671b76a7" translate="yes" xml:space="preserve">
          <source>Format &lt;code&gt;dt&lt;/code&gt; using the format specified by &lt;code&gt;f&lt;/code&gt;.</source>
          <target state="translated">使用 &lt;code&gt;f&lt;/code&gt; 指定的格式格式化 &lt;code&gt;dt&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dc91fa1264bb70f29dff1283c89ce3d70708411e" translate="yes" xml:space="preserve">
          <source>Format a log message using the &lt;code&gt;frmt&lt;/code&gt; format string, &lt;code&gt;level&lt;/code&gt; and varargs. See the module documentation for the format string syntax.</source>
          <target state="translated">使用 &lt;code&gt;frmt&lt;/code&gt; 格式的字符串， &lt;code&gt;level&lt;/code&gt; 和varargs 格式化日志消息。有关格式字符串语法，请参见模块文档。</target>
        </trans-unit>
        <trans-unit id="23df153e7e0e64b21db9ad3e5939710409b9a30c" translate="yes" xml:space="preserve">
          <source>Format strings</source>
          <target state="translated">格式化字符串</target>
        </trans-unit>
        <trans-unit id="d5fd1007724ad6493fdeb7d3d2e1c8dcb319f39f" translate="yes" xml:space="preserve">
          <source>Format strings support the following variables which must be prefixed with the dollar operator (&lt;code&gt;$&lt;/code&gt;):</source>
          <target state="translated">格式字符串支持以下变量，这些变量必须以 &lt;code&gt;$&lt;/code&gt; 运算符（$）为前缀：</target>
        </trans-unit>
        <trans-unit id="f473a4a2cbe85328e51c6376b1faaa820f7130a0" translate="yes" xml:space="preserve">
          <source>FormatStr:</source>
          <target state="translated">FormatStr:</target>
        </trans-unit>
        <trans-unit id="320a4b0cd77d1079692787bfa5cb01d1507b5a80" translate="yes" xml:space="preserve">
          <source>Formats a log message at the specified level with the given format string.</source>
          <target state="translated">用给定的格式字符串在指定级别上格式化日志消息。</target>
        </trans-unit>
        <trans-unit id="9a5aa38b4d926a0fd6b7ab965445c10223a0ef52" translate="yes" xml:space="preserve">
          <source>Formatting floats</source>
          <target state="translated">格式化浮动</target>
        </trans-unit>
        <trans-unit id="119b045ed7d9e9597e047eb5230d1263cac6b285" translate="yes" xml:space="preserve">
          <source>Formatting strings</source>
          <target state="translated">格式化字符串</target>
        </trans-unit>
        <trans-unit id="69f690f33d986c3349097e854e0eb9e08b5cc4f9" translate="yes" xml:space="preserve">
          <source>Forward declarations</source>
          <target state="translated">远期声明</target>
        </trans-unit>
        <trans-unit id="863ed164c9c45905d0e8f390e051e690266656e8" translate="yes" xml:space="preserve">
          <source>Forward definitions work properly, you just need to always add the &lt;code&gt;{.async.}&lt;/code&gt; pragma:</source>
          <target state="translated">转发定义可以正常工作，您只需要始终添加 &lt;code&gt;{.async.}&lt;/code&gt; 编译指示即可：</target>
        </trans-unit>
        <trans-unit id="f8c5a89a52fbfb7fb81f2ad9c8f8020cd9035054" translate="yes" xml:space="preserve">
          <source>Found nodes satisfying the condition will be appended to the &lt;code&gt;result&lt;/code&gt; sequence.</source>
          <target state="translated">找到的满足条件的节点将添加到 &lt;code&gt;result&lt;/code&gt; 序列中。</target>
        </trans-unit>
        <trans-unit id="9cd6940a09171e7ee9b5773accc63e225abdd1b0" translate="yes" xml:space="preserve">
          <source>Found nodes satisfying the condition will be appended to the &lt;em&gt;result&lt;/em&gt; sequence, which can't be nil or the proc will crash. Usage example:</source>
          <target state="translated">找到的满足条件的节点将被追加到&lt;em&gt;结果&lt;/em&gt;序列中，该序列不能为nil，否则proc将崩溃。用法示例：</target>
        </trans-unit>
        <trans-unit id="9451eac4434aa603b5d91f3457a805bcfe91aafd" translate="yes" xml:space="preserve">
          <source>Free memory referenced by SSLContext.</source>
          <target state="translated">释放SSLContext引用的内存。</target>
        </trans-unit>
        <trans-unit id="8839c93749a51b8f4573af0373c721bea8047dd5" translate="yes" xml:space="preserve">
          <source>Free memory referenced by SslContext.</source>
          <target state="translated">释放SslContext引用的内存。</target>
        </trans-unit>
        <trans-unit id="5fb76bd366f4e6ba99981748b97fcc7bbe8e1d1c" translate="yes" xml:space="preserve">
          <source>Frees a NULL terminated cstringArray.</source>
          <target state="translated">释放一个NULL终止的cstringArray。</target>
        </trans-unit>
        <trans-unit id="a3d4cf3a87e9cdbcca08f62555c9cfbef0748ca7" translate="yes" xml:space="preserve">
          <source>Frees the memory allocated with &lt;code&gt;alloc&lt;/code&gt;, &lt;code&gt;alloc0&lt;/code&gt; or &lt;code&gt;realloc&lt;/code&gt;.</source>
          <target state="translated">释放通过 &lt;code&gt;alloc&lt;/code&gt; ， &lt;code&gt;alloc0&lt;/code&gt; 或 &lt;code&gt;realloc&lt;/code&gt; 分配的内存。</target>
        </trans-unit>
        <trans-unit id="d269a02d2690912f030db18722ad0f6be8902d2f" translate="yes" xml:space="preserve">
          <source>Frees the memory allocated with &lt;code&gt;allocShared&lt;/code&gt;, &lt;code&gt;allocShared0&lt;/code&gt; or &lt;code&gt;reallocShared&lt;/code&gt;.</source>
          <target state="translated">释放通过 &lt;code&gt;allocShared&lt;/code&gt; ， &lt;code&gt;allocShared0&lt;/code&gt; 或 &lt;code&gt;reallocShared&lt;/code&gt; 分配的内存。</target>
        </trans-unit>
        <trans-unit id="c521c5fef3e2e4b71db5a2712cb612be33ee5fc9" translate="yes" xml:space="preserve">
          <source>Frees the memory allocated with &lt;code&gt;createShared&lt;/code&gt;, &lt;code&gt;createSharedU&lt;/code&gt; or &lt;code&gt;resizeShared&lt;/code&gt;.</source>
          <target state="translated">释放通过 &lt;code&gt;createShared&lt;/code&gt; ， &lt;code&gt;createSharedU&lt;/code&gt; 或 &lt;code&gt;resizeShared&lt;/code&gt; 分配的内存。</target>
        </trans-unit>
        <trans-unit id="5d32f0b040e1e463f6af2df09fd6c384e49112a6" translate="yes" xml:space="preserve">
          <source>Frees the resources associated with the condition variable.</source>
          <target state="translated">释放与条件变量相关的资源。</target>
        </trans-unit>
        <trans-unit id="217bf834335a4b2616a03e550f18eef5531ae2a0" translate="yes" xml:space="preserve">
          <source>Frees the resources associated with the lock.</source>
          <target state="translated">释放与锁相关的资源。</target>
        </trans-unit>
        <trans-unit id="3012e87b890b08501d892d7aaf9956fe4b6d7353" translate="yes" xml:space="preserve">
          <source>Frees the thread local heap. Runs every finalizer if &lt;code&gt;runFinalizers&lt;/code&gt; is true. If &lt;code&gt;allowGcAfterwards&lt;/code&gt; is true, a minimal amount of allocation happens to ensure the GC can continue to work after the call to &lt;code&gt;deallocHeap&lt;/code&gt;.</source>
          <target state="translated">释放线程本地堆。如果 &lt;code&gt;runFinalizers&lt;/code&gt; 为true，则运行每个终结器。如果 &lt;code&gt;allowGcAfterwards&lt;/code&gt; 为true，则会发生少量分配，以确保GC在调用 &lt;code&gt;deallocHeap&lt;/code&gt; 之后可以继续工作。</target>
        </trans-unit>
        <trans-unit id="54d3a1861da397f72e90bc587323bda31c9c723e" translate="yes" xml:space="preserve">
          <source>Friendlier version of the low-level &lt;code&gt;sendTo&lt;/code&gt;.</source>
          <target state="translated">低级 &lt;code&gt;sendTo&lt;/code&gt; 的友好版本。</target>
        </trans-unit>
        <trans-unit id="0651a01fbb901bf5682fe3d0d43a4123bbbc43b0" translate="yes" xml:space="preserve">
          <source>From &lt;code&gt;n&lt;/code&gt; up to &lt;code&gt;m&lt;/code&gt; times &lt;code&gt;E&lt;/code&gt;</source>
          <target state="translated">从 &lt;code&gt;n&lt;/code&gt; 到 &lt;code&gt;m&lt;/code&gt; 倍 &lt;code&gt;E&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a1ea6e8437394953edbfda643d827e4d4ef3e935" translate="yes" xml:space="preserve">
          <source>From import statement</source>
          <target state="translated">来自进口报表</target>
        </trans-unit>
        <trans-unit id="bee0ffc05592a90a71b79296ba74ad204f6a4854" translate="yes" xml:space="preserve">
          <source>From statement</source>
          <target state="translated">来自报表</target>
        </trans-unit>
        <trans-unit id="089c0e110f7531cecf41cc21ee48d15578ad6130" translate="yes" xml:space="preserve">
          <source>Full month string, properly capitalized.</source>
          <target state="translated">满月串,适当大写。</target>
        </trans-unit>
        <trans-unit id="1efdfc3c3fae4cb87be2f821dbd15c17e614eb81" translate="yes" xml:space="preserve">
          <source>Full path to the file containing the symbol.</source>
          <target state="translated">符号文件的完整路径。</target>
        </trans-unit>
        <trans-unit id="d10e5187c8d103dd4ab7d6a2e82e22d06d193e5e" translate="yes" xml:space="preserve">
          <source>Full qualified path of the symbol. If you are querying a symbol defined in the &lt;code&gt;proj.nim&lt;/code&gt; file, this would have the form &lt;code&gt;proj.symbolName&lt;/code&gt;.</source>
          <target state="translated">符号的完整限定路径。如果要查询 &lt;code&gt;proj.nim&lt;/code&gt; 文件中定义的符号，则格式为 &lt;code&gt;proj.symbolName&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9aa17034b6f9cc3733582b028743a15d4ca9a823" translate="yes" xml:space="preserve">
          <source>Full qualitifed path of the symbol. If you are querying a symbol defined in the &lt;code&gt;proj.nim&lt;/code&gt; file, this would have the form &lt;code&gt;proj.symbolName&lt;/code&gt;.</source>
          <target state="translated">符号的完整限定路径。如果要查询 &lt;code&gt;proj.nim&lt;/code&gt; 文件中定义的符号，则格式为 &lt;code&gt;proj.symbolName&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="25eab966ab009c6f9396a404c34a6efc2aec6a35" translate="yes" xml:space="preserve">
          <source>Full string for the day of the week.</source>
          <target state="translated">周日满弦。</target>
        </trans-unit>
        <trans-unit id="0de75419f9f0e58e30539063692f61bb63a8c14e" translate="yes" xml:space="preserve">
          <source>Full:</source>
          <target state="translated">Full:</target>
        </trans-unit>
        <trans-unit id="baf7883587d0db8919319600b0564cd5911762d2" translate="yes" xml:space="preserve">
          <source>Fully qualified path of the symbol. If you are querying a symbol defined in the &lt;code&gt;proj.nim&lt;/code&gt; file, this would have the form &lt;code&gt;proj.symbolName&lt;/code&gt;.</source>
          <target state="translated">符号的完全限定路径。如果要查询 &lt;code&gt;proj.nim&lt;/code&gt; 文件中定义的符号，则格式为 &lt;code&gt;proj.symbolName&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="56a52eaf688c8eb99e5f2a5f4ed34a39517d41a8" translate="yes" xml:space="preserve">
          <source>Fully supported OS: MacOSX, FreeBSD, OpenBSD, NetBSD, Linux (except for Android).</source>
          <target state="translated">完全支持的操作系统:MacOSX、FreeBSD、OpenBSD、NetBSD、Linux(Android除外)。</target>
        </trans-unit>
        <trans-unit id="d14c246c1269ccb4359c67583949d6908348f108" translate="yes" xml:space="preserve">
          <source>Func</source>
          <target state="translated">Func</target>
        </trans-unit>
        <trans-unit id="f30878239d150c44656cb1807dfee83bfae26ea8" translate="yes" xml:space="preserve">
          <source>Funcs</source>
          <target state="translated">Funcs</target>
        </trans-unit>
        <trans-unit id="39625e7c38b6dfbbccf8d818160b5949731fbcc2" translate="yes" xml:space="preserve">
          <source>Function that will be called instead of &lt;code&gt;stdmsg.write&lt;/code&gt; when printing stacktrace. Unstable API.</source>
          <target state="translated">打印stacktrace时将代替 &lt;code&gt;stdmsg.write&lt;/code&gt; 调用的函数。API不稳定。</target>
        </trans-unit>
        <trans-unit id="103b82fef1279c926f44a70b4dcbb7c19d6cba9c" translate="yes" xml:space="preserve">
          <source>Further complications</source>
          <target state="translated">进一步的并发症</target>
        </trans-unit>
        <trans-unit id="bab2f0e91a508ebe1da51e92c439b6ffc92bda93" translate="yes" xml:space="preserve">
          <source>Furthermore no backtracking is performed, if parsing fails after a value has already been bound to a matched subexpression this value is not restored to its original value. This rarely causes problems in practice and if it does for you, it's easy enough to bind to a temporary variable first.</source>
          <target state="translated">此外,没有进行回溯,如果在一个值已经绑定到匹配的子表达式后解析失败,这个值不会恢复到原来的值。这在实践中很少会引起问题,如果对你来说是这样的话,很容易就可以先绑定到一个临时变量。</target>
        </trans-unit>
        <trans-unit id="69610179c37adaec5ee39f67c094bcf4f227a4f5" translate="yes" xml:space="preserve">
          <source>Furthermore, every generic type automatically creates a type class of the same name that will match any instantiation of the generic type.</source>
          <target state="translated">此外,每个通用类型都会自动创建一个同名的类型类,它将与通用类型的任何实例相匹配。</target>
        </trans-unit>
        <trans-unit id="020268db057d0d374d177846575179b989319d62" translate="yes" xml:space="preserve">
          <source>Future directions</source>
          <target state="translated">未来的方向</target>
        </trans-unit>
        <trans-unit id="08cefc2bd0b44f2a8a17df6ae2c7647385a570c9" translate="yes" xml:space="preserve">
          <source>Future directions:</source>
          <target state="translated">未来方向:</target>
        </trans-unit>
        <trans-unit id="628f36f2b247989f52efae291bc0d00b5bc12f2e" translate="yes" xml:space="preserve">
          <source>Future objects can also store a callback procedure which will be called automatically once the future completes.</source>
          <target state="translated">未来的对象还可以存储一个回调过程,一旦未来完成,这个回调过程就会自动调用。</target>
        </trans-unit>
        <trans-unit id="f52ca92f6deff645322e492b01bf4e7e07479dc7" translate="yes" xml:space="preserve">
          <source>Futures should &lt;strong&gt;never&lt;/strong&gt; be discarded. This is because they may contain errors. If you do not care for the result of a Future then you should use the &lt;code&gt;asyncCheck&lt;/code&gt; procedure instead of the &lt;code&gt;discard&lt;/code&gt; keyword.</source>
          <target state="translated">期货&lt;strong&gt;永远不&lt;/strong&gt;应该被丢弃。这是因为它们可能包含错误。如果你不关心为未来的结果，那么你应该使用 &lt;code&gt;asyncCheck&lt;/code&gt; 而不是过程 &lt;code&gt;discard&lt;/code&gt; 关键字。</target>
        </trans-unit>
        <trans-unit id="181a7a6f276dfd96625be640094e14ce07c014e5" translate="yes" xml:space="preserve">
          <source>Futures should &lt;strong&gt;never&lt;/strong&gt; be discarded. This is because they may contain errors. If you do not care for the result of a Future then you should use the &lt;code&gt;asyncCheck&lt;/code&gt; procedure instead of the &lt;code&gt;discard&lt;/code&gt; keyword. Note however that this does not wait for completion, and you should use &lt;code&gt;waitFor&lt;/code&gt; for that purpose.</source>
          <target state="translated">期货&lt;strong&gt;永远不&lt;/strong&gt;应该被丢弃。这是因为它们可能包含错误。如果你不关心为未来的结果，那么你应该使用 &lt;code&gt;asyncCheck&lt;/code&gt; 而不是过程 &lt;code&gt;discard&lt;/code&gt; 关键字。但是请注意，这并不等待完成，因此您应该使用 &lt;code&gt;waitFor&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="56d159d6d60dadf784672c33c747ac7bbedd187d" translate="yes" xml:space="preserve">
          <source>Futures therefore can be thought of as an implementation of the proactor pattern. In this pattern you make a request for an action, and once that action is fulfilled a future is completed with the result of that action. Requests can be made by calling the appropriate functions. For example: calling the &lt;code&gt;recv&lt;/code&gt; function will create a request for some data to be read from a socket. The future which the &lt;code&gt;recv&lt;/code&gt; function returns will then complete once the requested amount of data is read &lt;strong&gt;or&lt;/strong&gt; an exception occurs.</source>
          <target state="translated">因此，可以将期货视为前摄者模式的一种实现。在这种模式下，您请求一个操作，一旦完成该操作，将来就可以完成该操作的结果。可以通过调用适当的函数来发出请求。例如：调用 &lt;code&gt;recv&lt;/code&gt; 函数将创建一个请求，要求从套接字读取某些数据。读取请求的数据量&lt;strong&gt;或&lt;/strong&gt;发生异常后， &lt;code&gt;recv&lt;/code&gt; 函数返回的将来将完成。&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="99a3e18460e703b6b52b26b4155c66c3e3ba24bc" translate="yes" xml:space="preserve">
          <source>GC</source>
          <target state="translated">GC</target>
        </trans-unit>
        <trans-unit id="24886e2768e1ad172ed42c67c3aefd8db070df8a" translate="yes" xml:space="preserve">
          <source>GC safety</source>
          <target state="translated">气相色谱仪安全</target>
        </trans-unit>
        <trans-unit id="eaa3fa39346ddc09dbf2bdba8048d23ac925a06b" translate="yes" xml:space="preserve">
          <source>GCStats</source>
          <target state="translated">GCStats</target>
        </trans-unit>
        <trans-unit id="decdf7b7c7e08bf8d9a5d48840bcdaa2ba169aa4" translate="yes" xml:space="preserve">
          <source>GETs the &lt;code&gt;url&lt;/code&gt; and returns a &lt;code&gt;Response&lt;/code&gt; object</source>
          <target state="translated">获取 &lt;code&gt;url&lt;/code&gt; 并返回一个 &lt;code&gt;Response&lt;/code&gt; 对象</target>
        </trans-unit>
        <trans-unit id="3cdc3ef08c097eb553bfa51683db392e9fd2bf94" translate="yes" xml:space="preserve">
          <source>GETs the body and returns it as a string.</source>
          <target state="translated">GETs the body并以字符串形式返回。</target>
        </trans-unit>
        <trans-unit id="7a252097fa66659331b3cddc9019fcc983caa9d2" translate="yes" xml:space="preserve">
          <source>GUI libraries</source>
          <target state="translated">GUI库</target>
        </trans-unit>
        <trans-unit id="84841ccacb20efbdee1996b961b9cb5573918289" translate="yes" xml:space="preserve">
          <source>Garbage collection</source>
          <target state="translated">垃圾收集</target>
        </trans-unit>
        <trans-unit id="9da6215e0b51f061b3fdba1a1ecfc65cbc078c5c" translate="yes" xml:space="preserve">
          <source>GcTypeKinds:</source>
          <target state="translated">GcTypeKinds:</target>
        </trans-unit>
        <trans-unit id="f6e05ce0d9c731cfa7368a04629cc24b4369f36e" translate="yes" xml:space="preserve">
          <source>General approach: AST replay</source>
          <target state="translated">一般方法。AST重播</target>
        </trans-unit>
        <trans-unit id="e8d58703ce9850fb34cef0e5f6a677d9ab6d889a" translate="yes" xml:space="preserve">
          <source>General format. Same as 'g' except switches to 'E' if the number gets to large.</source>
          <target state="translated">一般格式。与'g'相同,但如果数字太大,则切换到'E'。</target>
        </trans-unit>
        <trans-unit id="a78239c87e6d40ce60ad0d42f7de857091c769b8" translate="yes" xml:space="preserve">
          <source>General format. This prints the number as a fixed-point number, unless the number is too large, in which case it switches to 'e' exponent notation.</source>
          <target state="translated">一般格式。这将打印定点数字,除非数字太大,在这种情况下,它将切换到'e'指数符号。</target>
        </trans-unit>
        <trans-unit id="6ab8b3a8d895f749e9bdf5ce934de1c2d1d0b06b" translate="yes" xml:space="preserve">
          <source>Generalized raw string literals</source>
          <target state="translated">通用的原始字符串文字</target>
        </trans-unit>
        <trans-unit id="64fc3c60ac61d616b71e452185b1f4af623a77b5" translate="yes" xml:space="preserve">
          <source>Generate MD5 hash for a file. Result is a 32 character</source>
          <target state="translated">为文件生成MD5哈希值。结果是一个32个字符的</target>
        </trans-unit>
        <trans-unit id="9af7c728cf98e71cf64f9b1972e19c2d127c4a0b" translate="yes" xml:space="preserve">
          <source>Generate MD5 hash for a string. Result is a 32 character hex string with lowercase characters</source>
          <target state="translated">生成一个字符串的MD5哈希值。结果是一个32个字符的十六进制字符串,其中包含小写字符。</target>
        </trans-unit>
        <trans-unit id="194fd628240e5dda215e0b527d6380a53aeafbc6" translate="yes" xml:space="preserve">
          <source>Generate hash of Oid for use in hashtables</source>
          <target state="translated">生成Oid的哈希值,用于哈希表。</target>
        </trans-unit>
        <trans-unit id="98d2101f8c390609a97dc36588eb2c2b928336e4" translate="yes" xml:space="preserve">
          <source>Generated C code directory</source>
          <target state="translated">生成的C代码目录</target>
        </trans-unit>
        <trans-unit id="35615d886a02b1f0364e6b5e3dd2d7770360bec5" translate="yes" xml:space="preserve">
          <source>Generates a &lt;code&gt;SecureHash&lt;/code&gt; from a &lt;code&gt;str&lt;/code&gt;.</source>
          <target state="translated">从 &lt;code&gt;str&lt;/code&gt; 生成一个 &lt;code&gt;SecureHash&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="39284be70eadfcb17ab98430a8b07978b57a2e7c" translate="yes" xml:space="preserve">
          <source>Generates a &lt;code&gt;SecureHash&lt;/code&gt; from a file.</source>
          <target state="translated">从文件生成 &lt;code&gt;SecureHash&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="559a8bb5a2a73a549d431251cef37d8a30c8d5fd" translate="yes" xml:space="preserve">
          <source>Generates a fresh symbol that is guaranteed to be unique. The symbol needs to occur in a declaration context.</source>
          <target state="translated">生成一个保证唯一的新符号。符号需要在声明上下文中出现。</target>
        </trans-unit>
        <trans-unit id="755850f873129edef75e0603bc32b9c1db81e647" translate="yes" xml:space="preserve">
          <source>Generates a tuple constructor expression listing all the local variables in the current scope.</source>
          <target state="translated">生成一个元组构造函数表达式,列出当前作用域中的所有局部变量。</target>
        </trans-unit>
        <trans-unit id="120bc028779ab10d2c454afa8b36ea6cb77e7649" translate="yes" xml:space="preserve">
          <source>Generates a volatile load of the value stored in the container &lt;code&gt;src&lt;/code&gt;. Note that this only effects code generation on &lt;code&gt;C&lt;/code&gt; like backends</source>
          <target state="translated">生成存储在容器 &lt;code&gt;src&lt;/code&gt; 中的值的易失性负载。请注意，这只会影响 &lt;code&gt;C&lt;/code&gt; 等后端的代码生成</target>
        </trans-unit>
        <trans-unit id="e0fc580b3d486415cebb9117f5f9725b055316cc" translate="yes" xml:space="preserve">
          <source>Generates a volatile store into the container &lt;code&gt;dest&lt;/code&gt; of the value &lt;code&gt;val&lt;/code&gt;. Note that this only effects code generation on &lt;code&gt;C&lt;/code&gt; like backends</source>
          <target state="translated">在值 &lt;code&gt;val&lt;/code&gt; 的容器 &lt;code&gt;dest&lt;/code&gt; 中生成易失性存储。请注意，这只会影响 &lt;code&gt;C&lt;/code&gt; 等后端的代码生成</target>
        </trans-unit>
        <trans-unit id="289133444536aa23e14085f7d4547c38b4614e68" translate="yes" xml:space="preserve">
          <source>Generates an interpreting event parser &lt;em&gt;proc&lt;/em&gt; according to the specified PEG AST and handler code blocks. The &lt;em&gt;proc&lt;/em&gt; can be called with a string to be parsed and will execute the handler code blocks whenever their associated grammar element is matched. It returns -1 if the string does not match, else the length of the total match. The following example code evaluates an arithmetic expression defined by a simple PEG:</source>
          <target state="translated">根据指定的PEG AST和处理程序代码块生成解释事件解析器&lt;em&gt;proc&lt;/em&gt;。可以使用要解析的字符串来调用该&lt;em&gt;proc&lt;/em&gt;，并且只要它们的关联语法元素匹配，该&lt;em&gt;proc&lt;/em&gt;将执行处理程序代码块。如果字符串不匹配，则返回-1，否则返回总匹配的长度。以下示例代码评估由简单PEG定义的算术表达式：</target>
        </trans-unit>
        <trans-unit id="da34d01460dd01c931af1769caf2e264a100a2c5" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;a&lt;/code&gt; element.</source>
          <target state="translated">生成HTML &lt;code&gt;a&lt;/code&gt; 元素。</target>
        </trans-unit>
        <trans-unit id="32be55f1b86f94ed09b67ab8f7fdf18ad6137d7c" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;abbr&lt;/code&gt; element.</source>
          <target state="translated">生成HTML &lt;code&gt;abbr&lt;/code&gt; 元素。</target>
        </trans-unit>
        <trans-unit id="4fc4f1abc0b2fd50ff9ece52303ab7796c2b58c8" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;address&lt;/code&gt; element.</source>
          <target state="translated">生成HTML &lt;code&gt;address&lt;/code&gt; 元素。</target>
        </trans-unit>
        <trans-unit id="097cb30b6f31aef82824f3db37f2b2d8671714a4" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;annotation-xml&lt;/code&gt; element. MathML &lt;a href=&quot;https://wikipedia.org/wiki/MathML&quot;&gt;https://wikipedia.org/wiki/MathML&lt;/a&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/MathML/Element/semantics&quot;&gt;https://developer.mozilla.org/en-US/docs/Web/MathML/Element/semantics&lt;/a&gt;</source>
          <target state="translated">生成HTML &lt;code&gt;annotation-xml&lt;/code&gt; 元素。MathML &lt;a href=&quot;https://wikipedia.org/wiki/MathML&quot;&gt;https://wikipedia.org/wiki/MathML &lt;/a&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/MathML/Element/semantics&quot;&gt;https://developer.mozilla.org/en-US/docs/Web/MathML/Element/semantics&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a7186a1cbab5eb0d902bef55e569e69732998ab5" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;annotation&lt;/code&gt; element. MathML &lt;a href=&quot;https://wikipedia.org/wiki/MathML&quot;&gt;https://wikipedia.org/wiki/MathML&lt;/a&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/MathML/Element/semantics&quot;&gt;https://developer.mozilla.org/en-US/docs/Web/MathML/Element/semantics&lt;/a&gt;</source>
          <target state="translated">生成HTML &lt;code&gt;annotation&lt;/code&gt; 元素。MathML &lt;a href=&quot;https://wikipedia.org/wiki/MathML&quot;&gt;https://wikipedia.org/wiki/MathML &lt;/a&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/MathML/Element/semantics&quot;&gt;https://developer.mozilla.org/en-US/docs/Web/MathML/Element/semantics&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="27d3d488209133bc046e1215fc3b05d2d015dd1f" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;area&lt;/code&gt; element.</source>
          <target state="translated">生成HTML &lt;code&gt;area&lt;/code&gt; 元素。</target>
        </trans-unit>
        <trans-unit id="a625db72e199f1050b8a5089779786f6974e8b96" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;article&lt;/code&gt; element.</source>
          <target state="translated">生成HTML &lt;code&gt;article&lt;/code&gt; 元素。</target>
        </trans-unit>
        <trans-unit id="7c8abbecd1b46dea914db26539726b5fde4d2f55" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;aside&lt;/code&gt; element.</source>
          <target state="translated">生成HTML &lt;code&gt;aside&lt;/code&gt; 元素。</target>
        </trans-unit>
        <trans-unit id="e3ea8019aa9800496595e6fdc945d8e6fb6214b8" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;audio&lt;/code&gt; element.</source>
          <target state="translated">生成HTML &lt;code&gt;audio&lt;/code&gt; 元素。</target>
        </trans-unit>
        <trans-unit id="781e2bff84caf603de6b3f96592899d16001304e" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;b&lt;/code&gt; element.</source>
          <target state="translated">生成HTML &lt;code&gt;b&lt;/code&gt; 元素。</target>
        </trans-unit>
        <trans-unit id="8f97fe8e4d12bfb853835d7ee5a13495b66a3a79" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;base&lt;/code&gt; element.</source>
          <target state="translated">生成HTML &lt;code&gt;base&lt;/code&gt; 元素。</target>
        </trans-unit>
        <trans-unit id="0bef2ca9a3af4e73d6e4b6860268f8110174379a" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;bdi&lt;/code&gt; element.</source>
          <target state="translated">生成HTML &lt;code&gt;bdi&lt;/code&gt; 元素。</target>
        </trans-unit>
        <trans-unit id="26339ee335f1ed3446bbe37852ca6d1094a3b908" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;bdo&lt;/code&gt; element.</source>
          <target state="translated">生成HTML &lt;code&gt;bdo&lt;/code&gt; 元素。</target>
        </trans-unit>
        <trans-unit id="2d3d1e102d10a06299849f83848d80d2ce08f48a" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;big&lt;/code&gt; element.</source>
          <target state="translated">生成HTML &lt;code&gt;big&lt;/code&gt; 元素。</target>
        </trans-unit>
        <trans-unit id="fc0f3ace6f4bc9198b1c9d689700f7628187b64a" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;blockquote&lt;/code&gt; element.</source>
          <target state="translated">生成HTML &lt;code&gt;blockquote&lt;/code&gt; 元素。</target>
        </trans-unit>
        <trans-unit id="f4aa01acab28ac06305a168352495459e166a2fc" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;body&lt;/code&gt; element.</source>
          <target state="translated">生成HTML &lt;code&gt;body&lt;/code&gt; 元素。</target>
        </trans-unit>
        <trans-unit id="519ea02cf4b979961f20c565aac4b75e00a9b086" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;br&lt;/code&gt; element.</source>
          <target state="translated">生成HTML &lt;code&gt;br&lt;/code&gt; 元素。</target>
        </trans-unit>
        <trans-unit id="0657c98f3e40dcc75e99d757e4ffd2768f82af28" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;button&lt;/code&gt; element.</source>
          <target state="translated">生成HTML &lt;code&gt;button&lt;/code&gt; 元素。</target>
        </trans-unit>
        <trans-unit id="b6e8fdd28947fe81a182ca47b08e94c34ec1e4d2" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;canvas&lt;/code&gt; element.</source>
          <target state="translated">生成HTML &lt;code&gt;canvas&lt;/code&gt; 元素。</target>
        </trans-unit>
        <trans-unit id="e5bfdabbf0147366d16c4eaaa2404e363bd64249" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;caption&lt;/code&gt; element.</source>
          <target state="translated">生成HTML &lt;code&gt;caption&lt;/code&gt; 元素。</target>
        </trans-unit>
        <trans-unit id="660eb09173253a08b1646718e75541e4fb302d2e" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;center&lt;/code&gt; element.</source>
          <target state="translated">生成HTML &lt;code&gt;center&lt;/code&gt; 元素。</target>
        </trans-unit>
        <trans-unit id="88a07df737a0612622dec66f32371db2c52c4391" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;cite&lt;/code&gt; element.</source>
          <target state="translated">生成HTML &lt;code&gt;cite&lt;/code&gt; 元素。</target>
        </trans-unit>
        <trans-unit id="0584882269852e7832a727061f5b8b2852cf1d2a" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;code&lt;/code&gt; element.</source>
          <target state="translated">生成HTML &lt;code&gt;code&lt;/code&gt; 元素。</target>
        </trans-unit>
        <trans-unit id="61de1d464b0fa66efab9ea74c0c855e47cd487b9" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;col&lt;/code&gt; element.</source>
          <target state="translated">生成HTML &lt;code&gt;col&lt;/code&gt; 元素。</target>
        </trans-unit>
        <trans-unit id="dda768838cb4fecfbc87d29c889e4bef728ecd11" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;colgroup&lt;/code&gt; element.</source>
          <target state="translated">生成HTML &lt;code&gt;colgroup&lt;/code&gt; 元素。</target>
        </trans-unit>
        <trans-unit id="ec2096f5b7f2320775930577813c43c8707525bc" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;data&lt;/code&gt; element.</source>
          <target state="translated">生成HTML &lt;code&gt;data&lt;/code&gt; 元素。</target>
        </trans-unit>
        <trans-unit id="f2b101416b917f90a0263464dc6da695fafdbce2" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;datalist&lt;/code&gt; element.</source>
          <target state="translated">生成HTML &lt;code&gt;datalist&lt;/code&gt; 元素。</target>
        </trans-unit>
        <trans-unit id="3a1ecdcdf7c377a1b561e70572836e87cdb33693" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;dd&lt;/code&gt; element.</source>
          <target state="translated">生成HTML &lt;code&gt;dd&lt;/code&gt; 元素。</target>
        </trans-unit>
        <trans-unit id="d660ebebdeff46bec931d3f089a4e59bce312c8e" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;del&lt;/code&gt; element.</source>
          <target state="translated">生成HTML &lt;code&gt;del&lt;/code&gt; 元素。</target>
        </trans-unit>
        <trans-unit id="d456959c6a20d8c4fe07239ff996e70304cf1df1" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;details&lt;/code&gt; element.</source>
          <target state="translated">生成HTML &lt;code&gt;details&lt;/code&gt; 元素。</target>
        </trans-unit>
        <trans-unit id="31d917456b26585dced871779a05a80dfb53f0ca" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;dfn&lt;/code&gt; element.</source>
          <target state="translated">生成HTML &lt;code&gt;dfn&lt;/code&gt; 元素。</target>
        </trans-unit>
        <trans-unit id="0928eeba4125b3752b1e2d5e467ab1bc6b57aaa0" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;dialog&lt;/code&gt; element.</source>
          <target state="translated">生成HTML &lt;code&gt;dialog&lt;/code&gt; 元素。</target>
        </trans-unit>
        <trans-unit id="e9ab607ad1228c7400a9211b50265d207ab975f5" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;div&lt;/code&gt; element.</source>
          <target state="translated">生成HTML &lt;code&gt;div&lt;/code&gt; 元素。</target>
        </trans-unit>
        <trans-unit id="38aaeb2765ecda9c1c49044e2770a1d85c3f5960" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;dl&lt;/code&gt; element.</source>
          <target state="translated">生成HTML &lt;code&gt;dl&lt;/code&gt; 元素。</target>
        </trans-unit>
        <trans-unit id="a760008fc08d6993817e8732bb1bcb173b07a489" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;dt&lt;/code&gt; element.</source>
          <target state="translated">生成HTML &lt;code&gt;dt&lt;/code&gt; 元素。</target>
        </trans-unit>
        <trans-unit id="22b8544b49d83d1d59b33a2ac1f41238fdd0610b" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;em&lt;/code&gt; element.</source>
          <target state="translated">生成HTML &lt;code&gt;em&lt;/code&gt; 元素。</target>
        </trans-unit>
        <trans-unit id="c1570931b6f2239c20d17198d6995af278c83b32" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;embed&lt;/code&gt; element.</source>
          <target state="translated">生成HTML &lt;code&gt;embed&lt;/code&gt; 元素。</target>
        </trans-unit>
        <trans-unit id="1c67ff67bc45f60d4a3cb0372c848130bedf9d14" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;fieldset&lt;/code&gt; element.</source>
          <target state="translated">生成HTML &lt;code&gt;fieldset&lt;/code&gt; 元素。</target>
        </trans-unit>
        <trans-unit id="f4da2d200679bfe395e63618a960a70487adf672" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;figcaption&lt;/code&gt; element.</source>
          <target state="translated">生成HTML &lt;code&gt;figcaption&lt;/code&gt; 元素。</target>
        </trans-unit>
        <trans-unit id="ba4af81e539fd3886478908c327ad8cffed2d4a1" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;figure&lt;/code&gt; element.</source>
          <target state="translated">生成HTML &lt;code&gt;figure&lt;/code&gt; 元素。</target>
        </trans-unit>
        <trans-unit id="ba154b84b360700071cda4fbd58076d9b6b4be64" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;footer&lt;/code&gt; element.</source>
          <target state="translated">生成HTML &lt;code&gt;footer&lt;/code&gt; 元素。</target>
        </trans-unit>
        <trans-unit id="6dc0ef5b06525b6860bbfe5095afa55f7b5f074c" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;form&lt;/code&gt; element.</source>
          <target state="translated">生成HTML &lt;code&gt;form&lt;/code&gt; 元素。</target>
        </trans-unit>
        <trans-unit id="7ca6b27c79c2d3b9992d5d07c24a48a10e28b34c" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;h1&lt;/code&gt; element.</source>
          <target state="translated">生成HTML &lt;code&gt;h1&lt;/code&gt; 元素。</target>
        </trans-unit>
        <trans-unit id="d4789d3b3e9eb88607ad8e8db39b9d84e7e1b387" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;h2&lt;/code&gt; element.</source>
          <target state="translated">生成HTML &lt;code&gt;h2&lt;/code&gt; 元素。</target>
        </trans-unit>
        <trans-unit id="489e845a836298f33e3b64b19d090b856ebfa27d" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;h3&lt;/code&gt; element.</source>
          <target state="translated">生成HTML &lt;code&gt;h3&lt;/code&gt; 元素。</target>
        </trans-unit>
        <trans-unit id="367b7a712f4fea1207a13b88956c965cceb0ef30" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;h4&lt;/code&gt; element.</source>
          <target state="translated">生成HTML &lt;code&gt;h4&lt;/code&gt; 元素。</target>
        </trans-unit>
        <trans-unit id="fbe6c0e3c73c7c4ccf27d7ed85e6f4bfb2a015d2" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;h5&lt;/code&gt; element.</source>
          <target state="translated">生成HTML &lt;code&gt;h5&lt;/code&gt; 元素。</target>
        </trans-unit>
        <trans-unit id="cb72a2726fc9bcb8698c0aee4124749e011b9975" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;h6&lt;/code&gt; element.</source>
          <target state="translated">生成HTML &lt;code&gt;h6&lt;/code&gt; 元素。</target>
        </trans-unit>
        <trans-unit id="b741d14550a58d68d35d27def0f2b5f9e4f5ce12" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;head&lt;/code&gt; element.</source>
          <target state="translated">生成HTML &lt;code&gt;head&lt;/code&gt; 元素。</target>
        </trans-unit>
        <trans-unit id="be049901a7b44200d29f819318105d88429dfeb4" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;header&lt;/code&gt; element.</source>
          <target state="translated">生成HTML &lt;code&gt;header&lt;/code&gt; 元素。</target>
        </trans-unit>
        <trans-unit id="5f59f794866fd435a22266af704d282c41c171c9" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;hr&lt;/code&gt; element.</source>
          <target state="translated">生成HTML &lt;code&gt;hr&lt;/code&gt; 元素。</target>
        </trans-unit>
        <trans-unit id="3260027a04c7712c43bb51eb776720f6e82e196a" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;html&lt;/code&gt; element.</source>
          <target state="translated">生成HTML &lt;code&gt;html&lt;/code&gt; 元素。</target>
        </trans-unit>
        <trans-unit id="a1c658c2cb83a97628300d1ce9b62b730e1bc534" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;i&lt;/code&gt; element.</source>
          <target state="translated">生成HTML &lt;code&gt;i&lt;/code&gt; 元素。</target>
        </trans-unit>
        <trans-unit id="6c90e9cd0c44577a72b0a4003a70f33efd58287a" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;iframe&lt;/code&gt; element.</source>
          <target state="translated">生成HTML &lt;code&gt;iframe&lt;/code&gt; 元素。</target>
        </trans-unit>
        <trans-unit id="189ccdc7739b0beda3532e019673a73764bc2762" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;img&lt;/code&gt; element.</source>
          <target state="translated">生成HTML &lt;code&gt;img&lt;/code&gt; 元素。</target>
        </trans-unit>
        <trans-unit id="2689fd6ba4dabf3c926e3011326c0bbe0a6203d0" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;input&lt;/code&gt; element.</source>
          <target state="translated">生成HTML &lt;code&gt;input&lt;/code&gt; 元素。</target>
        </trans-unit>
        <trans-unit id="6257c9c257cfbb5f42946162cc1bf3411d1f6048" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;ins&lt;/code&gt; element.</source>
          <target state="translated">生成HTML &lt;code&gt;ins&lt;/code&gt; 元素。</target>
        </trans-unit>
        <trans-unit id="9a789f48702e7ee1ebd0d2c620727682ed0765f3" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;kbd&lt;/code&gt; element.</source>
          <target state="translated">生成HTML &lt;code&gt;kbd&lt;/code&gt; 元素。</target>
        </trans-unit>
        <trans-unit id="d540cb25a4e348c681a560269edf67cb03e7b78f" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;keygen&lt;/code&gt; element.</source>
          <target state="translated">生成HTML &lt;code&gt;keygen&lt;/code&gt; 元素。</target>
        </trans-unit>
        <trans-unit id="c9357ea873cb37668266594ebb44bcfcda727c7b" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;label&lt;/code&gt; element.</source>
          <target state="translated">生成HTML &lt;code&gt;label&lt;/code&gt; 元素。</target>
        </trans-unit>
        <trans-unit id="0f647a7e9d56924f3e2c2717cdc6f273fe2e0a9b" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;legend&lt;/code&gt; element.</source>
          <target state="translated">生成HTML &lt;code&gt;legend&lt;/code&gt; 元素。</target>
        </trans-unit>
        <trans-unit id="ee495d070a07ef79b104540a24f79c58f34d97ca" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;li&lt;/code&gt; element.</source>
          <target state="translated">生成HTML &lt;code&gt;li&lt;/code&gt; 元素。</target>
        </trans-unit>
        <trans-unit id="ee3bb6c0fe1bc782c3e6ca68919a9c403cd83cbc" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;link&lt;/code&gt; element.</source>
          <target state="translated">生成HTML &lt;code&gt;link&lt;/code&gt; 元素。</target>
        </trans-unit>
        <trans-unit id="b96b4c8f496bc552385a5d2d3644aac6928a53fe" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;maction&lt;/code&gt; element. MathML &lt;a href=&quot;https://wikipedia.org/wiki/MathML&quot;&gt;https://wikipedia.org/wiki/MathML&lt;/a&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/MathML/Element/maction&quot;&gt;https://developer.mozilla.org/en-US/docs/Web/MathML/Element/maction&lt;/a&gt;</source>
          <target state="translated">生成HTML &lt;code&gt;maction&lt;/code&gt; 元素。MathML &lt;a href=&quot;https://wikipedia.org/wiki/MathML&quot;&gt;https://wikipedia.org/wiki/MathML &lt;/a&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/MathML/Element/maction&quot;&gt;https://developer.mozilla.org/en-US/docs/Web/MathML/Element/maction&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3ceb84e08e07283f1c1c70090fb80caa6fa212c8" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;main&lt;/code&gt; element.</source>
          <target state="translated">生成HTML &lt;code&gt;main&lt;/code&gt; 元素。</target>
        </trans-unit>
        <trans-unit id="e21af6208a1e39b94c80eb93cec9f0c52376aa60" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;map&lt;/code&gt; element.</source>
          <target state="translated">生成HTML &lt;code&gt;map&lt;/code&gt; 元素。</target>
        </trans-unit>
        <trans-unit id="f51d139745dcedc6654f34b51827c38c33b86bd4" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;mark&lt;/code&gt; element.</source>
          <target state="translated">生成HTML &lt;code&gt;mark&lt;/code&gt; 元素。</target>
        </trans-unit>
        <trans-unit id="692d09d61bd0f039746929ac7b0339c9bcd2e702" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;marquee&lt;/code&gt; element.</source>
          <target state="translated">生成HTML &lt;code&gt;marquee&lt;/code&gt; 元素。</target>
        </trans-unit>
        <trans-unit id="499378107de248fd1c359efc6cfd0acff1e25ee8" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;math&lt;/code&gt; element. MathML &lt;a href=&quot;https://wikipedia.org/wiki/MathML&quot;&gt;https://wikipedia.org/wiki/MathML&lt;/a&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/MathML/Element/math#Examples&quot;&gt;https://developer.mozilla.org/en-US/docs/Web/MathML/Element/math#Examples&lt;/a&gt;</source>
          <target state="translated">生成HTML &lt;code&gt;math&lt;/code&gt; 元素。MathML &lt;a href=&quot;https://wikipedia.org/wiki/MathML&quot;&gt;https://wikipedia.org/wiki/MathML &lt;/a&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/MathML/Element/math#Examples&quot;&gt;https://developer.mozilla.org/en-US/docs/Web/MathML/Element/math#Examples&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a91aed1713f1856c234e3daa198d372bb4b29ae7" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;menclose&lt;/code&gt; element. MathML &lt;a href=&quot;https://wikipedia.org/wiki/MathML&quot;&gt;https://wikipedia.org/wiki/MathML&lt;/a&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/MathML/Element/menclose&quot;&gt;https://developer.mozilla.org/en-US/docs/Web/MathML/Element/menclose&lt;/a&gt;</source>
          <target state="translated">生成HTML &lt;code&gt;menclose&lt;/code&gt; 元素。MathML &lt;a href=&quot;https://wikipedia.org/wiki/MathML&quot;&gt;https://wikipedia.org/wiki/MathML &lt;/a&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/MathML/Element/menclose&quot;&gt;https://developer.mozilla.org/en-US/docs/Web/MathML/Element/menclose&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ba506a06399b82662ae53bf8eb917307e0f9bcfa" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;merror&lt;/code&gt; element. MathML &lt;a href=&quot;https://wikipedia.org/wiki/MathML&quot;&gt;https://wikipedia.org/wiki/MathML&lt;/a&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/MathML/Element/merror&quot;&gt;https://developer.mozilla.org/en-US/docs/Web/MathML/Element/merror&lt;/a&gt;</source>
          <target state="translated">生成HTML &lt;code&gt;merror&lt;/code&gt; 元素。MathML &lt;a href=&quot;https://wikipedia.org/wiki/MathML&quot;&gt;https://wikipedia.org/wiki/MathML &lt;/a&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/MathML/Element/merror&quot;&gt;https://developer.mozilla.org/en-US/docs/Web/MathML/Element/merror&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7abf9e36418e2349549d0205093b969a0f74954b" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;meta&lt;/code&gt; element.</source>
          <target state="translated">生成HTML &lt;code&gt;meta&lt;/code&gt; 元素。</target>
        </trans-unit>
        <trans-unit id="68200b0867ed246dfd3cdb816cab3d1aeacdec75" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;meter&lt;/code&gt; element.</source>
          <target state="translated">生成HTML &lt;code&gt;meter&lt;/code&gt; 元素。</target>
        </trans-unit>
        <trans-unit id="1c2596787542e0a138581b455419b609ef7faed4" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;mfenced&lt;/code&gt; element. MathML &lt;a href=&quot;https://wikipedia.org/wiki/MathML&quot;&gt;https://wikipedia.org/wiki/MathML&lt;/a&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/MathML/Element/mfenced&quot;&gt;https://developer.mozilla.org/en-US/docs/Web/MathML/Element/mfenced&lt;/a&gt;</source>
          <target state="translated">生成HTML &lt;code&gt;mfenced&lt;/code&gt; 元素。MathML &lt;a href=&quot;https://wikipedia.org/wiki/MathML&quot;&gt;https://wikipedia.org/wiki/MathML &lt;/a&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/MathML/Element/mfenced&quot;&gt;https://developer.mozilla.org/en-US/docs/Web/MathML/Element/mfenced&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4b6f8830012da66f18b566c07395a10f19162301" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;mfrac&lt;/code&gt; element. MathML &lt;a href=&quot;https://wikipedia.org/wiki/MathML&quot;&gt;https://wikipedia.org/wiki/MathML&lt;/a&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/MathML/Element/mfrac&quot;&gt;https://developer.mozilla.org/en-US/docs/Web/MathML/Element/mfrac&lt;/a&gt;</source>
          <target state="translated">生成HTML &lt;code&gt;mfrac&lt;/code&gt; 元素。MathML &lt;a href=&quot;https://wikipedia.org/wiki/MathML&quot;&gt;https://wikipedia.org/wiki/MathML &lt;/a&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/MathML/Element/mfrac&quot;&gt;https://developer.mozilla.org/en-US/docs/Web/MathML/Element/mfrac&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="be25138e70924676e8c7ecb9a4943d40efdaf3de" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;mglyph&lt;/code&gt; element. MathML &lt;a href=&quot;https://wikipedia.org/wiki/MathML&quot;&gt;https://wikipedia.org/wiki/MathML&lt;/a&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/MathML/Element/mglyph&quot;&gt;https://developer.mozilla.org/en-US/docs/Web/MathML/Element/mglyph&lt;/a&gt;</source>
          <target state="translated">生成HTML &lt;code&gt;mglyph&lt;/code&gt; 元素。MathML &lt;a href=&quot;https://wikipedia.org/wiki/MathML&quot;&gt;https://wikipedia.org/wiki/MathML &lt;/a&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/MathML/Element/mglyph&quot;&gt;https://developer.mozilla.org/en-US/docs/Web/MathML/Element/mglyph&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e9fa624f5b66a9d27dcf9aaa908a6730952e674b" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;mi&lt;/code&gt; element. MathML &lt;a href=&quot;https://wikipedia.org/wiki/MathML&quot;&gt;https://wikipedia.org/wiki/MathML&lt;/a&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/MathML/Element/mi&quot;&gt;https://developer.mozilla.org/en-US/docs/Web/MathML/Element/mi&lt;/a&gt;</source>
          <target state="translated">生成HTML &lt;code&gt;mi&lt;/code&gt; 元素。MathML &lt;a href=&quot;https://wikipedia.org/wiki/MathML&quot;&gt;https://wikipedia.org/wiki/MathML &lt;/a&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/MathML/Element/mi&quot;&gt;https://developer.mozilla.org/en-US/docs/Web/MathML/Element/mi&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0297c68c3fe75f6d402c686d8fc57d31edd154f0" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;mlabeledtr&lt;/code&gt; element. MathML &lt;a href=&quot;https://wikipedia.org/wiki/MathML&quot;&gt;https://wikipedia.org/wiki/MathML&lt;/a&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/MathML/Element/mlabeledtr&quot;&gt;https://developer.mozilla.org/en-US/docs/Web/MathML/Element/mlabeledtr&lt;/a&gt;</source>
          <target state="translated">生成HTML &lt;code&gt;mlabeledtr&lt;/code&gt; 元素。MathML &lt;a href=&quot;https://wikipedia.org/wiki/MathML&quot;&gt;https://wikipedia.org/wiki/MathML &lt;/a&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/MathML/Element/mlabeledtr&quot;&gt;https://developer.mozilla.org/en-US/docs/Web/MathML/Element/mlabeledtr&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="13e431e86f253b36beb5b9ccf8749ec36fb24bf3" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;mmultiscripts&lt;/code&gt; element. MathML &lt;a href=&quot;https://wikipedia.org/wiki/MathML&quot;&gt;https://wikipedia.org/wiki/MathML&lt;/a&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/MathML/Element/mmultiscripts&quot;&gt;https://developer.mozilla.org/en-US/docs/Web/MathML/Element/mmultiscripts&lt;/a&gt;</source>
          <target state="translated">生成HTML &lt;code&gt;mmultiscripts&lt;/code&gt; 元素。MathML &lt;a href=&quot;https://wikipedia.org/wiki/MathML&quot;&gt;https://wikipedia.org/wiki/MathML &lt;/a&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/MathML/Element/mmultiscripts&quot;&gt;https://developer.mozilla.org/en-US/docs/Web/MathML/Element/mmultiscripts&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b5624407164545b6def82bb7b0c6b1d25f9297f9" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;mn&lt;/code&gt; element. MathML &lt;a href=&quot;https://wikipedia.org/wiki/MathML&quot;&gt;https://wikipedia.org/wiki/MathML&lt;/a&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/MathML/Element/mn&quot;&gt;https://developer.mozilla.org/en-US/docs/Web/MathML/Element/mn&lt;/a&gt;</source>
          <target state="translated">生成HTML &lt;code&gt;mn&lt;/code&gt; 元素。MathML &lt;a href=&quot;https://wikipedia.org/wiki/MathML&quot;&gt;https://wikipedia.org/wiki/MathML &lt;/a&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/MathML/Element/mn&quot;&gt;https://developer.mozilla.org/en-US/docs/Web/MathML/Element/mn&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8df1bb16fde8f1db840769bf471ea6e0e2ef52e8" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;mo&lt;/code&gt; element. MathML &lt;a href=&quot;https://wikipedia.org/wiki/MathML&quot;&gt;https://wikipedia.org/wiki/MathML&lt;/a&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/MathML/Element/mo&quot;&gt;https://developer.mozilla.org/en-US/docs/Web/MathML/Element/mo&lt;/a&gt;</source>
          <target state="translated">生成HTML &lt;code&gt;mo&lt;/code&gt; 元素。MathML &lt;a href=&quot;https://wikipedia.org/wiki/MathML&quot;&gt;https://wikipedia.org/wiki/MathML &lt;/a&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/MathML/Element/mo&quot;&gt;https://developer.mozilla.org/en-US/docs/Web/MathML/Element/mo&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d3e156e70a4158caeb7b05630f09d639014f44df" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;mover&lt;/code&gt; element. MathML &lt;a href=&quot;https://wikipedia.org/wiki/MathML&quot;&gt;https://wikipedia.org/wiki/MathML&lt;/a&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/MathML/Element/mover&quot;&gt;https://developer.mozilla.org/en-US/docs/Web/MathML/Element/mover&lt;/a&gt;</source>
          <target state="translated">生成HTML &lt;code&gt;mover&lt;/code&gt; 元素。MathML &lt;a href=&quot;https://wikipedia.org/wiki/MathML&quot;&gt;https://wikipedia.org/wiki/MathML &lt;/a&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/MathML/Element/mover&quot;&gt;https://developer.mozilla.org/en-US/docs/Web/MathML/Element/mover&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="09be696b3bc9f981a56697741573dfe7b31da578" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;mpadded&lt;/code&gt; element. MathML &lt;a href=&quot;https://wikipedia.org/wiki/MathML&quot;&gt;https://wikipedia.org/wiki/MathML&lt;/a&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/MathML/Element/mpadded&quot;&gt;https://developer.mozilla.org/en-US/docs/Web/MathML/Element/mpadded&lt;/a&gt;</source>
          <target state="translated">生成HTML &lt;code&gt;mpadded&lt;/code&gt; 元素。MathML &lt;a href=&quot;https://wikipedia.org/wiki/MathML&quot;&gt;https://wikipedia.org/wiki/MathML &lt;/a&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/MathML/Element/mpadded&quot;&gt;https://developer.mozilla.org/en-US/docs/Web/MathML/Element/mpadded&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8a7cc95c8781953a8bc7c6348ee10e0c0fe11909" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;mphantom&lt;/code&gt; element. MathML &lt;a href=&quot;https://wikipedia.org/wiki/MathML&quot;&gt;https://wikipedia.org/wiki/MathML&lt;/a&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/MathML/Element/mphantom&quot;&gt;https://developer.mozilla.org/en-US/docs/Web/MathML/Element/mphantom&lt;/a&gt;</source>
          <target state="translated">生成HTML &lt;code&gt;mphantom&lt;/code&gt; 元素。MathML &lt;a href=&quot;https://wikipedia.org/wiki/MathML&quot;&gt;https://wikipedia.org/wiki/MathML &lt;/a&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/MathML/Element/mphantom&quot;&gt;https://developer.mozilla.org/en-US/docs/Web/MathML/Element/mphantom&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="bc6993bd6efa015fb7c7841e804a7ca66c930e68" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;mroot&lt;/code&gt; element. MathML &lt;a href=&quot;https://wikipedia.org/wiki/MathML&quot;&gt;https://wikipedia.org/wiki/MathML&lt;/a&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/MathML/Element/mroot&quot;&gt;https://developer.mozilla.org/en-US/docs/Web/MathML/Element/mroot&lt;/a&gt;</source>
          <target state="translated">生成HTML &lt;code&gt;mroot&lt;/code&gt; 元素。MathML &lt;a href=&quot;https://wikipedia.org/wiki/MathML&quot;&gt;https://wikipedia.org/wiki/MathML &lt;/a&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/MathML/Element/mroot&quot;&gt;https://developer.mozilla.org/en-US/docs/Web/MathML/Element/mroot&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5bc2ff2117f9a5988690d2964705c6f16da75ccf" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;mrow&lt;/code&gt; element. MathML &lt;a href=&quot;https://wikipedia.org/wiki/MathML&quot;&gt;https://wikipedia.org/wiki/MathML&lt;/a&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/MathML/Element/mrow&quot;&gt;https://developer.mozilla.org/en-US/docs/Web/MathML/Element/mrow&lt;/a&gt;</source>
          <target state="translated">生成HTML &lt;code&gt;mrow&lt;/code&gt; 元素。MathML &lt;a href=&quot;https://wikipedia.org/wiki/MathML&quot;&gt;https://wikipedia.org/wiki/MathML &lt;/a&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/MathML/Element/mrow&quot;&gt;https://developer.mozilla.org/en-US/docs/Web/MathML/Element/mrow&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9cbaa7aa8a33eec37f6d7f827fe244763291ebfc" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;ms&lt;/code&gt; element. MathML &lt;a href=&quot;https://wikipedia.org/wiki/MathML&quot;&gt;https://wikipedia.org/wiki/MathML&lt;/a&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/MathML/Element/ms&quot;&gt;https://developer.mozilla.org/en-US/docs/Web/MathML/Element/ms&lt;/a&gt;</source>
          <target state="translated">生成HTML &lt;code&gt;ms&lt;/code&gt; 元素。MathML &lt;a href=&quot;https://wikipedia.org/wiki/MathML&quot;&gt;https://wikipedia.org/wiki/MathML &lt;/a&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/MathML/Element/ms&quot;&gt;https://developer.mozilla.org/en-US/docs/Web/MathML/Element/ms&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="aa89b6be555f511dfd17db8db5d6c4ed4c7c0ab8" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;mspace&lt;/code&gt; element. MathML &lt;a href=&quot;https://wikipedia.org/wiki/MathML&quot;&gt;https://wikipedia.org/wiki/MathML&lt;/a&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/MathML/Element/mspace&quot;&gt;https://developer.mozilla.org/en-US/docs/Web/MathML/Element/mspace&lt;/a&gt;</source>
          <target state="translated">生成HTML &lt;code&gt;mspace&lt;/code&gt; 元素。MathML &lt;a href=&quot;https://wikipedia.org/wiki/MathML&quot;&gt;https://wikipedia.org/wiki/MathML &lt;/a&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/MathML/Element/mspace&quot;&gt;https://developer.mozilla.org/en-US/docs/Web/MathML/Element/mspace&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="aaec7a78e68576394018172847b775e346714fb0" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;msqrt&lt;/code&gt; element. MathML &lt;a href=&quot;https://wikipedia.org/wiki/MathML&quot;&gt;https://wikipedia.org/wiki/MathML&lt;/a&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/MathML/Element/msqrt&quot;&gt;https://developer.mozilla.org/en-US/docs/Web/MathML/Element/msqrt&lt;/a&gt;</source>
          <target state="translated">生成HTML &lt;code&gt;msqrt&lt;/code&gt; 元素。MathML &lt;a href=&quot;https://wikipedia.org/wiki/MathML&quot;&gt;https://wikipedia.org/wiki/MathML &lt;/a&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/MathML/Element/msqrt&quot;&gt;https://developer.mozilla.org/en-US/docs/Web/MathML/Element/msqrt&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="aa2bf0f25240d9ea69cbc45164eaede5871741c0" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;mstyle&lt;/code&gt; element. MathML &lt;a href=&quot;https://wikipedia.org/wiki/MathML&quot;&gt;https://wikipedia.org/wiki/MathML&lt;/a&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/MathML/Element/mstyle&quot;&gt;https://developer.mozilla.org/en-US/docs/Web/MathML/Element/mstyle&lt;/a&gt;</source>
          <target state="translated">生成HTML &lt;code&gt;mstyle&lt;/code&gt; 元素。MathML &lt;a href=&quot;https://wikipedia.org/wiki/MathML&quot;&gt;https://wikipedia.org/wiki/MathML &lt;/a&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/MathML/Element/mstyle&quot;&gt;https://developer.mozilla.org/en-US/docs/Web/MathML/Element/mstyle&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="483f8abe3b70822527bbdd3904f9b12f64663cea" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;msub&lt;/code&gt; element. MathML &lt;a href=&quot;https://wikipedia.org/wiki/MathML&quot;&gt;https://wikipedia.org/wiki/MathML&lt;/a&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/MathML/Element/msub&quot;&gt;https://developer.mozilla.org/en-US/docs/Web/MathML/Element/msub&lt;/a&gt;</source>
          <target state="translated">生成HTML &lt;code&gt;msub&lt;/code&gt; 元素。MathML &lt;a href=&quot;https://wikipedia.org/wiki/MathML&quot;&gt;https://wikipedia.org/wiki/MathML &lt;/a&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/MathML/Element/msub&quot;&gt;https://developer.mozilla.org/en-US/docs/Web/MathML/Element/msub&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="740eb50cfa63dc2584d63e8396667efdb0699087" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;msubsup&lt;/code&gt; element. MathML &lt;a href=&quot;https://wikipedia.org/wiki/MathML&quot;&gt;https://wikipedia.org/wiki/MathML&lt;/a&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/MathML/Element/msubsup&quot;&gt;https://developer.mozilla.org/en-US/docs/Web/MathML/Element/msubsup&lt;/a&gt;</source>
          <target state="translated">生成HTML &lt;code&gt;msubsup&lt;/code&gt; 元素。MathML &lt;a href=&quot;https://wikipedia.org/wiki/MathML&quot;&gt;https://wikipedia.org/wiki/MathML &lt;/a&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/MathML/Element/msubsup&quot;&gt;https://developer.mozilla.org/en-US/docs/Web/MathML/Element/msubsup&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="fcc0451b9f8e78faadbdf7dbaf7edcc9877d78c9" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;msup&lt;/code&gt; element. MathML &lt;a href=&quot;https://wikipedia.org/wiki/MathML&quot;&gt;https://wikipedia.org/wiki/MathML&lt;/a&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/MathML/Element/msup&quot;&gt;https://developer.mozilla.org/en-US/docs/Web/MathML/Element/msup&lt;/a&gt;</source>
          <target state="translated">生成HTML &lt;code&gt;msup&lt;/code&gt; 元素。MathML &lt;a href=&quot;https://wikipedia.org/wiki/MathML&quot;&gt;https://wikipedia.org/wiki/MathML &lt;/a&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/MathML/Element/msup&quot;&gt;https://developer.mozilla.org/en-US/docs/Web/MathML/Element/msup&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="2fc9144b7c870832664823b5e1bea8d14bf88831" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;mtable&lt;/code&gt; element. MathML &lt;a href=&quot;https://wikipedia.org/wiki/MathML&quot;&gt;https://wikipedia.org/wiki/MathML&lt;/a&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/MathML/Element/mtable&quot;&gt;https://developer.mozilla.org/en-US/docs/Web/MathML/Element/mtable&lt;/a&gt;</source>
          <target state="translated">生成HTML &lt;code&gt;mtable&lt;/code&gt; 元素。MathML &lt;a href=&quot;https://wikipedia.org/wiki/MathML&quot;&gt;https://wikipedia.org/wiki/MathML &lt;/a&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/MathML/Element/mtable&quot;&gt;https://developer.mozilla.org/en-US/docs/Web/MathML/Element/mtable&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6a800f093d24fabf56b303c28982c6403d8de4ca" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;mtd&lt;/code&gt; element. MathML &lt;a href=&quot;https://wikipedia.org/wiki/MathML&quot;&gt;https://wikipedia.org/wiki/MathML&lt;/a&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/MathML/Element/mtd&quot;&gt;https://developer.mozilla.org/en-US/docs/Web/MathML/Element/mtd&lt;/a&gt;</source>
          <target state="translated">生成HTML &lt;code&gt;mtd&lt;/code&gt; 元素。MathML &lt;a href=&quot;https://wikipedia.org/wiki/MathML&quot;&gt;https://wikipedia.org/wiki/MathML &lt;/a&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/MathML/Element/mtd&quot;&gt;https://developer.mozilla.org/en-US/docs/Web/MathML/Element/mtd&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1a580bcbc406807a386a6ac4e00027e1029bf778" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;mtext&lt;/code&gt; element. MathML &lt;a href=&quot;https://wikipedia.org/wiki/MathML&quot;&gt;https://wikipedia.org/wiki/MathML&lt;/a&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/MathML/Element/mtext&quot;&gt;https://developer.mozilla.org/en-US/docs/Web/MathML/Element/mtext&lt;/a&gt;</source>
          <target state="translated">生成HTML &lt;code&gt;mtext&lt;/code&gt; 元素。MathML &lt;a href=&quot;https://wikipedia.org/wiki/MathML&quot;&gt;https://wikipedia.org/wiki/MathML &lt;/a&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/MathML/Element/mtext&quot;&gt;https://developer.mozilla.org/en-US/docs/Web/MathML/Element/mtext&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f50436d4782346e0f2c90f5a97d6764b98c3e592" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;munder&lt;/code&gt; element. MathML &lt;a href=&quot;https://wikipedia.org/wiki/MathML&quot;&gt;https://wikipedia.org/wiki/MathML&lt;/a&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/MathML/Element/munder&quot;&gt;https://developer.mozilla.org/en-US/docs/Web/MathML/Element/munder&lt;/a&gt;</source>
          <target state="translated">生成HTML &lt;code&gt;munder&lt;/code&gt; 元素。MathML &lt;a href=&quot;https://wikipedia.org/wiki/MathML&quot;&gt;https://wikipedia.org/wiki/MathML &lt;/a&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/MathML/Element/munder&quot;&gt;https://developer.mozilla.org/en-US/docs/Web/MathML/Element/munder&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1cb0be55fb6f4c58428dc68ba7c74b76fa9ce00b" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;munderover&lt;/code&gt; element. MathML &lt;a href=&quot;https://wikipedia.org/wiki/MathML&quot;&gt;https://wikipedia.org/wiki/MathML&lt;/a&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/MathML/Element/munderover&quot;&gt;https://developer.mozilla.org/en-US/docs/Web/MathML/Element/munderover&lt;/a&gt;</source>
          <target state="translated">生成HTML &lt;code&gt;munderover&lt;/code&gt; 元素。MathML &lt;a href=&quot;https://wikipedia.org/wiki/MathML&quot;&gt;https://wikipedia.org/wiki/MathML &lt;/a&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/MathML/Element/munderover&quot;&gt;https://developer.mozilla.org/en-US/docs/Web/MathML/Element/munderover&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e64be23a3ca78e17c1d11fb87dcf0379edad5f67" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;nav&lt;/code&gt; element.</source>
          <target state="translated">生成HTML &lt;code&gt;nav&lt;/code&gt; 元素。</target>
        </trans-unit>
        <trans-unit id="8f504d61d3d0622640b9a76e75dd4d618dcbc646" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;noscript&lt;/code&gt; element.</source>
          <target state="translated">生成HTML &lt;code&gt;noscript&lt;/code&gt; 元素。</target>
        </trans-unit>
        <trans-unit id="a1d13d13bd7b8465f26d4689a2d957b6ba8e6914" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;object&lt;/code&gt; element.</source>
          <target state="translated">生成HTML &lt;code&gt;object&lt;/code&gt; 元素。</target>
        </trans-unit>
        <trans-unit id="50c3a6ea3e2a906df7ce7cb4b4b5e56c942549f2" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;ol&lt;/code&gt; element.</source>
          <target state="translated">生成HTML &lt;code&gt;ol&lt;/code&gt; 元素。</target>
        </trans-unit>
        <trans-unit id="603574bfaf599f93890e2fb3b00e4937994aee04" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;optgroup&lt;/code&gt; element.</source>
          <target state="translated">生成HTML &lt;code&gt;optgroup&lt;/code&gt; 元素。</target>
        </trans-unit>
        <trans-unit id="ec9a1e23896f777c1a50fe61956d79c83e99fe0e" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;option&lt;/code&gt; element.</source>
          <target state="translated">生成HTML &lt;code&gt;option&lt;/code&gt; 元素。</target>
        </trans-unit>
        <trans-unit id="9e91c1178d6e6a39fdec347b8b933af7f8166404" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;output&lt;/code&gt; element.</source>
          <target state="translated">生成HTML &lt;code&gt;output&lt;/code&gt; 元素。</target>
        </trans-unit>
        <trans-unit id="99069d37b3e72a5c699d119936ae25c179638da9" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;p&lt;/code&gt; element.</source>
          <target state="translated">生成HTML &lt;code&gt;p&lt;/code&gt; 元素。</target>
        </trans-unit>
        <trans-unit id="d5c99f67716e604deac5aeaf0ae29679e2e77f56" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;param&lt;/code&gt; element.</source>
          <target state="translated">生成HTML &lt;code&gt;param&lt;/code&gt; 元素。</target>
        </trans-unit>
        <trans-unit id="d0c1cf9b4ee9c05261bc5a92368a61e6e13099a1" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;picture&lt;/code&gt; element.</source>
          <target state="translated">生成HTML &lt;code&gt;picture&lt;/code&gt; 元素。</target>
        </trans-unit>
        <trans-unit id="927cf9075dfedda1ef6defe172c80896ce8cfa44" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;pre&lt;/code&gt; element.</source>
          <target state="translated">生成HTML &lt;code&gt;pre&lt;/code&gt; 元素。</target>
        </trans-unit>
        <trans-unit id="4a7ca998d91d3dca462510461fcabd03805870f7" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;progress&lt;/code&gt; element.</source>
          <target state="translated">生成HTML &lt;code&gt;progress&lt;/code&gt; 元素。</target>
        </trans-unit>
        <trans-unit id="1f3394adadad71640f551bb1f0b38f768245eb15" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;q&lt;/code&gt; element.</source>
          <target state="translated">生成HTML &lt;code&gt;q&lt;/code&gt; 元素。</target>
        </trans-unit>
        <trans-unit id="10b6e8d1cf19a4c0765095254f40e4438dc960ab" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;rb&lt;/code&gt; element.</source>
          <target state="translated">生成HTML &lt;code&gt;rb&lt;/code&gt; 元素。</target>
        </trans-unit>
        <trans-unit id="7f89e55d8df8bc83a1b801ecd4d66561a88adaea" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;rp&lt;/code&gt; element.</source>
          <target state="translated">生成HTML &lt;code&gt;rp&lt;/code&gt; 元素。</target>
        </trans-unit>
        <trans-unit id="8d4af404712d5f7e0f310aa3601b0943f64c5267" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;rt&lt;/code&gt; element.</source>
          <target state="translated">生成HTML &lt;code&gt;rt&lt;/code&gt; 元素。</target>
        </trans-unit>
        <trans-unit id="6f47d0bdd2bfea9b65862c99e096c1002435b06c" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;rtc&lt;/code&gt; element.</source>
          <target state="translated">生成HTML &lt;code&gt;rtc&lt;/code&gt; 元素。</target>
        </trans-unit>
        <trans-unit id="a420db35452a048fb5dd7cdfdc3b34168fc39dc1" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;ruby&lt;/code&gt; element.</source>
          <target state="translated">生成HTML &lt;code&gt;ruby&lt;/code&gt; 元素。</target>
        </trans-unit>
        <trans-unit id="aefeef801650e8395cff2e40d58c915d62540191" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;s&lt;/code&gt; element.</source>
          <target state="translated">生成HTML &lt;code&gt;s&lt;/code&gt; 元素。</target>
        </trans-unit>
        <trans-unit id="c8b88492f1821fa20f6da136ff86ef6965aef816" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;samp&lt;/code&gt; element.</source>
          <target state="translated">生成HTML &lt;code&gt;samp&lt;/code&gt; 元素。</target>
        </trans-unit>
        <trans-unit id="f57b7ae2c2122fc884ed075d827265932c771990" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;script&lt;/code&gt; element.</source>
          <target state="translated">生成HTML &lt;code&gt;script&lt;/code&gt; 元素。</target>
        </trans-unit>
        <trans-unit id="032f946dc0943f8f7ff5fc1e8691e6319b52c986" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;section&lt;/code&gt; element.</source>
          <target state="translated">生成HTML &lt;code&gt;section&lt;/code&gt; 元素。</target>
        </trans-unit>
        <trans-unit id="54ef79bbe2c64b862c935c4c2985f03340f0681c" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;select&lt;/code&gt; element.</source>
          <target state="translated">生成HTML &lt;code&gt;select&lt;/code&gt; 元素。</target>
        </trans-unit>
        <trans-unit id="885197cf3adff9060d7ad840c9711c0576cbc2f8" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;semantics&lt;/code&gt; element. MathML &lt;a href=&quot;https://wikipedia.org/wiki/MathML&quot;&gt;https://wikipedia.org/wiki/MathML&lt;/a&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/MathML/Element/semantics&quot;&gt;https://developer.mozilla.org/en-US/docs/Web/MathML/Element/semantics&lt;/a&gt;</source>
          <target state="translated">生成HTML &lt;code&gt;semantics&lt;/code&gt; 元素。MathML &lt;a href=&quot;https://wikipedia.org/wiki/MathML&quot;&gt;https://wikipedia.org/wiki/MathML &lt;/a&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/MathML/Element/semantics&quot;&gt;https://developer.mozilla.org/en-US/docs/Web/MathML/Element/semantics&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9eef6a77b30b886b5d4b938c85974a8e690613bf" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;slot&lt;/code&gt; element.</source>
          <target state="translated">生成HTML &lt;code&gt;slot&lt;/code&gt; 元素。</target>
        </trans-unit>
        <trans-unit id="f2bf01d48af1a21e5f109a7f960507c0486825c8" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;small&lt;/code&gt; element.</source>
          <target state="translated">生成HTML &lt;code&gt;small&lt;/code&gt; 元素。</target>
        </trans-unit>
        <trans-unit id="79c9ecb649311996dd7b870242a3044823dab843" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;source&lt;/code&gt; element.</source>
          <target state="translated">生成HTML &lt;code&gt;source&lt;/code&gt; 元素。</target>
        </trans-unit>
        <trans-unit id="c7248c71b05a3424702099d9262683e171fb9556" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;span&lt;/code&gt; element.</source>
          <target state="translated">生成HTML &lt;code&gt;span&lt;/code&gt; 元素。</target>
        </trans-unit>
        <trans-unit id="9f5759bf6134cc8899c575427332da55100d40b3" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;strong&lt;/code&gt; element.</source>
          <target state="translated">生成HTML &lt;code&gt;strong&lt;/code&gt; 元素。</target>
        </trans-unit>
        <trans-unit id="01a164d164cd14133a71b8e1f766853cd3ff6983" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;style&lt;/code&gt; element.</source>
          <target state="translated">生成HTML &lt;code&gt;style&lt;/code&gt; 元素。</target>
        </trans-unit>
        <trans-unit id="e497b992a0963e21d6b405ae152673a691a24a65" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;sub&lt;/code&gt; element.</source>
          <target state="translated">生成HTML &lt;code&gt;sub&lt;/code&gt; 元素。</target>
        </trans-unit>
        <trans-unit id="63f8b492814144ea06fa14f427ccd874ffc0353d" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;summary&lt;/code&gt; element.</source>
          <target state="translated">生成HTML &lt;code&gt;summary&lt;/code&gt; 元素。</target>
        </trans-unit>
        <trans-unit id="49f53281496402bc22649b4ada2e8c39bde66772" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;sup&lt;/code&gt; element.</source>
          <target state="translated">生成HTML &lt;code&gt;sup&lt;/code&gt; 元素。</target>
        </trans-unit>
        <trans-unit id="4b63a1d86f2e4295f86c74d5be70b57361f0a73b" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;table&lt;/code&gt; element.</source>
          <target state="translated">生成HTML &lt;code&gt;table&lt;/code&gt; 元素。</target>
        </trans-unit>
        <trans-unit id="7e12e676be1691ed4ae7ed6010fb163dcde9fe33" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;tbody&lt;/code&gt; element.</source>
          <target state="translated">生成HTML &lt;code&gt;tbody&lt;/code&gt; 元素。</target>
        </trans-unit>
        <trans-unit id="5d0a3bb62756c29e3183a118254cece57e00f0c4" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;td&lt;/code&gt; element.</source>
          <target state="translated">生成HTML &lt;code&gt;td&lt;/code&gt; 元素。</target>
        </trans-unit>
        <trans-unit id="176243abebd8e8d175c100a96b2a2e3e91ee2d7e" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;template&lt;/code&gt; element.</source>
          <target state="translated">生成HTML &lt;code&gt;template&lt;/code&gt; 元素。</target>
        </trans-unit>
        <trans-unit id="5ad42138b20d64d40d7d3094ad62c106d2cbff9d" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;textarea&lt;/code&gt; element.</source>
          <target state="translated">生成HTML &lt;code&gt;textarea&lt;/code&gt; 元素。</target>
        </trans-unit>
        <trans-unit id="54fbfbd9206b82eff0de8b083d3d5d21d085e817" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;tfoot&lt;/code&gt; element.</source>
          <target state="translated">生成HTML &lt;code&gt;tfoot&lt;/code&gt; 元素。</target>
        </trans-unit>
        <trans-unit id="e34135dae942c7e7cb4017ee38f734def17f6487" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;th&lt;/code&gt; element.</source>
          <target state="translated">生成HTML &lt;code&gt;th&lt;/code&gt; 元素。</target>
        </trans-unit>
        <trans-unit id="84ee6106bc8d50c4c02a5987b7fd33771a35478e" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;thead&lt;/code&gt; element.</source>
          <target state="translated">生成HTML &lt;code&gt;thead&lt;/code&gt; 元素。</target>
        </trans-unit>
        <trans-unit id="b38ec10e3ae60dfa7d07092b1852f7d445d2e5fb" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;time&lt;/code&gt; element.</source>
          <target state="translated">生成HTML &lt;code&gt;time&lt;/code&gt; 元素。</target>
        </trans-unit>
        <trans-unit id="779acc8c7b9a4b1584ca5a5e997ee4104e1bbe16" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;title&lt;/code&gt; element.</source>
          <target state="translated">生成HTML &lt;code&gt;title&lt;/code&gt; 元素。</target>
        </trans-unit>
        <trans-unit id="b009451fd485966f84e5d46e1fc1c8e35117afcb" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;tr&lt;/code&gt; element.</source>
          <target state="translated">生成HTML &lt;code&gt;tr&lt;/code&gt; 元素。</target>
        </trans-unit>
        <trans-unit id="90810fb6ee5e22c2187c395cd31a8fa8dae0e37c" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;track&lt;/code&gt; element.</source>
          <target state="translated">生成HTML &lt;code&gt;track&lt;/code&gt; 元素。</target>
        </trans-unit>
        <trans-unit id="90ebcdfc397b1445cc709d8890b2dcbf920efe5e" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;tt&lt;/code&gt; element.</source>
          <target state="translated">生成HTML &lt;code&gt;tt&lt;/code&gt; 元素。</target>
        </trans-unit>
        <trans-unit id="f979d07ab3099ffd83bd2aac6fefcb47cb6e1f26" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;u&lt;/code&gt; element.</source>
          <target state="translated">生成HTML &lt;code&gt;u&lt;/code&gt; 元素。</target>
        </trans-unit>
        <trans-unit id="b4b4ad09cbdd52448a64d367a2530303c8abc4b2" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;ul&lt;/code&gt; element.</source>
          <target state="translated">生成HTML &lt;code&gt;ul&lt;/code&gt; 元素。</target>
        </trans-unit>
        <trans-unit id="702489ba723db1998c9363f9002f88e4a94f5003" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;var&lt;/code&gt; element.</source>
          <target state="translated">生成HTML &lt;code&gt;var&lt;/code&gt; 元素。</target>
        </trans-unit>
        <trans-unit id="e808918cfd649391788ce9409245da2f232a763d" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;video&lt;/code&gt; element.</source>
          <target state="translated">生成HTML &lt;code&gt;video&lt;/code&gt; 元素。</target>
        </trans-unit>
        <trans-unit id="82ab02b014d023ecbb9e10205dcb4f53779bfb16" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;wbr&lt;/code&gt; element.</source>
          <target state="translated">生成HTML &lt;code&gt;wbr&lt;/code&gt; 元素。</target>
        </trans-unit>
        <trans-unit id="d238e05cf8359baddfe7e098b6e336c92a9522a7" translate="yes" xml:space="preserve">
          <source>Generating AST by hand</source>
          <target state="translated">手工生成AST</target>
        </trans-unit>
        <trans-unit id="6d7d9e5c5c51e8cdad797fbcfcf569b8c1cb37c1" translate="yes" xml:space="preserve">
          <source>Generating source code</source>
          <target state="translated">生成源码</target>
        </trans-unit>
        <trans-unit id="35071138dc35da926de98aaefe96984d4217c446" translate="yes" xml:space="preserve">
          <source>Generation of HTML documents is done via the &lt;code&gt;doc&lt;/code&gt; command. This command takes either a single .nim file, outputting a single .html file with the same base filename, or multiple .nim files, outputting multiple .html files and, optionally, an index file.</source>
          <target state="translated">HTML文档的生成是通过 &lt;code&gt;doc&lt;/code&gt; 命令完成的。此命令将使用单个.nim文件（输出具有相同基本文件名的单个.html文件），或多个.nim文件（输出多个.html文件以及可选的索引文件）。</target>
        </trans-unit>
        <trans-unit id="fa6d6526a743c04cb138f95e5e874619707d13b3" translate="yes" xml:space="preserve">
          <source>Generation of JSON documents is done via the &lt;code&gt;jsondoc&lt;/code&gt; command. This command takes in a .nim file, and outputs a .json file with the same base filename. Note that this tool is built off of the &lt;code&gt;doc&lt;/code&gt; command (previously &lt;code&gt;doc2&lt;/code&gt;), and contains the same information.</source>
          <target state="translated">JSON文档的生成通过 &lt;code&gt;jsondoc&lt;/code&gt; 命令完成。该命令接收一个.nim文件，并输出具有相同基本文件名的.json文件。请注意，此工具是基于 &lt;code&gt;doc&lt;/code&gt; 命令（以前为 &lt;code&gt;doc2&lt;/code&gt; ）构建的，并且包含相同的信息。</target>
        </trans-unit>
        <trans-unit id="a3e705cc61a19f33d7c9c030f107a70569966485" translate="yes" xml:space="preserve">
          <source>Generators</source>
          <target state="translated">Generators</target>
        </trans-unit>
        <trans-unit id="ecb8455c6017aa556f1a742c2bbe58fd6c33e126" translate="yes" xml:space="preserve">
          <source>Generators that are independent of the default one can be created with the &lt;a href=&quot;#initRand,int64&quot;&gt;initRand proc&lt;/a&gt;.</source>
          <target state="translated">独立于默认生成器的生成器可以使用&lt;a href=&quot;#initRand,int64&quot;&gt;initRand proc&lt;/a&gt;创建。</target>
        </trans-unit>
        <trans-unit id="fa4da4b25b29a5d42eacf30a326661d0c19bc53d" translate="yes" xml:space="preserve">
          <source>Generic 'sink' operator for Nim.</source>
          <target state="translated">Nim的通用 &quot;下沉 &quot;操作符。</target>
        </trans-unit>
        <trans-unit id="3f7d98939d2e599a92fb51644f3d139254dbe639" translate="yes" xml:space="preserve">
          <source>Generic &lt;code&gt;$&lt;/code&gt; operator for arrays that is lifted from the components.</source>
          <target state="translated">从组件中取出的数组的通用 &lt;code&gt;$&lt;/code&gt; 运算符。</target>
        </trans-unit>
        <trans-unit id="25dc10a10484e99e5be2de9d8740c28db93a4f0d" translate="yes" xml:space="preserve">
          <source>Generic &lt;code&gt;$&lt;/code&gt; operator for openarrays that is lifted from the components of &lt;code&gt;x&lt;/code&gt;. Example:</source>
          <target state="translated">从 &lt;code&gt;x&lt;/code&gt; 的组成部分提升的openarray的泛型 &lt;code&gt;$&lt;/code&gt; 运算符。例子：</target>
        </trans-unit>
        <trans-unit id="92a593d97b8fcd7767e73733dc0e14657fdc1f4b" translate="yes" xml:space="preserve">
          <source>Generic &lt;code&gt;$&lt;/code&gt; operator for seqs that is lifted from the components of &lt;code&gt;x&lt;/code&gt;. Example:</source>
          <target state="translated">从 &lt;code&gt;x&lt;/code&gt; 的组成部分提升的seqs的通用 &lt;code&gt;$&lt;/code&gt; 运算符。例子：</target>
        </trans-unit>
        <trans-unit id="68472d9619306bbfad1204d0d30f885be44b7a60" translate="yes" xml:space="preserve">
          <source>Generic &lt;code&gt;$&lt;/code&gt; operator for sets that is lifted from the components of &lt;code&gt;x&lt;/code&gt;. Example:</source>
          <target state="translated">从 &lt;code&gt;x&lt;/code&gt; 的组成部分提起的集合的泛型 &lt;code&gt;$&lt;/code&gt; 运算符。例子：</target>
        </trans-unit>
        <trans-unit id="ba53755f62ad03138279baf781166a53ed0ab135" translate="yes" xml:space="preserve">
          <source>Generic &lt;code&gt;$&lt;/code&gt; operator for slices that is lifted from the components of &lt;code&gt;x&lt;/code&gt;. Example:</source>
          <target state="translated">从 &lt;code&gt;x&lt;/code&gt; 的分量提升的切片的泛型 &lt;code&gt;$&lt;/code&gt; 运算符。例子：</target>
        </trans-unit>
        <trans-unit id="7e4e342b492689191bbf67b40fa6d701d15a99e8" translate="yes" xml:space="preserve">
          <source>Generic &lt;code&gt;$&lt;/code&gt; operator for tuples that is lifted from the components of &lt;code&gt;x&lt;/code&gt;. Example:</source>
          <target state="translated">元组的通用 &lt;code&gt;$&lt;/code&gt; 运算符，它从 &lt;code&gt;x&lt;/code&gt; 的组成部分提起。例子：</target>
        </trans-unit>
        <trans-unit id="6d3461386e665830f05493540980fbbad3db6e26" translate="yes" xml:space="preserve">
          <source>Generic &lt;code&gt;==&lt;/code&gt; operator for tuples that is lifted from the components. of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;.</source>
          <target state="translated">从组件提起的元组的通用 &lt;code&gt;==&lt;/code&gt; 运算符。的 &lt;code&gt;x&lt;/code&gt; 和 &lt;code&gt;y&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b860e8449129db1db575f3ace43091516f67c893" translate="yes" xml:space="preserve">
          <source>Generic &lt;code&gt;importcpp&lt;/code&gt;'ed objects are mapped to C++ templates. This means that one can import C++'s templates rather easily without the need for a pattern language for object types:</source>
          <target state="translated">通用的 &lt;code&gt;importcpp&lt;/code&gt; 对象被映射到C ++模板。这意味着可以轻松地导入C ++模板，而无需使用对象类型的模式语言：</target>
        </trans-unit>
        <trans-unit id="33a377ee820e09df0403fe82c53c3c8f2ee70f4b" translate="yes" xml:space="preserve">
          <source>Generic &lt;code&gt;importcpp&lt;/code&gt;'ed objects are mapped to C++ templates. This means that you can import C++'s templates rather easily without the need for a pattern language for object types:</source>
          <target state="translated">通用的 &lt;code&gt;importcpp&lt;/code&gt; 对象被映射到C ++模板。这意味着您可以轻松地导入C ++模板，而无需使用对象类型的模式语言：</target>
        </trans-unit>
        <trans-unit id="1a112a59a836ee051dd90640bf9a63207cb67f73" translate="yes" xml:space="preserve">
          <source>Generic &lt;span id=&quot;destructor_1&quot;&gt;destructor&lt;/span&gt; implementation that can be overridden.</source>
          <target state="translated">可以覆盖的通用&lt;span id=&quot;destructor_1&quot;&gt;析构函数&lt;/span&gt;实现。</target>
        </trans-unit>
        <trans-unit id="48811885ff4e6e1d4496613f53cf4fe6f1a80351" translate="yes" xml:space="preserve">
          <source>Generic &lt;span id=&quot;sink_1&quot;&gt;sink&lt;/span&gt; implementation that can be overridden.</source>
          <target state="translated">可以重写的通用接收&lt;span id=&quot;sink_1&quot;&gt;器&lt;/span&gt;实现。</target>
        </trans-unit>
        <trans-unit id="0e0fbaa97fbe2d5968844c44481eeeeaa9d8cf4d" translate="yes" xml:space="preserve">
          <source>Generic Operating System Services</source>
          <target state="translated">通用操作系统服务</target>
        </trans-unit>
        <trans-unit id="464fc06b76ab248412509ecef43c71e506b6ded7" translate="yes" xml:space="preserve">
          <source>Generic character types</source>
          <target state="translated">通用字符类型</target>
        </trans-unit>
        <trans-unit id="91a8b57b838f07b19ed30b33bc5aeffe6a02d4c6" translate="yes" xml:space="preserve">
          <source>Generic compare proc.</source>
          <target state="translated">通用比较程序</target>
        </trans-unit>
        <trans-unit id="678e67a971cceb4e4204476fbf467e12791b8c3c" translate="yes" xml:space="preserve">
          <source>Generic compare proc. Returns a value &amp;lt; 0 iff x &amp;lt; y, a value &amp;gt; 0 iff x &amp;gt; y and 0 iff x == y. This is useful for writing generic algorithms without performance loss. This generic implementation uses the &lt;em&gt;==&lt;/em&gt; and &lt;em&gt;&amp;lt;&lt;/em&gt; operators.</source>
          <target state="translated">通用比较过程。返回值&amp;lt;0 iff x &amp;lt;y，值&amp;gt; 0 iff x&amp;gt; y和0 iff x == y。这对于编写没有性能损失的通用算法很有用。此通用实现使用&lt;em&gt;==&lt;/em&gt;和&lt;em&gt;&amp;lt;&lt;/em&gt;运算符。</target>
        </trans-unit>
        <trans-unit id="6aac3374886170bb41e18aa9ef46d585b4c0cf3d" translate="yes" xml:space="preserve">
          <source>Generic concepts and type binding rules</source>
          <target state="translated">通用概念和类型绑定规则</target>
        </trans-unit>
        <trans-unit id="e9d9ced4a1220da78471017048bb21c0918f5f51" translate="yes" xml:space="preserve">
          <source>Generic constructor for JSON data. Creates a new &lt;code&gt;JArray JsonNode&lt;/code&gt;</source>
          <target state="translated">JSON数据的通用构造函数。创建一个新的 &lt;code&gt;JArray JsonNode&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2a284a5b6d26d3458edbcb91cb0cdc3e895de227" translate="yes" xml:space="preserve">
          <source>Generic constructor for JSON data. Creates a new &lt;code&gt;JBool JsonNode&lt;/code&gt;.</source>
          <target state="translated">JSON数据的通用构造函数。创建一个新的 &lt;code&gt;JBool JsonNode&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bb570386048b49850a85fb951fecbcbe240a19c3" translate="yes" xml:space="preserve">
          <source>Generic constructor for JSON data. Creates a new &lt;code&gt;JFloat JsonNode&lt;/code&gt;.</source>
          <target state="translated">JSON数据的通用构造函数。创建一个新的 &lt;code&gt;JFloat JsonNode&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0c9abbf466222ff52b0f6a4b2ff30f735f354ff5" translate="yes" xml:space="preserve">
          <source>Generic constructor for JSON data. Creates a new &lt;code&gt;JInt JsonNode&lt;/code&gt;.</source>
          <target state="translated">JSON数据的通用构造函数。创建一个新的 &lt;code&gt;JInt JsonNode&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d3a82330283a77e8f4325ad6d16dda3e1716a317" translate="yes" xml:space="preserve">
          <source>Generic constructor for JSON data. Creates a new &lt;code&gt;JNull JsonNode&lt;/code&gt; if &lt;code&gt;opt&lt;/code&gt; is empty, otherwise it delegates to the underlying value.</source>
          <target state="translated">JSON数据的通用构造函数。如果 &lt;code&gt;opt&lt;/code&gt; 为空，则创建一个新的 &lt;code&gt;JNull JsonNode&lt;/code&gt; ，否则将委托给基础值。</target>
        </trans-unit>
        <trans-unit id="6a4aa18634c4bcfb0eb0afbfbb21ce20b58df1e2" translate="yes" xml:space="preserve">
          <source>Generic constructor for JSON data. Creates a new &lt;code&gt;JObject JsonNode&lt;/code&gt;</source>
          <target state="translated">JSON数据的通用构造函数。创建一个新的 &lt;code&gt;JObject JsonNode&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="239890fb8c97702c6d4ee5104521be1ba227b16e" translate="yes" xml:space="preserve">
          <source>Generic constructor for JSON data. Creates a new &lt;code&gt;JObject JsonNode&lt;/code&gt;.</source>
          <target state="translated">JSON数据的通用构造函数。创建一个新的 &lt;code&gt;JObject JsonNode&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8abdbf1eb8384d43d3616880593cc740080350c2" translate="yes" xml:space="preserve">
          <source>Generic constructor for JSON data. Creates a new &lt;code&gt;JString JsonNode&lt;/code&gt;.</source>
          <target state="translated">JSON数据的通用构造函数。创建一个新的 &lt;code&gt;JString JsonNode&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5758f3b8d7db49429e2450605302abae607b2d2e" translate="yes" xml:space="preserve">
          <source>Generic constructor for JSON data. Creates a new &lt;em&gt;JArray JsonNode&lt;/em&gt;</source>
          <target state="translated">JSON数据的通用构造函数。创建一个新的&lt;em&gt;JArray JsonNode&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="56196b58c5a518827914bf2b7e0d971615bef4ef" translate="yes" xml:space="preserve">
          <source>Generic constructor for JSON data. Creates a new &lt;em&gt;JBool JsonNode&lt;/em&gt;.</source>
          <target state="translated">JSON数据的通用构造函数。创建一个新的&lt;em&gt;JBool JsonNode&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="c522119659c3ad469d660cbc777be1566eab03ca" translate="yes" xml:space="preserve">
          <source>Generic constructor for JSON data. Creates a new &lt;em&gt;JFloat JsonNode&lt;/em&gt;.</source>
          <target state="translated">JSON数据的通用构造函数。创建一个新的&lt;em&gt;JFloat JsonNode&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="428d41d73169fa86a546999a3ecbb89be1dc15dd" translate="yes" xml:space="preserve">
          <source>Generic constructor for JSON data. Creates a new &lt;em&gt;JInt JsonNode&lt;/em&gt;.</source>
          <target state="translated">JSON数据的通用构造函数。创建一个新的&lt;em&gt;JInt JsonNode&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="b6b9a542f51bfb8d8a58c48f28ef2d46b8502cfe" translate="yes" xml:space="preserve">
          <source>Generic constructor for JSON data. Creates a new &lt;em&gt;JObject JsonNode&lt;/em&gt;</source>
          <target state="translated">JSON数据的通用构造函数。创建一个新的&lt;em&gt;JObject JsonNode&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2877938000b60f256eb2208f3e2064ca182d0d1e" translate="yes" xml:space="preserve">
          <source>Generic constructor for JSON data. Creates a new &lt;em&gt;JString JsonNode&lt;/em&gt;.</source>
          <target state="translated">JSON数据的通用构造函数。创建一个新的&lt;em&gt;JString JsonNode&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="7a8148d60cedc7cdb10800bc50e60d1a318f6ded" translate="yes" xml:space="preserve">
          <source>Generic constructor for SEXP data. Creates a new &lt;em&gt;SFloat SexpNode&lt;/em&gt;.</source>
          <target state="translated">SEXP数据的通用构造函数。创建一个新的&lt;em&gt;SFloat SexpNode&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="368e470b1e2f2321d77f4df18391df0ebee5b99f" translate="yes" xml:space="preserve">
          <source>Generic constructor for SEXP data. Creates a new &lt;em&gt;SInt SexpNode&lt;/em&gt;.</source>
          <target state="translated">SEXP数据的通用构造函数。创建一个新的&lt;em&gt;SInt SexpNode&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="ce95a5ca77c5c22b17a766116d3147d2635c453e" translate="yes" xml:space="preserve">
          <source>Generic constructor for SEXP data. Creates a new &lt;em&gt;SList SexpNode&lt;/em&gt;</source>
          <target state="translated">SEXP数据的通用构造函数。创建一个新的&lt;em&gt;SList SexpNode&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="70060a28a86cfcd2dc2f2ba89648bd6996b8b345" translate="yes" xml:space="preserve">
          <source>Generic constructor for SEXP data. Creates a new &lt;em&gt;SString SexpNode&lt;/em&gt;.</source>
          <target state="translated">SEXP数据的通用构造函数。创建一个新的&lt;em&gt;SString SexpNode&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="ea5770ee43cc8a593a59a930e346d52787e2ce7c" translate="yes" xml:space="preserve">
          <source>Generic constructor for SEXP data. Creates a new &lt;em&gt;SSymbol SexpNode&lt;/em&gt; with value t or &lt;em&gt;SNil SexpNode&lt;/em&gt;.</source>
          <target state="translated">SEXP数据的通用构造函数。创建一个新的&lt;em&gt;SSymbol SexpNode&lt;/em&gt;，其值为t或&lt;em&gt;SNil SexpNode&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="2d9c5b40c902b45136bf82c2680715d032a1618a" translate="yes" xml:space="preserve">
          <source>Generic equals operator for sequences: relies on a equals operator for the element type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">序列的泛型equals运算符：依赖于元素 &lt;code&gt;T&lt;/code&gt; 的equals运算符。</target>
        </trans-unit>
        <trans-unit id="64fb5138e59ddec98dd809de58b7d3ddb3a5428f" translate="yes" xml:space="preserve">
          <source>Generic equals operator for sequences: relies on a equals operator for the element type &lt;em&gt;T&lt;/em&gt;.</source>
          <target state="translated">序列的泛型equals运算符：依赖于元素&lt;em&gt;T&lt;/em&gt;的equals运算符。</target>
        </trans-unit>
        <trans-unit id="24d2e728fc7eb11a101f2306259092cd481ba295" translate="yes" xml:space="preserve">
          <source>Generic hash table, consisting of a key-value pair.</source>
          <target state="translated">通用哈希表,由键值对组成。</target>
        </trans-unit>
        <trans-unit id="54e8bb6d675a2725d1d4b86c632445dea3d31b1b" translate="yes" xml:space="preserve">
          <source>Generic inference restrictions</source>
          <target state="translated">通用推理限制</target>
        </trans-unit>
        <trans-unit id="5e6ad75e310df0542586553577d204406a0479d0" translate="yes" xml:space="preserve">
          <source>Generic instantiations are owned by their originating generic symbol. This proc skips such owners and goes straight to the owner of the generic itself (the module or the enclosing proc).</source>
          <target state="translated">泛型实例由其原始泛型符号拥有。这个 proc 跳过了这些所有者,直接转到 generic 本身的所有者那里(模块或外层 proc)。</target>
        </trans-unit>
        <trans-unit id="c80a0a651229e4de9a85da8c186fe02e0a43aa3f" translate="yes" xml:space="preserve">
          <source>Generic lexicographic &lt;code&gt;&amp;lt;&lt;/code&gt; operator for tuples that is lifted from the components of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;. This implementation uses &lt;code&gt;cmp&lt;/code&gt;.</source>
          <target state="translated">从 &lt;code&gt;x&lt;/code&gt; 和 &lt;code&gt;y&lt;/code&gt; 的组成部分中提炼出的元组的通用词法 &lt;code&gt;&amp;lt;&lt;/code&gt; 运算符。此实现使用 &lt;code&gt;cmp&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6f1b34ea201f817f3f494d59966d575af6313b1d" translate="yes" xml:space="preserve">
          <source>Generic lexicographic &lt;code&gt;&amp;lt;=&lt;/code&gt; operator for tuples that is lifted from the components of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;. This implementation uses &lt;code&gt;cmp&lt;/code&gt;.</source>
          <target state="translated">从 &lt;code&gt;x&lt;/code&gt; 和 &lt;code&gt;y&lt;/code&gt; 的组成部分中提取出的元组的通用词典编目 &lt;code&gt;&amp;lt;=&lt;/code&gt; 运算符。此实现使用 &lt;code&gt;cmp&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2b4ec6bb77472d676b0b71755309ad80e343f837" translate="yes" xml:space="preserve">
          <source>Generic match: &lt;code&gt;f&lt;/code&gt; is a generic type and &lt;code&gt;a&lt;/code&gt; matches, for instance &lt;code&gt;a&lt;/code&gt; is &lt;code&gt;int&lt;/code&gt; and &lt;code&gt;f&lt;/code&gt; is a generic (constrained) parameter type (like in &lt;code&gt;[T]&lt;/code&gt; or &lt;code&gt;[T: int|char]&lt;/code&gt;.</source>
          <target state="translated">通用匹配： &lt;code&gt;f&lt;/code&gt; 是一个通用的类型和 &lt;code&gt;a&lt;/code&gt; 比赛，例如 &lt;code&gt;a&lt;/code&gt; 是 &lt;code&gt;int&lt;/code&gt; 和 &lt;code&gt;f&lt;/code&gt; 是一个通用的（受约束）参数类型（如在 &lt;code&gt;[T]&lt;/code&gt; 或 &lt;code&gt;[T: int|char]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5e2cd7649b731671a13f778e5ca52832337336a2" translate="yes" xml:space="preserve">
          <source>Generic ordinal type. Includes integer, bool, character, and enumeration types as well as their subtypes. Note &lt;em&gt;uint&lt;/em&gt; and &lt;em&gt;uint64&lt;/em&gt; are not ordinal types for implementation reasons</source>
          <target state="translated">通用序数类型。包括整数，布尔型，字符型和枚举类型及其子类型。注意&lt;em&gt;uint&lt;/em&gt;和&lt;em&gt;uint64&lt;/em&gt;出于实现原因不是序数类型</target>
        </trans-unit>
        <trans-unit id="b2e02c2b9e86e7cd2c89e27a604e3f3aebbcca9d" translate="yes" xml:space="preserve">
          <source>Generic ordinal type. Includes integer, bool, character, and enumeration types as well as their subtypes. See also &lt;code&gt;SomeOrdinal&lt;/code&gt;.</source>
          <target state="translated">通用序数类型。包括整数，布尔型，字符和枚举类型及其子类型。另请参见 &lt;code&gt;SomeOrdinal&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="205cba3940d3dacf00b9f300477ac45b29168176" translate="yes" xml:space="preserve">
          <source>Generic peek procedure. Peeks &lt;code&gt;result&lt;/code&gt; from the stream &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">通用的窥视程序。偷看 &lt;code&gt;result&lt;/code&gt; 从流 &lt;code&gt;s&lt;/code&gt; 产生的。</target>
        </trans-unit>
        <trans-unit id="af374b805d45c5e3931a72561172f771a870d67b" translate="yes" xml:space="preserve">
          <source>Generic proc for adding a container &lt;code&gt;y&lt;/code&gt; to a container &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">用于将容器 &lt;code&gt;y&lt;/code&gt; 添加到容器 &lt;code&gt;x&lt;/code&gt; 的通用proc 。</target>
        </trans-unit>
        <trans-unit id="ab9bb79fde5784544753502a2ab6bdd84e5e8025" translate="yes" xml:space="preserve">
          <source>Generic proc for adding a data item &lt;code&gt;y&lt;/code&gt; to a container &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">用于将数据项 &lt;code&gt;y&lt;/code&gt; 添加到容器 &lt;code&gt;x&lt;/code&gt; 的通用proc 。</target>
        </trans-unit>
        <trans-unit id="59d85eb1d2101a47518908a9543ab04dd38c3be8" translate="yes" xml:space="preserve">
          <source>Generic proc for adding a data item &lt;em&gt;y&lt;/em&gt; to a container &lt;em&gt;x&lt;/em&gt;. For containers that have an order, &lt;em&gt;add&lt;/em&gt; means &lt;em&gt;append&lt;/em&gt;. New generic containers should also call their adding proc &lt;em&gt;add&lt;/em&gt; for consistency. Generic code becomes much easier to write if the Nim naming scheme is respected.</source>
          <target state="translated">用于将数据项&lt;em&gt;y&lt;/em&gt;添加到容器&lt;em&gt;x的&lt;/em&gt;通用proc 。对于有订单的容器，&lt;em&gt;添加&lt;/em&gt;方法&lt;em&gt;append&lt;/em&gt;。新的通用容器还应调用其添加过程&lt;em&gt;add&lt;/em&gt;以保持一致性。如果遵守Nim命名方案，则通用代码将变得更容易编写。</target>
        </trans-unit>
        <trans-unit id="29c3bf9a1541d144b2e76c7c575756893384b0a5" translate="yes" xml:space="preserve">
          <source>Generic read procedure. Reads &lt;code&gt;result&lt;/code&gt; from the stream &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">通用读取过程。从流 &lt;code&gt;s&lt;/code&gt; 读取 &lt;code&gt;result&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dbccc6a656c4c0fcf5215bff94a25f9c34e2bcf1" translate="yes" xml:space="preserve">
          <source>Generic type to construct a varargs type.</source>
          <target state="translated">构建一个varargs类型的通用类型。</target>
        </trans-unit>
        <trans-unit id="d4c17034fe5c9e8772b30101d8cc632e4a17baf3" translate="yes" xml:space="preserve">
          <source>Generic type to construct bit sets.</source>
          <target state="translated">构建位集的通用类型。</target>
        </trans-unit>
        <trans-unit id="082c9d1651fdd2acdb7f2c31b3f3648b7afec885" translate="yes" xml:space="preserve">
          <source>Generic type to construct fixed-length arrays.</source>
          <target state="translated">构建固定长度数组的通用类型。</target>
        </trans-unit>
        <trans-unit id="ce68ddc8e58b7a3242f91b2251724e6a4a8e1dda" translate="yes" xml:space="preserve">
          <source>Generic type to construct open arrays. Open arrays are implemented as a pointer to the array data and a length field.</source>
          <target state="translated">构建开放式数组的通用类型。开放式数组的实现方式是指向数组数据的指针和一个长度字段。</target>
        </trans-unit>
        <trans-unit id="a145c1c6d93be237b998460577b653c1465acceb" translate="yes" xml:space="preserve">
          <source>Generic type to construct range types.</source>
          <target state="translated">构建范围类型的通用类型。</target>
        </trans-unit>
        <trans-unit id="a5a528710df29c84abff0cbb0679efaae048d50e" translate="yes" xml:space="preserve">
          <source>Generic type to construct sequences.</source>
          <target state="translated">构建序列的通用类型。</target>
        </trans-unit>
        <trans-unit id="78a0e3726f6a2b4d101a3ab834663f5ab843367b" translate="yes" xml:space="preserve">
          <source>Generic write procedure. Writes &lt;code&gt;x&lt;/code&gt; to the stream &lt;code&gt;s&lt;/code&gt;. Implementation:</source>
          <target state="translated">通用写过程。将 &lt;code&gt;x&lt;/code&gt; 写入流 &lt;code&gt;s&lt;/code&gt; 。执行：</target>
        </trans-unit>
        <trans-unit id="233fac928becc03e933e67dfcab3334426f64894" translate="yes" xml:space="preserve">
          <source>GenericTypes:</source>
          <target state="translated">GenericTypes:</target>
        </trans-unit>
        <trans-unit id="80dadd86173d0ff3979257793d4e45beb238b6a2" translate="yes" xml:space="preserve">
          <source>Generics</source>
          <target state="translated">Generics</target>
        </trans-unit>
        <trans-unit id="3b461060a51b8a72f2a4cb78364c85efb904c7a8" translate="yes" xml:space="preserve">
          <source>Generics are Nim's means to parametrize procs, iterators or types with &lt;span id=&quot;type-parameters_1&quot;&gt;type parameters&lt;/span&gt;. Depending on context, the brackets are used either to introduce type parameters or to instantiate a generic proc, iterator or type.</source>
          <target state="translated">泛型是Nim对带有&lt;span id=&quot;type-parameters_1&quot;&gt;类型参数的&lt;/span&gt; proc，迭代器或类型进行参数化的手段。根据上下文，方括号用于引入类型参数或实例化通用proc，迭代器或类型。</target>
        </trans-unit>
        <trans-unit id="6bf7d7c0d998ce8339e4157956b89967e9e5d710" translate="yes" xml:space="preserve">
          <source>Generics are Nim's means to parametrize procs, iterators or types with &lt;span id=&quot;type-parameters_1&quot;&gt;type parameters&lt;/span&gt;. Depending on the context, the brackets are used either to introduce type parameters or to instantiate a generic proc, iterator, or type.</source>
          <target state="translated">泛型是Nim对带有&lt;span id=&quot;type-parameters_1&quot;&gt;类型参数的&lt;/span&gt;proc，迭代器或类型进行参数化的手段。根据上下文，方括号可用于引入类型参数或实例化通用proc，迭代器或类型。</target>
        </trans-unit>
        <trans-unit id="ba8db3e0e66211eabb3c4f25fee0a1d1829b963a" translate="yes" xml:space="preserve">
          <source>Generics are Nim's means to parametrize procs, iterators or types with &lt;span id=&quot;type-parameters_1&quot;&gt;type parameters&lt;/span&gt;. They are most useful for efficient type safe containers:</source>
          <target state="translated">泛型是Nim对带有&lt;span id=&quot;type-parameters_1&quot;&gt;类型参数的&lt;/span&gt; proc，迭代器或类型进行参数化的手段。它们对于高效类型安全的容器最有用：</target>
        </trans-unit>
        <trans-unit id="5219c72bd04864634a1e88b3e8f66e09113a7f2a" translate="yes" xml:space="preserve">
          <source>Get &lt;code&gt;n&lt;/code&gt;'s &lt;code&gt;i&lt;/code&gt;'th child.</source>
          <target state="translated">获取 &lt;code&gt;n&lt;/code&gt; 的 &lt;code&gt;i&lt;/code&gt; '日的孩子。</target>
        </trans-unit>
        <trans-unit id="d40e8a56834c6a89deae8c24980dea5a106cc1dc" translate="yes" xml:space="preserve">
          <source>Get PSK identity.</source>
          <target state="translated">获取PSK身份。</target>
        </trans-unit>
        <trans-unit id="9c6b60808c47d23e2b6771a2d38777564ed24388" translate="yes" xml:space="preserve">
          <source>Get Proxy URL from environment variables:</source>
          <target state="translated">从环境变量中获取Proxy URL。</target>
        </trans-unit>
        <trans-unit id="07a2ad39e6ce26d304194dfe8051981d34f5f859" translate="yes" xml:space="preserve">
          <source>Get current implementation of &lt;code&gt;callSoon&lt;/code&gt;.</source>
          <target state="translated">获取 &lt;code&gt;callSoon&lt;/code&gt; 的当前实现。</target>
        </trans-unit>
        <trans-unit id="5454dcbb9ac5865ed0ee9c43e8d6c25d91b7171b" translate="yes" xml:space="preserve">
          <source>Get current rounding direction.</source>
          <target state="translated">获取当前的取舍方向。</target>
        </trans-unit>
        <trans-unit id="e9ac6d6364d34abd1d69bdc24707956d93bef51b" translate="yes" xml:space="preserve">
          <source>Get network socket, useful if you want to find out more details about the connection</source>
          <target state="translated">获取网络套接字,如果你想了解更多关于连接的细节,很有用。</target>
        </trans-unit>
        <trans-unit id="1c7502d212d9b35c5b4b2cd744a48143b4ef4139" translate="yes" xml:space="preserve">
          <source>Get string representation of &lt;code&gt;TimeInterval&lt;/code&gt;.</source>
          <target state="translated">获取 &lt;code&gt;TimeInterval&lt;/code&gt; 的字符串表示形式。</target>
        </trans-unit>
        <trans-unit id="12714742014fb6228a1c3f36ea543012ada95c75" translate="yes" xml:space="preserve">
          <source>Get string representation of &lt;em&gt;TimeInterval&lt;/em&gt;</source>
          <target state="translated">获取&lt;em&gt;TimeInterval的&lt;/em&gt;字符串表示形式&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="ad54c08fe8749a0e81ff7837b23c3157c0895d10" translate="yes" xml:space="preserve">
          <source>Get the &lt;code&gt;Timezone&lt;/code&gt; implementation for the UTC timezone.</source>
          <target state="translated">获取UTC时区的 &lt;code&gt;Timezone&lt;/code&gt; 实现。</target>
        </trans-unit>
        <trans-unit id="130ee2f075e62422a363a8a189c3d9f93794fbf2" translate="yes" xml:space="preserve">
          <source>Get the &lt;code&gt;Timezone&lt;/code&gt; implementation for the local timezone.</source>
          <target state="translated">获取本地时区的 &lt;code&gt;Timezone&lt;/code&gt; 实现。</target>
        </trans-unit>
        <trans-unit id="7990a11666434ac5f784621308133dfb7f2f044d" translate="yes" xml:space="preserve">
          <source>Get the current &lt;code&gt;MonoTime&lt;/code&gt; timestamp.</source>
          <target state="translated">获取当前的 &lt;code&gt;MonoTime&lt;/code&gt; 时间戳。</target>
        </trans-unit>
        <trans-unit id="b5c7e7bb6bfadc9b10aaa987304f7abf1345c0db" translate="yes" xml:space="preserve">
          <source>Get the current time as a &lt;code&gt;DateTime&lt;/code&gt; in the local timezone.</source>
          <target state="translated">获取当前时间作为本地时区中的 &lt;code&gt;DateTime&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="11562b1334027fecd5dcb805739b82f536f9c783" translate="yes" xml:space="preserve">
          <source>Get the fractional part of a &lt;code&gt;Time&lt;/code&gt; as the number of nanoseconds of the second.</source>
          <target state="translated">得到的小数部分 &lt;code&gt;Time&lt;/code&gt; 为第二的纳秒数。</target>
        </trans-unit>
        <trans-unit id="28122ec43897f8843b8ea9fdf99ecd6c1be76468" translate="yes" xml:space="preserve">
          <source>Get the longest representable duration of negative direction.</source>
          <target state="translated">获取负方向的最长可表示时间。</target>
        </trans-unit>
        <trans-unit id="7bdc6c0918cf5d26da44cabeb23abccc70e09b4e" translate="yes" xml:space="preserve">
          <source>Get the longest representable duration.</source>
          <target state="translated">获取最长的可表示持续时间。</target>
        </trans-unit>
        <trans-unit id="ba447136ea635e0aab9dc6afff0ec9f2acc09668" translate="yes" xml:space="preserve">
          <source>Get the next token from the parser's lexer, and store it in the parser's &lt;code&gt;tok&lt;/code&gt; member.</source>
          <target state="translated">从解析器的词法分析器中获取下一个令牌，并将其存储在解析器的 &lt;code&gt;tok&lt;/code&gt; 成员中。</target>
        </trans-unit>
        <trans-unit id="d064c02ff711820791ab991a62468a0815f7d265" translate="yes" xml:space="preserve">
          <source>Get the number of days in &lt;code&gt;month&lt;/code&gt; of &lt;code&gt;year&lt;/code&gt;.</source>
          <target state="translated">获取 &lt;code&gt;year&lt;/code&gt; 中 &lt;code&gt;month&lt;/code&gt; 的天数。</target>
        </trans-unit>
        <trans-unit id="bf89b2420cafea5152352e14cc484f7a750ccd87" translate="yes" xml:space="preserve">
          <source>Get the number of days in a &lt;code&gt;month&lt;/code&gt; of a &lt;code&gt;year&lt;/code&gt;.</source>
          <target state="translated">获取 &lt;code&gt;year&lt;/code&gt; &lt;code&gt;month&lt;/code&gt; 中的天数。</target>
        </trans-unit>
        <trans-unit id="a91e315a40bea130b02d973a8401879d06157a88" translate="yes" xml:space="preserve">
          <source>Get the number of days in a &lt;code&gt;year&lt;/code&gt;</source>
          <target state="translated">获取 &lt;code&gt;year&lt;/code&gt; 的天数</target>
        </trans-unit>
        <trans-unit id="4f8e6af49ebd57b98c32b3bef36972e51d6956de" translate="yes" xml:space="preserve">
          <source>Get the pragma of a proc type These will be expanded</source>
          <target state="translated">获取一个proc类型的pragma,这些将被展开。</target>
        </trans-unit>
        <trans-unit id="b4f54efaa84c02fb948f2230067248cb50cecece" translate="yes" xml:space="preserve">
          <source>Get the pragma of a proc type. These will be expanded.</source>
          <target state="translated">获取一个proc类型的pragma。这些将被展开。</target>
        </trans-unit>
        <trans-unit id="c2fb3d2f912aad36a7a2fab3df616b85598528a1" translate="yes" xml:space="preserve">
          <source>Get the socket's local address and port number.</source>
          <target state="translated">获取socket的本地地址和端口号。</target>
        </trans-unit>
        <trans-unit id="ed61d3d7776639eccbb79106f8cddd298594c0ca" translate="yes" xml:space="preserve">
          <source>Get the socket's peer address and port number.</source>
          <target state="translated">获取socket的对等体地址和端口号。</target>
        </trans-unit>
        <trans-unit id="723d6575987f98cca4d17c0950fa5dba4078249b" translate="yes" xml:space="preserve">
          <source>Get the string of an identifier node</source>
          <target state="translated">获取标识符节点的字符串</target>
        </trans-unit>
        <trans-unit id="12073f349102ad84aa4a0525eafd4479cd49fcf0" translate="yes" xml:space="preserve">
          <source>Get the string of an identifier node.</source>
          <target state="translated">获取标识符节点的字符串。</target>
        </trans-unit>
        <trans-unit id="3e3f4a8c20a8d9ffaecbbd07858ab29467163519" translate="yes" xml:space="preserve">
          <source>Get the string representation of the &lt;code&gt;Option&lt;/code&gt;.</source>
          <target state="translated">获取 &lt;code&gt;Option&lt;/code&gt; 的字符串表示形式。</target>
        </trans-unit>
        <trans-unit id="c99521d6ef98a806e912444f989eca6e635eefe5" translate="yes" xml:space="preserve">
          <source>Get the string representation of this option. If the option has a value, the result will be &lt;em&gt;Some(x)&lt;/em&gt; where &lt;em&gt;x&lt;/em&gt; is the string representation of the contained value. If the option does not have a value, the result will be &lt;em&gt;None[T]&lt;/em&gt; where &lt;em&gt;T&lt;/em&gt; is the name of the type contained in the option.</source>
          <target state="translated">获取此选项的字符串表示形式。如果选项具有值，则结果将为&lt;em&gt;Some（x）&lt;/em&gt;，其中&lt;em&gt;x&lt;/em&gt;是所包含值的字符串表示形式。如果选项没有值，则结果将为&lt;em&gt;None [T]&lt;/em&gt;，其中&lt;em&gt;T&lt;/em&gt;是选项中包含的类型的名称。</target>
        </trans-unit>
        <trans-unit id="d460591b4c527055a972fa5dd0628a7d7d96c7d1" translate="yes" xml:space="preserve">
          <source>Get type information for &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">获取 &lt;code&gt;x&lt;/code&gt; 的类型信息。</target>
        </trans-unit>
        <trans-unit id="b87fde255210c1b5747a10ad9f9fce9a84709dfe" translate="yes" xml:space="preserve">
          <source>Gets &lt;code&gt;n&lt;/code&gt;'s tag as a &lt;code&gt;HtmlTag&lt;/code&gt;.</source>
          <target state="translated">获取 &lt;code&gt;n&lt;/code&gt; 的标签作为 &lt;code&gt;HtmlTag&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e6e81c9ca7b9838c7aad39a88a6bc88879fb7071" translate="yes" xml:space="preserve">
          <source>Gets &lt;em&gt;n&lt;/em&gt;'s tag as a &lt;code&gt;HtmlTag&lt;/code&gt;.</source>
          <target state="translated">获取&lt;em&gt;n&lt;/em&gt;的标签作为 &lt;code&gt;HtmlTag&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8b1564152a0ef38676369c9a5ef127f13b4deb3e" translate="yes" xml:space="preserve">
          <source>Gets a cookie. If no cookie of &lt;code&gt;name&lt;/code&gt; exists, &quot;&quot; is returned.</source>
          <target state="translated">获取一个cookie。如果不存在 &lt;code&gt;name&lt;/code&gt; cookie，则返回&amp;ldquo;&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="13689de7004dbf96d752346d793d33acafe479cd" translate="yes" xml:space="preserve">
          <source>Gets a cookie. If no cookie of &lt;em&gt;name&lt;/em&gt; exists, &quot;&quot; is returned.</source>
          <target state="translated">获取一个cookie。如果不存在&lt;em&gt;名称的&lt;/em&gt; cookie，则返回&amp;ldquo;&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="b7973bd1edf3d8cfdba5e45c82a3bad70d6e244f" translate="yes" xml:space="preserve">
          <source>Gets a field from a &lt;code&gt;JObject&lt;/code&gt;, which must not be nil. If the value at &lt;code&gt;name&lt;/code&gt; does not exist, raises KeyError.</source>
          <target state="translated">从 &lt;code&gt;JObject&lt;/code&gt; 获取一个字段，该字段不能为nil。如果 &lt;code&gt;name&lt;/code&gt; 的值不存在，则引发KeyError。</target>
        </trans-unit>
        <trans-unit id="a11dc4d2dc18b3b4694d9f2f07be175ba7c66cef" translate="yes" xml:space="preserve">
          <source>Gets a field from a &lt;code&gt;node&lt;/code&gt;. If &lt;code&gt;node&lt;/code&gt; is nil or not an object or value at &lt;code&gt;key&lt;/code&gt; does not exist, returns nil</source>
          <target state="translated">从 &lt;code&gt;node&lt;/code&gt; 获取字段。如果 &lt;code&gt;node&lt;/code&gt; 为nil或 &lt;code&gt;key&lt;/code&gt; 上的对象或值不存在，则返回nil</target>
        </trans-unit>
        <trans-unit id="a9ee6b6486187c570cea3bd16707c23edffa1180" translate="yes" xml:space="preserve">
          <source>Gets a field from a &lt;em&gt;JObject&lt;/em&gt;, which must not be nil. If the value at &lt;em&gt;name&lt;/em&gt; does not exist, raises KeyError.</source>
          <target state="translated">从&lt;em&gt;JObject&lt;/em&gt;获取一个字段，该字段不能为nil。如果&lt;em&gt;name&lt;/em&gt;的值不存在，则引发KeyError。</target>
        </trans-unit>
        <trans-unit id="f35abda3cff44672e27443c29310a4342a3a7c85" translate="yes" xml:space="preserve">
          <source>Gets a field from a &lt;em&gt;node&lt;/em&gt;. If &lt;em&gt;node&lt;/em&gt; is nil or not an object or value at &lt;em&gt;key&lt;/em&gt; does not exist, returns nil</source>
          <target state="translated">从&lt;em&gt;节点&lt;/em&gt;获取字段。如果&lt;em&gt;node&lt;/em&gt;为nil或&lt;em&gt;key&lt;/em&gt;上的对象或值不存在，则返回nil</target>
        </trans-unit>
        <trans-unit id="35bb8b12e628c0e69e3c45da868773dc22a5afa1" translate="yes" xml:space="preserve">
          <source>Gets a field of &lt;code&gt;x&lt;/code&gt;; &lt;code&gt;x&lt;/code&gt; represents an object or a tuple.</source>
          <target state="translated">获取 &lt;code&gt;x&lt;/code&gt; 的字段； &lt;code&gt;x&lt;/code&gt; 表示对象或元组。</target>
        </trans-unit>
        <trans-unit id="d9e896ea8856279a92c23ca43823ce2065dfa17c" translate="yes" xml:space="preserve">
          <source>Gets extension which corresponds to &lt;code&gt;mimetype&lt;/code&gt;. Returns &lt;code&gt;default&lt;/code&gt; if &lt;code&gt;mimetype&lt;/code&gt; could not be found. Extensions are returned without the leading dot.</source>
          <target state="translated">获取对应于 &lt;code&gt;mimetype&lt;/code&gt; 的扩展名。如果找不到 &lt;code&gt;mimetype&lt;/code&gt; ,则返回 &lt;code&gt;default&lt;/code&gt; 。返回的扩展名没有前导点。</target>
        </trans-unit>
        <trans-unit id="d2af21c40c8b2beb9e88592fc792fd5b511c29f1" translate="yes" xml:space="preserve">
          <source>Gets extension which corresponds to &lt;code&gt;mimetype&lt;/code&gt;. Returns &lt;code&gt;default&lt;/code&gt; if &lt;code&gt;mimetype&lt;/code&gt; could not be found. Extensions are returned without the leading dot. &lt;code&gt;mimetype&lt;/code&gt; is lowercased before querying &lt;code&gt;mimedb&lt;/code&gt;.</source>
          <target state="translated">获取对应于 &lt;code&gt;mimetype&lt;/code&gt; 的扩展名。如果找不到 &lt;code&gt;mimetype&lt;/code&gt; ,则返回 &lt;code&gt;default&lt;/code&gt; 。返回的扩展名不带前导点。在查询 &lt;code&gt;mimedb&lt;/code&gt; 之前， &lt;code&gt;mimetype&lt;/code&gt; 是小写的。</target>
        </trans-unit>
        <trans-unit id="d08dcb1eea4061ffa3605412e9746813dfd3d3a3" translate="yes" xml:space="preserve">
          <source>Gets mimetype which corresponds to &lt;code&gt;ext&lt;/code&gt;. Returns &lt;code&gt;default&lt;/code&gt; if &lt;code&gt;ext&lt;/code&gt; could not be found. &lt;code&gt;ext&lt;/code&gt; can start with an optional dot which is ignored.</source>
          <target state="translated">获取对应于 &lt;code&gt;ext&lt;/code&gt; 的 mimetype 。如果找不到 &lt;code&gt;ext&lt;/code&gt; ,则返回 &lt;code&gt;default&lt;/code&gt; 。 &lt;code&gt;ext&lt;/code&gt; 可以从被忽略的可选点开始。</target>
        </trans-unit>
        <trans-unit id="b40b8b0e4a7f80635eb7dd5403cfbd0754192e46" translate="yes" xml:space="preserve">
          <source>Gets mimetype which corresponds to &lt;code&gt;ext&lt;/code&gt;. Returns &lt;code&gt;default&lt;/code&gt; if &lt;code&gt;ext&lt;/code&gt; could not be found. &lt;code&gt;ext&lt;/code&gt; can start with an optional dot which is ignored. &lt;code&gt;ext&lt;/code&gt; is lowercased before querying &lt;code&gt;mimedb&lt;/code&gt;.</source>
          <target state="translated">获取与 &lt;code&gt;ext&lt;/code&gt; 对应的mimetype 。如果找不到 &lt;code&gt;ext&lt;/code&gt; ,则返回 &lt;code&gt;default&lt;/code&gt; 。 &lt;code&gt;ext&lt;/code&gt; 可以从一个可选的点开始，该点被忽略。在查询 &lt;code&gt;mimedb&lt;/code&gt; 之前， &lt;code&gt;ext&lt;/code&gt; 是小写的。</target>
        </trans-unit>
        <trans-unit id="1714560401ef5d53bb12109cf2cb88182bbf5caa" translate="yes" xml:space="preserve">
          <source>Gets the &lt;em&gt;NonTerminalFlag&lt;/em&gt;-typed flags field of the parent &lt;em&gt;Peg&lt;/em&gt; variant object of a given &lt;em&gt;NonTerminal&lt;/em&gt;.</source>
          <target state="translated">获取给定&lt;em&gt;NonTerminal&lt;/em&gt;的父&lt;em&gt;Peg&lt;/em&gt;变量对象的&lt;em&gt;NonTerminalFlag&lt;/em&gt;类型的flags字段。&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="92e639fc7e6c6f3a36a4b433e2efd44d76d332e9" translate="yes" xml:space="preserve">
          <source>Gets the &lt;em&gt;Peg&lt;/em&gt; object representing the rule definition of the parent &lt;em&gt;Peg&lt;/em&gt; object variant of a given &lt;em&gt;NonTerminal&lt;/em&gt;.</source>
          <target state="translated">获取&lt;em&gt;钉&lt;/em&gt;表示父的规则定义对象&lt;em&gt;钉&lt;/em&gt;在给定的对象变型&lt;em&gt;非终结&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="c65ea61d4f736dc4703e718edfd99f538b4da59e" translate="yes" xml:space="preserve">
          <source>Gets the ID of the currently running thread.</source>
          <target state="translated">获取当前运行的线程的ID。</target>
        </trans-unit>
        <trans-unit id="f2a31ab6e34d28da2594120eec11f6a9e165ade3" translate="yes" xml:space="preserve">
          <source>Gets the Key value of the specified Section.</source>
          <target state="translated">获取指定章节的键值。</target>
        </trans-unit>
        <trans-unit id="91e7e705912c92bc18ff83aa63ee0725cc8dd702" translate="yes" xml:space="preserve">
          <source>Gets the Nim command that the compiler has been invoked with, for example &quot;c&quot;, &quot;js&quot;, &quot;build&quot;, &quot;help&quot;.</source>
          <target state="translated">获取编译器所调用的Nim命令,例如 &quot;c&quot;、&quot;js&quot;、&quot;build&quot;、&quot;help&quot;。</target>
        </trans-unit>
        <trans-unit id="db4276492a87292b45a2d798b8604d66f0972994" translate="yes" xml:space="preserve">
          <source>Gets the PSK identity provided by the client.</source>
          <target state="translated">获取客户端提供的PSK标识。</target>
        </trans-unit>
        <trans-unit id="ebc1991c3f4d76f5d82a1d1491c2bca82e49c8c2" translate="yes" xml:space="preserve">
          <source>Gets the associated text with the node &lt;code&gt;n&lt;/code&gt;.</source>
          <target state="translated">获取与节点 &lt;code&gt;n&lt;/code&gt; 相关的文本。</target>
        </trans-unit>
        <trans-unit id="936f98726360698f2fbd3879fd051a8034e01427" translate="yes" xml:space="preserve">
          <source>Gets the attributes belonging to &lt;code&gt;n&lt;/code&gt;.</source>
          <target state="translated">获取属于 &lt;code&gt;n&lt;/code&gt; 的属性。</target>
        </trans-unit>
        <trans-unit id="3ac591fc9023da962499b05992f4a42f885cb205" translate="yes" xml:space="preserve">
          <source>Gets the base type's kind; &lt;code&gt;akNone&lt;/code&gt; is returned if &lt;code&gt;x&lt;/code&gt; has no base type.</source>
          <target state="translated">获取基本类型的种类；如果 &lt;code&gt;x&lt;/code&gt; 没有基本类型，则返回 &lt;code&gt;akNone&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b67e2b7f4cd722e96c019267fd8f4fe2119fe30d" translate="yes" xml:space="preserve">
          <source>Gets the client data of &lt;code&gt;n&lt;/code&gt;.</source>
          <target state="translated">获取 &lt;code&gt;n&lt;/code&gt; 的客户数据。</target>
        </trans-unit>
        <trans-unit id="654f49772dc846fc7e8b0b5fafe8aba913ce8713" translate="yes" xml:space="preserve">
          <source>Gets the column number of the definition of the parent &lt;em&gt;Peg&lt;/em&gt; object variant of a given &lt;em&gt;NonTerminal&lt;/em&gt;.</source>
          <target state="translated">获取给定&lt;em&gt;NonTerminal&lt;/em&gt;的父&lt;em&gt;Peg&lt;/em&gt;对象变量的定义的列号。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="bd81d39ed2660b2a192796678428676c0ea999cd" translate="yes" xml:space="preserve">
          <source>Gets the current clock time as a string of the format &lt;code&gt;HH:MM:SS&lt;/code&gt;.</source>
          <target state="translated">以 &lt;code&gt;HH:MM:SS&lt;/code&gt; 格式的字符串获取当前时钟时间。</target>
        </trans-unit>
        <trans-unit id="3261759c69cac472d4a177821c0ced7e8297f225" translate="yes" xml:space="preserve">
          <source>Gets the current date as a string of the format &lt;code&gt;YYYY-MM-DD&lt;/code&gt;.</source>
          <target state="translated">以 &lt;code&gt;YYYY-MM-DD&lt;/code&gt; 格式的字符串获取当前日期。</target>
        </trans-unit>
        <trans-unit id="60b12a7fed9331a75165888138ad3b08fe8cbcc6" translate="yes" xml:space="preserve">
          <source>Gets the current local clock time as a string of the format &lt;code&gt;HH:mm:ss&lt;/code&gt;.</source>
          <target state="translated">以 &lt;code&gt;HH:mm:ss&lt;/code&gt; 格式的字符串获取当前本地时钟时间。</target>
        </trans-unit>
        <trans-unit id="276d1c12f54046c33015b7f91c050da08f21e286" translate="yes" xml:space="preserve">
          <source>Gets the current local date as a string of the format &lt;code&gt;YYYY-MM-DD&lt;/code&gt;.</source>
          <target state="translated">以 &lt;code&gt;YYYY-MM-DD&lt;/code&gt; 格式的字符串获取当前本地日期。</target>
        </trans-unit>
        <trans-unit id="eef62ba4079b74bbe4d31e0e21d470ddb156867e" translate="yes" xml:space="preserve">
          <source>Gets the current stack trace. This only works for debug builds.</source>
          <target state="translated">获取当前的堆栈跟踪。这只适用于调试构建。</target>
        </trans-unit>
        <trans-unit id="247d662645bc1637ead4656674f1a702738e8829" translate="yes" xml:space="preserve">
          <source>Gets the current time as a &lt;code&gt;Time&lt;/code&gt; with nanosecond resolution.</source>
          <target state="translated">将当前时间作为具有纳秒分辨率的 &lt;code&gt;Time&lt;/code&gt; 获取。</target>
        </trans-unit>
        <trans-unit id="0387f3706b353d7ae3e0089106d53591957c6c1e" translate="yes" xml:space="preserve">
          <source>Gets the current time as a &lt;code&gt;Time&lt;/code&gt; with up to nanosecond resolution.</source>
          <target state="translated">将当前时间作为 &lt;code&gt;Time&lt;/code&gt; 获取，分辨率最高为纳秒。</target>
        </trans-unit>
        <trans-unit id="d15dce4c95e8e6cf70f2ff21d4705069a9f68f3e" translate="yes" xml:space="preserve">
          <source>Gets the enum field name as a string. &lt;code&gt;x&lt;/code&gt; needs to represent an enum but is only used to access the type information. The field name of &lt;code&gt;ordinalValue&lt;/code&gt; is returned.</source>
          <target state="translated">以字符串形式获取枚举字段名称。 &lt;code&gt;x&lt;/code&gt; 需要表示一个枚举，但仅用于访问类型信息。返回 &lt;code&gt;ordinalValue&lt;/code&gt; 的字段名称。</target>
        </trans-unit>
        <trans-unit id="53bd1efd24342f90bb1e0532dc257b89f8a50185" translate="yes" xml:space="preserve">
          <source>Gets the enum field name as a string. &lt;code&gt;x&lt;/code&gt; needs to represent an enum.</source>
          <target state="translated">以字符串形式获取枚举字段名称。 &lt;code&gt;x&lt;/code&gt; 需要代表一个枚举。</target>
        </trans-unit>
        <trans-unit id="40c31138e270bd37015494e80deb2dc7d4ff50d4" translate="yes" xml:space="preserve">
          <source>Gets the enum field ordinal from &lt;code&gt;name&lt;/code&gt;. &lt;code&gt;x&lt;/code&gt; needs to represent an enum but is only used to access the type information. In case of an error &lt;code&gt;low(int)&lt;/code&gt; is returned.</source>
          <target state="translated">从 &lt;code&gt;name&lt;/code&gt; 获取序数的枚举字段。 &lt;code&gt;x&lt;/code&gt; 需要表示一个枚举，但仅用于访问类型信息。如果发生错误，则返回 &lt;code&gt;low(int)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1c769de6a12c15bcc2c5b444e497708dc0f8ed81" translate="yes" xml:space="preserve">
          <source>Gets the global log filter.</source>
          <target state="translated">获取全局日志过滤器。</target>
        </trans-unit>
        <trans-unit id="f9ac85ebfe353ff303610a6fd2becb00c94ca921" translate="yes" xml:space="preserve">
          <source>Gets the inner text of &lt;code&gt;n&lt;/code&gt;:</source>
          <target state="translated">获取 &lt;code&gt;n&lt;/code&gt; 的内部文本：</target>
        </trans-unit>
        <trans-unit id="d8967e163fbdddcb42a598980b8edacf5b388afd" translate="yes" xml:space="preserve">
          <source>Gets the key value of the specified Section. Returns the specified default value if the specified key does not exist.</source>
          <target state="translated">获取指定Section的键值。如果指定的键值不存在,则返回指定的默认值。</target>
        </trans-unit>
        <trans-unit id="e9d0ac9e5207f2824570ddf9a5876cb435b1720a" translate="yes" xml:space="preserve">
          <source>Gets the line number of the definition of the parent &lt;em&gt;Peg&lt;/em&gt; object variant of a given &lt;em&gt;NonTerminal&lt;/em&gt;.</source>
          <target state="translated">获取给定&lt;em&gt;NonTerminal&lt;/em&gt;的父&lt;em&gt;Peg&lt;/em&gt;对象变量的定义的行号。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="56bd530836a48d9d37ff0198c3155398e3eb5899" translate="yes" xml:space="preserve">
          <source>Gets the name of the symbol represented by the parent &lt;em&gt;Peg&lt;/em&gt; object variant of a given &lt;em&gt;NonTerminal&lt;/em&gt;.</source>
          <target state="translated">获取由给定&lt;em&gt;NonTerminal&lt;/em&gt;的父&lt;em&gt;Peg&lt;/em&gt;对象变体表示的符号的名称。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="28c7fc583337027cefdf3b98cef719005d99ad53" translate="yes" xml:space="preserve">
          <source>Gets the node at &lt;code&gt;index&lt;/code&gt; in an Array. Result is undefined if &lt;code&gt;index&lt;/code&gt; is out of bounds, but as long as array bound checks are enabled it will result in an exception.</source>
          <target state="translated">获取数组中 &lt;code&gt;index&lt;/code&gt; 处的节点。如果 &lt;code&gt;index&lt;/code&gt; 超出范围，则结果是不确定的，但是只要启用了数组边界检查，就会导致异常。</target>
        </trans-unit>
        <trans-unit id="60fbf54936c22fd972d85ed8d34160d9e21cbc39" translate="yes" xml:space="preserve">
          <source>Gets the node at &lt;em&gt;index&lt;/em&gt; in a List. Result is undefined if &lt;em&gt;index&lt;/em&gt; is out of bounds</source>
          <target state="translated">获取列表中&lt;em&gt;索引&lt;/em&gt;处的节点。如果&lt;em&gt;索引&lt;/em&gt;超出范围，则结果不确定</target>
        </trans-unit>
        <trans-unit id="f194ace764156524b46a54cf14a3d07dfbe7aad4" translate="yes" xml:space="preserve">
          <source>Gets the node at &lt;em&gt;index&lt;/em&gt; in an Array. Result is undefined if &lt;em&gt;index&lt;/em&gt; is out of bounds, but as long as array bound checks are enabled it will result in an exception.</source>
          <target state="translated">获取数组中&lt;em&gt;索引&lt;/em&gt;处的节点。如果&lt;em&gt;索引&lt;/em&gt;超出范围，则结果是不确定的，但是只要启用了数组边界检查，就会导致异常。</target>
        </trans-unit>
        <trans-unit id="6156c88c4b6d8c7a399e02c694bf7eec39c53e38" translate="yes" xml:space="preserve">
          <source>Gets the prefix dir, usually the parent directory where the binary resides.</source>
          <target state="translated">获取前缀dir,通常是二进制文件所在的父目录。</target>
        </trans-unit>
        <trans-unit id="84c0ad78f97cef0021b972740f623249afeb780e" translate="yes" xml:space="preserve">
          <source>Gets the stack trace associated with &lt;code&gt;e&lt;/code&gt;, which is the stack that lead to the &lt;code&gt;raise&lt;/code&gt; statement. This only works for debug builds.</source>
          <target state="translated">获取与 &lt;code&gt;e&lt;/code&gt; 关联的堆栈跟踪，e是导致 &lt;code&gt;raise&lt;/code&gt; 语句的堆栈。这仅适用于调试版本。</target>
        </trans-unit>
        <trans-unit id="717d2eaa7b1c9858103e02d4ee329a6170804578" translate="yes" xml:space="preserve">
          <source>Gets the tag name of &lt;code&gt;n&lt;/code&gt;.</source>
          <target state="translated">获取标签名称 &lt;code&gt;n&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7b3214d0ee72fb998da82e83db8adabb0cda1041" translate="yes" xml:space="preserve">
          <source>Gets the type kind.</source>
          <target state="translated">获取类型种类。</target>
        </trans-unit>
        <trans-unit id="20eff627fc48b7117674c6eedeb81d0d7a63a779" translate="yes" xml:space="preserve">
          <source>Gets time after the UNIX epoch (1970) in seconds. It is a float because sub-second resolution is likely to be supported (depending on the hardware/OS).</source>
          <target state="translated">获取UNIX纪元(1970年)之后的时间,单位为秒。它是一个浮点数,因为亚秒级的分辨率可能会被支持(取决于硬件/操作系统)。</target>
        </trans-unit>
        <trans-unit id="86f692087775e023d27920954ba6a5491569dce2" translate="yes" xml:space="preserve">
          <source>Gets time spent that the CPU spent to run the current process in seconds. This may be more useful for benchmarking than &lt;code&gt;epochTime&lt;/code&gt;. However, it may measure the real time instead (depending on the OS). The value of the result has no meaning. To generate useful timing values, take the difference between the results of two &lt;code&gt;cpuTime&lt;/code&gt; calls:</source>
          <target state="translated">获取花费的时间（以秒为单位），CPU花费在运行当前进程上。这对于基准测试可能比 &lt;code&gt;epochTime&lt;/code&gt; 更有用。但是，它可能会测量实时时间（取决于操作系统）。结果的值没有意义。要生成有用的计时值，请取两个 &lt;code&gt;cpuTime&lt;/code&gt; 调用的结果之差：</target>
        </trans-unit>
        <trans-unit id="329aa8af8f1565e4ae1eb4a65d49566bcb3acd69" translate="yes" xml:space="preserve">
          <source>Getting a blocking client from an AsyncSocket</source>
          <target state="translated">从AsyncSocket获取阻塞客户端</target>
        </trans-unit>
        <trans-unit id="fccf5719a0d1339930e0856ea9d166d1d319d2fa" translate="yes" xml:space="preserve">
          <source>Gives the difference between &lt;code&gt;startDt&lt;/code&gt; and &lt;code&gt;endDt&lt;/code&gt; as a &lt;code&gt;TimeInterval&lt;/code&gt;. The following guarantees about the result is given:</source>
          <target state="translated">将 &lt;code&gt;startDt&lt;/code&gt; 和 &lt;code&gt;endDt&lt;/code&gt; 之间的差异作为 &lt;code&gt;TimeInterval&lt;/code&gt; 给出。提供有关结果的以下保证：</target>
        </trans-unit>
        <trans-unit id="f03e100088f945af4a3c80b4c540244a44679c31" translate="yes" xml:space="preserve">
          <source>Global configuration files under /etc/nim</source>
          <target state="translated">/etc/nim下的全局配置文件</target>
        </trans-unit>
        <trans-unit id="3ef086870f2969d8fb668096b14518cd761c2738" translate="yes" xml:space="preserve">
          <source>GlobalVar</source>
          <target state="translated">GlobalVar</target>
        </trans-unit>
        <trans-unit id="2e0b45f2a456e8db55f08d7b65e87593a3e9a140" translate="yes" xml:space="preserve">
          <source>Go</source>
          <target state="translated">Go</target>
        </trans-unit>
        <trans-unit id="334f5022e7034a30c9d505d7796ba0335c961cbe" translate="yes" xml:space="preserve">
          <source>Goal.borrowChecking</source>
          <target state="translated">Goal.borrowChecking</target>
        </trans-unit>
        <trans-unit id="96311f1bbb4b89b89e7fee8588b3ce2f77acac56" translate="yes" xml:space="preserve">
          <source>Goal.constParameters</source>
          <target state="translated">Goal.constParameters</target>
        </trans-unit>
        <trans-unit id="652a20e779c3edb40a565e088aa9ec6a08f8a6c6" translate="yes" xml:space="preserve">
          <source>Goal.cursorInference</source>
          <target state="translated">Goal.cursorInference</target>
        </trans-unit>
        <trans-unit id="0cabce54968037724a189b4346cbb44ec0484c3d" translate="yes" xml:space="preserve">
          <source>Goal:</source>
          <target state="translated">Goal:</target>
        </trans-unit>
        <trans-unit id="03d0355833db6c38ad46b8c25161e0ab548b7757" translate="yes" xml:space="preserve">
          <source>Graceful Fallback</source>
          <target state="translated">优雅的后退</target>
        </trans-unit>
        <trans-unit id="dd17342cb47b948d64f169d73cfeec3f8b3e3f31" translate="yes" xml:space="preserve">
          <source>Grammar</source>
          <target state="translated">Grammar</target>
        </trans-unit>
        <trans-unit id="2ae6967b07a45b63c8543a6c5e34052414ba32af" translate="yes" xml:space="preserve">
          <source>Grouping</source>
          <target state="translated">Grouping</target>
        </trans-unit>
        <trans-unit id="4ff36b989c4ec5364741f73abb04f8673b791c08" translate="yes" xml:space="preserve">
          <source>Grouping: Parenthesis can be used to change operator priority.</source>
          <target state="translated">分组。可以用括号来改变操作者的优先级。</target>
        </trans-unit>
        <trans-unit id="f824be4c07d044b0a16411ca3a8b4fc4a03b1f51" translate="yes" xml:space="preserve">
          <source>Grows or shrinks a given memory block on the heap.</source>
          <target state="translated">增长或缩小堆上给定的内存块。</target>
        </trans-unit>
        <trans-unit id="25d9269d97953fa1fa172932fc112e70b8360490" translate="yes" xml:space="preserve">
          <source>Grows or shrinks a given memory block.</source>
          <target state="translated">扩大或缩小一个给定的内存块。</target>
        </trans-unit>
        <trans-unit id="adfbbb729d4d05d687e4d3812ac17e60d6a1d04a" translate="yes" xml:space="preserve">
          <source>GrowthFactor:</source>
          <target state="translated">GrowthFactor:</target>
        </trans-unit>
        <trans-unit id="db8f40454de4a3c5f9326c0b5a2982f87e8e8255" translate="yes" xml:space="preserve">
          <source>Guards and locks</source>
          <target state="translated">警卫和锁具</target>
        </trans-unit>
        <trans-unit id="2bd9bcf38059609e0eeeb386a0d770db57a4886d" translate="yes" xml:space="preserve">
          <source>Guards and the locks section</source>
          <target state="translated">警卫和锁具部分</target>
        </trans-unit>
        <trans-unit id="9f738ce8457f291b18ee47e665e96baa84f38fcd" translate="yes" xml:space="preserve">
          <source>HTML</source>
          <target state="translated">HTML</target>
        </trans-unit>
        <trans-unit id="f86fb5b0e4e4aba5bf48c3f733a13e62daa3f128" translate="yes" xml:space="preserve">
          <source>HTML DOM Aria Attributes</source>
          <target state="translated">HTML DOM Aria属性</target>
        </trans-unit>
        <trans-unit id="59d7ad1571583a88d359a165c32f4d98121c941b" translate="yes" xml:space="preserve">
          <source>HTML DOM Common Attributes</source>
          <target state="translated">HTML DOM通用属性</target>
        </trans-unit>
        <trans-unit id="a7c9ed7b4b0f4c4cbe29ccb07ab4ecb8ff0e1d2d" translate="yes" xml:space="preserve">
          <source>HTML DOM Core Attributes</source>
          <target state="translated">HTML DOM核心属性</target>
        </trans-unit>
        <trans-unit id="09c8c8533abee764b1f743ea4422f18d94cff3fd" translate="yes" xml:space="preserve">
          <source>HTML DOM Event Attributes</source>
          <target state="translated">HTML DOM事件属性</target>
        </trans-unit>
        <trans-unit id="b670aa89386f34895332e01e04f3dc802e9f3d5c" translate="yes" xml:space="preserve">
          <source>HTML anchor generation</source>
          <target state="translated">HTML锚点生成</target>
        </trans-unit>
        <trans-unit id="a2ef27ac824bc904fefaa0d0d28b7f8253599ae9" translate="yes" xml:space="preserve">
          <source>HTML tags are case insensitive, XML tags are case sensitive. Since this library can parse both, only the client knows which comparison is to be used.</source>
          <target state="translated">HTML标签是不区分大小写的,XML标签是区分大小写的。由于这个库可以同时解析这两种标签,所以只有客户端知道要使用哪种比较方式。</target>
        </trans-unit>
        <trans-unit id="362f233bfd36bbe9ffba21ece507104cececa24e" translate="yes" xml:space="preserve">
          <source>Handlers</source>
          <target state="translated">Handlers</target>
        </trans-unit>
        <trans-unit id="194f68d829d02bf8087b17ed3a49b755b9584b08" translate="yes" xml:space="preserve">
          <source>Handling Exceptions</source>
          <target state="translated">异常处理</target>
        </trans-unit>
        <trans-unit id="0ad54594ca575043b9dce31b4a4bf4d6b5f96af0" translate="yes" xml:space="preserve">
          <source>Handling optional keys</source>
          <target state="translated">处理可选键</target>
        </trans-unit>
        <trans-unit id="260da45171e90fa3c6347df36e669fab555188ca" translate="yes" xml:space="preserve">
          <source>Hash sets are different from the &lt;a href=&quot;manual#types-set-type&quot;&gt;built in set type&lt;/a&gt;. Sets allow you to store any value that can be &lt;a href=&quot;hashes&quot;&gt;hashed&lt;/a&gt; and they don't contain duplicate entries.</source>
          <target state="translated">哈希集与&lt;a href=&quot;manual#types-set-type&quot;&gt;内置集类型不同&lt;/a&gt;。集允许您存储可以&lt;a href=&quot;hashes&quot;&gt;散列的&lt;/a&gt;任何值，并且它们不包含重复的条目。</target>
        </trans-unit>
        <trans-unit id="7a473e47b59092b03dd1448042a57562e118bc2e" translate="yes" xml:space="preserve">
          <source>Hash table that counts the number of each key.</source>
          <target state="translated">散列表,统计每个键的数量。</target>
        </trans-unit>
        <trans-unit id="9b4a2b500895ac4b70ba425d1b1f35bfdaaaaf1f" translate="yes" xml:space="preserve">
          <source>Hash table that remembers insertion order.</source>
          <target state="translated">记住插入顺序的哈希表。</target>
        </trans-unit>
        <trans-unit id="beae2044fdc9cc3eb616c7214470e48cd3252524" translate="yes" xml:space="preserve">
          <source>Hashes an array of bytes of size &lt;code&gt;size&lt;/code&gt;.</source>
          <target state="translated">散列一个大小为 &lt;code&gt;size&lt;/code&gt; 的字节数组。</target>
        </trans-unit>
        <trans-unit id="53e49a69fb315c4f51afc9825055d4858a064cdc" translate="yes" xml:space="preserve">
          <source>Hashing</source>
          <target state="translated">Hashing</target>
        </trans-unit>
        <trans-unit id="13650a25502e1bcae35551cd38b7ddc7b60b6e44" translate="yes" xml:space="preserve">
          <source>Hashing of HashSet.</source>
          <target state="translated">对HashSet进行哈希处理。</target>
        </trans-unit>
        <trans-unit id="d1809488fc3457f3ae3c7f6df26f47396f9a03ee" translate="yes" xml:space="preserve">
          <source>Hashing of OrderedSet.</source>
          <target state="translated">OrderedSet的哈希值。</target>
        </trans-unit>
        <trans-unit id="379820ada71e6fc460419ac92a81ed0859a3ea71" translate="yes" xml:space="preserve">
          <source>Have test results printed in color. Default is true for the non-js target, for which &lt;code&gt;stdout&lt;/code&gt; is a tty. Setting the environment variable &lt;code&gt;NIMTEST_COLOR&lt;/code&gt; to &lt;code&gt;always&lt;/code&gt; or &lt;code&gt;never&lt;/code&gt; changes the default for the non-js target to true or false respectively. The deprecated environment variable &lt;code&gt;NIMTEST_NO_COLOR&lt;/code&gt;, when set, changes the defualt to true, if &lt;code&gt;NIMTEST_COLOR&lt;/code&gt; is undefined.</source>
          <target state="translated">将测试结果以彩色打印。对于非js目标（默认 &lt;code&gt;stdout&lt;/code&gt; 为tty），默认值为true 。将环境变量 &lt;code&gt;NIMTEST_COLOR&lt;/code&gt; 设置为 &lt;code&gt;always&lt;/code&gt; 或 &lt;code&gt;never&lt;/code&gt; 可以分别将non-js目标的默认值更改为true或false。如果未定义 &lt;code&gt;NIMTEST_COLOR&lt;/code&gt; ，则设置了弃用的环境变量 &lt;code&gt;NIMTEST_NO_COLOR&lt;/code&gt; 时，会将默认值更改为true 。</target>
        </trans-unit>
        <trans-unit id="23843a4a411f31b588dbb2d3c2973e3567ff072f" translate="yes" xml:space="preserve">
          <source>Header pragma</source>
          <target state="translated">页眉 pragma</target>
        </trans-unit>
        <trans-unit id="34a7e13c971024e72f200af89b16d872ead96102" translate="yes" xml:space="preserve">
          <source>Header to use for complete XML output.</source>
          <target state="translated">用于完整XML输出的头。</target>
        </trans-unit>
        <trans-unit id="977169a2f56615065497cd1735f54129679d50ec" translate="yes" xml:space="preserve">
          <source>Heap</source>
          <target state="translated">Heap</target>
        </trans-unit>
        <trans-unit id="73a2a0df8c0716bca2e8f0a3245d12dcc9011dbf" translate="yes" xml:space="preserve">
          <source>Heap dump</source>
          <target state="translated">堆放</target>
        </trans-unit>
        <trans-unit id="cd81a03d092d8f4c8cc38f239229d0a6b095622c" translate="yes" xml:space="preserve">
          <source>Heap queue algorithm (a.k.a. priority queue). Ported from Python heapq.</source>
          <target state="translated">堆队列算法 (a.k.a.priority queue)。移植自Python heapq。</target>
        </trans-unit>
        <trans-unit id="8131611ca642b3a3b9f02be683c0bd269e027af5" translate="yes" xml:space="preserve">
          <source>Heaps are arrays for which a[k] &amp;lt;= a[2*k+1] and a[k] &amp;lt;= a[2*k+2] for all k, counting elements from 0. For the sake of comparison, non-existing elements are considered to be infinite. The interesting property of a heap is that a[0] is always its smallest element.</source>
          <target state="translated">堆是所有k的a [k] &amp;lt;= a [2 * k + 1]和a [k] &amp;lt;= a [2 * k + 2]的数组，从0开始计数元素。现有元素被认为是无限的。堆的有趣特性是a [0]始终是其最小元素。</target>
        </trans-unit>
        <trans-unit id="0519b0503186bc1f59cca3b56dc1223ef363db94" translate="yes" xml:space="preserve">
          <source>Helper for performing user-defined range checks. Such checks will be performed only when the &lt;code&gt;rangechecks&lt;/code&gt; compile-time option is enabled.</source>
          <target state="translated">用于执行用户定义的范围检查的助手。仅当启用 &lt;code&gt;rangechecks&lt;/code&gt; 编译时选项时，才执行此类检查。</target>
        </trans-unit>
        <trans-unit id="24ce8e260901a579961746d0c4e5b3aa2323e89e" translate="yes" xml:space="preserve">
          <source>Helpers for binaries that use compiler passes, e.g.: nim, nimsuggest, nimfix</source>
          <target state="translated">为使用编译器通证的二进制文件提供帮助,例如:nim,nimsuggest,nimfix。</target>
        </trans-unit>
        <trans-unit id="2fe815bc3011561cb8a3933b51b18ec4e9c969d5" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;odd&lt;/code&gt; depends on &lt;code&gt;even&lt;/code&gt; and vice versa. Thus &lt;code&gt;even&lt;/code&gt; needs to be introduced to the compiler before it is completely defined. The syntax for such a forward declaration is simple: just omit the &lt;code&gt;=&lt;/code&gt; and the procedure's body. The &lt;code&gt;assert&lt;/code&gt; just adds border conditions, and will be covered later in &lt;a href=&quot;#modules&quot;&gt;Modules&lt;/a&gt; section.</source>
          <target state="translated">在这里， &lt;code&gt;odd&lt;/code&gt; 取决于 &lt;code&gt;even&lt;/code&gt; ，反之亦然。因此， &lt;code&gt;even&lt;/code&gt; 需要在完全定义编译器之前将其引入。这种前向声明的语法很简单：只需省略 &lt;code&gt;=&lt;/code&gt; 和过程的主体。该 &lt;code&gt;assert&lt;/code&gt; 只是增加了边界条件，并会在以后的覆盖&lt;a href=&quot;#modules&quot;&gt;模块&lt;/a&gt;部分。</target>
        </trans-unit>
        <trans-unit id="17aefe7b7076c916d73873643615cffec4a39033" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;var T from container&lt;/code&gt; explicitly exposes that the location is derived from the second parameter (called 'container' in this case). The syntax &lt;code&gt;var T from p&lt;/code&gt; specifies a type &lt;code&gt;varTy[T, 2]&lt;/code&gt; which is incompatible with &lt;code&gt;varTy[T, 1]&lt;/code&gt;.</source>
          <target state="translated">在这里， &lt;code&gt;var T from container&lt;/code&gt; 显式公开了该位置是从第二个参数（在这种情况下称为&amp;ldquo;容器&amp;rdquo;）派生的。 &lt;code&gt;var T from p&lt;/code&gt; 的语法var T指定类型 &lt;code&gt;varTy[T, 2]&lt;/code&gt; 与 &lt;code&gt;varTy[T, 1]&lt;/code&gt; 不兼容。</target>
        </trans-unit>
        <trans-unit id="8b85b0f3abb03a93662419b1e5d9c37d24bb18a1" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;var T from container&lt;/code&gt; explicitly exposes that the location is deviated from the second parameter (called 'container' in this case). The syntax &lt;code&gt;var T from p&lt;/code&gt; specifies a type &lt;code&gt;varTy[T, 2]&lt;/code&gt; which is incompatible with &lt;code&gt;varTy[T, 1]&lt;/code&gt;.</source>
          <target state="translated">在这里， &lt;code&gt;var T from container&lt;/code&gt; 显式地揭示了该位置偏离了第二个参数（在这种情况下称为&amp;ldquo;容器&amp;rdquo;）。 &lt;code&gt;var T from p&lt;/code&gt; 的语法var T指定类型 &lt;code&gt;varTy[T, 2]&lt;/code&gt; 与 &lt;code&gt;varTy[T, 1]&lt;/code&gt; 不兼容。</target>
        </trans-unit>
        <trans-unit id="249bc2bb97f90836e8e318de7900778d15e98366" translate="yes" xml:space="preserve">
          <source>Here are few examples of using the &lt;code&gt;switch&lt;/code&gt; proc:</source>
          <target state="translated">以下是使用 &lt;code&gt;switch&lt;/code&gt; proc的一些示例：</target>
        </trans-unit>
        <trans-unit id="b366ec3bfeb8e69a8b8038b2ee4c1d6a28ea529d" translate="yes" xml:space="preserve">
          <source>Here are more examples that illustrate implicit generics:</source>
          <target state="translated">下面是更多说明隐性属的例子。</target>
        </trans-unit>
        <trans-unit id="474408b78552b4a0d7ae5fdabc19bf252fc0eb8c" translate="yes" xml:space="preserve">
          <source>Here are some examples for Unix:</source>
          <target state="translated">下面是一些Unix的例子。</target>
        </trans-unit>
        <trans-unit id="4f50999e368be6860526051c42f03020821896ea" translate="yes" xml:space="preserve">
          <source>Here is a short overview of the most commonly used functions from the &lt;code&gt;system&lt;/code&gt; module. Function names in the tables below are clickable and will take you to the full documentation of the function.</source>
          <target state="translated">这是 &lt;code&gt;system&lt;/code&gt; 模块中最常用的功能的简短概述。下表中的函数名称是可单击的，将带您进入该函数的完整文档。</target>
        </trans-unit>
        <trans-unit id="b4b5a5ccfafdc873c836f01f1f7137f9ef720f3e" translate="yes" xml:space="preserve">
          <source>Here is an example of how to use the configuration file parser:</source>
          <target state="translated">下面是一个如何使用配置文件解析器的例子。</target>
        </trans-unit>
        <trans-unit id="540ee2aaf7182c6dfc449b18e5accb694e3b0894" translate="yes" xml:space="preserve">
          <source>Here is an example:</source>
          <target state="translated">下面是一个例子。</target>
        </trans-unit>
        <trans-unit id="a23c6c65d4dacf92bd4b7dd12966aa26aed4b8f6" translate="yes" xml:space="preserve">
          <source>Here is how a typical multilock statement can be implemented in Nim. Note how the runtime check is required to ensure a global ordering for two locks &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; of the same lock level:</source>
          <target state="translated">这是如何在Nim中实现典型的multilock语句的方法。请注意如何要求运行时检查，以确保对同一锁级别的两个锁 &lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;b&lt;/code&gt; 进行全局排序：</target>
        </trans-unit>
        <trans-unit id="16ec3351fc3909ec123a9438e435e521a554ccaf" translate="yes" xml:space="preserve">
          <source>Here is how to set a timeout when creating an &lt;code&gt;HttpClient&lt;/code&gt; instance:</source>
          <target state="translated">这是创建 &lt;code&gt;HttpClient&lt;/code&gt; 实例时如何设置超时的方法：</target>
        </trans-unit>
        <trans-unit id="a8056266ad685c758cc11b7e966ef3226e799b6f" translate="yes" xml:space="preserve">
          <source>Here is some example usage of this module:</source>
          <target state="translated">下面是这个模块的一些使用实例。</target>
        </trans-unit>
        <trans-unit id="87a765729a3650e7d53f6368f7d2640621d5290e" translate="yes" xml:space="preserve">
          <source>Here you can see an example about how to set the &lt;code&gt;maxRedirects&lt;/code&gt; of &lt;code&gt;HttpClient&lt;/code&gt;:</source>
          <target state="translated">在这里，您可以看到关于如何设置一个例子 &lt;code&gt;maxRedirects&lt;/code&gt; 的 &lt;code&gt;HttpClient&lt;/code&gt; 的：</target>
        </trans-unit>
        <trans-unit id="0d75a6bc3a26bf7e15a375f54de00e7b3a24d49e" translate="yes" xml:space="preserve">
          <source>Heterogeneous arrays are not supported.</source>
          <target state="translated">不支持异构阵列。</target>
        </trans-unit>
        <trans-unit id="9a472603c4793ba32a26895360ca1c167352b47b" translate="yes" xml:space="preserve">
          <source>Hex format. Outputs the number in base 16, using lower-case letters for the digits above 9.</source>
          <target state="translated">十六进制格式。输出16进制的数字,9以上的数字使用小写字母。</target>
        </trans-unit>
        <trans-unit id="16ecf8c049c3a3fc4daf4d45c04ec54049be9338" translate="yes" xml:space="preserve">
          <source>Hex format. Outputs the number in base 16, using uppercase letters for the digits above 9.</source>
          <target state="translated">十六进制格式。输出16进制的数字,9以上的数字使用大写字母。</target>
        </trans-unit>
        <trans-unit id="c64b0888277a234e68d21751554b1e7fd37d63e3" translate="yes" xml:space="preserve">
          <source>Hides the cursor.</source>
          <target state="translated">隐藏光标。</target>
        </trans-unit>
        <trans-unit id="201789f2014169f3fb9b5be056554d96ad45efe9" translate="yes" xml:space="preserve">
          <source>Higher-level version of &lt;code&gt;recv&lt;/code&gt; which returns a string.</source>
          <target state="translated">&lt;code&gt;recv&lt;/code&gt; 的更高版本，它返回一个字符串。</target>
        </trans-unit>
        <trans-unit id="375f88a238b922b4a8492616aa39100964dc9e28" translate="yes" xml:space="preserve">
          <source>Higher-level version of &lt;code&gt;recv&lt;/code&gt;.</source>
          <target state="translated">更高版本的 &lt;code&gt;recv&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0bf286ced5eb8cc0d307365394fbc65d95b6115c" translate="yes" xml:space="preserve">
          <source>Hints on the build process:</source>
          <target state="translated">构建过程中的提示。</target>
        </trans-unit>
        <trans-unit id="1f4fdd84cd707355c0d4470ac34583b420b822e4" translate="yes" xml:space="preserve">
          <source>Hints the optimizer that &lt;code&gt;val&lt;/code&gt; is likely going to be false.</source>
          <target state="translated">提示优化器 &lt;code&gt;val&lt;/code&gt; 可能为假。</target>
        </trans-unit>
        <trans-unit id="3f177d57d6287dec01b0af7f6ebac21c70b91405" translate="yes" xml:space="preserve">
          <source>Hints the optimizer that &lt;code&gt;val&lt;/code&gt; is likely going to be true.</source>
          <target state="translated">提示优化器 &lt;code&gt;val&lt;/code&gt; 可能是正确的。</target>
        </trans-unit>
        <trans-unit id="e181cef40f6b34c1f59ee5117ab9fb62d1330e72" translate="yes" xml:space="preserve">
          <source>Hints the optimizer that &lt;em&gt;val&lt;/em&gt; is likely going to be false.</source>
          <target state="translated">提示优化器&lt;em&gt;val&lt;/em&gt;可能为假。</target>
        </trans-unit>
        <trans-unit id="19f673072699a2a1b1f923ef0f54e924acd06dc7" translate="yes" xml:space="preserve">
          <source>Hints the optimizer that &lt;em&gt;val&lt;/em&gt; is likely going to be true.</source>
          <target state="translated">提示优化器&lt;em&gt;val&lt;/em&gt;可能是正确的。</target>
        </trans-unit>
        <trans-unit id="8393d3af1bb0b9c3fc06f67e4b0baddd2f8abb94" translate="yes" xml:space="preserve">
          <source>Historically, Nim was a fully &lt;span id=&quot;styleminusinsensitive_1&quot;&gt;style-insensitive&lt;/span&gt; language. This meant that it was not case-sensitive and underscores were ignored and there was not even a distinction between &lt;code&gt;foo&lt;/code&gt; and &lt;code&gt;Foo&lt;/code&gt;.</source>
          <target state="translated">从历史上看，Nim是一种完全&lt;span id=&quot;styleminusinsensitive_1&quot;&gt;不区分样式的&lt;/span&gt;语言。这意味着它不区分大小写，下划线被忽略，并且 &lt;code&gt;foo&lt;/code&gt; 和 &lt;code&gt;Foo&lt;/code&gt; 之间甚至没有区别。</target>
        </trans-unit>
        <trans-unit id="9737de0ba24413c483e0607526157c6b5607222d" translate="yes" xml:space="preserve">
          <source>Hook generation</source>
          <target state="translated">钩子的生成</target>
        </trans-unit>
        <trans-unit id="823d6faf924048154ea05aa93a8b2406e5e4a84f" translate="yes" xml:space="preserve">
          <source>Hook lifting</source>
          <target state="translated">钩子起重</target>
        </trans-unit>
        <trans-unit id="ebb7c24bb94fb8d304cae1d3ff1be0dcb43bbb49" translate="yes" xml:space="preserve">
          <source>Hot code reloading</source>
          <target state="translated">热码重装</target>
        </trans-unit>
        <trans-unit id="c48d4d3dd643b4c5ee380d17a07cb4815d3859c3" translate="yes" xml:space="preserve">
          <source>How long is a day?</source>
          <target state="translated">一天有多长?</target>
        </trans-unit>
        <trans-unit id="a6ec9f4760713f74026109bf0ded7ccc69847229" translate="yes" xml:space="preserve">
          <source>How the RTL is compiled</source>
          <target state="translated">RTL是如何编制的</target>
        </trans-unit>
        <trans-unit id="edc42b66f73d1503ac061b4ce145b9a1dd7e0b1b" translate="yes" xml:space="preserve">
          <source>How to deal with an absence of a value:</source>
          <target state="translated">如何处理一个价值的缺失。</target>
        </trans-unit>
        <trans-unit id="7980a8ae26b43f84582fc4763e99898544da0dad" translate="yes" xml:space="preserve">
          <source>However before the PATH is used the current directory is checked for the file's existence. So if PATH contains &lt;code&gt;$lib&lt;/code&gt; and &lt;code&gt;$lib/bar&lt;/code&gt; and the directory structure looks like this:</source>
          <target state="translated">但是，在使用PATH之前，将检查当前目录是否存在该文件。因此，如果PATH包含 &lt;code&gt;$lib&lt;/code&gt; 和 &lt;code&gt;$lib/bar&lt;/code&gt; 并且目录结构如下所示：</target>
        </trans-unit>
        <trans-unit id="737a9761248665739efdb7e092488b1f4438a576" translate="yes" xml:space="preserve">
          <source>However it is not efficient to do:</source>
          <target state="translated">然而这样做效率不高。</target>
        </trans-unit>
        <trans-unit id="2cbd76edbf731ff982e8e168638d25504365da00" translate="yes" xml:space="preserve">
          <source>However later versions of the language might change this to mean &quot;infer the parameters' types from the body&quot;. Then the above &lt;code&gt;foo&lt;/code&gt; would be rejected as the parameters' types can not be inferred from an empty &lt;code&gt;discard&lt;/code&gt; statement.</source>
          <target state="translated">但是，该语言的更高版本可能会将其更改为&amp;ldquo;从主体推断参数的类型&amp;rdquo;。那么上述 &lt;code&gt;foo&lt;/code&gt; 将被拒绝，因为无法从空的 &lt;code&gt;discard&lt;/code&gt; 语句中推断出参数的类型。</target>
        </trans-unit>
        <trans-unit id="368170efcb2db228f96a4630432ea5c83ce54ea6" translate="yes" xml:space="preserve">
          <source>However such features are not context sensitive and work simply on string matching, which can be problematic in Nim especially due to the case insensitiveness of the language (plus underscores as separators!).</source>
          <target state="translated">然而,这样的功能对上下文不敏感,只是简单地进行字符串匹配,这在Nim中可能是个问题,特别是由于语言的大小写不敏感(加上下划线作为分隔符!)。</target>
        </trans-unit>
        <trans-unit id="c8aede1d3274012cc4621182cf281306471b02d9" translate="yes" xml:space="preserve">
          <source>However the biggest problem is that dead code elimination breaks modularity! To see why, consider this scenario: The module &lt;code&gt;G&lt;/code&gt; (for example the huge Gtk2 module...) is compiled with dead code elimination turned on. So none of &lt;code&gt;G&lt;/code&gt;'s procs is generated at all.</source>
          <target state="translated">但是，最大的问题是消除无效代码会破坏模块化！若要了解原因，请考虑以下情形：编译模块 &lt;code&gt;G&lt;/code&gt; （例如巨大的Gtk2模块...）时，打开了消除死代码的功能。因此， &lt;code&gt;G&lt;/code&gt; 的proc完全不会生成。</target>
        </trans-unit>
        <trans-unit id="acb7eac83c404f63f4743f9a82480d0d20a94377" translate="yes" xml:space="preserve">
          <source>However you don't need to necessarily separate format patterns, a unambiguous format string like &lt;code&gt;yyyyMMddhhmmss&lt;/code&gt; is valid too (although only for years in the range 1..9999).</source>
          <target state="translated">但是，您不必一定要分隔格式模式，像 &lt;code&gt;yyyyMMddhhmmss&lt;/code&gt; 这样的明确格式字符串也是有效的（尽管仅适用于1..9999范围内的年份）。</target>
        </trans-unit>
        <trans-unit id="65d726c6740c8cd087e52ad1bbc8dea1218cd23b" translate="yes" xml:space="preserve">
          <source>However you don't need to necessarily separate format patterns, as an unambiguous format string like &lt;code&gt;yyyyMMddhhmmss&lt;/code&gt; is also valid (although only for years in the range 1..9999).</source>
          <target state="translated">但是，您不必一定要分开格式格式，因为诸如 &lt;code&gt;yyyyMMddhhmmss&lt;/code&gt; 之类的明确格式字符串也是有效的（尽管仅适用于1..9999范围内的年份）。</target>
        </trans-unit>
        <trans-unit id="742bd46b7a132e000ef82d863fbcce49eb7c5b85" translate="yes" xml:space="preserve">
          <source>However, &lt;code&gt;int&lt;/code&gt; literals are implicitly convertible to a smaller integer type if the literal's value fits this smaller type and such a conversion is less expensive than other implicit conversions, so &lt;code&gt;myInt16 + 34&lt;/code&gt; produces an &lt;code&gt;int16&lt;/code&gt; result.</source>
          <target state="translated">但是，如果文字的值适合该较小的类型，则可以将 &lt;code&gt;int&lt;/code&gt; 文字隐式转换为较小的整数类型，并且这种转换比其他隐式转换便宜，因此 &lt;code&gt;myInt16 + 34&lt;/code&gt; 会生成 &lt;code&gt;int16&lt;/code&gt; 结果。</target>
        </trans-unit>
        <trans-unit id="cbf8251069a2532e90f19da84e2234188384c198" translate="yes" xml:space="preserve">
          <source>However, a &lt;code&gt;void&lt;/code&gt; type cannot be inferred in generic code:</source>
          <target state="translated">但是，不能在通用代码中推断出 &lt;code&gt;void&lt;/code&gt; 类型：</target>
        </trans-unit>
        <trans-unit id="4c9fbaef3ddd5b531468395ce9dec2a5ab4f5ae7" translate="yes" xml:space="preserve">
          <source>However, depending on the use case &lt;code&gt;new Foo&lt;/code&gt; can also be wrapped like this instead:</source>
          <target state="translated">但是，根据用例，也可以像这样包装 &lt;code&gt;new Foo&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="31eaf302275d7d94ef88ad6acf5c8f08d9355de8" translate="yes" xml:space="preserve">
          <source>However, for the C like targets you need to link external code either statically or dynamically. The preferred way of integrating native code is to use dynamic linking because it allows you to compile Nim programs without the need for having the related development libraries installed. This is done through the &lt;a href=&quot;manual#dynlib-pragma-for-import&quot;&gt;dynlib pragma for import&lt;/a&gt;, though more specific control can be gained using the &lt;a href=&quot;dynlib&quot;&gt;dynlib module&lt;/a&gt;.</source>
          <target state="translated">但是，对于类似C的目标，您需要静态或动态链接外部代码。集成本机代码的首选方法是使用动态链接，因为它允许您编译Nim程序而无需安装相关的开发库。尽管可以使用&lt;a href=&quot;dynlib&quot;&gt;dynlib模块&lt;/a&gt;获得更具体的控制，但是这可以通过&lt;a href=&quot;manual#dynlib-pragma-for-import&quot;&gt;dynlib实用程序进行导入&lt;/a&gt;来完成。</target>
        </trans-unit>
        <trans-unit id="42250089280f811db9d02347ee4c65c943d06404" translate="yes" xml:space="preserve">
          <source>However, for the C like targets you need to link external code either statically or dynamically. The preferred way of integrating native code is to use dynamic linking because it allows you to compile Nim programs without the need for having the related development libraries installed. This is done through the &lt;a href=&quot;manual#foreign-function-interface-dynlib-pragma-for-import&quot;&gt;dynlib pragma for import&lt;/a&gt;, though more specific control can be gained using the &lt;a href=&quot;dynlib&quot;&gt;dynlib module&lt;/a&gt;.</source>
          <target state="translated">但是，对于类似C的目标，您需要静态或动态链接外部代码。集成本机代码的首选方法是使用动态链接，因为它允许您编译Nim程序而无需安装相关的开发库。尽管可以使用&lt;a href=&quot;dynlib&quot;&gt;dynlib模块&lt;/a&gt;获得更具体的控制，但这是通过&lt;a href=&quot;manual#foreign-function-interface-dynlib-pragma-for-import&quot;&gt;dynlib杂注进行导入的&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1d22d44af2cd8e5a6cc6b8f108be38e9a251be52" translate="yes" xml:space="preserve">
          <source>However, if more than a single statistical calculation is required, it is more efficient to push the data once to the RunningStat object, and call the numerous statistical procs for the RunningStat object.</source>
          <target state="translated">但是,如果需要进行不止一次的统计计算,那么将数据一次性推送到RunningStat对象中,再调用RunningStat对象的众多统计procs,效率更高。</target>
        </trans-unit>
        <trans-unit id="07fd3c66c743affb7b5ece82a87a7adaeb5ee006" translate="yes" xml:space="preserve">
          <source>However, it is not efficient to do:</source>
          <target state="translated">然而,这样做的效率并不高。</target>
        </trans-unit>
        <trans-unit id="c379ff0f54702af4514aa6f7ffb24917f230d3c8" translate="yes" xml:space="preserve">
          <source>However, it is possible to manually allocate shared memory for channels using e.g. &lt;code&gt;system.allocShared0&lt;/code&gt; and pass these pointers through thread arguments:</source>
          <target state="translated">但是，可以使用例如 &lt;code&gt;system.allocShared0&lt;/code&gt; 手动为通道分配共享内存，并通过线程参数传递这些指针：</target>
        </trans-unit>
        <trans-unit id="a5f20f62b2a4c64e2d22b78b12676a0c62815d5f" translate="yes" xml:space="preserve">
          <source>However, it is then not an ordinal anymore, so it is not possible to use these enums as an index type for arrays. The procedures &lt;code&gt;inc&lt;/code&gt;, &lt;code&gt;dec&lt;/code&gt;, &lt;code&gt;succ&lt;/code&gt; and &lt;code&gt;pred&lt;/code&gt; are not available for them either.</source>
          <target state="translated">但是，它不再是序数，因此无法将这些枚举用作数组的索引类型。程序 &lt;code&gt;inc&lt;/code&gt; ， &lt;code&gt;dec&lt;/code&gt; ， &lt;code&gt;succ&lt;/code&gt; 和 &lt;code&gt;pred&lt;/code&gt; 也不可用。</target>
        </trans-unit>
        <trans-unit id="dff82ffd386986c6ed8d26407f7247e97f81abe9" translate="yes" xml:space="preserve">
          <source>However, it is then not ordinal anymore, so it is not possible to use these enums as an index type for arrays. The procedures &lt;code&gt;inc&lt;/code&gt;, &lt;code&gt;dec&lt;/code&gt;, &lt;code&gt;succ&lt;/code&gt; and &lt;code&gt;pred&lt;/code&gt; are not available for them either.</source>
          <target state="translated">但是，它不再是序数，因此不可能将这些枚举用作数组的索引类型。程序 &lt;code&gt;inc&lt;/code&gt; ， &lt;code&gt;dec&lt;/code&gt; ， &lt;code&gt;succ&lt;/code&gt; 和 &lt;code&gt;pred&lt;/code&gt; 均不可用。</target>
        </trans-unit>
        <trans-unit id="48faa4a84ae67f6ff262efd3ddcb8c99b257507e" translate="yes" xml:space="preserve">
          <source>However, later versions of the language might change this to mean &quot;infer the parameters' types from the body&quot;. Then the above &lt;code&gt;foo&lt;/code&gt; would be rejected as the parameters' types can not be inferred from an empty &lt;code&gt;discard&lt;/code&gt; statement.</source>
          <target state="translated">但是，该语言的更高版本可能会将其更改为&amp;ldquo;从主体推断参数的类型&amp;rdquo;。然后上述 &lt;code&gt;foo&lt;/code&gt; 将被拒绝，因为不能从空的 &lt;code&gt;discard&lt;/code&gt; 语句中推断出参数的类型。</target>
        </trans-unit>
        <trans-unit id="55cd4c67b60fee0d63736ca3e9d60ab7cbbbc9b5" translate="yes" xml:space="preserve">
          <source>However, since &lt;code&gt;MonoTime&lt;/code&gt; represents the time that has passed since some unknown time origin, it cannot be converted to a human readable timestamp. If this is required, the &lt;code&gt;times.Time&lt;/code&gt; type should be used instead.</source>
          <target state="translated">但是，由于 &lt;code&gt;MonoTime&lt;/code&gt; 表示自某个未知时间来源以来已经过去的时间，因此无法将其转换为人类可读的时间戳。如果需要， &lt;code&gt;times.Time&lt;/code&gt; 类型。</target>
        </trans-unit>
        <trans-unit id="a7f19c857394d2f63dc7cf9130779ed557032b2a" translate="yes" xml:space="preserve">
          <source>However, since a template cannot iterate over varargs, this feature is generally much more useful for macros.</source>
          <target state="translated">但是,由于模板不能对varargs进行迭代,所以这个功能一般对宏更有用。</target>
        </trans-unit>
        <trans-unit id="91f963bca7858da3bd237b4e32710ada3fd1260b" translate="yes" xml:space="preserve">
          <source>However, sometimes one has to optimize. Do it in the following order:</source>
          <target state="translated">但是,有时候必须要优化。按照以下顺序进行。</target>
        </trans-unit>
        <trans-unit id="406663563bd897705cf8a1dfd9829c366e1e27d8" translate="yes" xml:space="preserve">
          <source>However, the &lt;code&gt;header&lt;/code&gt; pragma is often the better alternative.</source>
          <target state="translated">但是， &lt;code&gt;header&lt;/code&gt; 实用程序通常是更好的选择。</target>
        </trans-unit>
        <trans-unit id="0681510216903f8e2197cf4eef03fbf990baedec" translate="yes" xml:space="preserve">
          <source>However, the above code does not compile: the reason is that you have to cover every value that &lt;code&gt;n&lt;/code&gt; may contain, but the code only handles the values &lt;code&gt;0..8&lt;/code&gt;. Since it is not very practical to list every other possible integer (though it is possible thanks to the range notation), we fix this by telling the compiler that for every other value nothing should be done:</source>
          <target state="translated">但是，上面的代码无法编译：原因是您必须覆盖 &lt;code&gt;n&lt;/code&gt; 可能包含的每个值，但是代码仅处理值 &lt;code&gt;0..8&lt;/code&gt; 。由于列出所有其他可能的整数不是很实际（尽管可以使用范围表示法来列出），因此我们通过告诉编译器对于其他每个值都不应该进行处理来解决此问题：</target>
        </trans-unit>
        <trans-unit id="c495d80be884cf611f7914197a783d75a72f97b9" translate="yes" xml:space="preserve">
          <source>However, the concept of &quot;order of evaluation&quot; is only applicable after the code was normalized: The normalization involves template expansions and argument reorderings that have been passed to named parameters:</source>
          <target state="translated">然而,&quot;评估顺序 &quot;的概念只适用于经过规范化处理的代码。规范化涉及到模板扩展和参数的重新排序,这些参数已被传递给命名参数。</target>
        </trans-unit>
        <trans-unit id="fb9aeb69b131c87d8cd6853cf77ea1cf9dd6d2ce" translate="yes" xml:space="preserve">
          <source>However, the constraints &lt;code&gt;alias&lt;/code&gt; and &lt;code&gt;noalias&lt;/code&gt; are not available in ordinary routines.</source>
          <target state="translated">但是，约束 &lt;code&gt;alias&lt;/code&gt; 和 &lt;code&gt;noalias&lt;/code&gt; 在普通例程中不可用。</target>
        </trans-unit>
        <trans-unit id="3cc98398fc87222623ba18963b4867850eff8b10" translate="yes" xml:space="preserve">
          <source>However, the current implementation produces a warning in these cases. There are different ways to deal with this warning:</source>
          <target state="translated">然而,目前的实现在这些情况下会产生一个警告。有不同的方法来处理这个警告。</target>
        </trans-unit>
        <trans-unit id="f56c3539085a2fed48c36c5577618ef3c9427982" translate="yes" xml:space="preserve">
          <source>However, the generated C code is not platform independent. C code generated for Linux does not compile on Windows, for instance. The comment on top of the C file lists the OS, CPU and CC the file has been compiled for.</source>
          <target state="translated">但是,生成的C代码并不独立于平台。例如,为Linux生成的C代码不能在Windows上编译。C文件顶部的注释列出了该文件被编译的操作系统、CPU和CC。</target>
        </trans-unit>
        <trans-unit id="29ce0e843ffd1bf978a465d631b8be7e6a19827c" translate="yes" xml:space="preserve">
          <source>However, the generated C code is not platform-independent. C code generated for Linux does not compile on Windows, for instance. The comment on top of the C file lists the OS, CPU, and CC the file has been compiled for.</source>
          <target state="translated">然而,生成的C代码并不是独立于平台的。例如,为Linux生成的C代码不能在Windows上编译。C文件顶部的注释列出了该文件被编译的操作系统、CPU和CC。</target>
        </trans-unit>
        <trans-unit id="a13fe01a81aad0de40fb6ccb549edb2976ed2c1b" translate="yes" xml:space="preserve">
          <source>However, the modules &lt;a href=&quot;strutils&quot;&gt;strutils&lt;/a&gt;, &lt;a href=&quot;math&quot;&gt;math&lt;/a&gt;, and &lt;a href=&quot;times&quot;&gt;times&lt;/a&gt; are available! To access the DOM, use the &lt;a href=&quot;dom&quot;&gt;dom&lt;/a&gt; module that is only available for the JavaScript platform.</source>
          <target state="translated">但是，模块&lt;a href=&quot;strutils&quot;&gt;strutils&lt;/a&gt;，&lt;a href=&quot;math&quot;&gt;math&lt;/a&gt;和&lt;a href=&quot;times&quot;&gt;time&lt;/a&gt;可用！要访问DOM，请使用仅适用于JavaScript平台的&lt;a href=&quot;dom&quot;&gt;dom&lt;/a&gt;模块。</target>
        </trans-unit>
        <trans-unit id="94036a9c51a3400f9ddd28a5c63cabe204e0c9a5" translate="yes" xml:space="preserve">
          <source>However, the symbols &lt;code&gt;write&lt;/code&gt;, &lt;code&gt;writeLine&lt;/code&gt; and &lt;code&gt;stdout&lt;/code&gt; are already bound and are not looked up again. As the example shows, &lt;code&gt;bindSym&lt;/code&gt; does work with overloaded symbols implicitly.</source>
          <target state="translated">但是，符号 &lt;code&gt;write&lt;/code&gt; ， &lt;code&gt;writeLine&lt;/code&gt; 和 &lt;code&gt;stdout&lt;/code&gt; 已绑定，不再再次查找。如示例所示， &lt;code&gt;bindSym&lt;/code&gt; 确实可以隐式处理重载符号。</target>
        </trans-unit>
        <trans-unit id="db3f8b29b6aa7fbf63138a0a422b4e572110ad5c" translate="yes" xml:space="preserve">
          <source>However, the values being strings/json is quite problematic: Many lookup tables that are built at compiletime embed &lt;em&gt;proc vars&lt;/em&gt; and types which have no obvious string representation... Seems like AST diffing is still the best idea as it will not require to use an alien API and works with some existing Nimble packages, at least.</source>
          <target state="translated">但是，字符串/ json的值存在很大问题：许多在编译时生成的查找表都嵌入了&lt;em&gt;proc var&lt;/em&gt;和没有明显字符串表示形式的类型...似乎AST diff仍然是最好的主意，因为它不需要使用外部API，并且至少与某些现有的Nimble软件包一起使用。</target>
        </trans-unit>
        <trans-unit id="5b442e77c451b3f66ae133bcb7a6fa4d2d93f7cd" translate="yes" xml:space="preserve">
          <source>However, this does not work. The problem is that the procedure should not only &lt;code&gt;return&lt;/code&gt;, but return and &lt;strong&gt;continue&lt;/strong&gt; after an iteration has finished. This &lt;em&gt;return and continue&lt;/em&gt; is called a &lt;em&gt;yield&lt;/em&gt; statement. Now the only thing left to do is to replace the &lt;code&gt;proc&lt;/code&gt; keyword by &lt;code&gt;iterator&lt;/code&gt; and here it is - our first iterator:</source>
          <target state="translated">但是，这不起作用。问题在于该过程不仅应 &lt;code&gt;return&lt;/code&gt; ，而且应在迭代完成后返回并&lt;strong&gt;继续&lt;/strong&gt;。此&lt;em&gt;返回并继续&lt;/em&gt;称为&lt;em&gt;yield&lt;/em&gt;语句。现在剩下要做的就是用 &lt;code&gt;iterator&lt;/code&gt; 替换 &lt;code&gt;proc&lt;/code&gt; 关键字，这就是我们的第一个迭代器：</target>
        </trans-unit>
        <trans-unit id="11fb6436d40287c29f4518b54ff0c8803e2c0fb2" translate="yes" xml:space="preserve">
          <source>However, this is seldom needed. The most common case is to extract an error message from &lt;code&gt;e&lt;/code&gt;, and for such situations it is enough to use &lt;code&gt;getCurrentExceptionMsg&lt;/code&gt;:</source>
          <target state="translated">但是，这很少需要。最常见的情况是从 &lt;code&gt;e&lt;/code&gt; 提取错误消息，对于这种情况，使用 &lt;code&gt;getCurrentExceptionMsg&lt;/code&gt; 就足够了：</target>
        </trans-unit>
        <trans-unit id="abb9b269452062f371384e39f3c9c804325383d0" translate="yes" xml:space="preserve">
          <source>However, this is seldom needed. The most common case is to extract an error message from &lt;code&gt;e&lt;/code&gt;, and for such situations, it is enough to use &lt;code&gt;getCurrentExceptionMsg&lt;/code&gt;:</source>
          <target state="translated">但是，这很少需要。最常见的情况是从 &lt;code&gt;e&lt;/code&gt; 提取错误消息，对于这种情况，使用 &lt;code&gt;getCurrentExceptionMsg&lt;/code&gt; 就足够了：</target>
        </trans-unit>
        <trans-unit id="d419965001ec506c50156ffc5413028fbc540e86" translate="yes" xml:space="preserve">
          <source>However, this means that the method call syntax is not available for &lt;code&gt;gensym&lt;/code&gt;'ed symbols:</source>
          <target state="translated">但是，这意味着方法调用语法不适用于 &lt;code&gt;gensym&lt;/code&gt; 'ed符号：</target>
        </trans-unit>
        <trans-unit id="9ae0752c04a35700e1c477d06f622ee35116b587" translate="yes" xml:space="preserve">
          <source>However, you can also use a &lt;code&gt;closure&lt;/code&gt; iterator to get a different set of restrictions. See &lt;a href=&quot;manual#iterators-and-the-for-statement-first-class-iterators&quot;&gt;first class iterators&lt;/a&gt; for details. Iterators can have the same name and parameters as a proc, since essentially they have their own namespaces. Therefore it is common practice to wrap iterators in procs of the same name which accumulate the result of the iterator and return it as a sequence, like &lt;code&gt;split&lt;/code&gt; from the &lt;a href=&quot;strutils&quot;&gt;strutils module&lt;/a&gt;.</source>
          <target state="translated">但是，您也可以使用 &lt;code&gt;closure&lt;/code&gt; 迭代器来获得一组不同的限制。有关详细信息，请参见&lt;a href=&quot;manual#iterators-and-the-for-statement-first-class-iterators&quot;&gt;一流的迭代器&lt;/a&gt;。迭代器可以具有与proc相同的名称和参数，因为本质上它们具有自己的名称空间。因此，通常的做法是将迭代器包装在同名的&lt;a href=&quot;strutils&quot;&gt;proc中&lt;/a&gt;，这些proc会累积迭代器的结果，然后将其作为序列返回，例如从strutils模块 &lt;code&gt;split&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="27aa4ebcd005df33a75118f8923b50a0eb6fe684" translate="yes" xml:space="preserve">
          <source>HtmlExt:</source>
          <target state="translated">HtmlExt:</target>
        </trans-unit>
        <trans-unit id="56d4f245bec69d0b576c1bfc554101ec8df594ad" translate="yes" xml:space="preserve">
          <source>Human friendly string representation of &lt;code&gt;Duration&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Duration&lt;/code&gt; 人性化字符串表示形式。</target>
        </trans-unit>
        <trans-unit id="b6eabb595031ee4675266447f4a10ddfcfbee137" translate="yes" xml:space="preserve">
          <source>Human friendly string representation of a &lt;code&gt;Duration&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Duration&lt;/code&gt; 人性化字符串表示形式。</target>
        </trans-unit>
        <trans-unit id="079d3eca7e1c9c2fd619c47e7f37d0a7860da8ba" translate="yes" xml:space="preserve">
          <source>Hygiene in templates</source>
          <target state="translated">模板中的卫生</target>
        </trans-unit>
        <trans-unit id="0fcb4de22af01003cbbe36bbdb61566a4be791e9" translate="yes" xml:space="preserve">
          <source>I use the term &lt;em&gt;cell&lt;/em&gt; here to refer to everything that is traced (sequences, refs, strings). This section describes how the GC works.</source>
          <target state="translated">我在这里使用&amp;ldquo; &lt;em&gt;单元格&lt;/em&gt; &amp;rdquo;一词来指代所追踪的所有内容（序列，引用，字符串）。本节介绍GC的工作方式。</target>
        </trans-unit>
        <trans-unit id="cfb8efb0ed2a0e843062bd494febb53b03f95265" translate="yes" xml:space="preserve">
          <source>IE 11 on Windows 7</source>
          <target state="translated">Windows 7上的IE 11</target>
        </trans-unit>
        <trans-unit id="6969542799be4f3a836d0ff1c8e7f05eee2ed94d" translate="yes" xml:space="preserve">
          <source>IE8 on Windows XP</source>
          <target state="translated">Windows XP上的IE8</target>
        </trans-unit>
        <trans-unit id="1adbf823c203d9176878f1ea4880115650f6355a" translate="yes" xml:space="preserve">
          <source>IO effect.</source>
          <target state="translated">IO效应。</target>
        </trans-unit>
        <trans-unit id="43cbc65c44c1dc2f182c90bae6d0aeab5672e98a" translate="yes" xml:space="preserve">
          <source>IPv4 mapped address.</source>
          <target state="translated">IPv4映射地址。</target>
        </trans-unit>
        <trans-unit id="5c90dad54fd1910854f6a4d59c28bd806cb73299" translate="yes" xml:space="preserve">
          <source>IPv4-compatible address.</source>
          <target state="translated">IPv4兼容地址。</target>
        </trans-unit>
        <trans-unit id="ad9aff7f64597fbd6b68ad711de514b704a24201" translate="yes" xml:space="preserve">
          <source>IdeCmd.ideChk</source>
          <target state="translated">IdeCmd.ideChk</target>
        </trans-unit>
        <trans-unit id="408d49e1b1b54ed49bb8a7036e1788d1d6904769" translate="yes" xml:space="preserve">
          <source>IdeCmd.ideCon</source>
          <target state="translated">IdeCmd.ideCon</target>
        </trans-unit>
        <trans-unit id="c218025b172e7052d7b555322d8ec0182193f277" translate="yes" xml:space="preserve">
          <source>IdeCmd.ideDef</source>
          <target state="translated">IdeCmd.ideDef</target>
        </trans-unit>
        <trans-unit id="8609943548c6edbc2b3a396b7cfdc5696c923f89" translate="yes" xml:space="preserve">
          <source>IdeCmd.ideDus</source>
          <target state="translated">IdeCmd.ideDus</target>
        </trans-unit>
        <trans-unit id="487335d8217013c7c51994e95da9b65b39ae11ee" translate="yes" xml:space="preserve">
          <source>IdeCmd.ideHighlight</source>
          <target state="translated">IdeCmd.ideHighlight</target>
        </trans-unit>
        <trans-unit id="ef0d60957d129911c945617dc6936a2b0d838c65" translate="yes" xml:space="preserve">
          <source>IdeCmd.ideKnown</source>
          <target state="translated">IdeCmd.ideKnown</target>
        </trans-unit>
        <trans-unit id="af66fa5d4f624290cb3a7375e016e2f1a9d6cd92" translate="yes" xml:space="preserve">
          <source>IdeCmd.ideMod</source>
          <target state="translated">IdeCmd.ideMod</target>
        </trans-unit>
        <trans-unit id="aacddb1abd1dc36d50e62188851845f24b6c5101" translate="yes" xml:space="preserve">
          <source>IdeCmd.ideMsg</source>
          <target state="translated">IdeCmd.ideMsg</target>
        </trans-unit>
        <trans-unit id="3987542ae177afb775e54575ca34e3bd87302450" translate="yes" xml:space="preserve">
          <source>IdeCmd.ideNone</source>
          <target state="translated">IdeCmd.ideNone</target>
        </trans-unit>
        <trans-unit id="7144c11f7efc4c579a3892a3dd6f187c847dc692" translate="yes" xml:space="preserve">
          <source>IdeCmd.ideOutline</source>
          <target state="translated">IdeCmd.ideOutline</target>
        </trans-unit>
        <trans-unit id="82676e35d3d812ccddf64996ea0342ad189aad4a" translate="yes" xml:space="preserve">
          <source>IdeCmd.ideProject</source>
          <target state="translated">IdeCmd.ideProject</target>
        </trans-unit>
        <trans-unit id="524f1b9e740464e5cc4cfac6c7329c11a03cb5cb" translate="yes" xml:space="preserve">
          <source>IdeCmd.ideSug</source>
          <target state="translated">IdeCmd.ideSug</target>
        </trans-unit>
        <trans-unit id="9cd625a93d41e7f1a8a89dfd10ee83e81116c8ea" translate="yes" xml:space="preserve">
          <source>IdeCmd.ideUse</source>
          <target state="translated">IdeCmd.ideUse</target>
        </trans-unit>
        <trans-unit id="781685dbafc4ce6c2834f04d9b9bddb8581e51c1" translate="yes" xml:space="preserve">
          <source>IdeCmd:</source>
          <target state="translated">IdeCmd:</target>
        </trans-unit>
        <trans-unit id="202eae41ba3b623522762ddc9a18dda84472265e" translate="yes" xml:space="preserve">
          <source>Ideally in later versions of the language, the restriction will be enforced at compile time. (Which is also why the name &lt;code&gt;noalias&lt;/code&gt; was choosen instead of a more verbose name like &lt;code&gt;unsafeAssumeNoAlias&lt;/code&gt;.)</source>
          <target state="translated">理想情况下，在该语言的更高版本中，该限制将在编译时强制执行。（这也是为什么选择 &lt;code&gt;noalias&lt;/code&gt; 而不是像 &lt;code&gt;unsafeAssumeNoAlias&lt;/code&gt; 这样更冗长的名称的原因。）</target>
        </trans-unit>
        <trans-unit id="f46d64b104cd715eb0457b58becb01c6685a0c79" translate="yes" xml:space="preserve">
          <source>IdentCache:</source>
          <target state="translated">IdentCache:</target>
        </trans-unit>
        <trans-unit id="a44628ba8c21044e8636076b5b9d6ce7f49f8e2a" translate="yes" xml:space="preserve">
          <source>Identifier Mangling</source>
          <target state="translated">识别符混淆</target>
        </trans-unit>
        <trans-unit id="1c28aa3eba3eb83da8260427d9817edabf51acf1" translate="yes" xml:space="preserve">
          <source>Identifier construction</source>
          <target state="translated">确定建筑</target>
        </trans-unit>
        <trans-unit id="f85967cd9bf8fa30a0c4ed8ed9689bd0527d9092" translate="yes" xml:space="preserve">
          <source>Identifier equality</source>
          <target state="translated">识别符平等</target>
        </trans-unit>
        <trans-unit id="33920d1761007ef9f769013f951c310d3a56264f" translate="yes" xml:space="preserve">
          <source>Identifiers &amp;amp; Keywords</source>
          <target state="translated">标识符和关键字</target>
        </trans-unit>
        <trans-unit id="20cd19ee47a89934f0e36a1ce365b38563d00949" translate="yes" xml:space="preserve">
          <source>Identifiers are &lt;code&gt;nnkIdent&lt;/code&gt; nodes. After the name lookup pass these nodes get transferred into &lt;code&gt;nnkSym&lt;/code&gt; nodes.</source>
          <target state="translated">标识符是 &lt;code&gt;nnkIdent&lt;/code&gt; 节点。通过名称查找后，这些节点将被转移到 &lt;code&gt;nnkSym&lt;/code&gt; 节点中。</target>
        </trans-unit>
        <trans-unit id="70f77e9cbcac065322f642e26369053cdd2f513b" translate="yes" xml:space="preserve">
          <source>Identifiers are valid from the point of their declaration until the end of the block in which the declaration occurred. The range where the identifier is known is the scope of the identifier. The exact scope of an identifier depends on the way it was declared.</source>
          <target state="translated">标识符从其声明之时起至声明发生的区块结束时有效。标识符已知的范围就是标识符的范围。一个标识符的确切范围取决于它的声明方式。</target>
        </trans-unit>
        <trans-unit id="d92daa59c2bffaa34e4f7d06ae7114ce23760fe1" translate="yes" xml:space="preserve">
          <source>Identifiers in Nim can be any string of letters, digits and underscores, beginning with a letter. Two immediate following underscores &lt;code&gt;__&lt;/code&gt; are not allowed:</source>
          <target state="translated">Nim中的标识符可以是字母，数字和下划线（以字母开头）的任何字符串。紧随其后的两个下划线 &lt;code&gt;__&lt;/code&gt; 是不允许的：</target>
        </trans-unit>
        <trans-unit id="631bea32d0edced136f187185e144840ec08febb" translate="yes" xml:space="preserve">
          <source>Identifiers in Nim can be any string of letters, digits and underscores, with the following restrictions:</source>
          <target state="translated">Nim中的标识符可以是任何字母、数字和下划线的字符串,但有以下限制。</target>
        </trans-unit>
        <trans-unit id="5ece544cbbd4f4b4219db7d53e882c905ac75b6a" translate="yes" xml:space="preserve">
          <source>Identifies the conversion from one codeset to another.</source>
          <target state="translated">识别从一个代码集到另一个代码集的转换。</target>
        </trans-unit>
        <trans-unit id="952eeefab257b1dc395adc18dd057b07d99f8b74" translate="yes" xml:space="preserve">
          <source>Identifies version of block</source>
          <target state="translated">识别块的版本</target>
        </trans-unit>
        <trans-unit id="9041398445fc89d9adc20f2af276ac74b5c7695f" translate="yes" xml:space="preserve">
          <source>Idetools invocation</source>
          <target state="translated">Idetools调用</target>
        </trans-unit>
        <trans-unit id="aa8a0ddc0c68ca8c1cc048c8fc326b77812b0717" translate="yes" xml:space="preserve">
          <source>Idetools outputs is always returned on single lines separated by tab characters (&lt;code&gt;\t&lt;/code&gt;). The values of each column are:</source>
          <target state="translated">Idetools输出始终在由制表符（ &lt;code&gt;\t&lt;/code&gt; ）分隔的单行上返回。每列的值为：</target>
        </trans-unit>
        <trans-unit id="3d0ad0f39f445a61643d2d4071287f67b574496b" translate="yes" xml:space="preserve">
          <source>Idetools will always answer with a single definition or none if it can't find any valid symbol matching the position of the query.</source>
          <target state="translated">如果找不到与查询位置相匹配的有效符号,Idetools将始终以单个定义或无定义来回答。</target>
        </trans-unit>
        <trans-unit id="cbcd6684d671244fdee86d60056e68d1d16184a4" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;#randomize&quot;&gt;randomize&lt;/a&gt; has not been called, the order of outcomes from this proc will always be the same.</source>
          <target state="translated">如果尚未调用&lt;a href=&quot;#randomize&quot;&gt;随机&lt;/a&gt;，则此过程的结果顺序将始终相同。</target>
        </trans-unit>
        <trans-unit id="adaa58002f716e895634b6653c2a52881a8bd474" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;#randomize&quot;&gt;randomize&lt;/a&gt; has not been called, the sequence of random numbers returned from this proc will always be the same.</source>
          <target state="translated">如果尚未调用&lt;a href=&quot;#randomize&quot;&gt;randomize&lt;/a&gt;，则此proc返回的随机数序列将始终相同。</target>
        </trans-unit>
        <trans-unit id="e1275cffa883535748d5035619b8b0ef08c96ca9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;address&lt;/code&gt; is &quot;&quot; then ADDR_ANY will be bound.</source>
          <target state="translated">如果 &lt;code&gt;address&lt;/code&gt; 为&amp;ldquo;&amp;rdquo;，则将绑定ADDR_ANY。</target>
        </trans-unit>
        <trans-unit id="b0679c17ef5dc1d53fe25a90576aa73faa698dc6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;assumedDescriptorsPerRequest&lt;/code&gt; is 0 or greater the server cares about the process's maximum file descriptor limit. It then ensures that the process still has the resources for &lt;code&gt;assumedDescriptorsPerRequest&lt;/code&gt; file descriptors before accepting a connection.</source>
          <target state="translated">如果 &lt;code&gt;assumedDescriptorsPerRequest&lt;/code&gt; 为0或更大，则服务器将关心进程的最大文件描述符限制。然后，在接受连接之前，请确保该进程仍具有用于 &lt;code&gt;assumedDescriptorsPerRequest&lt;/code&gt; 描述符请求文件描述符的资源。</target>
        </trans-unit>
        <trans-unit id="37372fbcdbd5728a2d0bd860fbfc0027fc538aa8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;async&lt;/code&gt; is &lt;code&gt;True&lt;/code&gt; no error will be thrown in the case when the error was caused by no data being available to be read.</source>
          <target state="translated">如果 &lt;code&gt;async&lt;/code&gt; 为 &lt;code&gt;True&lt;/code&gt; ，则在错误是由于没有可用的数据读取引起的情况下，不会引发任何错误。</target>
        </trans-unit>
        <trans-unit id="389371efa6da3c7248da8f138d099fa9af63f943" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;async&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; no error will be thrown in the case when the error was caused by no data being available to be read.</source>
          <target state="translated">如果 &lt;code&gt;async&lt;/code&gt; 为 &lt;code&gt;true&lt;/code&gt; ，则在错误是由于无法读取任何数据而导致的情况下，不会引发任何错误。</target>
        </trans-unit>
        <trans-unit id="e29a775354124296f28e9eed8300d0c6214c4fb0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;b.len&lt;/code&gt; is not exactly the number of elements that are referred to by &lt;code&gt;x&lt;/code&gt;, a &lt;span id=&quot;splice_1&quot;&gt;splice&lt;/span&gt; is performed:</source>
          <target state="translated">如果 &lt;code&gt;b.len&lt;/code&gt; 是不完全是由称为元件的数目 &lt;code&gt;x&lt;/code&gt; ，一个&lt;span id=&quot;splice_1&quot;&gt;拼接&lt;/span&gt;执行：</target>
        </trans-unit>
        <trans-unit id="be2d08dcff45d58dab9a2535aa2834ec34815d9f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;b.len&lt;/code&gt; is not exactly the number of elements that are referred to by &lt;code&gt;x&lt;/code&gt;, a &lt;span id=&quot;splice_2&quot;&gt;splice&lt;/span&gt; is performed.</source>
          <target state="translated">如果 &lt;code&gt;b.len&lt;/code&gt; 是不完全是由称为元件的数目 &lt;code&gt;x&lt;/code&gt; ，一个&lt;span id=&quot;splice_2&quot;&gt;拼接&lt;/span&gt;被执行。</target>
        </trans-unit>
        <trans-unit id="f92b13775ef5d4abd1b179130a1e53880a7cf964" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;break&lt;/code&gt; is used without a jump-to location, &lt;code&gt;nnkEmpty&lt;/code&gt; replaces &lt;code&gt;nnkIdent&lt;/code&gt;.</source>
          <target state="translated">如果使用 &lt;code&gt;break&lt;/code&gt; 而没有跳转到的位置，则 &lt;code&gt;nnkEmpty&lt;/code&gt; 替换 &lt;code&gt;nnkIdent&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="307e3b5354402d4ec96fc67123487c24bedd7bdf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;cache&lt;/code&gt; is not empty, the results of &lt;code&gt;staticExec&lt;/code&gt; are cached within the &lt;code&gt;nimcache&lt;/code&gt; directory. Use &lt;code&gt;--forceBuild&lt;/code&gt; to get rid of this caching behaviour then. &lt;code&gt;command &amp;amp; input &amp;amp; cache&lt;/code&gt; (the concatenated string) is used to determine whether the entry in the cache is still valid. You can use versioning information for &lt;code&gt;cache&lt;/code&gt;:</source>
          <target state="translated">如果 &lt;code&gt;cache&lt;/code&gt; 不为空，则 &lt;code&gt;staticExec&lt;/code&gt; 的结果将缓存在 &lt;code&gt;nimcache&lt;/code&gt; 目录中。然后使用 &lt;code&gt;--forceBuild&lt;/code&gt; 摆脱这种缓存行为。 &lt;code&gt;command &amp;amp; input &amp;amp; cache&lt;/code&gt; （连接的字符串）用于确定高速缓存中的条目是否仍然有效。您可以将版本信息用于 &lt;code&gt;cache&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="b925c73f3626e46d93def9af1883e608c8b76c38" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;cmdline == &quot;&quot;&lt;/code&gt;, the real command line as provided by the &lt;code&gt;os&lt;/code&gt; module is retrieved instead.</source>
          <target state="translated">如果 &lt;code&gt;cmdline == &quot;&quot;&lt;/code&gt; ，则改为检索 &lt;code&gt;os&lt;/code&gt; 模块提供的实际命令行。</target>
        </trans-unit>
        <trans-unit id="c3959c38631a1e3835545dd4c60c36192eb7baea" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;cmdline.len == 0&lt;/code&gt;, the real command line as provided by the &lt;code&gt;os&lt;/code&gt; module is retrieved instead. Behavior of the other parameters remains the same as in &lt;a href=&quot;#initOptParser,string,set%5Bchar%5D,seq%5Bstring%5D&quot;&gt;initOptParser(string, ...)&lt;/a&gt;.</source>
          <target state="translated">如果 &lt;code&gt;cmdline.len == 0&lt;/code&gt; ，则改为检索 &lt;code&gt;os&lt;/code&gt; 模块提供的实际命令行。其他参数的行为与&lt;a href=&quot;#initOptParser,string,set%5Bchar%5D,seq%5Bstring%5D&quot;&gt;initOptParser（string，...）中的&lt;/a&gt;行为相同。</target>
        </trans-unit>
        <trans-unit id="b345cf9e0a07a334467009e3e58006f18498e01b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;data&lt;/code&gt; cannot be sent immediately it will be buffered and sent when &lt;code&gt;sock&lt;/code&gt; becomes writeable (during the &lt;code&gt;handleWrite&lt;/code&gt; event). It's possible that only a part of &lt;code&gt;data&lt;/code&gt; will be sent immediately, while the rest of it will be buffered and sent later.</source>
          <target state="translated">如果无法立即发送 &lt;code&gt;data&lt;/code&gt; ，它将在 &lt;code&gt;sock&lt;/code&gt; 变为可写状态时（在 &lt;code&gt;handleWrite&lt;/code&gt; 事件期间）进行缓冲和发送。有可能只立即发送一部分 &lt;code&gt;data&lt;/code&gt; ，而其余​​部分将被缓冲并稍后发送。</target>
        </trans-unit>
        <trans-unit id="2fabc8cf9e4e8d176409d6df5c92154de739b783" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;dest&lt;/code&gt; already exists, the file attributes will be preserved and the content overwritten.</source>
          <target state="translated">如果 &lt;code&gt;dest&lt;/code&gt; 已经存在，则将保留文件属性并覆盖内容。</target>
        </trans-unit>
        <trans-unit id="179c8b020c500392eb1dfa3ed37ad6700578fc18" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;doInc == true&lt;/code&gt; (default), &lt;code&gt;i&lt;/code&gt; is incremented by the number of bytes that have been processed.</source>
          <target state="translated">如果 &lt;code&gt;doInc == true&lt;/code&gt; （默认），则 &lt;code&gt;i&lt;/code&gt; 将增加已处理的字节数。</target>
        </trans-unit>
        <trans-unit id="f1b577f00ac3cb4195580c22caa7520e6b2cc68a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;doInc == true&lt;/code&gt; (default), &lt;code&gt;pos&lt;/code&gt; is incremented by the number of bytes that have been processed.</source>
          <target state="translated">如果 &lt;code&gt;doInc == true&lt;/code&gt; （默认值），则 &lt;code&gt;pos&lt;/code&gt; 将增加已处理的字节数。</target>
        </trans-unit>
        <trans-unit id="50c45493d4069c7c7e10803f397d81b028853a8a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;err&lt;/code&gt; is not lower than 0 no exception will be raised.</source>
          <target state="translated">如果 &lt;code&gt;err&lt;/code&gt; 不小于0，则不会引发异常。</target>
        </trans-unit>
        <trans-unit id="c232394d07fbecdfb853af6943c852dd56b17fb0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;flags&lt;/code&gt; contains &lt;code&gt;SafeDisconn&lt;/code&gt;, no exception will be raised when the error was caused by a peer disconnection.</source>
          <target state="translated">如果 &lt;code&gt;flags&lt;/code&gt; 包含 &lt;code&gt;SafeDisconn&lt;/code&gt; ，则由于对等方断开连接而导致错误时，不会引发异常。</target>
        </trans-unit>
        <trans-unit id="992f346f547e129010a04dc7a87a1c4c858a76bd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;format == ffDecimal&lt;/code&gt; then precision is the number of digits to be printed after the decimal point. If &lt;code&gt;format == ffScientific&lt;/code&gt; then precision is the maximum number of significant digits to be printed. &lt;code&gt;precision&lt;/code&gt;'s default value is the maximum number of meaningful digits after the decimal point for Nim's &lt;code&gt;biggestFloat&lt;/code&gt; type.</source>
          <target state="translated">如果 &lt;code&gt;format == ffDecimal&lt;/code&gt; 则precision是小数点后要打印的位数。如果 &lt;code&gt;format == ffScientific&lt;/code&gt; 则精度是要打印的最大有效位数。 &lt;code&gt;precision&lt;/code&gt; 的默认值是Nim的 &lt;code&gt;biggestFloat&lt;/code&gt; 类型的小数点后的最大有效位数。</target>
        </trans-unit>
        <trans-unit id="0de5dc05d085caca0d2da81d987cb100c6e2af20" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;format == ffDecimal&lt;/code&gt; then precision is the number of digits to be printed after the decimal point. If &lt;code&gt;format == ffScientific&lt;/code&gt; then precision is the maximum number of significant digits to be printed. &lt;code&gt;precision&lt;/code&gt;'s default value is the maximum number of meaningful digits after the decimal point for Nim's &lt;code&gt;float&lt;/code&gt; type.</source>
          <target state="translated">如果 &lt;code&gt;format == ffDecimal&lt;/code&gt; 则precision是小数点后要打印的位数。如果 &lt;code&gt;format == ffScientific&lt;/code&gt; 则精度是要打印的最大有效位数。 &lt;code&gt;precision&lt;/code&gt; 的默认值是Nim的 &lt;code&gt;float&lt;/code&gt; 类型的小数点后的最大有效位数。</target>
        </trans-unit>
        <trans-unit id="0cf358d5e12d7a571236022c026e1ba653036067" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;format == ffDecimal&lt;/code&gt; then precision is the number of digits to be printed after the decimal point. If &lt;code&gt;format == ffScientific&lt;/code&gt; then precision is the maximum number of significant digits to be printed. &lt;em&gt;precision&lt;/em&gt;'s default value is the maximum number of meaningful digits after the decimal point for Nim's &lt;code&gt;biggestFloat&lt;/code&gt; type.</source>
          <target state="translated">如果 &lt;code&gt;format == ffDecimal&lt;/code&gt; 则precision是小数点后要打印的位数。如果 &lt;code&gt;format == ffScientific&lt;/code&gt; 则精度是要打印的最大有效位数。&lt;em&gt;precision&lt;/em&gt;的默认值是Nim的 &lt;code&gt;biggestFloat&lt;/code&gt; 类型的小数点后的最大有效位数。</target>
        </trans-unit>
        <trans-unit id="54b435b8d0e06d5409c71a6bb322a443d196828c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;format == ffDecimal&lt;/code&gt; then precision is the number of digits to be printed after the decimal point. If &lt;code&gt;format == ffScientific&lt;/code&gt; then precision is the maximum number of significant digits to be printed. &lt;em&gt;precision&lt;/em&gt;'s default value is the maximum number of meaningful digits after the decimal point for Nim's &lt;code&gt;float&lt;/code&gt; type.</source>
          <target state="translated">如果 &lt;code&gt;format == ffDecimal&lt;/code&gt; 则precision是小数点后要打印的位数。如果 &lt;code&gt;format == ffScientific&lt;/code&gt; 则精度是要打印的最大有效位数。&lt;em&gt;precision&lt;/em&gt;的默认值是Nim的 &lt;code&gt;float&lt;/code&gt; 类型的小数点后的最大有效位数。</target>
        </trans-unit>
        <trans-unit id="24e87f76944be04ed6165ca1ab99d6886718e93f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;fromRoot&lt;/code&gt; is true (default: false), the traversal will start from the file system root directory. If &lt;code&gt;inclusive&lt;/code&gt; is true (default), the original argument will be included in the traversal.</source>
          <target state="translated">如果 &lt;code&gt;fromRoot&lt;/code&gt; 为true（默认值：false），则遍历将从文件系统根目录开始。如果 &lt;code&gt;inclusive&lt;/code&gt; 为true（默认值），则原始参数将包含在遍历中。</target>
        </trans-unit>
        <trans-unit id="5ace460fa7284386356689f6617103ecd8499358" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;fut&lt;/code&gt; completes first the returned future will hold true, otherwise, if &lt;code&gt;timeout&lt;/code&gt; milliseconds has elapsed first, the returned future will hold false.</source>
          <target state="translated">如果 &lt;code&gt;fut&lt;/code&gt; 首先完成，则返回的future将保持为true，否则，如果首先经过 &lt;code&gt;timeout&lt;/code&gt; 毫秒，则返回的future将为false。</target>
        </trans-unit>
        <trans-unit id="278da5a4825851f6e880eb352bee1e7ea97b26a3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;globalRaiseHook&lt;/code&gt; returns false, the exception is caught and does not propagate further through the call stack.</source>
          <target state="translated">如果 &lt;code&gt;globalRaiseHook&lt;/code&gt; 返回false，则捕获异常，并且不会通过调用堆栈进一步传播该异常。</target>
        </trans-unit>
        <trans-unit id="407f272e1c73737914b8601c245e937e7c1645a2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;in&lt;/code&gt; had been declared as &lt;code&gt;[T](elem: T, s: set[T])&lt;/code&gt; then &lt;code&gt;T&lt;/code&gt; would have been bound to &lt;code&gt;char&lt;/code&gt;. But &lt;code&gt;s&lt;/code&gt; is not compatible to type &lt;code&gt;set[char]&lt;/code&gt;! The solution is to bind &lt;code&gt;T&lt;/code&gt; to &lt;code&gt;range['a'..'z']&lt;/code&gt;. This is achieved by reversing the parameters for &lt;code&gt;contains&lt;/code&gt;; &lt;code&gt;in&lt;/code&gt; then passes its arguments in reverse order.</source>
          <target state="translated">如果 &lt;code&gt;in&lt;/code&gt; 被声明为 &lt;code&gt;[T](elem: T, s: set[T])&lt;/code&gt; 则 &lt;code&gt;T&lt;/code&gt; 将绑定到 &lt;code&gt;char&lt;/code&gt; 。但是 &lt;code&gt;s&lt;/code&gt; 与 &lt;code&gt;set[char]&lt;/code&gt; 类型不兼容！解决方案是将 &lt;code&gt;T&lt;/code&gt; 绑定到 &lt;code&gt;range['a'..'z']&lt;/code&gt; 。这是通过反转 &lt;code&gt;contains&lt;/code&gt; 的参数来实现的； &lt;code&gt;in&lt;/code&gt; 然后将其参数传递顺序相反。</target>
        </trans-unit>
        <trans-unit id="8cdfa42069bdaab72c3cf6574fc0385fb5627407" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;inheritable&lt;/code&gt; is false (the default), the new file descriptor will not be inheritable by child processes.</source>
          <target state="translated">如果 &lt;code&gt;inheritable&lt;/code&gt; 为false（默认设置），则子进程将不能继承新的文件描述符。</target>
        </trans-unit>
        <trans-unit id="1eeb170458a1fe104e5d45a5ffa26a4dd93248b3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;inheritable&lt;/code&gt; is false (the default), the resulting client socket will not be inheritable by child processes.</source>
          <target state="translated">如果 &lt;code&gt;inheritable&lt;/code&gt; 为false（默认设置），则生成的客户端套接字将不能被子进程继承。</target>
        </trans-unit>
        <trans-unit id="1c45c785b5cf885ca443ac7882ef91c561e30cc4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;inheritable&lt;/code&gt; is false (the default), the supplied &lt;code&gt;fd&lt;/code&gt; will not be inheritable by child processes.</source>
          <target state="translated">如果 &lt;code&gt;inheritable&lt;/code&gt; 为false（默认设置），则所提供的 &lt;code&gt;fd&lt;/code&gt; 将不能被子进程继承。</target>
        </trans-unit>
        <trans-unit id="406f9addf63c24219d984d581225fbd36b7e59cc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;input&lt;/code&gt; is not an empty string, it will be passed as a standard input to the executed program.</source>
          <target state="translated">如果 &lt;code&gt;input&lt;/code&gt; 不是空字符串，则将其作为标准输入传递给已执行的程序。</target>
        </trans-unit>
        <trans-unit id="38bf593991981830f4d9acc8190fb39437d3758e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;key&lt;/code&gt; is not in &lt;code&gt;t&lt;/code&gt;, the &lt;code&gt;KeyError&lt;/code&gt; exception is raised.</source>
          <target state="translated">如果 &lt;code&gt;key&lt;/code&gt; 不在 &lt;code&gt;t&lt;/code&gt; 中，则会引发 &lt;code&gt;KeyError&lt;/code&gt; 异常。</target>
        </trans-unit>
        <trans-unit id="d8a64c16e7bac188e04713249e1e33b48fab38ba" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;key&lt;/code&gt; is not in &lt;code&gt;t&lt;/code&gt;, the &lt;code&gt;KeyError&lt;/code&gt; exception is raised. One can check with &lt;a href=&quot;#hasKey,OrderedTable%5BA,B%5D,A&quot;&gt;hasKey proc&lt;/a&gt; whether the key exists.</source>
          <target state="translated">如果 &lt;code&gt;key&lt;/code&gt; 不在 &lt;code&gt;t&lt;/code&gt; 中，则会引发 &lt;code&gt;KeyError&lt;/code&gt; 异常。可以使用&lt;a href=&quot;#hasKey,OrderedTable%5BA,B%5D,A&quot;&gt;hasKey proc&lt;/a&gt;检查密钥是否存在。</target>
        </trans-unit>
        <trans-unit id="ba8e8766fde6a8a1dcfddaffbc7869351370c283" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;key&lt;/code&gt; is not in &lt;code&gt;t&lt;/code&gt;, the &lt;code&gt;KeyError&lt;/code&gt; exception is raised. One can check with &lt;a href=&quot;#hasKey,OrderedTableRef%5BA,B%5D,A&quot;&gt;hasKey proc&lt;/a&gt; whether the key exists.</source>
          <target state="translated">如果 &lt;code&gt;key&lt;/code&gt; 不在 &lt;code&gt;t&lt;/code&gt; 中，则会引发 &lt;code&gt;KeyError&lt;/code&gt; 异常。可以使用&lt;a href=&quot;#hasKey,OrderedTableRef%5BA,B%5D,A&quot;&gt;hasKey proc&lt;/a&gt;检查密钥是否存在。</target>
        </trans-unit>
        <trans-unit id="249c0f5a67da0cf5d36d5936c0e387ed53925fc9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;key&lt;/code&gt; is not in &lt;code&gt;t&lt;/code&gt;, the &lt;code&gt;KeyError&lt;/code&gt; exception is raised. One can check with &lt;a href=&quot;#hasKey,StringTableRef,string&quot;&gt;hasKey proc&lt;/a&gt; whether the key exists.</source>
          <target state="translated">如果 &lt;code&gt;key&lt;/code&gt; 不在 &lt;code&gt;t&lt;/code&gt; 中，则会引发 &lt;code&gt;KeyError&lt;/code&gt; 异常。可以使用&lt;a href=&quot;#hasKey,StringTableRef,string&quot;&gt;hasKey proc&lt;/a&gt;检查密钥是否存在。</target>
        </trans-unit>
        <trans-unit id="a34fe873c0c24ba691ca33fcee8e20cd2100b986" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;key&lt;/code&gt; is not in &lt;code&gt;t&lt;/code&gt;, the &lt;code&gt;KeyError&lt;/code&gt; exception is raised. One can check with &lt;a href=&quot;#hasKey,Table%5BA,B%5D,A&quot;&gt;hasKey proc&lt;/a&gt; whether the key exists.</source>
          <target state="translated">如果 &lt;code&gt;key&lt;/code&gt; 不在 &lt;code&gt;t&lt;/code&gt; 中，则会引发 &lt;code&gt;KeyError&lt;/code&gt; 异常。可以使用&lt;a href=&quot;#hasKey,Table%5BA,B%5D,A&quot;&gt;hasKey proc&lt;/a&gt;检查密钥是否存在。</target>
        </trans-unit>
        <trans-unit id="c366b491959c140ec84844ec33b5bdba7625e9f1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;key&lt;/code&gt; is not in &lt;code&gt;t&lt;/code&gt;, the &lt;code&gt;KeyError&lt;/code&gt; exception is raised. One can check with &lt;a href=&quot;#hasKey,TableRef%5BA,B%5D,A&quot;&gt;hasKey proc&lt;/a&gt; whether the key exists.</source>
          <target state="translated">如果 &lt;code&gt;key&lt;/code&gt; 不在 &lt;code&gt;t&lt;/code&gt; 中，则会引发 &lt;code&gt;KeyError&lt;/code&gt; 异常。可以使用&lt;a href=&quot;#hasKey,TableRef%5BA,B%5D,A&quot;&gt;hasKey proc&lt;/a&gt;检查密钥是否存在。</target>
        </trans-unit>
        <trans-unit id="380fdd32d425d34714b1a7f7c2ff89323d49982f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;key&lt;/code&gt; is not in &lt;code&gt;t&lt;/code&gt;, the default value is returned (if not specified, it is an empty string (&lt;code&gt;&quot;&quot;&lt;/code&gt;)).</source>
          <target state="translated">如果 &lt;code&gt;key&lt;/code&gt; 不在 &lt;code&gt;t&lt;/code&gt; 中，则返回默认值（如果未指定，则为空字符串（ &lt;code&gt;&quot;&quot;&lt;/code&gt; ））。</target>
        </trans-unit>
        <trans-unit id="6dddc0c1e8e530c684c4b1df8a66360d0d01a571" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;leading&lt;/code&gt; is true (default), leading &lt;code&gt;chars&lt;/code&gt; are stripped. If &lt;code&gt;trailing&lt;/code&gt; is true (default), trailing &lt;code&gt;chars&lt;/code&gt; are stripped. If both are false, the string is returned unchanged.</source>
          <target state="translated">如果 &lt;code&gt;leading&lt;/code&gt; 为真（默认），则前导 &lt;code&gt;chars&lt;/code&gt; 将被剥离。如果 &lt;code&gt;trailing&lt;/code&gt; 为true（默认值），则会删除拖尾的 &lt;code&gt;chars&lt;/code&gt; 。如果两者均为假，则字符串将保持不变。</target>
        </trans-unit>
        <trans-unit id="d94a1a67a9237104b3f1d2a751939b79d81f08be" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;leading&lt;/code&gt; is true (default), leading &lt;code&gt;runes&lt;/code&gt; are stripped. If &lt;code&gt;trailing&lt;/code&gt; is true (default), trailing &lt;code&gt;runes&lt;/code&gt; are stripped. If both are false, the string is returned unchanged.</source>
          <target state="translated">如果 &lt;code&gt;leading&lt;/code&gt; 为真（默认），则将去除前导 &lt;code&gt;runes&lt;/code&gt; 。如果 &lt;code&gt;trailing&lt;/code&gt; 为真（默认值），则会删除拖尾 &lt;code&gt;runes&lt;/code&gt; 。如果两者均为假，则字符串将保持不变。</target>
        </trans-unit>
        <trans-unit id="1aa44a5a1c74e0287d965a233c3c05072e637958" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;linkTitle&lt;/code&gt; or &lt;code&gt;linkDesc&lt;/code&gt; are not the empty string, two additional columns with their contents will be added.</source>
          <target state="translated">如果 &lt;code&gt;linkTitle&lt;/code&gt; 或 &lt;code&gt;linkDesc&lt;/code&gt; 不是空字符串，则将添加另外两个包含其内容的列。</target>
        </trans-unit>
        <trans-unit id="12edc873e65a9a77c6f3d231c1c390abbd00d2ea" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;localRaiseHook&lt;/code&gt; returns false, the exception is caught and does not propagate further through the call stack.</source>
          <target state="translated">如果 &lt;code&gt;localRaiseHook&lt;/code&gt; 返回false，则捕获异常，并且不会通过调用堆栈进一步传播该异常。</target>
        </trans-unit>
        <trans-unit id="026648ef593a1b1232f572c220366aa54c2ea801" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;maxLen == 0&lt;/code&gt; the length of the binary number has no upper bound. Else no more than &lt;code&gt;start + maxLen&lt;/code&gt; characters are parsed, up to the length of the string.</source>
          <target state="translated">如果 &lt;code&gt;maxLen == 0&lt;/code&gt; ，则二进制数的长度没有上限。否则，最多解析 &lt;code&gt;start + maxLen&lt;/code&gt; 字符+ maxLen个字符，直到字符串的长度。</target>
        </trans-unit>
        <trans-unit id="a51b764ac263fbad8833f0cd967c9d52db03faf6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;maxLen == 0&lt;/code&gt; the length of the hexadecimal number has no upper bound. Else no more than &lt;code&gt;start + maxLen&lt;/code&gt; characters are parsed, up to the length of the string.</source>
          <target state="translated">如果 &lt;code&gt;maxLen == 0&lt;/code&gt; ，则十六进制数的长度没有上限。否则，最多解析 &lt;code&gt;start + maxLen&lt;/code&gt; 字符+ maxLen个字符，直到字符串的长度。</target>
        </trans-unit>
        <trans-unit id="a562677ba8a99d4d9a7cacc5ea3e9107a7861eb4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;maxLen == 0&lt;/code&gt; the length of the octal number has no upper bound. Else no more than &lt;code&gt;start + maxLen&lt;/code&gt; characters are parsed, up to the length of the string.</source>
          <target state="translated">如果 &lt;code&gt;maxLen == 0&lt;/code&gt; ，则八进制数的长度没有上限。否则，最多解析 &lt;code&gt;start + maxLen&lt;/code&gt; 字符+ maxLen个字符，直到字符串的长度。</target>
        </trans-unit>
        <trans-unit id="893e5d58d510dc2be130e2fbd88c80d3117cd282" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;maxLen == 0&lt;/code&gt;, the parsing continues until the first non-bin character or to the end of the string. Otherwise, no more than &lt;code&gt;maxLen&lt;/code&gt; characters are parsed starting from the &lt;code&gt;start&lt;/code&gt; position.</source>
          <target state="translated">如果 &lt;code&gt;maxLen == 0&lt;/code&gt; ，则分析将继续进行，直到第一个非bin字符或字符串的末尾。否则，从 &lt;code&gt;start&lt;/code&gt; 位置开始 &lt;code&gt;maxLen&lt;/code&gt; 只能解析maxLen个字符。</target>
        </trans-unit>
        <trans-unit id="4615eaf861e5c44008a7604d9929e84b4e558bfb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;maxLen == 0&lt;/code&gt;, the parsing continues until the first non-hex character or to the end of the string. Otherwise, no more than &lt;code&gt;maxLen&lt;/code&gt; characters are parsed starting from the &lt;code&gt;start&lt;/code&gt; position.</source>
          <target state="translated">如果 &lt;code&gt;maxLen == 0&lt;/code&gt; ，则分析将继续进行，直到第一个非十六进制字符或字符串的末尾。否则，从 &lt;code&gt;start&lt;/code&gt; 位置开始 &lt;code&gt;maxLen&lt;/code&gt; 只能解析maxLen个字符。</target>
        </trans-unit>
        <trans-unit id="59ecf74de409bd74fef9fc6889a2ed9c82a0ea16" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;maxLen == 0&lt;/code&gt;, the parsing continues until the first non-oct character or to the end of the string. Otherwise, no more than &lt;code&gt;maxLen&lt;/code&gt; characters are parsed starting from the &lt;code&gt;start&lt;/code&gt; position.</source>
          <target state="translated">如果 &lt;code&gt;maxLen == 0&lt;/code&gt; ，则分析将继续进行，直到第一个非八进制字符或字符串的末尾。否则，从 &lt;code&gt;start&lt;/code&gt; 位置开始 &lt;code&gt;maxLen&lt;/code&gt; 只能解析maxLen个字符。</target>
        </trans-unit>
        <trans-unit id="ea53a3bfa9c6fede5ed2cef2db764156ef4fd873" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;n&lt;/code&gt; is &lt;code&gt;xnElement&lt;/code&gt;, runs recursively on each child node and concatenates the results.</source>
          <target state="translated">如果 &lt;code&gt;n&lt;/code&gt; 是 &lt;code&gt;xnElement&lt;/code&gt; ，则在每个子节点上递归运行并连接结果。</target>
        </trans-unit>
        <trans-unit id="0c56744ea64d2b69dd833961b7b0ac180f77e503" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;n&lt;/code&gt; is &lt;code&gt;xnText&lt;/code&gt; or &lt;code&gt;xnEntity&lt;/code&gt;, returns its content.</source>
          <target state="translated">如果 &lt;code&gt;n&lt;/code&gt; 是 &lt;code&gt;xnText&lt;/code&gt; 或 &lt;code&gt;xnEntity&lt;/code&gt; ，则返回其内容。</target>
        </trans-unit>
        <trans-unit id="75335f14f8d8c14a442f3d953a5045449d6890a4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;n&lt;/code&gt; is a &lt;code&gt;JArray&lt;/code&gt;, it returns the number of elements. If &lt;code&gt;n&lt;/code&gt; is a &lt;code&gt;JObject&lt;/code&gt;, it returns the number of pairs. Else it returns 0.</source>
          <target state="translated">如果 &lt;code&gt;n&lt;/code&gt; 是 &lt;code&gt;JArray&lt;/code&gt; ，则返回元素数。如果 &lt;code&gt;n&lt;/code&gt; 是 &lt;code&gt;JObject&lt;/code&gt; ，则返回对数。否则返回0。</target>
        </trans-unit>
        <trans-unit id="656c3dd520d94a762eebd679e51a735495d00093" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;nested&lt;/code&gt; is true (which is the default), the literals are replaced everywhere in the &lt;code&gt;constructor&lt;/code&gt; AST, otherwise only the first level is considered:</source>
          <target state="translated">如果 &lt;code&gt;nested&lt;/code&gt; 为true（默认设置），则在 &lt;code&gt;constructor&lt;/code&gt; AST中的所有位置替换文字，否则仅考虑第一级：</target>
        </trans-unit>
        <trans-unit id="595e68e557aa9284038e74f56a160c9ff7b91ad0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;nested&lt;/code&gt; is true, the literals are replaced everywhere in the &lt;code&gt;constructor&lt;/code&gt; AST, otherwise only the first level is considered:</source>
          <target state="translated">如果 &lt;code&gt;nested&lt;/code&gt; 为true，则在 &lt;code&gt;constructor&lt;/code&gt; AST中的所有位置替换文字，否则仅考虑第一级：</target>
        </trans-unit>
        <trans-unit id="4f29ea9e8bc8cec92963dfa196efcc3cdd9dbf0a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;oneshot&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, timer will be notified only once.</source>
          <target state="translated">如果 &lt;code&gt;oneshot&lt;/code&gt; 为 &lt;code&gt;true&lt;/code&gt; ，则计时器将仅被通知一次。</target>
        </trans-unit>
        <trans-unit id="fb7fcf3322c4b89ddc898d84136f3902db0b2173" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;p&lt;/code&gt; can raise an exception, NRVO applies regardless. This can produce observable differences in behavior:</source>
          <target state="translated">如果 &lt;code&gt;p&lt;/code&gt; 可以引发异常，则NRVO均适用。这会在行为上产生明显的差异：</target>
        </trans-unit>
        <trans-unit id="ba2d85cf4096ccec712e290202f540e8eba644bd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;p&lt;/code&gt; is &lt;strong&gt;nil&lt;/strong&gt; then a new memory block is returned. In either way the block has at least &lt;code&gt;T.sizeof * newSize&lt;/code&gt; bytes. If &lt;code&gt;newSize == 0&lt;/code&gt; and &lt;code&gt;p&lt;/code&gt; is not &lt;strong&gt;nil&lt;/strong&gt;&lt;code&gt;resize&lt;/code&gt; calls &lt;code&gt;dealloc(p)&lt;/code&gt;. In other cases the block has to be freed with &lt;code&gt;free&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;p&lt;/code&gt; 为&lt;strong&gt;nil，&lt;/strong&gt;则返回一个新的存储块。无论哪种方式，该块至少具有 &lt;code&gt;T.sizeof * newSize&lt;/code&gt; 个字节。如果 &lt;code&gt;newSize == 0&lt;/code&gt; 并且 &lt;code&gt;p&lt;/code&gt; 不为&lt;strong&gt;nil，则&lt;/strong&gt; &lt;code&gt;resize&lt;/code&gt; 调用 &lt;code&gt;dealloc(p)&lt;/code&gt; 。在其他情况下，必须使用 &lt;code&gt;free&lt;/code&gt; 释放该块。</target>
        </trans-unit>
        <trans-unit id="bed5605b04e8d57058de5a7f3da3929c77cecfcd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;p&lt;/code&gt; is &lt;strong&gt;nil&lt;/strong&gt; then a new memory block is returned. In either way the block has at least &lt;code&gt;T.sizeof * newSize&lt;/code&gt; bytes. If &lt;code&gt;newSize == 0&lt;/code&gt; and &lt;code&gt;p&lt;/code&gt; is not &lt;strong&gt;nil&lt;/strong&gt;&lt;code&gt;resizeShared&lt;/code&gt; calls &lt;code&gt;freeShared(p)&lt;/code&gt;. In other cases the block has to be freed with &lt;a href=&quot;#freeShared,ptr.T&quot;&gt;freeShared&lt;/a&gt;.</source>
          <target state="translated">如果 &lt;code&gt;p&lt;/code&gt; 为&lt;strong&gt;nil，&lt;/strong&gt;则返回一个新的存储块。无论哪种方式，该块至少具有 &lt;code&gt;T.sizeof * newSize&lt;/code&gt; 个字节。如果 &lt;code&gt;newSize == 0&lt;/code&gt; 和 &lt;code&gt;p&lt;/code&gt; 不&lt;strong&gt;为零&lt;/strong&gt; &lt;code&gt;resizeShared&lt;/code&gt; 调用 &lt;code&gt;freeShared(p)&lt;/code&gt; 。在其他情况下，必须使用&lt;a href=&quot;#freeShared,ptr.T&quot;&gt;freeShared&lt;/a&gt;释放该块。</target>
        </trans-unit>
        <trans-unit id="58b288f57414901fd3b7c8f558b4ac9ad0c4368e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;p&lt;/code&gt; is &lt;strong&gt;nil&lt;/strong&gt; then a new memory block is returned. In either way the block has at least &lt;code&gt;newSize&lt;/code&gt; bytes. If &lt;code&gt;newSize == 0&lt;/code&gt; and &lt;code&gt;p&lt;/code&gt; is not &lt;strong&gt;nil&lt;/strong&gt;&lt;code&gt;realloc&lt;/code&gt; calls &lt;code&gt;dealloc(p)&lt;/code&gt;. In other cases the block has to be freed with &lt;a href=&quot;#dealloc,pointer&quot;&gt;dealloc(block)&lt;/a&gt;.</source>
          <target state="translated">如果 &lt;code&gt;p&lt;/code&gt; 为&lt;strong&gt;nil，&lt;/strong&gt;则返回一个新的存储块。无论哪种方式，该块至少具有 &lt;code&gt;newSize&lt;/code&gt; 字节。如果 &lt;code&gt;newSize == 0&lt;/code&gt; 并且 &lt;code&gt;p&lt;/code&gt; 不为&lt;strong&gt;nil，则&lt;/strong&gt; &lt;code&gt;realloc&lt;/code&gt; 调用 &lt;code&gt;dealloc(p)&lt;/code&gt; 。在其他情况下，必须使用&lt;a href=&quot;#dealloc,pointer&quot;&gt;dealloc（block）&lt;/a&gt;释放该块。</target>
        </trans-unit>
        <trans-unit id="c7b9506b555b19e38390b766b3839016f55c3f20" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;p&lt;/code&gt; is &lt;strong&gt;nil&lt;/strong&gt; then a new memory block is returned. In either way the block has at least &lt;code&gt;newSize&lt;/code&gt; bytes. If &lt;code&gt;newSize == 0&lt;/code&gt; and &lt;code&gt;p&lt;/code&gt; is not &lt;strong&gt;nil&lt;/strong&gt;&lt;code&gt;reallocShared&lt;/code&gt; calls &lt;code&gt;deallocShared(p)&lt;/code&gt;. In other cases the block has to be freed with &lt;a href=&quot;#deallocShared,pointer&quot;&gt;deallocShared&lt;/a&gt;.</source>
          <target state="translated">如果 &lt;code&gt;p&lt;/code&gt; 为&lt;strong&gt;nil，&lt;/strong&gt;则返回一个新的存储块。无论哪种方式，该块至少具有 &lt;code&gt;newSize&lt;/code&gt; 字节。如果 &lt;code&gt;newSize == 0&lt;/code&gt; 和 &lt;code&gt;p&lt;/code&gt; 不&lt;strong&gt;为零&lt;/strong&gt; &lt;code&gt;reallocShared&lt;/code&gt; 调用 &lt;code&gt;deallocShared(p)&lt;/code&gt; 。在其他情况下，必须使用&lt;a href=&quot;#deallocShared,pointer&quot;&gt;deallocShared&lt;/a&gt;释放该块。</target>
        </trans-unit>
        <trans-unit id="49337ccb0d2caf6cbd714809676678b471a58cd9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;path&lt;/code&gt; has no extension, &lt;code&gt;ext&lt;/code&gt; is the empty string. If &lt;code&gt;path&lt;/code&gt; has no directory component, &lt;code&gt;dir&lt;/code&gt; is the empty string. If &lt;code&gt;path&lt;/code&gt; has no filename component, &lt;code&gt;name&lt;/code&gt; and &lt;code&gt;ext&lt;/code&gt; are empty strings.</source>
          <target state="translated">如果 &lt;code&gt;path&lt;/code&gt; 没有扩展名，则 &lt;code&gt;ext&lt;/code&gt; 是空字符串。如果 &lt;code&gt;path&lt;/code&gt; 没有目录组件，则 &lt;code&gt;dir&lt;/code&gt; 是空字符串。如果 &lt;code&gt;path&lt;/code&gt; 没有文件名部分，则 &lt;code&gt;name&lt;/code&gt; 和 &lt;code&gt;ext&lt;/code&gt; 为空字符串。</target>
        </trans-unit>
        <trans-unit id="95ef0a2efbe04230bcafbfd5fca750d56f178c89" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;pos&lt;/code&gt; or &lt;code&gt;len&lt;/code&gt; is negative they count from the end of the string. If &lt;code&gt;len&lt;/code&gt; is not given it means the longest possible string.</source>
          <target state="translated">如果 &lt;code&gt;pos&lt;/code&gt; 或 &lt;code&gt;len&lt;/code&gt; 为负，则从字符串末尾开始计数。如果未指定 &lt;code&gt;len&lt;/code&gt; ,则表示可能的最长字符串。</target>
        </trans-unit>
        <trans-unit id="a70580e1cf0a168c03d50768037af1f65f6b54c8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;precision == -1&lt;/code&gt;, it tries to format it nicely.</source>
          <target state="translated">如果 &lt;code&gt;precision == -1&lt;/code&gt; ，它将尝试很好地格式化它。</target>
        </trans-unit>
        <trans-unit id="5bf1390f2bc8d6e9c194a681c0dcbd434ac66ce4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;prefix == &quot;&quot;&lt;/code&gt; true is returned.</source>
          <target state="translated">如果 &lt;code&gt;prefix == &quot;&quot;&lt;/code&gt; 则返回true。</target>
        </trans-unit>
        <trans-unit id="cc25ab3f0e351a21f44f27af9ee1d4d7e0821c74" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;relative&lt;/code&gt; is true (default: false) the resulting path is shortened to be relative to &lt;code&gt;dir&lt;/code&gt;, otherwise the full path is returned.</source>
          <target state="translated">如果 &lt;code&gt;relative&lt;/code&gt; 为true（默认值：false），则将所得路径缩短为相对于 &lt;code&gt;dir&lt;/code&gt; ，否则返回完整路径。</target>
        </trans-unit>
        <trans-unit id="1b0d482ad73be533ef58efb16e6fe7464115647a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; contains none of the characters in &lt;code&gt;chars&lt;/code&gt;, -1 is returned. Otherwise the index returned is relative to &lt;code&gt;s[0]&lt;/code&gt;, not &lt;code&gt;start&lt;/code&gt;. Use &lt;code&gt;s[start..last].find&lt;/code&gt; for a &lt;code&gt;start&lt;/code&gt;-origin index.</source>
          <target state="translated">如果 &lt;code&gt;s&lt;/code&gt; 不包含 &lt;code&gt;chars&lt;/code&gt; 中的任何字符，则返回-1。否则，返回的索引是相对于 &lt;code&gt;s[0]&lt;/code&gt; 而不是 &lt;code&gt;start&lt;/code&gt; 的。使用 &lt;code&gt;s[start..last].find&lt;/code&gt; 作为 &lt;code&gt;start&lt;/code&gt; 索引。</target>
        </trans-unit>
        <trans-unit id="3c4618ad326f47cfc4d89b754072a43347be1f7d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; contains none of the characters in &lt;code&gt;chars&lt;/code&gt;, -1 is returned. Otherwise the index returned is relative to &lt;code&gt;s[0]&lt;/code&gt;, not &lt;code&gt;start&lt;/code&gt;. Use &lt;code&gt;s[start..last].rfind&lt;/code&gt; for a &lt;code&gt;start&lt;/code&gt;-origin index.</source>
          <target state="translated">如果 &lt;code&gt;s&lt;/code&gt; 不包含 &lt;code&gt;chars&lt;/code&gt; 中的任何字符，则返回-1。否则，返回的索引是相对于 &lt;code&gt;s[0]&lt;/code&gt; 而不是 &lt;code&gt;start&lt;/code&gt; 的。使用 &lt;code&gt;s[start..last].rfind&lt;/code&gt; 作为 &lt;code&gt;start&lt;/code&gt; 索引。</target>
        </trans-unit>
        <trans-unit id="9911531b5031bdcc6554ffa1919d8d6e7f1efaf4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; does not begin with &lt;code&gt;prefix&lt;/code&gt; and end with &lt;code&gt;suffix&lt;/code&gt; a ValueError exception will be raised.</source>
          <target state="translated">如果 &lt;code&gt;s&lt;/code&gt; 不以 &lt;code&gt;prefix&lt;/code&gt; 开头并且以 &lt;code&gt;suffix&lt;/code&gt; 结尾，则将引发ValueError异常。</target>
        </trans-unit>
        <trans-unit id="b3611bdbf077701ac2ce63e8fa76875d4287ff11" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; is not a valid binary integer, &lt;code&gt;ValueError&lt;/code&gt; is raised. &lt;code&gt;s&lt;/code&gt; can have one of the following optional prefixes: &lt;code&gt;0b&lt;/code&gt;, &lt;code&gt;0B&lt;/code&gt;. Underscores within &lt;code&gt;s&lt;/code&gt; are ignored.</source>
          <target state="translated">如果 &lt;code&gt;s&lt;/code&gt; 不是有效的二进制整数，则引发 &lt;code&gt;ValueError&lt;/code&gt; 。 &lt;code&gt;s&lt;/code&gt; 可以具有以下可选前缀之一： &lt;code&gt;0b&lt;/code&gt; ， &lt;code&gt;0B&lt;/code&gt; 。 &lt;code&gt;s&lt;/code&gt; 中的下划线将被忽略。</target>
        </trans-unit>
        <trans-unit id="05222260cd891e991699712618ddf0c7dfa42bff" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; is not a valid floating point number, &lt;code&gt;ValueError&lt;/code&gt; is raised. &lt;code&gt;NAN&lt;/code&gt;, &lt;code&gt;INF&lt;/code&gt;, &lt;code&gt;-INF&lt;/code&gt; are also supported (case insensitive comparison).</source>
          <target state="translated">如果 &lt;code&gt;s&lt;/code&gt; 不是有效的浮点数，则引发 &lt;code&gt;ValueError&lt;/code&gt; 。还支持 &lt;code&gt;NAN&lt;/code&gt; ， &lt;code&gt;INF&lt;/code&gt; ， &lt;code&gt;-INF&lt;/code&gt; （不区分大小写的比较）。</target>
        </trans-unit>
        <trans-unit id="b80fb9bde1ef884734a967ebf65c7defe9b17298" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; is not a valid hex integer, &lt;code&gt;ValueError&lt;/code&gt; is raised. &lt;code&gt;s&lt;/code&gt; can have one of the following optional prefixes: &lt;code&gt;0x&lt;/code&gt;, &lt;code&gt;0X&lt;/code&gt;, &lt;code&gt;#&lt;/code&gt;. Underscores within &lt;code&gt;s&lt;/code&gt; are ignored.</source>
          <target state="translated">如果 &lt;code&gt;s&lt;/code&gt; 不是有效的十六进制整数，则引发 &lt;code&gt;ValueError&lt;/code&gt; 。 &lt;code&gt;s&lt;/code&gt; 可以具有以下可选前缀之一： &lt;code&gt;0x&lt;/code&gt; ， &lt;code&gt;0X&lt;/code&gt; ， &lt;code&gt;#&lt;/code&gt; 。 &lt;code&gt;s&lt;/code&gt; 中的下划线将被忽略。</target>
        </trans-unit>
        <trans-unit id="8944664a31703273acb73b529c6684e13ca1d27d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; is not a valid integer, &lt;code&gt;ValueError&lt;/code&gt; is raised.</source>
          <target state="translated">如果 &lt;code&gt;s&lt;/code&gt; 不是有效的整数，则引发 &lt;code&gt;ValueError&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4f0f53b6bc8e0f0dbbffdf8dae723133a74d0bf5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; is not a valid oct integer, &lt;code&gt;ValueError&lt;/code&gt; is raised. &lt;code&gt;s&lt;/code&gt; can have one of the following optional prefixes: &lt;code&gt;0o&lt;/code&gt;, &lt;code&gt;0O&lt;/code&gt;. Underscores within &lt;code&gt;s&lt;/code&gt; are ignored.</source>
          <target state="translated">如果 &lt;code&gt;s&lt;/code&gt; 不是有效的八进制整数，则引发 &lt;code&gt;ValueError&lt;/code&gt; 。 &lt;code&gt;s&lt;/code&gt; 可以具有以下可选前缀之一： &lt;code&gt;0o&lt;/code&gt; ， &lt;code&gt;0O&lt;/code&gt; 。 &lt;code&gt;s&lt;/code&gt; 中的下划线将被忽略。</target>
        </trans-unit>
        <trans-unit id="8b74ad38f168d9d2226417f5a435c05ea2270de4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; is not a valid octal integer, &lt;code&gt;ValueError&lt;/code&gt; is raised. &lt;code&gt;s&lt;/code&gt; can have one of the following optional prefixes: &lt;code&gt;0o&lt;/code&gt;, &lt;code&gt;0O&lt;/code&gt;. Underscores within &lt;code&gt;s&lt;/code&gt; are ignored.</source>
          <target state="translated">如果 &lt;code&gt;s&lt;/code&gt; 不是有效的八进制整数，则引发 &lt;code&gt;ValueError&lt;/code&gt; 。 &lt;code&gt;s&lt;/code&gt; 可以具有以下可选前缀之一： &lt;code&gt;0o&lt;/code&gt; ， &lt;code&gt;0O&lt;/code&gt; 。 &lt;code&gt;s&lt;/code&gt; 中的下划线将被忽略。</target>
        </trans-unit>
        <trans-unit id="2374c2c8aa40a349e05a30284a2b42f18efb33ce" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; is one of the following values: &lt;code&gt;y, yes, true, 1, on&lt;/code&gt;, then returns &lt;code&gt;true&lt;/code&gt;. If &lt;code&gt;s&lt;/code&gt; is one of the following values: &lt;code&gt;n, no, false, 0, off&lt;/code&gt;, then returns &lt;code&gt;false&lt;/code&gt;. If &lt;code&gt;s&lt;/code&gt; is something else a &lt;code&gt;ValueError&lt;/code&gt; exception is raised.</source>
          <target state="translated">如果 &lt;code&gt;s&lt;/code&gt; 是以下值之一： &lt;code&gt;y, yes, true, 1, on&lt;/code&gt; ，则返回 &lt;code&gt;true&lt;/code&gt; 。如果 &lt;code&gt;s&lt;/code&gt; 是以下值之一： &lt;code&gt;n, no, false, 0, off&lt;/code&gt; ，则返回 &lt;code&gt;false&lt;/code&gt; 。如果 &lt;code&gt;s&lt;/code&gt; 是其他值，则会引发 &lt;code&gt;ValueError&lt;/code&gt; 异常。</target>
        </trans-unit>
        <trans-unit id="f39dfcd47dad136aebe8c56a844f53a0d8d6ae02" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; is one of the following values: &lt;code&gt;y, yes, true, 1, on&lt;/code&gt;, then returns &lt;em&gt;true&lt;/em&gt;. If &lt;code&gt;s&lt;/code&gt; is one of the following values: &lt;code&gt;n, no, false, 0, off&lt;/code&gt;, then returns &lt;em&gt;false&lt;/em&gt;. If &lt;code&gt;s&lt;/code&gt; is something else a &lt;code&gt;ValueError&lt;/code&gt; exception is raised.</source>
          <target state="translated">如果 &lt;code&gt;s&lt;/code&gt; 是以下值之一： &lt;code&gt;y, yes, true, 1, on&lt;/code&gt; ，则返回&lt;em&gt;true&lt;/em&gt;。如果 &lt;code&gt;s&lt;/code&gt; 是以下值之一： &lt;code&gt;n, no, false, 0, off&lt;/code&gt; ，则返回&lt;em&gt;false&lt;/em&gt;。如果 &lt;code&gt;s&lt;/code&gt; 是其他值，则会引发 &lt;code&gt;ValueError&lt;/code&gt; 异常。</target>
        </trans-unit>
        <trans-unit id="61ef1bcd9b55e9ade012520c7af4bb721dbb2002" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;safe&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; then it will encode using the URL-Safe and Filesystem-safe standard alphabet characters, which substitutes &lt;code&gt;-&lt;/code&gt; instead of &lt;code&gt;+&lt;/code&gt; and &lt;code&gt;_&lt;/code&gt; instead of &lt;code&gt;/&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;safe&lt;/code&gt; 为 &lt;code&gt;true&lt;/code&gt; ,则它将使用URL安全和Filesystem安全的标准字母字符进行编码，这些字符用 &lt;code&gt;-&lt;/code&gt; 代替 &lt;code&gt;+&lt;/code&gt; ，用 &lt;code&gt;_&lt;/code&gt; 代替 &lt;code&gt;/&lt;/code&gt; 代替。</target>
        </trans-unit>
        <trans-unit id="f39c36d767045ced0335fba924a908ac5c01042d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;siPrefix&lt;/code&gt; is set to true, the number will be displayed with the SI prefix corresponding to the exponent. For example 4100 will be displayed as &quot;4.1 k&quot; instead of &quot;4.1e3&quot;. Note that &lt;code&gt;u&lt;/code&gt; is used for micro- in place of the greek letter mu (&amp;mu;) as per ISO 2955. Numbers with an absolute value outside of the range 1e-18&amp;lt;f&amp;lt;1000e18 (1a&amp;lt;f&amp;lt;1000E) will be displayed with an exponent rather than an SI prefix, regardless of whether &lt;code&gt;siPrefix&lt;/code&gt; is true.</source>
          <target state="translated">如果 &lt;code&gt;siPrefix&lt;/code&gt; 设置为true，则将显示该数字以及与该指数对应的SI前缀。例如，4100将显示为&amp;ldquo; 4.1 k&amp;rdquo;而不是&amp;ldquo; 4.1e3&amp;rdquo;。请注意， &lt;code&gt;u&lt;/code&gt; 用于代替ISO 2955的希腊字母mu（&amp;mu;）。绝对值超出1e-18 &amp;lt;f &amp;lt;1000e18（1a &amp;lt;f &amp;lt;1000E）范围的数字将显示为指数，而不是SI前缀，而不管 &lt;code&gt;siPrefix&lt;/code&gt; 是否为true。</target>
        </trans-unit>
        <trans-unit id="010a71c05f1179f8db0658264d0a7a515cb8b523" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;skipNonAlpha&lt;/code&gt; is false, returns true only if all characters in &lt;code&gt;s&lt;/code&gt; are alphabetical and lower case.</source>
          <target state="translated">如果 &lt;code&gt;skipNonAlpha&lt;/code&gt; 为false，则仅当 &lt;code&gt;s&lt;/code&gt; 中的所有字符均为字母且小写时才返回true 。</target>
        </trans-unit>
        <trans-unit id="4f5851e215627025c8523ee634c01c31772cd434" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;skipNonAlpha&lt;/code&gt; is false, returns true only if all characters in &lt;code&gt;s&lt;/code&gt; are alphabetical and upper case.</source>
          <target state="translated">如果 &lt;code&gt;skipNonAlpha&lt;/code&gt; 为false，则仅当 &lt;code&gt;s&lt;/code&gt; 中的所有字符均为字母大写时才返回true 。</target>
        </trans-unit>
        <trans-unit id="a9ffc30f44ce015254cb84f1d8acff12890af1cd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;skipNonAlpha&lt;/code&gt; is false, returns true only if all runes in &lt;code&gt;s&lt;/code&gt; are alphabetical and lower case.</source>
          <target state="translated">如果 &lt;code&gt;skipNonAlpha&lt;/code&gt; 为false，则仅当 &lt;code&gt;s&lt;/code&gt; 中的所有符文均为字母且小写时才返回true 。</target>
        </trans-unit>
        <trans-unit id="8c1ee7df97e960b64a9a34fca52a4ee613463ee3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;skipNonAlpha&lt;/code&gt; is false, returns true only if all runes in &lt;code&gt;s&lt;/code&gt; are alphabetical and upper case.</source>
          <target state="translated">如果 &lt;code&gt;skipNonAlpha&lt;/code&gt; 为false，则仅当 &lt;code&gt;s&lt;/code&gt; 中的所有符文均为字母和大写字母时，才返回true 。</target>
        </trans-unit>
        <trans-unit id="d7daf16ddab2ec83f10b25fc93d560bdca6cc331" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;skipNonAlpha&lt;/code&gt; is true, returns true if all alphabetical characters in &lt;code&gt;s&lt;/code&gt; are lower case. Returns false if none of the characters in &lt;code&gt;s&lt;/code&gt; are alphabetical.</source>
          <target state="translated">如果 &lt;code&gt;skipNonAlpha&lt;/code&gt; 为true，则如果 &lt;code&gt;s&lt;/code&gt; 中的所有字母字符均为小写，则返回true 。如果 &lt;code&gt;s&lt;/code&gt; 中的所有字符都不是字母，则返回false 。</target>
        </trans-unit>
        <trans-unit id="5690821da9c726f211bd0d9f591332cb14d7d459" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;skipNonAlpha&lt;/code&gt; is true, returns true if all alphabetical characters in &lt;code&gt;s&lt;/code&gt; are upper case. Returns false if none of the characters in &lt;code&gt;s&lt;/code&gt; are alphabetical.</source>
          <target state="translated">如果 &lt;code&gt;skipNonAlpha&lt;/code&gt; 为true，则如果 &lt;code&gt;s&lt;/code&gt; 中的所有字母字符均为大写，则返回true 。如果 &lt;code&gt;s&lt;/code&gt; 中的所有字符都不是字母，则返回false 。</target>
        </trans-unit>
        <trans-unit id="317dfb0d58e9180509c313e714059b2f64b10411" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;skipNonAlpha&lt;/code&gt; is true, returns true if all alphabetical runes in &lt;code&gt;s&lt;/code&gt; are lower case. Returns false if none of the runes in &lt;code&gt;s&lt;/code&gt; are alphabetical.</source>
          <target state="translated">如果 &lt;code&gt;skipNonAlpha&lt;/code&gt; 为true，则如果 &lt;code&gt;s&lt;/code&gt; 中的所有字母符文均为小写，则返回true 。如果 &lt;code&gt;s&lt;/code&gt; 中的所有符文都不是字母，则返回false 。</target>
        </trans-unit>
        <trans-unit id="ed588c14681cc5f1a8b51d3a7fac0541af404239" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;skipNonAlpha&lt;/code&gt; is true, returns true if all alphabetical runes in &lt;code&gt;s&lt;/code&gt; are upper case. Returns false if none of the runes in &lt;code&gt;s&lt;/code&gt; are alphabetical.</source>
          <target state="translated">如果 &lt;code&gt;skipNonAlpha&lt;/code&gt; 为true，则如果 &lt;code&gt;s&lt;/code&gt; 中的所有字母符文均为大写，则返回true 。如果 &lt;code&gt;s&lt;/code&gt; 中的所有符文都不是字母，则返回false 。</target>
        </trans-unit>
        <trans-unit id="046a824089b8e2afbd1bb54bbb407aa442933340" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;socket&lt;/code&gt; is an SSL socket a handshake will be automatically performed.</source>
          <target state="translated">如果 &lt;code&gt;socket&lt;/code&gt; 是SSL套接字，则将自动执行握手。</target>
        </trans-unit>
        <trans-unit id="4d0f3c7d51187ced65130a92b89a877fc3668b25" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;socket&lt;/code&gt; is an SSL/TLS socket, this proc will also send a closure notification to the peer. If &lt;code&gt;SafeDisconn&lt;/code&gt; is in &lt;code&gt;flags&lt;/code&gt;, failure to do so due to disconnections will be ignored. This is generally safe in practice. See &lt;a href=&quot;https://security.stackexchange.com/a/82044&quot;&gt;here&lt;/a&gt; for more details.</source>
          <target state="translated">如果 &lt;code&gt;socket&lt;/code&gt; 是SSL / TLS套接字，则此proc还将向其对等方发送关闭通知。如果 &lt;code&gt;SafeDisconn&lt;/code&gt; 处于 &lt;code&gt;flags&lt;/code&gt; 中，那么由于断开连接而导致的失败将被忽略。实际上这通常是安全的。有关更多详细信息，请参见&lt;a href=&quot;https://security.stackexchange.com/a/82044&quot;&gt;此处&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="060c1aa6f7f394b2b22e4128d7bf5e88f3bff5e0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;spread&lt;/code&gt; is false and the length of &lt;code&gt;s&lt;/code&gt; is not a multiple of &lt;code&gt;num&lt;/code&gt;, the proc will max out the first sub-sequence with &lt;code&gt;1 + len(s) div num&lt;/code&gt; entries, leaving the remainder of elements to the last sequence.</source>
          <target state="translated">如果 &lt;code&gt;spread&lt;/code&gt; 为false并且 &lt;code&gt;s&lt;/code&gt; 的长度不是 &lt;code&gt;num&lt;/code&gt; 的倍数，则proc将使用 &lt;code&gt;1 + len(s) div num&lt;/code&gt; 个条目最大化第一个子序列，而将其余元素保留到最后一个序列。</target>
        </trans-unit>
        <trans-unit id="657ddf2b2a172bb3a4efe1d540a814def8cd98c9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;startDt.timezone != endDt.timezone&lt;/code&gt;, then the result will be equivalent to &lt;code&gt;between(startDt.utc, endDt.utc)&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;startDt.timezone != endDt.timezone&lt;/code&gt; ，则结果将等于 &lt;code&gt;between(startDt.utc, endDt.utc)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c7c307f2775a5e9f17487dafb7d99513801ab570" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;startDt.timezone == endDt.timezone&lt;/code&gt;, it is guaranteed that &lt;code&gt;startDt + between(startDt, endDt) == endDt&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;startDt.timezone == endDt.timezone&lt;/code&gt; ，则可以确保 &lt;code&gt;startDt + between(startDt, endDt) == endDt&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c110971e46a836dd2629952749afa315b2670098" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;substr == &quot;&quot;&lt;/code&gt; true is returned.</source>
          <target state="translated">如果 &lt;code&gt;substr == &quot;&quot;&lt;/code&gt; 则返回true。</target>
        </trans-unit>
        <trans-unit id="d757e24742c24af41e66e6d5cd0f46d4cd8adcb9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;suffix == &quot;&quot;&lt;/code&gt; true is returned.</source>
          <target state="translated">如果 &lt;code&gt;suffix == &quot;&quot;&lt;/code&gt; 则返回true。</target>
        </trans-unit>
        <trans-unit id="23a94d218a3df4e439dc4c897d75080cff84d65f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;trim&lt;/code&gt; is set to true, trailing zeros will be removed; if false, the number of digits specified by &lt;code&gt;precision&lt;/code&gt; will always be shown.</source>
          <target state="translated">如果 &lt;code&gt;trim&lt;/code&gt; 设置为true，则尾随零将被删除；否则，将删除尾随零。如果为false，将始终显示由 &lt;code&gt;precision&lt;/code&gt; 指定的位数。</target>
        </trans-unit>
        <trans-unit id="b73051fe1df0d6852ad033cd16067f76b3c7f36d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;true&lt;/code&gt; awaiting &lt;code&gt;fv&lt;/code&gt; will not block.</source>
          <target state="translated">如果为 &lt;code&gt;true&lt;/code&gt; ,则等待 &lt;code&gt;fv&lt;/code&gt; 不会阻塞。</target>
        </trans-unit>
        <trans-unit id="adaa3990942a768ad453fdae96d12de0c644136d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;true&lt;/code&gt;, awaiting &lt;code&gt;fv&lt;/code&gt; will not block.</source>
          <target state="translated">如果为 &lt;code&gt;true&lt;/code&gt; ，则等待 &lt;code&gt;fv&lt;/code&gt; 不会阻塞。</target>
        </trans-unit>
        <trans-unit id="76ecefbe050b42276046ba620021335a783ef155" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;typ&lt;/code&gt; is a tyObject then it is converted into a &lt;code&gt;ref &amp;lt;typ&amp;gt;&lt;/code&gt; and returned. Otherwise &lt;code&gt;typ&lt;/code&gt; is simply returned as-is.</source>
          <target state="translated">如果 &lt;code&gt;typ&lt;/code&gt; 是tyObject，则将其转换为 &lt;code&gt;ref &amp;lt;typ&amp;gt;&lt;/code&gt; 并返回。否则， &lt;code&gt;typ&lt;/code&gt; 只是按原样返回。</target>
        </trans-unit>
        <trans-unit id="cf295e9e7cbbb412c64f6987b18c18312bdc28e6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;typ&lt;/code&gt; is a tyRef then its immediate son is returned (which in many cases should be a &lt;code&gt;tyObject&lt;/code&gt;). Otherwise &lt;code&gt;typ&lt;/code&gt; is simply returned as-is.</source>
          <target state="translated">如果 &lt;code&gt;typ&lt;/code&gt; 是tyRef，则返回其直接子级（在许多情况下应为 &lt;code&gt;tyObject&lt;/code&gt; ）。否则， &lt;code&gt;typ&lt;/code&gt; 只是按原样返回。</target>
        </trans-unit>
        <trans-unit id="3e00843d5aef01872fdcccdd18ef42b91f785478" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;typ&lt;/code&gt; is not a tyVar then it is converted into a &lt;code&gt;var &amp;lt;typ&amp;gt;&lt;/code&gt; and returned. Otherwise &lt;code&gt;typ&lt;/code&gt; is simply returned as-is.</source>
          <target state="translated">如果 &lt;code&gt;typ&lt;/code&gt; 不是tyVar，则将其转换为 &lt;code&gt;var &amp;lt;typ&amp;gt;&lt;/code&gt; 并返回。否则， &lt;code&gt;typ&lt;/code&gt; 只是按原样返回。</target>
        </trans-unit>
        <trans-unit id="bc9c3ff2a3345cd590a6fedc6177790735c03231" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;type&lt;/code&gt; is used to determine the result type of a proc/iterator/converter call &lt;code&gt;c(X)&lt;/code&gt; (where &lt;code&gt;X&lt;/code&gt; stands for a possibly empty list of arguments), the interpretation where &lt;code&gt;c&lt;/code&gt; is an iterator is preferred over the other interpretations:</source>
          <target state="translated">如果将 &lt;code&gt;type&lt;/code&gt; 用于确定proc / iterator / converter调用 &lt;code&gt;c(X)&lt;/code&gt; 的结果类型（其中 &lt;code&gt;X&lt;/code&gt; 表示可能为空的参数列表），则 &lt;code&gt;c&lt;/code&gt; 是迭代器的解释优于其他解释：</target>
        </trans-unit>
        <trans-unit id="57a32de2331e9ab54dec2c66a459bffb42600360" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;typeof&lt;/code&gt; is used to determine the result type of a proc/iterator/converter call &lt;code&gt;c(X)&lt;/code&gt; (where &lt;code&gt;X&lt;/code&gt; stands for a possibly empty list of arguments), the interpretation, where &lt;code&gt;c&lt;/code&gt; is an iterator, is preferred over the other interpretations, but this behavior can be changed by passing &lt;code&gt;typeOfProc&lt;/code&gt; as the second argument to &lt;code&gt;typeof&lt;/code&gt;:</source>
          <target state="translated">如果使用 &lt;code&gt;typeof&lt;/code&gt; 来确定proc / iterator / converter调用 &lt;code&gt;c(X)&lt;/code&gt; 的结果类型（其中 &lt;code&gt;X&lt;/code&gt; 表示可能为空的参数列表），则解释（其中 &lt;code&gt;c&lt;/code&gt; 是迭代器）优于其他解释，但是可以通过将 &lt;code&gt;typeOfProc&lt;/code&gt; 作为第二个参数传递给 &lt;code&gt;typeof&lt;/code&gt; 来更改此行为：</target>
        </trans-unit>
        <trans-unit id="71f8f73625233247a8d51ea4a5902a174791b134" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;useUnitSpace&lt;/code&gt; is true, the provided unit will be appended to the string (with a space as required by the SI standard). This behaviour is slightly different to appending the unit to the result as the location of the space is altered depending on whether there is an exponent.</source>
          <target state="translated">如果 &lt;code&gt;useUnitSpace&lt;/code&gt; 为true，则将提供的单位追加到字符串（SI标准要求的空格）。这种行为与将单位附加到结果上略有不同，因为根据是否存在指数而改变了空间的位置。</target>
        </trans-unit>
        <trans-unit id="eeec7c4c3cb8ca4e353d938a916ba614cde6a3e1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;v&lt;/code&gt; is &lt;code&gt;result&lt;/code&gt; then &lt;code&gt;b&lt;/code&gt; has to be a location derived from the first formal parameter or from a constant location.</source>
          <target state="translated">如果 &lt;code&gt;v&lt;/code&gt; 是 &lt;code&gt;result&lt;/code&gt; 则 &lt;code&gt;b&lt;/code&gt; 必须是从第一个形式参数或恒定位置派生的位置。</target>
        </trans-unit>
        <trans-unit id="d912f1092864cc7f5e6b65ecaa626ec86c5e6033" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;v&lt;/code&gt; is a mutable view and &lt;code&gt;v&lt;/code&gt; is used to actually mutate the borrowed location, then &lt;code&gt;b&lt;/code&gt; has to be a mutable location. Note: If it is not actually used for mutation, borrowing a mutable view from an immutable location is allowed! This allows for many important idioms and will be justified in an upcoming RFC.</source>
          <target state="translated">如果 &lt;code&gt;v&lt;/code&gt; 是可变的视图，并且 &lt;code&gt;v&lt;/code&gt; 用于实际改变借位的位置，则 &lt;code&gt;b&lt;/code&gt; 必须是可变的位置。注意：如果它实际上没有用于突变，则可以从不变的位置借用可变视图！这允许许多重要的习惯用法，并且在即将到来的RFC中将得到证明。</target>
        </trans-unit>
        <trans-unit id="dc0337394aba82feb2ce0b0ccc36cfd2aaf3cae7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is &lt;code&gt;low(x)&lt;/code&gt; (that is -MININT for its type), an overflow exception is thrown (if overflow checking is turned on).</source>
          <target state="translated">如果 &lt;code&gt;x&lt;/code&gt; 为 &lt;code&gt;low(x)&lt;/code&gt; （其类型为-MININT），则将引发溢出异常（如果打开了溢出检查）。</target>
        </trans-unit>
        <trans-unit id="143f147cfc005d34e5469684ef9d46067c58a942" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is empty, 0 is returned.</source>
          <target state="translated">如果 &lt;code&gt;x&lt;/code&gt; 为空，则返回0。</target>
        </trans-unit>
        <trans-unit id="085a0739df2fb9bb634f99ec2ebd9833415011c9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is empty, 1 is returned.</source>
          <target state="translated">如果 &lt;code&gt;x&lt;/code&gt; 为空，则返回1。</target>
        </trans-unit>
        <trans-unit id="3a2410e0f5521d539c525fb5bab4dfb899762d20" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;fromRoot&lt;/em&gt; is set, the traversal will start from the file system root diretory. If &lt;em&gt;inclusive&lt;/em&gt; is set, the original argument will be included in the traversal.</source>
          <target state="translated">如果设置了&lt;em&gt;fromRoot&lt;/em&gt;，则遍历将从文件系统根目录开始。如果设置了&lt;em&gt;inclusive&lt;/em&gt;，则遍历中将包含原始参数。</target>
        </trans-unit>
        <trans-unit id="199de5473c17b3499d89cf849af056dcb7ec2a21" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;leading&lt;/em&gt; is true, leading &lt;em&gt;chars&lt;/em&gt; are stripped. If &lt;em&gt;trailing&lt;/em&gt; is true, trailing &lt;em&gt;chars&lt;/em&gt; are stripped. If both are false, the string is returned unchanged.</source>
          <target state="translated">如果&lt;em&gt;前导&lt;/em&gt;为真，则剥离前导&lt;em&gt;字符&lt;/em&gt;。如果&lt;em&gt;尾随&lt;/em&gt;为真，则除去尾随的&lt;em&gt;字符&lt;/em&gt;。如果两者均为假，则字符串将保持不变。</target>
        </trans-unit>
        <trans-unit id="858dcc140fb894e0ab39988b41a394056e356424" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;linkTitle&lt;/em&gt; or &lt;em&gt;linkDesc&lt;/em&gt; are not the empty string, two additional columns with their contents will be added.</source>
          <target state="translated">如果&lt;em&gt;linkTitle&lt;/em&gt;或&lt;em&gt;linkDesc&lt;/em&gt;不是空字符串，则将添加两个附加列及其内容。</target>
        </trans-unit>
        <trans-unit id="4e866237eb46ef9c2e685eaa551676cfb806b047" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;n&lt;/em&gt; is &lt;em&gt;xnElement&lt;/em&gt;, runs recursively on each child node and concatenates the results.</source>
          <target state="translated">如果&lt;em&gt;n&lt;/em&gt;是&lt;em&gt;xnElement&lt;/em&gt;，则在每个子节点上递归运行并连接结果。</target>
        </trans-unit>
        <trans-unit id="fa2323ffef001ae4f50de61394ed2c4c06dd1eef" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;n&lt;/em&gt; is &lt;em&gt;xnText&lt;/em&gt; or &lt;em&gt;xnEntity&lt;/em&gt;, returns its content.</source>
          <target state="translated">如果&lt;em&gt;n&lt;/em&gt;是&lt;em&gt;xnText&lt;/em&gt;或&lt;em&gt;xnEntity&lt;/em&gt;，则返回其内容。</target>
        </trans-unit>
        <trans-unit id="6015dc5849733f7831bc335a048414718d188cdf" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;n&lt;/em&gt; is a &lt;em&gt;JArray&lt;/em&gt;, it returns the number of elements. If &lt;em&gt;n&lt;/em&gt; is a &lt;em&gt;JObject&lt;/em&gt;, it returns the number of pairs. Else it returns 0.</source>
          <target state="translated">如果&lt;em&gt;n&lt;/em&gt;是&lt;em&gt;JArray&lt;/em&gt;，则返回元素数。如果&lt;em&gt;n&lt;/em&gt;是&lt;em&gt;JObject&lt;/em&gt;，则返回对数。否则返回0。</target>
        </trans-unit>
        <trans-unit id="bd5549ec7eeae51a8cdef6008f85c363b39530b0" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;n&lt;/em&gt; is a &lt;em&gt;SList&lt;/em&gt;, it returns the number of elements. If &lt;em&gt;n&lt;/em&gt; is a &lt;em&gt;JObject&lt;/em&gt;, it returns the number of pairs. Else it returns 0.</source>
          <target state="translated">如果&lt;em&gt;n&lt;/em&gt;是&lt;em&gt;SList&lt;/em&gt;，则返回元素数。如果&lt;em&gt;n&lt;/em&gt;是&lt;em&gt;JObject&lt;/em&gt;，则返回对数。否则返回0。</target>
        </trans-unit>
        <trans-unit id="b5d453d0776be5e831bfbd8ed97503ad7f979cee" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;path&lt;/em&gt; has no extension, &lt;em&gt;ext&lt;/em&gt; is the empty string. If &lt;em&gt;path&lt;/em&gt; has no directory component, &lt;em&gt;dir&lt;/em&gt; is the empty string. If &lt;em&gt;path&lt;/em&gt; has no filename component, &lt;em&gt;name&lt;/em&gt; and &lt;em&gt;ext&lt;/em&gt; are empty strings.</source>
          <target state="translated">如果&lt;em&gt;path&lt;/em&gt;没有扩展名，则&lt;em&gt;ext&lt;/em&gt;是空字符串。如果&lt;em&gt;path&lt;/em&gt;没有目录组件，则&lt;em&gt;dir&lt;/em&gt;是空字符串。如果&lt;em&gt;path&lt;/em&gt;没有文件名部分，则&lt;em&gt;name&lt;/em&gt;和&lt;em&gt;ext&lt;/em&gt;为空字符串。</target>
        </trans-unit>
        <trans-unit id="80be0c8b8f0887f6f6256d7bd08befefadc198dd" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;places&lt;/em&gt; is 0 (or omitted), round to the nearest integral value following normal mathematical rounding rules (e.g. &lt;em&gt;round(54.5) -&amp;gt; 55.0&lt;/em&gt;). If &lt;em&gt;places&lt;/em&gt; is greater than 0, round to the given number of decimal places, e.g. &lt;em&gt;round(54.346, 2) -&amp;gt; 54.35&lt;/em&gt;. If &lt;em&gt;places&lt;/em&gt; is negative, round to the left of the decimal place, e.g. &lt;em&gt;round(537.345, -1) -&amp;gt; 540.0&lt;/em&gt;</source>
          <target state="translated">如果&lt;em&gt;place&lt;/em&gt;为0（或省略），则遵循正常的数学舍入规则将舍入到最接近的整数值（例如，&lt;em&gt;round（54.5）-&amp;gt; 55.0&lt;/em&gt;）。如果&lt;em&gt;位数&lt;/em&gt;大于0，则舍入到给定的小数位数，例如&lt;em&gt;round（54.346，2）-&amp;gt; 54.35&lt;/em&gt;。如果&lt;em&gt;places&lt;/em&gt;为负数，则四舍五入到小数点左边，例如，&lt;em&gt;round（537.345，-1）-&amp;gt; 540.0&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="85943ee873870ccb602997d1ba558ce262f536fb" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;s&lt;/em&gt; contains none of the characters in &lt;em&gt;chars&lt;/em&gt;, -1 is returned.</source>
          <target state="translated">如果&lt;em&gt;s不&lt;/em&gt;包含&lt;em&gt;chars&lt;/em&gt;中的任何&lt;em&gt;字符&lt;/em&gt;，则返回-1。</target>
        </trans-unit>
        <trans-unit id="918bef596764b0dd1abc0034e3aca9f099546dd6" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;s&lt;/em&gt; does not begin with &lt;code&gt;prefix&lt;/code&gt; and end with &lt;code&gt;suffix&lt;/code&gt; a ValueError exception will be raised.</source>
          <target state="translated">如果&lt;em&gt;s&lt;/em&gt;不以 &lt;code&gt;prefix&lt;/code&gt; 开头和以 &lt;code&gt;suffix&lt;/code&gt; 结尾，则将引发ValueError异常。</target>
        </trans-unit>
        <trans-unit id="ffecd98c556448bc07a363bac2464a9be3914393" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;s&lt;/em&gt; is not a valid binary integer, &lt;em&gt;ValueError&lt;/em&gt; is raised. &lt;em&gt;s&lt;/em&gt; can have one of the following optional prefixes: &lt;code&gt;0b&lt;/code&gt;, &lt;code&gt;0B&lt;/code&gt;. Underscores within &lt;em&gt;s&lt;/em&gt; are ignored.</source>
          <target state="translated">如果&lt;em&gt;s&lt;/em&gt;不是有效的二进制整数，则引发&lt;em&gt;ValueError&lt;/em&gt;。&lt;em&gt;s&lt;/em&gt;可以具有以下可选前缀之一： &lt;code&gt;0b&lt;/code&gt; ， &lt;code&gt;0B&lt;/code&gt; 。&lt;em&gt;s&lt;/em&gt;中的下划线将被忽略。</target>
        </trans-unit>
        <trans-unit id="22934de3f162a4b17792ea0eea7d5289abc794bc" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;s&lt;/em&gt; is not a valid hex integer, &lt;em&gt;ValueError&lt;/em&gt; is raised. &lt;em&gt;s&lt;/em&gt; can have one of the following optional prefixes: &lt;code&gt;0x&lt;/code&gt;, &lt;code&gt;0X&lt;/code&gt;, &lt;code&gt;#&lt;/code&gt;. Underscores within &lt;em&gt;s&lt;/em&gt; are ignored.</source>
          <target state="translated">如果&lt;em&gt;s&lt;/em&gt;不是有效的十六进制整数，则引发&lt;em&gt;ValueError&lt;/em&gt;。&lt;em&gt;s&lt;/em&gt;可以具有以下可选前缀之一： &lt;code&gt;0x&lt;/code&gt; ， &lt;code&gt;0X&lt;/code&gt; ， &lt;code&gt;#&lt;/code&gt; 。&lt;em&gt;s&lt;/em&gt;中的下划线将被忽略。</target>
        </trans-unit>
        <trans-unit id="31f1b5486de0d368adaea367eae29e732db7fbdf" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;s&lt;/em&gt; is not a valid integer, &lt;em&gt;ValueError&lt;/em&gt; is raised.</source>
          <target state="translated">如果&lt;em&gt;s&lt;/em&gt;不是有效的整数，则引发&lt;em&gt;ValueError&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="a06a939f49597f675f8bb03c0e2cb909dc45d17e" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;s&lt;/em&gt; is not a valid oct integer, &lt;em&gt;ValueError&lt;/em&gt; is raised. &lt;em&gt;s&lt;/em&gt; can have one of the following optional prefixes: &lt;code&gt;0o&lt;/code&gt;, &lt;code&gt;0O&lt;/code&gt;. Underscores within &lt;em&gt;s&lt;/em&gt; are ignored.</source>
          <target state="translated">如果&lt;em&gt;s&lt;/em&gt;不是有效的八进制整数，则引发&lt;em&gt;ValueError&lt;/em&gt;。&lt;em&gt;s&lt;/em&gt;可以具有以下可选前缀之一： &lt;code&gt;0o&lt;/code&gt; ， &lt;code&gt;0O&lt;/code&gt; 。&lt;em&gt;s&lt;/em&gt;中的下划线将被忽略。</target>
        </trans-unit>
        <trans-unit id="27d35434baea7af37a0b648eef07955006978983" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;siPrefix&lt;/em&gt; is set to true, the number will be displayed with the SI prefix corresponding to the exponent. For example 4100 will be displayed as &quot;4.1 k&quot; instead of &quot;4.1e3&quot;. Note that &lt;em&gt;u&lt;/em&gt; is used for micro- in place of the greek letter mu (&amp;mu;) as per ISO 2955. Numbers with an absolute value outside of the range 1e-18&amp;lt;f&amp;lt;1000e18 (1a&amp;lt;f&amp;lt;1000E) will be displayed with an exponent rather than an SI prefix, regardless of whether &lt;em&gt;siPrefix&lt;/em&gt; is true.</source>
          <target state="translated">如果&lt;em&gt;siPrefix&lt;/em&gt;设置为true，则将显示该数字以及与该指数对应的SI前缀。例如，4100将显示为&amp;ldquo; 4.1 k&amp;rdquo;而不是&amp;ldquo; 4.1e3&amp;rdquo;。请注意，&lt;em&gt;u&lt;/em&gt;用于代替ISO 2955的希腊字母mu（&amp;mu;）。绝对值超出1e-18 &amp;lt;f &amp;lt;1000e18（1a &amp;lt;f &amp;lt;1000E）范围的数字将显示为指数，而不是SI前缀，而不管&lt;em&gt;siPrefix&lt;/em&gt;是否为true。</target>
        </trans-unit>
        <trans-unit id="3c153378df49ceb0514b8f9591a7fe13753328b6" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;spread&lt;/em&gt; is false and the length of &lt;em&gt;s&lt;/em&gt; is not a multiple of &lt;em&gt;num&lt;/em&gt;, the proc will max out the first sub sequences with &lt;code&gt;1 + len(s) div num&lt;/code&gt; entries, leaving the remainder of elements to the last sequence.</source>
          <target state="translated">如果&lt;em&gt;spread&lt;/em&gt;为false并且&lt;em&gt;s&lt;/em&gt;的长度不是&lt;em&gt;num&lt;/em&gt;的倍数，则proc将使用 &lt;code&gt;1 + len(s) div num&lt;/code&gt; 个条目最大化第一个子序列，而其余​​元素保留到最后一个序列。</target>
        </trans-unit>
        <trans-unit id="4775826ae44f8348308b950ee7f0228f3079a862" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;trim&lt;/em&gt; is set to true, trailing zeros will be removed; if false, the number of digits specified by &lt;em&gt;precision&lt;/em&gt; will always be shown.</source>
          <target state="translated">如果&lt;em&gt;trim&lt;/em&gt;设置为true，则尾随零将被删除；如果为false，则始终显示由&lt;em&gt;precision&lt;/em&gt;指定的位数。</target>
        </trans-unit>
        <trans-unit id="6a3df1de57df75f3d46e50b0da67618c0e39c016" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;useUnitSpace&lt;/em&gt; is true, the provided unit will be appended to the string (with a space as required by the SI standard). This behaviour is slightly different to appending the unit to the result as the location of the space is altered depending on whether there is an exponent.</source>
          <target state="translated">如果&lt;em&gt;useUnitSpace&lt;/em&gt;为true，则将提供的单位追加到字符串（SI标准要求的空格）。这种行为与将单位附加到结果上略有不同，因为根据是否存在指数而改变了空间的位置。</target>
        </trans-unit>
        <trans-unit id="e5a02da3e38654c4cf49cce80161e467b81e4e01" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;$&lt;/code&gt; operator for a concrete enumeration is provided, this is used instead. (In other words: &lt;em&gt;Overwriting&lt;/em&gt; is possible.)</source>
          <target state="translated">如果提供 &lt;code&gt;$&lt;/code&gt; 用于具体枚举的$运算符，则使用$运算符。（换句话说：可能会&lt;em&gt;覆盖&lt;/em&gt;。）</target>
        </trans-unit>
        <trans-unit id="0c624e82a301cd1b0a01c9e7e8780b498a5b18ce" translate="yes" xml:space="preserve">
          <source>If a declared symbol is marked with an &lt;span id=&quot;asterisk_1&quot;&gt;asterisk&lt;/span&gt; it is exported from the current module:</source>
          <target state="translated">如果已声明的符号带有&lt;span id=&quot;asterisk_1&quot;&gt;星号&lt;/span&gt;，则会从当前模块中将其导出：</target>
        </trans-unit>
        <trans-unit id="81ed4de47fdface2b8f48e90c1cc15890ee94e16" translate="yes" xml:space="preserve">
          <source>If a different format string is preferred, refer to the &lt;a href=&quot;#basic-usage-format-strings&quot;&gt;documentation about format strings&lt;/a&gt; for more information, including a list of available variables.</source>
          <target state="translated">如果首选其他格式字符串，请参阅&lt;a href=&quot;#basic-usage-format-strings&quot;&gt;有关格式字符串&lt;/a&gt;的文档以获取更多信息，包括可用变量列表。</target>
        </trans-unit>
        <trans-unit id="10f356aa84e307221ea1ddc951ea76e3235c5f18" translate="yes" xml:space="preserve">
          <source>If a full line has been retrieved; &lt;code&gt;ReadFullLine&lt;/code&gt; is returned.</source>
          <target state="translated">如果已检索整行；返回 &lt;code&gt;ReadFullLine&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f6e2de7dd3af4670ee12c88866b53b3fc6104073" translate="yes" xml:space="preserve">
          <source>If a full line has been retrieved; &lt;code&gt;RecvFullLine&lt;/code&gt; is returned.</source>
          <target state="translated">如果已检索整行； &lt;code&gt;RecvFullLine&lt;/code&gt; 返回。</target>
        </trans-unit>
        <trans-unit id="7d4edfbe8476a0a7a39ffd09f45852fb65cecbf1" translate="yes" xml:space="preserve">
          <source>If a full line is read &lt;code&gt;\r\L&lt;/code&gt; is not added to &lt;code&gt;line&lt;/code&gt;, however if solely &lt;code&gt;\r\L&lt;/code&gt; is read then &lt;code&gt;line&lt;/code&gt; will be set to it.</source>
          <target state="translated">如果读取了整行 &lt;code&gt;\r\L&lt;/code&gt; 不会添加到 &lt;code&gt;line&lt;/code&gt; ，但是如果仅读取 &lt;code&gt;\r\L&lt;/code&gt; ，则将 &lt;code&gt;line&lt;/code&gt; 设置为它。</target>
        </trans-unit>
        <trans-unit id="c16eab689c4842392a5a11dd1c091bb5c2263373" translate="yes" xml:space="preserve">
          <source>If a full line is read &lt;code&gt;\r\L&lt;/code&gt; is not added to the result, however if solely &lt;code&gt;\r\L&lt;/code&gt; is read then the result will be set to it.</source>
          <target state="translated">如果读取了整行，则不会将 &lt;code&gt;\r\L&lt;/code&gt; 添加到结果中，但是如果仅读取 &lt;code&gt;\r\L&lt;/code&gt; ，则将结果设置为该行。</target>
        </trans-unit>
        <trans-unit id="2e37450d6f575130f1da8f99af9d57374a8a5ea4" translate="yes" xml:space="preserve">
          <source>If a full line is received &lt;code&gt;\r\L&lt;/code&gt; is not added to &lt;code&gt;line&lt;/code&gt;, however if solely &lt;code&gt;\r\L&lt;/code&gt; is received then &lt;code&gt;line&lt;/code&gt; will be set to it.</source>
          <target state="translated">如果收到的全系列 &lt;code&gt;\r\L&lt;/code&gt; 未添加到 &lt;code&gt;line&lt;/code&gt; ，但是如果仅仅 &lt;code&gt;\r\L&lt;/code&gt; 收到然后 &lt;code&gt;line&lt;/code&gt; 将被设置为它。</target>
        </trans-unit>
        <trans-unit id="3ff59a2ff29be49ab647243344f65b1dcbfc2729" translate="yes" xml:space="preserve">
          <source>If a keyword is enclosed in backticks it loses its keyword property and becomes an ordinary identifier.</source>
          <target state="translated">如果一个关键字用反标号括起来,它就会失去关键字的属性,变成一个普通的标识符。</target>
        </trans-unit>
        <trans-unit id="4578160882d9270d9e934109afdfbf00113bc1cc" translate="yes" xml:space="preserve">
          <source>If a line starts with &lt;code&gt;#&lt;/code&gt; it will be ignored completely, so you can use that for comments.</source>
          <target state="translated">如果一行以 &lt;code&gt;#&lt;/code&gt; 开头，它将被完全忽略，因此您可以将其用作注释。</target>
        </trans-unit>
        <trans-unit id="986bd59d4565e747bd03d3184e193b50ce47993b" translate="yes" xml:space="preserve">
          <source>If a module gets recompiled, its dependencies need to be updated.</source>
          <target state="translated">如果一个模块被重新编译,它的依赖关系就需要更新。</target>
        </trans-unit>
        <trans-unit id="ae96445a1d8c8a917cd65647c489a45beaae265d" translate="yes" xml:space="preserve">
          <source>If a module imports an identifier by two different modules, each occurrence of the identifier has to be qualified unless it is an overloaded procedure or iterator in which case the overloading resolution takes place:</source>
          <target state="translated">如果一个模块由两个不同的模块导入一个标识符,标识符的每一次出现都必须被限定,除非它是一个重载的过程或迭代器,在这种情况下,重载的解决就会发生。</target>
        </trans-unit>
        <trans-unit id="9bc3730afa8c59c97647c426e37011adafd8a176" translate="yes" xml:space="preserve">
          <source>If a module imports an identifier by two different modules, each occurrence of the identifier has to be qualified, unless it is an overloaded procedure or iterator in which case the overloading resolution takes place:</source>
          <target state="translated">如果一个模块由两个不同的模块导入一个标识符,标识符的每一次出现都要进行限定,除非它是一个重载的过程或迭代器,在这种情况下,就会发生重载解析。</target>
        </trans-unit>
        <trans-unit id="efe916c21117e3859222aca055e9bea6cec4eac2" translate="yes" xml:space="preserve">
          <source>If a node is used in a different document than the one that created it (that doesn't support it)</source>
          <target state="translated">如果一个节点被用在与创建它的文档不同的文档中(该文档不支持它</target>
        </trans-unit>
        <trans-unit id="871e2115f882350e714e39955d71707aaebf9ba5" translate="yes" xml:space="preserve">
          <source>If a parameter or an operation is not supported by the underlying object.</source>
          <target state="translated">如果一个参数或一个操作不被底层对象支持。</target>
        </trans-unit>
        <trans-unit id="3086cb848c98b3dd77a110e77a2de136bf838978" translate="yes" xml:space="preserve">
          <source>If a proc is annotated with the &lt;code&gt;noinit&lt;/code&gt; pragma this refers to its implicit &lt;code&gt;result&lt;/code&gt; variable:</source>
          <target state="translated">如果proc带有 &lt;code&gt;noinit&lt;/code&gt; 注释，则引用其隐式 &lt;code&gt;result&lt;/code&gt; 变量：</target>
        </trans-unit>
        <trans-unit id="056e8beb820913d3d337f02913145eef09e66318" translate="yes" xml:space="preserve">
          <source>If a reference points to &lt;em&gt;nothing&lt;/em&gt;, it has the value &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">如果引用&lt;em&gt;没有&lt;/em&gt;指向&lt;em&gt;任何内容&lt;/em&gt;，则其值为 &lt;code&gt;nil&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7ac6b457358fbbcc06da0a6ca011f44a7007dfb9" translate="yes" xml:space="preserve">
          <source>If a reference points to &lt;em&gt;nothing&lt;/em&gt;, it has the value &lt;code&gt;nil&lt;/code&gt;. &lt;code&gt;nil&lt;/code&gt; is the default value for all &lt;code&gt;ref&lt;/code&gt; and &lt;code&gt;ptr&lt;/code&gt; types. The &lt;code&gt;nil&lt;/code&gt; value can also be used like any other literal value. For example, it can be used in an assignment like &lt;code&gt;myRef = nil&lt;/code&gt;.</source>
          <target state="translated">如果引用&lt;em&gt;没有&lt;/em&gt;指向&lt;em&gt;任何内容&lt;/em&gt;，则其值为 &lt;code&gt;nil&lt;/code&gt; 。 &lt;code&gt;nil&lt;/code&gt; 是所有 &lt;code&gt;ref&lt;/code&gt; 和 &lt;code&gt;ptr&lt;/code&gt; 类型的默认值。该 &lt;code&gt;nil&lt;/code&gt; 值也可以使用像任何其他文字值。例如，可以将其用于 &lt;code&gt;myRef = nil&lt;/code&gt; 类的赋值中。</target>
        </trans-unit>
        <trans-unit id="50ad2206a1169aba9bd7c1b09f9fb0941ea61337" translate="yes" xml:space="preserve">
          <source>If a section of code holds a lock of level &lt;code&gt;M&lt;/code&gt; than it can also acquire any lock of level &lt;code&gt;N &amp;lt; M&lt;/code&gt;. Another lock of level &lt;code&gt;M&lt;/code&gt; cannot be acquired. Locks of the same level can only be acquired &lt;em&gt;at the same time&lt;/em&gt; within a single &lt;code&gt;locks&lt;/code&gt; section:</source>
          <target state="translated">如果一段代码持有 &lt;code&gt;M&lt;/code&gt; 级锁，那么它也可以获得 &lt;code&gt;N &amp;lt; M&lt;/code&gt; 级的任何锁。无法获取另一个级别 &lt;code&gt;M&lt;/code&gt; 的锁。只能在单个 &lt;code&gt;locks&lt;/code&gt; 节中&lt;em&gt;同时&lt;/em&gt;获取相同级别的锁：</target>
        </trans-unit>
        <trans-unit id="f883af41470e39046741ce71193805e04a0fb408" translate="yes" xml:space="preserve">
          <source>If a structured type features a field with destructable type and the user has not provided an explicit implementation, a destructor for the structured type will be automatically generated. Calls to any base class destructors in both user-defined and generated destructors will be inserted.</source>
          <target state="translated">如果一个结构化类型具有一个可反构类型的字段,而用户没有提供一个明确的实现,那么该结构化类型的反构函数将被自动生成。在用户定义的和生成的析构器中,都会插入对基类析构器的调用。</target>
        </trans-unit>
        <trans-unit id="0db08f2b2e98ccda7902cf1898e764d8c7f5e868" translate="yes" xml:space="preserve">
          <source>If a type section uses generic parameters, they are treated here:</source>
          <target state="translated">如果一个类型部分使用了通用参数,则在这里进行处理。</target>
        </trans-unit>
        <trans-unit id="134dbfacce2b9cb40bf6b486318d4214197c545b" translate="yes" xml:space="preserve">
          <source>If a view type is used as a return type, the location must borrow from a location that is derived from the first parameter that is passed to the proc. See &lt;a href=&quot;manual#procedures-var-return-type&quot;&gt;https://nim-lang.org/docs/manual.html#procedures-var-return-type&lt;/a&gt; for details about how this is done for &lt;code&gt;var T&lt;/code&gt;.</source>
          <target state="translated">如果将视图类型用作返回类型，则该位置必须从从传递给proc的第一个参数派生的位置借用。有关如何针对 &lt;code&gt;var T&lt;/code&gt; 完成此操作的详细信息，请参见&lt;a href=&quot;manual#procedures-var-return-type&quot;&gt;https://nim-lang.org/docs/manual.html#procedures-var-return-type&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="de9d3f35f669e256aa6c736e6a1afde344da10ae" translate="yes" xml:space="preserve">
          <source>If an assertion in Nim's memory manager or GC fails, the stack trace keeps allocating memory! Thus a stack overflow may happen, hiding the real issue.</source>
          <target state="translated">如果在Nim的内存管理器或GC中的断言失败,堆栈跟踪就会一直分配内存! 因此,堆栈溢出可能会发生,隐藏了真正的问题。</target>
        </trans-unit>
        <trans-unit id="995c8ccff46b0b1f2916c13247fc81cbf289033e" translate="yes" xml:space="preserve">
          <source>If an attempt is made to add an attribute that is already in use elsewhere</source>
          <target state="translated">如果试图添加一个已在其他地方使用的属性</target>
        </trans-unit>
        <trans-unit id="a1629656009e8137e699c56c52cd43983c5570b7" translate="yes" xml:space="preserve">
          <source>If an attempt is made to create or change an object in a way which is incorrect with regard to namespaces.</source>
          <target state="translated">如果试图以不正确的命名空间方式创建或更改对象。</target>
        </trans-unit>
        <trans-unit id="7d19aea11801948c78474316888135ae6018e7ae" translate="yes" xml:space="preserve">
          <source>If an attempt is made to modify an object where modifications are not allowed</source>
          <target state="translated">如果试图在不允许修改的地方修改一个对象</target>
        </trans-unit>
        <trans-unit id="19d41b1964221f77e17c0e94a5badbf64e32ab22" translate="yes" xml:space="preserve">
          <source>If an attempt is made to modify the type of the underlying object.</source>
          <target state="translated">如果试图修改基础对象的类型。</target>
        </trans-unit>
        <trans-unit id="c2268feb0b92960c8ac6e11b1ff1a253a519fe84" translate="yes" xml:space="preserve">
          <source>If an attempt is made to reference a node in a context where it does not exist</source>
          <target state="translated">如果尝试在一个不存在的上下文中引用一个节点</target>
        </trans-unit>
        <trans-unit id="95f550c8bb30a788e989fe605398e29ff476452c" translate="yes" xml:space="preserve">
          <source>If an attempt is made to use an object that is not, or is no longer, usable.</source>
          <target state="translated">如果试图使用一个不可用或不再可用的对象;</target>
        </trans-unit>
        <trans-unit id="4a5a5458cfa721632e1a44b5d3d63641a792b115" translate="yes" xml:space="preserve">
          <source>If an awaited future completes with an error, then &lt;code&gt;await&lt;/code&gt; will re-raise this error. To avoid this, you can use the &lt;code&gt;yield&lt;/code&gt; keyword instead of &lt;code&gt;await&lt;/code&gt;. The following section shows different ways that you can handle exceptions in async procs.</source>
          <target state="translated">如果等待的将来以错误完成，则 &lt;code&gt;await&lt;/code&gt; 将重新引发此错误。为了避免这种情况，可以使用 &lt;code&gt;yield&lt;/code&gt; 关键字代替 &lt;code&gt;await&lt;/code&gt; 。下一节将介绍在异步处理中处理异常的不同方法。</target>
        </trans-unit>
        <trans-unit id="9cfe3c7dc34bbfcf5eaa53fe4a526fe2fa04f7a3" translate="yes" xml:space="preserve">
          <source>If an error occurs EOS will be raised.</source>
          <target state="translated">如果发生错误,EOS将被提出。</target>
        </trans-unit>
        <trans-unit id="c762cc02f8bd2fcadfc73b70486affd574b2c259" translate="yes" xml:space="preserve">
          <source>If an error occurs OSError will be raised.</source>
          <target state="translated">如果发生错误,将引发OSError。</target>
        </trans-unit>
        <trans-unit id="20075c8048a0853ffcb0c572ffb4edf2ab4dea98" translate="yes" xml:space="preserve">
          <source>If an error occurs an EOS exception will be raised. Otherwise the return value will be the length of data received.</source>
          <target state="translated">如果发生错误,将引发一个EOS异常。否则返回值将是接收到的数据长度。</target>
        </trans-unit>
        <trans-unit id="ee9dd9a88b7a108b3b5ddebf055242224e607202" translate="yes" xml:space="preserve">
          <source>If an error occurs an OSError exception will be raised.</source>
          <target state="translated">如果发生错误,将引发OSError异常。</target>
        </trans-unit>
        <trans-unit id="19f4f485cf59bf83ace5ba68ed775166e6202e97" translate="yes" xml:space="preserve">
          <source>If an error occurs an OSError exception will be raised. Otherwise the return value will be the length of data received.</source>
          <target state="translated">如果发生错误,将引发一个OSError异常。否则返回值将是接收到的数据长度。</target>
        </trans-unit>
        <trans-unit id="9df3e94f40e9f0642b83425fe8366b3839215739" translate="yes" xml:space="preserve">
          <source>If an error occurs the return value will be &lt;code&gt;-1&lt;/code&gt;. Otherwise the return value will be the length of data received.</source>
          <target state="translated">如果发生错误，则返回值为 &lt;code&gt;-1&lt;/code&gt; 。否则，返回值将是接收到的数据的长度。</target>
        </trans-unit>
        <trans-unit id="65934c6d6036cdaf55bf0800e92c5afaa296761f" translate="yes" xml:space="preserve">
          <source>If an even number of backslashes is followed by a double quotation mark, one backslash is placed in the argv array for every pair of backslashes, and the double quotation mark is interpreted as a string delimiter.</source>
          <target state="translated">如果偶数的反斜杠后面有双引号,那么每一对反斜杠就会在argv数组中放置一个反斜杠,双引号被解释为字符串定界符。</target>
        </trans-unit>
        <trans-unit id="5a8eb863c9933042fa8b79fabcb3a546485426d6" translate="yes" xml:space="preserve">
          <source>If an index is left out, &lt;code&gt;succ(lastIndex)&lt;/code&gt; is used as the index value:</source>
          <target state="translated">如果省略索引，则将 &lt;code&gt;succ(lastIndex)&lt;/code&gt; 用作索引值：</target>
        </trans-unit>
        <trans-unit id="7464323e44d0ae19ebeba4498e456ca8adf8480b" translate="yes" xml:space="preserve">
          <source>If an initializer is given the type can be omitted: the variable is then of the same type as the initializing expression. Variables are always initialized with a default value if there is no initializing expression. The default value depends on the type and is always a zero in binary.</source>
          <target state="translated">如果给定了初始化器,可以省略类型:那么变量的类型与初始化表达式相同。如果没有初始化表达式,变量总是用默认值初始化。默认值取决于类型,在二进制中总是一个零。</target>
        </trans-unit>
        <trans-unit id="523ee71c788d6ee708d4f30befc0a7f2aeb4aadc" translate="yes" xml:space="preserve">
          <source>If an invalid or illegal string is specified.</source>
          <target state="translated">如果指定了一个无效或非法的字符串。</target>
        </trans-unit>
        <trans-unit id="c16639803ee1e2193f59691f27a0a66926df18ac" translate="yes" xml:space="preserve">
          <source>If an invalid range is passed, it raises IndexDefect.</source>
          <target state="translated">如果传递了一个无效的范围,它会引发IndexDefect。</target>
        </trans-unit>
        <trans-unit id="31248330f03fa20f9122a001da3f7a4b63664cf0" translate="yes" xml:space="preserve">
          <source>If an odd number of backslashes is followed by a double quotation mark, one backslash is placed in the argv array for every pair of backslashes, and the double quotation mark is &quot;escaped&quot; by the remaining backslash, causing a literal double quotation mark (&quot;) to be placed in argv.</source>
          <target state="translated">如果奇数的反斜杠后面是双引号,那么每一对反斜杠在argv数组中放置一个反斜杠,双引号被剩下的反斜杠 &quot;转义&quot;,导致一个字面的双引号(&quot;)被放置在argv中。</target>
        </trans-unit>
        <trans-unit id="ac9b41083a3085bc3f11ff622b38e4fe8c4f414b" translate="yes" xml:space="preserve">
          <source>If an optional argument is present the following lookup algorithm is used:</source>
          <target state="translated">如果存在一个可选参数,则使用以下查找算法。</target>
        </trans-unit>
        <trans-unit id="a9811584c6a21ee0c14d6db331e13ba352d14ad0" translate="yes" xml:space="preserve">
          <source>If an unary operator's first character is &lt;code&gt;@&lt;/code&gt; it is a &lt;span id=&quot;sigilminuslike_1&quot;&gt;sigil-like&lt;/span&gt; operator which binds stronger than a &lt;code&gt;primarySuffix&lt;/code&gt;: &lt;code&gt;@x.abc&lt;/code&gt; is parsed as &lt;code&gt;(@x).abc&lt;/code&gt; whereas &lt;code&gt;$x.abc&lt;/code&gt; is parsed as &lt;code&gt;$(x.abc)&lt;/code&gt;.</source>
          <target state="translated">如果一元运算符的第一个字符是 &lt;code&gt;@&lt;/code&gt; ，则它是&lt;span id=&quot;sigilminuslike_1&quot;&gt;类似于sigil的&lt;/span&gt;运算符，其绑定强度大于 &lt;code&gt;primarySuffix&lt;/code&gt; ： &lt;code&gt;@x.abc&lt;/code&gt; 解析为 &lt;code&gt;(@x).abc&lt;/code&gt; &lt;code&gt;$x.abc&lt;/code&gt; ）.abc，而$ x.abc解析为 &lt;code&gt;$(x.abc)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fd6f49d0dfcf12fec7bb99768e6a680d44371f26" translate="yes" xml:space="preserve">
          <source>If any node is inserted somewhere it doesn't belong</source>
          <target state="translated">如果有任何节点被插入了不属于它的地方。</target>
        </trans-unit>
        <trans-unit id="7a913709639c29598ea85076fb70279d360292bd" translate="yes" xml:space="preserve">
          <source>If assertions are turned off, it does nothing. If assertions are turned on, later versions will check the string for valid syntax.</source>
          <target state="translated">如果断言被关闭,它什么都不做。如果开启了断言,以后的版本会检查字符串的有效语法。</target>
        </trans-unit>
        <trans-unit id="74b5d1a57a127216acbfd875469a1f6d6875a284" translate="yes" xml:space="preserve">
          <source>If async dispatcher is not running, &lt;code&gt;cbproc&lt;/code&gt; will be executed immediately.</source>
          <target state="translated">如果异步调度程序未运行，则 &lt;code&gt;cbproc&lt;/code&gt; 将立即执行。</target>
        </trans-unit>
        <trans-unit id="7eaacc538f76088f4558f36cb9f8907f19b9ce21" translate="yes" xml:space="preserve">
          <source>If async dispatcher is running, &lt;code&gt;cbproc&lt;/code&gt; will be executed during next dispatcher tick.</source>
          <target state="translated">如果异步调度程序正在运行，则 &lt;code&gt;cbproc&lt;/code&gt; 将在下一个调度程序滴答期间执行。</target>
        </trans-unit>
        <trans-unit id="7324648ec3da0700c798c83a7252c4467f507aa2" translate="yes" xml:space="preserve">
          <source>If call to &lt;code&gt;recv&lt;/code&gt; failed; &lt;code&gt;RecvFail&lt;/code&gt; is returned.</source>
          <target state="translated">如果调用 &lt;code&gt;recv&lt;/code&gt; 失败； &lt;code&gt;RecvFail&lt;/code&gt; 返回。</target>
        </trans-unit>
        <trans-unit id="71f6a401dad3e06dd5b3b05ed44e34fcc7b8ef06" translate="yes" xml:space="preserve">
          <source>If call to &lt;code&gt;recv&lt;/code&gt; failed; &lt;strong&gt;an EOS exception is raised.&lt;/strong&gt;</source>
          <target state="translated">如果调用 &lt;code&gt;recv&lt;/code&gt; 失败；&lt;strong&gt;引发EOS异常。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="369d3d999df1754a083b5c2ca0a01d76e66b2ff7" translate="yes" xml:space="preserve">
          <source>If conversion fails, or &lt;code&gt;errorCode&lt;/code&gt; is &lt;code&gt;0&lt;/code&gt; then &lt;code&gt;&quot;&quot;&lt;/code&gt; will be returned.</source>
          <target state="translated">如果转换失败，或者 &lt;code&gt;errorCode&lt;/code&gt; 为 &lt;code&gt;0&lt;/code&gt; ,则将返回 &lt;code&gt;&quot;&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="caa867aef2e9b590f00e0b0045de459f37c6f8f5" translate="yes" xml:space="preserve">
          <source>If data is specified for a node which does not support data</source>
          <target state="translated">如果为一个不支持数据的节点指定了数据</target>
        </trans-unit>
        <trans-unit id="66ac0ed79e6f3d38e5881a7e4d06e7dc26cae509" translate="yes" xml:space="preserve">
          <source>If environment variable &lt;code&gt;XDG_CONFIG_HOME&lt;/code&gt; is defined, &lt;code&gt;$XDG_CONFIG_HOME/nim/config.nims&lt;/code&gt; or &lt;code&gt;~/.config/nim/config.nims&lt;/code&gt; (POSIX) or &lt;code&gt;%APPDATA%/nim/config.nims&lt;/code&gt; (Windows). This file can be skipped with the &lt;code&gt;--skipUserCfg&lt;/code&gt; command line option.</source>
          <target state="translated">如果定义了环境变量 &lt;code&gt;XDG_CONFIG_HOME&lt;/code&gt; ，则 &lt;code&gt;$XDG_CONFIG_HOME/nim/config.nims&lt;/code&gt; 或 &lt;code&gt;~/.config/nim/config.nims&lt;/code&gt; （POSIX）或 &lt;code&gt;%APPDATA%/nim/config.nims&lt;/code&gt; （Windows）。可以使用 &lt;code&gt;--skipUserCfg&lt;/code&gt; 命令行选项跳过此文件。</target>
        </trans-unit>
        <trans-unit id="e824895cdb4cef64be7375ea8413a63a868d2ccc" translate="yes" xml:space="preserve">
          <source>If environment variable &lt;code&gt;XDG_CONFIG_HOME&lt;/code&gt; is defined, &lt;code&gt;$XDG_CONFIG_HOME/nim/nim.cfg&lt;/code&gt; or &lt;code&gt;~/.config/nim/nim.cfg&lt;/code&gt; (POSIX) or &lt;code&gt;%APPDATA%/nim/nim.cfg&lt;/code&gt; (Windows). This file can be skipped with the &lt;code&gt;--skipUserCfg&lt;/code&gt; command line option.</source>
          <target state="translated">如果定义了环境变量 &lt;code&gt;XDG_CONFIG_HOME&lt;/code&gt; ，则 &lt;code&gt;$XDG_CONFIG_HOME/nim/nim.cfg&lt;/code&gt; 或 &lt;code&gt;~/.config/nim/nim.cfg&lt;/code&gt; （POSIX）或 &lt;code&gt;%APPDATA%/nim/nim.cfg&lt;/code&gt; （Windows）。可以使用 &lt;code&gt;--skipUserCfg&lt;/code&gt; 命令行选项跳过此文件。</target>
        </trans-unit>
        <trans-unit id="20ac8fdf916d130ad74ee2dd25e10ce69bd5ec18" translate="yes" xml:space="preserve">
          <source>If expression</source>
          <target state="translated">如果表达式</target>
        </trans-unit>
        <trans-unit id="69dbcb321d20b0e49d118ee95433af7f3dbbbc3b" translate="yes" xml:space="preserve">
          <source>If future has already completed then &lt;code&gt;cb&lt;/code&gt; will be called immediately.</source>
          <target state="translated">如果将来已经完成，那么 &lt;code&gt;cb&lt;/code&gt; 将立即被调用。</target>
        </trans-unit>
        <trans-unit id="d41b28de410ec7385af014da7c0540575e3aaaaf" translate="yes" xml:space="preserve">
          <source>If head is the empty string, tail is returned. If tail is the empty string, head is returned with a trailing path separator. If tail starts with a path separator it will be removed when concatenated to head. Other path separators not located on boundaries won't be modified. More examples on Unix:</source>
          <target state="translated">如果head是空字符串,则返回尾部。如果tail是空字符串,则返回带有尾部路径分隔符的head。如果尾巴以路径分隔符开始,那么它将在连接到head时被移除。其他不在边界上的路径分隔符不会被修改。更多关于Unix的例子。</target>
        </trans-unit>
        <trans-unit id="7ed9d728cd6081bbf88a148e476d401db74961e1" translate="yes" xml:space="preserve">
          <source>If in the above example module &lt;code&gt;B&lt;/code&gt; is re-compiled, but &lt;code&gt;A&lt;/code&gt; is not then &lt;code&gt;B&lt;/code&gt; needs to be aware of &lt;code&gt;toBool&lt;/code&gt; even though &lt;code&gt;toBool&lt;/code&gt; is not referenced in &lt;code&gt;B&lt;/code&gt;&lt;em&gt;explicitly&lt;/em&gt;.</source>
          <target state="translated">如果在上面的例子模块 &lt;code&gt;B&lt;/code&gt; 是重新编译，但 &lt;code&gt;A&lt;/code&gt; 不那么 &lt;code&gt;B&lt;/code&gt; 需要注意的 &lt;code&gt;toBool&lt;/code&gt; 即使 &lt;code&gt;toBool&lt;/code&gt; 不中引用 &lt;code&gt;B&lt;/code&gt; &lt;em&gt;明确&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="f6d860796a5fd822923ee9652b94bac30474c3be" translate="yes" xml:space="preserve">
          <source>If index or size is negative, or greater than the allowed value</source>
          <target state="translated">如果指数或大小为负值,或者大于允许值</target>
        </trans-unit>
        <trans-unit id="06026b50e58de38d4a7da3787b3fc38c6088b7a8" translate="yes" xml:space="preserve">
          <source>If it fails, it returns &lt;code&gt;(false, default(msg))&lt;/code&gt; otherwise it returns &lt;code&gt;(true, msg)&lt;/code&gt;.</source>
          <target state="translated">如果失败，则返回 &lt;code&gt;(false, default(msg))&lt;/code&gt; 否则返回 &lt;code&gt;(true, msg)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c10462bf6533225f5f95a1f66cfe794cb8815ac6" translate="yes" xml:space="preserve">
          <source>If it returns &lt;code&gt;true&lt;/code&gt;, a &lt;code&gt;spawn&lt;/code&gt; may make sense. In general it is not necessary to call this directly; use &lt;a href=&quot;#spawnX.t&quot;&gt;spawnX template&lt;/a&gt; instead.</source>
          <target state="translated">如果返回 &lt;code&gt;true&lt;/code&gt; ，则可能会产生一个 &lt;code&gt;spawn&lt;/code&gt; 。通常，没有必要直接调用此方法。请改用&lt;a href=&quot;#spawnX.t&quot;&gt;spawnX模板&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8fb76ca4868b2e0aca87e97961ca0eea2622d4bb" translate="yes" xml:space="preserve">
          <source>If many threads will generate random numbers concurrently, it is better to create a single Rand state and pass it to each thread. After passing the Rand state to a thread, call this proc before passing it to the next one. By using the Rand state this way, the subsequences of random numbers generated in each thread will never overlap as long as no thread generates more than 2^64 random numbers.</source>
          <target state="translated">如果很多线程会同时产生随机数,最好创建一个单一的Rand状态,并将其传递给每个线程。将Rand状态传递给一个线程后,在将其传递给下一个线程之前调用这个proc。通过这样使用Rand状态,只要没有一个线程生成的随机数超过2^64个,那么每个线程中生成的随机数的子序列就不会重叠。</target>
        </trans-unit>
        <trans-unit id="e39e35b0fbc867536af0e669f2cd71c2245083f7" translate="yes" xml:space="preserve">
          <source>If more items are expected to be added, simply add that expected extra amount to the parameter before calling this.</source>
          <target state="translated">如果预计将增加更多的项目,只需在调用此函数之前将预计的额外数量添加到参数中即可。</target>
        </trans-unit>
        <trans-unit id="053100f3c7f667ff05d2bace27aa288dee22ba26" translate="yes" xml:space="preserve">
          <source>If more precise control is needed, the apostrophe &lt;code&gt;'&lt;/code&gt; can be used in the supplied pattern to denote the concrete type parameters of the generic type. See the usage of the apostrophe operator in proc patterns for more details.</source>
          <target state="translated">如果需要更精确的控制，可以在提供的模式中使用撇号 &lt;code&gt;'&lt;/code&gt; 来表示通用类型的具体类型参数。有关更多详细信息，请参见proc模式中的撇号运算符的用法。</target>
        </trans-unit>
        <trans-unit id="ce96d5e60286391515a7cbb0c79e9c3bb3e9d383" translate="yes" xml:space="preserve">
          <source>If nimcache already contains compiled code from a different compiler for the same project, add the &lt;code&gt;-f&lt;/code&gt; flag to force all files to be recompiled.</source>
          <target state="translated">如果nimcache已经包含来自同一项目的不同编译器的编译代码，请添加 &lt;code&gt;-f&lt;/code&gt; 标志以强制重新编译所有文件。</target>
        </trans-unit>
        <trans-unit id="5153d6410770a93b318a519a75636621e9c4c3aa" translate="yes" xml:space="preserve">
          <source>If no data could be retrieved; &lt;code&gt;ReadNone&lt;/code&gt; is returned.</source>
          <target state="translated">如果无法检索到数据； &lt;code&gt;ReadNone&lt;/code&gt; 返回。</target>
        </trans-unit>
        <trans-unit id="62072ffbfb683070d4fe0e0d3ee2dfe7022a3652" translate="yes" xml:space="preserve">
          <source>If no exception name is given, the current exception is &lt;span id=&quot;reminusraised_1&quot;&gt;re-raised&lt;/span&gt;. The &lt;span id=&quot;reraisedefect_1&quot;&gt;ReraiseDefect&lt;/span&gt; exception is raised if there is no exception to re-raise. It follows that the &lt;code&gt;raise&lt;/code&gt; statement &lt;em&gt;always&lt;/em&gt; raises an exception.</source>
          <target state="translated">如果没有给出异常名称，则&lt;span id=&quot;reminusraised_1&quot;&gt;重新引发&lt;/span&gt;当前异常。该&lt;span id=&quot;reraisedefect_1&quot;&gt;ReraiseDefect&lt;/span&gt;如果没有例外的再次加注异常。因此， &lt;code&gt;raise&lt;/code&gt; 语句&lt;em&gt;始终&lt;/em&gt;会引发异常。</target>
        </trans-unit>
        <trans-unit id="ec6c8813bd137356b82ff72079b75a071a3a49ec" translate="yes" xml:space="preserve">
          <source>If no exception name is given, the current exception is &lt;span id=&quot;reminusraised_1&quot;&gt;re-raised&lt;/span&gt;. The &lt;span id=&quot;reraiseerror_1&quot;&gt;ReraiseError&lt;/span&gt; exception is raised if there is no exception to re-raise. It follows that the &lt;code&gt;raise&lt;/code&gt; statement &lt;em&gt;always&lt;/em&gt; raises an exception.</source>
          <target state="translated">如果没有给出异常名称，则&lt;span id=&quot;reminusraised_1&quot;&gt;重新引发&lt;/span&gt;当前异常。该&lt;span id=&quot;reraiseerror_1&quot;&gt;ReraiseError&lt;/span&gt;如果没有例外的再次加注异常。因此， &lt;code&gt;raise&lt;/code&gt; 语句&lt;em&gt;始终&lt;/em&gt;会引发异常。</target>
        </trans-unit>
        <trans-unit id="b8f1c177651d5ac598768ca09b89f39ca965fc8a" translate="yes" xml:space="preserve">
          <source>If no valid color could be parsed &lt;code&gt;ValueError&lt;/code&gt; is raised. Case insensitive.</source>
          <target state="translated">如果无法解析有效的颜色，则会引发 &lt;code&gt;ValueError&lt;/code&gt; 。不区分大小写。</target>
        </trans-unit>
        <trans-unit id="05c31ffeb50efb95d9f7fcbe656ced23bb32fadb" translate="yes" xml:space="preserve">
          <source>If noQuotes is false the symbol may be returned in backticks. This will happen if the name happens to be a keyword or the first character is not part of the SymStartChars set.</source>
          <target state="translated">如果noQuotes为false,符号可能会以反引号返回。如果名称是关键字或者第一个字符不属于SymStartChars集,就会发生这种情况。</target>
        </trans-unit>
        <trans-unit id="bcb6340cf10c05ccf2a7bfa1e1c0783de9d0f0ba" translate="yes" xml:space="preserve">
          <source>If object &lt;code&gt;a&lt;/code&gt; inherits from &lt;code&gt;b&lt;/code&gt;, &lt;code&gt;a&lt;/code&gt; is a subtype of &lt;code&gt;b&lt;/code&gt;. This subtype relation is extended to the types &lt;code&gt;var&lt;/code&gt;, &lt;code&gt;ref&lt;/code&gt;, &lt;code&gt;ptr&lt;/code&gt;:</source>
          <target state="translated">如果对象 &lt;code&gt;a&lt;/code&gt; 从 &lt;code&gt;b&lt;/code&gt; 继承，则 &lt;code&gt;a&lt;/code&gt; 是 &lt;code&gt;b&lt;/code&gt; 的子类型。此子类型关系扩展为 &lt;code&gt;var&lt;/code&gt; ， &lt;code&gt;ref&lt;/code&gt; ， &lt;code&gt;ptr&lt;/code&gt; 类型：</target>
        </trans-unit>
        <trans-unit id="3cc150ff93a8e68590168a7d4dcb3edf2c87dc95" translate="yes" xml:space="preserve">
          <source>If only the date &amp;amp; time is considered, it appears that exactly one day has passed. However, the UTC offsets are different, which means that the UTC offset was changed somewhere in between. This happens twice each year for timezones that use daylight savings time. Because of this change, the amount of time that has passed is actually 25 hours.</source>
          <target state="translated">如果仅考虑日期和时间，则似乎已经过去了一天。但是，UTC偏移量是不同的，这意味着UTC偏移量介于两者之间。对于使用夏时制时间的时区，每年发生两次。由于此更改，经过的时间实际上是25小时。</target>
        </trans-unit>
        <trans-unit id="f05c37fe2a2ba4b139ce3fd0624a1db92445d0b7" translate="yes" xml:space="preserve">
          <source>If possible, prefer &lt;code&gt;isLower&lt;/code&gt; over &lt;code&gt;isUpper&lt;/code&gt;.</source>
          <target state="translated">如果可能，请 &lt;code&gt;isLower&lt;/code&gt; 选择isLower而不是 &lt;code&gt;isUpper&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="aade31752df0b65b99399acc157d4e6c367b1d08" translate="yes" xml:space="preserve">
          <source>If possible, prefer &lt;code&gt;toLower&lt;/code&gt; over &lt;code&gt;toUpper&lt;/code&gt;.</source>
          <target state="translated">如果可能的话，请 &lt;code&gt;toLower&lt;/code&gt; 选择&amp;ldquo;低&amp;rdquo;而 &lt;code&gt;toUpper&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="54ad6ae52f22f23880a6fa7417dc9ed9f2690573" translate="yes" xml:space="preserve">
          <source>If possible, the name parameter should match the name used in the tz database. If the timezone doesn't exist in the tz database, or if the timezone name is unknown, then any string that describes the timezone unambiguously can be used. Note that the timezones name is used for checking equality!</source>
          <target state="translated">如果可能的话,name参数应该与tz数据库中使用的名称相匹配,如果时区在tz数据库中不存在,或者时区名称未知,那么可以使用任何描述时区的字符串。如果时区不存在于tz数据库中,或者时区名称不详,那么可以使用任何能够明确描述时区的字符串。请注意,时区名称是用来检查平等性的!</target>
        </trans-unit>
        <trans-unit id="83cab258bfaceba0e5d7e569b163a43ec079fd90" translate="yes" xml:space="preserve">
          <source>If possible, the name will be the name used in the tz database. If the timezone doesn't exist in the tz database, or if the timezone name is unknown, then any string that describes the timezone unambiguously might be used. For example, the string &quot;LOCAL&quot; is used for the systems local timezone.</source>
          <target state="translated">如果可能的话,名称将是tz数据库中使用的名称。如果时区在tz数据库中不存在,或者时区名称不详,那么可以使用任何能够明确描述时区的字符串。例如,字符串 &quot;LOCAL &quot;被用来表示系统的本地时区。</target>
        </trans-unit>
        <trans-unit id="7d4e5a5abdc253c34bc8994506a514f7e8a3ab93" translate="yes" xml:space="preserve">
          <source>If socket is disconnected and no data is available to be read then the future will complete with a value of &lt;code&gt;&quot;&quot;&lt;/code&gt;.</source>
          <target state="translated">如果套接字断开连接并且没有数据可读取，则将来将以 &lt;code&gt;&quot;&quot;&lt;/code&gt; 值结束。</target>
        </trans-unit>
        <trans-unit id="ddadec8d4ad0814aaa2791b6db2a33e17de90113" translate="yes" xml:space="preserve">
          <source>If socket is disconnected and no data is available to be read then the future will complete with a value of &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">如果套接字已断开并且没有可用数据读取，则将来将以 &lt;code&gt;0&lt;/code&gt; 值结束。</target>
        </trans-unit>
        <trans-unit id="cb3029d46833d06111b6e34f35f0929a92d0edb0" translate="yes" xml:space="preserve">
          <source>If socket is disconnected during the recv operation then the future may complete with only a part of the requested data.</source>
          <target state="translated">如果socket在recv操作过程中被断开,那么未来可能只完成部分请求数据。</target>
        </trans-unit>
        <trans-unit id="0df46d3074a79a13b57275819c9d87a8439b076c" translate="yes" xml:space="preserve">
          <source>If some data has been retrieved; &lt;code&gt;ReadPartialLine&lt;/code&gt; is returned.</source>
          <target state="translated">如果已检索到一些数据； &lt;code&gt;ReadPartialLine&lt;/code&gt; 返回。</target>
        </trans-unit>
        <trans-unit id="f385d830d03b348ca6c7d251ed0e117515ba157e" translate="yes" xml:space="preserve">
          <source>If some data has been retrieved; &lt;code&gt;RecvPartialLine&lt;/code&gt; is returned.</source>
          <target state="translated">如果已检索到一些数据；返回 &lt;code&gt;RecvPartialLine&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bee5b1199e1feec8f933bd6e8aa87552a7bd77d7" translate="yes" xml:space="preserve">
          <source>If specified &lt;code&gt;entry&lt;/code&gt; does not exist, raises KeyError.</source>
          <target state="translated">如果指定的 &lt;code&gt;entry&lt;/code&gt; 不存在，则引发KeyError。</target>
        </trans-unit>
        <trans-unit id="99b6837e1f741f3a2cc549944f6142c90af6d182" translate="yes" xml:space="preserve">
          <source>If statement</source>
          <target state="translated">如果声明</target>
        </trans-unit>
        <trans-unit id="04f218769dfcd83f8fc0312e1f3e8248f84dbe92" translate="yes" xml:space="preserve">
          <source>If such a value does not exist, &lt;code&gt;OverflowDefect&lt;/code&gt; is raised or a compile time error occurs.</source>
          <target state="translated">如果不存在这样的值，则会引发 &lt;code&gt;OverflowDefect&lt;/code&gt; 或发生编译时错误。</target>
        </trans-unit>
        <trans-unit id="2dedc7eb074074f8129a06ee6d4eae6f2c0891b0" translate="yes" xml:space="preserve">
          <source>If such a value does not exist, &lt;code&gt;OverflowDefect&lt;/code&gt; is raised or a compile time error occurs. This is a short notation for: &lt;code&gt;x = pred(x, y)&lt;/code&gt;.</source>
          <target state="translated">如果不存在这样的值，则会引发 &lt;code&gt;OverflowDefect&lt;/code&gt; 或发生编译时错误。这是 &lt;code&gt;x = pred(x, y)&lt;/code&gt; 的缩写：x = pred（x，y）。</target>
        </trans-unit>
        <trans-unit id="0bc5aa4c9d62c0a4c5c72638dcde2f2a5ef1a6ad" translate="yes" xml:space="preserve">
          <source>If such a value does not exist, &lt;code&gt;OverflowDefect&lt;/code&gt; is raised or a compile time error occurs. This is a short notation for: &lt;code&gt;x = succ(x, y)&lt;/code&gt;.</source>
          <target state="translated">如果不存在这样的值，则会引发 &lt;code&gt;OverflowDefect&lt;/code&gt; 或发生编译时错误。这是 &lt;code&gt;x = succ(x, y)&lt;/code&gt; 的缩写：x = succ（x，y）。</target>
        </trans-unit>
        <trans-unit id="841bf5112e092c8cd39e9d2e2357a35f6b5f6da7" translate="yes" xml:space="preserve">
          <source>If the '#' character is present, integers use the 'alternate form' for formatting. This means that binary, octal, and hexadecimal output will be prefixed with '0b', '0o', and '0x', respectively.</source>
          <target state="translated">如果存在'#'字符,整数将使用'交替形式'进行格式化。这意味着二进制、八进制和十六进制输出将分别以'0b'、'0o'和'0x'作为前缀。</target>
        </trans-unit>
        <trans-unit id="2701e9b83a0e728206e51f442c68eb180551bc76" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;#pragmas-experimental-pragma&quot;&gt;experimental mode&lt;/a&gt; is active and no other match is found, the first argument &lt;code&gt;a&lt;/code&gt; is dereferenced automatically if it's a pointer type and overloading resolution is tried with &lt;code&gt;a[]&lt;/code&gt; instead.</source>
          <target state="translated">如果&lt;a href=&quot;#pragmas-experimental-pragma&quot;&gt;实验模式&lt;/a&gt;处于活动状态且未找到其他匹配项，则如果第一个参数 &lt;code&gt;a&lt;/code&gt; 是指针类型，则会自动取消引用该参数，并尝试使用 &lt;code&gt;a[]&lt;/code&gt; 尝试重载分辨率。</target>
        </trans-unit>
        <trans-unit id="26739fa77f2b7ce510c8a65058c811b7bbfd7c34" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;Option&lt;/code&gt; has a value, the result will be &lt;code&gt;Some(x)&lt;/code&gt; where &lt;code&gt;x&lt;/code&gt; is the string representation of the contained value. If the &lt;code&gt;Option&lt;/code&gt; does not have a value, the result will be &lt;code&gt;None[T]&lt;/code&gt; where &lt;code&gt;T&lt;/code&gt; is the name of the type contained in the &lt;code&gt;Option&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;Option&lt;/code&gt; 具有值，则结果将为 &lt;code&gt;Some(x)&lt;/code&gt; ，其中 &lt;code&gt;x&lt;/code&gt; 是所包含值的字符串表示形式。如果 &lt;code&gt;Option&lt;/code&gt; 没有值，则结果将为 &lt;code&gt;None[T]&lt;/code&gt; ，其中 &lt;code&gt;T&lt;/code&gt; 是 &lt;code&gt;Option&lt;/code&gt; 中包含的类型的名称。</target>
        </trans-unit>
        <trans-unit id="78a9cbb9118b85e5ba10a7abba984340fc868fac" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;Option&lt;/code&gt; is &lt;code&gt;None&lt;/code&gt;, &lt;code&gt;None&lt;/code&gt; of the return type of the &lt;code&gt;callback&lt;/code&gt; will be returned.</source>
          <target state="translated">如果 &lt;code&gt;Option&lt;/code&gt; 为 &lt;code&gt;None&lt;/code&gt; ， &lt;code&gt;None&lt;/code&gt; 返回 &lt;code&gt;callback&lt;/code&gt; 的返回类型。</target>
        </trans-unit>
        <trans-unit id="3d093b04a14e54cf08a5c56f3c93f1bdd47df2b7" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;callback&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;, the option is returned as &lt;code&gt;Some&lt;/code&gt;. If it returns &lt;code&gt;false&lt;/code&gt;, it is returned as &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;callback&lt;/code&gt; 返回 &lt;code&gt;true&lt;/code&gt; ，则该选项作为 &lt;code&gt;Some&lt;/code&gt; 返回。如果返回 &lt;code&gt;false&lt;/code&gt; ，则返回 &lt;code&gt;None&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9e5263d26588e23e499a73f68828b3208e4128e6" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;filename&lt;/code&gt; has no extension, &lt;code&gt;ext&lt;/code&gt; will be added. If &lt;code&gt;ext&lt;/code&gt; == &quot;&quot; then any extension is removed.</source>
          <target state="translated">如果 &lt;code&gt;filename&lt;/code&gt; 没有扩展名，则将添加 &lt;code&gt;ext&lt;/code&gt; 。如果 &lt;code&gt;ext&lt;/code&gt; ==&amp;ldquo;&amp;rdquo;，则所有扩展名都将被删除。</target>
        </trans-unit>
        <trans-unit id="30f04b40fb234123c9240535d5420bf04b4bad00" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;line&lt;/code&gt; pragma is used with a parameter, the parameter needs be a &lt;code&gt;tuple[filename: string, line: int]&lt;/code&gt;. If it is used without a parameter, &lt;code&gt;system.InstantiationInfo()&lt;/code&gt; is used.</source>
          <target state="translated">如果 &lt;code&gt;line&lt;/code&gt; pragma与参数一起使用，则该参数需要为 &lt;code&gt;tuple[filename: string, line: int]&lt;/code&gt; 。如果不带参数使用它，则使用 &lt;code&gt;system.InstantiationInfo()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cc91ac0b9432830816ba69fa3ae8519ab1eeae46" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;raise&lt;/code&gt; keyword is not followed by an expression, the last exception is &lt;em&gt;re-raised&lt;/em&gt;. For the purpose of avoiding repeating this common code pattern, the template &lt;code&gt;newException&lt;/code&gt; in the &lt;code&gt;system&lt;/code&gt; module can be used:</source>
          <target state="translated">如果 &lt;code&gt;raise&lt;/code&gt; 关键字后没有表达式，则&lt;em&gt;重新引发&lt;/em&gt;最后一个异常。为了避免重复该共同的代码图案为目的，模板 &lt;code&gt;newException&lt;/code&gt; 中 &lt;code&gt;system&lt;/code&gt; 模块可用于：</target>
        </trans-unit>
        <trans-unit id="a6220c53edf17f6d6c3f7b003487c554feec55e0" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;smtp&lt;/code&gt; object was created with &lt;code&gt;debug&lt;/code&gt; enabled, debugRecv will invoke &lt;code&gt;echo(&quot;S:&quot; &amp;amp; result.string)&lt;/code&gt; after the data is received.</source>
          <target state="translated">如果 &lt;code&gt;smtp&lt;/code&gt; 对象是在启用 &lt;code&gt;debug&lt;/code&gt; 下创建的，则debugRecv将在接收到数据后调用 &lt;code&gt;echo(&quot;S:&quot; &amp;amp; result.string)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5b3085b8812c2688f5e08f75eadc2fa13e9a9e96" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;smtp&lt;/code&gt; object was created with &lt;code&gt;debug&lt;/code&gt; enabled, debugSend will invoke &lt;code&gt;echo(&quot;C:&quot; &amp;amp; cmd)&lt;/code&gt; before sending.</source>
          <target state="translated">如果 &lt;code&gt;smtp&lt;/code&gt; 对象是在启用 &lt;code&gt;debug&lt;/code&gt; 下创建的，则debugSend将在发送前调用 &lt;code&gt;echo(&quot;C:&quot; &amp;amp; cmd)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a29b5294c2d5b8f33f39477a3e8ec43eeb105639" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;stackTrace&lt;/code&gt; option is turned on, the generated C contains code to ensure that proper stack traces are given if the program crashes or an uncaught exception is raised.</source>
          <target state="translated">如果打开 &lt;code&gt;stackTrace&lt;/code&gt; 选项，则生成的C包含代码，以确保在程序崩溃或引发未捕获的异常时给出正确的堆栈跟踪。</target>
        </trans-unit>
        <trans-unit id="66aa11a675956c0c2ffc06581868b69289fea7ae" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;stackTrace&lt;/code&gt; option is turned on, the generated C contains code to ensure that proper stack traces are given if the program crashes or some uncaught exception is raised.</source>
          <target state="translated">如果打开 &lt;code&gt;stackTrace&lt;/code&gt; 选项，则生成的C包含代码，以确保在程序崩溃或引发某些未捕获的异常时给出正确的堆栈跟踪。</target>
        </trans-unit>
        <trans-unit id="69353978c65a0ffe1cd9e998af57fe30abaceb6d" translate="yes" xml:space="preserve">
          <source>If the &lt;em&gt;filename&lt;/em&gt; has no extension, &lt;em&gt;ext&lt;/em&gt; will be added. If &lt;em&gt;ext&lt;/em&gt; == &quot;&quot; then any extension is removed. &lt;em&gt;Ext&lt;/em&gt; should be given without the leading '.', because some filesystems may use a different character. (Although I know of none such beast.)</source>
          <target state="translated">如果&lt;em&gt;文件名&lt;/em&gt;没有扩展名，则将添加&lt;em&gt;ext&lt;/em&gt;。如果&lt;em&gt;ext&lt;/em&gt; ==&amp;ldquo;&amp;rdquo;，则所有扩展名都将被删除。&lt;em&gt;Ext&lt;/em&gt;应该不带前导&amp;ldquo;。&amp;rdquo;，因为某些文件系统可能使用不同的字符。（尽管我不知道有这样的野兽。）</target>
        </trans-unit>
        <trans-unit id="6e6188bf137b40bf7c0100e9bc397d80a81640f7" translate="yes" xml:space="preserve">
          <source>If the AST returned by the macro contains other macro invocations, this process iterates.</source>
          <target state="translated">如果宏返回的AST包含其他宏调用,这个过程就会反复进行。</target>
        </trans-unit>
        <trans-unit id="79ace98adbbf3c8936f6e66ea8ff73968f01fefd" translate="yes" xml:space="preserve">
          <source>If the GNU assembler is used, quotes and newlines are inserted automatically:</source>
          <target state="translated">如果使用GNU汇编器,则会自动插入引号和换行。</target>
        </trans-unit>
        <trans-unit id="0f567e3c2047b434a83b4adc7353c2da45d5c2c6" translate="yes" xml:space="preserve">
          <source>If the awaited futures &lt;em&gt;are&lt;/em&gt;&lt;code&gt;Future[void]&lt;/code&gt;, this proc returns &lt;code&gt;Future[void]&lt;/code&gt;.</source>
          <target state="translated">如果等待的期货&lt;em&gt;是&lt;/em&gt; &lt;code&gt;Future[void]&lt;/code&gt; ，则此proc返回 &lt;code&gt;Future[void]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="aa43020aaaa8cf58315161b2bb7c7b775d6b572a" translate="yes" xml:space="preserve">
          <source>If the awaited futures are not &lt;code&gt;Future[void]&lt;/code&gt;, the returned future will hold the values of all awaited futures in a sequence.</source>
          <target state="translated">如果等待的期货不是 &lt;code&gt;Future[void]&lt;/code&gt; ，则返回的期货将按顺序保存所有等待的期货的值。</target>
        </trans-unit>
        <trans-unit id="a6ef9d4c5f7c94e1677a2aee62e318f20e408e57" translate="yes" xml:space="preserve">
          <source>If the blocks are equal, &lt;code&gt;true&lt;/code&gt; is returned, &lt;code&gt;false&lt;/code&gt; otherwise. Like any procedure dealing with raw memory this is &lt;strong&gt;unsafe&lt;/strong&gt;.</source>
          <target state="translated">如果块相等， &lt;code&gt;true&lt;/code&gt; 返回， &lt;code&gt;false&lt;/code&gt; 否则。像处理原始内存的任何过程一样，这是&lt;strong&gt;不安全的&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="e214db9e43017090098fcfa4aa20df6a7d5897d9" translate="yes" xml:space="preserve">
          <source>If the conversion fails, &lt;code&gt;ValueError&lt;/code&gt; is raised. However, on most platforms the conversion cannot fail.</source>
          <target state="translated">如果转换失败，则会引发 &lt;code&gt;ValueError&lt;/code&gt; 。但是，在大多数平台上，转换都不会失败。</target>
        </trans-unit>
        <trans-unit id="9ce6f3e71598f7a9a7b81af12401bcfa27f376fb" translate="yes" xml:space="preserve">
          <source>If the current length is greater than the new length, &lt;code&gt;s&lt;/code&gt; will be truncated.</source>
          <target state="translated">如果当前长度大于新长度，则 &lt;code&gt;s&lt;/code&gt; 将被截断。</target>
        </trans-unit>
        <trans-unit id="ce3d450e3aa3af165643f84339cce8ca42f91e47" translate="yes" xml:space="preserve">
          <source>If the error code is &lt;code&gt;0&lt;/code&gt; or an error message could not be retrieved, the message &lt;code&gt;unknown OS error&lt;/code&gt; will be used.</source>
          <target state="translated">如果错误代码为 &lt;code&gt;0&lt;/code&gt; 或无法检索到错误消息，则将使用消息 &lt;code&gt;unknown OS error&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="107b1dbcd45465b9fb9139f69422c54382db4de7" translate="yes" xml:space="preserve">
          <source>If the file cannot be opened, &lt;code&gt;nil&lt;/code&gt; is returned. See the &lt;a href=&quot;io&quot;&gt;io module&lt;/a&gt; for a list of available &lt;a href=&quot;io#FileMode&quot;&gt;FileMode enums&lt;/a&gt;.</source>
          <target state="translated">如果无法打开文件，则返回 &lt;code&gt;nil&lt;/code&gt; 。有关可用的&lt;a href=&quot;io#FileMode&quot;&gt;FileMode枚举&lt;/a&gt;的列表，请参见&lt;a href=&quot;io&quot;&gt;io模块&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="feb04dbf83fa77a108a19af608dbbb64dcf8bef0" translate="yes" xml:space="preserve">
          <source>If the file does not exist &lt;code&gt;IOError&lt;/code&gt; is raised. The trailing newline character(s) are removed from the iterated lines. Example:</source>
          <target state="translated">如果文件不存在，则会引发 &lt;code&gt;IOError&lt;/code&gt; 。从迭代行中删除尾随换行符。例子：</target>
        </trans-unit>
        <trans-unit id="5fe1d39f639c6431559fde4aae2a700b0d4ccf44" translate="yes" xml:space="preserve">
          <source>If the file does not exist &lt;em&gt;EIO&lt;/em&gt; is raised. The trailing newline character(s) are removed from the iterated lines. Example:</source>
          <target state="translated">如果文件不存在，则会引发&lt;em&gt;EIO&lt;/em&gt;。从迭代行中删除尾随换行符。例：</target>
        </trans-unit>
        <trans-unit id="bafa24e01b0dca07bfac7c2248312106929d5bde" translate="yes" xml:space="preserve">
          <source>If the file pointer is past the end of the file then an empty string is returned.</source>
          <target state="translated">如果文件指针已经过了文件的末端,那么将返回一个空字符串。</target>
        </trans-unit>
        <trans-unit id="76343cf0f621f6a2b7f316008b6f0e6e56f15e33" translate="yes" xml:space="preserve">
          <source>If the file pointer is past the end of the file then zero is returned and no bytes are read into &lt;code&gt;buf&lt;/code&gt;</source>
          <target state="translated">如果文件指针超出了文件的末尾，则返回零，并且没有字节读取到 &lt;code&gt;buf&lt;/code&gt; 中</target>
        </trans-unit>
        <trans-unit id="e9e8d1e3329be3b1efe953e0d47c9f6690b475b1" translate="yes" xml:space="preserve">
          <source>If the for loop expression &lt;code&gt;e&lt;/code&gt; does not denote an iterator and the for loop has exactly 1 variable, the for loop expression is rewritten to &lt;code&gt;items(e)&lt;/code&gt;; ie. an &lt;code&gt;items&lt;/code&gt; iterator is implicitly invoked:</source>
          <target state="translated">如果for循环表达式 &lt;code&gt;e&lt;/code&gt; 不表示迭代器，并且for循环正好具有1个变量，则for循环表达式将重写为 &lt;code&gt;items(e)&lt;/code&gt; ；即。一个 &lt;code&gt;items&lt;/code&gt; 迭代器被隐式调用：</target>
        </trans-unit>
        <trans-unit id="f1948e286ab2aa083c7abdf710bb8b040d1a1433" translate="yes" xml:space="preserve">
          <source>If the for loop has exactly 2 variables, a &lt;code&gt;pairs&lt;/code&gt; iterator is implicitly invoked.</source>
          <target state="translated">如果for循环恰好具有2个变量，则将隐式调用 &lt;code&gt;pairs&lt;/code&gt; 迭代器。</target>
        </trans-unit>
        <trans-unit id="f1d9041cac1672dd9769b2ea2138dfba71b254c8" translate="yes" xml:space="preserve">
          <source>If the formal parameter &lt;code&gt;f&lt;/code&gt; is of type &lt;code&gt;var T&lt;/code&gt; (or &lt;code&gt;out T&lt;/code&gt;) in addition to the ordinary type checking, the argument is checked to be an &lt;span id=&quot;lminusvalue_1&quot;&gt;l-value&lt;/span&gt;. &lt;code&gt;var T&lt;/code&gt; (or &lt;code&gt;out T&lt;/code&gt;) matches better than just &lt;code&gt;T&lt;/code&gt; then.</source>
          <target state="translated">如果除了普通类型检查外，形式参数 &lt;code&gt;f&lt;/code&gt; 的类型为 &lt;code&gt;var T&lt;/code&gt; （或 &lt;code&gt;out T&lt;/code&gt; ），则将参数检查为&lt;span id=&quot;lminusvalue_1&quot;&gt;l值&lt;/span&gt;。 &lt;code&gt;var T&lt;/code&gt; （或 &lt;code&gt;out T&lt;/code&gt; ）匹配的不仅仅是好 &lt;code&gt;T&lt;/code&gt; 呢。</target>
        </trans-unit>
        <trans-unit id="6316f54cbdea61f6ea28df0e5d5c083559be9b99" translate="yes" xml:space="preserve">
          <source>If the formal parameter &lt;code&gt;f&lt;/code&gt; is of type &lt;code&gt;var T&lt;/code&gt; in addition to the ordinary type checking, the argument is checked to be an &lt;span id=&quot;lminusvalue_1&quot;&gt;l-value&lt;/span&gt;. &lt;code&gt;var T&lt;/code&gt; matches better than just &lt;code&gt;T&lt;/code&gt; then.</source>
          <target state="translated">如果除了普通类型检查之外，形式参数 &lt;code&gt;f&lt;/code&gt; 的类型也为 &lt;code&gt;var T&lt;/code&gt; ，则将参数检查为&lt;span id=&quot;lminusvalue_1&quot;&gt;l值&lt;/span&gt;。 &lt;code&gt;var T&lt;/code&gt; 匹配不仅仅是好 &lt;code&gt;T&lt;/code&gt; 呢。</target>
        </trans-unit>
        <trans-unit id="06c385a15682548ea060388897b3ee567fedd764" translate="yes" xml:space="preserve">
          <source>If the future stream already has data or is finished then &lt;code&gt;cb&lt;/code&gt; will be called immediately.</source>
          <target state="translated">如果将来的流已经有数据或已完成，则 &lt;code&gt;cb&lt;/code&gt; 将立即被调用。</target>
        </trans-unit>
        <trans-unit id="9a17c29c098e84ef9b5397d265f349b1b95a392e" translate="yes" xml:space="preserve">
          <source>If the handler does not raise an exception, ordinary control flow continues and the program is terminated.</source>
          <target state="translated">如果处理程序没有引发异常,则普通控制流继续进行,程序终止。</target>
        </trans-unit>
        <trans-unit id="ba2e71c9350a067beb4f36ed2c2123aef7d9b604" translate="yes" xml:space="preserve">
          <source>If the implementation does not support the requested type of object or operation.</source>
          <target state="translated">如果实现不支持所请求的对象或操作类型。</target>
        </trans-unit>
        <trans-unit id="c9c412224e5b1f16ba846947349eefe31c0a2b58" translate="yes" xml:space="preserve">
          <source>If the information cannot be retrieved, such as when the file handle is invalid, &lt;code&gt;OSError&lt;/code&gt; is raised.</source>
          <target state="translated">如果无法检索信息（例如，当文件句柄无效时），则会引发 &lt;code&gt;OSError&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e36df26fc214c0ac51566c4f11deb9d6bc0cf23a" translate="yes" xml:space="preserve">
          <source>If the information cannot be retrieved, such as when the file handle is invalid, an error will be thrown.</source>
          <target state="translated">如果不能检索到信息,比如文件句柄无效,就会抛出一个错误。</target>
        </trans-unit>
        <trans-unit id="ff2dbea5ec04b95d862e774824113e63172e2b69" translate="yes" xml:space="preserve">
          <source>If the information cannot be retrieved, such as when the path doesn't exist, or when permission restrictions prevent the program from retrieving file information, &lt;code&gt;OSError&lt;/code&gt; is raised.</source>
          <target state="translated">如果无法检索信息（例如，当路径不存在或权限限制阻止程序检索文件信息时），则会引发 &lt;code&gt;OSError&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="931654e57ac7ff5e6e25ca20aeac61e7abee7076" translate="yes" xml:space="preserve">
          <source>If the information cannot be retrieved, such as when the path doesn't exist, or when permission restrictions prevent the program from retrieving file information, an error will be thrown.</source>
          <target state="translated">如果信息无法检索,比如路径不存在,或者权限限制使程序无法检索文件信息,就会抛出一个错误。</target>
        </trans-unit>
        <trans-unit id="c9e1e4f07efdbdfe683f438bf843008ae55e735b" translate="yes" xml:space="preserve">
          <source>If the iterator yields a tuple, there can be as many iteration variables as there are components in the tuple. The i'th iteration variable's type is the type of the i'th component. In other words, implicit tuple unpacking in a for loop context is supported.</source>
          <target state="translated">如果迭代器产生一个元组,那么元组中有多少个分量,就可以有多少个迭代变量。第i个迭代变量的类型就是第i个组件的类型。换句话说,在for循环上下文中支持隐式元组解包。</target>
        </trans-unit>
        <trans-unit id="6f90e673e99dd8f0b56aa326b33eb0d0306fdf75" translate="yes" xml:space="preserve">
          <source>If the operator ends with &lt;code&gt;=&lt;/code&gt; and its first character is none of &lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;!&lt;/code&gt;, &lt;code&gt;=&lt;/code&gt;, &lt;code&gt;~&lt;/code&gt;, &lt;code&gt;?&lt;/code&gt;, it is an &lt;em&gt;assignment operator&lt;/em&gt; which has the second lowest precedence.</source>
          <target state="translated">如果与操作者的端部 &lt;code&gt;=&lt;/code&gt; 和其第一个字符是没有的 &lt;code&gt;&amp;lt;&lt;/code&gt; ， &lt;code&gt;&amp;gt;&lt;/code&gt; ， &lt;code&gt;!&lt;/code&gt; ， &lt;code&gt;=&lt;/code&gt; ， &lt;code&gt;~&lt;/code&gt; ， &lt;code&gt;?&lt;/code&gt; ，它是具有第二低优先级的&lt;em&gt;赋值运算符&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="248bf6543c9b80549c21569bb17e72ffe3e4f779" translate="yes" xml:space="preserve">
          <source>If the operator ends with &lt;code&gt;=&lt;/code&gt; and its first character is none of &lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;!&lt;/code&gt;, &lt;code&gt;=&lt;/code&gt;, &lt;code&gt;~&lt;/code&gt;, &lt;code&gt;?&lt;/code&gt;, it is an &lt;em&gt;assignment operator&lt;/em&gt; which has the second-lowest precedence.</source>
          <target state="translated">如果与操作者的端部 &lt;code&gt;=&lt;/code&gt; 和其第一个字符是没有的 &lt;code&gt;&amp;lt;&lt;/code&gt; ， &lt;code&gt;&amp;gt;&lt;/code&gt; ， &lt;code&gt;!&lt;/code&gt; ， &lt;code&gt;=&lt;/code&gt; ， &lt;code&gt;~&lt;/code&gt; ， &lt;code&gt;?&lt;/code&gt; ，它是具有第二低优先级的&lt;em&gt;赋值运算符&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="75e7e394fcfc961cebe8bca07c60cb63e58b1db1" translate="yes" xml:space="preserve">
          <source>If the prefix is part of the name (but the name doesn't start with it), these symbols come second.</source>
          <target state="translated">如果前缀是名字的一部分(但名字不以它开头),这些符号就排在后面。</target>
        </trans-unit>
        <trans-unit id="77d5ae1836106c51a0b36a1a34e1eea987b0968e" translate="yes" xml:space="preserve">
          <source>If the proc declaration has no body, it is a &lt;span id=&quot;forward_1&quot;&gt;forward&lt;/span&gt; declaration. If the proc returns a value, the procedure body can access an implicitly declared variable named &lt;span id=&quot;result_2&quot;&gt;result&lt;/span&gt; that represents the return value. Procs can be overloaded. The overloading resolution algorithm determines which proc is the best match for the arguments. Example:</source>
          <target state="translated">如果proc声明没有主体，则为&lt;span id=&quot;forward_1&quot;&gt;前向&lt;/span&gt;声明。如果proc返回一个值，则过程主体可以访问一个隐式声明的名为&lt;span id=&quot;result_2&quot;&gt;result的&lt;/span&gt;变量，该变量表示返回值。过程可能会超载。重载解析算法确定哪个proc最适合参数。例：</target>
        </trans-unit>
        <trans-unit id="7f9553b958c19cddce23d7730df0fa25e4ae656d" translate="yes" xml:space="preserve">
          <source>If the procedure needs to modify the argument for the caller, a &lt;code&gt;var&lt;/code&gt; parameter can be used:</source>
          <target state="translated">如果该过程需要修改调用方的参数，则可以使用 &lt;code&gt;var&lt;/code&gt; 参数：</target>
        </trans-unit>
        <trans-unit id="8ffce8267c957e13dff8b29b02ca2b908de49e40" translate="yes" xml:space="preserve">
          <source>If the result of the future is an error then that error will be raised.</source>
          <target state="translated">如果未来的结果是一个错误,那么这个错误将被提出。</target>
        </trans-unit>
        <trans-unit id="16b303009a30beca5105d2aa322ae24b48a52b7d" translate="yes" xml:space="preserve">
          <source>If the resulting string is not longer than the original input string, only a single memory allocation is required.</source>
          <target state="translated">如果产生的字符串不比原始输入字符串长,只需要分配一次内存。</target>
        </trans-unit>
        <trans-unit id="a9b83a69915f2923c508823edf191d18bfe7c62b" translate="yes" xml:space="preserve">
          <source>If the socket has been disconnected; &lt;code&gt;ReadDisconnected&lt;/code&gt; is returned.</source>
          <target state="translated">如果插座已断开； &lt;code&gt;ReadDisconnected&lt;/code&gt; 返回。</target>
        </trans-unit>
        <trans-unit id="2f2159e99fd16ad61ca59fb4cff56737dc03dd06" translate="yes" xml:space="preserve">
          <source>If the socket has been disconnected; &lt;code&gt;RecvDisconnected&lt;/code&gt; is returned.</source>
          <target state="translated">如果插座已断开； &lt;code&gt;RecvDisconnected&lt;/code&gt; 返回。</target>
        </trans-unit>
        <trans-unit id="06267d9401718740a7aedde535d821882f38a309" translate="yes" xml:space="preserve">
          <source>If the socket is disconnected in the middle of a line (before &lt;code&gt;\r\L&lt;/code&gt; is read) then line will be set to &lt;code&gt;&quot;&quot;&lt;/code&gt;. The partial line &lt;strong&gt;will be lost&lt;/strong&gt;.</source>
          <target state="translated">如果套接字在一行中间断开（在读取 &lt;code&gt;\r\L&lt;/code&gt; 之前），则该行将设置为 &lt;code&gt;&quot;&quot;&lt;/code&gt; 。分线&lt;strong&gt;将丢失&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="aff4ce46ec1145925961993e78a141b3df5cdc42" translate="yes" xml:space="preserve">
          <source>If the socket is disconnected, &lt;code&gt;line&lt;/code&gt; will be set to &lt;code&gt;&quot;&quot;&lt;/code&gt; and &lt;code&gt;True&lt;/code&gt; will be returned.</source>
          <target state="translated">如果套接字断开连接，则将 &lt;code&gt;line&lt;/code&gt; 设置为 &lt;code&gt;&quot;&quot;&lt;/code&gt; 并返回 &lt;code&gt;True&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4152f2601369713f5b3377cbe629187b41c395fa" translate="yes" xml:space="preserve">
          <source>If the socket is disconnected, &lt;code&gt;line&lt;/code&gt; will be set to &lt;code&gt;&quot;&quot;&lt;/code&gt;.</source>
          <target state="translated">如果插座断开，则 &lt;code&gt;line&lt;/code&gt; 将设置为 &lt;code&gt;&quot;&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7db7153a9dd78804e9f3e45b8ee428bd5b09802b" translate="yes" xml:space="preserve">
          <source>If the socket is disconnected, the result will be set to &lt;code&gt;&quot;&quot;&lt;/code&gt;.</source>
          <target state="translated">如果套接字断开连接，则结果将设置为 &lt;code&gt;&quot;&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7d578dee840a7c31291fc81e023d496e5514d739" translate="yes" xml:space="preserve">
          <source>If the specified range of text does not fit into a DOMString Currently not used(Since DOMString is just string)</source>
          <target state="translated">如果指定的文字范围不能放入DOMString中 目前不使用(因为DOMString只是字符串)</target>
        </trans-unit>
        <trans-unit id="c9912e0ea82104240a5215a573498a602831f250" translate="yes" xml:space="preserve">
          <source>If the supplied number of elements exceeds the total number of elements in the deque, the deque will remain empty.</source>
          <target state="translated">如果提供的元素数量超过了deque中的元素总数,deque将保持为空。</target>
        </trans-unit>
        <trans-unit id="1c3e6dac4d1e457dc35cad93fa8d0a3e65325ba3" translate="yes" xml:space="preserve">
          <source>If the symbol should also be exported to a dynamic library, the &lt;code&gt;dynlib&lt;/code&gt; pragma should be used in addition to the &lt;code&gt;exportc&lt;/code&gt; pragma. See &lt;a href=&quot;#foreign-function-interface-dynlib-pragma-for-export&quot;&gt;Dynlib pragma for export&lt;/a&gt;.</source>
          <target state="translated">如果符号也应该导出到动态库，则 &lt;code&gt;dynlib&lt;/code&gt; 编译指示外，还应使用 &lt;code&gt;exportc&lt;/code&gt; 编译指示。请参阅&lt;a href=&quot;#foreign-function-interface-dynlib-pragma-for-export&quot;&gt;Dynlib实用程序进行导出&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2557668195fbfe5c8f3c1eca75334e08ac4d4277" translate="yes" xml:space="preserve">
          <source>If the system supports symlinks it also resolves them until it meets the actual file. This behavior can be disabled if desired by setting &lt;code&gt;followSymlinks = false&lt;/code&gt;.</source>
          <target state="translated">如果系统支持符号链接，它也会解析它们，直到符合实际文件。如果需要，可以通过设置 &lt;code&gt;followSymlinks = false&lt;/code&gt; 来禁用此行为。</target>
        </trans-unit>
        <trans-unit id="81b18a9e716c01074670be16ff9f7b2d4da9d53a" translate="yes" xml:space="preserve">
          <source>If the taint mode is turned off, &lt;code&gt;TaintedString&lt;/code&gt; is simply an alias for &lt;code&gt;string&lt;/code&gt;.</source>
          <target state="translated">如果关闭异味模式，则 &lt;code&gt;TaintedString&lt;/code&gt; 只是 &lt;code&gt;string&lt;/code&gt; 的别名。</target>
        </trans-unit>
        <trans-unit id="3ade66f9e7d10ed2722b60a91ec1dc67330d9fa7" translate="yes" xml:space="preserve">
          <source>If the taint mode is turned on (via the &lt;code&gt;--taintMode:on&lt;/code&gt; command line option) it is a distinct string type which helps to detect input validation errors:</source>
          <target state="translated">如果打开异味模式（通过 &lt;code&gt;--taintMode:on&lt;/code&gt; 命令行选项），则它是一种独特的字符串类型，有助于检测输入验证错误：</target>
        </trans-unit>
        <trans-unit id="9614b1e1a8be3e96f495969f1af445d51d40d1c3" translate="yes" xml:space="preserve">
          <source>If the template does not have types for its parameters, the type identifiers inside &lt;code&gt;nnkFormalParams&lt;/code&gt; just becomes &lt;code&gt;nnkEmpty&lt;/code&gt;.</source>
          <target state="translated">如果模板的参数没有类型，则 &lt;code&gt;nnkFormalParams&lt;/code&gt; 内部的类型标识符将变为 &lt;code&gt;nnkEmpty&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="80a4298614b1c88fcba898b49b736115a77cf332" translate="yes" xml:space="preserve">
          <source>If the template has no explicit return type, &lt;code&gt;void&lt;/code&gt; is used for consistency with procs and methods.</source>
          <target state="translated">如果模板没有显式的返回类型，则将 &lt;code&gt;void&lt;/code&gt; 用于与proc和方法保持一致。</target>
        </trans-unit>
        <trans-unit id="311a8257dbecbe5f571f1d56880174e340cbb539" translate="yes" xml:space="preserve">
          <source>If the variable does not exist, &lt;code&gt;&quot;&quot;&lt;/code&gt; is returned. To distinguish whether a variable exists or it's value is just &lt;code&gt;&quot;&quot;&lt;/code&gt;, call &lt;a href=&quot;#existsEnv,string&quot;&gt;existsEnv(key) proc&lt;/a&gt;.</source>
          <target state="translated">如果变量不存在，则返回 &lt;code&gt;&quot;&quot;&lt;/code&gt; 。要区分变量是否存在或其值仅仅是 &lt;code&gt;&quot;&quot;&lt;/code&gt; ，请调用&lt;a href=&quot;#existsEnv,string&quot;&gt;existEnv（key）proc&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="bea9fb33db15316176ec096b57a2d7c1faae43c3" translate="yes" xml:space="preserve">
          <source>If the width field is preceded by a zero ('0') character, this enables zero-padding.</source>
          <target state="translated">如果宽度字段前有零('0')字符,则启用零填充。</target>
        </trans-unit>
        <trans-unit id="08e24dc66cc5899916445680c12d07116f7a31f9" translate="yes" xml:space="preserve">
          <source>If there is a &lt;code&gt;finally&lt;/code&gt; part, it is always executed after the exception handlers.</source>
          <target state="translated">如果有 &lt;code&gt;finally&lt;/code&gt; 部分，则总是在异常处理程序之后执行。</target>
        </trans-unit>
        <trans-unit id="5403f5f769c6890d6ee94ea9cf83af93e0867d21" translate="yes" xml:space="preserve">
          <source>If there is a &lt;span id=&quot;finally_1&quot;&gt;finally&lt;/span&gt; clause, it is always executed after the exception handlers.</source>
          <target state="translated">如果有一个&lt;span id=&quot;finally_1&quot;&gt;finally&lt;/span&gt;子句，它总是在异常处理程序之后执行。</target>
        </trans-unit>
        <trans-unit id="8f3162b58a35394f9a00eeb14229f14280e86bba" translate="yes" xml:space="preserve">
          <source>If there is a prefix (foo|), symbols starting with this prefix come first.</source>
          <target state="translated">如果有前缀(foo|),以这个前缀开始的符号优先。</target>
        </trans-unit>
        <trans-unit id="b016123034bebbefe22ae78b4065b8c3fdf35002" translate="yes" xml:space="preserve">
          <source>If there is no data to be read from the socket &lt;code&gt;False&lt;/code&gt; will be returned.</source>
          <target state="translated">如果没有要从套接字读取的数据，将返回 &lt;code&gt;False&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="675af36ecdb4bc1179580030d8540852cbfd5745" translate="yes" xml:space="preserve">
          <source>If this algorithm returns &quot;ambiguous&quot; further disambiguation is performed: If the argument &lt;code&gt;a&lt;/code&gt; matches both the parameter type &lt;code&gt;f&lt;/code&gt; of &lt;code&gt;p&lt;/code&gt; and &lt;code&gt;g&lt;/code&gt; of &lt;code&gt;q&lt;/code&gt; via a subtyping relation, the inheritance depth is taken into account:</source>
          <target state="translated">如果该算法返回，执行&amp;ldquo;模糊&amp;rdquo;进一步消歧：如果参数 &lt;code&gt;a&lt;/code&gt; 匹配两个参数类型 &lt;code&gt;f&lt;/code&gt; 的 &lt;code&gt;p&lt;/code&gt; 和 &lt;code&gt;g&lt;/code&gt; 的 &lt;code&gt;q&lt;/code&gt; 经由子类型关系，继承深度是考虑到：</target>
        </trans-unit>
        <trans-unit id="210b5b5558f1d9d1b930518636f98564faf83e54" translate="yes" xml:space="preserve">
          <source>If this fails, &lt;code&gt;OSError&lt;/code&gt; is raised.</source>
          <target state="translated">如果失败，则引发 &lt;code&gt;OSError&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bd37f3d9598c7f5874dab0ebdd7196f760e5938c" translate="yes" xml:space="preserve">
          <source>If this fails, &lt;code&gt;OSError&lt;/code&gt; is raised. If &lt;code&gt;dest&lt;/code&gt; already exists, it will be overwritten.</source>
          <target state="translated">如果失败，则引发 &lt;code&gt;OSError&lt;/code&gt; 。如果 &lt;code&gt;dest&lt;/code&gt; 已经存在，它将被覆盖。</target>
        </trans-unit>
        <trans-unit id="4e7ae0850651d2d770c981a6dbda59ceaa531c62" translate="yes" xml:space="preserve">
          <source>If this fails, &lt;code&gt;OSError&lt;/code&gt; is raised. This does not fail if the directory never existed in the first place, unless &lt;code&gt;checkDir&lt;/code&gt; = true</source>
          <target state="translated">如果失败，则引发 &lt;code&gt;OSError&lt;/code&gt; 。如果目录从不存在，这不会失败，除非 &lt;code&gt;checkDir&lt;/code&gt; = true</target>
        </trans-unit>
        <trans-unit id="209836da67814eeba98a19e6ddc6b727ffa92871" translate="yes" xml:space="preserve">
          <source>If this fails, &lt;code&gt;OSError&lt;/code&gt; is raised. This does not fail if the file never existed in the first place.</source>
          <target state="translated">如果失败，则引发 &lt;code&gt;OSError&lt;/code&gt; 。如果文件从不存在，这不会失败。</target>
        </trans-unit>
        <trans-unit id="2622b56bd072d5f0cccd9fc29dc8d94e327fc30e" translate="yes" xml:space="preserve">
          <source>If this fails, &lt;code&gt;OSError&lt;/code&gt; is raised. This is a wrapper proc around &lt;a href=&quot;#copyDir,string,string&quot;&gt;copyDir&lt;/a&gt; and &lt;a href=&quot;#copyFileWithPermissions,string,string&quot;&gt;copyFileWithPermissions&lt;/a&gt; procs on non-Windows platforms.</source>
          <target state="translated">如果失败，则引发 &lt;code&gt;OSError&lt;/code&gt; 。这是在非Windows平台上围绕&lt;a href=&quot;#copyDir,string,string&quot;&gt;copyDir&lt;/a&gt;和&lt;a href=&quot;#copyFileWithPermissions,string,string&quot;&gt;copyFileWithPermissions&lt;/a&gt;过程的包装过程。</target>
        </trans-unit>
        <trans-unit id="fa135c30bca2146e78a4a18c707a6e4c9777b26c" translate="yes" xml:space="preserve">
          <source>If this fails, &lt;em&gt;OSError&lt;/em&gt; is raised. On the Windows platform this proc will copy the attributes from &lt;em&gt;source&lt;/em&gt; into &lt;em&gt;dest&lt;/em&gt;. On other platforms created files and directories will inherit the default permissions of a newly created file/directory for the user. To preserve attributes recursively on these platforms use &lt;a href=&quot;#copyDirWithPermissions&quot;&gt;copyDirWithPermissions()&lt;/a&gt;.</source>
          <target state="translated">如果失败，则引发&lt;em&gt;OSError&lt;/em&gt;。在Windows平台上，此proc会将属性从&lt;em&gt;源&lt;/em&gt;复制到&lt;em&gt;dest&lt;/em&gt;。在其他平台上，创建的文件和目录将为用户继承新创建的文件/目录的默认权限。要在这些平台上递归保留属性，请使用&lt;a href=&quot;#copyDirWithPermissions&quot;&gt;copyDirWithPermissions（）&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9ba7406fce433f75c1da2d28edafd72b5ca2511c" translate="yes" xml:space="preserve">
          <source>If this fails, &lt;em&gt;OSError&lt;/em&gt; is raised. On the Windows platform this proc will copy the source file's attributes into dest. On other platforms you need to use &lt;a href=&quot;#getFilePermissions&quot;&gt;getFilePermissions()&lt;/a&gt; and &lt;a href=&quot;#setFilePermissions&quot;&gt;setFilePermissions()&lt;/a&gt; to copy them by hand (or use the convenience &lt;a href=&quot;#copyFileWithPermissions&quot;&gt;copyFileWithPermissions()&lt;/a&gt; proc), otherwise &lt;em&gt;dest&lt;/em&gt; will inherit the default permissions of a newly created file for the user. If &lt;em&gt;dest&lt;/em&gt; already exists, the file attributes will be preserved and the content overwritten.</source>
          <target state="translated">如果失败，则引发&lt;em&gt;OSError&lt;/em&gt;。在Windows平台上，此proc将把源文件的属性复制到dest。在其他平台上，您需要使用&lt;a href=&quot;#getFilePermissions&quot;&gt;getFilePermissions（）&lt;/a&gt;和&lt;a href=&quot;#setFilePermissions&quot;&gt;setFilePermissions（）&lt;/a&gt;手动复制它们（或使用便捷的&lt;a href=&quot;#copyFileWithPermissions&quot;&gt;copyFileWithPermissions（）&lt;/a&gt; proc），否则&lt;em&gt;dest&lt;/em&gt;将为用户继承新创建文件的默认权限。如果&lt;em&gt;dest&lt;/em&gt;已经存在，则将保留文件属性，并覆盖内容。</target>
        </trans-unit>
        <trans-unit id="1c44eb8131bad6bf3fd6310d51476fb0e8f9dddf" translate="yes" xml:space="preserve">
          <source>If this fails, &lt;em&gt;OSError&lt;/em&gt; is raised. This does not fail if the directory never existed in the first place.</source>
          <target state="translated">如果失败，则引发&lt;em&gt;OSError&lt;/em&gt;。如果目录从不存在，这不会失败。</target>
        </trans-unit>
        <trans-unit id="b23ad4f30781ff872aab84374d7929409d46858b" translate="yes" xml:space="preserve">
          <source>If this fails, &lt;em&gt;OSError&lt;/em&gt; is raised. This is a wrapper proc around &lt;a href=&quot;#copyDir&quot;&gt;copyDir()&lt;/a&gt; and &lt;a href=&quot;#copyFileWithPermissions&quot;&gt;copyFileWithPermissions()&lt;/a&gt; on non Windows platforms. On Windows this proc is just a wrapper for &lt;a href=&quot;#copyDir&quot;&gt;copyDir()&lt;/a&gt; since that proc already copies attributes.</source>
          <target state="translated">如果失败，则引发&lt;em&gt;OSError&lt;/em&gt;。这是在非Windows平台上围绕&lt;a href=&quot;#copyDir&quot;&gt;copyDir（）&lt;/a&gt;和&lt;a href=&quot;#copyFileWithPermissions&quot;&gt;copyFileWithPermissions（）&lt;/a&gt;的包装过程。在Windows上，此proc只是&lt;a href=&quot;#copyDir&quot;&gt;copyDir（）&lt;/a&gt;的包装，因为该proc已经复制了属性。</target>
        </trans-unit>
        <trans-unit id="cb287e8ff379b2457a8e2d4d6e6de03aeec15e42" translate="yes" xml:space="preserve">
          <source>If this fails, returns &lt;code&gt;false&lt;/code&gt;. This does not fail if the file never existed in the first place.</source>
          <target state="translated">如果失败，则返回 &lt;code&gt;false&lt;/code&gt; 。如果文件从不存在，这不会失败。</target>
        </trans-unit>
        <trans-unit id="9eb3bbfbdd505f581fd217138a1e2152f6288922" translate="yes" xml:space="preserve">
          <source>If using enums and sets with C, use distinct cint.</source>
          <target state="translated">如果在C中使用枚举和集合,请使用不同的cint。</target>
        </trans-unit>
        <trans-unit id="8e140d916a532f239410b33165a6a9a6d5019f98" translate="yes" xml:space="preserve">
          <source>If we have a prefix, only symbols matching this prefix are returned and nothing else.</source>
          <target state="translated">如果我们有一个前缀,那么只返回与这个前缀相匹配的符号,而不是其他。</target>
        </trans-unit>
        <trans-unit id="f7fa0a4eec37fe2182192ec1daf3f2c74cec8c1f" translate="yes" xml:space="preserve">
          <source>If we have no prefix, consider the context. We currently distinguish between type and non-type contexts.</source>
          <target state="translated">如果我们没有前缀,就考虑上下文。目前我们区分了类型上下文和非类型上下文。</target>
        </trans-unit>
        <trans-unit id="c9a699519eb4bcfd6e9b388099f313da1c21a6c3" translate="yes" xml:space="preserve">
          <source>If we use &lt;code&gt;from ... import&lt;/code&gt;, the result is different, too.</source>
          <target state="translated">如果我们使用 &lt;code&gt;from ... import&lt;/code&gt; ，结果也将不同。</target>
        </trans-unit>
        <trans-unit id="85374d14a596c8e9c56292b195027162f71fdc93" translate="yes" xml:space="preserve">
          <source>If we use &lt;code&gt;generateXML&lt;/code&gt; code shown above and call the SCF file &lt;code&gt;xmlGen.nimf&lt;/code&gt; In your &lt;code&gt;main.nim&lt;/code&gt;:</source>
          <target state="translated">如果我们使用 &lt;code&gt;generateXML&lt;/code&gt; 代码如上图所示，并调用SCF文件 &lt;code&gt;xmlGen.nimf&lt;/code&gt; 在你 &lt;code&gt;main.nim&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="6d41cc53a37945c747c32e0bc6d03f91d352c9cd" translate="yes" xml:space="preserve">
          <source>If you are using simple standard types like &lt;code&gt;int&lt;/code&gt; or &lt;code&gt;string&lt;/code&gt; for the keys of the table you won't have any problems, but as soon as you try to use a more complex object as a key you will be greeted by a strange compiler error:</source>
          <target state="translated">如果您使用简单的标准类型（例如 &lt;code&gt;int&lt;/code&gt; 或 &lt;code&gt;string&lt;/code&gt; )作为表的键，则不会有任何问题，但是，一旦尝试将更复杂的对象用作键，就会遇到奇怪的编译器错误：</target>
        </trans-unit>
        <trans-unit id="a61618067feb2692a61a1309fe70a37f092e0dcd" translate="yes" xml:space="preserve">
          <source>If you don't want to run all the test case files you can pass any substring as a parameter to &lt;code&gt;caasdriver&lt;/code&gt;. Only files matching the passed substring will be run. The filtering doesn't use any globbing metacharacters, it's a plain match. For example, to run only &lt;code&gt;*-compile*.txt&lt;/code&gt; tests in verbose mode:</source>
          <target state="translated">如果您不想运行所有测试用例文件，则可以将任何子字符串作为参数传递给 &lt;code&gt;caasdriver&lt;/code&gt; 。只有与传递的子字符串匹配的文件才会运行。过滤不使用任何全局元字符，这是简单匹配。例如，仅以详细模式运行 &lt;code&gt;*-compile*.txt&lt;/code&gt; 测试：</target>
        </trans-unit>
        <trans-unit id="3b65c5702c4312fa92bc7a7a75f7b1cedc2ffdcc" translate="yes" xml:space="preserve">
          <source>If you hyper link a plain name symbol and there are other matches on the same HTML file, most browsers will go to the first one. To differentiate the rest, you will need to use the complex name. A complex name for a callable type is made up from several parts:</source>
          <target state="translated">如果你超链接一个纯名符号,而同一HTML文件上还有其他匹配的符号,大多数浏览器会转到第一个。为了区分其他的符号,您需要使用复名。一个可调用类型的复名是由几个部分组成的。</target>
        </trans-unit>
        <trans-unit id="d77f4e6941e6c25de4bc7bce05e47c82dde3f100" translate="yes" xml:space="preserve">
          <source>If you know what you're doing, you can also mark single string (or sequence) objects as &lt;span id=&quot;shallow_1&quot;&gt;shallow&lt;/span&gt;:</source>
          <target state="translated">如果您知道自己在做什么，还可以将单个字符串（或序列）对象标记为&amp;ldquo; &lt;span id=&quot;shallow_1&quot;&gt;浅&amp;rdquo;&lt;/span&gt;：</target>
        </trans-unit>
        <trans-unit id="7f6fcefa9ef0d5435edf3a86b98d9d16169b1981" translate="yes" xml:space="preserve">
          <source>If you know what you're doing, you can also mark single-string (or sequence) objects as &lt;span id=&quot;shallow_1&quot;&gt;shallow&lt;/span&gt;:</source>
          <target state="translated">如果您知道自己在做什么，还可以将单字符串（或序列）对象标记为&amp;ldquo;&lt;span id=&quot;shallow_1&quot;&gt;浅&amp;rdquo;&lt;/span&gt;：</target>
        </trans-unit>
        <trans-unit id="5c5621699cffb5f6aa7c0cfe6aad046283804e80" translate="yes" xml:space="preserve">
          <source>If you need a asynchronous server socket but you wish to process the clients synchronously then you can use the &lt;code&gt;getSocket&lt;/code&gt; converter to get a &lt;code&gt;Socket&lt;/code&gt; from the &lt;code&gt;AsyncSocket&lt;/code&gt; object, this can then be combined with &lt;code&gt;accept&lt;/code&gt; like so:</source>
          <target state="translated">如果需要异步服务器套接字，但希望同步处理客户端，则可以使用 &lt;code&gt;getSocket&lt;/code&gt; 转换器从 &lt;code&gt;AsyncSocket&lt;/code&gt; 对象获取 &lt;code&gt;Socket&lt;/code&gt; ，然后可以将其与 &lt;code&gt;accept&lt;/code&gt; 结合使用，如下所示：</target>
        </trans-unit>
        <trans-unit id="26b3c92840208778fb540b88ba9546be00de2473" translate="yes" xml:space="preserve">
          <source>If you need a permanent change, use the &lt;a href=&quot;#cd,string&quot;&gt;cd()&lt;/a&gt; proc. Usage example:</source>
          <target state="translated">如果需要永久更改，请使用&lt;a href=&quot;#cd,string&quot;&gt;cd（）&lt;/a&gt; proc。用法示例：</target>
        </trans-unit>
        <trans-unit id="e5c9b3765a26fdae2f51885e93ddca25dc0ccca4" translate="yes" xml:space="preserve">
          <source>If you need a sequence with the elements you can use &lt;a href=&quot;sequtils#toSeq.t,untyped&quot;&gt;sequtils.toSeq template&lt;/a&gt;.</source>
          <target state="translated">如果需要带有元素的序列，则可以使用&lt;a href=&quot;sequtils#toSeq.t,untyped&quot;&gt;sequtils.toSeq模板&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="006ed832ed732b3be5a2f86089a58493d5e5cace" translate="yes" xml:space="preserve">
          <source>If you need a sequence with the keys you can use &lt;a href=&quot;sequtils#toSeq&quot;&gt;sequtils.toSeq()&lt;/a&gt; on the iterator. Usage example:</source>
          <target state="translated">如果需要带有键的序列，则可以在迭代器上使用&lt;a href=&quot;sequtils#toSeq&quot;&gt;sequtils.toSeq（）&lt;/a&gt;。用法示例：</target>
        </trans-unit>
        <trans-unit id="5a8d301a71c9a03ca0fcbfc1bd1fbb38ac2c4793" translate="yes" xml:space="preserve">
          <source>If you need more elaborate waiting, you have to use an explicit barrier.</source>
          <target state="translated">如果你需要更复杂的等待,你必须使用一个明确的障碍。</target>
        </trans-unit>
        <trans-unit id="33cbb4e4f9774399c5110d17e6f93b09e6789def" translate="yes" xml:space="preserve">
          <source>If you need to &lt;em&gt;access&lt;/em&gt; the actual exception object or message inside an &lt;code&gt;except&lt;/code&gt; branch you can use the &lt;a href=&quot;system#getCurrentException&quot;&gt;getCurrentException()&lt;/a&gt; and &lt;a href=&quot;system#getCurrentExceptionMsg&quot;&gt;getCurrentExceptionMsg()&lt;/a&gt; procs from the &lt;a href=&quot;system&quot;&gt;system&lt;/a&gt; module. Example:</source>
          <target state="translated">如果您需要&lt;em&gt;访问&lt;/em&gt;内部的实际的异常对象或消息 &lt;code&gt;except&lt;/code&gt; 分支您可以使用&lt;a href=&quot;system#getCurrentException&quot;&gt;getCurrentException（）&lt;/a&gt;和&lt;a href=&quot;system#getCurrentExceptionMsg&quot;&gt;getCurrentExceptionMsg（）&lt;/a&gt;特效从&lt;a href=&quot;system&quot;&gt;系统&lt;/a&gt;模块。例：</target>
        </trans-unit>
        <trans-unit id="369d846e4c1b566404807c8b598a810efa4157ad" translate="yes" xml:space="preserve">
          <source>If you need to allow the rst &lt;code&gt;include&lt;/code&gt; directive or tweak the generated output you have to create your own &lt;code&gt;RstGenerator&lt;/code&gt; with &lt;code&gt;initRstGenerator&lt;/code&gt; and related procs.</source>
          <target state="translated">如果需要允许rst &lt;code&gt;include&lt;/code&gt; 指令或调整生成的输出，则必须使用 &lt;code&gt;initRstGenerator&lt;/code&gt; 和相关 &lt;code&gt;RstGenerator&lt;/code&gt; 创建自己的RstGenerator。</target>
        </trans-unit>
        <trans-unit id="6e0f3b7f2a6e094f5e44833f3b6b6ef4c156c0ee" translate="yes" xml:space="preserve">
          <source>If you need to create multiple identifiers you need to use the lower level &lt;code&gt;newNimNode&lt;/code&gt;:</source>
          <target state="translated">如果需要创建多个标识符，则需要使用较低级别的 &lt;code&gt;newNimNode&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="d0579aebab140b65d01d9ce28fdabf2191699ecf" translate="yes" xml:space="preserve">
          <source>If you need to pass around memory allocated by Nim to C, you can use the procs &lt;code&gt;GC_ref&lt;/code&gt; and &lt;code&gt;GC_unref&lt;/code&gt; to mark objects as referenced to avoid them being freed by the GC. Other useful procs from &lt;a href=&quot;system&quot;&gt;system&lt;/a&gt; you can use to keep track of memory are:</source>
          <target state="translated">如果需要将Nim分配的内存传递给C，则可以使用procs &lt;code&gt;GC_ref&lt;/code&gt; 和 &lt;code&gt;GC_unref&lt;/code&gt; 将对象标记为引用对象，以免GC释放它们。您可以用来跟踪内存的&lt;a href=&quot;system&quot;&gt;系统中&lt;/a&gt;其他有用的过程是：</target>
        </trans-unit>
        <trans-unit id="a716ba6d4ad79bc9608a8987c0c272c9d2a66e45" translate="yes" xml:space="preserve">
          <source>If you need to pass around memory allocated by Nim to C, you can use the procs &lt;code&gt;GC_ref&lt;/code&gt; and &lt;code&gt;GC_unref&lt;/code&gt; to mark objects as referenced to avoid them being freed by the garbage collector. Other useful procs from &lt;a href=&quot;system&quot;&gt;system&lt;/a&gt; you can use to keep track of memory are:</source>
          <target state="translated">如果需要将Nim分配的内存传递给C，则可以使用procs &lt;code&gt;GC_ref&lt;/code&gt; 和 &lt;code&gt;GC_unref&lt;/code&gt; 将对象标记为已引用，以避免垃圾回收器释放它们。您可以用来跟踪内存的&lt;a href=&quot;system&quot;&gt;系统中&lt;/a&gt;其他有用的过程包括：</target>
        </trans-unit>
        <trans-unit id="148b5ae6727551a8708027a1f900d39f713f26b5" translate="yes" xml:space="preserve">
          <source>If you start with an unsorted array/seq, the repeated permutations will &lt;strong&gt;not&lt;/strong&gt; give you all permutations but stop with last.</source>
          <target state="translated">如果您以未排序的数组/序列开头，则重复的排列将&lt;strong&gt;不会&lt;/strong&gt;为您提供所有排列，而是以最后一个结束。</target>
        </trans-unit>
        <trans-unit id="5af2edf06f6b1a44ed06899aac7fe78217a6197e" translate="yes" xml:space="preserve">
          <source>If you use &lt;a href=&quot;#toMD5,string&quot;&gt;toMD5 proc&lt;/a&gt; there's no need to call this function explicitly.</source>
          <target state="translated">如果使用&lt;a href=&quot;#toMD5,string&quot;&gt;toMD5 proc，&lt;/a&gt;则无需显式调用此函数。</target>
        </trans-unit>
        <trans-unit id="605d3be2a51e005f46c2c854f15f5f73980b42f0" translate="yes" xml:space="preserve">
          <source>If you use Nim's flexible calling syntax (as in &lt;code&gt;x.len()&lt;/code&gt;), the result is the same as above but wrapped in an &lt;code&gt;nnkCall&lt;/code&gt;.</source>
          <target state="translated">如果使用Nim的灵活调用语法（如 &lt;code&gt;x.len()&lt;/code&gt; 所示），则结果与上面相同，但包装在 &lt;code&gt;nnkCall&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="eaabbf0881b8169255900fc2e0a496ccef7b23be" translate="yes" xml:space="preserve">
          <source>If you use this function, you don't need to use asyncdispatch.recv() or asyncdispatch.accept(), because they are using IOCP, please use nativesockets.recv() and nativesockets.accept() instead.</source>
          <target state="translated">如果你使用这个函数,你不需要使用asyncdispatch.recv()或asyncdispatch.accept(),因为它们使用的是IOCP,请使用nativesockets.recv()和nativesockets.accept()代替。</target>
        </trans-unit>
        <trans-unit id="1badf00dcf0f3800f03821ebc8ea8986cacd6adb" translate="yes" xml:space="preserve">
          <source>If you use this function, you don't need to use asyncdispatch.send() or asyncdispatch.connect(), because they are using IOCP, please use nativesockets.send() and nativesockets.connect() instead.</source>
          <target state="translated">如果你使用这个函数,你不需要使用asyncdispatch.send()或asyncdispatch.connect(),因为它们使用的是IOCP,请使用nativesockets.send()和nativesockets.connect()代替。</target>
        </trans-unit>
        <trans-unit id="cac223c9791d80e68510ee018f308f5d57991c7e" translate="yes" xml:space="preserve">
          <source>If you want to add the &lt;code&gt;{.raises.}&lt;/code&gt; pragma to existing code, the compiler can also help you. You can add the &lt;code&gt;{.effects.}&lt;/code&gt; pragma statement to your proc and the compiler will output all inferred effects up to that point (exception tracking is part of Nim's effect system). Another more roundabout way to find out the list of exceptions raised by a proc is to use the Nim &lt;code&gt;doc2&lt;/code&gt; command which generates documentation for a whole module and decorates all procs with the list of raised exceptions. You can read more about Nim's &lt;a href=&quot;manual#effect-system&quot;&gt;effect system and related pragmas in the manual&lt;/a&gt;.</source>
          <target state="translated">如果要将 &lt;code&gt;{.raises.}&lt;/code&gt; 注添加到现有代码中，编译器也可以为您提供帮助。您可以在您的proc中添加 &lt;code&gt;{.effects.}&lt;/code&gt; pragma语句，然后编译器将输出所有推断的效果，直到这一点为止（异常跟踪是Nim效果系统的一部分）。找出proc引发的异常列表的另一种回旋方式是使用Nim &lt;code&gt;doc2&lt;/code&gt; 命令，该命令为整个模块生成文档，并用引发的异常列表装饰所有proc 。您可以&lt;a href=&quot;manual#effect-system&quot;&gt;在手册中&lt;/a&gt;详细了解Nim的效果系统和相关的语用。</target>
        </trans-unit>
        <trans-unit id="d0c0f4c00b1012d51fb6739c3f68752cf2b7b509" translate="yes" xml:space="preserve">
          <source>If you want to implement hash procs for your custom types you will end up writing the following kind of skeleton of code:</source>
          <target state="translated">如果你想为你的自定义类型实现哈希程序,你最终会写出以下的代码骨架。</target>
        </trans-unit>
        <trans-unit id="24263f42f3ba40007e49da841b6c42f49b268438" translate="yes" xml:space="preserve">
          <source>If you want to implement hash procs for your custom types, you will end up writing the following kind of skeleton of code:</source>
          <target state="translated">如果你想为你的自定义类型实现哈希程序,你将最终写出以下类型的代码骨架。</target>
        </trans-unit>
        <trans-unit id="421d4b3269fa42e83ec4575e39cc5f8f9348120c" translate="yes" xml:space="preserve">
          <source>If you want to reset the state of a global variable on each reload, just re-assign a value anywhere within the top-level code:</source>
          <target state="translated">如果你想在每次重载时重置全局变量的状态,只需在顶层代码的任何地方重新分配一个值即可。</target>
        </trans-unit>
        <trans-unit id="95147b50335541913ec2b4cdcd60beea22400d5c" translate="yes" xml:space="preserve">
          <source>If you want to reuse this feature in your own documentation you will have to modify &lt;code&gt;config/nimdoc.cfg&lt;/code&gt; to contain a &lt;code&gt;doc.item.seesrc&lt;/code&gt; value with a hyper link to your own code repository. As you will see by the comments in that file, the value &lt;code&gt;txt&lt;/code&gt; passed on the command line will be used in the HTML template along others like &lt;code&gt;$path&lt;/code&gt; and &lt;code&gt;$line&lt;/code&gt;.</source>
          <target state="translated">如果要在自己的文档中重用此功能，则必须修改 &lt;code&gt;config/nimdoc.cfg&lt;/code&gt; 以包含 &lt;code&gt;doc.item.seesrc&lt;/code&gt; 值，并带有指向自己代码存储库的超链接。正如您在该文件中的注释所看到的那样，在命令行中传递的 &lt;code&gt;txt&lt;/code&gt; 值将与其他 &lt;code&gt;$path&lt;/code&gt; 和 &lt;code&gt;$line&lt;/code&gt; 一起在HTML模板中使用。</target>
        </trans-unit>
        <trans-unit id="52843b664ac77e24f197735860350aeff2499277" translate="yes" xml:space="preserve">
          <source>If you want to start the server using stdin/stdout as communication you need to type:</source>
          <target state="translated">如果你想使用stdin/stdout作为通讯方式启动服务器,你需要输入。</target>
        </trans-unit>
        <trans-unit id="5faec14ac2e7f3a0dbf5ac1fc6670f916e429298" translate="yes" xml:space="preserve">
          <source>If you want to start the server using tcp and a port, you need to type:</source>
          <target state="translated">如果你想使用tcp和端口启动服务器,你需要输入。</target>
        </trans-unit>
        <trans-unit id="0e57ef06f554ec131431cf7cc7b3e87b3087eb9a" translate="yes" xml:space="preserve">
          <source>If you would like to remove the callback simply set it to &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">如果您想删除回调，只需将其设置为 &lt;code&gt;nil&lt;/code&gt; 即可。</target>
        </trans-unit>
        <trans-unit id="af0996b6e01e303c65f963b0e8fbe7eeea90dc53" translate="yes" xml:space="preserve">
          <source>If your custom types contain fields for which there already is a hash proc, like for example objects made up of &lt;code&gt;strings&lt;/code&gt;, you can simply hash together the hash value of the individual fields:</source>
          <target state="translated">如果您的自定义类型包含已经存在哈希处理的字段，例如由 &lt;code&gt;strings&lt;/code&gt; 组成的对象，则可以简单地将各个字段的哈希值哈希在一起：</target>
        </trans-unit>
        <trans-unit id="7b221d885e608a822eb4dd77455f03fffdf220cc" translate="yes" xml:space="preserve">
          <source>If your platform does not provide these functions it should be trivial to provide an implementation for them and link these to your program.</source>
          <target state="translated">如果你的平台没有提供这些功能,那么为它们提供一个实现并将其链接到你的程序中应该是很简单的。</target>
        </trans-unit>
        <trans-unit id="11a6540e806b12db45a31546a098431a84108a29" translate="yes" xml:space="preserve">
          <source>IgnoreCC:</source>
          <target state="translated">IgnoreCC:</target>
        </trans-unit>
        <trans-unit id="4aadbcf0bb321d44f7f560f38b96c7cecee80738" translate="yes" xml:space="preserve">
          <source>IgnoreTupleFields:</source>
          <target state="translated">IgnoreTupleFields:</target>
        </trans-unit>
        <trans-unit id="ee7d8473b3b03509d036a9e18c0f69477806dbbf" translate="yes" xml:space="preserve">
          <source>Ignoring the return value of a procedure without using a discard statement is a static error.</source>
          <target state="translated">忽略存储过程的返回值而不使用丢弃语句是一个静态错误。</target>
        </trans-unit>
        <trans-unit id="234aba6f014c3210479a86e1f7e85db4fc781aa3" translate="yes" xml:space="preserve">
          <source>Implementation Specific Pragmas</source>
          <target state="translated">具体实施方法</target>
        </trans-unit>
        <trans-unit id="81ebe12aa11cc123fdb7f8c88133ffaff6347b23" translate="yes" xml:space="preserve">
          <source>Implementation details</source>
          <target state="translated">实施细节</target>
        </trans-unit>
        <trans-unit id="e4c1e2458dab48a54a1e7f70dcc8c85f1ecef51b" translate="yes" xml:space="preserve">
          <source>Implementation of a &lt;span id=&quot;deque_1&quot;&gt;deque&lt;/span&gt; (double-ended queue). The underlying implementation uses a &lt;code&gt;seq&lt;/code&gt;.</source>
          <target state="translated">实现&lt;span id=&quot;deque_1&quot;&gt;双端队列&lt;/span&gt;（双端队列）。基础实现使用 &lt;code&gt;seq&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2b7a46b17c56770ce055c6ddb62375ac14462a9c" translate="yes" xml:space="preserve">
          <source>Implementation of singly and doubly linked lists. Because it makes no sense to do so, the 'next' and 'prev' pointers are not hidden from you and can be manipulated directly for efficiency.</source>
          <target state="translated">单链和双链列表的实现。因为这样做没有意义,所以'next'和'prev'指针不会被你隐藏,可以直接操作,提高效率。</target>
        </trans-unit>
        <trans-unit id="ebf8259b50eb672a953fe5e9182a91f7012116d5" translate="yes" xml:space="preserve">
          <source>Implementation of the check that &lt;code&gt;recover&lt;/code&gt; needs, see &lt;a href=&quot;https://github.com/nim-lang/RFCs/issues/244&quot;&gt;https://github.com/nim-lang/RFCs/issues/244&lt;/a&gt; for more details.</source>
          <target state="translated">&lt;code&gt;recover&lt;/code&gt; 需求检查的实现，请参阅&lt;a href=&quot;https://github.com/nim-lang/RFCs/issues/244&quot;&gt;https://github.com/nim-lang/RFCs/issues/244&lt;/a&gt;了解更多详细信息。</target>
        </trans-unit>
        <trans-unit id="6d4e9bd4bbca2e0729767fd4dd71bc8dfb1e6eec" translate="yes" xml:space="preserve">
          <source>Implementation of the command line parser.</source>
          <target state="translated">命令行解析器的实现。</target>
        </trans-unit>
        <trans-unit id="b22d7898babb0b43f69334c0a5efe09a2b8e7018" translate="yes" xml:space="preserve">
          <source>Implementation of:</source>
          <target state="translated">实施:</target>
        </trans-unit>
        <trans-unit id="a6c736db4db506401e673a9f4f1f349ad3e618b7" translate="yes" xml:space="preserve">
          <source>Implements Nim's 'spawn'.</source>
          <target state="translated">实施尼姆的 &quot;产卵&quot;。</target>
        </trans-unit>
        <trans-unit id="9bd1639b0652a75be41ded9fcf655fff747ec529" translate="yes" xml:space="preserve">
          <source>Implements Nim's &lt;a href=&quot;manual_experimental#parallel-amp-spawn&quot;&gt;spawn&lt;/a&gt;.</source>
          <target state="translated">实现Nim的&lt;a href=&quot;manual_experimental#parallel-amp-spawn&quot;&gt;spawn&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="fcc2133e32a735f3f33a5134e088577045119220" translate="yes" xml:space="preserve">
          <source>Implements a representation of Unicode with the limited ASCII character subset.</source>
          <target state="translated">用有限的ASCII字符子集实现Unicode的表示。</target>
        </trans-unit>
        <trans-unit id="a98bff4e5a957f15674cfda3f7cc2d9c63fef8d1" translate="yes" xml:space="preserve">
          <source>Implements an iterator which, when called repeatedly, returns the next top-level statement or emptyNode if end of stream.</source>
          <target state="translated">实现一个迭代器,当重复调用时,返回下一个顶层语句,如果流结束,则返回 emptyNode。</target>
        </trans-unit>
        <trans-unit id="b8d8bec9622c1c2efe7cbb87c656d2ee4e52f3f9" translate="yes" xml:space="preserve">
          <source>Implements marshaling for the VM.</source>
          <target state="translated">为虚拟机实施marshaling。</target>
        </trans-unit>
        <trans-unit id="ab186fe958c9515dc4682be825a79c4504cec277" translate="yes" xml:space="preserve">
          <source>Implements some helper procs for Nimble (Nim's package manager) support.</source>
          <target state="translated">为Nimble (Nim的包管理器)实施一些辅助程序。</target>
        </trans-unit>
        <trans-unit id="bde737fdbb85e35a06847480351be43a531285da" translate="yes" xml:space="preserve">
          <source>Implements the dispatcher for the different parsers.</source>
          <target state="translated">实施不同解析器的调度器。</target>
        </trans-unit>
        <trans-unit id="0e08fdde0cb22bad986cf922e162257fc105db33" translate="yes" xml:space="preserve">
          <source>Implements the module handling, including the caching of modules.</source>
          <target state="translated">实现模块处理,包括模块的缓存。</target>
        </trans-unit>
        <trans-unit id="b16e5331a0e8818de21a9814ad59e5ec8b5fc322" translate="yes" xml:space="preserve">
          <source>Implements the new configuration system for Nim. Uses Nim as a scripting language.</source>
          <target state="translated">为Nim实施新的配置系统。使用Nim作为脚本语言。</target>
        </trans-unit>
        <trans-unit id="c34284c7e697106a3a469f02b4020f23a7391954" translate="yes" xml:space="preserve">
          <source>Implements type sanity checking for ASTs resulting from macros. Lots of room for improvement here.</source>
          <target state="translated">实现对宏产生的AST的类型约束性检查。这里有很多需要改进的地方。</target>
        </trans-unit>
        <trans-unit id="2cb0d65e090ee41d0e4de59b229ce10d50db7a16" translate="yes" xml:space="preserve">
          <source>Implicit conversions are also performed for Nim's &lt;code&gt;range&lt;/code&gt; type constructor.</source>
          <target state="translated">还对Nim的 &lt;code&gt;range&lt;/code&gt; 类型构造函数执行隐式转换。</target>
        </trans-unit>
        <trans-unit id="5b6604e9fb39f02f35b5c6da5cdcf2e3e926fc60" translate="yes" xml:space="preserve">
          <source>Implicit generics</source>
          <target state="translated">隐含的代名词</target>
        </trans-unit>
        <trans-unit id="c85b8f323c721c3d94c6bf3a4189d897091a2f86" translate="yes" xml:space="preserve">
          <source>Implicit items/pairs invocations</source>
          <target state="translated">隐式项目/对子的调用</target>
        </trans-unit>
        <trans-unit id="36d95a1a4e4b67185b0210fb79bcd67e7997dd49" translate="yes" xml:space="preserve">
          <source>Implict items/pairs invocations</source>
          <target state="translated">隐含的项目/对子的调用</target>
        </trans-unit>
        <trans-unit id="3ed691724b16d193322f0f4e5a05ffaa21ad149b" translate="yes" xml:space="preserve">
          <source>Import section</source>
          <target state="translated">进口部分</target>
        </trans-unit>
        <trans-unit id="e1814134be9eb4b4edfac453d80420ef792ece15" translate="yes" xml:space="preserve">
          <source>Import statement</source>
          <target state="translated">进口声明</target>
        </trans-unit>
        <trans-unit id="13f50b27b1067e54a93395faae2bf7e5ac61b5af" translate="yes" xml:space="preserve">
          <source>ImportCpp pragma</source>
          <target state="translated">ImportCpp pragma</target>
        </trans-unit>
        <trans-unit id="89cca234c1c2121d46146205b0c1e5f783e9d794" translate="yes" xml:space="preserve">
          <source>ImportJs pragma</source>
          <target state="translated">ImportJs pragma</target>
        </trans-unit>
        <trans-unit id="1a87c0305fa3a21d3483f32794feeb2ede2ded57" translate="yes" xml:space="preserve">
          <source>ImportObjC pragma</source>
          <target state="translated">ImportObjC pragma</target>
        </trans-unit>
        <trans-unit id="b131713cc5dd52d93c263e9eaa3064820c90d46d" translate="yes" xml:space="preserve">
          <source>Importc pragma</source>
          <target state="translated">Importc pragma</target>
        </trans-unit>
        <trans-unit id="26fce7795dc194794340bfe9430c05967fd0f0b6" translate="yes" xml:space="preserve">
          <source>Importcpp for enums</source>
          <target state="translated">为enums导入cpp</target>
        </trans-unit>
        <trans-unit id="13bc024961b54b45de0538df5d4d8a1057ce09e2" translate="yes" xml:space="preserve">
          <source>Importcpp for objects</source>
          <target state="translated">导入对象的cpp</target>
        </trans-unit>
        <trans-unit id="c0f89463b661b1c831d73789e1f9b7febf176bb2" translate="yes" xml:space="preserve">
          <source>Importcpp for procs</source>
          <target state="translated">为procs导入cpp</target>
        </trans-unit>
        <trans-unit id="2a87ed2bec73f0f4c4783390b3b8eb37f3539383" translate="yes" xml:space="preserve">
          <source>Imported exceptions</source>
          <target state="translated">进口的例外情况</target>
        </trans-unit>
        <trans-unit id="e42328ac01cd03a47978f064c93b392caf3861f0" translate="yes" xml:space="preserve">
          <source>Imports</source>
          <target state="translated">Imports</target>
        </trans-unit>
        <trans-unit id="651038eb78adfd6971475066b4835457bc4c8cee" translate="yes" xml:space="preserve">
          <source>Imports a node from another document to this document</source>
          <target state="translated">将一个节点从另一个文档导入到这个文档。</target>
        </trans-unit>
        <trans-unit id="c57c28d05a963f62cc6e0646415b874f5ec5d460" translate="yes" xml:space="preserve">
          <source>Impure libraries</source>
          <target state="translated">不纯的图书馆</target>
        </trans-unit>
        <trans-unit id="76eed90bbf51f40c5cdfe6ef9d9c1bd9751546b4" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;f(...)&lt;/code&gt; (function call) hooks are generated for &lt;code&gt;typeof(f(...))&lt;/code&gt;.</source>
          <target state="translated">在 &lt;code&gt;f(...)&lt;/code&gt; （函数调用）中，将为 &lt;code&gt;typeof(f(...))&lt;/code&gt; 生成钩子。</target>
        </trans-unit>
        <trans-unit id="fd75085c09d97b8e3bec53c3d230c26383e2dd2b" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;if&lt;/code&gt; statements new scopes begin immediately after the &lt;code&gt;if&lt;/code&gt;/&lt;code&gt;elif&lt;/code&gt;/&lt;code&gt;else&lt;/code&gt; keywords and ends after the corresponding &lt;em&gt;then&lt;/em&gt; block. For visualization purposes the scopes have been enclosed in &lt;code&gt;{| |}&lt;/code&gt; in the following example:</source>
          <target state="translated">在 &lt;code&gt;if&lt;/code&gt; 语句中，新作用域在 &lt;code&gt;if&lt;/code&gt; / &lt;code&gt;elif&lt;/code&gt; / &lt;code&gt;else&lt;/code&gt; 关键字之后立即开始，并在相应的&lt;em&gt;then&lt;/em&gt;块之后结束。出于可视化目的，范围已包含在 &lt;code&gt;{| |}&lt;/code&gt; 在以下示例中：</target>
        </trans-unit>
        <trans-unit id="6e2bd3e8a5584dffb77d444423cb51fec6a6461a" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;x = ...&lt;/code&gt; (assignment) hooks are generated for &lt;code&gt;typeof(x)&lt;/code&gt;.</source>
          <target state="translated">在 &lt;code&gt;x = ...&lt;/code&gt; （赋值）中，将为 &lt;code&gt;typeof(x)&lt;/code&gt; 生成钩子。</target>
        </trans-unit>
        <trans-unit id="f8b317a37aea00acb6907f904d75b22bdcc1d94d" translate="yes" xml:space="preserve">
          <source>In Nim exceptions are objects. By convention, exception types are suffixed with 'Error'. The &lt;a href=&quot;system&quot;&gt;system&lt;/a&gt; module defines an exception hierarchy that you might want to stick to. Exceptions derive from &lt;code&gt;system.Exception&lt;/code&gt;, which provides the common interface.</source>
          <target state="translated">在Nim中，对象是例外。按照约定，异常类型的后缀为&amp;ldquo;错误&amp;rdquo;。该&lt;a href=&quot;system&quot;&gt;系统&lt;/a&gt;模块定义的异常层次结构，你可能要坚持到。异常来自提供公共接口的 &lt;code&gt;system.Exception&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9cd83e7d1b8675d5def27847af1a08b46fb4b887" translate="yes" xml:space="preserve">
          <source>In Nim it is possible to have a macro with the syntax of a &lt;em&gt;case-of&lt;/em&gt; expression just with the difference that all of branches are passed to and processed by the macro implementation. It is then up the macro implementation to transform the &lt;em&gt;of-branches&lt;/em&gt; into a valid Nim statement. The following example should show how this feature could be used for a lexical analyzer.</source>
          <target state="translated">在Nim中，可能有一个具有&lt;em&gt;case-of&lt;/em&gt;表达式语法的宏，只是所有分支都传递给该宏实现并由该宏实现处理而不同。然后是将宏&lt;em&gt;分支&lt;/em&gt;转换为有效的Nim语句的宏实现。下面的示例应说明如何将此功能用于词法分析器。</target>
        </trans-unit>
        <trans-unit id="bcd1f399e06fb598711f24d731eec160a7ac7612" translate="yes" xml:space="preserve">
          <source>In Nim new types can be defined within a &lt;code&gt;type&lt;/code&gt; statement:</source>
          <target state="translated">在Nim中，可以在 &lt;code&gt;type&lt;/code&gt; 语句中定义新的类型：</target>
        </trans-unit>
        <trans-unit id="b627b4840bb1e194f3e870e54e41a26eeaaa32b6" translate="yes" xml:space="preserve">
          <source>In Nim the compiler cannot always know if a reference is stored on the stack or not. This is caused by var parameters. Consider this example:</source>
          <target state="translated">在Nim中,编译器不能总是知道一个引用是否存储在堆栈上。这是由var参数造成的。考虑一下这个例子。</target>
        </trans-unit>
        <trans-unit id="3c1e31b69bdf6fd850da3e70033d8d8c55e35892" translate="yes" xml:space="preserve">
          <source>In Nim there is a distinction between &lt;em&gt;simple statements&lt;/em&gt; and &lt;em&gt;complex statements&lt;/em&gt;. &lt;em&gt;Simple statements&lt;/em&gt; cannot contain other statements: Assignment, procedure calls or the &lt;code&gt;return&lt;/code&gt; statement belong to the simple statements. &lt;em&gt;Complex statements&lt;/em&gt; like &lt;code&gt;if&lt;/code&gt;, &lt;code&gt;when&lt;/code&gt;, &lt;code&gt;for&lt;/code&gt;, &lt;code&gt;while&lt;/code&gt; can contain other statements. To avoid ambiguities, complex statements must always be indented, but single simple statements do not:</source>
          <target state="translated">在Nim中，&lt;em&gt;简单语句&lt;/em&gt;和&lt;em&gt;复杂语句&lt;/em&gt;之间是有区别的。&lt;em&gt;简单语句&lt;/em&gt;不能包含其他语句：赋值，过程调用或 &lt;code&gt;return&lt;/code&gt; 语句属于简单语句。诸如 &lt;code&gt;if&lt;/code&gt; ， &lt;code&gt;when&lt;/code&gt; ， &lt;code&gt;for&lt;/code&gt; ， &lt;code&gt;while&lt;/code&gt; 的&lt;em&gt;复杂语句&lt;/em&gt;可以包含其他语句。为避免歧义，复杂的语句必须始终缩进，但单个简单的语句则不能：</target>
        </trans-unit>
        <trans-unit id="d57f5186bf8c243d548cc3d53f7d506ffcb92873" translate="yes" xml:space="preserve">
          <source>In Nim, there is a redundant way to specify the type of an integer literal. First of all, it should be unsurprising that every node has a node kind. The node of an integer literal can be any of the following values:</source>
          <target state="translated">在Nim中,有一种多余的方式来指定一个整数文字的类型。首先,每一个节点都有一个节点种类,这一点应该不足为奇。一个整数文字的节点可以是以下任何一种值。</target>
        </trans-unit>
        <trans-unit id="36d31e1fe2a898ddbcb325dce9d25ddd964de3ec" translate="yes" xml:space="preserve">
          <source>In UTF-8 mode, characters with values greater than 128 never match &lt;code&gt;\d&lt;/code&gt;, &lt;code&gt;\s&lt;/code&gt;, or &lt;code&gt;\w&lt;/code&gt;, and always match &lt;code&gt;\D&lt;/code&gt;, &lt;code&gt;\S&lt;/code&gt;, and &lt;code&gt;\W&lt;/code&gt;. This is true even when Unicode character property support is available.</source>
          <target state="translated">在UTF-8模式下，其值大于128个字符永远不会匹配 &lt;code&gt;\d&lt;/code&gt; ， &lt;code&gt;\s&lt;/code&gt; ，或 &lt;code&gt;\w&lt;/code&gt; ，并总是匹配 &lt;code&gt;\D&lt;/code&gt; ， &lt;code&gt;\S&lt;/code&gt; ，和 &lt;code&gt;\W&lt;/code&gt; 。即使提供了Unicode字符属性支持，也是如此。</target>
        </trans-unit>
        <trans-unit id="3617947965a09e75ebe2e8b672a9f2c8fd3657b4" translate="yes" xml:space="preserve">
          <source>In a &lt;code&gt;var&lt;/code&gt; or &lt;code&gt;let&lt;/code&gt; statement tuple unpacking can be performed. The special identifier &lt;code&gt;_&lt;/code&gt; can be used to ignore some parts of the tuple:</source>
          <target state="translated">在 &lt;code&gt;var&lt;/code&gt; 或 &lt;code&gt;let&lt;/code&gt; 语句中，可以执行元组拆包。特殊标识符 &lt;code&gt;_&lt;/code&gt; 可用于忽略元组的某些部分：</target>
        </trans-unit>
        <trans-unit id="82817ac3f312f0760fba2fa577dfeca03d6206c4" translate="yes" xml:space="preserve">
          <source>In a call &lt;code&gt;p(args)&lt;/code&gt; the routine &lt;code&gt;p&lt;/code&gt; that matches best is selected. If multiple routines match equally well, the ambiguity is reported at compiletime.</source>
          <target state="translated">在调用 &lt;code&gt;p(args)&lt;/code&gt; 中，选择最匹配的例程 &lt;code&gt;p&lt;/code&gt; 。如果多个例程匹配得很好，则会在编译时报告歧义。</target>
        </trans-unit>
        <trans-unit id="f14b713b025417c0a4e34b72587925af836dc390" translate="yes" xml:space="preserve">
          <source>In a call &lt;code&gt;p(args)&lt;/code&gt; the routine &lt;code&gt;p&lt;/code&gt; that matches best is selected. If multiple routines match equally well, the ambiguity is reported during semantic analysis.</source>
          <target state="translated">在调用 &lt;code&gt;p(args)&lt;/code&gt; 中，选择最匹配的例程 &lt;code&gt;p&lt;/code&gt; 。如果多个例程匹配得很好，则在语义分析期间会报告歧义。</target>
        </trans-unit>
        <trans-unit id="12c9e01363343ad91c6333931ae770e8aef4dfbe" translate="yes" xml:space="preserve">
          <source>In a context with multiple overloads, the integer literal kind will always prefer the &lt;code&gt;int&lt;/code&gt; type over all other types. If none of the overloads is of type &lt;code&gt;int&lt;/code&gt;, then there will be an error because of ambiguity.</source>
          <target state="translated">在具有多个重载的上下文中，整数文字类型将始终比所有其他类型更喜欢 &lt;code&gt;int&lt;/code&gt; 类型。如果所有重载都不是 &lt;code&gt;int&lt;/code&gt; 类型，则由于歧义，将出现错误。</target>
        </trans-unit>
        <trans-unit id="6fc62f480a3f9078cee56fe51f6444a9d5250214" translate="yes" xml:space="preserve">
          <source>In a list of statements every expression except the last one needs to have the type &lt;code&gt;void&lt;/code&gt;. In addition to this rule an assignment to the builtin &lt;code&gt;result&lt;/code&gt; symbol also triggers a mandatory &lt;code&gt;void&lt;/code&gt; context for the subsequent expressions:</source>
          <target state="translated">在语句列表中，除最后一个表达式外，每个表达式都必须具有 &lt;code&gt;void&lt;/code&gt; 类型。除此规则外，对内置 &lt;code&gt;result&lt;/code&gt; 符号的赋值还会触发后续表达式的强制性 &lt;code&gt;void&lt;/code&gt; 上下文：</target>
        </trans-unit>
        <trans-unit id="488140be7cd1e3d7c93b424038a2aded23329152" translate="yes" xml:space="preserve">
          <source>In a multi-method all parameters that have an object type are used for the dispatching:</source>
          <target state="translated">在多方法中,所有具有对象类型的参数都会被用于调度。</target>
        </trans-unit>
        <trans-unit id="691482e2683e9f978caf9b0b633d8df4760325fa" translate="yes" xml:space="preserve">
          <source>In a typical Nim program, most of the code is compiled into the executable. However, some of the code may be executed at &lt;span id=&quot;compileminustime_1&quot;&gt;compile-time&lt;/span&gt;. This can include constant expressions, macro definitions, and Nim procedures used by macro definitions. Most of the Nim language is supported at compile-time, but there are some restrictions -- see &lt;a href=&quot;#restrictions-on-compileminustime-execution&quot;&gt;Restrictions on Compile-Time Execution&lt;/a&gt; for details. We use the term &lt;span id=&quot;runtime_1&quot;&gt;runtime&lt;/span&gt; to cover both compile-time execution and code execution in the executable.</source>
          <target state="translated">在典型的Nim程序中，大多数代码都被编译为可执行文件。但是，某些代码可能在&lt;span id=&quot;compileminustime_1&quot;&gt;编译时&lt;/span&gt;执行。这可以包括常量表达式，宏定义以及宏定义所使用的Nim过程。大多数Nim语言在编译时受支持，但是有一些限制-有关详细信息，请参见&lt;a href=&quot;#restrictions-on-compileminustime-execution&quot;&gt;编译时执行限制&lt;/a&gt;。我们使用&lt;span id=&quot;runtime_1&quot;&gt;运行时&lt;/span&gt;一词来涵盖可执行文件中的编译时执行和代码执行。</target>
        </trans-unit>
        <trans-unit id="51b365021e4df4ac8585444b431ae5bb9f1b96ec" translate="yes" xml:space="preserve">
          <source>In addition to &lt;code&gt;GC_ref&lt;/code&gt; and &lt;code&gt;GC_unref&lt;/code&gt; you can avoid the GC by manually allocating memory with procs like &lt;code&gt;alloc&lt;/code&gt;, &lt;code&gt;allocShared&lt;/code&gt;, or &lt;code&gt;allocCStringArray&lt;/code&gt;. The GC won't try to free them, you need to call their respective &lt;em&gt;dealloc&lt;/em&gt; pairs when you are done with them or they will leak.</source>
          <target state="translated">除了 &lt;code&gt;GC_ref&lt;/code&gt; 和 &lt;code&gt;GC_unref&lt;/code&gt; 您可以通过像特效手动分配内存避免了GC &lt;code&gt;alloc&lt;/code&gt; ， &lt;code&gt;allocShared&lt;/code&gt; ，或 &lt;code&gt;allocCStringArray&lt;/code&gt; 。GC不会尝试释放它们，完成处理后，您需要调用它们各自的&lt;em&gt;dealloc&lt;/em&gt;对，否则它们将泄漏。</target>
        </trans-unit>
        <trans-unit id="7a05427a05a096304d5b7dacd4ee54218ad43b1b" translate="yes" xml:space="preserve">
          <source>In addition to &lt;code&gt;GC_ref&lt;/code&gt; and &lt;code&gt;GC_unref&lt;/code&gt; you can avoid the garbage collector by manually allocating memory with procs like &lt;code&gt;alloc&lt;/code&gt;, &lt;code&gt;alloc0&lt;/code&gt;, &lt;code&gt;allocShared&lt;/code&gt;, &lt;code&gt;allocShared0&lt;/code&gt; or &lt;code&gt;allocCStringArray&lt;/code&gt;. The garbage collector won't try to free them, you need to call their respective &lt;em&gt;dealloc&lt;/em&gt; pairs (&lt;code&gt;dealloc&lt;/code&gt;, &lt;code&gt;deallocShared&lt;/code&gt;, &lt;code&gt;deallocCStringArray&lt;/code&gt;, etc) when you are done with them or they will leak.</source>
          <target state="translated">除了 &lt;code&gt;GC_ref&lt;/code&gt; 和 &lt;code&gt;GC_unref&lt;/code&gt; 之外，您还可以通过使用诸如 &lt;code&gt;alloc&lt;/code&gt; ， &lt;code&gt;alloc0&lt;/code&gt; ， &lt;code&gt;allocShared&lt;/code&gt; ， &lt;code&gt;allocShared0&lt;/code&gt; 或 &lt;code&gt;allocCStringArray&lt;/code&gt; 之类的proc手动分配内存来避免垃圾回收器。垃圾收集器不会尝试释放它们，您需要在使用 &lt;code&gt;deallocShared&lt;/code&gt; 它们后调用它们各自的&lt;em&gt;dealloc&lt;/em&gt;对（ &lt;code&gt;dealloc&lt;/code&gt; ，deallocShared， &lt;code&gt;deallocCStringArray&lt;/code&gt; 等），否则它们会泄漏。</target>
        </trans-unit>
        <trans-unit id="590bed6910696c3c90f97fbde2ce87692b87d870" translate="yes" xml:space="preserve">
          <source>In addition to fields, routine applications are also rewritten, but only if no other interpretation of the call is possible:</source>
          <target state="translated">除了字段外,例程应用也会被重写,但前提是不能对调用进行其他解释。</target>
        </trans-unit>
        <trans-unit id="00b487c57e5ed991eb8dcee9498e5c5bd5a4eb49" translate="yes" xml:space="preserve">
          <source>In addition to reading dynamic data, Nim can also unmarshal JSON directly into a type with the &lt;code&gt;to&lt;/code&gt; macro.</source>
          <target state="translated">除了读取动态数据外，Nim还可以使用 &lt;code&gt;to&lt;/code&gt; 宏将JSON直接解组为一种类型。</target>
        </trans-unit>
        <trans-unit id="3c1eb48be581c9adefbce7b80eb339a9d4bdac6f" translate="yes" xml:space="preserve">
          <source>In addition to the &lt;code&gt;untyped&lt;/code&gt; meta-type that prevents type checking there is also &lt;code&gt;varargs[untyped]&lt;/code&gt; so that not even the number of parameters is fixed:</source>
          <target state="translated">除了可以防止类型检查的未 &lt;code&gt;untyped&lt;/code&gt; 元类型之外，还可以使用 &lt;code&gt;varargs[untyped]&lt;/code&gt; 以便甚至无法固定参数数量：</target>
        </trans-unit>
        <trans-unit id="387616e73907f1f0c0f9c9b26be0a31bf6568eb0" translate="yes" xml:space="preserve">
          <source>In addition to the previous levels dumps a debug stack trace for compiler developers.</source>
          <target state="translated">除了前几级转储调试堆栈跟踪,供编译器开发者使用。</target>
        </trans-unit>
        <trans-unit id="ca3ff803089f70d16c29ec3feff03288c4ba5dae" translate="yes" xml:space="preserve">
          <source>In addition to the standard Nim syntax (&lt;a href=&quot;system&quot;&gt;system&lt;/a&gt; module), NimScripts support the procs and templates defined in the &lt;a href=&quot;nimscript&quot;&gt;nimscript&lt;/a&gt; module too.</source>
          <target state="translated">除了标准的Nim语法（&lt;a href=&quot;system&quot;&gt;系统&lt;/a&gt;模块）以外，NimScripts还支持&lt;a href=&quot;nimscript&quot;&gt;nimscript&lt;/a&gt;模块中定义的proc和模板。</target>
        </trans-unit>
        <trans-unit id="fa62a58dee28a4f60ea67a6c8e5a270a2279ae13" translate="yes" xml:space="preserve">
          <source>In addition to the usual arithmetic operators for signed and unsigned integers (&lt;code&gt;+ - *&lt;/code&gt; etc.) there are also operators that formally work on &lt;em&gt;signed&lt;/em&gt; integers but treat their arguments as &lt;em&gt;unsigned&lt;/em&gt;: They are mostly provided for backwards compatibility with older versions of the language that lacked unsigned integer types. These unsigned operations for signed integers use the &lt;code&gt;%&lt;/code&gt; suffix as convention:</source>
          <target state="translated">除了用于带符号和无符号整数的常用算术运算符（ &lt;code&gt;+ - *&lt;/code&gt; 等）之外，还有一些运算符可以对带&lt;em&gt;符号&lt;/em&gt;整数进行正式处理，但是将其参数视为&lt;em&gt;无符号&lt;/em&gt;：大多数情况下，提供它们是为了与该语言的较旧版本向后兼容缺少无符号整数类型。这些带符号整数的无符号运算使用 &lt;code&gt;%&lt;/code&gt; 后缀作为约定：</target>
        </trans-unit>
        <trans-unit id="a505d4cbc395f14732ae7d9715a2d71dbaa23d6d" translate="yes" xml:space="preserve">
          <source>In all descendant types of the object type.</source>
          <target state="translated">在对象类型的所有后代类型中。</target>
        </trans-unit>
        <trans-unit id="50cffa60fb3019583c70c527c490f8ebd32ae536" translate="yes" xml:space="preserve">
          <source>In an unchecked AST, the &lt;code&gt;typ&lt;/code&gt; field is nil. The type checker will set the &lt;code&gt;typ&lt;/code&gt; field accordingly to the node kind. Nodes of kind &lt;code&gt;nkIntLit&lt;/code&gt; will get the integer literal type (e.g. &lt;code&gt;int literal(123)&lt;/code&gt;). Nodes of kind &lt;code&gt;nkUIntLit&lt;/code&gt; will get type &lt;code&gt;uint&lt;/code&gt; (kind &lt;code&gt;tyUint&lt;/code&gt;), etc.</source>
          <target state="translated">在未经检查的AST中， &lt;code&gt;typ&lt;/code&gt; 字段为nil。类型检查器将根据节点种类相应地设置 &lt;code&gt;typ&lt;/code&gt; 字段。类型为 &lt;code&gt;nkIntLit&lt;/code&gt; 的节点将获得整数文字类型（例如intliteral &lt;code&gt;int literal(123)&lt;/code&gt; ）。类型为 &lt;code&gt;nkUIntLit&lt;/code&gt; 的节点将获得类型 &lt;code&gt;uint&lt;/code&gt; （类型 &lt;code&gt;tyUint&lt;/code&gt; ），依此类推。</target>
        </trans-unit>
        <trans-unit id="76eda137068d108454637b6e3ce61730b1cd808d" translate="yes" xml:space="preserve">
          <source>In any case, sorting also considers scoping information. Local variables get high priority.</source>
          <target state="translated">在任何情况下,排序也会考虑范围信息。局部变量获得高优先级。</target>
        </trans-unit>
        <trans-unit id="8255fdf45779c837c0b26b5faea383860b8d458a" translate="yes" xml:space="preserve">
          <source>In both cases the server will start up and await further commands. The syntax of the commands you can now send to the server is practically the same as running the nim compiler on the commandline, you only need to remove the name of the compiler since you are already talking to it. The server will answer with as many lines of text it thinks necessary plus an empty line to indicate the end of the answer.</source>
          <target state="translated">在这两种情况下,服务器会启动并等待进一步的命令。现在你可以向服务器发送的命令的语法实际上和在命令行上运行nim编译器是一样的,你只需要去掉编译器的名字,因为你已经在和它说话了。服务器会用它认为必要的文字行数加上空行来回答,表示回答的结束。</target>
        </trans-unit>
        <trans-unit id="87fcb4c9412aaaad5556b10d061891f17209ecf3" translate="yes" xml:space="preserve">
          <source>In contrast to that, a &lt;span id=&quot;closure-iterator_1&quot;&gt;closure iterator&lt;/span&gt; can be passed around more freely:</source>
          <target state="translated">与此相反，可以更自由地传递&lt;span id=&quot;closure-iterator_1&quot;&gt;闭包迭代器&lt;/span&gt;：</target>
        </trans-unit>
        <trans-unit id="862b7212edc1329bb097b23c4845a8a8f62159ad" translate="yes" xml:space="preserve">
          <source>In debug mode exceptions store the stack trace that led to them. A &lt;code&gt;StackTraceEntry&lt;/code&gt; is a single entry of the stack trace.</source>
          <target state="translated">在调试模式下，异常会存储导致它们的堆栈跟踪。一个 &lt;code&gt;StackTraceEntry&lt;/code&gt; 是堆栈跟踪的一个条目。</target>
        </trans-unit>
        <trans-unit id="d690804e9c35517f69d4546186980d7be8f2789c" translate="yes" xml:space="preserve">
          <source>In debug mode exceptions store the stack trace that led to them. A StackTraceEntry is a single entry of the stack trace.</source>
          <target state="translated">在调试模式下,异常存储了导致它们的堆栈跟踪。一个StackTraceEntry是堆栈跟踪的单个条目。</target>
        </trans-unit>
        <trans-unit id="af9ba250b7498b9006c490eda9c8a41290e0b66a" translate="yes" xml:space="preserve">
          <source>In every module compilation, reset the variable to its default value.</source>
          <target state="translated">在每次编译模块时,将变量重置为默认值。</target>
        </trans-unit>
        <trans-unit id="fd3c950a71716cce05a73a0cbb5053b0e20a8202" translate="yes" xml:space="preserve">
          <source>In fact, &lt;code&gt;.cursor&lt;/code&gt; more generally prevents object construction/destruction pairs and so can also be useful in other contexts. The alternative solution would be to use raw pointers (&lt;code&gt;ptr&lt;/code&gt;) instead which is more cumbersome and also more dangerous for Nim's evolution: Later on, the compiler can try to prove &lt;code&gt;.cursor&lt;/code&gt; annotations to be safe, but for &lt;code&gt;ptr&lt;/code&gt; the compiler has to remain silent about possible problems.</source>
          <target state="translated">实际上， &lt;code&gt;.cursor&lt;/code&gt; 通常会阻止对象构造/破坏对，因此在其他情况下也可能有用。替代的解决方案是使用原始指针（ &lt;code&gt;ptr&lt;/code&gt; ）来代替，这更麻烦，并且对于Nim的演变也更危险：以后，编译器可以尝试证明 &lt;code&gt;.cursor&lt;/code&gt; 注释是安全的，但是对于 &lt;code&gt;ptr&lt;/code&gt; ，编译器必须保持沉默关于可能的问题。</target>
        </trans-unit>
        <trans-unit id="b9d14a65a6bcb84eea05fa7cf43ef339b198f107" translate="yes" xml:space="preserve">
          <source>In fact, a trailing comma is allowed for every tuple construction.</source>
          <target state="translated">事实上,每一个元组结构都允许使用尾部逗号。</target>
        </trans-unit>
        <trans-unit id="4ef2c0c588919c564185ffbc7d6426162cb97e95" translate="yes" xml:space="preserve">
          <source>In fact, as a convention the following tasks should be available:</source>
          <target state="translated">事实上,作为一种惯例,应该有以下任务:</target>
        </trans-unit>
        <trans-unit id="32f48cac88984dbe72037f42d9b3ae356eb7d5f2" translate="yes" xml:space="preserve">
          <source>In fact, the root-mean-square error growth, assuming random roundoff errors, is only O(sqrt(log n)), which is nearly indistinguishable from O(1) in practice. See:</source>
          <target state="translated">事实上,假设随机圆周误差,均方根误差增长只有O(sqrt(log n)),这与实践中的O(1)几乎没有区别。见。</target>
        </trans-unit>
        <trans-unit id="d9e80bc5993cb0fc4644c16fb07461ebb339b897" translate="yes" xml:space="preserve">
          <source>In fact, this decribes how the AST should be stored in the database, as a &quot;shallow&quot; tree. Let's assume we compile module &lt;code&gt;m&lt;/code&gt; with the following contents:</source>
          <target state="translated">实际上，这描述了AST应该如何作为&amp;ldquo;浅&amp;rdquo;树存储在数据库中。假设我们用以下内容编译模块 &lt;code&gt;m&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="969fc90580200d3e34a84a7165170b2d397306ec" translate="yes" xml:space="preserve">
          <source>In fact, this describes how the AST should be stored in the database, as a &quot;shallow&quot; tree. Let's assume we compile module &lt;code&gt;m&lt;/code&gt; with the following contents:</source>
          <target state="translated">实际上，这描述了AST应该如何作为&amp;ldquo;浅&amp;rdquo;树存储在数据库中。假设我们用以下内容编译模块 &lt;code&gt;m&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="d7200c67cd9ab4646acaefd95fd28854405ad659" translate="yes" xml:space="preserve">
          <source>In general the case statement is used for subrange types or enumerations where it is of great help that the compiler checks that you covered any possible value.</source>
          <target state="translated">一般来说,case语句用于子范围类型或枚举,它对编译器检查你是否覆盖了任何可能的值有很大帮助。</target>
        </trans-unit>
        <trans-unit id="df2250e080bf643576540d132cb54644051a2eb3" translate="yes" xml:space="preserve">
          <source>In general, declaring types mirrors this syntax (i.e., &lt;code&gt;nnkStaticTy&lt;/code&gt; for &lt;code&gt;static&lt;/code&gt;, etc.). Examples follow (exceptions marked by &lt;code&gt;*&lt;/code&gt;):</source>
          <target state="translated">通常，声明类型反映了此语法（即，对于 &lt;code&gt;static&lt;/code&gt; 等，为 &lt;code&gt;nnkStaticTy&lt;/code&gt; ）。示例如下（带 &lt;code&gt;*&lt;/code&gt; 标记的例外）：</target>
        </trans-unit>
        <trans-unit id="1393a34bf1d4daea288238586a51eb0e1faccf00" translate="yes" xml:space="preserve">
          <source>In general, importing a dynamic library does not require any special linker options or linking with import libraries. This also implies that no &lt;em&gt;devel&lt;/em&gt; packages need to be installed.</source>
          <target state="translated">通常，导入动态库不需要任何特殊的链接器选项或与导入库链接。这也意味着不需要安装&lt;em&gt;devel&lt;/em&gt;软件包。</target>
        </trans-unit>
        <trans-unit id="0d0713666c6f10149634654fda5f08d4b39e3997" translate="yes" xml:space="preserve">
          <source>In highly specific cases (a dispatch loop of a bytecode interpreter for example) it may provide benefits, though.</source>
          <target state="translated">不过在非常特殊的情况下(例如字节码解释器的调度循环),它可能会带来好处。</target>
        </trans-unit>
        <trans-unit id="ccadb2f2afa462fe0a8e3a89f264df971c7a74b0" translate="yes" xml:space="preserve">
          <source>In many contexts, Nim allows you to treat the names of types as regular values. These values exists only during the compilation phase, but since all values must have a type, &lt;code&gt;type&lt;/code&gt; is considered their special type.</source>
          <target state="translated">在许多情况下，Nim允许您将类型的名称视为常规值。这些值仅在编译阶段存在，但是由于所有值都必须具有类型，因此将 &lt;code&gt;type&lt;/code&gt; 视为其特殊类型。</target>
        </trans-unit>
        <trans-unit id="5c2d206739a6370d6bd70863bb15b2c58816d4d9" translate="yes" xml:space="preserve">
          <source>In many contexts, Nim treats the names of types as regular values. These values exist only during the compilation phase, but since all values must have a type, &lt;code&gt;typedesc&lt;/code&gt; is considered their special type.</source>
          <target state="translated">在许多情况下，Nim都将类型的名称视为常规值。这些值仅在编译阶段存在，但是由于所有值都必须具有类型，因此 &lt;code&gt;typedesc&lt;/code&gt; 被视为其特殊类型。</target>
        </trans-unit>
        <trans-unit id="92effa90645c39523ba9f53c9bfe7bc808f9c10d" translate="yes" xml:space="preserve">
          <source>In normal debug and release builds code within a &lt;code&gt;runnableExamples&lt;/code&gt; section is ignored.</source>
          <target state="translated">在正常的调试和发布版本中，将忽略 &lt;code&gt;runnableExamples&lt;/code&gt; 部分中的代码。</target>
        </trans-unit>
        <trans-unit id="0fce6426da4fa8e50461c5a84f0b4bb26d70a6f7" translate="yes" xml:space="preserve">
          <source>In order to begin any sort of transfer of files you must first connect to an FTP server. You can do so with the &lt;code&gt;connect&lt;/code&gt; procedure.</source>
          <target state="translated">为了开始任何类型的文件传输，您必须首先连接到FTP服务器。您可以使用 &lt;code&gt;connect&lt;/code&gt; 过程进行操作。</target>
        </trans-unit>
        <trans-unit id="f0b84c550d9a8232bb0005f5c64c0b247f3554dd" translate="yes" xml:space="preserve">
          <source>In order to check for symbols accepting &lt;code&gt;type&lt;/code&gt; params, you must prefix the type with the explicit &lt;code&gt;type&lt;/code&gt; modifier. The named instance of the type, following the &lt;code&gt;concept&lt;/code&gt; keyword is also considered to have the explicit modifier and will be matched only as a type.</source>
          <target state="translated">为了检查符号是否接受 &lt;code&gt;type&lt;/code&gt; 参数，必须在类型前面加上显式的 &lt;code&gt;type&lt;/code&gt; 修饰符。类型的已命名实例（在 &lt;code&gt;concept&lt;/code&gt; 关键字之后）也被视为具有显式修饰符，并且仅作为类型进行匹配。</target>
        </trans-unit>
        <trans-unit id="ea6a479b9d25899b927b071796e99387ee4ff9e8" translate="yes" xml:space="preserve">
          <source>In order to compile Nim correctly, type-checking has to be separated from parsing. Otherwise generics cannot work.</source>
          <target state="translated">为了正确编译Nim,类型检查必须与解析分离。否则通用性就无法工作。</target>
        </trans-unit>
        <trans-unit id="f3802bfad258aac8c84f9a57c30500e4a9483a31" translate="yes" xml:space="preserve">
          <source>In order to encode some text simply call the &lt;code&gt;encode&lt;/code&gt; procedure:</source>
          <target state="translated">为了对一些文本进行编码，只需调用 &lt;code&gt;encode&lt;/code&gt; 过程：</target>
        </trans-unit>
        <trans-unit id="0a773d5bee7ad3c817ebe19e70c4e28c0ee6b821" translate="yes" xml:space="preserve">
          <source>In order to simplify structural type checking, recursive tuples are not valid:</source>
          <target state="translated">为了简化结构类型检查,递归的元组是无效的。</target>
        </trans-unit>
        <trans-unit id="312ff897ae89606cffe84af5ae7f281fbffba243" translate="yes" xml:space="preserve">
          <source>In order to use the SSL procedures defined in this module, you will need to compile your application with the &lt;code&gt;-d:ssl&lt;/code&gt; flag.</source>
          <target state="translated">为了使用此模块中定义的SSL过程，您将需要使用 &lt;code&gt;-d:ssl&lt;/code&gt; 标志来编译应用程序。</target>
        </trans-unit>
        <trans-unit id="4e1dd897461868e4657b4049dc2954656f20d85f" translate="yes" xml:space="preserve">
          <source>In order to use the SSL procedures defined in this module, you will need to compile your application with the &lt;code&gt;-d:ssl&lt;/code&gt; flag. See the &lt;a href=&quot;net#newContext%2Cstring%2Cstring%2Cstring%2Cstring%2Cstring&quot;&gt;newContext&lt;/a&gt; procedure for additional details.</source>
          <target state="translated">为了使用此模块中定义的SSL过程，您将需要使用 &lt;code&gt;-d:ssl&lt;/code&gt; 标志来编译您的应用程序。有关其他详细信息，请参见&lt;a href=&quot;net#newContext%2Cstring%2Cstring%2Cstring%2Cstring%2Cstring&quot;&gt;newContext&lt;/a&gt;过程。</target>
        </trans-unit>
        <trans-unit id="560248995a8c3109fbb872863af1490f690d2896" translate="yes" xml:space="preserve">
          <source>In ordinary object oriented languages, procedures (also called &lt;em&gt;methods&lt;/em&gt;) are bound to a class. This has disadvantages:</source>
          <target state="translated">在普通的面向对象语言中，过程（也称为&lt;em&gt;方法&lt;/em&gt;）绑定到一个类。这有缺点：</target>
        </trans-unit>
        <trans-unit id="e4128b2c0621b4875f7c93b74e81a267e43568d9" translate="yes" xml:space="preserve">
          <source>In other words sets a thread's &lt;span id=&quot;affinity_1&quot;&gt;affinity&lt;/span&gt;. If you don't know what this means, you shouldn't use this proc.</source>
          <target state="translated">换句话说，设置线程的&lt;span id=&quot;affinity_1&quot;&gt;亲和力&lt;/span&gt;。如果您不知道这意味着什么，则不应使用此proc。</target>
        </trans-unit>
        <trans-unit id="a0a598cac77f3ad01c6206ae5a35aace4982027b" translate="yes" xml:space="preserve">
          <source>In other words, the lifetime of what &lt;code&gt;result&lt;/code&gt; points to is attached to the lifetime of the first parameter and that is enough knowledge to verify memory safety at the call site.</source>
          <target state="translated">换句话说， &lt;code&gt;result&lt;/code&gt; 指向的生命周期附加到第一个参数的生命周期，并且这是足够的知识来验证呼叫站点的内存安全性。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
