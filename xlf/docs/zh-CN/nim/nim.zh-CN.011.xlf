<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="nim">
    <body>
      <group id="nim">
        <trans-unit id="e93d86b822e12c4d9ce33d7af413f341c5867140" translate="yes" xml:space="preserve">
          <source>Shared table support for Nim. Use plain old non GC'ed keys and values or you'll be in trouble. Uses a single lock to protect the table, lockfree implementations welcome but if lock contention is so high that you need a lockfree hash table, you're doing it wrong.</source>
          <target state="translated">支持Nim的共享表。使用普通的非GC'ed键和值,否则你会有麻烦。使用单一的锁来保护表,欢迎无锁的实现,但是如果锁的竞争太大,以至于你需要一个无锁的哈希表,那你就做错了。</target>
        </trans-unit>
        <trans-unit id="ec91193d5f88e5c879887f1193cd72ef6a694d25" translate="yes" xml:space="preserve">
          <source>Shifts right by pushing copies of the leftmost bit in from the left, and let the rightmost bits fall off.</source>
          <target state="translated">通过将最左边的位子的副本从左边推入,让最右边的位子掉下来,向右移动。</target>
        </trans-unit>
        <trans-unit id="05a85db16fbdbc68d6790c4c1c6d2377589785de" translate="yes" xml:space="preserve">
          <source>Short description of Nim's modules</source>
          <target state="translated">Nim模块的简要说明</target>
        </trans-unit>
        <trans-unit id="3aea3a391a6ebfd7b559fa27a009254bdee9654e" translate="yes" xml:space="preserve">
          <source>Short notation for:</source>
          <target state="translated">简称:</target>
        </trans-unit>
        <trans-unit id="1b40ffe9db9b97f7227d428a8e93cd1910e5bd51" translate="yes" xml:space="preserve">
          <source>Shortcut for &lt;code&gt;?(a *(b a))&lt;/code&gt;. Usually used for separators.</source>
          <target state="translated">&lt;code&gt;?(a *(b a))&lt;/code&gt; 快捷方式。通常用于分隔符。</target>
        </trans-unit>
        <trans-unit id="0fea2072669df686bfd29fd3b1504df5061432af" translate="yes" xml:space="preserve">
          <source>Shortcut for &lt;code&gt;?(a +(b a))&lt;/code&gt;. Usually used for separators.</source>
          <target state="translated">&lt;code&gt;?(a +(b a))&lt;/code&gt; 快捷方式。通常用于分隔符。</target>
        </trans-unit>
        <trans-unit id="cb96e2c575443083f6d3ddc0cd31cddbe58784dd" translate="yes" xml:space="preserve">
          <source>Shortcut for &lt;code&gt;toHex(x, T.sizeOf * 2)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;toHex(x, T.sizeOf * 2)&lt;/code&gt; 快捷方式</target>
        </trans-unit>
        <trans-unit id="4f9539002b86530179421f52fa92949ef36aae77" translate="yes" xml:space="preserve">
          <source>Shortcut version to assign in let blocks. Example:</source>
          <target state="translated">快捷版在let块中分配。例如:</target>
        </trans-unit>
        <trans-unit id="7f2812564b5e2e84d2a67a63d392d651dcda3d10" translate="yes" xml:space="preserve">
          <source>Shorthand for &lt;code&gt;dt.inZone(local())&lt;/code&gt;.</source>
          <target state="translated">速记 &lt;code&gt;dt.inZone(local())&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="088f96652b3ac9c5f1a3b23e8ff7e823708ee634" translate="yes" xml:space="preserve">
          <source>Shorthand for &lt;code&gt;dt.inZone(utc())&lt;/code&gt;.</source>
          <target state="translated">速记 &lt;code&gt;dt.inZone(utc())&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7cc17510fc204a22966fffd1886072211dea19a4" translate="yes" xml:space="preserve">
          <source>Shorthand for &lt;code&gt;getTime().local&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;getTime().local&lt;/code&gt; 简写。</target>
        </trans-unit>
        <trans-unit id="ccefd273539ba57e397a1a987afc4b367d6fd0cb" translate="yes" xml:space="preserve">
          <source>Shorthand for &lt;code&gt;t.inZone(local())&lt;/code&gt;.</source>
          <target state="translated">速记 &lt;code&gt;t.inZone(local())&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4d38209d424b19a4a50f30394d53391f0377fef8" translate="yes" xml:space="preserve">
          <source>Shorthand for &lt;code&gt;t.inZone(utc())&lt;/code&gt;.</source>
          <target state="translated">速记 &lt;code&gt;t.inZone(utc())&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6166daff0169e3dc89cc83eb9c8606a8a6917a8d" translate="yes" xml:space="preserve">
          <source>Shorthand for constructing a &lt;code&gt;TimeFormat&lt;/code&gt; and using it to format &lt;code&gt;dt&lt;/code&gt;.</source>
          <target state="translated">构造 &lt;code&gt;TimeFormat&lt;/code&gt; 并将其用于格式化 &lt;code&gt;dt&lt;/code&gt; 的简写。</target>
        </trans-unit>
        <trans-unit id="f394b42391f134971c4fd4caf836bd1af83856ed" translate="yes" xml:space="preserve">
          <source>Shorthand for constructing a &lt;code&gt;TimeFormat&lt;/code&gt; and using it to format &lt;code&gt;time&lt;/code&gt;. Will use the timezone specified by &lt;code&gt;zone&lt;/code&gt;.</source>
          <target state="translated">构造 &lt;code&gt;TimeFormat&lt;/code&gt; 并将其用于格式化 &lt;code&gt;time&lt;/code&gt; 的简写。将使用 &lt;code&gt;zone&lt;/code&gt; 指定的时区。</target>
        </trans-unit>
        <trans-unit id="719276957fc6ed6b9a172fd432c232dc57b61097" translate="yes" xml:space="preserve">
          <source>Shorthand for constructing a &lt;code&gt;TimeFormat&lt;/code&gt; and using it to parse &lt;code&gt;input&lt;/code&gt; as a &lt;code&gt;DateTime&lt;/code&gt;, then converting it a &lt;code&gt;Time&lt;/code&gt;.</source>
          <target state="translated">构造 &lt;code&gt;TimeFormat&lt;/code&gt; 并将其用于将 &lt;code&gt;input&lt;/code&gt; 解析为 &lt;code&gt;DateTime&lt;/code&gt; ，然后将其转换为 &lt;code&gt;Time&lt;/code&gt; 的简写形式。</target>
        </trans-unit>
        <trans-unit id="634ede6a595bd79a1f089d455148e4b9e1b829dc" translate="yes" xml:space="preserve">
          <source>Shorthand for constructing a &lt;code&gt;TimeFormat&lt;/code&gt; and using it to parse &lt;code&gt;input&lt;/code&gt; as a &lt;code&gt;DateTime&lt;/code&gt;.</source>
          <target state="translated">速记构建 &lt;code&gt;TimeFormat&lt;/code&gt; ，并用它来解析 &lt;code&gt;input&lt;/code&gt; 的 &lt;code&gt;DateTime&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0a88a0a1d83dbc4654c51021948189560a75286b" translate="yes" xml:space="preserve">
          <source>Shows global variables declarations.</source>
          <target state="translated">显示全局变量的声明。</target>
        </trans-unit>
        <trans-unit id="0e16604c6fe1879f13dbc7c436126fd3ae0ebb67" translate="yes" xml:space="preserve">
          <source>Shows the cursor.</source>
          <target state="translated">显示光标。</target>
        </trans-unit>
        <trans-unit id="5ddc127fefceccd7916455147b0c6cd1bfd5eb59" translate="yes" xml:space="preserve">
          <source>Shows when the C compiler is called.</source>
          <target state="translated">显示C编译器何时被调用。</target>
        </trans-unit>
        <trans-unit id="8b3d8d665a765918b70a3f5f0378d51df00b92dd" translate="yes" xml:space="preserve">
          <source>Sign</source>
          <target state="translated">Sign</target>
        </trans-unit>
        <trans-unit id="65a4950085292c6592af7d8392c4038e653ea152" translate="yes" xml:space="preserve">
          <source>Sign function. Returns -1 for negative numbers and &lt;em&gt;NegInf&lt;/em&gt;, 1 for positive numbers and &lt;em&gt;Inf&lt;/em&gt;, and 0 for positive zero, negative zero and &lt;em&gt;NaN&lt;/em&gt;.</source>
          <target state="translated">签名功能。对于负数和&lt;em&gt;NegInf&lt;/em&gt;返回-1 ，对于正数和&lt;em&gt;Inf&lt;/em&gt;返回1，对于正零，负零和&lt;em&gt;NaN返回&lt;/em&gt; 0 。</target>
        </trans-unit>
        <trans-unit id="8831fa9078748ee02f2347f5d90c34f992582819" translate="yes" xml:space="preserve">
          <source>Signal handling in Nim</source>
          <target state="translated">Nim中的信号处理</target>
        </trans-unit>
        <trans-unit id="f006508366ff589e263e35089658634396886e2b" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;recvLine&lt;/code&gt; but designed for non-blocking sockets.</source>
          <target state="translated">与 &lt;code&gt;recvLine&lt;/code&gt; 类似，但设计用于非阻塞套接字。</target>
        </trans-unit>
        <trans-unit id="3088f8f41c176a8c6c078dcbb7290cd8f5dcfe1d" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;write&lt;/code&gt;, but treating terminal style arguments specially. When some argument is &lt;code&gt;Style&lt;/code&gt;, &lt;code&gt;set[Style]&lt;/code&gt;, &lt;code&gt;ForegroundColor&lt;/code&gt;, &lt;code&gt;BackgroundColor&lt;/code&gt; or &lt;code&gt;TerminalCmd&lt;/code&gt; then it is not sent directly to &lt;code&gt;f&lt;/code&gt;, but instead corresponding terminal style proc is called.</source>
          <target state="translated">与 &lt;code&gt;write&lt;/code&gt; 类似，但特别对待终端样式参数。当某些参数是 &lt;code&gt;Style&lt;/code&gt; ， &lt;code&gt;set[Style]&lt;/code&gt; ， &lt;code&gt;ForegroundColor&lt;/code&gt; ， &lt;code&gt;BackgroundColor&lt;/code&gt; 或 &lt;code&gt;TerminalCmd&lt;/code&gt; 时,它不会直接发送到 &lt;code&gt;f&lt;/code&gt; ，而是会调用相应的终端样式proc。</target>
        </trans-unit>
        <trans-unit id="775c84deb7fd1acce89cc09f380ce7f83b7c3680" translate="yes" xml:space="preserve">
          <source>Similar to POSIX's &lt;span id=&quot;getpeername_1&quot;&gt;getpeername&lt;/span&gt;</source>
          <target state="translated">类似于POSIX的&lt;span id=&quot;getpeername_1&quot;&gt;getpeername&lt;/span&gt;</target>
        </trans-unit>
        <trans-unit id="9112c6f819f5ac3102803b1b46b40279bc4dc6e4" translate="yes" xml:space="preserve">
          <source>Similar to POSIX's &lt;span id=&quot;getsockname_1&quot;&gt;getsockname&lt;/span&gt;.</source>
          <target state="translated">类似于POSIX的&lt;span id=&quot;getsockname_1&quot;&gt;getsockname&lt;/span&gt;。</target>
        </trans-unit>
        <trans-unit id="d23f8837af17d948ac41ffcd02bd63cca20c677c" translate="yes" xml:space="preserve">
          <source>Similar to the &lt;a href=&quot;#foreign-function-interface-importc-pragma&quot;&gt;importc pragma for C&lt;/a&gt;, the &lt;code&gt;importcpp&lt;/code&gt; pragma can be used to import &lt;span id=&quot;cplusplus_2&quot;&gt;C++&lt;/span&gt; methods or C++ symbols in general. The generated code then uses the C++ method calling syntax: &lt;code&gt;obj-&amp;gt;method(arg)&lt;/code&gt;. In combination with the &lt;code&gt;header&lt;/code&gt; and &lt;code&gt;emit&lt;/code&gt; pragmas this allows &lt;em&gt;sloppy&lt;/em&gt; interfacing with libraries written in C++:</source>
          <target state="translated">类似于&lt;a href=&quot;#foreign-function-interface-importc-pragma&quot;&gt;C&lt;/a&gt;的 &lt;code&gt;importcpp&lt;/code&gt; pragma ，importcpp pragma通常可用于导入&lt;span id=&quot;cplusplus_2&quot;&gt;C ++&lt;/span&gt;方法或C ++符号。然后，生成的代码使用C ++方法调用语法： &lt;code&gt;obj-&amp;gt;method(arg)&lt;/code&gt; 。与 &lt;code&gt;header&lt;/code&gt; 结合使用并 &lt;code&gt;emit&lt;/code&gt; 编译指示，这允许与用C ++编写的库进行&lt;em&gt;草率的&lt;/em&gt;接口：</target>
        </trans-unit>
        <trans-unit id="f0db59dc951868b6d9e5ad7d56c503fc95dfe4f0" translate="yes" xml:space="preserve">
          <source>Similar to the &lt;a href=&quot;#foreign-function-interface-importc-pragma&quot;&gt;importc pragma for C&lt;/a&gt;, the &lt;code&gt;importobjc&lt;/code&gt; pragma can be used to import &lt;span id=&quot;objective-c_2&quot;&gt;Objective C&lt;/span&gt; methods. The generated code then uses the Objective C method calling syntax: &lt;code&gt;[obj method param1: arg]&lt;/code&gt;. In addition with the &lt;code&gt;header&lt;/code&gt; and &lt;code&gt;emit&lt;/code&gt; pragmas this allows &lt;em&gt;sloppy&lt;/em&gt; interfacing with libraries written in Objective C:</source>
          <target state="translated">类似于&lt;a href=&quot;#foreign-function-interface-importc-pragma&quot;&gt;C&lt;/a&gt;的 &lt;code&gt;importobjc&lt;/code&gt; 编译指示，importobjc编译指示可用于导入&lt;span id=&quot;objective-c_2&quot;&gt;Objective C&lt;/span&gt;方法。然后，生成的代码使用Objective C方法调用语法： &lt;code&gt;[obj method param1: arg]&lt;/code&gt; 。除了 &lt;code&gt;header&lt;/code&gt; 和 &lt;code&gt;emit&lt;/code&gt; 编译指示之外，这还允许与用Objective C编写的库进行&lt;em&gt;草率的&lt;/em&gt;接口：</target>
        </trans-unit>
        <trans-unit id="3adf311c5dd828b7c450080b9fe51795b3cb57d5" translate="yes" xml:space="preserve">
          <source>Similar to the &lt;code&gt;import&lt;/code&gt; statement, the AST is different for &lt;code&gt;export ... except&lt;/code&gt;.</source>
          <target state="translated">与 &lt;code&gt;import&lt;/code&gt; 语句相似，AST的 &lt;code&gt;export ... except&lt;/code&gt; 方式有所不同...除外。</target>
        </trans-unit>
        <trans-unit id="17f571225bcdb0061542084cc744c2d22c9a95bd" translate="yes" xml:space="preserve">
          <source>Similarly to &lt;span id=&quot;argv_1&quot;&gt;argv&lt;/span&gt; in C, it is possible to call &lt;code&gt;paramStr(0)&lt;/code&gt; but this will return OS specific contents (usually the name of the invoked executable). You should avoid this and call &lt;a href=&quot;#getAppFilename&quot;&gt;getAppFilename()&lt;/a&gt; instead.</source>
          <target state="translated">与C 中的&lt;span id=&quot;argv_1&quot;&gt;argv&lt;/span&gt;相似，可以调用 &lt;code&gt;paramStr(0)&lt;/code&gt; ,但这将返回OS特定的内容（通常是所调用可执行文件的名称）。您应该避免这种情况，而改为调用&lt;a href=&quot;#getAppFilename&quot;&gt;getAppFilename（）&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0836ce8cc993ea5e6c237d5e13b1926310dd2fc9" translate="yes" xml:space="preserve">
          <source>Similarly to the old &lt;code&gt;doc&lt;/code&gt; command the old &lt;code&gt;jsondoc&lt;/code&gt; command has been renamed &lt;code&gt;jsondoc0&lt;/code&gt;.</source>
          <target state="translated">与旧 &lt;code&gt;doc&lt;/code&gt; 命令类似，旧 &lt;code&gt;jsondoc&lt;/code&gt; 命令已重命名为 &lt;code&gt;jsondoc0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="923d2208cc2a00f7a0f1b3452857f4ae436b40d2" translate="yes" xml:space="preserve">
          <source>Similarly, any procedure and procedure type declarations that are longer than one line should do the same thing.</source>
          <target state="translated">类似地,任何长于一行的过程和过程类型声明都应该做同样的事情。</target>
        </trans-unit>
        <trans-unit id="03199fb1565fa787d6b802de955cc02879b12e5f" translate="yes" xml:space="preserve">
          <source>Simple PEG (Parsing expression grammar) matching. Uses no memorization, but uses superoperators and symbol inlining to improve performance. Note: Matching performance is hopefully competitive with optimized regular expression engines.</source>
          <target state="translated">简单的PEG(解析表达式语法)匹配。不使用记忆,但使用超级运算符和符号内联来提高性能。注:匹配性能有望与优化后的正则表达式引擎竞争。</target>
        </trans-unit>
        <trans-unit id="642d63f4b98668cb5f7dde10bc28bf59ccdf215c" translate="yes" xml:space="preserve">
          <source>Simple assertions</source>
          <target state="translated">简单论断</target>
        </trans-unit>
        <trans-unit id="edcc542b12309c356f091b9913fd4380c94b4828" translate="yes" xml:space="preserve">
          <source>Simple example that parses the &lt;code&gt;/etc/passwd&lt;/code&gt; file line by line:</source>
          <target state="translated">一个简单的示例，逐行分析 &lt;code&gt;/etc/passwd&lt;/code&gt; 文件：</target>
        </trans-unit>
        <trans-unit id="e8a60d51d4165fef55cc82ac2db54d5e0a688774" translate="yes" xml:space="preserve">
          <source>Simply add --os:nintendoswitch to your usual &lt;code&gt;nim c&lt;/code&gt; or &lt;code&gt;nim cpp&lt;/code&gt; command and set the &lt;code&gt;passC&lt;/code&gt; and &lt;code&gt;passL&lt;/code&gt; command line switches to something like:</source>
          <target state="translated">只需将--os：nintendoswitch添加到常用的 &lt;code&gt;nim c&lt;/code&gt; 或 &lt;code&gt;nim cpp&lt;/code&gt; 命令中，并将 &lt;code&gt;passC&lt;/code&gt; 和 &lt;code&gt;passL&lt;/code&gt; 命令行开关设置为类似以下内容：</target>
        </trans-unit>
        <trans-unit id="b090179dd62a9781100bf21383b86b639866ae6b" translate="yes" xml:space="preserve">
          <source>Since Nim generates C++ directly, any destructor is called implicitly by the C++ compiler at the scope exits. This means that often one can get away with not wrapping the destructor at all! However when it needs to be invoked explicitly, it needs to be wrapped. The pattern language provides everything that is required:</source>
          <target state="translated">由于Nim是直接生成C++的,所以任何destructor都会在scope退出时被C++编译器隐式调用。这意味着很多时候我们可以完全不包装destructor! 然而当它需要被显式调用时,就需要对它进行封装。模式语言提供了所需的一切。</target>
        </trans-unit>
        <trans-unit id="2836b4cd35895fbe3e4607ab829e68b8adca5bab" translate="yes" xml:space="preserve">
          <source>Since Nim is implemented in Nim, one of the nice things of this feature is that any user with an IDE supporting it can quickly jump around the standard library implementation and see exactly what a proc does, learning about the language and seeing real life examples of how to write/implement specific features.</source>
          <target state="translated">由于Nim是用Nim实现的,所以这个功能的一个好处是,任何有IDE支持的用户都可以快速跳转标准库实现,看到一个proc到底是做什么的,学习语言的知识,并看到如何编写/实现特定功能的实际例子。</target>
        </trans-unit>
        <trans-unit id="81d6398a9d34106da960c47713538b3d721fae12" translate="yes" xml:space="preserve">
          <source>Since Nim's garbage collector is not aware of the C code, once the &lt;code&gt;gimme&lt;/code&gt; proc has finished it can reclaim the memory of the &lt;code&gt;cstring&lt;/code&gt;. However, from a practical standpoint, the C code invoking the &lt;code&gt;gimme&lt;/code&gt; function directly will be able to use it since Nim's garbage collector has not had a chance to run &lt;em&gt;yet&lt;/em&gt;. This gives you enough time to make a copy for the C side of the program, as calling any further Nim procs &lt;em&gt;might&lt;/em&gt; trigger garbage collection making the previously returned string garbage. Or maybe you are &lt;a href=&quot;gc&quot;&gt;yourself triggering the collection&lt;/a&gt;.</source>
          <target state="translated">由于Nim的垃圾回收器不了解C代码，因此一旦 &lt;code&gt;gimme&lt;/code&gt; proc完成，它就可以回收 &lt;code&gt;cstring&lt;/code&gt; 的内存。然而，从实际情况来看，C代码调用 &lt;code&gt;gimme&lt;/code&gt; 直接作用将能够使用它，因为稔的垃圾回收一直没有机会运行&lt;em&gt;还&lt;/em&gt;。这为您提供了足够的时间来为程序的C端进行复制，因为调用任何进一步的Nim proc都&lt;em&gt;可能&lt;/em&gt;触发垃圾回收，从而使先前返回的字符串垃圾化。也许您&lt;a href=&quot;gc&quot;&gt;自己触发了收藏&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4c2d2708a6e9c531e547adff103c4d9f239c3ef0" translate="yes" xml:space="preserve">
          <source>Since closures capture local variables by reference it is often not wanted behavior inside loop bodies. See &lt;a href=&quot;system#closureScope&quot;&gt;closureScope&lt;/a&gt; for details on how to change this behavior.</source>
          <target state="translated">由于闭包通过引用捕获局部变量，因此在循环体内通常不希望有这种行为。有关如何更改此行为的详细信息，请参见&lt;a href=&quot;system#closureScope&quot;&gt;closureScope&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="433b2057ed04740122c7f9487a7fd644b8ab062a" translate="yes" xml:space="preserve">
          <source>Since counting up occurs so often in programs, Nim also has a &lt;a href=&quot;system#...i,S,T&quot;&gt;..&lt;/a&gt; iterator that does the same:</source>
          <target state="translated">由于累加程序在程序中经常发生，因此Nim也有一个&lt;a href=&quot;system#...i,S,T&quot;&gt;..&lt;/a&gt;迭代器，其作用相同：</target>
        </trans-unit>
        <trans-unit id="3f5358496f3a495272baef5ad9c4459080748780" translate="yes" xml:space="preserve">
          <source>Since module names are generally long to be descriptive, you can also define a shorter alias to use when qualifying symbols.</source>
          <target state="translated">由于模块名一般都比较长,要有描述性,所以也可以定义一个较短的别名,以便在限定符号时使用。</target>
        </trans-unit>
        <trans-unit id="eeb691770c7129b48bc1fbd85364e037b06e51a3" translate="yes" xml:space="preserve">
          <source>Since objects can reside on the heap or on the stack this greatly enhances the expressivity of the language:</source>
          <target state="translated">由于对象可以驻留在堆上,也可以驻留在栈上,这大大增强了语言的表现力。</target>
        </trans-unit>
        <trans-unit id="d18abb59d5555a0cd68ad92ca498969b76edc73a" translate="yes" xml:space="preserve">
          <source>Since some cases are specific to either &lt;code&gt;ProcRun&lt;/code&gt; or &lt;code&gt;CaasRun&lt;/code&gt; modes, you can prefix a line with the mode and the line will be processed only in that mode.</source>
          <target state="translated">由于某些情况特定于 &lt;code&gt;ProcRun&lt;/code&gt; 或 &lt;code&gt;CaasRun&lt;/code&gt; 模式，因此您可以在模式前面加上一行，并且仅在该模式下才处理该行。</target>
        </trans-unit>
        <trans-unit id="d1b539956855f09af0d247b1afd8148391989674" translate="yes" xml:space="preserve">
          <source>Since templates and macros that are not declared as &lt;code&gt;immediate&lt;/code&gt; participate in overloading resolution it's essential to have a way to pass unresolved expressions to a template or macro. This is what the meta-type &lt;code&gt;untyped&lt;/code&gt; accomplishes:</source>
          <target state="translated">由于未声明为 &lt;code&gt;immediate&lt;/code&gt; 模板和宏会参与重载解析，因此必须有一种方法可以将未解析的表达式传递给模板或宏。这是未键入的元 &lt;code&gt;untyped&lt;/code&gt; 完成的工作：</target>
        </trans-unit>
        <trans-unit id="20070e544008a5d9a536d614aa3a8b327168b8fa" translate="yes" xml:space="preserve">
          <source>Since the input is not modified you can use this version of &lt;code&gt;map&lt;/code&gt; to transform the type of the elements in the input container.</source>
          <target state="translated">由于未修改输入，因此可以使用此版本的 &lt;code&gt;map&lt;/code&gt; 来转换输入容器中元素的类型。</target>
        </trans-unit>
        <trans-unit id="8bd7e9132b57aa66fa0c89392e52a98747d0fab5" translate="yes" xml:space="preserve">
          <source>Since types are graphs which can have cycles, the above algorithm needs an auxiliary set &lt;code&gt;s&lt;/code&gt; to detect this case.</source>
          <target state="translated">由于类型是可以具有循环的图，因此上述算法需要一个辅助集 &lt;code&gt;s&lt;/code&gt; 来检测这种情况。</target>
        </trans-unit>
        <trans-unit id="693c97bf55b6187119c714b7b185fa6734646019" translate="yes" xml:space="preserve">
          <source>Since we adopt the &quot;replay the top level statements&quot; idea, the natural solution to this problem is to emit pseudo top level statements that reflect the mutations done to the global variable. However, this is MUCH harder than it sounds, for example &lt;code&gt;squeaknim&lt;/code&gt; uses this snippet:</source>
          <target state="translated">由于我们采用&amp;ldquo;重放顶级语句&amp;rdquo;的想法，因此解决此问题的自然方法是发出伪顶级语句，以反映对全局变量所做的更改。但是，这比听起来要难得多，例如 &lt;code&gt;squeaknim&lt;/code&gt; 使用以下代码段：</target>
        </trans-unit>
        <trans-unit id="d11cd8a4ff2f39268c05039e2c72e08ef63a5b60" translate="yes" xml:space="preserve">
          <source>Since we are building on the previous example generating source code, we will only mention the differences to it. Instead of creating a temporary &lt;code&gt;string&lt;/code&gt; variable and writing into it source code as if it were written &lt;em&gt;by hand&lt;/em&gt;, we use the &lt;code&gt;result&lt;/code&gt; variable directly and create a statement list node (&lt;code&gt;nnkStmtList&lt;/code&gt;) which will hold our children (line 7).</source>
          <target state="translated">由于我们是在前面的示例中生成源代码的基础上构建的，因此我们仅提及与之不同的地方。与其创建一个临时的 &lt;code&gt;string&lt;/code&gt; 变量并像&lt;em&gt;手工&lt;/em&gt;编写一样将其写入源代码，我们不直接使用 &lt;code&gt;result&lt;/code&gt; 变量，而是创建一个语句列表节点（ &lt;code&gt;nnkStmtList&lt;/code&gt; ）来保存我们的孩子（第7行）。</target>
        </trans-unit>
        <trans-unit id="67281e7beeac085659bafd0aefa97a7715dd587c" translate="yes" xml:space="preserve">
          <source>Skips &lt;code&gt;size&lt;/code&gt; amount of bytes.</source>
          <target state="translated">跳过 &lt;code&gt;size&lt;/code&gt; 字节数。</target>
        </trans-unit>
        <trans-unit id="caa40925a8a5ba1ec2c47da0074b9498483ee486" translate="yes" xml:space="preserve">
          <source>Skips all characters until one char from the set &lt;em&gt;until&lt;/em&gt; is found or the end is reached. Returns number of characters skipped.</source>
          <target state="translated">跳过所有字符，直到从集合中找到一个字符或找到结尾&lt;em&gt;为止&lt;/em&gt;。返回跳过的字符数。</target>
        </trans-unit>
        <trans-unit id="c0250535bb44963b382eb260412b12ae060f9664" translate="yes" xml:space="preserve">
          <source>Skips all characters until the char &lt;em&gt;until&lt;/em&gt; is found or the end is reached. Returns number of characters skipped.</source>
          <target state="translated">跳过所有字符，直到找到字符char 或到达末尾&lt;em&gt;为止&lt;/em&gt;。返回跳过的字符数。</target>
        </trans-unit>
        <trans-unit id="82c633400ddfee46423e0bdfdd5bf1035984706d" translate="yes" xml:space="preserve">
          <source>Skips all characters while one char from the set &lt;em&gt;token&lt;/em&gt; is found. Returns number of characters skipped.</source>
          <target state="translated">从设置的&lt;em&gt;令牌&lt;/em&gt;中找到一个字符时，跳过所有字符。返回跳过的字符数。</target>
        </trans-unit>
        <trans-unit id="e7c8076f2280bb4f56da2f4ba9faf089bdaf35a9" translate="yes" xml:space="preserve">
          <source>Skips optional whitespace.</source>
          <target state="translated">跳过可选的空白处。</target>
        </trans-unit>
        <trans-unit id="a455933ba1827ec6d2d6cea6cb61c05bd3954351" translate="yes" xml:space="preserve">
          <source>Slices</source>
          <target state="translated">Slices</target>
        </trans-unit>
        <trans-unit id="3b0fe98905d1d18450c150302cb674830bef8f5f" translate="yes" xml:space="preserve">
          <source>Slices are optimized so that no copy is performed. This optimization is not yet performed for ordinary slices outside of a &lt;code&gt;parallel&lt;/code&gt; section.</source>
          <target state="translated">优化切片，以便不执行任何复制。尚未对 &lt;code&gt;parallel&lt;/code&gt; 段外部的普通切片执行此优化。</target>
        </trans-unit>
        <trans-unit id="6b4413ae4cc49215fae1d8456ab98bdf32cdd690" translate="yes" xml:space="preserve">
          <source>Slices look similar to subranges types in syntax but are used in a different context. A slice is just an object of type Slice which contains two bounds, &lt;em&gt;a&lt;/em&gt; and &lt;em&gt;b&lt;/em&gt;. By itself a slice is not very useful, but other collection types define operators which accept Slice objects to define ranges.</source>
          <target state="translated">切片在语法上看起来类似于子范围类型，但在不同的上下文中使用。切片只是切片类型的对象，其中包含两个边界&lt;em&gt;a&lt;/em&gt;和&lt;em&gt;b&lt;/em&gt;。切片本身并不是很有用，但是其他集合类型定义了接受切片对象定义范围的运算符。</target>
        </trans-unit>
        <trans-unit id="c3fee626664b2a86ccfce0881ad458405c843067" translate="yes" xml:space="preserve">
          <source>Slightly different version of &lt;code&gt;acceptAddr&lt;/code&gt;.</source>
          <target state="translated">稍有不同的版本的 &lt;code&gt;acceptAddr&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="eee7a8ef42831f93c54af4a6309b748729834ca0" translate="yes" xml:space="preserve">
          <source>SmallLshouldNotBeUsed</source>
          <target state="translated">SmallLshouldNotBeUsed</target>
        </trans-unit>
        <trans-unit id="75f4dd2393a33188b388008b159b576f9d6c37ce" translate="yes" xml:space="preserve">
          <source>So &quot;pure object oriented&quot; code is easy to write:</source>
          <target state="translated">所以 &quot;纯面向对象 &quot;的代码很容易写。</target>
        </trans-unit>
        <trans-unit id="1884ef29a0caad9d01db393c26a4dacb7998bb83" translate="yes" xml:space="preserve">
          <source>So in many cases a callback does not cause the compiler to be overly conservative in its effect analysis.</source>
          <target state="translated">所以在很多情况下,回调不会导致编译器在效果分析上过于保守。</target>
        </trans-unit>
        <trans-unit id="d04b96e54f57571cb5f26f417c712886d005cc49" translate="yes" xml:space="preserve">
          <source>So it is not necessary to write &lt;code&gt;peg&quot; 'abc' &quot;&lt;/code&gt; in the above example.</source>
          <target state="translated">因此，在上面的示例中不必写 &lt;code&gt;peg&quot; 'abc' &quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8675cecc3e20035fc6e573ebf270227f7c7eb995" translate="yes" xml:space="preserve">
          <source>So now &lt;code&gt;G.c&lt;/code&gt; MUST contain both &lt;code&gt;P1&lt;/code&gt; and &lt;code&gt;P2&lt;/code&gt;, but we haven't even loaded &lt;code&gt;P1&lt;/code&gt; from the symbol file, nor do we want to because we then quickly would restore large parts of the whole program.</source>
          <target state="translated">因此，现在 &lt;code&gt;G.c&lt;/code&gt; 必须同时包含 &lt;code&gt;P1&lt;/code&gt; 和 &lt;code&gt;P2&lt;/code&gt; ，但是我们甚至都没有从符号文件中加载 &lt;code&gt;P1&lt;/code&gt; ，我们也不想这样做，因为这样我们很快就会恢复整个程序的大部分。</target>
        </trans-unit>
        <trans-unit id="d2837e373a9e08b8e4ae0fadd7bcf34bea8bba71" translate="yes" xml:space="preserve">
          <source>So the string &lt;code&gt;b&lt;/code&gt; is of length 19, and two different ways of specifying the indices are</source>
          <target state="translated">因此，字符串 &lt;code&gt;b&lt;/code&gt; 的长度为19，指定索引的两种不同方式是</target>
        </trans-unit>
        <trans-unit id="e588b1291d20c18b6f2648d5846b37301ef51066" translate="yes" xml:space="preserve">
          <source>So what about &lt;code&gt;2 * a&lt;/code&gt;? We should tell the compiler &lt;code&gt;*&lt;/code&gt; is commutative. We cannot really do that however as the following code only swaps arguments blindly:</source>
          <target state="translated">那么 &lt;code&gt;2 * a&lt;/code&gt; 呢？我们应该告诉编译器 &lt;code&gt;*&lt;/code&gt; 是可交换的。但是，我们不能真正做到这一点，因为以下代码仅盲目地交换参数：</target>
        </trans-unit>
        <trans-unit id="b4e6066da4ec97671c84015a233816abeed1a8d1" translate="yes" xml:space="preserve">
          <source>So, now that we are done with the basics, let's see what Nim offers apart from a nice syntax for procedural programming: &lt;a href=&quot;tut2&quot;&gt;Part II&lt;/a&gt;</source>
          <target state="translated">因此，既然我们已经完成了基础知识，那么让我们看一下Nim除了为过程编程提供了一种不错的语法之外还提供了什么：&lt;a href=&quot;tut2&quot;&gt;第二部分&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="99f2336f838a801c19d553e0c88c363ba411da59" translate="yes" xml:space="preserve">
          <source>SockClosed</source>
          <target state="translated">SockClosed</target>
        </trans-unit>
        <trans-unit id="2e364384ea1af26a7ae5749a4ee47846386614a6" translate="yes" xml:space="preserve">
          <source>SockConnected</source>
          <target state="translated">SockConnected</target>
        </trans-unit>
        <trans-unit id="ecb1db9b50d2375a93db032e8269b906e3a2d434" translate="yes" xml:space="preserve">
          <source>SockConnecting</source>
          <target state="translated">SockConnecting</target>
        </trans-unit>
        <trans-unit id="f96262d38e15e56e293b395e3a4e585d00445d21" translate="yes" xml:space="preserve">
          <source>SockIdle</source>
          <target state="translated">SockIdle</target>
        </trans-unit>
        <trans-unit id="49173abf46e65756efd207d62345b6562084170d" translate="yes" xml:space="preserve">
          <source>SockListening</source>
          <target state="translated">SockListening</target>
        </trans-unit>
        <trans-unit id="540e5e4a700a40f5403f5305e76a47af819360b6" translate="yes" xml:space="preserve">
          <source>SockUDPBound</source>
          <target state="translated">SockUDPBound</target>
        </trans-unit>
        <trans-unit id="22beb4639862a7b9b676d1e4836131999f91ce5b" translate="yes" xml:space="preserve">
          <source>Socket has been closed.</source>
          <target state="translated">插座已被关闭。</target>
        </trans-unit>
        <trans-unit id="879f6e69a5675653a92a791913da83a48c7fb678" translate="yes" xml:space="preserve">
          <source>Socket has only just been initialised, not connected or closed.</source>
          <target state="translated">Socket只是刚刚被初始化,没有连接或关闭。</target>
        </trans-unit>
        <trans-unit id="af4d7eba62345b81d526d2643d898eb239b5cdcf" translate="yes" xml:space="preserve">
          <source>Socket is a UDP socket which is listening for data.</source>
          <target state="translated">Socket是一个正在监听数据的UDP套接字。</target>
        </trans-unit>
        <trans-unit id="54b2d18985d4b7f5023824f4fcfddd48ab27cdff" translate="yes" xml:space="preserve">
          <source>Socket is a server socket and is listening for connections.</source>
          <target state="translated">Socket是一个服务器套接字,正在监听连接。</target>
        </trans-unit>
        <trans-unit id="b53ea21e56f48fba083f112fde7dee58dc547eb7" translate="yes" xml:space="preserve">
          <source>Socket is connected to a server.</source>
          <target state="translated">Socket是连接到服务器的。</target>
        </trans-unit>
        <trans-unit id="84e26ccd61f472edc6a5d97a690d05af186f5bed" translate="yes" xml:space="preserve">
          <source>Socket is in the process of connecting to a server.</source>
          <target state="translated">Socket正在连接到服务器的过程中。</target>
        </trans-unit>
        <trans-unit id="53b421c08a7dc0ab4bbd194fdc55f0c8077afbc0" translate="yes" xml:space="preserve">
          <source>Sockets which are &lt;strong&gt;not&lt;/strong&gt; ready for reading, writing or which don't have errors waiting on them are removed from the &lt;code&gt;readfds&lt;/code&gt;, &lt;code&gt;writefds&lt;/code&gt;, &lt;code&gt;exceptfds&lt;/code&gt; sequences respectively.</source>
          <target state="translated">&lt;strong&gt;尚未&lt;/strong&gt;准备好读取，写入或没有等待错误的套接字分别从 &lt;code&gt;readfds&lt;/code&gt; ， &lt;code&gt;writefds&lt;/code&gt; ， &lt;code&gt;exceptfds&lt;/code&gt; 序列中删除。</target>
        </trans-unit>
        <trans-unit id="441c0981544196354c221a53804d865bc53f74b3" translate="yes" xml:space="preserve">
          <source>Solution ~~~~~~~~</source>
          <target state="translated">解决方案~~~~~~~~~~。</target>
        </trans-unit>
        <trans-unit id="a18f034cd6a34c65d1fee4d43db529e754f206cf" translate="yes" xml:space="preserve">
          <source>Some builtins set an error flag. This is then turned into a proper exception. &lt;strong&gt;Note&lt;/strong&gt;: Ordinary application code should not call this.</source>
          <target state="translated">一些内置函数设置错误标志。然后，这变成了适当的例外。&lt;strong&gt;注意&lt;/strong&gt;：普通应用程序代码不应调用此函数。</target>
        </trans-unit>
        <trans-unit id="ab83d5be81d7366ced8b35ee80f8254106e6acd0" translate="yes" xml:space="preserve">
          <source>Some child may be missing. A missing child is a node of kind &lt;code&gt;nnkEmpty&lt;/code&gt;; a child can never be nil.</source>
          <target state="translated">一些孩子可能失踪了。丢失的孩子是 &lt;code&gt;nnkEmpty&lt;/code&gt; 类的节点；一个孩子永远不能为零。</target>
        </trans-unit>
        <trans-unit id="01706013cfdbcb0fc543d3c97784f3f4c235d630" translate="yes" xml:space="preserve">
          <source>Some examples:</source>
          <target state="translated">一些例子:</target>
        </trans-unit>
        <trans-unit id="fe96e74863b969e67aadbcee97242dea95a7b5c7" translate="yes" xml:space="preserve">
          <source>Some file not essential for the compiler's working could not be opened.</source>
          <target state="translated">一些非编译器工作所必需的文件无法打开。</target>
        </trans-unit>
        <trans-unit id="a01546d483ad56932b56e6f4f843c335f7232622" translate="yes" xml:space="preserve">
          <source>Some keywords are unused; they are reserved for future developments of the language.</source>
          <target state="translated">有些关键词是未使用的,它们是为今后语言的发展而保留的。</target>
        </trans-unit>
        <trans-unit id="7cb6d242fa43323b661e091ed4496920bf211e2d" translate="yes" xml:space="preserve">
          <source>Some terminology: in the example &lt;code&gt;question&lt;/code&gt; is called a (formal) &lt;em&gt;parameter&lt;/em&gt;, &lt;code&gt;&quot;Should I...&quot;&lt;/code&gt; is called an &lt;em&gt;argument&lt;/em&gt; that is passed to this parameter.</source>
          <target state="translated">一些术语：在本例中 &lt;code&gt;question&lt;/code&gt; 被称为（正式的）&lt;em&gt;参数&lt;/em&gt;， &lt;code&gt;&quot;Should I...&quot;&lt;/code&gt; 被称为一个&lt;em&gt;参数&lt;/em&gt;传递给此参数。</target>
        </trans-unit>
        <trans-unit id="6e93c59acfbd4ca81868fe83cdee12101d3d70c7" translate="yes" xml:space="preserve">
          <source>Some user defined warning.</source>
          <target state="translated">一些用户定义的警告。</target>
        </trans-unit>
        <trans-unit id="3e528bc25235f43baac24e5a82e6fba6ce5447ef" translate="yes" xml:space="preserve">
          <source>Sometimes a C++ class has a private copy constructor and so code like &lt;code&gt;Class c = Class(1,2);&lt;/code&gt; must not be generated but instead &lt;code&gt;Class c(1,2);&lt;/code&gt;. For this purpose the Nim proc that wraps a C++ constructor needs to be annotated with the &lt;span id=&quot;constructor_1&quot;&gt;constructor&lt;/span&gt; pragma. This pragma also helps to generate faster C++ code since construction then doesn't invoke the copy constructor:</source>
          <target state="translated">有时，C ++类具有私有副本构造函数，因此代码类似 &lt;code&gt;Class c = Class(1,2);&lt;/code&gt; 不得生成，而应生成 &lt;code&gt;Class c(1,2);&lt;/code&gt; 。为此，包装C ++构造函数的Nim proc需要使用&lt;span id=&quot;constructor_1&quot;&gt;构造函数&lt;/span&gt; pragma 进行注释。该构造函数还有助于生成更快的C ++代码，因为构造然后不会调用副本构造函数：</target>
        </trans-unit>
        <trans-unit id="e2bd3dc5145a046d8756e4c3b5e6319385dd6c64" translate="yes" xml:space="preserve">
          <source>Somewhat confusingly, &lt;code&gt;spawn&lt;/code&gt; is also used in the &lt;code&gt;parallel&lt;/code&gt; statement with slightly different semantics. &lt;code&gt;spawn&lt;/code&gt; always takes a call expression of the form &lt;code&gt;f(a, ...)&lt;/code&gt;. Let &lt;code&gt;T&lt;/code&gt; be &lt;code&gt;f&lt;/code&gt;'s return type. If &lt;code&gt;T&lt;/code&gt; is &lt;code&gt;void&lt;/code&gt; then &lt;code&gt;spawn&lt;/code&gt;'s return type is also &lt;code&gt;void&lt;/code&gt; otherwise it is &lt;code&gt;FlowVar[T]&lt;/code&gt;.</source>
          <target state="translated">令人困惑的是，在 &lt;code&gt;parallel&lt;/code&gt; 语句中还使用了 &lt;code&gt;spawn&lt;/code&gt; ，但语义有所不同。 &lt;code&gt;spawn&lt;/code&gt; 始终采用 &lt;code&gt;f(a, ...)&lt;/code&gt; 形式的调用表达式。令 &lt;code&gt;T&lt;/code&gt; 为 &lt;code&gt;f&lt;/code&gt; 的返回类型。如果 &lt;code&gt;T&lt;/code&gt; 为 &lt;code&gt;void&lt;/code&gt; ,则 &lt;code&gt;spawn&lt;/code&gt; 的返回类型也为 &lt;code&gt;void&lt;/code&gt; ,否则为 &lt;code&gt;FlowVar[T]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6da13addb000b67d42a6d66391713819e634149f" translate="yes" xml:space="preserve">
          <source>Source</source>
          <target state="translated">Source</target>
        </trans-unit>
        <trans-unit id="e2de8e03eb7da80a014273d286391bd6a4e6c758" translate="yes" xml:space="preserve">
          <source>Source Code Filters</source>
          <target state="translated">源代码过滤器</target>
        </trans-unit>
        <trans-unit id="3c6c119ba4476a2d13a835d7d4fcadc52e3ed050" translate="yes" xml:space="preserve">
          <source>Source code filters</source>
          <target state="translated">源代码过滤器</target>
        </trans-unit>
        <trans-unit id="c53df7c2a21cf1297f0d2b03c1f92cdd4f7da3c4" translate="yes" xml:space="preserve">
          <source>Source highlighter for programming or markup languages. Currently only few languages are supported, other languages may be added. The interface supports one language nested in another.</source>
          <target state="translated">编程或标记语言的源码高亮器。目前只支持少数几种语言,可能会增加其他语言。该接口支持一种语言嵌套在另一种语言中。</target>
        </trans-unit>
        <trans-unit id="97ec2600b2e9e2b39f1b45d05ed5cf67fa2a6b53" translate="yes" xml:space="preserve">
          <source>Spacing also determines whether &lt;code&gt;(a, b)&lt;/code&gt; is parsed as an the argument list of a call or whether it is parsed as a tuple constructor:</source>
          <target state="translated">间隔还确定是否将 &lt;code&gt;(a, b)&lt;/code&gt; 解析为调用的参数列表，还是将其解析为元组构造函数：</target>
        </trans-unit>
        <trans-unit id="49958459a4b8e1eb5bdebb01446519ea2cfeeae3" translate="yes" xml:space="preserve">
          <source>Spacing and Whitespace Conventions</source>
          <target state="translated">间隔和空白约定</target>
        </trans-unit>
        <trans-unit id="f85b49adfe2544a4256034716240a926337b5692" translate="yes" xml:space="preserve">
          <source>Spawn statement</source>
          <target state="translated">生成声明</target>
        </trans-unit>
        <trans-unit id="491354246b5eb961b32b192cc1c055827162214c" translate="yes" xml:space="preserve">
          <source>Special Operators</source>
          <target state="translated">特种作业人员</target>
        </trans-unit>
        <trans-unit id="e552d4b23e8c0dfe309d5166ff7dd844ec3d8ffe" translate="yes" xml:space="preserve">
          <source>Special Types</source>
          <target state="translated">特殊类型</target>
        </trans-unit>
        <trans-unit id="b23516a1efd1b704e237ef91f3620e190e02d0f3" translate="yes" xml:space="preserve">
          <source>Special built-in that takes a variable number of arguments. Each argument is converted to a string via &lt;code&gt;$&lt;/code&gt;, so it works for user-defined types that have an overloaded &lt;code&gt;$&lt;/code&gt; operator. It is roughly equivalent to &lt;code&gt;writeLine(stdout, x); flushFile(stdout)&lt;/code&gt;, but available for the JavaScript target too.</source>
          <target state="translated">特殊的内置函数，带有可变数量的参数。每个参数都通过 &lt;code&gt;$&lt;/code&gt; 转换为字符串，因此它适用于带有 &lt;code&gt;$&lt;/code&gt; 运算符重载的用户定义类型。大致相当于 &lt;code&gt;writeLine(stdout, x); flushFile(stdout)&lt;/code&gt; ，但也可用于JavaScript目标。</target>
        </trans-unit>
        <trans-unit id="f05b76e5943515524507d846a60375ad51a71e57" translate="yes" xml:space="preserve">
          <source>Special care has to be taken if an untraced object contains traced objects like traced references, strings or sequences: in order to free everything properly, the built-in procedure &lt;code&gt;GCunref&lt;/code&gt; has to be called before freeing the untraced memory manually:</source>
          <target state="translated">如果未跟踪的对象包含诸如跟踪的引用，字符串或序列之类的跟踪对象，则必须格外小心：为了正确释放所有内容，必须在手动释放未跟踪的内存之前调用内置过程 &lt;code&gt;GCunref&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="a17ccd8347abd9eacd874ea7f27e074ed74467ae" translate="yes" xml:space="preserve">
          <source>Special compile-time procedure that checks whether &lt;em&gt;x&lt;/em&gt; can be compiled without any semantic error. This can be used to check whether a type supports some operation:</source>
          <target state="translated">特殊的编译时过程，用于检查&lt;em&gt;x&lt;/em&gt;是否可以编译而没有任何语义错误。这可用于检查类型是否支持某些操作：</target>
        </trans-unit>
        <trans-unit id="a820fa7aa10cc8d5c0e8b3e7af391dbbe69898ef" translate="yes" xml:space="preserve">
          <source>Special compile-time procedure that checks whether &lt;em&gt;x&lt;/em&gt; is declared in the current scope. &lt;em&gt;x&lt;/em&gt; has to be an identifier.</source>
          <target state="translated">特殊的编译时过程，用于检查&lt;em&gt;x&lt;/em&gt;是否在当前作用域中声明。&lt;em&gt;x&lt;/em&gt;必须是一个标识符。</target>
        </trans-unit>
        <trans-unit id="a4043ead367d4586fd4c1c0c21c211b7645a7f10" translate="yes" xml:space="preserve">
          <source>Special compile-time procedure that checks whether &lt;em&gt;x&lt;/em&gt; is declared. &lt;em&gt;x&lt;/em&gt; has to be an identifier or a qualified identifier. This can be used to check whether a library provides a certain feature or not:</source>
          <target state="translated">特殊的编译时过程，用于检查是否声明了&lt;em&gt;x&lt;/em&gt;。&lt;em&gt;x&lt;/em&gt;必须是标识符或合格标识符。这可用于检查库是否提供某些功能：</target>
        </trans-unit>
        <trans-unit id="7c5d0a758aca8fbe6d34b755784c8711b34f72c9" translate="yes" xml:space="preserve">
          <source>Special compile-time procedure that checks whether &lt;em&gt;x&lt;/em&gt; is defined. &lt;em&gt;x&lt;/em&gt; is an external symbol introduced through the compiler's &lt;a href=&quot;nimc#compile-time-symbols&quot;&gt;-d:x switch&lt;/a&gt; to enable build time conditionals:</source>
          <target state="translated">特殊的编译时过程，用于检查是否定义了&lt;em&gt;x&lt;/em&gt;。&lt;em&gt;x&lt;/em&gt;是通过编译器的&lt;a href=&quot;nimc#compile-time-symbols&quot;&gt;-d：x开关&lt;/a&gt;引入的外部符号，以启用构建时间条件：</target>
        </trans-unit>
        <trans-unit id="9417dbf6690f564bf56645ff26108dd839309071" translate="yes" xml:space="preserve">
          <source>Special future that acts as a queue. Its API is still experimental and so is subject to change.</source>
          <target state="translated">作为队列的特殊未来。它的API仍然是实验性的,所以可能会有变化。</target>
        </trans-unit>
        <trans-unit id="57782b746713c4b81ac3390082e47036bd29bd10" translate="yes" xml:space="preserve">
          <source>Special node kinds</source>
          <target state="translated">特殊节点种类</target>
        </trans-unit>
        <trans-unit id="202355e0f6c77c7ad33ab91f862395103c925576" translate="yes" xml:space="preserve">
          <source>Specifies an OS Error Code.</source>
          <target state="translated">指定OS错误代码。</target>
        </trans-unit>
        <trans-unit id="8fff1eb8c0263a617b1052dd18dc76abb01e14c4" translate="yes" xml:space="preserve">
          <source>Specifies the default calling convention for all procedures (and procedure types) that follow.</source>
          <target state="translated">指定后面所有过程(和过程类型)的默认调用惯例。</target>
        </trans-unit>
        <trans-unit id="33f3e9bd75e7c34e8805079b75662d2523e05166" translate="yes" xml:space="preserve">
          <source>Specifies whether this attribute was specified in the original document</source>
          <target state="translated">指定此属性是否在原始文档中被指定。</target>
        </trans-unit>
        <trans-unit id="9340a269dc5c3688e5ddd09b6883c53291b53287" translate="yes" xml:space="preserve">
          <source>Specify the suite name delimited by &lt;code&gt;&quot;::&quot;&lt;/code&gt;.</source>
          <target state="translated">指定套件名称，以 &lt;code&gt;&quot;::&quot;&lt;/code&gt; 分隔。</target>
        </trans-unit>
        <trans-unit id="ba777a0b8be9b27a2fc0aebaa99a53bd014d0bab" translate="yes" xml:space="preserve">
          <source>Specify the test name as a command line argument.</source>
          <target state="translated">指定测试名称作为命令行参数。</target>
        </trans-unit>
        <trans-unit id="9ce8d37027aa3f3951f0667dbca699e808c4574d" translate="yes" xml:space="preserve">
          <source>Specifying &lt;code&gt;fromProc&lt;/code&gt;, which is a string specifying the name of the proc that this future belongs to, is a good habit as it helps with debugging.</source>
          <target state="translated">指定 &lt;code&gt;fromProc&lt;/code&gt; 是一个好习惯，因为它是一个字符串，用于指定此future所属的proc的名称，因为它有助于调试。</target>
        </trans-unit>
        <trans-unit id="b1caea9869ffec0e67a014cd78af1ef02ba40db6" translate="yes" xml:space="preserve">
          <source>Specifying the location of the query</source>
          <target state="translated">指定查询的位置</target>
        </trans-unit>
        <trans-unit id="d3924b51dd7eaa83d08808569b1b0ce045cdc5be" translate="yes" xml:space="preserve">
          <source>Split a number into mantissa and exponent. &lt;em&gt;frexp&lt;/em&gt; calculates the mantissa m (a float greater than or equal to 0.5 and less than 1) and the integer value n such that &lt;em&gt;x&lt;/em&gt; (the original float value) equals m * 2**n. frexp stores n in &lt;em&gt;exponent&lt;/em&gt; and returns m.</source>
          <target state="translated">将数字分为尾数和指数。&lt;em&gt;frexp&lt;/em&gt;计算尾数m（大于或等于0.5且小于1的浮点数）和整数值n，以使&lt;em&gt;x&lt;/em&gt;（原始浮点值）等于m * 2 ** n。frexp以&lt;em&gt;指数&lt;/em&gt;形式存储n 并返回m。</target>
        </trans-unit>
        <trans-unit id="0745140758afddfc4ee7cc02a1b14f4076dc0642" translate="yes" xml:space="preserve">
          <source>Split the string at the first or last occurrence of &lt;em&gt;sep&lt;/em&gt; into a 3-tuple</source>
          <target state="translated">将第一次或最后一次出现&lt;em&gt;sep时&lt;/em&gt;的字符串拆分为3个元组</target>
        </trans-unit>
        <trans-unit id="696d32e8d8bbfbcb085e88d7ad30d5090043c8af" translate="yes" xml:space="preserve">
          <source>Split the string at the last occurrence of &lt;em&gt;sep&lt;/em&gt; into a 3-tuple</source>
          <target state="translated">在最后一次出现&lt;em&gt;sep时&lt;/em&gt;将字符串拆分为3个元组</target>
        </trans-unit>
        <trans-unit id="9b30837131faaf707d014d0ca36f825f274439f5" translate="yes" xml:space="preserve">
          <source>Splits a &lt;span id=&quot;command-line_1&quot;&gt;command line&lt;/span&gt; into several components; This proc is only occasionally useful, better use the &lt;em&gt;parseopt&lt;/em&gt; module.</source>
          <target state="translated">将&lt;span id=&quot;command-line_1&quot;&gt;命令行&lt;/span&gt;分为几个部分；此proc仅偶尔使用，最好使用&lt;em&gt;parseopt&lt;/em&gt;模块。</target>
        </trans-unit>
        <trans-unit id="e2f6fefaa7fc5767e6bf862c955b2209fdb94636" translate="yes" xml:space="preserve">
          <source>Splits a directory into (head, tail), so that &lt;code&gt;head / tail == path&lt;/code&gt; (except for edge cases like &quot;/usr&quot;).</source>
          <target state="translated">将目录拆分为（头，尾），以便 &lt;code&gt;head / tail == path&lt;/code&gt; （&amp;ldquo; / usr&amp;rdquo;之类的极端情况除外）。</target>
        </trans-unit>
        <trans-unit id="d3a95cdd0557cc6b3279f5bbb847dfba5f79895c" translate="yes" xml:space="preserve">
          <source>Splits a filename into (dir, filename, extension). &lt;em&gt;dir&lt;/em&gt; does not end in &lt;em&gt;DirSep&lt;/em&gt;. &lt;em&gt;extension&lt;/em&gt; includes the leading dot.</source>
          <target state="translated">将文件名拆分为（目录，文件名，扩展名）。&lt;em&gt;dir&lt;/em&gt;不会以&lt;em&gt;DirSep结尾&lt;/em&gt;。&lt;em&gt;扩展名&lt;/em&gt;包括前导点。</target>
        </trans-unit>
        <trans-unit id="38adfc0e948e54bb128886ea5c9d463e755da1e5" translate="yes" xml:space="preserve">
          <source>Splits and distributes a sequence &lt;em&gt;s&lt;/em&gt; into &lt;em&gt;num&lt;/em&gt; sub sequences.</source>
          <target state="translated">将序列&lt;em&gt;s&lt;/em&gt;拆分并分布为&lt;em&gt;num&lt;/em&gt;个子序列。</target>
        </trans-unit>
        <trans-unit id="a0c6e0e448f34874bff64437b7d2ab91fdf935d9" translate="yes" xml:space="preserve">
          <source>Splits the string &lt;code&gt;s&lt;/code&gt; at whitespace stripping leading and trailing whitespace if necessary. If &lt;code&gt;maxsplit&lt;/code&gt; is specified and is positive, no more than &lt;code&gt;maxsplit&lt;/code&gt; splits is made.</source>
          <target state="translated">如有必要，请在空格处分割字符串 &lt;code&gt;s&lt;/code&gt; ,以剥离开头和结尾的空格。如果指定了 &lt;code&gt;maxsplit&lt;/code&gt; 且为正数，则最多进行 &lt;code&gt;maxsplit&lt;/code&gt; 个分割。</target>
        </trans-unit>
        <trans-unit id="a79255370060c2e50f8a5845d572dc8618abf3bc" translate="yes" xml:space="preserve">
          <source>Splits the string &lt;code&gt;s&lt;/code&gt; into a seq of substrings.</source>
          <target state="translated">将字符串 &lt;code&gt;s&lt;/code&gt; 拆分为一系列子字符串。</target>
        </trans-unit>
        <trans-unit id="cb7b44f53469c886c88f238f833dcf716ae5cf1d" translate="yes" xml:space="preserve">
          <source>Splits the string &lt;code&gt;s&lt;/code&gt; into substrings.</source>
          <target state="translated">将字符串 &lt;code&gt;s&lt;/code&gt; 拆分为子字符串。</target>
        </trans-unit>
        <trans-unit id="7bee92474f34808ecc0e41e36df829980b2f1e85" translate="yes" xml:space="preserve">
          <source>Splits the string &lt;em&gt;s&lt;/em&gt; into its containing lines.</source>
          <target state="translated">将字符串&lt;em&gt;s&lt;/em&gt;拆分为其包含的行。</target>
        </trans-unit>
        <trans-unit id="5b2ee834c17d5b26b6e4fac9083478adf72ace42" translate="yes" xml:space="preserve">
          <source>Splits the string &lt;em&gt;s&lt;/em&gt; into substrings from the right using a string separator. Works exactly the same as &lt;a href=&quot;#split.i,string,char,int&quot;&gt;split iterator&lt;/a&gt; except in reverse order.</source>
          <target state="translated">使用字符串分隔符从右侧将字符串&lt;em&gt;s&lt;/em&gt;拆分为子字符串。与&lt;a href=&quot;#split.i,string,char,int&quot;&gt;拆分迭代器的&lt;/a&gt;工作原理完全相同，只是顺序相反。</target>
        </trans-unit>
        <trans-unit id="087310e18b69609a2aa211f0f42cebd7c1cd07af" translate="yes" xml:space="preserve">
          <source>Splits the string &lt;em&gt;s&lt;/em&gt; into substrings from the right using a string separator. Works exactly the same as &lt;a href=&quot;#split.i,string,string,int&quot;&gt;split iterator&lt;/a&gt; except in reverse order.</source>
          <target state="translated">使用字符串分隔符从右侧将字符串&lt;em&gt;s&lt;/em&gt;拆分为子字符串。与&lt;a href=&quot;#split.i,string,string,int&quot;&gt;拆分迭代器的&lt;/a&gt;工作原理完全相同，只是顺序相反。</target>
        </trans-unit>
        <trans-unit id="cd60b97467de78d203515610e7c117f7aca90a40" translate="yes" xml:space="preserve">
          <source>Splits the string &lt;em&gt;s&lt;/em&gt; into substrings using a group of separators.</source>
          <target state="translated">使用一组分隔符将字符串&lt;em&gt;s&lt;/em&gt;拆分为子字符串。</target>
        </trans-unit>
        <trans-unit id="006e1144089a0526e01f597553d1e7c5c932d6fd" translate="yes" xml:space="preserve">
          <source>Splits the string &lt;em&gt;s&lt;/em&gt; into substrings using a single separator.</source>
          <target state="translated">使用单个分隔符将字符串&lt;em&gt;s&lt;/em&gt;拆分为子字符串。</target>
        </trans-unit>
        <trans-unit id="f52fdc09a9930420c66d61ce94065811386774f2" translate="yes" xml:space="preserve">
          <source>Splits the string &lt;em&gt;s&lt;/em&gt; into substrings using a string separator.</source>
          <target state="translated">使用字符串分隔符将字符串&lt;em&gt;s&lt;/em&gt;拆分为子字符串。</target>
        </trans-unit>
        <trans-unit id="bdcf8c0eeb58a21cdf0ea123c375dc7b74b4c1c3" translate="yes" xml:space="preserve">
          <source>Splits the string &lt;em&gt;s&lt;/em&gt; into substrings.</source>
          <target state="translated">将字符串&lt;em&gt;s&lt;/em&gt;拆分为子字符串。</target>
        </trans-unit>
        <trans-unit id="7ba91be4e0a331af370fe3ce81d200f372c209c4" translate="yes" xml:space="preserve">
          <source>Square root for a complex number &lt;em&gt;z&lt;/em&gt;.</source>
          <target state="translated">复数&lt;em&gt;z的&lt;/em&gt;平方根。</target>
        </trans-unit>
        <trans-unit id="c7d890a6474c971c057ab4ea575d83552a62c69b" translate="yes" xml:space="preserve">
          <source>StackTrace</source>
          <target state="translated">StackTrace</target>
        </trans-unit>
        <trans-unit id="5834da0d9d1f734eeb82b865257b78b65132ac61" translate="yes" xml:space="preserve">
          <source>StackTrace option</source>
          <target state="translated">StackTrace选项</target>
        </trans-unit>
        <trans-unit id="97a27501491262c65d421114e5586483e201f5db" translate="yes" xml:space="preserve">
          <source>Standard format implementation for &lt;code&gt;SomeFloat&lt;/code&gt;. It makes little sense to call this directly, but it is required to exist by the &lt;code&gt;&amp;amp;&lt;/code&gt; macro.</source>
          <target state="translated">&lt;code&gt;SomeFloat&lt;/code&gt; 的标准格式实现。直接调用它几乎没有意义，但是 &lt;code&gt;&amp;amp;&lt;/code&gt; 宏要求它存在。</target>
        </trans-unit>
        <trans-unit id="6c9988eb477879aef4e84166efb847dbda62ecb3" translate="yes" xml:space="preserve">
          <source>Standard format implementation for &lt;code&gt;SomeInteger&lt;/code&gt;. It makes little sense to call this directly, but it is required to exist by the &lt;code&gt;&amp;amp;&lt;/code&gt; macro.</source>
          <target state="translated">&lt;code&gt;SomeInteger&lt;/code&gt; 的标准格式实现。直接调用它几乎没有意义，但是 &lt;code&gt;&amp;amp;&lt;/code&gt; 宏要求它存在。</target>
        </trans-unit>
        <trans-unit id="82b4f534d5b70cca26d540da82df24c1661c25fa" translate="yes" xml:space="preserve">
          <source>Standard format implementation for &lt;code&gt;string&lt;/code&gt;. It makes little sense to call this directly, but it is required to exist by the &lt;code&gt;&amp;amp;&lt;/code&gt; macro.</source>
          <target state="translated">&lt;code&gt;string&lt;/code&gt; 的标准格式实现。直接调用它几乎没有意义，但是 &lt;code&gt;&amp;amp;&lt;/code&gt; 宏要求它存在。</target>
        </trans-unit>
        <trans-unit id="286926a53b71c9700c85a0fe22c8494800f423ec" translate="yes" xml:space="preserve">
          <source>Standard format specifier for strings, integers and floats</source>
          <target state="translated">字符串、整数和浮点数的标准格式指定器。</target>
        </trans-unit>
        <trans-unit id="e4536991ce4cfc6d6a8e33066d777f94420dea8c" translate="yes" xml:space="preserve">
          <source>Start types with a capital &lt;code&gt;T&lt;/code&gt;, unless they are pointers/references which start with &lt;code&gt;P&lt;/code&gt;.</source>
          <target state="translated">以大写 &lt;code&gt;T&lt;/code&gt; 开头的类型，除非它们是以 &lt;code&gt;P&lt;/code&gt; 开头的指针/引用。</target>
        </trans-unit>
        <trans-unit id="59898b19b077c1855bd9ba49e69a1b8694d1ea8a" translate="yes" xml:space="preserve">
          <source>Start watching the file descriptor for read availability and then call the callback &lt;code&gt;cb&lt;/code&gt;.</source>
          <target state="translated">开始观察文件描述符的读取可用性，然后调用回调 &lt;code&gt;cb&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c48d22286fde2df857b4c72495d932198256b33b" translate="yes" xml:space="preserve">
          <source>Start watching the file descriptor for write availability and then call the callback &lt;code&gt;cb&lt;/code&gt;.</source>
          <target state="translated">开始观察文件描述符的写可用性，然后调用回调 &lt;code&gt;cb&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7e536d288d0851f6d9e8276875d7977f4844842b" translate="yes" xml:space="preserve">
          <source>Starting with c2nim version 0.9.8 it is also possible to directly embed Nim code in the C file. This is handy when you don't want to modify the generated Nim code at all. Nim code can be embedded directly via &lt;code&gt;#@ Nim code here @#&lt;/code&gt;:</source>
          <target state="translated">从c2nim 0.9.8版开始，还可以将Nim代码直接嵌入C文件中。当您根本不想修改生成的Nim代码时，这非常方便。Nim代码可以通过 &lt;code&gt;#@ Nim code here @#&lt;/code&gt; 直接嵌入在这里@＃：</target>
        </trans-unit>
        <trans-unit id="bde902e0e1c0a059e5fe83c9f5f9792a0e51c8a5" translate="yes" xml:space="preserve">
          <source>Starting with the simplest case, a &lt;code&gt;type&lt;/code&gt; section appears much like &lt;code&gt;var&lt;/code&gt; and &lt;code&gt;const&lt;/code&gt;.</source>
          <target state="translated">从最简单的情况开始， &lt;code&gt;type&lt;/code&gt; 部分看起来很像 &lt;code&gt;var&lt;/code&gt; 和 &lt;code&gt;const&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5750880c4922c991ffb618071f7738d4d0253363" translate="yes" xml:space="preserve">
          <source>Starting with version 0.13.0 of the language Nim supports multiline comments. They look like:</source>
          <target state="translated">从0.13.0版本的语言开始,Nim支持多行注释。它们看起来像:</target>
        </trans-unit>
        <trans-unit id="0bc24feae6a6568706e81e7f2d7d483485e4dca3" translate="yes" xml:space="preserve">
          <source>Starting with version 0.14 of the language, Nim supports &lt;code&gt;field&lt;/code&gt; as a shortcut for &lt;code&gt;self.field&lt;/code&gt; comparable to the &lt;span id=&quot;this_1&quot;&gt;this&lt;/span&gt; keyword in Java or C++. This feature has to be explicitly enabled via a &lt;code&gt;{.this: self.}&lt;/code&gt; statement pragma. This pragma is active for the rest of the module:</source>
          <target state="translated">从该语言的0.14版本开始，Nim支持 &lt;code&gt;field&lt;/code&gt; 作为 &lt;code&gt;self.field&lt;/code&gt; 的快捷方式，与Java或C ++中的&lt;span id=&quot;this_1&quot;&gt;this&lt;/span&gt;关键字相当。必须通过 &lt;code&gt;{.this: self.}&lt;/code&gt; 语句编译指示显式启用此功能。该编译指示对模块的其余部分有效：</target>
        </trans-unit>
        <trans-unit id="fb2ad21d99439d76c4ae769b916f899ad8dad268" translate="yes" xml:space="preserve">
          <source>Starts a process. &lt;em&gt;Command&lt;/em&gt; is the executable file, &lt;em&gt;workingDir&lt;/em&gt; is the process's working directory. If &lt;code&gt;workingDir == &quot;&quot;&lt;/code&gt; the current directory is used. &lt;em&gt;args&lt;/em&gt; are the command line arguments that are passed to the process. On many operating systems, the first command line argument is the name of the executable. &lt;em&gt;args&lt;/em&gt; should not contain this argument! &lt;em&gt;env&lt;/em&gt; is the environment that will be passed to the process. If &lt;code&gt;env == nil&lt;/code&gt; the environment is inherited of the parent process. &lt;em&gt;options&lt;/em&gt; are additional flags that may be passed to &lt;em&gt;startProcess&lt;/em&gt;. See the documentation of &lt;code&gt;ProcessOption&lt;/code&gt; for the meaning of these flags. You need to &lt;em&gt;close&lt;/em&gt; the process when done.</source>
          <target state="translated">开始一个过程。&lt;em&gt;Command&lt;/em&gt;是可执行文件，&lt;em&gt;workingDir&lt;/em&gt;是进程的工作目录。如果 &lt;code&gt;workingDir == &quot;&quot;&lt;/code&gt; ，则使用当前目录。&lt;em&gt;args&lt;/em&gt;是传递给进程的命令行参数。在许多操作系统上，第一个命令行参数是可执行文件的名称。&lt;em&gt;args&lt;/em&gt;不应包含此参数！&lt;em&gt;env&lt;/em&gt;是将传递给流程的环境。如果 &lt;code&gt;env == nil&lt;/code&gt; 则环境继承自父进程。&lt;em&gt;options&lt;/em&gt;是可以传递给&lt;em&gt;startProcess的&lt;/em&gt;其他标志。请参阅 &lt;code&gt;ProcessOption&lt;/code&gt; 的文档这些标志的含义。完成后，您需要&lt;em&gt;关闭&lt;/em&gt;该过程。</target>
        </trans-unit>
        <trans-unit id="e1e47e87b9fe76e44fbbfad1b5c2f3cec6f694d4" translate="yes" xml:space="preserve">
          <source>Starts main coroutine scheduler loop which exits when all coroutines exit. Calling this proc starts execution of first coroutine.</source>
          <target state="translated">启动主coroutine调度循环,当所有coroutine退出时,该循环退出。调用该 proc,开始执行第一个 coroutine。</target>
        </trans-unit>
        <trans-unit id="e4b62e8fbf218158e05c575bcb526db8434456d7" translate="yes" xml:space="preserve">
          <source>Starts the process of listening for incoming HTTP connections on the specified address and port.</source>
          <target state="translated">启动监听指定地址和端口的HTTP连接的过程。</target>
        </trans-unit>
        <trans-unit id="95e9a635c9383520925e14042d4b923fd6c3ac7c" translate="yes" xml:space="preserve">
          <source>Startswith vs full match</source>
          <target state="translated">开始与全场比赛</target>
        </trans-unit>
        <trans-unit id="2f3fd7595abb518c6624f116892060fa788f065b" translate="yes" xml:space="preserve">
          <source>State of the random number generator. The procs that use the default state are &lt;strong&gt;not&lt;/strong&gt; thread-safe!</source>
          <target state="translated">随机数生成器的状态。使用默认状态的过程&lt;strong&gt;不是&lt;/strong&gt;线程安全的！</target>
        </trans-unit>
        <trans-unit id="585af40bd2ea53a8fcbac51a9fdd078062535c3e" translate="yes" xml:space="preserve">
          <source>Statement Macros</source>
          <target state="translated">语句宏</target>
        </trans-unit>
        <trans-unit id="c1d090a6c68c4210ac3bd5dfc03a161d8ee95112" translate="yes" xml:space="preserve">
          <source>Statement list</source>
          <target state="translated">声明列表</target>
        </trans-unit>
        <trans-unit id="e9d413cd91133512c4e3171d0a7ea1f91f1b99be" translate="yes" xml:space="preserve">
          <source>Statement list expression</source>
          <target state="translated">声明列表表达式</target>
        </trans-unit>
        <trans-unit id="561838a377363a51093422d3a816d894fc64a7aa" translate="yes" xml:space="preserve">
          <source>Statement macros are defined just as expression macros. However, they are invoked by an expression following a colon.</source>
          <target state="translated">语句宏的定义与表达式宏一样。但是,它们是由冒号后面的表达式调用的。</target>
        </trans-unit>
        <trans-unit id="5653cebc057d4791ce07031ad9286e729de6d691" translate="yes" xml:space="preserve">
          <source>Statements</source>
          <target state="translated">Statements</target>
        </trans-unit>
        <trans-unit id="5328a225bf88e0ed36c05ac4a8717682f2fb065b" translate="yes" xml:space="preserve">
          <source>Statements and expressions</source>
          <target state="translated">语句和表达方式</target>
        </trans-unit>
        <trans-unit id="28b50d2ede0bbc0df4e2532f866848d6bf82cffb" translate="yes" xml:space="preserve">
          <source>Statements and indentation</source>
          <target state="translated">声明和缩进</target>
        </trans-unit>
        <trans-unit id="2f0b50bd8139f25d6003b6a910f512893ff24a3e" translate="yes" xml:space="preserve">
          <source>Statements are separated into &lt;span id=&quot;simple-statements_1&quot;&gt;simple statements&lt;/span&gt; and &lt;span id=&quot;complex-statements_1&quot;&gt;complex statements&lt;/span&gt;. Simple statements are statements that cannot contain other statements like assignments, calls or the &lt;code&gt;return&lt;/code&gt; statement; complex statements can contain other statements. To avoid the &lt;span id=&quot;dangling-else-problem_1&quot;&gt;dangling else problem&lt;/span&gt;, complex statements always have to be indented. The details can be found in the grammar.</source>
          <target state="translated">语句分为&lt;span id=&quot;simple-statements_1&quot;&gt;简单语句&lt;/span&gt;和&lt;span id=&quot;complex-statements_1&quot;&gt;复杂语句&lt;/span&gt;。简单语句是不能包含其他语句（如赋值，调用或 &lt;code&gt;return&lt;/code&gt; 语句）的语句；复杂语句可以包含其他语句。为了避免&lt;span id=&quot;dangling-else-problem_1&quot;&gt;悬而未决的问题&lt;/span&gt;，总是必须缩进复杂的语句。细节可以在语法中找到。</target>
        </trans-unit>
        <trans-unit id="73e132de8d234237b097eae09c8f41a5d3aeb437" translate="yes" xml:space="preserve">
          <source>Statements can also occur in an expression context that looks like &lt;code&gt;(stmt1; stmt2; ...; ex)&lt;/code&gt;. This is called an statement list expression or &lt;code&gt;(;)&lt;/code&gt;. The type of &lt;code&gt;(stmt1; stmt2; ...; ex)&lt;/code&gt; is the type of &lt;code&gt;ex&lt;/code&gt;. All the other statements must be of type &lt;code&gt;void&lt;/code&gt;. (One can use &lt;code&gt;discard&lt;/code&gt; to produce a &lt;code&gt;void&lt;/code&gt; type.) &lt;code&gt;(;)&lt;/code&gt; does not introduce a new scope.</source>
          <target state="translated">语句也可以出现在看起来像 &lt;code&gt;(stmt1; stmt2; ...; ex)&lt;/code&gt; 的表达式上下文中。这称为语句列表表达式或 &lt;code&gt;(;)&lt;/code&gt; 。该类型的 &lt;code&gt;(stmt1; stmt2; ...; ex)&lt;/code&gt; 是类型 &lt;code&gt;ex&lt;/code&gt; 。所有其他语句必须为 &lt;code&gt;void&lt;/code&gt; 类型。（一个人可以使用 &lt;code&gt;discard&lt;/code&gt; 产生一个 &lt;code&gt;void&lt;/code&gt; 类型。） &lt;code&gt;(;)&lt;/code&gt; 不会引入新的作用域。</target>
        </trans-unit>
        <trans-unit id="09ba2d803c92fca5d318023b8b22a1bf044aeec2" translate="yes" xml:space="preserve">
          <source>States that &lt;em&gt;every&lt;/em&gt; other parameter must not alias with the marked parameter.</source>
          <target state="translated">声明&lt;em&gt;所有&lt;/em&gt;其他参数都不得与标记的参数混用。</target>
        </trans-unit>
        <trans-unit id="b21c7be07ec4d071647590676d7c707716706eb2" translate="yes" xml:space="preserve">
          <source>States that the marked parameter needs to alias with &lt;em&gt;some&lt;/em&gt; other parameter.</source>
          <target state="translated">指出标记的参数需要与其他&lt;em&gt;一些&lt;/em&gt;参数混叠。</target>
        </trans-unit>
        <trans-unit id="bda29e5bb4f9a6e91109576feba5b699a9ffa7c4" translate="yes" xml:space="preserve">
          <source>Static params can also appear in the signatures of generic types:</source>
          <target state="translated">静态参数也可以出现在通用类型的签名中。</target>
        </trans-unit>
        <trans-unit id="fd4eea69c0fcf4c239e8f32cdb22fe3e56921d96" translate="yes" xml:space="preserve">
          <source>Static statement/expression</source>
          <target state="translated">静态声明/表达式</target>
        </trans-unit>
        <trans-unit id="1efa0116abdd20c68f5da9f1569291c9d6bcab18" translate="yes" xml:space="preserve">
          <source>Static types, like &lt;code&gt;static[int]&lt;/code&gt;, use &lt;code&gt;nnkIdent&lt;/code&gt; wrapped in &lt;code&gt;nnkStaticTy&lt;/code&gt;.</source>
          <target state="translated">静态类型，如 &lt;code&gt;static[int]&lt;/code&gt; ，使用 &lt;code&gt;nnkIdent&lt;/code&gt; 包裹在 &lt;code&gt;nnkStaticTy&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="df6826b4250b90fb4e378254d9554431e3e76513" translate="yes" xml:space="preserve">
          <source>Statically typed wrapper around a JavaScript object.</source>
          <target state="translated">围绕一个JavaScript对象的静态类型包装器。</target>
        </trans-unit>
        <trans-unit id="f99da6af391d7d0b1782b934b78439cc36d3ec64" translate="yes" xml:space="preserve">
          <source>Statistical analysis framework for performing basic statistical analysis of data. The data is analysed in a single pass, when a data value is pushed to the &lt;code&gt;RunningStat&lt;/code&gt; or &lt;code&gt;RunningRegress&lt;/code&gt; objects</source>
          <target state="translated">统计分析框架，用于执行数据的基本统计分析。在单次通过的数据进行分析，当数据值被推向 &lt;code&gt;RunningStat&lt;/code&gt; 或 &lt;code&gt;RunningRegress&lt;/code&gt; 对象</target>
        </trans-unit>
        <trans-unit id="95c5b7897012d8f6b29894d9aacb62893a21c7dd" translate="yes" xml:space="preserve">
          <source>StdTmpl filter</source>
          <target state="translated">StdTmpl过滤器</target>
        </trans-unit>
        <trans-unit id="2d517ff3e91f20612466e4d677722b435331123f" translate="yes" xml:space="preserve">
          <source>Stop the process &lt;em&gt;p&lt;/em&gt;. On Posix OSes the procedure sends &lt;code&gt;SIGTERM&lt;/code&gt; to the process. On Windows the Win32 API function &lt;code&gt;TerminateProcess()&lt;/code&gt; is called to stop the process.</source>
          <target state="translated">停止过程&lt;em&gt;p&lt;/em&gt;。在Posix OS上，该过程将 &lt;code&gt;SIGTERM&lt;/code&gt; 发送到该进程。在Windows上，将调用Win32 API函数 &lt;code&gt;TerminateProcess()&lt;/code&gt; 来停止进程。</target>
        </trans-unit>
        <trans-unit id="193670292bbf8be6929e6f76418e0773142d3e9f" translate="yes" xml:space="preserve">
          <source>Stops coroutine execution and resumes no sooner than after &lt;code&gt;sleeptime&lt;/code&gt; seconds. Until then other coroutines are executed.</source>
          <target state="translated">停止协程执行，并且 &lt;code&gt;sleeptime&lt;/code&gt; 于睡眠时间秒后恢复。在此之前，将执行其他协程。</target>
        </trans-unit>
        <trans-unit id="c692f32f2608c4a295dcfea18799b8cd9fd2f756" translate="yes" xml:space="preserve">
          <source>Stops the program immediately with an exit code.</source>
          <target state="translated">用退出代码立即停止程序。</target>
        </trans-unit>
        <trans-unit id="6c7da5ae9d8453249af10e3df51f169922c5fe26" translate="yes" xml:space="preserve">
          <source>Store implementation-defined representation of the exception flags indicated by &lt;em&gt;excepts&lt;/em&gt; in the object pointed to by &lt;em&gt;flagp&lt;/em&gt;.</source>
          <target state="translated">存储实现定义所指示的异常标志的表示&lt;em&gt;节选&lt;/em&gt;的指向对象中的&lt;em&gt;flagp&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="bd07ac3fcadc296f8eadaaee32c2d2045b485375" translate="yes" xml:space="preserve">
          <source>Store the current floating-point environment in the object pointed to by &lt;em&gt;envp&lt;/em&gt;.</source>
          <target state="translated">将当前浮点环境存储​​在&lt;em&gt;envp&lt;/em&gt;指向的对象中。</target>
        </trans-unit>
        <trans-unit id="ed122e970e1da75eae7113f501ba6a2683599b66" translate="yes" xml:space="preserve">
          <source>Stores arbitrary data inside SSLContext. The unique &lt;em&gt;index&lt;/em&gt; should be retrieved using getSslContextExtraDataIndex.</source>
          <target state="translated">在SSLContext内部存储任意数据。应使用getSslContextExtraDataIndex检索唯一&lt;em&gt;索引&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="3561a6520c3d5d295122d365e075a71d866713db" translate="yes" xml:space="preserve">
          <source>Stores the empty string or the last headline/overline found in the rst document, so it can be used as a prettier name for term index generation.</source>
          <target state="translated">存储空字符串或在第1个文档中发现的最后一个标题/横线,因此它可以作为术语索引生成的一个更漂亮的名字。</target>
        </trans-unit>
        <trans-unit id="48c0d4450fba91caf6c704085748bb15b5343e9a" translate="yes" xml:space="preserve">
          <source>Stream interface that supports writing or reading. Note that these fields here shouldn't be used directly. They are accessible so that a stream implementation can override them.</source>
          <target state="translated">支持写或读的流接口。注意,这里的这些字段不应该直接使用。它们是可以访问的,这样流的实现就可以覆盖它们。</target>
        </trans-unit>
        <trans-unit id="51a31e0d2f2e0f77e70f94326ee6904303908d73" translate="yes" xml:space="preserve">
          <source>String &lt;span id=&quot;interpolation_1&quot;&gt;interpolation&lt;/span&gt; / &lt;span id=&quot;format_1&quot;&gt;format&lt;/span&gt; inspired by Python's &lt;code&gt;f&lt;/code&gt;-strings.</source>
          <target state="translated">受Python &lt;code&gt;f&lt;/code&gt; 字符串启发的字符串&lt;span id=&quot;interpolation_1&quot;&gt;插值&lt;/span&gt; / &lt;span id=&quot;format_1&quot;&gt;格式&lt;/span&gt;。</target>
        </trans-unit>
        <trans-unit id="dff366ef5455c79b8728295225889786b796cf17" translate="yes" xml:space="preserve">
          <source>String and character literals</source>
          <target state="translated">字符串和字符字数</target>
        </trans-unit>
        <trans-unit id="8592962cea78137eedb95afe4474ceef0bee804c" translate="yes" xml:space="preserve">
          <source>String assignments are sometimes expensive in Nim: They are required to copy the whole string. However, the compiler is often smart enough to not copy strings. Due to the argument passing semantics, strings are never copied when passed to subroutines. The compiler does not copy strings that are a result from a procedure call, because the callee returns a new string anyway. Thus it is efficient to do:</source>
          <target state="translated">字符串赋值在Nim中有时很昂贵。它们需要复制整个字符串。然而,编译器通常很聪明,不会复制字符串。由于参数传递的语义,当传递给子程序时,字符串永远不会被复制。编译器不会复制过程调用的结果的字符串,因为反正被调用者会返回一个新的字符串。因此这样做很有效率。</target>
        </trans-unit>
        <trans-unit id="f72b5d43e5245ea7b69b536ff3f8c988cbabcd7f" translate="yes" xml:space="preserve">
          <source>String handling</source>
          <target state="translated">字符串处理</target>
        </trans-unit>
        <trans-unit id="5993cb336c6391ee8eea94b873bb797a1c4d4619" translate="yes" xml:space="preserve">
          <source>String literals</source>
          <target state="translated">字符串</target>
        </trans-unit>
        <trans-unit id="af12c2e063676108d00610ed5b2b199ea508a589" translate="yes" xml:space="preserve">
          <source>String literals are enclosed in double quotes. The &lt;code&gt;var&lt;/code&gt; statement declares a new variable named &lt;code&gt;name&lt;/code&gt; of type &lt;code&gt;string&lt;/code&gt; with the value that is returned by the &lt;a href=&quot;system#readLine,File&quot;&gt;readLine&lt;/a&gt; procedure. Since the compiler knows that &lt;a href=&quot;system#readLine,File&quot;&gt;readLine&lt;/a&gt; returns a string, you can leave out the type in the declaration (this is called &lt;span id=&quot;local-type-inference_1&quot;&gt;local type inference&lt;/span&gt;). So this will work too:</source>
          <target state="translated">字符串文字用双引号引起来。该 &lt;code&gt;var&lt;/code&gt; 语句声明了一个新变量命名 &lt;code&gt;name&lt;/code&gt; 类型的 &lt;code&gt;string&lt;/code&gt; 与由返回值&lt;a href=&quot;system#readLine,File&quot;&gt;的readLine&lt;/a&gt;程序。由于编译器知道&lt;a href=&quot;system#readLine,File&quot;&gt;readLine&lt;/a&gt;返回一个字符串，因此您可以在声明中省略该类型（这称为&lt;span id=&quot;local-type-inference_1&quot;&gt;本地类型推断&lt;/span&gt;）。因此，这也将起作用：</target>
        </trans-unit>
        <trans-unit id="cbd76253c7810952b365eda2c20cec5a247a7e14" translate="yes" xml:space="preserve">
          <source>String literals are enclosed in double quotes; character literals in single quotes. Special characters are escaped with &lt;code&gt;\&lt;/code&gt;: &lt;code&gt;\n&lt;/code&gt; means newline, &lt;code&gt;\t&lt;/code&gt; means tabulator, etc. There are also &lt;em&gt;raw&lt;/em&gt; string literals:</source>
          <target state="translated">字符串文字用双引号引起来；单引号中的字符文字。特殊字符用 &lt;code&gt;\&lt;/code&gt; 进行转义： &lt;code&gt;\n&lt;/code&gt; 表示换行符， &lt;code&gt;\t&lt;/code&gt; 表示制表符，等等。还有&lt;em&gt;原始&lt;/em&gt;字符串文字：</target>
        </trans-unit>
        <trans-unit id="91beede65eb4bf81fa0a0b03f71ed1840d87fbad" translate="yes" xml:space="preserve">
          <source>String literals can also be delimited by three double quotes &lt;code&gt;&quot;&quot;&quot;&lt;/code&gt; ... &lt;code&gt;&quot;&quot;&quot;&lt;/code&gt;. Literals in this form may run for several lines, may contain &lt;code&gt;&quot;&lt;/code&gt; and do not interpret any escape sequences. For convenience, when the opening &lt;code&gt;&quot;&quot;&quot;&lt;/code&gt; is followed by a newline (there may be whitespace between the opening &lt;code&gt;&quot;&quot;&quot;&lt;/code&gt; and the newline), the newline (and the preceding whitespace) is not included in the string. The ending of the string literal is defined by the pattern &lt;code&gt;&quot;&quot;&quot;[^&quot;]&lt;/code&gt;, so this:</source>
          <target state="translated">字符串文字也可以由三个双引号 &lt;code&gt;&quot;&quot;&quot;&lt;/code&gt; ... &lt;code&gt;&quot;&quot;&quot;&lt;/code&gt; 分隔。这种形式的文字可能会运行多行，可能包含 &lt;code&gt;&quot;&lt;/code&gt; 并且不解释任何转义序列。为方便起见，当在开头的 &lt;code&gt;&quot;&quot;&quot;&lt;/code&gt; 后面接换行符（在开头的 &lt;code&gt;&quot;&quot;&quot;&lt;/code&gt; 与换行符之间可能会有空格） ，字符串中不包含换行符（和前面的空格）。字符串文字的结尾由模式 &lt;code&gt;&quot;&quot;&quot;[^&quot;]&lt;/code&gt; ，因此：</target>
        </trans-unit>
        <trans-unit id="a98bf22b08be1e87b2f87e1e68dc04c240c4f84a" translate="yes" xml:space="preserve">
          <source>String literals can be delimited by matching double quotes, and can contain the following &lt;span id=&quot;escape-sequences_1&quot;&gt;escape sequences&lt;/span&gt;:</source>
          <target state="translated">字符串文字可以通过匹配双引号来定界，并且可以包含以下&lt;span id=&quot;escape-sequences_1&quot;&gt;转义序列&lt;/span&gt;：</target>
        </trans-unit>
        <trans-unit id="add4920af30df00399258f443c32b23c074019f6" translate="yes" xml:space="preserve">
          <source>String match ignoring case for back reference.</source>
          <target state="translated">字符串匹配,忽略大小写作为后方参考。</target>
        </trans-unit>
        <trans-unit id="2a6aa06ff131f3961de8e3d1902b39032ccdc0a1" translate="yes" xml:space="preserve">
          <source>String match ignoring case.</source>
          <target state="translated">字符串匹配无视大小写。</target>
        </trans-unit>
        <trans-unit id="147076ac16a166598cdc8c313b99f065ab615a6a" translate="yes" xml:space="preserve">
          <source>String match ignoring style for back reference.</source>
          <target state="translated">字符串匹配,忽略样式,供后面参考。</target>
        </trans-unit>
        <trans-unit id="bb24a4c20f47d52b01a258419055f6b3dfdee121" translate="yes" xml:space="preserve">
          <source>String match ignoring style.</source>
          <target state="translated">字符串匹配忽略风格。</target>
        </trans-unit>
        <trans-unit id="02ac6c5d15d3833eb25c8fee2851790ab39dbbb4" translate="yes" xml:space="preserve">
          <source>String type</source>
          <target state="translated">字符串类型</target>
        </trans-unit>
        <trans-unit id="986c54b2d8959694bd3a8d1059f1a28ae674bd61" translate="yes" xml:space="preserve">
          <source>String variables are &lt;strong&gt;mutable&lt;/strong&gt;, so appending to a string is possible, and quite efficient. Strings in Nim are both zero-terminated and have a length field. A string's length can be retrieved with the builtin &lt;code&gt;len&lt;/code&gt; procedure; the length never counts the terminating zero. Accessing the terminating zero is an error, it only exists so that a Nim string can be converted to a &lt;code&gt;cstring&lt;/code&gt; without doing a copy.</source>
          <target state="translated">字符串变量是&lt;strong&gt;可变的&lt;/strong&gt;，因此可以将其追加到字符串中，而且效率很高。Nim中的字符串都以零结尾并且具有长度字段。可以使用内置的 &lt;code&gt;len&lt;/code&gt; 过程来检索字符串的长度。长度永远不会计入终止零。访问终止零是一个错误，它仅存在，因此Nim字符串无需转换即可转换为 &lt;code&gt;cstring&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9582510d33852bda61d01257c5b36aff25c4246c" translate="yes" xml:space="preserve">
          <source>String: If the text ahead is the string &lt;em&gt;s&lt;/em&gt;, consume it and indicate success. Otherwise indicate failure.</source>
          <target state="translated">字符串：如果前面的文本是字符串&lt;em&gt;s&lt;/em&gt;，请使用它并表示成功。否则表示失败。</target>
        </trans-unit>
        <trans-unit id="3816c4beac471c733eed1d91c213f8c2b6a29262" translate="yes" xml:space="preserve">
          <source>Strings</source>
          <target state="translated">Strings</target>
        </trans-unit>
        <trans-unit id="3fef5979e2a970ce485675c739e2e35d04689a53" translate="yes" xml:space="preserve">
          <source>Strings and C strings</source>
          <target state="translated">字符串和C字串</target>
        </trans-unit>
        <trans-unit id="1b710e9083a424ca250da057248ace9578ab56d8" translate="yes" xml:space="preserve">
          <source>Strings are compared by their lexicographical order. All comparison operators are available. Strings can be indexed like arrays (lower bound is 0). Unlike arrays, they can be used in case statements:</source>
          <target state="translated">字符串按其词法顺序进行比较。所有的比较运算符都是可用的。字符串可以像数组一样进行索引(下界为0)。与数组不同的是,它们可以在case语句中使用。</target>
        </trans-unit>
        <trans-unit id="09c9bb4c72fe3ad8b1a94e6b29d07b028ab504ba" translate="yes" xml:space="preserve">
          <source>Strings are compared using their lexicographical order. All the comparison operators are supported. By convention, all strings are UTF-8 encoded, but this is not enforced. For example, when reading strings from binary files, they are merely a sequence of bytes. The index operation &lt;code&gt;s[i]&lt;/code&gt; means the i-th &lt;em&gt;char&lt;/em&gt; of &lt;code&gt;s&lt;/code&gt;, not the i-th &lt;em&gt;unichar&lt;/em&gt;.</source>
          <target state="translated">字符串按其字典顺序进行比较。支持所有比较运算符。按照约定，所有字符串均采用UTF-8编码，但这不是强制性的。例如，当从二进制文件中读取字符串时，它们只是字节序列。索引操作 &lt;code&gt;s[i]&lt;/code&gt; 表示的第i个&lt;em&gt;字符&lt;/em&gt;的 &lt;code&gt;s&lt;/code&gt; ，而不是第i个&lt;em&gt;单字符&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="68f5a8dcb38cb2dcf8c5a38294f5911b71dc18ba" translate="yes" xml:space="preserve">
          <source>Strings in Nim may contain any 8-bit value, even embedded zeros. However some operations may interpret the first binary zero as a terminator.</source>
          <target state="translated">Nim中的字符串可以包含任何8位值,甚至是内嵌的0。但是有些操作可能会将第一个二进制零解释为终止符。</target>
        </trans-unit>
        <trans-unit id="5b34aa10a7504c11b1c238076600885e8cb63777" translate="yes" xml:space="preserve">
          <source>Strip filter</source>
          <target state="translated">剥离过滤器</target>
        </trans-unit>
        <trans-unit id="98e0d86ad6cb0129df0228988af89dce21ec584d" translate="yes" xml:space="preserve">
          <source>Strips leading or trailing &lt;em&gt;chars&lt;/em&gt; from &lt;em&gt;s&lt;/em&gt; and returns the resulting string.</source>
          <target state="translated">从&lt;em&gt;s&lt;/em&gt;剥离前导或尾随&lt;em&gt;字符&lt;/em&gt;，并返回结果字符串。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c8ff4b4dfac3e5ecfb01fa66e040f2be24062608" translate="yes" xml:space="preserve">
          <source>Structured types</source>
          <target state="translated">结构化类型</target>
        </trans-unit>
        <trans-unit id="6617ba0382b36cb88686c64241a0d1066459e84e" translate="yes" xml:space="preserve">
          <source>Style insensitive comparison.</source>
          <target state="translated">风格不敏感的比较。</target>
        </trans-unit>
        <trans-unit id="47c3fbfee5ccaddc82435585c637b37f1eed421b" translate="yes" xml:space="preserve">
          <source>Style insensitive comparison. &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; can be an identifier or a symbol.</source>
          <target state="translated">样式不敏感的比较。 &lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;b&lt;/code&gt; 可以是标识符或符号。</target>
        </trans-unit>
        <trans-unit id="327f538ea37da49ccf2c271b65129745ac5559a5" translate="yes" xml:space="preserve">
          <source>Style insensitive comparison. &lt;code&gt;a&lt;/code&gt; can be an identifier or a symbol.</source>
          <target state="translated">样式不敏感的比较。 &lt;code&gt;a&lt;/code&gt; 可以是标识符或符号。</target>
        </trans-unit>
        <trans-unit id="a24820daa51bd1dce30c8565c1d952ac958b1e4f" translate="yes" xml:space="preserve">
          <source>Style insensitive comparison. &lt;code&gt;b&lt;/code&gt; can be an identifier or a symbol.</source>
          <target state="translated">样式不敏感的比较。 &lt;code&gt;b&lt;/code&gt; 可以是标识符或符号。</target>
        </trans-unit>
        <trans-unit id="af3750102e983bbf33f619b8dae0de2a0f4b3c0c" translate="yes" xml:space="preserve">
          <source>Subrange of &lt;code&gt;TimeUnit&lt;/code&gt; that only includes units of fixed duration. These are the units that can be represented by a &lt;code&gt;Duration&lt;/code&gt;.</source>
          <target state="translated">的子范围 &lt;code&gt;TimeUnit&lt;/code&gt; 仅包括固定持续时间的单元。这些是可以由 &lt;code&gt;Duration&lt;/code&gt; 表示的单位。</target>
        </trans-unit>
        <trans-unit id="c3435d7cc8ec39979e476fdb02a131d9a1f16a5a" translate="yes" xml:space="preserve">
          <source>Subrange or subtype match: &lt;code&gt;a&lt;/code&gt; is a &lt;code&gt;range[T]&lt;/code&gt; and &lt;code&gt;T&lt;/code&gt; matches &lt;code&gt;f&lt;/code&gt; exactly. Or: &lt;code&gt;a&lt;/code&gt; is a subtype of &lt;code&gt;f&lt;/code&gt;.</source>
          <target state="translated">子 &lt;code&gt;range[T]&lt;/code&gt; 或子类型匹配： &lt;code&gt;a&lt;/code&gt; 是range [T]， &lt;code&gt;T&lt;/code&gt; 精确匹配 &lt;code&gt;f&lt;/code&gt; 。或者： &lt;code&gt;a&lt;/code&gt; 是 &lt;code&gt;f&lt;/code&gt; 的子类型。</target>
        </trans-unit>
        <trans-unit id="6ee14d0889156d81963bda220fbb8514a525f717" translate="yes" xml:space="preserve">
          <source>Subrange types</source>
          <target state="translated">子范围类型</target>
        </trans-unit>
        <trans-unit id="041d20cfb351df25518b1fc63a1180aa4794aa06" translate="yes" xml:space="preserve">
          <source>Subranges</source>
          <target state="translated">Subranges</target>
        </trans-unit>
        <trans-unit id="b5f3755a0b5ea501c2ceef9602ab2b833039d687" translate="yes" xml:space="preserve">
          <source>Substitution Expressions (subex)</source>
          <target state="translated">取代表达式(subex)</target>
        </trans-unit>
        <trans-unit id="10ae1fbab8828c5f045753afbdada38d4797d019" translate="yes" xml:space="preserve">
          <source>Substitution variables can also be words (that is &lt;code&gt;[A-Za-z_]+[A-Za-z0-9_]*&lt;/code&gt;) in which case the arguments in &lt;em&gt;a&lt;/em&gt; with even indices are keys and with odd indices are the corresponding values. An example:</source>
          <target state="translated">替代变量也可以是单词（即 &lt;code&gt;[A-Za-z_]+[A-Za-z0-9_]*&lt;/code&gt; ），在这种情况下，具有偶数索引的&lt;em&gt;a中&lt;/em&gt;的参数是键，而具有奇数索引的实参是相应的值。一个例子：</target>
        </trans-unit>
        <trans-unit id="834dbbb6edc63f93dd355df612f58e6f6c9305b3" translate="yes" xml:space="preserve">
          <source>Substrings are separated by a substring containing only &lt;em&gt;seps&lt;/em&gt;.</source>
          <target state="translated">子字符串由仅包含&lt;em&gt;seps&lt;/em&gt;的子字符串&lt;em&gt;分隔&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="6d2ec85e175386f10e5a8dc9ec3874b1df9dc2ae" translate="yes" xml:space="preserve">
          <source>Substrings are separated by a substring containing only &lt;em&gt;seps&lt;/em&gt;. Examples:</source>
          <target state="translated">子字符串由仅包含&lt;em&gt;seps&lt;/em&gt;的子字符串&lt;em&gt;分隔&lt;/em&gt;。例子：</target>
        </trans-unit>
        <trans-unit id="9b3a380e1c6cb3aaa0328c36e53f0fcd3dd31ec2" translate="yes" xml:space="preserve">
          <source>Substrings are separated by the PEG &lt;em&gt;sep&lt;/em&gt;. Examples:</source>
          <target state="translated">子串由PEG &lt;em&gt;sep&lt;/em&gt;分隔。例子：</target>
        </trans-unit>
        <trans-unit id="e91de9d53e26c3248ed96f64d99b705efaf9da39" translate="yes" xml:space="preserve">
          <source>Substrings are separated by the character &lt;em&gt;sep&lt;/em&gt;. The code:</source>
          <target state="translated">子字符串由字符&lt;em&gt;sep&lt;/em&gt;分隔。代码：</target>
        </trans-unit>
        <trans-unit id="5bff515ff93456666b03df7f012092cf65f567c4" translate="yes" xml:space="preserve">
          <source>Substrings are separated by the regular expression &lt;code&gt;sep&lt;/code&gt; (and the portion matched by &lt;code&gt;sep&lt;/code&gt; is not returned).</source>
          <target state="translated">子字符串由正则表达式 &lt;code&gt;sep&lt;/code&gt; 分隔（并且不返回由 &lt;code&gt;sep&lt;/code&gt; 匹配的部分）。</target>
        </trans-unit>
        <trans-unit id="e8588d2a952b8b1b868045a8e60e1b1612fbdf6e" translate="yes" xml:space="preserve">
          <source>Substrings are separated by the string &lt;em&gt;sep&lt;/em&gt;. The code:</source>
          <target state="translated">子字符串由字符串&lt;em&gt;sep&lt;/em&gt;分隔。代码：</target>
        </trans-unit>
        <trans-unit id="969d144035ae8c1097f28295048d2e10839468b5" translate="yes" xml:space="preserve">
          <source>Substrings are separated by the string &lt;em&gt;sep&lt;/em&gt;. This is a wrapper around the &lt;a href=&quot;#split.i,string,string,int&quot;&gt;split iterator&lt;/a&gt;.</source>
          <target state="translated">子字符串由字符串&lt;em&gt;sep&lt;/em&gt;分隔。这是&lt;a href=&quot;#split.i,string,string,int&quot;&gt;拆分迭代器&lt;/a&gt;的包装。</target>
        </trans-unit>
        <trans-unit id="518967ba497c08dc430a7afa2799aa4c61e41859" translate="yes" xml:space="preserve">
          <source>Substrings are separated from the right by the char &lt;em&gt;sep&lt;/em&gt;</source>
          <target state="translated">子字符串从右分隔字符char &lt;em&gt;sep&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2cd528c9f9109219b97fe511dbbed0b9acbd1118" translate="yes" xml:space="preserve">
          <source>Substrings are separated from the right by the set of chars &lt;em&gt;seps&lt;/em&gt;</source>
          <target state="translated">子字符串由字符&lt;em&gt;分隔符&lt;/em&gt;从右边&lt;em&gt;分隔&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5e2f8adf7c1cab6995d76bf2a7d0ca46134fd40b" translate="yes" xml:space="preserve">
          <source>Substrings are separated from the right by the string &lt;em&gt;sep&lt;/em&gt;</source>
          <target state="translated">子字符串由字符串&lt;em&gt;sep&lt;/em&gt;与右边分开&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f96fd7e06b2e3440bae01cbcfe7490ed94381668" translate="yes" xml:space="preserve">
          <source>Subtract &lt;code&gt;interval&lt;/code&gt; from &lt;code&gt;dt&lt;/code&gt;. Components from &lt;code&gt;interval&lt;/code&gt; are subtracted in the order of their size, i.e first the &lt;code&gt;years&lt;/code&gt; component, then the &lt;code&gt;months&lt;/code&gt; component and so on. The returned &lt;code&gt;DateTime&lt;/code&gt; will have the same timezone as the input.</source>
          <target state="translated">从 &lt;code&gt;dt&lt;/code&gt; 减去 &lt;code&gt;interval&lt;/code&gt; 。 &lt;code&gt;interval&lt;/code&gt; 中的成分按其大小顺序减去，即首先是 &lt;code&gt;years&lt;/code&gt; 成分，然后是 &lt;code&gt;months&lt;/code&gt; 成分，依此类推。返回的 &lt;code&gt;DateTime&lt;/code&gt; 将具有与输入相同的时区。</target>
        </trans-unit>
        <trans-unit id="76bc475fe96d51312be250027df1a17a17035b2c" translate="yes" xml:space="preserve">
          <source>Subtract &lt;em&gt;y&lt;/em&gt; from &lt;em&gt;x&lt;/em&gt;.</source>
          <target state="translated">从&lt;em&gt;x&lt;/em&gt;减去&lt;em&gt;y&lt;/em&gt;。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b1dcda865799d69866263f2964a5c388fd816f8c" translate="yes" xml:space="preserve">
          <source>Subtract &lt;em&gt;y&lt;/em&gt; from the complex number &lt;em&gt;x&lt;/em&gt;.</source>
          <target state="translated">从复数&lt;em&gt;x&lt;/em&gt;减去&lt;em&gt;y&lt;/em&gt;。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="7d4f3fc03c45197f8110a3f544c2fd44b496e0b4" translate="yes" xml:space="preserve">
          <source>Subtract a duration from another.</source>
          <target state="translated">从另一个期限中减去一个期限。</target>
        </trans-unit>
        <trans-unit id="0a0ad440585f43f54b766a259c1467e330bf63c8" translate="yes" xml:space="preserve">
          <source>Subtract int &lt;em&gt;y&lt;/em&gt; from rational &lt;em&gt;x&lt;/em&gt;.</source>
          <target state="translated">从有理数&lt;em&gt;x&lt;/em&gt;减去整数&lt;em&gt;y&lt;/em&gt;。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5428a30fe88840d786a7f61b7d233914d258e100" translate="yes" xml:space="preserve">
          <source>Subtract rational &lt;em&gt;y&lt;/em&gt; from int &lt;em&gt;x&lt;/em&gt;.</source>
          <target state="translated">从int &lt;em&gt;x&lt;/em&gt;减去有理&lt;em&gt;y&lt;/em&gt;。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="41acafc64eeedf3eca00c862873071d48f536cc2" translate="yes" xml:space="preserve">
          <source>Subtract rational &lt;em&gt;y&lt;/em&gt; from rational &lt;em&gt;x&lt;/em&gt;.</source>
          <target state="translated">从有理&lt;em&gt;x&lt;/em&gt;减去有理&lt;em&gt;y&lt;/em&gt;。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="7bef7ee0413bb39584843be44a786acae479c9b7" translate="yes" xml:space="preserve">
          <source>Subtract two complex numbers.</source>
          <target state="translated">减去两个复数。</target>
        </trans-unit>
        <trans-unit id="7189d91ec5033b9efd0a25062c31f9a16c88f644" translate="yes" xml:space="preserve">
          <source>Subtract two rational numbers.</source>
          <target state="translated">减去两个有理数。</target>
        </trans-unit>
        <trans-unit id="000947a7b3b6b45852df6f5a592408f7e55c3bb3" translate="yes" xml:space="preserve">
          <source>Subtracts &lt;em&gt;interval&lt;/em&gt; from Time &lt;em&gt;time&lt;/em&gt;. If &lt;em&gt;interval&lt;/em&gt; contains any years, months, weeks or days the operation is performed in the local timezone.</source>
          <target state="translated">从Time &lt;em&gt;时间&lt;/em&gt;减去&lt;em&gt;时间间隔&lt;/em&gt;。如果&lt;em&gt;间隔&lt;/em&gt;包含任何年，月，周或天，则在当地时区执行操作。&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="333dcd5ddf8f4d8066eab6ce4acb5ae7c09ae03c" translate="yes" xml:space="preserve">
          <source>Subtracts TimeInterval &lt;code&gt;ti1&lt;/code&gt; from &lt;code&gt;ti2&lt;/code&gt;.</source>
          <target state="translated">从 &lt;code&gt;ti2&lt;/code&gt; 中减去TimeInterval &lt;code&gt;ti1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f6179323b99f6b40288e7176393e0e598ec9f2ba" translate="yes" xml:space="preserve">
          <source>Subtracts a duration of time from a &lt;code&gt;Time&lt;/code&gt;.</source>
          <target state="translated">从 &lt;code&gt;Time&lt;/code&gt; 中减去持续时间。</target>
        </trans-unit>
        <trans-unit id="8dcbc2b9a13a2d866e0df3c601f071ff376561ec" translate="yes" xml:space="preserve">
          <source>Subtracts complex &lt;em&gt;y&lt;/em&gt; from float &lt;em&gt;x&lt;/em&gt;.</source>
          <target state="translated">从浮点数&lt;em&gt;x&lt;/em&gt;减去复数&lt;em&gt;y&lt;/em&gt;。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="4c88d3850624fa5509b42b7c6454e560083b18e5" translate="yes" xml:space="preserve">
          <source>Subtracts float &lt;em&gt;y&lt;/em&gt; from complex &lt;em&gt;x&lt;/em&gt;.</source>
          <target state="translated">从复数&lt;em&gt;x&lt;/em&gt;减去浮点&lt;em&gt;y&lt;/em&gt;。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f70590b4a99f5ea41cbbb277fc8ae20c97c2f508" translate="yes" xml:space="preserve">
          <source>Subtype relation</source>
          <target state="translated">子类型关系</target>
        </trans-unit>
        <trans-unit id="0dfbf551cd1febe9be3271e47b0ace6915b7e99f" translate="yes" xml:space="preserve">
          <source>Success, SuccessX</source>
          <target state="translated">成功,成功X</target>
        </trans-unit>
        <trans-unit id="d9aa2dd47e2183e4004b0890583ddab7b0dd3b84" translate="yes" xml:space="preserve">
          <source>Successful compilation of a library or a binary.</source>
          <target state="translated">成功编译一个库或二进制文件。</target>
        </trans-unit>
        <trans-unit id="885db975a310a3bb649f91e5771f94988987874d" translate="yes" xml:space="preserve">
          <source>Suffix</source>
          <target state="translated">Suffix</target>
        </trans-unit>
        <trans-unit id="8e3e076ed673ec7f1a40d1724dfcc98398c4fee1" translate="yes" xml:space="preserve">
          <source>Sugar for contains</source>
          <target state="translated">含糖量</target>
        </trans-unit>
        <trans-unit id="2b0f1741006e1749638aebbba0c62519275602e6" translate="yes" xml:space="preserve">
          <source>Sugar for not containing</source>
          <target state="translated">不含糖的糖</target>
        </trans-unit>
        <trans-unit id="861edba00547bc9ce7a08df78d4378766418179f" translate="yes" xml:space="preserve">
          <source>Suggestions</source>
          <target state="translated">Suggestions</target>
        </trans-unit>
        <trans-unit id="941d7d9ac0746aafb3a7018083b0465f921dce61" translate="yes" xml:space="preserve">
          <source>Supported OS primitives: &lt;code&gt;epoll&lt;/code&gt;, &lt;code&gt;kqueue&lt;/code&gt;, &lt;code&gt;poll&lt;/code&gt; and Windows &lt;code&gt;select&lt;/code&gt;.</source>
          <target state="translated">支持的操作系统原语： &lt;code&gt;epoll&lt;/code&gt; ， &lt;code&gt;kqueue&lt;/code&gt; ， &lt;code&gt;poll&lt;/code&gt; 和Windows &lt;code&gt;select&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a5f3ef8bd9a226a902e3da626f593d8f6bdd720e" translate="yes" xml:space="preserve">
          <source>Supported PEG grammar</source>
          <target state="translated">支持的PEG语法</target>
        </trans-unit>
        <trans-unit id="9d80112951ed980c75468e1be3b86df0f222e090" translate="yes" xml:space="preserve">
          <source>Supported features: files, sockets, pipes, timers, processes, signals and user events.</source>
          <target state="translated">支持的功能:文件、套接字、管道、定时器、进程、信号和用户事件。</target>
        </trans-unit>
        <trans-unit id="922e354db556982aaec9d3960cdeb221956777ff" translate="yes" xml:space="preserve">
          <source>Supported syntax with default empty &lt;code&gt;shortNoVal&lt;/code&gt;/&lt;code&gt;longNoVal&lt;/code&gt;:</source>
          <target state="translated">支持的语法，默认为空 &lt;code&gt;shortNoVal&lt;/code&gt; / &lt;code&gt;longNoVal&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="52fecfba1182fabfdebf61ef0bd285c76b11a6aa" translate="yes" xml:space="preserve">
          <source>Suspends the execution of the current async procedure for the next &lt;code&gt;ms&lt;/code&gt; milliseconds.</source>
          <target state="translated">在接下来的 &lt;code&gt;ms&lt;/code&gt; 毫秒内暂停当前​​异步过程的执行。</target>
        </trans-unit>
        <trans-unit id="d5c77fcc8428eb1c29fb0edea391c5fde177f006" translate="yes" xml:space="preserve">
          <source>Suspends the process &lt;em&gt;p&lt;/em&gt;.</source>
          <target state="translated">挂起进程&lt;em&gt;p&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="ff172170c09b0a3f643ea6f3860725b0e3adcde6" translate="yes" xml:space="preserve">
          <source>Swaps the case of unicode characters in &lt;em&gt;s&lt;/em&gt;</source>
          <target state="translated">交换&lt;em&gt;s&lt;/em&gt;中unicode字符的大小写&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="55b596882450b0f897f71f7b842053dfc1583f85" translate="yes" xml:space="preserve">
          <source>Swaps the positions of elements in a sequence randomly.</source>
          <target state="translated">随机交换序列中元素的位置。</target>
        </trans-unit>
        <trans-unit id="0ccabcb7feef7d8bfe041ead9426ae3125086c8c" translate="yes" xml:space="preserve">
          <source>Symbol binding in templates</source>
          <target state="translated">模板中的符号绑定</target>
        </trans-unit>
        <trans-unit id="e15d9719893fff31a651b51709f3f17053857c18" translate="yes" xml:space="preserve">
          <source>Symbol lookup in generics</source>
          <target state="translated">符号查询</target>
        </trans-unit>
        <trans-unit id="93722351d20a0af3b4b9e37b38817089ab39c090" translate="yes" xml:space="preserve">
          <source>Symbol lookup of the identifiers &lt;code&gt;items&lt;/code&gt;/&lt;code&gt;pairs&lt;/code&gt; is performed after the rewriting step, so that all overloads of &lt;code&gt;items&lt;/code&gt;/&lt;code&gt;pairs&lt;/code&gt; are taken into account.</source>
          <target state="translated">在重写步骤之后执行标识符 &lt;code&gt;items&lt;/code&gt; / &lt;code&gt;pairs&lt;/code&gt; 符号查找，以便考虑 &lt;code&gt;items&lt;/code&gt; / &lt;code&gt;pairs&lt;/code&gt; 所有重载。</target>
        </trans-unit>
        <trans-unit id="84e33e2c80c65f15d6048f2ca6f92d94cfd3e6de" translate="yes" xml:space="preserve">
          <source>Symbol usages</source>
          <target state="translated">符号用途</target>
        </trans-unit>
        <trans-unit id="15d2715339927ab1cacbd3a795da09326886df84" translate="yes" xml:space="preserve">
          <source>Symbolic link.</source>
          <target state="translated">符号链接。</target>
        </trans-unit>
        <trans-unit id="11ad0ab4dc32899beb01665dac0504b053480af8" translate="yes" xml:space="preserve">
          <source>Symbols declared in an &lt;em&gt;enter&lt;/em&gt; handler can be made visible in the corresponding &lt;em&gt;leave&lt;/em&gt; handler by annotating them with an &lt;em&gt;inject&lt;/em&gt; pragma.</source>
          <target state="translated">通过使用&lt;em&gt;注入&lt;/em&gt;注解对它们进行注释，可以使在&lt;em&gt;输入&lt;/em&gt;处理程序中声明的符号在相应的&lt;em&gt;离开&lt;/em&gt;处理程序中可见。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a4b7119bc873b1a47de2955098054673778589df" translate="yes" xml:space="preserve">
          <source>Synonym for existsDir</source>
          <target state="translated">existsDir的同义词</target>
        </trans-unit>
        <trans-unit id="ba60d4cc263ff180c27a4a09e6b636cd98ac4e3b" translate="yes" xml:space="preserve">
          <source>Synonym for existsFile</source>
          <target state="translated">existFile的同义词</target>
        </trans-unit>
        <trans-unit id="e8aa2bdcd24d6964731df6f38e8110132abbce66" translate="yes" xml:space="preserve">
          <source>Syntactically a &lt;em&gt;type conversion&lt;/em&gt; is like a procedure call, but a type name replaces the procedure name. A type conversion is always safe in the sense that a failure to convert a type to another results in an exception (if it cannot be determined statically).</source>
          <target state="translated">从句法上讲，&lt;em&gt;类型转换&lt;/em&gt;类似于过程调用，但是类型名称代替了过程名称。从无法将类型转换为另一个类型会导致异常（如果无法静态确定）的意义上说，类型转换始终是安全的。</target>
        </trans-unit>
        <trans-unit id="17c7ba7676ad1ad6dd1c4e6b997adcae910262c9" translate="yes" xml:space="preserve">
          <source>Syntax</source>
          <target state="translated">Syntax</target>
        </trans-unit>
        <trans-unit id="9c59412440fcb6dd3270f66f446a4acc85d89be4" translate="yes" xml:space="preserve">
          <source>Syntax sugar for anonymous procedures.</source>
          <target state="translated">匿名程序的语法糖。</target>
        </trans-unit>
        <trans-unit id="a492d9c66fdcf105c885da59425dccb0b62e918e" translate="yes" xml:space="preserve">
          <source>Syntax sugar for procedure types.</source>
          <target state="translated">过程类型的语法糖。</target>
        </trans-unit>
        <trans-unit id="2e2159d4e1bf250922bd0a832c5179a9837c51e5" translate="yes" xml:space="preserve">
          <source>T = enum</source>
          <target state="translated">T=enum</target>
        </trans-unit>
        <trans-unit id="4434fd593bde3375839bc932883b120b979c7044" translate="yes" xml:space="preserve">
          <source>THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</source>
          <target state="translated">本软件由版权拥有者和贡献者 &quot;按原样 &quot;提供,任何明示或默示的保证,包括但不限于默示的适销性和特定用途的适用性保证,均不予承认。在任何情况下,版权所有者或合作伙伴均不对任何直接、间接、偶然、特殊、例外或后果性损害(包括但不限于购买替代商品或服务;使用、数据或利润损失;或业务中断)承担责任,无论其原因如何,也无论其责任理论如何,无论是合同、严格责任还是侵权(包括过失或其他),即使已被告知此类损害的可能性。</target>
        </trans-unit>
        <trans-unit id="7cbcc89bc56ee06c7485bd88edf78b958d325e03" translate="yes" xml:space="preserve">
          <source>TODO: &lt;code&gt;/dev/poll&lt;/code&gt;, &lt;code&gt;event ports&lt;/code&gt; and filesystem events.</source>
          <target state="translated">TODO： &lt;code&gt;/dev/poll&lt;/code&gt; ， &lt;code&gt;event ports&lt;/code&gt; 和文件系统事件。</target>
        </trans-unit>
        <trans-unit id="cb0d62cece24d665ba7c89ca01c113d1046f4bc2" translate="yes" xml:space="preserve">
          <source>Table constructor</source>
          <target state="translated">表构造器</target>
        </trans-unit>
        <trans-unit id="d9afbd5c6dd4be0b038affd18116707f9d6423e7" translate="yes" xml:space="preserve">
          <source>Tag tracking</source>
          <target state="translated">标签跟踪</target>
        </trans-unit>
        <trans-unit id="88ab9771610a9a442e0329746e6647da7d9f316c" translate="yes" xml:space="preserve">
          <source>Taint mode</source>
          <target state="translated">污染模式</target>
        </trans-unit>
        <trans-unit id="dfaa7a1f02c7c5f9df730df7121afa459170ff28" translate="yes" xml:space="preserve">
          <source>Take special care when declaring types as &lt;code&gt;proc&lt;/code&gt;. The behavior is similar to &lt;code&gt;Procedure declaration&lt;/code&gt;, below, but does not treat &lt;code&gt;nnkGenericParams&lt;/code&gt;. Generic parameters are treated in the type, not the &lt;code&gt;proc&lt;/code&gt; itself.</source>
          <target state="translated">在将类型声明为 &lt;code&gt;proc&lt;/code&gt; 时要特别小心。该行为类似于下面的 &lt;code&gt;Procedure declaration&lt;/code&gt; ，但不处理 &lt;code&gt;nnkGenericParams&lt;/code&gt; 。泛型参数按类型而不是 &lt;code&gt;proc&lt;/code&gt; 本身处理。</target>
        </trans-unit>
        <trans-unit id="b25c3237baf7da022bd4ce5dd72ff7bbd7b4e0d2" translate="yes" xml:space="preserve">
          <source>Takes a &lt;code&gt;typedesc&lt;/code&gt; as its first argument, and a series of expressions of type &lt;code&gt;key: value&lt;/code&gt;, and returns a value of the specified type with each field &lt;code&gt;key&lt;/code&gt; set to &lt;code&gt;value&lt;/code&gt;, as specified in the arguments of &lt;code&gt;{}&lt;/code&gt;.</source>
          <target state="translated">以 &lt;code&gt;typedesc&lt;/code&gt; 作为其第一个参数，以及一系列类型为 &lt;code&gt;key: value&lt;/code&gt; 的表达式，并返回指定类型的值，其中每个字段 &lt;code&gt;key&lt;/code&gt; 设置为 &lt;code&gt;value&lt;/code&gt; ，如 &lt;code&gt;{}&lt;/code&gt; 的参数中所指定。</target>
        </trans-unit>
        <trans-unit id="5694602502f6f1e320a5499e60e3f6eb2a597ab1" translate="yes" xml:space="preserve">
          <source>Takes a float which contains the number of seconds since the unix epoch and returns a time object.</source>
          <target state="translated">取一个float,包含自unix epoch以来的秒数,并返回一个时间对象。</target>
        </trans-unit>
        <trans-unit id="aae55bc35eb360650aead66c4fe99a44fac76e39" translate="yes" xml:space="preserve">
          <source>Takes an int which contains the number of seconds since the unix epoch and returns a time object.</source>
          <target state="translated">取一个包含自unix纪元以来的秒数的int,并返回一个时间对象。</target>
        </trans-unit>
        <trans-unit id="4bad4e5a1f77a3fa2ad87fcd6030a2fbe78305df" translate="yes" xml:space="preserve">
          <source>Takes an integer and outputs as many &quot;hello world!&quot;s</source>
          <target state="translated">取一个整数并输出尽可能多的 &quot;hello world!&quot;。</target>
        </trans-unit>
        <trans-unit id="aca4638357a681dba4149f01bff4b890bc77cb16" translate="yes" xml:space="preserve">
          <source>Takes several sequences' items and returns them inside a new sequence.</source>
          <target state="translated">读取多个序列的项目,并将其返回到一个新的序列中。</target>
        </trans-unit>
        <trans-unit id="54bd658583d742b0230f0f3e91860906626fd48f" translate="yes" xml:space="preserve">
          <source>Takes the name of a procedure and wraps it into a lambda missing the first argument, which passes the JavaScript builtin &lt;code&gt;this&lt;/code&gt; as the first argument to the procedure. Returns the resulting lambda.</source>
          <target state="translated">获取过程的名称并将其包装到缺少第一个参数的lambda中，该参数将内置 &lt;code&gt;this&lt;/code&gt; 的JavaScript 作为该过程的第一个参数传递。返回结果lambda。</target>
        </trans-unit>
        <trans-unit id="7fbcef4f12fbf3e15c5cc83ae7b0ad02579d3228" translate="yes" xml:space="preserve">
          <source>Template declaration</source>
          <target state="translated">模板声明</target>
        </trans-unit>
        <trans-unit id="9d6df49bcce99024a2e48ebc7e962779552b3e40" translate="yes" xml:space="preserve">
          <source>Template to fold a sequence from left to right, returning the accumulation.</source>
          <target state="translated">模板从左到右折叠一个序列,返回积累。</target>
        </trans-unit>
        <trans-unit id="de22212f29283d60e7209a9a47f7c24e8243be55" translate="yes" xml:space="preserve">
          <source>Template to fold a sequence from right to left, returning the accumulation.</source>
          <target state="translated">模板从右到左折叠一个序列,返回积累。</target>
        </trans-unit>
        <trans-unit id="fbe50b6e0ad8f81f8d1ff40ace889c5bf58be0d6" translate="yes" xml:space="preserve">
          <source>Template which expands to either stdout or stderr depending on &lt;em&gt;useStdoutAsStdmsg&lt;/em&gt; compile-time switch.</source>
          <target state="translated">根据&lt;em&gt;useStdoutAsStdmsg&lt;/em&gt;编译时开关，扩展为stdout或stderr的模板。</target>
        </trans-unit>
        <trans-unit id="f25b700ed9f092123a43acb205a6869342cf9dd6" translate="yes" xml:space="preserve">
          <source>Templates</source>
          <target state="translated">Templates</target>
        </trans-unit>
        <trans-unit id="f24083e3c7410b73370a6d3df27c2a49cb0ea1cc" translate="yes" xml:space="preserve">
          <source>Templates (as well as macros, as we'll see) have a slightly expanded AST when compared to procs and iterators. The reason for this is [term-rewriting macros](&lt;a href=&quot;http://nim-lang.org/docs/manual.html#term-rewriting-macros)&quot;&gt;http://nim-lang.org/docs/manual.html#term-rewriting-macros)&lt;/a&gt;. Notice the &lt;code&gt;nnkEmpty()&lt;/code&gt; as the second argument to &lt;code&gt;nnkProcDef&lt;/code&gt; and &lt;code&gt;nnkIteratorDef&lt;/code&gt; above? That's where the term-rewriting macros go.</source>
          <target state="translated">与proc和迭代器相比，模板（以及宏，我们将看到）具有稍微扩展的AST。这样做的原因是[term-rewriting宏]（&lt;a href=&quot;http://nim-lang.org/docs/manual.html#term-rewriting-macros)&quot;&gt;http://nim-lang.org/docs/manual.html#term-rewriting-macros）&lt;/a&gt;。注意上面的 &lt;code&gt;nnkProcDef&lt;/code&gt; 和 &lt;code&gt;nnkIteratorDef&lt;/code&gt; 的第二个参数 &lt;code&gt;nnkEmpty()&lt;/code&gt; 吗？这就是术语重写宏的去向。</target>
        </trans-unit>
        <trans-unit id="dcfcea00b9c87e288d0369354ff63f75a960b95b" translate="yes" xml:space="preserve">
          <source>Templates are a simple substitution mechanism that operates on Nim's abstract syntax trees. Templates are processed in the semantic pass of the compiler. They integrate well with the rest of the language and share none of C's preprocessor macros flaws.</source>
          <target state="translated">模板是一种简单的替换机制,它在Nim的抽象语法树上运行。模板在编译器的语义通道中进行处理。它们与语言的其他部分很好地集成在一起,并且没有C语言的预处理器宏的缺陷。</target>
        </trans-unit>
        <trans-unit id="96f5a0e5d16500060d1f7d5115cee45e47157761" translate="yes" xml:space="preserve">
          <source>Templates are especially useful for lazy evaluation purposes. Consider a simple proc for logging:</source>
          <target state="translated">模板对于懒惰的评估目的特别有用。考虑一个简单的记录过程。</target>
        </trans-unit>
        <trans-unit id="a4ab366bab0be60e3998095c84a25a6598269dc1" translate="yes" xml:space="preserve">
          <source>Temporary storage for &lt;code&gt;readLine&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;readLine&lt;/code&gt; 的临时存储</target>
        </trans-unit>
        <trans-unit id="c8ead6a06ca5a06f3fd3f26aa97c8aa66bfd565e" translate="yes" xml:space="preserve">
          <source>Term rewriting macros</source>
          <target state="translated">术语改写宏</target>
        </trans-unit>
        <trans-unit id="a6680ab0f20ce389b5124d56dd72b741a29ed36a" translate="yes" xml:space="preserve">
          <source>Term rewriting macros are macros or templates that have not only a &lt;em&gt;name&lt;/em&gt; but also a &lt;em&gt;pattern&lt;/em&gt; that is searched for after the semantic checking phase of the compiler: This means they provide an easy way to enhance the compilation pipeline with user defined optimizations:</source>
          <target state="translated">术语重写宏是不仅具有&lt;em&gt;名称，&lt;/em&gt;而且具有在编译器的语义检查阶段之后搜索的&lt;em&gt;模式的&lt;/em&gt;宏或模板：这意味着它们提供了一种通过用户定义的优化来增强编译管道的简便方法：</target>
        </trans-unit>
        <trans-unit id="41291f4ae4297ee61df6a797422526ba9e83df38" translate="yes" xml:space="preserve">
          <source>Terminal symbol</source>
          <target state="translated">终端符号</target>
        </trans-unit>
        <trans-unit id="bef52f1c5083f29909e547fdf32cc8985b604537" translate="yes" xml:space="preserve">
          <source>Terminal symbol in the grammar: &lt;code&gt;RSTR_LIT&lt;/code&gt;.</source>
          <target state="translated">语法中的终端符号： &lt;code&gt;RSTR_LIT&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="09a8a9bac49fc0459e1510c675469f02c63be7ca" translate="yes" xml:space="preserve">
          <source>Terminal symbol in the grammar: &lt;code&gt;STR_LIT&lt;/code&gt;.</source>
          <target state="translated">语法中的终端符号： &lt;code&gt;STR_LIT&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1d576d491af5f274a42068737f7ccbdab6163370" translate="yes" xml:space="preserve">
          <source>Terminal symbol in the grammar: &lt;code&gt;TRIPLESTR_LIT&lt;/code&gt;.</source>
          <target state="translated">语法中的 &lt;code&gt;TRIPLESTR_LIT&lt;/code&gt; 符号：TRIPLESTR_LIT。</target>
        </trans-unit>
        <trans-unit id="e69f5068cdc01aad4375523276cb15e9d4ebbbc8" translate="yes" xml:space="preserve">
          <source>Terminal symbols in the grammar: &lt;code&gt;GENERALIZED_STR_LIT&lt;/code&gt;, &lt;code&gt;GENERALIZED_TRIPLESTR_LIT&lt;/code&gt;.</source>
          <target state="translated">语法中的 &lt;code&gt;GENERALIZED_STR_LIT&lt;/code&gt; 符号：GENERALIZED_STR_LIT， &lt;code&gt;GENERALIZED_TRIPLESTR_LIT&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="785f87cb41855c7bc99d2fd2726f808d1af1b5e6" translate="yes" xml:space="preserve">
          <source>Terminates the async http server instance.</source>
          <target state="translated">终止异步http服务器实例。</target>
        </trans-unit>
        <trans-unit id="751a90a6435d21431d11cc9e3b0833f5ca5eb590" translate="yes" xml:space="preserve">
          <source>Terminates the connection to the server.</source>
          <target state="translated">终止与服务器的连接。</target>
        </trans-unit>
        <trans-unit id="e3597aaf6cdfbeaf6431029759d5522ddcee7a42" translate="yes" xml:space="preserve">
          <source>Test case file format</source>
          <target state="translated">测试案例文件格式</target>
        </trans-unit>
        <trans-unit id="b33a4cfd962fe2b39c56b4ecde938402268b2e10" translate="yes" xml:space="preserve">
          <source>Test for a block special file.</source>
          <target state="translated">测试块特殊文件。</target>
        </trans-unit>
        <trans-unit id="a9f69337598e21f93cab2ebd657596ec3df3e129" translate="yes" xml:space="preserve">
          <source>Test for a character special file.</source>
          <target state="translated">测试字符特殊文件。</target>
        </trans-unit>
        <trans-unit id="952a8cbcb1fcde688a18a823ebbda401d701fbcd" translate="yes" xml:space="preserve">
          <source>Test for a directory.</source>
          <target state="translated">测试一个目录。</target>
        </trans-unit>
        <trans-unit id="1d54cb1533572699c4c3111108695b83f5f3b3b8" translate="yes" xml:space="preserve">
          <source>Test for a message queue.</source>
          <target state="translated">测试消息队列。</target>
        </trans-unit>
        <trans-unit id="f90ba2506c9fa49f566e376d10a4bb5d7ba584a7" translate="yes" xml:space="preserve">
          <source>Test for a pipe or FIFO special file.</source>
          <target state="translated">测试管道或FIFO特殊文件。</target>
        </trans-unit>
        <trans-unit id="f13d7458dcb8f1aa6f0b325ab968c053f51907a9" translate="yes" xml:space="preserve">
          <source>Test for a regular file.</source>
          <target state="translated">测试一个常规文件。</target>
        </trans-unit>
        <trans-unit id="2ac777a23cc611262a8452a43aeb1f412c46ac83" translate="yes" xml:space="preserve">
          <source>Test for a semaphore.</source>
          <target state="translated">测试信号灯。</target>
        </trans-unit>
        <trans-unit id="63a613e82f42e3dfcb1758affe0e08e5bab7c6eb" translate="yes" xml:space="preserve">
          <source>Test for a shared memory object.</source>
          <target state="translated">测试共享内存对象。</target>
        </trans-unit>
        <trans-unit id="c255ce2ca23650ca45172eee903a6b011becc55e" translate="yes" xml:space="preserve">
          <source>Test for a socket.</source>
          <target state="translated">测试一个插座。</target>
        </trans-unit>
        <trans-unit id="e7ff66eaf314a4eceeaf9ad8b6c2a819916574da" translate="yes" xml:space="preserve">
          <source>Test for a symbolic link.</source>
          <target state="translated">测试一个符号链接。</target>
        </trans-unit>
        <trans-unit id="765e5922fa70d1f573a8d979885d6d361bb38400" translate="yes" xml:space="preserve">
          <source>Test if &lt;em&gt;body&lt;/em&gt; raises an exception found in the passed &lt;em&gt;exceptions&lt;/em&gt;. The test passes if the raised exception is part of the acceptable exceptions. Otherwise, it fails. Example:</source>
          <target state="translated">测试&lt;em&gt;body是否&lt;/em&gt;引发在传递的异常中发现的&lt;em&gt;异常&lt;/em&gt;。如果引发的异常是可接受异常的一部分，则测试通过。否则，它将失败。例：</target>
        </trans-unit>
        <trans-unit id="adc4fd08a5eb9c1e704b8fb9dedc41a222765399" translate="yes" xml:space="preserve">
          <source>Test macro for a typed memory object.</source>
          <target state="translated">类型化内存对象的测试宏。</target>
        </trans-unit>
        <trans-unit id="5f967f7d2e1f440aeb4c91e854d76b62157077cf" translate="yes" xml:space="preserve">
          <source>Test suite</source>
          <target state="translated">测试套件</target>
        </trans-unit>
        <trans-unit id="450392a2e8adbf4bec17df3a66d6c7ef132d0fc1" translate="yes" xml:space="preserve">
          <source>Tested on these OSes: Linux, Windows, OSX</source>
          <target state="translated">在这些操作系统上测试。Linux,Windows,OSX</target>
        </trans-unit>
        <trans-unit id="dbb71175e7ed02ff6aee92d2ec95782f4f92c6f4" translate="yes" xml:space="preserve">
          <source>Tests can be nested, however failure of a nested test will not mark the parent test as failed. Setup and teardown are inherited. Setup can be overridden locally.</source>
          <target state="translated">测试可以被嵌套,但是嵌套测试的失败并不会将父测试标记为失败。设置和删除是继承的。设置可以在本地被覆盖。</target>
        </trans-unit>
        <trans-unit id="47e7d34d76d0c77b4690ea7930812dcf7ab8551a" translate="yes" xml:space="preserve">
          <source>Tests matching &lt;strong&gt;any&lt;/strong&gt; of the arguments are executed.</source>
          <target state="translated">执行与&lt;strong&gt;任何&lt;/strong&gt;参数匹配的测试。</target>
        </trans-unit>
        <trans-unit id="6aab81bfaf53615e8f766c7726f5ae51db83d879" translate="yes" xml:space="preserve">
          <source>Tests whether the DOM implementation implements a specific feature and that feature is supported by this node.</source>
          <target state="translated">测试DOM实现是否实现了特定的功能,以及该功能是否被该节点支持。</target>
        </trans-unit>
        <trans-unit id="613d55da24ea8bd5c97f0f07cd2c9af975d55abd" translate="yes" xml:space="preserve">
          <source>Tests with GCC on Amd64 showed that it's really beneficical if the 'environment' pointer is passed as the last argument, not as the first argument.</source>
          <target state="translated">在 Amd64 上使用 GCC 进行的测试表明,如果将 &quot;环境 &quot;指针作为最后一个参数,而不是第一个参数传递,那将是非常有益的。</target>
        </trans-unit>
        <trans-unit id="8fd9cd67f9ffbc2e8869c9ea4ebafbfe80184633" translate="yes" xml:space="preserve">
          <source>Thanks to its conditional construct &lt;code&gt;$[0|1|2|else]&lt;/code&gt; it supports &lt;span id=&quot;internationalization_1&quot;&gt;internationalization&lt;/span&gt; of format string literals quite well.</source>
          <target state="translated">由于其条件构造 &lt;code&gt;$[0|1|2|else]&lt;/code&gt; 它很好地支持格式字符串文字的&lt;span id=&quot;internationalization_1&quot;&gt;国际化&lt;/span&gt;。</target>
        </trans-unit>
        <trans-unit id="12b773bb24713516f53e274a95d42c996bab5cb9" translate="yes" xml:space="preserve">
          <source>That means only the first letters are compared in a case sensitive manner. Other letters are compared case insensitively within the ASCII range and underscores are ignored.</source>
          <target state="translated">这意味着只有第一个字母会以区分大小写的方式进行比较。其他字母在ASCII码范围内进行不区分大小写的比较,下划线被忽略。</target>
        </trans-unit>
        <trans-unit id="15669c375b35911d24b624c36d00f40792243390" translate="yes" xml:space="preserve">
          <source>That means to convert it to lower case and remove any '_'. This should NOT be used to normalize Nim identifier names.</source>
          <target state="translated">这意味着要将其转换为小写,并删除任何'_'。这不应该用来规范Nim标识符名称。</target>
        </trans-unit>
        <trans-unit id="2158ac17be0eaafff993defade193f729c2e722f" translate="yes" xml:space="preserve">
          <source>The &quot;``&quot; notation can also be used to call an operator just like any other procedure:</source>
          <target state="translated">&quot;``&quot;符号也可以像其他过程一样用来调用操作符。</target>
        </trans-unit>
        <trans-unit id="07ebfc1a638cb27eb2a7bdc1bbdba99b104e75e6" translate="yes" xml:space="preserve">
          <source>The &quot;hello world&quot; program contains several identifiers that are already known to the compiler: &lt;code&gt;echo&lt;/code&gt;, &lt;a href=&quot;system#readLine,File&quot;&gt;readLine&lt;/a&gt;, etc. These built-ins are declared in the &lt;a href=&quot;system&quot;&gt;system&lt;/a&gt; module which is implicitly imported by any other module.</source>
          <target state="translated">&amp;ldquo; hello world&amp;rdquo;程序包含几个编译器已知的标识符： &lt;code&gt;echo&lt;/code&gt; ，&lt;a href=&quot;system#readLine,File&quot;&gt;readLine&lt;/a&gt;等。这些内置函数在&lt;a href=&quot;system&quot;&gt;系统&lt;/a&gt;模块中声明，该模块由其他模块隐式导入。</target>
        </trans-unit>
        <trans-unit id="4660111e8f03f55e19e040ae55e537bca96088fa" translate="yes" xml:space="preserve">
          <source>The &quot;types&quot; of templates can be the symbols &lt;code&gt;untyped&lt;/code&gt;, &lt;code&gt;typed&lt;/code&gt; or &lt;code&gt;type&lt;/code&gt;. These are &quot;meta types&quot;, they can only be used in certain contexts. Regular types can be used too; this implies that &lt;code&gt;typed&lt;/code&gt; expressions are expected.</source>
          <target state="translated">该模板的&amp;ldquo;类型&amp;rdquo;可以是符号 &lt;code&gt;untyped&lt;/code&gt; ， &lt;code&gt;typed&lt;/code&gt; 或 &lt;code&gt;type&lt;/code&gt; 。这些是&amp;ldquo;元类型&amp;rdquo;，它们只能在某些情况下使用。也可以使用常规类型。这意味着应该使用 &lt;code&gt;typed&lt;/code&gt; 表达式。</target>
        </trans-unit>
        <trans-unit id="f29301d597d1872c3e865f162650568b25afe624" translate="yes" xml:space="preserve">
          <source>The 'precision' is a decimal number indicating how many digits should be displayed after the decimal point in a floating point conversion. For non-numeric types the field indicates the maximum field size - in other words, how many characters will be used from the field content. The precision is ignored for integer conversions.</source>
          <target state="translated">精度 &quot;是一个小数,表示在浮点转换中小数点后应该显示多少位。对于非数字类型,该字段表示最大字段大小--换句话说,字段内容将使用多少个字符。对于整数转换,精度被忽略。</target>
        </trans-unit>
        <trans-unit id="77bffde3bb99cdc6cc73c28c1d75251c36736508" translate="yes" xml:space="preserve">
          <source>The 'return' statement should ideally be used when its control-flow properties are required. Use a procedure's implicit 'result' variable whenever possible. This improves readability.</source>
          <target state="translated">'return'语句最好在需要其控制流属性的时候使用。尽可能地使用存储过程的隐式'结果'变量。这样可以提高可读性。</target>
        </trans-unit>
        <trans-unit id="2fffbfa23769923249ad2d3fd0e589b66b9c9408" translate="yes" xml:space="preserve">
          <source>The 'sign' option is only valid for numeric types, and can be one of the following:</source>
          <target state="translated">符号 &quot;选项只对数字类型有效,可以是以下之一。</target>
        </trans-unit>
        <trans-unit id="fa7a7006450028d34fa532dc709a868bd4924dee" translate="yes" xml:space="preserve">
          <source>The (integer) value of the radix used to represent any floating point type on the architecture used to build the program.</source>
          <target state="translated">在用于构建程序的架构上,用来表示任何浮点类型的(整数)值。</target>
        </trans-unit>
        <trans-unit id="3ab168c9fb07b629d33d94adcd06a5a7b86f04e3" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#nimble&quot;&gt;bottom&lt;/a&gt; of this page includes a list of 3rd party packages created by the Nim community. These packages are a useful addition to the modules in the standard library.</source>
          <target state="translated">该&lt;a href=&quot;#nimble&quot;&gt;底部&lt;/a&gt;本页包括由稔社区创建的第三方包的列表。这些软件包是对标准库中模块的有用补充。</target>
        </trans-unit>
        <trans-unit id="2a9b60df59f882b166b262beab63215a98833664" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;nimc&quot;&gt;Nim Compiler User Guide&lt;/a&gt; documents the typical compiler invocation, using the &lt;code&gt;compile&lt;/code&gt; or &lt;code&gt;c&lt;/code&gt; command to transform a &lt;code&gt;.nim&lt;/code&gt; file into one or more &lt;code&gt;.c&lt;/code&gt; files which are then compiled with the platform's C compiler into a static binary. However there are other commands to compile to C++, Objective-C or JavaScript. This document tries to concentrate in a single place all the backend and interfacing options.</source>
          <target state="translated">《&lt;a href=&quot;nimc&quot;&gt;Nim Compiler用户指南》&lt;/a&gt;记录了典型的编译器调用，使用 &lt;code&gt;compile&lt;/code&gt; 或 &lt;code&gt;c&lt;/code&gt; 命令将 &lt;code&gt;.nim&lt;/code&gt; 文件转换为一个或多个 &lt;code&gt;.c&lt;/code&gt; 文件，然后使用平台的C编译器将其编译为静态二进制文件。但是，还有其他命令可以编译为C ++，Objective-C或JavaScript。本文档尝试将所有后端和接口选项集中在一个地方。</target>
        </trans-unit>
        <trans-unit id="14d9a77578450b8a08312f7178544f27b410a5e1" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;nimc#dynliboverride&quot;&gt;dynlibOverride&lt;/a&gt; command line switch allows to avoid dynamic linking if you need to statically link something instead. Nim wrappers designed to statically link source files can use the &lt;a href=&quot;nimc#compile-pragma&quot;&gt;compile pragma&lt;/a&gt; if there are few sources or providing them along the Nim code is easier than using a system library. Libraries installed on the host system can be linked in with the &lt;a href=&quot;nimc#passl-pragma&quot;&gt;PassL pragma&lt;/a&gt;.</source>
          <target state="translated">该&lt;a href=&quot;nimc#dynliboverride&quot;&gt;dynlibOverride&lt;/a&gt;命令行开关允许避免动态，如果你需要静态链接的东西而不是链接。如果源很少，则设计为静态链接源文件的Nim包装器可以使用&lt;a href=&quot;nimc#compile-pragma&quot;&gt;编译&lt;/a&gt;实用程序，或者与使用系统库相比，沿着Nim代码提供它们很容易。主机系统上安装的库可以与&lt;a href=&quot;nimc#passl-pragma&quot;&gt;PassL编译指示&lt;/a&gt;链接。</target>
        </trans-unit>
        <trans-unit id="ee78ba5934ab094d006d5548d674ad0a80ec7579" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;system#inc&quot;&gt;inc&lt;/a&gt;, &lt;a href=&quot;system#dec&quot;&gt;dec&lt;/a&gt;, &lt;a href=&quot;system#succ&quot;&gt;succ&lt;/a&gt; and &lt;a href=&quot;system#pred&quot;&gt;pred&lt;/a&gt; operations can fail by raising an &lt;em&gt;EOutOfRange&lt;/em&gt; or &lt;em&gt;EOverflow&lt;/em&gt; exception. (If the code has been compiled with the proper runtime checks turned on.)</source>
          <target state="translated">该&lt;a href=&quot;system#inc&quot;&gt;INC&lt;/a&gt;，&lt;a href=&quot;system#dec&quot;&gt;十二月&lt;/a&gt;，&lt;a href=&quot;system#succ&quot;&gt;SUCC&lt;/a&gt;和&lt;a href=&quot;system#pred&quot;&gt;预解码&lt;/a&gt;操作可以通过提高一个失败&lt;em&gt;EOutOfRange&lt;/em&gt;或&lt;em&gt;EOVERFLOW&lt;/em&gt;例外。（如果在正确的运行时检查已打开的情况下编译了代码。）</target>
        </trans-unit>
        <trans-unit id="15e6a3a29797da15852fead9e28ee2b0370e150e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;!=&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;gt;=&lt;/code&gt;, &lt;code&gt;in&lt;/code&gt;, &lt;code&gt;notin&lt;/code&gt;, &lt;code&gt;isnot&lt;/code&gt; operators are in fact templates:</source>
          <target state="translated">该 &lt;code&gt;!=&lt;/code&gt; ， &lt;code&gt;&amp;gt;&lt;/code&gt; ， &lt;code&gt;&amp;gt;=&lt;/code&gt; ， &lt;code&gt;in&lt;/code&gt; ， &lt;code&gt;notin&lt;/code&gt; ， &lt;code&gt;isnot&lt;/code&gt; 运营商其实都是模板：</target>
        </trans-unit>
        <trans-unit id="2199e698bdfaf3681a19531d523f1d0976b1bdfd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;!=&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;gt;=&lt;/code&gt;, &lt;code&gt;in&lt;/code&gt;, &lt;code&gt;notin&lt;/code&gt;, &lt;code&gt;isnot&lt;/code&gt; operators are in fact templates: this has the benefit that if you overload the &lt;code&gt;==&lt;/code&gt; operator, the &lt;code&gt;!=&lt;/code&gt; operator is available automatically and does the right thing. (Except for IEEE floating point numbers - NaN breaks basic boolean logic.)</source>
          <target state="translated">该 &lt;code&gt;!=&lt;/code&gt; ， &lt;code&gt;&amp;gt;&lt;/code&gt; ， &lt;code&gt;&amp;gt;=&lt;/code&gt; ， &lt;code&gt;in&lt;/code&gt; ， &lt;code&gt;notin&lt;/code&gt; ， &lt;code&gt;isnot&lt;/code&gt; 运营商实际上都是模板：这一个好处，如果你重载 &lt;code&gt;==&lt;/code&gt; 操作符， &lt;code&gt;!=&lt;/code&gt; 运算符是自动提供并做正确的事。（除了IEEE浮点数-NaN破坏了基本的布尔逻辑。）</target>
        </trans-unit>
        <trans-unit id="094e0d63fcca9df22fc0f3fbd6b2b575dd7da3f8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;#header&lt;/code&gt; and the &lt;code&gt;#dynlib&lt;/code&gt; directives are mutually exclusive. A binding that uses &lt;code&gt;dynlib&lt;/code&gt; is much more preferable over one that uses &lt;code&gt;header&lt;/code&gt;! The Nim compiler might drop support for the &lt;code&gt;header&lt;/code&gt; pragma in the future as it cannot work for backends that do not generate C code.</source>
          <target state="translated">该 &lt;code&gt;#header&lt;/code&gt; 和 &lt;code&gt;#dynlib&lt;/code&gt; 指令是互斥的。绑定使用 &lt;code&gt;dynlib&lt;/code&gt; 超过一个使用更加优选的 &lt;code&gt;header&lt;/code&gt; ！Nim编译器将来可能会放弃对 &lt;code&gt;header&lt;/code&gt; 编译指示的支持，因为它不适用于不生成C代码的后端。</target>
        </trans-unit>
        <trans-unit id="f43b7889013c5efda25d7e2a5951e7e48009b60a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;#header&lt;/code&gt; directive tells c2nim that it should annotate every proc that resulted from a C function prototype and every exported variable and type with the &lt;code&gt;header&lt;/code&gt; pragma:</source>
          <target state="translated">该 &lt;code&gt;#header&lt;/code&gt; 指令告诉c2nim，它应该标注每一个进程内起因于C函数原型和每个导出的变量和类型与 &lt;code&gt;header&lt;/code&gt; 编译：</target>
        </trans-unit>
        <trans-unit id="8d682f6cc241d8bb6822410eaa23e70f79490caf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;#skipcomments&lt;/code&gt; directive can be put into the C code to make c2nim ignore comments and not copy them into the generated Nim file.</source>
          <target state="translated">该 &lt;code&gt;#skipcomments&lt;/code&gt; 指令可以被放入C代码，使c2nim忽略注释，而不是将它们复制到生成的文件稔。</target>
        </trans-unit>
        <trans-unit id="c45bd804ab79049b4d0886ddf5d109c11eb57c06" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;#typeprefixes&lt;/code&gt; directive can be put into the C code to make c2nim generate the &lt;code&gt;T&lt;/code&gt; or &lt;code&gt;P&lt;/code&gt; prefix for every defined type.</source>
          <target state="translated">所述 &lt;code&gt;#typeprefixes&lt;/code&gt; 指令可以被放入C代码，以使c2nim生成 &lt;code&gt;T&lt;/code&gt; 或 &lt;code&gt;P&lt;/code&gt; 为每个定义的类型的前缀。</target>
        </trans-unit>
        <trans-unit id="6ba0d1128c367616c99c9dc0a68b1f43d686832f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$&lt;/code&gt; operator can convert any enumeration value to its name, and the &lt;code&gt;ord&lt;/code&gt; proc can convert it to its underlying integer value.</source>
          <target state="translated">在 &lt;code&gt;$&lt;/code&gt; 操作者可以在任何枚举值转换为它的名称和 &lt;code&gt;ord&lt;/code&gt; PROC可以将其转换到其基础整数值。</target>
        </trans-unit>
        <trans-unit id="aae68c571abf2694e7a2359e8dbac146d141b789" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;**&lt;/code&gt; is much like the &lt;code&gt;*&lt;/code&gt; operator, except that it gathers not only all the arguments, but also the matched operators in reverse polish notation:</source>
          <target state="translated">该 &lt;code&gt;**&lt;/code&gt; 很像 &lt;code&gt;*&lt;/code&gt; 运营商，但它收集不仅所有的参数，而且在逆波兰式匹配的运营商：</target>
        </trans-unit>
        <trans-unit id="8023e9669b603ea0fcacf9f6cda5d9d92f066b57" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;**&lt;/code&gt; operator</source>
          <target state="translated">在 &lt;code&gt;**&lt;/code&gt; 运营商</target>
        </trans-unit>
        <trans-unit id="d5b2439f0e50417f5d7601f9c27477b456c09ecb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;*&lt;/code&gt; operator</source>
          <target state="translated">在 &lt;code&gt;*&lt;/code&gt; 运营商</target>
        </trans-unit>
        <trans-unit id="aef4abe76e6ffc1cb6cb1bd388d212ec07b74cd3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;*&lt;/code&gt; operator can &lt;em&gt;flatten&lt;/em&gt; a nested binary expression like &lt;code&gt;a &amp;amp; b &amp;amp; c&lt;/code&gt; to &lt;code&gt;&amp;amp;(a, b, c)&lt;/code&gt;:</source>
          <target state="translated">的 &lt;code&gt;*&lt;/code&gt; 操作者可以&lt;em&gt;弄平&lt;/em&gt;嵌套二进制表达式像 &lt;code&gt;a &amp;amp; b &amp;amp; c&lt;/code&gt; 到 &lt;code&gt;&amp;amp;(a, b, c)&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="7c6b5c181de77c676c99c40b4e5b0d932bb8b8f8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--context&lt;/code&gt; idetools switch is very similar to the suggestions switch, but instead of being used after the user has typed a dot character, this one is meant to be used after the user has typed an opening brace to start typing parameters.</source>
          <target state="translated">该 &lt;code&gt;--context&lt;/code&gt; idetools开关是非常相似的建议切换，但不是用户键入点字符之后仍然被使用，这一项是指用户键入开括号开始输入参数后使用。</target>
        </trans-unit>
        <trans-unit id="c4b4b572ba4241498b55d821bb912dd3ce8ce04c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--def&lt;/code&gt; idetools switch performs a query about the definition of a specific symbol. If available, idetools will answer with the type, source file, line/column information and other accessory data if available like a docstring. With this information an IDE can provide the typical &lt;em&gt;Jump to definition&lt;/em&gt; where a user puts the cursor on a symbol or uses the mouse to select it and is redirected to the place where the symbol is located.</source>
          <target state="translated">所述 &lt;code&gt;--def&lt;/code&gt; idetools开关执行查询关于特定符号的定义。如果可用，idetools将回答类型，源文件，行/列信息以及其他附件数据（如docstring）。通过此信息，IDE可以提供典型的&lt;em&gt;跳转到定义&lt;/em&gt;，用户将光标放在符号上或使用鼠标将其选中，然后将其重定向到该符号所在的位置。</target>
        </trans-unit>
        <trans-unit id="dd3e3ce57e9aecee15d1c10869647548dba0871c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--nimcache&lt;/code&gt;&lt;a href=&quot;nimc#command-line-switches&quot;&gt;compiler switch&lt;/a&gt; can be used to to change the &lt;code&gt;nimcache&lt;/code&gt; directory.</source>
          <target state="translated">所述 &lt;code&gt;--nimcache&lt;/code&gt; &lt;a href=&quot;nimc#command-line-switches&quot;&gt;编译器开关&lt;/a&gt;可被用于改变 &lt;code&gt;nimcache&lt;/code&gt; 目录。</target>
        </trans-unit>
        <trans-unit id="788b5d4a8f1368ab06e596c6b7b65932cae8614e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--suggest&lt;/code&gt; idetools switch performs a query about possible completion symbols at some point in the file. IDEs can easily provide an autocompletion feature where the IDE scans the current file (and related ones, if it knows about the language being edited and follows includes/imports) and when the user starts typing something a completion box with different options appears.</source>
          <target state="translated">所述 &lt;code&gt;--suggest&lt;/code&gt; idetools开关执行关于可能完成符号查询在文件中的某些点。IDE可以轻松提供自动完成功能，其中IDE扫描当前文件（以及相关文件，如果它知道所编辑的语言并遵循包含/导入），并且当用户开始输入内容时，会出现带有不同选项的完成框。</target>
        </trans-unit>
        <trans-unit id="984ae4024ec2641122166acc2ed459d4784e8ac8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--usages&lt;/code&gt; idetools switch lists all usages of the symbol at a position. IDEs can use this to find all the places in the file where the symbol is used and offer the user to rename it in all places at the same time. Again, a pure string based search and replace may catch symbols out of the scope of a function/loop.</source>
          <target state="translated">该 &lt;code&gt;--usages&lt;/code&gt; idetools切换列表符号的所有使用的位置。IDE可以使用它查找文件中使用符号的所有位置，并向用户提供同时在所有位置对其进行重命名的功能。同样，基于纯字符串的搜索和替换可能会捕获符号超出功能/循环的范围。</target>
        </trans-unit>
        <trans-unit id="45fbc61391e1a4b2d9263d29ca29efb51c1bb5ef" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.&lt;/code&gt; (access a tuple/object field operator) and &lt;code&gt;[]&lt;/code&gt; (array/string/sequence index operator) operators perform implicit dereferencing operations for reference types:</source>
          <target state="translated">的 &lt;code&gt;.&lt;/code&gt; （访问元组/对象字段运算符）和 &lt;code&gt;[]&lt;/code&gt; （数组/字符串/序列索引运算符）运算符对引用类型执行隐式解引用操作：</target>
        </trans-unit>
        <trans-unit id="78cd0d64a2665d2e29cb96ea56b4b61eaca69557" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;C2NIM&lt;/code&gt; symbol is only recognized in &lt;code&gt;#ifdef&lt;/code&gt; and &lt;code&gt;#ifndef&lt;/code&gt; constructs! &lt;code&gt;#if defined(C2NIM)&lt;/code&gt; does &lt;strong&gt;not&lt;/strong&gt; work.</source>
          <target state="translated">该 &lt;code&gt;C2NIM&lt;/code&gt; 符号只承认在 &lt;code&gt;#ifdef&lt;/code&gt; 和 &lt;code&gt;#ifndef&lt;/code&gt; 构造！ &lt;code&gt;#if defined(C2NIM)&lt;/code&gt; 确实&lt;strong&gt;没有&lt;/strong&gt;工作。</target>
        </trans-unit>
        <trans-unit id="a092497804c363adf0a9b85877d3ac5364f557a9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;DateTime&lt;/code&gt; type can be parsed and formatted using the different &lt;code&gt;parse&lt;/code&gt; and &lt;code&gt;format&lt;/code&gt; procedures.</source>
          <target state="translated">的 &lt;code&gt;DateTime&lt;/code&gt; 类型可被解析，并使用不同的格式的 &lt;code&gt;parse&lt;/code&gt; 和 &lt;code&gt;format&lt;/code&gt; 的程序。</target>
        </trans-unit>
        <trans-unit id="b02713e2a0c1ca4eb80a37fb1dc1324674096936" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;InvalidObjectConversionError&lt;/code&gt; exception is raised if &lt;code&gt;x&lt;/code&gt; is not a &lt;code&gt;Student&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;InvalidObjectConversionError&lt;/code&gt; 如果引发异常 &lt;code&gt;x&lt;/code&gt; 是不是 &lt;code&gt;Student&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="400dc7a3bd3178893b14b3f966ead94a0da3a473" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;RstParseOptions&lt;/code&gt;, &lt;code&gt;FindFileHandler&lt;/code&gt; and &lt;code&gt;MsgHandler&lt;/code&gt; types are defined in the the &lt;a href=&quot;rst&quot;&gt;packages/docutils/rst module&lt;/a&gt;. &lt;code&gt;options&lt;/code&gt; selects the behaviour of the rst parser.</source>
          <target state="translated">的 &lt;code&gt;RstParseOptions&lt;/code&gt; ， &lt;code&gt;FindFileHandler&lt;/code&gt; 和 &lt;code&gt;MsgHandler&lt;/code&gt; 类型的中定义的&lt;a href=&quot;rst&quot;&gt;包/ docutils的/ RST模块&lt;/a&gt;。 &lt;code&gt;options&lt;/code&gt; 选择第一个解析器的行为。</target>
        </trans-unit>
        <trans-unit id="00aa0e83fb2fddd7efccd136ea820b487d913775" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;T&lt;/code&gt; is called a &lt;span id=&quot;generic-type-parameter_1&quot;&gt;generic type parameter&lt;/span&gt; or a &lt;span id=&quot;type-variable_1&quot;&gt;type variable&lt;/span&gt;.</source>
          <target state="translated">该 &lt;code&gt;T&lt;/code&gt; 被称为&lt;span id=&quot;generic-type-parameter_1&quot;&gt;通用型参数&lt;/span&gt;或&lt;span id=&quot;type-variable_1&quot;&gt;类型的变量&lt;/span&gt;。</target>
        </trans-unit>
        <trans-unit id="ab738a00bda430d5fb380595920132610b0ad705" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;[: ]&lt;/code&gt; notation has been designed to mitigate this issue: &lt;code&gt;x.p[:T]&lt;/code&gt; is rewritten by the parser to &lt;code&gt;p[T](x)&lt;/code&gt;, &lt;code&gt;x.p[:T](y)&lt;/code&gt; is rewritten to &lt;code&gt;p[T](x, y)&lt;/code&gt;. Note that &lt;code&gt;[: ]&lt;/code&gt; has no AST representation, the rewrite is performed directly in the parsing step.</source>
          <target state="translated">的 &lt;code&gt;[: ]&lt;/code&gt; 符号已被设计为减轻此问题的方法： &lt;code&gt;x.p[:T]&lt;/code&gt; 被分析器改写为 &lt;code&gt;p[T](x)&lt;/code&gt; ， &lt;code&gt;x.p[:T](y)&lt;/code&gt; 被改写为 &lt;code&gt;p[T](x, y)&lt;/code&gt; 。注意 &lt;code&gt;[: ]&lt;/code&gt; 没有AST表示，重写直接在分析步骤中执行。</target>
        </trans-unit>
        <trans-unit id="2a7a43acb1307f045b6107d24a38c825385ea414" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;[]&lt;/code&gt; array access operator can be overloaded to provide &lt;span id=&quot;array-properties_1&quot;&gt;array properties&lt;/span&gt;:</source>
          <target state="translated">在 &lt;code&gt;[]&lt;/code&gt; 数组访问运算符可以被重载以提供&lt;span id=&quot;array-properties_1&quot;&gt;阵列属性&lt;/span&gt;：</target>
        </trans-unit>
        <trans-unit id="914a69574ba02242343d8c757f3b0950ffcaeca8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;[]&lt;/code&gt; operator will raise an exception when the specified field does not exist. If you wish to avoid this behaviour you can use the &lt;code&gt;{}&lt;/code&gt; operator instead, it will simply return &lt;code&gt;nil&lt;/code&gt; when the field is not found. The &lt;code&gt;get&lt;/code&gt;-family of procedures will return a default value when called on &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">如果指定的字段不存在，则 &lt;code&gt;[]&lt;/code&gt; 运算符将引发异常。如果希望避免这种行为，可以改用 &lt;code&gt;{}&lt;/code&gt; 运算符，当找不到该字段时，它将仅返回 &lt;code&gt;nil&lt;/code&gt; 。过程的 &lt;code&gt;get&lt;/code&gt; - family在 &lt;code&gt;nil&lt;/code&gt; 上调用时将返回默认值。</target>
        </trans-unit>
        <trans-unit id="d733185fdec6756a23f89ac0039a4d5fad38bdbf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;[]&lt;/code&gt; subscript operator for arrays/openarrays/sequences can be overloaded.</source>
          <target state="translated">数组/ openarrays / sequence 的 &lt;code&gt;[]&lt;/code&gt; 下标运算符可以重载。</target>
        </trans-unit>
        <trans-unit id="208edec1bf02d3f5453b13c50f0afe4bdd7b43ac" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;\A&lt;/code&gt;, &lt;code&gt;\Z&lt;/code&gt;, and &lt;code&gt;\z&lt;/code&gt; assertions differ from the traditional circumflex and dollar in that they only ever match at the very start and end of the subject string, whatever options are set. The difference between &lt;code&gt;\Z&lt;/code&gt; and &lt;code&gt;\z&lt;/code&gt; is that &lt;code&gt;\Z&lt;/code&gt; matches before a newline that is the last character of the string as well as at the end of the string, whereas &lt;code&gt;\z&lt;/code&gt; matches only at the end.</source>
          <target state="translated">该 &lt;code&gt;\A&lt;/code&gt; ， &lt;code&gt;\Z&lt;/code&gt; 和 &lt;code&gt;\z&lt;/code&gt; 断言之处在于它们仅匹配在起步和目标字符串，任何选项都设置结束了传统的音调符和美元。之间的差 &lt;code&gt;\Z&lt;/code&gt; 和 &lt;code&gt;\z&lt;/code&gt; 是 &lt;code&gt;\Z&lt;/code&gt; 换行符，其在所述串的结束字符串的以及最后一个字符，而在此之前的比赛 &lt;code&gt;\z&lt;/code&gt; 仅在端部相匹配。</target>
        </trans-unit>
        <trans-unit id="7e817ef93305a23fbf7c9a80e38b0806e7482064" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;_r&lt;/code&gt; suffix is used for release builds, &lt;code&gt;_d&lt;/code&gt; is for debug builds.</source>
          <target state="translated">该 &lt;code&gt;_r&lt;/code&gt; 后缀用于发布版本， &lt;code&gt;_d&lt;/code&gt; 是建立调试。</target>
        </trans-unit>
        <trans-unit id="07747905d782c21340b66ec287991fea62bc1650" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;accept&lt;/code&gt; call may result in an error if the connecting socket disconnects during the duration of the &lt;code&gt;accept&lt;/code&gt;. If the &lt;code&gt;SafeDisconn&lt;/code&gt; flag is specified then this error will not be raised and instead accept will be called again.</source>
          <target state="translated">如果在 &lt;code&gt;accept&lt;/code&gt; 期间连接套接字断开连接， &lt;code&gt;accept&lt;/code&gt; 调用可能会导致错误。如果指定了 &lt;code&gt;SafeDisconn&lt;/code&gt; 标志，则不会引发此错误，而是将再次调用accept。</target>
        </trans-unit>
        <trans-unit id="94b1ebe9dc31ad8dd9efa346619cf83e23a375a0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;acyclic&lt;/code&gt; pragma can be used for object types to mark them as acyclic even though they seem to be cyclic. This is an &lt;strong&gt;optimization&lt;/strong&gt; for the garbage collector to not consider objects of this type as part of a cycle:</source>
          <target state="translated">该 &lt;code&gt;acyclic&lt;/code&gt; 编译可用于对象类型将它们标记为非周期性尽管他们似乎是循环的。这是垃圾收集器的一种&lt;strong&gt;优化&lt;/strong&gt;，它不将这种类型的对象视为周期的一部分：</target>
        </trans-unit>
        <trans-unit id="613f12943604467ec30c9f5050f1fcb757eb0680" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;addr&lt;/code&gt; operator returns the address of an l-value. If the type of the location is &lt;code&gt;T&lt;/code&gt;, the &lt;em&gt;addr&lt;/em&gt; operator result is of the type &lt;code&gt;ptr T&lt;/code&gt;. An address is always an untraced reference. Taking the address of an object that resides on the stack is &lt;strong&gt;unsafe&lt;/strong&gt;, as the pointer may live longer than the object on the stack and can thus reference a non-existing object. One can get the address of variables, but one can't use it on variables declared through &lt;code&gt;let&lt;/code&gt; statements:</source>
          <target state="translated">该 &lt;code&gt;addr&lt;/code&gt; 运算符返回的左值的地址。如果位置的类型为 &lt;code&gt;T&lt;/code&gt; ，则&lt;em&gt;addr&lt;/em&gt;运算符的结果为 &lt;code&gt;ptr T&lt;/code&gt; 类型。地址始终是未跟踪的引用。获取驻留在堆栈上的对象的地址是&lt;strong&gt;不安全的&lt;/strong&gt;，因为指针的寿命可能比堆栈上的对象的寿命长，因此可以引用不存在的对象。一个可以获取变量的地址，但不能在通过 &lt;code&gt;let&lt;/code&gt; 语句声明的变量上使用它：</target>
        </trans-unit>
        <trans-unit id="bae94e7bbf49797d2a7e82b8a0df92aa58eba2b8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;async&lt;/code&gt; procedures also offer limited support for the try statement.</source>
          <target state="translated">在 &lt;code&gt;async&lt;/code&gt; 程序还提供了try语句的支持有限。</target>
        </trans-unit>
        <trans-unit id="50db6910ce0829d49cf640239e7c5e2012608b2e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;auto&lt;/code&gt; type can only be used for return types and parameters. For return types it causes the compiler to infer the type from the routine body:</source>
          <target state="translated">该 &lt;code&gt;auto&lt;/code&gt; 类型只能用于返回类型和参数。对于返回类型，它将导致编译器从例程主体中推断类型：</target>
        </trans-unit>
        <trans-unit id="c935fb430329bfdcd15706ca3da9cc7d25a5deb7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;await&lt;/code&gt; call may be used in many contexts. It can be used on the right hand side of a variable declaration: &lt;code&gt;var data = await socket.recv(100)&lt;/code&gt;, in which case the variable will be set to the value of the future automatically. It can be used to await a &lt;code&gt;Future&lt;/code&gt; object, and it can be used to await a procedure returning a &lt;code&gt;Future[void]&lt;/code&gt;: &lt;code&gt;await socket.send(&quot;foobar&quot;)&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;await&lt;/code&gt; 呼叫可以在许多环境中使用。它可以在变量声明的右侧使用： &lt;code&gt;var data = await socket.recv(100)&lt;/code&gt; ，在这种情况下，变量将自动设置为future的值。它可以用来等待 &lt;code&gt;Future&lt;/code&gt; 对象，也可以用来等待返回 &lt;code&gt;Future[void]&lt;/code&gt; ： &lt;code&gt;await socket.send(&quot;foobar&quot;)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3034958596b82fd279a106ed77e05a13c012c241" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;bind&lt;/code&gt; statement is the counterpart to the &lt;code&gt;mixin&lt;/code&gt; statement. It can be used to explicitly declare identifiers that should be bound early (i.e. the identifiers should be looked up in the scope of the template/generic definition):</source>
          <target state="translated">该 &lt;code&gt;bind&lt;/code&gt; 语句是对应于 &lt;code&gt;mixin&lt;/code&gt; 声明。它可用于显式声明应尽早绑定的标识符（即，应在模板/通用定义的范围内查找标识符）：</target>
        </trans-unit>
        <trans-unit id="2689f22307a3f463f4d508ab1aa3def314234321" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;bitsize&lt;/code&gt; pragma is for object field members. It declares the field as a bitfield in C/C++.</source>
          <target state="translated">位 &lt;code&gt;bitsize&lt;/code&gt; 编译指示适用于对象字段成员。它在C / C ++中将字段声明为位字段。</target>
        </trans-unit>
        <trans-unit id="3194ada345dceb4b88200e579d663c2676d8313e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;borrow&lt;/code&gt; pragma makes the compiler use the same implementation as the proc that deals with the distinct type's base type, so no code is generated.</source>
          <target state="translated">的 &lt;code&gt;borrow&lt;/code&gt; 编译使得编译器使用相同的实现作为处理的是不同类型的基本类型，所以不生成代码的PROC。</target>
        </trans-unit>
        <trans-unit id="ecd73ebdde8c6264e667c9b2e15208469fb20c86" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;break&lt;/code&gt; statement is used to leave a block immediately. If &lt;code&gt;symbol&lt;/code&gt; is given, it is the name of the enclosing block that is to leave. If it is absent, the innermost block is left.</source>
          <target state="translated">该 &lt;code&gt;break&lt;/code&gt; 语句用来立即离开块。如果给出 &lt;code&gt;symbol&lt;/code&gt; ，则是要离开的封闭块的名称。如果不存在，则保留最里面的块。</target>
        </trans-unit>
        <trans-unit id="3b17893941a66444039629e3f18a21d2a35573b2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;bycopy&lt;/code&gt; pragma can be applied to an object or tuple type and instructs the compiler to pass the type by value to procs:</source>
          <target state="translated">所述 &lt;code&gt;bycopy&lt;/code&gt; 编译可应用于对象或元组类型和指示编译器通过值传递类型的特效：</target>
        </trans-unit>
        <trans-unit id="2cbef8ce9bc4f27aa65fea1e9689cc4a8226d95b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;byref&lt;/code&gt; pragma can be applied to an object or tuple type and instructs the compiler to pass the type by reference (hidden pointer) to procs.</source>
          <target state="translated">在 &lt;code&gt;byref&lt;/code&gt; 编译可应用于对象或元组类型，并指示编译器通过参考（隐藏指针）特效传递的类型。</target>
        </trans-unit>
        <trans-unit id="77887b44cd49a95c9b69ac0376b1caf0f2b195c1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;call&lt;/code&gt; constraint is particularly useful to implement a move optimization for types that have copying semantics:</source>
          <target state="translated">该 &lt;code&gt;call&lt;/code&gt; 限制是特别有用的实施举措优化具有复制语义类型：</target>
        </trans-unit>
        <trans-unit id="33fe5bba83ee973b32a89460ea4507bb32681a04" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;case&lt;/code&gt; statement is similar to the if statement, but it represents a multi-branch selection. The expression after the keyword &lt;code&gt;case&lt;/code&gt; is evaluated and if its value is in a &lt;em&gt;slicelist&lt;/em&gt; the corresponding statements (after the &lt;code&gt;of&lt;/code&gt; keyword) are executed. If the value is not in any given &lt;em&gt;slicelist&lt;/em&gt; the &lt;code&gt;else&lt;/code&gt; part is executed. If there is no &lt;code&gt;else&lt;/code&gt; part and not all possible values that &lt;code&gt;expr&lt;/code&gt; can hold occur in a &lt;code&gt;slicelist&lt;/code&gt;, a static error occurs. This holds only for expressions of ordinal types. &quot;All possible values&quot; of &lt;code&gt;expr&lt;/code&gt; are determined by &lt;code&gt;expr&lt;/code&gt;'s type. To suppress the static error an &lt;code&gt;else&lt;/code&gt; part with an empty &lt;code&gt;discard&lt;/code&gt; statement should be used.</source>
          <target state="translated">的 &lt;code&gt;case&lt;/code&gt; 语句类似于if语句，但它代表了一个多分支选择。计算关键字 &lt;code&gt;case&lt;/code&gt; 之后的表达式，如果其值在&lt;em&gt;slicelist中&lt;/em&gt;，则执行相应的语句（在 &lt;code&gt;of&lt;/code&gt; 关键字之后）。如果该值不在任何给定的&lt;em&gt;切片列表中&lt;/em&gt;，则执行 &lt;code&gt;else&lt;/code&gt; 部分。如果没有 &lt;code&gt;else&lt;/code&gt; 部分，并且 &lt;code&gt;expr&lt;/code&gt; 可以容纳的所有可能值都没有出现在 &lt;code&gt;slicelist&lt;/code&gt; ，则会发生静态错误。这仅适用于序数类型的表达式。的&amp;ldquo;所有可能的值&amp;rdquo; &lt;code&gt;expr&lt;/code&gt; 被确定 &lt;code&gt;expr&lt;/code&gt; 的类型。为了抑制静态错误，应使用带有空的 &lt;code&gt;discard&lt;/code&gt; 语句的 &lt;code&gt;else&lt;/code&gt; 部分。</target>
        </trans-unit>
        <trans-unit id="b931d0051b260f30fa749dc3d29290c854e0e0fd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;codegenDecl&lt;/code&gt; pragma can be used to directly influence Nim's code generator. It receives a format string that determines how the variable or proc is declared in the generated code.</source>
          <target state="translated">该 &lt;code&gt;codegenDecl&lt;/code&gt; 编译可用于直接影响稔的代码生成器。它接收一个格式字符串，该格式字符串确定如何在生成的代码中声明变量或proc。</target>
        </trans-unit>
        <trans-unit id="4a60295e92762b0a268d73c57558484ce5962353" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;compile&lt;/code&gt; pragma can be used to compile and link a C/C++ source file with the project:</source>
          <target state="translated">所述 &lt;code&gt;compile&lt;/code&gt; 编译指示可用于编译和链接C / C ++源文件与项目：</target>
        </trans-unit>
        <trans-unit id="32f5047930630f7d43dcd54eb01e5361a0735034" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;compileTime&lt;/code&gt; pragma is used to mark a proc or variable to be used at compile time only. No code will be generated for it. Compile time procs are useful as helpers for macros. Since version 0.12.0 of the language, a proc that uses &lt;code&gt;system.NimNode&lt;/code&gt; within its parameter types is implicitly declared &lt;code&gt;compileTime&lt;/code&gt;:</source>
          <target state="translated">在 &lt;code&gt;compileTime&lt;/code&gt; 编译用于标记一个PROC或变量在仅编译时被使用。不会为此生成任何代码。编译时间处理程序可用作宏的帮助程序。从该语言的0.12.0版本开始，在其参数类型内使用 &lt;code&gt;system.NimNode&lt;/code&gt; 的proc 被隐式声明为 &lt;code&gt;compileTime&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="e71c552e9eb087bf7303d12b46f93a710977aea7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;computedGoto&lt;/code&gt; pragma can be used to tell the compiler how to compile a Nim &lt;span id=&quot;case_2&quot;&gt;case&lt;/span&gt; in a &lt;code&gt;while true&lt;/code&gt; statement. Syntactically it has to be used as a statement inside the loop:</source>
          <target state="translated">该 &lt;code&gt;computedGoto&lt;/code&gt; 编译可以用来告诉编译器如何编译稔&lt;span id=&quot;case_2&quot;&gt;情况下，&lt;/span&gt;在 &lt;code&gt;while true&lt;/code&gt; 声明。从句法上讲，它必须用作循环内的语句：</target>
        </trans-unit>
        <trans-unit id="13725b1c9ade232410cac093cb3d9c609f4347af" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;con&lt;/code&gt; Nimsuggest command is very similar to the suggestions command, but instead of being used after the user has typed a dot character, this one is meant to be used after the user has typed an opening brace to start typing parameters.</source>
          <target state="translated">该 &lt;code&gt;con&lt;/code&gt; Nimsuggest命令非常相似，但对建议的命令，而不是用户键入一个点字符之后仍然被使用，这一项是指用户键入开括号开始输入参数后使用。</target>
        </trans-unit>
        <trans-unit id="a4393be6b906a951ceceb50efcf150dd498771f7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cstring&lt;/code&gt; type meaning &lt;em&gt;compatible string&lt;/em&gt; is the native representation of a string for the compilation backend. For the C backend the &lt;code&gt;cstring&lt;/code&gt; type represents a pointer to a zero-terminated char array compatible to the type &lt;code&gt;char*&lt;/code&gt; in Ansi C. Its primary purpose lies in easy interfacing with C. The index operation &lt;code&gt;s[i]&lt;/code&gt; means the i-th &lt;em&gt;char&lt;/em&gt; of &lt;code&gt;s&lt;/code&gt;; however no bounds checking for &lt;code&gt;cstring&lt;/code&gt; is performed making the index operation unsafe.</source>
          <target state="translated">在 &lt;code&gt;cstring&lt;/code&gt; 类型含义&lt;em&gt;兼容的字符串&lt;/em&gt;是编译后端字符串的本地表示。对于C后端， &lt;code&gt;cstring&lt;/code&gt; 类型表示一个指针，该指针指向与Ansi C中的 &lt;code&gt;char*&lt;/code&gt; 类型兼容的零终止char数组。其主要目的在于易于与C接口。索引操作 &lt;code&gt;s[i]&lt;/code&gt; 表示第i个&lt;em&gt;char&lt;/em&gt;的 &lt;code&gt;s&lt;/code&gt; ; 但是，不执行对 &lt;code&gt;cstring&lt;/code&gt; 的边界检查，这会使索引操作不安全。</target>
        </trans-unit>
        <trans-unit id="94b4450902f6290125300edf3507775a37d2e1c6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;data&lt;/code&gt; is application-defined data, which will be passed when &lt;code&gt;ev&lt;/code&gt; happens.</source>
          <target state="translated">的 &lt;code&gt;data&lt;/code&gt; 是应用程序定义的数据，时将被传递 &lt;code&gt;ev&lt;/code&gt; 发生。</target>
        </trans-unit>
        <trans-unit id="2420343b67cf5f6d0ad1bb94f0326b094a8ab2e3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;data&lt;/code&gt; is application-defined data, which will be passed when process with &lt;code&gt;pid&lt;/code&gt; has exited.</source>
          <target state="translated">的 &lt;code&gt;data&lt;/code&gt; 是应用程序定义的数据，当与方法，该方法将被传递 &lt;code&gt;pid&lt;/code&gt; 已退出。</target>
        </trans-unit>
        <trans-unit id="944bc8355b34d79d86a6c6b2a6eb683062d9add5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;data&lt;/code&gt; is application-defined data, which will be passed when signal raises.</source>
          <target state="translated">的 &lt;code&gt;data&lt;/code&gt; 是应用程序定义的数据，当信号升高，这将被传递。</target>
        </trans-unit>
        <trans-unit id="39620c3fad1d30f3b1f821ad058fe01edf735504" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;data&lt;/code&gt; is application-defined data, which will be passed, when the timer is triggered.</source>
          <target state="translated">的 &lt;code&gt;data&lt;/code&gt; 是应用程序定义的数据，这将被传递时，定时器被触发时。</target>
        </trans-unit>
        <trans-unit id="d408a6fed5457e4eb16aefaa58b57d0d3444464a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;def&lt;/code&gt; Nimsuggest command performs a query about the definition of a specific symbol. If available, Nimsuggest will answer with the type, source file, line/column information and other accessory data if available like a docstring. With this information an IDE can provide the typical &lt;em&gt;Jump to definition&lt;/em&gt; where a user puts the cursor on a symbol or uses the mouse to select it and is redirected to the place where the symbol is located.</source>
          <target state="translated">的 &lt;code&gt;def&lt;/code&gt; Nimsuggest命令执行关于特定符号的定义查询。如果可用，Nimsuggest将回答类型，源文件，行/列信息以及其他附件数据（如docstring）。通过此信息，IDE可以提供典型的&lt;em&gt;跳转到定义&lt;/em&gt;，用户将光标放在符号上或使用鼠标将其选中，然后将其重定向到该符号所在的位置。</target>
        </trans-unit>
        <trans-unit id="a06a0dec2b01f32c664435ab9f31e13949ab037d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;discard&lt;/code&gt; statement can also be used to create block comments as described in the &lt;a href=&quot;#comments&quot;&gt;Comments&lt;/a&gt; section.</source>
          <target state="translated">该 &lt;code&gt;discard&lt;/code&gt; 的语句也可以用作描述创建块注释&lt;a href=&quot;#comments&quot;&gt;注释&lt;/a&gt;部分。</target>
        </trans-unit>
        <trans-unit id="9b91a9fbefbe79c145dec481daa3f20cf6495d82" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;discard&lt;/code&gt; statement evaluates its expression for side-effects and throws the expression's resulting value away.</source>
          <target state="translated">该 &lt;code&gt;discard&lt;/code&gt; 语句计算其副作用的表达，并引发表达式的结果值了。</target>
        </trans-unit>
        <trans-unit id="e03a7cd86091bf4978da827132b8b38c56f5a7ec" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;doc&lt;/code&gt; command:</source>
          <target state="translated">该 &lt;code&gt;doc&lt;/code&gt; 的命令：</target>
        </trans-unit>
        <trans-unit id="9ca7671dacb127635569222e277ebf2ecb0f66a4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;dynlib&lt;/code&gt; import mechanism supports a versioning scheme:</source>
          <target state="translated">该 &lt;code&gt;dynlib&lt;/code&gt; 进口机制支持的版本控制方案：</target>
        </trans-unit>
        <trans-unit id="711b0f2233816783424452869696407ac31e0db3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;dynlib&lt;/code&gt; pragma supports not only constant strings as argument but also string expressions in general:</source>
          <target state="translated">该 &lt;code&gt;dynlib&lt;/code&gt; 附注不仅支持常量字符串作为参数，而且字符串表达式一般：</target>
        </trans-unit>
        <trans-unit id="0a70d199da0b3634e63e2a723bfea6e65d9ac0d1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;effects&lt;/code&gt; pragma has been designed to assist the programmer with the effects analysis. It is a statement that makes the compiler output all inferred effects up to the &lt;code&gt;effects&lt;/code&gt;'s position:</source>
          <target state="translated">该 &lt;code&gt;effects&lt;/code&gt; 编译的设计，以协助效果分析程序员。这是一条语句，使编译器可以输出所有推断的效果，直到 &lt;code&gt;effects&lt;/code&gt; 的位置为止：</target>
        </trans-unit>
        <trans-unit id="e6f0db3ce7d6ed0afa4949c7005ccdb2e6f1d36f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;emit&lt;/code&gt; pragma can be used to directly affect the output of the compiler's code generator. So it makes your code unportable to other code generators/backends. Its usage is highly discouraged! However, it can be extremely useful for interfacing with &lt;span id=&quot;cplusplus_1&quot;&gt;C++&lt;/span&gt; or &lt;span id=&quot;objective-c_1&quot;&gt;Objective C&lt;/span&gt; code.</source>
          <target state="translated">所述 &lt;code&gt;emit&lt;/code&gt; 编译指示可用于直接影响编译器的代码生成器的输出。因此，它使您的代码无法移植到其他代码生成器/后端。不鼓励使用它！但是，对于与&lt;span id=&quot;cplusplus_1&quot;&gt;C ++&lt;/span&gt;或&lt;span id=&quot;objective-c_1&quot;&gt;目标C&lt;/span&gt;代码进行接口连接而言，它可能非常有用。</target>
        </trans-unit>
        <trans-unit id="4e1c7e194942108d8e21f2868b591c724f772ae0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;encode&lt;/code&gt; procedure takes an &lt;code&gt;openarray&lt;/code&gt; so both arrays and sequences can be passed as parameters.</source>
          <target state="translated">的 &lt;code&gt;encode&lt;/code&gt; 过程需要一个 &lt;code&gt;openarray&lt;/code&gt; 这样两个阵列和序列可以作为参数被传递。</target>
        </trans-unit>
        <trans-unit id="0be6fe6293d87b67dc2913d9bce025978f0a0479" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;error&lt;/code&gt; pragma can also be used to annotate a symbol (like an iterator or proc). The &lt;em&gt;usage&lt;/em&gt; of the symbol then triggers a compile-time error. This is especially useful to rule out that some operation is valid due to overloading and type conversions:</source>
          <target state="translated">的 &lt;code&gt;error&lt;/code&gt; 附注也可用于标注一个符号（如一个迭代或PROC）。然后，&lt;em&gt;使用&lt;/em&gt;符号会触发编译时错误。这对于排除某些操作由于重载和类型转换而有效的情况特别有用：</target>
        </trans-unit>
        <trans-unit id="4f57f84a99b6715a53ef1c48e22f80406dcf7a1d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;error&lt;/code&gt; pragma is used to make the compiler output an error message with the given content. Compilation does not necessarily abort after an error though.</source>
          <target state="translated">的 &lt;code&gt;error&lt;/code&gt; 附注用于使编译器输出的错误消息与所述给定的内容。但是，编译不一定会在出错后中止。</target>
        </trans-unit>
        <trans-unit id="6e20ba8aa37ee9c1d06ae011187ea2193578fda3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;experimental&lt;/code&gt; pragma enables experimental language features. Depending on the concrete feature this means that the feature is either considered too unstable for an otherwise stable release or that the future of the feature is uncertain (it may be removed any time).</source>
          <target state="translated">该 &lt;code&gt;experimental&lt;/code&gt; 编译使实验的语言功能。根据具体的功能，这意味着该功能要么被认为对于通过其他方式稳定发布而言过于不稳定，要么不确定该功能的未来（可以随时删除）。</target>
        </trans-unit>
        <trans-unit id="5c5fb8cbfdf80872586dff5915d97b9df4693c00" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;exportc&lt;/code&gt; pragma provides a means to export a type, a variable, or a procedure to C. Enums and constants can't be exported. The optional argument is a string containing the C identifier. If the argument is missing, the C name is the Nim identifier &lt;em&gt;exactly as spelled&lt;/em&gt;:</source>
          <target state="translated">所述 &lt;code&gt;exportc&lt;/code&gt; 编译指示提供到导出类型，变量或C.枚举和常量的过程无法导出的装置。可选参数是包含C标识符的字符串。如果缺少该参数，则C名称是与&lt;em&gt;拼写完全相同&lt;/em&gt;的Nim标识符：</target>
        </trans-unit>
        <trans-unit id="47b24553ecff8957d4500654446c7208e0bde7f6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;expr&lt;/code&gt; in &lt;code&gt;let x = expr&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;expr&lt;/code&gt; 在 &lt;code&gt;let x = expr&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5b98b3911e1265813479591033e8dcbc4614d140" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;expr&lt;/code&gt; in &lt;code&gt;result = expr&lt;/code&gt; where &lt;code&gt;result&lt;/code&gt; is the special symbol introduced by the compiler.</source>
          <target state="translated">的 &lt;code&gt;expr&lt;/code&gt; 在 &lt;code&gt;result = expr&lt;/code&gt; 其中 &lt;code&gt;result&lt;/code&gt; 是由编译器引入的特殊符号。</target>
        </trans-unit>
        <trans-unit id="9a1869dad0651b77d39e69eb4e5353bc58adc7c8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;expr&lt;/code&gt; in &lt;code&gt;return expr&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;expr&lt;/code&gt; 在 &lt;code&gt;return expr&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="78082c4233243f41109f44b1a863ec8557ffce70" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;expr&lt;/code&gt; in &lt;code&gt;var x = expr&lt;/code&gt;.</source>
          <target state="translated">的 &lt;code&gt;expr&lt;/code&gt; 在 &lt;code&gt;var x = expr&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0ccc224f63d4c9f00b3f6c42a04670fca5ecc5e9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;fatal&lt;/code&gt; pragma is used to make the compiler output an error message with the given content. In contrast to the &lt;code&gt;error&lt;/code&gt; pragma, compilation is guaranteed to be aborted by this pragma. Example:</source>
          <target state="translated">的 &lt;code&gt;fatal&lt;/code&gt; 编译指示被用来使编译器输出与给定的内容的错误信息。与 &lt;code&gt;error&lt;/code&gt; 编译指示相反，保证编译会被此编译指示中止。例：</target>
        </trans-unit>
        <trans-unit id="4a8a977747b68cc9df3227b470584d16d2fcbb42" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;file&lt;/code&gt; paramater is enough for static analysis, but IDEs tend to have &lt;em&gt;unsaved buffers&lt;/em&gt; where the user may still be in the middle of typing a line. In such situations the IDE can save the current contents to a temporary file and then use the &lt;code&gt;dirtyfile.nim&lt;/code&gt; option to tell Nimsuggest that &lt;code&gt;foobar.nim&lt;/code&gt; should be taken from &lt;code&gt;temporary/foobar.nim&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;file&lt;/code&gt; paramater是足够的静态分析，但是集成开发环境往往有&lt;em&gt;未保存的缓冲区&lt;/em&gt;，其中用户仍然可以在键入一行的中间。在这种情况下，IDE可以将当前内容保存到一个临时文件中，然后使用 &lt;code&gt;dirtyfile.nim&lt;/code&gt; 选项告诉Nimsuggest &lt;code&gt;foobar.nim&lt;/code&gt; 应该从 &lt;code&gt;temporary/foobar.nim&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="32aac42cbd8ce78d102f6016c7193cba8438ab2d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;final&lt;/code&gt; pragma can be used for an object type to specify that it cannot be inherited from. Note that inheritance is only available for objects that inherit from an existing object (via the &lt;code&gt;object of SuperType&lt;/code&gt; syntax) or that have been marked as &lt;code&gt;inheritable&lt;/code&gt;.</source>
          <target state="translated">的 &lt;code&gt;final&lt;/code&gt; 编译指示可用于一个对象类型来指定它不能从被继承。请注意，继承仅适用于从现有对象继承（通过 &lt;code&gt;object of SuperType&lt;/code&gt; 语法的对象）或已标记为 &lt;code&gt;inheritable&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bc6920d18d66b9005034c2f565bcac18339a40f3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;fmt&quot;{expr}&quot;&lt;/code&gt; syntax is more aesthetically pleasing, but it hides a small gotcha. The string is a &lt;a href=&quot;manual#lexical-analysis-generalized-raw-string-literals&quot;&gt;generalized raw string literal&lt;/a&gt;. This has some surprising effects:</source>
          <target state="translated">在 &lt;code&gt;fmt&quot;{expr}&quot;&lt;/code&gt; 语法更美观，但它隐藏了一个小的疑难杂症。该字符串是&lt;a href=&quot;manual#lexical-analysis-generalized-raw-string-literals&quot;&gt;广义的原始字符串文字&lt;/a&gt;。这具有一些令人惊讶的效果：</target>
        </trans-unit>
        <trans-unit id="436147e1c09214f0e309d989b28b417ff7622040" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;for&lt;/code&gt; loop declares iteration variables - their scope reaches until the end of the loop body. The iteration variables' types are inferred by the return type of the iterator.</source>
          <target state="translated">该 &lt;code&gt;for&lt;/code&gt; 循环反复声明的变量-它们的范围，直到达到循环体的结束。迭代变量的类型由迭代器的返回类型推断。</target>
        </trans-unit>
        <trans-unit id="d87dfe950dbe2084f156bb115bd025bb3ef4b279" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;for&lt;/code&gt; statement can be used with one or two variables when used with a sequence. When you use the one variable form, the variable will hold the value provided by the sequence. The &lt;code&gt;for&lt;/code&gt; statement is looping over the results from the &lt;a href=&quot;system#items.i,seq%5BT%5D&quot;&gt;items()&lt;/a&gt; iterator from the &lt;a href=&quot;system&quot;&gt;system&lt;/a&gt; module. But if you use the two variable form, the first variable will hold the index position and the second variable will hold the value. Here the &lt;code&gt;for&lt;/code&gt; statement is looping over the results from the &lt;a href=&quot;system#pairs.i,seq%5BT%5D&quot;&gt;pairs()&lt;/a&gt; iterator from the &lt;a href=&quot;system&quot;&gt;system&lt;/a&gt; module. Examples:</source>
          <target state="translated">该 &lt;code&gt;for&lt;/code&gt; 语句可以与一个或两个变量，一个序列中使用时，可以使用。当使用一个变量形式时，变量将保存序列提供的值。该 &lt;code&gt;for&lt;/code&gt; 语句从遍历结果&lt;a href=&quot;system#items.i,seq%5BT%5D&quot;&gt;项（）&lt;/a&gt;从迭代器&lt;a href=&quot;system&quot;&gt;系统&lt;/a&gt;模块。但是，如果使用两个变量形式，则第一个变量将保留索引位置，第二个变量将保留值。这里的 &lt;code&gt;for&lt;/code&gt; 语句遍历&lt;a href=&quot;system&quot;&gt;系统&lt;/a&gt;模块的&lt;a href=&quot;system#pairs.i,seq%5BT%5D&quot;&gt;pair（）&lt;/a&gt;迭代器的结果。例子：</target>
        </trans-unit>
        <trans-unit id="7a5f8ddc630011123a75729ce1011d437f837fe3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;for&lt;/code&gt; statement is a construct to loop over any element an &lt;em&gt;iterator&lt;/em&gt; provides. The example uses the built-in &lt;a href=&quot;system#countup&quot;&gt;countup&lt;/a&gt; iterator:</source>
          <target state="translated">该 &lt;code&gt;for&lt;/code&gt; 语句是一个结构遍历的任何元素&lt;em&gt;迭代器&lt;/em&gt;提供。该示例使用内置的&lt;a href=&quot;system#countup&quot;&gt;countup&lt;/a&gt;迭代器：</target>
        </trans-unit>
        <trans-unit id="a3b3d0f268a26cc4a0699d12f685526f47dd2e35" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;from&lt;/code&gt; statement can also force namespace qualification on symbols, thereby making symbols available, but needing to be qualified to be used.</source>
          <target state="translated">在 &lt;code&gt;from&lt;/code&gt; 语句也可以强迫符号命名空间限定，从而使符号可用，但需要是有资格被使用。</target>
        </trans-unit>
        <trans-unit id="628bb89d094225e527b7e15df6b1eb1b878153d6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;func&lt;/code&gt; keyword introduces a shortcut for a &lt;span id=&quot;nosideeffect_1&quot;&gt;noSideEffect&lt;/span&gt; proc.</source>
          <target state="translated">该 &lt;code&gt;func&lt;/code&gt; 关键字引入了一个快捷方式&lt;span id=&quot;nosideeffect_1&quot;&gt;noSideEffect&lt;/span&gt; PROC。</target>
        </trans-unit>
        <trans-unit id="d0083ea6cc0b6494a6dbfc51aca179ac8b3c56af" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;get&lt;/code&gt; operation demonstrated above returns the underlying value, or raises &lt;code&gt;UnpackError&lt;/code&gt; if there is no value. There is another option for obtaining the value: &lt;code&gt;unsafeGet&lt;/code&gt;, but you must only use it when you are absolutely sure the value is present (e.g. after checking &lt;code&gt;isSome&lt;/code&gt;). If you do not care about the tiny overhead that &lt;code&gt;get&lt;/code&gt; causes, you should simply never use &lt;code&gt;unsafeGet&lt;/code&gt;.</source>
          <target state="translated">上面演示的 &lt;code&gt;get&lt;/code&gt; 操作返回基础值，如果没有值，则引发 &lt;code&gt;UnpackError&lt;/code&gt; 。还有一个获取值的选项： &lt;code&gt;unsafeGet&lt;/code&gt; ，但是只有在绝对确定存在该值时（例如，在检查 &lt;code&gt;isSome&lt;/code&gt; 之后），才必须使用它。如果你不关心的小开销 &lt;code&gt;get&lt;/code&gt; 的原因，你应该永远使用 &lt;code&gt;unsafeGet&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3b262a4793a87dcd3423e3de392c1373594c7a80" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;global&lt;/code&gt; pragma can be applied to a variable within a proc to instruct the compiler to store it in a global location and initialize it once at program startup.</source>
          <target state="translated">在 &lt;code&gt;global&lt;/code&gt; 编译可以应用到一个变量一个进程内指示编译器将其存储在一个全球性的位置，并在程序启动一次初始化。</target>
        </trans-unit>
        <trans-unit id="f3137d8ded88666f115e1ad63a5e346dd2aff08c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;guard&lt;/code&gt; annotation can also be used to protect fields within an object. The guard then needs to be another field within the same object or a global variable.</source>
          <target state="translated">该 &lt;code&gt;guard&lt;/code&gt; 注释也可以用来在对象上保护领域。然后，防护必须是同一对象内的另一个字段或全局变量。</target>
        </trans-unit>
        <trans-unit id="e66122e0d67f678d2cd3350768f39275164af1b8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;header&lt;/code&gt; pragma always expects a string constant. The string contant contains the header file: As usual for C, a system header file is enclosed in angle brackets: &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt;. If no angle brackets are given, Nim encloses the header file in &lt;code&gt;&quot;&quot;&lt;/code&gt; in the generated C code.</source>
          <target state="translated">该 &lt;code&gt;header&lt;/code&gt; 编译总是期望一个字符串常量。字符串内容包含头文件：与C一样，系统头文件用尖括号括起来： &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 。如果未提供尖括号，则Nim会将头文件包含在生成的C代码中的 &lt;code&gt;&quot;&quot;&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="0b679c76e7a9ed62a93f723575cfccef75d26424" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;header&lt;/code&gt; pragma is very similar to the &lt;code&gt;noDecl&lt;/code&gt; pragma: It can be applied to almost any symbol and specifies that it should not be declared and instead the generated code should contain an &lt;code&gt;#include&lt;/code&gt;:</source>
          <target state="translated">的 &lt;code&gt;header&lt;/code&gt; 的pragma是非常相似的 &lt;code&gt;noDecl&lt;/code&gt; 编译指示：它可应用于几乎任何符号，并指定不应该声明，而不是将所生成的代码应包含 &lt;code&gt;#include&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="9a9ed3be3ca0ab53ad4c051a00d1adf22ed5686a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;hint&lt;/code&gt; pragma is used to make the compiler output a hint message with the given content. Compilation continues after the hint.</source>
          <target state="translated">该 &lt;code&gt;hint&lt;/code&gt; 编译指示被用来使编译器输出一个提示消息与所述给定的内容。提示后，编译继续进行。</target>
        </trans-unit>
        <trans-unit id="2ebd6b843b12e6bfab912253ce8368ae735e6323" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;if&lt;/code&gt; statement is a simple way to make a branch in the control flow: The expression after the keyword &lt;code&gt;if&lt;/code&gt; is evaluated, if it is true the corresponding statements after the &lt;code&gt;:&lt;/code&gt; are executed. Otherwise the expression after the &lt;code&gt;elif&lt;/code&gt; is evaluated (if there is an &lt;code&gt;elif&lt;/code&gt; branch), if it is true the corresponding statements after the &lt;code&gt;:&lt;/code&gt; are executed. This goes on until the last &lt;code&gt;elif&lt;/code&gt;. If all conditions fail, the &lt;code&gt;else&lt;/code&gt; part is executed. If there is no &lt;code&gt;else&lt;/code&gt; part, execution continues with the next statement.</source>
          <target state="translated">该 &lt;code&gt;if&lt;/code&gt; 语句是一个简单的方法，使在控制流分支：表达式，关键字后面 &lt;code&gt;if&lt;/code&gt; 被评估，如果以后相应的陈述是真实的 &lt;code&gt;:&lt;/code&gt; 被执行。否则，将评估 &lt;code&gt;elif&lt;/code&gt; 之后的表达式（如果存在 &lt;code&gt;elif&lt;/code&gt; 分支），如果为true，则执行 &lt;code&gt;:&lt;/code&gt; 之后的相应语句。这一直持续到最后一个 &lt;code&gt;elif&lt;/code&gt; 为止。如果所有条件都失败，则执行 &lt;code&gt;else&lt;/code&gt; 部分。如果没有 &lt;code&gt;else&lt;/code&gt; 部分，则从下一条语句继续执行。</target>
        </trans-unit>
        <trans-unit id="fd9a59bb3838f7721c56dcd3c0f527061c3d17e3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;importc&lt;/code&gt; pragma provides a means to import a proc or a variable from C. The optional argument is a string containing the C identifier. If the argument is missing, the C name is the Nim identifier &lt;em&gt;exactly as spelled&lt;/em&gt;:</source>
          <target state="translated">该 &lt;code&gt;importc&lt;/code&gt; 编译指示提供了导入一个PROC或可选的参数是一个包含C标识符字符串从C.可变的装置。如果缺少该参数，则C名称是与&lt;em&gt;拼写完全相同&lt;/em&gt;的Nim标识符：</target>
        </trans-unit>
        <trans-unit id="ad4417d81051ba2fda59de7fd41e5159b1404cce" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;include&lt;/code&gt; statement does something fundamentally different than importing a module: it merely includes the contents of a file. The &lt;code&gt;include&lt;/code&gt; statement is useful to split up a large module into several files:</source>
          <target state="translated">在 &lt;code&gt;include&lt;/code&gt; 语句做的东西比导入模块根本不同：它仅仅包括文件的内容。在 &lt;code&gt;include&lt;/code&gt; 声明是有用的大型模块分成几个文件：</target>
        </trans-unit>
        <trans-unit id="0f94857a75c9bc1979ffd9f951809e759cc263fa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;incompleteStruct&lt;/code&gt; pragma tells the compiler to not use the underlying C &lt;code&gt;struct&lt;/code&gt; in a &lt;code&gt;sizeof&lt;/code&gt; expression:</source>
          <target state="translated">所述 &lt;code&gt;incompleteStruct&lt;/code&gt; 编译指示告诉编译器不使用底层C &lt;code&gt;struct&lt;/code&gt; 在一个 &lt;code&gt;sizeof&lt;/code&gt; 表达式：</target>
        </trans-unit>
        <trans-unit id="bf743bc2a57bf16453dba05ab29e67acdfb89a5b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;inject&lt;/code&gt; and &lt;code&gt;gensym&lt;/code&gt; pragmas are second class annotations; they have no semantics outside of a template definition and cannot be abstracted over:</source>
          <target state="translated">的 &lt;code&gt;inject&lt;/code&gt; 和 &lt;code&gt;gensym&lt;/code&gt; 编译指示是第二类注释; 它们在模板定义之外没有语义，并且不能通过以下方式抽象：</target>
        </trans-unit>
        <trans-unit id="c48a2765e8c42b7c535b1be5ad5b35ddb4c24b83" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;injectStmt&lt;/code&gt; pragma can be used to inject a statement before every other statement in the current module. It is only supposed to be used for debugging:</source>
          <target state="translated">该 &lt;code&gt;injectStmt&lt;/code&gt; 编译可用于当前模块中的所有其他语句之前注入的声明。它仅应用于调试：</target>
        </trans-unit>
        <trans-unit id="633eb4e1412a3b13001ffe18b5db908a368027e4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;intsets&lt;/code&gt; module implements an efficient int set implemented as a &lt;span id=&quot;sparse-bit-set_1&quot;&gt;sparse bit set&lt;/span&gt;. &lt;strong&gt;Note&lt;/strong&gt;: Since Nim currently does not allow the assignment operator to be overloaded, &lt;code&gt;=&lt;/code&gt; for int sets performs some rather meaningless shallow copy; use &lt;code&gt;assign&lt;/code&gt; to get a deep copy.</source>
          <target state="translated">所述 &lt;code&gt;intsets&lt;/code&gt; 模块实现为实现一个高效的INT组&lt;span id=&quot;sparse-bit-set_1&quot;&gt;稀疏比特集合&lt;/span&gt;。&lt;strong&gt;注意&lt;/strong&gt;：由于Nim当前不允许重载赋值运算符，因此对于int集的 &lt;code&gt;=&lt;/code&gt; 会执行一些相当无意义的浅表复制；使用 &lt;code&gt;assign&lt;/code&gt; 获取深层副本。</target>
        </trans-unit>
        <trans-unit id="ac6a8f8a9038fd001e9bcf25c7590eeedb8367bb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;int{lit}&lt;/code&gt; parameter pattern matches against an expression of type &lt;code&gt;int&lt;/code&gt;, but only if it's a literal.</source>
          <target state="translated">的 &lt;code&gt;int{lit}&lt;/code&gt; 针对类型的表达式参数模式匹配 &lt;code&gt;int&lt;/code&gt; ，但只有当它是一个文字。</target>
        </trans-unit>
        <trans-unit id="dbcf608e730943249674bddace7178d1650d4c3d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;is&lt;/code&gt; operator checks for type equivalence at compile time. It is therefore very useful for type specialization within generic code:</source>
          <target state="translated">的 &lt;code&gt;is&lt;/code&gt; 用于在编译时型等价操作者检查。因此，这对于通用代码中的类型专门化非常有用：</target>
        </trans-unit>
        <trans-unit id="bab0e112ac9b29f05be238eca0977fc170691191" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;iterator&lt;/code&gt; type is always of the calling convention &lt;code&gt;closure&lt;/code&gt; implicitly; the following example shows how to use iterators to implement a &lt;span id=&quot;collaborative-tasking_1&quot;&gt;collaborative tasking&lt;/span&gt; system:</source>
          <target state="translated">该 &lt;code&gt;iterator&lt;/code&gt; 类型是调用约定的始终 &lt;code&gt;closure&lt;/code&gt; 含蓄; 以下示例显示了如何使用迭代器来实现&lt;span id=&quot;collaborative-tasking_1&quot;&gt;协作式任务&lt;/span&gt;系统：</target>
        </trans-unit>
        <trans-unit id="8c51c8609edeb22ed76fcbde9b258a50e77c8157" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;jsondoc0&lt;/code&gt; command:</source>
          <target state="translated">该 &lt;code&gt;jsondoc0&lt;/code&gt; 命令：</target>
        </trans-unit>
        <trans-unit id="d07ffe6edb5db09dbe2b7e3001f8af54d7978127" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;jsondoc&lt;/code&gt; command:</source>
          <target state="translated">该 &lt;code&gt;jsondoc&lt;/code&gt; 命令：</target>
        </trans-unit>
        <trans-unit id="f86e1a24462b67c7426c7b0acfee59f9a241fd55" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;koch&lt;/code&gt; program is Nim's maintenance script. It is a replacement for make and shell scripting with the advantage that it is much more portable. More information about its options can be found in the &lt;a href=&quot;koch&quot;&gt;koch&lt;/a&gt; documentation.</source>
          <target state="translated">该 &lt;code&gt;koch&lt;/code&gt; 程序是稔的维护脚本。它替代了make和shell脚本，其优点是更易于移植。可以在&lt;a href=&quot;koch&quot;&gt;koch&lt;/a&gt;文档中找到有关其选项的更多信息。</target>
        </trans-unit>
        <trans-unit id="7b2c762fac40a5608e0b7e7de49ebe36c6b608ae" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;let&lt;/code&gt; statement works like the &lt;code&gt;var&lt;/code&gt; statement but the declared symbols are &lt;em&gt;single assignment&lt;/em&gt; variables: After the initialization their value cannot change:</source>
          <target state="translated">该 &lt;code&gt;let&lt;/code&gt; 语句的工作方式的 &lt;code&gt;var&lt;/code&gt; 声明，但声明的符号是&lt;em&gt;单赋值&lt;/em&gt;的变量：初始化后，其价值无法更改：</target>
        </trans-unit>
        <trans-unit id="2e8bf1e1e37d7a0035195dab30ef109a27650d29" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;line&lt;/code&gt; pragma can be used to affect line information of the annotated statement as seen in stack backtraces:</source>
          <target state="translated">该 &lt;code&gt;line&lt;/code&gt; 编译可以用来影响注释语句行信息在栈回溯看到：</target>
        </trans-unit>
        <trans-unit id="915701467dacb0f53184563a8354aa1f016b1417" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;lineDir&lt;/code&gt; option can be turned on or off. If turned on the generated C code contains &lt;code&gt;#line&lt;/code&gt; directives. This may be helpful for debugging with GDB.</source>
          <target state="translated">该 &lt;code&gt;lineDir&lt;/code&gt; 选项可以打开或关闭。如果打开，则生成的C代码包含 &lt;code&gt;#line&lt;/code&gt; 指令。这对于使用GDB进行调试可能会有所帮助。</target>
        </trans-unit>
        <trans-unit id="8862192e862105c15d55393354d8d5087e6d99c3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;lineInfoFrom&lt;/code&gt; parameter is used for line information when the produced code crashes. You should ensure that it is set to a node that you are transforming.</source>
          <target state="translated">所述 &lt;code&gt;lineInfoFrom&lt;/code&gt; 参数用于行信息时生成的代码崩溃。您应该确保将其设置为要转换的节点。</target>
        </trans-unit>
        <trans-unit id="947951cac85d38c8083826636d24bf5d2f716054" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;lineTrace&lt;/code&gt; option implies the &lt;code&gt;stackTrace&lt;/code&gt; option. If turned on, the generated C contains code to ensure that proper stack traces with line number information are given if the program crashes or an uncaught exception is raised.</source>
          <target state="translated">该 &lt;code&gt;lineTrace&lt;/code&gt; 选项隐含 &lt;code&gt;stackTrace&lt;/code&gt; 选项。如果打开，生成的C将包含代码，以确保在程序崩溃或引发未捕获的异常时，给出带有行号信息的正确堆栈跟踪。</target>
        </trans-unit>
        <trans-unit id="d980b3bcc3269067f6e576157b155e2551065156" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;linearScanEnd&lt;/code&gt; pragma can be used to tell the compiler how to compile a Nim &lt;span id=&quot;case_1&quot;&gt;case&lt;/span&gt; statement. Syntactically it has to be used as a statement:</source>
          <target state="translated">该 &lt;code&gt;linearScanEnd&lt;/code&gt; 编译可以用来告诉编译器如何编译稔&lt;span id=&quot;case_1&quot;&gt;情况&lt;/span&gt;陈述。从句法上讲，它必须用作语句：</target>
        </trans-unit>
        <trans-unit id="81348c7397c56af7cb77770121f3f2ce241cb992" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;linearScanEnd&lt;/code&gt; pragma should be put into the last branch that should be tested against via linear scanning. If put into the last branch of the whole &lt;code&gt;case&lt;/code&gt; statement, the whole &lt;code&gt;case&lt;/code&gt; statement uses linear scanning.</source>
          <target state="translated">该 &lt;code&gt;linearScanEnd&lt;/code&gt; 编译应投入应该对通过线性扫描测试的最后一个分支。如果放在整个 &lt;code&gt;case&lt;/code&gt; 语句的最后一个分支中，则整个 &lt;code&gt;case&lt;/code&gt; 语句将使用线性扫描。</target>
        </trans-unit>
        <trans-unit id="661a3797ceadcd6fa8b44a4a0a3e4223544ab7e5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;link&lt;/code&gt; pragma can be used to link an additional file with the project:</source>
          <target state="translated">该 &lt;code&gt;link&lt;/code&gt; 编译可用于与项目链接的其他文件：</target>
        </trans-unit>
        <trans-unit id="c23f1774076a702902344c093a45ba7378aef4c5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;locks&lt;/code&gt; pragma can also take the special value &lt;code&gt;&quot;unknown&quot;&lt;/code&gt;. This is useful in the context of dynamic method dispatching. In the following example, the compiler can infer a lock level of 0 for the &lt;code&gt;base&lt;/code&gt; case. However, one of the overloaded methods calls a procvar which is potentially locking. Thus, the lock level of calling &lt;code&gt;g.testMethod&lt;/code&gt; cannot be inferred statically, leading to compiler warnings. By using &lt;code&gt;{.locks: &quot;unknown&quot;.}&lt;/code&gt;, the base method can be marked explicitly as having unknown lock level as well:</source>
          <target state="translated">该 &lt;code&gt;locks&lt;/code&gt; 编译还可以采取特殊值 &lt;code&gt;&quot;unknown&quot;&lt;/code&gt; 。这在动态方法分派的上下文中很有用。在下面的示例中，编译器可以为 &lt;code&gt;base&lt;/code&gt; 情况推断锁定级别0 。但是，其中一个重载方法调用了一个可能锁定的procvar。因此，无法静态推断调用 &lt;code&gt;g.testMethod&lt;/code&gt; 的锁定级别，从而导致编译器警告。通过使用 &lt;code&gt;{.locks: &quot;unknown&quot;.}&lt;/code&gt; ，基本方法也可以显式标记为具有未知的锁定级别：</target>
        </trans-unit>
        <trans-unit id="d06a4c92dabcb638ee9265fba0f2704858746025" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;locks&lt;/code&gt; pragma takes a list of lock expressions &lt;code&gt;locks: [a, b, ...]&lt;/code&gt; in order to support &lt;em&gt;multi lock&lt;/em&gt; statements. Why these are essential is explained in the &lt;a href=&quot;#guards-and-locks-lock-levels&quot;&gt;lock levels&lt;/a&gt; section.</source>
          <target state="translated">该 &lt;code&gt;locks&lt;/code&gt; 编译需要锁定的措辞列表 &lt;code&gt;locks: [a, b, ...]&lt;/code&gt; 为了支持&lt;em&gt;多锁&lt;/em&gt;语句。为什么这些必不可少的原因在&lt;a href=&quot;#guards-and-locks-lock-levels&quot;&gt;锁定级别&lt;/a&gt;部分中进行了说明。</target>
        </trans-unit>
        <trans-unit id="aae9f3366ca8ab53657f45e7a28b3801e912c68f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;locks&lt;/code&gt; section deliberately looks ugly because it has no runtime semantics and should not be used directly! It should only be used in templates that also implement some form of locking at runtime:</source>
          <target state="translated">该 &lt;code&gt;locks&lt;/code&gt; 部分故意长相丑陋，因为它没有运行时语义，不应该直接使用！它仅应在还可以在运行时实现某种形式的锁定的模板中使用：</target>
        </trans-unit>
        <trans-unit id="9be3a7206cb8c2fa20f67cb405592a8272cb3e35" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;mapper&lt;/code&gt; can can modify &lt;code&gt;val&lt;/code&gt; and &lt;code&gt;pairExists&lt;/code&gt; values to change the mapping of the key or delete it from the table. When adding a value, make sure to set &lt;code&gt;pairExists&lt;/code&gt; to &lt;code&gt;true&lt;/code&gt; along with modifying the &lt;code&gt;val&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;mapper&lt;/code&gt; 可以可以修改 &lt;code&gt;val&lt;/code&gt; 和 &lt;code&gt;pairExists&lt;/code&gt; 值更改密钥的映射或从表中删除它。添加值时，请确保将 &lt;code&gt;pairExists&lt;/code&gt; 设置为 &lt;code&gt;true&lt;/code&gt; 以及修改 &lt;code&gt;val&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f7db9956ef94890909f647902398c88b4235d0a7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;mapper&lt;/code&gt; takes 3 arguments:</source>
          <target state="translated">该 &lt;code&gt;mapper&lt;/code&gt; 接受3个参数：</target>
        </trans-unit>
        <trans-unit id="e2aecc3d04e1ba9c4da69fcea31f814e198a879c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;maxLength&lt;/code&gt; parameter determines the maximum amount of characters that can be read. &lt;code&gt;resString&lt;/code&gt; will be truncated after that.</source>
          <target state="translated">的 &lt;code&gt;maxLength&lt;/code&gt; 参数决定了可读取的字符的最大数量。之后， &lt;code&gt;resString&lt;/code&gt; 将被截断。</target>
        </trans-unit>
        <trans-unit id="5170e2edf536777dba0d2b9cf8223c8b3f59eaa7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;maxLength&lt;/code&gt; parameter determines the maximum amount of characters that can be read. The result is truncated after that.</source>
          <target state="translated">的 &lt;code&gt;maxLength&lt;/code&gt; 参数决定了可读取的字符的最大数量。之后，结果将被截断。</target>
        </trans-unit>
        <trans-unit id="12a39cee8d46eadd14d3ca1ab6f3b43021968677" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;msgHandler&lt;/code&gt; is a proc used for user error reporting. It will be called with the filename, line, col, and type of any error found during parsing. If you pass &lt;code&gt;nil&lt;/code&gt;, a default message handler will be used which writes the messages to the standard output.</source>
          <target state="translated">该 &lt;code&gt;msgHandler&lt;/code&gt; 是用于用户错误报告一个PROC。将使用解析期间发现的任何错误的文件名，行，列和类型来调用它。如果传递 &lt;code&gt;nil&lt;/code&gt; ，则将使用默认消息处理程序，该消息处理程序会将消息写入标准输出。</target>
        </trans-unit>
        <trans-unit id="65292252dedeb03bdd4cf17027914a7ac8f246a6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;nim&lt;/code&gt; executable processes configuration files in the following directories (in this order; later files overwrite previous settings):</source>
          <target state="translated">该 &lt;code&gt;nim&lt;/code&gt; 在以下目录中的可执行程序的配置文件（在这个秩序;更高版本的文件覆盖以前的设置）：</target>
        </trans-unit>
        <trans-unit id="2224eba7d666dacb73dc23680ccb160ec95313ae" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;nnkElifBranch&lt;/code&gt; and &lt;code&gt;nnkElse&lt;/code&gt; parts may be missing.</source>
          <target state="translated">该 &lt;code&gt;nnkElifBranch&lt;/code&gt; 和 &lt;code&gt;nnkElse&lt;/code&gt; 部分可能会丢失。</target>
        </trans-unit>
        <trans-unit id="32f208ade320ac5ce50ba89abb7bedd7b3b6454d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;noDecl&lt;/code&gt; pragma can be applied to almost any symbol (variable, proc, type, etc.) and is sometimes useful for interoperability with C: It tells Nim that it should not generate a declaration for the symbol in the C code. For example:</source>
          <target state="translated">所述 &lt;code&gt;noDecl&lt;/code&gt; 编译可应用于几乎任何符号（变量，PROC，类型等），并且有时在使用C互操作有用：它告诉稔，它不应该产生在C代码符号的声明。例如：</target>
        </trans-unit>
        <trans-unit id="80a70425379e8b6e57d7dbe189a2d199ed50d30f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;noSideEffect&lt;/code&gt; pragma is used to mark a proc/iterator to have no side effects. This means that the proc/iterator only changes locations that are reachable from its parameters and the return value only depends on the arguments. If none of its parameters have the type &lt;code&gt;var T&lt;/code&gt; or &lt;code&gt;ref T&lt;/code&gt; or &lt;code&gt;ptr T&lt;/code&gt; this means no locations are modified. It is a static error to mark a proc/iterator to have no side effect if the compiler cannot verify this.</source>
          <target state="translated">所述 &lt;code&gt;noSideEffect&lt;/code&gt; 编译用于标记一个PROC /迭代器没有任何副作用。这意味着proc / iterator仅更改其参数可访问的位置，并且返回值仅取决于参数。如果其所有参数都不具有 &lt;code&gt;var T&lt;/code&gt; 或 &lt;code&gt;ref T&lt;/code&gt; 或 &lt;code&gt;ptr T&lt;/code&gt; 类型,则表示没有位置被修改。如果编译器无法验证，则将proc /迭代器标记为没有副作用是一个静态错误。</target>
        </trans-unit>
        <trans-unit id="2f748ada5af7bcb027fed012bb10126b2e9ffdf6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;noreturn&lt;/code&gt; pragma is used to mark a proc that never returns.</source>
          <target state="translated">将 &lt;code&gt;noreturn&lt;/code&gt; 编译是用来标记一个进程，从来没有回报。</target>
        </trans-unit>
        <trans-unit id="6b1eff353ff0898aff7ebac46828c56901af2121" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;operation&lt;/code&gt; parameter should be an expression which uses the variables &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; for each step of the fold. Since this is a left fold, for non associative binary operations like subtraction think that the sequence of numbers 1, 2 and 3 will be parenthesized as (((1) - 2) - 3).</source>
          <target state="translated">的 &lt;code&gt;operation&lt;/code&gt; 参数应使用所述变量的表达式 &lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;b&lt;/code&gt; 为所述折叠的每个步骤。由于这是左折，因此对于像减法这样的非关联二进制运算，请认为数字1、2和3的序列将被括为（（（（1）-2）-3）。</target>
        </trans-unit>
        <trans-unit id="cf888b143d2f4149c1d7d438f9d55fbfcce18b54" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;operation&lt;/code&gt; parameter should be an expression which uses the variables &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; for each step of the fold. Since this is a right fold, for non associative binary operations like subtraction think that the sequence of numbers 1, 2 and 3 will be parenthesized as (1 - (2 - (3))).</source>
          <target state="translated">的 &lt;code&gt;operation&lt;/code&gt; 参数应使用所述变量的表达式 &lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;b&lt;/code&gt; 为所述折叠的每个步骤。由于这是正确的对折，因此对于像减法这样的非关联二进制运算，请考虑将数字1、2和3的序列括为（1-（2--（3）））。</target>
        </trans-unit>
        <trans-unit id="92b676ebe4f3f6e80af4461a2389327433cc03e5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;operation&lt;/code&gt; parameter should be an expression which uses the variables &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; for each step of the fold. The &lt;code&gt;first&lt;/code&gt; parameter is the start value (the first &lt;code&gt;a&lt;/code&gt;) and therefor defines the type of the result.</source>
          <target state="translated">的 &lt;code&gt;operation&lt;/code&gt; 参数应使用所述变量的表达式 &lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;b&lt;/code&gt; 为所述折叠的每个步骤。第 &lt;code&gt;first&lt;/code&gt; 参数是起始值（第一个 &lt;code&gt;a&lt;/code&gt; ），因此定义了结果的类型。</target>
        </trans-unit>
        <trans-unit id="e2887106b7df244891547998dfdb11bc056b419b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;optPeg&lt;/code&gt; template optimizes the case of a peg constructor with a string literal, so that the pattern will only be parsed once at program startup and stored in a global &lt;code&gt;gl&lt;/code&gt; which is then re-used. This optimization is called hoisting because it is comparable to classical loop hoisting.</source>
          <target state="translated">该 &lt;code&gt;optPeg&lt;/code&gt; 模板优化用于字符串的PEG构造的情况下，这样的模式将只在一次程序启动时解析，并存储在全局 &lt;code&gt;gl&lt;/code&gt; 然后用于重。此优化称为提升，因为它可与传统的环路提升相比。</target>
        </trans-unit>
        <trans-unit id="79bf8ca22f95d3471dae0c1cf77a6259078a951a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;packed&lt;/code&gt; pragma can be applied to any &lt;code&gt;object&lt;/code&gt; type. It ensures that the fields of an object are packed back-to-back in memory. It is useful to store packets or messages from/to network or hardware drivers, and for interoperability with C. Combining packed pragma with inheritance is not defined, and it should not be used with GC'ed memory (ref's).</source>
          <target state="translated">该 &lt;code&gt;packed&lt;/code&gt; 编译可应用于任何 &lt;code&gt;object&lt;/code&gt; 类型。它确保对象的字段在内存中背对背打包。存储来自/至网络或硬件驱动程序的数据包或消息，以及与C互操作性很有用。未定义打包的编​​译指示与继承的组合，因此不应将其与GC'ed内存（ref's）一起使用。</target>
        </trans-unit>
        <trans-unit id="b1e59de77052cfdd0f7bf673a9989ac1cea0fa90" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;params&lt;/code&gt; array must start with the return type of the proc, followed by a list of IdentDefs which specify the params.</source>
          <target state="translated">该 &lt;code&gt;params&lt;/code&gt; 阵列必须与返回类型的进程内，随后是指定PARAMS IdentDefs名单开始。</target>
        </trans-unit>
        <trans-unit id="899485653059d1572f2f010810cdc7109336ff7e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;parseJson&lt;/code&gt; procedure takes a string containing JSON and returns a &lt;code&gt;JsonNode&lt;/code&gt; object. This is an object variant and it is either a &lt;code&gt;JObject&lt;/code&gt;, &lt;code&gt;JArray&lt;/code&gt;, &lt;code&gt;JString&lt;/code&gt;, &lt;code&gt;JInt&lt;/code&gt;, &lt;code&gt;JFloat&lt;/code&gt;, &lt;code&gt;JBool&lt;/code&gt; or &lt;code&gt;JNull&lt;/code&gt;. You check the kind of this object variant by using the &lt;code&gt;kind&lt;/code&gt; accessor.</source>
          <target state="translated">所述 &lt;code&gt;parseJson&lt;/code&gt; 过程需要含有JSON并返回一个字符串 &lt;code&gt;JsonNode&lt;/code&gt; 对象。这是一个对象变体，可以是 &lt;code&gt;JObject&lt;/code&gt; ， &lt;code&gt;JArray&lt;/code&gt; ， &lt;code&gt;JString&lt;/code&gt; ， &lt;code&gt;JInt&lt;/code&gt; ， &lt;code&gt;JFloat&lt;/code&gt; ， &lt;code&gt;JBool&lt;/code&gt; 或 &lt;code&gt;JNull&lt;/code&gt; 。您可以通过使用 &lt;code&gt;kind&lt;/code&gt; 访问器来检查此对象变量的种类。</target>
        </trans-unit>
        <trans-unit id="7500e4fe275240ec3e962a88617dbb075a1767f0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;parsecfg&lt;/code&gt; module implements a high performance configuration file parser. The configuration file's syntax is similar to the Windows &lt;code&gt;.ini&lt;/code&gt; format, but much more powerful, as it is not a line based parser. String literals, raw string literals and triple quoted string literals are supported as in the Nim programming language.This is an example of how a configuration file may look like:</source>
          <target state="translated">该 &lt;code&gt;parsecfg&lt;/code&gt; 模块实现高性能的配置文件分析器。配置文件的语法类似于Windows &lt;code&gt;.ini&lt;/code&gt; 格式，但是功能更强大，因为它不是基于行的解析器。与Nim编程语言一样，支持字符串文字，原始字符串文字和带三引号的字符串文字，这是配置文件的外观示例：</target>
        </trans-unit>
        <trans-unit id="efd64c6ce1f02ecfbb0ad808048c92aad34275ce" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;parsesql&lt;/code&gt; module implements a high performance SQL file parser. It parses PostgreSQL syntax and the SQL ANSI standard.</source>
          <target state="translated">该 &lt;code&gt;parsesql&lt;/code&gt; 模块实现高性能的SQL文件分析器。它解析PostgreSQL语法和SQL ANSI标准。</target>
        </trans-unit>
        <trans-unit id="56d6940c534b2d5fc6c85df625e69961eee4fb6a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;passC&lt;/code&gt; pragma can be used to pass additional parameters to the C compiler like you would using the commandline switch &lt;code&gt;--passC&lt;/code&gt;:</source>
          <target state="translated">所述 &lt;code&gt;passC&lt;/code&gt; 编译指示可用于传递附加参数，以C编译器等你会使用命令行开关 &lt;code&gt;--passC&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="85c8b7f23a56b9ff37dc65de5153a5e24bf44f34" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;passL&lt;/code&gt; pragma can be used to pass additional parameters to the linker like you would using the commandline switch &lt;code&gt;--passL&lt;/code&gt;:</source>
          <target state="translated">该 &lt;code&gt;passL&lt;/code&gt; 编译可用于其他参数传递给连接器就像您使用命令行开关 &lt;code&gt;--passL&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="b3f85014800afa36f3b960f11ad58d019170e999" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;poll&lt;/code&gt; function will not, on its own, return any events. Instead an appropriate &lt;code&gt;Future&lt;/code&gt; object will be completed. A &lt;code&gt;Future&lt;/code&gt; is a type which holds a value which is not yet available, but which &lt;em&gt;may&lt;/em&gt; be available in the future. You can check whether a future is finished by using the &lt;code&gt;finished&lt;/code&gt; function. When a future is finished it means that either the value that it holds is now available or it holds an error instead. The latter situation occurs when the operation to complete a future fails with an exception. You can distinguish between the two situations with the &lt;code&gt;failed&lt;/code&gt; function.</source>
          <target state="translated">该 &lt;code&gt;poll&lt;/code&gt; 功能将不，就其本身而言，返回任何事件。而是将完成一个适当的 &lt;code&gt;Future&lt;/code&gt; 对象。一个 &lt;code&gt;Future&lt;/code&gt; 是保持一个值，该值尚未公布，但一个类型&lt;em&gt;可以&lt;/em&gt;在将来提供。您可以使用 &lt;code&gt;finished&lt;/code&gt; 功能来检查将来是否完成。将来完成时，意味着它持有的值现在可用，或者持有错误。当完成将来的操作失败并发生异常时，会发生后一种情况。您可以使用 &lt;code&gt;failed&lt;/code&gt; 功能来区分这两种情况。</target>
        </trans-unit>
        <trans-unit id="27a7881313cd70143e77c7b574a9601952ffdf78" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pragma&lt;/code&gt; pragma can be used to declare user defined pragmas. This is useful because Nim's templates and macros do not affect pragmas. User defined pragmas are in a different module-wide scope than all other symbols. They cannot be imported from a module.</source>
          <target state="translated">所述 &lt;code&gt;pragma&lt;/code&gt; 编译指示可用于声明用户定义的编译指示。这很有用，因为Nim的模板和宏不会影响编译指示。用户定义的编译指示与所有其他符号不在模块范围内。它们不能从模块导入。</target>
        </trans-unit>
        <trans-unit id="93c3772886433492aac2ca1b4e999a7c892e1968" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;readCfgAtRuntime&lt;/code&gt; proc will open the given filename and return a &lt;code&gt;Table&lt;/code&gt; from the &lt;a href=&quot;tables&quot;&gt;tables module&lt;/a&gt;. The parsing of the file is done (without much care for handling invalid data or corner cases) using the &lt;a href=&quot;strutils#splitLines&quot;&gt;splitLines proc from the strutils module&lt;/a&gt;. There are many things which can fail; mind the purpose is explaining how to make this run at compile time, not how to properly implement a DRM scheme.</source>
          <target state="translated">该 &lt;code&gt;readCfgAtRuntime&lt;/code&gt; PROC将打开指定的文件名，并返回一个 &lt;code&gt;Table&lt;/code&gt; 从&lt;a href=&quot;tables&quot;&gt;表模块&lt;/a&gt;。使用&lt;a href=&quot;strutils#splitLines&quot;&gt;strutils模块中&lt;/a&gt;的splitLines proc来完成文件的解析（无需过多地处理无效数据或极端情况）。有很多事情可能会失败；我的目的是解释如何在编译时运行它，而不是如何正确实施DRM方案。</target>
        </trans-unit>
        <trans-unit id="a044506e0603eea131639eb9376dd6b5cddf2eb3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;register&lt;/code&gt; pragma is for variables only. It declares the variable as &lt;code&gt;register&lt;/code&gt;, giving the compiler a hint that the variable should be placed in a hardware register for faster access. C compilers usually ignore this though and for good reasons: Often they do a better job without it anyway.</source>
          <target state="translated">该 &lt;code&gt;register&lt;/code&gt; 附注仅用于变量。它将变量声明为 &lt;code&gt;register&lt;/code&gt; ，从而向编译器提示该变量应放置在硬件寄存器中以加快访问速度。C编译器通常会忽略这一点，但有充分的理由：不管怎样，他们通常会做得更好。</target>
        </trans-unit>
        <trans-unit id="8e697c97568aeba97089d02acbf3eabde37e8d56" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;result&lt;/code&gt; variable is already implicitly declared at the start of the function, so declaring it again with 'var result', for example, would shadow it with a normal variable of the same name. The result variable is also already initialised with the type's default value. Note that referential data types will be &lt;code&gt;nil&lt;/code&gt; at the start of the procedure, and thus may require manual initialisation.</source>
          <target state="translated">该 &lt;code&gt;result&lt;/code&gt; 变量已经隐含在函数的开始申报，所以用&amp;ldquo;变种结果&amp;rdquo;再次声明它，例如，将具有相同名称的普通变量的影子吧。结果变量也已经使用类型的默认值进行了初始化。请注意，在过程开始时，引用数据类型将 &lt;code&gt;nil&lt;/code&gt; ，因此可能需要手动初始化。</target>
        </trans-unit>
        <trans-unit id="425fcae39b623db5726296d9c803046886d46240" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;return&lt;/code&gt; statement ends the execution of the current procedure. It is only allowed in procedures. If there is an &lt;code&gt;expr&lt;/code&gt;, this is syntactic sugar for:</source>
          <target state="translated">在 &lt;code&gt;return&lt;/code&gt; 语句结束当前程序的执行。仅在过程中允许。如果存在 &lt;code&gt;expr&lt;/code&gt; ，则这是以下语法糖：</target>
        </trans-unit>
        <trans-unit id="22be64c3baaca8bed87e9a59bcd86debbab1977d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;rst2tex&lt;/code&gt; command is invoked identically to &lt;code&gt;rst2html&lt;/code&gt;, but outputs a .tex file instead of .html.</source>
          <target state="translated">该 &lt;code&gt;rst2tex&lt;/code&gt; 命令相同地调用 &lt;code&gt;rst2html&lt;/code&gt; ，但输出.tex文件，而不是html的。</target>
        </trans-unit>
        <trans-unit id="ac1c0e0c744f03f7d86ed6c0e6ccc56589352680" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;scanp&lt;/code&gt; maps the grammar code into Nim code that performs the parsing. The parsing is performed with the help of 3 helper templates that that can be implemented for a custom type.</source>
          <target state="translated">所述 &lt;code&gt;scanp&lt;/code&gt; 映射语法的代码到执行解析稔代码。借助3个可针对自定义类型实现的帮助程序模板来执行解析。</target>
        </trans-unit>
        <trans-unit id="23546f4b46dd4608db4ddbed2703e5c7ee24bec8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;sets&lt;/code&gt; module implements an efficient &lt;span id=&quot;hash-set_1&quot;&gt;hash set&lt;/span&gt; and ordered hash set.</source>
          <target state="translated">该 &lt;code&gt;sets&lt;/code&gt; 模块实现高效的&lt;span id=&quot;hash-set_1&quot;&gt;哈希集合&lt;/span&gt;，并下令哈希集合。</target>
        </trans-unit>
        <trans-unit id="e59337587ab0c8780c2022ab5a55fc7fbccf5729" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;shallow&lt;/code&gt; pragma affects the semantics of a type: The compiler is allowed to make a shallow copy. This can cause serious semantic issues and break memory safety! However, it can speed up assignments considerably, because the semantics of Nim require deep copying of sequences and strings. This can be expensive, especially if sequences are used to build a tree structure:</source>
          <target state="translated">在 &lt;code&gt;shallow&lt;/code&gt; 编译影响类型的语义：编译器允许建立一个浅拷贝。这可能会导致严重的语义问题并破坏内存安全！但是，由于Nim的语义需要深度复制序列和字符串，因此它可以大大加快分配速度。这可能会很昂贵，尤其是如果使用序列来构建树结构时：</target>
        </trans-unit>
        <trans-unit id="5afbb3aa2be881123747a6ecc1beb41e7bc4bafa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;strtabs&lt;/code&gt; module implements an efficient hash table that is a mapping from strings to strings. Supports a case-sensitive, case-insensitive and style-insensitive mode. An efficient string substitution operator &lt;code&gt;%&lt;/code&gt; for the string table is also provided.</source>
          <target state="translated">所述 &lt;code&gt;strtabs&lt;/code&gt; 模块实现一个高效的哈希表，它是从字符串到字符串的映射。支持区分大小写，不区分大小写和不区分样式的模式。还提供了有效的字符串表字符串替换运算符 &lt;code&gt;%&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1bdd9a9646780d7c99c91ba808857d4c209506e0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;sug&lt;/code&gt; Nimsuggest command performs a query about possible completion symbols at some point in the file.</source>
          <target state="translated">的 &lt;code&gt;sug&lt;/code&gt; Nimsuggest命令执行关于在文件中的某些点有可能完成的符号查询。</target>
        </trans-unit>
        <trans-unit id="0ad03b44ad275fed9c4ae098f471d2c17ea38253" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;system&lt;/code&gt; module contains the part of the RTL which needs support by compiler magic (and the stuff that needs to be in it because the spec says so). The C code generator generates the C code for it just like any other module. However, calls to some procedures like &lt;code&gt;addInt&lt;/code&gt; are inserted by the CCG. Therefore the module &lt;code&gt;magicsys&lt;/code&gt; contains a table (&lt;code&gt;compilerprocs&lt;/code&gt;) with all symbols that are marked as &lt;code&gt;compilerproc&lt;/code&gt;. &lt;code&gt;compilerprocs&lt;/code&gt; are needed by the code generator. A &lt;code&gt;magic&lt;/code&gt; proc is not the same as a &lt;code&gt;compilerproc&lt;/code&gt;: A &lt;code&gt;magic&lt;/code&gt; is a proc that needs compiler magic for its semantic checking, a &lt;code&gt;compilerproc&lt;/code&gt; is a proc that is used by the code generator.</source>
          <target state="translated">该 &lt;code&gt;system&lt;/code&gt; 模块包含由编译器魔术（和东西，需要在它，因为规范是这么说的）需要支持的RTL的一部分。 C代码生成器会像其他任何模块一样为其生成C代码。但是，CCG会插入对诸如 &lt;code&gt;addInt&lt;/code&gt; 之类的某些过程的调用。因此，模块 &lt;code&gt;magicsys&lt;/code&gt; 包含一个表（ &lt;code&gt;compilerprocs&lt;/code&gt; 与被标记为所有的符号） &lt;code&gt;compilerproc&lt;/code&gt; 。代码生成 &lt;code&gt;compilerprocs&lt;/code&gt; 需要editorprocs。一个 &lt;code&gt;magic&lt;/code&gt; PROC是不一样的 &lt;code&gt;compilerproc&lt;/code&gt; ：一个 &lt;code&gt;magic&lt;/code&gt; 是一个进程，对于其语义检查需要编译器法宝，一个 &lt;code&gt;compilerproc&lt;/code&gt; 是代码生成器使用的proc。</target>
        </trans-unit>
        <trans-unit id="62ca4c72a3bc5eec2d4c6c1463c200d704c694f7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;system&lt;/code&gt; module defines the important &lt;a href=&quot;system#Natural&quot;&gt;Natural&lt;/a&gt; type as &lt;code&gt;range[0..high(int)]&lt;/code&gt; (&lt;a href=&quot;system#high&quot;&gt;high&lt;/a&gt; returns the maximal value). Other programming languages may suggest the use of unsigned integers for natural numbers. This is often &lt;strong&gt;unwise&lt;/strong&gt;: you don't want unsigned arithmetic (which wraps around) just because the numbers cannot be negative. Nim's &lt;code&gt;Natural&lt;/code&gt; type helps to avoid this common programming error.</source>
          <target state="translated">该 &lt;code&gt;system&lt;/code&gt; 模块定义的重要&lt;a href=&quot;system#Natural&quot;&gt;天然&lt;/a&gt;类型为 &lt;code&gt;range[0..high(int)]&lt;/code&gt; （&lt;a href=&quot;system#high&quot;&gt;高&lt;/a&gt;回报最大值）。其他编程语言可能建议对自然数使用无符号整数。这通常是&lt;strong&gt;不明智的&lt;/strong&gt;：仅仅因为数字不能为负数，就不需要无符号算术（环绕）。Nim的 &lt;code&gt;Natural&lt;/code&gt; 类型有助于避免这种常见的编程错误。</target>
        </trans-unit>
        <trans-unit id="14dc5a05b6b245cb0be25c1bbcfb8cbd3c4b9fb8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;tables&lt;/code&gt; module implements variants of an efficient &lt;span id=&quot;hash-table_1&quot;&gt;hash table&lt;/span&gt; (also often named &lt;span id=&quot;dictionary_1&quot;&gt;dictionary&lt;/span&gt; in other programming languages) that is a mapping from keys to values. &lt;code&gt;Table&lt;/code&gt; is the usual hash table, &lt;code&gt;OrderedTable&lt;/code&gt; is like &lt;code&gt;Table&lt;/code&gt; but remembers insertion order and &lt;code&gt;CountTable&lt;/code&gt; is a mapping from a key to its number of occurrences. For consistency with every other data type in Nim these have &lt;strong&gt;value&lt;/strong&gt; semantics, this means that &lt;code&gt;=&lt;/code&gt; performs a copy of the hash table. For &lt;strong&gt;reference&lt;/strong&gt; semantics use the &lt;code&gt;Ref&lt;/code&gt; variant: &lt;code&gt;TableRef&lt;/code&gt;, &lt;code&gt;OrderedTableRef&lt;/code&gt;, &lt;code&gt;CountTableRef&lt;/code&gt;. To give an example, when &lt;em&gt;a&lt;/em&gt; is a Table, then &lt;em&gt;var b = a&lt;/em&gt; gives &lt;em&gt;b&lt;/em&gt; as a new independent table. b is initialised with the contents of &lt;em&gt;a&lt;/em&gt;. Changing &lt;em&gt;b&lt;/em&gt; does not affect &lt;em&gt;a&lt;/em&gt; and vice versa:</source>
          <target state="translated">该 &lt;code&gt;tables&lt;/code&gt; 的有效的模块实现变体&lt;span id=&quot;hash-table_1&quot;&gt;哈希表&lt;/span&gt;（也通常命名为&lt;span id=&quot;dictionary_1&quot;&gt;字典&lt;/span&gt;在其他编程语言），其从键到值的映射。 &lt;code&gt;Table&lt;/code&gt; 是通常的哈希表， &lt;code&gt;OrderedTable&lt;/code&gt; 类似于 &lt;code&gt;Table&lt;/code&gt; ,但是记住插入顺序，而 &lt;code&gt;CountTable&lt;/code&gt; 是从键到其出现次数的映射。为了与Nim中的所有其他数据类型保持一致，它们具有&lt;strong&gt;值&lt;/strong&gt;语义，这意味着 &lt;code&gt;=&lt;/code&gt; 将执行哈希表的副本。对于&lt;strong&gt;参考&lt;/strong&gt;语义，请使用 &lt;code&gt;Ref&lt;/code&gt; 变体： &lt;code&gt;TableRef&lt;/code&gt; ， &lt;code&gt;OrderedTableRef&lt;/code&gt; ， &lt;code&gt;CountTableRef&lt;/code&gt; 。举一个例子，当&lt;em&gt;a&lt;/em&gt;是一个表时，则&lt;em&gt;var b = a&lt;/em&gt;给出&lt;em&gt;b&lt;/em&gt;作为新的独立表。b的初始化用的内容&lt;em&gt;一个&lt;/em&gt;。更改&lt;em&gt;b&lt;/em&gt;不会影响&lt;em&gt;a&lt;/em&gt;，反之亦然：</target>
        </trans-unit>
        <trans-unit id="56ae4324ab0abf484cafe035da581771b6411aae" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;timeout&lt;/code&gt; argument specifies the maximum number of milliseconds the function will be blocked for if no events are ready. Specifying a timeout of &lt;code&gt;-1&lt;/code&gt; causes the function to block indefinitely.</source>
          <target state="translated">该 &lt;code&gt;timeout&lt;/code&gt; 参数指定毫秒的功能将被阻止，如果没有事件准备的最大数量。将超时指定为 &lt;code&gt;-1&lt;/code&gt; 将导致该函数无限期地阻塞。</target>
        </trans-unit>
        <trans-unit id="d431b3c8673538504427a8309f89779fe91091e0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;timeout&lt;/code&gt; argument specifies the maximum number of milliseconds the function will be blocked for if no events are ready. Specifying a timeout of &lt;code&gt;-1&lt;/code&gt; causes the function to block indefinitely. All available events will be stored in &lt;code&gt;results&lt;/code&gt; array.</source>
          <target state="translated">该 &lt;code&gt;timeout&lt;/code&gt; 参数指定毫秒的功能将被阻止，如果没有事件准备的最大数量。将超时指定为 &lt;code&gt;-1&lt;/code&gt; 将导致该函数无限期地阻塞。所有可用事件将存储在 &lt;code&gt;results&lt;/code&gt; 数组中。</target>
        </trans-unit>
        <trans-unit id="d8dfd6109dacde12070a0913015e494bbf03c02d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;timeout&lt;/code&gt; paremeter specifies the time in milliseconds to allow for the connection to the server to be made.</source>
          <target state="translated">该 &lt;code&gt;timeout&lt;/code&gt; 要进行paremeter单位为毫秒的时间以允许连接到服务器上。</target>
        </trans-unit>
        <trans-unit id="f2168e89685d500f34305fadd8a799ea9837bc0b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;try&lt;/code&gt; statement handles exceptions:</source>
          <target state="translated">在 &lt;code&gt;try&lt;/code&gt; 语句处理异常：</target>
        </trans-unit>
        <trans-unit id="ec7d06e028291e266b3574501a3bbca632d71df1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;unchecked&lt;/code&gt; pragma can be used to mark a named array as &lt;code&gt;unchecked&lt;/code&gt; meaning its bounds are not checked. This is often useful to implement customized flexibly sized arrays. Additionally an unchecked array is translated into a C array of undetermined size:</source>
          <target state="translated">在 &lt;code&gt;unchecked&lt;/code&gt; 编译，可以用来标记命名的数组作为 &lt;code&gt;unchecked&lt;/code&gt; 的意义它的界限，不检查。这对于实现定制的灵活大小的数组通常很有用。此外，未经检查的数组将转换为大小不确定的C数组：</target>
        </trans-unit>
        <trans-unit id="c94b76defb11868b1ae8894e3bb63b7d8285f9f9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;union&lt;/code&gt; pragma can be applied to any &lt;code&gt;object&lt;/code&gt; type. It means all of the object's fields are overlaid in memory. This produces a &lt;code&gt;union&lt;/code&gt; instead of a &lt;code&gt;struct&lt;/code&gt; in the generated C/C++ code. The object declaration then must not use inheritance or any GC'ed memory but this is currently not checked.</source>
          <target state="translated">该 &lt;code&gt;union&lt;/code&gt; 编译可应用于任何 &lt;code&gt;object&lt;/code&gt; 类型。这意味着该对象的所有字段都覆盖在内存中。这将在生成的C / C ++代码中产生 &lt;code&gt;union&lt;/code&gt; 而不是 &lt;code&gt;struct&lt;/code&gt; 。这样，对象声明一定不能使用继承或任何GC的内存，但是当前不检查。</target>
        </trans-unit>
        <trans-unit id="5512388758e298c4c26f4a165b06bea0eae327c0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;unroll&lt;/code&gt; pragma can be used to tell the compiler that it should unroll a &lt;span id=&quot;for_2&quot;&gt;for&lt;/span&gt; or &lt;span id=&quot;while_1&quot;&gt;while&lt;/span&gt; loop for runtime efficiency:</source>
          <target state="translated">该 &lt;code&gt;unroll&lt;/code&gt; 编译可以用来告诉编译器，它应该展开一个&lt;span id=&quot;for_2&quot;&gt;对&lt;/span&gt;或&lt;span id=&quot;while_1&quot;&gt;同时&lt;/span&gt;循环运行时的效率：</target>
        </trans-unit>
        <trans-unit id="965b5f72fd2186e49462ff5ed9043780f9e1cb58" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;use&lt;/code&gt; Nimsuggest command lists all usages of the symbol at a position. IDEs can use this to find all the places in the file where the symbol is used and offer the user to rename it in all places at the same time.</source>
          <target state="translated">在 &lt;code&gt;use&lt;/code&gt; Nimsuggest命令列出了一个位置符号的所有用途。IDE可以使用它查找文件中使用符号的所有位置，并向用户提供同时在所有位置对其进行重命名的功能。</target>
        </trans-unit>
        <trans-unit id="bded0ec11c200a51a4e6475dbab31e4355ab12d4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;using&lt;/code&gt; section uses the same indentation based grouping syntax as a &lt;code&gt;var&lt;/code&gt; or &lt;code&gt;let&lt;/code&gt; section.</source>
          <target state="translated">在 &lt;code&gt;using&lt;/code&gt; 部分使用基于分组的语法为相同的缩进 &lt;code&gt;var&lt;/code&gt; 或 &lt;code&gt;let&lt;/code&gt; 部分。</target>
        </trans-unit>
        <trans-unit id="cf32e53e4609c5f4cde4e84fe336750a3c4a317a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;varargs&lt;/code&gt; pragma can be applied to procedures only (and procedure types). It tells Nim that the proc can take a variable number of parameters after the last specified parameter. Nim string values will be converted to C strings automatically:</source>
          <target state="translated">所述 &lt;code&gt;varargs&lt;/code&gt; 编译可应用于仅程序（和程序类型）。它告诉Nim，该proc可以在最后指定的参数之后接受可变数量的参数。Nim字符串值将自动转换为C字符串：</target>
        </trans-unit>
        <trans-unit id="fac4b56c328a62775e81f815e78bd26e59b4f4d3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;void&lt;/code&gt; type denotes the absence of any type. Parameters of type &lt;code&gt;void&lt;/code&gt; are treated as non-existent, &lt;code&gt;void&lt;/code&gt; as a return type means that the procedure does not return a value:</source>
          <target state="translated">的 &lt;code&gt;void&lt;/code&gt; 类型表示不存在任何类型的。 &lt;code&gt;void&lt;/code&gt; 类型的参数被视为不存在， &lt;code&gt;void&lt;/code&gt; 作为返回类型意味着该过程不返回值：</target>
        </trans-unit>
        <trans-unit id="d54f05d7805d3d20206628828c5a46105e33e791" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;void&lt;/code&gt; type is only valid for parameters and return types; other symbols cannot have the type &lt;code&gt;void&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;void&lt;/code&gt; 类型仅适用于参数和返回类型; 其他符号的类型不能为 &lt;code&gt;void&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="11d46bfe15b6bb594dd4d7b4f9ac119c89f36e71" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;void&lt;/code&gt; type is particularly useful for generic code:</source>
          <target state="translated">的 &lt;code&gt;void&lt;/code&gt; 类型是通用代码是特别有用的：</target>
        </trans-unit>
        <trans-unit id="9d170c08bbf58e946b9ec8840f5556c7094bc2b2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;volatile&lt;/code&gt; pragma is for variables only. It declares the variable as &lt;code&gt;volatile&lt;/code&gt;, whatever that means in C/C++ (its semantics are not well defined in C/C++).</source>
          <target state="translated">该 &lt;code&gt;volatile&lt;/code&gt; 附注仅用于变量。它将变量声明为 &lt;code&gt;volatile&lt;/code&gt; ，无论在C / C ++中意味着什么（在C / C ++中其语义都没有很好地定义）。</target>
        </trans-unit>
        <trans-unit id="45f140f4f01fe1213690fb05d3fda0c6d1fe6699" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;warning&lt;/code&gt; pragma is used to make the compiler output a warning message with the given content. Compilation continues after the warning.</source>
          <target state="translated">该 &lt;code&gt;warning&lt;/code&gt; 编译用于使编译器输出给定内容的警告消息。警告后继续编译。</target>
        </trans-unit>
        <trans-unit id="9509e80840bb0f1df308f8032f3bb053eea5da51" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;when&lt;/code&gt; statement enables conditional compilation techniques. As a special syntactic extension, the &lt;code&gt;when&lt;/code&gt; construct is also available within &lt;code&gt;object&lt;/code&gt; definitions.</source>
          <target state="translated">在 &lt;code&gt;when&lt;/code&gt; 语句使条件编译技术。作为特殊的语法扩展，在 &lt;code&gt;object&lt;/code&gt; 定义中还可以使用 &lt;code&gt;when&lt;/code&gt; 构造。</target>
        </trans-unit>
        <trans-unit id="3923b0ea614af5c8a6acc8fd050a8e60d9177947" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;when&lt;/code&gt; statement is almost identical to the &lt;code&gt;if&lt;/code&gt; statement with some exceptions:</source>
          <target state="translated">在 &lt;code&gt;when&lt;/code&gt; 语句是几乎相同的 &lt;code&gt;if&lt;/code&gt; 有一些例外的声明：</target>
        </trans-unit>
        <trans-unit id="238308d0a093ac5ec92a1fb377ed60fb2c7f5746" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;when&lt;/code&gt; statement is almost identical to the &lt;code&gt;if&lt;/code&gt; statement, but with these differences:</source>
          <target state="translated">在 &lt;code&gt;when&lt;/code&gt; 语句是几乎相同的 &lt;code&gt;if&lt;/code&gt; 声明，但有以下差异：</target>
        </trans-unit>
        <trans-unit id="57d001b8d7b1eb7efa8f75e5bfa898d7953ff6a1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;when&lt;/code&gt; statement is useful for writing platform specific code, similar to the &lt;code&gt;#ifdef&lt;/code&gt; construct in the C programming language.</source>
          <target state="translated">该 &lt;code&gt;when&lt;/code&gt; 声明是编写平台特定的代码，类似有用 &lt;code&gt;#ifdef&lt;/code&gt; 在C编程语言构造。</target>
        </trans-unit>
        <trans-unit id="3ed2216fef6cefddc51b5dfc1501acbc63519752" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;while&lt;/code&gt; statement is executed until the &lt;code&gt;expr&lt;/code&gt; evaluates to false. Endless loops are no error. &lt;code&gt;while&lt;/code&gt; statements open an &lt;em&gt;implicit block&lt;/em&gt;, so that they can be left with a &lt;code&gt;break&lt;/code&gt; statement.</source>
          <target state="translated">在 &lt;code&gt;while&lt;/code&gt; 语句执行，直到 &lt;code&gt;expr&lt;/code&gt; 的计算结果为假。无休止的循环没有错误。 &lt;code&gt;while&lt;/code&gt; 语句打开一个&lt;em&gt;隐式块&lt;/em&gt;，以便可以将其与 &lt;code&gt;break&lt;/code&gt; 语句一起使用。</target>
        </trans-unit>
        <trans-unit id="77e5c5d6d627aa54296b3870cd7922006782e15e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;yield&lt;/code&gt; statement is used instead of the &lt;code&gt;return&lt;/code&gt; statement in iterators. It is only valid in iterators. Execution is returned to the body of the for loop that called the iterator. Yield does not end the iteration process, but execution is passed back to the iterator if the next iteration starts. See the section about iterators (&lt;a href=&quot;#iterators-and-the-for-statement&quot;&gt;Iterators and the for statement&lt;/a&gt;) for further information.</source>
          <target state="translated">该 &lt;code&gt;yield&lt;/code&gt; 语句用来代替 &lt;code&gt;return&lt;/code&gt; 迭代器声明。它仅在迭代器中有效。执行将返回到称为迭代器的for循环的主体。Yield不会结束迭代过程，但是如果下一次迭代开始，则执行将传递回迭代器。有关更多信息，请参见有关迭代器的部分（&lt;a href=&quot;#iterators-and-the-for-statement&quot;&gt;Iterators和for语句&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="0694f678da714119225cabbbd0654c71587ddfa4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;{}&lt;/code&gt; operator</source>
          <target state="translated">该 &lt;code&gt;{}&lt;/code&gt; 运营商</target>
        </trans-unit>
        <trans-unit id="1201154eaa53a6a08247d7a1f878b08cbcc71415" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;|&lt;/code&gt; operator</source>
          <target state="translated">该 &lt;code&gt;|&lt;/code&gt; 算子</target>
        </trans-unit>
        <trans-unit id="7b0bf905e381cc04d13b47c0b5b03f3639bd78ee" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;|&lt;/code&gt; operator if used as infix operator creates an ordered choice:</source>
          <target state="translated">该 &lt;code&gt;|&lt;/code&gt; 运算符（如果用作infix运算符）将创建有序选择：</target>
        </trans-unit>
        <trans-unit id="64228bf590558ad4fc967418a6eab8c95681462e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;|&lt;/code&gt;, &lt;code&gt;/&lt;/code&gt; symbols are used to mark alternatives and have the lowest precedence. &lt;code&gt;/&lt;/code&gt; is the ordered choice that requires the parser to try the alternatives in the given order. &lt;code&gt;/&lt;/code&gt; is often used to ensure the grammar is not ambiguous.</source>
          <target state="translated">该 &lt;code&gt;|&lt;/code&gt; ， &lt;code&gt;/&lt;/code&gt; 符号用于标记替代项，并且优先级最低。 &lt;code&gt;/&lt;/code&gt; 是有序选择，需要解析器按给定顺序尝试替代项。 &lt;code&gt;/&lt;/code&gt; 通常用于确保语法不模糊。</target>
        </trans-unit>
        <trans-unit id="c06e1a048dfb09f151ad6af04b4cc2cbab7ce373" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;~&lt;/code&gt; operator</source>
          <target state="translated">在 &lt;code&gt;~&lt;/code&gt; 运营商</target>
        </trans-unit>
        <trans-unit id="9856d0d900d79fc607cd6848700f2bafec366603" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;~&lt;/code&gt; operator is the &lt;strong&gt;not&lt;/strong&gt; operator in patterns:</source>
          <target state="translated">该 &lt;code&gt;~&lt;/code&gt; 运营商是&lt;strong&gt;不是&lt;/strong&gt;在模式操作：</target>
        </trans-unit>
        <trans-unit id="6edb4e4054e37bf60483392193b7ad3441d67ddf" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;$&lt;/em&gt; operator for count tables.</source>
          <target state="translated">计数表的&lt;em&gt;$&lt;/em&gt;运算符。</target>
        </trans-unit>
        <trans-unit id="8c6a817abf878b263302b528ba9eba150a0b5e4f" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;$&lt;/em&gt; operator for hash tables.</source>
          <target state="translated">哈希表的&lt;em&gt;$&lt;/em&gt;运算符。</target>
        </trans-unit>
        <trans-unit id="21210e15f2beb096edd05ccec6e1b9573b666a36" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;$&lt;/em&gt; operator for int sets.</source>
          <target state="translated">整数集的&lt;em&gt;$&lt;/em&gt;运算符。</target>
        </trans-unit>
        <trans-unit id="6d5e46312d92579508d6c9ed937fbbd4c1df3a3a" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;$&lt;/em&gt; operator for ordered hash tables.</source>
          <target state="translated">有序哈希表的&lt;em&gt;$&lt;/em&gt;运算符。</target>
        </trans-unit>
        <trans-unit id="9eea65ebe90881c4414538083cd97f3fc9aef8d6" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;$&lt;/em&gt; operator for string tables.</source>
          <target state="translated">字符串表的&lt;em&gt;$&lt;/em&gt;运算符。</target>
        </trans-unit>
        <trans-unit id="1a84d3734edf137dc85d74d27bc8c4eec4e9620e" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;%&lt;/em&gt; operator for string tables.</source>
          <target state="translated">字符串表的&lt;em&gt;％&lt;/em&gt;运算符。</target>
        </trans-unit>
        <trans-unit id="42fb88e76a89671075d6dad00a270f10b9b6f1ed" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;==&lt;/em&gt; operator for count tables. Returns &lt;code&gt;true&lt;/code&gt; iff both tables contain the same keys with the same count. Insert order does not matter.</source>
          <target state="translated">计数表的&lt;em&gt;==&lt;/em&gt;运算符。如果两个表包含具有相同计数的相同键，则返回 &lt;code&gt;true&lt;/code&gt; 。插入顺序无关紧要。</target>
        </trans-unit>
        <trans-unit id="f3c437f641f31ef6a98cac2a696fbef8b9e8bc19" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;==&lt;/em&gt; operator for count tables. Returns &lt;code&gt;true&lt;/code&gt; iff either both tables are &lt;code&gt;nil&lt;/code&gt; or none is &lt;code&gt;nil&lt;/code&gt; and both contain the same keys with the same count. Insert order does not matter.</source>
          <target state="translated">计数表的&lt;em&gt;==&lt;/em&gt;运算符。如果两个表均为 &lt;code&gt;nil&lt;/code&gt; 或none为 &lt;code&gt;nil&lt;/code&gt; 并且都包含具有相同计数的相同键，则返回 &lt;code&gt;true&lt;/code&gt; 。插入顺序无关紧要。</target>
        </trans-unit>
        <trans-unit id="65caa9363c9c4bee80ce44c109b6388268b58a9e" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;==&lt;/em&gt; operator for hash tables. Returns &lt;code&gt;true&lt;/code&gt; iff either both tables are &lt;code&gt;nil&lt;/code&gt; or none is &lt;code&gt;nil&lt;/code&gt; and the content of both tables contains the same key-value pairs. Insert order does not matter.</source>
          <target state="translated">哈希表的&lt;em&gt;==&lt;/em&gt;运算符。如果两个表均为 &lt;code&gt;nil&lt;/code&gt; 或none为 &lt;code&gt;nil&lt;/code&gt; 并且两个表的内容包含相同的键值对，则返回 &lt;code&gt;true&lt;/code&gt; 。插入顺序无关紧要。</target>
        </trans-unit>
        <trans-unit id="ecfa374c36b6bffd18a0ef6cce629ecea93ec8e1" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;==&lt;/em&gt; operator for hash tables. Returns &lt;code&gt;true&lt;/code&gt; iff the content of both tables contains the same key-value pairs. Insert order does not matter.</source>
          <target state="translated">哈希表的&lt;em&gt;==&lt;/em&gt;运算符。如果两个表的内容包含相同的键值对，则返回 &lt;code&gt;true&lt;/code&gt; 。插入顺序无关紧要。</target>
        </trans-unit>
        <trans-unit id="eadaefcf55fb6edbf3abdf3db98fb0843d048aaf" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;==&lt;/em&gt; operator for ordered hash tables. Returns true iff both the content and the order are equal.</source>
          <target state="translated">有序哈希表的&lt;em&gt;==&lt;/em&gt;运算符。如果内容和顺序相等，则返回true。</target>
        </trans-unit>
        <trans-unit id="8914eb62f26e75052b45d57bea0bc85c1277e2e4" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;==&lt;/em&gt; operator for ordered hash tables. Returns true iff either both tables are &lt;code&gt;nil&lt;/code&gt; or none is &lt;code&gt;nil&lt;/code&gt; and the content and the order of both are equal.</source>
          <target state="translated">有序哈希表的&lt;em&gt;==&lt;/em&gt;运算符。如果两个表均为 &lt;code&gt;nil&lt;/code&gt; 或none为 &lt;code&gt;nil&lt;/code&gt; 并且两者的内容和顺序相等，则返回true 。</target>
        </trans-unit>
        <trans-unit id="4d36127144c35e196b74a69bb0dd19d7650ca3b4" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;Nim compiler&lt;/em&gt; also has support for RST (reStructuredText) files with the &lt;code&gt;rst2html&lt;/code&gt; and &lt;code&gt;rst2tex&lt;/code&gt; commands. Documents like this one are initially written in a dialect of RST which adds support for nim sourcecode highlighting with the &lt;code&gt;.. code-block:: nim&lt;/code&gt; prefix. &lt;code&gt;code-block&lt;/code&gt; also supports highlighting of C++ and some other c-like languages.</source>
          <target state="translated">该&lt;em&gt;稔编译器&lt;/em&gt;还具有与RST（新结构化）文件的支持 &lt;code&gt;rst2html&lt;/code&gt; 和 &lt;code&gt;rst2tex&lt;/code&gt; 命令。像这样的文档最初是用RST方言编写的，它以 &lt;code&gt;.. code-block:: nim&lt;/code&gt; 前缀添加了对nim源代码突出显示的支持。 &lt;code&gt;code-block&lt;/code&gt; 还支持突出显示C ++和其他一些类似c的语言。</target>
        </trans-unit>
        <trans-unit id="64b9df197c2acb72edd07ad4070f99730861f242" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;case expression&lt;/em&gt; is again very similar to the case statement:</source>
          <target state="translated">的&lt;em&gt;情况下表达&lt;/em&gt;又是非常相似的case语句：</target>
        </trans-unit>
        <trans-unit id="dd1e3926f728dc35f509a5bf9e5f4dad82e16ce3" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;character type&lt;/em&gt; is called &lt;code&gt;char&lt;/code&gt;. Its size is always one byte, so it cannot represent most UTF-8 characters; but it &lt;em&gt;can&lt;/em&gt; represent one of the bytes that makes up a multi-byte UTF-8 character. The reason for this is efficiency: for the overwhelming majority of use-cases, the resulting programs will still handle UTF-8 properly as UTF-8 was specially designed for this. Character literals are enclosed in single quotes.</source>
          <target state="translated">该&lt;em&gt;字符类型&lt;/em&gt;被称为 &lt;code&gt;char&lt;/code&gt; 。它的大小始终为一个字节，因此不能表示大多数UTF-8字符；但它&lt;em&gt;可以&lt;/em&gt;代表组成多字节UTF-8字符的字节之一。原因是效率：在绝大多数用例中，生成的程序仍将正确处理UTF-8，因为UTF-8是为此专门设计的。字符文字用单引号引起来。</target>
        </trans-unit>
        <trans-unit id="71d5db35b5bd11b522d53f5b565bc1dd579987f8" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;filename&lt;/em&gt; parameter will be used for error reporting and creating index hyperlinks to the file, but you can pass an empty string here if you are parsing a stream in memory. If &lt;em&gt;filename&lt;/em&gt; ends with the &lt;code&gt;.nim&lt;/code&gt; extension, the title for the document will be set by default to &lt;code&gt;Module filename&lt;/code&gt;. This default title can be overriden by the embedded rst, but it helps to prettify the generated index if no title is found.</source>
          <target state="translated">该&lt;em&gt;文件名&lt;/em&gt;参数将被用于错误报告和创建索引超链接到文件，但你可以，如果你正在分析在内存中的数据流在这里传递一个空字符串。如果&lt;em&gt;filename&lt;/em&gt;以 &lt;code&gt;.nim&lt;/code&gt; 扩展&lt;em&gt;名&lt;/em&gt;结尾，则文档的标题将默认设置为 &lt;code&gt;Module filename&lt;/code&gt; 。嵌入的rst可以覆盖此默认标题，但是如果找不到标题，则可以帮助美化生成的索引。</target>
        </trans-unit>
        <trans-unit id="edbaae9f7ab66a5f097fb8ddd27afa919150b133" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;handlers&lt;/em&gt; parameter consists of code blocks for &lt;em&gt;PegKinds&lt;/em&gt;, which define the grammar elements of interest. Each block can contain handler code to be executed when the parser enters and leaves text matching the grammar element. An &lt;em&gt;enter&lt;/em&gt; handler can access the specific PEG AST node being matched as &lt;em&gt;p&lt;/em&gt;, the entire parsed string as &lt;em&gt;s&lt;/em&gt; and the position of the matched text segment in &lt;em&gt;s&lt;/em&gt; as &lt;em&gt;start&lt;/em&gt;. A &lt;em&gt;leave&lt;/em&gt; handler can access &lt;em&gt;p&lt;/em&gt;, &lt;em&gt;s&lt;/em&gt;, &lt;em&gt;start&lt;/em&gt; and also the length of the matched text segment as &lt;em&gt;length&lt;/em&gt;. For an unsuccessful match, the &lt;em&gt;enter&lt;/em&gt; and &lt;em&gt;leave&lt;/em&gt; handlers will be executed, with &lt;em&gt;length&lt;/em&gt; set to -1.</source>
          <target state="translated">的&lt;em&gt;处理程序&lt;/em&gt;参数由码块的&lt;em&gt;PegKinds&lt;/em&gt;，定义感兴趣的语法元素。每个块都可以包含在解析器输入并留下与语法元素匹配的文本时要执行的处理程序代码。一个&lt;em&gt;输入&lt;/em&gt;处理程序可以访问该特定的PEG AST节点被匹配为&lt;em&gt;p&lt;/em&gt;，则整个解析的字符串作为&lt;em&gt;小号&lt;/em&gt;和匹配的文本段中的位置&lt;em&gt;小号&lt;/em&gt;作为&lt;em&gt;开始&lt;/em&gt;。一个&lt;em&gt;假&lt;/em&gt;处理程序可以访问&lt;em&gt;p&lt;/em&gt;，&lt;em&gt;小号&lt;/em&gt;，&lt;em&gt;开始&lt;/em&gt;也是匹配的文本段的长度&lt;em&gt;长&lt;/em&gt;。对于不成功的比赛，&lt;em&gt;输入&lt;/em&gt;和&lt;em&gt;离开&lt;/em&gt;处理程序将被执行，&lt;em&gt;长度&lt;/em&gt;设置为-1。</target>
        </trans-unit>
        <trans-unit id="64386956b3c73085d6328c9f138a7d8052469400" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;id&lt;/em&gt; will be appended with a hash character only if its length is not zero, otherwise no specific anchor will be generated. In general you should only pass an empty &lt;em&gt;id&lt;/em&gt; value for the title of standalone rst documents (they are special for the &lt;a href=&quot;#mergeIndexes&quot;&gt;mergeIndexes()&lt;/a&gt; proc, see &lt;a href=&quot;docgen#index-idx-file-format&quot;&gt;Index (idx) file format&lt;/a&gt; for more information). Unlike other index terms, title entries are inserted at the beginning of the accumulated buffer to maintain a logical order of entries.</source>
          <target state="translated">该&lt;em&gt;ID&lt;/em&gt;将与散列字符被附加仅当它的长度不为零，否则没有具体的锚将生成。通常，只应为独立的第一个文档的标题传递一个空的&lt;em&gt;id&lt;/em&gt;值（它们对于&lt;a href=&quot;#mergeIndexes&quot;&gt;mergeIndexes（）&lt;/a&gt; proc 是特殊的，有关更多信息，请参见&lt;a href=&quot;docgen#index-idx-file-format&quot;&gt;Index（idx）文件格式&lt;/a&gt;）。与其他索引项不同，标题条目会插入累积缓冲区的开头，以保持条目的逻辑顺序。</target>
        </trans-unit>
        <trans-unit id="e7bcea88e9b3afcedaf4fe86c7903aad3e98b4fa" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;initialSize&lt;/em&gt; parameter needs to be a power of two. You can use &lt;a href=&quot;math#nextPowerOfTwo&quot;&gt;math.nextPowerOfTwo()&lt;/a&gt; or &lt;em&gt;rightSize&lt;/em&gt; to guarantee that at runtime. All set variables must be initialized before use with other procs from this module with the exception of &lt;a href=&quot;#isValid,TOrderedSet%5BA%5D&quot;&gt;isValid()&lt;/a&gt; and &lt;a href=&quot;#len,TOrderedSet%5BA%5D&quot;&gt;len()&lt;/a&gt;.</source>
          <target state="translated">该&lt;em&gt;INITIALSIZE&lt;/em&gt;参数需要两个电源。您可以使用&lt;a href=&quot;math#nextPowerOfTwo&quot;&gt;math.nextPowerOfTwo（）&lt;/a&gt;或&lt;em&gt;rightSize&lt;/em&gt;来保证在运行时实现这一点。除&lt;a href=&quot;#isValid,TOrderedSet%5BA%5D&quot;&gt;isValid（）&lt;/a&gt;和&lt;a href=&quot;#len,TOrderedSet%5BA%5D&quot;&gt;len（）&lt;/a&gt;外，所有设置变量都必须在与该模块的其他proc一起使用之前进行初始化。</target>
        </trans-unit>
        <trans-unit id="e595993e5c058be0e84afb91215737952ff662f5" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;initialSize&lt;/em&gt; parameter needs to be a power of two. You can use &lt;a href=&quot;math#nextPowerOfTwo&quot;&gt;math.nextPowerOfTwo()&lt;/a&gt; or &lt;em&gt;rightSize&lt;/em&gt; to guarantee that at runtime. All set variables must be initialized before use with other procs from this module with the exception of &lt;a href=&quot;#isValid,TSet%5BA%5D&quot;&gt;isValid()&lt;/a&gt; and &lt;a href=&quot;#len,TSet%5BA%5D&quot;&gt;len()&lt;/a&gt;.</source>
          <target state="translated">该&lt;em&gt;INITIALSIZE&lt;/em&gt;参数需要两个电源。您可以使用&lt;a href=&quot;math#nextPowerOfTwo&quot;&gt;math.nextPowerOfTwo（）&lt;/a&gt;或&lt;em&gt;rightSize&lt;/em&gt;来保证在运行时实现这一点。除&lt;a href=&quot;#isValid,TSet%5BA%5D&quot;&gt;isValid（）&lt;/a&gt;和&lt;a href=&quot;#len,TSet%5BA%5D&quot;&gt;len（）&lt;/a&gt;外，所有设置变量都必须在与该模块的其他proc一起使用之前进行初始化。</target>
        </trans-unit>
        <trans-unit id="7c214c728d4121535b4b7a34f396ea719117cb4d" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;scope&lt;/em&gt; of a variable declared in the declaration part of a block is valid from the point of declaration until the end of the block. If a block contains a second block, in which the identifier is redeclared, then inside this block, the second declaration will be valid. Upon leaving the inner block, the first declaration is valid again. An identifier cannot be redefined in the same block, except if valid for procedure or iterator overloading purposes.</source>
          <target state="translated">在块的声明部分声明的变量的&lt;em&gt;范围&lt;/em&gt;从声明点到块结束均有效。如果一个块包含第二个块，在该块中重新声明了标识符，则在该块内部，第二个声明将有效。离开内部块后，第一个声明再次有效。除非在过程或迭代器重载目的上有效，否则不能在同一块中重新定义标识符。</target>
        </trans-unit>
        <trans-unit id="31957fd1dab3297b9650262294cc9e647a86c978" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;sloppy interfacing&lt;/em&gt; example uses &lt;code&gt;.emit&lt;/code&gt; to produce &lt;code&gt;using namespace&lt;/code&gt; declarations. It is usually much better to instead refer to the imported name via the &lt;code&gt;namespace::identifier&lt;/code&gt; notation:</source>
          <target state="translated">的&lt;em&gt;稀松接口&lt;/em&gt;示例用途 &lt;code&gt;.emit&lt;/code&gt; 以产生 &lt;code&gt;using namespace&lt;/code&gt; 声明。通常最好通过 &lt;code&gt;namespace::identifier&lt;/code&gt; 表示法引用导入的名称：</target>
        </trans-unit>
        <trans-unit id="ea5cdc44b88b5634c8f912a49a8f74da86b5d738" translate="yes" xml:space="preserve">
          <source>The &lt;span id=&quot;backslash_1&quot;&gt;backslash&lt;/span&gt; character has several uses. Firstly, if it is followed by a non-alphanumeric character, it takes away any special meaning that character may have. This use of backslash as an escape character applies both inside and outside character classes.</source>
          <target state="translated">该&lt;span id=&quot;backslash_1&quot;&gt;反斜杠&lt;/span&gt;字符有几种用途。首先，如果其后跟非字母数字字符，则它将删除该字符可能具有的任何特殊含义。反斜杠作为转义字符的这种用法适用于内部字符类和外部字符类。</target>
        </trans-unit>
        <trans-unit id="b06b473e1ee1762f517fd6999bd07dece354bc29" translate="yes" xml:space="preserve">
          <source>The &lt;span id=&quot;boot_1&quot;&gt;boot&lt;/span&gt; command bootstraps the compiler, and it accepts different options:</source>
          <target state="translated">在&lt;span id=&quot;boot_1&quot;&gt;启动&lt;/span&gt;命令引导了编译器，它接受不同的选项：</target>
        </trans-unit>
        <trans-unit id="fe5c377ca282280b9863d88ec5a8f55bcf5f2255" translate="yes" xml:space="preserve">
          <source>The &lt;span id=&quot;csource_1&quot;&gt;csource&lt;/span&gt; command builds the C sources for installation. It accepts the same options as you would pass to the &lt;a href=&quot;#boot-command&quot;&gt;boot command&lt;/a&gt;.</source>
          <target state="translated">所述&lt;span id=&quot;csource_1&quot;&gt;csource&lt;/span&gt;命令构建用于安装的碳源。它接受与传递给&lt;a href=&quot;#boot-command&quot;&gt;boot命令&lt;/a&gt;相同的选项。</target>
        </trans-unit>
        <trans-unit id="debca29a7a9e313a0d076cc0661ed876f0ad8d69" translate="yes" xml:space="preserve">
          <source>The &lt;span id=&quot;for_1&quot;&gt;for&lt;/span&gt; statement is an abstract mechanism to iterate over the elements of a container. It relies on an &lt;span id=&quot;iterator_1&quot;&gt;iterator&lt;/span&gt; to do so. Like &lt;code&gt;while&lt;/code&gt; statements, &lt;code&gt;for&lt;/code&gt; statements open an &lt;span id=&quot;implicit-block_1&quot;&gt;implicit block&lt;/span&gt;, so that they can be left with a &lt;code&gt;break&lt;/code&gt; statement.</source>
          <target state="translated">该&lt;span id=&quot;for_1&quot;&gt;用于&lt;/span&gt;语句是一个抽象的机制来遍历一个容器中的元素。它依靠&lt;span id=&quot;iterator_1&quot;&gt;迭代器&lt;/span&gt;来做到这一点。与 &lt;code&gt;while&lt;/code&gt; 语句一样， &lt;code&gt;for&lt;/code&gt; 语句打开一个&lt;span id=&quot;implicit-block_1&quot;&gt;隐式block&lt;/span&gt;，以便可以将它们与 &lt;code&gt;break&lt;/code&gt; 语句一起使用。</target>
        </trans-unit>
        <trans-unit id="6d9382afc1ab3b35fd9c7113d6add76969213268" translate="yes" xml:space="preserve">
          <source>The &lt;span id=&quot;gcsafe_1&quot;&gt;gcsafe&lt;/span&gt; annotation can be used to mark a proc to be gcsafe, otherwise this property is inferred by the compiler. Note that &lt;code&gt;noSideEffect&lt;/code&gt; implies &lt;code&gt;gcsafe&lt;/code&gt;. The only way to create a thread is via &lt;code&gt;spawn&lt;/code&gt; or &lt;code&gt;createThread&lt;/code&gt;. &lt;code&gt;spawn&lt;/code&gt; is usually the preferable method. Either way the invoked proc must not use &lt;code&gt;var&lt;/code&gt; parameters nor must any of its parameters contain a &lt;code&gt;ref&lt;/code&gt; or &lt;code&gt;closure&lt;/code&gt; type. This enforces the &lt;em&gt;no heap sharing restriction&lt;/em&gt;.</source>
          <target state="translated">所述&lt;span id=&quot;gcsafe_1&quot;&gt;gcsafe&lt;/span&gt;注释可以被用于标记一个PROC是gcsafe，否则该属性是由编译器推断。请注意， &lt;code&gt;noSideEffect&lt;/code&gt; 暗含 &lt;code&gt;gcsafe&lt;/code&gt; 。创建线程的唯一方法是通过 &lt;code&gt;spawn&lt;/code&gt; 或 &lt;code&gt;createThread&lt;/code&gt; 。 &lt;code&gt;spawn&lt;/code&gt; 通常是首选方法。无论哪种方式，被调用的proc都不得使用 &lt;code&gt;var&lt;/code&gt; 参数，其任何参数均不得包含 &lt;code&gt;ref&lt;/code&gt; 或 &lt;code&gt;closure&lt;/code&gt; 类型。这将强制执行&lt;em&gt;无堆共享限制&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="91164a5c7f6c7e859655b6b6af4545842eee07d8" translate="yes" xml:space="preserve">
          <source>The &lt;span id=&quot;hotcodereloading_1&quot;&gt;hotCodeReloading&lt;/span&gt; option enables special compilation mode where changes in the code can be applied automatically to a running program. The code reloading happens at the granularity of an individual module. When a module is reloaded, Nim will preserve the state of all global variables which are initialized with a standard variable declaration in the code. All other top level code will be executed repeatedly on each reload. If you want to prevent this behavior, you can guard a block of code with the &lt;code&gt;once&lt;/code&gt; construct:</source>
          <target state="translated">该&lt;span id=&quot;hotcodereloading_1&quot;&gt;hotCodeReloading&lt;/span&gt;选项允许在代码的变化可以自动应用到正在运行的程序的特殊编译模式。代码重装以单个模块的粒度进行。重新加载模块时，Nim将保留所有全局变量的状态，这些全局变量在代码中使用标准变量声明进行了初始化。所有其他顶级代码将在每次重新加载时重复执行。如果要防止这种行为，则可以使用 &lt;code&gt;once&lt;/code&gt; 构造来保护代码块：</target>
        </trans-unit>
        <trans-unit id="57a3663a206275ec6b24a0d4f5e454d389b9f45f" translate="yes" xml:space="preserve">
          <source>The &lt;span id=&quot;koch_1&quot;&gt;koch&lt;/span&gt; program is Nim's maintenance script. It is a replacement for make and shell scripting with the advantage that it is much more portable. The word &lt;em&gt;koch&lt;/em&gt; means &lt;em&gt;cook&lt;/em&gt; in German. &lt;code&gt;koch&lt;/code&gt; is used mainly to build the Nim compiler, but it can also be used for other tasks. This document describes the supported commands and their options.</source>
          <target state="translated">该&lt;span id=&quot;koch_1&quot;&gt;科赫&lt;/span&gt;程序是稔的维护脚本。它替代了make和shell脚本，其优点是更易于移植。&lt;em&gt;koch&lt;/em&gt;一词在德语中意为&lt;em&gt;厨师&lt;/em&gt;。 &lt;code&gt;koch&lt;/code&gt; 主要用于构建Nim编译器，但也可以用于其他任务。本文档介绍了受支持的命令及其选项。</target>
        </trans-unit>
        <trans-unit id="a53571f24b323d265b8569c9fb2bedae1b76e3af" translate="yes" xml:space="preserve">
          <source>The &lt;span id=&quot;nimcache_1&quot;&gt;nimcache&lt;/span&gt; directory is generated during compilation and will hold either temporary or final files depending on your backend target. The default name for the directory depends on the used backend and on your OS but you can use the &lt;code&gt;--nimcache&lt;/code&gt;&lt;a href=&quot;nimc#command-line-switches&quot;&gt;compiler switch&lt;/a&gt; to change it.</source>
          <target state="translated">该&lt;span id=&quot;nimcache_1&quot;&gt;nimcache&lt;/span&gt;编译期间生成的目录，并将举办取决于后端的目标是临时或最终文件。该目录的默认名称取决于使用的后端和您的操作系统，但是您可以使用 &lt;code&gt;--nimcache&lt;/code&gt; &lt;a href=&quot;nimc#command-line-switches&quot;&gt;编译器开关&lt;/a&gt;进行更改。</target>
        </trans-unit>
        <trans-unit id="54a1e48458551511422bbb61f22c648f60734046" translate="yes" xml:space="preserve">
          <source>The &lt;span id=&quot;parameter-constraint_1&quot;&gt;parameter constraint&lt;/span&gt; expression can use the operators &lt;code&gt;|&lt;/code&gt; (or), &lt;code&gt;&amp;amp;&lt;/code&gt; (and) and &lt;code&gt;~&lt;/code&gt; (not) and the following predicates:</source>
          <target state="translated">该&lt;span id=&quot;parameter-constraint_1&quot;&gt;参数约束&lt;/span&gt;表达式可以使用运营商 &lt;code&gt;|&lt;/code&gt; （或）， &lt;code&gt;&amp;amp;&lt;/code&gt; （和）和 &lt;code&gt;~&lt;/code&gt; （不是）以及以下谓词：</target>
        </trans-unit>
        <trans-unit id="cfa661ac5acf3812a9603d558f0cc5e9d16b725f" translate="yes" xml:space="preserve">
          <source>The &lt;span id=&quot;pushslashpop_1&quot;&gt;push/pop&lt;/span&gt; pragmas are very similar to the option directive, but are used to override the settings temporarily. Example:</source>
          <target state="translated">该&lt;span id=&quot;pushslashpop_1&quot;&gt;PUSH / POP&lt;/span&gt;编译指示是非常相似的选项指令，而是用于暂时覆盖设置。例：</target>
        </trans-unit>
        <trans-unit id="87bbfad905a0fc037232436963bb95bf7f76d077" translate="yes" xml:space="preserve">
          <source>The &lt;span id=&quot;slice_1&quot;&gt;slice&lt;/span&gt; operator .. takes precedence over other tokens that contain a dot: {..} are the three tokens {, .., } and not the two tokens {., .}.</source>
          <target state="translated">该&lt;span id=&quot;slice_1&quot;&gt;切片&lt;/span&gt;操作..优先于包含点其他标记：{..}是三个令牌{，...，}，而不是两个标记{，。}。</target>
        </trans-unit>
        <trans-unit id="5af8373b9460197079b99667c8fea57ecbb59884" translate="yes" xml:space="preserve">
          <source>The &lt;span id=&quot;substitution_1&quot;&gt;substitution&lt;/span&gt; operator performs string substitutions in &lt;em&gt;formatstr&lt;/em&gt; and returns a modified &lt;em&gt;formatstr&lt;/em&gt;. This is often called &lt;span id=&quot;string-interpolation_1&quot;&gt;string interpolation&lt;/span&gt;.</source>
          <target state="translated">在&lt;span id=&quot;substitution_1&quot;&gt;替代&lt;/span&gt;操作者执行字符串替换在&lt;em&gt;formatstr&lt;/em&gt;并返回一个改性&lt;em&gt;formatstr&lt;/em&gt;。这通常称为&lt;span id=&quot;string-interpolation_1&quot;&gt;字符串插值&lt;/span&gt;。</target>
        </trans-unit>
        <trans-unit id="6513fa7dcefd8fcc828e499152082db4c572537e" translate="yes" xml:space="preserve">
          <source>The &lt;span id=&quot;substitution_2&quot;&gt;substitution&lt;/span&gt; operator performs string substitutions in &lt;em&gt;formatstr&lt;/em&gt; and returns a modified &lt;em&gt;formatstr&lt;/em&gt;. This is often called &lt;span id=&quot;string-interpolation_2&quot;&gt;string interpolation&lt;/span&gt;.</source>
          <target state="translated">在&lt;span id=&quot;substitution_2&quot;&gt;替代&lt;/span&gt;操作者执行字符串替换在&lt;em&gt;formatstr&lt;/em&gt;并返回一个改性&lt;em&gt;formatstr&lt;/em&gt;。这通常称为&lt;span id=&quot;string-interpolation_2&quot;&gt;字符串插值&lt;/span&gt;。</target>
        </trans-unit>
        <trans-unit id="6f1b458b1b19b189d8e65f1668a50897e0a48f44" translate="yes" xml:space="preserve">
          <source>The &lt;span id=&quot;test_1&quot;&gt;test&lt;/span&gt; command can also be invoked with the alias &lt;code&gt;tests&lt;/code&gt;. This command will compile and run &lt;code&gt;tests/testament/tester.nim&lt;/code&gt;, which is the main driver of Nim's test suite. You can pass options to the &lt;code&gt;test&lt;/code&gt; command, they will be forwarded to the tester. See its source code for available options.</source>
          <target state="translated">该&lt;span id=&quot;test_1&quot;&gt;测试&lt;/span&gt;命令也可以用别名调用的 &lt;code&gt;tests&lt;/code&gt; 。该命令将编译并运行 &lt;code&gt;tests/testament/tester.nim&lt;/code&gt; ，这是Nim测试套件的主要驱动程序。您可以将选项传递给 &lt;code&gt;test&lt;/code&gt; 命令，它们将被转发给测试人员。请参阅其源代码以获取可用选项。</target>
        </trans-unit>
        <trans-unit id="b2c15981e5e4830750c05aa5cb51e33019a0e2a4" translate="yes" xml:space="preserve">
          <source>The &lt;span id=&quot;web_1&quot;&gt;web&lt;/span&gt; command converts the documentation in the &lt;code&gt;doc&lt;/code&gt; directory from rst to HTML. It also repeats the same operation but places the result in the &lt;code&gt;web/upload&lt;/code&gt; which can be used to update the website at &lt;a href=&quot;https://nim-lang.org&quot;&gt;https://nim-lang.org&lt;/a&gt;.</source>
          <target state="translated">该&lt;span id=&quot;web_1&quot;&gt;网页&lt;/span&gt;命令转换的文档 &lt;code&gt;doc&lt;/code&gt; 从第一个到HTML目录。它还重复相同的操作，但是将结果放置在 &lt;code&gt;web/upload&lt;/code&gt; 中，该结果可用于更新&lt;a href=&quot;https://nim-lang.org&quot;&gt;https://nim-lang.org上&lt;/a&gt;的网站。</target>
        </trans-unit>
        <trans-unit id="dea7302995c2fe043006be5d95cc1952f9177148" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;FILE&lt;/strong&gt; paramater is enough for static analysis, but IDEs tend to have &lt;em&gt;unsaved buffers&lt;/em&gt; where the user may still be in the middle of typing a line. In such situations the IDE can save the current contents to a temporary file and then use the &lt;code&gt;--trackDirty&lt;/code&gt; switch.</source>
          <target state="translated">该&lt;strong&gt;文件&lt;/strong&gt; paramater是足够的静态分析，但是集成开发环境往往有&lt;em&gt;未保存的缓冲区&lt;/em&gt;，其中用户仍然可以在键入一行的中间。在这种情况下，IDE可以将当前内容保存到一个临时文件中，然后使用 &lt;code&gt;--trackDirty&lt;/code&gt; 开关。</target>
        </trans-unit>
        <trans-unit id="c27b669448c36c816470b9ecb178842de255828a" translate="yes" xml:space="preserve">
          <source>The API is designed to be &lt;strong&gt;easy to use&lt;/strong&gt; and consistent. Ease of use is measured by the number of calls to achieve a concrete high level action.</source>
          <target state="translated">该API旨在&lt;strong&gt;易于使用&lt;/strong&gt;和保持一致。易用性是通过达到具体的高级别操作的呼叫次数来衡量的。</target>
        </trans-unit>
        <trans-unit id="c73b5df5c651cfdc62f3ab0cb7d427e139e5b455" translate="yes" xml:space="preserve">
          <source>The API should embrace the AST diffing notion: See the module &lt;code&gt;macrocache&lt;/code&gt; for the final details.</source>
          <target state="translated">该API应该包含AST差异概念：有关最终详细信息，请参见模块 &lt;code&gt;macrocache&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="340251b1d9f2a716c84b7e7a92de21c0f5e2b332" translate="yes" xml:space="preserve">
          <source>The AST in Nim</source>
          <target state="translated">尼姆的AST</target>
        </trans-unit>
        <trans-unit id="d9e072d30e620c5ec90f1b3cdaf9f07a7689786e" translate="yes" xml:space="preserve">
          <source>The C like backends will place their temporary &lt;code&gt;.c&lt;/code&gt;, &lt;code&gt;.cpp&lt;/code&gt; or &lt;code&gt;.m&lt;/code&gt; files in the &lt;code&gt;nimcache&lt;/code&gt; directory. The naming of these files follows the pattern &lt;code&gt;nimblePackageName_&lt;/code&gt; + &lt;code&gt;nimSource&lt;/code&gt;:</source>
          <target state="translated">像C这样的后端会将其临时 &lt;code&gt;.c&lt;/code&gt; ， &lt;code&gt;.cpp&lt;/code&gt; 或 &lt;code&gt;.m&lt;/code&gt; 文件放在 &lt;code&gt;nimcache&lt;/code&gt; 目录中。这些文件的命名遵循 &lt;code&gt;nimblePackageName_&lt;/code&gt; + &lt;code&gt;nimSource&lt;/code&gt; 模式：</target>
        </trans-unit>
        <trans-unit id="7c1c75d070fdb7254d04b1bbedfea64bf072a3ea" translate="yes" xml:space="preserve">
          <source>The C like targets</source>
          <target state="translated">C类目标</target>
        </trans-unit>
        <trans-unit id="5d8208a944d082cd05346b5083e300cf7433b341" translate="yes" xml:space="preserve">
          <source>The CellSet data structure</source>
          <target state="translated">CellSet数据结构</target>
        </trans-unit>
        <trans-unit id="6ed4e2479ba02a41f340ac876f235bcda842872e" translate="yes" xml:space="preserve">
          <source>The DevkitPro setup must be the same as the default with their new installer &lt;a href=&quot;https://github.com/devkitPro/pacman/releases&quot;&gt;here for Mac/Linux&lt;/a&gt; or &lt;a href=&quot;https://github.com/devkitPro/installer/releases&quot;&gt;here for Windows&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/devkitPro/pacman/releases&quot;&gt;对于Mac / Linux&lt;/a&gt;或&lt;a href=&quot;https://github.com/devkitPro/installer/releases&quot;&gt;Windows&lt;/a&gt;，DevkitPro的安装程序必须与默认设置相同，并带有其新安装程序。</target>
        </trans-unit>
        <trans-unit id="ffd5b1c0ab5a21a3d6f5ddcb44893f272563ba0a" translate="yes" xml:space="preserve">
          <source>The GC depends on an extremely efficient datastructure for storing a set of pointers - this is called a &lt;code&gt;TCellSet&lt;/code&gt; in the source code. Inserting, deleting and searching are done in constant time. However, modifying a &lt;code&gt;TCellSet&lt;/code&gt; during traversation leads to undefined behaviour.</source>
          <target state="translated">GC依赖于极其高效的数据结构来存储一组指针- 在源代码中将其称为 &lt;code&gt;TCellSet&lt;/code&gt; 。插入，删除和搜索是在固定时间内完成的。但是，在遍历期间修改 &lt;code&gt;TCellSet&lt;/code&gt; 会导致不确定的行为。</target>
        </trans-unit>
        <trans-unit id="ebc02645609d7f52fae8aedf8c4c8bf347d64250" translate="yes" xml:space="preserve">
          <source>The GC is only triggered in a memory allocation operation. It is not triggered by some timer and does not run in a background thread.</source>
          <target state="translated">GC只在内存分配操作中被触发,它不是由某个定时器触发,也不在后台线程中运行。它不是由某个定时器触发的,也不在后台线程中运行。</target>
        </trans-unit>
        <trans-unit id="05815d59fb042a842f4d63bb24b3e64b07d2dee5" translate="yes" xml:space="preserve">
          <source>The GC's way of measuring time uses (see &lt;code&gt;lib/system/timers.nim&lt;/code&gt; for the implementation):</source>
          <target state="translated">GC度量时间使用的方式（有关实现，请参见 &lt;code&gt;lib/system/timers.nim&lt;/code&gt; ）：</target>
        </trans-unit>
        <trans-unit id="ea7df501b4189771d55e6aaa674cc650d42d3aa3" translate="yes" xml:space="preserve">
          <source>The Garbage Collector</source>
          <target state="translated">垃圾收集器</target>
        </trans-unit>
        <trans-unit id="dcad958e2a5300a34865aa11366e580e6c78767e" translate="yes" xml:space="preserve">
          <source>The IEEE exceptions are either ignored at runtime or mapped to the Nim exceptions: &lt;span id=&quot;floatinvalidoperror_1&quot;&gt;FloatInvalidOpError&lt;/span&gt;, &lt;span id=&quot;floatdivbyzeroerror_1&quot;&gt;FloatDivByZeroError&lt;/span&gt;, &lt;span id=&quot;floatoverflowerror_1&quot;&gt;FloatOverflowError&lt;/span&gt;, &lt;span id=&quot;floatunderflowerror_1&quot;&gt;FloatUnderflowError&lt;/span&gt;, and &lt;span id=&quot;floatinexacterror_1&quot;&gt;FloatInexactError&lt;/span&gt;. These exceptions inherit from the &lt;span id=&quot;floatingpointerror_1&quot;&gt;FloatingPointError&lt;/span&gt; base class.</source>
          <target state="translated">IEEE异常或者在运行时被忽略，或者映射到以下Nim异常：&lt;span id=&quot;floatinvalidoperror_1&quot;&gt;FloatInvalidOpError&lt;/span&gt;，&lt;span id=&quot;floatdivbyzeroerror_1&quot;&gt;FloatDivByZeroError&lt;/span&gt;，&lt;span id=&quot;floatoverflowerror_1&quot;&gt;FloatOverflowError&lt;/span&gt;，&lt;span id=&quot;floatunderflowerror_1&quot;&gt;FloatUnderflowError&lt;/span&gt;和&lt;span id=&quot;floatinexacterror_1&quot;&gt;FloatInexactError&lt;/span&gt;。这些异常继承自&lt;span id=&quot;floatingpointerror_1&quot;&gt;FloatingPointError&lt;/span&gt;基类。</target>
        </trans-unit>
        <trans-unit id="e93e53c09fc19a935940b71534b7f3d3ef1586f6" translate="yes" xml:space="preserve">
          <source>The IEEE standard defines five types of floating-point exceptions:</source>
          <target state="translated">IEEE标准定义了五种类型的浮点异常。</target>
        </trans-unit>
        <trans-unit id="3a986d0cb1d3a266cf50f1d33d468ab68b62b7e0" translate="yes" xml:space="preserve">
          <source>The JS target is actually &lt;code&gt;node.js&lt;/code&gt;.</source>
          <target state="translated">JS的目标实际上是 &lt;code&gt;node.js&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e6137eefe505bc68232cc4d0ce7515cc44adc09e" translate="yes" xml:space="preserve">
          <source>The JavaScript target</source>
          <target state="translated">JavaScript目标</target>
        </trans-unit>
        <trans-unit id="4cbe26954e5cc8b26988852f379eeeef2ae7a95f" translate="yes" xml:space="preserve">
          <source>The JavaScript target doesn't have any further interfacing considerations since it also has garbage collection, but the C targets require you to initialize Nim's internals, which is done calling a &lt;code&gt;NimMain&lt;/code&gt; function. Also, C code requires you to specify a forward declaration for functions or the compiler will assume certain types for the return value and parameters which will likely make your program crash at runtime.</source>
          <target state="translated">JavaScript目标没有任何其他接口方面的考虑，因为它也具有垃圾回收功能，但是C目标要求您初始化Nim的内部，这是通过调用 &lt;code&gt;NimMain&lt;/code&gt; 函数来完成的。同样，C代码要求您为函数指定前向声明，否则编译器将假定某些类型的返回值和参数，这可能会使您的程序在运行时崩溃。</target>
        </trans-unit>
        <trans-unit id="c71fa4398834a6a9a72702a17c78e6eacdbf2bf6" translate="yes" xml:space="preserve">
          <source>The Nim compiler and most parts of the standard library support a taint mode. Input strings are declared with the &lt;span id=&quot;taintedstring_1&quot;&gt;TaintedString&lt;/span&gt; string type declared in the &lt;code&gt;system&lt;/code&gt; module.</source>
          <target state="translated">Nim编译器和标准库的大多数部分都支持异味模式。输入字符串使用在 &lt;code&gt;system&lt;/code&gt; 模块中声明的&lt;span id=&quot;taintedstring_1&quot;&gt;TaintedString&lt;/span&gt;字符串类型声明。</target>
        </trans-unit>
        <trans-unit id="def6a14c368cd75cd8626ee152affd572b2968a4" translate="yes" xml:space="preserve">
          <source>The Nim compiler can generate a C interface header through the &lt;code&gt;--header&lt;/code&gt; command line switch. The generated header will contain all the exported symbols and the &lt;code&gt;NimMain&lt;/code&gt; proc which you need to call before any other Nim code.</source>
          <target state="translated">Nim编译器可以通过 &lt;code&gt;--header&lt;/code&gt; 命令行开关生成C接口头。生成的标头将包含所有导出的符号和您需要在任何其他Nim代码之前调用的 &lt;code&gt;NimMain&lt;/code&gt; proc。</target>
        </trans-unit>
        <trans-unit id="94228688470dadb9d05b8e3aa4652ece8f0668d5" translate="yes" xml:space="preserve">
          <source>The Nim compiler emits different kinds of messages: &lt;span id=&quot;hint_1&quot;&gt;hint&lt;/span&gt;, &lt;span id=&quot;warning_1&quot;&gt;warning&lt;/span&gt;, and &lt;span id=&quot;error_1&quot;&gt;error&lt;/span&gt; messages. An &lt;em&gt;error&lt;/em&gt; message is emitted if the compiler encounters any static error.</source>
          <target state="translated">Nim编译器发出不同类型的消息：&lt;span id=&quot;hint_1&quot;&gt;hint&lt;/span&gt;，&lt;span id=&quot;warning_1&quot;&gt;warning&lt;/span&gt;和&lt;span id=&quot;error_1&quot;&gt;error&lt;/span&gt;消息。如果编译器遇到任何静态错误，则会发出一条&lt;em&gt;错误&lt;/em&gt;消息。</target>
        </trans-unit>
        <trans-unit id="925789b7eec75edffc7a653892e368b900774bb2" translate="yes" xml:space="preserve">
          <source>The Nim compiler includes a simple linear equation solver, allowing it to infer static params in some situations where integer arithmetic is involved.</source>
          <target state="translated">Nim编译器包括一个简单的线性方程求解器,允许它在某些涉及整数运算的情况下推断静态参数。</target>
        </trans-unit>
        <trans-unit id="0aad288594b7108c08933546073e4929c7d5707a" translate="yes" xml:space="preserve">
          <source>The Nim compiler supports mainly two backend families: the C, C++ and Objective-C targets and the JavaScript target. &lt;a href=&quot;#backends-the-c-like-targets&quot;&gt;The C like targets&lt;/a&gt; creates source files which can be compiled into a library or a final executable. &lt;a href=&quot;#backends-the-javascript-target&quot;&gt;The JavaScript target&lt;/a&gt; can generate a &lt;code&gt;.js&lt;/code&gt; file which you reference from an HTML file or create a &lt;a href=&quot;http://nodejs.org&quot;&gt;standalone nodejs program&lt;/a&gt;.</source>
          <target state="translated">Nim编译器主要支持两个后端系列：C，C ++和Objective-C目标以及JavaScript目标。&lt;a href=&quot;#backends-the-c-like-targets&quot;&gt;类似于C的目标将&lt;/a&gt;创建可编译为库或最终可执行文件的源文件。&lt;a href=&quot;#backends-the-javascript-target&quot;&gt;JavaScript目标&lt;/a&gt;可以生成一个 &lt;code&gt;.js&lt;/code&gt; 文件，您可以从HTML文件中引用该文件，也可以创建一个&lt;a href=&quot;http://nodejs.org&quot;&gt;独立的nodejs程序&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ab9acd635a298ee76edc5f11e47d2fedf88be9db" translate="yes" xml:space="preserve">
          <source>The Nim compiler supports source code filters as a simple yet powerful builtin templating system.</source>
          <target state="translated">Nim编译器支持源代码过滤器,作为一个简单而强大的内置模板系统。</target>
        </trans-unit>
        <trans-unit id="3b52099df7643f4b981a178452104474413203d0" translate="yes" xml:space="preserve">
          <source>The Nim compiler will handle linking the source files generated in the &lt;code&gt;nimcache&lt;/code&gt; directory into the &lt;code&gt;libfib.nim.a&lt;/code&gt; static library, which you can then link into your C program. Note that these commands are generic and will vary for each system. For instance, on Linux systems you will likely need to use &lt;code&gt;-ldl&lt;/code&gt; too to link in required dlopen functionality.</source>
          <target state="translated">Nim编译器将处理将 &lt;code&gt;nimcache&lt;/code&gt; 目录中生成的源文件链接到 &lt;code&gt;libfib.nim.a&lt;/code&gt; 静态库中，然后您可以将其链接到C程序中。请注意，这些命令是通用的，并且对于每个系统都会有所不同。例如，在Linux系统上，您可能还需要使用 &lt;code&gt;-ldl&lt;/code&gt; 来链接所需的dlopen功能。</target>
        </trans-unit>
        <trans-unit id="1fdb91e1f0e7364e6a781dd1b11345e2628e4a18" translate="yes" xml:space="preserve">
          <source>The Nim library makes heavy use of overloading - one reason for this is that each operator like &lt;code&gt;+&lt;/code&gt; is just an overloaded proc. The parser lets you use operators in &lt;em&gt;infix notation&lt;/em&gt; (&lt;code&gt;a + b&lt;/code&gt;) or &lt;em&gt;prefix notation&lt;/em&gt; (&lt;code&gt;+ a&lt;/code&gt;). An infix operator always receives two arguments, a prefix operator always one. (Postfix operators are not possible, because this would be ambiguous: does &lt;code&gt;a @ @ b&lt;/code&gt; mean &lt;code&gt;(a) @ (@b)&lt;/code&gt; or &lt;code&gt;(a@) @ (b)&lt;/code&gt;? It always means &lt;code&gt;(a) @ (@b)&lt;/code&gt;, because there are no postfix operators in Nim.)</source>
          <target state="translated">Nim库大量使用了重载-原因之一是像 &lt;code&gt;+&lt;/code&gt; 这样的每个运算符都只是一个重载proc。解析器可以让你在使用运营商&lt;em&gt;中间符号&lt;/em&gt;（ &lt;code&gt;a + b&lt;/code&gt; ）或&lt;em&gt;前缀符号&lt;/em&gt;（ &lt;code&gt;+ a&lt;/code&gt; ）。前缀运算符始终接收两个参数，前缀运算符始终接收一个参数。 （后缀运算符是不可能的，因为这可能是模棱两可的： &lt;code&gt;a @ @ b&lt;/code&gt; 表示 &lt;code&gt;(a) @ (@b)&lt;/code&gt; @b ）还是 &lt;code&gt;(a@) @ (b)&lt;/code&gt; ？它总是表示 &lt;code&gt;(a) @ (@b)&lt;/code&gt; ，因为Nim中没有后缀运算符。）</target>
        </trans-unit>
        <trans-unit id="b17c19d995b51a702da47a322eb14c3c3f74d169" translate="yes" xml:space="preserve">
          <source>The Nim manual is a draft that will evolve into a proper specification.</source>
          <target state="translated">尼姆手册是一个草案,将演变成一个适当的规范。</target>
        </trans-unit>
        <trans-unit id="e4eee78d4b7b5546dac0f0bcfd4ab8e0361f503a" translate="yes" xml:space="preserve">
          <source>The Nim programming language has no concept of Posix's signal handling mechanisms. However, the standard library offers some rudimentary support for signal handling, in particular, segmentation faults are turned into fatal errors that produce a stack trace. This can be disabled with the &lt;code&gt;-d:noSignalHandler&lt;/code&gt; switch.</source>
          <target state="translated">Nim编程语言没有Posix信号处理机制的概念。但是，标准库为信号处理提供了一些基本支持，特别是，分段错误被转换为致命错误，从而产生堆栈跟踪。可以使用 &lt;code&gt;-d:noSignalHandler&lt;/code&gt; 开关禁用它。</target>
        </trans-unit>
        <trans-unit id="e3345c6b8f143dcd54f42f93fcf9a202601d5fc9" translate="yes" xml:space="preserve">
          <source>The Nim project's directory structure is:</source>
          <target state="translated">Nim项目的目录结构是。</target>
        </trans-unit>
        <trans-unit id="745ed56715666ebf26c03c8cf5d30717ab67de33" translate="yes" xml:space="preserve">
          <source>The Nim standard library uses this function on the elements of collections when producing a string representation of a collection. It is recommended to use this function as well for user-side collections. Users may overload &lt;em&gt;addQuoted&lt;/em&gt; for custom (string-like) types if they want to implement a customized element representation.</source>
          <target state="translated">Nim标准库在生成集合的字符串表示形式时，会对集合的元素使用此函数。建议在用户端集合中也使用此功能。如果用户想要实现自定义元素表示，&lt;em&gt;则可&lt;/em&gt;以为自定义（类字符串）类型重载&lt;em&gt;addQuoted&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="54b8c6d91ca6a5455af26ed86869eb5c4519994d" translate="yes" xml:space="preserve">
          <source>The Nim tutorial part one deals with the basics.</source>
          <target state="translated">Nim教程第一部分讲的是基础知识。</target>
        </trans-unit>
        <trans-unit id="9a6b7b3f497d2672fe45a7b21b92290089548d77" translate="yes" xml:space="preserve">
          <source>The Nim tutorial part two deals with the advanced language constructs.</source>
          <target state="translated">Nim教程第二部分涉及高级语言构造。</target>
        </trans-unit>
        <trans-unit id="c83305965ac9b2ed953b344478f9a769c28c7aba" translate="yes" xml:space="preserve">
          <source>The PEG parser implements this grammar (written in PEG syntax):</source>
          <target state="translated">PEG解析器实现了这个语法(用PEG语法编写)。</target>
        </trans-unit>
        <trans-unit id="b2baf9c90ee9c6afac7ad841487341acef025679" translate="yes" xml:space="preserve">
          <source>The above &lt;code&gt;debug&lt;/code&gt; macro relies on the fact that &lt;code&gt;write&lt;/code&gt;, &lt;code&gt;writeLine&lt;/code&gt; and &lt;code&gt;stdout&lt;/code&gt; are declared in the system module and thus visible in the instantiating context. There is a way to use bound identifiers (aka &lt;span id=&quot;symbols_1&quot;&gt;symbols&lt;/span&gt;) instead of using unbound identifiers. The &lt;code&gt;bindSym&lt;/code&gt; builtin can be used for that:</source>
          <target state="translated">上面的 &lt;code&gt;debug&lt;/code&gt; 宏依赖于以下事实：在系统模块中声明了 &lt;code&gt;write&lt;/code&gt; ， &lt;code&gt;writeLine&lt;/code&gt; 和 &lt;code&gt;stdout&lt;/code&gt; ，因此它们在实例化上下文中可见。有一种方法可以使用绑定标识符（也称为&lt;span id=&quot;symbols_1&quot;&gt;符号&lt;/span&gt;），而不是使用未绑定标识符。内置的 &lt;code&gt;bindSym&lt;/code&gt; 可用于：</target>
        </trans-unit>
        <trans-unit id="ed87b5819ca0a50089cd2bf1bad97ce7b0637b5f" translate="yes" xml:space="preserve">
          <source>The above code fails with the mysterious error message that &lt;code&gt;i&lt;/code&gt; has already been declared. The reason for this is that the &lt;code&gt;var i = ...&lt;/code&gt; bodies need to be type-checked before they are passed to the &lt;code&gt;body&lt;/code&gt; parameter and type checking in Nim implies symbol lookups. For the symbol lookups to succeed &lt;code&gt;i&lt;/code&gt; needs to be added to the current (i.e. outer) scope. After type checking these additions to the symbol table are not rolled back (for better or worse). The same code works with &lt;code&gt;untyped&lt;/code&gt; as the passed body is not required to be type-checked:</source>
          <target state="translated">上面的代码失败与神秘的错误消息， &lt;code&gt;i&lt;/code&gt; 已经声明。这样做的原因是，在将 &lt;code&gt;var i = ...&lt;/code&gt; 主体传递给 &lt;code&gt;body&lt;/code&gt; 参数之前，需要对其进行类型检查，并且在Nim中进行类型检查会隐含符号查找。为了使符号查找成功， &lt;code&gt;i&lt;/code&gt; 需要添加到当前（即外部）范围中。在进行类型检查之后，不会回退这些添加到符号表中的内容（无论好坏）。相同的代码适用于 &lt;code&gt;untyped&lt;/code&gt; ,因为不需要对传递的主体进行类型检查：</target>
        </trans-unit>
        <trans-unit id="b3982101b8689b140d25aa17cb82ea30c138360e" translate="yes" xml:space="preserve">
          <source>The above code outputs:</source>
          <target state="translated">上述代码输出。</target>
        </trans-unit>
        <trans-unit id="dc4bda02bd351eb1e53dd407e05088912ae083f6" translate="yes" xml:space="preserve">
          <source>The above example will fail, to ensure c2nim &lt;em&gt;processes&lt;/em&gt; these defines and expands them, use c2nim's &lt;code&gt;#def&lt;/code&gt; directive:</source>
          <target state="translated">上面的示例将失败，以确保c2nim &lt;em&gt;处理&lt;/em&gt;这些定义并扩展它们，请使用c2nim的 &lt;code&gt;#def&lt;/code&gt; 指令：</target>
        </trans-unit>
        <trans-unit id="af1747a46fc4da26a624c04d36cc94dfd97e3023" translate="yes" xml:space="preserve">
          <source>The above module exports &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;*&lt;/code&gt;, but not &lt;code&gt;y&lt;/code&gt;.</source>
          <target state="translated">上面的模块输出 &lt;code&gt;x&lt;/code&gt; 和 &lt;code&gt;*&lt;/code&gt; ，但是不输出 &lt;code&gt;y&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2164536ddfd6de29510303b3ffa83bdfffcb08d5" translate="yes" xml:space="preserve">
          <source>The above output could be the result of a code snippet like:</source>
          <target state="translated">上面的输出可能是一个代码片段的结果,比如。</target>
        </trans-unit>
        <trans-unit id="3921e4649d03a4f2c2e0f1f2787d19741635bd73" translate="yes" xml:space="preserve">
          <source>The access to field &lt;code&gt;x.v&lt;/code&gt; is allowed since its guard &lt;code&gt;x.L&lt;/code&gt; is active. After template expansion, this amounts to:</source>
          <target state="translated">由于其保护 &lt;code&gt;x.L&lt;/code&gt; 处于活动状态，因此允许访问字段 &lt;code&gt;x.v&lt;/code&gt; 。模板扩展后，总计为：</target>
        </trans-unit>
        <trans-unit id="8dd5c61046585195d0c3e2c466315972a1789d8b" translate="yes" xml:space="preserve">
          <source>The addr operator</source>
          <target state="translated">addr运算符</target>
        </trans-unit>
        <trans-unit id="9c16d3733ab5de84d13321ea183405e627ced8c0" translate="yes" xml:space="preserve">
          <source>The algorithm for compiling modules is:</source>
          <target state="translated">编译模块的算法是。</target>
        </trans-unit>
        <trans-unit id="7735ffef84f6b2ad890f11a7dd0ee082beb33ad5" translate="yes" xml:space="preserve">
          <source>The algorithm is based on the theory of continued fractions.</source>
          <target state="translated">该算法的基础是续分理论。</target>
        </trans-unit>
        <trans-unit id="d614f17a9f1bd45756a257161f52b39079cec7a1" translate="yes" xml:space="preserve">
          <source>The assignment operator for strings always copies the string. The &lt;code&gt;&amp;amp;&lt;/code&gt; operator concatenates strings.</source>
          <target state="translated">字符串的赋值运算符始终复制该字符串。在 &lt;code&gt;&amp;amp;&lt;/code&gt; 运算符连接字符串。</target>
        </trans-unit>
        <trans-unit id="7d2817b98254430aea892c64ac0086b7f62a2214" translate="yes" xml:space="preserve">
          <source>The assignment operator for strings copies the string. You can use the &lt;code&gt;&amp;amp;&lt;/code&gt; operator to concatenate strings and &lt;code&gt;add&lt;/code&gt; to append to a string.</source>
          <target state="translated">字符串的赋值运算符将复制字符串。您可以使用 &lt;code&gt;&amp;amp;&lt;/code&gt; 运算符来连接字符串，并 &lt;code&gt;add&lt;/code&gt; 以追加到字符串。</target>
        </trans-unit>
        <trans-unit id="bb716b99b45cbb4781636530d6cc58814ca4c5cf" translate="yes" xml:space="preserve">
          <source>The assignment operator for tuples copies each component. The default assignment operator for objects copies each component. Overloading of the assignment operator is described in &lt;a href=&quot;#typeminusboundminusoperationsminusoperator&quot;&gt;type-bound-operations-operator&lt;/a&gt;.</source>
          <target state="translated">元组的赋值运算符复制每个组件。对象的默认赋值运算符将复制每个组件。赋值运算符的重载在&lt;a href=&quot;#typeminusboundminusoperationsminusoperator&quot;&gt;type-bound-operations-operator中进行了描述&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ad5e1062fa49239262e20658b8eefbafc9c44097" translate="yes" xml:space="preserve">
          <source>The assignment operator for tuples copies each component. The notation &lt;code&gt;t.field&lt;/code&gt; is used to access a tuple's field. Another notation is &lt;code&gt;t[i]&lt;/code&gt; to access the &lt;code&gt;i&lt;/code&gt;'th field. Here &lt;code&gt;i&lt;/code&gt; must be a constant integer.</source>
          <target state="translated">元组的赋值运算符复制每个组件。 &lt;code&gt;t.field&lt;/code&gt; 表示法用于访问元组的字段。另一个符号是 &lt;code&gt;t[i]&lt;/code&gt; 访问第 &lt;code&gt;i&lt;/code&gt; 个字段。在这里， &lt;code&gt;i&lt;/code&gt; 必须是一个常数整数。</target>
        </trans-unit>
        <trans-unit id="804f01a733a67cfcf057f33e60859ec41e2582ef" translate="yes" xml:space="preserve">
          <source>The assignment operator needs to be attached to an object or distinct type &lt;code&gt;T&lt;/code&gt;. Its signature has to be &lt;code&gt;(var T, T)&lt;/code&gt;. Example:</source>
          <target state="translated">赋值运算符需要被附加到对象或不同类型 &lt;code&gt;T&lt;/code&gt; 。其签名必须为 &lt;code&gt;(var T, T)&lt;/code&gt; 。例：</target>
        </trans-unit>
        <trans-unit id="57e23a9b21d323dac48595a4bbc01b14afe5e195" translate="yes" xml:space="preserve">
          <source>The assignment statement</source>
          <target state="translated">转让声明</target>
        </trans-unit>
        <trans-unit id="69e1ab703b32f93b8ef72d294804a9cde1a4f4f9" translate="yes" xml:space="preserve">
          <source>The assignment statement assigns a new value to a variable or more generally to a storage location:</source>
          <target state="translated">赋值语句将一个新的值赋给一个变量或更一般的存储位置。</target>
        </trans-unit>
        <trans-unit id="d73476dc2a350d437b107b771d2828a4abae111d" translate="yes" xml:space="preserve">
          <source>The async dispatcher implements the proactor pattern and also has an implementation of IOCP. It implements the proactor pattern for other OS' via the selectors module. Futures are also implemented here, and indeed all the procedures return a future.</source>
          <target state="translated">async dispatcher实现了proactor模式,也有IOCP的实现。它通过选择器模块实现了其他操作系统的proactor模式。这里也实现了期货,事实上所有的程序都会返回一个未来。</target>
        </trans-unit>
        <trans-unit id="b8f9435ff6dfbae860f91fa36f9f0b5fbb9f39e8" translate="yes" xml:space="preserve">
          <source>The available floating point presentation types are:</source>
          <target state="translated">可用的浮点表现类型有:</target>
        </trans-unit>
        <trans-unit id="45e4ec41244c100fe61e74f34e82a254e2fcc455" translate="yes" xml:space="preserve">
          <source>The available integer presentation types are:</source>
          <target state="translated">可用的整数表现类型有:</target>
        </trans-unit>
        <trans-unit id="79db556b1fc1486c80abc68c65a3dd21e5851952" translate="yes" xml:space="preserve">
          <source>The backend must have some logic so that if the currently processed module is from the compilation cache, the &lt;code&gt;ast&lt;/code&gt; field is not accessed. Instead the generated C(++) for the symbol's body needs to be cached too and inserted back into the produced C file. This approach seems to deal with all the outlined problems above.</source>
          <target state="translated">后端必须具有某种逻辑，以便如果当前处理的模块来自编译缓存，则不会访问 &lt;code&gt;ast&lt;/code&gt; 字段。相反，为符号主体生成的C（++）也需要缓存，然后再插入生成的C文件中。这种方法似乎可以解决上述所有问题。</target>
        </trans-unit>
        <trans-unit id="ac450c1d36f3fc4bcff981788349d27816a68afe" translate="yes" xml:space="preserve">
          <source>The base type of the unchecked array may not contain any GC'ed memory but this is currently not checked.</source>
          <target state="translated">未被选中的数组的基本类型可能不包含任何GC'ed内存,但目前没有被选中。</target>
        </trans-unit>
        <trans-unit id="179771803cf0c16d91d22dfc5e7584351c3201db" translate="yes" xml:space="preserve">
          <source>The basic algorithm is &lt;em&gt;Deferred Reference Counting&lt;/em&gt; with cycle detection. References on the stack are not counted for better performance (and easier C code generation). Cycle detection is currently done by a simple mark&amp;amp;sweep GC that has to scan the full (thread local heap). &lt;code&gt;--gc:v2&lt;/code&gt; replaces this with an incremental mark and sweep. That it is not production ready yet, however.</source>
          <target state="translated">基本算法是带有循环检测的&lt;em&gt;递延参考计数&lt;/em&gt;。为了提高性能（并简化C代码生成），不计算堆栈上的引用。当前，循环检测是通过一个简单的标记扫描GC来完成的，该标记必须扫描完整的（线程本地堆）。 &lt;code&gt;--gc:v2&lt;/code&gt; 将其替换为增量标记和扫描。但是它还没有准备好生产。</target>
        </trans-unit>
        <trans-unit id="6d21aca78505b578689d1824dee245b0be8d52e9" translate="yes" xml:space="preserve">
          <source>The basic algorithm is &lt;em&gt;Deferrent Reference Counting&lt;/em&gt; with cycle detection. References on the stack are not counted for better performance and easier C code generation.</source>
          <target state="translated">基本算法是带有循环检测的&lt;em&gt;Deferrent参考计数&lt;/em&gt;。为了更好的性能和更容易的C代码生成，不计算堆栈上的引用。</target>
        </trans-unit>
        <trans-unit id="01e318808654d94079517579df63094331b22821" translate="yes" xml:space="preserve">
          <source>The binary &lt;code&gt;^*&lt;/code&gt; operator is used as a shorthand for 0 or more occurrences separated by its second argument; likewise &lt;code&gt;^+&lt;/code&gt; means 1 or more occurrences: &lt;code&gt;a ^+ b&lt;/code&gt; is short for &lt;code&gt;a (b a)*&lt;/code&gt; and &lt;code&gt;a ^* b&lt;/code&gt; is short for &lt;code&gt;(a (b a)*)?&lt;/code&gt;. Example:</source>
          <target state="translated">二进制 &lt;code&gt;^*&lt;/code&gt; 运算符用作0次或多次出现的简写，并由其第二个参数分隔；同样， &lt;code&gt;^+&lt;/code&gt; 表示1次或多次出现： &lt;code&gt;a ^+ b&lt;/code&gt; 是 &lt;code&gt;a (b a)*&lt;/code&gt; 缩写，而 &lt;code&gt;a ^* b&lt;/code&gt; 是 &lt;code&gt;(a (b a)*)?&lt;/code&gt; 缩写？。例：</target>
        </trans-unit>
        <trans-unit id="10ef37192c4c3ac0d1a132ff61857597f3ebc82a" translate="yes" xml:space="preserve">
          <source>The block statement is a means to group statements to a (named) &lt;code&gt;block&lt;/code&gt;. Inside the block, the &lt;code&gt;break&lt;/code&gt; statement is allowed to leave the block immediately. A &lt;code&gt;break&lt;/code&gt; statement can contain a name of a surrounding block to specify which block is to leave.</source>
          <target state="translated">块语句是将语句分组到（命名的） &lt;code&gt;block&lt;/code&gt; 。在该块内部，可以使用 &lt;code&gt;break&lt;/code&gt; 语句立即离开该块。一个 &lt;code&gt;break&lt;/code&gt; 语句可以包含一围框的名称来指定哪些块是离开。</target>
        </trans-unit>
        <trans-unit id="4ac080ff8c42136d469aa9618ca8dd14a7c9497c" translate="yes" xml:space="preserve">
          <source>The block's &lt;em&gt;label&lt;/em&gt; (&lt;code&gt;myblock&lt;/code&gt; in the example) is optional.</source>
          <target state="translated">块的&lt;em&gt;标签&lt;/em&gt;（ &lt;code&gt;myblock&lt;/code&gt; 中的myblock）是可选的。</target>
        </trans-unit>
        <trans-unit id="390a433a85fe95c30ff748c4a4396344238da974" translate="yes" xml:space="preserve">
          <source>The boolean type is named &lt;span id=&quot;bool_1&quot;&gt;bool&lt;/span&gt; in Nim and can be one of the two pre-defined values &lt;code&gt;true&lt;/code&gt; and &lt;code&gt;false&lt;/code&gt;. Conditions in &lt;code&gt;while&lt;/code&gt;, &lt;code&gt;if&lt;/code&gt;, &lt;code&gt;elif&lt;/code&gt;, &lt;code&gt;when&lt;/code&gt;-statements need to be of type &lt;code&gt;bool&lt;/code&gt;.</source>
          <target state="translated">布尔类型在Nim中称为&lt;span id=&quot;bool_1&quot;&gt;bool&lt;/span&gt;，可以是两个预定义值 &lt;code&gt;true&lt;/code&gt; 和 &lt;code&gt;false&lt;/code&gt; 之一。出条件 &lt;code&gt;while&lt;/code&gt; ， &lt;code&gt;if&lt;/code&gt; ， &lt;code&gt;elif&lt;/code&gt; ， &lt;code&gt;when&lt;/code&gt; -statements需型的 &lt;code&gt;bool&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cc2ce9bd7c5f1b8affcc95224634c4003923668d" translate="yes" xml:space="preserve">
          <source>The borrow pragma can also be used to annotate the distinct type to allow certain builtin operations to be lifted:</source>
          <target state="translated">借用pragma也可以用来注释独特类型,以允许某些内置操作被解除。</target>
        </trans-unit>
        <trans-unit id="f277ec78fce68a5d9247ac9d7120e37c595d4513" translate="yes" xml:space="preserve">
          <source>The built-in &lt;a href=&quot;system#len,TOpenArray&quot;&gt;len&lt;/a&gt; proc returns the array's length. &lt;a href=&quot;system#low&quot;&gt;low(a)&lt;/a&gt; returns the lowest valid index for the array &lt;em&gt;a&lt;/em&gt; and &lt;a href=&quot;system#high&quot;&gt;high(a)&lt;/a&gt; the highest valid index.</source>
          <target state="translated">内置的&lt;a href=&quot;system#len,TOpenArray&quot;&gt;len&lt;/a&gt; proc返回数组的长度。&lt;a href=&quot;system#low&quot;&gt;low（a）&lt;/a&gt;返回数组&lt;em&gt;a&lt;/em&gt;的最低有效索引，&lt;a href=&quot;system#high&quot;&gt;high（a）返回&lt;/a&gt;最高有效索引。</target>
        </trans-unit>
        <trans-unit id="a9933530b06a29cb28167851eb7193a2ebfd89d2" translate="yes" xml:space="preserve">
          <source>The builtin &lt;code&gt;deepCopy&lt;/code&gt; can even clone closures and their environments. See the documentation of &lt;a href=&quot;#parallel-spawn&quot;&gt;spawn&lt;/a&gt; for details.</source>
          <target state="translated">内置的 &lt;code&gt;deepCopy&lt;/code&gt; 甚至可以克隆闭包及其环境。有关详细信息，请参见&lt;a href=&quot;#parallel-spawn&quot;&gt;spawn&lt;/a&gt;的文档。</target>
        </trans-unit>
        <trans-unit id="18e36e8445862a6742d9876a1c8ed0b253932bec" translate="yes" xml:space="preserve">
          <source>The builtin &lt;code&gt;system.finished&lt;/code&gt; can be used to determine if an iterator has finished its operation; no exception is raised on an attempt to invoke an iterator that has already finished its work.</source>
          <target state="translated">内置的 &lt;code&gt;system.finished&lt;/code&gt; 可用于确定迭代器是否已完成其操作；尝试调用已经完成其工作的迭代器不会引发任何异常。</target>
        </trans-unit>
        <trans-unit id="d3ed05fd4188503b5e918e419071d83535ca6d73" translate="yes" xml:space="preserve">
          <source>The builtin document generator &lt;code&gt;nim doc&lt;/code&gt; generates HTML documentation from &lt;code&gt;.nim&lt;/code&gt; source files.</source>
          <target state="translated">内置文档生成器 &lt;code&gt;nim doc&lt;/code&gt; 从 &lt;code&gt;.nim&lt;/code&gt; 源文件生成HTML文档。</target>
        </trans-unit>
        <trans-unit id="03f6f784af17f7bc54b3aa6aaca5046f4b889d50" translate="yes" xml:space="preserve">
          <source>The callback is also called when the future is completed. So you should use &lt;code&gt;finished&lt;/code&gt; to check whether data is available.</source>
          <target state="translated">将来完成时也会调用该回调。因此，您应该使用 &lt;code&gt;finished&lt;/code&gt; 检查数据是否可用。</target>
        </trans-unit>
        <trans-unit id="fda0db03a44323f53881c6ed07ea62221c4d40ac" translate="yes" xml:space="preserve">
          <source>The callback should return one of:</source>
          <target state="translated">回调应该返回以下之一:</target>
        </trans-unit>
        <trans-unit id="98431101a07bff81af63ae772b99a639ecfd446d" translate="yes" xml:space="preserve">
          <source>The caret character (^) is not recognized as an escape character or delimiter. The character is handled completely by the command-line parser in the operating system before being passed to the argv array in the program.</source>
          <target state="translated">卡擦字符(^)不被识别为转义字符或定界符。这个字符在被传递到程序中的argv数组之前,完全由操作系统中的命令行解析器处理。</target>
        </trans-unit>
        <trans-unit id="275705377e0dee3785eb3e50c9fe458fd4e6307b" translate="yes" xml:space="preserve">
          <source>The case statement can deal with integers, other ordinal types and strings. (What an ordinal type is will be explained soon.) For integers or other ordinal types value ranges are also possible:</source>
          <target state="translated">case语句可以处理整数、其他序数类型和字符串。(什么是序数类型,稍后将解释)对于整数或其他序数类型,值范围也是可以的。(什么是序数类型,稍后将解释。)对于整数或其他序数类型,也可以使用值范围。</target>
        </trans-unit>
        <trans-unit id="3cb06e2eb10f97945a6a1dc769debf11f66cc02b" translate="yes" xml:space="preserve">
          <source>The cdecl convention means that a procedure shall use the same convention as the C compiler. Under windows the generated C procedure is declared with the &lt;code&gt;__cdecl&lt;/code&gt; keyword.</source>
          <target state="translated">cdecl约定表示过程应使用与C编译器相同的约定。在Windows下，使用 &lt;code&gt;__cdecl&lt;/code&gt; 关键字声明生成的C过程。</target>
        </trans-unit>
        <trans-unit id="cf2d21d3ec49f1b953444178b23232a5b0355231" translate="yes" xml:space="preserve">
          <source>The character conventionally used by the operating system to separate search patch components (as in PATH), such as ':' for POSIX or ';' for Windows.</source>
          <target state="translated">操作系统通常用来分隔搜索补丁组件的字符(如PATH),如POSIX的':'或Windows的';'。</target>
        </trans-unit>
        <trans-unit id="daf14d8e5ee092bdea92e4c3639c4ffbc471a82f" translate="yes" xml:space="preserve">
          <source>The character type is named &lt;code&gt;char&lt;/code&gt; in Nim. Its size is one byte. Thus it cannot represent an UTF-8 character, but a part of it. The reason for this is efficiency: for the overwhelming majority of use-cases, the resulting programs will still handle UTF-8 properly as UTF-8 was specially designed for this. Another reason is that Nim can support &lt;code&gt;array[char, int]&lt;/code&gt; or &lt;code&gt;set[char]&lt;/code&gt; efficiently as many algorithms rely on this feature. The &lt;em&gt;Rune&lt;/em&gt; type is used for Unicode characters, it can represent any Unicode character. &lt;code&gt;Rune&lt;/code&gt; is declared in the &lt;a href=&quot;unicode&quot;&gt;unicode module&lt;/a&gt;.</source>
          <target state="translated">字符类型在Nim中称为 &lt;code&gt;char&lt;/code&gt; 。它的大小是一个字节。因此，它不能代表UTF-8字符，而是一部分。原因是效率：在绝大多数用例中，生成的程序仍将正确处理UTF-8，因为UTF-8是为此专门设计的。另一个原因是Nim可以有效地支持 &lt;code&gt;array[char, int]&lt;/code&gt; 或 &lt;code&gt;set[char]&lt;/code&gt; 因为许多算法都依赖此功能。的&lt;em&gt;符文&lt;/em&gt;类型用于Unicode字符，它可以代表任何Unicode字符。 &lt;code&gt;Rune&lt;/code&gt; 在&lt;a href=&quot;unicode&quot;&gt;unicode模块中&lt;/a&gt;声明。</target>
        </trans-unit>
        <trans-unit id="012338159832c9f5b5b221070a9909e38b48330b" translate="yes" xml:space="preserve">
          <source>The character used by the operating system to separate pathname components, for example, '/' for POSIX or ':' for the classic Macintosh.</source>
          <target state="translated">操作系统用来分隔路径名组件的字符,例如,POSIX的'/'或经典Macintosh的':'。</target>
        </trans-unit>
        <trans-unit id="8595c8efa2aa083f52c712e47adba9de6178e714" translate="yes" xml:space="preserve">
          <source>The character which separates the base filename from the extension; for example, the '.' in &lt;code&gt;os.nim&lt;/code&gt;.</source>
          <target state="translated">将基本文件名与扩展名分开的字符；例如，&amp;ldquo;。&amp;rdquo; 在 &lt;code&gt;os.nim&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="1e0adad1955b78ddab6f74ee977c388f8e7ad21e" translate="yes" xml:space="preserve">
          <source>The choice of style is up to you.</source>
          <target state="translated">风格的选择由你决定。</target>
        </trans-unit>
        <trans-unit id="78f0b6da6c7f59b81902fe7eaf3cc327e7160fa5" translate="yes" xml:space="preserve">
          <source>The closing &lt;code&gt;@#&lt;/code&gt; needs to be on a line of its own, only preceeded by optional whitespace. This way &lt;code&gt;@#&lt;/code&gt; can otherwise occur in the Nim code as the example shows.</source>
          <target state="translated">&lt;code&gt;@#&lt;/code&gt; 结束处必须自己一行，只能在可选的空白之前。这样， &lt;code&gt;@#&lt;/code&gt; 否则可发生在稔代码作为示例所示。</target>
        </trans-unit>
        <trans-unit id="c2a6d13754b9070007f419ad05ea1ed9a30039c9" translate="yes" xml:space="preserve">
          <source>The code contains a confusing &lt;code&gt;var&lt;/code&gt; declaration.</source>
          <target state="translated">该代码包含一个令人困惑的 &lt;code&gt;var&lt;/code&gt; 声明。</target>
        </trans-unit>
        <trans-unit id="27b7a967cf2c61e046012b3021e3386a2439d280" translate="yes" xml:space="preserve">
          <source>The code contains an unsupported octal sequence.</source>
          <target state="translated">该代码包含一个不支持的八进制序列。</target>
        </trans-unit>
        <trans-unit id="6648d68a40326bd32903c1e98c224eb206ee30b9" translate="yes" xml:space="preserve">
          <source>The code reordering feature can implicitly rearrange procedure, template, and macro definitions along with variable declarations and initializations at the top level scope so that, to a large extent, a programmer should not have to worry about ordering definitions correctly or be forced to use forward declarations to preface definitions inside a module.</source>
          <target state="translated">代码重排序功能可以隐性地将过程、模板、宏定义以及顶层作用域的变量声明和初始化重新排列,因此,在很大程度上,程序员不必担心定义的排序是否正确,也不必被迫在模块内部使用正向声明来为定义作序。</target>
        </trans-unit>
        <trans-unit id="fd31996b685a939214cab476b507369c2a26dbe0" translate="yes" xml:space="preserve">
          <source>The code uses a deprecated symbol.</source>
          <target state="translated">该代码使用了一个废弃的符号。</target>
        </trans-unit>
        <trans-unit id="cadbefb6d63605ada88260c0953028138c9935e0" translate="yes" xml:space="preserve">
          <source>The coercion &lt;code&gt;type(x)&lt;/code&gt; can be used to obtain the type of the given expression &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">强制 &lt;code&gt;type(x)&lt;/code&gt; 可用于获取给定表达式 &lt;code&gt;x&lt;/code&gt; 的类型。</target>
        </trans-unit>
        <trans-unit id="21a01b95e07874cdea952698896961c01561234b" translate="yes" xml:space="preserve">
          <source>The collector checks whether there is still time left for its work after every &lt;code&gt;workPackage&lt;/code&gt;'th iteration. This is currently set to 100 which means that up to 100 objects are traversed and freed before it checks again. Thus &lt;code&gt;workPackage&lt;/code&gt; affects the timing granularity and may need to be tweaked in highly specialized environments or for older hardware.</source>
          <target state="translated">收集器会在每次 &lt;code&gt;workPackage&lt;/code&gt; 的迭代之后检查是否还有剩余的工作时间。当前设置为100，这意味着在再次检查之前将遍历并释放多达100个对象。因此， &lt;code&gt;workPackage&lt;/code&gt; 影响时序粒度，并且可能需要在高度专业化的环境中或针对较旧的硬件进行调整。</target>
        </trans-unit>
        <trans-unit id="79afdb7f6889da26e189c0f3c33044a04e18d142" translate="yes" xml:space="preserve">
          <source>The command invocation syntax also can't have complex expressions as arguments. For example: (&lt;a href=&quot;#anonymous-procs&quot;&gt;anonymous procs&lt;/a&gt;), &lt;code&gt;if&lt;/code&gt;, &lt;code&gt;case&lt;/code&gt; or &lt;code&gt;try&lt;/code&gt;. The (&lt;a href=&quot;#do-notation&quot;&gt;do notation&lt;/a&gt;) is limited, but usable for a single proc (see the example in the corresponding section). Function calls with no arguments still needs () to distinguish between a call and the function itself as a first class value.</source>
          <target state="translated">命令调用语法也不能使用复杂的表达式作为参数。例如：（&lt;a href=&quot;#anonymous-procs&quot;&gt;匿名procs&lt;/a&gt;）， &lt;code&gt;if&lt;/code&gt; ，则为 &lt;code&gt;case&lt;/code&gt; 或 &lt;code&gt;try&lt;/code&gt; 。（&lt;a href=&quot;#do-notation&quot;&gt;符号&lt;/a&gt;）是有限的，但可用于单个proc（请参见相应部分中的示例）。不带参数的函数调用仍然需要（）来区分调用和函数本身，作为第一类值。</target>
        </trans-unit>
        <trans-unit id="bbb3a5b11c8c58cd3db6e75b060c5cb1256d4072" translate="yes" xml:space="preserve">
          <source>The commands to compile to either C, C++ or Objective-C are:</source>
          <target state="translated">编译成C、C++或Objective-C的命令是:。</target>
        </trans-unit>
        <trans-unit id="9147d3666608b3555f82a0b1ee6751419dc98de6" translate="yes" xml:space="preserve">
          <source>The common &lt;code&gt;--&lt;/code&gt; non-option argument delimiter appears as an empty string long option key. &lt;code&gt;OptParser.cmd&lt;/code&gt;, &lt;code&gt;OptParser.pos&lt;/code&gt;, and &lt;code&gt;os.parseCmdLine&lt;/code&gt; may be used to complete parsing in that case.</source>
          <target state="translated">通用 &lt;code&gt;--&lt;/code&gt; 非选项参数定界符显示为空字符串长选项键。在这种情况下，可以使用 &lt;code&gt;OptParser.cmd&lt;/code&gt; ， &lt;code&gt;OptParser.pos&lt;/code&gt; 和 &lt;code&gt;os.parseCmdLine&lt;/code&gt; 来完成解析。</target>
        </trans-unit>
        <trans-unit id="bfdfd6148988703a688e3c05eca6a8eff773759f" translate="yes" xml:space="preserve">
          <source>The common operators &lt;code&gt;+ - * / &amp;lt; &amp;lt;= == != &amp;gt; &amp;gt;=&lt;/code&gt; are defined for floats and follow the IEEE-754 standard.</source>
          <target state="translated">通用运算符 &lt;code&gt;+ - * / &amp;lt; &amp;lt;= == != &amp;gt; &amp;gt;=&lt;/code&gt; 为浮点定义，并遵循IEEE-754标准。</target>
        </trans-unit>
        <trans-unit id="883abbd0b16cdebab167565d80838c6044a1fcf0" translate="yes" xml:space="preserve">
          <source>The common operators &lt;code&gt;+ - * div mod &amp;lt; &amp;lt;= == != &amp;gt; &amp;gt;=&lt;/code&gt; are defined for integers. The &lt;code&gt;and or xor not&lt;/code&gt; operators are also defined for integers, and provide &lt;em&gt;bitwise&lt;/em&gt; operations. Left bit shifting is done with the &lt;code&gt;shl&lt;/code&gt;, right shifting with the &lt;code&gt;shr&lt;/code&gt; operator. Bit shifting operators always treat their arguments as &lt;em&gt;unsigned&lt;/em&gt;. For &lt;span id=&quot;arithmetic-bit-shifts_1&quot;&gt;arithmetic bit shifts&lt;/span&gt; ordinary multiplication or division can be used.</source>
          <target state="translated">通用运算符 &lt;code&gt;+ - * div mod &amp;lt; &amp;lt;= == != &amp;gt; &amp;gt;=&lt;/code&gt; 为整数定义。该 &lt;code&gt;and or xor not&lt;/code&gt; 运营商也在为整数定义，并提供&lt;em&gt;按位&lt;/em&gt;操作。左移使用 &lt;code&gt;shl&lt;/code&gt; 完成，右移使用 &lt;code&gt;shr&lt;/code&gt; 运算符。移位运算符始终将其参数视为&lt;em&gt;unsigned&lt;/em&gt;。对于&lt;span id=&quot;arithmetic-bit-shifts_1&quot;&gt;算术移位，&lt;/span&gt;可以使用普通的乘法或除法。</target>
        </trans-unit>
        <trans-unit id="93c350055cc7a991a83791a66ef96ae8da82f094" translate="yes" xml:space="preserve">
          <source>The compiler checks that each parameter receives exactly one argument.</source>
          <target state="translated">编译器会检查每个参数是否正好收到一个参数。</target>
        </trans-unit>
        <trans-unit id="124083caaf9e67c2924ff4ad019f8bdbdc5c26c4" translate="yes" xml:space="preserve">
          <source>The compiler checks the semantics and produces code &lt;em&gt;only&lt;/em&gt; for the statements that belong to the first condition that evaluates to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">编译器检查语义并&lt;em&gt;仅为&lt;/em&gt;属于第一个条件的语句（其结果为 &lt;code&gt;true&lt;/code&gt; )生成代码。</target>
        </trans-unit>
        <trans-unit id="47314c2a3c9cb869c3d9611f5dd9ca92a7d73b2a" translate="yes" xml:space="preserve">
          <source>The compiler commands select the target backend, but if needed you can &lt;a href=&quot;nimc#cross-compilation&quot;&gt;specify additional switches for cross compilation&lt;/a&gt; to select the target CPU, operative system or compiler/linker commands.</source>
          <target state="translated">编译器命令选择目标后端，但是如果需要，您可以&lt;a href=&quot;nimc#cross-compilation&quot;&gt;指定用于交叉编译的其他开关&lt;/a&gt;以选择目标CPU，操作系统或编译器/链接器命令。</target>
        </trans-unit>
        <trans-unit id="93170a1da8e409d02256d9f99c47fbb958d19414" translate="yes" xml:space="preserve">
          <source>The compiler depends on the System module to work properly and the System module depends on the compiler. Most of the routines listed here use special compiler magic. Each module implicitly imports the System module; it must not be listed explicitly. Because of this there cannot be a user-defined module named &lt;code&gt;system&lt;/code&gt;.</source>
          <target state="translated">编译器取决于System模块才能正常工作，而System模块则取决于编译器。此处列出的大多数例程都使用特殊的编译器魔术。每个模块都隐式导入System模块；不能明确列出。因此，不能有一个名为 &lt;code&gt;system&lt;/code&gt; 的用户定义模块。</target>
        </trans-unit>
        <trans-unit id="20fd635c293115e7e5e8cbd64caf63eed7e31f4f" translate="yes" xml:space="preserve">
          <source>The compiler ensures that every code path initializes variables which contain non nilable pointers. The details of this analysis are still to be specified here.</source>
          <target state="translated">编译器确保每条代码路径都会初始化包含非nilable指针的变量。这个分析的细节在这里还需要具体说明。</target>
        </trans-unit>
        <trans-unit id="24838b6da70bcf6db067073b75a8fadd6fa3eb45" translate="yes" xml:space="preserve">
          <source>The compiler generates code as if the programmer would have written this:</source>
          <target state="translated">编译器生成的代码就像程序员会写这个一样。</target>
        </trans-unit>
        <trans-unit id="7fae9d1a9ed8aeef0ae7bee39888a86acbeeaae5" translate="yes" xml:space="preserve">
          <source>The compiler may not generate any code at all for &lt;code&gt;assert&lt;/code&gt; if it is advised to do so through the &lt;code&gt;-d:release&lt;/code&gt; or &lt;code&gt;--assertions:off&lt;/code&gt;&lt;a href=&quot;nimc#command-line-switches&quot;&gt;command line switches&lt;/a&gt;.</source>
          <target state="translated">如果建议通过 &lt;code&gt;-d:release&lt;/code&gt; 或 &lt;code&gt;--assertions:off&lt;/code&gt; &lt;a href=&quot;nimc#command-line-switches&quot;&gt;命令行开关&lt;/a&gt;这样做，则编译器可能根本不会为 &lt;code&gt;assert&lt;/code&gt; 生成任何代码。</target>
        </trans-unit>
        <trans-unit id="db364455640be314eef1467aaec6fd2d418125f9" translate="yes" xml:space="preserve">
          <source>The compiler needs to be told to generate C++ (command &lt;code&gt;cpp&lt;/code&gt;) for this to work. The conditional symbol &lt;code&gt;cpp&lt;/code&gt; is defined when the compiler emits C++ code.</source>
          <target state="translated">需要告知编译器生成C ++（命令 &lt;code&gt;cpp&lt;/code&gt; ）以使其工作。条件符号 &lt;code&gt;cpp&lt;/code&gt; 是在编译器发出C ++代码时定义的。</target>
        </trans-unit>
        <trans-unit id="b07c704d05cf142e0a3e3c5f7b0076809faa6524" translate="yes" xml:space="preserve">
          <source>The compiler needs to be told to generate Objective C (command &lt;code&gt;objc&lt;/code&gt;) for this to work. The conditional symbol &lt;code&gt;objc&lt;/code&gt; is defined when the compiler emits Objective C code.</source>
          <target state="translated">需要告诉编译器生成目标C（命令 &lt;code&gt;objc&lt;/code&gt; ）以使其工作。当编译器发出目标C代码时，将定义条件符号 &lt;code&gt;objc&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f8805142a67c1fcd5058bf1936f838d762e70095" translate="yes" xml:space="preserve">
          <source>The compiler now rewrites &lt;code&gt;x * 2&lt;/code&gt; as &lt;code&gt;x + x&lt;/code&gt;. The code inside the curlies is the pattern to match against. The operators &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;**&lt;/code&gt;, &lt;code&gt;|&lt;/code&gt;, &lt;code&gt;~&lt;/code&gt; have a special meaning in patterns if they are written in infix notation, so to match verbatim against &lt;code&gt;*&lt;/code&gt; the ordinary function call syntax needs to be used.</source>
          <target state="translated">现在，编译器将 &lt;code&gt;x * 2&lt;/code&gt; 重写为 &lt;code&gt;x + x&lt;/code&gt; 。curlies内部的代码是要匹配的模式。运算符 &lt;code&gt;*&lt;/code&gt; ， &lt;code&gt;**&lt;/code&gt; ， &lt;code&gt;|&lt;/code&gt; ， &lt;code&gt;~&lt;/code&gt; 如果以infix表示法在模式中具有特殊含义，因此要逐字匹配 &lt;code&gt;*&lt;/code&gt; ，需要使用普通的函数调用语法。</target>
        </trans-unit>
        <trans-unit id="98ccaef8e67a887a919921b63fd9651f08d45b7b" translate="yes" xml:space="preserve">
          <source>The compiler optimizes string case statements: A hashing scheme is used for them if several different string constants are used. So code like this is reasonably efficient:</source>
          <target state="translated">编译器优化了字符串案例语句。如果使用了几个不同的字符串常量,就会使用一个散列方案来处理它们。所以这样的代码是相当高效的。</target>
        </trans-unit>
        <trans-unit id="99dc98d2e9fd018605a9070695e4f40f907e1508" translate="yes" xml:space="preserve">
          <source>The compiler produces a hint message that &lt;code&gt;IOError&lt;/code&gt; can be raised. &lt;code&gt;OSError&lt;/code&gt; is not listed as it cannot be raised in the branch the &lt;code&gt;effects&lt;/code&gt; pragma appears in.</source>
          <target state="translated">编译器会生成一条提示消息，提示可以 &lt;code&gt;IOError&lt;/code&gt; 。未列出 &lt;code&gt;OSError&lt;/code&gt; ，因为无法在出现杂物 &lt;code&gt;effects&lt;/code&gt; 的分支中引发它。</target>
        </trans-unit>
        <trans-unit id="0e1191530a1aabbbcf17eb667a751d36496cbed2" translate="yes" xml:space="preserve">
          <source>The compiler supports the built-in stringify operator &lt;code&gt;$&lt;/code&gt; for enumerations. The stringify's result can be controlled by explicitly giving the string values to use:</source>
          <target state="translated">编译器支持内置的stringify运算符 &lt;code&gt;$&lt;/code&gt; 进行枚举。可以通过显式给出要使用的字符串值来控制stringify的结果：</target>
        </trans-unit>
        <trans-unit id="278d7d171283ed12aaddd7862802da6834c8c0bb" translate="yes" xml:space="preserve">
          <source>The compiler then ensures that every access of &lt;code&gt;gdata&lt;/code&gt; is within a &lt;code&gt;locks&lt;/code&gt; section:</source>
          <target state="translated">然后，编译器确保对 &lt;code&gt;gdata&lt;/code&gt; 的每次访问都在 &lt;code&gt;locks&lt;/code&gt; 部分内：</target>
        </trans-unit>
        <trans-unit id="e1c591d42a39fa2cac9b572e36ef028dda7cec6f" translate="yes" xml:space="preserve">
          <source>The compiler's architecture</source>
          <target state="translated">编译器的架构</target>
        </trans-unit>
        <trans-unit id="d997b4ac7c8e54accc0951c93c7af7ae2bdbee79" translate="yes" xml:space="preserve">
          <source>The complementary error function</source>
          <target state="translated">补差函数</target>
        </trans-unit>
        <trans-unit id="5846f2c1b1099d4de8d1900d6964f1db9892caf2" translate="yes" xml:space="preserve">
          <source>The complier will report any failure to evaluate the expression or a possible type mismatch error.</source>
          <target state="translated">编译器将报告任何未能评估表达式或可能的类型不匹配错误。</target>
        </trans-unit>
        <trans-unit id="22e9c95f9ebf3625a28669e8b3ce3192da579bb4" translate="yes" xml:space="preserve">
          <source>The concept is a match if:</source>
          <target state="translated">这个概念是一个匹配的如果。</target>
        </trans-unit>
        <trans-unit id="aaa92c15c23e4f3caae54c3381bbefb039b5333e" translate="yes" xml:space="preserve">
          <source>The concept types can be parametric just like the regular generic types:</source>
          <target state="translated">概念类型可以像普通的通用类型一样是参数化的。</target>
        </trans-unit>
        <trans-unit id="7ec85a5fad9202d978280705ad23fc7951fe5afb" translate="yes" xml:space="preserve">
          <source>The condition in a &lt;code&gt;do while(condition)&lt;/code&gt; statement must be &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">在条件 &lt;code&gt;do while(condition)&lt;/code&gt; 语句必须是 &lt;code&gt;0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="46668a8f385559561fb965d9c9162d27d76feb6a" translate="yes" xml:space="preserve">
          <source>The constant string used by the operating system to refer to the current directory.</source>
          <target state="translated">操作系统用来表示当前目录的常量字符串。</target>
        </trans-unit>
        <trans-unit id="b7d275cdb93fdbf6c6bdd566733c471d5cb82c86" translate="yes" xml:space="preserve">
          <source>The constant string used by the operating system to refer to the parent directory.</source>
          <target state="translated">操作系统用来引用父目录的常量字符串。</target>
        </trans-unit>
        <trans-unit id="2496559a72199a18b9bd92fb0f307658c3e8c8db" translate="yes" xml:space="preserve">
          <source>The constraint can be a concrete type or a type class.</source>
          <target state="translated">约束可以是一个具体的类型,也可以是一个类型类。</target>
        </trans-unit>
        <trans-unit id="bdda80e1481774a2bcf89e333a8a607041b5e8d4" translate="yes" xml:space="preserve">
          <source>The construct &lt;code&gt;identifier&quot;&quot;&quot;string literal&quot;&quot;&quot;&lt;/code&gt; exists too. It is a shortcut for &lt;code&gt;identifier(&quot;&quot;&quot;string literal&quot;&quot;&quot;)&lt;/code&gt;.</source>
          <target state="translated">构造 &lt;code&gt;identifier&quot;&quot;&quot;string literal&quot;&quot;&quot;&lt;/code&gt; 存在。它是 &lt;code&gt;identifier(&quot;&quot;&quot;string literal&quot;&quot;&quot;)&lt;/code&gt; 的快捷方式。</target>
        </trans-unit>
        <trans-unit id="b76daad7f41aa0f12c4252effb99658f3e34679b" translate="yes" xml:space="preserve">
          <source>The construct &lt;code&gt;identifier&quot;string literal&quot;&lt;/code&gt; (without whitespace between the identifier and the opening quotation mark) is a generalized raw string literal. It is a shortcut for the construct &lt;code&gt;identifier(r&quot;string literal&quot;)&lt;/code&gt;, so it denotes a procedure call with a raw string literal as its only argument. Generalized raw string literals are especially convenient for embedding mini languages directly into Nim (for example regular expressions).</source>
          <target state="translated">构造 &lt;code&gt;identifier&quot;string literal&quot;&lt;/code&gt; （标识符和开头引号之间没有空格）是广义的原始字符串文字。它是构造 &lt;code&gt;identifier(r&quot;string literal&quot;)&lt;/code&gt; 的快捷方式，因此它表示将原始字符串文字作为唯一参数的过程调用。通用原始字符串文字对于将迷你语言直接嵌入到Nim中（例如正则表达式）特别方便。</target>
        </trans-unit>
        <trans-unit id="15d06627966f858375d16fcd25aa9c8d53eb89d1" translate="yes" xml:space="preserve">
          <source>The contravariant parameters introduced with the &lt;code&gt;in&lt;/code&gt; modifier are currently useful only when interfacing with imported types having such semantics.</source>
          <target state="translated">当前，仅在与具有这种语义的导入类型进行接口连接时，使用 &lt;code&gt;in&lt;/code&gt; 修饰符引入的反变量参数才有用。</target>
        </trans-unit>
        <trans-unit id="f79116fcf17d026b0e4914fbd53c2223ebb6510b" translate="yes" xml:space="preserve">
          <source>The convertible relation can be relaxed by a user-defined type &lt;span id=&quot;converter_1&quot;&gt;converter&lt;/span&gt;.</source>
          <target state="translated">可以通过用户定义的类型&lt;span id=&quot;converter_1&quot;&gt;转换器&lt;/span&gt;放宽可转换的关系。</target>
        </trans-unit>
        <trans-unit id="b18a614e84b5a50fd0095d557ca3e5d6b4cdd331" translate="yes" xml:space="preserve">
          <source>The crit bit tree can either be used as a mapping from strings to some type &lt;code&gt;T&lt;/code&gt; or as a set of strings if &lt;code&gt;T&lt;/code&gt; is void.</source>
          <target state="translated">临界位树既可以用作从字符串到某种类型 &lt;code&gt;T&lt;/code&gt; 的映射，也可以用作一组字符串（如果 &lt;code&gt;T&lt;/code&gt; 为空）。</target>
        </trans-unit>
        <trans-unit id="9b76fe6e6adda8db66493cbcc5c7f0fd20c378ec" translate="yes" xml:space="preserve">
          <source>The current implementation poses some restrictions for compile time evaluation: Code which contains &lt;code&gt;cast&lt;/code&gt; or makes use of the foreign function interface cannot be evaluated at compile time. Later versions of Nim will support the FFI at compile time.</source>
          <target state="translated">当前的实现对编译时评估提出了一些限制：包含 &lt;code&gt;cast&lt;/code&gt; 或使用外部函数接口的代码无法在编译时评估。Nim的更高版本将在编译时支持FFI。</target>
        </trans-unit>
        <trans-unit id="a150efd164504eebf2c6ca387f4a2724cdddad5b" translate="yes" xml:space="preserve">
          <source>The cycle collector can be en-/disabled independently from the other parts of the GC with &lt;code&gt;GC_enableMarkAndSweep&lt;/code&gt; and &lt;code&gt;GC_disableMarkAndSweep&lt;/code&gt;.</source>
          <target state="translated">可以使用 &lt;code&gt;GC_enableMarkAndSweep&lt;/code&gt; 和 &lt;code&gt;GC_disableMarkAndSweep&lt;/code&gt; 与GC的其他部分独立地启用/禁用循环收集器。</target>
        </trans-unit>
        <trans-unit id="b087f456c58a0b1e2bb211a477a678bd99fae255" translate="yes" xml:space="preserve">
          <source>The default build of a project is a &lt;span id=&quot;debug-build_1&quot;&gt;debug build&lt;/span&gt;. To compile a &lt;span id=&quot;release-build_1&quot;&gt;release build&lt;/span&gt; define the &lt;code&gt;release&lt;/code&gt; symbol:</source>
          <target state="translated">项目的默认构建是&lt;span id=&quot;debug-build_1&quot;&gt;调试构建&lt;/span&gt;。要编译&lt;span id=&quot;release-build_1&quot;&gt;发布版本，请&lt;/span&gt;定义 &lt;code&gt;release&lt;/code&gt; 符号：</target>
        </trans-unit>
        <trans-unit id="d12eb915f38cd1b959d9b90e29441cd8da7737ff" translate="yes" xml:space="preserve">
          <source>The default calling convention is &lt;code&gt;nimcall&lt;/code&gt;, unless it is an inner proc (a proc inside of a proc). For an inner proc an analysis is performed whether it accesses its environment. If it does so, it has the calling convention &lt;code&gt;closure&lt;/code&gt;, otherwise it has the calling convention &lt;code&gt;nimcall&lt;/code&gt;.</source>
          <target state="translated">默认的调用约定是 &lt;code&gt;nimcall&lt;/code&gt; ，除非它是一个内部proc（proc内部的proc）。对于内部过程，将执行是否访问其环境的分析。如果这样做，它将具有调用约定 &lt;code&gt;closure&lt;/code&gt; ，否则将具有调用约定 &lt;code&gt;nimcall&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ce8c7b7d3265aaf66366428beeb806323db1c873" translate="yes" xml:space="preserve">
          <source>The default compiler is defined at the top of &lt;code&gt;config\nim.cfg&lt;/code&gt;. Changing this setting affects the compiler used by &lt;code&gt;koch&lt;/code&gt; to (re)build Nim.</source>
          <target state="translated">默认编译器在 &lt;code&gt;config\nim.cfg&lt;/code&gt; 的顶部定义。更改此设置会影响 &lt;code&gt;koch&lt;/code&gt; 用来（重新）构建Nim 的编译器。</target>
        </trans-unit>
        <trans-unit id="2fb29e1efca282ec617c93b0148451d02698d52e" translate="yes" xml:space="preserve">
          <source>The default configuration (&lt;em&gt;trim=true&lt;/em&gt; and &lt;em&gt;precision=10&lt;/em&gt;) shows the &lt;strong&gt;shortest&lt;/strong&gt; form that precisely (up to a maximum of 10 decimal places) displays the value. For example, 4.100000 will be displayed as 4.1 (which is mathematically identical) whereas 4.1000003 will be displayed as 4.1000003.</source>
          <target state="translated">默认配置（&lt;em&gt;trim = true&lt;/em&gt;和&lt;em&gt;precision = 10&lt;/em&gt;）显示精确显示该值的&lt;strong&gt;最短&lt;/strong&gt;形式（最多10个小数位）。例如，4.100000将显示为4.1（在数学上是相同的），而4.1000003将显示为4.1000003。</target>
        </trans-unit>
        <trans-unit id="7d91717c8150be3c817688d172359eebf60c9b3f" translate="yes" xml:space="preserve">
          <source>The default float type is &lt;code&gt;float&lt;/code&gt;. In the current implementation, &lt;code&gt;float&lt;/code&gt; is always 64-bits.</source>
          <target state="translated">默认的float类型是 &lt;code&gt;float&lt;/code&gt; 。在当前的实现中， &lt;code&gt;float&lt;/code&gt; 始终为64位。</target>
        </trans-unit>
        <trans-unit id="2c1049ba9351f416eaad2423d6f9c80998361c05" translate="yes" xml:space="preserve">
          <source>The default for symbols of entity &lt;code&gt;type&lt;/code&gt;, &lt;code&gt;var&lt;/code&gt;, &lt;code&gt;let&lt;/code&gt; and &lt;code&gt;const&lt;/code&gt; is &lt;code&gt;gensym&lt;/code&gt; and for &lt;code&gt;proc&lt;/code&gt;, &lt;code&gt;iterator&lt;/code&gt;, &lt;code&gt;converter&lt;/code&gt;, &lt;code&gt;template&lt;/code&gt;, &lt;code&gt;macro&lt;/code&gt; is &lt;code&gt;inject&lt;/code&gt;. However, if the name of the entity is passed as a template parameter, it is an inject'ed symbol:</source>
          <target state="translated">对于实体的符号的默认 &lt;code&gt;type&lt;/code&gt; ， &lt;code&gt;var&lt;/code&gt; ， &lt;code&gt;let&lt;/code&gt; 和 &lt;code&gt;const&lt;/code&gt; 是 &lt;code&gt;gensym&lt;/code&gt; 和 &lt;code&gt;proc&lt;/code&gt; ， &lt;code&gt;iterator&lt;/code&gt; ， &lt;code&gt;converter&lt;/code&gt; ， &lt;code&gt;template&lt;/code&gt; ， &lt;code&gt;macro&lt;/code&gt; 是 &lt;code&gt;inject&lt;/code&gt; 。但是，如果实体名称作为模板参数传递，则它是注入符号：</target>
        </trans-unit>
        <trans-unit id="c2e82f3dbf50ec4aead0f830c3d860bcc03915a0" translate="yes" xml:space="preserve">
          <source>The default integer type is &lt;code&gt;int&lt;/code&gt;. Integer literals can have a &lt;em&gt;type suffix&lt;/em&gt; to specify a non-default integer type:</source>
          <target state="translated">默认整数类型为 &lt;code&gt;int&lt;/code&gt; 。整数文字可以具有&lt;em&gt;类型后缀&lt;/em&gt;以指定非默认整数类型：</target>
        </trans-unit>
        <trans-unit id="a938a7c0d5ddba81851d8d833ea57ac0a05a8458" translate="yes" xml:space="preserve">
          <source>The deprecated pragma is used to mark a symbol as deprecated:</source>
          <target state="translated">废弃的pragma用于标记一个符号为废弃的符号。</target>
        </trans-unit>
        <trans-unit id="e86d1f1124b9d68611440bacc4bff7bcfe2f6e0a" translate="yes" xml:space="preserve">
          <source>The difference between 1.0 and the smallest number greater than 1.0 that can be represented in a 32-bit floating-point type.</source>
          <target state="translated">1.0和大于1.0的最小数字之间的差值,可以用32位浮点类型表示。</target>
        </trans-unit>
        <trans-unit id="afc1aa22832c69c45d0caa9362039ca2a87d5b07" translate="yes" xml:space="preserve">
          <source>The difference between 1.0 and the smallest number greater than 1.0 that can be represented in a 64-bit floating-point type.</source>
          <target state="translated">1.0和大于1.0的最小数字之间的差值,可以用64位浮点类型表示。</target>
        </trans-unit>
        <trans-unit id="8d3ea0a55b18000a3ec2d6587062c904d3e896cd" translate="yes" xml:space="preserve">
          <source>The difference between &lt;code&gt;let&lt;/code&gt; and &lt;code&gt;const&lt;/code&gt; is: &lt;code&gt;let&lt;/code&gt; introduces a variable that can not be re-assigned, &lt;code&gt;const&lt;/code&gt; means &quot;enforce compile time evaluation and put it into a data section&quot;:</source>
          <target state="translated">&lt;code&gt;let&lt;/code&gt; 和 &lt;code&gt;const&lt;/code&gt; 之间的区别是： &lt;code&gt;let&lt;/code&gt; 引入了一个无法重新分配的变量， &lt;code&gt;const&lt;/code&gt; 的意思是&amp;ldquo;强制执行编译时评估并将其放入数据部分&amp;rdquo;：</target>
        </trans-unit>
        <trans-unit id="0a74b6801170bf0f38a336281fab4bfa8303a82a" translate="yes" xml:space="preserve">
          <source>The difference of two sets is represented mathematically as &lt;em&gt;A B&lt;/em&gt; and is the set of all objects that are members of &lt;em&gt;s1&lt;/em&gt; and not members of &lt;em&gt;s2&lt;/em&gt;. Example:</source>
          <target state="translated">两组的差在数学上用&lt;em&gt;AB&lt;/em&gt;表示，是&lt;em&gt;s1的&lt;/em&gt;成员而不是&lt;em&gt;s2&lt;/em&gt;的所有对象的集合。例：</target>
        </trans-unit>
        <trans-unit id="7c0c41b3f142cacbbcc66573b8adaf31d489334d" translate="yes" xml:space="preserve">
          <source>The difference with regards to the &lt;a href=&quot;#excl,TOrderedSet%5BA%5D,A&quot;&gt;excl()&lt;/a&gt; proc is that this proc returns &lt;em&gt;true&lt;/em&gt; if &lt;em&gt;key&lt;/em&gt; was not present in &lt;em&gt;s&lt;/em&gt;. Example:</source>
          <target state="translated">关于&lt;a href=&quot;#excl,TOrderedSet%5BA%5D,A&quot;&gt;excl（）&lt;/a&gt; proc 的区别在于，如果&lt;em&gt;s&lt;/em&gt;中不存在&lt;em&gt;key&lt;/em&gt;，则此proc返回&lt;em&gt;true&lt;/em&gt;。例：&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d1de829e0ca997f038aa2fbccf312c02165e0cb7" translate="yes" xml:space="preserve">
          <source>The difference with regards to the &lt;a href=&quot;#excl,TSet%5BA%5D,A&quot;&gt;excl()&lt;/a&gt; proc is that this proc returns &lt;em&gt;true&lt;/em&gt; if &lt;em&gt;key&lt;/em&gt; was not present in &lt;em&gt;s&lt;/em&gt;. Example:</source>
          <target state="translated">关于&lt;a href=&quot;#excl,TSet%5BA%5D,A&quot;&gt;excl（）&lt;/a&gt; proc 的区别在于，如果&lt;em&gt;s&lt;/em&gt;中不存在&lt;em&gt;key&lt;/em&gt;，则此proc返回&lt;em&gt;true&lt;/em&gt;。例：&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="18b21997787778562d6aa4adbaf236a4acd894b9" translate="yes" xml:space="preserve">
          <source>The difference with regards to the &lt;a href=&quot;#incl,TOrderedSet%5BA%5D,A&quot;&gt;incl()&lt;/a&gt; proc is that this proc returns &lt;em&gt;true&lt;/em&gt; if &lt;em&gt;key&lt;/em&gt; was already present in &lt;em&gt;s&lt;/em&gt;. The proc will return false if &lt;em&gt;key&lt;/em&gt; was added as a new value to &lt;em&gt;s&lt;/em&gt; during this call. Example:</source>
          <target state="translated">关于&lt;a href=&quot;#incl,TOrderedSet%5BA%5D,A&quot;&gt;incl（）&lt;/a&gt; proc 的区别是，如果&lt;em&gt;s&lt;/em&gt;中已经存在&lt;em&gt;key&lt;/em&gt;，则此proc返回&lt;em&gt;true&lt;/em&gt;。如果在此调用期间将&lt;em&gt;key&lt;/em&gt;作为新值添加到&lt;em&gt;s&lt;/em&gt;，则proc将返回false 。例：&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9b85f52a313da4c653da005f49f49e563663ab9e" translate="yes" xml:space="preserve">
          <source>The difference with regards to the &lt;a href=&quot;#incl,TSet%5BA%5D,A&quot;&gt;incl()&lt;/a&gt; proc is that this proc returns &lt;em&gt;true&lt;/em&gt; if &lt;em&gt;key&lt;/em&gt; was already present in &lt;em&gt;s&lt;/em&gt;. The proc will return false if &lt;em&gt;key&lt;/em&gt; was added as a new value to &lt;em&gt;s&lt;/em&gt; during this call. Example:</source>
          <target state="translated">关于&lt;a href=&quot;#incl,TSet%5BA%5D,A&quot;&gt;incl（）&lt;/a&gt; proc 的区别是，如果&lt;em&gt;s&lt;/em&gt;中已经存在&lt;em&gt;key&lt;/em&gt;，则此proc返回&lt;em&gt;true&lt;/em&gt;。如果在此调用期间将&lt;em&gt;key&lt;/em&gt;作为新值添加到&lt;em&gt;s&lt;/em&gt;，则proc将返回false 。例：&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="220030e8b435e84f93ba209fa1bb4177a255c969" translate="yes" xml:space="preserve">
          <source>The different format patterns that are supported are documented below.</source>
          <target state="translated">支持的不同格式模式记录如下。</target>
        </trans-unit>
        <trans-unit id="d7d6c6dc11f53e07d9cdc8acaebc2671f78a141c" translate="yes" xml:space="preserve">
          <source>The direct embedding of assembler code into Nim code is supported by the unsafe &lt;code&gt;asm&lt;/code&gt; statement. Identifiers in the assembler code that refer to Nim identifiers shall be enclosed in a special character which can be specified in the statement's pragmas. The default special character is &lt;code&gt;'`'&lt;/code&gt;:</source>
          <target state="translated">不安全的 &lt;code&gt;asm&lt;/code&gt; 语句支持将汇编程序代码直接嵌入到Nim代码中。汇编程序代码中引用Nim标识符的标识符必须用特殊字符括起来，该特殊字符可以在语句的编译指示中指定。默认的特殊字符是 &lt;code&gt;'`'&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="79c14e4edc4e62d3b50ec111744e90c76fe6415b" translate="yes" xml:space="preserve">
          <source>The directory may contain several subdirectories that do not exist yet. The full path is created. If this fails, &lt;em&gt;OSError&lt;/em&gt; is raised. It does &lt;strong&gt;not&lt;/strong&gt; fail if the directory already exists because for most usages this does not indicate an error.</source>
          <target state="translated">该目录可能包含几个尚不存在的子目录。完整路径已创建。如果失败，则引发&lt;em&gt;OSError&lt;/em&gt;。它并&lt;strong&gt;没有&lt;/strong&gt;，如果该目录已经存在，因为大多数情况的使用，这并不表示错误失败。</target>
        </trans-unit>
        <trans-unit id="3d9c316616578336f1d520853682d58bf4e6eb88" translate="yes" xml:space="preserve">
          <source>The dispatcher acts as a kind of event loop. You must call &lt;code&gt;poll&lt;/code&gt; on it (or a function which does so for you such as &lt;code&gt;waitFor&lt;/code&gt; or &lt;code&gt;runForever&lt;/code&gt;) in order to poll for any outstanding events. The underlying implementation is based on epoll on Linux, IO Completion Ports on Windows and select on other operating systems.</source>
          <target state="translated">调度程序充当一种事件循环。您必须对它调用 &lt;code&gt;poll&lt;/code&gt; （或为您调用poll的函数，例如 &lt;code&gt;waitFor&lt;/code&gt; 或 &lt;code&gt;runForever&lt;/code&gt; ）才能轮询任何未完成的事件。基础实现基于Linux上的epoll，Windows上的IO完成端口以及其他操作系统上的select。</target>
        </trans-unit>
        <trans-unit id="ad786784a7a091bc39b8e45514e333722de53121" translate="yes" xml:space="preserve">
          <source>The documentation consists of several documents:</source>
          <target state="translated">该文件由若干文件组成。</target>
        </trans-unit>
        <trans-unit id="37bdec1f204951850d37528255d2ee12a6d8560b" translate="yes" xml:space="preserve">
          <source>The documentation generator is aware of these examples and considers them part of the &lt;code&gt;##&lt;/code&gt; doc comment. As the last step of documentation generation the examples are put into an &lt;code&gt;$file_example.nim&lt;/code&gt; file, compiled and tested. The collected examples are put into their own module to ensure the examples do not refer to non-exported symbols.</source>
          <target state="translated">文档生成器了解这些示例，并将其视为 &lt;code&gt;##&lt;/code&gt; doc注释的一部分。作为生成文档的最后一步，将示例放入 &lt;code&gt;$file_example.nim&lt;/code&gt; 文件中，进行编译和测试。收集的示例将放入其自己的模块中，以确保示例不引用未导出的符号。</target>
        </trans-unit>
        <trans-unit id="1d6f51cc7af628cca8e6d65688dcf5a3aea1a258" translate="yes" xml:space="preserve">
          <source>The effect system (&lt;code&gt;raises: []&lt;/code&gt;) does not work with async procedures.</source>
          <target state="translated">效果系统（ &lt;code&gt;raises: []&lt;/code&gt; ）不适用于异步过程。</target>
        </trans-unit>
        <trans-unit id="c5c6ad0fa17f28cab354438579a552a5a86576fc" translate="yes" xml:space="preserve">
          <source>The empty &lt;a href=&quot;#procedures-discard-statement&quot;&gt;discard statement&lt;/a&gt; is a &lt;em&gt;do nothing&lt;/em&gt; statement. The compiler knows that a case statement with an else part cannot fail and thus the error disappears. Note that it is impossible to cover all possible string values: that is why string cases always need an &lt;code&gt;else&lt;/code&gt; branch.</source>
          <target state="translated">空的&lt;a href=&quot;#procedures-discard-statement&quot;&gt;废弃语句&lt;/a&gt;是&amp;ldquo; &lt;em&gt;不执行&amp;rdquo;&lt;/em&gt;语句。编译器知道带有else部分的case语句不会失败，因此错误消失了。注意，不可能覆盖所有可能的字符串值：这就是为什么字符串大小写总是需要 &lt;code&gt;else&lt;/code&gt; 分支的原因。</target>
        </trans-unit>
        <trans-unit id="b0d537489684ccaa630656ec96401b6693a6022d" translate="yes" xml:space="preserve">
          <source>The empty &lt;code&gt;[]&lt;/code&gt; subscript notation can be used to &lt;em&gt;derefer&lt;/em&gt; a reference, meaning to retrieve the item the reference points to. The &lt;code&gt;.&lt;/code&gt; (access a tuple/object field operator) and &lt;code&gt;[]&lt;/code&gt; (array/string/sequence index operator) operators perform implicit dereferencing operations for reference types:</source>
          <target state="translated">空的 &lt;code&gt;[]&lt;/code&gt; 下标符号可用于&lt;em&gt;取消&lt;/em&gt;引用参考，表示检索引用指向的项目。的 &lt;code&gt;.&lt;/code&gt; （访问元组/对象字段运算符）和 &lt;code&gt;[]&lt;/code&gt; （数组/字符串/序列索引运算符）运算符对引用类型执行隐式解引用操作：</target>
        </trans-unit>
        <trans-unit id="ffc8ff3a5600abff18d1541feff45aa3dbf706b3" translate="yes" xml:space="preserve">
          <source>The empty &lt;code&gt;except&lt;/code&gt; part is executed if there is an exception that is not explicitly listed. It is similar to an &lt;code&gt;else&lt;/code&gt; part in &lt;code&gt;if&lt;/code&gt; statements.</source>
          <target state="translated">如果存在未明确列出的异常，则将执行空的 &lt;code&gt;except&lt;/code&gt; 部分。它类似于 &lt;code&gt;if&lt;/code&gt; 语句中的 &lt;code&gt;else&lt;/code&gt; 部分。</target>
        </trans-unit>
        <trans-unit id="65c91587bac500ac8c7817439d895663e0f5eef7" translate="yes" xml:space="preserve">
          <source>The empty &lt;span id=&quot;except_1&quot;&gt;except&lt;/span&gt; clause is executed if there is an exception that is not listed otherwise. It is similar to an &lt;code&gt;else&lt;/code&gt; clause in &lt;code&gt;if&lt;/code&gt; statements.</source>
          <target state="translated">如果存在例外（否则未列出），则执行空的&lt;span id=&quot;except_1&quot;&gt;except&lt;/span&gt;子句。它类似于 &lt;code&gt;if&lt;/code&gt; 语句中的 &lt;code&gt;else&lt;/code&gt; 子句。</target>
        </trans-unit>
        <trans-unit id="0c1d4d209aa8e17c99e2eb2160eabae179a2322b" translate="yes" xml:space="preserve">
          <source>The empty table can be written &lt;code&gt;{:}&lt;/code&gt; (in contrast to the empty set which is &lt;code&gt;{}&lt;/code&gt;) which is thus another way to write as the empty array constructor &lt;code&gt;[]&lt;/code&gt;. This slightly unusual way of supporting tables has lots of advantages:</source>
          <target state="translated">空表可以写成 &lt;code&gt;{:}&lt;/code&gt; （与空集 &lt;code&gt;{}&lt;/code&gt; 相比），这是写成空数组构造函数 &lt;code&gt;[]&lt;/code&gt; 的另一种方式。这种稍微不寻常的表支持方式有很多优点：</target>
        </trans-unit>
        <trans-unit id="64a046b2305ba9ca93a6dc63513571f740cfbd0a" translate="yes" xml:space="preserve">
          <source>The error function</source>
          <target state="translated">错误函数</target>
        </trans-unit>
        <trans-unit id="07d3a0d65c780c53b944c8f6088eecf4c5ac94f3" translate="yes" xml:space="preserve">
          <source>The example also shows that a proc's body can consist of a single expression whose value is then returned implicitly.</source>
          <target state="translated">这个例子还表明,proc的主体可以由一个表达式组成,然后隐式返回其值。</target>
        </trans-unit>
        <trans-unit id="1ee7135c60a97c9109575a0365bdcd4548a56a80" translate="yes" xml:space="preserve">
          <source>The example is silly, since a vector is better modelled by a tuple which already provides &lt;code&gt;v[]&lt;/code&gt; access.</source>
          <target state="translated">这个例子很愚蠢，因为向量已经由提供 &lt;code&gt;v[]&lt;/code&gt; 访问的元组更好地建模了。</target>
        </trans-unit>
        <trans-unit id="5c91aee76f225823a200aa2713bba977502db3e5" translate="yes" xml:space="preserve">
          <source>The example shows a generic binary tree. Depending on context, the brackets are used either to introduce type parameters or to instantiate a generic proc, iterator or type. As the example shows, generics work with overloading: the best match of &lt;code&gt;add&lt;/code&gt; is used. The built-in &lt;code&gt;add&lt;/code&gt; procedure for sequences is not hidden and is used in the &lt;code&gt;preorder&lt;/code&gt; iterator.</source>
          <target state="translated">该示例显示了通用的二叉树。根据上下文，方括号用于引入类型参数或实例化通用proc，迭代器或类型。如示例所示，泛型可用于重载：使用 &lt;code&gt;add&lt;/code&gt; 的最佳匹配。序列的内置 &lt;code&gt;add&lt;/code&gt; 过程未隐藏，而是在 &lt;code&gt;preorder&lt;/code&gt; 迭代器中使用。</target>
        </trans-unit>
        <trans-unit id="f68d69ad3fae0ae0b097e4eebbbc1987f9438cae" translate="yes" xml:space="preserve">
          <source>The example uses a while loop to keep asking the users for their name, as long as the user types in nothing (only presses RETURN).</source>
          <target state="translated">这个例子使用了一个 while 循环,只要用户不输入任何内容(只按 RETURN),就会一直询问用户的名字。</target>
        </trans-unit>
        <trans-unit id="9e69f04e6b758773caa47fda144764cd2b769f26" translate="yes" xml:space="preserve">
          <source>The exception is &lt;em&gt;consumed&lt;/em&gt; in an &lt;code&gt;except&lt;/code&gt; part. If an exception is not handled, it is propagated through the call stack. This means that often the rest of the procedure - that is not within a &lt;code&gt;finally&lt;/code&gt; clause - is not executed (if an exception occurs).</source>
          <target state="translated">唯一的例外是&lt;em&gt;消耗&lt;/em&gt;在 &lt;code&gt;except&lt;/code&gt; 部分。如果未处理异常，它将通过调用堆栈传播。这意味着通常不会执行过程的其余部分（不在 &lt;code&gt;finally&lt;/code&gt; 子句中）（如果发生异常）。</target>
        </trans-unit>
        <trans-unit id="ff3ed48d6f7129871b8222e272bcbad9f0531ac9" translate="yes" xml:space="preserve">
          <source>The exception is &lt;em&gt;consumed&lt;/em&gt; in an exception handler. However, an exception handler may raise another exception. If the exception is not handled, it is propagated through the call stack. This means that often the rest of the procedure - that is not within a &lt;code&gt;finally&lt;/code&gt; clause - is not executed (if an exception occurs).</source>
          <target state="translated">唯一的例外是&lt;em&gt;消耗&lt;/em&gt;在异常处理。但是，异常处理程序可能会引发另一个异常。如果未处理该异常，它将通过调用堆栈传播。这意味着通常不会执行过程的其余部分（不在 &lt;code&gt;finally&lt;/code&gt; 子句中）（如果发生异常）。</target>
        </trans-unit>
        <trans-unit id="c1d798ae9282ab3c90cac1e64ce5600a12ced505" translate="yes" xml:space="preserve">
          <source>The exception tracking is part of Nim's &lt;span id=&quot;effect-system_1&quot;&gt;effect system&lt;/span&gt;. Raising an exception is an &lt;em&gt;effect&lt;/em&gt;. Other effects can also be defined. A user defined effect is a means to &lt;em&gt;tag&lt;/em&gt; a routine and to perform checks against this tag:</source>
          <target state="translated">异常跟踪是Nim &lt;span id=&quot;effect-system_1&quot;&gt;效果系统的一部分&lt;/span&gt;。引发例外是一种&lt;em&gt;效果&lt;/em&gt;。也可以定义其他效果。用户定义的效果是一种&lt;em&gt;标记&lt;/em&gt;例程并对该标记执行检查的方法：</target>
        </trans-unit>
        <trans-unit id="f4d218a789a1df54f173c0ece34a43f3b86bc503" translate="yes" xml:space="preserve">
          <source>The exception tree is defined in the &lt;a href=&quot;system&quot;&gt;system&lt;/a&gt; module. Every exception inherits from &lt;code&gt;system.Exception&lt;/code&gt;. Exceptions that indicate programming bugs inherit from &lt;code&gt;system.Defect&lt;/code&gt; (which is a subtype of &lt;code&gt;Exception&lt;/code&gt;) and are stricly speaking not catchable as they can also be mapped to an operation that terminates the whole process. Exceptions that indicate any other runtime error that can be caught inherit from &lt;code&gt;system.CatchableError&lt;/code&gt; (which is a subtype of &lt;code&gt;Exception&lt;/code&gt;).</source>
          <target state="translated">异常树在&lt;a href=&quot;system&quot;&gt;系统&lt;/a&gt;模块中定义。每个异常都从 &lt;code&gt;system.Exception&lt;/code&gt; 继承。指示编程错误的异常继承自 &lt;code&gt;system.Defect&lt;/code&gt; （这是 &lt;code&gt;Exception&lt;/code&gt; 的子类型），并且严格来讲不能捕获，因为它们也可以映射到终止整个过程的操作。指示可以捕获的任何其他运行时错误的 &lt;code&gt;Exception&lt;/code&gt; 将从 &lt;code&gt;system.CatchableError&lt;/code&gt; （这是Exception的子类型）继承。</target>
        </trans-unit>
        <trans-unit id="8eb9fe59b5acee224134869a4fa8ee343bb10bba" translate="yes" xml:space="preserve">
          <source>The expression &lt;code&gt;x&lt;/code&gt; in &lt;code&gt;x.f&lt;/code&gt; needs to be semantically checked (that means symbol lookup and type checking) before it can be decided that it needs to be rewritten to &lt;code&gt;f(x)&lt;/code&gt;. Therefore the dot syntax has some limitations when it is used to invoke templates/macros:</source>
          <target state="translated">表达式 &lt;code&gt;x&lt;/code&gt; 在 &lt;code&gt;x.f&lt;/code&gt; 需要被检查语义（即手段符号查找和类型检查）之前，可以决定它需要被重写为 &lt;code&gt;f(x)&lt;/code&gt; 。因此，点语法在用于调用模板/宏时会受到一些限制：</target>
        </trans-unit>
        <trans-unit id="5d1f3451fa30a273a7f6aed76323af4d8616546f" translate="yes" xml:space="preserve">
          <source>The extended means that comments starting with &lt;em&gt;#&lt;/em&gt; and whitespace are ignored.</source>
          <target state="translated">扩展意味着将忽略以&lt;em&gt;＃&lt;/em&gt;和空格开头的注释。</target>
        </trans-unit>
        <trans-unit id="12b4cab5727b122b7b1ec87cba8d2831f9aab5a6" translate="yes" xml:space="preserve">
          <source>The field identifiers inside a tuple or object definition are valid in the following places:</source>
          <target state="translated">元组或对象定义中的字段标识符在以下地方有效。</target>
        </trans-unit>
        <trans-unit id="dd916f7a49d8a7ac10551fea591882cb2dbe45da" translate="yes" xml:space="preserve">
          <source>The file &lt;code&gt;examples/htmlrefs.nim&lt;/code&gt; demonstrates how to use the XML parser to accomplish another simple task: To determine all the links an HTML document contains.</source>
          <target state="translated">文件 &lt;code&gt;examples/htmlrefs.nim&lt;/code&gt; 演示了如何使用XML解析器完成另一个简单的任务：确定HTML文档包含的所有链接。</target>
        </trans-unit>
        <trans-unit id="20888f5db03e3bbd07212160a3014e7495057d4b" translate="yes" xml:space="preserve">
          <source>The file &lt;code&gt;examples/htmltitle.nim&lt;/code&gt; demonstrates how to use the XML parser to accomplish a simple task: To determine the title of an HTML document.</source>
          <target state="translated">文件 &lt;code&gt;examples/htmltitle.nim&lt;/code&gt; 演示了如何使用XML解析器来完成一个简单的任务：确定HTML文档的标题。</target>
        </trans-unit>
        <trans-unit id="787b89eaa57a97560754c43aa4b06898c7b48aec" translate="yes" xml:space="preserve">
          <source>The file extension of a script file. For example: &quot;&quot; for POSIX, &quot;bat&quot; on Windows.</source>
          <target state="translated">脚本文件的文件扩展名。例如:POSIX的&quot;&quot;,Windows的 &quot;bat&quot;。&quot;&quot;代表POSIX,&quot;bat &quot;代表Windows。</target>
        </trans-unit>
        <trans-unit id="8875b78032e0936292139b8d9ad9a639776438c6" translate="yes" xml:space="preserve">
          <source>The file extension of native executables. For example: &quot;&quot; for POSIX, &quot;exe&quot; on Windows.</source>
          <target state="translated">本机可执行文件的文件扩展名。例如,POSIX的&quot;&quot;,Windows的 &quot;exe&quot;。POSIX的&quot;&quot;,Windows的 &quot;exe&quot;。</target>
        </trans-unit>
        <trans-unit id="aa1522384259bb7f728de722e2a3a3b90755fa75" translate="yes" xml:space="preserve">
          <source>The file mode when opening a file.</source>
          <target state="translated">打开文件时的文件模式。</target>
        </trans-unit>
        <trans-unit id="b0d5634247976656f5fce2a230b840835d3dfc38" translate="yes" xml:space="preserve">
          <source>The file you want to perform the query on. Usually you will pass in the same value as &lt;strong&gt;proj.nim&lt;/strong&gt;.</source>
          <target state="translated">您要对其执行查询的文件。通常，您将传递与&lt;strong&gt;proj.nim&lt;/strong&gt;相同的值。</target>
        </trans-unit>
        <trans-unit id="d49d4484596c8b0e0159eb69ef8f9c586d3b72f8" translate="yes" xml:space="preserve">
          <source>The filter transforms this into:</source>
          <target state="translated">滤波器将其转化为。</target>
        </trans-unit>
        <trans-unit id="ca2479d6b8b610f51a5a98ec6a8fac67b9578c0a" translate="yes" xml:space="preserve">
          <source>The final layer is the async await transformation. This allows you to write asynchronous code in a synchronous style and works similar to C#'s await. The transformation works by converting any async procedures into an iterator.</source>
          <target state="translated">最后一层是async await转换。这允许你以同步的风格编写异步代码,其工作原理类似于C#的 await。该转换通过将任何异步过程转换为迭代器来工作。</target>
        </trans-unit>
        <trans-unit id="92e24af529f18eee0612283d52e69f9a932a8269" translate="yes" xml:space="preserve">
          <source>The first command runs the Nim compiler with three special options to avoid generating a &lt;code&gt;main()&lt;/code&gt; function in the generated files, avoid linking the object files into a final binary, and explicitly generate a header file for C integration. All the generated files are placed into the &lt;code&gt;nimcache&lt;/code&gt; directory. That's why the next command compiles the &lt;code&gt;maths.c&lt;/code&gt; source plus all the &lt;code&gt;.c&lt;/code&gt; files form &lt;code&gt;nimcache&lt;/code&gt;. In addition to this path, you also have to tell the C compiler where to find Nim's &lt;code&gt;nimbase.h&lt;/code&gt; header file.</source>
          <target state="translated">第一个命令使用三个特殊选项运行Nim编译器，以避免在生成的文件中生成 &lt;code&gt;main()&lt;/code&gt; 函数，避免将目标文件链接到最终二进制文件中，并显式生成用于C集成的头文件。所有生成的文件都放置在 &lt;code&gt;nimcache&lt;/code&gt; 目录中。这就是为什么下 &lt;code&gt;maths.c&lt;/code&gt; 命令会编译maths.c源代码以及所有 &lt;code&gt;.c&lt;/code&gt; 文件形式 &lt;code&gt;nimcache&lt;/code&gt; 的原因。除了此路径外，您还必须告诉C编译器在哪里可以找到Nim的 &lt;code&gt;nimbase.h&lt;/code&gt; 头文件。</target>
        </trans-unit>
        <trans-unit id="2e1aabe2958ba075f566d5962b4d499e691da35a" translate="yes" xml:space="preserve">
          <source>The first line indicates the main project file.</source>
          <target state="translated">第一行表示主项目文件。</target>
        </trans-unit>
        <trans-unit id="070b4e293fffd6ce73b8fe7be23fcf1de6e8b78b" translate="yes" xml:space="preserve">
          <source>The first program</source>
          <target state="translated">第一个项目</target>
        </trans-unit>
        <trans-unit id="d0b3d98d639136123acdde78f568ba55378801a8" translate="yes" xml:space="preserve">
          <source>The first thing to note is that all callable types have at least a comma, even if they don't have any parameters. If there are parameters, they are represented by their types and will be comma separated. To the plain symbol a suffix may be added depending on the type of the callable:</source>
          <target state="translated">首先要注意的是,所有的可调用类型都至少有一个逗号,即使它们没有任何参数。如果有参数,它们由它们的类型来表示,并且会用逗号来分隔。根据可调用类型的不同,可以在普通符号上添加一个后缀。</target>
        </trans-unit>
        <trans-unit id="4999312ef44c80455b502761b700c78c2fa7ee69" translate="yes" xml:space="preserve">
          <source>The first thing you will always need to do in order to start using sockets, is to create a new instance of the &lt;code&gt;Socket&lt;/code&gt; type using the &lt;code&gt;newSocket&lt;/code&gt; procedure.</source>
          <target state="translated">为了开始使用套接字，您始终需要做的第一件事是使用 &lt;code&gt;newSocket&lt;/code&gt; 过程创建 &lt;code&gt;Socket&lt;/code&gt; 类型的新实例。</target>
        </trans-unit>
        <trans-unit id="492b47655f6079de4ef1caff7c3c1bff381df22c" translate="yes" xml:space="preserve">
          <source>The first version uses &lt;em&gt;cmp&lt;/em&gt; to compare the elements. The expected return values are the same as that of system.cmp. The second version uses the default comparison function &lt;em&gt;cmp&lt;/em&gt;.</source>
          <target state="translated">第一个版本使用&lt;em&gt;cmp&lt;/em&gt;比较元素。预期的返回值与system.cmp相同。第二个版本使用默认的比较功能&lt;em&gt;cmp&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="f04db68a5b3cac0d3a181a32ee15094e36574928" translate="yes" xml:space="preserve">
          <source>The following Nim code:</source>
          <target state="translated">以下是Nim代码。</target>
        </trans-unit>
        <trans-unit id="7ffd87a515c30c8b2fec87be6689a08608b581e5" translate="yes" xml:space="preserve">
          <source>The following algorithm (in pseudo-code) determines whether two types are equal with no respect to &lt;code&gt;distinct&lt;/code&gt; types. For brevity the cycle check with an auxiliary set &lt;code&gt;s&lt;/code&gt; is omitted:</source>
          <target state="translated">以下算法（用伪代码）确定两种类型是否相等，而与 &lt;code&gt;distinct&lt;/code&gt; 类型无关。为简便起见，省略了带有辅助集 &lt;code&gt;s&lt;/code&gt; 的循环检查：</target>
        </trans-unit>
        <trans-unit id="6090c7cb57b21b2858f8d3bdfeddde8fc3e0c835" translate="yes" xml:space="preserve">
          <source>The following builtin procs cannot be overloaded for reasons of implementation simplicity (they require specialized semantic checking):</source>
          <target state="translated">由于实现简单的原因,以下内置的procs不能被重载(它们需要专门的语义检查)。</target>
        </trans-unit>
        <trans-unit id="d491fd2b65326bcc2d9548ada2c065f112cca208" translate="yes" xml:space="preserve">
          <source>The following code:</source>
          <target state="translated">以下代码:</target>
        </trans-unit>
        <trans-unit id="9e6abf51c6a7caaa00936172c084814413d0375a" translate="yes" xml:space="preserve">
          <source>The following dot operators are available:</source>
          <target state="translated">以下是可用的点运算符。</target>
        </trans-unit>
        <trans-unit id="64478c18e3d0e98035bc04ab8a881a14b95dcc0f" translate="yes" xml:space="preserve">
          <source>The following example demonstrates a simple chat server.</source>
          <target state="translated">下面的例子演示了一个简单的聊天服务器。</target>
        </trans-unit>
        <trans-unit id="0f231e3e3462123dc4c8a24dcb21c49c8592a8ba" translate="yes" xml:space="preserve">
          <source>The following example demonstrates loading a function called 'greet' from a library that is determined at runtime based upon a language choice. If the library fails to load or the function 'greet' is not found, it quits with a failure error code.</source>
          <target state="translated">下面的例子演示了从一个库中加载一个名为'greet'的函数,这个函数是在运行时根据语言选择确定的。如果库加载失败或没有找到函数'greet',它将以失败的错误代码退出。</target>
        </trans-unit>
        <trans-unit id="1d58b86348511b493c86a97949db3309ab3fe22e" translate="yes" xml:space="preserve">
          <source>The following example demonstrates logging to three different handlers simultaneously:</source>
          <target state="translated">下面的例子演示了同时记录到三个不同的处理程序。</target>
        </trans-unit>
        <trans-unit id="cf3bc2b5c483a0603436689403c8ba9fb562644c" translate="yes" xml:space="preserve">
          <source>The following example implements a powerful &lt;code&gt;debug&lt;/code&gt; command that accepts a variable number of arguments:</source>
          <target state="translated">以下示例实现了功能强大的 &lt;code&gt;debug&lt;/code&gt; 命令，该命令接受可变数量的参数：</target>
        </trans-unit>
        <trans-unit id="4f734436e3f885c81c0eadfbb6a2b481609c6a63" translate="yes" xml:space="preserve">
          <source>The following example outlines a macro that generates a lexical analyzer from regular expressions:</source>
          <target state="translated">下面的例子概述了一个从正则表达式生成词法分析器的宏。</target>
        </trans-unit>
        <trans-unit id="13db42d616e29834b46f311e3a54ec91b9956d97" translate="yes" xml:space="preserve">
          <source>The following example shows a generic binary tree can be modelled:</source>
          <target state="translated">下面的例子显示了一个通用的二叉树可以被建模。</target>
        </trans-unit>
        <trans-unit id="873ce1a1fdbf3cb02ed243f39b15af534c75db54" translate="yes" xml:space="preserve">
          <source>The following example shows how some form of hoisting can be implemented:</source>
          <target state="translated">下面的例子展示了如何实现某种形式的吊装。</target>
        </trans-unit>
        <trans-unit id="a71a0ac5c57a9a249cd9d88a6571b08a6d33aaff" translate="yes" xml:space="preserve">
          <source>The following example shows how some simple partial evaluation can be implemented with term rewriting:</source>
          <target state="translated">下面的例子展示了如何用术语改写来实现一些简单的局部评价。</target>
        </trans-unit>
        <trans-unit id="49a73336f3c49f017bc0c2b05195fd5ec881be73" translate="yes" xml:space="preserve">
          <source>The following examples will generate documentation for the below contrived &lt;em&gt;Nim&lt;/em&gt; module, aptly named 'sample.nim'</source>
          <target state="translated">以下示例将为以下人为设计的&lt;em&gt;Nim&lt;/em&gt;模块生成文档，恰当地命名为&amp;ldquo; sample.nim&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="bca8bd37c432e705556c08bdad3554df72311569" translate="yes" xml:space="preserve">
          <source>The following floating point types are pre-defined:</source>
          <target state="translated">以下是预先定义的浮点类型。</target>
        </trans-unit>
        <trans-unit id="e001b72ea1919b9c8b5454d3e5745443232dfc3d" translate="yes" xml:space="preserve">
          <source>The following keywords are reserved and cannot be used as identifiers:</source>
          <target state="translated">以下关键词是保留的,不能作为标识符使用。</target>
        </trans-unit>
        <trans-unit id="7a481f800b73584de7da49ba29d51edc5e8e325d" translate="yes" xml:space="preserve">
          <source>The following nim code:</source>
          <target state="translated">以下是nim代码。</target>
        </trans-unit>
        <trans-unit id="6a498725f77daa319527cf92f4474c6333dfd7c1" translate="yes" xml:space="preserve">
          <source>The following paragraphs are mostly a reminder for myself. Things to keep in mind:</source>
          <target state="translated">以下几段主要是提醒自己。要记住的事情。</target>
        </trans-unit>
        <trans-unit id="61304b559e87418b6d1e3732c6eb734eea6a3b9b" translate="yes" xml:space="preserve">
          <source>The following section defines several relations on types that are needed to describe the type checking done by the compiler.</source>
          <target state="translated">下面一节定义了几个关于类型的关系,这些关系是描述编译器进行类型检查所需要的。</target>
        </trans-unit>
        <trans-unit id="9926ea103ae5593a38a4d6fb91b32805b8670e76" translate="yes" xml:space="preserve">
          <source>The following sections define the expected output for each kind of symbol for which idetools returns valid output.</source>
          <target state="translated">以下部分定义了idetools返回有效输出的每一种符号的预期输出。</target>
        </trans-unit>
        <trans-unit id="6af8e1a2f34a50e4507418236b89fc3d2ccf3867" translate="yes" xml:space="preserve">
          <source>The following sections describe the use of each of the metacharacters.</source>
          <target state="translated">下面的章节将描述每个元字符的使用。</target>
        </trans-unit>
        <trans-unit id="525a807668897271f1a9b9de59f3fdf8f64551a7" translate="yes" xml:space="preserve">
          <source>The following strings denote other tokens:</source>
          <target state="translated">以下字符串表示其他令牌。</target>
        </trans-unit>
        <trans-unit id="fb3d56eb3ea6e9604bb48a3710981f35773bad09" translate="yes" xml:space="preserve">
          <source>The format string to turn a filename into a &lt;span id=&quot;dll_1&quot;&gt;DLL&lt;/span&gt; file (also called &lt;span id=&quot;shared-object_1&quot;&gt;shared object&lt;/span&gt; on some operating systems).</source>
          <target state="translated">将文件名转换为&lt;span id=&quot;dll_1&quot;&gt;DLL&lt;/span&gt;文件的格式字符串（在某些操作系统上也称为&lt;span id=&quot;shared-object_1&quot;&gt;共享&lt;/span&gt;&lt;span id=&quot;dll_1&quot;&gt;库&lt;/span&gt;）。</target>
        </trans-unit>
        <trans-unit id="e0651b47a0b75f9bee920150d8eee4c5416bccac" translate="yes" xml:space="preserve">
          <source>The fourth column will be the empty string if the iterator is being defined, since at that point in the file the parser hasn't processed the full line yet. The signature will be returned complete in posterior instances of the iterator.</source>
          <target state="translated">如果正在定义迭代器,第四列将是空字符串,因为在文件的那个点上,解析器还没有处理完整的行。在迭代器的后置实例中,签名将被完整返回。</target>
        </trans-unit>
        <trans-unit id="44fc97c45a76e00051690505a1a829c9f330d1aa" translate="yes" xml:space="preserve">
          <source>The fourth column will be the empty string if the macro is being defined, since at that point in the file the parser hasn't processed the full line yet. The signature will be returned complete in posterior instances of the macro.</source>
          <target state="translated">如果正在定义宏,第四列将是空字符串,因为在文件的那个点上,解析器还没有处理完整的行。在宏的后置实例中,签名将被完整地返回。</target>
        </trans-unit>
        <trans-unit id="d08eba1a7248e709a58efba0473c7cce761f8eca" translate="yes" xml:space="preserve">
          <source>The fourth column will be the empty string if the method is being defined, since at that point in the file the parser hasn't processed the full line yet. The signature will be returned complete in posterior instances of the method.</source>
          <target state="translated">如果正在定义方法,第四列将是空字符串,因为在文件的这一点上,解析器还没有处理完整的行。在该方法的后置实例中,签名将被完整地返回。</target>
        </trans-unit>
        <trans-unit id="9cac080ce5d18f814923daa287cef0ac2f3d19be" translate="yes" xml:space="preserve">
          <source>The fourth column will be the empty string if the proc is being defined, since at that point in the file the parser hasn't processed the full line yet. The signature will be returned complete in posterior instances of the proc.</source>
          <target state="translated">如果正在定义proc,第四列将是空字符串,因为在文件中的这一点上,解析器还没有处理完整的行。在proc的后置实例中,签名将被完整地返回。</target>
        </trans-unit>
        <trans-unit id="54e7544248ea9ef4bea128a267709875e2c3f3de" translate="yes" xml:space="preserve">
          <source>The fourth column will be the empty string if the template is being defined, since at that point in the file the parser hasn't processed the full line yet. The signature will be returned complete in posterior instances of the template.</source>
          <target state="translated">如果正在定义模板,第四列将是空字符串,因为在文件的这一点上,解析器还没有处理完整的行。在模板的后置实例中,签名将被完整地返回。</target>
        </trans-unit>
        <trans-unit id="55c1deefa556120681916d6951582e608271f06c" translate="yes" xml:space="preserve">
          <source>The fourth use of backslash is for certain &lt;span id=&quot;simple-assertions_1&quot;&gt;simple assertions&lt;/span&gt;. An assertion specifies a condition that has to be met at a particular point in a match, without consuming any characters from the subject string. The use of subpatterns for more complicated assertions is described below. The backslashed assertions are::</source>
          <target state="translated">反斜杠的第四种用法是用于某些&lt;span id=&quot;simple-assertions_1&quot;&gt;简单的断言&lt;/span&gt;。断言指定必须在匹配中的特定点满足条件，而不会消耗主题字符串中的任何字符。子模式用于更复杂的断言的描述如下。反斜杠断言是：</target>
        </trans-unit>
        <trans-unit id="870186741ca6e1d444f360ccba4f4fded87a39e7" translate="yes" xml:space="preserve">
          <source>The fractional part of duration, as a duration.</source>
          <target state="translated">持续时间的小数部分,作为持续时间。</target>
        </trans-unit>
        <trans-unit id="4f2b0c3709a2752c88fc8474be143cd0204e9b79" translate="yes" xml:space="preserve">
          <source>The full output can be seen here: &lt;a href=&quot;docgen_sample&quot;&gt;docgen_sample.html&lt;/a&gt;. It runs after semantic checking, and includes pragmas attached implicitly by the compiler.</source>
          <target state="translated">完整的输出可以在这里看到：&lt;a href=&quot;docgen_sample&quot;&gt;docgen_sample.html&lt;/a&gt;。它在语义检查之后运行，并包含编译器隐式附加的编译指示。</target>
        </trans-unit>
        <trans-unit id="552ab82c6faae30ed9dbac63563f851d644aaccd" translate="yes" xml:space="preserve">
          <source>The functionality implemented by &lt;code&gt;HttpClient&lt;/code&gt; and &lt;code&gt;AsyncHttpClient&lt;/code&gt; is the same, so you can use whichever one suits you best in the examples shown here.</source>
          <target state="translated">&lt;code&gt;HttpClient&lt;/code&gt; 和 &lt;code&gt;AsyncHttpClient&lt;/code&gt; 实现的功能是相同的，因此您可以在此处显示的示例中使用最适合的一种。</target>
        </trans-unit>
        <trans-unit id="59835708b577fecda7c831ca2458e4c628fc710f" translate="yes" xml:space="preserve">
          <source>The future stream is completed (this means that no more data will be written).</source>
          <target state="translated">未来的流已经完成(这意味着不会再有数据被写入)。</target>
        </trans-unit>
        <trans-unit id="9be33b21289a1eef5808366623258d9dbcbaa46c" translate="yes" xml:space="preserve">
          <source>The gamma function</source>
          <target state="translated">伽马函数</target>
        </trans-unit>
        <trans-unit id="7a4585c32f1f4c6914153a2005cd46dd9de070e8" translate="yes" xml:space="preserve">
          <source>The gamma function &lt;strong&gt;Deprecated since version 0.19.0&lt;/strong&gt;: Use &lt;code&gt;gamma&lt;/code&gt; instead.</source>
          <target state="translated">&lt;strong&gt;从0.19.0版开始不推荐&lt;/strong&gt;使用 &lt;code&gt;gamma&lt;/code&gt; 函数：请改用gamma。</target>
        </trans-unit>
        <trans-unit id="da16bec30ab8a97eb878d0183e447bbc8ee7a461" translate="yes" xml:space="preserve">
          <source>The general form of a standard format specifier is:</source>
          <target state="translated">标准格式指定器的一般形式是:</target>
        </trans-unit>
        <trans-unit id="c09a581cb8f65c3c5d14cf7a67dcb119a964cc82" translate="yes" xml:space="preserve">
          <source>The generated C code will not have any explicit calling convention and thus use the C compiler's default calling convention. This is needed because Nim's default calling convention for procedures is &lt;code&gt;fastcall&lt;/code&gt; to improve speed.</source>
          <target state="translated">生成的C代码将没有任何显式的调用约定，因此将使用C编译器的默认调用约定。这是必需的，因为Nim对过程的默认调用约定是 &lt;code&gt;fastcall&lt;/code&gt; 以提高速度。</target>
        </trans-unit>
        <trans-unit id="b7379e59f2bd87fdbadd32039106a54f883a446d" translate="yes" xml:space="preserve">
          <source>The generated HTML for some of these wrappers is so huge that it is not contained in the distribution. You can then find them on the website.</source>
          <target state="translated">其中一些包装器生成的HTML非常庞大,所以不包含在发行版中。然后你可以在网站上找到它们。</target>
        </trans-unit>
        <trans-unit id="aa03edbbdb0c3d938f260d58cb5ca2f51408059e" translate="yes" xml:space="preserve">
          <source>The generated files that Nim produces all go into a subdirectory called &lt;code&gt;nimcache&lt;/code&gt;. Its full path is</source>
          <target state="translated">Nim生成的生成文件全部进入一个名为 &lt;code&gt;nimcache&lt;/code&gt; 的子目录。其完整路径是</target>
        </trans-unit>
        <trans-unit id="4c785c59836bb83ab636f8a5d0cda606ab17c5e4" translate="yes" xml:space="preserve">
          <source>The generated index. &lt;strong&gt;Index + (Ctrl+F) == Joy&lt;/strong&gt;</source>
          <target state="translated">生成的索引。&lt;strong&gt;索引+（Ctrl + F）== Joy&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f790d93cc82c110db5a7f7d8300334c9fc7c8808" translate="yes" xml:space="preserve">
          <source>The getrlimit() system call gets resource limits.</source>
          <target state="translated">系统调用getrlimit()获取资源限制。</target>
        </trans-unit>
        <trans-unit id="dba6185483a07591222dc085893c06cb1d77fd81" translate="yes" xml:space="preserve">
          <source>The good news is not much has changed! First, we need to change the handling of the input parameter (line 3). In the dynamic version the &lt;code&gt;readCfgAtRuntime&lt;/code&gt; proc receives a string parameter. However, in the macro version it is also declared as string, but this is the &lt;em&gt;outside&lt;/em&gt; interface of the macro. When the macro is run, it actually gets a &lt;code&gt;PNimNode&lt;/code&gt; object instead of a string, and we have to call the &lt;a href=&quot;macros#strVal&quot;&gt;strVal proc&lt;/a&gt; (line 5) from the &lt;a href=&quot;macros&quot;&gt;macros module&lt;/a&gt; to obtain the string being passed in to the macro.</source>
          <target state="translated">好消息没有太大改变！首先，我们需要更改输入参数的处理（第3行）。在动态版本中， &lt;code&gt;readCfgAtRuntime&lt;/code&gt; proc接收一个字符串参数。但是，在宏版本中，它也声明为字符串，但这是宏的&lt;em&gt;外部&lt;/em&gt;接口。运行宏时，它实际上获得了一个 &lt;code&gt;PNimNode&lt;/code&gt; 对象而不是字符串，并且我们必须从&lt;a href=&quot;macros&quot;&gt;宏模块中&lt;/a&gt;调用&lt;a href=&quot;macros#strVal&quot;&gt;strVal proc&lt;/a&gt;（第5行），以获取要传递给宏的字符串。</target>
        </trans-unit>
        <trans-unit id="14f57dccb74a2123a9f5546e3bebaee4e90cb289" translate="yes" xml:space="preserve">
          <source>The grammar's start symbol is &lt;code&gt;module&lt;/code&gt;.</source>
          <target state="translated">语法的开始符号是 &lt;code&gt;module&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c6743543c75d60b9f024c8d8ce6011899979a9a7" translate="yes" xml:space="preserve">
          <source>The greetings program consists of 3 statements that are executed sequentially. Only the most primitive programs can get away with that: branching and looping are needed too.</source>
          <target state="translated">问候程序由3条语句组成,依次执行。只有最原始的程序才能摆脱这种情况:也需要分支和循环。</target>
        </trans-unit>
        <trans-unit id="ac70a8fca453e797498ff8e165be78d4d719a059" translate="yes" xml:space="preserve">
          <source>The guard does not need to be of any particular type. It is flexible enough to model low level lockfree mechanisms:</source>
          <target state="translated">保护装置不需要是任何特定类型的。它足够灵活,可以模拟低级无锁机制。</target>
        </trans-unit>
        <trans-unit id="d0d6ece26593eceae5133245593e5e87cf3e06f3" translate="yes" xml:space="preserve">
          <source>The handling of a backslash followed by a digit other than 0 is complicated. Outside a character class, PCRE reads it and any following digits as a decimal number. If the number is less than 10, or if there have been at least that many previous capturing left parentheses in the expression, the entire sequence is taken as a back reference. A description of how this works is given later, following the discussion of parenthesized subpatterns.</source>
          <target state="translated">处理反斜杠后面的数字而不是0的处理方法很复杂。在字符类之外,PCRE将它和后面的任何数字作为十进制数读取。如果这个数字小于10,或者在表达式中至少有那么多之前的捕获左小括号,整个序列就会被当作后参考。后面在讨论小括号子模式后,将对这一工作原理进行描述。</target>
        </trans-unit>
        <trans-unit id="a0b88ec5fc66250e8218fe5157065e3562f9959e" translate="yes" xml:space="preserve">
          <source>The heap dump feature is still in its infancy, but it already proved useful for us, so it might be useful for you. To get a heap dump, compile with &lt;code&gt;-d:nimTypeNames&lt;/code&gt; and call &lt;code&gt;dumpNumberOfInstances&lt;/code&gt; at a strategic place in your program. This produces a list of used types in your program and for every type the total amount of object instances for this type as well as the total amount of bytes these instances take up. This list is currently unsorted! You need to use external shell script hacking to sort it.</source>
          <target state="translated">堆转储功能仍处于起步阶段，但已证明对我们有用，因此可能对您有用。要获取堆转储，请使用 &lt;code&gt;-d:nimTypeNames&lt;/code&gt; 进行编译，然后在程序中的重要位置调用 &lt;code&gt;dumpNumberOfInstances&lt;/code&gt; 。这将生成程序中已使用类型的列表，对于每种类型，此类型的对象实例总数以及这些实例占用的字节总数将为您提供清单。该列表目前未排序！您需要使用外部Shell脚本黑客对其进行排序。</target>
        </trans-unit>
        <trans-unit id="eddf728b23d010d05fee2b18ba2bee9bcf3ad561" translate="yes" xml:space="preserve">
          <source>The hostname of the client that made the request.</source>
          <target state="translated">发出请求的客户端的主机名。</target>
        </trans-unit>
        <trans-unit id="ae4bd9577099eefd3ac234c48f0755b6cae28779" translate="yes" xml:space="preserve">
          <source>The hours in one digit if possible, ranging from 0-23.</source>
          <target state="translated">如果可能的话,小时数为一位数,范围为0-23。</target>
        </trans-unit>
        <trans-unit id="508ac3f8b6d5beb7c16ecbb475b705dc160e6aea" translate="yes" xml:space="preserve">
          <source>The hours in one digit if possible. Ranging from 1-12.</source>
          <target state="translated">如果可能的话,小时数为一位数。从1-12不等。</target>
        </trans-unit>
        <trans-unit id="6e46e361665712eacbeb9a335f8ac314ff87abf9" translate="yes" xml:space="preserve">
          <source>The hours in two digits always. 0 is prepended if the hour is one digit.</source>
          <target state="translated">小时数总是两位数。如果小时数是一位数,则在前面加上0。</target>
        </trans-unit>
        <trans-unit id="35c9e4c595e71cdcb96dde240197d1b8a79fe6b5" translate="yes" xml:space="preserve">
          <source>The hours in two digits always. If the hour is one digit 0 is prepended.</source>
          <target state="translated">小时数始终为两位数。如果小时数是一位数,则在前面加上0。</target>
        </trans-unit>
        <trans-unit id="dcaf88b5d30ee42061a975ec06cd4f726da65a81" translate="yes" xml:space="preserve">
          <source>The identifiers following the &lt;code&gt;concept&lt;/code&gt; keyword represent instances of the currently matched type. You can apply any of the standard type modifiers such as &lt;code&gt;var&lt;/code&gt;, &lt;code&gt;ref&lt;/code&gt;, &lt;code&gt;ptr&lt;/code&gt; and &lt;code&gt;static&lt;/code&gt; to denote a more specific type of instance. You can also apply the &lt;em&gt;type&lt;/em&gt; modifier to create a named instance of the type itself:</source>
          <target state="translated">&lt;code&gt;concept&lt;/code&gt; 关键字后面的标识符表示当前匹配类型的实例。您可以应用任何标准类型修饰符，例如 &lt;code&gt;var&lt;/code&gt; ， &lt;code&gt;ref&lt;/code&gt; ， &lt;code&gt;ptr&lt;/code&gt; 和 &lt;code&gt;static&lt;/code&gt; 来表示实例的更特定类型。您还可以应用&lt;em&gt;类型&lt;/em&gt;修饰符创建类型本身的命名实例：</target>
        </trans-unit>
        <trans-unit id="bbb5916fc4882a2710c89523611ae3521f422971" translate="yes" xml:space="preserve">
          <source>The idetools command can be run as a compiler service (CAAS), where you first launch the compiler and it will stay online as a server, accepting queries in a telnet like fashion. The advantage of staying on is that for many queries the compiler can cache the results of the compilation, and subsequent queries should be fast in the millisecond range, thus being responsive enough for IDEs.</source>
          <target state="translated">idetools命令可以以编译器服务(CAAS)的方式运行,你首先启动编译器,它就会作为服务器保持在线,以类似telnet的方式接受查询。保持在线的好处是,对于很多查询,编译器可以缓存编译结果,后续的查询速度应该在毫秒级,因此对于IDE来说,响应速度足够快。</target>
        </trans-unit>
        <trans-unit id="79d04054b05925070544c64b6a10b2d6f82716f2" translate="yes" xml:space="preserve">
          <source>The if statement is one way to branch the control flow:</source>
          <target state="translated">if语句是分支控制流的一种方式。</target>
        </trans-unit>
        <trans-unit id="186aff351d775e0607553eab0c0008691860c0dc" translate="yes" xml:space="preserve">
          <source>The imaginary unit. &amp;radic;-1.</source>
          <target state="translated">虚数单位。&amp;radic;-1。</target>
        </trans-unit>
        <trans-unit id="2e0e8535555370a430de44e05424a154580b342b" translate="yes" xml:space="preserve">
          <source>The immediate pragma is obsolete. See &lt;a href=&quot;#typed-vs-untyped-parameters&quot;&gt;Typed vs untyped parameters&lt;/a&gt;.</source>
          <target state="translated">立即的实用性已过时。请参见&lt;a href=&quot;#typed-vs-untyped-parameters&quot;&gt;类型化参数与非类型化参数&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7fc80eb338f0f7897699f01c0d17e46fc45536bb" translate="yes" xml:space="preserve">
          <source>The implementation aligns the fields for best access performance. The alignment is compatible with the way the C compiler does it.</source>
          <target state="translated">该实现将字段对齐以获得最佳访问性能。这种对齐方式与C编译器的方式兼容。</target>
        </trans-unit>
        <trans-unit id="a9335f13c424aeabf870c93de05f27167c506276" translate="yes" xml:space="preserve">
          <source>The implementation currently provides the following possible options (various others may be added later).</source>
          <target state="translated">目前的实施方案提供了以下可能的选择(以后可能会增加其他各种选择):</target>
        </trans-unit>
        <trans-unit id="c3d620a68814993a0e566de11d8cdb73db09b126" translate="yes" xml:space="preserve">
          <source>The implementation of the compilation cache is tricky: There are lots of issues to be solved for the front- and backend.</source>
          <target state="translated">编译缓存的实现很棘手:前后端都有很多问题需要解决。</target>
        </trans-unit>
        <trans-unit id="c05e5029b48899e6e6d2a69b1f77e63ebf121b7d" translate="yes" xml:space="preserve">
          <source>The implicit initialization can be also prevented by the &lt;span id=&quot;requiresinit_1&quot;&gt;requiresInit&lt;/span&gt; type pragma. The compiler requires an explicit initialization for the object and all of its fields. However it does a &lt;span id=&quot;control-flow-analysis_1&quot;&gt;control flow analysis&lt;/span&gt; to prove the variable has been initialized and does not rely on syntactic properties:</source>
          <target state="translated">还可以通过&lt;span id=&quot;requiresinit_1&quot;&gt;requireInit&lt;/span&gt;类型编译指示来防止隐式初始化。编译器要求对对象及其所有字段进行显式初始化。但是，它进行&lt;span id=&quot;control-flow-analysis_1&quot;&gt;控制流分析&lt;/span&gt;以证明变量已初始化，并且不依赖语法属性：</target>
        </trans-unit>
        <trans-unit id="6bee0de5240bc2aece39314fb5444f70f1444362" translate="yes" xml:space="preserve">
          <source>The implicit initialization can be avoided for optimization reasons with the &lt;span id=&quot;noinit_1&quot;&gt;noinit&lt;/span&gt; pragma:</source>
          <target state="translated">出于优化原因，可以使用&lt;span id=&quot;noinit_1&quot;&gt;noinit&lt;/span&gt;编译指示来避免隐式初始化：</target>
        </trans-unit>
        <trans-unit id="3b7fd6facf0715e6c58bb9982e48c189f4d6d0c2" translate="yes" xml:space="preserve">
          <source>The indentation handling is implemented as follows: The lexer annotates the following token with the preceding number of spaces; indentation is not a separate token. This trick allows parsing of Nim with only 1 token of lookahead.</source>
          <target state="translated">缩进处理的实现方式如下。词典会用前面的空格数来注释下面的标记;缩进不是一个单独的标记。这个技巧允许只用1个lookahead标记来解析Nim。</target>
        </trans-unit>
        <trans-unit id="beff0881d78e8e065e276388970843e17443daff" translate="yes" xml:space="preserve">
          <source>The index generation tools try to differentiate between documentation generated from &lt;code&gt;.nim&lt;/code&gt; files and documentation generated from &lt;code&gt;.txt&lt;/code&gt; or &lt;code&gt;.rst&lt;/code&gt; files. The former are always closely related to source code and consist mainly of API entries. The latter are generic documents meant for human reading.</source>
          <target state="translated">索引生成工具尝试区分从 &lt;code&gt;.nim&lt;/code&gt; 文件生成的文档和从 &lt;code&gt;.txt&lt;/code&gt; 或 &lt;code&gt;.rst&lt;/code&gt; 文件生成的文档。前者始终与源代码密切相关，并且主要由API条目组成。后者是供人类阅读的通用文档。</target>
        </trans-unit>
        <trans-unit id="6306cc92a3bed777b6c141274a3bc860eba5a71d" translate="yes" xml:space="preserve">
          <source>The index won't be written to disk unless you call &lt;a href=&quot;#writeIndexFile&quot;&gt;writeIndexFile()&lt;/a&gt;. The purpose of the index is documented in the &lt;a href=&quot;docgen#index-switch&quot;&gt;docgen tools guide&lt;/a&gt;.</source>
          <target state="translated">除非您调用&lt;a href=&quot;#writeIndexFile&quot;&gt;writeIndexFile（），&lt;/a&gt;否则索引不会写入磁盘。索引的目的已在&lt;a href=&quot;docgen#index-switch&quot;&gt;docgen工具指南&lt;/a&gt;中进行了说明。</target>
        </trans-unit>
        <trans-unit id="7771da68e022b74bd5731922346ef2df52d2b53c" translate="yes" xml:space="preserve">
          <source>The inference for read/write tracking is analogous to the inference for exception tracking.</source>
          <target state="translated">读/写跟踪的推理类似于异常跟踪的推理。</target>
        </trans-unit>
        <trans-unit id="8d228a4803537313b1b78b37775bd1778df6dcc5" translate="yes" xml:space="preserve">
          <source>The inference for tag tracking is analogous to the inference for exception tracking.</source>
          <target state="translated">标签跟踪的推理类似于异常跟踪的推理。</target>
        </trans-unit>
        <trans-unit id="f5fb44e48abd9154517dcc0228213cb6390a548c" translate="yes" xml:space="preserve">
          <source>The inline convention means the the caller should not call the procedure, but inline its code directly. Note that Nim does not inline, but leaves this to the C compiler; it generates &lt;code&gt;__inline&lt;/code&gt; procedures. This is only a hint for the compiler: it may completely ignore it and it may inline procedures that are not marked as &lt;code&gt;inline&lt;/code&gt;.</source>
          <target state="translated">内联约定意味着调用者不应调用该过程，而应直接内联其代码。请注意，Nim不内联，而是将其留给C编译器使用。它生成 &lt;code&gt;__inline&lt;/code&gt; 程序。这只是对编译器的提示：它可能会完全忽略它，并且可能会嵌入未标记为 &lt;code&gt;inline&lt;/code&gt; 的内联过程。</target>
        </trans-unit>
        <trans-unit id="a0e8a627ab18ca245222565836c8b78837c0f702" translate="yes" xml:space="preserve">
          <source>The interaction between threads and exceptions is simple: A &lt;em&gt;handled&lt;/em&gt; exception in one thread cannot affect any other thread. However, an &lt;em&gt;unhandled&lt;/em&gt; exception in one thread terminates the whole &lt;em&gt;process&lt;/em&gt;!</source>
          <target state="translated">线程与异常之间的交互很简单：一个线程中的已&lt;em&gt;处理&lt;/em&gt;异常不会影响任何其他线程。但是，一个线程中&lt;em&gt;未处理的&lt;/em&gt;异常会终止整个&lt;em&gt;过程&lt;/em&gt;！</target>
        </trans-unit>
        <trans-unit id="a3f5985cf8e619dcc28842b0431cc6a248880914" translate="yes" xml:space="preserve">
          <source>The interesting thing is that our macro does not return a runtime &lt;a href=&quot;tables#Table&quot;&gt;Table&lt;/a&gt; object. Instead, it builds up Nim source code into the &lt;code&gt;source&lt;/code&gt; variable. For each line of the configuration file a &lt;code&gt;const&lt;/code&gt; variable will be generated (line 15). To avoid conflicts we prefix these variables with &lt;code&gt;cfg&lt;/code&gt;. In essence, what the compiler is doing is replacing the line calling the macro with the following snippet of code:</source>
          <target state="translated">有趣的是，我们的宏不返回运行时&lt;a href=&quot;tables#Table&quot;&gt;Table&lt;/a&gt;对象。而是将Nim源代码构建到 &lt;code&gt;source&lt;/code&gt; 变量中。对于配置文件的每一行，将生成一个 &lt;code&gt;const&lt;/code&gt; 变量（第15行）。为了避免冲突，我们在这些变量前加上 &lt;code&gt;cfg&lt;/code&gt; 。本质上，编译器正在做的是用以下代码片段替换调用宏的行：</target>
        </trans-unit>
        <trans-unit id="7fda431dba2bcff15441a32a1ff7eabe4a0fcf00" translate="yes" xml:space="preserve">
          <source>The internal documentation describes how the compiler is implemented. Read this if you want to hack the compiler.</source>
          <target state="translated">内部文档描述了编译器是如何实现的。如果你想破解编译器,请阅读这个文件。</target>
        </trans-unit>
        <trans-unit id="3e39595327b5d15b7987f46c8523802d25b3413e" translate="yes" xml:space="preserve">
          <source>The intersection of two sets is represented mathematically as &lt;em&gt;A &amp;cap; B&lt;/em&gt; and is the set of all objects that are members of &lt;em&gt;s1&lt;/em&gt; and &lt;em&gt;s2&lt;/em&gt; at the same time. Example:</source>
          <target state="translated">两组的交集在数学上用&lt;em&gt;A&amp;cap;B&lt;/em&gt;表示，并且是同时属于&lt;em&gt;s1&lt;/em&gt;和&lt;em&gt;s2&lt;/em&gt;的所有对象的集合。例：</target>
        </trans-unit>
        <trans-unit id="ea2460c0b5417fd480903274412d643b12ea3569" translate="yes" xml:space="preserve">
          <source>The language constructs are explained using an extended BNF, in which &lt;code&gt;(a)*&lt;/code&gt; means 0 or more &lt;code&gt;a&lt;/code&gt;'s, &lt;code&gt;a+&lt;/code&gt; means 1 or more &lt;code&gt;a&lt;/code&gt;'s, and &lt;code&gt;(a)?&lt;/code&gt; means an optional &lt;em&gt;a&lt;/em&gt;. Parentheses may be used to group elements.</source>
          <target state="translated">使用扩展的BNF来解释语言结构，其中 &lt;code&gt;(a)*&lt;/code&gt; 表示0或多个 &lt;code&gt;a&lt;/code&gt; ， &lt;code&gt;a+&lt;/code&gt; 表示1或多个 &lt;code&gt;a&lt;/code&gt; ，并且 &lt;code&gt;(a)?&lt;/code&gt; 表示可选&lt;em&gt;的&lt;/em&gt;。括号可用于对元素进行分组。</target>
        </trans-unit>
        <trans-unit id="5fa17fe926761d71195e28d1150f004609551f7f" translate="yes" xml:space="preserve">
          <source>The largest positive number that can be represented in a 32-bit floating-point type.</source>
          <target state="translated">用32位浮点类型表示的最大正数。</target>
        </trans-unit>
        <trans-unit id="df1bceb0b90a5c84eca91bbd3d5e55dc6f933514" translate="yes" xml:space="preserve">
          <source>The largest positive number that can be represented in a 64-bit floating-point type.</source>
          <target state="translated">64位浮点类型中可以表示的最大正数。</target>
        </trans-unit>
        <trans-unit id="c6b90ce83aefcb334988e56d2cf302f465c1ef2d" translate="yes" xml:space="preserve">
          <source>The last two digits of the year. When parsing, the current century is assumed.</source>
          <target state="translated">年份的最后两位数字。在解析时,假设当前的世纪。</target>
        </trans-unit>
        <trans-unit id="d738ffb3d9772102e7dddad8f87eb9e66e116402" translate="yes" xml:space="preserve">
          <source>The last two parameters specify the certificate file path and the key file path, a server socket will most likely not work without these. Certificates can be generated using the following command: &lt;code&gt;openssl req -x509 -nodes -days 365 -newkey rsa:1024 -keyout mycert.pem -out mycert.pem&lt;/code&gt;.</source>
          <target state="translated">最后两个参数指定证书文件路径和密钥文件路径，没有这些，服务器套接字很可能无法工作。可以使用以下命令生成证书： &lt;code&gt;openssl req -x509 -nodes -days 365 -newkey rsa:1024 -keyout mycert.pem -out mycert.pem&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="22883001fe945b433749aff495f00df528dc3c12" translate="yes" xml:space="preserve">
          <source>The let statement</source>
          <target state="translated">Let语句</target>
        </trans-unit>
        <trans-unit id="d0faa7666c0de3db04b2c000430e78a9499fe142" translate="yes" xml:space="preserve">
          <source>The letter 'l' should not be used as an identifier.</source>
          <target state="translated">字母 &quot;l &quot;不应作为标识符使用。</target>
        </trans-unit>
        <trans-unit id="e1a4f72b5fdcd674f6a9f4458b16b275e31bc2a1" translate="yes" xml:space="preserve">
          <source>The library uses a simple naming scheme that makes use of common abbreviations to keep the names short but meaningful.</source>
          <target state="translated">该库使用了一个简单的命名方案,利用常见的缩写,使名称简短而有意义。</target>
        </trans-unit>
        <trans-unit id="03449ea33dc1c4c4ed0647ce0ae2f4b3f5ab6c04" translate="yes" xml:space="preserve">
          <source>The library uses a simple naming scheme that makes use of common abbreviations to keep the names short but meaningful. Since version 0.8.2 many symbols have been renamed to fit this scheme. The ultimate goal is that the programmer can &lt;em&gt;guess&lt;/em&gt; a name.</source>
          <target state="translated">该库使用一种简单的命名方案，该方案使用常见的缩写来使名称简短但有意义。从版本0.8.2开始，已将许多符号重命名以适合此方案。最终目标是程序员可以&lt;em&gt;猜出&lt;/em&gt;一个名字。</target>
        </trans-unit>
        <trans-unit id="81b15f3b8be0db527b2dd32e57b3edc710545648" translate="yes" xml:space="preserve">
          <source>The listed pragmas here can be used to override the code generation options for a proc/method/converter.</source>
          <target state="translated">这里列出的实用名词可以用来覆盖proc/method/converter的代码生成选项。</target>
        </trans-unit>
        <trans-unit id="d6ba5327d8647bd7ed894bcffd2bb86402f1c550" translate="yes" xml:space="preserve">
          <source>The lower bound of an array or sequence may be received by the built-in proc &lt;code&gt;low()&lt;/code&gt;, the higher bound by &lt;code&gt;high()&lt;/code&gt;. The length may be received by &lt;code&gt;len()&lt;/code&gt;. &lt;code&gt;low()&lt;/code&gt; for a sequence or an open array always returns 0, as this is the first valid index. One can append elements to a sequence with the &lt;code&gt;add()&lt;/code&gt; proc or the &lt;code&gt;&amp;amp;&lt;/code&gt; operator, and remove (and get) the last element of a sequence with the &lt;code&gt;pop()&lt;/code&gt; proc.</source>
          <target state="translated">数组或序列的下限可由内置的proc &lt;code&gt;low()&lt;/code&gt; 接收，上限由 &lt;code&gt;high()&lt;/code&gt; 接收。该长度可以由 &lt;code&gt;len()&lt;/code&gt; 接收。序列或开放数组的 &lt;code&gt;low()&lt;/code&gt; 始终返回0，因为这是第一个有效索引。可以使用 &lt;code&gt;add()&lt;/code&gt; proc或 &lt;code&gt;&amp;amp;&lt;/code&gt; 运算符将元素追加到序列中，并使用 &lt;code&gt;pop()&lt;/code&gt; proc 删除（并获取）序列的最后一个元素。</target>
        </trans-unit>
        <trans-unit id="5734f010cce3ed3e6eb9ebff7381b95381124003" translate="yes" xml:space="preserve">
          <source>The macro call expands to:</source>
          <target state="translated">宏调用扩展到。</target>
        </trans-unit>
        <trans-unit id="ba15c60c9b85487537b51042f4adcf6c970f986b" translate="yes" xml:space="preserve">
          <source>The manual mentions that &lt;a href=&quot;manual#cstring-type&quot;&gt;Nim strings are implicitly convertible to cstrings&lt;/a&gt; which makes interaction usually painless. Most C functions accepting a Nim string converted to a &lt;code&gt;cstring&lt;/code&gt; will likely not need to keep this string around and by the time they return the string won't be needed any more. However, for the rare cases where a Nim string has to be preserved and made available to the C backend as a &lt;code&gt;cstring&lt;/code&gt;, you will need to manually prevent the string data from being freed with &lt;a href=&quot;system#GC_ref&quot;&gt;GC_ref&lt;/a&gt; and &lt;a href=&quot;system#GC_unref&quot;&gt;GC_unref&lt;/a&gt;.</source>
          <target state="translated">该手册提到&lt;a href=&quot;manual#cstring-type&quot;&gt;Nim字符串可以隐式转换为cstring&lt;/a&gt;，这通常使交互变得轻松。大多数接受将Nim字符串转换为 &lt;code&gt;cstring&lt;/code&gt; 的 C函数都可能不需要保留该字符串，并且在它们返回时不再需要该字符串。但是，在极少数情况下，必须保留Nim字符串并以 &lt;code&gt;cstring&lt;/code&gt; 的形式提供给C后端，您需要手动防止使用&lt;a href=&quot;system#GC_ref&quot;&gt;GC_ref&lt;/a&gt;和&lt;a href=&quot;system#GC_unref&quot;&gt;GC_unref&lt;/a&gt;释放字符串数据。</target>
        </trans-unit>
        <trans-unit id="d055cba0dbcd824c3d51d9d663b957c1d43495ed" translate="yes" xml:space="preserve">
          <source>The matched dot operators can be symbols of any callable kind (procs, templates and macros), depending on the desired effect:</source>
          <target state="translated">匹配的点运算符可以是任何可调用种类的符号(procs、模板和宏),这取决于所需的效果。</target>
        </trans-unit>
        <trans-unit id="aa302af914c04b9a452351c8217335cf34464abe" translate="yes" xml:space="preserve">
          <source>The matching AST must be a call/apply expression.</source>
          <target state="translated">匹配的AST必须是一个调用/应用表达式。</target>
        </trans-unit>
        <trans-unit id="0b44d6a083a904cecf3aef26278e11886b2e549d" translate="yes" xml:space="preserve">
          <source>The matching AST must be an lvalue.</source>
          <target state="translated">匹配的AST必须是一个l值。</target>
        </trans-unit>
        <trans-unit id="9fac33d3e99596d75ad6eeca948e5afafcf536ac" translate="yes" xml:space="preserve">
          <source>The matching AST must have a side effect.</source>
          <target state="translated">匹配的AST必须有副作用。</target>
        </trans-unit>
        <trans-unit id="62342d8683b403d83a8513c785f6aafa6bfbd8b4" translate="yes" xml:space="preserve">
          <source>The matching AST must have no side effect.</source>
          <target state="translated">匹配的AST必须没有副作用。</target>
        </trans-unit>
        <trans-unit id="5661a426b593f52c0ca7fa90eafc833175b21253" translate="yes" xml:space="preserve">
          <source>The matching AST must have the specified kind. (Example: &lt;code&gt;nkIfStmt&lt;/code&gt; denotes an &lt;code&gt;if&lt;/code&gt; statement.)</source>
          <target state="translated">匹配的AST必须具有指定的种类。（示例： &lt;code&gt;nkIfStmt&lt;/code&gt; 表示一个 &lt;code&gt;if&lt;/code&gt; 语句。）</target>
        </trans-unit>
        <trans-unit id="eb0f0fe081b64818b6b3016af8a01416e217ed1f" translate="yes" xml:space="preserve">
          <source>The matching is performed after the compiler performed some optimizations like constant folding, so the following does not work:</source>
          <target state="translated">匹配是在编译器进行了一些优化后进行的,比如恒定的折叠,所以下面就不能用了。</target>
        </trans-unit>
        <trans-unit id="25c9e6f14aaa1c25059b8a65928452c58ffeac86" translate="yes" xml:space="preserve">
          <source>The matching node has no children.</source>
          <target state="translated">匹配的节点没有子节点。</target>
        </trans-unit>
        <trans-unit id="3bee02bd8ec9e041895cdd7f8534811610597c81" translate="yes" xml:space="preserve">
          <source>The matching node is a literal like &quot;abc&quot;, 12.</source>
          <target state="translated">匹配的节点是像 &quot;abc &quot;这样的文字,12.</target>
        </trans-unit>
        <trans-unit id="721eb0da3439ce9f34194a03def0ba45ab30e608" translate="yes" xml:space="preserve">
          <source>The matching node must be a symbol (a bound identifier).</source>
          <target state="translated">匹配的节点必须是一个符号(绑定标识符)。</target>
        </trans-unit>
        <trans-unit id="be1a3bab050b769c30c8177fd935188143910209" translate="yes" xml:space="preserve">
          <source>The matching node must be an identifier (an unbound identifier).</source>
          <target state="translated">匹配的节点必须是一个标识符(非绑定标识符)。</target>
        </trans-unit>
        <trans-unit id="4f8a620db21ad017e74d603c8e4851fa5f18d228" translate="yes" xml:space="preserve">
          <source>The maximum content-length that will be read for the body.</source>
          <target state="translated">读取正文的最大内容长度。</target>
        </trans-unit>
        <trans-unit id="43fd98d19fce24bd57a3a5dd301ed84cfd20f560" translate="yes" xml:space="preserve">
          <source>The maximum value of &lt;em&gt;x&lt;/em&gt;. &lt;code&gt;T&lt;/code&gt; needs to have a &lt;code&gt;&amp;lt;&lt;/code&gt; operator.</source>
          <target state="translated">&lt;em&gt;x&lt;/em&gt;的最大值。 &lt;code&gt;T&lt;/code&gt; 需要有一个 &lt;code&gt;&amp;lt;&lt;/code&gt; 运算符。</target>
        </trans-unit>
        <trans-unit id="5d2d6e30267d2820d060080987be5a5b7a4f91f3" translate="yes" xml:space="preserve">
          <source>The maximum value of two integers.</source>
          <target state="translated">两个整数的最大值。</target>
        </trans-unit>
        <trans-unit id="bb9b388505eb1fb774570095acc72dd570fedb16" translate="yes" xml:space="preserve">
          <source>The method call syntax conflicts with explicit generic instantiations: &lt;code&gt;p[T](x)&lt;/code&gt; cannot be written as &lt;code&gt;x.p[T]&lt;/code&gt; because &lt;code&gt;x.p[T]&lt;/code&gt; is always parsed as &lt;code&gt;(x.p)[T]&lt;/code&gt;.</source>
          <target state="translated">方法调用语法与显式泛型实例化冲突： &lt;code&gt;p[T](x)&lt;/code&gt; 不能写为 &lt;code&gt;x.p[T]&lt;/code&gt; 因为 &lt;code&gt;x.p[T]&lt;/code&gt; 始终被解析为 &lt;code&gt;(x.p)[T]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a0ef8bda90a06a0c3f6e30dace9ed42593b23481" translate="yes" xml:space="preserve">
          <source>The minimum value of &lt;em&gt;x&lt;/em&gt;. &lt;code&gt;T&lt;/code&gt; needs to have a &lt;code&gt;&amp;lt;&lt;/code&gt; operator.</source>
          <target state="translated">&lt;em&gt;x&lt;/em&gt;的最小值。 &lt;code&gt;T&lt;/code&gt; 需要有一个 &lt;code&gt;&amp;lt;&lt;/code&gt; 运算符。</target>
        </trans-unit>
        <trans-unit id="6382aa6ed7dc87e04b1c5dfd0efac1c3cf2ff114" translate="yes" xml:space="preserve">
          <source>The minimum value of two integers.</source>
          <target state="translated">两个整数的最小值。</target>
        </trans-unit>
        <trans-unit id="42618bccaa1614ff3af2e91f3ca07f6ebdc8c5aa" translate="yes" xml:space="preserve">
          <source>The minutes in 1 digit if possible.</source>
          <target state="translated">如果可能的话,分钟数为1位数。</target>
        </trans-unit>
        <trans-unit id="b3095d9956a51342dd5a97c0ff4d61f08e5b0b7f" translate="yes" xml:space="preserve">
          <source>The module will fallback to pure nim procs incase the backend is not supported. You can also use the flag &lt;em&gt;noIntrinsicsBitOpts&lt;/em&gt; to disable compiler intrinsics.</source>
          <target state="translated">如果不支持后端，该模块将回退到纯nim proc。您还可以使用标志&lt;em&gt;noIntrinsicsBitOpts&lt;/em&gt;禁用编译器内部函数。</target>
        </trans-unit>
        <trans-unit id="8e065869153c9cf19339eeb5fe17bfa8010a6236" translate="yes" xml:space="preserve">
          <source>The month in one digit if possible.</source>
          <target state="translated">如果可能的话,月份以一位数表示。</target>
        </trans-unit>
        <trans-unit id="8eb37896b3a59b2013774ad8a8bc6115389438f2" translate="yes" xml:space="preserve">
          <source>The month in two digits always. 0 is prepended.</source>
          <target state="translated">月份总是以两位数表示。0为前缀。</target>
        </trans-unit>
        <trans-unit id="9b7d512c82e7ce84b958ad19e901783b62720ac2" translate="yes" xml:space="preserve">
          <source>The most important reason for RTTI. Generating traversal procedures produces bigger code and is likely to be slower on modern hardware as dynamic procedure binding is hard to predict.</source>
          <target state="translated">RTTI的最重要原因。生成遍历过程会产生更大的代码,而且在现代硬件上可能会更慢,因为动态过程绑定很难预测。</target>
        </trans-unit>
        <trans-unit id="cf6c2e2953025ff455ecd8b6b1f063d8970db911" translate="yes" xml:space="preserve">
          <source>The most reliable way to handle exceptions is to use &lt;code&gt;yield&lt;/code&gt; on a future then check the future's &lt;code&gt;failed&lt;/code&gt; property. For example:</source>
          <target state="translated">处理异常的最可靠方法是在 &lt;code&gt;yield&lt;/code&gt; 上使用yield，然后检查Future的 &lt;code&gt;failed&lt;/code&gt; 属性。例如：</target>
        </trans-unit>
        <trans-unit id="abac663a9e4ad29972ddcc95fc577538bbcbd3dd" translate="yes" xml:space="preserve">
          <source>The most significant difference between these commands is that if you look into the &lt;code&gt;nimcache&lt;/code&gt; directory you will find &lt;code&gt;.c&lt;/code&gt;, &lt;code&gt;.cpp&lt;/code&gt; or &lt;code&gt;.m&lt;/code&gt; files, other than that all of them will produce a native binary for your project. This allows you to take the generated code and place it directly into a project using any of these languages. Here are some typical command line invocations:</source>
          <target state="translated">这些命令之间最显着的区别是，如果查看 &lt;code&gt;nimcache&lt;/code&gt; 目录，则会找到 &lt;code&gt;.c&lt;/code&gt; ， &lt;code&gt;.cpp&lt;/code&gt; 或 &lt;code&gt;.m&lt;/code&gt; 文件，除此之外，所有这些文件都会为您的项目生成本机二进制文件。这使您可以采用生成的代码，并使用任何这些语言将其直接放入项目中。以下是一些典型的命令行调用：</target>
        </trans-unit>
        <trans-unit id="69f05063edc5202ee9c72c0096b575ad8468f147" translate="yes" xml:space="preserve">
          <source>The name of the timezone.</source>
          <target state="translated">时区的名称。</target>
        </trans-unit>
        <trans-unit id="f458d384ea0910910144b31e2bb7acec5965f32b" translate="yes" xml:space="preserve">
          <source>The normal &lt;code&gt;import&lt;/code&gt; statement will bring in all exported symbols. These can be limited by naming symbols which should be excluded with the &lt;code&gt;except&lt;/code&gt; qualifier.</source>
          <target state="translated">正常的 &lt;code&gt;import&lt;/code&gt; 语句将引入所有导出的符号。这些可以通过命名符号来加以限制，这些符号应被排除在限定符 &lt;code&gt;except&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="629262f7b72a57e5a72d86066221973769332f9a" translate="yes" xml:space="preserve">
          <source>The normal operation mode is called &lt;code&gt;ProcRun&lt;/code&gt; and it involves starting a process for each command or query, similar to running manually the Nim compiler from the commandline. The &lt;code&gt;CaasRun&lt;/code&gt; mode starts a server process to answer all queries. The &lt;code&gt;SymbolProcRun&lt;/code&gt; mode is used by compiler developers. This means that running all tests involves processing all &lt;code&gt;*.txt&lt;/code&gt; files three times, which can be quite time consuming.</source>
          <target state="translated">正常操作模式称为 &lt;code&gt;ProcRun&lt;/code&gt; ，它涉及为每个命令或查询启动一个过程，类似于从命令行手动运行Nim编译器。该 &lt;code&gt;CaasRun&lt;/code&gt; 模式启动一个服务器进程来回答所有问题。该 &lt;code&gt;SymbolProcRun&lt;/code&gt; 模式由编译器开发人员使用。这意味着运行所有测试涉及对所有 &lt;code&gt;*.txt&lt;/code&gt; 文件进行三次处理，这可能非常耗时。</target>
        </trans-unit>
        <trans-unit id="4bae69dda155aa8a4d14da3a2fc6579a9ca759df" translate="yes" xml:space="preserve">
          <source>The notation &lt;code&gt;x[i]&lt;/code&gt; can be used to access the i-th element of &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;x[i]&lt;/code&gt; 表示法可用于访问 &lt;code&gt;x&lt;/code&gt; 的第i个元素。</target>
        </trans-unit>
        <trans-unit id="658eabb7c8362bd8ccc2db983d207e849c519eb7" translate="yes" xml:space="preserve">
          <source>The notation &lt;code&gt;x[i]&lt;/code&gt; is used to access the i-th element of &lt;code&gt;x&lt;/code&gt;. Array access is always bounds checked (at compile-time or at runtime). These checks can be disabled via pragmas or invoking the compiler with the &lt;code&gt;--bound_checks:off&lt;/code&gt; command line switch.</source>
          <target state="translated">&lt;code&gt;x[i]&lt;/code&gt; 表示法用于访问 &lt;code&gt;x&lt;/code&gt; 的第i个元素。始终对数组访问进行边界检查（在编译时或运行时）。可以通过编译指示或使用 &lt;code&gt;--bound_checks:off&lt;/code&gt; 命令行开关调用编译器来禁用这些检查。</target>
        </trans-unit>
        <trans-unit id="84253c85ff2fe63ceae34cee869e8056c8618b6f" translate="yes" xml:space="preserve">
          <source>The notation used for a PEG is similar to that of EBNF:</source>
          <target state="translated">PEG使用的符号与EBNF类似。</target>
        </trans-unit>
        <trans-unit id="35c5176abc505099c32f5f56c77ef46929971143" translate="yes" xml:space="preserve">
          <source>The number of bytes belonging to 's[i]' including following combining characters.</source>
          <target state="translated">属于's[i]'的字节数,包括以下组合字符。</target>
        </trans-unit>
        <trans-unit id="67410fb726aaa716bc56a897729095f56b009d39" translate="yes" xml:space="preserve">
          <source>The numbers count the number of objects in all GC heaps, they refer to all running threads, not only to the current thread. (The current thread would be the thread that calls &lt;code&gt;dumpNumberOfInstances&lt;/code&gt;.) This might change in later versions.</source>
          <target state="translated">这些数字计算所有GC堆中的对象数量，它们引用所有正在运行的线程，而不仅是当前线程。（当前线程将是调用 &lt;code&gt;dumpNumberOfInstances&lt;/code&gt; 的线程。）在更高版本中，这可能会更改。</target>
        </trans-unit>
        <trans-unit id="943d32e77792f1b379a556185254f33101e23b55" translate="yes" xml:space="preserve">
          <source>The numerical identifier is just a random number. The number gets assigned according to the section and position of the symbol in the file being processed and you should not rely on it being constant: if you add or remove a symbol the numbers may shuffle around.</source>
          <target state="translated">数字标识符只是一个随机数。数字会根据文件中符号的部分和位置进行分配,您不应该依赖它的恒定性:如果您添加或删除一个符号,数字可能会随机变化。</target>
        </trans-unit>
        <trans-unit id="727a603933eb24259acf39e94c54b8c8c69ecf4d" translate="yes" xml:space="preserve">
          <source>The occasional use of idetools is acceptable for things like definitions, where the user puts the cursor on a symbol or double clicks it and after a second or two the IDE displays where that symbol is defined. Such latencies would be terrible for features like symbol suggestion, plus why wait at all if we can avoid it?</source>
          <target state="translated">偶尔使用idetools是可以接受的,比如定义,用户把光标放在一个符号上或者双击它,一两秒钟后IDE就会显示出这个符号被定义的位置。这样的延迟对于像符号建议这样的功能来说是很糟糕的,另外,如果我们能避免这样的延迟,为什么还要等待呢?</target>
        </trans-unit>
        <trans-unit id="37994ecd43903ca9e4ef6ac25795c9cd0cb6d035" translate="yes" xml:space="preserve">
          <source>The only case where things aren't as easy is when the garbage collector needs some assembler tweaking to work. The standard version of the GC uses C's &lt;code&gt;setjmp&lt;/code&gt; function to store all registers on the hardware stack. It may be necessary that the new platform needs to replace this generic code by some assembler code.</source>
          <target state="translated">唯一不那么容易的情况是，垃圾收集器需要一些汇编器调整才能工作。GC的标准版本使用C的 &lt;code&gt;setjmp&lt;/code&gt; 函数将所有寄存器存储在硬件堆栈上。新平台可能需要用某些汇编代码替换该通用代码。</target>
        </trans-unit>
        <trans-unit id="e2f49d4957d979510c6bf361e27282ecac40ce06" translate="yes" xml:space="preserve">
          <source>The only difference between the contents of that file and the values provided by this proc is the &lt;code&gt;doc.file&lt;/code&gt; variable. The &lt;code&gt;doc.file&lt;/code&gt; variable of the configuration file contains HTML to build standalone pages, while this proc returns just the content for procs like &lt;code&gt;rstToHtml&lt;/code&gt; to generate the bare minimum HTML.</source>
          <target state="translated">该文件的内容与该proc提供的值之间的唯一区别是 &lt;code&gt;doc.file&lt;/code&gt; 变量。配置文件的 &lt;code&gt;doc.file&lt;/code&gt; 变量包含用于构建独立页面的HTML，而此proc仅返回诸如 &lt;code&gt;rstToHtml&lt;/code&gt; 之类的proc内容以生成最少的HTML。</target>
        </trans-unit>
        <trans-unit id="66d1058ab09e19fbf4fbe3d6ea05970103c3b41c" translate="yes" xml:space="preserve">
          <source>The only operations that are affected by the &lt;code&gt;floatChecks&lt;/code&gt; pragma are the &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;/&lt;/code&gt; operators for floating point types.</source>
          <target state="translated">唯一受 &lt;code&gt;floatChecks&lt;/code&gt; 编译指示影响的运算是浮点类型的 &lt;code&gt;+&lt;/code&gt; ， &lt;code&gt;-&lt;/code&gt; ， &lt;code&gt;*&lt;/code&gt; ， &lt;code&gt;/&lt;/code&gt; 运算符。</target>
        </trans-unit>
        <trans-unit id="168d790e853cbd9034f71729f2476481319d159c" translate="yes" xml:space="preserve">
          <source>The openarray type cannot be nested: multidimensional openarrays are not supported because this is seldom needed and cannot be done efficiently.</source>
          <target state="translated">openarray类型不能嵌套:不支持多维openarray,因为很少需要这样做,而且不能有效地完成。</target>
        </trans-unit>
        <trans-unit id="c4e0647a4c89f8b16abd9dcace05bac8931235f1" translate="yes" xml:space="preserve">
          <source>The operation is performed atomically and other operations on the table will be blocked while the &lt;code&gt;mapper&lt;/code&gt; is invoked, so it should be short and simple.</source>
          <target state="translated">该操作是原子执行的，并且在调用 &lt;code&gt;mapper&lt;/code&gt; 将阻止对表的其他操作，因此它应该简短而简单。</target>
        </trans-unit>
        <trans-unit id="83ab7b4d2bb2233e5f2fab96873b663a53e9e12f" translate="yes" xml:space="preserve">
          <source>The operation produced a result that cannot be represented with infinite precision -- for example: &lt;code&gt;2.0 / 3.0, log(1.1)&lt;/code&gt;</source>
          <target state="translated">该操作产生的结果无法无限精确地表示-例如： &lt;code&gt;2.0 / 3.0, log(1.1)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8377f7d618fcf4075ebaa21071b51f158edf57be" translate="yes" xml:space="preserve">
          <source>The operation produced a result that exceeds the range of the exponent.</source>
          <target state="translated">操作产生的结果超过了指数的范围。</target>
        </trans-unit>
        <trans-unit id="33f13b87dbb9bcf04674b0e7829c348aac46fcd6" translate="yes" xml:space="preserve">
          <source>The operation produced a result that is too small to be represented as a normal number.</source>
          <target state="translated">操作产生的结果太小,无法用普通数表示。</target>
        </trans-unit>
        <trans-unit id="941ce1be2e887859312d9d5ab72c51d7733f52a5" translate="yes" xml:space="preserve">
          <source>The operator's precedence is determined by its first character. The details can be found in the manual.</source>
          <target state="translated">操作员的优先级由其第一个字符决定。详细内容可以在手册中找到。</target>
        </trans-unit>
        <trans-unit id="c0e839d05d73521d7af47a856f782f7c30977b0c" translate="yes" xml:space="preserve">
          <source>The operators &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;**&lt;/code&gt;, &lt;code&gt;|&lt;/code&gt;, &lt;code&gt;~&lt;/code&gt; have a special meaning in patterns if they are written in infix notation.</source>
          <target state="translated">运算符 &lt;code&gt;*&lt;/code&gt; ， &lt;code&gt;**&lt;/code&gt; ， &lt;code&gt;|&lt;/code&gt; ， &lt;code&gt;~&lt;/code&gt; 如果以后缀符号表示，则在模式中具有特殊含义。</target>
        </trans-unit>
        <trans-unit id="bf012723c5a2a5eb3b690eb90475c06700cb84be" translate="yes" xml:space="preserve">
          <source>The operators &lt;code&gt;not, and, or, xor, &amp;lt;, &amp;lt;=, &amp;gt;, &amp;gt;=, !=, ==&lt;/code&gt; are defined for the bool type. The &lt;code&gt;and&lt;/code&gt; and &lt;code&gt;or&lt;/code&gt; operators perform short-circuit evaluation. For example:</source>
          <target state="translated">为布尔类型定义了运算符 &lt;code&gt;not, and, or, xor, &amp;lt;, &amp;lt;=, &amp;gt;, &amp;gt;=, !=, ==&lt;/code&gt; 。的 &lt;code&gt;and&lt;/code&gt; 和 &lt;code&gt;or&lt;/code&gt; 运算符执行短路评价。例如：</target>
        </trans-unit>
        <trans-unit id="5a6dbe81c71ecdddbb102d68881f2f73beabe16e" translate="yes" xml:space="preserve">
          <source>The operators &lt;code&gt;not, and, or, xor, &amp;lt;, &amp;lt;=, &amp;gt;, &amp;gt;=, !=, ==&lt;/code&gt; are defined for the bool type. The &lt;code&gt;and&lt;/code&gt; and &lt;code&gt;or&lt;/code&gt; operators perform short-cut evaluation. Example:</source>
          <target state="translated">为布尔类型定义了运算符 &lt;code&gt;not, and, or, xor, &amp;lt;, &amp;lt;=, &amp;gt;, &amp;gt;=, !=, ==&lt;/code&gt; 。在 &lt;code&gt;and&lt;/code&gt; 和 &lt;code&gt;or&lt;/code&gt; 运营商进行快捷的评估。例：</target>
        </trans-unit>
        <trans-unit id="81caedce7ab00b1fe39f7b3ec76b901fbe2f933f" translate="yes" xml:space="preserve">
          <source>The optional 'fill' character defines the character to be used to pad the field to the minimum width. The fill character, if present, must be followed by an alignment flag.</source>
          <target state="translated">可选的 &quot;填充 &quot;字符定义了用于填充字段到最小宽度的字符。填充字符如果存在,必须在后面加上对齐标志。</target>
        </trans-unit>
        <trans-unit id="e4b3a59de6d012b18e22a8e7a284e6db58df1867" translate="yes" xml:space="preserve">
          <source>The optional align flag can be one of the following:</source>
          <target state="translated">可选的对齐标志可以是以下之一。</target>
        </trans-unit>
        <trans-unit id="a0e3a6522c824ed95aa3e1f8fe8ce4a5f4f147b1" translate="yes" xml:space="preserve">
          <source>The order of the (key,value)-pairs is preserved, thus it is easy to support ordered dicts with for example &lt;code&gt;{key: val}.newOrderedTable&lt;/code&gt;.</source>
          <target state="translated">（键，值）对的顺序得以保留，因此很容易通过例如 &lt;code&gt;{key: val}.newOrderedTable&lt;/code&gt; 支持有序字典。</target>
        </trans-unit>
        <trans-unit id="429f542ce113c15e57f01af974550e0e5b305975" translate="yes" xml:space="preserve">
          <source>The order of the replacements does matter. Earlier replacements are preferred over later replacements in the argument list.</source>
          <target state="translated">替换的顺序确实很重要。在参数列表中,较早的替换优于较晚的替换。</target>
        </trans-unit>
        <trans-unit id="dacff1821dbef72a128b774b46c26a9e053a10c5" translate="yes" xml:space="preserve">
          <source>The original module name is then not accessible. The notations &lt;code&gt;path/to/module&lt;/code&gt; or &lt;code&gt;&quot;path/to/module&quot;&lt;/code&gt; can be used to refer to a module in subdirectories:</source>
          <target state="translated">这样就无法访问原始模块名称。 &lt;code&gt;path/to/module&lt;/code&gt; 或 &lt;code&gt;&quot;path/to/module&quot;&lt;/code&gt; 符号可用于引用子目录中的模块：</target>
        </trans-unit>
        <trans-unit id="cc86fbbfca2829ffbb5ee4206b27f3d101a719c7" translate="yes" xml:space="preserve">
          <source>The original string is returned if &lt;em&gt;width&lt;/em&gt; is less than or equal to &lt;em&gt;s.len&lt;/em&gt;.</source>
          <target state="translated">如果&lt;em&gt;width&lt;/em&gt;小于或等于&lt;em&gt;s.len，&lt;/em&gt;则返回原始字符串。</target>
        </trans-unit>
        <trans-unit id="56fcfadb9f1701723ceb4fcaae9d90dddc612821" translate="yes" xml:space="preserve">
          <source>The other reason is that the dirty file can appear anywhere on disk (e.g. in tmpfs), but it must be treated as having a path matching the original module when it comes to usage of relative paths, etc. Queries, however, will refer to the dirty module name in their answers instead of the normal filename.</source>
          <target state="translated">另一个原因是,dirty文件可以出现在磁盘的任何地方(如tmpfs中),但在使用相对路径等问题上,必须将其视为具有与原始模块相匹配的路径。然而,查询会在答案中引用脏文件的模块名,而不是正常的文件名。</target>
        </trans-unit>
        <trans-unit id="81362a99790f1d4f0fa145c5d4c8a309f3b532a8" translate="yes" xml:space="preserve">
          <source>The output for HTML and LaTeX comes from the &lt;code&gt;config/nimdoc.cfg&lt;/code&gt; and &lt;code&gt;config/nimdoc.tex.cfg&lt;/code&gt; configuration files. You can add and modify these files to your project to change the look of docgen output.</source>
          <target state="translated">HTML和LaTeX的输出来自 &lt;code&gt;config/nimdoc.cfg&lt;/code&gt; 和 &lt;code&gt;config/nimdoc.tex.cfg&lt;/code&gt; 配置文件。您可以在项目中添加和修改这些文件，以更改docgen输出的外观。</target>
        </trans-unit>
        <trans-unit id="5fab1111abe4336bbc798351e8ca9549d09746d9" translate="yes" xml:space="preserve">
          <source>The output is twice the input long. No prefix like &lt;code&gt;0x&lt;/code&gt; is generated.</source>
          <target state="translated">输出是输入长度的两倍。不会生成像 &lt;code&gt;0x&lt;/code&gt; 这样的前缀。</target>
        </trans-unit>
        <trans-unit id="533631499bbd1d8be6ff4dcee292a72b882cc3f0" translate="yes" xml:space="preserve">
          <source>The output verbosity of the tests.</source>
          <target state="translated">测试的输出语气。</target>
        </trans-unit>
        <trans-unit id="461db813bbace1635974b27e6126d38b9c4ee9ad" translate="yes" xml:space="preserve">
          <source>The parallel statement is the preferred mechanism to introduce parallelism in a Nim program. A subset of the Nim language is valid within a &lt;code&gt;parallel&lt;/code&gt; section. This subset is checked to be free of data races at compile time. A sophisticated &lt;span id=&quot;disjoint-checker_1&quot;&gt;disjoint checker&lt;/span&gt; ensures that no data races are possible even though shared memory is extensively supported!</source>
          <target state="translated">并行语句是在Nim程序中引入并行性的首选机制。Nim语言的子集在 &lt;code&gt;parallel&lt;/code&gt; 部分内有效。在编译时检查此子集是否没有数据争用。复杂的&lt;span id=&quot;disjoint-checker_1&quot;&gt;脱节检查器&lt;/span&gt;可确保即使广泛支持共享内存也无法进行数据竞争！</target>
        </trans-unit>
        <trans-unit id="d785f95df44f47948246d72ae65b3b0c993eb38c" translate="yes" xml:space="preserve">
          <source>The parameters' types can be ordinary types or the meta types &lt;code&gt;untyped&lt;/code&gt;, &lt;code&gt;typed&lt;/code&gt;, or &lt;code&gt;type&lt;/code&gt;. &lt;code&gt;type&lt;/code&gt; suggests that only a type symbol may be given as an argument, and &lt;code&gt;untyped&lt;/code&gt; means symbol lookups and type resolution is not performed before the expression is passed to the template.</source>
          <target state="translated">参数的类型可以是普通类型，也可以是 &lt;code&gt;untyped&lt;/code&gt; ， &lt;code&gt;typed&lt;/code&gt; 或 &lt;code&gt;type&lt;/code&gt; 的元类型。 &lt;code&gt;type&lt;/code&gt; 表示只能将类型符号作为自变量，而 &lt;code&gt;untyped&lt;/code&gt; 表示在将表达式传递到模板之前不执行符号查找和类型解析。</target>
        </trans-unit>
        <trans-unit id="81b1f54dcfe838ac2e0c59b6f42dae3e0756b1fe" translate="yes" xml:space="preserve">
          <source>The parser uses a stack of indentation levels: the stack consists of integers counting the spaces. The indentation information is queried at strategic places in the parser but ignored otherwise: The pseudo terminal &lt;code&gt;IND{&amp;gt;}&lt;/code&gt; denotes an indentation that consists of more spaces than the entry at the top of the stack; &lt;code&gt;IND{=}&lt;/code&gt; an indentation that has the same number of spaces. &lt;code&gt;DED&lt;/code&gt; is another pseudo terminal that describes the &lt;em&gt;action&lt;/em&gt; of popping a value from the stack, &lt;code&gt;IND{&amp;gt;}&lt;/code&gt; then implies to push onto the stack.</source>
          <target state="translated">解析器使用缩进级别的堆栈：该堆栈由计算空格的整数组成。缩进信息是在解析器中的关键位置查询的，但否则将被忽略：伪终端 &lt;code&gt;IND{&amp;gt;}&lt;/code&gt; 表示一个缩进，它比堆栈顶部的条目包含更多的空间； &lt;code&gt;IND{=}&lt;/code&gt; 具有相同数量空格的缩进。 &lt;code&gt;DED&lt;/code&gt; 是另一个伪终端，描述了从堆栈中弹出一个值的&lt;em&gt;动作&lt;/em&gt;，然后 &lt;code&gt;IND{&amp;gt;}&lt;/code&gt; 表示压入堆栈。</target>
        </trans-unit>
        <trans-unit id="7f9027f1cfc9029d9bab0ad3b282e7849cb03b34" translate="yes" xml:space="preserve">
          <source>The path analysis is &lt;strong&gt;currently unsound&lt;/strong&gt;, but that doesn't make it useless. Two paths are considered equivalent if they are syntactically the same.</source>
          <target state="translated">路径分析&lt;strong&gt;目前尚不完善&lt;/strong&gt;，但这并没有使它失效。如果两条路径在语法上相同，则认为它们是等效的。</target>
        </trans-unit>
        <trans-unit id="e21fa755d2f9dd13f4c401361fe48cbd80c4ec20" translate="yes" xml:space="preserve">
          <source>The plain name of a symbol is a simplified version of its fully exported signature. Variables or constants have the same plain name symbol as their complex name. The plain name for procs, templates, and other callable types will be their unquoted value after removing parameters, return types and pragmas. The plain name allows short and nice linking of symbols which works unless you have a module with collisions due to overloading.</source>
          <target state="translated">符号的纯名是其完全导出的签名的简化版本。变量或常量的明文名符号与它们的复杂名称相同。procs、模板和其他可调用类型的纯名将是去除参数、返回类型和语法后的未引号值。纯名允许短而好的符号链接,这很有效,除非你的模块由于重载而产生碰撞。</target>
        </trans-unit>
        <trans-unit id="14e09d7c794944bac489c1fb890465f3395a7739" translate="yes" xml:space="preserve">
          <source>The portion matched by &lt;code&gt;sep&lt;/code&gt; is not returned.</source>
          <target state="translated">由 &lt;code&gt;sep&lt;/code&gt; 匹配的部分不返回。</target>
        </trans-unit>
        <trans-unit id="5905889f12b10a582b5de19496532d186574a39d" translate="yes" xml:space="preserve">
          <source>The pragmas listed here can be used to optionally accept values from the -d/--define option at compile time.</source>
          <target state="translated">这里列出的实用名词可以在编译时选择性地接受来自-d/--define选项的值。</target>
        </trans-unit>
        <trans-unit id="f4c1f5ea59e38f8446c010800e904b6889b2d6f5" translate="yes" xml:space="preserve">
          <source>The problem here is that the compiler already decided that &lt;code&gt;something()&lt;/code&gt; as an iterator is not callable in this context before &lt;code&gt;toSeq&lt;/code&gt; gets its chance to convert it into a sequence.</source>
          <target state="translated">这里的问题是，编译器已经确定，在 &lt;code&gt;toSeq&lt;/code&gt; 获得将其转换为序列的机会之前，不能在此上下文中调用 &lt;code&gt;something()&lt;/code&gt; 作为迭代器。</target>
        </trans-unit>
        <trans-unit id="1413d5988b205726c716a63467c96b038a113fd1" translate="yes" xml:space="preserve">
          <source>The proc &lt;code&gt;quit(QuitSuccess)&lt;/code&gt; is called implicitly when your nim program finishes without incident for platforms where this is the expected behavior. A raised unhandled exception is equivalent to calling &lt;code&gt;quit(QuitFailure)&lt;/code&gt;.</source>
          <target state="translated">当您的nim程序完成而对这是预期行为的平台没有意外时，将隐式调用proc &lt;code&gt;quit(QuitSuccess)&lt;/code&gt; 。引发的未处理异常等效于调用 &lt;code&gt;quit(QuitFailure)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7e2d3b14bba8ee482acb489760d42aaa50f22724" translate="yes" xml:space="preserve">
          <source>The proc is meant to parse the Cookie header set by a client, not the &quot;Set-Cookie&quot; header set by servers.</source>
          <target state="translated">这个proc是用来解析客户端设置的Cookie头,而不是服务器设置的 &quot;Set-Cookie &quot;头。</target>
        </trans-unit>
        <trans-unit id="37ebd1b54b6f7339d68d2b35085cae9b111d5bdc" translate="yes" xml:space="preserve">
          <source>The procedure has been designed so that its output is usable for many different common syntaxes. &lt;strong&gt;Note&lt;/strong&gt;: This is not correct for producing Ansi C code!</source>
          <target state="translated">该过程经过设计，使其输出可用于许多不同的通用语法。&lt;strong&gt;注意&lt;/strong&gt;：这对于生成Ansi C代码是不正确的！</target>
        </trans-unit>
        <trans-unit id="e4ed2941bc29e9113b49ab22213c1bd08c56b866" translate="yes" xml:space="preserve">
          <source>The progress of either a file upload or a file download can be checked by specifying a &lt;code&gt;onProgressChanged&lt;/code&gt; procedure to the &lt;code&gt;store&lt;/code&gt; or &lt;code&gt;retrFile&lt;/code&gt; procedures.</source>
          <target state="translated">通过向 &lt;code&gt;store&lt;/code&gt; 或 &lt;code&gt;retrFile&lt;/code&gt; 过程指定 &lt;code&gt;onProgressChanged&lt;/code&gt; 过程，可以检查文件上传或文件下载的进度。</target>
        </trans-unit>
        <trans-unit id="f15f5453e331e56f9b69a6e72ccfba467ab59e8f" translate="yes" xml:space="preserve">
          <source>The project makes use of a deprecated config file.</source>
          <target state="translated">该项目使用了一个过时的配置文件。</target>
        </trans-unit>
        <trans-unit id="0151e7d00a06bf727dbd72da71ba5ce97b155194" translate="yes" xml:space="preserve">
          <source>The reason is that the compiler already transformed the 1 into &quot;1&quot; for the &lt;code&gt;echo&lt;/code&gt; statement. However, a term rewriting macro should not change the semantics anyway. In fact they can be deactivated with the &lt;code&gt;--patterns:off&lt;/code&gt; command line option or temporarily with the &lt;code&gt;patterns&lt;/code&gt; pragma.</source>
          <target state="translated">原因是编译器已经为 &lt;code&gt;echo&lt;/code&gt; 语句将1转换为&amp;ldquo; 1&amp;rdquo; 。但是，术语重写宏无论如何都不应更改语义。实际上，可以使用 &lt;code&gt;--patterns:off&lt;/code&gt; 命令行选项将其停用，也可以使用 &lt;code&gt;patterns&lt;/code&gt; 编译指示将其暂时禁用。</target>
        </trans-unit>
        <trans-unit id="f950b9dc37be83169d340916b25b6ad1600d2a00" translate="yes" xml:space="preserve">
          <source>The reimplementation of this code as a compile time proc will allow us to get rid of the &lt;code&gt;data.cfg&lt;/code&gt; file we would need to distribute along the binary, plus if the information is really constant, it doesn't make from a logical point of view to have it &lt;em&gt;mutable&lt;/em&gt; in a global variable, it would be better if it was a constant. Finally, and likely the most valuable feature, we can implement some verification at compile time. You could think of this as a &lt;em&gt;better unit testing&lt;/em&gt;, since it is impossible to obtain a binary unless everything is correct, preventing you to ship to users a broken program which won't start because a small critical file is missing or its contents changed by mistake to something invalid.</source>
          <target state="translated">将此代码重新实现为编译时proc，将使我们摆脱需要沿着二进制文件分发的 &lt;code&gt;data.cfg&lt;/code&gt; 文件，此外，如果信息确实是恒定的，那么从逻辑的角度来看，它不是必需的。有它&lt;em&gt;可变&lt;/em&gt;的全局变量，它会更好，如果它是一个常数。最后，也是最有价值的功能，我们可以在编译时实施一些验证。您可以将其视为&lt;em&gt;更好的单元测试&lt;/em&gt;，因为除非一切正确，否则不可能获得二进制文件，从而阻止您将损坏的程序交付给用户，该程序由于缺少关键文件太小或内容被更改而无法启动。犯错误</target>
        </trans-unit>
        <trans-unit id="bd941de653f278721095a2c43367c41906f6489e" translate="yes" xml:space="preserve">
          <source>The relationship of type to suffix is made by the proc &lt;code&gt;complexName&lt;/code&gt; in the &lt;code&gt;compiler/docgen.nim&lt;/code&gt; file. Here are some examples of complex names for symbols in the &lt;a href=&quot;system&quot;&gt;system module&lt;/a&gt;.</source>
          <target state="translated">型的以后缀的关系由PROC制成 &lt;code&gt;complexName&lt;/code&gt; 在 &lt;code&gt;compiler/docgen.nim&lt;/code&gt; 文件。这是&lt;a href=&quot;system&quot;&gt;系统模块中&lt;/a&gt;符号的复杂名称的一些示例。</target>
        </trans-unit>
        <trans-unit id="2bf0a82f5d893e438a2023ce750bc90f2a128096" translate="yes" xml:space="preserve">
          <source>The removal of existing files.</source>
          <target state="translated">删除现有文件;</target>
        </trans-unit>
        <trans-unit id="d6fd935f249c62b7608872cee19d42012edb0e86" translate="yes" xml:space="preserve">
          <source>The replace filter replaces substrings in each line.</source>
          <target state="translated">替换过滤器替换每行中的子串。</target>
        </trans-unit>
        <trans-unit id="28a78280047d22a351983c3a0d358b7203f54114" translate="yes" xml:space="preserve">
          <source>The representation of the &lt;code&gt;if&lt;/code&gt; expression is subtle, but easy to traverse.</source>
          <target state="translated">&lt;code&gt;if&lt;/code&gt; 表达式的表示形式很细微，但易于遍历。</target>
        </trans-unit>
        <trans-unit id="73836858e4d8022cd4c46c9283cbdf6cfe3ad8c7" translate="yes" xml:space="preserve">
          <source>The representation of the if statement is subtle, but easy to traverse. If there is no &lt;code&gt;else&lt;/code&gt; branch, no &lt;code&gt;nnkElse&lt;/code&gt; child exists.</source>
          <target state="translated">if语句的表示形式很微妙，但易于遍历。如果没有 &lt;code&gt;else&lt;/code&gt; 分支，则不存在 &lt;code&gt;nnkElse&lt;/code&gt; 子级。</target>
        </trans-unit>
        <trans-unit id="28c784e74f236c4964b6fd6d91fbb0a37256995f" translate="yes" xml:space="preserve">
          <source>The response's body stream is read synchronously.</source>
          <target state="translated">响应的主体流是同步读取的。</target>
        </trans-unit>
        <trans-unit id="989aceedc601a5b9a5742f1d14477507d7adf53d" translate="yes" xml:space="preserve">
          <source>The rest of the line is treated as a &lt;a href=&quot;re&quot;&gt;regular expression&lt;/a&gt;, so be careful escaping metacharacters like parenthesis.</source>
          <target state="translated">该行的其余部分被视为&lt;a href=&quot;re&quot;&gt;正则表达式&lt;/a&gt;，因此请小心转义圆括号之类的元字符。</target>
        </trans-unit>
        <trans-unit id="6de3479f33b83e39dae126f685d1475edff6c449" translate="yes" xml:space="preserve">
          <source>The resulting client socket is automatically registered to the dispatcher.</source>
          <target state="translated">由此产生的客户端套接字会自动注册到调度器。</target>
        </trans-unit>
        <trans-unit id="e81240f3c82766aef65cfde973adbe5730fdaa4e" translate="yes" xml:space="preserve">
          <source>The resulting client will inherit any properties of the server socket. For example: whether the socket is buffered or not.</source>
          <target state="translated">产生的客户端将继承服务器套接字的任何属性。例如:套接字是否被缓冲。</target>
        </trans-unit>
        <trans-unit id="1d0eda4f937e942666810677280a88be73c7577b" translate="yes" xml:space="preserve">
          <source>The resulting string is always &lt;em&gt;len&lt;/em&gt; characters long. No leading &lt;code&gt;0b&lt;/code&gt; prefix is generated.</source>
          <target state="translated">结果字符串始终为&lt;em&gt;len个&lt;/em&gt;字符长。不会产生前导 &lt;code&gt;0b&lt;/code&gt; 前缀。</target>
        </trans-unit>
        <trans-unit id="ea3fa6f05db7b82f91043df8507510ba9b2c0af9" translate="yes" xml:space="preserve">
          <source>The resulting string is always &lt;em&gt;len&lt;/em&gt; characters long. No leading &lt;code&gt;0o&lt;/code&gt; prefix is generated.</source>
          <target state="translated">结果字符串始终为&lt;em&gt;len个&lt;/em&gt;字符长。不会产生前导 &lt;code&gt;0o&lt;/code&gt; 前缀。</target>
        </trans-unit>
        <trans-unit id="45fdb218e0bbadf017f51aea11eb54c54acabed2" translate="yes" xml:space="preserve">
          <source>The resulting string is prefixed with &lt;em&gt;prefix&lt;/em&gt; and suffixed with &lt;em&gt;suffix&lt;/em&gt;. Both may be empty strings.</source>
          <target state="translated">结果字符串以&lt;em&gt;prefix&lt;/em&gt;为前缀，并以&lt;em&gt;suffix为后缀&lt;/em&gt;。两者都可能是空字符串。</target>
        </trans-unit>
        <trans-unit id="403899c0e7f32ab870cef66df940fa7e27c170e3" translate="yes" xml:space="preserve">
          <source>The resulting string may not have a leading zero. Its length is always exactly 3.</source>
          <target state="translated">由此产生的字符串可能没有前导零。它的长度总是正好是3。</target>
        </trans-unit>
        <trans-unit id="30afb7397e54c9840f15c6ce3837b090cbb826dc" translate="yes" xml:space="preserve">
          <source>The resulting string will be exactly &lt;em&gt;len&lt;/em&gt; characters long. No prefix like &lt;code&gt;0x&lt;/code&gt; is generated. &lt;em&gt;x&lt;/em&gt; is treated as an unsigned value.</source>
          <target state="translated">结果字符串将恰好为&lt;em&gt;len个&lt;/em&gt;字符。不会生成像 &lt;code&gt;0x&lt;/code&gt; 这样的前缀。&lt;em&gt;x&lt;/em&gt;被视为无符号值。</target>
        </trans-unit>
        <trans-unit id="f90efc9f77052cc77655df5707232ad9216984b9" translate="yes" xml:space="preserve">
          <source>The resulting string will be minimally &lt;em&gt;minchars&lt;/em&gt; characters long. This is achieved by adding leading zeros.</source>
          <target state="translated">结果字符串的长度最少为&lt;em&gt;minchars个&lt;/em&gt;字符。这可以通过添加前导零来实现。</target>
        </trans-unit>
        <trans-unit id="a48658314c6de6bf50c3ec96a319b4bcbf46bc4f" translate="yes" xml:space="preserve">
          <source>The return value can be ignored implicitly if the called proc/iterator has been declared with the &lt;code&gt;discardable&lt;/code&gt; pragma:</source>
          <target state="translated">如果已使用 &lt;code&gt;discardable&lt;/code&gt; 编译指示声明了被调用的proc / iterator，则可以隐式忽略返回值：</target>
        </trans-unit>
        <trans-unit id="67bd9c724c4f982734f839921c898bc019482c8d" translate="yes" xml:space="preserve">
          <source>The return value can be ignored implicitly if the called proc/iterator has been declared with the &lt;span id=&quot;discardable_1&quot;&gt;discardable&lt;/span&gt; pragma:</source>
          <target state="translated">如果已使用&lt;span id=&quot;discardable_1&quot;&gt;可放弃的&lt;/span&gt;编译指示声明了被调用的proc / iterator，则可以隐式忽略返回值：</target>
        </trans-unit>
        <trans-unit id="756b0797d628461ffc91c206ce4262901afa5425" translate="yes" xml:space="preserve">
          <source>The returned &lt;code&gt;StringTableRef&lt;/code&gt; contains the parameters used by the HTML engine to build the final output. For information on what these parameters are and their purpose, please look up the file &lt;code&gt;config/nimdoc.cfg&lt;/code&gt; bundled with the compiler.</source>
          <target state="translated">返回的 &lt;code&gt;StringTableRef&lt;/code&gt; 包含HTML引擎用来构建最终输出的参数。有关这些参数的含义及其用途的信息，请查找与编译器捆绑在一起的文件 &lt;code&gt;config/nimdoc.cfg&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6d314e6c213f7dc11b7be0a941b6f5bc49b81919" translate="yes" xml:space="preserve">
          <source>The returned Future will complete once all data has been written to the specified file.</source>
          <target state="translated">一旦所有数据被写入指定文件,返回的Future将完成。</target>
        </trans-unit>
        <trans-unit id="d420b4d0177cf52670fb1bd5d6c63c44491d8117" translate="yes" xml:space="preserve">
          <source>The rules for compile-time computability are:</source>
          <target state="translated">编译时可计算性的规则是:</target>
        </trans-unit>
        <trans-unit id="698e091efe4e128cb702c79882a2f45f056f90d7" translate="yes" xml:space="preserve">
          <source>The same action can also be performed asynchronously, simply use the &lt;code&gt;AsyncHttpClient&lt;/code&gt;:</source>
          <target state="translated">也可以异步执行相同的操作，只需使用 &lt;code&gt;AsyncHttpClient&lt;/code&gt; 即可：</target>
        </trans-unit>
        <trans-unit id="4d8108fe45337e2b675ce1f770f1401249335850" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;add(s, formatstr % a)&lt;/code&gt;, but more efficient.</source>
          <target state="translated">与 &lt;code&gt;add(s, formatstr % a)&lt;/code&gt; ，但效率更高。</target>
        </trans-unit>
        <trans-unit id="eea3f061ff9424cd86d52bd3cac8dfd6e94a7529" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;joinPath(head, tail)&lt;/code&gt;</source>
          <target state="translated">与 &lt;code&gt;joinPath(head, tail)&lt;/code&gt; 相同（头，尾）</target>
        </trans-unit>
        <trans-unit id="c4562377386ad596a9d2e194a9741b56a7124917" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;parentDir(head) / tail&lt;/code&gt; unless there is no parent directory. Then &lt;code&gt;head / tail&lt;/code&gt; is performed instead.</source>
          <target state="translated">除非没有父目录，否则与 &lt;code&gt;parentDir(head) / tail&lt;/code&gt; 相同。然后执行 &lt;code&gt;head / tail&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="896b7a919e5c694aa0a0d238075545c1cae1c488" translate="yes" xml:space="preserve">
          <source>The same as &lt;em&gt;joinPath(head, tail)&lt;/em&gt;, but works with any number of directory parts. You need to pass at least one element or the proc will assert in debug builds and crash on release builds.</source>
          <target state="translated">与&lt;em&gt;joinPath（head，tail）相同&lt;/em&gt;，但可用于任意数量的目录部分。您需要传递至少一个元素，否则proc将在调试版本中声明并在发行版本中崩溃。</target>
        </trans-unit>
        <trans-unit id="25fcdd3704177b32025508d9d8dc540fb2c73caa" translate="yes" xml:space="preserve">
          <source>The same as the &lt;a href=&quot;#rsplit.i,string,char,int&quot;&gt;rsplit iterator&lt;/a&gt;, but is a proc that returns a sequence of substrings.</source>
          <target state="translated">与&lt;a href=&quot;#rsplit.i,string,char,int&quot;&gt;rsplit迭代器&lt;/a&gt;相同，但是是一个proc，它返回一系列子字符串。</target>
        </trans-unit>
        <trans-unit id="db09ba6be055ec25fc71a3c77b55d883dbb50574" translate="yes" xml:space="preserve">
          <source>The same as the &lt;a href=&quot;#rsplit.i,string,set%5Bchar%5D,int&quot;&gt;rsplit iterator&lt;/a&gt;, but is a proc that returns a sequence of substrings.</source>
          <target state="translated">与&lt;a href=&quot;#rsplit.i,string,set%5Bchar%5D,int&quot;&gt;rsplit迭代器&lt;/a&gt;相同，但是是一个proc，它返回一系列子字符串。</target>
        </trans-unit>
        <trans-unit id="872080f867045c7487dbf61ec0245aa4502cb8a8" translate="yes" xml:space="preserve">
          <source>The same as the &lt;a href=&quot;#rsplit.i,string,string,int&quot;&gt;rsplit iterator&lt;/a&gt;, but is a proc that returns a sequence of substrings.</source>
          <target state="translated">与&lt;a href=&quot;#rsplit.i,string,string,int&quot;&gt;rsplit迭代器&lt;/a&gt;相同，但是是一个proc，它返回一系列子字符串。</target>
        </trans-unit>
        <trans-unit id="6e5fe058f47f2922444e3cdf8a11480b26b2bdc0" translate="yes" xml:space="preserve">
          <source>The same as the &lt;a href=&quot;#split.i,string,char,int&quot;&gt;split iterator&lt;/a&gt;, but is a proc that returns a sequence of substrings.</source>
          <target state="translated">与&lt;a href=&quot;#split.i,string,char,int&quot;&gt;split迭代器&lt;/a&gt;相同，但是是一个proc，它返回一系列子字符串。</target>
        </trans-unit>
        <trans-unit id="55216d0743f38afb17e58bb0b29813f0ebcc2b0b" translate="yes" xml:space="preserve">
          <source>The same as the &lt;a href=&quot;#split.i,string,set%5Bchar%5D,int&quot;&gt;split iterator&lt;/a&gt;, but is a proc that returns a sequence of substrings.</source>
          <target state="translated">与&lt;a href=&quot;#split.i,string,set%5Bchar%5D,int&quot;&gt;split迭代器&lt;/a&gt;相同，但是是一个proc，它返回一系列子字符串。</target>
        </trans-unit>
        <trans-unit id="f6bd26725a590268da07c53a69dedbe58085e4ed" translate="yes" xml:space="preserve">
          <source>The same as the &lt;a href=&quot;#splitLines.i,string&quot;&gt;splitLines&lt;/a&gt; iterator, but is a proc that returns a sequence of substrings.</source>
          <target state="translated">与&lt;a href=&quot;#splitLines.i,string&quot;&gt;splitLines&lt;/a&gt;迭代器相同，但是是一个可返回一系列子字符串的proc。</target>
        </trans-unit>
        <trans-unit id="155ce31bc857a624f4b637a724b282d2d7a0299b" translate="yes" xml:space="preserve">
          <source>The same as the &lt;a href=&quot;#splitWhitespace.i,string,int&quot;&gt;splitWhitespace&lt;/a&gt; iterator, but is a proc that returns a sequence of substrings.</source>
          <target state="translated">与&lt;a href=&quot;#splitWhitespace.i,string,int&quot;&gt;splitWhitespace&lt;/a&gt;迭代器相同，但是是一个可返回子字符串序列的proc。</target>
        </trans-unit>
        <trans-unit id="10f55c7794b6e447d4540977b35266563d3b8496" translate="yes" xml:space="preserve">
          <source>The same syntax applies to &lt;code&gt;iterator&lt;/code&gt; (with &lt;code&gt;nnkIteratorTy&lt;/code&gt;), but &lt;em&gt;does not&lt;/em&gt; apply to &lt;code&gt;converter&lt;/code&gt; or &lt;code&gt;template&lt;/code&gt;.</source>
          <target state="translated">相同的语法适用于 &lt;code&gt;iterator&lt;/code&gt; （带 &lt;code&gt;nnkIteratorTy&lt;/code&gt; ），但&lt;em&gt;并不&lt;/em&gt;适用于 &lt;code&gt;converter&lt;/code&gt; 或 &lt;code&gt;template&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8f2b58b4e423bfdce9cdf95cfb670ae8ff6353ae" translate="yes" xml:space="preserve">
          <source>The scanp macro</source>
          <target state="translated">Scanp 宏</target>
        </trans-unit>
        <trans-unit id="1c86c735cf43c50791d8029b9f0a87ffd482fd7f" translate="yes" xml:space="preserve">
          <source>The second operator of &lt;em&gt;*&lt;/em&gt; must be a parameter; it is used to gather all the arguments. The expression &lt;code&gt;&quot;my&quot; &amp;amp;&amp;amp; (space &amp;amp; &quot;awe&quot; &amp;amp;&amp;amp; &quot;some &quot; ) &amp;amp;&amp;amp; &quot;concat&quot;&lt;/code&gt; is passed to &lt;code&gt;optConc&lt;/code&gt; in &lt;code&gt;a&lt;/code&gt; as a special list (of kind &lt;code&gt;nkArgList&lt;/code&gt;) which is flattened into a call expression; thus the invocation of &lt;code&gt;optConc&lt;/code&gt; produces:</source>
          <target state="translated">&lt;em&gt;*&lt;/em&gt;的第二个运算符必须是参数；它用于收集所有参数。表达式 &lt;code&gt;&quot;my&quot; &amp;amp;&amp;amp; (space &amp;amp; &quot;awe&quot; &amp;amp;&amp;amp; &quot;some &quot; ) &amp;amp;&amp;amp; &quot;concat&quot;&lt;/code&gt; 作为特殊列表（类型为 &lt;code&gt;nkArgList&lt;/code&gt; ）传递给 &lt;code&gt;optConc&lt;/code&gt; ， &lt;code&gt;a&lt;/code&gt; 列表被扁平化为调用表达式；因此，调用 &lt;code&gt;optConc&lt;/code&gt; 会产生：</target>
        </trans-unit>
        <trans-unit id="5ae0df5a264f4266cdb5160062cd0aaa33125c37" translate="yes" xml:space="preserve">
          <source>The sequence is required to have at least a single element. Debug versions of your program will assert in this situation but release versions will happily go ahead. If the sequence has a single element it will be returned without applying &lt;code&gt;operation&lt;/code&gt;.</source>
          <target state="translated">该序列必须至少包含一个元素。在这种情况下，您的程序的调试版本会有效，但发行版本会很高兴继续进行。如果序列有一个单一的元素，它将不应用返回 &lt;code&gt;operation&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="de05e83beaaac1f274966bd69ab8d48a0491b166" translate="yes" xml:space="preserve">
          <source>The set type models the mathematical notion of a set. The set's basetype can only be an ordinal type of a certain size, namely:</source>
          <target state="translated">集合类型是集的数学概念的模型。集的基型只能是一定大小的序型,即:</target>
        </trans-unit>
        <trans-unit id="aa01d82d61dfce28cfeda16c5bd80e4dbed31204" translate="yes" xml:space="preserve">
          <source>The setrlimit() system calls sets resource limits.</source>
          <target state="translated">setrlimit()系统调用设置资源限制。</target>
        </trans-unit>
        <trans-unit id="2b11bf3cb2bd50300b9f5b036f32f39ad404f4b8" translate="yes" xml:space="preserve">
          <source>The signature has to be:</source>
          <target state="translated">签名必须是:</target>
        </trans-unit>
        <trans-unit id="2bed7f833a05e8210ed42f0ce7ddfee8765659dd" translate="yes" xml:space="preserve">
          <source>The size of the bool type is one byte.</source>
          <target state="translated">bool类型的大小是一个字节。</target>
        </trans-unit>
        <trans-unit id="d6a8c97ed2a17dc44a3f97e1801a8e2cbc5ffe6e" translate="yes" xml:space="preserve">
          <source>The smallest positive (nonzero) number that can be represented in a 32-bit floating-point type.</source>
          <target state="translated">可以用32位浮点类型表示的最小正数(非零)。</target>
        </trans-unit>
        <trans-unit id="37339a476e0f2e7116d49064ea767be2f3f7d153" translate="yes" xml:space="preserve">
          <source>The smallest positive (nonzero) number that can be represented in a 64-bit floating-point type.</source>
          <target state="translated">可以用64位浮点类型表示的最小正数(非零)。</target>
        </trans-unit>
        <trans-unit id="dc5780ad9a486e96ea340daaaf93bd9d64035e65" translate="yes" xml:space="preserve">
          <source>The solution is to &lt;strong&gt;re-play&lt;/strong&gt; the module's top level statements. This solves the problem without having to special case the logic that fills the internal seqs which are affected by the pragmas.</source>
          <target state="translated">解决方案是&lt;strong&gt;重新播放&lt;/strong&gt;模块的顶级语句。这样就解决了问题，而无需特殊情况下填充由编译指示影响的内部序列的逻辑。</target>
        </trans-unit>
        <trans-unit id="9449ed4a1afa5ff8ca6796adc72142c21a9e0e84" translate="yes" xml:space="preserve">
          <source>The source line that triggered a diagnostic message.</source>
          <target state="translated">触发诊断信息的源行。</target>
        </trans-unit>
        <trans-unit id="799e7aa051d179767ffba8160a4bb2cdfa09b721" translate="yes" xml:space="preserve">
          <source>The special &lt;code&gt;result&lt;/code&gt; variable.</source>
          <target state="translated">特殊 &lt;code&gt;result&lt;/code&gt; 变量。</target>
        </trans-unit>
        <trans-unit id="68b5ebd6f219423fa1db061ea18fb296f76e1f9f" translate="yes" xml:space="preserve">
          <source>The square brackets &lt;code&gt;[]&lt;/code&gt; indicate an optional element.</source>
          <target state="translated">方括号 &lt;code&gt;[]&lt;/code&gt; 表示可选元素。</target>
        </trans-unit>
        <trans-unit id="f2a70efe37ccaad3ecc8b9b1191dbd149f70e953" translate="yes" xml:space="preserve">
          <source>The standard distribution ships with the following tools:</source>
          <target state="translated">标准发行版附带以下工具:</target>
        </trans-unit>
        <trans-unit id="c14ddf17075fee8f053a24cb7922aea2d8242099" translate="yes" xml:space="preserve">
          <source>The standard error stream.</source>
          <target state="translated">标准误差流。</target>
        </trans-unit>
        <trans-unit id="25a87846c6350f9b0dad73c8670fb5c7a560abfc" translate="yes" xml:space="preserve">
          <source>The standard input stream.</source>
          <target state="translated">标准输入流。</target>
        </trans-unit>
        <trans-unit id="0c3f75a49135f9016942ef1a6c30dd582e32a67d" translate="yes" xml:space="preserve">
          <source>The standard library can be avoided to a point where C code generation for 16bit micro controllers is feasible. Use the &lt;span id=&quot;standalone_1&quot;&gt;standalone&lt;/span&gt; target (&lt;code&gt;--os:standalone&lt;/code&gt;) for a bare bones standard library that lacks any OS features.</source>
          <target state="translated">可以避免在16位微控制器的C代码生成可行的情况下使用标准库。对于没有任何操作系统功能的基本标准库，请使用&lt;span id=&quot;standalone_1&quot;&gt;独立&lt;/span&gt;目标（ &lt;code&gt;--os:standalone&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="3bbcfca9d43af60421b59aa297f2843d4ff476d7" translate="yes" xml:space="preserve">
          <source>The standard library supports a growing number of &lt;code&gt;useX&lt;/code&gt; conditional defines affecting how some features are implemented. This section tries to give a complete list.</source>
          <target state="translated">标准库支持越来越多的 &lt;code&gt;useX&lt;/code&gt; 条件定义，这些条件定义影响实现某些功能的方式。本节尝试给出完整的列表。</target>
        </trans-unit>
        <trans-unit id="3a9e602747062d7eede03400aa4e39b2ccb593c6" translate="yes" xml:space="preserve">
          <source>The standard output stream.</source>
          <target state="translated">标准输出流。</target>
        </trans-unit>
        <trans-unit id="e587b063e208685c74c0b90958dc5ab40a14e654" translate="yes" xml:space="preserve">
          <source>The statements after the &lt;code&gt;try&lt;/code&gt; are executed in sequential order unless an exception &lt;code&gt;e&lt;/code&gt; is raised. If the exception type of &lt;code&gt;e&lt;/code&gt; matches any listed in an &lt;code&gt;except&lt;/code&gt; clause the corresponding statements are executed. The statements following the &lt;code&gt;except&lt;/code&gt; clauses are called &lt;span id=&quot;exception-handlers_1&quot;&gt;exception handlers&lt;/span&gt;.</source>
          <target state="translated">&lt;code&gt;try&lt;/code&gt; 后的语句将按顺序执行，除非引发异常 &lt;code&gt;e&lt;/code&gt; 。如果 &lt;code&gt;e&lt;/code&gt; 的异常类型与 &lt;code&gt;except&lt;/code&gt; 子句中列出的任何异常类型匹配，则将执行相应的语句。 &lt;code&gt;except&lt;/code&gt; 子句后面的语句称为&lt;span id=&quot;exception-handlers_1&quot;&gt;异常处理程序&lt;/span&gt;。</target>
        </trans-unit>
        <trans-unit id="5e42bdb57f1a751ebb6ae75640b75ab4a37accc2" translate="yes" xml:space="preserve">
          <source>The statements after the &lt;code&gt;try&lt;/code&gt; are executed unless an exception is raised. Then the appropriate &lt;code&gt;except&lt;/code&gt; part is executed.</source>
          <target state="translated">除非引发异常，否则将执行 &lt;code&gt;try&lt;/code&gt; 之后的语句。然后执行适当的 &lt;code&gt;except&lt;/code&gt; 部分。</target>
        </trans-unit>
        <trans-unit id="1f3324ba035483cd423641c95748bc8274785628" translate="yes" xml:space="preserve">
          <source>The statements do not open a new scope.</source>
          <target state="translated">这些语句不会打开一个新的范围。</target>
        </trans-unit>
        <trans-unit id="885e9c28443dfee3e864ed46b2792fa6eef8a60c" translate="yes" xml:space="preserve">
          <source>The statements that belong to the expression that evaluated to true are translated by the compiler, the other statements are not checked for semantics! However, each condition is checked for semantics.</source>
          <target state="translated">属于表达式的语句,评价为真的语句会被编译器翻译,其他语句不进行语义检查!但每个条件都会进行语义检查。但是,每个条件都会进行语义检查。</target>
        </trans-unit>
        <trans-unit id="e6d4574c29f988390f3a56cfec01b716ffdcfb61" translate="yes" xml:space="preserve">
          <source>The statements within a branch do not open a new scope.</source>
          <target state="translated">分支内的语句不会打开一个新的范围。</target>
        </trans-unit>
        <trans-unit id="4e30151d5e9f17c8b266d5c2ebc2ca35ea0c04ba" translate="yes" xml:space="preserve">
          <source>The status of a test when it is done.</source>
          <target state="translated">测试完成后的状态。</target>
        </trans-unit>
        <trans-unit id="fd60c4990adcd88d94b2b574d1d8c68d1fefb098" translate="yes" xml:space="preserve">
          <source>The stdlib API is designed to be &lt;strong&gt;easy to use&lt;/strong&gt; and consistent. Ease of use is measured by the number of calls to achieve a concrete high level action. The ultimate goal is that the programmer can &lt;em&gt;guess&lt;/em&gt; a name.</source>
          <target state="translated">stdlib API设计为&lt;strong&gt;易于使用&lt;/strong&gt;且一致。易用性是通过达到具体的高级别操作的呼叫次数来衡量的。最终目标是程序员可以&lt;em&gt;猜出&lt;/em&gt;一个名字。</target>
        </trans-unit>
        <trans-unit id="10b2a953237a037ac2265ff58952966ca750b340" translate="yes" xml:space="preserve">
          <source>The stdtmpl filter provides a simple templating engine for Nim. The filter uses a line based parser: Lines prefixed with a &lt;em&gt;meta character&lt;/em&gt; (default: &lt;code&gt;#&lt;/code&gt;) contain Nim code, other lines are verbatim. Because indentation-based parsing is not suited for a templating engine, control flow statements need &lt;code&gt;end X&lt;/code&gt; delimiters.</source>
          <target state="translated">stdtmpl过滤器为Nim提供了一个简单的模板引擎。筛选器使用基于行的解析器：带有&lt;em&gt;元字符&lt;/em&gt;（默认值： &lt;code&gt;#&lt;/code&gt; ）的行包含Nim代码，其他行是逐字的。由于基于缩进的解析不适用于模板引擎，因此控制流语句需要使用 &lt;code&gt;end X&lt;/code&gt; 定界符。</target>
        </trans-unit>
        <trans-unit id="d853705ac2e16ddbf20df344526fe76e5bbe1d6b" translate="yes" xml:space="preserve">
          <source>The string literal passed to &lt;code&gt;exportc&lt;/code&gt; can be a format string:</source>
          <target state="translated">传递给 &lt;code&gt;exportc&lt;/code&gt; 的字符串文字可以是格式字符串：</target>
        </trans-unit>
        <trans-unit id="bc021537db9d4c37bc85c30ff44582b67a30832c" translate="yes" xml:space="preserve">
          <source>The string literal passed to &lt;code&gt;importc&lt;/code&gt; can be a format string:</source>
          <target state="translated">传递给 &lt;code&gt;importc&lt;/code&gt; 的字符串文字可以是格式字符串：</target>
        </trans-unit>
        <trans-unit id="4d2a1a53ec06666d804727e437f2a83c5ef106f3" translate="yes" xml:space="preserve">
          <source>The stringify operator for a CString argument. Returns &lt;em&gt;x&lt;/em&gt; converted to a string.</source>
          <target state="translated">CString参数的stringify运算符。返回&lt;em&gt;x&lt;/em&gt;转换为字符串。</target>
        </trans-unit>
        <trans-unit id="c484fec0f015605339671fc06ee766d4baaf377e" translate="yes" xml:space="preserve">
          <source>The stringify operator for a boolean argument. Returns &lt;em&gt;x&lt;/em&gt; converted to the string &quot;false&quot; or &quot;true&quot;.</source>
          <target state="translated">布尔参数的stringify运算符。返回&lt;em&gt;x&lt;/em&gt;转换为字符串&amp;ldquo; false&amp;rdquo;或&amp;ldquo; true&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="a992e6797c902629fdda65b889cba064825234dc" translate="yes" xml:space="preserve">
          <source>The stringify operator for a character argument. Returns &lt;em&gt;x&lt;/em&gt; converted to a string.</source>
          <target state="translated">字符参数的stringify运算符。返回&lt;em&gt;x&lt;/em&gt;转换为字符串。</target>
        </trans-unit>
        <trans-unit id="89e3fe4dd1865173eb89990a7d7f5be7c43387f1" translate="yes" xml:space="preserve">
          <source>The stringify operator for a float argument. Returns &lt;em&gt;x&lt;/em&gt; converted to a decimal string.</source>
          <target state="translated">float参数的stringify运算符。返回&lt;em&gt;x&lt;/em&gt;转换为十进制字符串。</target>
        </trans-unit>
        <trans-unit id="c0db5c9df492c1a8b3dd9a2a95f9cef2f3e526af" translate="yes" xml:space="preserve">
          <source>The stringify operator for a string argument. Returns &lt;em&gt;x&lt;/em&gt; as it is. This operator is useful for generic code, so that &lt;code&gt;$expr&lt;/code&gt; also works if &lt;code&gt;expr&lt;/code&gt; is already a string.</source>
          <target state="translated">字符串参数的stringify运算符。按原样返回&lt;em&gt;x&lt;/em&gt;。该运算符对通用代码很有用，因此，如果 &lt;code&gt;expr&lt;/code&gt; 已经是字符串，则 &lt;code&gt;$expr&lt;/code&gt; 也可以使用。</target>
        </trans-unit>
        <trans-unit id="3ee7503135fe164e7c14568404ab5024b8abba0c" translate="yes" xml:space="preserve">
          <source>The stringify operator for an enumeration argument. This works for any enumeration type thanks to compiler magic. If a &lt;code&gt;$&lt;/code&gt; operator for a concrete enumeration is provided, this is used instead. (In other words: &lt;em&gt;Overwriting&lt;/em&gt; is possible.)</source>
          <target state="translated">枚举参数的stringify运算符。多亏了编译器的魔力，该方法适用于任何枚举类型。如果提供 &lt;code&gt;$&lt;/code&gt; 用于具体枚举的$运算符，则使用$运算符。（换句话说：可以&lt;em&gt;覆盖&lt;/em&gt;。）</target>
        </trans-unit>
        <trans-unit id="e386bfe78072559f8bbde8532560130a6e7ea6ed" translate="yes" xml:space="preserve">
          <source>The stringify operator for an integer argument. Returns &lt;em&gt;x&lt;/em&gt; converted to a decimal string.</source>
          <target state="translated">整数参数的stringify运算符。返回&lt;em&gt;x&lt;/em&gt;转换为十进制字符串。</target>
        </trans-unit>
        <trans-unit id="606e2a47ef9a1510fef08559a8704f9cc52bd2a6" translate="yes" xml:space="preserve">
          <source>The stringify operator for an integer argument. Returns &lt;em&gt;x&lt;/em&gt; converted to a decimal string. &lt;code&gt;$&lt;/code&gt; is Nim's general way of spelling &lt;span id=&quot;tostring_1&quot;&gt;toString&lt;/span&gt;.</source>
          <target state="translated">整数参数的stringify运算符。返回&lt;em&gt;x&lt;/em&gt;转换为十进制字符串。 &lt;code&gt;$&lt;/code&gt; 是Nim拼写&lt;span id=&quot;tostring_1&quot;&gt;toString&lt;/span&gt;的通用方法。</target>
        </trans-unit>
        <trans-unit id="df81e6c55f80fcc8fa6ae2e9828d9cd7028b723f" translate="yes" xml:space="preserve">
          <source>The strip filter simply removes leading and trailing whitespace from each line.</source>
          <target state="translated">条形过滤器简单地从每一行中删除前导和后导的空白。</target>
        </trans-unit>
        <trans-unit id="8354da2777d5d9c0570db388afcea4a685a09419" translate="yes" xml:space="preserve">
          <source>The subexpression after the colon (&lt;code&gt;arg&lt;/code&gt; in &lt;code&gt;&amp;amp;&quot;{key} is {value:arg} {{z}}&quot;&lt;/code&gt;) is an optional argument passed to &lt;code&gt;format&lt;/code&gt;.</source>
          <target state="translated">冒号后的子表达式（ &lt;code&gt;arg&lt;/code&gt; 在 &lt;code&gt;&amp;amp;&quot;{key} is {value:arg} {{z}}&quot;&lt;/code&gt; ）是传递到一个可选的参数 &lt;code&gt;format&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="085f167d1954a66b4d663e11ef8c099c5beed236" translate="yes" xml:space="preserve">
          <source>The subset is in fact the full language with the following restrictions / changes:</source>
          <target state="translated">该子集实际上是完整的语言,但有以下限制/变化。</target>
        </trans-unit>
        <trans-unit id="13d7858966cc6cd5e4db4c4d41318b516b21b8a4" translate="yes" xml:space="preserve">
          <source>The substitution character introduces a Nim expression &lt;em&gt;e&lt;/em&gt; within the string literal. &lt;em&gt;e&lt;/em&gt; is converted to a string with the &lt;em&gt;toString&lt;/em&gt; operation which defaults to &lt;code&gt;$&lt;/code&gt;. For strong type checking, set &lt;code&gt;toString&lt;/code&gt; to the empty string. &lt;em&gt;e&lt;/em&gt; must match this PEG pattern:</source>
          <target state="translated">替换字符在字符串文字中引入了Nim表达式&lt;em&gt;e&lt;/em&gt;。&lt;em&gt;e&lt;/em&gt;使用&lt;em&gt;toString&lt;/em&gt;操作转换为字符串，默认为 &lt;code&gt;$&lt;/code&gt; 。为了进行强类型检查，请将 &lt;code&gt;toString&lt;/code&gt; 设置为空字符串。&lt;em&gt;e&lt;/em&gt;必须匹配此PEG模式：</target>
        </trans-unit>
        <trans-unit id="167b71fcfef3ed3730604fc6b40f66159f634c79" translate="yes" xml:space="preserve">
          <source>The substitution variables (the thing after the &lt;code&gt;$&lt;/code&gt;) are enumerated from 1 to &lt;code&gt;a.len&lt;/code&gt;. To produce a verbatim &lt;code&gt;$&lt;/code&gt;, use &lt;code&gt;$$&lt;/code&gt;. The notation &lt;code&gt;$#&lt;/code&gt; can be used to refer to the next substitution variable:</source>
          <target state="translated">替换变量（ &lt;code&gt;$&lt;/code&gt; 之后的值）从1枚举到 &lt;code&gt;a.len&lt;/code&gt; 。要产生逐字 &lt;code&gt;$&lt;/code&gt; ，请使用 &lt;code&gt;$$&lt;/code&gt; 。 &lt;code&gt;$#&lt;/code&gt; 符号可用于引用下一个替换变量：</target>
        </trans-unit>
        <trans-unit id="d363d1e70588dfd25d1127db5f03a916d9f112a5" translate="yes" xml:space="preserve">
          <source>The suite will run the individual test cases in the order in which they were listed. With default global settings the above code prints:</source>
          <target state="translated">该套件将按照列出的顺序运行各个测试用例。在默认的全局设置下,打印上述代码。</target>
        </trans-unit>
        <trans-unit id="58f6801df2beac64305a6335b8896742f456c35c" translate="yes" xml:space="preserve">
          <source>The supplied &lt;code&gt;fd&lt;/code&gt;'s non-blocking state will be enabled implicitly.</source>
          <target state="translated">提供的 &lt;code&gt;fd&lt;/code&gt; 的非阻塞状态将隐式启用。</target>
        </trans-unit>
        <trans-unit id="80f2150ae39427c1e80e64b88f0a9a85b61d40f9" translate="yes" xml:space="preserve">
          <source>The symbol binding rules in generics are slightly subtle: There are &quot;open&quot; and &quot;closed&quot; symbols. A &quot;closed&quot; symbol cannot be re-bound in the instantiation context, an &quot;open&quot; symbol can. Per default overloaded symbols are open and every other symbol is closed.</source>
          <target state="translated">属类中的符号绑定规则略显微妙:符号有 &quot;开放 &quot;和 &quot;封闭 &quot;之分。一个 &quot;封闭的 &quot;符号不能在实例化上下文中重新绑定,一个 &quot;开放的 &quot;符号可以。默认情况下,重载符号是开放的,其他符号都是封闭的。</target>
        </trans-unit>
        <trans-unit id="1b8df85fe6e5d00af794928d133e0df6b4e79a93" translate="yes" xml:space="preserve">
          <source>The symbol's &lt;code&gt;ast&lt;/code&gt; field is loaded lazily, on demand. This is where most savings come from, only the shallow outer AST is reconstructed immediately.</source>
          <target state="translated">符号的 &lt;code&gt;ast&lt;/code&gt; 字段按需延迟加载。这是大多数节省的地方，只有立即重建浅外部AST。</target>
        </trans-unit>
        <trans-unit id="9db37ffc32ca144aebdbca14546aec93600a111e" translate="yes" xml:space="preserve">
          <source>The symmetric difference of two sets is represented mathematically as &lt;em&gt;A △ B&lt;/em&gt; or &lt;em&gt;A ⊖ B&lt;/em&gt; and is the set of all objects that are members of &lt;em&gt;s1&lt;/em&gt; or &lt;em&gt;s2&lt;/em&gt; but not both at the same time. Example:</source>
          <target state="translated">两组的对称差在数学上表示为&lt;em&gt;A△B&lt;/em&gt;或&lt;em&gt;A⊖B，&lt;/em&gt;并且是&lt;em&gt;s1&lt;/em&gt;或&lt;em&gt;s2的&lt;/em&gt;成员但不是同时属于两个的所有对象的集合。例：</target>
        </trans-unit>
        <trans-unit id="b6a7467e652ab7936684b0f288dffd1681193ff3" translate="yes" xml:space="preserve">
          <source>The syntax &lt;code&gt;import dir / [moduleA, moduleB]&lt;/code&gt; can be used to import multiple modules from the same directory.</source>
          <target state="translated">语法 &lt;code&gt;import dir / [moduleA, moduleB]&lt;/code&gt; 可用于从同一目录导入多个模块。</target>
        </trans-unit>
        <trans-unit id="b40da33c17602bee643c7f4057eb8022801e2460" translate="yes" xml:space="preserve">
          <source>The syntax for iterators is similar to procs, but with &lt;code&gt;nnkIteratorDef&lt;/code&gt; replacing &lt;code&gt;nnkProcDef&lt;/code&gt;.</source>
          <target state="translated">迭代器的语法与procs类似，但是用 &lt;code&gt;nnkIteratorDef&lt;/code&gt; 代替 &lt;code&gt;nnkProcDef&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5e8fda84a4ffe40d2120509d7a72b690281067e4" translate="yes" xml:space="preserve">
          <source>The syntax for nested arrays (multidimensional) in other languages is a matter of appending more brackets because usually each dimension is restricted to the same index type as the others. In Nim you can have different dimensions with different index types, so the nesting syntax is slightly different. Building on the previous example where a level is defined as an array of enums indexed by yet another enum, we can add the following lines to add a light tower type subdivided in height levels accessed through their integer index:</source>
          <target state="translated">在其他语言中,嵌套数组(多维)的语法就是多加括号的问题,因为通常每个维度都被限制在与其他维度相同的索引类型。在Nim中,你可以拥有不同的维度和不同的索引类型,所以嵌套语法略有不同。在上一个例子的基础上,级别被定义为一个由又一个枚举索引的数组,我们可以添加下面的行来添加一个通过其整数索引访问的高度级别细分的光塔类型。</target>
        </trans-unit>
        <trans-unit id="0fc163c5356858c1953a68e20f8853fbed990195" translate="yes" xml:space="preserve">
          <source>The syntax for type conversions is &lt;code&gt;destination_type(expression_to_convert)&lt;/code&gt; (like an ordinary call):</source>
          <target state="translated">类型转换的语法是 &lt;code&gt;destination_type(expression_to_convert)&lt;/code&gt; （类似于普通调用）：</target>
        </trans-unit>
        <trans-unit id="2f95970b03c93b55b855c3143404ffb154e93738" translate="yes" xml:space="preserve">
          <source>The syntax of &lt;code&gt;case&lt;/code&gt; in an object declaration follows closely the syntax of the &lt;code&gt;case&lt;/code&gt; statement: The branches in a &lt;code&gt;case&lt;/code&gt; section may be indented too.</source>
          <target state="translated">对象声明中 &lt;code&gt;case&lt;/code&gt; 的语法紧跟 &lt;code&gt;case&lt;/code&gt; 语句的语法： &lt;code&gt;case&lt;/code&gt; 部分中的分支也可以缩进。</target>
        </trans-unit>
        <trans-unit id="8df91b05c23f64188bd8503b3710389f5709acad" translate="yes" xml:space="preserve">
          <source>The syntax to &lt;em&gt;invoke&lt;/em&gt; a template is the same as calling a procedure.</source>
          <target state="translated">&lt;em&gt;调用&lt;/em&gt;模板的语法与&lt;em&gt;调用过程&lt;/em&gt;的语法相同。</target>
        </trans-unit>
        <trans-unit id="379a9e1787c2fb57f06adcc397630994d8088c6e" translate="yes" xml:space="preserve">
          <source>The syntax tree</source>
          <target state="translated">语法树</target>
        </trans-unit>
        <trans-unit id="f8025e01a9219586f4ea9ca1e8fe9cf0b016b7a2" translate="yes" xml:space="preserve">
          <source>The syntax tree consists of nodes which may have an arbitrary number of children. Types and symbols are represented by other nodes, because they may contain cycles. The AST changes its shape after semantic checking. This is needed to make life easier for the code generators. See the &quot;ast&quot; module for the type definitions. The &lt;a href=&quot;macros&quot;&gt;macros&lt;/a&gt; module contains many examples how the AST represents each syntactic structure.</source>
          <target state="translated">语法树由可以具有任意数量的子代的节点组成。类型和符号由其他节点表示，因为它们可能包含循环。AST在语义检查后更改其形状。为了使代码生成器的工作更轻松，这是必需的。有关类型定义，请参见&amp;ldquo; ast&amp;rdquo;模块。该&lt;a href=&quot;macros&quot;&gt;宏&lt;/a&gt;模块包含了许多例子AST如何表示每个语法结构。</target>
        </trans-unit>
        <trans-unit id="46885e1cfadfc4a010003eabca5811146f7c040a" translate="yes" xml:space="preserve">
          <source>The syscall convention is the same as &lt;code&gt;__syscall&lt;/code&gt; in C. It is used for interrupts.</source>
          <target state="translated">syscall约定与C中的 &lt;code&gt;__syscall&lt;/code&gt; 相同。它用于中断。</target>
        </trans-unit>
        <trans-unit id="a3f6bdaaf4d5477f1c500a92aa3e349f56e0070d" translate="yes" xml:space="preserve">
          <source>The temp command builds the Nim compiler but with a different final name (&lt;code&gt;nim_temp&lt;/code&gt;), so it doesn't overwrite your normal compiler. You can use this command to test different options, the same you would issue for the &lt;a href=&quot;#boot-command&quot;&gt;boot command&lt;/a&gt;.</source>
          <target state="translated">temp命令将构建Nim编译器，但使用不同的最终名称（ &lt;code&gt;nim_temp&lt;/code&gt; ），因此它不会覆盖您的常规编译器。您可以使用此命令测试不同的选项，与对&lt;a href=&quot;#boot-command&quot;&gt;boot命令&lt;/a&gt;发出的选项相同。</target>
        </trans-unit>
        <trans-unit id="3df22e7a1794dd0ef985c2174f0bd9d90ca21bb9" translate="yes" xml:space="preserve">
          <source>The template engine is quite flexible. It is easy to produce a procedure that writes the template code directly to a file:</source>
          <target state="translated">模板引擎是相当灵活的。很容易制作一个过程,将模板代码直接写入文件。</target>
        </trans-unit>
        <trans-unit id="5d144a85c6f59928edd7f189f3b6401e2a927278" translate="yes" xml:space="preserve">
          <source>The template injects the &lt;code&gt;it&lt;/code&gt; variable which you can use directly in an expression.</source>
          <target state="translated">模板将注入 &lt;code&gt;it&lt;/code&gt; 变量，您可以直接在表达式中使用它。</target>
        </trans-unit>
        <trans-unit id="9b23f79ed77cf3b0ae3ac2cd0d6a1fd2ff5bea88" translate="yes" xml:space="preserve">
          <source>The template injects the &lt;code&gt;it&lt;/code&gt; variable which you can use directly in an expression. Example:</source>
          <target state="translated">模板将注入 &lt;code&gt;it&lt;/code&gt; 变量，您可以直接在表达式中使用它。例：</target>
        </trans-unit>
        <trans-unit id="71559554774a606802fa41138d874a38d2c3c673" translate="yes" xml:space="preserve">
          <source>The template injects the &lt;code&gt;it&lt;/code&gt; variable which you can use directly in an expression. The expression has to return the same type as the sequence you are mutating.</source>
          <target state="translated">模板将注入 &lt;code&gt;it&lt;/code&gt; 变量，您可以直接在表达式中使用它。表达式必须返回与您要突变的序列相同的类型。</target>
        </trans-unit>
        <trans-unit id="7e6285ee4f6bf81ff2cc725be672e1b5b5dc8943" translate="yes" xml:space="preserve">
          <source>The template injects the &lt;code&gt;it&lt;/code&gt; variable which you can use directly in an expression. You also need to pass as &lt;em&gt;typ&lt;/em&gt; the type of the expression, since the new returned sequence can have a different type than the original.</source>
          <target state="translated">模板将注入 &lt;code&gt;it&lt;/code&gt; 变量，您可以直接在表达式中使用它。您还需要通过为&lt;em&gt;典型值&lt;/em&gt;表达式的类型，因为新的返回序列可以有不同的类型比原来的。</target>
        </trans-unit>
        <trans-unit id="a708a430f68cec5b9b3fed13a7aade1b333cf36a" translate="yes" xml:space="preserve">
          <source>The terminating zero cannot be accessed unless the string is converted to the &lt;code&gt;cstring&lt;/code&gt; type first. The terminating zero assures that this conversion can be done in O(1) and without any allocations.</source>
          <target state="translated">除非先将字符串转换为 &lt;code&gt;cstring&lt;/code&gt; 类型，否则不能访问终止零。终止零确保可以在O（1）中完成此转换，而无需进行任何分配。</target>
        </trans-unit>
        <trans-unit id="6f48e150aa0a5a53af6ca79d3b6ba9e7f7657bf6" translate="yes" xml:space="preserve">
          <source>The test status and name is printed after any output or traceback.</source>
          <target state="translated">测试状态和名称会在任何输出或回溯后打印出来。</target>
        </trans-unit>
        <trans-unit id="526c72c6f1f64cc3b20092dd199d521f48bbae6b" translate="yes" xml:space="preserve">
          <source>The third and last way to write string literals are &lt;em&gt;long string literals&lt;/em&gt;. They are written with three quotes: &lt;code&gt;&quot;&quot;&quot; ... &quot;&quot;&quot;&lt;/code&gt;; they can span over multiple lines and the &lt;code&gt;\&lt;/code&gt; is not an escape character either. They are very useful for embedding HTML code templates for example.</source>
          <target state="translated">写字符串文字的第三种也是最后一种方式是&lt;em&gt;长字符串文字&lt;/em&gt;。它们用三个引号引起来： &lt;code&gt;&quot;&quot;&quot; ... &quot;&quot;&quot;&lt;/code&gt; ; 它们可以跨越多行，并且 &lt;code&gt;\&lt;/code&gt; 也不是转义字符。例如，它们对于嵌入HTML代码模板非常有用。</target>
        </trans-unit>
        <trans-unit id="c7d0bff946245f3196ff3fec3eab7b5f9ec10e1f" translate="yes" xml:space="preserve">
          <source>The third use of backslash is for specifying &lt;span id=&quot;generic-character-types_1&quot;&gt;generic character types&lt;/span&gt;. The following are always recognized:</source>
          <target state="translated">反斜杠的第三种用法是用于指定&lt;span id=&quot;generic-character-types_1&quot;&gt;通用字符类型&lt;/span&gt;。始终公认以下几点：</target>
        </trans-unit>
        <trans-unit id="716122720506770b96f97a3949c5f63d216ca318" translate="yes" xml:space="preserve">
          <source>The trailing newline character(s) are removed from the iterated lines. Example:</source>
          <target state="translated">从迭代行中删除尾部的换行符。例子:</target>
        </trans-unit>
        <trans-unit id="088f34b2b9f2860def75b9865d8fa88192adf164" translate="yes" xml:space="preserve">
          <source>The type coercion &lt;code&gt;static(x)&lt;/code&gt; can be used to force the compile-time evaluation of the given expression &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">强制类型 &lt;code&gt;static(x)&lt;/code&gt; 可用于强制执行给定表达式 &lt;code&gt;x&lt;/code&gt; 的编译时评估。</target>
        </trans-unit>
        <trans-unit id="4ed681a392a0c61fb28eee2975db81a956d2924e" translate="yes" xml:space="preserve">
          <source>The type conversion &lt;code&gt;T(a)&lt;/code&gt; is an L-value if &lt;code&gt;a&lt;/code&gt; is an L-value and &lt;code&gt;typeEqualsOrDistinct(T, type(a))&lt;/code&gt; holds.</source>
          <target state="translated">如果 &lt;code&gt;a&lt;/code&gt; 为L值且 &lt;code&gt;typeEqualsOrDistinct(T, type(a))&lt;/code&gt; 成立，则类型转换 &lt;code&gt;T(a)&lt;/code&gt; 为L值。</target>
        </trans-unit>
        <trans-unit id="f7007f414d9f07ec9d9545e70f77c0fb11e2655f" translate="yes" xml:space="preserve">
          <source>The type of a parameter may be prefixed with the &lt;code&gt;var&lt;/code&gt; keyword:</source>
          <target state="translated">参数的类型可以以 &lt;code&gt;var&lt;/code&gt; 关键字为前缀：</target>
        </trans-unit>
        <trans-unit id="b4149e9c761a9c5b1d817b72b94a54f51db12381" translate="yes" xml:space="preserve">
          <source>The type representing a file handle.</source>
          <target state="translated">代表文件句柄的类型。</target>
        </trans-unit>
        <trans-unit id="9b4854aa3e47cfa3fa7a0d71ef4763a784b0d2a7" translate="yes" xml:space="preserve">
          <source>The type suffixes are:</source>
          <target state="translated">类型后缀为:</target>
        </trans-unit>
        <trans-unit id="4006d5cc88fdabea98a514a10633d32480b50418" translate="yes" xml:space="preserve">
          <source>The types &lt;code&gt;var T&lt;/code&gt; and &lt;code&gt;typedesc[T]&lt;/code&gt; cannot be inferred in a generic instantiation. The following is not allowed:</source>
          <target state="translated">不能在通用实例中推断类型 &lt;code&gt;var T&lt;/code&gt; 和 &lt;code&gt;typedesc[T]&lt;/code&gt; 。不允许以下内容：</target>
        </trans-unit>
        <trans-unit id="15965d3cd0f4bb804b8212dddb5431bf9b84d441" translate="yes" xml:space="preserve">
          <source>The typical compiler usage involves using the &lt;code&gt;compile&lt;/code&gt; or &lt;code&gt;c&lt;/code&gt; command to transform a &lt;code&gt;.nim&lt;/code&gt; file into one or more &lt;code&gt;.c&lt;/code&gt; files which are then compiled with the platform's C compiler into a static binary. However there are other commands to compile to C++, Objective-C or Javascript. More details can be read in the &lt;a href=&quot;backends&quot;&gt;Nim Backend Integration document&lt;/a&gt;.</source>
          <target state="translated">典型的编译器用法包括使用 &lt;code&gt;compile&lt;/code&gt; 或 &lt;code&gt;c&lt;/code&gt; 命令将 &lt;code&gt;.nim&lt;/code&gt; 文件转换为一个或多个 &lt;code&gt;.c&lt;/code&gt; 文件，然后使用平台的C编译器将其编译为静态二进制文件。但是，还有其他命令可以编译为C ++，Objective-C或Javascript。更多详细信息，请参阅&lt;a href=&quot;backends&quot;&gt;Nim后端集成文档&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2323beee7c184cc654539984a6ab3af180da6e48" translate="yes" xml:space="preserve">
          <source>The typical usage scenario for this option is to call it after the user has typed the dot character for &lt;a href=&quot;tut2#method-call-syntax&quot;&gt;the object oriented call syntax&lt;/a&gt;. Idetools will try to return the suggestions sorted first by scope (from innermost to outermost) and then by item name.</source>
          <target state="translated">此选项的典型用法是在用户键入&lt;a href=&quot;tut2#method-call-syntax&quot;&gt;面向对象的调用语法&lt;/a&gt;的点字符后调用它。Idetools将尝试返回建议，这些建议首先按范围（从最内到最外）排序，然后按项目名称排序。</target>
        </trans-unit>
        <trans-unit id="b45de376a3cd2738b15e943470c78ad94bed4791" translate="yes" xml:space="preserve">
          <source>The typical usage scenario for this option is to call it after the user has typed the dot character for &lt;a href=&quot;tut2#method-call-syntax&quot;&gt;the object oriented call syntax&lt;/a&gt;. Nimsuggest will try to return the suggestions sorted first by scope (from innermost to outermost) and then by item name.</source>
          <target state="translated">此选项的典型用法是在用户键入&lt;a href=&quot;tut2#method-call-syntax&quot;&gt;面向对象的调用语法&lt;/a&gt;的点字符后调用它。Nimsuggest将尝试返回建议，这些建议首先按范围（从最内到最外）排序，然后按项目名称排序。</target>
        </trans-unit>
        <trans-unit id="c1bb924a06b99256d96c42fb02e7ceffd0f6c417" translate="yes" xml:space="preserve">
          <source>The union of two sets is represented mathematically as &lt;em&gt;A &amp;cup; B&lt;/em&gt; and is the set of all objects that are members of &lt;em&gt;s1&lt;/em&gt;, &lt;em&gt;s2&lt;/em&gt; or both. Example:</source>
          <target state="translated">两组的并集在数学上用&lt;em&gt;A&amp;cup;B&lt;/em&gt;表示，并且是&lt;em&gt;s1&lt;/em&gt;，&lt;em&gt;s2&lt;/em&gt;或这两个成员的所有对象的集合。例：</target>
        </trans-unit>
        <trans-unit id="d8d1d1447b153afdb0a97fd8b87918bc4140f680" translate="yes" xml:space="preserve">
          <source>The unit of the parameters &lt;code&gt;maxPauseInUs&lt;/code&gt; and &lt;code&gt;us&lt;/code&gt; is microseconds.</source>
          <target state="translated">参数 &lt;code&gt;maxPauseInUs&lt;/code&gt; 和 &lt;code&gt;us&lt;/code&gt; 的单位是微秒。</target>
        </trans-unit>
        <trans-unit id="ebb55c959a3f02d3eea1dc9ff808f8bb2abaea44" translate="yes" xml:space="preserve">
          <source>The unsafeAddr operator</source>
          <target state="translated">unsafeAddr运算符</target>
        </trans-unit>
        <trans-unit id="0ef21f06b17eb379f0787340a289e02dd9482513" translate="yes" xml:space="preserve">
          <source>The upload of new files.</source>
          <target state="translated">新文件的上传。</target>
        </trans-unit>
        <trans-unit id="ffb9dbd8c79b78dedb57dfcf3aa60f5d7e195511" translate="yes" xml:space="preserve">
          <source>The usage of &lt;code&gt;concept&lt;/code&gt; (experimental) is similar to objects.</source>
          <target state="translated">&lt;code&gt;concept&lt;/code&gt; （实验性）的用法类似于对象。</target>
        </trans-unit>
        <trans-unit id="9a559c657b3e94a5a3b4f28ede4f3e541e9898aa" translate="yes" xml:space="preserve">
          <source>The user guide lists command line arguments, special features of the compiler, etc.</source>
          <target state="translated">用户指南列出了命令行参数、编译器的特殊功能等。</target>
        </trans-unit>
        <trans-unit id="aec3c4c08d9fd434b6b3b95d1925acd83f75de3e" translate="yes" xml:space="preserve">
          <source>The using statement provides syntactic convenience in modules where the same parameter names and types are used over and over. Instead of:</source>
          <target state="translated">在模块中,如果重复使用相同的参数名称和类型,那么using语句提供了语法上的便利。取而代之的是:</target>
        </trans-unit>
        <trans-unit id="99d6383e434dd62dcbce9c98ef86b8da04045406" translate="yes" xml:space="preserve">
          <source>The values of the returned enum should be pretty self explanatory:</source>
          <target state="translated">返回的枚举值应该是非常自明的。</target>
        </trans-unit>
        <trans-unit id="e580cb29ada1c872bcbdfbf5d59c299cb8b1209f" translate="yes" xml:space="preserve">
          <source>The var statement</source>
          <target state="translated">变量语句</target>
        </trans-unit>
        <trans-unit id="44981de5f0080cccfda5bafeb275d3e5b51b6196" translate="yes" xml:space="preserve">
          <source>The var statement declares a new local or global variable:</source>
          <target state="translated">var语句声明了一个新的局部或全局变量。</target>
        </trans-unit>
        <trans-unit id="a7fb42712b4a095b6edcf947d23562ccc99a3384" translate="yes" xml:space="preserve">
          <source>The variable &lt;code&gt;i&lt;/code&gt; is implicitly declared by the &lt;code&gt;for&lt;/code&gt; loop and has the type &lt;code&gt;int&lt;/code&gt;, because that is what &lt;a href=&quot;system#countup&quot;&gt;countup&lt;/a&gt; returns. &lt;code&gt;i&lt;/code&gt; runs through the values 1, 2, .., 10. Each value is &lt;code&gt;echo&lt;/code&gt;-ed. This code does the same:</source>
          <target state="translated">变量 &lt;code&gt;i&lt;/code&gt; 由 &lt;code&gt;for&lt;/code&gt; 循环隐式声明，并且类型为 &lt;code&gt;int&lt;/code&gt; ，因为那是&lt;a href=&quot;system#countup&quot;&gt;countup&lt;/a&gt;返回的内容。 &lt;code&gt;i&lt;/code&gt; 遍历值1、2，..，10。每个值都 &lt;code&gt;echo&lt;/code&gt; 。此代码执行相同的操作：</target>
        </trans-unit>
        <trans-unit id="bc84debb5dc6452e51fb2c78cf8623fbed79f8ac" translate="yes" xml:space="preserve">
          <source>The variables are compared with &lt;em&gt;cmpIgnoreStyle&lt;/em&gt;. &lt;em&gt;ValueError&lt;/em&gt; is raised if an ill-formed format string has been passed to the &lt;em&gt;%&lt;/em&gt; operator.</source>
          <target state="translated">将变量与&lt;em&gt;cmpIgnoreStyle&lt;/em&gt;进行比较。如果格式错误的格式字符串已传递给&lt;em&gt;％&lt;/em&gt;运算符，则会引发&lt;em&gt;ValueError&lt;/em&gt;。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2fa9f6f05c0209f1598bd49966b81632306fcee5" translate="yes" xml:space="preserve">
          <source>The while statement is a simple looping construct:</source>
          <target state="translated">while语句是一个简单的循环结构。</target>
        </trans-unit>
        <trans-unit id="aba71dc483d2c43f3b09cfa11f1f0b476cc3d1fd" translate="yes" xml:space="preserve">
          <source>The year without any padding. Is always positive, even when the year is BC.</source>
          <target state="translated">没有任何铺垫的年份。是永远的正能量,即使是BC年。</target>
        </trans-unit>
        <trans-unit id="ab38f01dd3bc85831012f0bac4816fc3e75b4486" translate="yes" xml:space="preserve">
          <source>The year without any padding. Will be negative when the year is BC.</source>
          <target state="translated">年,没有任何填充物。当年份为BC时将为负数。</target>
        </trans-unit>
        <trans-unit id="b039a29b58c22bdb2915a3acea080780142c1b28" translate="yes" xml:space="preserve">
          <source>The year, padded to atleast four digits. Is always positive, even when the year is BC. When the year is more than four digits, '+' is prepended.</source>
          <target state="translated">年份,至少要垫到四位数。始终是正数,即使年份是BC。当年份超过四位数时,前面加'+'。</target>
        </trans-unit>
        <trans-unit id="2f78eca394ea113bd4e29e67d3fec4d4e88e2b66" translate="yes" xml:space="preserve">
          <source>The year, padded to atleast four digits. Will be negative when the year is BC. When the year is more than four digits, '+' is prepended unless the year is BC.</source>
          <target state="translated">年份,至少垫到四位数。当年份是BC时,将为负数。当年份超过四位数时,除非年份是BC,否则会在前面加上'+'。</target>
        </trans-unit>
        <trans-unit id="7ff8ad7505b8b464009361f8dda42aba0d8ec846" translate="yes" xml:space="preserve">
          <source>Then calls &lt;a href=&quot;#readAll&quot;&gt;readAll&lt;/a&gt; and closes the file afterwards. Returns the string. Raises an IO exception in case of an error. If you need to call this inside a compile time macro you can use &lt;a href=&quot;#staticRead&quot;&gt;staticRead&lt;/a&gt;.</source>
          <target state="translated">然后调用&lt;a href=&quot;#readAll&quot;&gt;readAll&lt;/a&gt;并随后关闭文件。返回字符串。发生错误时引发IO异常。如果需要在编译时宏中调用此&lt;a href=&quot;#staticRead&quot;&gt;函数，则&lt;/a&gt;可以使用staticRead。</target>
        </trans-unit>
        <trans-unit id="030aaf6f2fc0e5a5cf064da69f557632a5c59e9e" translate="yes" xml:space="preserve">
          <source>Then module &lt;code&gt;A&lt;/code&gt; (that depends on &lt;code&gt;B&lt;/code&gt; and &lt;code&gt;G&lt;/code&gt;) is compiled and &lt;code&gt;B&lt;/code&gt; and &lt;code&gt;G&lt;/code&gt; are left unchanged. &lt;code&gt;A&lt;/code&gt; requires &lt;code&gt;G.P2&lt;/code&gt;.</source>
          <target state="translated">然后，编译模块 &lt;code&gt;A&lt;/code&gt; （取决于 &lt;code&gt;B&lt;/code&gt; 和 &lt;code&gt;G&lt;/code&gt; ），并且 &lt;code&gt;B&lt;/code&gt; 和 &lt;code&gt;G&lt;/code&gt; 保持不变。 &lt;code&gt;A&lt;/code&gt; 需要 &lt;code&gt;G.P2&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0ade512072594e8264ff592564aff0e3bc992458" translate="yes" xml:space="preserve">
          <source>Then module &lt;code&gt;B&lt;/code&gt; is compiled that requires &lt;code&gt;G.P1&lt;/code&gt;. Ok, no problem, &lt;code&gt;G.P1&lt;/code&gt; is loaded from the symbol file and &lt;code&gt;G.c&lt;/code&gt; now contains &lt;code&gt;G.P1&lt;/code&gt;.</source>
          <target state="translated">然后模块 &lt;code&gt;B&lt;/code&gt; 编译需要 &lt;code&gt;G.P1&lt;/code&gt; 。OK，没问题， &lt;code&gt;G.P1&lt;/code&gt; 从符号文件加载和 &lt;code&gt;G.c&lt;/code&gt; 现在包含 &lt;code&gt;G.P1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="43a70a722d347238a21f07b6a20009bf20f06664" translate="yes" xml:space="preserve">
          <source>Then move the C code and the compile script &lt;code&gt;compile_myproject.sh&lt;/code&gt; to your Linux i386 machine and run the script.</source>
          <target state="translated">然后将C代码和编译脚本 &lt;code&gt;compile_myproject.sh&lt;/code&gt; 移至Linux i386计算机并运行该脚本。</target>
        </trans-unit>
        <trans-unit id="23f5d4391872d1d0618203f6cd8356fa03af48c8" translate="yes" xml:space="preserve">
          <source>There are 2 kinds of iterators in Nim: &lt;em&gt;inline&lt;/em&gt; and &lt;em&gt;closure&lt;/em&gt; iterators. An &lt;span id=&quot;inline-iterator_1&quot;&gt;inline iterator&lt;/span&gt; is an iterator that's always inlined by the compiler leading to zero overhead for the abstraction, but may result in a heavy increase in code size. Inline iterators are second class citizens; They can be passed as parameters only to other inlining code facilities like templates, macros and other inline iterators.</source>
          <target state="translated">Nim中有2种迭代器：&lt;em&gt;内联&lt;/em&gt;迭代器和&lt;em&gt;闭包&lt;/em&gt;迭代器。一个&lt;span id=&quot;inline-iterator_1&quot;&gt;内嵌迭代器&lt;/span&gt;是总是由编译器导致零开销抽象内联的迭代器，但可能会导致代码大小一个沉重的增加。内联迭代器是二等公民。它们只能作为参数传递给其他内联代码工具，例如模板，宏和其他内联迭代器。</target>
        </trans-unit>
        <trans-unit id="2204cd4df928fb544bb442ca84cde7bf3009d982" translate="yes" xml:space="preserve">
          <source>There are 3 operations that are bound to a type:</source>
          <target state="translated">有3种操作可以绑定到一个类型。</target>
        </trans-unit>
        <trans-unit id="a85b79c160e40ebe8ffa7f8d4d317c2a9bf28239" translate="yes" xml:space="preserve">
          <source>There are a few things that don't work because the DevkitPro libraries don't support them. They are:</source>
          <target state="translated">由于 DevkitPro 库不支持,有一些东西无法使用。它们是:</target>
        </trans-unit>
        <trans-unit id="0ab99b54c858ac8f9d51bf5e5fe33ce55f9ff7f8" translate="yes" xml:space="preserve">
          <source>There are also raw string literals that are preceded with the letter &lt;code&gt;r&lt;/code&gt; (or &lt;code&gt;R&lt;/code&gt;) and are delimited by matching double quotes (just like ordinary string literals) and do not interpret the escape sequences. This is especially convenient for regular expressions or Windows paths:</source>
          <target state="translated">也有原始字符串文字，其前面带有字母 &lt;code&gt;r&lt;/code&gt; （或 &lt;code&gt;R&lt;/code&gt; ），并由匹配的双引号分隔（就像普通的字符串文字一样），并且不解释转义序列。这对于正则表达式或Windows路径特别方便：</target>
        </trans-unit>
        <trans-unit id="ca885d10f37134acc825e1d0fd4f729e20b0c53b" translate="yes" xml:space="preserve">
          <source>There are currently only two options for verify mode; one is &lt;code&gt;CVerifyNone&lt;/code&gt; and with it certificates will not be verified the other is &lt;code&gt;CVerifyPeer&lt;/code&gt; and certificates will be verified for it, &lt;code&gt;CVerifyPeer&lt;/code&gt; is the safest choice.</source>
          <target state="translated">当前只有两种验证模式选项；一个是 &lt;code&gt;CVerifyNone&lt;/code&gt; ，它将不验证证书，另一个是 &lt;code&gt;CVerifyPeer&lt;/code&gt; ,并且将为此验证证书， &lt;code&gt;CVerifyPeer&lt;/code&gt; 是最安全的选择。</target>
        </trans-unit>
        <trans-unit id="b9bd1745d20224197bc6b19e361674c1fbfbfeef" translate="yes" xml:space="preserve">
          <source>There are multiple ways to get around this, including the use of the &lt;code&gt;&amp;amp;&lt;/code&gt; operator:</source>
          <target state="translated">有多种解决方法，包括使用 &lt;code&gt;&amp;amp;&lt;/code&gt; 运算符：</target>
        </trans-unit>
        <trans-unit id="dfad946c72305fa2959afdaad8dd73249e24fab2" translate="yes" xml:space="preserve">
          <source>There are no constraints for the &lt;code&gt;constructor&lt;/code&gt; AST, it works for nested tuples of arrays of sets etc.</source>
          <target state="translated">&lt;code&gt;constructor&lt;/code&gt; AST 没有任何限制，它适用于集合数组的嵌套元组等。</target>
        </trans-unit>
        <trans-unit id="3e9b3d4d5566426791f36142323c5dcdbd575538" translate="yes" xml:space="preserve">
          <source>There are several node kinds that are used for semantic checking or code generation. These are accessible from this module, but should not be used. Other node kinds are especially designed to make AST manipulations easier. These are explained here.</source>
          <target state="translated">有几种节点类型用于语义检查或代码生成。这些都可以从这个模块中访问,但不应该被使用。其他的节点种类是为了使AST操作更容易而特别设计的。在这里对这些节点进行了解释。</target>
        </trans-unit>
        <trans-unit id="70805ca564aa8b928a6ee8c36e9ffa0c1565c921" translate="yes" xml:space="preserve">
          <source>There are two different sets of metacharacters: those that are recognized anywhere in the pattern except within square brackets, and those that are recognized in square brackets. Outside square brackets, the metacharacters are as follows:</source>
          <target state="translated">有两组不同的元字符:除方括号内的元字符外,图案中任何地方都能识别的元字符,以及方括号内的元字符。方括号外的元字符如下。</target>
        </trans-unit>
        <trans-unit id="9518223ac809befff3867df05b169ff12200b863" translate="yes" xml:space="preserve">
          <source>There are two pseudo directories:</source>
          <target state="translated">有两个伪目录。</target>
        </trans-unit>
        <trans-unit id="b6623c5091377da7e54f379e771f12aab4eb9ebe" translate="yes" xml:space="preserve">
          <source>There are two ways to construct a PEG in Nim code:</source>
          <target state="translated">在Nim代码中,有两种方法可以构建PEG。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
