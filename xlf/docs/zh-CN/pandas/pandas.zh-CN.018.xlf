<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="pandas">
    <body>
      <group id="pandas">
        <trans-unit id="280e0dcd01a74e9f2971dc15e9ea5e4fed9ba1e7" translate="yes" xml:space="preserve">
          <source>GroupBy objects are returned by groupby calls: &lt;a href=&quot;api/pandas.dataframe.groupby#pandas.DataFrame.groupby&quot;&gt;&lt;code&gt;pandas.DataFrame.groupby()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;api/pandas.series.groupby#pandas.Series.groupby&quot;&gt;&lt;code&gt;pandas.Series.groupby()&lt;/code&gt;&lt;/a&gt;, etc.</source>
          <target state="translated">通过groupby调用返回GroupBy对象：&lt;a href=&quot;api/pandas.dataframe.groupby#pandas.DataFrame.groupby&quot;&gt; &lt;code&gt;pandas.DataFrame.groupby()&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;api/pandas.series.groupby#pandas.Series.groupby&quot;&gt; &lt;code&gt;pandas.Series.groupby()&lt;/code&gt; &lt;/a&gt;等。</target>
        </trans-unit>
        <trans-unit id="ef1b77e5d75adde3306a51cdd096ed01e94f4b14" translate="yes" xml:space="preserve">
          <source>GroupBy sorting</source>
          <target state="translated">GroupBy排序</target>
        </trans-unit>
        <trans-unit id="bf46240f856a5682954118b148c3e4fe55d034af" translate="yes" xml:space="preserve">
          <source>GroupBy with MultiIndex</source>
          <target state="translated">GroupBy with MultiIndex</target>
        </trans-unit>
        <trans-unit id="32fdf78ac7e6bd8018e3271aa0c9d041f20f2211" translate="yes" xml:space="preserve">
          <source>Groupby a specific column with the desired frequency. This is like resampling.</source>
          <target state="translated">按所需频率对特定列进行分组。这就像重新取样一样。</target>
        </trans-unit>
        <trans-unit id="50ee04b10dd8ef682ca6c7cdb964b01ff1e4723f" translate="yes" xml:space="preserve">
          <source>Groupby also works with some plotting methods. For example, suppose we suspect that some features in a DataFrame may differ by group, in this case, the values in column 1 where the group is &amp;ldquo;B&amp;rdquo; are 3 higher on average.</source>
          <target state="translated">Groupby还可以使用某些绘图方法。例如，假设我们怀疑DataFrame中的某些功能可能因组而异，在这种情况下，组1为&amp;ldquo; B&amp;rdquo;的第1列中的值平均要高3。</target>
        </trans-unit>
        <trans-unit id="39c96bea6efc5cf3346c84735e823e0034188931" translate="yes" xml:space="preserve">
          <source>Groupby by indexer to &amp;lsquo;resample&amp;rsquo; data</source>
          <target state="translated">按索引器分组以&amp;ldquo;重新采样&amp;rdquo;数据</target>
        </trans-unit>
        <trans-unit id="ab29307976ccacc26ac65efc4e37aa349c72454e" translate="yes" xml:space="preserve">
          <source>Groupby iterator.</source>
          <target state="translated">Groupby迭代器。</target>
        </trans-unit>
        <trans-unit id="7b4bf5d82cf17787b55659f7a273347eac9f8902" translate="yes" xml:space="preserve">
          <source>Groupby key, which selects the grouping column of the target.</source>
          <target state="translated">Groupby键,选择目标的分组列。</target>
        </trans-unit>
        <trans-unit id="918b5ad011a620824893a5734d02f858a6a13add" translate="yes" xml:space="preserve">
          <source>Groupby on a HDFStore with high group density</source>
          <target state="translated">在高分组密度的HDFStore上进行分组比。</target>
        </trans-unit>
        <trans-unit id="ddf0c2abdd85fb648361a521b0d32db681754f91" translate="yes" xml:space="preserve">
          <source>Groupby on a HDFStore with low group density</source>
          <target state="translated">在低组密度的HDFStore上进行组比。</target>
        </trans-unit>
        <trans-unit id="e63f7dc74d42e24a6af9901ab8b42b7aa13d4a1a" translate="yes" xml:space="preserve">
          <source>Groupby one column and return the mean of only particular column in the group.</source>
          <target state="translated">按一列进行分组,并只返回组中特定列的平均值。</target>
        </trans-unit>
        <trans-unit id="1791776b439188ec61725cdf5b05148568043324" translate="yes" xml:space="preserve">
          <source>Groupby one column and return the mean of the remaining columns in each group.</source>
          <target state="translated">按一列进行分组,并返回每组中其余列的平均值。</target>
        </trans-unit>
        <trans-unit id="c23dcbebf567a5f1cbcee4e7dadfd7904a8b5717" translate="yes" xml:space="preserve">
          <source>Groupby operations on the index will preserve the index nature as well.</source>
          <target state="translated">对索引的Groupby操作也会保留索引的性质。</target>
        </trans-unit>
        <trans-unit id="d720fc80687d90ae00e0ff29c33e68654b9f8d9c" translate="yes" xml:space="preserve">
          <source>Groupby two columns and return the mean of the remaining column.</source>
          <target state="translated">按两列进行分组,并返回剩余列的平均值。</target>
        </trans-unit>
        <trans-unit id="b7936f6ac97d94069c7eac9bde37e7210dab8305" translate="yes" xml:space="preserve">
          <source>Groupby will also show &amp;ldquo;unused&amp;rdquo; categories:</source>
          <target state="translated">Groupby还将显示&amp;ldquo;未使用&amp;rdquo;类别：</target>
        </trans-unit>
        <trans-unit id="42c8f672af9a6da3268b6f4a99958d6e735607b1" translate="yes" xml:space="preserve">
          <source>Grouper</source>
          <target state="translated">Grouper</target>
        </trans-unit>
        <trans-unit id="439ef5b4855b51a20d486556cd3d53a3ceee4963" translate="yes" xml:space="preserve">
          <source>Grouper()</source>
          <target state="translated">Grouper()</target>
        </trans-unit>
        <trans-unit id="2ae6967b07a45b63c8543a6c5e34052414ba32af" translate="yes" xml:space="preserve">
          <source>Grouping</source>
          <target state="translated">Grouping</target>
        </trans-unit>
        <trans-unit id="bea5d4da543fa550ad0fc184bd837b179b3659cb" translate="yes" xml:space="preserve">
          <source>Grouping DataFrame with Index levels and columns</source>
          <target state="translated">用索引级别和列对DataFrame进行分组。</target>
        </trans-unit>
        <trans-unit id="3360636443934b7226aa2d127f6a2ac58e7d4669" translate="yes" xml:space="preserve">
          <source>Grouping and summarizing</source>
          <target state="translated">归类和总结</target>
        </trans-unit>
        <trans-unit id="f8f359575ce3ab2a02a810c3b1782873145964fe" translate="yes" xml:space="preserve">
          <source>Grouping and then applying the &lt;a href=&quot;../reference/api/pandas.core.groupby.groupby.sum#pandas.core.groupby.GroupBy.sum&quot;&gt;&lt;code&gt;sum()&lt;/code&gt;&lt;/a&gt; function to the resulting groups.</source>
          <target state="translated">分组，然后将&lt;a href=&quot;../reference/api/pandas.core.groupby.groupby.sum#pandas.core.groupby.GroupBy.sum&quot;&gt; &lt;code&gt;sum()&lt;/code&gt; &lt;/a&gt;函数应用于结果组。</target>
        </trans-unit>
        <trans-unit id="afcadcfef8d4935dc588e61f6702eec50be51112" translate="yes" xml:space="preserve">
          <source>Grouping by a categorical column also shows empty categories.</source>
          <target state="translated">按分类列进行分组,也会显示空类别。</target>
        </trans-unit>
        <trans-unit id="ac86dfd20ea0c35fb856dec7c01ef9c8dbf27fa3" translate="yes" xml:space="preserve">
          <source>Grouping by multiple columns forms a hierarchical index, and again we can apply the &lt;a href=&quot;../reference/api/pandas.core.groupby.groupby.sum#pandas.core.groupby.GroupBy.sum&quot;&gt;&lt;code&gt;sum()&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">按多列分组会形成一个层次结构索引，同样，我们可以应用&lt;a href=&quot;../reference/api/pandas.core.groupby.groupby.sum#pandas.core.groupby.GroupBy.sum&quot;&gt; &lt;code&gt;sum()&lt;/code&gt; &lt;/a&gt;函数。</target>
        </trans-unit>
        <trans-unit id="72a25e97424d28d2b53606830a675cb2c5765592" translate="yes" xml:space="preserve">
          <source>Grouping like Python&amp;rsquo;s itertools.groupby</source>
          <target state="translated">像Python的itertools.groupby一样分组</target>
        </trans-unit>
        <trans-unit id="8c6d5986d1d0890c74650296e8acadfc61d984d3" translate="yes" xml:space="preserve">
          <source>Grouping using a MultiIndex</source>
          <target state="translated">使用多索引进行分组</target>
        </trans-unit>
        <trans-unit id="5125fd5e29c34786d3e8901ae40be86c001faeb2" translate="yes" xml:space="preserve">
          <source>Grouping with a grouper specification</source>
          <target state="translated">用石斑鱼规格进行分组</target>
        </trans-unit>
        <trans-unit id="dbfa32bfae76816eb5fcd1ed109b80e107640b8d" translate="yes" xml:space="preserve">
          <source>Grouping with multiple levels is supported.</source>
          <target state="translated">支持多级分组。</target>
        </trans-unit>
        <trans-unit id="12d0d69e2faac3cba479930cd6f20092c9c0ea1a" translate="yes" xml:space="preserve">
          <source>Grouping with ordered factors</source>
          <target state="translated">有序因素的分组</target>
        </trans-unit>
        <trans-unit id="79300cb379b299ff45fb8750bc24f22896f49f6d" translate="yes" xml:space="preserve">
          <source>Guaranteed return of an indexer even when non-unique.</source>
          <target state="translated">即使在非唯一性的情况下,保证索引器的回报。</target>
        </trans-unit>
        <trans-unit id="7cf184f4c67ad58283ecb19349720b0cae756829" translate="yes" xml:space="preserve">
          <source>H</source>
          <target state="translated">H</target>
        </trans-unit>
        <trans-unit id="7c1d0e621e0ca09058706d36a425fc4578904765" translate="yes" xml:space="preserve">
          <source>HDF5</source>
          <target state="translated">HDF5</target>
        </trans-unit>
        <trans-unit id="4d0784f9d9f96af76bb1f3d1e361bf164aa153e1" translate="yes" xml:space="preserve">
          <source>HDF5 (PyTables)</source>
          <target state="translated">HDF5(PyTables)</target>
        </trans-unit>
        <trans-unit id="92aab64c23220250c4b7eff53be23edf32d43f26" translate="yes" xml:space="preserve">
          <source>HDF5 Format</source>
          <target state="translated">HDF5格式</target>
        </trans-unit>
        <trans-unit id="13e3758fc9538b8efd6e347d1be18dbf1cbc68fd" translate="yes" xml:space="preserve">
          <source>HDF5 reading / writing</source>
          <target state="translated">HDF5读/写</target>
        </trans-unit>
        <trans-unit id="2042ab10d2a6b286f6f10f05830da036077c6714" translate="yes" xml:space="preserve">
          <source>HDF5-based reading / writing</source>
          <target state="translated">基于HDF5的读/写</target>
        </trans-unit>
        <trans-unit id="75fbd819b26ac15432c615f102871f48862eb405" translate="yes" xml:space="preserve">
          <source>HDFStore</source>
          <target state="translated">HDFStore</target>
        </trans-unit>
        <trans-unit id="1e6cc28b0699c70e48d3ba2bd954a3c1d6db4410" translate="yes" xml:space="preserve">
          <source>HDFStore will by default not drop rows that are all missing. This behavior can be changed by setting &lt;code&gt;dropna=True&lt;/code&gt;.</source>
          <target state="translated">HDFStore默认情况下不会删除所有丢失的行。可以通过设置 &lt;code&gt;dropna=True&lt;/code&gt; 来更改此行为。</target>
        </trans-unit>
        <trans-unit id="2315b78c90521194806e6ff15e4519be29290f8e" translate="yes" xml:space="preserve">
          <source>HDFStore.append()</source>
          <target state="translated">HDFStore.append()</target>
        </trans-unit>
        <trans-unit id="3c06f7762f6274d7f755a35a5ece2d1938d4d16f" translate="yes" xml:space="preserve">
          <source>HDFStore.get()</source>
          <target state="translated">HDFStore.get()</target>
        </trans-unit>
        <trans-unit id="cf1d970069f4505ca66af47560075f080d7fdebb" translate="yes" xml:space="preserve">
          <source>HDFStore.groups()</source>
          <target state="translated">HDFStore.groups()</target>
        </trans-unit>
        <trans-unit id="2ac4435c6ecd4445adfd51cc1924d3128de8464c" translate="yes" xml:space="preserve">
          <source>HDFStore.info()</source>
          <target state="translated">HDFStore.info()</target>
        </trans-unit>
        <trans-unit id="a63dab9ef218085a01b08427a9709a9da31fdd26" translate="yes" xml:space="preserve">
          <source>HDFStore.keys()</source>
          <target state="translated">HDFStore.keys()</target>
        </trans-unit>
        <trans-unit id="3adc308c4363c6063de35b9f347d5df2b4b2dd55" translate="yes" xml:space="preserve">
          <source>HDFStore.put()</source>
          <target state="translated">HDFStore.put()</target>
        </trans-unit>
        <trans-unit id="f47662db7950975a5ae22dcd0f80f911933903e7" translate="yes" xml:space="preserve">
          <source>HDFStore.select()</source>
          <target state="translated">HDFStore.select()</target>
        </trans-unit>
        <trans-unit id="1832f491303fd89a2974748d322daf584ae70a42" translate="yes" xml:space="preserve">
          <source>HDFStore.walk()</source>
          <target state="translated">HDFStore.walk()</target>
        </trans-unit>
        <trans-unit id="a7b6ae83f2cc25f8ad0ff53d17f8388b4154d54e" translate="yes" xml:space="preserve">
          <source>HDFStore: PyTables (HDF5)</source>
          <target state="translated">HDFStore.PyTables (HDF5)PyTables (HDF5)</target>
        </trans-unit>
        <trans-unit id="9f738ce8457f291b18ee47e665e96baa84f38fcd" translate="yes" xml:space="preserve">
          <source>HTML</source>
          <target state="translated">HTML</target>
        </trans-unit>
        <trans-unit id="06c9f44f3e2be2f8c75b4052579d6903ad2edb30" translate="yes" xml:space="preserve">
          <source>HTML Table Parsing Gotchas</source>
          <target state="translated">HTML表格解析的疑难杂症</target>
        </trans-unit>
        <trans-unit id="bec8b87bbf1ceb04748df519c09bdd4a4242e7e8" translate="yes" xml:space="preserve">
          <source>HTML parser for read_html (see &lt;a href=&quot;#optional-html&quot;&gt;note&lt;/a&gt;)</source>
          <target state="translated">用于read_html的HTML解析器（请参阅&lt;a href=&quot;#optional-html&quot;&gt;注释&lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="5bd8e02b619f57af85ab307312adff41f7e01a52" translate="yes" xml:space="preserve">
          <source>HTML result.</source>
          <target state="translated">HTML结果。</target>
        </trans-unit>
        <trans-unit id="1d1bf76b1fca3d41efaf27152174bffcbb14206d" translate="yes" xml:space="preserve">
          <source>HTML result. These classes are added within specified</source>
          <target state="translated">HTML结果。这些类是在指定的</target>
        </trans-unit>
        <trans-unit id="11dc542c0ffeed8b41bad901e2044f438e4ab0e5" translate="yes" xml:space="preserve">
          <source>HTML:</source>
          <target state="translated">HTML:</target>
        </trans-unit>
        <trans-unit id="dc1a076811de9231220364407db78fe7dff1efa1" translate="yes" xml:space="preserve">
          <source>Hadley Wickham&amp;rsquo;s &lt;a href=&quot;https://ggplot2.tidyverse.org/&quot;&gt;ggplot2&lt;/a&gt; is a foundational exploratory visualization package for the R language. Based on &lt;a href=&quot;https://www.cs.uic.edu/~wilkinson/TheGrammarOfGraphics/GOG.html&quot;&gt;&amp;ldquo;The Grammar of Graphics&amp;rdquo;&lt;/a&gt; it provides a powerful, declarative and extremely general way to generate bespoke plots of any kind of data. It&amp;rsquo;s really quite incredible. Various implementations to other languages are available, but a faithful implementation for Python users has long been missing. Although still young (as of Jan-2014), the &lt;a href=&quot;https://github.com/yhat/ggpy&quot;&gt;yhat/ggpy&lt;/a&gt; project has been progressing quickly in that direction.</source>
          <target state="translated">Hadley Wickham的&lt;a href=&quot;https://ggplot2.tidyverse.org/&quot;&gt;ggplot2&lt;/a&gt;是R语言的基础探索性可视化软件包。它基于&lt;a href=&quot;https://www.cs.uic.edu/~wilkinson/TheGrammarOfGraphics/GOG.html&quot;&gt;&amp;ldquo;图形语法&amp;rdquo;&lt;/a&gt;，提供了一种强大，声明性且极其通用的方式来生成任何类型数据的定制图。真的非常不可思议。可以使用其他语言的各种实现，但是长期以来缺少针对Python用户的忠实实现。尽管还很年轻（截至2014年1月），但&lt;a href=&quot;https://github.com/yhat/ggpy&quot;&gt;yhat / ggpy&lt;/a&gt;项目已朝着这个方向快速发展。</target>
        </trans-unit>
        <trans-unit id="58e12ddb14f6f822bcd8d3ae4e6bb3cbe96c7a13" translate="yes" xml:space="preserve">
          <source>Handle these ambiguous times by specifying the following.</source>
          <target state="translated">通过规定以下内容来处理这些模糊不清的时间。</target>
        </trans-unit>
        <trans-unit id="7c197bf13850693a62be0f9cbc4ad92a5ec806fd" translate="yes" xml:space="preserve">
          <source>Handler to call if object cannot otherwise be converted to a suitable format for JSON. Should receive a single argument which is the object to convert and return a serialisable object.</source>
          <target state="translated">如果对象不能以其他方式转换为JSON的合适格式时调用的处理程序。应该接收一个参数,即要转换的对象,并返回一个serialisable对象。</target>
        </trans-unit>
        <trans-unit id="1bc3b2505837662fcbdfc517f2a1895b70ef262d" translate="yes" xml:space="preserve">
          <source>Handles the leap year case as well:</source>
          <target state="translated">也处理闰年的情况。</target>
        </trans-unit>
        <trans-unit id="46d71ad7a53d41e7f92c55501ff895dde5287631" translate="yes" xml:space="preserve">
          <source>Handling &amp;ldquo;bad&amp;rdquo; lines</source>
          <target state="translated">处理&amp;ldquo;坏&amp;rdquo;行</target>
        </trans-unit>
        <trans-unit id="90545bb5835723940b207d6d85a9b68c0212d6c8" translate="yes" xml:space="preserve">
          <source>Handling column names</source>
          <target state="translated">处理列名</target>
        </trans-unit>
        <trans-unit id="b705fcddebca8a2e54628df55916f3a124b0fddf" translate="yes" xml:space="preserve">
          <source>Handling indexes</source>
          <target state="translated">处理索引</target>
        </trans-unit>
        <trans-unit id="804fe0806cf830f124c1462f636392df61b369ab" translate="yes" xml:space="preserve">
          <source>Handling of (un)observed Categorical values</source>
          <target state="translated">处理(未)观察到的绝对值。</target>
        </trans-unit>
        <trans-unit id="8ebd411c16de03f824e7e963a0ca15fcfc23c034" translate="yes" xml:space="preserve">
          <source>Has no effect but is accepted for compatibility with numpy.</source>
          <target state="translated">没有任何影响,但为了与numpy兼容,可以接受。</target>
        </trans-unit>
        <trans-unit id="3008b93348839f05f66696fd64d26af09f702629" translate="yes" xml:space="preserve">
          <source>Has the correct &lt;code&gt;env&lt;/code&gt; and &lt;code&gt;template&lt;/code&gt; class attributes set.</source>
          <target state="translated">设置了正确的 &lt;code&gt;env&lt;/code&gt; 和 &lt;code&gt;template&lt;/code&gt; 类属性。</target>
        </trans-unit>
        <trans-unit id="38d2254d4a789d989c2b2664108442e3526a1101" translate="yes" xml:space="preserve">
          <source>Hash table-based unique.</source>
          <target state="translated">基于哈希表的独特。</target>
        </trans-unit>
        <trans-unit id="6425f543a801b25f82203571fd175fdf4730a76a" translate="yes" xml:space="preserve">
          <source>Hash table-based unique. Uniques are returned in order of appearance. This does NOT sort.</source>
          <target state="translated">基于哈希表的唯一性。按外观顺序返回唯一性。不进行排序。</target>
        </trans-unit>
        <trans-unit id="e193cbedf5e701ce24af4ab6f04e23203933d9e8" translate="yes" xml:space="preserve">
          <source>Hash_key for string key to encode.</source>
          <target state="translated">Hash_key 为要编码的字符串密钥。</target>
        </trans-unit>
        <trans-unit id="53e49a69fb315c4f51afc9825055d4858a064cdc" translate="yes" xml:space="preserve">
          <source>Hashing</source>
          <target state="translated">Hashing</target>
        </trans-unit>
        <trans-unit id="7ca230abf27a8d0783dda3e3a009514bc03f3dcc" translate="yes" xml:space="preserve">
          <source>Having a duplicated index will raise for a &lt;code&gt;.reindex()&lt;/code&gt;:</source>
          <target state="translated">索引重复将产生一个 &lt;code&gt;.reindex()&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="880b58b88e88151082e731678ce3c724dafb7219" translate="yes" xml:space="preserve">
          <source>Head and tail</source>
          <target state="translated">头和尾</target>
        </trans-unit>
        <trans-unit id="1bb6d883feee979d1e59b94e521dd11f3e0a12d1" translate="yes" xml:space="preserve">
          <source>Helper function to convert DataFrame and Series to matplotlib.table.</source>
          <target state="translated">转换DataFrame和Series到matplotlib.table的辅助函数。</target>
        </trans-unit>
        <trans-unit id="ef6feb04d2cc1517b1a7d23c7680888c4feb48d2" translate="yes" xml:space="preserve">
          <source>Helps style a DataFrame or Series according to the data with HTML and CSS.</source>
          <target state="translated">通过HTML和CSS帮助根据数据对DataFrame或Series进行样式设计。</target>
        </trans-unit>
        <trans-unit id="158ccd51d8c878205e5636d3f99db16bf05effe5" translate="yes" xml:space="preserve">
          <source>Here &amp;lsquo;c&amp;rsquo; and &amp;lsquo;f&amp;rsquo; are not represented in the data and will not be shown in the output because dropna is True by default. Set dropna=False to preserve categories with no data.</source>
          <target state="translated">这里的&amp;ldquo; c&amp;rdquo;和&amp;ldquo; f&amp;rdquo;未在数据中表示，也不会在输出中显示，因为dropna默认为True。设置dropna = False可保留没有数据的类别。</target>
        </trans-unit>
        <trans-unit id="8619034f5d8a24bc1e04110edf64b5187717db5d" translate="yes" xml:space="preserve">
          <source>Here &lt;a href=&quot;../reference/api/pandas.dataframe.transform#pandas.DataFrame.transform&quot;&gt;&lt;code&gt;transform()&lt;/code&gt;&lt;/a&gt; received a single function; this is equivalent to a &lt;a href=&quot;https://numpy.org/doc/stable/reference/ufuncs.html&quot;&gt;ufunc&lt;/a&gt; application.</source>
          <target state="translated">在这里，&lt;a href=&quot;../reference/api/pandas.dataframe.transform#pandas.DataFrame.transform&quot;&gt; &lt;code&gt;transform()&lt;/code&gt; &lt;/a&gt;接收到一个函数；这等效于&lt;a href=&quot;https://numpy.org/doc/stable/reference/ufuncs.html&quot;&gt;ufunc&lt;/a&gt;应用程序。</target>
        </trans-unit>
        <trans-unit id="eb498dc0133a396e16fbab2a4cc64715ce635afe" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;'type'&lt;/code&gt; is optional, and can be a nested pandas type specification here (but not categorical)</source>
          <target state="translated">这里的 &lt;code&gt;'type'&lt;/code&gt; 是可选的，在这里可以是嵌套的熊猫类型规范（但不是分类的）</target>
        </trans-unit>
        <trans-unit id="1d0d20df741a19de9966e743d9965ede0d8c2325" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;origin&lt;/code&gt; is the default name given to your remote repository on GitHub. You can see the remote repositories:</source>
          <target state="translated">此处 &lt;code&gt;origin&lt;/code&gt; 是为GitHub上的远程存储库提供的默认名称。您可以看到远程存储库：</target>
        </trans-unit>
        <trans-unit id="dd7acc3d2934c47bf767aabcf0a0a1045090fcba" translate="yes" xml:space="preserve">
          <source>Here are a few interesting examples.</source>
          <target state="translated">这里有几个有趣的例子。</target>
        </trans-unit>
        <trans-unit id="57c90bbd4cc0875781c24f250ae82def1a858909" translate="yes" xml:space="preserve">
          <source>Here are just a few of the things that pandas does well:</source>
          <target state="translated">以下是大熊猫做得好的几件事。</target>
        </trans-unit>
        <trans-unit id="a48a53a3eeb7f35d9bd9ef58204ea375b22f3555" translate="yes" xml:space="preserve">
          <source>Here are some examples of datetime strings that can be guessed (All representing December 30th, 2011 at 00:00:00):</source>
          <target state="translated">下面是一些可以猜测的日期时间字符串的例子(全部代表2011年12月30日00:00:00)。</target>
        </trans-unit>
        <trans-unit id="0931022beea83b3afc095873234631b7243eeca4" translate="yes" xml:space="preserve">
          <source>Here are some examples:</source>
          <target state="translated">下面是一些例子。</target>
        </trans-unit>
        <trans-unit id="b4aeaea13540388e074b786658dd6cb588265e66" translate="yes" xml:space="preserve">
          <source>Here is a basic tenet to keep in mind: &lt;strong&gt;data alignment is intrinsic&lt;/strong&gt;. The link between labels and data will not be broken unless done so explicitly by you.</source>
          <target state="translated">这是要牢记的基本原则：&lt;strong&gt;数据对齐是固有的&lt;/strong&gt;。除非您明确地这样做，否则标签和数据之间的链接不会断开。</target>
        </trans-unit>
        <trans-unit id="1ea58d8d9e42af87e8caa9d68ed8a547761d5bb4" translate="yes" xml:space="preserve">
          <source>Here is a more complicated example with multiple join keys. Only the keys appearing in &lt;code&gt;left&lt;/code&gt; and &lt;code&gt;right&lt;/code&gt; are present (the intersection), since &lt;code&gt;how='inner'&lt;/code&gt; by default.</source>
          <target state="translated">这是带有多个联接键的更复杂的示例。只出现在键 &lt;code&gt;left&lt;/code&gt; 和 &lt;code&gt;right&lt;/code&gt; 是本（交叉），因为 &lt;code&gt;how='inner'&lt;/code&gt; 默认情况下。</target>
        </trans-unit>
        <trans-unit id="ab8e8ea95ae7bf0defacc7692b79888576dc32c3" translate="yes" xml:space="preserve">
          <source>Here is a quick reference summary table of common functions. Each also takes an optional &lt;code&gt;level&lt;/code&gt; parameter which applies only if the object has a &lt;a href=&quot;advanced#advanced-hierarchical&quot;&gt;hierarchical index&lt;/a&gt;.</source>
          <target state="translated">这是常见功能的快速参考摘要表。每个对象还带有一个可选的 &lt;code&gt;level&lt;/code&gt; 参数，该参数仅在对象具有&lt;a href=&quot;advanced#advanced-hierarchical&quot;&gt;层次结构索引&lt;/a&gt;时才适用。</target>
        </trans-unit>
        <trans-unit id="0d5643537f0f51a6854fc58eb3352e4428cfc1a6" translate="yes" xml:space="preserve">
          <source>Here is a real-world times-series example</source>
          <target state="translated">下面是一个真实世界的时间序列的例子。</target>
        </trans-unit>
        <trans-unit id="2761aae2553cd60018f3fc88987941d00c347168" translate="yes" xml:space="preserve">
          <source>Here is a recipe for generating a query and using it to create equal sized return chunks.</source>
          <target state="translated">这里有一个生成查询并使用它来创建同等大小的返回块的配方。</target>
        </trans-unit>
        <trans-unit id="24a5d5de06a3beca2e7b0755d842882c6d86b038" translate="yes" xml:space="preserve">
          <source>Here is a sample (using 100 column x 100,000 row &lt;code&gt;DataFrames&lt;/code&gt;):</source>
          <target state="translated">这是一个示例（使用100列x 100,000行 &lt;code&gt;DataFrames&lt;/code&gt; ）：</target>
        </trans-unit>
        <trans-unit id="ea724b816190320574ae29c6484ba706b02e562b" translate="yes" xml:space="preserve">
          <source>Here is a simple example:</source>
          <target state="translated">下面是一个简单的例子。</target>
        </trans-unit>
        <trans-unit id="8cb9fc3a406988ae21b268f402abd1ae6f24810e" translate="yes" xml:space="preserve">
          <source>Here is a typical use-case for using this type of indexing. Imagine that you have a somewhat irregular timedelta-like indexing scheme, but the data is recorded as floats. This could, for example, be millisecond offsets.</source>
          <target state="translated">这里是使用这种类型的索引的一个典型用例。想象一下,你有一个有点不规则的类似于timedelta的索引方案,但数据被记录为浮动。例如,这可能是毫秒级的偏移。</target>
        </trans-unit>
        <trans-unit id="12c821efcdfcf141472c6dc48cb7fc32b0aa88f1" translate="yes" xml:space="preserve">
          <source>Here is a typical usecase. You have comma separated strings in a column and want to expand this.</source>
          <target state="translated">下面是一个典型的使用案例。你在一列中有逗号分隔的字符串,并希望扩展这个字符串。</target>
        </trans-unit>
        <trans-unit id="3f944828834dd16d5151a4915c604fb981122b37" translate="yes" xml:space="preserve">
          <source>Here is an example of a self-contained set of tests that illustrate multiple features that we like to use.</source>
          <target state="translated">下面是一组自带测试的例子,说明了我们喜欢使用的多种功能。</target>
        </trans-unit>
        <trans-unit id="23a618ab8a95adb5ee1b90429b7d557f8f970e97" translate="yes" xml:space="preserve">
          <source>Here is an example of each of these methods. First, the default &lt;code&gt;join='outer'&lt;/code&gt; behavior:</source>
          <target state="translated">这是每种方法的一个示例。首先，默认的 &lt;code&gt;join='outer'&lt;/code&gt; 行为：</target>
        </trans-unit>
        <trans-unit id="f53355fe7427e04619d8bfd8d6d3f63a25299701" translate="yes" xml:space="preserve">
          <source>Here is an example of one way to easily plot group means with standard deviations from the raw data.</source>
          <target state="translated">下面是一个例子,可以很容易地从原始数据中绘制带有标准差的组平均值。</target>
        </trans-unit>
        <trans-unit id="22ebc10164acf0daf0825fdd5c161702fb625bfa" translate="yes" xml:space="preserve">
          <source>Here is another example with duplicate join keys in DataFrames:</source>
          <target state="translated">下面是另一个在DataFrames中使用重复连接键的例子。</target>
        </trans-unit>
        <trans-unit id="f00ebbc96feac952e5b8441f93f7abf964a535a4" translate="yes" xml:space="preserve">
          <source>Here is how to view the top and bottom rows of the frame:</source>
          <target state="translated">下面是如何查看框架的上下两行。</target>
        </trans-unit>
        <trans-unit id="43a546924cfd7fc3d41ac31690e23053da201bb2" translate="yes" xml:space="preserve">
          <source>Here is the default behavior, notice how the x-axis tick labeling is performed:</source>
          <target state="translated">这是默认的行为,请注意X轴的刻度标签是如何执行的。</target>
        </trans-unit>
        <trans-unit id="ba4bad7934460a80f863bfdba98774b48472faf0" translate="yes" xml:space="preserve">
          <source>Here is the same thing with &lt;code&gt;join='inner'&lt;/code&gt;:</source>
          <target state="translated">这与 &lt;code&gt;join='inner'&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="16c36edb11aab952de7238aea1b16530fc5cb8f5" translate="yes" xml:space="preserve">
          <source>Here we can see that, when setting &lt;code&gt;origin&lt;/code&gt; to &lt;code&gt;'epoch'&lt;/code&gt;, the result after &lt;code&gt;'2000-10-02 00:00:00'&lt;/code&gt; are identical depending on the start of time series:</source>
          <target state="translated">在这里我们可以看到，将 &lt;code&gt;origin&lt;/code&gt; 设置为 &lt;code&gt;'epoch'&lt;/code&gt; 时，根据时间序列的开始， &lt;code&gt;'2000-10-02 00:00:00'&lt;/code&gt; 之后的结果是相同的：</target>
        </trans-unit>
        <trans-unit id="39e8b6e3df62487c5013989ae5875e737adce772" translate="yes" xml:space="preserve">
          <source>Here we can see that, when using &lt;code&gt;origin&lt;/code&gt; with its default value (&lt;code&gt;'start_day'&lt;/code&gt;), the result after &lt;code&gt;'2000-10-02 00:00:00'&lt;/code&gt; are not identical depending on the start of time series:</source>
          <target state="translated">在这里我们可以看到，当使用带有默认值（ &lt;code&gt;'start_day'&lt;/code&gt; ）的 &lt;code&gt;origin&lt;/code&gt; 时，根据时间序列的开始， &lt;code&gt;'2000-10-02 00:00:00'&lt;/code&gt; 之后的结果是不同的：</target>
        </trans-unit>
        <trans-unit id="a130bb6d2b269db357d8376f97e1107e7ce04d4c" translate="yes" xml:space="preserve">
          <source>Here we construct a simple time series data set to use for illustrating the indexing functionality:</source>
          <target state="translated">在这里,我们构建了一个简单的时间序列数据集,用于说明索引功能。</target>
        </trans-unit>
        <trans-unit id="fd9b2cf6332d18d9140f68e40ee723e9daac96ff" translate="yes" xml:space="preserve">
          <source>Here we discuss a lot of the essential functionality common to the pandas data structures. Here&amp;rsquo;s how to create some of the objects used in the examples from the previous section:</source>
          <target state="translated">在这里，我们讨论了熊猫数据结构共有的许多基本功能。以下是创建上一部分示例中使用的一些对象的方法：</target>
        </trans-unit>
        <trans-unit id="520aaca96214b09c92db1a304a3c24a849e08087" translate="yes" xml:space="preserve">
          <source>Here we discuss a lot of the essential functionality common to the pandas data structures. To begin, let&amp;rsquo;s create some example objects like we did in the &lt;a href=&quot;10min#min&quot;&gt;10 minutes to pandas&lt;/a&gt; section:</source>
          <target state="translated">在这里，我们讨论了熊猫数据结构共有的许多基本功能。首先，让我们创建一些示例对象，就像在&lt;a href=&quot;10min#min&quot;&gt;10分钟的熊猫学习&lt;/a&gt;部分中所做的那样：</target>
        </trans-unit>
        <trans-unit id="1962f1379801e34e3473e040d888c5d732cbc345" translate="yes" xml:space="preserve">
          <source>Here we multiply a DataFrame with a Series.</source>
          <target state="translated">这里我们用一个系列乘以一个DataFrame。</target>
        </trans-unit>
        <trans-unit id="217a16b260162c6b9ecb75aafaf0420285c29b8e" translate="yes" xml:space="preserve">
          <source>Here we multiply a DataFrame with another DataFrame.</source>
          <target state="translated">这里我们将一个DataFrame与另一个DataFrame相乘。</target>
        </trans-unit>
        <trans-unit id="901b74d6c5c2ab9f7fb4f6269ab16305edfca5b2" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s a boring example of rendering a DataFrame, without any (visible) styles:</source>
          <target state="translated">这是一个呈现DataFrame的无聊示例，没有任何（可见）样式：</target>
        </trans-unit>
        <trans-unit id="ade488284bcb2d315b9857b5a71d06a045b7e2a6" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s an example implementation, which relies on casting the extension array to object dtype. This uses the helper method &lt;code&gt;pandas.api.extensions.take()&lt;/code&gt;.</source>
          <target state="translated">这是一个示例实现，它依赖于将扩展数组强制转换为对象dtype。这使用了辅助方法 &lt;code&gt;pandas.api.extensions.take()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fa4e641ba9561c10a3cc502bc8073154340d3577" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s an example of how the index metadata is structured in pyarrow:</source>
          <target state="translated">这是在pyarrow中如何构造索引元数据的示例：</target>
        </trans-unit>
        <trans-unit id="f572a71811f0f563fe73dd42aa90e9196d2abf9f" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s how you can change the above with the new &lt;code&gt;align='mid'&lt;/code&gt; option:</source>
          <target state="translated">您可以使用新的 &lt;code&gt;align='mid'&lt;/code&gt; 选项更改上述内容：</target>
        </trans-unit>
        <trans-unit id="ab62496d5c665ac1b5f50c1319d13221f4ea9788" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s the function in pure Python:</source>
          <target state="translated">这是纯Python中的函数：</target>
        </trans-unit>
        <trans-unit id="8d56691ee65295aa8cd217efc5f1fb0ec7a019f8" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s the template structure:</source>
          <target state="translated">这是模板结构：</target>
        </trans-unit>
        <trans-unit id="cd5f260a168827626f78de5b53f7fbc115fd0ce9" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;&amp;lt;c0&amp;gt;&lt;/code&gt;/&lt;code&gt;&amp;lt;ci0&amp;gt;&lt;/code&gt; and so forth are dictionaries containing the metadata for each column, &lt;em&gt;including the index columns&lt;/em&gt;. This has JSON form:</source>
          <target state="translated">在这里， &lt;code&gt;&amp;lt;c0&amp;gt;&lt;/code&gt; / &lt;code&gt;&amp;lt;ci0&amp;gt;&lt;/code&gt; 等是包含每个列（&lt;em&gt;包括索引列）&lt;/em&gt;元数据的字典。它具有JSON形式：</target>
        </trans-unit>
        <trans-unit id="ea88593cb4a459ae35a505f3a4797efa4ba41e7d" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;data&lt;/code&gt; can be many different things:</source>
          <target state="translated">在这里， &lt;code&gt;data&lt;/code&gt; 可以有很多不同的东西：</target>
        </trans-unit>
        <trans-unit id="2209d4a279c0f96f254c0f3985cac25e0c79d658" translate="yes" xml:space="preserve">
          <source>Here, the &lt;code&gt;f&lt;/code&gt; label was not contained in the Series and hence appears as &lt;code&gt;NaN&lt;/code&gt; in the result.</source>
          <target state="translated">此处， &lt;code&gt;f&lt;/code&gt; 标签未包含在系列中，因此在结果中显示为 &lt;code&gt;NaN&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="367e96118a43c8abe35b5adc3684f98a88f4d169" translate="yes" xml:space="preserve">
          <source>Here, there are expressions on different lines, making it multiline, but the last line has no variable assigned to the output of</source>
          <target state="translated">这里,在不同的行上有表达式,使得它是多行的,但最后一行没有给输出的</target>
        </trans-unit>
        <trans-unit id="8578a243d227600659d59a488618d0fcbdeafb33" translate="yes" xml:space="preserve">
          <source>Here, there are expressions on different lines, making it multiline, but the last line has no variable assigned to the output of &lt;code&gt;a + 2&lt;/code&gt;.</source>
          <target state="translated">在这里，不同行上有表达式，使其成为多行，但最后一行没有将变量分配给 &lt;code&gt;a + 2&lt;/code&gt; 的输出。</target>
        </trans-unit>
        <trans-unit id="453713ccad6edfbc5405a61e004c0c1430893a5b" translate="yes" xml:space="preserve">
          <source>Hexagonal bin plot</source>
          <target state="translated">六角宾格图</target>
        </trans-unit>
        <trans-unit id="29aaaf58b1b7c87af3da68daa99b0dc678b41d70" translate="yes" xml:space="preserve">
          <source>Hexagonal binning plot using matplotlib, the matplotlib function that is used under the hood.</source>
          <target state="translated">使用matplotlib,即罩下使用的matplotlib函数,绘制六边形分幅图。</target>
        </trans-unit>
        <trans-unit id="e4ea59ac502bd091d6b3044bcc3a7e4faa7076ab" translate="yes" xml:space="preserve">
          <source>Hexbin</source>
          <target state="translated">Hexbin</target>
        </trans-unit>
        <trans-unit id="4b2faf5cd777f9e9a92fe8907b82dcdf0f0474e9" translate="yes" xml:space="preserve">
          <source>Hide any indices from rendering.</source>
          <target state="translated">在渲染过程中隐藏任何指数。</target>
        </trans-unit>
        <trans-unit id="78d0b0e4e9c34ece1c9f3157d86d6d1ecb4d874b" translate="yes" xml:space="preserve">
          <source>Hide columns from rendering.</source>
          <target state="translated">在渲染时隐藏列。</target>
        </trans-unit>
        <trans-unit id="bd353e1c956b727376767cec3296c124209a3bf3" translate="yes" xml:space="preserve">
          <source>Hiding the Index or Columns</source>
          <target state="translated">隐藏索引或列</target>
        </trans-unit>
        <trans-unit id="9bfcf47106d24e26c8f6da4717ec31b0b2fed3e9" translate="yes" xml:space="preserve">
          <source>Hierarchical / Multi-level indexing is very exciting as it opens the door to some quite sophisticated data analysis and manipulation, especially for working with higher dimensional data. In essence, it enables you to store and manipulate data with an arbitrary number of dimensions in lower dimensional data structures like &lt;code&gt;Series&lt;/code&gt; (1d) and &lt;code&gt;DataFrame&lt;/code&gt; (2d).</source>
          <target state="translated">分层/多级索引非常令人兴奋，因为它为一些非常复杂的数据分析和操作（尤其是处理高维数据）打开了一扇门。从本质上讲，它使您可以在 &lt;code&gt;Series&lt;/code&gt; （1d）和 &lt;code&gt;DataFrame&lt;/code&gt; （2d）等低维数据结构中存储和处理任意维数的数据。</target>
        </trans-unit>
        <trans-unit id="26c08f6047ab488a2eab24b98eb1681296096769" translate="yes" xml:space="preserve">
          <source>Hierarchical Data Format (HDF) is self-describing, allowing an application to interpret the structure and contents of a file with no outside information. One HDF file can hold a mix of related objects which can be accessed as a group or as individual objects.</source>
          <target state="translated">层次数据格式(HDF)是自描述的,允许应用程序在没有外部信息的情况下解释文件的结构和内容。一个HDF文件可以容纳多个相关对象,这些对象可以作为一组或单个对象进行访问。</target>
        </trans-unit>
        <trans-unit id="67724216d805a96555340d07e6d2a1f2633c2f46" translate="yes" xml:space="preserve">
          <source>Hierarchical indexing (MultiIndex)</source>
          <target state="translated">层次索引(MultiIndex)</target>
        </trans-unit>
        <trans-unit id="1a9f500d25e9b6e9fe7d2a3db8e7b8f2d7ac56fe" translate="yes" xml:space="preserve">
          <source>Hierarchical keys</source>
          <target state="translated">层次键</target>
        </trans-unit>
        <trans-unit id="3e7fe953892ec885f20573b0003196c021532c0e" translate="yes" xml:space="preserve">
          <source>Hierarchical keys cannot be retrieved as dotted (attribute) access as described above for items stored under the root node.</source>
          <target state="translated">对于存储在根节点下的项目,不能如上所述以点状(属性)访问方式检索层次键。</target>
        </trans-unit>
        <trans-unit id="b0d5447bdfc0df1a34b46d8a2d1ee8d33f0c163c" translate="yes" xml:space="preserve">
          <source>Hierarchical queries on a HDFStore</source>
          <target state="translated">在HDFStore上进行分层查询。</target>
        </trans-unit>
        <trans-unit id="3837ce83f3d8a13c3570b62b1a2b446adaff328e" translate="yes" xml:space="preserve">
          <source>Highlight the maximum by shading the background.</source>
          <target state="translated">通过对背景的遮挡来突出最大。</target>
        </trans-unit>
        <trans-unit id="95eeff0d7f01c83d8e331dfa7e0642eef83365e6" translate="yes" xml:space="preserve">
          <source>Highlight the minimum by shading the background.</source>
          <target state="translated">通过对背景的阴影来突出最小值。</target>
        </trans-unit>
        <trans-unit id="28572094b6f31e2425178183c31a01aadfbfa89f" translate="yes" xml:space="preserve">
          <source>Hint to the hashtable sizer.</source>
          <target state="translated">暗示哈希塔布施。</target>
        </trans-unit>
        <trans-unit id="f16459104f92ab6b38aa265adb4ecbfc3768e303" translate="yes" xml:space="preserve">
          <source>Histogram</source>
          <target state="translated">Histogram</target>
        </trans-unit>
        <trans-unit id="0535ab5fb89daffb4f49da30bceb3bd47fb53e02" translate="yes" xml:space="preserve">
          <source>Histogramming</source>
          <target state="translated">Histogramming</target>
        </trans-unit>
        <trans-unit id="9f573dd516c5fae818d100652937d22c8be8a33c" translate="yes" xml:space="preserve">
          <source>Histograms</source>
          <target state="translated">Histograms</target>
        </trans-unit>
        <trans-unit id="63bf65c682511a4e911a035e53ebaec3bd640815" translate="yes" xml:space="preserve">
          <source>Histograms can be drawn by using the &lt;a href=&quot;../reference/api/pandas.dataframe.plot.hist#pandas.DataFrame.plot.hist&quot;&gt;&lt;code&gt;DataFrame.plot.hist()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../reference/api/pandas.series.plot.hist#pandas.Series.plot.hist&quot;&gt;&lt;code&gt;Series.plot.hist()&lt;/code&gt;&lt;/a&gt; methods.</source>
          <target state="translated">可以通过使用&lt;a href=&quot;../reference/api/pandas.dataframe.plot.hist#pandas.DataFrame.plot.hist&quot;&gt; &lt;code&gt;DataFrame.plot.hist()&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../reference/api/pandas.series.plot.hist#pandas.Series.plot.hist&quot;&gt; &lt;code&gt;Series.plot.hist()&lt;/code&gt; &lt;/a&gt;方法绘制直方图。</target>
        </trans-unit>
        <trans-unit id="27f0f11e6d450b6c48a57c7b24ced4711f75593d" translate="yes" xml:space="preserve">
          <source>Holiday calendars can be used to provide the list of holidays. See the &lt;a href=&quot;#timeseries-holiday&quot;&gt;holiday calendar&lt;/a&gt; section for more information.</source>
          <target state="translated">假期日历可用于提供假期列表。有关更多信息，请参见&lt;a href=&quot;#timeseries-holiday&quot;&gt;假期日历&lt;/a&gt;部分。</target>
        </trans-unit>
        <trans-unit id="515694a72054239ce456c9d00c296205caabf8e9" translate="yes" xml:space="preserve">
          <source>Holidays / holiday calendars</source>
          <target state="translated">假期/节日日历</target>
        </trans-unit>
        <trans-unit id="616d8701b286696dac56ea5e0564f7f0664ba1a3" translate="yes" xml:space="preserve">
          <source>Holidays and calendars provide a simple way to define holiday rules to be used with &lt;code&gt;CustomBusinessDay&lt;/code&gt; or in other analysis that requires a predefined set of holidays. The &lt;code&gt;AbstractHolidayCalendar&lt;/code&gt; class provides all the necessary methods to return a list of holidays and only &lt;code&gt;rules&lt;/code&gt; need to be defined in a specific holiday calendar class. Furthermore, the &lt;code&gt;start_date&lt;/code&gt; and &lt;code&gt;end_date&lt;/code&gt; class attributes determine over what date range holidays are generated. These should be overwritten on the &lt;code&gt;AbstractHolidayCalendar&lt;/code&gt; class to have the range apply to all calendar subclasses. &lt;code&gt;USFederalHolidayCalendar&lt;/code&gt; is the only calendar that exists and primarily serves as an example for developing other calendars.</source>
          <target state="translated">假期和日历提供了一种简单的方法来定义要与 &lt;code&gt;CustomBusinessDay&lt;/code&gt; 一起使用的假期规则，或用于需要预定义假期集的其他分析中。该 &lt;code&gt;AbstractHolidayCalendar&lt;/code&gt; 类提供了所有必要的方法返回假期的列表，只有 &lt;code&gt;rules&lt;/code&gt; 需要在一个特定的假期日历类中定义。此外， &lt;code&gt;start_date&lt;/code&gt; 和 &lt;code&gt;end_date&lt;/code&gt; 类属性确定在哪个日期范围内生成假日。这些应在 &lt;code&gt;AbstractHolidayCalendar&lt;/code&gt; 类上覆盖，以使范围适用于所有日历子类。 &lt;code&gt;USFederalHolidayCalendar&lt;/code&gt; 是唯一存在的日历，主要用作开发其他日历的示例。</target>
        </trans-unit>
        <trans-unit id="ee9d332c80b88cbc5ba41e638f5ce24c1e73743a" translate="yes" xml:space="preserve">
          <source>Horizontal and vertical error bars can be supplied to the &lt;code&gt;xerr&lt;/code&gt; and &lt;code&gt;yerr&lt;/code&gt; keyword arguments to &lt;a href=&quot;../reference/api/pandas.dataframe.plot#pandas.DataFrame.plot&quot;&gt;&lt;code&gt;plot()&lt;/code&gt;&lt;/a&gt;. The error values can be specified using a variety of formats:</source>
          <target state="translated">可以将水平和垂直误差线提供给&lt;a href=&quot;../reference/api/pandas.dataframe.plot#pandas.DataFrame.plot&quot;&gt; &lt;code&gt;plot()&lt;/code&gt; &lt;/a&gt;的 &lt;code&gt;xerr&lt;/code&gt; 和 &lt;code&gt;yerr&lt;/code&gt; 关键字参数。可以使用多种格式来指定错误值：</target>
        </trans-unit>
        <trans-unit id="798d45d4f1a4e0cb111c2c75f0fa48db95a41bbc" translate="yes" xml:space="preserve">
          <source>Horizontal bar plot.</source>
          <target state="translated">水平条形图。</target>
        </trans-unit>
        <trans-unit id="c37cf838b0b980da78f19ac1366359fb80951f62" translate="yes" xml:space="preserve">
          <source>Hour</source>
          <target state="translated">Hour</target>
        </trans-unit>
        <trans-unit id="425c6644ee61c9a230fcbf65d7494b117f494021" translate="yes" xml:space="preserve">
          <source>Hour (12-hour clock) as a decimal number [01,12].</source>
          <target state="translated">小时(12小时钟)为十进制数[01,12]。</target>
        </trans-unit>
        <trans-unit id="fb9eb08a7d5aa5786e2bc10ef029f16e805c8a84" translate="yes" xml:space="preserve">
          <source>Hour (24-hour clock) as a decimal number [00,23].</source>
          <target state="translated">小时(24小时钟)为十进制数[00,23]。</target>
        </trans-unit>
        <trans-unit id="03a69bfc0ec29e28cb09c485868505a4c11f3bca" translate="yes" xml:space="preserve">
          <source>Hour value of the period.</source>
          <target state="translated">期的小时值。</target>
        </trans-unit>
        <trans-unit id="53ac924a77d55d00e79592ebf70cc9ed9ee316d5" translate="yes" xml:space="preserve">
          <source>Hour.apply()</source>
          <target state="translated">Hour.apply()</target>
        </trans-unit>
        <trans-unit id="35bdb37831e82b82f92a864b1de84dce868b6263" translate="yes" xml:space="preserve">
          <source>Hour.apply_index()</source>
          <target state="translated">Hour.apply_index()</target>
        </trans-unit>
        <trans-unit id="1f7e570565de4188139ce1f495f0a4a767e428ee" translate="yes" xml:space="preserve">
          <source>Hour.base</source>
          <target state="translated">Hour.base</target>
        </trans-unit>
        <trans-unit id="8e585e3df04c4eec4de525fdca327fd2ba65e241" translate="yes" xml:space="preserve">
          <source>Hour.copy()</source>
          <target state="translated">Hour.copy()</target>
        </trans-unit>
        <trans-unit id="0b44862c33cc1a129b4117e0a1d4417ca66ca4c7" translate="yes" xml:space="preserve">
          <source>Hour.delta</source>
          <target state="translated">Hour.delta</target>
        </trans-unit>
        <trans-unit id="74c19e92ad107036eb344727623e1624200ae97c" translate="yes" xml:space="preserve">
          <source>Hour.freqstr</source>
          <target state="translated">Hour.freqstr</target>
        </trans-unit>
        <trans-unit id="691d0fbccd1823943092dfae8501b40efd199b1b" translate="yes" xml:space="preserve">
          <source>Hour.isAnchored()</source>
          <target state="translated">Hour.isAnchored()</target>
        </trans-unit>
        <trans-unit id="acea6d808fb787e2e979f0a7998c4c3df4d8fdd5" translate="yes" xml:space="preserve">
          <source>Hour.kwds</source>
          <target state="translated">Hour.kwds</target>
        </trans-unit>
        <trans-unit id="151d0e20cbd270cc7fb43e6f25553f0878a45a70" translate="yes" xml:space="preserve">
          <source>Hour.name</source>
          <target state="translated">Hour.name</target>
        </trans-unit>
        <trans-unit id="58d34fac168d93b38466a203549a3caebb9ae352" translate="yes" xml:space="preserve">
          <source>Hour.nanos</source>
          <target state="translated">Hour.nanos</target>
        </trans-unit>
        <trans-unit id="0105783696e6fdc9e5a7987c9699f50e93cff23e" translate="yes" xml:space="preserve">
          <source>Hour.normalize</source>
          <target state="translated">Hour.normalize</target>
        </trans-unit>
        <trans-unit id="739f2fb0b17377837145e941edbf36e33fdcc828" translate="yes" xml:space="preserve">
          <source>Hour.onOffset()</source>
          <target state="translated">Hour.onOffset()</target>
        </trans-unit>
        <trans-unit id="ef471ab00360fbd9ee97bd21ccfb08b1d39e4f2e" translate="yes" xml:space="preserve">
          <source>Hour.rollback()</source>
          <target state="translated">Hour.rollback()</target>
        </trans-unit>
        <trans-unit id="5f509dd688e4275ebcb58828f5df610b3c98968c" translate="yes" xml:space="preserve">
          <source>Hour.rollforward()</source>
          <target state="translated">Hour.rollforward()</target>
        </trans-unit>
        <trans-unit id="ab0f7f4231f94b918d559de375fb69ef0eca4951" translate="yes" xml:space="preserve">
          <source>Hour.rule_code</source>
          <target state="translated">Hour.rule_code</target>
        </trans-unit>
        <trans-unit id="2a3dfca25bfb019117c3cc536806011800c9abd7" translate="yes" xml:space="preserve">
          <source>Hours: &amp;lsquo;H&amp;rsquo;</source>
          <target state="translated">时间：&amp;ldquo; H&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="9242a5cf1124466c24859cdaf585816d21ba9d1b" translate="yes" xml:space="preserve">
          <source>Hover to highlight.</source>
          <target state="translated">悬停以突出显示。</target>
        </trans-unit>
        <trans-unit id="a49764fca3c1e25986ac974c8d8c40659e3823f6" translate="yes" xml:space="preserve">
          <source>Hover to magnify</source>
          <target state="translated">悬停放大</target>
        </trans-unit>
        <trans-unit id="283b111b642f8a04124a8e358013df41d1234238" translate="yes" xml:space="preserve">
          <source>How to align the bars with the cells.</source>
          <target state="translated">如何将条形图与单元格对齐。</target>
        </trans-unit>
        <trans-unit id="db6e9be9081ca92d77c03fe26dd79592e8be869b" translate="yes" xml:space="preserve">
          <source>How to behave if the table already exists.</source>
          <target state="translated">如果表已经存在,如何处理。</target>
        </trans-unit>
        <trans-unit id="5d737c62270b3a47acff25bef86300e61500eac8" translate="yes" xml:space="preserve">
          <source>How to build the pandas documentation</source>
          <target state="translated">如何建立大熊猫文档</target>
        </trans-unit>
        <trans-unit id="c0e83970905861dcc3c10030c88fffa02a03906c" translate="yes" xml:space="preserve">
          <source>How to find the values that will be replaced.</source>
          <target state="translated">如何找到将被替换的值。</target>
        </trans-unit>
        <trans-unit id="ef1fa5b11035bf1f8ae6577f9a0c105ba2e2b145" translate="yes" xml:space="preserve">
          <source>How to handle NAs before computing percent changes.</source>
          <target state="translated">在计算百分比变化之前,如何处理新农合。</target>
        </trans-unit>
        <trans-unit id="a27a42eb28b5e559a07433ac0d391873cf2dd91a" translate="yes" xml:space="preserve">
          <source>How to handle indexes on other axis (or axes).</source>
          <target state="translated">如何处理其他轴(或轴)上的索引。</target>
        </trans-unit>
        <trans-unit id="02c8e011c1a6a4bdf7e57bb059c9a9c96c0cbcdb" translate="yes" xml:space="preserve">
          <source>How to handle negative values in</source>
          <target state="translated">如何处理负值</target>
        </trans-unit>
        <trans-unit id="f8266c50c74c6156dfafa87c97ec3af24485274c" translate="yes" xml:space="preserve">
          <source>How to handle negative values in &lt;code&gt;indices&lt;/code&gt;.</source>
          <target state="translated">如何处理 &lt;code&gt;indices&lt;/code&gt; 负值。</target>
        </trans-unit>
        <trans-unit id="a517432712fa10fd0ef073277ee02f0df0c11e06" translate="yes" xml:space="preserve">
          <source>How to handle non-NA values for overlapping keys:</source>
          <target state="translated">如何处理重叠键的非NA值。</target>
        </trans-unit>
        <trans-unit id="f43e18e889c91ca8e330be78e88e8778e041728c" translate="yes" xml:space="preserve">
          <source>How to handle the operation of the two objects.</source>
          <target state="translated">如何处理这两个对象的操作。</target>
        </trans-unit>
        <trans-unit id="4216b24f1023ffed1547bba13339a0671760163f" translate="yes" xml:space="preserve">
          <source>How to justify the column labels. If None uses the option from the print configuration (controlled by set_option), &amp;lsquo;right&amp;rsquo; out of the box. Valid values are</source>
          <target state="translated">如何对齐列标签。如果&amp;ldquo;无&amp;rdquo;使用打印配置中的选项（由set_option控制），则开箱即用&amp;ldquo;正确&amp;rdquo;。有效值为</target>
        </trans-unit>
        <trans-unit id="02811e68280934a244076bbee273988252e2decb" translate="yes" xml:space="preserve">
          <source>How to rank NaN values:</source>
          <target state="translated">如何对NaN值进行排名。</target>
        </trans-unit>
        <trans-unit id="c81e5ee5f61ddfa3a78d5f341fad4ecdb5dbf234" translate="yes" xml:space="preserve">
          <source>How to rank the group of records that have the same value (i.e. ties):</source>
          <target state="translated">如何对数值相同的一组记录进行排序(即并列)。</target>
        </trans-unit>
        <trans-unit id="996d750728af9280fc018cea501ee9ee8bf33d71" translate="yes" xml:space="preserve">
          <source>How to represent null values as str. Not allowed with append=True.</source>
          <target state="translated">如何将空值表示为str。不允许使用append=True。</target>
        </trans-unit>
        <trans-unit id="2c6355c14b385846a9957518e259e8b8d6d85c59" translate="yes" xml:space="preserve">
          <source>How to set the index and join</source>
          <target state="translated">如何设置索引和加入</target>
        </trans-unit>
        <trans-unit id="471a170bf31c512c1a494dec35601a8a64ba6702" translate="yes" xml:space="preserve">
          <source>However, &lt;a href=&quot;../reference/api/pandas.series#pandas.Series&quot;&gt;&lt;code&gt;Series&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../reference/api/pandas.dataframe#pandas.DataFrame&quot;&gt;&lt;code&gt;DataFrame&lt;/code&gt;&lt;/a&gt; can directly also support the time component as data itself.</source>
          <target state="translated">但是，&lt;a href=&quot;../reference/api/pandas.series#pandas.Series&quot;&gt; &lt;code&gt;Series&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../reference/api/pandas.dataframe#pandas.DataFrame&quot;&gt; &lt;code&gt;DataFrame&lt;/code&gt; &lt;/a&gt;也可以直接支持将时间分量作为数据本身。</target>
        </trans-unit>
        <trans-unit id="a7c0b091654e5dfa38cb05b8014dccae44bda9da" translate="yes" xml:space="preserve">
          <source>However, for many applications this estimate may not be acceptable because the estimate covariance matrix is not guaranteed to be positive semi-definite. This could lead to estimate correlations having absolute values which are greater than one, and/or a non-invertible covariance matrix. See &lt;a href=&quot;http://en.wikipedia.org/w/index.php?title=Estimation_of_covariance_matrices&quot;&gt;Estimation of covariance matrices&lt;/a&gt; for more details.</source>
          <target state="translated">但是，对于许多应用，此估计可能不可接受，因为不能保证估计协方差矩阵是正半定的。这可能导致估计相关性具有绝对值大于1的绝对值和/或不可逆协方差矩阵。有关更多详细信息，请参见&lt;a href=&quot;http://en.wikipedia.org/w/index.php?title=Estimation_of_covariance_matrices&quot;&gt;协方差矩阵的估计&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4f30dd2978cd54ab19f166292391c83028de9bc4" translate="yes" xml:space="preserve">
          <source>However, for many applications this estimate may not be acceptable because the estimate covariance matrix is not guaranteed to be positive semi-definite. This could lead to estimate correlations having absolute values which are greater than one, and/or a non-invertible covariance matrix. See &lt;a href=&quot;https://en.wikipedia.org/w/index.php?title=Estimation_of_covariance_matrices&quot;&gt;Estimation of covariance matrices&lt;/a&gt; for more details.</source>
          <target state="translated">但是，对于许多应用，此估计可能不可接受，因为不能保证估计协方差矩阵是正半定的。这可能导致估计相关性具有绝对值大于1的绝对值和/或不可逆协方差矩阵。有关更多详细信息，请参见&lt;a href=&quot;https://en.wikipedia.org/w/index.php?title=Estimation_of_covariance_matrices&quot;&gt;协方差矩阵的估计&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="cea8c38f3625a97d53eaf6bdfdf954504f10d29b" translate="yes" xml:space="preserve">
          <source>However, if at least one of the two is absent &lt;em&gt;and&lt;/em&gt; the index is not sorted, an error will be raised (since doing otherwise would be computationally expensive, as well as potentially ambiguous for mixed type indexes). For instance, in the above example, &lt;code&gt;s.loc[1:6]&lt;/code&gt; would raise &lt;code&gt;KeyError&lt;/code&gt;.</source>
          <target state="translated">但是，如果两者中至少有一个不存在&lt;em&gt;并且未&lt;/em&gt;对索引进行排序，则会引发错误（因为这样做会导致计算量大，并且可能对混合类型索引造成歧义）。例如，在上面的示例中， &lt;code&gt;s.loc[1:6]&lt;/code&gt; 将引发 &lt;code&gt;KeyError&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="97abfa2058c4b2b46bd77047bcea7c55ad0f19cb" translate="yes" xml:space="preserve">
          <source>However, if the same element in both dataframes is None, that None is preserved</source>
          <target state="translated">但是,如果两个数据帧中的相同元素都是None,那么这个None就会被保留下来。</target>
        </trans-unit>
        <trans-unit id="3a03dd4a4919d77e193bdd2d0336e4f5f7cdca3c" translate="yes" xml:space="preserve">
          <source>However, if the string is treated as an exact match, the selection in &lt;code&gt;DataFrame&lt;/code&gt;&amp;rsquo;s &lt;code&gt;[]&lt;/code&gt; will be column-wise and not row-wise, see &lt;a href=&quot;indexing#indexing-basics&quot;&gt;Indexing Basics&lt;/a&gt;. For example &lt;code&gt;dft_minute['2011-12-31 23:59']&lt;/code&gt; will raise &lt;code&gt;KeyError&lt;/code&gt; as &lt;code&gt;'2012-12-31 23:59'&lt;/code&gt; has the same resolution as the index and there is no column with such name:</source>
          <target state="translated">但是，如果将字符串视为完全匹配，则 &lt;code&gt;DataFrame&lt;/code&gt; 的 &lt;code&gt;[]&lt;/code&gt; 中的选择将是按列而不是按行，请参阅&lt;a href=&quot;indexing#indexing-basics&quot;&gt;Indexing Basics&lt;/a&gt;。例如， &lt;code&gt;dft_minute['2011-12-31 23:59']&lt;/code&gt; 将引发 &lt;code&gt;KeyError&lt;/code&gt; ,因为 &lt;code&gt;'2012-12-31 23:59'&lt;/code&gt; 具有与索引相同的分辨率，并且没有这样的名称的列：</target>
        </trans-unit>
        <trans-unit id="fa5d15a357f215082d304b7f83dbf3174f57094b" translate="yes" xml:space="preserve">
          <source>However, if you have bs4 and html5lib installed and pass &lt;code&gt;None&lt;/code&gt; or &lt;code&gt;['lxml',
'bs4']&lt;/code&gt; then the parse will most likely succeed. Note that &lt;em&gt;as soon as a parse succeeds, the function will return&lt;/em&gt;.</source>
          <target state="translated">但是，如果您安装了bs4和html5lib并传递 &lt;code&gt;None&lt;/code&gt; 或 &lt;code&gt;['lxml', 'bs4']&lt;/code&gt; 则解析很可能会成功。请注意，&lt;em&gt;解析成功后，函数将返回&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="4ba5f87176c631128dde92954aea07df8626e674" translate="yes" xml:space="preserve">
          <source>However, if you only had &lt;code&gt;c&lt;/code&gt; and &lt;code&gt;e&lt;/code&gt;, determining the next element in the index can be somewhat complicated. For example, the following does not work:</source>
          <target state="translated">但是，如果只有 &lt;code&gt;c&lt;/code&gt; 和 &lt;code&gt;e&lt;/code&gt; ，则确定索引中的下一个元素可能会有些复杂。例如对于以下不起作用：</target>
        </trans-unit>
        <trans-unit id="f99ae8e704303cfb147ca20954e7c5d706c860d9" translate="yes" xml:space="preserve">
          <source>However, if you want an actual NumPy &lt;code&gt;datetime64[ns]&lt;/code&gt; array (with the values converted to UTC) instead of an array of objects, you can specify the &lt;code&gt;dtype&lt;/code&gt; argument:</source>
          <target state="translated">但是，如果要使用实际的NumPy &lt;code&gt;datetime64[ns]&lt;/code&gt; 数组（将值转换为UTC）而不是对象数组，则可以指定 &lt;code&gt;dtype&lt;/code&gt; 参数：</target>
        </trans-unit>
        <trans-unit id="e8586709902eda78307d43fe1d0d6e66bde6ac09" translate="yes" xml:space="preserve">
          <source>However, in many cases it is more natural to associate things like change variables with a time span instead. The span represented by &lt;code&gt;Period&lt;/code&gt; can be specified explicitly, or inferred from datetime string format.</source>
          <target state="translated">但是，在许多情况下，将诸如更改变量之类的内容与时间跨度关联起来更为自然。可以由 &lt;code&gt;Period&lt;/code&gt; 表示的范围明确指定，或从日期时间字符串格式推断。</target>
        </trans-unit>
        <trans-unit id="742d8f13359fd0f11624a3ccb6310e89fb9120cd" translate="yes" xml:space="preserve">
          <source>However, instantiating StringArrays directly with non-strings will raise an error.</source>
          <target state="translated">然而,直接用非字符串实例化StringArrays会引发一个错误。</target>
        </trans-unit>
        <trans-unit id="d16b5b78eb22ffbe381a9afe057b0f7ef78e76bb" translate="yes" xml:space="preserve">
          <source>However, it comes with it a couple of trade-offs which I most certainly have not ignored.</source>
          <target state="translated">不过,它也有几个取舍,我肯定没有忽略。</target>
        </trans-unit>
        <trans-unit id="9268bff9bf083e3d79e17753e03c59437d23b40c" translate="yes" xml:space="preserve">
          <source>However, setting this option incorrectly for your terminal will cause these characters to be aligned incorrectly:</source>
          <target state="translated">但是,如果你的终端不正确地设置这个选项,将导致这些字符不正确地排列。</target>
        </trans-unit>
        <trans-unit id="81f0e71582f79bc80ae9961177bfc8e3b8868102" translate="yes" xml:space="preserve">
          <source>However, their presence is indicated in the</source>
          <target state="translated">然而,它们的存在在《公约》中得到了体现。</target>
        </trans-unit>
        <trans-unit id="069df0e9a71bb80b7b5eae23852a6a27ea3af22b" translate="yes" xml:space="preserve">
          <source>However, these can be filled in using &lt;a href=&quot;../reference/api/pandas.dataframe.fillna#pandas.DataFrame.fillna&quot;&gt;&lt;code&gt;fillna()&lt;/code&gt;&lt;/a&gt; and it will work fine:</source>
          <target state="translated">但是，可以使用&lt;a href=&quot;../reference/api/pandas.dataframe.fillna#pandas.DataFrame.fillna&quot;&gt; &lt;code&gt;fillna()&lt;/code&gt; &lt;/a&gt;填写这些内容，并且可以正常工作：</target>
        </trans-unit>
        <trans-unit id="c113642dd4aea7e48ebcf42a5463be4a78e7eb62" translate="yes" xml:space="preserve">
          <source>However, this would &lt;em&gt;still&lt;/em&gt; raise if your resulting index is duplicated.</source>
          <target state="translated">但是，如果您生成的索引重复，这&lt;em&gt;仍然会&lt;/em&gt;增加。</target>
        </trans-unit>
        <trans-unit id="3c40de3c7cecbc0d644bc9d73ad07fe90fe31ba6" translate="yes" xml:space="preserve">
          <source>However, using &lt;code&gt;to_string&lt;/code&gt; will return a string representation of the DataFrame in tabular form, though it won&amp;rsquo;t always fit the console width:</source>
          <target state="translated">但是，使用 &lt;code&gt;to_string&lt;/code&gt; 会以表格形式返回DataFrame的字符串表示形式，尽管它并不总是适合控制台宽度：</target>
        </trans-unit>
        <trans-unit id="ba7929059d6edf0d7eddc551cc797b90990c10c2" translate="yes" xml:space="preserve">
          <source>However, when an axis is integer based, ONLY label based access and not positional access is supported. Thus, in such cases, it&amp;rsquo;s usually better to be explicit and use &lt;code&gt;.iloc&lt;/code&gt; or &lt;code&gt;.loc&lt;/code&gt;.</source>
          <target state="translated">但是，当轴基于整数时，仅支持基于标签的访问，而不支持基于位置的访问。因此，在这种情况下，通常最好是显式并使用 &lt;code&gt;.iloc&lt;/code&gt; 或 &lt;code&gt;.loc&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bffc9ca5ad36fbad3b3a0f25c38eeb95a3771bef" translate="yes" xml:space="preserve">
          <source>However, you can do (notice the comment that needs to be added)</source>
          <target state="translated">不过,你可以这样做(注意需要添加的注释)。</target>
        </trans-unit>
        <trans-unit id="f8ac6f61c1aa59daf66de62601615682e1049435" translate="yes" xml:space="preserve">
          <source>Hypothesis is a library for property-based testing. Instead of explicitly parametrizing a test, you can describe &lt;em&gt;all&lt;/em&gt; valid inputs and let Hypothesis try to find a failing input. Even better, no matter how many random examples it tries, Hypothesis always reports a single minimal counterexample to your assertions - often an example that you would never have thought to test.</source>
          <target state="translated">假设是用于基于属性的测试的库。您可以描述&lt;em&gt;所有&lt;/em&gt;有效输入，然后让假设假设尝试查找失败的输入，而不是对测试进行显式参数化。更好的是，无论尝试多少随机示例，假设总是报告您的断言的单个最小反例-通常是您从未想过要测试的示例。</target>
        </trans-unit>
        <trans-unit id="6b4059c9b5820041f826f688b6e57c7201e42d5f" translate="yes" xml:space="preserve">
          <source>IDE</source>
          <target state="translated">IDE</target>
        </trans-unit>
        <trans-unit id="f8fd4493c0520c4dc8242f0098e35eb107cc179d" translate="yes" xml:space="preserve">
          <source>IEX</source>
          <target state="translated">IEX</target>
        </trans-unit>
        <trans-unit id="ca6691485e94f29b172edd1428309ac2c47100cc" translate="yes" xml:space="preserve">
          <source>IO tools</source>
          <target state="translated">IO工具</target>
        </trans-unit>
        <trans-unit id="a462e1e327253efa119d5a0e2286d8d8d84ef77d" translate="yes" xml:space="preserve">
          <source>IO tools (text, CSV, HDF5, &amp;hellip;)</source>
          <target state="translated">IO工具（文本，CSV，HDF5等）</target>
        </trans-unit>
        <trans-unit id="571ae8f12e56e6a82f24791cda171d0b8fd05d68" translate="yes" xml:space="preserve">
          <source>IPython</source>
          <target state="translated">IPython</target>
        </trans-unit>
        <trans-unit id="e81acf4cb4ac2f9dfa0516461c3ce5a6c992dff8" translate="yes" xml:space="preserve">
          <source>IPython Vega</source>
          <target state="translated">IPython Vega</target>
        </trans-unit>
        <trans-unit id="991bf056dd16995f47856efd54d6471c32029dfb" translate="yes" xml:space="preserve">
          <source>IPython is an interactive command shell and distributed computing environment. IPython tab completion works with Pandas methods and also attributes like DataFrame columns.</source>
          <target state="translated">IPython是一个交互式命令壳和分布式计算环境。IPython标签完成与Pandas方法以及DataFrame列等属性一起工作。</target>
        </trans-unit>
        <trans-unit id="7ce0c669ac9952944e64534615185377818bf4dd" translate="yes" xml:space="preserve">
          <source>IX indexer is deprecated</source>
          <target state="translated">IX 索引器已被废弃</target>
        </trans-unit>
        <trans-unit id="837958207e911e1a986e234409c61e629d2c52b7" translate="yes" xml:space="preserve">
          <source>Ideally, the attributes in &lt;code&gt;_metadata&lt;/code&gt; will match the parameters to your &lt;code&gt;ExtensionDtype.__init__&lt;/code&gt; (if any). If any of the attributes in &lt;code&gt;_metadata&lt;/code&gt; don&amp;rsquo;t implement the standard &lt;code&gt;__eq__&lt;/code&gt; or &lt;code&gt;__hash__&lt;/code&gt;, the default implementations here will not work.</source>
          <target state="translated">理想情况下， &lt;code&gt;_metadata&lt;/code&gt; 中的属性将参数与您的 &lt;code&gt;ExtensionDtype.__init__&lt;/code&gt; （如果有）匹配。如果 &lt;code&gt;_metadata&lt;/code&gt; 中的任何属性未实现标准的 &lt;code&gt;__eq__&lt;/code&gt; 或 &lt;code&gt;__hash__&lt;/code&gt; ，则此处的默认实现将不起作用。</target>
        </trans-unit>
        <trans-unit id="ca9b496aede42137d37ed26eee610c0663585a70" translate="yes" xml:space="preserve">
          <source>Identical method.</source>
          <target state="translated">同样的方法。</target>
        </trans-unit>
        <trans-unit id="ed000ba923e4837b5f64d072ac83b369b8bbc564" translate="yes" xml:space="preserve">
          <source>Identifier for the group in the store.</source>
          <target state="translated">店内群组的标识符。</target>
        </trans-unit>
        <trans-unit id="cc70bdac5409cb9636fe71b4171d38f1636e5344" translate="yes" xml:space="preserve">
          <source>Identifier of column that should be used as index of the DataFrame.</source>
          <target state="translated">作为DataFrame索引的列的标识符。</target>
        </trans-unit>
        <trans-unit id="d1693517b90bc1546304cd1fb892ae941d720a6b" translate="yes" xml:space="preserve">
          <source>Identifies data (i.e. provides &lt;em&gt;metadata&lt;/em&gt;) using known indicators, important for analysis, visualization, and interactive console display.</source>
          <target state="translated">使用已知的指标标识数据（即提供&lt;em&gt;元数据&lt;/em&gt;），这对于分析，可视化和交互式控制台显示很重要。</target>
        </trans-unit>
        <trans-unit id="7b2b315db6cb8b61d91ac6d610561c15d151098e" translate="yes" xml:space="preserve">
          <source>Identity method.</source>
          <target state="translated">身份法。</target>
        </trans-unit>
        <trans-unit id="ec04bd386a626dbd6df1f3954dfd578f058ce091" translate="yes" xml:space="preserve">
          <source>Idioms</source>
          <target state="translated">Idioms</target>
        </trans-unit>
        <trans-unit id="751c68a3471b1c791efaee0a8e7c24ea0c266efd" translate="yes" xml:space="preserve">
          <source>If</source>
          <target state="translated">If</target>
        </trans-unit>
        <trans-unit id="f6003bd8eabce8b7ff3690312b777fcfeb97f5b7" translate="yes" xml:space="preserve">
          <source>If #1 fails, &lt;code&gt;date_parser&lt;/code&gt; is called with all the columns concatenated row-wise into a single array (e.g., &lt;code&gt;date_parser(['2013 1', '2013 2'])&lt;/code&gt;).</source>
          <target state="translated">如果＃1失败，则将 &lt;code&gt;date_parser&lt;/code&gt; 调用，并将所有列按行连接到单个数组中（例如 &lt;code&gt;date_parser(['2013 1', '2013 2'])&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="e8cae4bf30e27a1848901c64267dcac0e2ff75cd" translate="yes" xml:space="preserve">
          <source>If &amp;lsquo;coerce&amp;rsquo;, then invalid parsing will be set as NaN</source>
          <target state="translated">如果为&amp;ldquo;强制&amp;rdquo;，则将无效解析设置为NaN</target>
        </trans-unit>
        <trans-unit id="16bba9351b97f05aabf6f317cfe45f93cda01afb" translate="yes" xml:space="preserve">
          <source>If &amp;lsquo;coerce&amp;rsquo;, then invalid parsing will be set as NaN.</source>
          <target state="translated">如果为&amp;ldquo;强制&amp;rdquo;，则将无效解析设置为NaN。</target>
        </trans-unit>
        <trans-unit id="6702a592aaa4545f91194718e2267ecc33a26886" translate="yes" xml:space="preserve">
          <source>If &amp;lsquo;coerce&amp;rsquo;, then invalid parsing will be set as NaT</source>
          <target state="translated">如果为&amp;ldquo;强制&amp;rdquo;，则将无效解析设置为NaT</target>
        </trans-unit>
        <trans-unit id="e327c3620244d73e8137e7777edd3944c79b840d" translate="yes" xml:space="preserve">
          <source>If &amp;lsquo;coerce&amp;rsquo;, then invalid parsing will be set as NaT.</source>
          <target state="translated">如果为&amp;ldquo;强制&amp;rdquo;，则将无效解析设置为NaT。</target>
        </trans-unit>
        <trans-unit id="a8cc6e9c326cf3572f065a17f177306c8775d049" translate="yes" xml:space="preserve">
          <source>If &amp;lsquo;first&amp;rsquo; puts NaNs at the beginning, &amp;lsquo;last&amp;rsquo; puts NaNs at the end. Not implemented for MultiIndex.</source>
          <target state="translated">如果&amp;ldquo;第一个&amp;rdquo;将NaN放在开头，则&amp;ldquo;最后一个&amp;rdquo;将NaN放在结尾。未针对MultiIndex实施。</target>
        </trans-unit>
        <trans-unit id="85a05c0ef3ed46dcadbc8af33ffe40bbea47052f" translate="yes" xml:space="preserve">
          <source>If &amp;lsquo;ignore&amp;rsquo;, propagate NA values, without passing them to the mapping correspondence.</source>
          <target state="translated">如果&amp;ldquo;忽略&amp;rdquo;，则传播NA值，而不将其传递给映射对应关系。</target>
        </trans-unit>
        <trans-unit id="1287f6267e3f7063b36811426aebcc8a1b393699" translate="yes" xml:space="preserve">
          <source>If &amp;lsquo;ignore&amp;rsquo;, propagate NaN values, without passing them to func.</source>
          <target state="translated">如果&amp;ldquo;忽略&amp;rdquo;，则传播NaN值，而不将其传递给func。</target>
        </trans-unit>
        <trans-unit id="66b7f9b117c829902f069c8250ee1dcbed71f06f" translate="yes" xml:space="preserve">
          <source>If &amp;lsquo;ignore&amp;rsquo;, propagate NaN values, without passing them to the mapping correspondence.</source>
          <target state="translated">如果&amp;ldquo;忽略&amp;rdquo;，则传播NaN值，而不将其传递给映射对应关系。</target>
        </trans-unit>
        <trans-unit id="22afdde341e33ad8a79ea55dc5be1cbcc7e96d01" translate="yes" xml:space="preserve">
          <source>If &amp;lsquo;ignore&amp;rsquo;, suppress error and existing labels are dropped.</source>
          <target state="translated">如果&amp;ldquo;忽略&amp;rdquo;，则抑制错误并删除现有标签。</target>
        </trans-unit>
        <trans-unit id="d430013a0236928d816f5189528441973b498e09" translate="yes" xml:space="preserve">
          <source>If &amp;lsquo;ignore&amp;rsquo;, suppress error and only existing labels are dropped.</source>
          <target state="translated">如果&amp;ldquo;忽略&amp;rdquo;，则抑制错误，仅删除现有标签。</target>
        </trans-unit>
        <trans-unit id="55ef49bb1d9190e26977a4e97151c2887af3928e" translate="yes" xml:space="preserve">
          <source>If &amp;lsquo;ignore&amp;rsquo;, then invalid parsing will return the input</source>
          <target state="translated">如果为&amp;ldquo; ignore&amp;rdquo;，则无效的解析将返回输入</target>
        </trans-unit>
        <trans-unit id="cd3b02bde7d23065b5493af3d78edab92d8661c6" translate="yes" xml:space="preserve">
          <source>If &amp;lsquo;ignore&amp;rsquo;, then invalid parsing will return the input.</source>
          <target state="translated">如果为&amp;ldquo; ignore&amp;rdquo;，则无效的解析将返回输入。</target>
        </trans-unit>
        <trans-unit id="1dc7b9597b7436e84a9fd5cd7c267d98ceeb4c95" translate="yes" xml:space="preserve">
          <source>If &amp;lsquo;infer&amp;rsquo; and &amp;lsquo;path_or_url&amp;rsquo; is path-like, then detect compression from the following extensions: &amp;lsquo;.gz&amp;rsquo;, &amp;lsquo;.bz2&amp;rsquo;, &amp;lsquo;.zip&amp;rsquo;, or &amp;lsquo;.xz&amp;rsquo; (otherwise no compression) If &amp;lsquo;infer&amp;rsquo; and &amp;lsquo;path_or_url&amp;rsquo; is not path-like, then use None (= no decompression).</source>
          <target state="translated">如果'infer'和'path_or_url'类似于路径，则从以下扩展名检测压缩：'.gz'，'。bz2'，'。zip'或'.xz'（否则不压缩）如果'infer'并且&amp;ldquo; path_or_url&amp;rdquo;不是类路径，请使用&amp;ldquo;无&amp;rdquo;（=不进行解压缩）。</target>
        </trans-unit>
        <trans-unit id="ff34e86f499a6da13800cd52b6acf8d0206bc8b4" translate="yes" xml:space="preserve">
          <source>If &amp;lsquo;julian&amp;rsquo;, unit must be &amp;lsquo;D&amp;rsquo;, and origin is set to beginning of Julian Calendar. Julian day number 0 is assigned to the day starting at noon on January 1, 4713 BC.</source>
          <target state="translated">如果为'julian'，则单位必须为'D'，并且原点设置为Julian Calendar的开头。朱利安天数0被指定为从4713年1月1日中午开始的那一天。</target>
        </trans-unit>
        <trans-unit id="b2092bae9f0ce3fc3810aa44034eb94fcaaf590d" translate="yes" xml:space="preserve">
          <source>If &amp;lsquo;label&amp;rsquo; does not exist in DataFrame.</source>
          <target state="translated">如果DataFrame中不存在&amp;ldquo;标签&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="b20de98cc6d0b1c8d0f7085d3b7e17aedbf78e9b" translate="yes" xml:space="preserve">
          <source>If &amp;lsquo;left&amp;rsquo;, the index of the first suitable location found is given. If &amp;lsquo;right&amp;rsquo;, return the last such index. If there is no suitable index, return either 0 or N (where N is the length of</source>
          <target state="translated">如果为&amp;ldquo; left&amp;rdquo;，则给出找到的第一个合适位置的索引。如果为&amp;ldquo;正确&amp;rdquo;，则返回最后一个这样的索引。如果没有合适的索引，则返回0或N（其中N是</target>
        </trans-unit>
        <trans-unit id="3b55e654d50b8ad774057f6ba47ce5789398ba97" translate="yes" xml:space="preserve">
          <source>If &amp;lsquo;left&amp;rsquo;, the index of the first suitable location found is given. If &amp;lsquo;right&amp;rsquo;, return the last such index. If there is no suitable index, return either 0 or N (where N is the length of &lt;code&gt;self&lt;/code&gt;).</source>
          <target state="translated">如果为&amp;ldquo; left&amp;rdquo;，则给出找到的第一个合适位置的索引。如果为&amp;ldquo;正确&amp;rdquo;，则返回最后一个这样的索引。如果没有合适的索引，则返回0或N（其中N是 &lt;code&gt;self&lt;/code&gt; 的长度）。</target>
        </trans-unit>
        <trans-unit id="14c9113bf406806dfc7fa4d776177c7889c78c60" translate="yes" xml:space="preserve">
          <source>If &amp;lsquo;limit&amp;rsquo; is not specified:</source>
          <target state="translated">如果未指定&amp;ldquo;限制&amp;rdquo;：</target>
        </trans-unit>
        <trans-unit id="2cc24626be3d05b2f4b9cd06416847f88949fd27" translate="yes" xml:space="preserve">
          <source>If &amp;lsquo;method&amp;rsquo; is &amp;lsquo;backfill&amp;rsquo; or &amp;lsquo;bfill&amp;rsquo;, &amp;lsquo;limit_direction&amp;rsquo; must be &amp;lsquo;backwards&amp;rsquo;.</source>
          <target state="translated">如果&amp;ldquo;方法&amp;rdquo;为&amp;ldquo;回填&amp;rdquo;或&amp;ldquo;填充&amp;rdquo;，则&amp;ldquo; limit_direction&amp;rdquo;必须为&amp;ldquo;向后&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="198a8a08aee1bff5568a3c9bfad2801313ba81bb" translate="yes" xml:space="preserve">
          <source>If &amp;lsquo;method&amp;rsquo; is &amp;lsquo;backfill&amp;rsquo; or &amp;lsquo;bfill&amp;rsquo;, the default is &amp;lsquo;backward&amp;rsquo;</source>
          <target state="translated">如果'method'为'backfill'或'bfill'，则默认值为'backward'</target>
        </trans-unit>
        <trans-unit id="970a0920f7495cbfcd494a86c1c52c95ec206136" translate="yes" xml:space="preserve">
          <source>If &amp;lsquo;method&amp;rsquo; is &amp;lsquo;pad&amp;rsquo; or &amp;lsquo;ffill&amp;rsquo;, &amp;lsquo;limit_direction&amp;rsquo; must be &amp;lsquo;forward&amp;rsquo;.</source>
          <target state="translated">如果&amp;ldquo;方法&amp;rdquo;为&amp;ldquo;填充&amp;rdquo;或&amp;ldquo;填充&amp;rdquo;，则&amp;ldquo; limit_direction&amp;rdquo;必须为&amp;ldquo;前进&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="199d3e9cf5e8512896d9d482541e87cadcde8682" translate="yes" xml:space="preserve">
          <source>If &amp;lsquo;orient&amp;rsquo; is &amp;lsquo;records&amp;rsquo; write out line delimited json format. Will throw ValueError if incorrect &amp;lsquo;orient&amp;rsquo; since others are not list like.</source>
          <target state="translated">如果'orient'是'records'，则写出行分隔的json格式。如果不正确的&amp;ldquo;东方&amp;rdquo;将抛出ValueError，因为其他人没有列出。</target>
        </trans-unit>
        <trans-unit id="efece3541c7fce3c755b622642e6e00a9f5917b5" translate="yes" xml:space="preserve">
          <source>If &amp;lsquo;raise&amp;rsquo;, raise a</source>
          <target state="translated">如果&amp;ldquo;提高&amp;rdquo;，请提高</target>
        </trans-unit>
        <trans-unit id="7a715eced952aac9082838419cee8dbd64346a0c" translate="yes" xml:space="preserve">
          <source>If &amp;lsquo;raise&amp;rsquo;, raise a &lt;code&gt;KeyError&lt;/code&gt; when a dict-like &lt;code&gt;mapper&lt;/code&gt;, &lt;code&gt;index&lt;/code&gt;, or &lt;code&gt;columns&lt;/code&gt; contains labels that are not present in the Index being transformed. If &amp;lsquo;ignore&amp;rsquo;, existing keys will be renamed and extra keys will be ignored.</source>
          <target state="translated">如果为'raise'，则当类似dict的 &lt;code&gt;mapper&lt;/code&gt; ， &lt;code&gt;index&lt;/code&gt; 或 &lt;code&gt;columns&lt;/code&gt; 包含要转换的Index中不存在的标签时，引发 &lt;code&gt;KeyError&lt;/code&gt; 。如果为&amp;ldquo; ignore&amp;rdquo;，则现有的密钥将被重命名，多余的密钥将被忽略。</target>
        </trans-unit>
        <trans-unit id="0485157b5ba13ba379ff6892b6733f96842f0855" translate="yes" xml:space="preserve">
          <source>If &amp;lsquo;raise&amp;rsquo;, then invalid parsing will raise an exception</source>
          <target state="translated">如果为&amp;ldquo; raise&amp;rdquo;，则无效的解析将引发异常</target>
        </trans-unit>
        <trans-unit id="00849af26e0f3b9e37f7a382187cd7e59f774f16" translate="yes" xml:space="preserve">
          <source>If &amp;lsquo;raise&amp;rsquo;, then invalid parsing will raise an exception.</source>
          <target state="translated">如果为&amp;ldquo; raise&amp;rdquo;，则无效的解析将引发异常。</target>
        </trans-unit>
        <trans-unit id="4e71c458e98a0c8dc01eef2182556595f5c145b3" translate="yes" xml:space="preserve">
          <source>If &amp;lsquo;raise&amp;rsquo;, will raise a ValueError if the DataFrame and</source>
          <target state="translated">如果为'raise'，则在DataFrame和</target>
        </trans-unit>
        <trans-unit id="3839ee4020555f4a90cf6574c343569184832636" translate="yes" xml:space="preserve">
          <source>If &amp;lsquo;raise&amp;rsquo;, will raise a ValueError if the DataFrame and &lt;code&gt;other&lt;/code&gt; both contain non-NA data in the same place.</source>
          <target state="translated">如果为'raise'，则当DataFrame和 &lt;code&gt;other&lt;/code&gt; 两者在同一位置包含非NA数据时，将引发ValueError 。</target>
        </trans-unit>
        <trans-unit id="3dcbf99c91197fe50065b8c2d1bbfb5fb4697702" translate="yes" xml:space="preserve">
          <source>If &amp;lsquo;unix&amp;rsquo; (or POSIX) time; origin is set to 1970-01-01.</source>
          <target state="translated">如果是&amp;ldquo; unix&amp;rdquo;（或POSIX）时间；原点设置为1970-01-01。</target>
        </trans-unit>
        <trans-unit id="f3d61e029440c96cda1e26ffdb0c5f6446bc64ce" translate="yes" xml:space="preserve">
          <source>If 0 or &amp;lsquo;index&amp;rsquo; counts are generated for each column. If 1 or &amp;lsquo;columns&amp;rsquo; counts are generated for each &lt;strong&gt;row&lt;/strong&gt;.</source>
          <target state="translated">如果为0或&amp;ldquo;索引&amp;rdquo;，则为每列生成计数。如果为1或&amp;ldquo;列&amp;rdquo;，则为每一&lt;strong&gt;行&lt;/strong&gt;生成计数。</target>
        </trans-unit>
        <trans-unit id="38c6dad808791fe5af42cd8974e115c8505961be" translate="yes" xml:space="preserve">
          <source>If 0 or &amp;lsquo;index&amp;rsquo; counts are generated for each column. If 1 or &amp;lsquo;columns&amp;rsquo; counts are generated for each row.</source>
          <target state="translated">如果为0或&amp;ldquo;索引&amp;rdquo;，则为每一列生成计数。如果为1或&amp;ldquo;列&amp;rdquo;，则为每一行生成计数。</target>
        </trans-unit>
        <trans-unit id="6e7da5c288c9e6258ab4bc7bde9bc7e6455b66f5" translate="yes" xml:space="preserve">
          <source>If 0 or &amp;lsquo;index&amp;rsquo;: apply function to each column. If 1 or &amp;lsquo;columns&amp;rsquo;: apply function to each row.</source>
          <target state="translated">如果为0或'index'：将函数应用于每一列。如果为1或&amp;ldquo;列&amp;rdquo;：将函数应用于每一行。</target>
        </trans-unit>
        <trans-unit id="6ae3f7be53f938183a6a6a7495ab5b0abb73ba73" translate="yes" xml:space="preserve">
          <source>If 1-D array like, a sequence with the same shape as the observations.</source>
          <target state="translated">如果是1-D数组一样,则是与观测值形状相同的序列。</target>
        </trans-unit>
        <trans-unit id="d3d4cb4694f132bb429f38f873d8a3b68e48888e" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;https://numba.pydata.org/&quot;&gt;Numba&lt;/a&gt; is installed as an optional dependency, the &lt;code&gt;transform&lt;/code&gt; and &lt;code&gt;aggregate&lt;/code&gt; methods support &lt;code&gt;engine='numba'&lt;/code&gt; and &lt;code&gt;engine_kwargs&lt;/code&gt; arguments. The &lt;code&gt;engine_kwargs&lt;/code&gt; argument is a dictionary of keyword arguments that will be passed into the &lt;a href=&quot;https://numba.pydata.org/numba-doc/latest/reference/jit-compilation.html#numba.jit&quot;&gt;numba.jit decorator&lt;/a&gt;. These keyword arguments will be applied to the passed function. Currently only &lt;code&gt;nogil&lt;/code&gt;, &lt;code&gt;nopython&lt;/code&gt;, and &lt;code&gt;parallel&lt;/code&gt; are supported, and their default values are set to &lt;code&gt;False&lt;/code&gt;, &lt;code&gt;True&lt;/code&gt; and &lt;code&gt;False&lt;/code&gt; respectively.</source>
          <target state="translated">如果将&lt;a href=&quot;https://numba.pydata.org/&quot;&gt;Numba&lt;/a&gt;作为可选依赖项安装，则 &lt;code&gt;transform&lt;/code&gt; 和 &lt;code&gt;aggregate&lt;/code&gt; 方法支持 &lt;code&gt;engine='numba'&lt;/code&gt; 和 &lt;code&gt;engine_kwargs&lt;/code&gt; 参数。该 &lt;code&gt;engine_kwargs&lt;/code&gt; 参数是将要传递到参数的字典&lt;a href=&quot;https://numba.pydata.org/numba-doc/latest/reference/jit-compilation.html#numba.jit&quot;&gt;numba.jit装饰&lt;/a&gt;。这些关键字参数将应用于传递的函数。当前仅支持 &lt;code&gt;nogil&lt;/code&gt; ， &lt;code&gt;nopython&lt;/code&gt; 和 &lt;code&gt;parallel&lt;/code&gt; ，并且它们的默认值分别设置为 &lt;code&gt;False&lt;/code&gt; ， &lt;code&gt;True&lt;/code&gt; 和 &lt;code&gt;False&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e78b0523719ecd8724561c4f3f88618255a6a160" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;pandas.categoricaldtype#pandas.CategoricalDtype&quot;&gt;&lt;code&gt;CategoricalDtype&lt;/code&gt;&lt;/a&gt;, cannot be used together with</source>
          <target state="translated">如果为&lt;a href=&quot;pandas.categoricaldtype#pandas.CategoricalDtype&quot;&gt; &lt;code&gt;CategoricalDtype&lt;/code&gt; &lt;/a&gt;，则不能与</target>
        </trans-unit>
        <trans-unit id="9100712e07a1a3144bf279ca0131c5328bb20fae" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;pandas.categoricaldtype#pandas.CategoricalDtype&quot;&gt;&lt;code&gt;CategoricalDtype&lt;/code&gt;&lt;/a&gt;, cannot be used together with &lt;code&gt;categories&lt;/code&gt; or &lt;code&gt;ordered&lt;/code&gt;.</source>
          <target state="translated">如果为&lt;a href=&quot;pandas.categoricaldtype#pandas.CategoricalDtype&quot;&gt; &lt;code&gt;CategoricalDtype&lt;/code&gt; &lt;/a&gt;，则不能与 &lt;code&gt;categories&lt;/code&gt; 一起使用或 &lt;code&gt;ordered&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="957f4921f3fe1f14cc5e0972c2a9f63db875fa60" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;C&lt;/code&gt; is specified, specifies values at given coordinates &lt;code&gt;(x[i], y[i])&lt;/code&gt;. These values are accumulated for each hexagonal bin and then reduced according to &lt;code&gt;reduce_C_function&lt;/code&gt;, having as default the NumPy&amp;rsquo;s mean function (&lt;code&gt;numpy.mean()&lt;/code&gt;). (If &lt;code&gt;C&lt;/code&gt; is specified, it must also be a 1-D sequence of the same length as &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;, or a column label.)</source>
          <target state="translated">如果指定了 &lt;code&gt;C&lt;/code&gt; ,则指定给定坐标 &lt;code&gt;(x[i], y[i])&lt;/code&gt; 。这些值针对每个六角形仓进行累加，然后根据 &lt;code&gt;reduce_C_function&lt;/code&gt; 进行缩减，默认情况下为NumPy的均值函数（ &lt;code&gt;numpy.mean()&lt;/code&gt; ）。（如果指定了 &lt;code&gt;C&lt;/code&gt; ，则它还必须是与 &lt;code&gt;x&lt;/code&gt; 和 &lt;code&gt;y&lt;/code&gt; 长度相同的一维序列或列标签。）</target>
        </trans-unit>
        <trans-unit id="6499e3dc9a031482752c69e5eecddd3f70eff0f2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;False&lt;/code&gt;, return Series/Index, containing lists of strings.</source>
          <target state="translated">如果为 &lt;code&gt;False&lt;/code&gt; ，则返回Series / Index，其中包含字符串列表。</target>
        </trans-unit>
        <trans-unit id="085b836cec77eb5bb263be486be44249eef786e7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;False&lt;/code&gt;, the resulting index will not drop any level.</source>
          <target state="translated">如果为 &lt;code&gt;False&lt;/code&gt; ，则所得索引将不会下降任何级别。</target>
        </trans-unit>
        <trans-unit id="da8ba51c7b0b90045082965fc49ef9200c0d1945" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;None&lt;/code&gt; is one of the accepted values, it always needs to be the last in the list.</source>
          <target state="translated">如果&amp;ldquo; &lt;code&gt;None&lt;/code&gt; 是可接受的值之一，则它始终必须是列表中的最后一个。</target>
        </trans-unit>
        <trans-unit id="4f8282afef3786c655e62035f97e7e04ec1fca5b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Period&lt;/code&gt; freq is daily or higher (&lt;code&gt;D&lt;/code&gt;, &lt;code&gt;H&lt;/code&gt;, &lt;code&gt;T&lt;/code&gt;, &lt;code&gt;S&lt;/code&gt;, &lt;code&gt;L&lt;/code&gt;, &lt;code&gt;U&lt;/code&gt;, &lt;code&gt;N&lt;/code&gt;), &lt;code&gt;offsets&lt;/code&gt; and &lt;code&gt;timedelta&lt;/code&gt;-like can be added if the result can have the same freq. Otherwise, &lt;code&gt;ValueError&lt;/code&gt; will be raised.</source>
          <target state="translated">如果&amp;ldquo; &lt;code&gt;Period&lt;/code&gt; 频率是每天或更高（ &lt;code&gt;D&lt;/code&gt; ， &lt;code&gt;H&lt;/code&gt; ， &lt;code&gt;T&lt;/code&gt; ， &lt;code&gt;S&lt;/code&gt; ， &lt;code&gt;L&lt;/code&gt; ， &lt;code&gt;U&lt;/code&gt; ， &lt;code&gt;N&lt;/code&gt; ），则如果结果可以具有相同的频率，则可以添加 &lt;code&gt;offsets&lt;/code&gt; 和 &lt;code&gt;timedelta&lt;/code&gt; 的值。否则，将引发 &lt;code&gt;ValueError&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="da2cedf361e06add2c01f64839ff01dfc5bc08b5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Period&lt;/code&gt; has other frequencies, only the same &lt;code&gt;offsets&lt;/code&gt; can be added. Otherwise, &lt;code&gt;ValueError&lt;/code&gt; will be raised.</source>
          <target state="translated">如果&amp;ldquo; &lt;code&gt;Period&lt;/code&gt; 具有其他频率，则只能添加相同的 &lt;code&gt;offsets&lt;/code&gt; 。否则，将引发 &lt;code&gt;ValueError&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="29422fd31262e0e9fc4f8605659e8b004decc893" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;True&lt;/code&gt; -&amp;gt; try parsing the index.</source>
          <target state="translated">如果为 &lt;code&gt;True&lt;/code&gt; - &amp;gt;尝试解析索引。</target>
        </trans-unit>
        <trans-unit id="5d0c1bf5aebde721450027a33154f95136617245" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;True&lt;/code&gt; and parse_dates is enabled for a column, attempt to infer the datetime format to speed up the processing.</source>
          <target state="translated">如果为列启用了 &lt;code&gt;True&lt;/code&gt; 和parse_dates，请尝试推断datetime格式以加快处理速度。</target>
        </trans-unit>
        <trans-unit id="a6363a0cc564b7e07b8b809c7a41ba46945ef3ec" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;True&lt;/code&gt; and parse_dates specifies combining multiple columns then keep the original columns.</source>
          <target state="translated">如果 &lt;code&gt;True&lt;/code&gt; 和parse_dates指定合并多个列，则保留原始列。</target>
        </trans-unit>
        <trans-unit id="4c1aba1752b18100abe103f9924f71075d0ee20b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;True&lt;/code&gt;, include the dataframe&amp;rsquo;s index(es) in the file output. If &lt;code&gt;False&lt;/code&gt;, they will not be written to the file. If &lt;code&gt;None&lt;/code&gt;, similar to &lt;code&gt;True&lt;/code&gt; the dataframe&amp;rsquo;s index(es) will be saved. However, instead of being saved as values, the RangeIndex will be stored as a range in the metadata so it doesn&amp;rsquo;t require much space and is faster. Other indexes will be included as columns in the file output.</source>
          <target state="translated">如果为 &lt;code&gt;True&lt;/code&gt; ，则在文件输出中包括数据框的索引。如果为 &lt;code&gt;False&lt;/code&gt; ，则不会将它们写入文件。如果为 &lt;code&gt;None&lt;/code&gt; ，则类似于 &lt;code&gt;True&lt;/code&gt; ，将保存数据框的索引。但是，RangeIndex不会保存为值，而是存储为元数据中的范围，因此它不需要太多空间而且速度更快。其他索引将作为列包含在文件输出中。</target>
        </trans-unit>
        <trans-unit id="d31355248f274c3070a84b13f60346c84b6ae353" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;True&lt;/code&gt;, include the dataframe&amp;rsquo;s index(es) in the file output. If &lt;code&gt;False&lt;/code&gt;, they will not be written to the file. If &lt;code&gt;None&lt;/code&gt;, the behavior depends on the chosen engine.</source>
          <target state="translated">如果为 &lt;code&gt;True&lt;/code&gt; ，则在文件输出中包括数据框的索引。如果为 &lt;code&gt;False&lt;/code&gt; ，则不会将它们写入文件。如果为 &lt;code&gt;None&lt;/code&gt; ，则行为取决于所选的引擎。</target>
        </trans-unit>
        <trans-unit id="db9c68e2c0847c2648159936067c9e97bd68d778" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;True&lt;/code&gt;, performs operation inplace and returns None.</source>
          <target state="translated">如果为 &lt;code&gt;True&lt;/code&gt; ，则执行就地操作并返回None。</target>
        </trans-unit>
        <trans-unit id="4cb94c12a9c4ef4e915d043b0131ab965753c6c0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;True&lt;/code&gt;, return DataFrame/MultiIndex expanding dimensionality.</source>
          <target state="translated">如果为 &lt;code&gt;True&lt;/code&gt; ，则返回DataFrame / MultiIndex扩展维。</target>
        </trans-unit>
        <trans-unit id="517a8e80d621d1f11e0a5937c0b56cff33456958" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;True&lt;/code&gt;, skip over blank lines rather than interpreting as NaN values.</source>
          <target state="translated">如果为 &lt;code&gt;True&lt;/code&gt; ，则跳过空白行，而不是将其解释为NaN值。</target>
        </trans-unit>
        <trans-unit id="e6e2f07bf71d2ba4698109742fc9a9a2f3add4c6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;[1, 2, 3]&lt;/code&gt; -&amp;gt; try parsing columns 1, 2, 3 each as a separate date column.</source>
          <target state="translated">如果 &lt;code&gt;[1, 2, 3]&lt;/code&gt; -&amp;gt;尝试将第1、2、3列解析为单独的日期列。</target>
        </trans-unit>
        <trans-unit id="184af077a3aa944d3aa6d28e063d05e84f7b5e9d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;[[1, 3]]&lt;/code&gt; -&amp;gt; combine columns 1 and 3 and parse as a single date column.</source>
          <target state="translated">如果 &lt;code&gt;[[1, 3]]&lt;/code&gt; -&amp;gt;合并列1和3，并解析为单个日期列。</target>
        </trans-unit>
        <trans-unit id="970376fd9f251fcf7442a3e8dc1c7f205bfd8a40" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;axis&lt;/code&gt; and/or &lt;code&gt;level&lt;/code&gt; are passed as keywords to both &lt;code&gt;Grouper&lt;/code&gt; and &lt;code&gt;groupby&lt;/code&gt;, the values passed to &lt;code&gt;Grouper&lt;/code&gt; take precedence.</source>
          <target state="translated">如果将 &lt;code&gt;axis&lt;/code&gt; 和/或 &lt;code&gt;level&lt;/code&gt; 作为关键字传递给 &lt;code&gt;Grouper&lt;/code&gt; 和 &lt;code&gt;groupby&lt;/code&gt; ，则传递给 &lt;code&gt;Grouper&lt;/code&gt; 的值优先。</target>
        </trans-unit>
        <trans-unit id="937f7d2a44b813e6b8d92c1002659f32d8844922" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;complib&lt;/code&gt; is defined as something other than the listed libraries a &lt;code&gt;ValueError&lt;/code&gt; exception is issued.</source>
          <target state="translated">如果将 &lt;code&gt;complib&lt;/code&gt; 定义为除列出的库以外的其他库，则将发出 &lt;code&gt;ValueError&lt;/code&gt; 异常。</target>
        </trans-unit>
        <trans-unit id="b5f1537f9831fb3154a33d877feb6f73352a3d42" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;crosstab&lt;/code&gt; receives only two Series, it will provide a frequency table.</source>
          <target state="translated">如果 &lt;code&gt;crosstab&lt;/code&gt; 仅接收两个系列，它将提供一个频率表。</target>
        </trans-unit>
        <trans-unit id="db32402bbe8a4f901a9b37cd1cc804bf16b8f6a2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;data&lt;/code&gt; is a scalar value, an index must be provided. The value will be repeated to match the length of &lt;strong&gt;index&lt;/strong&gt;.</source>
          <target state="translated">如果 &lt;code&gt;data&lt;/code&gt; 是标量值，则必须提供索引。该值将重复以匹配&lt;strong&gt;index&lt;/strong&gt;的长度。</target>
        </trans-unit>
        <trans-unit id="f3bd838dfe683144e93c449ff32d03c1dfd018a1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;data&lt;/code&gt; is an ndarray, &lt;strong&gt;index&lt;/strong&gt; must be the same length as &lt;strong&gt;data&lt;/strong&gt;. If no index is passed, one will be created having values &lt;code&gt;[0, ..., len(data) - 1]&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;data&lt;/code&gt; 是ndarray，则&lt;strong&gt;index&lt;/strong&gt;必须与&lt;strong&gt;data的&lt;/strong&gt;长度相同。如果没有传递索引，则将创建一个具有 &lt;code&gt;[0, ..., len(data) - 1]&lt;/code&gt; 值的索引。</target>
        </trans-unit>
        <trans-unit id="256b2ec2109a10c2b922ec284f2aa6d0f4996ee1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;dropna&lt;/code&gt; is False, &lt;strong&gt;THE USER IS RESPONSIBLE FOR SYNCHRONIZING THE TABLES&lt;/strong&gt;. Remember that entirely &lt;code&gt;np.Nan&lt;/code&gt; rows are not written to the HDFStore, so if you choose to call &lt;code&gt;dropna=False&lt;/code&gt;, some tables may have more rows than others, and therefore &lt;code&gt;select_as_multiple&lt;/code&gt; may not work or it may return unexpected results.</source>
          <target state="translated">如果 &lt;code&gt;dropna&lt;/code&gt; 为False，则&lt;strong&gt;用户负责同步表&lt;/strong&gt;。请记住，整个 &lt;code&gt;np.Nan&lt;/code&gt; 行都不会写入HDFStore，因此，如果您选择调用 &lt;code&gt;dropna=False&lt;/code&gt; ，则某些表可能比其他表具有更多的行，因此 &lt;code&gt;select_as_multiple&lt;/code&gt; 可能无法工作，否则可能返回意外结果。</target>
        </trans-unit>
        <trans-unit id="4efc8cfad113907e0158cf2bc9289ac516eb7f46" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;formatter&lt;/code&gt; is None, the default formatter is used.</source>
          <target state="translated">如果 &lt;code&gt;formatter&lt;/code&gt; 为None，则使用默认的formatter。</target>
        </trans-unit>
        <trans-unit id="9939487b947ef8676c1bc3bbe3735bce7e975089" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;func&lt;/code&gt; is a standard Python function, the engine will &lt;a href=&quot;https://numba.pydata.org/numba-doc/latest/user/overview.html&quot;&gt;JIT&lt;/a&gt; the passed function. &lt;code&gt;func&lt;/code&gt; can also be a JITed function in which case the engine will not JIT the function again.</source>
          <target state="translated">如果 &lt;code&gt;func&lt;/code&gt; 是标准的Python函数，则引擎将&lt;a href=&quot;https://numba.pydata.org/numba-doc/latest/user/overview.html&quot;&gt;JIT&lt;/a&gt;传递的函数。 &lt;code&gt;func&lt;/code&gt; 也可以是JITed函数，在这种情况下，引擎将不再再次JIT函数。</target>
        </trans-unit>
        <trans-unit id="3ab813b7fd3b3d65ecd4fb06b280ae7968617f53" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;include&lt;/code&gt; and &lt;code&gt;exclude&lt;/code&gt; have overlapping elements</source>
          <target state="translated">如果 &lt;code&gt;include&lt;/code&gt; 和 &lt;code&gt;exclude&lt;/code&gt; 具有重叠元素</target>
        </trans-unit>
        <trans-unit id="a7da045296675e29f8161fcdf9df7881d520bb33" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;join != &amp;lsquo;left&amp;rsquo;&lt;/code&gt;</source>
          <target state="translated">如果 &lt;code&gt;join != &amp;lsquo;left&amp;rsquo;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e408e50f4efff0be75273835ecad495f9e1afc4a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;keep_default_na&lt;/code&gt; is &lt;code&gt;False&lt;/code&gt;, and &lt;code&gt;na_values&lt;/code&gt; are not specified, no strings will be parsed as NaN.</source>
          <target state="translated">如果 &lt;code&gt;keep_default_na&lt;/code&gt; 为 &lt;code&gt;False&lt;/code&gt; ，并且未指定 &lt;code&gt;na_values&lt;/code&gt; ，则不会将任何字符串解析为NaN。</target>
        </trans-unit>
        <trans-unit id="cd73a654c84b29616fb9b65fd07e1551ee72e146" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;keep_default_na&lt;/code&gt; is &lt;code&gt;False&lt;/code&gt;, and &lt;code&gt;na_values&lt;/code&gt; are specified, only the NaN values specified &lt;code&gt;na_values&lt;/code&gt; are used for parsing.</source>
          <target state="translated">如果 &lt;code&gt;keep_default_na&lt;/code&gt; 是 &lt;code&gt;False&lt;/code&gt; ，和 &lt;code&gt;na_values&lt;/code&gt; 指定，只有指定的NaN值 &lt;code&gt;na_values&lt;/code&gt; 用于解析。</target>
        </trans-unit>
        <trans-unit id="7a4e153f94488bea1392d12a65c1e2c2599e5594" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;keep_default_na&lt;/code&gt; is &lt;code&gt;True&lt;/code&gt;, and &lt;code&gt;na_values&lt;/code&gt; are not specified, only the default NaN values are used for parsing.</source>
          <target state="translated">如果 &lt;code&gt;keep_default_na&lt;/code&gt; 为 &lt;code&gt;True&lt;/code&gt; ，并且未指定 &lt;code&gt;na_values&lt;/code&gt; ，则仅使用默认的NaN值进行解析。</target>
        </trans-unit>
        <trans-unit id="e25908c5c32fc206359705ce5477202d627c658a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;keep_default_na&lt;/code&gt; is &lt;code&gt;True&lt;/code&gt;, and &lt;code&gt;na_values&lt;/code&gt; are specified, &lt;code&gt;na_values&lt;/code&gt; is appended to the default NaN values used for parsing.</source>
          <target state="translated">如果 &lt;code&gt;keep_default_na&lt;/code&gt; 是 &lt;code&gt;True&lt;/code&gt; ，并且 &lt;code&gt;na_values&lt;/code&gt; 指定， &lt;code&gt;na_values&lt;/code&gt; 被附加到NaN值用于解析所述默认值。</target>
        </trans-unit>
        <trans-unit id="f265a8f044bf232fffa85812d820574c8444bbe7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;keep_default_na&lt;/code&gt; is False, and &lt;code&gt;na_values&lt;/code&gt; are not specified, no strings will be parsed as NaN.</source>
          <target state="translated">如果 &lt;code&gt;keep_default_na&lt;/code&gt; 为False，并且未指定 &lt;code&gt;na_values&lt;/code&gt; ，则不会将任何字符串解析为NaN。</target>
        </trans-unit>
        <trans-unit id="8a282745eb357ce0d97179f43d5f0ca158631ab3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;keep_default_na&lt;/code&gt; is False, and &lt;code&gt;na_values&lt;/code&gt; are specified, only the NaN values specified &lt;code&gt;na_values&lt;/code&gt; are used for parsing.</source>
          <target state="translated">如果 &lt;code&gt;keep_default_na&lt;/code&gt; 是假，和 &lt;code&gt;na_values&lt;/code&gt; 指定，只有指定的NaN值 &lt;code&gt;na_values&lt;/code&gt; 用于解析。</target>
        </trans-unit>
        <trans-unit id="e8ef3b4bb67919e2a3c220c269aec10ecbb92263" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;keep_default_na&lt;/code&gt; is True, and &lt;code&gt;na_values&lt;/code&gt; are not specified, only the default NaN values are used for parsing.</source>
          <target state="translated">如果 &lt;code&gt;keep_default_na&lt;/code&gt; 为True，并且未指定 &lt;code&gt;na_values&lt;/code&gt; ，则仅使用默认的NaN值进行解析。</target>
        </trans-unit>
        <trans-unit id="4119b503697716799e0d3d53bb23a09257bc768a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;keep_default_na&lt;/code&gt; is True, and &lt;code&gt;na_values&lt;/code&gt; are specified, &lt;code&gt;na_values&lt;/code&gt; is appended to the default NaN values used for parsing.</source>
          <target state="translated">如果 &lt;code&gt;keep_default_na&lt;/code&gt; 为True，并且 &lt;code&gt;na_values&lt;/code&gt; 指定， &lt;code&gt;na_values&lt;/code&gt; 被附加到NaN值用于解析所述默认值。</target>
        </trans-unit>
        <trans-unit id="14eafb6125c72331ed6931749a85a2bfe869b0fb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;level&lt;/code&gt; is not set, all levels are removed from the Index.</source>
          <target state="translated">如果 &lt;code&gt;level&lt;/code&gt; 没有设置，各级从索引中删除。</target>
        </trans-unit>
        <trans-unit id="bbb5a110126584a428bb870b81494275cb5c1371" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;level&lt;/code&gt; is specified:</source>
          <target state="translated">如果指定 &lt;code&gt;level&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="60f1e6635b0a341e3238693e8e1f6f09613ae56b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;na_rep&lt;/code&gt; is None, and &lt;code&gt;others&lt;/code&gt; is None, missing values in the Series/Index are omitted from the result.</source>
          <target state="translated">如果 &lt;code&gt;na_rep&lt;/code&gt; 为None， &lt;code&gt;others&lt;/code&gt; 值为None，则从结果中省略Series / Index中缺少的值。</target>
        </trans-unit>
        <trans-unit id="444db6399518d3b249738d624701c4ac6b47e94e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;na_rep&lt;/code&gt; is None, and &lt;code&gt;others&lt;/code&gt; is not None, a row containing a missing value in any of the columns (before concatenation) will have a missing value in the result.</source>
          <target state="translated">如果 &lt;code&gt;na_rep&lt;/code&gt; 为None，而 &lt;code&gt;others&lt;/code&gt; 的不是None，则在任何列中（连接之前）包含缺失值的行将在结果中具有缺失值。</target>
        </trans-unit>
        <trans-unit id="c1f385438de08840651ce957815b6972e0f16406" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;numpy=True&lt;/code&gt; is passed to &lt;code&gt;read_json&lt;/code&gt; an attempt will be made to sniff an appropriate dtype during deserialization and to subsequently decode directly to NumPy arrays, bypassing the need for intermediate Python objects.</source>
          <target state="translated">如果将 &lt;code&gt;numpy=True&lt;/code&gt; 传递给 &lt;code&gt;read_json&lt;/code&gt; ，则将尝试在反序列化过程中嗅探适当的dtype，然后直接解码为NumPy数组，而无需中间的Python对象。</target>
        </trans-unit>
        <trans-unit id="5b7230c53dd34c840119bd5592d141943fc9eb82" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;other&lt;/code&gt; contains NaNs the corresponding values are not updated in the original Series.</source>
          <target state="translated">如果 &lt;code&gt;other&lt;/code&gt; 包含NaN，则相应的值在原始系列中不会更新。</target>
        </trans-unit>
        <trans-unit id="deb8809ee611aa9a981b6b0843436b17f4eb152b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;other&lt;/code&gt; contains NaNs the corresponding values are not updated in the original dataframe.</source>
          <target state="translated">如果 &lt;code&gt;other&lt;/code&gt; 包含NaN，则相应的值不会在原始数据帧中更新。</target>
        </trans-unit>
        <trans-unit id="25b2a3bb2e641aa80e4bd798d256b6357269c5bf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;others&lt;/code&gt; is None, &lt;code&gt;str&lt;/code&gt; is returned, otherwise a &lt;code&gt;Series/Index&lt;/code&gt; (same type as caller) of objects is returned.</source>
          <target state="translated">如果 &lt;code&gt;others&lt;/code&gt; 为None，则返回 &lt;code&gt;str&lt;/code&gt; ，否则返回对象的 &lt;code&gt;Series/Index&lt;/code&gt; （与调用者相同的类型）。</target>
        </trans-unit>
        <trans-unit id="09719fe597a3b1238ba510411ad64aa8b9b27a42" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;others&lt;/code&gt; is specified, corresponding values are concatenated with the separator. Result will be a Series of strings.</source>
          <target state="translated">如果指定了 &lt;code&gt;others&lt;/code&gt; 值，则将相应的值与分隔符连接在一起。结果将是一系列字符串。</target>
        </trans-unit>
        <trans-unit id="403aef7dbc0efb83661ae14475ba2c1f617d536d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;others&lt;/code&gt; is specified, this function concatenates the Series/Index and elements of &lt;code&gt;others&lt;/code&gt; element-wise. If &lt;code&gt;others&lt;/code&gt; is not passed, then all values in the Series/Index are concatenated into a single string with a given &lt;code&gt;sep&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;others&lt;/code&gt; 被指定，这个函数连接的系列/索引和元素 &lt;code&gt;others&lt;/code&gt; 元素方面。如果未传递 &lt;code&gt;others&lt;/code&gt; 值，则将Series / Index中的所有值连接到具有给定 &lt;code&gt;sep&lt;/code&gt; 的单个字符串中。</target>
        </trans-unit>
        <trans-unit id="1abddbde8315f2084021872e6073c1be66d77681" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;path_or_buffer&lt;/code&gt; is an OpenDocument format (.odf, .ods, .odt), then &lt;a href=&quot;https://pypi.org/project/odfpy/&quot;&gt;odf&lt;/a&gt; will be used.</source>
          <target state="translated">如果 &lt;code&gt;path_or_buffer&lt;/code&gt; 是OpenDocument格式（.odf，.ods，.odt），则将使用&lt;a href=&quot;https://pypi.org/project/odfpy/&quot;&gt;odf&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3baa765246b3745f60bd4ee59b2f98ce470debc0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;periods &amp;gt; len(self)&lt;/code&gt;, then an array of size len(self) is returned, with all values filled with &lt;code&gt;self.dtype.na_value&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;periods &amp;gt; len(self)&lt;/code&gt; ，则返回大小为len（self）的数组，所有值都用 &lt;code&gt;self.dtype.na_value&lt;/code&gt; 填充。</target>
        </trans-unit>
        <trans-unit id="c112aa6403a164634d1416141466a683b493a868" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;q&lt;/code&gt; is a float, a Series will be returned where the</source>
          <target state="translated">如果 &lt;code&gt;q&lt;/code&gt; 为浮点数，则在</target>
        </trans-unit>
        <trans-unit id="6ea206fbf912a77c2c5baccfb75902c0063d921d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;q&lt;/code&gt; is an array, a DataFrame will be returned where the</source>
          <target state="translated">如果 &lt;code&gt;q&lt;/code&gt; 是一个数组，则将返回一个DataFrame，其中</target>
        </trans-unit>
        <trans-unit id="961740cc92f0fc03f28c95a8a238e4dbbce71c86" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;q&lt;/code&gt; is an array, a Series will be returned where the index is &lt;code&gt;q&lt;/code&gt; and the values are the quantiles, otherwise a float will be returned.</source>
          <target state="translated">如果 &lt;code&gt;q&lt;/code&gt; 是一个数组，则将返回索引为 &lt;code&gt;q&lt;/code&gt; 且值为分位数的Series ，否则将返回float。</target>
        </trans-unit>
        <trans-unit id="50282aa940212018e61f3deecb959d20f87fb9a6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;regex&lt;/code&gt; is not a &lt;code&gt;bool&lt;/code&gt; and &lt;code&gt;to_replace&lt;/code&gt; is not &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;regex&lt;/code&gt; 不是 &lt;code&gt;bool&lt;/code&gt; 并且 &lt;code&gt;to_replace&lt;/code&gt; 不是 &lt;code&gt;None&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b41c22f4efb9468b1cb6a930f4d6611ab107c8d3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;return_type&lt;/code&gt; is</source>
          <target state="translated">如果 &lt;code&gt;return_type&lt;/code&gt; 为</target>
        </trans-unit>
        <trans-unit id="81766fdd49633266642838e7da2bdf12aca59fae" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;return_type&lt;/code&gt; is &lt;code&gt;None&lt;/code&gt;, a NumPy array of axes with the same shape as &lt;code&gt;layout&lt;/code&gt; is returned.</source>
          <target state="translated">如果 &lt;code&gt;return_type&lt;/code&gt; 为 &lt;code&gt;None&lt;/code&gt; ，则返回与 &lt;code&gt;layout&lt;/code&gt; 具有相同形状的NumPy轴数组。</target>
        </trans-unit>
        <trans-unit id="f81d6e8038a65cfec7ed666581c73e2227881317" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;return_type&lt;/code&gt; is &lt;code&gt;None&lt;/code&gt;, a NumPy array of axes with the same shape as &lt;code&gt;layout&lt;/code&gt; is returned:</source>
          <target state="translated">如果 &lt;code&gt;return_type&lt;/code&gt; 为 &lt;code&gt;None&lt;/code&gt; ，则返回与 &lt;code&gt;layout&lt;/code&gt; 具有相同形状的NumPy轴数组：</target>
        </trans-unit>
        <trans-unit id="9403f65e0291ebfce3b893ca7ef9f39c4702bafd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;self&lt;/code&gt; is empty or &lt;code&gt;periods&lt;/code&gt; is 0, a copy of &lt;code&gt;self&lt;/code&gt; is returned.</source>
          <target state="translated">如果 &lt;code&gt;self&lt;/code&gt; 为空或 &lt;code&gt;periods&lt;/code&gt; 为0，则返回 &lt;code&gt;self&lt;/code&gt; 的副本。</target>
        </trans-unit>
        <trans-unit id="6c9ebf0aff8358da4c22aadcc4e5af5797dd0abb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;sep&lt;/code&gt; is not specified, the values are concatenated without separation.</source>
          <target state="translated">如果未指定 &lt;code&gt;sep&lt;/code&gt; ，则将这些值连接起来而不会分离。</target>
        </trans-unit>
        <trans-unit id="42e82e5988245d4a3bb290ebd363efd4d9efea4c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;skip_blank_lines=False&lt;/code&gt;, then &lt;code&gt;read_csv&lt;/code&gt; will not ignore blank lines:</source>
          <target state="translated">如果 &lt;code&gt;skip_blank_lines=False&lt;/code&gt; ，则 &lt;code&gt;read_csv&lt;/code&gt; 将不会忽略空行：</target>
        </trans-unit>
        <trans-unit id="be88e00b6cd2ee9590d0a2d751007eb4876a853c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;skipna&lt;/code&gt; is False and there is an NA value in the data, the function returns &lt;code&gt;nan&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;skipna&lt;/code&gt; 为False并且数据中有NA值，则该函数返回 &lt;code&gt;nan&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8565c59edb64329c1ca271f30471849138be0bff" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;start&lt;/code&gt; or &lt;code&gt;end&lt;/code&gt; are &lt;code&gt;Period&lt;/code&gt; objects, they will be used as anchor endpoints for a &lt;code&gt;PeriodIndex&lt;/code&gt; with frequency matching that of the &lt;code&gt;PeriodIndex&lt;/code&gt; constructor.</source>
          <target state="translated">如果 &lt;code&gt;start&lt;/code&gt; 或 &lt;code&gt;end&lt;/code&gt; 是 &lt;code&gt;Period&lt;/code&gt; 对象，则它们将用作 &lt;code&gt;PeriodIndex&lt;/code&gt; 的锚定端点，其频率与 &lt;code&gt;PeriodIndex&lt;/code&gt; 构造函数的频率匹配。</target>
        </trans-unit>
        <trans-unit id="d07c799aa985555aa80944ae394ade3e6e41e965" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;start&lt;/code&gt; or &lt;code&gt;end&lt;/code&gt; are &lt;code&gt;Period&lt;/code&gt; objects, they will be used as anchor endpoints for a &lt;code&gt;PeriodIndex&lt;/code&gt; with frequency matching that of the &lt;code&gt;period_range&lt;/code&gt; constructor.</source>
          <target state="translated">如果 &lt;code&gt;start&lt;/code&gt; 或 &lt;code&gt;end&lt;/code&gt; 是 &lt;code&gt;Period&lt;/code&gt; 对象，则它们将用作 &lt;code&gt;PeriodIndex&lt;/code&gt; 的锚定端点，其频率与 &lt;code&gt;period_range&lt;/code&gt; 构造函数的频率匹配。</target>
        </trans-unit>
        <trans-unit id="b7b0a663d9250908bec356033f00f39037ab14b6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;target&lt;/code&gt; is provided, and the expression mutates &lt;code&gt;target&lt;/code&gt;, whether to modify &lt;code&gt;target&lt;/code&gt; inplace. Otherwise, return a copy of &lt;code&gt;target&lt;/code&gt; with the mutation.</source>
          <target state="translated">如果提供了 &lt;code&gt;target&lt;/code&gt; ，并且表达式使 &lt;code&gt;target&lt;/code&gt; 突变，则是否就地修改 &lt;code&gt;target&lt;/code&gt; 。否则，返回带有突变的 &lt;code&gt;target&lt;/code&gt; 的副本。</target>
        </trans-unit>
        <trans-unit id="e1e7c5e72393131f2654387c48d329fe2921498d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;text_color_threshold&lt;/code&gt; is not a value from 0 to 1.</source>
          <target state="translated">如果 &lt;code&gt;text_color_threshold&lt;/code&gt; 不是0到1之间的值。</target>
        </trans-unit>
        <trans-unit id="535b234a64529b3677378d8dfde02546b2a249b1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;times&lt;/code&gt; is specified, the time unit (str or timedelta) over which an observation decays to half its value. Only applicable to &lt;code&gt;mean()&lt;/code&gt; and halflife value will not apply to the other functions.</source>
          <target state="translated">如果 &lt;code&gt;times&lt;/code&gt; 被指定时，时间单位（STR或timedelta），在其上观察衰减到一半的值。仅适用于 &lt;code&gt;mean()&lt;/code&gt; 和半衰期值将不适用于其他函数。</target>
        </trans-unit>
        <trans-unit id="704cdb74002773b3b579c1c3d6d7936011db63ed" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;to_replace&lt;/code&gt; is &lt;code&gt;None&lt;/code&gt; and &lt;code&gt;regex&lt;/code&gt; is not compilable into a regular expression or is a list, dict, ndarray, or Series.</source>
          <target state="translated">如果 &lt;code&gt;to_replace&lt;/code&gt; 为 &lt;code&gt;None&lt;/code&gt; 并且 &lt;code&gt;regex&lt;/code&gt; 不能编译为正则表达式或者为列表，字典，ndarray或Series。</target>
        </trans-unit>
        <trans-unit id="d03447781d080adef5a2a9380fc861eeabc92417" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;to_replace&lt;/code&gt; is a &lt;code&gt;dict&lt;/code&gt; and &lt;code&gt;value&lt;/code&gt; is not a &lt;code&gt;list&lt;/code&gt;, &lt;code&gt;dict&lt;/code&gt;, &lt;code&gt;ndarray&lt;/code&gt;, or &lt;code&gt;Series&lt;/code&gt;</source>
          <target state="translated">如果 &lt;code&gt;to_replace&lt;/code&gt; 是 &lt;code&gt;dict&lt;/code&gt; 而 &lt;code&gt;value&lt;/code&gt; 不是 &lt;code&gt;list&lt;/code&gt; ， &lt;code&gt;dict&lt;/code&gt; ， &lt;code&gt;ndarray&lt;/code&gt; 或 &lt;code&gt;Series&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3a1caaa2d26334416b23c7630389d536a0fad7d6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;usecols&lt;/code&gt; is a list of integers, then it is assumed to be the file column indices to be parsed.</source>
          <target state="translated">如果 &lt;code&gt;usecols&lt;/code&gt; 是整数列表，则假定它是要解析的文件列索引。</target>
        </trans-unit>
        <trans-unit id="6ac4edea12a43fd31cf9476433f0b0a1a854909b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;usecols&lt;/code&gt; is a list of strings, it is assumed that each string corresponds to a column name provided either by the user in &lt;code&gt;names&lt;/code&gt; or inferred from the document header row(s). Those strings define which columns will be parsed:</source>
          <target state="translated">如果 &lt;code&gt;usecols&lt;/code&gt; 是字符串列表，则假定每个字符串都与用户提供的 &lt;code&gt;names&lt;/code&gt; 或从文档标题行推断出的列名称相对应。这些字符串定义将要解析的列：</target>
        </trans-unit>
        <trans-unit id="e01b5dff3b67b87609e0579db43ccbda944e4e34" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;usecols&lt;/code&gt; is callable, the callable function will be evaluated against the column names, returning names where the callable function evaluates to &lt;code&gt;True&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;usecols&lt;/code&gt; 是可调用的，则将针对列名称评估可调用函数，并在可调用函数计算结果为 &lt;code&gt;True&lt;/code&gt; 的情况下返回名称。</target>
        </trans-unit>
        <trans-unit id="1a1de8e0a85b6ff84557f7ecae5437820577f3a8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;uuid&lt;/code&gt; is not specified, the length of the &lt;code&gt;uuid&lt;/code&gt; to randomly generate expressed in hex characters, in range [0, 32].</source>
          <target state="translated">如果 &lt;code&gt;uuid&lt;/code&gt; 未指定，则长度 &lt;code&gt;uuid&lt;/code&gt; 随机在十六进制字符产生表达，在范围[0，32]。</target>
        </trans-unit>
        <trans-unit id="c278841e9bef34e1e1bd4a72a3426ae68586bd37" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;values&lt;/code&gt; is a string</source>
          <target state="translated">如果 &lt;code&gt;values&lt;/code&gt; 是一个字符串</target>
        </trans-unit>
        <trans-unit id="d9b7a5e40e9f52d62b19692bf3dcad2166cfe945" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;win_type=None&lt;/code&gt; all points are evenly weighted. To learn more about different window types see &lt;a href=&quot;https://docs.scipy.org/doc/scipy/reference/signal.html#window-functions&quot;&gt;scipy.signal window functions&lt;/a&gt;.</source>
          <target state="translated">如果 &lt;code&gt;win_type=None&lt;/code&gt; ,则对所有点进行平均加权。要了解有关不同窗口类型的更多信息，请参见&lt;a href=&quot;https://docs.scipy.org/doc/scipy/reference/signal.html#window-functions&quot;&gt;scipy.signal窗口函数&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a7762da07ec115be44fc02765f9d76407b7404d1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;win_type=None&lt;/code&gt;, all points are evenly weighted; otherwise, &lt;code&gt;win_type&lt;/code&gt; can accept a string of any &lt;a href=&quot;https://docs.scipy.org/doc/scipy/reference/signal.windows.html#module-scipy.signal.windows&quot;&gt;scipy.signal window function&lt;/a&gt;.</source>
          <target state="translated">如果 &lt;code&gt;win_type=None&lt;/code&gt; ，则对所有点进行平均加权；否则为0。否则， &lt;code&gt;win_type&lt;/code&gt; 可以接受任何&lt;a href=&quot;https://docs.scipy.org/doc/scipy/reference/signal.windows.html#module-scipy.signal.windows&quot;&gt;scipy.signal窗口函数&lt;/a&gt;的字符串。</target>
        </trans-unit>
        <trans-unit id="a71b0b95595f61d6f49ae04391e762a1155d81ff" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;{'foo': [1, 3]}&lt;/code&gt; -&amp;gt; parse columns 1, 3 as date and call result &amp;lsquo;foo&amp;rsquo;. A fast-path exists for iso8601-formatted dates.</source>
          <target state="translated">如果 &lt;code&gt;{'foo': [1, 3]}&lt;/code&gt; -&amp;gt;将第1、3列解析为日期，并调用结果'foo'。对于iso8601格式的日期，存在快速路径。</target>
        </trans-unit>
        <trans-unit id="82a6323b295fa22008498d6df468eee6b83c1cb8" translate="yes" xml:space="preserve">
          <source>If DataFrame contains only NaNs, it is still not considered empty. See the example below.</source>
          <target state="translated">如果DataFrame只包含NaNs,它仍然不被认为是空的。请看下面的例子。</target>
        </trans-unit>
        <trans-unit id="dc64a7e5f7b013c75ec87dad61798a0bf364de27" translate="yes" xml:space="preserve">
          <source>If DataFrame is empty, return True, if not return False.</source>
          <target state="translated">如果DataFrame为空,则返回True,如果不是则返回False。</target>
        </trans-unit>
        <trans-unit id="9db46c5d4b42b8c5a58b772328c51b664e184ae7" translate="yes" xml:space="preserve">
          <source>If Datetime Array/Index is tz-naive.</source>
          <target state="translated">如果Datetime Array/Index是tz-naive。</target>
        </trans-unit>
        <trans-unit id="d1f885919f4b6084a26832cb39a10a880fe30e9f" translate="yes" xml:space="preserve">
          <source>If False (default), the SparseSeries index consists of only the coords of the non-null entries of the original coo_matrix. If True, the SparseSeries index consists of the full sorted (row, col) coordinates of the coo_matrix.</source>
          <target state="translated">如果为False(默认值),SparseSeries索引只由原始coo_matrix的非空条目的坐标组成,如果为True,SparseSeries索引由coo_matrix的全部排序(行,列)坐标组成。如果为True,SparseSeries索引由coo_matrix的全部排序(行,列)坐标组成。</target>
        </trans-unit>
        <trans-unit id="af4968ab538593a91313d8dbcdb3666d290ea5ad" translate="yes" xml:space="preserve">
          <source>If False returns a numpy.timedelta64 or numpy.darray of values of dtype timedelta64[ns].</source>
          <target state="translated">如果False,则返回dtype timedelta64[ns]的numpy.timedelta64或numpy.darray值。</target>
        </trans-unit>
        <trans-unit id="19cb14e4bedf8bda1fb770c21ea9563b40397a07" translate="yes" xml:space="preserve">
          <source>If False returns ndarray of values.</source>
          <target state="translated">如果False返回ndarray的值。</target>
        </trans-unit>
        <trans-unit id="c4ef3d2ab2c9c4543800461df47e4edf64d59fdc" translate="yes" xml:space="preserve">
          <source>If False then only matching columns between self and other will be used and the output will be a DataFrame. If True then all pairwise combinations will be calculated and the output will be a MultiIndex DataFrame in the case of DataFrame inputs. In the case of missing elements, only complete pairwise observations will be used.</source>
          <target state="translated">如果为False,则只使用self和other之间的匹配列,输出为DataFrame。如果为真,那么将计算所有的配对组合,在DataFrame输入的情况下,输出将是一个MultiIndex DataFrame。在缺少元素的情况下,将只使用完整的配对观测值。</target>
        </trans-unit>
        <trans-unit id="b5a787dc4a36cd7a1fb843fad1ef9b45ebd6788d" translate="yes" xml:space="preserve">
          <source>If False then only matching columns between self and other will be used and the output will be a DataFrame. If True then all pairwise combinations will be calculated and the output will be a MultiIndexed DataFrame in the case of DataFrame inputs. In the case of missing elements, only complete pairwise observations will be used.</source>
          <target state="translated">如果为False,则只使用self和other之间的匹配列,输出是一个DataFrame。如果为真,那么将计算所有的配对组合,在DataFrame输入的情况下,输出将是一个MultiIndexed DataFrame。在缺少元素的情况下,将只使用完整的配对观测值。</target>
        </trans-unit>
        <trans-unit id="a089d4a3cab4ec051531af18ca8716ac15f227f1" translate="yes" xml:space="preserve">
          <source>If False then underlying input data is not copied.</source>
          <target state="translated">如果False,则不复制底层输入数据。</target>
        </trans-unit>
        <trans-unit id="7f4768ce69348aa654b6f78c372d4c73bce62c22" translate="yes" xml:space="preserve">
          <source>If False, allow the format to match anywhere in the target string.</source>
          <target state="translated">如果为False,允许在目标字符串的任何地方匹配格式。</target>
        </trans-unit>
        <trans-unit id="30010fa9b0dacd4bae2d42840bc8bc8330f1bc61" translate="yes" xml:space="preserve">
          <source>If False, avoid copy if possible.</source>
          <target state="translated">如果是False,尽可能避免复制。</target>
        </trans-unit>
        <trans-unit id="291d4f114810ff3b85734eb9c885f67fb9461220" translate="yes" xml:space="preserve">
          <source>If False, do not copy data unnecessarily.</source>
          <target state="translated">如果为 &quot;False&quot;,则不要不必要地复制数据。</target>
        </trans-unit>
        <trans-unit id="713b0af025da394c1dfc7bcc4b8e6a4fc01b89b5" translate="yes" xml:space="preserve">
          <source>If False, don&amp;rsquo;t match the same &amp;lsquo;on&amp;rsquo; value (i.e., strictly less-than / strictly greater-than)</source>
          <target state="translated">如果为False，则不匹配相同的&amp;ldquo; on&amp;rdquo;值（即，严格小于/严格大于）</target>
        </trans-unit>
        <trans-unit id="e90b5bec78f4ab7a4fe30e4eff0e3912178db8a9" translate="yes" xml:space="preserve">
          <source>If False, don&amp;rsquo;t match the same &amp;lsquo;on&amp;rsquo; value (i.e., strictly less-than / strictly greater-than).</source>
          <target state="translated">如果为False，则不匹配相同的&amp;ldquo; on&amp;rdquo;值（即，严格小于/严格大于）。</target>
        </trans-unit>
        <trans-unit id="6b84b5f31bb2d6147a51b4eadc91b3e249c42dd9" translate="yes" xml:space="preserve">
          <source>If False, groups that evaluate False are filled with NaNs.</source>
          <target state="translated">如果False,评价False的组就会充满NaNs。</target>
        </trans-unit>
        <trans-unit id="6b2899b63827cccc80ce7f0849090ad8a00a13fe" translate="yes" xml:space="preserve">
          <source>If False, number in reverse, from length of group - 1 to 0.</source>
          <target state="translated">如果为False,则从组的长度-1到0,倒数。</target>
        </trans-unit>
        <trans-unit id="18d85815ef65505f4da3c47d9d292cf07677ec50" translate="yes" xml:space="preserve">
          <source>If False, number in reverse, from number of group - 1 to 0.</source>
          <target state="translated">如果False,则从组数-1到0,数字倒过来。</target>
        </trans-unit>
        <trans-unit id="c66981ba95dd5d03a5bf5f115c2c1e1bc6df4b6d" translate="yes" xml:space="preserve">
          <source>If False, outputs info in a human readable form to the console.</source>
          <target state="translated">如果为False,则以人类可读的形式输出信息到控制台。</target>
        </trans-unit>
        <trans-unit id="fb6ee337b37c7d79d6ff069d1d6be9c1ee63f16e" translate="yes" xml:space="preserve">
          <source>If False, return a copy. Otherwise, do operation inplace and return None.</source>
          <target state="translated">如果为False,返回一个副本。否则,做原地操作,返回None。</target>
        </trans-unit>
        <trans-unit id="eee400988b3add06c7b8d82d92a5db12cafc5df8" translate="yes" xml:space="preserve">
          <source>If False, returns object with same levels as self.</source>
          <target state="translated">如果为False,返回与self相同级别的对象。</target>
        </trans-unit>
        <trans-unit id="93f8cbc94b6ecff2910e70c613725fd41f719aa1" translate="yes" xml:space="preserve">
          <source>If False, the quantile of datetime and timedelta data will be computed as well.</source>
          <target state="translated">如果为 &quot;False&quot;,则也会计算日期时间和时间德尔塔数据的分位数。</target>
        </trans-unit>
        <trans-unit id="1a855233ec9b42057ad4f3f0a22d197f5cc6c27a" translate="yes" xml:space="preserve">
          <source>If False, treats the pat as a literal string.</source>
          <target state="translated">如果为False,则将pat作为一个字符串处理。</target>
        </trans-unit>
        <trans-unit id="d42e87de00086a1c6e6f625064f6fded12c14393" translate="yes" xml:space="preserve">
          <source>If False, treats the pattern as a literal string</source>
          <target state="translated">如果为 &quot;False&quot;,则将该模式作为一个字符串处理。</target>
        </trans-unit>
        <trans-unit id="386a8df84344bc31d4acd3d0513c6b8223ed5e6c" translate="yes" xml:space="preserve">
          <source>If NaN is in the values, and we want to include NaN in the uniques of the values, it can be achieved by setting &lt;code&gt;na_sentinel=None&lt;/code&gt;.</source>
          <target state="translated">如果值中包含NaN，并且我们希望将NaN包含在值的唯一性中，则可以通过设置 &lt;code&gt;na_sentinel=None&lt;/code&gt; 来实现。</target>
        </trans-unit>
        <trans-unit id="6823fe124c6d762f846db12c9b7eb432cef57e38" translate="yes" xml:space="preserve">
          <source>If None, defaults to 1</source>
          <target state="translated">如果无,默认为1。</target>
        </trans-unit>
        <trans-unit id="0f5d6d9a47683654054d53fe83da6d519ea96659" translate="yes" xml:space="preserve">
          <source>If None, defaults to 1.</source>
          <target state="translated">如果没有,默认为1。</target>
        </trans-unit>
        <trans-unit id="7a198b80d00181744c0b52dce1e2d43c14c2ff18" translate="yes" xml:space="preserve">
          <source>If None, defaults to the beginning</source>
          <target state="translated">如果无,则默认为开头</target>
        </trans-unit>
        <trans-unit id="2228cf54c4d2a4d2730b3b9a52429df0614dd9bd" translate="yes" xml:space="preserve">
          <source>If None, defaults to the beginning.</source>
          <target state="translated">如果无,则默认为开头。</target>
        </trans-unit>
        <trans-unit id="d75f9174710ceedaeffa648b72cbbd3e8b87a0b5" translate="yes" xml:space="preserve">
          <source>If None, defaults to the end</source>
          <target state="translated">如果无,默认为结束</target>
        </trans-unit>
        <trans-unit id="ed03605cbabb4c3045d9b32daba224dab5b90b57" translate="yes" xml:space="preserve">
          <source>If None, defaults to the end.</source>
          <target state="translated">如果无,默认为结束。</target>
        </trans-unit>
        <trans-unit id="99befa70db36b844698b11450c67335fe8946fc0" translate="yes" xml:space="preserve">
          <source>If None, dtype will be inferred</source>
          <target state="translated">如果没有,将推断出dtype。</target>
        </trans-unit>
        <trans-unit id="305e45bf0f534becf08e10a608173f7b64e54cf0" translate="yes" xml:space="preserve">
          <source>If None, dtype will be inferred.</source>
          <target state="translated">如果无,将推断出dtype。</target>
        </trans-unit>
        <trans-unit id="33245c017268287ad9b24177b04ead223d178eae" translate="yes" xml:space="preserve">
          <source>If None, file format is inferred from file extension. If &amp;lsquo;xport&amp;rsquo; or &amp;lsquo;sas7bdat&amp;rsquo;, uses the corresponding format.</source>
          <target state="translated">如果为None，则从文件扩展名推断文件格式。如果为&amp;ldquo; xport&amp;rdquo;或&amp;ldquo; sas7bdat&amp;rdquo;，则使用相应的格式。</target>
        </trans-unit>
        <trans-unit id="e4bd68ed52ae06d305e0f091922ac01ec8be5f11" translate="yes" xml:space="preserve">
          <source>If None, pd.get_option(&amp;lsquo;io.hdf.default_format&amp;rsquo;) is checked, followed by fallback to &amp;ldquo;fixed&amp;rdquo;</source>
          <target state="translated">如果为None，则检查pd.get_option（'io.hdf.default_format'），然后回退到&amp;ldquo;固定&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="f40dfbb91453fe35b8691d9034b77ccdc78058b8" translate="yes" xml:space="preserve">
          <source>If None, return all columns, otherwise, returns specified columns.</source>
          <target state="translated">如果None,则返回所有列,否则,返回指定列。</target>
        </trans-unit>
        <trans-unit id="9d3b9a2dcf0b8b571245f92f0d02282c76972d82" translate="yes" xml:space="preserve">
          <source>If None, then parse all columns.</source>
          <target state="translated">如果无,则解析所有列。</target>
        </trans-unit>
        <trans-unit id="cede37750460f29cb4fa52c7fec665577cfd52b2" translate="yes" xml:space="preserve">
          <source>If Numba is passed a function that includes something it doesn&amp;rsquo;t know how to work with &amp;ndash; a category that currently includes sets, lists, dictionaries, or string functions &amp;ndash; it will revert to &lt;code&gt;object mode&lt;/code&gt;. In &lt;code&gt;object mode&lt;/code&gt;, Numba will execute but your code will not speed up significantly. If you would prefer that Numba throw an error if it cannot compile a function in a way that speeds up your code, pass Numba the argument &lt;code&gt;nopython=True&lt;/code&gt; (e.g. &lt;code&gt;@numba.jit(nopython=True)&lt;/code&gt;). For more on troubleshooting Numba modes, see the &lt;a href=&quot;http://numba.pydata.org/numba-doc/latest/user/troubleshoot.html#the-compiled-code-is-too-slow&quot;&gt;Numba troubleshooting page&lt;/a&gt;.</source>
          <target state="translated">如果Numba传递了一个函数，该函数包含一个不知道如何使用的函数（当前包含集合，列表，字典或字符串函数的类别），它将恢复为 &lt;code&gt;object mode&lt;/code&gt; 。在 &lt;code&gt;object mode&lt;/code&gt; ，Numba将执行，但是您的代码将不会显着加快速度。如果您希望Numba在无法以加速代码的方式编译函数时抛出错误，请向 &lt;code&gt;nopython=True&lt;/code&gt; 传递参数nopython = True（例如 &lt;code&gt;@numba.jit(nopython=True)&lt;/code&gt; ）。有关对Numba模式进行故障排除的更多信息，请参阅&lt;a href=&quot;http://numba.pydata.org/numba-doc/latest/user/troubleshoot.html#the-compiled-code-is-too-slow&quot;&gt;Numba故障排除页面&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6cf83492c2f7d9b62bbeb8e6388f30b8fbfed606" translate="yes" xml:space="preserve">
          <source>If Numba is passed a function that includes something it doesn&amp;rsquo;t know how to work with &amp;ndash; a category that currently includes sets, lists, dictionaries, or string functions &amp;ndash; it will revert to &lt;code&gt;object mode&lt;/code&gt;. In &lt;code&gt;object mode&lt;/code&gt;, Numba will execute but your code will not speed up significantly. If you would prefer that Numba throw an error if it cannot compile a function in a way that speeds up your code, pass Numba the argument &lt;code&gt;nopython=True&lt;/code&gt; (e.g. &lt;code&gt;@numba.jit(nopython=True)&lt;/code&gt;). For more on troubleshooting Numba modes, see the &lt;a href=&quot;https://numba.pydata.org/numba-doc/latest/user/troubleshoot.html#the-compiled-code-is-too-slow&quot;&gt;Numba troubleshooting page&lt;/a&gt;.</source>
          <target state="translated">如果Numba传递了一个函数，该函数包含一个不知道如何使用的函数（当前包含集合，列表，字典或字符串函数的类别），它将恢复为 &lt;code&gt;object mode&lt;/code&gt; 。在 &lt;code&gt;object mode&lt;/code&gt; ，Numba将执行，但是您的代码将不会显着加快速度。如果您希望Numba在无法以加速代码的方式编译函数时抛出错误，请向 &lt;code&gt;nopython=True&lt;/code&gt; 传递参数nopython = True（例如 &lt;code&gt;@numba.jit(nopython=True)&lt;/code&gt; ）。有关对Numba模式进行故障排除的更多信息，请参阅&lt;a href=&quot;https://numba.pydata.org/numba-doc/latest/user/troubleshoot.html#the-compiled-code-is-too-slow&quot;&gt;Numba故障排除页面&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="21738859f1a9792d732c95f50fc39e869d10cb29" translate="yes" xml:space="preserve">
          <source>If SQLAlchemy is not installed, a fallback is only provided for sqlite (and for mysql for backwards compatibility, but this is deprecated and will be removed in a future version). This mode requires a Python database adapter which respect the &lt;a href=&quot;https://www.python.org/dev/peps/pep-0249/&quot;&gt;Python DB-API&lt;/a&gt;.</source>
          <target state="translated">如果未安装SQLAlchemy，则仅为sqlite（以及向后兼容的mysql）提供回退功能，但已弃用该功能，并将在以后的版本中将其删除。此模式需要一个遵循&lt;a href=&quot;https://www.python.org/dev/peps/pep-0249/&quot;&gt;Python DB-API&lt;/a&gt;的Python数据库适配器。</target>
        </trans-unit>
        <trans-unit id="3c1f8f822f180177bfde53d3b1ec7bf4e05cab5e" translate="yes" xml:space="preserve">
          <source>If Timestamp convertible, origin is set to Timestamp identified by origin.</source>
          <target state="translated">如果时间戳可转换,则原点设置为由原点确定的时间戳。</target>
        </trans-unit>
        <trans-unit id="302ec23d134fa94295f5a5b21bbe57333cc5ba71" translate="yes" xml:space="preserve">
          <source>If Timestamp is tz-naive.</source>
          <target state="translated">如果时间戳是tz-naive。</target>
        </trans-unit>
        <trans-unit id="877daf2c60c584794d63f9ddbf4bb796256b13ee" translate="yes" xml:space="preserve">
          <source>If True (default) the description(s) will be printed to stdout. Otherwise, the description(s) will be returned as a unicode string (for testing).</source>
          <target state="translated">如果为真(默认),描述将被打印到stdout。否则,描述将以unicode字符串的形式返回(用于测试)。</target>
        </trans-unit>
        <trans-unit id="79279f7b5a78bfc09767977781bcb3e7ef19efbc" translate="yes" xml:space="preserve">
          <source>If True and</source>
          <target state="translated">如果真和</target>
        </trans-unit>
        <trans-unit id="6d916b7ecf5b34c978b87a1cac148ea4e85e0797" translate="yes" xml:space="preserve">
          <source>If True and &lt;code&gt;parse_dates&lt;/code&gt; is enabled, pandas will attempt to infer the format of the datetime strings in the columns, and if it can be inferred, switch to a faster method of parsing them. In some cases this can increase the parsing speed by 5-10x.</source>
          <target state="translated">如果启用True和 &lt;code&gt;parse_dates&lt;/code&gt; ，则pandas将尝试推断列中日期时间字符串的格式，如果可以推断出日期格式，请切换到解析它们的更快方法。在某些情况下，这可以使解析速度提高5-10倍。</target>
        </trans-unit>
        <trans-unit id="a6c1e57d23e26869dc0e2062acc23c857f4141f1" translate="yes" xml:space="preserve">
          <source>If True and &lt;code&gt;parse_dates&lt;/code&gt; specifies combining multiple columns then keep the original columns.</source>
          <target state="translated">如果True和 &lt;code&gt;parse_dates&lt;/code&gt; 指定合并多个列，则保留原始列。</target>
        </trans-unit>
        <trans-unit id="b1ba3921dc01d9fac0f5e6f97a8d6ec85f39852c" translate="yes" xml:space="preserve">
          <source>If True and no</source>
          <target state="translated">如果为真且无</target>
        </trans-unit>
        <trans-unit id="cdbd44edb95eb1919d0e70e68013314a95652069" translate="yes" xml:space="preserve">
          <source>If True and no &lt;code&gt;format&lt;/code&gt; is given, attempt to infer the format of the datetime strings, and if it can be inferred, switch to a faster method of parsing them. In some cases this can increase the parsing speed by ~5-10x.</source>
          <target state="translated">如果为True并且未给出 &lt;code&gt;format&lt;/code&gt; ，请尝试推断日期时间字符串的格式，如果可以推断出日期格式，则切换到更快的解析日期时间字符串的方法。在某些情况下，这可以使解析速度提高约5-10倍。</target>
        </trans-unit>
        <trans-unit id="05ce3205c3816ae877ac9af3cf60622cf6b06aa7" translate="yes" xml:space="preserve">
          <source>If True and sorting by level and index is multilevel, sort by other levels too (in order) after sorting by specified level.</source>
          <target state="translated">如果为True,且按级别和索引排序是多级排序,则在按指定级别排序后也按其他级别排序(按顺序)。</target>
        </trans-unit>
        <trans-unit id="c4da65c79c92e3c24cfc8f74ebd023389cdd2b17" translate="yes" xml:space="preserve">
          <source>If True parse dates in</source>
          <target state="translated">如果为真,解析日期为</target>
        </trans-unit>
        <trans-unit id="262d40ea87b315db865b2f76fe9cef275e5b9327" translate="yes" xml:space="preserve">
          <source>If True parse dates in &lt;code&gt;data&lt;/code&gt; with the year first order</source>
          <target state="translated">如果True解析日期在 &lt;code&gt;data&lt;/code&gt; 中的年份为第一位</target>
        </trans-unit>
        <trans-unit id="d875c9e78a8f10c4070a76617db0aea9c9581c5c" translate="yes" xml:space="preserve">
          <source>If True parses dates with the year first, eg 10/11/12 is parsed as 2010-11-12.</source>
          <target state="translated">如果True解析日期时先解析年份,例如10/11/12被解析为2010-11-12。</target>
        </trans-unit>
        <trans-unit id="bb627fc931d5d5697f56d7a0202d4eeb9eb2c217" translate="yes" xml:space="preserve">
          <source>If True returns a DatetimeIndex or Index-like object</source>
          <target state="translated">如果为真,返回一个DatetimeIndex或类似Index的对象。</target>
        </trans-unit>
        <trans-unit id="e55faf7a09074a6a866ad052dfba8d934e2a620c" translate="yes" xml:space="preserve">
          <source>If True returns a Timedelta/TimedeltaIndex of the results.</source>
          <target state="translated">如果为真,则返回结果的Timedelta/TimedeltaIndex。</target>
        </trans-unit>
        <trans-unit id="50b84049db5e2134804159a690e8517ba44f78e8" translate="yes" xml:space="preserve">
          <source>If True then default datelike columns may be converted (depending on keep_default_dates). If False, no dates will be converted. If a list of column names, then those columns will be converted and default datelike columns may also be converted (depending on keep_default_dates).</source>
          <target state="translated">如果为真,那么默认的日期列可能会被转换(取决于keep_default_dates)。如果为False,则不会转换日期。如果是列名列表,那么这些列将被转换,默认的日期型列也可能被转换(取决于keep_default_dates)。</target>
        </trans-unit>
        <trans-unit id="460a87b8b136bb4a2b3c54602f91c633b0e77bca" translate="yes" xml:space="preserve">
          <source>If True then the object returned will contain the relative frequencies of the unique values.</source>
          <target state="translated">如果True,那么返回的对象将包含唯一值的相对频率。</target>
        </trans-unit>
        <trans-unit id="2f6899875f0d289bc3d7921ca50f8266c60d0690" translate="yes" xml:space="preserve">
          <source>If True, adds a column to output DataFrame called &amp;ldquo;_merge&amp;rdquo; with information on the source of each row. If string, column with information on source of each row will be added to output DataFrame, and column will be named value of string. Information column is Categorical-type and takes on a value of &amp;ldquo;left_only&amp;rdquo; for observations whose merge key only appears in &amp;lsquo;left&amp;rsquo; DataFrame, &amp;ldquo;right_only&amp;rdquo; for observations whose merge key only appears in &amp;lsquo;right&amp;rsquo; DataFrame, and &amp;ldquo;both&amp;rdquo; if the observation&amp;rsquo;s merge key is found in both.</source>
          <target state="translated">如果为True，则在输出数据帧中添加一列，称为&amp;ldquo; _merge&amp;rdquo;，其中包含有关每一行源的信息。如果为字符串，则将在每一行的源上带有信息的列添加到输出DataFrame中，并且该列将被命名为字符串的值。信息列是分类类型的，对于其合并键仅出现在&amp;ldquo; left&amp;rdquo; DataFrame中的观测值，其值为&amp;ldquo; left_only&amp;rdquo;，对于其合并键仅出现在&amp;ldquo; right&amp;rdquo; DataFrame中的观测值，其值为&amp;ldquo; right_only&amp;rdquo;，如果两者中都存在观察值的合并键。</target>
        </trans-unit>
        <trans-unit id="f47a60165f80019a2aacb8f49d7ce550df20d9ae" translate="yes" xml:space="preserve">
          <source>If True, adds a column to the output DataFrame called &amp;ldquo;_merge&amp;rdquo; with information on the source of each row. The column can be given a different name by providing a string argument. The column will have a Categorical type with the value of &amp;ldquo;left_only&amp;rdquo; for observations whose merge key only appears in the left DataFrame, &amp;ldquo;right_only&amp;rdquo; for observations whose merge key only appears in the right DataFrame, and &amp;ldquo;both&amp;rdquo; if the observation&amp;rsquo;s merge key is found in both DataFrames.</source>
          <target state="translated">如果为True，则将一列添加到输出DataFrame中，称为&amp;ldquo; _merge&amp;rdquo;，其中包含有关每一行源的信息。通过提供字符串参数，可以为列指定其他名称。该列将具有分类类型，其合并键仅出现在左侧DataFrame中的观测值的值为&amp;ldquo; left_only&amp;rdquo;，其合并键仅出现在右侧DataFrame中的观测值的值为&amp;ldquo; right_only&amp;rdquo;，如果观察项的合并键的值为&amp;ldquo; both&amp;rdquo;在两个DataFrames中都可以找到。</target>
        </trans-unit>
        <trans-unit id="54a0d8d2165cdc25ae287fecadf2dc5419cb8c90" translate="yes" xml:space="preserve">
          <source>If True, allow matching with the same &amp;lsquo;on&amp;rsquo; value (i.e. less-than-or-equal-to / greater-than-or-equal-to)</source>
          <target state="translated">如果为True，则允许匹配相同的&amp;ldquo; on&amp;rdquo;值（即小于或等于/大于或等于）</target>
        </trans-unit>
        <trans-unit id="1954fe0d26126090114d61aee388af1ae86e3bf1" translate="yes" xml:space="preserve">
          <source>If True, and if group keys contain NA values, NA values together with row/column will be dropped. If False, NA values will also be treated as the key in groups</source>
          <target state="translated">如果为真,如果组键包含NA值,NA值和行/列将被删除。如果为False,NA值也将作为组中的键来处理。</target>
        </trans-unit>
        <trans-unit id="1d19895ec0d15a9331df9ff0f2a55c57a6a58746" translate="yes" xml:space="preserve">
          <source>If True, and if group keys contain NA values, NA values together with row/column will be dropped. If False, NA values will also be treated as the key in groups.</source>
          <target state="translated">如果为真,如果组键包含NA值,NA值和行/列将被删除。如果为False,NA值也将作为组中的键处理。</target>
        </trans-unit>
        <trans-unit id="4660645b9175a4b6c992d8f895126a90fe4a50a3" translate="yes" xml:space="preserve">
          <source>If True, assumes the passed-in pattern is a regular expression.</source>
          <target state="translated">如果为True,则假设传入的模式是一个正则表达式。</target>
        </trans-unit>
        <trans-unit id="1e74a09f271b28537768cc8961b39d335e31e6de" translate="yes" xml:space="preserve">
          <source>If True, assumes the pat is a regular expression.</source>
          <target state="translated">如果为True,假设pat是一个正则表达式。</target>
        </trans-unit>
        <trans-unit id="467512e132775d71f6afd4e58bafe55b86f48864" translate="yes" xml:space="preserve">
          <source>If True, boolean values can be plotted.</source>
          <target state="translated">如果为True,可以绘制布尔值。</target>
        </trans-unit>
        <trans-unit id="00f3e2f20afae1e95c8a12af9612d6d458bd5a5a" translate="yes" xml:space="preserve">
          <source>If True, case sensitive (the default if</source>
          <target state="translated">如果为True,则区分大小写(默认如果</target>
        </trans-unit>
        <trans-unit id="7fc051579ade2d30effac2d7f975b7af0eaf1117" translate="yes" xml:space="preserve">
          <source>If True, case sensitive (the default if &lt;code&gt;pat&lt;/code&gt; is a string)</source>
          <target state="translated">如果为True，则区分大小写（如果 &lt;code&gt;pat&lt;/code&gt; 是字符串，则为默认值）</target>
        </trans-unit>
        <trans-unit id="9f69db8a36129425d43c6f59fe632f1d4ad16ea5" translate="yes" xml:space="preserve">
          <source>If True, case sensitive.</source>
          <target state="translated">如果为真,则区分大小写。</target>
        </trans-unit>
        <trans-unit id="849117a9db8ed6e6e51890ffed8b4fd6a41700fb" translate="yes" xml:space="preserve">
          <source>If True, checks that levels and codes are compatible.</source>
          <target state="translated">如果为真,则检查级别和代码是否兼容。</target>
        </trans-unit>
        <trans-unit id="d154f805b1bfe50fc4462690ece065dd32c399b0" translate="yes" xml:space="preserve">
          <source>If True, columns in</source>
          <target state="translated">如果为真,在</target>
        </trans-unit>
        <trans-unit id="963a559726df468b6da10ccb14a21fec119cd396" translate="yes" xml:space="preserve">
          <source>If True, columns in &lt;code&gt;self&lt;/code&gt; that do not exist in &lt;code&gt;other&lt;/code&gt; will be overwritten with NaNs.</source>
          <target state="translated">如果为True，则 &lt;code&gt;self&lt;/code&gt; 中不存在于 &lt;code&gt;other&lt;/code&gt; 列中的列将被NaN覆盖。</target>
        </trans-unit>
        <trans-unit id="0072997ec6faf6f05624c4fd43f7c2c5957f60e6" translate="yes" xml:space="preserve">
          <source>If True, copy the underlying data.</source>
          <target state="translated">如果为真,则复制基础数据。</target>
        </trans-unit>
        <trans-unit id="3b1dcb5dd58fb08e7346d27ce52d23be1c63ae1c" translate="yes" xml:space="preserve">
          <source>If True, create stacked plot.</source>
          <target state="translated">如果为真,则创建叠加图。</target>
        </trans-unit>
        <trans-unit id="beef21df15134efbd5ef8eaa6cfbb8bd6ce0957e" translate="yes" xml:space="preserve">
          <source>If True, do not use the index labels.</source>
          <target state="translated">如果为真,则不使用索引标签。</target>
        </trans-unit>
        <trans-unit id="39eabebf10ef842b50bf2b46f976dd96a678bf6f" translate="yes" xml:space="preserve">
          <source>If True, do not use the index values along the concatenation axis. The resulting axis will be labeled 0, &amp;hellip;, n - 1. This is useful if you are concatenating objects where the concatenation axis does not have meaningful indexing information. Note the index values on the other axes are still respected in the join.</source>
          <target state="translated">如果为True，则不要沿串联轴使用索引值。结果轴将标记为0，&amp;hellip;，n-1。如果要串联对象时，串联轴没有有意义的索引信息，这将很有用。请注意，联接中仍会考虑其他轴上的索引值。</target>
        </trans-unit>
        <trans-unit id="2be78667d971f765edd09b5dcf231a83202213b7" translate="yes" xml:space="preserve">
          <source>If True, do operation inplace and return None.</source>
          <target state="translated">如果为True,进行原地操作,返回None。</target>
        </trans-unit>
        <trans-unit id="02a05fbc517d0938e12546e82b1fa2c67e2f36f4" translate="yes" xml:space="preserve">
          <source>If True, draw a table using the data in the DataFrame and the data will be transposed to meet matplotlib&amp;rsquo;s default layout. If a Series or DataFrame is passed, use passed data to draw a table.</source>
          <target state="translated">如果为True，则使用DataFrame中的数据绘制表格，数据将转置以满足matplotlib的默认布局。如果传递了Series或DataFrame，请使用传递的数据绘制表格。</target>
        </trans-unit>
        <trans-unit id="28b1d2c85f895aef12f78ff43875c24af96a30a5" translate="yes" xml:space="preserve">
          <source>If True, each cell will have an &lt;code&gt;id&lt;/code&gt; attribute in their HTML tag. The &lt;code&gt;id&lt;/code&gt; takes the form &lt;code&gt;T_&amp;lt;uuid&amp;gt;_row&amp;lt;num_row&amp;gt;_col&amp;lt;num_col&amp;gt;&lt;/code&gt; where &lt;code&gt;&amp;lt;uuid&amp;gt;&lt;/code&gt; is the unique identifier, &lt;code&gt;&amp;lt;num_row&amp;gt;&lt;/code&gt; is the row number and &lt;code&gt;&amp;lt;num_col&amp;gt;&lt;/code&gt; is the column number.</source>
          <target state="translated">如果为True，则每个单元格的HTML标记中将具有 &lt;code&gt;id&lt;/code&gt; 属性。的 &lt;code&gt;id&lt;/code&gt; 的形式为 &lt;code&gt;T_&amp;lt;uuid&amp;gt;_row&amp;lt;num_row&amp;gt;_col&amp;lt;num_col&amp;gt;&lt;/code&gt; 其中 &lt;code&gt;&amp;lt;uuid&amp;gt;&lt;/code&gt; 是唯一标识符 &lt;code&gt;&amp;lt;num_row&amp;gt;&lt;/code&gt; 是行数和 &lt;code&gt;&amp;lt;num_col&amp;gt;&lt;/code&gt; 是列号。</target>
        </trans-unit>
        <trans-unit id="c187de18efb1034db0f173b43d135203505eb0f2" translate="yes" xml:space="preserve">
          <source>If True, each whitespace character (as defined by string.whitespace) remaining after tab expansion will be replaced by a single space (default: True).</source>
          <target state="translated">如果为True,制表符扩展后剩余的每个空白字符(由string.whitespace定义)将被一个单一的空格取代(默认:True)。</target>
        </trans-unit>
        <trans-unit id="7bc41a15bead4034e53881eb90092ca96d9054c1" translate="yes" xml:space="preserve">
          <source>If True, fill in-place. Note: this will modify any other views on this object (e.g., a no-copy slice for a column in a DataFrame).</source>
          <target state="translated">如果为真,则就地填充。注意:这将修改此对象上的任何其他视图(例如,DataFrame中的一列的无复制切片)。</target>
        </trans-unit>
        <trans-unit id="779f470c819fe4b8c76c9ffe041585b2a57ed854" translate="yes" xml:space="preserve">
          <source>If True, ignore the order of index &amp;amp; columns. Note: index labels must match their respective rows (same as in columns) - same labels must be with the same data.</source>
          <target state="translated">如果为True，则忽略索引和列的顺序。注意：索引标签必须与它们各自的行匹配（与列中的相同）-相同的标签必须具有相同的数据。</target>
        </trans-unit>
        <trans-unit id="c1fb42cadb1475602cce6ec757150306fd56fb02" translate="yes" xml:space="preserve">
          <source>If True, in place. Note: this will modify any other views on this object (e.g. a column from a DataFrame). Returns the caller if this is True.</source>
          <target state="translated">如果为True,则为到位。注意:这将会修改这个对象上的任何其他视图(例如来自DataFrame的列)。如果为True,返回调用者。</target>
        </trans-unit>
        <trans-unit id="7f32cc95594d1282134f1d68f351ad29dfeba40d" translate="yes" xml:space="preserve">
          <source>If True, infer dtypes; if a dict of column to dtype, then use those; if False, then don&amp;rsquo;t infer dtypes at all, applies only to the data.</source>
          <target state="translated">如果为True，则推断dtypes；否则为false。如果将列的字典指定为dtype，则使用这些字典；如果为False，则根本不推断dtype，仅适用于数据。</target>
        </trans-unit>
        <trans-unit id="7997ecfa519f0e9d11e8ccfaf5aa7070e2ac85d4" translate="yes" xml:space="preserve">
          <source>If True, introspect the data deeply by interrogating</source>
          <target state="translated">如果为真,通过审视数据深入反省</target>
        </trans-unit>
        <trans-unit id="28a638dbfeb78f983bc652085d7b9c8a2d0bd1c8" translate="yes" xml:space="preserve">
          <source>If True, introspect the data deeply by interrogating &lt;code&gt;object&lt;/code&gt; dtypes for system-level memory consumption, and include it in the returned value.</source>
          <target state="translated">如果为True，则通过查询 &lt;code&gt;object&lt;/code&gt; dtypes以了解系统级内存消耗来深入检查数据，并将其包含在返回值中。</target>
        </trans-unit>
        <trans-unit id="11c935c8f1af11c12f350eee790d77bcc513b2a8" translate="yes" xml:space="preserve">
          <source>If True, introspect the data deeply by interrogating &lt;code&gt;object&lt;/code&gt; dtypes for system-level memory consumption, and include it in the returned values.</source>
          <target state="translated">如果为True，则通过查询 &lt;code&gt;object&lt;/code&gt; dtypes来深入了解数据的系统级内存消耗，并将其包含在返回值中。</target>
        </trans-unit>
        <trans-unit id="c8196976ac650ceea0e3a5f6ce68de3af78ca762" translate="yes" xml:space="preserve">
          <source>If True, modifies the DataFrame in place (do not create a new object).</source>
          <target state="translated">如果为True,则在原地修改DataFrame(不要创建新对象)。</target>
        </trans-unit>
        <trans-unit id="75f616449e447dd01e651b655bec89b32f9f161a" translate="yes" xml:space="preserve">
          <source>If True, mutates in place.</source>
          <target state="translated">如果为真,就地突变。</target>
        </trans-unit>
        <trans-unit id="e79427f24ce68d71e994b467383dc8a5a268616c" translate="yes" xml:space="preserve">
          <source>If True, only apply to numeric columns.</source>
          <target state="translated">如果为真,只适用于数字列。</target>
        </trans-unit>
        <trans-unit id="35ec09831bdd6b8649e000f3fff40e0f896b2493" translate="yes" xml:space="preserve">
          <source>If True, original index is ignored. If False, the original index is retained. Index labels will be repeated as necessary.</source>
          <target state="translated">如果为真,则忽略原始索引。如果为False,则保留原始索引。索引标签将根据需要重复使用。</target>
        </trans-unit>
        <trans-unit id="7ead6d9026e6e44fe03446f442da04f5bbd5558f" translate="yes" xml:space="preserve">
          <source>If True, outputs info in JSON format to the console.</source>
          <target state="translated">如果为True,以JSON格式输出信息到控制台。</target>
        </trans-unit>
        <trans-unit id="b35ba5920ddefac79cf35ea89415ec6c3aaa7827" translate="yes" xml:space="preserve">
          <source>If True, parse dates in</source>
          <target state="translated">如果为True,将日期解析为</target>
        </trans-unit>
        <trans-unit id="12c714b402a0f7d59a93c0a1d85e385c49190143" translate="yes" xml:space="preserve">
          <source>If True, parse dates in &lt;code&gt;data&lt;/code&gt; with the day first order</source>
          <target state="translated">如果为True，则以第一天的顺序解析 &lt;code&gt;data&lt;/code&gt; 中的日期</target>
        </trans-unit>
        <trans-unit id="11a6adfd18dc986d6ff6528d42e29ae888e6d526" translate="yes" xml:space="preserve">
          <source>If True, perform operation in-place.</source>
          <target state="translated">如果为真,则在原地进行操作。</target>
        </trans-unit>
        <trans-unit id="52083255d0c1625b5421b918b643ad39c3d91f57" translate="yes" xml:space="preserve">
          <source>If True, plot colorbar (only relevant for &amp;lsquo;scatter&amp;rsquo; and &amp;lsquo;hexbin&amp;rsquo; plots).</source>
          <target state="translated">如果为True，则绘制颜色条（仅与&amp;ldquo;散布&amp;rdquo;图和&amp;ldquo;六边形&amp;rdquo;图有关）。</target>
        </trans-unit>
        <trans-unit id="7b35ea2160939c711232caacbe9ffc59471f5f6b" translate="yes" xml:space="preserve">
          <source>If True, prefix records with dotted (?) path, e.g. foo.bar.field if meta is [&amp;lsquo;foo&amp;rsquo;, &amp;lsquo;bar&amp;rsquo;].</source>
          <target state="translated">如果为True，则前缀记录带有点缀（？）路径，例如，如果meta为['foo'，'bar']，则为foo.bar.field。</target>
        </trans-unit>
        <trans-unit id="918691faec44a66f1b1c5ddaf68832370f5563d0" translate="yes" xml:space="preserve">
          <source>If True, prefix records with dotted (?) path, e.g. foo.bar.field if path to records is [&amp;lsquo;foo&amp;rsquo;, &amp;lsquo;bar&amp;rsquo;].</source>
          <target state="translated">如果为True，则以点（？）路径为记录的前缀，例如，如果记录的路径为['foo'，'bar']，则为foo.bar.field。</target>
        </trans-unit>
        <trans-unit id="1b787f2412a9a56f4f2d0a2789a8e490bc7bd97a" translate="yes" xml:space="preserve">
          <source>If True, raise Exception on creating index with duplicates.</source>
          <target state="translated">如果为真,在创建有重复的索引时引发异常。</target>
        </trans-unit>
        <trans-unit id="f92c7eaff72b81ab6a7f6f3c046d665142253fca" translate="yes" xml:space="preserve">
          <source>If True, raise ValueError on creating index with duplicates.</source>
          <target state="translated">如果为True,在创建有重复的索引时引发ValueError。</target>
        </trans-unit>
        <trans-unit id="65688aa40ea915fb917db04985ab684fb4b0d10f" translate="yes" xml:space="preserve">
          <source>If True, require an exact format match.</source>
          <target state="translated">如果为真,要求格式完全匹配。</target>
        </trans-unit>
        <trans-unit id="a51ee754f13842cc1c7503238049ba90f6317028" translate="yes" xml:space="preserve">
          <source>If True, return DataFrame with one column per capture group. If False, return a Series/Index if there is one capture group or DataFrame if there are multiple capture groups.</source>
          <target state="translated">如果为True,则返回每个捕获组有一列的DataFrame,如果为False,则返回一个Series/Index,如果有多个捕获组,则返回DataFrame。如果为False,如果有一个捕获组,则返回Series/Index,如果有多个捕获组,则返回DataFrame。</target>
        </trans-unit>
        <trans-unit id="752a06fc414514adb4cbae9fe15c30471375abcf" translate="yes" xml:space="preserve">
          <source>If True, return DataFrame/MultiIndex expanding dimensionality. If False, return Series/Index.</source>
          <target state="translated">如果为真,返回DataFrame/MultiIndex扩维。如果False,返回Series/Index。</target>
        </trans-unit>
        <trans-unit id="fceb9f4dd2f49705ce97835f6760fabf3db79d64" translate="yes" xml:space="preserve">
          <source>If True, return the index as the first element of the tuple.</source>
          <target state="translated">如果True,返回索引作为元组的第一个元素。</target>
        </trans-unit>
        <trans-unit id="db6a2a7946d7a74ee079d7db1cd5033117192d16" translate="yes" xml:space="preserve">
          <source>If True, returns an iterator for reading the file incrementally.</source>
          <target state="translated">如果为True,返回一个迭代器,用于递增读取文件。</target>
        </trans-unit>
        <trans-unit id="8e9f098b0cebf828eaf4b7145977c959411d29fa" translate="yes" xml:space="preserve">
          <source>If True, skip NaN values.</source>
          <target state="translated">如果为真,则跳过NaN值。</target>
        </trans-unit>
        <trans-unit id="2c7785df59be40ed32a0a30ad986c482f4b9104c" translate="yes" xml:space="preserve">
          <source>If True, skip over blank lines rather than interpreting as NaN values.</source>
          <target state="translated">如果为真,则跳过空行,而不是解释为NaN值。</target>
        </trans-unit>
        <trans-unit id="45dc4286e28963ebfaf419f2ca82e19caa47ad55" translate="yes" xml:space="preserve">
          <source>If True, sort values in ascending order, otherwise descending.</source>
          <target state="translated">如果为真,则按升序排序,否则按降序排序。</target>
        </trans-unit>
        <trans-unit id="b4c0dbb1de303429c5f1585939b0e85294386572" translate="yes" xml:space="preserve">
          <source>If True, tab characters will be expanded to spaces (default: True).</source>
          <target state="translated">如果为 &quot;True&quot;,制表符将被扩展到空格(默认:True)。</target>
        </trans-unit>
        <trans-unit id="f9b43baf827304c498c502484b0f8be2d39c6d28" translate="yes" xml:space="preserve">
          <source>If True, the resulting axis will be labeled 0, 1, &amp;hellip;, n - 1.</source>
          <target state="translated">如果为True，则结果轴将标记为0、1，...，n-1。</target>
        </trans-unit>
        <trans-unit id="b0d21f7b111187cb1a3ffe644e0758fb4ee939e9" translate="yes" xml:space="preserve">
          <source>If True, the resulting index will be labeled 0, 1, &amp;hellip;, n - 1.</source>
          <target state="translated">如果为True，则结果索引将标记为0、1，...，n-1。</target>
        </trans-unit>
        <trans-unit id="c4133671064687e871d2078ebf94e5b70a1263d8" translate="yes" xml:space="preserve">
          <source>If True, the underlying data is copied. Otherwise (default), no copy is made if possible.</source>
          <target state="translated">如果为True,则复制底层数据,否则(默认),尽可能不复制。否则(默认),尽可能不复制。</target>
        </trans-unit>
        <trans-unit id="fdead9bb7da05f8a6a1234e7274e5a9b654351b0" translate="yes" xml:space="preserve">
          <source>If True, then words longer than width will be broken in order to ensure that no lines are longer than width. If it is false, long words will not be broken, and some lines may be longer than width (default: True).</source>
          <target state="translated">如果为True,那么超过宽度的字将被打断,以确保没有行长超过宽度。如果为false,则长的字不会被打断,一些行可能会比宽度长(默认:True)。</target>
        </trans-unit>
        <trans-unit id="96caf78b1c5986e9400372061306220c9af20aa7" translate="yes" xml:space="preserve">
          <source>If True, use a cache of unique, converted dates to apply the datetime conversion. May produce significant speed-up when parsing duplicate date strings, especially ones with timezone offsets.</source>
          <target state="translated">如果为True,使用唯一的、转换过的日期缓存来应用日期时间转换。当解析重复的日期字符串时,可能会产生显著的速度,特别是那些有时区偏移的字符串。</target>
        </trans-unit>
        <trans-unit id="850369ac77e896e440c30d1b4a94fb2f6cbfc17a" translate="yes" xml:space="preserve">
          <source>If True, use a cache of unique, converted dates to apply the datetime conversion. May produce significant speed-up when parsing duplicate date strings, especially ones with timezone offsets. The cache is only used when there are at least 50 values. The presence of out-of-bounds values will render the cache unusable and may slow down parsing.</source>
          <target state="translated">如果为True,使用唯一的、转换过的日期缓存来应用日期时间转换。当解析重复的日期字符串时,可能会产生显著的速度,特别是那些有时区偏移的日期。缓存只在至少有50个值时使用。如果存在越界值,缓存将无法使用,并可能减慢解析速度。</target>
        </trans-unit>
        <trans-unit id="6cbf45354c267296e53e87ec9ae9077df026352c" translate="yes" xml:space="preserve">
          <source>If True, use dtypes that use &lt;code&gt;pd.NA&lt;/code&gt; as missing value indicator for the resulting DataFrame (only applicable for &lt;code&gt;engine=&quot;pyarrow&quot;&lt;/code&gt;). As new dtypes are added that support &lt;code&gt;pd.NA&lt;/code&gt; in the future, the output with this option will change to use those dtypes. Note: this is an experimental option, and behaviour (e.g. additional support dtypes) may change without notice.</source>
          <target state="translated">如果为True，则使用将 &lt;code&gt;pd.NA&lt;/code&gt; 用作结果DataFrame的缺失值指示符的dtypes（仅适用于 &lt;code&gt;engine=&quot;pyarrow&quot;&lt;/code&gt; ）。随着将来添加支持 &lt;code&gt;pd.NA&lt;/code&gt; 新dtypes ，带有此选项的输出将更改为使用这些dtypes。注意：这是一个实验选项，行为（例如，其他支持dtypes）可能会更改，恕不另行通知。</target>
        </trans-unit>
        <trans-unit id="edc5966567744c9deec0817e54ad119ae9eb8051" translate="yes" xml:space="preserve">
          <source>If True, whitespace that, after wrapping, happens to end up at the beginning or end of a line is dropped (default: True).</source>
          <target state="translated">如果为True,则会删除包装后恰好位于行首或行尾的空白字符(默认:True)。</target>
        </trans-unit>
        <trans-unit id="af63c1972ac9e275096f086bf4dbabfd22a77fc3" translate="yes" xml:space="preserve">
          <source>If True, wrapping will occur preferably on whitespace and right after hyphens in compound words, as it is customary in English. If false, only whitespaces will be considered as potentially good places for line breaks, but you need to set break_long_words to false if you want truly insecable words (default: True).</source>
          <target state="translated">如果为True,包装将最好发生在空白处和复合词的连字符之后,这在英语中是习惯的。如果为false,只有whitespaces会被认为是潜在的好的换行位置,但是如果你想要真正不安全的单词,你需要将break_long_words设置为false(默认:True)。</target>
        </trans-unit>
        <trans-unit id="562d6a085d036935dc458e97eb2b83b32b781d44" translate="yes" xml:space="preserve">
          <source>If a</source>
          <target state="translated">如果一个</target>
        </trans-unit>
        <trans-unit id="60a23d3725070e24cb533dd92a64738f0efc9eeb" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;DataFrame&lt;/code&gt; does not have a datetimelike index, but instead you want to resample based on datetimelike column in the frame, it can passed to the &lt;code&gt;on&lt;/code&gt; keyword.</source>
          <target state="translated">如果 &lt;code&gt;DataFrame&lt;/code&gt; 没有datetimelike索引，但是您想根据框架中的datetimelike列进行重新采样，则可以将其传递给 &lt;code&gt;on&lt;/code&gt; 关键字。</target>
        </trans-unit>
        <trans-unit id="b671a6d1db2b1bde6a5afb6d8028d31c59543e99" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;dict&lt;/code&gt; is used, all unmapped categories are mapped to &lt;code&gt;NaN&lt;/code&gt; and the result is an &lt;a href=&quot;pandas.index#pandas.Index&quot;&gt;&lt;code&gt;Index&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">如果使用 &lt;code&gt;dict&lt;/code&gt; ，则所有未映射的类别都将映射到 &lt;code&gt;NaN&lt;/code&gt; ，结果是&lt;a href=&quot;pandas.index#pandas.Index&quot;&gt; &lt;code&gt;Index&lt;/code&gt; &lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="3fc417177302a9cebffe9152263446b535b47d84" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;dict&lt;/code&gt; or &lt;a href=&quot;pandas.series#pandas.Series&quot;&gt;&lt;code&gt;Series&lt;/code&gt;&lt;/a&gt; is used any unmapped category is mapped to &lt;code&gt;NaN&lt;/code&gt;. Note that if this happens an &lt;a href=&quot;pandas.index#pandas.Index&quot;&gt;&lt;code&gt;Index&lt;/code&gt;&lt;/a&gt; will be returned.</source>
          <target state="translated">如果使用 &lt;code&gt;dict&lt;/code&gt; 或&lt;a href=&quot;pandas.series#pandas.Series&quot;&gt; &lt;code&gt;Series&lt;/code&gt; ,&lt;/a&gt;则任何未映射的类别都将映射到 &lt;code&gt;NaN&lt;/code&gt; 。请注意，如果发生这种情况，将返回&lt;a href=&quot;pandas.index#pandas.Index&quot;&gt; &lt;code&gt;Index&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5a13d756489055d99c339c198cd08b153d3f1acb" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;list&lt;/code&gt; or an &lt;code&gt;ndarray&lt;/code&gt; is passed to</source>
          <target state="translated">如果将 &lt;code&gt;list&lt;/code&gt; 或 &lt;code&gt;ndarray&lt;/code&gt; 传递给</target>
        </trans-unit>
        <trans-unit id="4cbad76c3179a700e058557a45022426a6d90e9b" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;list&lt;/code&gt; or an &lt;code&gt;ndarray&lt;/code&gt; is passed to &lt;code&gt;to_replace&lt;/code&gt; and &lt;code&gt;value&lt;/code&gt; but they are not the same length.</source>
          <target state="translated">如果将 &lt;code&gt;list&lt;/code&gt; 或 &lt;code&gt;ndarray&lt;/code&gt; 传递给 &lt;code&gt;to_replace&lt;/code&gt; 和 &lt;code&gt;value&lt;/code&gt; ,但它们的长度不相同。</target>
        </trans-unit>
        <trans-unit id="0839be279acdfe99dee443052560f05d4bdcf1b9" translate="yes" xml:space="preserve">
          <source>If a BaseIndexer subclass is passed, calculates the window boundaries based on the defined &lt;code&gt;get_window_bounds&lt;/code&gt; method. Additional rolling keyword arguments, namely</source>
          <target state="translated">如果传递了BaseIndexer子类，则根据定义的 &lt;code&gt;get_window_bounds&lt;/code&gt; 方法计算窗口边界。其他滚动关键字参数，即</target>
        </trans-unit>
        <trans-unit id="22fc0dda91ce0c6cfb03015af03fb9aeb3abddac" translate="yes" xml:space="preserve">
          <source>If a DataFrame column label is a valid Python variable name, the column can be accessed like an attribute:</source>
          <target state="translated">如果DataFrame列标签是一个有效的Python变量名,那么该列可以像属性一样被访问。</target>
        </trans-unit>
        <trans-unit id="8ecaf8e0ca6ae047a74668fa9ea2d262449f1084" translate="yes" xml:space="preserve">
          <source>If a DataFrame contains homogeneously-typed data, the ndarray can actually be modified in-place, and the changes will be reflected in the data structure. For heterogeneous data (e.g. some of the DataFrame&amp;rsquo;s columns are not all the same dtype), this will not be the case. The values attribute itself, unlike the axis labels, cannot be assigned to.</source>
          <target state="translated">如果DataFrame包含同类型的数据，则ndarray实际上可以就地进行修改，并且更改将反映在数据结构中。对于异构数据（例如，某些DataFrame的列并非都具有相同的dtype），情况并非如此。与轴标签不同，不能将values属性本身分配给。</target>
        </trans-unit>
        <trans-unit id="5059a3623e6ca9dc7f9b266d2608545843106902" translate="yes" xml:space="preserve">
          <source>If a class cannot be constructed from this &amp;lsquo;string&amp;rsquo;.</source>
          <target state="translated">如果无法从此&amp;ldquo;字符串&amp;rdquo;构造类。</target>
        </trans-unit>
        <trans-unit id="f9cedd3dcea3a4e2001323d4fb82c0c2fdae21be" translate="yes" xml:space="preserve">
          <source>If a column or index cannot be represented as an array of datetimes, say because of an unparsable value or a mixture of timezones, the column or index will be returned unaltered as an object data type. For non-standard datetime parsing, use &lt;code&gt;pd.to_datetime&lt;/code&gt; after &lt;code&gt;pd.read_csv&lt;/code&gt;. To parse an index or column with a mixture of timezones, specify &lt;code&gt;date_parser&lt;/code&gt; to be a partially-applied &lt;a href=&quot;pandas.to_datetime#pandas.to_datetime&quot;&gt;&lt;code&gt;pandas.to_datetime()&lt;/code&gt;&lt;/a&gt; with &lt;code&gt;utc=True&lt;/code&gt;. See &lt;a href=&quot;../../user_guide/io#io-csv-mixed-timezones&quot;&gt;Parsing a CSV with mixed timezones&lt;/a&gt; for more.</source>
          <target state="translated">如果无法将列或索引表示为日期时间数组，例如由于不可解析的值或时区的混合，则将按原样返回该列或索引作为对象数据类型。对于非标准日期时间解析， &lt;code&gt;pd.to_datetime&lt;/code&gt; 在 &lt;code&gt;pd.read_csv&lt;/code&gt; 之后使用pd.to_datetime。要解析时区混合的索引或列，请指定 &lt;code&gt;date_parser&lt;/code&gt; 为部分应用的&lt;a href=&quot;pandas.to_datetime#pandas.to_datetime&quot;&gt; &lt;code&gt;pandas.to_datetime()&lt;/code&gt; ,&lt;/a&gt;并带有 &lt;code&gt;utc=True&lt;/code&gt; 。有关更多信息，请参见&lt;a href=&quot;../../user_guide/io#io-csv-mixed-timezones&quot;&gt;解析具有混合时区的CSV&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c8c5f0454c9ec1fde1714f17e1d952b9f7a5cc52" translate="yes" xml:space="preserve">
          <source>If a column or index cannot be represented as an array of datetimes, say because of an unparseable value or a mixture of timezones, the column or index will be returned unaltered as an object data type. For non-standard datetime parsing, use &lt;code&gt;pd.to_datetime&lt;/code&gt; after &lt;code&gt;pd.read_csv&lt;/code&gt;. To parse an index or column with a mixture of timezones, specify &lt;code&gt;date_parser&lt;/code&gt; to be a partially-applied &lt;a href=&quot;pandas.to_datetime#pandas.to_datetime&quot;&gt;&lt;code&gt;pandas.to_datetime()&lt;/code&gt;&lt;/a&gt; with &lt;code&gt;utc=True&lt;/code&gt;. See &lt;a href=&quot;../../user_guide/io#io-csv-mixed-timezones&quot;&gt;Parsing a CSV with mixed timezones&lt;/a&gt; for more.</source>
          <target state="translated">如果列或索引不能表示为日期时间数组（例如，由于不可解析的值或时区的混合），则将按原样返回该列或索引作为对象数据类型。对于非标准日期时间解析， &lt;code&gt;pd.to_datetime&lt;/code&gt; 在 &lt;code&gt;pd.read_csv&lt;/code&gt; 之后使用pd.to_datetime。要解析时区混合的索引或列，请指定 &lt;code&gt;date_parser&lt;/code&gt; 为部分应用的&lt;a href=&quot;pandas.to_datetime#pandas.to_datetime&quot;&gt; &lt;code&gt;pandas.to_datetime()&lt;/code&gt; ,&lt;/a&gt;并带有 &lt;code&gt;utc=True&lt;/code&gt; 。有关更多信息，请参见&lt;a href=&quot;../../user_guide/io#io-csv-mixed-timezones&quot;&gt;解析具有混合时区的CSV&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="cb05dbd1a0c1f92f0ac524caef14f441578726d7" translate="yes" xml:space="preserve">
          <source>If a column or index contains an unparsable date, the entire column or index will be returned unaltered as an object data type. For non-standard datetime parsing, use &lt;a href=&quot;../reference/api/pandas.to_datetime#pandas.to_datetime&quot;&gt;&lt;code&gt;to_datetime()&lt;/code&gt;&lt;/a&gt; after &lt;code&gt;pd.read_csv&lt;/code&gt;.</source>
          <target state="translated">如果列或索引包含不可解析的日期，则整个列或索引将以不变的形式作为对象数据类型返回。对于非标准日期时间解析，请在 &lt;code&gt;pd.read_csv&lt;/code&gt; 之后使用&lt;a href=&quot;../reference/api/pandas.to_datetime#pandas.to_datetime&quot;&gt; &lt;code&gt;to_datetime()&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="024994997113b185624470243df16f27242d166f" translate="yes" xml:space="preserve">
          <source>If a column or index contains an unparseable date, the entire column or index will be returned unaltered as an object data type. For non-standard datetime parsing, use &lt;code&gt;pd.to_datetime&lt;/code&gt; after &lt;code&gt;pd.read_excel&lt;/code&gt;.</source>
          <target state="translated">如果列或索引包含不可解析的日期，则整个列或索引将保留原样作为对象数据类型返回。对于非标准日期时间解析， &lt;code&gt;pd.to_datetime&lt;/code&gt; 在 &lt;code&gt;pd.read_excel&lt;/code&gt; 之后使用pd.to_datetime。</target>
        </trans-unit>
        <trans-unit id="4e3d1c1348b7e96001002741ab684587a40cbd98" translate="yes" xml:space="preserve">
          <source>If a column or index contains an unparseable date, the entire column or index will be returned unaltered as an object data type. If you don`t want to parse some cells as date just change their type in Excel to &amp;ldquo;Text&amp;rdquo;. For non-standard datetime parsing, use &lt;code&gt;pd.to_datetime&lt;/code&gt; after &lt;code&gt;pd.read_excel&lt;/code&gt;.</source>
          <target state="translated">如果列或索引包含不可解析的日期，则整个列或索引将保留原样作为对象数据类型返回。如果您不想将某些单元格解析为日期，只需在Excel中将其类型更改为&amp;ldquo;文本&amp;rdquo;即可。对于非标准日期时间解析， &lt;code&gt;pd.to_datetime&lt;/code&gt; 在 &lt;code&gt;pd.read_excel&lt;/code&gt; 之后使用pd.to_datetime。</target>
        </trans-unit>
        <trans-unit id="7d2a0936634decaa45bcdb1077adb50caa2399d8" translate="yes" xml:space="preserve">
          <source>If a date does not meet the &lt;a href=&quot;http://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html#timeseries-timestamp-limits&quot;&gt;timestamp limitations&lt;/a&gt;, passing errors=&amp;rsquo;ignore&amp;rsquo; will return the original input instead of raising any exception.</source>
          <target state="translated">如果日期不符合&lt;a href=&quot;http://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html#timeseries-timestamp-limits&quot;&gt;时间戳限制&lt;/a&gt;，则传递errors ='ignore'将返回原始输入，而不引发任何异常。</target>
        </trans-unit>
        <trans-unit id="26d1dfa4eb8f3f636141624b253418278cce2bf6" translate="yes" xml:space="preserve">
          <source>If a date does not meet the &lt;a href=&quot;https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html#timeseries-timestamp-limits&quot;&gt;timestamp limitations&lt;/a&gt;, passing errors=&amp;rsquo;ignore&amp;rsquo; will return the original input instead of raising any exception.</source>
          <target state="translated">如果日期不符合&lt;a href=&quot;https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html#timeseries-timestamp-limits&quot;&gt;时间戳限制&lt;/a&gt;，则传递errors ='ignore'将返回原始输入，而不引发任何异常。</target>
        </trans-unit>
        <trans-unit id="78077d7035e3e1bf386c562ad6a6026d3c197e60" translate="yes" xml:space="preserve">
          <source>If a date is not on a valid date, the rollback and rollforward methods can be used to roll the date to the nearest valid date before/after the date.</source>
          <target state="translated">如果一个日期不在有效日期上,可以使用回滚和向前滚动方法将日期滚动到该日期前/后最近的有效日期。</target>
        </trans-unit>
        <trans-unit id="8d1bab9d594a6b54ccef73be2232f54e1cae5a4c" translate="yes" xml:space="preserve">
          <source>If a dict is passed, the sorted keys will be used as the &lt;code&gt;keys&lt;/code&gt; argument, unless it is passed, in which case the values will be selected (see below). Any None objects will be dropped silently unless they are all None in which case a ValueError will be raised.</source>
          <target state="translated">如果传递了dict ，则除非传递了已排序的 &lt;code&gt;keys&lt;/code&gt; ，否则它将用作keys参数，在这种情况下，将选择值（请参见下文）。除非所有对象都为None，否则所有None对象都将被静默删除，在这种情况下将引发ValueError。</target>
        </trans-unit>
        <trans-unit id="c64f440bc1e2f9dad75b50704b6ed07e14d9e40e" translate="yes" xml:space="preserve">
          <source>If a dtype is not specified, &lt;code&gt;data&lt;/code&gt; is passed through to &lt;code&gt;numpy.array()&lt;/code&gt;, and a &lt;a href=&quot;pandas.arrays.pandasarray#pandas.arrays.PandasArray&quot;&gt;&lt;code&gt;arrays.PandasArray&lt;/code&gt;&lt;/a&gt; is returned.</source>
          <target state="translated">如果未指定 &lt;code&gt;numpy.array()&lt;/code&gt; ，则 &lt;code&gt;data&lt;/code&gt; 将传递到numpy.array（），并返回一个&lt;a href=&quot;pandas.arrays.pandasarray#pandas.arrays.PandasArray&quot;&gt; &lt;code&gt;arrays.PandasArray&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6a750fe1b1c8b035fa42fb2c24abeccf5e0da7e3" translate="yes" xml:space="preserve">
          <source>If a dtype is not specified, pandas will infer the best dtype from the values. See the description of</source>
          <target state="translated">如果没有指定dtype,pandas将从这些值中推断出最佳的dtype。参见</target>
        </trans-unit>
        <trans-unit id="d9fe46615783e09d1c274ff3a49d146beb787260" translate="yes" xml:space="preserve">
          <source>If a file has one more column of data than the number of column names, the first column will be used as the &lt;code&gt;DataFrame&lt;/code&gt;&amp;rsquo;s row names:</source>
          <target state="translated">如果文件的数据列比列名的数量多，则第一列将用作 &lt;code&gt;DataFrame&lt;/code&gt; 的行名：</target>
        </trans-unit>
        <trans-unit id="4a7d71bcc1d2c6a1d61b732ec612b9df1bce2c33" translate="yes" xml:space="preserve">
          <source>If a filepath is provided for</source>
          <target state="translated">如果为</target>
        </trans-unit>
        <trans-unit id="a4a6eb6c7d1e4657646b6302b848a8747082bbc0" translate="yes" xml:space="preserve">
          <source>If a filepath is provided for &lt;code&gt;filepath_or_buffer&lt;/code&gt;, map the file object directly onto memory and access the data directly from there. Using this option can improve performance because there is no longer any I/O overhead.</source>
          <target state="translated">如果为filepath_or_buffer提供了文件 &lt;code&gt;filepath_or_buffer&lt;/code&gt; ，则将文件对象直接映射到内存中并直接从那里访问数据。使用此选项可以提高性能，因为不再有任何I / O开销。</target>
        </trans-unit>
        <trans-unit id="f5b0e7c1c6bb842c26a2ad6521207d7b659ebca7" translate="yes" xml:space="preserve">
          <source>If a function with the same arguments as the one being deprecated exist, you can use the &lt;code&gt;pandas.util._decorators.deprecate&lt;/code&gt;:</source>
          <target state="translated">如果存在与不赞成使用的参数相同的函数，则可以使用 &lt;code&gt;pandas.util._decorators.deprecate&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="7a55f5c7d16f500e6da16614d2adb42965248f34" translate="yes" xml:space="preserve">
          <source>If a label is in several intervals, you get the locations of all the relevant intervals.</source>
          <target state="translated">如果一个标签在几个区间内,你会得到所有相关区间的位置。</target>
        </trans-unit>
        <trans-unit id="4f47b003de0809072edf3c049a0ce30a21e507fa" translate="yes" xml:space="preserve">
          <source>If a label is not contained, an exception is raised:</source>
          <target state="translated">如果没有包含标签,就会引发异常。</target>
        </trans-unit>
        <trans-unit id="f0da20aab515eb31a5cffcf23bf1728563e5abe6" translate="yes" xml:space="preserve">
          <source>If a list of dict/series is passed and the keys are all contained in the DataFrame&amp;rsquo;s index, the order of the columns in the resulting DataFrame will be unchanged.</source>
          <target state="translated">如果传递了dict / series列表，并且键都包含在DataFrame的索引中，则结果DataFrame中列的顺序将保持不变。</target>
        </trans-unit>
        <trans-unit id="c2084be9d8e5985ceb2c1bbb180f91068c44c3ca" translate="yes" xml:space="preserve">
          <source>If a list/tuple of expressions is passed they will be combined via &lt;code&gt;&amp;amp;&lt;/code&gt;</source>
          <target state="translated">如果传递了一个表达式列表/元组，它们将通过 &lt;code&gt;&amp;amp;&lt;/code&gt; 组合</target>
        </trans-unit>
        <trans-unit id="e233f630f6e64777b8004e8848b98a69ced310c3" translate="yes" xml:space="preserve">
          <source>If a mapping is passed, the sorted keys will be used as the</source>
          <target state="translated">如果传递了一个映射,排序后的键将被用作</target>
        </trans-unit>
        <trans-unit id="a57b14a0144398613fa46db6a643212d87f9fab6" translate="yes" xml:space="preserve">
          <source>If a non-default &lt;code&gt;orient&lt;/code&gt; was used when encoding to JSON be sure to pass the same option here so that decoding produces sensible results, see &lt;a href=&quot;#orient-options&quot;&gt;Orient Options&lt;/a&gt; for an overview.</source>
          <target state="translated">如果非默认的 &lt;code&gt;orient&lt;/code&gt; 编码到JSON当使用一定要经过同样的选项，使这里的解码产生有意义的结果，看到&lt;a href=&quot;#orient-options&quot;&gt;东方选项&lt;/a&gt;的概述。</target>
        </trans-unit>
        <trans-unit id="30f27dc120bd0cd0936d6ea3e2605fa14175aaad" translate="yes" xml:space="preserve">
          <source>If a pandas object contains data with multiple dtypes &lt;em&gt;in a single column&lt;/em&gt;, the dtype of the column will be chosen to accommodate all of the data types (&lt;code&gt;object&lt;/code&gt; is the most general).</source>
          <target state="translated">如果pandas对象&lt;em&gt;在单个列中&lt;/em&gt;包含具有多个dtypes的数据，则将选择该列的dtype来容纳所有数据类型（ &lt;code&gt;object&lt;/code&gt; 是最通用的）。</target>
        </trans-unit>
        <trans-unit id="3a932b347122ba17dc03c8f35de7e3581545858f" translate="yes" xml:space="preserve">
          <source>If a scalar value is passed it is used to fill all missing values. Alternatively, an array-like &amp;lsquo;value&amp;rsquo; can be given. It&amp;rsquo;s expected that the array-like have the same length as &amp;lsquo;self&amp;rsquo;.</source>
          <target state="translated">如果传递了标量值，它将用于填充所有缺少的值。或者，可以给出类似数组的&amp;ldquo;值&amp;rdquo;。预计类似数组的长度与&amp;ldquo;自身&amp;rdquo;的长度相同。</target>
        </trans-unit>
        <trans-unit id="f43ebe72554d837c1947c44cf9fbf7743e493fcf" translate="yes" xml:space="preserve">
          <source>If a str is passed, the color is the same for both negative and positive numbers. If 2-tuple/list is used, the first element is the color_negative and the second is the color_positive (eg: [&amp;lsquo;#d65f5f&amp;rsquo;, &amp;lsquo;#5fba7d&amp;rsquo;]).</source>
          <target state="translated">如果传递了str，则负数和正数的颜色都相同。如果使用2元组/列表，则第一个元素为color_negative，第二个元素为color_positive（例如：['＃d65f5f'，'＃5fba7d']）。</target>
        </trans-unit>
        <trans-unit id="664c221db1d1a044cd6be831ba5898cec1c6e906" translate="yes" xml:space="preserve">
          <source>If a string is given, must be a name of the level If list-like must be names or ints of levels.</source>
          <target state="translated">如果给定一个字符串,必须是关卡的名称 如果是list-like必须是关卡的名称或ints。</target>
        </trans-unit>
        <trans-unit id="cafbad4f4c6b2e30bd77049a6387059a8f8a90f9" translate="yes" xml:space="preserve">
          <source>If a string is given, must be a name of the level. If list-like must be names or ints of levels.</source>
          <target state="translated">如果是字符串,必须是关卡的名称。如果是list-like,必须是关卡的名称或ints。</target>
        </trans-unit>
        <trans-unit id="a1949bae823faece7ef8021ce74e5c7a237a24cd" translate="yes" xml:space="preserve">
          <source>If a string is given, must be the name of a level If list-like, elements must be names or indexes of levels.</source>
          <target state="translated">如果给定一个字符串,必须是一个级别的名称 如果是列表式,元素必须是级别的名称或索引。</target>
        </trans-unit>
        <trans-unit id="2bd170078f20dc52e06bd86e8da7a8f33d73c15a" translate="yes" xml:space="preserve">
          <source>If a string is given, must be the name of a level If list-like, elements must be names or positional indexes of levels.</source>
          <target state="translated">如果给定一个字符串,必须是级别的名称 如果是列表式,元素必须是级别的名称或位置索引。</target>
        </trans-unit>
        <trans-unit id="0e11c8b3b91fdf70e4a950b5de81db4fc235d3c5" translate="yes" xml:space="preserve">
          <source>If a string matches both a column name and an index level name then a warning is issued and the column takes precedence. This will result in an ambiguity error in a future version.</source>
          <target state="translated">如果一个字符串同时匹配一个列名和一个索引级别的名称,那么就会发出警告,并以列名为准。这将在未来的版本中导致一个模糊性错误。</target>
        </trans-unit>
        <trans-unit id="a7917632f71f22a6298fe99afe8da3a61861e243" translate="yes" xml:space="preserve">
          <source>If a string matches both a column name and an index level name, then a warning is issued and the column takes precedence. This will result in an ambiguity error in a future version.</source>
          <target state="translated">如果一个字符串同时匹配一个列名和一个索引级别的名称,那么就会发出警告,列名优先。这将在未来的版本中导致一个模糊性错误。</target>
        </trans-unit>
        <trans-unit id="ab59153983f88bd3ac8734604519b5c38d644805" translate="yes" xml:space="preserve">
          <source>If a string or type, the data type to store all columns. If a dictionary, a mapping of column names and indices (zero-indexed) to specific data types.</source>
          <target state="translated">如果是字符串或类型,则是存储所有列的数据类型。如果是字典,则是列名和索引(零索引)到特定数据类型的映射。</target>
        </trans-unit>
        <trans-unit id="2cbe87791c4a51a042d70e2afa4264d8fe2def9f" translate="yes" xml:space="preserve">
          <source>If a string or type, the data type to store all index levels. If a dictionary, a mapping of index level names and indices (zero-indexed) to specific data types.</source>
          <target state="translated">如果是字符串或类型,则是存储所有索引级别的数据类型。如果是字典,则是索引级别名称和索引(零索引)到特定数据类型的映射。</target>
        </trans-unit>
        <trans-unit id="55a5950721810aaccc29839d233355a54a0b4274" translate="yes" xml:space="preserve">
          <source>If a string, it will be used as Root Directory path when writing a partitioned dataset. By file-like object, we refer to objects with a write() method, such as a file handle (e.g. via builtin open function) or io.BytesIO. The engine fastparquet does not accept file-like objects. If path is None, a bytes object is returned.</source>
          <target state="translated">如果是字符串,在写入分区数据集时,它将被用作根目录路径。所谓类文件对象,指的是具有write()方法的对象,如文件句柄(如通过内置的open函数)或io.BytesIO。引擎fastparquet不接受类文件对象。如果路径为None,则返回一个字节对象。</target>
        </trans-unit>
        <trans-unit id="d189c526d90e423b055887f39bc14e0c56d23d2a" translate="yes" xml:space="preserve">
          <source>If a string, it will be used as Root Directory path.</source>
          <target state="translated">如果是字符串,它将被用作根目录路径。</target>
        </trans-unit>
        <trans-unit id="d5aa15d15858711058094f491e41747189d9c0b7" translate="yes" xml:space="preserve">
          <source>If a subset of data is being parsed using the &lt;code&gt;usecols&lt;/code&gt; option, the &lt;code&gt;index_col&lt;/code&gt; specification is based on that subset, not the original data.</source>
          <target state="translated">如果使用 &lt;code&gt;usecols&lt;/code&gt; 选项解析数据的子集，则 &lt;code&gt;index_col&lt;/code&gt; 规范基于该子集，而不是原始数据。</target>
        </trans-unit>
        <trans-unit id="17ceab91a6aa8289bb5b8021e866580a53c5a0f2" translate="yes" xml:space="preserve">
          <source>If all elements are non-NA/null, returns None. Also returns None for empty Series/DataFrame.</source>
          <target state="translated">如果所有元素都是非NA/null,返回None。对于空的Series/DataFrame也返回None。</target>
        </trans-unit>
        <trans-unit id="8ff697a66f776f6bf9d5cb31605d3eecae945555" translate="yes" xml:space="preserve">
          <source>If all of the labels in the index are later than a label in</source>
          <target state="translated">如果索引中的所有标签都晚于在</target>
        </trans-unit>
        <trans-unit id="7703cb2a81c8223e4ff309ac97d763111e01337d" translate="yes" xml:space="preserve">
          <source>If all of the labels in the index are later than a label in &lt;code&gt;where&lt;/code&gt;, -1 is returned.</source>
          <target state="translated">如果索引中的所有标签都晚于 &lt;code&gt;where&lt;/code&gt; 的标签，则返回-1。</target>
        </trans-unit>
        <trans-unit id="ba174535c6272f0b997374d38b2209ea810429e1" translate="yes" xml:space="preserve">
          <source>If all of the labels in the index are later than the passed label, NaN is returned.</source>
          <target state="translated">如果索引中的所有标签都晚于传递的标签,则返回NaN。</target>
        </trans-unit>
        <trans-unit id="c1e29cecb8deb1bb9249dfbe69e58b24b5165bd3" translate="yes" xml:space="preserve">
          <source>If allow_fill=True and fill_value is not None, indices specified by -1 is regarded as NA. If Index doesn&amp;rsquo;t hold NA, raise ValueError</source>
          <target state="translated">如果allow_fill = True并且fill_value不为None，则将-1指定的索引视为NA。如果Index不包含NA，则引发ValueError</target>
        </trans-unit>
        <trans-unit id="e1054a2c112cb5a2006f1be297346faf1ff6466b" translate="yes" xml:space="preserve">
          <source>If allow_fill=True and fill_value is not None, indices specified by -1 is regarded as NA. If Index doesn&amp;rsquo;t hold NA, raise ValueError.</source>
          <target state="translated">如果allow_fill = True且fill_value不为None，则将-1指定的索引视为NA。如果Index不包含NA，则引发ValueError。</target>
        </trans-unit>
        <trans-unit id="ff14634826d79012ed764cfa8de5a9838978cc57" translate="yes" xml:space="preserve">
          <source>If an array is passed, it must be the same length as the data. The list can contain any of the other types (except list). Keys to group by on the pivot table column. If an array is passed, it is being used as the same manner as column values.</source>
          <target state="translated">如果传递的是一个数组,它的长度必须与数据相同。列表可以包含任何其他类型(列表除外)。在数据透视表列上按键进行分组。如果传递一个数组,它的使用方式与列值相同。</target>
        </trans-unit>
        <trans-unit id="9c5ee36569ccce557bf8297b686d33c4ab619682" translate="yes" xml:space="preserve">
          <source>If an array is passed, it must be the same length as the data. The list can contain any of the other types (except list). Keys to group by on the pivot table index. If an array is passed, it is being used as the same manner as column values.</source>
          <target state="translated">如果传递的是一个数组,它的长度必须与数据相同。列表可以包含任何其他类型(列表除外)。按数据透视表索引分组的键。如果传递一个数组,它的使用方式与列值相同。</target>
        </trans-unit>
        <trans-unit id="1e71a78ce13f5e4a60eac8f95606f6a518f5b879" translate="yes" xml:space="preserve">
          <source>If an explicit &lt;code&gt;ordered=True&lt;/code&gt; is given but no</source>
          <target state="translated">如果给出了明确的 &lt;code&gt;ordered=True&lt;/code&gt; ，但没有给出</target>
        </trans-unit>
        <trans-unit id="af8c676f3147891a205dd28d61aaddbbe77519ec" translate="yes" xml:space="preserve">
          <source>If an explicit &lt;code&gt;ordered=True&lt;/code&gt; is given but no &lt;code&gt;categories&lt;/code&gt; and the &lt;code&gt;values&lt;/code&gt; are not sortable.</source>
          <target state="translated">如果给出明确的 &lt;code&gt;ordered=True&lt;/code&gt; ，但没有 &lt;code&gt;categories&lt;/code&gt; ，则 &lt;code&gt;values&lt;/code&gt; 不可排序。</target>
        </trans-unit>
        <trans-unit id="2e237695f0996c6449ac5d388a3e4cbbe78266cb" translate="yes" xml:space="preserve">
          <source>If an index is passed, the values in data corresponding to the labels in the index will be pulled out.</source>
          <target state="translated">如果传递了一个索引,那么索引中的标签对应的数据中的值就会被拉出来。</target>
        </trans-unit>
        <trans-unit id="8259a6d68eab8c19d5e0eabd67405da8ab57b1f5" translate="yes" xml:space="preserve">
          <source>If an indexed key is passed and its index is unalignable to the frame index.</source>
          <target state="translated">如果传递了一个索引键,其索引与帧索引不可对齐。</target>
        </trans-unit>
        <trans-unit id="66446b4ed963dd0e69016b68d9c4e0f33d4ddf75" translate="yes" xml:space="preserve">
          <source>If any items are not found.</source>
          <target state="translated">如果没有找到任何物品。</target>
        </trans-unit>
        <trans-unit id="a811d63c53b8811ca58b647eaf1fc34cafb5488e" translate="yes" xml:space="preserve">
          <source>If any kind of string dtype is passed in.</source>
          <target state="translated">如果传入任何一种字符串dtype。</target>
        </trans-unit>
        <trans-unit id="737e8df6f3276db9f6615ef85a21d500c5c61d47" translate="yes" xml:space="preserve">
          <source>If any method argument other than the default of None is specified as these are not yet implemented.</source>
          <target state="translated">如果指定了除默认值None以外的其他方法参数,因为这些方法还没有实现。</target>
        </trans-unit>
        <trans-unit id="70c61d6e01ff0aae044349ecdba7bbb1250fe8c6" translate="yes" xml:space="preserve">
          <source>If any of the labels is not found in the selected axis and &amp;ldquo;errors=&amp;rsquo;raise&amp;rsquo;&amp;rdquo;.</source>
          <target state="translated">如果在所选轴中未找到任何标签，则显示&amp;ldquo; errors ='raise'&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="f11beca5c6ae8017f4b7406cc4296549080b22d3" translate="yes" xml:space="preserve">
          <source>If any of the labels is not found in the selected axis.</source>
          <target state="translated">如果在选定的轴中没有找到任何一个标签。</target>
        </trans-unit>
        <trans-unit id="2320b14f67eb9ec3b540a8bb24814b91f5c2d50d" translate="yes" xml:space="preserve">
          <source>If any of the levels passed to &lt;code&gt;set_levels()&lt;/code&gt; exceeds the existing length, all of the values from that argument will be stored in the MultiIndex levels, though the values will be truncated in the MultiIndex output.</source>
          <target state="translated">如果传递给 &lt;code&gt;set_levels()&lt;/code&gt; 的任何级别超过现有长度，则该参数的所有值都将存储在MultiIndex级别中，尽管这些值将在MultiIndex输出中被截断。</target>
        </trans-unit>
        <trans-unit id="98671b51d92b145da7c4a68f0d6180b02179c533" translate="yes" xml:space="preserve">
          <source>If any of the list items is not a string object, the result of the join will be</source>
          <target state="translated">如果任何一个列表项不是字符串对象,连接的结果将是</target>
        </trans-unit>
        <trans-unit id="47983fc844672129f9ac1881a49d6e66e982428b" translate="yes" xml:space="preserve">
          <source>If any of the list items is not a string object, the result of the join will be &lt;code&gt;NaN&lt;/code&gt;.</source>
          <target state="translated">如果任何列表项不是字符串对象，则 &lt;code&gt;NaN&lt;/code&gt; 的结果将为NaN。</target>
        </trans-unit>
        <trans-unit id="74b321536b7a61a75e369e0d3490288a3ea2fe2a" translate="yes" xml:space="preserve">
          <source>If any of these defaults are not what you want, or if you want to be explicit about how missing values are handled, consider using &lt;a href=&quot;../reference/api/pandas.dataframe.fillna#pandas.DataFrame.fillna&quot;&gt;&lt;code&gt;fillna()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../reference/api/pandas.dataframe.dropna#pandas.DataFrame.dropna&quot;&gt;&lt;code&gt;dropna()&lt;/code&gt;&lt;/a&gt; before plotting.</source>
          <target state="translated">如果这些默认值都不是您想要的默认值，或者想要明确说明缺失值的处理方式，请在绘制之前考虑使用&lt;a href=&quot;../reference/api/pandas.dataframe.fillna#pandas.DataFrame.fillna&quot;&gt; &lt;code&gt;fillna()&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;../reference/api/pandas.dataframe.dropna#pandas.DataFrame.dropna&quot;&gt; &lt;code&gt;dropna()&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="abc14636cf1e86ec565e13cf216055ad1c0f39df" translate="yes" xml:space="preserve">
          <source>If appending prefix, separator/delimiter to use. Or pass a list or dictionary as with</source>
          <target state="translated">如果附加前缀,则使用分隔符/定界符。或者传递一个列表或字典,如</target>
        </trans-unit>
        <trans-unit id="1979d89f7de4b9fbb39ec05f540083098724a80f" translate="yes" xml:space="preserve">
          <source>If appending prefix, separator/delimiter to use. Or pass a list or dictionary as with &lt;code&gt;prefix&lt;/code&gt;.</source>
          <target state="translated">如果附加前缀，则使用分隔符/分隔符。或传递列表或字典作为 &lt;code&gt;prefix&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a11a511e2ae2cc8424f72edc278dc39628207610" translate="yes" xml:space="preserve">
          <source>If applicable, we highly recommend that you implement &lt;code&gt;__array_ufunc__&lt;/code&gt; in your extension array to avoid coercion to an ndarray. See &lt;a href=&quot;https://docs.scipy.org/doc/numpy/reference/generated/numpy.lib.mixins.NDArrayOperatorsMixin.html&quot;&gt;the numpy documentation&lt;/a&gt; for an example.</source>
          <target state="translated">如果适用，我们强烈建议您实现 &lt;code&gt;__array_ufunc__&lt;/code&gt; 在扩展阵列，以避免强制到ndarray。有关示例，请参见&lt;a href=&quot;https://docs.scipy.org/doc/numpy/reference/generated/numpy.lib.mixins.NDArrayOperatorsMixin.html&quot;&gt;numpy文档&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="072e26cb4593102e0bb6adf3546c35bd36d7bb05" translate="yes" xml:space="preserve">
          <source>If applying compression use the fletcher32 checksum.</source>
          <target state="translated">如果应用压缩,则使用fletcher32校验和。</target>
        </trans-unit>
        <trans-unit id="53cfe1a79643b5445944cea852309386c3712f73" translate="yes" xml:space="preserve">
          <source>If at least one of the two is absent, but the index is sorted, and can be compared against start and stop labels, then slicing will still work as expected, by selecting labels which &lt;em&gt;rank&lt;/em&gt; between the two:</source>
          <target state="translated">如果这两个中的至少一个不存在的，但该指数进行排序，并能对启动和停止的标签进行比较，然后切片仍然会按预期方式工作，通过选择的标签，其&lt;em&gt;排名&lt;/em&gt;在两者之间：</target>
        </trans-unit>
        <trans-unit id="9f8772725018c792397868923cdb717ae3175a40" translate="yes" xml:space="preserve">
          <source>If axis ia a MultiIndex, convert a specific level. Otherwise must be None</source>
          <target state="translated">如果 axis ia 是一个 MultiIndex,则转换一个特定的级别。否则必须是None</target>
        </trans-unit>
        <trans-unit id="87391f1e1e648bf058bee7a9654161130eecfc7b" translate="yes" xml:space="preserve">
          <source>If axis ia a MultiIndex, localize a specific level. Otherwise must be None</source>
          <target state="translated">如果 axis ia 是一个 MultiIndex,则定位一个特定的级别。否则必须为None</target>
        </trans-unit>
        <trans-unit id="8a50a2305a89159f20c3e526bded6db5fec79fba" translate="yes" xml:space="preserve">
          <source>If axis ia a MultiIndex, localize a specific level. Otherwise must be None.</source>
          <target state="translated">如果 axis ia 是一个 MultiIndex,则定位一个特定的级别。否则必须为None。</target>
        </trans-unit>
        <trans-unit id="4e1261ab8f79e64a44def90e5c786465d95ec434" translate="yes" xml:space="preserve">
          <source>If axis is 0 or &amp;lsquo;index&amp;rsquo; the result will be a Series. The resulting index will be a MultiIndex with &amp;lsquo;self&amp;rsquo; and &amp;lsquo;other&amp;rsquo; stacked alternately at the inner level.</source>
          <target state="translated">如果轴为0或&amp;ldquo;索引&amp;rdquo;，则结果为系列。生成的索引将是一个MultiIndex，其&amp;ldquo; self&amp;rdquo;和&amp;ldquo; other&amp;rdquo;在内部级别交替堆叠。</target>
        </trans-unit>
        <trans-unit id="ba63f643d6684b1fc4f7718c26beec37bedbe5f2" translate="yes" xml:space="preserve">
          <source>If axis is 1 or &amp;lsquo;columns&amp;rsquo; the result will be a DataFrame. It will have two columns namely &amp;lsquo;self&amp;rsquo; and &amp;lsquo;other&amp;rsquo;.</source>
          <target state="translated">如果axis为1或&amp;ldquo;列&amp;rdquo;，则结果将为DataFrame。它将具有两列，即&amp;ldquo;自我&amp;rdquo;和&amp;ldquo;其他&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="dca845052cf9e007f580b3f733e1fac9e0281428" translate="yes" xml:space="preserve">
          <source>If axis is a MultiIndex, convert a specific level. Otherwise must be None.</source>
          <target state="translated">如果轴是一个MultiIndex,则转换一个特定的级别。否则必须是None。</target>
        </trans-unit>
        <trans-unit id="b3d63325924797f142a9e6c13d5c6dd030cce6e4" translate="yes" xml:space="preserve">
          <source>If axis labels are not passed, they will be constructed from the input data based on common sense rules.</source>
          <target state="translated">如果不传递轴标签,它们将根据常识性规则从输入数据中构建。</target>
        </trans-unit>
        <trans-unit id="e69e66617e975b4f927b06bc80c35783ba32c625" translate="yes" xml:space="preserve">
          <source>If bin edges are not unique, raise ValueError or drop non-uniques.</source>
          <target state="translated">如果bin边缘不是唯一的,则引发ValueError或放弃非唯一性。</target>
        </trans-unit>
        <trans-unit id="8999a3f1324f4044aba9bb76851d3a780b4c0b9d" translate="yes" xml:space="preserve">
          <source>If both &lt;code&gt;header&lt;/code&gt; and &lt;code&gt;skiprows&lt;/code&gt; are specified, &lt;code&gt;header&lt;/code&gt; will be relative to the end of &lt;code&gt;skiprows&lt;/code&gt;. For example:</source>
          <target state="translated">如果同时指定了 &lt;code&gt;header&lt;/code&gt; 和 &lt;code&gt;skiprows&lt;/code&gt; ，则 &lt;code&gt;header&lt;/code&gt; 将相对于 &lt;code&gt;skiprows&lt;/code&gt; 的末尾。例如：</target>
        </trans-unit>
        <trans-unit id="253d364dc8215c289f304194e1235e5c7cb7fc6c" translate="yes" xml:space="preserve">
          <source>If both dayfirst and yearfirst are True, yearfirst is preceded (same as dateutil).</source>
          <target state="translated">如果dayfirst和yearfirst都为True,则yearfirst在前面(与dateutil相同)。</target>
        </trans-unit>
        <trans-unit id="20ec4100e04e070e2add532e3371209cd96960d1" translate="yes" xml:space="preserve">
          <source>If both of &lt;code&gt;include&lt;/code&gt; and &lt;code&gt;exclude&lt;/code&gt; are empty</source>
          <target state="translated">如果 &lt;code&gt;include&lt;/code&gt; 和 &lt;code&gt;exclude&lt;/code&gt; 都为空</target>
        </trans-unit>
        <trans-unit id="cc54c1baccafe31b1df94f88241fa0c566479663" translate="yes" xml:space="preserve">
          <source>If buf is None, returns the result as a string. Otherwise returns None.</source>
          <target state="translated">如果buf为None,则以字符串形式返回结果。否则返回None。</target>
        </trans-unit>
        <trans-unit id="ab952ef7ef22e79ae1ce8234aa416ed5979fad75" translate="yes" xml:space="preserve">
          <source>If buf is None, returns the resulting LateX format as a string. Otherwise returns None.</source>
          <target state="translated">如果buf为None,则返回结果为字符串的LateX格式。否则返回None。</target>
        </trans-unit>
        <trans-unit id="f9d07940e53f336322c19c2cd577417a583dce50" translate="yes" xml:space="preserve">
          <source>If callable, the callable function will be evaluated against the column names, returning names where the callable function evaluates to True. An example of a valid callable argument would be &lt;code&gt;lambda x: x.upper() in
['AAA', 'BBB', 'DDD']&lt;/code&gt;. Using this parameter results in much faster parsing time and lower memory usage.</source>
          <target state="translated">如果是可调用的，则将根据列名对可调用函数进行求值，并在可调用函数求值为True的情况下返回名称。有效的可调用参数的一个示例是 &lt;code&gt;lambda x: x.upper() in ['AAA', 'BBB', 'DDD']&lt;/code&gt; 。使用此参数可以大大加快解析时间并降低内存使用量。</target>
        </trans-unit>
        <trans-unit id="f28da403364b3ca9b72b658dafe69a7d983229a8" translate="yes" xml:space="preserve">
          <source>If callable, the callable function will be evaluated against the column names, returning names where the callable function evaluates to True:</source>
          <target state="translated">如果是可调用的,可调用的函数将对列名进行评估,返回可调用函数评估为True的列名。</target>
        </trans-unit>
        <trans-unit id="9cc56eeda19feaa07d8092a737946e7c1b49b405" translate="yes" xml:space="preserve">
          <source>If callable, the callable function will be evaluated against the row indices, returning True if the row should be skipped and False otherwise. An example of a valid callable argument would be &lt;code&gt;lambda x: x in [0, 2]&lt;/code&gt;.</source>
          <target state="translated">如果可调用，则将针对行索引评估可调用函数，如果应跳过该行，则返回True，否则返回False。有效的可调用参数的一个示例是 &lt;code&gt;lambda x: x in [0, 2]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e005dc46520dc329b9e3c5ee6c0162eb68f3a28a" translate="yes" xml:space="preserve">
          <source>If callable, the callable function will be evaluated against the row indices, returning True if the row should be skipped and False otherwise:</source>
          <target state="translated">如果是可调用的,可调用的函数将根据行的索引进行评估,如果该行应该被跳过,则返回True,否则返回False。</target>
        </trans-unit>
        <trans-unit id="513ede3f3a8cf7e7586af86037ccc686ffc6ba4a" translate="yes" xml:space="preserve">
          <source>If callable, then evaluate each column name against it and parse the column if the callable returns &lt;code&gt;True&lt;/code&gt;.</source>
          <target state="translated">如果可调用，则针对它评估每个列名称，如果可调用返回 &lt;code&gt;True&lt;/code&gt; ，则解析该列。</target>
        </trans-unit>
        <trans-unit id="51a1daa823350ace6cba99a153f88fcde66e034b" translate="yes" xml:space="preserve">
          <source>If categorical data is ordered (&lt;code&gt;s.cat.ordered == True&lt;/code&gt;), then the order of the categories has a meaning and certain operations are possible. If the categorical is unordered, &lt;code&gt;.min()/.max()&lt;/code&gt; will raise a &lt;code&gt;TypeError&lt;/code&gt;.</source>
          <target state="translated">如果分类数据是有序的（ &lt;code&gt;s.cat.ordered == True&lt;/code&gt; ），则类别的顺序具有含义，并且某些操作是可能的。如果分类是无序的，则 &lt;code&gt;.min()/.max()&lt;/code&gt; 将引发 &lt;code&gt;TypeError&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="685d3f02d43beae9f293bf9f8747df3c13b4c5c6" translate="yes" xml:space="preserve">
          <source>If columns are a MultiIndex then use this level to melt.</source>
          <target state="translated">如果列是一个MultiIndex,那么就用这个级别来融化。</target>
        </trans-unit>
        <trans-unit id="73f524f5a96443526a0f752ccc0a0f45d33e2689" translate="yes" xml:space="preserve">
          <source>If data is None, start is used as the start point in generating regular timedelta data.</source>
          <target state="translated">如果数据为None,则使用start作为生成常规timedelta数据的起始点。</target>
        </trans-unit>
        <trans-unit id="ff093965800686fc456d1ec74cddd873c03a2a06" translate="yes" xml:space="preserve">
          <source>If data is None, start is used as the start point in generating regular timestamp data.</source>
          <target state="translated">如果数据为None,则使用start作为生成常规时间戳数据的起始点。</target>
        </trans-unit>
        <trans-unit id="dae62288e37f2c075b791322d9beac67a5a2965c" translate="yes" xml:space="preserve">
          <source>If data is None, used as the start point in generating regular period data.</source>
          <target state="translated">如果数据为None,作为生成定期数据的起点。</target>
        </trans-unit>
        <trans-unit id="f945356c77bbf782bb9b78eeeea13f0a8f770df9" translate="yes" xml:space="preserve">
          <source>If datetimes contain timezone information</source>
          <target state="translated">如果日期时间包含时区信息</target>
        </trans-unit>
        <trans-unit id="151a8d67020136db3746f6fd54d019f0751e502a" translate="yes" xml:space="preserve">
          <source>If dropna, will take the nth non-null row, dropna is either &amp;lsquo;all&amp;rsquo; or &amp;lsquo;any&amp;rsquo;; this is equivalent to calling dropna(how=dropna) before the groupby.</source>
          <target state="translated">如果dropna会采用第n个非空行，则dropna要么是&amp;ldquo; all&amp;rdquo;，要么是&amp;ldquo; any&amp;rdquo;；这等效于在groupby之前调用dropna（how = dropna）。</target>
        </trans-unit>
        <trans-unit id="ec063cf3e1fb3772513c2c6ae92ef2ab32d9ee75" translate="yes" xml:space="preserve">
          <source>If dtype is None, we find the dtype that best fits the data. If an actual dtype is provided, we coerce to that dtype if it&amp;rsquo;s safe. Otherwise, an error will be raised.</source>
          <target state="translated">如果dtype为None，我们将找到最适合数据的dtype。如果提供了实际的dtype，则在安全的情况下强制使用该dtype。否则，将引发错误。</target>
        </trans-unit>
        <trans-unit id="c23c90863643c36250aa1190db0145034944681e" translate="yes" xml:space="preserve">
          <source>If error_bad_lines is &lt;code&gt;False&lt;/code&gt;, and warn_bad_lines is &lt;code&gt;True&lt;/code&gt;, a warning for each &amp;ldquo;bad line&amp;rdquo; will be output.</source>
          <target state="translated">如果error_bad_lines为 &lt;code&gt;False&lt;/code&gt; ，而warn_bad_lines为 &lt;code&gt;True&lt;/code&gt; ，则将输出针对每个&amp;ldquo;不良行&amp;rdquo;的警告。</target>
        </trans-unit>
        <trans-unit id="5291444796253761cd9ba2fe4457299e7f8a08a6" translate="yes" xml:space="preserve">
          <source>If error_bad_lines is False, and warn_bad_lines is True, a warning for each &amp;ldquo;bad line&amp;rdquo; will be output.</source>
          <target state="translated">如果error_bad_lines为False，而warn_bad_lines为True，则将为每个&amp;ldquo;坏行&amp;rdquo;输出警告。</target>
        </trans-unit>
        <trans-unit id="f6c76ec1a67aef33e908ab260e62c8b2c8f08ade" translate="yes" xml:space="preserve">
          <source>If everything looks good, you are ready to make a pull request. A pull request is how code from a local repository becomes available to the GitHub community and can be looked at and eventually merged into the master version. This pull request and its associated changes will eventually be committed to the master branch and available in the next release. To submit a pull request:</source>
          <target state="translated">如果一切看起来都不错,你就可以提出拉取请求了。拉取请求是将本地仓库中的代码提供给GitHub社区的方式,可以查看并最终合并到主版本中。这个拉取请求及其相关的改动最终会被提交到主分支,并在下一个版本中使用。要提交一个拉取请求。</target>
        </trans-unit>
        <trans-unit id="6d2b4f1f9225dd4aceca893c869ab3d65bdb1668" translate="yes" xml:space="preserve">
          <source>If for a certain row the number of found splits &amp;lt;</source>
          <target state="translated">如果对于某行，找到的分割数&amp;lt;</target>
        </trans-unit>
        <trans-unit id="23c9060c54c6bb6c39f0e98425258486180b9e59" translate="yes" xml:space="preserve">
          <source>If for a certain row the number of found splits &amp;lt; &lt;code&gt;n&lt;/code&gt;, append &lt;code&gt;None&lt;/code&gt; for padding up to &lt;code&gt;n&lt;/code&gt; if &lt;code&gt;expand=True&lt;/code&gt;</source>
          <target state="translated">如果对于某行，找到的拆分数&amp;lt; &lt;code&gt;n&lt;/code&gt; ，则在 &lt;code&gt;expand=True&lt;/code&gt; 时追加 &lt;code&gt;None&lt;/code&gt; 以填充至 &lt;code&gt;n&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4f1bbf12bd4be481a7b76931c444ac723ac7f23e" translate="yes" xml:space="preserve">
          <source>If for some reason you have a column named &lt;code&gt;index&lt;/code&gt;, then you can refer to the index as &lt;code&gt;ilevel_0&lt;/code&gt; as well, but at this point you should consider renaming your columns to something less ambiguous.</source>
          <target state="translated">如果由于某种原因，您有一个名为 &lt;code&gt;index&lt;/code&gt; 的列，那么您也可以将索引称为 &lt;code&gt;ilevel_0&lt;/code&gt; ，但是此时，您应该考虑将列重命名为不太模糊的名称。</target>
        </trans-unit>
        <trans-unit id="332a16903c151c1ecb224e10fcac795483da5669" translate="yes" xml:space="preserve">
          <source>If found splits &amp;gt;</source>
          <target state="translated">如果发现分裂&amp;gt;</target>
        </trans-unit>
        <trans-unit id="6211ffb8fa3fb2fd37ec09f2b6296b76ea53b066" translate="yes" xml:space="preserve">
          <source>If found splits &amp;gt; &lt;code&gt;n&lt;/code&gt;, make first &lt;code&gt;n&lt;/code&gt; splits only</source>
          <target state="translated">如果发现拆分&amp;gt; &lt;code&gt;n&lt;/code&gt; ，则仅使前 &lt;code&gt;n&lt;/code&gt; 个拆分</target>
        </trans-unit>
        <trans-unit id="967baafdae5ca9570712f0e926ab45321d817a83" translate="yes" xml:space="preserve">
          <source>If found splits &amp;lt;=</source>
          <target state="translated">如果发现分裂&amp;lt;=</target>
        </trans-unit>
        <trans-unit id="b37fc31feaa05a56a504bc57a3dc5a6d1aa79bdc" translate="yes" xml:space="preserve">
          <source>If found splits &amp;lt;= &lt;code&gt;n&lt;/code&gt;, make all splits</source>
          <target state="translated">如果发现拆分&amp;lt;= &lt;code&gt;n&lt;/code&gt; ，则进行所有拆分</target>
        </trans-unit>
        <trans-unit id="faedb07d74ab41f0e6f62f0f259b9779f728a236" translate="yes" xml:space="preserve">
          <source>If freq is an invalid frequency</source>
          <target state="translated">如果freq是一个无效的频率</target>
        </trans-unit>
        <trans-unit id="803c3a3090c279b46259470fbbb792974d7f901b" translate="yes" xml:space="preserve">
          <source>If freq is not specified then tries to use the freq or inferred_freq attributes of the index. If neither of those attributes exist, a ValueError is thrown</source>
          <target state="translated">如果没有指定freq,则尝试使用索引的freq或inferred_freq属性。如果这两个属性都不存在,就会抛出一个ValueError。</target>
        </trans-unit>
        <trans-unit id="913b44532f3a53f43a3f8beb187957afcd4c09d7" translate="yes" xml:space="preserve">
          <source>If freq is passed, the index will be increased using the periods and the freq.</source>
          <target state="translated">如果传入freq,则使用周期和freq增加指数。</target>
        </trans-unit>
        <trans-unit id="cd7e199c3229ad1a29b7396ccb73cb9b8b33ec4f" translate="yes" xml:space="preserve">
          <source>If func returns a Series object the result will be a DataFrame.</source>
          <target state="translated">如果func返回一个Series对象,结果将是一个DataFrame。</target>
        </trans-unit>
        <trans-unit id="e05cd03bb9478611824232e1b320bc090b5b4903" translate="yes" xml:space="preserve">
          <source>If given, it will use the</source>
          <target state="translated">如果给定,它将使用</target>
        </trans-unit>
        <trans-unit id="97e40162438268f3434fb42f4961c0381c5a410b" translate="yes" xml:space="preserve">
          <source>If given, it will use the &lt;code&gt;fig&lt;/code&gt; reference for plotting instead of creating a new one with default parameters.</source>
          <target state="translated">如果给出，它将使用 &lt;code&gt;fig&lt;/code&gt; 参考进行绘图，而不是使用默认参数创建一个新的参考。</target>
        </trans-unit>
        <trans-unit id="7c905670577eb23cd045f70e74e41dc154603058" translate="yes" xml:space="preserve">
          <source>If grouper is PeriodIndex and</source>
          <target state="translated">如果grouper是PeriodIndex并且</target>
        </trans-unit>
        <trans-unit id="4f948fed8d6912efb15a4f875d827717c7e831f0" translate="yes" xml:space="preserve">
          <source>If grouper is PeriodIndex and &lt;code&gt;freq&lt;/code&gt; parameter is passed.</source>
          <target state="translated">如果grouper为PeriodIndex并且传递了 &lt;code&gt;freq&lt;/code&gt; 参数。</target>
        </trans-unit>
        <trans-unit id="2153311a52299005ad6b900f85d75a5bc89c102d" translate="yes" xml:space="preserve">
          <source>If implementing NumPy&amp;rsquo;s &lt;code&gt;__array_ufunc__&lt;/code&gt; interface, pandas expects that</source>
          <target state="translated">如果实现NumPy的 &lt;code&gt;__array_ufunc__&lt;/code&gt; 接口，熊猫希望</target>
        </trans-unit>
        <trans-unit id="40c691f0e2bf83f7f8c92678a022cd114c946bdb" translate="yes" xml:space="preserve">
          <source>If index resolution is second, then the minute-accurate timestamp gives a &lt;code&gt;Series&lt;/code&gt;.</source>
          <target state="translated">如果索引分辨率为第二，则精确到分钟的时间戳记为 &lt;code&gt;Series&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b739f8adfb8ff0aa6b270221577514d1891e01fa" translate="yes" xml:space="preserve">
          <source>If instead you don&amp;rsquo;t want to or cannot name your index, you can use the name &lt;code&gt;index&lt;/code&gt; in your query expression:</source>
          <target state="translated">相反，如果您不想或无法命名索引，则可以在查询表达式中使用名称 &lt;code&gt;index&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="9b5b6c6275ac36d8c29c9ef0f491f5feaa9d6ffc" translate="yes" xml:space="preserve">
          <source>If int and &amp;ldquo;stop&amp;rdquo; is not given, interpreted as &amp;ldquo;stop&amp;rdquo; instead.</source>
          <target state="translated">如果没有给出int和&amp;ldquo; stop&amp;rdquo;，则解释为&amp;ldquo; stop&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="6ef44adf7e998129a0e17630965a27165eef6f11" translate="yes" xml:space="preserve">
          <source>If int, array-like, or BitGenerator (NumPy&amp;gt;=1.17), seed for random number generator If np.random.RandomState, use as numpy RandomState object.</source>
          <target state="translated">如果是int，类数组或BitGenerator（NumPy&amp;gt; = 1.17），则为随机数生成器提供种子。如果为np.random.RandomState，请用作numpy RandomState对象。</target>
        </trans-unit>
        <trans-unit id="3b7b2547e4136f8605b954d25571fea98abec426" translate="yes" xml:space="preserve">
          <source>If int, then indicates last column to be parsed.</source>
          <target state="translated">如果是int,则表示要解析的最后一列。</target>
        </trans-unit>
        <trans-unit id="3bb72fad3e82acae71dc7993a1447557d62c8a5b" translate="yes" xml:space="preserve">
          <source>If io is not a buffer or path, this must be set to identify io. Acceptable values are None or xlrd.</source>
          <target state="translated">如果io不是缓冲区或路径,必须设置为识别io。可接受的值是None或xlrd。</target>
        </trans-unit>
        <trans-unit id="9263cf78203e7295e057b98deb02db9d1dd510c4" translate="yes" xml:space="preserve">
          <source>If io is not a buffer or path, this must be set to identify io. Supported engines: &amp;ldquo;xlrd&amp;rdquo;, &amp;ldquo;openpyxl&amp;rdquo;, &amp;ldquo;odf&amp;rdquo;, &amp;ldquo;pyxlsb&amp;rdquo;. Engine compatibility :</source>
          <target state="translated">如果io不是缓冲区或路径，则必须设置它以标识io。支持的引擎：&amp;ldquo; xlrd&amp;rdquo;，&amp;ldquo; openpyxl&amp;rdquo;，&amp;ldquo; odf&amp;rdquo;，&amp;ldquo; pyxlsb&amp;rdquo;。引擎兼容性：</target>
        </trans-unit>
        <trans-unit id="43ca6d2682f5657f7e98ea4373774e219e824496" translate="yes" xml:space="preserve">
          <source>If its an offset then this will be the time period of each window. Each window will be a variable sized based on the observations included in the time-period. This is only valid for datetimelike indexes.</source>
          <target state="translated">如果是偏移,那么这将是每个窗口的时间段。每个窗口的大小将根据时间周期中包含的观测值而变化。这只对类似于日期时间的索引有效。</target>
        </trans-unit>
        <trans-unit id="e7b90b33df08c56801541d97b52863d5cc1a2208" translate="yes" xml:space="preserve">
          <source>If its an offset then this will be the time period of each window. Each window will be a variable sized based on the observations included in the time-period. This is only valid for datetimelike indexes. This is new in 0.19.0</source>
          <target state="translated">如果是偏移,那么这将是每个窗口的时间段。每个窗口的大小将根据时间周期中包含的观测值而变化。这只对类似于日期时间的索引有效。这是在0.19.0中新增的。</target>
        </trans-unit>
        <trans-unit id="ad91bd2fcbc8853d5dc9cba2938f0dd911cf8a6d" translate="yes" xml:space="preserve">
          <source>If keep_tz is False:</source>
          <target state="translated">如果keep_tz为False。</target>
        </trans-unit>
        <trans-unit id="baf1483fae1fac9f24a7c2ddac2906ea600716bb" translate="yes" xml:space="preserve">
          <source>If keep_tz is True:</source>
          <target state="translated">如果keep_tz为真。</target>
        </trans-unit>
        <trans-unit id="5bb59e5d8fa791e8b043037739659a61a93a3a51" translate="yes" xml:space="preserve">
          <source>If label is contained, will be reference to calling Series, otherwise a new object.</source>
          <target state="translated">如果标签被包含,将引用调用Series,否则新建一个对象。</target>
        </trans-unit>
        <trans-unit id="d8f134714528b444920506c4fe5aa496b4202bff" translate="yes" xml:space="preserve">
          <source>If label is not contained, a new object is created with the label placed at the end of the result index.</source>
          <target state="translated">如果标签不包含,则创建一个新的对象,将标签放在结果索引的末尾。</target>
        </trans-unit>
        <trans-unit id="a824931c7f88c06d3b1aacfaeeb1337548e955e0" translate="yes" xml:space="preserve">
          <source>If label pair is contained, will be reference to calling DataFrame, otherwise a new object.</source>
          <target state="translated">如果包含标签对,将引用调用DataFrame,否则新建一个对象。</target>
        </trans-unit>
        <trans-unit id="c00e1450820324efbc32fd35d064eb356db799b1" translate="yes" xml:space="preserve">
          <source>If level is specified, then, DataFrame is returned; otherwise, Series is returned.</source>
          <target state="translated">如果指定了级别,则返回DataFrame;否则,返回Series。</target>
        </trans-unit>
        <trans-unit id="7877da1e50e258680542b6af26d6fd85ecae2065" translate="yes" xml:space="preserve">
          <source>If level is specified, then, Series is returned; otherwise, scalar is returned.</source>
          <target state="translated">如果指定了level,则返回Series,否则返回scalar。</target>
        </trans-unit>
        <trans-unit id="ca17fab71c58fc25bab74d5c9db224c9c0dc9b57" translate="yes" xml:space="preserve">
          <source>If limit is specified, consecutive NaNs will be filled in this direction.</source>
          <target state="translated">如果指定了限制,则连续的NaNs将朝这个方向填充。</target>
        </trans-unit>
        <trans-unit id="eed73a2e297bebfb2ce480434de0e2542a0badfc" translate="yes" xml:space="preserve">
          <source>If limit is specified, consecutive NaNs will be filled with this restriction.</source>
          <target state="translated">如果指定了限制,连续的NaNs将被填入该限制。</target>
        </trans-unit>
        <trans-unit id="88c5560ab95765eb920a208bc7fb13404935ff90" translate="yes" xml:space="preserve">
          <source>If limit is specified:</source>
          <target state="translated">如果指定了限制。</target>
        </trans-unit>
        <trans-unit id="7caf98f1a23fbe99f3eecc43311325e017b47681" translate="yes" xml:space="preserve">
          <source>If list of functions passed, the resulting pivot table will have hierarchical columns whose top level are the function names (inferred from the function objects themselves) If dict is passed, the key is column to aggregate and value is function or list of functions</source>
          <target state="translated">如果传递的是函数列表,生成的数据透视表将有层次分明的列,其最上层是函数名称(从函数对象本身推断)如果传递的是dict,键是集合列,值是函数或函数列表</target>
        </trans-unit>
        <trans-unit id="50b3274a3da951ffb461e11c79f73edf459c48e7" translate="yes" xml:space="preserve">
          <source>If list of functions passed, the resulting pivot table will have hierarchical columns whose top level are the function names (inferred from the function objects themselves) If dict is passed, the key is column to aggregate and value is function or list of functions.</source>
          <target state="translated">如果传递的是函数列表,生成的数据透视表将有分层列,其顶层是函数名称(从函数对象本身推断)如果传递的是dict,键是要聚合的列,值是函数或函数列表。</target>
        </trans-unit>
        <trans-unit id="1d66f9c3628338003e89214bb889ccfda13c37c0" translate="yes" xml:space="preserve">
          <source>If list of int, then indicates list of column numbers to be parsed.</source>
          <target state="translated">如果列表为int,则表示要解析的列号列表。</target>
        </trans-unit>
        <trans-unit id="5fe49dea595acc90377978d171ab9c0a0e7439a2" translate="yes" xml:space="preserve">
          <source>If list of string, then indicates list of column names to be parsed.</source>
          <target state="translated">如果是字符串列表,则表示要解析的列名列表。</target>
        </trans-unit>
        <trans-unit id="68825ea1972a721fb38b022bcfd56c301bc54df2" translate="yes" xml:space="preserve">
          <source>If margins is</source>
          <target state="translated">如果margins是</target>
        </trans-unit>
        <trans-unit id="0d433683ef161d07d541b7f8a919bcca2325d430" translate="yes" xml:space="preserve">
          <source>If margins is &lt;code&gt;True&lt;/code&gt;, will also normalize margin values.</source>
          <target state="translated">如果margins为 &lt;code&gt;True&lt;/code&gt; ，还将标准化margin值。</target>
        </trans-unit>
        <trans-unit id="62646e174920cf65de16aa9a88e993e7c1b80354" translate="yes" xml:space="preserve">
          <source>If max_cols is exceeded, switch to truncate view. Depending on</source>
          <target state="translated">如果超过了max_cols,则切换到截断视图。根据</target>
        </trans-unit>
        <trans-unit id="db9fb1c596d81c3f532c5167f5855674a6532345" translate="yes" xml:space="preserve">
          <source>If max_rows is exceeded, switch to truncate view. Depending on</source>
          <target state="translated">如果超过了max_rows,则切换到截断视图。根据</target>
        </trans-unit>
        <trans-unit id="2a02a553bcee455a6ab31e5dbd189b43939c5bad" translate="yes" xml:space="preserve">
          <source>If method is specified, this is the maximum number of consecutive NaN values to forward/backward fill. In other words, if there is a gap with more than this number of consecutive NaNs, it will only be partially filled. If method is not specified, this is the maximum number of entries along the entire axis where NaNs will be filled.</source>
          <target state="translated">如果指定了方法,这是向前/向后填充的最大连续NaN值数。换句话说,如果有一个超过这个数量的连续NaN值的空白,它将只被部分填充。如果没有指定方法,这是沿整个轴的NaNs将被填充的最大条目数。</target>
        </trans-unit>
        <trans-unit id="64b5d3200781c8ed371e1e797a995a4f75b1dcb3" translate="yes" xml:space="preserve">
          <source>If method is specified, this is the maximum number of consecutive NaN values to forward/backward fill. In other words, if there is a gap with more than this number of consecutive NaNs, it will only be partially filled. If method is not specified, this is the maximum number of entries along the entire axis where NaNs will be filled. Must be greater than 0 if not None.</source>
          <target state="translated">如果指定了方法,这是向前/向后填充的最大连续NaN值数。换句话说,如果有一个超过这个数量的连续NaN值的空白,它将只被部分填充。如果没有指定方法,这是沿整个轴的NaNs将被填充的最大条目数。如果不是None,必须大于0。</target>
        </trans-unit>
        <trans-unit id="7f7d613c787dbb21e15f1dcf963bf265292c5edc" translate="yes" xml:space="preserve">
          <source>If more than one type is accepted, separate them by commas, except the last two types, that need to be separated by the word &amp;lsquo;or&amp;rsquo;:</source>
          <target state="translated">如果接受的类型不止一种，请用逗号将它们分开，但最后两种类型除外，这些逗号之间必须用单词&amp;ldquo;或&amp;rdquo;隔开：</target>
        </trans-unit>
        <trans-unit id="052f2f856a6dfb7a8830bd4e0484cb7b2be454e4" translate="yes" xml:space="preserve">
          <source>If multiple levels passed, should contain tuples. Construct hierarchical index using the passed keys as the outermost level.</source>
          <target state="translated">如果传递了多个层次,应该包含元组。使用传递的键作为最外层,构建层次索引。</target>
        </trans-unit>
        <trans-unit id="6501af21994846ec90e14ed89e7a813350f8d52c" translate="yes" xml:space="preserve">
          <source>If multiple object values have the highest count, then the &lt;code&gt;count&lt;/code&gt; and &lt;code&gt;top&lt;/code&gt; results will be arbitrarily chosen from among those with the highest count.</source>
          <target state="translated">如果多个对象值具有最高计数，则将从 &lt;code&gt;count&lt;/code&gt; 最高的对象中任意选择计数和 &lt;code&gt;top&lt;/code&gt; 结果。</target>
        </trans-unit>
        <trans-unit id="34d7f3599c01ed87631ef489cca8da2b4308aa21" translate="yes" xml:space="preserve">
          <source>If multiple values equal the maximum, the first row label with that value is returned.</source>
          <target state="translated">如果多个值等于最大值,则返回该值的第一个行标签。</target>
        </trans-unit>
        <trans-unit id="12828981e6321f886a33ba30627df341eba8d652" translate="yes" xml:space="preserve">
          <source>If multiple values equal the minimum, the first row label with that value is returned.</source>
          <target state="translated">如果多个值等于最小值,则返回带有该值的第一行标签。</target>
        </trans-unit>
        <trans-unit id="22f182e9b6624459ce684e4c8ed64ff090a2529a" translate="yes" xml:space="preserve">
          <source>If na_values are specified and keep_default_na is False the default NaN values are overridden, otherwise they&amp;rsquo;re appended to</source>
          <target state="translated">如果指定了na_values且keep_default_na为False，则默认的NaN值将被覆盖，否则会将它们附加到</target>
        </trans-unit>
        <trans-unit id="d6a517305158ceac1628f92ad56b945b90297339" translate="yes" xml:space="preserve">
          <source>If na_values are specified and keep_default_na is False the default NaN values are overridden, otherwise they&amp;rsquo;re appended to.</source>
          <target state="translated">如果指定了na_values且keep_default_na为False，则默认的NaN值将被覆盖，否则将附加它们。</target>
        </trans-unit>
        <trans-unit id="f762185f104435345c74d2cdd090da0e1d42ac15" translate="yes" xml:space="preserve">
          <source>If ndarray-like but cannot infer the dtype</source>
          <target state="translated">如果类似ndarray,但不能推断出dtype。</target>
        </trans-unit>
        <trans-unit id="e23113f2a52942ee42c83e1b254e8235537f3f63" translate="yes" xml:space="preserve">
          <source>If needed you can explicitly specify a format string, or a dict of arguments to pass to &lt;a href=&quot;../reference/api/pandas.to_datetime#pandas.to_datetime&quot;&gt;&lt;code&gt;pandas.to_datetime()&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">如果需要，您可以显式指定格式字符串或传递给&lt;a href=&quot;../reference/api/pandas.to_datetime#pandas.to_datetime&quot;&gt; &lt;code&gt;pandas.to_datetime()&lt;/code&gt; &lt;/a&gt;的参数字典：</target>
        </trans-unit>
        <trans-unit id="3f4eb2917c5222b0d337bae6fbff3ef21460ab9a" translate="yes" xml:space="preserve">
          <source>If needed you can just adjust the bins with an &lt;code&gt;offset&lt;/code&gt; Timedelta that would be added to the default &lt;code&gt;origin&lt;/code&gt;. Those two examples are equivalent for this time series:</source>
          <target state="translated">如果需要，您可以调整 &lt;code&gt;offset&lt;/code&gt; Timedelta的垃圾箱，该偏移量将添加到默认 &lt;code&gt;origin&lt;/code&gt; 。对于该时间序列，这两个示例是等效的：</target>
        </trans-unit>
        <trans-unit id="637d5696700a6df0a8baf6d3b140ebe5aff89341" translate="yes" xml:space="preserve">
          <source>If needed you can use a custom timestamp for &lt;code&gt;origin&lt;/code&gt;:</source>
          <target state="translated">如果需要，您可以使用自定义时间戳记作为 &lt;code&gt;origin&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="7000054cf48292d0455a5b9aca5bf89643b6c472" translate="yes" xml:space="preserve">
          <source>If new categories are list-like and do not have the same number of items than the current categories or do not validate as categories</source>
          <target state="translated">如果新的类别是列表式的,并且与当前类别的项目数量不一样,或者不作为类别有效。</target>
        </trans-unit>
        <trans-unit id="56ab769c4964e541ce9265684d378bc3a0d09287" translate="yes" xml:space="preserve">
          <source>If new_categories does not validate as categories</source>
          <target state="translated">如果new_categories没有被验证为categories</target>
        </trans-unit>
        <trans-unit id="cbed0bbea58dcdb206a837899ad95a4ba77dcd33" translate="yes" xml:space="preserve">
          <source>If no names are provided, use the column names, or tuple of column names if the columns is a MultiIndex. If a sequence, overwrite names with the given sequence.</source>
          <target state="translated">如果没有提供名称,使用列名,如果列是MultiIndex,则使用列名的元组。如果是一个序列,则用给定的序列覆盖名称。</target>
        </trans-unit>
        <trans-unit id="5a5bad26bee04e3ba222956c2c796e863be42591" translate="yes" xml:space="preserve">
          <source>If none of the labels are found in the index.</source>
          <target state="translated">如果在索引中没有找到任何标签。</target>
        </trans-unit>
        <trans-unit id="27841c0014abcd0463ff2861c53f354a6a34facc" translate="yes" xml:space="preserve">
          <source>If not None, and if the data has been successfully cast to a numerical dtype (or if the data was numeric to begin with), downcast that resulting data to the smallest numerical dtype possible according to the following rules:</source>
          <target state="translated">如果不是 &quot;无&quot;,并且如果数据已经被成功地投射到一个数字dtype(或者如果数据一开始就是数字型的),则根据以下规则将结果数据下传到尽可能小的数字dtype。</target>
        </trans-unit>
        <trans-unit id="1e307ecdc7ecd59bd95757600bace6779421241e" translate="yes" xml:space="preserve">
          <source>If not None, apply the key function to the index values before sorting. This is similar to the</source>
          <target state="translated">如果不是None,则在排序前对索引值应用键函数。这与</target>
        </trans-unit>
        <trans-unit id="66ebf1d3140f80342f207320ff26cd6b1a32ef4f" translate="yes" xml:space="preserve">
          <source>If not None, apply the key function to the series values before sorting. This is similar to the</source>
          <target state="translated">如果不是None,则在排序前对系列值应用键函数。这与</target>
        </trans-unit>
        <trans-unit id="e361817d859e555a419bc1371e6268617ba32d96" translate="yes" xml:space="preserve">
          <source>If not None, only these columns will be read from the file.</source>
          <target state="translated">如果不是None,则只从文件中读取这些列。</target>
        </trans-unit>
        <trans-unit id="cfe9cce3f8330a3251ed95d788697677222e7323" translate="yes" xml:space="preserve">
          <source>If not None, sort on values in specified index level(s).</source>
          <target state="translated">如果不是 &quot;无&quot;,则按指定索引级别的值排序。</target>
        </trans-unit>
        <trans-unit id="9376aca00f183cc74c267ce0caa80bff2fb817d1" translate="yes" xml:space="preserve">
          <source>If not all of the labels are found in the selected axis</source>
          <target state="translated">如果在选定的轴中没有找到所有的标签</target>
        </trans-unit>
        <trans-unit id="d0a22f48a5959f07a3692660fc0f335e8e4e36ac" translate="yes" xml:space="preserve">
          <source>If not passed, uses gca()</source>
          <target state="translated">如果不通过,则使用gca()</target>
        </trans-unit>
        <trans-unit id="c241cd23cfdf52a4bd48350a73a6738548d9b996" translate="yes" xml:space="preserve">
          <source>If not passed, uses gca().</source>
          <target state="translated">如果没有通过,则使用gca()。</target>
        </trans-unit>
        <trans-unit id="605ce58ce37edd99b2cbc7ee655fc1a9f67c5f6c" translate="yes" xml:space="preserve">
          <source>If not provided, all columns are read.</source>
          <target state="translated">如果没有提供,则读取所有列。</target>
        </trans-unit>
        <trans-unit id="c7adf8e39eb0b3d72eaf0f61526432eb5bfe7de6" translate="yes" xml:space="preserve">
          <source>If not specified, the keyword &lt;code&gt;sep&lt;/code&gt; for the separator defaults to the empty string, &lt;code&gt;sep=''&lt;/code&gt;:</source>
          <target state="translated">如果未指定，则分隔符的关键字 &lt;code&gt;sep&lt;/code&gt; 默认为空字符串 &lt;code&gt;sep=''&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="a29100beab681308f154ad5a4be5b3b89fb544c7" translate="yes" xml:space="preserve">
          <source>If not specified, there are two possibilities:</source>
          <target state="translated">如果没有说明,有两种可能。</target>
        </trans-unit>
        <trans-unit id="67d8b502538e17d92597d391d70ada0247caada5" translate="yes" xml:space="preserve">
          <source>If not supplied then will default to self and produce pairwise output.</source>
          <target state="translated">如果不提供,那么将默认为self,并产生配对输出。</target>
        </trans-unit>
        <trans-unit id="17e1ffdad774475011f6787cf4716965a7dadec6" translate="yes" xml:space="preserve">
          <source>If not supplied then will default to self.</source>
          <target state="translated">如果没有提供,那么将默认为自己。</target>
        </trans-unit>
        <trans-unit id="a7b3cbcd2ecfdfe645e2c20769e281ebccbcc3e3" translate="yes" xml:space="preserve">
          <source>If other is a Series, return the matrix product between self and other as a Serie. If other is a DataFrame or a numpy.array, return the matrix product of self and other in a DataFrame of a np.array.</source>
          <target state="translated">如果other是一个Series,则返回self和other之间的矩阵乘积为Serie。如果other是DataFrame或numpy.array,返回self和other在np.array的DataFrame中的矩阵积。</target>
        </trans-unit>
        <trans-unit id="43623d69404123e7a6aac874029d1b30acdfa12e" translate="yes" xml:space="preserve">
          <source>If other is a Series, return the matrix product between self and other as a Series. If other is a DataFrame or a numpy.array, return the matrix product of self and other in a DataFrame of a np.array.</source>
          <target state="translated">如果other是一个Series,返回self和other之间的矩阵乘积,作为Series。如果 other 是一个 DataFrame 或 numpy.array,返回 self 和 other 在一个 np.array 的 DataFrame 中的矩阵积。</target>
        </trans-unit>
        <trans-unit id="236a44b890a6ba0afca4e7206977a422c9384304" translate="yes" xml:space="preserve">
          <source>If others is None, the method returns the concatenation of all strings in the calling Series/Index.</source>
          <target state="translated">如果others为None,则该方法返回调用Series/Index中所有字符串的连接。</target>
        </trans-unit>
        <trans-unit id="b6f15e903f0777b1e7f0e9efd0f00fdc7d5f16dc" translate="yes" xml:space="preserve">
          <source>If others is a list-like that contains a combination of Series, Index or np.ndarray (1-dim), then all elements will be unpacked and must satisfy the above criteria individually.</source>
          <target state="translated">如果others是一个包含Series、Index或np.ndarray(1-dim)组合的list-like,那么所有元素将被解包,并且必须单独满足上述标准。</target>
        </trans-unit>
        <trans-unit id="44aa5702e4b920b2bf468228e7acc9cc6e30a8d3" translate="yes" xml:space="preserve">
          <source>If pandas does not infer a dedicated extension type a &lt;a href=&quot;pandas.arrays.pandasarray#pandas.arrays.PandasArray&quot;&gt;&lt;code&gt;arrays.PandasArray&lt;/code&gt;&lt;/a&gt; is returned.</source>
          <target state="translated">如果pandas不推断专用扩展名类型，则返回&lt;a href=&quot;pandas.arrays.pandasarray#pandas.arrays.PandasArray&quot;&gt; &lt;code&gt;arrays.PandasArray&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="63d6f5378543f5ad0bc487858af5d8d984e37eb8" translate="yes" xml:space="preserve">
          <source>If parsing dates (convert_dates is not False), then try to parse the default datelike columns. A column label is datelike if</source>
          <target state="translated">如果解析日期(convert_dates不是False),那么尝试解析默认的日期型列。如果一个列的标签是datelike,那么</target>
        </trans-unit>
        <trans-unit id="7aa4696f9d9f11d69bd7c0bc73e4bd0736b1ad80" translate="yes" xml:space="preserve">
          <source>If parsing dates, then parse the default datelike columns.</source>
          <target state="translated">如果解析日期,则解析默认的日期类列。</target>
        </trans-unit>
        <trans-unit id="4884f91f4d98371473cdc16c244105fb8fec04f3" translate="yes" xml:space="preserve">
          <source>If parsing succeeded. Return type depends on input:</source>
          <target state="translated">如果解析成功。返回类型取决于输入。</target>
        </trans-unit>
        <trans-unit id="72335770581c60c00751461ab89cd0b5ee370293" translate="yes" xml:space="preserve">
          <source>If passed &amp;lsquo;all&amp;rsquo; or</source>
          <target state="translated">如果通过&amp;ldquo;全部&amp;rdquo;或</target>
        </trans-unit>
        <trans-unit id="6ab98323b9cd6c707ec25d2e47620cf585b844dc" translate="yes" xml:space="preserve">
          <source>If passed &amp;lsquo;all&amp;rsquo; or &lt;code&gt;True&lt;/code&gt;, will normalize over all values.</source>
          <target state="translated">如果通过'all'或 &lt;code&gt;True&lt;/code&gt; ，将对所有值进行标准化。</target>
        </trans-unit>
        <trans-unit id="a89a0012ee03a22f72bd2860e27eba43a13982b3" translate="yes" xml:space="preserve">
          <source>If passed &amp;lsquo;columns&amp;rsquo; will normalize over each column.</source>
          <target state="translated">如果通过&amp;ldquo;列&amp;rdquo;，则将在每列上进行归一化。</target>
        </trans-unit>
        <trans-unit id="e234887ca1ae0a80fa1868664dd0238d5d04ba79" translate="yes" xml:space="preserve">
          <source>If passed &amp;lsquo;index&amp;rsquo; will normalize over each row.</source>
          <target state="translated">如果通过，则&amp;ldquo; index&amp;rdquo;将对每一行进行标准化。</target>
        </trans-unit>
        <trans-unit id="95e50caaa0069694aa1cc539c06f69fd598085ff" translate="yes" xml:space="preserve">
          <source>If passed a Series will use the values of the series (NOT THE INDEX).</source>
          <target state="translated">如果通过系列,将使用系列的值(不是索引)。</target>
        </trans-unit>
        <trans-unit id="cdbafc7d17980ded598ce2f6b941b4de6b162f7f" translate="yes" xml:space="preserve">
          <source>If passed, must match number of column arrays passed.</source>
          <target state="translated">如果传递,必须与传递的列数组数量相匹配。</target>
        </trans-unit>
        <trans-unit id="f97f42e1389db9548ed46ba6d3fe5d917a8fa133" translate="yes" xml:space="preserve">
          <source>If passed, must match number of row arrays passed.</source>
          <target state="translated">如果传递,必须与传递的行数组数量相匹配。</target>
        </trans-unit>
        <trans-unit id="9fa12f2a0ca4016bad2139234c3a9ac376f53792" translate="yes" xml:space="preserve">
          <source>If passed, then used to form histograms for separate groups</source>
          <target state="translated">如果通过,则用于形成各组的直方图。</target>
        </trans-unit>
        <trans-unit id="2a4b782f57e19abcb2aa77b54645db0e489c6b42" translate="yes" xml:space="preserve">
          <source>If passed, then used to form histograms for separate groups.</source>
          <target state="translated">如果通过,则用于形成单独组的直方图。</target>
        </trans-unit>
        <trans-unit id="3b1c91474589b55c524f8116422575c56dae40f7" translate="yes" xml:space="preserve">
          <source>If passed, will be used to limit data to a subset of columns.</source>
          <target state="translated">如果通过,将用于限制数据到列的子集。</target>
        </trans-unit>
        <trans-unit id="cf13cb19b460c1c30c4e0e63d016fc04e393c052" translate="yes" xml:space="preserve">
          <source>If path_or_buf is None, returns the resulting csv format as a string. Otherwise returns None.</source>
          <target state="translated">如果path_or_buf为None,则返回字符串格式的csv。否则返回None。</target>
        </trans-unit>
        <trans-unit id="467786b2cc9f24142a326f141e5e9998e551f79b" translate="yes" xml:space="preserve">
          <source>If path_or_buf is None, returns the resulting json format as a string. Otherwise returns None.</source>
          <target state="translated">如果path_or_buf为None,则返回字符串形式的json格式。否则返回None。</target>
        </trans-unit>
        <trans-unit id="3ab35a4e69cd5e00e62bc40ef695d80398b3047f" translate="yes" xml:space="preserve">
          <source>If path_or_buf is None, returns the resulting msgpack format as a byte string. Otherwise returns None.</source>
          <target state="translated">如果 path_or_buf 是 None,则返回 msgpack 格式的字节字符串。否则返回None。</target>
        </trans-unit>
        <trans-unit id="0fe82b619e0bf64745c86d941d95a0506e74aff0" translate="yes" xml:space="preserve">
          <source>If periods is none, generated index will extend to first conforming period on or just past end argument</source>
          <target state="translated">如果句号为none,生成的索引将延伸到第一个符合条件的句号上或刚刚过去的结束参数。</target>
        </trans-unit>
        <trans-unit id="d32965fa894336b076cce4f85e7e48d5894d1d82" translate="yes" xml:space="preserve">
          <source>If periods is none, generated index will extend to first conforming time on or just past end argument</source>
          <target state="translated">如果periodes为none,生成的索引将延伸到第一个符合时间或刚刚过去的结束参数。</target>
        </trans-unit>
        <trans-unit id="9dd9779620b8974ba66618f8372fc57e4f8ce556" translate="yes" xml:space="preserve">
          <source>If provided, this parameter will override values (default or not) for the following parameters:</source>
          <target state="translated">如果提供,该参数将覆盖以下参数的值(默认或不)。</target>
        </trans-unit>
        <trans-unit id="71f980c4e25c4e9da56d7674ad6dffd737c076ee" translate="yes" xml:space="preserve">
          <source>If provided, this parameter will override values (default or not) for the following parameters: &lt;code&gt;delimiter&lt;/code&gt;, &lt;code&gt;doublequote&lt;/code&gt;, &lt;code&gt;escapechar&lt;/code&gt;, &lt;code&gt;skipinitialspace&lt;/code&gt;, &lt;code&gt;quotechar&lt;/code&gt;, and &lt;code&gt;quoting&lt;/code&gt;. If it is necessary to override values, a ParserWarning will be issued. See &lt;a href=&quot;https://docs.python.org/3/library/csv.html#csv.Dialect&quot;&gt;&lt;code&gt;csv.Dialect&lt;/code&gt;&lt;/a&gt; documentation for more details.</source>
          <target state="translated">如果提供的话，该参数将覆盖为以下参数的值（默认或不）： &lt;code&gt;delimiter&lt;/code&gt; ， &lt;code&gt;doublequote&lt;/code&gt; ， &lt;code&gt;escapechar&lt;/code&gt; ， &lt;code&gt;skipinitialspace&lt;/code&gt; ， &lt;code&gt;quotechar&lt;/code&gt; ，和 &lt;code&gt;quoting&lt;/code&gt; 。如果有必要覆盖值，则将发出ParserWarning。有关更多详细信息，请参见&lt;a href=&quot;https://docs.python.org/3/library/csv.html#csv.Dialect&quot;&gt; &lt;code&gt;csv.Dialect&lt;/code&gt; &lt;/a&gt;文档。</target>
        </trans-unit>
        <trans-unit id="be9cd18b4c26564dea3305689f1e4726a3a1fb03" translate="yes" xml:space="preserve">
          <source>If provided, this parameter will override values (default or not) for the following parameters: &lt;code&gt;delimiter&lt;/code&gt;, &lt;code&gt;doublequote&lt;/code&gt;, &lt;code&gt;escapechar&lt;/code&gt;, &lt;code&gt;skipinitialspace&lt;/code&gt;, &lt;code&gt;quotechar&lt;/code&gt;, and &lt;code&gt;quoting&lt;/code&gt;. If it is necessary to override values, a ParserWarning will be issued. See csv.Dialect documentation for more details.</source>
          <target state="translated">如果提供的话，该参数将覆盖为以下参数的值（默认或不）： &lt;code&gt;delimiter&lt;/code&gt; ， &lt;code&gt;doublequote&lt;/code&gt; ， &lt;code&gt;escapechar&lt;/code&gt; ， &lt;code&gt;skipinitialspace&lt;/code&gt; ， &lt;code&gt;quotechar&lt;/code&gt; ，和 &lt;code&gt;quoting&lt;/code&gt; 。如果有必要覆盖值，则将发出ParserWarning。有关更多详细信息，请参见csv.Dialect文档。</target>
        </trans-unit>
        <trans-unit id="a05339991167e0e6c730f03164ad020504ffa9b3" translate="yes" xml:space="preserve">
          <source>If resulting index has only 1 level left, the result will be of Index type, not MultiIndex.</source>
          <target state="translated">如果生成的索引只剩下1层,结果将是索引类型,而不是MultiIndex。</target>
        </trans-unit>
        <trans-unit id="1d17d6d3193f2c431cd73525c42fc1232029c3d2" translate="yes" xml:space="preserve">
          <source>If returning an ExtensionArray, then</source>
          <target state="translated">如果返回一个ExtensionArray,那么</target>
        </trans-unit>
        <trans-unit id="3e064bce4d5d267a12f81f957574e39d35faa28b" translate="yes" xml:space="preserve">
          <source>If set to None, the number of items to be printed is unlimited. [default: 100] [currently: 100]</source>
          <target state="translated">如果设置为 &quot;无&quot;,则打印的项目数量不受限制。[默认值:100][当前值:100]。</target>
        </trans-unit>
        <trans-unit id="881d4fbdc1e7a8b7ba5ab81f1479cb45ced59e14" translate="yes" xml:space="preserve">
          <source>If set to None, the number of items to be printed is unlimited. [default: 100] [currently: 100]display.memory_usage : bool, string or None This specifies if the memory usage of a DataFrame should be displayed when df.info() is called. Valid values True,False,&amp;rsquo;deep&amp;rsquo; [default: True] [currently: True]display.min_rows : int The numbers of rows to show in a truncated view (when &lt;code&gt;max_rows&lt;/code&gt; is exceeded). Ignored when &lt;code&gt;max_rows&lt;/code&gt; is set to None or 0. When set to None, follows the value of &lt;code&gt;max_rows&lt;/code&gt;. [default: 10] [currently: 10]display.multi_sparse : boolean &amp;ldquo;sparsify&amp;rdquo; MultiIndex display (don&amp;rsquo;t display repeated elements in outer levels within groups) [default: True] [currently: True]display.notebook_repr_html : boolean When True, IPython notebook will use html representation for pandas objects (if it is available). [default: True] [currently: True]display.pprint_nest_depth : int Controls the number of nested levels to process when pretty-printing [default: 3] [currently: 3]display.precision : int Floating point output precision (number of significant digits). This is only a suggestion [default: 6] [currently: 6]display.show_dimensions : boolean or &amp;lsquo;truncate&amp;rsquo; Whether to print out dimensions at the end of DataFrame repr. If &amp;lsquo;truncate&amp;rsquo; is specified, only print out the dimensions if the frame is truncated (e.g. not display all rows and/or columns) [default: truncate] [currently: truncate]display.unicode.ambiguous_as_wide : boolean Whether to use the Unicode East Asian Width to calculate the display text width. Enabling this may affect to the performance (default: False) [default: False] [currently: False]display.unicode.east_asian_width : boolean Whether to use the Unicode East Asian Width to calculate the display text width. Enabling this may affect to the performance (default: False) [default: False] [currently: False]display.width : int Width of the display in characters. In case python/IPython is running in a terminal this can be set to None and pandas will correctly auto-detect the width. Note that the IPython notebook, IPython qtconsole, or IDLE do not run in a terminal and hence it is not possible to correctly detect the width. [default: 80] [currently: 80]io.excel.ods.reader : string The default Excel reader engine for &amp;lsquo;ods&amp;rsquo; files. Available options: auto, odf. [default: auto] [currently: auto]io.excel.xls.reader : string The default Excel reader engine for &amp;lsquo;xls&amp;rsquo; files. Available options: auto, xlrd. [default: auto] [currently: auto]io.excel.xls.writer : string The default Excel writer engine for &amp;lsquo;xls&amp;rsquo; files. Available options: auto, xlwt. [default: auto] [currently: auto]io.excel.xlsm.reader : string The default Excel reader engine for &amp;lsquo;xlsm&amp;rsquo; files. Available options: auto, xlrd, openpyxl. [default: auto] [currently: auto]io.excel.xlsm.writer : string The default Excel writer engine for &amp;lsquo;xlsm&amp;rsquo; files. Available options: auto, openpyxl. [default: auto] [currently: auto]io.excel.xlsx.reader : string The default Excel reader engine for &amp;lsquo;xlsx&amp;rsquo; files. Available options: auto, xlrd, openpyxl. [default: auto] [currently: auto]io.excel.xlsx.writer : string The default Excel writer engine for &amp;lsquo;xlsx&amp;rsquo; files. Available options: auto, openpyxl, xlsxwriter. [default: auto] [currently: auto]io.hdf.default_format : format default format writing format, if None, then put will default to &amp;lsquo;fixed&amp;rsquo; and append will default to &amp;lsquo;table&amp;rsquo; [default: None] [currently: None]io.hdf.dropna_table : boolean drop ALL nan rows when appending to a table [default: False] [currently: False]io.parquet.engine : string The default parquet reader/writer engine. Available options: &amp;lsquo;auto&amp;rsquo;, &amp;lsquo;pyarrow&amp;rsquo;, &amp;lsquo;fastparquet&amp;rsquo;, the default is &amp;lsquo;auto&amp;rsquo; [default: auto] [currently: auto]mode.chained_assignment : string Raise an exception, warn, or no action if trying to use chained assignment, The default is warn [default: warn] [currently: warn]mode.sim_interactive : boolean Whether to simulate interactive mode for purposes of testing [default: False] [currently: False]mode.use_inf_as_na : boolean True means treat None, NaN, INF, -INF as NA (old way), False means None and NaN are null, but INF, -INF are not NA (new way). [default: False] [currently: False]mode.use_inf_as_null : boolean use_inf_as_null had been deprecated and will be removed in a future version. Use &lt;code&gt;use_inf_as_na&lt;/code&gt; instead. [default: False] [currently: False] (Deprecated, use &lt;code&gt;mode.use_inf_as_na&lt;/code&gt; instead.)plotting.backend : str The plotting backend to use. The default value is &amp;ldquo;matplotlib&amp;rdquo;, the backend provided with pandas. Other backends can be specified by prodiving the name of the module that implements the backend. [default: matplotlib] [currently: matplotlib]plotting.matplotlib.register_converters : bool Whether to register converters with matplotlib&amp;rsquo;s units registry for dates, times, datetimes, and Periods. Toggling to False will remove the converters, restoring any converters that pandas overwrote. [default: True] [currently: True]</source>
          <target state="translated">如果设置为&amp;ldquo;无&amp;rdquo;，则要打印的项目数不受限制。 [默认：100] [当前：100] display.memory_usage：bool，字符串或无这指定在调用df.info（）时是否应显示DataFrame的内存使用情况。有效值True，False，'deep'[默认值：True] [当前：True] display.min_rows：int在截断视图中显示的行数（超过 &lt;code&gt;max_rows&lt;/code&gt; 时）。当 &lt;code&gt;max_rows&lt;/code&gt; 设置为None或0时被忽略。设置为None时，遵循 &lt;code&gt;max_rows&lt;/code&gt; 的值。 [默认：10] [当前：10] display.multi_sparse：布尔值&amp;ldquo; sparsify&amp;rdquo; MultiIndex显示（不显示组中外部级别的重复元素）[默认值：True] [当前：True] display.notebook_repr_html：boolean ，IPython Notebook将为熊猫对象使用html表示形式（如果可用）。 [默认：True] [当前：True] display.pprint_nest_depth：int控制漂亮打印时要处理的嵌套层数[默认：3] [当前：3] display.precision：int浮点输出精度（有效位数）数字）。这只是一个建议[默认：6] [当前：6] display.show_dimensions：布尔值或'truncate'是否在DataFrame表示的末尾打印尺寸。如果指定了&amp;ldquo; truncate&amp;rdquo;，则仅在框架被截断时打印出尺寸（例如不显示所有行和/或列）[默认值：截断] [当前：截断] display.unicode.ambiguous_as_wide：布尔值是否使用Unicode East Asian Width计算显示文本的宽度。启用它可能会影响性能（默认：False）[默认：False] [当前：False] display.unicode.east_asian_width：boolean是否使用Unicode East Asian Width计算显示文本的宽度。启用它可能会影响性能（默认：False）[默认：False] [当前：False] display.width：int以字符为单位的显示宽度。如果python / IPython在终端中运行，则可以将其设置为None，而pandas将正确地自动检测宽度。请注意，IPython笔记本，IPython qtconsole或IDLE不在终端中运行，因此无法正确检测宽度。 [默认：80] [当前：80] io.excel.ods.reader：string'ods'文件的默认Excel阅读器引擎。可用选项：自动，odf。 [默认：自动] [当前：自动] io.excel.xls.reader：字符串&amp;ldquo; xls&amp;rdquo;文件的默认Excel阅读器引擎。可用选项：自动，xlrd。 [默认：自动] [当前：自动] io.excel.xls.writer：字符串&amp;ldquo; xls&amp;rdquo;文件的默认Excel编写器引擎。可用选项：自动，xlwt。 [默认：自动] [当前：自动] io.excel.xlsm.reader：字符串&amp;ldquo; xlsm&amp;rdquo;文件的默认Excel阅读器引擎。可用选项：自动，xlrd，openpyxl。 [默认：自动] [当前：自动] io.excel.xlsm.writer：字符串'xlsm'文件的默认Excel编写器引擎。可用选项：自动，openpyxl。 [默认：自动] [当前：自动] io.excel.xlsx.reader：字符串&amp;ldquo; xlsx&amp;rdquo;文件的默认Excel阅读器引擎。可用选项：自动，xlrd，openpyxl。 [默认：自动] [当前：自动] io.excel.xlsx.writer：字符串&amp;ldquo; xlsx&amp;rdquo;文件的默认Excel编写器引擎。可用选项：自动，openpyxl，xlsxwriter。 [默认：自动] [当前：自动] io.hdf.default_format：格式化默认格式写入格式，如果为None，则put将默认为'fixed'，append将默认为'table'[default：None] [当前：None ] io.hdf.dropna_table：布尔值追加到表时丢弃所有nan行[默认值：False] [当前：False] io.parquet.engine：字符串默认的实木复合地板读取器/写入器引擎。可用选项：'auto'，'pyarrow'，'fastparquet'，默认值为'auto'[默认值：auto] [当前：自动] mode.chained_assignment：string引发异常，警告或尝试使用链接时不采取任何措施分配，默认为warn [默认：warn] [当前：warn] mode.sim_interactive：boolean是否出于测试目的模拟交互模式[默认值：False] [当前：False] mode.use_inf_as_na：布尔值True表示将None，NaN，INF，-INF视为NA（旧方式），False表示None和NaN为空，但INF，-INF不是NA（新方法）。 [默认值：False] [当前：False] mode.use_inf_as_null：布尔值use_inf_as_null已被弃用，并将在以后的版本中删除。用 &lt;code&gt;use_inf_as_na&lt;/code&gt; 代替。 [默认：False] [当前：False]（不建议使用，请使用 &lt;code&gt;mode.use_inf_as_na&lt;/code&gt; 。）plotting.backend：str要使用的绘图后端。默认值为&amp;ldquo; matplotlib&amp;rdquo;，这是熊猫提供的后端。可以通过扩展实现该后端的模块的名称来指定其他后端。 [默认：matplotlib] [当前：matplotlib] plotting.matplotlib.register_converters：bool是否在matplotlib的单位注册表中注册日期，时间，日期时间和期间的转换器。切换为False将删除转换器，恢复所有熊猫重写的转换器。 [默认：真] [当前：真]</target>
        </trans-unit>
        <trans-unit id="4983fff342fff2155fda50539177d2d395cc41ca" translate="yes" xml:space="preserve">
          <source>If set to a float value, all float values smaller then the given threshold will be displayed as exactly 0 by repr and friends.</source>
          <target state="translated">如果设置为浮动值,所有小于给定阈值的浮动值都会被repr和朋友们显示为0。</target>
        </trans-unit>
        <trans-unit id="ae05e640370b98c99c2eb61bf5fe03e0f6a770c7" translate="yes" xml:space="preserve">
          <source>If set, limit the maximum number of rows to fetch from the query results.</source>
          <target state="translated">如果设置,限制从查询结果中获取的最大行数。</target>
        </trans-unit>
        <trans-unit id="db0453700b5f3a81a6b68576ac4ef69d3f6c097f" translate="yes" xml:space="preserve">
          <source>If set, use the &lt;a href=&quot;https://tqdm.github.io/&quot;&gt;tqdm&lt;/a&gt; library to display a progress bar while the data downloads. Install the &lt;code&gt;tqdm&lt;/code&gt; package to use this feature.</source>
          <target state="translated">如果已设置，请在下载数据时使用&lt;a href=&quot;https://tqdm.github.io/&quot;&gt;tqdm&lt;/a&gt;库显示进度条。安装 &lt;code&gt;tqdm&lt;/code&gt; 软件包以使用此功能。</target>
        </trans-unit>
        <trans-unit id="fa12ba58c2be2f71104408a510d4489d9b0c6ffa" translate="yes" xml:space="preserve">
          <source>If specified changes the x-axis label size</source>
          <target state="translated">如果指定,则改变X轴标签的大小。</target>
        </trans-unit>
        <trans-unit id="97863624dbef3656142375cfc414d8c6db270d6b" translate="yes" xml:space="preserve">
          <source>If specified changes the x-axis label size.</source>
          <target state="translated">如果指定,则改变X轴的标签大小。</target>
        </trans-unit>
        <trans-unit id="9a7873740ccf0410b3fb0bea93346ff13ec92e92" translate="yes" xml:space="preserve">
          <source>If specified changes the y-axis label size</source>
          <target state="translated">如果指定,则改变Y轴标签的大小。</target>
        </trans-unit>
        <trans-unit id="581f8ddceda8e96b28aea9467091a054fc8fcba4" translate="yes" xml:space="preserve">
          <source>If specified changes the y-axis label size.</source>
          <target state="translated">如果指定,则改变Y轴标签的大小。</target>
        </trans-unit>
        <trans-unit id="fc3648b96e279d94f92a6ee0971122e6704390a3" translate="yes" xml:space="preserve">
          <source>If specified only options matching</source>
          <target state="translated">如果指定了,则只有符合以下条件的选项</target>
        </trans-unit>
        <trans-unit id="7820aaef54858d9fe6f835280f13f8d7b53a28bd" translate="yes" xml:space="preserve">
          <source>If specified only options matching &lt;code&gt;prefix*&lt;/code&gt; will be reset. Note: partial matches are supported for convenience, but unless you use the full option name (e.g. x.y.z.option_name), your code may break in future versions if new options with similar names are introduced.</source>
          <target state="translated">如果指定，则仅匹配 &lt;code&gt;prefix*&lt;/code&gt; 选项将被重置。注意：为方便起见，支持部分匹配，但是除非使用完整的选项名称（egxyzoption_name），否则如果引入具有相似名称的新选项，则代码可能会在将来的版本中中断。</target>
        </trans-unit>
        <trans-unit id="fbfd3a88eab2f247413e17f672c68ad4e5e49adc" translate="yes" xml:space="preserve">
          <source>If specified, &lt;strong&gt;fill&lt;/strong&gt; data for missing labels using logic (highly relevant to working with time series data)</source>
          <target state="translated">如果指定，则使用逻辑&lt;strong&gt;填充&lt;/strong&gt;缺失标签的数据（与使用时间序列数据高度相关）</target>
        </trans-unit>
        <trans-unit id="1e2fd14b30360e01bd1925a87fecdb829dae8c45" translate="yes" xml:space="preserve">
          <source>If specified, checks if merge is of specified type.</source>
          <target state="translated">如果指定,则检查是否为指定类型的合并。</target>
        </trans-unit>
        <trans-unit id="72c2f9cefac58e113fc2c842ab3415610081df06" translate="yes" xml:space="preserve">
          <source>If specified, requires</source>
          <target state="translated">如果指定,需要</target>
        </trans-unit>
        <trans-unit id="195f4d58de033a32ef9e0ed103f9771ba227ede5" translate="yes" xml:space="preserve">
          <source>If specified, requires &lt;code&gt;values&lt;/code&gt; be specified as well.</source>
          <target state="translated">如果指定，则还需要指定 &lt;code&gt;values&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b8ff89eb07dddd54f2f0304a34009cfe5e81e653" translate="yes" xml:space="preserve">
          <source>If specified, return an iterator where</source>
          <target state="translated">如果指定,返回一个迭代器,其中</target>
        </trans-unit>
        <trans-unit id="50b212e57ff80a7164ca948bedf3a2c591bca4f5" translate="yes" xml:space="preserve">
          <source>If specified, return an iterator where &lt;code&gt;chunksize&lt;/code&gt; is the number of rows to include in each chunk.</source>
          <target state="translated">如果指定，则返回一个迭代器，其中 &lt;code&gt;chunksize&lt;/code&gt; 是每个块中要包括的行数。</target>
        </trans-unit>
        <trans-unit id="0082373421092da175dee8a9b93a4ccc4f6ac2a4" translate="yes" xml:space="preserve">
          <source>If specified, returns an iterator where</source>
          <target state="translated">如果指定,返回一个迭代器,其中</target>
        </trans-unit>
        <trans-unit id="78439b54e5e60a975149f48cea5f22c188ad305b" translate="yes" xml:space="preserve">
          <source>If specified, returns an iterator where &lt;code&gt;chunksize&lt;/code&gt; is the number of rows to include in each chunk.</source>
          <target state="translated">如果指定，则返回一个迭代器，其中 &lt;code&gt;chunksize&lt;/code&gt; 是每个块中要包括的行数。</target>
        </trans-unit>
        <trans-unit id="999348edd253a275c024b1092f6c830ad7d41693" translate="yes" xml:space="preserve">
          <source>If str, it will be considered as a path to a file. Info will be written to that file in JSON format.</source>
          <target state="translated">如果是str,它将被认为是一个文件的路径。信息将以JSON格式写入该文件。</target>
        </trans-unit>
        <trans-unit id="4ce81a105f24afb5e0f2c0a1d42b5a9e99140d42" translate="yes" xml:space="preserve">
          <source>If str, represents compression mode. If dict, value at &amp;lsquo;method&amp;rsquo; is the compression mode. Compression mode may be any of the following possible values: {&amp;lsquo;infer&amp;rsquo;, &amp;lsquo;gzip&amp;rsquo;, &amp;lsquo;bz2&amp;rsquo;, &amp;lsquo;zip&amp;rsquo;, &amp;lsquo;xz&amp;rsquo;, None}. If compression mode is &amp;lsquo;infer&amp;rsquo; and</source>
          <target state="translated">如果为str，则表示压缩模式。如果是dict，则&amp;ldquo;方法&amp;rdquo;中的值是压缩模式。压缩模式可以是以下任何可能的值：{'infer'，'gzip'，'bz2'，'zip'，'xz'，None}。如果压缩模式为&amp;ldquo;推断&amp;rdquo;，则</target>
        </trans-unit>
        <trans-unit id="657e48eb3a4d68a611327f580edbd21c7f670eb9" translate="yes" xml:space="preserve">
          <source>If str, the name of the column in the DataFrame representing the times.</source>
          <target state="translated">如果是str,则是DataFrame中代表时间的列名。</target>
        </trans-unit>
        <trans-unit id="04bcdac7e76a787e1fbea8ae01f3869fac3ea6f8" translate="yes" xml:space="preserve">
          <source>If str, then indicates comma separated list of Excel column letters and column ranges (e.g. &amp;ldquo;A:E&amp;rdquo; or &amp;ldquo;A,C,E:F&amp;rdquo;). Ranges are inclusive of both sides.</source>
          <target state="translated">如果为str，则表示Excel列字母和列范围的逗号分隔列表（例如&amp;ldquo; A：E&amp;rdquo;或&amp;ldquo; A，C，E：F&amp;rdquo;）。范围包括双方。</target>
        </trans-unit>
        <trans-unit id="9da6ca18cdc6eec7c4db6f8861692e993483053b" translate="yes" xml:space="preserve">
          <source>If such a function works, please file a bug at &lt;a href=&quot;https://github.com/pandas-dev/pandas&quot;&gt;https://github.com/pandas-dev/pandas&lt;/a&gt;!</source>
          <target state="translated">如果此功能有效，请在&lt;a href=&quot;https://github.com/pandas-dev/pandas&quot;&gt;https://github.com/pandas-dev/pandas&lt;/a&gt;提交错误！</target>
        </trans-unit>
        <trans-unit id="00eda6030f8870181f3ae042945f9f88a8227cb5" translate="yes" xml:space="preserve">
          <source>If supplying a list, each individual table_style should be a dictionary with &lt;code&gt;selector&lt;/code&gt; and &lt;code&gt;props&lt;/code&gt; keys. &lt;code&gt;selector&lt;/code&gt; should be a CSS selector that the style will be applied to (automatically prefixed by the table&amp;rsquo;s UUID) and &lt;code&gt;props&lt;/code&gt; should be a list of tuples with &lt;code&gt;(attribute, value)&lt;/code&gt;. If supplying a dict, the dict keys should correspond to column names or index values, depending upon the specified</source>
          <target state="translated">如果提供列表，则每个table_style应该是带有 &lt;code&gt;selector&lt;/code&gt; 和 &lt;code&gt;props&lt;/code&gt; 键的字典。 &lt;code&gt;selector&lt;/code&gt; 应该是样式将应用到的CSS选择器（由表的UUID自动添加前缀），而 &lt;code&gt;props&lt;/code&gt; 应该是具有 &lt;code&gt;(attribute, value)&lt;/code&gt; 的元组列表。如果提供dict，则dict键应对应于列名或索引值，具体取决于指定的</target>
        </trans-unit>
        <trans-unit id="a6e8edc6bf86da535a40f6cb6e96a6e8c7af0dcb" translate="yes" xml:space="preserve">
          <source>If table exists raise pandas_gbq.gbq.TableCreationError.</source>
          <target state="translated">如果表存在,就会引发pandas_gbq.gbq.TableCreationError。</target>
        </trans-unit>
        <trans-unit id="f4a7f4d474e4d7426374eb27e2b8239df04809bb" translate="yes" xml:space="preserve">
          <source>If table exists, do nothing.</source>
          <target state="translated">如果表格存在,什么都不做。</target>
        </trans-unit>
        <trans-unit id="2ca3b25179b041d34301bc35b333ae308c33e09c" translate="yes" xml:space="preserve">
          <source>If table exists, drop it, recreate it, and insert data.</source>
          <target state="translated">如果表存在,将其删除,重新创建,并插入数据。</target>
        </trans-unit>
        <trans-unit id="8c60747c3d8c8c498c4f7ba4c804063996419ee9" translate="yes" xml:space="preserve">
          <source>If table exists, insert data. Create if does not exist.</source>
          <target state="translated">如果表存在,插入数据。如果不存在,则创建。</target>
        </trans-unit>
        <trans-unit id="2042ba3d5eaacecb710b9e13fa4e5db8076a696a" translate="yes" xml:space="preserve">
          <source>If that condition is not satisfied, a join with two multi-indexes can be done using the following code.</source>
          <target state="translated">如果不满足该条件,可以使用下面的代码进行两个多索引的连接。</target>
        </trans-unit>
        <trans-unit id="7806b6b94836ae0ac10b4b506a0d107772af3b21" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;'numba'&lt;/code&gt; engine is chosen, the function must be a user defined function with &lt;code&gt;values&lt;/code&gt; and &lt;code&gt;index&lt;/code&gt; as the first and second arguments respectively in the function signature. Each group&amp;rsquo;s index will be passed to the user defined function and optionally available for use.</source>
          <target state="translated">如果选择了 &lt;code&gt;'numba'&lt;/code&gt; 引擎，则该函数必须是用户定义的函数，其 &lt;code&gt;values&lt;/code&gt; 和 &lt;code&gt;index&lt;/code&gt; 分别作为函数签名中的第一个和第二个参数。每个组的索引将传递给用户定义的函数，并且可以选择使用。</target>
        </trans-unit>
        <trans-unit id="dbdf454f40b0c45a027c499e77bdb6113f2b6c7d" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;Categorical&lt;/code&gt; is not ordered, &lt;a href=&quot;../reference/api/pandas.series.min#pandas.Series.min&quot;&gt;&lt;code&gt;Series.min()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../reference/api/pandas.series.max#pandas.Series.max&quot;&gt;&lt;code&gt;Series.max()&lt;/code&gt;&lt;/a&gt; will raise &lt;code&gt;TypeError&lt;/code&gt;. Numeric operations like &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;/&lt;/code&gt; and operations based on them (e.g. &lt;a href=&quot;../reference/api/pandas.series.median#pandas.Series.median&quot;&gt;&lt;code&gt;Series.median()&lt;/code&gt;&lt;/a&gt;, which would need to compute the mean between two values if the length of an array is even) do not work and raise a &lt;code&gt;TypeError&lt;/code&gt;.</source>
          <target state="translated">如果未订购 &lt;code&gt;Categorical&lt;/code&gt; ，则&lt;a href=&quot;../reference/api/pandas.series.min#pandas.Series.min&quot;&gt; &lt;code&gt;Series.min()&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../reference/api/pandas.series.max#pandas.Series.max&quot;&gt; &lt;code&gt;Series.max()&lt;/code&gt; &lt;/a&gt;将引发 &lt;code&gt;TypeError&lt;/code&gt; 。诸如 &lt;code&gt;+&lt;/code&gt; ， &lt;code&gt;-&lt;/code&gt; ， &lt;code&gt;*&lt;/code&gt; 和 &lt;code&gt;/&lt;/code&gt; 的数值运算以及基于它们的运算（例如&lt;a href=&quot;../reference/api/pandas.series.median#pandas.Series.median&quot;&gt; &lt;code&gt;Series.median()&lt;/code&gt; &lt;/a&gt;，如果数组的长度为偶数，则需要计算两个值之间的平均值）不起作用，并引发 &lt;code&gt;TypeError&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5d3f807d7903fe4db8bb66d5321128e42d669a89" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;MultiIndex&lt;/code&gt; levels names are &lt;code&gt;None&lt;/code&gt;, the levels are automatically made available via the &lt;code&gt;level_n&lt;/code&gt; keyword with &lt;code&gt;n&lt;/code&gt; the level of the &lt;code&gt;MultiIndex&lt;/code&gt; you want to select from.</source>
          <target state="translated">如果 &lt;code&gt;MultiIndex&lt;/code&gt; 级别名称为 &lt;code&gt;None&lt;/code&gt; ，则可以通过 &lt;code&gt;level_n&lt;/code&gt; 关键字自动将级别变为可用，其中 &lt;code&gt;n&lt;/code&gt; 是您要从中选择的 &lt;code&gt;MultiIndex&lt;/code&gt; 级别。</target>
        </trans-unit>
        <trans-unit id="c8c94091f3e6317915c8bf08e4e19200411544ff" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;bins&lt;/code&gt; keyword is an &lt;code&gt;IntervalIndex&lt;/code&gt;, then these will be used to bin the passed data.:</source>
          <target state="translated">如果 &lt;code&gt;bins&lt;/code&gt; 关键字是 &lt;code&gt;IntervalIndex&lt;/code&gt; ，那么这些将用于对传递的数据进行装箱：</target>
        </trans-unit>
        <trans-unit id="4e6fc9dc69af6ac9bd02208d524cc26f9590d304" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;bins&lt;/code&gt; keyword is an integer, then equal-width bins are formed. Alternatively we can specify custom bin-edges:</source>
          <target state="translated">如果 &lt;code&gt;bins&lt;/code&gt; 关键字是整数，则将形成等宽的bin。或者，我们可以指定自定义bin-edges：</target>
        </trans-unit>
        <trans-unit id="2283dad6d1e4f0ad9f7a475c923728b16127b882" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;comment&lt;/code&gt; parameter is specified, then completely commented lines will be ignored. By default, completely blank lines will be ignored as well.</source>
          <target state="translated">如果指定了 &lt;code&gt;comment&lt;/code&gt; 参数，则将完全注释掉的行。默认情况下，完全空白行也将被忽略。</target>
        </trans-unit>
        <trans-unit id="398ce981deb02bcf84891cf39753b3a46345bf90" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;join&lt;/code&gt; keyword is not passed, the method &lt;a href=&quot;../reference/api/pandas.series.str.cat#pandas.Series.str.cat&quot;&gt;&lt;code&gt;cat()&lt;/code&gt;&lt;/a&gt; will currently fall back to the behavior before version 0.23.0 (i.e. no alignment), but a &lt;code&gt;FutureWarning&lt;/code&gt; will be raised if any of the involved indexes differ, since this default will change to &lt;code&gt;join='left'&lt;/code&gt; in a future version.</source>
          <target state="translated">如果未传递 &lt;code&gt;join&lt;/code&gt; 关键字，则&lt;a href=&quot;../reference/api/pandas.series.str.cat#pandas.Series.str.cat&quot;&gt; &lt;code&gt;cat()&lt;/code&gt; &lt;/a&gt;方法当前将退回到0.23.0版之前的行为（即不对齐），但是如果任何涉及的索引不同，则会引发 &lt;code&gt;FutureWarning&lt;/code&gt; ，因为此默认值将更改以 &lt;code&gt;join='left'&lt;/code&gt; 在未来的版本。</target>
        </trans-unit>
        <trans-unit id="cb65b84a0ed9ca7d9ee485a9567cc369b8c9fcac" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;values&lt;/code&gt; argument is omitted, and the input &lt;code&gt;DataFrame&lt;/code&gt; has more than one column of values which are not used as column or index inputs to &lt;code&gt;pivot&lt;/code&gt;, then the resulting &amp;ldquo;pivoted&amp;rdquo; &lt;code&gt;DataFrame&lt;/code&gt; will have &lt;a href=&quot;advanced#advanced-hierarchical&quot;&gt;hierarchical columns&lt;/a&gt; whose topmost level indicates the respective value column:</source>
          <target state="translated">如果省略 &lt;code&gt;values&lt;/code&gt; 参数，并且输入 &lt;code&gt;DataFrame&lt;/code&gt; 具有多于一列的值，这些值不用作 &lt;code&gt;pivot&lt;/code&gt; 列或索引输入，那么生成的&amp;ldquo; 透视 &amp;rdquo; &lt;code&gt;DataFrame&lt;/code&gt; 将具有&lt;a href=&quot;advanced#advanced-hierarchical&quot;&gt;层次结构的列，&lt;/a&gt;其最高层指示相应的值列：</target>
        </trans-unit>
        <trans-unit id="fa8a2744eb24887cc6fb10a04b4424c9fbb9186e" translate="yes" xml:space="preserve">
          <source>If the DST transition causes nonexistent times, you can shift these dates forward or backward with a timedelta object or</source>
          <target state="translated">如果DST转换导致了不存在的时间,你可以用timedelta对象或用</target>
        </trans-unit>
        <trans-unit id="6472e80c2a9dc53f51fd601d89084b2d1b47e172" translate="yes" xml:space="preserve">
          <source>If the DST transition causes nonexistent times, you can shift these dates forward or backwards with a timedelta object or</source>
          <target state="translated">如果DST转换导致了不存在的时间,你可以用timedelta对象或用</target>
        </trans-unit>
        <trans-unit id="42ecf87fc244588bee56119972b559fcabe156fa" translate="yes" xml:space="preserve">
          <source>If the DST transition causes nonexistent times, you can shift these dates forward or backwards with a timedelta object or &lt;code&gt;&amp;lsquo;shift_forward&amp;rsquo;&lt;/code&gt; or &lt;code&gt;&amp;lsquo;shift_backwards&amp;rsquo;&lt;/code&gt;. &amp;gt;&amp;gt;&amp;gt; s = pd.Series(range(2), index=pd.DatetimeIndex([ &amp;hellip; &amp;lsquo;2015-03-29 02:30:00&amp;rsquo;, &amp;hellip; &amp;lsquo;2015-03-29 03:30:00&amp;rsquo;])) &amp;gt;&amp;gt;&amp;gt; s.tz_localize(&amp;lsquo;Europe/Warsaw&amp;rsquo;, nonexistent=&amp;rsquo;shift_forward&amp;rsquo;) 2015-03-29 03:00:00+02:00 0 2015-03-29 03:30:00+02:00 1 dtype: int64 &amp;gt;&amp;gt;&amp;gt; s.tz_localize(&amp;lsquo;Europe/Warsaw&amp;rsquo;, nonexistent=&amp;rsquo;shift_backward&amp;rsquo;) 2015-03-29 01:59:59.999999999+01:00 0 2015-03-29 03:30:00+02:00 1 dtype: int64 &amp;gt;&amp;gt;&amp;gt; s.tz_localize(&amp;lsquo;Europe/Warsaw&amp;rsquo;, nonexistent=pd.Timedelta(&amp;lsquo;1H&amp;rsquo;)) 2015-03-29 03:30:00+02:00 0 2015-03-29 03:30:00+02:00 1 dtype: int64</source>
          <target state="translated">如果DST过渡导致不存在时间，则可以使用timedelta对象或 &lt;code&gt;&amp;lsquo;shift_forward&amp;rsquo;&lt;/code&gt; 或 &lt;code&gt;&amp;lsquo;shift_backwards&amp;rsquo;&lt;/code&gt; 将这些日期向前或向后移动。 &amp;gt;&amp;gt;&amp;gt; s = pd.Series（range（2），index = pd.DatetimeIndex（[&amp;hellip;'2015-03-29 02:30:00'，&amp;hellip;'2015-03-29 03:30:00']） ）&amp;gt;&amp;gt;&amp;gt; s.tz_localize（'欧洲/华沙，不存在='shift_forward'）2015-03-29 03：00：00 + 02：00 0 2015-03-29 03：30：00 + 02：00 1 dtype：int64 &amp;gt;&amp;gt;&amp;gt; s.tz_localize（'欧洲/华沙，不存在='shift_backward'）2015-03-29 01：59：59.999999999 + 01：00 0 2015-03-29 03：30：00 + 02： 00 1 dtype：int64 &amp;gt;&amp;gt;&amp;gt; s.tz_localize（'欧洲/华沙'，不存在= pd.Timedelta（'1H'））2015-03-29 03：30：00 + 02：00 0 2015-03-29 03 ：30：00 + 02：00 1 dtype：int64</target>
        </trans-unit>
        <trans-unit id="1efef3e25f01393c1708b5d04424ad93e6acad6e" translate="yes" xml:space="preserve">
          <source>If the DST transition causes nonexistent times, you can shift these dates forward or backwards with a timedelta object or &lt;code&gt;&amp;lsquo;shift_forward&amp;rsquo;&lt;/code&gt; or &lt;code&gt;&amp;lsquo;shift_backwards&amp;rsquo;&lt;/code&gt;. &amp;gt;&amp;gt;&amp;gt; s = pd.to_datetime(pd.Series([&amp;lsquo;2015-03-29 02:30:00&amp;rsquo;, &amp;hellip; &amp;lsquo;2015-03-29 03:30:00&amp;rsquo;])) &amp;gt;&amp;gt;&amp;gt; s.dt.tz_localize(&amp;lsquo;Europe/Warsaw&amp;rsquo;, nonexistent=&amp;rsquo;shift_forward&amp;rsquo;) 0 2015-03-29 03:00:00+02:00 1 2015-03-29 03:30:00+02:00 dtype: datetime64[ns, &amp;lsquo;Europe/Warsaw&amp;rsquo;] &amp;gt;&amp;gt;&amp;gt; s.dt.tz_localize(&amp;lsquo;Europe/Warsaw&amp;rsquo;, nonexistent=&amp;rsquo;shift_backward&amp;rsquo;) 0 2015-03-29 01:59:59.999999999+01:00 1 2015-03-29 03:30:00+02:00 dtype: datetime64[ns, &amp;lsquo;Europe/Warsaw&amp;rsquo;] &amp;gt;&amp;gt;&amp;gt; s.dt.tz_localize(&amp;lsquo;Europe/Warsaw&amp;rsquo;, nonexistent=pd.Timedelta(&amp;lsquo;1H&amp;rsquo;)) 0 2015-03-29 03:30:00+02:00 1 2015-03-29 03:30:00+02:00 dtype: datetime64[ns, &amp;lsquo;Europe/Warsaw&amp;rsquo;]</source>
          <target state="translated">如果DST过渡导致不存在时间，则可以使用timedelta对象或 &lt;code&gt;&amp;lsquo;shift_forward&amp;rsquo;&lt;/code&gt; 或 &lt;code&gt;&amp;lsquo;shift_backwards&amp;rsquo;&lt;/code&gt; 将这些日期向前或向后移动。 &amp;gt;&amp;gt;&amp;gt; s = pd.to_datetime（pd.Series（['2015-03-29 02:30:00'，&amp;hellip;'2015-03-29 03:30:00']））&amp;gt;&amp;gt;&amp;gt; s.dt tz_localize（'欧洲/华沙'，不存在='shift_forward'）0 2015-03-29 03：00：00 + 02：00 1 2015-03-29 03：30：00 + 02：00 dtype：datetime64 [ns， '欧洲/华沙'] &amp;gt;&amp;gt;&amp;gt; s.dt.tz_localize（'欧洲/华沙，不存在='shift_backward'）0 2015-03-29 01：59：59.999999999 + 01：00 1 2015-03-29 03： 30：00 + 02：00 dtype：datetime64 [ns，'Europe / Warsaw'] &amp;gt;&amp;gt;&amp;gt; s.dt.tz_localize（'Europe / Warsaw'，不存在= pd.Timedelta（'1H'））0 2015-03- 29 03：30：00 + 02：00 1 2015-03-29 03：30：00 + 02：00 dtype：datetime64 [ns，'Europe / Warsaw']</target>
        </trans-unit>
        <trans-unit id="0cded44943bc29f11107a3fa48812fe3fd18029d" translate="yes" xml:space="preserve">
          <source>If the DataFrame index has no label then the recarray field name is set to &amp;lsquo;index&amp;rsquo;. If the index has a label then this is used as the field name:</source>
          <target state="translated">如果DataFrame索引没有标签，则将recarray字段名称设置为&amp;ldquo; index&amp;rdquo;。如果索引具有标签，则将其用作字段名称：</target>
        </trans-unit>
        <trans-unit id="d214ff5505dcc3df58ad0b05017eb7e67d620183" translate="yes" xml:space="preserve">
          <source>If the Datetime Array/Index is tz-aware and tz is not None.</source>
          <target state="translated">如果Datetime Array/Index是tz-aware且tz不是None。</target>
        </trans-unit>
        <trans-unit id="b9d9791f0508f684363d699b80bee52d000f007a" translate="yes" xml:space="preserve">
          <source>If the Index is a MultiIndex, drop the value when any or all levels are NaN.</source>
          <target state="translated">如果指数是一个多重指数,当任何或所有级别都是NaN时,放弃该值。</target>
        </trans-unit>
        <trans-unit id="be05eaa0dbbfb873520e230604c6d5204e61826b" translate="yes" xml:space="preserve">
          <source>If the Index objects are incompatible, both Index objects will be cast to dtype(&amp;lsquo;object&amp;rsquo;) first.</source>
          <target state="translated">如果Index对象不兼容，则两个Index对象将首先转换为dtype（'object'）。</target>
        </trans-unit>
        <trans-unit id="33e611dc7e8a5693ba6d67785cded9a86565fe9b" translate="yes" xml:space="preserve">
          <source>If the JSON serializer cannot handle the container contents directly it will fall back in the following manner:</source>
          <target state="translated">如果JSON序列器不能直接处理容器内容,它将以下列方式回落。</target>
        </trans-unit>
        <trans-unit id="40eecad766d670f6843c3a0267a49f5717901b35" translate="yes" xml:space="preserve">
          <source>If the MultiIndex has names specified, these can be passed instead of the level number:</source>
          <target state="translated">如果指定了MultiIndex的名称,则可以通过这些名称来代替级别号。</target>
        </trans-unit>
        <trans-unit id="6155bdd87909d66e388cdbb2e09aeed48e81654e" translate="yes" xml:space="preserve">
          <source>If the Pearson correlation is not well defined return &amp;lsquo;NaN&amp;rsquo;.</source>
          <target state="translated">如果没有很好定义Pearson相关，则返回&amp;ldquo; NaN&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="5ef45e6ec64f5bd071dc24f8d1e69cc1e5cd8b83" translate="yes" xml:space="preserve">
          <source>If the Pearson correlation is not well defined, then &amp;lsquo;NaN&amp;rsquo; is returned.</source>
          <target state="translated">如果没有很好地定义Pearson相关性，则返回&amp;ldquo; NaN&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="93c56163ba997d495339f68cf9109d1071720ba6" translate="yes" xml:space="preserve">
          <source>If the Series is empty.</source>
          <target state="translated">如果该系列为空。</target>
        </trans-unit>
        <trans-unit id="a8f2ab2c508af24c8a42b9be04bbb0ee02647fda" translate="yes" xml:space="preserve">
          <source>If the Series is of dtype &lt;code&gt;CategoricalDtype&lt;/code&gt;, &lt;code&gt;Series.cat&lt;/code&gt; can be used to change the categorical data. See &lt;a href=&quot;series#api-series-cat&quot;&gt;Categorical accessor&lt;/a&gt; for more.</source>
          <target state="translated">如果Series为 &lt;code&gt;Series.cat&lt;/code&gt; &lt;code&gt;CategoricalDtype&lt;/code&gt; ，则Series.cat可用于更改分类数据。有关更多信息，请参见&lt;a href=&quot;series#api-series-cat&quot;&gt;分类访问&lt;/a&gt;器。</target>
        </trans-unit>
        <trans-unit id="5c83fd268af8fe1a16e48c3a1ab2791b08629b1d" translate="yes" xml:space="preserve">
          <source>If the TimeSeries is tz-aware and tz is not None.</source>
          <target state="translated">如果TimeSeries是tz-aware且tz不是None。</target>
        </trans-unit>
        <trans-unit id="166773b46d18bb469c09bcac6b289439b56e7d14" translate="yes" xml:space="preserve">
          <source>If the Timestamp is tz-aware and tz is not None.</source>
          <target state="translated">如果时间戳是tz-aware且tz不是None。</target>
        </trans-unit>
        <trans-unit id="ed9393b2d06f7ca7196058734584b10915f7b7ef" translate="yes" xml:space="preserve">
          <source>If the applied function returns a &lt;code&gt;Series&lt;/code&gt;, the final output is a &lt;code&gt;DataFrame&lt;/code&gt;. The columns match the index of the &lt;code&gt;Series&lt;/code&gt; returned by the applied function.</source>
          <target state="translated">如果应用的函数返回 &lt;code&gt;Series&lt;/code&gt; ，则最终输出为 &lt;code&gt;DataFrame&lt;/code&gt; 。这些列与应用函数返回的 &lt;code&gt;Series&lt;/code&gt; 的索引匹配。</target>
        </trans-unit>
        <trans-unit id="c7c554cfb74ad16eb30cb8acf707f73662f04504" translate="yes" xml:space="preserve">
          <source>If the applied function returns any other type, the final output is a &lt;code&gt;Series&lt;/code&gt;.</source>
          <target state="translated">如果应用的函数返回任何其他类型，则最终输出为 &lt;code&gt;Series&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="57492f8aeb84c4c11084b50073db14b29faccfda" translate="yes" xml:space="preserve">
          <source>If the axis is a</source>
          <target state="translated">如果轴是一个</target>
        </trans-unit>
        <trans-unit id="31df692ed74865cf46655ed034fdaf4f052a8d85" translate="yes" xml:space="preserve">
          <source>If the axis is a &lt;code&gt;MultiIndex&lt;/code&gt; (hierarchical), count along a particular &lt;code&gt;level&lt;/code&gt;, collapsing into a &lt;code&gt;DataFrame&lt;/code&gt;. A &lt;code&gt;str&lt;/code&gt; specifies the level name.</source>
          <target state="translated">如果轴是 &lt;code&gt;MultiIndex&lt;/code&gt; （分层），则沿特定 &lt;code&gt;level&lt;/code&gt; 计数，并折叠为 &lt;code&gt;DataFrame&lt;/code&gt; 。一个 &lt;code&gt;str&lt;/code&gt; 指定级别名称。</target>
        </trans-unit>
        <trans-unit id="cb176b6dcd2c00fd60079bc8af02e9483c7b2358" translate="yes" xml:space="preserve">
          <source>If the axis is a MultiIndex (hierarchical), count along a particular level, collapsing into a Series</source>
          <target state="translated">如果轴是一个MultiIndex(分层),则沿某一层次计数,折叠成一个Series(系列)。</target>
        </trans-unit>
        <trans-unit id="769c2b618c37d94ee04a6ed2f86ca3697aa771ee" translate="yes" xml:space="preserve">
          <source>If the axis is a MultiIndex (hierarchical), count along a particular level, collapsing into a Series.</source>
          <target state="translated">如果轴是一个MultiIndex(分层),则沿某一层次计数,折叠成一个Series。</target>
        </trans-unit>
        <trans-unit id="5c874bca9b0f22f8a1cb6ace88f3bf9ba4eb54d3" translate="yes" xml:space="preserve">
          <source>If the axis is a MultiIndex (hierarchical), count along a particular level, collapsing into a scalar</source>
          <target state="translated">如果轴是一个MultiIndex(分层),则沿着特定的层次计数,折叠成一个标量。</target>
        </trans-unit>
        <trans-unit id="9cfa60e80d738cd1ce2e3e1ca125d513cb5b51b9" translate="yes" xml:space="preserve">
          <source>If the axis is a MultiIndex (hierarchical), count along a particular level, collapsing into a scalar.</source>
          <target state="translated">如果轴是一个MultiIndex(分层),则沿着特定的层次计数,折叠成一个标量。</target>
        </trans-unit>
        <trans-unit id="acc1c61e1d22ff923e52dd41f329881f26c8cde0" translate="yes" xml:space="preserve">
          <source>If the axis is a MultiIndex (hierarchical), count along a particular level, collapsing into a smaller Series.</source>
          <target state="translated">如果轴是一个MultiIndex(分层),则沿某一层次计数,折叠成一个较小的Series。</target>
        </trans-unit>
        <trans-unit id="4bde74fe49512814aa9175078e647d0e2833dc88" translate="yes" xml:space="preserve">
          <source>If the axis is a MultiIndex (hierarchical), count along a particular level, collapsing into a {name1}.</source>
          <target state="translated">如果轴是MultiIndex(分层),则沿某一层计数,折叠成{name1}。</target>
        </trans-unit>
        <trans-unit id="67fb26f3d36635371a47ec0c1a6253a35906fe24" translate="yes" xml:space="preserve">
          <source>If the axis is a MultiIndex (hierarchical), group by a particular level or levels.</source>
          <target state="translated">如果轴是一个MultiIndex(分层),则按一个或多个特定级别进行分组。</target>
        </trans-unit>
        <trans-unit id="b5361e8b12cba57093a4bca7b1ba4eecbc07f527" translate="yes" xml:space="preserve">
          <source>If the axis is tz-naive.</source>
          <target state="translated">如果轴是tz-naive。</target>
        </trans-unit>
        <trans-unit id="b60526c69422bc15a4ea3ceaf37ce27ebe587a8b" translate="yes" xml:space="preserve">
          <source>If the backend is not the default matplotlib one, the return value will be the object returned by the backend.</source>
          <target state="translated">如果后端不是默认的matplotlib,返回值将是后端返回的对象。</target>
        </trans-unit>
        <trans-unit id="aeceb5d896fc9cb6f840f781402681ca9e0cca6b" translate="yes" xml:space="preserve">
          <source>If the caller is heterogeneous and contains booleans or objects, the result will be of dtype=object. See Notes.</source>
          <target state="translated">如果调用者是异构的,并且包含booleans或对象,那么结果将是dtype=object。见注释。</target>
        </trans-unit>
        <trans-unit id="78dfb04301d7d11f06e3b14acf5990d58d0a43a0" translate="yes" xml:space="preserve">
          <source>If the categories do not validate.</source>
          <target state="translated">如果类别无效。</target>
        </trans-unit>
        <trans-unit id="37b7a652ec11f0c6a680c6d296b342bf36963ce7" translate="yes" xml:space="preserve">
          <source>If the columns have a &lt;code&gt;MultiIndex&lt;/code&gt;, you can choose which level to stack. The stacked level becomes the new lowest level in a &lt;code&gt;MultiIndex&lt;/code&gt; on the columns:</source>
          <target state="translated">如果列具有 &lt;code&gt;MultiIndex&lt;/code&gt; ，则可以选择要堆叠的级别。堆叠级别成为列上 &lt;code&gt;MultiIndex&lt;/code&gt; 中新的最低级别：</target>
        </trans-unit>
        <trans-unit id="e6bab78d983e5853d00e346d9f3278a1b337046e" translate="yes" xml:space="preserve">
          <source>If the columns have multiple levels, determines how the other levels are named. If None then the index name is repeated.</source>
          <target state="translated">如果列有多级,决定其他级别如何命名。如果None,则重复索引名。</target>
        </trans-unit>
        <trans-unit id="16f324de3f6d44a6d155ca6a0800716c76d8fdf8" translate="yes" xml:space="preserve">
          <source>If the columns have multiple levels, determines which level the labels are inserted into. By default it is inserted into the first level.</source>
          <target state="translated">如果列有多级,决定标签插入到哪一级。默认情况下是插入到第一层。</target>
        </trans-unit>
        <trans-unit id="b46261a6c2734b27734de6d0fcc60d9a4f9f2be6" translate="yes" xml:space="preserve">
          <source>If the data are all NA, the result will be 0.</source>
          <target state="translated">如果数据都是NA,结果将是0。</target>
        </trans-unit>
        <trans-unit id="2a8d59c818fd41f1886de03e2a0e8206d7189f0d" translate="yes" xml:space="preserve">
          <source>If the data are tz-aware, then every value in the array must have the same timezone.</source>
          <target state="translated">如果数据是tz-aware的,那么数组中的每个值都必须有相同的时区。</target>
        </trans-unit>
        <trans-unit id="751891dab5d046525fc44f6b2e68f95c51bfff3b" translate="yes" xml:space="preserve">
          <source>If the data is not length-1.</source>
          <target state="translated">如果数据长度不为1。</target>
        </trans-unit>
        <trans-unit id="d39bced8875c9d4daed1623756606adbd29a4918" translate="yes" xml:space="preserve">
          <source>If the default template doesn&amp;rsquo;t quite suit your needs, you can subclass Styler and extend or override the template. We&amp;rsquo;ll show an example of extending the default template to insert a custom header before each table.</source>
          <target state="translated">如果默认模板不太适合您的需求，则可以继承Styler的子类并扩展或覆盖模板。我们将展示一个扩展默认模板以在每个表之前插入自定义标头的示例。</target>
        </trans-unit>
        <trans-unit id="6fd8fd90d6a0d1abee70b7276ea680c627a14212" translate="yes" xml:space="preserve">
          <source>If the dtype is integer, convert to an appropriate integer extension type.</source>
          <target state="translated">如果dtype是整数,则转换为适当的整数扩展类型。</target>
        </trans-unit>
        <trans-unit id="9934081d7cb4f95460aa7414ef39e9099336c32f" translate="yes" xml:space="preserve">
          <source>If the dtype is numeric, and consists of all integers, convert to an appropriate integer extension type. Otherwise, convert to an appropriate floating extension type.</source>
          <target state="translated">如果dtype是数值型,并且全部是整数,则转换为适当的整数扩展类型。否则,转换为适当的浮动扩展类型。</target>
        </trans-unit>
        <trans-unit id="b474e8292463ff3d6dc397cb12f9e866f037fd93" translate="yes" xml:space="preserve">
          <source>If the elements of a Series are lists themselves, join the content of these lists using the delimiter passed to the function. This function is an equivalent to &lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#str.join&quot;&gt;&lt;code&gt;str.join()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果Series的元素本身是列​​表，则使用传递给函数的定界符将这些列表的内容连接起来。此函数等效于&lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#str.join&quot;&gt; &lt;code&gt;str.join()&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b5cd27d9aa0745a9023fb6c25cf1ae1d3bf731d3" translate="yes" xml:space="preserve">
          <source>If the exact type is not relevant, but must be compatible with a numpy array, array-like can be specified. If Any type that can be iterated is accepted, iterable can be used:</source>
          <target state="translated">如果确切的类型不相关,但必须与numpy数组兼容,可以指定array-like。如果接受任何可以迭代的类型,可以使用iterable。</target>
        </trans-unit>
        <trans-unit id="be5ff8f8c878d0a8afe3f068aed76c34baa9e8b2" translate="yes" xml:space="preserve">
          <source>If the expression contains an assignment, whether to perform the operation inplace and mutate the existing DataFrame. Otherwise, a new DataFrame is returned.</source>
          <target state="translated">如果表达式中包含赋值,则是否执行原地操作并突变现有的DataFrame。否则,将返回一个新的DataFrame。</target>
        </trans-unit>
        <trans-unit id="d26e067e645ae141c3a27a1e812db05453a5ed1b" translate="yes" xml:space="preserve">
          <source>If the file or header contains duplicate names, pandas will by default distinguish between them so as to prevent overwriting data:</source>
          <target state="translated">如果文件或头文件包含重复的名称,pandas默认会对它们进行区分,以防止数据被覆盖。</target>
        </trans-unit>
        <trans-unit id="58976636f12bfa2b230629347f075b16cf9d94be" translate="yes" xml:space="preserve">
          <source>If the fiscal year starts in April (</source>
          <target state="translated">如果财政年度从4月开始(</target>
        </trans-unit>
        <trans-unit id="b7ff9c19369126c9e7394a827328229c91b340d6" translate="yes" xml:space="preserve">
          <source>If the fiscal year starts in April (&lt;code&gt;Q-MAR&lt;/code&gt;), the first quarter of 2018 will start in April 2017. &lt;code&gt;year&lt;/code&gt; will then be 2018, but &lt;code&gt;qyear&lt;/code&gt; will be the fiscal year, 2018.</source>
          <target state="translated">如果会计年度从四月（ &lt;code&gt;Q-MAR&lt;/code&gt; ）开始，则2018年第一季度将从2017 &lt;code&gt;year&lt;/code&gt; 4月开始。年份将是2018年，但 &lt;code&gt;qyear&lt;/code&gt; 将是2018会计年度。</target>
        </trans-unit>
        <trans-unit id="b59db1d7abf5d61294ac0431e0b446551a515714" translate="yes" xml:space="preserve">
          <source>If the frequency is higher than daily (e.g. monthly), the last day of the period is used.</source>
          <target state="translated">如果频率高于每日(如每月),则使用该期间的最后一天。</target>
        </trans-unit>
        <trans-unit id="cbee9b96a09f286deac2451511a01eaea475791a" translate="yes" xml:space="preserve">
          <source>If the given date &lt;em&gt;is&lt;/em&gt; on an anchor point, it is moved &lt;code&gt;|n|&lt;/code&gt; points forwards or backwards.</source>
          <target state="translated">如果给定的日期&lt;em&gt;是&lt;/em&gt;上一个锚点，它被移动 &lt;code&gt;|n|&lt;/code&gt; 指向前进或后退。</target>
        </trans-unit>
        <trans-unit id="251850cb5f40595dbfbfb399f7a94595a96e86d5" translate="yes" xml:space="preserve">
          <source>If the header is in a row other than the first, pass the row number to &lt;code&gt;header&lt;/code&gt;. This will skip the preceding rows:</source>
          <target state="translated">如果标题不在第一行中，则将行号传递给 &lt;code&gt;header&lt;/code&gt; 。这将跳过前面的行：</target>
        </trans-unit>
        <trans-unit id="e95726e1713352efccbe37d7bda0327d4e035e6e" translate="yes" xml:space="preserve">
          <source>If the index being truncated contains only datetime values,</source>
          <target state="translated">如果被截断的索引只包含日期时间值。</target>
        </trans-unit>
        <trans-unit id="d726bbcf68dc737c3aca6d41e599a28b3f5d3ff8" translate="yes" xml:space="preserve">
          <source>If the index being truncated contains only datetime values, &lt;code&gt;before&lt;/code&gt; and &lt;code&gt;after&lt;/code&gt; may be specified as strings instead of Timestamps.</source>
          <target state="translated">如果被截断的索引仅包含日期时间值，则可以将字符串 &lt;code&gt;before&lt;/code&gt; 和 &lt;code&gt;after&lt;/code&gt; 指定为字符串，而不是时间戳。</target>
        </trans-unit>
        <trans-unit id="26ab44fcadd1b6b21a6d87e3f94d723582cab96b" translate="yes" xml:space="preserve">
          <source>If the index consists of dates, it calls &lt;a href=&quot;https://matplotlib.org/api/_as_gen/matplotlib.figure.Figure.html#matplotlib.figure.Figure.autofmt_xdate&quot;&gt;&lt;code&gt;gcf().autofmt_xdate()&lt;/code&gt;&lt;/a&gt; to try to format the x-axis nicely as per above.</source>
          <target state="translated">如果索引由日期组成，它将调用&lt;a href=&quot;https://matplotlib.org/api/_as_gen/matplotlib.figure.Figure.html#matplotlib.figure.Figure.autofmt_xdate&quot;&gt; &lt;code&gt;gcf().autofmt_xdate()&lt;/code&gt; &lt;/a&gt;尝试按照上述方法很好地格式化x轴。</target>
        </trans-unit>
        <trans-unit id="2264c92998892aeab7e100ff43c608c30c0b3eaf" translate="yes" xml:space="preserve">
          <source>If the index has level names, they will parsed as well, using the same parameters.</source>
          <target state="translated">如果索引有级别名称,它们也会被解析,使用相同的参数。</target>
        </trans-unit>
        <trans-unit id="62bf561852f13e8a7992a8390ffa6b918215b325" translate="yes" xml:space="preserve">
          <source>If the index has multiple levels, we can reset a subset of them:</source>
          <target state="translated">如果指数有多个级别,我们可以重置其中的一个子集。</target>
        </trans-unit>
        <trans-unit id="cda1d90ab4aeda16d9fd7875489389b8cf6ae137" translate="yes" xml:space="preserve">
          <source>If the index is a MultiIndex, level(s) to set (None for all levels). Otherwise level must be None.</source>
          <target state="translated">如果索引是一个MultiIndex,那么要设置的级别(所有级别为无)。否则级别必须为None。</target>
        </trans-unit>
        <trans-unit id="067743019a50efb3de30de5e7db206d81efd2bfc" translate="yes" xml:space="preserve">
          <source>If the index is not a &lt;a href=&quot;pandas.datetimeindex#pandas.DatetimeIndex&quot;&gt;&lt;code&gt;DatetimeIndex&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">如果索引不是&lt;a href=&quot;pandas.datetimeindex#pandas.DatetimeIndex&quot;&gt; &lt;code&gt;DatetimeIndex&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1927dd8f9c19eb08ec5a860837248b90f251a58b" translate="yes" xml:space="preserve">
          <source>If the index is not a MultiIndex, the output will be a Series (the analogue of stack when the columns are not a MultiIndex).</source>
          <target state="translated">如果索引不是MultiIndex,则输出为Series(当列不是MultiIndex时,堆栈的模拟)。</target>
        </trans-unit>
        <trans-unit id="30fd49a077ae8a3b14098e6244c90ec8aaa36f10" translate="yes" xml:space="preserve">
          <source>If the index is not datetime-like.</source>
          <target state="translated">如果索引不是日期型的。</target>
        </trans-unit>
        <trans-unit id="0474835e1da4e14d4e8fd21bedd592901f57b6d7" translate="yes" xml:space="preserve">
          <source>If the index is not sorted, an error is raised.</source>
          <target state="translated">如果索引没有排序,就会引发一个错误。</target>
        </trans-unit>
        <trans-unit id="91a507c7cc7e55eec65d8adcd1430cebef29fade" translate="yes" xml:space="preserve">
          <source>If the index of a &lt;code&gt;Series&lt;/code&gt; or &lt;code&gt;DataFrame&lt;/code&gt; is monotonically increasing or decreasing, then the bounds of a label-based slice can be outside the range of the index, much like slice indexing a normal Python &lt;code&gt;list&lt;/code&gt;. Monotonicity of an index can be tested with the &lt;a href=&quot;../reference/api/pandas.index.is_monotonic_increasing#pandas.Index.is_monotonic_increasing&quot;&gt;&lt;code&gt;is_monotonic_increasing()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../reference/api/pandas.index.is_monotonic_decreasing#pandas.Index.is_monotonic_decreasing&quot;&gt;&lt;code&gt;is_monotonic_decreasing()&lt;/code&gt;&lt;/a&gt; attributes.</source>
          <target state="translated">如果 &lt;code&gt;Series&lt;/code&gt; 或 &lt;code&gt;DataFrame&lt;/code&gt; 的索引单调递增或递减，则基于标签的切片的范围可能超出索引范围，就像切片为普通Python &lt;code&gt;list&lt;/code&gt; 编制索引一样。可以使用&lt;a href=&quot;../reference/api/pandas.index.is_monotonic_increasing#pandas.Index.is_monotonic_increasing&quot;&gt; &lt;code&gt;is_monotonic_increasing()&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../reference/api/pandas.index.is_monotonic_decreasing#pandas.Index.is_monotonic_decreasing&quot;&gt; &lt;code&gt;is_monotonic_decreasing()&lt;/code&gt; &lt;/a&gt;属性测试索引的单调性。</target>
        </trans-unit>
        <trans-unit id="48b9e82a9c1b991449ed1f9627ad743db7ae93ac" translate="yes" xml:space="preserve">
          <source>If the indexes have names, you can use the level names instead of specifying the level numbers:</source>
          <target state="translated">如果索引有名称,可以使用级别名称代替指定级别号。</target>
        </trans-unit>
        <trans-unit id="ab6a27e99c67cc04b243466ae25a20129613f55a" translate="yes" xml:space="preserve">
          <source>If the key is past the lexsort depth, the return may be a boolean mask array, otherwise it is always a slice or int.</source>
          <target state="translated">如果键过了lexsort深度,返回的可能是一个布尔掩码数组,否则总是一个分片或int。</target>
        </trans-unit>
        <trans-unit id="23363d65d1a6bf0f3c3353ab3f1570ee49ce97bd" translate="yes" xml:space="preserve">
          <source>If the label is in the index, the method returns the passed label.</source>
          <target state="translated">如果标签在索引中,则该方法返回传递的标签。</target>
        </trans-unit>
        <trans-unit id="62728247d7d94b3cd5df3bfeeee148f0c1c53570" translate="yes" xml:space="preserve">
          <source>If the levels of the &lt;code&gt;MultiIndex&lt;/code&gt; are unnamed, you can refer to them using special names:</source>
          <target state="translated">如果未命名 &lt;code&gt;MultiIndex&lt;/code&gt; 的级别，则可以使用特殊名称来引用它们：</target>
        </trans-unit>
        <trans-unit id="1bace5351497c6afbd0b965925661935f3882c76" translate="yes" xml:space="preserve">
          <source>If the library specified with the &lt;code&gt;complib&lt;/code&gt; option is missing on your platform, compression defaults to &lt;code&gt;zlib&lt;/code&gt; without further ado.</source>
          <target state="translated">如果平台上缺少用 &lt;code&gt;complib&lt;/code&gt; 选项指定的库，则默认情况下压缩默认为 &lt;code&gt;zlib&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="621ef692e94d8c2c7ed3c141b773d4670d1901fd" translate="yes" xml:space="preserve">
          <source>If the mapping doesn&amp;rsquo;t include a column/index label, it isn&amp;rsquo;t renamed. Note that extra labels in the mapping don&amp;rsquo;t throw an error.</source>
          <target state="translated">如果映射不包含列/索引标签，则不会重命名。请注意，映射中的额外标签不会引发错误。</target>
        </trans-unit>
        <trans-unit id="22dfc540b19512c01f76cdc319937a5edf13e1d7" translate="yes" xml:space="preserve">
          <source>If the mapping is not one-to-one an &lt;a href=&quot;pandas.index#pandas.Index&quot;&gt;&lt;code&gt;Index&lt;/code&gt;&lt;/a&gt; is returned:</source>
          <target state="translated">如果映射不是一对一的，则返回一个&lt;a href=&quot;pandas.index#pandas.Index&quot;&gt; &lt;code&gt;Index&lt;/code&gt; &lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="f30e3b28f5a53e1916fb432f6e3f20ec400af36a" translate="yes" xml:space="preserve">
          <source>If the mapping is one-to-one the ordering of the categories is preserved:</source>
          <target state="translated">如果映射是一对一的,则保留类别的排序。</target>
        </trans-unit>
        <trans-unit id="a768d5fc9004a5e554c6076edc84eab413d78b6d" translate="yes" xml:space="preserve">
          <source>If the maximum is achieved in multiple locations, the first row position is returned.</source>
          <target state="translated">如果在多个位置达到最大值,则返回第一行位置。</target>
        </trans-unit>
        <trans-unit id="29594b7fad55aba80e626335052ebbda64589beb" translate="yes" xml:space="preserve">
          <source>If the method returns a value, it will be documented in this section. Also if the method yields its output.</source>
          <target state="translated">如果该方法返回一个值,它将在本节中被记录下来。另外,如果该方法产生了它的输出。</target>
        </trans-unit>
        <trans-unit id="1c7fa85a4950fc4db50e956b853116480dbe2810" translate="yes" xml:space="preserve">
          <source>If the method yields its value:</source>
          <target state="translated">如果该方法产生其价值。</target>
        </trans-unit>
        <trans-unit id="6ea0723c633b98419ce3a16ae4f68fc08bf4f8d0" translate="yes" xml:space="preserve">
          <source>If the minimum is achieved in multiple locations, the first row position is returned.</source>
          <target state="translated">如果在多个位置达到最小值,则返回第一行位置。</target>
        </trans-unit>
        <trans-unit id="fcb76a7d2f4b9a5dfe28cdf6f1774a0fbdbb4d8d" translate="yes" xml:space="preserve">
          <source>If the name of your index overlaps with a column name, the column name is given precedence. For example,</source>
          <target state="translated">如果你的索引名称与列名重叠,则列名优先。例如:</target>
        </trans-unit>
        <trans-unit id="90b88b10d573c557d524dfc87fd5f8d2b05a6035" translate="yes" xml:space="preserve">
          <source>If the natural and fiscal year are the same,</source>
          <target state="translated">如果自然年度和财政年度相同。</target>
        </trans-unit>
        <trans-unit id="2be314f975c703a2d0fb14d5a08ed837b5ac3d17" translate="yes" xml:space="preserve">
          <source>If the natural and fiscal year are the same, &lt;code&gt;qyear&lt;/code&gt; and &lt;code&gt;year&lt;/code&gt; will be the same.</source>
          <target state="translated">如果自然年度和会计年度相同，则 &lt;code&gt;qyear&lt;/code&gt; 和 &lt;code&gt;year&lt;/code&gt; 将相同。</target>
        </trans-unit>
        <trans-unit id="c2d7883a841125b807eecd00b3c3af4f438f2ede" translate="yes" xml:space="preserve">
          <source>If the new categories do not contain all old category items or any new ones</source>
          <target state="translated">如果新的类别不包含所有旧的类别项目或任何新的类别项目。</target>
        </trans-unit>
        <trans-unit id="b8ff9a9bc1a204944889d9f9ab64cff13098ce04" translate="yes" xml:space="preserve">
          <source>If the new categories do not validate as categories or if the number of new categories is unequal the number of old categories</source>
          <target state="translated">如果新的类别没有被确认为类别,或者新的类别数量与旧的类别数量不相等</target>
        </trans-unit>
        <trans-unit id="e5bb30293ce2058c6ee007b1c0630a5f11c11af8" translate="yes" xml:space="preserve">
          <source>If the new categories include old categories or do not validate as categories</source>
          <target state="translated">如果新的类别包括旧的类别,或者不作为类别生效。</target>
        </trans-unit>
        <trans-unit id="fe951dca7785cedc66869cdb77e398f6c9c6fc86" translate="yes" xml:space="preserve">
          <source>If the number of categories approaches the length of the data, the &lt;code&gt;Categorical&lt;/code&gt; will use nearly the same or more memory than an equivalent &lt;code&gt;object&lt;/code&gt; dtype representation.</source>
          <target state="translated">如果类别的数量接近数据的长度，则 &lt;code&gt;Categorical&lt;/code&gt; 将使用与等效 &lt;code&gt;object&lt;/code&gt; dtype表示几乎相同或更多的内存。</target>
        </trans-unit>
        <trans-unit id="6d42972fb825ba15c0b8fbd39cf2275d1d47464c" translate="yes" xml:space="preserve">
          <source>If the offset class maps directly to a &lt;code&gt;Timedelta&lt;/code&gt; (&lt;code&gt;Day&lt;/code&gt;, &lt;code&gt;Hour&lt;/code&gt;, &lt;code&gt;Minute&lt;/code&gt;, &lt;code&gt;Second&lt;/code&gt;, &lt;code&gt;Micro&lt;/code&gt;, &lt;code&gt;Milli&lt;/code&gt;, &lt;code&gt;Nano&lt;/code&gt;) it can be used exactly like a &lt;code&gt;Timedelta&lt;/code&gt; - see the &lt;a href=&quot;timedeltas#timedeltas-operations&quot;&gt;Timedelta section&lt;/a&gt; for more examples.</source>
          <target state="translated">如果偏移种类直接映射到一个 &lt;code&gt;Timedelta&lt;/code&gt; （ &lt;code&gt;Day&lt;/code&gt; ， &lt;code&gt;Hour&lt;/code&gt; ， &lt;code&gt;Minute&lt;/code&gt; ， &lt;code&gt;Second&lt;/code&gt; ， &lt;code&gt;Micro&lt;/code&gt; ， &lt;code&gt;Milli&lt;/code&gt; ， &lt;code&gt;Nano&lt;/code&gt; ），它可以用来酷似 &lt;code&gt;Timedelta&lt;/code&gt; -看到&lt;a href=&quot;timedeltas#timedeltas-operations&quot;&gt;Timedelta节&lt;/a&gt;有更多的例子。</target>
        </trans-unit>
        <trans-unit id="aa4e627ef93053b4aa69b81750fbb56a233374ba" translate="yes" xml:space="preserve">
          <source>If the parsed data only contains one column then return a &lt;code&gt;Series&lt;/code&gt;.</source>
          <target state="translated">如果解析的数据仅包含一列，则返回 &lt;code&gt;Series&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dc97c541d898a4ba589bd072c2b06a7b9a9ba55c" translate="yes" xml:space="preserve">
          <source>If the parsed data only contains one column then return a Series.</source>
          <target state="translated">如果解析的数据只包含一列,那么返回一个Series。</target>
        </trans-unit>
        <trans-unit id="6fce5176c2e9226fd8f8db2e0305dd4e81c28cba" translate="yes" xml:space="preserve">
          <source>If the pattern is found more than once in the same string, then a list of multiple strings is returned:</source>
          <target state="translated">如果在同一个字符串中发现了不止一次的模式,那么将返回一个多字符串的列表。</target>
        </trans-unit>
        <trans-unit id="862fb94e4f74981a38a343060cd76373e4ac1593" translate="yes" xml:space="preserve">
          <source>If the period frequency is lower than daily (e.g. hourly), and the period spans over multiple days, the day at the start of the period is used.</source>
          <target state="translated">如果周期频率低于每日(如每小时),且周期跨越多日,则使用周期开始时的一天。</target>
        </trans-unit>
        <trans-unit id="afacabf141fdf1a3c0b0db32b0df85742991ee4b" translate="yes" xml:space="preserve">
          <source>If the precision is higher than nanoseconds, the precision of the duration is truncated to nanoseconds for string inputs.</source>
          <target state="translated">如果精度高于纳秒,对于字符串输入,持续时间的精度被截断为纳秒。</target>
        </trans-unit>
        <trans-unit id="0dc1edffb0f31fc99e3c48d2e32580c307e64c9a" translate="yes" xml:space="preserve">
          <source>If the precision is higher than nanoseconds, the precision of the duration is truncated to nanoseconds.</source>
          <target state="translated">如果精度高于纳秒,则将持续时间的精度截断为纳秒。</target>
        </trans-unit>
        <trans-unit id="24931cba16f8d7d23729af82afc7b5cf33a8ab54" translate="yes" xml:space="preserve">
          <source>If the removals are not contained in the categories</source>
          <target state="translated">如果清除的内容不属于以下类别:</target>
        </trans-unit>
        <trans-unit id="a91b79ba0a48641f561804353a8466ad061c6ff1" translate="yes" xml:space="preserve">
          <source>If the row/column is empty</source>
          <target state="translated">如果该行/列为空</target>
        </trans-unit>
        <trans-unit id="c1275c4e20323c10096aa977b7395839bb87cb2c" translate="yes" xml:space="preserve">
          <source>If the slicing operation returns either a &lt;code&gt;DataFrame&lt;/code&gt; or a column of type &lt;code&gt;Series&lt;/code&gt;, the &lt;code&gt;category&lt;/code&gt; dtype is preserved.</source>
          <target state="translated">如果切片操作情况传回 &lt;code&gt;DataFrame&lt;/code&gt; 或类型的列 &lt;code&gt;Series&lt;/code&gt; ，该 &lt;code&gt;category&lt;/code&gt; D型细胞被保留。</target>
        </trans-unit>
        <trans-unit id="5afed770bb40cdc080e4e911d978019b4cc3a824" translate="yes" xml:space="preserve">
          <source>If the source file has both &lt;code&gt;MultiIndex&lt;/code&gt; index and columns, lists specifying each should be passed to &lt;code&gt;index_col&lt;/code&gt; and &lt;code&gt;header&lt;/code&gt;:</source>
          <target state="translated">如果源文件同时具有 &lt;code&gt;MultiIndex&lt;/code&gt; 索引和列，则应将指定它们的列表传递给 &lt;code&gt;index_col&lt;/code&gt; 和 &lt;code&gt;header&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="d2fbbcf4ba212002b0c61ef4fa072fb2a25199bd" translate="yes" xml:space="preserve">
          <source>If the supplied Series contains neither strings nor lists.</source>
          <target state="translated">如果提供的系列既不包含字符串也不包含列表。</target>
        </trans-unit>
        <trans-unit id="e0f175e63735de751d2d7b89f97ca4eea1b0abeb" translate="yes" xml:space="preserve">
          <source>If the test generates a warning of class &lt;code&gt;category&lt;/code&gt; whose message starts with &lt;code&gt;msg&lt;/code&gt;, the warning will be ignored and the test will pass.</source>
          <target state="translated">如果测试生成了一个 &lt;code&gt;category&lt;/code&gt; 的警告，其消息以 &lt;code&gt;msg&lt;/code&gt; 开头，则警告将被忽略并且测试将通过。</target>
        </trans-unit>
        <trans-unit id="e13fc8bacc6ba344e6b7c59f5500846f60bb9f0f" translate="yes" xml:space="preserve">
          <source>If the timestamp string is treated as a slice, it can be used to index &lt;code&gt;DataFrame&lt;/code&gt; with &lt;code&gt;.loc[]&lt;/code&gt; as well.</source>
          <target state="translated">如果时间戳字符串被视为切片，则它也可以用于通过 &lt;code&gt;.loc[]&lt;/code&gt; 索引 &lt;code&gt;DataFrame&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="14413eaf87552171ee2c64255914c3d985a6b0cb" translate="yes" xml:space="preserve">
          <source>If the timezone is not set, the resulting Series will have a datetime64[ns] dtype.</source>
          <target state="translated">如果没有设置时区,生成的Series将有一个datetime64[ns]dtype。</target>
        </trans-unit>
        <trans-unit id="55f68536b5e696d5ad33c88c279512e394794e07" translate="yes" xml:space="preserve">
          <source>If the type is a pandas type, also specify pandas except for Series and DataFrame:</source>
          <target state="translated">如果类型是pandas类型,除了Series和DataFrame,也要指定pandas。</target>
        </trans-unit>
        <trans-unit id="2c463cab0f756d454178e69be623cfa933046f80" translate="yes" xml:space="preserve">
          <source>If the type is defined in a Python module, the module must be specified:</source>
          <target state="translated">如果类型是在Python模块中定义的,则必须指定该模块。</target>
        </trans-unit>
        <trans-unit id="fa3ae3c0858082628b417918cb8ce07cd4ca5f45" translate="yes" xml:space="preserve">
          <source>If the type is in a package, the module must be also specified:</source>
          <target state="translated">如果类型是在一个包中,也必须指定模块。</target>
        </trans-unit>
        <trans-unit id="7a03f05686c0d02f3139ecf76b3027fa808e62cc" translate="yes" xml:space="preserve">
          <source>If the user is aware of the duplicates in the right &lt;code&gt;DataFrame&lt;/code&gt; but wants to ensure there are no duplicates in the left DataFrame, one can use the &lt;code&gt;validate='one_to_many'&lt;/code&gt; argument instead, which will not raise an exception.</source>
          <target state="translated">如果用户知道右侧 &lt;code&gt;DataFrame&lt;/code&gt; 中的重复项，但要确保左侧DataFrame中没有重复项，则可以改用 &lt;code&gt;validate='one_to_many'&lt;/code&gt; 参数，这不会引发异常。</target>
        </trans-unit>
        <trans-unit id="40e3ffe708d7d382314e21166febe6fa597c1764" translate="yes" xml:space="preserve">
          <source>If the values are not monotonically sorted, wrong locations may be returned:</source>
          <target state="translated">如果数值不是单调排序的,可能会返回错误的位置。</target>
        </trans-unit>
        <trans-unit id="8116189ef90a7c0ac0c0a3c8ff175ce609f080fc" translate="yes" xml:space="preserve">
          <source>If there are any NaN or NaT values in the grouping key, these will be automatically excluded. In other words, there will never be an &amp;ldquo;NA group&amp;rdquo; or &amp;ldquo;NaT group&amp;rdquo;. This was not the case in older versions of pandas, but users were generally discarding the NA group anyway (and supporting it was an implementation headache).</source>
          <target state="translated">如果分组键中有NaN或NaT值，这些值将被自动排除。换句话说，将永远不会有&amp;ldquo; NA组&amp;rdquo;或&amp;ldquo; NaT组&amp;rdquo;。在较早版本的熊猫中不是这种情况，但是用户通常无论如何都会丢弃NA组（并且支持它是实施中的头疼事）。</target>
        </trans-unit>
        <trans-unit id="682fbbd327f7dba66b881174932070842597549b" translate="yes" xml:space="preserve">
          <source>If there are fewer than three values.</source>
          <target state="translated">如果数值少于三个。</target>
        </trans-unit>
        <trans-unit id="46f25d66dfb27cdf7e82e3397b599f84e8bbd166" translate="yes" xml:space="preserve">
          <source>If there are merge conflicts, you need to solve those conflicts. See for example at &lt;a href=&quot;https://help.github.com/articles/resolving-a-merge-conflict-using-the-command-line/&quot;&gt;https://help.github.com/articles/resolving-a-merge-conflict-using-the-command-line/&lt;/a&gt; for an explanation on how to do this. Once the conflicts are merged and the files where the conflicts were solved are added, you can run &lt;code&gt;git commit&lt;/code&gt; to save those fixes.</source>
          <target state="translated">如果存在合并冲突，则需要解决这些冲突。有关如何执行此操作的说明，请参见例如&lt;a href=&quot;https://help.github.com/articles/resolving-a-merge-conflict-using-the-command-line/&quot;&gt;https://help.github.com/articles/resolving-a-merge-conflict-using-the-command-line/&lt;/a&gt;。合并冲突并添加解决冲突的文件后，您可以运行 &lt;code&gt;git commit&lt;/code&gt; 来保存这些修复程序。</target>
        </trans-unit>
        <trans-unit id="f267a36da468b5ae5ceb8cafd473d483c3fe55df" translate="yes" xml:space="preserve">
          <source>If there are no conflicts (or they could be fixed automatically), a file with a default commit message will open, and you can simply save and quit this file.</source>
          <target state="translated">如果没有冲突(或者可以自动修复),就会打开一个带有默认提交信息的文件,你可以直接保存并退出这个文件。</target>
        </trans-unit>
        <trans-unit id="f642e67158a066fd10cb787b665aedb36dbf5c3d" translate="yes" xml:space="preserve">
          <source>If there are people interested in continued support for Python 2.7 past December 31, 2018 (either backporting bug fixes or funding) please reach out to the maintainers on the issue tracker.</source>
          <target state="translated">如果有人对在2018年12月31日之后继续支持Python 2.7感兴趣(无论是回传bug修复还是资助),请在问题跟踪器上联系维护者。</target>
        </trans-unit>
        <trans-unit id="df8b99601c3ccae4df1dcef1c8a935236cdb7582" translate="yes" xml:space="preserve">
          <source>If there is a small part of the result that can vary (e.g. a hash in an object representation), you can use &lt;code&gt;...&lt;/code&gt; to represent this part.</source>
          <target state="translated">如果结果的一小部分可能有所不同（例如，对象表示形式中的哈希），则可以使用 &lt;code&gt;...&lt;/code&gt; 表示这一部分。</target>
        </trans-unit>
        <trans-unit id="79166ffe4f486692983ad25c9bb5a734e08993de" translate="yes" xml:space="preserve">
          <source>If there is no good value, NaN is returned for a Series or a Series of NaN values for a DataFrame</source>
          <target state="translated">如果没有好值,则返回一个系列的NaN或一个DataFrame的NaN值系列。</target>
        </trans-unit>
        <trans-unit id="9a50506ea7c3939131db7d78d6afca01537a49a9" translate="yes" xml:space="preserve">
          <source>If this behavior is surprising, keep in mind that using &lt;code&gt;in&lt;/code&gt; on a Python dictionary tests keys, not values, and &lt;code&gt;Series&lt;/code&gt; are dict-like. To test for membership in the values, use the method &lt;a href=&quot;../reference/api/pandas.series.isin#pandas.Series.isin&quot;&gt;&lt;code&gt;isin()&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">如果这种行为令人惊讶，请记住， &lt;code&gt;in&lt;/code&gt; Python字典上使用in会测试键，而不是值，而 &lt;code&gt;Series&lt;/code&gt; 则类似于dict。要测试值中的成员资格，请使用&lt;a href=&quot;../reference/api/pandas.series.isin#pandas.Series.isin&quot;&gt; &lt;code&gt;isin()&lt;/code&gt; &lt;/a&gt;方法：</target>
        </trans-unit>
        <trans-unit id="3c4e4a825180bf8808a64195ae6d697226e17fa3" translate="yes" xml:space="preserve">
          <source>If this parameter is False, sets will not be considered list-like</source>
          <target state="translated">如果这个参数为False,集合将不被视为list-like。</target>
        </trans-unit>
        <trans-unit id="407299ada9b8eb20aa8ecf277a6368180bf252b5" translate="yes" xml:space="preserve">
          <source>If this parameter is False, sets will not be considered list-like.</source>
          <target state="translated">如果该参数为False,则不会将集合视为列表式。</target>
        </trans-unit>
        <trans-unit id="cde86769fd29b3bc205b6c427ec8870bad01f3ff" translate="yes" xml:space="preserve">
          <source>If true, ALL nan rows will not be written to store.</source>
          <target state="translated">如果为 &quot;true&quot;,所有的nan行将不会被写入存储空间。</target>
        </trans-unit>
        <trans-unit id="47999fb8ac96a558b41fd99b5e696eccf4732cbe" translate="yes" xml:space="preserve">
          <source>If true, all rows and columns are kept. Otherwise, only the ones with different values are kept.</source>
          <target state="translated">如果为真,则保留所有的行和列。否则,只保留数值不同的行和列。</target>
        </trans-unit>
        <trans-unit id="3282649a37ac55c74db8a5a1b1a27ca8c630f36d" translate="yes" xml:space="preserve">
          <source>If true, columns will be used as xticks</source>
          <target state="translated">如果为 &quot;true&quot;,则列将作为xticks使用。</target>
        </trans-unit>
        <trans-unit id="0a143ef8b9e23894e4227d511a2a634fc694a65a" translate="yes" xml:space="preserve">
          <source>If true, columns will be used as xticks.</source>
          <target state="translated">如果为真,列将被用作xticks。</target>
        </trans-unit>
        <trans-unit id="a761e46b1b0da1fd384002ba5d9bdd4de4efda77" translate="yes" xml:space="preserve">
          <source>If true, resulting categories will be lexsorted, otherwise they will be ordered as they appear in the data.</source>
          <target state="translated">如果为真,将对产生的类别进行排序,否则将按照数据中出现的类别进行排序。</target>
        </trans-unit>
        <trans-unit id="4fcaa7b2fe91e543e75e6441530fd4b5d810bb7f" translate="yes" xml:space="preserve">
          <source>If true, the ordered attribute of the Categoricals will be ignored. Results in an unordered categorical.</source>
          <target state="translated">如果为真,将忽略分类的有序属性。结果是一个无序的分类。</target>
        </trans-unit>
        <trans-unit id="bcaaeba8088f223fce415445cc2fe59773a45d3f" translate="yes" xml:space="preserve">
          <source>If true, the result keeps values that are equal. Otherwise, equal values are shown as NaNs.</source>
          <target state="translated">如果为真,结果会保留相等的值。否则,相等的值将显示为NaNs。</target>
        </trans-unit>
        <trans-unit id="d1fe920431a3d41d651dfbcc77af70b504aee8c8" translate="yes" xml:space="preserve">
          <source>If true, vertical lines will be added at each xtick</source>
          <target state="translated">如果为 &quot;true&quot;,将在每个xtick处添加垂直线。</target>
        </trans-unit>
        <trans-unit id="2c27e3a5063b9b94517959af47c02a3dd19fa2c3" translate="yes" xml:space="preserve">
          <source>If true, vertical lines will be added at each xtick.</source>
          <target state="translated">如果为真,将在每个xtick处添加垂直线。</target>
        </trans-unit>
        <trans-unit id="ce59a050f48126ce6320c30610faaa9c86fc199e" translate="yes" xml:space="preserve">
          <source>If two CategoricalIndex objects have equal elements True, otherwise False.</source>
          <target state="translated">如果两个CategoricalIndex对象的元素相等,则为True,否则为False。</target>
        </trans-unit>
        <trans-unit id="d639547142f390403b221695989f0de239dbb7b1" translate="yes" xml:space="preserve">
          <source>If two Index objects have equal elements and same type True, otherwise False.</source>
          <target state="translated">如果两个Index对象的元素相等且类型相同,则为True,否则为False。</target>
        </trans-unit>
        <trans-unit id="626c6821778795ed6605d4fcfb4d554d4bb3ee62" translate="yes" xml:space="preserve">
          <source>If unnamed &lt;code&gt;Series&lt;/code&gt; are passed they will be numbered consecutively.</source>
          <target state="translated">如果未命名的 &lt;code&gt;Series&lt;/code&gt; 通过，它们将被连续编号。</target>
        </trans-unit>
        <trans-unit id="952e2dee711cdb4ef88782a2cd0578a6a6843049" translate="yes" xml:space="preserve">
          <source>If using &lt;code&gt;expand=True&lt;/code&gt;, Series and Index callers return DataFrame and MultiIndex objects, respectively.</source>
          <target state="translated">如果使用 &lt;code&gt;expand=True&lt;/code&gt; ，则Series和Index调用者分别返回DataFrame和MultiIndex对象。</target>
        </trans-unit>
        <trans-unit id="4055d83a079c44709ace2481bdd4e3c1f48c7657" translate="yes" xml:space="preserve">
          <source>If using &lt;code&gt;join='right'&lt;/code&gt; on a list-like of &lt;code&gt;others&lt;/code&gt; that contains different indexes, the union of these indexes will be used as the basis for the final concatenation:</source>
          <target state="translated">如果在包含不同索引的 &lt;code&gt;others&lt;/code&gt; 列表类似的列表上使用 &lt;code&gt;join='right'&lt;/code&gt; ，则这些索引的并集将用作最终串联的基础：</target>
        </trans-unit>
        <trans-unit id="a1cf23a69f82311296b7504255332812bccf16b4" translate="yes" xml:space="preserve">
          <source>If using in the Jupyter notebook, Styler has defined a &lt;code&gt;_repr_html_&lt;/code&gt; to automatically render itself. Otherwise call Styler.render to get the generated HTML.</source>
          <target state="translated">如果在Jupyter笔记本中使用，Styler定义了一个 &lt;code&gt;_repr_html_&lt;/code&gt; 以自动呈现自身。否则，调用Styler.render以获取生成的HTML。</target>
        </trans-unit>
        <trans-unit id="302e92543f3f0f75ce924bc7f9f8aa88c440b3a5" translate="yes" xml:space="preserve">
          <source>If warn=True, issue a warning if nanoseconds is nonzero.</source>
          <target state="translated">如果war=Tr,如果纳秒数为非零,则发出警告。</target>
        </trans-unit>
        <trans-unit id="260f17759a03e9b11140d2b1e686eb99c682c39b" translate="yes" xml:space="preserve">
          <source>If we also have a MultiIndex on columns &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt;, we can group by all but the specified columns</source>
          <target state="translated">如果我们在 &lt;code&gt;A&lt;/code&gt; 和 &lt;code&gt;B&lt;/code&gt; 列上也有一个MultiIndex ，则可以按除指定列之外的所有列进行分组</target>
        </trans-unit>
        <trans-unit id="82061eba4d9b00cf01b3ade310c01171b0a5cc2f" translate="yes" xml:space="preserve">
          <source>If we are not dropping the index, by default, it is placed in the top level. We can place it in another level:</source>
          <target state="translated">如果我们没有放弃索引,默认情况下,它被放置在顶层。我们可以将其放置在另一个级别。</target>
        </trans-unit>
        <trans-unit id="b79fd67d25657db5cfcdb0ceff92c9e8f9633182" translate="yes" xml:space="preserve">
          <source>If we have many columns, we could also use a regex to find our stubnames and pass that list on to wide_to_long</source>
          <target state="translated">如果我们有很多列,我们也可以使用一个regex来找到我们的存根名,并将这个列表传递给width_to_long。</target>
        </trans-unit>
        <trans-unit id="7958cdd41a3b26aba9f751c1c05f025c55b1c42f" translate="yes" xml:space="preserve">
          <source>If we need intervals on a regular frequency, we can use the &lt;a href=&quot;../reference/api/pandas.interval_range#pandas.interval_range&quot;&gt;&lt;code&gt;interval_range()&lt;/code&gt;&lt;/a&gt; function to create an &lt;code&gt;IntervalIndex&lt;/code&gt; using various combinations of &lt;code&gt;start&lt;/code&gt;, &lt;code&gt;end&lt;/code&gt;, and &lt;code&gt;periods&lt;/code&gt;. The default frequency for &lt;code&gt;interval_range&lt;/code&gt; is a 1 for numeric intervals, and calendar day for datetime-like intervals:</source>
          <target state="translated">如果我们需要固定频率的&lt;a href=&quot;../reference/api/pandas.interval_range#pandas.interval_range&quot;&gt; &lt;code&gt;interval_range()&lt;/code&gt; &lt;/a&gt;，则可以使用interval_range（）函数使用 &lt;code&gt;start&lt;/code&gt; ， &lt;code&gt;end&lt;/code&gt; 和 &lt;code&gt;periods&lt;/code&gt; 各种组合来创建 &lt;code&gt;IntervalIndex&lt;/code&gt; 。 &lt;code&gt;interval_range&lt;/code&gt; 的默认频率对于数字间隔为1，对于类似于日期时间的间隔为日历日：</target>
        </trans-unit>
        <trans-unit id="f3059eebcb64938e4b7a073e1ffb4bda57975fc0" translate="yes" xml:space="preserve">
          <source>If we only have NaNs in our DataFrame, it is not considered empty! We will need to drop the NaNs to make the DataFrame empty:</source>
          <target state="translated">如果我们的DataFrame中只有NaNs,那么它就不会被认为是空的!我们需要放弃NaNs来使DataFrame为空。我们将需要删除NaNs来使DataFrame为空。</target>
        </trans-unit>
        <trans-unit id="71867c41ff101e2dd9ed7493912c5eb77334366c" translate="yes" xml:space="preserve">
          <source>If we only want consecutive gaps filled up to a certain number of data points, we can use the &lt;code&gt;limit&lt;/code&gt; keyword:</source>
          <target state="translated">如果我们只希望连续的间隙填充到一定数量的数据点，则可以使用 &lt;code&gt;limit&lt;/code&gt; 关键字：</target>
        </trans-unit>
        <trans-unit id="968348830bc4858358f68548de84b2c5a80500f0" translate="yes" xml:space="preserve">
          <source>If we specify a nonexistent level for</source>
          <target state="translated">如果我们指定一个不存在的级别为</target>
        </trans-unit>
        <trans-unit id="c7bb5bb11f2ff2055c13b48cfec8d32f8a45a2e2" translate="yes" xml:space="preserve">
          <source>If we specify a nonexistent level for &lt;code&gt;col_fill&lt;/code&gt;, it is created:</source>
          <target state="translated">如果我们为 &lt;code&gt;col_fill&lt;/code&gt; 指定一个不存在的级别，则会创建它：</target>
        </trans-unit>
        <trans-unit id="f00dc1db037371153c550cb158eb937061016aea" translate="yes" xml:space="preserve">
          <source>If we want to join using the key columns, we need to set key to be the index in both</source>
          <target state="translated">如果我们想使用键列进行连接,我们需要将key设置为这两列中的索引。</target>
        </trans-unit>
        <trans-unit id="7ebde3340d88dc78a7515ebac165ad4cba048950" translate="yes" xml:space="preserve">
          <source>If we want to join using the key columns, we need to set key to be the index in both &lt;code&gt;df&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;. The joined DataFrame will have key as its index.</source>
          <target state="translated">如果要使用键列进行联接，则需要将key设置为 &lt;code&gt;df&lt;/code&gt; 和 &lt;code&gt;other&lt;/code&gt; 的索引。加入的DataFrame将以key作为其索引。</target>
        </trans-unit>
        <trans-unit id="9837dbf801ccbd6d7e3a0358e252af7c064b1881" translate="yes" xml:space="preserve">
          <source>If we want to resample to the full range of the series:</source>
          <target state="translated">如果我们想重新采样到系列的全部范围。</target>
        </trans-unit>
        <trans-unit id="116d297e0a504b613424946f4af9dc6593eaa9dd" translate="yes" xml:space="preserve">
          <source>If we were to measure the memory usage of the two calls, we&amp;rsquo;d see that specifying &lt;code&gt;columns&lt;/code&gt; uses about 1/10th the memory in this case.</source>
          <target state="translated">如果我们要测量两个调用的内存使用情况，则会发现在这种情况下，指定 &lt;code&gt;columns&lt;/code&gt; 使用的内存约为内存的1/10。</target>
        </trans-unit>
        <trans-unit id="e711c3bc9df9cb81190099d32dcc6f9c71c2292f" translate="yes" xml:space="preserve">
          <source>If you &lt;em&gt;must&lt;/em&gt; interpolate, use the &lt;code&gt;'%r'&lt;/code&gt; format specifier</source>
          <target state="translated">如果&lt;em&gt;必须&lt;/em&gt;插值，请使用 &lt;code&gt;'%r'&lt;/code&gt; 格式说明符</target>
        </trans-unit>
        <trans-unit id="3f5b50b561b3e7aa33c127ffbfebf0a7133f79a8" translate="yes" xml:space="preserve">
          <source>If you added the upstream repository as described above you will see something like:</source>
          <target state="translated">如果你添加了如上所述的上游仓库,你会看到类似的东西。</target>
        </trans-unit>
        <trans-unit id="6dcbc8930cebc1be87b34e4cba1b548ad13195a7" translate="yes" xml:space="preserve">
          <source>If you already have &lt;code&gt;codes&lt;/code&gt; and &lt;code&gt;categories&lt;/code&gt;, you can use the &lt;a href=&quot;../reference/api/pandas.categorical.from_codes#pandas.Categorical.from_codes&quot;&gt;&lt;code&gt;from_codes()&lt;/code&gt;&lt;/a&gt; constructor to save the factorize step during normal constructor mode:</source>
          <target state="translated">如果已经有了 &lt;code&gt;codes&lt;/code&gt; 和 &lt;code&gt;categories&lt;/code&gt; ，则可以使用&lt;a href=&quot;../reference/api/pandas.categorical.from_codes#pandas.Categorical.from_codes&quot;&gt; &lt;code&gt;from_codes()&lt;/code&gt; &lt;/a&gt;构造函数在常规构造函数模式下保存分解步骤：</target>
        </trans-unit>
        <trans-unit id="d5c85b3d61764da8be18d5d777eb530f704213c9" translate="yes" xml:space="preserve">
          <source>If you also want to index a specific column with &lt;code&gt;.loc&lt;/code&gt;, you must use a tuple like this:</source>
          <target state="translated">如果您还想使用 &lt;code&gt;.loc&lt;/code&gt; 索引特定的列，则必须使用这样的元组：</target>
        </trans-unit>
        <trans-unit id="65afa83f1a217fb5a6797c63c1a0429f4d6825c0" translate="yes" xml:space="preserve">
          <source>If you are attempting to perform an operation you might see an exception like:</source>
          <target state="translated">如果你试图执行一个操作,你可能会看到这样的异常。</target>
        </trans-unit>
        <trans-unit id="a901823fe7ea06c8a1cd9a222f4bb095acb15157" translate="yes" xml:space="preserve">
          <source>If you are brand new to pandas or open-source development, we recommend going through the &lt;a href=&quot;https://github.com/pandas-dev/pandas/issues&quot;&gt;GitHub &amp;ldquo;issues&amp;rdquo; tab&lt;/a&gt; to find issues that interest you. There are a number of issues listed under &lt;a href=&quot;https://github.com/pandas-dev/pandas/issues?labels=Docs&amp;amp;sort=updated&amp;amp;state=open&quot;&gt;Docs&lt;/a&gt; and &lt;a href=&quot;https://github.com/pandas-dev/pandas/issues?labels=good+first+issue&amp;amp;sort=updated&amp;amp;state=open&quot;&gt;good first issue&lt;/a&gt; where you could start out. Once you&amp;rsquo;ve found an interesting issue, you can return here to get your development environment setup.</source>
          <target state="translated">如果您是熊猫或开源开发的新手，我们建议您通过&lt;a href=&quot;https://github.com/pandas-dev/pandas/issues&quot;&gt;GitHub&amp;ldquo;问题&amp;rdquo;选项卡&lt;/a&gt;查找您感兴趣的问题。有许多的下所列问题的&lt;a href=&quot;https://github.com/pandas-dev/pandas/issues?labels=Docs&amp;amp;sort=updated&amp;amp;state=open&quot;&gt;文档&lt;/a&gt;和&lt;a href=&quot;https://github.com/pandas-dev/pandas/issues?labels=good+first+issue&amp;amp;sort=updated&amp;amp;state=open&quot;&gt;良好的第一个问题&lt;/a&gt;，你可以开始了。找到有趣的问题后，您可以返回此处进行开发环境设置。</target>
        </trans-unit>
        <trans-unit id="465f837f95ed9e96291bb7885669730c62809aef" translate="yes" xml:space="preserve">
          <source>If you are dealing with a time series that is growing at an increasing rate, &lt;code&gt;method='quadratic'&lt;/code&gt; may be appropriate.</source>
          <target state="translated">如果您要处理一个以不断增加的速度增长的时间序列，那么 &lt;code&gt;method='quadratic'&lt;/code&gt; 可能是合适的。</target>
        </trans-unit>
        <trans-unit id="ca624ad660100e102682b9a51c3848478a72f2ee" translate="yes" xml:space="preserve">
          <source>If you are not passing any &lt;code&gt;data_columns&lt;/code&gt;, then the &lt;code&gt;min_itemsize&lt;/code&gt; will be the maximum of the length of any string passed</source>
          <target state="translated">如果没有传递任何 &lt;code&gt;data_columns&lt;/code&gt; ，则 &lt;code&gt;min_itemsize&lt;/code&gt; 将为传递的任何字符串的最大长度</target>
        </trans-unit>
        <trans-unit id="c15a6f9c5535245e9be6fcbd4d03ed646264a348" translate="yes" xml:space="preserve">
          <source>If you are using Python &amp;lt; 3.6 or pandas &amp;lt; 0.23, and &lt;code&gt;columns&lt;/code&gt; is not specified, the &lt;code&gt;DataFrame&lt;/code&gt; columns will be the lexically ordered list of dict keys.</source>
          <target state="translated">如果您在使用Python &amp;lt;3.6或熊猫&amp;lt;0.23， &lt;code&gt;columns&lt;/code&gt; 不被指定， &lt;code&gt;DataFrame&lt;/code&gt; 列将是字典键的词法有序列表。</target>
        </trans-unit>
        <trans-unit id="b1734348d69969fd360e31fd62aca6442bca44f8" translate="yes" xml:space="preserve">
          <source>If you are using dates beyond 2038-01-18, due to current deficiencies in the underlying libraries caused by the year 2038 problem, daylight saving time (DST) adjustments to timezone aware dates will not be applied. If and when the underlying libraries are fixed, the DST transitions will be applied.</source>
          <target state="translated">如果您使用的日期超过2038-01-18,由于2038年问题导致的底层库的当前缺陷,将不会应用时区感知日期的夏令时(DST)调整。如果底层库修复后,将应用DST转换。</target>
        </trans-unit>
        <trans-unit id="b96b99bd90b15f960a8a1d823fd7572e68539985" translate="yes" xml:space="preserve">
          <source>If you are using the IPython environment, you may also use tab-completion to see these accessible attributes.</source>
          <target state="translated">如果你使用的是IPython环境,你也可以使用tab-completion来查看这些可访问的属性。</target>
        </trans-unit>
        <trans-unit id="104adf5a4c3ea5cc99dad3c496195368e599955a" translate="yes" xml:space="preserve">
          <source>If you aren&amp;rsquo;t using conda for your development environment, follow these instructions. You&amp;rsquo;ll need to have at least python3.5 installed on your system.</source>
          <target state="translated">如果您不在开发环境中使用conda，请遵循以下说明。您至少需要在系统上安装python3.5。</target>
        </trans-unit>
        <trans-unit id="1b5a95ce05a5137b543597ab970b813363417ec7" translate="yes" xml:space="preserve">
          <source>If you build a great library on top of this, let us know and we&amp;rsquo;ll &lt;a href=&quot;http://pandas.pydata.org/pandas-docs/stable/ecosystem.html&quot;&gt;link&lt;/a&gt; to it.</source>
          <target state="translated">如果您在此基础上构建了一个很棒的库，请告诉我们，我们将&lt;a href=&quot;http://pandas.pydata.org/pandas-docs/stable/ecosystem.html&quot;&gt;链接&lt;/a&gt;到它。</target>
        </trans-unit>
        <trans-unit id="67704c3d1919945e86ee78d09fa2f38a50a2066f" translate="yes" xml:space="preserve">
          <source>If you build a great library on top of this, let us know and we&amp;rsquo;ll &lt;a href=&quot;https://pandas.pydata.org/pandas-docs/stable/ecosystem.html&quot;&gt;link&lt;/a&gt; to it.</source>
          <target state="translated">如果您在此基础上构建了一个很棒的库，请告诉我们，我们将&lt;a href=&quot;https://pandas.pydata.org/pandas-docs/stable/ecosystem.html&quot;&gt;链接&lt;/a&gt;到它。</target>
        </trans-unit>
        <trans-unit id="741a6d65c45aabc2da8321ecddb112f34bdca128" translate="yes" xml:space="preserve">
          <source>If you create an index yourself, you can just assign it to the &lt;code&gt;index&lt;/code&gt; field:</source>
          <target state="translated">如果您自己创建索引，则可以将其分配给 &lt;code&gt;index&lt;/code&gt; 字段：</target>
        </trans-unit>
        <trans-unit id="2610e8594483b112bc2ba67861d9a8abeac5ec9c" translate="yes" xml:space="preserve">
          <source>If you do wish to include decimal or object columns in an aggregation with other non-nuisance data types, you must do so explicitly.</source>
          <target state="translated">如果您确实希望在聚合中包含十进制或对象列与其他非滋扰数据类型,您必须明确地这样做。</target>
        </trans-unit>
        <trans-unit id="bd6076bc560cf97aea736a51a15e40cbe385b624" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t like the default colours, you can specify how you&amp;rsquo;d like each column to be colored.</source>
          <target state="translated">如果您不喜欢默认颜色，则可以指定希望每列上色的方式。</target>
        </trans-unit>
        <trans-unit id="5a1d9ea7791dacf7b9c85b45bf9ae6bfbc250a85" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t prefix the local variable with &lt;code&gt;@&lt;/code&gt;, pandas will raise an exception telling you the variable is undefined.</source>
          <target state="translated">如果您没有在局部变量前加上 &lt;code&gt;@&lt;/code&gt; ，则pandas会引发异常，告诉您该变量未定义。</target>
        </trans-unit>
        <trans-unit id="417bb3c329e071119224d529f869bb0141b6dcf0" translate="yes" xml:space="preserve">
          <source>If you have &lt;code&gt;parse_dates&lt;/code&gt; enabled for some or all of your columns, and your datetime strings are all formatted the same way, you may get a large speed up by setting &lt;code&gt;infer_datetime_format=True&lt;/code&gt;. If set, pandas will attempt to guess the format of your datetime strings, and then use a faster means of parsing the strings. 5-10x parsing speeds have been observed. pandas will fallback to the usual parsing if either the format cannot be guessed or the format that was guessed cannot properly parse the entire column of strings. So in general, &lt;code&gt;infer_datetime_format&lt;/code&gt; should not have any negative consequences if enabled.</source>
          <target state="translated">如果为部分或全部列启用了 &lt;code&gt;parse_dates&lt;/code&gt; ，并且datetime字符串的格式都相同，则可以通过设置 &lt;code&gt;infer_datetime_format=True&lt;/code&gt; 来大幅度提高速度。如果设置，熊猫将尝试猜测日期时间字符串的格式，然后使用更快的方式解析字符串。已经观察到5-10倍的解析速度。如果无法猜测格式或被猜测的格式无法正确解析整个字符串列，则熊猫将退回到常规解析。因此，一般而言，如果启用 &lt;code&gt;infer_datetime_format&lt;/code&gt; ,则不会产生任何负面影响。</target>
        </trans-unit>
        <trans-unit id="121f2b3e5cfa3e20d0594c4ac58f6710888524e4" translate="yes" xml:space="preserve">
          <source>If you have a &lt;code&gt;Series&lt;/code&gt; where lots of elements are repeated (i.e. the number of unique elements in the &lt;code&gt;Series&lt;/code&gt; is a lot smaller than the length of the &lt;code&gt;Series&lt;/code&gt;), it can be faster to convert the original &lt;code&gt;Series&lt;/code&gt; to one of type &lt;code&gt;category&lt;/code&gt; and then use &lt;code&gt;.str.&amp;lt;method&amp;gt;&lt;/code&gt; or &lt;code&gt;.dt.&amp;lt;property&amp;gt;&lt;/code&gt; on that. The performance difference comes from the fact that, for &lt;code&gt;Series&lt;/code&gt; of type &lt;code&gt;category&lt;/code&gt;, the string operations are done on the &lt;code&gt;.categories&lt;/code&gt; and not on each element of the &lt;code&gt;Series&lt;/code&gt;.</source>
          <target state="translated">如果你有一个 &lt;code&gt;Series&lt;/code&gt; ，在那里重复大量元素（即独特的元素个数 &lt;code&gt;Series&lt;/code&gt; 比长度小了很多 &lt;code&gt;Series&lt;/code&gt; ），它能够更快的原转换 &lt;code&gt;Series&lt;/code&gt; ，以类型的一个 &lt;code&gt;category&lt;/code&gt; ，然后使用 &lt;code&gt;.str.&amp;lt;method&amp;gt;&lt;/code&gt; 或 &lt;code&gt;.dt.&amp;lt;property&amp;gt;&lt;/code&gt; 。性能差异来自以下事实：对于类型 &lt;code&gt;category&lt;/code&gt; &lt;code&gt;Series&lt;/code&gt; ，字符串操作是在 &lt;code&gt;.categories&lt;/code&gt; 上执行的，而不是在 &lt;code&gt;Series&lt;/code&gt; 的每个元素上执行的。</target>
        </trans-unit>
        <trans-unit id="c991175b9cdf3e6da785720a9bef9cdc38f17c27" translate="yes" xml:space="preserve">
          <source>If you have a DataFrame or Series using traditional types that have missing data represented using &lt;code&gt;np.nan&lt;/code&gt;, there are convenience methods &lt;a href=&quot;../reference/api/pandas.series.convert_dtypes#pandas.Series.convert_dtypes&quot;&gt;&lt;code&gt;convert_dtypes()&lt;/code&gt;&lt;/a&gt; in Series and &lt;a href=&quot;../reference/api/pandas.dataframe.convert_dtypes#pandas.DataFrame.convert_dtypes&quot;&gt;&lt;code&gt;convert_dtypes()&lt;/code&gt;&lt;/a&gt; in DataFrame that can convert data to use the newer dtypes for integers, strings and booleans listed &lt;a href=&quot;basics#basics-dtypes&quot;&gt;here&lt;/a&gt;. This is especially helpful after reading in data sets when letting the readers such as &lt;a href=&quot;../reference/api/pandas.read_csv#pandas.read_csv&quot;&gt;&lt;code&gt;read_csv()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../reference/api/pandas.read_excel#pandas.read_excel&quot;&gt;&lt;code&gt;read_excel()&lt;/code&gt;&lt;/a&gt; infer default dtypes.</source>
          <target state="translated">如果您的DataFrame或Series使用的传统类型缺少使用 &lt;code&gt;np.nan&lt;/code&gt; 表示的数据，则可以使用Series中的便捷方法&lt;a href=&quot;../reference/api/pandas.series.convert_dtypes#pandas.Series.convert_dtypes&quot;&gt; &lt;code&gt;convert_dtypes()&lt;/code&gt; &lt;/a&gt;和DataFrame中的&lt;a href=&quot;../reference/api/pandas.dataframe.convert_dtypes#pandas.DataFrame.convert_dtypes&quot;&gt; &lt;code&gt;convert_dtypes()&lt;/code&gt; &lt;/a&gt;来将数据转换为对整数，字符串和布尔值使用较新的dtypes在&lt;a href=&quot;basics#basics-dtypes&quot;&gt;这里&lt;/a&gt;列出。当让诸如&lt;a href=&quot;../reference/api/pandas.read_csv#pandas.read_csv&quot;&gt; &lt;code&gt;read_csv()&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../reference/api/pandas.read_excel#pandas.read_excel&quot;&gt; &lt;code&gt;read_excel()&lt;/code&gt; 之&lt;/a&gt;类的读取器推断默认dtypes时，在读取数据集后这特别有用。</target>
        </trans-unit>
        <trans-unit id="a6d12092a100fe501656091bdf566b30b2ed9abe" translate="yes" xml:space="preserve">
          <source>If you have a code snippet that wraps multiple lines, you need to use &amp;lsquo;&amp;hellip;&amp;rsquo; on the continued lines:</source>
          <target state="translated">如果您有一个包含多行代码的代码段，则需要在续行上使用&amp;ldquo; ...&amp;rdquo;：</target>
        </trans-unit>
        <trans-unit id="ce1c3f4a8b1303b2233ce9f8b61542133b12817a" translate="yes" xml:space="preserve">
          <source>If you have a function that takes the data as (say) the second argument, pass a tuple indicating which keyword expects the data. For example, suppose &lt;code&gt;f&lt;/code&gt; takes its data as &lt;code&gt;arg2&lt;/code&gt;:</source>
          <target state="translated">如果您有一个将数据作为（例如）第二个参数的函数，则传递一个元组，指示哪个关键字需要该数据。例如，假设 &lt;code&gt;f&lt;/code&gt; 将其数据作为 &lt;code&gt;arg2&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="56a4c8962933a12e5a9e2a5d7dffcb9394a6134b" translate="yes" xml:space="preserve">
          <source>If you have a really non-standard format, use a custom &lt;code&gt;date_parser&lt;/code&gt; function. For optimal performance, this should be vectorized, i.e., it should accept arrays as arguments.</source>
          <target state="translated">如果您使用的是非标准格式，请使用自定义的 &lt;code&gt;date_parser&lt;/code&gt; 函数。为了获得最佳性能，应对此进行矢量化处理，即应接受数组作为参数。</target>
        </trans-unit>
        <trans-unit id="4bce04d77a3695fe541ba97dbace1da91706c1a3" translate="yes" xml:space="preserve">
          <source>If you have a test that would emit a warning, but you aren&amp;rsquo;t actually testing the warning itself (say because it&amp;rsquo;s going to be removed in the future, or because we&amp;rsquo;re matching a 3rd-party library&amp;rsquo;s behavior), then use &lt;code&gt;pytest.mark.filterwarnings&lt;/code&gt; to ignore the error.</source>
          <target state="translated">如果您有一个会发出警告的测试，但是您实际上并没有对警告本身进行测试（例如，因为将来将要删除该警告，或者因为我们要匹配第3方库的行为），请使用 &lt;code&gt;pytest.mark.filterwarnings&lt;/code&gt; 忽略该错误。</target>
        </trans-unit>
        <trans-unit id="71117c5bba102f9e8b43378fc40f53207cd5d122" translate="yes" xml:space="preserve">
          <source>If you have an SQLAlchemy description of your database you can express where conditions using SQLAlchemy expressions</source>
          <target state="translated">如果您有一个SQLAlchemy对数据库的描述,您可以使用SQLAlchemy表达式表达where条件</target>
        </trans-unit>
        <trans-unit id="1e53b0f81dd0d27916b9567f3537fac3de69986c" translate="yes" xml:space="preserve">
          <source>If you have created a new file, it is not being tracked by git. Add it by typing:</source>
          <target state="translated">如果您创建了一个新文件,它没有被 git 跟踪。请输入</target>
        </trans-unit>
        <trans-unit id="15be1e2a8dd36c4d3fa91d03c09bda6ba985f358" translate="yes" xml:space="preserve">
          <source>If you have data that is outside of the &lt;code&gt;Timestamp&lt;/code&gt; bounds, see &lt;a href=&quot;#timeseries-timestamp-limits&quot;&gt;Timestamp limitations&lt;/a&gt;, then you can use a &lt;code&gt;PeriodIndex&lt;/code&gt; and/or &lt;code&gt;Series&lt;/code&gt; of &lt;code&gt;Periods&lt;/code&gt; to do computations.</source>
          <target state="translated">如果你有一个是外部的数据 &lt;code&gt;Timestamp&lt;/code&gt; 界限，看到&lt;a href=&quot;#timeseries-timestamp-limits&quot;&gt;时间戳限制&lt;/a&gt;，那么你可以使用一个 &lt;code&gt;PeriodIndex&lt;/code&gt; 和/或 &lt;code&gt;Series&lt;/code&gt; 的 &lt;code&gt;Periods&lt;/code&gt; 做计算。</target>
        </trans-unit>
        <trans-unit id="efd3e79e7aaca2c9a3799bfafe49c89cd6d0b4f3" translate="yes" xml:space="preserve">
          <source>If you have more than one plot that needs to be suppressed, the &lt;code&gt;use&lt;/code&gt; method in &lt;code&gt;pandas.plotting.plot_params&lt;/code&gt; can be used in a &lt;code&gt;with&lt;/code&gt; statement:</source>
          <target state="translated">如果您需要抑制多个绘图，则可以在 &lt;code&gt;with&lt;/code&gt; 语句中使用 &lt;code&gt;pandas.plotting.plot_params&lt;/code&gt; 中的 &lt;code&gt;use&lt;/code&gt; 方法：</target>
        </trans-unit>
        <trans-unit id="88a4ccdcf75e8833f91575d8840de48cc6dfbca8" translate="yes" xml:space="preserve">
          <source>If you have multi-index columns:</source>
          <target state="translated">如果你有多索引列。</target>
        </trans-unit>
        <trans-unit id="1610c5a9f274b426003a33163f560701a7d5688a" translate="yes" xml:space="preserve">
          <source>If you have multiple conditions, you can use &lt;a href=&quot;https://numpy.org/doc/stable/reference/generated/numpy.select.html#numpy.select&quot;&gt;&lt;code&gt;numpy.select()&lt;/code&gt;&lt;/a&gt; to achieve that. Say corresponding to three conditions there are three choice of colors, with a fourth color as a fallback, you can do the following.</source>
          <target state="translated">如果您有多个条件，则可以使用&lt;a href=&quot;https://numpy.org/doc/stable/reference/generated/numpy.select.html#numpy.select&quot;&gt; &lt;code&gt;numpy.select()&lt;/code&gt; &lt;/a&gt;来实现。说出对应于三个条件的三种颜色可供选择，以第四种颜色作为后备，您可以执行以下操作。</target>
        </trans-unit>
        <trans-unit id="5ad80e0520119e0bea6b4d13398628db73a1bdcc" translate="yes" xml:space="preserve">
          <source>If you have uncommitted changes at the moment you want to update the branch with master, you will need to &lt;code&gt;stash&lt;/code&gt; them prior to updating (see the &lt;a href=&quot;https://git-scm.com/book/en/v2/Git-Tools-Stashing-and-Cleaning&quot;&gt;stash docs&lt;/a&gt;). This will effectively store your changes and they can be reapplied after updating.</source>
          <target state="translated">如果您要使用master更新分支时尚未提交更改，则需要在更新之前对其进行 &lt;code&gt;stash&lt;/code&gt; （请参见&lt;a href=&quot;https://git-scm.com/book/en/v2/Git-Tools-Stashing-and-Cleaning&quot;&gt;stash docs&lt;/a&gt;）。这将有效地存储您的更改，并且可以在更新后重新应用它们。</target>
        </trans-unit>
        <trans-unit id="247d69c8f2cc4de2283149f111517ab75bb87577" translate="yes" xml:space="preserve">
          <source>If you have values approximating a cumulative distribution function, then &lt;code&gt;method='pchip'&lt;/code&gt; should work well.</source>
          <target state="translated">如果您的值近似于累积分布函数，则 &lt;code&gt;method='pchip'&lt;/code&gt; 应该可以正常工作。</target>
        </trans-unit>
        <trans-unit id="71d3bbb491c7ab50f4e3fb55087b95818a33a2bf" translate="yes" xml:space="preserve">
          <source>If you just want to handle one column as a categorical variable (like R&amp;rsquo;s factor), you can use &lt;code&gt;df[&quot;cat_col&quot;] = pd.Categorical(df[&quot;col&quot;])&lt;/code&gt; or &lt;code&gt;df[&quot;cat_col&quot;] = df[&quot;col&quot;].astype(&quot;category&quot;)&lt;/code&gt;. For full docs on &lt;a href=&quot;../reference/api/pandas.categorical#pandas.Categorical&quot;&gt;&lt;code&gt;Categorical&lt;/code&gt;&lt;/a&gt;, see the &lt;a href=&quot;categorical#categorical&quot;&gt;Categorical introduction&lt;/a&gt; and the &lt;a href=&quot;../reference/arrays#api-arrays-categorical&quot;&gt;API documentation&lt;/a&gt;.</source>
          <target state="translated">如果只想将一列作为分类变量（如R的因数）处理，则可以使用 &lt;code&gt;df[&quot;cat_col&quot;] = pd.Categorical(df[&quot;col&quot;])&lt;/code&gt; 或 &lt;code&gt;df[&quot;cat_col&quot;] = df[&quot;col&quot;].astype(&quot;category&quot;)&lt;/code&gt; 。有关&lt;a href=&quot;../reference/api/pandas.categorical#pandas.Categorical&quot;&gt; &lt;code&gt;Categorical&lt;/code&gt; 的&lt;/a&gt;完整文档，请参阅&lt;a href=&quot;categorical#categorical&quot;&gt;Categorical简介&lt;/a&gt;和&lt;a href=&quot;../reference/arrays#api-arrays-categorical&quot;&gt;API文档&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c9ea4b81cff5c89da5d8728c0c720182331aed2b" translate="yes" xml:space="preserve">
          <source>If you know the format, use &lt;code&gt;pd.to_datetime()&lt;/code&gt;: &lt;code&gt;date_parser=lambda x: pd.to_datetime(x, format=...)&lt;/code&gt;.</source>
          <target state="translated">如果知道格式，请使用 &lt;code&gt;pd.to_datetime()&lt;/code&gt; ： &lt;code&gt;date_parser=lambda x: pd.to_datetime(x, format=...)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4a716fc818c498688ccdf097fd60bb57e60c32a5" translate="yes" xml:space="preserve">
          <source>If you know you need a NumPy array, use &lt;a href=&quot;../reference/api/pandas.series.to_numpy#pandas.Series.to_numpy&quot;&gt;&lt;code&gt;to_numpy()&lt;/code&gt;&lt;/a&gt; or &lt;code&gt;numpy.asarray()&lt;/code&gt;.</source>
          <target state="translated">如果知道需要NumPy数组，请使用&lt;a href=&quot;../reference/api/pandas.series.to_numpy#pandas.Series.to_numpy&quot;&gt; &lt;code&gt;to_numpy()&lt;/code&gt; &lt;/a&gt;或 &lt;code&gt;numpy.asarray()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="eadfdb34403ad34e86a99ae41be9ea1264eab6e2" translate="yes" xml:space="preserve">
          <source>If you need additional logic to handle duplicate labels, rather than just dropping the repeats, using &lt;code&gt;groupby()&lt;/code&gt; on the index is a common trick. For example, we&amp;rsquo;ll resolve duplicates by taking the average of all rows with the same label.</source>
          <target state="translated">如果您需要其他逻辑来处理重复的标签，而不只是丢弃重复的标签，则在索引上使用 &lt;code&gt;groupby()&lt;/code&gt; 是一个常见的技巧。例如，我们将对所有具有相同标签的行取平均值来解决重复项。</target>
        </trans-unit>
        <trans-unit id="1285b10e07e025b0f5ded4a959a18da26d5f6127" translate="yes" xml:space="preserve">
          <source>If you need finer-grained control, you can use Python&amp;rsquo;s usual &lt;a href=&quot;https://docs.python.org/3/library/warnings.html&quot;&gt;warnings module&lt;/a&gt; to control whether a warning is ignored / raised at different places within a single test.</source>
          <target state="translated">如果需要更细粒度的控制，则可以使用Python的常规&lt;a href=&quot;https://docs.python.org/3/library/warnings.html&quot;&gt;警告模块&lt;/a&gt;来控制在单个测试中的不同位置是否忽略/提出警告。</target>
        </trans-unit>
        <trans-unit id="56e5fa9a528ad91081e25594019830af1e89d7a2" translate="yes" xml:space="preserve">
          <source>If you need integer based selection, you should use &lt;code&gt;iloc&lt;/code&gt;:</source>
          <target state="translated">如果需要基于整数的选择，则应使用 &lt;code&gt;iloc&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="9abdfc1c00b5fd40564a95fa7255b69eb7054961" translate="yes" xml:space="preserve">
          <source>If you need packages that are available to pip but not conda, then install pip, and then use pip to install those packages:</source>
          <target state="translated">如果你需要的包是pip可以使用的,但不是conda,那就安装pip,然后用pip来安装这些包。</target>
        </trans-unit>
        <trans-unit id="f1e4f52552e9e7307e462d0dc56ddd6709abf810" translate="yes" xml:space="preserve">
          <source>If you need the actual array backing a &lt;code&gt;Series&lt;/code&gt;, use &lt;a href=&quot;../reference/api/pandas.series.array#pandas.Series.array&quot;&gt;&lt;code&gt;Series.array&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果需要支持 &lt;code&gt;Series&lt;/code&gt; 的实际数组，请使用&lt;a href=&quot;../reference/api/pandas.series.array#pandas.Series.array&quot;&gt; &lt;code&gt;Series.array&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b3bc12041bab368ec20ccfaba0caed898614b818" translate="yes" xml:space="preserve">
          <source>If you need to do iterative manipulations on the values but performance is important, consider writing the inner loop with cython or numba. See the &lt;a href=&quot;enhancingperf#enhancingperf&quot;&gt;enhancing performance&lt;/a&gt; section for some examples of this approach.</source>
          <target state="translated">如果需要对值进行迭代操作，但是性能很重要，请考虑使用cython或numba编写内部循环。有关此方法的一些示例，请参见&lt;a href=&quot;enhancingperf#enhancingperf&quot;&gt;增强性能&lt;/a&gt;部分。</target>
        </trans-unit>
        <trans-unit id="2163ffd026f03007f2657d1aa45cced3b636cb62" translate="yes" xml:space="preserve">
          <source>If you need to represent integers with possibly missing values, use one of the nullable-integer extension dtypes provided by pandas</source>
          <target state="translated">如果你需要用可能缺失的值来表示整数,可以使用pandas提供的nullable-integer扩展dtypes之一。</target>
        </trans-unit>
        <trans-unit id="a6464b5756b83cd90f8547c8b9746a2e4119403d" translate="yes" xml:space="preserve">
          <source>If you need to run a benchmark, change your directory to &lt;code&gt;asv_bench/&lt;/code&gt; and run:</source>
          <target state="translated">如果需要运行基准测试，请将目录更改为 &lt;code&gt;asv_bench/&lt;/code&gt; 并运行：</target>
        </trans-unit>
        <trans-unit id="5cd75591fba8c48a6ec96f77cf45ec1114588623" translate="yes" xml:space="preserve">
          <source>If you pass &lt;code&gt;margins=True&lt;/code&gt; to &lt;code&gt;pivot_table&lt;/code&gt;, special &lt;code&gt;All&lt;/code&gt; columns and rows will be added with partial group aggregates across the categories on the rows and columns:</source>
          <target state="translated">如果您通过 &lt;code&gt;margins=True&lt;/code&gt; 到 &lt;code&gt;pivot_table&lt;/code&gt; ，则特殊的 &lt;code&gt;All&lt;/code&gt; 列和行将添加有跨行和列的类别的部分组聚合：</target>
        </trans-unit>
        <trans-unit id="976af2f6fab5f0ae12fdcf76be0120e4404254cf" translate="yes" xml:space="preserve">
          <source>If you pass &lt;code&gt;orient='index'&lt;/code&gt;, the keys will be the row labels. In this case, you can also pass the desired column names:</source>
          <target state="translated">如果通过 &lt;code&gt;orient='index'&lt;/code&gt; ，则键将成为行标签。在这种情况下，您还可以传递所需的列名：</target>
        </trans-unit>
        <trans-unit id="8b70868c4ee48742da635c260d8cd9f3a080b210" translate="yes" xml:space="preserve">
          <source>If you pass a Series to &lt;a href=&quot;../reference/api/pandas.dataframe.align#pandas.DataFrame.align&quot;&gt;&lt;code&gt;DataFrame.align()&lt;/code&gt;&lt;/a&gt;, you can choose to align both objects either on the DataFrame&amp;rsquo;s index or columns using the &lt;code&gt;axis&lt;/code&gt; argument:</source>
          <target state="translated">如果将Series传递给&lt;a href=&quot;../reference/api/pandas.dataframe.align#pandas.DataFrame.align&quot;&gt; &lt;code&gt;DataFrame.align()&lt;/code&gt; &lt;/a&gt;，则可以选择使用 &lt;code&gt;axis&lt;/code&gt; 参数在DataFrame的索引或列上对齐两个对象：</target>
        </trans-unit>
        <trans-unit id="9b0a373c7cc571366c10185793baa20f98905f8d" translate="yes" xml:space="preserve">
          <source>If you pass a function, it must return a value when called with any of the labels (and must produce a set of unique values). A dict or Series can also be used:</source>
          <target state="translated">如果你传递了一个函数,当调用任何一个标签时,它必须返回一个值(并且必须产生一组唯一的值)。也可以使用dict或Series。</target>
        </trans-unit>
        <trans-unit id="31c6e882d9eb5401127c01282e6bbb98c5ee31ca" translate="yes" xml:space="preserve">
          <source>If you pass a single string to &lt;code&gt;to_datetime&lt;/code&gt;, it returns a single &lt;code&gt;Timestamp&lt;/code&gt;. &lt;code&gt;Timestamp&lt;/code&gt; can also accept string input, but it doesn&amp;rsquo;t accept string parsing options like &lt;code&gt;dayfirst&lt;/code&gt; or &lt;code&gt;format&lt;/code&gt;, so use &lt;code&gt;to_datetime&lt;/code&gt; if these are required.</source>
          <target state="translated">如果将单个字符串传递给 &lt;code&gt;to_datetime&lt;/code&gt; ，它将返回单个 &lt;code&gt;Timestamp&lt;/code&gt; 。 &lt;code&gt;Timestamp&lt;/code&gt; 也可以接受字符串输入，但不接受诸如 &lt;code&gt;dayfirst&lt;/code&gt; 或 &lt;code&gt;format&lt;/code&gt; 之类的字符串解析选项，因此如果需要，请使用 &lt;code&gt;to_datetime&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8f45d99e2ee0921bed375bc8861439fdec9a9792" translate="yes" xml:space="preserve">
          <source>If you pass values whose sum total is less than 1.0, matplotlib draws a semicircle.</source>
          <target state="translated">如果你传递的值总和小于1.0,matplotlib会画一个半圆。</target>
        </trans-unit>
        <trans-unit id="632406b5aa18fdb674faf69296473f0d12e452b9" translate="yes" xml:space="preserve">
          <source>If you see output like the below in &lt;a href=&quot;#contributing-ci&quot;&gt;Continuous Integration&lt;/a&gt; checks:</source>
          <target state="translated">如果您在&lt;a href=&quot;#contributing-ci&quot;&gt;持续集成&lt;/a&gt;检查中看到如下输出：</target>
        </trans-unit>
        <trans-unit id="288307bac0582bc58303b0b714a45cbb853bef32" translate="yes" xml:space="preserve">
          <source>If you select a label &lt;em&gt;contained&lt;/em&gt; within an interval, this will also select the interval.</source>
          <target state="translated">如果选择间隔中&lt;em&gt;包含&lt;/em&gt;的标签，这还将选择间隔。</target>
        </trans-unit>
        <trans-unit id="97fe72667c3b81a7bfa27ffdd0cd1ec5b244cfc6" translate="yes" xml:space="preserve">
          <source>If you use dates which start with the day first (i.e. European style), you can pass the &lt;code&gt;dayfirst&lt;/code&gt; flag:</source>
          <target state="translated">如果您使用以第一天（即欧式风格）开始的日期，则可以传递 &lt;code&gt;dayfirst&lt;/code&gt; 标志：</target>
        </trans-unit>
        <trans-unit id="826366db7d9516e4c1549c46a4ef6fe02c423fcb" translate="yes" xml:space="preserve">
          <source>If you use locks to manage write access between multiple processes, you may want to use &lt;a href=&quot;https://docs.python.org/3/library/os.html#os.fsync&quot;&gt;&lt;code&gt;fsync()&lt;/code&gt;&lt;/a&gt; before releasing write locks. For convenience you can use &lt;code&gt;store.flush(fsync=True)&lt;/code&gt; to do this for you.</source>
          <target state="translated">如果使用锁来管理多个进程之间的写访问，则可能要在释放写锁之前使用&lt;a href=&quot;https://docs.python.org/3/library/os.html#os.fsync&quot;&gt; &lt;code&gt;fsync()&lt;/code&gt; &lt;/a&gt;。为了方便起见，您可以使用 &lt;code&gt;store.flush(fsync=True)&lt;/code&gt; 为您执行此操作。</target>
        </trans-unit>
        <trans-unit id="2b6748b33160c9896abd9c3b4018432b2fa8ff70" translate="yes" xml:space="preserve">
          <source>If you want a</source>
          <target state="translated">如果你想要一个</target>
        </trans-unit>
        <trans-unit id="30ed4c27edf0b54fe936d124ccd9179b9a98665c" translate="yes" xml:space="preserve">
          <source>If you want a &lt;code&gt;defaultdict&lt;/code&gt;, you need to initialize it:</source>
          <target state="translated">如果需要 &lt;code&gt;defaultdict&lt;/code&gt; ，则需要对其进行初始化：</target>
        </trans-unit>
        <trans-unit id="da78135cd296f262655fefcba77395d1f17b8c5b" translate="yes" xml:space="preserve">
          <source>If you want literal replacement of a string (equivalent to &lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#str.replace&quot;&gt;&lt;code&gt;str.replace()&lt;/code&gt;&lt;/a&gt;), you can set the optional &lt;code&gt;regex&lt;/code&gt; parameter to &lt;code&gt;False&lt;/code&gt;, rather than escaping each character. In this case both &lt;code&gt;pat&lt;/code&gt; and &lt;code&gt;repl&lt;/code&gt; must be strings:</source>
          <target state="translated">如果要字面替换字符串（等效于&lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#str.replace&quot;&gt; &lt;code&gt;str.replace()&lt;/code&gt; &lt;/a&gt;）， &lt;code&gt;regex&lt;/code&gt; 可以将可选的regex参数设置为 &lt;code&gt;False&lt;/code&gt; ，而不是转义每个字符。在这种情况下， &lt;code&gt;pat&lt;/code&gt; 和 &lt;code&gt;repl&lt;/code&gt; 都必须是字符串：</target>
        </trans-unit>
        <trans-unit id="e6b94aa79bc7cda927f9dd9bef83486c02c863c7" translate="yes" xml:space="preserve">
          <source>If you want the &lt;em&gt;index&lt;/em&gt; of the maximum, use &lt;code&gt;idxmax&lt;/code&gt;. This is the equivalent of the &lt;code&gt;numpy.ndarray&lt;/code&gt; method &lt;code&gt;argmax&lt;/code&gt;.</source>
          <target state="translated">如果您想要最大的&lt;em&gt;索引&lt;/em&gt;，请使用 &lt;code&gt;idxmax&lt;/code&gt; 。这等效于 &lt;code&gt;numpy.ndarray&lt;/code&gt; 方法 &lt;code&gt;argmax&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="da99536b7cebadbafed991dfc4d1e9297843d4f2" translate="yes" xml:space="preserve">
          <source>If you want the &lt;em&gt;index&lt;/em&gt; of the maximum, use &lt;code&gt;idxmax&lt;/code&gt;. This isthe equivalent of the &lt;code&gt;numpy.ndarray&lt;/code&gt; method &lt;code&gt;argmax&lt;/code&gt;.</source>
          <target state="translated">如果您想要最大的&lt;em&gt;索引&lt;/em&gt;，请使用 &lt;code&gt;idxmax&lt;/code&gt; 。这等效于 &lt;code&gt;numpy.ndarray&lt;/code&gt; 方法 &lt;code&gt;argmax&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9b950797521b756aeaf591d6f6cec56c5160f174" translate="yes" xml:space="preserve">
          <source>If you want the &lt;em&gt;index&lt;/em&gt; of the minimum, use &lt;code&gt;idxmin&lt;/code&gt;. This is the equivalent of the &lt;code&gt;numpy.ndarray&lt;/code&gt; method &lt;code&gt;argmin&lt;/code&gt;.</source>
          <target state="translated">如果要最小的&lt;em&gt;索引&lt;/em&gt;，请使用 &lt;code&gt;idxmin&lt;/code&gt; 。这相当于所述的 &lt;code&gt;numpy.ndarray&lt;/code&gt; 方法 &lt;code&gt;argmin&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4215c4240d2b96b95049f942871fecaec754b8c9" translate="yes" xml:space="preserve">
          <source>If you want the &lt;em&gt;index&lt;/em&gt; of the minimum, use &lt;code&gt;idxmin&lt;/code&gt;. This isthe equivalent of the &lt;code&gt;numpy.ndarray&lt;/code&gt; method &lt;code&gt;argmin&lt;/code&gt;.</source>
          <target state="translated">如果要最小的&lt;em&gt;索引&lt;/em&gt;，请使用 &lt;code&gt;idxmin&lt;/code&gt; 。此isthe当量的 &lt;code&gt;numpy.ndarray&lt;/code&gt; 方法 &lt;code&gt;argmin&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="324b614ff3eac5f57300aa2b07bed38fd549fbcf" translate="yes" xml:space="preserve">
          <source>If you want to adjust the start of the bins based on a fixed timestamp:</source>
          <target state="translated">如果你想根据固定的时间戳来调整料仓的开始。</target>
        </trans-unit>
        <trans-unit id="d48bf81b5b17c8f77d08206ccd9d4824d6c3996e" translate="yes" xml:space="preserve">
          <source>If you want to adjust the start of the bins with an</source>
          <target state="translated">如果你想调整料仓的起始点,用一个</target>
        </trans-unit>
        <trans-unit id="38c72be389f57078f7031a3f750835e41af8a1e4" translate="yes" xml:space="preserve">
          <source>If you want to combine categoricals that do not necessarily have the same categories,</source>
          <target state="translated">如果你想把不一定有相同类别的分类组合起来。</target>
        </trans-unit>
        <trans-unit id="90ceed891230ae542e55ffbac52ad427e321e79a" translate="yes" xml:space="preserve">
          <source>If you want to combine categoricals that do not necessarily have the same categories, &lt;code&gt;union_categoricals&lt;/code&gt; will combine a list-like of categoricals. The new categories will be the union of the categories being combined.</source>
          <target state="translated">如果要合并不一定具有相同类别的分类，则 &lt;code&gt;union_categoricals&lt;/code&gt; 将合并类似列表的分类。新类别将是被合并类别的并集。</target>
        </trans-unit>
        <trans-unit id="f70b3672763179b3ba5414e9cc915c8902e77cfd" translate="yes" xml:space="preserve">
          <source>If you want to combine categoricals that do not necessarily have the same categories, the &lt;a href=&quot;../reference/api/pandas.api.types.union_categoricals#pandas.api.types.union_categoricals&quot;&gt;&lt;code&gt;union_categoricals()&lt;/code&gt;&lt;/a&gt; function will combine a list-like of categoricals. The new categories will be the union of the categories being combined.</source>
          <target state="translated">如果要合并不一定具有相同类别的分类，则&lt;a href=&quot;../reference/api/pandas.api.types.union_categoricals#pandas.api.types.union_categoricals&quot;&gt; &lt;code&gt;union_categoricals()&lt;/code&gt; &lt;/a&gt;函数将合并类似列表的分类。新类别将是被合并类别的并集。</target>
        </trans-unit>
        <trans-unit id="cb077c2288f1403c4b0ecbd42403a54af7be64aa" translate="yes" xml:space="preserve">
          <source>If you want to consider &lt;code&gt;inf&lt;/code&gt; and &lt;code&gt;-inf&lt;/code&gt; to be &amp;ldquo;NA&amp;rdquo; in computations, you can set &lt;code&gt;pandas.options.mode.use_inf_as_na = True&lt;/code&gt;.</source>
          <target state="translated">如果要在计算 &lt;code&gt;-inf&lt;/code&gt; &lt;code&gt;inf&lt;/code&gt; 和-inf视为&amp;ldquo; NA&amp;rdquo;，则可以设置 &lt;code&gt;pandas.options.mode.use_inf_as_na = True&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="105ffd39b32076ebf1ebd3d7165f004063f83832" translate="yes" xml:space="preserve">
          <source>If you want to do a &amp;ldquo;non-equality&amp;rdquo; comparison of a categorical series with a list-like object which is not categorical data, you need to be explicit and convert the categorical data back to the original values:</source>
          <target state="translated">如果要对分类序列与不是分类数据的类似列表的对象进行&amp;ldquo;非相等&amp;rdquo;比较，则需要明确，并将分类数据转换回原始值：</target>
        </trans-unit>
        <trans-unit id="3a494419aff90e75a65fca5fcb99703bd1e43872" translate="yes" xml:space="preserve">
          <source>If you want to do a full clean build, do:</source>
          <target state="translated">如果你想做一个完全干净的构建,做。</target>
        </trans-unit>
        <trans-unit id="9364d4a7de813e6cc040e7514a87f830c1e52fa7" translate="yes" xml:space="preserve">
          <source>If you want to do remove and add new categories in one step (which has some speed advantage), or simply set the categories to a predefined scale, use &lt;code&gt;set_categories()&lt;/code&gt;.</source>
          <target state="translated">如果您要一步一步地删除和添加新类别（这在速度方面有优势），或者只是将类别设置为预定义的比例，请使用 &lt;code&gt;set_categories()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="496ed137ac195eaa0b96ba47dbede5d3d45026e0" translate="yes" xml:space="preserve">
          <source>If you want to get a buffer to the parquet content you can use a io.BytesIO object, as long as you don&amp;rsquo;t use partition_cols, which creates multiple files.</source>
          <target state="translated">如果要为镶木地板内容获取缓冲区，可以使用io.BytesIO对象，只要不使用partition_cols即可创建多个文件。</target>
        </trans-unit>
        <trans-unit id="2ca2aaf5871712e332fd47e4529e86f2d40fbf9d" translate="yes" xml:space="preserve">
          <source>If you want to have more control on which packages, or have a limited internet bandwidth, then installing pandas with &lt;a href=&quot;http://conda.pydata.org/miniconda.html&quot;&gt;Miniconda&lt;/a&gt; may be a better solution.</source>
          <target state="translated">如果您想更好地控制哪些软件包或互联网带宽有限，那么使用&lt;a href=&quot;http://conda.pydata.org/miniconda.html&quot;&gt;Miniconda&lt;/a&gt;安装熊猫可能是一个更好的解决方案。</target>
        </trans-unit>
        <trans-unit id="6e630d4535a19d2c51476c3a14031d74da486a01" translate="yes" xml:space="preserve">
          <source>If you want to hide wedge labels, specify &lt;code&gt;labels=None&lt;/code&gt;. If &lt;code&gt;fontsize&lt;/code&gt; is specified, the value will be applied to wedge labels. Also, other keywords supported by &lt;a href=&quot;https://matplotlib.org/api/_as_gen/matplotlib.pyplot.pie.html#matplotlib.pyplot.pie&quot;&gt;&lt;code&gt;matplotlib.pyplot.pie()&lt;/code&gt;&lt;/a&gt; can be used.</source>
          <target state="translated">如果要隐藏楔形标签，请指定 &lt;code&gt;labels=None&lt;/code&gt; 。如果指定了 &lt;code&gt;fontsize&lt;/code&gt; ，则该值将应用于楔形标签。另外，可以使用&lt;a href=&quot;https://matplotlib.org/api/_as_gen/matplotlib.pyplot.pie.html#matplotlib.pyplot.pie&quot;&gt; &lt;code&gt;matplotlib.pyplot.pie()&lt;/code&gt; &lt;/a&gt;支持的其他关键字。</target>
        </trans-unit>
        <trans-unit id="838c6416400ccef4da44e58e719db49e883edf34" translate="yes" xml:space="preserve">
          <source>If you want to identify and remove duplicate rows in a DataFrame, there are two methods that will help: &lt;code&gt;duplicated&lt;/code&gt; and &lt;code&gt;drop_duplicates&lt;/code&gt;. Each takes as an argument the columns to use to identify duplicated rows.</source>
          <target state="translated">如果你想确定，并在数据帧删除重复的行，有两种方法，这将有助于： &lt;code&gt;duplicated&lt;/code&gt; 和 &lt;code&gt;drop_duplicates&lt;/code&gt; 。每个参数都以用于标识重复行的列作为参数。</target>
        </trans-unit>
        <trans-unit id="a59364a4030877526c3fb43a1076dbe047f4ce00" translate="yes" xml:space="preserve">
          <source>If you want to include &lt;strong&gt;all&lt;/strong&gt; of data categories even if the actual data does not contain any instances of a particular category, you should set &lt;code&gt;dropna=False&lt;/code&gt;.</source>
          <target state="translated">如果您希望包括&lt;strong&gt;所有&lt;/strong&gt;数据类别，即使实际数据不包含特定类别的任何实例，则应设置 &lt;code&gt;dropna=False&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ba39bcec7f6db4e1b09827720ef4bb35fbb65050" translate="yes" xml:space="preserve">
          <source>If you want to inspect the stored object, retrieve via &lt;code&gt;get_storer&lt;/code&gt;. You could use this programmatically to say get the number of rows in an object.</source>
          <target state="translated">如果要检查存储的对象，请通过 &lt;code&gt;get_storer&lt;/code&gt; 进行检索。您可以以编程方式使用它来表示获取对象中的行数。</target>
        </trans-unit>
        <trans-unit id="8c0960af5a9c3a1fb441fc7e6e682d503ea6726c" translate="yes" xml:space="preserve">
          <source>If you want to manage your own connections you can pass one of those instead:</source>
          <target state="translated">如果你想管理自己的连接,你可以通过其中的一个来代替。</target>
        </trans-unit>
        <trans-unit id="95a5a881302f9b77f030472899c0c61a452bf781" translate="yes" xml:space="preserve">
          <source>If you want to omit a dataframe&amp;rsquo;s indexes when writing, pass &lt;code&gt;index=False&lt;/code&gt; to &lt;a href=&quot;../reference/api/pandas.dataframe.to_parquet#pandas.DataFrame.to_parquet&quot;&gt;&lt;code&gt;to_parquet()&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">如果要在写入时忽略数据&lt;a href=&quot;../reference/api/pandas.dataframe.to_parquet#pandas.DataFrame.to_parquet&quot;&gt; &lt;code&gt;to_parquet()&lt;/code&gt; &lt;/a&gt; &lt;code&gt;index=False&lt;/code&gt; ，请将index = False传递给to_parquet（）：</target>
        </trans-unit>
        <trans-unit id="f39c7a5a2ebd376e45bc4789c9e32d770747fa47" translate="yes" xml:space="preserve">
          <source>If you want to only run a specific group of tests from a file, you can do it using &lt;code&gt;.&lt;/code&gt; as a separator. For example:</source>
          <target state="translated">如果您只想从文件中运行一组特定的测试，则可以使用进行测试 &lt;code&gt;.&lt;/code&gt; 作为分隔符。例如：</target>
        </trans-unit>
        <trans-unit id="431c2f4b44553a66b404402f29529cfcdabf6d56" translate="yes" xml:space="preserve">
          <source>If you want to pass in a path object, pandas accepts any &lt;code&gt;os.PathLike&lt;/code&gt;.</source>
          <target state="translated">如果要传递路径对象，pandas可以接受任何 &lt;code&gt;os.PathLike&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="260a6b638018f13e44320b83a5f3393470170f1f" translate="yes" xml:space="preserve">
          <source>If you want to select the nth not-null item, use the &lt;code&gt;dropna&lt;/code&gt; kwarg. For a DataFrame this should be either &lt;code&gt;'any'&lt;/code&gt; or &lt;code&gt;'all'&lt;/code&gt; just like you would pass to dropna:</source>
          <target state="translated">如果要选择第n个非空项目，请使用 &lt;code&gt;dropna&lt;/code&gt; kwarg。对于DataFrame，它应该是 &lt;code&gt;'any'&lt;/code&gt; 或 &lt;code&gt;'all'&lt;/code&gt; ，就像您传递给dropna一样：</target>
        </trans-unit>
        <trans-unit id="8e69cf53c2f90f63fca612ceaf55108d6a7645de" translate="yes" xml:space="preserve">
          <source>If you want to show a case where an exception is raised, you can do:</source>
          <target state="translated">如果你想展示一个引发异常的案例,你可以这样做。</target>
        </trans-unit>
        <trans-unit id="3444f60978a55340c6fd4266fe2afeb502624670" translate="yes" xml:space="preserve">
          <source>If you want to show that &lt;code&gt;s.plot()&lt;/code&gt; returns a matplotlib AxesSubplot object, this will fail the doctest</source>
          <target state="translated">如果要显示 &lt;code&gt;s.plot()&lt;/code&gt; 返回一个matplotlib AxesSubplot对象，这将使doctest失败</target>
        </trans-unit>
        <trans-unit id="8341aec896361ab00c05ae9a1482550fce8e4f42" translate="yes" xml:space="preserve">
          <source>If you wish to get the 0th and the 2nd elements from the index in the &amp;lsquo;A&amp;rsquo; column, you can do:</source>
          <target state="translated">如果您希望从&amp;ldquo; A&amp;rdquo;列的索引中获取第0和第2个元素，则可以执行以下操作：</target>
        </trans-unit>
        <trans-unit id="79b6a034b92c3c225415a2cbf07b02e0810a9cdc" translate="yes" xml:space="preserve">
          <source>If you wish to keep all original rows and columns, set &lt;code&gt;keep_shape&lt;/code&gt; argument to &lt;code&gt;True&lt;/code&gt;.</source>
          <target state="translated">如果希望保留所有原始行和列，请将 &lt;code&gt;keep_shape&lt;/code&gt; 参数设置为 &lt;code&gt;True&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a6fca580ca146fe1287a019a063eff316214cd98" translate="yes" xml:space="preserve">
          <source>If you wish to specify other levels (as will occasionally be the case), you can do so using the &lt;code&gt;levels&lt;/code&gt; argument:</source>
          <target state="translated">如果您希望指定其他级别（有时会这样），则可以使用 &lt;code&gt;levels&lt;/code&gt; 参数来指定：</target>
        </trans-unit>
        <trans-unit id="5357656a53a0ea6cda290cc82e0cca1c51833255" translate="yes" xml:space="preserve">
          <source>If you wish to write to more than one sheet in the workbook, it is necessary to specify an ExcelWriter object:</source>
          <target state="translated">如果希望向工作簿中的多个工作表写入数据,则需要指定一个ExcelWriter对象。</target>
        </trans-unit>
        <trans-unit id="c0ac4887afa33726cb4047a790d5d629409d0a01" translate="yes" xml:space="preserve">
          <source>If you wish, you may choose to stack the differences on rows.</source>
          <target state="translated">如果你愿意,你可以选择在行上叠加差异。</target>
        </trans-unit>
        <trans-unit id="55c38761c27fc078a6f71bc308a6215ee7bb40a4" translate="yes" xml:space="preserve">
          <source>If you would like pandas to be more or less trusting about assignment to a chained indexing expression, you can set the &lt;a href=&quot;options#options&quot;&gt;option&lt;/a&gt;&lt;code&gt;mode.chained_assignment&lt;/code&gt; to one of these values:</source>
          <target state="translated">如果您希望熊猫在 &lt;code&gt;mode.chained_assignment&lt;/code&gt; 信任链式索引表达式的分配，可以将&lt;a href=&quot;options#options&quot;&gt;选项&lt;/a&gt;mode.chained_assignment设置为以下值之一：</target>
        </trans-unit>
        <trans-unit id="1a6f96245d6df3c307f3f4bfc1f0124b3effe146" translate="yes" xml:space="preserve">
          <source>If you would prefer to keep the &lt;code&gt;NA&lt;/code&gt; values you can manually fill them with &lt;code&gt;fillna(True)&lt;/code&gt;.</source>
          <target state="translated">如果您希望保留 &lt;code&gt;NA&lt;/code&gt; 值，则可以使用 &lt;code&gt;fillna(True)&lt;/code&gt; 手动填充它们。</target>
        </trans-unit>
        <trans-unit id="603667115b7f0addd355740b600caf5f30806f25" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re building a library that implements the interface, please publicize it on &lt;a href=&quot;../ecosystem#ecosystem-extensions&quot;&gt;Extension data types&lt;/a&gt;.</source>
          <target state="translated">如果您要构建实现该接口的库，请在&lt;a href=&quot;../ecosystem#ecosystem-extensions&quot;&gt;扩展数据类型&lt;/a&gt;上对其进行宣传。</target>
        </trans-unit>
        <trans-unit id="a6c8245d9d9f1878751eb8d7ab972407703ff1cf" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re having trouble pasting the above into your ipython, you may need to be using bleeding edge IPython for paste to play well with cell magics.</source>
          <target state="translated">如果您在将上述内容粘贴到ipython时遇到麻烦，则可能需要使用出血边缘IPython进行粘贴才能很好地发挥细胞魔力。</target>
        </trans-unit>
        <trans-unit id="ab47c63b2d6927d1db8e796a8720b53461c8e93d" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re having trouble pasting the above into your ipython, you may need to be using bleeding edge ipython for paste to play well with cell magics.</source>
          <target state="translated">如果您在将上述内容粘贴到ipython时遇到麻烦，则可能需要使用出血边缘ipython进行粘贴才能很好地与细胞魔术配合使用。</target>
        </trans-unit>
        <trans-unit id="8179681b12d1079bcde2bda507f3523470acc9a8" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re interested in contributing, please visit the &lt;a href=&quot;../development/contributing#contributing&quot;&gt;contributing guide&lt;/a&gt;.</source>
          <target state="translated">如果您有兴趣贡献，请访问&lt;a href=&quot;../development/contributing#contributing&quot;&gt;贡献指南&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="954e9c7dcd852245711eafdd97aac0e41254af2a" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re new to pandas, you might want to first read through &lt;a href=&quot;../10min#min&quot;&gt;10 Minutes to pandas&lt;/a&gt; to familiarize yourself with the library.</source>
          <target state="translated">如果您是熊猫的新手，则可能需要先阅读&lt;a href=&quot;../10min#min&quot;&gt;10分钟&lt;/a&gt;以了解熊猫，以熟悉图书馆。</target>
        </trans-unit>
        <trans-unit id="cf4479cf67c908330f3502d0976c6b8c094f6f72" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re using IPython, tab completion for column names (as well as public attributes) is automatically enabled. Here&amp;rsquo;s a subset of the attributes that will be completed:</source>
          <target state="translated">如果您使用的是IPython，则会自动启用列名（以及公共属性）的制表符完成功能。这是将要完成的属性的子集：</target>
        </trans-unit>
        <trans-unit id="20447cc89f3341970de8f262a8187e6f8b87da3f" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re using Python &amp;lt; 3.6 or pandas &amp;lt; 0.23, and an index is not passed, the &lt;code&gt;Series&lt;/code&gt; index will be the lexically ordered list of dict keys.</source>
          <target state="translated">如果您使用的Python &amp;lt;3.6或pandas &amp;lt;0.23，并且未传递索引，则 &lt;code&gt;Series&lt;/code&gt; 索引将按字典顺序按字典顺序排列。</target>
        </trans-unit>
        <trans-unit id="ea10e2f23c35ab01a19875e0da269fdf0c5585fe" translate="yes" xml:space="preserve">
          <source>If your change involves checking that a warning is actually emitted, use &lt;code&gt;tm.assert_produces_warning(ExpectedWarning)&lt;/code&gt;.</source>
          <target state="translated">如果更改涉及检查是否确实发出警告，请使用 &lt;code&gt;tm.assert_produces_warning(ExpectedWarning)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="55c057d9cb3f679f9d738d6ec8fbd7a104357a59" translate="yes" xml:space="preserve">
          <source>If your code is an enhancement, it is most likely necessary to add usage examples to the existing documentation. This can be done following the section regarding documentation &lt;a href=&quot;#contributing-documentation&quot;&gt;above&lt;/a&gt;. Further, to let users know when this feature was added, the &lt;code&gt;versionadded&lt;/code&gt; directive is used. The sphinx syntax for that is:</source>
          <target state="translated">如果您的代码是增强功能，则很可能有必要在现有文档中添加用法示例。可以按照&lt;a href=&quot;#contributing-documentation&quot;&gt;上面&lt;/a&gt;有关文档的部分进行操作。此外，为了让用户知道何时添加此功能，使用了 &lt;code&gt;versionadded&lt;/code&gt; 添加指令。狮身人面像的语法是：</target>
        </trans-unit>
        <trans-unit id="17297cf285c7c41a2305959b1d4993f6c38dfb8b" translate="yes" xml:space="preserve">
          <source>If your data does not follow this convention, please use the normal constructor.</source>
          <target state="translated">如果你的数据没有遵循这个约定,请使用普通的构造函数。</target>
        </trans-unit>
        <trans-unit id="24ad4ea1217ea5f3ca6628c5a502cceebb4edfb0" translate="yes" xml:space="preserve">
          <source>If your desired output column names are not valid Python keywords, construct a dictionary and unpack the keyword arguments</source>
          <target state="translated">如果所需的输出列名不是有效的Python关键字,构造一个字典并解包关键字参数</target>
        </trans-unit>
        <trans-unit id="98cbab20b6fb2abfa92fdc4fc1f66575059d0c3b" translate="yes" xml:space="preserve">
          <source>If your style function uses a &lt;code&gt;subset&lt;/code&gt; or &lt;code&gt;axis&lt;/code&gt; keyword argument, consider wrapping your function in a &lt;code&gt;functools.partial&lt;/code&gt;, partialing out that keyword.</source>
          <target state="translated">如果您的样式函数使用 &lt;code&gt;subset&lt;/code&gt; 或 &lt;code&gt;axis&lt;/code&gt; 关键字参数，请考虑将函数包装在 &lt;code&gt;functools.partial&lt;/code&gt; 中，以分隔该关键字。</target>
        </trans-unit>
        <trans-unit id="0577eb9b0205a991abdc93cdc5c980e96a949c1e" translate="yes" xml:space="preserve">
          <source>If/then logic</source>
          <target state="translated">If/then逻辑</target>
        </trans-unit>
        <trans-unit id="537a32d1d7729f25747f50cd67c683b5fa307d78" translate="yes" xml:space="preserve">
          <source>Ignore NaN values when inferring the type.</source>
          <target state="translated">推断类型时忽略NaN值。</target>
        </trans-unit>
        <trans-unit id="0a84d018aa4bed7f09ba656bc9b54ababd117230" translate="yes" xml:space="preserve">
          <source>Ignore differing dtypes in columns with check_dtype.</source>
          <target state="translated">忽略列中带有check_dtype的不同dtypes。</target>
        </trans-unit>
        <trans-unit id="ad9ed1e274f3db919ec0acff031892fd9c7b7466" translate="yes" xml:space="preserve">
          <source>Ignore missing values when calculating weights; specify &lt;code&gt;True&lt;/code&gt; to reproduce pre-0.15.0 behavior.</source>
          <target state="translated">计算权重时忽略缺失值；指定 &lt;code&gt;True&lt;/code&gt; 可重现0.15.0之前的行为。</target>
        </trans-unit>
        <trans-unit id="2705a7c2d2d0fbc6c769f7fda4a47ca8dc459762" translate="yes" xml:space="preserve">
          <source>Ignore missing values when calculating weights; specify True to reproduce pre-0.15.0 behavior.</source>
          <target state="translated">计算权重时忽略缺失值;指定True以重现0.15.0之前的行为。</target>
        </trans-unit>
        <trans-unit id="c0ff52c3b715a732da704fc6f3adeec3e1261b21" translate="yes" xml:space="preserve">
          <source>Ignoring case sensitivity using</source>
          <target state="translated">忽略大小写敏感性,使用</target>
        </trans-unit>
        <trans-unit id="9ea19abc80c5f9b9a3d69ac6d138608e64b4eae7" translate="yes" xml:space="preserve">
          <source>Ignoring case sensitivity using &lt;code&gt;flags&lt;/code&gt; with regex.</source>
          <target state="translated">使用带有正则表达式的 &lt;code&gt;flags&lt;/code&gt; 忽略大小写。</target>
        </trans-unit>
        <trans-unit id="15a016f34e155f11682e304c096f6e7fed15242d" translate="yes" xml:space="preserve">
          <source>Ignoring indexes on the concatenation axis</source>
          <target state="translated">忽略连接轴上的索引。</target>
        </trans-unit>
        <trans-unit id="9ffd813cd81894c96ceecf900ec3ac39d754ec33" translate="yes" xml:space="preserve">
          <source>Ignoring line comments and empty lines</source>
          <target state="translated">忽略行注释和空行</target>
        </trans-unit>
        <trans-unit id="c48163e8e369cc932393aa060be7a71ab51f15db" translate="yes" xml:space="preserve">
          <source>Immutable Index for period data.</source>
          <target state="translated">期数据的不可更改指数。</target>
        </trans-unit>
        <trans-unit id="fa675f0928ac3d188978d143601cfaef0581eebe" translate="yes" xml:space="preserve">
          <source>Immutable Index implementing a monotonic integer range.</source>
          <target state="translated">实现单调整数范围的不可变指数。</target>
        </trans-unit>
        <trans-unit id="77bb5b08e773dcc647c2137be13943f11993af3a" translate="yes" xml:space="preserve">
          <source>Immutable Index implementing an ordered, sliceable set.</source>
          <target state="translated">不可变索引实现一个有序的、可分片的集合。</target>
        </trans-unit>
        <trans-unit id="09666a0d15aa17eade5da13deaf4058fff5e91c0" translate="yes" xml:space="preserve">
          <source>Immutable index of intervals that are closed on the same side.</source>
          <target state="translated">不变指数的区间,在同一侧封闭。</target>
        </trans-unit>
        <trans-unit id="322432105222ac065c39c51c46ac7e62258f855b" translate="yes" xml:space="preserve">
          <source>Immutable ndarray holding ordinal values indicating regular periods in time such as particular years, quarters, months, etc.</source>
          <target state="translated">不可变的ndarray,包含有规律的年、季、月等时间段的序值。</target>
        </trans-unit>
        <trans-unit id="337daa08831acb19d7ba65d5abaa56b4ada8d9e9" translate="yes" xml:space="preserve">
          <source>Immutable ndarray holding ordinal values indicating regular periods in time.</source>
          <target state="translated">不可变的ndarray,存放表示时间段规律的序值。</target>
        </trans-unit>
        <trans-unit id="95ddec45685f37191edce0f9c049167f337a12e2" translate="yes" xml:space="preserve">
          <source>Immutable ndarray holding ordinal values.</source>
          <target state="translated">不可变的ndarray,可容纳序数值。</target>
        </trans-unit>
        <trans-unit id="ff5fce9b61c2b7d306def659869f8a2d0e740987" translate="yes" xml:space="preserve">
          <source>Immutable ndarray implementing an ordered, sliceable set.</source>
          <target state="translated">不可变的ndarray实现了一个有序的、可分片的集合。</target>
        </trans-unit>
        <trans-unit id="632aea5fb4e51ab537ce029dad7185968ea1903b" translate="yes" xml:space="preserve">
          <source>Immutable ndarray implementing an ordered, sliceable set. The basic object storing axis labels for all pandas objects.</source>
          <target state="translated">不可变的ndarray,实现一个有序的、可分片的集合。存储所有pandas对象的轴标签的基本对象。</target>
        </trans-unit>
        <trans-unit id="a1d7735d372421181df84b4198539d11f0bd5288" translate="yes" xml:space="preserve">
          <source>Immutable ndarray implementing an ordered, sliceable set. The basic object storing axis labels for all pandas objects. Float64Index is a special case of &lt;code&gt;Index&lt;/code&gt; with purely float labels.</source>
          <target state="translated">实现一个有序，可切片集合的不可变ndarray。用于存储所有熊猫对象的轴对象的基本对象。Float64Index是带有纯浮点标签的 &lt;code&gt;Index&lt;/code&gt; 的特殊情况。</target>
        </trans-unit>
        <trans-unit id="a63505fab2255dbaad9e67cc969dee30b7999644" translate="yes" xml:space="preserve">
          <source>Immutable ndarray implementing an ordered, sliceable set. The basic object storing axis labels for all pandas objects. Int64Index is a special case of &lt;code&gt;Index&lt;/code&gt; with purely integer labels.</source>
          <target state="translated">实现一个有序，可切片集合的不可变ndarray。存储所有熊猫对象的轴对象的基本对象。Int64Index是带有纯整数标签的 &lt;code&gt;Index&lt;/code&gt; 的特殊情况。</target>
        </trans-unit>
        <trans-unit id="e2a7d783a146ccf2aebd945545d5c4801e5a2997" translate="yes" xml:space="preserve">
          <source>Immutable ndarray implementing an ordered, sliceable set. The basic object storing axis labels for all pandas objects. UInt64Index is a special case of &lt;code&gt;Index&lt;/code&gt; with purely unsigned integer labels.</source>
          <target state="translated">实现一个有序，可切片集合的不可变ndarray。用于存储所有熊猫对象的轴对象的基本对象。UInt64Index是带有纯无符号整数标签的 &lt;code&gt;Index&lt;/code&gt; 的特殊情况。</target>
        </trans-unit>
        <trans-unit id="3f9f35d14ce44451d11a45398cd4e7e33b22d52e" translate="yes" xml:space="preserve">
          <source>Immutable ndarray of datetime64 data, represented internally as int64, and which can be boxed to Timestamp objects that are subclasses of datetime and carry metadata such as frequency information.</source>
          <target state="translated">不可变的ndarray的datetime64数据,内部表示为int64,可以将其框定为Timestamp对象,Timestamp对象是datetime的子类,携带频率信息等元数据。</target>
        </trans-unit>
        <trans-unit id="a0c7ddd23ba079b38767357bd06b67a58ed2ef16" translate="yes" xml:space="preserve">
          <source>Immutable ndarray of timedelta64 data, represented internally as int64, and which can be boxed to timedelta objects</source>
          <target state="translated">不可变的时间德尔塔64数据的ndarray,内部表示为int64,它可以被装箱为时间德尔塔对象。</target>
        </trans-unit>
        <trans-unit id="5398d1add4bca5f5b7f2b03337b3d627dd293318" translate="yes" xml:space="preserve">
          <source>Immutable ndarray of timedelta64 data, represented internally as int64, and which can be boxed to timedelta objects.</source>
          <target state="translated">不可变的timedelta64数据ndarray,内部表示为int64,可以将其框定为timedelta对象。</target>
        </trans-unit>
        <trans-unit id="d546a7e1c870efa75e1e47b90e1203b5c50b7ac2" translate="yes" xml:space="preserve">
          <source>Immutable ndarray-like of datetime64 data.</source>
          <target state="translated">不可变的类似ndarray的datetime64数据。</target>
        </trans-unit>
        <trans-unit id="5d4d9fb600d19bd44b1d23393cd235ddaf172e07" translate="yes" xml:space="preserve">
          <source>Immutable object implementing an Interval, a bounded slice-like interval.</source>
          <target state="translated">不可变的对象,实现一个Interval,一个有界的类似切片的区间。</target>
        </trans-unit>
        <trans-unit id="505bb48d000edeee874dc5be5afd4732ecdf5ebd" translate="yes" xml:space="preserve">
          <source>Immutable sequence used for indexing and alignment.</source>
          <target state="translated">用于索引和对齐的不可改变的序列。</target>
        </trans-unit>
        <trans-unit id="127cfce9c5b60f47493c14c12a2d15589ccdb84e" translate="yes" xml:space="preserve">
          <source>Immutable sequence used for indexing and alignment. The basic object storing axis labels for all pandas objects.</source>
          <target state="translated">用于索引和对齐的不可改变的序列。存储所有pandas对象的轴标签的基本对象。</target>
        </trans-unit>
        <trans-unit id="0f38f448ebc934c19cecd4c61d947b66ce618345" translate="yes" xml:space="preserve">
          <source>Immutable sequence used for indexing and alignment. The basic object storing axis labels for all pandas objects. Float64Index is a special case of</source>
          <target state="translated">用于索引和对齐的不可改变的序列。存储所有 pandas 对象的轴标签的基本对象。Float64Index 是一个特殊的例子,它是</target>
        </trans-unit>
        <trans-unit id="0b9732e001aecfcbbba7d1d2226b813ee863d077" translate="yes" xml:space="preserve">
          <source>Immutable sequence used for indexing and alignment. The basic object storing axis labels for all pandas objects. Int64Index is a special case of</source>
          <target state="translated">用于索引和对齐的不可改变的序列。存储所有pandas对象的轴标签的基本对象。Int64Index 是</target>
        </trans-unit>
        <trans-unit id="a8d0cee96f82a003d95761bdb1bea6e5c8b8bb2c" translate="yes" xml:space="preserve">
          <source>Immutable sequence used for indexing and alignment. The basic object storing axis labels for all pandas objects. UInt64Index is a special case of</source>
          <target state="translated">用于索引和对齐的不可改变的序列。为所有pandas对象存储轴标签的基本对象。UInt64Index 是 UInt64Index 的一个特例。</target>
        </trans-unit>
        <trans-unit id="31b7603ab9e328ac9ecd3a57b22b14f6ba634622" translate="yes" xml:space="preserve">
          <source>Implement the sparse version of the DataFrame meaning that any data matching a specific value it&amp;rsquo;s omitted in the representation. The sparse DataFrame allows for a more efficient storage.</source>
          <target state="translated">实现DataFrame的稀疏版本，这意味着任何与特定值匹配的数据都将在表示中省略。稀疏的DataFrame可以提高存储效率。</target>
        </trans-unit>
        <trans-unit id="10a2799ea91e51525dea53960078f9f6f3203aa1" translate="yes" xml:space="preserve">
          <source>Implements datetime.replace, handles nanoseconds.</source>
          <target state="translated">实现datetime.replace,处理纳秒。</target>
        </trans-unit>
        <trans-unit id="c6745b96941850a92b0edba7a6c22b838293d405" translate="yes" xml:space="preserve">
          <source>Import Stata data files.</source>
          <target state="translated">导入的数据文件。</target>
        </trans-unit>
        <trans-unit id="1e5491997dd74b680ce524f97d0882e687569640" translate="yes" xml:space="preserve">
          <source>Import all needed libraries (except for pandas and numpy, those are already imported as &lt;code&gt;import pandas as pd&lt;/code&gt; and &lt;code&gt;import numpy as np&lt;/code&gt;) and define all variables you use in the example.</source>
          <target state="translated">导入所有需要的库（除了pandas和numpy，它们已经作为 &lt;code&gt;import pandas as pd&lt;/code&gt; 和 &lt;code&gt;import numpy as np&lt;/code&gt; ），并定义了示例中使用的所有变量。</target>
        </trans-unit>
        <trans-unit id="d23dd8370347a27e8c15358e5d3021400237aac7" translate="yes" xml:space="preserve">
          <source>Import formatting</source>
          <target state="translated">导入格式化</target>
        </trans-unit>
        <trans-unit id="72cab777e486bd355797f7e6fdade33e9f41fd52" translate="yes" xml:space="preserve">
          <source>Import required libraries (except &lt;code&gt;numpy&lt;/code&gt; and &lt;code&gt;pandas&lt;/code&gt;)</source>
          <target state="translated">导入所需的库（ &lt;code&gt;numpy&lt;/code&gt; 和 &lt;code&gt;pandas&lt;/code&gt; 除外）</target>
        </trans-unit>
        <trans-unit id="4b6d6a30150a506f9b79caf45da5aecb76b0018e" translate="yes" xml:space="preserve">
          <source>Important</source>
          <target state="translated">Important</target>
        </trans-unit>
        <trans-unit id="8e9f5299061cd70fa083abaf2a821d53b2bf0a35" translate="yes" xml:space="preserve">
          <source>Important to notice that &lt;code&gt;df2&lt;/code&gt; will contain both</source>
          <target state="translated">重要的是要注意 &lt;code&gt;df2&lt;/code&gt; 将同时包含</target>
        </trans-unit>
        <trans-unit id="8caa460d7e776f14562e9da5c4c08d479a40d0c1" translate="yes" xml:space="preserve">
          <source>Important to notice that &lt;code&gt;df2&lt;/code&gt; will contain both &lt;code&gt;str&lt;/code&gt; and &lt;code&gt;int&lt;/code&gt; for the same input, &amp;lsquo;1&amp;rsquo;.</source>
          <target state="translated">重要的是要注意，对于相同的输入&amp;ldquo; 1&amp;rdquo; ， &lt;code&gt;df2&lt;/code&gt; 将同时包含 &lt;code&gt;str&lt;/code&gt; 和 &lt;code&gt;int&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5f3ec8323e548daf8dafc731adcf0f495f9f93cb" translate="yes" xml:space="preserve">
          <source>Importantly, a list of tuples indexes several complete &lt;code&gt;MultiIndex&lt;/code&gt; keys, whereas a tuple of lists refer to several values within a level:</source>
          <target state="translated">重要的是，一个元组列表索引了几个完整的 &lt;code&gt;MultiIndex&lt;/code&gt; 键，而一个列表元组则引用了一个级别中的多个值：</target>
        </trans-unit>
        <trans-unit id="e4595506130e2cf8db40b1b6430ef7e36fa5cf73" translate="yes" xml:space="preserve">
          <source>Imports are alphabetically sorted within these sections.</source>
          <target state="translated">进口产品在这些部分中按字母顺序排列。</target>
        </trans-unit>
        <trans-unit id="8982a4b2f79ddf31cda90fa02617abd56244f09b" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;missing_data#missing-data&quot;&gt;Working with missing data&lt;/a&gt;, we saw that pandas primarily uses &lt;code&gt;NaN&lt;/code&gt; to represent missing data. Because &lt;code&gt;NaN&lt;/code&gt; is a float, this forces an array of integers with any missing values to become floating point. In some cases, this may not matter much. But if your integer column is, say, an identifier, casting to float can be problematic. Some integers cannot even be represented as floating point numbers.</source>
          <target state="translated">在&lt;a href=&quot;missing_data#missing-data&quot;&gt;使用缺失数据中&lt;/a&gt;，我们看到了熊猫主要使用 &lt;code&gt;NaN&lt;/code&gt; 来表示缺失数据。由于 &lt;code&gt;NaN&lt;/code&gt; 是浮点数，因此这会强制将所有缺少值的整数数组变为浮点数。在某些情况下，这可能无关紧要。但是，如果您的整数列是一个标识符，则将其强制转换为float可能会出现问题。有些整数甚至不能表示为浮点数。</target>
        </trans-unit>
        <trans-unit id="555d2dfae47903c8bd58329d13a61da63add288b" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;and&lt;/code&gt;</source>
          <target state="translated">在 &lt;code&gt;and&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0e52f1bacd4f24deb022009e6cbcfc6777c66aa9" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;boxplot&lt;/code&gt;, the return type can be controlled by the &lt;code&gt;return_type&lt;/code&gt;, keyword. The valid choices are &lt;code&gt;{&quot;axes&quot;, &quot;dict&quot;, &quot;both&quot;, None}&lt;/code&gt;. Faceting, created by &lt;code&gt;DataFrame.boxplot&lt;/code&gt; with the &lt;code&gt;by&lt;/code&gt; keyword, will affect the output type as well:</source>
          <target state="translated">在 &lt;code&gt;boxplot&lt;/code&gt; 中，返回类型可以由 &lt;code&gt;return_type&lt;/code&gt; 关键字控制。有效选择为 &lt;code&gt;{&quot;axes&quot;, &quot;dict&quot;, &quot;both&quot;, None}&lt;/code&gt; 。由 &lt;code&gt;DataFrame.boxplot&lt;/code&gt; 使用 &lt;code&gt;by&lt;/code&gt; 关键字创建的构面也会影响输出类型：</target>
        </trans-unit>
        <trans-unit id="0a852e68eeb631ade0cef03cf874abce1f81c9e7" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;or&lt;/code&gt;</source>
          <target state="translated">在 &lt;code&gt;or&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="097ba133ee7ab96717f7a5a56ab8a4beb1aa23eb" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;pytz&lt;/code&gt; you can find a list of common (and less common) time zones using &lt;code&gt;from pytz import common_timezones, all_timezones&lt;/code&gt;.</source>
          <target state="translated">在 &lt;code&gt;pytz&lt;/code&gt; 中,您可以使用 &lt;code&gt;from pytz import common_timezones, all_timezones&lt;/code&gt; 中的常见（和较不常见）时区列表。</target>
        </trans-unit>
        <trans-unit id="dbe401f5c64aba5b5ac112f3a745ea229c800ebf" translate="yes" xml:space="preserve">
          <source>In Python 2 replacing the &lt;code&gt;range&lt;/code&gt; with its generator counterpart (&lt;code&gt;xrange&lt;/code&gt;) would mean the &lt;code&gt;range&lt;/code&gt; line would vanish. In Python 3 &lt;code&gt;range&lt;/code&gt; is already a generator.</source>
          <target state="translated">在Python 2中，将 &lt;code&gt;range&lt;/code&gt; 替换为其生成器副本（ &lt;code&gt;xrange&lt;/code&gt; ）意味着 &lt;code&gt;range&lt;/code&gt; 线将消失。在Python 3中， &lt;code&gt;range&lt;/code&gt; 已经是一个生成器。</target>
        </trans-unit>
        <trans-unit id="da0a8b268dc3a515b0c25d7910a12354f6dbce4d" translate="yes" xml:space="preserve">
          <source>In Python 3.6+, you can create multiple columns within the same assign where one of the columns depends on another one defined within the same assign:</source>
          <target state="translated">在Python 3.6+中,你可以在同一个赋值中创建多个列,其中一个列依赖于同一个赋值中定义的另一个列。</target>
        </trans-unit>
        <trans-unit id="907e8abd6c8723d202c63be6f377cf83483ea444" translate="yes" xml:space="preserve">
          <source>In R this file can be read into a &lt;code&gt;data.frame&lt;/code&gt; object using the &lt;code&gt;rhdf5&lt;/code&gt; library. The following example function reads the corresponding column names and data values from the values and assembles them into a &lt;code&gt;data.frame&lt;/code&gt;:</source>
          <target state="translated">在R中，可以使用 &lt;code&gt;rhdf5&lt;/code&gt; 库将该文件读入 &lt;code&gt;data.frame&lt;/code&gt; 对象。以下示例函数从值中读取相应的列名和数据值，并将它们组合成 &lt;code&gt;data.frame&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="01750648f39249d22ad4fc3c3a3a8334f0b9fee0" translate="yes" xml:space="preserve">
          <source>In SAS, if/then logic can be used to create new columns.</source>
          <target state="translated">在SAS中,if/then逻辑可以用来创建新列。</target>
        </trans-unit>
        <trans-unit id="ca39c6fc3d7d80268fd46f392c1dc4b249e34950" translate="yes" xml:space="preserve">
          <source>In SQL, selection is done using a comma-separated list of columns you&amp;rsquo;d like to select (or a &lt;code&gt;*&lt;/code&gt; to select all columns):</source>
          <target state="translated">在SQL中，选择是使用您要选择的列的逗号分隔列表（或使用 &lt;code&gt;*&lt;/code&gt; 来选择所有列）来完成的：</target>
        </trans-unit>
        <trans-unit id="877c9547b65141215299da5fbdfe17f3178aa51f" translate="yes" xml:space="preserve">
          <source>In Series and DataFrame, the arithmetic functions have the option of inputting a &lt;em&gt;fill_value&lt;/em&gt;, namely a value to substitute when at most one of the values at a location are missing. For example, when adding two DataFrame objects, you may wish to treat NaN as 0 unless both DataFrames are missing that value, in which case the result will be NaN (you can later replace NaN with some other value using &lt;code&gt;fillna&lt;/code&gt; if you wish).</source>
          <target state="translated">在Series和DataFrame中，算术函数可以选择输入&lt;em&gt;fill_value&lt;/em&gt;，即在某个位置最多缺少一个值时要替换的值。例如，当添加两个DataFrame对象时，除非两个DataFrame都缺少该值，否则您可能希望将NaN视为0，在这种情况下，结果将是NaN（如果需要，您可以稍后使用 &lt;code&gt;fillna&lt;/code&gt; 将NaN替换为其他值）。</target>
        </trans-unit>
        <trans-unit id="dc2683c2af6d69c783f5e1c2c60c2fb95add6385" translate="yes" xml:space="preserve">
          <source>In Stata, an &lt;code&gt;if&lt;/code&gt; clause can also be used to create new columns.</source>
          <target state="translated">在Stata中， &lt;code&gt;if&lt;/code&gt; 子句也可用于创建新列。</target>
        </trans-unit>
        <trans-unit id="4fca911336b8e64fe53b3d338ac822c1038ec5cd" translate="yes" xml:space="preserve">
          <source>In Stata, arbitrary math expressions can be used with the &lt;code&gt;generate&lt;/code&gt; and &lt;code&gt;replace&lt;/code&gt; commands on new or existing columns. The &lt;code&gt;drop&lt;/code&gt; command drops the column from the data set.</source>
          <target state="translated">在Stata中，可以将任意数学表达式与新列或现有列上的 &lt;code&gt;generate&lt;/code&gt; 和 &lt;code&gt;replace&lt;/code&gt; 命令一起使用。所述 &lt;code&gt;drop&lt;/code&gt; 命令丢弃来自所述数据集的列。</target>
        </trans-unit>
        <trans-unit id="a485b7b38ddc54d065958b69c383566407ee3e76" translate="yes" xml:space="preserve">
          <source>In a &lt;code&gt;SparseDataFrame&lt;/code&gt;, &lt;em&gt;all&lt;/em&gt; columns were sparse. A &lt;a href=&quot;../reference/api/pandas.dataframe#pandas.DataFrame&quot;&gt;&lt;code&gt;DataFrame&lt;/code&gt;&lt;/a&gt; can have a mixture of sparse and dense columns. As a consequence, assigning new columns to a &lt;code&gt;DataFrame&lt;/code&gt; with sparse values will not automatically convert the input to be sparse.</source>
          <target state="translated">在 &lt;code&gt;SparseDataFrame&lt;/code&gt; 中，&lt;em&gt;所有&lt;/em&gt;列都是稀疏的。甲&lt;a href=&quot;../reference/api/pandas.dataframe#pandas.DataFrame&quot;&gt; &lt;code&gt;DataFrame&lt;/code&gt; &lt;/a&gt;可以具有稀疏和密集列的混合物。因此，将新列分配给具有稀疏值的 &lt;code&gt;DataFrame&lt;/code&gt; 不会自动将输入转换为稀疏。</target>
        </trans-unit>
        <trans-unit id="25885b0cb342fdce61ba57e7af9bc59a044474ea" translate="yes" xml:space="preserve">
          <source>In a current or later Python session, you can retrieve stored objects:</source>
          <target state="translated">在当前或以后的 Python 会话中,您可以检索存储的对象。</target>
        </trans-unit>
        <trans-unit id="29c635720f72e69b069f2ad905af2503cd996e22" translate="yes" xml:space="preserve">
          <source>In a special case, quotes that make a pair around a backtick can confuse the parser. For example, &lt;code&gt;`it's` &amp;gt; `that's`&lt;/code&gt; will raise an error, as it forms a quoted string (&lt;code&gt;'s &amp;gt; `that'&lt;/code&gt;) with a backtick inside.</source>
          <target state="translated">在特殊情况下，引号引起反引号对可能会使解析器感到困惑。例如， &lt;code&gt;`it's` &amp;gt; `that's`&lt;/code&gt; 会引发错误，因为它形成一个带引号的字符串（ &lt;code&gt;'s &amp;gt; `that'&lt;/code&gt; ），内部带有反引号。</target>
        </trans-unit>
        <trans-unit id="c92016604a38d8c1c1b602e884aa0580151d6703" translate="yes" xml:space="preserve">
          <source>In addition to accepting an integer or offset as a &lt;code&gt;window&lt;/code&gt; argument, &lt;code&gt;rolling&lt;/code&gt; also accepts a &lt;code&gt;BaseIndexer&lt;/code&gt; subclass that allows a user to define a custom method for calculating window bounds. The &lt;code&gt;BaseIndexer&lt;/code&gt; subclass will need to define a &lt;code&gt;get_window_bounds&lt;/code&gt; method that returns a tuple of two arrays, the first being the starting indices of the windows and second being the ending indices of the windows. Additionally, &lt;code&gt;num_values&lt;/code&gt;, &lt;code&gt;min_periods&lt;/code&gt;, &lt;code&gt;center&lt;/code&gt;, &lt;code&gt;closed&lt;/code&gt; and will automatically be passed to &lt;code&gt;get_window_bounds&lt;/code&gt; and the defined method must always accept these arguments.</source>
          <target state="translated">除了接受整数或偏移量作为 &lt;code&gt;window&lt;/code&gt; 参数外， &lt;code&gt;rolling&lt;/code&gt; 还接受 &lt;code&gt;BaseIndexer&lt;/code&gt; 子类，该子类允许用户定义用于计算窗口边界的自定义方法。该 &lt;code&gt;BaseIndexer&lt;/code&gt; 子类将需要定义一个 &lt;code&gt;get_window_bounds&lt;/code&gt; 方法，该方法返回两个阵列的元组，第一个是窗口的起始索引和第二个是窗口的结尾索引。另外， &lt;code&gt;num_values&lt;/code&gt; ， &lt;code&gt;min_periods&lt;/code&gt; ， &lt;code&gt;center&lt;/code&gt; ， &lt;code&gt;closed&lt;/code&gt; 会自动传递给 &lt;code&gt;get_window_bounds&lt;/code&gt; ，并且定义的方法必须始终接受这些参数。</target>
        </trans-unit>
        <trans-unit id="936eee8f2267eff6f3fed4ea5b56ef617d250c89" translate="yes" xml:space="preserve">
          <source>In addition to following the steps in this tutorial, users interested in enhancing performance are highly encouraged to install the &lt;a href=&quot;https://pandas.pydata.org/pandas-docs/version/1.2.0/getting_started/install.html#install-recommended-dependencies&quot;&gt;recommended dependencies&lt;/a&gt; for pandas. These dependencies are often not installed by default, but will offer speed improvements if present.</source>
          <target state="translated">除了按照本教程中的步骤进行操作外，强烈建议有兴趣提高性能的用户安装&lt;a href=&quot;https://pandas.pydata.org/pandas-docs/version/1.2.0/getting_started/install.html#install-recommended-dependencies&quot;&gt;建议&lt;/a&gt;的熊猫依赖项。默认情况下，通常不安装这些依赖项，但是如果存在的话，它们将提供速度上的改进。</target>
        </trans-unit>
        <trans-unit id="e63de287fe4a4658bb5a80280e4fa5c2bfd3ca20" translate="yes" xml:space="preserve">
          <source>In addition to object conversion, &lt;a href=&quot;../reference/api/pandas.to_numeric#pandas.to_numeric&quot;&gt;&lt;code&gt;to_numeric()&lt;/code&gt;&lt;/a&gt; provides another argument &lt;code&gt;downcast&lt;/code&gt;, which gives the option of downcasting the newly (or already) numeric data to a smaller dtype, which can conserve memory:</source>
          <target state="translated">除了对象转换外，&lt;a href=&quot;../reference/api/pandas.to_numeric#pandas.to_numeric&quot;&gt; &lt;code&gt;to_numeric()&lt;/code&gt; &lt;/a&gt;还提供了另一个参数 &lt;code&gt;downcast&lt;/code&gt; ，它提供了将新的（或已经）数字数据向下转换为较小的dtype的选项，该类型可以节省内存：</target>
        </trans-unit>
        <trans-unit id="88d11d83548d7a8bd3e2260ac358ac93abc83c24" translate="yes" xml:space="preserve">
          <source>In addition to text/csv and Stata files, pandas supports a variety of other data formats such as Excel, SAS, HDF5, Parquet, and SQL databases. These are all read via a &lt;code&gt;pd.read_*&lt;/code&gt; function. See the &lt;a href=&quot;../../user_guide/io#io&quot;&gt;IO documentation&lt;/a&gt; for more details.</source>
          <target state="translated">除了text / csv和Stata文件之外，pandas还支持多种其他数据格式，例如Excel，SAS，HDF5，Parquet和SQL数据库。这些都是通过 &lt;code&gt;pd.read_*&lt;/code&gt; 函数读取的。有关更多详细信息，请参见&lt;a href=&quot;../../user_guide/io#io&quot;&gt;IO文档&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4b35d4c53f87e1ec5baecbdbc6b0b27f79f9dad9" translate="yes" xml:space="preserve">
          <source>In addition to text/csv, pandas supports a variety of other data formats such as Excel, HDF5, and SQL databases. These are all read via a &lt;code&gt;pd.read_*&lt;/code&gt; function. See the &lt;a href=&quot;../../user_guide/io#io&quot;&gt;IO documentation&lt;/a&gt; for more details.</source>
          <target state="translated">除了text / csv外，pandas还支持其他多种数据格式，例如Excel，HDF5和SQL数据库。这些都是通过 &lt;code&gt;pd.read_*&lt;/code&gt; 函数读取的。有关更多详细信息，请参见&lt;a href=&quot;../../user_guide/io#io&quot;&gt;IO文档&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2fa15bcbd59eff23d62eafdefa1f3a939cba9e8d" translate="yes" xml:space="preserve">
          <source>In addition to that, &lt;code&gt;MultiIndex&lt;/code&gt; allows selecting a separate level to use in the membership check:</source>
          <target state="translated">除此之外， &lt;code&gt;MultiIndex&lt;/code&gt; 还允许选择一个单独的级别以用于成员资格检查：</target>
        </trans-unit>
        <trans-unit id="e488502fc61ee071297be900543941c302873763" translate="yes" xml:space="preserve">
          <source>In addition to the required datetime string, a &lt;code&gt;format&lt;/code&gt; argument can be passed to ensure specific parsing. This could also potentially speed up the conversion considerably.</source>
          <target state="translated">除了必需的日期时间字符串外，还可以传递 &lt;code&gt;format&lt;/code&gt; 参数以确保进行特定的解析。这也有可能极大地加快转换速度。</target>
        </trans-unit>
        <trans-unit id="0f194ff577d3246f42a365dc02ca65f2f46a8b57" translate="yes" xml:space="preserve">
          <source>In addition to the top level &lt;a href=&quot;../reference/api/pandas.eval#pandas.eval&quot;&gt;&lt;code&gt;pandas.eval()&lt;/code&gt;&lt;/a&gt; function you can also evaluate an expression in the &amp;ldquo;context&amp;rdquo; of a &lt;a href=&quot;../reference/api/pandas.dataframe#pandas.DataFrame&quot;&gt;&lt;code&gt;DataFrame&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">除了顶级的&lt;a href=&quot;../reference/api/pandas.eval#pandas.eval&quot;&gt; &lt;code&gt;pandas.eval()&lt;/code&gt; &lt;/a&gt;函数，您还可以在&lt;a href=&quot;../reference/api/pandas.dataframe#pandas.DataFrame&quot;&gt; &lt;code&gt;DataFrame&lt;/code&gt; &lt;/a&gt;的&amp;ldquo;上下文&amp;rdquo;中评估表达式。</target>
        </trans-unit>
        <trans-unit id="344220efeaea8bac8f88606648dc5f32ff74a82e" translate="yes" xml:space="preserve">
          <source>In addition to these &lt;code&gt;kind&lt;/code&gt; s, there are the &lt;a href=&quot;#visualization-hist&quot;&gt;DataFrame.hist()&lt;/a&gt;, and &lt;a href=&quot;#visualization-box&quot;&gt;DataFrame.boxplot()&lt;/a&gt; methods, which use a separate interface.</source>
          <target state="translated">除了这些 &lt;code&gt;kind&lt;/code&gt; 之外，还有&lt;a href=&quot;#visualization-hist&quot;&gt;DataFrame.hist（）&lt;/a&gt;和&lt;a href=&quot;#visualization-box&quot;&gt;DataFrame.boxplot（）&lt;/a&gt;方法，它们使用单​​独的接口。</target>
        </trans-unit>
        <trans-unit id="2ef7225efe8be70a38588aff72833171774ac432" translate="yes" xml:space="preserve">
          <source>In addition, &lt;code&gt;where&lt;/code&gt; takes an optional &lt;code&gt;other&lt;/code&gt; argument for replacement of values where the condition is False, in the returned copy.</source>
          <target state="translated">另外， &lt;code&gt;where&lt;/code&gt; 返回的副本中，where使用可选的 &lt;code&gt;other&lt;/code&gt; 参数替换条件为False的值。</target>
        </trans-unit>
        <trans-unit id="5d7ff888cd67986fa3c15b5083cd5f831adcd6a1" translate="yes" xml:space="preserve">
          <source>In addition, Unicode characters whose width is &amp;ldquo;Ambiguous&amp;rdquo; can either be 1 or 2 characters wide depending on the terminal setting or encoding. The option &lt;code&gt;display.unicode.ambiguous_as_wide&lt;/code&gt; can be used to handle the ambiguity.</source>
          <target state="translated">另外，根据终端设置或编码，宽度为&amp;ldquo;歧义&amp;rdquo;的Unicode字符宽度可以为1或2个字符。选项 &lt;code&gt;display.unicode.ambiguous_as_wide&lt;/code&gt; 可用于处理歧义。</target>
        </trans-unit>
        <trans-unit id="461cd1c60765166195c8d8ff831032d5cc889866" translate="yes" xml:space="preserve">
          <source>In addition, because a lot of people use our library, it is important that we do not make sudden changes to the code that could have the potential to break a lot of user code as a result, that is, we need it to be as &lt;em&gt;backwards compatible&lt;/em&gt; as possible to avoid mass breakages.</source>
          <target state="translated">另外，由于很多人都在使用我们的库，因此重要的是，不要对代码进行突然更改，以免破坏大量用户代码，也就是说，我们需要尽可能&lt;em&gt;向后兼容&lt;/em&gt;以避免质量破坏。</target>
        </trans-unit>
        <trans-unit id="6ec024bfe3b45af422e3ecb72973bb611c9bf681" translate="yes" xml:space="preserve">
          <source>In addition, downcasting will only occur if the size of the resulting data&amp;rsquo;s dtype is strictly larger than the dtype it is to be cast to, so if none of the dtypes checked satisfy that specification, no downcasting will be performed on the data.</source>
          <target state="translated">另外，仅当结果数据的dtype的大小严格大于要强制转换为dtype的dtype时，才会发生向下转换，因此，如果所检查的dtype均不满足该规范，则不会对该数据执行向下转换。</target>
        </trans-unit>
        <trans-unit id="5fc9b4cee9d4013aab9b23ecb620605ef783cea3" translate="yes" xml:space="preserve">
          <source>In addition, pandas also provides utilities to compare two Series or DataFrame and summarize their differences.</source>
          <target state="translated">此外,pandas还提供了比较两个Series或DataFrame并总结其差异的实用工具。</target>
        </trans-unit>
        <trans-unit id="28dd64e14727048112de8dad7d43482313ba396c" translate="yes" xml:space="preserve">
          <source>In addition, you can perform assignment of columns within an expression. This allows for &lt;em&gt;formulaic evaluation&lt;/em&gt;. The assignment target can be a new column name or an existing column name, and it must be a valid Python identifier.</source>
          <target state="translated">此外，您可以在表达式中执行列的分配。这可以进行&lt;em&gt;公式化评估&lt;/em&gt;。分配目标可以是新列名或现有列名，并且它必须是有效的Python标识符。</target>
        </trans-unit>
        <trans-unit id="cbe0930be96da940e74db577618b77c18b9ac4bd" translate="yes" xml:space="preserve">
          <source>In all, we&amp;rsquo;ve reduced the in-memory footprint of this dataset to 1/5 of its original size.</source>
          <target state="translated">总而言之，我们已将此数据集的内存占用空间减小到其原始大小的1/5。</target>
        </trans-unit>
        <trans-unit id="3f5ff527a5832e386d2fa919bb55a7946b3f099b" translate="yes" xml:space="preserve">
          <source>In any of these cases, standard indexing will still work, e.g. &lt;code&gt;s['1']&lt;/code&gt;, &lt;code&gt;s['min']&lt;/code&gt;, and &lt;code&gt;s['index']&lt;/code&gt; will access the corresponding element or column.</source>
          <target state="translated">在任何这些情况下，标准索引仍将起作用，例如 &lt;code&gt;s['1']&lt;/code&gt; ， &lt;code&gt;s['min']&lt;/code&gt; 和 &lt;code&gt;s['index']&lt;/code&gt; 将访问相应的元素或列。</target>
        </trans-unit>
        <trans-unit id="d37f34cfe50312c2a03cda42e1c85d47a9f3b53e" translate="yes" xml:space="preserve">
          <source>In case &lt;code&gt;subplots=True&lt;/code&gt;, share x axis and set some x axis labels to invisible; defaults to True if ax is None otherwise False if an ax is passed in; Be aware, that passing in both an ax and &lt;code&gt;sharex=True&lt;/code&gt; will alter all x axis labels for all axis in a figure.</source>
          <target state="translated">如果 &lt;code&gt;subplots=True&lt;/code&gt; ，则共享x轴并将某些x轴标签设置为不可见；如果ax为None则默认为True，否则为False。请注意，同时传递ax和 &lt;code&gt;sharex=True&lt;/code&gt; 将更改图形中所有轴的所有x轴标签。</target>
        </trans-unit>
        <trans-unit id="259ff876d5b3d5405f39041292d56dab1977340a" translate="yes" xml:space="preserve">
          <source>In case &lt;code&gt;subplots=True&lt;/code&gt;, share y axis and set some y axis labels to invisible.</source>
          <target state="translated">如果 &lt;code&gt;subplots=True&lt;/code&gt; ，则共享y轴并将一些y轴标签设置为不可见。</target>
        </trans-unit>
        <trans-unit id="cd532ff8699d514dc2c1ce70655231461c01cdd0" translate="yes" xml:space="preserve">
          <source>In case of a MultiIndex, only rename labels in the specified level.</source>
          <target state="translated">在多索引的情况下,只重命名指定级别的标签。</target>
        </trans-unit>
        <trans-unit id="82d44e95df31ef34cd50671cd671f7030bd91cea" translate="yes" xml:space="preserve">
          <source>In case of a key partially contained in a MultiIndex, indicate which levels are used. Levels can be referred by label or position.</source>
          <target state="translated">如果一个键部分包含在一个MultiIndex中,请说明使用了哪些级别。级别可以通过标签或位置来表示。</target>
        </trans-unit>
        <trans-unit id="fb7330f48df29ed5326f3bb15396cd90585fabe1" translate="yes" xml:space="preserve">
          <source>In case python/IPython is running in a terminal and</source>
          <target state="translated">如果python/IPython在终端上运行,而</target>
        </trans-unit>
        <trans-unit id="1052f0d8e2c2e12c931a4c0074d4560c46bfb585" translate="yes" xml:space="preserve">
          <source>In case python/IPython is running in a terminal and &lt;code&gt;large_repr&lt;/code&gt; equals &amp;lsquo;truncate&amp;rsquo; this can be set to 0 and pandas will auto-detect the height of the terminal and print a truncated object which fits the screen height. The IPython notebook, IPython qtconsole, or IDLE do not run in a terminal and hence it is not possible to do correct auto-detection. [default: 60] [currently: 15]display.max_seq_items : int or None when pretty-printing a long sequence, no more then &lt;code&gt;max_seq_items&lt;/code&gt; will be printed. If items are omitted, they will be denoted by the addition of &amp;ldquo;&amp;hellip;&amp;rdquo; to the resulting string.</source>
          <target state="translated">如果python / IPython在终端中运行，并且 &lt;code&gt;large_repr&lt;/code&gt; 等于'truncate'，则可以将其设置为0，熊猫会自动检测终端的高度并打印适合屏幕高度的截断对象。IPython笔记本，IPython qtconsole或IDLE不在终端中运行，因此无法进行正确的自动检测。[默认：60] [当前：15] display.max_seq_items：int或无，当漂亮地打印一个长序列时， &lt;code&gt;max_seq_items&lt;/code&gt; 只能打印max_seq_items。如果省略了项目，则将在结果字符串中添加&amp;ldquo;&amp;hellip;&amp;rdquo;来表示它们。</target>
        </trans-unit>
        <trans-unit id="88dc0ceb9b4e5ade156f2fb19973b762c584b547" translate="yes" xml:space="preserve">
          <source>In case python/IPython is running in a terminal and &lt;code&gt;large_repr&lt;/code&gt; equals &amp;lsquo;truncate&amp;rsquo; this can be set to 0 and pandas will auto-detect the width of the terminal and print a truncated object which fits the screen width. The IPython notebook, IPython qtconsole, or IDLE do not run in a terminal and hence it is not possible to do correct auto-detection. [default: 0] [currently: 0]display.max_colwidth : int The maximum width in characters of a column in the repr of a pandas data structure. When the column overflows, a &amp;ldquo;&amp;hellip;&amp;rdquo; placeholder is embedded in the output. [default: 50] [currently: 50]display.max_info_columns : int max_info_columns is used in DataFrame.info method to decide if per column information will be printed. [default: 100] [currently: 100]display.max_info_rows : int or None df.info() will usually show null-counts for each column. For large frames this can be quite slow. max_info_rows and max_info_cols limit this null check only to frames with smaller dimensions than specified. [default: 1690785] [currently: 1690785]display.max_rows : int If max_rows is exceeded, switch to truncate view. Depending on &lt;code&gt;large_repr&lt;/code&gt;, objects are either centrally truncated or printed as a summary view. &amp;lsquo;None&amp;rsquo; value means unlimited.</source>
          <target state="translated">如果python / IPython在终端中运行并且 &lt;code&gt;large_repr&lt;/code&gt; 等于'truncate'可以设置为0，pandas将自动检测终端的宽度并打印一个适合屏幕宽度的截断的对象。 IPython笔记本，IPython qtconsole或IDLE不在终端中运行，因此无法进行正确的自动检测。 [默认：0] [当前：0] display.max_colwidth：int熊猫数据结构的repr中列的最大宽度（以字符为单位）。当列溢出时，输出中将嵌入一个&amp;ldquo;&amp;hellip;&amp;rdquo;占位符。 [默认：50] [当前：50] display.max_info_columns：int max_info_columns在DataFrame.info方法中用于确定是否将打印每列信息。 [默认：100] [当前：100] display.max_info_rows：int或None df.info（）通常将为每列显示空计数。对于大帧，这可能会很慢。max_info_rows和max_info_cols将此空检查仅限制于尺寸小于指定尺寸的框架。 [默认：1690785] [当前：1690785] display.max_rows：int如果超出了max_rows，则切换到截断视图。取决于 &lt;code&gt;large_repr&lt;/code&gt; ，对象将被集中截断或作为摘要视图打印。 &amp;ldquo;无&amp;rdquo;值意味着无限。</target>
        </trans-unit>
        <trans-unit id="8e35d288cb0c579433cc89556209e4bed46e672a" translate="yes" xml:space="preserve">
          <source>In case subplots=True, share x axis and set some x axis labels to invisible; defaults to True if ax is None otherwise False if an ax is passed in. Note that passing in both an ax and sharex=True will alter all x axis labels for all subplots in a figure.</source>
          <target state="translated">在subplots=True的情况下,共享x轴,并将一些x轴标签设置为不可见;如果ax为None,默认为True;如果传递了一个ax,则默认为False。请注意,同时传递 ax 和 sharex=True 将会改变图中所有子图的所有 x 轴标签。</target>
        </trans-unit>
        <trans-unit id="13d4a95cd38f900c3ec733f1670b49419dc85c00" translate="yes" xml:space="preserve">
          <source>In case subplots=True, share y axis and set some y axis labels to invisible.</source>
          <target state="translated">在subplots=True的情况下,共享y轴并将一些y轴标签设置为不可见。</target>
        </trans-unit>
        <trans-unit id="0d9d818756c135822b8f3d3ecf8891eb81a47a9f" translate="yes" xml:space="preserve">
          <source>In case there is a tie, the lexicographical sorting looks at the next level of the MultiIndex.</source>
          <target state="translated">如果出现平局,词法排序会看MultiIndex的下一级。</target>
        </trans-unit>
        <trans-unit id="cde29dc4b9128386ba4e2d708cd826477c4917e9" translate="yes" xml:space="preserve">
          <source>In case when it is not possible to return designated types (e.g. when any element of input is before Timestamp.min or after Timestamp.max) return will have datetime.datetime type (or corresponding array/Series).</source>
          <target state="translated">在无法返回指定类型的情况下(例如,输入的任何元素在Timestamp.min之前或Timestamp.max之后),返回的将是datetime.datetime类型(或相应的数组/系列)。</target>
        </trans-unit>
        <trans-unit id="2d98b509261df46a77d5170a3ea614953001361f" translate="yes" xml:space="preserve">
          <source>In case where there are just a set of values allowed, list them in curly brackets and separated by commas (followed by a space). If the values are ordinal and they have an order, list them in this order. Otherwise, list the default value first, if there is one:</source>
          <target state="translated">如果只允许有一组值,则用大括号列出,并用逗号隔开(后面加一个空格)。如果值是顺序的,并且它们有一个顺序,就按这个顺序列出它们。否则,先列出默认值(如果有的话)。</target>
        </trans-unit>
        <trans-unit id="3faa60af9b3f807fffd055e96cd73d0da7d66524" translate="yes" xml:space="preserve">
          <source>In cases where the default value is &lt;code&gt;None&lt;/code&gt;, meaning that the value will not be used. Instead of &amp;ldquo;str, default None&amp;rdquo;, it is preferred to write &amp;ldquo;str, optional&amp;rdquo;. When &lt;code&gt;None&lt;/code&gt; is a value being used, we will keep the form &amp;ldquo;str, default None&amp;rdquo;. For example, in &lt;code&gt;df.to_csv(compression=None)&lt;/code&gt;, &lt;code&gt;None&lt;/code&gt; is not a value being used, but means that compression is optional, and no compression is being used if not provided. In this case we will use &lt;code&gt;str, optional&lt;/code&gt;. Only in cases like &lt;code&gt;func(value=None)&lt;/code&gt; and &lt;code&gt;None&lt;/code&gt; is being used in the same way as &lt;code&gt;0&lt;/code&gt; or &lt;code&gt;foo&lt;/code&gt; would be used, then we will specify &amp;ldquo;str, int or None, default None&amp;rdquo;.</source>
          <target state="translated">如果默认值为 &lt;code&gt;None&lt;/code&gt; ，则将不使用该值。最好是写&amp;ldquo; str，optional&amp;rdquo;代替&amp;ldquo; str，default None&amp;rdquo;。当使用 &lt;code&gt;None&lt;/code&gt; 值时，我们将使用&amp;ldquo; str，默认None&amp;rdquo;形式。例如，在 &lt;code&gt;df.to_csv(compression=None)&lt;/code&gt; 中， &lt;code&gt;None&lt;/code&gt; 并非正在使用的值，而是表示压缩是可选的，并且如果未提供压缩，则不使用压缩。在这种情况下，我们将使用 &lt;code&gt;str, optional&lt;/code&gt; 。只有在使用 &lt;code&gt;func(value=None)&lt;/code&gt; 和 &lt;code&gt;None&lt;/code&gt; 的情况下，才使用与 &lt;code&gt;0&lt;/code&gt; 或 &lt;code&gt;foo&lt;/code&gt; 相同的方式，然后我们将指定&amp;ldquo; str，int或None，默认为None&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="31fa9361b97b46ead5543693c00a21a41800c4f9" translate="yes" xml:space="preserve">
          <source>In comparison operations, &lt;a href=&quot;../reference/api/pandas.arrays.stringarray#pandas.arrays.StringArray&quot;&gt;&lt;code&gt;arrays.StringArray&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;Series&lt;/code&gt; backed by a &lt;code&gt;StringArray&lt;/code&gt; will return an object with &lt;a href=&quot;../reference/api/pandas.booleandtype#pandas.BooleanDtype&quot;&gt;&lt;code&gt;BooleanDtype&lt;/code&gt;&lt;/a&gt;, rather than a &lt;code&gt;bool&lt;/code&gt; dtype object. Missing values in a &lt;code&gt;StringArray&lt;/code&gt; will propagate in comparison operations, rather than always comparing unequal like &lt;code&gt;numpy.nan&lt;/code&gt;.</source>
          <target state="translated">在比较操作中，由 &lt;code&gt;StringArray&lt;/code&gt; 支持的&lt;a href=&quot;../reference/api/pandas.arrays.stringarray#pandas.arrays.StringArray&quot;&gt; &lt;code&gt;arrays.StringArray&lt;/code&gt; &lt;/a&gt;和 &lt;code&gt;Series&lt;/code&gt; 将返回具有&lt;a href=&quot;../reference/api/pandas.booleandtype#pandas.BooleanDtype&quot;&gt; &lt;code&gt;BooleanDtype&lt;/code&gt; &lt;/a&gt;的对象，而不是 &lt;code&gt;bool&lt;/code&gt; dtype对象。 &lt;code&gt;StringArray&lt;/code&gt; 中缺少的值将在比较操作中传播，而不是总是像 &lt;code&gt;numpy.nan&lt;/code&gt; 这样比较不相等的值。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
