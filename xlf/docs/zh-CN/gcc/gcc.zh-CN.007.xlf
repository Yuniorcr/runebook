<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="gcc">
    <body>
      <group id="gcc">
        <trans-unit id="e19fab7ccaf71008439ad46e66a6dd8a8249abc0" translate="yes" xml:space="preserve">
          <source>As in the preceding example, you can explicitly specify the alignment (in bytes) that you wish the compiler to use for a given &lt;code&gt;struct&lt;/code&gt; or &lt;code&gt;union&lt;/code&gt; type. Alternatively, you can leave out the alignment factor and just ask the compiler to align a type to the maximum useful alignment for the target machine you are compiling for. For example, you could write:</source>
          <target state="translated">如上例所示，您可以显式指定希望编译器用于给定 &lt;code&gt;struct&lt;/code&gt; 或 &lt;code&gt;union&lt;/code&gt; 类型的对齐方式（以字节为单位）。另外，您可以忽略对齐因子，而只是要求编译器将类型与要编译的目标计算机的最大有用对齐方式对齐。例如，您可以编写：</target>
        </trans-unit>
        <trans-unit id="b67040c22389d40183c4661602eeb071108d65a1" translate="yes" xml:space="preserve">
          <source>As in the preceding examples, you can explicitly specify the alignment (in bytes) that you wish the compiler to use for a given variable or structure field. Alternatively, you can leave out the alignment factor and just ask the compiler to align a variable or field to the default alignment for the target architecture you are compiling for. The default alignment is sufficient for all scalar types, but may not be enough for all vector types on a target that supports vector operations. The default alignment is fixed for a particular target ABI.</source>
          <target state="translated">和前面的例子一样,你可以明确地指定你希望编译器对一个给定的变量或结构字段使用的对齐方式(以字节为单位)。或者,你也可以不使用对齐因子,只要求编译器将一个变量或字段对齐到你正在编译的目标架构的默认对齐方式。默认对齐对于所有标量类型来说是足够的,但对于支持向量操作的目标上的所有向量类型来说可能是不够的。默认对齐方式对于特定的目标ABI来说是固定的。</target>
        </trans-unit>
        <trans-unit id="4953117cca7e33df31955c24738168de010b1a14" translate="yes" xml:space="preserve">
          <source>As long as the stack frame backchain is not used, code generated with</source>
          <target state="translated">只要不使用堆栈框架回链,用</target>
        </trans-unit>
        <trans-unit id="55612a0f57841c9314e7eae808cb715df500b680" translate="yes" xml:space="preserve">
          <source>As mentioned above, the new exceptions do not support handling types other than Objective-C objects. Furthermore, when used from Objective-C++, the Objective-C exception model does not interoperate with C++ exceptions at this time. This means you cannot &lt;code&gt;@throw&lt;/code&gt; an exception from Objective-C and &lt;code&gt;catch&lt;/code&gt; it in C++, or vice versa (i.e., &lt;code&gt;throw &amp;hellip; @catch&lt;/code&gt;).</source>
          <target state="translated">如上所述，新的异常不支持除Objective-C对象之外的其他处理类型。此外，从Objective-C ++使用时，Objective-C异常模型目前无法与C ++异常互操作。这意味着您不能 &lt;code&gt;@throw&lt;/code&gt; 从Objective-C抛出异常并用C ++ &lt;code&gt;catch&lt;/code&gt; 它，反之亦然（即， &lt;code&gt;throw &amp;hellip; @catch&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="294a250033394e9398ee357e8a3028f8f81f0fc0" translate="yes" xml:space="preserve">
          <source>As new Intel processors are deployed in the marketplace, the behavior of this option will change. Therefore, if you upgrade to a newer version of GCC, code generation controlled by this option will change to reflect the most current Intel processors at the time that version of GCC is released.</source>
          <target state="translated">随着市场上新的英特尔处理器的部署,这个选项的行为将发生变化。因此,如果您升级到较新版本的GCC,由该选项控制的代码生成将改变,以反映该版本GCC发布时最新的Intel处理器。</target>
        </trans-unit>
        <trans-unit id="071c1df1bb91e5145c672769a3ad43fada5e0f32" translate="yes" xml:space="preserve">
          <source>As new processors are deployed in the marketplace, the behavior of this option will change. Therefore, if you upgrade to a newer version of GCC, code generation controlled by this option will change to reflect the processors that are most common at the time that version of GCC is released.</source>
          <target state="translated">随着市场上新处理器的部署,这个选项的行为会发生变化。因此,如果您升级到较新的GCC版本,由该选项控制的代码生成将改变,以反映该版本GCC发布时最常见的处理器。</target>
        </trans-unit>
        <trans-unit id="3744f46b0905194e3e22c08ee725283caaeed6c9" translate="yes" xml:space="preserve">
          <source>As of the GCC 4.7.1 release, GCC supports the Go 1 language standard, described at &lt;a href=&quot;https://golang.org/doc/go1&quot;&gt;https://golang.org/doc/go1&lt;/a&gt;.</source>
          <target state="translated">从GCC 4.7.1版本开始，GCC支持Go 1语言标准，如&lt;a href=&quot;https://golang.org/doc/go1&quot;&gt;https://golang.org/doc/go1所述&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e64c1bee27f99a750cc73752558d5aa035a91d3b" translate="yes" xml:space="preserve">
          <source>As of this writing, only the NeXT runtime on Mac OS X 10.4 and later has support for invoking the &lt;code&gt;- (id) .cxx_construct&lt;/code&gt; and &lt;code&gt;- (void) .cxx_destruct&lt;/code&gt; methods.</source>
          <target state="translated">在撰写本文时，仅Mac OS X 10.4及更高版本上的NeXT运行时支持调用 &lt;code&gt;- (id) .cxx_construct&lt;/code&gt; 和 &lt;code&gt;- (void) .cxx_destruct&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="190838497fcc16bfeb19ed9bf8cb7b33b5859658" translate="yes" xml:space="preserve">
          <source>As of this writing, there are no SPARC implementations that have hardware support for the quad-word floating-point instructions. They all invoke a trap handler for one of these instructions, and then the trap handler emulates the effect of the instruction. Because of the trap handler overhead, this is much slower than calling the ABI library routines. Thus the</source>
          <target state="translated">截至本报告撰写时,还没有任何SPARC实现对四字浮点指令的硬件支持。它们都是为其中一条指令调用一个陷阱处理程序,然后由陷阱处理程序模拟指令的效果。由于陷阱处理程序的开销,这比调用ABI库的例程要慢得多。因此</target>
        </trans-unit>
        <trans-unit id="ea115f65d5a89a6a0ce102bba12e75c8b98c940e" translate="yes" xml:space="preserve">
          <source>As part of the Security Extensions GCC implements the intrinsics below. FPTR is used here to mean any function pointer type.</source>
          <target state="translated">作为安全扩展的一部分,GCC实现了下面的本征。FPTR在这里是指任何函数指针类型。</target>
        </trans-unit>
        <trans-unit id="44e4fff7ccbcdce5ca766f79d5a621ec9dbe0d23" translate="yes" xml:space="preserve">
          <source>As part of the Security Extensions GCC implements two new function attributes: &lt;code&gt;cmse_nonsecure_entry&lt;/code&gt; and &lt;code&gt;cmse_nonsecure_call&lt;/code&gt;.</source>
          <target state="translated">作为安全性扩展的一部分，GCC实现了两个新的函数属性： &lt;code&gt;cmse_nonsecure_entry&lt;/code&gt; 和 &lt;code&gt;cmse_nonsecure_call&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7eaf9c2848babad871d614fdc58e037312c5b34b" translate="yes" xml:space="preserve">
          <source>As per</source>
          <target state="translated">根据</target>
        </trans-unit>
        <trans-unit id="77bdd745d898a259ccaad1e7c0edf927d13bbb62" translate="yes" xml:space="preserve">
          <source>As per the previous level, but also show events for the entry to each function.</source>
          <target state="translated">与上一级一样,但也要显示每个功能的入口事件。</target>
        </trans-unit>
        <trans-unit id="51c247ef3385f14a80d57ef00798ecd37f7339e8" translate="yes" xml:space="preserve">
          <source>As per the previous level, but also show events relating to control flow that are significant to triggering the issue (e.g. &amp;ldquo;true path taken&amp;rdquo; at a conditional).</source>
          <target state="translated">按照之前的级别，还会显示与控制流相关的事件，这些事件对于触发问题很重要（例如，在有条件的情况下采用&amp;ldquo;真实路径&amp;rdquo;）。</target>
        </trans-unit>
        <trans-unit id="2efe9a9ef3b6fb5fc179ca740391f6374be999fe" translate="yes" xml:space="preserve">
          <source>As per the previous level, but show all control flow events, not just significant ones.</source>
          <target state="translated">与上一级一样,但显示所有控制流事件,而不仅仅是重要事件。</target>
        </trans-unit>
        <trans-unit id="dc6f3f1d276c90c5e06c8b6bf28158a5a889bccd" translate="yes" xml:space="preserve">
          <source>As permitted by ISO C11 and for compatibility with other compilers, GCC allows you to define a structure or union that contains, as fields, structures and unions without names. For example:</source>
          <target state="translated">在ISO C11的允许下,为了与其他编译器兼容,GCC允许你定义一个结构或联合体,它包含了字段、结构和无名联合体。例如:</target>
        </trans-unit>
        <trans-unit id="cd38e2252e3cfbc1562a66af3fc83a7b3476b926" translate="yes" xml:space="preserve">
          <source>As required by ISO C++, GCC considers member functions defined within the body of a class to be marked inline even if they are not explicitly declared with the &lt;code&gt;inline&lt;/code&gt; keyword. You can override this with</source>
          <target state="translated">根据ISO C ++的要求，即使未使用 &lt;code&gt;inline&lt;/code&gt; 关键字明确声明，GCC仍将在类主体内定义的成员函数标记为内联。您可以使用</target>
        </trans-unit>
        <trans-unit id="ee86d176185420b2cd516cd28e0d2c038499f36a" translate="yes" xml:space="preserve">
          <source>As with all outermost parameter qualifiers, &lt;code&gt;__restrict__&lt;/code&gt; is ignored in function definition matching. This means you only need to specify &lt;code&gt;__restrict__&lt;/code&gt; in a function definition, rather than in a function prototype as well.</source>
          <target state="translated">与所有最外面的参数限定符一样， &lt;code&gt;__restrict__&lt;/code&gt; 在函数定义匹配中被忽略。这意味着您只需要在函数定义中指定 &lt;code&gt;__restrict__&lt;/code&gt; ，而无需在函数原型中指定。</target>
        </trans-unit>
        <trans-unit id="ba3fbd93824241c0022727ea0aaa70098dbf8058" translate="yes" xml:space="preserve">
          <source>As with global register variables, it is recommended that you choose a register that is normally saved and restored by function calls on your machine, so that calls to library routines will not clobber it.</source>
          <target state="translated">与全局寄存器变量一样,建议选择一个通常由机器上的函数调用来保存和恢复的寄存器,这样对库例程的调用就不会破坏它。</target>
        </trans-unit>
        <trans-unit id="9d9e595b377650b7d530b408f01a2295e9aa3eb5" translate="yes" xml:space="preserve">
          <source>As with the C front end, G++ understands the C99 feature of restricted pointers, specified with the &lt;code&gt;__restrict__&lt;/code&gt;, or &lt;code&gt;__restrict&lt;/code&gt; type qualifier. Because you cannot compile C++ by specifying the</source>
          <target state="translated">与C前端一样，G ++理解使用 &lt;code&gt;__restrict__&lt;/code&gt; 或 &lt;code&gt;__restrict&lt;/code&gt; 类型限定符指定的受限指针的C99功能。因为您不能通过指定C来编译C ++</target>
        </trans-unit>
        <trans-unit id="21e7da79fc603087dc1baeac067752aa75dc3fe9" translate="yes" xml:space="preserve">
          <source>Assembler Options</source>
          <target state="translated">汇编器选项</target>
        </trans-unit>
        <trans-unit id="bcf5f12f4332ce70ca2c9b5133dda1d57f7cdf19" translate="yes" xml:space="preserve">
          <source>Assembler code that must be preprocessed.</source>
          <target state="translated">必须进行预处理的汇编程序代码。</target>
        </trans-unit>
        <trans-unit id="f9cab59729ce9a72e9592405aff1f8fcf01f46db" translate="yes" xml:space="preserve">
          <source>Assembler code.</source>
          <target state="translated">组装代码。</target>
        </trans-unit>
        <trans-unit id="32b8b4178e9d441788dbf96199839a839961313d" translate="yes" xml:space="preserve">
          <source>Assembler names for data:</source>
          <target state="translated">数据的汇编者名称。</target>
        </trans-unit>
        <trans-unit id="a60468da111a0ab238610d89ab550d7cb3db7634" translate="yes" xml:space="preserve">
          <source>Assembler names for functions:</source>
          <target state="translated">函数的汇编者名称。</target>
        </trans-unit>
        <trans-unit id="c09492c8b5916e81a92681e73286dd4d053d0d64" translate="yes" xml:space="preserve">
          <source>Assembly output</source>
          <target state="translated">组装输出</target>
        </trans-unit>
        <trans-unit id="c20d25392b6fcd428956d9fadf904cf6f25c34c2" translate="yes" xml:space="preserve">
          <source>Assert that compilation targets a freestanding environment. This implies</source>
          <target state="translated">断言编译的目标是一个独立的环境。这意味着</target>
        </trans-unit>
        <trans-unit id="d5b5344f90d89057b5b4c1d64f39bf480cc87ed4" translate="yes" xml:space="preserve">
          <source>Assert that compilation targets a hosted environment. This implies</source>
          <target state="translated">断言编译的目标是托管环境。这意味着</target>
        </trans-unit>
        <trans-unit id="3d6a91afbb703874ed1adcc1fc07fbc355255566" translate="yes" xml:space="preserve">
          <source>Assignments are also expressions and have an rvalue. However when assigning to a scalar volatile, the volatile object is not reread, regardless of whether the assignment expression&amp;rsquo;s rvalue is used or not. If the assignment&amp;rsquo;s rvalue is used, the value is that assigned to the volatile object. For instance, there is no read of &lt;var&gt;vobj&lt;/var&gt; in all the following cases:</source>
          <target state="translated">赋值也是表达式，具有右值。但是，在分配给标量volatile时，无论是否使用赋值表达式的rvalue，都不会重新读取volatile对象。如果使用分配的右值，则该值为分配给易失对象的值。例如，在以下所有情况下，都不会读取 &lt;var&gt;vobj&lt;/var&gt; ：</target>
        </trans-unit>
        <trans-unit id="0c40f851ca2e4b0159b069f87df3cdf0c325569f" translate="yes" xml:space="preserve">
          <source>Assume (do not assume) that all symbols have 32-bit values, regardless of the selected ABI. This option is useful in combination with</source>
          <target state="translated">假定(不要假定)所有符号都具有32位值,无论所选ABI如何。此选项与</target>
        </trans-unit>
        <trans-unit id="29f90ada4a3fec867ca24dbc5026596c24d16fc4" translate="yes" xml:space="preserve">
          <source>Assume (do not assume) that externally-defined data is in a small data section if the size of that data is within the</source>
          <target state="translated">假设(不要假设)外部定义的数据是在一个小数据部分,如果该数据的大小在</target>
        </trans-unit>
        <trans-unit id="2cfe16d43985ee39e482829ca4a8dfdcb2d636f4" translate="yes" xml:space="preserve">
          <source>Assume (do not assume) that the reciprocal estimate instructions provide higher-precision estimates than is mandated by the PowerPC ABI.</source>
          <target state="translated">假设(不要假设)往复估算指令提供的估算精度高于PowerPC ABI规定的精度。</target>
        </trans-unit>
        <trans-unit id="ec6f2df5d90d0e07067a08f77629a109a7baeb7c" translate="yes" xml:space="preserve">
          <source>Assume (do not assume) that the reciprocal estimate instructions provide higher-precision estimates than is mandated by the PowerPC ABI. Selecting</source>
          <target state="translated">假设(不要假设)往复估计指令提供的估计精度高于PowerPC ABI规定的精度。选择</target>
        </trans-unit>
        <trans-unit id="813b5f0f913426f167f43f6e9f2605b43322e0d6" translate="yes" xml:space="preserve">
          <source>Assume (do not assume) that the static and dynamic linkers support PLTs and copy relocations. This option only affects</source>
          <target state="translated">假设(不要假设)静态和动态链接器支持PLT和复制重定位。这个选项只影响</target>
        </trans-unit>
        <trans-unit id="6218242555601cfde6dcb1f0fb4410c65b0c0afe" translate="yes" xml:space="preserve">
          <source>Assume (do not assume) that zero displacement conditional branch instructions &lt;code&gt;bt&lt;/code&gt; and &lt;code&gt;bf&lt;/code&gt; are fast. If</source>
          <target state="translated">假设（不假设）零位移条件分支指令 &lt;code&gt;bt&lt;/code&gt; 和 &lt;code&gt;bf&lt;/code&gt; 很快。如果</target>
        </trans-unit>
        <trans-unit id="4d87b438e6a49fee40ee2b8e75d048b2cb33a8d4" translate="yes" xml:space="preserve">
          <source>Assume &lt;code&gt;int&lt;/code&gt; to be 8-bit integer. This affects the sizes of all types: a &lt;code&gt;char&lt;/code&gt; is 1 byte, an &lt;code&gt;int&lt;/code&gt; is 1 byte, a &lt;code&gt;long&lt;/code&gt; is 2 bytes, and &lt;code&gt;long long&lt;/code&gt; is 4 bytes. Please note that this option does not conform to the C standards, but it results in smaller code size.</source>
          <target state="translated">假设 &lt;code&gt;int&lt;/code&gt; 为8位整数。这会影响所有类型的大小： &lt;code&gt;char&lt;/code&gt; 是1个字节， &lt;code&gt;int&lt;/code&gt; 是1个字节， &lt;code&gt;long&lt;/code&gt; 是2个字节， &lt;code&gt;long long&lt;/code&gt; 是4个字节。请注意，此选项不符合C标准，但会导致代码较小。</target>
        </trans-unit>
        <trans-unit id="5c2bc85ec675432aace4d6922b50129cffa86b60" translate="yes" xml:space="preserve">
          <source>Assume &lt;var&gt;num&lt;/var&gt; to be the cost for a branch instruction. Higher numbers make the compiler try to generate more branch-free code if possible. If not specified the value is selected depending on the processor type that is being compiled for.</source>
          <target state="translated">假设 &lt;var&gt;num&lt;/var&gt; 是分支指令的成本。较大的数字使编译器在可能的情况下尝试生成更多的无分支代码。如果未指定，则根据要为其编译的处理器类型选择该值。</target>
        </trans-unit>
        <trans-unit id="a18b03a98d3895d8de33097ebfdc73e386381f27" translate="yes" xml:space="preserve">
          <source>Assume a large TLS segment when generating thread-local code.</source>
          <target state="translated">生成线程本地代码时,假设TLS段很大。</target>
        </trans-unit>
        <trans-unit id="dcc9240dada623776592057c6e5b8a92da4c9b4e" translate="yes" xml:space="preserve">
          <source>Assume addresses can be loaded as 16-bit unsigned values. This does not apply to function addresses for which</source>
          <target state="translated">假设地址可以加载为16位无符号值。这不适用于以下情况的函数地址</target>
        </trans-unit>
        <trans-unit id="fb31614e67999bd6734c6361178e2cdabb52e555" translate="yes" xml:space="preserve">
          <source>Assume all objects live in the lower 16MB of memory (so that their addresses can be loaded with the &lt;code&gt;ld24&lt;/code&gt; instruction), and assume all subroutines are reachable with the &lt;code&gt;bl&lt;/code&gt; instruction. This is the default.</source>
          <target state="translated">假定所有对象都位于较低的16MB内存中（以便可以通过 &lt;code&gt;ld24&lt;/code&gt; 指令加载其地址），并假定所有子例程都可以通过 &lt;code&gt;bl&lt;/code&gt; 指令访问。这是默认值。</target>
        </trans-unit>
        <trans-unit id="c507ae5c9607f036356273bef8470c3d07a51113" translate="yes" xml:space="preserve">
          <source>Assume inline assembler is using unified asm syntax. The default is currently off which implies divided syntax. This option has no impact on Thumb2. However, this may change in future releases of GCC. Divided syntax should be considered deprecated.</source>
          <target state="translated">假设内联汇编器使用统一的asm语法。目前的默认值是关闭,这意味着分割语法。这个选项对Thumb2没有影响。然而,在未来的GCC版本中可能会改变。分割语法应该被认为是废弃的。</target>
        </trans-unit>
        <trans-unit id="db05f7ded93295035bf91b215647f3c25bb15bd8" translate="yes" xml:space="preserve">
          <source>Assume loading data from flash is slower than fetching instruction. Therefore literal load is minimized for better performance. This option is only supported when compiling for ARMv7 M-profile and off by default. It conflicts with</source>
          <target state="translated">假设从flash加载数据比获取指令慢。因此,为了获得更好的性能,字面加载被最小化。这个选项只在编译ARMv7 M-profile时支持,默认情况下是关闭的。它与</target>
        </trans-unit>
        <trans-unit id="d4a16bcb883f109ce15025d3902db389e542f4a1" translate="yes" xml:space="preserve">
          <source>Assume objects may be anywhere in the 32-bit address space (the compiler generates &lt;code&gt;seth/add3&lt;/code&gt; instructions to load their addresses), and assume all subroutines are reachable with the &lt;code&gt;bl&lt;/code&gt; instruction.</source>
          <target state="translated">假定对象可能在32位地址空间中的任何位置（编译器生成 &lt;code&gt;seth/add3&lt;/code&gt; 指令以加载其地址），并假定 &lt;code&gt;bl&lt;/code&gt; 指令可访问所有子例程。</target>
        </trans-unit>
        <trans-unit id="7d339dd7aa4708a54eb51d13312b9c328ad3f5e5" translate="yes" xml:space="preserve">
          <source>Assume objects may be anywhere in the 32-bit address space (the compiler generates &lt;code&gt;seth/add3&lt;/code&gt; instructions to load their addresses), and assume subroutines may not be reachable with the &lt;code&gt;bl&lt;/code&gt; instruction (the compiler generates the much slower &lt;code&gt;seth/add3/jl&lt;/code&gt; instruction sequence).</source>
          <target state="translated">假设对象可能在32位地址空间中的任何位置（编译器生成 &lt;code&gt;seth/add3&lt;/code&gt; 指令以加载其地址），并假定 &lt;code&gt;bl&lt;/code&gt; 指令可能无法访问子例程（编译器生成慢得多的 &lt;code&gt;seth/add3/jl&lt;/code&gt; 指令）序列）。</target>
        </trans-unit>
        <trans-unit id="c85e043c6d4b72a1f02e91090d703114e74e4f8f" translate="yes" xml:space="preserve">
          <source>Assume that &lt;code&gt;RJMP&lt;/code&gt; and &lt;code&gt;RCALL&lt;/code&gt; can target the whole program memory.</source>
          <target state="translated">假定 &lt;code&gt;RJMP&lt;/code&gt; 和 &lt;code&gt;RCALL&lt;/code&gt; 可以针对整个程序存储器。</target>
        </trans-unit>
        <trans-unit id="33caf9125270759b9ef9dbfd91c8e100e633839c" translate="yes" xml:space="preserve">
          <source>Assume that ICPLBs are enabled at run time. This has an effect on certain anomaly workarounds. For Linux targets, the default is to assume ICPLBs are enabled; for standalone applications the default is off.</source>
          <target state="translated">假设在运行时启用ICPLBs。这对某些异常解决方法有影响。对于Linux目标机,默认是假设ICPLBs已启用;对于独立应用程序,默认是关闭。</target>
        </trans-unit>
        <trans-unit id="b5ac123daea99f10bd295c162e2bdc33dbbb4983" translate="yes" xml:space="preserve">
          <source>Assume that a loop with an exit will eventually take the exit and not loop indefinitely. This allows the compiler to remove loops that otherwise have no side-effects, not considering eventual endless looping as such.</source>
          <target state="translated">假设一个有退出的循环最终会把退出,而不是无限循环。这使得编译器可以删除原本没有副作用的循环,而不考虑最终的无尽循环。</target>
        </trans-unit>
        <trans-unit id="ed72c79186a186d46e787e25dd72b1da5c105ed8" translate="yes" xml:space="preserve">
          <source>Assume that all Objective-C message dispatches (&lt;code&gt;[receiver
message:arg]&lt;/code&gt;) in this translation unit ensure that the receiver is not &lt;code&gt;nil&lt;/code&gt;. This allows for more efficient entry points in the runtime to be used. This option is only available in conjunction with the NeXT runtime and ABI version 0 or 1.</source>
          <target state="translated">假定此转换单元中的所有Objective-C消息调度程序（ &lt;code&gt;[receiver message:arg]&lt;/code&gt; ）确保接收者不是 &lt;code&gt;nil&lt;/code&gt; 。这允许在运行时中使用更有效的入口点。该选项仅与NeXT运行时和ABI版本0或1结合使用。</target>
        </trans-unit>
        <trans-unit id="866258482a2aa9fcb54dee6ab333e2e33fa56a9f" translate="yes" xml:space="preserve">
          <source>Assume that all data in static storage can be accessed by LDS / STS instructions. This option has only an effect on reduced Tiny devices like ATtiny40. See also the &lt;code&gt;absdata&lt;/code&gt;&lt;a href=&quot;variable-attributes#AVR-Variable-Attributes&quot;&gt;variable attribute&lt;/a&gt;.</source>
          <target state="translated">假设可以通过LDS / STS指令访问静态存储中的所有数据。此选项仅对减少的Tiny设备（如ATtiny40）有效。另请参见 &lt;code&gt;absdata&lt;/code&gt; &lt;a href=&quot;variable-attributes#AVR-Variable-Attributes&quot;&gt;变量属性&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9ef3d0ef83e6f997acb69f32efa34ce5f18bfd5d" translate="yes" xml:space="preserve">
          <source>Assume that doubles have 8-byte alignment. This is the default.</source>
          <target state="translated">假设双字节有8个字节的对齐方式。这是默认的。</target>
        </trans-unit>
        <trans-unit id="856f36f37f5770dafc37ec4f5ce9ae4ba43b9ab0" translate="yes" xml:space="preserve">
          <source>Assume that floating-point registers are 32 bits wide.</source>
          <target state="translated">假设浮点寄存器的宽度为32位。</target>
        </trans-unit>
        <trans-unit id="89754b304532c00897fca86b5c5a4a2fdb8ea856" translate="yes" xml:space="preserve">
          <source>Assume that floating-point registers are 64 bits wide.</source>
          <target state="translated">假设浮点寄存器的宽度为64位。</target>
        </trans-unit>
        <trans-unit id="6c5971ed7912aa4bcfc190d25dcfc54913916046" translate="yes" xml:space="preserve">
          <source>Assume that floating-point stores and loads are not likely to cause a conflict when placed into the same instruction group. This option is disabled by default.</source>
          <target state="translated">假设浮点存储和加载放到同一个指令组中不会引起冲突。该选项默认为禁用。</target>
        </trans-unit>
        <trans-unit id="79ddd95e70fe2bc8d68e335f2358d8d016cca43e" translate="yes" xml:space="preserve">
          <source>Assume that general-purpose registers are 32 bits wide.</source>
          <target state="translated">假设通用寄存器的宽度为32位。</target>
        </trans-unit>
        <trans-unit id="67b1eea988cecf507f4140115cf0f3a04a0b6bc0" translate="yes" xml:space="preserve">
          <source>Assume that general-purpose registers are 64 bits wide.</source>
          <target state="translated">假设通用寄存器的宽度为64位。</target>
        </trans-unit>
        <trans-unit id="d05b8de7cb58ad911a3c660af041154da0f70378" translate="yes" xml:space="preserve">
          <source>Assume that programs cannot safely dereference null pointers, and that no code or data element resides at address zero. This option enables simple constant folding optimizations at all optimization levels. In addition, other optimization passes in GCC use this flag to control global dataflow analyses that eliminate useless checks for null pointers; these assume that a memory access to address zero always results in a trap, so that if a pointer is checked after it has already been dereferenced, it cannot be null.</source>
          <target state="translated">假设程序不能安全地去引用空指针,并且没有代码或数据元素驻留在零地址。这个选项可以在所有优化级别上实现简单的常量折叠优化。此外,GCC中的其他优化通道使用这个标志来控制全局数据流分析,以消除对空指针的无用检查;这些假设对地址为零的内存访问总是导致陷阱,因此如果一个指针在已经被解除引用后被检查,它就不能是空指针。</target>
        </trans-unit>
        <trans-unit id="076633874f4c1995b07023b5b94aab209c515c86" translate="yes" xml:space="preserve">
          <source>Assume that runtime support has been provided and so omit the simulator library (</source>
          <target state="translated">假设已经提供了运行时支持,因此省略了模拟器库(</target>
        </trans-unit>
        <trans-unit id="42823e20bce5001093b19d4ebc090a1f52fb87fe" translate="yes" xml:space="preserve">
          <source>Assume that runtime support has been provided and so there is no need to include the simulator library (</source>
          <target state="translated">假设已经提供了运行时支持,因此不需要包含模拟器库 (</target>
        </trans-unit>
        <trans-unit id="0d530f525409fd98b58f0bb247b2945e9f43679e" translate="yes" xml:space="preserve">
          <source>Assume that the current compilation unit represents the whole program being compiled. All public functions and variables with the exception of &lt;code&gt;main&lt;/code&gt; and those merged by attribute &lt;code&gt;externally_visible&lt;/code&gt; become static functions and in effect are optimized more aggressively by interprocedural optimizers.</source>
          <target state="translated">假定当前的编译单元代表正在编译的整个程序。除 &lt;code&gt;main&lt;/code&gt; 以外的所有公共函数和变量，以及由属性 &lt;code&gt;externally_visible&lt;/code&gt; 合并的那些公共函数和变量，都变为静态函数，实际上是由过程间优化器更积极地优化的。</target>
        </trans-unit>
        <trans-unit id="d4cfc093a537b06194880f65fa701bc5be05c19f" translate="yes" xml:space="preserve">
          <source>Assume that the device supports the Read-Modify-Write instructions &lt;code&gt;XCH&lt;/code&gt;, &lt;code&gt;LAC&lt;/code&gt;, &lt;code&gt;LAS&lt;/code&gt; and &lt;code&gt;LAT&lt;/code&gt;.</source>
          <target state="translated">假设设备支持Read-Modify-Write指令 &lt;code&gt;XCH&lt;/code&gt; ， &lt;code&gt;LAC&lt;/code&gt; ， &lt;code&gt;LAS&lt;/code&gt; 和 &lt;code&gt;LAT&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="766547e453a1be99c1e3faccd183445d895ac153" translate="yes" xml:space="preserve">
          <source>Assume that the displacement between the text and data segments is fixed at static link time. This allows data to be referenced by offset from start of text address instead of GOT since PC-relative addressing is not supported.</source>
          <target state="translated">假设文本段和数据段之间的位移在静态链接时是固定的。由于不支持PC相关寻址,因此可以用文本地址开始的偏移量而不是GOT来引用数据。</target>
        </trans-unit>
        <trans-unit id="ebfb14654d3ce6ee7fc14d89650e1df706d43a0e" translate="yes" xml:space="preserve">
          <source>Assume that the displacement between the text and data segments is fixed at static link time. This permits using PC-relative addressing operations to access data known to be in the data segment. For non-VxWorks RTP targets, this option is enabled by default. When disabled on such targets, it will enable</source>
          <target state="translated">假设文本段和数据段之间的位移在静态链接时间是固定的。这允许使用PC相对寻址操作来访问数据段中已知的数据。对于非VxWorks RTP目标,该选项默认为启用。当在这些目标上禁用时,它将启用</target>
        </trans-unit>
        <trans-unit id="38bffa713c2a7cd96b200f3894b2b7a3ab419ebb" translate="yes" xml:space="preserve">
          <source>Assume that the flash memory has a size of &lt;var&gt;num&lt;/var&gt; times 64 KiB.</source>
          <target state="translated">假设闪存的大小为 &lt;var&gt;num&lt;/var&gt; 乘以64 KiB。</target>
        </trans-unit>
        <trans-unit id="0381000794bbd2c3b341dcaa9dd877537e5d82e9" translate="yes" xml:space="preserve">
          <source>Assume that the floating-point coprocessor only supports single-precision operations.</source>
          <target state="translated">假设浮点协处理器只支持单精度操作。</target>
        </trans-unit>
        <trans-unit id="da28820fdda9574eb1ba106e15f86ccdafa0352f" translate="yes" xml:space="preserve">
          <source>Assume that the floating-point coprocessor supports double-precision operations. This is the default.</source>
          <target state="translated">假设浮点协处理器支持双精度操作。这是默认的。</target>
        </trans-unit>
        <trans-unit id="fdfa0bfee5480efa2b5e12152c0e653e6cc25473" translate="yes" xml:space="preserve">
          <source>Assume that the handler uses a shadow register set, instead of the main general-purpose registers. An optional argument &lt;code&gt;intstack&lt;/code&gt; is supported to indicate that the shadow register set contains a valid stack pointer.</source>
          <target state="translated">假定处理程序使用影子寄存器集，而不是主要的通用寄存器。支持可选参数 &lt;code&gt;intstack&lt;/code&gt; ，以指示影子寄存器集包含有效的堆栈指针。</target>
        </trans-unit>
        <trans-unit id="cb05f1c18ebd5a07940293ac38328ed8480807dc" translate="yes" xml:space="preserve">
          <source>Assume that the program is arbitrarily large. This is the default.</source>
          <target state="translated">假设程序是任意大的。这是默认的。</target>
        </trans-unit>
        <trans-unit id="bea8e60014028d1c1e2350ea91c13bef18cfe395" translate="yes" xml:space="preserve">
          <source>Assume the incoming stack is aligned to a 2 raised to &lt;var&gt;num&lt;/var&gt; byte boundary. If</source>
          <target state="translated">假定传入的堆栈与2对齐到 &lt;var&gt;num&lt;/var&gt; 个字节的边界对齐。如果</target>
        </trans-unit>
        <trans-unit id="2b0c018c4bbeac1a835b6bc4f97980f45c5201f9" translate="yes" xml:space="preserve">
          <source>At level &lt;var&gt;2&lt;/var&gt;, the call in the example above is again diagnosed, but this time because with &lt;var&gt;a&lt;/var&gt; equal to a 32-bit &lt;code&gt;INT_MIN&lt;/code&gt; the first &lt;code&gt;%i&lt;/code&gt; directive will write some of its digits beyond the end of the destination buffer. To make the call safe regardless of the values of the two variables, the size of the destination buffer must be increased to at least 34 bytes. GCC includes the minimum size of the buffer in an informational note following the warning.</source>
          <target state="translated">在级别 &lt;var&gt;2&lt;/var&gt; ，在上述的例子中，呼叫被再次诊断，但此时，因为与 &lt;var&gt;a&lt;/var&gt; 等于32位 &lt;code&gt;INT_MIN&lt;/code&gt; 第一 &lt;code&gt;%i&lt;/code&gt; 指令将写它的一些数字超出目标缓冲区的末尾。为了使调用安全，而与两个变量的值无关，必须将目标缓冲区的大小增加到至少34个字节。 GCC在警告之后的信息性注释中包括缓冲区的最小大小。</target>
        </trans-unit>
        <trans-unit id="3ddf0f631ce882bb84e3fb93f118fee7f5a7f5f9" translate="yes" xml:space="preserve">
          <source>At present, GCC only provides support for operations on 32-bit vectors. The vector type associated with 8-bit integer data is usually called &lt;code&gt;v4i8&lt;/code&gt;, the vector type associated with Q7 is usually called &lt;code&gt;v4q7&lt;/code&gt;, the vector type associated with 16-bit integer data is usually called &lt;code&gt;v2i16&lt;/code&gt;, and the vector type associated with Q15 is usually called &lt;code&gt;v2q15&lt;/code&gt;. They can be defined in C as follows:</source>
          <target state="translated">目前，GCC仅支持对32位向量的操作。与8位整数数据相关的向量类型通常称为 &lt;code&gt;v4i8&lt;/code&gt; ，与Q7相关的向量类型通常称为 &lt;code&gt;v4q7&lt;/code&gt; ，与16位整数数据有关的向量类型通常称为 &lt;code&gt;v2i16&lt;/code&gt; ，与Q15相关的向量类型通常为称为 &lt;code&gt;v2q15&lt;/code&gt; 。它们可以在C中定义如下：</target>
        </trans-unit>
        <trans-unit id="7562b8145986b9d15bbe747f7453ec31fbcb23e3" translate="yes" xml:space="preserve">
          <source>At present, a declaration to which &lt;code&gt;weakref&lt;/code&gt; is attached can only be &lt;code&gt;static&lt;/code&gt;.</source>
          <target state="translated">目前，附加了 &lt;code&gt;weakref&lt;/code&gt; 的声明只能是 &lt;code&gt;static&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e4135487f1e326a7c07cb63519ab457040bcc6fd" translate="yes" xml:space="preserve">
          <source>At present, the first parameter in a function prototype must have some type specifier that is not an attribute specifier; this resolves an ambiguity in the interpretation of &lt;code&gt;void f(int
(__attribute__((foo)) x))&lt;/code&gt;, but is subject to change. At present, if the parentheses of a function declarator contain only attributes then those attributes are ignored, rather than yielding an error or warning or implying a single parameter of type int, but this is subject to change.</source>
          <target state="translated">当前，函数原型中的第一个参数必须具有某种类型说明符，而不是属性说明符。这解决了 &lt;code&gt;void f(int (__attribute__((foo)) x))&lt;/code&gt; 的解释中的歧义，但可能会发生变化。当前，如果函数声明符的括号仅包含属性，则将忽略这些属性，而不是产生错误或警告或暗示单个int类型的参数，但这可能会发生变化。</target>
        </trans-unit>
        <trans-unit id="aba1eab05ac64c3b09192d2f6e850b4049723108" translate="yes" xml:space="preserve">
          <source>At the user level, the extension is visible with a new storage class keyword: &lt;code&gt;__thread&lt;/code&gt;. For example:</source>
          <target state="translated">在用户级别，可以使用新的存储类关键字 &lt;code&gt;__thread&lt;/code&gt; 看到扩展名。例如：</target>
        </trans-unit>
        <trans-unit id="822a22d01653371bac14c53e07474f5d45325389" translate="yes" xml:space="preserve">
          <source>At this level</source>
          <target state="translated">在这一级</target>
        </trans-unit>
        <trans-unit id="87ea658ed4a4a90d1fc99e8e69012153c56f031c" translate="yes" xml:space="preserve">
          <source>At this level, in addition to diagnosing all the same constructs as at level 1, a diagnostic is also issued for placement new expressions that construct an object in the last member of structure whose type is an array of a single element and whose size is less than the size of the object being constructed. While the previous example would be diagnosed, the following construct makes use of the flexible member array extension to avoid the warning at level 2.</source>
          <target state="translated">在这一级,除了诊断所有与第1级相同的构造外,还对在结构的最后一个成员中构造对象的放置新表达式发出诊断,该对象的类型是一个单元素数组,其大小小于被构造对象的大小。虽然前面的例子会被诊断出来,但下面的构造利用灵活的成员数组扩展来避免第2级的警告。</target>
        </trans-unit>
        <trans-unit id="899a58ab48a1eeb8b5da7677f79db54f17f5ac4a" translate="yes" xml:space="preserve">
          <source>At this level, interprocedural call and return events are displayed, along with the most pertinent state-change events relating to a diagnostic. For example, for a double-&lt;code&gt;free&lt;/code&gt; diagnostic, both calls to &lt;code&gt;free&lt;/code&gt; will be shown.</source>
          <target state="translated">在此级别上，将显示过程间调用和返回事件，以及与诊断有关的最相关的状态更改事件。例如，对于双重 &lt;code&gt;free&lt;/code&gt; 诊断，将显示两个 &lt;code&gt;free&lt;/code&gt; 呼叫。</target>
        </trans-unit>
        <trans-unit id="01d0144240e3a9879fbee890a976db3a3119bfe0" translate="yes" xml:space="preserve">
          <source>At this time GCC tries to detect also a few terminals that are known to not implement the URL feature, and have bugs or at least had bugs in some versions that are still in use, where the URL escapes are likely to misbehave, i.e. print garbage on the screen. That list is currently xfce4-terminal, certain known to be buggy gnome-terminal versions, the linux console, and mingw. This check can be skipped with the</source>
          <target state="translated">此时GCC还试图检测一些已知没有实现URL功能的终端,并且在某些仍在使用的版本中存在bug或至少有过bug,在这些版本中,URL转义很可能出现错误行为,即在屏幕上打印垃圾。这个列表目前是xfce4-terminal、某些已知有bug的gnome-terminal版本、linux控制台和mingw。这个检查可以用</target>
        </trans-unit>
        <trans-unit id="27bef66661f5c0b03146d1698ca3afb51d9a26fb" translate="yes" xml:space="preserve">
          <source>Atomic built-in functions with memory model.</source>
          <target state="translated">原子内置功能与内存模型。</target>
        </trans-unit>
        <trans-unit id="4ce1364206864236a22c5c48cd625fe86883adb2" translate="yes" xml:space="preserve">
          <source>Atomic types are not permitted for bit-fields.</source>
          <target state="translated">位字段不允许使用原子类型。</target>
        </trans-unit>
        <trans-unit id="b41c8daf0a5d584177e036c6b54eb5d698ff31ca" translate="yes" xml:space="preserve">
          <source>Attempt to avoid false dependencies in scheduled code by making use of registers left over after register allocation. This optimization most benefits processors with lots of registers. Depending on the debug information format adopted by the target, however, it can make debugging impossible, since variables no longer stay in a &amp;ldquo;home register&amp;rdquo;.</source>
          <target state="translated">尝试通过使用寄存器分配后剩余的寄存器来避免调度代码中的虚假依赖关系。这种优化最有利于拥有大量寄存器的处理器。但是，根据目标采用的调试信息格式，由于变量不再停留在&amp;ldquo;本地寄存器&amp;rdquo;中，它可能使调试变得不可能。</target>
        </trans-unit>
        <trans-unit id="c6f5acede0fbb18382444dea8c6c4247f6477d4a" translate="yes" xml:space="preserve">
          <source>Attempt to convert calls to virtual functions to direct calls. This is done both within a procedure and interprocedurally as part of indirect inlining (</source>
          <target state="translated">试图将对虚拟函数的调用转换为直接调用。这既可以在存储过程中进行,也可以作为间接内联的一部分在过程间进行(</target>
        </trans-unit>
        <trans-unit id="23ecd786dc35f08a1baffd99e6e7d5e25ec53b58" translate="yes" xml:space="preserve">
          <source>Attempt to convert calls to virtual functions to speculative direct calls. Based on the analysis of the type inheritance graph, determine for a given call the set of likely targets. If the set is small, preferably of size 1, change the call into a conditional deciding between direct and indirect calls. The speculative calls enable more optimizations, such as inlining. When they seem useless after further optimization, they are converted back into original form.</source>
          <target state="translated">尝试将对虚拟函数的调用转换为投机性直接调用。根据对类型继承图的分析,确定给定调用的可能目标集。如果该集合很小,最好是大小为1,则将调用改为有条件的决定直接调用和间接调用。投机调用可以实现更多的优化,比如内联。当它们在进一步优化后显得无用时,就会被转换回原始形式。</target>
        </trans-unit>
        <trans-unit id="015c279bf199fbda7e73b9795378a6fd0b0af2c9" translate="yes" xml:space="preserve">
          <source>Attempt to decrease register pressure through register live range shrinkage. This is helpful for fast processors with small or moderate size register sets.</source>
          <target state="translated">试图通过收缩寄存器活区来降低寄存器压力。这对具有小型或中等规模寄存器集的快速处理器很有帮助。</target>
        </trans-unit>
        <trans-unit id="687510f6384de354811653c1b3a65669791e13da" translate="yes" xml:space="preserve">
          <source>Attempt to determine location views that can be omitted from location view lists. This requires the compiler to have very accurate insn length estimates, which isn&amp;rsquo;t always the case, and it may cause incorrect view lists to be generated silently when using an assembler that does not support location view lists. The GNU assembler will flag any such error as a &lt;code&gt;view number mismatch&lt;/code&gt;. This is only enabled on ports that define a reliable estimation function.</source>
          <target state="translated">尝试确定可以从位置视图列表中省略的位置视图。这要求编译器具有非常准确的insn长度估计，而这并非总是如此，并且在使用不支持位置视图列表的汇编器时，它可能会导致不正确地生成不正确的视图列表。GNU汇编器会将任何此类错误标记为 &lt;code&gt;view number mismatch&lt;/code&gt; 。仅在定义可靠估计功能的端口上启用此功能。</target>
        </trans-unit>
        <trans-unit id="aac236b78fdffe9d37dcfcf412e47b1651113242" translate="yes" xml:space="preserve">
          <source>Attempt to keep the stack boundary aligned to a 2 raised to &lt;var&gt;num&lt;/var&gt; byte boundary. If</source>
          <target state="translated">尝试使堆栈边界与2对齐，以提高到 &lt;var&gt;num&lt;/var&gt; 字节边界。如果</target>
        </trans-unit>
        <trans-unit id="c862c84dcea1c34fb363ef2530e074c7fb9ff011" translate="yes" xml:space="preserve">
          <source>Attempt to merge identical constants (string constants and floating-point constants) across compilation units.</source>
          <target state="translated">试图将相同的常量(字符串常量和浮点常量)合并到不同的编译单元。</target>
        </trans-unit>
        <trans-unit id="50e4bd95dd66a112841cf4cd0b134789556e574d" translate="yes" xml:space="preserve">
          <source>Attempt to merge identical constants and identical variables.</source>
          <target state="translated">试图合并相同的常量和相同的变量。</target>
        </trans-unit>
        <trans-unit id="0f797d45d3d320c615fd705a20d8464b1c6f92f0" translate="yes" xml:space="preserve">
          <source>Attempt to minimize stack usage. The compiler attempts to use less stack space, even if that makes the program slower. This option implies setting the</source>
          <target state="translated">试图尽量减少堆栈的使用。编译器试图使用更少的堆栈空间,即使这会使程序更慢。这个选项意味着将</target>
        </trans-unit>
        <trans-unit id="1d6331b92854e1a7daaaa3b254ef23d3e2705563" translate="yes" xml:space="preserve">
          <source>Attempt to remove redundant extension instructions. This is especially helpful for the x86-64 architecture, which implicitly zero-extends in 64-bit registers after writing to their lower 32-bit half.</source>
          <target state="translated">试图删除多余的扩展指令。这对x86-64架构特别有帮助,因为x86-64架构在写到64位寄存器的下半部分32位后,会隐式地在64位寄存器中进行零扩展。</target>
        </trans-unit>
        <trans-unit id="af8cd75ee0ed545b02a70bb0db32f4bb7b0a164a" translate="yes" xml:space="preserve">
          <source>Attempt to transform conditional jumps in the innermost loops to branch-less equivalents. The intent is to remove control-flow from the innermost loops in order to improve the ability of the vectorization pass to handle these loops. This is enabled by default if vectorization is enabled.</source>
          <target state="translated">试图将最内部循环中的条件跳转转化为无分支的等价物。这样做的目的是为了去除最内部循环中的控制流,以提高矢量化传递处理这些循环的能力。如果启用了向量化,则默认启用该功能。</target>
        </trans-unit>
        <trans-unit id="a82b9d3f6e114711b5045a6cdf1e499c5d11c4fa" translate="yes" xml:space="preserve">
          <source>Attempt to transform conditional jumps into branch-less equivalents. This includes use of conditional moves, min, max, set flags and abs instructions, and some tricks doable by standard arithmetics. The use of conditional execution on chips where it is available is controlled by</source>
          <target state="translated">试图将条件跳转转化为无分支的等价物。这包括使用条件移动、最小、最大、设置标志和abs指令,以及一些可以通过标准算术来实现的技巧。在可以使用条件执行的芯片上,条件执行的使用是由以下控制的</target>
        </trans-unit>
        <trans-unit id="1ffd089c28cbc3f051c86ecbaa3c75b1a01df17f" translate="yes" xml:space="preserve">
          <source>Attempt to utilize both instruction sets at once. This effectively doubles the amount of available registers, and on chips with separate execution units for 387 and SSE the execution resources too. Use this option with care, as it is still experimental, because the GCC register allocator does not model separate functional units well, resulting in unstable performance.</source>
          <target state="translated">试图同时利用两个指令集。这样可以有效地将可用的寄存器数量增加一倍,在有387和SSE独立执行单元的芯片上,执行资源也会增加一倍。谨慎使用这个选项,因为它还是试验性的,因为GCC寄存器分配器不能很好地模拟单独的功能单元,导致性能不稳定。</target>
        </trans-unit>
        <trans-unit id="768394a0c657893c518e749955ef528cb8973c45" translate="yes" xml:space="preserve">
          <source>Attribute specifiers may be mixed with type qualifiers appearing inside the &lt;code&gt;[]&lt;/code&gt; of a parameter array declarator, in the C99 construct by which such qualifiers are applied to the pointer to which the array is implicitly converted. Such attribute specifiers apply to the pointer, not to the array, but at present this is not implemented and they are ignored.</source>
          <target state="translated">在C99结构中，属性说明符可以与出现在参数数组声明符 &lt;code&gt;[]&lt;/code&gt; 内的类型限定符混合，通过这种限定符将这些限定符应用于隐式转换到数组的指针。此类属性说明符适用于指针，而不适用于数组，但目前尚未实现，因此将被忽略。</target>
        </trans-unit>
        <trans-unit id="f15f9fabc9141a4fd02709ab1f144944da1df77d" translate="yes" xml:space="preserve">
          <source>Attributes considered include &lt;code&gt;alloc_align&lt;/code&gt;, &lt;code&gt;alloc_size&lt;/code&gt;, &lt;code&gt;cold&lt;/code&gt;, &lt;code&gt;const&lt;/code&gt;, &lt;code&gt;hot&lt;/code&gt;, &lt;code&gt;leaf&lt;/code&gt;, &lt;code&gt;malloc&lt;/code&gt;, &lt;code&gt;nonnull&lt;/code&gt;, &lt;code&gt;noreturn&lt;/code&gt;, &lt;code&gt;nothrow&lt;/code&gt;, &lt;code&gt;pure&lt;/code&gt;, &lt;code&gt;returns_nonnull&lt;/code&gt;, and &lt;code&gt;returns_twice&lt;/code&gt;.</source>
          <target state="translated">考虑属性包括 &lt;code&gt;alloc_align&lt;/code&gt; ， &lt;code&gt;alloc_size&lt;/code&gt; ， &lt;code&gt;cold&lt;/code&gt; ， &lt;code&gt;const&lt;/code&gt; ， &lt;code&gt;hot&lt;/code&gt; ， &lt;code&gt;leaf&lt;/code&gt; ， &lt;code&gt;malloc&lt;/code&gt; 的， &lt;code&gt;nonnull&lt;/code&gt; ， &lt;code&gt;noreturn&lt;/code&gt; ， &lt;code&gt;nothrow&lt;/code&gt; ， &lt;code&gt;pure&lt;/code&gt; ， &lt;code&gt;returns_nonnull&lt;/code&gt; 和 &lt;code&gt;returns_twice&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1e72cecf4ee93be8444bf26683f3314180b4f20f" translate="yes" xml:space="preserve">
          <source>Augment variable location lists with progressive view numbers implied from the line number table. This enables debug information consumers to inspect state at certain points of the program, even if no instructions associated with the corresponding source locations are present at that point. If the assembler lacks support for view numbers in line number tables, this will cause the compiler to emit the line number table, which generally makes them somewhat less compact. The augmented line number tables and location lists are fully backward-compatible, so they can be consumed by debug information consumers that are not aware of these augmentations, but they won&amp;rsquo;t derive any benefit from them either.</source>
          <target state="translated">扩充变量位置列表，其中包含行号表中隐含的渐进视图号。这使调试信息使用者能够检查程序某些点的状态，即使在该点不存在与相应源位置关联的指令也是如此。如果汇编程序不支持行号表中的视图号，则将导致编译器发出行号表，这通常会使它们的紧凑性降低。扩展的行号表和位置列表是完全向后兼容的，因此调试信息使用方可以使用它们，这些用户不知道这些扩展，但是它们也不会从中获得任何好处。</target>
        </trans-unit>
        <trans-unit id="e028ddf293b9280450ea608fcf02b6afb803a5cf" translate="yes" xml:space="preserve">
          <source>Automatically convert relative source file names to absolute path names in the</source>
          <target state="translated">自动将相对的源文件名转换为绝对路径名。</target>
        </trans-unit>
        <trans-unit id="5484fc94aa2d1ceccb816e9c671bdaec50d90ef7" translate="yes" xml:space="preserve">
          <source>Average number of iterations of a loop.</source>
          <target state="translated">循环的平均迭代次数。</target>
        </trans-unit>
        <trans-unit id="04f04d96d845a90ad835e69c3cba86443a61a89a" translate="yes" xml:space="preserve">
          <source>Avoid or allow generating memory accesses that may not be aligned on a natural object boundary as described in the architecture specification.</source>
          <target state="translated">避免或允许生成可能不在架构规范中描述的自然对象边界上对齐的内存访问。</target>
        </trans-unit>
        <trans-unit id="ae4f281df5a5d0ff3cad6371f76d5c29b6d953ec" translate="yes" xml:space="preserve">
          <source>B</source>
          <target state="translated">B</target>
        </trans-unit>
        <trans-unit id="25ec48c867ed8bb8e6f96a8b43aad4372bc4578a" translate="yes" xml:space="preserve">
          <source>B register</source>
          <target state="translated">B册</target>
        </trans-unit>
        <trans-unit id="cde782be8b675144b1c3a413d952e5058ca53d38" translate="yes" xml:space="preserve">
          <source>BL</source>
          <target state="translated">BL</target>
        </trans-unit>
        <trans-unit id="7a64a2253d2959f0bf9362ab5d3438b38d98d231" translate="yes" xml:space="preserve">
          <source>BMI instructions.</source>
          <target state="translated">BMI指示。</target>
        </trans-unit>
        <trans-unit id="a694b7ba8977f0d1b0d7c872c114539da755bd3b" translate="yes" xml:space="preserve">
          <source>BMI2 instructions.</source>
          <target state="translated">BMI2说明。</target>
        </trans-unit>
        <trans-unit id="bfdb06081cf1ce665b573d70cc38b7b454902ff9" translate="yes" xml:space="preserve">
          <source>BRIG files (binary representation of HSAIL).</source>
          <target state="translated">BRIG文件(HSAIL的二进制表示);</target>
        </trans-unit>
        <trans-unit id="089ea9746c8cbdc04b34721f820ba603e6881ff2" translate="yes" xml:space="preserve">
          <source>Base pointer register (r28&amp;ndash;r31)</source>
          <target state="translated">基本指针寄存器（r28&amp;ndash;r31）</target>
        </trans-unit>
        <trans-unit id="92f76287d800c12dfd6b51ad7e80eed03e92c213" translate="yes" xml:space="preserve">
          <source>Base::Base</source>
          <target state="translated">Base::Base</target>
        </trans-unit>
        <trans-unit id="9039faeb6333b5e373bf646f9ff036f287abc6be" translate="yes" xml:space="preserve">
          <source>Base::operator=</source>
          <target state="translated">Base::operator=</target>
        </trans-unit>
        <trans-unit id="7b3a608459615b9bc19c9d4a294c3d2c0cd4a8a0" translate="yes" xml:space="preserve">
          <source>Basic use of constraints.</source>
          <target state="translated">约束的基本使用。</target>
        </trans-unit>
        <trans-unit id="d5770040433fcf2fed9fca7319c3ac627f6efe91" translate="yes" xml:space="preserve">
          <source>Be aware of this when performing timing tests, for instance the following loop can be completely removed, provided &lt;code&gt;some_expression&lt;/code&gt; can provably not change any global state.</source>
          <target state="translated">在执行时序测试时，请注意这一点，例如，只要 &lt;code&gt;some_expression&lt;/code&gt; 可证明不更改任何全局状态，则可以完全删除以下循环。</target>
        </trans-unit>
        <trans-unit id="6d4c386efa741fabb074be3b34ff11b267e4e0d7" translate="yes" xml:space="preserve">
          <source>Be aware that headers from outside your project, in particular system headers and headers from any other library you use, may not be expecting to be compiled with visibility other than the default. You may need to explicitly say &lt;code&gt;#pragma GCC visibility push(default)&lt;/code&gt; before including any such headers.</source>
          <target state="translated">请注意，项目外部的标头（尤其是系统标头和您使用的任何其他库的标头）可能不会期望使用默认值以外的可见性进行编译。在包含任何此类标头之前，您可能需要明确地说 &lt;code&gt;#pragma GCC visibility push(default)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b31e54ef88fe124b0da9af9ee2524cfb6800e5f0" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;__builtin_longjmp&lt;/code&gt; depends on the function return mechanism to restore the stack context, it cannot be called from the same function calling &lt;code&gt;__builtin_setjmp&lt;/code&gt; to initialize &lt;var&gt;buf&lt;/var&gt;. It can only be called from a function called (directly or indirectly) from the function calling &lt;code&gt;__builtin_setjmp&lt;/code&gt;.</source>
          <target state="translated">因为 &lt;code&gt;__builtin_longjmp&lt;/code&gt; 依赖于函数返回机制来还原堆栈上下文，所以不能从调用 &lt;code&gt;__builtin_setjmp&lt;/code&gt; 的同一函数中调用它来初始化 &lt;var&gt;buf&lt;/var&gt; 。只能从调用 &lt;code&gt;__builtin_setjmp&lt;/code&gt; 的函数（直接或间接）中调用的函数。</target>
        </trans-unit>
        <trans-unit id="d94ff60e2bbcd755c2d21600b1c5beacc8d88e0e" translate="yes" xml:space="preserve">
          <source>Because of the interactions between synchronization and exception handling, you can only use &lt;code&gt;@synchronized&lt;/code&gt; when compiling with exceptions enabled, that is with the command line option</source>
          <target state="translated">由于同步和异常处理之间存在交互作用，因此仅在启用异常的情况下（即通过命令行选项）进行编译时，才可以使用 &lt;code&gt;@synchronized&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bc31609fad1f0a543a7bf312e8fc7b4e085e75b6" translate="yes" xml:space="preserve">
          <source>Because of the special nature of the flag output operands, the constraint may not include alternatives.</source>
          <target state="translated">由于标志输出操作数的特殊性,约束条件可能不包括替代品。</target>
        </trans-unit>
        <trans-unit id="74b7dab219d7dd89ab8e51f25903de3035d7b00a" translate="yes" xml:space="preserve">
          <source>Because of the way GCC instruments calls, a call count can be shown after a line with no individual blocks. As you can see, line 33 contains a basic block that was not executed.</source>
          <target state="translated">由于GCC工具调用的方式,可以在没有单独块的行后显示调用计数。如你所见,第33行包含了一个没有被执行的基本块。</target>
        </trans-unit>
        <trans-unit id="ba975e496f98093e5f2ea388a49453725d139a4b" translate="yes" xml:space="preserve">
          <source>Because the &lt;code&gt;asm&lt;/code&gt; statement unconditionally transfers control out of the function, control never reaches the end of the function body. The &lt;code&gt;__builtin_unreachable&lt;/code&gt; is in fact unreachable and communicates this fact to the compiler.</source>
          <target state="translated">因为 &lt;code&gt;asm&lt;/code&gt; 语句无条件地将控制权转移到函数之外，所以控制权永远不会到达函数体的末尾。该 &lt;code&gt;__builtin_unreachable&lt;/code&gt; 其实可达并将该事实编译器。</target>
        </trans-unit>
        <trans-unit id="a314cc1449bd666eda6884b69e668c28f95c1087" translate="yes" xml:space="preserve">
          <source>Before you can use this option, you must first generate profiling information. See &lt;a href=&quot;instrumentation-options#Instrumentation-Options&quot;&gt;Instrumentation Options&lt;/a&gt;, for information about the</source>
          <target state="translated">使用此选项之前，必须首先生成分析信息。有关的信息，请参见&lt;a href=&quot;instrumentation-options#Instrumentation-Options&quot;&gt;工具选项&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5ba07a31df23960760847e555518779312499558" translate="yes" xml:space="preserve">
          <source>Below</source>
          <target state="translated">Below</target>
        </trans-unit>
        <trans-unit id="5788148d39b8d5244dcdc29f7a93a22a6334768d" translate="yes" xml:space="preserve">
          <source>Besides declarations, the file indicates, in comments, the origin of each declaration (source file and line), whether the declaration was implicit, prototyped or unprototyped (&amp;lsquo;</source>
          <target state="translated">除声明外，该文件还在注释中指出每个声明的来源（源文件和行），无论该声明是隐式，原型还是非原型（'</target>
        </trans-unit>
        <trans-unit id="51eccbcd60621399284c614907bba67ce4fca17c" translate="yes" xml:space="preserve">
          <source>Beware that on some ELF systems this attribute is unsuitable for global functions in shared libraries with lazy binding (which is the default). Lazy binding sends the first call via resolving code in the loader, which might assume EAX, EDX and ECX can be clobbered, as per the standard calling conventions. Solaris 8 is affected by this. Systems with the GNU C Library version 2.1 or higher and FreeBSD are believed to be safe since the loaders there save EAX, EDX and ECX. (Lazy binding can be disabled with the linker or the loader if desired, to avoid the problem.)</source>
          <target state="translated">要注意的是,在某些ELF系统中,这个属性不适合使用懒惰绑定(默认)的共享库中的全局函数。懒惰绑定会通过加载器中的解析代码发送第一次调用,这可能会假设 EAX、EDX 和 ECX 可以被 clobbered,按照标准调用惯例。Solaris 8 受此影响。使用 GNU C 库 2.1 或更高版本的系统和 FreeBSD 被认为是安全的,因为那里的加载器会保存 EAX、EDX 和 ECX。(如果需要的话,可以通过链接器或加载器禁用懒惰绑定,以避免这个问题。)</target>
        </trans-unit>
        <trans-unit id="2c5d61cd9cd2849c270a6af03ebe1306ad2048ca" translate="yes" xml:space="preserve">
          <source>Binary Compatibility</source>
          <target state="translated">二进制兼容性</target>
        </trans-unit>
        <trans-unit id="8668d27514898ff49d03fb634b072fd0aba7e0f7" translate="yes" xml:space="preserve">
          <source>Binary arithmetic operations.</source>
          <target state="translated">二进制算术运算。</target>
        </trans-unit>
        <trans-unit id="18e9b92cdcd75a69e0946923d3da4f8d0a7fd71d" translate="yes" xml:space="preserve">
          <source>Binary compatibility encompasses several related concepts:</source>
          <target state="translated">二进制兼容性包含了几个相关的概念。</target>
        </trans-unit>
        <trans-unit id="f8ed98dae9970ec4cee447405cb8c658f46ef706" translate="yes" xml:space="preserve">
          <source>Binary constants using the &amp;lsquo;</source>
          <target state="translated">使用'</target>
        </trans-unit>
        <trans-unit id="666bffac0affe44914b807024f7928a6d6ca6941" translate="yes" xml:space="preserve">
          <source>Bind references to global symbols when building a shared object. Warn about any unresolved references (unless overridden by the link editor option</source>
          <target state="translated">构建共享对象时,将引用绑定到全局符号。对任何未解决的引用发出警告(除非被链接编辑器选项覆盖</target>
        </trans-unit>
        <trans-unit id="628682c1112ff8669d8fed436fe1daac74760ad6" translate="yes" xml:space="preserve">
          <source>Bit reversal. Return the result of reversing the bits in &lt;var&gt;value&lt;/var&gt;. Bit 15 is swapped with bit 0, bit 14 is swapped with bit 1, and so on.</source>
          <target state="translated">位反转。返回反转 &lt;var&gt;value&lt;/var&gt; 中的位的结果。位15与位0交换，位14与位1交换，依此类推。</target>
        </trans-unit>
        <trans-unit id="2eb3706f981c5da19b9c626f35ee7ccc246608e1" translate="yes" xml:space="preserve">
          <source>Bitwise operators act on the representation of the value including both the sign and value bits, where the sign bit is considered immediately above the highest-value value bit. Signed &amp;lsquo;</source>
          <target state="translated">按位运算符作用于包括符号位和值位的值的表示形式，其中符号位被认为紧邻最高值位。签 '</target>
        </trans-unit>
        <trans-unit id="8b063c3045af1663a8359f63f1ffd9a1d853789c" translate="yes" xml:space="preserve">
          <source>Blackfin family&amp;mdash;</source>
          <target state="translated">Blackfin家族&amp;mdash;</target>
        </trans-unit>
        <trans-unit id="0daa776b5dad37eac562c1bddec1cfa040024e9a" translate="yes" xml:space="preserve">
          <source>Borland C++ solved the template instantiation problem by adding the code equivalent of common blocks to their linker; the compiler emits template instances in each translation unit that uses them, and the linker collapses them together. The advantage of this model is that the linker only has to consider the object files themselves; there is no external complexity to worry about. The disadvantage is that compilation time is increased because the template code is being compiled repeatedly. Code written for this model tends to include definitions of all templates in the header file, since they must be seen to be instantiated.</source>
          <target state="translated">Borland C++通过在他们的链接器中加入相当于普通块的代码来解决模板实例化问题;编译器在每个使用它们的翻译单元中发出模板实例,链接器将它们折叠在一起。这种模式的优点是链接器只需要考虑对象文件本身,没有外部复杂性需要担心。缺点是编译时间会增加,因为模板代码会被重复编译。为这种模式编写的代码往往在头文件中包含所有模板的定义,因为必须看到它们被实例化。</target>
        </trans-unit>
        <trans-unit id="200e3a355b82a42f3341fd59904fc5750775b807" translate="yes" xml:space="preserve">
          <source>Borland model</source>
          <target state="translated">Borland模型</target>
        </trans-unit>
        <trans-unit id="06b22f59b253dcf9c37ea4fe24c6526c4dd1e47c" translate="yes" xml:space="preserve">
          <source>Both global and local variables can be associated with a register. The consequences of performing this association are very different between the two, as explained in the sections below.</source>
          <target state="translated">全局变量和局部变量都可以与寄存器进行关联。两者之间进行这种关联的后果是非常不同的,在下面的章节中会有解释。</target>
        </trans-unit>
        <trans-unit id="fc4416d6a83edb82efd0f4cdffd08c5cd70ca428" translate="yes" xml:space="preserve">
          <source>Bound on number of candidates for induction variables, below which all candidates are considered for each use in induction variable optimizations. If there are more candidates than this, only the most relevant ones are considered to avoid quadratic time complexity.</source>
          <target state="translated">归纳变量候选数的约束,低于此数的候选数在归纳变量优化中的每次使用都会被考虑。如果候选变量的数量多于此数,则只考虑最相关的候选变量,以避免二次元时间的复杂性。</target>
        </trans-unit>
        <trans-unit id="430f77e04bd4e8702495c79a5ebb639d2a4812c8" translate="yes" xml:space="preserve">
          <source>Bound on size of expressions used in the scalar evolutions analyzer. Large expressions slow the analyzer.</source>
          <target state="translated">对标量演化分析器中使用的表达式大小进行约束。大的表达式会减慢分析器的速度。</target>
        </trans-unit>
        <trans-unit id="f0e549afa5762802ff68ea72f123883ebb295578" translate="yes" xml:space="preserve">
          <source>Bound on the complexity of the expressions in the scalar evolutions analyzer. Complex expressions slow the analyzer.</source>
          <target state="translated">对标量演化分析器中表达式的复杂性进行约束。复杂的表达式会减慢分析器的速度。</target>
        </trans-unit>
        <trans-unit id="c2a6a8fa6e2e8a317cd5dd66c604413295e3eb45" translate="yes" xml:space="preserve">
          <source>Bound on the cost of an expression to compute the number of iterations.</source>
          <target state="translated">对计算迭代次数的表达式的成本进行约束。</target>
        </trans-unit>
        <trans-unit id="26981c43732b427e5b2eae3c3cb43a791d6ce820" translate="yes" xml:space="preserve">
          <source>Brain half-precision floating-point instructions. This also enables Advanced SIMD and floating-point instructions.</source>
          <target state="translated">脑半精度浮点指令。这也可以实现高级SIMD和浮点指令。</target>
        </trans-unit>
        <trans-unit id="ebb1b62c34f820227fd0537f593962386bf2cc61" translate="yes" xml:space="preserve">
          <source>Branch register</source>
          <target state="translated">分部登记册</target>
        </trans-unit>
        <trans-unit id="a833b9b5c7959a93636f56f73df394e8d3c434e8" translate="yes" xml:space="preserve">
          <source>Branches are present only with &lt;var&gt;-b&lt;/var&gt; option. Fields of the &lt;var&gt;line&lt;/var&gt; element have following semantics:</source>
          <target state="translated">仅在使用 &lt;var&gt;-b&lt;/var&gt; 选项时才存在分支。 &lt;var&gt;line&lt;/var&gt; 元素的字段具有以下语义：</target>
        </trans-unit>
        <trans-unit id="a6495e1aabddcd6526141ce6efe62824f5a7eae3" translate="yes" xml:space="preserve">
          <source>Brief list of all options, without explanations.</source>
          <target state="translated">所有选项的简要清单,不作解释。</target>
        </trans-unit>
        <trans-unit id="654ffe48f6054af226250c2aa3867b5fc4c80bcc" translate="yes" xml:space="preserve">
          <source>Bugs we will fix later.</source>
          <target state="translated">错误我们会在以后修复。</target>
        </trans-unit>
        <trans-unit id="de5bfe3fd9b6538bfa34acbeb7a505866d87ffce" translate="yes" xml:space="preserve">
          <source>Build a standalone application for Core A of BF561 when using the one-application-per-core programming model. Proper start files and link scripts are used to support Core A, and the macro &lt;code&gt;__BFIN_COREA&lt;/code&gt; is defined. This option can only be used in conjunction with</source>
          <target state="translated">使用每核一个应用程序编程模型时，为BF561的Core A构建一个独立的应用程序。正确的启动文件和链接脚本用于支持Core A，并定义了宏 &lt;code&gt;__BFIN_COREA&lt;/code&gt; 。此选项只能与</target>
        </trans-unit>
        <trans-unit id="6320906d93f259f860a69b97e3abeb20581c59d7" translate="yes" xml:space="preserve">
          <source>Build a standalone application for Core B of BF561 when using the one-application-per-core programming model. Proper start files and link scripts are used to support Core B, and the macro &lt;code&gt;__BFIN_COREB&lt;/code&gt; is defined. When this option is used, &lt;code&gt;coreb_main&lt;/code&gt; should be used instead of &lt;code&gt;main&lt;/code&gt;. This option can only be used in conjunction with</source>
          <target state="translated">使用每核一个应用程序编程模型时，为BF561的Core B构建一个独立的应用程序。正确的启动文件和链接脚本用于支持Core B，并定义了宏 &lt;code&gt;__BFIN_COREB&lt;/code&gt; 。使用此选项时，应使用 &lt;code&gt;coreb_main&lt;/code&gt; 而不是 &lt;code&gt;main&lt;/code&gt; 。此选项只能与</target>
        </trans-unit>
        <trans-unit id="e010c48c400b5b030ac052e6ece9a00978fee8f4" translate="yes" xml:space="preserve">
          <source>Build a standalone application for SDRAM. Proper start files and link scripts are used to put the application into SDRAM, and the macro &lt;code&gt;__BFIN_SDRAM&lt;/code&gt; is defined. The loader should initialize SDRAM before loading the application.</source>
          <target state="translated">为SDRAM构建一个独立的应用程序。正确的启动文件和链接脚本用于将应用程序放入SDRAM，并定义了宏 &lt;code&gt;__BFIN_SDRAM&lt;/code&gt; 。加载程序应在加载应用程序之前初始化SDRAM。</target>
        </trans-unit>
        <trans-unit id="93828509d9639cf155e61322b59daf0187eb136a" translate="yes" xml:space="preserve">
          <source>Build a standalone application for multicore Blackfin processors. This option causes proper start files and link scripts supporting multicore to be used, and defines the macro &lt;code&gt;__BFIN_MULTICORE&lt;/code&gt;. It can only be used with</source>
          <target state="translated">为多核Blackfin处理器构建一个独立的应用程序。该选项导致使用支持多核的正确的启动文件和链接脚本，并定义了宏 &lt;code&gt;__BFIN_MULTICORE&lt;/code&gt; 。它只能与</target>
        </trans-unit>
        <trans-unit id="f3ef0f891e9c255998243907e244b5b488c698cb" translate="yes" xml:space="preserve">
          <source>Build-in macro that resolves to a decimal number that identifies the architecture and depends on the</source>
          <target state="translated">内建宏,解析为标识架构的十进制数,并依赖于</target>
        </trans-unit>
        <trans-unit id="2d34970179e2bcbb0ecc79b090b87f98043678d3" translate="yes" xml:space="preserve">
          <source>Building data dependencies is expensive for very large loops. This parameter limits the number of data references in loops that are considered for data dependence analysis. These large loops are no handled by the optimizations using loop data dependencies.</source>
          <target state="translated">对于非常大的循环来说,建立数据依赖性是很昂贵的。这个参数限制了在数据依赖性分析中考虑的循环中数据引用的数量。使用循环数据依赖的优化不会处理这些大型循环。</target>
        </trans-unit>
        <trans-unit id="2d296efa2545fd43e5ab712c86bbcd120531a39c" translate="yes" xml:space="preserve">
          <source>Built-in Function:  &lt;strong id=&quot;index-_005f_005fbuiltin_005fva_005farg_005fpack&quot;&gt;__builtin_va_arg_pack&lt;/strong&gt; ()</source>
          <target state="translated">内置函数： &lt;strong id=&quot;index-_005f_005fbuiltin_005fva_005farg_005fpack&quot;&gt;__builtin_va_arg_pack&lt;/strong&gt;（）</target>
        </trans-unit>
        <trans-unit id="77cea55a1a3d5467f8414836cb770a0b2fa5b655" translate="yes" xml:space="preserve">
          <source>Built-in Function: &lt;var id=&quot;index-_005f_005fatomic_005fadd_005ffetch&quot;&gt;type&lt;/var&gt;&lt;strong&gt;__atomic_add_fetch&lt;/strong&gt; (&lt;var&gt;type&lt;/var&gt; *ptr, &lt;var&gt;type&lt;/var&gt; val, int memorder)</source>
          <target state="translated">内置功能： &lt;var id=&quot;index-_005f_005fatomic_005fadd_005ffetch&quot;&gt;type&lt;/var&gt; &lt;strong&gt;__atomic_add_fetch&lt;/strong&gt;（ &lt;var&gt;type&lt;/var&gt; * PTR， &lt;var&gt;type&lt;/var&gt; 缬氨酸，INT memorder）</target>
        </trans-unit>
        <trans-unit id="65f1c3be3667c2fa06bb169c518b6d4d03675142" translate="yes" xml:space="preserve">
          <source>Built-in Function: &lt;var id=&quot;index-_005f_005fatomic_005fand_005ffetch&quot;&gt;type&lt;/var&gt;&lt;strong&gt;__atomic_and_fetch&lt;/strong&gt; (&lt;var&gt;type&lt;/var&gt; *ptr, &lt;var&gt;type&lt;/var&gt; val, int memorder)</source>
          <target state="translated">内置功能： &lt;var id=&quot;index-_005f_005fatomic_005fand_005ffetch&quot;&gt;type&lt;/var&gt; &lt;strong&gt;__atomic_and_fetch&lt;/strong&gt;（ &lt;var&gt;type&lt;/var&gt; * PTR， &lt;var&gt;type&lt;/var&gt; 缬氨酸，INT memorder）</target>
        </trans-unit>
        <trans-unit id="a03055a0cd281ae02bbb4f07ca3c585700a7af0b" translate="yes" xml:space="preserve">
          <source>Built-in Function: &lt;var id=&quot;index-_005f_005fatomic_005fexchange_005fn&quot;&gt;type&lt;/var&gt;&lt;strong&gt;__atomic_exchange_n&lt;/strong&gt; (&lt;var&gt;type&lt;/var&gt; *ptr, &lt;var&gt;type&lt;/var&gt; val, int memorder)</source>
          <target state="translated">内置功能： &lt;var id=&quot;index-_005f_005fatomic_005fexchange_005fn&quot;&gt;type&lt;/var&gt; &lt;strong&gt;__atomic_exchange_n&lt;/strong&gt;（ &lt;var&gt;type&lt;/var&gt; * PTR， &lt;var&gt;type&lt;/var&gt; 缬氨酸，INT memorder）</target>
        </trans-unit>
        <trans-unit id="6eb648ab26ef838877bc3cc4ee57b8ff3c3ec10d" translate="yes" xml:space="preserve">
          <source>Built-in Function: &lt;var id=&quot;index-_005f_005fatomic_005ffetch_005fadd&quot;&gt;type&lt;/var&gt;&lt;strong&gt;__atomic_fetch_add&lt;/strong&gt; (&lt;var&gt;type&lt;/var&gt; *ptr, &lt;var&gt;type&lt;/var&gt; val, int memorder)</source>
          <target state="translated">内置功能： &lt;var id=&quot;index-_005f_005fatomic_005ffetch_005fadd&quot;&gt;type&lt;/var&gt; &lt;strong&gt;__atomic_fetch_add&lt;/strong&gt;（ &lt;var&gt;type&lt;/var&gt; * PTR， &lt;var&gt;type&lt;/var&gt; 缬氨酸，INT memorder）</target>
        </trans-unit>
        <trans-unit id="caf737dd7d0b652a623f88bdd6fd64fcd63596e4" translate="yes" xml:space="preserve">
          <source>Built-in Function: &lt;var id=&quot;index-_005f_005fatomic_005ffetch_005fand&quot;&gt;type&lt;/var&gt;&lt;strong&gt;__atomic_fetch_and&lt;/strong&gt; (&lt;var&gt;type&lt;/var&gt; *ptr, &lt;var&gt;type&lt;/var&gt; val, int memorder)</source>
          <target state="translated">内置函数： &lt;var id=&quot;index-_005f_005fatomic_005ffetch_005fand&quot;&gt;type&lt;/var&gt; &lt;strong&gt;__atomic_fetch_and&lt;/strong&gt;（ &lt;var&gt;type&lt;/var&gt; * ptr， &lt;var&gt;type&lt;/var&gt; val，int内存）</target>
        </trans-unit>
        <trans-unit id="f9b1604908ceaddf5e7b79ba9db81f0f1c23485e" translate="yes" xml:space="preserve">
          <source>Built-in Function: &lt;var id=&quot;index-_005f_005fatomic_005ffetch_005fnand&quot;&gt;type&lt;/var&gt;&lt;strong&gt;__atomic_fetch_nand&lt;/strong&gt; (&lt;var&gt;type&lt;/var&gt; *ptr, &lt;var&gt;type&lt;/var&gt; val, int memorder)</source>
          <target state="translated">内置函数： &lt;var id=&quot;index-_005f_005fatomic_005ffetch_005fnand&quot;&gt;type&lt;/var&gt; &lt;strong&gt;__atomic_fetch_nand&lt;/strong&gt;（ &lt;var&gt;type&lt;/var&gt; * ptr， &lt;var&gt;type&lt;/var&gt; val，int内存）</target>
        </trans-unit>
        <trans-unit id="45f4365ebf0124211f5cb2705e77bd2bfd90775d" translate="yes" xml:space="preserve">
          <source>Built-in Function: &lt;var id=&quot;index-_005f_005fatomic_005ffetch_005for&quot;&gt;type&lt;/var&gt;&lt;strong&gt;__atomic_fetch_or&lt;/strong&gt; (&lt;var&gt;type&lt;/var&gt; *ptr, &lt;var&gt;type&lt;/var&gt; val, int memorder)</source>
          <target state="translated">内置功能： &lt;var id=&quot;index-_005f_005fatomic_005ffetch_005for&quot;&gt;type&lt;/var&gt; &lt;strong&gt;__atomic_fetch_or&lt;/strong&gt;（ &lt;var&gt;type&lt;/var&gt; * PTR， &lt;var&gt;type&lt;/var&gt; 缬氨酸，INT memorder）</target>
        </trans-unit>
        <trans-unit id="cf646256d882577bfba56a5678e5b9426274e60b" translate="yes" xml:space="preserve">
          <source>Built-in Function: &lt;var id=&quot;index-_005f_005fatomic_005ffetch_005fsub&quot;&gt;type&lt;/var&gt;&lt;strong&gt;__atomic_fetch_sub&lt;/strong&gt; (&lt;var&gt;type&lt;/var&gt; *ptr, &lt;var&gt;type&lt;/var&gt; val, int memorder)</source>
          <target state="translated">内置功能： &lt;var id=&quot;index-_005f_005fatomic_005ffetch_005fsub&quot;&gt;type&lt;/var&gt; &lt;strong&gt;__atomic_fetch_sub&lt;/strong&gt;（ &lt;var&gt;type&lt;/var&gt; * PTR， &lt;var&gt;type&lt;/var&gt; 缬氨酸，INT memorder）</target>
        </trans-unit>
        <trans-unit id="5041b1cf8f3a6577d287aff4388265cba990c15b" translate="yes" xml:space="preserve">
          <source>Built-in Function: &lt;var id=&quot;index-_005f_005fatomic_005ffetch_005fxor&quot;&gt;type&lt;/var&gt;&lt;strong&gt;__atomic_fetch_xor&lt;/strong&gt; (&lt;var&gt;type&lt;/var&gt; *ptr, &lt;var&gt;type&lt;/var&gt; val, int memorder)</source>
          <target state="translated">内置功能： &lt;var id=&quot;index-_005f_005fatomic_005ffetch_005fxor&quot;&gt;type&lt;/var&gt; &lt;strong&gt;__atomic_fetch_xor&lt;/strong&gt;（ &lt;var&gt;type&lt;/var&gt; * PTR， &lt;var&gt;type&lt;/var&gt; 缬氨酸，INT memorder）</target>
        </trans-unit>
        <trans-unit id="75268ab0697eb9af1dc5c6b541d4d1ba8ac4dbf6" translate="yes" xml:space="preserve">
          <source>Built-in Function: &lt;var id=&quot;index-_005f_005fatomic_005fload_005fn&quot;&gt;type&lt;/var&gt;&lt;strong&gt;__atomic_load_n&lt;/strong&gt; (&lt;var&gt;type&lt;/var&gt; *ptr, int memorder)</source>
          <target state="translated">内置函数： &lt;var id=&quot;index-_005f_005fatomic_005fload_005fn&quot;&gt;type&lt;/var&gt; &lt;strong&gt;__atomic_load_n&lt;/strong&gt;（ &lt;var&gt;type&lt;/var&gt; * ptr，int内存）</target>
        </trans-unit>
        <trans-unit id="cd00e4ef24b741036ea643da78829d2849f8f8d7" translate="yes" xml:space="preserve">
          <source>Built-in Function: &lt;var id=&quot;index-_005f_005fatomic_005fnand_005ffetch&quot;&gt;type&lt;/var&gt;&lt;strong&gt;__atomic_nand_fetch&lt;/strong&gt; (&lt;var&gt;type&lt;/var&gt; *ptr, &lt;var&gt;type&lt;/var&gt; val, int memorder)</source>
          <target state="translated">内置功能： &lt;var id=&quot;index-_005f_005fatomic_005fnand_005ffetch&quot;&gt;type&lt;/var&gt; &lt;strong&gt;__atomic_nand_fetch&lt;/strong&gt;（ &lt;var&gt;type&lt;/var&gt; * PTR， &lt;var&gt;type&lt;/var&gt; 缬氨酸，INT memorder）</target>
        </trans-unit>
        <trans-unit id="a4657eb44924236cf67282c47ad4d932f5594137" translate="yes" xml:space="preserve">
          <source>Built-in Function: &lt;var id=&quot;index-_005f_005fatomic_005for_005ffetch&quot;&gt;type&lt;/var&gt;&lt;strong&gt;__atomic_or_fetch&lt;/strong&gt; (&lt;var&gt;type&lt;/var&gt; *ptr, &lt;var&gt;type&lt;/var&gt; val, int memorder)</source>
          <target state="translated">内置功能： &lt;var id=&quot;index-_005f_005fatomic_005for_005ffetch&quot;&gt;type&lt;/var&gt; &lt;strong&gt;__atomic_or_fetch&lt;/strong&gt;（ &lt;var&gt;type&lt;/var&gt; * PTR， &lt;var&gt;type&lt;/var&gt; 缬氨酸，INT memorder）</target>
        </trans-unit>
        <trans-unit id="57b4ecf7d291340ab5ae6cc114b7f02d58e8a705" translate="yes" xml:space="preserve">
          <source>Built-in Function: &lt;var id=&quot;index-_005f_005fatomic_005fsub_005ffetch&quot;&gt;type&lt;/var&gt;&lt;strong&gt;__atomic_sub_fetch&lt;/strong&gt; (&lt;var&gt;type&lt;/var&gt; *ptr, &lt;var&gt;type&lt;/var&gt; val, int memorder)</source>
          <target state="translated">内置功能： &lt;var id=&quot;index-_005f_005fatomic_005fsub_005ffetch&quot;&gt;type&lt;/var&gt; &lt;strong&gt;__atomic_sub_fetch&lt;/strong&gt;（ &lt;var&gt;type&lt;/var&gt; * PTR， &lt;var&gt;type&lt;/var&gt; 缬氨酸，INT memorder）</target>
        </trans-unit>
        <trans-unit id="a52f64419e32735eabc4e3c18aa68dedfb2e4625" translate="yes" xml:space="preserve">
          <source>Built-in Function: &lt;var id=&quot;index-_005f_005fatomic_005fxor_005ffetch&quot;&gt;type&lt;/var&gt;&lt;strong&gt;__atomic_xor_fetch&lt;/strong&gt; (&lt;var&gt;type&lt;/var&gt; *ptr, &lt;var&gt;type&lt;/var&gt; val, int memorder)</source>
          <target state="translated">内置功能： &lt;var id=&quot;index-_005f_005fatomic_005fxor_005ffetch&quot;&gt;type&lt;/var&gt; &lt;strong&gt;__atomic_xor_fetch&lt;/strong&gt;（ &lt;var&gt;type&lt;/var&gt; * PTR， &lt;var&gt;type&lt;/var&gt; 缬氨酸，INT memorder）</target>
        </trans-unit>
        <trans-unit id="1167cb7b44d7d9f620598ea0aefcbfdf9dc55a1f" translate="yes" xml:space="preserve">
          <source>Built-in Function: &lt;var id=&quot;index-_005f_005fbuiltin_005fcall_005fwith_005fstatic_005fchain-1&quot;&gt;type&lt;/var&gt;&lt;strong&gt;__builtin_call_with_static_chain&lt;/strong&gt; (&lt;var&gt;call_exp&lt;/var&gt;, &lt;var&gt;pointer_exp&lt;/var&gt;)</source>
          <target state="translated">内置函数： &lt;var id=&quot;index-_005f_005fbuiltin_005fcall_005fwith_005fstatic_005fchain-1&quot;&gt;type&lt;/var&gt; &lt;strong&gt;__builtin_call_with_static_chain&lt;/strong&gt;（ &lt;var&gt;call_exp&lt;/var&gt; ， &lt;var&gt;pointer_exp&lt;/var&gt; ）</target>
        </trans-unit>
        <trans-unit id="34f799a7c8358da11b0de0991867b1ca62dd416b" translate="yes" xml:space="preserve">
          <source>Built-in Function: &lt;var id=&quot;index-_005f_005fbuiltin_005fchoose_005fexpr&quot;&gt;type&lt;/var&gt;&lt;strong&gt;__builtin_choose_expr&lt;/strong&gt; (&lt;var&gt;const_exp&lt;/var&gt;, &lt;var&gt;exp1&lt;/var&gt;, &lt;var&gt;exp2&lt;/var&gt;)</source>
          <target state="translated">内置函数： &lt;var id=&quot;index-_005f_005fbuiltin_005fchoose_005fexpr&quot;&gt;type&lt;/var&gt; &lt;strong&gt;__builtin_choose_expr&lt;/strong&gt;（ &lt;var&gt;const_exp&lt;/var&gt; ， &lt;var&gt;exp1&lt;/var&gt; ， &lt;var&gt;exp2&lt;/var&gt; ）</target>
        </trans-unit>
        <trans-unit id="11e363a3b892d8f6c1c1fdfdd845f80862a3606b" translate="yes" xml:space="preserve">
          <source>Built-in Function: &lt;var id=&quot;index-_005f_005fbuiltin_005fcomplex&quot;&gt;type&lt;/var&gt;&lt;strong&gt;__builtin_complex&lt;/strong&gt; (&lt;var&gt;real&lt;/var&gt;, &lt;var&gt;imag&lt;/var&gt;)</source>
          <target state="translated">内置函数： &lt;var id=&quot;index-_005f_005fbuiltin_005fcomplex&quot;&gt;type&lt;/var&gt; &lt;strong&gt;__builtin_complex&lt;/strong&gt;（ &lt;var&gt;real&lt;/var&gt; ， &lt;var&gt;imag&lt;/var&gt; ）</target>
        </trans-unit>
        <trans-unit id="9eec0865162048e6dccab85fb3d740aa5f07fc05" translate="yes" xml:space="preserve">
          <source>Built-in Function: &lt;var id=&quot;index-_005f_005fbuiltin_005fspeculation_005fsafe_005fvalue-1&quot;&gt;type&lt;/var&gt;&lt;strong&gt;__builtin_speculation_safe_value&lt;/strong&gt; (&lt;var&gt;type&lt;/var&gt; val, &lt;var&gt;type&lt;/var&gt; failval)</source>
          <target state="translated">内置函数： &lt;var id=&quot;index-_005f_005fbuiltin_005fspeculation_005fsafe_005fvalue-1&quot;&gt;type&lt;/var&gt; &lt;strong&gt;__builtin_speculation_safe_value&lt;/strong&gt;（ &lt;var&gt;type&lt;/var&gt; val， &lt;var&gt;type&lt;/var&gt; failval）</target>
        </trans-unit>
        <trans-unit id="7c5c7616bd765dd4fc8d843ce99908ad16336f51" translate="yes" xml:space="preserve">
          <source>Built-in Function: &lt;var id=&quot;index-_005f_005fbuiltin_005ftgmath&quot;&gt;type&lt;/var&gt;&lt;strong&gt;__builtin_tgmath&lt;/strong&gt; (&lt;var&gt;functions&lt;/var&gt;, &lt;var&gt;arguments&lt;/var&gt;)</source>
          <target state="translated">内置函数： &lt;var id=&quot;index-_005f_005fbuiltin_005ftgmath&quot;&gt;type&lt;/var&gt; &lt;strong&gt;__builtin_tgmath&lt;/strong&gt;（ &lt;var&gt;functions&lt;/var&gt; ， &lt;var&gt;arguments&lt;/var&gt; ）</target>
        </trans-unit>
        <trans-unit id="e3600affbf40f82a1f599528ce0f72402f629874" translate="yes" xml:space="preserve">
          <source>Built-in Function: Pmode &lt;strong id=&quot;index-_005f_005fbuiltin_005fextend_005fpointer-1&quot;&gt;__builtin_extend_pointer&lt;/strong&gt; (void * x)</source>
          <target state="translated">内置函数：Pmode &lt;strong id=&quot;index-_005f_005fbuiltin_005fextend_005fpointer-1&quot;&gt;__builtin_extend_pointer&lt;/strong&gt;（void * x）</target>
        </trans-unit>
        <trans-unit id="b7ca6e3021fea0b720388d29d28e89de6177efaa" translate="yes" xml:space="preserve">
          <source>Built-in Function: _Decimal128 &lt;strong id=&quot;index-_005f_005fbuiltin_005finfd128&quot;&gt;__builtin_infd128&lt;/strong&gt; (void)</source>
          <target state="translated">内置函数：_Decimal128 &lt;strong id=&quot;index-_005f_005fbuiltin_005finfd128&quot;&gt;__builtin_infd128&lt;/strong&gt;（void）</target>
        </trans-unit>
        <trans-unit id="bf8fbba0296cd046f79b2f8fac454e9f96b680c3" translate="yes" xml:space="preserve">
          <source>Built-in Function: _Decimal128 &lt;strong id=&quot;index-_005f_005fbuiltin_005fnand128&quot;&gt;__builtin_nand128&lt;/strong&gt; (const char *str)</source>
          <target state="translated">内置函数：_Decimal128 &lt;strong id=&quot;index-_005f_005fbuiltin_005fnand128&quot;&gt;__builtin_nand128&lt;/strong&gt;（const char * str）</target>
        </trans-unit>
        <trans-unit id="ad3f5c8f497e0e257636ccbaf6459ad1ad8e6479" translate="yes" xml:space="preserve">
          <source>Built-in Function: _Decimal32 &lt;strong id=&quot;index-_005f_005fbuiltin_005finfd32&quot;&gt;__builtin_infd32&lt;/strong&gt; (void)</source>
          <target state="translated">内置函数：_Decimal32 &lt;strong id=&quot;index-_005f_005fbuiltin_005finfd32&quot;&gt;__builtin_infd32&lt;/strong&gt;（无效）</target>
        </trans-unit>
        <trans-unit id="2d12b2517571e9887a8920d94ebf233b53b0d3e9" translate="yes" xml:space="preserve">
          <source>Built-in Function: _Decimal32 &lt;strong id=&quot;index-_005f_005fbuiltin_005fnand32&quot;&gt;__builtin_nand32&lt;/strong&gt; (const char *str)</source>
          <target state="translated">内置函数：_Decimal32 &lt;strong id=&quot;index-_005f_005fbuiltin_005fnand32&quot;&gt;__builtin_nand32&lt;/strong&gt;（const char * str）</target>
        </trans-unit>
        <trans-unit id="c4f59dbda6a0f6f12e013b7d8146bb95b52fddbf" translate="yes" xml:space="preserve">
          <source>Built-in Function: _Decimal64 &lt;strong id=&quot;index-_005f_005fbuiltin_005finfd64&quot;&gt;__builtin_infd64&lt;/strong&gt; (void)</source>
          <target state="translated">内置函数：_Decimal64 &lt;strong id=&quot;index-_005f_005fbuiltin_005finfd64&quot;&gt;__builtin_infd64&lt;/strong&gt;（无效）</target>
        </trans-unit>
        <trans-unit id="dcf12c95c5e2671a78a61f716ad8c91e6ab3dca2" translate="yes" xml:space="preserve">
          <source>Built-in Function: _Decimal64 &lt;strong id=&quot;index-_005f_005fbuiltin_005fnand64&quot;&gt;__builtin_nand64&lt;/strong&gt; (const char *str)</source>
          <target state="translated">内置函数：_Decimal64 &lt;strong id=&quot;index-_005f_005fbuiltin_005fnand64&quot;&gt;__builtin_nand64&lt;/strong&gt;（const char * str）</target>
        </trans-unit>
        <trans-unit id="e065d1bdd11d40eb46afaa76c7e3c275e0e7c656" translate="yes" xml:space="preserve">
          <source>Built-in Function: _Float&lt;var id=&quot;index-_005f_005fbuiltin_005fhuge_005fvalfn&quot;&gt;n&lt;/var&gt;&lt;strong&gt;__builtin_huge_valf&lt;var&gt;n&lt;/var&gt;&lt;/strong&gt; (void)</source>
          <target state="translated">内置函数：_Float &lt;var id=&quot;index-_005f_005fbuiltin_005fhuge_005fvalfn&quot;&gt;n&lt;/var&gt; &lt;strong&gt;__builtin_huge_valf &lt;var&gt;n&lt;/var&gt; &lt;/strong&gt;（无效）</target>
        </trans-unit>
        <trans-unit id="bc1ad27f368302d827ffdedc2f161e1a34576916" translate="yes" xml:space="preserve">
          <source>Built-in Function: _Float&lt;var id=&quot;index-_005f_005fbuiltin_005fhuge_005fvalfnx&quot;&gt;n&lt;/var&gt;x &lt;strong&gt;__builtin_huge_valf&lt;var&gt;n&lt;/var&gt;x&lt;/strong&gt; (void)</source>
          <target state="translated">内置函数：_Float &lt;var id=&quot;index-_005f_005fbuiltin_005fhuge_005fvalfnx&quot;&gt;n&lt;/var&gt; x &lt;strong&gt;__builtin_huge_valf &lt;var&gt;n&lt;/var&gt; x&lt;/strong&gt;（无效）</target>
        </trans-unit>
        <trans-unit id="4f4a5dc00bc657abe7ad80938a7d60c8e79b5015" translate="yes" xml:space="preserve">
          <source>Built-in Function: _Float&lt;var id=&quot;index-_005f_005fbuiltin_005finffn&quot;&gt;n&lt;/var&gt;&lt;strong&gt;__builtin_inff&lt;var&gt;n&lt;/var&gt;&lt;/strong&gt; (void)</source>
          <target state="translated">内置函数：_Float &lt;var id=&quot;index-_005f_005fbuiltin_005finffn&quot;&gt;n&lt;/var&gt; &lt;strong&gt;__builtin_inff &lt;var&gt;n&lt;/var&gt; &lt;/strong&gt;（无效）</target>
        </trans-unit>
        <trans-unit id="28b60d24ae373b1240786dec7b198434f539e010" translate="yes" xml:space="preserve">
          <source>Built-in Function: _Float&lt;var id=&quot;index-_005f_005fbuiltin_005finffnx&quot;&gt;n&lt;/var&gt;&lt;strong&gt;__builtin_inff&lt;var&gt;n&lt;/var&gt;x&lt;/strong&gt; (void)</source>
          <target state="translated">内置函数：_Float &lt;var id=&quot;index-_005f_005fbuiltin_005finffnx&quot;&gt;n&lt;/var&gt; &lt;strong&gt;__builtin_inff &lt;var&gt;n&lt;/var&gt; x&lt;/strong&gt;（无效）</target>
        </trans-unit>
        <trans-unit id="bf9f5f175d78dc2baeeae0348c4b4da7826acad2" translate="yes" xml:space="preserve">
          <source>Built-in Function: _Float&lt;var id=&quot;index-_005f_005fbuiltin_005fnanfn&quot;&gt;n&lt;/var&gt;&lt;strong&gt;__builtin_nanf&lt;var&gt;n&lt;/var&gt;&lt;/strong&gt; (const char *str)</source>
          <target state="translated">内置函数：_Float &lt;var id=&quot;index-_005f_005fbuiltin_005fnanfn&quot;&gt;n&lt;/var&gt; &lt;strong&gt;__builtin_nanf &lt;var&gt;n&lt;/var&gt; &lt;/strong&gt;（const char * str）</target>
        </trans-unit>
        <trans-unit id="d8897a35cb1a3842c5a7b59ff4525f61eb36974a" translate="yes" xml:space="preserve">
          <source>Built-in Function: _Float&lt;var id=&quot;index-_005f_005fbuiltin_005fnanfnx&quot;&gt;n&lt;/var&gt;x &lt;strong&gt;__builtin_nanf&lt;var&gt;n&lt;/var&gt;x&lt;/strong&gt; (const char *str)</source>
          <target state="translated">内置函数：_Float &lt;var id=&quot;index-_005f_005fbuiltin_005fnanfnx&quot;&gt;n&lt;/var&gt; x &lt;strong&gt;__builtin_nanf &lt;var&gt;n&lt;/var&gt; x&lt;/strong&gt;（const char * str）</target>
        </trans-unit>
        <trans-unit id="1bd15fd91da1a9d9a87216c52e010f17bc3d22e6" translate="yes" xml:space="preserve">
          <source>Built-in Function: _Float&lt;var id=&quot;index-_005f_005fbuiltin_005fnansfn&quot;&gt;n&lt;/var&gt;&lt;strong&gt;__builtin_nansf&lt;var&gt;n&lt;/var&gt;&lt;/strong&gt; (const char *str)</source>
          <target state="translated">内置函数：_Float &lt;var id=&quot;index-_005f_005fbuiltin_005fnansfn&quot;&gt;n&lt;/var&gt; &lt;strong&gt;__builtin_nansf &lt;var&gt;n&lt;/var&gt; &lt;/strong&gt;（const char * str）</target>
        </trans-unit>
        <trans-unit id="615e03fdb9ea794729a2a1d7c358b1e301921c3b" translate="yes" xml:space="preserve">
          <source>Built-in Function: _Float&lt;var id=&quot;index-_005f_005fbuiltin_005fnansfnx&quot;&gt;n&lt;/var&gt;x &lt;strong&gt;__builtin_nansf&lt;var&gt;n&lt;/var&gt;x&lt;/strong&gt; (const char *str)</source>
          <target state="translated">内置函数：_Float &lt;var id=&quot;index-_005f_005fbuiltin_005fnansfnx&quot;&gt;n&lt;/var&gt; x &lt;strong&gt;__builtin_nansf &lt;var&gt;n&lt;/var&gt; x&lt;/strong&gt;（const char * str）</target>
        </trans-unit>
        <trans-unit id="f520d1247e2979f87ba6e5662e70795dbd438963" translate="yes" xml:space="preserve">
          <source>Built-in Function: bool &lt;strong id=&quot;index-_005f_005fatomic_005falways_005flock_005ffree&quot;&gt;__atomic_always_lock_free&lt;/strong&gt; (size_t size, void *ptr)</source>
          <target state="translated">内置函数：bool &lt;strong id=&quot;index-_005f_005fatomic_005falways_005flock_005ffree&quot;&gt;__atomic_always_lock_free&lt;/strong&gt;（size_t size，void * ptr）</target>
        </trans-unit>
        <trans-unit id="24b1fe88fa6197e2c0740249ab472fde949dc447" translate="yes" xml:space="preserve">
          <source>Built-in Function: bool &lt;strong id=&quot;index-_005f_005fatomic_005fcompare_005fexchange&quot;&gt;__atomic_compare_exchange&lt;/strong&gt; (&lt;var&gt;type&lt;/var&gt; *ptr, &lt;var&gt;type&lt;/var&gt; *expected, &lt;var&gt;type&lt;/var&gt; *desired, bool weak, int success_memorder, int failure_memorder)</source>
          <target state="translated">内置函数：bool &lt;strong id=&quot;index-_005f_005fatomic_005fcompare_005fexchange&quot;&gt;__atomic_compare_exchange&lt;/strong&gt;（ &lt;var&gt;type&lt;/var&gt; * ptr， &lt;var&gt;type&lt;/var&gt; * expected， &lt;var&gt;type&lt;/var&gt; * desired，布尔强度弱，int success_memorder，int failure_memorder）</target>
        </trans-unit>
        <trans-unit id="e0cae369ba572d6fc730f1208ec5ebfd8c31b5c9" translate="yes" xml:space="preserve">
          <source>Built-in Function: bool &lt;strong id=&quot;index-_005f_005fatomic_005fcompare_005fexchange_005fn&quot;&gt;__atomic_compare_exchange_n&lt;/strong&gt; (&lt;var&gt;type&lt;/var&gt; *ptr, &lt;var&gt;type&lt;/var&gt; *expected, &lt;var&gt;type&lt;/var&gt; desired, bool weak, int success_memorder, int failure_memorder)</source>
          <target state="translated">内置函数：bool &lt;strong id=&quot;index-_005f_005fatomic_005fcompare_005fexchange_005fn&quot;&gt;__atomic_compare_exchange_n&lt;/strong&gt;（ &lt;var&gt;type&lt;/var&gt; * ptr， &lt;var&gt;type&lt;/var&gt; * expected，所需 &lt;var&gt;type&lt;/var&gt; ，布尔值弱，int success_memorder，int failure_memorder）</target>
        </trans-unit>
        <trans-unit id="e6ff9b335ec817f16bd5f09bc44d64b4868726b1" translate="yes" xml:space="preserve">
          <source>Built-in Function: bool &lt;strong id=&quot;index-_005f_005fatomic_005fis_005flock_005ffree&quot;&gt;__atomic_is_lock_free&lt;/strong&gt; (size_t size, void *ptr)</source>
          <target state="translated">内置函数：bool &lt;strong id=&quot;index-_005f_005fatomic_005fis_005flock_005ffree&quot;&gt;__atomic_is_lock_free&lt;/strong&gt;（size_t size，void * ptr）</target>
        </trans-unit>
        <trans-unit id="24aee6114b477fd331dab8c2aef844fb97f49851" translate="yes" xml:space="preserve">
          <source>Built-in Function: bool &lt;strong id=&quot;index-_005f_005fatomic_005ftest_005fand_005fset&quot;&gt;__atomic_test_and_set&lt;/strong&gt; (void *ptr, int memorder)</source>
          <target state="translated">内置函数：bool &lt;strong id=&quot;index-_005f_005fatomic_005ftest_005fand_005fset&quot;&gt;__atomic_test_and_set&lt;/strong&gt;（void * ptr，int memorder）</target>
        </trans-unit>
        <trans-unit id="64b8a4ae04512641547c12a9c73d39675cb460a9" translate="yes" xml:space="preserve">
          <source>Built-in Function: bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fadd_005foverflow&quot;&gt;__builtin_add_overflow&lt;/strong&gt; (&lt;var&gt;type1&lt;/var&gt; a, &lt;var&gt;type2&lt;/var&gt; b, &lt;var&gt;type3&lt;/var&gt; *res)</source>
          <target state="translated">内置函数：bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fadd_005foverflow&quot;&gt;__builtin_add_overflow&lt;/strong&gt;（ &lt;var&gt;type1&lt;/var&gt; a， &lt;var&gt;type2&lt;/var&gt; b， &lt;var&gt;type3&lt;/var&gt; * res）</target>
        </trans-unit>
        <trans-unit id="af59554b89a8bf55a3dc48af48346f20f06e852a" translate="yes" xml:space="preserve">
          <source>Built-in Function: bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fadd_005foverflow_005fp&quot;&gt;__builtin_add_overflow_p&lt;/strong&gt; (&lt;var&gt;type1&lt;/var&gt; a, &lt;var&gt;type2&lt;/var&gt; b, &lt;var&gt;type3&lt;/var&gt; c)</source>
          <target state="translated">内置函数：bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fadd_005foverflow_005fp&quot;&gt;__builtin_add_overflow_p&lt;/strong&gt;（ &lt;var&gt;type1&lt;/var&gt; a， &lt;var&gt;type2&lt;/var&gt; b， &lt;var&gt;type3&lt;/var&gt; c）</target>
        </trans-unit>
        <trans-unit id="be98828c48e0d16aa6b6e2421edf84970dc86a6f" translate="yes" xml:space="preserve">
          <source>Built-in Function: bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fhas_005fattribute-1&quot;&gt;__builtin_has_attribute&lt;/strong&gt; (&lt;var&gt;type-or-expression&lt;/var&gt;, &lt;var&gt;attribute&lt;/var&gt;)</source>
          <target state="translated">内置函数：bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fhas_005fattribute-1&quot;&gt;__builtin_has_attribute&lt;/strong&gt;（ &lt;var&gt;type-or-expression&lt;/var&gt; ， &lt;var&gt;attribute&lt;/var&gt; ）</target>
        </trans-unit>
        <trans-unit id="b7e50b8a64da2b188793a4579bb5cae5cac82268" translate="yes" xml:space="preserve">
          <source>Built-in Function: bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fis_005fconstant_005fevaluated&quot;&gt;__builtin_is_constant_evaluated&lt;/strong&gt; (void)</source>
          <target state="translated">内置函数：bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fis_005fconstant_005fevaluated&quot;&gt;__builtin_is_constant_evaluated&lt;/strong&gt;（void）</target>
        </trans-unit>
        <trans-unit id="ee9d3aabacf2156e5d393cd93749ff7c8037d66e" translate="yes" xml:space="preserve">
          <source>Built-in Function: bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fmul_005foverflow&quot;&gt;__builtin_mul_overflow&lt;/strong&gt; (&lt;var&gt;type1&lt;/var&gt; a, &lt;var&gt;type2&lt;/var&gt; b, &lt;var&gt;type3&lt;/var&gt; *res)</source>
          <target state="translated">内置函数：bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fmul_005foverflow&quot;&gt;__builtin_mul_overflow&lt;/strong&gt;（ &lt;var&gt;type1&lt;/var&gt; a， &lt;var&gt;type2&lt;/var&gt; b， &lt;var&gt;type3&lt;/var&gt; * res）</target>
        </trans-unit>
        <trans-unit id="8fd735437fc9239fd342fe45001594bf9731cdde" translate="yes" xml:space="preserve">
          <source>Built-in Function: bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fmul_005foverflow_005fp&quot;&gt;__builtin_mul_overflow_p&lt;/strong&gt; (&lt;var&gt;type1&lt;/var&gt; a, &lt;var&gt;type2&lt;/var&gt; b, &lt;var&gt;type3&lt;/var&gt; c)</source>
          <target state="translated">内置函数：bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fmul_005foverflow_005fp&quot;&gt;__builtin_mul_overflow_p&lt;/strong&gt;（ &lt;var&gt;type1&lt;/var&gt; a， &lt;var&gt;type2&lt;/var&gt; b， &lt;var&gt;type3&lt;/var&gt; c）</target>
        </trans-unit>
        <trans-unit id="25ee4265411f06ce5b584d4448bc72ef70be2921" translate="yes" xml:space="preserve">
          <source>Built-in Function: bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fsadd_005foverflow&quot;&gt;__builtin_sadd_overflow&lt;/strong&gt; (int a, int b, int *res)</source>
          <target state="translated">内置函数：bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fsadd_005foverflow&quot;&gt;__builtin_sadd_overflow&lt;/strong&gt;（int a，int b，int * res）</target>
        </trans-unit>
        <trans-unit id="69472084a70d9c551110645ab2de32722f859a56" translate="yes" xml:space="preserve">
          <source>Built-in Function: bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fsaddl_005foverflow&quot;&gt;__builtin_saddl_overflow&lt;/strong&gt; (long int a, long int b, long int *res)</source>
          <target state="translated">内置函数：bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fsaddl_005foverflow&quot;&gt;__builtin_saddl_overflow&lt;/strong&gt;（长整数a，长整数b，长整数* res）</target>
        </trans-unit>
        <trans-unit id="d167da624174d67a584837afb39ffafce3529192" translate="yes" xml:space="preserve">
          <source>Built-in Function: bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fsaddll_005foverflow&quot;&gt;__builtin_saddll_overflow&lt;/strong&gt; (long long int a, long long int b, long long int *res)</source>
          <target state="translated">内置函数：bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fsaddll_005foverflow&quot;&gt;__builtin_saddll_overflow&lt;/strong&gt;（long long int a，long long int b，long long int * res）</target>
        </trans-unit>
        <trans-unit id="0751d990e1a6176428723a69b8b9d35eb80fd837" translate="yes" xml:space="preserve">
          <source>Built-in Function: bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fsmul_005foverflow&quot;&gt;__builtin_smul_overflow&lt;/strong&gt; (int a, int b, int *res)</source>
          <target state="translated">内置函数：bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fsmul_005foverflow&quot;&gt;__builtin_smul_overflow&lt;/strong&gt;（int a，int b，int * res）</target>
        </trans-unit>
        <trans-unit id="956b1e662b4c40d70010047e2d0274713e3963f3" translate="yes" xml:space="preserve">
          <source>Built-in Function: bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fsmull_005foverflow&quot;&gt;__builtin_smull_overflow&lt;/strong&gt; (long int a, long int b, long int *res)</source>
          <target state="translated">内置函数：bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fsmull_005foverflow&quot;&gt;__builtin_smull_overflow&lt;/strong&gt;（长整数a，长整数b，长整数* res）</target>
        </trans-unit>
        <trans-unit id="90b14c01667b17099ca43e693ecf1b190d3e0c9b" translate="yes" xml:space="preserve">
          <source>Built-in Function: bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fsmulll_005foverflow&quot;&gt;__builtin_smulll_overflow&lt;/strong&gt; (long long int a, long long int b, long long int *res)</source>
          <target state="translated">内置函数：bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fsmulll_005foverflow&quot;&gt;__builtin_smulll_overflow&lt;/strong&gt;（long long int a，long long int b，long long int * res）</target>
        </trans-unit>
        <trans-unit id="77b2f488874750806435b3aaff4f191420925191" translate="yes" xml:space="preserve">
          <source>Built-in Function: bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fssub_005foverflow&quot;&gt;__builtin_ssub_overflow&lt;/strong&gt; (int a, int b, int *res)</source>
          <target state="translated">内置函数：bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fssub_005foverflow&quot;&gt;__builtin_ssub_overflow&lt;/strong&gt;（int a，int b，int * res）</target>
        </trans-unit>
        <trans-unit id="49724eb9cf1b5f433d9a763058afdd03539a15c8" translate="yes" xml:space="preserve">
          <source>Built-in Function: bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fssubl_005foverflow&quot;&gt;__builtin_ssubl_overflow&lt;/strong&gt; (long int a, long int b, long int *res)</source>
          <target state="translated">内置函数：bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fssubl_005foverflow&quot;&gt;__builtin_ssubl_overflow&lt;/strong&gt;（长整数a，长整数b，长整数* res）</target>
        </trans-unit>
        <trans-unit id="8bb17f1956b296109f50ac2e4c7c8a50ec613924" translate="yes" xml:space="preserve">
          <source>Built-in Function: bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fssubll_005foverflow&quot;&gt;__builtin_ssubll_overflow&lt;/strong&gt; (long long int a, long long int b, long long int *res)</source>
          <target state="translated">内置函数：bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fssubll_005foverflow&quot;&gt;__builtin_ssubll_overflow&lt;/strong&gt;（long long int a，long long int b，long long int * res）</target>
        </trans-unit>
        <trans-unit id="3ca0d6297a605dc41e2b859a3577a44be6641a95" translate="yes" xml:space="preserve">
          <source>Built-in Function: bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fsub_005foverflow&quot;&gt;__builtin_sub_overflow&lt;/strong&gt; (&lt;var&gt;type1&lt;/var&gt; a, &lt;var&gt;type2&lt;/var&gt; b, &lt;var&gt;type3&lt;/var&gt; *res)</source>
          <target state="translated">内置函数：bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fsub_005foverflow&quot;&gt;__builtin_sub_overflow&lt;/strong&gt;（ &lt;var&gt;type1&lt;/var&gt; a， &lt;var&gt;type2&lt;/var&gt; b， &lt;var&gt;type3&lt;/var&gt; * res）</target>
        </trans-unit>
        <trans-unit id="cc3ccbf74e07a994d7fa1a99c72273b8a5afff58" translate="yes" xml:space="preserve">
          <source>Built-in Function: bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fsub_005foverflow_005fp&quot;&gt;__builtin_sub_overflow_p&lt;/strong&gt; (&lt;var&gt;type1&lt;/var&gt; a, &lt;var&gt;type2&lt;/var&gt; b, &lt;var&gt;type3&lt;/var&gt; c)</source>
          <target state="translated">内置函数：bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fsub_005foverflow_005fp&quot;&gt;__builtin_sub_overflow_p&lt;/strong&gt;（ &lt;var&gt;type1&lt;/var&gt; a， &lt;var&gt;type2&lt;/var&gt; b， &lt;var&gt;type3&lt;/var&gt; c）</target>
        </trans-unit>
        <trans-unit id="5b02b9649ef1800e43226f7e7109d8bbef8357dc" translate="yes" xml:space="preserve">
          <source>Built-in Function: bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fuadd_005foverflow&quot;&gt;__builtin_uadd_overflow&lt;/strong&gt; (unsigned int a, unsigned int b, unsigned int *res)</source>
          <target state="translated">内置函数：bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fuadd_005foverflow&quot;&gt;__builtin_uadd_overflow&lt;/strong&gt;（无符号整数a，无符号整数b，无符号整数* res）</target>
        </trans-unit>
        <trans-unit id="567411aa095944ed062923c573393ad7b9494fcc" translate="yes" xml:space="preserve">
          <source>Built-in Function: bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fuaddl_005foverflow&quot;&gt;__builtin_uaddl_overflow&lt;/strong&gt; (unsigned long int a, unsigned long int b, unsigned long int *res)</source>
          <target state="translated">内置函数：bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fuaddl_005foverflow&quot;&gt;__builtin_uaddl_overflow&lt;/strong&gt;（无符号长整数a，无符号长整数b，无符号长整数* res）</target>
        </trans-unit>
        <trans-unit id="a7d580478c24cd4b2a59ce2c1f75d3bbd1e01675" translate="yes" xml:space="preserve">
          <source>Built-in Function: bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fuaddll_005foverflow&quot;&gt;__builtin_uaddll_overflow&lt;/strong&gt; (unsigned long long int a, unsigned long long int b, unsigned long long int *res)</source>
          <target state="translated">内置函数：bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fuaddll_005foverflow&quot;&gt;__builtin_uaddll_overflow&lt;/strong&gt;（unsigned long long int a，unsigned long long int b，unsigned long long int * res）</target>
        </trans-unit>
        <trans-unit id="4df720b89a79aa504ee2325733fecf62f5d154df" translate="yes" xml:space="preserve">
          <source>Built-in Function: bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fumul_005foverflow&quot;&gt;__builtin_umul_overflow&lt;/strong&gt; (unsigned int a, unsigned int b, unsigned int *res)</source>
          <target state="translated">内置函数：bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fumul_005foverflow&quot;&gt;__builtin_umul_overflow&lt;/strong&gt;（无符号整数a，无符号整数b，无符号整数* res）</target>
        </trans-unit>
        <trans-unit id="127b7aa724932fc0c15543b161cf5ca336f40c65" translate="yes" xml:space="preserve">
          <source>Built-in Function: bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fumull_005foverflow&quot;&gt;__builtin_umull_overflow&lt;/strong&gt; (unsigned long int a, unsigned long int b, unsigned long int *res)</source>
          <target state="translated">内置函数：bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fumull_005foverflow&quot;&gt;__builtin_umull_overflow&lt;/strong&gt;（无符号长整数a，无符号长整数b，无符号长整数* res）</target>
        </trans-unit>
        <trans-unit id="6e0e5de085f1421cd056a7b7c2d1ac4593a791e8" translate="yes" xml:space="preserve">
          <source>Built-in Function: bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fumulll_005foverflow&quot;&gt;__builtin_umulll_overflow&lt;/strong&gt; (unsigned long long int a, unsigned long long int b, unsigned long long int *res)</source>
          <target state="translated">内置函数：bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fumulll_005foverflow&quot;&gt;__builtin_umulll_overflow&lt;/strong&gt;（unsigned long long int a，unsigned long long int b，unsigned long long int * res）</target>
        </trans-unit>
        <trans-unit id="43f0099aa9a654a142bfe318e5e28643d8ddc6f6" translate="yes" xml:space="preserve">
          <source>Built-in Function: bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fusub_005foverflow&quot;&gt;__builtin_usub_overflow&lt;/strong&gt; (unsigned int a, unsigned int b, unsigned int *res)</source>
          <target state="translated">内置函数：bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fusub_005foverflow&quot;&gt;__builtin_usub_overflow&lt;/strong&gt;（无符号整数a，无符号整数b，无符号整数* res）</target>
        </trans-unit>
        <trans-unit id="1c5542c5653c759c2ffcd0eb56e8e4fce2653611" translate="yes" xml:space="preserve">
          <source>Built-in Function: bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fusubl_005foverflow&quot;&gt;__builtin_usubl_overflow&lt;/strong&gt; (unsigned long int a, unsigned long int b, unsigned long int *res)</source>
          <target state="translated">内置函数：bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fusubl_005foverflow&quot;&gt;__builtin_usubl_overflow&lt;/strong&gt;（无符号长整数a，无符号长整数b，无符号长整数* res）</target>
        </trans-unit>
        <trans-unit id="8967205f7b6c405e734e918e4030fc20dcc7a6e8" translate="yes" xml:space="preserve">
          <source>Built-in Function: bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fusubll_005foverflow&quot;&gt;__builtin_usubll_overflow&lt;/strong&gt; (unsigned long long int a, unsigned long long int b, unsigned long long int *res)</source>
          <target state="translated">内置函数：bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fusubll_005foverflow&quot;&gt;__builtin_usubll_overflow&lt;/strong&gt;（无符号长整型a，无符号长整型b，无符号长整型* res）</target>
        </trans-unit>
        <trans-unit id="3d3ebe01d55449070f5b00bc45933b6ab0472f70" translate="yes" xml:space="preserve">
          <source>Built-in Function: const char * &lt;strong id=&quot;index-_005f_005fbuiltin_005fFILE&quot;&gt;__builtin_FILE&lt;/strong&gt; ()</source>
          <target state="translated">内置函数：const char * &lt;strong id=&quot;index-_005f_005fbuiltin_005fFILE&quot;&gt;__builtin_FILE&lt;/strong&gt;（）</target>
        </trans-unit>
        <trans-unit id="0721ec3a797458f28da3b2711e9fc2d2af1823e2" translate="yes" xml:space="preserve">
          <source>Built-in Function: const char * &lt;strong id=&quot;index-_005f_005fbuiltin_005fFUNCTION&quot;&gt;__builtin_FUNCTION&lt;/strong&gt; ()</source>
          <target state="translated">内置函数：const char * &lt;strong id=&quot;index-_005f_005fbuiltin_005fFUNCTION&quot;&gt;__builtin_FUNCTION&lt;/strong&gt;（）</target>
        </trans-unit>
        <trans-unit id="2a1712d1ad359c0cac12cd7a3537116bd9e795fc" translate="yes" xml:space="preserve">
          <source>Built-in Function: double &lt;strong id=&quot;index-_005f_005fbuiltin_005fhuge_005fval&quot;&gt;__builtin_huge_val&lt;/strong&gt; (void)</source>
          <target state="translated">内置函数：double &lt;strong id=&quot;index-_005f_005fbuiltin_005fhuge_005fval&quot;&gt;__builtin_huge_val&lt;/strong&gt;（void）</target>
        </trans-unit>
        <trans-unit id="ffafe4d74af74fb9ca60ea9821704b751632b93c" translate="yes" xml:space="preserve">
          <source>Built-in Function: double &lt;strong id=&quot;index-_005f_005fbuiltin_005finf&quot;&gt;__builtin_inf&lt;/strong&gt; (void)</source>
          <target state="translated">内置函数：double &lt;strong id=&quot;index-_005f_005fbuiltin_005finf&quot;&gt;__builtin_inf&lt;/strong&gt;（void）</target>
        </trans-unit>
        <trans-unit id="2864a0d09a57cc7f91ca4ff8697942e0585349f6" translate="yes" xml:space="preserve">
          <source>Built-in Function: double &lt;strong id=&quot;index-_005f_005fbuiltin_005fnan&quot;&gt;__builtin_nan&lt;/strong&gt; (const char *str)</source>
          <target state="translated">内置函数：double &lt;strong id=&quot;index-_005f_005fbuiltin_005fnan&quot;&gt;__builtin_nan&lt;/strong&gt;（const char * str）</target>
        </trans-unit>
        <trans-unit id="51bc6d3e017f472618e17d8b483f22c00009407c" translate="yes" xml:space="preserve">
          <source>Built-in Function: double &lt;strong id=&quot;index-_005f_005fbuiltin_005fnans&quot;&gt;__builtin_nans&lt;/strong&gt; (const char *str)</source>
          <target state="translated">内置函数：double &lt;strong id=&quot;index-_005f_005fbuiltin_005fnans&quot;&gt;__builtin_nans&lt;/strong&gt;（const char * str）</target>
        </trans-unit>
        <trans-unit id="b40603712a54f648b2195d490214834e3f8465f8" translate="yes" xml:space="preserve">
          <source>Built-in Function: double &lt;strong id=&quot;index-_005f_005fbuiltin_005fpowi-1&quot;&gt;__builtin_powi&lt;/strong&gt; (double, int)</source>
          <target state="translated">内置函数：double &lt;strong id=&quot;index-_005f_005fbuiltin_005fpowi-1&quot;&gt;__builtin_powi&lt;/strong&gt;（double，int）</target>
        </trans-unit>
        <trans-unit id="37264a6694867df8b96fcd2a07266108a13c8c2e" translate="yes" xml:space="preserve">
          <source>Built-in Function: float &lt;strong id=&quot;index-_005f_005fbuiltin_005fhuge_005fvalf&quot;&gt;__builtin_huge_valf&lt;/strong&gt; (void)</source>
          <target state="translated">内置函数：float &lt;strong id=&quot;index-_005f_005fbuiltin_005fhuge_005fvalf&quot;&gt;__builtin_huge_valf&lt;/strong&gt;（void）</target>
        </trans-unit>
        <trans-unit id="605b7b7bd5e72cf972739ddb673591e051dadcd8" translate="yes" xml:space="preserve">
          <source>Built-in Function: float &lt;strong id=&quot;index-_005f_005fbuiltin_005finff&quot;&gt;__builtin_inff&lt;/strong&gt; (void)</source>
          <target state="translated">内置函数：float &lt;strong id=&quot;index-_005f_005fbuiltin_005finff&quot;&gt;__builtin_inff&lt;/strong&gt;（void）</target>
        </trans-unit>
        <trans-unit id="a84c6b7adfcd7dc51b670ecde42ed816377e7198" translate="yes" xml:space="preserve">
          <source>Built-in Function: float &lt;strong id=&quot;index-_005f_005fbuiltin_005fnanf&quot;&gt;__builtin_nanf&lt;/strong&gt; (const char *str)</source>
          <target state="translated">内置函数：float &lt;strong id=&quot;index-_005f_005fbuiltin_005fnanf&quot;&gt;__builtin_nanf&lt;/strong&gt;（const char * str）</target>
        </trans-unit>
        <trans-unit id="ae6f3577a561b5595beef7b2c40d9183bbecdc53" translate="yes" xml:space="preserve">
          <source>Built-in Function: float &lt;strong id=&quot;index-_005f_005fbuiltin_005fnansf&quot;&gt;__builtin_nansf&lt;/strong&gt; (const char *str)</source>
          <target state="translated">内置函数：float &lt;strong id=&quot;index-_005f_005fbuiltin_005fnansf&quot;&gt;__builtin_nansf&lt;/strong&gt;（const char * str）</target>
        </trans-unit>
        <trans-unit id="a17547d96b5dcfda1585e7b927ed2efd4413b34e" translate="yes" xml:space="preserve">
          <source>Built-in Function: float &lt;strong id=&quot;index-_005f_005fbuiltin_005fpowif-1&quot;&gt;__builtin_powif&lt;/strong&gt; (float, int)</source>
          <target state="translated">内置函数：float &lt;strong id=&quot;index-_005f_005fbuiltin_005fpowif-1&quot;&gt;__builtin_powif&lt;/strong&gt;（float，int）</target>
        </trans-unit>
        <trans-unit id="5af70608a64ebe69db59d9a08864316c44173d0e" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005fLINE&quot;&gt;__builtin_LINE&lt;/strong&gt; ()</source>
          <target state="translated">内置函数：int &lt;strong id=&quot;index-_005f_005fbuiltin_005fLINE&quot;&gt;__builtin_LINE&lt;/strong&gt;（）</target>
        </trans-unit>
        <trans-unit id="48642fe0ecb713fe1c2c62aceb4756a077c1f773" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005farc_005faligned&quot;&gt;__builtin_arc_aligned&lt;/strong&gt; (void *&lt;var&gt;val&lt;/var&gt;, int &lt;var&gt;alignval&lt;/var&gt;)</source>
          <target state="translated">内置函数：int &lt;strong id=&quot;index-_005f_005fbuiltin_005farc_005faligned&quot;&gt;__builtin_arc_aligned&lt;/strong&gt;（void * &lt;var&gt;val&lt;/var&gt; ，int &lt;var&gt;alignval&lt;/var&gt; ）</target>
        </trans-unit>
        <trans-unit id="d03ad02fdd87a3d6c105f1b3776333e8f10a10d5" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005farc_005fdivaw&quot;&gt;__builtin_arc_divaw&lt;/strong&gt; (int &lt;var&gt;a&lt;/var&gt;, int &lt;var&gt;b&lt;/var&gt;)</source>
          <target state="translated">内置函数：int &lt;strong id=&quot;index-_005f_005fbuiltin_005farc_005fdivaw&quot;&gt;__builtin_arc_divaw&lt;/strong&gt;（int &lt;var&gt;a&lt;/var&gt; ，int &lt;var&gt;b&lt;/var&gt; ）</target>
        </trans-unit>
        <trans-unit id="9c45a4bbd1df9874258bef23963c99d6fdf07ecc" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005farc_005fnorm&quot;&gt;__builtin_arc_norm&lt;/strong&gt; (int &lt;var&gt;src&lt;/var&gt;)</source>
          <target state="translated">内置函数：int &lt;strong id=&quot;index-_005f_005fbuiltin_005farc_005fnorm&quot;&gt;__builtin_arc_norm&lt;/strong&gt;（int &lt;var&gt;src&lt;/var&gt; ）</target>
        </trans-unit>
        <trans-unit id="343cfc12f31c0a60920faf8b433b92fcf3f860cf" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005farc_005fswap&quot;&gt;__builtin_arc_swap&lt;/strong&gt; (int &lt;var&gt;src&lt;/var&gt;)</source>
          <target state="translated">内置函数：int &lt;strong id=&quot;index-_005f_005fbuiltin_005farc_005fswap&quot;&gt;__builtin_arc_swap&lt;/strong&gt;（int &lt;var&gt;src&lt;/var&gt; ）</target>
        </trans-unit>
        <trans-unit id="4d84191dd5a2bd1c0e1ed8ebf20f4a6e76b3cbe6" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005fclrsb&quot;&gt;__builtin_clrsb&lt;/strong&gt; (int x)</source>
          <target state="translated">内置函数：int &lt;strong id=&quot;index-_005f_005fbuiltin_005fclrsb&quot;&gt;__builtin_clrsb&lt;/strong&gt;（int x）</target>
        </trans-unit>
        <trans-unit id="26c48a9f003c2411e7dd88432db5f58cb7b19302" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005fclrsbl&quot;&gt;__builtin_clrsbl&lt;/strong&gt; (long)</source>
          <target state="translated">内置函数：int &lt;strong id=&quot;index-_005f_005fbuiltin_005fclrsbl&quot;&gt;__builtin_clrsbl&lt;/strong&gt;（long）</target>
        </trans-unit>
        <trans-unit id="def7076c73776e0b25f88bdee6855cecbffd2e2a" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005fclrsbll&quot;&gt;__builtin_clrsbll&lt;/strong&gt; (long long)</source>
          <target state="translated">内置函数：int &lt;strong id=&quot;index-_005f_005fbuiltin_005fclrsbll&quot;&gt;__builtin_clrsbll&lt;/strong&gt;（long long）</target>
        </trans-unit>
        <trans-unit id="68a0ab60ba16fc861473b90def46ecb8b60b639d" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005fclz&quot;&gt;__builtin_clz&lt;/strong&gt; (unsigned int x)</source>
          <target state="translated">内置函数：int &lt;strong id=&quot;index-_005f_005fbuiltin_005fclz&quot;&gt;__builtin_clz&lt;/strong&gt;（无符号int x）</target>
        </trans-unit>
        <trans-unit id="af52cee1c123c25328e32f99b41a08f4a5682992" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005fclzl&quot;&gt;__builtin_clzl&lt;/strong&gt; (unsigned long)</source>
          <target state="translated">内置函数：int &lt;strong id=&quot;index-_005f_005fbuiltin_005fclzl&quot;&gt;__builtin_clzl&lt;/strong&gt;（无符号长）</target>
        </trans-unit>
        <trans-unit id="f3a7c4157a06fcdbaf2b34c2852b5f5191d70ac6" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005fclzll&quot;&gt;__builtin_clzll&lt;/strong&gt; (unsigned long long)</source>
          <target state="translated">内置函数：int &lt;strong id=&quot;index-_005f_005fbuiltin_005fclzll&quot;&gt;__builtin_clzll&lt;/strong&gt;（无符号long long）</target>
        </trans-unit>
        <trans-unit id="e47a14a24701e5c3353b9003a2bdd96c5e473a94" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005fconstant_005fp&quot;&gt;__builtin_constant_p&lt;/strong&gt; (&lt;var&gt;exp&lt;/var&gt;)</source>
          <target state="translated">内置函数：int &lt;strong id=&quot;index-_005f_005fbuiltin_005fconstant_005fp&quot;&gt;__builtin_constant_p&lt;/strong&gt;（ &lt;var&gt;exp&lt;/var&gt; ）</target>
        </trans-unit>
        <trans-unit id="ef14ea6a7a4d27be1b6d59915aed4bf7b4b1a9b6" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005fcpu_005fis&quot;&gt;__builtin_cpu_is&lt;/strong&gt; (const char *&lt;var&gt;cpuname&lt;/var&gt;)</source>
          <target state="translated">内置函数：int &lt;strong id=&quot;index-_005f_005fbuiltin_005fcpu_005fis&quot;&gt;__builtin_cpu_is&lt;/strong&gt;（const char * &lt;var&gt;cpuname&lt;/var&gt; ）</target>
        </trans-unit>
        <trans-unit id="b3f1d6da484baf586ba4417cd2ac456d3490d574" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005fcpu_005fis-1&quot;&gt;__builtin_cpu_is&lt;/strong&gt; (const char *&lt;var&gt;cpuname&lt;/var&gt;)</source>
          <target state="translated">内置函数：int &lt;strong id=&quot;index-_005f_005fbuiltin_005fcpu_005fis-1&quot;&gt;__builtin_cpu_is&lt;/strong&gt;（const char * &lt;var&gt;cpuname&lt;/var&gt; ）</target>
        </trans-unit>
        <trans-unit id="8f5e90517840f43dd21b0d12105cc6839b7ba276" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005fcpu_005fsupports&quot;&gt;__builtin_cpu_supports&lt;/strong&gt; (const char *&lt;var&gt;feature&lt;/var&gt;)</source>
          <target state="translated">内置函数：int &lt;strong id=&quot;index-_005f_005fbuiltin_005fcpu_005fsupports&quot;&gt;__builtin_cpu_supports&lt;/strong&gt;（const char * &lt;var&gt;feature&lt;/var&gt; ）</target>
        </trans-unit>
        <trans-unit id="be485791899d037b9a8263a3418dab2b9ad4f3b5" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005fcpu_005fsupports-1&quot;&gt;__builtin_cpu_supports&lt;/strong&gt; (const char *&lt;var&gt;feature&lt;/var&gt;)</source>
          <target state="translated">内置函数：int &lt;strong id=&quot;index-_005f_005fbuiltin_005fcpu_005fsupports-1&quot;&gt;__builtin_cpu_supports&lt;/strong&gt;（const char * &lt;var&gt;feature&lt;/var&gt; ）</target>
        </trans-unit>
        <trans-unit id="7f22b95a5cdd587669aed9814a5480962c20cb7d" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005fctz&quot;&gt;__builtin_ctz&lt;/strong&gt; (unsigned int x)</source>
          <target state="translated">内置函数：int &lt;strong id=&quot;index-_005f_005fbuiltin_005fctz&quot;&gt;__builtin_ctz&lt;/strong&gt;（无符号int x）</target>
        </trans-unit>
        <trans-unit id="8e1e06b0d6fb4ae3123c409271d97e77380c487c" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005fctzl&quot;&gt;__builtin_ctzl&lt;/strong&gt; (unsigned long)</source>
          <target state="translated">内置函数：int &lt;strong id=&quot;index-_005f_005fbuiltin_005fctzl&quot;&gt;__builtin_ctzl&lt;/strong&gt;（无符号长）</target>
        </trans-unit>
        <trans-unit id="20a1238733f66fff846c6029aaa32b6b42066621" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005fctzll&quot;&gt;__builtin_ctzll&lt;/strong&gt; (unsigned long long)</source>
          <target state="translated">内置函数：int &lt;strong id=&quot;index-_005f_005fbuiltin_005fctzll&quot;&gt;__builtin_ctzll&lt;/strong&gt;（unsigned long long）</target>
        </trans-unit>
        <trans-unit id="0937729bdd117da89bde58b2fd5056203d7a7e12" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005fffs&quot;&gt;__builtin_ffs&lt;/strong&gt; (int x)</source>
          <target state="translated">内置函数：int &lt;strong id=&quot;index-_005f_005fbuiltin_005fffs&quot;&gt;__builtin_ffs&lt;/strong&gt;（int x）</target>
        </trans-unit>
        <trans-unit id="c820dda274694fd7c04aa653b01ff9cf75ba5bae" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005fffsl&quot;&gt;__builtin_ffsl&lt;/strong&gt; (long)</source>
          <target state="translated">内置函数：int &lt;strong id=&quot;index-_005f_005fbuiltin_005fffsl&quot;&gt;__builtin_ffsl&lt;/strong&gt;（long）</target>
        </trans-unit>
        <trans-unit id="0419174c77d9db8a178954419d9e7c6e3dc80183" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005fffsll&quot;&gt;__builtin_ffsll&lt;/strong&gt; (long long)</source>
          <target state="translated">内置函数：int &lt;strong id=&quot;index-_005f_005fbuiltin_005fffsll&quot;&gt;__builtin_ffsll&lt;/strong&gt;（long long）</target>
        </trans-unit>
        <trans-unit id="d32b1e79ff752f0a0ce225c7feb84f484de727e9" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005ffpclassify-1&quot;&gt;__builtin_fpclassify&lt;/strong&gt; (int, int, int, int, int, ...)</source>
          <target state="translated">内置函数：int &lt;strong id=&quot;index-_005f_005fbuiltin_005ffpclassify-1&quot;&gt;__builtin_fpclassify&lt;/strong&gt;（int，int，int，int，int，...）</target>
        </trans-unit>
        <trans-unit id="e67b5cb4d37226ea2da9240fb2bf4c5fbfb5a8e1" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005fgoacc_005fparlevel_005fid&quot;&gt;__builtin_goacc_parlevel_id&lt;/strong&gt; (int x)</source>
          <target state="translated">内置函数：int &lt;strong id=&quot;index-_005f_005fbuiltin_005fgoacc_005fparlevel_005fid&quot;&gt;__builtin_goacc_parlevel_id&lt;/strong&gt;（int x）</target>
        </trans-unit>
        <trans-unit id="6e97eb7d6696130c1b12f3a195f09c5fe85037ac" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005fgoacc_005fparlevel_005fsize&quot;&gt;__builtin_goacc_parlevel_size&lt;/strong&gt; (int x)</source>
          <target state="translated">内置函数：int &lt;strong id=&quot;index-_005f_005fbuiltin_005fgoacc_005fparlevel_005fsize&quot;&gt;__builtin_goacc_parlevel_size&lt;/strong&gt;（int x）</target>
        </trans-unit>
        <trans-unit id="6d1c7c86aea003afe938bab829e378b0663f340f" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005fisinf_005fsign-1&quot;&gt;__builtin_isinf_sign&lt;/strong&gt; (...)</source>
          <target state="translated">内置函数：int &lt;strong id=&quot;index-_005f_005fbuiltin_005fisinf_005fsign-1&quot;&gt;__builtin_isinf_sign&lt;/strong&gt;（...）</target>
        </trans-unit>
        <trans-unit id="b6364cb6c54b3f23f200e94c257634d572b72a2b" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005fnds32_005fmfsr&quot;&gt;__builtin_nds32_mfsr&lt;/strong&gt; (int &lt;var&gt;sr&lt;/var&gt;)</source>
          <target state="translated">内置函数：int &lt;strong id=&quot;index-_005f_005fbuiltin_005fnds32_005fmfsr&quot;&gt;__builtin_nds32_mfsr&lt;/strong&gt;（int &lt;var&gt;sr&lt;/var&gt; ）</target>
        </trans-unit>
        <trans-unit id="75355c68c6a70985d49c27c009882adbab77b765" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005fnds32_005fmfusr&quot;&gt;__builtin_nds32_mfusr&lt;/strong&gt; (int &lt;var&gt;usr&lt;/var&gt;)</source>
          <target state="translated">内置函数：int &lt;strong id=&quot;index-_005f_005fbuiltin_005fnds32_005fmfusr&quot;&gt;__builtin_nds32_mfusr&lt;/strong&gt;（int &lt;var&gt;usr&lt;/var&gt; ）</target>
        </trans-unit>
        <trans-unit id="4ea0be9b20abc1e8c8611e711574fc9d068aecdf" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005fparity&quot;&gt;__builtin_parity&lt;/strong&gt; (unsigned int x)</source>
          <target state="translated">内置函数：int &lt;strong id=&quot;index-_005f_005fbuiltin_005fparity&quot;&gt;__builtin_parity&lt;/strong&gt;（无符号int x）</target>
        </trans-unit>
        <trans-unit id="d2674768572b8928e01401026a8478558c974780" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005fparityl&quot;&gt;__builtin_parityl&lt;/strong&gt; (unsigned long)</source>
          <target state="translated">内置函数：int &lt;strong id=&quot;index-_005f_005fbuiltin_005fparityl&quot;&gt;__builtin_parityl&lt;/strong&gt;（无符号长）</target>
        </trans-unit>
        <trans-unit id="ee9664e69ce71d737f813b0b4d98ebf2574871d2" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005fparityll&quot;&gt;__builtin_parityll&lt;/strong&gt; (unsigned long long)</source>
          <target state="translated">内置函数：int &lt;strong id=&quot;index-_005f_005fbuiltin_005fparityll&quot;&gt;__builtin_parityll&lt;/strong&gt;（unsigned long long）</target>
        </trans-unit>
        <trans-unit id="f4ff1595ae9b712ea80b334ac2a6cdea20f82b68" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005fpopcount&quot;&gt;__builtin_popcount&lt;/strong&gt; (unsigned int x)</source>
          <target state="translated">内置函数：int &lt;strong id=&quot;index-_005f_005fbuiltin_005fpopcount&quot;&gt;__builtin_popcount&lt;/strong&gt;（无符号int x）</target>
        </trans-unit>
        <trans-unit id="06a51eea95b9b1a09db27133b891662e30ce0448" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005fpopcountl&quot;&gt;__builtin_popcountl&lt;/strong&gt; (unsigned long)</source>
          <target state="translated">内置函数：int &lt;strong id=&quot;index-_005f_005fbuiltin_005fpopcountl&quot;&gt;__builtin_popcountl&lt;/strong&gt;（无符号长）</target>
        </trans-unit>
        <trans-unit id="cdd076b3e2da0133a80ede36a8b399d240589b8d" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005fpopcountll&quot;&gt;__builtin_popcountll&lt;/strong&gt; (unsigned long long)</source>
          <target state="translated">内置函数：int &lt;strong id=&quot;index-_005f_005fbuiltin_005fpopcountll&quot;&gt;__builtin_popcountll&lt;/strong&gt;（unsigned long long）</target>
        </trans-unit>
        <trans-unit id="81ba97f2fd93c345aa1ebd2ae07061c6b3b1e18d" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005fmvfachi&quot;&gt;__builtin_rx_mvfachi&lt;/strong&gt; (void)</source>
          <target state="translated">内置函数：int &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005fmvfachi&quot;&gt;__builtin_rx_mvfachi&lt;/strong&gt;（无效）</target>
        </trans-unit>
        <trans-unit id="bc349ef1269f6645b577d9e0423a3da86a3c0c64" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005fmvfacmi&quot;&gt;__builtin_rx_mvfacmi&lt;/strong&gt; (void)</source>
          <target state="translated">内置函数：int &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005fmvfacmi&quot;&gt;__builtin_rx_mvfacmi&lt;/strong&gt;（void）</target>
        </trans-unit>
        <trans-unit id="3c6283c7dae9e9bf7ecb0b6d081f4b083bb18c46" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005fmvfc&quot;&gt;__builtin_rx_mvfc&lt;/strong&gt; (int)</source>
          <target state="translated">内置函数：int &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005fmvfc&quot;&gt;__builtin_rx_mvfc&lt;/strong&gt;（int）</target>
        </trans-unit>
        <trans-unit id="061b61de0614f91eda3a2e79ebd09fdb750a9e0f" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005frevw&quot;&gt;__builtin_rx_revw&lt;/strong&gt; (int)</source>
          <target state="translated">内置函数：int &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005frevw&quot;&gt;__builtin_rx_revw&lt;/strong&gt;（int）</target>
        </trans-unit>
        <trans-unit id="90ac1419f6405c9d67980323a8c6db2b17519fa4" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005fsat&quot;&gt;__builtin_rx_sat&lt;/strong&gt; (int)</source>
          <target state="translated">内置函数：int &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005fsat&quot;&gt;__builtin_rx_sat&lt;/strong&gt;（int）</target>
        </trans-unit>
        <trans-unit id="ba08ce759241ad5b54043023fc31cb69ea10ef12" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005fsetjmp&quot;&gt;__builtin_setjmp&lt;/strong&gt; (intptr_t *&lt;var&gt;buf&lt;/var&gt;)</source>
          <target state="translated">内置函数：int &lt;strong id=&quot;index-_005f_005fbuiltin_005fsetjmp&quot;&gt;__builtin_setjmp&lt;/strong&gt;（intptr_t * &lt;var&gt;buf&lt;/var&gt; ）</target>
        </trans-unit>
        <trans-unit id="3b5f4e2e49e883c140bdde81a146113e7826c6e9" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005ftbegin&quot;&gt;__builtin_tbegin&lt;/strong&gt; (void*)</source>
          <target state="translated">内置函数：int &lt;strong id=&quot;index-_005f_005fbuiltin_005ftbegin&quot;&gt;__builtin_tbegin&lt;/strong&gt;（void *）</target>
        </trans-unit>
        <trans-unit id="00769436b2cde422b3b7011657e79f1018006b03" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005ftbegin_005fnofloat&quot;&gt;__builtin_tbegin_nofloat&lt;/strong&gt; (void*)</source>
          <target state="translated">内置函数：int &lt;strong id=&quot;index-_005f_005fbuiltin_005ftbegin_005fnofloat&quot;&gt;__builtin_tbegin_nofloat&lt;/strong&gt;（void *）</target>
        </trans-unit>
        <trans-unit id="b626c4c35bdf8b837ccbdac21dccf04d3259501c" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005ftbegin_005fretry&quot;&gt;__builtin_tbegin_retry&lt;/strong&gt; (void*, int)</source>
          <target state="translated">内置函数：int &lt;strong id=&quot;index-_005f_005fbuiltin_005ftbegin_005fretry&quot;&gt;__builtin_tbegin_retry&lt;/strong&gt;（void *，int）</target>
        </trans-unit>
        <trans-unit id="7b0e1df41de31ed2e428c07e756094f54001f4e6" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005ftbegin_005fretry_005fnofloat&quot;&gt;__builtin_tbegin_retry_nofloat&lt;/strong&gt; (void*, int)</source>
          <target state="translated">内置函数：int &lt;strong id=&quot;index-_005f_005fbuiltin_005ftbegin_005fretry_005fnofloat&quot;&gt;__builtin_tbegin_retry_nofloat&lt;/strong&gt;（void *，int）</target>
        </trans-unit>
        <trans-unit id="5a37cc4aa4480ad9e51ba1642145972ee824d1c3" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005ftend&quot;&gt;__builtin_tend&lt;/strong&gt; (void)</source>
          <target state="translated">内置函数：int &lt;strong id=&quot;index-_005f_005fbuiltin_005ftend&quot;&gt;__builtin_tend&lt;/strong&gt;（void）</target>
        </trans-unit>
        <trans-unit id="b156bfa334cc82648dee3d2f253e789fdf0de655" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005ftx_005fnesting_005fdepth&quot;&gt;__builtin_tx_nesting_depth&lt;/strong&gt; (void)</source>
          <target state="translated">内置函数：int &lt;strong id=&quot;index-_005f_005fbuiltin_005ftx_005fnesting_005fdepth&quot;&gt;__builtin_tx_nesting_depth&lt;/strong&gt;（无效）</target>
        </trans-unit>
        <trans-unit id="7d1b9cf1258d4a3f36ac2384619d6f6feef8480b" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005ftypes_005fcompatible_005fp&quot;&gt;__builtin_types_compatible_p&lt;/strong&gt; (&lt;var&gt;type1&lt;/var&gt;, &lt;var&gt;type2&lt;/var&gt;)</source>
          <target state="translated">内置函数：int &lt;strong id=&quot;index-_005f_005fbuiltin_005ftypes_005fcompatible_005fp&quot;&gt;__builtin_types_compatible_p&lt;/strong&gt;（ &lt;var&gt;type1&lt;/var&gt; ， &lt;var&gt;type2&lt;/var&gt; ）</target>
        </trans-unit>
        <trans-unit id="ab0fd3c8fa261ef1e9881453b5ce3996db8b353f" translate="yes" xml:space="preserve">
          <source>Built-in Function: long &lt;strong id=&quot;index-_005f_005fbuiltin_005fexpect&quot;&gt;__builtin_expect&lt;/strong&gt; (long &lt;var&gt;exp&lt;/var&gt;, long &lt;var&gt;c&lt;/var&gt;)</source>
          <target state="translated">内置函数：long &lt;strong id=&quot;index-_005f_005fbuiltin_005fexpect&quot;&gt;__builtin_expect&lt;/strong&gt;（long &lt;var&gt;exp&lt;/var&gt; ，long &lt;var&gt;c&lt;/var&gt; ）</target>
        </trans-unit>
        <trans-unit id="f748429dddf7f60efd21f75bc9d96a2f04db2076" translate="yes" xml:space="preserve">
          <source>Built-in Function: long &lt;strong id=&quot;index-_005f_005fbuiltin_005fexpect_005fwith_005fprobability&quot;&gt;__builtin_expect_with_probability&lt;/strong&gt;</source>
          <target state="translated">内置函数：long &lt;strong id=&quot;index-_005f_005fbuiltin_005fexpect_005fwith_005fprobability&quot;&gt;__builtin_expect_with_probability&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="971be5dbeae5d7765bfe0bd927cc0410ae39a447" translate="yes" xml:space="preserve">
          <source>Built-in Function: long double &lt;strong id=&quot;index-_005f_005fbuiltin_005fhuge_005fvall&quot;&gt;__builtin_huge_vall&lt;/strong&gt; (void)</source>
          <target state="translated">内置函数：long double &lt;strong id=&quot;index-_005f_005fbuiltin_005fhuge_005fvall&quot;&gt;__builtin_huge_vall&lt;/strong&gt;（无效）</target>
        </trans-unit>
        <trans-unit id="f890816fdc58a1aea60b82df935d886c00b2bf15" translate="yes" xml:space="preserve">
          <source>Built-in Function: long double &lt;strong id=&quot;index-_005f_005fbuiltin_005finfl&quot;&gt;__builtin_infl&lt;/strong&gt; (void)</source>
          <target state="translated">内置函数：long double &lt;strong id=&quot;index-_005f_005fbuiltin_005finfl&quot;&gt;__builtin_infl&lt;/strong&gt;（无效）</target>
        </trans-unit>
        <trans-unit id="4324db719b621df0af588063a194c3f4173810b5" translate="yes" xml:space="preserve">
          <source>Built-in Function: long double &lt;strong id=&quot;index-_005f_005fbuiltin_005fnanl&quot;&gt;__builtin_nanl&lt;/strong&gt; (const char *str)</source>
          <target state="translated">内置函数：long double &lt;strong id=&quot;index-_005f_005fbuiltin_005fnanl&quot;&gt;__builtin_nanl&lt;/strong&gt;（const char * str）</target>
        </trans-unit>
        <trans-unit id="05afbb2ee64f8e1c3ac88b778a44096576c7f966" translate="yes" xml:space="preserve">
          <source>Built-in Function: long double &lt;strong id=&quot;index-_005f_005fbuiltin_005fnansl&quot;&gt;__builtin_nansl&lt;/strong&gt; (const char *str)</source>
          <target state="translated">内置函数：long double &lt;strong id=&quot;index-_005f_005fbuiltin_005fnansl&quot;&gt;__builtin_nansl&lt;/strong&gt;（const char * str）</target>
        </trans-unit>
        <trans-unit id="2b868b2b6ef31f0d2806eabe890d6c604ddddf56" translate="yes" xml:space="preserve">
          <source>Built-in Function: long double &lt;strong id=&quot;index-_005f_005fbuiltin_005fpowil-1&quot;&gt;__builtin_powil&lt;/strong&gt; (long double, int)</source>
          <target state="translated">内置函数：long double &lt;strong id=&quot;index-_005f_005fbuiltin_005fpowil-1&quot;&gt;__builtin_powil&lt;/strong&gt;（long double，int）</target>
        </trans-unit>
        <trans-unit id="d356427c6ff17cd4bc34021c1341be077bc0c8a1" translate="yes" xml:space="preserve">
          <source>Built-in Function: short int &lt;strong id=&quot;index-_005f_005fbuiltin_005farc_005fnormw&quot;&gt;__builtin_arc_normw&lt;/strong&gt; (short int &lt;var&gt;src&lt;/var&gt;)</source>
          <target state="translated">内置函数：short int &lt;strong id=&quot;index-_005f_005fbuiltin_005farc_005fnormw&quot;&gt;__builtin_arc_normw&lt;/strong&gt;（short int &lt;var&gt;src&lt;/var&gt; ）</target>
        </trans-unit>
        <trans-unit id="f029118b8798750fa6c678264c3c7762285f4d28" translate="yes" xml:space="preserve">
          <source>Built-in Function: size_t &lt;strong id=&quot;index-_005f_005fbuiltin_005fobject_005fsize-1&quot;&gt;__builtin_object_size&lt;/strong&gt; (const void * &lt;var&gt;ptr&lt;/var&gt;, int &lt;var&gt;type&lt;/var&gt;)</source>
          <target state="translated">内置函数：size_t &lt;strong id=&quot;index-_005f_005fbuiltin_005fobject_005fsize-1&quot;&gt;__builtin_object_size&lt;/strong&gt;（const void * &lt;var&gt;ptr&lt;/var&gt; ，int &lt;var&gt;type&lt;/var&gt; ）</target>
        </trans-unit>
        <trans-unit id="e7554947332f78bb70c0521290e9a6608845a4d1" translate="yes" xml:space="preserve">
          <source>Built-in Function: size_t &lt;strong id=&quot;index-_005f_005fbuiltin_005fobject_005fsize-3&quot;&gt;__builtin_object_size&lt;/strong&gt; (const void * &lt;var&gt;ptr&lt;/var&gt;, int &lt;var&gt;type&lt;/var&gt;)</source>
          <target state="translated">内置函数：size_t &lt;strong id=&quot;index-_005f_005fbuiltin_005fobject_005fsize-3&quot;&gt;__builtin_object_size&lt;/strong&gt;（const void * &lt;var&gt;ptr&lt;/var&gt; ，int &lt;var&gt;type&lt;/var&gt; ）</target>
        </trans-unit>
        <trans-unit id="989a30653b65ffed34f5682558a8970a9aa0e644" translate="yes" xml:space="preserve">
          <source>Built-in Function: size_t &lt;strong id=&quot;index-_005f_005fbuiltin_005fva_005farg_005fpack_005flen&quot;&gt;__builtin_va_arg_pack_len&lt;/strong&gt; ()</source>
          <target state="translated">内置函数：size_t &lt;strong id=&quot;index-_005f_005fbuiltin_005fva_005farg_005fpack_005flen&quot;&gt;__builtin_va_arg_pack_len&lt;/strong&gt;（）</target>
        </trans-unit>
        <trans-unit id="22d331467c48fe2922c4d1d28e785562b4d984a9" translate="yes" xml:space="preserve">
          <source>Built-in Function: uint16_t &lt;strong id=&quot;index-_005f_005fbuiltin_005fbswap16&quot;&gt;__builtin_bswap16&lt;/strong&gt; (uint16_t x)</source>
          <target state="translated">内置函数：uint16_t &lt;strong id=&quot;index-_005f_005fbuiltin_005fbswap16&quot;&gt;__builtin_bswap16&lt;/strong&gt;（uint16_t x）</target>
        </trans-unit>
        <trans-unit id="c1726e6c424d7f99d5018566837c4927b7db5948" translate="yes" xml:space="preserve">
          <source>Built-in Function: uint32_t &lt;strong id=&quot;index-_005f_005fbuiltin_005fbswap32&quot;&gt;__builtin_bswap32&lt;/strong&gt; (uint32_t x)</source>
          <target state="translated">内置函数：uint32_t &lt;strong id=&quot;index-_005f_005fbuiltin_005fbswap32&quot;&gt;__builtin_bswap32&lt;/strong&gt;（uint32_t x）</target>
        </trans-unit>
        <trans-unit id="3c5352b73e73ceeb994fa2584683f756d8f9d112" translate="yes" xml:space="preserve">
          <source>Built-in Function: uint64_t &lt;strong id=&quot;index-_005f_005fbuiltin_005fbswap64&quot;&gt;__builtin_bswap64&lt;/strong&gt; (uint64_t x)</source>
          <target state="translated">内置函数：uint64_t &lt;strong id=&quot;index-_005f_005fbuiltin_005fbswap64&quot;&gt;__builtin_bswap64&lt;/strong&gt;（uint64_t x）</target>
        </trans-unit>
        <trans-unit id="abc61c858b13f41c2e5ca8e8946562bef29c71f9" translate="yes" xml:space="preserve">
          <source>Built-in Function: unsigned &lt;strong id=&quot;index-long&quot;&gt;long&lt;/strong&gt; long __builtin_bpf_load_byte (unsigned long long &lt;var&gt;offset&lt;/var&gt;)</source>
          <target state="translated">内置函数：unsigned &lt;strong id=&quot;index-long&quot;&gt;long&lt;/strong&gt; long __builtin_bpf_load_byte（unsigned long long &lt;var&gt;offset&lt;/var&gt; ）</target>
        </trans-unit>
        <trans-unit id="aa41c7be715e464532b85eaa4dc6a456f1c00215" translate="yes" xml:space="preserve">
          <source>Built-in Function: unsigned &lt;strong id=&quot;index-long-1&quot;&gt;long&lt;/strong&gt; long __builtin_bpf_load_half (unsigned long long &lt;var&gt;offset&lt;/var&gt;)</source>
          <target state="translated">内置函数：unsigned &lt;strong id=&quot;index-long-1&quot;&gt;long&lt;/strong&gt; long __builtin_bpf_load_half（无符号long long &lt;var&gt;offset&lt;/var&gt; ）</target>
        </trans-unit>
        <trans-unit id="7b96451756f237a6911f0f759acff406d9ac6251" translate="yes" xml:space="preserve">
          <source>Built-in Function: unsigned &lt;strong id=&quot;index-long-2&quot;&gt;long&lt;/strong&gt; long __builtin_bpf_load_word (unsigned long long &lt;var&gt;offset&lt;/var&gt;)</source>
          <target state="translated">内置函数：unsigned &lt;strong id=&quot;index-long-2&quot;&gt;long&lt;/strong&gt; long __builtin_bpf_load_word（unsigned long long &lt;var&gt;offset&lt;/var&gt; ）</target>
        </trans-unit>
        <trans-unit id="509ae15fd2e87932ac8b26cb6b1d223cd12aa699" translate="yes" xml:space="preserve">
          <source>Built-in Function: unsigned int &lt;strong id=&quot;index-_005f_005fbuiltin_005farc_005fcore_005fread&quot;&gt;__builtin_arc_core_read&lt;/strong&gt; (unsigned int &lt;var&gt;regno&lt;/var&gt;)</source>
          <target state="translated">内置函数：unsigned int &lt;strong id=&quot;index-_005f_005fbuiltin_005farc_005fcore_005fread&quot;&gt;__builtin_arc_core_read&lt;/strong&gt;（unsigned int &lt;var&gt;regno&lt;/var&gt; ）</target>
        </trans-unit>
        <trans-unit id="930e355c3b80a5a9fc58fc1acd0a189dee429782" translate="yes" xml:space="preserve">
          <source>Built-in Function: unsigned int &lt;strong id=&quot;index-_005f_005fbuiltin_005farc_005flr&quot;&gt;__builtin_arc_lr&lt;/strong&gt; (unsigned int &lt;var&gt;auxr&lt;/var&gt;)</source>
          <target state="translated">内置函数：unsigned int &lt;strong id=&quot;index-_005f_005fbuiltin_005farc_005flr&quot;&gt;__builtin_arc_lr&lt;/strong&gt;（unsigned int &lt;var&gt;auxr&lt;/var&gt; ）</target>
        </trans-unit>
        <trans-unit id="fe43f813f2eb2f9db208678d8efd3062ab0ae06f" translate="yes" xml:space="preserve">
          <source>Built-in Function: unsigned int &lt;strong id=&quot;index-_005f_005fbuiltin_005fsh_005fget_005ffpscr&quot;&gt;__builtin_sh_get_fpscr&lt;/strong&gt; (void)</source>
          <target state="translated">内置函数：unsigned int &lt;strong id=&quot;index-_005f_005fbuiltin_005fsh_005fget_005ffpscr&quot;&gt;__builtin_sh_get_fpscr&lt;/strong&gt;（无效）</target>
        </trans-unit>
        <trans-unit id="7bd053e0e0e0c481f2fd8761cce8fb20e0497500" translate="yes" xml:space="preserve">
          <source>Built-in Function: void * &lt;strong id=&quot;index-_005f_005fbuiltin_005fapply&quot;&gt;__builtin_apply&lt;/strong&gt; (void (*&lt;var&gt;function&lt;/var&gt;)(), void *&lt;var&gt;arguments&lt;/var&gt;, size_t &lt;var&gt;size&lt;/var&gt;)</source>
          <target state="translated">内置函数：void * &lt;strong id=&quot;index-_005f_005fbuiltin_005fapply&quot;&gt;__builtin_apply&lt;/strong&gt;（void（* &lt;var&gt;function&lt;/var&gt; ）（），void * &lt;var&gt;arguments&lt;/var&gt; ，size_t &lt;var&gt;size&lt;/var&gt; ）</target>
        </trans-unit>
        <trans-unit id="34fa5cc333ec1b465b8bc1469ac13a9805646394" translate="yes" xml:space="preserve">
          <source>Built-in Function: void * &lt;strong id=&quot;index-_005f_005fbuiltin_005fapply_005fargs&quot;&gt;__builtin_apply_args&lt;/strong&gt; ()</source>
          <target state="translated">内置函数：void * &lt;strong id=&quot;index-_005f_005fbuiltin_005fapply_005fargs&quot;&gt;__builtin_apply_args&lt;/strong&gt;（）</target>
        </trans-unit>
        <trans-unit id="ae3f4e7eb7b92dd81ca2567a194a5a901d0bfe5f" translate="yes" xml:space="preserve">
          <source>Built-in Function: void * &lt;strong id=&quot;index-_005f_005fbuiltin_005fassume_005faligned&quot;&gt;__builtin_assume_aligned&lt;/strong&gt; (const void *&lt;var&gt;exp&lt;/var&gt;, size_t &lt;var&gt;align&lt;/var&gt;, ...)</source>
          <target state="translated">内置函数：void * &lt;strong id=&quot;index-_005f_005fbuiltin_005fassume_005faligned&quot;&gt;__builtin_assume_aligned&lt;/strong&gt;（const void * &lt;var&gt;exp&lt;/var&gt; ，size_t &lt;var&gt;align&lt;/var&gt; ，...）</target>
        </trans-unit>
        <trans-unit id="89fd532a50930c3b77686313f0365b067e8b2061" translate="yes" xml:space="preserve">
          <source>Built-in Function: void * &lt;strong id=&quot;index-_005f_005fbuiltin_005fextract_005freturn_005faddr&quot;&gt;__builtin_extract_return_addr&lt;/strong&gt; (void *&lt;var&gt;addr&lt;/var&gt;)</source>
          <target state="translated">内置函数：void * &lt;strong id=&quot;index-_005f_005fbuiltin_005fextract_005freturn_005faddr&quot;&gt;__builtin_extract_return_addr&lt;/strong&gt;（void * &lt;var&gt;addr&lt;/var&gt; ）</target>
        </trans-unit>
        <trans-unit id="af5db4b2531bc00d2c26aa89ffd98b83b1ec2ffd" translate="yes" xml:space="preserve">
          <source>Built-in Function: void * &lt;strong id=&quot;index-_005f_005fbuiltin_005fframe_005faddress&quot;&gt;__builtin_frame_address&lt;/strong&gt; (unsigned int &lt;var&gt;level&lt;/var&gt;)</source>
          <target state="translated">内置函数：void * &lt;strong id=&quot;index-_005f_005fbuiltin_005fframe_005faddress&quot;&gt;__builtin_frame_address&lt;/strong&gt;（无符号int &lt;var&gt;level&lt;/var&gt; ）</target>
        </trans-unit>
        <trans-unit id="d65d4d6005c36effe3b2d9cb5dc89b8f157bffcd" translate="yes" xml:space="preserve">
          <source>Built-in Function: void * &lt;strong id=&quot;index-_005f_005fbuiltin_005ffrob_005freturn_005faddr&quot;&gt;__builtin_frob_return_addr&lt;/strong&gt; (void *&lt;var&gt;addr&lt;/var&gt;)</source>
          <target state="translated">内置函数：void * &lt;strong id=&quot;index-_005f_005fbuiltin_005ffrob_005freturn_005faddr&quot;&gt;__builtin_frob_return_addr&lt;/strong&gt;（void * &lt;var&gt;addr&lt;/var&gt; ）</target>
        </trans-unit>
        <trans-unit id="0ae549b690a18db077d51fc88ddfe8895c32f392" translate="yes" xml:space="preserve">
          <source>Built-in Function: void * &lt;strong id=&quot;index-_005f_005fbuiltin_005ffrob_005freturn_005faddress&quot;&gt;__builtin_frob_return_address&lt;/strong&gt; (void *&lt;var&gt;addr&lt;/var&gt;)</source>
          <target state="translated">内置函数：void * &lt;strong id=&quot;index-_005f_005fbuiltin_005ffrob_005freturn_005faddress&quot;&gt;__builtin_frob_return_address&lt;/strong&gt;（void * &lt;var&gt;addr&lt;/var&gt; ）</target>
        </trans-unit>
        <trans-unit id="570bc19f96ffb431d4ed4e07d4a76a73d90b1bab" translate="yes" xml:space="preserve">
          <source>Built-in Function: void * &lt;strong id=&quot;index-_005f_005fbuiltin_005freturn_005faddress&quot;&gt;__builtin_return_address&lt;/strong&gt; (unsigned int &lt;var&gt;level&lt;/var&gt;)</source>
          <target state="translated">内置函数：void * &lt;strong id=&quot;index-_005f_005fbuiltin_005freturn_005faddress&quot;&gt;__builtin_return_address&lt;/strong&gt;（无符号int &lt;var&gt;level&lt;/var&gt; ）</target>
        </trans-unit>
        <trans-unit id="2a17d8a48dd1cfb01e5eca9e0fefb74ccd1f3e19" translate="yes" xml:space="preserve">
          <source>Built-in Function: void * &lt;strong id=&quot;index-_005f_005fbuiltin_005fthread_005fpointer&quot;&gt;__builtin_thread_pointer&lt;/strong&gt; (void)</source>
          <target state="translated">内置函数：void * &lt;strong id=&quot;index-_005f_005fbuiltin_005fthread_005fpointer&quot;&gt;__builtin_thread_pointer&lt;/strong&gt;（void）</target>
        </trans-unit>
        <trans-unit id="f386f8fa1a3ce61aaddb01d8f87e99be90ce722e" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_002a_005f_005fbuiltin_005falloca&quot;&gt;*__builtin_alloca&lt;/strong&gt; (size_t size)</source>
          <target state="translated">内置函数：void &lt;strong id=&quot;index-_002a_005f_005fbuiltin_005falloca&quot;&gt;* __ builtin_alloca&lt;/strong&gt;（size_t大小）</target>
        </trans-unit>
        <trans-unit id="c063cc66ca8c65c97e5563c39a35ab67426b4796" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_002a_005f_005fbuiltin_005falloca_005fwith_005falign&quot;&gt;*__builtin_alloca_with_align&lt;/strong&gt; (size_t size, size_t alignment)</source>
          <target state="translated">内置函数：void &lt;strong id=&quot;index-_002a_005f_005fbuiltin_005falloca_005fwith_005falign&quot;&gt;* __ builtin_alloca_with_align&lt;/strong&gt;（size_t大小，size_t对齐）</target>
        </trans-unit>
        <trans-unit id="9c9a2cc82b83f94f4d0c65d76c51d114da95b31b" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_002a_005f_005fbuiltin_005falloca_005fwith_005falign_005fand_005fmax&quot;&gt;*__builtin_alloca_with_align_and_max&lt;/strong&gt; (size_t size, size_t alignment, size_t max_size)</source>
          <target state="translated">内置函数：void &lt;strong id=&quot;index-_002a_005f_005fbuiltin_005falloca_005fwith_005falign_005fand_005fmax&quot;&gt;* __ builtin_alloca_with_align_and_max&lt;/strong&gt;（size_t大小，size_t对齐，size_t max_size）</target>
        </trans-unit>
        <trans-unit id="9362d0fd68d2bba012773ea9bf47a7cf19548a71" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fatomic_005fclear&quot;&gt;__atomic_clear&lt;/strong&gt; (bool *ptr, int memorder)</source>
          <target state="translated">内置函数：void &lt;strong id=&quot;index-_005f_005fatomic_005fclear&quot;&gt;__atomic_clear&lt;/strong&gt;（bool * ptr，int内存）</target>
        </trans-unit>
        <trans-unit id="af38ddba7b2c30fcdbcb19cb7f7f28b84121aca6" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fatomic_005fexchange&quot;&gt;__atomic_exchange&lt;/strong&gt; (&lt;var&gt;type&lt;/var&gt; *ptr, &lt;var&gt;type&lt;/var&gt; *val, &lt;var&gt;type&lt;/var&gt; *ret, int memorder)</source>
          <target state="translated">内置函数：void &lt;strong id=&quot;index-_005f_005fatomic_005fexchange&quot;&gt;__atomic_exchange&lt;/strong&gt;（ &lt;var&gt;type&lt;/var&gt; * ptr， &lt;var&gt;type&lt;/var&gt; * val， &lt;var&gt;type&lt;/var&gt; * ret，int内存）</target>
        </trans-unit>
        <trans-unit id="81cf5ada4648091ed72e1aa65aae72b350e8c4d3" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fatomic_005fload&quot;&gt;__atomic_load&lt;/strong&gt; (&lt;var&gt;type&lt;/var&gt; *ptr, &lt;var&gt;type&lt;/var&gt; *ret, int memorder)</source>
          <target state="translated">内置函数：void &lt;strong id=&quot;index-_005f_005fatomic_005fload&quot;&gt;__atomic_load&lt;/strong&gt;（ &lt;var&gt;type&lt;/var&gt; * ptr， &lt;var&gt;type&lt;/var&gt; * ret，int内存）</target>
        </trans-unit>
        <trans-unit id="a339c94ea5a60096d289e4b1ba778af9caadce5c" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fatomic_005fsignal_005ffence&quot;&gt;__atomic_signal_fence&lt;/strong&gt; (int memorder)</source>
          <target state="translated">内置函数：void &lt;strong id=&quot;index-_005f_005fatomic_005fsignal_005ffence&quot;&gt;__atomic_signal_fence&lt;/strong&gt;（int内存）</target>
        </trans-unit>
        <trans-unit id="a1bcb5179154226f5bada80a127d69eae1eb5cec" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fatomic_005fstore&quot;&gt;__atomic_store&lt;/strong&gt; (&lt;var&gt;type&lt;/var&gt; *ptr, &lt;var&gt;type&lt;/var&gt; *val, int memorder)</source>
          <target state="translated">内置函数：void &lt;strong id=&quot;index-_005f_005fatomic_005fstore&quot;&gt;__atomic_store&lt;/strong&gt;（ &lt;var&gt;type&lt;/var&gt; * ptr， &lt;var&gt;type&lt;/var&gt; * val，int内存）</target>
        </trans-unit>
        <trans-unit id="0a97d93631348e25f6183eb76cee2e101979f75e" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fatomic_005fstore_005fn&quot;&gt;__atomic_store_n&lt;/strong&gt; (&lt;var&gt;type&lt;/var&gt; *ptr, &lt;var&gt;type&lt;/var&gt; val, int memorder)</source>
          <target state="translated">内置函数：void &lt;strong id=&quot;index-_005f_005fatomic_005fstore_005fn&quot;&gt;__atomic_store_n&lt;/strong&gt;（ &lt;var&gt;type&lt;/var&gt; * ptr， &lt;var&gt;type&lt;/var&gt; val，int内存）</target>
        </trans-unit>
        <trans-unit id="2d340009d0a0b7de28ca2e66c34cf11a1340bae0" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fatomic_005fthread_005ffence&quot;&gt;__atomic_thread_fence&lt;/strong&gt; (int memorder)</source>
          <target state="translated">内置函数：void &lt;strong id=&quot;index-_005f_005fatomic_005fthread_005ffence&quot;&gt;__atomic_thread_fence&lt;/strong&gt;（int memorder）</target>
        </trans-unit>
        <trans-unit id="de406e12d51eaad788fc9e9d5903dcbf3bcb9513" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005f_005f_005fclear_005fcache&quot;&gt;__builtin___clear_cache&lt;/strong&gt; (void *&lt;var&gt;begin&lt;/var&gt;, void *&lt;var&gt;end&lt;/var&gt;)</source>
          <target state="translated">内置函数：void &lt;strong id=&quot;index-_005f_005fbuiltin_005f_005f_005fclear_005fcache&quot;&gt;__builtin___clear_cache&lt;/strong&gt;（void * &lt;var&gt;begin&lt;/var&gt; ，void * &lt;var&gt;end&lt;/var&gt; ）</target>
        </trans-unit>
        <trans-unit id="fbdc79fbdaaac306ca33e716a38d2039cdbc731c" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005farc_005fbrk&quot;&gt;__builtin_arc_brk&lt;/strong&gt; (void)</source>
          <target state="translated">内置函数：void &lt;strong id=&quot;index-_005f_005fbuiltin_005farc_005fbrk&quot;&gt;__builtin_arc_brk&lt;/strong&gt;（void）</target>
        </trans-unit>
        <trans-unit id="41dfbf690d1f1831d27b0be428eb428d5c08e800" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005farc_005fcore_005fwrite&quot;&gt;__builtin_arc_core_write&lt;/strong&gt; (unsigned int &lt;var&gt;regno&lt;/var&gt;, unsigned int &lt;var&gt;val&lt;/var&gt;)</source>
          <target state="translated">内置函数：void &lt;strong id=&quot;index-_005f_005fbuiltin_005farc_005fcore_005fwrite&quot;&gt;__builtin_arc_core_write&lt;/strong&gt;（unsigned int &lt;var&gt;regno&lt;/var&gt; ，unsigned int &lt;var&gt;val&lt;/var&gt; ）</target>
        </trans-unit>
        <trans-unit id="938747d2d81b773df4eb146dc47c371852f38281" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005farc_005fflag&quot;&gt;__builtin_arc_flag&lt;/strong&gt; (unsigned int &lt;var&gt;a&lt;/var&gt;)</source>
          <target state="translated">内置函数：void &lt;strong id=&quot;index-_005f_005fbuiltin_005farc_005fflag&quot;&gt;__builtin_arc_flag&lt;/strong&gt;（unsigned int &lt;var&gt;a&lt;/var&gt; ）</target>
        </trans-unit>
        <trans-unit id="dacbc2eeaf144c8f5f67ca6a60249f78488adc0b" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005farc_005fmul64&quot;&gt;__builtin_arc_mul64&lt;/strong&gt; (int &lt;var&gt;a&lt;/var&gt;, int &lt;var&gt;b&lt;/var&gt;)</source>
          <target state="translated">内置函数：void &lt;strong id=&quot;index-_005f_005fbuiltin_005farc_005fmul64&quot;&gt;__builtin_arc_mul64&lt;/strong&gt;（int &lt;var&gt;a&lt;/var&gt; ，int &lt;var&gt;b&lt;/var&gt; ）</target>
        </trans-unit>
        <trans-unit id="5df39d3186b8d524cef79461c8ccbf9360ab5670" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005farc_005fmulu64&quot;&gt;__builtin_arc_mulu64&lt;/strong&gt; (unsigned int &lt;var&gt;a&lt;/var&gt;, unsigned int &lt;var&gt;b&lt;/var&gt;)</source>
          <target state="translated">内置函数：void &lt;strong id=&quot;index-_005f_005fbuiltin_005farc_005fmulu64&quot;&gt;__builtin_arc_mulu64&lt;/strong&gt;（unsigned int &lt;var&gt;a&lt;/var&gt; ，unsigned int &lt;var&gt;b&lt;/var&gt; ）</target>
        </trans-unit>
        <trans-unit id="f6b3b375828d6b123d4a73fe0837a99b6630234e" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005farc_005fnop&quot;&gt;__builtin_arc_nop&lt;/strong&gt; (void)</source>
          <target state="translated">内置函数：void &lt;strong id=&quot;index-_005f_005fbuiltin_005farc_005fnop&quot;&gt;__builtin_arc_nop&lt;/strong&gt;（void）</target>
        </trans-unit>
        <trans-unit id="3e99485526d0fd614866e77c7a635130751c7b1d" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005farc_005frtie&quot;&gt;__builtin_arc_rtie&lt;/strong&gt; (void)</source>
          <target state="translated">内置函数：void &lt;strong id=&quot;index-_005f_005fbuiltin_005farc_005frtie&quot;&gt;__builtin_arc_rtie&lt;/strong&gt;（void）</target>
        </trans-unit>
        <trans-unit id="5cc0e84fe67d81076fbea0352fb8f5781564ffca" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005farc_005fsleep&quot;&gt;__builtin_arc_sleep&lt;/strong&gt; (int &lt;var&gt;a&lt;/var&gt;</source>
          <target state="translated">内置函数：void &lt;strong id=&quot;index-_005f_005fbuiltin_005farc_005fsleep&quot;&gt;__builtin_arc_sleep&lt;/strong&gt;（int &lt;var&gt;a&lt;/var&gt;</target>
        </trans-unit>
        <trans-unit id="39ed65244aa708bd181a626a0afcf9435d2147f5" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005farc_005fsr&quot;&gt;__builtin_arc_sr&lt;/strong&gt; (unsigned int &lt;var&gt;auxr&lt;/var&gt;, unsigned int &lt;var&gt;val&lt;/var&gt;)</source>
          <target state="translated">内置函数：void &lt;strong id=&quot;index-_005f_005fbuiltin_005farc_005fsr&quot;&gt;__builtin_arc_sr&lt;/strong&gt;（unsigned int &lt;var&gt;auxr&lt;/var&gt; ，unsigned int &lt;var&gt;val&lt;/var&gt; ）</target>
        </trans-unit>
        <trans-unit id="f420eb345d10d7bfd574d6a3346de63183adc893" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005farc_005fswi&quot;&gt;__builtin_arc_swi&lt;/strong&gt; (void)</source>
          <target state="translated">内置函数：void &lt;strong id=&quot;index-_005f_005fbuiltin_005farc_005fswi&quot;&gt;__builtin_arc_swi&lt;/strong&gt;（void）</target>
        </trans-unit>
        <trans-unit id="b42e0753d14b76f3a20b1e491681f5295a8dc135" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005farc_005fsync&quot;&gt;__builtin_arc_sync&lt;/strong&gt; (void)</source>
          <target state="translated">内置函数：void &lt;strong id=&quot;index-_005f_005fbuiltin_005farc_005fsync&quot;&gt;__builtin_arc_sync&lt;/strong&gt;（void）</target>
        </trans-unit>
        <trans-unit id="78cc7129f46ffcafd69b91e8eda56456c2ecced9" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005farc_005ftrap_005fs&quot;&gt;__builtin_arc_trap_s&lt;/strong&gt; (unsigned int &lt;var&gt;c&lt;/var&gt;)</source>
          <target state="translated">内置函数：void &lt;strong id=&quot;index-_005f_005fbuiltin_005farc_005ftrap_005fs&quot;&gt;__builtin_arc_trap_s&lt;/strong&gt;（unsigned int &lt;var&gt;c&lt;/var&gt; ）</target>
        </trans-unit>
        <trans-unit id="627e1715f16535c4e6e435528706da2168cf77df" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005farc_005funimp_005fs&quot;&gt;__builtin_arc_unimp_s&lt;/strong&gt; (void)</source>
          <target state="translated">内置函数：void &lt;strong id=&quot;index-_005f_005fbuiltin_005farc_005funimp_005fs&quot;&gt;__builtin_arc_unimp_s&lt;/strong&gt;（void）</target>
        </trans-unit>
        <trans-unit id="b29e71f1f17adad688b68068d1063df98d3d4aee" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005fcpu_005finit&quot;&gt;__builtin_cpu_init&lt;/strong&gt; (void)</source>
          <target state="translated">内置函数：void &lt;strong id=&quot;index-_005f_005fbuiltin_005fcpu_005finit&quot;&gt;__builtin_cpu_init&lt;/strong&gt;（void）</target>
        </trans-unit>
        <trans-unit id="ae429fc5f0112c7890dcdff589f10f47deea16dd" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005fcpu_005finit-1&quot;&gt;__builtin_cpu_init&lt;/strong&gt; (void)</source>
          <target state="translated">内置函数：void &lt;strong id=&quot;index-_005f_005fbuiltin_005fcpu_005finit-1&quot;&gt;__builtin_cpu_init&lt;/strong&gt;（void）</target>
        </trans-unit>
        <trans-unit id="d3cd845b205509711bbf6256051511ce8b3607ab" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005flongjmp&quot;&gt;__builtin_longjmp&lt;/strong&gt; (intptr_t *&lt;var&gt;buf&lt;/var&gt;, int &lt;var&gt;val&lt;/var&gt;)</source>
          <target state="translated">内置函数：void &lt;strong id=&quot;index-_005f_005fbuiltin_005flongjmp&quot;&gt;__builtin_longjmp&lt;/strong&gt;（intptr_t * &lt;var&gt;buf&lt;/var&gt; ，int &lt;var&gt;val&lt;/var&gt; ）</target>
        </trans-unit>
        <trans-unit id="fff14e5c46a00a91c0c0603fe5f170bde38d705e" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005fnds32_005fisb&quot;&gt;__builtin_nds32_isb&lt;/strong&gt; (void)</source>
          <target state="translated">内置函数：void &lt;strong id=&quot;index-_005f_005fbuiltin_005fnds32_005fisb&quot;&gt;__builtin_nds32_isb&lt;/strong&gt;（void）</target>
        </trans-unit>
        <trans-unit id="fe5501c6b5d93e7b033487f6a848dd334597db03" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005fnds32_005fisync&quot;&gt;__builtin_nds32_isync&lt;/strong&gt; (int *&lt;var&gt;addr&lt;/var&gt;)</source>
          <target state="translated">内置函数：void &lt;strong id=&quot;index-_005f_005fbuiltin_005fnds32_005fisync&quot;&gt;__builtin_nds32_isync&lt;/strong&gt;（int * &lt;var&gt;addr&lt;/var&gt; ）</target>
        </trans-unit>
        <trans-unit id="841f0b2bab051a37cafce912e8b554544bed4ffb" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005fnds32_005fmtsr&quot;&gt;__builtin_nds32_mtsr&lt;/strong&gt; (int &lt;var&gt;value&lt;/var&gt;, int &lt;var&gt;sr&lt;/var&gt;)</source>
          <target state="translated">内置函数：void &lt;strong id=&quot;index-_005f_005fbuiltin_005fnds32_005fmtsr&quot;&gt;__builtin_nds32_mtsr&lt;/strong&gt;（int &lt;var&gt;value&lt;/var&gt; ，int &lt;var&gt;sr&lt;/var&gt; ）</target>
        </trans-unit>
        <trans-unit id="df8bab86f6689c778da28b14954604543548fb9b" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005fnds32_005fmtusr&quot;&gt;__builtin_nds32_mtusr&lt;/strong&gt; (int &lt;var&gt;value&lt;/var&gt;, int &lt;var&gt;usr&lt;/var&gt;)</source>
          <target state="translated">内置函数：void &lt;strong id=&quot;index-_005f_005fbuiltin_005fnds32_005fmtusr&quot;&gt;__builtin_nds32_mtusr&lt;/strong&gt;（int &lt;var&gt;value&lt;/var&gt; ，int &lt;var&gt;usr&lt;/var&gt; ）</target>
        </trans-unit>
        <trans-unit id="cc7672c01bcce0ae5cb385b443579f1f0e814383" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005fnds32_005fsetgie_005fdis&quot;&gt;__builtin_nds32_setgie_dis&lt;/strong&gt; (void)</source>
          <target state="translated">内置函数：void &lt;strong id=&quot;index-_005f_005fbuiltin_005fnds32_005fsetgie_005fdis&quot;&gt;__builtin_nds32_setgie_dis&lt;/strong&gt;（void）</target>
        </trans-unit>
        <trans-unit id="01c2cb53755ea177e9b7bcabfb291e59bf8c8d8b" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005fnds32_005fsetgie_005fen&quot;&gt;__builtin_nds32_setgie_en&lt;/strong&gt; (void)</source>
          <target state="translated">内置函数：void &lt;strong id=&quot;index-_005f_005fbuiltin_005fnds32_005fsetgie_005fen&quot;&gt;__builtin_nds32_setgie_zh&lt;/strong&gt;（void）</target>
        </trans-unit>
        <trans-unit id="2f23c91db2e471b60a85c1d974b337410d93c4ae" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005fnon_005ftx_005fstore&quot;&gt;__builtin_non_tx_store&lt;/strong&gt; (uint64_t *, uint64_t)</source>
          <target state="translated">内置函数：void &lt;strong id=&quot;index-_005f_005fbuiltin_005fnon_005ftx_005fstore&quot;&gt;__builtin_non_tx_store&lt;/strong&gt;（uint64_t *，uint64_t）</target>
        </trans-unit>
        <trans-unit id="2321505821d1604108a7105b3b6858f231f0c9ea" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005fprefetch&quot;&gt;__builtin_prefetch&lt;/strong&gt; (const void *&lt;var&gt;addr&lt;/var&gt;, ...)</source>
          <target state="translated">内置函数：void &lt;strong id=&quot;index-_005f_005fbuiltin_005fprefetch&quot;&gt;__builtin_prefetch&lt;/strong&gt;（const void * &lt;var&gt;addr&lt;/var&gt; ，...）</target>
        </trans-unit>
        <trans-unit id="fe3fc0ac7968932105d1c1d3ab50d7b85cfe594b" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005freturn&quot;&gt;__builtin_return&lt;/strong&gt; (void *&lt;var&gt;result&lt;/var&gt;)</source>
          <target state="translated">内置函数：void &lt;strong id=&quot;index-_005f_005fbuiltin_005freturn&quot;&gt;__builtin_return&lt;/strong&gt;（void * &lt;var&gt;result&lt;/var&gt; ）</target>
        </trans-unit>
        <trans-unit id="a1a8dfdf0491f60d9f3285d8de87cb556335dd7c" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005fbrk&quot;&gt;__builtin_rx_brk&lt;/strong&gt; (void)</source>
          <target state="translated">内置函数：void &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005fbrk&quot;&gt;__builtin_rx_brk&lt;/strong&gt;（void）</target>
        </trans-unit>
        <trans-unit id="baafeee4f82f6b2b3615bbf58d2dd0b69de47091" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005fclrpsw&quot;&gt;__builtin_rx_clrpsw&lt;/strong&gt; (int)</source>
          <target state="translated">内置函数：void &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005fclrpsw&quot;&gt;__builtin_rx_clrpsw&lt;/strong&gt;（int）</target>
        </trans-unit>
        <trans-unit id="40ac58e52ec8cfeb1ed0ce17f884d6ca28de4bb2" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005fint&quot;&gt;__builtin_rx_int&lt;/strong&gt; (int)</source>
          <target state="translated">内置函数：void &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005fint&quot;&gt;__builtin_rx_int&lt;/strong&gt;（int）</target>
        </trans-unit>
        <trans-unit id="60f5dc479a3c9ca583cab1eca4c28279f3d7220a" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005fmachi&quot;&gt;__builtin_rx_machi&lt;/strong&gt; (int, int)</source>
          <target state="translated">内置函数：void &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005fmachi&quot;&gt;__builtin_rx_machi&lt;/strong&gt;（int，int）</target>
        </trans-unit>
        <trans-unit id="8e28f28fffe61c4b4679e59b89330fa5d0042874" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005fmaclo&quot;&gt;__builtin_rx_maclo&lt;/strong&gt; (int, int)</source>
          <target state="translated">内置函数：void &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005fmaclo&quot;&gt;__builtin_rx_maclo&lt;/strong&gt;（int，int）</target>
        </trans-unit>
        <trans-unit id="46c536195bce3a86157c9c49ee77c45d3577dcc4" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005fmulhi&quot;&gt;__builtin_rx_mulhi&lt;/strong&gt; (int, int)</source>
          <target state="translated">内置函数：void &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005fmulhi&quot;&gt;__builtin_rx_mulhi&lt;/strong&gt;（int，int）</target>
        </trans-unit>
        <trans-unit id="5621acbcbc1163f811efb159aa50ed209c490ad9" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005fmullo&quot;&gt;__builtin_rx_mullo&lt;/strong&gt; (int, int)</source>
          <target state="translated">内置函数：void &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005fmullo&quot;&gt;__builtin_rx_mullo&lt;/strong&gt;（int，int）</target>
        </trans-unit>
        <trans-unit id="227762640b3aca70bd083850fd27548557a69595" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005fmvtachi&quot;&gt;__builtin_rx_mvtachi&lt;/strong&gt; (int)</source>
          <target state="translated">内置函数：void &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005fmvtachi&quot;&gt;__builtin_rx_mvtachi&lt;/strong&gt;（int）</target>
        </trans-unit>
        <trans-unit id="4eefd425b2ddf508a48e8a2189b6454058653fea" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005fmvtaclo&quot;&gt;__builtin_rx_mvtaclo&lt;/strong&gt; (int)</source>
          <target state="translated">内置函数：void &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005fmvtaclo&quot;&gt;__builtin_rx_mvtaclo&lt;/strong&gt;（int）</target>
        </trans-unit>
        <trans-unit id="662dad4c2fd795f4f1dddab9d3e0737c1c8a5708" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005fmvtc&quot;&gt;__builtin_rx_mvtc&lt;/strong&gt; (int reg, int val)</source>
          <target state="translated">内置函数：void &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005fmvtc&quot;&gt;__builtin_rx_mvtc&lt;/strong&gt;（int reg，int val）</target>
        </trans-unit>
        <trans-unit id="276391cb278528b1f872b1280affb29edbd7927c" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005fmvtipl&quot;&gt;__builtin_rx_mvtipl&lt;/strong&gt; (int)</source>
          <target state="translated">内置函数：void &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005fmvtipl&quot;&gt;__builtin_rx_mvtipl&lt;/strong&gt;（int）</target>
        </trans-unit>
        <trans-unit id="700036ac6c5189b95316dbc5c4ae3b0309325df1" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005fracw&quot;&gt;__builtin_rx_racw&lt;/strong&gt; (int)</source>
          <target state="translated">内置函数：void &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005fracw&quot;&gt;__builtin_rx_racw&lt;/strong&gt;（int）</target>
        </trans-unit>
        <trans-unit id="c48b2b82b14ae8b91fdb2fe28e06b8ea0b1cb522" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005frmpa&quot;&gt;__builtin_rx_rmpa&lt;/strong&gt; (void)</source>
          <target state="translated">内置函数：void &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005frmpa&quot;&gt;__builtin_rx_rmpa&lt;/strong&gt;（void）</target>
        </trans-unit>
        <trans-unit id="4595d30c690a3b8c89c7807c08a9959f30d56800" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005fround&quot;&gt;__builtin_rx_round&lt;/strong&gt; (float)</source>
          <target state="translated">内置函数：void &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005fround&quot;&gt;__builtin_rx_round&lt;/strong&gt;（float）</target>
        </trans-unit>
        <trans-unit id="c5948033a96e4003655c71953e27a3f9741045b3" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005fsetpsw&quot;&gt;__builtin_rx_setpsw&lt;/strong&gt; (int)</source>
          <target state="translated">内置函数：void &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005fsetpsw&quot;&gt;__builtin_rx_setpsw&lt;/strong&gt;（int）</target>
        </trans-unit>
        <trans-unit id="f89dbf6d50890784687748f168df8d729aebf79c" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005fwait&quot;&gt;__builtin_rx_wait&lt;/strong&gt; (void)</source>
          <target state="translated">内置函数：void &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005fwait&quot;&gt;__builtin_rx_wait&lt;/strong&gt;（void）</target>
        </trans-unit>
        <trans-unit id="95b218b72a2c6b938556ce1a8c8a3cca255a13b1" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005fset_005fthread_005fpointer&quot;&gt;__builtin_set_thread_pointer&lt;/strong&gt; (void *&lt;var&gt;ptr&lt;/var&gt;)</source>
          <target state="translated">内置函数：void &lt;strong id=&quot;index-_005f_005fbuiltin_005fset_005fthread_005fpointer&quot;&gt;__builtin_set_thread_pointer&lt;/strong&gt;（void * &lt;var&gt;ptr&lt;/var&gt; ）</target>
        </trans-unit>
        <trans-unit id="2db4725d0eae1acd204db5ae18744d85101db3ea" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005fsh_005fset_005ffpscr&quot;&gt;__builtin_sh_set_fpscr&lt;/strong&gt; (unsigned int &lt;var&gt;val&lt;/var&gt;)</source>
          <target state="translated">内置函数：void &lt;strong id=&quot;index-_005f_005fbuiltin_005fsh_005fset_005ffpscr&quot;&gt;__builtin_sh_set_fpscr&lt;/strong&gt;（unsigned int &lt;var&gt;val&lt;/var&gt; ）</target>
        </trans-unit>
        <trans-unit id="f9baaf9b0798ed586e63831552a408b61b1a992c" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005ftabort&quot;&gt;__builtin_tabort&lt;/strong&gt; (int)</source>
          <target state="translated">内置函数：void &lt;strong id=&quot;index-_005f_005fbuiltin_005ftabort&quot;&gt;__builtin_tabort&lt;/strong&gt;（int）</target>
        </trans-unit>
        <trans-unit id="d228c7f65857695f955c2630b92714965d36378f" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005ftbeginc&quot;&gt;__builtin_tbeginc&lt;/strong&gt; (void)</source>
          <target state="translated">内置函数：void &lt;strong id=&quot;index-_005f_005fbuiltin_005ftbeginc&quot;&gt;__builtin_tbeginc&lt;/strong&gt;（void）</target>
        </trans-unit>
        <trans-unit id="94689ecdbd4d60ff7b0fd602ce7245bc7b6beb10" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005ftrap&quot;&gt;__builtin_trap&lt;/strong&gt; (void)</source>
          <target state="translated">内置函数：void &lt;strong id=&quot;index-_005f_005fbuiltin_005ftrap&quot;&gt;__builtin_trap&lt;/strong&gt;（void）</target>
        </trans-unit>
        <trans-unit id="4a1c671de0baf7c15aaf53f248312afd293d5b33" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005ftx_005fassist&quot;&gt;__builtin_tx_assist&lt;/strong&gt; (int)</source>
          <target state="translated">内置函数：void &lt;strong id=&quot;index-_005f_005fbuiltin_005ftx_005fassist&quot;&gt;__builtin_tx_assist&lt;/strong&gt;（int）</target>
        </trans-unit>
        <trans-unit id="5904be3f2c9a60beac8be0103847c267a6f80e80" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005funreachable&quot;&gt;__builtin_unreachable&lt;/strong&gt; (void)</source>
          <target state="translated">内置函数：void &lt;strong id=&quot;index-_005f_005fbuiltin_005funreachable&quot;&gt;__builtin_unreachable&lt;/strong&gt;（void）</target>
        </trans-unit>
        <trans-unit id="836cf5a0e71cae3a60324503179866ad686508a7" translate="yes" xml:space="preserve">
          <source>Built-in functions for limited buffer overflow checking.</source>
          <target state="translated">内置功能,用于有限的缓冲区溢出检查。</target>
        </trans-unit>
        <trans-unit id="d4b5ba0eb7000fc998fff5b209a2516ba2e54a3f" translate="yes" xml:space="preserve">
          <source>Built-in functions specific to particular targets.</source>
          <target state="translated">针对特定目标的内置功能。</target>
        </trans-unit>
        <trans-unit id="253258e2e82600175022e888019e1f8e9ab9c3a1" translate="yes" xml:space="preserve">
          <source>Built-in functions to perform arithmetics and arithmetic overflow checking.</source>
          <target state="translated">内建函数来执行算术和算术溢出检查。</target>
        </trans-unit>
        <trans-unit id="4708bb7371d5b0f788e5028a015745453830a6ee" translate="yes" xml:space="preserve">
          <source>Built-in macros, macros defined on the command line, and macros defined in include files are not warned about.</source>
          <target state="translated">内置宏、在命令行定义的宏和在include文件中定义的宏都不会被警告。</target>
        </trans-unit>
        <trans-unit id="606b68375f39bb1e243e870d45cdf01eab0caad3" translate="yes" xml:space="preserve">
          <source>But if you need to debug a problem with method signatures and need to know how they are implemented (i.e., the &amp;ldquo;ABI&amp;rdquo;), read on.</source>
          <target state="translated">但是，如果您需要调试方法签名的问题，并且需要知道如何实现它们（即&amp;ldquo; ABI&amp;rdquo;），请继续阅读。</target>
        </trans-unit>
        <trans-unit id="18ba03b4395ba58ba0713d75a0907aa6ed34a2f6" translate="yes" xml:space="preserve">
          <source>But in the definition of &lt;code&gt;foo&lt;/code&gt;, the file-scope type is used because that is available to be inherited. Thus, the definition and the prototype do not match, and you get an error.</source>
          <target state="translated">但是在 &lt;code&gt;foo&lt;/code&gt; 的定义中，使用了文件作用域类型，因为它可以被继承。因此，定义和原型不匹配，并且会出现错误。</target>
        </trans-unit>
        <trans-unit id="54f71fd5d9e178736a8b25951cca5312e798d273" translate="yes" xml:space="preserve">
          <source>But in this example, the &lt;code&gt;std::move&lt;/code&gt; call prevents copy elision.</source>
          <target state="translated">但是在此示例中， &lt;code&gt;std::move&lt;/code&gt; 调用可防止复制省略。</target>
        </trans-unit>
        <trans-unit id="cf56c043a9173e054f17c75c7e06c6a5d352b771" translate="yes" xml:space="preserve">
          <source>But this definition computes either &lt;var id=&quot;index-side-effects_002c-macro-argument&quot;&gt;a&lt;/var&gt; or &lt;var&gt;b&lt;/var&gt; twice, with bad results if the operand has side effects. In GNU C, if you know the type of the operands (here taken as &lt;code&gt;int&lt;/code&gt;), you can avoid this problem by defining the macro as follows:</source>
          <target state="translated">但是此定义计算 &lt;var id=&quot;index-side-effects_002c-macro-argument&quot;&gt;a&lt;/var&gt; 或 &lt;var&gt;b&lt;/var&gt; 两次，如果操作数有副作用，则结果会很差。在GNU C中，如果您知道操作数的类型（此处为 &lt;code&gt;int&lt;/code&gt; ），则可以通过如下定义宏来避免此问题：</target>
        </trans-unit>
        <trans-unit id="089c24745336688f5099a4bd50557aedc8fc6fff" translate="yes" xml:space="preserve">
          <source>By contrast, PCC on most target machines returns structures and unions of any size by copying the data into an area of static storage, and then returning the address of that storage as if it were a pointer value. The caller must copy the data from that memory area to the place where the value is wanted. GCC does not use this method because it is slower and nonreentrant.</source>
          <target state="translated">相比之下,大多数目标机上的PCC通过将数据复制到静态存储区域中,然后像返回指针值一样返回该存储区域的地址,从而返回任意大小的结构和联合。调用者必须将数据从那个存储区域复制到想要值的地方。GCC不使用这种方法,因为它比较慢而且不重入。</target>
        </trans-unit>
        <trans-unit id="8e8864b0dc6da1e44443610d33567bb75bb81d17" translate="yes" xml:space="preserve">
          <source>By declaring a function inline, you can direct GCC to make calls to that function faster. One way GCC can achieve this is to integrate that function&amp;rsquo;s code into the code for its callers. This makes execution faster by eliminating the function-call overhead; in addition, if any of the actual argument values are constant, their known values may permit simplifications at compile time so that not all of the inline function&amp;rsquo;s code needs to be included. The effect on code size is less predictable; object code may be larger or smaller with function inlining, depending on the particular case. You can also direct GCC to try to integrate all &amp;ldquo;simple enough&amp;rdquo; functions into their callers with the option</source>
          <target state="translated">通过声明一个函数内联，您可以指示GCC更快地调用该函数。 GCC可以做到这一点的一种方法是将该函数的代码集成到其调用者的代码中。通过消除函数调用开销，这使执行速度更快。另外，如果任何实际参数值是恒定的，则它们的已知值可能会在编译时进行简化，因此不必包括所有内联函数的代码。对代码大小的影响难以预测。根据具体情况，使用函数内联可以使目标代码更大或更小。您还可以指示GCC尝试使用选项将所有&amp;ldquo;足够简单&amp;rdquo;的功能集成到其调用方中</target>
        </trans-unit>
        <trans-unit id="571c61d917cc3bc4c5e2835a5dd40c5c41bd768f" translate="yes" xml:space="preserve">
          <source>By default (unless configured otherwise), GCC generates code for the GR5 variant of the Visium architecture.</source>
          <target state="translated">默认情况下(除非另有配置),GCC会生成Visium架构的GR5变体的代码。</target>
        </trans-unit>
        <trans-unit id="8ff1bd96a4bdcc76b002de9ee97861c9f804a0dc" translate="yes" xml:space="preserve">
          <source>By default (unless configured otherwise), GCC generates code for the V7 variant of the SPARC architecture. With</source>
          <target state="translated">默认情况下(除非另有配置),GCC生成SPARC架构V7变体的代码。如果使用</target>
        </trans-unit>
        <trans-unit id="44c806b35c6f92efecb7ce7748b95c7a4f87c40c" translate="yes" xml:space="preserve">
          <source>By default GCC inlines string operations only when the destination is known to be aligned to least a 4-byte boundary. This enables more inlining and increases code size, but may improve performance of code that depends on fast &lt;code&gt;memcpy&lt;/code&gt; and &lt;code&gt;memset&lt;/code&gt; for short lengths. The option enables inline expansion of &lt;code&gt;strlen&lt;/code&gt; for all pointer alignments.</source>
          <target state="translated">默认情况下，仅当已知目标与至少4个字节的边界对齐时，GCC才会内联字符串操作。这样可以进行更多的内联并增加代码大小，但可以提高依赖于快速 &lt;code&gt;memcpy&lt;/code&gt; 和 &lt;code&gt;memset&lt;/code&gt; 的短长度代码的性能。该选项为所有指针对齐启用 &lt;code&gt;strlen&lt;/code&gt; 的内联扩展。</target>
        </trans-unit>
        <trans-unit id="ee5c102e65c6f170a209b204a4dbc9b094f06846" translate="yes" xml:space="preserve">
          <source>By default GCC inlines string operations only when the destination is known to be aligned to least a 4-byte boundary. This enables more inlining and increases code size, but may improve performance of code that depends on fast &lt;code&gt;memcpy&lt;/code&gt;, &lt;code&gt;strlen&lt;/code&gt;, and &lt;code&gt;memset&lt;/code&gt; for short lengths.</source>
          <target state="translated">默认情况下，仅当已知目标与至少4个字节的边界对齐时，GCC才会内联字符串操作。这样可以进行更多的内联并增加代码大小，但是可以提高依赖于快速 &lt;code&gt;memcpy&lt;/code&gt; ， &lt;code&gt;strlen&lt;/code&gt; 和 &lt;code&gt;memset&lt;/code&gt; 的短长度代码的性能。</target>
        </trans-unit>
        <trans-unit id="828f5d805ef0fc5866d738b0ffbff970c7d7f41f" translate="yes" xml:space="preserve">
          <source>By default assume that all calls are far away so that a longer and more expensive calling sequence is required. This is required for calls farther than 32 megabytes (33,554,432 bytes) from the current location. A short call is generated if the compiler knows the call cannot be that far away. This setting can be overridden by the &lt;code&gt;shortcall&lt;/code&gt; function attribute, or by &lt;code&gt;#pragma
longcall(0)&lt;/code&gt;.</source>
          <target state="translated">默认情况下，假设所有呼叫都在远处，因此需要更长和更昂贵的呼叫顺序。对于距离当前位置超过32兆字节（33,554,432字节）的呼叫，这是必需的。如果编译器知道该调用不能那么远，则会生成一个短调用。可以通过 &lt;code&gt;shortcall&lt;/code&gt; 函数属性或 &lt;code&gt;#pragma longcall(0)&lt;/code&gt; 覆盖此设置。</target>
        </trans-unit>
        <trans-unit id="e7d64d02eb42b84df503cac7606206757e75fdfc" translate="yes" xml:space="preserve">
          <source>By default instance variables in Objective-C can be accessed as if they were local variables from within the methods of the class they&amp;rsquo;re declared in. This can lead to shadowing between instance variables and other variables declared either locally inside a class method or globally with the same name. Specifying the</source>
          <target state="translated">默认情况下，可以访问Objective-C中的实例变量，就好像它们是在声明它们的类的方法内是局部变量一样。这可能导致实例变量与其他在类方法内部或全局声明的变量之间产生阴影。同名。指定</target>
        </trans-unit>
        <trans-unit id="812f601802f8d41b61d44c3f0bd220d17f966e00" translate="yes" xml:space="preserve">
          <source>By default it is treated as &lt;code&gt;signed int&lt;/code&gt; but this may be changed by the</source>
          <target state="translated">默认情况下，它被视为有 &lt;code&gt;signed int&lt;/code&gt; 但这可能会被</target>
        </trans-unit>
        <trans-unit id="42ef9328c623bad5538b4f26249da5459c5c08d3" translate="yes" xml:space="preserve">
          <source>By default or when</source>
          <target state="translated">默认情况下或当</target>
        </trans-unit>
        <trans-unit id="3fa72f6f9c5a94c5d09caf64d4a1e9c339e8bb7c" translate="yes" xml:space="preserve">
          <source>By default the analyzer attempts to simplify analysis by merging sufficiently similar states at each program point as it builds its &amp;ldquo;exploded graph&amp;rdquo;. With</source>
          <target state="translated">默认情况下，分析仪会在构建&amp;ldquo;爆炸图&amp;rdquo;时尝试通过在每个程序点处合并足够相似的状态来简化分析。和</target>
        </trans-unit>
        <trans-unit id="238d21ed5942f525fb456a138be81dac5934eca2" translate="yes" xml:space="preserve">
          <source>By default the analyzer attempts to simplify analysis by purging aspects of state at a program point that appear to no longer be relevant e.g. the values of locals that aren&amp;rsquo;t accessed later in the function and which aren&amp;rsquo;t relevant to leak analysis.</source>
          <target state="translated">默认情况下，分析器尝试通过清除似乎不再相关的程序点处的状态来简化分析，例如，在函数中稍后无法访问且与泄漏分析不相关的局部值。</target>
        </trans-unit>
        <trans-unit id="c9b76575429db7ab5c66debc083d774f7e949e1c" translate="yes" xml:space="preserve">
          <source>By default this feature is not enabled. The default can be restored via the</source>
          <target state="translated">默认情况下,该功能未被启用。默认值可以通过</target>
        </trans-unit>
        <trans-unit id="be7bad4b8f0ace00e1f8f2cdea4bdacee4c90882" translate="yes" xml:space="preserve">
          <source>By default when the C++ frontend prints diagnostics showing mismatching template types, common parts of the types are printed as &amp;ldquo;[...]&amp;rdquo; to simplify the error message. For example:</source>
          <target state="translated">默认情况下，当C ++前端打印出显示模板类型不匹配的诊断信息时，这些类型的公共部分将打印为&amp;ldquo; [...]&amp;rdquo;以简化错误消息。例如：</target>
        </trans-unit>
        <trans-unit id="e5c0fdbe4acada00b33542c8af5765b2142c6787" translate="yes" xml:space="preserve">
          <source>By default, GCC also provides some additional extensions to the C++ language that on rare occasions conflict with the C++ standard. See &lt;a href=&quot;c_002b_002b-dialect-options#C_002b_002b-Dialect-Options&quot;&gt;Options Controlling C++ Dialect&lt;/a&gt;. Use of the</source>
          <target state="translated">默认情况下，GCC还为C ++语言提供了一些其他扩展，这些扩展在极少数情况下与C ++标准冲突。请参阅&lt;a href=&quot;c_002b_002b-dialect-options#C_002b_002b-Dialect-Options&quot;&gt;控制C ++语言的选项&lt;/a&gt;。使用</target>
        </trans-unit>
        <trans-unit id="1b721c8be1fed47cd95a2b324cc0ec1f3f3fd2db" translate="yes" xml:space="preserve">
          <source>By default, GCC emits an error message if the feedback profiles do not match the source code. This error can be turned into a warning by using</source>
          <target state="translated">默认情况下,如果反馈配置文件与源代码不匹配,GCC会发出一条错误信息。这个错误可以通过使用</target>
        </trans-unit>
        <trans-unit id="68205120aabfb538f7bc7f4202c9b447a1cf9091" translate="yes" xml:space="preserve">
          <source>By default, GCC generates a branch hint instruction to avoid pipeline stalls for always-taken or probably-taken branches. A hint is not generated closer than 8 instructions away from its branch. There is little reason to disable them, except for debugging purposes, or to make an object a little bit smaller.</source>
          <target state="translated">默认情况下,GCC会生成一个分支提示指令,以避免总是被占用或可能被占用的分支出现管道停顿。在距离分支超过8条指令的地方,不会生成提示指令。除了为了调试的目的,或者为了让对象变得更小一点,没有什么理由禁用它们。</target>
        </trans-unit>
        <trans-unit id="0f0fae0fc27ffb4e00a4f068905f564a20595bd8" translate="yes" xml:space="preserve">
          <source>By default, GCC generates code assuming that addresses are never larger than 18 bits. With</source>
          <target state="translated">默认情况下,GCC生成的代码假定地址永远不会大于18位。如果使用</target>
        </trans-unit>
        <trans-unit id="bfc14d5fdff5ebfd96cb93f60f01d2cd55db824a" translate="yes" xml:space="preserve">
          <source>By default, GCC ignores trigraphs, but in standard-conforming modes it converts them. See the</source>
          <target state="translated">默认情况下,GCC会忽略三角图,但在符合标准的模式下,它会转换三角图。参见</target>
        </trans-unit>
        <trans-unit id="7b2b09a4a457e7ae05463c18b24ed251756826ce" translate="yes" xml:space="preserve">
          <source>By default, GCC inserts NOPs to increase dual issue when it expects it to increase performance. &lt;var&gt;n&lt;/var&gt; can be a value from 0 to 10. A smaller &lt;var&gt;n&lt;/var&gt; inserts fewer NOPs. 10 is the default, 0 is the same as</source>
          <target state="translated">默认情况下，当GCC希望提高性能时，会插入NOP来增加双重问题。 &lt;var&gt;n&lt;/var&gt; 可以是0到10之间的值。较小的 &lt;var&gt;n&lt;/var&gt; 插入较少的NOP。默认值为10，0等于</target>
        </trans-unit>
        <trans-unit id="fb6ff38e6ed640debf4ee9a5067811f24a626ac7" translate="yes" xml:space="preserve">
          <source>By default, GCC limits the size of functions that can be inlined. This flag allows coarse control of this limit. &lt;var&gt;n&lt;/var&gt; is the size of functions that can be inlined in number of pseudo instructions.</source>
          <target state="translated">默认情况下，GCC限制可以内联的函数的大小。该标志允许对该限制进行粗略控制。 &lt;var&gt;n&lt;/var&gt; 是可以内嵌在伪指令数量中的函数的大小。</target>
        </trans-unit>
        <trans-unit id="9bf107b2c0510e1f5a934dedd69183ab9f3da713" translate="yes" xml:space="preserve">
          <source>By default, GCC links against startup code that assumes the SPU-style main function interface (which has an unconventional parameter list). With</source>
          <target state="translated">默认情况下,GCC会针对假定使用SPU风格的主函数接口(它有一个非常规的参数列表)的启动代码进行链接。如果使用</target>
        </trans-unit>
        <trans-unit id="7b2fda2cbe2c03ae974fe1e7172dd8c82c7ece3a" translate="yes" xml:space="preserve">
          <source>By default, GCC provides some extensions to the C language that, on rare occasions conflict with the C standard. See &lt;a href=&quot;c-extensions#C-Extensions&quot;&gt;Extensions to the C Language Family&lt;/a&gt;. Some features that are part of the C99 standard are accepted as extensions in C90 mode, and some features that are part of the C11 standard are accepted as extensions in C90 and C99 modes. Use of the</source>
          <target state="translated">默认情况下，GCC提供了一些C语言扩展，在极少数情况下会与C标准冲突。请参见&lt;a href=&quot;c-extensions#C-Extensions&quot;&gt;C语言家族的扩展&lt;/a&gt;。在C90模式下，某些扩展功能被接受为C99标准的一部分，在C90和C99模式下，某些扩展功能被接受为C11标准的一部分。使用</target>
        </trans-unit>
        <trans-unit id="9893f2e72481c2382557fc2f081ec3a8e97bc79b" translate="yes" xml:space="preserve">
          <source>By default, an edge in this graph can contain the effects of a run of multiple statements within a basic block. With</source>
          <target state="translated">默认情况下,该图中的一条边可以包含一个基本块中多条语句的运行效果。有了这条边,就可以在一个基本块中包含多个语句的运行效果。</target>
        </trans-unit>
        <trans-unit id="2e7c9e5570dcde91269bdc30909a64efa434ef4f" translate="yes" xml:space="preserve">
          <source>By default, each diagnostic emitted includes text indicating the command-line option that directly controls the diagnostic (if such an option is known to the diagnostic machinery). Specifying the</source>
          <target state="translated">默认情况下,每个诊断器发出的文本包括指示直接控制诊断器的命令行选项的文本(如果诊断器知道有这样的选项)。指定</target>
        </trans-unit>
        <trans-unit id="6a4309cf8cee66811505f90edea42d61f9045107" translate="yes" xml:space="preserve">
          <source>By default, each diagnostic emitted includes the original source line and a caret &amp;lsquo;</source>
          <target state="translated">默认情况下，发出的每个诊断都包括原始源代码行和插入符号'</target>
        </trans-unit>
        <trans-unit id="bac331913dd18e98186423b1f11ca77a9b8683cf" translate="yes" xml:space="preserve">
          <source>By default, no debug information is produced for symbols that are not actually used. Use this option if you want debug information for all symbols.</source>
          <target state="translated">默认情况下,对于没有实际使用的符号,不会产生调试信息。如果想要所有符号的调试信息,请使用此选项。</target>
        </trans-unit>
        <trans-unit id="7763701cba03a5661d0405bf0959714c47202a4e" translate="yes" xml:space="preserve">
          <source>By default, only &amp;ldquo;high-level&amp;rdquo; messages are emitted. This option enables additional, more detailed, messages, which are likely to only be of interest to GCC developers.</source>
          <target state="translated">默认情况下，仅发出&amp;ldquo;高级&amp;rdquo;消息。此选项启用其他更详细的消息，这些消息可能仅对GCC开发人员感兴趣。</target>
        </trans-unit>
        <trans-unit id="98a82faa0eba738f33fea70355cca2f77f4d752d" translate="yes" xml:space="preserve">
          <source>By default, the analysis silently stops if the code is too complicated for the analyzer to fully explore and it reaches an internal limit. The</source>
          <target state="translated">默认情况下,如果代码太复杂,分析器无法完全探索,达到内部极限,分析就会默默停止。在</target>
        </trans-unit>
        <trans-unit id="7d31796fedde16b57588ddd5284b3abd8463c996" translate="yes" xml:space="preserve">
          <source>By default, the assembler file name for a source file is made by replacing the suffix &amp;lsquo;</source>
          <target state="translated">默认情况下，源文件的汇编文件名是通过替换后缀'</target>
        </trans-unit>
        <trans-unit id="10caadf2568f37c4e4608d0c62719e2855118ce6" translate="yes" xml:space="preserve">
          <source>By default, the dump will contain messages about successful optimizations (equivalent to</source>
          <target state="translated">默认情况下,dump将包含关于成功优化的消息(相当于</target>
        </trans-unit>
        <trans-unit id="ae9a2b16ff551e2f7ff627c2fd6228056bed25a8" translate="yes" xml:space="preserve">
          <source>By default, the keyword &lt;code&gt;__vector&lt;/code&gt; is added. The macro &lt;code&gt;vector&lt;/code&gt; is defined in &lt;code&gt;&amp;lt;spu_intrinsics.h&amp;gt;&lt;/code&gt; and can be undefined.</source>
          <target state="translated">默认情况下，添加关键字 &lt;code&gt;__vector&lt;/code&gt; 。宏 &lt;code&gt;vector&lt;/code&gt; 在 &lt;code&gt;&amp;lt;spu_intrinsics.h&amp;gt;&lt;/code&gt; 中定义，可以不确定。</target>
        </trans-unit>
        <trans-unit id="b102924aa2fe89599576741a2bd8c5becb0889f6" translate="yes" xml:space="preserve">
          <source>By default, the object file name for a source file is made by replacing the suffix &amp;lsquo;</source>
          <target state="translated">默认情况下，源文件的目标文件名是通过替换后缀'</target>
        </trans-unit>
        <trans-unit id="4e689c10c02894b0d8e0dcec9a7f6bd5f47a0486" translate="yes" xml:space="preserve">
          <source>By default, when printing source code (via</source>
          <target state="translated">默认情况下,当打印源代码时(通过</target>
        </trans-unit>
        <trans-unit id="f618b8855eb83706e0dd5ba4b20f8784c6acdce1" translate="yes" xml:space="preserve">
          <source>Byte swap. Return the result of swapping the upper and lower bytes of &lt;var&gt;value&lt;/var&gt;.</source>
          <target state="translated">字节交换。返回交换 &lt;var&gt;value&lt;/var&gt; 的高低字节的结果。</target>
        </trans-unit>
        <trans-unit id="32096c2e0eff33d844ee6d675407ace18289357d" translate="yes" xml:space="preserve">
          <source>C</source>
          <target state="translated">C</target>
        </trans-unit>
        <trans-unit id="8c7f20acc9bb2d58739f2e1f94cb9494f549d093" translate="yes" xml:space="preserve">
          <source>C Language Options</source>
          <target state="translated">C语言选项</target>
        </trans-unit>
        <trans-unit id="4f2345e5746cc2edc7fabec343cb3f91233c3786" translate="yes" xml:space="preserve">
          <source>C and Objective-C-only Warning Options</source>
          <target state="translated">只有C和Objective-C的警告选项</target>
        </trans-unit>
        <trans-unit id="a16bcf14a78c44b6bfc6c36207ff504cb459f2ef" translate="yes" xml:space="preserve">
          <source>C code</source>
          <target state="translated">C码</target>
        </trans-unit>
        <trans-unit id="43bd1aa29c2f227114eb9168f3aeb20a853ce287" translate="yes" xml:space="preserve">
          <source>C contains many standard functions that return a value that most programs choose to ignore. One obvious example is &lt;code&gt;printf&lt;/code&gt;. Warning about this practice only leads the defensive programmer to clutter programs with dozens of casts to &lt;code&gt;void&lt;/code&gt;. Such casts are required so frequently that they become visual noise. Writing those casts becomes so automatic that they no longer convey useful information about the intentions of the programmer. For functions where the return value should never be ignored, use the &lt;code&gt;warn_unused_result&lt;/code&gt; function attribute (see &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;Function Attributes&lt;/a&gt;).</source>
          <target state="translated">C包含许多标准函数，这些函数返回大多数程序选择忽略的值。一个明显的例子是 &lt;code&gt;printf&lt;/code&gt; 。对这种做法的警告仅会使防御性程序员陷入混乱的程序，数十次强制转换 &lt;code&gt;void&lt;/code&gt; 。如此频繁地需要这样的演员，以至于它们变成视觉噪音。编写这些强制类型转换变得非常自动，以致它们不再传达有关程序员意图的有用信息。对于不应忽略返回值的函数，请使用 &lt;code&gt;warn_unused_result&lt;/code&gt; 函数属性（请参见&lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;函数属性&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="b3d334ba58e80b66d4161266b799ef1fa9dce232" translate="yes" xml:space="preserve">
          <source>C flag clear or unsigned less than</source>
          <target state="translated">C 标志清除或无符号小于</target>
        </trans-unit>
        <trans-unit id="aa17b2be06e6856744ee3e4f2479342954c18298" translate="yes" xml:space="preserve">
          <source>C flag set or unsigned greater than equal</source>
          <target state="translated">C标志设置或无符号大于等于</target>
        </trans-unit>
        <trans-unit id="6cc85e5ef0494952e2e594d8f572f0cb62561829" translate="yes" xml:space="preserve">
          <source>C has the concept of volatile objects. These are normally accessed by pointers and used for accessing hardware or inter-thread communication. The standard encourages compilers to refrain from optimizations concerning accesses to volatile objects, but leaves it implementation defined as to what constitutes a volatile access. The minimum requirement is that at a sequence point all previous accesses to volatile objects have stabilized and no subsequent accesses have occurred. Thus an implementation is free to reorder and combine volatile accesses that occur between sequence points, but cannot do so for accesses across a sequence point. The use of volatile does not allow you to violate the restriction on updating objects multiple times between two sequence points.</source>
          <target state="translated">C语言有易失性对象的概念。这些对象通常由指针访问,用于访问硬件或线程间通信。标准鼓励编译器避免对易失性对象的访问进行优化,但对于什么是易失性访问,则让编译器在实施时加以定义。最低要求是在一个序列点上,之前对易失性对象的所有访问都已经稳定下来,并且没有后续的访问发生。因此,实现可以自由地对序列点之间发生的volatile访问进行重新排序和组合,但不能对跨序列点的访问进行排序和组合。使用volatile不允许违反两个序列点之间多次更新对象的限制。</target>
        </trans-unit>
        <trans-unit id="c49f69bf7866959fd041d254d44ecd95bab5ba98" translate="yes" xml:space="preserve">
          <source>C register.</source>
          <target state="translated">C寄存器。</target>
        </trans-unit>
        <trans-unit id="2327d3d6eb8a5f7ce91755caf9e65d7a2e7dc1de" translate="yes" xml:space="preserve">
          <source>C source code that must be preprocessed.</source>
          <target state="translated">必须进行预处理的C源代码。</target>
        </trans-unit>
        <trans-unit id="61f8a2e0d02a243e776c6bb9750832b606cb81e5" translate="yes" xml:space="preserve">
          <source>C source code that should not be preprocessed.</source>
          <target state="translated">不应预处理的C源代码。</target>
        </trans-unit>
        <trans-unit id="11548c240585bf5af759bc0a6b301b88b353e27e" translate="yes" xml:space="preserve">
          <source>C++ Language Options</source>
          <target state="translated">C++语言选项</target>
        </trans-unit>
        <trans-unit id="57f68a93b1bb79e369d8676d696444f1cbbc7bb2" translate="yes" xml:space="preserve">
          <source>C++ comments are recognized.</source>
          <target state="translated">C++注释被认可。</target>
        </trans-unit>
        <trans-unit id="7f61cc8037210ca9970d93d649a42c41aee100de" translate="yes" xml:space="preserve">
          <source>C++ concepts provide much-improved support for generic programming. In particular, they allow the specification of constraints on template arguments. The constraints are used to extend the usual overloading and partial specialization capabilities of the language, allowing generic data structures and algorithms to be &amp;ldquo;refined&amp;rdquo; based on their properties rather than their type names.</source>
          <target state="translated">C ++概念为通用编程提供了大大改进的支持。特别是，它们允许指定对模板参数的约束。约束用于扩展语言的常规重载和部分专业化功能，从而允许根据通用数据结构和算法的属性（而不是类型名称）&amp;ldquo;完善&amp;rdquo;它们。</target>
        </trans-unit>
        <trans-unit id="98cd14ec337b46f3c719029c11a0be19021fb2b8" translate="yes" xml:space="preserve">
          <source>C++ header file to be turned into a precompiled header or Ada spec.</source>
          <target state="translated">将C++头文件转化为预编译的头文件或Ada规范。</target>
        </trans-unit>
        <trans-unit id="f7bc99762b7f83b6b621c845d769390544ce75a0" translate="yes" xml:space="preserve">
          <source>C++ is a complex language and an evolving one, and its standard definition (the ISO C++ standard) was only recently completed. As a result, your C++ compiler may occasionally surprise you, even when its behavior is correct. This section discusses some areas that frequently give rise to questions of this sort.</source>
          <target state="translated">C++是一门复杂的语言,也是一门不断发展的语言,它的标准定义(ISO C++标准)最近才完成。因此,你的C++编译器可能偶尔会让你感到惊讶,即使它的行为是正确的。本节将讨论一些经常引起这类问题的领域。</target>
        </trans-unit>
        <trans-unit id="e84a747565fa51df782491a580d39e6a3f403239" translate="yes" xml:space="preserve">
          <source>C++ requires information about types to be written out in order to implement &amp;lsquo;</source>
          <target state="translated">C ++要求将有关类型的信息写出来，以实现&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="fda8008d202b2d7ff2b02b361c7ea913221a6d44" translate="yes" xml:space="preserve">
          <source>C++ source code that must be preprocessed. Note that in &amp;lsquo;</source>
          <target state="translated">必须预处理的C ++源代码。请注意，</target>
        </trans-unit>
        <trans-unit id="99fa7c5a2c337828c11bc2c4ade3aae26a30fe89" translate="yes" xml:space="preserve">
          <source>C++ source code that should not be preprocessed.</source>
          <target state="translated">不应预处理的C++源码。</target>
        </trans-unit>
        <trans-unit id="cc9e861072d065eff5c8caf3bd72ac42f37e3e61" translate="yes" xml:space="preserve">
          <source>C++ source files conventionally use one of the suffixes &amp;lsquo;</source>
          <target state="translated">C ++源文件通常使用后缀'</target>
        </trans-unit>
        <trans-unit id="e4d70d761fb7676ae22ebe197ff2d2dd053c553d" translate="yes" xml:space="preserve">
          <source>C++ templates were the first language feature to require more intelligence from the environment than was traditionally found on a UNIX system. Somehow the compiler and linker have to make sure that each template instance occurs exactly once in the executable if it is needed, and not at all otherwise. There are two basic approaches to this problem, which are referred to as the Borland model and the Cfront model.</source>
          <target state="translated">C++模板是第一个要求环境提供比传统的UNIX系统更多智能的语言特性。编译器和链接器必须以某种方式确保每个模板实例在可执行文件中准确地出现一次,如果需要的话,否则完全不需要。有两种基本的方法来解决这个问题,它们被称为Borland模型和Cfront模型。</target>
        </trans-unit>
        <trans-unit id="16bd188cbd64c4bf1a17218266102bf9d269e075" translate="yes" xml:space="preserve">
          <source>C++ virtual functions are implemented in most compilers using a lookup table, known as a vtable. The vtable contains pointers to the virtual functions provided by a class, and each object of the class contains a pointer to its vtable (or vtables, in some multiple-inheritance situations). If the class declares any non-inline, non-pure virtual functions, the first one is chosen as the &amp;ldquo;key method&amp;rdquo; for the class, and the vtable is only emitted in the translation unit where the key method is defined.</source>
          <target state="translated">大多数编译器使用查找表（称为vtable）来实现C ++虚函数。vtable包含指向类提供的虚函数的指针，并且该类的每个对象均包含指向其vtable的指针（在某些多继承情况下，该vtable）。如果该类声明了任何非内联非纯虚函数，则将第一个选择为该类的&amp;ldquo;键方法&amp;rdquo;，并且vtable仅在定义了键方法的转换单元中发出。</target>
        </trans-unit>
        <trans-unit id="17265012fdaf7b797d7862b29ff392331cd3a4a0" translate="yes" xml:space="preserve">
          <source>C++17 provides a standard way to suppress the</source>
          <target state="translated">C++17提供了一种标准的方法来抑制</target>
        </trans-unit>
        <trans-unit id="f78d571177e03968d05d81e87283c743f9bd11eb" translate="yes" xml:space="preserve">
          <source>C, C++, Objective-C or Objective-C++ header file to be turned into a precompiled header (default), or C, C++ header file to be turned into an Ada spec (via the</source>
          <target state="translated">C、C++、Objective-C或Objective-C++头文件要变成预编译的头文件(默认),或C、C++头文件要变成Ada规范(经过</target>
        </trans-unit>
        <trans-unit id="6297518e9deb3ffb36cfb4da17e5731d4f43ddd3" translate="yes" xml:space="preserve">
          <source>C-EUCJP</source>
          <target state="translated">C-EUCJP</target>
        </trans-unit>
        <trans-unit id="fea2102020df627a3fcd18f01c6b90d1d1ebc0a5" translate="yes" xml:space="preserve">
          <source>C-JIS</source>
          <target state="translated">C-JIS</target>
        </trans-unit>
        <trans-unit id="8aed662488c94d21a572d72dd344a0c46e870bc0" translate="yes" xml:space="preserve">
          <source>C-SJIS</source>
          <target state="translated">C-SJIS</target>
        </trans-unit>
        <trans-unit id="e1c33b8c4686460cd515031a9d28c68a3cfcef87" translate="yes" xml:space="preserve">
          <source>C-SKY&amp;mdash;</source>
          <target state="translated">C-SKY&amp;mdash;</target>
        </trans-unit>
        <trans-unit id="e66b4865aad9938d99c99c6f4ab23939ca58e09e" translate="yes" xml:space="preserve">
          <source>C99 Annex F is followed.</source>
          <target state="translated">C99附件F得到了遵守。</target>
        </trans-unit>
        <trans-unit id="0817809900308ce7f22b686082215869550cf931" translate="yes" xml:space="preserve">
          <source>C99 restricted pointers and references.</source>
          <target state="translated">C99限制性指针和引用。</target>
        </trans-unit>
        <trans-unit id="792d9ffa119c05fda74148cc441c8be905361027" translate="yes" xml:space="preserve">
          <source>CALL_INSN</source>
          <target state="translated">CALL_INSN</target>
        </trans-unit>
        <trans-unit id="a4c1d0441ce79e81e5b485ea5fcda7d1c56b743e" translate="yes" xml:space="preserve">
          <source>CB</source>
          <target state="translated">CB</target>
        </trans-unit>
        <trans-unit id="7c9c078a9c0f1169f25be27f38940093778bb37c" translate="yes" xml:space="preserve">
          <source>CET Function: ret_type &lt;strong id=&quot;index-_005fget_005fssp&quot;&gt;_get_ssp&lt;/strong&gt; (void)</source>
          <target state="translated">CET功能：ret_type &lt;strong id=&quot;index-_005fget_005fssp&quot;&gt;_get_ssp&lt;/strong&gt;（无效）</target>
        </trans-unit>
        <trans-unit id="01ab10eefead0e21345d5d4e4f22d758ced4568b" translate="yes" xml:space="preserve">
          <source>CET Function: void &lt;strong id=&quot;index-_005finc_005fssp&quot;&gt;_inc_ssp&lt;/strong&gt; (unsigned int)</source>
          <target state="translated">CET函数：void &lt;strong id=&quot;index-_005finc_005fssp&quot;&gt;_inc_ssp&lt;/strong&gt;（无符号int）</target>
        </trans-unit>
        <trans-unit id="feca3790fce7c96d6df26540c7b4128215a81089" translate="yes" xml:space="preserve">
          <source>CMOV instruction.</source>
          <target state="translated">CMOV指令。</target>
        </trans-unit>
        <trans-unit id="c2711a4d5237b1b481ba6a122e49ae7f80826ead" translate="yes" xml:space="preserve">
          <source>CPU does not have a timebase (eg, 601 and 403gx).</source>
          <target state="translated">CPU没有时基(如601和403gx)。</target>
        </trans-unit>
        <trans-unit id="ca704ae8911deda5afe0231823961924eb739a85" translate="yes" xml:space="preserve">
          <source>CPU has a CELL broadband engine.</source>
          <target state="translated">CPU具有CELL宽带引擎。</target>
        </trans-unit>
        <trans-unit id="4f3f4709b09760afc34be4c56dc4c6225a92c342" translate="yes" xml:space="preserve">
          <source>CPU has a SIMD/Vector Unit.</source>
          <target state="translated">CPU有一个SIMD/Vector单元。</target>
        </trans-unit>
        <trans-unit id="7513f4d098c1065cad2f73416dc6c7b6d28bb7ca" translate="yes" xml:space="preserve">
          <source>CPU has a SPE double precision floating point unit.</source>
          <target state="translated">CPU具有SPE双精度浮点单元。</target>
        </trans-unit>
        <trans-unit id="249044ceb00915a3621d91cc9c9342822f5d3a2e" translate="yes" xml:space="preserve">
          <source>CPU has a SPE single precision floating point unit.</source>
          <target state="translated">CPU具有SPE单精度浮点单元。</target>
        </trans-unit>
        <trans-unit id="afc457a7d1f6c70e1a12a91ad1a70b454e13c88b" translate="yes" xml:space="preserve">
          <source>CPU has a decimal floating point unit.</source>
          <target state="translated">CPU有一个十进制浮点单位。</target>
        </trans-unit>
        <trans-unit id="daecf052e0ef6eddacd32a707988a46a48b10a26" translate="yes" xml:space="preserve">
          <source>CPU has a floating point unit.</source>
          <target state="translated">CPU有一个浮点单位。</target>
        </trans-unit>
        <trans-unit id="e350ba25d5b50e7eecaa8cd017e06461b70e0e96" translate="yes" xml:space="preserve">
          <source>CPU has a memory management unit.</source>
          <target state="translated">CPU有一个内存管理单元。</target>
        </trans-unit>
        <trans-unit id="d25b3ec38c741ef05546cfa00487c01e86a288da" translate="yes" xml:space="preserve">
          <source>CPU has a signal processing extension unit.</source>
          <target state="translated">CPU有一个信号处理扩展单元。</target>
        </trans-unit>
        <trans-unit id="a6cdbd18b45d3ceafe188679188c10b0e63fc06b" translate="yes" xml:space="preserve">
          <source>CPU has hardware transaction memory instructions.</source>
          <target state="translated">CPU有硬件事务存储器指令。</target>
        </trans-unit>
        <trans-unit id="817e69cd99aa2fae8e8cb1ea4ccb1e7cade39e36" translate="yes" xml:space="preserve">
          <source>CPU has unified I/D cache.</source>
          <target state="translated">CPU有统一的I/D缓存。</target>
        </trans-unit>
        <trans-unit id="a85030d258895560b198880492e35a8dc7104678" translate="yes" xml:space="preserve">
          <source>CPU support simultaneous multi-threading.</source>
          <target state="translated">CPU支持同时多线程。</target>
        </trans-unit>
        <trans-unit id="1fa8be29b90ade4bb4d6c9abca15ef4efb5cea12" translate="yes" xml:space="preserve">
          <source>CPU supports 128-bit IEEE binary floating point instructions.</source>
          <target state="translated">CPU支持128位IEEE二进制浮点指令。</target>
        </trans-unit>
        <trans-unit id="d0ec10bc634bb744e9ff5bc9b6ccebe2f8a4c1fd" translate="yes" xml:space="preserve">
          <source>CPU supports 32-bit mode execution.</source>
          <target state="translated">CPU支持32位模式执行。</target>
        </trans-unit>
        <trans-unit id="c550c34cceac587d8bfa3d110ce84630536005e1" translate="yes" xml:space="preserve">
          <source>CPU supports 64-bit mode execution.</source>
          <target state="translated">CPU支持64位模式执行。</target>
        </trans-unit>
        <trans-unit id="969f1a1bfc594794e1d088866f33884cafe4c0a3" translate="yes" xml:space="preserve">
          <source>CPU supports ISA 2.00 (eg, POWER4)</source>
          <target state="translated">CPU支持ISA 2.00(如POWER4)。</target>
        </trans-unit>
        <trans-unit id="f021a7b007d311f22fec3723c62516e8f3a0319b" translate="yes" xml:space="preserve">
          <source>CPU supports ISA 2.02 (eg, POWER5)</source>
          <target state="translated">CPU支持ISA 2.02(例如,POWER5)。</target>
        </trans-unit>
        <trans-unit id="ee64c969eb8481f0eae6c612175233cd07361227" translate="yes" xml:space="preserve">
          <source>CPU supports ISA 2.03 (eg, POWER5+)</source>
          <target state="translated">CPU支持ISA 2.03(例如,POWER5+)。</target>
        </trans-unit>
        <trans-unit id="13964fdc29b60cfc0a706e4cb0569a01c55f1208" translate="yes" xml:space="preserve">
          <source>CPU supports ISA 2.05 (eg, POWER6)</source>
          <target state="translated">CPU支持ISA 2.05(例如,POWER6)。</target>
        </trans-unit>
        <trans-unit id="4ba1460155478447375ae1fb486a30ad51582aec" translate="yes" xml:space="preserve">
          <source>CPU supports ISA 2.05 (eg, POWER6) extended opcodes mffgpr and mftgpr.</source>
          <target state="translated">CPU支持ISA 2.05(例如,POWER6)扩展操作码mffgpr和mftgpr。</target>
        </trans-unit>
        <trans-unit id="990b205fa1433a7d0dc63ad9070ee91af0800dd1" translate="yes" xml:space="preserve">
          <source>CPU supports ISA 2.06 (eg, POWER7)</source>
          <target state="translated">CPU支持ISA 2.06(例如,POWER7)。</target>
        </trans-unit>
        <trans-unit id="6a9081f5b37e7737655ad795c102d5fe7087b65d" translate="yes" xml:space="preserve">
          <source>CPU supports ISA 2.07 (eg, POWER8)</source>
          <target state="translated">CPU支持ISA 2.07(例如,POWER8)。</target>
        </trans-unit>
        <trans-unit id="dcf25ddc902c83eba265e85451df12c824bf2a7b" translate="yes" xml:space="preserve">
          <source>CPU supports ISA 3.0 (eg, POWER9)</source>
          <target state="translated">CPU支持ISA 3.0(例如,POWER9)。</target>
        </trans-unit>
        <trans-unit id="6092133b8e23ee5373746ec5bc5db76ea54238a4" translate="yes" xml:space="preserve">
          <source>CPU supports ISA 3.1 (eg, POWER10)</source>
          <target state="translated">CPU支持ISA 3.1(例如,POWER10)。</target>
        </trans-unit>
        <trans-unit id="055a8304e60c6c298c280b0809896894a417c35e" translate="yes" xml:space="preserve">
          <source>CPU supports a little-endian mode that uses address swizzling.</source>
          <target state="translated">CPU支持使用地址旋转的小恩典模式。</target>
        </trans-unit>
        <trans-unit id="255ddfc220c178db8c2fdf2c3d887268be52afce" translate="yes" xml:space="preserve">
          <source>CPU supports event base branching.</source>
          <target state="translated">CPU支持事件基础分支。</target>
        </trans-unit>
        <trans-unit id="7a546c031cbdf8f942b2e95c5d11fb1b52e9cc57" translate="yes" xml:space="preserve">
          <source>CPU supports hardware transaction memory but does not support the &lt;code&gt;tsuspend.&lt;/code&gt; instruction.</source>
          <target state="translated">CPU支持硬件事务存储器，但不支持 &lt;code&gt;tsuspend.&lt;/code&gt; 指令。</target>
        </trans-unit>
        <trans-unit id="98cc31dee3a3972d6c8549b9b9d63935ff74bd07" translate="yes" xml:space="preserve">
          <source>CPU supports icache snooping capabilities.</source>
          <target state="translated">CPU支持icache snooping功能。</target>
        </trans-unit>
        <trans-unit id="86a7a3dc0108d58ef63d3f6ab2c6e0a72b7c8029" translate="yes" xml:space="preserve">
          <source>CPU supports the &lt;code&gt;darn&lt;/code&gt; (deliver a random number) instruction.</source>
          <target state="translated">CPU支持 &lt;code&gt;darn&lt;/code&gt; （传递随机数）指令。</target>
        </trans-unit>
        <trans-unit id="77d7a3e63ab0326c7992c2322e10e155757df7b2" translate="yes" xml:space="preserve">
          <source>CPU supports the Embedded ISA category.</source>
          <target state="translated">CPU支持嵌入式ISA类别。</target>
        </trans-unit>
        <trans-unit id="c159e0e90690ac6c2f371b7dff8ce2db12767971" translate="yes" xml:space="preserve">
          <source>CPU supports the PA Semi 6T CORE ISA.</source>
          <target state="translated">CPU支持PA Semi 6T CORE ISA。</target>
        </trans-unit>
        <trans-unit id="2267dd90003bf8b5f66bba6f8158082ed6e95240" translate="yes" xml:space="preserve">
          <source>CPU supports the data stream control register.</source>
          <target state="translated">CPU支持数据流控制寄存器。</target>
        </trans-unit>
        <trans-unit id="45a297e9cc9f2eb5df0912ac8e91302da6382422" translate="yes" xml:space="preserve">
          <source>CPU supports the integer select instruction.</source>
          <target state="translated">CPU支持整数选择指令。</target>
        </trans-unit>
        <trans-unit id="2e306759e72b16093678ea3f4c4c712cd49b17a9" translate="yes" xml:space="preserve">
          <source>CPU supports the matrix-multiply assist instructions.</source>
          <target state="translated">CPU支持矩阵乘法辅助指令。</target>
        </trans-unit>
        <trans-unit id="99a95efc8023d10b71a08bff59a8789aa22a0fb6" translate="yes" xml:space="preserve">
          <source>CPU supports the old POWER ISA (eg, 601)</source>
          <target state="translated">CPU支持旧的POWER ISA(如601)。</target>
        </trans-unit>
        <trans-unit id="309f8ee6774ef217dd65020d0047499e145915f8" translate="yes" xml:space="preserve">
          <source>CPU supports the set of compatible performance monitoring events.</source>
          <target state="translated">CPU支持一组兼容的性能监控事件。</target>
        </trans-unit>
        <trans-unit id="654d56ee4aa1191ad640c84c9cda741472551b11" translate="yes" xml:space="preserve">
          <source>CPU supports the target address register.</source>
          <target state="translated">CPU支持目标地址寄存器。</target>
        </trans-unit>
        <trans-unit id="2b74cd2604db8f416c0c904f549425dc7576345f" translate="yes" xml:space="preserve">
          <source>CPU supports the vector cryptography instructions.</source>
          <target state="translated">CPU支持向量加密指令。</target>
        </trans-unit>
        <trans-unit id="2910c789b3b4293207054dd9a2e43cc18d433b78" translate="yes" xml:space="preserve">
          <source>CPU supports the vector-scalar extension.</source>
          <target state="translated">CPU支持向量-标量扩展。</target>
        </trans-unit>
        <trans-unit id="41c99496e20c6a12697b36d694855c474afbe5bb" translate="yes" xml:space="preserve">
          <source>CPU supports true little-endian mode.</source>
          <target state="translated">CPU支持真正的小二进制模式。</target>
        </trans-unit>
        <trans-unit id="2ec7e4eb5fc127660ed425c7dcd89cd8eddc4bc5" translate="yes" xml:space="preserve">
          <source>CPUs based on AMD Family 10h cores with x86-64 instruction set support. (This supersets MMX, SSE, SSE2, SSE3, SSE4A, 3DNow!, enhanced 3DNow!, ABM and 64-bit instruction set extensions.)</source>
          <target state="translated">基于AMD家族10h核心的CPU,支持x86-64指令集。(这超越了MMX、SSE、SSE2、SSE3、SSE4A、3DNow!、增强型3DNow!、ABM和64位指令集扩展)。</target>
        </trans-unit>
        <trans-unit id="b84062366ba14fb3f3b6ff6b47d03c475a3828a9" translate="yes" xml:space="preserve">
          <source>CPUs based on AMD Family 14h cores with x86-64 instruction set support. (This supersets MMX, SSE, SSE2, SSE3, SSSE3, SSE4A, CX16, ABM and 64-bit instruction set extensions.)</source>
          <target state="translated">基于AMD家族14h核心的CPU,支持x86-64指令集。(这超越了MMX、SSE、SSE2、SSE3、SSE3、SSE4A、CX16、ABM和64位指令集扩展)。</target>
        </trans-unit>
        <trans-unit id="7cd17945f4d7f7d90dbb7eb4390b3e09de24051b" translate="yes" xml:space="preserve">
          <source>CPUs based on AMD Family 15h cores with x86-64 instruction set support. (This supersets FMA4, AVX, XOP, LWP, AES, PCLMUL, CX16, MMX, SSE, SSE2, SSE3, SSE4A, SSSE3, SSE4.1, SSE4.2, ABM and 64-bit instruction set extensions.)</source>
          <target state="translated">基于AMD家族15h核心的CPU,支持x86-64指令集。(这超越了FMA4、AVX、XOP、LWP、AES、PCLMUL、CX16、MMX、SSE、SSE2、SSE3、SSE4A、SSSE3、SSE4.1、SSE4.2、ABM和64位指令集扩展。)</target>
        </trans-unit>
        <trans-unit id="113524bb3893cb5857442da17502358001cf141b" translate="yes" xml:space="preserve">
          <source>CPUs based on AMD Family 15h cores with x86-64 instruction set support. (This supersets FMA4, AVX, XOP, LWP, AES, PCL_MUL, CX16, MMX, SSE, SSE2, SSE3, SSE4A, SSSE3, SSE4.1, SSE4.2, ABM and 64-bit instruction set extensions.)</source>
          <target state="translated">基于AMD家族15h核心的CPU,支持x86-64指令集。(这超越了FMA4、AVX、XOP、LWP、AES、PCL_MUL、CX16、MMX、SSE、SSE2、SSE3、SSE4A、SSSE3、SSE4.1、SSE4.2、ABM和64位指令集扩展。)</target>
        </trans-unit>
        <trans-unit id="de84db6df1b92636fc4cae8a7a0a74534cf2484c" translate="yes" xml:space="preserve">
          <source>CPUs based on AMD Family 16h cores with x86-64 instruction set support. This includes MOVBE, F16C, BMI, AVX, PCLMUL, AES, SSE4.2, SSE4.1, CX16, ABM, SSE4A, SSSE3, SSE3, SSE2, SSE, MMX and 64-bit instruction set extensions.</source>
          <target state="translated">基于AMD家族16h内核的CPU,支持x86-64指令集。包括MOVBE、F16C、BMI、AVX、PCLMUL、AES、SSE4.2、SSE4.1、CX16、ABM、SSE4A、SSE3、SSE3、SSE2、SSE、MMX和64位指令集扩展。</target>
        </trans-unit>
        <trans-unit id="47a0219528807f6268d19e1c7ca96f3e9c601c1e" translate="yes" xml:space="preserve">
          <source>CPUs based on AMD Family 16h cores with x86-64 instruction set support. This includes MOVBE, F16C, BMI, AVX, PCL_MUL, AES, SSE4.2, SSE4.1, CX16, ABM, SSE4A, SSSE3, SSE3, SSE2, SSE, MMX and 64-bit instruction set extensions.</source>
          <target state="translated">基于AMD家族16h内核的CPU,支持x86-64指令集。包括MOVBE、F16C、BMI、AVX、PCL_MUL、AES、SSE4.2、SSE4.1、CX16、ABM、SSE4A、SSE3、SSE3、SSE2、SSE、MMX和64位指令集扩展。</target>
        </trans-unit>
        <trans-unit id="762cf7076b068d306d32ea79b0d0e2277121f2b5" translate="yes" xml:space="preserve">
          <source>CR</source>
          <target state="translated">CR</target>
        </trans-unit>
        <trans-unit id="5e1fb0077df92097ce069aa21ed47aa03c3d5c5d" translate="yes" xml:space="preserve">
          <source>CR16 Architecture&amp;mdash;</source>
          <target state="translated">CR16体系结构&amp;mdash;</target>
        </trans-unit>
        <trans-unit id="f9c744e8c0ecb712753e6342db41d199b59d9bf6" translate="yes" xml:space="preserve">
          <source>CTR</source>
          <target state="translated">CTR</target>
        </trans-unit>
        <trans-unit id="58ad68590efc1385d2b4fd64a16b4b9f8cfaaa44" translate="yes" xml:space="preserve">
          <source>Call operand, const_int, for absolute calls.</source>
          <target state="translated">调用操作数,const_int,用于绝对调用。</target>
        </trans-unit>
        <trans-unit id="3373e7e79f4085d8f7291896ef1d3760c15083be" translate="yes" xml:space="preserve">
          <source>Call operand, reg, for indirect calls</source>
          <target state="translated">调用操作数,reg,用于间接调用</target>
        </trans-unit>
        <trans-unit id="3c51d11770c5ea3546c0d152d73faf160c859f37" translate="yes" xml:space="preserve">
          <source>Call operand, symbol, for relative calls.</source>
          <target state="translated">调用操作数,符号,用于相对调用。</target>
        </trans-unit>
        <trans-unit id="f0c515fe9bf062328bec62182c3bb93d352208ec" translate="yes" xml:space="preserve">
          <source>Call the named function &lt;var&gt;function&lt;/var&gt;, passing it &lt;var&gt;args&lt;/var&gt;. &lt;var&gt;args&lt;/var&gt; is first processed as a nested spec string, then split into an argument vector in the usual fashion. The function returns a string which is processed as if it had appeared literally as part of the current spec.</source>
          <target state="translated">调用命名函数 &lt;var&gt;function&lt;/var&gt; ，将其传递给 &lt;var&gt;args&lt;/var&gt; 。 &lt;var&gt;args&lt;/var&gt; 首先作为嵌套的规范字符串处理，然后以通常的方式拆分为参数向量。该函数返回一个字符串，该字符串的处理方式就好像它确实是当前规范的一部分。</target>
        </trans-unit>
        <trans-unit id="4b1ccc6ccff0a4b4d69b01f9c83e0859c8e4f058" translate="yes" xml:space="preserve">
          <source>Calling conventions are a subset of an ABI that specify of how arguments are passed and function results are returned.</source>
          <target state="translated">调用约定是ABI的一个子集,它指定了如何传递参数和返回函数结果。</target>
        </trans-unit>
        <trans-unit id="8e13d2ff4cf44ed7d75b8cee9472ba906dfafd20" translate="yes" xml:space="preserve">
          <source>Calling this function with a nonzero argument can have unpredictable effects, including crashing the calling program. As a result, calls that are considered unsafe are diagnosed when the</source>
          <target state="translated">用一个非零参数调用这个函数可能会产生不可预知的影响,包括使调用程序崩溃。因此,被认为是不安全的调用会在当</target>
        </trans-unit>
        <trans-unit id="fc12921ff6d4899e4dc68b34cc1cd37e3157e57e" translate="yes" xml:space="preserve">
          <source>Calls a library function that performs the operation in double precision floating point. Division by zero causes a floating-point exception. This is the default for SHcompact with FPU. Specifying this for targets that do not have a double precision FPU defaults to &lt;code&gt;call-div1&lt;/code&gt;.</source>
          <target state="translated">调用以双精度浮点数执行操作的库函数。被零除会导致浮点异常。这是SHcompact与FPU的默认设置。为没有双精度FPU的目标指定此选项的默认值是 &lt;code&gt;call-div1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="29e8cd2fa85f5515142e26b60a518bb56cd4bcb6" translate="yes" xml:space="preserve">
          <source>Calls a library function that uses a lookup table for small divisors and the &lt;code&gt;div1&lt;/code&gt; instruction with case distinction for larger divisors. Division by zero calculates an unspecified result and does not trap. This is the default for SH4. Specifying this for targets that do not have dynamic shift instructions defaults to &lt;code&gt;call-div1&lt;/code&gt;.</source>
          <target state="translated">调用一个库函数，该函数对小除数使用查找表，对大除数使用区分大小写的 &lt;code&gt;div1&lt;/code&gt; 指令。除以零会计算不确定的结果，并且不会捕获。这是SH4的默认设置。为没有动态移位指令的目标指定此选项默认为 &lt;code&gt;call-div1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b66ee13b0a48eb1333567adb5302965969bbf50a" translate="yes" xml:space="preserve">
          <source>Calls a library function that uses the single-step division instruction &lt;code&gt;div1&lt;/code&gt; to perform the operation. Division by zero calculates an unspecified result and does not trap. This is the default except for SH4, SH2A and SHcompact.</source>
          <target state="translated">调用使用单步除法指令 &lt;code&gt;div1&lt;/code&gt; 的库函数来执行该操作。除以零会计算不确定的结果，并且不会捕获。除SH4，SH2A和SHcompact外，这是默认设置。</target>
        </trans-unit>
        <trans-unit id="b45cc51de5de6fd998285ffd2412d7b2646d5ad0" translate="yes" xml:space="preserve">
          <source>Calls to &lt;code&gt;foo&lt;/code&gt; are mapped to calls to &lt;code&gt;foo{20040821}&lt;/code&gt;.</source>
          <target state="translated">对 &lt;code&gt;foo&lt;/code&gt; 的调用将映射到对 &lt;code&gt;foo{20040821}&lt;/code&gt; 调用。</target>
        </trans-unit>
        <trans-unit id="293878ce1781e2ea1bacb79578feb3fbe4be3315" translate="yes" xml:space="preserve">
          <source>Calls to external functions with this attribute must return to the current compilation unit only by return or by exception handling. In particular, a leaf function is not allowed to invoke callback functions passed to it from the current compilation unit, directly call functions exported by the unit, or &lt;code&gt;longjmp&lt;/code&gt; into the unit. Leaf functions might still call functions from other compilation units and thus they are not necessarily leaf in the sense that they contain no function calls at all.</source>
          <target state="translated">使用此属性对外部函数的调用必须仅通过return或通过异常处理才能返回到当前的编译单元。特别是，不允许叶子函数调用从当前编译单元传递给它的回调函数，直接调用由该单元导出的函数或将 &lt;code&gt;longjmp&lt;/code&gt; 放入该单元中。叶子函数可能仍会从其他编译单元调用函数，因此从它们根本不包含任何函数调用的意义上来说，它们不一定是叶子。</target>
        </trans-unit>
        <trans-unit id="4271715ba8546178ce2b0fafe7396f6340205ed7" translate="yes" xml:space="preserve">
          <source>Calls to functions that have no observable effects on the state of the program other than to return a value may lend themselves to optimizations such as common subexpression elimination. Declaring such functions with the &lt;code&gt;pure&lt;/code&gt; attribute allows GCC to avoid emitting some calls in repeated invocations of the function with the same argument values.</source>
          <target state="translated">调用除返回值外对程序状态没有可观察的影响的函数可能有助于进行优化，例如消除公共子表达式。使用 &lt;code&gt;pure&lt;/code&gt; 属性声明此类函数可以使GCC避免在重复调用具有相同参数值的函数时发出某些调用。</target>
        </trans-unit>
        <trans-unit id="3b52d0ab938b444cac1b9e9d1c160806cd6da345" translate="yes" xml:space="preserve">
          <source>Calls to functions whose return value is not affected by changes to the observable state of the program and that have no observable effects on such state other than to return a value may lend themselves to optimizations such as common subexpression elimination. Declaring such functions with the &lt;code&gt;const&lt;/code&gt; attribute allows GCC to avoid emitting some calls in repeated invocations of the function with the same argument values.</source>
          <target state="translated">调用其返回值不受程序可观察状态的更改影响并且对这种状态没有可观察的影响（而不返回值）的函数的调用可以使自己进行优化，例如消除公共子表达式。使用 &lt;code&gt;const&lt;/code&gt; 属性声明此类函数可以使GCC避免在重复调用具有相同参数值的函数时发出某些调用。</target>
        </trans-unit>
        <trans-unit id="f8eba46ecad008a4e218a210a71672db04d7e157" translate="yes" xml:space="preserve">
          <source>Cancel an assertion with the predicate &lt;var&gt;predicate&lt;/var&gt; and answer &lt;var&gt;answer&lt;/var&gt;.</source>
          <target state="translated">取消与谓词断言 &lt;var&gt;predicate&lt;/var&gt; 和答案 &lt;var&gt;answer&lt;/var&gt; 。</target>
        </trans-unit>
        <trans-unit id="59d15eea66865b0282cb17c0e3120ed653071f95" translate="yes" xml:space="preserve">
          <source>Cancel any previous definition of &lt;var&gt;name&lt;/var&gt;, either built in or provided with a</source>
          <target state="translated">取消 &lt;var&gt;name&lt;/var&gt; 的任何以前的定义，该定义是内置的或随附的</target>
        </trans-unit>
        <trans-unit id="192387cfc73b539ff900c725ddee4d021db73db5" translate="yes" xml:space="preserve">
          <source>Casting to union type from any member of the union.</source>
          <target state="translated">从该联盟的任何成员投向联盟类型。</target>
        </trans-unit>
        <trans-unit id="b08eca4544a17d0207cde77668a933d9951e246a" translate="yes" xml:space="preserve">
          <source>Cause gas to print out tomcat statistics.</source>
          <target state="translated">导致气体打印出tomcat统计数据。</target>
        </trans-unit>
        <trans-unit id="5a1bd09378f19d49cb410444dadaeb9f88738a8a" translate="yes" xml:space="preserve">
          <source>Cause the errors having to do with files that have the wrong architecture to be fatal.</source>
          <target state="translated">导致与架构错误的文件有关的错误是致命的。</target>
        </trans-unit>
        <trans-unit id="5019333f8c270c0e57b171951e0397047e39d35e" translate="yes" xml:space="preserve">
          <source>Causes GCC to remember the state of the diagnostics as of each &lt;code&gt;push&lt;/code&gt;, and restore to that point at each &lt;code&gt;pop&lt;/code&gt;. If a &lt;code&gt;pop&lt;/code&gt; has no matching &lt;code&gt;push&lt;/code&gt;, the command-line options are restored.</source>
          <target state="translated">使GCC在每次 &lt;code&gt;push&lt;/code&gt; 记住诊断的状态，并在每次 &lt;code&gt;pop&lt;/code&gt; 恢复到该点。如果某个 &lt;code&gt;pop&lt;/code&gt; 没有匹配的 &lt;code&gt;push&lt;/code&gt; ，则将还原命令行选项。</target>
        </trans-unit>
        <trans-unit id="667cccec716e1283ccef9e29985511e0bdf9e0a0" translate="yes" xml:space="preserve">
          <source>Causes all functions to default to the &lt;code&gt;.far&lt;/code&gt; section. Without this option, functions default to the &lt;code&gt;.near&lt;/code&gt; section.</source>
          <target state="translated">使所有函数默认为 &lt;code&gt;.far&lt;/code&gt; 节。没有此选项，函数默认为 &lt;code&gt;.near&lt;/code&gt; 部分。</target>
        </trans-unit>
        <trans-unit id="e30905206e2b1ac1064f6ac3bbe5bd6c803a6b79" translate="yes" xml:space="preserve">
          <source>Causes all variables to default to the &lt;code&gt;.tiny&lt;/code&gt; section. Note that there is a 65536-byte limit to this section. Accesses to these variables use the &lt;code&gt;%gp&lt;/code&gt; base register.</source>
          <target state="translated">使所有变量默认为 &lt;code&gt;.tiny&lt;/code&gt; 部分。请注意，此部分限制为65536字节。对这些变量的访问使用 &lt;code&gt;%gp&lt;/code&gt; 基址寄存器。</target>
        </trans-unit>
        <trans-unit id="98be0c7de301463de1c80070885a43330018a0b2" translate="yes" xml:space="preserve">
          <source>Causes constant variables to be placed in the &lt;code&gt;.near&lt;/code&gt; section.</source>
          <target state="translated">使常量变量放置在 &lt;code&gt;.near&lt;/code&gt; 节中。</target>
        </trans-unit>
        <trans-unit id="655599ac8eaa0291e221b62364ffdf96a51309de" translate="yes" xml:space="preserve">
          <source>Causes the output file to be marked such that the dynamic linker will bind all undefined references when the file is loaded or launched.</source>
          <target state="translated">导致输出文件被标记为当文件被加载或启动时,动态链接器将绑定所有未定义的引用。</target>
        </trans-unit>
        <trans-unit id="c48452dfc4582d4eee857576d8fb13bb7694884b" translate="yes" xml:space="preserve">
          <source>Causes variables to be assigned to the &lt;code&gt;.far&lt;/code&gt; section by default.</source>
          <target state="translated">导致默认情况下将变量分配给 &lt;code&gt;.far&lt;/code&gt; 部分。</target>
        </trans-unit>
        <trans-unit id="13cb136a09a7c1b01f2dc417dcf7c22b8038c03d" translate="yes" xml:space="preserve">
          <source>Causes variables to be assigned to the &lt;code&gt;.near&lt;/code&gt; section by default.</source>
          <target state="translated">导致默认情况下将变量分配给 &lt;code&gt;.near&lt;/code&gt; 节。</target>
        </trans-unit>
        <trans-unit id="efdb8f56a4df91a529ce6b66e59857019a48ac1f" translate="yes" xml:space="preserve">
          <source>Certain ABI-changing flags are required to match in all compilation units, and trying to override this at link time with a conflicting value is ignored. This includes options such as</source>
          <target state="translated">某些ABI变化的标志在所有编译单元中都需要匹配,在链接时试图用一个冲突的值来覆盖这个标志会被忽略。这包括一些选项,如</target>
        </trans-unit>
        <trans-unit id="a8db3b10d95cbc07c88dbe64efa680baa0d22c3b" translate="yes" xml:space="preserve">
          <source>Certain local variables aren&amp;rsquo;t recognized by debuggers when you compile with optimization.</source>
          <target state="translated">在进行优化编译时，调试器无法识别某些局部变量。</target>
        </trans-unit>
        <trans-unit id="be7c527dd55f67d739c97b4f416bd42f396b0844" translate="yes" xml:space="preserve">
          <source>Cfront model</source>
          <target state="translated">Cfront模型</target>
        </trans-unit>
        <trans-unit id="1aba59b0fc2fb3ed3ce5d3423cf83addc1f152f7" translate="yes" xml:space="preserve">
          <source>Change ABI to use double word insns.</source>
          <target state="translated">将ABI改为使用双字insns。</target>
        </trans-unit>
        <trans-unit id="9f8ed70cb1d356e0b695cceb7ab02d866b216534" translate="yes" xml:space="preserve">
          <source>Change paragraph 1</source>
          <target state="translated">修改第1款</target>
        </trans-unit>
        <trans-unit id="3cb692fbb429d564d86c14c1772ab21a4cec5d73" translate="yes" xml:space="preserve">
          <source>Change paragraph 2</source>
          <target state="translated">修改第2款</target>
        </trans-unit>
        <trans-unit id="9b9fbfc9cacb726e629a9636bbe98d28a8d83b9b" translate="yes" xml:space="preserve">
          <source>Change paragraph 2 to</source>
          <target state="translated">将第2款改为:</target>
        </trans-unit>
        <trans-unit id="cb241f39f5fa8625fba68e7d9da30611af7534b7" translate="yes" xml:space="preserve">
          <source>Change the current ABI to use IBM extended-precision long double. This is not likely to work if your system defaults to using IEEE extended-precision long double. If you change the long double type from IEEE extended-precision, the compiler will issue a warning unless you use the</source>
          <target state="translated">将当前 ABI 更改为使用 IBM 扩展精度长双数。如果您的系统默认使用 IEEE 扩展精度长双数,这不太可能奏效。如果您将长双数类型从 IEEE 扩展精度改为长双数,编译器将发出警告,除非您使用</target>
        </trans-unit>
        <trans-unit id="8b05bb4515e125b765f13f146e5cba54744fff37" translate="yes" xml:space="preserve">
          <source>Change the current ABI to use IEEE extended-precision long double. This is not likely to work if your system defaults to using IBM extended-precision long double. If you change the long double type from IBM extended-precision, the compiler will issue a warning unless you use the</source>
          <target state="translated">将当前 ABI 更改为使用 IEEE 扩展精度长双数。如果您的系统默认使用IBM扩展精度长双数,这不太可能奏效。如果您将长双数类型从 IBM 扩展精度改为长双数,编译器将发出警告,除非您使用了</target>
        </trans-unit>
        <trans-unit id="24cf332293e237ad325e62a5ee2905fadea5402b" translate="yes" xml:space="preserve">
          <source>Change the current ABI to use the ELFv1 ABI. This is the default ABI for big-endian PowerPC 64-bit Linux. Overriding the default ABI requires special system support and is likely to fail in spectacular ways.</source>
          <target state="translated">将当前 ABI 更改为使用 ELFv1 ABI。这是 big-endian PowerPC 64-bit Linux 的默认 ABI。覆盖默认的 ABI 需要特殊的系统支持,并且很可能以惊人的方式失败。</target>
        </trans-unit>
        <trans-unit id="8ed54cd4038a43f7d20137c040c4f60546641dbf" translate="yes" xml:space="preserve">
          <source>Change the current ABI to use the ELFv2 ABI. This is the default ABI for little-endian PowerPC 64-bit Linux. Overriding the default ABI requires special system support and is likely to fail in spectacular ways.</source>
          <target state="translated">将当前 ABI 更改为使用 ELFv2 ABI。这是小字段 PowerPC 64 位 Linux 的默认 ABI。覆盖默认的 ABI 需要特殊的系统支持,并且很可能以惊人的方式失败。</target>
        </trans-unit>
        <trans-unit id="85a1bd4814c92b33b933c24808e3438fdd28e471" translate="yes" xml:space="preserve">
          <source>Change the preferred SIMD mode to SImode. The default is</source>
          <target state="translated">将首选的SIMD模式改为SImode。默认为</target>
        </trans-unit>
        <trans-unit id="1693787c0c1da76f7df927835bc9d253ab1baa96" translate="yes" xml:space="preserve">
          <source>Change the target of the rule emitted by dependency generation. By default CPP takes the name of the main input file, deletes any directory components and any file suffix such as &amp;lsquo;</source>
          <target state="translated">更改依赖项生成所发出的规则的目标。默认情况下，CPP使用主输入文件的名称，删除所有目录组件和任何文件后缀，例如&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="aca39a5b032e87a9c462bafacf2e62ade09bc55e" translate="yes" xml:space="preserve">
          <source>Check calls to &lt;code&gt;printf&lt;/code&gt; and &lt;code&gt;scanf&lt;/code&gt;, etc., to make sure that the arguments supplied have types appropriate to the format string specified, and that the conversions specified in the format string make sense. This includes standard functions, and others specified by format attributes (see &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;Function Attributes&lt;/a&gt;), in the &lt;code&gt;printf&lt;/code&gt;, &lt;code&gt;scanf&lt;/code&gt;, &lt;code&gt;strftime&lt;/code&gt; and &lt;code&gt;strfmon&lt;/code&gt; (an X/Open extension, not in the C standard) families (or other target-specific families). Which functions are checked without format attributes having been specified depends on the standard version selected, and such checks of functions without the attribute specified are disabled by</source>
          <target state="translated">检查对 &lt;code&gt;printf&lt;/code&gt; 和 &lt;code&gt;scanf&lt;/code&gt; 等的调用，以确保提供的参数具有与指定的格式字符串相对应的类型，并且确保在格式字符串中指定的转换有意义。这包括标准函数以及在 &lt;code&gt;printf&lt;/code&gt; ， &lt;code&gt;scanf&lt;/code&gt; ， &lt;code&gt;strftime&lt;/code&gt; 和 &lt;code&gt;strfmon&lt;/code&gt; （X / Open扩展，不是C标准），系列（或其他特定于目标的系列）中由格式属性指定的其他&lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;功能&lt;/a&gt;（请参见功能属性）。在未指定格式属性的情况下检查哪些功能取决于所选的标准版本，而未在未指定属性的情况下进行的功能检查将被禁用</target>
        </trans-unit>
        <trans-unit id="c6a3f453fdd63ac92077276df83570873739aa07" translate="yes" xml:space="preserve">
          <source>Check for 64 bits wide constants for add/sub instructions</source>
          <target state="translated">检查64位宽的加/减指令的常量。</target>
        </trans-unit>
        <trans-unit id="fac4c7c683a989d8b06bb9ece7f678cee49ed294" translate="yes" xml:space="preserve">
          <source>Check that the pointer returned by &lt;code&gt;operator new&lt;/code&gt; is non-null before attempting to modify the storage allocated. This check is normally unnecessary because the C++ standard specifies that &lt;code&gt;operator new&lt;/code&gt; only returns &lt;code&gt;0&lt;/code&gt; if it is declared &lt;code&gt;throw()&lt;/code&gt;, in which case the compiler always checks the return value even without this option. In all other cases, when &lt;code&gt;operator new&lt;/code&gt; has a non-empty exception specification, memory exhaustion is signalled by throwing &lt;code&gt;std::bad_alloc&lt;/code&gt;. See also &amp;lsquo;</source>
          <target state="translated">在尝试修改分配的存储之前，请检查 &lt;code&gt;operator new&lt;/code&gt; 返回的指针是否为非空。通常，此检查是不必要的，因为C ++标准指定 &lt;code&gt;operator new&lt;/code&gt; 如果声明为 &lt;code&gt;throw()&lt;/code&gt; ，则仅返回 &lt;code&gt;0&lt;/code&gt; ，在这种情况下，即使没有此选项，编译器也会始终检查返回值。在所有其他情况下，当 &lt;code&gt;operator new&lt;/code&gt; 具有非空异常规范时，将通过抛出 &lt;code&gt;std::bad_alloc&lt;/code&gt; 来指示内存耗尽。也可以看看 '</target>
        </trans-unit>
        <trans-unit id="81e890de105f29124c3560894740b09b086a655a" translate="yes" xml:space="preserve">
          <source>Check the code for syntax errors, but don&amp;rsquo;t do anything beyond that.</source>
          <target state="translated">检查代码中是否存在语法错误，但不要做其他任何事情。</target>
        </trans-unit>
        <trans-unit id="5b609f7a36a96f87c3d3229801dbbe278531362e" translate="yes" xml:space="preserve">
          <source>Checking the number and type of arguments to a function which has an old-fashioned definition and no prototype.</source>
          <target state="translated">检查一个有老式定义而没有原型的函数的参数数量和类型。</target>
        </trans-unit>
        <trans-unit id="fd9acb009d6a873fdb579dcb1f012d6d507dcf76" translate="yes" xml:space="preserve">
          <source>Choose a data model. The choices for &lt;var&gt;model&lt;/var&gt; are &amp;lsquo;</source>
          <target state="translated">选择一个数据模型。 &lt;var&gt;model&lt;/var&gt; 的选择是</target>
        </trans-unit>
        <trans-unit id="8d3369d8e5fea9b901b46c632d20401df2fdb02c" translate="yes" xml:space="preserve">
          <source>Choose between the two available implementations of</source>
          <target state="translated">在两个可用的</target>
        </trans-unit>
        <trans-unit id="41e3a1c87aff0500a839e105b5b619da6d89b8a6" translate="yes" xml:space="preserve">
          <source>Choose integer type as 32-bit wide.</source>
          <target state="translated">选择整数类型为32位宽。</target>
        </trans-unit>
        <trans-unit id="fd477ac5e4063d79ef6de9d30fdf3c13757351dd" translate="yes" xml:space="preserve">
          <source>Choose startup files and linker script suitable for the simulator.</source>
          <target state="translated">选择适合模拟器的启动文件和链接器脚本。</target>
        </trans-unit>
        <trans-unit id="a7c124dc3d6f2fff1283f2960f19679f618eb758" translate="yes" xml:space="preserve">
          <source>Chopped rounding mode. Floating-point numbers are rounded towards zero.</source>
          <target state="translated">斩波进位模式。浮点数字四舍五入为零。</target>
        </trans-unit>
        <trans-unit id="baeeaf6c90ab7667596e853c19ec9377ba1a6bed" translate="yes" xml:space="preserve">
          <source>Chunk size of omp schedule for loops parallelized by parloops.</source>
          <target state="translated">通过parloops并行化的循环的OMP计划的Chunk大小。</target>
        </trans-unit>
        <trans-unit id="39f6c5316b94c42ede9e8f3c0902f04af5a47ac9" translate="yes" xml:space="preserve">
          <source>Clobber descriptions may not in any way overlap with an input or output operand. For example, you may not have an operand describing a register class with one member when listing that register in the clobber list. Variables declared to live in specific registers (see &lt;a href=&quot;explicit-register-variables#Explicit-Register-Variables&quot;&gt;Explicit Register Variables&lt;/a&gt;) and used as &lt;code&gt;asm&lt;/code&gt; input or output operands must have no part mentioned in the clobber description. In particular, there is no way to specify that input operands get modified without also specifying them as output operands.</source>
          <target state="translated">垃圾描述可能不会与输入或输出操作数重叠。例如，当您将一个寄存器描述在寄存器列表中时，可能没有操作数描述一个成员的寄存器类。声明要存在于特定寄存器中的&lt;a href=&quot;explicit-register-variables#Explicit-Register-Variables&quot;&gt;变量&lt;/a&gt;（请参阅显式寄存器变量），并且用作 &lt;code&gt;asm&lt;/code&gt; 输入或输出操作数的变量，在Clobber描述中必须没有提及。特别是，如果没有将输入操作数也指定为输出操作数，就无法指定对其进行修改。</target>
        </trans-unit>
        <trans-unit id="e7d5e82c3d8cf6aecb50f1c3dec1dfd81862c300" translate="yes" xml:space="preserve">
          <source>Code Generation Options</source>
          <target state="translated">代码生成选项</target>
        </trans-unit>
        <trans-unit id="de73aa04e00c631b2bba60472a9b4cb42f90647b" translate="yes" xml:space="preserve">
          <source>Code generation tweaks that disable, respectively, splitting of 32-bit loads, generation of post-increment addresses, and generation of post-modify addresses. The defaults are</source>
          <target state="translated">代码生成调整,分别禁用32位负载的分割、生成增量后地址和生成修改后地址。默认值是</target>
        </trans-unit>
        <trans-unit id="0acb8ba8662201458fc8762cdc2bfb973da3d9b7" translate="yes" xml:space="preserve">
          <source>Code like this may run successfully under some other compilers, particularly obsolete cfront-based compilers that delete temporaries along with normal local variables. However, the GNU C++ behavior is standard-conforming, so if your program depends on late destruction of temporaries it is not portable.</source>
          <target state="translated">像这样的代码可能会在一些其他编译器下成功运行,特别是那些基于cfront的过时编译器,它们会将临时变量和普通的局部变量一起删除。然而,GNU C++的行为是符合标准的,所以如果你的程序依赖于临时变量的后期销毁,那么它是不可移植的。</target>
        </trans-unit>
        <trans-unit id="d477ef0f890f99da791a35a9c4922d4a6b4caa9b" translate="yes" xml:space="preserve">
          <source>Code that (effectively) clobbers bits of &lt;code&gt;SREG&lt;/code&gt; other than the &lt;code&gt;I&lt;/code&gt;-flag by writing to the memory location of &lt;code&gt;SREG&lt;/code&gt;.</source>
          <target state="translated">通过写入 &lt;code&gt;SREG&lt;/code&gt; 的存储位置（有效地）清除 &lt;code&gt;SREG&lt;/code&gt; 的 &lt;code&gt;I&lt;/code&gt; 标志以外的位的代码。</target>
        </trans-unit>
        <trans-unit id="22aee03764143c3347036737d5c49aa3c48b93fe" translate="yes" xml:space="preserve">
          <source>Code that uses inline assembler to jump to a different function which expects (parts of) the prologue code as outlined above to be present.</source>
          <target state="translated">使用内联汇编器跳转到不同函数的代码,该函数期望(部分)如上所述的序幕代码存在。</target>
        </trans-unit>
        <trans-unit id="a04d4be0af028c55d37a5eda8e2e9e52e00d9883" translate="yes" xml:space="preserve">
          <source>Collect and dump debug information into a temporary file if an internal compiler error (ICE) occurs.</source>
          <target state="translated">如果发生内部编译器错误(ICE),收集并将调试信息转储到一个临时文件中。</target>
        </trans-unit>
        <trans-unit id="3de9bf73c20469d02f33a82c6c1b964c35ca72c5" translate="yes" xml:space="preserve">
          <source>Collect the profiles for different set of inputs, and use this tool to merge them. One can specify the weight to factor in the relative importance of each input.</source>
          <target state="translated">收集不同输入集的剖面图,并使用此工具将其合并。可以指定权重,以考虑每个输入的相对重要性。</target>
        </trans-unit>
        <trans-unit id="674fdd25c0f94978ce5404bf7783af22ebecb1fb" translate="yes" xml:space="preserve">
          <source>Combine increments or decrements of addresses with memory accesses. This pass is always skipped on architectures that do not have instructions to support this. Enabled by default at</source>
          <target state="translated">将地址的增量或减量与内存访问相结合。在没有指令支持这个功能的架构上,这个通道总是被跳过。默认情况下,在</target>
        </trans-unit>
        <trans-unit id="5c675961000becf8ff6422c0eeb1b9242b5fdf0f" translate="yes" xml:space="preserve">
          <source>Combines the effects of both &lt;code&gt;__ATOMIC_ACQUIRE&lt;/code&gt; and &lt;code&gt;__ATOMIC_RELEASE&lt;/code&gt;.</source>
          <target state="translated">结合 &lt;code&gt;__ATOMIC_ACQUIRE&lt;/code&gt; 和 &lt;code&gt;__ATOMIC_RELEASE&lt;/code&gt; 的效果。</target>
        </trans-unit>
        <trans-unit id="4393d8b520a9b50ddef09d9f77984a620fcf38de" translate="yes" xml:space="preserve">
          <source>Combining several classes is possible, although this usually restricts the output so much that there is nothing to display. One case where it does work, however, is when one of the classes is &lt;var&gt;target&lt;/var&gt;. For example, to display all the target-specific optimization options, use:</source>
          <target state="translated">可以组合多个类，尽管这通常会限制输出，以至于无任何显示。但是，它确实起作用的一种情况是当其中一个类是 &lt;var&gt;target&lt;/var&gt; 时。例如，要显示所有特定于目标的优化选项，请使用：</target>
        </trans-unit>
        <trans-unit id="72a257637f31b3509bd8ac95d015b26d1c5d9ce9" translate="yes" xml:space="preserve">
          <source>Command options supported by &amp;lsquo;</source>
          <target state="translated">'支持的命令选项</target>
        </trans-unit>
        <trans-unit id="8e5bbd00924927db3116b7ce896a99d0d6c09a71" translate="yes" xml:space="preserve">
          <source>Commit the current transaction. When no transaction is active this faults. All memory side effects of the transaction become visible to other threads in an atomic manner.</source>
          <target state="translated">提交当前事务。当没有事务活动时,这个故障。事务的所有内存副作用都会以原子方式对其他线程可见。</target>
        </trans-unit>
        <trans-unit id="953dbfff4f1c2d7c9623cfa81345a412c8c95e6f" translate="yes" xml:space="preserve">
          <source>Common misunderstandings with GNU C++.</source>
          <target state="translated">GNU C++的常见误区。</target>
        </trans-unit>
        <trans-unit id="99484341af697bedb30f82944a2b8048a7bd9d3b" translate="yes" xml:space="preserve">
          <source>Compare at most &lt;var&gt;num&lt;/var&gt; string bytes with inline code. If the difference or end of string is not found at the end of the inline compare a call to &lt;code&gt;strcmp&lt;/code&gt; or &lt;code&gt;strncmp&lt;/code&gt; will take care of the rest of the comparison. The default is 64 bytes.</source>
          <target state="translated">将最多 &lt;var&gt;num&lt;/var&gt; 个字符串字节与内联代码进行比较。如果 &lt;code&gt;strncmp&lt;/code&gt; 联比较的末尾未找到字符串的差或结尾，则对 &lt;code&gt;strcmp&lt;/code&gt; 或strncmp的调用将完成其余的比较。默认值为64字节。</target>
        </trans-unit>
        <trans-unit id="7e11797436f7910f8bb83ca2860c72513034685a" translate="yes" xml:space="preserve">
          <source>Comparison of four paired-single values (&lt;code&gt;c.&lt;var&gt;cond&lt;/var&gt;.ps&lt;/code&gt;/&lt;code&gt;cabs.&lt;var&gt;cond&lt;/var&gt;.ps&lt;/code&gt;, &lt;code&gt;bc1any4t&lt;/code&gt;/&lt;code&gt;bc1any4f&lt;/code&gt;).</source>
          <target state="translated">4配对单值的比较（ &lt;code&gt;c.&lt;var&gt;cond&lt;/var&gt;.ps&lt;/code&gt; / &lt;code&gt;cabs.&lt;var&gt;cond&lt;/var&gt;.ps&lt;/code&gt; ， &lt;code&gt;bc1any4t&lt;/code&gt; / &lt;code&gt;bc1any4f&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="c8cb7f422f46057d6869362d0511c9090d3a1fd7" translate="yes" xml:space="preserve">
          <source>Comparison of two paired-single values (&lt;code&gt;c.&lt;var&gt;cond&lt;/var&gt;.ps&lt;/code&gt;, &lt;code&gt;bc1t&lt;/code&gt;/&lt;code&gt;bc1f&lt;/code&gt;).</source>
          <target state="translated">两个成对的单值（比较 &lt;code&gt;c.&lt;var&gt;cond&lt;/var&gt;.ps&lt;/code&gt; ， &lt;code&gt;bc1t&lt;/code&gt; / &lt;code&gt;bc1f&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="11a9160f31b23e32c54ba7fe5458de10730189d9" translate="yes" xml:space="preserve">
          <source>Comparison of two paired-single values (&lt;code&gt;c.&lt;var&gt;cond&lt;/var&gt;.ps&lt;/code&gt;/&lt;code&gt;cabs.&lt;var&gt;cond&lt;/var&gt;.ps&lt;/code&gt;, &lt;code&gt;bc1any2t&lt;/code&gt;/&lt;code&gt;bc1any2f&lt;/code&gt;).</source>
          <target state="translated">两个成对的单值的比较（ &lt;code&gt;c.&lt;var&gt;cond&lt;/var&gt;.ps&lt;/code&gt; / &lt;code&gt;cabs.&lt;var&gt;cond&lt;/var&gt;.ps&lt;/code&gt; ， &lt;code&gt;bc1any2t&lt;/code&gt; / &lt;code&gt;bc1any2f&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="651d13a7683a8781ee0feea932b0d34d198ddce8" translate="yes" xml:space="preserve">
          <source>Comparison operations.</source>
          <target state="translated">比较操作。</target>
        </trans-unit>
        <trans-unit id="1adbeb956bb205e79fa3fa9ca1c2daca593fb1fa" translate="yes" xml:space="preserve">
          <source>Compatibilities with earlier definitions of C++.</source>
          <target state="translated">与C++早期定义的兼容性。</target>
        </trans-unit>
        <trans-unit id="51c2b0659cd05018587a8d43545227600a32a376" translate="yes" xml:space="preserve">
          <source>Compilation can involve up to four stages: preprocessing, compilation proper, assembly and linking, always in that order. GCC is capable of preprocessing and compiling several files either into several assembler input files, or into one assembler input file; then each assembler input file produces an object file, and linking combines all the object files (those newly compiled, and those specified as input) into an executable file.</source>
          <target state="translated">编译最多可以包括四个阶段:预处理、适当编译、汇编和链接,顺序总是如此。GCC能够对若干文件进行预处理,并将其编译成若干个汇编器输入文件或一个汇编器输入文件;然后,每个汇编器输入文件产生一个对象文件,而链接则将所有的对象文件(新编译的文件和指定为输入的文件)合并为一个可执行文件。</target>
        </trans-unit>
        <trans-unit id="1f490d968ba17b1a6b9c49acd428a6392e787830" translate="yes" xml:space="preserve">
          <source>Compile ARCv2 code with a multiplier design option. You can specify the option using either a string or numeric value for &lt;var&gt;multo&lt;/var&gt;. &amp;lsquo;</source>
          <target state="translated">使用乘法器设计选项编译ARCv2代码。您可以使用字符串或 &lt;var&gt;multo&lt;/var&gt; 数值指定选项。'</target>
        </trans-unit>
        <trans-unit id="4a90dd66273f8436ce33369f342227123629a080" translate="yes" xml:space="preserve">
          <source>Compile code assuming that IEEE signaling NaNs may generate user-visible traps during floating-point operations. Setting this option disables optimizations that may change the number of exceptions visible with signaling NaNs. This option implies</source>
          <target state="translated">编译代码时假设IEEE信号NaNs在浮点运算时可能产生用户可见的陷阱。设置该选项可以禁止可能改变信号NaNs可见异常数量的优化。这个选项意味着,在编译代码时,要考虑到IEEE信号NaN可能会在浮点运算时产生用户可见的陷阱。</target>
        </trans-unit>
        <trans-unit id="9970fa5395affc7dc93ea1ed06f8fdd6c082c5bc" translate="yes" xml:space="preserve">
          <source>Compile code assuming that floating-point operations cannot generate user-visible traps. These traps include division by zero, overflow, underflow, inexact result and invalid operation. This option requires that</source>
          <target state="translated">编译代码时假设浮点运算不会产生用户可见的陷阱,这些陷阱包括零除、溢出、底溢、不完全结果和无效运算。这些陷阱包括:零除、溢出、底溢、不精确结果和无效操作。该选项要求</target>
        </trans-unit>
        <trans-unit id="7167229840a9f09cf85e4d3c02813e6e3f7c2954" translate="yes" xml:space="preserve">
          <source>Compile code assuming that pointers to the PPU address space accessed via the &lt;code&gt;__ea&lt;/code&gt; named address space qualifier are either 32 or 64 bits wide. The default is 32 bits. As this is an ABI-changing option, all object code in an executable must be compiled with the same setting.</source>
          <target state="translated">假定通过 &lt;code&gt;__ea&lt;/code&gt; 命名的地址空间限定符访问的PPU地址空间的指针的宽度为32位或64位，则编译代码。默认值为32位。由于这是一个更改ABI的选项，因此必须使用相同的设置来编译可执行文件中的所有目标代码。</target>
        </trans-unit>
        <trans-unit id="31103695d6eecad4fc985951c0af142d11cd5c1a" translate="yes" xml:space="preserve">
          <source>Compile code compatible with Android platform. This is the default on &amp;lsquo;</source>
          <target state="translated">编译与Android平台兼容的代码。这是&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="894efb97728307a39eeed2699c1c4e4bd26dd9dc" translate="yes" xml:space="preserve">
          <source>Compile code for big-endian mode. This is the default.</source>
          <target state="translated">编译大段模式的代码。这是默认的。</target>
        </trans-unit>
        <trans-unit id="d1832ee4b35f2abfa3f4e141edadd28f18085110" translate="yes" xml:space="preserve">
          <source>Compile code for big-endian targets. Use of these options is now deprecated. Big-endian code is supported by configuring GCC to build &lt;code&gt;arceb-elf32&lt;/code&gt; and &lt;code&gt;arceb-linux-uclibc&lt;/code&gt; targets, for which big endian is the default.</source>
          <target state="translated">编译大端目标的代码。现在不建议使用这些选项。通过配置GCC来构建 &lt;code&gt;arceb-elf32&lt;/code&gt; 和 &lt;code&gt;arceb-linux-uclibc&lt;/code&gt; 目标来支持big-endian代码，默认情况下为big endian。</target>
        </trans-unit>
        <trans-unit id="be8c22e36ad1f39109ec2efd6cc1a81d955acd13" translate="yes" xml:space="preserve">
          <source>Compile code for little-endian mode.</source>
          <target state="translated">编译小二烯模式的代码。</target>
        </trans-unit>
        <trans-unit id="9b8ec4f965ec58185bb6754ac805aafeb89d3ae4" translate="yes" xml:space="preserve">
          <source>Compile code for little-endian targets. Use of these options is now deprecated. Little-endian code is supported by configuring GCC to build &lt;code&gt;arc-elf32&lt;/code&gt; and &lt;code&gt;arc-linux-uclibc&lt;/code&gt; targets, for which little endian is the default.</source>
          <target state="translated">编译小端目标的代码。现在不建议使用这些选项。通过配置GCC来构建 &lt;code&gt;arc-elf32&lt;/code&gt; 和 &lt;code&gt;arc-linux-uclibc&lt;/code&gt; 目标，可以支持little-endian代码，对于这些目标，默认为little-endian。</target>
        </trans-unit>
        <trans-unit id="b9cb11574bb395057387b096cea7b6d6f515f971" translate="yes" xml:space="preserve">
          <source>Compile code for the processor in big-endian mode.</source>
          <target state="translated">以大段模式编译处理器的代码。</target>
        </trans-unit>
        <trans-unit id="9f489feb9b6caedf9bb6320c99f84e7364f3077b" translate="yes" xml:space="preserve">
          <source>Compile code for the processor in little-endian mode.</source>
          <target state="translated">以小二烯模式编译处理器的代码。</target>
        </trans-unit>
        <trans-unit id="39bc5e8e166e8b03d8be316efdd326cda59c0f57" translate="yes" xml:space="preserve">
          <source>Compile for ARC 600 CPU with &lt;code&gt;norm&lt;/code&gt; and 32x16-bit multiply instructions enabled.</source>
          <target state="translated">为ARC 600 CPU编译并启用了 &lt;code&gt;norm&lt;/code&gt; 和32x16位乘法指令。</target>
        </trans-unit>
        <trans-unit id="17be7dfb615c6d886c0d693b9048e7e155b99fb6" translate="yes" xml:space="preserve">
          <source>Compile for ARC 600 CPU with &lt;code&gt;norm&lt;/code&gt; and &lt;code&gt;mul64&lt;/code&gt;-family instructions enabled.</source>
          <target state="translated">在启用了 &lt;code&gt;norm&lt;/code&gt; 和 &lt;code&gt;mul64&lt;/code&gt; 系列说明的情况下针对ARC 600 CPU进行编译。</target>
        </trans-unit>
        <trans-unit id="d7f2d72dcd31900923f3da8d539cfc9292aa3f8e" translate="yes" xml:space="preserve">
          <source>Compile for ARC 600 CPU with &lt;code&gt;norm&lt;/code&gt; instructions enabled.</source>
          <target state="translated">在启用了 &lt;code&gt;norm&lt;/code&gt; 指令的情况下针对ARC 600 CPU进行编译。</target>
        </trans-unit>
        <trans-unit id="16696f4c8426aaf6854eeea45ee7e1bd467edd27" translate="yes" xml:space="preserve">
          <source>Compile for ARC 601 CPU with &lt;code&gt;norm&lt;/code&gt; and 32x16-bit multiply instructions enabled.</source>
          <target state="translated">为ARC 601 CPU编译并启用了 &lt;code&gt;norm&lt;/code&gt; 和32x16位乘法指令。</target>
        </trans-unit>
        <trans-unit id="5bca932c9c4e343d44b89be260ad06bfe429ab8a" translate="yes" xml:space="preserve">
          <source>Compile for ARC 601 CPU with &lt;code&gt;norm&lt;/code&gt; and &lt;code&gt;mul64&lt;/code&gt;-family instructions enabled.</source>
          <target state="translated">在启用了 &lt;code&gt;norm&lt;/code&gt; 和 &lt;code&gt;mul64&lt;/code&gt; 系列指令的情况下为ARC 601 CPU进行编译。</target>
        </trans-unit>
        <trans-unit id="02df7632e889a6c5616971f35e12edcc4a5d8c62" translate="yes" xml:space="preserve">
          <source>Compile for ARC 601 CPU with &lt;code&gt;norm&lt;/code&gt; instructions enabled.</source>
          <target state="translated">在启用了 &lt;code&gt;norm&lt;/code&gt; 指令的情况下为ARC 601 CPU进行编译。</target>
        </trans-unit>
        <trans-unit id="b7fdc4d4b7214e5e7819e3d3a90236053d8b22cd" translate="yes" xml:space="preserve">
          <source>Compile for ARC 700 on NPS400 chip.</source>
          <target state="translated">在NPS400芯片上为ARC 700编译。</target>
        </trans-unit>
        <trans-unit id="1e4380f255d2d18d4e8f267e7678f7435eab73b8" translate="yes" xml:space="preserve">
          <source>Compile for ARC EM CPU with no hardware extensions.</source>
          <target state="translated">为ARC EM CPU编译,无硬件扩展。</target>
        </trans-unit>
        <trans-unit id="d617eff21e80138509c5fb71d3dfb75e71687f6e" translate="yes" xml:space="preserve">
          <source>Compile for ARC EM minimalist configuration featuring reduced register set.</source>
          <target state="translated">编译ARC EM最小化配置,减少寄存器集。</target>
        </trans-unit>
        <trans-unit id="75b4e707d87f6b65d51c529906a072e95ff89b29" translate="yes" xml:space="preserve">
          <source>Compile for ARC EM.</source>
          <target state="translated">为ARC EM编译。</target>
        </trans-unit>
        <trans-unit id="da70dd835733600356587db74a19ff09214dbd17" translate="yes" xml:space="preserve">
          <source>Compile for ARC EM4 CPU.</source>
          <target state="translated">为ARC EM4 CPU编译。</target>
        </trans-unit>
        <trans-unit id="a460d3a31969ec154e7b1632e56830c60250b541" translate="yes" xml:space="preserve">
          <source>Compile for ARC EM4 DMIPS CPU with single-precision floating-point and double assist instructions.</source>
          <target state="translated">编译用于ARC EM4 DMIPS CPU的单精度浮点和双辅助指令。</target>
        </trans-unit>
        <trans-unit id="a5b00683884602ca4044736a233bc8c892a0f636" translate="yes" xml:space="preserve">
          <source>Compile for ARC EM4 DMIPS CPU with the single-precision floating-point extension.</source>
          <target state="translated">编译用于ARC EM4 DMIPS CPU的单精度浮点扩展。</target>
        </trans-unit>
        <trans-unit id="88b1ffe9efdf7ea63c9f3422bb5547df94d22ce1" translate="yes" xml:space="preserve">
          <source>Compile for ARC EM4 DMIPS CPU.</source>
          <target state="translated">为ARC EM4 DMIPS CPU编译。</target>
        </trans-unit>
        <trans-unit id="086d9196358fe7f0fa7f3e7051ae4fc4f433b7ae" translate="yes" xml:space="preserve">
          <source>Compile for ARC HS CPU with no hardware extensions except the atomic instructions.</source>
          <target state="translated">为ARC HS CPU编译,除了原子指令外,没有任何硬件扩展。</target>
        </trans-unit>
        <trans-unit id="cacfee18847f11dad685598d36ea6ee3b6957c02" translate="yes" xml:space="preserve">
          <source>Compile for ARC HS.</source>
          <target state="translated">为ARC HS编译。</target>
        </trans-unit>
        <trans-unit id="847cd27652d52b58f36a4f2e5ea5cead4371673c" translate="yes" xml:space="preserve">
          <source>Compile for ARC HS34 CPU.</source>
          <target state="translated">为ARC HS34 CPU编译。</target>
        </trans-unit>
        <trans-unit id="d44b3581972b8ea0a69f39fb0ebefd762b42bbe7" translate="yes" xml:space="preserve">
          <source>Compile for ARC HS38 CPU with all hardware extensions on.</source>
          <target state="translated">为ARC HS38 CPU编译,并开启所有硬件扩展。</target>
        </trans-unit>
        <trans-unit id="4c711906d8e4d4a87fb48440c2cfaa0c80bee620" translate="yes" xml:space="preserve">
          <source>Compile for ARC HS38 CPU.</source>
          <target state="translated">为ARC HS38 CPU编译。</target>
        </trans-unit>
        <trans-unit id="8348ca27592b892d967948ee652e94376f711101" translate="yes" xml:space="preserve">
          <source>Compile for ARC600. Aliases:</source>
          <target state="translated">为ARC600编译。别名:</target>
        </trans-unit>
        <trans-unit id="9c0fc8bbbde2253a58a83a11623bea243e8a7c8b" translate="yes" xml:space="preserve">
          <source>Compile for ARC601. Alias:</source>
          <target state="translated">为ARC601编译。别名:</target>
        </trans-unit>
        <trans-unit id="05e0d990baf06011ef4d82bdf9df53fdce00286b" translate="yes" xml:space="preserve">
          <source>Compile for ARC700. Aliases:</source>
          <target state="translated">为ARC700编译。别名:</target>
        </trans-unit>
        <trans-unit id="e278797da8990f0ccb7f07f045508cd4010b76aa" translate="yes" xml:space="preserve">
          <source>Compile for GCN3 Fiji devices (gfx803).</source>
          <target state="translated">为GCN3 Fiji设备(gfx803)编译。</target>
        </trans-unit>
        <trans-unit id="713b8f86530a1c2d9a5d702e486321c4dc351849" translate="yes" xml:space="preserve">
          <source>Compile for GCN5 Vega 10 devices (gfx900).</source>
          <target state="translated">为GCN5 Vega 10设备(gfx900)编译。</target>
        </trans-unit>
        <trans-unit id="b90b725a08b6d96eebe36b77a50cd90bcf52390d" translate="yes" xml:space="preserve">
          <source>Compile for GCN5 Vega 20 devices (gfx906).</source>
          <target state="translated">为GCN5 Vega 20设备(gfx906)编译。</target>
        </trans-unit>
        <trans-unit id="d6c48f84ed7faf104f474152b0d3bc268ee56eba" translate="yes" xml:space="preserve">
          <source>Compile or assemble the source files, but do not link. The linking stage simply is not done. The ultimate output is in the form of an object file for each source file.</source>
          <target state="translated">编译或组装源文件,但不要链接。链接阶段根本没有完成。最终输出的是每个源文件的对象文件形式。</target>
        </trans-unit>
        <trans-unit id="aada22a2dba27d65c33f8d484ca9df970f74fa8a" translate="yes" xml:space="preserve">
          <source>Compile the source files additionally with</source>
          <target state="translated">编译源文件,另外用</target>
        </trans-unit>
        <trans-unit id="8e1d1625ee50b70503b880bddd8c2899625cfd1d" translate="yes" xml:space="preserve">
          <source>Compile the source files with</source>
          <target state="translated">编译源文件时使用</target>
        </trans-unit>
        <trans-unit id="bae2f3f4c4da22165b65f81f0ab47bfdf72e5a74" translate="yes" xml:space="preserve">
          <source>Compile your code with</source>
          <target state="translated">编译你的代码,用</target>
        </trans-unit>
        <trans-unit id="61a5380160ff93557be23ea688dad9be208e4dbd" translate="yes" xml:space="preserve">
          <source>Compile your template-using code with</source>
          <target state="translated">编译你的模板使用代码</target>
        </trans-unit>
        <trans-unit id="bb1fb4ab4c5c8120d8c582a624d0a9ac53f55fe3" translate="yes" xml:space="preserve">
          <source>Compiler encoding</source>
          <target state="translated">编译器编码</target>
        </trans-unit>
        <trans-unit id="24922f29f09454ba5b177fdcf5e81c9543043eef" translate="yes" xml:space="preserve">
          <source>Compiler support for type traits.</source>
          <target state="translated">编译器对类型特征的支持。</target>
        </trans-unit>
        <trans-unit id="2d58377b2111c9408f411d965f3b8abfb37ec05b" translate="yes" xml:space="preserve">
          <source>Compiling C++ programs.</source>
          <target state="translated">编译C++程序。</target>
        </trans-unit>
        <trans-unit id="ed13de84ad4a0f0cd9e6bd0e630f5cc19d816c7d" translate="yes" xml:space="preserve">
          <source>Compiling a header once, and using it many times.</source>
          <target state="translated">编译一次头条,多次使用。</target>
        </trans-unit>
        <trans-unit id="a9cb191f84bf0e0a5fd4e8fafa0cbeb0ce255ebb" translate="yes" xml:space="preserve">
          <source>Compiling with</source>
          <target state="translated">编译</target>
        </trans-unit>
        <trans-unit id="8097f9a2f49c7bb34a8f3d4a23b5682dee4f13c4" translate="yes" xml:space="preserve">
          <source>Complex multiplication and division follow Fortran rules. Range reduction is done as part of complex division, but there is no checking whether the result of a complex multiplication or division is &lt;code&gt;NaN
+ I*NaN&lt;/code&gt;, with an attempt to rescue the situation in that case.</source>
          <target state="translated">复杂的乘法和除法遵循Fortran规则。范围缩小是复数除法的一部分，但是没有检查复数乘法或除法的结果是否为 &lt;code&gt;NaN + I*NaN&lt;/code&gt; ，从而试图挽救这种情况。</target>
        </trans-unit>
        <trans-unit id="e323088fd5a174d70e9a002849c8a4e688bcae61" translate="yes" xml:space="preserve">
          <source>Complex types</source>
          <target state="translated">复杂类型</target>
        </trans-unit>
        <trans-unit id="a513e209b739423b55158eb7f0004ee614ede0ee" translate="yes" xml:space="preserve">
          <source>Comply with the calling conventions defined by Renesas.</source>
          <target state="translated">遵守Renesas定义的调用惯例。</target>
        </trans-unit>
        <trans-unit id="7ca1263e4404b74af40b4e0106fd5b298bab578a" translate="yes" xml:space="preserve">
          <source>Comply with the calling conventions defined for GCC before the Renesas conventions were available. This option is the default for all targets of the SH toolchain.</source>
          <target state="translated">遵守在Renesas约定之前为GCC定义的调用约定。这个选项是所有SH工具链目标的默认值。</target>
        </trans-unit>
        <trans-unit id="8065b09eb57234d64105b727689f45402502d3a0" translate="yes" xml:space="preserve">
          <source>Compound literals for scalar types and union types are also allowed. In the following example the variable &lt;code&gt;i&lt;/code&gt; is initialized to the value &lt;code&gt;2&lt;/code&gt;, the result of incrementing the unnamed object created by the compound literal.</source>
          <target state="translated">标量类型和联合类型的复合文字也被允许。在下面的示例中，变量 &lt;code&gt;i&lt;/code&gt; 初始化为值 &lt;code&gt;2&lt;/code&gt; ，该值是由复合文字创建的未命名对象递增的结果。</target>
        </trans-unit>
        <trans-unit id="a6bff82561ec7274ee97d8914e7822d45d55dda6" translate="yes" xml:space="preserve">
          <source>Compound literals give structures, unions or arrays as values.</source>
          <target state="translated">复合字元给出结构、联合或数组作为值。</target>
        </trans-unit>
        <trans-unit id="9966e73a786b7c65f837b6274e264d2ae3402caf" translate="yes" xml:space="preserve">
          <source>Compress all code using the Ft32B code compression scheme.</source>
          <target state="translated">使用Ft32B代码压缩方案压缩所有代码。</target>
        </trans-unit>
        <trans-unit id="6c77d95794a767632393b14f518d98416da9d81b" translate="yes" xml:space="preserve">
          <source>Compute the overlap score between the two specified profile directories. The overlap score is computed based on the arc profiles. It is defined as the sum of min (p1_counter[i] / p1_sum_all, p2_counter[i] / p2_sum_all), for all arc counter i, where p1_counter[i] and p2_counter[i] are two matched counters and p1_sum_all and p2_sum_all are the sum of counter values in profile 1 and profile 2, respectively.</source>
          <target state="translated">计算两个指定剖面目录之间的重叠得分。重叠得分是根据弧形轮廓计算的。它被定义为所有弧形计数器i的最小值(p1_counter[i]/p1_sum_all,p2_counter[i]/p2_sum_all)之和,其中p1_counter[i]和p2_counter[i]是两个匹配的计数器,p1_sum_all和p2_sum_all分别是剖面1和剖面2的计数器值之和。</target>
        </trans-unit>
        <trans-unit id="e0428c06ffccfdc67cd165569d403d34631d68a4" translate="yes" xml:space="preserve">
          <source>Condition code register</source>
          <target state="translated">条件码注册</target>
        </trans-unit>
        <trans-unit id="0ae2a8a1d30f4ab16342776ecad8922a8468db3e" translate="yes" xml:space="preserve">
          <source>Condition register field 0, &lt;code&gt;cr0&lt;/code&gt;.</source>
          <target state="translated">条件寄存器字段0， &lt;code&gt;cr0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e7cba93bc22565aab9f967f87bf72c15fbda6979" translate="yes" xml:space="preserve">
          <source>Conditional move based on absolute comparison (&lt;code&gt;cabs.&lt;var&gt;cond&lt;/var&gt;.ps&lt;/code&gt;, &lt;code&gt;movt.ps&lt;/code&gt;/&lt;code&gt;movf.ps&lt;/code&gt;).</source>
          <target state="translated">基于绝对比较条件移动（ &lt;code&gt;cabs.&lt;var&gt;cond&lt;/var&gt;.ps&lt;/code&gt; ， &lt;code&gt;movt.ps&lt;/code&gt; / &lt;code&gt;movf.ps&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="ef8ee622eb15147934b0f1ea15e7848c0fa98464" translate="yes" xml:space="preserve">
          <source>Conditional move based on floating-point comparison (&lt;code&gt;c.&lt;var&gt;cond&lt;/var&gt;.ps&lt;/code&gt;, &lt;code&gt;movt.ps&lt;/code&gt;/&lt;code&gt;movf.ps&lt;/code&gt;).</source>
          <target state="translated">基于浮点比较条件移动（ &lt;code&gt;c.&lt;var&gt;cond&lt;/var&gt;.ps&lt;/code&gt; ， &lt;code&gt;movt.ps&lt;/code&gt; / &lt;code&gt;movf.ps&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="34fb4ffc803fecfe4e7aef7908f668b60686f196" translate="yes" xml:space="preserve">
          <source>Configure a board specific runtime. This will be passed to the linker for newlib board library linking. The default is &lt;code&gt;or1ksim&lt;/code&gt;.</source>
          <target state="translated">配置主板特定的运行时。这将传递给链接器以进行newlib板库链接。缺省值为 &lt;code&gt;or1ksim&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="73691e44c058afa420e3a5b298659ae385093f25" translate="yes" xml:space="preserve">
          <source>Conform to the language syntax of Objective-C 1.0, the language recognized by GCC 4.0. This only affects the Objective-C additions to the C/C++ language; it does not affect conformance to C/C++ standards, which is controlled by the separate C/C++ dialect option flags. When this option is used with the Objective-C or Objective-C++ compiler, any Objective-C syntax that is not recognized by GCC 4.0 is rejected. This is useful if you need to make sure that your Objective-C code can be compiled with older versions of GCC.</source>
          <target state="translated">符合Objective-C 1.0的语言语法,即GCC 4.0认可的语言。这只影响Objective-C对C/C++语言的添加,它不影响对C/C++标准的符合性,这是由单独的C/C++方言选项标志控制的。当这个选项与Objective-C或Objective-C++编译器一起使用时,任何不被GCC 4.0识别的Objective-C语法都会被拒绝。如果你需要确保你的Objective-C代码可以用旧版本的GCC编译,这个选项就很有用。</target>
        </trans-unit>
        <trans-unit id="276327c90b14e9bc39dc498e6536c698c6fb7874" translate="yes" xml:space="preserve">
          <source>Conformance to the same ABI and the same behavior of implementation-defined features are both relevant for compatibility.</source>
          <target state="translated">遵循相同的ABI和实现定义的特性的相同行为都与兼容性有关。</target>
        </trans-unit>
        <trans-unit id="af74bda50719fa1b3103b3627d3eb38149eb7313" translate="yes" xml:space="preserve">
          <source>Consider (as in C99 subclause 6.7.5 paragraph 4) a declaration &lt;code&gt;T
D1&lt;/code&gt;, where &lt;code&gt;T&lt;/code&gt; contains declaration specifiers that specify a type &lt;var&gt;Type&lt;/var&gt; (such as &lt;code&gt;int&lt;/code&gt;) and &lt;code&gt;D1&lt;/code&gt; is a declarator that contains an identifier &lt;var&gt;ident&lt;/var&gt;. The type specified for &lt;var&gt;ident&lt;/var&gt; for derived declarators whose type does not include an attribute specifier is as in the ISO C standard.</source>
          <target state="translated">考虑一个声明 &lt;code&gt;T D1&lt;/code&gt; （如C99中第6.7.5节第4款所述），其中 &lt;code&gt;T&lt;/code&gt; 包含指定类型 &lt;var&gt;Type&lt;/var&gt; 的声明说明符（例如 &lt;code&gt;int&lt;/code&gt; ）， &lt;code&gt;D1&lt;/code&gt; 是包含标识符 &lt;var&gt;ident&lt;/var&gt; 的声明符。为派生声明符的 &lt;var&gt;ident&lt;/var&gt; 指定的类型（其类型不包含属性说明符）与ISO C标准相同。</target>
        </trans-unit>
        <trans-unit id="9b667c089da7e561b4d6f55e12e93a78181226e5" translate="yes" xml:space="preserve">
          <source>Consider all &lt;code&gt;static&lt;/code&gt; functions called once for inlining into their caller even if they are not marked &lt;code&gt;inline&lt;/code&gt;. If a call to a given function is integrated, then the function is not output as assembler code in its own right.</source>
          <target state="translated">考虑所有一次调用的 &lt;code&gt;static&lt;/code&gt; 函数以内联到其调用方中，即使它们未标记为 &lt;code&gt;inline&lt;/code&gt; 。如果集成了对给定函数的调用，则该函数本身不会作为汇编代码输出。</target>
        </trans-unit>
        <trans-unit id="35a3be8ed672f20c07ec027046430f867cf3e587" translate="yes" xml:space="preserve">
          <source>Consider all functions for inlining, even if they are not declared inline. The compiler heuristically decides which functions are worth integrating in this way.</source>
          <target state="translated">考虑所有函数进行内联,即使它们没有被声明为内联。编译器以启发式的方式决定哪些函数值得以这种方式集成。</target>
        </trans-unit>
        <trans-unit id="7b85816a30be72db5578a7db246b88f298f1a216" translate="yes" xml:space="preserve">
          <source>Consider that instructions that may throw exceptions but don&amp;rsquo;t otherwise contribute to the execution of the program can be optimized away. This option is enabled by default for the Ada front end, as permitted by the Ada language specification. Optimization passes that cause dead exceptions to be removed are enabled independently at different optimization levels.</source>
          <target state="translated">考虑到可能会抛出异常但不会对程序执行有贡献的指令可以被优化掉。默认情况下，Ada前端会启用此选项，这是Ada语言规范所允许的。可在不同的优化级别上独立启用导致清除异常的优化过程。</target>
        </trans-unit>
        <trans-unit id="56b80af072fa83ee95788ec24e46c4595598d634" translate="yes" xml:space="preserve">
          <source>Consider the following example,</source>
          <target state="translated">请看下面的例子。</target>
        </trans-unit>
        <trans-unit id="a59af01b7f010c19c9dde4af8032ceeec0657a9d" translate="yes" xml:space="preserve">
          <source>Consider type &lt;code&gt;int&lt;/code&gt; to be 16 bits wide, like &lt;code&gt;short int&lt;/code&gt;. Additionally, parameters passed on the stack are also aligned to a 16-bit boundary even on targets whose API mandates promotion to 32-bit.</source>
          <target state="translated">考虑 &lt;code&gt;int&lt;/code&gt; 类型为16位宽，例如 &lt;code&gt;short int&lt;/code&gt; 。此外，即使在其API要求提升为32位的目标上，在堆栈上传递的参数也与16位边界对齐。</target>
        </trans-unit>
        <trans-unit id="14249be6954dd348580bb1e0a79129f5f1192211" translate="yes" xml:space="preserve">
          <source>Constant 255.</source>
          <target state="translated">常数255。</target>
        </trans-unit>
        <trans-unit id="7c36129cdf24a616a089dfb7d284688c9138762e" translate="yes" xml:space="preserve">
          <source>Constant 65535.</source>
          <target state="translated">常数65535。</target>
        </trans-unit>
        <trans-unit id="7ebcf06cc87a00b632c948fbc204e56f0827cd01" translate="yes" xml:space="preserve">
          <source>Constant &lt;var&gt;n&lt;/var&gt;, where &lt;var&gt;n&lt;/var&gt; is a single-digit constant in the range 0 to 4.</source>
          <target state="translated">常数 &lt;var&gt;n&lt;/var&gt; ，其中 &lt;var&gt;n&lt;/var&gt; 是0到4范围内的个位数常数。</target>
        </trans-unit>
        <trans-unit id="37323b42fe56e6f04c3dbbef4d9fbb95b7fc380b" translate="yes" xml:space="preserve">
          <source>Constant for arithmetic/logical operations. This is like &lt;code&gt;i&lt;/code&gt;, except that for position independent code, no symbols / expressions needing relocations are allowed.</source>
          <target state="translated">用于算术/逻辑运算的常数。类似于 &lt;code&gt;i&lt;/code&gt; ，除了对于位置无关的代码，不允许需要重定位的符号/表达式。</target>
        </trans-unit>
        <trans-unit id="c7644d686263ca6ceaeace041caa08f8c6cf68aa" translate="yes" xml:space="preserve">
          <source>Constant greater than -1, less than 64</source>
          <target state="translated">常量大于-1,小于64</target>
        </trans-unit>
        <trans-unit id="09c49e4a44186e5736b6b3d234fbcdd1b306818b" translate="yes" xml:space="preserve">
          <source>Constant greater than -64, less than 1</source>
          <target state="translated">大于-64,小于1的常数</target>
        </trans-unit>
        <trans-unit id="629c52a6147c82fa4c525c23e4812fa96465cd8a" translate="yes" xml:space="preserve">
          <source>Constant integer -1</source>
          <target state="translated">常数整数-1</target>
        </trans-unit>
        <trans-unit id="721c7841ba7521d9d4cd87f007487a95dabae8a8" translate="yes" xml:space="preserve">
          <source>Constant integer 0</source>
          <target state="translated">常数整数0</target>
        </trans-unit>
        <trans-unit id="4c0d77dad954cfa376cbed314919134fe483d92e" translate="yes" xml:space="preserve">
          <source>Constant integer 1</source>
          <target state="translated">常数整数1</target>
        </trans-unit>
        <trans-unit id="a0be78fc92c33b25cda27188d52e852922b4e406" translate="yes" xml:space="preserve">
          <source>Constant integer 2</source>
          <target state="translated">常数整数2</target>
        </trans-unit>
        <trans-unit id="202072b2675376ab5d42618242f422abd21566ab" translate="yes" xml:space="preserve">
          <source>Constant integer 8, 16, or 24</source>
          <target state="translated">常数整数8,16,或24。</target>
        </trans-unit>
        <trans-unit id="5bf3f3ad783e97cd6b61e26de5af436d02b8dbc8" translate="yes" xml:space="preserve">
          <source>Constant integer with a value of 0x7fffffff.</source>
          <target state="translated">常数整数,值为0x7fffffff。</target>
        </trans-unit>
        <trans-unit id="4b2e9b490d5b5f4c17de70d9c9fdf5aa2b4b1450" translate="yes" xml:space="preserve">
          <source>Constant larger than 31</source>
          <target state="translated">大于31的常数</target>
        </trans-unit>
        <trans-unit id="47f3d5d59a235c75b0766f99a2edf9666aa348c9" translate="yes" xml:space="preserve">
          <source>Constant that fits in 8 bits</source>
          <target state="translated">适合8位的常数</target>
        </trans-unit>
        <trans-unit id="719b7b797492e1507d09c13adb21a02c3fe64069" translate="yes" xml:space="preserve">
          <source>Constant whose negation is a signed 16-bit constant</source>
          <target state="translated">常量的否定值是一个有符号的16位常量。</target>
        </trans-unit>
        <trans-unit id="180e678224087bf03d6c9c2f7ac11f4d9834fa9a" translate="yes" xml:space="preserve">
          <source>Constant zero</source>
          <target state="translated">恒定零度</target>
        </trans-unit>
        <trans-unit id="a9100a8537fb85e4bf388bedae7d5d58f76e7b6e" translate="yes" xml:space="preserve">
          <source>Constant?</source>
          <target state="translated">Constant?</target>
        </trans-unit>
        <trans-unit id="7efcb4b4f328cdb249f8926cb267f61ac8015a9d" translate="yes" xml:space="preserve">
          <source>Constraints for &lt;code&gt;asm&lt;/code&gt; operands</source>
          <target state="translated">&lt;code&gt;asm&lt;/code&gt; 操作数的约束</target>
        </trans-unit>
        <trans-unit id="3e3f7e5411ee0f1fda2ac40b39097fae6a9abb77" translate="yes" xml:space="preserve">
          <source>Constructs webs as commonly used for register allocation purposes and assign each web individual pseudo register. This allows the register allocation pass to operate on pseudos directly, but also strengthens several other optimization passes, such as CSE, loop optimizer and trivial dead code remover. It can, however, make debugging impossible, since variables no longer stay in a &amp;ldquo;home register&amp;rdquo;.</source>
          <target state="translated">构造通常用于寄存器分配目的的网络，并为每个网络分配单独的伪寄存器。这使寄存器分配过程可以直接对伪操作进行操作，还可以增强其他一些优化过程，例如CSE，循环优化器和琐碎的死代码清除器。但是，由于变量不再保留在&amp;ldquo;本地寄存器&amp;rdquo;中，因此它可能使调试变得不可能。</target>
        </trans-unit>
        <trans-unit id="d4f501afecf0b8b5f3993371f4f6074a753dc0e6" translate="yes" xml:space="preserve">
          <source>Contributors to GCC</source>
          <target state="translated">海合会捐款者</target>
        </trans-unit>
        <trans-unit id="4648a291e89516ba0f4f56b93d6fdb1d01cfd9c4" translate="yes" xml:space="preserve">
          <source>Control GCC&amp;rsquo;s optimizations to produce output suitable for live-patching.</source>
          <target state="translated">控制GCC的优化以产生适合实时修补的输出。</target>
        </trans-unit>
        <trans-unit id="2000010d8fcae415d2b9780e43435379e14ee053" translate="yes" xml:space="preserve">
          <source>Control how GCC aligns variables and constants of array, structure, or union types. Supported values for &lt;var&gt;type&lt;/var&gt; are &amp;lsquo;</source>
          <target state="translated">控制GCC如何对齐数组，结构或联合类型的变量和常量。支持的 &lt;var&gt;type&lt;/var&gt; 值为&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="bcc7b6b362569344fe25ab394774bd26a1bf6f6a" translate="yes" xml:space="preserve">
          <source>Control how GCC aligns variables. Supported values for &lt;var&gt;type&lt;/var&gt; are &amp;lsquo;</source>
          <target state="translated">控制GCC如何对齐变量。支持的 &lt;var&gt;type&lt;/var&gt; 值为&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="7e88213c055c1aca5596a30dea879bf4859e75f5" translate="yes" xml:space="preserve">
          <source>Control how many registers are used to pass integer arguments. By default, no registers are used to pass arguments, and at most 3 registers can be used. You can control this behavior for a specific function by using the function attribute &lt;code&gt;regparm&lt;/code&gt;. See &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;Function Attributes&lt;/a&gt;.</source>
          <target state="translated">控制使用多少个寄存器传递整数参数。默认情况下，不使用任何寄存器来传递参数，并且最多可以使用3个寄存器。您可以使用功能属性 &lt;code&gt;regparm&lt;/code&gt; 来控制特定功能的此行为。请参阅&lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;函数属性&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ae31e36dd1f96d1b47c3f78f649f25722c9f1d7b" translate="yes" xml:space="preserve">
          <source>Control if warning triggered by the &lt;code&gt;warn_if_not_aligned&lt;/code&gt; attribute should be issued. This is enabled by default. Use</source>
          <target state="translated">控制是否发出由 &lt;code&gt;warn_if_not_aligned&lt;/code&gt; 属性触发的警告。默认情况下启用。用</target>
        </trans-unit>
        <trans-unit id="9e5c3f2f79d503814d4fe18475f20d72c26564d7" translate="yes" xml:space="preserve">
          <source>Control if warnings triggered by the &lt;code&gt;warn_if_not_aligned&lt;/code&gt; attribute should be issued. These warnings are enabled by default.</source>
          <target state="translated">控制是否发出由 &lt;code&gt;warn_if_not_aligned&lt;/code&gt; 属性触发的警告。这些警告默认情况下处于启用状态。</target>
        </trans-unit>
        <trans-unit id="7631dd8867c98dbe9aea4e0521ca0a270c9af1bd" translate="yes" xml:space="preserve">
          <source>Control level of reproducibility of profile gathered by &lt;code&gt;-fprofile-generate&lt;/code&gt;. This makes it possible to rebuild program with same outcome which is useful, for example, for distribution packages.</source>
          <target state="translated">&lt;code&gt;-fprofile-generate&lt;/code&gt; 收集的配置文件可再现性的控制级别。这样就可以重建具有相同结果的程序，这对于分发程序包很有用。</target>
        </trans-unit>
        <trans-unit id="a2f461ee948da2dba5ee60b9ffddb2967c79a05b" translate="yes" xml:space="preserve">
          <source>Control the IEEE compliance of floating-point comparisons, which affects the handling of cases where the result of a comparison is unordered. By default</source>
          <target state="translated">控制浮点比较的IEEE合规性,这将影响比较结果无序时的处理。默认情况下</target>
        </trans-unit>
        <trans-unit id="2afb7e07aedef4a32dbbca185426a76a2840c4b0" translate="yes" xml:space="preserve">
          <source>Control the dumping at various stages of inter-procedural analysis language tree to a file. The file name is generated by appending a switch specific suffix to the source file name, and the file is created in the same directory as the output file. The following dumps are possible:</source>
          <target state="translated">控制程序间分析语言树各阶段的转储到文件中。文件名通过在源文件名上附加开关专用后缀生成,文件与输出文件在同一目录下创建。可以进行以下转储。</target>
        </trans-unit>
        <trans-unit id="f18aaf944d2648faf5bedcbbdbf1ddd945fad607" translate="yes" xml:space="preserve">
          <source>Control the dumping at various stages of processing the intermediate language tree to a file. If the &amp;lsquo;</source>
          <target state="translated">在将中间语言树处理为文件的各个阶段，控制转储。如果&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="c0a71f6d1404f7b16378e5d31c9c7e2a41e97704" translate="yes" xml:space="preserve">
          <source>Control the dumping of language-specific information. The &lt;var&gt;options&lt;/var&gt; and &lt;var&gt;filename&lt;/var&gt; portions behave as described in the</source>
          <target state="translated">控制特定语言信息的转储。的 &lt;var&gt;options&lt;/var&gt; 和 &lt;var&gt;filename&lt;/var&gt; 作为在所描述的行为的部分</target>
        </trans-unit>
        <trans-unit id="d78b6d3fd867212c02526e9987edeed79105b1e7" translate="yes" xml:space="preserve">
          <source>Control the probability of the expression having the specified value. This parameter takes a percentage (i.e. 0 ... 100) as input.</source>
          <target state="translated">控制表达式具有指定值的概率。该参数采用百分比(即0 ...100)作为输入。</target>
        </trans-unit>
        <trans-unit id="3bc8404322e32343cc4763c8bd1ae2d2c9dab937" translate="yes" xml:space="preserve">
          <source>Control the verbosity of the dump file for the integrated register allocator. The default value is 5. If the value &lt;var&gt;n&lt;/var&gt; is greater or equal to 10, the dump output is sent to stderr using the same format as &lt;var&gt;n&lt;/var&gt; minus 10.</source>
          <target state="translated">控制集成寄存器分配器的转储文件的详细程度。默认值为5。如果值 &lt;var&gt;n&lt;/var&gt; 大于或等于10，则转储输出将使用与 &lt;var&gt;n&lt;/var&gt; 减10 相同的格式发送到stderr 。</target>
        </trans-unit>
        <trans-unit id="f9bae08f2081e939f273d8f52a1db45d82560f46" translate="yes" xml:space="preserve">
          <source>Control whether GCC aligns &lt;code&gt;double&lt;/code&gt;, &lt;code&gt;long double&lt;/code&gt;, and &lt;code&gt;long long&lt;/code&gt; variables on a two-word boundary or a one-word boundary. Aligning &lt;code&gt;double&lt;/code&gt; variables on a two-word boundary produces code that runs somewhat faster on a Pentium at the expense of more memory.</source>
          <target state="translated">控制GCC 在两字边界还是一字边界上对齐 &lt;code&gt;double&lt;/code&gt; ， &lt;code&gt;long double&lt;/code&gt; 和 &lt;code&gt;long long&lt;/code&gt; 变量。在两个单词的边界上对齐 &lt;code&gt;double&lt;/code&gt; 变量会产生在奔腾上运行速度更快的代码，但会占用更多内存。</target>
        </trans-unit>
        <trans-unit id="8f446d353bc1e77fdd352360a3275f518dfbc090" translate="yes" xml:space="preserve">
          <source>Control whether GCC aligns &lt;code&gt;int&lt;/code&gt;, &lt;code&gt;long&lt;/code&gt;, &lt;code&gt;long long&lt;/code&gt;, &lt;code&gt;float&lt;/code&gt;, &lt;code&gt;double&lt;/code&gt;, and &lt;code&gt;long double&lt;/code&gt; variables on a 32-bit boundary (</source>
          <target state="translated">控制GCC是否在32位边界上对齐 &lt;code&gt;int&lt;/code&gt; ， &lt;code&gt;long&lt;/code&gt; ， &lt;code&gt;long long&lt;/code&gt; ， &lt;code&gt;float&lt;/code&gt; ， &lt;code&gt;double&lt;/code&gt; 和 &lt;code&gt;long double&lt;/code&gt; 变量（</target>
        </trans-unit>
        <trans-unit id="75311304fc882ae2426d795d34cedb8140da086e" translate="yes" xml:space="preserve">
          <source>Control whether or not the compiler uses IEEE floating-point comparisons. These correctly handle the case where the result of a comparison is unordered.</source>
          <target state="translated">控制编译器是否使用IEEE浮点比较。这可以正确处理比较结果无序的情况。</target>
        </trans-unit>
        <trans-unit id="62bad428ae7c19b0490d45917456075bd42d88a6" translate="yes" xml:space="preserve">
          <source>Controlling header files and macro definitions. Also, getting dependency information for Make.</source>
          <target state="translated">控制头文件和宏定义。同时,获取Make的依赖信息。</target>
        </trans-unit>
        <trans-unit id="e99744632595e185715acaad17e041aa084fa9ba" translate="yes" xml:space="preserve">
          <source>Controlling how diagnostics should be formatted.</source>
          <target state="translated">控制诊断程序的格式。</target>
        </trans-unit>
        <trans-unit id="e7841aeb7ad7a7b2bbd17b2d58521eec5ba1a4f0" translate="yes" xml:space="preserve">
          <source>Controlling the kind of output: an executable, object files, assembler files, or preprocessed source.</source>
          <target state="translated">控制输出的种类:可执行文件、对象文件、汇编文件或预处理的源文件。</target>
        </trans-unit>
        <trans-unit id="c6ecef85f48d8878d76bfb7e0a0331e88e337d9a" translate="yes" xml:space="preserve">
          <source>Controlling the variant of C language compiled.</source>
          <target state="translated">控制C语言编译的变体。</target>
        </trans-unit>
        <trans-unit id="35f36b715e771eac424fea4a5652ad0db1feb811" translate="yes" xml:space="preserve">
          <source>Controls optimization dumps from various optimization passes. If the &amp;lsquo;</source>
          <target state="translated">控制来自各种优化过程的优化转储。如果&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="addf45283fa1231bccd97d1a11480f865b18f29c" translate="yes" xml:space="preserve">
          <source>Controls warnings if a shift count is greater than or equal to the bit width of the type. This warning is enabled by default.</source>
          <target state="translated">如果移位数大于或等于类型的位宽,控制警告。默认情况下,该警告已启用。</target>
        </trans-unit>
        <trans-unit id="5c8bc0ebce27c4f8597b1ed37dbc7e6eb2315759" translate="yes" xml:space="preserve">
          <source>Controls warnings if a shift count is negative. This warning is enabled by default.</source>
          <target state="translated">控制移位计数为负值时的警告。默认情况下,该警告是启用的。</target>
        </trans-unit>
        <trans-unit id="eae41d379a4cfbab73e910f93e19e6f3bad5167f" translate="yes" xml:space="preserve">
          <source>Controls whether TLS variables may be accessed with offsets from the TLS segment register (&lt;code&gt;%gs&lt;/code&gt; for 32-bit, &lt;code&gt;%fs&lt;/code&gt; for 64-bit), or whether the thread base pointer must be added. Whether or not this is valid depends on the operating system, and whether it maps the segment to cover the entire TLS area.</source>
          <target state="translated">控制是否可以使用TLS段寄存器的偏移量（32位为 &lt;code&gt;%gs&lt;/code&gt; ，64位为 &lt;code&gt;%fs&lt;/code&gt; ）来访问TLS变量，或者是否必须添加线程基指针。这是否有效取决于操作系统，以及它是否将段映射为覆盖整个TLS区域。</target>
        </trans-unit>
        <trans-unit id="eb9ef4e6ab162f6fc8a3bf857fc774382a954629" translate="yes" xml:space="preserve">
          <source>Conversely, &lt;code&gt;bar&lt;/code&gt; and the call to &lt;code&gt;foo&lt;/code&gt; in the fourth marked line are used in contexts that do depend on the type of &lt;code&gt;T&lt;/code&gt;, so they are only looked up at the point of instantiation, and you can provide declarations for them after declaring the template, but before instantiating it. In particular, if you instantiate &lt;code&gt;A::f&amp;lt;int&amp;gt;&lt;/code&gt;, the last line will call an overloaded &lt;code&gt;::foo(int)&lt;/code&gt; if one was provided, even if after the declaration of &lt;code&gt;struct A&lt;/code&gt;.</source>
          <target state="translated">相反，在第四条标记行中使用 &lt;code&gt;bar&lt;/code&gt; 和对 &lt;code&gt;foo&lt;/code&gt; 的调用在确实取决于 &lt;code&gt;T&lt;/code&gt; 类型的上下文中使用，因此它们仅在实例化点被查找，并且您可以在声明模板后为其提供声明，但是在实例化它之前。特别是，如果实例化 &lt;code&gt;A::f&amp;lt;int&amp;gt;&lt;/code&gt; ，即使提供了 &lt;code&gt;struct A&lt;/code&gt; 的声明，如果提供了最后一行，即使提供了一个，也将调用重载 &lt;code&gt;::foo(int)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1dbc54a6ca4a64275cd12138ea70589c4f463e73" translate="yes" xml:space="preserve">
          <source>Conversely, if the register is a call-clobbered register, making calls to functions that use standard ABI may lose contents of the variable. Such calls may be created by the compiler even if none are evident in the original program, for example when libgcc functions are used to make up for unavailable instructions.</source>
          <target state="translated">相反,如果寄存器是一个调用-clobbered寄存器,那么调用使用标准ABI的函数可能会丢失变量的内容。即使在原始程序中没有明显的调用,编译器也可能产生这样的调用,例如当libgcc函数被用来弥补不可用的指令时。</target>
        </trans-unit>
        <trans-unit id="ff7d2b7b709500e425e46256b872f1c524a8fe88" translate="yes" xml:space="preserve">
          <source>Conversely, when you include the same header file in a main source file that declares it as &amp;lsquo;</source>
          <target state="translated">相反，当您在主源文件中包含相同的头文件并将其声明为&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="f8292e36ff2425ba64b2fca8bba18ef8c5d24cbf" translate="yes" xml:space="preserve">
          <source>Conversion from double precision to single precision.</source>
          <target state="translated">从双精度转换为单精度。</target>
        </trans-unit>
        <trans-unit id="e8f87ba256340926897664cced7edc0ce8ec124d" translate="yes" xml:space="preserve">
          <source>Conversion from floating point to signed or unsigned integer types, with truncation towards zero.</source>
          <target state="translated">从浮点数转换为有符号或无符号整数类型,截断为零。</target>
        </trans-unit>
        <trans-unit id="e8ec2eea2629558824283e676ad9bac71b3d3e53" translate="yes" xml:space="preserve">
          <source>Conversion from signed or unsigned integer types to floating-point types.</source>
          <target state="translated">从有符号或无符号整数类型转换为浮点类型。</target>
        </trans-unit>
        <trans-unit id="416cd3e7b0ad0f46f99e977b880dc368db1cdff8" translate="yes" xml:space="preserve">
          <source>Conversion from single precision to double precision.</source>
          <target state="translated">从单精度转换为双精度。</target>
        </trans-unit>
        <trans-unit id="0fc5b8691f90f80b04961e22033d17dee1964933" translate="yes" xml:space="preserve">
          <source>Conversion from single-precision floating point to signed integer, rounding to the nearest integer and ties away from zero. This corresponds to the &lt;code&gt;__builtin_lroundf&lt;/code&gt; function when</source>
          <target state="translated">从单精度浮点到有符号整数的转换，四舍五入到最接近的整数并从零开始平移。这对应于 &lt;code&gt;__builtin_lroundf&lt;/code&gt; 函数，当</target>
        </trans-unit>
        <trans-unit id="536e910ea0e856f9ebf3793f69bec672bb95cd2c" translate="yes" xml:space="preserve">
          <source>Conversions by prototypes between fixed/floating-point values and vice versa. The absence of these prototypes when compiling with traditional C causes serious problems. This is a subset of the possible conversion warnings; for the full set use</source>
          <target state="translated">通过原型在定点/浮点值之间进行转换,反之亦然。在用传统C语言编译时,如果没有这些原型,会导致严重的问题。这是可能出现的转换警告的一个子集,完整的警告集请使用</target>
        </trans-unit>
        <trans-unit id="0912352accd4bfa1711e2febca470cb4f85bbc4c" translate="yes" xml:space="preserve">
          <source>Conversions:</source>
          <target state="translated">Conversions:</target>
        </trans-unit>
        <trans-unit id="baf1df2f34189a80f5d58da24bff382fe6f23f9c" translate="yes" xml:space="preserve">
          <source>Convert a 128-bit IEEE floating point value to &lt;code&gt;double&lt;/code&gt; using round to odd as the rounding mode.</source>
          <target state="translated">使用舍入到奇数作为舍入模式将128位IEEE浮点值转换为 &lt;code&gt;double&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c5f6051eea145ce2adef0c8027dd705cfcc7007e" translate="yes" xml:space="preserve">
          <source>Convert function return with &lt;var&gt;choice&lt;/var&gt;. The default is &amp;lsquo;</source>
          <target state="translated">用 &lt;var&gt;choice&lt;/var&gt; 转换函数返回。默认值为&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="454c8084600f90536a1954e8c20d848d81c823ed" translate="yes" xml:space="preserve">
          <source>Convert indirect call and jump with &lt;var&gt;choice&lt;/var&gt;. The default is &amp;lsquo;</source>
          <target state="translated">转换间接调用并按 &lt;var&gt;choice&lt;/var&gt; 跳转。默认值为&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="e6098cfb721df754afe96180a874c8cc3a1a8ded" translate="yes" xml:space="preserve">
          <source>Convert pair lower to single (&lt;code&gt;cvt.s.pl&lt;/code&gt;).</source>
          <target state="translated">将线对下转换为单（ &lt;code&gt;cvt.s.pl&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="52f3ab191bdd722d1394008161cded401dd949a0" translate="yes" xml:space="preserve">
          <source>Convert pair to paired single (&lt;code&gt;cvt.ps.s&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;cvt.ps.s&lt;/code&gt; 转换为成对的单（cvt.ps.s）。</target>
        </trans-unit>
        <trans-unit id="dbfe6d8e23313dd7f9196c8cdcc1c08381a49c43" translate="yes" xml:space="preserve">
          <source>Convert pair upper to single (&lt;code&gt;cvt.s.pu&lt;/code&gt;).</source>
          <target state="translated">将上对转换为单（ &lt;code&gt;cvt.s.pu&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="055bbf265923b2e5410a5e939d7297c0c9f2b211" translate="yes" xml:space="preserve">
          <source>Convert paired single to paired word (&lt;code&gt;cvt.pw.ps&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;cvt.pw.ps&lt;/code&gt; 对的单字转换为成对的字（cvt.pw.ps）。</target>
        </trans-unit>
        <trans-unit id="8b6b177ab15aa362100af3868aea344b1c1501b0" translate="yes" xml:space="preserve">
          <source>Convert paired word to paired single (&lt;code&gt;cvt.ps.pw&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;cvt.ps.pw&lt;/code&gt; 对的单词转换为成对的单（cvt.ps.pw）。</target>
        </trans-unit>
        <trans-unit id="3b04bf1a5e85023c3eed3599d79cb09164690ab2" translate="yes" xml:space="preserve">
          <source>Copy Assignment operators copy virtual bases twice</source>
          <target state="translated">复制赋值运算符将虚拟基地复制两次</target>
        </trans-unit>
        <trans-unit id="d5eae2b9f3ad758ce3ef79fc7015a6ffa9156eac" translate="yes" xml:space="preserve">
          <source>Copyright &amp;copy; 1988-2019 Free Software Foundation, Inc.</source>
          <target state="translated">版权所有&amp;copy;1988-2019自由软件基金会，Inc.</target>
        </trans-unit>
        <trans-unit id="00d80b436f1c8689f9094a048f0b7d3b3fb4eee4" translate="yes" xml:space="preserve">
          <source>Copyright &amp;copy; 1988-2020 Free Software Foundation, Inc.</source>
          <target state="translated">版权所有&amp;copy;1988-2020自由软件基金会，Inc.</target>
        </trans-unit>
        <trans-unit id="aa5bc69c89234b43d34e0f300cbb8e8580610fdc" translate="yes" xml:space="preserve">
          <source>Core control register class.</source>
          <target state="translated">核心控制寄存器类。</target>
        </trans-unit>
        <trans-unit id="26ed802e7eb78ff2045b4541fe370087376fea5e" translate="yes" xml:space="preserve">
          <source>Cost to assume for a multiply instruction, with &amp;lsquo;</source>
          <target state="translated">乘法指令的假设成本，其中&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="c2ddd3bb796bfb895719a519a79aeec2d836822b" translate="yes" xml:space="preserve">
          <source>Cost, roughly measured as the cost of a single typical machine instruction, at which GCSE optimizations do not constrain the distance an expression can travel. This is currently supported only in the code hoisting pass. The lesser the cost, the more aggressive code hoisting is. Specifying 0 allows all expressions to travel unrestricted distances.</source>
          <target state="translated">成本,大致以单条典型机器指令的成本来衡量,在这个成本下,GCSE优化不会约束一个表达式可以走的距离。目前只在代码提升通中支持。成本越小,代码提升越激进。指定0可以让所有的表达式走过的距离不受限制。</target>
        </trans-unit>
        <trans-unit id="73a8cda37ae16987b1b76b7dd95bcc1d393efb64" translate="yes" xml:space="preserve">
          <source>Create a canonical counter for number of iterations in loops for which determining number of iterations requires complicated analysis. Later optimizations then may determine the number easily. Useful especially in connection with unrolling.</source>
          <target state="translated">在确定迭代次数需要复杂分析的循环中,为迭代次数创建一个规范的计数器。之后的优化可以很容易地确定迭代次数。特别是在展开循环时有用。</target>
        </trans-unit>
        <trans-unit id="abd404fec245486ddadc6af0006baee144b9f9b5" translate="yes" xml:space="preserve">
          <source>Create a shared object. It is recommended that</source>
          <target state="translated">创建一个共享对象。建议</target>
        </trans-unit>
        <trans-unit id="f1fd203b49f15a9115d31d7e6edbf2d093ba7de0" translate="yes" xml:space="preserve">
          <source>Create constant pools in the compiler instead of deferring it to the assembler. This option is the default and required for correct code generation on CK801 and CK802, and is optional on other processors.</source>
          <target state="translated">在编译器中创建常量池,而不是推迟到汇编器中。这个选项是默认的,在CK801和CK802上是正确生成代码所必需的,在其他处理器上是可选的。</target>
        </trans-unit>
        <trans-unit id="b23e0354f5ad5eff5e150918b9120e5576f9697a" translate="yes" xml:space="preserve">
          <source>Create long file names for included source files. For example, if the header file</source>
          <target state="translated">为包含的源文件创建长文件名。例如,如果头文件是</target>
        </trans-unit>
        <trans-unit id="e38ae255fe9e80cdce8fdaed0460f9c86fe6b8ba" translate="yes" xml:space="preserve">
          <source>Creates a new &amp;lsquo;</source>
          <target state="translated">创建一个新的&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="99dfbad76db4acc6eb91954940ce7b9993db8870" translate="yes" xml:space="preserve">
          <source>Creates an inter-thread happens-before constraint from the release (or stronger) semantic store to this acquire load. Can prevent hoisting of code to before the operation.</source>
          <target state="translated">从release(或更强的)语义存储中创建一个线程间 happens-before 约束到这个获取负载。可以防止将代码提升到操作之前。</target>
        </trans-unit>
        <trans-unit id="281a58c77cb45edf43cfdf897384199b4ab0a3ee" translate="yes" xml:space="preserve">
          <source>Creates an inter-thread happens-before constraint to acquire (or stronger) semantic loads that read from this release store. Can prevent sinking of code to after the operation.</source>
          <target state="translated">创建一个线程间 happens-before 约束,以获取(或更强的)语义负载,从这个释放存储中读取。可以防止代码下沉到操作后。</target>
        </trans-unit>
        <trans-unit id="67ae8f8fb8bba8ab92d3a89b17a6600fa05951e3" translate="yes" xml:space="preserve">
          <source>Creates and defines a register class. These register classes can be used by inline &lt;code&gt;asm&lt;/code&gt; constructs. &lt;var&gt;registers&lt;/var&gt; may be a single register, register range separated by ellipses, or comma-separated list of those. Example:</source>
          <target state="translated">创建并定义一个寄存器类。内联 &lt;code&gt;asm&lt;/code&gt; 构造可以使用这些寄存器类。 &lt;var&gt;registers&lt;/var&gt; 可以是单个寄存器，寄存器范围可以用椭圆分隔，也可以用逗号分隔。例：</target>
        </trans-unit>
        <trans-unit id="6e67e7d1e719647852b7fdbba193a58bb75ed395" translate="yes" xml:space="preserve">
          <source>Critical functions disable interrupts upon entry and restore the previous interrupt state upon exit. Critical functions cannot also have the &lt;code&gt;naked&lt;/code&gt;, &lt;code&gt;reentrant&lt;/code&gt; or &lt;code&gt;interrupt&lt;/code&gt; attributes.</source>
          <target state="translated">关键功能在进入时禁用中断，并在退出时恢复先前的中断状态。关键函数也不能具有 &lt;code&gt;naked&lt;/code&gt; 属性， &lt;code&gt;reentrant&lt;/code&gt; 属性或 &lt;code&gt;interrupt&lt;/code&gt; 属性。</target>
        </trans-unit>
        <trans-unit id="c3cb5c6e6c93496c35c07eb658977d77e8d997f1" translate="yes" xml:space="preserve">
          <source>Current argument is the name of a library or startup file of some sort. Search for that file in a standard list of directories and substitute the full name found. The current working directory is included in the list of directories scanned.</source>
          <target state="translated">当前参数是某个库或某种启动文件的名称。在标准目录列表中搜索该文件,并替换找到的全名。当前工作目录包含在扫描的目录列表中。</target>
        </trans-unit>
        <trans-unit id="27ed6e70669ea07173e0ff90384757c33382fb6e" translate="yes" xml:space="preserve">
          <source>Current argument is the name of a linker script. Search for that file in the current list of directories to scan for libraries. If the file is located insert a</source>
          <target state="translated">当前参数是一个链接器脚本的名称。在当前目录列表中搜索该文件以扫描库。如果该文件被定位,则插入一个</target>
        </trans-unit>
        <trans-unit id="318f590d6974d7ec1e4d3da7f86481fca68df621" translate="yes" xml:space="preserve">
          <source>Current gcov-tool supports the following functionalities:</source>
          <target state="translated">当前的gcov-tool支持以下功能。</target>
        </trans-unit>
        <trans-unit id="883949fd66aefc2f68b17e769896d2b8ef7a23bf" translate="yes" xml:space="preserve">
          <source>Currently the x86 GNU/Linux target provides an implementation based on Intel Control-flow Enforcement Technology (CET).</source>
          <target state="translated">目前x86 GNU/Linux目标提供了基于Intel控制流执行技术(CET)的实现。</target>
        </trans-unit>
        <trans-unit id="4e2c32ee916d61bb5fb82fcf33fd745d76fa8899" translate="yes" xml:space="preserve">
          <source>Currently this feature only works for</source>
          <target state="translated">目前该功能只适用于</target>
        </trans-unit>
        <trans-unit id="0990f74b9abadf3ef16d92f66dc8a33347d7b30f" translate="yes" xml:space="preserve">
          <source>Currently, ARM and AArch64 back ends do not support ACLE 2.0 fully. Both back ends support CRC32 intrinsics and the ARM back end supports the Coprocessor intrinsics, all from</source>
          <target state="translated">目前,ARM和Arch64后端不完全支持ACLE 2.0。两种后端都支持CRC32本征,ARM后端支持Coprocessor本征,均来自于</target>
        </trans-unit>
        <trans-unit id="31736ea72fe4084b8c34c06d50c0f1b2816826be" translate="yes" xml:space="preserve">
          <source>Currently, GCC defines &lt;code&gt;__STDC__&lt;/code&gt; unconditionally. This provides good results in practice.</source>
          <target state="translated">当前，GCC 无条件定义 &lt;code&gt;__STDC__&lt;/code&gt; 。在实践中这提供了良好的结果。</target>
        </trans-unit>
        <trans-unit id="2f63ff4fabd516030a0097fd6f4d244c1efad6e8" translate="yes" xml:space="preserve">
          <source>Currently, the attribute is ignored for inlined functions. If the attribute is applied to a symbol &lt;em&gt;definition&lt;/em&gt;, an error is reported. If a symbol previously declared &lt;code&gt;dllimport&lt;/code&gt; is later defined, the attribute is ignored in subsequent references, and a warning is emitted. The attribute is also overridden by a subsequent declaration as &lt;code&gt;dllexport&lt;/code&gt;.</source>
          <target state="translated">当前，内联函数将忽略该属性。如果将属性应用于符号&lt;em&gt;定义&lt;/em&gt;，则会报告错误。如果以后定义了先前声明的 &lt;code&gt;dllimport&lt;/code&gt; 符号，则在后续引用中将忽略该属性，并发出警告。该属性也被后续声明为 &lt;code&gt;dllexport&lt;/code&gt; 覆盖。</target>
        </trans-unit>
        <trans-unit id="590e74950b3a359e45f46ccc033df08293e7e8d0" translate="yes" xml:space="preserve">
          <source>Currently, the preferred dialect makes plain bit-fields signed, because this is simplest. Since &lt;code&gt;int&lt;/code&gt; is the same as &lt;code&gt;signed int&lt;/code&gt; in every other context, it is cleanest for them to be the same in bit-fields as well.</source>
          <target state="translated">当前，首​​选方言使普通的位域签名，因为这是最简单的。由于 &lt;code&gt;int&lt;/code&gt; 在所有其他上下文中都与 &lt;code&gt;signed int&lt;/code&gt; 相同，因此它们在位字段中也相同是最干净的。</target>
        </trans-unit>
        <trans-unit id="62ab12d09721515fc5fde562eb0862cdc8c3be63" translate="yes" xml:space="preserve">
          <source>Currently, there are two Blackfin-specific built-in functions. These are used for generating &lt;code&gt;CSYNC&lt;/code&gt; and &lt;code&gt;SSYNC&lt;/code&gt; machine insns without using inline assembly; by using these built-in functions the compiler can automatically add workarounds for hardware errata involving these instructions. These functions are named as follows:</source>
          <target state="translated">当前，有两个特定于Blackfin的内置函数。这些用于生成 &lt;code&gt;CSYNC&lt;/code&gt; 和 &lt;code&gt;SSYNC&lt;/code&gt; 机器insns，而无需使用内联汇编；通过使用这些内置函数，编译器可以自动添加涉及这些指令的硬件勘误的解决方法。这些函数的名称如下：</target>
        </trans-unit>
        <trans-unit id="3463fd1fcbee98183382ce3e6bfb37d05534e64b" translate="yes" xml:space="preserve">
          <source>Custom instruction assignments given by individual</source>
          <target state="translated">由个人提供的定制教学任务</target>
        </trans-unit>
        <trans-unit id="f2bc7d2b6265d22c6647e1fcd64c13f072748076" translate="yes" xml:space="preserve">
          <source>D documentation code (Ddoc).</source>
          <target state="translated">D文件编码(Ddoc)。</target>
        </trans-unit>
        <trans-unit id="2c7c0a531f3f523f274fda8de9447eb2371b07a9" translate="yes" xml:space="preserve">
          <source>D interface file.</source>
          <target state="translated">D接口文件。</target>
        </trans-unit>
        <trans-unit id="6e41c2f41f21895821ff2de4b2b537b418d821df" translate="yes" xml:space="preserve">
          <source>D register</source>
          <target state="translated">D寄存器</target>
        </trans-unit>
        <trans-unit id="2b608c731b27a1c96a6f8a0e732c2d9673589c56" translate="yes" xml:space="preserve">
          <source>D source code.</source>
          <target state="translated">D源码。</target>
        </trans-unit>
        <trans-unit id="6e946b779e60851d5c244c3ad74774cbf9f1d48d" translate="yes" xml:space="preserve">
          <source>DD</source>
          <target state="translated">DD</target>
        </trans-unit>
        <trans-unit id="333132be138ba9ace941111a0f174248952df7a1" translate="yes" xml:space="preserve">
          <source>DF</source>
          <target state="translated">DF</target>
        </trans-unit>
        <trans-unit id="53a81edefe355889dccbacb38a4a1453f4e85785" translate="yes" xml:space="preserve">
          <source>DL</source>
          <target state="translated">DL</target>
        </trans-unit>
        <trans-unit id="8fe69de0441ad2ce15deb455eb1d3b4c6713b22c" translate="yes" xml:space="preserve">
          <source>Data file relocation.</source>
          <target state="translated">数据文件搬迁。</target>
        </trans-unit>
        <trans-unit id="12293b22c91f6b4096277825dea65487973f1c86" translate="yes" xml:space="preserve">
          <source>Data prefetch does not generate faults if &lt;var&gt;addr&lt;/var&gt; is invalid, but the address expression itself must be valid. For example, a prefetch of &lt;code&gt;p-&amp;gt;next&lt;/code&gt; does not fault if &lt;code&gt;p-&amp;gt;next&lt;/code&gt; is not a valid address, but evaluation faults if &lt;code&gt;p&lt;/code&gt; is not a valid address.</source>
          <target state="translated">如果 &lt;var&gt;addr&lt;/var&gt; 无效，则数据预取不会产生错误，但是地址表达式本身必须有效。例如，预取 &lt;code&gt;p-&amp;gt;next&lt;/code&gt; 并不时发生故障 &lt;code&gt;p-&amp;gt;next&lt;/code&gt; ，如果不是一个有效的地址，但评价故障 &lt;code&gt;p&lt;/code&gt; 是不是一个有效的地址。</target>
        </trans-unit>
        <trans-unit id="c2a93a0b6a01599dcd1bcda6f09bcde290d7a928" translate="yes" xml:space="preserve">
          <source>Data register</source>
          <target state="translated">数据寄存器</target>
        </trans-unit>
        <trans-unit id="46a7bcc6b46e84d9b5870e2cd0ac98f1bdb1402e" translate="yes" xml:space="preserve">
          <source>Data register (arbitrary general purpose register)</source>
          <target state="translated">数据寄存器(任意通用寄存器)</target>
        </trans-unit>
        <trans-unit id="47be067ca541e17c43e79dffecbcbbad2c9d9a08" translate="yes" xml:space="preserve">
          <source>Data type: &lt;strong id=&quot;index-struct-_005f_005fhtm_005ftdb&quot;&gt;struct __htm_tdb&lt;/strong&gt;</source>
          <target state="translated">数据类型：&lt;strong id=&quot;index-struct-_005f_005fhtm_005ftdb&quot;&gt;struct __htm_tdb&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2310e7e6984f7b9841fe3043d76bb8748b8032aa" translate="yes" xml:space="preserve">
          <source>Data types for complex numbers.</source>
          <target state="translated">复数的数据类型。</target>
        </trans-unit>
        <trans-unit id="c002fd4f69749774cd614b7282439760b0a132f5" translate="yes" xml:space="preserve">
          <source>Debug dumps can be enabled with a</source>
          <target state="translated">调试转储可以通过</target>
        </trans-unit>
        <trans-unit id="d5a9f22c83f9299405413f6e5e553516a6cf6903" translate="yes" xml:space="preserve">
          <source>Debugging (</source>
          <target state="translated">调试 (</target>
        </trans-unit>
        <trans-unit id="b7b96436cf5229d16fb5897e129a114445f95678" translate="yes" xml:space="preserve">
          <source>Debugging Options</source>
          <target state="translated">调试选项</target>
        </trans-unit>
        <trans-unit id="aff6d1089cf54da46ac69c2183c78d051d04eff0" translate="yes" xml:space="preserve">
          <source>Decimal Floating Types.</source>
          <target state="translated">十进制浮动类型。</target>
        </trans-unit>
        <trans-unit id="6a66960857760a2cd63559ec52ee94a4a711e705" translate="yes" xml:space="preserve">
          <source>Declarations of external variables and functions within a block apply only to the block containing the declaration. In other words, they have the same scope as any other declaration in the same place.</source>
          <target state="translated">块中的外部变量和函数的声明只适用于包含声明的块。换句话说,它们的范围与同一地方的其他声明相同。</target>
        </trans-unit>
        <trans-unit id="226f69acb8ae88a869e2645962bf30e8ec7e974f" translate="yes" xml:space="preserve">
          <source>Declares the instruction to be commutative for this operand and the following operand. This means that the compiler may interchange the two operands if that is the cheapest way to make all operands fit the constraints. &amp;lsquo;</source>
          <target state="translated">声明该操作数与后续操作数的可交换指令。这意味着，如果这是使所有操作数都符合约束的最廉价方法，则编译器可以互换两个操作数。'</target>
        </trans-unit>
        <trans-unit id="6e381a53c21bfca57ae3c6418395aa6805faa3e6" translate="yes" xml:space="preserve">
          <source>Declaring multiple function versions.</source>
          <target state="translated">声明多个函数版本。</target>
        </trans-unit>
        <trans-unit id="9df458345b87f143e1443622e3689e81c8f18de5" translate="yes" xml:space="preserve">
          <source>Declaring objects with &lt;code&gt;uncached&lt;/code&gt; allows you to exclude data-cache participation in load and store operations on those objects without involving the additional semantic implications of &lt;code&gt;volatile&lt;/code&gt;. The &lt;code&gt;.di&lt;/code&gt; instruction suffix is used for all loads and stores of data declared &lt;code&gt;uncached&lt;/code&gt;.</source>
          <target state="translated">使用 &lt;code&gt;uncached&lt;/code&gt; 声明对象使您可以排除数据缓存参与这些对象的加载和存储操作，而无需涉及 &lt;code&gt;volatile&lt;/code&gt; 的其他语义含义。该 &lt;code&gt;.di&lt;/code&gt; 指令后缀用于所有负载和数据存储的声明 &lt;code&gt;uncached&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dea979b67c132bc175e1957da54321717a0b3e04" translate="yes" xml:space="preserve">
          <source>Declaring that functions have no side effects, or that they can never return.</source>
          <target state="translated">声明函数没有副作用,或者永远不能返回。</target>
        </trans-unit>
        <trans-unit id="63030d3cd1e02a687549d142e20f0269121d2b83" translate="yes" xml:space="preserve">
          <source>Declaring the variable</source>
          <target state="translated">声明变量</target>
        </trans-unit>
        <trans-unit id="b2609010c78f10c37fecace799c32d84a8b0113e" translate="yes" xml:space="preserve">
          <source>Declaring zero-length arrays in other contexts, including as interior members of structure objects or as non-member objects, is discouraged. Accessing elements of zero-length arrays declared in such contexts is undefined and may be diagnosed.</source>
          <target state="translated">不鼓励在其他情况下声明零长度数组,包括作为结构对象的内部成员或非成员对象。访问在这些上下文中声明的零长度数组的元素是没有定义的,可能会被诊断出来。</target>
        </trans-unit>
        <trans-unit id="c0ce91fb53831d435a29b5632774a3c603665597" translate="yes" xml:space="preserve">
          <source>Declaring zero-length arrays is allowed in GNU C as an extension. A zero-length array can be useful as the last element of a structure that is really a header for a variable-length object:</source>
          <target state="translated">在GNU C中,允许声明零长度数组作为一种扩展。零长度数组可以作为一个结构的最后一个元素,而这个结构实际上是一个可变长度对象的头。</target>
        </trans-unit>
        <trans-unit id="6ccbb003fcbbef0455a040407eca25644a68c8af" translate="yes" xml:space="preserve">
          <source>Default instruction scheduling parameters are used for values that select an architecture and not an implementation. These are &amp;lsquo;</source>
          <target state="translated">默认指令调度参数用于选择架构而不是实现的值。这些是 '</target>
        </trans-unit>
        <trans-unit id="ba9d931a2de4e95a1c6e18f4c96c1c9b9529c7aa" translate="yes" xml:space="preserve">
          <source>Default to 64-bit memory allocation routines.</source>
          <target state="translated">默认为64位内存分配例程。</target>
        </trans-unit>
        <trans-unit id="bc0e52c70e2e3d40aed76c210b466f12c8a6307d" translate="yes" xml:space="preserve">
          <source>Default visibility corresponds to &amp;ldquo;external linkage&amp;rdquo; in the language.</source>
          <target state="translated">默认可见性对应于该语言中的&amp;ldquo;外部链接&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="422c626b9da356260a74af4c444e356b1dff1705" translate="yes" xml:space="preserve">
          <source>Default visibility is the normal case for the object file format. This value is available for the visibility attribute to override other options that may change the assumed visibility of entities.</source>
          <target state="translated">默认可见性是对象文件格式的正常情况。该值可用于可见性属性,以覆盖可能改变实体的假定可见性的其他选项。</target>
        </trans-unit>
        <trans-unit id="dcc8364c434a51851187f20fa9cd4e3c3aefb760" translate="yes" xml:space="preserve">
          <source>Define a copy constructor and an assignment operator for classes with dynamically-allocated memory.</source>
          <target state="translated">为具有动态分配内存的类定义一个复制构造函数和一个赋值操作符。</target>
        </trans-unit>
        <trans-unit id="5e2f8d06c00c297c0f950f50c2f9216e48b9c380" translate="yes" xml:space="preserve">
          <source>Define additional macros required for using the POSIX threads library. You should use this option consistently for both compilation and linking. This option is supported on GNU/Linux targets, most other Unix derivatives, and also on x86 Cygwin and MinGW targets.</source>
          <target state="translated">定义使用POSIX线程库所需的附加宏。你应该在编译和链接时一致使用这个选项。这个选项在GNU/Linux目标机、大多数其他Unix衍生产品以及x86 Cygwin和MinGW目标机上都受到支持。</target>
        </trans-unit>
        <trans-unit id="8c097d198bbcce6c15c43b9673925ec2a844aa50" translate="yes" xml:space="preserve">
          <source>Define an argument called &lt;var&gt;key&lt;/var&gt; with a value of &lt;var&gt;value&lt;/var&gt; for the plugin called &lt;var&gt;name&lt;/var&gt;.</source>
          <target state="translated">为名为 &lt;var&gt;name&lt;/var&gt; 的插件定义一个名为 &lt;var&gt;key&lt;/var&gt; 的参数，其值为 &lt;var&gt;value&lt;/var&gt; 。</target>
        </trans-unit>
        <trans-unit id="3b065b864c454ddad2ef2e2ee36967d76b136921" translate="yes" xml:space="preserve">
          <source>Define how many insn groups (cycles) are examined for a dependency on a stalled insn that is a candidate for premature removal from the queue of stalled insns. This has an effect only during the second scheduling pass, and only if</source>
          <target state="translated">定义有多少个insn组(周期)会被检查,以确定是否依赖于停滞的insn,该停滞的insn是过早从停滞的insn队列中移除的候选者。这只有在第二个调度通道中才会产生影响,并且只有在以下情况下才会产生影响</target>
        </trans-unit>
        <trans-unit id="d9b9a323e114f08ae98c07403af86c1b8b068b0b" translate="yes" xml:space="preserve">
          <source>Define how many insns (if any) can be moved prematurely from the queue of stalled insns into the ready list during the second scheduling pass.</source>
          <target state="translated">定义在第二次调度过程中,有多少insn(如果有的话)可以从停滞的insn队列中提前移动到准备好的列表中。</target>
        </trans-unit>
        <trans-unit id="c71f73e3c6f3ec478d5a3cb4a896c06575c34175" translate="yes" xml:space="preserve">
          <source>Define the value of the global environment variable &amp;lsquo;</source>
          <target state="translated">定义全局环境变量的值</target>
        </trans-unit>
        <trans-unit id="007a5a1c8e0d06fa894878b70ba1b2c632ffae5b" translate="yes" xml:space="preserve">
          <source>Defined if</source>
          <target state="translated">定义为:如果</target>
        </trans-unit>
        <trans-unit id="461eb2c6003ae0aaa3a339d944fe5cf6fb4d9e9b" translate="yes" xml:space="preserve">
          <source>Defined if the compiler supports 32-bit double resp. 64-bit double. The actual layout is specified by option</source>
          <target state="translated">如果编译器支持32位双工或64位双工,则定义为。实际布局由选项</target>
        </trans-unit>
        <trans-unit id="b02590046df70d51175d1e6e43007843fa86e90a" translate="yes" xml:space="preserve">
          <source>Defining a register variable does not reserve the register. Other than when invoking the Extended &lt;code&gt;asm&lt;/code&gt;, the contents of the specified register are not guaranteed. For this reason, the following uses are explicitly &lt;em&gt;not&lt;/em&gt; supported. If they appear to work, it is only happenstance, and may stop working as intended due to (seemingly) unrelated changes in surrounding code, or even minor changes in the optimization of a future version of gcc:</source>
          <target state="translated">定义寄存器变量不会保留寄存器。除了调用扩展 &lt;code&gt;asm&lt;/code&gt; 时，不能保证指定寄存器的内容。因此，明确&lt;em&gt;不&lt;/em&gt;支持以下用途。如果它们似乎起作用，那只是偶然，并且可能会由于（似乎）周围代码中不相关的更改，甚至在gcc未来版本的优化中的微小更改而按预期停止工作：</target>
        </trans-unit>
        <trans-unit id="827f9d9fc11f005c60202a566cf0397ae86dd11d" translate="yes" xml:space="preserve">
          <source>Defining inline functions (as fast as macros).</source>
          <target state="translated">定义内联函数(和宏一样快)。</target>
        </trans-unit>
        <trans-unit id="85adcd212de2e338813907851ee4a5662c5f1efc" translate="yes" xml:space="preserve">
          <source>Defining variables residing in specified registers.</source>
          <target state="translated">定义驻留在指定寄存器中的变量。</target>
        </trans-unit>
        <trans-unit id="83ee69015768e1155b22074ebd3a36cc37e95cce" translate="yes" xml:space="preserve">
          <source>Delay execution for &lt;var&gt;ticks&lt;/var&gt; cycles. Note that this built-in does not take into account the effect of interrupts that might increase delay time. &lt;var&gt;ticks&lt;/var&gt; must be a compile-time integer constant; delays with a variable number of cycles are not supported.</source>
          <target state="translated">延迟执行 &lt;var&gt;ticks&lt;/var&gt; 周期。请注意，此内置功能未考虑可能会增加延迟时间的中断的影响。 &lt;var&gt;ticks&lt;/var&gt; 必须是编译时整数常量；不支持具有可变周期数的延迟。</target>
        </trans-unit>
        <trans-unit id="1610d19a0a48226750b3049b914e4786781d22cd" translate="yes" xml:space="preserve">
          <source>Deleting &amp;ldquo;empty&amp;rdquo; loops.</source>
          <target state="translated">删除&amp;ldquo;空&amp;rdquo;循环。</target>
        </trans-unit>
        <trans-unit id="36a3093d26bbd3d1360751144e1efe12aeac3836" translate="yes" xml:space="preserve">
          <source>Depending on the target and how GCC was configured, a slightly different set of optimizations may be enabled at each</source>
          <target state="translated">根据目标和GCC的配置方式,可能会在每一个</target>
        </trans-unit>
        <trans-unit id="c9892e7a514c42b2b22214f98f72a5abf448bce9" translate="yes" xml:space="preserve">
          <source>Describes the type of hardware multiply supported by the target. Accepted values are &amp;lsquo;</source>
          <target state="translated">描述目标支持的硬件乘法类型。可接受的值为&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="55f8ebc805e65b5b71ddafdae390e3be2bcd69af" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">Description</target>
        </trans-unit>
        <trans-unit id="230a2f1369c19e9bed8580ef0c388abed833d36f" translate="yes" xml:space="preserve">
          <source>Despite the nomenclature, &amp;lsquo;</source>
          <target state="translated">尽管有术语，&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="bd519eb03ed0c213fdab64aa985771c57b8bf1cd" translate="yes" xml:space="preserve">
          <source>Detect floating-point division by zero. Unlike other similar options,</source>
          <target state="translated">检测浮点除以零。与其他类似选项不同。</target>
        </trans-unit>
        <trans-unit id="f275b676db5ca45003e8d7fdde53e395b48ae26a" translate="yes" xml:space="preserve">
          <source>Detect integer division by zero as well as &lt;code&gt;INT_MIN / -1&lt;/code&gt; division.</source>
          <target state="translated">检测整数除以零以及 &lt;code&gt;INT_MIN / -1&lt;/code&gt; 除。</target>
        </trans-unit>
        <trans-unit id="1f073b8e3005614eac7c90dae6865076fed02ebe" translate="yes" xml:space="preserve">
          <source>Detect paths that trigger erroneous or undefined behavior due to a null value being used in a way forbidden by a &lt;code&gt;returns_nonnull&lt;/code&gt; or &lt;code&gt;nonnull&lt;/code&gt; attribute. Isolate those paths from the main control flow and turn the statement with erroneous or undefined behavior into a trap. This is not currently enabled, but may be enabled by</source>
          <target state="translated">检测由于 &lt;code&gt;returns_nonnull&lt;/code&gt; 或 &lt;code&gt;nonnull&lt;/code&gt; 属性禁止使用空值而导致触发错误或未定义行为的路径。从主控制流中隔离这些路径，并将具有错误或未定义行为的语句转换为陷阱。目前尚未启用，但可以通过以下方式启用</target>
        </trans-unit>
        <trans-unit id="6fd69cb31930da8cd040a4ffab1183319f8c09e1" translate="yes" xml:space="preserve">
          <source>Detect paths that trigger erroneous or undefined behavior due to dereferencing a null pointer. Isolate those paths from the main control flow and turn the statement with erroneous or undefined behavior into a trap. This flag is enabled by default at</source>
          <target state="translated">侦测由于去引用空指针而触发错误或未定义行为的路径。将这些路径从主控制流中分离出来,并将具有错误或未定义行为的语句变成一个陷阱。这个标志默认在</target>
        </trans-unit>
        <trans-unit id="b579efc699383256e0ea46438d32e07c0012bfb5" translate="yes" xml:space="preserve">
          <source>Determine the language standard. See &lt;a href=&quot;standards#Standards&quot;&gt;Language Standards Supported by GCC&lt;/a&gt;, for details of these standard versions. This option is currently only supported when compiling C or C++.</source>
          <target state="translated">确定语言标准。有关这些标准版本的详细信息，请参见&lt;a href=&quot;standards#Standards&quot;&gt;GCC支持的语言标准&lt;/a&gt;。当前仅在编译C或C ++时才支持此选项。</target>
        </trans-unit>
        <trans-unit id="86070f5116cf4fafa20ed47f8a131328fabf7c26" translate="yes" xml:space="preserve">
          <source>Determined by ABI.</source>
          <target state="translated">由ABI确定。</target>
        </trans-unit>
        <trans-unit id="3673862083301334f396f6717a9c4dfccba740e6" translate="yes" xml:space="preserve">
          <source>Determined by ABI. The options</source>
          <target state="translated">由ABI确定。选项</target>
        </trans-unit>
        <trans-unit id="95662524b23c122195f82746bb2090bea580b1d6" translate="yes" xml:space="preserve">
          <source>Determining the alignment of a function, type or variable.</source>
          <target state="translated">确定一个函数、类型或变量的对齐方式。</target>
        </trans-unit>
        <trans-unit id="1e53b5ee672acae1a69a324148d3c1bc9485a2b5" translate="yes" xml:space="preserve">
          <source>Developer Options</source>
          <target state="translated">开发者选项</target>
        </trans-unit>
        <trans-unit id="76b02b7503c565a218e0634291f3750002ba2b81" translate="yes" xml:space="preserve">
          <source>Devices belonging to &lt;code&gt;avrtiny&lt;/code&gt; and &lt;code&gt;avrxmega3&lt;/code&gt; can access flash memory by means of &lt;code&gt;LD*&lt;/code&gt; instructions because the flash memory is mapped into the RAM address space. There is &lt;em&gt;no need&lt;/em&gt; for language extensions like &lt;code&gt;__flash&lt;/code&gt; or attribute &lt;a href=&quot;variable-attributes#AVR-Variable-Attributes&quot;&gt;&lt;code&gt;progmem&lt;/code&gt;&lt;/a&gt;. The default linker description files for these devices cater for that feature and &lt;code&gt;.rodata&lt;/code&gt; stays in flash: The compiler just generates &lt;code&gt;LD*&lt;/code&gt; instructions, and the linker script adds core specific offsets to all &lt;code&gt;.rodata&lt;/code&gt; symbols: &lt;code&gt;0x4000&lt;/code&gt; in the case of &lt;code&gt;avrtiny&lt;/code&gt; and &lt;code&gt;0x8000&lt;/code&gt; in the case of &lt;code&gt;avrxmega3&lt;/code&gt;. See &lt;a href=&quot;avr-options#AVR-Options&quot;&gt;AVR Options&lt;/a&gt; for a list of respective devices.</source>
          <target state="translated">属于 &lt;code&gt;avrtiny&lt;/code&gt; 和 &lt;code&gt;avrxmega3&lt;/code&gt; 的设备可以通过 &lt;code&gt;LD*&lt;/code&gt; 指令访问闪存，因为闪存已映射到RAM地址空间中。有&lt;em&gt;没有必要&lt;/em&gt;对语言的扩展名如 &lt;code&gt;__flash&lt;/code&gt; 或属性&lt;a href=&quot;variable-attributes#AVR-Variable-Attributes&quot;&gt; &lt;code&gt;progmem&lt;/code&gt; &lt;/a&gt;。这些设备的默认链接描述文件满足该功能并 &lt;code&gt;.rodata&lt;/code&gt; 闪光灯住宿：编译器只是生成 &lt;code&gt;LD*&lt;/code&gt; 说明和链接器脚本添加核心特定偏移所有 &lt;code&gt;.rodata&lt;/code&gt; 符号： &lt;code&gt;0x4000&lt;/code&gt; 的在的情况下 &lt;code&gt;avrtiny&lt;/code&gt; 和 &lt;code&gt;0x8000&lt;/code&gt; 在的情况下 &lt;code&gt;avrxmega3&lt;/code&gt; 。有关相应设备的列表，请参阅&lt;a href=&quot;avr-options#AVR-Options&quot;&gt;AVR选项&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ce3941724906083a5cbd3b764ac34bb494078fce" translate="yes" xml:space="preserve">
          <source>Diagnostic Message Formatting Options</source>
          <target state="translated">诊断信息格式选项</target>
        </trans-unit>
        <trans-unit id="24dd6971b6b8e1e14c204ff9047942c4efd19644" translate="yes" xml:space="preserve">
          <source>Diagnostic messages can optionally have an associated &lt;a href=&quot;https://cwe.mitre.org/index.html&quot;&gt;CWE&lt;/a&gt; identifier. GCC itself only provides such metadata for some of the</source>
          <target state="translated">诊断消息可以选择具有关联的&lt;a href=&quot;https://cwe.mitre.org/index.html&quot;&gt;CWE&lt;/a&gt;标识符。GCC本身仅为某些</target>
        </trans-unit>
        <trans-unit id="e6bef0ef417e13647c36cc079b8003855e534522" translate="yes" xml:space="preserve">
          <source>Diagnostic options such as</source>
          <target state="translated">诊断选项,如</target>
        </trans-unit>
        <trans-unit id="3f68058e1e87ea41d8c9d3c7c1f94f8140abe531" translate="yes" xml:space="preserve">
          <source>Diagnostics can have child diagnostics. For example, this error and note:</source>
          <target state="translated">诊断程序可以有子诊断程序。例如,这个错误和说明。</target>
        </trans-unit>
        <trans-unit id="f2f5c489e6e2397fb8b9f0a64fb5a021b4c96f8f" translate="yes" xml:space="preserve">
          <source>Diagnostics consist of all the output sent to stderr by GCC.</source>
          <target state="translated">诊断包括GCC发送到stderr的所有输出。</target>
        </trans-unit>
        <trans-unit id="3545c8182bd90d9cc3755c0e6e77d7f64b0e4f2b" translate="yes" xml:space="preserve">
          <source>Different sets of tools are interoperable if they generate files that can be used in the same program. The set of tools includes compilers, assemblers, linkers, libraries, header files, startup files, and debuggers. Binaries produced by different sets of tools are not interoperable unless they implement the same ABI. This applies to different versions of the same tools as well as tools from different vendors.</source>
          <target state="translated">不同的工具集如果产生的文件可以在同一个程序中使用,那么它们就是可以互操作的。工具集包括编译器、汇编器、链接器、库、头文件、启动文件和调试器。由不同工具集产生的二进制文件不能互操作,除非它们实现了相同的ABI。这适用于同一工具的不同版本以及不同供应商的工具。</target>
        </trans-unit>
        <trans-unit id="356087678cfa620825af09ad133165c6564b44fe" translate="yes" xml:space="preserve">
          <source>Direct the linker to not merge together strings in the debugging information that are identical in different object files. Merging is not supported by all assemblers or linkers. Merging decreases the size of the debug information in the output file at the cost of increasing link processing time. Merging is enabled by default.</source>
          <target state="translated">指示链接器不要将调试信息中不同对象文件中相同的字符串合并在一起。并非所有汇编器或链接器都支持合并。合并会以增加链接处理时间为代价,减少输出文件中调试信息的大小。合并在默认情况下是启用的。</target>
        </trans-unit>
        <trans-unit id="7eb0eda4de9f69bec3e03226fe8296271cfe198f" translate="yes" xml:space="preserve">
          <source>Directories specified with</source>
          <target state="translated">指定的目录,用</target>
        </trans-unit>
        <trans-unit id="f710acdf8c3a36b577ab367527e400e4e4519a38" translate="yes" xml:space="preserve">
          <source>Directory Options</source>
          <target state="translated">目录选项</target>
        </trans-unit>
        <trans-unit id="9a7d4e0687b14e2b7cda406900b802782cd50a62" translate="yes" xml:space="preserve">
          <source>Disable</source>
          <target state="translated">Disable</target>
        </trans-unit>
        <trans-unit id="2d24b1d992d1c4af780c8f9d61b9c942a6314962" translate="yes" xml:space="preserve">
          <source>Disable (do not disable) use of the &lt;code&gt;jal&lt;/code&gt; instruction. Calling functions using &lt;code&gt;jal&lt;/code&gt; is more efficient but requires the caller and callee to be in the same 256 megabyte segment.</source>
          <target state="translated">禁用（请勿禁用） &lt;code&gt;jal&lt;/code&gt; 指令。使用 &lt;code&gt;jal&lt;/code&gt; 的调用函数效率更高，但要求调用者和被调用者位于相同的256 MB段中。</target>
        </trans-unit>
        <trans-unit id="df30c5939a2b24c38598155ef45390b83313cc5d" translate="yes" xml:space="preserve">
          <source>Disable (or enable) optimizations that use the small data section. This may be useful for working around optimizer bugs.</source>
          <target state="translated">禁用(或启用)使用小数据部分的优化。这对于解决优化器的错误可能很有用。</target>
        </trans-unit>
        <trans-unit id="7f2ac79b60fc58bb07e366adfa0ca3573c94fc1b" translate="yes" xml:space="preserve">
          <source>Disable (or re-enable) the generation of PC-relative jump instructions.</source>
          <target state="translated">禁用(或重新启用)PC相关跳转指令的生成。</target>
        </trans-unit>
        <trans-unit id="e288cae69ca3cd91f647a069f6407394ee8f11c1" translate="yes" xml:space="preserve">
          <source>Disable (or re-enable) the generation of hardware floating point instructions. This option is only significant when the target architecture is &amp;lsquo;</source>
          <target state="translated">禁用（或重新启用）硬件浮点指令的生成。仅当目标架构为&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="b671582f983bdaa2dca5a8611789524ffa3c4ce1" translate="yes" xml:space="preserve">
          <source>Disable &lt;code&gt;lr&lt;/code&gt; and &lt;code&gt;sr&lt;/code&gt; instructions from using FPX extension aux registers.</source>
          <target state="translated">通过使用FPX扩展aux寄存器禁用 &lt;code&gt;lr&lt;/code&gt; 和 &lt;code&gt;sr&lt;/code&gt; 指令。</target>
        </trans-unit>
        <trans-unit id="c1660e5f22d4c71c2ee4abdaec7f4aef18aa78c9" translate="yes" xml:space="preserve">
          <source>Disable IPA pass &lt;var&gt;pass&lt;/var&gt;. &lt;var&gt;pass&lt;/var&gt; is the pass name. If the same pass is statically invoked in the compiler multiple times, the pass name should be appended with a sequential number starting from 1.</source>
          <target state="translated">禁用IPA pass &lt;var&gt;pass&lt;/var&gt; 。 &lt;var&gt;pass&lt;/var&gt; 是通过名称。如果在编译器中多次静态调用同一遍，则遍历名称应附加从1开始的序列号。</target>
        </trans-unit>
        <trans-unit id="9d85b585d1d05ada062cacb1bc9babcd262635c5" translate="yes" xml:space="preserve">
          <source>Disable RTL pass &lt;var&gt;pass&lt;/var&gt;. &lt;var&gt;pass&lt;/var&gt; is the pass name. If the same pass is statically invoked in the compiler multiple times, the pass name should be appended with a sequential number starting from 1. &lt;var&gt;range-list&lt;/var&gt; is a comma-separated list of function ranges or assembler names. Each range is a number pair separated by a colon. The range is inclusive in both ends. If the range is trivial, the number pair can be simplified as a single number. If the function&amp;rsquo;s call graph node&amp;rsquo;s &lt;var&gt;uid&lt;/var&gt; falls within one of the specified ranges, the &lt;var&gt;pass&lt;/var&gt; is disabled for that function. The &lt;var&gt;uid&lt;/var&gt; is shown in the function header of a dump file, and the pass names can be dumped by using option</source>
          <target state="translated">禁用RTL pass &lt;var&gt;pass&lt;/var&gt; 。 &lt;var&gt;pass&lt;/var&gt; 是通过名称。如果在编译器中多次静态调用同一遍，则遍历名称应附加一个从1开始的序号。range &lt;var&gt;range-list&lt;/var&gt; 是用逗号分隔的函数范围或汇编程序名称列表。每个范围都是一个由冒号分隔的数字对。该范围包括两端。如果范围很小，则可以将数字对简化为单个数字。如果函数的调用图节点的 &lt;var&gt;uid&lt;/var&gt; 处于指定范围之一内，则对该函数禁用 &lt;var&gt;pass&lt;/var&gt; 。该 &lt;var&gt;uid&lt;/var&gt; 示于转储文件的函数头，和通过名字可以通过使用选项被倾倒</target>
        </trans-unit>
        <trans-unit id="7472182885a7c5023818095d70ccee0a1003a982" translate="yes" xml:space="preserve">
          <source>Disable Wpedantic warnings about constructs used in MFC, such as implicit int and getting a pointer to member function via non-standard syntax.</source>
          <target state="translated">禁用Wpedantic对MFC中使用的结构的警告,如隐式int和通过非标准语法获取成员函数的指针。</target>
        </trans-unit>
        <trans-unit id="d634773489054e3f820c752b2fe8a75da7d7b819" translate="yes" xml:space="preserve">
          <source>Disable all estimate instructions, equivalent to</source>
          <target state="translated">禁用所有估算指令,相当于</target>
        </trans-unit>
        <trans-unit id="24c834ead83a4d1ebc3aa24aef6d4685246dfacb" translate="yes" xml:space="preserve">
          <source>Disable any machine-specific peephole optimizations. The difference between</source>
          <target state="translated">禁用任何特定机器的窥视孔优化。之间的区别</target>
        </trans-unit>
        <trans-unit id="dd10c462b4994eb3982bf5bd6da47ab31464aa34" translate="yes" xml:space="preserve">
          <source>Disable built-in declarations of functions that are not mandated by ANSI/ISO C. These include &lt;code&gt;ffs&lt;/code&gt;, &lt;code&gt;alloca&lt;/code&gt;, &lt;code&gt;_exit&lt;/code&gt;, &lt;code&gt;index&lt;/code&gt;, &lt;code&gt;bzero&lt;/code&gt;, &lt;code&gt;conjf&lt;/code&gt;, and other related functions.</source>
          <target state="translated">禁用未由ANSI / ISO C强制执行的函数的内置声明。这些声明包括 &lt;code&gt;ffs&lt;/code&gt; ， &lt;code&gt;alloca&lt;/code&gt; ， &lt;code&gt;_exit&lt;/code&gt; ， &lt;code&gt;index&lt;/code&gt; ， &lt;code&gt;bzero&lt;/code&gt; ， &lt;code&gt;conjf&lt;/code&gt; 和其他相关函数。</target>
        </trans-unit>
        <trans-unit id="e02b6f324995da402dd843cdd3b4c4bea9e780ea" translate="yes" xml:space="preserve">
          <source>Disable compilation effects of</source>
          <target state="translated">禁用编译效果</target>
        </trans-unit>
        <trans-unit id="4deddc96335abb292813c9ba7387aa150fa39b18" translate="yes" xml:space="preserve">
          <source>Disable compiler generated atomic sequences and emit library calls for atomic operations. This is the default if the target is not &lt;code&gt;sh*-*-linux*&lt;/code&gt;.</source>
          <target state="translated">禁用编译器生成的原子序列，并发出对原子操作的库调用。如果目标不是 &lt;code&gt;sh*-*-linux*&lt;/code&gt; 则这是默认设置。</target>
        </trans-unit>
        <trans-unit id="e03c896d7744b1b31e15f0be1dc55290d5dd4d98" translate="yes" xml:space="preserve">
          <source>Disable diagnostics that the standard says a compiler does not need to issue. Currently, the only such diagnostic issued by G++ is the one for a name having multiple meanings within a class.</source>
          <target state="translated">禁用标准规定编译器不需要发布的诊断程序。目前,G++发出的唯一的诊断是对一个类中具有多重含义的名称的诊断。</target>
        </trans-unit>
        <trans-unit id="15a8077f24c55fd5c21ad0119861505db428aa18" translate="yes" xml:space="preserve">
          <source>Disable generation of &lt;code&gt;bcnz&lt;/code&gt; instructions.</source>
          <target state="translated">禁用生成 &lt;code&gt;bcnz&lt;/code&gt; 指令。</target>
        </trans-unit>
        <trans-unit id="5286938aafbdfcae094ead274d86fb0eb12ec590" translate="yes" xml:space="preserve">
          <source>Disable generation of information about every class with virtual functions for use by the C++ run-time type identification features (&lt;code&gt;dynamic_cast&lt;/code&gt; and &lt;code&gt;typeid&lt;/code&gt;). If you don&amp;rsquo;t use those parts of the language, you can save some space by using this flag. Note that exception handling uses the same information, but G++ generates it as needed. The &lt;code&gt;dynamic_cast&lt;/code&gt; operator can still be used for casts that do not require run-time type information, i.e. casts to &lt;code&gt;void *&lt;/code&gt; or to unambiguous base classes.</source>
          <target state="translated">禁止使用虚拟函数生成有关每个类的信息，以供C ++运行时类型标识功能（ &lt;code&gt;dynamic_cast&lt;/code&gt; 和 &lt;code&gt;typeid&lt;/code&gt; ）使用。如果您不使用语言的这些部分，则可以使用此标志节省一些空间。请注意，异常处理使用相同的信息，但是G ++会根据需要生成它。该 &lt;code&gt;dynamic_cast&lt;/code&gt; 的操作仍然可以使用，不需要运行时类型信息，即强制类型强制转换 &lt;code&gt;void *&lt;/code&gt; 或明确的基类。</target>
        </trans-unit>
        <trans-unit id="2c5d893b2d5daa4c819c5a8197085e49914249d8" translate="yes" xml:space="preserve">
          <source>Disable global interrupt.</source>
          <target state="translated">禁用全局中断。</target>
        </trans-unit>
        <trans-unit id="5c285b2217d4516708f07171dfd66ed9be6d9834" translate="yes" xml:space="preserve">
          <source>Disable instruction scheduling across basic blocks, which is normally enabled when scheduling before register allocation, i.e. with</source>
          <target state="translated">禁用跨基本块的指令调度,通常在寄存器分配前进行调度时启用,即用</target>
        </trans-unit>
        <trans-unit id="0e98c6ae6e073a4473bf45d5938dfbe138a13b1c" translate="yes" xml:space="preserve">
          <source>Disable interprocedural optimizations between the function with this attribute and its callers, as if the body of the function is not available when optimizing callers and the callers are unavailable when optimizing the body. This attribute implies &lt;code&gt;noinline&lt;/code&gt;, &lt;code&gt;noclone&lt;/code&gt; and &lt;code&gt;no_icf&lt;/code&gt; attributes. However, this attribute is not equivalent to a combination of other attributes, because its purpose is to suppress existing and future optimizations employing interprocedural analysis, including those that do not have an attribute suitable for disabling them individually. This attribute is supported mainly for the purpose of testing the compiler.</source>
          <target state="translated">禁用具有此属性的函数及其调用者之间的过程间优化，好像在优化调用者时函数的主体不可用，而在优化主体时调用者不可用。此属性暗含 &lt;code&gt;noinline&lt;/code&gt; ， &lt;code&gt;noclone&lt;/code&gt; 和 &lt;code&gt;no_icf&lt;/code&gt; 属性。但是，此属性不等于其他属性的组合，因为它的目的是抑制使用过程间分析的现有和将来的优化，包括那些不具有适合单独禁用它们的属性的优化。支持此属性主要是为了测试编译器。</target>
        </trans-unit>
        <trans-unit id="c37151a8e5f5341e877c6066a7b31e954ab243b6" translate="yes" xml:space="preserve">
          <source>Disable lazy binding of function calls. This option is the default and is defined for compatibility with Diab.</source>
          <target state="translated">禁用函数调用的懒惰绑定。这个选项是默认的,是为了与Diab兼容而定义的。</target>
        </trans-unit>
        <trans-unit id="79f399771b0bd71907b7340d736452ada0291344" translate="yes" xml:space="preserve">
          <source>Disable linking effects of</source>
          <target state="translated">禁用链接效果</target>
        </trans-unit>
        <trans-unit id="609817ad0deecdec8c6b793819e36a0c5e4631a2" translate="yes" xml:space="preserve">
          <source>Disable nested conditional execution optimizations.</source>
          <target state="translated">禁用嵌套条件执行优化。</target>
        </trans-unit>
        <trans-unit id="252fe391b1a4b9d960215788262ee75bfd6c19f6" translate="yes" xml:space="preserve">
          <source>Disable optimization of &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; and &lt;code&gt;||&lt;/code&gt; in conditional execution.</source>
          <target state="translated">禁用 &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; 和 &lt;code&gt;||&lt;/code&gt; 的优化 在条件执行中。</target>
        </trans-unit>
        <trans-unit id="161926f247c9f892e24d049743fa9253ac876603" translate="yes" xml:space="preserve">
          <source>Disable sharing of stack slots allocated for pseudo-registers. Each pseudo-register that does not get a hard register gets a separate stack slot, and as a result function stack frames are larger.</source>
          <target state="translated">禁用为伪寄存器分配的栈槽的共享。每个没有得到硬寄存器的伪寄存器都会得到一个单独的堆栈槽,因此函数堆栈帧较大。</target>
        </trans-unit>
        <trans-unit id="c4a9a68d37ad2c1a1ec5ead44b9d2a2ec4d10976" translate="yes" xml:space="preserve">
          <source>Disable sharing of stack slots used for saving call-used hard registers living through a call. Each hard register gets a separate stack slot, and as a result function stack frames are larger.</source>
          <target state="translated">禁用共享用于保存调用使用的硬寄存器的堆栈槽。每个硬寄存器都有一个单独的堆栈槽,因此函数的堆栈框架更大。</target>
        </trans-unit>
        <trans-unit id="64d3adeb52b81d55606f0c9f79019d7885ab8d8f" translate="yes" xml:space="preserve">
          <source>Disable speculative motion of non-load instructions, which is normally enabled when scheduling before register allocation, i.e. with</source>
          <target state="translated">禁用非负载指令的推测运动,通常在寄存器分配前调度时启用,即用</target>
        </trans-unit>
        <trans-unit id="1b9e6a10d7feb88af30d21664dcd930d0d3d0e48" translate="yes" xml:space="preserve">
          <source>Disable the ARCompact-specific pass to generate conditional execution instructions.</source>
          <target state="translated">禁用ARCompact专用通道来生成条件执行指令。</target>
        </trans-unit>
        <trans-unit id="e7b7d0aa54600e475f975b3ad94c992870425a43" translate="yes" xml:space="preserve">
          <source>Disable the ARM-state integer division extension.</source>
          <target state="translated">禁用ARM状态下的整数除法扩展。</target>
        </trans-unit>
        <trans-unit id="9ae205131ae6c1f0b1ad1d6cdc75d88e53999201" translate="yes" xml:space="preserve">
          <source>Disable the Advanced SIMD instructions (does not disable floating point).</source>
          <target state="translated">禁用高级SIMD指令(不禁用浮点)。</target>
        </trans-unit>
        <trans-unit id="57b7e24dd0dd62653de9bd626e4944fa6899e1dd" translate="yes" xml:space="preserve">
          <source>Disable the DSP extension.</source>
          <target state="translated">禁用DSP扩展。</target>
        </trans-unit>
        <trans-unit id="734f786ab444d8f65fc0c46cdddee12bfda3218d" translate="yes" xml:space="preserve">
          <source>Disable the DSP instructions on &amp;lsquo;</source>
          <target state="translated">禁用&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="c7d8376c95023cbfb7c660163253089208b34ece" translate="yes" xml:space="preserve">
          <source>Disable the cryptographic extension.</source>
          <target state="translated">禁用加密扩展。</target>
        </trans-unit>
        <trans-unit id="7f3f13b931ffd3d75ba124cd726692f8712aa12e" translate="yes" xml:space="preserve">
          <source>Disable the cryptographic instructions.</source>
          <target state="translated">禁用加密指令。</target>
        </trans-unit>
        <trans-unit id="354594897b575026e6476d5a01060d1ccbb17336" translate="yes" xml:space="preserve">
          <source>Disable the diagnostic for converting a bound pointer to member function to a plain pointer.</source>
          <target state="translated">禁用将绑定指针转换为成员函数的普通指针的诊断。</target>
        </trans-unit>
        <trans-unit id="c0bf355bf048a8a4bc609b141cbb68d7e3532d66" translate="yes" xml:space="preserve">
          <source>Disable the floating-point and Advanced SIMD instructions.</source>
          <target state="translated">禁用浮点和高级SIMD指令。</target>
        </trans-unit>
        <trans-unit id="f50bf78f4ef90550849e16bf00e7f8fd3e26a980" translate="yes" xml:space="preserve">
          <source>Disable the floating-point extension.</source>
          <target state="translated">禁用浮点扩展。</target>
        </trans-unit>
        <trans-unit id="04850fd68730a9ccdd397aa31033dbe8ded5b8ec" translate="yes" xml:space="preserve">
          <source>Disable the floating-point extensions.</source>
          <target state="translated">禁用浮点扩展功能。</target>
        </trans-unit>
        <trans-unit id="c08d0916688b59b4478dd3a8a8d551babc61d679" translate="yes" xml:space="preserve">
          <source>Disable the floating-point instructions.</source>
          <target state="translated">禁用浮点指令。</target>
        </trans-unit>
        <trans-unit id="005c34c6f1c2fb8f1d59d1e3c41e0a0a2122f930" translate="yes" xml:space="preserve">
          <source>Disable the floating-point, Advanced SIMD and cryptographic instructions.</source>
          <target state="translated">禁用浮点、高级SIMD和加密指令。</target>
        </trans-unit>
        <trans-unit id="9c28f6f627d67c9bbae1a8f36d817bb71ee86b5b" translate="yes" xml:space="preserve">
          <source>Disable the insertion of cache barriers. This is the default setting.</source>
          <target state="translated">禁用插入缓存屏障。这是默认设置。</target>
        </trans-unit>
        <trans-unit id="f56b2447b6cc6f830b2511a8763a44abd8412f42" translate="yes" xml:space="preserve">
          <source>Disable the optimization pass that scans for opportunities to use &amp;ldquo;decrement and branch&amp;rdquo; instructions on a count register instead of instruction sequences that decrement a register, compare it against zero, and then branch based upon the result. This option is only meaningful on architectures that support such instructions, which include x86, PowerPC, IA-64 and S/390. Note that the</source>
          <target state="translated">禁用用于扫描在计数寄存器上使用&amp;ldquo;减量和转移&amp;rdquo;指令的机会的优化过程，而不是对减量寄存器进行比较的指令序列，将其与零进行比较，然后根据结果进行转移。该选项仅对支持此类指令的体系结构有意义，这些体系结构包括x86，PowerPC，IA-64和S / 390。请注意</target>
        </trans-unit>
        <trans-unit id="c15dc65887ffe75f7696788f129ef9f9ee6c4b19" translate="yes" xml:space="preserve">
          <source>Disable the use of conditional execution.</source>
          <target state="translated">禁止使用条件执行。</target>
        </trans-unit>
        <trans-unit id="47a29a4761de80ec38be8a0cf5e531389fb7bc55" translate="yes" xml:space="preserve">
          <source>Disable the use of conditional set instructions.</source>
          <target state="translated">禁止使用条件集指令。</target>
        </trans-unit>
        <trans-unit id="5cb2b9c6309800d129c0dac9ca4f0d952c4c16ba" translate="yes" xml:space="preserve">
          <source>Disable the use of conditional-move instructions.</source>
          <target state="translated">禁止使用条件移动指令。</target>
        </trans-unit>
        <trans-unit id="c4ab5898827402073a5b1c951bd92d3ef7f4f26a" translate="yes" xml:space="preserve">
          <source>Disable the warning about a throw-expression that will immediately result in a call to &lt;code&gt;terminate&lt;/code&gt;.</source>
          <target state="translated">禁用有关throw-expression的警告，该警告将立即导致调用 &lt;code&gt;terminate&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9e916b556b452967e0dcb5e2d11c70ff45829cad" translate="yes" xml:space="preserve">
          <source>Disable the warning about the case when a conversion function converts an object to the same type, to a base class of that type, or to void; such a conversion function will never be called.</source>
          <target state="translated">禁用关于转换函数将对象转换为相同类型、转换为该类型的基类或转换为void的情况的警告;这样的转换函数永远不会被调用。</target>
        </trans-unit>
        <trans-unit id="97813576f6a1f168ea49d44405f937b0428780d3" translate="yes" xml:space="preserve">
          <source>Disable transformations and optimizations that assume default floating-point rounding behavior. This is round-to-zero for all floating point to integer conversions, and round-to-nearest for all other arithmetic truncations. This option should be specified for programs that change the FP rounding mode dynamically, or that may be executed with a non-default rounding mode. This option disables constant folding of floating-point expressions at compile time (which may be affected by rounding mode) and arithmetic transformations that are unsafe in the presence of sign-dependent rounding modes.</source>
          <target state="translated">禁用假设默认浮点取整行为的转换和优化。对于所有的浮点到整数的转换都是四舍五入,对于所有其他的算术截断都是四舍五入。对于动态改变FP舍入模式的程序,或者可能以非默认舍入模式执行的程序,应该指定这个选项。这个选项禁止在编译时对浮点表达式进行恒定的折叠(可能会受到四舍五入模式的影响),也禁止在符号相关的四舍五入模式下进行不安全的算术变换。</target>
        </trans-unit>
        <trans-unit id="fa652af71b1d233eeae7ac973249eb12d16d530a" translate="yes" xml:space="preserve">
          <source>Disable tree pass &lt;var&gt;pass&lt;/var&gt;. See</source>
          <target state="translated">禁用树 &lt;var&gt;pass&lt;/var&gt; 。看到</target>
        </trans-unit>
        <trans-unit id="c43ef83976903738f93a9dacec55c01d9094fe2c" translate="yes" xml:space="preserve">
          <source>Disable use of the small data area. Variables are put into one of &lt;code&gt;.data&lt;/code&gt;, &lt;code&gt;.bss&lt;/code&gt;, or &lt;code&gt;.rodata&lt;/code&gt; (unless the &lt;code&gt;section&lt;/code&gt; attribute has been specified). This is the default.</source>
          <target state="translated">禁用小数据区域。变量被放入 &lt;code&gt;.data&lt;/code&gt; ， &lt;code&gt;.bss&lt;/code&gt; 或 &lt;code&gt;.rodata&lt;/code&gt; 之一（除非指定了 &lt;code&gt;section&lt;/code&gt; 属性）。这是默认值。</target>
        </trans-unit>
        <trans-unit id="dd6879ec12c29349f77ab51cc9ef664f2b926a46" translate="yes" xml:space="preserve">
          <source>Disable warnings when non-template friend functions are declared within a template. In very old versions of GCC that predate implementation of the ISO standard, declarations such as &amp;lsquo;</source>
          <target state="translated">在模板中声明非模板好友功能时，禁用警告。在早于ISO标准实施的GCC的较旧版本中，声明如&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="75de5d4a7b64d839362aa8d626128e23f7764239" translate="yes" xml:space="preserve">
          <source>Disabled at level</source>
          <target state="translated">伤残等级</target>
        </trans-unit>
        <trans-unit id="bf492e44698b816bac566d70d52b5954c19119dd" translate="yes" xml:space="preserve">
          <source>Disabled by default.</source>
          <target state="translated">默认情况下已禁用。</target>
        </trans-unit>
        <trans-unit id="aac880794e7e82b2a88791e338313ba16ba15074" translate="yes" xml:space="preserve">
          <source>Disables all the optional instructions enabled by</source>
          <target state="translated">禁用所有由</target>
        </trans-unit>
        <trans-unit id="870d995d131280874dc4cc508b91ef24ce1bb25e" translate="yes" xml:space="preserve">
          <source>Disables the SIMD (but not floating-point) instructions on &amp;lsquo;</source>
          <target state="translated">停用&amp;ldquo;&amp;rdquo;上的SIMD（但不使用浮点数）指令</target>
        </trans-unit>
        <trans-unit id="a27996206286cd961e06403639946454e47385b1" translate="yes" xml:space="preserve">
          <source>Disables the double-precision component of the floating-point instructions on &amp;lsquo;</source>
          <target state="translated">在'上禁用浮点指令的双精度组件</target>
        </trans-unit>
        <trans-unit id="f08047d7bdf26e21f60892f7f2f9f2faee1af25c" translate="yes" xml:space="preserve">
          <source>Disables the floating-point instructions on &amp;lsquo;</source>
          <target state="translated">禁用&amp;ldquo;上的浮点指令&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="df9e25965e3555d25ff57722cb18d00af55afb9e" translate="yes" xml:space="preserve">
          <source>Disables warnings about the generation of inefficient code. These warnings can be generated, for example, when compiling code that performs byte-level memory operations on the MAC AE type. The MAC AE has no hardware support for byte-level memory operations, so all byte load/stores must be synthesized from word load/store operations. This is inefficient and a warning is generated to indicate that you should rewrite the code to avoid byte operations, or to target an AE type that has the necessary hardware support. This option disables these warnings.</source>
          <target state="translated">禁用关于产生低效代码的警告。例如,当编译在MAC AE类型上执行字节级内存操作的代码时,可能会产生这些警告。MAC AE没有对字节级内存操作的硬件支持,因此所有字节加载/存储必须从字加载/存储操作中合成。这是很低效的,并且会产生一个警告,提示您应该重写代码以避免字节操作,或者以具有必要硬件支持的AE类型为目标。这个选项可以禁用这些警告。</target>
        </trans-unit>
        <trans-unit id="8c83476e13772d4a0c7d47269ca8280ee489e48a" translate="yes" xml:space="preserve">
          <source>Disallow using extensions of later DWARF standard version than selected with</source>
          <target state="translated">不允许使用DWARF标准版本以后的扩展,而不允许用</target>
        </trans-unit>
        <trans-unit id="48fef3c4f4f198a3fc747aaf4241ba4c8fd572a6" translate="yes" xml:space="preserve">
          <source>Discover read-only, write-only and non-addressable static variables. Enabled by default at</source>
          <target state="translated">发现只读、只写和不可寻址的静态变量。默认在</target>
        </trans-unit>
        <trans-unit id="fcb652ea128e958ac5cce84cb6ef8250a1be8fe4" translate="yes" xml:space="preserve">
          <source>Discover which functions are pure or constant. Enabled by default at</source>
          <target state="translated">发现哪些函数是纯函数或常量函数。默认在</target>
        </trans-unit>
        <trans-unit id="a208f773f4cc31e2ce047d428bfcf70af185cc47" translate="yes" xml:space="preserve">
          <source>Discover which static variables do not escape the compilation unit. Enabled by default at</source>
          <target state="translated">发现哪些静态变量不逃逸编译单元。默认在</target>
        </trans-unit>
        <trans-unit id="651cd5d45dfead116269d73c1f57b41b4dbd0dc9" translate="yes" xml:space="preserve">
          <source>Dispatching a call to another function.</source>
          <target state="translated">调度对另一个函数的调用。</target>
        </trans-unit>
        <trans-unit id="81b470ecff5209cbe640ee9ba4362aba6ca2d2e9" translate="yes" xml:space="preserve">
          <source>Display all of the optimization options supported by the compiler.</source>
          <target state="translated">显示编译器支持的所有优化选项。</target>
        </trans-unit>
        <trans-unit id="72c8c0bfdf122469f724652953f16cbdb6f10057" translate="yes" xml:space="preserve">
          <source>Display all of the options controlling warning messages produced by the compiler.</source>
          <target state="translated">显示所有控制编译器产生的警告信息的选项。</target>
        </trans-unit>
        <trans-unit id="aed462cd18dddfb7255b08046613981f43dcc83d" translate="yes" xml:space="preserve">
          <source>Display demangled function names in output. The default is to show mangled function names.</source>
          <target state="translated">在输出中显示已解密的函数名。默认情况下是显示杂乱的函数名。</target>
        </trans-unit>
        <trans-unit id="265008e8627ab28c29c4c783e5dfd9614fe2af35" translate="yes" xml:space="preserve">
          <source>Display help about using &lt;code&gt;gcov-dump&lt;/code&gt; (on the standard output), and exit without doing any further processing.</source>
          <target state="translated">显示有关使用 &lt;code&gt;gcov-dump&lt;/code&gt; 的帮助（在标准输出上），然后不做任何进一步处理就退出。</target>
        </trans-unit>
        <trans-unit id="e12fbb96aff9cead22e458e9ec3c8f5e63fa5684" translate="yes" xml:space="preserve">
          <source>Display help about using &lt;code&gt;gcov-tool&lt;/code&gt; (on the standard output), and exit without doing any further processing.</source>
          <target state="translated">显示有关使用 &lt;code&gt;gcov-tool&lt;/code&gt; 的帮助（在标准输出上），然后不做任何进一步处理就退出。</target>
        </trans-unit>
        <trans-unit id="c2a32dd6399128ea64f2e8805722cf5f0f40906c" translate="yes" xml:space="preserve">
          <source>Display help about using &lt;code&gt;gcov&lt;/code&gt; (on the standard output), and exit without doing any further processing.</source>
          <target state="translated">显示有关使用 &lt;code&gt;gcov&lt;/code&gt; 的帮助（在标准输出上），然后退出而不进行任何进一步处理。</target>
        </trans-unit>
        <trans-unit id="05abc5bf9b915eda30e5f0fa5412f4d00c71675a" translate="yes" xml:space="preserve">
          <source>Display only those options that are undocumented.</source>
          <target state="translated">只显示未记录的选项。</target>
        </trans-unit>
        <trans-unit id="f03b0f7a546ee49a503453f7975e25ffe065c35f" translate="yes" xml:space="preserve">
          <source>Display options taking an argument that appears after an equal sign in the same continuous piece of text, such as: &amp;lsquo;</source>
          <target state="translated">显示选项带有一个参数，该参数出现在同一连续文本中的等号之后，例如：'</target>
        </trans-unit>
        <trans-unit id="78dd198d091922fefb8d713c3d97e47984a683e2" translate="yes" xml:space="preserve">
          <source>Display options taking an argument that appears as a separate word following the original option, such as: &amp;lsquo;</source>
          <target state="translated">显示选项带有一个参数，该参数在原始选项之后显示为单独的单词，例如：'</target>
        </trans-unit>
        <trans-unit id="3034576017d5b01854a8c0bd7d19d6bd34b0118e" translate="yes" xml:space="preserve">
          <source>Display target-specific options. Unlike the</source>
          <target state="translated">显示特定目标的选项。与</target>
        </trans-unit>
        <trans-unit id="344037446b18226df15907aaf4b6b36a2c93c89d" translate="yes" xml:space="preserve">
          <source>Display the &lt;code&gt;gcov-dump&lt;/code&gt; version number (on the standard output), and exit without doing any further processing.</source>
          <target state="translated">显示 &lt;code&gt;gcov-dump&lt;/code&gt; 版本号（在标准输出上），然后不做任何进一步处理就退出。</target>
        </trans-unit>
        <trans-unit id="35cc61bd60aed0586a7ab81a239eee8b50af7443" translate="yes" xml:space="preserve">
          <source>Display the &lt;code&gt;gcov-tool&lt;/code&gt; version number (on the standard output), and exit without doing any further processing.</source>
          <target state="translated">显示 &lt;code&gt;gcov-tool&lt;/code&gt; 版本号（在标准输出上），然后不做任何进一步处理就退出。</target>
        </trans-unit>
        <trans-unit id="b6e074d4004bd50fbdfdcf5bba3331e5f56c291a" translate="yes" xml:space="preserve">
          <source>Display the &lt;code&gt;gcov&lt;/code&gt; version number (on the standard output), and exit without doing any further processing.</source>
          <target state="translated">显示 &lt;code&gt;gcov&lt;/code&gt; 版本号（在标准输出上），然后不做任何进一步处理就退出。</target>
        </trans-unit>
        <trans-unit id="e1dab73554637fba73ebd51cac08053a6ac2d5d1" translate="yes" xml:space="preserve">
          <source>Display the dump tool help.</source>
          <target state="translated">显示转储工具帮助。</target>
        </trans-unit>
        <trans-unit id="cef9fe7c4ae3fd66d0616ac76fb1a92ba4cf451e" translate="yes" xml:space="preserve">
          <source>Display the options supported for &lt;var&gt;language&lt;/var&gt;, where &lt;var&gt;language&lt;/var&gt; is the name of one of the languages supported in this version of GCC.</source>
          <target state="translated">显示 &lt;var&gt;language&lt;/var&gt; 支持的选项，其中 &lt;var&gt;language&lt;/var&gt; 是此版本的GCC支持的一种语言的名称。</target>
        </trans-unit>
        <trans-unit id="ecaf3dad0e5ad7c6fd0a0b9f49a9e6fe224ab8c8" translate="yes" xml:space="preserve">
          <source>Display the options supported for &lt;var&gt;language&lt;/var&gt;, where &lt;var&gt;language&lt;/var&gt; is the name of one of the languages supported in this version of GCC. If an option is supported by all languages, one needs to select &amp;lsquo;</source>
          <target state="translated">显示 &lt;var&gt;language&lt;/var&gt; 支持的选项，其中 &lt;var&gt;language&lt;/var&gt; 是此版本的GCC支持的一种语言的名称。如果所有语言都支持该选项，则需要选择&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="9ab2c82abfc8159be6e9fa8d50b69489311c099e" translate="yes" xml:space="preserve">
          <source>Display the options that are common to all languages.</source>
          <target state="translated">显示所有语言通用的选项。</target>
        </trans-unit>
        <trans-unit id="0ec31abb5e51897ba8130f63f01229988bd5728b" translate="yes" xml:space="preserve">
          <source>Display the progress on the standard output.</source>
          <target state="translated">在标准输出上显示进度。</target>
        </trans-unit>
        <trans-unit id="6dbb61eb69b04350133e621d0c73b06d5ccc9c5b" translate="yes" xml:space="preserve">
          <source>Display the values recognized by the</source>
          <target state="translated">识别值的显示</target>
        </trans-unit>
        <trans-unit id="34d093aadfdac161b403733078a63e69c40898c6" translate="yes" xml:space="preserve">
          <source>Display the version number and copyrights of the invoked GCC.</source>
          <target state="translated">显示调用的GCC的版本号和版权。</target>
        </trans-unit>
        <trans-unit id="26dfbbd6de78ea5ea887b6576aa7df3d1cced839" translate="yes" xml:space="preserve">
          <source>Disregard strict standards compliance.</source>
          <target state="translated">无视严格的标准遵守。</target>
        </trans-unit>
        <trans-unit id="810ca5fb4bf9b88327a090dfa7228390b8a8933b" translate="yes" xml:space="preserve">
          <source>Distances are measured from the beginning of functions when using the</source>
          <target state="translated">当使用该函数时,从函数开始测量距离。</target>
        </trans-unit>
        <trans-unit id="700c5d1f81b1eabfd1898baf4899894e603c6ec2" translate="yes" xml:space="preserve">
          <source>Distinguish between prefix and postfix forms of increment and decrement operators.</source>
          <target state="translated">区分增减运算符的前缀和后缀形式。</target>
        </trans-unit>
        <trans-unit id="15d45d388da758d77a316f2815f529d6f4aa8a47" translate="yes" xml:space="preserve">
          <source>Do (don&amp;rsquo;t) generate code that uses the fused multiply/add or multiply/subtract instructions. The default is to use these instructions.</source>
          <target state="translated">不要（不）生成使用融合的乘/加或乘/减指令的代码。默认值为使用这些说明。</target>
        </trans-unit>
        <trans-unit id="fa3eae74d7b2c9843e7a1a146ef2fdd2dc03d4df" translate="yes" xml:space="preserve">
          <source>Do alignment optimizations for call instructions.</source>
          <target state="translated">对调用指令做对齐优化。</target>
        </trans-unit>
        <trans-unit id="66402eadff3f8314991b18d5e3fc15f2b633b72a" translate="yes" xml:space="preserve">
          <source>Do not (do) assume that unaligned memory references are handled by the system.</source>
          <target state="translated">不要(做)假设未对齐的内存引用由系统处理。</target>
        </trans-unit>
        <trans-unit id="54f30aa11a7322472ca655cc5794b473a6db2cb4" translate="yes" xml:space="preserve">
          <source>Do not affect the &lt;code&gt;long_call&lt;/code&gt; or &lt;code&gt;short_call&lt;/code&gt; attributes of subsequent functions.</source>
          <target state="translated">不要影响后续函数的 &lt;code&gt;long_call&lt;/code&gt; 或 &lt;code&gt;short_call&lt;/code&gt; 属性。</target>
        </trans-unit>
        <trans-unit id="1d4def84337c056fee739188d13fda579c041fe7" translate="yes" xml:space="preserve">
          <source>Do not align the destination of inlined string operations. This switch reduces code size and improves performance in case the destination is already aligned, but GCC doesn&amp;rsquo;t know about it.</source>
          <target state="translated">不要对齐内联字符串操作的目标。如果目标已经对齐，则此开关减小了代码大小并提高了性能，但GCC对此一无所知。</target>
        </trans-unit>
        <trans-unit id="0de4bbafb6a75d9a2bf9d1dffc4ce55c0685a9e6" translate="yes" xml:space="preserve">
          <source>Do not allow constant data to be placed in code sections. Additionally, when compiling for ELF object format give all text sections the ELF processor-specific section attribute &lt;code&gt;SHF_ARM_PURECODE&lt;/code&gt;. This option is only available when generating non-pic code for M-profile targets with the MOVT instruction.</source>
          <target state="translated">不允许将常量数据放在代码段中。此外，在为ELF对象格式进行编译时，请为所有文本部分提供ELF处理器特定的部分属性 &lt;code&gt;SHF_ARM_PURECODE&lt;/code&gt; 。仅当使用MOVT指令为M轮廓目标生成非图片代码时，此选项才可用。</target>
        </trans-unit>
        <trans-unit id="78254c6c406c6c1d161d9cea04f2b296c2dea358" translate="yes" xml:space="preserve">
          <source>Do not allow constant data to be placed in code sections. Additionally, when compiling for ELF object format give all text sections the ELF processor-specific section attribute &lt;code&gt;SHF_ARM_PURECODE&lt;/code&gt;. This option is only available when generating non-pic code for M-profile targets.</source>
          <target state="translated">不允许将常量数据放置在代码段中。此外，在为ELF对象格式进行编译时，请为所有文本节提供ELF处理器专有的节属性 &lt;code&gt;SHF_ARM_PURECODE&lt;/code&gt; 。仅当为M轮廓目标生成非图片代码时，此选项才可用。</target>
        </trans-unit>
        <trans-unit id="d843db312bcca2cdf09a7f1fe7ee427392d62fac" translate="yes" xml:space="preserve">
          <source>Do not allow the built-in functions &lt;code&gt;ceil&lt;/code&gt;, &lt;code&gt;floor&lt;/code&gt;, &lt;code&gt;round&lt;/code&gt; and &lt;code&gt;trunc&lt;/code&gt;, and their &lt;code&gt;float&lt;/code&gt; and &lt;code&gt;long
double&lt;/code&gt; variants, to generate code that raises the &amp;ldquo;inexact&amp;rdquo; floating-point exception for noninteger arguments. ISO C99 and C11 allow these functions to raise the &amp;ldquo;inexact&amp;rdquo; exception, but ISO/IEC TS 18661-1:2014, the C bindings to IEEE 754-2008, as integrated into ISO C2X, does not allow these functions to do so.</source>
          <target state="translated">不允许内置函数 &lt;code&gt;ceil&lt;/code&gt; ， &lt;code&gt;floor&lt;/code&gt; ， &lt;code&gt;round&lt;/code&gt; 和 &lt;code&gt;trunc&lt;/code&gt; 以及它们的 &lt;code&gt;float&lt;/code&gt; 和 &lt;code&gt;long double&lt;/code&gt; 变体生成用于引发非整数参数&amp;ldquo; inexact&amp;rdquo;浮点异常的代码。ISO C99和C11允许这些功能引发&amp;ldquo; inexact&amp;rdquo;异常，但是ISO / IEC TS 18661-1：2014（集成到ISO C2X中的对IEEE 754-2008的C绑定）不允许这些功能这样做。</target>
        </trans-unit>
        <trans-unit id="03d8305d540b6aba4d4042404329e432ca465541" translate="yes" xml:space="preserve">
          <source>Do not allow the built-in functions &lt;code&gt;ceil&lt;/code&gt;, &lt;code&gt;floor&lt;/code&gt;, &lt;code&gt;round&lt;/code&gt; and &lt;code&gt;trunc&lt;/code&gt;, and their &lt;code&gt;float&lt;/code&gt; and &lt;code&gt;long
double&lt;/code&gt; variants, to generate code that raises the &amp;ldquo;inexact&amp;rdquo; floating-point exception for noninteger arguments. ISO C99 and C11 allow these functions to raise the &amp;ldquo;inexact&amp;rdquo; exception, but ISO/IEC TS 18661-1:2014, the C bindings to IEEE 754-2008, does not allow these functions to do so.</source>
          <target state="translated">不允许内置函数 &lt;code&gt;ceil&lt;/code&gt; ， &lt;code&gt;floor&lt;/code&gt; ， &lt;code&gt;round&lt;/code&gt; 和 &lt;code&gt;trunc&lt;/code&gt; 以及它们的 &lt;code&gt;float&lt;/code&gt; 和 &lt;code&gt;long double&lt;/code&gt; 变体生成用于引发非整数参数&amp;ldquo; inexact&amp;rdquo;浮点异常的代码。ISO C99和C11允许这些功能引发&amp;ldquo; inexact&amp;rdquo;异常，但是ISO / IEC TS 18661-1：2014（对IEEE 754-2008的C绑定）不允许这些功能这样做。</target>
        </trans-unit>
        <trans-unit id="f3ff2c5279a75029bc339b07e7530899c9302db8" translate="yes" xml:space="preserve">
          <source>Do not allow the compiler to generate &lt;em&gt;Long Instruction Word&lt;/em&gt; instructions. This option defines the preprocessor macro &lt;code&gt;__NO_LIW__&lt;/code&gt;.</source>
          <target state="translated">不允许编译器生&lt;em&gt;成长指令字&lt;/em&gt;指令。此选项定义预处理器宏 &lt;code&gt;__NO_LIW__&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="308fe4eb96a98c640686f8d44a99dca853e4e2bc" translate="yes" xml:space="preserve">
          <source>Do not allow the compiler to generate &lt;em&gt;SETLB&lt;/em&gt; or &lt;em&gt;Lcc&lt;/em&gt; instructions. This option defines the preprocessor macro &lt;code&gt;__NO_SETLB__&lt;/code&gt;.</source>
          <target state="translated">不允许编译器生成&lt;em&gt;SETLB&lt;/em&gt;或&lt;em&gt;Lcc&lt;/em&gt;指令。此选项定义预处理器宏 &lt;code&gt;__NO_SETLB__&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c30c06515f3c7a9db38f03e0071054e61d0d6bea" translate="yes" xml:space="preserve">
          <source>Do not apply the &lt;code&gt;longcall&lt;/code&gt; attribute to subsequent function declarations.</source>
          <target state="translated">不要将 &lt;code&gt;longcall&lt;/code&gt; 属性应用于后续函数声明。</target>
        </trans-unit>
        <trans-unit id="6c726465b100e603972419cccdc343f480a4a19b" translate="yes" xml:space="preserve">
          <source>Do not assume a large TLS segment when generating thread-local code.</source>
          <target state="translated">在生成线程本地代码时,不要假设一个大的TLS段。</target>
        </trans-unit>
        <trans-unit id="728fc451cc179eebcc18f5c6344c5c0c36dd581d" translate="yes" xml:space="preserve">
          <source>Do not assume that registers saved by the calling function are restored before calling the &lt;code&gt;noreturn&lt;/code&gt; function.</source>
          <target state="translated">不要假设在调用 &lt;code&gt;noreturn&lt;/code&gt; 函数之前已恢复调用函数保存的寄存器。</target>
        </trans-unit>
        <trans-unit id="e33e43a1033f382fce00f6b8091a2ad6b0b4e974" translate="yes" xml:space="preserve">
          <source>Do not assume that the code being compiled won&amp;rsquo;t link against any ID shared libraries. Slower code is generated for jump and call insns.</source>
          <target state="translated">不要以为正在编译的代码不会链接到任何ID共享库。为跳转和调用insns生成了较慢的代码。</target>
        </trans-unit>
        <trans-unit id="91704a7cde69df99e26557a8fcaceedc0c021417" translate="yes" xml:space="preserve">
          <source>Do not assume the width of floating-point registers.</source>
          <target state="translated">不要假设浮点寄存器的宽度。</target>
        </trans-unit>
        <trans-unit id="56a17068976fe756a1e89e46ec309c06e7526fbb" translate="yes" xml:space="preserve">
          <source>Do not attempt to schedule the preceding instruction into the delay slot of a branch instruction placed at the end of a short loop of six instructions or fewer and always schedule a &lt;code&gt;nop&lt;/code&gt; instruction there instead. The short loop bug under certain conditions causes loops to execute only once or twice, due to a hardware bug in the R5900 chip. The workaround is implemented by the assembler rather than by GCC.</source>
          <target state="translated">不要试图将前一条指令调度到位于六个或更少指令的短循环末尾的分支指令的延迟槽中，而应始终在那里调度一个 &lt;code&gt;nop&lt;/code&gt; 指令。由于R5900芯片中的硬件错误，在某些情况下的短循环错误会导致循环仅执行一次或两次。解决方法是由汇编程序而非GCC实施。</target>
        </trans-unit>
        <trans-unit id="d2be752bd5c8aabe79c7a8b900f158b404d70833" translate="yes" xml:space="preserve">
          <source>Do not consider type &lt;code&gt;int&lt;/code&gt; to be 16 bits wide. This is the default.</source>
          <target state="translated">不要认为 &lt;code&gt;int&lt;/code&gt; 类型为16位宽。这是默认值。</target>
        </trans-unit>
        <trans-unit id="08c20a0490ee73056523e456a376bd15da68e3f1" translate="yes" xml:space="preserve">
          <source>Do not create the &lt;code&gt;gcov&lt;/code&gt; output file.</source>
          <target state="translated">不要创建 &lt;code&gt;gcov&lt;/code&gt; 输出文件。</target>
        </trans-unit>
        <trans-unit id="61bd4083e901aa03be2fec075c5a07232b9c93d4" translate="yes" xml:space="preserve">
          <source>Do not discard comments, including during macro expansion. This is like</source>
          <target state="translated">不要丢弃评论,包括在宏扩展期间。这就像</target>
        </trans-unit>
        <trans-unit id="094e1651c852304b7a16e16ed4d0185ecd59b26b" translate="yes" xml:space="preserve">
          <source>Do not discard comments. All comments are passed through to the output file, except for comments in processed directives, which are deleted along with the directive.</source>
          <target state="translated">不要丢弃注释。所有的注释都会被传递到输出文件中,但经过处理的指令中的注释除外,这些注释会和指令一起被删除。</target>
        </trans-unit>
        <trans-unit id="91b2c99fa330a126f06708c6cdfa9c96a1c2ca48" translate="yes" xml:space="preserve">
          <source>Do not emit instructions with side effects in addressing modes other than post-increment.</source>
          <target state="translated">不要在后增量以外的寻址模式下发出有副作用的指令。</target>
        </trans-unit>
        <trans-unit id="8e8fcc0f33555f7707b3fe0e2c86d30a856ae4de" translate="yes" xml:space="preserve">
          <source>Do not emit the extra code to use the routines specified in the C++ ABI for thread-safe initialization of local statics. You can use this option to reduce code size slightly in code that doesn&amp;rsquo;t need to be thread-safe.</source>
          <target state="translated">不要发出多余的代码来使用C ++ ABI中指定的例程对本地静态变量进行线程安全的初始化。您可以使用此选项在不需要线程安全的代码中稍微减小代码大小。</target>
        </trans-unit>
        <trans-unit id="a50320f9ab85e604d11edb3fea826b2a1de37844" translate="yes" xml:space="preserve">
          <source>Do not enforce a 32-byte alignment for loops. This is the default.</source>
          <target state="translated">不对循环执行32字节的对齐方式。这是默认的。</target>
        </trans-unit>
        <trans-unit id="891fab210e7a9b122822bf86387a01881f014d38" translate="yes" xml:space="preserve">
          <source>Do not expand any functions inline apart from those marked with the &lt;code&gt;always_inline&lt;/code&gt; attribute. This is the default when not optimizing.</source>
          <target state="translated">除了标有 &lt;code&gt;always_inline&lt;/code&gt; 属性的功能外，请勿展开任何内联功能。这是未优化时的默认设置。</target>
        </trans-unit>
        <trans-unit id="e55929ae438e9efde315189f7933071caa5c75d9" translate="yes" xml:space="preserve">
          <source>Do not expand any symbolic links, resolve references to &amp;lsquo;</source>
          <target state="translated">请勿展开任何符号链接，而是将对&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="76bc4e801782e79c379029a2b2d98ead9b1c58f2" translate="yes" xml:space="preserve">
          <source>Do not expect a sequence of &lt;code&gt;asm&lt;/code&gt; statements to remain perfectly consecutive after compilation, even when you are using the &lt;code&gt;volatile&lt;/code&gt; qualifier. If certain instructions need to remain consecutive in the output, put them in a single multi-instruction &lt;code&gt;asm&lt;/code&gt; statement.</source>
          <target state="translated">即使在使用 &lt;code&gt;volatile&lt;/code&gt; 限定符时，也不要期望 &lt;code&gt;asm&lt;/code&gt; 语句序列在编译后能保持完美连续。如果某些指令需要在输出中保持连续，请将它们放在单个多指令 &lt;code&gt;asm&lt;/code&gt; 语句中。</target>
        </trans-unit>
        <trans-unit id="1357d76978b996f4f01f805d2256a79e656aef14" translate="yes" xml:space="preserve">
          <source>Do not expect a sequence of &lt;code&gt;asm&lt;/code&gt; statements to remain perfectly consecutive after compilation. If certain instructions need to remain consecutive in the output, put them in a single multi-instruction &lt;code&gt;asm&lt;/code&gt; statement. Note that GCC&amp;rsquo;s optimizers can move &lt;code&gt;asm&lt;/code&gt; statements relative to other code, including across jumps.</source>
          <target state="translated">不要期望 &lt;code&gt;asm&lt;/code&gt; 后的一系列asm语句保持完美连续。如果某些指令需要在输出中保持连续，请将它们放在单个多指令 &lt;code&gt;asm&lt;/code&gt; 语句中。请注意，GCC的优化程序可以相对于其他代码移动 &lt;code&gt;asm&lt;/code&gt; 语句，包括跨跳转。</target>
        </trans-unit>
        <trans-unit id="84b3d7d09c0c54d717842f06c98dbd62ec42f930" translate="yes" xml:space="preserve">
          <source>Do not generate 16-bit instructions.</source>
          <target state="translated">不要生成16位指令。</target>
        </trans-unit>
        <trans-unit id="ad6e921329e0de0a14badc58726b2429a811f03b" translate="yes" xml:space="preserve">
          <source>Do not generate &lt;code&gt;mpy&lt;/code&gt;-family instructions for ARC700. This option is deprecated.</source>
          <target state="translated">不要为ARC700 生成 &lt;code&gt;mpy&lt;/code&gt; -family指令。不建议使用此选项。</target>
        </trans-unit>
        <trans-unit id="677bb296fc46c470e0c30284fe52bf50c8bf95e0" translate="yes" xml:space="preserve">
          <source>Do not generate GP-relative accesses.</source>
          <target state="translated">不要产生GP相关的访问。</target>
        </trans-unit>
        <trans-unit id="f71d5f68821b30e885b1156b06fcb682f984e58f" translate="yes" xml:space="preserve">
          <source>Do not generate code that can only run in supervisor mode. This is relevant only for the &lt;code&gt;casa&lt;/code&gt; instruction emitted for the LEON3 processor. This is the default.</source>
          <target state="translated">不要生成只能在超级用户模式下运行的代码。这仅与LEON3处理器发出的 &lt;code&gt;casa&lt;/code&gt; 指令有关。这是默认值。</target>
        </trans-unit>
        <trans-unit id="0295c6ec8a8e0c073456a9cdaa9ef67d389ca72d" translate="yes" xml:space="preserve">
          <source>Do not generate code that reads program memory.</source>
          <target state="translated">不要生成读取程序内存的代码。</target>
        </trans-unit>
        <trans-unit id="2a55e3aa2938e0b388b8a2f34ed44323717c2975" translate="yes" xml:space="preserve">
          <source>Do not generate code to avoid bugs in the multiply instructions for the MN10300 processors.</source>
          <target state="translated">不要生成代码,以避免MN10300处理器的乘法指令出现错误。</target>
        </trans-unit>
        <trans-unit id="6775dd83d160f5e2159511baea19387bf2da721f" translate="yes" xml:space="preserve">
          <source>Do not generate code using features specific to the AM33 processor. This is the default.</source>
          <target state="translated">不要使用AM33处理器特有的功能生成代码。这是默认的。</target>
        </trans-unit>
        <trans-unit id="159947dfd1a4fc3fd4fb823f295379e5ec4d1e29" translate="yes" xml:space="preserve">
          <source>Do not generate conditional move instructions.</source>
          <target state="translated">不要产生有条件的移动指令。</target>
        </trans-unit>
        <trans-unit id="2a7c63697c44693e6c631b03a4bcdf4c623d8e94" translate="yes" xml:space="preserve">
          <source>Do not generate floating-point instructions; use library calls instead. This is the default for 68000, 68010, and 68832 targets. It is also the default for ColdFire devices that have no FPU.</source>
          <target state="translated">不要生成浮点指令,而使用库调用。这是68000、68010和68832目标的默认值。这也是没有FPU的ColdFire设备的默认值。</target>
        </trans-unit>
        <trans-unit id="2cc223b18a9c8fe85db4c5fdd1a4568ac5523351" translate="yes" xml:space="preserve">
          <source>Do not generate inline code for &lt;code&gt;sqrt&lt;/code&gt;.</source>
          <target state="translated">不要为 &lt;code&gt;sqrt&lt;/code&gt; 生成内联代码。</target>
        </trans-unit>
        <trans-unit id="7dccee88899cb101fdf1122d7b6f87cc5ad98128" translate="yes" xml:space="preserve">
          <source>Do not generate inline code for divides of floating-point values.</source>
          <target state="translated">不要为浮点值的除法生成内联代码。</target>
        </trans-unit>
        <trans-unit id="db0d6f198e71d6a0581c6b52ba5d158f3703dad4" translate="yes" xml:space="preserve">
          <source>Do not generate inline code for divides of integer values.</source>
          <target state="translated">不要生成整数值除法的内联代码。</target>
        </trans-unit>
        <trans-unit id="5bf145c70d37b823fa320934be3a45f2f5b58879" translate="yes" xml:space="preserve">
          <source>Do not generate performance extension 2 instructions.</source>
          <target state="translated">不要产生性能扩展2指令。</target>
        </trans-unit>
        <trans-unit id="3b1b47a62d265ff0109bc6fe295c353c7dfbd942" translate="yes" xml:space="preserve">
          <source>Do not generate performance extension instructions.</source>
          <target state="translated">不要产生性能扩展指令。</target>
        </trans-unit>
        <trans-unit id="b028375dbf2397374ef15ae6807634be0bef9937" translate="yes" xml:space="preserve">
          <source>Do not generate sdata references. This is the default for tool chains built for &lt;code&gt;arc-linux-uclibc&lt;/code&gt; and &lt;code&gt;arceb-linux-uclibc&lt;/code&gt; targets.</source>
          <target state="translated">不生成sdata引用。这是为 &lt;code&gt;arc-linux-uclibc&lt;/code&gt; 和 &lt;code&gt;arceb-linux-uclibc&lt;/code&gt; 目标构建的工具链的默认设置。</target>
        </trans-unit>
        <trans-unit id="543afe0ee34f2553275fc1e0d4f92ae4d031e11e" translate="yes" xml:space="preserve">
          <source>Do not generate string extension instructions.</source>
          <target state="translated">不要生成字符串扩展指令。</target>
        </trans-unit>
        <trans-unit id="35172dff465f7db05c87cd9d0fa618a5943366ff" translate="yes" xml:space="preserve">
          <source>Do not generate v3 push25/pop25 instructions.</source>
          <target state="translated">不要生成v3 push25/pop25指令。</target>
        </trans-unit>
        <trans-unit id="57a412ef71d36d080e33196062eae1a348ffd9a5" translate="yes" xml:space="preserve">
          <source>Do not guess branch probabilities using heuristics.</source>
          <target state="translated">不要用启发式方法猜测分支概率。</target>
        </trans-unit>
        <trans-unit id="c3b0780d488de79c8fb5609252ace9e026b5485c" translate="yes" xml:space="preserve">
          <source>Do not link in the C run-time initialization object file.</source>
          <target state="translated">不要在C语言运行时初始化对象文件中进行链接。</target>
        </trans-unit>
        <trans-unit id="1be7375d07ff18651b91e6f0b8f72660024d9706" translate="yes" xml:space="preserve">
          <source>Do not mark ABI switches in e_flags.</source>
          <target state="translated">不要在e_flags中标记ABI开关。</target>
        </trans-unit>
        <trans-unit id="431d0ac813eff431a021eadf038696c3b8c0a701" translate="yes" xml:space="preserve">
          <source>Do not optimize (do optimize) basic blocks that use the same index pointer 4 or more times to copy pointer into the &lt;code&gt;ep&lt;/code&gt; register, and use the shorter &lt;code&gt;sld&lt;/code&gt; and &lt;code&gt;sst&lt;/code&gt; instructions. The</source>
          <target state="translated">不要优化（执行优化）使用相同索引指针4次或更多次的基本块，以将指针复制到 &lt;code&gt;ep&lt;/code&gt; 寄存器中，并使用较短的 &lt;code&gt;sld&lt;/code&gt; 和 &lt;code&gt;sst&lt;/code&gt; 指令。的</target>
        </trans-unit>
        <trans-unit id="79c5f07fbe7818d1561eea80118156e770e03da3" translate="yes" xml:space="preserve">
          <source>Do not optimize block moves, use &lt;code&gt;memcpy&lt;/code&gt;.</source>
          <target state="translated">不要优化块移动，请使用 &lt;code&gt;memcpy&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1c81bdb6603f6660bfebcf5b1c10715d6960adf2" translate="yes" xml:space="preserve">
          <source>Do not or do generate unaligned memory accesses. The default is set depending on whether the processor we are optimizing for supports fast unaligned access or not.</source>
          <target state="translated">不产生或不产生不对齐的内存访问。默认值的设置取决于我们优化的处理器是否支持快速不对齐访问。</target>
        </trans-unit>
        <trans-unit id="4a89ae960644f6dae44b3cb05c0d0550f4cbdda0" translate="yes" xml:space="preserve">
          <source>Do not output certain jump instructions (&lt;code&gt;aobleq&lt;/code&gt; and so on) that the Unix assembler for the VAX cannot handle across long ranges.</source>
          <target state="translated">不要输出某些用于VAX的Unix汇编程序无法跨长距离处理的跳转指令（ &lt;code&gt;aobleq&lt;/code&gt; 等）。</target>
        </trans-unit>
        <trans-unit id="f8a3ee3da0c5dc6481bc333868effaef20cfecb3" translate="yes" xml:space="preserve">
          <source>Do not pack VLIW instructions.</source>
          <target state="translated">不要包装VLIW说明书。</target>
        </trans-unit>
        <trans-unit id="5cf0a2e01f314e50aac688fcc0637765ffe183d2" translate="yes" xml:space="preserve">
          <source>Do not predefine any system-specific or GCC-specific macros. The standard predefined macros remain defined.</source>
          <target state="translated">不要预先定义任何系统专用或GCC专用宏。标准的预定义宏仍然被定义。</target>
        </trans-unit>
        <trans-unit id="490cb97bfac29c7944f438d394a40917ab27b463" translate="yes" xml:space="preserve">
          <source>Do not print column numbers in diagnostics. This may be necessary if diagnostics are being scanned by a program that does not understand the column numbers, such as &lt;code&gt;dejagnu&lt;/code&gt;.</source>
          <target state="translated">不要在诊断中打印列号。如果诊断程序是由不了解列号的程序（例如 &lt;code&gt;dejagnu&lt;/code&gt; )扫描的，则可能有必要。</target>
        </trans-unit>
        <trans-unit id="5a166eec1d3e160d989368c024582f88a817fbe4" translate="yes" xml:space="preserve">
          <source>Do not put function addresses in registers; make each instruction that calls a constant function contain the function&amp;rsquo;s address explicitly.</source>
          <target state="translated">不要将功能地址放在寄存器中；使每个调用常量函数的指令显式包含该函数的地址。</target>
        </trans-unit>
        <trans-unit id="42d099b873c7985f112edf3c200fc2a3b03ec5d0" translate="yes" xml:space="preserve">
          <source>Do not recognize &lt;code&gt;asm&lt;/code&gt;, &lt;code&gt;inline&lt;/code&gt; or &lt;code&gt;typeof&lt;/code&gt; as a keyword, so that code can use these words as identifiers. You can use the keywords &lt;code&gt;__asm__&lt;/code&gt;, &lt;code&gt;__inline__&lt;/code&gt; and &lt;code&gt;__typeof__&lt;/code&gt; instead.</source>
          <target state="translated">不要将 &lt;code&gt;asm&lt;/code&gt; ， &lt;code&gt;inline&lt;/code&gt; 或 &lt;code&gt;typeof&lt;/code&gt; 识别为关键字，以便代码可以将这些单词用作标识符。您可以使用关键字 &lt;code&gt;__asm__&lt;/code&gt; ， &lt;code&gt;__inline__&lt;/code&gt; 和 &lt;code&gt;__typeof__&lt;/code&gt; 代替。</target>
        </trans-unit>
        <trans-unit id="4748c7a1ef517bb9ba562d1dfbac2e153a84b556" translate="yes" xml:space="preserve">
          <source>Do not recognize &lt;code&gt;typeof&lt;/code&gt; as a keyword, so that code can use this word as an identifier. You can use the keyword &lt;code&gt;__typeof__&lt;/code&gt; instead. This option is implied by the strict ISO C++ dialects:</source>
          <target state="translated">不要将 &lt;code&gt;typeof&lt;/code&gt; 识别为关键字，以便代码可以将此词用作标识符。您可以改用关键字 &lt;code&gt;__typeof__&lt;/code&gt; 。严格的ISO C ++方言暗含此选项：</target>
        </trans-unit>
        <trans-unit id="d988b2ea918cdfbb994dc84b28dcc9b828621817" translate="yes" xml:space="preserve">
          <source>Do not remove unused C++ allocations in dead code elimination.</source>
          <target state="translated">在消除死代码时不要删除未使用的C++分配。</target>
        </trans-unit>
        <trans-unit id="0184fc6ad01e42f8636e2c8922ca8fae3a1d46de" translate="yes" xml:space="preserve">
          <source>Do not reorder functions or variables marked &lt;code&gt;no_reorder&lt;/code&gt; against each other or top level assembler statements the executable. The actual order in the program will depend on the linker command line. Static variables marked like this are also not removed. This has a similar effect as the</source>
          <target state="translated">请勿将标有 &lt;code&gt;no_reorder&lt;/code&gt; 的函数或变量彼此重新排序，也不要在顶级汇编器语句中对可执行文件进行重新排序。程序中的实际顺序将取决于链接器命令行。标记为这样的静态变量也不会被删除。这与</target>
        </trans-unit>
        <trans-unit id="8ddac79842e7bae2915ad838f14a89d8d6021356" translate="yes" xml:space="preserve">
          <source>Do not reorder top-level functions, variables, and &lt;code&gt;asm&lt;/code&gt; statements. Output them in the same order that they appear in the input file. When this option is used, unreferenced static variables are not removed. This option is intended to support existing code that relies on a particular ordering. For new code, it is better to use attributes when possible.</source>
          <target state="translated">不要对顶级函数，变量和 &lt;code&gt;asm&lt;/code&gt; 语句重新排序。按照它们在输入文件中出现的顺序输出它们。使用此选项时，不会删除未引用的静态变量。此选项旨在支持依赖特定顺序的现有代码。对于新代码，最好尽可能使用属性。</target>
        </trans-unit>
        <trans-unit id="e09f89632800cad3603644ff83e1a579b7e4eb4f" translate="yes" xml:space="preserve">
          <source>Do not run a pass to pack branches into VLIW instructions.</source>
          <target state="translated">不要运行通证将分支打包成VLIW指令。</target>
        </trans-unit>
        <trans-unit id="0dba1f61030583d8ab48fd80d73e6a5afaf9d194" translate="yes" xml:space="preserve">
          <source>Do not save registers in &lt;code&gt;main&lt;/code&gt;. The effect is the same like attaching attribute &lt;a href=&quot;avr-function-attributes#AVR-Function-Attributes&quot;&gt;&lt;code&gt;OS_task&lt;/code&gt;&lt;/a&gt; to &lt;code&gt;main&lt;/code&gt;. It is activated per default if optimization is on.</source>
          <target state="translated">不要将寄存器保存在 &lt;code&gt;main&lt;/code&gt; 中。效果与将属性&lt;a href=&quot;avr-function-attributes#AVR-Function-Attributes&quot;&gt; &lt;code&gt;OS_task&lt;/code&gt; &lt;/a&gt;附加到 &lt;code&gt;main&lt;/code&gt; 相同。如果启用了优化，则默认情况下会激活它。</target>
        </trans-unit>
        <trans-unit id="9b74c0ce30e69827202932531a3c2d31b17cec32" translate="yes" xml:space="preserve">
          <source>Do not search for header files in the C++-specific standard directories, but do still search the other standard directories. (This option is used when building the C++ library.)</source>
          <target state="translated">不搜索C++专用标准目录中的头文件,但仍搜索其他标准目录。(此选项在构建C++库时使用。)</target>
        </trans-unit>
        <trans-unit id="10d644d96645c398a65f49953416f8df18eac09b" translate="yes" xml:space="preserve">
          <source>Do not search for header files in the standard directories specific to C++, but do still search the other standard directories. (This option is used when building the C++ library.)</source>
          <target state="translated">不要在C++特有的标准目录中搜索头文件,但仍要搜索其他标准目录。(此选项在构建C++库时使用。)</target>
        </trans-unit>
        <trans-unit id="6ee81949a7a2777f7208e1e6ee75bc8ae9472923" translate="yes" xml:space="preserve">
          <source>Do not search the standard system directories for header files. Only the directories explicitly specified with</source>
          <target state="translated">不要在标准系统目录中搜索头文件。只搜索用</target>
        </trans-unit>
        <trans-unit id="eb16433a9f72928c54140581a05d1867ea26ccd7" translate="yes" xml:space="preserve">
          <source>Do not set &lt;code&gt;errno&lt;/code&gt; after calling math functions that are executed with a single instruction, e.g., &lt;code&gt;sqrt&lt;/code&gt;. A program that relies on IEEE exceptions for math error handling may want to use this flag for speed while maintaining IEEE arithmetic compatibility.</source>
          <target state="translated">调用用单个指令执行的数学函数（例如 &lt;code&gt;sqrt&lt;/code&gt; )后，请勿设置 &lt;code&gt;errno&lt;/code&gt; 。依赖IEEE异常进行数学错误处理的程序可能希望将此标志用于速度，同时保持IEEE算术兼容性。</target>
        </trans-unit>
        <trans-unit id="20c8d2c68cfa75e481382ec2a217fdac468ae476" translate="yes" xml:space="preserve">
          <source>Do not store floating-point variables in registers, and inhibit other options that might change whether a floating-point value is taken from a register or memory.</source>
          <target state="translated">不要将浮点变量存储在寄存器中,并抑制其他可能改变浮点值是来自寄存器还是内存的选项。</target>
        </trans-unit>
        <trans-unit id="1e223b8f5150edab41b25d5219e57c17c3a59917" translate="yes" xml:space="preserve">
          <source>Do not substitute constants for known return value of formatted output functions such as &lt;code&gt;sprintf&lt;/code&gt;, &lt;code&gt;snprintf&lt;/code&gt;, &lt;code&gt;vsprintf&lt;/code&gt;, and &lt;code&gt;vsnprintf&lt;/code&gt; (but not &lt;code&gt;printf&lt;/code&gt; of &lt;code&gt;fprintf&lt;/code&gt;). This transformation allows GCC to optimize or even eliminate branches based on the known return value of these functions called with arguments that are either constant, or whose values are known to be in a range that makes determining the exact return value possible. For example, when</source>
          <target state="translated">不要用常量代替格式化输出函数的已知返回值，例如 &lt;code&gt;sprintf&lt;/code&gt; ， &lt;code&gt;snprintf&lt;/code&gt; ， &lt;code&gt;vsprintf&lt;/code&gt; 和 &lt;code&gt;vsnprintf&lt;/code&gt; （但不要用 &lt;code&gt;fprintf&lt;/code&gt; 的 &lt;code&gt;printf&lt;/code&gt; ）。这种转换允许GCC根据这些函数的已知返回值优化或消除分支，这些函数的返回值是恒定的，或者已知其值在可以确定确切返回值的范围内。例如，当</target>
        </trans-unit>
        <trans-unit id="cf78eba26b5aa804017da1ef12f012cd3682e1fb" translate="yes" xml:space="preserve">
          <source>Do not treat the operator name keywords &lt;code&gt;and&lt;/code&gt;, &lt;code&gt;bitand&lt;/code&gt;, &lt;code&gt;bitor&lt;/code&gt;, &lt;code&gt;compl&lt;/code&gt;, &lt;code&gt;not&lt;/code&gt;, &lt;code&gt;or&lt;/code&gt; and &lt;code&gt;xor&lt;/code&gt; as synonyms as keywords.</source>
          <target state="translated">不要把运营商名称的关键字 &lt;code&gt;and&lt;/code&gt; ， &lt;code&gt;bitand&lt;/code&gt; ， &lt;code&gt;bitor&lt;/code&gt; ， &lt;code&gt;compl&lt;/code&gt; ， &lt;code&gt;not&lt;/code&gt; ， &lt;code&gt;or&lt;/code&gt; 和 &lt;code&gt;xor&lt;/code&gt; 作为同义词作为关键字。</target>
        </trans-unit>
        <trans-unit id="a51f0c8e8070d0d16a2b1996318508b466a43f6d" translate="yes" xml:space="preserve">
          <source>Do not try to dynamically allocate condition code registers, only use &lt;code&gt;icc0&lt;/code&gt; and &lt;code&gt;fcc0&lt;/code&gt;.</source>
          <target state="translated">不要尝试动态分配条件代码寄存器，而只能使用 &lt;code&gt;icc0&lt;/code&gt; 和 &lt;code&gt;fcc0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e4b145e8904eea56f7b19e2cc3eedad3e7a2b834" translate="yes" xml:space="preserve">
          <source>Do not use (do use) external functions to save and restore registers at the prologue and epilogue of a function. The external functions are slower, but use less code space if more than one function saves the same number of registers. The</source>
          <target state="translated">不要在一个函数的序幕和尾声使用(做使用)外部函数来保存和恢复寄存器。如果一个以上的函数保存相同数量的寄存器,外部函数的速度较慢,但使用的代码空间较少。寄存器数量相同的情况下,外部函数的速度较慢,但使用的代码空间较少。</target>
        </trans-unit>
        <trans-unit id="00d7092da6abac6816723cc9e024cce735f69d9a" translate="yes" xml:space="preserve">
          <source>Do not use &lt;code&gt;__gcc_isr&lt;/code&gt; pseudo instructions in a function with the &lt;code&gt;interrupt&lt;/code&gt; or &lt;code&gt;signal&lt;/code&gt; attribute aka. interrupt service routine (ISR). Use this attribute if the preamble of the ISR prologue should always read</source>
          <target state="translated">不要在具有 &lt;code&gt;interrupt&lt;/code&gt; 或 &lt;code&gt;signal&lt;/code&gt; 属性的函数中使用 &lt;code&gt;__gcc_isr&lt;/code&gt; 伪指令。中断服务程序（ISR）。如果ISR序言的序言应始终阅读，请使用此属性</target>
        </trans-unit>
        <trans-unit id="18d8580e81e8dfe5a32f7016f417e2eb0471dcb3" translate="yes" xml:space="preserve">
          <source>Do not use a so-called &amp;ldquo;red zone&amp;rdquo; for x86-64 code. The red zone is mandated by the x86-64 ABI; it is a 128-byte area beyond the location of the stack pointer that is not modified by signal or interrupt handlers and therefore can be used for temporary data without adjusting the stack pointer. The flag</source>
          <target state="translated">请勿对x86-64代码使用所谓的&amp;ldquo;红色区域&amp;rdquo;。红色区域由x86-64 ABI强制；它是堆栈指针位置之外的128字节区域，未被信号或中断处理程序修改，因此可用于临时数据而无需调整堆栈指针。旗</target>
        </trans-unit>
        <trans-unit id="18a500f76abd74325a0b47c0d5b69985957db494" translate="yes" xml:space="preserve">
          <source>Do not use condition-code results from previous instruction; always emit compare and test instructions before use of condition codes.</source>
          <target state="translated">不要使用前一条指令的条件码结果;在使用条件码之前,总是先发出比较和测试指令。</target>
        </trans-unit>
        <trans-unit id="8b90672d13ea8faf72441a2154876e77530d1d87" translate="yes" xml:space="preserve">
          <source>Do not use div and mod instructions.</source>
          <target state="translated">不要使用div和model指令。</target>
        </trans-unit>
        <trans-unit id="a1c8552434007f4da99e51d45212d527e1753ccf" translate="yes" xml:space="preserve">
          <source>Do not use double word instructions.</source>
          <target state="translated">不要使用双字说明。</target>
        </trans-unit>
        <trans-unit id="3da98d0922de975e727ce6056f533717a8befbdb" translate="yes" xml:space="preserve">
          <source>Do not use floating-point coprocessor instructions. Implement floating-point calculations using library calls instead.</source>
          <target state="translated">不要使用浮点协处理器指令。使用库调用实现浮点计算。</target>
        </trans-unit>
        <trans-unit id="9fdd545e439d4b4617a15eacf8cd9e4f96ac14e8" translate="yes" xml:space="preserve">
          <source>Do not use floating-point double instructions.</source>
          <target state="translated">不要使用浮点双指令。</target>
        </trans-unit>
        <trans-unit id="95fd53c42ee138555aacbc40f7b4326fe9304fd6" translate="yes" xml:space="preserve">
          <source>Do not use hardware floating point.</source>
          <target state="translated">不要使用硬件浮点。</target>
        </trans-unit>
        <trans-unit id="97b2ddca9650ddbadc66a49ca355676910df5582" translate="yes" xml:space="preserve">
          <source>Do not use jump tables for switch statements even where it would be more efficient than other code generation strategies. This option is of use in conjunction with</source>
          <target state="translated">即使在比其他代码生成策略更有效的情况下,也不要对开关语句使用跳表。这个选项与</target>
        </trans-unit>
        <trans-unit id="66b43b46849088f20d198292bf3b1d8b62697198" translate="yes" xml:space="preserve">
          <source>Do not use media instructions.</source>
          <target state="translated">不要使用媒体说明。</target>
        </trans-unit>
        <trans-unit id="0a7e7f9ca7cad5a355cdeb3565cfa6b4acd871ea" translate="yes" xml:space="preserve">
          <source>Do not use multiply and add/subtract instructions.</source>
          <target state="translated">不要使用乘法和加/减法指令。</target>
        </trans-unit>
        <trans-unit id="8d9e83aee940103d590cb767e0456c5b78e32683" translate="yes" xml:space="preserve">
          <source>Do not use table-based fast divide for small numbers. The default is to use the fast divide at</source>
          <target state="translated">对于小数,不要使用基于表格的快速除法。默认情况下,使用快速除法,在</target>
        </trans-unit>
        <trans-unit id="05b033596194e8c7885a56cfce16297eb0279fb4" translate="yes" xml:space="preserve">
          <source>Do not use the C library or system libraries tightly coupled with it when linking. Still link with the startup files,</source>
          <target state="translated">链接时不要使用C库或与之紧密耦合的系统库。还是用启动文件链接。</target>
        </trans-unit>
        <trans-unit id="7597081c858717e7804a44bce422498f190040a9" translate="yes" xml:space="preserve">
          <source>Do not use the FPU registers for return values of functions.</source>
          <target state="translated">不要将FPU寄存器用于函数的返回值。</target>
        </trans-unit>
        <trans-unit id="1d16a9b15ecbbe19aaee48f8f83799d98bf40097" translate="yes" xml:space="preserve">
          <source>Do not use the PLT for external function calls in position-independent code. Instead, load the callee address at call sites from the GOT and branch to it. This leads to more efficient code by eliminating PLT stubs and exposing GOT loads to optimizations. On architectures such as 32-bit x86 where PLT stubs expect the GOT pointer in a specific register, this gives more register allocation freedom to the compiler. Lazy binding requires use of the PLT; with</source>
          <target state="translated">不要在与位置无关的代码中使用PLT进行外部函数调用。相反,从GOT中加载调用站点的被叫者地址,并对其进行分支。这样可以消除PLT存根,并将GOT负载暴露给优化,从而提高代码效率。在32位x86等架构上,PLT存根期望GOT指针在特定寄存器中,这给编译器提供了更多的寄存器分配自由度。懒惰绑定需要使用PLT;有了</target>
        </trans-unit>
        <trans-unit id="0ea4440b962126227be7707085ba73c227777ab2" translate="yes" xml:space="preserve">
          <source>Do not use the bit-field instructions. The</source>
          <target state="translated">不要使用位场指令。的,不要使用位场指令。</target>
        </trans-unit>
        <trans-unit id="be4c2d58ea2c75689a1e197b8bce077dc3baf8e4" translate="yes" xml:space="preserve">
          <source>Do not use the standard system libraries when linking. Only the libraries you specify are passed to the linker, and options specifying linkage of the system libraries, such as</source>
          <target state="translated">链接时不要使用标准的系统库。只有你指定的库才会传递给链接器,而指定系统库链接的选项,如</target>
        </trans-unit>
        <trans-unit id="1749ead3f9e7878168e9e856a83790c8110a2327" translate="yes" xml:space="preserve">
          <source>Do not use the standard system startup files or libraries when linking. No startup files and only the libraries you specify are passed to the linker, and options specifying linkage of the system libraries, such as</source>
          <target state="translated">链接时不要使用标准的系统启动文件或库。没有启动文件,只把你指定的库传递给链接器,而指定系统库链接的选项,如</target>
        </trans-unit>
        <trans-unit id="c08b8394a0f77286bf2dfe4eba4ed4f08b60e58a" translate="yes" xml:space="preserve">
          <source>Do not use the standard system startup files when linking. The standard system libraries are used normally, unless</source>
          <target state="translated">链接时不要使用标准系统启动文件。标准系统库是正常使用的,除非</target>
        </trans-unit>
        <trans-unit id="52b9f7e2d461f74673bbbc8c6515110fc50b3657" translate="yes" xml:space="preserve">
          <source>Do not use type qualifiers such as &lt;code&gt;const&lt;/code&gt; and &lt;code&gt;volatile&lt;/code&gt;, as the outcome may be contrary to expectations. In particular, using the &lt;code&gt;volatile&lt;/code&gt; qualifier does not fully prevent the compiler from optimizing accesses to the register.</source>
          <target state="translated">不要使用 &lt;code&gt;const&lt;/code&gt; 和 &lt;code&gt;volatile&lt;/code&gt; 等类型限定符，因为结果可能与预期相反。特别是，使用 &lt;code&gt;volatile&lt;/code&gt; 限定符不会完全阻止编译器优化对寄存器的访问。</target>
        </trans-unit>
        <trans-unit id="78d5320a817e4a255712f70b363a7e985f54d40c" translate="yes" xml:space="preserve">
          <source>Do not use type qualifiers such as &lt;code&gt;const&lt;/code&gt; and &lt;code&gt;volatile&lt;/code&gt;, as the outcome may be contrary to expectations. In particular, when the &lt;code&gt;const&lt;/code&gt; qualifier is used, the compiler may substitute the variable with its initializer in &lt;code&gt;asm&lt;/code&gt; statements, which may cause the corresponding operand to appear in a different register.</source>
          <target state="translated">不要使用 &lt;code&gt;const&lt;/code&gt; 和 &lt;code&gt;volatile&lt;/code&gt; 等类型限定符，因为结果可能与预期相反。特别是，当使用 &lt;code&gt;const&lt;/code&gt; 限定符时，编译器可以在 &lt;code&gt;asm&lt;/code&gt; 语句中用其初始化程序替换变量，这可能导致相应的操作数出现在不同的寄存器中。</target>
        </trans-unit>
        <trans-unit id="4a1518a9d7c5d3a374a0e3380575da8c6a0c3463" translate="yes" xml:space="preserve">
          <source>Do not use weak symbol support, even if it is provided by the linker. By default, G++ uses weak symbols if they are available. This option exists only for testing, and should not be used by end-users; it results in inferior code and has no benefits. This option may be removed in a future release of G++.</source>
          <target state="translated">不要使用弱符号支持,即使是由链接器提供的。默认情况下,如果有弱符号,G++会使用弱符号。这个选项只存在于测试中,终端用户不应该使用,它导致的是低劣的代码,没有任何好处。这个选项可能会在未来的G++版本中被删除。</target>
        </trans-unit>
        <trans-unit id="1c6a44b0e85a6edc81e27b7d2eeb886e6e3cf31e" translate="yes" xml:space="preserve">
          <source>Do not warn about compile-time integer division by zero. Floating-point division by zero is not warned about, as it can be a legitimate way of obtaining infinities and NaNs.</source>
          <target state="translated">不要警告编译时的整数除以零。不警告浮点除以零,因为这可能是获得无穷大和NaN的合法方式。</target>
        </trans-unit>
        <trans-unit id="5c0402a3d7a93e89c19d0b2bc886627da9bb7bce" translate="yes" xml:space="preserve">
          <source>Do not warn about compile-time overflow in constant expressions.</source>
          <target state="translated">不要对常量表达式中的编译时溢出发出警告。</target>
        </trans-unit>
        <trans-unit id="f3164f98334eb82394edc2af61f2d8e4ea49e902" translate="yes" xml:space="preserve">
          <source>Do not warn about incompatible integer to pointer and pointer to integer conversions. This warning is about implicit conversions; for explicit conversions the warnings</source>
          <target state="translated">不要对不兼容的整数到指针和指针到整数的转换发出警告。这个警告是关于隐式转换的;对于显式转换,警告为</target>
        </trans-unit>
        <trans-unit id="9ee34e26cbf6dcdf9bae6a606eba5f147e3812eb" translate="yes" xml:space="preserve">
          <source>Do not warn about misuses of pragmas, such as incorrect parameters, invalid syntax, or conflicts between pragmas. See also</source>
          <target state="translated">不要对滥用语法提出警告,例如错误的参数、无效的语法或语法之间的冲突。参见</target>
        </trans-unit>
        <trans-unit id="2fba612926859cd3b2ec30d821b233c2c88e411e" translate="yes" xml:space="preserve">
          <source>Do not warn about returning a pointer (or in C++, a reference) to a variable that goes out of scope after the function returns.</source>
          <target state="translated">在函数返回后,不要警告返回一个指针(或在C++中,一个引用)到一个超出范围的变量。</target>
        </trans-unit>
        <trans-unit id="92098da2097ee55c0bcb42fe16576932a7b751af" translate="yes" xml:space="preserve">
          <source>Do not warn about stray tokens after &lt;code&gt;#else&lt;/code&gt; and &lt;code&gt;#endif&lt;/code&gt;.</source>
          <target state="translated">不要在 &lt;code&gt;#else&lt;/code&gt; 和 &lt;code&gt;#endif&lt;/code&gt; 之后警告流浪令牌。</target>
        </trans-unit>
        <trans-unit id="e20062785b98beaefd7db7d397190023d3d7d01c" translate="yes" xml:space="preserve">
          <source>Do not warn about usage of deprecated features. See &lt;a href=&quot;deprecated-features#Deprecated-Features&quot;&gt;Deprecated Features&lt;/a&gt;.</source>
          <target state="translated">不要警告使用已弃用的功能。请参阅&lt;a href=&quot;deprecated-features#Deprecated-Features&quot;&gt;不推荐使用的功能&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5741a81d36ae80d4f66c3d238560cf727f6d2221" translate="yes" xml:space="preserve">
          <source>Do not warn about usage of functions (see &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;Function Attributes&lt;/a&gt;) declared with &lt;code&gt;warning&lt;/code&gt; attribute. By default, this warning is enabled.</source>
          <target state="translated">不要警告使用 &lt;code&gt;warning&lt;/code&gt; 属性声明的函数（请参见&lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;Function Attributes&lt;/a&gt;）。默认情况下，此警告处于启用状态。</target>
        </trans-unit>
        <trans-unit id="569882ee6769c783a7c673619d2b596b07ae7884" translate="yes" xml:space="preserve">
          <source>Do not warn about uses of &lt;code&gt;std::initializer_list&lt;/code&gt; that are likely to result in dangling pointers. Since the underlying array for an &lt;code&gt;initializer_list&lt;/code&gt; is handled like a normal C++ temporary object, it is easy to inadvertently keep a pointer to the array past the end of the array&amp;rsquo;s lifetime. For example:</source>
          <target state="translated">不要警告可能会导致指针悬空的 &lt;code&gt;std::initializer_list&lt;/code&gt; 使用。由于 &lt;code&gt;initializer_list&lt;/code&gt; 的基础数组像普通的C ++临时对象一样进行处理，因此很容易在数组生命周期的末尾无意间保持指向该数组的指针。例如：</target>
        </trans-unit>
        <trans-unit id="e7879bd2657e4473a1347324fd997f9cdc3d041e" translate="yes" xml:space="preserve">
          <source>Do not warn about uses of functions (see &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;Function Attributes&lt;/a&gt;), variables (see &lt;a href=&quot;variable-attributes#Variable-Attributes&quot;&gt;Variable Attributes&lt;/a&gt;), and types (see &lt;a href=&quot;type-attributes#Type-Attributes&quot;&gt;Type Attributes&lt;/a&gt;) marked as deprecated by using the &lt;code&gt;deprecated&lt;/code&gt; attribute.</source>
          <target state="translated">时不发出警告的功能用途（见&lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;函数属性&lt;/a&gt;），变量（见&lt;a href=&quot;variable-attributes#Variable-Attributes&quot;&gt;变量属性&lt;/a&gt;）和类型（见&lt;a href=&quot;type-attributes#Type-Attributes&quot;&gt;类型属性&lt;/a&gt;）标记的使用为废弃 &lt;code&gt;deprecated&lt;/code&gt; 属性。</target>
        </trans-unit>
        <trans-unit id="e33f23c639b6d41c2c3035fff8afee57ebc3fce6" translate="yes" xml:space="preserve">
          <source>Do not warn for calls to bounded string manipulation functions such as &lt;code&gt;strncat&lt;/code&gt;, &lt;code&gt;strncpy&lt;/code&gt;, and &lt;code&gt;stpncpy&lt;/code&gt; that may either truncate the copied string or leave the destination unchanged.</source>
          <target state="translated">不要警告对可能会截断复制的字符串或使目标保持不变的限制字符串操作函数（例如 &lt;code&gt;strncat&lt;/code&gt; ， &lt;code&gt;strncpy&lt;/code&gt; 和 &lt;code&gt;stpncpy&lt;/code&gt; )的调用。</target>
        </trans-unit>
        <trans-unit id="b2ba657c651e9df665e818d59934ea7360d21f9d" translate="yes" xml:space="preserve">
          <source>Do not warn for conversions between &lt;code&gt;NULL&lt;/code&gt; and non-pointer types.</source>
          <target state="translated">不要警告在 &lt;code&gt;NULL&lt;/code&gt; 和非指针类型之间进行转换。</target>
        </trans-unit>
        <trans-unit id="f3c7034f14450f34ae37fb2f3dc3f8309df1df4c" translate="yes" xml:space="preserve">
          <source>Do not warn if a caller of a function marked with attribute &lt;code&gt;warn_unused_result&lt;/code&gt; (see &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;Function Attributes&lt;/a&gt;) does not use its return value. The default is</source>
          <target state="translated">如果标记有属性 &lt;code&gt;warn_unused_result&lt;/code&gt; 的函数的调用者（请参见&lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;Function Attributes&lt;/a&gt;）未使用其返回值，则不要发出警告。默认是</target>
        </trans-unit>
        <trans-unit id="fb9755e0253eb1306289d1103fce8726c90aae41" translate="yes" xml:space="preserve">
          <source>Do not warn if a class type has a base or a field whose type uses the anonymous namespace or depends on a type with no linkage. If a type A depends on a type B with no or internal linkage, defining it in multiple translation units would be an ODR violation because the meaning of B is different in each translation unit. If A only appears in a single translation unit, the best way to silence the warning is to give it internal linkage by putting it in an anonymous namespace as well. The compiler doesn&amp;rsquo;t give this warning for types defined in the main .C file, as those are unlikely to have multiple definitions.</source>
          <target state="translated">如果类类型具有使用匿名名称空间的基本类型或字段或依赖于没有链接的类型，则不要发出警告。如果类型A依赖于没有或具有内部链接的类型B，则在多个翻译单元中对其进行定义将违反ODR，因为B的含义在每个翻译单元中都不同。如果A仅出现在单个翻译单元中，则使警告静音的最佳方法是通过将其也置于匿名名称空间中来使其内部链接。编译器不会针对主.C文件中定义的类型发出此警告，因为这些类型不太可能具有多个定义。</target>
        </trans-unit>
        <trans-unit id="e5c44e9dcc0d0d2cc0d4fcbe48e1b3887ed71621" translate="yes" xml:space="preserve">
          <source>Do not warn if a multicharacter constant (&amp;lsquo;</source>
          <target state="translated">如果多字符常量（'</target>
        </trans-unit>
        <trans-unit id="443e1e0e70a448710aa93209ae6dd62fb7533f28" translate="yes" xml:space="preserve">
          <source>Do not warn if a pointer is compared with a zero character constant. This usually means that the pointer was meant to be dereferenced. For example:</source>
          <target state="translated">如果指针与一个零字符常量进行比较,不要发出警告。这通常意味着该指针是要被取消引用的。例如</target>
        </trans-unit>
        <trans-unit id="474d345e0c92820e39935346f3f6f08e315a2c69" translate="yes" xml:space="preserve">
          <source>Do not warn if a priority from 0 to 100 is used for constructor or destructor. The use of constructor and destructor attributes allow you to assign a priority to the constructor/destructor to control its order of execution before &lt;code&gt;main&lt;/code&gt; is called or after it returns. The priority values must be greater than 100 as the compiler reserves priority values between 0&amp;ndash;100 for the implementation.</source>
          <target state="translated">如果构造函数或析构函数的优先级为0到100，则不发出警告。使用构造函数和析构函数属性可让您为构造函数/析构函数分配优先级，以控制其在调用 &lt;code&gt;main&lt;/code&gt; 或返回main之后的执行顺序。优先级值必须大于100，因为编译器为实现保留了0-100之间的优先级值。</target>
        </trans-unit>
        <trans-unit id="732973795e8a7e32daa52d09fac5902c9d2be92b" translate="yes" xml:space="preserve">
          <source>Do not warn if a property for an Objective-C object has no assign semantics specified.</source>
          <target state="translated">如果一个Objective-C对象的属性没有指定赋值语义,不要发出警告。</target>
        </trans-unit>
        <trans-unit id="9a797405ed28a43b7b96611721ab2d6938e13b2f" translate="yes" xml:space="preserve">
          <source>Do not warn if an initialized field with side effects is overridden when using designated initializers (see &lt;a href=&quot;designated-inits#Designated-Inits&quot;&gt;Designated Initializers&lt;/a&gt;). This warning is enabled by default.</source>
          <target state="translated">使用指定的初始化程序时，请不要警告是否会覆盖带有副作用的初始化字段（请参阅&amp;ldquo;&lt;a href=&quot;designated-inits#Designated-Inits&quot;&gt;指定的初始化程序&amp;rdquo;&lt;/a&gt;）。默认情况下启用此警告。</target>
        </trans-unit>
        <trans-unit id="c5958651457da08de9e91cd3ae0fc547368da59b" translate="yes" xml:space="preserve">
          <source>Do not warn if an unexpected &lt;code&gt;__attribute__&lt;/code&gt; is used, such as unrecognized attributes, function attributes applied to variables, etc. This does not stop errors for incorrect use of supported attributes.</source>
          <target state="translated">如果使用了意外的 &lt;code&gt;__attribute__&lt;/code&gt; （例如，无法识别的属性，应用于变量的函数属性等），则不会发出警告。这不会因错误使用支持的属性而停止错误。</target>
        </trans-unit>
        <trans-unit id="776e98d1dffbde23efe71be5b00aaf8afcebd19f" translate="yes" xml:space="preserve">
          <source>Do not warn if certain built-in macros are redefined. This suppresses warnings for redefinition of &lt;code&gt;__TIMESTAMP__&lt;/code&gt;, &lt;code&gt;__TIME__&lt;/code&gt;, &lt;code&gt;__DATE__&lt;/code&gt;, &lt;code&gt;__FILE__&lt;/code&gt;, and &lt;code&gt;__BASE_FILE__&lt;/code&gt;.</source>
          <target state="translated">如果某些内置宏被重新定义，则不发出警告。这抑制了警告，重新定义 &lt;code&gt;__TIMESTAMP__&lt;/code&gt; ， &lt;code&gt;__TIME__&lt;/code&gt; ， &lt;code&gt;__DATE__&lt;/code&gt; ， &lt;code&gt;__FILE__&lt;/code&gt; 和 &lt;code&gt;__BASE_FILE__&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a5961961b151110f8171f9f71097fa474a97d41f" translate="yes" xml:space="preserve">
          <source>Do not warn if type qualifiers on arrays which are pointer targets are being discarded. Typically, the compiler warns if a &lt;code&gt;const int (*)[]&lt;/code&gt; variable is passed to a function that takes a &lt;code&gt;int (*)[]&lt;/code&gt; parameter. This option can be used to suppress such a warning.</source>
          <target state="translated">不要警告是否舍弃了作为指针目标的数组上的类型限定符。通常，如果将 &lt;code&gt;const int (*)[]&lt;/code&gt; 变量传递给采用 &lt;code&gt;int (*)[]&lt;/code&gt; 参数的函数，则编译器会发出警告。此选项可用于禁止显示此类警告。</target>
        </trans-unit>
        <trans-unit id="4f6ac391aa1f66b1759edea5545511d490e350b4" translate="yes" xml:space="preserve">
          <source>Do not warn if type qualifiers on pointers are being discarded. Typically, the compiler warns if a &lt;code&gt;const char *&lt;/code&gt; variable is passed to a function that takes a &lt;code&gt;char *&lt;/code&gt; parameter. This option can be used to suppress such a warning.</source>
          <target state="translated">不要警告是否丢弃了指针上的类型限定符。通常，如果将 &lt;code&gt;const char *&lt;/code&gt; 变量传递给采用 &lt;code&gt;char *&lt;/code&gt; 参数的函数，则编译器会发出警告。此选项可用于禁止显示此类警告。</target>
        </trans-unit>
        <trans-unit id="2237d0ea4af513f919bfca5807318b7adb31ba01" translate="yes" xml:space="preserve">
          <source>Do not warn on suspicious constructs involving reverse scalar storage order.</source>
          <target state="translated">不要对涉及反向标量存储顺序的可疑构造发出警告。</target>
        </trans-unit>
        <trans-unit id="dbb582054a4578d09382786263898193b0ff21b0" translate="yes" xml:space="preserve">
          <source>Do not warn upon questionable usage of the macros used to handle variable arguments like &lt;code&gt;va_start&lt;/code&gt;. These warnings are enabled by default.</source>
          <target state="translated">不要警告用于处理可变参数（例如 &lt;code&gt;va_start&lt;/code&gt; )的宏的可疑用法。这些警告默认情况下处于启用状态。</target>
        </trans-unit>
        <trans-unit id="b084ddd7e0fe08b48906115755ffa4e3da32fe0c" translate="yes" xml:space="preserve">
          <source>Do not warn when HSAIL cannot be emitted for the compiled function or OpenMP construct. These warnings are enabled by default.</source>
          <target state="translated">当编译后的函数或OpenMP构造不能发出HSAIL时,不要发出警告。默认情况下,这些警告是启用的。</target>
        </trans-unit>
        <trans-unit id="7781876bcee57ab05b4c1b6a1db698152f3d5c11" translate="yes" xml:space="preserve">
          <source>Do not warn when a &lt;code&gt;switch&lt;/code&gt; statement contains statements between the controlling expression and the first case label, which will never be executed. For example:</source>
          <target state="translated">当 &lt;code&gt;switch&lt;/code&gt; 语句包含在控制表达式和第一个case标签之间的语句（永远不会执行）时，请勿发出警告。例如：</target>
        </trans-unit>
        <trans-unit id="28680d2e20ffb7926eea11f38e1b6b85ce89c733" translate="yes" xml:space="preserve">
          <source>Do not warn when a &lt;code&gt;switch&lt;/code&gt; statement has an index of boolean type and the case values are outside the range of a boolean type. It is possible to suppress this warning by casting the controlling expression to a type other than &lt;code&gt;bool&lt;/code&gt;. For example:</source>
          <target state="translated">当 &lt;code&gt;switch&lt;/code&gt; 语句具有布尔类型的索引并且大小写值超出布尔类型的范围时，请勿发出警告。通过将控制表达式强制转换为 &lt;code&gt;bool&lt;/code&gt; 以外的其他类型，可以抑制此警告。例如：</target>
        </trans-unit>
        <trans-unit id="9af5475a41b51138661971a42f878b92d42b232b" translate="yes" xml:space="preserve">
          <source>Do not warn when a conversion function converts an object to the same type, to a base class of that type, or to void; such a conversion function will never be called.</source>
          <target state="translated">当一个转换函数将一个对象转换为同一类型,转换为该类型的基类,或者转换为void时,不要发出警告;这样的转换函数永远不会被调用。</target>
        </trans-unit>
        <trans-unit id="00c13e36c06e819c05d426233228bd8a2938fb6e" translate="yes" xml:space="preserve">
          <source>Do not warn when a string or character literal is followed by a ud-suffix which does not begin with an underscore. As a conforming extension, GCC treats such suffixes as separate preprocessing tokens in order to maintain backwards compatibility with code that uses formatting macros from &lt;code&gt;&amp;lt;inttypes.h&amp;gt;&lt;/code&gt;. For example:</source>
          <target state="translated">当字符串或字符文字后跟不是以下划线开头的ud后缀时，请勿发出警告。作为一致的扩展，GCC将这些后缀视为单独的预处理令牌，以保持与使用 &lt;code&gt;&amp;lt;inttypes.h&amp;gt;&lt;/code&gt; 格式宏的代码的向后兼容性。例如：</target>
        </trans-unit>
        <trans-unit id="505f6f0a22dd44c4b12ed8d2e6a399fe3806c159" translate="yes" xml:space="preserve">
          <source>Do not warn when attempting to free an object that was not allocated on the heap.</source>
          <target state="translated">当试图释放一个没有在堆上分配的对象时,不要发出警告。</target>
        </trans-unit>
        <trans-unit id="0eea2eb346314f258d9bd4887c4a7d0ac495ba36" translate="yes" xml:space="preserve">
          <source>Do not warn when deleting a pointer to incomplete type, which may cause undefined behavior at runtime. This warning is enabled by default.</source>
          <target state="translated">当删除指向不完整类型的指针时,不要发出警告,这可能会在运行时引起未定义的行为。默认情况下,这个警告是启用的。</target>
        </trans-unit>
        <trans-unit id="94889f68926578d446953d9dc1636114cf6715d6" translate="yes" xml:space="preserve">
          <source>Do not warn when the &lt;code&gt;sizeof&lt;/code&gt; operator is applied to a parameter that is declared as an array in a function definition. This warning is enabled by default for C and C++ programs.</source>
          <target state="translated">当 &lt;code&gt;sizeof&lt;/code&gt; 运算符应用于在函数定义中声明为数组的参数时，请勿发出警告。默认情况下，C和C ++程序启用此警告。</target>
        </trans-unit>
        <trans-unit id="d665894bec0cb8c7c615758edc8127e2b609bfec" translate="yes" xml:space="preserve">
          <source>Do not warn when the address of packed member of struct or union is taken, which usually results in an unaligned pointer value. This is enabled by default.</source>
          <target state="translated">当结构或联合体的打包成员的地址被取走时,不要发出警告,因为这通常会导致一个未对齐的指针值。这在默认情况下是启用的。</target>
        </trans-unit>
        <trans-unit id="b41e5f71b800c0d75e8bc4c789587d50634e7b35" translate="yes" xml:space="preserve">
          <source>Do not warn when there is a conversion between pointers that have incompatible types. This warning is for cases not covered by</source>
          <target state="translated">当有不兼容类型的指针之间发生转换时,不要发出警告。这个警告是针对</target>
        </trans-unit>
        <trans-unit id="7288e67492dfae2c91a3de07cd384be7cd59dcec" translate="yes" xml:space="preserve">
          <source>Do not warn whenever a local variable shadows an instance variable in an Objective-C method.</source>
          <target state="translated">当一个局部变量在Objective-C方法中影射一个实例变量时,不要发出警告。</target>
        </trans-unit>
        <trans-unit id="a828e7021a3bac6b8a79dcdabca3402745cfbb45" translate="yes" xml:space="preserve">
          <source>Do not warn whenever an &lt;code&gt;#else&lt;/code&gt; or an &lt;code&gt;#endif&lt;/code&gt; are followed by text. This sometimes happens in older programs with code of the form</source>
          <target state="translated">当 &lt;code&gt;#else&lt;/code&gt; 或 &lt;code&gt;#endif&lt;/code&gt; 后跟文本时，请勿发出警告。有时在使用以下形式的代码的旧程序中会发生这种情况</target>
        </trans-unit>
        <trans-unit id="12e3a14254e97e0a14b8cdd90a112ee9ef9f78f5" translate="yes" xml:space="preserve">
          <source>Do nothing. Code written for the Borland model works fine, but each translation unit contains instances of each of the templates it uses. The duplicate instances will be discarded by the linker, but in a large program, this can lead to an unacceptable amount of code duplication in object files or shared libraries.</source>
          <target state="translated">什么都不做。为Borland模型编写的代码可以正常工作,但每个翻译单元都包含它使用的每个模板的实例。重复的实例将被链接器丢弃,但在一个大型程序中,这可能会导致对象文件或共享库中出现不可接受的代码重复。</target>
        </trans-unit>
        <trans-unit id="36f05070ba1aa8ebb373ea5159cf72f76e048943" translate="yes" xml:space="preserve">
          <source>Do or don&amp;rsquo;t use hardware floating-point divide and square root instructions. This requires the F or D extensions for floating-point registers. The default is to use them if the specified architecture has these instructions.</source>
          <target state="translated">是否使用硬件浮点除法和平方根指令。这需要浮点寄存器的F或D扩展名。如果指定的体系结构具有这些说明，则默认值为使用它们。</target>
        </trans-unit>
        <trans-unit id="57a1444191ca5bb7028d2e6eff0344f434565ffa" translate="yes" xml:space="preserve">
          <source>Do or don&amp;rsquo;t use hardware instructions for integer division. This requires the M extension. The default is to use them if the specified architecture has these instructions.</source>
          <target state="translated">是否使用硬件指令进行整数除法。这需要M扩展名。如果指定的体系结构具有这些说明，则默认值为使用它们。</target>
        </trans-unit>
        <trans-unit id="ddefab05090bb15a5eac377b4c14800d5252c830" translate="yes" xml:space="preserve">
          <source>Do or don&amp;rsquo;t use smaller but slower prologue and epilogue code that uses library function calls. The default is to use fast inline prologues and epilogues.</source>
          <target state="translated">是否使用较小但较慢的使用库函数调用的序言和结尾代码。默认设置是使用快速内联序言和结语。</target>
        </trans-unit>
        <trans-unit id="96ba75d321eadfeb26cc86353736e08f35e773ab" translate="yes" xml:space="preserve">
          <source>Do output those jump instructions, on the assumption that the GNU assembler is being used.</source>
          <target state="translated">做输出这些跳转指令,前提是使用GNU汇编器。</target>
        </trans-unit>
        <trans-unit id="4d204a72f0077f832ff1f2432253a2d1ae4c41b8" translate="yes" xml:space="preserve">
          <source>Do stack checking using information placed into L1 scratchpad memory by the uClinux kernel.</source>
          <target state="translated">使用uClinux内核放入L1 scratchpad内存的信息进行堆栈检查。</target>
        </trans-unit>
        <trans-unit id="63c71786896a4df72c3bdfbb021ed8f95f3c7268" translate="yes" xml:space="preserve">
          <source>Do use the bit-field instructions. The</source>
          <target state="translated">做使用位场指令。的</target>
        </trans-unit>
        <trans-unit id="73b333e917a724e80117a86ff858d4e12be1cb13" translate="yes" xml:space="preserve">
          <source>Do warn about implicit conversions from arithmetic operations even when conversion of the operands to the same type cannot change their values. This affects warnings from</source>
          <target state="translated">警告算术运算中的隐式转换,即使操作数转换为相同类型也不能改变其值。这将影响来自</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
