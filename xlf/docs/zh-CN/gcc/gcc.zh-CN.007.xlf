<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="gcc">
    <body>
      <group id="gcc">
        <trans-unit id="73691e44c058afa420e3a5b298659ae385093f25" translate="yes" xml:space="preserve">
          <source>Conform to the language syntax of Objective-C 1.0, the language recognized by GCC 4.0. This only affects the Objective-C additions to the C/C++ language; it does not affect conformance to C/C++ standards, which is controlled by the separate C/C++ dialect option flags. When this option is used with the Objective-C or Objective-C++ compiler, any Objective-C syntax that is not recognized by GCC 4.0 is rejected. This is useful if you need to make sure that your Objective-C code can be compiled with older versions of GCC.</source>
          <target state="translated">符合Objective-C 1.0的语言语法,即GCC 4.0认可的语言。这只影响Objective-C对C/C++语言的添加,它不影响对C/C++标准的符合性,这是由单独的C/C++方言选项标志控制的。当这个选项与Objective-C或Objective-C++编译器一起使用时,任何不被GCC 4.0识别的Objective-C语法都会被拒绝。如果你需要确保你的Objective-C代码可以用旧版本的GCC编译,这个选项就很有用。</target>
        </trans-unit>
        <trans-unit id="276327c90b14e9bc39dc498e6536c698c6fb7874" translate="yes" xml:space="preserve">
          <source>Conformance to the same ABI and the same behavior of implementation-defined features are both relevant for compatibility.</source>
          <target state="translated">遵循相同的ABI和实现定义的特性的相同行为都与兼容性有关。</target>
        </trans-unit>
        <trans-unit id="af74bda50719fa1b3103b3627d3eb38149eb7313" translate="yes" xml:space="preserve">
          <source>Consider (as in C99 subclause 6.7.5 paragraph 4) a declaration &lt;code&gt;T
D1&lt;/code&gt;, where &lt;code&gt;T&lt;/code&gt; contains declaration specifiers that specify a type &lt;var&gt;Type&lt;/var&gt; (such as &lt;code&gt;int&lt;/code&gt;) and &lt;code&gt;D1&lt;/code&gt; is a declarator that contains an identifier &lt;var&gt;ident&lt;/var&gt;. The type specified for &lt;var&gt;ident&lt;/var&gt; for derived declarators whose type does not include an attribute specifier is as in the ISO C standard.</source>
          <target state="translated">考虑一个声明 &lt;code&gt;T D1&lt;/code&gt; （如C99中第6.7.5节第4款所述），其中 &lt;code&gt;T&lt;/code&gt; 包含指定类型 &lt;var&gt;Type&lt;/var&gt; 的声明说明符（例如 &lt;code&gt;int&lt;/code&gt; ）， &lt;code&gt;D1&lt;/code&gt; 是包含标识符 &lt;var&gt;ident&lt;/var&gt; 的声明符。为派生声明符的 &lt;var&gt;ident&lt;/var&gt; 指定的类型（其类型不包含属性说明符）与ISO C标准相同。</target>
        </trans-unit>
        <trans-unit id="9b667c089da7e561b4d6f55e12e93a78181226e5" translate="yes" xml:space="preserve">
          <source>Consider all &lt;code&gt;static&lt;/code&gt; functions called once for inlining into their caller even if they are not marked &lt;code&gt;inline&lt;/code&gt;. If a call to a given function is integrated, then the function is not output as assembler code in its own right.</source>
          <target state="translated">考虑所有一次调用的 &lt;code&gt;static&lt;/code&gt; 函数以内联到其调用方中，即使它们未标记为 &lt;code&gt;inline&lt;/code&gt; 。如果集成了对给定函数的调用，则该函数本身不会作为汇编代码输出。</target>
        </trans-unit>
        <trans-unit id="35a3be8ed672f20c07ec027046430f867cf3e587" translate="yes" xml:space="preserve">
          <source>Consider all functions for inlining, even if they are not declared inline. The compiler heuristically decides which functions are worth integrating in this way.</source>
          <target state="translated">考虑所有函数进行内联,即使它们没有被声明为内联。编译器以启发式的方式决定哪些函数值得以这种方式集成。</target>
        </trans-unit>
        <trans-unit id="7b85816a30be72db5578a7db246b88f298f1a216" translate="yes" xml:space="preserve">
          <source>Consider that instructions that may throw exceptions but don&amp;rsquo;t otherwise contribute to the execution of the program can be optimized away. This option is enabled by default for the Ada front end, as permitted by the Ada language specification. Optimization passes that cause dead exceptions to be removed are enabled independently at different optimization levels.</source>
          <target state="translated">考虑到可能会抛出异常但不会对程序执行有贡献的指令可以被优化掉。默认情况下，Ada前端会启用此选项，这是Ada语言规范所允许的。可在不同的优化级别上独立启用导致清除异常的优化过程。</target>
        </trans-unit>
        <trans-unit id="56b80af072fa83ee95788ec24e46c4595598d634" translate="yes" xml:space="preserve">
          <source>Consider the following example,</source>
          <target state="translated">请看下面的例子。</target>
        </trans-unit>
        <trans-unit id="a59af01b7f010c19c9dde4af8032ceeec0657a9d" translate="yes" xml:space="preserve">
          <source>Consider type &lt;code&gt;int&lt;/code&gt; to be 16 bits wide, like &lt;code&gt;short int&lt;/code&gt;. Additionally, parameters passed on the stack are also aligned to a 16-bit boundary even on targets whose API mandates promotion to 32-bit.</source>
          <target state="translated">考虑 &lt;code&gt;int&lt;/code&gt; 类型为16位宽，例如 &lt;code&gt;short int&lt;/code&gt; 。此外，即使在其API要求提升为32位的目标上，在堆栈上传递的参数也与16位边界对齐。</target>
        </trans-unit>
        <trans-unit id="14249be6954dd348580bb1e0a79129f5f1192211" translate="yes" xml:space="preserve">
          <source>Constant 255.</source>
          <target state="translated">常数255。</target>
        </trans-unit>
        <trans-unit id="7c36129cdf24a616a089dfb7d284688c9138762e" translate="yes" xml:space="preserve">
          <source>Constant 65535.</source>
          <target state="translated">常数65535。</target>
        </trans-unit>
        <trans-unit id="7ebcf06cc87a00b632c948fbc204e56f0827cd01" translate="yes" xml:space="preserve">
          <source>Constant &lt;var&gt;n&lt;/var&gt;, where &lt;var&gt;n&lt;/var&gt; is a single-digit constant in the range 0 to 4.</source>
          <target state="translated">常数 &lt;var&gt;n&lt;/var&gt; ，其中 &lt;var&gt;n&lt;/var&gt; 是0到4范围内的个位数常数。</target>
        </trans-unit>
        <trans-unit id="37323b42fe56e6f04c3dbbef4d9fbb95b7fc380b" translate="yes" xml:space="preserve">
          <source>Constant for arithmetic/logical operations. This is like &lt;code&gt;i&lt;/code&gt;, except that for position independent code, no symbols / expressions needing relocations are allowed.</source>
          <target state="translated">用于算术/逻辑运算的常数。类似于 &lt;code&gt;i&lt;/code&gt; ，除了对于位置无关的代码，不允许需要重定位的符号/表达式。</target>
        </trans-unit>
        <trans-unit id="c7644d686263ca6ceaeace041caa08f8c6cf68aa" translate="yes" xml:space="preserve">
          <source>Constant greater than -1, less than 64</source>
          <target state="translated">常量大于-1,小于64</target>
        </trans-unit>
        <trans-unit id="09c49e4a44186e5736b6b3d234fbcdd1b306818b" translate="yes" xml:space="preserve">
          <source>Constant greater than -64, less than 1</source>
          <target state="translated">大于-64,小于1的常数</target>
        </trans-unit>
        <trans-unit id="629c52a6147c82fa4c525c23e4812fa96465cd8a" translate="yes" xml:space="preserve">
          <source>Constant integer -1</source>
          <target state="translated">常数整数-1</target>
        </trans-unit>
        <trans-unit id="721c7841ba7521d9d4cd87f007487a95dabae8a8" translate="yes" xml:space="preserve">
          <source>Constant integer 0</source>
          <target state="translated">常数整数0</target>
        </trans-unit>
        <trans-unit id="4c0d77dad954cfa376cbed314919134fe483d92e" translate="yes" xml:space="preserve">
          <source>Constant integer 1</source>
          <target state="translated">常数整数1</target>
        </trans-unit>
        <trans-unit id="a0be78fc92c33b25cda27188d52e852922b4e406" translate="yes" xml:space="preserve">
          <source>Constant integer 2</source>
          <target state="translated">常数整数2</target>
        </trans-unit>
        <trans-unit id="202072b2675376ab5d42618242f422abd21566ab" translate="yes" xml:space="preserve">
          <source>Constant integer 8, 16, or 24</source>
          <target state="translated">常数整数8,16,或24。</target>
        </trans-unit>
        <trans-unit id="5bf3f3ad783e97cd6b61e26de5af436d02b8dbc8" translate="yes" xml:space="preserve">
          <source>Constant integer with a value of 0x7fffffff.</source>
          <target state="translated">常数整数,值为0x7fffffff。</target>
        </trans-unit>
        <trans-unit id="4b2e9b490d5b5f4c17de70d9c9fdf5aa2b4b1450" translate="yes" xml:space="preserve">
          <source>Constant larger than 31</source>
          <target state="translated">大于31的常数</target>
        </trans-unit>
        <trans-unit id="47f3d5d59a235c75b0766f99a2edf9666aa348c9" translate="yes" xml:space="preserve">
          <source>Constant that fits in 8 bits</source>
          <target state="translated">适合8位的常数</target>
        </trans-unit>
        <trans-unit id="719b7b797492e1507d09c13adb21a02c3fe64069" translate="yes" xml:space="preserve">
          <source>Constant whose negation is a signed 16-bit constant</source>
          <target state="translated">常量的否定值是一个有符号的16位常量。</target>
        </trans-unit>
        <trans-unit id="180e678224087bf03d6c9c2f7ac11f4d9834fa9a" translate="yes" xml:space="preserve">
          <source>Constant zero</source>
          <target state="translated">恒定零度</target>
        </trans-unit>
        <trans-unit id="a9100a8537fb85e4bf388bedae7d5d58f76e7b6e" translate="yes" xml:space="preserve">
          <source>Constant?</source>
          <target state="translated">Constant?</target>
        </trans-unit>
        <trans-unit id="7efcb4b4f328cdb249f8926cb267f61ac8015a9d" translate="yes" xml:space="preserve">
          <source>Constraints for &lt;code&gt;asm&lt;/code&gt; operands</source>
          <target state="translated">&lt;code&gt;asm&lt;/code&gt; 操作数的约束</target>
        </trans-unit>
        <trans-unit id="3e3f7e5411ee0f1fda2ac40b39097fae6a9abb77" translate="yes" xml:space="preserve">
          <source>Constructs webs as commonly used for register allocation purposes and assign each web individual pseudo register. This allows the register allocation pass to operate on pseudos directly, but also strengthens several other optimization passes, such as CSE, loop optimizer and trivial dead code remover. It can, however, make debugging impossible, since variables no longer stay in a &amp;ldquo;home register&amp;rdquo;.</source>
          <target state="translated">构造通常用于寄存器分配目的的网络，并为每个网络分配单独的伪寄存器。这使寄存器分配过程可以直接对伪操作进行操作，还可以增强其他一些优化过程，例如CSE，循环优化器和琐碎的死代码清除器。但是，由于变量不再保留在&amp;ldquo;本地寄存器&amp;rdquo;中，因此它可能使调试变得不可能。</target>
        </trans-unit>
        <trans-unit id="d4f501afecf0b8b5f3993371f4f6074a753dc0e6" translate="yes" xml:space="preserve">
          <source>Contributors to GCC</source>
          <target state="translated">海合会捐款者</target>
        </trans-unit>
        <trans-unit id="4648a291e89516ba0f4f56b93d6fdb1d01cfd9c4" translate="yes" xml:space="preserve">
          <source>Control GCC&amp;rsquo;s optimizations to produce output suitable for live-patching.</source>
          <target state="translated">控制GCC的优化以产生适合实时修补的输出。</target>
        </trans-unit>
        <trans-unit id="bcc7b6b362569344fe25ab394774bd26a1bf6f6a" translate="yes" xml:space="preserve">
          <source>Control how GCC aligns variables. Supported values for &lt;var&gt;type&lt;/var&gt; are &amp;lsquo;</source>
          <target state="translated">控制GCC如何对齐变量。支持的 &lt;var&gt;type&lt;/var&gt; 值为&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="7e88213c055c1aca5596a30dea879bf4859e75f5" translate="yes" xml:space="preserve">
          <source>Control how many registers are used to pass integer arguments. By default, no registers are used to pass arguments, and at most 3 registers can be used. You can control this behavior for a specific function by using the function attribute &lt;code&gt;regparm&lt;/code&gt;. See &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;Function Attributes&lt;/a&gt;.</source>
          <target state="translated">控制使用多少个寄存器传递整数参数。默认情况下，不使用任何寄存器来传递参数，并且最多可以使用3个寄存器。您可以使用功能属性 &lt;code&gt;regparm&lt;/code&gt; 来控制特定功能的此行为。请参阅&lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;函数属性&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ae31e36dd1f96d1b47c3f78f649f25722c9f1d7b" translate="yes" xml:space="preserve">
          <source>Control if warning triggered by the &lt;code&gt;warn_if_not_aligned&lt;/code&gt; attribute should be issued. This is enabled by default. Use</source>
          <target state="translated">控制是否发出由 &lt;code&gt;warn_if_not_aligned&lt;/code&gt; 属性触发的警告。默认情况下启用。用</target>
        </trans-unit>
        <trans-unit id="a2f461ee948da2dba5ee60b9ffddb2967c79a05b" translate="yes" xml:space="preserve">
          <source>Control the IEEE compliance of floating-point comparisons, which affects the handling of cases where the result of a comparison is unordered. By default</source>
          <target state="translated">控制浮点比较的IEEE合规性,这将影响比较结果无序时的处理。默认情况下</target>
        </trans-unit>
        <trans-unit id="2afb7e07aedef4a32dbbca185426a76a2840c4b0" translate="yes" xml:space="preserve">
          <source>Control the dumping at various stages of inter-procedural analysis language tree to a file. The file name is generated by appending a switch specific suffix to the source file name, and the file is created in the same directory as the output file. The following dumps are possible:</source>
          <target state="translated">控制程序间分析语言树各阶段的转储到文件中。文件名通过在源文件名上附加开关专用后缀生成,文件与输出文件在同一目录下创建。可以进行以下转储。</target>
        </trans-unit>
        <trans-unit id="f18aaf944d2648faf5bedcbbdbf1ddd945fad607" translate="yes" xml:space="preserve">
          <source>Control the dumping at various stages of processing the intermediate language tree to a file. If the &amp;lsquo;</source>
          <target state="translated">在将中间语言树处理为文件的各个阶段，控制转储。如果&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="c0a71f6d1404f7b16378e5d31c9c7e2a41e97704" translate="yes" xml:space="preserve">
          <source>Control the dumping of language-specific information. The &lt;var&gt;options&lt;/var&gt; and &lt;var&gt;filename&lt;/var&gt; portions behave as described in the</source>
          <target state="translated">控制特定语言信息的转储。的 &lt;var&gt;options&lt;/var&gt; 和 &lt;var&gt;filename&lt;/var&gt; 作为在所描述的行为的部分</target>
        </trans-unit>
        <trans-unit id="d78b6d3fd867212c02526e9987edeed79105b1e7" translate="yes" xml:space="preserve">
          <source>Control the probability of the expression having the specified value. This parameter takes a percentage (i.e. 0 ... 100) as input.</source>
          <target state="translated">控制表达式具有指定值的概率。该参数采用百分比(即0 ...100)作为输入。</target>
        </trans-unit>
        <trans-unit id="3bc8404322e32343cc4763c8bd1ae2d2c9dab937" translate="yes" xml:space="preserve">
          <source>Control the verbosity of the dump file for the integrated register allocator. The default value is 5. If the value &lt;var&gt;n&lt;/var&gt; is greater or equal to 10, the dump output is sent to stderr using the same format as &lt;var&gt;n&lt;/var&gt; minus 10.</source>
          <target state="translated">控制集成寄存器分配器的转储文件的详细程度。默认值为5。如果值 &lt;var&gt;n&lt;/var&gt; 大于或等于10，则转储输出将使用与 &lt;var&gt;n&lt;/var&gt; 减10 相同的格式发送到stderr 。</target>
        </trans-unit>
        <trans-unit id="f9bae08f2081e939f273d8f52a1db45d82560f46" translate="yes" xml:space="preserve">
          <source>Control whether GCC aligns &lt;code&gt;double&lt;/code&gt;, &lt;code&gt;long double&lt;/code&gt;, and &lt;code&gt;long long&lt;/code&gt; variables on a two-word boundary or a one-word boundary. Aligning &lt;code&gt;double&lt;/code&gt; variables on a two-word boundary produces code that runs somewhat faster on a Pentium at the expense of more memory.</source>
          <target state="translated">控制GCC 在两字边界还是一字边界上对齐 &lt;code&gt;double&lt;/code&gt; ， &lt;code&gt;long double&lt;/code&gt; 和 &lt;code&gt;long long&lt;/code&gt; 变量。在两个单词的边界上对齐 &lt;code&gt;double&lt;/code&gt; 变量会产生在奔腾上运行速度更快的代码，但会占用更多内存。</target>
        </trans-unit>
        <trans-unit id="8f446d353bc1e77fdd352360a3275f518dfbc090" translate="yes" xml:space="preserve">
          <source>Control whether GCC aligns &lt;code&gt;int&lt;/code&gt;, &lt;code&gt;long&lt;/code&gt;, &lt;code&gt;long long&lt;/code&gt;, &lt;code&gt;float&lt;/code&gt;, &lt;code&gt;double&lt;/code&gt;, and &lt;code&gt;long double&lt;/code&gt; variables on a 32-bit boundary (</source>
          <target state="translated">控制GCC是否在32位边界上对齐 &lt;code&gt;int&lt;/code&gt; ， &lt;code&gt;long&lt;/code&gt; ， &lt;code&gt;long long&lt;/code&gt; ， &lt;code&gt;float&lt;/code&gt; ， &lt;code&gt;double&lt;/code&gt; 和 &lt;code&gt;long double&lt;/code&gt; 变量（</target>
        </trans-unit>
        <trans-unit id="75311304fc882ae2426d795d34cedb8140da086e" translate="yes" xml:space="preserve">
          <source>Control whether or not the compiler uses IEEE floating-point comparisons. These correctly handle the case where the result of a comparison is unordered.</source>
          <target state="translated">控制编译器是否使用IEEE浮点比较。这可以正确处理比较结果无序的情况。</target>
        </trans-unit>
        <trans-unit id="62bad428ae7c19b0490d45917456075bd42d88a6" translate="yes" xml:space="preserve">
          <source>Controlling header files and macro definitions. Also, getting dependency information for Make.</source>
          <target state="translated">控制头文件和宏定义。同时,获取Make的依赖信息。</target>
        </trans-unit>
        <trans-unit id="e99744632595e185715acaad17e041aa084fa9ba" translate="yes" xml:space="preserve">
          <source>Controlling how diagnostics should be formatted.</source>
          <target state="translated">控制诊断程序的格式。</target>
        </trans-unit>
        <trans-unit id="e7841aeb7ad7a7b2bbd17b2d58521eec5ba1a4f0" translate="yes" xml:space="preserve">
          <source>Controlling the kind of output: an executable, object files, assembler files, or preprocessed source.</source>
          <target state="translated">控制输出的种类:可执行文件、对象文件、汇编文件或预处理的源文件。</target>
        </trans-unit>
        <trans-unit id="c6ecef85f48d8878d76bfb7e0a0331e88e337d9a" translate="yes" xml:space="preserve">
          <source>Controlling the variant of C language compiled.</source>
          <target state="translated">控制C语言编译的变体。</target>
        </trans-unit>
        <trans-unit id="35f36b715e771eac424fea4a5652ad0db1feb811" translate="yes" xml:space="preserve">
          <source>Controls optimization dumps from various optimization passes. If the &amp;lsquo;</source>
          <target state="translated">控制来自各种优化过程的优化转储。如果&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="eae41d379a4cfbab73e910f93e19e6f3bad5167f" translate="yes" xml:space="preserve">
          <source>Controls whether TLS variables may be accessed with offsets from the TLS segment register (&lt;code&gt;%gs&lt;/code&gt; for 32-bit, &lt;code&gt;%fs&lt;/code&gt; for 64-bit), or whether the thread base pointer must be added. Whether or not this is valid depends on the operating system, and whether it maps the segment to cover the entire TLS area.</source>
          <target state="translated">控制是否可以使用TLS段寄存器的偏移量（32位为 &lt;code&gt;%gs&lt;/code&gt; ，64位为 &lt;code&gt;%fs&lt;/code&gt; ）来访问TLS变量，或者是否必须添加线程基指针。这是否有效取决于操作系统，以及它是否将段映射为覆盖整个TLS区域。</target>
        </trans-unit>
        <trans-unit id="eb9ef4e6ab162f6fc8a3bf857fc774382a954629" translate="yes" xml:space="preserve">
          <source>Conversely, &lt;code&gt;bar&lt;/code&gt; and the call to &lt;code&gt;foo&lt;/code&gt; in the fourth marked line are used in contexts that do depend on the type of &lt;code&gt;T&lt;/code&gt;, so they are only looked up at the point of instantiation, and you can provide declarations for them after declaring the template, but before instantiating it. In particular, if you instantiate &lt;code&gt;A::f&amp;lt;int&amp;gt;&lt;/code&gt;, the last line will call an overloaded &lt;code&gt;::foo(int)&lt;/code&gt; if one was provided, even if after the declaration of &lt;code&gt;struct A&lt;/code&gt;.</source>
          <target state="translated">相反，在第四条标记行中使用 &lt;code&gt;bar&lt;/code&gt; 和对 &lt;code&gt;foo&lt;/code&gt; 的调用在确实取决于 &lt;code&gt;T&lt;/code&gt; 类型的上下文中使用，因此它们仅在实例化点被查找，并且您可以在声明模板后为其提供声明，但是在实例化它之前。特别是，如果实例化 &lt;code&gt;A::f&amp;lt;int&amp;gt;&lt;/code&gt; ，即使提供了 &lt;code&gt;struct A&lt;/code&gt; 的声明，如果提供了最后一行，即使提供了一个，也将调用重载 &lt;code&gt;::foo(int)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1dbc54a6ca4a64275cd12138ea70589c4f463e73" translate="yes" xml:space="preserve">
          <source>Conversely, if the register is a call-clobbered register, making calls to functions that use standard ABI may lose contents of the variable. Such calls may be created by the compiler even if none are evident in the original program, for example when libgcc functions are used to make up for unavailable instructions.</source>
          <target state="translated">相反,如果寄存器是一个调用-clobbered寄存器,那么调用使用标准ABI的函数可能会丢失变量的内容。即使在原始程序中没有明显的调用,编译器也可能产生这样的调用,例如当libgcc函数被用来弥补不可用的指令时。</target>
        </trans-unit>
        <trans-unit id="ff7d2b7b709500e425e46256b872f1c524a8fe88" translate="yes" xml:space="preserve">
          <source>Conversely, when you include the same header file in a main source file that declares it as &amp;lsquo;</source>
          <target state="translated">相反，当您在主源文件中包含相同的头文件并将其声明为&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="f8292e36ff2425ba64b2fca8bba18ef8c5d24cbf" translate="yes" xml:space="preserve">
          <source>Conversion from double precision to single precision.</source>
          <target state="translated">从双精度转换为单精度。</target>
        </trans-unit>
        <trans-unit id="e8f87ba256340926897664cced7edc0ce8ec124d" translate="yes" xml:space="preserve">
          <source>Conversion from floating point to signed or unsigned integer types, with truncation towards zero.</source>
          <target state="translated">从浮点数转换为有符号或无符号整数类型,截断为零。</target>
        </trans-unit>
        <trans-unit id="e8ec2eea2629558824283e676ad9bac71b3d3e53" translate="yes" xml:space="preserve">
          <source>Conversion from signed or unsigned integer types to floating-point types.</source>
          <target state="translated">从有符号或无符号整数类型转换为浮点类型。</target>
        </trans-unit>
        <trans-unit id="416cd3e7b0ad0f46f99e977b880dc368db1cdff8" translate="yes" xml:space="preserve">
          <source>Conversion from single precision to double precision.</source>
          <target state="translated">从单精度转换为双精度。</target>
        </trans-unit>
        <trans-unit id="0fc5b8691f90f80b04961e22033d17dee1964933" translate="yes" xml:space="preserve">
          <source>Conversion from single-precision floating point to signed integer, rounding to the nearest integer and ties away from zero. This corresponds to the &lt;code&gt;__builtin_lroundf&lt;/code&gt; function when</source>
          <target state="translated">从单精度浮点到有符号整数的转换，四舍五入到最接近的整数并从零开始平移。这对应于 &lt;code&gt;__builtin_lroundf&lt;/code&gt; 函数，当</target>
        </trans-unit>
        <trans-unit id="536e910ea0e856f9ebf3793f69bec672bb95cd2c" translate="yes" xml:space="preserve">
          <source>Conversions by prototypes between fixed/floating-point values and vice versa. The absence of these prototypes when compiling with traditional C causes serious problems. This is a subset of the possible conversion warnings; for the full set use</source>
          <target state="translated">通过原型在定点/浮点值之间进行转换,反之亦然。在用传统C语言编译时,如果没有这些原型,会导致严重的问题。这是可能出现的转换警告的一个子集,完整的警告集请使用</target>
        </trans-unit>
        <trans-unit id="0912352accd4bfa1711e2febca470cb4f85bbc4c" translate="yes" xml:space="preserve">
          <source>Conversions:</source>
          <target state="translated">Conversions:</target>
        </trans-unit>
        <trans-unit id="baf1df2f34189a80f5d58da24bff382fe6f23f9c" translate="yes" xml:space="preserve">
          <source>Convert a 128-bit IEEE floating point value to &lt;code&gt;double&lt;/code&gt; using round to odd as the rounding mode.</source>
          <target state="translated">使用舍入到奇数作为舍入模式将128位IEEE浮点值转换为 &lt;code&gt;double&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c5f6051eea145ce2adef0c8027dd705cfcc7007e" translate="yes" xml:space="preserve">
          <source>Convert function return with &lt;var&gt;choice&lt;/var&gt;. The default is &amp;lsquo;</source>
          <target state="translated">用 &lt;var&gt;choice&lt;/var&gt; 转换函数返回。默认值为&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="454c8084600f90536a1954e8c20d848d81c823ed" translate="yes" xml:space="preserve">
          <source>Convert indirect call and jump with &lt;var&gt;choice&lt;/var&gt;. The default is &amp;lsquo;</source>
          <target state="translated">转换间接调用并按 &lt;var&gt;choice&lt;/var&gt; 跳转。默认值为&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="e6098cfb721df754afe96180a874c8cc3a1a8ded" translate="yes" xml:space="preserve">
          <source>Convert pair lower to single (&lt;code&gt;cvt.s.pl&lt;/code&gt;).</source>
          <target state="translated">将线对下转换为单（ &lt;code&gt;cvt.s.pl&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="52f3ab191bdd722d1394008161cded401dd949a0" translate="yes" xml:space="preserve">
          <source>Convert pair to paired single (&lt;code&gt;cvt.ps.s&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;cvt.ps.s&lt;/code&gt; 转换为成对的单（cvt.ps.s）。</target>
        </trans-unit>
        <trans-unit id="dbfe6d8e23313dd7f9196c8cdcc1c08381a49c43" translate="yes" xml:space="preserve">
          <source>Convert pair upper to single (&lt;code&gt;cvt.s.pu&lt;/code&gt;).</source>
          <target state="translated">将上对转换为单（ &lt;code&gt;cvt.s.pu&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="055bbf265923b2e5410a5e939d7297c0c9f2b211" translate="yes" xml:space="preserve">
          <source>Convert paired single to paired word (&lt;code&gt;cvt.pw.ps&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;cvt.pw.ps&lt;/code&gt; 对的单字转换为成对的字（cvt.pw.ps）。</target>
        </trans-unit>
        <trans-unit id="8b6b177ab15aa362100af3868aea344b1c1501b0" translate="yes" xml:space="preserve">
          <source>Convert paired word to paired single (&lt;code&gt;cvt.ps.pw&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;cvt.ps.pw&lt;/code&gt; 对的单词转换为成对的单（cvt.ps.pw）。</target>
        </trans-unit>
        <trans-unit id="3b04bf1a5e85023c3eed3599d79cb09164690ab2" translate="yes" xml:space="preserve">
          <source>Copy Assignment operators copy virtual bases twice</source>
          <target state="translated">复制赋值运算符将虚拟基地复制两次</target>
        </trans-unit>
        <trans-unit id="d5eae2b9f3ad758ce3ef79fc7015a6ffa9156eac" translate="yes" xml:space="preserve">
          <source>Copyright &amp;copy; 1988-2019 Free Software Foundation, Inc.</source>
          <target state="translated">版权所有&amp;copy;1988-2019自由软件基金会，Inc.</target>
        </trans-unit>
        <trans-unit id="aa5bc69c89234b43d34e0f300cbb8e8580610fdc" translate="yes" xml:space="preserve">
          <source>Core control register class.</source>
          <target state="translated">核心控制寄存器类。</target>
        </trans-unit>
        <trans-unit id="26ed802e7eb78ff2045b4541fe370087376fea5e" translate="yes" xml:space="preserve">
          <source>Cost to assume for a multiply instruction, with &amp;lsquo;</source>
          <target state="translated">乘法指令的假设成本，其中&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="c2ddd3bb796bfb895719a519a79aeec2d836822b" translate="yes" xml:space="preserve">
          <source>Cost, roughly measured as the cost of a single typical machine instruction, at which GCSE optimizations do not constrain the distance an expression can travel. This is currently supported only in the code hoisting pass. The lesser the cost, the more aggressive code hoisting is. Specifying 0 allows all expressions to travel unrestricted distances.</source>
          <target state="translated">成本,大致以单条典型机器指令的成本来衡量,在这个成本下,GCSE优化不会约束一个表达式可以走的距离。目前只在代码提升通中支持。成本越小,代码提升越激进。指定0可以让所有的表达式走过的距离不受限制。</target>
        </trans-unit>
        <trans-unit id="73a8cda37ae16987b1b76b7dd95bcc1d393efb64" translate="yes" xml:space="preserve">
          <source>Create a canonical counter for number of iterations in loops for which determining number of iterations requires complicated analysis. Later optimizations then may determine the number easily. Useful especially in connection with unrolling.</source>
          <target state="translated">在确定迭代次数需要复杂分析的循环中,为迭代次数创建一个规范的计数器。之后的优化可以很容易地确定迭代次数。特别是在展开循环时有用。</target>
        </trans-unit>
        <trans-unit id="abd404fec245486ddadc6af0006baee144b9f9b5" translate="yes" xml:space="preserve">
          <source>Create a shared object. It is recommended that</source>
          <target state="translated">创建一个共享对象。建议</target>
        </trans-unit>
        <trans-unit id="f1fd203b49f15a9115d31d7e6edbf2d093ba7de0" translate="yes" xml:space="preserve">
          <source>Create constant pools in the compiler instead of deferring it to the assembler. This option is the default and required for correct code generation on CK801 and CK802, and is optional on other processors.</source>
          <target state="translated">在编译器中创建常量池,而不是推迟到汇编器中。这个选项是默认的,在CK801和CK802上是正确生成代码所必需的,在其他处理器上是可选的。</target>
        </trans-unit>
        <trans-unit id="b23e0354f5ad5eff5e150918b9120e5576f9697a" translate="yes" xml:space="preserve">
          <source>Create long file names for included source files. For example, if the header file</source>
          <target state="translated">为包含的源文件创建长文件名。例如,如果头文件是</target>
        </trans-unit>
        <trans-unit id="e38ae255fe9e80cdce8fdaed0460f9c86fe6b8ba" translate="yes" xml:space="preserve">
          <source>Creates a new &amp;lsquo;</source>
          <target state="translated">创建一个新的&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="99dfbad76db4acc6eb91954940ce7b9993db8870" translate="yes" xml:space="preserve">
          <source>Creates an inter-thread happens-before constraint from the release (or stronger) semantic store to this acquire load. Can prevent hoisting of code to before the operation.</source>
          <target state="translated">从release(或更强的)语义存储中创建一个线程间 happens-before 约束到这个获取负载。可以防止将代码提升到操作之前。</target>
        </trans-unit>
        <trans-unit id="281a58c77cb45edf43cfdf897384199b4ab0a3ee" translate="yes" xml:space="preserve">
          <source>Creates an inter-thread happens-before constraint to acquire (or stronger) semantic loads that read from this release store. Can prevent sinking of code to after the operation.</source>
          <target state="translated">创建一个线程间 happens-before 约束,以获取(或更强的)语义负载,从这个释放存储中读取。可以防止代码下沉到操作后。</target>
        </trans-unit>
        <trans-unit id="67ae8f8fb8bba8ab92d3a89b17a6600fa05951e3" translate="yes" xml:space="preserve">
          <source>Creates and defines a register class. These register classes can be used by inline &lt;code&gt;asm&lt;/code&gt; constructs. &lt;var&gt;registers&lt;/var&gt; may be a single register, register range separated by ellipses, or comma-separated list of those. Example:</source>
          <target state="translated">创建并定义一个寄存器类。内联 &lt;code&gt;asm&lt;/code&gt; 构造可以使用这些寄存器类。 &lt;var&gt;registers&lt;/var&gt; 可以是单个寄存器，寄存器范围可以用椭圆分隔，也可以用逗号分隔。例：</target>
        </trans-unit>
        <trans-unit id="6e67e7d1e719647852b7fdbba193a58bb75ed395" translate="yes" xml:space="preserve">
          <source>Critical functions disable interrupts upon entry and restore the previous interrupt state upon exit. Critical functions cannot also have the &lt;code&gt;naked&lt;/code&gt;, &lt;code&gt;reentrant&lt;/code&gt; or &lt;code&gt;interrupt&lt;/code&gt; attributes.</source>
          <target state="translated">关键功能在进入时禁用中断，并在退出时恢复先前的中断状态。关键函数也不能具有 &lt;code&gt;naked&lt;/code&gt; 属性， &lt;code&gt;reentrant&lt;/code&gt; 属性或 &lt;code&gt;interrupt&lt;/code&gt; 属性。</target>
        </trans-unit>
        <trans-unit id="c3cb5c6e6c93496c35c07eb658977d77e8d997f1" translate="yes" xml:space="preserve">
          <source>Current argument is the name of a library or startup file of some sort. Search for that file in a standard list of directories and substitute the full name found. The current working directory is included in the list of directories scanned.</source>
          <target state="translated">当前参数是某个库或某种启动文件的名称。在标准目录列表中搜索该文件,并替换找到的全名。当前工作目录包含在扫描的目录列表中。</target>
        </trans-unit>
        <trans-unit id="27ed6e70669ea07173e0ff90384757c33382fb6e" translate="yes" xml:space="preserve">
          <source>Current argument is the name of a linker script. Search for that file in the current list of directories to scan for libraries. If the file is located insert a</source>
          <target state="translated">当前参数是一个链接器脚本的名称。在当前目录列表中搜索该文件以扫描库。如果该文件被定位,则插入一个</target>
        </trans-unit>
        <trans-unit id="318f590d6974d7ec1e4d3da7f86481fca68df621" translate="yes" xml:space="preserve">
          <source>Current gcov-tool supports the following functionalities:</source>
          <target state="translated">当前的gcov-tool支持以下功能。</target>
        </trans-unit>
        <trans-unit id="883949fd66aefc2f68b17e769896d2b8ef7a23bf" translate="yes" xml:space="preserve">
          <source>Currently the x86 GNU/Linux target provides an implementation based on Intel Control-flow Enforcement Technology (CET).</source>
          <target state="translated">目前x86 GNU/Linux目标提供了基于Intel控制流执行技术(CET)的实现。</target>
        </trans-unit>
        <trans-unit id="4e2c32ee916d61bb5fb82fcf33fd745d76fa8899" translate="yes" xml:space="preserve">
          <source>Currently this feature only works for</source>
          <target state="translated">目前该功能只适用于</target>
        </trans-unit>
        <trans-unit id="0990f74b9abadf3ef16d92f66dc8a33347d7b30f" translate="yes" xml:space="preserve">
          <source>Currently, ARM and AArch64 back ends do not support ACLE 2.0 fully. Both back ends support CRC32 intrinsics and the ARM back end supports the Coprocessor intrinsics, all from</source>
          <target state="translated">目前,ARM和Arch64后端不完全支持ACLE 2.0。两种后端都支持CRC32本征,ARM后端支持Coprocessor本征,均来自于</target>
        </trans-unit>
        <trans-unit id="31736ea72fe4084b8c34c06d50c0f1b2816826be" translate="yes" xml:space="preserve">
          <source>Currently, GCC defines &lt;code&gt;__STDC__&lt;/code&gt; unconditionally. This provides good results in practice.</source>
          <target state="translated">当前，GCC 无条件定义 &lt;code&gt;__STDC__&lt;/code&gt; 。在实践中这提供了良好的结果。</target>
        </trans-unit>
        <trans-unit id="2f63ff4fabd516030a0097fd6f4d244c1efad6e8" translate="yes" xml:space="preserve">
          <source>Currently, the attribute is ignored for inlined functions. If the attribute is applied to a symbol &lt;em&gt;definition&lt;/em&gt;, an error is reported. If a symbol previously declared &lt;code&gt;dllimport&lt;/code&gt; is later defined, the attribute is ignored in subsequent references, and a warning is emitted. The attribute is also overridden by a subsequent declaration as &lt;code&gt;dllexport&lt;/code&gt;.</source>
          <target state="translated">当前，内联函数将忽略该属性。如果将属性应用于符号&lt;em&gt;定义&lt;/em&gt;，则会报告错误。如果以后定义了先前声明的 &lt;code&gt;dllimport&lt;/code&gt; 符号，则在后续引用中将忽略该属性，并发出警告。该属性也被后续声明为 &lt;code&gt;dllexport&lt;/code&gt; 覆盖。</target>
        </trans-unit>
        <trans-unit id="590e74950b3a359e45f46ccc033df08293e7e8d0" translate="yes" xml:space="preserve">
          <source>Currently, the preferred dialect makes plain bit-fields signed, because this is simplest. Since &lt;code&gt;int&lt;/code&gt; is the same as &lt;code&gt;signed int&lt;/code&gt; in every other context, it is cleanest for them to be the same in bit-fields as well.</source>
          <target state="translated">当前，首​​选方言使普通的位域签名，因为这是最简单的。由于 &lt;code&gt;int&lt;/code&gt; 在所有其他上下文中都与 &lt;code&gt;signed int&lt;/code&gt; 相同，因此它们在位字段中也相同是最干净的。</target>
        </trans-unit>
        <trans-unit id="62ab12d09721515fc5fde562eb0862cdc8c3be63" translate="yes" xml:space="preserve">
          <source>Currently, there are two Blackfin-specific built-in functions. These are used for generating &lt;code&gt;CSYNC&lt;/code&gt; and &lt;code&gt;SSYNC&lt;/code&gt; machine insns without using inline assembly; by using these built-in functions the compiler can automatically add workarounds for hardware errata involving these instructions. These functions are named as follows:</source>
          <target state="translated">当前，有两个特定于Blackfin的内置函数。这些用于生成 &lt;code&gt;CSYNC&lt;/code&gt; 和 &lt;code&gt;SSYNC&lt;/code&gt; 机器insns，而无需使用内联汇编；通过使用这些内置函数，编译器可以自动添加涉及这些指令的硬件勘误的解决方法。这些函数的名称如下：</target>
        </trans-unit>
        <trans-unit id="3463fd1fcbee98183382ce3e6bfb37d05534e64b" translate="yes" xml:space="preserve">
          <source>Custom instruction assignments given by individual</source>
          <target state="translated">由个人提供的定制教学任务</target>
        </trans-unit>
        <trans-unit id="f2bc7d2b6265d22c6647e1fcd64c13f072748076" translate="yes" xml:space="preserve">
          <source>D documentation code (Ddoc).</source>
          <target state="translated">D文件编码(Ddoc)。</target>
        </trans-unit>
        <trans-unit id="2c7c0a531f3f523f274fda8de9447eb2371b07a9" translate="yes" xml:space="preserve">
          <source>D interface file.</source>
          <target state="translated">D接口文件。</target>
        </trans-unit>
        <trans-unit id="6e41c2f41f21895821ff2de4b2b537b418d821df" translate="yes" xml:space="preserve">
          <source>D register</source>
          <target state="translated">D寄存器</target>
        </trans-unit>
        <trans-unit id="2b608c731b27a1c96a6f8a0e732c2d9673589c56" translate="yes" xml:space="preserve">
          <source>D source code.</source>
          <target state="translated">D源码。</target>
        </trans-unit>
        <trans-unit id="6e946b779e60851d5c244c3ad74774cbf9f1d48d" translate="yes" xml:space="preserve">
          <source>DD</source>
          <target state="translated">DD</target>
        </trans-unit>
        <trans-unit id="333132be138ba9ace941111a0f174248952df7a1" translate="yes" xml:space="preserve">
          <source>DF</source>
          <target state="translated">DF</target>
        </trans-unit>
        <trans-unit id="53a81edefe355889dccbacb38a4a1453f4e85785" translate="yes" xml:space="preserve">
          <source>DL</source>
          <target state="translated">DL</target>
        </trans-unit>
        <trans-unit id="8fe69de0441ad2ce15deb455eb1d3b4c6713b22c" translate="yes" xml:space="preserve">
          <source>Data file relocation.</source>
          <target state="translated">数据文件搬迁。</target>
        </trans-unit>
        <trans-unit id="12293b22c91f6b4096277825dea65487973f1c86" translate="yes" xml:space="preserve">
          <source>Data prefetch does not generate faults if &lt;var&gt;addr&lt;/var&gt; is invalid, but the address expression itself must be valid. For example, a prefetch of &lt;code&gt;p-&amp;gt;next&lt;/code&gt; does not fault if &lt;code&gt;p-&amp;gt;next&lt;/code&gt; is not a valid address, but evaluation faults if &lt;code&gt;p&lt;/code&gt; is not a valid address.</source>
          <target state="translated">如果 &lt;var&gt;addr&lt;/var&gt; 无效，则数据预取不会产生错误，但是地址表达式本身必须有效。例如，预取 &lt;code&gt;p-&amp;gt;next&lt;/code&gt; 并不时发生故障 &lt;code&gt;p-&amp;gt;next&lt;/code&gt; ，如果不是一个有效的地址，但评价故障 &lt;code&gt;p&lt;/code&gt; 是不是一个有效的地址。</target>
        </trans-unit>
        <trans-unit id="c2a93a0b6a01599dcd1bcda6f09bcde290d7a928" translate="yes" xml:space="preserve">
          <source>Data register</source>
          <target state="translated">数据寄存器</target>
        </trans-unit>
        <trans-unit id="46a7bcc6b46e84d9b5870e2cd0ac98f1bdb1402e" translate="yes" xml:space="preserve">
          <source>Data register (arbitrary general purpose register)</source>
          <target state="translated">数据寄存器(任意通用寄存器)</target>
        </trans-unit>
        <trans-unit id="47be067ca541e17c43e79dffecbcbbad2c9d9a08" translate="yes" xml:space="preserve">
          <source>Data type: &lt;strong id=&quot;index-struct-_005f_005fhtm_005ftdb&quot;&gt;struct __htm_tdb&lt;/strong&gt;</source>
          <target state="translated">数据类型：&lt;strong id=&quot;index-struct-_005f_005fhtm_005ftdb&quot;&gt;struct __htm_tdb&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2310e7e6984f7b9841fe3043d76bb8748b8032aa" translate="yes" xml:space="preserve">
          <source>Data types for complex numbers.</source>
          <target state="translated">复数的数据类型。</target>
        </trans-unit>
        <trans-unit id="c002fd4f69749774cd614b7282439760b0a132f5" translate="yes" xml:space="preserve">
          <source>Debug dumps can be enabled with a</source>
          <target state="translated">调试转储可以通过</target>
        </trans-unit>
        <trans-unit id="d5a9f22c83f9299405413f6e5e553516a6cf6903" translate="yes" xml:space="preserve">
          <source>Debugging (</source>
          <target state="translated">调试 (</target>
        </trans-unit>
        <trans-unit id="b7b96436cf5229d16fb5897e129a114445f95678" translate="yes" xml:space="preserve">
          <source>Debugging Options</source>
          <target state="translated">调试选项</target>
        </trans-unit>
        <trans-unit id="aff6d1089cf54da46ac69c2183c78d051d04eff0" translate="yes" xml:space="preserve">
          <source>Decimal Floating Types.</source>
          <target state="translated">十进制浮动类型。</target>
        </trans-unit>
        <trans-unit id="6a66960857760a2cd63559ec52ee94a4a711e705" translate="yes" xml:space="preserve">
          <source>Declarations of external variables and functions within a block apply only to the block containing the declaration. In other words, they have the same scope as any other declaration in the same place.</source>
          <target state="translated">块中的外部变量和函数的声明只适用于包含声明的块。换句话说,它们的范围与同一地方的其他声明相同。</target>
        </trans-unit>
        <trans-unit id="226f69acb8ae88a869e2645962bf30e8ec7e974f" translate="yes" xml:space="preserve">
          <source>Declares the instruction to be commutative for this operand and the following operand. This means that the compiler may interchange the two operands if that is the cheapest way to make all operands fit the constraints. &amp;lsquo;</source>
          <target state="translated">声明该操作数与后续操作数的可交换指令。这意味着，如果这是使所有操作数都符合约束的最廉价方法，则编译器可以互换两个操作数。'</target>
        </trans-unit>
        <trans-unit id="6e381a53c21bfca57ae3c6418395aa6805faa3e6" translate="yes" xml:space="preserve">
          <source>Declaring multiple function versions.</source>
          <target state="translated">声明多个函数版本。</target>
        </trans-unit>
        <trans-unit id="9df458345b87f143e1443622e3689e81c8f18de5" translate="yes" xml:space="preserve">
          <source>Declaring objects with &lt;code&gt;uncached&lt;/code&gt; allows you to exclude data-cache participation in load and store operations on those objects without involving the additional semantic implications of &lt;code&gt;volatile&lt;/code&gt;. The &lt;code&gt;.di&lt;/code&gt; instruction suffix is used for all loads and stores of data declared &lt;code&gt;uncached&lt;/code&gt;.</source>
          <target state="translated">使用 &lt;code&gt;uncached&lt;/code&gt; 声明对象使您可以排除数据缓存参与这些对象的加载和存储操作，而无需涉及 &lt;code&gt;volatile&lt;/code&gt; 的其他语义含义。该 &lt;code&gt;.di&lt;/code&gt; 指令后缀用于所有负载和数据存储的声明 &lt;code&gt;uncached&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dea979b67c132bc175e1957da54321717a0b3e04" translate="yes" xml:space="preserve">
          <source>Declaring that functions have no side effects, or that they can never return.</source>
          <target state="translated">声明函数没有副作用,或者永远不能返回。</target>
        </trans-unit>
        <trans-unit id="63030d3cd1e02a687549d142e20f0269121d2b83" translate="yes" xml:space="preserve">
          <source>Declaring the variable</source>
          <target state="translated">声明变量</target>
        </trans-unit>
        <trans-unit id="b2609010c78f10c37fecace799c32d84a8b0113e" translate="yes" xml:space="preserve">
          <source>Declaring zero-length arrays in other contexts, including as interior members of structure objects or as non-member objects, is discouraged. Accessing elements of zero-length arrays declared in such contexts is undefined and may be diagnosed.</source>
          <target state="translated">不鼓励在其他情况下声明零长度数组,包括作为结构对象的内部成员或非成员对象。访问在这些上下文中声明的零长度数组的元素是没有定义的,可能会被诊断出来。</target>
        </trans-unit>
        <trans-unit id="c0ce91fb53831d435a29b5632774a3c603665597" translate="yes" xml:space="preserve">
          <source>Declaring zero-length arrays is allowed in GNU C as an extension. A zero-length array can be useful as the last element of a structure that is really a header for a variable-length object:</source>
          <target state="translated">在GNU C中,允许声明零长度数组作为一种扩展。零长度数组可以作为一个结构的最后一个元素,而这个结构实际上是一个可变长度对象的头。</target>
        </trans-unit>
        <trans-unit id="6ccbb003fcbbef0455a040407eca25644a68c8af" translate="yes" xml:space="preserve">
          <source>Default instruction scheduling parameters are used for values that select an architecture and not an implementation. These are &amp;lsquo;</source>
          <target state="translated">默认指令调度参数用于选择架构而不是实现的值。这些是 '</target>
        </trans-unit>
        <trans-unit id="ba9d931a2de4e95a1c6e18f4c96c1c9b9529c7aa" translate="yes" xml:space="preserve">
          <source>Default to 64-bit memory allocation routines.</source>
          <target state="translated">默认为64位内存分配例程。</target>
        </trans-unit>
        <trans-unit id="bc0e52c70e2e3d40aed76c210b466f12c8a6307d" translate="yes" xml:space="preserve">
          <source>Default visibility corresponds to &amp;ldquo;external linkage&amp;rdquo; in the language.</source>
          <target state="translated">默认可见性对应于该语言中的&amp;ldquo;外部链接&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="422c626b9da356260a74af4c444e356b1dff1705" translate="yes" xml:space="preserve">
          <source>Default visibility is the normal case for the object file format. This value is available for the visibility attribute to override other options that may change the assumed visibility of entities.</source>
          <target state="translated">默认可见性是对象文件格式的正常情况。该值可用于可见性属性,以覆盖可能改变实体的假定可见性的其他选项。</target>
        </trans-unit>
        <trans-unit id="dcc8364c434a51851187f20fa9cd4e3c3aefb760" translate="yes" xml:space="preserve">
          <source>Define a copy constructor and an assignment operator for classes with dynamically-allocated memory.</source>
          <target state="translated">为具有动态分配内存的类定义一个复制构造函数和一个赋值操作符。</target>
        </trans-unit>
        <trans-unit id="5e2f8d06c00c297c0f950f50c2f9216e48b9c380" translate="yes" xml:space="preserve">
          <source>Define additional macros required for using the POSIX threads library. You should use this option consistently for both compilation and linking. This option is supported on GNU/Linux targets, most other Unix derivatives, and also on x86 Cygwin and MinGW targets.</source>
          <target state="translated">定义使用POSIX线程库所需的附加宏。你应该在编译和链接时一致使用这个选项。这个选项在GNU/Linux目标机、大多数其他Unix衍生产品以及x86 Cygwin和MinGW目标机上都受到支持。</target>
        </trans-unit>
        <trans-unit id="8c097d198bbcce6c15c43b9673925ec2a844aa50" translate="yes" xml:space="preserve">
          <source>Define an argument called &lt;var&gt;key&lt;/var&gt; with a value of &lt;var&gt;value&lt;/var&gt; for the plugin called &lt;var&gt;name&lt;/var&gt;.</source>
          <target state="translated">为名为 &lt;var&gt;name&lt;/var&gt; 的插件定义一个名为 &lt;var&gt;key&lt;/var&gt; 的参数，其值为 &lt;var&gt;value&lt;/var&gt; 。</target>
        </trans-unit>
        <trans-unit id="3b065b864c454ddad2ef2e2ee36967d76b136921" translate="yes" xml:space="preserve">
          <source>Define how many insn groups (cycles) are examined for a dependency on a stalled insn that is a candidate for premature removal from the queue of stalled insns. This has an effect only during the second scheduling pass, and only if</source>
          <target state="translated">定义有多少个insn组(周期)会被检查,以确定是否依赖于停滞的insn,该停滞的insn是过早从停滞的insn队列中移除的候选者。这只有在第二个调度通道中才会产生影响,并且只有在以下情况下才会产生影响</target>
        </trans-unit>
        <trans-unit id="d9b9a323e114f08ae98c07403af86c1b8b068b0b" translate="yes" xml:space="preserve">
          <source>Define how many insns (if any) can be moved prematurely from the queue of stalled insns into the ready list during the second scheduling pass.</source>
          <target state="translated">定义在第二次调度过程中,有多少insn(如果有的话)可以从停滞的insn队列中提前移动到准备好的列表中。</target>
        </trans-unit>
        <trans-unit id="b02590046df70d51175d1e6e43007843fa86e90a" translate="yes" xml:space="preserve">
          <source>Defining a register variable does not reserve the register. Other than when invoking the Extended &lt;code&gt;asm&lt;/code&gt;, the contents of the specified register are not guaranteed. For this reason, the following uses are explicitly &lt;em&gt;not&lt;/em&gt; supported. If they appear to work, it is only happenstance, and may stop working as intended due to (seemingly) unrelated changes in surrounding code, or even minor changes in the optimization of a future version of gcc:</source>
          <target state="translated">定义寄存器变量不会保留寄存器。除了调用扩展 &lt;code&gt;asm&lt;/code&gt; 时，不能保证指定寄存器的内容。因此，明确&lt;em&gt;不&lt;/em&gt;支持以下用途。如果它们似乎起作用，那只是偶然，并且可能会由于（似乎）周围代码中不相关的更改，甚至在gcc未来版本的优化中的微小更改而按预期停止工作：</target>
        </trans-unit>
        <trans-unit id="827f9d9fc11f005c60202a566cf0397ae86dd11d" translate="yes" xml:space="preserve">
          <source>Defining inline functions (as fast as macros).</source>
          <target state="translated">定义内联函数(和宏一样快)。</target>
        </trans-unit>
        <trans-unit id="85adcd212de2e338813907851ee4a5662c5f1efc" translate="yes" xml:space="preserve">
          <source>Defining variables residing in specified registers.</source>
          <target state="translated">定义驻留在指定寄存器中的变量。</target>
        </trans-unit>
        <trans-unit id="83ee69015768e1155b22074ebd3a36cc37e95cce" translate="yes" xml:space="preserve">
          <source>Delay execution for &lt;var&gt;ticks&lt;/var&gt; cycles. Note that this built-in does not take into account the effect of interrupts that might increase delay time. &lt;var&gt;ticks&lt;/var&gt; must be a compile-time integer constant; delays with a variable number of cycles are not supported.</source>
          <target state="translated">延迟执行 &lt;var&gt;ticks&lt;/var&gt; 周期。请注意，此内置功能未考虑可能会增加延迟时间的中断的影响。 &lt;var&gt;ticks&lt;/var&gt; 必须是编译时整数常量；不支持具有可变周期数的延迟。</target>
        </trans-unit>
        <trans-unit id="1610d19a0a48226750b3049b914e4786781d22cd" translate="yes" xml:space="preserve">
          <source>Deleting &amp;ldquo;empty&amp;rdquo; loops.</source>
          <target state="translated">删除&amp;ldquo;空&amp;rdquo;循环。</target>
        </trans-unit>
        <trans-unit id="36a3093d26bbd3d1360751144e1efe12aeac3836" translate="yes" xml:space="preserve">
          <source>Depending on the target and how GCC was configured, a slightly different set of optimizations may be enabled at each</source>
          <target state="translated">根据目标和GCC的配置方式,可能会在每一个</target>
        </trans-unit>
        <trans-unit id="c9892e7a514c42b2b22214f98f72a5abf448bce9" translate="yes" xml:space="preserve">
          <source>Describes the type of hardware multiply supported by the target. Accepted values are &amp;lsquo;</source>
          <target state="translated">描述目标支持的硬件乘法类型。可接受的值为&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="55f8ebc805e65b5b71ddafdae390e3be2bcd69af" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">Description</target>
        </trans-unit>
        <trans-unit id="230a2f1369c19e9bed8580ef0c388abed833d36f" translate="yes" xml:space="preserve">
          <source>Despite the nomenclature, &amp;lsquo;</source>
          <target state="translated">尽管有术语，&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="bd519eb03ed0c213fdab64aa985771c57b8bf1cd" translate="yes" xml:space="preserve">
          <source>Detect floating-point division by zero. Unlike other similar options,</source>
          <target state="translated">检测浮点除以零。与其他类似选项不同。</target>
        </trans-unit>
        <trans-unit id="f275b676db5ca45003e8d7fdde53e395b48ae26a" translate="yes" xml:space="preserve">
          <source>Detect integer division by zero as well as &lt;code&gt;INT_MIN / -1&lt;/code&gt; division.</source>
          <target state="translated">检测整数除以零以及 &lt;code&gt;INT_MIN / -1&lt;/code&gt; 除。</target>
        </trans-unit>
        <trans-unit id="1f073b8e3005614eac7c90dae6865076fed02ebe" translate="yes" xml:space="preserve">
          <source>Detect paths that trigger erroneous or undefined behavior due to a null value being used in a way forbidden by a &lt;code&gt;returns_nonnull&lt;/code&gt; or &lt;code&gt;nonnull&lt;/code&gt; attribute. Isolate those paths from the main control flow and turn the statement with erroneous or undefined behavior into a trap. This is not currently enabled, but may be enabled by</source>
          <target state="translated">检测由于 &lt;code&gt;returns_nonnull&lt;/code&gt; 或 &lt;code&gt;nonnull&lt;/code&gt; 属性禁止使用空值而导致触发错误或未定义行为的路径。从主控制流中隔离这些路径，并将具有错误或未定义行为的语句转换为陷阱。目前尚未启用，但可以通过以下方式启用</target>
        </trans-unit>
        <trans-unit id="6fd69cb31930da8cd040a4ffab1183319f8c09e1" translate="yes" xml:space="preserve">
          <source>Detect paths that trigger erroneous or undefined behavior due to dereferencing a null pointer. Isolate those paths from the main control flow and turn the statement with erroneous or undefined behavior into a trap. This flag is enabled by default at</source>
          <target state="translated">侦测由于去引用空指针而触发错误或未定义行为的路径。将这些路径从主控制流中分离出来,并将具有错误或未定义行为的语句变成一个陷阱。这个标志默认在</target>
        </trans-unit>
        <trans-unit id="b579efc699383256e0ea46438d32e07c0012bfb5" translate="yes" xml:space="preserve">
          <source>Determine the language standard. See &lt;a href=&quot;standards#Standards&quot;&gt;Language Standards Supported by GCC&lt;/a&gt;, for details of these standard versions. This option is currently only supported when compiling C or C++.</source>
          <target state="translated">确定语言标准。有关这些标准版本的详细信息，请参见&lt;a href=&quot;standards#Standards&quot;&gt;GCC支持的语言标准&lt;/a&gt;。当前仅在编译C或C ++时才支持此选项。</target>
        </trans-unit>
        <trans-unit id="86070f5116cf4fafa20ed47f8a131328fabf7c26" translate="yes" xml:space="preserve">
          <source>Determined by ABI.</source>
          <target state="translated">由ABI确定。</target>
        </trans-unit>
        <trans-unit id="3673862083301334f396f6717a9c4dfccba740e6" translate="yes" xml:space="preserve">
          <source>Determined by ABI. The options</source>
          <target state="translated">由ABI确定。选项</target>
        </trans-unit>
        <trans-unit id="95662524b23c122195f82746bb2090bea580b1d6" translate="yes" xml:space="preserve">
          <source>Determining the alignment of a function, type or variable.</source>
          <target state="translated">确定一个函数、类型或变量的对齐方式。</target>
        </trans-unit>
        <trans-unit id="1e53b5ee672acae1a69a324148d3c1bc9485a2b5" translate="yes" xml:space="preserve">
          <source>Developer Options</source>
          <target state="translated">开发者选项</target>
        </trans-unit>
        <trans-unit id="76b02b7503c565a218e0634291f3750002ba2b81" translate="yes" xml:space="preserve">
          <source>Devices belonging to &lt;code&gt;avrtiny&lt;/code&gt; and &lt;code&gt;avrxmega3&lt;/code&gt; can access flash memory by means of &lt;code&gt;LD*&lt;/code&gt; instructions because the flash memory is mapped into the RAM address space. There is &lt;em&gt;no need&lt;/em&gt; for language extensions like &lt;code&gt;__flash&lt;/code&gt; or attribute &lt;a href=&quot;variable-attributes#AVR-Variable-Attributes&quot;&gt;&lt;code&gt;progmem&lt;/code&gt;&lt;/a&gt;. The default linker description files for these devices cater for that feature and &lt;code&gt;.rodata&lt;/code&gt; stays in flash: The compiler just generates &lt;code&gt;LD*&lt;/code&gt; instructions, and the linker script adds core specific offsets to all &lt;code&gt;.rodata&lt;/code&gt; symbols: &lt;code&gt;0x4000&lt;/code&gt; in the case of &lt;code&gt;avrtiny&lt;/code&gt; and &lt;code&gt;0x8000&lt;/code&gt; in the case of &lt;code&gt;avrxmega3&lt;/code&gt;. See &lt;a href=&quot;avr-options#AVR-Options&quot;&gt;AVR Options&lt;/a&gt; for a list of respective devices.</source>
          <target state="translated">属于 &lt;code&gt;avrtiny&lt;/code&gt; 和 &lt;code&gt;avrxmega3&lt;/code&gt; 的设备可以通过 &lt;code&gt;LD*&lt;/code&gt; 指令访问闪存，因为闪存已映射到RAM地址空间中。有&lt;em&gt;没有必要&lt;/em&gt;对语言的扩展名如 &lt;code&gt;__flash&lt;/code&gt; 或属性&lt;a href=&quot;variable-attributes#AVR-Variable-Attributes&quot;&gt; &lt;code&gt;progmem&lt;/code&gt; &lt;/a&gt;。这些设备的默认链接描述文件满足该功能并 &lt;code&gt;.rodata&lt;/code&gt; 闪光灯住宿：编译器只是生成 &lt;code&gt;LD*&lt;/code&gt; 说明和链接器脚本添加核心特定偏移所有 &lt;code&gt;.rodata&lt;/code&gt; 符号： &lt;code&gt;0x4000&lt;/code&gt; 的在的情况下 &lt;code&gt;avrtiny&lt;/code&gt; 和 &lt;code&gt;0x8000&lt;/code&gt; 在的情况下 &lt;code&gt;avrxmega3&lt;/code&gt; 。有关相应设备的列表，请参阅&lt;a href=&quot;avr-options#AVR-Options&quot;&gt;AVR选项&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ce3941724906083a5cbd3b764ac34bb494078fce" translate="yes" xml:space="preserve">
          <source>Diagnostic Message Formatting Options</source>
          <target state="translated">诊断信息格式选项</target>
        </trans-unit>
        <trans-unit id="3f68058e1e87ea41d8c9d3c7c1f94f8140abe531" translate="yes" xml:space="preserve">
          <source>Diagnostics can have child diagnostics. For example, this error and note:</source>
          <target state="translated">诊断程序可以有子诊断程序。例如,这个错误和说明。</target>
        </trans-unit>
        <trans-unit id="f2f5c489e6e2397fb8b9f0a64fb5a021b4c96f8f" translate="yes" xml:space="preserve">
          <source>Diagnostics consist of all the output sent to stderr by GCC.</source>
          <target state="translated">诊断包括GCC发送到stderr的所有输出。</target>
        </trans-unit>
        <trans-unit id="3545c8182bd90d9cc3755c0e6e77d7f64b0e4f2b" translate="yes" xml:space="preserve">
          <source>Different sets of tools are interoperable if they generate files that can be used in the same program. The set of tools includes compilers, assemblers, linkers, libraries, header files, startup files, and debuggers. Binaries produced by different sets of tools are not interoperable unless they implement the same ABI. This applies to different versions of the same tools as well as tools from different vendors.</source>
          <target state="translated">不同的工具集如果产生的文件可以在同一个程序中使用,那么它们就是可以互操作的。工具集包括编译器、汇编器、链接器、库、头文件、启动文件和调试器。由不同工具集产生的二进制文件不能互操作,除非它们实现了相同的ABI。这适用于同一工具的不同版本以及不同供应商的工具。</target>
        </trans-unit>
        <trans-unit id="356087678cfa620825af09ad133165c6564b44fe" translate="yes" xml:space="preserve">
          <source>Direct the linker to not merge together strings in the debugging information that are identical in different object files. Merging is not supported by all assemblers or linkers. Merging decreases the size of the debug information in the output file at the cost of increasing link processing time. Merging is enabled by default.</source>
          <target state="translated">指示链接器不要将调试信息中不同对象文件中相同的字符串合并在一起。并非所有汇编器或链接器都支持合并。合并会以增加链接处理时间为代价,减少输出文件中调试信息的大小。合并在默认情况下是启用的。</target>
        </trans-unit>
        <trans-unit id="7eb0eda4de9f69bec3e03226fe8296271cfe198f" translate="yes" xml:space="preserve">
          <source>Directories specified with</source>
          <target state="translated">指定的目录,用</target>
        </trans-unit>
        <trans-unit id="f710acdf8c3a36b577ab367527e400e4e4519a38" translate="yes" xml:space="preserve">
          <source>Directory Options</source>
          <target state="translated">目录选项</target>
        </trans-unit>
        <trans-unit id="9a7d4e0687b14e2b7cda406900b802782cd50a62" translate="yes" xml:space="preserve">
          <source>Disable</source>
          <target state="translated">Disable</target>
        </trans-unit>
        <trans-unit id="2d24b1d992d1c4af780c8f9d61b9c942a6314962" translate="yes" xml:space="preserve">
          <source>Disable (do not disable) use of the &lt;code&gt;jal&lt;/code&gt; instruction. Calling functions using &lt;code&gt;jal&lt;/code&gt; is more efficient but requires the caller and callee to be in the same 256 megabyte segment.</source>
          <target state="translated">禁用（请勿禁用） &lt;code&gt;jal&lt;/code&gt; 指令。使用 &lt;code&gt;jal&lt;/code&gt; 的调用函数效率更高，但要求调用者和被调用者位于相同的256 MB段中。</target>
        </trans-unit>
        <trans-unit id="df30c5939a2b24c38598155ef45390b83313cc5d" translate="yes" xml:space="preserve">
          <source>Disable (or enable) optimizations that use the small data section. This may be useful for working around optimizer bugs.</source>
          <target state="translated">禁用(或启用)使用小数据部分的优化。这对于解决优化器的错误可能很有用。</target>
        </trans-unit>
        <trans-unit id="7f2ac79b60fc58bb07e366adfa0ca3573c94fc1b" translate="yes" xml:space="preserve">
          <source>Disable (or re-enable) the generation of PC-relative jump instructions.</source>
          <target state="translated">禁用(或重新启用)PC相关跳转指令的生成。</target>
        </trans-unit>
        <trans-unit id="e288cae69ca3cd91f647a069f6407394ee8f11c1" translate="yes" xml:space="preserve">
          <source>Disable (or re-enable) the generation of hardware floating point instructions. This option is only significant when the target architecture is &amp;lsquo;</source>
          <target state="translated">禁用（或重新启用）硬件浮点指令的生成。仅当目标架构为&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="b671582f983bdaa2dca5a8611789524ffa3c4ce1" translate="yes" xml:space="preserve">
          <source>Disable &lt;code&gt;lr&lt;/code&gt; and &lt;code&gt;sr&lt;/code&gt; instructions from using FPX extension aux registers.</source>
          <target state="translated">通过使用FPX扩展aux寄存器禁用 &lt;code&gt;lr&lt;/code&gt; 和 &lt;code&gt;sr&lt;/code&gt; 指令。</target>
        </trans-unit>
        <trans-unit id="c1660e5f22d4c71c2ee4abdaec7f4aef18aa78c9" translate="yes" xml:space="preserve">
          <source>Disable IPA pass &lt;var&gt;pass&lt;/var&gt;. &lt;var&gt;pass&lt;/var&gt; is the pass name. If the same pass is statically invoked in the compiler multiple times, the pass name should be appended with a sequential number starting from 1.</source>
          <target state="translated">禁用IPA pass &lt;var&gt;pass&lt;/var&gt; 。 &lt;var&gt;pass&lt;/var&gt; 是通过名称。如果在编译器中多次静态调用同一遍，则遍历名称应附加从1开始的序列号。</target>
        </trans-unit>
        <trans-unit id="9d85b585d1d05ada062cacb1bc9babcd262635c5" translate="yes" xml:space="preserve">
          <source>Disable RTL pass &lt;var&gt;pass&lt;/var&gt;. &lt;var&gt;pass&lt;/var&gt; is the pass name. If the same pass is statically invoked in the compiler multiple times, the pass name should be appended with a sequential number starting from 1. &lt;var&gt;range-list&lt;/var&gt; is a comma-separated list of function ranges or assembler names. Each range is a number pair separated by a colon. The range is inclusive in both ends. If the range is trivial, the number pair can be simplified as a single number. If the function&amp;rsquo;s call graph node&amp;rsquo;s &lt;var&gt;uid&lt;/var&gt; falls within one of the specified ranges, the &lt;var&gt;pass&lt;/var&gt; is disabled for that function. The &lt;var&gt;uid&lt;/var&gt; is shown in the function header of a dump file, and the pass names can be dumped by using option</source>
          <target state="translated">禁用RTL pass &lt;var&gt;pass&lt;/var&gt; 。 &lt;var&gt;pass&lt;/var&gt; 是通过名称。如果在编译器中多次静态调用同一遍，则遍历名称应附加一个从1开始的序号。range &lt;var&gt;range-list&lt;/var&gt; 是用逗号分隔的函数范围或汇编程序名称列表。每个范围都是一个由冒号分隔的数字对。该范围包括两端。如果范围很小，则可以将数字对简化为单个数字。如果函数的调用图节点的 &lt;var&gt;uid&lt;/var&gt; 处于指定范围之一内，则对该函数禁用 &lt;var&gt;pass&lt;/var&gt; 。该 &lt;var&gt;uid&lt;/var&gt; 示于转储文件的函数头，和通过名字可以通过使用选项被倾倒</target>
        </trans-unit>
        <trans-unit id="7472182885a7c5023818095d70ccee0a1003a982" translate="yes" xml:space="preserve">
          <source>Disable Wpedantic warnings about constructs used in MFC, such as implicit int and getting a pointer to member function via non-standard syntax.</source>
          <target state="translated">禁用Wpedantic对MFC中使用的结构的警告,如隐式int和通过非标准语法获取成员函数的指针。</target>
        </trans-unit>
        <trans-unit id="d634773489054e3f820c752b2fe8a75da7d7b819" translate="yes" xml:space="preserve">
          <source>Disable all estimate instructions, equivalent to</source>
          <target state="translated">禁用所有估算指令,相当于</target>
        </trans-unit>
        <trans-unit id="24c834ead83a4d1ebc3aa24aef6d4685246dfacb" translate="yes" xml:space="preserve">
          <source>Disable any machine-specific peephole optimizations. The difference between</source>
          <target state="translated">禁用任何特定机器的窥视孔优化。之间的区别</target>
        </trans-unit>
        <trans-unit id="dd10c462b4994eb3982bf5bd6da47ab31464aa34" translate="yes" xml:space="preserve">
          <source>Disable built-in declarations of functions that are not mandated by ANSI/ISO C. These include &lt;code&gt;ffs&lt;/code&gt;, &lt;code&gt;alloca&lt;/code&gt;, &lt;code&gt;_exit&lt;/code&gt;, &lt;code&gt;index&lt;/code&gt;, &lt;code&gt;bzero&lt;/code&gt;, &lt;code&gt;conjf&lt;/code&gt;, and other related functions.</source>
          <target state="translated">禁用未由ANSI / ISO C强制执行的函数的内置声明。这些声明包括 &lt;code&gt;ffs&lt;/code&gt; ， &lt;code&gt;alloca&lt;/code&gt; ， &lt;code&gt;_exit&lt;/code&gt; ， &lt;code&gt;index&lt;/code&gt; ， &lt;code&gt;bzero&lt;/code&gt; ， &lt;code&gt;conjf&lt;/code&gt; 和其他相关函数。</target>
        </trans-unit>
        <trans-unit id="e02b6f324995da402dd843cdd3b4c4bea9e780ea" translate="yes" xml:space="preserve">
          <source>Disable compilation effects of</source>
          <target state="translated">禁用编译效果</target>
        </trans-unit>
        <trans-unit id="4deddc96335abb292813c9ba7387aa150fa39b18" translate="yes" xml:space="preserve">
          <source>Disable compiler generated atomic sequences and emit library calls for atomic operations. This is the default if the target is not &lt;code&gt;sh*-*-linux*&lt;/code&gt;.</source>
          <target state="translated">禁用编译器生成的原子序列，并发出对原子操作的库调用。如果目标不是 &lt;code&gt;sh*-*-linux*&lt;/code&gt; 则这是默认设置。</target>
        </trans-unit>
        <trans-unit id="e03c896d7744b1b31e15f0be1dc55290d5dd4d98" translate="yes" xml:space="preserve">
          <source>Disable diagnostics that the standard says a compiler does not need to issue. Currently, the only such diagnostic issued by G++ is the one for a name having multiple meanings within a class.</source>
          <target state="translated">禁用标准规定编译器不需要发布的诊断程序。目前,G++发出的唯一的诊断是对一个类中具有多重含义的名称的诊断。</target>
        </trans-unit>
        <trans-unit id="15a8077f24c55fd5c21ad0119861505db428aa18" translate="yes" xml:space="preserve">
          <source>Disable generation of &lt;code&gt;bcnz&lt;/code&gt; instructions.</source>
          <target state="translated">禁用生成 &lt;code&gt;bcnz&lt;/code&gt; 指令。</target>
        </trans-unit>
        <trans-unit id="5286938aafbdfcae094ead274d86fb0eb12ec590" translate="yes" xml:space="preserve">
          <source>Disable generation of information about every class with virtual functions for use by the C++ run-time type identification features (&lt;code&gt;dynamic_cast&lt;/code&gt; and &lt;code&gt;typeid&lt;/code&gt;). If you don&amp;rsquo;t use those parts of the language, you can save some space by using this flag. Note that exception handling uses the same information, but G++ generates it as needed. The &lt;code&gt;dynamic_cast&lt;/code&gt; operator can still be used for casts that do not require run-time type information, i.e. casts to &lt;code&gt;void *&lt;/code&gt; or to unambiguous base classes.</source>
          <target state="translated">禁止使用虚拟函数生成有关每个类的信息，以供C ++运行时类型标识功能（ &lt;code&gt;dynamic_cast&lt;/code&gt; 和 &lt;code&gt;typeid&lt;/code&gt; ）使用。如果您不使用语言的这些部分，则可以使用此标志节省一些空间。请注意，异常处理使用相同的信息，但是G ++会根据需要生成它。该 &lt;code&gt;dynamic_cast&lt;/code&gt; 的操作仍然可以使用，不需要运行时类型信息，即强制类型强制转换 &lt;code&gt;void *&lt;/code&gt; 或明确的基类。</target>
        </trans-unit>
        <trans-unit id="2c5d893b2d5daa4c819c5a8197085e49914249d8" translate="yes" xml:space="preserve">
          <source>Disable global interrupt.</source>
          <target state="translated">禁用全局中断。</target>
        </trans-unit>
        <trans-unit id="5c285b2217d4516708f07171dfd66ed9be6d9834" translate="yes" xml:space="preserve">
          <source>Disable instruction scheduling across basic blocks, which is normally enabled when scheduling before register allocation, i.e. with</source>
          <target state="translated">禁用跨基本块的指令调度,通常在寄存器分配前进行调度时启用,即用</target>
        </trans-unit>
        <trans-unit id="0e98c6ae6e073a4473bf45d5938dfbe138a13b1c" translate="yes" xml:space="preserve">
          <source>Disable interprocedural optimizations between the function with this attribute and its callers, as if the body of the function is not available when optimizing callers and the callers are unavailable when optimizing the body. This attribute implies &lt;code&gt;noinline&lt;/code&gt;, &lt;code&gt;noclone&lt;/code&gt; and &lt;code&gt;no_icf&lt;/code&gt; attributes. However, this attribute is not equivalent to a combination of other attributes, because its purpose is to suppress existing and future optimizations employing interprocedural analysis, including those that do not have an attribute suitable for disabling them individually. This attribute is supported mainly for the purpose of testing the compiler.</source>
          <target state="translated">禁用具有此属性的函数及其调用者之间的过程间优化，好像在优化调用者时函数的主体不可用，而在优化主体时调用者不可用。此属性暗含 &lt;code&gt;noinline&lt;/code&gt; ， &lt;code&gt;noclone&lt;/code&gt; 和 &lt;code&gt;no_icf&lt;/code&gt; 属性。但是，此属性不等于其他属性的组合，因为它的目的是抑制使用过程间分析的现有和将来的优化，包括那些不具有适合单独禁用它们的属性的优化。支持此属性主要是为了测试编译器。</target>
        </trans-unit>
        <trans-unit id="c37151a8e5f5341e877c6066a7b31e954ab243b6" translate="yes" xml:space="preserve">
          <source>Disable lazy binding of function calls. This option is the default and is defined for compatibility with Diab.</source>
          <target state="translated">禁用函数调用的懒惰绑定。这个选项是默认的,是为了与Diab兼容而定义的。</target>
        </trans-unit>
        <trans-unit id="79f399771b0bd71907b7340d736452ada0291344" translate="yes" xml:space="preserve">
          <source>Disable linking effects of</source>
          <target state="translated">禁用链接效果</target>
        </trans-unit>
        <trans-unit id="609817ad0deecdec8c6b793819e36a0c5e4631a2" translate="yes" xml:space="preserve">
          <source>Disable nested conditional execution optimizations.</source>
          <target state="translated">禁用嵌套条件执行优化。</target>
        </trans-unit>
        <trans-unit id="252fe391b1a4b9d960215788262ee75bfd6c19f6" translate="yes" xml:space="preserve">
          <source>Disable optimization of &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; and &lt;code&gt;||&lt;/code&gt; in conditional execution.</source>
          <target state="translated">禁用 &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; 和 &lt;code&gt;||&lt;/code&gt; 的优化 在条件执行中。</target>
        </trans-unit>
        <trans-unit id="161926f247c9f892e24d049743fa9253ac876603" translate="yes" xml:space="preserve">
          <source>Disable sharing of stack slots allocated for pseudo-registers. Each pseudo-register that does not get a hard register gets a separate stack slot, and as a result function stack frames are larger.</source>
          <target state="translated">禁用为伪寄存器分配的栈槽的共享。每个没有得到硬寄存器的伪寄存器都会得到一个单独的堆栈槽,因此函数堆栈帧较大。</target>
        </trans-unit>
        <trans-unit id="c4a9a68d37ad2c1a1ec5ead44b9d2a2ec4d10976" translate="yes" xml:space="preserve">
          <source>Disable sharing of stack slots used for saving call-used hard registers living through a call. Each hard register gets a separate stack slot, and as a result function stack frames are larger.</source>
          <target state="translated">禁用共享用于保存调用使用的硬寄存器的堆栈槽。每个硬寄存器都有一个单独的堆栈槽,因此函数的堆栈框架更大。</target>
        </trans-unit>
        <trans-unit id="64d3adeb52b81d55606f0c9f79019d7885ab8d8f" translate="yes" xml:space="preserve">
          <source>Disable speculative motion of non-load instructions, which is normally enabled when scheduling before register allocation, i.e. with</source>
          <target state="translated">禁用非负载指令的推测运动,通常在寄存器分配前调度时启用,即用</target>
        </trans-unit>
        <trans-unit id="1b9e6a10d7feb88af30d21664dcd930d0d3d0e48" translate="yes" xml:space="preserve">
          <source>Disable the ARCompact-specific pass to generate conditional execution instructions.</source>
          <target state="translated">禁用ARCompact专用通道来生成条件执行指令。</target>
        </trans-unit>
        <trans-unit id="e7b7d0aa54600e475f975b3ad94c992870425a43" translate="yes" xml:space="preserve">
          <source>Disable the ARM-state integer division extension.</source>
          <target state="translated">禁用ARM状态下的整数除法扩展。</target>
        </trans-unit>
        <trans-unit id="9ae205131ae6c1f0b1ad1d6cdc75d88e53999201" translate="yes" xml:space="preserve">
          <source>Disable the Advanced SIMD instructions (does not disable floating point).</source>
          <target state="translated">禁用高级SIMD指令(不禁用浮点)。</target>
        </trans-unit>
        <trans-unit id="57b7e24dd0dd62653de9bd626e4944fa6899e1dd" translate="yes" xml:space="preserve">
          <source>Disable the DSP extension.</source>
          <target state="translated">禁用DSP扩展。</target>
        </trans-unit>
        <trans-unit id="734f786ab444d8f65fc0c46cdddee12bfda3218d" translate="yes" xml:space="preserve">
          <source>Disable the DSP instructions on &amp;lsquo;</source>
          <target state="translated">禁用&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="c7d8376c95023cbfb7c660163253089208b34ece" translate="yes" xml:space="preserve">
          <source>Disable the cryptographic extension.</source>
          <target state="translated">禁用加密扩展。</target>
        </trans-unit>
        <trans-unit id="7f3f13b931ffd3d75ba124cd726692f8712aa12e" translate="yes" xml:space="preserve">
          <source>Disable the cryptographic instructions.</source>
          <target state="translated">禁用加密指令。</target>
        </trans-unit>
        <trans-unit id="354594897b575026e6476d5a01060d1ccbb17336" translate="yes" xml:space="preserve">
          <source>Disable the diagnostic for converting a bound pointer to member function to a plain pointer.</source>
          <target state="translated">禁用将绑定指针转换为成员函数的普通指针的诊断。</target>
        </trans-unit>
        <trans-unit id="c0bf355bf048a8a4bc609b141cbb68d7e3532d66" translate="yes" xml:space="preserve">
          <source>Disable the floating-point and Advanced SIMD instructions.</source>
          <target state="translated">禁用浮点和高级SIMD指令。</target>
        </trans-unit>
        <trans-unit id="f50bf78f4ef90550849e16bf00e7f8fd3e26a980" translate="yes" xml:space="preserve">
          <source>Disable the floating-point extension.</source>
          <target state="translated">禁用浮点扩展。</target>
        </trans-unit>
        <trans-unit id="04850fd68730a9ccdd397aa31033dbe8ded5b8ec" translate="yes" xml:space="preserve">
          <source>Disable the floating-point extensions.</source>
          <target state="translated">禁用浮点扩展功能。</target>
        </trans-unit>
        <trans-unit id="c08d0916688b59b4478dd3a8a8d551babc61d679" translate="yes" xml:space="preserve">
          <source>Disable the floating-point instructions.</source>
          <target state="translated">禁用浮点指令。</target>
        </trans-unit>
        <trans-unit id="005c34c6f1c2fb8f1d59d1e3c41e0a0a2122f930" translate="yes" xml:space="preserve">
          <source>Disable the floating-point, Advanced SIMD and cryptographic instructions.</source>
          <target state="translated">禁用浮点、高级SIMD和加密指令。</target>
        </trans-unit>
        <trans-unit id="9c28f6f627d67c9bbae1a8f36d817bb71ee86b5b" translate="yes" xml:space="preserve">
          <source>Disable the insertion of cache barriers. This is the default setting.</source>
          <target state="translated">禁用插入缓存屏障。这是默认设置。</target>
        </trans-unit>
        <trans-unit id="f56b2447b6cc6f830b2511a8763a44abd8412f42" translate="yes" xml:space="preserve">
          <source>Disable the optimization pass that scans for opportunities to use &amp;ldquo;decrement and branch&amp;rdquo; instructions on a count register instead of instruction sequences that decrement a register, compare it against zero, and then branch based upon the result. This option is only meaningful on architectures that support such instructions, which include x86, PowerPC, IA-64 and S/390. Note that the</source>
          <target state="translated">禁用用于扫描在计数寄存器上使用&amp;ldquo;减量和转移&amp;rdquo;指令的机会的优化过程，而不是对减量寄存器进行比较的指令序列，将其与零进行比较，然后根据结果进行转移。该选项仅对支持此类指令的体系结构有意义，这些体系结构包括x86，PowerPC，IA-64和S / 390。请注意</target>
        </trans-unit>
        <trans-unit id="c15dc65887ffe75f7696788f129ef9f9ee6c4b19" translate="yes" xml:space="preserve">
          <source>Disable the use of conditional execution.</source>
          <target state="translated">禁止使用条件执行。</target>
        </trans-unit>
        <trans-unit id="47a29a4761de80ec38be8a0cf5e531389fb7bc55" translate="yes" xml:space="preserve">
          <source>Disable the use of conditional set instructions.</source>
          <target state="translated">禁止使用条件集指令。</target>
        </trans-unit>
        <trans-unit id="5cb2b9c6309800d129c0dac9ca4f0d952c4c16ba" translate="yes" xml:space="preserve">
          <source>Disable the use of conditional-move instructions.</source>
          <target state="translated">禁止使用条件移动指令。</target>
        </trans-unit>
        <trans-unit id="c4ab5898827402073a5b1c951bd92d3ef7f4f26a" translate="yes" xml:space="preserve">
          <source>Disable the warning about a throw-expression that will immediately result in a call to &lt;code&gt;terminate&lt;/code&gt;.</source>
          <target state="translated">禁用有关throw-expression的警告，该警告将立即导致调用 &lt;code&gt;terminate&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9e916b556b452967e0dcb5e2d11c70ff45829cad" translate="yes" xml:space="preserve">
          <source>Disable the warning about the case when a conversion function converts an object to the same type, to a base class of that type, or to void; such a conversion function will never be called.</source>
          <target state="translated">禁用关于转换函数将对象转换为相同类型、转换为该类型的基类或转换为void的情况的警告;这样的转换函数永远不会被调用。</target>
        </trans-unit>
        <trans-unit id="97813576f6a1f168ea49d44405f937b0428780d3" translate="yes" xml:space="preserve">
          <source>Disable transformations and optimizations that assume default floating-point rounding behavior. This is round-to-zero for all floating point to integer conversions, and round-to-nearest for all other arithmetic truncations. This option should be specified for programs that change the FP rounding mode dynamically, or that may be executed with a non-default rounding mode. This option disables constant folding of floating-point expressions at compile time (which may be affected by rounding mode) and arithmetic transformations that are unsafe in the presence of sign-dependent rounding modes.</source>
          <target state="translated">禁用假设默认浮点取整行为的转换和优化。对于所有的浮点到整数的转换都是四舍五入,对于所有其他的算术截断都是四舍五入。对于动态改变FP舍入模式的程序,或者可能以非默认舍入模式执行的程序,应该指定这个选项。这个选项禁止在编译时对浮点表达式进行恒定的折叠(可能会受到四舍五入模式的影响),也禁止在符号相关的四舍五入模式下进行不安全的算术变换。</target>
        </trans-unit>
        <trans-unit id="fa652af71b1d233eeae7ac973249eb12d16d530a" translate="yes" xml:space="preserve">
          <source>Disable tree pass &lt;var&gt;pass&lt;/var&gt;. See</source>
          <target state="translated">禁用树 &lt;var&gt;pass&lt;/var&gt; 。看到</target>
        </trans-unit>
        <trans-unit id="c43ef83976903738f93a9dacec55c01d9094fe2c" translate="yes" xml:space="preserve">
          <source>Disable use of the small data area. Variables are put into one of &lt;code&gt;.data&lt;/code&gt;, &lt;code&gt;.bss&lt;/code&gt;, or &lt;code&gt;.rodata&lt;/code&gt; (unless the &lt;code&gt;section&lt;/code&gt; attribute has been specified). This is the default.</source>
          <target state="translated">禁用小数据区域。变量被放入 &lt;code&gt;.data&lt;/code&gt; ， &lt;code&gt;.bss&lt;/code&gt; 或 &lt;code&gt;.rodata&lt;/code&gt; 之一（除非指定了 &lt;code&gt;section&lt;/code&gt; 属性）。这是默认值。</target>
        </trans-unit>
        <trans-unit id="dd6879ec12c29349f77ab51cc9ef664f2b926a46" translate="yes" xml:space="preserve">
          <source>Disable warnings when non-template friend functions are declared within a template. In very old versions of GCC that predate implementation of the ISO standard, declarations such as &amp;lsquo;</source>
          <target state="translated">在模板中声明非模板好友功能时，禁用警告。在早于ISO标准实施的GCC的较旧版本中，声明如&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="75de5d4a7b64d839362aa8d626128e23f7764239" translate="yes" xml:space="preserve">
          <source>Disabled at level</source>
          <target state="translated">伤残等级</target>
        </trans-unit>
        <trans-unit id="bf492e44698b816bac566d70d52b5954c19119dd" translate="yes" xml:space="preserve">
          <source>Disabled by default.</source>
          <target state="translated">默认情况下已禁用。</target>
        </trans-unit>
        <trans-unit id="aac880794e7e82b2a88791e338313ba16ba15074" translate="yes" xml:space="preserve">
          <source>Disables all the optional instructions enabled by</source>
          <target state="translated">禁用所有由</target>
        </trans-unit>
        <trans-unit id="870d995d131280874dc4cc508b91ef24ce1bb25e" translate="yes" xml:space="preserve">
          <source>Disables the SIMD (but not floating-point) instructions on &amp;lsquo;</source>
          <target state="translated">停用&amp;ldquo;&amp;rdquo;上的SIMD（但不使用浮点数）指令</target>
        </trans-unit>
        <trans-unit id="a27996206286cd961e06403639946454e47385b1" translate="yes" xml:space="preserve">
          <source>Disables the double-precision component of the floating-point instructions on &amp;lsquo;</source>
          <target state="translated">在'上禁用浮点指令的双精度组件</target>
        </trans-unit>
        <trans-unit id="f08047d7bdf26e21f60892f7f2f9f2faee1af25c" translate="yes" xml:space="preserve">
          <source>Disables the floating-point instructions on &amp;lsquo;</source>
          <target state="translated">禁用&amp;ldquo;上的浮点指令&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="df9e25965e3555d25ff57722cb18d00af55afb9e" translate="yes" xml:space="preserve">
          <source>Disables warnings about the generation of inefficient code. These warnings can be generated, for example, when compiling code that performs byte-level memory operations on the MAC AE type. The MAC AE has no hardware support for byte-level memory operations, so all byte load/stores must be synthesized from word load/store operations. This is inefficient and a warning is generated to indicate that you should rewrite the code to avoid byte operations, or to target an AE type that has the necessary hardware support. This option disables these warnings.</source>
          <target state="translated">禁用关于产生低效代码的警告。例如,当编译在MAC AE类型上执行字节级内存操作的代码时,可能会产生这些警告。MAC AE没有对字节级内存操作的硬件支持,因此所有字节加载/存储必须从字加载/存储操作中合成。这是很低效的,并且会产生一个警告,提示您应该重写代码以避免字节操作,或者以具有必要硬件支持的AE类型为目标。这个选项可以禁用这些警告。</target>
        </trans-unit>
        <trans-unit id="8c83476e13772d4a0c7d47269ca8280ee489e48a" translate="yes" xml:space="preserve">
          <source>Disallow using extensions of later DWARF standard version than selected with</source>
          <target state="translated">不允许使用DWARF标准版本以后的扩展,而不允许用</target>
        </trans-unit>
        <trans-unit id="48fef3c4f4f198a3fc747aaf4241ba4c8fd572a6" translate="yes" xml:space="preserve">
          <source>Discover read-only, write-only and non-addressable static variables. Enabled by default at</source>
          <target state="translated">发现只读、只写和不可寻址的静态变量。默认在</target>
        </trans-unit>
        <trans-unit id="fcb652ea128e958ac5cce84cb6ef8250a1be8fe4" translate="yes" xml:space="preserve">
          <source>Discover which functions are pure or constant. Enabled by default at</source>
          <target state="translated">发现哪些函数是纯函数或常量函数。默认在</target>
        </trans-unit>
        <trans-unit id="a208f773f4cc31e2ce047d428bfcf70af185cc47" translate="yes" xml:space="preserve">
          <source>Discover which static variables do not escape the compilation unit. Enabled by default at</source>
          <target state="translated">发现哪些静态变量不逃逸编译单元。默认在</target>
        </trans-unit>
        <trans-unit id="651cd5d45dfead116269d73c1f57b41b4dbd0dc9" translate="yes" xml:space="preserve">
          <source>Dispatching a call to another function.</source>
          <target state="translated">调度对另一个函数的调用。</target>
        </trans-unit>
        <trans-unit id="81b470ecff5209cbe640ee9ba4362aba6ca2d2e9" translate="yes" xml:space="preserve">
          <source>Display all of the optimization options supported by the compiler.</source>
          <target state="translated">显示编译器支持的所有优化选项。</target>
        </trans-unit>
        <trans-unit id="72c8c0bfdf122469f724652953f16cbdb6f10057" translate="yes" xml:space="preserve">
          <source>Display all of the options controlling warning messages produced by the compiler.</source>
          <target state="translated">显示所有控制编译器产生的警告信息的选项。</target>
        </trans-unit>
        <trans-unit id="aed462cd18dddfb7255b08046613981f43dcc83d" translate="yes" xml:space="preserve">
          <source>Display demangled function names in output. The default is to show mangled function names.</source>
          <target state="translated">在输出中显示已解密的函数名。默认情况下是显示杂乱的函数名。</target>
        </trans-unit>
        <trans-unit id="265008e8627ab28c29c4c783e5dfd9614fe2af35" translate="yes" xml:space="preserve">
          <source>Display help about using &lt;code&gt;gcov-dump&lt;/code&gt; (on the standard output), and exit without doing any further processing.</source>
          <target state="translated">显示有关使用 &lt;code&gt;gcov-dump&lt;/code&gt; 的帮助（在标准输出上），然后不做任何进一步处理就退出。</target>
        </trans-unit>
        <trans-unit id="e12fbb96aff9cead22e458e9ec3c8f5e63fa5684" translate="yes" xml:space="preserve">
          <source>Display help about using &lt;code&gt;gcov-tool&lt;/code&gt; (on the standard output), and exit without doing any further processing.</source>
          <target state="translated">显示有关使用 &lt;code&gt;gcov-tool&lt;/code&gt; 的帮助（在标准输出上），然后不做任何进一步处理就退出。</target>
        </trans-unit>
        <trans-unit id="c2a32dd6399128ea64f2e8805722cf5f0f40906c" translate="yes" xml:space="preserve">
          <source>Display help about using &lt;code&gt;gcov&lt;/code&gt; (on the standard output), and exit without doing any further processing.</source>
          <target state="translated">显示有关使用 &lt;code&gt;gcov&lt;/code&gt; 的帮助（在标准输出上），然后退出而不进行任何进一步处理。</target>
        </trans-unit>
        <trans-unit id="05abc5bf9b915eda30e5f0fa5412f4d00c71675a" translate="yes" xml:space="preserve">
          <source>Display only those options that are undocumented.</source>
          <target state="translated">只显示未记录的选项。</target>
        </trans-unit>
        <trans-unit id="f03b0f7a546ee49a503453f7975e25ffe065c35f" translate="yes" xml:space="preserve">
          <source>Display options taking an argument that appears after an equal sign in the same continuous piece of text, such as: &amp;lsquo;</source>
          <target state="translated">显示选项带有一个参数，该参数出现在同一连续文本中的等号之后，例如：'</target>
        </trans-unit>
        <trans-unit id="78dd198d091922fefb8d713c3d97e47984a683e2" translate="yes" xml:space="preserve">
          <source>Display options taking an argument that appears as a separate word following the original option, such as: &amp;lsquo;</source>
          <target state="translated">显示选项带有一个参数，该参数在原始选项之后显示为单独的单词，例如：'</target>
        </trans-unit>
        <trans-unit id="3034576017d5b01854a8c0bd7d19d6bd34b0118e" translate="yes" xml:space="preserve">
          <source>Display target-specific options. Unlike the</source>
          <target state="translated">显示特定目标的选项。与</target>
        </trans-unit>
        <trans-unit id="344037446b18226df15907aaf4b6b36a2c93c89d" translate="yes" xml:space="preserve">
          <source>Display the &lt;code&gt;gcov-dump&lt;/code&gt; version number (on the standard output), and exit without doing any further processing.</source>
          <target state="translated">显示 &lt;code&gt;gcov-dump&lt;/code&gt; 版本号（在标准输出上），然后不做任何进一步处理就退出。</target>
        </trans-unit>
        <trans-unit id="35cc61bd60aed0586a7ab81a239eee8b50af7443" translate="yes" xml:space="preserve">
          <source>Display the &lt;code&gt;gcov-tool&lt;/code&gt; version number (on the standard output), and exit without doing any further processing.</source>
          <target state="translated">显示 &lt;code&gt;gcov-tool&lt;/code&gt; 版本号（在标准输出上），然后不做任何进一步处理就退出。</target>
        </trans-unit>
        <trans-unit id="b6e074d4004bd50fbdfdcf5bba3331e5f56c291a" translate="yes" xml:space="preserve">
          <source>Display the &lt;code&gt;gcov&lt;/code&gt; version number (on the standard output), and exit without doing any further processing.</source>
          <target state="translated">显示 &lt;code&gt;gcov&lt;/code&gt; 版本号（在标准输出上），然后不做任何进一步处理就退出。</target>
        </trans-unit>
        <trans-unit id="cef9fe7c4ae3fd66d0616ac76fb1a92ba4cf451e" translate="yes" xml:space="preserve">
          <source>Display the options supported for &lt;var&gt;language&lt;/var&gt;, where &lt;var&gt;language&lt;/var&gt; is the name of one of the languages supported in this version of GCC.</source>
          <target state="translated">显示 &lt;var&gt;language&lt;/var&gt; 支持的选项，其中 &lt;var&gt;language&lt;/var&gt; 是此版本的GCC支持的一种语言的名称。</target>
        </trans-unit>
        <trans-unit id="9ab2c82abfc8159be6e9fa8d50b69489311c099e" translate="yes" xml:space="preserve">
          <source>Display the options that are common to all languages.</source>
          <target state="translated">显示所有语言通用的选项。</target>
        </trans-unit>
        <trans-unit id="0ec31abb5e51897ba8130f63f01229988bd5728b" translate="yes" xml:space="preserve">
          <source>Display the progress on the standard output.</source>
          <target state="translated">在标准输出上显示进度。</target>
        </trans-unit>
        <trans-unit id="6dbb61eb69b04350133e621d0c73b06d5ccc9c5b" translate="yes" xml:space="preserve">
          <source>Display the values recognized by the</source>
          <target state="translated">识别值的显示</target>
        </trans-unit>
        <trans-unit id="34d093aadfdac161b403733078a63e69c40898c6" translate="yes" xml:space="preserve">
          <source>Display the version number and copyrights of the invoked GCC.</source>
          <target state="translated">显示调用的GCC的版本号和版权。</target>
        </trans-unit>
        <trans-unit id="26dfbbd6de78ea5ea887b6576aa7df3d1cced839" translate="yes" xml:space="preserve">
          <source>Disregard strict standards compliance.</source>
          <target state="translated">无视严格的标准遵守。</target>
        </trans-unit>
        <trans-unit id="810ca5fb4bf9b88327a090dfa7228390b8a8933b" translate="yes" xml:space="preserve">
          <source>Distances are measured from the beginning of functions when using the</source>
          <target state="translated">当使用该函数时,从函数开始测量距离。</target>
        </trans-unit>
        <trans-unit id="700c5d1f81b1eabfd1898baf4899894e603c6ec2" translate="yes" xml:space="preserve">
          <source>Distinguish between prefix and postfix forms of increment and decrement operators.</source>
          <target state="translated">区分增减运算符的前缀和后缀形式。</target>
        </trans-unit>
        <trans-unit id="15d45d388da758d77a316f2815f529d6f4aa8a47" translate="yes" xml:space="preserve">
          <source>Do (don&amp;rsquo;t) generate code that uses the fused multiply/add or multiply/subtract instructions. The default is to use these instructions.</source>
          <target state="translated">不要（不）生成使用融合的乘/加或乘/减指令的代码。默认值为使用这些说明。</target>
        </trans-unit>
        <trans-unit id="fa3eae74d7b2c9843e7a1a146ef2fdd2dc03d4df" translate="yes" xml:space="preserve">
          <source>Do alignment optimizations for call instructions.</source>
          <target state="translated">对调用指令做对齐优化。</target>
        </trans-unit>
        <trans-unit id="66402eadff3f8314991b18d5e3fc15f2b633b72a" translate="yes" xml:space="preserve">
          <source>Do not (do) assume that unaligned memory references are handled by the system.</source>
          <target state="translated">不要(做)假设未对齐的内存引用由系统处理。</target>
        </trans-unit>
        <trans-unit id="54f30aa11a7322472ca655cc5794b473a6db2cb4" translate="yes" xml:space="preserve">
          <source>Do not affect the &lt;code&gt;long_call&lt;/code&gt; or &lt;code&gt;short_call&lt;/code&gt; attributes of subsequent functions.</source>
          <target state="translated">不要影响后续函数的 &lt;code&gt;long_call&lt;/code&gt; 或 &lt;code&gt;short_call&lt;/code&gt; 属性。</target>
        </trans-unit>
        <trans-unit id="1d4def84337c056fee739188d13fda579c041fe7" translate="yes" xml:space="preserve">
          <source>Do not align the destination of inlined string operations. This switch reduces code size and improves performance in case the destination is already aligned, but GCC doesn&amp;rsquo;t know about it.</source>
          <target state="translated">不要对齐内联字符串操作的目标。如果目标已经对齐，则此开关减小了代码大小并提高了性能，但GCC对此一无所知。</target>
        </trans-unit>
        <trans-unit id="0de4bbafb6a75d9a2bf9d1dffc4ce55c0685a9e6" translate="yes" xml:space="preserve">
          <source>Do not allow constant data to be placed in code sections. Additionally, when compiling for ELF object format give all text sections the ELF processor-specific section attribute &lt;code&gt;SHF_ARM_PURECODE&lt;/code&gt;. This option is only available when generating non-pic code for M-profile targets with the MOVT instruction.</source>
          <target state="translated">不允许将常量数据放在代码段中。此外，在为ELF对象格式进行编译时，请为所有文本部分提供ELF处理器特定的部分属性 &lt;code&gt;SHF_ARM_PURECODE&lt;/code&gt; 。仅当使用MOVT指令为M轮廓目标生成非图片代码时，此选项才可用。</target>
        </trans-unit>
        <trans-unit id="03d8305d540b6aba4d4042404329e432ca465541" translate="yes" xml:space="preserve">
          <source>Do not allow the built-in functions &lt;code&gt;ceil&lt;/code&gt;, &lt;code&gt;floor&lt;/code&gt;, &lt;code&gt;round&lt;/code&gt; and &lt;code&gt;trunc&lt;/code&gt;, and their &lt;code&gt;float&lt;/code&gt; and &lt;code&gt;long
double&lt;/code&gt; variants, to generate code that raises the &amp;ldquo;inexact&amp;rdquo; floating-point exception for noninteger arguments. ISO C99 and C11 allow these functions to raise the &amp;ldquo;inexact&amp;rdquo; exception, but ISO/IEC TS 18661-1:2014, the C bindings to IEEE 754-2008, does not allow these functions to do so.</source>
          <target state="translated">不允许内置函数 &lt;code&gt;ceil&lt;/code&gt; ， &lt;code&gt;floor&lt;/code&gt; ， &lt;code&gt;round&lt;/code&gt; 和 &lt;code&gt;trunc&lt;/code&gt; 以及它们的 &lt;code&gt;float&lt;/code&gt; 和 &lt;code&gt;long double&lt;/code&gt; 变体生成用于引发非整数参数&amp;ldquo; inexact&amp;rdquo;浮点异常的代码。ISO C99和C11允许这些功能引发&amp;ldquo; inexact&amp;rdquo;异常，但是ISO / IEC TS 18661-1：2014（对IEEE 754-2008的C绑定）不允许这些功能这样做。</target>
        </trans-unit>
        <trans-unit id="f3ff2c5279a75029bc339b07e7530899c9302db8" translate="yes" xml:space="preserve">
          <source>Do not allow the compiler to generate &lt;em&gt;Long Instruction Word&lt;/em&gt; instructions. This option defines the preprocessor macro &lt;code&gt;__NO_LIW__&lt;/code&gt;.</source>
          <target state="translated">不允许编译器生&lt;em&gt;成长指令字&lt;/em&gt;指令。此选项定义预处理器宏 &lt;code&gt;__NO_LIW__&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="308fe4eb96a98c640686f8d44a99dca853e4e2bc" translate="yes" xml:space="preserve">
          <source>Do not allow the compiler to generate &lt;em&gt;SETLB&lt;/em&gt; or &lt;em&gt;Lcc&lt;/em&gt; instructions. This option defines the preprocessor macro &lt;code&gt;__NO_SETLB__&lt;/code&gt;.</source>
          <target state="translated">不允许编译器生成&lt;em&gt;SETLB&lt;/em&gt;或&lt;em&gt;Lcc&lt;/em&gt;指令。此选项定义预处理器宏 &lt;code&gt;__NO_SETLB__&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c30c06515f3c7a9db38f03e0071054e61d0d6bea" translate="yes" xml:space="preserve">
          <source>Do not apply the &lt;code&gt;longcall&lt;/code&gt; attribute to subsequent function declarations.</source>
          <target state="translated">不要将 &lt;code&gt;longcall&lt;/code&gt; 属性应用于后续函数声明。</target>
        </trans-unit>
        <trans-unit id="6c726465b100e603972419cccdc343f480a4a19b" translate="yes" xml:space="preserve">
          <source>Do not assume a large TLS segment when generating thread-local code.</source>
          <target state="translated">在生成线程本地代码时,不要假设一个大的TLS段。</target>
        </trans-unit>
        <trans-unit id="728fc451cc179eebcc18f5c6344c5c0c36dd581d" translate="yes" xml:space="preserve">
          <source>Do not assume that registers saved by the calling function are restored before calling the &lt;code&gt;noreturn&lt;/code&gt; function.</source>
          <target state="translated">不要假设在调用 &lt;code&gt;noreturn&lt;/code&gt; 函数之前已恢复调用函数保存的寄存器。</target>
        </trans-unit>
        <trans-unit id="e33e43a1033f382fce00f6b8091a2ad6b0b4e974" translate="yes" xml:space="preserve">
          <source>Do not assume that the code being compiled won&amp;rsquo;t link against any ID shared libraries. Slower code is generated for jump and call insns.</source>
          <target state="translated">不要以为正在编译的代码不会链接到任何ID共享库。为跳转和调用insns生成了较慢的代码。</target>
        </trans-unit>
        <trans-unit id="91704a7cde69df99e26557a8fcaceedc0c021417" translate="yes" xml:space="preserve">
          <source>Do not assume the width of floating-point registers.</source>
          <target state="translated">不要假设浮点寄存器的宽度。</target>
        </trans-unit>
        <trans-unit id="56a17068976fe756a1e89e46ec309c06e7526fbb" translate="yes" xml:space="preserve">
          <source>Do not attempt to schedule the preceding instruction into the delay slot of a branch instruction placed at the end of a short loop of six instructions or fewer and always schedule a &lt;code&gt;nop&lt;/code&gt; instruction there instead. The short loop bug under certain conditions causes loops to execute only once or twice, due to a hardware bug in the R5900 chip. The workaround is implemented by the assembler rather than by GCC.</source>
          <target state="translated">不要试图将前一条指令调度到位于六个或更少指令的短循环末尾的分支指令的延迟槽中，而应始终在那里调度一个 &lt;code&gt;nop&lt;/code&gt; 指令。由于R5900芯片中的硬件错误，在某些情况下的短循环错误会导致循环仅执行一次或两次。解决方法是由汇编程序而非GCC实施。</target>
        </trans-unit>
        <trans-unit id="d2be752bd5c8aabe79c7a8b900f158b404d70833" translate="yes" xml:space="preserve">
          <source>Do not consider type &lt;code&gt;int&lt;/code&gt; to be 16 bits wide. This is the default.</source>
          <target state="translated">不要认为 &lt;code&gt;int&lt;/code&gt; 类型为16位宽。这是默认值。</target>
        </trans-unit>
        <trans-unit id="08c20a0490ee73056523e456a376bd15da68e3f1" translate="yes" xml:space="preserve">
          <source>Do not create the &lt;code&gt;gcov&lt;/code&gt; output file.</source>
          <target state="translated">不要创建 &lt;code&gt;gcov&lt;/code&gt; 输出文件。</target>
        </trans-unit>
        <trans-unit id="61bd4083e901aa03be2fec075c5a07232b9c93d4" translate="yes" xml:space="preserve">
          <source>Do not discard comments, including during macro expansion. This is like</source>
          <target state="translated">不要丢弃评论,包括在宏扩展期间。这就像</target>
        </trans-unit>
        <trans-unit id="094e1651c852304b7a16e16ed4d0185ecd59b26b" translate="yes" xml:space="preserve">
          <source>Do not discard comments. All comments are passed through to the output file, except for comments in processed directives, which are deleted along with the directive.</source>
          <target state="translated">不要丢弃注释。所有的注释都会被传递到输出文件中,但经过处理的指令中的注释除外,这些注释会和指令一起被删除。</target>
        </trans-unit>
        <trans-unit id="91b2c99fa330a126f06708c6cdfa9c96a1c2ca48" translate="yes" xml:space="preserve">
          <source>Do not emit instructions with side effects in addressing modes other than post-increment.</source>
          <target state="translated">不要在后增量以外的寻址模式下发出有副作用的指令。</target>
        </trans-unit>
        <trans-unit id="8e8fcc0f33555f7707b3fe0e2c86d30a856ae4de" translate="yes" xml:space="preserve">
          <source>Do not emit the extra code to use the routines specified in the C++ ABI for thread-safe initialization of local statics. You can use this option to reduce code size slightly in code that doesn&amp;rsquo;t need to be thread-safe.</source>
          <target state="translated">不要发出多余的代码来使用C ++ ABI中指定的例程对本地静态变量进行线程安全的初始化。您可以使用此选项在不需要线程安全的代码中稍微减小代码大小。</target>
        </trans-unit>
        <trans-unit id="a50320f9ab85e604d11edb3fea826b2a1de37844" translate="yes" xml:space="preserve">
          <source>Do not enforce a 32-byte alignment for loops. This is the default.</source>
          <target state="translated">不对循环执行32字节的对齐方式。这是默认的。</target>
        </trans-unit>
        <trans-unit id="891fab210e7a9b122822bf86387a01881f014d38" translate="yes" xml:space="preserve">
          <source>Do not expand any functions inline apart from those marked with the &lt;code&gt;always_inline&lt;/code&gt; attribute. This is the default when not optimizing.</source>
          <target state="translated">除了标有 &lt;code&gt;always_inline&lt;/code&gt; 属性的功能外，请勿展开任何内联功能。这是未优化时的默认设置。</target>
        </trans-unit>
        <trans-unit id="e55929ae438e9efde315189f7933071caa5c75d9" translate="yes" xml:space="preserve">
          <source>Do not expand any symbolic links, resolve references to &amp;lsquo;</source>
          <target state="translated">请勿展开任何符号链接，而是将对&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="76bc4e801782e79c379029a2b2d98ead9b1c58f2" translate="yes" xml:space="preserve">
          <source>Do not expect a sequence of &lt;code&gt;asm&lt;/code&gt; statements to remain perfectly consecutive after compilation, even when you are using the &lt;code&gt;volatile&lt;/code&gt; qualifier. If certain instructions need to remain consecutive in the output, put them in a single multi-instruction &lt;code&gt;asm&lt;/code&gt; statement.</source>
          <target state="translated">即使在使用 &lt;code&gt;volatile&lt;/code&gt; 限定符时，也不要期望 &lt;code&gt;asm&lt;/code&gt; 语句序列在编译后能保持完美连续。如果某些指令需要在输出中保持连续，请将它们放在单个多指令 &lt;code&gt;asm&lt;/code&gt; 语句中。</target>
        </trans-unit>
        <trans-unit id="1357d76978b996f4f01f805d2256a79e656aef14" translate="yes" xml:space="preserve">
          <source>Do not expect a sequence of &lt;code&gt;asm&lt;/code&gt; statements to remain perfectly consecutive after compilation. If certain instructions need to remain consecutive in the output, put them in a single multi-instruction &lt;code&gt;asm&lt;/code&gt; statement. Note that GCC&amp;rsquo;s optimizers can move &lt;code&gt;asm&lt;/code&gt; statements relative to other code, including across jumps.</source>
          <target state="translated">不要期望 &lt;code&gt;asm&lt;/code&gt; 后的一系列asm语句保持完美连续。如果某些指令需要在输出中保持连续，请将它们放在单个多指令 &lt;code&gt;asm&lt;/code&gt; 语句中。请注意，GCC的优化程序可以相对于其他代码移动 &lt;code&gt;asm&lt;/code&gt; 语句，包括跨跳转。</target>
        </trans-unit>
        <trans-unit id="84b3d7d09c0c54d717842f06c98dbd62ec42f930" translate="yes" xml:space="preserve">
          <source>Do not generate 16-bit instructions.</source>
          <target state="translated">不要生成16位指令。</target>
        </trans-unit>
        <trans-unit id="ad6e921329e0de0a14badc58726b2429a811f03b" translate="yes" xml:space="preserve">
          <source>Do not generate &lt;code&gt;mpy&lt;/code&gt;-family instructions for ARC700. This option is deprecated.</source>
          <target state="translated">不要为ARC700 生成 &lt;code&gt;mpy&lt;/code&gt; -family指令。不建议使用此选项。</target>
        </trans-unit>
        <trans-unit id="677bb296fc46c470e0c30284fe52bf50c8bf95e0" translate="yes" xml:space="preserve">
          <source>Do not generate GP-relative accesses.</source>
          <target state="translated">不要产生GP相关的访问。</target>
        </trans-unit>
        <trans-unit id="f71d5f68821b30e885b1156b06fcb682f984e58f" translate="yes" xml:space="preserve">
          <source>Do not generate code that can only run in supervisor mode. This is relevant only for the &lt;code&gt;casa&lt;/code&gt; instruction emitted for the LEON3 processor. This is the default.</source>
          <target state="translated">不要生成只能在超级用户模式下运行的代码。这仅与LEON3处理器发出的 &lt;code&gt;casa&lt;/code&gt; 指令有关。这是默认值。</target>
        </trans-unit>
        <trans-unit id="0295c6ec8a8e0c073456a9cdaa9ef67d389ca72d" translate="yes" xml:space="preserve">
          <source>Do not generate code that reads program memory.</source>
          <target state="translated">不要生成读取程序内存的代码。</target>
        </trans-unit>
        <trans-unit id="2a55e3aa2938e0b388b8a2f34ed44323717c2975" translate="yes" xml:space="preserve">
          <source>Do not generate code to avoid bugs in the multiply instructions for the MN10300 processors.</source>
          <target state="translated">不要生成代码,以避免MN10300处理器的乘法指令出现错误。</target>
        </trans-unit>
        <trans-unit id="6775dd83d160f5e2159511baea19387bf2da721f" translate="yes" xml:space="preserve">
          <source>Do not generate code using features specific to the AM33 processor. This is the default.</source>
          <target state="translated">不要使用AM33处理器特有的功能生成代码。这是默认的。</target>
        </trans-unit>
        <trans-unit id="159947dfd1a4fc3fd4fb823f295379e5ec4d1e29" translate="yes" xml:space="preserve">
          <source>Do not generate conditional move instructions.</source>
          <target state="translated">不要产生有条件的移动指令。</target>
        </trans-unit>
        <trans-unit id="2a7c63697c44693e6c631b03a4bcdf4c623d8e94" translate="yes" xml:space="preserve">
          <source>Do not generate floating-point instructions; use library calls instead. This is the default for 68000, 68010, and 68832 targets. It is also the default for ColdFire devices that have no FPU.</source>
          <target state="translated">不要生成浮点指令,而使用库调用。这是68000、68010和68832目标的默认值。这也是没有FPU的ColdFire设备的默认值。</target>
        </trans-unit>
        <trans-unit id="2cc223b18a9c8fe85db4c5fdd1a4568ac5523351" translate="yes" xml:space="preserve">
          <source>Do not generate inline code for &lt;code&gt;sqrt&lt;/code&gt;.</source>
          <target state="translated">不要为 &lt;code&gt;sqrt&lt;/code&gt; 生成内联代码。</target>
        </trans-unit>
        <trans-unit id="7dccee88899cb101fdf1122d7b6f87cc5ad98128" translate="yes" xml:space="preserve">
          <source>Do not generate inline code for divides of floating-point values.</source>
          <target state="translated">不要为浮点值的除法生成内联代码。</target>
        </trans-unit>
        <trans-unit id="db0d6f198e71d6a0581c6b52ba5d158f3703dad4" translate="yes" xml:space="preserve">
          <source>Do not generate inline code for divides of integer values.</source>
          <target state="translated">不要生成整数值除法的内联代码。</target>
        </trans-unit>
        <trans-unit id="5bf145c70d37b823fa320934be3a45f2f5b58879" translate="yes" xml:space="preserve">
          <source>Do not generate performance extension 2 instructions.</source>
          <target state="translated">不要产生性能扩展2指令。</target>
        </trans-unit>
        <trans-unit id="3b1b47a62d265ff0109bc6fe295c353c7dfbd942" translate="yes" xml:space="preserve">
          <source>Do not generate performance extension instructions.</source>
          <target state="translated">不要产生性能扩展指令。</target>
        </trans-unit>
        <trans-unit id="b028375dbf2397374ef15ae6807634be0bef9937" translate="yes" xml:space="preserve">
          <source>Do not generate sdata references. This is the default for tool chains built for &lt;code&gt;arc-linux-uclibc&lt;/code&gt; and &lt;code&gt;arceb-linux-uclibc&lt;/code&gt; targets.</source>
          <target state="translated">不生成sdata引用。这是为 &lt;code&gt;arc-linux-uclibc&lt;/code&gt; 和 &lt;code&gt;arceb-linux-uclibc&lt;/code&gt; 目标构建的工具链的默认设置。</target>
        </trans-unit>
        <trans-unit id="543afe0ee34f2553275fc1e0d4f92ae4d031e11e" translate="yes" xml:space="preserve">
          <source>Do not generate string extension instructions.</source>
          <target state="translated">不要生成字符串扩展指令。</target>
        </trans-unit>
        <trans-unit id="35172dff465f7db05c87cd9d0fa618a5943366ff" translate="yes" xml:space="preserve">
          <source>Do not generate v3 push25/pop25 instructions.</source>
          <target state="translated">不要生成v3 push25/pop25指令。</target>
        </trans-unit>
        <trans-unit id="57a412ef71d36d080e33196062eae1a348ffd9a5" translate="yes" xml:space="preserve">
          <source>Do not guess branch probabilities using heuristics.</source>
          <target state="translated">不要用启发式方法猜测分支概率。</target>
        </trans-unit>
        <trans-unit id="c3b0780d488de79c8fb5609252ace9e026b5485c" translate="yes" xml:space="preserve">
          <source>Do not link in the C run-time initialization object file.</source>
          <target state="translated">不要在C语言运行时初始化对象文件中进行链接。</target>
        </trans-unit>
        <trans-unit id="1be7375d07ff18651b91e6f0b8f72660024d9706" translate="yes" xml:space="preserve">
          <source>Do not mark ABI switches in e_flags.</source>
          <target state="translated">不要在e_flags中标记ABI开关。</target>
        </trans-unit>
        <trans-unit id="431d0ac813eff431a021eadf038696c3b8c0a701" translate="yes" xml:space="preserve">
          <source>Do not optimize (do optimize) basic blocks that use the same index pointer 4 or more times to copy pointer into the &lt;code&gt;ep&lt;/code&gt; register, and use the shorter &lt;code&gt;sld&lt;/code&gt; and &lt;code&gt;sst&lt;/code&gt; instructions. The</source>
          <target state="translated">不要优化（执行优化）使用相同索引指针4次或更多次的基本块，以将指针复制到 &lt;code&gt;ep&lt;/code&gt; 寄存器中，并使用较短的 &lt;code&gt;sld&lt;/code&gt; 和 &lt;code&gt;sst&lt;/code&gt; 指令。的</target>
        </trans-unit>
        <trans-unit id="79c5f07fbe7818d1561eea80118156e770e03da3" translate="yes" xml:space="preserve">
          <source>Do not optimize block moves, use &lt;code&gt;memcpy&lt;/code&gt;.</source>
          <target state="translated">不要优化块移动，请使用 &lt;code&gt;memcpy&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1c81bdb6603f6660bfebcf5b1c10715d6960adf2" translate="yes" xml:space="preserve">
          <source>Do not or do generate unaligned memory accesses. The default is set depending on whether the processor we are optimizing for supports fast unaligned access or not.</source>
          <target state="translated">不产生或不产生不对齐的内存访问。默认值的设置取决于我们优化的处理器是否支持快速不对齐访问。</target>
        </trans-unit>
        <trans-unit id="4a89ae960644f6dae44b3cb05c0d0550f4cbdda0" translate="yes" xml:space="preserve">
          <source>Do not output certain jump instructions (&lt;code&gt;aobleq&lt;/code&gt; and so on) that the Unix assembler for the VAX cannot handle across long ranges.</source>
          <target state="translated">不要输出某些用于VAX的Unix汇编程序无法跨长距离处理的跳转指令（ &lt;code&gt;aobleq&lt;/code&gt; 等）。</target>
        </trans-unit>
        <trans-unit id="f8a3ee3da0c5dc6481bc333868effaef20cfecb3" translate="yes" xml:space="preserve">
          <source>Do not pack VLIW instructions.</source>
          <target state="translated">不要包装VLIW说明书。</target>
        </trans-unit>
        <trans-unit id="5cf0a2e01f314e50aac688fcc0637765ffe183d2" translate="yes" xml:space="preserve">
          <source>Do not predefine any system-specific or GCC-specific macros. The standard predefined macros remain defined.</source>
          <target state="translated">不要预先定义任何系统专用或GCC专用宏。标准的预定义宏仍然被定义。</target>
        </trans-unit>
        <trans-unit id="490cb97bfac29c7944f438d394a40917ab27b463" translate="yes" xml:space="preserve">
          <source>Do not print column numbers in diagnostics. This may be necessary if diagnostics are being scanned by a program that does not understand the column numbers, such as &lt;code&gt;dejagnu&lt;/code&gt;.</source>
          <target state="translated">不要在诊断中打印列号。如果诊断程序是由不了解列号的程序（例如 &lt;code&gt;dejagnu&lt;/code&gt; )扫描的，则可能有必要。</target>
        </trans-unit>
        <trans-unit id="5a166eec1d3e160d989368c024582f88a817fbe4" translate="yes" xml:space="preserve">
          <source>Do not put function addresses in registers; make each instruction that calls a constant function contain the function&amp;rsquo;s address explicitly.</source>
          <target state="translated">不要将功能地址放在寄存器中；使每个调用常量函数的指令显式包含该函数的地址。</target>
        </trans-unit>
        <trans-unit id="42d099b873c7985f112edf3c200fc2a3b03ec5d0" translate="yes" xml:space="preserve">
          <source>Do not recognize &lt;code&gt;asm&lt;/code&gt;, &lt;code&gt;inline&lt;/code&gt; or &lt;code&gt;typeof&lt;/code&gt; as a keyword, so that code can use these words as identifiers. You can use the keywords &lt;code&gt;__asm__&lt;/code&gt;, &lt;code&gt;__inline__&lt;/code&gt; and &lt;code&gt;__typeof__&lt;/code&gt; instead.</source>
          <target state="translated">不要将 &lt;code&gt;asm&lt;/code&gt; ， &lt;code&gt;inline&lt;/code&gt; 或 &lt;code&gt;typeof&lt;/code&gt; 识别为关键字，以便代码可以将这些单词用作标识符。您可以使用关键字 &lt;code&gt;__asm__&lt;/code&gt; ， &lt;code&gt;__inline__&lt;/code&gt; 和 &lt;code&gt;__typeof__&lt;/code&gt; 代替。</target>
        </trans-unit>
        <trans-unit id="4748c7a1ef517bb9ba562d1dfbac2e153a84b556" translate="yes" xml:space="preserve">
          <source>Do not recognize &lt;code&gt;typeof&lt;/code&gt; as a keyword, so that code can use this word as an identifier. You can use the keyword &lt;code&gt;__typeof__&lt;/code&gt; instead. This option is implied by the strict ISO C++ dialects:</source>
          <target state="translated">不要将 &lt;code&gt;typeof&lt;/code&gt; 识别为关键字，以便代码可以将此词用作标识符。您可以改用关键字 &lt;code&gt;__typeof__&lt;/code&gt; 。严格的ISO C ++方言暗含此选项：</target>
        </trans-unit>
        <trans-unit id="0184fc6ad01e42f8636e2c8922ca8fae3a1d46de" translate="yes" xml:space="preserve">
          <source>Do not reorder functions or variables marked &lt;code&gt;no_reorder&lt;/code&gt; against each other or top level assembler statements the executable. The actual order in the program will depend on the linker command line. Static variables marked like this are also not removed. This has a similar effect as the</source>
          <target state="translated">请勿将标有 &lt;code&gt;no_reorder&lt;/code&gt; 的函数或变量彼此重新排序，也不要在顶级汇编器语句中对可执行文件进行重新排序。程序中的实际顺序将取决于链接器命令行。标记为这样的静态变量也不会被删除。这与</target>
        </trans-unit>
        <trans-unit id="8ddac79842e7bae2915ad838f14a89d8d6021356" translate="yes" xml:space="preserve">
          <source>Do not reorder top-level functions, variables, and &lt;code&gt;asm&lt;/code&gt; statements. Output them in the same order that they appear in the input file. When this option is used, unreferenced static variables are not removed. This option is intended to support existing code that relies on a particular ordering. For new code, it is better to use attributes when possible.</source>
          <target state="translated">不要对顶级函数，变量和 &lt;code&gt;asm&lt;/code&gt; 语句重新排序。按照它们在输入文件中出现的顺序输出它们。使用此选项时，不会删除未引用的静态变量。此选项旨在支持依赖特定顺序的现有代码。对于新代码，最好尽可能使用属性。</target>
        </trans-unit>
        <trans-unit id="e09f89632800cad3603644ff83e1a579b7e4eb4f" translate="yes" xml:space="preserve">
          <source>Do not run a pass to pack branches into VLIW instructions.</source>
          <target state="translated">不要运行通证将分支打包成VLIW指令。</target>
        </trans-unit>
        <trans-unit id="0dba1f61030583d8ab48fd80d73e6a5afaf9d194" translate="yes" xml:space="preserve">
          <source>Do not save registers in &lt;code&gt;main&lt;/code&gt;. The effect is the same like attaching attribute &lt;a href=&quot;avr-function-attributes#AVR-Function-Attributes&quot;&gt;&lt;code&gt;OS_task&lt;/code&gt;&lt;/a&gt; to &lt;code&gt;main&lt;/code&gt;. It is activated per default if optimization is on.</source>
          <target state="translated">不要将寄存器保存在 &lt;code&gt;main&lt;/code&gt; 中。效果与将属性&lt;a href=&quot;avr-function-attributes#AVR-Function-Attributes&quot;&gt; &lt;code&gt;OS_task&lt;/code&gt; &lt;/a&gt;附加到 &lt;code&gt;main&lt;/code&gt; 相同。如果启用了优化，则默认情况下会激活它。</target>
        </trans-unit>
        <trans-unit id="9b74c0ce30e69827202932531a3c2d31b17cec32" translate="yes" xml:space="preserve">
          <source>Do not search for header files in the C++-specific standard directories, but do still search the other standard directories. (This option is used when building the C++ library.)</source>
          <target state="translated">不搜索C++专用标准目录中的头文件,但仍搜索其他标准目录。(此选项在构建C++库时使用。)</target>
        </trans-unit>
        <trans-unit id="10d644d96645c398a65f49953416f8df18eac09b" translate="yes" xml:space="preserve">
          <source>Do not search for header files in the standard directories specific to C++, but do still search the other standard directories. (This option is used when building the C++ library.)</source>
          <target state="translated">不要在C++特有的标准目录中搜索头文件,但仍要搜索其他标准目录。(此选项在构建C++库时使用。)</target>
        </trans-unit>
        <trans-unit id="6ee81949a7a2777f7208e1e6ee75bc8ae9472923" translate="yes" xml:space="preserve">
          <source>Do not search the standard system directories for header files. Only the directories explicitly specified with</source>
          <target state="translated">不要在标准系统目录中搜索头文件。只搜索用</target>
        </trans-unit>
        <trans-unit id="eb16433a9f72928c54140581a05d1867ea26ccd7" translate="yes" xml:space="preserve">
          <source>Do not set &lt;code&gt;errno&lt;/code&gt; after calling math functions that are executed with a single instruction, e.g., &lt;code&gt;sqrt&lt;/code&gt;. A program that relies on IEEE exceptions for math error handling may want to use this flag for speed while maintaining IEEE arithmetic compatibility.</source>
          <target state="translated">调用用单个指令执行的数学函数（例如 &lt;code&gt;sqrt&lt;/code&gt; )后，请勿设置 &lt;code&gt;errno&lt;/code&gt; 。依赖IEEE异常进行数学错误处理的程序可能希望将此标志用于速度，同时保持IEEE算术兼容性。</target>
        </trans-unit>
        <trans-unit id="20c8d2c68cfa75e481382ec2a217fdac468ae476" translate="yes" xml:space="preserve">
          <source>Do not store floating-point variables in registers, and inhibit other options that might change whether a floating-point value is taken from a register or memory.</source>
          <target state="translated">不要将浮点变量存储在寄存器中,并抑制其他可能改变浮点值是来自寄存器还是内存的选项。</target>
        </trans-unit>
        <trans-unit id="1e223b8f5150edab41b25d5219e57c17c3a59917" translate="yes" xml:space="preserve">
          <source>Do not substitute constants for known return value of formatted output functions such as &lt;code&gt;sprintf&lt;/code&gt;, &lt;code&gt;snprintf&lt;/code&gt;, &lt;code&gt;vsprintf&lt;/code&gt;, and &lt;code&gt;vsnprintf&lt;/code&gt; (but not &lt;code&gt;printf&lt;/code&gt; of &lt;code&gt;fprintf&lt;/code&gt;). This transformation allows GCC to optimize or even eliminate branches based on the known return value of these functions called with arguments that are either constant, or whose values are known to be in a range that makes determining the exact return value possible. For example, when</source>
          <target state="translated">不要用常量代替格式化输出函数的已知返回值，例如 &lt;code&gt;sprintf&lt;/code&gt; ， &lt;code&gt;snprintf&lt;/code&gt; ， &lt;code&gt;vsprintf&lt;/code&gt; 和 &lt;code&gt;vsnprintf&lt;/code&gt; （但不要用 &lt;code&gt;fprintf&lt;/code&gt; 的 &lt;code&gt;printf&lt;/code&gt; ）。这种转换允许GCC根据这些函数的已知返回值优化或消除分支，这些函数的返回值是恒定的，或者已知其值在可以确定确切返回值的范围内。例如，当</target>
        </trans-unit>
        <trans-unit id="cf78eba26b5aa804017da1ef12f012cd3682e1fb" translate="yes" xml:space="preserve">
          <source>Do not treat the operator name keywords &lt;code&gt;and&lt;/code&gt;, &lt;code&gt;bitand&lt;/code&gt;, &lt;code&gt;bitor&lt;/code&gt;, &lt;code&gt;compl&lt;/code&gt;, &lt;code&gt;not&lt;/code&gt;, &lt;code&gt;or&lt;/code&gt; and &lt;code&gt;xor&lt;/code&gt; as synonyms as keywords.</source>
          <target state="translated">不要把运营商名称的关键字 &lt;code&gt;and&lt;/code&gt; ， &lt;code&gt;bitand&lt;/code&gt; ， &lt;code&gt;bitor&lt;/code&gt; ， &lt;code&gt;compl&lt;/code&gt; ， &lt;code&gt;not&lt;/code&gt; ， &lt;code&gt;or&lt;/code&gt; 和 &lt;code&gt;xor&lt;/code&gt; 作为同义词作为关键字。</target>
        </trans-unit>
        <trans-unit id="a51f0c8e8070d0d16a2b1996318508b466a43f6d" translate="yes" xml:space="preserve">
          <source>Do not try to dynamically allocate condition code registers, only use &lt;code&gt;icc0&lt;/code&gt; and &lt;code&gt;fcc0&lt;/code&gt;.</source>
          <target state="translated">不要尝试动态分配条件代码寄存器，而只能使用 &lt;code&gt;icc0&lt;/code&gt; 和 &lt;code&gt;fcc0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e4b145e8904eea56f7b19e2cc3eedad3e7a2b834" translate="yes" xml:space="preserve">
          <source>Do not use (do use) external functions to save and restore registers at the prologue and epilogue of a function. The external functions are slower, but use less code space if more than one function saves the same number of registers. The</source>
          <target state="translated">不要在一个函数的序幕和尾声使用(做使用)外部函数来保存和恢复寄存器。如果一个以上的函数保存相同数量的寄存器,外部函数的速度较慢,但使用的代码空间较少。寄存器数量相同的情况下,外部函数的速度较慢,但使用的代码空间较少。</target>
        </trans-unit>
        <trans-unit id="00d7092da6abac6816723cc9e024cce735f69d9a" translate="yes" xml:space="preserve">
          <source>Do not use &lt;code&gt;__gcc_isr&lt;/code&gt; pseudo instructions in a function with the &lt;code&gt;interrupt&lt;/code&gt; or &lt;code&gt;signal&lt;/code&gt; attribute aka. interrupt service routine (ISR). Use this attribute if the preamble of the ISR prologue should always read</source>
          <target state="translated">不要在具有 &lt;code&gt;interrupt&lt;/code&gt; 或 &lt;code&gt;signal&lt;/code&gt; 属性的函数中使用 &lt;code&gt;__gcc_isr&lt;/code&gt; 伪指令。中断服务程序（ISR）。如果ISR序言的序言应始终阅读，请使用此属性</target>
        </trans-unit>
        <trans-unit id="18d8580e81e8dfe5a32f7016f417e2eb0471dcb3" translate="yes" xml:space="preserve">
          <source>Do not use a so-called &amp;ldquo;red zone&amp;rdquo; for x86-64 code. The red zone is mandated by the x86-64 ABI; it is a 128-byte area beyond the location of the stack pointer that is not modified by signal or interrupt handlers and therefore can be used for temporary data without adjusting the stack pointer. The flag</source>
          <target state="translated">请勿对x86-64代码使用所谓的&amp;ldquo;红色区域&amp;rdquo;。红色区域由x86-64 ABI强制；它是堆栈指针位置之外的128字节区域，未被信号或中断处理程序修改，因此可用于临时数据而无需调整堆栈指针。旗</target>
        </trans-unit>
        <trans-unit id="18a500f76abd74325a0b47c0d5b69985957db494" translate="yes" xml:space="preserve">
          <source>Do not use condition-code results from previous instruction; always emit compare and test instructions before use of condition codes.</source>
          <target state="translated">不要使用前一条指令的条件码结果;在使用条件码之前,总是先发出比较和测试指令。</target>
        </trans-unit>
        <trans-unit id="8b90672d13ea8faf72441a2154876e77530d1d87" translate="yes" xml:space="preserve">
          <source>Do not use div and mod instructions.</source>
          <target state="translated">不要使用div和model指令。</target>
        </trans-unit>
        <trans-unit id="a1c8552434007f4da99e51d45212d527e1753ccf" translate="yes" xml:space="preserve">
          <source>Do not use double word instructions.</source>
          <target state="translated">不要使用双字说明。</target>
        </trans-unit>
        <trans-unit id="3da98d0922de975e727ce6056f533717a8befbdb" translate="yes" xml:space="preserve">
          <source>Do not use floating-point coprocessor instructions. Implement floating-point calculations using library calls instead.</source>
          <target state="translated">不要使用浮点协处理器指令。使用库调用实现浮点计算。</target>
        </trans-unit>
        <trans-unit id="9fdd545e439d4b4617a15eacf8cd9e4f96ac14e8" translate="yes" xml:space="preserve">
          <source>Do not use floating-point double instructions.</source>
          <target state="translated">不要使用浮点双指令。</target>
        </trans-unit>
        <trans-unit id="95fd53c42ee138555aacbc40f7b4326fe9304fd6" translate="yes" xml:space="preserve">
          <source>Do not use hardware floating point.</source>
          <target state="translated">不要使用硬件浮点。</target>
        </trans-unit>
        <trans-unit id="97b2ddca9650ddbadc66a49ca355676910df5582" translate="yes" xml:space="preserve">
          <source>Do not use jump tables for switch statements even where it would be more efficient than other code generation strategies. This option is of use in conjunction with</source>
          <target state="translated">即使在比其他代码生成策略更有效的情况下,也不要对开关语句使用跳表。这个选项与</target>
        </trans-unit>
        <trans-unit id="66b43b46849088f20d198292bf3b1d8b62697198" translate="yes" xml:space="preserve">
          <source>Do not use media instructions.</source>
          <target state="translated">不要使用媒体说明。</target>
        </trans-unit>
        <trans-unit id="0a7e7f9ca7cad5a355cdeb3565cfa6b4acd871ea" translate="yes" xml:space="preserve">
          <source>Do not use multiply and add/subtract instructions.</source>
          <target state="translated">不要使用乘法和加/减法指令。</target>
        </trans-unit>
        <trans-unit id="8d9e83aee940103d590cb767e0456c5b78e32683" translate="yes" xml:space="preserve">
          <source>Do not use table-based fast divide for small numbers. The default is to use the fast divide at</source>
          <target state="translated">对于小数,不要使用基于表格的快速除法。默认情况下,使用快速除法,在</target>
        </trans-unit>
        <trans-unit id="05b033596194e8c7885a56cfce16297eb0279fb4" translate="yes" xml:space="preserve">
          <source>Do not use the C library or system libraries tightly coupled with it when linking. Still link with the startup files,</source>
          <target state="translated">链接时不要使用C库或与之紧密耦合的系统库。还是用启动文件链接。</target>
        </trans-unit>
        <trans-unit id="7597081c858717e7804a44bce422498f190040a9" translate="yes" xml:space="preserve">
          <source>Do not use the FPU registers for return values of functions.</source>
          <target state="translated">不要将FPU寄存器用于函数的返回值。</target>
        </trans-unit>
        <trans-unit id="1d16a9b15ecbbe19aaee48f8f83799d98bf40097" translate="yes" xml:space="preserve">
          <source>Do not use the PLT for external function calls in position-independent code. Instead, load the callee address at call sites from the GOT and branch to it. This leads to more efficient code by eliminating PLT stubs and exposing GOT loads to optimizations. On architectures such as 32-bit x86 where PLT stubs expect the GOT pointer in a specific register, this gives more register allocation freedom to the compiler. Lazy binding requires use of the PLT; with</source>
          <target state="translated">不要在与位置无关的代码中使用PLT进行外部函数调用。相反,从GOT中加载调用站点的被叫者地址,并对其进行分支。这样可以消除PLT存根,并将GOT负载暴露给优化,从而提高代码效率。在32位x86等架构上,PLT存根期望GOT指针在特定寄存器中,这给编译器提供了更多的寄存器分配自由度。懒惰绑定需要使用PLT;有了</target>
        </trans-unit>
        <trans-unit id="0ea4440b962126227be7707085ba73c227777ab2" translate="yes" xml:space="preserve">
          <source>Do not use the bit-field instructions. The</source>
          <target state="translated">不要使用位场指令。的,不要使用位场指令。</target>
        </trans-unit>
        <trans-unit id="be4c2d58ea2c75689a1e197b8bce077dc3baf8e4" translate="yes" xml:space="preserve">
          <source>Do not use the standard system libraries when linking. Only the libraries you specify are passed to the linker, and options specifying linkage of the system libraries, such as</source>
          <target state="translated">链接时不要使用标准的系统库。只有你指定的库才会传递给链接器,而指定系统库链接的选项,如</target>
        </trans-unit>
        <trans-unit id="1749ead3f9e7878168e9e856a83790c8110a2327" translate="yes" xml:space="preserve">
          <source>Do not use the standard system startup files or libraries when linking. No startup files and only the libraries you specify are passed to the linker, and options specifying linkage of the system libraries, such as</source>
          <target state="translated">链接时不要使用标准的系统启动文件或库。没有启动文件,只把你指定的库传递给链接器,而指定系统库链接的选项,如</target>
        </trans-unit>
        <trans-unit id="c08b8394a0f77286bf2dfe4eba4ed4f08b60e58a" translate="yes" xml:space="preserve">
          <source>Do not use the standard system startup files when linking. The standard system libraries are used normally, unless</source>
          <target state="translated">链接时不要使用标准系统启动文件。标准系统库是正常使用的,除非</target>
        </trans-unit>
        <trans-unit id="52b9f7e2d461f74673bbbc8c6515110fc50b3657" translate="yes" xml:space="preserve">
          <source>Do not use type qualifiers such as &lt;code&gt;const&lt;/code&gt; and &lt;code&gt;volatile&lt;/code&gt;, as the outcome may be contrary to expectations. In particular, using the &lt;code&gt;volatile&lt;/code&gt; qualifier does not fully prevent the compiler from optimizing accesses to the register.</source>
          <target state="translated">不要使用 &lt;code&gt;const&lt;/code&gt; 和 &lt;code&gt;volatile&lt;/code&gt; 等类型限定符，因为结果可能与预期相反。特别是，使用 &lt;code&gt;volatile&lt;/code&gt; 限定符不会完全阻止编译器优化对寄存器的访问。</target>
        </trans-unit>
        <trans-unit id="78d5320a817e4a255712f70b363a7e985f54d40c" translate="yes" xml:space="preserve">
          <source>Do not use type qualifiers such as &lt;code&gt;const&lt;/code&gt; and &lt;code&gt;volatile&lt;/code&gt;, as the outcome may be contrary to expectations. In particular, when the &lt;code&gt;const&lt;/code&gt; qualifier is used, the compiler may substitute the variable with its initializer in &lt;code&gt;asm&lt;/code&gt; statements, which may cause the corresponding operand to appear in a different register.</source>
          <target state="translated">不要使用 &lt;code&gt;const&lt;/code&gt; 和 &lt;code&gt;volatile&lt;/code&gt; 等类型限定符，因为结果可能与预期相反。特别是，当使用 &lt;code&gt;const&lt;/code&gt; 限定符时，编译器可以在 &lt;code&gt;asm&lt;/code&gt; 语句中用其初始化程序替换变量，这可能导致相应的操作数出现在不同的寄存器中。</target>
        </trans-unit>
        <trans-unit id="4a1518a9d7c5d3a374a0e3380575da8c6a0c3463" translate="yes" xml:space="preserve">
          <source>Do not use weak symbol support, even if it is provided by the linker. By default, G++ uses weak symbols if they are available. This option exists only for testing, and should not be used by end-users; it results in inferior code and has no benefits. This option may be removed in a future release of G++.</source>
          <target state="translated">不要使用弱符号支持,即使是由链接器提供的。默认情况下,如果有弱符号,G++会使用弱符号。这个选项只存在于测试中,终端用户不应该使用,它导致的是低劣的代码,没有任何好处。这个选项可能会在未来的G++版本中被删除。</target>
        </trans-unit>
        <trans-unit id="1c6a44b0e85a6edc81e27b7d2eeb886e6e3cf31e" translate="yes" xml:space="preserve">
          <source>Do not warn about compile-time integer division by zero. Floating-point division by zero is not warned about, as it can be a legitimate way of obtaining infinities and NaNs.</source>
          <target state="translated">不要警告编译时的整数除以零。不警告浮点除以零,因为这可能是获得无穷大和NaN的合法方式。</target>
        </trans-unit>
        <trans-unit id="5c0402a3d7a93e89c19d0b2bc886627da9bb7bce" translate="yes" xml:space="preserve">
          <source>Do not warn about compile-time overflow in constant expressions.</source>
          <target state="translated">不要对常量表达式中的编译时溢出发出警告。</target>
        </trans-unit>
        <trans-unit id="f3164f98334eb82394edc2af61f2d8e4ea49e902" translate="yes" xml:space="preserve">
          <source>Do not warn about incompatible integer to pointer and pointer to integer conversions. This warning is about implicit conversions; for explicit conversions the warnings</source>
          <target state="translated">不要对不兼容的整数到指针和指针到整数的转换发出警告。这个警告是关于隐式转换的;对于显式转换,警告为</target>
        </trans-unit>
        <trans-unit id="9ee34e26cbf6dcdf9bae6a606eba5f147e3812eb" translate="yes" xml:space="preserve">
          <source>Do not warn about misuses of pragmas, such as incorrect parameters, invalid syntax, or conflicts between pragmas. See also</source>
          <target state="translated">不要对滥用语法提出警告,例如错误的参数、无效的语法或语法之间的冲突。参见</target>
        </trans-unit>
        <trans-unit id="2fba612926859cd3b2ec30d821b233c2c88e411e" translate="yes" xml:space="preserve">
          <source>Do not warn about returning a pointer (or in C++, a reference) to a variable that goes out of scope after the function returns.</source>
          <target state="translated">在函数返回后,不要警告返回一个指针(或在C++中,一个引用)到一个超出范围的变量。</target>
        </trans-unit>
        <trans-unit id="e20062785b98beaefd7db7d397190023d3d7d01c" translate="yes" xml:space="preserve">
          <source>Do not warn about usage of deprecated features. See &lt;a href=&quot;deprecated-features#Deprecated-Features&quot;&gt;Deprecated Features&lt;/a&gt;.</source>
          <target state="translated">不要警告使用已弃用的功能。请参阅&lt;a href=&quot;deprecated-features#Deprecated-Features&quot;&gt;不推荐使用的功能&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5741a81d36ae80d4f66c3d238560cf727f6d2221" translate="yes" xml:space="preserve">
          <source>Do not warn about usage of functions (see &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;Function Attributes&lt;/a&gt;) declared with &lt;code&gt;warning&lt;/code&gt; attribute. By default, this warning is enabled.</source>
          <target state="translated">不要警告使用 &lt;code&gt;warning&lt;/code&gt; 属性声明的函数（请参见&lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;Function Attributes&lt;/a&gt;）。默认情况下，此警告处于启用状态。</target>
        </trans-unit>
        <trans-unit id="569882ee6769c783a7c673619d2b596b07ae7884" translate="yes" xml:space="preserve">
          <source>Do not warn about uses of &lt;code&gt;std::initializer_list&lt;/code&gt; that are likely to result in dangling pointers. Since the underlying array for an &lt;code&gt;initializer_list&lt;/code&gt; is handled like a normal C++ temporary object, it is easy to inadvertently keep a pointer to the array past the end of the array&amp;rsquo;s lifetime. For example:</source>
          <target state="translated">不要警告可能会导致指针悬空的 &lt;code&gt;std::initializer_list&lt;/code&gt; 使用。由于 &lt;code&gt;initializer_list&lt;/code&gt; 的基础数组像普通的C ++临时对象一样进行处理，因此很容易在数组生命周期的末尾无意间保持指向该数组的指针。例如：</target>
        </trans-unit>
        <trans-unit id="e7879bd2657e4473a1347324fd997f9cdc3d041e" translate="yes" xml:space="preserve">
          <source>Do not warn about uses of functions (see &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;Function Attributes&lt;/a&gt;), variables (see &lt;a href=&quot;variable-attributes#Variable-Attributes&quot;&gt;Variable Attributes&lt;/a&gt;), and types (see &lt;a href=&quot;type-attributes#Type-Attributes&quot;&gt;Type Attributes&lt;/a&gt;) marked as deprecated by using the &lt;code&gt;deprecated&lt;/code&gt; attribute.</source>
          <target state="translated">时不发出警告的功能用途（见&lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;函数属性&lt;/a&gt;），变量（见&lt;a href=&quot;variable-attributes#Variable-Attributes&quot;&gt;变量属性&lt;/a&gt;）和类型（见&lt;a href=&quot;type-attributes#Type-Attributes&quot;&gt;类型属性&lt;/a&gt;）标记的使用为废弃 &lt;code&gt;deprecated&lt;/code&gt; 属性。</target>
        </trans-unit>
        <trans-unit id="b2ba657c651e9df665e818d59934ea7360d21f9d" translate="yes" xml:space="preserve">
          <source>Do not warn for conversions between &lt;code&gt;NULL&lt;/code&gt; and non-pointer types.</source>
          <target state="translated">不要警告在 &lt;code&gt;NULL&lt;/code&gt; 和非指针类型之间进行转换。</target>
        </trans-unit>
        <trans-unit id="f3c7034f14450f34ae37fb2f3dc3f8309df1df4c" translate="yes" xml:space="preserve">
          <source>Do not warn if a caller of a function marked with attribute &lt;code&gt;warn_unused_result&lt;/code&gt; (see &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;Function Attributes&lt;/a&gt;) does not use its return value. The default is</source>
          <target state="translated">如果标记有属性 &lt;code&gt;warn_unused_result&lt;/code&gt; 的函数的调用者（请参见&lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;Function Attributes&lt;/a&gt;）未使用其返回值，则不要发出警告。默认是</target>
        </trans-unit>
        <trans-unit id="e5c44e9dcc0d0d2cc0d4fcbe48e1b3887ed71621" translate="yes" xml:space="preserve">
          <source>Do not warn if a multicharacter constant (&amp;lsquo;</source>
          <target state="translated">如果多字符常量（'</target>
        </trans-unit>
        <trans-unit id="474d345e0c92820e39935346f3f6f08e315a2c69" translate="yes" xml:space="preserve">
          <source>Do not warn if a priority from 0 to 100 is used for constructor or destructor. The use of constructor and destructor attributes allow you to assign a priority to the constructor/destructor to control its order of execution before &lt;code&gt;main&lt;/code&gt; is called or after it returns. The priority values must be greater than 100 as the compiler reserves priority values between 0&amp;ndash;100 for the implementation.</source>
          <target state="translated">如果构造函数或析构函数的优先级为0到100，则不发出警告。使用构造函数和析构函数属性可让您为构造函数/析构函数分配优先级，以控制其在调用 &lt;code&gt;main&lt;/code&gt; 或返回main之后的执行顺序。优先级值必须大于100，因为编译器为实现保留了0-100之间的优先级值。</target>
        </trans-unit>
        <trans-unit id="c5958651457da08de9e91cd3ae0fc547368da59b" translate="yes" xml:space="preserve">
          <source>Do not warn if an unexpected &lt;code&gt;__attribute__&lt;/code&gt; is used, such as unrecognized attributes, function attributes applied to variables, etc. This does not stop errors for incorrect use of supported attributes.</source>
          <target state="translated">如果使用了意外的 &lt;code&gt;__attribute__&lt;/code&gt; （例如，无法识别的属性，应用于变量的函数属性等），则不会发出警告。这不会因错误使用支持的属性而停止错误。</target>
        </trans-unit>
        <trans-unit id="776e98d1dffbde23efe71be5b00aaf8afcebd19f" translate="yes" xml:space="preserve">
          <source>Do not warn if certain built-in macros are redefined. This suppresses warnings for redefinition of &lt;code&gt;__TIMESTAMP__&lt;/code&gt;, &lt;code&gt;__TIME__&lt;/code&gt;, &lt;code&gt;__DATE__&lt;/code&gt;, &lt;code&gt;__FILE__&lt;/code&gt;, and &lt;code&gt;__BASE_FILE__&lt;/code&gt;.</source>
          <target state="translated">如果某些内置宏被重新定义，则不发出警告。这抑制了警告，重新定义 &lt;code&gt;__TIMESTAMP__&lt;/code&gt; ， &lt;code&gt;__TIME__&lt;/code&gt; ， &lt;code&gt;__DATE__&lt;/code&gt; ， &lt;code&gt;__FILE__&lt;/code&gt; 和 &lt;code&gt;__BASE_FILE__&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a5961961b151110f8171f9f71097fa474a97d41f" translate="yes" xml:space="preserve">
          <source>Do not warn if type qualifiers on arrays which are pointer targets are being discarded. Typically, the compiler warns if a &lt;code&gt;const int (*)[]&lt;/code&gt; variable is passed to a function that takes a &lt;code&gt;int (*)[]&lt;/code&gt; parameter. This option can be used to suppress such a warning.</source>
          <target state="translated">不要警告是否舍弃了作为指针目标的数组上的类型限定符。通常，如果将 &lt;code&gt;const int (*)[]&lt;/code&gt; 变量传递给采用 &lt;code&gt;int (*)[]&lt;/code&gt; 参数的函数，则编译器会发出警告。此选项可用于禁止显示此类警告。</target>
        </trans-unit>
        <trans-unit id="4f6ac391aa1f66b1759edea5545511d490e350b4" translate="yes" xml:space="preserve">
          <source>Do not warn if type qualifiers on pointers are being discarded. Typically, the compiler warns if a &lt;code&gt;const char *&lt;/code&gt; variable is passed to a function that takes a &lt;code&gt;char *&lt;/code&gt; parameter. This option can be used to suppress such a warning.</source>
          <target state="translated">不要警告是否丢弃了指针上的类型限定符。通常，如果将 &lt;code&gt;const char *&lt;/code&gt; 变量传递给采用 &lt;code&gt;char *&lt;/code&gt; 参数的函数，则编译器会发出警告。此选项可用于禁止显示此类警告。</target>
        </trans-unit>
        <trans-unit id="2237d0ea4af513f919bfca5807318b7adb31ba01" translate="yes" xml:space="preserve">
          <source>Do not warn on suspicious constructs involving reverse scalar storage order.</source>
          <target state="translated">不要对涉及反向标量存储顺序的可疑构造发出警告。</target>
        </trans-unit>
        <trans-unit id="505f6f0a22dd44c4b12ed8d2e6a399fe3806c159" translate="yes" xml:space="preserve">
          <source>Do not warn when attempting to free an object that was not allocated on the heap.</source>
          <target state="translated">当试图释放一个没有在堆上分配的对象时,不要发出警告。</target>
        </trans-unit>
        <trans-unit id="b41e5f71b800c0d75e8bc4c789587d50634e7b35" translate="yes" xml:space="preserve">
          <source>Do not warn when there is a conversion between pointers that have incompatible types. This warning is for cases not covered by</source>
          <target state="translated">当有不兼容类型的指针之间发生转换时,不要发出警告。这个警告是针对</target>
        </trans-unit>
        <trans-unit id="7288e67492dfae2c91a3de07cd384be7cd59dcec" translate="yes" xml:space="preserve">
          <source>Do not warn whenever a local variable shadows an instance variable in an Objective-C method.</source>
          <target state="translated">当一个局部变量在Objective-C方法中影射一个实例变量时,不要发出警告。</target>
        </trans-unit>
        <trans-unit id="a828e7021a3bac6b8a79dcdabca3402745cfbb45" translate="yes" xml:space="preserve">
          <source>Do not warn whenever an &lt;code&gt;#else&lt;/code&gt; or an &lt;code&gt;#endif&lt;/code&gt; are followed by text. This sometimes happens in older programs with code of the form</source>
          <target state="translated">当 &lt;code&gt;#else&lt;/code&gt; 或 &lt;code&gt;#endif&lt;/code&gt; 后跟文本时，请勿发出警告。有时在使用以下形式的代码的旧程序中会发生这种情况</target>
        </trans-unit>
        <trans-unit id="12e3a14254e97e0a14b8cdd90a112ee9ef9f78f5" translate="yes" xml:space="preserve">
          <source>Do nothing. Code written for the Borland model works fine, but each translation unit contains instances of each of the templates it uses. The duplicate instances will be discarded by the linker, but in a large program, this can lead to an unacceptable amount of code duplication in object files or shared libraries.</source>
          <target state="translated">什么都不做。为Borland模型编写的代码可以正常工作,但每个翻译单元都包含它使用的每个模板的实例。重复的实例将被链接器丢弃,但在一个大型程序中,这可能会导致对象文件或共享库中出现不可接受的代码重复。</target>
        </trans-unit>
        <trans-unit id="36f05070ba1aa8ebb373ea5159cf72f76e048943" translate="yes" xml:space="preserve">
          <source>Do or don&amp;rsquo;t use hardware floating-point divide and square root instructions. This requires the F or D extensions for floating-point registers. The default is to use them if the specified architecture has these instructions.</source>
          <target state="translated">是否使用硬件浮点除法和平方根指令。这需要浮点寄存器的F或D扩展名。如果指定的体系结构具有这些说明，则默认值为使用它们。</target>
        </trans-unit>
        <trans-unit id="57a1444191ca5bb7028d2e6eff0344f434565ffa" translate="yes" xml:space="preserve">
          <source>Do or don&amp;rsquo;t use hardware instructions for integer division. This requires the M extension. The default is to use them if the specified architecture has these instructions.</source>
          <target state="translated">是否使用硬件指令进行整数除法。这需要M扩展名。如果指定的体系结构具有这些说明，则默认值为使用它们。</target>
        </trans-unit>
        <trans-unit id="ddefab05090bb15a5eac377b4c14800d5252c830" translate="yes" xml:space="preserve">
          <source>Do or don&amp;rsquo;t use smaller but slower prologue and epilogue code that uses library function calls. The default is to use fast inline prologues and epilogues.</source>
          <target state="translated">是否使用较小但较慢的使用库函数调用的序言和结尾代码。默认设置是使用快速内联序言和结语。</target>
        </trans-unit>
        <trans-unit id="96ba75d321eadfeb26cc86353736e08f35e773ab" translate="yes" xml:space="preserve">
          <source>Do output those jump instructions, on the assumption that the GNU assembler is being used.</source>
          <target state="translated">做输出这些跳转指令,前提是使用GNU汇编器。</target>
        </trans-unit>
        <trans-unit id="4d204a72f0077f832ff1f2432253a2d1ae4c41b8" translate="yes" xml:space="preserve">
          <source>Do stack checking using information placed into L1 scratchpad memory by the uClinux kernel.</source>
          <target state="translated">使用uClinux内核放入L1 scratchpad内存的信息进行堆栈检查。</target>
        </trans-unit>
        <trans-unit id="63c71786896a4df72c3bdfbb021ed8f95f3c7268" translate="yes" xml:space="preserve">
          <source>Do use the bit-field instructions. The</source>
          <target state="translated">做使用位场指令。的</target>
        </trans-unit>
        <trans-unit id="aeab84fbb87aa1ae0148d00185bbbe64a7f1de75" translate="yes" xml:space="preserve">
          <source>Do/do not align destination of inlined string operations.</source>
          <target state="translated">做/不对齐内联字符串操作的目标。</target>
        </trans-unit>
        <trans-unit id="bc45e676c4601147aa81205b6b35bbce28a0956f" translate="yes" xml:space="preserve">
          <source>Dollar sign is allowed in identifiers.</source>
          <target state="translated">在标识符中允许使用美元符号。</target>
        </trans-unit>
        <trans-unit id="68e93316f665d706cb16fce9b665aecabf389d83" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t (or do) generate assembler code for the DWARF line number debugging info. This may be useful when not using the GNU assembler.</source>
          <target state="translated">不要（或这样做）为DWARF行号调试信息生成汇编代码。当不使用GNU汇编器时，这可能很有用。</target>
        </trans-unit>
        <trans-unit id="f51bdbcf76c028728ebe02e5fd8a3a1a4630491b" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t allocate any register in the range &lt;code&gt;r32&lt;/code&gt;&amp;hellip;&lt;code&gt;r63&lt;/code&gt;. That allows code to run on hardware variants that lack these registers.</source>
          <target state="translated">不要在 &lt;code&gt;r32&lt;/code&gt; &amp;hellip; &lt;code&gt;r63&lt;/code&gt; 范围内分配任何寄存器。这使得代码可以在缺少这些寄存器的硬件变体上运行。</target>
        </trans-unit>
        <trans-unit id="0696f924a6a7aba65bb0c521d005ad21d730a7e5" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t allow (allow) the compiler generating privileged mode code. Specifying</source>
          <target state="translated">不允许（允许）编译器生成特权模式代码。指定</target>
        </trans-unit>
        <trans-unit id="b4aac26fa88db757f99f48797196bd3cbd91bc9d" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t emit code for implicit instantiations of inline templates, either. The default is to handle inlines differently so that compiles with and without optimization need the same set of explicit instantiations.</source>
          <target state="translated">也不为内联模板的隐式实例发出代码。缺省设置是对内联进行不同的处理，因此无论是否进行优化，编译过程都需要使用同一组显式实例化。</target>
        </trans-unit>
        <trans-unit id="c69befd629431a6e029cd45dbc6aab7876d6d7d6" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t generate code to check for violation of exception specifications at run time. This option violates the C++ standard, but may be useful for reducing code size in production builds, much like defining &lt;code&gt;NDEBUG&lt;/code&gt;. This does not give user code permission to throw exceptions in violation of the exception specifications; the compiler still optimizes based on the specifications, so throwing an unexpected exception results in undefined behavior at run time.</source>
          <target state="translated">不要在运行时生成代码来检查是否违反了异常规范。该选项违反了C ++标准，但是对于减少生产版本中的代码大小可能很有用，就像定义 &lt;code&gt;NDEBUG&lt;/code&gt; 一样。这不授予用户代码违反异常规范的权限来抛出异常；编译器仍会根据规范进行优化，因此抛出意外异常会在运行时导致未定义的行为。</target>
        </trans-unit>
        <trans-unit id="f8291058c6a41a1212fed5bdc0b889e02ad54e73" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t generate extra code to prevent CSYNC or SSYNC instructions from occurring too soon after a conditional branch.</source>
          <target state="translated">不要生成额外的代码来防止CSYNC或SSYNC指令在条件分支后过早发生。</target>
        </trans-unit>
        <trans-unit id="92fc05375382df9e90695eff3a44465379a9fc8a" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t generate extra code to prevent speculative loads from occurring.</source>
          <target state="translated">不要生成额外的代码来防止投机负载的发生。</target>
        </trans-unit>
        <trans-unit id="841b2c5913f27dd6d0a0b75be4041ed9060e2a5b" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t indicate any priority for target registers.</source>
          <target state="translated">不要为目标寄存器指定任何优先级。</target>
        </trans-unit>
        <trans-unit id="316b458b3b915800cc227cb589b8354e8997e031" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t insert NOPs.</source>
          <target state="translated">不要插入NOP。</target>
        </trans-unit>
        <trans-unit id="ff257b74ea5cefc2a6c99dc46dcf1ce2fc00c3e9" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t keep the frame pointer in a register for leaf functions. This avoids the instructions to save, set up and restore frame pointers and makes an extra register available in leaf functions.</source>
          <target state="translated">不要将帧指针保存在用于叶函数的寄存器中。这避免了保存，设置和还原帧指针的指令，并在叶函数中提供了额外的寄存器。</target>
        </trans-unit>
        <trans-unit id="29fcb114afda8378c254d0362fee3390fc31a076" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t keep the frame pointer in a register for leaf functions. This avoids the instructions to save, set up, and restore frame pointers and makes an extra register available in leaf functions. The option</source>
          <target state="translated">不要将帧指针保存在用于叶函数的寄存器中。这避免了保存，设置和还原帧指针的说明，并在叶函数中提供了额外的寄存器。选项</target>
        </trans-unit>
        <trans-unit id="ba01c69254f25c86224b738f06e6534bc4f3d911" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t link against AVR-LibC&amp;rsquo;s device specific library &lt;code&gt;lib&amp;lt;mcu&amp;gt;.a&lt;/code&gt;.</source>
          <target state="translated">不要链接到AVR-LibC的设备专用库 &lt;code&gt;lib&amp;lt;mcu&amp;gt;.a&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e29b08debc2f8c83b43cab1a04eee2f4d727ea03" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t output a &lt;code&gt;.size&lt;/code&gt; assembler directive, or anything else that would cause trouble if the function is split in the middle, and the two halves are placed at locations far apart in memory. This option is used when compiling</source>
          <target state="translated">不要输出 &lt;code&gt;.size&lt;/code&gt; 汇编程序指令，否则不要输出任何其他会导致问题的结果，如果函数在中间被拆分，并且两半放在内存中相距较远的位置。编译时使用此选项</target>
        </trans-unit>
        <trans-unit id="d01cd709102ba1930825f66a542ae471f0249850" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t produce a dynamically linked position independent executable.</source>
          <target state="translated">不要产生动态链接的位置无关可执行文件。</target>
        </trans-unit>
        <trans-unit id="0d7422ae3d66c98a5899ca6447dbd9bcec60457e" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t recognize built-in functions that do not begin with &amp;lsquo;</source>
          <target state="translated">无法识别不以'开头的内置函数</target>
        </trans-unit>
        <trans-unit id="700e3402560c020ff640d0360da073b7f29b63b2" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t try to return a reference when you must return an object.</source>
          <target state="translated">当您必须返回对象时，请勿尝试返回引用。</target>
        </trans-unit>
        <trans-unit id="af0c2963603baeac9b84a7601cb10b5b24bf9b5d" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t use less than 25-bit addressing range for calls, which is the offset available for an unconditional branch-and-link instruction. Conditional execution of function calls is suppressed, to allow use of the 25-bit range, rather than the 21-bit range with conditional branch-and-link. This is the default for tool chains built for &lt;code&gt;arc-linux-uclibc&lt;/code&gt; and &lt;code&gt;arceb-linux-uclibc&lt;/code&gt; targets.</source>
          <target state="translated">调用时不要使用少于25位的寻址范围，这是无条件分支和链接指令可用的偏移量。抑制了函数调用的有条件执行，以允许使用25位范围，而不是使用带条件分支和链接的21位范围。这是为 &lt;code&gt;arc-linux-uclibc&lt;/code&gt; 和 &lt;code&gt;arceb-linux-uclibc&lt;/code&gt; 目标构建的工具链的默认设置。</target>
        </trans-unit>
        <trans-unit id="71dc31daaf7ec06b2fa4f05018881b81c4bb5538" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t use the &lt;code&gt;__cxa_get_exception_ptr&lt;/code&gt; runtime routine. This causes &lt;code&gt;std::uncaught_exception&lt;/code&gt; to be incorrect, but is necessary if the runtime routine is not available.</source>
          <target state="translated">不要使用 &lt;code&gt;__cxa_get_exception_ptr&lt;/code&gt; 运行时例程。这会导致 &lt;code&gt;std::uncaught_exception&lt;/code&gt; 不正确，但是如果运行时例程不可用，则有必要。</target>
        </trans-unit>
        <trans-unit id="8dcc5d27681a8bdad6a9cb3ee54a8968b968d227" translate="yes" xml:space="preserve">
          <source>Double-precision floating point:</source>
          <target state="translated">双精度浮点数。</target>
        </trans-unit>
        <trans-unit id="ed1ceb86db6df41816a7c2bb25eb2a7096005f14" translate="yes" xml:space="preserve">
          <source>Double-precision minimum and maximum. These instructions are only generated if</source>
          <target state="translated">双精度的最小值和最大值。只有在以下情况下才会产生这些指令</target>
        </trans-unit>
        <trans-unit id="37d9eb125267c27f5502a1a9d084767dc36a78f0" translate="yes" xml:space="preserve">
          <source>Double-precision trigonometric and exponential functions. These instructions are only generated if</source>
          <target state="translated">双精度三角函数和指数函数。只有在以下情况下才会产生这些指令</target>
        </trans-unit>
        <trans-unit id="6df71cfe44fe533eddb81c22b571782849f6b7cc" translate="yes" xml:space="preserve">
          <source>Double-word integers&amp;mdash;&lt;code&gt;long long int&lt;/code&gt;.</source>
          <target state="translated">双字整数-long &lt;code&gt;long long int&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dc953a7def63cef4cb68fb70c5f14bea1b94cf60" translate="yes" xml:space="preserve">
          <source>Downgrade some diagnostics about nonconformant code from errors to warnings. Thus, using</source>
          <target state="translated">将一些关于不合格代码的诊断从错误降级为警告。因此,使用</target>
        </trans-unit>
        <trans-unit id="01180802e3e84af7a4d8039eea60df66e24e2e3d" translate="yes" xml:space="preserve">
          <source>Due to a limitation the &lt;code&gt;__builtin_has_attribute&lt;/code&gt; function returns &lt;code&gt;false&lt;/code&gt; for the &lt;code&gt;mode&lt;/code&gt; attribute even if the type or variable referenced by the &lt;var&gt;type-or-expression&lt;/var&gt; argument was declared with one. The function is also not supported with labels, and in C with enumerators.</source>
          <target state="translated">由于限制所述 &lt;code&gt;__builtin_has_attribute&lt;/code&gt; 函数返回 &lt;code&gt;false&lt;/code&gt; 的 &lt;code&gt;mode&lt;/code&gt; 即使由所引用的类型或变量属性 &lt;var&gt;type-or-expression&lt;/var&gt; 参数是使用一个所声明的。标签也不支持该功能，C中还没有枚举器支持该功能。</target>
        </trans-unit>
        <trans-unit id="eaa7b08f0e0c97160e76284248f06868dbcb58d2" translate="yes" xml:space="preserve">
          <source>Due to delay slot scheduling and interactions between operand numbers, literal sizes, instruction lengths, and the support for conditional execution, the target-independent pass to generate conditional execution is often lacking, so the ARC port has kept a special pass around that tries to find more conditional execution generation opportunities after register allocation, branch shortening, and delay slot scheduling have been done. This pass generally, but not always, improves performance and code size, at the cost of extra compilation time, which is why there is an option to switch it off. If you have a problem with call instructions exceeding their allowable offset range because they are conditionalized, you should consider using</source>
          <target state="translated">由于延时槽调度以及操作数、字面大小、指令长度之间的相互影响,以及对条件执行的支持,产生条件执行的目标无关的通证往往是缺乏的,所以ARC端口保留了一个特殊的通证,它试图在寄存器分配、分支缩短和延时槽调度完成后,寻找更多的条件执行生成机会。这个通证一般来说,但并不总是能提高性能和代码大小,但代价是额外的编译时间,这就是为什么有一个选项可以关闭它。如果你的调用指令因为被条件化而超过其允许的偏移范围,你应该考虑使用</target>
        </trans-unit>
        <trans-unit id="8570e266a139eea3cf33870c783885655692c297" translate="yes" xml:space="preserve">
          <source>Due to differences in 64-bit ABIs, any Microsoft ABI function that calls a System V ABI function must consider RSI, RDI and XMM6-15 as clobbered. By default, the code for saving and restoring these registers is emitted inline, resulting in fairly lengthy prologues and epilogues. Using</source>
          <target state="translated">由于64位ABI的差异,任何调用System V ABI函数的Microsoft ABI函数必须将RSI、RDI和XMM6-15视为clobbered。默认情况下,保存和恢复这些寄存器的代码是内联发射的,导致相当长的序言和尾声。使用</target>
        </trans-unit>
        <trans-unit id="55dc1ed426258fad4287ccc3186c8799b4478fe2" translate="yes" xml:space="preserve">
          <source>Dump after RTL generation.</source>
          <target state="translated">RTL生成后的倾倒。</target>
        </trans-unit>
        <trans-unit id="55112da270658f739f4dfb65c2070abbe0a2de15" translate="yes" xml:space="preserve">
          <source>Dump after all rtl has been unshared.</source>
          <target state="translated">在所有的rtl都被取消共享后,Dump。</target>
        </trans-unit>
        <trans-unit id="17713d860b95f07f88ad9a9c6f46bff3093dd8bf" translate="yes" xml:space="preserve">
          <source>Dump after auto-inc-dec discovery. This pass is only run on architectures that have auto inc or auto dec instructions.</source>
          <target state="translated">在发现auto-inc-dec后进行dump。这个通道只在有自动入库或自动出库指令的架构上运行。</target>
        </trans-unit>
        <trans-unit id="4544c05126cdb19431a178314ee1eee9792fb198" translate="yes" xml:space="preserve">
          <source>Dump after block reordering.</source>
          <target state="translated">块重新排序后的转储。</target>
        </trans-unit>
        <trans-unit id="78c9d4108223d54d2d9b5209aec4c77ba61f990a" translate="yes" xml:space="preserve">
          <source>Dump after branch alignments have been computed.</source>
          <target state="translated">在计算完分支排列后进行转储。</target>
        </trans-unit>
        <trans-unit id="becf6aa3d2a32b64f568f0ff4ffede5097942c5f" translate="yes" xml:space="preserve">
          <source>Dump after cleaning up the barrier instructions.</source>
          <target state="translated">清理完障碍物后倾倒说明。</target>
        </trans-unit>
        <trans-unit id="4157bd0dc462fb4b9de6813e4b6322c3ce89115d" translate="yes" xml:space="preserve">
          <source>Dump after combining stack adjustments.</source>
          <target state="translated">合并堆栈调整后转储。</target>
        </trans-unit>
        <trans-unit id="ca08541014a668445bc90fdf9e0e75729f2449db" translate="yes" xml:space="preserve">
          <source>Dump after common sequence discovery.</source>
          <target state="translated">普通序列发现后的转储。</target>
        </trans-unit>
        <trans-unit id="003a4c3463d2348777de9c3ec96a83fded9a133b" translate="yes" xml:space="preserve">
          <source>Dump after conversion from GCC&amp;rsquo;s &amp;ldquo;flat register file&amp;rdquo; registers to the x87&amp;rsquo;s stack-like registers. This pass is only run on x86 variants.</source>
          <target state="translated">从GCC的&amp;ldquo;平面寄存器文件&amp;rdquo;寄存器转换为x87的类似堆栈的寄存器后转储。此过程仅在x86变体上运行。</target>
        </trans-unit>
        <trans-unit id="83008119d9369fbf18b0ada0441c79a07768ec53" translate="yes" xml:space="preserve">
          <source>Dump after conversion of EH handling range regions.</source>
          <target state="translated">EH处理范围区域转换后的转储。</target>
        </trans-unit>
        <trans-unit id="3bf729ea33ed64d3ed60d59c687162fd5feb227f" translate="yes" xml:space="preserve">
          <source>Dump after converting from cfglayout mode.</source>
          <target state="translated">从cfglayout模式转换后的dump。</target>
        </trans-unit>
        <trans-unit id="8c3c2b3635d622c5e7ba8ea735eb12810fb32bac" translate="yes" xml:space="preserve">
          <source>Dump after converting to cfglayout mode.</source>
          <target state="translated">转换为cfglayout模式后的dump。</target>
        </trans-unit>
        <trans-unit id="c3336c59217d8a52dec6ae53e20f9f151f5f642d" translate="yes" xml:space="preserve">
          <source>Dump after converting virtual registers to hard registers.</source>
          <target state="translated">将虚拟寄存器转换为硬寄存器后的转储。</target>
        </trans-unit>
        <trans-unit id="9e4924e7d7139d25008b3b0767ee0c48540ad8c8" translate="yes" xml:space="preserve">
          <source>Dump after delayed branch scheduling.</source>
          <target state="translated">延迟分支调度后的转储。</target>
        </trans-unit>
        <trans-unit id="d2764959e209d321913a6a9e66c4ca5ca11ad126" translate="yes" xml:space="preserve">
          <source>Dump after duplicating the computed gotos.</source>
          <target state="translated">复制计算出的gotos后进行转储。</target>
        </trans-unit>
        <trans-unit id="6e4665a9117fc08d9bbcca5529570f4270193b64" translate="yes" xml:space="preserve">
          <source>Dump after finalization of EH handling code.</source>
          <target state="translated">在最终确定EH处理代码后,Dump。</target>
        </trans-unit>
        <trans-unit id="0bd2968b703fd689e056f9d8a3839eaca5ddccc9" translate="yes" xml:space="preserve">
          <source>Dump after fixing rtl statements that have unsatisfied in/out constraints.</source>
          <target state="translated">修正有不满意的in/out约束的rtl语句后转储。</target>
        </trans-unit>
        <trans-unit id="1f6440e322c9dbaaa59c98dce4c47af3058d32dc" translate="yes" xml:space="preserve">
          <source>Dump after function inlining.</source>
          <target state="translated">在函数内联后进行转储。</target>
        </trans-unit>
        <trans-unit id="988226cdeaba5c3515016a8a81c5ff5fb6cd975a" translate="yes" xml:space="preserve">
          <source>Dump after generating the function prologues and epilogues.</source>
          <target state="translated">生成函数序言和尾声后的转储。</target>
        </trans-unit>
        <trans-unit id="337d4408dd5282e57a077069c98fc55c719caf17" translate="yes" xml:space="preserve">
          <source>Dump after hard register copy propagation.</source>
          <target state="translated">硬寄存器拷贝传播后的转储。</target>
        </trans-unit>
        <trans-unit id="6cfe830bfa04c4483b1574a46bcfd925bca4b994" translate="yes" xml:space="preserve">
          <source>Dump after iterated register allocation.</source>
          <target state="translated">迭代寄存器分配后的转储。</target>
        </trans-unit>
        <trans-unit id="1332404cd20a620c3e5eef9263282d44f935e6c1" translate="yes" xml:space="preserve">
          <source>Dump after jump bypassing and control flow optimizations.</source>
          <target state="translated">跳转旁路和控制流优化后的转储。</target>
        </trans-unit>
        <trans-unit id="bbeda7ae9b9627b581ee42ee3d7f61a589a6f9b2" translate="yes" xml:space="preserve">
          <source>Dump after live range splitting.</source>
          <target state="translated">活期范围分割后的转储。</target>
        </trans-unit>
        <trans-unit id="35f1d73925595e51018771690ad76fb0f4a1f233" translate="yes" xml:space="preserve">
          <source>Dump after modulo scheduling. This pass is only run on some architectures.</source>
          <target state="translated">模数调度后的转储。这个通道只在某些架构上运行。</target>
        </trans-unit>
        <trans-unit id="d76e4430e6a8233563404db6f071f4d94eacdd64" translate="yes" xml:space="preserve">
          <source>Dump after partitioning hot and cold basic blocks.</source>
          <target state="translated">对冷热基本块进行分区后甩。</target>
        </trans-unit>
        <trans-unit id="93dacaa1e7ab1044d9cdae673b25a3808eaccbc6" translate="yes" xml:space="preserve">
          <source>Dump after performing the machine dependent reorganization pass, if that pass exists.</source>
          <target state="translated">在执行依赖机器的重组通证后进行转储,如果该通证存在的话。</target>
        </trans-unit>
        <trans-unit id="b6bdb28476f2b3244c70b802b4bb64b0a7243f10" translate="yes" xml:space="preserve">
          <source>Dump after post-reload optimizations.</source>
          <target state="translated">重载后优化后的转储。</target>
        </trans-unit>
        <trans-unit id="88e826a50b33b907232b8a297fb0c5a8f9b2749b" translate="yes" xml:space="preserve">
          <source>Dump after register renumbering.</source>
          <target state="translated">在寄存器重新编号后进行转储。</target>
        </trans-unit>
        <trans-unit id="ababff05976fea728752ca7d70fe16f292f0407d" translate="yes" xml:space="preserve">
          <source>Dump after removing redundant mode switches.</source>
          <target state="translated">去掉冗余模式开关后的转储。</target>
        </trans-unit>
        <trans-unit id="017c4f83a9a4f5ea41d958881b5ab4ae0e8a9034" translate="yes" xml:space="preserve">
          <source>Dump after shortening branches.</source>
          <target state="translated">缩短枝条后倾倒。</target>
        </trans-unit>
        <trans-unit id="b3771d727095e3610636bea776ecdc1fc695644e" translate="yes" xml:space="preserve">
          <source>Dump after sibling call optimizations.</source>
          <target state="translated">同级调用优化后的转储。</target>
        </trans-unit>
        <trans-unit id="c8dbbab140317072ef733bc98b57dcf08d1828c7" translate="yes" xml:space="preserve">
          <source>Dump after sign/zero extension elimination.</source>
          <target state="translated">签/零延时消除后的倾销。</target>
        </trans-unit>
        <trans-unit id="e9bbcf22fbbd3795374ba7c5550d62449e5abb59" translate="yes" xml:space="preserve">
          <source>Dump after the RTL instruction combination pass.</source>
          <target state="translated">RTL指令组合通过后的Dump。</target>
        </trans-unit>
        <trans-unit id="feffc80f8e62ccde9b555546a5afb7ff2768d0f7" translate="yes" xml:space="preserve">
          <source>Dump after the computation of the initial value sets.</source>
          <target state="translated">在计算完初始值集后进行转储。</target>
        </trans-unit>
        <trans-unit id="5bf6c1aae6940dca8add6967093968d70664b454" translate="yes" xml:space="preserve">
          <source>Dump after the initialization of the registers.</source>
          <target state="translated">寄存器初始化后的Dump。</target>
        </trans-unit>
        <trans-unit id="d22e8f2d8c89989fe194bf7d0b0983f1d445d944" translate="yes" xml:space="preserve">
          <source>Dump after the peephole pass.</source>
          <target state="translated">在窥视孔通行证后倾倒。</target>
        </trans-unit>
        <trans-unit id="9201f61bd4694de8e9a9ab14f3cc717f0cf63945" translate="yes" xml:space="preserve">
          <source>Dump after the second jump optimization.</source>
          <target state="translated">二次跳转优化后的转储。</target>
        </trans-unit>
        <trans-unit id="418c902efcddfdb022a1c7b5bf343ea52897c514" translate="yes" xml:space="preserve">
          <source>Dump after the standalone dead code elimination passes.</source>
          <target state="translated">单机死码消除通过后,转储。</target>
        </trans-unit>
        <trans-unit id="79702f60e31788035dc7ae01b75a7919074a5bce" translate="yes" xml:space="preserve">
          <source>Dump after variable tracking.</source>
          <target state="translated">变量跟踪后的转储。</target>
        </trans-unit>
        <trans-unit id="907510a3aae3ec8d9be507f0c620d65e786ea7f0" translate="yes" xml:space="preserve">
          <source>Dump all macro definitions, at the end of preprocessing, in addition to normal output.</source>
          <target state="translated">转储所有宏定义,在预处理结束后,除正常输出外。</target>
        </trans-unit>
        <trans-unit id="c5efd5b60f90b713fff2357c80d7db933b0250ab" translate="yes" xml:space="preserve">
          <source>Dump class hierarchy information. Virtual table information is emitted unless &amp;rsquo;</source>
          <target state="translated">转储类层次结构信息。发出虚拟表信息，除非&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="7bc6ef641876378e44aa64caddde9a5c6398af12" translate="yes" xml:space="preserve">
          <source>Dump content of records.</source>
          <target state="translated">转储记录的内容。</target>
        </trans-unit>
        <trans-unit id="b65d037ae2af66afd4c389367c4bc6cdd9830974" translate="yes" xml:space="preserve">
          <source>Dump debugging information generated during the debug generation phase.</source>
          <target state="translated">转储调试生成阶段产生的调试信息。</target>
        </trans-unit>
        <trans-unit id="c9b2d27d13ca1550be85a391df7269704a34e8f9" translate="yes" xml:space="preserve">
          <source>Dump debugging information generated during the early debug generation phase.</source>
          <target state="translated">转储早期调试生成阶段产生的调试信息。</target>
        </trans-unit>
        <trans-unit id="5d5bde1ac03861eb7f209733ddfd1025c1c70bcf" translate="yes" xml:space="preserve">
          <source>Dump instruction size and location in the assembly code.</source>
          <target state="translated">转储指令大小和在汇编代码中的位置。</target>
        </trans-unit>
        <trans-unit id="754b569854e205d185835c2d9673785b92b6f32c" translate="yes" xml:space="preserve">
          <source>Dump interface declarations for all classes seen in the source file to a file named</source>
          <target state="translated">将源文件中所有类的接口声明转储到一个名为</target>
        </trans-unit>
        <trans-unit id="e881c92154f92df37cd4957d4fba3b310ed362c0" translate="yes" xml:space="preserve">
          <source>Dump out a</source>
          <target state="translated">甩出一个</target>
        </trans-unit>
        <trans-unit id="72d2bf1fd50afe65e57f8ac99ba069fc8e23ed58" translate="yes" xml:space="preserve">
          <source>Dump positions of records.</source>
          <target state="translated">倾倒记录的位置。</target>
        </trans-unit>
        <trans-unit id="09ac4bde087663de0f3a006b963a6f5235611c2d" translate="yes" xml:space="preserve">
          <source>Dump the RTL in the assembler output as a comment before each instruction. Also turns on</source>
          <target state="translated">将汇编器输出中的RTL作为注释在每条指令前倾倒。同时开启</target>
        </trans-unit>
        <trans-unit id="5d265d5ceeb36fc58845a8b5aa258590ef02cc80" translate="yes" xml:space="preserve">
          <source>Dump the final internal representation (RTL) to &lt;var&gt;file&lt;/var&gt;. If the optional argument is omitted (or if &lt;var&gt;file&lt;/var&gt; is &lt;code&gt;.&lt;/code&gt;), the name of the dump file is determined by appending &lt;code&gt;.gkd&lt;/code&gt; to the compilation output file name.</source>
          <target state="translated">转储最终的内部表示（RTL）到 &lt;var&gt;file&lt;/var&gt; 。如果省略了可选参数（或者 &lt;var&gt;file&lt;/var&gt; 为 &lt;code&gt;.&lt;/code&gt; ），则转储文件的名称是通过在编译输出文件名后附加 &lt;code&gt;.gkd&lt;/code&gt; 来确定的。</target>
        </trans-unit>
        <trans-unit id="6290582c1c9788e12ed9d3f73eafdd3bbcd4abf7" translate="yes" xml:space="preserve">
          <source>Dump the raw internal tree data. This option is applicable to C++ only.</source>
          <target state="translated">转储原始内部树数据。这个选项只适用于C++。</target>
        </trans-unit>
        <trans-unit id="5c09bbbb574ea9794181ca0910564f4164221e71" translate="yes" xml:space="preserve">
          <source>Dumps information about call-graph optimization, unused function removal, and inlining decisions.</source>
          <target state="translated">转储有关调用图优化、未使用的函数删除和内联决策的信息。</target>
        </trans-unit>
        <trans-unit id="c057075d7f6d1311d665f05607d5a1143e726ae5" translate="yes" xml:space="preserve">
          <source>Duplicate instances of a template can be avoided by defining an explicit instantiation in one object file, and preventing the compiler from doing implicit instantiations in any other object files by using an explicit instantiation declaration, using the &lt;code&gt;extern template&lt;/code&gt; syntax:</source>
          <target state="translated">通过在一个目标文件中定义一个显式实例，并使用 &lt;code&gt;extern template&lt;/code&gt; 语法使用显式实例化声明，防止编译器在任何其他目标文件中执行隐式实例，可以避免模板的重复实例：</target>
        </trans-unit>
        <trans-unit id="873001cb1e8e159e206fe4747ed8630083de92b7" translate="yes" xml:space="preserve">
          <source>During its analysis of function bodies, IPA-CP employs alias analysis in order to track values pointed to by function parameters. In order not spend too much time analyzing huge functions, it gives up and consider all memory clobbered after examining</source>
          <target state="translated">在分析函数体的过程中,IPA-CP采用了别名分析,以跟踪函数参数所指向的值。为了不花太多时间分析庞大的函数,它在检查完之后就放弃了,认为所有的内存都被抢光了。</target>
        </trans-unit>
        <trans-unit id="35ad8603f50d24cddaa26acc281e43114f0f03d6" translate="yes" xml:space="preserve">
          <source>During the incremental link (by</source>
          <target state="translated">在增量环节(由</target>
        </trans-unit>
        <trans-unit id="6e5d8e172227784c44cef25322c1d84b5b1ed089" translate="yes" xml:space="preserve">
          <source>During the link-time optimization warn about type mismatches in global declarations from different compilation units. Requires</source>
          <target state="translated">在链接时间优化期间,警告来自不同编译单元的全局声明的类型不匹配。需要</target>
        </trans-unit>
        <trans-unit id="1ed8a7568d4927beb8ca9fcc2f434426a2ed3775" translate="yes" xml:space="preserve">
          <source>Dynamic rounding mode. A field in the floating-point control register (&lt;var&gt;fpcr&lt;/var&gt;, see Alpha architecture reference manual) controls the rounding mode in effect. The C library initializes this register for rounding towards plus infinity. Thus, unless your program modifies the &lt;var&gt;fpcr&lt;/var&gt;, &amp;lsquo;</source>
          <target state="translated">动态舍入模式。浮点控制寄存器（ &lt;var&gt;fpcr&lt;/var&gt; ，请参见Alpha体系结构参考手册）中的字段控制有效的舍入模式。C库初始化此寄存器以使其向加无穷大舍入。因此，除非您的程序修改了 &lt;var&gt;fpcr&lt;/var&gt; ，</target>
        </trans-unit>
        <trans-unit id="ee61e1d4359d2101e0207f1f6ab138bc105fa253" translate="yes" xml:space="preserve">
          <source>Dynamically allocate condition code registers.</source>
          <target state="translated">动态分配条件代码寄存器。</target>
        </trans-unit>
        <trans-unit id="e0184adedf913b076626646d3f52c3b49c39ad6d" translate="yes" xml:space="preserve">
          <source>E</source>
          <target state="translated">E</target>
        </trans-unit>
        <trans-unit id="8424e737649ba7f5ce9529e01136274dd622c253" translate="yes" xml:space="preserve">
          <source>E+</source>
          <target state="translated">E+</target>
        </trans-unit>
        <trans-unit id="b86bd135c70e92d6b2051a988af8d8fd3b21cb67" translate="yes" xml:space="preserve">
          <source>E-</source>
          <target state="translated">E-</target>
        </trans-unit>
        <trans-unit id="fa4a7a170f7075560c98a976572cae386b13a240" translate="yes" xml:space="preserve">
          <source>E.g.</source>
          <target state="translated">E.g.</target>
        </trans-unit>
        <trans-unit id="180b58cf69b13102962b17f297dd40af5fac3b7a" translate="yes" xml:space="preserve">
          <source>EAM register &lt;code&gt;mdb&lt;/code&gt;</source>
          <target state="translated">EAM寄存器 &lt;code&gt;mdb&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4183eec55a2657bd56f5a3f286167e22c41277ca" translate="yes" xml:space="preserve">
          <source>EAM register &lt;code&gt;mdc&lt;/code&gt;</source>
          <target state="translated">EAM寄存器 &lt;code&gt;mdc&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="042b890a506cb1f86b057af9f2065c60f0543326" translate="yes" xml:space="preserve">
          <source>ESC</source>
          <target state="translated">ESC</target>
        </trans-unit>
        <trans-unit id="ef29ed353f79614b0af0aa06877e0e8365ad41a3" translate="yes" xml:space="preserve">
          <source>EV</source>
          <target state="translated">EV</target>
        </trans-unit>
        <trans-unit id="8404c13b819cbc829893e6fcf7e6b011dc8afafa" translate="yes" xml:space="preserve">
          <source>EXEC register (EXEC_LO and EXEC_HI)</source>
          <target state="translated">EXEC 寄存器 (EXEC_LO 和 EXEC_HI)</target>
        </trans-unit>
        <trans-unit id="3633746b067241666bc462dcfe7a24ff23a8db68" translate="yes" xml:space="preserve">
          <source>Each</source>
          <target state="translated">Each</target>
        </trans-unit>
        <trans-unit id="ec76a07122ba99b0a9685803ebd0fcbd4bc2bfc8" translate="yes" xml:space="preserve">
          <source>Each &amp;lsquo;</source>
          <target state="translated">每个'</target>
        </trans-unit>
        <trans-unit id="7a238e89c65aac1db813f790141cd6a1706499a7" translate="yes" xml:space="preserve">
          <source>Each &lt;var&gt;branch&lt;/var&gt; has the following form:</source>
          <target state="translated">每个 &lt;var&gt;branch&lt;/var&gt; 具有以下形式：</target>
        </trans-unit>
        <trans-unit id="3994e33e5e0917632f9e9de329b4a0f3ad3998af" translate="yes" xml:space="preserve">
          <source>Each &lt;var&gt;file&lt;/var&gt; has the following form:</source>
          <target state="translated">每个 &lt;var&gt;file&lt;/var&gt; 具有以下形式：</target>
        </trans-unit>
        <trans-unit id="c75857c9773e24edc3bfc44893ae2b0b910e079d" translate="yes" xml:space="preserve">
          <source>Each &lt;var&gt;function&lt;/var&gt; has the following form:</source>
          <target state="translated">每个 &lt;var&gt;function&lt;/var&gt; 具有以下形式：</target>
        </trans-unit>
        <trans-unit id="62acae4631fd900e861a22b9b523800b0a789662" translate="yes" xml:space="preserve">
          <source>Each &lt;var&gt;line&lt;/var&gt; has the following form:</source>
          <target state="translated">每 &lt;var&gt;line&lt;/var&gt; 具有以下形式：</target>
        </trans-unit>
        <trans-unit id="1c50fb88397b0c7346926cd4cd765575f7023e36" translate="yes" xml:space="preserve">
          <source>Each architecture defines additional constraints. These constraints are used by the compiler itself for instruction generation, as well as for &lt;code&gt;asm&lt;/code&gt; statements; therefore, some of the constraints are not particularly useful for &lt;code&gt;asm&lt;/code&gt;. Here is a summary of some of the machine-dependent constraints available on some particular machines; it includes both constraints that are useful for &lt;code&gt;asm&lt;/code&gt; and constraints that aren&amp;rsquo;t. The compiler source file mentioned in the table heading for each architecture is the definitive reference for the meanings of that architecture&amp;rsquo;s constraints.</source>
          <target state="translated">每种体系结构都定义了其他约束。这些约束由编译器本身用于指令生成以及 &lt;code&gt;asm&lt;/code&gt; 语句。因此，某些约束对于 &lt;code&gt;asm&lt;/code&gt; 并不是特别有用。这是某些特定机器上可用的一些与机器有关的约束的摘要。它既包括对 &lt;code&gt;asm&lt;/code&gt; 有用的约束，又包括对asm无用的约束。表标题中针对每种体系结构提到的编译器源文件是该体系结构约束含义的权威参考。</target>
        </trans-unit>
        <trans-unit id="9a8f7e527e362e2f465669113fa77cfedd4d35d0" translate="yes" xml:space="preserve">
          <source>Each argument to the macro appears only once in the expansion of the macro. This prevents the size of the macro expansion growing exponentially when calls to such macros are nested inside arguments of such macros.</source>
          <target state="translated">宏的每个参数在宏的扩展中只出现一次。这就防止了当对这类宏的调用嵌套在这类宏的参数内时,宏扩展的大小成倍增长。</target>
        </trans-unit>
        <trans-unit id="76b41f32117ccc7bbc36f4b00ab7cb610cec2b62" translate="yes" xml:space="preserve">
          <source>Each argument, with the type encoding, followed by the offset (in bytes) of the argument in the list of parameters.</source>
          <target state="translated">每个参数,都有类型编码,后面是参数在参数列表中的偏移量(单位:字节)。</target>
        </trans-unit>
        <trans-unit id="e6b2353f285a19086a3e061a5dcfed498d63a240" translate="yes" xml:space="preserve">
          <source>Each identifier is visible from where it is declared until the end of the enclosing block.</source>
          <target state="translated">每一个标识符从它被声明的地方开始就可见,直到包围块的最后。</target>
        </trans-unit>
        <trans-unit id="01e3221d2b21a8f447ed5a0ced29ddbea2cbee30" translate="yes" xml:space="preserve">
          <source>Each implementation shall include documentation that identifies all conditionally-supported constructs that it does not support (C++0x 1.4).</source>
          <target state="translated">每个实现都应包含文档,以确定它不支持的所有有条件支持的构造(C++0x 1.4)。</target>
        </trans-unit>
        <trans-unit id="701d795fb8ee42f93e3f4a253aa01935ee62e44d" translate="yes" xml:space="preserve">
          <source>Each kind of machine has a default for what &lt;code&gt;char&lt;/code&gt; should be. It is either like &lt;code&gt;unsigned char&lt;/code&gt; by default or like &lt;code&gt;signed char&lt;/code&gt; by default.</source>
          <target state="translated">每种机器都有默认的 &lt;code&gt;char&lt;/code&gt; 字符。默认情况下，它就像 &lt;code&gt;unsigned char&lt;/code&gt; ，或者默认情况下像 &lt;code&gt;signed char&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ef05478f4365f65d0ddfa7b0d492a5a495d01714" translate="yes" xml:space="preserve">
          <source>Each of the following options must be the same when building and using the precompiled header:</source>
          <target state="translated">在构建和使用预编译头时,以下每个选项必须是相同的。</target>
        </trans-unit>
        <trans-unit id="12375fa3bc94216fddfb3082e628f5277fd37349" translate="yes" xml:space="preserve">
          <source>Each of these represents a register constraint for an individual register, from r0 to r10.</source>
          <target state="translated">每一个都代表了一个单独寄存器的寄存器约束,从r0到r10。</target>
        </trans-unit>
        <trans-unit id="c7c856c52d5df36a325270b79c39dbe4777d924c" translate="yes" xml:space="preserve">
          <source>Each target machine supported by GCC can have its own options&amp;mdash;for example, to allow you to compile for a particular processor variant or ABI, or to control optimizations specific to that machine. By convention, the names of machine-specific options start with &amp;lsquo;</source>
          <target state="translated">GCC支持的每个目标计算机都可以有其自己的选项，例如，允许您针对特定的处理器变体或ABI进行编译，或控制特定于该计算机的优化。按照惯例，特定于计算机的选项的名称以'</target>
        </trans-unit>
        <trans-unit id="e1bf5c8e09d672f359406f3ca337be92c84db460" translate="yes" xml:space="preserve">
          <source>Each variable&amp;rsquo;s value is a list of directories separated by a special character, much like &lt;code&gt;PATH&lt;/code&gt;, in which to look for header files. The special character, &lt;code&gt;PATH_SEPARATOR&lt;/code&gt;, is target-dependent and determined at GCC build time. For Microsoft Windows-based targets it is a semicolon, and for almost all other targets it is a colon.</source>
          <target state="translated">每个变量的值都是用特殊字符分隔的目录列表，类似于 &lt;code&gt;PATH&lt;/code&gt; ，在其中查找头文件。特殊字符 &lt;code&gt;PATH_SEPARATOR&lt;/code&gt; 取决于目标，并在GCC构建时确定。对于基于Microsoft Windows的目标，它是一个分号，对于几乎所有其他目标，它是一个冒号。</target>
        </trans-unit>
        <trans-unit id="9fc7669bba8b360ced14bcd0e63ab75ab5c8df7f" translate="yes" xml:space="preserve">
          <source>Embedded statements are not allowed in constant expressions, such as the value of an enumeration constant, the width of a bit-field, or the initial value of a static variable.</source>
          <target state="translated">在常量表达式中不允许嵌入语句,如枚举常量的值、位域的宽度或静态变量的初始值。</target>
        </trans-unit>
        <trans-unit id="948e9b48ea593e051a4153362a7090d684f2c222" translate="yes" xml:space="preserve">
          <source>Emit (do not emit) RISC-V attribute to record extra information into ELF objects. This feature requires at least binutils 2.32.</source>
          <target state="translated">发射(不发射)RISC-V属性,将额外信息记录到ELF对象中。这个功能至少需要 binutils 2.32。</target>
        </trans-unit>
        <trans-unit id="070ac08031f3d1c435e4576ba37695a82ca0786d" translate="yes" xml:space="preserve">
          <source>Emit (do not emit) code that allows &lt;code&gt;_mcount&lt;/code&gt; to modify the calling function&amp;rsquo;s return address. When enabled, this option extends the usual &lt;code&gt;_mcount&lt;/code&gt; interface with a new &lt;var&gt;ra-address&lt;/var&gt; parameter, which has type &lt;code&gt;intptr_t *&lt;/code&gt; and is passed in register &lt;code&gt;$12&lt;/code&gt;. &lt;code&gt;_mcount&lt;/code&gt; can then modify the return address by doing both of the following:</source>
          <target state="translated">发出（不发出）允许 &lt;code&gt;_mcount&lt;/code&gt; 修改调用函数的返回地址的代码。启用后，此选项将使用新的 &lt;var&gt;ra-address&lt;/var&gt; 参数扩展常规 &lt;code&gt;_mcount&lt;/code&gt; 接口，该参数的类型为 &lt;code&gt;intptr_t *&lt;/code&gt; 并在寄存器 &lt;code&gt;$12&lt;/code&gt; 传递。 &lt;code&gt;_mcount&lt;/code&gt; 然后可以通过执行以下两个操作来修改返回地址：</target>
        </trans-unit>
        <trans-unit id="ff5e30537593e35e64b6a16b2c1bdbe42c087863" translate="yes" xml:space="preserve">
          <source>Emit .gnu_attribute assembly directives to set tag/value pairs in a .gnu.attributes section that specify ABI variations in function parameters or return values.</source>
          <target state="translated">发出.gnu_attribute汇编指令,在.gnu.attribute部分设置标签/值对,指定函数参数或返回值的ABI变化。</target>
        </trans-unit>
        <trans-unit id="20bf9a915993aa5a7a1666c72b879d8cd3f7ac3e" translate="yes" xml:space="preserve">
          <source>Emit &lt;code&gt;.stack_size&lt;/code&gt; directives for each function in the assembly output. This option defaults to off.</source>
          <target state="translated">在程序集输出中为每个函数发出 &lt;code&gt;.stack_size&lt;/code&gt; 指令。此选项默认为关闭。</target>
        </trans-unit>
        <trans-unit id="2f04fa21301da1a9e382b512bcad8e362a751619" translate="yes" xml:space="preserve">
          <source>Emit &lt;code&gt;static&lt;/code&gt; functions into the object file, even if the function is never used.</source>
          <target state="translated">将 &lt;code&gt;static&lt;/code&gt; 函数发送到目标文件中，即使从未使用过该函数也是如此。</target>
        </trans-unit>
        <trans-unit id="cb38e0a4e398a1b8eae664d56e6c229db862f612" translate="yes" xml:space="preserve">
          <source>Emit &lt;var&gt;num&lt;/var&gt; NOPs before every other generated instruction.</source>
          <target state="translated">在每隔一条生成的指令之前发出 &lt;var&gt;num&lt;/var&gt; NOP。</target>
        </trans-unit>
        <trans-unit id="3da3562e4f5b4b2c349aec3c276d4ecf1abb3a7e" translate="yes" xml:space="preserve">
          <source>Emit DWARF unwind info as compiler generated &lt;code&gt;.eh_frame&lt;/code&gt; section instead of using GAS &lt;code&gt;.cfi_*&lt;/code&gt; directives.</source>
          <target state="translated">将DWARF展开信息作为编译器生成的 &lt;code&gt;.eh_frame&lt;/code&gt; 节而不是使用GAS &lt;code&gt;.cfi_*&lt;/code&gt; 指令发送。</target>
        </trans-unit>
        <trans-unit id="661cfa361d4a5be25ea38381adeec0544f3162ba" translate="yes" xml:space="preserve">
          <source>Emit a special marker instructing &lt;code&gt;ld(1)&lt;/code&gt; not to statically link in the resulting object file, and allow &lt;code&gt;dyld(1)&lt;/code&gt; to load it in at run time instead. This is used in conjunction with the Fix-and-Continue debugging mode, where the object file in question may be recompiled and dynamically reloaded in the course of program execution, without the need to restart the program itself. Currently, Fix-and-Continue functionality is only available in conjunction with the NeXT runtime on Mac OS X 10.3 and later.</source>
          <target state="translated">发出一个特殊的标记，指示 &lt;code&gt;ld(1)&lt;/code&gt; 不要静态链接到生成的目标文件中，并允许 &lt;code&gt;dyld(1)&lt;/code&gt; 在运行时加载它。这与&amp;ldquo;修复并继续&amp;rdquo;调试模式结合使用，在该模式下，可以在程序执行过程中重新编译并动态重新加载所讨论的目标文件，而无需重新启动程序本身。目前，&amp;ldquo;修复并继续&amp;rdquo;功能仅可与Mac OS X 10.3及更高版本上的NeXT运行时结合使用。</target>
        </trans-unit>
        <trans-unit id="7e8645e36e17a7945813986a8d0a71d3821820d0" translate="yes" xml:space="preserve">
          <source>Emit a warning if the current function exceeds the given frame size. Because this is a compile-time check it doesn&amp;rsquo;t need to be a real problem when the program runs. It is intended to identify functions that most probably cause a stack overflow. It is useful to be used in an environment with limited stack size e.g. the linux kernel.</source>
          <target state="translated">如果当前功能超出给定的帧大小，则发出警告。因为这是编译时检查，所以在程序运行时并不一定是真正的问题。它旨在确定最有可能导致堆栈溢出的功能。在堆栈大小有限的环境中使用该功能很有用，例如linux内核。</target>
        </trans-unit>
        <trans-unit id="e60a4bf4bc37e66d9947816b7195c8391e4776d0" translate="yes" xml:space="preserve">
          <source>Emit a warning if the function calls &lt;code&gt;alloca&lt;/code&gt; or uses dynamically-sized arrays. This is generally a bad idea with a limited stack size.</source>
          <target state="translated">如果函数调用 &lt;code&gt;alloca&lt;/code&gt; 或使用动态大小的数组，则发出警告。通常，在堆栈大小有限的情况下，这是一个坏主意。</target>
        </trans-unit>
        <trans-unit id="9b489883dd494ef67ae3146bb7729487672712a9" translate="yes" xml:space="preserve">
          <source>Emit callgraph information.</source>
          <target state="translated">发出调用信息。</target>
        </trans-unit>
        <trans-unit id="f2b5ec1d50c73d9342d0da2e8de77ea3e8b06bfb" translate="yes" xml:space="preserve">
          <source>Emit debug information for struct-like types only when the base name of the compilation source file matches the base name of file in which the struct is defined.</source>
          <target state="translated">只有当编译源文件的基名与定义结构体的文件基名一致时,才会发出类结构体类型的调试信息。</target>
        </trans-unit>
        <trans-unit id="ea8ad7a3ce89000c68597a212e3b7e178630bf37" translate="yes" xml:space="preserve">
          <source>Emit debug information for struct-like types only when the base name of the compilation source file matches the base name of file in which the type is defined, unless the struct is a template or defined in a system header.</source>
          <target state="translated">只有当编译源文件的基名与定义该类型的文件基名一致时,才会发出类结构类型的调试信息,除非该结构是模板或定义在系统头中。</target>
        </trans-unit>
        <trans-unit id="bcf9409c139607d0741250959d86960d9d3fc823" translate="yes" xml:space="preserve">
          <source>Emit debugging information for all symbols and types.</source>
          <target state="translated">发出所有符号和类型的调试信息。</target>
        </trans-unit>
        <trans-unit id="8a7c3f8e8609e257b077878b6041fc34297f5e52" translate="yes" xml:space="preserve">
          <source>Emit debugging information for symbols that are used. For stabs debugging format, this enables</source>
          <target state="translated">发出使用的符号的调试信息。对于stabs的调试格式,这可以使</target>
        </trans-unit>
        <trans-unit id="b01323833aaf7728ad582d052fc8f41810ddeadf" translate="yes" xml:space="preserve">
          <source>Emit extra code to check for buffer overflows, such as stack smashing attacks. This is done by adding a guard variable to functions with vulnerable objects. This includes functions that call &lt;code&gt;alloca&lt;/code&gt;, and functions with buffers larger than 8 bytes. The guards are initialized when a function is entered and then checked when the function exits. If a guard check fails, an error message is printed and the program exits.</source>
          <target state="translated">发出额外的代码以检查缓冲区溢出，例如堆栈破坏攻击。这是通过向具有易受攻击对象的函数添加一个保护变量来完成的。这包括调用 &lt;code&gt;alloca&lt;/code&gt; 的函数以及缓冲区大于8个字节的函数。在进入功能时初始化防护，然后在功能退出时检查。如果防护检查失败，则会显示一条错误消息并退出程序。</target>
        </trans-unit>
        <trans-unit id="141c4b8396ef386665e92dca002cbfbddd934501" translate="yes" xml:space="preserve">
          <source>Emit fix-it hints in a machine-parseable format, suitable for consumption by IDEs. For each fix-it, a line will be printed after the relevant diagnostic, starting with the string &amp;ldquo;fix-it:&amp;rdquo;. For example:</source>
          <target state="translated">以机器可解析的格式发出修复提示，适合IDE使用。对于每个修复程序，将在相关诊断后打印一行，以字符串&amp;ldquo; fix-it：&amp;rdquo;开头。例如：</target>
        </trans-unit>
        <trans-unit id="1a5a47bca88794809e7e2a3bb7e287c60614c83b" translate="yes" xml:space="preserve">
          <source>Emit function prologues only before parts of the function that need it, rather than at the top of the function. This flag is enabled by default at</source>
          <target state="translated">只在需要函数序言的部分之前,而不是在函数的顶部,才会发出函数序言。这个标志默认在</target>
        </trans-unit>
        <trans-unit id="7a29575e26772eb5ddc3404ae8049245b33348e5" translate="yes" xml:space="preserve">
          <source>Emit location column information into DWARF debugging information, rather than just file and line. This option is enabled by default.</source>
          <target state="translated">在DWARF调试信息中输入位置列信息,而不仅仅是文件和行。该选项默认为启用。</target>
        </trans-unit>
        <trans-unit id="669b4b85cda6e8d55a22a680d295c7c66356a584" translate="yes" xml:space="preserve">
          <source>Emit perf-like colored output for hot lines. Legend of the color scale is printed at the very beginning of the output file.</source>
          <target state="translated">发出类似敷衍的彩色输出,用于热线。在输出文件的开头打印色标的图例。</target>
        </trans-unit>
        <trans-unit id="bf88babe6e871b26c963f43a03a560a58bbbd726" translate="yes" xml:space="preserve">
          <source>Emit statistics about front-end processing at the end of the compilation. This option is supported only by the C++ front end, and the information is generally only useful to the G++ development team.</source>
          <target state="translated">在编译结束时发出有关前端处理的统计信息。这个选项只有C++前端支持,这些信息一般只对G++开发团队有用。</target>
        </trans-unit>
        <trans-unit id="986149807dd103440d26581e0c8034fe654a931b" translate="yes" xml:space="preserve">
          <source>Emit variables declared &lt;code&gt;static const&lt;/code&gt; when optimization isn&amp;rsquo;t turned on, even if the variables aren&amp;rsquo;t referenced.</source>
          <target state="translated">在未启用优化的情况下，即使未引用变量，也要发出声明为 &lt;code&gt;static const&lt;/code&gt; 的变量。</target>
        </trans-unit>
        <trans-unit id="7039662b9ecdfee8f51909b1bca797f2d5646847" translate="yes" xml:space="preserve">
          <source>Empty. Empty attributes are ignored.</source>
          <target state="translated">空。空属性被忽略。</target>
        </trans-unit>
        <trans-unit id="dee5764f5fbac8ea9eadf819b59721dd60ce4b7b" translate="yes" xml:space="preserve">
          <source>En_US</source>
          <target state="translated">En_US</target>
        </trans-unit>
        <trans-unit id="20063ad9053289cecaa20ae630ed2dd758282a07" translate="yes" xml:space="preserve">
          <source>Enable</source>
          <target state="translated">Enable</target>
        </trans-unit>
        <trans-unit id="4fa0f6fb6e440f220b80c6c2d4888a44c80062d9" translate="yes" xml:space="preserve">
          <source>Enable &amp;lsquo;</source>
          <target state="translated">启用&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="e92d7b5eafccf1d9c2c8bae0da3467a97bfe43eb" translate="yes" xml:space="preserve">
          <source>Enable (disable) an optimization that pairs consecutive load or store instructions to enable load/store bonding. This option is enabled by default but only takes effect when the selected architecture is known to support bonding.</source>
          <target state="translated">启用(禁用)一项优化,将连续的加载或存储指令配对以启用加载/存储绑定。该选项默认为启用,但只有在已知所选架构支持绑定时才会生效。</target>
        </trans-unit>
        <trans-unit id="a5876c1f4b70b8a6258f54ff9e4b48ce21c8e2cc" translate="yes" xml:space="preserve">
          <source>Enable (disable) frame header optimization in the o32 ABI. When using the o32 ABI, calling functions will allocate 16 bytes on the stack for the called function to write out register arguments. When enabled, this optimization will suppress the allocation of the frame header if it can be determined that it is unused.</source>
          <target state="translated">在o32 ABI中启用(禁用)帧头优化。当使用o32 ABI时,调用函数将在堆栈上分配16个字节供被调用函数写出寄存器参数。当启用时,如果可以确定帧头未被使用,该优化将抑制帧头的分配。</target>
        </trans-unit>
        <trans-unit id="69fa958a8a2e61f2783ede1c3821c1af600c12f1" translate="yes" xml:space="preserve">
          <source>Enable (disable) generation of &lt;code&gt;synci&lt;/code&gt; instructions on architectures that support it. The &lt;code&gt;synci&lt;/code&gt; instructions (if enabled) are generated when &lt;code&gt;__builtin___clear_cache&lt;/code&gt; is compiled.</source>
          <target state="translated">在支持它的体系结构上启用（禁用） &lt;code&gt;synci&lt;/code&gt; 指令的生成。该 &lt;code&gt;synci&lt;/code&gt; 当指令（如果启用）产生 &lt;code&gt;__builtin___clear_cache&lt;/code&gt; 编译。</target>
        </trans-unit>
        <trans-unit id="affa7a90abe6524cdcc085355a0cf87de25de669" translate="yes" xml:space="preserve">
          <source>Enable (disable) the use of the built-in functions that allow direct access to the Hardware Transactional Memory (HTM) instructions that were added in version 2.07 of the PowerPC ISA.</source>
          <target state="translated">启用(禁用)使用内置功能,允许直接访问PowerPC ISA 2.07版本中添加的硬件事务性内存(HTM)指令。</target>
        </trans-unit>
        <trans-unit id="a9d43112761b398944fa6b8aebeadd62b27a6873" translate="yes" xml:space="preserve">
          <source>Enable (disable) use of the &lt;code&gt;%hi()&lt;/code&gt; and &lt;code&gt;%lo()&lt;/code&gt; assembler relocation operators. This option has been superseded by</source>
          <target state="translated">启用（禁用） &lt;code&gt;%hi()&lt;/code&gt; 和 &lt;code&gt;%lo()&lt;/code&gt; 汇编器重定位运算符的使用。此选项已被取代</target>
        </trans-unit>
        <trans-unit id="22e717c26fa88a4531e1982fba5a0708a2d39b81" translate="yes" xml:space="preserve">
          <source>Enable (disable) use of the &lt;code&gt;mad&lt;/code&gt;, &lt;code&gt;madu&lt;/code&gt; and &lt;code&gt;mul&lt;/code&gt; instructions, as provided by the R4650 ISA.</source>
          <target state="translated">启用（禁用）R4650 ISA提供的 &lt;code&gt;mad&lt;/code&gt; ， &lt;code&gt;madu&lt;/code&gt; 和 &lt;code&gt;mul&lt;/code&gt; 指令的使用。</target>
        </trans-unit>
        <trans-unit id="d7e0884ba3d3cc932c864d47a1ad9e75ce9d3f27" translate="yes" xml:space="preserve">
          <source>Enable (disable) use of the &lt;code&gt;madd&lt;/code&gt; and &lt;code&gt;msub&lt;/code&gt; integer instructions. The default is</source>
          <target state="translated">启用（禁用） &lt;code&gt;madd&lt;/code&gt; 和 &lt;code&gt;msub&lt;/code&gt; 整数指令。默认是</target>
        </trans-unit>
        <trans-unit id="fb69f64525577d36a129060c4be04db4c7157197" translate="yes" xml:space="preserve">
          <source>Enable (disable) use of the floating-point multiply-accumulate instructions, when they are available. The default is</source>
          <target state="translated">当浮点乘法累加指令可用时,启用(禁用)这些指令。默认值是</target>
        </trans-unit>
        <trans-unit id="a72dea94649019bb860dd9ef3c4021f60f45fa32" translate="yes" xml:space="preserve">
          <source>Enable 64-bit AIX ABI and calling convention: 64-bit pointers, 64-bit &lt;code&gt;long&lt;/code&gt; type, and the infrastructure needed to support them. Specifying</source>
          <target state="translated">启用64位AIX ABI和调用约定：64位指针，64位 &lt;code&gt;long&lt;/code&gt; 类型以及支持它们的基础结构。指定</target>
        </trans-unit>
        <trans-unit id="e8bed769cd5303c03eac96915f98c0018f45868e" translate="yes" xml:space="preserve">
          <source>Enable &lt;code&gt;div&lt;/code&gt; and &lt;code&gt;rem&lt;/code&gt; instructions for ARCv2 cores.</source>
          <target state="translated">启用ARCv2内核的 &lt;code&gt;div&lt;/code&gt; 和 &lt;code&gt;rem&lt;/code&gt; 指令。</target>
        </trans-unit>
        <trans-unit id="2b739befdde9d37b726baa741659e214041a11f0" translate="yes" xml:space="preserve">
          <source>Enable AddressSanitizer for Linux kernel. See &lt;a href=&quot;https://github.com/google/kasan/wiki&quot;&gt;https://github.com/google/kasan/wiki&lt;/a&gt; for more details.</source>
          <target state="translated">为Linux内核启用AddressSanitizer。有关更多详细信息，请参见&lt;a href=&quot;https://github.com/google/kasan/wiki&quot;&gt;https://github.com/google/kasan/wiki&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="dd5750bb548742f5f6797880a8c614d311fe2963" translate="yes" xml:space="preserve">
          <source>Enable AddressSanitizer, a fast memory error detector. Memory access instructions are instrumented to detect out-of-bounds and use-after-free bugs. The option enables</source>
          <target state="translated">启用快速内存错误检测器AddressSanitizer。对内存访问指令进行检测,以检测越界和使用后的错误。该选项可以启用</target>
        </trans-unit>
        <trans-unit id="b884f9df2c0fdf875f501de19eb4a43163aded4e" translate="yes" xml:space="preserve">
          <source>Enable Advanced SIMD instructions. This also enables floating-point instructions. This is on by default for all possible values for options</source>
          <target state="translated">启用高级SIMD指令。这也启用了浮点指令。对于选项的所有可能值,默认为开启</target>
        </trans-unit>
        <trans-unit id="1737ee87e4af9d47c80e040e08ffbf40c4cf4499" translate="yes" xml:space="preserve">
          <source>Enable C-SKY DSP, Enhanced DSP, or Vector DSP instructions, respectively. All of these options default to off.</source>
          <target state="translated">分别启用C-SKY DSP、Enhanced DSP或Vector DSP指令。所有这些选项都默认为关闭。</target>
        </trans-unit>
        <trans-unit id="460dd2625e669a6da5fd8971a359142b70341354" translate="yes" xml:space="preserve">
          <source>Enable C-SKY security instructions; the default is off.</source>
          <target state="translated">启用C-SKY安全指令,默认为关闭。</target>
        </trans-unit>
        <trans-unit id="be1993c993457eac4e123ff5ca8683dff8eb6707" translate="yes" xml:space="preserve">
          <source>Enable C-SKY trust instructions; the default is off.</source>
          <target state="translated">启用C-SKY信任指令,默认为关闭。</target>
        </trans-unit>
        <trans-unit id="db19cd91956a3cc7c7ec589751c003754ab24a04" translate="yes" xml:space="preserve">
          <source>Enable CFG-sensitive rematerialization in LRA. Instead of loading values of spilled pseudos, LRA tries to rematerialize (recalculate) values if it is profitable.</source>
          <target state="translated">在LRA中启用对CFG敏感的再材料化。如果有利可图,LRA会尝试重新材料化(重新计算),而不是加载溢出的伪值。</target>
        </trans-unit>
        <trans-unit id="3228c63b76a89731a999face742dbc8e98e43fb7" translate="yes" xml:space="preserve">
          <source>Enable CRC extension. This is on by default for</source>
          <target state="translated">启用CRC扩展。默认情况下,这对于</target>
        </trans-unit>
        <trans-unit id="6f57bb69abaacf2d80f6a8ad9ba44e14d8d03b75" translate="yes" xml:space="preserve">
          <source>Enable CRIS-specific verbose debug-related information in the assembly code. This option also has the effect of turning off the &amp;lsquo;</source>
          <target state="translated">在汇编代码中启用特定于CRIS的详细调试相关信息。此选项还具有关闭&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="a77b829448e4eeb6288384fb17669c5c039a4b5e" translate="yes" xml:space="preserve">
          <source>Enable Crypto extension. This also enables Advanced SIMD and floating-point instructions.</source>
          <target state="translated">启用Crypto扩展。这也可以启用高级SIMD和浮点指令。</target>
        </trans-unit>
        <trans-unit id="c34f6f6c7e11aa9f0332985736de3e72e193f5ba" translate="yes" xml:space="preserve">
          <source>Enable FP16 extension. This also enables floating-point instructions.</source>
          <target state="translated">启用FP16扩展。这也可以启用浮点指令。</target>
        </trans-unit>
        <trans-unit id="2babb7d5abaf4060eeca52d7ae4316df315816d6" translate="yes" xml:space="preserve">
          <source>Enable FP16 fmla extension. This also enables FP16 extensions and floating-point instructions. This option is enabled by default for</source>
          <target state="translated">启用FP16 fmla扩展。这也启用了FP16扩展和浮点指令。该选项默认为</target>
        </trans-unit>
        <trans-unit id="3a8ba9a41b704d15493ebc76a0b1f017540a81f2" translate="yes" xml:space="preserve">
          <source>Enable IPA pass &lt;var&gt;pass&lt;/var&gt;. &lt;var&gt;pass&lt;/var&gt; is the pass name. If the same pass is statically invoked in the compiler multiple times, the pass name should be appended with a sequential number starting from 1.</source>
          <target state="translated">启用IPA pass &lt;var&gt;pass&lt;/var&gt; 。 &lt;var&gt;pass&lt;/var&gt; 是通过名称。如果在编译器中多次静态调用同一遍，则遍历名称应附加从1开始的序列号。</target>
        </trans-unit>
        <trans-unit id="17d5ca6696a8cdc79b6dc05a7cd14c4945472844" translate="yes" xml:space="preserve">
          <source>Enable Large System Extension instructions. This is on by default for</source>
          <target state="translated">启用大型系统扩展指令。对于以下情况,默认为开启</target>
        </trans-unit>
        <trans-unit id="5313db34f510b6a28a51ef561341a7742309082f" translate="yes" xml:space="preserve">
          <source>Enable LeakSanitizer, a memory leak detector. This option only matters for linking of executables and the executable is linked against a library that overrides &lt;code&gt;malloc&lt;/code&gt; and other allocator functions. See &lt;a href=&quot;https://github.com/google/sanitizers/wiki/AddressSanitizerLeakSanitizer&quot;&gt;https://github.com/google/sanitizers/wiki/AddressSanitizerLeakSanitizer&lt;/a&gt; for more details. The run-time behavior can be influenced using the &lt;code&gt;LSAN_OPTIONS&lt;/code&gt; environment variable. The option cannot be combined with</source>
          <target state="translated">启用内存泄漏检测器LeakSanitizer。此选项仅对链接可执行文件很重要，并且可执行文件是针对覆盖 &lt;code&gt;malloc&lt;/code&gt; 和其他分配程序功能的库的。有关更多详细信息，请参见&lt;a href=&quot;https://github.com/google/sanitizers/wiki/AddressSanitizerLeakSanitizer&quot;&gt;https://github.com/google/sanitizers/wiki/AddressSanitizerLeakSanitizer&lt;/a&gt;。可以使用 &lt;code&gt;LSAN_OPTIONS&lt;/code&gt; 环境变量来影响运行时行为。该选项不能与</target>
        </trans-unit>
        <trans-unit id="963f7996b716be1c17df5a79ae31f2f9bb23a517" translate="yes" xml:space="preserve">
          <source>Enable Local Register Allocation. This is still experimental for ARC, so by default the compiler uses standard reload (i.e.</source>
          <target state="translated">启用本地寄存器分配。这对ARC来说还是试验性的,所以默认情况下,编译器使用标准的重载(即</target>
        </trans-unit>
        <trans-unit id="3bd13a89a3ec768d816679409bb63a5907cc342b" translate="yes" xml:space="preserve">
          <source>Enable Local Register Allocation. This is still experimental for FT32, so by default the compiler uses standard reload.</source>
          <target state="translated">启用本地寄存器分配。这对FT32来说还是试验性的,所以默认情况下,编译器使用标准重载。</target>
        </trans-unit>
        <trans-unit id="7fa9e4dd118db6c43acdd9765995f0465281818a" translate="yes" xml:space="preserve">
          <source>Enable Local Register Allocation. This is the default for SPARC since GCC 7 so</source>
          <target state="translated">启用本地寄存器分配。这是自GCC 7以来SPARC的默认值,所以</target>
        </trans-unit>
        <trans-unit id="89bbfd96b1406df4e9daca603ac86b980c364e5c" translate="yes" xml:space="preserve">
          <source>Enable RTL pass &lt;var&gt;pass&lt;/var&gt;. See</source>
          <target state="translated">启用RTL pass &lt;var&gt;pass&lt;/var&gt; 。看到</target>
        </trans-unit>
        <trans-unit id="f44412802c3209f5d9e4e5d01f1b31cdf41ef7c0" translate="yes" xml:space="preserve">
          <source>Enable Round Double Multiply Accumulate instructions. This is on by default for</source>
          <target state="translated">启用圆周双乘累加指令。默认情况下,这对于</target>
        </trans-unit>
        <trans-unit id="1332af3411aa268a3ef4a1b41bc0ae5d1edc2594" translate="yes" xml:space="preserve">
          <source>Enable Scalable Vector Extension instructions. This also enables Advanced SIMD and floating-point instructions.</source>
          <target state="translated">启用可扩展向量扩展指令。这也启用了高级SIMD和浮点指令。</target>
        </trans-unit>
        <trans-unit id="082f6e4a45595d5f7a3a2a560115400fb4ee2b89" translate="yes" xml:space="preserve">
          <source>Enable ThreadSanitizer, a fast data race detector. Memory access instructions are instrumented to detect data race bugs. See &lt;a href=&quot;https://github.com/google/sanitizers/wiki#threadsanitizer&quot;&gt;https://github.com/google/sanitizers/wiki#threadsanitizer&lt;/a&gt; for more details. The run-time behavior can be influenced using the &lt;code&gt;TSAN_OPTIONS&lt;/code&gt; environment variable; see &lt;a href=&quot;https://github.com/google/sanitizers/wiki/ThreadSanitizerFlags&quot;&gt;https://github.com/google/sanitizers/wiki/ThreadSanitizerFlags&lt;/a&gt; for a list of supported options. The option cannot be combined with</source>
          <target state="translated">启用ThreadSanitizer，一种快速的数据竞争检测器。内存访问指令用于检测数据争用错误。有关更多详细信息，请参见&lt;a href=&quot;https://github.com/google/sanitizers/wiki#threadsanitizer&quot;&gt;https://github.com/google/sanitizers/wiki#threadsanitizer&lt;/a&gt;。可以使用 &lt;code&gt;TSAN_OPTIONS&lt;/code&gt; 环境变量来影响运行时行为。有关受支持的选项的列表，请参见&lt;a href=&quot;https://github.com/google/sanitizers/wiki/ThreadSanitizerFlags&quot;&gt;https://github.com/google/sanitizers/wiki/ThreadSanitizerFlags&lt;/a&gt;。该选项不能与</target>
        </trans-unit>
        <trans-unit id="949a1a6c2112a203d7294b63f617d43e64b4229c" translate="yes" xml:space="preserve">
          <source>Enable UndefinedBehaviorSanitizer, a fast undefined behavior detector. Various computations are instrumented to detect undefined behavior at runtime. Current suboptions are:</source>
          <target state="translated">启用UndefinedBehaviorSanitizer,一个快速的未定义行为检测器。在运行时通过各种计算工具来检测未定义的行为。当前的子选项有:</target>
        </trans-unit>
        <trans-unit id="96f5c056cf8c5a806da05ed8b96789bc0b6d048b" translate="yes" xml:space="preserve">
          <source>Enable all estimate instructions.</source>
          <target state="translated">启用所有估算指令。</target>
        </trans-unit>
        <trans-unit id="df3c7c5cb30d8d0e87829e7d5c48c82259c25cb7" translate="yes" xml:space="preserve">
          <source>Enable all language-specific dumps.</source>
          <target state="translated">启用所有特定语言的转储。</target>
        </trans-unit>
        <trans-unit id="ae518ed7bc949ae822d65bcaeff9c7041fb826a6" translate="yes" xml:space="preserve">
          <source>Enable allocation of values to registers that are clobbered by function calls, by emitting extra instructions to save and restore the registers around such calls. Such allocation is done only when it seems to result in better code.</source>
          <target state="translated">通过发出额外的指令来保存和恢复这些调用周围的寄存器,从而实现对被函数调用占用的寄存器的值分配。只有当这种分配似乎能带来更好的代码时,才会进行这种分配。</target>
        </trans-unit>
        <trans-unit id="0a0fd86a97f36ba3d21ddbe6e9254e7a16fbfe18" translate="yes" xml:space="preserve">
          <source>Enable and control dumping of pass statistics in a separate file. The file name is generated by appending a suffix ending in &amp;lsquo;</source>
          <target state="translated">在单独的文件中启用和控制通过统计信息的转储。通过添加以'结尾的后缀来生成文件名</target>
        </trans-unit>
        <trans-unit id="f6804494e75f7aaede40247da0a4be9cdb7a84eb" translate="yes" xml:space="preserve">
          <source>Enable asan allocas/VLAs protection.</source>
          <target state="translated">启用asan allocas/VLAs保护。</target>
        </trans-unit>
        <trans-unit id="61fd83dce0b4c24f54b3d95d0aba14e424d6bcbf" translate="yes" xml:space="preserve">
          <source>Enable automatic template instantiation at link time. This option also implies</source>
          <target state="translated">在链接时启用自动模板实例化。这个选项也意味着</target>
        </trans-unit>
        <trans-unit id="803437b7c125524ce44c25382c66dec8a107376e" translate="yes" xml:space="preserve">
          <source>Enable barrel-shift instructions.</source>
          <target state="translated">启用换桶指令。</target>
        </trans-unit>
        <trans-unit id="dd1a569881fabce4df110c82ea43f4ea0973b717" translate="yes" xml:space="preserve">
          <source>Enable bbit peephole2.</source>
          <target state="translated">启用bbit窥视孔2。</target>
        </trans-unit>
        <trans-unit id="1e317e7bf07e0ef1d8933e0c682ab5ffc4c86dfe" translate="yes" xml:space="preserve">
          <source>Enable buffer overflow detection for global objects. This kind of protection is enabled by default if you are using</source>
          <target state="translated">启用全局对象的缓冲区溢出检测。如果您使用了</target>
        </trans-unit>
        <trans-unit id="0ff2936ea712569b3e61003e75e4a3a94ca881aa" translate="yes" xml:space="preserve">
          <source>Enable buffer overflow detection for memory reads. This kind of protection is enabled by default when using</source>
          <target state="translated">启用内存读取的缓冲区溢出检测。这种保护默认在使用</target>
        </trans-unit>
        <trans-unit id="c11c559ccc97fad4b1acec42a5bfc66eb0c4fd61" translate="yes" xml:space="preserve">
          <source>Enable buffer overflow detection for memory writes. This kind of protection is enabled by default when using</source>
          <target state="translated">启用内存写入的缓冲区溢出检测。这种保护默认在使用</target>
        </trans-unit>
        <trans-unit id="c2ab49f5ce7f3d41ded69401c310972e445af621" translate="yes" xml:space="preserve">
          <source>Enable buffer overflow detection for stack objects. This kind of protection is enabled by default when using</source>
          <target state="translated">启用堆栈对象的缓冲区溢出检测。这种保护默认在使用</target>
        </trans-unit>
        <trans-unit id="bcd2fc731b6ca5ce8904f8dd2548970ab5fbc93a" translate="yes" xml:space="preserve">
          <source>Enable cache bypass for volatile references.</source>
          <target state="translated">启用易失性引用的缓存旁路。</target>
        </trans-unit>
        <trans-unit id="dc4973bdf3e5300316096cd00a6ec0877e4070c6" translate="yes" xml:space="preserve">
          <source>Enable code density instructions for ARC EM. This option is on by default for ARC HS.</source>
          <target state="translated">启用ARC EM的代码密度指令。ARC HS的该选项默认为开启。</target>
        </trans-unit>
        <trans-unit id="6f26f87d795cdafd882a37f7cf6106b44c65db50" translate="yes" xml:space="preserve">
          <source>Enable code instrumentation of control-flow transfers to increase program security by checking that target addresses of control-flow transfer instructions (such as indirect function call, function return, indirect jump) are valid. This prevents diverting the flow of control to an unexpected target. This is intended to protect against such threats as Return-oriented Programming (ROP), and similarly call/jmp-oriented programming (COP/JOP).</source>
          <target state="translated">通过检查控制流转移指令(如间接函数调用、函数返回、间接跳转)的目标地址是否有效,启用控制流转移的代码仪表,以提高程序的安全性。这样可以防止将控制流转移到一个意想不到的目标。这样做的目的是为了防止诸如面向返回的编程(ROP),以及类似于面向调用/jmp的编程(COP/JOP)等威胁。</target>
        </trans-unit>
        <trans-unit id="b04ea9a65f69d1ed270cd68689d1e12352618b80" translate="yes" xml:space="preserve">
          <source>Enable compact &lt;code&gt;casesi&lt;/code&gt; pattern. This is the default for</source>
          <target state="translated">启用紧凑的 &lt;code&gt;casesi&lt;/code&gt; 模式。这是默认设置</target>
        </trans-unit>
        <trans-unit id="0c57839724a2712f31a1af12f90ff1f615581733" translate="yes" xml:space="preserve">
          <source>Enable constructor/destructor feature.</source>
          <target state="translated">启用构造函数/析构函数功能。</target>
        </trans-unit>
        <trans-unit id="975ccca01950f97ce533ac489aa7f20116354de0" translate="yes" xml:space="preserve">
          <source>Enable coprocessor instructions; the default is off.</source>
          <target state="translated">启用协处理器指令,默认为关闭。</target>
        </trans-unit>
        <trans-unit id="133e4f830a510ad1f945a9a4b1965c6cdd0bf2e0" translate="yes" xml:space="preserve">
          <source>Enable coverage-guided fuzzing code instrumentation. Inserts a call to &lt;code&gt;__sanitizer_cov_trace_pc&lt;/code&gt; into every basic block.</source>
          <target state="translated">启用覆盖率指导的模糊代码检测。 &lt;code&gt;__sanitizer_cov_trace_pc&lt;/code&gt; 的调用插入到每个基本块中。</target>
        </trans-unit>
        <trans-unit id="787d37d09881b29ce95c34e07e7021e04de78815" translate="yes" xml:space="preserve">
          <source>Enable dataflow guided fuzzing code instrumentation. Inserts a call to &lt;code&gt;__sanitizer_cov_trace_cmp1&lt;/code&gt;, &lt;code&gt;__sanitizer_cov_trace_cmp2&lt;/code&gt;, &lt;code&gt;__sanitizer_cov_trace_cmp4&lt;/code&gt; or &lt;code&gt;__sanitizer_cov_trace_cmp8&lt;/code&gt; for integral comparison with both operands variable or &lt;code&gt;__sanitizer_cov_trace_const_cmp1&lt;/code&gt;, &lt;code&gt;__sanitizer_cov_trace_const_cmp2&lt;/code&gt;, &lt;code&gt;__sanitizer_cov_trace_const_cmp4&lt;/code&gt; or &lt;code&gt;__sanitizer_cov_trace_const_cmp8&lt;/code&gt; for integral comparison with one operand constant, &lt;code&gt;__sanitizer_cov_trace_cmpf&lt;/code&gt; or &lt;code&gt;__sanitizer_cov_trace_cmpd&lt;/code&gt; for float or double comparisons and &lt;code&gt;__sanitizer_cov_trace_switch&lt;/code&gt; for switch statements.</source>
          <target state="translated">启用数据流引导的模糊代码检测。插入到一个呼叫 &lt;code&gt;__sanitizer_cov_trace_cmp1&lt;/code&gt; ， &lt;code&gt;__sanitizer_cov_trace_cmp2&lt;/code&gt; ， &lt;code&gt;__sanitizer_cov_trace_cmp4&lt;/code&gt; 或 &lt;code&gt;__sanitizer_cov_trace_cmp8&lt;/code&gt; 用于与这两个操作数的变量或积分比较 &lt;code&gt;__sanitizer_cov_trace_const_cmp1&lt;/code&gt; ， &lt;code&gt;__sanitizer_cov_trace_const_cmp2&lt;/code&gt; ， &lt;code&gt;__sanitizer_cov_trace_const_cmp4&lt;/code&gt; 或 &lt;code&gt;__sanitizer_cov_trace_const_cmp8&lt;/code&gt; 用于与一个操作数常数，积分比较 &lt;code&gt;__sanitizer_cov_trace_cmpf&lt;/code&gt; 或 &lt;code&gt;__sanitizer_cov_trace_cmpd&lt;/code&gt; 浮法或双比较和 &lt;code&gt;__sanitizer_cov_trace_switch&lt;/code&gt; 用于switch语句。</target>
        </trans-unit>
        <trans-unit id="1af777f40a3150cb8ba378da9ca8aedaaf114176" translate="yes" xml:space="preserve">
          <source>Enable deduction of a template type parameter as &lt;code&gt;std::initializer_list&lt;/code&gt; from a brace-enclosed initializer list, i.e.</source>
          <target state="translated">启用从括号括起来的初始化程序列表中将模板类型参数推导为 &lt;code&gt;std::initializer_list&lt;/code&gt; ，即</target>
        </trans-unit>
        <trans-unit id="699beaa366dd56ec35a2702d45f2103e1f67c4dc" translate="yes" xml:space="preserve">
          <source>Enable detection for built-in functions. This kind of protection is enabled by default when using</source>
          <target state="translated">启用内置功能的检测。当您使用</target>
        </trans-unit>
        <trans-unit id="d53fecd502038ea015d9795c95247289bc1d17ab" translate="yes" xml:space="preserve">
          <source>Enable detection of use-after-return. This kind of protection is enabled by default when using the</source>
          <target state="translated">启用检测返回后的使用。这种保护在使用</target>
        </trans-unit>
        <trans-unit id="22325b2d023fcd4619a9818a760c689af219e959" translate="yes" xml:space="preserve">
          <source>Enable divide and modulus instructions.</source>
          <target state="translated">启用除法和模数指令。</target>
        </trans-unit>
        <trans-unit id="6860f8ad3c912d9de1bc957db83ae37ff4acd2f1" translate="yes" xml:space="preserve">
          <source>Enable double load/store operations for ARC HS cores.</source>
          <target state="translated">启用ARC HS内核的双重加载/存储操作。</target>
        </trans-unit>
        <trans-unit id="f30747b51f35d511a8324038d0ec742af8852f12" translate="yes" xml:space="preserve">
          <source>Enable dumping various statistics about the pass (not honored by every dump option).</source>
          <target state="translated">启用转储关于通证的各种统计信息(并非每个转储选项都能兑现)。</target>
        </trans-unit>
        <trans-unit id="e61159e5abc9e858d3e7dc68248bef77e7e66569" translate="yes" xml:space="preserve">
          <source>Enable dumps from all OMP (Offloading and Multi Processing) optimizations.</source>
          <target state="translated">启用所有OMP(卸载和多处理)优化的转储。</target>
        </trans-unit>
        <trans-unit id="126e933efdf810fc684f2a27ed78c7f4a97f9db5" translate="yes" xml:space="preserve">
          <source>Enable dumps from all inlining optimizations.</source>
          <target state="translated">启用所有内联优化的转储。</target>
        </trans-unit>
        <trans-unit id="d0c94685fdabc0e86d42873897a8642d64c915a0" translate="yes" xml:space="preserve">
          <source>Enable dumps from all interprocedural optimizations.</source>
          <target state="translated">启用所有程序间优化的转储。</target>
        </trans-unit>
        <trans-unit id="f4a495e6ab007e96555960123af4b2e049e343cb" translate="yes" xml:space="preserve">
          <source>Enable dumps from all loop optimizations.</source>
          <target state="translated">启用所有循环优化的转储。</target>
        </trans-unit>
        <trans-unit id="da404a0e7964dc17445f8eab1557032d44193e2a" translate="yes" xml:space="preserve">
          <source>Enable dumps from all optimizations. This is a superset of the optimization groups listed above.</source>
          <target state="translated">启用所有优化的转储。这是上述优化组的超集。</target>
        </trans-unit>
        <trans-unit id="82fd093708bd37548045d3e8dc300297a204bb93" translate="yes" xml:space="preserve">
          <source>Enable dumps from all vectorization optimizations.</source>
          <target state="translated">启用所有矢量化优化的转储。</target>
        </trans-unit>
        <trans-unit id="1ca26bbd13d508b47dfc0ff9aedfd700309873f0" translate="yes" xml:space="preserve">
          <source>Enable emission of special debug stores within HSA kernels which are then read and reported by libgomp plugin. Generation of these stores is disabled by default, use</source>
          <target state="translated">在HSA内核中启用特殊的调试存储,然后由libgomp插件读取和报告。默认情况下,这些存储空间的生成是被禁用的,请使用</target>
        </trans-unit>
        <trans-unit id="92b0248c8870fe4857fc02d723bd02f0d5d911ee" translate="yes" xml:space="preserve">
          <source>Enable exception handling. Generates extra code needed to propagate exceptions. For some targets, this implies GCC generates frame unwind information for all functions, which can produce significant data size overhead, although it does not affect execution. If you do not specify this option, GCC enables it by default for languages like C++ that normally require exception handling, and disables it for languages like C that do not normally require it. However, you may need to enable this option when compiling C code that needs to interoperate properly with exception handlers written in C++. You may also wish to disable this option if you are compiling older C++ programs that don&amp;rsquo;t use exception handling.</source>
          <target state="translated">启用异常处理。生成传播异常所需的额外代码。对于某些目标，这意味着GCC会为所有功能生成帧展开信息，尽管这不会影响执行，但可能会产生大量的数据大小开销。如果未指定此选项，则默认情况下，GCC对通常要求例外处理的C ++语言启用它，而对于通常不要求其处理的C语言，则禁用它。但是，在编译需要与用C ++编写的异常处理程序正确互操作的C代码时，可能需要启用此选项。如果您正在编译不使用异常处理的较旧的C ++程序，则还可能希望禁用此选项。</target>
        </trans-unit>
        <trans-unit id="291b92d09ee9fff716f8b0be8063487213868bdd" translate="yes" xml:space="preserve">
          <source>Enable floating-point instructions. This is on by default for all possible values for options</source>
          <target state="translated">启用浮点指令。对于所有选项的可能值,默认为 &quot;开启&quot;。</target>
        </trans-unit>
        <trans-unit id="39904b8795d477fdb077dab2b449e06a2b1bd74a" translate="yes" xml:space="preserve">
          <source>Enable garbage collection (GC) in Objective-C and Objective-C++ programs. This option is only available with the NeXT runtime; the GNU runtime has a different garbage collection implementation that does not require special compiler flags.</source>
          <target state="translated">在Objective-C和Objective-C++程序中启用垃圾收集(GC)。这个选项只在NeXT运行时可用;GNU运行时有不同的垃圾收集实现,不需要特殊的编译器标志。</target>
        </trans-unit>
        <trans-unit id="eb9fbffb72277aaa3548891dbb1b3b1153391a9e" translate="yes" xml:space="preserve">
          <source>Enable generation of ARC SIMD instructions via target-specific builtins. Only valid for</source>
          <target state="translated">通过目标特定的内建程序来生成ARC SIMD指令。仅对以下情况有效</target>
        </trans-unit>
        <trans-unit id="64de54a950fd518ed74414f068843cdf15d9e810" translate="yes" xml:space="preserve">
          <source>Enable generation of linemarkers in the preprocessor output that let the compiler know the current working directory at the time of preprocessing. When this option is enabled, the preprocessor emits, after the initial linemarker, a second linemarker with the current working directory followed by two slashes. GCC uses this directory, when it&amp;rsquo;s present in the preprocessed input, as the directory emitted as the current working directory in some debugging information formats. This option is implicitly enabled if debugging information is enabled, but this can be inhibited with the negated form</source>
          <target state="translated">在预处理器输出中启用行标记的生成，使编译器在预处理时知道当前的工作目录。启用此选项后，预处理器将在初始行标记之后发出第二个行标记，其中第二行标记带有当前工作目录，后跟两个斜杠。当该目录存在于预处理输入中时，GCC使用该目录作为某些调试信息格式作为当前工作目录发出的目录。如果启用了调试信息，则隐式启用此选项，但是可以使用反数形式将其禁止</target>
        </trans-unit>
        <trans-unit id="4f6c2330300990f23059abacc5ecdfe5f1dc0281" translate="yes" xml:space="preserve">
          <source>Enable generation of unaligned load and store instructions.</source>
          <target state="translated">启用生成未对齐的加载和存储指令。</target>
        </trans-unit>
        <trans-unit id="d26f3d711c1a65ce5ae7ed795204b286f03213ae" translate="yes" xml:space="preserve">
          <source>Enable global interrupt.</source>
          <target state="translated">启用全局中断。</target>
        </trans-unit>
        <trans-unit id="2f452efb25c68aa75fbb01603256e25885a6060f" translate="yes" xml:space="preserve">
          <source>Enable handling of OpenACC directives &lt;code&gt;#pragma acc&lt;/code&gt; in C/C++ and &lt;code&gt;!$acc&lt;/code&gt; in Fortran. When</source>
          <target state="translated">在C / C ++中启用OpenACC指令 &lt;code&gt;#pragma acc&lt;/code&gt; 的处理，在Fortran中启用 &lt;code&gt;!$acc&lt;/code&gt; 的处理。什么时候</target>
        </trans-unit>
        <trans-unit id="2ca92300312c8fc1987b891433bf16fbf5350717" translate="yes" xml:space="preserve">
          <source>Enable handling of OpenMP directives &lt;code&gt;#pragma omp&lt;/code&gt; in C/C++ and &lt;code&gt;!$omp&lt;/code&gt; in Fortran. When</source>
          <target state="translated">在C / C ++中启用OpenMP指令 &lt;code&gt;#pragma omp&lt;/code&gt; 的处理，在Fortran中启用 &lt;code&gt;!$omp&lt;/code&gt; 的处理。什么时候</target>
        </trans-unit>
        <trans-unit id="f764c2e81a54602d1c0862a3fd8d88c71c27e5ef" translate="yes" xml:space="preserve">
          <source>Enable handling of OpenMP&amp;rsquo;s SIMD directives with &lt;code&gt;#pragma omp&lt;/code&gt; in C/C++ and &lt;code&gt;!$omp&lt;/code&gt; in Fortran. Other OpenMP directives are ignored.</source>
          <target state="translated">使用C / C ++中的 &lt;code&gt;#pragma omp&lt;/code&gt; 和Fortran中的 &lt;code&gt;!$omp&lt;/code&gt; 启用对OpenMP SIMD指令的处理。其他OpenMP指令将被忽略。</target>
        </trans-unit>
        <trans-unit id="325afe18f0a625fafbd824b05e823388581382ad" translate="yes" xml:space="preserve">
          <source>Enable inlining of PLT entries in function calls to functions that are not known to bind locally. It has no effect without</source>
          <target state="translated">启用在函数调用中内嵌PLT条目,这些函数不知道是本地绑定的。如果不使用</target>
        </trans-unit>
        <trans-unit id="26c34a078cd9b46fb0bd484cd235d46f5c53f46b" translate="yes" xml:space="preserve">
          <source>Enable internal consistency checking. The default depends on the compiler configuration.</source>
          <target state="translated">启用内部一致性检查。默认值取决于编译器的配置。</target>
        </trans-unit>
        <trans-unit id="b40ab07f35e9ecebed6c91979cb9c80321b2c600" translate="yes" xml:space="preserve">
          <source>Enable interrupt stack instructions; the default is off.</source>
          <target state="translated">启用中断栈指令,默认为关闭。</target>
        </trans-unit>
        <trans-unit id="fd58b676d0e4ba40cac9f6295490ba16f891fad5" translate="yes" xml:space="preserve">
          <source>Enable kernel development mode. The</source>
          <target state="translated">启用内核开发模式。启用内核开发模式。</target>
        </trans-unit>
        <trans-unit id="6942946c621ac80c436737b7a31ee339272c871d" translate="yes" xml:space="preserve">
          <source>Enable lazy binding of function calls. This option is equivalent to</source>
          <target state="translated">启用函数调用的懒惰绑定。这个选项相当于</target>
        </trans-unit>
        <trans-unit id="c3e68f8f7d9888cb3d2e2d66e5738f0a5b7bffcf" translate="yes" xml:space="preserve">
          <source>Enable linker relaxation. Linker relaxation is a process whereby the linker attempts to reduce the size of a program by finding shorter versions of various instructions. Disabled by default.</source>
          <target state="translated">启用链接器松弛。链接器松弛是一个过程,链接器试图通过寻找各种指令的较短版本来减少程序的大小。默认情况下已禁用。</target>
        </trans-unit>
        <trans-unit id="0765f61b18fd9b0cd981b0d3115e02320dabdb7a" translate="yes" xml:space="preserve">
          <source>Enable loop epilogue vectorization using smaller vector size.</source>
          <target state="translated">使用较小的向量大小启用循环尾声向量化。</target>
        </trans-unit>
        <trans-unit id="04769dddbdca1dd3af29e66b89d9df24ccfdaae0" translate="yes" xml:space="preserve">
          <source>Enable more detailed dumps (not honored by every dump option). Also include information from the optimization passes.</source>
          <target state="translated">启用更详细的转储(不是每个转储选项都会遵守)。还包括来自优化通道的信息。</target>
        </trans-unit>
        <trans-unit id="9f3bf571af4fb133a9ed845eaa94347bdecede5e" translate="yes" xml:space="preserve">
          <source>Enable multiply instructions.</source>
          <target state="translated">启用乘法指令。</target>
        </trans-unit>
        <trans-unit id="6bdc85b650029e698104b9394508a12676ccb6ec" translate="yes" xml:space="preserve">
          <source>Enable multiprocessor instructions; the default is off.</source>
          <target state="translated">启用多处理器指令,默认为关闭。</target>
        </trans-unit>
        <trans-unit id="dae98acaa0a30e3960a49dff4e2a8d6c6a98eb29" translate="yes" xml:space="preserve">
          <source>Enable nested conditional execution optimizations (default).</source>
          <target state="translated">启用嵌套条件执行优化(默认)。</target>
        </trans-unit>
        <trans-unit id="0523e9bf64ec1c9137b9f17ae48ec467d581e674" translate="yes" xml:space="preserve">
          <source>Enable optimization of &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; and &lt;code&gt;||&lt;/code&gt; in conditional execution (default).</source>
          <target state="translated">启用 &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; 和 &lt;code&gt;||&lt;/code&gt; 的优化 在条件执行中（默认）。</target>
        </trans-unit>
        <trans-unit id="43cad454d19cf94092ebd0b65a6a9f9c7c63ffa9" translate="yes" xml:space="preserve">
          <source>Enable options usually used for instrumenting application to produce profile useful for later recompilation with profile feedback based optimization. You must use</source>
          <target state="translated">启用通常用于工具应用程序的选项,以产生对以后重新编译有用的基于配置文件反馈的优化的配置文件。您必须使用</target>
        </trans-unit>
        <trans-unit id="9425982687d5465084a29222f1e8d83738debfbc" translate="yes" xml:space="preserve">
          <source>Enable or disable PC-relative literal loads. With this option literal pools are accessed using a single instruction and emitted after each function. This limits the maximum size of functions to 1MB. This is enabled by default for</source>
          <target state="translated">启用或禁用PC相关的文字负载。使用该选项,可以使用单条指令访问文字池,并在每个函数后发出。这将函数的最大大小限制为1MB。默认情况下,该选项被启用,用于</target>
        </trans-unit>
        <trans-unit id="f213f1158c65a76a7da3e44d0dfb546afeb1c37d" translate="yes" xml:space="preserve">
          <source>Enable or disable emitting &lt;code&gt;mul&lt;/code&gt;, &lt;code&gt;mulx&lt;/code&gt; and &lt;code&gt;div&lt;/code&gt; family of instructions by the compiler. The default is to emit &lt;code&gt;mul&lt;/code&gt; and not emit &lt;code&gt;div&lt;/code&gt; and &lt;code&gt;mulx&lt;/code&gt;.</source>
          <target state="translated">由编译器启用或禁用发出 &lt;code&gt;mul&lt;/code&gt; ， &lt;code&gt;mulx&lt;/code&gt; 和 &lt;code&gt;div&lt;/code&gt; 系列指令。默认设置是发出 &lt;code&gt;mul&lt;/code&gt; 而不发出 &lt;code&gt;div&lt;/code&gt; 和 &lt;code&gt;mulx&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a0c735f45199333d31330ebeb1c39ca77bf91fab" translate="yes" xml:space="preserve">
          <source>Enable or disable generation of Nios II R2 BMX (bit manipulation) and CDX (code density) instructions. Enabling these instructions also requires</source>
          <target state="translated">启用或禁用Nios II R2 BMX(位操作)和CDX(代码密度)指令的生成。启用这些指令还需要</target>
        </trans-unit>
        <trans-unit id="e82224b52a26ba48a5b113f09b7fcf8cc858a9c2" translate="yes" xml:space="preserve">
          <source>Enable or disable generation of additional code to track speculative execution through conditional branches. The tracking state can then be used by the compiler when expanding calls to &lt;code&gt;__builtin_speculation_safe_copy&lt;/code&gt; to permit a more efficient code sequence to be generated.</source>
          <target state="translated">启用或禁用附加代码的生成，以通过条件分支跟踪推测性执行。然后，在扩展对 &lt;code&gt;__builtin_speculation_safe_copy&lt;/code&gt; 的调用以允许生成更有效的代码序列时，编译器可以使用跟踪状态。</target>
        </trans-unit>
        <trans-unit id="8588fb4dd2a8d4f96274711c0f8a3dcffa809a3b" translate="yes" xml:space="preserve">
          <source>Enable or disable the division approximation. This option only has an effect if</source>
          <target state="translated">启用或禁用除法近似。只有在以下情况下,该选项才会生效</target>
        </trans-unit>
        <trans-unit id="da4836dd8fd423982dc5d807088aa304a1a7fb40" translate="yes" xml:space="preserve">
          <source>Enable or disable the reciprocal square root approximation. This option only has an effect if</source>
          <target state="translated">启用或禁用往复平方根近似。此选项只有在以下情况下才会生效</target>
        </trans-unit>
        <trans-unit id="6cd2e01bcd6daa77f123d3562e525b53f2208b99" translate="yes" xml:space="preserve">
          <source>Enable or disable the square root approximation. This option only has an effect if</source>
          <target state="translated">启用或禁用平方根近似。此选项只有在以下情况下才会生效</target>
        </trans-unit>
        <trans-unit id="f6d5d7b63171cb59117cb5da0b6d0ce6a7318345" translate="yes" xml:space="preserve">
          <source>Enable or disable the workaround for the ARM Cortex-A53 erratum number 835769. This involves inserting a NOP instruction between memory instructions and 64-bit integer multiply-accumulate instructions.</source>
          <target state="translated">启用或禁用ARM Cortex-A53错误编号835769的解决方法。这涉及在内存指令和 64 位整数乘法累加指令之间插入 NOP 指令。</target>
        </trans-unit>
        <trans-unit id="1b8e841a5a6d9c6fdc72f5d2c3b9462219761996" translate="yes" xml:space="preserve">
          <source>Enable or disable the workaround for the ARM Cortex-A53 erratum number 843419. This erratum workaround is made at link time and this will only pass the corresponding flag to the linker.</source>
          <target state="translated">启用或禁用 ARM Cortex-A53 勘误号 843419 的变通方法。该勘误工作法是在链接时进行的,这只会将相应的标志传递给链接器。</target>
        </trans-unit>
        <trans-unit id="e8d2c7af76155c379ab5d5ec1df26431744e4771" translate="yes" xml:space="preserve">
          <source>Enable or disable use of &lt;code&gt;CONST16&lt;/code&gt; instructions for loading constant values. The &lt;code&gt;CONST16&lt;/code&gt; instruction is currently not a standard option from Tensilica. When enabled, &lt;code&gt;CONST16&lt;/code&gt; instructions are always used in place of the standard &lt;code&gt;L32R&lt;/code&gt; instructions. The use of &lt;code&gt;CONST16&lt;/code&gt; is enabled by default only if the &lt;code&gt;L32R&lt;/code&gt; instruction is not available.</source>
          <target state="translated">启用或禁用使用 &lt;code&gt;CONST16&lt;/code&gt; 指令加载常量值。目前，Tensilica尚未将 &lt;code&gt;CONST16&lt;/code&gt; 指令作为标准选项。启用后，将始终使用 &lt;code&gt;CONST16&lt;/code&gt; 指令代替标准 &lt;code&gt;L32R&lt;/code&gt; 指令。采用 &lt;code&gt;CONST16&lt;/code&gt; 默认启用仅在 &lt;code&gt;L32R&lt;/code&gt; 指令不可用。</target>
        </trans-unit>
        <trans-unit id="87ea222da3a42af40a5b89fab414b5a2466d4691" translate="yes" xml:space="preserve">
          <source>Enable or disable use of Branch Likely instructions, regardless of the default for the selected architecture. By default, Branch Likely instructions may be generated if they are supported by the selected architecture. An exception is for the MIPS32 and MIPS64 architectures and processors that implement those architectures; for those, Branch Likely instructions are not be generated by default because the MIPS32 and MIPS64 architectures specifically deprecate their use.</source>
          <target state="translated">启用或禁用Branch Likely指令,无论所选架构的默认值如何。默认情况下,如果所选架构支持Branch Likely指令,则可以生成这些指令。MIPS32和MIPS64架构以及实现这些架构的处理器是一个例外;对于这些架构,默认情况下不会生成Branch Likely指令,因为MIPS32和MIPS64架构特别禁止使用这些指令。</target>
        </trans-unit>
        <trans-unit id="6f7c7366f13d27cab3029da7a7c328e36fbdbb28" translate="yes" xml:space="preserve">
          <source>Enable or disable use of fused multiply/add and multiply/subtract instructions in the floating-point option. This has no effect if the floating-point option is not also enabled. Disabling fused multiply/add and multiply/subtract instructions forces the compiler to use separate instructions for the multiply and add/subtract operations. This may be desirable in some cases where strict IEEE 754-compliant results are required: the fused multiply add/subtract instructions do not round the intermediate result, thereby producing results with &lt;em&gt;more&lt;/em&gt; bits of precision than specified by the IEEE standard. Disabling fused multiply add/subtract instructions also ensures that the program output is not sensitive to the compiler&amp;rsquo;s ability to combine multiply and add/subtract operations.</source>
          <target state="translated">在浮点选项中启用或禁用融合的乘法/加法和乘法/减法指令的使用。如果未同时启用浮点选项，则无效。禁用融合的乘法/加法和乘法/减法指令会强制编译器对乘法和加法/减法运算使用单独的指令。这可能是在某些情况下是必需的严格符合IEEE 754结果可取的：该融合乘法加法/减法指令不圆的中间结果，以由此产生的结果&lt;em&gt;更&lt;/em&gt;比IEEE标准所规定的精度的位。禁用融合的乘法加/减指令还可以确保程序输出对编译器组合乘法与加/减运算的能力不敏感。</target>
        </trans-unit>
        <trans-unit id="f2d29f4186409cdd0269837c4398f5ca04568394" translate="yes" xml:space="preserve">
          <source>Enable other detailed optimization information (only available in certain passes).</source>
          <target state="translated">启用其他详细的优化信息(仅在某些通道中可用)。</target>
        </trans-unit>
        <trans-unit id="338cf5f95ce763c97fbfe82953390f719fbef967" translate="yes" xml:space="preserve">
          <source>Enable parsing of function definitions marked with &lt;code&gt;__GIMPLE&lt;/code&gt;. This is an experimental feature that allows unit testing of GIMPLE passes.</source>
          <target state="translated">启用对标记为 &lt;code&gt;__GIMPLE&lt;/code&gt; 的函数定义的解析。这是一项实验功能，可以对GIMPLE通过进行单元测试。</target>
        </trans-unit>
        <trans-unit id="f3fcc68975389b930adf047407384e4de7afa86d" translate="yes" xml:space="preserve">
          <source>Enable pre-reload use of the &lt;code&gt;cbranchsi&lt;/code&gt; pattern.</source>
          <target state="translated">启用 &lt;code&gt;cbranchsi&lt;/code&gt; 模式的预加载使用。</target>
        </trans-unit>
        <trans-unit id="7aca1894ee9ae073c5e50327164b18c35adaf0e4" translate="yes" xml:space="preserve">
          <source>Enable profile feedback-directed optimizations, and the following optimizations, many of which are generally profitable only with profile feedback available:</source>
          <target state="translated">启用配置文件反馈导向的优化,以及以下优化,很多优化一般只有在有配置文件反馈的情况下才能盈利。</target>
        </trans-unit>
        <trans-unit id="9b22143dddf716e38b0694ad2ca7a60178731d02" translate="yes" xml:space="preserve">
          <source>Enable register pressure sensitive insn scheduling before register allocation. This only makes sense when scheduling before register allocation is enabled, i.e. with</source>
          <target state="translated">在寄存器分配前启用寄存器压力敏感的insn调度。只有在启用了寄存器分配前的调度时,这才是有意义的,即在使用</target>
        </trans-unit>
        <trans-unit id="c0432e33b5c323c92ba751b7a0171493013f8ec2" translate="yes" xml:space="preserve">
          <source>Enable sampling-based feedback-directed optimizations, and the following optimizations, many of which are generally profitable only with profile feedback available:</source>
          <target state="translated">启用基于采样的反馈导向优化,以及以下优化,其中很多优化一般只有在有剖面反馈的情况下才能盈利。</target>
        </trans-unit>
        <trans-unit id="9201f89c6bef5151370e84b69891107c6c6b6ade" translate="yes" xml:space="preserve">
          <source>Enable sanitization of local variables to detect use-after-scope bugs. The option sets</source>
          <target state="translated">启用局部变量的净化,以检测使用范围后的错误。该选项设置了</target>
        </trans-unit>
        <trans-unit id="37f6c409f5734729b3dae114f8c39805c8586c4f" translate="yes" xml:space="preserve">
          <source>Enable showing basic block boundaries (disabled in raw dumps).</source>
          <target state="translated">启用显示基本块边界(在原始转储中禁用)。</target>
        </trans-unit>
        <trans-unit id="92f2f939a0618b052e264a0ddefa5df5b7f5e756" translate="yes" xml:space="preserve">
          <source>Enable showing line numbers for statements.</source>
          <target state="translated">启用显示报表的行号。</target>
        </trans-unit>
        <trans-unit id="fd380e6ae8aa5c4cc3cef79ab2ea9026b97f5fbd" translate="yes" xml:space="preserve">
          <source>Enable showing missed optimization information (only available in certain passes).</source>
          <target state="translated">启用显示遗漏的优化信息(仅在某些通道中可用)。</target>
        </trans-unit>
        <trans-unit id="0d329eb30c66df2a8bec3e0f68514d20ab1b9f92" translate="yes" xml:space="preserve">
          <source>Enable showing optimization information (only available in certain passes).</source>
          <target state="translated">启用显示优化信息(仅在某些通道中可用)。</target>
        </trans-unit>
        <trans-unit id="f10fcf4d31c6a2b2451c140a8a88da810228a75d" translate="yes" xml:space="preserve">
          <source>Enable showing scalar evolution analysis details.</source>
          <target state="translated">启用显示标量演变分析细节。</target>
        </trans-unit>
        <trans-unit id="1fa4da5aa5a1df45f7fc17506d98a1fa44e7ec97" translate="yes" xml:space="preserve">
          <source>Enable showing the EH region number holding each statement.</source>
          <target state="translated">启用显示持有每个报表的EH区域号。</target>
        </trans-unit>
        <trans-unit id="c8bfc39b577282d7a982b0609ca5e212d2e36522" translate="yes" xml:space="preserve">
          <source>Enable showing the tree dump for each statement.</source>
          <target state="translated">启用显示每个语句的树形转储。</target>
        </trans-unit>
        <trans-unit id="c1965c688248d83e371ce542160789f937fce791" translate="yes" xml:space="preserve">
          <source>Enable showing the unique ID (&lt;code&gt;DECL_UID&lt;/code&gt;) for each variable.</source>
          <target state="translated">启用显示每个变量的唯一ID（ &lt;code&gt;DECL_UID&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="2c8e86f5a7b56d45f646fe90ecd4602077ea1bdc" translate="yes" xml:space="preserve">
          <source>Enable showing virtual operands for every statement.</source>
          <target state="translated">启用显示每个语句的虚拟操作数。</target>
        </trans-unit>
        <trans-unit id="7287e0e84335a843622d1b816ceb09d5c05aa749" translate="yes" xml:space="preserve">
          <source>Enable sign extend instructions.</source>
          <target state="translated">启用标志扩展指令。</target>
        </trans-unit>
        <trans-unit id="2106aa3d9fb87ebeededad40a76e40f9c935fadd" translate="yes" xml:space="preserve">
          <source>Enable software pipelining of innermost loops during selective scheduling. This option has no effect unless one of</source>
          <target state="translated">在选择性调度期间,启用最内部循环的软件流水线。这个选项没有效果,除非有以下情况之一</target>
        </trans-unit>
        <trans-unit id="523a4757398235b8bbb90229026fc9eed157dbee" translate="yes" xml:space="preserve">
          <source>Enable special code to work around file systems which only permit very short file names, such as MS-DOS.</source>
          <target state="translated">启用特殊代码,以绕过只允许非常短的文件名的文件系统,如MS-DOS。</target>
        </trans-unit>
        <trans-unit id="3536f2d6d38314050bafe0d10aa71b6595a43eae" translate="yes" xml:space="preserve">
          <source>Enable streaming of mangled types names of C++ types and their unification at link time. This increases size of LTO object files, but enables diagnostics about One Definition Rule violations.</source>
          <target state="translated">启用C++类型的杂乱类型名的流式传输,并在链接时对其进行统一。这增加了LTO对象文件的大小,但可以对违反One Definition Rule的行为进行诊断。</target>
        </trans-unit>
        <trans-unit id="07a4edd982a3edcc355177edde03a13c0e84c57f" translate="yes" xml:space="preserve">
          <source>Enable support for &lt;code&gt;char8_t&lt;/code&gt; as adopted for C++2a. This includes the addition of a new &lt;code&gt;char8_t&lt;/code&gt; fundamental type, changes to the types of UTF-8 string and character literals, new signatures for user-defined literals, associated standard library updates, and new &lt;code&gt;__cpp_char8_t&lt;/code&gt; and &lt;code&gt;__cpp_lib_char8_t&lt;/code&gt; feature test macros.</source>
          <target state="translated">启用对C ++ 2a所采用的 &lt;code&gt;char8_t&lt;/code&gt; 的支持。这包括添加新的 &lt;code&gt;char8_t&lt;/code&gt; 基本类型，更改UTF-8字符串和字符文字的类型，用户定义文字的新签名，关联的标准库更新以及新的 &lt;code&gt;__cpp_char8_t&lt;/code&gt; 和 &lt;code&gt;__cpp_lib_char8_t&lt;/code&gt; 功能测试宏。</target>
        </trans-unit>
        <trans-unit id="86deb01ddbea29be60b5e5fa22319efa9cd9ea02" translate="yes" xml:space="preserve">
          <source>Enable support for C++17 &lt;code&gt;new&lt;/code&gt; of types that require more alignment than &lt;code&gt;void* ::operator new(std::size_t)&lt;/code&gt; provides. A numeric argument such as &lt;code&gt;-faligned-new=32&lt;/code&gt; can be used to specify how much alignment (in bytes) is provided by that function, but few users will need to override the default of &lt;code&gt;alignof(std::max_align_t)&lt;/code&gt;.</source>
          <target state="translated">启用对C ++ 17 &lt;code&gt;new&lt;/code&gt; 类型的支持，这些类型需要比 &lt;code&gt;void* ::operator new(std::size_t)&lt;/code&gt; 提供的对齐更多的类型。可以使用 &lt;code&gt;-faligned-new=32&lt;/code&gt; 之类的数字参数来指定该函数提供的对齐方式（以字节为单位），但是很少有用户需要覆盖 &lt;code&gt;alignof(std::max_align_t)&lt;/code&gt; 的默认值。</target>
        </trans-unit>
        <trans-unit id="e96dd7f9b95634f8def4cef0c03097523e0ad470" translate="yes" xml:space="preserve">
          <source>Enable support for the C++ Extensions for Concepts Technical Specification, ISO 19217 (2015), which allows code like</source>
          <target state="translated">启用对C++概念扩展技术规范,ISO 19217(2015)的支持,它允许像这样的代码</target>
        </trans-unit>
        <trans-unit id="f069479e84a1d7c81e6433a171bacdd46bd05f77" translate="yes" xml:space="preserve">
          <source>Enable syntactic support for structured exception handling in Objective-C, similar to what is offered by C++. This option is required to use the Objective-C keywords &lt;code&gt;@try&lt;/code&gt;, &lt;code&gt;@throw&lt;/code&gt;, &lt;code&gt;@catch&lt;/code&gt;, &lt;code&gt;@finally&lt;/code&gt; and &lt;code&gt;@synchronized&lt;/code&gt;. This option is available with both the GNU runtime and the NeXT runtime (but not available in conjunction with the NeXT runtime on Mac OS X 10.2 and earlier).</source>
          <target state="translated">与C ++相似，在Objective-C中为结构化异常处理启用语法支持。此选项需要使用Objective-C关键字 &lt;code&gt;@try&lt;/code&gt; ， &lt;code&gt;@throw&lt;/code&gt; ， &lt;code&gt;@catch&lt;/code&gt; ， &lt;code&gt;@finally&lt;/code&gt; 和 &lt;code&gt;@synchronized&lt;/code&gt; 。 GNU运行时和NeXT运行时都可以使用此选项（但不能在Mac OS X 10.2和更早版本上与NeXT运行时一起使用）。</target>
        </trans-unit>
        <trans-unit id="2d795a0556dc7d4b23ca50c7c054a8e91a0bb9da" translate="yes" xml:space="preserve">
          <source>Enable the Armv8-a Execution and Data Prediction Restriction instructions. This option is only to enable the extension at the assembler level and does not affect code generation. This option is enabled by default for</source>
          <target state="translated">启用Armv8-a执行和数据预测限制指令。这个选项只是为了在汇编器级别启用扩展,不影响代码的生成。这个选项默认为</target>
        </trans-unit>
        <trans-unit id="d449b6d30f1777aba3aa927c43beb1ba1eca16be" translate="yes" xml:space="preserve">
          <source>Enable the Armv8-a Speculation Barrier instruction. This option is only to enable the extension at the assembler level and does not affect code generation. This option is enabled by default for</source>
          <target state="translated">启用Armv8-a Speculation Barrier指令。这个选项只是为了在汇编器级别启用扩展,不影响代码的生成。这个选项默认为</target>
        </trans-unit>
        <trans-unit id="9f3b4e86290c1a4d9bac5d679d03a802d662a426" translate="yes" xml:space="preserve">
          <source>Enable the Armv8-a Speculative Store Bypass Safe instruction. This option is only to enable the extension at the assembler level and does not affect code generation. This option is enabled by default for</source>
          <target state="translated">启用Armv8-a猜测性存储旁路安全指令。这个选项只是为了在汇编器级别启用扩展,不影响代码的生成。这个选项默认为</target>
        </trans-unit>
        <trans-unit id="cb4dff47dd10c4d2d29138894fb337bf731a4703" translate="yes" xml:space="preserve">
          <source>Enable the Armv8-a aes and pmull crypto extension. This also enables Advanced SIMD instructions.</source>
          <target state="translated">启用Armv8-a aes和pmull加密扩展。这也可以启用高级SIMD指令。</target>
        </trans-unit>
        <trans-unit id="e878790ea268c6c3c0f09ca24b1f8d32605101d6" translate="yes" xml:space="preserve">
          <source>Enable the Armv8-a sha2 crypto extension. This also enables Advanced SIMD instructions.</source>
          <target state="translated">启用Armv8-a sha2加密扩展。这也可以启用高级SIMD指令。</target>
        </trans-unit>
        <trans-unit id="712d78d3897110fb983a6b1ce64ceb649bbc8b13" translate="yes" xml:space="preserve">
          <source>Enable the Armv8.5-a Memory Tagging Extensions. This option is only to enable the extension at the assembler level and does not affect code generation.</source>
          <target state="translated">启用Armv8.5-a内存标记扩展。这个选项只是在汇编器层面启用扩展,不影响代码的生成。</target>
        </trans-unit>
        <trans-unit id="95fc60e33111a67c5486993a8b351f8b44d07966" translate="yes" xml:space="preserve">
          <source>Enable the Armv8.5-a Random Number instructions. This option is only to enable the extension at the assembler level and does not affect code generation.</source>
          <target state="translated">启用Armv8.5-a随机数指令。这个选项只是为了在汇编器级别启用扩展,不影响代码的生成。</target>
        </trans-unit>
        <trans-unit id="5baad961c199027af6ce41f297ba396c80d7b6e4" translate="yes" xml:space="preserve">
          <source>Enable the Dot Product extension. This also enables Advanced SIMD instructions.</source>
          <target state="translated">启用 Dot Product 扩展。这也将启用高级SIMD指令。</target>
        </trans-unit>
        <trans-unit id="75d41529d8ccf751d43eb43b131c2899752ea6dc" translate="yes" xml:space="preserve">
          <source>Enable the P0136 adjustment to the semantics of C++11 constructor inheritance. This is part of C++17 but also considered to be a Defect Report against C++11 and C++14. This flag is enabled by default unless</source>
          <target state="translated">启用P0136调整C++11构造函数继承的语义。这是C++17的一部分,但也被认为是针对C++11和C++14的缺陷报告。这个标志默认是启用的,除非</target>
        </trans-unit>
        <trans-unit id="3336547cc155fdebeb020d2a6fd267e14851b493" translate="yes" xml:space="preserve">
          <source>Enable the P0522 resolution to Core issue 150, template template parameters and default arguments: this allows a template with default template arguments as an argument for a template template parameter with fewer template parameters. This flag is enabled by default for</source>
          <target state="translated">启用P0522解决核心问题150,模板参数和默认参数:这允许一个具有默认模板参数的模板作为模板参数的参数,模板参数较少。该标志默认为</target>
        </trans-unit>
        <trans-unit id="e10cb464cd66cc6979f0f2bd645896f8d79b1002" translate="yes" xml:space="preserve">
          <source>Enable the RcPc extension. This does not change code generation from GCC, but is passed on to the assembler, enabling inline asm statements to use instructions from the RcPc extension.</source>
          <target state="translated">启用RcPc扩展。这不会改变GCC的代码生成,但会传递给汇编器,使内联asm语句能够使用RcPc扩展的指令。</target>
        </trans-unit>
        <trans-unit id="b8bb0e2cd28800659cbb25749c903e1e45881bcd" translate="yes" xml:space="preserve">
          <source>Enable the Statistical Profiling extension. This option is only to enable the extension at the assembler level and does not affect code generation.</source>
          <target state="translated">启用统计分析扩展。这个选项只是为了在汇编器级别启用扩展,不影响代码的生成。</target>
        </trans-unit>
        <trans-unit id="d2bf0d0b92eedbfd9d708906c85f1c2c0761dac3" translate="yes" xml:space="preserve">
          <source>Enable the approximation for scalar division.</source>
          <target state="translated">启用标量除法的近似。</target>
        </trans-unit>
        <trans-unit id="089b193263b191426125d1b838990e7a8cad6bd6" translate="yes" xml:space="preserve">
          <source>Enable the approximation for scalar square root.</source>
          <target state="translated">启用标量平方根的近似。</target>
        </trans-unit>
        <trans-unit id="9c93085948ceb9475fc7f62f768a72b094e0ccf8" translate="yes" xml:space="preserve">
          <source>Enable the approximation for vectorized division.</source>
          <target state="translated">启用向量化除法的近似值。</target>
        </trans-unit>
        <trans-unit id="57c9384569cf978709f6ae7436442c4140ae097a" translate="yes" xml:space="preserve">
          <source>Enable the approximation for vectorized square root.</source>
          <target state="translated">启用向量化平方根的近似。</target>
        </trans-unit>
        <trans-unit id="a491c3894437f3620a7562cbc06a8ae940a33c10" translate="yes" xml:space="preserve">
          <source>Enable the built-in global declarations</source>
          <target state="translated">启用内置全局声明</target>
        </trans-unit>
        <trans-unit id="2237d50ade0b28ca43195c6d9a72499aa22da748" translate="yes" xml:space="preserve">
          <source>Enable the compiler to directly use a symbol name as an address in a load/store instruction, without first loading it into a register. Typically, the use of this option generates larger programs, which run faster than when the option isn&amp;rsquo;t used. However, the results vary from program to program, so it is left as a user option, rather than being permanently enabled.</source>
          <target state="translated">使编译器可以直接将符号名称用作加载/存储指令中的地址，而无需先将其加载到寄存器中。通常，使用此选项会生成较大的程序，其运行速度比不使用该选项时要快。但是，结果因程序而异，因此它留作用户选项，而不是永久启用。</target>
        </trans-unit>
        <trans-unit id="41ed1ab2ec5c1611d830306ad10031d9f9977d65" translate="yes" xml:space="preserve">
          <source>Enable the critical-path heuristic in the scheduler. This heuristic favors instructions on the critical path. This is enabled by default when scheduling is enabled, i.e. with</source>
          <target state="translated">在调度器中启用关键路径启发式。这个启发式方法倾向于关键路径上的指令。当启用调度时,即使用</target>
        </trans-unit>
        <trans-unit id="4067ddde2438b48af6e32a24a3e86763ffbd4275" translate="yes" xml:space="preserve">
          <source>Enable the default instructions, equivalent to</source>
          <target state="translated">启用默认指令,相当于</target>
        </trans-unit>
        <trans-unit id="8f1e0508bfc454c7d53eb8b99b0581386011e857" translate="yes" xml:space="preserve">
          <source>Enable the dependent-count heuristic in the scheduler. This heuristic favors the instruction that has more instructions depending on it. This is enabled by default when scheduling is enabled, i.e. with</source>
          <target state="translated">启用调度器中的依赖数量启发式。这个启发式方法倾向于有更多指令依赖的指令。当启用了调度时,即使用了</target>
        </trans-unit>
        <trans-unit id="507033c0f31508a95a83480597cd9ac155e65d9c" translate="yes" xml:space="preserve">
          <source>Enable the documented workaround for the back-to-back store errata of the GR712RC processor.</source>
          <target state="translated">启用GR712RC处理器的背靠背存储勘误的文档化解决方法。</target>
        </trans-unit>
        <trans-unit id="eef2a052e4462aff6add94764479243457e98b05" translate="yes" xml:space="preserve">
          <source>Enable the documented workaround for the back-to-back store errata of the UT699E/UT700 processor.</source>
          <target state="translated">启用UT699E/UT700处理器的背靠背存储勘误的文档化解决方法。</target>
        </trans-unit>
        <trans-unit id="decf2a901923b7e9eb5ca1ab92693295f143a06a" translate="yes" xml:space="preserve">
          <source>Enable the documented workaround for the single erratum of the Atmel AT697F processor (which corresponds to erratum #13 of the AT697E processor).</source>
          <target state="translated">启用 Atmel AT697F 处理器的单一故障(对应于 AT697E 处理器的故障 #13)的文档解决方法。</target>
        </trans-unit>
        <trans-unit id="bcb5bb2598740b13546a58b17f6d5aa7c7ba6853" translate="yes" xml:space="preserve">
          <source>Enable the documented workarounds for the floating-point errata and the data cache nullify errata of the UT699 processor.</source>
          <target state="translated">启用UT699处理器的浮点勘误和数据缓存无效勘误的文档化工作方法。</target>
        </trans-unit>
        <trans-unit id="43eeb910cdee4c766507663e6e771a799fe37d3f" translate="yes" xml:space="preserve">
          <source>Enable the double-precision reciprocal approximation instructions.</source>
          <target state="translated">启用双精度往复逼近指令。</target>
        </trans-unit>
        <trans-unit id="446e6f12ce2775419c21aa646c548678ff1569c1" translate="yes" xml:space="preserve">
          <source>Enable the double-precision reciprocal square root approximation instructions.</source>
          <target state="translated">启用双精度往复平方根逼近指令。</target>
        </trans-unit>
        <trans-unit id="71718fe9aa5b48da1b26c519c152f829f75fb0c0" translate="yes" xml:space="preserve">
          <source>Enable the extended &lt;code&gt;lrw&lt;/code&gt; instruction. This option defaults to on for CK801 and off otherwise.</source>
          <target state="translated">启用扩展的 &lt;code&gt;lrw&lt;/code&gt; 指令。CK801的此选项默认为开，否则为关。</target>
        </trans-unit>
        <trans-unit id="26a17bc6f3de31676776135a782cd9c993e95087" translate="yes" xml:space="preserve">
          <source>Enable the generation of conditional moves.</source>
          <target state="translated">启用条件动作的生成。</target>
        </trans-unit>
        <trans-unit id="04969a109a871e39815667dea2edea4731968533" translate="yes" xml:space="preserve">
          <source>Enable the group heuristic in the scheduler. This heuristic favors the instruction that belongs to a schedule group. This is enabled by default when scheduling is enabled, i.e. with</source>
          <target state="translated">启用调度器中的组启发式。这个启发式方法有利于属于调度组的指令。当调度被启用时,即在使用</target>
        </trans-unit>
        <trans-unit id="74416a1c4632bd2c9719e7f267cc78921917bec4" translate="yes" xml:space="preserve">
          <source>Enable the identity transformation for graphite. For every SCoP we generate the polyhedral representation and transform it back to gimple. Using</source>
          <target state="translated">启用石墨的身份转换。对于每一个SCoP,我们都会生成多面体表示并将其转换回gimple。使用</target>
        </trans-unit>
        <trans-unit id="d52969e42d36857a708d794bd442398a6f2b1d5e" translate="yes" xml:space="preserve">
          <source>Enable the isl based loop nest optimizer. This is a generic loop nest optimizer based on the Pluto optimization algorithms. It calculates a loop structure optimized for data-locality and parallelism. This option is experimental.</source>
          <target state="translated">启用基于isl的循环嵌套优化器。这是一个基于Pluto优化算法的通用循环嵌套优化器。它计算一个针对数据定位和并行性优化的循环结构。这个选项是试验性的。</target>
        </trans-unit>
        <trans-unit id="08b7ee5bf2b0eaab5c12a44d79b227e23ee0c0f5" translate="yes" xml:space="preserve">
          <source>Enable the last-instruction heuristic in the scheduler. This heuristic favors the instruction that is less dependent on the last instruction scheduled. This is enabled by default when scheduling is enabled, i.e. with</source>
          <target state="translated">启用调度器中的最后一条指令启发式。这个启发式方法倾向于对最后一条调度指令依赖性较小的指令。当启用了调度时,即使用了</target>
        </trans-unit>
        <trans-unit id="dc56e6084e464db3d7d083e493fb69fc336bcfc3" translate="yes" xml:space="preserve">
          <source>Enable the optimization pass in the HP-UX linker. Note this makes symbolic debugging impossible. It also triggers a bug in the HP-UX 8 and HP-UX 9 linkers in which they give bogus error messages when linking some programs.</source>
          <target state="translated">启用HP-UX链接器中的优化通道。注意,这使得符号调试变得不可能。它还会触发HP-UX 8和HP-UX 9链接器中的一个错误,当链接某些程序时,它们会给出虚假的错误信息。</target>
        </trans-unit>
        <trans-unit id="8008915ad05d64b6cc01c8698eac6fdda560f6c1" translate="yes" xml:space="preserve">
          <source>Enable the rank heuristic in the scheduler. This heuristic favors the instruction belonging to a basic block with greater size or frequency. This is enabled by default when scheduling is enabled, i.e. with</source>
          <target state="translated">启用调度器中的等级启发式。这个启发式倾向于属于基本块的指令,其大小或频率更高。当启用调度时,默认启用该功能,即使用</target>
        </trans-unit>
        <trans-unit id="e6ed1ceef09b312da3bb73bea4902c46d06845e0" translate="yes" xml:space="preserve">
          <source>Enable the reciprocal approximation instructions for both single and double precision.</source>
          <target state="translated">启用单精度和双精度的往复近似指令。</target>
        </trans-unit>
        <trans-unit id="4c8e53d3299e21b3cf3fba9ff55c2082c7b6b1ec" translate="yes" xml:space="preserve">
          <source>Enable the reciprocal square root approximation instructions for both single and double precision.</source>
          <target state="translated">启用单精度和双精度的往复平方根逼近指令。</target>
        </trans-unit>
        <trans-unit id="21fb72c5396788f3586c523b20f25c7cd0196802" translate="yes" xml:space="preserve">
          <source>Enable the sha512 and sha3 crypto extension. This also enables Advanced SIMD instructions. Use of this option with architectures prior to Armv8.2-A is not supported.</source>
          <target state="translated">启用 sha512 和 sha3 加密扩展。这也可以启用高级SIMD指令。不支持在Armv8.2-A之前的架构中使用该选项。</target>
        </trans-unit>
        <trans-unit id="ac17a049cdd1860b9740d6573dbf1dae4507b37b" translate="yes" xml:space="preserve">
          <source>Enable the single-precision reciprocal approximation instructions.</source>
          <target state="translated">启用单精度往复逼近指令。</target>
        </trans-unit>
        <trans-unit id="a4aef85fc3ef145e7cf3738dcc41b55cc33d82a4" translate="yes" xml:space="preserve">
          <source>Enable the single-precision reciprocal square root approximation instructions.</source>
          <target state="translated">启用单精度往复平方根逼近指令。</target>
        </trans-unit>
        <trans-unit id="0a29cdf0e1f32dd82e6b20680fbd0f552bb364b2" translate="yes" xml:space="preserve">
          <source>Enable the sm3 and sm4 crypto extension. This also enables Advanced SIMD instructions. Use of this option with architectures prior to Armv8.2-A is not supported.</source>
          <target state="translated">启用sm3和sm4加密扩展。这也可以启用高级SIMD指令。不支持在Armv8.2-A之前的架构中使用该选项。</target>
        </trans-unit>
        <trans-unit id="cab5f01ba7747ba0641df8f437ad352196c1c6d3" translate="yes" xml:space="preserve">
          <source>Enable the speculative instruction heuristic in the scheduler. This heuristic favors speculative instructions with greater dependency weakness. This is enabled by default when scheduling is enabled, i.e. with</source>
          <target state="translated">启用调度器中的推测性指令启发式。这个启发式指令倾向于依赖性更弱的推测性指令。当调度被启用时,即在使用</target>
        </trans-unit>
        <trans-unit id="e847a09656f326765748affab74d130a0fbbbfb3" translate="yes" xml:space="preserve">
          <source>Enable the use (disable) of the built-in functions that allow direct access to the cryptographic instructions that were added in version 2.07 of the PowerPC ISA.</source>
          <target state="translated">启用(禁用)内置功能,允许直接访问PowerPC ISA 2.07版本中增加的加密指令。</target>
        </trans-unit>
        <trans-unit id="0beb7325ebbd427ff6f653a5586006076fc19189" translate="yes" xml:space="preserve">
          <source>Enable the use of &lt;code&gt;GPREL&lt;/code&gt; relocations in the FDPIC ABI for data that is known to be in read-only sections. It&amp;rsquo;s enabled by default, except for</source>
          <target state="translated">在FDPIC ABI中启用对 &lt;code&gt;GPREL&lt;/code&gt; 重定位的使用，以用于已知在只读部分中的数据。默认情况下启用，除了</target>
        </trans-unit>
        <trans-unit id="4b3e38bf3ad012b6637b58a91ae68d4399ef997c" translate="yes" xml:space="preserve">
          <source>Enable the use of a minimum runtime environment - no static initializers or constructors. This is intended for memory-constrained devices. The compiler includes special symbols in some objects that tell the linker and runtime which code fragments are required.</source>
          <target state="translated">启用最小运行时环境--没有静态初始化器或构造器。这是为内存受限的设备准备的。编译器在一些对象中包含了特殊的符号,告诉链接器和运行时需要哪些代码片段。</target>
        </trans-unit>
        <trans-unit id="2e3906c56ec37b4268552279d6414d35519910f2" translate="yes" xml:space="preserve">
          <source>Enable the use of assembler directives only GAS understands.</source>
          <target state="translated">启用只有GAS才能理解的汇编器指令。</target>
        </trans-unit>
        <trans-unit id="8315949440093bd19b322b38da5ef593bd5c1273" translate="yes" xml:space="preserve">
          <source>Enable the use of bit manipulation instructions on SH2A.</source>
          <target state="translated">启用SH2A上的位操作指令。</target>
        </trans-unit>
        <trans-unit id="776b7d037afae7efec8fa9845c5ffbd3bad3e0de" translate="yes" xml:space="preserve">
          <source>Enable the use of conditional execution (default).</source>
          <target state="translated">启用条件执行(默认)。</target>
        </trans-unit>
        <trans-unit id="3f92036c53e4d3d87aa05d99ffc56331dbaf7cbe" translate="yes" xml:space="preserve">
          <source>Enable the use of conditional set instructions (default).</source>
          <target state="translated">启用条件集指令的使用(默认)。</target>
        </trans-unit>
        <trans-unit id="f02a7f12f7eb0e41accd67fcdeeacad0f7a7fbae" translate="yes" xml:space="preserve">
          <source>Enable the use of conditional-move instructions (default).</source>
          <target state="translated">启用条件移动指令的使用(默认)。</target>
        </trans-unit>
        <trans-unit id="8bd8c14864a3dc22ad6416f43c205d177280cc14" translate="yes" xml:space="preserve">
          <source>Enable the use of indexed loads. This can be problematic because some optimizers then assume that indexed stores exist, which is not the case.</source>
          <target state="translated">启用索引加载的使用。这可能会有问题,因为有些优化器会认为存在索引存储,而事实并非如此。</target>
        </trans-unit>
        <trans-unit id="fa24f968931ae6f6108870656a7843c7774cc339" translate="yes" xml:space="preserve">
          <source>Enable the use of multiply-accumulate instructions. Disabled by default.</source>
          <target state="translated">启用乘法累加指令的使用。默认情况下已禁用。</target>
        </trans-unit>
        <trans-unit id="d7a1f017f17fab4284673c060b8b2143eec98325" translate="yes" xml:space="preserve">
          <source>Enable the use of odd-numbered single-precision floating-point registers for the o32 ABI. This is the default for processors that are known to support these registers. When using the o32 FPXX ABI,</source>
          <target state="translated">启用o32 ABI使用奇数单精度浮点寄存器。这是已知支持这些寄存器的处理器的默认值。当使用o32 FPXX ABI时。</target>
        </trans-unit>
        <trans-unit id="ea76b09fecc8949f24ae03f9a3f42c9fa0287c50" translate="yes" xml:space="preserve">
          <source>Enable the use of pre/post modify with register displacement.</source>
          <target state="translated">启用前/后修改与寄存器位移的使用。</target>
        </trans-unit>
        <trans-unit id="6635132d2079387847468168f8edcfc7554ca84f" translate="yes" xml:space="preserve">
          <source>Enable the use of the instruction &lt;code&gt;fmovd&lt;/code&gt;. Check</source>
          <target state="translated">启用指令 &lt;code&gt;fmovd&lt;/code&gt; 的使用。检查一下</target>
        </trans-unit>
        <trans-unit id="a2fdf0058d830cee1f93b69f832936392dc9ed46" translate="yes" xml:space="preserve">
          <source>Enable tree pass &lt;var&gt;pass&lt;/var&gt;. See</source>
          <target state="translated">启用tree pass &lt;var&gt;pass&lt;/var&gt; 。看到</target>
        </trans-unit>
        <trans-unit id="b8f020346acd5709653f3c40d525659258a1b9db" translate="yes" xml:space="preserve">
          <source>Enable use of &lt;code&gt;bi&lt;/code&gt; or &lt;code&gt;bih&lt;/code&gt; instructions to implement jump tables.</source>
          <target state="translated">启用使用 &lt;code&gt;bi&lt;/code&gt; 或 &lt;code&gt;bih&lt;/code&gt; 指令来实现跳转表。</target>
        </trans-unit>
        <trans-unit id="79a73d3f193a6e6ff330a4b9de3265b919526bff" translate="yes" xml:space="preserve">
          <source>Enable use of the extended instructions of the FT32B processor.</source>
          <target state="translated">允许使用FT32B处理器的扩展指令。</target>
        </trans-unit>
        <trans-unit id="6d0438ac8bb52c3d5f5f9c3df1e29694d4f64211" translate="yes" xml:space="preserve">
          <source>Enable user-defined instructions.</source>
          <target state="translated">启用用户自定义指令。</target>
        </trans-unit>
        <trans-unit id="289e8ab3bafc79cd3d4d7a33238e966c5c4d7a05" translate="yes" xml:space="preserve">
          <source>Enable verbose cost model dumping in the debug dump files. This option is provided for use in debugging the compiler.</source>
          <target state="translated">在调试转储文件中启用详细的成本模型转储。这个选项是为了在调试编译器时使用。</target>
        </trans-unit>
        <trans-unit id="5698cf3230e865992f3f27c124b887d7d8c62160" translate="yes" xml:space="preserve">
          <source>Enable/disable bit-field layout compatible with the native Microsoft Windows compiler.</source>
          <target state="translated">开启/关闭与本地Microsoft Windows编译器兼容的位域布局。</target>
        </trans-unit>
        <trans-unit id="ec1922decad109f864b4cf7878296aa732c83b64" translate="yes" xml:space="preserve">
          <source>Enable/disable inlining of string operations.</source>
          <target state="translated">开启/关闭字符串操作的内联。</target>
        </trans-unit>
        <trans-unit id="77a9782fdfbab35d94a1e98b3a7fd934623ad240" translate="yes" xml:space="preserve">
          <source>Enable/disable the &lt;var&gt;__float128&lt;/var&gt; keyword for IEEE 128-bit floating point and use either software emulation for IEEE 128-bit floating point or hardware instructions.</source>
          <target state="translated">为IEEE 128位浮点启用/禁用 &lt;var&gt;__float128&lt;/var&gt; 关键字，并为IEEE 128位浮点使用软件仿真或使用硬件指令。</target>
        </trans-unit>
        <trans-unit id="eef257e319b773e37c267992617c97ed3ff87e5c" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of RCPSS, RCPPS, RSQRTSS and RSQRTPS instructions followed an additional Newton-Raphson step instead of doing a floating-point division.</source>
          <target state="translated">启用/禁用RCPSS、RCPPS、RSQRTSS和RSQRTPS指令的生成,这些指令遵循额外的Newton-Raphson步骤,而不是做浮点除法。</target>
        </trans-unit>
        <trans-unit id="ce9687705ccc627a85aa74c6222e1c475cf39951" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of floating point that depends on IEEE arithmetic.</source>
          <target state="translated">开启/关闭依赖于IEEE算术的浮点数的生成。</target>
        </trans-unit>
        <trans-unit id="e06af20ef568b69c3362691eda73268a45b5e6fb" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the 3DNow! instructions.</source>
          <target state="translated">启用/禁用3DNow!指令的生成。</target>
        </trans-unit>
        <trans-unit id="8ea30fdab63dafe3dc7fc652cf67136424f3b625" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the &lt;code&gt;sin&lt;/code&gt;, &lt;code&gt;cos&lt;/code&gt;, and &lt;code&gt;sqrt&lt;/code&gt; instructions on the 387 floating-point unit.</source>
          <target state="translated">在387浮点单元上启用/禁用 &lt;code&gt;sin&lt;/code&gt; ， &lt;code&gt;cos&lt;/code&gt; 和 &lt;code&gt;sqrt&lt;/code&gt; 指令的生成。</target>
        </trans-unit>
        <trans-unit id="d2ce898ea3fbbf85aca7bdcebad5257c4339a871" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the ADX instructions.</source>
          <target state="translated">启用/禁用ADX指令的生成。</target>
        </trans-unit>
        <trans-unit id="8c51cd7ffa80497e01030865d76bb3aa852e4b11" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the AES instructions.</source>
          <target state="translated">启用/禁用AES指令的生成。</target>
        </trans-unit>
        <trans-unit id="139f5148751f41ac5e236f52ce09ecaba429fae5" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the AVX instructions.</source>
          <target state="translated">启用/禁用AVX指令的生成。</target>
        </trans-unit>
        <trans-unit id="c03537f2a6f562c3bdf507ee0385caa610905340" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the AVX2 instructions.</source>
          <target state="translated">启用/禁用AVX2指令的生成。</target>
        </trans-unit>
        <trans-unit id="2f46ca2cd644ae06703a20fd137f758ec86b545b" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the AVX5124FMAPS instructions.</source>
          <target state="translated">启用/禁用AVX5124FMAPS指令的生成。</target>
        </trans-unit>
        <trans-unit id="07c3fb12af13a9cd69b78d9bc8b1bf44bce2f703" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the AVX5124VNNIW instructions.</source>
          <target state="translated">启用/禁用AVX5124VNNIW指令的生成。</target>
        </trans-unit>
        <trans-unit id="3754f28eb3ff315a901b1086241414b36cdc2445" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the AVX512BITALG instructions.</source>
          <target state="translated">启用/禁用AVX512BITALG指令的生成。</target>
        </trans-unit>
        <trans-unit id="9d757b2f48a6a1b6957e3c46cfd35f8cef5e43f2" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the AVX512BW instructions.</source>
          <target state="translated">启用/禁用AVX512BW指令的生成。</target>
        </trans-unit>
        <trans-unit id="d3c2cb946f575c062fed2315966b199b452fa19e" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the AVX512CD instructions.</source>
          <target state="translated">启用/禁用AVX512CD指令的生成。</target>
        </trans-unit>
        <trans-unit id="55f4758594e3826b45c045f868cd0c0b6fe314a5" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the AVX512DQ instructions.</source>
          <target state="translated">启用/禁用AVX512DQ指令的生成。</target>
        </trans-unit>
        <trans-unit id="868a5a7c9ba2cab10b4dbee05b59b72caa86a0f1" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the AVX512ER instructions.</source>
          <target state="translated">启用/禁用AVX512ER指令的生成。</target>
        </trans-unit>
        <trans-unit id="40cf4ec0c6bc30ab932552059f3f09cac003af63" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the AVX512F instructions.</source>
          <target state="translated">启用/禁用AVX512F指令的生成。</target>
        </trans-unit>
        <trans-unit id="ba0e32798c4a1b18ba185f7a8c7a840f7e7480c5" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the AVX512IFMA instructions.</source>
          <target state="translated">启用/禁用AVX512IFMA指令的生成。</target>
        </trans-unit>
        <trans-unit id="cfee43efb9eef88de6b588ce9a55a47d1e02ac8b" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the AVX512PF instructions.</source>
          <target state="translated">启用/禁用AVX512PF指令的生成。</target>
        </trans-unit>
        <trans-unit id="1d9376176900a884770b47d4b38ffe3800952fda" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the AVX512VBMI instructions.</source>
          <target state="translated">启用/禁用AVX512VBMI指令的生成。</target>
        </trans-unit>
        <trans-unit id="5315cd056026db5157cf29bd04c56d18b6d556b6" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the AVX512VBMI2 instructions.</source>
          <target state="translated">启用/禁用AVX512VBMI2指令的生成。</target>
        </trans-unit>
        <trans-unit id="ddf56de8dc48259cd81ab8285e90003fb25e73e2" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the AVX512VL instructions.</source>
          <target state="translated">启用/禁用AVX512VL指令的生成。</target>
        </trans-unit>
        <trans-unit id="26241a02deae96e24160a0ca3f3cc5c41033dbf3" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the AVX512VNNI instructions.</source>
          <target state="translated">启用/禁用AVX512VNNI指令的生成。</target>
        </trans-unit>
        <trans-unit id="84a8ab5234b9fa4c56baeffdaee98c552e89549f" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the AVX512VPOPCNTDQ instructions.</source>
          <target state="translated">启用/禁用AVX512VPOPCNTDQ指令的生成。</target>
        </trans-unit>
        <trans-unit id="dae7d1054e24eee8d8b487043aaad1fc5f1db574" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the BMI instructions.</source>
          <target state="translated">启用/禁用BMI指令的生成。</target>
        </trans-unit>
        <trans-unit id="3d72a8758536f6a87e94a41fe37b66f09beef533" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the BMI2 instructions.</source>
          <target state="translated">启用/禁用BMI2指令的生成。</target>
        </trans-unit>
        <trans-unit id="b738e70323169015d6a48d84ae40dd6c29e5217d" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the CLD before string moves.</source>
          <target state="translated">开启/关闭在字符串移动前生成CLD的功能。</target>
        </trans-unit>
        <trans-unit id="d65d8d65a18d1cfa6dc9c78ebdaad5ad563343cb" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the CLDEMOTE instructions.</source>
          <target state="translated">开启/关闭CLDEMOTE指令的生成。</target>
        </trans-unit>
        <trans-unit id="ccb6f558360b355b894e7ea63cd154a997ed12e8" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the CLFLUSHOPT instructions.</source>
          <target state="translated">开启/关闭CLFLUSHOPT指令的生成。</target>
        </trans-unit>
        <trans-unit id="f0801d5d70f8b9df1efe3aea49e8a0671ca5bfec" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the CLWB instructions.</source>
          <target state="translated">启用/禁用CLWB指令的生成。</target>
        </trans-unit>
        <trans-unit id="94ecea85bbdafb56613082f3e5be7c02237756ed" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the CLZERO instructions.</source>
          <target state="translated">开启/关闭CLZERO指令的生成。</target>
        </trans-unit>
        <trans-unit id="f8d79a3c698ec42fbe32e73864266b011f951b2f" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the CMPXCHG16B instructions.</source>
          <target state="translated">启用/禁用CMPXCHG16B指令的生成。</target>
        </trans-unit>
        <trans-unit id="b0bd05f01479f2861886a517faf455f95df939c9" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the CRC32 instructions.</source>
          <target state="translated">启用/禁用CRC32指令的生成。</target>
        </trans-unit>
        <trans-unit id="d6440333fc0c90bc6217f92335430eaed3b0c3e6" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the F16C instructions.</source>
          <target state="translated">启用/禁用F16C指令的生成。</target>
        </trans-unit>
        <trans-unit id="5cea65073f4a60c1177a3414fc29a42c91b72246" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the FMA instructions.</source>
          <target state="translated">启用/禁用FMA指令的生成。</target>
        </trans-unit>
        <trans-unit id="99871ac8f6615a85bb6ff6e756bf21d0a7db8138" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the FMA4 instructions.</source>
          <target state="translated">启用/禁用FMA4指令的生成。</target>
        </trans-unit>
        <trans-unit id="4820cc9a7748ec354eac413d8f383da9dd67e717" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the FSGSBASE instructions.</source>
          <target state="translated">启用/禁用FSGSBASE指令的生成。</target>
        </trans-unit>
        <trans-unit id="60644d857fe08e2846e93707df49f0bca9fb4a3e" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the FXSR instructions.</source>
          <target state="translated">启用/禁用FXSR指令的生成。</target>
        </trans-unit>
        <trans-unit id="0d58cb597f94125b583603aeaf0cb6d6fac80c1b" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the GFNI instructions.</source>
          <target state="translated">启用/禁用GFNI指令的生成。</target>
        </trans-unit>
        <trans-unit id="9578e9d5e6eece4df004759dd7fc90f39eea18e0" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the HLE instruction prefixes.</source>
          <target state="translated">启用/禁用HLE指令前缀的生成。</target>
        </trans-unit>
        <trans-unit id="549533ddadf886e04d518c98906dae343a33a8ce" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the LWP instructions.</source>
          <target state="translated">开启/关闭LWP指令的生成。</target>
        </trans-unit>
        <trans-unit id="8c3785d4101d06b824b0b36311920e0a30ccd2d9" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the LZCNT instructions.</source>
          <target state="translated">启用/禁用LZCNT指令的生成。</target>
        </trans-unit>
        <trans-unit id="574261210d9c97190453b59ddf32621dc2c86c69" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the MMX instructions.</source>
          <target state="translated">启用/禁用MMX指令的生成。</target>
        </trans-unit>
        <trans-unit id="45a7da12e51c3e52b7908907f0dfac053d1882c4" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the MOVBE instructions.</source>
          <target state="translated">启用/禁用MOVBE指令的生成。</target>
        </trans-unit>
        <trans-unit id="75cfc04edcd4dee4218a715cae2bd3ac7fa16a7e" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the MOVDIR64B instructions.</source>
          <target state="translated">启用/禁用MOVDIR64B指令的生成。</target>
        </trans-unit>
        <trans-unit id="c6371db2050fdd103c6d197692dfd64140187f4a" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the MOVDIRI instructions.</source>
          <target state="translated">启用/禁用MOVDIRI指令的生成。</target>
        </trans-unit>
        <trans-unit id="6e98e7f5d53a1e3439a31b14070244368aebebfe" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the MWAITX instructions.</source>
          <target state="translated">启用/禁用MWAITX指令的生成。</target>
        </trans-unit>
        <trans-unit id="dc37894f7a2ce025aaeba83cdca8f3ca819436f1" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the PCLMUL instructions.</source>
          <target state="translated">启用/禁用PCLMUL指令的生成。</target>
        </trans-unit>
        <trans-unit id="c6ecdb5d5fff5ea045de6d2ca8023861f04ebc4d" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the PCONFIG instructions.</source>
          <target state="translated">开启或关闭PCONFIG指令的生成。</target>
        </trans-unit>
        <trans-unit id="a081a1e7a08745213d7883c3b5236130fe755e13" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the PKU instructions.</source>
          <target state="translated">启用/禁用PKU指令的生成。</target>
        </trans-unit>
        <trans-unit id="e9e69747966699a82f308dbbadb71d6e9fb92d92" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the POPCNT instruction.</source>
          <target state="translated">启用/禁用POPCNT指令的生成。</target>
        </trans-unit>
        <trans-unit id="f9ed3efe60bd11688e60a3f2cb5a1ff252d812d0" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the PREFETCHW instruction.</source>
          <target state="translated">开启或关闭PREFETCHW指令的生成。</target>
        </trans-unit>
        <trans-unit id="006748470b229e9088cb61bc26a1257f2c9a8615" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the PREFETCHWT1 instructions.</source>
          <target state="translated">开启/关闭PREFETCHWT1指令的生成。</target>
        </trans-unit>
        <trans-unit id="2447c34a50f2bd64c3943526353f34051a55f5aa" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the PTWRITE instructions.</source>
          <target state="translated">启用/禁用PTWRITE指令的生成。</target>
        </trans-unit>
        <trans-unit id="5735ee8db2baf84da1ef868849fd1bf84c1f8c11" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the RDPID instructions.</source>
          <target state="translated">启用/禁用RDPID指令的生成。</target>
        </trans-unit>
        <trans-unit id="0b0a5749ac92e20b8e558766d0dd8d71d8adeeaf" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the RDRND instructions.</source>
          <target state="translated">启用/禁用RDRND指令的生成。</target>
        </trans-unit>
        <trans-unit id="4913a7bcb28cb1f12173c4058eaf61ab9315d7d3" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the RDSEED instructions.</source>
          <target state="translated">启用/禁用RDSEED指令的生成。</target>
        </trans-unit>
        <trans-unit id="300142c2ef84f7df525c1aa21af494a1e7bead9f" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the RTM instructions.</source>
          <target state="translated">启用/禁用RTM指令的生成。</target>
        </trans-unit>
        <trans-unit id="0d2ad4e123ffd7abb18aa9c974df2646f0d5508c" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the SAHF instructions.</source>
          <target state="translated">启用/禁用SAHF指令的生成。</target>
        </trans-unit>
        <trans-unit id="632f005a4b74a3843a3298d0871cbe50c5ad6aa9" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the SGX instructions.</source>
          <target state="translated">启用/禁用SGX指令的生成。</target>
        </trans-unit>
        <trans-unit id="6b57bd12c5e2df48fa7d7e43ba31d0995c7f5553" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the SHA instructions.</source>
          <target state="translated">启用/禁用SHA指令的生成。</target>
        </trans-unit>
        <trans-unit id="b5d7ecf6e517427fea4ad12abde111a42bd74cea" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the SSE instructions.</source>
          <target state="translated">启用/禁用SSE指令的生成。</target>
        </trans-unit>
        <trans-unit id="1f0972ae163067735798e2e6f4187300ae1137e4" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the SSE2 instructions.</source>
          <target state="translated">启用/禁用SSE2指令的生成。</target>
        </trans-unit>
        <trans-unit id="b03632fda4a2d3d92f1cf4eac7cca05dbc5a7516" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the SSE3 instructions.</source>
          <target state="translated">启用/禁用SSE3指令的生成。</target>
        </trans-unit>
        <trans-unit id="5e9b999ddb7457a054d66bdaa2de1a8f647ad215" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the SSE4 instructions (both SSE4.1 and SSE4.2).</source>
          <target state="translated">启用/禁用SSE4指令的生成(包括SSE4.1和SSE4.2)。</target>
        </trans-unit>
        <trans-unit id="21d0ef801e5d8043d92d8c50dd3d6daaddab55a0" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the SSE4A instructions.</source>
          <target state="translated">启用/禁用SSE4A指令的生成。</target>
        </trans-unit>
        <trans-unit id="ab7b78506bfd06d655fee8ea1068706000cbeacf" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the SSSE3 instructions.</source>
          <target state="translated">启用/禁用SSSE3指令的生成。</target>
        </trans-unit>
        <trans-unit id="f0e97c519b39b4830d04c86470ddf48b233a76c5" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the TBM instructions.</source>
          <target state="translated">启用/禁用TBM指令的生成。</target>
        </trans-unit>
        <trans-unit id="f3acd83d7172837bca3d0b44672674470b67ff86" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the VAES instructions.</source>
          <target state="translated">开启/关闭VAES指令的生成。</target>
        </trans-unit>
        <trans-unit id="9789894eea8adf6b88ad98db26058bba573138b8" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the VPCLMULQDQ instructions.</source>
          <target state="translated">启用/禁用VPCLMULQDQ指令的生成。</target>
        </trans-unit>
        <trans-unit id="b524ba4aef3ce6873b5b0e11048e23307db06122" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the WAITPKG instructions.</source>
          <target state="translated">开启/关闭WAITPKG指令的生成。</target>
        </trans-unit>
        <trans-unit id="a045e3b2a45d14170b9039170f7578c3d2713015" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the WBNOINVD instructions.</source>
          <target state="translated">开启/关闭WBNOINVD指令的生成。</target>
        </trans-unit>
        <trans-unit id="e40cfbce647b2c7f9ddf7f4f626656cc3a1bc167" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the XOP instructions.</source>
          <target state="translated">启用/禁用XOP指令的生成。</target>
        </trans-unit>
        <trans-unit id="af8da63fa2d12d8f18afd42b233c4d37ee867c63" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the XSAVE instructions.</source>
          <target state="translated">启用/禁用XSAVE指令的生成。</target>
        </trans-unit>
        <trans-unit id="1233b5b867e3f5dba2db3c438d3d6df18bde5ef8" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the XSAVEC instructions.</source>
          <target state="translated">启用/禁用XSAVEC指令的生成。</target>
        </trans-unit>
        <trans-unit id="a0a9e371f8da9a97cd65e604007429c825f18769" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the XSAVEOPT instructions.</source>
          <target state="translated">开启/关闭XSAVEOPT指令的生成。</target>
        </trans-unit>
        <trans-unit id="40e3ea0db494aa36d313e852fcbfd0f81556503b" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the XSAVES instructions.</source>
          <target state="translated">开启/关闭XSAVES指令的生成。</target>
        </trans-unit>
        <trans-unit id="fe009b6bf64ee12df513906e2d5837b5e1c97910" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the advanced bit instructions.</source>
          <target state="translated">启用/禁用高级位指令的生成。</target>
        </trans-unit>
        <trans-unit id="da867b2b85cc94070610ef36f96c5698f745a3ec" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the enhanced 3DNow! instructions.</source>
          <target state="translated">启用/禁用生成增强型3DNow!指令。</target>
        </trans-unit>
        <trans-unit id="7b3bd531bffe003f20aeec31cfccd8602793b41a" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the inline code to do small string operations and calling the library routines for large operations.</source>
          <target state="translated">开启/关闭内联代码的生成,进行小的字符串操作和调用库例程进行大的操作。</target>
        </trans-unit>
        <trans-unit id="902acc4f79ae76c2d32a7b6c514f8deac67c62fb" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the sse4.1 instructions.</source>
          <target state="translated">开启/关闭SSE4.1指令的生成。</target>
        </trans-unit>
        <trans-unit id="2a2818a0c367c053dac063d194f234ec531d06f2" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the sse4.2 instructions.</source>
          <target state="translated">开启/关闭SSE4.2指令的生成。</target>
        </trans-unit>
        <trans-unit id="37e917a07fa74d7e4e6dadb9579fbc16f97ae659" translate="yes" xml:space="preserve">
          <source>Enable/disable the shadow stack built-in functions from CET.</source>
          <target state="translated">开启/关闭CET的影子栈内置功能。</target>
        </trans-unit>
        <trans-unit id="e907f9b58bf0706e2b41d509db8ed99ad239f467" translate="yes" xml:space="preserve">
          <source>Enable/disable using ISA 3.0 hardware instructions to support the &lt;var&gt;__float128&lt;/var&gt; data type.</source>
          <target state="translated">使用ISA 3.0硬件说明启用/禁用以支持 &lt;var&gt;__float128&lt;/var&gt; 数据类型。</target>
        </trans-unit>
        <trans-unit id="4b32f2d1dc57603e53cae07a8b8cf8dd5b0f7205" translate="yes" xml:space="preserve">
          <source>Enabled at levels</source>
          <target state="translated">启用的级别</target>
        </trans-unit>
        <trans-unit id="a2d7a1ae5b45c7663ff5c6c74c01638ab9ca0806" translate="yes" xml:space="preserve">
          <source>Enabled by</source>
          <target state="translated">通过以下方式启用</target>
        </trans-unit>
        <trans-unit id="87971a35b8aed293eb3378e3d8ac5721ecb5cb96" translate="yes" xml:space="preserve">
          <source>Enabled by default at</source>
          <target state="translated">默认情况下,在</target>
        </trans-unit>
        <trans-unit id="bcd7c586f5c724dfc09404aaf2a878d0206e9f76" translate="yes" xml:space="preserve">
          <source>Enabled by default when</source>
          <target state="translated">在以下情况下默认为启用</target>
        </trans-unit>
        <trans-unit id="4f94ea1c93e5664c46cd416ea64f7cc9936467d8" translate="yes" xml:space="preserve">
          <source>Enabled by default with</source>
          <target state="translated">默认启用</target>
        </trans-unit>
        <trans-unit id="261c7b9c3b776bec501c26a9d2fe4d480d9d16f7" translate="yes" xml:space="preserve">
          <source>Enabled by default.</source>
          <target state="translated">默认为已启用。</target>
        </trans-unit>
        <trans-unit id="d3d5b773827f9c4413a2fc452aae96dd06f591fd" translate="yes" xml:space="preserve">
          <source>Enabled for Alpha, AArch64 and x86 at levels</source>
          <target state="translated">在Alpha,AArch64和x86级别启用。</target>
        </trans-unit>
        <trans-unit id="217f8e562e876828812e90f53725615d6901cc9d" translate="yes" xml:space="preserve">
          <source>Enabled for x86 at levels</source>
          <target state="translated">启用x86的级别</target>
        </trans-unit>
        <trans-unit id="44ce21fc6a64ad296ee8e3cda3bcb2b9759adebf" translate="yes" xml:space="preserve">
          <source>Enabled with</source>
          <target state="translated">启用了</target>
        </trans-unit>
        <trans-unit id="979f6df4ed2e6e9238efa8b3ebc9f087264e476a" translate="yes" xml:space="preserve">
          <source>Enables (</source>
          <target state="translated">启用(</target>
        </trans-unit>
        <trans-unit id="7eae3793cec99e5fa487fe453e12770d55076d5b" translate="yes" xml:space="preserve">
          <source>Enables (or disables) reading and writing of 16- and 32- bit values from addresses that are not 16- or 32- bit aligned. By default unaligned access is disabled for all pre-ARMv6, all ARMv6-M and for ARMv8-M Baseline architectures, and enabled for all other architectures. If unaligned access is not enabled then words in packed data structures are accessed a byte at a time.</source>
          <target state="translated">启用(或禁用)从未对齐的16位或32位地址读写16位和32位值。默认情况下,对于所有preARMv6、所有ARMv6-M和ARMv8-M基线架构,不对齐访问是禁用的,而对于所有其他架构,不对齐访问是启用的。如果不启用不对齐访问,那么打包数据结构中的字每次只访问一个字节。</target>
        </trans-unit>
        <trans-unit id="b65eaeca3be0a544da578e950cb68230b9d67b03" translate="yes" xml:space="preserve">
          <source>Enables IVC2 scheduling. IVC2 is a 64-bit VLIW coprocessor.</source>
          <target state="translated">启用IVC2调度。IVC2是一个64位VLIW协处理器。</target>
        </trans-unit>
        <trans-unit id="f8bfc926b8449de54aa34c3f95b4955d0fe52d4e" translate="yes" xml:space="preserve">
          <source>Enables all inter-procedural analysis dumps.</source>
          <target state="translated">启用所有程序间分析转储。</target>
        </trans-unit>
        <trans-unit id="39e032a23d350be5be02b628822ab23ba3864dfe" translate="yes" xml:space="preserve">
          <source>Enables all the optional instructions&amp;mdash;average, multiply, divide, bit operations, leading zero, absolute difference, min/max, clip, and saturation.</source>
          <target state="translated">启用所有可选指令-平均，乘法，除法，位运算，前导零，绝对差，最小/最大，限幅和饱和度。</target>
        </trans-unit>
        <trans-unit id="dcd06b68e12a4e252dc788f4fd7792582f994c23" translate="yes" xml:space="preserve">
          <source>Enables expression of values of induction variables in later iterations of the unrolled loop using the value in the first iteration. This breaks long dependency chains, thus improving efficiency of the scheduling passes.</source>
          <target state="translated">使得在以后的未滚动循环迭代中,可以使用第一次迭代中的值来表达感应变量的值。这样可以打破长长的依赖链,从而提高调度通道的效率。</target>
        </trans-unit>
        <trans-unit id="7564b980df27ae9794a4d64f8c88854f784c151d" translate="yes" xml:space="preserve">
          <source>Enables or disables the use of the string manipulation instructions &lt;code&gt;SMOVF&lt;/code&gt;, &lt;code&gt;SCMPU&lt;/code&gt;, &lt;code&gt;SMOVB&lt;/code&gt;, &lt;code&gt;SMOVU&lt;/code&gt;, &lt;code&gt;SUNTIL&lt;/code&gt;&lt;code&gt;SWHILE&lt;/code&gt; and also the &lt;code&gt;RMPA&lt;/code&gt; instruction. These instructions may prefetch data, which is not safe to do if accessing an I/O register. (See section 12.2.7 of the RX62N Group User&amp;rsquo;s Manual for more information).</source>
          <target state="translated">启用或禁用字符串操作指令 &lt;code&gt;SMOVF&lt;/code&gt; ， &lt;code&gt;SCMPU&lt;/code&gt; ， &lt;code&gt;SMOVB&lt;/code&gt; ， &lt;code&gt;SMOVU&lt;/code&gt; ， &lt;code&gt;SUNTIL&lt;/code&gt; &lt;code&gt;SWHILE&lt;/code&gt; 以及 &lt;code&gt;RMPA&lt;/code&gt; 指令的使用。这些指令可能会预取数据，如果访问I / O寄存器，这样做是不安全的。（有关更多信息，请参见RX62N组用户手册的12.2.7节）。</target>
        </trans-unit>
        <trans-unit id="b2d56a3e8dc64cdea92b5b177de5eee2ddc022a5" translate="yes" xml:space="preserve">
          <source>Enables support for &lt;code&gt;double&lt;/code&gt; and &lt;code&gt;long long&lt;/code&gt; types to be aligned on 8-byte boundaries. The default is to restrict the alignment of all objects to at most 4-bytes. When</source>
          <target state="translated">启用对 &lt;code&gt;double&lt;/code&gt; 和 &lt;code&gt;long long&lt;/code&gt; 类型的支持，使其在8字节边界上对齐。默认设置是将所有对象的对齐限制为最多4个字节。什么时候</target>
        </trans-unit>
        <trans-unit id="85b9ecfc95ed087be71f719ded533eb947f09555" translate="yes" xml:space="preserve">
          <source>Enables support for all single- and double-precision floating-point hardware extensions. Not available for ARC EM.</source>
          <target state="translated">支持所有单精度和双精度浮点硬件扩展。不适用于ARC EM。</target>
        </trans-unit>
        <trans-unit id="f75e5afbbe9ab70b1263a70cb8894e0664caf0b1" translate="yes" xml:space="preserve">
          <source>Enables support for all single-precision floating-point hardware extensions.</source>
          <target state="translated">启用对所有单精度浮点硬件扩展的支持。</target>
        </trans-unit>
        <trans-unit id="7883565cb4fb9258e363d1f2d7f38e140fa66bc4" translate="yes" xml:space="preserve">
          <source>Enables support for double-precision floating-point and fused multiply and add hardware extensions. This option includes option &amp;lsquo;</source>
          <target state="translated">启用对双精度浮点和融合乘法与添加硬件扩展的支持。此选项包括选项&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="09688a51318111fb1133a1873f85c86a0dd2d24a" translate="yes" xml:space="preserve">
          <source>Enables support for double-precision floating-point hardware extensions using double-precision assist instructions. All single-precision floating-point hardware extensions are also enabled. This option is only available for ARC EM.</source>
          <target state="translated">使用双精度辅助指令支持双精度浮点硬件扩展。所有单精度浮点硬件扩展也被启用。该选项仅适用于ARC EM。</target>
        </trans-unit>
        <trans-unit id="998d962adb014531e7dc98dfd0f68752292543ee" translate="yes" xml:space="preserve">
          <source>Enables support for double-precision floating-point hardware extensions using double-precision assist instructions. The single-precision floating-point and fused multiply and add hardware extensions are also enabled. This option is only available for ARC EM.</source>
          <target state="translated">使用双精度辅助指令支持双精度浮点硬件扩展。单精度浮点和融合乘法和加法硬件扩展也被启用。此选项仅适用于ARC EM。</target>
        </trans-unit>
        <trans-unit id="4d9fab6d5bc5404d7e456a561365555b9e55a46b" translate="yes" xml:space="preserve">
          <source>Enables support for double-precision floating-point hardware extensions using double-precision assist instructions. The single-precision floating-point extension is also enabled. This option is only available for ARC EM.</source>
          <target state="translated">使用双精度辅助指令支持双精度浮点硬件扩展。单精度浮点扩展也被启用。该选项仅适用于ARC EM。</target>
        </trans-unit>
        <trans-unit id="8714aef39627cf0d1b3a7e36332dd7526fef4382" translate="yes" xml:space="preserve">
          <source>Enables support for double-precision floating-point hardware extensions using double-precision assist instructions. The single-precision floating-point, square-root, and divide extensions are also enabled. This option is only available for ARC EM.</source>
          <target state="translated">使用双精度辅助指令,支持双精度浮点硬件扩展,同时启用单精度浮点、平方根和除法扩展。单精度浮点、平方根和除法扩展也被启用。该选项仅适用于ARC EM。</target>
        </trans-unit>
        <trans-unit id="88614dbf859eb550fe6ea83089c08ee2a35b6c5a" translate="yes" xml:space="preserve">
          <source>Enables support for double-precision floating-point hardware extensions. The single-precision floating-point extension is also enabled. Not available for ARC EM.</source>
          <target state="translated">启用对双精度浮点硬件扩展的支持,同时启用单精度浮点扩展。单精度浮点扩展也被启用。不适用于ARC EM。</target>
        </trans-unit>
        <trans-unit id="ed75b445d9416dbdcca6532a5b9e4ba16b46347a" translate="yes" xml:space="preserve">
          <source>Enables support for double-precision floating-point, square-root and divide hardware extensions. This option includes option &amp;lsquo;</source>
          <target state="translated">支持双精度浮点，平方根和除法硬件扩展。此选项包括选项&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="4020a8753a0799a59f9043cec8f1b76a8cbf21f5" translate="yes" xml:space="preserve">
          <source>Enables support for single-precision floating-point and fused multiply and add hardware extensions.</source>
          <target state="translated">实现对单精度浮点和融合乘法和加法硬件扩展的支持。</target>
        </trans-unit>
        <trans-unit id="739ef3a6f4ad193608707def042ed976fbb38794" translate="yes" xml:space="preserve">
          <source>Enables support for single-precision floating-point hardware extensions.</source>
          <target state="translated">启用对单精度浮点硬件扩展的支持。</target>
        </trans-unit>
        <trans-unit id="69030e58955d3b24f425bf1f743dd072b9ea41e4" translate="yes" xml:space="preserve">
          <source>Enables support for single-precision floating-point, square-root and divide hardware extensions.</source>
          <target state="translated">实现对单精度浮点、平方根和除法硬件扩展的支持。</target>
        </trans-unit>
        <trans-unit id="dd589dcd1e2f89f81d2aa1944b9d5b300d0537d9" translate="yes" xml:space="preserve">
          <source>Enables support for specific floating-point hardware extensions for ARCv2 cores. Supported values for &lt;var&gt;fpu&lt;/var&gt; are:</source>
          <target state="translated">为ARCv2内核启用对特定浮点硬件扩展的支持。 &lt;var&gt;fpu&lt;/var&gt; 支持的值为：</target>
        </trans-unit>
        <trans-unit id="40edc654abf50990a91d4feb4df5e9d34bf7f47f" translate="yes" xml:space="preserve">
          <source>Enables support for the RH850 version of the V850 ABI. This is the default. With this version of the ABI the following rules apply:</source>
          <target state="translated">启用对 V850 ABI 的 RH850 版本的支持。这是默认值。对于此版本的 ABI,适用以下规则。</target>
        </trans-unit>
        <trans-unit id="a3ccc0d52f2a100abeb7168c2966e22df181fb16" translate="yes" xml:space="preserve">
          <source>Enables support for the old GCC version of the V850 ABI. With this version of the ABI the following rules apply:</source>
          <target state="translated">启用对 V850 ABI 旧版 GCC 的支持。对于此版本的 ABI,适用以下规则。</target>
        </trans-unit>
        <trans-unit id="13d14b8a88583d4801772d41f78d731f585ac76d" translate="yes" xml:space="preserve">
          <source>Enables the 32-bit coprocessor&amp;rsquo;s instructions.</source>
          <target state="translated">启用32位协处理器的指令。</target>
        </trans-unit>
        <trans-unit id="37f8bcfc01e8c9f171283b3e6b96664748ea2f0b" translate="yes" xml:space="preserve">
          <source>Enables the 64-bit coprocessor&amp;rsquo;s instructions.</source>
          <target state="translated">启用64位协处理器的指令。</target>
        </trans-unit>
        <trans-unit id="866afe4dc503faaed460c73ebf4e30e8a9116810" translate="yes" xml:space="preserve">
          <source>Enables the &lt;code&gt;abs&lt;/code&gt; instruction, which is the absolute difference between two registers.</source>
          <target state="translated">启用 &lt;code&gt;abs&lt;/code&gt; 指令，这是两个寄存器之间的绝对差。</target>
        </trans-unit>
        <trans-unit id="50cf3b6e541adf62bd77b142fc53a61d05fc7c9c" translate="yes" xml:space="preserve">
          <source>Enables the &lt;code&gt;ave&lt;/code&gt; instruction, which computes the average of two registers.</source>
          <target state="translated">启用 &lt;code&gt;ave&lt;/code&gt; 指令，该指令计算两个寄存器的平均值。</target>
        </trans-unit>
        <trans-unit id="2e8478914d75d996b9e9464d4ca7119db6662af4" translate="yes" xml:space="preserve">
          <source>Enables the &lt;code&gt;clip&lt;/code&gt; instruction. Note that</source>
          <target state="translated">启用 &lt;code&gt;clip&lt;/code&gt; 指令。注意</target>
        </trans-unit>
        <trans-unit id="e97f2d1656d0f25d2a745cdd7d099a3de6f71833" translate="yes" xml:space="preserve">
          <source>Enables the &lt;code&gt;div&lt;/code&gt; and &lt;code&gt;divu&lt;/code&gt; instructions.</source>
          <target state="translated">启用 &lt;code&gt;div&lt;/code&gt; 和 &lt;code&gt;divu&lt;/code&gt; 指令。</target>
        </trans-unit>
        <trans-unit id="13fbaebc3f1567a809a1ff5ab5607726671f6a6a" translate="yes" xml:space="preserve">
          <source>Enables the &lt;code&gt;leadz&lt;/code&gt; (leading zero) instruction.</source>
          <target state="translated">启用 &lt;code&gt;leadz&lt;/code&gt; （前导零）指令。</target>
        </trans-unit>
        <trans-unit id="1da519d84df5ff1b705dd7abe77d948ec006a771" translate="yes" xml:space="preserve">
          <source>Enables the &lt;code&gt;min&lt;/code&gt; and &lt;code&gt;max&lt;/code&gt; instructions.</source>
          <target state="translated">启用 &lt;code&gt;min&lt;/code&gt; 和 &lt;code&gt;max&lt;/code&gt; 指令。</target>
        </trans-unit>
        <trans-unit id="4da5357bac4df4fb4da7516696ce5726e90631ac" translate="yes" xml:space="preserve">
          <source>Enables the &lt;code&gt;repeat&lt;/code&gt; and &lt;code&gt;erepeat&lt;/code&gt; instructions, used for low-overhead looping.</source>
          <target state="translated">启用 &lt;code&gt;repeat&lt;/code&gt; 和 &lt;code&gt;erepeat&lt;/code&gt; 指令，用于低开销循环。</target>
        </trans-unit>
        <trans-unit id="b4f230bdb2809992da1b8ee11728eb1397ea6487" translate="yes" xml:space="preserve">
          <source>Enables the bit operation instructions&amp;mdash;bit test (&lt;code&gt;btstm&lt;/code&gt;), set (&lt;code&gt;bsetm&lt;/code&gt;), clear (&lt;code&gt;bclrm&lt;/code&gt;), invert (&lt;code&gt;bnotm&lt;/code&gt;), and test-and-set (&lt;code&gt;tas&lt;/code&gt;).</source>
          <target state="translated">启用位操作指令-位测试（ &lt;code&gt;btstm&lt;/code&gt; ），置位（ &lt;code&gt;bsetm&lt;/code&gt; ），清除（ &lt;code&gt;bclrm&lt;/code&gt; ），取反（ &lt;code&gt;bnotm&lt;/code&gt; ）和测试设置（ &lt;code&gt;tas&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="650b34422af73f1c39adc7884ebaf0f44be9cbe6" translate="yes" xml:space="preserve">
          <source>Enables the coprocessor instructions. By default, this is a 32-bit coprocessor. Note that the coprocessor is normally enabled via the</source>
          <target state="translated">启用协处理器指令。默认情况下,这是一个32位协处理器。请注意,协处理器通常是通过以下方式启用的</target>
        </trans-unit>
        <trans-unit id="849d54c65b67142ad3610bf0ff41505e124671a1" translate="yes" xml:space="preserve">
          <source>Enables the cryptographic instructions on &amp;lsquo;</source>
          <target state="translated">启用&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="e300897cde7331a4be041e33bbcd7fc9ca650ebe" translate="yes" xml:space="preserve">
          <source>Enables the generation of position independent data. When enabled any access to constant data is done via an offset from a base address held in a register. This allows the location of constant data to be determined at run time without requiring the executable to be relocated, which is a benefit to embedded applications with tight memory constraints. Data that can be modified is not affected by this option.</source>
          <target state="translated">启用位置独立数据的生成。当启用时,对常量数据的任何访问都是通过与寄存器中的基地址的偏移来完成的。这允许在运行时确定常量数据的位置,而不需要重新定位可执行文件,这对内存紧张的嵌入式应用是有好处的。可以修改的数据不受此选项的影响。</target>
        </trans-unit>
        <trans-unit id="cf1918bfd22c209206d2846ea3d88a19e3a73f7d" translate="yes" xml:space="preserve">
          <source>Enables the loop invariant motion pass in the RTL loop optimizer. Enabled at level</source>
          <target state="translated">启用RTL循环优化器中的循环不变运动通道。启用级别</target>
        </trans-unit>
        <trans-unit id="ecd974872f6eca7f7d4ae7dac04ee2a0a333973d" translate="yes" xml:space="preserve">
          <source>Enables the multiplication and multiply-accumulate instructions.</source>
          <target state="translated">启用乘法和乘法累加指令。</target>
        </trans-unit>
        <trans-unit id="7fc40693c14939b54a70a171fa80eb19af8d1f4b" translate="yes" xml:space="preserve">
          <source>Enables the saturation instructions. Note that the compiler does not currently generate these itself, but this option is included for compatibility with other tools, like &lt;code&gt;as&lt;/code&gt;.</source>
          <target state="translated">启用饱和度指令。需要注意的是编译器不产生目前这些本身，而是这个选项是为了与其他工具，如兼容性 &lt;code&gt;as&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e1d7284a520ac6d5afcc167354eeade161094006" translate="yes" xml:space="preserve">
          <source>Enables the use of a linker plugin during link-time optimization. This option relies on plugin support in the linker, which is available in gold or in GNU ld 2.21 or newer.</source>
          <target state="translated">在链接时间优化期间启用链接器插件。这个选项依赖于链接器中的插件支持,在gold或GNU ld 2.21或更新版本中可用。</target>
        </trans-unit>
        <trans-unit id="118989c6873866bc4e811127fbd742299b49d5aa" translate="yes" xml:space="preserve">
          <source>Enables the use of the e3v5 LOOP instruction. The use of this instruction is not enabled by default when the e3v5 architecture is selected because its use is still experimental.</source>
          <target state="translated">启用e3v5 LOOP指令的使用。当选择e3v5架构时,该指令的使用默认不启用,因为它的使用仍是试验性的。</target>
        </trans-unit>
        <trans-unit id="e218c1fa9772e443eea87ffbfc5f0dee5a840cd5" translate="yes" xml:space="preserve">
          <source>Enables using Neon to handle scalar 64-bits operations. This is disabled by default since the cost of moving data from core registers to Neon is high.</source>
          <target state="translated">启用Neon处理64位标量操作。由于将数据从核心寄存器转移到Neon的成本很高,所以默认情况下是禁用的。</target>
        </trans-unit>
        <trans-unit id="93ce405e36a27a5a639a5f340a06317ff8160589" translate="yes" xml:space="preserve">
          <source>Enabling profiling and extra run-time error checking.</source>
          <target state="translated">启用剖析和额外的运行时错误检查。</target>
        </trans-unit>
        <trans-unit id="5821fec7ee87050117e2081a31b307f34868a8ad" translate="yes" xml:space="preserve">
          <source>Encoding</source>
          <target state="translated">Encoding</target>
        </trans-unit>
        <trans-unit id="1819780111faf7544a66daa1d16d7611734230e4" translate="yes" xml:space="preserve">
          <source>End lock elision on a lock variable. Memory order must be &lt;code&gt;__ATOMIC_RELEASE&lt;/code&gt; or stronger.</source>
          <target state="translated">在锁变量上结束锁省略。内存顺序必须为 &lt;code&gt;__ATOMIC_RELEASE&lt;/code&gt; 或更高。</target>
        </trans-unit>
        <trans-unit id="69cc11cd813a9fd03e4e1fc6cf5b510b36e19495" translate="yes" xml:space="preserve">
          <source>Enforces total ordering with all other &lt;code&gt;__ATOMIC_SEQ_CST&lt;/code&gt; operations.</source>
          <target state="translated">与所有其他 &lt;code&gt;__ATOMIC_SEQ_CST&lt;/code&gt; 操作一起强制执行总排序。</target>
        </trans-unit>
        <trans-unit id="73b1dc6c07adcccbcc5d5e8b0eff931a874c6d38" translate="yes" xml:space="preserve">
          <source>Enumerator Attributes</source>
          <target state="translated">枚举者属性</target>
        </trans-unit>
        <trans-unit id="761809a73bf6c1d0fb389d9bcb324c7d577436ca" translate="yes" xml:space="preserve">
          <source>Env vars that affect GCC.</source>
          <target state="translated">影响GCC的环境变量。</target>
        </trans-unit>
        <trans-unit id="ea26afcbc28cf64cc5104756e2576f023e89221a" translate="yes" xml:space="preserve">
          <source>Epiphany&amp;mdash;</source>
          <target state="translated">Epiphany&amp;mdash;</target>
        </trans-unit>
        <trans-unit id="fdd6abe4d3e43555fd6a8a4c1cf45b848e487e53" translate="yes" xml:space="preserve">
          <source>Equivalent to</source>
          <target state="translated">相当于</target>
        </trans-unit>
        <trans-unit id="0492deafa8eba22fc0afe8f6e0c0ba64239ba223" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;r&lt;/code&gt;; retained for backwards compatibility.</source>
          <target state="translated">等效于 &lt;code&gt;r&lt;/code&gt; ; 保留以向后兼容。</target>
        </trans-unit>
        <trans-unit id="5ca07fcd394d3a2e5866991bf00cbd021a139de4" translate="yes" xml:space="preserve">
          <source>Errors in the 1990 ISO C standard were corrected in two Technical Corrigenda published in 1994 and 1996. GCC does not support the uncorrected version.</source>
          <target state="translated">1994年和1996年出版的两份技术更正中纠正了1990年ISO C标准中的错误。GCC不支持未更正的版本。</target>
        </trans-unit>
        <trans-unit id="9bd134a89f5b4b95f3127d3f912224b4af14b70c" translate="yes" xml:space="preserve">
          <source>Errors in the 1999 ISO C standard were corrected in three Technical Corrigenda published in 2001, 2004 and 2007. GCC does not support the uncorrected version.</source>
          <target state="translated">在2001年、2004年和2007年出版的三份技术更正中纠正了1999年ISO C标准中的错误。GCC不支持未更正的版本。</target>
        </trans-unit>
        <trans-unit id="6e25566cabac14a5da9bfa8653af8b052717aff4" translate="yes" xml:space="preserve">
          <source>Estimate on average number of instructions that are executed before prefetch finishes. The distance prefetched ahead is proportional to this constant. Increasing this number may also lead to less streams being prefetched (see</source>
          <target state="translated">估算预取结束前平均执行的指令数。前面预取的距离与这个常数成正比。增加这个数字也可能会导致预取的指令流减少(参见</target>
        </trans-unit>
        <trans-unit id="72b4ac99601ca6a847d5bc2efd8309225cad447d" translate="yes" xml:space="preserve">
          <source>Evaluate member access, array subscripting, and shift expressions in left-to-right order, and evaluate assignment in right-to-left order, as adopted for C++17. Enabled by default with</source>
          <target state="translated">以从左到右的顺序评估成员访问、数组下标和移位表达式,并以从右到左的顺序评估赋值,正如C++17所采用的那样。缺省情况下,启用了</target>
        </trans-unit>
        <trans-unit id="ed6e92089eb6b24b347c4f30cb7670720994b11e" translate="yes" xml:space="preserve">
          <source>Even if</source>
          <target state="translated">即使</target>
        </trans-unit>
        <trans-unit id="8ba62c67150da80165ae50905d020111dae00562" translate="yes" xml:space="preserve">
          <source>Even if a recovery mode is turned on the compiler side, it needs to be also enabled on the runtime library side, otherwise the failures are still fatal. The runtime library defaults to &lt;code&gt;halt_on_error=0&lt;/code&gt; for ThreadSanitizer and UndefinedBehaviorSanitizer, while default value for AddressSanitizer is &lt;code&gt;halt_on_error=1&lt;/code&gt;. This can be overridden through setting the &lt;code&gt;halt_on_error&lt;/code&gt; flag in the corresponding environment variable.</source>
          <target state="translated">即使在编译器端启用了恢复模式，也需要在运行时库端启用它，否则失败仍然是致命的。对于ThreadSanitizer和UndefinedBehaviorSanitizer，运行时库的默认值为 &lt;code&gt;halt_on_error=0&lt;/code&gt; ，而AddressSanitizer的默认值为 &lt;code&gt;halt_on_error=1&lt;/code&gt; 。可以通过在相应的环境变量中设置 &lt;code&gt;halt_on_error&lt;/code&gt; 标志来覆盖它。</target>
        </trans-unit>
        <trans-unit id="da53370f643fa43e1823dc15023009c950cb897a" translate="yes" xml:space="preserve">
          <source>Even if a zero-length bit-field is not followed by a normal bit-field, it may still affect the alignment of the structure:</source>
          <target state="translated">即使零长度的位字段后面没有正常的位字段,也可能影响结构的排列。</target>
        </trans-unit>
        <trans-unit id="9b825b64ce454de632ebee37b594db5436e47422" translate="yes" xml:space="preserve">
          <source>Even if this switch is enabled, not all function calls are turned into long calls. The heuristic is that static functions, functions that have the &lt;code&gt;short_call&lt;/code&gt; attribute, functions that are inside the scope of a &lt;code&gt;#pragma no_long_calls&lt;/code&gt; directive, and functions whose definitions have already been compiled within the current compilation unit are not turned into long calls. The exceptions to this rule are that weak function definitions, functions with the &lt;code&gt;long_call&lt;/code&gt; attribute or the &lt;code&gt;section&lt;/code&gt; attribute, and functions that are within the scope of a &lt;code&gt;#pragma long_calls&lt;/code&gt; directive are always turned into long calls.</source>
          <target state="translated">即使启用此开关，也不是所有的函数调用都变成长调用。启发式方法是，静态函数，具有 &lt;code&gt;short_call&lt;/code&gt; 属性的函数，在 &lt;code&gt;#pragma no_long_calls&lt;/code&gt; 指令范围内的函数以及定义已在当前编译单元中编译的函数不会转换为长调用。该规则的例外是弱函数定义，具有 &lt;code&gt;long_call&lt;/code&gt; 属性或 &lt;code&gt;section&lt;/code&gt; 属性的函数以及在 &lt;code&gt;#pragma long_calls&lt;/code&gt; 指令范围内的函数始终会转换为长调用。</target>
        </trans-unit>
        <trans-unit id="a177b98fd2580c16f017a412cd7670171b404cf0" translate="yes" xml:space="preserve">
          <source>Even if you specify</source>
          <target state="translated">即使你指定了</target>
        </trans-unit>
        <trans-unit id="026e995923c6387a8240f24bd1c3774f9d66883c" translate="yes" xml:space="preserve">
          <source>Even register</source>
          <target state="translated">甚至注册</target>
        </trans-unit>
        <trans-unit id="1873ee5db4140cfb18dab53240c9f43c6ee8669a" translate="yes" xml:space="preserve">
          <source>Even though &lt;code&gt;sum&lt;/code&gt; is accumulated in the loop, no use is made of that summation, so the accumulation can be removed.</source>
          <target state="translated">即使在循环中累积了 &lt;code&gt;sum&lt;/code&gt; ，也没有使用该总和，因此可以删除累积。</target>
        </trans-unit>
        <trans-unit id="0b22f73b585732fa4671fb4003533ee7b0a1cf1d" translate="yes" xml:space="preserve">
          <source>Even-numbered D register</source>
          <target state="translated">偶数D寄存器</target>
        </trans-unit>
        <trans-unit id="7a684983474ccc7c72520e56a87f8aeb051b1c6b" translate="yes" xml:space="preserve">
          <source>Even-numbered accumulator register.</source>
          <target state="translated">偶数的累加器寄存器。</target>
        </trans-unit>
        <trans-unit id="5d57aa9755d20359a2247e4c26c56f18f53bb2c4" translate="yes" xml:space="preserve">
          <source>Every data object has an alignment requirement. The alignment requirement for all data except structures, unions, and arrays is either the size of the object or the current packing size (specified with either the &lt;code&gt;aligned&lt;/code&gt; attribute or the &lt;code&gt;pack&lt;/code&gt; pragma), whichever is less. For structures, unions, and arrays, the alignment requirement is the largest alignment requirement of its members. Every object is allocated an offset so that:</source>
          <target state="translated">每个数据对象都有一个对齐要求。除结构，并集和数组以外的所有数据的对齐要求是对象的大小或当前的包装大小（由 &lt;code&gt;aligned&lt;/code&gt; 属性或 &lt;code&gt;pack&lt;/code&gt; pragma指定），以较小者为准。对于结构，联合和数组，对齐要求是其成员中最大的对齐要求。每个对象都分配有一个偏移量，以便：</target>
        </trans-unit>
        <trans-unit id="f8971cb366f8a5972e5437f17d61872668933fb6" translate="yes" xml:space="preserve">
          <source>Exact power of 2</source>
          <target state="translated">2的精确功率</target>
        </trans-unit>
        <trans-unit id="54ce059465b2a026c1f41bec2bf7eb93331ac554" translate="yes" xml:space="preserve">
          <source>Exactly like</source>
          <target state="translated">就像...</target>
        </trans-unit>
        <trans-unit id="ec471d84b36457f0d9d75c03377c9e3cd5f3de93" translate="yes" xml:space="preserve">
          <source>Example of use:</source>
          <target state="translated">使用实例:</target>
        </trans-unit>
        <trans-unit id="861245b8779c3c0a240081e66f72046983ca7d16" translate="yes" xml:space="preserve">
          <source>Example usage</source>
          <target state="translated">使用实例</target>
        </trans-unit>
        <trans-unit id="98859dfb330cbeca8950e6e5316d288484dfa387" translate="yes" xml:space="preserve">
          <source>Example usage of these low level built-in functions may look like:</source>
          <target state="translated">这些低级内置函数的使用示例可能是这样的。</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="3203ec56f6623a12f68979ebebcaf218b0674056" translate="yes" xml:space="preserve">
          <source>Examples of code with undefined behavior are &lt;code&gt;a = a++;&lt;/code&gt;, &lt;code&gt;a[n]
= b[n++]&lt;/code&gt; and &lt;code&gt;a[i++] = i;&lt;/code&gt;. Some more complicated cases are not diagnosed by this option, and it may give an occasional false positive result, but in general it has been found fairly effective at detecting this sort of problem in programs.</source>
          <target state="translated">具有未定义行为的代码示例为 &lt;code&gt;a = a++;&lt;/code&gt; ， &lt;code&gt;a[n] = b[n++]&lt;/code&gt; 和 &lt;code&gt;a[i++] = i;&lt;/code&gt; 。使用此选项无法诊断出一些更复杂的情况，并且可能偶尔会出现误报的结果，但总的来说，已发现在检测程序中此类问题方面相当有效。</target>
        </trans-unit>
        <trans-unit id="ac2978569b0d96ea67fa55ae3fcac3a58dbeaa7e" translate="yes" xml:space="preserve">
          <source>Examples of the use cases for this tool are:</source>
          <target state="translated">该工具的使用案例有:</target>
        </trans-unit>
        <trans-unit id="fb3447b632f6a431215776dcf254a01001a40c4f" translate="yes" xml:space="preserve">
          <source>Examples:</source>
          <target state="translated">Examples:</target>
        </trans-unit>
        <trans-unit id="911d893025886382ab91769b068aa06459b40499" translate="yes" xml:space="preserve">
          <source>Exception handlers differ from interrupt handlers because the system pushes an error code on the stack. An exception handler declaration is similar to that for an interrupt handler, but with a different mandatory function signature. The compiler arranges to pop the error code off the stack before the &lt;code&gt;IRET&lt;/code&gt; instruction.</source>
          <target state="translated">异常处理程序与中断处理程序不同，因为系统将错误代码压入堆栈。异常处理程序的声明与中断处理程序的声明相似，但是具有不同的强制性函数签名。编译器安排在 &lt;code&gt;IRET&lt;/code&gt; 指令之前从堆栈弹出错误代码。</target>
        </trans-unit>
        <trans-unit id="d60ce999e28bc42ef5590e1790afd26bd6f33f60" translate="yes" xml:space="preserve">
          <source>Exception handlers should only be used for exceptions that push an error code; you should use an interrupt handler in other cases. The system will crash if the wrong kind of handler is used.</source>
          <target state="translated">异常处理程序只能用于推送错误代码的异常,在其他情况下应该使用中断处理程序。如果使用了错误的处理程序,系统会崩溃。</target>
        </trans-unit>
        <trans-unit id="61c358f1bb209146fb6ebbb188045ae7738fdddb" translate="yes" xml:space="preserve">
          <source>Execution and Data Prediction Restriction Instructions.</source>
          <target state="translated">执行和数据预测限制指令。</target>
        </trans-unit>
        <trans-unit id="cd06a6fd64c8b50d4558cb3316fd26ee9feb5746" translate="yes" xml:space="preserve">
          <source>Expand &lt;code&gt;adddi3&lt;/code&gt; and &lt;code&gt;subdi3&lt;/code&gt; at RTL generation time into &lt;code&gt;add.f&lt;/code&gt;, &lt;code&gt;adc&lt;/code&gt; etc. This option is deprecated.</source>
          <target state="translated">在RTL生成时将 &lt;code&gt;adddi3&lt;/code&gt; 和 &lt;code&gt;subdi3&lt;/code&gt; 扩展为 &lt;code&gt;add.f&lt;/code&gt; ， &lt;code&gt;adc&lt;/code&gt; 等。不建议使用此选项。</target>
        </trans-unit>
        <trans-unit id="ad01d735326a2f6603f39ee595dd5b05ec416e8b" translate="yes" xml:space="preserve">
          <source>Expand into an inline loop.</source>
          <target state="translated">展开成一个内联循环。</target>
        </trans-unit>
        <trans-unit id="5ddf0ba44f58c348b4ec4063056d25a8b4689f7a" translate="yes" xml:space="preserve">
          <source>Expand using i386 &lt;code&gt;rep&lt;/code&gt; prefix of the specified size.</source>
          <target state="translated">使用指定大小的i386 &lt;code&gt;rep&lt;/code&gt; 前缀进行扩展。</target>
        </trans-unit>
        <trans-unit id="7720f0269a2d383f2dd786328047f312351d0105" translate="yes" xml:space="preserve">
          <source>Explain what alignment considerations lead to the decision to make an instruction short or long.</source>
          <target state="translated">解释哪些调整考虑因素导致决定使指令变短或变长。</target>
        </trans-unit>
        <trans-unit id="69ccd30207ce48099a948be1541f4d6a441981f8" translate="yes" xml:space="preserve">
          <source>Explicit instantiations can be used for the largest or most frequently duplicated instances, without having to know exactly which other instances are used in the rest of the program. You can scatter the explicit instantiations throughout your program, perhaps putting them in the translation units where the instances are used or the translation units that define the templates themselves; you can put all of the explicit instantiations you need into one big file; or you can create small files like</source>
          <target state="translated">显式实例可以用于最大的或最经常重复的实例,而不需要确切地知道在程序的其余部分使用了哪些其他实例。你可以将显式实例分散在整个程序中,可能将它们放在使用实例的翻译单元中,或者放在定义模板本身的翻译单元中;你可以将所有你需要的显式实例放在一个大文件中;或者你可以创建一些小文件,如</target>
        </trans-unit>
        <trans-unit id="83042939fc50e1e36ef864fc1e78eae1c62725bf" translate="yes" xml:space="preserve">
          <source>Explicitly instantiated inline methods are unaffected by this option as their linkage might otherwise cross a shared library boundary. See &lt;a href=&quot;template-instantiation#Template-Instantiation&quot;&gt;Template Instantiation&lt;/a&gt;.</source>
          <target state="translated">显式实例化的内联方法不受此选项的影响，因为它们的链接可能会跨越共享库的边界。请参阅&lt;a href=&quot;template-instantiation#Template-Instantiation&quot;&gt;模板实例化&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="61bd3ccba4b2c3767215774893d82391e0bc09ab" translate="yes" xml:space="preserve">
          <source>Expressions are currently only contracted if</source>
          <target state="translated">目前只有在以下情况下才会收缩表达式</target>
        </trans-unit>
        <trans-unit id="83c4bb072fc47e954ad84b1ea046adec27e854fd" translate="yes" xml:space="preserve">
          <source>Expressions that may be cast to the union type are those whose type matches at least one of the members of the union. Thus, given the following union and variables:</source>
          <target state="translated">可以投向联合类型的表达式是那些类型至少与联合中的一个成员匹配的表达式。因此,给定以下联合体和变量:</target>
        </trans-unit>
        <trans-unit id="ed9daef21d2e4305e648aee577dd1d6036550745" translate="yes" xml:space="preserve">
          <source>Extend (do not extend) the</source>
          <target state="translated">延长(不延长)</target>
        </trans-unit>
        <trans-unit id="20891f4ff37ed22f4675dae3faaf487875cf701e" translate="yes" xml:space="preserve">
          <source>Extend the current ABI with a particular extension, or remove such extension. Valid values are &amp;lsquo;</source>
          <target state="translated">用特定的扩展名扩展当前的ABI，或删除该扩展名。有效值为'</target>
        </trans-unit>
        <trans-unit id="91653b5f0401d6aa2a22ebdd6efdf9699bdaeb42" translate="yes" xml:space="preserve">
          <source>Extended &lt;code&gt;asm&lt;/code&gt; statements have to be inside a C function, so to write inline assembly language at file scope (&amp;ldquo;top-level&amp;rdquo;), outside of C functions, you must use basic &lt;code&gt;asm&lt;/code&gt;. You can use this technique to emit assembler directives, define assembly language macros that can be invoked elsewhere in the file, or write entire functions in assembly language. Basic &lt;code&gt;asm&lt;/code&gt; statements outside of functions may not use any qualifiers.</source>
          <target state="translated">扩展的 &lt;code&gt;asm&lt;/code&gt; 语句必须在C函数内部，因此要在C函数之外的文件范围（&amp;ldquo;顶级&amp;rdquo;）编写内联汇编语言，必须使用basic &lt;code&gt;asm&lt;/code&gt; 。您可以使用此技术来发出汇编器指令，定义可以在文件中其他位置调用的汇编语言宏，或以汇编语言编写整个函数。函数外部的基本 &lt;code&gt;asm&lt;/code&gt; 语句不能使用任何限定符。</target>
        </trans-unit>
        <trans-unit id="04a315d0cc75470cd36dfd3cb992c3efb5b94ebf" translate="yes" xml:space="preserve">
          <source>Extended alignments up to &lt;em&gt;2^{28}&lt;/em&gt; (bytes) are supported for objects of automatic storage duration. Alignments supported for objects of static and thread storage duration are determined by the ABI.</source>
          <target state="translated">对于自动存储持续时间的对象，最多支持&lt;em&gt;2 ^ {28}&lt;/em&gt;（字节）的扩展对齐方式。静态和线程存储持续时间对象支持的对齐方式由ABI确定。</target>
        </trans-unit>
        <trans-unit id="342b07a4e48b541946d49b2270415ae84b1aef83" translate="yes" xml:space="preserve">
          <source>Extended registers are not stored on stack before execution of function with monitor attribute. Default option is</source>
          <target state="translated">在执行具有监视器属性的函数之前,扩展寄存器不存储在堆栈中。默认选项是</target>
        </trans-unit>
        <trans-unit id="57cf6f586241383946ebaa10651980906e2e7008" translate="yes" xml:space="preserve">
          <source>Extended registers are stored on stack before execution of function with monitor attribute. Default option is</source>
          <target state="translated">扩展寄存器在执行具有监视器属性的函数之前被存储在堆栈中。默认选项是</target>
        </trans-unit>
        <trans-unit id="c9dbca1f0ee851a1a4128829e444f15ff917ef20" translate="yes" xml:space="preserve">
          <source>Extra time accounted by inliner for function overhead such as time needed to execute function prologue and epilogue</source>
          <target state="translated">额外的时间由inliner计入函数开销,如执行函数序幕和尾声所需的时间。</target>
        </trans-unit>
        <trans-unit id="e69f20e9f683920d3fb4329abd951e878b1f9372" translate="yes" xml:space="preserve">
          <source>F</source>
          <target state="translated">F</target>
        </trans-unit>
        <trans-unit id="6b84b9421bc7074ef9cc3088b04a6a18d77c5b2a" translate="yes" xml:space="preserve">
          <source>FMA instructions.</source>
          <target state="translated">FMA指示:</target>
        </trans-unit>
        <trans-unit id="cbf2cb3fe36db407f3a3f0c5e7fef7fc69c6ce00" translate="yes" xml:space="preserve">
          <source>FMA4 instructions.</source>
          <target state="translated">FMA4说明:</target>
        </trans-unit>
        <trans-unit id="b911450c0baee87cf3722095b3e43b717fb436bb" translate="yes" xml:space="preserve">
          <source>FP or VSX register to hold 64-bit doubles for direct moves or NO_REGS.</source>
          <target state="translated">FP或VSX寄存器,用于存放64位的双倍数,用于直接移动或NO_REGS。</target>
        </trans-unit>
        <trans-unit id="faed2456bafb04f8c1fb3d816c3c01f0fb54a75c" translate="yes" xml:space="preserve">
          <source>FP or VSX register to hold 64-bit integers for VSX insns or NO_REGS.</source>
          <target state="translated">FP或VSX寄存器为VSX insns或NO_REGS保存64位整数。</target>
        </trans-unit>
        <trans-unit id="09f3e1a89b6305e70a6393d549d66dbbcfd2f8f3" translate="yes" xml:space="preserve">
          <source>FP or VSX register to hold 64-bit integers for direct moves or NO_REGS.</source>
          <target state="translated">FP或VSX寄存器,用于存放64位整数,用于直接移动或NO_REGS。</target>
        </trans-unit>
        <trans-unit id="ec3d1f378b46e7073f89e8d2b44ffed3f4925fb8" translate="yes" xml:space="preserve">
          <source>FP or VSX register to perform ISA 2.07 float ops or NO_REGS.</source>
          <target state="translated">FP或VSX寄存器执行ISA 2.07浮点运算或NO_REGS。</target>
        </trans-unit>
        <trans-unit id="c07c5ae5e3671f1039b7da098eb0348a7624af7b" translate="yes" xml:space="preserve">
          <source>FP or VSX register to perform float operations under</source>
          <target state="translated">FP 或 VSX 寄存器,以执行浮动运算,在</target>
        </trans-unit>
        <trans-unit id="a924751782c4ee4b5b496793046fc57512ab59f9" translate="yes" xml:space="preserve">
          <source>FP register if</source>
          <target state="translated">FP寄存器,如果</target>
        </trans-unit>
        <trans-unit id="5b1d99e5f9118d7c70848e6ad6167bba8b0b23d3" translate="yes" xml:space="preserve">
          <source>FPSCR</source>
          <target state="translated">FPSCR</target>
        </trans-unit>
        <trans-unit id="ff875f9855f1361e4b30af2d77d0d9c23d4bdca2" translate="yes" xml:space="preserve">
          <source>FRV&amp;mdash;</source>
          <target state="translated">FRV&amp;mdash;</target>
        </trans-unit>
        <trans-unit id="230d241b3d82558160cd5187f1fe9d9c435b18d5" translate="yes" xml:space="preserve">
          <source>FSF GCC on Darwin does not create &amp;ldquo;fat&amp;rdquo; object files; it creates an object file for the single architecture that GCC was built to target. Apple&amp;rsquo;s GCC on Darwin does create &amp;ldquo;fat&amp;rdquo; files if multiple</source>
          <target state="translated">达尔文市的FSF GCC不会创建&amp;ldquo;胖&amp;rdquo;目标文件。它为GCC所针对的单一架构创建了一个目标文件。如果达尔文的Apple GCC确实创建了多个&amp;ldquo;胖&amp;rdquo;文件</target>
        </trans-unit>
        <trans-unit id="7a156574143e4ca84e24da6dfdb279cf456cca04" translate="yes" xml:space="preserve">
          <source>FT32&amp;mdash;</source>
          <target state="translated">FT32&amp;mdash;</target>
        </trans-unit>
        <trans-unit id="599d4afb33240eb91ea2840bb9ba8f1ff44bf581" translate="yes" xml:space="preserve">
          <source>Fat LTO objects are object files that contain both the intermediate language and the object code. This makes them usable for both LTO linking and normal linking. This option is effective only when compiling with</source>
          <target state="translated">胖LTO对象是包含中间语言和对象代码的对象文件。这使得它们既可以用于LTO链接,也可以用于普通链接。这个选项只有在编译时使用</target>
        </trans-unit>
        <trans-unit id="ad565d9d01d0e0bf91fd6a8532f6d81613338901" translate="yes" xml:space="preserve">
          <source>Feature</source>
          <target state="translated">Feature</target>
        </trans-unit>
        <trans-unit id="909a10c01414726d2e86792cc51fea9d589c8fb6" translate="yes" xml:space="preserve">
          <source>Feature Modifiers</source>
          <target state="translated">特征修改器</target>
        </trans-unit>
        <trans-unit id="c796b811ac5dce8d8e36d70db0e07e63b27d5eab" translate="yes" xml:space="preserve">
          <source>Feature modifiers used with</source>
          <target state="translated">使用的特征修饰符</target>
        </trans-unit>
        <trans-unit id="aa0dd17c258c743dbea5c193ddf09bb6cebf5964" translate="yes" xml:space="preserve">
          <source>Fields of the &lt;var&gt;branch&lt;/var&gt; element have following semantics:</source>
          <target state="translated">&lt;var&gt;branch&lt;/var&gt; 元素的字段具有以下语义：</target>
        </trans-unit>
        <trans-unit id="9cc6e9443d376e5757bc3441d57c3f310bf11770" translate="yes" xml:space="preserve">
          <source>Fields of the &lt;var&gt;file&lt;/var&gt; element have following semantics:</source>
          <target state="translated">&lt;var&gt;file&lt;/var&gt; 元素的字段具有以下语义：</target>
        </trans-unit>
        <trans-unit id="95d9f92882f18f3b5a67ac3eeafb040cc8cd3ea3" translate="yes" xml:space="preserve">
          <source>Fields of the &lt;var&gt;function&lt;/var&gt; element have following semantics:</source>
          <target state="translated">&lt;var&gt;function&lt;/var&gt; 元素的字段具有以下语义：</target>
        </trans-unit>
        <trans-unit id="55692b6d4a213073df2d182e70897f1d18b6852c" translate="yes" xml:space="preserve">
          <source>Fields of the root element have following semantics:</source>
          <target state="translated">根元素的字段具有以下语义。</target>
        </trans-unit>
        <trans-unit id="fba211bc33a4751c92e11eae269c5fe4195a12b5" translate="yes" xml:space="preserve">
          <source>Finally &amp;lsquo;</source>
          <target state="translated">最后'</target>
        </trans-unit>
        <trans-unit id="fa45d699cd27babdae75f4a8d69ed2b5379e7a87" translate="yes" xml:space="preserve">
          <source>Finally, consider:</source>
          <target state="translated">最后,考虑:</target>
        </trans-unit>
        <trans-unit id="6901050dc8495daab10889e0ec9cf3617e7fb433" translate="yes" xml:space="preserve">
          <source>Finally, note how we declared the &lt;code&gt;len&lt;/code&gt; argument and the return value to be of type &lt;code&gt;unsigned long&lt;/code&gt;. They could also be declared to be of type &lt;code&gt;unsigned int&lt;/code&gt; and everything would still work.</source>
          <target state="translated">最后，请注意我们如何将 &lt;code&gt;len&lt;/code&gt; 参数和返回值声明为 &lt;code&gt;unsigned long&lt;/code&gt; 类型。也可以将它们声明为 &lt;code&gt;unsigned int&lt;/code&gt; 类型，并且一切仍将正常进行。</target>
        </trans-unit>
        <trans-unit id="e5f1ab577d27769ef2407d2da5789ec6bcd34e2a" translate="yes" xml:space="preserve">
          <source>Finally, there is a complication when encoding &lt;code&gt;const char *&lt;/code&gt; versus &lt;code&gt;char * const&lt;/code&gt;. Because &lt;code&gt;char *&lt;/code&gt; is encoded as &lt;code&gt;*&lt;/code&gt; and not as &lt;code&gt;^c&lt;/code&gt;, there is no way to express the fact that &lt;code&gt;r&lt;/code&gt; applies to the pointer or to the pointee.</source>
          <target state="translated">最后，在对 &lt;code&gt;const char *&lt;/code&gt; 与 &lt;code&gt;char * const&lt;/code&gt; 编码时会出现复杂情况。因为 &lt;code&gt;char *&lt;/code&gt; 被编码为 &lt;code&gt;*&lt;/code&gt; 而不是 &lt;code&gt;^c&lt;/code&gt; ，所以无法表达 &lt;code&gt;r&lt;/code&gt; 适用于指针或指针的事实。</target>
        </trans-unit>
        <trans-unit id="8d30428380add9f793c9b319edf17d149e4e4f73" translate="yes" xml:space="preserve">
          <source>Find the pass dump in a file whose name is composed of three components separated by a period: the name of the source file GCC was invoked to compile, a numeric suffix indicating the pass number followed by the letter &amp;lsquo;</source>
          <target state="translated">在文件名中查找密码转储，该文件的名称由三个由句点分隔的部分组成：调用源文件GCC的名称进行编译，数字后缀表示密码，后跟字母'</target>
        </trans-unit>
        <trans-unit id="e29b12881247aeb3ff64dc0cee23e3331d67217f" translate="yes" xml:space="preserve">
          <source>Fine-tune size optimization with regards to instruction lengths and alignment. The recognized values for &lt;var&gt;level&lt;/var&gt; are:</source>
          <target state="translated">关于指令长度和对齐方式的大小优化。公认的 &lt;var&gt;level&lt;/var&gt; 值是：</target>
        </trans-unit>
        <trans-unit id="ac0c5ec00d58b3e74a205bd50ea7108335fcb5b8" translate="yes" xml:space="preserve">
          <source>First SSE register (&lt;code&gt;%xmm0&lt;/code&gt;).</source>
          <target state="translated">第一个SSE寄存器（ &lt;code&gt;%xmm0&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="846211171f7db5bd2bab9f64d61f4530995ca5a0" translate="yes" xml:space="preserve">
          <source>First, the argument corresponding to a transparent union type can be of any type in the union; no cast is required. Also, if the union contains a pointer type, the corresponding argument can be a null pointer constant or a void pointer expression; and if the union contains a void pointer type, the corresponding argument can be any pointer expression. If the union member type is a pointer, qualifiers like &lt;code&gt;const&lt;/code&gt; on the referenced type must be respected, just as with normal pointer conversions.</source>
          <target state="translated">首先，与透明联合类型相对应的参数可以是联合中的任何类型。无需强制转换。另外，如果联合包含指针类型，则对应的参数可以是空指针常量或空指针表达式；如果联合包含空指针类型，则对应的参数可以是任何指针表达式。如果联合成员类型是指针，则必须 &lt;code&gt;const&lt;/code&gt; 引用类型上的const等限定符，就像普通的指针转换一样。</target>
        </trans-unit>
        <trans-unit id="15ab13a54971de84d7939a64c563f0a383d5df53" translate="yes" xml:space="preserve">
          <source>Fixed form Fortran source code that must be preprocessed (with the traditional preprocessor).</source>
          <target state="translated">固定形式的Fortran源代码,必须进行预处理(用传统的预处理器)。</target>
        </trans-unit>
        <trans-unit id="5552528a96a767723e84e4196dd1b4ccd0182f5d" translate="yes" xml:space="preserve">
          <source>Fixed form Fortran source code that should not be preprocessed.</source>
          <target state="translated">修正了不应该被预处理的Fortran源代码的形式。</target>
        </trans-unit>
        <trans-unit id="a31ce070cf9649524c3cf990ab1f1ab74aaffaa3" translate="yes" xml:space="preserve">
          <source>Fixed limit on the size of the static frame of functions: when it is topped by a particular function, stack checking is not reliable and a warning is issued by the compiler.</source>
          <target state="translated">修正了对函数静态帧大小的限制:当它被某个函数顶住时,堆栈检查不可靠,编译器会发出警告。</target>
        </trans-unit>
        <trans-unit id="85452dd45f77555cfc8a81ff291dd73781c80f82" translate="yes" xml:space="preserve">
          <source>Fixed-Point Types.</source>
          <target state="translated">定点类型。</target>
        </trans-unit>
        <trans-unit id="9f75981b930fd7189960fca9ba3bbc1796113fd3" translate="yes" xml:space="preserve">
          <source>Fixed-point data values contain fractional and optional integral parts. The format of fixed-point data varies and depends on the target machine.</source>
          <target state="translated">定点数据值包含小数和可选的积分部分。定点数据的格式因目标机器而异。</target>
        </trans-unit>
        <trans-unit id="cb9fd0ce1881fdc78c0697ef42b75b52d214196d" translate="yes" xml:space="preserve">
          <source>Fixed-point types are supported by the DWARF debug information format.</source>
          <target state="translated">DWARF调试信息格式支持固定点类型。</target>
        </trans-unit>
        <trans-unit id="265c5eecf02fb4f371ef39bcfe52b0dfc566b452" translate="yes" xml:space="preserve">
          <source>Flag the first routine whose name starts with &lt;var&gt;prefix&lt;/var&gt; as the main routine for the debugger.</source>
          <target state="translated">将名称以 &lt;var&gt;prefix&lt;/var&gt; 开头的第一个例程标记为调试器的主要例程。</target>
        </trans-unit>
        <trans-unit id="b3390bf7e3c55aee432834653f4b1f941089ffde" translate="yes" xml:space="preserve">
          <source>Flexible array members are written as &lt;code&gt;contents[]&lt;/code&gt; without the &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">灵活的数组成员以不带 &lt;code&gt;0&lt;/code&gt; 的 &lt;code&gt;contents[]&lt;/code&gt; 形式编写。</target>
        </trans-unit>
        <trans-unit id="78dbcf864480c990f48bdd0342e3500b8c1282bd" translate="yes" xml:space="preserve">
          <source>Flexible array members have incomplete type, and so the &lt;code&gt;sizeof&lt;/code&gt; operator may not be applied. As a quirk of the original implementation of zero-length arrays, &lt;code&gt;sizeof&lt;/code&gt; evaluates to zero.</source>
          <target state="translated">灵活数组成员的类型不完整，因此可能不应用 &lt;code&gt;sizeof&lt;/code&gt; 运算符。作为零长度数组的原始实现的怪癖， &lt;code&gt;sizeof&lt;/code&gt; 的值为零。</target>
        </trans-unit>
        <trans-unit id="417d40e05d0999fe399d7881ccf242563a660e4a" translate="yes" xml:space="preserve">
          <source>Flexible array members may only appear as the last member of a &lt;code&gt;struct&lt;/code&gt; that is otherwise non-empty.</source>
          <target state="translated">灵活数组成员只能显示为结构的最后一个成员，否则该 &lt;code&gt;struct&lt;/code&gt; 为非空。</target>
        </trans-unit>
        <trans-unit id="7ffa11ebef97287859a0bb0cd563e4e8b95df556" translate="yes" xml:space="preserve">
          <source>Floating point constant 0.</source>
          <target state="translated">浮点常数0。</target>
        </trans-unit>
        <trans-unit id="4560e48bbc91965a1ad028ff4792c55d56a0a598" translate="yes" xml:space="preserve">
          <source>Floating point constant that can be loaded into a register with one instruction per word</source>
          <target state="translated">浮点常数,可以用每字一条指令加载到寄存器中。</target>
        </trans-unit>
        <trans-unit id="c516f23fc0c0d103a2cd7b68a6433df4fc2451d6" translate="yes" xml:space="preserve">
          <source>Floating point constant that is legal for store immediate</source>
          <target state="translated">浮点常数,是合法的存储即时的。</target>
        </trans-unit>
        <trans-unit id="32a95fa9a487a375449247a65d3193bb1004c1f0" translate="yes" xml:space="preserve">
          <source>Floating point constant that is not a 68881 constant</source>
          <target state="translated">不是68881常数的浮点常数。</target>
        </trans-unit>
        <trans-unit id="79fb00b4bc62aed23a250b86e31fbd72d18840a5" translate="yes" xml:space="preserve">
          <source>Floating point constant zero</source>
          <target state="translated">浮点常数为零</target>
        </trans-unit>
        <trans-unit id="af1bda543b578583ca4289ffad142bd3d77692c3" translate="yes" xml:space="preserve">
          <source>Floating point register</source>
          <target state="translated">浮点寄存器</target>
        </trans-unit>
        <trans-unit id="573ca6d44dc3da178f33a1539aefbe9a7a969613" translate="yes" xml:space="preserve">
          <source>Floating point register (containing 32-bit value)</source>
          <target state="translated">浮点寄存器(含32位值)</target>
        </trans-unit>
        <trans-unit id="b5c02f93e377f6b8a0b2a78a784d0d990452bae9" translate="yes" xml:space="preserve">
          <source>Floating point register (containing 64-bit value)</source>
          <target state="translated">浮点寄存器(含64位值)</target>
        </trans-unit>
        <trans-unit id="ef449f8f1e197b3fc12f9a7bbd29815185c01715" translate="yes" xml:space="preserve">
          <source>Floating point register (deprecated)</source>
          <target state="translated">浮点寄存器(已废弃)</target>
        </trans-unit>
        <trans-unit id="f7558c1a4bb9c6d833aca45e4903e960fa15f358" translate="yes" xml:space="preserve">
          <source>Floating point register if</source>
          <target state="translated">浮点寄存器,如果</target>
        </trans-unit>
        <trans-unit id="c165ca40457d305eb7d330afdb797521f5de1b77" translate="yes" xml:space="preserve">
          <source>Floating point register if direct moves are available, or NO_REGS.</source>
          <target state="translated">浮点寄存器,如果可以直接移动,或者NO_REGS。</target>
        </trans-unit>
        <trans-unit id="5262899d7f774e7136ab629899288cb3977b1a82" translate="yes" xml:space="preserve">
          <source>Floating point register if the LFIWAX instruction is enabled or NO_REGS.</source>
          <target state="translated">浮点寄存器,如果LFIWAX指令被启用或NO_REGS。</target>
        </trans-unit>
        <trans-unit id="37f6e14594705b3a931f7fb11f09da2da0b4cf9c" translate="yes" xml:space="preserve">
          <source>Floating point register if the LFIWZX instruction is enabled or NO_REGS.</source>
          <target state="translated">浮点寄存器,如果启用LFIWZX指令或NO_REGS。</target>
        </trans-unit>
        <trans-unit id="92eb4ccc2dc9e99f2247ac815df53adacfbc08da" translate="yes" xml:space="preserve">
          <source>Floating point register if the STFIWX instruction is enabled or NO_REGS.</source>
          <target state="translated">如果启用STFIWX指令或NO_REGS,则为浮点寄存器。</target>
        </trans-unit>
        <trans-unit id="aaae0bc8bed9980f091aa46b02c6dcb5a52b76ec" translate="yes" xml:space="preserve">
          <source>Floating point register, Advanced SIMD vector register or SVE vector register</source>
          <target state="translated">浮点寄存器,高级SIMD向量寄存器或SVE向量寄存器。</target>
        </trans-unit>
        <trans-unit id="16c68eba878493a77d0c164e7869af76e99d9145" translate="yes" xml:space="preserve">
          <source>Floating point registers AC0 through AC3. These can be loaded from/to memory with a single instruction.</source>
          <target state="translated">浮点寄存器AC0至AC3。这些寄存器可以用一条指令从内存加载到内存。</target>
        </trans-unit>
        <trans-unit id="83ce48a9f40c05895bc4e20f6bb82f032e76933d" translate="yes" xml:space="preserve">
          <source>Floating point registers AC4 and AC5. These cannot be loaded from/to memory with a single instruction.</source>
          <target state="translated">浮点寄存器AC4和AC5。这些寄存器不能用一条指令从内存中加载到内存中。</target>
        </trans-unit>
        <trans-unit id="f58b0d70fd4d764630301aac0286ba68330e3308" translate="yes" xml:space="preserve">
          <source>Floating-point condition code register.</source>
          <target state="translated">浮点条件代码寄存器。</target>
        </trans-unit>
        <trans-unit id="b56c9d5aa5cba048b4016e56db5b37a9156be6f1" translate="yes" xml:space="preserve">
          <source>Floating-point constant 0.0</source>
          <target state="translated">浮点常数 0.0</target>
        </trans-unit>
        <trans-unit id="11ca0595ff5b1cee498ed130d48a9d7ef77d2ce2" translate="yes" xml:space="preserve">
          <source>Floating-point constant 0.0 or 1.0</source>
          <target state="translated">浮点常数0.0或1.0。</target>
        </trans-unit>
        <trans-unit id="3af5f60b6556d63fbe7c6434e046d0c15fe3ffe1" translate="yes" xml:space="preserve">
          <source>Floating-point constant whose integral representation can be moved into an integer register using a high/lo_sum instruction sequence</source>
          <target state="translated">浮点常数,其积分表示法可以通过高/低的指令序列转移到整数寄存器中。</target>
        </trans-unit>
        <trans-unit id="c0e1876d49ff7a36e4b65c8a5784d9cd7a8e4781" translate="yes" xml:space="preserve">
          <source>Floating-point constant whose integral representation can be moved into an integer register using a single mov instruction</source>
          <target state="translated">浮点常数,其积分表示法可以通过一条mov指令移动到一个整数寄存器中。</target>
        </trans-unit>
        <trans-unit id="500223502156611a39a78dc4c23517d86e8a772f" translate="yes" xml:space="preserve">
          <source>Floating-point constant whose integral representation can be moved into an integer register using a single sethi instruction</source>
          <target state="translated">浮点常数,其积分表示法可以通过一条sethi指令转移到整数寄存器中。</target>
        </trans-unit>
        <trans-unit id="95fef479c80cb031fff0832cf86c7d5b4d064fb7" translate="yes" xml:space="preserve">
          <source>Floating-point instructions are only generated for 32-bit floating-point values, however, so the FPU hardware is not used for doubles if the</source>
          <target state="translated">但浮点指令只针对32位浮点值生成,所以FPU硬件不用于双倍值,如果是</target>
        </trans-unit>
        <trans-unit id="f213ef5758f227bd35596edf6ff5e36aed746a21" translate="yes" xml:space="preserve">
          <source>Floating-point minimum and maximum. These instructions are only generated if</source>
          <target state="translated">浮点最小和最大。只有在以下情况下才会产生这些指令</target>
        </trans-unit>
        <trans-unit id="92610c4245848bdded34c9ee994e62b738188b93" translate="yes" xml:space="preserve">
          <source>Floating-point register</source>
          <target state="translated">浮点寄存器</target>
        </trans-unit>
        <trans-unit id="e5380eea89f6db263d5d241526df6bedd0bd11ff" translate="yes" xml:space="preserve">
          <source>Floating-point register on the SPARC-V8 architecture and lower floating-point register on the SPARC-V9 architecture.</source>
          <target state="translated">SPARC-V8架构的浮点寄存器和SPARC-V9架构的低级浮点寄存器。</target>
        </trans-unit>
        <trans-unit id="2b69cf45a938c9e06197f0424f9a02b9aa9f002d" translate="yes" xml:space="preserve">
          <source>Floating-point register. It is equivalent to &amp;lsquo;</source>
          <target state="translated">浮点寄存器。相当于&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="8ed13acd5482c325b73e858b30874f469fb342d2" translate="yes" xml:space="preserve">
          <source>Floating-point register. It is only valid on the SPARC-V9 architecture when the Visual Instruction Set is available.</source>
          <target state="translated">浮点寄存器。只有在SPARC-V9架构上,当可视指令集可用时,它才有效。</target>
        </trans-unit>
        <trans-unit id="d0d6928cc5c4254d825994f1f03f5fa64bf43b02" translate="yes" xml:space="preserve">
          <source>Floating-point trigonometric and exponential functions. These instructions are only generated if</source>
          <target state="translated">浮点三角函数和指数函数。只有在以下情况下才会产生这些指令</target>
        </trans-unit>
        <trans-unit id="cebba3f2674f659c3ac76a05e885a881a3fcce6d" translate="yes" xml:space="preserve">
          <source>Floating-point zero</source>
          <target state="translated">浮点零点</target>
        </trans-unit>
        <trans-unit id="c245efe80db566f234058018cbe48e4698e1bcb0" translate="yes" xml:space="preserve">
          <source>Floating-point zero.</source>
          <target state="translated">浮点数为0。</target>
        </trans-unit>
        <trans-unit id="bc0561e46ee46f1370ce39f7bd133e69f6b47448" translate="yes" xml:space="preserve">
          <source>Flushing registers to memory has performance implications and may be an issue for time-sensitive code. You can provide better information to GCC to avoid this, as shown in the following examples. At a minimum, aliasing rules allow GCC to know what memory &lt;em&gt;doesn&amp;rsquo;t&lt;/em&gt; need to be flushed.</source>
          <target state="translated">将寄存器刷新到内存会影响性能，并且可能是时间敏感代码的问题。您可以向GCC提供更好的信息来避免这种情况，如以下示例所示。至少，重叠规则允许GCC知道内存&lt;em&gt;并不&lt;/em&gt;需要被刷新。</target>
        </trans-unit>
        <trans-unit id="7d035cae4646bbea859b3aa6a64d528d7a19fea6" translate="yes" xml:space="preserve">
          <source>Follow the EABI requirement of always creating a frame pointer whenever a stack frame is allocated. This option is enabled by default and can be disabled with</source>
          <target state="translated">遵循EABI的要求,每当分配一个堆栈帧时,总是创建一个帧指针。这个选项默认是启用的,也可以使用</target>
        </trans-unit>
        <trans-unit id="ec0c3b76630fd745381cc215a284820af75a683a" translate="yes" xml:space="preserve">
          <source>Footnotes</source>
          <target state="translated">Footnotes</target>
        </trans-unit>
        <trans-unit id="9203a30acc55d5bd89f275fd6b63f1da488b512a" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;t2&lt;/code&gt;, &lt;code&gt;bar&lt;/code&gt; is placed at offset 2, rather than offset 1. Accordingly, the size of &lt;code&gt;t2&lt;/code&gt; is 4. For &lt;code&gt;t3&lt;/code&gt;, the zero-length bit-field does not affect the alignment of &lt;code&gt;bar&lt;/code&gt; or, as a result, the size of the structure.</source>
          <target state="translated">对于 &lt;code&gt;t2&lt;/code&gt; ， &lt;code&gt;bar&lt;/code&gt; 放置在偏移量2处，而不是偏移量1处。因此， &lt;code&gt;t2&lt;/code&gt; 的大小为4。对于 &lt;code&gt;t3&lt;/code&gt; ，零长度位域不影响 &lt;code&gt;bar&lt;/code&gt; 的对齐，因此不影响bar的大小。结构。</target>
        </trans-unit>
        <trans-unit id="c0e04e76cdfed448d6c782b7f817b6eea03c0f50" translate="yes" xml:space="preserve">
          <source>For &lt;var&gt;n&lt;/var&gt; greater than zero,</source>
          <target state="translated">对于大于零的 &lt;var&gt;n&lt;/var&gt;</target>
        </trans-unit>
        <trans-unit id="fda527468e7c30de6308efd890e87b3a3fff811b" translate="yes" xml:space="preserve">
          <source>For ARC, a function marked with the &lt;code&gt;long_call&lt;/code&gt; attribute is always called using register-indirect jump-and-link instructions, thereby enabling the called function to be placed anywhere within the 32-bit address space. A function marked with the &lt;code&gt;medium_call&lt;/code&gt; attribute will always be close enough to be called with an unconditional branch-and-link instruction, which has a 25-bit offset from the call site. A function marked with the &lt;code&gt;short_call&lt;/code&gt; attribute will always be close enough to be called with a conditional branch-and-link instruction, which has a 21-bit offset from the call site.</source>
          <target state="translated">对于ARC，始终使用寄存器间接跳转和链接指令调用标有 &lt;code&gt;long_call&lt;/code&gt; 属性的函数，从而使被调用函数可以放置在32位地址空间内的任何位置。标记有 &lt;code&gt;medium_call&lt;/code&gt; 属性的函数将始终足够接近以使用无条件分支和链接指令进行调用，该指令与调用位置的偏移量为25位。标记有 &lt;code&gt;short_call&lt;/code&gt; 属性的函数将始终足够接近以被有条件的分支和链接指令调用，该指令与调用位置的偏移量为21位。</target>
        </trans-unit>
        <trans-unit id="6adc57b693c8942df2cd231eba32d27dd15cba72" translate="yes" xml:space="preserve">
          <source>For C and C++ source and include files, generate corresponding Ada specs. See &lt;a href=&quot;http://gcc.gnu.org/onlinedocs/gnat_ugn/Generating-Ada-Bindings-for-C-and-C_002b_002b-headers.html#Generating-Ada-Bindings-for-C-and-C_002b_002b-headers&quot;&gt;Generating Ada Bindings for C and C++ headers&lt;/a&gt; in GNAT User&amp;rsquo;s Guide, which provides detailed documentation on this feature.</source>
          <target state="translated">对于C和C ++源代码以及包含文件，请生成相应的Ada规范。请参阅&lt;a href=&quot;http://gcc.gnu.org/onlinedocs/gnat_ugn/Generating-Ada-Bindings-for-C-and-C_002b_002b-headers.html#Generating-Ada-Bindings-for-C-and-C_002b_002b-headers&quot;&gt;《&lt;/a&gt; GNAT用户指南》中的为C和C ++头生成Ada绑定，其中提供了有关此功能的详细文档。</target>
        </trans-unit>
        <trans-unit id="a54d6337d3721d977a537facc549a93425ea6c7b" translate="yes" xml:space="preserve">
          <source>For C only, warn about a &lt;code&gt;return&lt;/code&gt; statement with an expression in a function whose return type is &lt;code&gt;void&lt;/code&gt;, unless the expression type is also &lt;code&gt;void&lt;/code&gt;. As a GNU extension, the latter case is accepted without a warning unless</source>
          <target state="translated">仅对于C，警告 &lt;code&gt;return&lt;/code&gt; 语句中包含返回类型为 &lt;code&gt;void&lt;/code&gt; 的函数的表达式，除非表达式类型也为 &lt;code&gt;void&lt;/code&gt; 。作为GNU扩展，除非有警告，否则接受后一种情况，除非</target>
        </trans-unit>
        <trans-unit id="2ec28d96fea6d9177d31ee6cda12fa27a81380e2" translate="yes" xml:space="preserve">
          <source>For C++ this also warns for some cases of unnecessary parentheses in declarations, which can indicate an attempt at a function call instead of a declaration:</source>
          <target state="translated">对于C++来说,这也警告了一些声明中不必要的小括号的情况,这可能表明试图调用一个函数而不是声明。</target>
        </trans-unit>
        <trans-unit id="a1ba0033d082d3c48e09cd4d28a77031c040292c" translate="yes" xml:space="preserve">
          <source>For C++ types with non-trivial constructors and/or destructors it is impossible for the compiler to determine whether a variable of this type is truly unused if it is not referenced. This type attribute informs the compiler that variables of this type should be warned about if they appear to be unused, just like variables of fundamental types.</source>
          <target state="translated">对于具有非平凡的构造函数和/或析构函数的C++类型,如果一个类型的变量没有被引用,编译器就无法确定它是否真的未被使用。这个类型属性告诉编译器,如果这个类型的变量看起来是未使用的,就应该像基本类型的变量一样被警告。</target>
        </trans-unit>
        <trans-unit id="0ae259ea1be0c205a219871342f05ea5c73b071c" translate="yes" xml:space="preserve">
          <source>For C++, also warn for confusing overload resolution for user-defined conversions; and conversions that never use a type conversion operator: conversions to &lt;code&gt;void&lt;/code&gt;, the same type, a base class or a reference to them. Warnings about conversions between signed and unsigned integers are disabled by default in C++ unless</source>
          <target state="translated">对于C ++，还警告用户定义转换时的重载解析混乱；以及从未使用类型转换运算符的转换：转换为 &lt;code&gt;void&lt;/code&gt; ，相同类型，基类或对其的引用。除非在C ++中，否则默认禁用有关有符号和无符号整数之间转换的警告</target>
        </trans-unit>
        <trans-unit id="e062686eecb3f26c45c0833c30627154026b2d61" translate="yes" xml:space="preserve">
          <source>For C++11 and later standards, narrowing conversions are diagnosed by default, as required by the standard. A narrowing conversion from a constant produces an error, and a narrowing conversion from a non-constant produces a warning, but</source>
          <target state="translated">对于C++11及以后的标准,按照标准的要求,缺省会对窄化转换进行诊断。从一个常数进行窄化转换会产生错误,从一个非常数进行窄化转换会产生警告,但</target>
        </trans-unit>
        <trans-unit id="f97e8575f9ec69703e8c96b79759e90bcf7fbfd5" translate="yes" xml:space="preserve">
          <source>For C, overloaded functions are implemented with macros so the following does not work:</source>
          <target state="translated">对于C语言来说,重载函数是用宏来实现的,所以下面的内容不能用。</target>
        </trans-unit>
        <trans-unit id="9bcf8fa5038512fc6bcb9ac1f639a794219e10dd" translate="yes" xml:space="preserve">
          <source>For Microsoft Windows targets the use of the &lt;code&gt;dllimport&lt;/code&gt; attribute on functions is not necessary, but provides a small performance benefit by eliminating a thunk in the DLL. The use of the &lt;code&gt;dllimport&lt;/code&gt; attribute on imported variables can be avoided by passing the</source>
          <target state="translated">对于Microsoft Windows目标，不需要在函数上使用 &lt;code&gt;dllimport&lt;/code&gt; 属性，但是通过消除DLL中的重击，可以提供较小的性能优势。通过传递参数可以避免在导入的变量上使用 &lt;code&gt;dllimport&lt;/code&gt; 属性。</target>
        </trans-unit>
        <trans-unit id="9b439766be6cedb98071044e5f74180de17ccd28" translate="yes" xml:space="preserve">
          <source>For Microsoft Windows targets there are alternative methods for including the symbol in the DLL&amp;rsquo;s export table such as using a</source>
          <target state="translated">对于Microsoft Windows目标，可以使用其他方法将符号包括在DLL的导出表中，例如使用</target>
        </trans-unit>
        <trans-unit id="c0f97011eddc4db6c5d876ee996866a2e41c88d5" translate="yes" xml:space="preserve">
          <source>For Objective-C dialects, &lt;code&gt;NSString&lt;/code&gt; (or &lt;code&gt;__NSString__&lt;/code&gt;) is recognized in the same context. Declarations including these format attributes are parsed for correct syntax, however the result of checking of such format strings is not yet defined, and is not carried out by this version of the compiler.</source>
          <target state="translated">对于Objective-C方言，可以在同一上下文中识别 &lt;code&gt;NSString&lt;/code&gt; （或 &lt;code&gt;__NSString__&lt;/code&gt; ）。解析包含这些格式属性的声明以获取正确的语法，但是尚未定义此类格式字符串的检查结果，并且此版本的编译器无法执行该检查。</target>
        </trans-unit>
        <trans-unit id="7b8c007aa57d34905e4e1143a8c9e0a695e59978" translate="yes" xml:space="preserve">
          <source>For Objective-C dialects, the &lt;code&gt;format-arg&lt;/code&gt; attribute may refer to an &lt;code&gt;NSString&lt;/code&gt; reference for compatibility with the &lt;code&gt;format&lt;/code&gt; attribute above.</source>
          <target state="translated">对于Objective-C方言， &lt;code&gt;format-arg&lt;/code&gt; 属性可以引用 &lt;code&gt;NSString&lt;/code&gt; 参考以与上面的 &lt;code&gt;format&lt;/code&gt; 属性兼容。</target>
        </trans-unit>
        <trans-unit id="92a499e6d28c647e0ab66f857f55afedfae35b1a" translate="yes" xml:space="preserve">
          <source>For PMF constants (i.e. expressions of the form &amp;lsquo;</source>
          <target state="translated">对于PMF常数（即形式为'</target>
        </trans-unit>
        <trans-unit id="da58c329594be0295cc2415f6a69d9838ef88a83" translate="yes" xml:space="preserve">
          <source>For SysV/x86-64, unions with &lt;code&gt;long double&lt;/code&gt; members are passed in memory as specified in psABI. For example:</source>
          <target state="translated">对于SysV / x86-64，具有 &lt;code&gt;long double&lt;/code&gt; 精度成员的并集将按照psABI中的指定在内存中传递。例如：</target>
        </trans-unit>
        <trans-unit id="1e5082f805fe556d28e82883360f1cc9602556d6" translate="yes" xml:space="preserve">
          <source>For a branch, if it was executed at least once, then a percentage indicating the number of times the branch was taken divided by the number of times the branch was executed will be printed. Otherwise, the message &amp;ldquo;never executed&amp;rdquo; is printed.</source>
          <target state="translated">对于分支，如果执行了至少一次，则将打印一个百分比，该百分比指示分支被执行的次数除以分支被执行的次数。否则，将显示消息&amp;ldquo;从不执行&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="c55de54fa0492ae593f558830d0cb1158609d3e6" translate="yes" xml:space="preserve">
          <source>For a call, if it was executed at least once, then a percentage indicating the number of times the call returned divided by the number of times the call was executed will be printed. This will usually be 100%, but may be less for functions that call &lt;code&gt;exit&lt;/code&gt; or &lt;code&gt;longjmp&lt;/code&gt;, and thus may not return every time they are called.</source>
          <target state="translated">对于一个呼叫，如果它至少执行了一次，则将打印一个百分比，该百分比表示该呼叫返回的次数除以该呼叫执行的次数。通常为100％，但对于调用 &lt;code&gt;exit&lt;/code&gt; 或 &lt;code&gt;longjmp&lt;/code&gt; 的函数而言可能会更少，因此可能不会在每次调用它们时都返回。</target>
        </trans-unit>
        <trans-unit id="6d3a2fcd90b12dd021860d8f2094fd5bb769b990" translate="yes" xml:space="preserve">
          <source>For all builtins, &lt;code&gt;__builtin_arc_&lt;var&gt;someinsn&lt;/var&gt;&lt;/code&gt;, the header file</source>
          <target state="translated">对于所有内建文件，头文件 &lt;code&gt;__builtin_arc_&lt;var&gt;someinsn&lt;/var&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2d0b11d5fd63069d7902f804e3faa32968adf01d" translate="yes" xml:space="preserve">
          <source>For all of these except the last, the compiler automatically ignores the precompiled header if the conditions aren&amp;rsquo;t met. If you find an option combination that doesn&amp;rsquo;t work and doesn&amp;rsquo;t cause the precompiled header to be ignored, please consider filing a bug report, see &lt;a href=&quot;https://gcc.gnu.org/onlinedocs/gcc-9.2.0/gcc/Bugs.html#Bugs&quot;&gt;Bugs&lt;/a&gt;.</source>
          <target state="translated">对于除最后一项以外的所有其他条件，如果不满足条件，则编译器会自动忽略预编译的标头。如果您发现一个无效的选项组合并且不会导致忽略预编译的标头，请考虑提交错误报告，请参阅&lt;a href=&quot;https://gcc.gnu.org/onlinedocs/gcc-9.2.0/gcc/Bugs.html#Bugs&quot;&gt;错误&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="58f02a64f2f86869e0c0753651765b098a5d48fc" translate="yes" xml:space="preserve">
          <source>For an automatic (i.e. local) variable, if there exists a path from the function entry to a use of the variable that is initialized, but there exist some other paths for which the variable is not initialized, the compiler emits a warning if it cannot prove the uninitialized paths are not executed at run time.</source>
          <target state="translated">对于一个自动变量(即局部变量),如果存在一个从函数入口到使用该变量的路径是初始化的,但存在一些其他路径的变量没有初始化,编译器如果不能证明未初始化的路径在运行时没有被执行,就会发出警告。</target>
        </trans-unit>
        <trans-unit id="66413344ffac4ff8769f77f6b83c7166f806eb53" translate="yes" xml:space="preserve">
          <source>For any declared symbols matching &lt;var&gt;name&lt;/var&gt;, this does three things to that symbol: it forces the symbol to be located at the given address (a number), it forces the symbol to be volatile, and it changes the symbol&amp;rsquo;s scope to be static. This pragma exists for compatibility with other compilers, but note that the common &lt;code&gt;1234H&lt;/code&gt; numeric syntax is not supported (use &lt;code&gt;0x1234&lt;/code&gt; instead). Example:</source>
          <target state="translated">对于任何声明的与 &lt;var&gt;name&lt;/var&gt; 匹配的符号，它对该符号执行三件事：强制该符号位于给定的地址（数字）上，强制该符号易变，并且将符号的范围更改为静态。存在该 &lt;code&gt;1234H&lt;/code&gt; 注是为了与其他编译器兼容，但请注意，不支持常见的1234H数字语法（请改用 &lt;code&gt;0x1234&lt;/code&gt; ）。例：</target>
        </trans-unit>
        <trans-unit id="a150049db7b708562952c9c177d8b88f32edb151" translate="yes" xml:space="preserve">
          <source>For any given input file, the file name suffix determines what kind of compilation is done:</source>
          <target state="translated">对于任何给定的输入文件,文件名后缀决定了编译的种类。</target>
        </trans-unit>
        <trans-unit id="07d18512cc77ea85f9b39807bf636696e007c1f0" translate="yes" xml:space="preserve">
          <source>For any input register that is implicitly popped by an &lt;code&gt;asm&lt;/code&gt;, it is necessary to know how to adjust the stack to compensate for the pop. If any non-popped input is closer to the top of the reg-stack than the implicitly popped register, it would not be possible to know what the stack looked like&amp;mdash;it&amp;rsquo;s not clear how the rest of the stack &amp;ldquo;slides up&amp;rdquo;.</source>
          <target state="translated">对于由 &lt;code&gt;asm&lt;/code&gt; 隐式弹出的任何输入寄存器，有必要知道如何调整堆栈以补偿弹出。如果有任何未弹出的输入比隐式弹出的寄存器更靠近reg-stack的顶部，则不可能知道堆栈是什么样子&amp;mdash;尚不清楚其余堆栈如何&amp;ldquo;向上滑动&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="f70c821669087836df1b08a79652756521c81032" translate="yes" xml:space="preserve">
          <source>For basic &lt;code&gt;asm&lt;/code&gt; with non-empty assembler string GCC assumes the assembler block does not change any general purpose registers, but it may read or write any globally accessible variable.</source>
          <target state="translated">对于具有非空汇编程序字符串的基本 &lt;code&gt;asm&lt;/code&gt; ，GCC假定汇编程序块不会更改任何通用寄存器，但可以读取或写入任何全局可访问变量。</target>
        </trans-unit>
        <trans-unit id="5e325c0c804529598de8767ff4c99ad5a3e91e4a" translate="yes" xml:space="preserve">
          <source>For compatibility with Microsoft Windows compilers, GCC supports &amp;lsquo;</source>
          <target state="translated">为了与Microsoft Windows编译器兼容，GCC支持&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="2e68646242b9dd84443ad785c99336fb66a4c416" translate="yes" xml:space="preserve">
          <source>For compatibility with Microsoft Windows compilers, GCC supports a set of &lt;code&gt;#pragma&lt;/code&gt; directives that change the maximum alignment of members of structures (other than zero-width bit-fields), unions, and classes subsequently defined. The &lt;var&gt;n&lt;/var&gt; value below always is required to be a small power of two and specifies the new alignment in bytes.</source>
          <target state="translated">为了与Microsoft Windows编译器兼容，GCC支持一组 &lt;code&gt;#pragma&lt;/code&gt; 指令，这些指令可更改结构成员（零宽度位域除外），并集和随后定义的类的最大对齐方式。始终要求下面的 &lt;var&gt;n&lt;/var&gt; 值为2的小数幂，并以字节为单位指定新的对齐方式。</target>
        </trans-unit>
        <trans-unit id="2922cd58b39e0ff05824f3d77b79c0fe7423d78f" translate="yes" xml:space="preserve">
          <source>For compatibility with SVR4, GCC supports a set of &lt;code&gt;#pragma&lt;/code&gt; directives for declaring symbols to be weak, and defining weak aliases.</source>
          <target state="translated">为了与SVR4兼容，GCC支持一组 &lt;code&gt;#pragma&lt;/code&gt; 指令，用于将符号声明为弱，并定义弱别名。</target>
        </trans-unit>
        <trans-unit id="47783006d3b2d24697c7b14be6b4ca265bdb02d0" translate="yes" xml:space="preserve">
          <source>For compatibility with existing code written for compiler versions that did not implement attributes on nested declarators, some laxity is allowed in the placing of attributes. If an attribute that only applies to types is applied to a declaration, it is treated as applying to the type of that declaration. If an attribute that only applies to declarations is applied to the type of a declaration, it is treated as applying to that declaration; and, for compatibility with code placing the attributes immediately before the identifier declared, such an attribute applied to a function return type is treated as applying to the function type, and such an attribute applied to an array element type is treated as applying to the array type. If an attribute that only applies to function types is applied to a pointer-to-function type, it is treated as applying to the pointer target type; if such an attribute is applied to a function return type that is not a pointer-to-function type, it is treated as applying to the function type.</source>
          <target state="translated">为了兼容为编译器版本编写的现有代码,这些编译器没有在嵌套的声明器上实现属性,在属性的放置上允许有一些宽松。如果一个只适用于类型的属性被应用于一个声明,那么它将被视为应用于该声明的类型。如果一个只适用于声明的属性被应用于声明的类型,那么它被视为应用于该声明;而且,为了与紧接在声明的标识符之前放置属性的代码相兼容,这样一个应用于函数返回类型的属性被视为应用于函数类型,这样一个应用于数组元素类型的属性被视为应用于数组类型。如果一个只适用于函数类型的属性被应用于指针到函数类型,则被视为应用于指针目标类型;如果这样的属性被应用于不是指针到函数类型的函数返回类型,则被视为应用于函数类型。</target>
        </trans-unit>
        <trans-unit id="55c454a21201bdfc3a9a886c367d99786c9c4842" translate="yes" xml:space="preserve">
          <source>For compatibility, it&amp;rsquo;s always newlib for elf now.</source>
          <target state="translated">为了兼容性，它现在始终是elf的newlib。</target>
        </trans-unit>
        <trans-unit id="4859bddb1e6f097bf4875ee4cd32afb8f33d13e6" translate="yes" xml:space="preserve">
          <source>For convenience, it is allowed to use a binary vector operation where one operand is a scalar. In that case the compiler transforms the scalar operand into a vector where each element is the scalar from the operation. The transformation happens only if the scalar could be safely converted to the vector-element type. Consider the following code.</source>
          <target state="translated">为了方便起见,允许使用二进制向量操作,其中一个操作数是一个标量。在这种情况下,编译器会将标量操作数转换为一个向量,其中每个元素都是操作数的标量。只有当标量可以安全地转换为向量元素类型时,才会发生这种转换。考虑以下代码。</target>
        </trans-unit>
        <trans-unit id="3d923f6f173753b3c978292a218e04d22288b211" translate="yes" xml:space="preserve">
          <source>For conversion to a type of width &lt;em&gt;N&lt;/em&gt;, the value is reduced modulo &lt;em&gt;2^N&lt;/em&gt; to be within range of the type; no signal is raised.</source>
          <target state="translated">为了转换为宽度&lt;em&gt;N&lt;/em&gt;的类型，将值模&lt;em&gt;2 ^ N&lt;/em&gt;减小到该类型的范围内；没有信号发出。</target>
        </trans-unit>
        <trans-unit id="3216191fb385483c1e97afafeea464af935a4944" translate="yes" xml:space="preserve">
          <source>For devices not in &lt;code&gt;avrtiny&lt;/code&gt; or &lt;code&gt;avrxmega3&lt;/code&gt;, any data including read-only data is located in RAM (the generic address space) because flash memory is not visible in the RAM address space. In order to locate read-only data in flash memory &lt;em&gt;and&lt;/em&gt; to generate the right instructions to access this data without using (inline) assembler code, special address spaces are needed.</source>
          <target state="translated">对于不在 &lt;code&gt;avrtiny&lt;/code&gt; 或 &lt;code&gt;avrxmega3&lt;/code&gt; 中的设备，包括只读数据在内的任何数据都位于RAM（通用地址空间）中，因为闪存在RAM地址空间中不可见。为了在闪存中定位只读数据&lt;em&gt;并&lt;/em&gt;生成正确的指令以访问该数据而无需使用（内联）汇编代码，需要特殊的地址空间。</target>
        </trans-unit>
        <trans-unit id="0733ee9be6e082cc123e5464c02486573ae7f9cd" translate="yes" xml:space="preserve">
          <source>For documentation of &lt;code&gt;altivec&lt;/code&gt; attribute please see the documentation in &lt;a href=&quot;type-attributes#PowerPC-Type-Attributes&quot;&gt;PowerPC Type Attributes&lt;/a&gt;.</source>
          <target state="translated">有关 &lt;code&gt;altivec&lt;/code&gt; 属性的文档，请参阅&lt;a href=&quot;type-attributes#PowerPC-Type-Attributes&quot;&gt;PowerPC类型属性中&lt;/a&gt;的文档。</target>
        </trans-unit>
        <trans-unit id="eb3f33ef599bbcb991ed9de189514be3fb2765a7" translate="yes" xml:space="preserve">
          <source>For each Objective-C class, check if any of its instance variables is a C++ object with a non-trivial default constructor. If so, synthesize a special &lt;code&gt;- (id) .cxx_construct&lt;/code&gt; instance method which runs non-trivial default constructors on any such instance variables, in order, and then return &lt;code&gt;self&lt;/code&gt;. Similarly, check if any instance variable is a C++ object with a non-trivial destructor, and if so, synthesize a special &lt;code&gt;- (void) .cxx_destruct&lt;/code&gt; method which runs all such default destructors, in reverse order.</source>
          <target state="translated">对于每个Objective-C类，请检查其任何实例变量是否是带有非平凡默认构造函数的C ++对象。如果是这样，请合成一个特殊的 &lt;code&gt;- (id) .cxx_construct&lt;/code&gt; 实例方法，该方法对任何此类实例变量按顺序运行非平凡的默认构造函数，然后返回 &lt;code&gt;self&lt;/code&gt; 。同样，检查任何实例变量是否是带有非平凡析构函数的C ++对象，如果是，则合成一个特殊的 &lt;code&gt;- (void) .cxx_destruct&lt;/code&gt; 方法，该方法以相反的顺序运行所有此类默认析构函数。</target>
        </trans-unit>
        <trans-unit id="ecabcf6fb487210c3e414abe28454af79991a5a8" translate="yes" xml:space="preserve">
          <source>For each basic block, a line is printed after the last line of the basic block describing the branch or call that ends the basic block. There can be multiple branches and calls listed for a single source line if there are multiple basic blocks that end on that line. In this case, the branches and calls are each given a number. There is no simple way to map these branches and calls back to source constructs. In general, though, the lowest numbered branch or call will correspond to the leftmost construct on the source line.</source>
          <target state="translated">对于每个基本块,在基本块的最后一行之后打印一行,描述结束基本块的分支或调用。如果有多个基本块在一条源线上结束,那么可以为该线列出多个分支和调用。在这种情况下,分支和调用都被赋予一个编号。没有简单的方法可以将这些分支和调用映射回源构造。但一般来说,编号最低的分支或调用将对应于源行上最左边的构造。</target>
        </trans-unit>
        <trans-unit id="7d57dddd1f25be9ff5b83775303a0d6d59fce852" translate="yes" xml:space="preserve">
          <source>For each built-in function for AVR, there is an equally named, uppercase built-in macro defined. That way users can easily query if or if not a specific built-in is implemented or not. For example, if &lt;code&gt;__builtin_avr_nop&lt;/code&gt; is available the macro &lt;code&gt;__BUILTIN_AVR_NOP&lt;/code&gt; is defined to &lt;code&gt;1&lt;/code&gt; and undefined otherwise.</source>
          <target state="translated">对于AVR的每个内置函数，都定义了一个同名的大写内置宏。这样，用户可以轻松查询是否实现了特定的内置程序。例如，如果 &lt;code&gt;__builtin_avr_nop&lt;/code&gt; 可用，则宏 &lt;code&gt;__BUILTIN_AVR_NOP&lt;/code&gt; 定义为 &lt;code&gt;1&lt;/code&gt; ，否则未定义。</target>
        </trans-unit>
        <trans-unit id="d11a6b019eb02c22d6e7924e271f0d952fce8600" translate="yes" xml:space="preserve">
          <source>For each function, a line is printed showing how many times the function is called, how many times it returns and what percentage of the function&amp;rsquo;s blocks were executed.</source>
          <target state="translated">对于每个函数，将打印一行以显示该函数被调用了多少次，返回了多少次以及执行了多少百分比的功能块。</target>
        </trans-unit>
        <trans-unit id="4bcb841b4282f8986587d3e6966d3ed8c8dbe585" translate="yes" xml:space="preserve">
          <source>For each language compiled by GCC for which there is a standard, GCC attempts to follow one or more versions of that standard, possibly with some exceptions, and possibly with some extensions.</source>
          <target state="translated">对于GCC编译的每一种有标准的语言,GCC都试图遵循该标准的一个或多个版本,可能有一些例外,也可能有一些扩展。</target>
        </trans-unit>
        <trans-unit id="454897cc2fe9ad183bab2f7040fb6e5f25d9835d" translate="yes" xml:space="preserve">
          <source>For each named address space supported by avr-gcc there is an equally named but uppercase built-in macro defined. The purpose is to facilitate testing if respective address space support is available or not:</source>
          <target state="translated">对于avr-gcc支持的每个命名的地址空间,都定义了一个同样命名但大写的内置宏。这样做的目的是为了方便测试各个地址空间是否支持。</target>
        </trans-unit>
        <trans-unit id="a3f4882138b251f321ad16e203354e1a8d314d76" translate="yes" xml:space="preserve">
          <source>For each of the other indicated dump files (</source>
          <target state="translated">对于其他每个指定的转储文件(</target>
        </trans-unit>
        <trans-unit id="52f8ea439a283b5dc96c21715d0fefc3004bcf28" translate="yes" xml:space="preserve">
          <source>For each subprogram to be run, the compiler driver first tries the</source>
          <target state="translated">对于每个要运行的子程序,编译器驱动程序首先会尝试使用</target>
        </trans-unit>
        <trans-unit id="fdc4fc8f69b51e6f564843d4ff6b4102d66402dd" translate="yes" xml:space="preserve">
          <source>For even more AVR-specific built-in macros see &lt;a href=&quot;named-address-spaces#AVR-Named-Address-Spaces&quot;&gt;AVR Named Address Spaces&lt;/a&gt; and &lt;a href=&quot;avr-built_002din-functions#AVR-Built_002din-Functions&quot;&gt;AVR Built-in Functions&lt;/a&gt;.</source>
          <target state="translated">有关更多特定于AVR的内置宏，请参见&lt;a href=&quot;named-address-spaces#AVR-Named-Address-Spaces&quot;&gt;AVR命名地址空间&lt;/a&gt;和&lt;a href=&quot;avr-built_002din-functions#AVR-Built_002din-Functions&quot;&gt;AVR内置函数&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1baa0cc1603bf61303a12aa930a0094973d11cab" translate="yes" xml:space="preserve">
          <source>For example in the structure below, the member array &lt;code&gt;x&lt;/code&gt; is packed so that it immediately follows &lt;code&gt;a&lt;/code&gt; with no intervening padding:</source>
          <target state="translated">例如，在下面的结构中，成员数组 &lt;code&gt;x&lt;/code&gt; 被打包，因此它紧跟在 &lt;code&gt;a&lt;/code&gt; 之后，中间没有填充：</target>
        </trans-unit>
        <trans-unit id="6db6725e9e7d5c088630e348048d1e73fc7657d3" translate="yes" xml:space="preserve">
          <source>For example,</source>
          <target state="translated">例如:</target>
        </trans-unit>
        <trans-unit id="67c7bfe6911146baef42ccf95311646fa6de1225" translate="yes" xml:space="preserve">
          <source>For example, &amp;lsquo;</source>
          <target state="translated">例如， '</target>
        </trans-unit>
        <trans-unit id="f35aae572eaa511b9e1fec745e2f41aff9a397c4" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;-MT '$(objpfx)foo.o'&lt;/code&gt; might give</source>
          <target state="translated">例如， &lt;code&gt;-MT '$(objpfx)foo.o'&lt;/code&gt; 可能会给出</target>
        </trans-unit>
        <trans-unit id="687851312bf05d13456ec79c098b24da9ffe5635" translate="yes" xml:space="preserve">
          <source>For example, GCC warns about &lt;code&gt;i&lt;/code&gt; being uninitialized in the following snippet only when</source>
          <target state="translated">例如，GCC 仅在以下情况下警告 &lt;code&gt;i&lt;/code&gt; 未在以下代码段中初始化</target>
        </trans-unit>
        <trans-unit id="481bf59d3e774632a4ae291477b6e304f7e4939c" translate="yes" xml:space="preserve">
          <source>For example, a bounded case of &lt;code&gt;alloca&lt;/code&gt; could be:</source>
          <target state="translated">例如， &lt;code&gt;alloca&lt;/code&gt; 的有限情况可能是：</target>
        </trans-unit>
        <trans-unit id="b71521cff46dbe352ddadd34594ed3081919fa62" translate="yes" xml:space="preserve">
          <source>For example, a method with no arguments and returning &lt;code&gt;int&lt;/code&gt; would have the signature &lt;code&gt;i8@0:4&lt;/code&gt; if the size of a pointer is 4. The signature is interpreted as follows: the &lt;code&gt;i&lt;/code&gt; is the return type (an &lt;code&gt;int&lt;/code&gt;), the &lt;code&gt;8&lt;/code&gt; is the total size of the parameters in bytes (two pointers each of size 4), the &lt;code&gt;@0&lt;/code&gt; is the first parameter (an object at byte offset &lt;code&gt;0&lt;/code&gt;) and &lt;code&gt;:4&lt;/code&gt; is the second parameter (a &lt;code&gt;SEL&lt;/code&gt; at byte offset &lt;code&gt;4&lt;/code&gt;).</source>
          <target state="translated">例如，如果一个指针的大小为 &lt;code&gt;i8@0:4&lt;/code&gt; ，则不带参数且返回 &lt;code&gt;int&lt;/code&gt; 的方法的签名为i8 @ 0：4。签名的解释如下： &lt;code&gt;i&lt;/code&gt; 是返回类型（ &lt;code&gt;int&lt;/code&gt; ）， &lt;code&gt;8&lt;/code&gt; 是参数的总大小（以字节为单位）（两个指针，每个指针的大小均为4）， &lt;code&gt;@0&lt;/code&gt; 是第一个参数（对象在字节偏移量 &lt;code&gt;0&lt;/code&gt; 处），而 &lt;code&gt;:4&lt;/code&gt; 是第二个参数（ &lt;code&gt;SEL&lt;/code&gt; 在字节偏移量 &lt;code&gt;4&lt;/code&gt; 处）。</target>
        </trans-unit>
        <trans-unit id="68ba042328cca36e153d2c8dab7d8879565e3845" translate="yes" xml:space="preserve">
          <source>For example, a program may use a function &lt;code&gt;strfunc&lt;/code&gt; that returns &lt;code&gt;string&lt;/code&gt; objects, and another function &lt;code&gt;charfunc&lt;/code&gt; that operates on pointers to &lt;code&gt;char&lt;/code&gt;:</source>
          <target state="translated">例如，程序可以使用函数 &lt;code&gt;strfunc&lt;/code&gt; 返回 &lt;code&gt;string&lt;/code&gt; 对象，而另一个函数 &lt;code&gt;charfunc&lt;/code&gt; 对 &lt;code&gt;char&lt;/code&gt; 的指针进行操作：</target>
        </trans-unit>
        <trans-unit id="88bf56d21a567365b50f7c0d1260f3e77c253d14" translate="yes" xml:space="preserve">
          <source>For example, a spec string like this:</source>
          <target state="translated">例如,像这样的规格字符串。</target>
        </trans-unit>
        <trans-unit id="9636aa78a9470d85d5322503884f630474bbcbd8" translate="yes" xml:space="preserve">
          <source>For example, an address which is constant is offsettable; so is an address that is the sum of a register and a constant (as long as a slightly larger constant is also within the range of address-offsets supported by the machine); but an autoincrement or autodecrement address is not offsettable. More complicated indirect/indexed addresses may or may not be offsettable depending on the other addressing modes that the machine supports.</source>
          <target state="translated">例如,一个常数的地址是可以偏移的;一个寄存器和一个常数之和的地址也是可以偏移的(只要一个稍大的常数也在机器支持的地址偏移范围内);但一个自动增量或自动减量的地址是不可偏移的。更复杂的间接/索引地址可能是可偏移的,也可能是不可偏移的,这取决于机器支持的其他寻址模式。</target>
        </trans-unit>
        <trans-unit id="bb39fad998b5526c7cd037c77aee5706a45b5058" translate="yes" xml:space="preserve">
          <source>For example, by default a structure containing nothing but 8 &lt;code&gt;unsigned&lt;/code&gt; bit-fields of length 1 is aligned to a 4-byte boundary and has a size of 4 bytes. By using</source>
          <target state="translated">例如，默认情况下，仅包含8个长度为1的 &lt;code&gt;unsigned&lt;/code&gt; 位域的结构与4字节边界对齐，并且大小为4字节。通过使用</target>
        </trans-unit>
        <trans-unit id="44c92e45a35c2e3631a1416540d7623d393688e2" translate="yes" xml:space="preserve">
          <source>For example, code using the standard ISA encoding cannot jump directly to MIPS16 or microMIPS code; it must either use a call or an indirect jump.</source>
          <target state="translated">例如,使用标准ISA编码的代码不能直接跳转到MIPS16或microMIPS代码,必须使用调用或间接跳转。</target>
        </trans-unit>
        <trans-unit id="6d3c95f985f19da9d6dbc1a830c9da53b0e26416" translate="yes" xml:space="preserve">
          <source>For example, given this C source file:</source>
          <target state="translated">例如,给定这个C源文件。</target>
        </trans-unit>
        <trans-unit id="f0defbb763ebb18b66cf3162b2b446b84c5034e8" translate="yes" xml:space="preserve">
          <source>For example, if an x86 compiler supports two dialects (&amp;lsquo;</source>
          <target state="translated">例如，如果x86编译器支持两种方言（'</target>
        </trans-unit>
        <trans-unit id="9b3c7e9c23ebc44c980aef19936a5699e234861d" translate="yes" xml:space="preserve">
          <source>For example, if the object file</source>
          <target state="translated">例如,如果对象文件</target>
        </trans-unit>
        <trans-unit id="6277fc8469340ab02cc75749b9fdf00e3b3028a6" translate="yes" xml:space="preserve">
          <source>For example, if the target machine requires a &lt;code&gt;double&lt;/code&gt; value to be aligned on an 8-byte boundary, then &lt;code&gt;__alignof__ (double)&lt;/code&gt; is 8. This is true on many RISC machines. On more traditional machine designs, &lt;code&gt;__alignof__ (double)&lt;/code&gt; is 4 or even 2.</source>
          <target state="translated">例如，如果目标机器需要一个 &lt;code&gt;double&lt;/code&gt; 值到8字节的边界上对齐，然后 &lt;code&gt;__alignof__ (double)&lt;/code&gt; 为8。这是许多RISC机器真。在更传统的机器设计中， &lt;code&gt;__alignof__ (double)&lt;/code&gt; 为4甚至2。</target>
        </trans-unit>
        <trans-unit id="ace71a372dd9faf87968abc19f07a8c712084e3c" translate="yes" xml:space="preserve">
          <source>For example, in the following function the call to &lt;code&gt;g&lt;/code&gt; is unsafe because when &lt;code&gt;overalign&lt;/code&gt; is non-zero, the space allocated by &lt;code&gt;__builtin_alloca_with_align&lt;/code&gt; may have been released at the end of the &lt;code&gt;if&lt;/code&gt; statement in which it was called.</source>
          <target state="translated">例如，在以下函数中，对 &lt;code&gt;g&lt;/code&gt; 的调用是不安全的，因为当 &lt;code&gt;overalign&lt;/code&gt; 不为零时，由 &lt;code&gt;__builtin_alloca_with_align&lt;/code&gt; 分配的空间可能已在其被调用的 &lt;code&gt;if&lt;/code&gt; 语句的末尾释放。</target>
        </trans-unit>
        <trans-unit id="b982bcc761519bf794d14c5f76ed85a5c03967e1" translate="yes" xml:space="preserve">
          <source>For example, in the following, each call to function &lt;code&gt;foo&lt;/code&gt; will print a line similar to &lt;code&gt;&quot;file.c:123: foo: message&quot;&lt;/code&gt; with the name of the file and the line number of the &lt;code&gt;printf&lt;/code&gt; call, the name of the function &lt;code&gt;foo&lt;/code&gt;, followed by the word &lt;code&gt;message&lt;/code&gt;.</source>
          <target state="translated">例如，在下面的代码中，每次对函数 &lt;code&gt;foo&lt;/code&gt; 的调用都将打印类似于 &lt;code&gt;&quot;file.c:123: foo: message&quot;&lt;/code&gt; 的行，并带有文件名和 &lt;code&gt;printf&lt;/code&gt; 调用的行号，即函数 &lt;code&gt;foo&lt;/code&gt; 的名称，然后是 &lt;code&gt;message&lt;/code&gt; 一词。</target>
        </trans-unit>
        <trans-unit id="55f28e4d67f6e114f470b97bac400ac0e25f6328" translate="yes" xml:space="preserve">
          <source>For example, on the 68000 in a fullword instruction it is possible to use an immediate operand; but if the immediate value is between -128 and 127, better code results from loading the value into a register and using the register. This is because the load into the register can be done with a &amp;lsquo;</source>
          <target state="translated">例如，在68000的全字指令中，可以使用立即数操作数。但是如果立即数在-128到127之间，则将值加载到寄存器中并使用该寄存器会产生更好的代码。这是因为可以通过'</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
