<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="gcc">
    <body>
      <group id="gcc">
        <trans-unit id="31ab20eab881b18de841e0f744838f8d79533911" translate="yes" xml:space="preserve">
          <source>On System V.4 and embedded PowerPC systems, specify that you are compiling for a VxWorks system.</source>
          <target state="translated">在系统V.4和嵌入式PowerPC系统上,请指定您正在为VxWorks系统编译。</target>
        </trans-unit>
        <trans-unit id="3b7c9e8fe9be90e5b1711df0aa43109dbeeee519" translate="yes" xml:space="preserve">
          <source>On a PowerPC, you can compile a function with &lt;code&gt;target_clones(&quot;cpu=power9,default&quot;)&lt;/code&gt;. GCC will create two function clones, one compiled with</source>
          <target state="translated">在PowerPC上，可以使用 &lt;code&gt;target_clones(&quot;cpu=power9,default&quot;)&lt;/code&gt; 编译函数。GCC将创建两个函数克隆，其中一个使用</target>
        </trans-unit>
        <trans-unit id="2b6207218221cf5a21cb4ce70228ebd866adf3c7" translate="yes" xml:space="preserve">
          <source>On a SPARC, GCC aligns all values of type &lt;code&gt;double&lt;/code&gt; on an 8-byte boundary, and it expects every &lt;code&gt;double&lt;/code&gt; to be so aligned. The Sun compiler usually gives &lt;code&gt;double&lt;/code&gt; values 8-byte alignment, with one exception: function arguments of type &lt;code&gt;double&lt;/code&gt; may not be aligned.</source>
          <target state="translated">在SPARC上，GCC 在8字节边界上对齐所有 &lt;code&gt;double&lt;/code&gt; 类型的值，并且期望每个 &lt;code&gt;double&lt;/code&gt; 都这样对齐。Sun编译器通常提供 &lt;code&gt;double&lt;/code&gt; 值8字节对齐，但有一个例外： &lt;code&gt;double&lt;/code&gt; 类型的函数参数可能未对齐。</target>
        </trans-unit>
        <trans-unit id="c54d5e9842efa1190de832e68ceeddd07e1b57ec" translate="yes" xml:space="preserve">
          <source>On embedded PowerPC systems, assume that the startup module is called</source>
          <target state="translated">在嵌入式PowerPC系统中,假设启动模块称为</target>
        </trans-unit>
        <trans-unit id="8b133920834ad968fd5e3ad90be374421844ec08" translate="yes" xml:space="preserve">
          <source>On embedded PowerPC systems, put all initialized global and static data in the &lt;code&gt;.data&lt;/code&gt; section, and all uninitialized data in the &lt;code&gt;.bss&lt;/code&gt; section.</source>
          <target state="translated">在嵌入式PowerPC系统上，将所有初始化的全局和静态数据放在 &lt;code&gt;.data&lt;/code&gt; 节中，并将所有未初始化的数据放在 &lt;code&gt;.bss&lt;/code&gt; 节中。</target>
        </trans-unit>
        <trans-unit id="956164ada36cee4efdb76678bae728426fa21ad6" translate="yes" xml:space="preserve">
          <source>On embedded PowerPC systems, put global and static items less than or equal to &lt;var&gt;num&lt;/var&gt; bytes into the small data or BSS sections instead of the normal data or BSS section. By default, &lt;var&gt;num&lt;/var&gt; is 8. The</source>
          <target state="translated">在嵌入式PowerPC系统上，将小于或等于 &lt;var&gt;num&lt;/var&gt; 字节的全局项和静态项放入小数据或BSS节中，而不是普通数据或BSS节中。缺省情况下， &lt;var&gt;num&lt;/var&gt; 为8。</target>
        </trans-unit>
        <trans-unit id="12a413b7674df08ad1aab1d7a97049457f7c4105" translate="yes" xml:space="preserve">
          <source>On embedded PowerPC systems, set the &lt;code&gt;PPC_EMB&lt;/code&gt; bit in the ELF flags header to indicate that &amp;lsquo;</source>
          <target state="translated">在嵌入式PowerPC系统上，将ELF标志标头中的 &lt;code&gt;PPC_EMB&lt;/code&gt; 位置1表示&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="276196a98c13434d4d4c303d9ed47e653a63a0a3" translate="yes" xml:space="preserve">
          <source>On machines where a function returns floating-point results in the 80387 register stack, some floating-point opcodes may be emitted even if</source>
          <target state="translated">在函数在80387寄存器堆栈中返回浮点结果的机器上,一些浮点运算代码可能会被发出,即使是在</target>
        </trans-unit>
        <trans-unit id="765fd445f5f79a3b6c1bf65d331a2ab62d7c09c3" translate="yes" xml:space="preserve">
          <source>On machines with register windows, be sure to choose a global register that is not affected magically by the function call mechanism.</source>
          <target state="translated">在有寄存器窗口的机器上,一定要选择不受函数调用机制神奇影响的全局寄存器。</target>
        </trans-unit>
        <trans-unit id="baf0367d5874a0c5c72bd2d02e6ad6a8602da5fb" translate="yes" xml:space="preserve">
          <source>On many platforms, GCC supports a different ABI for C++ than do other compilers, so the object files compiled by GCC cannot be used with object files generated by another C++ compiler.</source>
          <target state="translated">在许多平台上,GCC支持的C++的ABI与其他编译器不同,所以GCC编译的对象文件不能与其他C++编译器生成的对象文件一起使用。</target>
        </trans-unit>
        <trans-unit id="4d7c2fb9e12e897dbce329dee3a106daf06850a0" translate="yes" xml:space="preserve">
          <source>On most machines, &lt;code&gt;longjmp&lt;/code&gt; restores to each global register variable the value it had at the time of the &lt;code&gt;setjmp&lt;/code&gt;. On some machines, however, &lt;code&gt;longjmp&lt;/code&gt; does not change the value of global register variables. To be portable, the function that called &lt;code&gt;setjmp&lt;/code&gt; should make other arrangements to save the values of the global register variables, and to restore them in a &lt;code&gt;longjmp&lt;/code&gt;. This way, the same thing happens regardless of what &lt;code&gt;longjmp&lt;/code&gt; does.</source>
          <target state="translated">在大多数计算机上， &lt;code&gt;longjmp&lt;/code&gt; 将其在 &lt;code&gt;setjmp&lt;/code&gt; 时的值恢复到每个全局寄存器变量。但是，在某些计算机上， &lt;code&gt;longjmp&lt;/code&gt; 不会更改全局寄存器变量的值。为了便于移植，调用 &lt;code&gt;setjmp&lt;/code&gt; 的函数应进行其他安排以保存全局寄存器变量的值，并将其恢复为 &lt;code&gt;longjmp&lt;/code&gt; 。这样，无论 &lt;code&gt;longjmp&lt;/code&gt; 做什么，都会发生相同的事情。</target>
        </trans-unit>
        <trans-unit id="61f4155d039689baf9c247b710861ebab661061d" translate="yes" xml:space="preserve">
          <source>On most systems that use stabs format,</source>
          <target state="translated">在大多数使用stabs格式的系统上。</target>
        </trans-unit>
        <trans-unit id="164e2d1cdab76253173fd67017576978f44922c1" translate="yes" xml:space="preserve">
          <source>On some BSD systems, including some versions of Ultrix, use of profiling causes static variable destructors (currently used only in C++) not to be run.</source>
          <target state="translated">在某些BSD系统上,包括某些版本的Ultrix,使用profiling会导致静态变量析构器(目前只在C++中使用)不被运行。</target>
        </trans-unit>
        <trans-unit id="63572090afdc3d5b19c4bea28a32908c6254289e" translate="yes" xml:space="preserve">
          <source>On some machines it may be impossible to determine the frame address of any function other than the current one; in such cases, or when the top of the stack has been reached, this function returns &lt;code&gt;0&lt;/code&gt; if the first frame pointer is properly initialized by the startup code.</source>
          <target state="translated">在某些机器上，可能无法确定除当前功能以外的任何功能的帧地址。在这种情况下，或者到达栈顶时，如果启动代码正确初始化了第一个帧指针，则此函数返回 &lt;code&gt;0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c1c8ec9b26e1e50270902a24206b23748281f80a" translate="yes" xml:space="preserve">
          <source>On some machines it may be impossible to determine the return address of any function other than the current one; in such cases, or when the top of the stack has been reached, this function returns &lt;code&gt;0&lt;/code&gt; or a random value. In addition, &lt;code&gt;__builtin_frame_address&lt;/code&gt; may be used to determine if the top of the stack has been reached.</source>
          <target state="translated">在某些机器上，可能无法确定除当前函数以外的任何函数的返回地址。在这种情况下，或者到达栈顶时，此函数返回 &lt;code&gt;0&lt;/code&gt; 或随机值。另外， &lt;code&gt;__builtin_frame_address&lt;/code&gt; 可用于确定是否已到达栈顶。</target>
        </trans-unit>
        <trans-unit id="1ef53bfa27577d13d6b983892ac610f1cbdddec9" translate="yes" xml:space="preserve">
          <source>On some machines it may be impossible to determine the return address of any function other than the current one; in such cases, or when the top of the stack has been reached, this function returns an unspecified value. In addition, &lt;code&gt;__builtin_frame_address&lt;/code&gt; may be used to determine if the top of the stack has been reached.</source>
          <target state="translated">在某些机器上，可能无法确定除当前函数以外的任何函数的返回地址。在这种情况下，或者到达栈顶时，此函数返回一个未指定的值。另外， &lt;code&gt;__builtin_frame_address&lt;/code&gt; 可用于确定是否已到达栈顶。</target>
        </trans-unit>
        <trans-unit id="9459429806b19bedbc3812fd4e4235d2169468c6" translate="yes" xml:space="preserve">
          <source>On some newer machines, PCC uses a reentrant convention for all structure and union returning. GCC on most of these machines uses a compatible convention when returning structures and unions in memory, but still returns small structures and unions in registers.</source>
          <target state="translated">在一些较新的机器上,PCC对所有结构体和联合体的返回都使用重入约定。在大多数这些机器上,GCC在返回内存中的结构体和联合体时,使用兼容的约定,但仍然返回寄存器中的小结构体和联合体。</target>
        </trans-unit>
        <trans-unit id="e7a00be8ad71da46c5174d313f9a640c4604077b" translate="yes" xml:space="preserve">
          <source>On some processors, like Intel Atom, 8-bit unsigned integer divide is much faster than 32-bit/64-bit integer divide. This option generates a run-time check. If both dividend and divisor are within range of 0 to 255, 8-bit unsigned integer divide is used instead of 32-bit/64-bit integer divide.</source>
          <target state="translated">在某些处理器上,比如Intel Atom,8位无符号整数除法比32位/64位整数除法快得多。这个选项会产生一个运行时检查。如果除数和除数都在0到255的范围内,则使用8位无符号整数除法代替32位/64位整数除法。</target>
        </trans-unit>
        <trans-unit id="962c05222fdb4b91f96523bd87b84e3ad46c65d1" translate="yes" xml:space="preserve">
          <source>On some rare x86 targets, &lt;code&gt;setjmp&lt;/code&gt; doesn&amp;rsquo;t save the registers in all circumstances. In those cases, GCC doesn&amp;rsquo;t allocate any variables in registers unless they are marked &lt;code&gt;register&lt;/code&gt;.</source>
          <target state="translated">在一些罕见的x86目标上， &lt;code&gt;setjmp&lt;/code&gt; 不会在所有情况下都保存寄存器。在这些情况下，除非将GCC标记为 &lt;code&gt;register&lt;/code&gt; ,否则它们不会在寄存器中分配任何变量。</target>
        </trans-unit>
        <trans-unit id="50b8a98a7845b95d4eb0c4bf2a96f13e10a0e926" translate="yes" xml:space="preserve">
          <source>On some systems, &amp;lsquo;</source>
          <target state="translated">在某些系统上，</target>
        </trans-unit>
        <trans-unit id="18b57ea0d71c60c160b6870aa792c110927a6a2b" translate="yes" xml:space="preserve">
          <source>On some systems, header file directories contain machine-specific symbolic links in certain places. This makes it possible to share most of the header files among hosts running the same version of the system on different machine models.</source>
          <target state="translated">在某些系统中,头文件目录在某些地方包含了特定机器的符号链接。这样就可以在不同机器型号上运行同一版本系统的主机之间共享大部分头文件。</target>
        </trans-unit>
        <trans-unit id="5afa05ee4c2834411c301dd21c9dd367b2afc2a4" translate="yes" xml:space="preserve">
          <source>On some target machines, GCC supports many built-in functions specific to those machines. Generally these generate calls to specific machine instructions, but allow the compiler to schedule those calls.</source>
          <target state="translated">在一些目标机器上,GCC支持许多针对这些机器的内置函数。一般来说,这些函数会产生对特定机器指令的调用,但允许编译器调度这些调用。</target>
        </trans-unit>
        <trans-unit id="98a0b32bda81ede1cd6faa721c95ce64fb072f42" translate="yes" xml:space="preserve">
          <source>On some targets the attributes also accept an integer argument to specify a priority to control the order in which constructor and destructor functions are run. A constructor with a smaller priority number runs before a constructor with a larger priority number; the opposite relationship holds for destructors. So, if you have a constructor that allocates a resource and a destructor that deallocates the same resource, both functions typically have the same priority. The priorities for constructor and destructor functions are the same as those specified for namespace-scope C++ objects (see &lt;a href=&quot;c_002b_002b-attributes#C_002b_002b-Attributes&quot;&gt;C++ Attributes&lt;/a&gt;). However, at present, the order in which constructors for C++ objects with static storage duration and functions decorated with attribute &lt;code&gt;constructor&lt;/code&gt; are invoked is unspecified. In mixed declarations, attribute &lt;code&gt;init_priority&lt;/code&gt; can be used to impose a specific ordering.</source>
          <target state="translated">在某些目标上，这些属性还接受一个整数参数来指定优先级，以控制构造函数和析构函数运行的顺序。优先级编号较小的构造函数在优先级编号较大的构造函数之前运行；相反的关系适用于破坏者。因此，如果您有一个分配资源的构造函数和一个释放相同资源的析构函数，则两个函数通常具有相同的优先级。构造函数和析构函数的优先级与为命名空间范围的C ++对象指定的优先级相同（请参见&lt;a href=&quot;c_002b_002b-attributes#C_002b_002b-Attributes&quot;&gt;C ++ Attributes&lt;/a&gt;）。但是，目前，具有静态存储持续时间的C ++对象的 &lt;code&gt;constructor&lt;/code&gt; 函数和用属性构造函数修饰的函数的构造顺序未指定被调用。在混合声明中，属性 &lt;code&gt;init_priority&lt;/code&gt; 可用于施加特定顺序。</target>
        </trans-unit>
        <trans-unit id="788803b9b10d0e01cda4976ecfb5c895ad7a5b3a" translate="yes" xml:space="preserve">
          <source>On some targets this flag has no effect because the standard calling sequence always uses a frame pointer, so it cannot be omitted.</source>
          <target state="translated">在某些目标上,这个标志没有效果,因为标准调用序列总是使用帧指针,所以不能省略。</target>
        </trans-unit>
        <trans-unit id="c64fcda505cd363eeb7c02acd97bfcddc4bbd34d" translate="yes" xml:space="preserve">
          <source>On some targets,</source>
          <target state="translated">在一些目标上:</target>
        </trans-unit>
        <trans-unit id="69a2029b429c1edce694be8a2285d9fe96168834" translate="yes" xml:space="preserve">
          <source>On some targets, a special form of output operand exists by which conditions in the flags register may be outputs of the asm. The set of conditions supported are target specific, but the general rule is that the output variable must be a scalar integer, and the value is boolean. When supported, the target defines the preprocessor symbol &lt;code&gt;__GCC_ASM_FLAG_OUTPUTS__&lt;/code&gt;.</source>
          <target state="translated">在某些目标上，存在一种特殊形式的输出操作数，通过这种形式，标志寄存器中的条件可以是asm的输出。支持的条件集是特定于目标的，但是一般规则是输出变量必须为标量整数，并且值为布尔值。当受支持时，目标定义预处理器符号 &lt;code&gt;__GCC_ASM_FLAG_OUTPUTS__&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="15856f8aeb189d03f7962b7a088a8da27e3b7698" translate="yes" xml:space="preserve">
          <source>On some targets, the instruction set contains SIMD vector instructions which operate on multiple values contained in one large register at the same time. For example, on the x86 the MMX, 3DNow! and SSE extensions can be used this way.</source>
          <target state="translated">在某些目标上,指令集包含SIMD向量指令,可同时对一个大寄存器中包含的多个值进行操作。例如,在x86上,MMX、3DNow!和SSE扩展可以这样使用。</target>
        </trans-unit>
        <trans-unit id="f61759f6ed3890f04c249dd91cb9dd263d93f566" translate="yes" xml:space="preserve">
          <source>On systems that provide</source>
          <target state="translated">关于系统,提供</target>
        </trans-unit>
        <trans-unit id="3224a581ef3e35f60ddcaea7c51bc1eb2a15bb26" translate="yes" xml:space="preserve">
          <source>On systems that support dynamic linking, this overrides</source>
          <target state="translated">在支持动态链接的系统中,这将取代</target>
        </trans-unit>
        <trans-unit id="40c0cbf9ca562d8813acfb29f55f0f2638a9538b" translate="yes" xml:space="preserve">
          <source>On systems that support the &lt;code&gt;visibility&lt;/code&gt; attribute, this attribute also implies &amp;ldquo;default&amp;rdquo; visibility. It is an error to explicitly specify any other visibility.</source>
          <target state="translated">在支持 &lt;code&gt;visibility&lt;/code&gt; 属性的系统上，此属性还暗含&amp;ldquo;默认&amp;rdquo;可见性。明确指定任何其他可见性是错误的。</target>
        </trans-unit>
        <trans-unit id="0b5a32b9b4c00b5336f23962d28d21f5785c04c6" translate="yes" xml:space="preserve">
          <source>On systems where an underscore is normally prepended to the name of a C variable, this feature allows you to define names for the linker that do not start with an underscore.</source>
          <target state="translated">在系统中,一个C变量的名称前通常会有下划线,这个特性允许你为链接器定义不以下划线开头的名称。</target>
        </trans-unit>
        <trans-unit id="212542d3f9bd9c37cf41fc83c6e569604a10e8a0" translate="yes" xml:space="preserve">
          <source>On systems with recent GNU assembler and C library, the C++ compiler uses the &lt;code&gt;STB_GNU_UNIQUE&lt;/code&gt; binding to make sure that definitions of template static data members and static local variables in inline functions are unique even in the presence of &lt;code&gt;RTLD_LOCAL&lt;/code&gt;; this is necessary to avoid problems with a library used by two different &lt;code&gt;RTLD_LOCAL&lt;/code&gt; plugins depending on a definition in one of them and therefore disagreeing with the other one about the binding of the symbol. But this causes &lt;code&gt;dlclose&lt;/code&gt; to be ignored for affected DSOs; if your program relies on reinitialization of a DSO via &lt;code&gt;dlclose&lt;/code&gt; and &lt;code&gt;dlopen&lt;/code&gt;, you can use</source>
          <target state="translated">在具有最新GNU汇编器和C库的系统上，C ++编译器使用 &lt;code&gt;STB_GNU_UNIQUE&lt;/code&gt; 绑定来确保即使在存在 &lt;code&gt;RTLD_LOCAL&lt;/code&gt; 的情况下，内联函数中模板静态数据成员和静态局部变量的定义也是唯一的；为了避免两个不同的 &lt;code&gt;RTLD_LOCAL&lt;/code&gt; 插件使用一个库而出现问题，这取决于其中一个的定义，因此对于另一个关于符号绑定的观点存在分歧，这是必要的。但是，这会使受影响的DSO忽略 &lt;code&gt;dlclose&lt;/code&gt; 。如果您的程序依赖于通过 &lt;code&gt;dlclose&lt;/code&gt; 和 &lt;code&gt;dlopen&lt;/code&gt; 重新初始化DSO ，则可以使用</target>
        </trans-unit>
        <trans-unit id="425eb623da59637995768118b04879b74012b572" translate="yes" xml:space="preserve">
          <source>On targets such as x86 that support multiple assembler dialects, all basic &lt;code&gt;asm&lt;/code&gt; blocks use the assembler dialect specified by the</source>
          <target state="translated">在支持多种汇编方言的目标（例如x86）上，所有基本的 &lt;code&gt;asm&lt;/code&gt; 块均使用由指定的汇编方言</target>
        </trans-unit>
        <trans-unit id="d61cb2550f8a937ac6fdb2426039ef34d8bd79ab" translate="yes" xml:space="preserve">
          <source>On targets such as x86, GCC supports multiple assembler dialects. The</source>
          <target state="translated">在x86等目标上,GCC支持多种汇编器方言。汇编器方言</target>
        </trans-unit>
        <trans-unit id="58cd0cfdbd27bd5c1c85588e8db09d5e47fe7abd" translate="yes" xml:space="preserve">
          <source>On targets that don&amp;rsquo;t support COMDAT, but do support weak symbols, GCC uses them. This way one copy overrides all the others, but the unused copies still take up space in the executable.</source>
          <target state="translated">在不支持COMDAT但支持弱符号的目标上，GCC使用它们。这样，一个副本将覆盖所有其他副本，但是未使用的副本仍会占用可执行文件中的空间。</target>
        </trans-unit>
        <trans-unit id="db6b506cf934f95ab486d96d507e199e74530808" translate="yes" xml:space="preserve">
          <source>On targets that support strong aliases, G++ works around mangling changes by creating an alias with the correct mangled name when defining a symbol with an incorrect mangled name. This switch specifies which ABI version to use for the alias.</source>
          <target state="translated">在支持强别名的目标上,G++通过在定义一个具有错误别名的符号时,创建一个具有正确别名的别名来解决混乱的变化。这个开关指定了别名要使用的ABI版本。</target>
        </trans-unit>
        <trans-unit id="ad2005f135085bd91be5baac596d98423c81523a" translate="yes" xml:space="preserve">
          <source>On targets that support symbol aliases, the default is</source>
          <target state="translated">在支持符号别名的目标上,默认是</target>
        </trans-unit>
        <trans-unit id="08070a532da1172ea25375415fe645b0da79ac62" translate="yes" xml:space="preserve">
          <source>On targets that use instruction scheduling, this option controls the amount of debugging output the scheduler prints to the dump files.</source>
          <target state="translated">在使用指令调度的目标上,这个选项控制调度器打印到转储文件的调试输出量。</target>
        </trans-unit>
        <trans-unit id="092af2f5d49550882da513d26e921a4d8d4fe252" translate="yes" xml:space="preserve">
          <source>On targets where code addresses are representable as &lt;code&gt;void *&lt;/code&gt;,</source>
          <target state="translated">在代码地址可表示为 &lt;code&gt;void *&lt;/code&gt; 的目标上，</target>
        </trans-unit>
        <trans-unit id="0357809f36796934ee518b4f582ea0c9e04da24c" translate="yes" xml:space="preserve">
          <source>On targets where the user visible pointer size is smaller than the size of an actual hardware address this function returns the extended user pointer. Targets where this is true included ILP32 mode on x86_64 or Aarch64. This function is mainly useful when writing inline assembly code.</source>
          <target state="translated">在用户可见指针大小小于实际硬件地址大小的目标上,该函数返回扩展的用户指针。此函数为真的目标包括x86_64或Aarch64上的ILP32模式。这个函数主要在编写内联汇编代码时有用。</target>
        </trans-unit>
        <trans-unit id="c74599677d84a97b951cd701c929b270ae2a8f43" translate="yes" xml:space="preserve">
          <source>On the ARC, you must specify the kind of interrupt to be handled in a parameter to the interrupt attribute like this:</source>
          <target state="translated">在ARC上,你必须在中断属性的参数中指定要处理的中断种类,比如这样。</target>
        </trans-unit>
        <trans-unit id="8f1b9d0583dcf355892e7a5808d90a73184b57e9" translate="yes" xml:space="preserve">
          <source>On the AVR target, there are several address spaces that can be used in order to put read-only data into the flash memory and access that data by means of the special instructions &lt;code&gt;LPM&lt;/code&gt; or &lt;code&gt;ELPM&lt;/code&gt; needed to read from flash.</source>
          <target state="translated">在AVR目标上，可以使用几个地址空间，以便将只读数据放入闪存并通过从闪存读取所需的特殊指令 &lt;code&gt;LPM&lt;/code&gt; 或 &lt;code&gt;ELPM&lt;/code&gt; 来访问该数据。</target>
        </trans-unit>
        <trans-unit id="fa1a3a8be337624014eab65a011ba0cd4944578f" translate="yes" xml:space="preserve">
          <source>On the AVR, the hardware globally disables interrupts when an interrupt is executed. The first instruction of an interrupt handler declared with this attribute is a &lt;code&gt;SEI&lt;/code&gt; instruction to re-enable interrupts. See also the &lt;code&gt;signal&lt;/code&gt; function attribute that does not insert a &lt;code&gt;SEI&lt;/code&gt; instruction. If both &lt;code&gt;signal&lt;/code&gt; and &lt;code&gt;interrupt&lt;/code&gt; are specified for the same function, &lt;code&gt;signal&lt;/code&gt; is silently ignored.</source>
          <target state="translated">在AVR上，执行中断时，硬件会全局禁用中断。使用此属性声明的中断处理程序的第一条指令是 &lt;code&gt;SEI&lt;/code&gt; 指令，用于重新启用中断。另请参见未插入 &lt;code&gt;SEI&lt;/code&gt; 指令的 &lt;code&gt;signal&lt;/code&gt; 功能属性。如果 &lt;code&gt;signal&lt;/code&gt; 和 &lt;code&gt;interrupt&lt;/code&gt; 都指定用于同一功能，则将忽略 &lt;code&gt;signal&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5cd37ff9ade8fdf6a273265986e56386f3b6bf8a" translate="yes" xml:space="preserve">
          <source>On the H8/300H and H8S, use the same alignment rules as for the H8/300. The default for the H8/300H and H8S is to align longs and floats on 4-byte boundaries.</source>
          <target state="translated">在H8/300H和H8S上,使用与H8/300相同的对齐规则。H8/300H和H8S的默认值是在4字节边界上对齐长和浮动。</target>
        </trans-unit>
        <trans-unit id="11e9b1c71b01253bfa1fdd5df13310266b613077" translate="yes" xml:space="preserve">
          <source>On the HP PA machine, ADB sometimes fails to work on functions compiled with GCC. Specifically, it fails to work on functions that use &lt;code&gt;alloca&lt;/code&gt; or variable-size arrays. This is because GCC doesn&amp;rsquo;t generate HP-UX unwind descriptors for such functions. It may even be impossible to generate them.</source>
          <target state="translated">在HP PA计算机上，ADB有时无法使用GCC编译的功能。特别是，它无法在使用 &lt;code&gt;alloca&lt;/code&gt; 或可变大小数组的函数上工作。这是因为GCC不会为此类功能生成HP-UX展开描述符。甚至可能无法生成它们。</target>
        </trans-unit>
        <trans-unit id="a6f0c85db03b4e781c3473176ab2b4c1d6c0940b" translate="yes" xml:space="preserve">
          <source>On the M32C target, with the R8C and M16C CPU variants, variables qualified with &lt;code&gt;__far&lt;/code&gt; are accessed using 32-bit addresses in order to access memory beyond the first 64 Ki bytes. If &lt;code&gt;__far&lt;/code&gt; is used with the M32CM or M32C CPU variants, it has no effect.</source>
          <target state="translated">在M32C目标上，使用R8C和M16C CPU变体，使用32位地址访问 &lt;code&gt;__far&lt;/code&gt; 限定的变量，以便访问前64 Ki字节以外的内存。如果 &lt;code&gt;__far&lt;/code&gt; 与M32CM或M32C CPU变体一起使用，则无效。</target>
        </trans-unit>
        <trans-unit id="8646819484a9f2352804185ed962b1134d1b1e37" translate="yes" xml:space="preserve">
          <source>On the M32R/D, use this attribute to set the addressability of an object, and of the code generated for a function. The identifier &lt;var&gt;model-name&lt;/var&gt; is one of &lt;code&gt;small&lt;/code&gt;, &lt;code&gt;medium&lt;/code&gt;, or &lt;code&gt;large&lt;/code&gt;, representing each of the code models.</source>
          <target state="translated">在M32R / D上，使用此属性设置对象的可寻址性以及为函数生成的代码的可寻址性。标识符 &lt;var&gt;model-name&lt;/var&gt; 是 &lt;code&gt;small&lt;/code&gt; ， &lt;code&gt;medium&lt;/code&gt; 或 &lt;code&gt;large&lt;/code&gt; 之一，代表每个代码模型。</target>
        </trans-unit>
        <trans-unit id="9e52ddbba667c27e2e0b8a95a8956a520ea2f402" translate="yes" xml:space="preserve">
          <source>On the MIPS platform, there is related use for local register variables with slightly different characteristics (see &lt;a href=&quot;http://gcc.gnu.org/onlinedocs/gccint/MIPS-Coprocessors.html#MIPS-Coprocessors&quot;&gt;Defining coprocessor specifics for MIPS targets&lt;/a&gt; in GNU Compiler Collection (GCC) Internals).</source>
          <target state="translated">在MIPS平台上，具有略微不同特征的局部寄存器变量也有相关用途（请参阅在GNU编译器集合（GCC）内部中&lt;a href=&quot;http://gcc.gnu.org/onlinedocs/gccint/MIPS-Coprocessors.html#MIPS-Coprocessors&quot;&gt;为MIPS目标定义协处理器细节&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="fbec944e2c4c4a91315d423364fb336ceebd34f7" translate="yes" xml:space="preserve">
          <source>On the MSP430 target these attributes can be used to specify whether the function or variable should be placed into low memory, high memory, or the placement should be left to the linker to decide. The attributes are only significant if compiling for the MSP430X architecture in the large memory model.</source>
          <target state="translated">在MSP430目标上,这些属性可以用来指定函数或变量是否应该放置在低内存、高内存中,还是应该由链接器来决定放置位置。只有在为大内存模型的MSP430X架构编译时,这些属性才有意义。</target>
        </trans-unit>
        <trans-unit id="7d84cba170c40b006fde2258af21b87e67ebfb09" translate="yes" xml:space="preserve">
          <source>On the MSP430 target these attributes can be used to specify whether the function or variable should be placed into low memory, high memory, or the placement should be left to the linker to decide. The attributes are only significant if compiling for the MSP430X architecture.</source>
          <target state="translated">在MSP430目标上,这些属性可以用来指定函数或变量是否应该放置在低内存、高内存,还是应该由链接器来决定放置位置。这些属性只有在为MSP430X架构编译时才有意义。</target>
        </trans-unit>
        <trans-unit id="d95670eabb89227c4ff1a457e8d12df37bee42fd" translate="yes" xml:space="preserve">
          <source>On the PowerPC Linux VSX targets, you can declare complex types using the corresponding internal complex type, &lt;code&gt;KCmode&lt;/code&gt; for &lt;code&gt;__float128&lt;/code&gt; type and &lt;code&gt;ICmode&lt;/code&gt; for &lt;code&gt;__ibm128&lt;/code&gt; type:</source>
          <target state="translated">在PowerPC的Linux的VSX目标，可以使用相应的内部复杂类型，声明复杂类型 &lt;code&gt;KCmode&lt;/code&gt; 为 &lt;code&gt;__float128&lt;/code&gt; 类型和 &lt;code&gt;ICmode&lt;/code&gt; 为 &lt;code&gt;__ibm128&lt;/code&gt; 类型：</target>
        </trans-unit>
        <trans-unit id="f6000ef0ce4e92f4ee54acf70fa8700653c71a5b" translate="yes" xml:space="preserve">
          <source>On the PowerPC, the following options are allowed:</source>
          <target state="translated">在PowerPC上,允许使用以下选项:</target>
        </trans-unit>
        <trans-unit id="86940e5138753858b6a6f91addcad4105a370c7f" translate="yes" xml:space="preserve">
          <source>On the PowerPC, the inliner does not inline a function that has different target options than the caller, unless the callee has a subset of the target options of the caller.</source>
          <target state="translated">在PowerPC上,inliner不会内联一个与调用者有不同目标选项的函数,除非被调用者有调用者目标选项的子集。</target>
        </trans-unit>
        <trans-unit id="45c4a00032a0dce389cc7f9c888e279c99fc2d6e" translate="yes" xml:space="preserve">
          <source>On the R8000 CPU when multiply-accumulate instructions are used, the intermediate product is calculated to infinite precision and is not subject to the FCSR Flush to Zero bit. This may be undesirable in some circumstances. On other processors the result is numerically identical to the equivalent computation using separate multiply, add, subtract and negate instructions.</source>
          <target state="translated">在R8000 CPU上,当使用乘法累加指令时,中间积的计算精度是无限大的,不受FCSR冲到零位的影响。这在某些情况下可能是不可取的。在其他处理器上,其结果与使用单独的乘、加、减、负指令进行的等效计算在数值上是相同的。</target>
        </trans-unit>
        <trans-unit id="0c2723395c05076575d0edc1ba09dc0cbf5cf2e2" translate="yes" xml:space="preserve">
          <source>On the RL78 target, variables qualified with &lt;code&gt;__far&lt;/code&gt; are accessed with 32-bit pointers (20-bit addresses) rather than the default 16-bit addresses. Non-far variables are assumed to appear in the topmost 64 KiB of the address space.</source>
          <target state="translated">在RL78目标上，使用 &lt;code&gt;__far&lt;/code&gt; 限定的变量是使用32位指针（20位地址）而不是默认的16位地址访问的。假定非远变量出现在地址空间的最顶部64 KiB中。</target>
        </trans-unit>
        <trans-unit id="fd6f38b7027d1749320d26f46d1a28168c174ead" translate="yes" xml:space="preserve">
          <source>On the SH Symbian OS target the &lt;code&gt;dllimport&lt;/code&gt; attribute also has another affect&amp;mdash;it can cause the vtable and run-time type information for a class to be exported. This happens when the class has a dllimported constructor or a non-inline, non-pure virtual function and, for either of those two conditions, the class also has an inline constructor or destructor and has a key function that is defined in the current translation unit.</source>
          <target state="translated">在SH Symbian OS目标上， &lt;code&gt;dllimport&lt;/code&gt; 属性还具有另一个影响-它可能导致导出类的vtable和运行时类型信息。当类具有dllimported构造函数或非内联非纯虚函数，并且对于这两种情况中的任一种，该类也具有内联构造函数或析构函数并且具有在当前翻译中定义的键函数时，会发生这种情况单元。</target>
        </trans-unit>
        <trans-unit id="cd5e8bc41b24a03848da023d0c42ed2a7835fd49" translate="yes" xml:space="preserve">
          <source>On the SH2A target, this attribute enables the high-speed register saving and restoration using a register bank for &lt;code&gt;interrupt_handler&lt;/code&gt; routines. Saving to the bank is performed automatically after the CPU accepts an interrupt that uses a register bank.</source>
          <target state="translated">在SH2A目标上，此属性通过使用用于 &lt;code&gt;interrupt_handler&lt;/code&gt; 例程的寄存器组来启用高速寄存器的保存和恢复。CPU接受使用寄存器组的中断后，将自动执行保存到组。</target>
        </trans-unit>
        <trans-unit id="f2adbfacdc8481145065b808452ffcbbe789d6e7" translate="yes" xml:space="preserve">
          <source>On the SPU target variables may be declared as belonging to another address space by qualifying the type with the &lt;code&gt;__ea&lt;/code&gt; address space identifier:</source>
          <target state="translated">在SPU上，通过使用 &lt;code&gt;__ea&lt;/code&gt; 地址空间标识符限定类型，可以将目标变量声明为属于另一个地址空间：</target>
        </trans-unit>
        <trans-unit id="583c1957eff9fd54fc7ba9d8a8ce5bd6cbbb0dbc" translate="yes" xml:space="preserve">
          <source>On the i386, x86_64, IA-64, and HP-UX targets, you can declare complex types using the corresponding internal complex type, &lt;code&gt;XCmode&lt;/code&gt; for &lt;code&gt;__float80&lt;/code&gt; type and &lt;code&gt;TCmode&lt;/code&gt; for &lt;code&gt;__float128&lt;/code&gt; type:</source>
          <target state="translated">在i386上，x86_64的，IA-64和HP-UX的目标，您可以使用相应的内部复杂类型，声明复杂类型 &lt;code&gt;XCmode&lt;/code&gt; 为 &lt;code&gt;__float80&lt;/code&gt; 类型和 &lt;code&gt;TCmode&lt;/code&gt; 为 &lt;code&gt;__float128&lt;/code&gt; 类型：</target>
        </trans-unit>
        <trans-unit id="dcf75663e59f753533fd49143ad9b22b45ca5dee" translate="yes" xml:space="preserve">
          <source>On the other hand, in this example there is no warning:</source>
          <target state="translated">另一方面,在这个例子中,没有警告。</target>
        </trans-unit>
        <trans-unit id="c654fceb0b13e0812db2eebf6209fb23d2a4245f" translate="yes" xml:space="preserve">
          <source>On the reduced Tiny devices like ATtiny40, no address spaces are supported. Just use vanilla C / C++ code without overhead as outlined above. Attribute &lt;code&gt;progmem&lt;/code&gt; is supported but works differently, see &lt;a href=&quot;variable-attributes#AVR-Variable-Attributes&quot;&gt;AVR Variable Attributes&lt;/a&gt;.</source>
          <target state="translated">在像ATtiny40这样精简的Tiny设备上，不支持任何地址空间。只需使用原始的C / C ++代码即可，而不会产生上述开销。支持属性 &lt;code&gt;progmem&lt;/code&gt; ，但工作方式有所不同，请参阅&lt;a href=&quot;variable-attributes#AVR-Variable-Attributes&quot;&gt;AVR变量属性&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4951a4be95b4833eb07239f4a372cdd8f2448825" translate="yes" xml:space="preserve">
          <source>On the x86 target, variables may be declared as being relative to the &lt;code&gt;%fs&lt;/code&gt; or &lt;code&gt;%gs&lt;/code&gt; segments.</source>
          <target state="translated">在x86目标上，可以将变量声明为相对于 &lt;code&gt;%fs&lt;/code&gt; 或 &lt;code&gt;%gs&lt;/code&gt; 段。</target>
        </trans-unit>
        <trans-unit id="147636575199bc4c1463a6a96921cb3caf526a23" translate="yes" xml:space="preserve">
          <source>On the x86, the following options are allowed:</source>
          <target state="translated">在x86上,允许使用以下选项:</target>
        </trans-unit>
        <trans-unit id="04f0f8c579cd5c70473d51704cbf41abb08c9dc8" translate="yes" xml:space="preserve">
          <source>On the x86, the inliner does not inline a function that has different target options than the caller, unless the callee has a subset of the target options of the caller. For example a function declared with &lt;code&gt;target(&quot;sse3&quot;)&lt;/code&gt; can inline a function with &lt;code&gt;target(&quot;sse2&quot;)&lt;/code&gt;, since &lt;code&gt;-msse3&lt;/code&gt; implies &lt;code&gt;-msse2&lt;/code&gt;.</source>
          <target state="translated">在x86上，内联函数不会内联具有与调用者不同的目标选项的函数，除非被调用者具有调用者的目标选项的子集。例如，用 &lt;code&gt;target(&quot;sse3&quot;)&lt;/code&gt; 声明的函数可以用-target &lt;code&gt;target(&quot;sse2&quot;)&lt;/code&gt; 内联函数，因为 &lt;code&gt;-msse3&lt;/code&gt; 意味着 &lt;code&gt;-msse2&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0c4f5a0b052b2a8060d4fded035d077e00490366" translate="yes" xml:space="preserve">
          <source>On the x86-32 targets, the &lt;code&gt;cdecl&lt;/code&gt; attribute causes the compiler to assume that the calling function pops off the stack space used to pass arguments. This is useful to override the effects of the</source>
          <target state="translated">在x86-32目标上， &lt;code&gt;cdecl&lt;/code&gt; 属性使编译器假定调用函数弹出用于传递参数的堆栈空间。这对于覆盖</target>
        </trans-unit>
        <trans-unit id="ef036c2436b70e56f5d89ed3a4bd592468b97a24" translate="yes" xml:space="preserve">
          <source>On those ARM targets that support &lt;code&gt;dllimport&lt;/code&gt; (such as Symbian OS), you can use the &lt;code&gt;notshared&lt;/code&gt; attribute to indicate that the virtual table and other similar data for a class should not be exported from a DLL. For example:</source>
          <target state="translated">在那些支持 &lt;code&gt;dllimport&lt;/code&gt; 的 ARM目标（例如Symbian OS）上，可以使用 &lt;code&gt;notshared&lt;/code&gt; 属性来指示不应从DLL导出类的虚拟表和其他类似数据。例如：</target>
        </trans-unit>
        <trans-unit id="70eb4df699149cfe34494e2a2d4a3053eec54b36" translate="yes" xml:space="preserve">
          <source>On x86 targets, the &lt;code&gt;fentry_name&lt;/code&gt; attribute sets the function to call on function entry when function instrumentation is enabled with</source>
          <target state="translated">在x86目标上， &lt;code&gt;fentry_name&lt;/code&gt; 属性将功能设置为在启用了功能检测时调用功能条目</target>
        </trans-unit>
        <trans-unit id="3c3e4dc55159d733bc6d8174d6c0b4b44576b30b" translate="yes" xml:space="preserve">
          <source>On x86 targets, the &lt;code&gt;fentry_section&lt;/code&gt; attribute sets the name of the section to record function entry instrumentation calls in when enabled with</source>
          <target state="translated">在x86目标上， &lt;code&gt;fentry_section&lt;/code&gt; 属性设置该节的名称，以在启用以下命令时记录函数条目检测调用</target>
        </trans-unit>
        <trans-unit id="13bdaf45293e8c14caaa41c024215d1502f9dedd" translate="yes" xml:space="preserve">
          <source>On x86 targets, the &lt;code&gt;force_align_arg_pointer&lt;/code&gt; attribute may be applied to individual function definitions, generating an alternate prologue and epilogue that realigns the run-time stack if necessary. This supports mixing legacy codes that run with a 4-byte aligned stack with modern codes that keep a 16-byte stack for SSE compatibility.</source>
          <target state="translated">在x86目标上，可以将 &lt;code&gt;force_align_arg_pointer&lt;/code&gt; 属性应用于单个函数定义，从而生成备用的序言和结尾，以在必要时重新对齐运行时堆栈。这支持将以4字节对齐的堆栈运行的旧代码与保留16字节堆栈的现代代码混合在一起以实现SSE兼容性。</target>
        </trans-unit>
        <trans-unit id="4b9b1df237cb48ab5b390c563b9173f28432ce30" translate="yes" xml:space="preserve">
          <source>On x86 targets, the &lt;code&gt;function_return&lt;/code&gt; attribute causes the compiler to convert function return with &lt;var&gt;choice&lt;/var&gt;. &amp;lsquo;</source>
          <target state="translated">在x86目标上， &lt;code&gt;function_return&lt;/code&gt; 属性使编译器使用 &lt;var&gt;choice&lt;/var&gt; 转换函数return 。'</target>
        </trans-unit>
        <trans-unit id="e98109b32d764a6aa78e38267f8fd0b80deffe59" translate="yes" xml:space="preserve">
          <source>On x86 targets, the &lt;code&gt;indirect_branch&lt;/code&gt; attribute causes the compiler to convert indirect call and jump with &lt;var&gt;choice&lt;/var&gt;. &amp;lsquo;</source>
          <target state="translated">在x86目标上， &lt;code&gt;indirect_branch&lt;/code&gt; 属性使编译器转换间接调用并使用 &lt;var&gt;choice&lt;/var&gt; 跳转。'</target>
        </trans-unit>
        <trans-unit id="6debaf7293c72e5d4ef579b9583d9c54220aa952" translate="yes" xml:space="preserve">
          <source>On x86 targets, there are several rules on the usage of stack-like registers in the operands of an &lt;code&gt;asm&lt;/code&gt;. These rules apply only to the operands that are stack-like registers:</source>
          <target state="translated">在x86目标上，在 &lt;code&gt;asm&lt;/code&gt; 的操作数中使用类似堆栈的寄存器有一些规则。这些规则仅适用于类似于堆栈的寄存器的操作数：</target>
        </trans-unit>
        <trans-unit id="0a9ad2d6b1a6892ed184c51d63255bdbba6feecb" translate="yes" xml:space="preserve">
          <source>On x86-32 targets with SSE support, the &lt;code&gt;sseregparm&lt;/code&gt; attribute causes the compiler to pass up to 3 floating-point arguments in SSE registers instead of on the stack. Functions that take a variable number of arguments continue to pass all of their floating-point arguments on the stack.</source>
          <target state="translated">在具有SSE支持的x86-32目标上， &lt;code&gt;sseregparm&lt;/code&gt; 属性使编译器在SSE寄存器中而不是堆栈中最多传递3个浮点参数。带有可变数量参数的函数将继续在堆栈上传递其所有浮点参数。</target>
        </trans-unit>
        <trans-unit id="b5b62a62d6592728c9f30e63c3f3d4654c7cba4c" translate="yes" xml:space="preserve">
          <source>On x86-32 targets, the &lt;code&gt;fastcall&lt;/code&gt; attribute causes the compiler to pass the first argument (if of integral type) in the register ECX and the second argument (if of integral type) in the register EDX. Subsequent and other typed arguments are passed on the stack. The called function pops the arguments off the stack. If the number of arguments is variable all arguments are pushed on the stack.</source>
          <target state="translated">在x86-32目标上， &lt;code&gt;fastcall&lt;/code&gt; 属性使编译器在寄存器ECX中传递第一个参数（如果是整数类型），在寄存器EDX中传递第二个参数（如果是整数类型）。后续和其他类型的参数在堆栈上传递。被调用函数将参数弹出堆栈。如果参数数量可变，则所有参数都将压入堆栈。</target>
        </trans-unit>
        <trans-unit id="cbd1fa07b20b0b27ba6acba6bf923a6e60833164" translate="yes" xml:space="preserve">
          <source>On x86-32 targets, the &lt;code&gt;regparm&lt;/code&gt; attribute causes the compiler to pass arguments number one to &lt;var&gt;number&lt;/var&gt; if they are of integral type in registers EAX, EDX, and ECX instead of on the stack. Functions that take a variable number of arguments continue to be passed all of their arguments on the stack.</source>
          <target state="translated">在x86-32目标上，如果 &lt;code&gt;regparm&lt;/code&gt; 属性在寄存器EAX，EDX和ECX中为整数类型，而不是在堆栈上，则regparm属性使编译器将第一参数传递给 &lt;var&gt;number&lt;/var&gt; 。带有可变数量参数的函数将继续在堆栈上传递其所有参数。</target>
        </trans-unit>
        <trans-unit id="3ff7dde95e04753c9aa0506316b6827d1c04e392" translate="yes" xml:space="preserve">
          <source>On x86-32 targets, the &lt;code&gt;stdcall&lt;/code&gt; attribute causes the compiler to assume that the called function pops off the stack space used to pass arguments, unless it takes a variable number of arguments.</source>
          <target state="translated">在x86-32目标上， &lt;code&gt;stdcall&lt;/code&gt; 属性使编译器假定被调用函数弹出用于传递参数的堆栈空间，除非它采用可变数量的参数。</target>
        </trans-unit>
        <trans-unit id="7e68005038eba79aa520fa3e9f1d5a1f549a6854" translate="yes" xml:space="preserve">
          <source>On x86-32 targets, the &lt;code&gt;thiscall&lt;/code&gt; attribute causes the compiler to pass the first argument (if of integral type) in the register ECX. Subsequent and other typed arguments are passed on the stack. The called function pops the arguments off the stack. If the number of arguments is variable all arguments are pushed on the stack. The &lt;code&gt;thiscall&lt;/code&gt; attribute is intended for C++ non-static member functions. As a GCC extension, this calling convention can be used for C functions and for static member methods.</source>
          <target state="translated">在x86-32目标上， &lt;code&gt;thiscall&lt;/code&gt; 属性使编译器在寄存器ECX中传递第一个参数（如果是整数类型）。后续和其他类型的参数在堆栈上传递。被调用函数将参数弹出堆栈。如果参数数量可变，则所有参数都将压入堆栈。所述 &lt;code&gt;thiscall&lt;/code&gt; 属性是用于C ++非静态成员函数。作为GCC扩展，此调用约定可用于C函数和静态成员方法。</target>
        </trans-unit>
        <trans-unit id="4c75d4c9c1f7232a6ff5a36eb71f949d09c252de" translate="yes" xml:space="preserve">
          <source>On x86-32 targets, you can use this attribute to control how aggregates are returned in memory. If the caller is responsible for popping the hidden pointer together with the rest of the arguments, specify &lt;var&gt;number&lt;/var&gt; equal to zero. If callee is responsible for popping the hidden pointer, specify &lt;var&gt;number&lt;/var&gt; equal to one.</source>
          <target state="translated">在x86-32目标上，可以使用此属性来控制如何在内存中返回聚合。如果调用方负责将隐藏的指针与其余参数一起弹出，请指定 &lt;var&gt;number&lt;/var&gt; 等于零。如果被叫方是负责弹出隐藏的指针，指定 &lt;var&gt;number&lt;/var&gt; 等于一。</target>
        </trans-unit>
        <trans-unit id="4fecb03395dc1395498320fbdf3198613b4b8a60" translate="yes" xml:space="preserve">
          <source>On x86-64,</source>
          <target state="translated">在x86-64上。</target>
        </trans-unit>
        <trans-unit id="42dd75ddf8dffa70aaf71424d90322dc968acd07" translate="yes" xml:space="preserve">
          <source>Once you know these things about how your code works when compiled, you can look at each module to see which modules should be optimized. &lt;code&gt;gcov&lt;/code&gt; helps you determine where to work on optimization.</source>
          <target state="translated">一旦了解了有关代码在编译时如何工作的这些知识，就可以查看每个模块以查看应优化的模块。 &lt;code&gt;gcov&lt;/code&gt; 可帮助您确定在哪里进行优化。</target>
        </trans-unit>
        <trans-unit id="7b43238f6f78aaf633ee23a498072b63cc24feec" translate="yes" xml:space="preserve">
          <source>One 16x16 multiplier, blocking, sequential. The following instructions are additionally enabled: &lt;code&gt;mpy&lt;/code&gt;, &lt;code&gt;mpyu&lt;/code&gt;, &lt;code&gt;mpym&lt;/code&gt;, &lt;code&gt;mpymu&lt;/code&gt;, and &lt;code&gt;mpy_s&lt;/code&gt;.</source>
          <target state="translated">一个16x16乘法器，按顺序阻塞。另外启用了以下指令： &lt;code&gt;mpy&lt;/code&gt; ， &lt;code&gt;mpyu&lt;/code&gt; ， &lt;code&gt;mpym&lt;/code&gt; ， &lt;code&gt;mpymu&lt;/code&gt; 和 &lt;code&gt;mpy_s&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="21c409760c2daeb8e7cc4e16b05141d45f49a9c8" translate="yes" xml:space="preserve">
          <source>One 32x4 multiplier, blocking, sequential. The following instructions are additionally enabled: &lt;code&gt;mpy&lt;/code&gt;, &lt;code&gt;mpyu&lt;/code&gt;, &lt;code&gt;mpym&lt;/code&gt;, &lt;code&gt;mpymu&lt;/code&gt;, and &lt;code&gt;mpy_s&lt;/code&gt;.</source>
          <target state="translated">1个32x4乘法器，按顺序阻塞。另外启用了以下指令： &lt;code&gt;mpy&lt;/code&gt; ， &lt;code&gt;mpyu&lt;/code&gt; ， &lt;code&gt;mpym&lt;/code&gt; ， &lt;code&gt;mpymu&lt;/code&gt; 和 &lt;code&gt;mpy_s&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="849f208cf290b5367e3408ce32e8d353040bdae1" translate="yes" xml:space="preserve">
          <source>One attribute is currently defined for the M32R/D.</source>
          <target state="translated">目前为M32R/D定义了一个属性。</target>
        </trans-unit>
        <trans-unit id="40fe184b70220276317c0b61fedbed3c3b9cb8e1" translate="yes" xml:space="preserve">
          <source>One attribute is currently defined for xstormy16 configurations: &lt;code&gt;below100&lt;/code&gt;.</source>
          <target state="translated">当前为xstormy16配置定义了一个属性： &lt;code&gt;below100&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1dd2f15e1e49aa3a60aafa7cc37a3dcdf9c0a48d" translate="yes" xml:space="preserve">
          <source>One consequence is that you cannot call &lt;code&gt;mktemp&lt;/code&gt; with a string constant argument. The function &lt;code&gt;mktemp&lt;/code&gt; always alters the string its argument points to.</source>
          <target state="translated">结果是您不能使用字符串常量参数调用 &lt;code&gt;mktemp&lt;/code&gt; 。函数 &lt;code&gt;mktemp&lt;/code&gt; 总是更改其参数指向的字符串。</target>
        </trans-unit>
        <trans-unit id="44bd2c18671505607165541a387b3b6df0ee2e30" translate="yes" xml:space="preserve">
          <source>One drawback to using this attribute is that a pointer to a &lt;em&gt;variable&lt;/em&gt; marked as &lt;code&gt;dllimport&lt;/code&gt; cannot be used as a constant address. However, a pointer to a &lt;em&gt;function&lt;/em&gt; with the &lt;code&gt;dllimport&lt;/code&gt; attribute can be used as a constant initializer; in this case, the address of a stub function in the import lib is referenced. On Microsoft Windows targets, the attribute can be disabled for functions by setting the</source>
          <target state="translated">使用此属性的一个缺点是，不能将指向标记为 &lt;code&gt;dllimport&lt;/code&gt; 的&lt;em&gt;变量&lt;/em&gt;的指针用作常量地址。但是，可以将指向具有 &lt;code&gt;dllimport&lt;/code&gt; 属性的&lt;em&gt;函数&lt;/em&gt;的指针用作常量初始化器。在这种情况下，将引用导入库中存根函数的地址。在Microsoft Windows目标上，可以通过设置&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="eec865ab9ca221fb872ddd30d1cd51ca9cd6aa48" translate="yes" xml:space="preserve">
          <source>One final built-in function has been added that returns the value of the 2-bit Transaction State field of the Machine Status Register (MSR) as stored in &lt;code&gt;CR0&lt;/code&gt;.</source>
          <target state="translated">添加了最后一个内置函数，该函数返回存储在 &lt;code&gt;CR0&lt;/code&gt; 中的机器状态寄存器（MSR）的2位事务状态字段的值。</target>
        </trans-unit>
        <trans-unit id="c1bb56d3e41b8821842eef1d720c3d75aea46a37" translate="yes" xml:space="preserve">
          <source>One of the low eight SVE predicate registers (&lt;code&gt;P0&lt;/code&gt; to &lt;code&gt;P7&lt;/code&gt;)</source>
          <target state="translated">低8个SVE谓词寄存器（ &lt;code&gt;P0&lt;/code&gt; 至 &lt;code&gt;P7&lt;/code&gt; ）之一</target>
        </trans-unit>
        <trans-unit id="64b686b9cc394ce49f58ad2185501cf7ed15c7d0" translate="yes" xml:space="preserve">
          <source>One of the standard libraries bypassed by</source>
          <target state="translated">绕过的一个标准库</target>
        </trans-unit>
        <trans-unit id="02b57e3d25b1b84de7aa1ea5322739942677791f" translate="yes" xml:space="preserve">
          <source>One or more of the following option keywords can be used to describe a group of optimizations:</source>
          <target state="translated">以下一个或多个选项关键字可以用来描述一组优化。</target>
        </trans-unit>
        <trans-unit id="55a0fb6dad6e34221933361d3e31d20be49bd376" translate="yes" xml:space="preserve">
          <source>One or more qualifiers: &lt;code&gt;static&lt;/code&gt;, &lt;code&gt;dynamic&lt;/code&gt;, &lt;code&gt;bounded&lt;/code&gt;.</source>
          <target state="translated">一个或多个限定符： &lt;code&gt;static&lt;/code&gt; ， &lt;code&gt;dynamic&lt;/code&gt; ， &lt;code&gt;bounded&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="56bb919cccd4e254306e243c0906992cea6d6640" translate="yes" xml:space="preserve">
          <source>One such case is immediately following an &lt;code&gt;asm&lt;/code&gt; statement that either never terminates, or one that transfers control elsewhere and never returns. In this example, without the &lt;code&gt;__builtin_unreachable&lt;/code&gt;, GCC issues a warning that control reaches the end of a non-void function. It also generates code to return after the &lt;code&gt;asm&lt;/code&gt;.</source>
          <target state="translated">一种这样的情况是紧跟在一个 &lt;code&gt;asm&lt;/code&gt; 语句之后，该语句要么永不终止，要么将控制权转移到其他位置而永不返回。在此示例中，如果没有 &lt;code&gt;__builtin_unreachable&lt;/code&gt; ，则GCC会发出警告，指出控件已到达非void函数的末尾。它还会生成代码以在 &lt;code&gt;asm&lt;/code&gt; 之后返回。</target>
        </trans-unit>
        <trans-unit id="cfb62f38764ce598607e81e73ef5564abcafbf10" translate="yes" xml:space="preserve">
          <source>One typical use case for this built-in is adjusting input and output values to non-contiguous port layouts. Some examples:</source>
          <target state="translated">该内置的一个典型用例是调整输入和输出值到非连续端口布局。一些例子。</target>
        </trans-unit>
        <trans-unit id="cdc3d4316f37caecddf4da207a8a333a1f06f1e6" translate="yes" xml:space="preserve">
          <source>One way of using these constants is in initializing a static array that serves as a jump table:</source>
          <target state="translated">使用这些常量的一种方式是在初始化一个静态数组,作为跳转表。</target>
        </trans-unit>
        <trans-unit id="4abf320685928f7114b2a671b0c8e5d78f023c66" translate="yes" xml:space="preserve">
          <source>One way to solve this problem is to compile your entire program with GCC. Another solution is to modify the function that is compiled with Sun CC to copy the argument into a local variable; local variables are always properly aligned. A third solution is to modify the function that uses the pointer to dereference it via the following function &lt;code&gt;access_double&lt;/code&gt; instead of directly with &amp;lsquo;</source>
          <target state="translated">解决此问题的一种方法是使用GCC编译整个程序。另一个解决方案是修改使用Sun CC编译的函数，以将参数复制到局部变量中。局部变量始终正确对齐。第三种解决方案是通过以下函数 &lt;code&gt;access_double&lt;/code&gt; 而不是直接使用' 来修改使用指针取消引用的函数。</target>
        </trans-unit>
        <trans-unit id="11c60f443d3a43430190f5782a8be8122d41c489" translate="yes" xml:space="preserve">
          <source>One workaround is to insert cache barrier instructions before every memory access that might be speculatively executed and that might have side effects even if aborted.</source>
          <target state="translated">一个变通的办法是在每次可能被投机执行的内存访问之前插入缓存屏障指令,即使被中止也可能产生副作用。</target>
        </trans-unit>
        <trans-unit id="46fd9a138136ce012f77c2ad875a236ea7641073" translate="yes" xml:space="preserve">
          <source>One&amp;rsquo;s complement of a 6-bit unsigned integer constant.</source>
          <target state="translated">一个6位无符号整数常数的补码。</target>
        </trans-unit>
        <trans-unit id="09ff598dbd1dd52bba3a7ce58edc2ab65caf114c" translate="yes" xml:space="preserve">
          <source>One-bit boolean register</source>
          <target state="translated">1位布尔值寄存器</target>
        </trans-unit>
        <trans-unit id="b86152f3b7cb1fd57d0957c837b7a02e1c1edec1" translate="yes" xml:space="preserve">
          <source>Only available if either</source>
          <target state="translated">只有在以下两种情况下才可使用</target>
        </trans-unit>
        <trans-unit id="fa0e52cdfb683b064ba9081fec281277ab21b369" translate="yes" xml:space="preserve">
          <source>Only available with</source>
          <target state="translated">只提供</target>
        </trans-unit>
        <trans-unit id="d8174cb5b4a5090a1c9f6528e9032514840b01a2" translate="yes" xml:space="preserve">
          <source>Only change the lower 8 bits of the stack pointer.</source>
          <target state="translated">只改变栈指针的低8位。</target>
        </trans-unit>
        <trans-unit id="fa1093075a5bab803d61da780f973e8e456e21b9" translate="yes" xml:space="preserve">
          <source>Only enable inlining and cloning optimizations, which includes inlining, cloning, interprocedural scalar replacement of aggregates and partial inlining. As a result, when patching a function, all its callers and its clones&amp;rsquo; callers are impacted, therefore need to be patched as well.</source>
          <target state="translated">仅启用内联和克隆优化，包括内联，克隆，聚合过程间标量替换和部分内联。结果，在修补功能时，其所有调用者及其克隆的调用者都会受到影响，因此也需要进行修补。</target>
        </trans-unit>
        <trans-unit id="98cdd885ed933d2b0d71761a5e0e3218cffb4c2b" translate="yes" xml:space="preserve">
          <source>Only enable inlining of static functions. As a result, when patching a static function, all its callers are impacted and so need to be patched as well.</source>
          <target state="translated">只启用静态函数的内联。因此,当对静态函数打补丁时,它的所有调用者都会受到影响,因此也需要打补丁。</target>
        </trans-unit>
        <trans-unit id="a790c727dbde2c9153b76b5c8a491055c1c24680" translate="yes" xml:space="preserve">
          <source>Only generate absolute relocations on word-sized values (i.e. R_ARM_ABS32). This is enabled by default on targets (uClinux, SymbianOS) where the runtime loader imposes this restriction, and when</source>
          <target state="translated">只在字大小的值上生成绝对重定位 (即 R_ARM_ABS32)。在运行时加载器有此限制的目标(uClinux,SymbianOS)上,这是默认启用的,而且当</target>
        </trans-unit>
        <trans-unit id="69487605cf89b2b25fc2b6052bd8701c5c25ea67" translate="yes" xml:space="preserve">
          <source>Only meaningful in line-wrapping mode. Instructs the diagnostic messages reporter to emit source location information &lt;em&gt;once&lt;/em&gt;; that is, in case the message is too long to fit on a single physical line and has to be wrapped, the source location won&amp;rsquo;t be emitted (as prefix) again, over and over, in subsequent continuation lines. This is the default behavior.</source>
          <target state="translated">仅在换行模式下有意义。指示诊断消息报告程序&lt;em&gt;一次&lt;/em&gt;发出源位置信息；也就是说，如果消息太长而无法容纳在单个物理行上并且必须进行包装，则源位置将不会在后续的连续行中一遍又一遍地发出（作为前缀）。这是默认行为。</target>
        </trans-unit>
        <trans-unit id="ebd505efc7bd99f753105955cdf89673e5640a71" translate="yes" xml:space="preserve">
          <source>Only meaningful in line-wrapping mode. Instructs the diagnostic messages reporter to emit the same source location information (as prefix) for physical lines that result from the process of breaking a message which is too long to fit on a single line.</source>
          <target state="translated">只有在包线模式下才有意义。指示诊断电文报告器对因电文太长而无法在单行上显示而产生的物理行发出相同的源位置信息(作为前缀)。</target>
        </trans-unit>
        <trans-unit id="330993f6286aa72148d14226b91455d3ac494a8c" translate="yes" xml:space="preserve">
          <source>Only one precompiled header can be used in a particular compilation.</source>
          <target state="translated">在一个特定的编译中只能使用一个预编译的头。</target>
        </trans-unit>
        <trans-unit id="0c89e84df5b584e830b8d2d2e716a4ce60df935f" translate="yes" xml:space="preserve">
          <source>Only output information about source files with a relative pathname (after source prefix elision). Absolute paths are usually system header files and coverage of any inline functions therein is normally uninteresting.</source>
          <target state="translated">只输出带有相对路径名的源文件信息(在源文件前缀删除后)。绝对路径通常是系统头文件,对其中的任何内联函数的覆盖通常是不感兴趣的。</target>
        </trans-unit>
        <trans-unit id="72274ff34b747c56a57940685e3ffdf10da20513" translate="yes" xml:space="preserve">
          <source>Only print info for hot objects/functions.</source>
          <target state="translated">只打印热对象/功能的信息。</target>
        </trans-unit>
        <trans-unit id="8b24ee9bfdf40f46680f47de16c5081b87003895" translate="yes" xml:space="preserve">
          <source>Only use the first 32 general-purpose registers.</source>
          <target state="translated">只使用前32个通用寄存器。</target>
        </trans-unit>
        <trans-unit id="338aae9daa260c2c83f7e418040b21c679f46883" translate="yes" xml:space="preserve">
          <source>Only use these options when there are significant benefits from doing so. When you specify these options, the assembler and linker create larger object and executable files and are also slower. These options affect code generation. They prevent optimizations by the compiler and assembler using relative locations inside a translation unit since the locations are unknown until link time. An example of such an optimization is relaxing calls to short call instructions.</source>
          <target state="translated">只有在这样做有显著好处的时候才使用这些选项。当你指定这些选项时,汇编器和链接器会创建较大的对象文件和可执行文件,而且速度也较慢。这些选项会影响代码的生成。它们防止编译器和汇编器使用翻译单元内的相对位置进行优化,因为在链接时间之前,这些位置是未知的。这种优化的一个例子是放宽对短调用指令的调用。</target>
        </trans-unit>
        <trans-unit id="7b26ac27e9054975e1b8c28c749dd8e60046db26" translate="yes" xml:space="preserve">
          <source>Only valid if the &amp;lsquo;</source>
          <target state="translated">仅在&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="a24c971c70af3e6d67c9922de68be68fd14aa925" translate="yes" xml:space="preserve">
          <source>Only valid with</source>
          <target state="translated">仅在以下情况下有效</target>
        </trans-unit>
        <trans-unit id="4f3ef120810b89335683d19761269a1b29d439b1" translate="yes" xml:space="preserve">
          <source>OpenRISC&amp;mdash;</source>
          <target state="translated">OpenRISC&amp;mdash;</target>
        </trans-unit>
        <trans-unit id="ff04060b9cdf50d21da510eb2aee82a293b79942" translate="yes" xml:space="preserve">
          <source>Operand</source>
          <target state="translated">Operand</target>
        </trans-unit>
        <trans-unit id="96c8142487d93ded6eed966e1c94866edb7f6ce0" translate="yes" xml:space="preserve">
          <source>Operands are separated by commas. Each operand has this format:</source>
          <target state="translated">操作数用逗号分隔。每个操作数都有这样的格式。</target>
        </trans-unit>
        <trans-unit id="67c4124aaeb7fa5b37a4c13183fee8472dbd34a2" translate="yes" xml:space="preserve">
          <source>Operands that satisfy &amp;rsquo;m&amp;rsquo; when -mpcrel is in effect</source>
          <target state="translated">-mpcrel生效时满足&amp;ldquo; m&amp;rdquo;的操作数</target>
        </trans-unit>
        <trans-unit id="f223672699f4c0fd304046c8f55c3a8a822eafba" translate="yes" xml:space="preserve">
          <source>Operands that satisfy &amp;rsquo;s&amp;rsquo; when -mpcrel is not in effect</source>
          <target state="translated">-mpcrel无效时满足&amp;ldquo; s&amp;rdquo;的操作数</target>
        </trans-unit>
        <trans-unit id="a6a1e6ee77f32bbfca88fdb0ed00cdafe059d583" translate="yes" xml:space="preserve">
          <source>Operands using the &amp;lsquo;</source>
          <target state="translated">使用'</target>
        </trans-unit>
        <trans-unit id="dd2427f9810f7d01de4920a5fbaf944c75db0f9b" translate="yes" xml:space="preserve">
          <source>Optimization Options</source>
          <target state="translated">优化选项</target>
        </trans-unit>
        <trans-unit id="cab9c4fb94627ad4002c4f07a4e254f1d83181e5" translate="yes" xml:space="preserve">
          <source>Optimize debugging experience.</source>
          <target state="translated">优化调试体验。</target>
        </trans-unit>
        <trans-unit id="f6711b309c1e96e21f6e3fd3f0f4cca8b00ad887" translate="yes" xml:space="preserve">
          <source>Optimize even more. GCC performs nearly all supported optimizations that do not involve a space-speed tradeoff. As compared to</source>
          <target state="translated">优化更多。GCC几乎执行了所有支持的优化,不涉及空间速度的折衷。与</target>
        </trans-unit>
        <trans-unit id="115cffa4f350df63881ca8bb33b21ff035557045" translate="yes" xml:space="preserve">
          <source>Optimize for &lt;var&gt;arch&lt;/var&gt;. Among other things, this option controls the way instructions are scheduled, and the perceived cost of arithmetic operations. The list of &lt;var&gt;arch&lt;/var&gt; values is the same as for</source>
          <target state="translated">优化 &lt;var&gt;arch&lt;/var&gt; 。除其他外，该选项控制指令的调度方式以及算术运算的成本。 &lt;var&gt;arch&lt;/var&gt; 值列表与</target>
        </trans-unit>
        <trans-unit id="00bcbcf49330fd5cd07800c1cc402ad50059a9a8" translate="yes" xml:space="preserve">
          <source>Optimize for size.</source>
          <target state="translated">优化尺寸。</target>
        </trans-unit>
        <trans-unit id="b1f0ff5d58183a1211bf6345ec617611e6079a6c" translate="yes" xml:space="preserve">
          <source>Optimize sibling and tail recursive calls.</source>
          <target state="translated">优化同级和尾部递归调用。</target>
        </trans-unit>
        <trans-unit id="82acb86d67d8f7c979237a3f9d5995187b58bb34" translate="yes" xml:space="preserve">
          <source>Optimize the output for the given processor, specified by microarchitecture name. Permissible values for this option are: &amp;lsquo;</source>
          <target state="translated">优化由微体系结构名称指定的给定处理器的输出。该选项的允许值为：</target>
        </trans-unit>
        <trans-unit id="beede52c02c3ccdc57d067263b0592c5c5870f64" translate="yes" xml:space="preserve">
          <source>Optimize the prologue of variadic argument functions with respect to usage of those arguments.</source>
          <target state="translated">优化变量参数函数的序言,对这些参数的用法进行优化。</target>
        </trans-unit>
        <trans-unit id="8091cf8a7f45d51dd71bbe1a181b77efee3b92fa" translate="yes" xml:space="preserve">
          <source>Optimize various standard C string functions (e.g. &lt;code&gt;strlen&lt;/code&gt;, &lt;code&gt;strchr&lt;/code&gt; or &lt;code&gt;strcpy&lt;/code&gt;) and their &lt;code&gt;_FORTIFY_SOURCE&lt;/code&gt; counterparts into faster alternatives.</source>
          <target state="translated">将各种标准C字符串函数（例如 &lt;code&gt;strlen&lt;/code&gt; ， &lt;code&gt;strchr&lt;/code&gt; 或 &lt;code&gt;strcpy&lt;/code&gt; ）及其 &lt;code&gt;_FORTIFY_SOURCE&lt;/code&gt; 对应项优化为更快的替代方案。</target>
        </trans-unit>
        <trans-unit id="313c197a1bf79c8cb464f9108769008bb606d983" translate="yes" xml:space="preserve">
          <source>Optimize yet more.</source>
          <target state="translated">再优化一下。</target>
        </trans-unit>
        <trans-unit id="913d9fd2399cdf6e86c3e975d0cc5dad07465ec2" translate="yes" xml:space="preserve">
          <source>Optimize. Optimizing compilation takes somewhat more time, and a lot more memory for a large function.</source>
          <target state="translated">优化。优化编译需要更多的时间,对于一个大函数来说,需要更多的内存。</target>
        </trans-unit>
        <trans-unit id="e31d972229de381b461860014dd710856361917a" translate="yes" xml:space="preserve">
          <source>Option</source>
          <target state="translated">Option</target>
        </trans-unit>
        <trans-unit id="2c7ca22e5600046b144f3d24624f25c564332dee" translate="yes" xml:space="preserve">
          <source>Option Index</source>
          <target state="translated">选项指数</target>
        </trans-unit>
        <trans-unit id="30d4712df73ef1c0d4db51f2dbb5607ea375fe4b" translate="yes" xml:space="preserve">
          <source>Optional Return Value Pointer</source>
          <target state="translated">可选的返回值指针</target>
        </trans-unit>
        <trans-unit id="c12455d26a0da53c0d68029c9bf0819232e1f305" translate="yes" xml:space="preserve">
          <source>Options in &lt;var&gt;file&lt;/var&gt; are separated by whitespace. A whitespace character may be included in an option by surrounding the entire option in either single or double quotes. Any character (including a backslash) may be included by prefixing the character to be included with a backslash. The &lt;var&gt;file&lt;/var&gt; may itself contain additional @&lt;var&gt;file&lt;/var&gt; options; any such options will be processed recursively.</source>
          <target state="translated">&lt;var&gt;file&lt;/var&gt; 中的选项用空格分隔。通过将整个选项括在单引号或双引号中，可以在选项中包括空格字符。通过在要包含的字符前面加上反斜杠，可以包含任何字符（包括反斜杠）。该 &lt;var&gt;file&lt;/var&gt; 本身可能包含其他@ &lt;var&gt;file&lt;/var&gt; 选项；任何此类选项将被递归处理。</target>
        </trans-unit>
        <trans-unit id="4660151a0ebf47062b565d717689e53cf9ce9103" translate="yes" xml:space="preserve">
          <source>Options of the form</source>
          <target state="translated">形式的选项</target>
        </trans-unit>
        <trans-unit id="23bd069950c6d99802ae19186b5b3c8a35033589" translate="yes" xml:space="preserve">
          <source>Original Intel i386 CPU.</source>
          <target state="translated">原装英特尔i386 CPU。</target>
        </trans-unit>
        <trans-unit id="1a9a54bb04ec8317f6fd027b56dada4bf5eca84f" translate="yes" xml:space="preserve">
          <source>Os</source>
          <target state="translated">Os</target>
        </trans-unit>
        <trans-unit id="18bee9973a249c2e29e697cfeb7c675bf6ae3fa7" translate="yes" xml:space="preserve">
          <source>Other Alpha compilers provide the equivalent options called</source>
          <target state="translated">其他Alpha编译器提供了类似的选项,称为</target>
        </trans-unit>
        <trans-unit id="cd2bf473aa5d5250266aacf77c308456d1faabee" translate="yes" xml:space="preserve">
          <source>Other C compilers won&amp;rsquo;t accept these alternative keywords; if you want to compile with another compiler, you can define the alternate keywords as macros to replace them with the customary keywords. It looks like this:</source>
          <target state="translated">其他C编译器将不接受这些替代关键字。如果要使用其他编译器进行编译，则可以将备用关键字定义为宏，以将它们替换为常规关键字。看起来像这样：</target>
        </trans-unit>
        <trans-unit id="0ffe248f8b25bb61e4c3f0c71863b1ea1b623bad" translate="yes" xml:space="preserve">
          <source>Other C++ compilers may not correctly implement the standard behavior. As a result, when you switch to &lt;code&gt;g++&lt;/code&gt; from one of these compilers, you may discover that a program that appeared to work correctly in fact does not conform to the standard: &lt;code&gt;g++&lt;/code&gt; reports as undefined symbols any static data members that lack definitions.</source>
          <target state="translated">其他C ++编译器可能无法正确实现标准行为。结果，当您从这些编译器之一切换到 &lt;code&gt;g++&lt;/code&gt; ，您可能会发现一个看起来正常工作的程序实际上不符合该标准： &lt;code&gt;g++&lt;/code&gt; 将缺少定义的任何静态数据成员报告为未定义符号。</target>
        </trans-unit>
        <trans-unit id="f7754320d0468c70e98bda0da0fe360c850f2c18" translate="yes" xml:space="preserve">
          <source>Other VR4120 errata require a NOP to be inserted between certain pairs of instructions. These errata are handled by the assembler, not by GCC itself.</source>
          <target state="translated">其他的VR4120错误表要求在某些指令对之间插入NOP,这些错误表由汇编器处理,而不是由GCC本身处理。这些勘误是由汇编器处理的,而不是由GCC本身处理的。</target>
        </trans-unit>
        <trans-unit id="8c84374a07e7982abd1eda236f79d01355c7610a" translate="yes" xml:space="preserve">
          <source>Other attributes are defined for functions (see &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;Function Attributes&lt;/a&gt;), labels (see &lt;a href=&quot;label-attributes#Label-Attributes&quot;&gt;Label Attributes&lt;/a&gt;), enumerators (see &lt;a href=&quot;enumerator-attributes#Enumerator-Attributes&quot;&gt;Enumerator Attributes&lt;/a&gt;), statements (see &lt;a href=&quot;statement-attributes#Statement-Attributes&quot;&gt;Statement Attributes&lt;/a&gt;), and for variables (see &lt;a href=&quot;variable-attributes#Variable-Attributes&quot;&gt;Variable Attributes&lt;/a&gt;).</source>
          <target state="translated">还为函数（请参见&lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;函数属性&lt;/a&gt;），标签（请参见&lt;a href=&quot;label-attributes#Label-Attributes&quot;&gt;Label Attributes&lt;/a&gt;），枚举器（请参见&lt;a href=&quot;enumerator-attributes#Enumerator-Attributes&quot;&gt;Enumerator Attributes&lt;/a&gt;），语句（请参见&lt;a href=&quot;statement-attributes#Statement-Attributes&quot;&gt;Statement Attributes&lt;/a&gt;）和变量（请参见&lt;a href=&quot;variable-attributes#Variable-Attributes&quot;&gt;Variable Attributes&lt;/a&gt;）定义其他属性。</target>
        </trans-unit>
        <trans-unit id="c2a10075dec0d365de937669196a9657d9df8590" translate="yes" xml:space="preserve">
          <source>Other built-in functions.</source>
          <target state="translated">其他内置功能。</target>
        </trans-unit>
        <trans-unit id="ece657a55e4e8a32408fa84921a8230117870046" translate="yes" xml:space="preserve">
          <source>Other helpers:</source>
          <target state="translated">其他帮手。</target>
        </trans-unit>
        <trans-unit id="71f741ac380c3a470196d38432e10beb772eddbf" translate="yes" xml:space="preserve">
          <source>Other integer types, such as &lt;code&gt;long int&lt;/code&gt;, and enumerated types are permitted even in strictly conforming mode.</source>
          <target state="translated">即使在严格符合模式下，也允许使用其他整数类型，例如 &lt;code&gt;long int&lt;/code&gt; 和枚举类型。</target>
        </trans-unit>
        <trans-unit id="9b6d809c6085c6515fee8105cda39c6f0c8299d6" translate="yes" xml:space="preserve">
          <source>Other letters can be defined in machine-dependent fashion to stand for particular classes of registers or other arbitrary operand types. &amp;lsquo;</source>
          <target state="translated">可以以与机器有关的方式定义其他字母，以代表特定类别的寄存器或其他任意操作数类型。'</target>
        </trans-unit>
        <trans-unit id="31e826484120507f81d7b01e00ba111ce50563d4" translate="yes" xml:space="preserve">
          <source>Other letters in the range &amp;lsquo;</source>
          <target state="translated">范围内的其他字母</target>
        </trans-unit>
        <trans-unit id="79d2df03f3d88bfc6b34208de56c0d8f69fae24c" translate="yes" xml:space="preserve">
          <source>Other options are passed on to one or more stages of processing. Some options control the preprocessor and others the compiler itself. Yet other options control the assembler and linker; most of these are not documented here, since you rarely need to use any of them.</source>
          <target state="translated">其他选项被传递到一个或多个处理阶段。有些选项控制预处理器,有些则控制编译器本身。还有一些选项则控制汇编器和链接器;这里不对其中的大部分进行记录,因为你很少需要使用它们。</target>
        </trans-unit>
        <trans-unit id="58690e93570c04719b58436037bbfe7e9e889794" translate="yes" xml:space="preserve">
          <source>Other options such as</source>
          <target state="translated">其他选项,如</target>
        </trans-unit>
        <trans-unit id="b54d8cbfcf04d8c6ef55524abdd897e953dd52de" translate="yes" xml:space="preserve">
          <source>Other prefixes specified with</source>
          <target state="translated">指定的其他前缀</target>
        </trans-unit>
        <trans-unit id="12651a5c2964110c993acc911324809845963ccd" translate="yes" xml:space="preserve">
          <source>Otherwise, &lt;code&gt;false&lt;/code&gt; is returned and memory is affected according to &lt;var&gt;failure_memorder&lt;/var&gt;. This memory order cannot be &lt;code&gt;__ATOMIC_RELEASE&lt;/code&gt; nor &lt;code&gt;__ATOMIC_ACQ_REL&lt;/code&gt;. It also cannot be a stronger order than that specified by &lt;var&gt;success_memorder&lt;/var&gt;.</source>
          <target state="translated">否则，将根据 &lt;var&gt;failure_memorder&lt;/var&gt; 返回 &lt;code&gt;false&lt;/code&gt; 并影响内存。该内存顺序不能为 &lt;code&gt;__ATOMIC_RELEASE&lt;/code&gt; 或 &lt;code&gt;__ATOMIC_ACQ_REL&lt;/code&gt; 。它也不能比 &lt;var&gt;success_memorder&lt;/var&gt; 指定的顺序更强。</target>
        </trans-unit>
        <trans-unit id="0163f25dca25dd9eb232ac96989846b2be8a2890" translate="yes" xml:space="preserve">
          <source>Otherwise, an attribute specifier appears as part of a declaration, counting declarations of unnamed parameters and type names, and relates to that declaration (which may be nested in another declaration, for example in the case of a parameter declaration), or to a particular declarator within a declaration. Where an attribute specifier is applied to a parameter declared as a function or an array, it should apply to the function or array rather than the pointer to which the parameter is implicitly converted, but this is not yet correctly implemented.</source>
          <target state="translated">否则,属性指定符作为声明的一部分出现,计入未命名的参数和类型名的声明,并与该声明有关(该声明可能嵌套在另一个声明中,例如在参数声明的情况下),或与声明中的特定声明者有关。当一个属性指定符被应用于一个被声明为函数或数组的参数时,它应该应用于函数或数组,而不是隐式转换为参数的指针,但这一点还没有正确实现。</target>
        </trans-unit>
        <trans-unit id="9c5c46d604645721e578d5c70ebb88f027aaf128" translate="yes" xml:space="preserve">
          <source>Output &amp;lsquo;</source>
          <target state="translated">输出'</target>
        </trans-unit>
        <trans-unit id="647dcf3ef174bc80ea2e9689a611bd97a6a704cd" translate="yes" xml:space="preserve">
          <source>Output assembly instructions using selected &lt;var&gt;dialect&lt;/var&gt;. Also affects which dialect is used for basic &lt;code&gt;asm&lt;/code&gt; (see &lt;a href=&quot;basic-asm#Basic-Asm&quot;&gt;Basic Asm&lt;/a&gt;) and extended &lt;code&gt;asm&lt;/code&gt; (see &lt;a href=&quot;extended-asm#Extended-Asm&quot;&gt;Extended Asm&lt;/a&gt;). Supported choices (in dialect order) are &amp;lsquo;</source>
          <target state="translated">使用选定的 &lt;var&gt;dialect&lt;/var&gt; 输出汇编指令。还影响将哪种方言用于基本 &lt;code&gt;asm&lt;/code&gt; （请参阅&lt;a href=&quot;basic-asm#Basic-Asm&quot;&gt;Basic Asm&lt;/a&gt;）和扩展 &lt;code&gt;asm&lt;/code&gt; （请参阅&lt;a href=&quot;extended-asm#Extended-Asm&quot;&gt;Extended Asm&lt;/a&gt;）。支持的选项（按方言顺序）是&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="f8b5c88cee0a083c4b1b7974adc28656d2681e85" translate="yes" xml:space="preserve">
          <source>Output code for G-format floating-point numbers instead of D-format.</source>
          <target state="translated">用G格式的浮点数代替D格式的输出代码。</target>
        </trans-unit>
        <trans-unit id="e560ad077bfca12ce7d694879e9c015007ae41a0" translate="yes" xml:space="preserve">
          <source>Output constraints must begin with either &amp;lsquo;</source>
          <target state="translated">输出限制必须以&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="180883c60047df12608a1941cecf8662e8d97968" translate="yes" xml:space="preserve">
          <source>Output gcov file in an easy-to-parse JSON intermediate format which does not require source code for generation. The JSON file is compressed with gzip compression algorithm and the files have</source>
          <target state="translated">以易于解析的JSON中间格式输出gcov文件,生成时不需要源代码。JSON文件是用gzip压缩算法压缩的,文件的内容有</target>
        </trans-unit>
        <trans-unit id="9b6fcda59898207a429e1ef091692b9398444b1f" translate="yes" xml:space="preserve">
          <source>Output operand expressions must be lvalues. The compiler cannot check whether the operands have data types that are reasonable for the instruction being executed. For output expressions that are not directly addressable (for example a bit-field), the constraint must allow a register. In that case, GCC uses the register as the output of the &lt;code&gt;asm&lt;/code&gt;, and then stores that register into the output.</source>
          <target state="translated">输出操作数表达式必须为左值。编译器无法检查操作数是否具有对于正在执行的指令合理的数据类型。对于不能直接寻址的输出表达式（例如位字段），约束必须允许寄存器。在这种情况下，GCC将寄存器用作 &lt;code&gt;asm&lt;/code&gt; 的输出，然后将该寄存器存储到输出中。</target>
        </trans-unit>
        <trans-unit id="316859616622aa738df7e68ec92a5bb090fb360c" translate="yes" xml:space="preserve">
          <source>Output operands may not be &amp;ldquo;inserted&amp;rdquo; between existing stack registers. Since no 387 opcode uses a read/write operand, all output operands are dead before the &lt;code&gt;asm&lt;/code&gt;, and are pushed by the &lt;code&gt;asm&lt;/code&gt;. It makes no sense to push anywhere but the top of the reg-stack.</source>
          <target state="translated">输出操作数可能不会&amp;ldquo;插入&amp;rdquo;现有的堆栈寄存器之间。由于没有387操作码使用读/写操作数，因此所有输出操作数在 &lt;code&gt;asm&lt;/code&gt; 之前都是无效的，并由 &lt;code&gt;asm&lt;/code&gt; 推送。除了reg-stack的顶部以外，将其推入其他任何地方都没有任何意义。</target>
        </trans-unit>
        <trans-unit id="43f24935d9221797dfcb78b34d6cf08d867d6284" translate="yes" xml:space="preserve">
          <source>Output operands must specifically indicate which register an output appears in after an &lt;code&gt;asm&lt;/code&gt;. &amp;lsquo;</source>
          <target state="translated">输出操作数必须具体指出在 &lt;code&gt;asm&lt;/code&gt; 之后输出出现在哪个寄存器中。'</target>
        </trans-unit>
        <trans-unit id="faed737fa40fe25af4473d1b6bcfd0d0b292b68b" translate="yes" xml:space="preserve">
          <source>Output operands must start at the top of the reg-stack: output operands may not &amp;ldquo;skip&amp;rdquo; a register.</source>
          <target state="translated">输出操作数必须从寄存器堆栈的顶部开始：输出操作数可能不会&amp;ldquo;跳过&amp;rdquo;寄存器。</target>
        </trans-unit>
        <trans-unit id="a8b51102b411c12b6e0f93eb391fa91ba24693de" translate="yes" xml:space="preserve">
          <source>Output summaries for each function in addition to the file level summary.</source>
          <target state="translated">除了文件级摘要外,还输出每个函数的摘要。</target>
        </trans-unit>
        <trans-unit id="2f6f31ff885b55e9edb44a9bbaf83bcf540cfa80" translate="yes" xml:space="preserve">
          <source>Output the accumulated assembler options specified by</source>
          <target state="translated">输出由</target>
        </trans-unit>
        <trans-unit id="bca339912e193031f5941578cba2e8013cdc4fbe" translate="yes" xml:space="preserve">
          <source>Output the accumulated linker options specified by</source>
          <target state="translated">输出由</target>
        </trans-unit>
        <trans-unit id="abd07145d91464d8949250e737d08ee71cd3be75" translate="yes" xml:space="preserve">
          <source>Output the accumulated preprocessor options specified by</source>
          <target state="translated">输出累计的预处理器选项,由</target>
        </trans-unit>
        <trans-unit id="b0560621f7532768e8148f5f9549c378f9566ea1" translate="yes" xml:space="preserve">
          <source>Output to standard output instead of output files.</source>
          <target state="translated">输出到标准输出而不是输出文件。</target>
        </trans-unit>
        <trans-unit id="0ec497bb07e2cf136e8af2890004bae91d0a14be" translate="yes" xml:space="preserve">
          <source>Output to the given filename prototyped declarations for all functions declared and/or defined in a translation unit, including those in header files. This option is silently ignored in any language other than C.</source>
          <target state="translated">将翻译单元中声明和/或定义的所有函数(包括头文件中的函数)的原型声明输出到给定文件名。在C语言以外的任何语言中,这个选项都会被默默地忽略。</target>
        </trans-unit>
        <trans-unit id="62fca7a249d9dca7d004d8f4915abc2b5e965646" translate="yes" xml:space="preserve">
          <source>Outputs &amp;lsquo;</source>
          <target state="translated">输出'</target>
        </trans-unit>
        <trans-unit id="13d5c086d06fc973e45c927d40c8e059a1643032" translate="yes" xml:space="preserve">
          <source>Outputs a number that is unique to each instance of the &lt;code&gt;asm&lt;/code&gt; statement in the entire compilation. This option is useful when creating local labels and referring to them multiple times in a single template that generates multiple assembler instructions.</source>
          <target state="translated">输出整个编译过程中 &lt;code&gt;asm&lt;/code&gt; 语句的每个实例唯一的数字。当创建本地标签并在生成多个汇编指令的单个模板中多次引用它们时，此选项很有用。</target>
        </trans-unit>
        <trans-unit id="b7054dde1d20d86e88a5b1e9f1914cd2a35614b4" translate="yes" xml:space="preserve">
          <source>Outputs a single &amp;lsquo;</source>
          <target state="translated">输出单个&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="0dee1166c5edc6ac11a34fc79bdb2cb27916d9db" translate="yes" xml:space="preserve">
          <source>Outside strict ISO C mode (</source>
          <target state="translated">在严格的ISO C模式之外(</target>
        </trans-unit>
        <trans-unit id="dd7bd1ab4e4204054540331b82bdd3051fd1f8f8" translate="yes" xml:space="preserve">
          <source>Overall Options</source>
          <target state="translated">总体选择</target>
        </trans-unit>
        <trans-unit id="b4cd9a287c6914a99205f05078ac2e480bd2c7a2" translate="yes" xml:space="preserve">
          <source>Override the defaults for &lt;code&gt;bool&lt;/code&gt; so that &lt;code&gt;sizeof(bool)==1&lt;/code&gt;. By default &lt;code&gt;sizeof(bool)&lt;/code&gt; is &lt;code&gt;4&lt;/code&gt; when compiling for Darwin/PowerPC and &lt;code&gt;1&lt;/code&gt; when compiling for Darwin/x86, so this option has no effect on x86.</source>
          <target state="translated">覆盖 &lt;code&gt;bool&lt;/code&gt; 的默认值，以使 &lt;code&gt;sizeof(bool)==1&lt;/code&gt; 。默认情况下，对于Darwin / PowerPC编译， &lt;code&gt;sizeof(bool)&lt;/code&gt; 为 &lt;code&gt;4&lt;/code&gt; ，对于Darwin / x86编译，sizeof（bool）为 &lt;code&gt;1&lt;/code&gt; ，因此此选项对x86无效。</target>
        </trans-unit>
        <trans-unit id="a199208b37cd1f5b9a0a8191fd588411de91c2f1" translate="yes" xml:space="preserve">
          <source>Override the internal decision heuristic for the particular algorithm to use for inlining string operations. The allowed values for &lt;var&gt;alg&lt;/var&gt; are:</source>
          <target state="translated">重写用于内联字符串操作的特定算法的内部决策启发式方法。 &lt;var&gt;alg&lt;/var&gt; 的允许值为：</target>
        </trans-unit>
        <trans-unit id="725dd7b59f06dae5a8f87fd7ac1c6ed71f821187" translate="yes" xml:space="preserve">
          <source>Override the internal decision heuristic to decide if &lt;code&gt;__builtin_memcpy&lt;/code&gt; should be inlined and what inline algorithm to use when the expected size of the copy operation is known. &lt;var&gt;strategy&lt;/var&gt; is a comma-separated list of &lt;var&gt;alg&lt;/var&gt;:&lt;var&gt;max_size&lt;/var&gt;:&lt;var&gt;dest_align&lt;/var&gt; triplets. &lt;var&gt;alg&lt;/var&gt; is specified in</source>
          <target state="translated">覆盖内部决策启发式，以决定是否应内联 &lt;code&gt;__builtin_memcpy&lt;/code&gt; 以及在知道复制操作的预期大小时使用哪种内联算法。 &lt;var&gt;strategy&lt;/var&gt; 是逗号分隔的 &lt;var&gt;alg&lt;/var&gt; ： &lt;var&gt;max_size&lt;/var&gt; ： &lt;var&gt;dest_align&lt;/var&gt; 三胞胎列表。 &lt;var&gt;alg&lt;/var&gt; 在</target>
        </trans-unit>
        <trans-unit id="9b46c3db03a238d3f5a14ace1b604afe4e45f0cd" translate="yes" xml:space="preserve">
          <source>Override the underlying type for &lt;code&gt;wchar_t&lt;/code&gt; to be &lt;code&gt;short
unsigned int&lt;/code&gt; instead of the default for the target. This option is useful for building programs to run under WINE.</source>
          <target state="translated">覆盖基础类型 &lt;code&gt;wchar_t&lt;/code&gt; 的是 &lt;code&gt;short unsigned int&lt;/code&gt; ，而不是目标的缺省值。此选项对于构建要在WINE下运行的程序很有用。</target>
        </trans-unit>
        <trans-unit id="48df9e72f6c8bb00c7da9fa106f8a794bf0ae66b" translate="yes" xml:space="preserve">
          <source>Override tuning decisions made by the back-end in response to a</source>
          <target state="translated">覆盖由后端在响应于以下情况时做出的调整决定</target>
        </trans-unit>
        <trans-unit id="e7b14d3050ddec57bd832691acdae4f4799a4d96" translate="yes" xml:space="preserve">
          <source>Overrides the command-line option &lt;code&gt;-memregs=&lt;/code&gt; for the current file. Use with care! This pragma must be before any function in the file, and mixing different memregs values in different objects may make them incompatible. This pragma is useful when a performance-critical function uses a memreg for temporary values, as it may allow you to reduce the number of memregs used.</source>
          <target state="translated">覆盖当前文件的命令行选项 &lt;code&gt;-memregs=&lt;/code&gt; 。小心使用！该杂注必须在文件中的任何函数之前，并且在不同对象中混合不同的memregs值可能会使它们不兼容。当对性能至关重要的函数使用memreg作为临时值时，此实用程序很有用，因为它可以使您减少使用的memreg的数量。</target>
        </trans-unit>
        <trans-unit id="55a8f7943bb312b706050a92052877ddd19cd1fc" translate="yes" xml:space="preserve">
          <source>Overrides the command-line option &lt;code&gt;-mio-volatile&lt;/code&gt; for the current file. Note that for compatibility with future GCC releases, this option should only be used once before any &lt;code&gt;io&lt;/code&gt; variables in each file.</source>
          <target state="translated">覆盖当前文件的命令行选项 &lt;code&gt;-mio-volatile&lt;/code&gt; 。请注意，为了与将来的GCC版本兼容，每个文件中的任何 &lt;code&gt;io&lt;/code&gt; 变量之前只能使用一次此选项。</target>
        </trans-unit>
        <trans-unit id="511993d3c99719e38a6779073019dacd7178ddb9" translate="yes" xml:space="preserve">
          <source>P</source>
          <target state="translated">P</target>
        </trans-unit>
        <trans-unit id="80fce3cd5d10f70e9287dc65ad351b4cf54cdde0" translate="yes" xml:space="preserve">
          <source>P register</source>
          <target state="translated">P寄存器</target>
        </trans-unit>
        <trans-unit id="a1fd3d9945606c835489fdf8c9492b256385656d" translate="yes" xml:space="preserve">
          <source>P+</source>
          <target state="translated">P+</target>
        </trans-unit>
        <trans-unit id="76803f0adcbaf98d2e1e19d699c318fa770240a3" translate="yes" xml:space="preserve">
          <source>P-</source>
          <target state="translated">P-</target>
        </trans-unit>
        <trans-unit id="2b16716bc26fa1b19f59589aec2ebef33f5db5d7" translate="yes" xml:space="preserve">
          <source>PCC allows typedef names to be used as function parameters.</source>
          <target state="translated">PCC允许用typedef名作为函数参数。</target>
        </trans-unit>
        <trans-unit id="c246c3028d26fbb81d1a1f15dafa0622e6684f4e" translate="yes" xml:space="preserve">
          <source>PCC allows whitespace in the middle of compound assignment operators such as &amp;lsquo;</source>
          <target state="translated">PCC允许在复合赋值运算符（例如'</target>
        </trans-unit>
        <trans-unit id="0a6e19866b6bb2535a3f2c2dd0776aefd4accf5d" translate="yes" xml:space="preserve">
          <source>PCLMUL instructions.</source>
          <target state="translated">PCLMUL指令。</target>
        </trans-unit>
        <trans-unit id="6f863e0fedbf92ef4aea9ea322ccc2a547325ef5" translate="yes" xml:space="preserve">
          <source>PDP-11&amp;mdash;</source>
          <target state="translated">PDP-11&amp;mdash;</target>
        </trans-unit>
        <trans-unit id="8c50d8866e4321b0ad859637afa10d6ead05148c" translate="yes" xml:space="preserve">
          <source>POPCNT instruction.</source>
          <target state="translated">POPCNT指令。</target>
        </trans-unit>
        <trans-unit id="3ebc8ebc50e3a46fda8970768cc6e859e914444f" translate="yes" xml:space="preserve">
          <source>PRU&amp;mdash;</source>
          <target state="translated">PRU&amp;mdash;</target>
        </trans-unit>
        <trans-unit id="e2d341dab357c92fea1cc61d3e72cb6281d41c97" translate="yes" xml:space="preserve">
          <source>PTRDIFF_MAX</source>
          <target state="translated">PTRDIFF_MAX</target>
        </trans-unit>
        <trans-unit id="7ec74130044a66b80c889b01a82126dc008750ff" translate="yes" xml:space="preserve">
          <source>Pack VLIW instructions.</source>
          <target state="translated">包装VLIW说明。</target>
        </trans-unit>
        <trans-unit id="dd44725ed2025ff2e1a97e1f2348c9d1ca8f2c1f" translate="yes" xml:space="preserve">
          <source>Pad with NOPs any dispatch group that has vacant issue slots, according to the scheduler&amp;rsquo;s grouping.</source>
          <target state="translated">根据调度程序的分组，将NOP填充到具有空闲发行版位的任何调度组。</target>
        </trans-unit>
        <trans-unit id="2372cf312ccb9c8b03aea17e3c79e0a1982f2394" translate="yes" xml:space="preserve">
          <source>Pair lower lower (&lt;code&gt;pll.ps&lt;/code&gt;).</source>
          <target state="translated">配对较低较低（ &lt;code&gt;pll.ps&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="f740b666193926024898bc0d930212a406bee8c8" translate="yes" xml:space="preserve">
          <source>Pair lower upper (&lt;code&gt;plu.ps&lt;/code&gt;).</source>
          <target state="translated">配对较低的鞋帮（ &lt;code&gt;plu.ps&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="9eedbb6f660ceda1616660d44dce629298a3b655" translate="yes" xml:space="preserve">
          <source>Pair upper lower (&lt;code&gt;pul.ps&lt;/code&gt;).</source>
          <target state="translated">配对上下部（ &lt;code&gt;pul.ps&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="5e0770dcfd7cae26e45306dd9f097f8dbb0edbc8" translate="yes" xml:space="preserve">
          <source>Pair upper upper (&lt;code&gt;puu.ps&lt;/code&gt;).</source>
          <target state="translated">配对上部鞋帮（ &lt;code&gt;puu.ps&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="ac1dfe5c81f3c8f3e57c17faae475d9260a62249" translate="yes" xml:space="preserve">
          <source>Parallelize loops, i.e., split their iteration space to run in n threads. This is only possible for loops whose iterations are independent and can be arbitrarily reordered. The optimization is only profitable on multiprocessor machines, for loops that are CPU-intensive, rather than constrained e.g. by memory bandwidth. This option implies</source>
          <target state="translated">并行化循环,即分割其迭代空间以n个线程运行。这只适用于迭代独立且可以任意重新排序的循环。只有在多处理器机器上,对于CPU密集型的循环,而不是受内存带宽等限制的循环,这种优化才是有利的。这个选项意味着</target>
        </trans-unit>
        <trans-unit id="a975eea30db9fa05003e3b5097688bd49ec7e01b" translate="yes" xml:space="preserve">
          <source>Parameters</source>
          <target state="translated">Parameters</target>
        </trans-unit>
        <trans-unit id="00310a3d64efc1d0ab28741454559ddf52284d4c" translate="yes" xml:space="preserve">
          <source>Parameters of this option are analogous to the</source>
          <target state="translated">这个选项的参数类似于</target>
        </trans-unit>
        <trans-unit id="ed89c3a81f547cc64d254621a2e80d0b09920687" translate="yes" xml:space="preserve">
          <source>Partial Store Order</source>
          <target state="translated">部分店铺订单</target>
        </trans-unit>
        <trans-unit id="26760520407ec598057e0350ad5e24f9ca068704" translate="yes" xml:space="preserve">
          <source>Pass &lt;var&gt;option&lt;/var&gt; as an option to the assembler. If &lt;var&gt;option&lt;/var&gt; contains commas, it is split into multiple options at the commas.</source>
          <target state="translated">通过 &lt;var&gt;option&lt;/var&gt; 作为一个选项，以汇编。如果 &lt;var&gt;option&lt;/var&gt; 包含逗号，则会在逗号处将其拆分为多个选项。</target>
        </trans-unit>
        <trans-unit id="2d87e9abac2f57600cdd7d5c2efaf0f6e66f628c" translate="yes" xml:space="preserve">
          <source>Pass &lt;var&gt;option&lt;/var&gt; as an option to the assembler. You can use this to supply system-specific assembler options that GCC does not recognize.</source>
          <target state="translated">通过 &lt;var&gt;option&lt;/var&gt; 作为一个选项，以汇编。您可以使用它来提供GCC无法识别的系统特定的汇编器选项。</target>
        </trans-unit>
        <trans-unit id="ea3ae9b22cd6a0097fe66cc5d0b0c7c77b1e7361" translate="yes" xml:space="preserve">
          <source>Pass &lt;var&gt;option&lt;/var&gt; as an option to the linker. If &lt;var&gt;option&lt;/var&gt; contains commas, it is split into multiple options at the commas. You can use this syntax to pass an argument to the option. For example,</source>
          <target state="translated">通过 &lt;var&gt;option&lt;/var&gt; 作为链接器的选项。如果 &lt;var&gt;option&lt;/var&gt; 包含逗号，则会在逗号处将其拆分为多个选项。您可以使用此语法将参数传递给选项。例如，</target>
        </trans-unit>
        <trans-unit id="3b76a14ce88deda8b639a199af148cdc191f52bb" translate="yes" xml:space="preserve">
          <source>Pass &lt;var&gt;option&lt;/var&gt; as an option to the linker. You can use this to supply system-specific linker options that GCC does not recognize.</source>
          <target state="translated">通过 &lt;var&gt;option&lt;/var&gt; 作为链接器的选项。您可以使用它来提供GCC无法识别的特定于系统的链接器选项。</target>
        </trans-unit>
        <trans-unit id="2d7525a4e6f37e298e13e376428f81521ebcf0ad" translate="yes" xml:space="preserve">
          <source>Pass &lt;var&gt;option&lt;/var&gt; as an option to the preprocessor. You can use this to supply system-specific preprocessor options that GCC does not recognize.</source>
          <target state="translated">通过 &lt;var&gt;option&lt;/var&gt; 作为预处理器的选项。您可以使用它来提供GCC无法识别的特定于系统的预处理器选项。</target>
        </trans-unit>
        <trans-unit id="3d4c02ac25f95e4b321bd7c365e291db31eb2591" translate="yes" xml:space="preserve">
          <source>Pass on (or do not pass on) the</source>
          <target state="translated">传承(或不传)。</target>
        </trans-unit>
        <trans-unit id="ebcca6f4e1a3875b263182927c19bae27d56304e" translate="yes" xml:space="preserve">
          <source>Pass the flag</source>
          <target state="translated">传旗</target>
        </trans-unit>
        <trans-unit id="edb98a025d28cabbd69e003e051e7e9e248d058f" translate="yes" xml:space="preserve">
          <source>Passed down to the assembler to enable dual- and single-operand instructions for telephony. Also sets the preprocessor symbol &lt;code&gt;__Xtelephony&lt;/code&gt;. This option is deprecated.</source>
          <target state="translated">传递给汇编器以启用电话的双操作数和单操作数指令。还设置预处理器符号 &lt;code&gt;__Xtelephony&lt;/code&gt; 。不建议使用此选项。</target>
        </trans-unit>
        <trans-unit id="f90bde4ab81702f82c3a14c8f169a594acac87bc" translate="yes" xml:space="preserve">
          <source>Passed down to the assembler to enable the 64-bit time-stamp counter extension instruction. Also sets the preprocessor symbol &lt;code&gt;__Xrtsc&lt;/code&gt;. This option is deprecated.</source>
          <target state="translated">传递给汇编器以启用64位时间戳计数器扩展指令。还设置预处理器符号 &lt;code&gt;__Xrtsc&lt;/code&gt; 。不建议使用此选项。</target>
        </trans-unit>
        <trans-unit id="4f8b46d31a4a12bcb7d5a9b4c4bc5f82313d8a46" translate="yes" xml:space="preserve">
          <source>Passed down to the assembler to enable the DSP Pack A extensions. Also sets the preprocessor symbol &lt;code&gt;__Xdsp_packa&lt;/code&gt;. This option is deprecated.</source>
          <target state="translated">传递给汇编器以启用DSP Pack A扩展。还设置预处理器符号 &lt;code&gt;__Xdsp_packa&lt;/code&gt; 。不建议使用此选项。</target>
        </trans-unit>
        <trans-unit id="437ce81938361281bc7bdc1ba1109fae98afde5d" translate="yes" xml:space="preserve">
          <source>Passed down to the assembler to enable the XY memory extension. Also sets the preprocessor symbol &lt;code&gt;__Xxy&lt;/code&gt;.</source>
          <target state="translated">传递给汇编器以启用XY内存扩展。还设置预处理器符号 &lt;code&gt;__Xxy&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="192f1963f648220379d598033602fa765954e9e1" translate="yes" xml:space="preserve">
          <source>Passed down to the assembler to enable the dual Viterbi butterfly extension. Also sets the preprocessor symbol &lt;code&gt;__Xdvbf&lt;/code&gt;. This option is deprecated.</source>
          <target state="translated">传递给汇编器以启用双维特比蝶形扩展。还设置预处理器符号 &lt;code&gt;__Xdvbf&lt;/code&gt; 。不建议使用此选项。</target>
        </trans-unit>
        <trans-unit id="e120edac277c94aa8119101f86b7c6a0712b9fcc" translate="yes" xml:space="preserve">
          <source>Passed down to the assembler to enable the locked load/store conditional extension. Also sets the preprocessor symbol &lt;code&gt;__Xlock&lt;/code&gt;.</source>
          <target state="translated">传递给汇编器以启用锁定的加载/存储条件扩展。还设置预处理器符号 &lt;code&gt;__Xlock&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2ba98472aa75cacca4b08108732162c8ba249643" translate="yes" xml:space="preserve">
          <source>Passed down to the assembler to enable the swap byte ordering extension instruction. Also sets the preprocessor symbol &lt;code&gt;__Xswape&lt;/code&gt;.</source>
          <target state="translated">传递给汇编器以启用交换字节顺序扩展指令。还设置预处理器符号 &lt;code&gt;__Xswape&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6ad82551672605333a9c6ede433a1e6a6d571936" translate="yes" xml:space="preserve">
          <source>Passed down to the assembler. Also sets the preprocessor symbol &lt;code&gt;__Xxmac_24&lt;/code&gt;. This option is deprecated.</source>
          <target state="translated">传递给汇编器。还设置预处理器符号 &lt;code&gt;__Xxmac_24&lt;/code&gt; 。不建议使用此选项。</target>
        </trans-unit>
        <trans-unit id="b5b5c4c5c6dc85e300e5d3da99c217798b87ef15" translate="yes" xml:space="preserve">
          <source>Passed down to the assembler. Also sets the preprocessor symbol &lt;code&gt;__Xxmac_d16&lt;/code&gt;. This option is deprecated.</source>
          <target state="translated">传递给汇编器。还设置预处理器符号 &lt;code&gt;__Xxmac_d16&lt;/code&gt; 。不建议使用此选项。</target>
        </trans-unit>
        <trans-unit id="8e378b2ec7874c891a1160d052f02fb0e9162569" translate="yes" xml:space="preserve">
          <source>Passed through to the linker, to specify use of the &lt;code&gt;arclinux&lt;/code&gt; emulation. This option is enabled by default in tool chains built for &lt;code&gt;arc-linux-uclibc&lt;/code&gt; and &lt;code&gt;arceb-linux-uclibc&lt;/code&gt; targets when profiling is not requested.</source>
          <target state="translated">传递给链接器，以指定使用 &lt;code&gt;arclinux&lt;/code&gt; 仿真。默认情况下，当不要求进行概要分析时，在为 &lt;code&gt;arc-linux-uclibc&lt;/code&gt; 和 &lt;code&gt;arceb-linux-uclibc&lt;/code&gt; 目标构建的工具链中默认启用此选项。</target>
        </trans-unit>
        <trans-unit id="a028490f082637af1740d556712c0ce06eb5a830" translate="yes" xml:space="preserve">
          <source>Passed through to the linker, to specify use of the &lt;code&gt;arclinux_prof&lt;/code&gt; emulation. This option is enabled by default in tool chains built for &lt;code&gt;arc-linux-uclibc&lt;/code&gt; and &lt;code&gt;arceb-linux-uclibc&lt;/code&gt; targets when profiling is requested.</source>
          <target state="translated">传递给链接器，以指定使用 &lt;code&gt;arclinux_prof&lt;/code&gt; 仿真。请求分析时，在为 &lt;code&gt;arc-linux-uclibc&lt;/code&gt; 和 &lt;code&gt;arceb-linux-uclibc&lt;/code&gt; 目标构建的工具链中，默认情况下启用此选项。</target>
        </trans-unit>
        <trans-unit id="fd42d8d9c3b5bd99cdf57029443caa7831c5b611" translate="yes" xml:space="preserve">
          <source>Passes that use the dataflow information are enabled independently at different optimization levels.</source>
          <target state="translated">使用数据流信息的通道在不同的优化级别上独立启用。</target>
        </trans-unit>
        <trans-unit id="df4603bbe9d05798f6607572b723fee8e9240d5c" translate="yes" xml:space="preserve">
          <source>Passing</source>
          <target state="translated">Passing</target>
        </trans-unit>
        <trans-unit id="ca1bab93bc155d4bc9f92ddda956825855fee474" translate="yes" xml:space="preserve">
          <source>Passing options to the assembler.</source>
          <target state="translated">将选项传递给汇编器。</target>
        </trans-unit>
        <trans-unit id="a82f31d7c90d96412082c64503f9dcd5d50cd894" translate="yes" xml:space="preserve">
          <source>Passing parameters to or from Basic &lt;code&gt;asm&lt;/code&gt;</source>
          <target state="translated">将参数传递给Basic &lt;code&gt;asm&lt;/code&gt; 或从中传递参数</target>
        </trans-unit>
        <trans-unit id="a7301fd43d902ef4b0d5fbb8c15e6456832236d7" translate="yes" xml:space="preserve">
          <source>Passing parameters to or from Extended &lt;code&gt;asm&lt;/code&gt; without using input or output operands.</source>
          <target state="translated">在不使用输入或输出操作数的情况下，将参数传递给扩展 &lt;code&gt;asm&lt;/code&gt; 或从扩展asm传递参数。</target>
        </trans-unit>
        <trans-unit id="f36b9a29c6322b4f073965f6981e3c605c717562" translate="yes" xml:space="preserve">
          <source>Passing parameters to or from routines written in assembler (or other languages) using non-standard calling conventions.</source>
          <target state="translated">使用非标准的调用约定,向使用汇编器(或其他语言)编写的例程传递参数或从例程传递参数。</target>
        </trans-unit>
        <trans-unit id="8340576084abc7513cb9511dd3a179bdd58bea84" translate="yes" xml:space="preserve">
          <source>Path specified by the environment variable &amp;lsquo;</source>
          <target state="translated">环境变量'指定的路径</target>
        </trans-unit>
        <trans-unit id="2b8053a12982c8b5e19f801216dbc51afcd39aab" translate="yes" xml:space="preserve">
          <source>Pay special attention to code like this:</source>
          <target state="translated">要特别注意这样的代码。</target>
        </trans-unit>
        <trans-unit id="ce53b63c4327f47412072347ed7949c1656ab556" translate="yes" xml:space="preserve">
          <source>Peels loops for which there is enough information that they do not roll much (from profile feedback or static analysis). It also turns on complete loop peeling (i.e. complete removal of loops with small constant number of iterations).</source>
          <target state="translated">剥离那些有足够信息表明它们不会滚动的环路(从轮廓反馈或静态分析)。它还可以开启完整的环路剥离(即用少量的恒定迭代次数完全去除环路)。</target>
        </trans-unit>
        <trans-unit id="10555cda3fcf7df8cd08616e7d5db51df194941b" translate="yes" xml:space="preserve">
          <source>People who have contributed to GCC.</source>
          <target state="translated">对海合会有贡献的人。</target>
        </trans-unit>
        <trans-unit id="f13a48860e36bb0177b534cc2a15b3b114032ea9" translate="yes" xml:space="preserve">
          <source>Per-thread variables.</source>
          <target state="translated">每线程变量。</target>
        </trans-unit>
        <trans-unit id="73545218d23922d3a876b5c815bc65525793f423" translate="yes" xml:space="preserve">
          <source>Percentage penalty functions containing a single call to another function will receive when they are evaluated for cloning.</source>
          <target state="translated">包含对另一个函数的单次调用的函数在被评估为克隆函数时将收到的惩罚百分比。</target>
        </trans-unit>
        <trans-unit id="dcfc68277a1e2c4d9091b21b46740ae70e4d5a9c" translate="yes" xml:space="preserve">
          <source>Percentage penalty the recursive functions will receive when they are evaluated for cloning.</source>
          <target state="translated">当递归函数被评估为克隆时,它们将收到的惩罚百分比。</target>
        </trans-unit>
        <trans-unit id="b1bfacd8c51fd20af1a996d2b1c9005f74a8a0d2" translate="yes" xml:space="preserve">
          <source>Perform Identical Code Folding for functions and read-only variables. The optimization reduces code size and may disturb unwind stacks by replacing a function by equivalent one with a different name. The optimization works more effectively with link-time optimization enabled.</source>
          <target state="translated">对函数和只读变量进行相同代码折叠。该优化减少了代码大小,并且可能会通过用不同名称的等价函数替换函数来扰乱解卷堆栈。启用链接时间优化后,该优化更有效。</target>
        </trans-unit>
        <trans-unit id="a6a8c1431d58909bfaffe9050c8733ea996d20bc" translate="yes" xml:space="preserve">
          <source>Perform Value Range Propagation on trees. This is similar to the constant propagation pass, but instead of values, ranges of values are propagated. This allows the optimizers to remove unnecessary range checks like array bound checks and null pointer checks. This is enabled by default at</source>
          <target state="translated">对树进行值范围传播。这与常量传播传递类似,但传播的不是值,而是值的范围。这允许优化器删除不必要的范围检查,如数组绑定检查和空指针检查。这在默认情况下是启用的</target>
        </trans-unit>
        <trans-unit id="f11a18844b7820edfc7cfe8256d4e394a5329f58" translate="yes" xml:space="preserve">
          <source>Perform a 128-bit IEEE floating point add using round to odd as the rounding mode.</source>
          <target state="translated">使用四舍五入到奇数作为四舍五入模式,执行128位IEEE浮点加法。</target>
        </trans-unit>
        <trans-unit id="ad630415b45adc0f11ff88c9ad397123e4ccfb1f" translate="yes" xml:space="preserve">
          <source>Perform a 128-bit IEEE floating point divide using round to odd as the rounding mode.</source>
          <target state="translated">执行128位IEEE浮点除法,使用四舍五入到奇数作为四舍五入模式。</target>
        </trans-unit>
        <trans-unit id="21b7a42855f16a63bf420afa4550fc9d4fc080ac" translate="yes" xml:space="preserve">
          <source>Perform a 128-bit IEEE floating point fused multiply and add operation using round to odd as the rounding mode.</source>
          <target state="translated">执行128位IEEE浮点融合乘法和加法运算,使用舍入到奇数作为舍入模式。</target>
        </trans-unit>
        <trans-unit id="37ed36e9d63104743cea777f5e55fc078dfd943b" translate="yes" xml:space="preserve">
          <source>Perform a 128-bit IEEE floating point multiply using round to odd as the rounding mode.</source>
          <target state="translated">使用四舍五入到奇数作为四舍五入模式,执行128位IEEE浮点乘法。</target>
        </trans-unit>
        <trans-unit id="737a589634f68c1da9ecbd09594b87b83ec0aa7c" translate="yes" xml:space="preserve">
          <source>Perform a 128-bit IEEE floating point square root using round to odd as the rounding mode.</source>
          <target state="translated">使用四舍五入到奇数作为四舍五入模式,执行128位IEEE浮点平方根。</target>
        </trans-unit>
        <trans-unit id="ead0f18b8a1f24823972492647bc71a9e31e2c4a" translate="yes" xml:space="preserve">
          <source>Perform a 128-bit IEEE floating point subtract using round to odd as the rounding mode.</source>
          <target state="translated">执行128位IEEE浮点减法,使用四舍五入到奇数作为四舍五入模式。</target>
        </trans-unit>
        <trans-unit id="68de9811e50d3937c1ad606957f9ce3a651afee7" translate="yes" xml:space="preserve">
          <source>Perform a forward propagation pass on RTL. The pass tries to combine two instructions and checks if the result can be simplified. If loop unrolling is active, two passes are performed and the second is scheduled after loop unrolling.</source>
          <target state="translated">在RTL上执行前向传播传递。该通证尝试将两条指令合并,并检查结果是否可以简化。如果循环展开是活动的,则执行两次传递,第二次传递安排在循环展开之后。</target>
        </trans-unit>
        <trans-unit id="6dba988e88741e74ba501068678e1ab16f88bb77" translate="yes" xml:space="preserve">
          <source>Perform a global common subexpression elimination pass. This pass also performs global constant and copy propagation.</source>
          <target state="translated">执行全局通用子表达式消除传递。该通证还执行全局常量和复制传播。</target>
        </trans-unit>
        <trans-unit id="d64787311f720e83d55ee7c16d5127e619d4c2d5" translate="yes" xml:space="preserve">
          <source>Perform a number of minor optimizations that are relatively expensive.</source>
          <target state="translated">进行一些相对昂贵的小优化。</target>
        </trans-unit>
        <trans-unit id="e4ef7411a4a596cce036263deed71704a6a4403d" translate="yes" xml:space="preserve">
          <source>Perform a variety of simple scalar cleanups (constant/copy propagation, redundancy elimination, range propagation and expression simplification) based on a dominator tree traversal. This also performs jump threading (to reduce jumps to jumps). This flag is enabled by default at</source>
          <target state="translated">基于主宰树遍历执行各种简单的标量清理(常量/副本传播、冗余消除、范围传播和表达式简化)。这也会执行跳线程(以减少跳转到跳转)。这个标志默认在</target>
        </trans-unit>
        <trans-unit id="c690704255c1ecf4d6857e6000f1190b108f7ea6" translate="yes" xml:space="preserve">
          <source>Perform basic block vectorization on trees. This flag is enabled by default at</source>
          <target state="translated">在树上执行基本的块向量化。这个标志默认在</target>
        </trans-unit>
        <trans-unit id="eeac5885ee87ab9527e79d1e7e4c5d0a5ab9cfee" translate="yes" xml:space="preserve">
          <source>Perform branch target register load optimization after prologue / epilogue threading.</source>
          <target state="translated">在序幕/序幕线程后执行分支目标寄存器加载优化。</target>
        </trans-unit>
        <trans-unit id="f22ee925531c470bf10c56d8ec49b3ad79443d58" translate="yes" xml:space="preserve">
          <source>Perform branch target register load optimization before prologue / epilogue threading. The use of target registers can typically be exposed only during reload, thus hoisting loads out of loops and doing inter-block scheduling needs a separate optimization pass.</source>
          <target state="translated">在序幕/序幕线程之前执行分支目标寄存器负载优化。目标寄存器的使用通常只能在重载期间暴露,因此将负载从循环中提升出来并进行块间调度需要单独的优化通道。</target>
        </trans-unit>
        <trans-unit id="78ecf7dff1475297797e70aa8e37b17a7fe0ba23" translate="yes" xml:space="preserve">
          <source>Perform code hoisting. Code hoisting tries to move the evaluation of expressions executed on all paths to the function exit as early as possible. This is especially useful as a code size optimization, but it often helps for code speed as well. This flag is enabled by default at</source>
          <target state="translated">执行代码提升。代码提升试图将所有路径上执行的表达式的评估尽可能早地移到函数出口。这对于优化代码大小特别有用,但也有助于提高代码速度。这个标志默认在</target>
        </trans-unit>
        <trans-unit id="d42beff05151efc426a83c25d60382c077faa4d8" translate="yes" xml:space="preserve">
          <source>Perform conditional dead code elimination (DCE) for calls to built-in functions that may set &lt;code&gt;errno&lt;/code&gt; but are otherwise free of side effects. This flag is enabled by default at</source>
          <target state="translated">对可能设置 &lt;code&gt;errno&lt;/code&gt; 但没有副作用的内置函数的调用执行条件死代码消除（DCE）。默认情况下，此标志处于启用状态</target>
        </trans-unit>
        <trans-unit id="3acf0b56088845895309ffb7ff3f62580c187452" translate="yes" xml:space="preserve">
          <source>Perform conversion of simple initializations in a switch to initializations from a scalar array. This flag is enabled by default at</source>
          <target state="translated">将开关中的简单初始化转换为标量数组的初始化。这个标志默认在</target>
        </trans-unit>
        <trans-unit id="76903ec0550edaa382bc63ed2ba99b071ffdb752" translate="yes" xml:space="preserve">
          <source>Perform copy propagation on trees. This pass eliminates unnecessary copy operations. This flag is enabled by default at</source>
          <target state="translated">对树进行复制传播。这个传递可以消除不必要的复制操作。这个标志默认在</target>
        </trans-unit>
        <trans-unit id="6d7ec7c39be13500a07e954c10fb63594d459307" translate="yes" xml:space="preserve">
          <source>Perform cross-jumping transformation. This transformation unifies equivalent code and saves code size. The resulting code may or may not perform better than without cross-jumping.</source>
          <target state="translated">进行交叉跳转变换。这种转换统一了等价代码,节省了代码大小。由此产生的代码可能比没有交叉跳跃的代码性能更好,也可能没有。</target>
        </trans-unit>
        <trans-unit id="f21edf0cd1996b67db995a9d0465125524c66c2d" translate="yes" xml:space="preserve">
          <source>Perform dead code elimination (DCE) on RTL. Enabled by default at</source>
          <target state="translated">在RTL上执行死码消除(DCE)。默认在</target>
        </trans-unit>
        <trans-unit id="3dbd69c046baefc1f0428ff45ebf37c050ee9b35" translate="yes" xml:space="preserve">
          <source>Perform dead code elimination (DCE) on trees. This flag is enabled by default at</source>
          <target state="translated">在树上执行死码消除(DCE)。这个标志默认在</target>
        </trans-unit>
        <trans-unit id="1fac6b62e0201c67a765b9639bb451910616441d" translate="yes" xml:space="preserve">
          <source>Perform dead store elimination (DSE) on RTL. Enabled by default at</source>
          <target state="translated">在RTL上执行死存储消除(DSE)。默认在</target>
        </trans-unit>
        <trans-unit id="9c91758280f32089239ead4d20b5ec849be15a87" translate="yes" xml:space="preserve">
          <source>Perform dead store elimination (DSE) on trees. A dead store is a store into a memory location that is later overwritten by another store without any intervening loads. In this case the earlier store can be deleted. This flag is enabled by default at</source>
          <target state="translated">对树进行死存储消除(DSE)。死存储是指进入内存位置的存储,后来被另一个存储覆盖,没有任何中间的负载。在这种情况下,先前的存储可以被删除。默认情况下,这个标志在</target>
        </trans-unit>
        <trans-unit id="753e71f3a5ff6388d6a57662208a4d8d6dc2cf2a" translate="yes" xml:space="preserve">
          <source>Perform final value replacement. If a variable is modified in a loop in such a way that its value when exiting the loop can be determined using only its initial value and the number of loop iterations, replace uses of the final value by such a computation, provided it is sufficiently cheap. This reduces data dependencies and may allow further simplifications. Enabled by default at</source>
          <target state="translated">进行终值替换。如果一个变量在循环中被修改,以致于它退出循环时的值只能用它的初始值和循环迭代次数来确定,那么用这样的计算来替换最终值的使用,只要它足够便宜。这减少了数据的依赖性,可能允许进一步简化。默认在</target>
        </trans-unit>
        <trans-unit id="70b6a364a52abbfd9ee8ac29b5164966fafd5f6e" translate="yes" xml:space="preserve">
          <source>Perform forward propagation on trees. This flag is enabled by default at</source>
          <target state="translated">在树上执行前向传播。这个标志默认在</target>
        </trans-unit>
        <trans-unit id="673d903cfc5f5e6d5fb3bb1eee0f4c9f6c48077e" translate="yes" xml:space="preserve">
          <source>Perform forward store motion on trees. This flag is enabled by default at</source>
          <target state="translated">在树上执行正向存储运动。这个标志默认在</target>
        </trans-unit>
        <trans-unit id="d36329f87f0281004169238a916fdfdf7420040e" translate="yes" xml:space="preserve">
          <source>Perform full redundancy elimination (FRE) on trees. The difference between FRE and PRE is that FRE only considers expressions that are computed on all paths leading to the redundant computation. This analysis is faster than PRE, though it exposes fewer redundancies. This flag is enabled by default at</source>
          <target state="translated">对树进行全冗余消除(FRE)。FRE和PRE的区别在于,FRE只考虑在所有通往冗余计算的路径上计算的表达式。这种分析比PRE快,尽管它暴露的冗余更少。这个标志默认在</target>
        </trans-unit>
        <trans-unit id="3f354c46e4dde1d877eb683cb0a6100f2cbc4bca" translate="yes" xml:space="preserve">
          <source>Perform function cloning to make interprocedural constant propagation stronger. When enabled, interprocedural constant propagation performs function cloning when externally visible function can be called with constant arguments. Because this optimization can create multiple copies of functions, it may significantly increase code size (see</source>
          <target state="translated">执行函数克隆,使程序间常数传播更强。启用后,当外部可见的函数可以用常量参数调用时,程序间常量传播会执行函数克隆。由于该优化可以创建多个函数的副本,因此可能会显著增加代码大小(见</target>
        </trans-unit>
        <trans-unit id="154c76319b0c62d9b2e90e2513183f271e8cf0cd" translate="yes" xml:space="preserve">
          <source>Perform function-local points-to analysis on trees. This flag is enabled by default at</source>
          <target state="translated">在树上执行函数局部点对点分析。这个标志默认在</target>
        </trans-unit>
        <trans-unit id="56af57ea7e8c24ebc43912154747d0770817c691" translate="yes" xml:space="preserve">
          <source>Perform hoisting of loads from conditional pointers on trees. This pass is enabled by default at</source>
          <target state="translated">从树上的条件指针执行负载提升。这个通道默认在</target>
        </trans-unit>
        <trans-unit id="4ab70db777954340ed7abb290ec401d3cad6d79c" translate="yes" xml:space="preserve">
          <source>Perform induction variable optimizations (strength reduction, induction variable merging and induction variable elimination) on trees.</source>
          <target state="translated">对树进行诱导变量优化(强度降低、诱导变量合并和诱导变量消除)。</target>
        </trans-unit>
        <trans-unit id="1073eeaaee6148009c2caccc4b4d6c7d341bbb2f" translate="yes" xml:space="preserve">
          <source>Perform interprocedural constant propagation. This optimization analyzes the program to determine when values passed to functions are constants and then optimizes accordingly. This optimization can substantially increase performance if the application has constants passed to functions. This flag is enabled by default at</source>
          <target state="translated">进行程序间常量传播。该优化分析程序以确定何时传递给函数的值是常量,然后进行相应的优化。如果应用程序有常量传递给函数,这种优化可以大幅提高性能。该标志默认在</target>
        </trans-unit>
        <trans-unit id="20c997fc23010523f8221d0a92c5b9e6c4050935" translate="yes" xml:space="preserve">
          <source>Perform interprocedural pointer analysis and interprocedural modification and reference analysis. This option can cause excessive memory and compile-time usage on large compilation units. It is not enabled by default at any optimization level.</source>
          <target state="translated">执行程序间指针分析和程序间修改和引用分析。在大型编译单元上,该选项可能会导致内存和编译时的过度使用。在任何优化级别上,默认情况下都不启用该选项。</target>
        </trans-unit>
        <trans-unit id="4921214a12f7612e4410a372e1807efabe260fc7" translate="yes" xml:space="preserve">
          <source>Perform interprocedural profile propagation. The functions called only from cold functions are marked as cold. Also functions executed once (such as &lt;code&gt;cold&lt;/code&gt;, &lt;code&gt;noreturn&lt;/code&gt;, static constructors or destructors) are identified. Cold functions and loop less parts of functions executed once are then optimized for size. Enabled by default at</source>
          <target state="translated">执行过程间轮廓传播。仅从冷函数调用的函数标记为冷。还可以识别一次执行的函数（例如 &lt;code&gt;cold&lt;/code&gt; ， &lt;code&gt;noreturn&lt;/code&gt; ，static构造函数或析构函数）。然后对冷函数和循环执行的函数的较少部分进行大小优化。默认情况下启用</target>
        </trans-unit>
        <trans-unit id="fb68f0d0ee8b6c41ae81d56a47219400b71ee1b8" translate="yes" xml:space="preserve">
          <source>Perform interprocedural scalar replacement of aggregates, removal of unused parameters and replacement of parameters passed by reference by parameters passed by value.</source>
          <target state="translated">进行程序间的标量替换集合,删除未使用的参数,用值传递的参数替换引用传递的参数。</target>
        </trans-unit>
        <trans-unit id="f5a5996d13689478fbbcfefaf187644cb0bd68f3" translate="yes" xml:space="preserve">
          <source>Perform loop distribution of patterns that can be code generated with calls to a library. This flag is enabled by default at</source>
          <target state="translated">对可以通过调用库生成的代码的模式进行循环分配。这个标志默认在</target>
        </trans-unit>
        <trans-unit id="b51b13ca91f32e55112e18c7be23871252a6a72b" translate="yes" xml:space="preserve">
          <source>Perform loop distribution. This flag can improve cache performance on big loop bodies and allow further loop optimizations, like parallelization or vectorization, to take place. For example, the loop</source>
          <target state="translated">执行循环分布。这个标志可以提高大循环体的缓存性能,并允许进行进一步的循环优化,如并行化或矢量化。例如,循环的</target>
        </trans-unit>
        <trans-unit id="00772bc8e86a7b4ab6c55ba37b514b8f5f461b5a" translate="yes" xml:space="preserve">
          <source>Perform loop header copying on trees. This is beneficial since it increases effectiveness of code motion optimizations. It also saves one jump. This flag is enabled by default at</source>
          <target state="translated">对树进行循环头复制。这是有益的,因为它增加了代码运动优化的有效性。它还节省了一次跳转。这个标志默认在</target>
        </trans-unit>
        <trans-unit id="6482eb095ab0106534173067ba63a63b4e772180" translate="yes" xml:space="preserve">
          <source>Perform loop interchange outside of graphite. This flag can improve cache performance on loop nest and allow further loop optimizations, like vectorization, to take place. For example, the loop</source>
          <target state="translated">在石墨之外执行循环互换。这个标志可以提高循环嵌套的缓存性能,并允许进行进一步的循环优化,比如矢量化。例如,循环</target>
        </trans-unit>
        <trans-unit id="babeb9c2acdfb002d90adf1ca5e9065ac71e5cf8" translate="yes" xml:space="preserve">
          <source>Perform loop invariant motion on trees. This pass moves only invariants that are hard to handle at RTL level (function calls, operations that expand to nontrivial sequences of insns). With</source>
          <target state="translated">在树上执行循环不变性运动。这个通道只移动那些在RTL级别难以处理的不变量(函数调用、扩展到非平凡的ins序列的操作)。有了</target>
        </trans-unit>
        <trans-unit id="3759039cae2d11146e7c0dfe601eacde292dd1d1" translate="yes" xml:space="preserve">
          <source>Perform loop nest optimizations. Same as</source>
          <target state="translated">进行循环嵌套优化。同</target>
        </trans-unit>
        <trans-unit id="6a64dbc5caecc19bd9b50ef676cc69a1b212fa95" translate="yes" xml:space="preserve">
          <source>Perform loop optimizations on trees. This flag is enabled by default at</source>
          <target state="translated">对树进行循环优化。这个标志默认在</target>
        </trans-unit>
        <trans-unit id="121a475df0390f719f03e11127e3dd161d431728" translate="yes" xml:space="preserve">
          <source>Perform loop vectorization on trees. This flag is enabled by default at</source>
          <target state="translated">在树上执行循环矢量化。这个标志默认在</target>
        </trans-unit>
        <trans-unit id="f7516a23fd7e60004d67be66a314a10a37b3fdbd" translate="yes" xml:space="preserve">
          <source>Perform merging of narrow stores to consecutive memory addresses. This pass merges contiguous stores of immediate values narrower than a word into fewer wider stores to reduce the number of instructions. This is enabled by default at</source>
          <target state="translated">执行窄存储合并到连续的内存地址。该通道将比字更窄的即时值的连续存储合并到更少的宽存储中,以减少指令数量。默认情况下,该功能在</target>
        </trans-unit>
        <trans-unit id="1807eb51aa29cd70afd6f6f94c9e10f8d8e2a87a" translate="yes" xml:space="preserve">
          <source>Perform more aggressive SMS-based modulo scheduling with register moves allowed. By setting this flag certain anti-dependences edges are deleted, which triggers the generation of reg-moves based on the life-range analysis. This option is effective only with</source>
          <target state="translated">执行更积极的基于SMS的模数调度,允许寄存器移动。通过设置这个标志,某些反依赖边会被删除,从而触发基于生命范围分析的reg-moves的生成。该选项仅在以下情况下有效</target>
        </trans-unit>
        <trans-unit id="ebc09c6b12bc75f0257526fb06df9feb9bf5a73f" translate="yes" xml:space="preserve">
          <source>Perform optimizations that check to see if a jump branches to a location where another comparison subsumed by the first is found. If so, the first branch is redirected to either the destination of the second branch or a point immediately following it, depending on whether the condition is known to be true or false.</source>
          <target state="translated">执行优化,检查是否跳转分支到了被第一个分支所包含的另一个比较的位置。如果是这样,第一个分支将被重定向到第二个分支的目的地或紧随其后的一个点,这取决于已知条件是真还是假。</target>
        </trans-unit>
        <trans-unit id="8bd151314b28d93fbbbfc848886d1f59ee15eb4c" translate="yes" xml:space="preserve">
          <source>Perform partial redundancy elimination (PRE) on trees. This flag is enabled by default at</source>
          <target state="translated">在树上执行部分冗余消除(PRE)。这个标志默认在</target>
        </trans-unit>
        <trans-unit id="5a687acdfae667c8ef7b171f66546043ce33e5d1" translate="yes" xml:space="preserve">
          <source>Perform pattern matching on SSA PHI nodes to optimize conditional code. This pass is enabled by default at</source>
          <target state="translated">在SSA PHI节点上执行模式匹配以优化条件代码。该通道默认在</target>
        </trans-unit>
        <trans-unit id="d2e68d673229fe5ee8d59afbd3fa0d22ff809b67" translate="yes" xml:space="preserve">
          <source>Perform predictive commoning optimization, i.e., reusing computations (especially memory loads and stores) performed in previous iterations of loops.</source>
          <target state="translated">进行预测性的共通优化,即重复使用在之前的循环迭代中进行的计算(特别是内存加载和存储)。</target>
        </trans-unit>
        <trans-unit id="26325618e11578248e60d5c5ff4d5018d8830e39" translate="yes" xml:space="preserve">
          <source>Perform preprocessing as a separate pass before compilation. By default, GCC performs preprocessing as an integrated part of input tokenization and parsing. If this option is provided, the appropriate language front end (&lt;code&gt;cc1&lt;/code&gt;, &lt;code&gt;cc1plus&lt;/code&gt;, or &lt;code&gt;cc1obj&lt;/code&gt; for C, C++, and Objective-C, respectively) is instead invoked twice, once for preprocessing only and once for actual compilation of the preprocessed input. This option may be useful in conjunction with the</source>
          <target state="translated">编译之前，将预处理作为单独的过程进行。默认情况下，GCC将预处理作为输入标记和解析的集成部分。如果这个选项被提供时，相应的语言前端（ &lt;code&gt;cc1&lt;/code&gt; ， &lt;code&gt;cc1plus&lt;/code&gt; ，或 &lt;code&gt;cc1obj&lt;/code&gt; 为C，C ++，和Objective-C，分别地）代替调用两次，一次仅用于预处理，一次用于预处理输入的实际编译。此选项可能与</target>
        </trans-unit>
        <trans-unit id="62b772c98eeb18277e47f6941de481fe39743b88" translate="yes" xml:space="preserve">
          <source>Perform reassociation on trees. This flag is enabled by default at</source>
          <target state="translated">在树上执行重新关联。这个标志默认在</target>
        </trans-unit>
        <trans-unit id="813a6aee318424bad47fc31e7a836620510b882c" translate="yes" xml:space="preserve">
          <source>Perform scalar replacement of aggregates. This pass replaces structure references with scalars to prevent committing structures to memory too early. This flag is enabled by default at</source>
          <target state="translated">对聚合体进行标量替换。这个传递将结构引用替换为标量,以防止过早地将结构提交到内存中。这个标志默认在</target>
        </trans-unit>
        <trans-unit id="b26f36abadc06bc5e7c208db61bbe3c358c44821" translate="yes" xml:space="preserve">
          <source>Perform sparse conditional bit constant propagation on trees and propagate pointer alignment information. This pass only operates on local scalar variables and is enabled by default at</source>
          <target state="translated">在树上执行稀疏的条件位常数传播,传播指针对齐信息。这个通道只对局部标量变量进行操作,默认在</target>
        </trans-unit>
        <trans-unit id="98694aae92ae0c01003bcd09f650c827470ff6ab" translate="yes" xml:space="preserve">
          <source>Perform sparse conditional constant propagation (CCP) on trees. This pass only operates on local scalar variables and is enabled by default at</source>
          <target state="translated">在树上执行稀疏的条件常量传播(CCP)。这个通道只对局部标量变量进行操作,默认在</target>
        </trans-unit>
        <trans-unit id="8f21fbfa919feaca891f89e479b5cefd818de1a6" translate="yes" xml:space="preserve">
          <source>Perform straight-line strength reduction on trees. This recognizes related expressions involving multiplications and replaces them by less expensive calculations when possible. This is enabled by default at</source>
          <target state="translated">对树进行直线强度还原。这可以识别涉及乘法的相关表达式,并在可能的情况下用较便宜的计算来代替它们。这在默认情况下是在</target>
        </trans-unit>
        <trans-unit id="fc1747c25395001b1247e16471c4481c44d67bd9" translate="yes" xml:space="preserve">
          <source>Perform swing modulo scheduling immediately before the first scheduling pass. This pass looks at innermost loops and reorders their instructions by overlapping different iterations.</source>
          <target state="translated">在第一个调度通道之前立即执行摆动模数调度。这个通道查看最内部的循环,并通过重叠不同的迭代来重新排序它们的指令。</target>
        </trans-unit>
        <trans-unit id="a919828d7b7d52d94d6f24adec36ae549e8a769d" translate="yes" xml:space="preserve">
          <source>Perform tail duplication to enlarge superblock size. This transformation simplifies the control flow of the function allowing other optimizations to do a better job.</source>
          <target state="translated">进行尾部复制,扩大超级块的大小。这种转换简化了函数的控制流程,使其他优化工作能够更好地进行。</target>
        </trans-unit>
        <trans-unit id="8a7a4b7c3b7e1bdf82389ca95d6d1678d6326545" translate="yes" xml:space="preserve">
          <source>Perform temporary expression replacement during the SSA-&amp;gt;normal phase. Single use/single def temporaries are replaced at their use location with their defining expression. This results in non-GIMPLE code, but gives the expanders much more complex trees to work on resulting in better RTL generation. This is enabled by default at</source>
          <target state="translated">在SSA-&amp;gt;正常阶段执行临时表达式替换。一次性使用/单一定义临时对象在其使用位置被其定义表达式替换。这将导致生成非GIMPLE代码，但使扩展器可以处理更多复杂的树，从而更好地生成RTL。默认情况下启用</target>
        </trans-unit>
        <trans-unit id="04e4b2d91846b5259c4027f98674900fe1e5e1ea" translate="yes" xml:space="preserve">
          <source>Perform vectorization on trees. This flag enables</source>
          <target state="translated">对树进行矢量化。这个标志使</target>
        </trans-unit>
        <trans-unit id="bf3de408c364e89ef2141957569f6e056a16d34e" translate="yes" xml:space="preserve">
          <source>Performs a target dependent pass over the instruction stream to schedule instructions of same type together because target machine can execute them more efficiently if they are adjacent to each other in the instruction flow.</source>
          <target state="translated">在指令流上执行目标依赖性传递,将相同类型的指令调度在一起,因为目标机如果在指令流中相邻,可以更有效地执行这些指令。</target>
        </trans-unit>
        <trans-unit id="0cf20e92e0ce42954a3e029ad821a60784d2e15d" translate="yes" xml:space="preserve">
          <source>Permissible names are: &amp;lsquo;</source>
          <target state="translated">允许的名称为：'</target>
        </trans-unit>
        <trans-unit id="af0a0da269eb7e218ba55c95eef7829d862234bb" translate="yes" xml:space="preserve">
          <source>Permissible names for this option are the same as those for</source>
          <target state="translated">此选项的允许名称与以下选项相同。</target>
        </trans-unit>
        <trans-unit id="35baeb043fe816dcaf36ed0df9f003c63e8e45b3" translate="yes" xml:space="preserve">
          <source>Permissible values for these parameters are: &lt;code&gt;reset&lt;/code&gt;, &lt;code&gt;software_exception&lt;/code&gt;, &lt;code&gt;page_miss&lt;/code&gt;, &lt;code&gt;timer0&lt;/code&gt;, &lt;code&gt;timer1&lt;/code&gt;, &lt;code&gt;message&lt;/code&gt;, &lt;code&gt;dma0&lt;/code&gt;, &lt;code&gt;dma1&lt;/code&gt;, &lt;code&gt;wand&lt;/code&gt; and &lt;code&gt;swi&lt;/code&gt;. Multiple parameters indicate that multiple entries in the interrupt vector table should be initialized for this function, i.e. for each parameter &lt;var&gt;name&lt;/var&gt;, a jump to the function is emitted in the section ivt_entry_&lt;var&gt;name&lt;/var&gt;. The parameter(s) may be omitted entirely, in which case no interrupt vector table entry is provided.</source>
          <target state="translated">这些参数的可允许的值是： &lt;code&gt;reset&lt;/code&gt; ， &lt;code&gt;software_exception&lt;/code&gt; ， &lt;code&gt;page_miss&lt;/code&gt; ， &lt;code&gt;timer0&lt;/code&gt; ， &lt;code&gt;timer1&lt;/code&gt; ， &lt;code&gt;message&lt;/code&gt; ， &lt;code&gt;dma0&lt;/code&gt; ， &lt;code&gt;dma1&lt;/code&gt; ， &lt;code&gt;wand&lt;/code&gt; 和 &lt;code&gt;swi&lt;/code&gt; 。多个参数指示应为此功能初始化中断向量表中的多个条目，即，对于每个参数 &lt;var&gt;name&lt;/var&gt; ，在ivt_entry_ &lt;var&gt;name&lt;/var&gt; 部分中将跳转到该功能。参数可以完全省略，在这种情况下，不提供中断向量表条目。</target>
        </trans-unit>
        <trans-unit id="b9723fc078a6d12e16c3d4a9c0abd787a24129b7" translate="yes" xml:space="preserve">
          <source>Permissible values for this parameter are &lt;code&gt;user&lt;/code&gt;, &lt;code&gt;supervisor&lt;/code&gt;, and &lt;code&gt;machine&lt;/code&gt;. If there is no parameter, then it defaults to &lt;code&gt;machine&lt;/code&gt;.</source>
          <target state="translated">该参数的允许值为 &lt;code&gt;user&lt;/code&gt; ， &lt;code&gt;supervisor&lt;/code&gt; 和 &lt;code&gt;machine&lt;/code&gt; 。如果没有参数，则默认为 &lt;code&gt;machine&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3cc7aed9a0397bf927110c664bfb64b86eeabb19" translate="yes" xml:space="preserve">
          <source>Permissible values for this parameter are: &lt;code&gt;IRQ&lt;/code&gt;, &lt;code&gt;FIQ&lt;/code&gt;, &lt;code&gt;SWI&lt;/code&gt;, &lt;code&gt;ABORT&lt;/code&gt; and &lt;code&gt;UNDEF&lt;/code&gt;.</source>
          <target state="translated">此参数的允许值为： &lt;code&gt;IRQ&lt;/code&gt; ， &lt;code&gt;FIQ&lt;/code&gt; ， &lt;code&gt;SWI&lt;/code&gt; ， &lt;code&gt;ABORT&lt;/code&gt; 和 &lt;code&gt;UNDEF&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3b9d9d84efd3990ebcb9f633346ed4f086d6a8d9" translate="yes" xml:space="preserve">
          <source>Permissible values for this parameter are: &lt;code&gt;ilink1&lt;/code&gt; and &lt;code&gt;ilink2&lt;/code&gt; for ARCv1 architecture, and &lt;code&gt;ilink&lt;/code&gt; and &lt;code&gt;firq&lt;/code&gt; for ARCv2 architecture.</source>
          <target state="translated">此参数的允许值为： &lt;code&gt;ilink1&lt;/code&gt; 和 &lt;code&gt;ilink2&lt;/code&gt; 为ARCv1建筑， &lt;code&gt;ilink&lt;/code&gt; 和 &lt;code&gt;firq&lt;/code&gt; 为ARCv2架构。</target>
        </trans-unit>
        <trans-unit id="57d5e1c32f10448459df52f2af315ff5a35b20a7" translate="yes" xml:space="preserve">
          <source>Permissible values for this parameter are: &lt;code&gt;ilink1&lt;/code&gt; and &lt;code&gt;ilink2&lt;/code&gt;.</source>
          <target state="translated">此参数的允许值为： &lt;code&gt;ilink1&lt;/code&gt; 和 &lt;code&gt;ilink2&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4f3f12e5bf476c3ff221016dda60f3c7460d0647" translate="yes" xml:space="preserve">
          <source>Permission is granted to copy, distribute and/or modify this document under the terms of the GNU Free Documentation License, Version 1.3 or any later version published by the Free Software Foundation; with the Invariant Sections being &amp;ldquo;Funding Free Software&amp;rdquo;, the Front-Cover Texts being (a) (see below), and with the Back-Cover Texts being (b) (see below). A copy of the license is included in the section entitled &amp;ldquo;GNU Free Documentation License&amp;rdquo;.</source>
          <target state="translated">根据GNU自由文档许可版本1.3或自由软件基金会发布的任何更高版本，授予复制，分发和/或修改本文档的权限；不变部分为&amp;ldquo;免费金融软件&amp;rdquo;，封面文本为（a）（见下文），封面文本为（b）（见下文）。许可证的副本包含在标题为&amp;ldquo; GNU自由文档许可证&amp;rdquo;的部分中。</target>
        </trans-unit>
        <trans-unit id="cb303e16e1de5b240406d59f6d4950a031fdb18c" translate="yes" xml:space="preserve">
          <source>Permit scheduling of function prologue and epilogue sequences. Using this option can result in code that is not compliant with the C-SKY V2 ABI prologue requirements and that cannot be debugged or backtraced. It is disabled by default.</source>
          <target state="translated">允许调度函数序幕和尾声序列。使用这个选项可能会导致代码不符合C-SKY V2 ABI序幕的要求,并且无法调试或回溯。默认情况下它是被禁用的。</target>
        </trans-unit>
        <trans-unit id="258db086a140738c3e68e86e4185fee98a52b02b" translate="yes" xml:space="preserve">
          <source>Pertinent parameters for controlling the exploration are:</source>
          <target state="translated">控制勘探的相关参数有:</target>
        </trans-unit>
        <trans-unit id="efb7f323fa4189969e284506cb84cfc7c5590b36" translate="yes" xml:space="preserve">
          <source>Place a stop bit after every cycle when scheduling. This option is on by default.</source>
          <target state="translated">排程时在每个周期后放置一个停止位。该选项默认为开启。</target>
        </trans-unit>
        <trans-unit id="f322bfc998e9190a4bf5a7767d3d6625d8974da3" translate="yes" xml:space="preserve">
          <source>Place each function or data item into its own section in the output file if the target supports arbitrary sections. The name of the function or the name of the data item determines the section&amp;rsquo;s name in the output file.</source>
          <target state="translated">如果目标支持任意部分，则将每个函数或数据项放入输出文件中其自己的部分中。函数的名称或数据项的名称决定了输出文件中该节的名称。</target>
        </trans-unit>
        <trans-unit id="d5dd2f33d892c7609324f2984b75dba44e198b60" translate="yes" xml:space="preserve">
          <source>Place output in file &lt;var&gt;file&lt;/var&gt;. This applies to whatever sort of output is being produced, whether it be an executable file, an object file, an assembler file or preprocessed C code.</source>
          <target state="translated">将输出放在文件 &lt;var&gt;file&lt;/var&gt; 中。这适用于所产生的任何类型的输出，无论是可执行文件，目标文件，汇编文件还是预处理的C代码。</target>
        </trans-unit>
        <trans-unit id="6702fed7fed6176a523c58b5ddd51a1d929453f7" translate="yes" xml:space="preserve">
          <source>Please note the warning under</source>
          <target state="translated">请注意以下警告</target>
        </trans-unit>
        <trans-unit id="fa1c5292c2aed3e9e6527fac2de8fd113fa58e19" translate="yes" xml:space="preserve">
          <source>Pointer arguments to variadic functions.</source>
          <target state="translated">变量函数的指针。</target>
        </trans-unit>
        <trans-unit id="c72a43085fa8bb37fba01322fd21a237f32d0882" translate="yes" xml:space="preserve">
          <source>Pointer register (r26&amp;ndash;r31)</source>
          <target state="translated">指针寄存器（r26&amp;ndash;r31）</target>
        </trans-unit>
        <trans-unit id="548e8a6d360621f369a6ac68a9d06d3b535c4226" translate="yes" xml:space="preserve">
          <source>Pointer with long displacement.</source>
          <target state="translated">长位移的指针。</target>
        </trans-unit>
        <trans-unit id="f829df7980df5422cdac2c36bfd4a6a0924d2a9d" translate="yes" xml:space="preserve">
          <source>Pointer with short displacement.</source>
          <target state="translated">短位移的指针。</target>
        </trans-unit>
        <trans-unit id="221a34492903a7d75d1476fa80d265dd838ae397" translate="yes" xml:space="preserve">
          <source>Pointers in the implementation are 16 bits wide. The address of a function or label is represented as word address so that indirect jumps and calls can target any code address in the range of 64 Ki words.</source>
          <target state="translated">实现中指针的宽度为16位。函数或标签的地址用字地址表示,这样间接跳转和调用可以针对64Ki字范围内的任何代码地址。</target>
        </trans-unit>
        <trans-unit id="b71846dbdd6d5df077c8d26dc154bb35c68e7752" translate="yes" xml:space="preserve">
          <source>Pointers to arrays with qualifiers work as expected.</source>
          <target state="translated">指向带有限定符的数组的指针可以正常工作。</target>
        </trans-unit>
        <trans-unit id="da127d1a6d3dff99efb435318078508cb04231bb" translate="yes" xml:space="preserve">
          <source>Popping the arguments after the function call can be expensive on AVR so that accumulating the stack space might lead to smaller executables because arguments need not be removed from the stack after such a function call.</source>
          <target state="translated">在函数调用后弹出参数在AVR上是很昂贵的,所以积累堆栈空间可能会导致更小的可执行文件,因为在这样的函数调用后不需要从堆栈中删除参数。</target>
        </trans-unit>
        <trans-unit id="1ec131a13f5ccb0f8a6fa30408faa2bccded3261" translate="yes" xml:space="preserve">
          <source>Position-independent code requires special support, and therefore works only on certain machines.</source>
          <target state="translated">与位置无关的代码需要特殊的支持,因此只能在某些机器上工作。</target>
        </trans-unit>
        <trans-unit id="ff1fde2f659bcd7d20cf19e7e6dbdfb1735e0055" translate="yes" xml:space="preserve">
          <source>Position-independent code requires special support, and therefore works only on certain machines. For the x86, GCC supports PIC for System V but not for the Sun 386i. Code generated for the IBM RS/6000 is always position-independent.</source>
          <target state="translated">与位置无关的代码需要特殊的支持,因此只适用于某些机器。对于x86,GCC支持System V的PIC,但不支持Sun 386i。为IBM RS/6000生成的代码总是与位置无关的。</target>
        </trans-unit>
        <trans-unit id="d29deccf36aae92e4a7875b6f993d6712f4c48c0" translate="yes" xml:space="preserve">
          <source>PowerPC 405 32-bit Embedded CPU.</source>
          <target state="translated">PowerPC 405 32位嵌入式CPU。</target>
        </trans-unit>
        <trans-unit id="b1d2fd0956b324f2b71d45c79701e634006f0998" translate="yes" xml:space="preserve">
          <source>PowerPC 440 32-bit Embedded CPU.</source>
          <target state="translated">PowerPC 440 32位嵌入式CPU。</target>
        </trans-unit>
        <trans-unit id="8c88a5ec0bad9b2ec3a6e912ad1b84fe1cb0e913" translate="yes" xml:space="preserve">
          <source>PowerPC and IBM RS6000&amp;mdash;</source>
          <target state="translated">PowerPC和IBM RS6000 &amp;mdash;</target>
        </trans-unit>
        <trans-unit id="bcb9720231f4eefcc2911c6644e67562366e664a" translate="yes" xml:space="preserve">
          <source>Pragmas accepted by GCC.</source>
          <target state="translated">海合会接受的实用方法。</target>
        </trans-unit>
        <trans-unit id="ae3be2297868a8755878b8140bb470b2659e5173" translate="yes" xml:space="preserve">
          <source>Pragmas to control overflow and rounding behaviors are not implemented.</source>
          <target state="translated">没有实现控制溢出和四舍五入行为的实用程序。</target>
        </trans-unit>
        <trans-unit id="8e93065e97687afdb6c2cb1807aa95de831b3446" translate="yes" xml:space="preserve">
          <source>Predefine &lt;var&gt;name&lt;/var&gt; as a macro, with definition &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">将 &lt;var&gt;name&lt;/var&gt; 预定义为宏，定义为 &lt;code&gt;1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e38583cb5384743db9afcc426cedec4f148c0b26" translate="yes" xml:space="preserve">
          <source>Predicate register (&amp;lsquo;</source>
          <target state="translated">谓词寄存器（'</target>
        </trans-unit>
        <trans-unit id="f6c24206b3789713e962d5bee080397fea9809bf" translate="yes" xml:space="preserve">
          <source>Predicate registers in register file A (A0&amp;ndash;A2 on C64X and higher, A1 and A2 otherwise).</source>
          <target state="translated">谓词寄存器在寄存器文件A中（C64X和更高版本上为A0&amp;ndash;A2，否则为A1和A2）。</target>
        </trans-unit>
        <trans-unit id="fec436f1165c01f7b8c12f56c12ec41ae48daa7c" translate="yes" xml:space="preserve">
          <source>Predicate registers in register file B (B0&amp;ndash;B2).</source>
          <target state="translated">谓词寄存器在寄存器文件B（B0&amp;ndash;B2）中。</target>
        </trans-unit>
        <trans-unit id="d010b8de73801ea6c16e7a693f380cb435e67997" translate="yes" xml:space="preserve">
          <source>Prefer 128-bit vector width for instructions.</source>
          <target state="translated">优先选择128位向量宽度的指令。</target>
        </trans-unit>
        <trans-unit id="c72722357c9f06e0451f0baf6353c7d5bd987c68" translate="yes" xml:space="preserve">
          <source>Prefer 256-bit vector width for instructions.</source>
          <target state="translated">优先选择256位向量宽度的指令。</target>
        </trans-unit>
        <trans-unit id="3d1a90957e39dc52fe3e0a5dff721af2c1533ae9" translate="yes" xml:space="preserve">
          <source>Prefer 512-bit vector width for instructions.</source>
          <target state="translated">优先选择512位向量宽度的指令。</target>
        </trans-unit>
        <trans-unit id="55b3d6f2f24c6bd41aa8d455a302118a96706fdb" translate="yes" xml:space="preserve">
          <source>Prefer initialization to assignment in constructors.</source>
          <target state="translated">在构造函数中更倾向于初始化而不是赋值。</target>
        </trans-unit>
        <trans-unit id="e5fe97372ea4c44c05ad1e9f80e485c5b8d2b708" translate="yes" xml:space="preserve">
          <source>Prefer word access when reading byte quantities.</source>
          <target state="translated">读取字节数量时,首选字访问。</target>
        </trans-unit>
        <trans-unit id="751bcd963c78ac89d226c347c0db73a5eb17519e" translate="yes" xml:space="preserve">
          <source>Prefer zero-displacement conditional branches for conditional move instruction patterns. This can result in faster code on the SH4 processor.</source>
          <target state="translated">对于条件移动指令模式,首选零位移条件分支。这可以使SH4处理器上的代码更快。</target>
        </trans-unit>
        <trans-unit id="62927f12aebe8245ca7ccbec4d045c60284016e4" translate="yes" xml:space="preserve">
          <source>Preferentially allocate registers that allow short instruction generation. This can result in increased instruction count, so this may either reduce or increase overall code size.</source>
          <target state="translated">优先分配允许短指令生成的寄存器。这可能会导致指令数增加,因此这可能会减少或增加整体代码大小。</target>
        </trans-unit>
        <trans-unit id="a1fdf593aa54fe21b57f9608b9af0f175a51f5bf" translate="yes" xml:space="preserve">
          <source>Prepend (do not prepend) a &amp;lsquo;</source>
          <target state="translated">前置（不前置）&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="7b1baabda5f4c155086c1133972437c2a11a8717" translate="yes" xml:space="preserve">
          <source>Preprocessor Options</source>
          <target state="translated">预处理机选项</target>
        </trans-unit>
        <trans-unit id="c52cfab87f1f18bc931d7a53ed6f0f346f5be727" translate="yes" xml:space="preserve">
          <source>Preserve complete path information in the names of generated</source>
          <target state="translated">保留完整的路径信息在生成的</target>
        </trans-unit>
        <trans-unit id="133f0b62da14d995af8aaf975f0c4e6493e01234" translate="yes" xml:space="preserve">
          <source>Pretend the symbol &lt;var&gt;symbol&lt;/var&gt; is undefined, to force linking of library modules to define it. You can use</source>
          <target state="translated">假设符号 &lt;var&gt;symbol&lt;/var&gt; 未定义，以强制链接库模块对其进行定义。您可以使用</target>
        </trans-unit>
        <trans-unit id="93b748cdea3b771906f02431b0afee34e97035a0" translate="yes" xml:space="preserve">
          <source>Prevent floating-point registers from being used in any manner. This is necessary for compiling kernels that perform lazy context switching of floating-point registers. If you use this option and attempt to perform floating-point operations, the compiler aborts.</source>
          <target state="translated">防止以任何方式使用浮点寄存器。这对于编译执行浮点寄存器懒惰上下文切换的内核是必要的。如果使用这个选项并试图执行浮点运算,编译器会中止。</target>
        </trans-unit>
        <trans-unit id="bb7e629d281cc1130ee30ba469e70f725c11a1a9" translate="yes" xml:space="preserve">
          <source>Prevent the compiler from using indexing address modes. This avoids some rather obscure problems when compiling MIG generated code under MACH.</source>
          <target state="translated">防止编译器使用索引地址模式。这样可以避免在MACH下编译MIG生成的代码时出现一些比较隐晦的问题。</target>
        </trans-unit>
        <trans-unit id="a884d00641db1ef92c5861d9f7679506da26ff4e" translate="yes" xml:space="preserve">
          <source>Prevent the reordering of instructions in the function prologue, or the merging of those instruction with the instructions in the function&amp;rsquo;s body. This means that all functions start with a recognizable set of instructions (or in fact one of a choice from a small set of different function prologues), and this information can be used to locate the start of functions inside an executable piece of code. The default is</source>
          <target state="translated">防止对函数序言中的指令进行重新排序，或防止将这些指令与函数主体中的指令合并。这意味着所有功能都以一组可识别的指令开始（或者实际上是从一小组不同功能序言中选择的一个），并且该信息可用于在可执行代码段中定位功能的开始。默认是</target>
        </trans-unit>
        <trans-unit id="8bee5f1a685fff3e9255748fa0a591a79f24269b" translate="yes" xml:space="preserve">
          <source>Prevents GCC from issuing a warning message if it finds more than one fast interrupt handler when it is compiling a file. The default is to issue a warning for each extra fast interrupt handler found, as the RX only supports one such interrupt.</source>
          <target state="translated">防止GCC在编译文件时发现一个以上的快速中断处理程序时发出警告信息。默认情况下是为每个额外发现的快速中断处理程序发出警告,因为RX只支持一个这样的中断。</target>
        </trans-unit>
        <trans-unit id="e537c0dc3e8d81002fc1ef4c91ba84299819e72d" translate="yes" xml:space="preserve">
          <source>Previous: &lt;a href=&quot;_0040encode#g_t_0040encode&quot;&gt;@encode&lt;/a&gt;, Up: &lt;a href=&quot;type-encoding#Type-encoding&quot;&gt;Type encoding&lt;/a&gt; [&lt;a href=&quot;index#SEC_Contents&quot;&gt;Contents&lt;/a&gt;][&lt;a href=&quot;https://gcc.gnu.org/onlinedocs/gcc-10.2.0/gcc/Option-Index.html#Option-Index&quot;&gt;Index&lt;/a&gt;]</source>
          <target state="translated">上&lt;a href=&quot;_0040encode#g_t_0040encode&quot;&gt;一篇&lt;/a&gt;：@encode，上一篇：&lt;a href=&quot;type-encoding#Type-encoding&quot;&gt;类型编码&lt;/a&gt;[&lt;a href=&quot;index#SEC_Contents&quot;&gt;目录&lt;/a&gt;] [&lt;a href=&quot;https://gcc.gnu.org/onlinedocs/gcc-10.2.0/gcc/Option-Index.html#Option-Index&quot;&gt;索引&lt;/a&gt;]</target>
        </trans-unit>
        <trans-unit id="0c298d2156eb911587b91d6784586e592c266917" translate="yes" xml:space="preserve">
          <source>Previous: &lt;a href=&quot;_0040encode#g_t_0040encode&quot;&gt;@encode&lt;/a&gt;, Up: &lt;a href=&quot;type-encoding#Type-encoding&quot;&gt;Type encoding&lt;/a&gt; [&lt;a href=&quot;index#SEC_Contents&quot;&gt;Contents&lt;/a&gt;][&lt;a href=&quot;https://gcc.gnu.org/onlinedocs/gcc-9.2.0/gcc/Option-Index.html#Option-Index&quot;&gt;Index&lt;/a&gt;]</source>
          <target state="translated">上&lt;a href=&quot;_0040encode#g_t_0040encode&quot;&gt;一篇&lt;/a&gt;：@encode，上一篇：&lt;a href=&quot;type-encoding#Type-encoding&quot;&gt;类型编码&lt;/a&gt; [ &lt;a href=&quot;index#SEC_Contents&quot;&gt;目录&lt;/a&gt; ] [ &lt;a href=&quot;https://gcc.gnu.org/onlinedocs/gcc-9.2.0/gcc/Option-Index.html#Option-Index&quot;&gt;索引&lt;/a&gt; ]</target>
        </trans-unit>
        <trans-unit id="c46b9f654c99730d96df95c0b87bec0a17545c4a" translate="yes" xml:space="preserve">
          <source>Previous: &lt;a href=&quot;basic-powerpc-built_002din-functions-available-on-isa-2_002e07#Basic-PowerPC-Built_002din-Functions-Available-on-ISA-2_002e07&quot;&gt;Basic PowerPC Built-in Functions Available on ISA 2.07&lt;/a&gt;, Up: &lt;a href=&quot;basic-powerpc-built_002din-functions#Basic-PowerPC-Built_002din-Functions&quot;&gt;Basic PowerPC Built-in Functions&lt;/a&gt; [&lt;a href=&quot;index#SEC_Contents&quot;&gt;Contents&lt;/a&gt;][&lt;a href=&quot;https://gcc.gnu.org/onlinedocs/gcc-10.2.0/gcc/Option-Index.html#Option-Index&quot;&gt;Index&lt;/a&gt;]</source>
          <target state="translated">上一页：&lt;a href=&quot;basic-powerpc-built_002din-functions-available-on-isa-2_002e07#Basic-PowerPC-Built_002din-Functions-Available-on-ISA-2_002e07&quot;&gt;ISA 2.07&lt;/a&gt;上可用的PowerPC内置基本功能，上：&lt;a href=&quot;basic-powerpc-built_002din-functions#Basic-PowerPC-Built_002din-Functions&quot;&gt;PowerPC内置基本功能&lt;/a&gt;[&lt;a href=&quot;index#SEC_Contents&quot;&gt;目录&lt;/a&gt;] [&lt;a href=&quot;https://gcc.gnu.org/onlinedocs/gcc-10.2.0/gcc/Option-Index.html#Option-Index&quot;&gt;索引&lt;/a&gt;]</target>
        </trans-unit>
        <trans-unit id="45ae7dc171d8dbf2c108f57d090926498ec01d52" translate="yes" xml:space="preserve">
          <source>Previous: &lt;a href=&quot;basic-powerpc-built_002din-functions-available-on-isa-2_002e07#Basic-PowerPC-Built_002din-Functions-Available-on-ISA-2_002e07&quot;&gt;Basic PowerPC Built-in Functions Available on ISA 2.07&lt;/a&gt;, Up: &lt;a href=&quot;basic-powerpc-built_002din-functions#Basic-PowerPC-Built_002din-Functions&quot;&gt;Basic PowerPC Built-in Functions&lt;/a&gt; [&lt;a href=&quot;index#SEC_Contents&quot;&gt;Contents&lt;/a&gt;][&lt;a href=&quot;https://gcc.gnu.org/onlinedocs/gcc-9.2.0/gcc/Option-Index.html#Option-Index&quot;&gt;Index&lt;/a&gt;]</source>
          <target state="translated">上&lt;a href=&quot;basic-powerpc-built_002din-functions-available-on-isa-2_002e07#Basic-PowerPC-Built_002din-Functions-Available-on-ISA-2_002e07&quot;&gt;一篇&lt;/a&gt;：ISA 2.07上可用的PowerPC内置基本功能，上：&lt;a href=&quot;basic-powerpc-built_002din-functions#Basic-PowerPC-Built_002din-Functions&quot;&gt;PowerPC内置基本功能&lt;/a&gt; [ &lt;a href=&quot;index#SEC_Contents&quot;&gt;目录&lt;/a&gt; ] [ &lt;a href=&quot;https://gcc.gnu.org/onlinedocs/gcc-9.2.0/gcc/Option-Index.html#Option-Index&quot;&gt;索引&lt;/a&gt; ]</target>
        </trans-unit>
        <trans-unit id="9f033bea3c19731300ef9c88817c0cbd24e4a4db" translate="yes" xml:space="preserve">
          <source>Previous: &lt;a href=&quot;c99-thread_002dlocal-edits#C99-Thread_002dLocal-Edits&quot;&gt;C99 Thread-Local Edits&lt;/a&gt;, Up: &lt;a href=&quot;thread_002dlocal#Thread_002dLocal&quot;&gt;Thread-Local&lt;/a&gt; [&lt;a href=&quot;index#SEC_Contents&quot;&gt;Contents&lt;/a&gt;][&lt;a href=&quot;https://gcc.gnu.org/onlinedocs/gcc-10.2.0/gcc/Option-Index.html#Option-Index&quot;&gt;Index&lt;/a&gt;]</source>
          <target state="translated">上一页：&lt;a href=&quot;c99-thread_002dlocal-edits#C99-Thread_002dLocal-Edits&quot;&gt;C99线程本地编辑&lt;/a&gt;，向上：&lt;a href=&quot;thread_002dlocal#Thread_002dLocal&quot;&gt;线程本地&lt;/a&gt;[&lt;a href=&quot;index#SEC_Contents&quot;&gt;目录&lt;/a&gt;] [&lt;a href=&quot;https://gcc.gnu.org/onlinedocs/gcc-10.2.0/gcc/Option-Index.html#Option-Index&quot;&gt;索引&lt;/a&gt;]</target>
        </trans-unit>
        <trans-unit id="92416ecc83e7012e1b2389fd283cb8d6c4bca85a" translate="yes" xml:space="preserve">
          <source>Previous: &lt;a href=&quot;c99-thread_002dlocal-edits#C99-Thread_002dLocal-Edits&quot;&gt;C99 Thread-Local Edits&lt;/a&gt;, Up: &lt;a href=&quot;thread_002dlocal#Thread_002dLocal&quot;&gt;Thread-Local&lt;/a&gt; [&lt;a href=&quot;index#SEC_Contents&quot;&gt;Contents&lt;/a&gt;][&lt;a href=&quot;https://gcc.gnu.org/onlinedocs/gcc-9.2.0/gcc/Option-Index.html#Option-Index&quot;&gt;Index&lt;/a&gt;]</source>
          <target state="translated">上一页：&lt;a href=&quot;c99-thread_002dlocal-edits#C99-Thread_002dLocal-Edits&quot;&gt;C99线程本地编辑&lt;/a&gt;，向上：&lt;a href=&quot;thread_002dlocal#Thread_002dLocal&quot;&gt;线程本地&lt;/a&gt; [ &lt;a href=&quot;index#SEC_Contents&quot;&gt;目录&lt;/a&gt; ] [ &lt;a href=&quot;https://gcc.gnu.org/onlinedocs/gcc-9.2.0/gcc/Option-Index.html#Option-Index&quot;&gt;索引&lt;/a&gt; ]</target>
        </trans-unit>
        <trans-unit id="9f3249c5747ff73558c59477858dab2add894b11" translate="yes" xml:space="preserve">
          <source>Previous: &lt;a href=&quot;dynamically-registering-methods#Dynamically-registering-methods&quot;&gt;Dynamically registering methods&lt;/a&gt;, Up: &lt;a href=&quot;messaging-with-the-gnu-objective_002dc-runtime#Messaging-with-the-GNU-Objective_002dC-runtime&quot;&gt;Messaging with the GNU Objective-C runtime&lt;/a&gt; [&lt;a href=&quot;index#SEC_Contents&quot;&gt;Contents&lt;/a&gt;][&lt;a href=&quot;https://gcc.gnu.org/onlinedocs/gcc-10.2.0/gcc/Option-Index.html#Option-Index&quot;&gt;Index&lt;/a&gt;]</source>
          <target state="translated">上一页：&lt;a href=&quot;dynamically-registering-methods#Dynamically-registering-methods&quot;&gt;动态注册方法&lt;/a&gt;，上一篇：&lt;a href=&quot;messaging-with-the-gnu-objective_002dc-runtime#Messaging-with-the-GNU-Objective_002dC-runtime&quot;&gt;使用GNU Objective-C运行时进行消息传递&lt;/a&gt;[&lt;a href=&quot;index#SEC_Contents&quot;&gt;目录&lt;/a&gt;] [&lt;a href=&quot;https://gcc.gnu.org/onlinedocs/gcc-10.2.0/gcc/Option-Index.html#Option-Index&quot;&gt;索引&lt;/a&gt;]</target>
        </trans-unit>
        <trans-unit id="095b2c8cec2a9ee9cd6a1fc1d2c2268ef5e58bb5" translate="yes" xml:space="preserve">
          <source>Previous: &lt;a href=&quot;dynamically-registering-methods#Dynamically-registering-methods&quot;&gt;Dynamically registering methods&lt;/a&gt;, Up: &lt;a href=&quot;messaging-with-the-gnu-objective_002dc-runtime#Messaging-with-the-GNU-Objective_002dC-runtime&quot;&gt;Messaging with the GNU Objective-C runtime&lt;/a&gt; [&lt;a href=&quot;index#SEC_Contents&quot;&gt;Contents&lt;/a&gt;][&lt;a href=&quot;https://gcc.gnu.org/onlinedocs/gcc-9.2.0/gcc/Option-Index.html#Option-Index&quot;&gt;Index&lt;/a&gt;]</source>
          <target state="translated">Previous：&lt;a href=&quot;dynamically-registering-methods#Dynamically-registering-methods&quot;&gt;动态注册方法&lt;/a&gt;，Up：&lt;a href=&quot;messaging-with-the-gnu-objective_002dc-runtime#Messaging-with-the-GNU-Objective_002dC-runtime&quot;&gt;使用GNU Objective-C运行时进行消息传递&lt;/a&gt; [ &lt;a href=&quot;index#SEC_Contents&quot;&gt;目录&lt;/a&gt; ] [ &lt;a href=&quot;https://gcc.gnu.org/onlinedocs/gcc-9.2.0/gcc/Option-Index.html#Option-Index&quot;&gt;索引&lt;/a&gt; ]</target>
        </trans-unit>
        <trans-unit id="597300060534fa0401e363904c20fc0185b2beaa" translate="yes" xml:space="preserve">
          <source>Previous: &lt;a href=&quot;environment-variables#Environment-Variables&quot;&gt;Environment Variables&lt;/a&gt;, Up: &lt;a href=&quot;invoking-gcc#Invoking-GCC&quot;&gt;Invoking GCC&lt;/a&gt; [&lt;a href=&quot;index#SEC_Contents&quot;&gt;Contents&lt;/a&gt;][&lt;a href=&quot;https://gcc.gnu.org/onlinedocs/gcc-10.2.0/gcc/Option-Index.html#Option-Index&quot;&gt;Index&lt;/a&gt;]</source>
          <target state="translated">上一页：&lt;a href=&quot;environment-variables#Environment-Variables&quot;&gt;环境变量&lt;/a&gt;，上&lt;a href=&quot;invoking-gcc#Invoking-GCC&quot;&gt;一篇&lt;/a&gt;：调用GCC [&lt;a href=&quot;index#SEC_Contents&quot;&gt;目录&lt;/a&gt;] [&lt;a href=&quot;https://gcc.gnu.org/onlinedocs/gcc-10.2.0/gcc/Option-Index.html#Option-Index&quot;&gt;索引&lt;/a&gt;]</target>
        </trans-unit>
        <trans-unit id="8f89899827d8a560e31e2ca14d0a8300f657be83" translate="yes" xml:space="preserve">
          <source>Previous: &lt;a href=&quot;environment-variables#Environment-Variables&quot;&gt;Environment Variables&lt;/a&gt;, Up: &lt;a href=&quot;invoking-gcc#Invoking-GCC&quot;&gt;Invoking GCC&lt;/a&gt; [&lt;a href=&quot;index#SEC_Contents&quot;&gt;Contents&lt;/a&gt;][&lt;a href=&quot;https://gcc.gnu.org/onlinedocs/gcc-9.2.0/gcc/Option-Index.html#Option-Index&quot;&gt;Index&lt;/a&gt;]</source>
          <target state="translated">上一页：&lt;a href=&quot;environment-variables#Environment-Variables&quot;&gt;环境变量&lt;/a&gt;，上&lt;a href=&quot;invoking-gcc#Invoking-GCC&quot;&gt;一篇&lt;/a&gt;：调用GCC [ &lt;a href=&quot;index#SEC_Contents&quot;&gt;目录&lt;/a&gt; ] [ &lt;a href=&quot;https://gcc.gnu.org/onlinedocs/gcc-9.2.0/gcc/Option-Index.html#Option-Index&quot;&gt;索引&lt;/a&gt; ]</target>
        </trans-unit>
        <trans-unit id="f2998325d9fc9a4736bf01e439e1fca60b9b2e42" translate="yes" xml:space="preserve">
          <source>Previous: &lt;a href=&quot;fast-enumeration-details#Fast-enumeration-details&quot;&gt;Fast enumeration details&lt;/a&gt;, Up: &lt;a href=&quot;fast-enumeration#Fast-enumeration&quot;&gt;Fast enumeration&lt;/a&gt; [&lt;a href=&quot;index#SEC_Contents&quot;&gt;Contents&lt;/a&gt;][&lt;a href=&quot;https://gcc.gnu.org/onlinedocs/gcc-10.2.0/gcc/Option-Index.html#Option-Index&quot;&gt;Index&lt;/a&gt;]</source>
          <target state="translated">上一页：&lt;a href=&quot;fast-enumeration-details#Fast-enumeration-details&quot;&gt;快速枚举详细信息&lt;/a&gt;，向上：&lt;a href=&quot;fast-enumeration#Fast-enumeration&quot;&gt;快速枚举&lt;/a&gt;[&lt;a href=&quot;index#SEC_Contents&quot;&gt;目录&lt;/a&gt;] [&lt;a href=&quot;https://gcc.gnu.org/onlinedocs/gcc-10.2.0/gcc/Option-Index.html#Option-Index&quot;&gt;索引&lt;/a&gt;]</target>
        </trans-unit>
        <trans-unit id="3abd0fcac2246de54cbf842bcf5c2d572e95cf49" translate="yes" xml:space="preserve">
          <source>Previous: &lt;a href=&quot;fast-enumeration-details#Fast-enumeration-details&quot;&gt;Fast enumeration details&lt;/a&gt;, Up: &lt;a href=&quot;fast-enumeration#Fast-enumeration&quot;&gt;Fast enumeration&lt;/a&gt; [&lt;a href=&quot;index#SEC_Contents&quot;&gt;Contents&lt;/a&gt;][&lt;a href=&quot;https://gcc.gnu.org/onlinedocs/gcc-9.2.0/gcc/Option-Index.html#Option-Index&quot;&gt;Index&lt;/a&gt;]</source>
          <target state="translated">上一页：&lt;a href=&quot;fast-enumeration-details#Fast-enumeration-details&quot;&gt;快速枚举详细信息&lt;/a&gt;，向上：&lt;a href=&quot;fast-enumeration#Fast-enumeration&quot;&gt;快速枚举&lt;/a&gt; [ &lt;a href=&quot;index#SEC_Contents&quot;&gt;目录&lt;/a&gt; ] [ &lt;a href=&quot;https://gcc.gnu.org/onlinedocs/gcc-9.2.0/gcc/Option-Index.html#Option-Index&quot;&gt;索引&lt;/a&gt; ]</target>
        </trans-unit>
        <trans-unit id="01b241e71cd4dc628aefbb9fd607bdcfacb287a1" translate="yes" xml:space="preserve">
          <source>Previous: &lt;a href=&quot;gcov_002dtool-intro#Gcov_002dtool-Intro&quot;&gt;Gcov-tool Intro&lt;/a&gt;, Up: &lt;a href=&quot;gcov_002dtool#Gcov_002dtool&quot;&gt;Gcov-tool&lt;/a&gt; [&lt;a href=&quot;index#SEC_Contents&quot;&gt;Contents&lt;/a&gt;][&lt;a href=&quot;https://gcc.gnu.org/onlinedocs/gcc-10.2.0/gcc/Option-Index.html#Option-Index&quot;&gt;Index&lt;/a&gt;]</source>
          <target state="translated">上&lt;a href=&quot;gcov_002dtool-intro#Gcov_002dtool-Intro&quot;&gt;一篇&lt;/a&gt;：Gcov-tool简介，上&lt;a href=&quot;gcov_002dtool#Gcov_002dtool&quot;&gt;一篇&lt;/a&gt;：Gcov-tool [&lt;a href=&quot;index#SEC_Contents&quot;&gt;目录&lt;/a&gt;] [&lt;a href=&quot;https://gcc.gnu.org/onlinedocs/gcc-10.2.0/gcc/Option-Index.html#Option-Index&quot;&gt;索引&lt;/a&gt;]</target>
        </trans-unit>
        <trans-unit id="0cd478c56630e085181033925575eebae41d495c" translate="yes" xml:space="preserve">
          <source>Previous: &lt;a href=&quot;gcov_002dtool-intro#Gcov_002dtool-Intro&quot;&gt;Gcov-tool Intro&lt;/a&gt;, Up: &lt;a href=&quot;gcov_002dtool#Gcov_002dtool&quot;&gt;Gcov-tool&lt;/a&gt; [&lt;a href=&quot;index#SEC_Contents&quot;&gt;Contents&lt;/a&gt;][&lt;a href=&quot;https://gcc.gnu.org/onlinedocs/gcc-9.2.0/gcc/Option-Index.html#Option-Index&quot;&gt;Index&lt;/a&gt;]</source>
          <target state="translated">上&lt;a href=&quot;gcov_002dtool-intro#Gcov_002dtool-Intro&quot;&gt;一篇&lt;/a&gt;：Gcov-tool简介，上&lt;a href=&quot;gcov_002dtool#Gcov_002dtool&quot;&gt;一篇&lt;/a&gt;：Gcov-tool [ &lt;a href=&quot;index#SEC_Contents&quot;&gt;目录&lt;/a&gt; ] [ &lt;a href=&quot;https://gcc.gnu.org/onlinedocs/gcc-9.2.0/gcc/Option-Index.html#Option-Index&quot;&gt;索引&lt;/a&gt; ]</target>
        </trans-unit>
        <trans-unit id="4a9566099b54e5c67ad5605d031fa9346aeb2bbe" translate="yes" xml:space="preserve">
          <source>Previous: &lt;a href=&quot;global-register-variables#Global-Register-Variables&quot;&gt;Global Register Variables&lt;/a&gt;, Up: &lt;a href=&quot;explicit-register-variables#Explicit-Register-Variables&quot;&gt;Explicit Register Variables&lt;/a&gt; [&lt;a href=&quot;index#SEC_Contents&quot;&gt;Contents&lt;/a&gt;][&lt;a href=&quot;https://gcc.gnu.org/onlinedocs/gcc-10.2.0/gcc/Option-Index.html#Option-Index&quot;&gt;Index&lt;/a&gt;]</source>
          <target state="translated">上一页：&lt;a href=&quot;global-register-variables#Global-Register-Variables&quot;&gt;全局寄存器变量&lt;/a&gt;，向上：&lt;a href=&quot;explicit-register-variables#Explicit-Register-Variables&quot;&gt;显式寄存器变量&lt;/a&gt;[&lt;a href=&quot;index#SEC_Contents&quot;&gt;目录&lt;/a&gt;] [&lt;a href=&quot;https://gcc.gnu.org/onlinedocs/gcc-10.2.0/gcc/Option-Index.html#Option-Index&quot;&gt;索引&lt;/a&gt;]</target>
        </trans-unit>
        <trans-unit id="2e40d48fc32253bef8628625302a0abbcde80f82" translate="yes" xml:space="preserve">
          <source>Previous: &lt;a href=&quot;global-register-variables#Global-Register-Variables&quot;&gt;Global Register Variables&lt;/a&gt;, Up: &lt;a href=&quot;explicit-register-variables#Explicit-Register-Variables&quot;&gt;Explicit Register Variables&lt;/a&gt; [&lt;a href=&quot;index#SEC_Contents&quot;&gt;Contents&lt;/a&gt;][&lt;a href=&quot;https://gcc.gnu.org/onlinedocs/gcc-9.2.0/gcc/Option-Index.html#Option-Index&quot;&gt;Index&lt;/a&gt;]</source>
          <target state="translated">上一页：&lt;a href=&quot;global-register-variables#Global-Register-Variables&quot;&gt;全局寄存器变量&lt;/a&gt;，向上：&lt;a href=&quot;explicit-register-variables#Explicit-Register-Variables&quot;&gt;显式寄存器变量&lt;/a&gt; [ &lt;a href=&quot;index#SEC_Contents&quot;&gt;目录&lt;/a&gt; ] [ &lt;a href=&quot;https://gcc.gnu.org/onlinedocs/gcc-9.2.0/gcc/Option-Index.html#Option-Index&quot;&gt;索引&lt;/a&gt; ]</target>
        </trans-unit>
        <trans-unit id="e78f20be2ed14e47d0193eab14570be8658e8dcd" translate="yes" xml:space="preserve">
          <source>Previous: &lt;a href=&quot;modifiers#Modifiers&quot;&gt;Modifiers&lt;/a&gt;, Up: &lt;a href=&quot;constraints#Constraints&quot;&gt;Constraints&lt;/a&gt; [&lt;a href=&quot;index#SEC_Contents&quot;&gt;Contents&lt;/a&gt;][&lt;a href=&quot;https://gcc.gnu.org/onlinedocs/gcc-10.2.0/gcc/Option-Index.html#Option-Index&quot;&gt;Index&lt;/a&gt;]</source>
          <target state="translated">上一页：&lt;a href=&quot;modifiers#Modifiers&quot;&gt;修饰符&lt;/a&gt;，向上：&lt;a href=&quot;constraints#Constraints&quot;&gt;约束&lt;/a&gt;[&lt;a href=&quot;index#SEC_Contents&quot;&gt;目录&lt;/a&gt;] [&lt;a href=&quot;https://gcc.gnu.org/onlinedocs/gcc-10.2.0/gcc/Option-Index.html#Option-Index&quot;&gt;索引&lt;/a&gt;]</target>
        </trans-unit>
        <trans-unit id="180c60ac0f109d44e10ade3943d2c55400d71f8d" translate="yes" xml:space="preserve">
          <source>Previous: &lt;a href=&quot;modifiers#Modifiers&quot;&gt;Modifiers&lt;/a&gt;, Up: &lt;a href=&quot;constraints#Constraints&quot;&gt;Constraints&lt;/a&gt; [&lt;a href=&quot;index#SEC_Contents&quot;&gt;Contents&lt;/a&gt;][&lt;a href=&quot;https://gcc.gnu.org/onlinedocs/gcc-9.2.0/gcc/Option-Index.html#Option-Index&quot;&gt;Index&lt;/a&gt;]</source>
          <target state="translated">上一页：&lt;a href=&quot;modifiers#Modifiers&quot;&gt;修饰符&lt;/a&gt;，向上：&lt;a href=&quot;constraints#Constraints&quot;&gt;约束&lt;/a&gt; [ &lt;a href=&quot;index#SEC_Contents&quot;&gt;目录&lt;/a&gt; ] [ &lt;a href=&quot;https://gcc.gnu.org/onlinedocs/gcc-9.2.0/gcc/Option-Index.html#Option-Index&quot;&gt;索引&lt;/a&gt; ]</target>
        </trans-unit>
        <trans-unit id="71dcd5c672b6e4a395348302781c78ca4d6c6269" translate="yes" xml:space="preserve">
          <source>Previous: &lt;a href=&quot;non_002dbugs#Non_002dbugs&quot;&gt;Non-bugs&lt;/a&gt;, Up: &lt;a href=&quot;trouble#Trouble&quot;&gt;Trouble&lt;/a&gt; [&lt;a href=&quot;index#SEC_Contents&quot;&gt;Contents&lt;/a&gt;][&lt;a href=&quot;https://gcc.gnu.org/onlinedocs/gcc-10.2.0/gcc/Option-Index.html#Option-Index&quot;&gt;Index&lt;/a&gt;]</source>
          <target state="translated">上一篇：&lt;a href=&quot;non_002dbugs#Non_002dbugs&quot;&gt;非错误&lt;/a&gt;，上一篇：&lt;a href=&quot;trouble#Trouble&quot;&gt;故障&lt;/a&gt;[&lt;a href=&quot;index#SEC_Contents&quot;&gt;目录&lt;/a&gt;] [&lt;a href=&quot;https://gcc.gnu.org/onlinedocs/gcc-10.2.0/gcc/Option-Index.html#Option-Index&quot;&gt;索引&lt;/a&gt;]</target>
        </trans-unit>
        <trans-unit id="2690cc6bd85085d1a20978cb1ff148ed57eeb42a" translate="yes" xml:space="preserve">
          <source>Previous: &lt;a href=&quot;non_002dbugs#Non_002dbugs&quot;&gt;Non-bugs&lt;/a&gt;, Up: &lt;a href=&quot;trouble#Trouble&quot;&gt;Trouble&lt;/a&gt; [&lt;a href=&quot;index#SEC_Contents&quot;&gt;Contents&lt;/a&gt;][&lt;a href=&quot;https://gcc.gnu.org/onlinedocs/gcc-9.2.0/gcc/Option-Index.html#Option-Index&quot;&gt;Index&lt;/a&gt;]</source>
          <target state="translated">上一页：&lt;a href=&quot;non_002dbugs#Non_002dbugs&quot;&gt;非错误&lt;/a&gt;，向上：&lt;a href=&quot;trouble#Trouble&quot;&gt;故障&lt;/a&gt; [ &lt;a href=&quot;index#SEC_Contents&quot;&gt;目录&lt;/a&gt; ] [ &lt;a href=&quot;https://gcc.gnu.org/onlinedocs/gcc-9.2.0/gcc/Option-Index.html#Option-Index&quot;&gt;索引&lt;/a&gt; ]</target>
        </trans-unit>
        <trans-unit id="486364a1dc0ac59682deece8e5ab665d6c4c2b74" translate="yes" xml:space="preserve">
          <source>Previous: &lt;a href=&quot;paired_002dsingle-built_002din-functions#Paired_002dSingle-Built_002din-Functions&quot;&gt;Paired-Single Built-in Functions&lt;/a&gt;, Up: &lt;a href=&quot;mips-loongson-built_002din-functions#MIPS-Loongson-Built_002din-Functions&quot;&gt;MIPS Loongson Built-in Functions&lt;/a&gt; [&lt;a href=&quot;index#SEC_Contents&quot;&gt;Contents&lt;/a&gt;][&lt;a href=&quot;https://gcc.gnu.org/onlinedocs/gcc-10.2.0/gcc/Option-Index.html#Option-Index&quot;&gt;Index&lt;/a&gt;]</source>
          <target state="translated">上一页：&lt;a href=&quot;paired_002dsingle-built_002din-functions#Paired_002dSingle-Built_002din-Functions&quot;&gt;配对单内置函数&lt;/a&gt;上&lt;a href=&quot;mips-loongson-built_002din-functions#MIPS-Loongson-Built_002din-Functions&quot;&gt;一篇&lt;/a&gt;：MIPS Loongson内置函数[&lt;a href=&quot;index#SEC_Contents&quot;&gt;目录&lt;/a&gt;] [&lt;a href=&quot;https://gcc.gnu.org/onlinedocs/gcc-10.2.0/gcc/Option-Index.html#Option-Index&quot;&gt;索引&lt;/a&gt;]</target>
        </trans-unit>
        <trans-unit id="518a1b2a1a9d78ecacf627dac6376da5b9566530" translate="yes" xml:space="preserve">
          <source>Previous: &lt;a href=&quot;paired_002dsingle-built_002din-functions#Paired_002dSingle-Built_002din-Functions&quot;&gt;Paired-Single Built-in Functions&lt;/a&gt;, Up: &lt;a href=&quot;mips-loongson-built_002din-functions#MIPS-Loongson-Built_002din-Functions&quot;&gt;MIPS Loongson Built-in Functions&lt;/a&gt; [&lt;a href=&quot;index#SEC_Contents&quot;&gt;Contents&lt;/a&gt;][&lt;a href=&quot;https://gcc.gnu.org/onlinedocs/gcc-9.2.0/gcc/Option-Index.html#Option-Index&quot;&gt;Index&lt;/a&gt;]</source>
          <target state="translated">上&lt;a href=&quot;paired_002dsingle-built_002din-functions#Paired_002dSingle-Built_002din-Functions&quot;&gt;一篇&lt;/a&gt;：配对单内置函数上&lt;a href=&quot;mips-loongson-built_002din-functions#MIPS-Loongson-Built_002din-Functions&quot;&gt;一篇&lt;/a&gt;：MIPS Loongson内置函数 [ &lt;a href=&quot;index#SEC_Contents&quot;&gt;目录&lt;/a&gt; ] [ &lt;a href=&quot;https://gcc.gnu.org/onlinedocs/gcc-9.2.0/gcc/Option-Index.html#Option-Index&quot;&gt;索引&lt;/a&gt; ]</target>
        </trans-unit>
        <trans-unit id="5a3c60991462b709bc1ab9bb096c67236fb69620" translate="yes" xml:space="preserve">
          <source>Previous: &lt;a href=&quot;powerpc-altivec-built_002din-functions-available-on-isa-2_002e07#PowerPC-AltiVec-Built_002din-Functions-Available-on-ISA-2_002e07&quot;&gt;PowerPC AltiVec Built-in Functions Available on ISA 2.07&lt;/a&gt;, Up: &lt;a href=&quot;powerpc-altivec_002fvsx-built_002din-functions#PowerPC-AltiVec_002fVSX-Built_002din-Functions&quot;&gt;PowerPC AltiVec/VSX Built-in Functions&lt;/a&gt; [&lt;a href=&quot;index#SEC_Contents&quot;&gt;Contents&lt;/a&gt;][&lt;a href=&quot;https://gcc.gnu.org/onlinedocs/gcc-10.2.0/gcc/Option-Index.html#Option-Index&quot;&gt;Index&lt;/a&gt;]</source>
          <target state="translated">上&lt;a href=&quot;powerpc-altivec-built_002din-functions-available-on-isa-2_002e07#PowerPC-AltiVec-Built_002din-Functions-Available-on-ISA-2_002e07&quot;&gt;一篇&lt;/a&gt;：ISA 2.07上可用的PowerPC AltiVec内置函数，上&lt;a href=&quot;powerpc-altivec_002fvsx-built_002din-functions#PowerPC-AltiVec_002fVSX-Built_002din-Functions&quot;&gt;一篇&lt;/a&gt;：PowerPC AltiVec / VSX内置函数[&lt;a href=&quot;index#SEC_Contents&quot;&gt;目录&lt;/a&gt;] [&lt;a href=&quot;https://gcc.gnu.org/onlinedocs/gcc-10.2.0/gcc/Option-Index.html#Option-Index&quot;&gt;索引&lt;/a&gt;]</target>
        </trans-unit>
        <trans-unit id="8a6424fd89847064955d1584a816d8d119f016ca" translate="yes" xml:space="preserve">
          <source>Previous: &lt;a href=&quot;powerpc-altivec-built_002din-functions-available-on-isa-2_002e07#PowerPC-AltiVec-Built_002din-Functions-Available-on-ISA-2_002e07&quot;&gt;PowerPC AltiVec Built-in Functions Available on ISA 2.07&lt;/a&gt;, Up: &lt;a href=&quot;powerpc-altivec_002fvsx-built_002din-functions#PowerPC-AltiVec_002fVSX-Built_002din-Functions&quot;&gt;PowerPC AltiVec/VSX Built-in Functions&lt;/a&gt; [&lt;a href=&quot;index#SEC_Contents&quot;&gt;Contents&lt;/a&gt;][&lt;a href=&quot;https://gcc.gnu.org/onlinedocs/gcc-9.2.0/gcc/Option-Index.html#Option-Index&quot;&gt;Index&lt;/a&gt;]</source>
          <target state="translated">上&lt;a href=&quot;powerpc-altivec-built_002din-functions-available-on-isa-2_002e07#PowerPC-AltiVec-Built_002din-Functions-Available-on-ISA-2_002e07&quot;&gt;一篇&lt;/a&gt;：ISA 2.07上可用的PowerPC AltiVec内置函数，上：&lt;a href=&quot;powerpc-altivec_002fvsx-built_002din-functions#PowerPC-AltiVec_002fVSX-Built_002din-Functions&quot;&gt;PowerPC AltiVec / VSX内置函数&lt;/a&gt; [ &lt;a href=&quot;index#SEC_Contents&quot;&gt;目录&lt;/a&gt; ] [ &lt;a href=&quot;https://gcc.gnu.org/onlinedocs/gcc-9.2.0/gcc/Option-Index.html#Option-Index&quot;&gt;索引&lt;/a&gt; ]</target>
        </trans-unit>
        <trans-unit id="5070ca712488a6295aeb93bb4b823f413e03dde1" translate="yes" xml:space="preserve">
          <source>Print (on standard error output) the commands executed to run the stages of compilation. Also print the version number of the compiler driver program and of the preprocessor and the compiler proper.</source>
          <target state="translated">打印(在标准错误输出上)执行的编译阶段的命令。同时打印编译器驱动程序、预处理器和编译器的版本号。</target>
        </trans-unit>
        <trans-unit id="f0802ef33bb80e0daadac78e85825604f940dbf7" translate="yes" xml:space="preserve">
          <source>Print (on the standard output) a description of target-specific command-line options for each tool. For some targets extra target-specific information may also be printed.</source>
          <target state="translated">打印(在标准输出上)每个工具的特定目标命令行选项的描述。对于某些目标,还可以打印额外的目标特定信息。</target>
        </trans-unit>
        <trans-unit id="da44c4f450112c4e0f6f8b3b80edf560950a6ee6" translate="yes" xml:space="preserve">
          <source>Print (on the standard output) a description of the command-line options understood by &lt;code&gt;gcc&lt;/code&gt;. If the</source>
          <target state="translated">打印（在标准输出上） &lt;code&gt;gcc&lt;/code&gt; 理解的命令行选项的描述。如果</target>
        </trans-unit>
        <trans-unit id="e18b1edf66bd2215edee93ad1bfe2475848c1c40" translate="yes" xml:space="preserve">
          <source>Print (on the standard output) a description of the command-line options understood by the compiler that fit into all specified classes and qualifiers. These are the supported classes:</source>
          <target state="translated">打印(在标准输出上)编译器理解的适合所有指定类和限定符的命令行选项的描述。这些是支持的类。</target>
        </trans-unit>
        <trans-unit id="36e2db25cdaf136a1b1871f7bddede044a014af0" translate="yes" xml:space="preserve">
          <source>Print (or do not print) additional debug information when compiling. The default is to not print debug information.</source>
          <target state="translated">编译时打印(或不打印)额外的调试信息。默认情况是不打印调试信息。</target>
        </trans-unit>
        <trans-unit id="042a1c2bccf30839985d02fecb0aaa588016c586" translate="yes" xml:space="preserve">
          <source>Print &lt;var&gt;str&lt;/var&gt; as an error message. &lt;var&gt;str&lt;/var&gt; is terminated by a newline. Use this when inconsistent options are detected.</source>
          <target state="translated">将 &lt;var&gt;str&lt;/var&gt; 打印为错误消息。 &lt;var&gt;str&lt;/var&gt; 由换行符终止。当检测到不一致的选项时，请使用此选项。</target>
        </trans-unit>
        <trans-unit id="646c20558d20e2f30241cc9574d344b39d2a71e9" translate="yes" xml:space="preserve">
          <source>Print CPU tuning information as comment in assembler file. This is an option used only for regression testing of the compiler and not intended for ordinary use in compiling code. This option is disabled by default.</source>
          <target state="translated">在汇编文件中以注释形式打印CPU调整信息。这个选项只用于编译器的回归测试,而不是用于普通的编译代码。这个选项默认是禁用的。</target>
        </trans-unit>
        <trans-unit id="0c02ead981dc46c74eca673ebbadeb5775102eb4" translate="yes" xml:space="preserve">
          <source>Print a raw representation of the tree. By default, trees are pretty-printed into a C-like representation.</source>
          <target state="translated">打印树的原始表示方式。默认情况下,树木是以类似C语言的方式打印的。</target>
        </trans-unit>
        <trans-unit id="bee9976317d77665142eb597fb744cf4a5bc63c3" translate="yes" xml:space="preserve">
          <source>Print an absolute memory reference.</source>
          <target state="translated">打印一个绝对的内存引用。</target>
        </trans-unit>
        <trans-unit id="c1b62ec38c8c02ce83661de096266f4e8ad36d5d" translate="yes" xml:space="preserve">
          <source>Print detailed optimization information. This includes &amp;lsquo;</source>
          <target state="translated">打印详细的优化信息。这包括 '</target>
        </trans-unit>
        <trans-unit id="747925ea13ebc5265845c242e39f7d5de361cc9c" translate="yes" xml:space="preserve">
          <source>Print fix-it hints to stderr in unified diff format, after any diagnostics are printed. For example:</source>
          <target state="translated">在任何诊断程序被打印出来后,以统一的 diff 格式将修复提示打印到 stderr。例如</target>
        </trans-unit>
        <trans-unit id="27e48e9709e199f67d90728d88acda8122e690ad" translate="yes" xml:space="preserve">
          <source>Print full gcda filename.</source>
          <target state="translated">打印完整的gcda文件名。</target>
        </trans-unit>
        <trans-unit id="b3444c534ef235bd7cfb2bb1457050c5df19fa98" translate="yes" xml:space="preserve">
          <source>Print function level overlap score.</source>
          <target state="translated">打印功能级别重叠得分。</target>
        </trans-unit>
        <trans-unit id="2259612d90015512d8565367d9b66e6d1907b7e3" translate="yes" xml:space="preserve">
          <source>Print information about missed optimizations. Individual passes control which information to include in the output.</source>
          <target state="translated">打印错过的优化信息。各个通道控制哪些信息要包含在输出中。</target>
        </trans-unit>
        <trans-unit id="0e737c134e058a6b5be3c38b4d61e9060cbe2d6f" translate="yes" xml:space="preserve">
          <source>Print information when an optimization is successfully applied. It is up to a pass to decide which information is relevant. For example, the vectorizer passes print the source location of loops which are successfully vectorized.</source>
          <target state="translated">当优化成功应用时,打印信息。由pass决定哪些信息是相关的。例如,矢量化器通证会打印成功矢量化的循环的源位置。</target>
        </trans-unit>
        <trans-unit id="49e8d2891f1bb00bf2fce45c40fe769f980367c0" translate="yes" xml:space="preserve">
          <source>Print object level overlap score.</source>
          <target state="translated">打印对象级重叠得分。</target>
        </trans-unit>
        <trans-unit id="3a95fbc869807d22e5b89ec0f92871dcddcd83ac" translate="yes" xml:space="preserve">
          <source>Print on</source>
          <target state="translated">打印</target>
        </trans-unit>
        <trans-unit id="fdc5672b8cdd0196a1822504903f9194000cffdc" translate="yes" xml:space="preserve">
          <source>Print raw symbol name (without syntax-specific prefixes).</source>
          <target state="translated">打印原始符号名称(不含语法专用前缀)。</target>
        </trans-unit>
        <trans-unit id="8b3eb16e33ebf816827fd23a1d5134fcb39c5577" translate="yes" xml:space="preserve">
          <source>Print the DImode name of the register.</source>
          <target state="translated">打印寄存器的DImode名称。</target>
        </trans-unit>
        <trans-unit id="8cbb39fe370973258d3221791eb533a79143c1a4" translate="yes" xml:space="preserve">
          <source>Print the HImode name of the register.</source>
          <target state="translated">打印寄存器的HImode名称。</target>
        </trans-unit>
        <trans-unit id="5f0523fe616c1a4ec29efecc044a8b533dbfc088" translate="yes" xml:space="preserve">
          <source>Print the QImode name for a &amp;ldquo;high&amp;rdquo; register.</source>
          <target state="translated">打印&amp;ldquo;高&amp;rdquo;寄存器的QImode名称。</target>
        </trans-unit>
        <trans-unit id="cba0544fdad24e8c71fa2998d0fc17006f470a5d" translate="yes" xml:space="preserve">
          <source>Print the QImode name of the register.</source>
          <target state="translated">打印寄存器的QImode名称。</target>
        </trans-unit>
        <trans-unit id="415fe8734ed5c7ca7d367010aad83e19c898fcd9" translate="yes" xml:space="preserve">
          <source>Print the SImode name of the register.</source>
          <target state="translated">打印寄存器的SImode名称。</target>
        </trans-unit>
        <trans-unit id="7bde1647cee4db781bd592bee36a2a9579dff9ad" translate="yes" xml:space="preserve">
          <source>Print the address in Double Integer (DImode) mode (8 bytes) when the target is 64-bit. Otherwise mode is unspecified (VOIDmode).</source>
          <target state="translated">当目标是64位时,以双整数(DImode)模式(8个字节)打印地址。否则模式为未指定(VOIDmode)。</target>
        </trans-unit>
        <trans-unit id="0a2a748643cbf5bccb4c8b64fbb809daa63616ff" translate="yes" xml:space="preserve">
          <source>Print the address of each node. Usually this is not meaningful as it changes according to the environment and source file. Its primary use is for tying up a dump file with a debug environment.</source>
          <target state="translated">打印每个节点的地址。通常这并没有什么意义,因为它根据环境和源文件的不同而变化。它的主要用途是用于绑定dump文件与调试环境。</target>
        </trans-unit>
        <trans-unit id="c30bf938013bc01150cd4223148df68eeb709db3" translate="yes" xml:space="preserve">
          <source>Print the compiler version (for example, &lt;code&gt;3.0&lt;/code&gt;, &lt;code&gt;6.3.0&lt;/code&gt; or &lt;code&gt;7&lt;/code&gt;)&amp;mdash;and don&amp;rsquo;t do anything else. This is the compiler version used in filesystem paths and specs. Depending on how the compiler has been configured it can be just a single number (major version), two numbers separated by a dot (major and minor version) or three numbers separated by dots (major, minor and patchlevel version).</source>
          <target state="translated">打印编译器版本（例如， &lt;code&gt;3.0&lt;/code&gt; ， &lt;code&gt;6.3.0&lt;/code&gt; 或 &lt;code&gt;7&lt;/code&gt; ） -和没有其他人做任何事情。这是文件系统路径和规范中使用的编译器版本。根据编译器的配置方式，它可以是一个数字（主要版本），两个以点分隔的数字（主要和次要版本）或三个以点分隔的数字（主要，次要和补丁程序版本）。</target>
        </trans-unit>
        <trans-unit id="39f02afa5381880ed9364aabcf135637b524d215" translate="yes" xml:space="preserve">
          <source>Print the compiler&amp;rsquo;s built-in specs&amp;mdash;and don&amp;rsquo;t do anything else. (This is used when GCC itself is being built.) See &lt;a href=&quot;spec-files#Spec-Files&quot;&gt;Spec Files&lt;/a&gt;.</source>
          <target state="translated">打印编译器的内置规范，而不做其他任何事情。（在构建GCC本身时使用。）请参见&lt;a href=&quot;spec-files#Spec-Files&quot;&gt;Spec Files&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="653f7adb65f1f84d8d88241f8ddf357af1eec6c5" translate="yes" xml:space="preserve">
          <source>Print the compiler&amp;rsquo;s target machine (for example, &amp;lsquo;</source>
          <target state="translated">打印编译器的目标计算机（例如，&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="2ea813d3d56acd15b7aece5721398087dd287686" translate="yes" xml:space="preserve">
          <source>Print the directory name corresponding to the multilib selected by any other switches present in the command line. This directory is supposed to exist in &lt;code&gt;GCC_EXEC_PREFIX&lt;/code&gt;.</source>
          <target state="translated">打印与命令行中存在的任何其他开关选择的multilib对应的目录名称。该目录应该存在于 &lt;code&gt;GCC_EXEC_PREFIX&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="ce50f8d87d282115171e0d700a3119dab66c3b68" translate="yes" xml:space="preserve">
          <source>Print the full absolute name of the library file &lt;var&gt;library&lt;/var&gt; that would be used when linking&amp;mdash;and don&amp;rsquo;t do anything else. With this option, GCC does not compile or link anything; it just prints the file name.</source>
          <target state="translated">打印链接时将使用的库文件 &lt;var&gt;library&lt;/var&gt; 绝对全名，而无需执行其他任何操作。使用此选项，GCC不会编译或链接任何内容；它只是打印文件名。</target>
        </trans-unit>
        <trans-unit id="2d08bb037870c1271f6d358ce7e39175cb5c6846" translate="yes" xml:space="preserve">
          <source>Print the full compiler version&amp;mdash;and don&amp;rsquo;t do anything else. The output is always three numbers separated by dots, major, minor and patchlevel version.</source>
          <target state="translated">打印完整的编译器版本-请勿执行其他任何操作。输出始终是三个数字，由点，主要，次要和补丁级别版本分隔。</target>
        </trans-unit>
        <trans-unit id="1ca2b71a9e603f4ac7cb5b1a49646b6058026d67" translate="yes" xml:space="preserve">
          <source>Print the label name with no punctuation.</source>
          <target state="translated">打印标签名称,不要有标点符号。</target>
        </trans-unit>
        <trans-unit id="ed777f4d8158d9a13715e5d83bcf213db1f9294b" translate="yes" xml:space="preserve">
          <source>Print the mapping from multilib directory names to compiler switches that enable them. The directory name is separated from the switches by &amp;lsquo;</source>
          <target state="translated">打印从multilib目录名到启用它们的编译器开关的映射。目录名称与交换机之间用'分隔</target>
        </trans-unit>
        <trans-unit id="b73d8c440e7cc936048904194d2e85dfdb15e4ef" translate="yes" xml:space="preserve">
          <source>Print the name and the counter upper bound for all debug counters.</source>
          <target state="translated">打印所有调试计数器的名称和计数器上界。</target>
        </trans-unit>
        <trans-unit id="c0f3c0f3c07600ebb279734d69613c90e09b8dbd" translate="yes" xml:space="preserve">
          <source>Print the name of each header file used, in addition to other normal activities. Each name is indented to show how deep in the &amp;lsquo;</source>
          <target state="translated">除其他正常活动外，还打印所使用的每个头文件的名称。每个名称都会缩进，以显示&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="6ed5656674995024e55926271a786ceb4ef7c456" translate="yes" xml:space="preserve">
          <source>Print the name of the configured installation directory and a list of program and library directories &lt;code&gt;gcc&lt;/code&gt; searches&amp;mdash;and don&amp;rsquo;t do anything else.</source>
          <target state="translated">打印已配置的安装目录的名称以及 &lt;code&gt;gcc&lt;/code&gt; 搜索的程序和库目录的列表-请勿执行其他任何操作。</target>
        </trans-unit>
        <trans-unit id="f46fbec7a98d95993ab6d7180f46da35309a305c" translate="yes" xml:space="preserve">
          <source>Print the opcode suffix for the size of the current integer operand (one of &lt;code&gt;b&lt;/code&gt;/&lt;code&gt;w&lt;/code&gt;/&lt;code&gt;l&lt;/code&gt;/&lt;code&gt;q&lt;/code&gt;).</source>
          <target state="translated">打印当前整数操作数（ &lt;code&gt;b&lt;/code&gt; / &lt;code&gt;w&lt;/code&gt; / &lt;code&gt;l&lt;/code&gt; / &lt;code&gt;q&lt;/code&gt; 之一）大小的操作码后缀。</target>
        </trans-unit>
        <trans-unit id="908b57b33b152b029092573720dba6a435ce6981" translate="yes" xml:space="preserve">
          <source>Print the path to OS libraries for the selected multiarch, relative to some</source>
          <target state="translated">打印所选多库的操作系统库的路径,相对于某个</target>
        </trans-unit>
        <trans-unit id="5d7b39edfb2bb437d185c29750569c1585d1f048" translate="yes" xml:space="preserve">
          <source>Print the path to OS libraries for the selected multilib, relative to some</source>
          <target state="translated">打印所选多库的操作系统库的路径,相对于某个</target>
        </trans-unit>
        <trans-unit id="b628c9460b668c00eb8e6efa459a4b3817bd622d" translate="yes" xml:space="preserve">
          <source>Print the suffix added to the target sysroot when searching for headers, or give an error if the compiler is not configured with such a suffix&amp;mdash;and don&amp;rsquo;t do anything else.</source>
          <target state="translated">搜索标题时，打印添加到目标sysroot的后缀，如果编译器未配置后缀，则显示错误，并且不要执行任何其他操作。</target>
        </trans-unit>
        <trans-unit id="08d61da80381f2354abfcc2dc79c82da27bcfcde" translate="yes" xml:space="preserve">
          <source>Print the target sysroot directory that is used during compilation. This is the target sysroot specified either at configure time or using the</source>
          <target state="translated">打印编译时使用的目标sysroot目录。这是在配置时或使用下面的命令指定的目标系统根目录。</target>
        </trans-unit>
        <trans-unit id="38b6abf4c9502a0a96a0b149ec935db21970d271" translate="yes" xml:space="preserve">
          <source>Print verbose information about optimizations, such as certain transformations, more detailed messages about decisions etc.</source>
          <target state="translated">打印有关优化的口头信息,如某些变换,更详细的决策信息等。</target>
        </trans-unit>
        <trans-unit id="a2dcd67e0df70361f07cda6c2139ad5ffd3e3acd" translate="yes" xml:space="preserve">
          <source>Print verbose informations related to basic blocks and arcs.</source>
          <target state="translated">打印与基本块和弧相关的详细信息。</target>
        </trans-unit>
        <trans-unit id="14433cdcc593ba724150c5d3b1d1053f1e28730c" translate="yes" xml:space="preserve">
          <source>Print warning messages for constructs found in system header files. Warnings from system headers are normally suppressed, on the assumption that they usually do not indicate real problems and would only make the compiler output harder to read. Using this command-line option tells GCC to emit warnings from system headers as if they occurred in user code. However, note that using</source>
          <target state="translated">打印系统头文件中发现的构造的警告信息。来自系统头文件的警告通常会被抑制,因为它们通常不会显示真正的问题,只会让编译器的输出更难读。使用这个命令行选项可以让GCC发出来自系统头文件的警告,就像它们发生在用户代码中一样。但是,请注意,使用这个命令行选项可以让GCC从系统头文件中发出警告,就像它们发生在用户代码中一样。</target>
        </trans-unit>
        <trans-unit id="483c1121bee3466e31656e5ccaa4978d23e0bae2" translate="yes" xml:space="preserve">
          <source>Printable strings which are the name of the current function.</source>
          <target state="translated">可打印的字符串,是当前函数的名称。</target>
        </trans-unit>
        <trans-unit id="b65afc72a52b24c7e17f59c175dc14fa999357ad" translate="yes" xml:space="preserve">
          <source>Printing GCC configuration info, statistics, and debugging dumps.</source>
          <target state="translated">打印GCC配置信息、统计数据和调试转储。</target>
        </trans-unit>
        <trans-unit id="223d9059a8851156459124a029c324e8d582a617" translate="yes" xml:space="preserve">
          <source>Prints &lt;var&gt;string&lt;/var&gt; as a compiler message on compilation. The message is informational only, and is neither a compilation warning nor an error. Newlines can be included in the string by using the &amp;lsquo;</source>
          <target state="translated">在编译时将 &lt;var&gt;string&lt;/var&gt; 打印为编译器消息。该消息仅供参考，既不是编译警告也不是错误。可以使用'将换行符包含在字符串中</target>
        </trans-unit>
        <trans-unit id="ba052fde4908541fb5507b0c0b8fa5890f691843" translate="yes" xml:space="preserve">
          <source>Prints a report with internal details on the workings of the link-time optimizer. The contents of this report vary from version to version. It is meant to be useful to GCC developers when processing object files in LTO mode (via</source>
          <target state="translated">打印一份关于链接时间优化器工作的内部细节报告。该报告的内容因版本而异。当GCC开发人员在LTO模式下处理对象文件(通过</target>
        </trans-unit>
        <trans-unit id="356b649f8a5b2eeac75d52d3fde25687e1baf75a" translate="yes" xml:space="preserve">
          <source>PrivateHeaders</source>
          <target state="translated">PrivateHeaders</target>
        </trans-unit>
        <trans-unit id="2ad988ff4da432b2bd8d59157204ad932c4a0a31" translate="yes" xml:space="preserve">
          <source>Probability (in percent) that C++ inline function with comdat visibility are shared across multiple compilation units.</source>
          <target state="translated">具有comdat可见性的C++内联函数被多个编译单元共享的概率(百分比)。</target>
        </trans-unit>
        <trans-unit id="850fe6834f667b77b7e2ae19ee297ae3dd8470cf" translate="yes" xml:space="preserve">
          <source>Problems using GCC with other compilers, and with certain linkers, assemblers and debuggers.</source>
          <target state="translated">使用GCC与其他编译器,以及与某些链接器、汇编器和调试器的问题。</target>
        </trans-unit>
        <trans-unit id="9c6060b3674c249414e5152b2230ab7030cef431" translate="yes" xml:space="preserve">
          <source>Process &lt;var&gt;file&lt;/var&gt; after the compiler reads in the standard</source>
          <target state="translated">编译器读入标准后的处理 &lt;var&gt;file&lt;/var&gt;</target>
        </trans-unit>
        <trans-unit id="191842ffa605d8dc7494dd7b68d3c292602796ee" translate="yes" xml:space="preserve">
          <source>Process &lt;var&gt;file&lt;/var&gt; as if &lt;code&gt;#include &quot;file&quot;&lt;/code&gt; appeared as the first line of the primary source file. However, the first directory searched for &lt;var&gt;file&lt;/var&gt; is the preprocessor&amp;rsquo;s working directory &lt;em&gt;instead of&lt;/em&gt; the directory containing the main source file. If not found there, it is searched for in the remainder of the &lt;code&gt;#include &quot;&amp;hellip;&quot;&lt;/code&gt; search chain as normal.</source>
          <target state="translated">处理 &lt;var&gt;file&lt;/var&gt; ，就好像 &lt;code&gt;#include &quot;file&quot;&lt;/code&gt; 出现在主要源文件的第一行一样。但是，搜索 &lt;var&gt;file&lt;/var&gt; 的第一个目录是预处理程序的工作目录，&lt;em&gt;而不是&lt;/em&gt;包含主源文件的目录。如果未在此处找到，则照常在 &lt;code&gt;#include &quot;&amp;hellip;&quot;&lt;/code&gt; 搜索链的其余部分中进行搜索。</target>
        </trans-unit>
        <trans-unit id="6734f891a855dd7a87c6c0bfe8fa052810c7d184" translate="yes" xml:space="preserve">
          <source>Process the &lt;code&gt;asm&lt;/code&gt; spec. This is used to compute the switches to be passed to the assembler.</source>
          <target state="translated">处理 &lt;code&gt;asm&lt;/code&gt; 规范。这用于计算要传递给汇编器的开关。</target>
        </trans-unit>
        <trans-unit id="38573e03d0821a17e48df49ff92134f08123d891" translate="yes" xml:space="preserve">
          <source>Process the &lt;code&gt;asm_final&lt;/code&gt; spec. This is a spec string for passing switches to an assembler post-processor, if such a program is needed.</source>
          <target state="translated">处理 &lt;code&gt;asm_final&lt;/code&gt; 规范。如果需要这样的程序，这是一个规范字符串，用于将开关传递到汇编器后处理器。</target>
        </trans-unit>
        <trans-unit id="c24b1fe466497f7be4ea4b8ebfb1c796e853db45" translate="yes" xml:space="preserve">
          <source>Process the &lt;code&gt;cc1&lt;/code&gt; spec. This is used to construct the options to be passed to the actual C compiler (&lt;code&gt;cc1&lt;/code&gt;).</source>
          <target state="translated">处理 &lt;code&gt;cc1&lt;/code&gt; 规范。这用于构造要传递给实际C编译器（ &lt;code&gt;cc1&lt;/code&gt; ）的选项。</target>
        </trans-unit>
        <trans-unit id="d6f17bdc842d5e5f40364c825949e630921d84fa" translate="yes" xml:space="preserve">
          <source>Process the &lt;code&gt;cc1plus&lt;/code&gt; spec. This is used to construct the options to be passed to the actual C++ compiler (&lt;code&gt;cc1plus&lt;/code&gt;).</source>
          <target state="translated">处理 &lt;code&gt;cc1plus&lt;/code&gt; 规范。这用于构造要传递给实际C ++编译器（ &lt;code&gt;cc1plus&lt;/code&gt; ）的选项。</target>
        </trans-unit>
        <trans-unit id="d5396bf6c9ae0325ba2157fe3770f71223e19ef3" translate="yes" xml:space="preserve">
          <source>Process the &lt;code&gt;cpp&lt;/code&gt; spec. This is used to construct the arguments to be passed to the C preprocessor.</source>
          <target state="translated">处理 &lt;code&gt;cpp&lt;/code&gt; 规范。这用于构造要传递给C预处理程序的参数。</target>
        </trans-unit>
        <trans-unit id="8c1edb26c6deccdbec0712ee2d8d11b418fd33df" translate="yes" xml:space="preserve">
          <source>Process the &lt;code&gt;endfile&lt;/code&gt; spec. This is a spec string that specifies the last object files that are passed to the linker.</source>
          <target state="translated">处理最终 &lt;code&gt;endfile&lt;/code&gt; 规范。这是一个规范字符串，用于指定最后一个传递给链接器的目标文件。</target>
        </trans-unit>
        <trans-unit id="a2255c514c878d9f84e377c0c64a134c8dce070b" translate="yes" xml:space="preserve">
          <source>Process the &lt;code&gt;lib&lt;/code&gt; spec. This is a spec string for deciding which libraries are included on the command line to the linker.</source>
          <target state="translated">处理 &lt;code&gt;lib&lt;/code&gt; 规范。这是一个规范字符串，用于确定链接程序的命令行上包括哪些库。</target>
        </trans-unit>
        <trans-unit id="21eaf027956ca118a365869c3f14adfd31ded482" translate="yes" xml:space="preserve">
          <source>Process the &lt;code&gt;libgcc&lt;/code&gt; spec. This is a spec string for deciding which GCC support library is included on the command line to the linker.</source>
          <target state="translated">处理 &lt;code&gt;libgcc&lt;/code&gt; 规范。这是一个规范字符串，用于确定链接器的命令行上包括哪个GCC支持库。</target>
        </trans-unit>
        <trans-unit id="4bace10c4995ad6f02604a1283502179576e6980" translate="yes" xml:space="preserve">
          <source>Process the &lt;code&gt;link&lt;/code&gt; spec. This is the spec for computing the command line passed to the linker. Typically it makes use of the &amp;lsquo;</source>
          <target state="translated">处理 &lt;code&gt;link&lt;/code&gt; 规范。这是用于计算传递给链接器的命令行的规范。通常，它使用&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="fb8c4d2ece6f487a7a0a494e47ae351215a61c64" translate="yes" xml:space="preserve">
          <source>Process the &lt;code&gt;startfile&lt;/code&gt; spec. This is a spec for deciding which object files are the first ones passed to the linker. Typically this might be a file named</source>
          <target state="translated">处理 &lt;code&gt;startfile&lt;/code&gt; 规范。这是用来确定哪些对象文件是第一个传递给链接器的规范。通常，这可能是一个名为</target>
        </trans-unit>
        <trans-unit id="ec518e4b3e80564c09131d1ae87879a3f6d17ed9" translate="yes" xml:space="preserve">
          <source>Processors based on the AMD K8 core with x86-64 instruction set support, including the AMD Opteron, Athlon 64, and Athlon 64 FX processors. (This supersets MMX, SSE, SSE2, 3DNow!, enhanced 3DNow! and 64-bit instruction set extensions.)</source>
          <target state="translated">基于AMD K8内核的处理器,支持x86-64指令集,包括AMD Opteron、Athlon 64和Athlon 64 FX处理器。(这超越了MMX、SSE、SSE2、3DNow!、增强型3DNow!和64位指令集扩展)。</target>
        </trans-unit>
        <trans-unit id="62590afcaa5b3d90840b2e3dacaeab111c2a8e70" translate="yes" xml:space="preserve">
          <source>Produce a Mach-o bundle format file. See man ld(1) for more information.</source>
          <target state="translated">生成Mach-o bundle格式文件。更多信息请参见 man ld(1)。</target>
        </trans-unit>
        <trans-unit id="9cedce134ad1d6e39e6ac28f5ea367bb4ac3cf33" translate="yes" xml:space="preserve">
          <source>Produce a core dump whenever an error occurs.</source>
          <target state="translated">每当发生错误时,就会产生一个核心转储。</target>
        </trans-unit>
        <trans-unit id="ba338fc5c81c60c18e5763d1fadce97ad1e61e6a" translate="yes" xml:space="preserve">
          <source>Produce a dynamically linked position independent executable on targets that support it. For predictable results, you must also specify the same set of options used for compilation (</source>
          <target state="translated">在支持它的目标上生成一个动态链接的独立于位置的可执行文件。为了获得可预测的结果,您还必须指定用于编译的同一组选项 (</target>
        </trans-unit>
        <trans-unit id="6cb3358c313e561510d03d4f43da46e9f117e2c5" translate="yes" xml:space="preserve">
          <source>Produce a notes file that the &lt;code&gt;gcov&lt;/code&gt; code-coverage utility (see &lt;a href=&quot;gcov#Gcov&quot;&gt;&lt;code&gt;gcov&lt;/code&gt;&amp;mdash;a Test Coverage Program&lt;/a&gt;) can use to show program coverage. Each source file&amp;rsquo;s note file is called</source>
          <target state="translated">生成一个注释文件， &lt;code&gt;gcov&lt;/code&gt; 代码覆盖率实用程序（请参阅&lt;a href=&quot;gcov#Gcov&quot;&gt; &lt;code&gt;gcov&lt;/code&gt; &amp;mdash;测试覆盖率程序&lt;/a&gt;）可用于显示程序覆盖率。每个源文件的注释文件称为</target>
        </trans-unit>
        <trans-unit id="8b280710ae96a8b8d8e74aa28a812b327df111b1" translate="yes" xml:space="preserve">
          <source>Produce a relocatable object as output. This is also known as partial linking.</source>
          <target state="translated">产生一个可重定位的对象作为输出。这也就是所谓的部分链接。</target>
        </trans-unit>
        <trans-unit id="26aa77097b9a063e69af15c39e1ef1623a1a0dab" translate="yes" xml:space="preserve">
          <source>Produce a shared object which can then be linked with other objects to form an executable. Not all systems support this option. For predictable results, you must also specify the same set of options used for compilation (</source>
          <target state="translated">生成一个共享对象,然后可以与其他对象链接,形成一个可执行文件。并非所有系统都支持这个选项。为了获得可预测的结果,您还必须指定用于编译的同一组选项(</target>
        </trans-unit>
        <trans-unit id="82a6e20338c2d2cb9f44077a8123f0423ba29a56" translate="yes" xml:space="preserve">
          <source>Produce a static position independent executable on targets that support it. A static position independent executable is similar to a static executable, but can be loaded at any address without a dynamic linker. For predictable results, you must also specify the same set of options used for compilation (</source>
          <target state="translated">在支持静态位置独立的目标上生成一个静态位置独立的可执行文件。静态位置独立的可执行文件类似于静态可执行文件,但可以在任何地址加载,而不需要动态链接器。为了获得可预测的结果,您还必须指定用于编译的同一组选项(</target>
        </trans-unit>
        <trans-unit id="229bc991f84912dbb707cad7f57cc3c00958246f" translate="yes" xml:space="preserve">
          <source>Produce all the dumps listed above.</source>
          <target state="translated">制作上述所有的转储。</target>
        </trans-unit>
        <trans-unit id="c830b4e289b1d603d4b29ad3603ac7fe06258efc" translate="yes" xml:space="preserve">
          <source>Produce code optimized for the most common IA32/AMD64/EM64T processors. If you know the CPU on which your code will run, then you should use the corresponding</source>
          <target state="translated">制作针对最常见的IA32/AMD64/EM64T处理器优化的代码。如果您知道您的代码将在哪个CPU上运行,那么您应该使用相应的</target>
        </trans-unit>
        <trans-unit id="874624fe120d74004c74672b177571000bb8d675" translate="yes" xml:space="preserve">
          <source>Produce code optimized for the most current Intel processors, which are Haswell and Silvermont for this version of GCC. If you know the CPU on which your code will run, then you should use the corresponding</source>
          <target state="translated">制作针对最新的英特尔处理器优化的代码,这个版本的GCC是Haswell和Silvermont。如果您知道您的代码将在哪个CPU上运行,那么您应该使用相应的</target>
        </trans-unit>
        <trans-unit id="59d6dfa4b2545178e43d697c719e6e2891444e31" translate="yes" xml:space="preserve">
          <source>Produce code that conforms more closely to IBM XL compiler semantics when using AIX-compatible ABI. Pass floating-point arguments to prototyped functions beyond the register save area (RSA) on the stack in addition to argument FPRs. Do not assume that most significant double in 128-bit long double value is properly rounded when comparing values and converting to double. Use XL symbol names for long double support routines.</source>
          <target state="translated">当使用AIX兼容的ABI时,产生更符合IBM XL编译器语义的代码。除了参数FPR外,还将浮点参数传递给堆栈上超出寄存器保存区(RSA)的原型函数。在比较值和转换为双数时,不要认为128位长双数值中最重要的双数是正确的四舍五入。长双支持例程使用XL符号名。</target>
        </trans-unit>
        <trans-unit id="70aa8e6a5aa6f95946582de4d3eebc24892a15cb" translate="yes" xml:space="preserve">
          <source>Produce compressed debug sections in DWARF format, if that is supported. If &lt;var&gt;type&lt;/var&gt; is not given, the default type depends on the capabilities of the assembler and linker used. &lt;var&gt;type&lt;/var&gt; may be one of &amp;lsquo;</source>
          <target state="translated">如果支持，则以DWARF格式生成压缩的调试节。如果未提供 &lt;var&gt;type&lt;/var&gt; ，则默认类型取决于所使用的汇编器和链接器的功能。 &lt;var&gt;type&lt;/var&gt; 可能是&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="d785038635c115caba3a3a72ca445989fe650fad" translate="yes" xml:space="preserve">
          <source>Produce debugging information for use by GDB. This means to use the most expressive format available (DWARF, stabs, or the native format if neither of those are supported), including GDB extensions if at all possible.</source>
          <target state="translated">产生调试信息供GDB使用。这意味着要使用可用的最有表现力的格式(DWARF,stabs,或者本地格式,如果这两种格式都不支持的话),包括GDB扩展(如果可能的话)。</target>
        </trans-unit>
        <trans-unit id="6e76e1882b03d7c105da1aec1b4b65497ef05063" translate="yes" xml:space="preserve">
          <source>Produce debugging information in Alpha/VMS debug format (if that is supported). This is the format used by DEBUG on Alpha/VMS systems.</source>
          <target state="translated">以Alpha/VMS调试格式生成调试信息(如果支持的话)。这是Alpha/VMS系统中DEBUG使用的格式。</target>
        </trans-unit>
        <trans-unit id="1c89bdfbe7ff24838a86019c90957a16af275605" translate="yes" xml:space="preserve">
          <source>Produce debugging information in DWARF format (if that is supported). The value of &lt;var&gt;version&lt;/var&gt; may be either 2, 3, 4 or 5; the default version for most targets is 4. DWARF Version 5 is only experimental.</source>
          <target state="translated">产生DWARF格式的调试信息（如果支持）。 &lt;var&gt;version&lt;/var&gt; 的值可以是2、3、4或5；大多数目标的默认版本是4。DWARF版本5仅是实验性的。</target>
        </trans-unit>
        <trans-unit id="21dc1c45a8426cfd7ea86f0ff5efd716fb463aa3" translate="yes" xml:space="preserve">
          <source>Produce debugging information in XCOFF format (if that is supported), using GNU extensions understood only by the GNU debugger (GDB). The use of these extensions is likely to make other debuggers crash or refuse to read the program, and may cause assemblers other than the GNU assembler (GAS) to fail with an error.</source>
          <target state="translated">使用只有GNU调试器(GDB)才能理解的GNU扩展,以XCOFF格式(如果支持的话)生成调试信息。使用这些扩展可能会使其他调试器崩溃或拒绝读取程序,并可能导致GNU汇编器(GAS)以外的汇编器出错。</target>
        </trans-unit>
        <trans-unit id="1c31c10a8554b29470b180047c3e117a364d7374" translate="yes" xml:space="preserve">
          <source>Produce debugging information in XCOFF format (if that is supported). This is the format used by the DBX debugger on IBM RS/6000 systems.</source>
          <target state="translated">生成XCOFF格式的调试信息(如果支持的话)。这是IBM RS/6000系统上DBX调试器使用的格式。</target>
        </trans-unit>
        <trans-unit id="a8732936178c413fac329a93443e75c2a16089d0" translate="yes" xml:space="preserve">
          <source>Produce debugging information in stabs format (if that is supported), for only symbols that are actually used.</source>
          <target state="translated">以stabs格式生成调试信息(如果支持的话),只针对实际使用的符号。</target>
        </trans-unit>
        <trans-unit id="798e83cefb7f6ea7ef9a535cd3ace3be5a753318" translate="yes" xml:space="preserve">
          <source>Produce debugging information in stabs format (if that is supported), using GNU extensions understood only by the GNU debugger (GDB). The use of these extensions is likely to make other debuggers crash or refuse to read the program.</source>
          <target state="translated">使用只有GNU调试器(GDB)才能理解的GNU扩展,以stabs格式(如果支持的话)生成调试信息。使用这些扩展可能会使其他调试器崩溃或拒绝读取程序。</target>
        </trans-unit>
        <trans-unit id="e675746f0878092c9d5ac57cb51767441496530c" translate="yes" xml:space="preserve">
          <source>Produce debugging information in stabs format (if that is supported), without GDB extensions. This is the format used by DBX on most BSD systems. On MIPS, Alpha and System V Release 4 systems this option produces stabs debugging output that is not understood by DBX. On System V Release 4 systems this option requires the GNU assembler.</source>
          <target state="translated">生成stabs格式的调试信息(如果支持的话),不需要GDB扩展。这是大多数BSD系统上DBX使用的格式。在MIPS、Alpha和System V Release 4系统上,这个选项产生的stabs调试输出不被DBX理解。在System V Release 4系统上,这个选项需要使用GNU汇编器。</target>
        </trans-unit>
        <trans-unit id="2effb462b688a145487a6f229d8da95bd056d019" translate="yes" xml:space="preserve">
          <source>Produce debugging information in the operating system&amp;rsquo;s native format (stabs, COFF, XCOFF, or DWARF). GDB can work with this debugging information.</source>
          <target state="translated">以操作系统的本机格式（stab，COFF，XCOFF或DWARF）产生调试信息。GDB可以使用此调试信息。</target>
        </trans-unit>
        <trans-unit id="1c30c7a4385f1b1870365ef3b00c760d3c2db0e3" translate="yes" xml:space="preserve">
          <source>Producing an AutoFDO profile data file requires running your program with the &lt;code&gt;perf&lt;/code&gt; utility on a supported GNU/Linux target system. For more information, see &lt;a href=&quot;https://perf.wiki.kernel.org/&quot;&gt;https://perf.wiki.kernel.org/&lt;/a&gt;.</source>
          <target state="translated">产生AutoFDO配置文件数据文件需要在支持的GNU / Linux目标系统上使用 &lt;code&gt;perf&lt;/code&gt; 实用程序运行程序。有关更多信息，请参见&lt;a href=&quot;https://perf.wiki.kernel.org/&quot;&gt;https://perf.wiki.kernel.org/&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3d16847b11987e862bb0226a6dbf93a65cab5ec8" translate="yes" xml:space="preserve">
          <source>Producing debuggable code.</source>
          <target state="translated">制作可调试的代码。</target>
        </trans-unit>
        <trans-unit id="66065140c4bd69f9a929457e5e1f5ddcadca4b33" translate="yes" xml:space="preserve">
          <source>Profiles collected using an instrumented binary for multi-threaded programs may be inconsistent due to missed counter updates. When this option is specified, GCC uses heuristics to correct or smooth out such inconsistencies. By default, GCC emits an error message when an inconsistent profile is detected.</source>
          <target state="translated">对于多线程程序,使用工具化二进制程序收集的配置文件可能会因为错过计数器更新而导致不一致。当指定此选项时,GCC使用启发式方法来纠正或消除这种不一致。默认情况下,当检测到不一致的配置文件时,GCC会发出一条错误信息。</target>
        </trans-unit>
        <trans-unit id="215364611f5d742bb3cf5b6bc5f45d76aedfc488" translate="yes" xml:space="preserve">
          <source>Profiling run-time library reports various errors related to profile manipulation and profile saving. Errors are printed into standard error output or &amp;lsquo;</source>
          <target state="translated">概要分析运行时库报告与概要文件处理和概要文件保存相关的各种错误。错误会打印到标准错误输出或'</target>
        </trans-unit>
        <trans-unit id="6d0967a146a9cd54e7f2cfdefd92dad89185e247" translate="yes" xml:space="preserve">
          <source>Profiling tools help you analyze your code&amp;rsquo;s performance. Using a profiler such as &lt;code&gt;gcov&lt;/code&gt; or &lt;code&gt;gprof&lt;/code&gt;, you can find out some basic performance statistics, such as:</source>
          <target state="translated">分析工具可帮助您分析代码的性能。使用诸如 &lt;code&gt;gcov&lt;/code&gt; 或 &lt;code&gt;gprof&lt;/code&gt; 之类的探查器，您可以找到一些基本的性能统计信息，例如：</target>
        </trans-unit>
        <trans-unit id="299845fbcd8fc09058a26974d7a1694c0d922e8b" translate="yes" xml:space="preserve">
          <source>Program Instrumentation Options</source>
          <target state="translated">程序仪表选项</target>
        </trans-unit>
        <trans-unit id="bce0913595ade4c39c8c03d2dbf27980dd7aa2d2" translate="yes" xml:space="preserve">
          <source>Program precision. This option is the default and means a trap handler can only identify which program caused a floating-point exception.</source>
          <target state="translated">程序精度。这个选项是默认的,意味着陷阱处理程序只能识别是哪个程序引起的浮点异常。</target>
        </trans-unit>
        <trans-unit id="2e30a8e13f6fe61be9a133d07d1e5fc7f1ccd080" translate="yes" xml:space="preserve">
          <source>Programmers normally use conditionals on &lt;code&gt;__STDC__&lt;/code&gt; to ask whether it is safe to use certain features of ISO C, such as function prototypes or ISO token concatenation. Since plain &lt;code&gt;gcc&lt;/code&gt; supports all the features of ISO C, the correct answer to these questions is &amp;ldquo;yes&amp;rdquo;.</source>
          <target state="translated">程序员通常在 &lt;code&gt;__STDC__&lt;/code&gt; 上使用条件语句，以询问使用ISO C的某些功能（例如函数原型或ISO令牌串联）是否安全。由于普通 &lt;code&gt;gcc&lt;/code&gt; 支持ISO C的所有功能，因此对这些问题的正确答案是&amp;ldquo;是&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="a0bd705cf04e9357c2ea73ca926ccbac6b893041" translate="yes" xml:space="preserve">
          <source>Programs that use preprocessing directives in the middle of macro arguments do not work with GCC. For example, a program like this will not work:</source>
          <target state="translated">在宏参数中间使用预处理指令的程序不能在GCC中运行。例如,这样的程序将无法工作。</target>
        </trans-unit>
        <trans-unit id="f2ac6418060115eaba540e4ea02f9d2bc08e06a3" translate="yes" xml:space="preserve">
          <source>Programs written to compile with C++-to-C translators get the value of &lt;code&gt;__STDC__&lt;/code&gt; that goes with the C compiler that is subsequently used. These programs must test &lt;code&gt;__STDC__&lt;/code&gt; to determine what kind of C preprocessor that compiler uses: whether they should concatenate tokens in the ISO C fashion or in the traditional fashion.</source>
          <target state="translated">编写使用C ++到C转换器进行编译的程序将获得 &lt;code&gt;__STDC__&lt;/code&gt; 的值，该值与随后使用的C编译器一起使用。这些程序必须测试 &lt;code&gt;__STDC__&lt;/code&gt; 以确定编译器使用哪种C预处理器：它们是否应该以ISO C方式或传统方式来连接令牌。</target>
        </trans-unit>
        <trans-unit id="5a9cb5a82aeec8a68235c0ced346ccbfb76bb12a" translate="yes" xml:space="preserve">
          <source>Propagate information about uses of a value up the definition chain in order to simplify the definitions. For example, this pass strips sign operations if the sign of a value never matters. The flag is enabled by default at</source>
          <target state="translated">为了简化定义,在定义链上传播关于一个值的使用信息。例如,如果一个值的符号从来都不重要,那么这个传递就会剥离符号操作。该标志默认在</target>
        </trans-unit>
        <trans-unit id="fa7dd81f88cb5c4139f9dbe0c73fbba733aa4a44" translate="yes" xml:space="preserve">
          <source>Protected visibility is like default visibility except that it indicates that references within the defining module bind to the definition in that module. That is, the declared entity cannot be overridden by another module.</source>
          <target state="translated">受保护的可见性和默认可见性一样,只是它表明定义模块中的引用与该模块中的定义绑定。也就是说,声明的实体不能被另一个模块覆盖。</target>
        </trans-unit>
        <trans-unit id="af2b8481cf932700a1d1fe584409316090685bcd" translate="yes" xml:space="preserve">
          <source>Prototype declarations and old-style definitions.</source>
          <target state="translated">原型声明和旧式定义。</target>
        </trans-unit>
        <trans-unit id="281df885a6152b0fc99de98c97f687a7bacdb5ad" translate="yes" xml:space="preserve">
          <source>Provide a user-defined function to handle NMI exception.</source>
          <target state="translated">提供一个用户定义的函数来处理NMI异常。</target>
        </trans-unit>
        <trans-unit id="a507043f2b5ce9798e6d052565a1ba8fcc61bd09" translate="yes" xml:space="preserve">
          <source>Provide a user-defined function to handle warm reset exception.</source>
          <target state="translated">提供一个用户自定义的功能来处理温态复位异常。</target>
        </trans-unit>
        <trans-unit id="ba0e24e32262e9027ddf344b0bbb6826b30533e8" translate="yes" xml:space="preserve">
          <source>Providing multiple strings as arguments separated by commas to specify multiple options is equivalent to separating the option suffixes with a comma (&amp;lsquo;</source>
          <target state="translated">提供多个字符串作为用逗号分隔以指定多个选项的参数，等效于用逗号分隔选项后缀（'</target>
        </trans-unit>
        <trans-unit id="c6e467f9fef2c6ec37e713ef7ce97be04a79d3ee" translate="yes" xml:space="preserve">
          <source>Pseudo type</source>
          <target state="translated">伪型</target>
        </trans-unit>
        <trans-unit id="2ec15755e92f7ec74b89a276482fe0679fe6a677" translate="yes" xml:space="preserve">
          <source>Put all data, not just small objects, into the sections reserved for small data, and use addressing relative to the &lt;code&gt;B14&lt;/code&gt; register to access them.</source>
          <target state="translated">将所有数据（不仅是小对象）放入为小数据保留的部分中，并使用相对于 &lt;code&gt;B14&lt;/code&gt; 寄存器的寻址来访问它们。</target>
        </trans-unit>
        <trans-unit id="14d82a1bb301488807b0804cf1d8b4aed130dcd1" translate="yes" xml:space="preserve">
          <source>Put definitions of externally-visible data in a small data section if that data is no bigger than &lt;var&gt;num&lt;/var&gt; bytes. GCC can then generate more efficient accesses to the data; see</source>
          <target state="translated">如果外部可见数据的定义不超过 &lt;var&gt;num&lt;/var&gt; 个字节，则将其定义放在一个小的数据段中。然后，GCC可以生成对数据的更有效访问；看到</target>
        </trans-unit>
        <trans-unit id="ee1f4e4ed1983ff05857b16e6d5463e63d52f87d" translate="yes" xml:space="preserve">
          <source>Put definitions of externally-visible data in a small data section if that data is no bigger than &lt;var&gt;num&lt;/var&gt; bytes. The default value of &lt;var&gt;num&lt;/var&gt; is 4 for any ARC configuration, or 8 when we have double load/store operations.</source>
          <target state="translated">如果外部可见数据的定义不超过 &lt;var&gt;num&lt;/var&gt; 个字节，则将其定义放在一个小的数据段中。对于任何ARC配置， &lt;var&gt;num&lt;/var&gt; 的默认值为4，当我们执行双重加载/存储操作时，默认值为8。</target>
        </trans-unit>
        <trans-unit id="dd10aa9229d46223067d4529eb087ca1d5b4bb37" translate="yes" xml:space="preserve">
          <source>Put extra commentary information in the generated assembly code to make it more readable. This option is generally only of use to those who actually need to read the generated assembly code (perhaps while debugging the compiler itself).</source>
          <target state="translated">在生成的汇编代码中放入额外的注释信息,使其更易读。这个选项通常只对那些真正需要阅读生成的汇编代码的人有用(也许在调试编译器本身时)。</target>
        </trans-unit>
        <trans-unit id="4efa75b425ee3379e46be03951b8fed10951f423" translate="yes" xml:space="preserve">
          <source>Put global and static data smaller than &lt;var&gt;n&lt;/var&gt; bytes into a special section (on some targets).</source>
          <target state="translated">将小于 &lt;var&gt;n&lt;/var&gt; 个字节的全局和静态数据放入一个特殊部分（在某些目标上）。</target>
        </trans-unit>
        <trans-unit id="803e4d47363b74310533dbbacf9cf5e406c33858" translate="yes" xml:space="preserve">
          <source>Put global and static objects less than or equal to &lt;var&gt;num&lt;/var&gt; bytes into the small data or BSS sections instead of the normal data or BSS sections. The default value of &lt;var&gt;num&lt;/var&gt; is 8.</source>
          <target state="translated">将小于或等于 &lt;var&gt;num&lt;/var&gt; 字节的全局和静态对象放入小数据或BSS节中，而不是普通数据或BSS节中。 &lt;var&gt;num&lt;/var&gt; 的默认值为8。</target>
        </trans-unit>
        <trans-unit id="325fbb1dff6b2bc48b832b2c0837a0d4aa50c625" translate="yes" xml:space="preserve">
          <source>Put global and static objects less than or equal to &lt;var&gt;num&lt;/var&gt; bytes into the small data or BSS sections instead of the normal data or BSS sections. The default value of &lt;var&gt;num&lt;/var&gt; is 8. The</source>
          <target state="translated">将小于或等于 &lt;var&gt;num&lt;/var&gt; 个字节的全局和静态对象放入小数据或BSS节中，而不是普通数据或BSS节中。 &lt;var&gt;num&lt;/var&gt; 的默认值为8。</target>
        </trans-unit>
        <trans-unit id="2845f96bd365594a3cd3c2c2ff97b86e1f179d72" translate="yes" xml:space="preserve">
          <source>Put read-only objects in the &lt;code&gt;.sdata&lt;/code&gt; section as well. This is the default.</source>
          <target state="translated">也将只读对象放在 &lt;code&gt;.sdata&lt;/code&gt; 节中。这是默认值。</target>
        </trans-unit>
        <trans-unit id="aaee271d332c564c26a565ff260fd11119341a45" translate="yes" xml:space="preserve">
          <source>Put small global and static data in the &lt;code&gt;.neardata&lt;/code&gt; section, which is pointed to by register &lt;code&gt;B14&lt;/code&gt;. Put small uninitialized global and static data in the &lt;code&gt;.bss&lt;/code&gt; section, which is adjacent to the &lt;code&gt;.neardata&lt;/code&gt; section. Put small read-only data into the &lt;code&gt;.rodata&lt;/code&gt; section. The corresponding sections used for large pieces of data are &lt;code&gt;.fardata&lt;/code&gt;, &lt;code&gt;.far&lt;/code&gt; and &lt;code&gt;.const&lt;/code&gt;.</source>
          <target state="translated">将小的全局和静态数据放入 &lt;code&gt;.neardata&lt;/code&gt; 节中，该数据由寄存器 &lt;code&gt;B14&lt;/code&gt; 指向。将小的未初始化的全局和静态数据放入 &lt;code&gt;.bss&lt;/code&gt; 节中，该节与 &lt;code&gt;.neardata&lt;/code&gt; 节相邻。将小的只读数据放入 &lt;code&gt;.rodata&lt;/code&gt; 节。用于大数据的相应部分是 &lt;code&gt;.fardata&lt;/code&gt; ， &lt;code&gt;.far&lt;/code&gt; 和 &lt;code&gt;.const&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f2399d291f04f4ceb6a5d4d94e2129947be998a8" translate="yes" xml:space="preserve">
          <source>Put small global and static data in the small data area, and generate special instructions to reference them.</source>
          <target state="translated">把小全局数据和静态数据放在小数据区,并生成特殊指令来引用。</target>
        </trans-unit>
        <trans-unit id="d62b1c870b332795e163f0098650ca88ceaf5c00" translate="yes" xml:space="preserve">
          <source>Put small global and static data in the small data area, but do not generate special code to reference them.</source>
          <target state="translated">把小全局数据和静态数据放在小数据区,但不要生成特殊代码来引用它们。</target>
        </trans-unit>
        <trans-unit id="f427abf1ae046d699cd5f6fec41113c62676ed1b" translate="yes" xml:space="preserve">
          <source>Put static or global variables whose size is &lt;var&gt;n&lt;/var&gt; bytes or less into the first 32 kilobytes of memory.</source>
          <target state="translated">将大小为 &lt;var&gt;n&lt;/var&gt; 字节或更小的静态或全局变量放入前32 KB内存中。</target>
        </trans-unit>
        <trans-unit id="c3a89106111c4929799b74f87481c16b67c9438e" translate="yes" xml:space="preserve">
          <source>Put static or global variables whose size is &lt;var&gt;n&lt;/var&gt; bytes or less into the small data area that register &lt;code&gt;gp&lt;/code&gt; points to. The small data area can hold up to 64 kilobytes.</source>
          <target state="translated">将大小为 &lt;var&gt;n&lt;/var&gt; 字节或更小的静态或全局变量放入寄存器 &lt;code&gt;gp&lt;/code&gt; 指向的小数据区域中。小数据区域最多可容纳64 KB。</target>
        </trans-unit>
        <trans-unit id="90b5e26c9c08b39bd895b34bb6ae576000e2eb1e" translate="yes" xml:space="preserve">
          <source>Put static or global variables whose size is &lt;var&gt;n&lt;/var&gt; bytes or less into the tiny data area that register &lt;code&gt;ep&lt;/code&gt; points to. The tiny data area can hold up to 256 bytes in total (128 bytes for byte references).</source>
          <target state="translated">将大小为 &lt;var&gt;n&lt;/var&gt; 字节或更小的静态或全局变量放入寄存器 &lt;code&gt;ep&lt;/code&gt; 指向的微小数据区域中。微小数据区域最多可容纳256个字节（字节引用为128个字节）。</target>
        </trans-unit>
        <trans-unit id="fb78a5b9af064b32c202bfb144d8f6d597bc15ce" translate="yes" xml:space="preserve">
          <source>Put uninitialized &lt;code&gt;const&lt;/code&gt; variables in the read-only data section. This option is only meaningful in conjunction with</source>
          <target state="translated">将未初始化的 &lt;code&gt;const&lt;/code&gt; 变量放在只读数据部分中。该选项仅在与</target>
        </trans-unit>
        <trans-unit id="15266f7e96e613e475613699a09898779a9cf785" translate="yes" xml:space="preserve">
          <source>Putting statements and declarations inside expressions.</source>
          <target state="translated">把语句和声明放在表达式里面。</target>
        </trans-unit>
        <trans-unit id="c3156e00d3c2588c639e0d3cf6821258b05761c7" translate="yes" xml:space="preserve">
          <source>Q</source>
          <target state="translated">Q</target>
        </trans-unit>
        <trans-unit id="2fb1858154779be9095d34bc86481decea9864b5" translate="yes" xml:space="preserve">
          <source>Qualifiers</source>
          <target state="translated">Qualifiers</target>
        </trans-unit>
        <trans-unit id="06576556d1ad802f247cad11ae748be47b70cd9c" translate="yes" xml:space="preserve">
          <source>R</source>
          <target state="translated">R</target>
        </trans-unit>
        <trans-unit id="51d0c108a00931316d1d9196895d716cd8591259" translate="yes" xml:space="preserve">
          <source>R10</source>
          <target state="translated">R10</target>
        </trans-unit>
        <trans-unit id="a8c8c0f94567fb54e5baecfbbe7a22ad9ffe90a8" translate="yes" xml:space="preserve">
          <source>R9</source>
          <target state="translated">R9</target>
        </trans-unit>
        <trans-unit id="4ed9df973cbf299009483fc686300ba83d456ff4" translate="yes" xml:space="preserve">
          <source>RAM larger than 64 KiB is not supported by GCC for AVR targets. If you use inline assembler to read from locations outside the 16-bit address range and change one of the &lt;code&gt;RAMP&lt;/code&gt; registers, you must reset it to zero after the access.</source>
          <target state="translated">对于AVR目标，GCC不支持大于64 KiB的RAM。如果使用内联汇编器从16位地址范围以外的位置读取并更改 &lt;code&gt;RAMP&lt;/code&gt; 寄存器之一，则必须在访问后将其重置为零。</target>
        </trans-unit>
        <trans-unit id="cdc0f19760327ced87ad8aee74afab31fe72c4fe" translate="yes" xml:space="preserve">
          <source>REG_BR_PROB</source>
          <target state="translated">REG_BR_PROB</target>
        </trans-unit>
        <trans-unit id="f440f2eda03ec65b7157428e14ccfd6f3d0babc7" translate="yes" xml:space="preserve">
          <source>RISC-V&amp;mdash;</source>
          <target state="translated">RISC-V&amp;mdash;</target>
        </trans-unit>
        <trans-unit id="647dca504e5b45f643aed4172949afe845cda414" translate="yes" xml:space="preserve">
          <source>RL78&amp;mdash;</source>
          <target state="translated">RL78&amp;mdash;</target>
        </trans-unit>
        <trans-unit id="575f4784d61d9c2b0ea79d87650e89f3ea480cc7" translate="yes" xml:space="preserve">
          <source>RTL if-conversion tries to remove conditional branches around a block and replace them with conditionally executed instructions. This parameter gives the maximum number of instructions in a block which should be considered for if-conversion. The compiler will also use other heuristics to decide whether if-conversion is likely to be profitable.</source>
          <target state="translated">RTL if-conversion 试图删除一个块周围的条件分支,并用条件执行的指令替换它们。这个参数给出了一个块中应该被考虑进行if转换的最大指令数。编译器也会使用其他的启发式方法来决定if-conversion是否可能有利可图。</target>
        </trans-unit>
        <trans-unit id="8ffe843fed02ef77ab2e92d415d12da14c23bcab" translate="yes" xml:space="preserve">
          <source>RTL if-conversion will try to remove conditional branches around a block and replace them with conditionally executed instructions. These parameters give the maximum permissible cost for the sequence that would be generated by if-conversion depending on whether the branch is statically determined to be predictable or not. The units for this parameter are the same as those for the GCC internal seq_cost metric. The compiler will try to provide a reasonable default for this parameter using the BRANCH_COST target macro.</source>
          <target state="translated">RTL if-conversion将尝试删除块周围的条件分支,并用条件执行的指令替换。这些参数给出了if-conversion生成的序列的最大允许成本,这取决于分支是否被静态确定为可预测。这个参数的单位与GCC内部的seq_cost度量的单位相同。编译器将尝试使用BRANCH_COST目标宏为这个参数提供一个合理的默认值。</target>
        </trans-unit>
        <trans-unit id="b61bd2259b081aeab3036fb11de5495fed60c76b" translate="yes" xml:space="preserve">
          <source>RTM Function: int &lt;strong id=&quot;index-_005fxtest&quot;&gt;_xtest&lt;/strong&gt; ()</source>
          <target state="translated">RTM函数：int &lt;strong id=&quot;index-_005fxtest&quot;&gt;_xtest&lt;/strong&gt;（）</target>
        </trans-unit>
        <trans-unit id="ee01945fd30707cfbb63a1376c78162c28d86d32" translate="yes" xml:space="preserve">
          <source>RTM Function: unsigned &lt;strong id=&quot;index-_005fxbegin&quot;&gt;_xbegin&lt;/strong&gt; ()</source>
          <target state="translated">RTM功能：无符号&lt;strong id=&quot;index-_005fxbegin&quot;&gt;_xbegin&lt;/strong&gt;（）</target>
        </trans-unit>
        <trans-unit id="e8ff66f739eabb13f3e3a702095e9beb4ceb7801" translate="yes" xml:space="preserve">
          <source>RTM Function: void &lt;strong id=&quot;index-_005fxabort&quot;&gt;_xabort&lt;/strong&gt; (status)</source>
          <target state="translated">RTM功能：void &lt;strong id=&quot;index-_005fxabort&quot;&gt;_xabort&lt;/strong&gt;（状态）</target>
        </trans-unit>
        <trans-unit id="9b706c796609ffc332644946cbe8681890d7242e" translate="yes" xml:space="preserve">
          <source>RTM Function: void &lt;strong id=&quot;index-_005fxend&quot;&gt;_xend&lt;/strong&gt; ()</source>
          <target state="translated">RTM功能：void &lt;strong id=&quot;index-_005fxend&quot;&gt;_xend&lt;/strong&gt;（）</target>
        </trans-unit>
        <trans-unit id="828c78a41071d9949c1d88a38a7d2dcd59e5c5f3" translate="yes" xml:space="preserve">
          <source>RX&amp;mdash;</source>
          <target state="translated">RX&amp;mdash;</target>
        </trans-unit>
        <trans-unit id="d7b79d74a6226f5fa551619ad3ed2cd4c064e1e4" translate="yes" xml:space="preserve">
          <source>RX200</source>
          <target state="translated">RX200</target>
        </trans-unit>
        <trans-unit id="6b0bdb50e97b5f7896cc50adf9568df594becf5a" translate="yes" xml:space="preserve">
          <source>RX600</source>
          <target state="translated">RX600</target>
        </trans-unit>
        <trans-unit id="e9b5640a7d2c4fd0e5ab9dc9d14a004b2b5bb4b9" translate="yes" xml:space="preserve">
          <source>RX610</source>
          <target state="translated">RX610</target>
        </trans-unit>
        <trans-unit id="75a59f2d35f8f89735f1550d0fb20ce1794b174c" translate="yes" xml:space="preserve">
          <source>Range 24 to 31, rotatert:SI 8 to 1 expressed as rotate</source>
          <target state="translated">范围24~31,rotatert:SI 8~1表示为旋转。</target>
        </trans-unit>
        <trans-unit id="03a9b8383aae047c9acd6c38cefaa42394133afe" translate="yes" xml:space="preserve">
          <source>Range 8 to 15, rotatert:HI 8 to 1 expressed as rotate</source>
          <target state="translated">范围8~15,rotatert:HI 8~1用旋转表示。</target>
        </trans-unit>
        <trans-unit id="b09e126e8976753eddde68fb3b2daae37eaf29a0" translate="yes" xml:space="preserve">
          <source>Range of signed numbers that don&amp;rsquo;t fit in 16 bits</source>
          <target state="translated">不适合16位的有符号数字范围</target>
        </trans-unit>
        <trans-unit id="3f3d7a48648a100cea8d8857ee93983cdfde6d2e" translate="yes" xml:space="preserve">
          <source>Rather than allocating fixed registers via clobbers to provide scratch registers for an &lt;code&gt;asm&lt;/code&gt; statement, an alternative is to define a variable and make it an early-clobber output as with &lt;code&gt;a2&lt;/code&gt; and &lt;code&gt;a3&lt;/code&gt; in the example below. This gives the compiler register allocator more freedom. You can also define a variable and make it an output tied to an input as with &lt;code&gt;a0&lt;/code&gt; and &lt;code&gt;a1&lt;/code&gt;, tied respectively to &lt;code&gt;ap&lt;/code&gt; and &lt;code&gt;lda&lt;/code&gt;. Of course, with tied outputs your &lt;code&gt;asm&lt;/code&gt; can&amp;rsquo;t use the input value after modifying the output register since they are one and the same register. What&amp;rsquo;s more, if you omit the early-clobber on the output, it is possible that GCC might allocate the same register to another of the inputs if GCC could prove they had the same value on entry to the &lt;code&gt;asm&lt;/code&gt;. This is why &lt;code&gt;a1&lt;/code&gt; has an early-clobber. Its tied input, &lt;code&gt;lda&lt;/code&gt; might conceivably be known to have the value 16 and without an early-clobber share the same register as &lt;code&gt;%11&lt;/code&gt;. On the other hand, &lt;code&gt;ap&lt;/code&gt; can&amp;rsquo;t be the same as any of the other inputs, so an early-clobber on &lt;code&gt;a0&lt;/code&gt; is not needed. It is also not desirable in this case. An early-clobber on &lt;code&gt;a0&lt;/code&gt; would cause GCC to allocate a separate register for the &lt;code&gt;&quot;m&quot; (*(const double (*)[]) ap)&lt;/code&gt; input. Note that tying an input to an output is the way to set up an initialized temporary register modified by an &lt;code&gt;asm&lt;/code&gt; statement. An input not tied to an output is assumed by GCC to be unchanged, for example &lt;code&gt;&quot;b&quot; (16)&lt;/code&gt; below sets up &lt;code&gt;%11&lt;/code&gt; to 16, and GCC might use that register in following code if the value 16 happened to be needed. You can even use a normal &lt;code&gt;asm&lt;/code&gt; output for a scratch if all inputs that might share the same register are consumed before the scratch is used. The VSX registers clobbered by the &lt;code&gt;asm&lt;/code&gt; statement could have used this technique except for GCC&amp;rsquo;s limit on the number of &lt;code&gt;asm&lt;/code&gt; parameters.</source>
          <target state="translated">与其通过clobbers分配固定寄存器来为 &lt;code&gt;asm&lt;/code&gt; 语句提供暂存器，还可以定义变量并将其设置为早期生成器输出，如下面的示例中的 &lt;code&gt;a2&lt;/code&gt; 和 &lt;code&gt;a3&lt;/code&gt; 所示。这赋予了编译器寄存器分配器更多的自由。您还可以定义一个变量并使它的输出绑定到输入，就像 &lt;code&gt;a0&lt;/code&gt; 和 &lt;code&gt;a1&lt;/code&gt; 一样，分别绑定到 &lt;code&gt;ap&lt;/code&gt; 和 &lt;code&gt;lda&lt;/code&gt; 。当然，通过捆绑输出，您的 &lt;code&gt;asm&lt;/code&gt; 修改输出寄存器后不能使用输入值，因为它们是一个相同的寄存器。而且，如果您在输出中省略了早期代码，那么如果GCC可以证明它们在输入 &lt;code&gt;asm&lt;/code&gt; 时具有相同的值，则GCC可能会将相同的寄存器分配给另一个输入。这就是为什么 &lt;code&gt;a1&lt;/code&gt; 具有早期优势的原因。可以想象，它的并列输入 &lt;code&gt;lda&lt;/code&gt; 的值为16，并且没有早期用户共享与 &lt;code&gt;%11&lt;/code&gt; 相同的寄存器。另一方面， &lt;code&gt;ap&lt;/code&gt; 不能与任何其他输入相同，因此不需要 &lt;code&gt;a0&lt;/code&gt; 上的早期指令。在这种情况下也是不希望的。 &lt;code&gt;a0&lt;/code&gt; 的早期用户会导致GCC为 &lt;code&gt;&quot;m&quot; (*(const double (*)[]) ap)&lt;/code&gt; 输入分配一个单独的寄存器。请注意，将输入绑定到输出是设置由 &lt;code&gt;asm&lt;/code&gt; 语句修改的初始化临时寄存器的方法。 GCC认为未绑定到输出的输入是不变的，例如，下面的 &lt;code&gt;&quot;b&quot; (16)&lt;/code&gt; 将 &lt;code&gt;%11&lt;/code&gt; 设置为16，如果碰巧需要值16，则GCC可以在以下代码中使用该寄存器。如果在使用暂存器之前已消耗了所有可能共享同一寄存器的输入，则甚至可以将普通的 &lt;code&gt;asm&lt;/code&gt; 输出用于暂存器。被 &lt;code&gt;asm&lt;/code&gt; 语句破坏的VSX寄存器可以使用此技术，但GCC的数量限制 &lt;code&gt;asm&lt;/code&gt; 参数。</target>
        </trans-unit>
        <trans-unit id="131238f337a82403a435f04af76b710a1a825a6e" translate="yes" xml:space="preserve">
          <source>Rather than using the built-ins directly, it is preferred for programs to include</source>
          <target state="translated">与其直接使用内置功能,不如在程序中加入</target>
        </trans-unit>
        <trans-unit id="3d48db591bff1043a0d8039e8ccf5e783e97e6a2" translate="yes" xml:space="preserve">
          <source>Rcq</source>
          <target state="translated">Rcq</target>
        </trans-unit>
        <trans-unit id="521f78e80ba6f8863e858ff98f48391a0330829a" translate="yes" xml:space="preserve">
          <source>Rcw</source>
          <target state="translated">Rcw</target>
        </trans-unit>
        <trans-unit id="8b8331348b2521f417469192e2b07ba6bae059df" translate="yes" xml:space="preserve">
          <source>Re-run common subexpression elimination after loop optimizations are performed.</source>
          <target state="translated">进行循环优化后,重新运行普通子表达式消除。</target>
        </trans-unit>
        <trans-unit id="47e55523da5572635c20ab856b76afcfa5225486" translate="yes" xml:space="preserve">
          <source>Read command-line options from &lt;var&gt;file&lt;/var&gt;. The options read are inserted in place of the original @&lt;var&gt;file&lt;/var&gt; option. If &lt;var&gt;file&lt;/var&gt; does not exist, or cannot be read, then the option will be treated literally, and not removed.</source>
          <target state="translated">从 &lt;var&gt;file&lt;/var&gt; 中读取命令行选项。读取的选项将插入到原始@ &lt;var&gt;file&lt;/var&gt; 选项中。如果 &lt;var&gt;file&lt;/var&gt; 不存在或无法读取，则该选项将按字面意义处理，并且不会删除。</target>
        </trans-unit>
        <trans-unit id="ee0598dcd3bf6f16e79ad5d502ed56654313a31d" translate="yes" xml:space="preserve">
          <source>Read the most or least (respectively) significant half of X and store it in &lt;var&gt;dest&lt;/var&gt;.</source>
          <target state="translated">读取X的最高或最低（分别）有效的一半，并将其存储在 &lt;var&gt;dest&lt;/var&gt; 中。</target>
        </trans-unit>
        <trans-unit id="7a126a185b0d0082578e19ef3a5daeade792a6f6" translate="yes" xml:space="preserve">
          <source>Read the specified profile directory and rewrite to a new directory.</source>
          <target state="translated">读取指定的配置文件目录并重写到新的目录。</target>
        </trans-unit>
        <trans-unit id="1324c749c5caee9deabe2d1d46a7919f7a43e96a" translate="yes" xml:space="preserve">
          <source>Read the value of Y and store it into &lt;var&gt;dest&lt;/var&gt;.</source>
          <target state="translated">读取Y的值并将其存储到 &lt;var&gt;dest&lt;/var&gt; 中。</target>
        </trans-unit>
        <trans-unit id="2e0e1585c9e916aa0dcd09633e5b74f9bffa47f5" translate="yes" xml:space="preserve">
          <source>Reading across the 64 KiB section boundary of the &lt;code&gt;__flash&lt;/code&gt; or &lt;code&gt;__flash&lt;var&gt;N&lt;/var&gt;&lt;/code&gt; address spaces shows undefined behavior. The only address space that supports reading across the 64 KiB flash segment boundaries is &lt;code&gt;__memx&lt;/code&gt;.</source>
          <target state="translated">跨 &lt;code&gt;__flash&lt;/code&gt; 或 &lt;code&gt;__flash&lt;var&gt;N&lt;/var&gt;&lt;/code&gt; 地址空间的64 KiB节边界读取将显示未定义的行为。 &lt;code&gt;__memx&lt;/code&gt; 是支持跨越64 KiB Flash段边界读取的唯一地址空间。</target>
        </trans-unit>
        <trans-unit id="cc9977fd47f39524c5c4335bb2cc07440e340402" translate="yes" xml:space="preserve">
          <source>Real C type</source>
          <target state="translated">真C型</target>
        </trans-unit>
        <trans-unit id="b01207b1c7506846e0bfacee12ec2af4714dfc01" translate="yes" xml:space="preserve">
          <source>Realign the stack at entry. On the x86, the</source>
          <target state="translated">在进入时重新调整堆栈。在x86上,</target>
        </trans-unit>
        <trans-unit id="f8d3df1ed60f0155cff1c249d5d8c961d1ce5254" translate="yes" xml:space="preserve">
          <source>Recall that a compound statement is a sequence of statements surrounded by braces; in this construct, parentheses go around the braces. For example:</source>
          <target state="translated">回顾一下,复合语句是由大括号包围的语句序列;在这个结构中,大括号围绕着大括号。例如:</target>
        </trans-unit>
        <trans-unit id="f625feb6c1f19cc48c16f0f10876aa7bd3ff669d" translate="yes" xml:space="preserve">
          <source>Recognize EUCJP characters.</source>
          <target state="translated">认识EUCJP字符。</target>
        </trans-unit>
        <trans-unit id="7c01853b77bfeb03d9b038e23e661cf8dc08fff1" translate="yes" xml:space="preserve">
          <source>Recognize JIS characters.</source>
          <target state="translated">认识JIS字符。</target>
        </trans-unit>
        <trans-unit id="794f97acfad850c064b040b0a84cf0cc856becc0" translate="yes" xml:space="preserve">
          <source>Recognize SJIS characters.</source>
          <target state="translated">认识SJIS字符。</target>
        </trans-unit>
        <trans-unit id="27cc26e0565438fda7c152cefdfd1b3f962fba55" translate="yes" xml:space="preserve">
          <source>Record the time consumed by infrastructure parts separately for each pass.</source>
          <target state="translated">分别记录基建部分每次通行所消耗的时间。</target>
        </trans-unit>
        <trans-unit id="fe2bbb8aea21cc382d288c61a66ab949bdc88ab3" translate="yes" xml:space="preserve">
          <source>Recursive cloning only when the probability of call being executed exceeds the parameter.</source>
          <target state="translated">只有当调用被执行的概率超过参数时,才会递归克隆。</target>
        </trans-unit>
        <trans-unit id="ecb4684dd74316d7840b5ce3326149ec45004d04" translate="yes" xml:space="preserve">
          <source>Recursive inlining is profitable only for function having deep recursion in average and can hurt for function having little recursion depth by increasing the prologue size or complexity of function body to other optimizers.</source>
          <target state="translated">递归内联只对平均递归程度较深的函数有利,对于递归程度不深的函数,由于增加了函数体的序幕大小或复杂度,会对其他优化器造成伤害。</target>
        </trans-unit>
        <trans-unit id="6d1dad90db7b45d2f00d2160233fcf301ebfc624" translate="yes" xml:space="preserve">
          <source>Reduce compilation time and make debugging produce the expected results. This is the default.</source>
          <target state="translated">减少编译时间,使调试产生预期的结果。这是默认的。</target>
        </trans-unit>
        <trans-unit id="6aec65068eeb8842d5e5c7061649e6408aeb8661" translate="yes" xml:space="preserve">
          <source>Reduce stack alignment on call sites if possible. Enabled by default.</source>
          <target state="translated">尽可能减少调用站点的堆栈对齐。默认情况下已启用。</target>
        </trans-unit>
        <trans-unit id="7ae7930fe556a2ec3059d5f1104e863261afd8f6" translate="yes" xml:space="preserve">
          <source>Reduce target register priority for r0..r3 / r12..r15.</source>
          <target state="translated">降低目标寄存器r0...r3/r12...r15的优先级。</target>
        </trans-unit>
        <trans-unit id="1cb5fa5caf504f40df07a2cdb9428651f086d6df" translate="yes" xml:space="preserve">
          <source>Reduced-precision reciprocal (sequence step 1) (&lt;code&gt;recip1.&lt;var&gt;fmt&lt;/var&gt;&lt;/code&gt;).</source>
          <target state="translated">降低精度倒数（序列步骤1）（ &lt;code&gt;recip1.&lt;var&gt;fmt&lt;/var&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="6b50a97d7c07e8e5ac702942c6a7c44137ba2c8f" translate="yes" xml:space="preserve">
          <source>Reduced-precision reciprocal (sequence step 2) (&lt;code&gt;recip2.&lt;var&gt;fmt&lt;/var&gt;&lt;/code&gt;).</source>
          <target state="translated">降低精度倒数（序列步骤2）（ &lt;code&gt;recip2.&lt;var&gt;fmt&lt;/var&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="311a85e245f0ddc53f02f904b2b964a9654bf632" translate="yes" xml:space="preserve">
          <source>Reduced-precision reciprocal square root (sequence step 1) (&lt;code&gt;rsqrt1.&lt;var&gt;fmt&lt;/var&gt;&lt;/code&gt;).</source>
          <target state="translated">降低精度倒数平方根（序列步骤1）（ &lt;code&gt;rsqrt1.&lt;var&gt;fmt&lt;/var&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="c3ac4a799c5d637561c73e206b8150513e28619c" translate="yes" xml:space="preserve">
          <source>Reduced-precision reciprocal square root (sequence step 2) (&lt;code&gt;rsqrt2.&lt;var&gt;fmt&lt;/var&gt;&lt;/code&gt;).</source>
          <target state="translated">降低精度倒数平方根（序列步骤2）（ &lt;code&gt;rsqrt2.&lt;var&gt;fmt&lt;/var&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="12e0462f32071ff4845c302840bb4153c2588c2c" translate="yes" xml:space="preserve">
          <source>Reduction add (&lt;code&gt;addr.ps&lt;/code&gt;).</source>
          <target state="translated">减少加法（ &lt;code&gt;addr.ps&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="e0d244d016314e418eaa174fb12395086f569f16" translate="yes" xml:space="preserve">
          <source>Reduction multiply (&lt;code&gt;mulr.ps&lt;/code&gt;).</source>
          <target state="translated">减少乘以（ &lt;code&gt;mulr.ps&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="0bb3aef854538033314f9b9054c89b202a7a46e1" translate="yes" xml:space="preserve">
          <source>Reentrant functions disable interrupts upon entry and enable them upon exit. Reentrant functions cannot also have the &lt;code&gt;naked&lt;/code&gt; or &lt;code&gt;critical&lt;/code&gt; attributes. They can have the &lt;code&gt;interrupt&lt;/code&gt; attribute.</source>
          <target state="translated">可重入函数在进入时禁用中断，并在退出时启用中断。可重入函数也不能具有 &lt;code&gt;naked&lt;/code&gt; 属性或 &lt;code&gt;critical&lt;/code&gt; 属性。它们可以具有 &lt;code&gt;interrupt&lt;/code&gt; 属性。</target>
        </trans-unit>
        <trans-unit id="572b0899e79b2675d4a7828ac0598f6989f2d4b9" translate="yes" xml:space="preserve">
          <source>References to input, output, and goto operands in the assembler template of extended &lt;code&gt;asm&lt;/code&gt; statements can use modifiers to affect the way the operands are formatted in the code output to the assembler. For example, the following code uses the &amp;lsquo;</source>
          <target state="translated">扩展 &lt;code&gt;asm&lt;/code&gt; 语句的汇编器模板中对输入，输出和goto操作数的引用可以使用修饰符来影响输出到汇编器的代码中操作数格式化的方式。例如，以下代码使用&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="37a430ef72ccbdfa3fd42aeebadb3c338dd54892" translate="yes" xml:space="preserve">
          <source>Reflects the &lt;code&gt;--with-double-comparison={tristate|bool|libf7}&lt;/code&gt;&lt;a href=&quot;https://gcc.gnu.org/install/configure.html#avr&quot;&gt;configure option&lt;/a&gt; and is defined to &lt;code&gt;2&lt;/code&gt; or &lt;code&gt;3&lt;/code&gt;.</source>
          <target state="translated">反映 &lt;code&gt;--with-double-comparison={tristate|bool|libf7}&lt;/code&gt; &lt;a href=&quot;https://gcc.gnu.org/install/configure.html#avr&quot;&gt;配置选项&lt;/a&gt;，并定义为 &lt;code&gt;2&lt;/code&gt; 或 &lt;code&gt;3&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4818801906599006df93661a53c0144ebcb2cff5" translate="yes" xml:space="preserve">
          <source>Reflects the &lt;code&gt;--with-libf7={libgcc|math|math-symbols}&lt;/code&gt;&lt;a href=&quot;https://gcc.gnu.org/install/configure.html#avr&quot;&gt;configure option&lt;/a&gt;.</source>
          <target state="translated">反映 &lt;code&gt;--with-libf7={libgcc|math|math-symbols}&lt;/code&gt; &lt;a href=&quot;https://gcc.gnu.org/install/configure.html#avr&quot;&gt;配置选项&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b1fccad55d1cd1e1deefbf2127cfdfd61810f2dd" translate="yes" xml:space="preserve">
          <source>Refrain from adding &lt;code&gt;.ident&lt;/code&gt; directives to the output file (this is the default).</source>
          <target state="translated">不要在输出文件中添加 &lt;code&gt;.ident&lt;/code&gt; 指令（这是默认设置）。</target>
        </trans-unit>
        <trans-unit id="3001d626a710b17789a0092c43744394347ea069" translate="yes" xml:space="preserve">
          <source>Register &lt;code&gt;$3&lt;/code&gt;. Do not use this constraint in new code; it is retained only for compatibility with glibc.</source>
          <target state="translated">注册 &lt;code&gt;$3&lt;/code&gt; 。不要在新代码中使用此约束；保留它仅是为了与glibc兼容。</target>
        </trans-unit>
        <trans-unit id="3567485f11d416ff7283001d94e2df1c5725db16" translate="yes" xml:space="preserve">
          <source>Register &lt;code&gt;r1&lt;/code&gt;</source>
          <target state="translated">寄存器 &lt;code&gt;r1&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9eb9c84600134957bc0bafd88d9264e6fe1a9153" translate="yes" xml:space="preserve">
          <source>Register &lt;code&gt;r2&lt;/code&gt;</source>
          <target state="translated">寄存器 &lt;code&gt;r2&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="09b82e9bbfda6d5a540f8220132caa45617cfba9" translate="yes" xml:space="preserve">
          <source>Register &lt;code&gt;r3&lt;/code&gt;</source>
          <target state="translated">寄存器 &lt;code&gt;r3&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f6bc4e57659e02dd40d1f5e77c49bbd03b18fc44" translate="yes" xml:space="preserve">
          <source>Register B14 (aka DP).</source>
          <target state="translated">登记册B14(又名DP);</target>
        </trans-unit>
        <trans-unit id="533a97d446a8a5b93bc162a4324dc4171fb8ddfe" translate="yes" xml:space="preserve">
          <source>Register R12.</source>
          <target state="translated">登记R12。</target>
        </trans-unit>
        <trans-unit id="f1c1d776b68a0b27c9825edf576eb52eaa0cc6ec" translate="yes" xml:space="preserve">
          <source>Register R13.</source>
          <target state="translated">登记R13。</target>
        </trans-unit>
        <trans-unit id="1052cf107720625d376ff935f6870b8efc3827a7" translate="yes" xml:space="preserve">
          <source>Register destructors for objects with static storage duration with the &lt;code&gt;__cxa_atexit&lt;/code&gt; function rather than the &lt;code&gt;atexit&lt;/code&gt; function. This option is required for fully standards-compliant handling of static destructors, but only works if your C library supports &lt;code&gt;__cxa_atexit&lt;/code&gt;.</source>
          <target state="translated">使用 &lt;code&gt;__cxa_atexit&lt;/code&gt; 函数而不是 &lt;code&gt;atexit&lt;/code&gt; 函数为具有静态存储持续时间的对象注册析构函数。对于完全符合标准的静态析构函数的处理，此选项是必需的，但是仅在您的C库支持 &lt;code&gt;__cxa_atexit&lt;/code&gt; 时才有效。</target>
        </trans-unit>
        <trans-unit id="7c42270e4a24dd0bfbae7acb6e659ccc0acf3f22" translate="yes" xml:space="preserve">
          <source>Register file A (A0&amp;ndash;A31).</source>
          <target state="translated">寄存器文件A（A0&amp;ndash;A31）。</target>
        </trans-unit>
        <trans-unit id="bdb218bd85a72cf91961a4baf75015f2c537debf" translate="yes" xml:space="preserve">
          <source>Register file A, excluding predicate registers (A3&amp;ndash;A31, plus A0 if not C64X or higher).</source>
          <target state="translated">寄存器文件A，不包括谓词寄存器（A3-A31，如果不是C64X或更高版本，则加A0）。</target>
        </trans-unit>
        <trans-unit id="1742f2e75d608f80fedddd8e77336383043c25ae" translate="yes" xml:space="preserve">
          <source>Register file B (B0&amp;ndash;B31).</source>
          <target state="translated">注册文件B（B0&amp;ndash;B31）。</target>
        </trans-unit>
        <trans-unit id="1444488f53becce76ff486bdb18d0cd8356cea74" translate="yes" xml:space="preserve">
          <source>Register file B, excluding predicate registers (B3&amp;ndash;B31).</source>
          <target state="translated">寄存器文件B，不包括谓词寄存器（B3-B31）。</target>
        </trans-unit>
        <trans-unit id="a59bf4be334c96a8db1601f16454148488cc2943" translate="yes" xml:space="preserve">
          <source>Register from r0 to r11 (all 16-bit registers)</source>
          <target state="translated">寄存器从r0到r11(所有16位寄存器)。</target>
        </trans-unit>
        <trans-unit id="480c1a3005b1f1617a3032a48dc7e43063c42c0c" translate="yes" xml:space="preserve">
          <source>Register from r12 to r15 (all 32-bit registers)</source>
          <target state="translated">寄存器从r12到r15(所有32位寄存器)。</target>
        </trans-unit>
        <trans-unit id="2b3c2b112d10d3044f325ab4493e523def957e04" translate="yes" xml:space="preserve">
          <source>Register in the class &lt;code&gt;ACCG_REGS&lt;/code&gt; (&lt;code&gt;accg0&lt;/code&gt; to &lt;code&gt;accg7&lt;/code&gt;).</source>
          <target state="translated">在类 &lt;code&gt;ACCG_REGS&lt;/code&gt; 中注册（从 &lt;code&gt;accg0&lt;/code&gt; 到 &lt;code&gt;accg7&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="7da0fdc2c3630cb8c657242c1c4ac92c07fc0b4b" translate="yes" xml:space="preserve">
          <source>Register in the class &lt;code&gt;ACC_REGS&lt;/code&gt; (&lt;code&gt;acc0&lt;/code&gt; to &lt;code&gt;acc7&lt;/code&gt;).</source>
          <target state="translated">在类 &lt;code&gt;ACC_REGS&lt;/code&gt; 中注册（从 &lt;code&gt;acc0&lt;/code&gt; 到 &lt;code&gt;acc7&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="8d01bcabe56f9176a78fd1c7f42ce5bc52571e38" translate="yes" xml:space="preserve">
          <source>Register in the class &lt;code&gt;CC_REGS&lt;/code&gt; (&lt;code&gt;fcc0&lt;/code&gt; to &lt;code&gt;fcc3&lt;/code&gt; and &lt;code&gt;icc0&lt;/code&gt; to &lt;code&gt;icc3&lt;/code&gt;).</source>
          <target state="translated">在类 &lt;code&gt;CC_REGS&lt;/code&gt; 中注册（ &lt;code&gt;fcc0&lt;/code&gt; 至 &lt;code&gt;fcc3&lt;/code&gt; 和 &lt;code&gt;icc0&lt;/code&gt; 至 &lt;code&gt;icc3&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="60401b0367db40fb60a9cde0e01a905072f4adce" translate="yes" xml:space="preserve">
          <source>Register in the class &lt;code&gt;CR_REGS&lt;/code&gt; (&lt;code&gt;cc0&lt;/code&gt; to &lt;code&gt;cc7&lt;/code&gt;).</source>
          <target state="translated">在类 &lt;code&gt;CR_REGS&lt;/code&gt; 中注册（ &lt;code&gt;cc0&lt;/code&gt; 到 &lt;code&gt;cc7&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="59a99c246bcf173869c670543e28aefb7eaef202" translate="yes" xml:space="preserve">
          <source>Register in the class &lt;code&gt;EVEN_ACC_REGS&lt;/code&gt; (&lt;code&gt;acc0&lt;/code&gt; to &lt;code&gt;acc7&lt;/code&gt;).</source>
          <target state="translated">在类 &lt;code&gt;EVEN_ACC_REGS&lt;/code&gt; 中注册（从 &lt;code&gt;acc0&lt;/code&gt; 到 &lt;code&gt;acc7&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="dd4f2434b1ee5dd0a73e566a4353d3b841b3be02" translate="yes" xml:space="preserve">
          <source>Register in the class &lt;code&gt;EVEN_REGS&lt;/code&gt; (&lt;code&gt;gr0&lt;/code&gt; to &lt;code&gt;gr63&lt;/code&gt;). Odd registers are excluded not in the class but through the use of a machine mode larger than 4 bytes.</source>
          <target state="translated">在 &lt;code&gt;EVEN_REGS&lt;/code&gt; 类中注册（ &lt;code&gt;gr0&lt;/code&gt; 至 &lt;code&gt;gr63&lt;/code&gt; ）。奇数寄存器不排除在类中，而是通过使用大于4字节的机器模式来排除。</target>
        </trans-unit>
        <trans-unit id="7684a3097ebf46a01e56e039fccba7728030eae8" translate="yes" xml:space="preserve">
          <source>Register in the class &lt;code&gt;FCC_REGS&lt;/code&gt; (&lt;code&gt;fcc0&lt;/code&gt; to &lt;code&gt;fcc3&lt;/code&gt;).</source>
          <target state="translated">在类 &lt;code&gt;FCC_REGS&lt;/code&gt; 中注册（ &lt;code&gt;fcc0&lt;/code&gt; 到 &lt;code&gt;fcc3&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="5924427c40695e1f7e3fa17f28b85c901bb780f0" translate="yes" xml:space="preserve">
          <source>Register in the class &lt;code&gt;FCR_REGS&lt;/code&gt; (&lt;code&gt;cc0&lt;/code&gt; to &lt;code&gt;cc3&lt;/code&gt;).</source>
          <target state="translated">注册在类 &lt;code&gt;FCR_REGS&lt;/code&gt; （ &lt;code&gt;cc0&lt;/code&gt; 至 &lt;code&gt;cc3&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="65d5a8ed496d976776f700862d585c95cb234cc1" translate="yes" xml:space="preserve">
          <source>Register in the class &lt;code&gt;FEVEN_REGS&lt;/code&gt; (&lt;code&gt;fr0&lt;/code&gt; to &lt;code&gt;fr63&lt;/code&gt;). Odd registers are excluded not in the class but through the use of a machine mode larger than 4 bytes.</source>
          <target state="translated">在类 &lt;code&gt;FEVEN_REGS&lt;/code&gt; 中注册（ &lt;code&gt;fr0&lt;/code&gt; 至 &lt;code&gt;fr63&lt;/code&gt; ）。奇数寄存器不排除在类中，而是通过使用大于4字节的机器模式来排除。</target>
        </trans-unit>
        <trans-unit id="253b27d108e605b64087cadbee528e59c1f7a79f" translate="yes" xml:space="preserve">
          <source>Register in the class &lt;code&gt;FPR_REGS&lt;/code&gt; (&lt;code&gt;fr0&lt;/code&gt; to &lt;code&gt;fr63&lt;/code&gt;).</source>
          <target state="translated">在 &lt;code&gt;FPR_REGS&lt;/code&gt; 类中注册（ &lt;code&gt;fr0&lt;/code&gt; 至 &lt;code&gt;fr63&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="1a9a5917a9352a9b774047a78e988238f033f90b" translate="yes" xml:space="preserve">
          <source>Register in the class &lt;code&gt;GPR_REGS&lt;/code&gt; (&lt;code&gt;gr0&lt;/code&gt; to &lt;code&gt;gr63&lt;/code&gt;).</source>
          <target state="translated">在类 &lt;code&gt;GPR_REGS&lt;/code&gt; 中注册（ &lt;code&gt;gr0&lt;/code&gt; 至 &lt;code&gt;gr63&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="de6724c19d1c6001733a2c683050c56b6b1affbc" translate="yes" xml:space="preserve">
          <source>Register in the class &lt;code&gt;ICC_REGS&lt;/code&gt; (&lt;code&gt;icc0&lt;/code&gt; to &lt;code&gt;icc3&lt;/code&gt;).</source>
          <target state="translated">在类 &lt;code&gt;ICC_REGS&lt;/code&gt; 中注册（ &lt;code&gt;icc0&lt;/code&gt; 至 &lt;code&gt;icc3&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="0ca423076130e7e6489d4f896160ff5e22f77c62" translate="yes" xml:space="preserve">
          <source>Register in the class &lt;code&gt;ICR_REGS&lt;/code&gt; (&lt;code&gt;cc4&lt;/code&gt; to &lt;code&gt;cc7&lt;/code&gt;).</source>
          <target state="translated">在类 &lt;code&gt;ICR_REGS&lt;/code&gt; 中注册（从 &lt;code&gt;cc4&lt;/code&gt; 到 &lt;code&gt;cc7&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="148c41bd7ab7376f2591378add35d9d26efd9177" translate="yes" xml:space="preserve">
          <source>Register in the class &lt;code&gt;LR_REG&lt;/code&gt; (the &lt;code&gt;lr&lt;/code&gt; register).</source>
          <target state="translated">在 &lt;code&gt;LR_REG&lt;/code&gt; 类中注册（ &lt;code&gt;lr&lt;/code&gt; 寄存器）。</target>
        </trans-unit>
        <trans-unit id="a34d537ea831c75f947b48a3453e17d88afefaf4" translate="yes" xml:space="preserve">
          <source>Register in the class &lt;code&gt;QUAD_ACC_REGS&lt;/code&gt; (&lt;code&gt;acc0&lt;/code&gt; to &lt;code&gt;acc7&lt;/code&gt;).</source>
          <target state="translated">在类 &lt;code&gt;QUAD_ACC_REGS&lt;/code&gt; 中注册（从 &lt;code&gt;acc0&lt;/code&gt; 到 &lt;code&gt;acc7&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="510647219824fa78b9f755cf92ce845481e8c212" translate="yes" xml:space="preserve">
          <source>Register in the class &lt;code&gt;QUAD_FPR_REGS&lt;/code&gt; (&lt;code&gt;fr0&lt;/code&gt; to &lt;code&gt;fr63&lt;/code&gt;). Register numbers not divisible by 4 are excluded not in the class but through the use of a machine mode larger than 8 bytes.</source>
          <target state="translated">在类 &lt;code&gt;QUAD_FPR_REGS&lt;/code&gt; 中注册（ &lt;code&gt;fr0&lt;/code&gt; 至 &lt;code&gt;fr63&lt;/code&gt; ）。不能被4整除的寄存器号不在类中，而是通过使用大于8字节的机器模式来排除。</target>
        </trans-unit>
        <trans-unit id="b2a1adf092bc540d607f8adfe316ebd0e23d6e5f" translate="yes" xml:space="preserve">
          <source>Register in the class &lt;code&gt;QUAD_REGS&lt;/code&gt; (&lt;code&gt;gr2&lt;/code&gt; to &lt;code&gt;gr63&lt;/code&gt;). Register numbers not divisible by 4 are excluded not in the class but through the use of a machine mode larger than 8 bytes.</source>
          <target state="translated">在类 &lt;code&gt;QUAD_REGS&lt;/code&gt; 中注册（ &lt;code&gt;gr2&lt;/code&gt; 至 &lt;code&gt;gr63&lt;/code&gt; ）。不能被4整除的寄存器号不在类中，而是通过使用大于8字节的机器模式来排除。</target>
        </trans-unit>
        <trans-unit id="a9cbfc355864e59c43680683d72198de7278ba3e" translate="yes" xml:space="preserve">
          <source>Register in the class &lt;code&gt;SPR_REGS&lt;/code&gt; (&lt;code&gt;lcr&lt;/code&gt; and &lt;code&gt;lr&lt;/code&gt;).</source>
          <target state="translated">在类 &lt;code&gt;SPR_REGS&lt;/code&gt; 中注册（ &lt;code&gt;lcr&lt;/code&gt; 和 &lt;code&gt;lr&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="769f1e93ba84a3021586676ebf74ba9a35bdb862" translate="yes" xml:space="preserve">
          <source>Register offset addressing</source>
          <target state="translated">寄存器偏移寻址</target>
        </trans-unit>
        <trans-unit id="c5f75dbc07c39bcb48abaeacbb855b7e10bf33e2" translate="yes" xml:space="preserve">
          <source>Register pair X (r27:r26)</source>
          <target state="translated">寄存器对X(r27:r26)</target>
        </trans-unit>
        <trans-unit id="3b43e753bc9f5bc9b63c0e261a0e69e87d9b370f" translate="yes" xml:space="preserve">
          <source>Register pair Y (r29:r28)</source>
          <target state="translated">寄存器对 Y (r29:r28)</target>
        </trans-unit>
        <trans-unit id="8e0fa3a292eb7a9cffe0fac8e87c12161eb6cf21" translate="yes" xml:space="preserve">
          <source>Register pair Z (r31:r30)</source>
          <target state="translated">寄存器对Z (r31:r30)</target>
        </trans-unit>
        <trans-unit id="025dbba0464975dfda3cfdcc9c21e3f5a63bca74" translate="yes" xml:space="preserve">
          <source>Register r0.</source>
          <target state="translated">寄存器r0。</target>
        </trans-unit>
        <trans-unit id="2559f54d5a47f8d70d102e65a5685a865132ce80" translate="yes" xml:space="preserve">
          <source>Register r1.</source>
          <target state="translated">注册r1。</target>
        </trans-unit>
        <trans-unit id="c9b7b7b870bca848747bbe900b4af27c68299883" translate="yes" xml:space="preserve">
          <source>Register r2.</source>
          <target state="translated">注册r2。</target>
        </trans-unit>
        <trans-unit id="c7b019e71df945fd75260cb8b739e27afabcb89d" translate="yes" xml:space="preserve">
          <source>Register r8.</source>
          <target state="translated">注册r8。</target>
        </trans-unit>
        <trans-unit id="cfa7fdd3bd0b34e806122b121b229661568a7a14" translate="yes" xml:space="preserve">
          <source>Registers are a scarce resource on most systems and allowing the compiler to manage their usage usually results in the best code. However, under special circumstances it can make sense to reserve some globally. For example this may be useful in programs such as programming language interpreters that have a couple of global variables that are accessed very often.</source>
          <target state="translated">寄存器在大多数系统中是一种稀缺资源,让编译器管理它们的使用通常会得到最好的代码。然而,在特殊情况下,全局保留一些寄存器是有意义的。例如,这在编程语言解释器等程序中可能很有用,因为这些程序有几个全局变量,经常被访问。</target>
        </trans-unit>
        <trans-unit id="9258e74b890dc26f006130edaeedc1c986bbea52" translate="yes" xml:space="preserve">
          <source>Registers chat can hold 16 bit values, including all control registers.</source>
          <target state="translated">寄存器聊天可以容纳16位值,包括所有控制寄存器。</target>
        </trans-unit>
        <trans-unit id="756cb0ca2dcd3e9a9e7bd75807e28976eb525101" translate="yes" xml:space="preserve">
          <source>Registers from r0 to r14 (registers without stack pointer)</source>
          <target state="translated">从r0到r14的寄存器(没有堆栈指针的寄存器)。</target>
        </trans-unit>
        <trans-unit id="02e3921f37f882ea8d9c75adce25fafdbe8692d7" translate="yes" xml:space="preserve">
          <source>Registers from r0 to r15</source>
          <target state="translated">寄存器从r0到r15</target>
        </trans-unit>
        <trans-unit id="f9f658d92ebc98d15c63ce46e1732d5659102ede" translate="yes" xml:space="preserve">
          <source>Registers from r16 to r23</source>
          <target state="translated">r16至r23的寄存器</target>
        </trans-unit>
        <trans-unit id="079d6f1b242baa1c7f0618d4f05a489251d1825b" translate="yes" xml:space="preserve">
          <source>Registers from r16 to r31</source>
          <target state="translated">r16至r31的寄存器</target>
        </trans-unit>
        <trans-unit id="489ac96c6b638b89a7b8ba2debb3353857a6eef8" translate="yes" xml:space="preserve">
          <source>Registers from r24 to r31. These registers can be used in &amp;lsquo;</source>
          <target state="translated">从r24到r31注册。这些寄存器可用于&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="eeebb5d987a8e9e62e6d397774e01593c964d34f" translate="yes" xml:space="preserve">
          <source>Registers r0 and r1.</source>
          <target state="translated">寄存器r0和r1。</target>
        </trans-unit>
        <trans-unit id="8300b61d2af50cc4dabd9f53915430a576a4f4a2" translate="yes" xml:space="preserve">
          <source>Registers r0 through r7.</source>
          <target state="translated">寄存器r0至r7。</target>
        </trans-unit>
        <trans-unit id="1bdabc9e342c28d99561b12e0784162f57cd5ff1" translate="yes" xml:space="preserve">
          <source>Registers r8 and r9.</source>
          <target state="translated">寄存器r8和r9。</target>
        </trans-unit>
        <trans-unit id="46b53a197a4a621fbf89bc41aa1be3ce75327950" translate="yes" xml:space="preserve">
          <source>Registers that can be used with displacements ($a0, $a1, $sb).</source>
          <target state="translated">可以使用位移的寄存器($a0,$a1,$sb)。</target>
        </trans-unit>
        <trans-unit id="d44cddb1d6b35d0af8eee84e19b037c303c54a0d" translate="yes" xml:space="preserve">
          <source>Registers that can hold 16 bit values.</source>
          <target state="translated">可容纳16位值的寄存器。</target>
        </trans-unit>
        <trans-unit id="10c61cbba1cb11bc1f9e9cef337e27161929a237" translate="yes" xml:space="preserve">
          <source>Registers that can hold 32 bit values.</source>
          <target state="translated">可容纳32位值的寄存器。</target>
        </trans-unit>
        <trans-unit id="55f1a6e3e272896d0899d9ea18b33ee00c7e2940" translate="yes" xml:space="preserve">
          <source>Registers that can hold QI values.</source>
          <target state="translated">可容纳QI值的寄存器。</target>
        </trans-unit>
        <trans-unit id="cf58d717e47b85a4f429025faf79666cce971c58" translate="yes" xml:space="preserve">
          <source>Registers that can hold pointers (16 bit registers for r8c, m16c; 24 bit registers for m32cm, m32c).</source>
          <target state="translated">可容纳指针的寄存器(16位寄存器为r8c、m16c;24位寄存器为m32cm、m32c)。</target>
        </trans-unit>
        <trans-unit id="caf84b9bb95c9665246bc340b9cdec9d8e62178c" translate="yes" xml:space="preserve">
          <source>Registers usable as base-regs of memory addresses in ARCompact 16-bit memory instructions: &lt;code&gt;r0&lt;/code&gt;-&lt;code&gt;r3&lt;/code&gt;, &lt;code&gt;r12&lt;/code&gt;-&lt;code&gt;r15&lt;/code&gt;, &lt;code&gt;sp&lt;/code&gt;. This constraint can only match when the</source>
          <target state="translated">可用作ARCompact 16位存储器指令中的存储器地址的基址寄存器 &lt;code&gt;r0&lt;/code&gt; - &lt;code&gt;r3&lt;/code&gt; ， &lt;code&gt;r12&lt;/code&gt; - &lt;code&gt;r15&lt;/code&gt; 和 &lt;code&gt;sp&lt;/code&gt; 。仅当</target>
        </trans-unit>
        <trans-unit id="a35caf683ee22a98f2498aca90a5baa9b5082d4e" translate="yes" xml:space="preserve">
          <source>Registers usable in ARCompact 16-bit instructions: &lt;code&gt;r0&lt;/code&gt;-&lt;code&gt;r3&lt;/code&gt;, &lt;code&gt;r12&lt;/code&gt;-&lt;code&gt;r15&lt;/code&gt;. This constraint can only match when the</source>
          <target state="translated">可在ARCompact 16位指令中使用的寄存器： &lt;code&gt;r0&lt;/code&gt; - &lt;code&gt;r3&lt;/code&gt; ， &lt;code&gt;r12&lt;/code&gt; - &lt;code&gt;r15&lt;/code&gt; 。仅当</target>
        </trans-unit>
        <trans-unit id="19e1e0518e942309076618fad593fdad104075c6" translate="yes" xml:space="preserve">
          <source>Registers used for circular buffering, i.e. I, B, or L registers.</source>
          <target state="translated">用于循环缓冲的寄存器,即I、B或L寄存器。</target>
        </trans-unit>
        <trans-unit id="77ea1d61c29764c1f5fd6dc887e5e48e1ad31364" translate="yes" xml:space="preserve">
          <source>Regrettable things we cannot change, but not quite bugs.</source>
          <target state="translated">遗憾的事情我们无法改变,但不完全是bug。</target>
        </trans-unit>
        <trans-unit id="32092d009780b34590134ea6fce964ac071704f4" translate="yes" xml:space="preserve">
          <source>Relaxation is a GNU feature and for safety reasons is disabled when using</source>
          <target state="translated">Relaxation是GNU的一个功能,出于安全考虑,在使用该功能时,会被禁用。</target>
        </trans-unit>
        <trans-unit id="d425b70c81109fac404a0fdbe25847f8affed9e1" translate="yes" xml:space="preserve">
          <source>Relaxed Memory Order</source>
          <target state="translated">放松记忆顺序</target>
        </trans-unit>
        <trans-unit id="dcf0a37891b53a0ada46be28abcde8419a66138e" translate="yes" xml:space="preserve">
          <source>Relaxing must be turned on if linker stubs are needed, see the section on &lt;code&gt;EIND&lt;/code&gt; and linker stubs below.</source>
          <target state="translated">如果需要链接器存根，则必须打开放松功能，请参阅下面有关 &lt;code&gt;EIND&lt;/code&gt; 和链接器存根的部分。</target>
        </trans-unit>
        <trans-unit id="d7020f448aaf8aacc8b4d63537e375e865fff9d8" translate="yes" xml:space="preserve">
          <source>Remarks</source>
          <target state="translated">Remarks</target>
        </trans-unit>
        <trans-unit id="bd65f12268c9cd14645e3d325d57c4b3512607f7" translate="yes" xml:space="preserve">
          <source>Remove all occurrences of &lt;code&gt;-S&lt;/code&gt; from the command line. Note&amp;mdash;this command is position dependent. &amp;lsquo;</source>
          <target state="translated">从命令行中删除所有出现的 &lt;code&gt;-S&lt;/code&gt; 。注意-此命令与位置有关。'</target>
        </trans-unit>
        <trans-unit id="5b528b4646554331e8a3d8f764cb6e6d2423c0b0" translate="yes" xml:space="preserve">
          <source>Remove all symbol table and relocation information from the executable.</source>
          <target state="translated">从可执行文件中删除所有符号表和重定位信息。</target>
        </trans-unit>
        <trans-unit id="9042eb2108ad4333137f668f9d20f239e0364cbc" translate="yes" xml:space="preserve">
          <source>Rename the spec string &lt;var&gt;old_name&lt;/var&gt; to &lt;var&gt;new_name&lt;/var&gt;.</source>
          <target state="translated">将规范字符串 &lt;var&gt;old_name&lt;/var&gt; 重命名为 &lt;var&gt;new_name&lt;/var&gt; 。</target>
        </trans-unit>
        <trans-unit id="a57f3dbe9a8b794ea15e657f613c3dee256ad6e3" translate="yes" xml:space="preserve">
          <source>Reorder basic blocks in the compiled function in order to reduce number of taken branches and improve code locality.</source>
          <target state="translated">对编译函数中的基本块进行重新排序,以减少被占用的分支数量,提高代码的局部性。</target>
        </trans-unit>
        <trans-unit id="868b5a2b9f40116ce6cc017884431ba3599c4f2c" translate="yes" xml:space="preserve">
          <source>Reorder functions in the object file in order to improve code locality. This is implemented by using special subsections &lt;code&gt;.text.hot&lt;/code&gt; for most frequently executed functions and &lt;code&gt;.text.unlikely&lt;/code&gt; for unlikely executed functions. Reordering is done by the linker so object file format must support named sections and linker must place them in a reasonable way.</source>
          <target state="translated">在目标文件中对函数进行重新排序，以提高代码的局部性。这是通过对最常执行的功能使用特殊的 &lt;code&gt;.text.hot&lt;/code&gt; &lt;code&gt;.text.unlikely&lt;/code&gt; 对不太可能执行的功能使用.text。小节来实现的。链接器完成了重新排序，因此目标文件格式必须支持命名节，并且链接器必须以合理的方式放置它们。</target>
        </trans-unit>
        <trans-unit id="4db98af9e39320a953bbea6bb998fe7493c40e5e" translate="yes" xml:space="preserve">
          <source>Replaced by</source>
          <target state="translated">代之以</target>
        </trans-unit>
        <trans-unit id="66ec31a6cc491021c387eb4e55e0ad4c5a4f7424" translate="yes" xml:space="preserve">
          <source>Report the CPU time taken by each subprocess in the compilation sequence. For C source files, this is the compiler proper and assembler (plus the linker if linking is done).</source>
          <target state="translated">报告编译序列中每个子进程所花费的CPU时间。对于C语言源文件,这是指编译器本身和汇编器(如果进行了链接,还要加上链接器)。</target>
        </trans-unit>
        <trans-unit id="886e8af128447aeefef31c794358ef6bddcacd1c" translate="yes" xml:space="preserve">
          <source>Request debugging information and also use &lt;var&gt;level&lt;/var&gt; to specify how much information. The default level is 2.</source>
          <target state="translated">请求调试信息，并使用 &lt;var&gt;level&lt;/var&gt; 指定多少信息。默认级别为2。</target>
        </trans-unit>
        <trans-unit id="50792516332342d0d1eda395f8cfbb177e04fe78" translate="yes" xml:space="preserve">
          <source>Require (do not require) that code using the standard (uncompressed) MIPS ISA be link-compatible with MIPS16 and microMIPS code, and vice versa.</source>
          <target state="translated">要求(不要求)使用标准(未压缩)MIPS ISA的代码与MIPS16和microMIPS代码链接兼容,反之亦然。</target>
        </trans-unit>
        <trans-unit id="af5306e882621ffa9b4f415a4290811d77c026c0" translate="yes" xml:space="preserve">
          <source>Require a constant operand and print the constant expression with no punctuation.</source>
          <target state="translated">要求操作数为常数,并打印常数表达式,不加标点。</target>
        </trans-unit>
        <trans-unit id="75dfdca44a05f21975d7bfe493dd698fbb1af400" translate="yes" xml:space="preserve">
          <source>Reserve space once for outgoing arguments in the function prologue rather than around each call. Generally beneficial for performance and size. Also needed for unwinding to avoid changing the stack frame around conditional code.</source>
          <target state="translated">在函数序言中为传出的参数保留一次空间,而不是在每次调用的周围。一般来说对性能和大小有利。也是为了避免在条件代码周围改变堆栈框架而需要的。</target>
        </trans-unit>
        <trans-unit id="94629eea0f8e1b90e19e833a19ccac13e4d420e3" translate="yes" xml:space="preserve">
          <source>Restrict the analyzer to run just the named checker, and enable it.</source>
          <target state="translated">限制分析器只运行命名的检查器,并启用它。</target>
        </trans-unit>
        <trans-unit id="7fdab2693d6cbb613b61178d94663186d04bbeb3" translate="yes" xml:space="preserve">
          <source>Restricts generation of IT blocks to conform to the rules of ARMv8-A. IT blocks can only contain a single 16-bit instruction from a select set of instructions. This option is on by default for ARMv8-A Thumb mode.</source>
          <target state="translated">限制 IT 块的生成以符合 ARMv8-A 的规则。IT 块只能包含选定指令集中的一条 16 位指令。对于ARMv8-A拇指模式,该选项默认为打开。</target>
        </trans-unit>
        <trans-unit id="e5415cb36e8b15e5a43bee566eb1a298ee341943" translate="yes" xml:space="preserve">
          <source>Return &amp;ldquo;short&amp;rdquo; &lt;code&gt;struct&lt;/code&gt; and &lt;code&gt;union&lt;/code&gt; values in memory like longer ones, rather than in registers. This convention is less efficient, but it has the advantage of allowing intercallability between GCC-compiled files and files compiled with other compilers, particularly the Portable C Compiler (pcc).</source>
          <target state="translated">像较长的 &lt;code&gt;struct&lt;/code&gt; 和 &lt;code&gt;union&lt;/code&gt; 值一样，在内存中返回&amp;ldquo;短&amp;rdquo; 结构和联合值，而不是在寄存器中。该约定的效率较低，但是具有允许GCC编译的文件与其他编译器（尤其是可移植C编译器（pcc））编译的文件之间的可调用性的优点。</target>
        </trans-unit>
        <trans-unit id="a50ab20cde7d366a67815b583ce3fa9e992f502c" translate="yes" xml:space="preserve">
          <source>Return 1 if &lt;var&gt;val&lt;/var&gt; is known to have the byte alignment given by &lt;var&gt;alignval&lt;/var&gt;, otherwise return 0. Note that this is different from</source>
          <target state="translated">如果已知 &lt;var&gt;val&lt;/var&gt; 具有由 &lt;var&gt;alignval&lt;/var&gt; 给定的字节对齐方式，则返回1，否则返回0。请注意，这与</target>
        </trans-unit>
        <trans-unit id="f0dd2a1246825d5d496ccaf1b983d6b8565185f3" translate="yes" xml:space="preserve">
          <source>Return 8-byte vectors in memory instead of MMX registers. This is the default on Solaris 8 and 9 and VxWorks to match the ABI of the Sun Studio compilers until version 12. Later compiler versions (starting with Studio 12 Update 1) follow the ABI used by other x86 targets, which is the default on Solaris 10 and later. &lt;em&gt;Only&lt;/em&gt; use this option if you need to remain compatible with existing code produced by those previous compiler versions or older versions of GCC.</source>
          <target state="translated">在内存而不是MMX寄存器中返回8字节向量。这是Solaris 8和9和VxWorks上的默认设置，以匹配Sun Studio编译器的ABI直到版本12。更高版本的编译器（从Studio 12 Update 1开始）遵循其他x86目标所使用的ABI，这是Solaris上的默认设置。 10及更高版本。&lt;em&gt;仅&lt;/em&gt;在需要与以前的编译器版本或更旧版本的GCC生成的现有代码保持兼容时，&lt;em&gt;才&lt;/em&gt;使用此选项。</target>
        </trans-unit>
        <trans-unit id="7cd08f506bbc481490a4eaa7c9f2a0ea64c20349" translate="yes" xml:space="preserve">
          <source>Return 8-byte vectors in memory instead of MMX registers. This is the default on VxWorks to match the ABI of the Sun Studio compilers until version 12. &lt;em&gt;Only&lt;/em&gt; use this option if you need to remain compatible with existing code produced by those previous compiler versions or older versions of GCC.</source>
          <target state="translated">在内存中返回8字节向量，而不是MMX寄存器。这是VxWorks上的默认设置，以匹配Sun Studio编译器的ABI直到版本12。&lt;em&gt;只有&lt;/em&gt;在需要与那些以前的编译器版本或较旧版本的GCC生成的现有代码保持兼容时，&lt;em&gt;才&lt;/em&gt;使用此选项。</target>
        </trans-unit>
        <trans-unit id="c21aa754cb318c04fb0ee764bc873d27cf0f356a" translate="yes" xml:space="preserve">
          <source>Return &lt;code&gt;struct&lt;/code&gt; and &lt;code&gt;union&lt;/code&gt; values in registers when possible. This is more efficient for small structures than</source>
          <target state="translated">如果可能，在寄存器中返回 &lt;code&gt;struct&lt;/code&gt; 和 &lt;code&gt;union&lt;/code&gt; 值。对于小型结构，这比</target>
        </trans-unit>
        <trans-unit id="36902af805238b98afe6ec42c8fc287d8ef121a4" translate="yes" xml:space="preserve">
          <source>Return VMS condition codes from &lt;code&gt;main&lt;/code&gt;. The default is to return POSIX-style condition (e.g. error) codes.</source>
          <target state="translated">从 &lt;code&gt;main&lt;/code&gt; 返回VMS条件代码。默认为返回POSIX样式的条件（例如错误）代码。</target>
        </trans-unit>
        <trans-unit id="4a959557662cc82b19295040cf9540ea2756207a" translate="yes" xml:space="preserve">
          <source>Return a nonzero value if a transaction is currently active, otherwise 0.</source>
          <target state="translated">如果当前交易处于活动状态,返回一个非零值,否则为0。</target>
        </trans-unit>
        <trans-unit id="e2b1c139ef70f0354479708d23d7002bd34b77b0" translate="yes" xml:space="preserve">
          <source>Return all structures in memory (as specified by the AIX ABI).</source>
          <target state="translated">返回内存中的所有结构(由AIX ABI指定)。</target>
        </trans-unit>
        <trans-unit id="30d548f2a666f3d2dacef41428651a854ac9ec7e" translate="yes" xml:space="preserve">
          <source>Return floating-point results in ac0 (fr0 in Unix assembler syntax).</source>
          <target state="translated">返回以ac0为单位的浮点结果(Unix汇编器语法中的fr0)。</target>
        </trans-unit>
        <trans-unit id="18c78c8de7fda3409221e2eb382dd5b60425f50a" translate="yes" xml:space="preserve">
          <source>Return floating-point results in memory. This is the default.</source>
          <target state="translated">返回内存中的浮点运算结果。这是默认值。</target>
        </trans-unit>
        <trans-unit id="b755295260a7fdcf5823a2b1f0e58a7da66e2993" translate="yes" xml:space="preserve">
          <source>Return structures smaller than 8 bytes in registers (as specified by the SVR4 ABI).</source>
          <target state="translated">返回寄存器中小于8字节的结构(由SVR4 ABI指定)。</target>
        </trans-unit>
        <trans-unit id="3d89b1dbd918009a622c075a1068bdd32199587c" translate="yes" xml:space="preserve">
          <source>Return the content of a system register which is mapped by &lt;var&gt;sr&lt;/var&gt;.</source>
          <target state="translated">返回由 &lt;var&gt;sr&lt;/var&gt; 映射的系统寄存器的内容。</target>
        </trans-unit>
        <trans-unit id="4c8c8de6a7d4547a06d2be7861947f5101a14fa7" translate="yes" xml:space="preserve">
          <source>Return the content of a user space register which is mapped by &lt;var&gt;usr&lt;/var&gt;.</source>
          <target state="translated">返回 &lt;var&gt;usr&lt;/var&gt; 映射的用户空间寄存器的内容。</target>
        </trans-unit>
        <trans-unit id="b6ef9796498d3cf9c9b3db66db0d93d9f477244a" translate="yes" xml:space="preserve">
          <source>Return the full 64-bit value of IACC0. The &lt;var&gt;reg&lt;/var&gt; argument is reserved for future expansion and must be 0.</source>
          <target state="translated">返回IACC0的完整64位值。该 &lt;var&gt;reg&lt;/var&gt; 参数保留为将来扩展，并且必须是0。</target>
        </trans-unit>
        <trans-unit id="d91fca12a5b708d6ecc723a264ae13bbf294ac10" translate="yes" xml:space="preserve">
          <source>Return the value of IACC0H if &lt;var&gt;reg&lt;/var&gt; is 0 and IACC0L if &lt;var&gt;reg&lt;/var&gt; is 1. Other values of &lt;var&gt;reg&lt;/var&gt; are rejected as invalid.</source>
          <target state="translated">如果 &lt;var&gt;reg&lt;/var&gt; 为0，则返回IACC0H的值；如果 &lt;var&gt;reg&lt;/var&gt; 为1 ，则返回IACC0L的值。其他 &lt;var&gt;reg&lt;/var&gt; 值将被拒绝为无效值。</target>
        </trans-unit>
        <trans-unit id="7c3c1904eaf1f7ff88cdff376d592fd0116b430c" translate="yes" xml:space="preserve">
          <source>Return using the &lt;code&gt;deret&lt;/code&gt; instruction. Interrupt handlers that don&amp;rsquo;t have this attribute return using &lt;code&gt;eret&lt;/code&gt; instead.</source>
          <target state="translated">使用 &lt;code&gt;deret&lt;/code&gt; 指令返回。没有此属性的中断处理程序将使用 &lt;code&gt;eret&lt;/code&gt; 返回。</target>
        </trans-unit>
        <trans-unit id="491a48cde73679c4ca1d8a8c89727d674aeaaaf5" translate="yes" xml:space="preserve">
          <source>Returning the new address in register &lt;code&gt;$31&lt;/code&gt;.</source>
          <target state="translated">返回寄存器 &lt;code&gt;$31&lt;/code&gt; 的新地址。</target>
        </trans-unit>
        <trans-unit id="74c0a885f7ba9097f37e8734157c3ad725a829d5" translate="yes" xml:space="preserve">
          <source>Returns &lt;var&gt;x&lt;/var&gt; with the order of the bytes reversed; for example, &lt;code&gt;0xaabb&lt;/code&gt; becomes &lt;code&gt;0xbbaa&lt;/code&gt;. Byte here always means exactly 8 bits.</source>
          <target state="translated">返回 &lt;var&gt;x&lt;/var&gt; ，其字节顺序相反；例如， &lt;code&gt;0xaabb&lt;/code&gt; 变为 &lt;code&gt;0xbbaa&lt;/code&gt; 。字节在这里始终意味着8位。</target>
        </trans-unit>
        <trans-unit id="0b996dc11180c5ec0a219a9ff967979bab82ce06" translate="yes" xml:space="preserve">
          <source>Returns a positive infinity, if supported by the floating-point format, else &lt;code&gt;DBL_MAX&lt;/code&gt;. This function is suitable for implementing the ISO C macro &lt;code&gt;HUGE_VAL&lt;/code&gt;.</source>
          <target state="translated">如果浮点格式支持，则返回正无穷大，否则返回 &lt;code&gt;DBL_MAX&lt;/code&gt; 。此函数适合于实现ISO C宏 &lt;code&gt;HUGE_VAL&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="444af2bf8634b26ae9a1f1a7ad3d817e427a36b4" translate="yes" xml:space="preserve">
          <source>Returns one plus the index of the least significant 1-bit of &lt;var&gt;x&lt;/var&gt;, or if &lt;var&gt;x&lt;/var&gt; is zero, returns zero.</source>
          <target state="translated">返回1加 &lt;var&gt;x&lt;/var&gt; 的最低有效1位的索引，或者如果 &lt;var&gt;x&lt;/var&gt; 为零，则返回零。</target>
        </trans-unit>
        <trans-unit id="dd145587033c252d0c6c626afd75667794945e4a" translate="yes" xml:space="preserve">
          <source>Returns the first argument raised to the power of the second. Unlike the &lt;code&gt;pow&lt;/code&gt; function no guarantees about precision and rounding are made.</source>
          <target state="translated">返回第一个参数的第二个幂。与 &lt;code&gt;pow&lt;/code&gt; 函数不同，不保证精度和舍入。</target>
        </trans-unit>
        <trans-unit id="4894d6f1b8e22494899330d0555ad8ffa8201099" translate="yes" xml:space="preserve">
          <source>Returns the number of 1-bits in &lt;var&gt;x&lt;/var&gt;.</source>
          <target state="translated">返回 &lt;var&gt;x&lt;/var&gt; 中的1位数字。</target>
        </trans-unit>
        <trans-unit id="ce29b9b6bb07f313a52a112df90327683c6c87b7" translate="yes" xml:space="preserve">
          <source>Returns the number of leading 0-bits in &lt;var&gt;x&lt;/var&gt;, starting at the most significant bit position. If &lt;var&gt;x&lt;/var&gt; is 0, the result is undefined.</source>
          <target state="translated">从最高有效位开始，返回 &lt;var&gt;x&lt;/var&gt; 中前导0位的数量。如果 &lt;var&gt;x&lt;/var&gt; 为0，则结果不确定。</target>
        </trans-unit>
        <trans-unit id="bafa0131b220bae62b75cbabaa4716f183d3539a" translate="yes" xml:space="preserve">
          <source>Returns the number of leading redundant sign bits in &lt;var&gt;x&lt;/var&gt;, i.e. the number of bits following the most significant bit that are identical to it. There are no special cases for 0 or other values.</source>
          <target state="translated">返回 &lt;var&gt;x&lt;/var&gt; 中前导冗余符号位的数量，即，与之相同的最高有效位之后的位数。对于0或其他值，没有特殊情况。</target>
        </trans-unit>
        <trans-unit id="8891f7de90b5ed2a6bcf46eb0d0dd183cbf8e095" translate="yes" xml:space="preserve">
          <source>Returns the number of trailing 0-bits in &lt;var&gt;x&lt;/var&gt;, starting at the least significant bit position. If &lt;var&gt;x&lt;/var&gt; is 0, the result is undefined.</source>
          <target state="translated">返回 &lt;var&gt;x&lt;/var&gt; 中从最低有效位位置开始的尾随0位的数量。如果 &lt;var&gt;x&lt;/var&gt; 为0，则结果不确定。</target>
        </trans-unit>
        <trans-unit id="683aba47e0d0f99bd0b4e45d3206d9722f1a751a" translate="yes" xml:space="preserve">
          <source>Returns the openacc gang, worker or vector id depending on whether &lt;var&gt;x&lt;/var&gt; is 0, 1 or 2.</source>
          <target state="translated">根据 &lt;var&gt;x&lt;/var&gt; 是0、1或2 返回openacc帮派，工作者或向量id 。</target>
        </trans-unit>
        <trans-unit id="b954a6b3f64ab16c6a6435467af5731684d67694" translate="yes" xml:space="preserve">
          <source>Returns the openacc gang, worker or vector size depending on whether &lt;var&gt;x&lt;/var&gt; is 0, 1 or 2.</source>
          <target state="translated">根据 &lt;var&gt;x&lt;/var&gt; 是0、1或2 返回openacc帮派，工作者或向量的大小。</target>
        </trans-unit>
        <trans-unit id="ce96cb4941a37e756412838ec82f95aa7bf28c53" translate="yes" xml:space="preserve">
          <source>Returns the parity of &lt;var&gt;x&lt;/var&gt;, i.e. the number of 1-bits in &lt;var&gt;x&lt;/var&gt; modulo 2.</source>
          <target state="translated">返回 &lt;var&gt;x&lt;/var&gt; 的奇偶校验，即 &lt;var&gt;x&lt;/var&gt; 模2中的1位数目。</target>
        </trans-unit>
        <trans-unit id="db0ab2a04434d84e5f96198ad75f2283577abc26" translate="yes" xml:space="preserve">
          <source>Returns the size of an object pointed to by &lt;var&gt;ptr&lt;/var&gt;. See &lt;a href=&quot;object-size-checking#Object-Size-Checking&quot;&gt;Object Size Checking&lt;/a&gt;, for a detailed description of the function.</source>
          <target state="translated">返回 &lt;var&gt;ptr&lt;/var&gt; 指向的对象的大小。有关功能的详细说明，请参见&lt;a href=&quot;object-size-checking#Object-Size-Checking&quot;&gt;对象大小检查&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="68a547fa5de03ac85628195326b7b381d300173e" translate="yes" xml:space="preserve">
          <source>Returns the value that is currently set in the &amp;lsquo;</source>
          <target state="translated">返回当前在&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="662ea5f2d376e017455cb3f3b25cf7d3dcc098a2" translate="yes" xml:space="preserve">
          <source>Revision 2 of the ASE was introduced in the second half of 2006. This revision adds extra instructions to the original ASE, but is otherwise backwards-compatible with it. You can select revision 2 using the command-line option</source>
          <target state="translated">ASE的第2次修订版于2006年下半年推出。这个修订版在原来的ASE基础上增加了额外的指令,但在其他方面是向后兼容的。你可以使用命令行选项来选择版本2</target>
        </trans-unit>
        <trans-unit id="0f30b33f89f9ca36be8f698bd38e6d3998be756f" translate="yes" xml:space="preserve">
          <source>Rewrite the profile after removing a subset of the gcda files, while maintaining the consistency of the summary and the histogram.</source>
          <target state="translated">删除gcda文件的子集后重写配置文件,同时保持摘要和直方图的一致性。</target>
        </trans-unit>
        <trans-unit id="2fe16a196b9fb96bcf22656d266c0859479e525c" translate="yes" xml:space="preserve">
          <source>Right-shift of -1, i.e., a bit mask with a trailing block of ones, the rest being zeroes. Or to put it another way, one less than a power of two. Can only match when the</source>
          <target state="translated">右移为-1,即位掩码的尾部为1,其余为0。或者换一种说法,就是比二的幂少一个。只有当</target>
        </trans-unit>
        <trans-unit id="e687f82379bd394253bac71b24072104b029d942" translate="yes" xml:space="preserve">
          <source>Round towards minus infinity.</source>
          <target state="translated">朝着负无限圆。</target>
        </trans-unit>
        <trans-unit id="1c3cd028b5f1e6b0edc653ec95977523018f750c" translate="yes" xml:space="preserve">
          <source>Run a pass to pack branches into VLIW instructions (default).</source>
          <target state="translated">运行一个通证,将分支打包成VLIW指令(默认)。</target>
        </trans-unit>
        <trans-unit id="9411013c77a06e01966ed1ee47bcab5ff91c1389" translate="yes" xml:space="preserve">
          <source>Run the program on a representative workload to generate the arc profile information. This may be repeated any number of times. You can run concurrent instances of your program, and provided that the file system supports locking, the data files will be correctly updated. Unless a strict ISO C dialect option is in effect, &lt;code&gt;fork&lt;/code&gt; calls are detected and correctly handled without double counting.</source>
          <target state="translated">以代表性的工作量运行该程序以生成电弧轮廓信息。可以重复多次。您可以运行程序的并发实例，并且如果文件系统支持锁定，则将正确更新数据文件。除非执行严格的ISO C语言方言，否则将检测到 &lt;code&gt;fork&lt;/code&gt; 调用并对其进行正确处理而无需重复计算。</target>
        </trans-unit>
        <trans-unit id="750febd8962214edbdb1e987e070e09b26bed006" translate="yes" xml:space="preserve">
          <source>Run variable tracking pass. It computes where variables are stored at each position in code. Better debugging information is then generated (if the debugging information format supports this information).</source>
          <target state="translated">运行变量跟踪通。它计算代码中每个位置的变量存储位置。然后生成更好的调试信息(如果调试信息格式支持这些信息)。</target>
        </trans-unit>
        <trans-unit id="02a6d5433704778d27c91a559d1a246126ca2b03" translate="yes" xml:space="preserve">
          <source>Running &lt;code&gt;gcov&lt;/code&gt; with your program&amp;rsquo;s source file names as arguments will now produce a listing of the code along with frequency of execution for each line. For example, if your program is called</source>
          <target state="translated">现在，使用程序的源文件名作为参数运行 &lt;code&gt;gcov&lt;/code&gt; ，将产生代码清单以及每行的执行频率。例如，如果您的程序被调用</target>
        </trans-unit>
        <trans-unit id="6f72aac6d9b0821f24cd11653e9e1ea61d3b8eda" translate="yes" xml:space="preserve">
          <source>Running the program will cause profile output to be generated. For each source file compiled with</source>
          <target state="translated">运行该程序将导致生成配置文件输出。对于每个用</target>
        </trans-unit>
        <trans-unit id="c8eb0737c3e070d91c82da44ad778a26941751ad" translate="yes" xml:space="preserve">
          <source>S/390 and zSeries&amp;mdash;</source>
          <target state="translated">S / 390和zSeries &amp;mdash;</target>
        </trans-unit>
        <trans-unit id="0a939f740002d6325878635a4ecb4eff29305501" translate="yes" xml:space="preserve">
          <source>SGPR register</source>
          <target state="translated">SGPR登记册</target>
        </trans-unit>
        <trans-unit id="52fb4091ed310353e09517862a36800ca2c86150" translate="yes" xml:space="preserve">
          <source>SGPR registers valid as a source for scalar memory instructions (excludes M0 and EXEC)</source>
          <target state="translated">作为标量内存指令源有效的SGPR寄存器(不包括M0和EXEC)。</target>
        </trans-unit>
        <trans-unit id="650aa12551cfc9241e1cd5e644660f68d55f375f" translate="yes" xml:space="preserve">
          <source>SGPR registers valid as a source or destination for vector instructions (excludes EXEC)</source>
          <target state="translated">SGPR寄存器作为向量指令的源头或目的地有效(不包括EXEC)。</target>
        </trans-unit>
        <trans-unit id="e7dc62b437b8a1360c1151acc32ef2d34c838e11" translate="yes" xml:space="preserve">
          <source>SGPR registers valid for instruction destinations, including VCC, M0 and EXEC</source>
          <target state="translated">SGPR寄存器对指令目的地有效,包括VCC、M0和EXEC。</target>
        </trans-unit>
        <trans-unit id="06d98e22c3590a0e22d3bfe590a8875bfcf62f6b" translate="yes" xml:space="preserve">
          <source>SGPR registers valid for instruction sources, including VCC, M0, EXEC and SCC</source>
          <target state="translated">SGPR寄存器对指令源有效,包括VCC、M0、EXEC和SCC。</target>
        </trans-unit>
        <trans-unit id="f2bee3c133454cc4ba540d21be2c00a748ada303" translate="yes" xml:space="preserve">
          <source>SGR substring for colorizing paths of control-flow events as printed via</source>
          <target state="translated">SGR子串,用于对控制流事件的路径进行着色,因为它通过</target>
        </trans-unit>
        <trans-unit id="c6b62b4cc9ebcf08c9d4f483e4f102a627e7a387" translate="yes" xml:space="preserve">
          <source>SGR substring for deleted lines within generated patches.</source>
          <target state="translated">在生成的补丁中删除行的SGR子串。</target>
        </trans-unit>
        <trans-unit id="4233963b1da8186d90f6982e524e354494399405" translate="yes" xml:space="preserve">
          <source>SGR substring for error: markers.</source>
          <target state="translated">错误的SGR子串:标记。</target>
        </trans-unit>
        <trans-unit id="f0f2ece3f5afef3a96618fb40d9e516c0938cd83" translate="yes" xml:space="preserve">
          <source>SGR substring for filename headers within generated patches.</source>
          <target state="translated">SGR子串用于生成补丁中的文件名头。</target>
        </trans-unit>
        <trans-unit id="ef3de6666e18bb1d0075a653fd3207878cc7a23b" translate="yes" xml:space="preserve">
          <source>SGR substring for first additional range.</source>
          <target state="translated">第一个附加范围的SGR子串。</target>
        </trans-unit>
        <trans-unit id="4047e51ab31499ea74aa0557270ff12e007c7adc" translate="yes" xml:space="preserve">
          <source>SGR substring for fix-it hints suggesting text to be deleted.</source>
          <target state="translated">SGR子串,用于提示要删除的文本的修复提示。</target>
        </trans-unit>
        <trans-unit id="26c66a34977746cd4a9a18d107d2484d6baf05b6" translate="yes" xml:space="preserve">
          <source>SGR substring for fix-it hints suggesting text to be inserted or replaced.</source>
          <target state="translated">SGR子串用于修复提示,建议插入或替换文本。</target>
        </trans-unit>
        <trans-unit id="a9e49a359d82dca9087414389ea6203f7d97c096" translate="yes" xml:space="preserve">
          <source>SGR substring for highlighting mismatching types within template arguments in the C++ frontend.</source>
          <target state="translated">SGR子串,用于在C++前端高亮显示模板参数内的不匹配类型。</target>
        </trans-unit>
        <trans-unit id="c2c54171666812e81afa463446e8b8c7bf07a44f" translate="yes" xml:space="preserve">
          <source>SGR substring for information printed within quotes.</source>
          <target state="translated">SGR子串,用于打印引号内的信息。</target>
        </trans-unit>
        <trans-unit id="21ec7b29e8556fe0733397c42965d397a384f312" translate="yes" xml:space="preserve">
          <source>SGR substring for inserted lines within generated patches.</source>
          <target state="translated">在生成的补丁中插入的行的SGR子串。</target>
        </trans-unit>
        <trans-unit id="631ff44ce6295a577998e0d45d27d8697542d130" translate="yes" xml:space="preserve">
          <source>SGR substring for location information, &amp;lsquo;</source>
          <target state="translated">用于位置信息的SGR子字符串，&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="13b8b196547b7c911a6008681f44695559ee3d8a" translate="yes" xml:space="preserve">
          <source>SGR substring for note: markers.</source>
          <target state="translated">注释的SGR子串:标记。</target>
        </trans-unit>
        <trans-unit id="3c69ac2294e9dd81357177aa53e734578849f1b7" translate="yes" xml:space="preserve">
          <source>SGR substring for second additional range.</source>
          <target state="translated">第二个附加范围的SGR子串。</target>
        </trans-unit>
        <trans-unit id="0836e70b794378ba99fbdf640887a055c2507059" translate="yes" xml:space="preserve">
          <source>SGR substring for the starts of hunks within generated patches.</source>
          <target state="translated">SGR子串,用于在生成的补丁中启动hunks。</target>
        </trans-unit>
        <trans-unit id="2ce0ddcf3a9872af855e6e18893f63c26237ec2f" translate="yes" xml:space="preserve">
          <source>SGR substring for warning: markers.</source>
          <target state="translated">警告的SGR子串:标记。</target>
        </trans-unit>
        <trans-unit id="4ef460c02c4bda0400a9d02a2e56bc8688eea615" translate="yes" xml:space="preserve">
          <source>SIMD builtins provided by the compiler can be used to generate the vector instructions. This section describes the available builtins and their usage in programs. With the</source>
          <target state="translated">编译器提供的SIMD内建可以用来生成向量指令。本节介绍了可用的内建函数及其在程序中的用法。有了</target>
        </trans-unit>
        <trans-unit id="ae4985ac14b1eabd45a1c1fcc429ea9f7090e85d" translate="yes" xml:space="preserve">
          <source>SIMD vector types declared using &lt;code&gt;__attribute ((vector_size))&lt;/code&gt; were mangled in a non-standard way that does not allow for overloading of functions taking vectors of different sizes.</source>
          <target state="translated">使用 &lt;code&gt;__attribute ((vector_size))&lt;/code&gt; 声明的SIMD向量类型以一种非标准的方式处理，不允许使用不同大小的向量重载函数。</target>
        </trans-unit>
        <trans-unit id="256c9f9a067e633db18da0ec81de7b585e074898" translate="yes" xml:space="preserve">
          <source>SIZE_MAX</source>
          <target state="translated">SIZE_MAX</target>
        </trans-unit>
        <trans-unit id="0c1688b370e73b8fab30795615287ddf0ee92cde" translate="yes" xml:space="preserve">
          <source>SPARC&amp;mdash;</source>
          <target state="translated">SPARC&amp;mdash;</target>
        </trans-unit>
        <trans-unit id="4c33d2e33886a24479b8c7ca85ded7473e3a114a" translate="yes" xml:space="preserve">
          <source>SPU&amp;mdash;</source>
          <target state="translated">SPU&amp;mdash;</target>
        </trans-unit>
        <trans-unit id="d5ef57a9b4e24298fd79d6a4c241fc751bc397dc" translate="yes" xml:space="preserve">
          <source>SSE constant zero operand.</source>
          <target state="translated">SSE常零操作数。</target>
        </trans-unit>
        <trans-unit id="6b6185655c0d6d39e8477b7cf295bc855e8520de" translate="yes" xml:space="preserve">
          <source>SSE instructions.</source>
          <target state="translated">上交所指示。</target>
        </trans-unit>
        <trans-unit id="ad670c94b7871773b33360abf956fb366993570e" translate="yes" xml:space="preserve">
          <source>SSE2 instructions.</source>
          <target state="translated">SSE2指令。</target>
        </trans-unit>
        <trans-unit id="2369317c8b51e3b18170998e24ffa71aa0b8a0d0" translate="yes" xml:space="preserve">
          <source>SSE3 instructions.</source>
          <target state="translated">SSE3说明。</target>
        </trans-unit>
        <trans-unit id="52027268fb40ad079dd27f174909bf61fa52b68f" translate="yes" xml:space="preserve">
          <source>SSE4.1 instructions.</source>
          <target state="translated">SSE4.1说明。</target>
        </trans-unit>
        <trans-unit id="1220ef87db9d2afe63d2dbbebe7cc117f311cd6d" translate="yes" xml:space="preserve">
          <source>SSE4.2 instructions.</source>
          <target state="translated">SSE4.2说明。</target>
        </trans-unit>
        <trans-unit id="14c8a208e6acf4297b13ae5c14762fb6cb87c9a5" translate="yes" xml:space="preserve">
          <source>SSE4A instructions.</source>
          <target state="translated">SSE4A说明。</target>
        </trans-unit>
        <trans-unit id="a824cf2031e7a9f24844581ed281a20b09b219a7" translate="yes" xml:space="preserve">
          <source>SSSE3 instructions.</source>
          <target state="translated">SSSE3指令。</target>
        </trans-unit>
        <trans-unit id="75f02b7e3264b6af278eeb7499231b0a15daefdb" translate="yes" xml:space="preserve">
          <source>STVX</source>
          <target state="translated">STVX</target>
        </trans-unit>
        <trans-unit id="f54d3d8da212d77cf012ec70b98f091e4df6592b" translate="yes" xml:space="preserve">
          <source>STXVD2X</source>
          <target state="translated">STXVD2X</target>
        </trans-unit>
        <trans-unit id="464ed831ffed8bdfd8130295a2edb2d9e9578400" translate="yes" xml:space="preserve">
          <source>STXVW4X</source>
          <target state="translated">STXVW4X</target>
        </trans-unit>
        <trans-unit id="b0dabbf327525cacc4497069188029fd059e7389" translate="yes" xml:space="preserve">
          <source>Safely accessing C data and calling functions from basic &lt;code&gt;asm&lt;/code&gt; is more complex than it may appear. To access C data, it is better to use extended &lt;code&gt;asm&lt;/code&gt;.</source>
          <target state="translated">从基本 &lt;code&gt;asm&lt;/code&gt; 中安全地访问C数据和调用函数比看起来要复杂得多。要访问C数据，最好使用扩展 &lt;code&gt;asm&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4e1a6674d38590faffffeb4695d9d452b5339baa" translate="yes" xml:space="preserve">
          <source>Same as</source>
          <target state="translated">同理</target>
        </trans-unit>
        <trans-unit id="69d40738c15585e5ece8390b1d9dcc4417cde63d" translate="yes" xml:space="preserve">
          <source>Same as &amp;lsquo;</source>
          <target state="translated">和...一样 '</target>
        </trans-unit>
        <trans-unit id="a79ab980d305db447bee9c479d0843b84bd7f8c7" translate="yes" xml:space="preserve">
          <source>Same as &lt;code&gt;__builtin_tbegin&lt;/code&gt; but without FPR saves and restores. Using this variant in code making use of FPRs will leave the FPRs in undefined state when entering the transaction abort handler code.</source>
          <target state="translated">与 &lt;code&gt;__builtin_tbegin&lt;/code&gt; 相同，但没有FPR保存和恢复。在使用FPR的代码中使用此变体会在输入事务异常中止处理程序代码时使FPR处于未定义状态。</target>
        </trans-unit>
        <trans-unit id="4de3c96aaa50bbcebfe6c154f9425492819e4fda" translate="yes" xml:space="preserve">
          <source>Same as &lt;code&gt;__builtin_tbegin_retry&lt;/code&gt; but without FPR saves and restores. Using this variant in code making use of FPRs will leave the FPRs in undefined state when entering the transaction abort handler code.</source>
          <target state="translated">与 &lt;code&gt;__builtin_tbegin_retry&lt;/code&gt; 相同，但没有FPR保存和恢复。在使用FPR的代码中使用此变体会在输入事务异常中止处理程序代码时使FPR处于未定义状态。</target>
        </trans-unit>
        <trans-unit id="d0f31e0230de2939ed9a4a3bfde6705e7873175b" translate="yes" xml:space="preserve">
          <source>Same as above, but for &lt;code&gt;long double&lt;/code&gt; instead of &lt;code&gt;double&lt;/code&gt;.</source>
          <target state="translated">与上述相同，但 &lt;code&gt;long double&lt;/code&gt; 而不是 &lt;code&gt;double&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="aac99bb488266e0b7b7ade351899535fdea6eef8" translate="yes" xml:space="preserve">
          <source>Sanitize global variables in selected user-defined sections. &lt;var&gt;si&lt;/var&gt; may contain wildcards.</source>
          <target state="translated">在选定的用户定义部分中清除全局变量。 &lt;var&gt;si&lt;/var&gt; 可能包含通配符。</target>
        </trans-unit>
        <trans-unit id="9384413dcf3a99a56f6d5fb6ddd74fec9e18520d" translate="yes" xml:space="preserve">
          <source>Saturating addition. Return the result of adding &lt;var&gt;x&lt;/var&gt; and &lt;var&gt;y&lt;/var&gt;, storing the value 32767 if the result overflows.</source>
          <target state="translated">饱和加成。返回将 &lt;var&gt;x&lt;/var&gt; 和 &lt;var&gt;y&lt;/var&gt; 相加的结果，如果结果溢出，则存储值32767。</target>
        </trans-unit>
        <trans-unit id="504215725299cdd825dda25f0c85b38e0bd4d51e" translate="yes" xml:space="preserve">
          <source>Saturating subtraction. Return the result of subtracting &lt;var&gt;y&lt;/var&gt; from &lt;var&gt;x&lt;/var&gt;, storing the value -32768 if the result overflows.</source>
          <target state="translated">饱和减法。返回从 &lt;var&gt;x&lt;/var&gt; 减去 &lt;var&gt;y&lt;/var&gt; 的结果，如果结果溢出则存储-32768的值。</target>
        </trans-unit>
        <trans-unit id="20ad33acfaabe4d68a4482f6776dcaa2a9be1f91" translate="yes" xml:space="preserve">
          <source>Says that .ZZ files are, in fact, C++ source files.</source>
          <target state="translated">说是.ZZ文件,其实是C++源文件。</target>
        </trans-unit>
        <trans-unit id="b29493698792fa428aa92855b6cf7ad4a0f77c71" translate="yes" xml:space="preserve">
          <source>Says to make debugging dumps during compilation as specified by &lt;var&gt;letters&lt;/var&gt;. The flags documented here are those relevant to the preprocessor. Other &lt;var&gt;letters&lt;/var&gt; are interpreted by the compiler proper, or reserved for future versions of GCC, and so are silently ignored. If you specify &lt;var&gt;letters&lt;/var&gt; whose behavior conflicts, the result is undefined. See &lt;a href=&quot;developer-options#Developer-Options&quot;&gt;Developer Options&lt;/a&gt;, for more information.</source>
          <target state="translated">表示按照 &lt;var&gt;letters&lt;/var&gt; 指定的方式在编译过程中进行调试转储。此处记录的标志是与预处理器相关的标志。其他 &lt;var&gt;letters&lt;/var&gt; 由编译器自行解释，或保留给以后的GCC版本，因此将被静默忽略。如果指定行为冲突的 &lt;var&gt;letters&lt;/var&gt; ，则结果是不确定的。有关更多信息，请参见&lt;a href=&quot;developer-options#Developer-Options&quot;&gt;开发人员选项&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4060536ee75ab5287f71dfb97d864d7f22d2ca94" translate="yes" xml:space="preserve">
          <source>Says to make debugging dumps during compilation at times specified by &lt;var&gt;letters&lt;/var&gt;. This is used for debugging the RTL-based passes of the compiler.</source>
          <target state="translated">表示在编译过程中按 &lt;var&gt;letters&lt;/var&gt; 指定的时间进行调试转储。这用于调试基于RTL的编译器传递。</target>
        </trans-unit>
        <trans-unit id="d4f20ee224e1157c9c2cb4923edd8e603ca68078" translate="yes" xml:space="preserve">
          <source>Scalar condition register: SCC</source>
          <target state="translated">标量条件寄存器。SCC</target>
        </trans-unit>
        <trans-unit id="112620d6eb072a0c362e896824493987aba20f3a" translate="yes" xml:space="preserve">
          <source>Scale factor to apply to the number of blocks in a threading path when comparing to the number of (scaled) statements.</source>
          <target state="translated">当比较(缩放)语句的数量时,应用于线程路径中块的数量的缩放因子。</target>
        </trans-unit>
        <trans-unit id="95dbc5e98d074c513e988faebfbccb22e09ae395" translate="yes" xml:space="preserve">
          <source>Scale factor to apply to the number of statements in a threading path when comparing to the number of (scaled) blocks.</source>
          <target state="translated">当比较线程路径中的语句数量和(比例)块数量时,应用的比例因子。</target>
        </trans-unit>
        <trans-unit id="86cf479673ca3b066e5d67cd80cb00f46a9ad376" translate="yes" xml:space="preserve">
          <source>Scale the profile counters. The specified value can be in floating point value, or simple fraction value form, such 1, 2, 2/3, and 5/3.</source>
          <target state="translated">缩放轮廓计数器。指定的值可以是浮点值,或简单的分数值形式,如1、2、2/3和5/3。</target>
        </trans-unit>
        <trans-unit id="ff4952674116ca1ef68e6dc524bc6fd65b2aa9ad" translate="yes" xml:space="preserve">
          <source>Scaling factor in calculation of maximum distance an expression can be moved by GCSE optimizations. This is currently supported only in the code hoisting pass. The bigger the ratio, the more aggressive code hoisting is with simple expressions, i.e., the expressions that have cost less than</source>
          <target state="translated">GCSE优化计算一个表达式可以移动的最大距离时的缩放因子。目前只在代码提升通证中支持。比值越大,对于简单的表达式,即成本小于的表达式,代码提升越积极。</target>
        </trans-unit>
        <trans-unit id="532227f59708576e594e220bb0a8588203d0536c" translate="yes" xml:space="preserve">
          <source>Schedule code according to the constraints for the machine type &lt;var&gt;cpu-type&lt;/var&gt;. The choices for &lt;var&gt;cpu-type&lt;/var&gt; are &amp;lsquo;</source>
          <target state="translated">根据机器类型 &lt;var&gt;cpu-type&lt;/var&gt; 的约束调度代码。 &lt;var&gt;cpu-type&lt;/var&gt; 的选择是'</target>
        </trans-unit>
        <trans-unit id="512110c2a7a87680ea125d2d5070dd617326491f" translate="yes" xml:space="preserve">
          <source>Schedule instructions using selective scheduling algorithm. Selective scheduling runs instead of the first scheduler pass.</source>
          <target state="translated">使用选择性调度算法调度指令。选择性调度代替第一道调度程序运行。</target>
        </trans-unit>
        <trans-unit id="a8bc58f0865e7ffaa1277982a9a30e1e6328ca0f" translate="yes" xml:space="preserve">
          <source>Schedule instructions using selective scheduling algorithm. Selective scheduling runs instead of the second scheduler pass.</source>
          <target state="translated">使用选择性调度算法调度指令。选择性调度代替第二道调度程序运行。</target>
        </trans-unit>
        <trans-unit id="b5c9dbe52234ab7adfb9709d744b3335541af679" translate="yes" xml:space="preserve">
          <source>Schedule type of omp schedule for loops parallelized by parloops (static, dynamic, guided, auto, runtime).</source>
          <target state="translated">omp调度类型的循环并行的parloops(静态、动态、引导、自动、运行时)。</target>
        </trans-unit>
        <trans-unit id="090706d50c1a9631674ea954b72f473248174f5c" translate="yes" xml:space="preserve">
          <source>Schedules as an EV4 and has no instruction set extensions.</source>
          <target state="translated">附表为EV4,没有指令集扩展。</target>
        </trans-unit>
        <trans-unit id="e3bebf86216646d883305006d7a92a77b0a80860" translate="yes" xml:space="preserve">
          <source>Schedules as an EV5 and has no instruction set extensions.</source>
          <target state="translated">附表为EV5,没有指令集扩展。</target>
        </trans-unit>
        <trans-unit id="01ff3c69f7080eed625112079f8743f5f048b2bc" translate="yes" xml:space="preserve">
          <source>Schedules as an EV5 and supports the BWX and MAX extensions.</source>
          <target state="translated">以EV5方式调度,支持BWX和MAX扩展。</target>
        </trans-unit>
        <trans-unit id="b44df77a439d014c7e3b18a60c36ae6be23b8bed" translate="yes" xml:space="preserve">
          <source>Schedules as an EV5 and supports the BWX extension.</source>
          <target state="translated">以EV5方式调度,支持BWX扩展。</target>
        </trans-unit>
        <trans-unit id="d98e18423f9732958ffea0c6bd4bd7f9f1294627" translate="yes" xml:space="preserve">
          <source>Schedules as an EV6 and supports the BWX, CIX, FIX, and MAX extensions.</source>
          <target state="translated">以EV6方式调度,支持BWX、CIX、FIX和MAX扩展。</target>
        </trans-unit>
        <trans-unit id="bbf50f85903256e541bbf3311b99e71d3918fbbc" translate="yes" xml:space="preserve">
          <source>Schedules as an EV6 and supports the BWX, FIX, and MAX extensions.</source>
          <target state="translated">以EV6方式调度,支持BWX、FIX和MAX扩展。</target>
        </trans-unit>
        <trans-unit id="2933ec5911ccb0e4b7c1d0f9419a5e7a7d360e81" translate="yes" xml:space="preserve">
          <source>Scoped enumerators passed as arguments to a variadic function are promoted like unscoped enumerators, causing &lt;code&gt;va_arg&lt;/code&gt; to complain. On most targets this does not actually affect the parameter passing ABI, as there is no way to pass an argument smaller than &lt;code&gt;int&lt;/code&gt;.</source>
          <target state="translated">像无作用域枚举器一样，将作为参数传递给可变参数函数的作用域枚举器得到提升，从而导致 &lt;code&gt;va_arg&lt;/code&gt; 抱怨。在大多数目标上，这实际上不会影响传递ABI的参数，因为没有办法传递小于 &lt;code&gt;int&lt;/code&gt; 的参数。</target>
        </trans-unit>
        <trans-unit id="178b5f6bb9943f6de74ed00010972a24a7bb5622" translate="yes" xml:space="preserve">
          <source>Search for &lt;var&gt;file&lt;/var&gt; and insert its text at the current point in the specs file.</source>
          <target state="translated">搜索 &lt;var&gt;file&lt;/var&gt; 并将其文本插入specs文件中的当前位置。</target>
        </trans-unit>
        <trans-unit id="ba898c1a0a41a81bab594f983313300f956e596d" translate="yes" xml:space="preserve">
          <source>Search the directories &lt;var&gt;dirs&lt;/var&gt;, and no others, for libraries specified with</source>
          <target state="translated">搜索目录 &lt;var&gt;dirs&lt;/var&gt; ，而不搜索其他目录，以指定使用的库</target>
        </trans-unit>
        <trans-unit id="240544ba3059ddd6fa51173abfa71bc79edad6e6" translate="yes" xml:space="preserve">
          <source>Search the library named &lt;var&gt;library&lt;/var&gt; when linking. (The second alternative with the library as a separate argument is only for POSIX compliance and is not recommended.)</source>
          <target state="translated">链接时搜索名为 &lt;var&gt;library&lt;/var&gt; 的库。（使用库作为单独参数的第二种替代方法仅是为了符合POSIX，不建议这样做。）</target>
        </trans-unit>
        <trans-unit id="2f6637081eaeba40dac20edac8983d65e9c687dd" translate="yes" xml:space="preserve">
          <source>Second from top of 80387 floating-point stack (&lt;code&gt;%st(1)&lt;/code&gt;).</source>
          <target state="translated">从80387浮点堆栈（ &lt;code&gt;%st(1)&lt;/code&gt; ）的顶部开始第二个。</target>
        </trans-unit>
        <trans-unit id="f2a9e9979a3fe235f6129e47257fa2f36d503ac5" translate="yes" xml:space="preserve">
          <source>Second, the argument is passed to the function using the calling conventions of the first member of the transparent union, not the calling conventions of the union itself. All members of the union must have the same machine representation; this is necessary for this argument passing to work properly.</source>
          <target state="translated">其次,参数传递给函数时,使用的是透明联盟中第一个成员的调用惯例,而不是联盟本身的调用惯例。联合体的所有成员必须具有相同的机器表示;这对于这种参数传递的正常工作是必要的。</target>
        </trans-unit>
        <trans-unit id="ea3456e6bd81cdabf3c368be0bfbf5a7261e636e" translate="yes" xml:space="preserve">
          <source>Second, when the type of an anonymous field is a &lt;code&gt;typedef&lt;/code&gt; for a &lt;code&gt;struct&lt;/code&gt; or &lt;code&gt;union&lt;/code&gt;, code may refer to the field using the name of the &lt;code&gt;typedef&lt;/code&gt;.</source>
          <target state="translated">其次，当一个匿名字段的类型是一个 &lt;code&gt;typedef&lt;/code&gt; 用于 &lt;code&gt;struct&lt;/code&gt; 或 &lt;code&gt;union&lt;/code&gt; ，代码可使用的名称指的是场 &lt;code&gt;typedef&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f4677b56029d2d5a1454e15af8e873ba7843c108" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;arm-options#ARM-Options&quot;&gt;ARM Options&lt;/a&gt; and &lt;a href=&quot;aarch64-options#AArch64-Options&quot;&gt;AArch64 Options&lt;/a&gt; for more information on the availability of extensions.</source>
          <target state="translated">有关扩展的可用性的更多信息，请参见&lt;a href=&quot;arm-options#ARM-Options&quot;&gt;ARM选项&lt;/a&gt;和&lt;a href=&quot;aarch64-options#AArch64-Options&quot;&gt;AArch64选项&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a3ed7b770e23a9147c81b72b94f04738551cd044" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;assembler-options#Assembler-Options&quot;&gt;Passing Options to the Assembler&lt;/a&gt;.</source>
          <target state="translated">请参见将&lt;a href=&quot;assembler-options#Assembler-Options&quot;&gt;选项传递给汇编器&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5fa624e4b9bdd50f27ab9969ddbd05fadec90527" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;attribute-syntax#Attribute-Syntax&quot;&gt;Attribute Syntax&lt;/a&gt;, for details of the exact syntax for using attributes.</source>
          <target state="translated">有关使用属性的确切语法的详细信息，请参见&amp;ldquo; &lt;a href=&quot;attribute-syntax#Attribute-Syntax&quot;&gt;属性语法&amp;rdquo;&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e7798844f22a2c2e6d35571a21bc9b88a41e9976" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;c-dialect-options#C-Dialect-Options&quot;&gt;Options Controlling C Dialect&lt;/a&gt;.</source>
          <target state="translated">请参阅&lt;a href=&quot;c-dialect-options#C-Dialect-Options&quot;&gt;控制C语言的选项&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b629b8d91d57fd123b970633646d0ea0d91cd217" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;c_002b_002b-dialect-options#C_002b_002b-Dialect-Options&quot;&gt;Options Controlling C++ Dialect&lt;/a&gt;.</source>
          <target state="translated">请参阅&lt;a href=&quot;c_002b_002b-dialect-options#C_002b_002b-Dialect-Options&quot;&gt;控制C ++语言的选项&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7a9f7ae4d625bd6f1865541dd19d916bd7384014" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;c_002b_002b-interface#C_002b_002b-Interface&quot;&gt;Declarations and Definitions in One Header&lt;/a&gt;, for another way to control placement of these constructs.</source>
          <target state="translated">有关控制这些构造的放置的另一种方法，请参见&lt;a href=&quot;c_002b_002b-interface#C_002b_002b-Interface&quot;&gt;&amp;ldquo;一个标头中的声明和定义&amp;rdquo;&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f65573cc9b99e9cba7846f00d5e0e8a7a8e51df7" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;code-gen-options#Code-Gen-Options&quot;&gt;Options for Code Generation Conventions&lt;/a&gt;.</source>
          <target state="translated">请参阅&lt;a href=&quot;code-gen-options#Code-Gen-Options&quot;&gt;代码生成约定的选项&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f2c2c26650fff8c74769de012a123d508e5fd307" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;debugging-options#Debugging-Options&quot;&gt;Options for Debugging Your Program&lt;/a&gt;.</source>
          <target state="translated">请参阅&lt;a href=&quot;debugging-options#Debugging-Options&quot;&gt;调试程序的选项&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ed60c5c11a89d5b8997565970e20adef9aae6e73" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;developer-options#Developer-Options&quot;&gt;GCC Developer Options&lt;/a&gt;.</source>
          <target state="translated">请参阅&lt;a href=&quot;developer-options#Developer-Options&quot;&gt;GCC开发者选项&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="068f02a10a991b8dd4c9c4d4f1176aa1f6736565" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;diagnostic-message-formatting-options#Diagnostic-Message-Formatting-Options&quot;&gt;Options to Control Diagnostic Messages Formatting&lt;/a&gt;.</source>
          <target state="translated">请参阅&lt;a href=&quot;diagnostic-message-formatting-options#Diagnostic-Message-Formatting-Options&quot;&gt;控制诊断消息格式的选项&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="980f2aedfa176760da97d08ae0c35c00555524bc" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;directory-options#Directory-Options&quot;&gt;Options for Directory Search&lt;/a&gt;.</source>
          <target state="translated">请参阅&lt;a href=&quot;directory-options#Directory-Options&quot;&gt;目录搜索选项&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b7df942c5c9bf184f3f2a89ce21ae90ce25b87ab" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;Function Attributes&lt;/a&gt;, for details of the semantics of attributes applying to functions. See &lt;a href=&quot;variable-attributes#Variable-Attributes&quot;&gt;Variable Attributes&lt;/a&gt;, for details of the semantics of attributes applying to variables. See &lt;a href=&quot;type-attributes#Type-Attributes&quot;&gt;Type Attributes&lt;/a&gt;, for details of the semantics of attributes applying to structure, union and enumerated types. See &lt;a href=&quot;label-attributes#Label-Attributes&quot;&gt;Label Attributes&lt;/a&gt;, for details of the semantics of attributes applying to labels. See &lt;a href=&quot;enumerator-attributes#Enumerator-Attributes&quot;&gt;Enumerator Attributes&lt;/a&gt;, for details of the semantics of attributes applying to enumerators. See &lt;a href=&quot;statement-attributes#Statement-Attributes&quot;&gt;Statement Attributes&lt;/a&gt;, for details of the semantics of attributes applying to statements.</source>
          <target state="translated">有关适用于函数的属性的语义的详细信息，请参见&lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;函数属性&lt;/a&gt;。有关应用于变量的属性的语义的详细信息，请参见&lt;a href=&quot;variable-attributes#Variable-Attributes&quot;&gt;变量属性&lt;/a&gt;。有关适用于结构，联合和枚举类型的属性的语义的详细信息，请参见&lt;a href=&quot;type-attributes#Type-Attributes&quot;&gt;类型属性&lt;/a&gt;。有关应用于标签的属性的语义的详细信息，请参见&lt;a href=&quot;label-attributes#Label-Attributes&quot;&gt;标签属性&lt;/a&gt;。有关应用于&lt;a href=&quot;enumerator-attributes#Enumerator-Attributes&quot;&gt;枚举器的属性&lt;/a&gt;的语义的详细信息，请参见Enumerator Attributes。有关应用于语句的属性的语义的详细信息，请参见&lt;a href=&quot;statement-attributes#Statement-Attributes&quot;&gt;语句属性&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="01ea811dd42662016230f114720fe01339ff4419" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;function-multiversioning#Function-Multiversioning&quot;&gt;Function Multiversioning&lt;/a&gt;, where it is used to specify the default function version.</source>
          <target state="translated">请参阅&lt;a href=&quot;function-multiversioning#Function-Multiversioning&quot;&gt;函数多版本化&lt;/a&gt;，用于指定默认函数版本。</target>
        </trans-unit>
        <trans-unit id="148b71982b9647e6d6ecafa6882d1190f5b5569f" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;http://gcc.gnu.org/onlinedocs/cpp/Implementation_002ddefined-behavior.html#Implementation_002ddefined-behavior&quot;&gt;Implementation-defined behavior&lt;/a&gt; in The C Preprocessor, for details of these aspects of implementation-defined behavior.</source>
          <target state="translated">有关&lt;a href=&quot;http://gcc.gnu.org/onlinedocs/cpp/Implementation_002ddefined-behavior.html#Implementation_002ddefined-behavior&quot;&gt;实现定义的行为&lt;/a&gt;的这些方面的详细信息，请参见The C Preprocessor中的实现定义的行为。</target>
        </trans-unit>
        <trans-unit id="18443493189256836930c6a050f4842f9c78519f" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;http://gcc.gnu.org/onlinedocs/cpp/Implementation_002ddefined-behavior.html#Implementation_002ddefined-behavior&quot;&gt;Implementation-defined behavior&lt;/a&gt; in The C Preprocessor.</source>
          <target state="translated">请参见The C Preprocessor中的&lt;a href=&quot;http://gcc.gnu.org/onlinedocs/cpp/Implementation_002ddefined-behavior.html#Implementation_002ddefined-behavior&quot;&gt;实现定义的行为&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c7d31e8396ed3e8775b3882f9a8562adac8992e6" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;http://gcc.gnu.org/onlinedocs/cpp/Implementation_002ddefined-behavior.html#Implementation_002ddefined-behavior&quot;&gt;Implementation-defined behavior&lt;/a&gt; in The C Preprocessor. &lt;code&gt;char16_t&lt;/code&gt; and &lt;code&gt;char32_t&lt;/code&gt; literals are always encoded in UTF-16 and UTF-32 respectively.</source>
          <target state="translated">请参见The C Preprocessor中的&lt;a href=&quot;http://gcc.gnu.org/onlinedocs/cpp/Implementation_002ddefined-behavior.html#Implementation_002ddefined-behavior&quot;&gt;实现定义的行为&lt;/a&gt;。 &lt;code&gt;char16_t&lt;/code&gt; 和 &lt;code&gt;char32_t&lt;/code&gt; 文字始终始终分别以UTF-16和UTF-32编码。</target>
        </trans-unit>
        <trans-unit id="658fbadcbe7e3cfa27592bb7cc8aab369c0db247" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;http://gcc.gnu.org/onlinedocs/cpp/Pragmas.html#Pragmas&quot;&gt;Pragmas&lt;/a&gt; in The C Preprocessor, for details of pragmas accepted by GCC on all targets. See &lt;a href=&quot;pragmas#Pragmas&quot;&gt;Pragmas Accepted by GCC&lt;/a&gt;, for details of target-specific pragmas.</source>
          <target state="translated">见&lt;a href=&quot;http://gcc.gnu.org/onlinedocs/cpp/Pragmas.html#Pragmas&quot;&gt;编译指示&lt;/a&gt;中的C预处理器，由GCC上的所有目标接受编译指示的细节。有关特定于目标的实用程序的详细信息，请参见&lt;a href=&quot;pragmas#Pragmas&quot;&gt;GCC接受的&lt;/a&gt;实用程序。</target>
        </trans-unit>
        <trans-unit id="21007d084137c7d2ec1671d76187750384f6f2e0" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;http://gcc.gnu.org/onlinedocs/gccint/Machine-Modes.html#Machine-Modes&quot;&gt;Machine Modes&lt;/a&gt; in GNU Compiler Collection (GCC) Internals, for a list of the possible keywords for &lt;var&gt;mode&lt;/var&gt;. You may also specify a mode of &lt;code&gt;byte&lt;/code&gt; or &lt;code&gt;__byte__&lt;/code&gt; to indicate the mode corresponding to a one-byte integer, &lt;code&gt;word&lt;/code&gt; or &lt;code&gt;__word__&lt;/code&gt; for the mode of a one-word integer, and &lt;code&gt;pointer&lt;/code&gt; or &lt;code&gt;__pointer__&lt;/code&gt; for the mode used to represent pointers.</source>
          <target state="translated">有关 &lt;var&gt;mode&lt;/var&gt; 的可能关键字的列表，请参见GNU Compiler Collection（GCC）内部的&lt;a href=&quot;http://gcc.gnu.org/onlinedocs/gccint/Machine-Modes.html#Machine-Modes&quot;&gt;机器模式&lt;/a&gt;。您还可以指定 &lt;code&gt;byte&lt;/code&gt; 或 &lt;code&gt;__byte__&lt;/code&gt; 的模式来表示与一字节整数相对应的模式，对于一个单字整数的模式来表示对应于 &lt;code&gt;word&lt;/code&gt; 或 &lt;code&gt;__word__&lt;/code&gt; 的模式，对于用于表示指针的模式来指定 &lt;code&gt;pointer&lt;/code&gt; 或 &lt;code&gt;__pointer__&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2b73e4c61d6aa3ba91f4f3757ed312f0dea34e9a" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;http://gcc.gnu.org/onlinedocs/gfortran/Standards.html#Standards&quot;&gt;Standards&lt;/a&gt; in The GNU Fortran Compiler, for details of standards supported by GNU Fortran.</source>
          <target state="translated">参见&lt;a href=&quot;http://gcc.gnu.org/onlinedocs/gfortran/Standards.html#Standards&quot;&gt;标准&lt;/a&gt;中的GNU C ++编译器，通过GNU的Fortran支持标准的详细信息。</target>
        </trans-unit>
        <trans-unit id="d4544c625c9250deeb4d1b2109535476e6a41bc9" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;http://gcc.gnu.org/onlinedocs/gnat_rm/index.html#Top&quot;&gt;About This Guide&lt;/a&gt; in GNAT Reference Manual, for information on standard conformance and compatibility of the Ada compiler.</source>
          <target state="translated">有关Ada编译器的标准一致性和兼容性的信息，请参见GNAT参考手册中的&lt;a href=&quot;http://gcc.gnu.org/onlinedocs/gnat_rm/index.html#Top&quot;&gt;关于本指南&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="55b4d78ded59c60738ad7dd10ccaf7dcedeb36a8" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://gcc.gnu.org/onlinedocs/gcc-10.2.0/gcc/Option-Index.html#Option-Index&quot;&gt;Option Index&lt;/a&gt;, for an index to GCC&amp;rsquo;s options.</source>
          <target state="translated">请参阅&lt;a href=&quot;https://gcc.gnu.org/onlinedocs/gcc-10.2.0/gcc/Option-Index.html#Option-Index&quot;&gt;期权索引&lt;/a&gt;，以获取GCC期权的索引。</target>
        </trans-unit>
        <trans-unit id="02206115a18ef138f866a5377cf36d2dcdf3f39c" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://gcc.gnu.org/onlinedocs/gcc-9.2.0/gcc/Option-Index.html#Option-Index&quot;&gt;Option Index&lt;/a&gt;, for an index to GCC&amp;rsquo;s options.</source>
          <target state="translated">有关GCC &lt;a href=&quot;https://gcc.gnu.org/onlinedocs/gcc-9.2.0/gcc/Option-Index.html#Option-Index&quot;&gt;期权的索引&lt;/a&gt;，请参阅期权索引。</target>
        </trans-unit>
        <trans-unit id="f92b372afeb33fdcb2e400c22586894ceb4a8913" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://www.akkadia.org/drepper/tls.pdf&quot;&gt;ELF Handling For Thread-Local Storage&lt;/a&gt; for a detailed explanation of the four thread-local storage addressing models, and how the runtime is expected to function.</source>
          <target state="translated">有关四种线程本地存储寻址模型的详细说明，以及运行时的预期功能，请参见&amp;ldquo; &lt;a href=&quot;https://www.akkadia.org/drepper/tls.pdf&quot;&gt;ELF处理线程本地存储&amp;rdquo;&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8e13ff5ec63319e8432be9ffc09617dcfec5efa5" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;instrumentation-options#Instrumentation-Options&quot;&gt;Program Instrumentation Options&lt;/a&gt;.</source>
          <target state="translated">请参阅&lt;a href=&quot;instrumentation-options#Instrumentation-Options&quot;&gt;程序工具选项&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7c45509f6f79a8b5d9dfd4c1f3557aba0312fefe" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;link-options#Link-Options&quot;&gt;Options for Linking&lt;/a&gt;.</source>
          <target state="translated">请参阅&lt;a href=&quot;link-options#Link-Options&quot;&gt;链接选项&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e1d926ae4839442bf4ca475259e4691d6d87ea8e" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;microsoft-windows-function-attributes#Microsoft-Windows-Function-Attributes&quot;&gt;Microsoft Windows Function Attributes&lt;/a&gt;, for discussion of the &lt;code&gt;dllexport&lt;/code&gt; and &lt;code&gt;dllimport&lt;/code&gt; attributes.</source>
          <target state="translated">有关 &lt;code&gt;dllexport&lt;/code&gt; 和 &lt;code&gt;dllimport&lt;/code&gt; 属性的讨论，请参见&lt;a href=&quot;microsoft-windows-function-attributes#Microsoft-Windows-Function-Attributes&quot;&gt;Microsoft Windows Function Attributes&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b9f06eae06e3de3e9542d05510637a475fc262bd" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;objective_002dc-and-objective_002dc_002b_002b-dialect-options#Objective_002dC-and-Objective_002dC_002b_002b-Dialect-Options&quot;&gt;Options Controlling Objective-C and Objective-C++ Dialects&lt;/a&gt;.</source>
          <target state="translated">请参阅&lt;a href=&quot;objective_002dc-and-objective_002dc_002b_002b-dialect-options#Objective_002dC-and-Objective_002dC_002b_002b-Dialect-Options&quot;&gt;控制Objective-C和Objective-C ++方言的选项&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2c63c6c8e460a8cf682e66ddf66e9aa0d0e42598" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;optimize-options#Optimize-Options&quot;&gt;Options that Control Optimization&lt;/a&gt;.</source>
          <target state="translated">请参阅&lt;a href=&quot;optimize-options#Optimize-Options&quot;&gt;控制优化的选项&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="85e23a477ff3ed397006f7d7b24f8677346f373f" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;overall-options#Overall-Options&quot;&gt;Options Controlling the Kind of Output&lt;/a&gt;.</source>
          <target state="translated">请参阅&lt;a href=&quot;overall-options#Overall-Options&quot;&gt;控制输出类型的选项&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e8f74f8e18121481259f5157b4129afe2078cfe1" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;preprocessor-options#Preprocessor-Options&quot;&gt;Options Controlling the Preprocessor&lt;/a&gt;.</source>
          <target state="translated">请参阅&lt;a href=&quot;preprocessor-options#Preprocessor-Options&quot;&gt;控制预处理器的选项&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7419f71237f51267399c64c7786cdedb41924e54" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;rs_002f6000-and-powerpc-options#RS_002f6000-and-PowerPC-Options&quot;&gt;RS/6000 and PowerPC Options&lt;/a&gt;, for more information on whether long calls are necessary.</source>
          <target state="translated">有关是否需要长通话的更多信息，请参见&lt;a href=&quot;rs_002f6000-and-powerpc-options#RS_002f6000-and-PowerPC-Options&quot;&gt;RS / 6000和PowerPC选项&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="be6a4b97c04d8e12e6e473deb1c9a9e10689a66e" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;standards#Standards&quot;&gt;Language Standards Supported by GCC&lt;/a&gt;, for details of freestanding and hosted environments.</source>
          <target state="translated">有关独立和托管环境的详细信息，请参见&lt;a href=&quot;standards#Standards&quot;&gt;GCC支持的语言标准&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ba9a6e9c7aff941ff05b9acae516bf8bb6d040a5" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;submodel-options#Submodel-Options&quot;&gt;Machine-Dependent Options&lt;/a&gt;.</source>
          <target state="translated">请参阅&lt;a href=&quot;submodel-options#Submodel-Options&quot;&gt;机器相关选项&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b2ef31c8cf0906842f80898060f3a9631a0e782b" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;warning-options#Warning-Options&quot;&gt;Options to Request or Suppress Warnings&lt;/a&gt;, for more detail on these and related command-line options.</source>
          <target state="translated">有关这些以及相关命令行选项的更多详细信息，请参见&lt;a href=&quot;warning-options#Warning-Options&quot;&gt;请求或禁止警告的&lt;/a&gt;选项。</target>
        </trans-unit>
        <trans-unit id="434c807b2e25d15f5d415ef83533343f55fbfad1" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;warning-options#Warning-Options&quot;&gt;Options to Request or Suppress Warnings&lt;/a&gt;.</source>
          <target state="translated">请参阅&lt;a href=&quot;warning-options#Warning-Options&quot;&gt;请求或禁止警告的选项&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2d8243a2c0e464492c9d563c4f92c56ae3421bcc" translate="yes" xml:space="preserve">
          <source>See also</source>
          <target state="translated">另见</target>
        </trans-unit>
        <trans-unit id="bda50b9f3b2060976d692aee1d5a5eba1e23d6ef" translate="yes" xml:space="preserve">
          <source>See also the &lt;code&gt;interrupt&lt;/code&gt; function attribute.</source>
          <target state="translated">另请参见 &lt;code&gt;interrupt&lt;/code&gt; 功能属性。</target>
        </trans-unit>
        <trans-unit id="eeb6c38f7196a47f72f632cd6967a92ae3e51f69" translate="yes" xml:space="preserve">
          <source>See also under &lt;a href=&quot;x86-options#x86-Options&quot;&gt;x86 Options&lt;/a&gt; for standard options.</source>
          <target state="translated">另请参阅&lt;a href=&quot;x86-options#x86-Options&quot;&gt;x86选项下&lt;/a&gt;的标准选项。</target>
        </trans-unit>
        <trans-unit id="0ac2d935c64bc2be469f96342d1ea704cfe35909" translate="yes" xml:space="preserve">
          <source>See below for a documentation of the individual parameters controlling inlining and for the defaults of these parameters.</source>
          <target state="translated">关于控制内联的各个参数和这些参数的默认值,请看下面的文档。</target>
        </trans-unit>
        <trans-unit id="2ccea17a61232afe4c2d489d47c0c9f6ac6d3602" translate="yes" xml:space="preserve">
          <source>Select a different format for printing diagnostics. &lt;var&gt;FORMAT&lt;/var&gt; is &amp;lsquo;</source>
          <target state="translated">选择其他格式进行打印诊断。 &lt;var&gt;FORMAT&lt;/var&gt; 为&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="1ce47ca4d6aa3221bdc1ff64eaa11ecfaa3bd85d" translate="yes" xml:space="preserve">
          <source>Select application model &lt;var&gt;app-model&lt;/var&gt;. Valid models are</source>
          <target state="translated">选择应用程序模型 &lt;var&gt;app-model&lt;/var&gt; 。有效模型是</target>
        </trans-unit>
        <trans-unit id="d1e50956bbd1c0ef350e09e3963ba2a16dd200cb" translate="yes" xml:space="preserve">
          <source>Select between generating code that executes in ARM and Thumb states. The default for most configurations is to generate code that executes in ARM state, but the default can be changed by configuring GCC with the</source>
          <target state="translated">选择生成在 ARM 和 Thumb 状态下执行的代码。大多数配置的默认值是生成在 ARM 状态下执行的代码,但可以通过使用</target>
        </trans-unit>
        <trans-unit id="fbbf6e0767f80e0a0e9d40cacab1bf157a107962" translate="yes" xml:space="preserve">
          <source>Select big- or little-endian code. The default is little-endian.</source>
          <target state="translated">选择大字型或小字型代码。默认为小段码。</target>
        </trans-unit>
        <trans-unit id="b9e930cb008c241b5c815eaa75c8616049a76f3c" translate="yes" xml:space="preserve">
          <source>Select fraction of the entry block frequency of executions of basic block in function given basic block needs to have to be considered hot.</source>
          <target state="translated">选择函数中基本块执行频率的进入块的分数,给定的基本块需要有被认为是热点。</target>
        </trans-unit>
        <trans-unit id="5d7f15e7b6cef89c571f030f1f45d8b85b80d1bd" translate="yes" xml:space="preserve">
          <source>Select fraction of the maximal count of repetitions of basic block in program given basic block needs to have to be considered hot (used in non-LTO mode)</source>
          <target state="translated">选择程序中基本块最大重复次数的几分之一,给定基本块必须被视为热块(在非LTO模式下使用)。</target>
        </trans-unit>
        <trans-unit id="36c07223da795b37e11fd68e818cf3c38a43554f" translate="yes" xml:space="preserve">
          <source>Select fraction of the maximal frequency of executions of a basic block in a function to align the basic block.</source>
          <target state="translated">选择函数中基本块的最大执行频率的分数来对齐基本块。</target>
        </trans-unit>
        <trans-unit id="9dc9d80b086954c572282f72064b77416ea46446" translate="yes" xml:space="preserve">
          <source>Select hardware or software floating-point implementations. The default is soft float.</source>
          <target state="translated">选择硬件或软件浮点实现。默认为软浮点。</target>
        </trans-unit>
        <trans-unit id="c7bd7daa13fd958a4357701d8054beaa2dee311b" translate="yes" xml:space="preserve">
          <source>Select software or hardware divide (&lt;code&gt;l.div&lt;/code&gt;, &lt;code&gt;l.divu&lt;/code&gt;) instructions. This default is hardware divide.</source>
          <target state="translated">选择软件或硬件除法（ &lt;code&gt;l.div&lt;/code&gt; ， &lt;code&gt;l.divu&lt;/code&gt; ）指令。该默认值为硬件划分。</target>
        </trans-unit>
        <trans-unit id="eee7b4722a1d3c17eb5906a36d02871593b94d36" translate="yes" xml:space="preserve">
          <source>Select software or hardware for floating point operations. The default is software.</source>
          <target state="translated">选择浮点运算的软件或硬件。默认为软件。</target>
        </trans-unit>
        <trans-unit id="3d76e8a947fb86d59dfbb84b64c271c44cbe3e1d" translate="yes" xml:space="preserve">
          <source>Select software or hardware multiply (&lt;code&gt;l.mul&lt;/code&gt;, &lt;code&gt;l.muli&lt;/code&gt;) instructions. This default is hardware multiply.</source>
          <target state="translated">选择软件或硬件乘法（ &lt;code&gt;l.mul&lt;/code&gt; ， &lt;code&gt;l.muli&lt;/code&gt; ）指令。此默认值为硬件乘法。</target>
        </trans-unit>
        <trans-unit id="4805085c7cdeea70b47df74e1f45155c6818e56a" translate="yes" xml:space="preserve">
          <source>Select the CPU for which code is generated. &lt;var&gt;name&lt;/var&gt; may be one of &amp;lsquo;</source>
          <target state="translated">选择为其生成代码的CPU。 &lt;var&gt;name&lt;/var&gt; 可能是&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="cf37beb2b67c6c34b54f4a1faba9ff153bb95a67" translate="yes" xml:space="preserve">
          <source>Select the FDPIC ABI, which uses 64-bit function descriptors to represent pointers to functions. When the compiler is configured for &lt;code&gt;arm-*-uclinuxfdpiceabi&lt;/code&gt; targets, this option is on by default and implies</source>
          <target state="translated">选择FDPIC ABI，它使用64位函数描述符表示函数的指针。当为 &lt;code&gt;arm-*-uclinuxfdpiceabi&lt;/code&gt; 目标配置了编译器时，此选项默认情况下处于启用状态，并且意味着</target>
        </trans-unit>
        <trans-unit id="5298db8756dae785af6835a7d749dc6e4b0e83e6" translate="yes" xml:space="preserve">
          <source>Select the FDPIC ABI, which uses function descriptors to represent pointers to functions. Without any PIC/PIE-related options, it implies</source>
          <target state="translated">选择FDPIC ABI,它使用函数描述符来表示函数的指针。如果没有任何与PIC/PIE相关的选项,它意味着</target>
        </trans-unit>
        <trans-unit id="b96987a051865812581f43da2e6b76b38be2e5d6" translate="yes" xml:space="preserve">
          <source>Select the MCU to target. This is used to create a C preprocessor symbol based upon the MCU name, converted to upper case and pre- and post-fixed with &amp;lsquo;</source>
          <target state="translated">选择要定位的MCU。这用于根据MCU名称创建C预处理器符号，并将其转换为大写字母，并使用'</target>
        </trans-unit>
        <trans-unit id="34d05e3013dad1f7bde8dbed8f375c5a52258615" translate="yes" xml:space="preserve">
          <source>Select the branch protection features to use. &amp;lsquo;</source>
          <target state="translated">选择要使用的分支保护功能。'</target>
        </trans-unit>
        <trans-unit id="2bf2cc4264a1022ff36bdedefe29b59b658dcdb3" translate="yes" xml:space="preserve">
          <source>Select the floating-point processor. This option can only be used with</source>
          <target state="translated">选择浮点处理器。该选项只能与</target>
        </trans-unit>
        <trans-unit id="980188b0321fba68ce5bd61028cfbc3eaef9c423" translate="yes" xml:space="preserve">
          <source>Select the function scope on which branch protection will be applied. The behavior and permissible arguments are the same as for the command-line option</source>
          <target state="translated">选择要应用分支保护的函数范围。其行为和允许的参数与命令行选项--------相同。</target>
        </trans-unit>
        <trans-unit id="d7cbd726a83eac18e26570056a1fab4af001c14c" translate="yes" xml:space="preserve">
          <source>Select the function scope on which return address signing will be applied. Permissible values are &amp;lsquo;</source>
          <target state="translated">选择将在其上应用返回地址签名的功能范围。允许值为&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="429411e25d795ae5c5e83a75cda8f5a21a98ceca" translate="yes" xml:space="preserve">
          <source>Select the function scope on which return address signing will be applied. The behavior and permissible arguments are the same as for the command-line option</source>
          <target state="translated">选择应用返回地址签名的函数范围。其行为和允许的参数与命令行选项--------相同。</target>
        </trans-unit>
        <trans-unit id="cad7dc1efa3eac596691110965725da6620b1019" translate="yes" xml:space="preserve">
          <source>Select the processor type for which to generate code. Possible values are &amp;lsquo;</source>
          <target state="translated">选择要为其生成代码的处理器类型。可能的值为&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="8f2f44369855722542be7f026c33d280a03e5883" translate="yes" xml:space="preserve">
          <source>Select the type of traceback table. Valid values for &lt;var&gt;traceback_type&lt;/var&gt; are &amp;lsquo;</source>
          <target state="translated">选择回溯表的类型。 &lt;var&gt;traceback_type&lt;/var&gt; 的有效值为'</target>
        </trans-unit>
        <trans-unit id="7e33cf27814e6b940d30b3e1737b7c77cdf2dd07" translate="yes" xml:space="preserve">
          <source>Selects one of the built-in core configurations. Each MeP chip has one or more modules in it; each module has a core CPU and a variety of coprocessors, optional instructions, and peripherals. The &lt;code&gt;MeP-Integrator&lt;/code&gt; tool, not part of GCC, provides these configurations through this option; using this option is the same as using all the corresponding command-line options. The default configuration is &amp;lsquo;</source>
          <target state="translated">选择内置核心配置之一。每个MeP芯片中都有一个或多个模块。每个模块都有一个核心CPU和各种协处理器，可选指令和外围设备。该 &lt;code&gt;MeP-Integrator&lt;/code&gt; 工具，GCC的不一部分，它提供通过这个选项这些配置; 使用此选项与使用所有相应的命令行选项相同。默认配置为</target>
        </trans-unit>
        <trans-unit id="365acdbdf4035eefca1a110d44e0b136c3ce634c" translate="yes" xml:space="preserve">
          <source>Selects the IEEE rounding mode. Other Alpha compilers call this option</source>
          <target state="translated">选择IEEE取整模式。其他的Alpha编译器称这个选项为</target>
        </trans-unit>
        <trans-unit id="994fea32157f20c5fab4acc82606581a7793a57c" translate="yes" xml:space="preserve">
          <source>Selects the type of CPU to be targeted. Currently the only supported type is &amp;lsquo;</source>
          <target state="translated">选择要定位的CPU类型。目前唯一支持的类型是&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="c91d8046baa6bef1bf16fff71b19c1547c4000e2" translate="yes" xml:space="preserve">
          <source>Selects the type of RX CPU to be targeted. Currently three types are supported, the generic &amp;lsquo;</source>
          <target state="translated">选择要定位的RX CPU的类型。目前支持三种类型，通用&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="aaf8d2e6bd32db4a0d11443d63ebb0f809925ed1" translate="yes" xml:space="preserve">
          <source>Selects which section constant data is placed in. &lt;var&gt;name&lt;/var&gt; may be &amp;lsquo;</source>
          <target state="translated">选择放置在哪个节常量数据中。 &lt;var&gt;name&lt;/var&gt; 可以是&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="a326f0729df90ca61ebaebd51aa74199758de422" translate="yes" xml:space="preserve">
          <source>Sending a message in the GNU Objective-C runtime is composed of two separate steps. First, there is a call to the lookup function, &lt;code&gt;objc_msg_lookup ()&lt;/code&gt; (or, in the case of messages to super, &lt;code&gt;objc_msg_lookup_super ()&lt;/code&gt;). This runtime function takes as argument the receiver and the selector of the method to be called; it returns the &lt;code&gt;IMP&lt;/code&gt;, that is a pointer to the function implementing the method. The second step of method invocation consists of casting this pointer function to the appropriate function pointer type, and calling the function pointed to it with the right arguments.</source>
          <target state="translated">在GNU Objective-C运行时中发送消息由两个单独的步骤组成。首先，调用查找函数 &lt;code&gt;objc_msg_lookup ()&lt;/code&gt; （或者，对于发送至super的消息，则 &lt;code&gt;objc_msg_lookup_super ()&lt;/code&gt; ）。该运行时函数将要调用的方法的接收者和选择器作为参数；它返回 &lt;code&gt;IMP&lt;/code&gt; ，它是实现该方法的函数的指针。方法调用的第二步包括将该指针函数转换为适当的函数指针类型，并使用正确的参数调用指向它的函数。</target>
        </trans-unit>
        <trans-unit id="b72ffc8386ea0ea78c13552225aab02558985774" translate="yes" xml:space="preserve">
          <source>Separate as much DWARF debugging information as possible into a separate output file with the extension</source>
          <target state="translated">将尽可能多的DWARF调试信息分离到一个单独的输出文件中,扩展名为 &quot;DWARF&quot;。</target>
        </trans-unit>
        <trans-unit id="a0c8baa5021f22a8ce8d11940201cb0f1ef70ad0" translate="yes" xml:space="preserve">
          <source>Sequential Consistency</source>
          <target state="translated">顺序一致性</target>
        </trans-unit>
        <trans-unit id="db8c4e6b85438b041d4b954b044c9acc5ea86188" translate="yes" xml:space="preserve">
          <source>Set 80387 floating-point precision to 32, 64 or 80 bits. When</source>
          <target state="translated">设置80387浮点精度为32、64或80位。当</target>
        </trans-unit>
        <trans-unit id="6f094549c4101d290a41a69929786b1083499073" translate="yes" xml:space="preserve">
          <source>Set &lt;code&gt;enable_sgpr_dispatch_id&lt;/code&gt; flag.</source>
          <target state="translated">设置 &lt;code&gt;enable_sgpr_dispatch_id&lt;/code&gt; 标志。</target>
        </trans-unit>
        <trans-unit id="e063a374a4f9b63d6fbc54a457afb454bf3dc60b" translate="yes" xml:space="preserve">
          <source>Set &lt;code&gt;enable_sgpr_dispatch_ptr&lt;/code&gt; flag. Always on (required to locate the launch dimensions).</source>
          <target state="translated">设置 &lt;code&gt;enable_sgpr_dispatch_ptr&lt;/code&gt; 标志。始终打开（需要找到发射尺寸）。</target>
        </trans-unit>
        <trans-unit id="4bf6767f6db51278dce4ba489ee759bfe27ca860" translate="yes" xml:space="preserve">
          <source>Set &lt;code&gt;enable_sgpr_flat_scratch_init&lt;/code&gt; flag.</source>
          <target state="translated">设置 &lt;code&gt;enable_sgpr_flat_scratch_init&lt;/code&gt; 标志。</target>
        </trans-unit>
        <trans-unit id="e018c4a2413ef8651cec5e018baeed25a64535ef" translate="yes" xml:space="preserve">
          <source>Set &lt;code&gt;enable_sgpr_grid_workgroup_count_x&lt;/code&gt; flag. Always on (required to use OpenACC/OpenMP).</source>
          <target state="translated">设置 &lt;code&gt;enable_sgpr_grid_workgroup_count_x&lt;/code&gt; 标志。常亮（使用OpenACC / OpenMP时必须）。</target>
        </trans-unit>
        <trans-unit id="8a3463fca2684949d657154ef95e5116320e933b" translate="yes" xml:space="preserve">
          <source>Set &lt;code&gt;enable_sgpr_grid_workgroup_count_y&lt;/code&gt; flag.</source>
          <target state="translated">设置 &lt;code&gt;enable_sgpr_grid_workgroup_count_y&lt;/code&gt; 标志。</target>
        </trans-unit>
        <trans-unit id="9121d61d52bfdfdb7d41c445246f7a36b8486d92" translate="yes" xml:space="preserve">
          <source>Set &lt;code&gt;enable_sgpr_grid_workgroup_count_z&lt;/code&gt; flag.</source>
          <target state="translated">设置 &lt;code&gt;enable_sgpr_grid_workgroup_count_z&lt;/code&gt; 标志。</target>
        </trans-unit>
        <trans-unit id="47dd861ea509bc2bed29c0b97e6909d4e6ec3ffa" translate="yes" xml:space="preserve">
          <source>Set &lt;code&gt;enable_sgpr_kernarg_segment_ptr&lt;/code&gt; flag. Always on (required to locate the kernel arguments, &quot;kernargs&quot;).</source>
          <target state="translated">设置 &lt;code&gt;enable_sgpr_kernarg_segment_ptr&lt;/code&gt; 标志。始终打开（需要找到内核参数&amp;ldquo; kernargs&amp;rdquo;）。</target>
        </trans-unit>
        <trans-unit id="cd7c041f21c0b317df592ef375a2d79306809a19" translate="yes" xml:space="preserve">
          <source>Set &lt;code&gt;enable_sgpr_private_segment_buffer&lt;/code&gt; flag. Always on (required to locate the stack).</source>
          <target state="translated">设置 &lt;code&gt;enable_sgpr_private_segment_buffer&lt;/code&gt; 标志。始终亮着（需要找到堆栈）。</target>
        </trans-unit>
        <trans-unit id="6cb3983fd9748551d692e967fc5d0571ccaac036" translate="yes" xml:space="preserve">
          <source>Set &lt;code&gt;enable_sgpr_private_segment_size&lt;/code&gt; flag.</source>
          <target state="translated">设置 &lt;code&gt;enable_sgpr_private_segment_size&lt;/code&gt; 标志。</target>
        </trans-unit>
        <trans-unit id="e321e30fee9a76386f96bea4dafdd22df3c58297" translate="yes" xml:space="preserve">
          <source>Set &lt;code&gt;enable_sgpr_private_segment_wave_byte_offset&lt;/code&gt; flag. Always on (required to locate the stack).</source>
          <target state="translated">设置 &lt;code&gt;enable_sgpr_private_segment_wave_byte_offset&lt;/code&gt; 标志。始终亮着（需要找到堆栈）。</target>
        </trans-unit>
        <trans-unit id="318a046da8f702fe1ef7095bb61e01886dd9a552" translate="yes" xml:space="preserve">
          <source>Set &lt;code&gt;enable_sgpr_queue_ptr&lt;/code&gt; flag. Always on (required to convert address spaces).</source>
          <target state="translated">设置 &lt;code&gt;enable_sgpr_queue_ptr&lt;/code&gt; 标志。常亮（转换地址空间必需）。</target>
        </trans-unit>
        <trans-unit id="f2dea393dcbc34f57c9589ed5c20be98ac3c0bd2" translate="yes" xml:space="preserve">
          <source>Set &lt;code&gt;enable_sgpr_workgroup_id_x&lt;/code&gt; flag.</source>
          <target state="translated">设置 &lt;code&gt;enable_sgpr_workgroup_id_x&lt;/code&gt; 标志。</target>
        </trans-unit>
        <trans-unit id="922f6db77c2bc32594aaaea2ec14d4d827c574c4" translate="yes" xml:space="preserve">
          <source>Set &lt;code&gt;enable_sgpr_workgroup_id_y&lt;/code&gt; flag.</source>
          <target state="translated">设置 &lt;code&gt;enable_sgpr_workgroup_id_y&lt;/code&gt; 标志。</target>
        </trans-unit>
        <trans-unit id="14e0b73f99741e4ae34f7adcad5960d6204fcfd0" translate="yes" xml:space="preserve">
          <source>Set &lt;code&gt;enable_sgpr_workgroup_id_z&lt;/code&gt; flag.</source>
          <target state="translated">设置 &lt;code&gt;enable_sgpr_workgroup_id_z&lt;/code&gt; 标志。</target>
        </trans-unit>
        <trans-unit id="31293ecfe585105b73e60e083df6e0122cc62953" translate="yes" xml:space="preserve">
          <source>Set &lt;code&gt;enable_sgpr_workgroup_info&lt;/code&gt; flag.</source>
          <target state="translated">设置 &lt;code&gt;enable_sgpr_workgroup_info&lt;/code&gt; 标志。</target>
        </trans-unit>
        <trans-unit id="380057a6f93584a7133cb8fb90b07c8a8cc27fc3" translate="yes" xml:space="preserve">
          <source>Set &lt;code&gt;enable_vgpr_workitem_id&lt;/code&gt; parameter. Always on (can&amp;rsquo;t be disabled).</source>
          <target state="translated">设置 &lt;code&gt;enable_vgpr_workitem_id&lt;/code&gt; 参数。始终开启（无法禁用）。</target>
        </trans-unit>
        <trans-unit id="2399bb34bb60e0afafdf365068c0d7d3cf7ce8fd" translate="yes" xml:space="preserve">
          <source>Set &lt;code&gt;enable_vgpr_workitem_id&lt;/code&gt; parameter. Always on (required to enable vectorization.)</source>
          <target state="translated">设置 &lt;code&gt;enable_vgpr_workitem_id&lt;/code&gt; 参数。始终打开（启用矢量化是必需的。）</target>
        </trans-unit>
        <trans-unit id="82aa777ac54dda2b6c22bad4293654db9c8f37c4" translate="yes" xml:space="preserve">
          <source>Set &lt;code&gt;enable_vgpr_workitem_id&lt;/code&gt; parameter. Always on (required to use OpenACC/OpenMP).</source>
          <target state="translated">设置 &lt;code&gt;enable_vgpr_workitem_id&lt;/code&gt; 参数。常亮（使用OpenACC / OpenMP时必须）。</target>
        </trans-unit>
        <trans-unit id="1105231c54783be6055a3890df5dbc54a64a890f" translate="yes" xml:space="preserve">
          <source>Set IACC0H to &lt;var&gt;x&lt;/var&gt; if &lt;var&gt;reg&lt;/var&gt; is 0 and IACC0L to &lt;var&gt;x&lt;/var&gt; if &lt;var&gt;reg&lt;/var&gt; is 1. Other values of &lt;var&gt;reg&lt;/var&gt; are rejected as invalid.</source>
          <target state="translated">设置IACC0H到 &lt;var&gt;x&lt;/var&gt; ，如果 &lt;var&gt;reg&lt;/var&gt; 是0和IACC0L到 &lt;var&gt;x&lt;/var&gt; ，如果 &lt;var&gt;reg&lt;/var&gt; 为1的其他值 &lt;var&gt;reg&lt;/var&gt; 被拒绝为无效。</target>
        </trans-unit>
        <trans-unit id="ee53a79e935585433b8493e61ec418d3cf4dbe69" translate="yes" xml:space="preserve">
          <source>Set all subsequent functions to have the &lt;code&gt;long_call&lt;/code&gt; attribute.</source>
          <target state="translated">将所有后续函数设置为具有 &lt;code&gt;long_call&lt;/code&gt; 属性。</target>
        </trans-unit>
        <trans-unit id="d60d9bf9dcc9adc753b1eb2a43c3660a75d81801" translate="yes" xml:space="preserve">
          <source>Set all subsequent functions to have the &lt;code&gt;short_call&lt;/code&gt; attribute.</source>
          <target state="translated">将所有后续函数设置为具有 &lt;code&gt;short_call&lt;/code&gt; 属性。</target>
        </trans-unit>
        <trans-unit id="97836a72f6504940ee575ca631515c1b5c65d1b7" translate="yes" xml:space="preserve">
          <source>Set architecture type or tuning for &lt;var&gt;gpu&lt;/var&gt;. Supported values for &lt;var&gt;gpu&lt;/var&gt; are</source>
          <target state="translated">设置架构类型或为 &lt;var&gt;gpu&lt;/var&gt; 进行调整。为支持的值 &lt;var&gt;gpu&lt;/var&gt; 是</target>
        </trans-unit>
        <trans-unit id="0c9ead2e0e9ad50453ecaadabc1a54be0e28b16c" translate="yes" xml:space="preserve">
          <source>Set architecture type, register usage, and instruction scheduling parameters for &lt;var&gt;cpu&lt;/var&gt;. There are also shortcut alias options available for backward compatibility and convenience. Supported values for &lt;var&gt;cpu&lt;/var&gt; are</source>
          <target state="translated">设置 &lt;var&gt;cpu&lt;/var&gt; 的体系结构类型，寄存器使用率和指令调度参数。还有一些快捷方式别名选项可用于向后兼容和方便。为支持的值 &lt;var&gt;cpu&lt;/var&gt; 是</target>
        </trans-unit>
        <trans-unit id="64a7071b5e71b31be5eb05dbe2fa3aa85d88985c" translate="yes" xml:space="preserve">
          <source>Set architecture type, register usage, and instruction scheduling parameters for machine type &lt;var&gt;cpu_type&lt;/var&gt;. Supported values for &lt;var&gt;cpu_type&lt;/var&gt; are &amp;lsquo;</source>
          <target state="translated">设置机器类型 &lt;var&gt;cpu_type&lt;/var&gt; 的体系结构类型，寄存器使用率和指令调度参数。支持的 &lt;var&gt;cpu_type&lt;/var&gt; 值为'</target>
        </trans-unit>
        <trans-unit id="2d8d13e552ebd3846286db451c6c5b431512dad9" translate="yes" xml:space="preserve">
          <source>Set instruction scheduling parameters for &lt;var&gt;cpu&lt;/var&gt;, overriding any implied by</source>
          <target state="translated">设置 &lt;var&gt;cpu&lt;/var&gt; 的指令调度参数，覆盖任何由...隐含的参数</target>
        </trans-unit>
        <trans-unit id="2715a46db2794f249b7a95e35f8fbd08b56ac85b" translate="yes" xml:space="preserve">
          <source>Set name of __fentry__ symbol called at function entry for -pg -mfentry functions.</source>
          <target state="translated">设置在-pg -mfentry函数的函数入口处调用的__fentry__符号的名称。</target>
        </trans-unit>
        <trans-unit id="516912ad28df352c9af39b170d45bd0f779026e3" translate="yes" xml:space="preserve">
          <source>Set name of section to record -mrecord-mcount calls (default __mcount_loc).</source>
          <target state="translated">设置要记录-mrecord-mcount调用的部分名称(默认为__mcount_loc)。</target>
        </trans-unit>
        <trans-unit id="5b5c27a6d88589e59ef75449f5dd3ac676e7651f" translate="yes" xml:space="preserve">
          <source>Set only the instruction scheduling parameters for machine type &lt;var&gt;cpu_type&lt;/var&gt;. The instruction set is not changed.</source>
          <target state="translated">仅为机器类型 &lt;var&gt;cpu_type&lt;/var&gt; 设置指令调度参数。指令集不变。</target>
        </trans-unit>
        <trans-unit id="96d85595444fd17f8fc2c443c3589b270f0ca169" translate="yes" xml:space="preserve">
          <source>Set probability threshold for unaligning branches. When tuning for &amp;lsquo;</source>
          <target state="translated">设置分支未对齐的概率阈值。调优时</target>
        </trans-unit>
        <trans-unit id="0ea21e9156c401cfb3bdea0993d6be3967bad591" translate="yes" xml:space="preserve">
          <source>Set the branch costs for conditional branch instructions to &lt;var&gt;cost&lt;/var&gt;. Reasonable values for &lt;var&gt;cost&lt;/var&gt; are small, non-negative integers. The default branch cost is 0.</source>
          <target state="translated">将有条件分支指令的分支成本设置为 &lt;var&gt;cost&lt;/var&gt; 。合理的 &lt;var&gt;cost&lt;/var&gt; 值是小的非负整数。默认分支成本为0。</target>
        </trans-unit>
        <trans-unit id="0f86bf8c6795fb942b4cb5cea169bd8c5df0318b" translate="yes" xml:space="preserve">
          <source>Set the branch costs to roughly &lt;code&gt;n&lt;/code&gt; instructions. The default is 1.</source>
          <target state="translated">将分支成本设置为大约 &lt;code&gt;n&lt;/code&gt; 条指令。预设值为1。</target>
        </trans-unit>
        <trans-unit id="ff18182da94c7d99a8b4c2f28568b2d883024732" translate="yes" xml:space="preserve">
          <source>Set the code model to one of</source>
          <target state="translated">将代码模型设置为下列之一</target>
        </trans-unit>
        <trans-unit id="78eeaac8789a3827df0a0d0ed12693670bedcea6" translate="yes" xml:space="preserve">
          <source>Set the cost of branches to roughly &lt;var&gt;n&lt;/var&gt; instructions.</source>
          <target state="translated">将分支的成本设置为大约 &lt;var&gt;n&lt;/var&gt; 条指令。</target>
        </trans-unit>
        <trans-unit id="d6c018249bccc05c5ac1fc5bfd4c0431b5934b35" translate="yes" xml:space="preserve">
          <source>Set the cost of branches to roughly &lt;var&gt;num&lt;/var&gt; &amp;ldquo;simple&amp;rdquo; instructions. This cost is only a heuristic and is not guaranteed to produce consistent results across releases.</source>
          <target state="translated">将分支成本设置为大约 &lt;var&gt;num&lt;/var&gt; 个 &amp;ldquo;简单&amp;rdquo;指令。此成本仅是一种试探，不能保证在各个发行版中都能产生一致的结果。</target>
        </trans-unit>
        <trans-unit id="52c26e276ceb37a9e0ef6641f16eb200d20fd608" translate="yes" xml:space="preserve">
          <source>Set the cost of branches to roughly &lt;var&gt;num&lt;/var&gt; &amp;ldquo;simple&amp;rdquo; instructions. This cost is only a heuristic and is not guaranteed to produce consistent results across releases. A zero cost redundantly selects the default, which is based on the</source>
          <target state="translated">将分支成本设置为大约 &lt;var&gt;num&lt;/var&gt; 个 &amp;ldquo;简单&amp;rdquo;指令。此成本仅是一种试探，不能保证在各个发行版中都能产生一致的结果。零成本会冗余地选择默认值，该默认值基于</target>
        </trans-unit>
        <trans-unit id="5a0841b373cdd65fccf05bdefa98b9359151f994" translate="yes" xml:space="preserve">
          <source>Set the cost to assume for a multiply insn.</source>
          <target state="translated">设置成本假设为乘法钤。</target>
        </trans-unit>
        <trans-unit id="9b5cc228ada7a61f910769476607cbb994fb6862" translate="yes" xml:space="preserve">
          <source>Set the default ELF image symbol visibility to the specified option&amp;mdash;all symbols are marked with this unless overridden within the code. Using this feature can very substantially improve linking and load times of shared object libraries, produce more optimized code, provide near-perfect API export and prevent symbol clashes. It is &lt;strong&gt;strongly&lt;/strong&gt; recommended that you use this in any shared objects you distribute.</source>
          <target state="translated">将默认的ELF图像符号可见性设置为指定的选项-除非代码中覆盖了所有符号，否则所有符号都以此标记。使用此功能可以极大地改善共享库的链接和加载时间，生成更优化的代码，提供接近完美的API导出并防止符号冲突。这是&lt;strong&gt;强烈&lt;/strong&gt;建议您在您分发的任何共享对象使用。</target>
        </trans-unit>
        <trans-unit id="ea1605288d268d2678207ef0c71d1f4525e63f8a" translate="yes" xml:space="preserve">
          <source>Set the default instance variable visibility to the specified option so that instance variables declared outside the scope of any access modifier directives default to the specified visibility.</source>
          <target state="translated">将默认的实例变量可见性设置为指定的选项,这样在任何访问修改器指令范围外声明的实例变量就会默认为指定的可见性。</target>
        </trans-unit>
        <trans-unit id="2a86ab7ec489c5eb483da27838bf7e2eb9274102" translate="yes" xml:space="preserve">
          <source>Set the default scalar storage order of structures and unions to the specified endianness. The accepted values are &amp;lsquo;</source>
          <target state="translated">将结构和联合的默认标量存储顺序设置为指定的字节序。可接受的值为&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="f3dbc51abbb4a58e848b6c7fade12f6fc892b4eb" translate="yes" xml:space="preserve">
          <source>Set the default size of pointers. Possible options for &lt;var&gt;size&lt;/var&gt; are &amp;lsquo;</source>
          <target state="translated">设置指针的默认大小。 &lt;var&gt;size&lt;/var&gt; 可能选项是'</target>
        </trans-unit>
        <trans-unit id="62f2e2f7b01631d9a6515e5e155db801fef2b550" translate="yes" xml:space="preserve">
          <source>Set the directory to search for plugins that are passed by</source>
          <target state="translated">设置搜索目录,以搜索由</target>
        </trans-unit>
        <trans-unit id="344c767b23b4250954654e45ee61197856443517" translate="yes" xml:space="preserve">
          <source>Set the directory to search for the profile data files in to &lt;var&gt;path&lt;/var&gt;. This option affects only the profile data generated by</source>
          <target state="translated">设置目录以在 &lt;var&gt;path&lt;/var&gt; 中搜索概要文件数据文件。此选项仅影响由...生成的配置文件数据</target>
        </trans-unit>
        <trans-unit id="c88a9680382a42696b15d1fef7d2ae2621b8c420" translate="yes" xml:space="preserve">
          <source>Set the distance between tab stops. This helps the preprocessor report correct column numbers in warnings or errors, even if tabs appear on the line. If the value is less than 1 or greater than 100, the option is ignored. The default is 8.</source>
          <target state="translated">设置制表符停止符之间的距离。这有助于预处理器在警告或错误中报告正确的列号,即使行上出现制表符。如果该值小于1或大于100,该选项将被忽略。默认值是8。</target>
        </trans-unit>
        <trans-unit id="1d08f91e70e865b37a7c6408c62bba8aaf4795be" translate="yes" xml:space="preserve">
          <source>Set the division strategy to be used for integer division operations. &lt;var&gt;strategy&lt;/var&gt; can be one of:</source>
          <target state="translated">设置用于整数除法运算的除法策略。 &lt;var&gt;strategy&lt;/var&gt; 可以是以下之一：</target>
        </trans-unit>
        <trans-unit id="39cb7b5430317218ec8ac64bf16cfa98e3b257be" translate="yes" xml:space="preserve">
          <source>Set the execution character set, used for string and character constants. The default is UTF-8. &lt;var&gt;charset&lt;/var&gt; can be any encoding supported by the system&amp;rsquo;s &lt;code&gt;iconv&lt;/code&gt; library routine.</source>
          <target state="translated">设置执行字符集，用于字符串和字符常量。默认值为UTF-8。 &lt;var&gt;charset&lt;/var&gt; 可以是系统的 &lt;code&gt;iconv&lt;/code&gt; 库例程支持的任何编码。</target>
        </trans-unit>
        <trans-unit id="51202b29bb6ce9f52c2e1294c6b529a40bcf359f" translate="yes" xml:space="preserve">
          <source>Set the full 64-bit value of IACC0 to &lt;var&gt;x&lt;/var&gt;. The &lt;var&gt;reg&lt;/var&gt; argument is reserved for future expansion and must be 0.</source>
          <target state="translated">将IACC0的完整64位值设置为 &lt;var&gt;x&lt;/var&gt; 。该 &lt;var&gt;reg&lt;/var&gt; 参数保留为将来扩展，并且必须是0。</target>
        </trans-unit>
        <trans-unit id="b310b7c6a38563bb5ac12d36d2b4fae1244b8499" translate="yes" xml:space="preserve">
          <source>Set the input character set, used for translation from the character set of the input file to the source character set used by GCC. If the locale does not specify, or GCC cannot get this information from the locale, the default is UTF-8. This can be overridden by either the locale or this command-line option. Currently the command-line option takes precedence if there&amp;rsquo;s a conflict. &lt;var&gt;charset&lt;/var&gt; can be any encoding supported by the system&amp;rsquo;s &lt;code&gt;iconv&lt;/code&gt; library routine.</source>
          <target state="translated">设置输入字符集，用于将输入文件的字符集转换为GCC使用的源字符集。如果未指定语言环境，或者GCC无法从语言环境获取此信息，则默认值为UTF-8。可以通过语言环境或此命令行选项来覆盖它。当前，如果有冲突，则命令行选项优先。 &lt;var&gt;charset&lt;/var&gt; 可以是系统的 &lt;code&gt;iconv&lt;/code&gt; 库例程支持的任何编码。</target>
        </trans-unit>
        <trans-unit id="652927b7d54857ab31904ba55c5609207b150484" translate="yes" xml:space="preserve">
          <source>Set the instruction scheduling parameters for machine type &lt;var&gt;cpu_type&lt;/var&gt;, but do not set the architecture type or register usage, as</source>
          <target state="translated">为机器类型 &lt;var&gt;cpu_type&lt;/var&gt; 设置指令调度参数，但不要设置体系结构类型或寄存器使用率，例如</target>
        </trans-unit>
        <trans-unit id="11f00614fec90c6021e141511f6f276e35bf0cb8" translate="yes" xml:space="preserve">
          <source>Set the instruction scheduling parameters for machine type &lt;var&gt;cpu_type&lt;/var&gt;, but do not set the instruction set or register set that the option</source>
          <target state="translated">为机器类型 &lt;var&gt;cpu_type&lt;/var&gt; 设置指令调度参数，但不要设置该选项的指令集或寄存器集</target>
        </trans-unit>
        <trans-unit id="50be1da58f5d233c63ebfa9b37341f9609727916" translate="yes" xml:space="preserve">
          <source>Set the instruction set and instruction scheduling parameters for machine type &lt;var&gt;cpu_type&lt;/var&gt;. You can specify either the &amp;lsquo;</source>
          <target state="translated">为机器类型 &lt;var&gt;cpu_type&lt;/var&gt; 设置指令集和指令调度参数。您可以指定&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="3637c6b1faf044bd713cef9c135202d8f375fec1" translate="yes" xml:space="preserve">
          <source>Set the instruction set, register set, and instruction scheduling parameters for array element type &lt;var&gt;ae_type&lt;/var&gt;. Supported values for &lt;var&gt;ae_type&lt;/var&gt; are &amp;lsquo;</source>
          <target state="translated">为数组元素类型 &lt;var&gt;ae_type&lt;/var&gt; 设置指令集，寄存器集和指令调度参数。支持的 &lt;var&gt;ae_type&lt;/var&gt; 值为 '</target>
        </trans-unit>
        <trans-unit id="2130c0c09cc91a0c33f4d19aae8686d805e90ec1" translate="yes" xml:space="preserve">
          <source>Set the instruction set, register set, and instruction scheduling parameters for machine type &lt;var&gt;cpu_type&lt;/var&gt;. Supported values for &lt;var&gt;cpu_type&lt;/var&gt; are &amp;lsquo;</source>
          <target state="translated">设置机器类型 &lt;var&gt;cpu_type&lt;/var&gt; 的指令集，寄存器集和指令调度参数。支持的 &lt;var&gt;cpu_type&lt;/var&gt; 值为'</target>
        </trans-unit>
        <trans-unit id="500d192eb62847936b3fcadaa2c3190ec61e5693" translate="yes" xml:space="preserve">
          <source>Set the internal debug counter lower and upper bound. &lt;var&gt;counter-value-list&lt;/var&gt; is a comma-separated list of &lt;var&gt;name&lt;/var&gt;:&lt;var&gt;lower_bound1&lt;/var&gt;-&lt;var&gt;upper_bound1&lt;/var&gt; [:&lt;var&gt;lower_bound2&lt;/var&gt;-&lt;var&gt;upper_bound2&lt;/var&gt;...] tuples which sets the name of the counter and list of closed intervals. The &lt;var&gt;lower_bound&lt;/var&gt; is optional and is zero initialized if not set. For example, with</source>
          <target state="translated">设置内部调试计数器的上限和下限。 &lt;var&gt;counter-value-list&lt;/var&gt; 是逗号分隔的 &lt;var&gt;name&lt;/var&gt; 列表： &lt;var&gt;lower_bound1&lt;/var&gt; - &lt;var&gt;upper_bound1&lt;/var&gt; [： &lt;var&gt;lower_bound2&lt;/var&gt; - &lt;var&gt;upper_bound2&lt;/var&gt; ...]元组，它设置计数器的名称和关闭间隔的列表。该 &lt;var&gt;lower_bound&lt;/var&gt; 是可选的，如果没有设置初始化为零。例如，</target>
        </trans-unit>
        <trans-unit id="4c79cc68a1f91929b96557468c86dfcad2cce72f" translate="yes" xml:space="preserve">
          <source>Set the internal debug counter lower and upper bound. &lt;var&gt;counter-value-list&lt;/var&gt; is a comma-separated list of &lt;var&gt;name&lt;/var&gt;:&lt;var&gt;lower_bound&lt;/var&gt;:&lt;var&gt;upper_bound&lt;/var&gt; tuples which sets the lower and the upper bound of each debug counter &lt;var&gt;name&lt;/var&gt;. The &lt;var&gt;lower_bound&lt;/var&gt; is optional and is zero initialized if not set. All debug counters have the initial upper bound of &lt;code&gt;UINT_MAX&lt;/code&gt;; thus &lt;code&gt;dbg_cnt&lt;/code&gt; returns true always unless the upper bound is set by this option. For example, with</source>
          <target state="translated">设置内部调试计数器的上限和下限。 &lt;var&gt;counter-value-list&lt;/var&gt; 是用逗号分隔的 &lt;var&gt;name&lt;/var&gt; 列表： &lt;var&gt;lower_bound&lt;/var&gt; ： &lt;var&gt;upper_bound&lt;/var&gt; 元组，它设置每个调试计数器 &lt;var&gt;name&lt;/var&gt; 的下限和上限。该 &lt;var&gt;lower_bound&lt;/var&gt; 是可选的，如果没有设置初始化为零。所有调试计数器的初始上限为 &lt;code&gt;UINT_MAX&lt;/code&gt; ;因此，除非此选项设置了上限，否则 &lt;code&gt;dbg_cnt&lt;/code&gt; 始终返回true。例如，</target>
        </trans-unit>
        <trans-unit id="6a2e63898a05f461ab31f6f83dad590dc851ec3a" translate="yes" xml:space="preserve">
          <source>Set the list of functions that are excluded from instrumentation (see the description of</source>
          <target state="translated">设置被排除在仪器仪表之外的函数列表(请参见</target>
        </trans-unit>
        <trans-unit id="42e134132bf53619895cfe9c4d4c0a63e9ff7d7c" translate="yes" xml:space="preserve">
          <source>Set the maximum amount for a single stack increment operation. Large values can increase the speed of programs that contain functions that need a large amount of stack space, but they can also trigger a segmentation fault if the stack is extended too much. The default value is 0x1000.</source>
          <target state="translated">设置单次堆栈增量操作的最大数量。大值可以提高包含需要大量堆栈空间的函数的程序的速度,但如果堆栈扩展过大,也会触发分段故障。默认值为0x1000。</target>
        </trans-unit>
        <trans-unit id="c1ec8e089c1ac627e7990475e62c40b0d43e58d3" translate="yes" xml:space="preserve">
          <source>Set the maximum depth of the nested #include. The default is 200.</source>
          <target state="translated">设置嵌套#include的最大深度。默认为200。</target>
        </trans-unit>
        <trans-unit id="d4f670c7bd6ab86529aad1732ecfea40af410c2b" translate="yes" xml:space="preserve">
          <source>Set the maximum instantiation depth for template classes to &lt;var&gt;n&lt;/var&gt;. A limit on the template instantiation depth is needed to detect endless recursions during template class instantiation. ANSI/ISO C++ conforming programs must not rely on a maximum depth greater than 17 (changed to 1024 in C++11). The default value is 900, as the compiler can run out of stack space before hitting 1024 in some situations.</source>
          <target state="translated">将模板类的最大实例化深度设置为 &lt;var&gt;n&lt;/var&gt; 。模板实例化深度需要一个限制，以检测模板类实例化期间的无穷递归。符合ANSI / ISO C ++的程序不得依赖大于17的最大深度（在C ++ 11中更改为1024）。默认值为900，因为在某些情况下编译器在达到1024之前可能会耗尽堆栈空间。</target>
        </trans-unit>
        <trans-unit id="9f75c9fef6ead4d480bb957cf3712c8ad825156f" translate="yes" xml:space="preserve">
          <source>Set the maximum level of nested evaluation depth for C++11 constexpr functions that will be cached to &lt;var&gt;n&lt;/var&gt;. This is a heuristic that trades off compilation speed (when the cache avoids repeated calculations) against memory consumption (when the cache grows very large from highly recursive evaluations). The default is 8. Very few users are likely to want to adjust it, but if your code does heavy constexpr calculations you might want to experiment to find which value works best for you.</source>
          <target state="translated">设置将缓存到 &lt;var&gt;n&lt;/var&gt; 的C ++ 11 constexpr函数的嵌套评估深度的最大级别。这是一种启发式方法，需要权衡编译速度（当高速缓存避免重复计算时）与内存消耗（当高速缓存因高度递归的评估而变得很大时）之间的折中。默认值为8。极少数用户可能希望对其进行调整，但是如果您的代码进行大量的constexpr计算，则可能需要尝试找出最适合您的值。</target>
        </trans-unit>
        <trans-unit id="f0c34cb3bf3e4cbb7843f5530d7dab6ff427a4a8" translate="yes" xml:space="preserve">
          <source>Set the maximum nested evaluation depth for C++11 constexpr functions to &lt;var&gt;n&lt;/var&gt;. A limit is needed to detect endless recursion during constant expression evaluation. The minimum specified by the standard is 512.</source>
          <target state="translated">将C ++ 11 constexpr函数的最大嵌套评估深度设置为 &lt;var&gt;n&lt;/var&gt; 。在常量表达式评估期间，需要一个极限来检测无限递归。该标准指定的最小值为512。</target>
        </trans-unit>
        <trans-unit id="b1da5be9c3391cd736caa92a61985889a98f2b05" translate="yes" xml:space="preserve">
          <source>Set the maximum number of existing candidates that are considered when seeking a basis for a new straight-line strength reduction candidate.</source>
          <target state="translated">设置在寻求新的直线减员候选者基础时,考虑现有候选者的最大数量。</target>
        </trans-unit>
        <trans-unit id="cfe13945b74f8afda07bf3e9441d08f927ed94f9" translate="yes" xml:space="preserve">
          <source>Set the maximum number of instructions executed in parallel in reassociated tree. This parameter overrides target dependent heuristics used by default if has non zero value.</source>
          <target state="translated">设置重关联树中并行执行的最大指令数。如果该值不为零,该参数将覆盖默认使用的目标依赖性启发式算法。</target>
        </trans-unit>
        <trans-unit id="ad1d48dcf4aec833ed476a8c06e702825b1456b2" translate="yes" xml:space="preserve">
          <source>Set the maximum number of iterations for a loop in C++14 constexpr functions to &lt;var&gt;n&lt;/var&gt;. A limit is needed to detect infinite loops during constant expression evaluation. The default is 262144 (1&amp;lt;&amp;lt;18).</source>
          <target state="translated">将C ++ 14 constexpr函数中循环的最大迭代次数设置为 &lt;var&gt;n&lt;/var&gt; 。在常量表达式求值期间检测无限循环需要一个限制。默认值为262144（1 &amp;lt;&amp;lt; 18）。</target>
        </trans-unit>
        <trans-unit id="b10b01f3627d31eea1b8ecfa0a7d6381d1c99dfd" translate="yes" xml:space="preserve">
          <source>Set the maximum number of operations during a single constexpr evaluation. Even when number of iterations of a single loop is limited with the above limit, if there are several nested loops and each of them has many iterations but still smaller than the above limit, or if in a body of some loop or even outside of a loop too many expressions need to be evaluated, the resulting constexpr evaluation might take too long. The default is 33554432 (1&amp;lt;&amp;lt;25).</source>
          <target state="translated">设置一次constexpr评估期间的最大操作数。即使单个循环的迭代次数受到上述限制，即使有多个嵌套循环且每个嵌套循环都具有许多迭代但仍小于上述限制，或者处于某个循环的主体中，甚至位于循环需要评估太多的表达式，结果constexpr评估可能花费太长时间。默认值为33554432（1 &amp;lt;&amp;lt; 25）。</target>
        </trans-unit>
        <trans-unit id="2d5dabb85d70dc403cca1e25a382c4592a347c35" translate="yes" xml:space="preserve">
          <source>Set the maximum number of template instantiation notes for a single warning or error to &lt;var&gt;n&lt;/var&gt;. The default value is 10.</source>
          <target state="translated">将单个警告或错误的模板实例化注释的最大数量设置为 &lt;var&gt;n&lt;/var&gt; 。预设值为10。</target>
        </trans-unit>
        <trans-unit id="47ea880c254638d27a922dbb4046bb1a923dc25e" translate="yes" xml:space="preserve">
          <source>Set the memory model in force on the processor to one of</source>
          <target state="translated">将处理器上有效的内存模型设置为以下之一</target>
        </trans-unit>
        <trans-unit id="d8ff5750579f8eb1fad99e9d99cd9274a1f87812" translate="yes" xml:space="preserve">
          <source>Set the merge weights of the &lt;var&gt;directory1&lt;/var&gt; and &lt;var&gt;directory2&lt;/var&gt;, respectively. The default weights are 1 for both.</source>
          <target state="translated">分别设置 &lt;var&gt;directory1&lt;/var&gt; 和 &lt;var&gt;directory2&lt;/var&gt; 的合并权重。两者的默认权重均为1。</target>
        </trans-unit>
        <trans-unit id="e2cd2322187a5ecdca2024a2990e890bcbbf394b" translate="yes" xml:space="preserve">
          <source>Set the name of the library function used for 32-bit signed division to &lt;var&gt;name&lt;/var&gt;. This only affects the name used in the &amp;lsquo;</source>
          <target state="translated">将用于32位有符号除法的库函数的名称设置为 &lt;var&gt;name&lt;/var&gt; 。这只会影响&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="eaddd89d6c99265ee29e5fc045d536ee700140e2" translate="yes" xml:space="preserve">
          <source>Set the offset between the top of the stack and the stack pointer. E.g., a value of 8 means that the eight bytes in the range &lt;code&gt;sp+0&amp;hellip;sp+7&lt;/code&gt; can be used by leaf functions without stack allocation. Values other than &amp;lsquo;</source>
          <target state="translated">设置堆栈顶部和堆栈指针之间的偏移量。例如，值8表示叶函数可以使用 &lt;code&gt;sp+0&amp;hellip;sp+7&lt;/code&gt; 范围内的八个字节，而无需堆栈分配。除'以外的其他值</target>
        </trans-unit>
        <trans-unit id="adf223dfbaa5deae634aec76651716f604f84bf4" translate="yes" xml:space="preserve">
          <source>Set the output profile directory. Default output directory name is &lt;var&gt;merged_profile&lt;/var&gt;.</source>
          <target state="translated">设置输出配置文件目录。默认输出目录名称为 &lt;var&gt;merged_profile&lt;/var&gt; 。</target>
        </trans-unit>
        <trans-unit id="6e4acbb536ee226dd76cd7df2c462f1fe127b3f4" translate="yes" xml:space="preserve">
          <source>Set the output profile directory. Default output name is &lt;var&gt;rewrite_profile&lt;/var&gt;.</source>
          <target state="translated">设置输出配置文件目录。默认输出名称为 &lt;var&gt;rewrite_profile&lt;/var&gt; 。</target>
        </trans-unit>
        <trans-unit id="7c0d7893ab57d9f01b9082ae29d8d0f77891bc37" translate="yes" xml:space="preserve">
          <source>Set the prevailing mode of the floating-point unit. This determines the floating-point mode that is provided and expected at function call and return time. Making this mode match the mode you predominantly need at function start can make your programs smaller and faster by avoiding unnecessary mode switches.</source>
          <target state="translated">设置浮点单元的现行模式。这决定了在函数调用和返回时提供和期望的浮点模式。使该模式与函数启动时主要需要的模式相匹配,可以避免不必要的模式切换,使程序更小更快。</target>
        </trans-unit>
        <trans-unit id="861bf514a61a077f62ab519a80b71ce1b519743f" translate="yes" xml:space="preserve">
          <source>Set the size (in bits) of the &lt;code&gt;double&lt;/code&gt; or &lt;code&gt;long double&lt;/code&gt; type, respectively. Possible values for &lt;var&gt;bits&lt;/var&gt; are 32 and 64. Whether or not a specific value for &lt;var&gt;bits&lt;/var&gt; is allowed depends on the &lt;code&gt;--with-double=&lt;/code&gt; and &lt;code&gt;--with-long-double=&lt;/code&gt;&lt;a href=&quot;https://gcc.gnu.org/install/configure.html#avr&quot;&gt;configure options&lt;/a&gt;, and the same applies for the default values of the options.</source>
          <target state="translated">分别设置 &lt;code&gt;double&lt;/code&gt; 或 &lt;code&gt;long double&lt;/code&gt; 类型的大小（以位为单位）。 &lt;var&gt;bits&lt;/var&gt; 可能值是32和64。是否允许 &lt;var&gt;bits&lt;/var&gt; 的特定值取决于 &lt;code&gt;--with-double=&lt;/code&gt; 和 &lt;code&gt;--with-long-double=&lt;/code&gt; &lt;a href=&quot;https://gcc.gnu.org/install/configure.html#avr&quot;&gt;configure选项&lt;/a&gt;，并且对它们的默认值也是如此。选项。</target>
        </trans-unit>
        <trans-unit id="762a949ea014b3f016344afca377c6c1fd120d31" translate="yes" xml:space="preserve">
          <source>Set the threshold for hot counter value.</source>
          <target state="translated">设置热计数器值的阈值。</target>
        </trans-unit>
        <trans-unit id="d1910b7ca1cbad135b71510c6caa598c927aef30" translate="yes" xml:space="preserve">
          <source>Set the verbose mode.</source>
          <target state="translated">设置啰嗦模式。</target>
        </trans-unit>
        <trans-unit id="44eafd221897534f159d32b54a0983fafc5fa037" translate="yes" xml:space="preserve">
          <source>Set the wide execution character set, used for wide string and character constants. The default is UTF-32 or UTF-16, whichever corresponds to the width of &lt;code&gt;wchar_t&lt;/code&gt;. As with</source>
          <target state="translated">设置宽执行字符集，用于宽字符串和字符常量。缺省值为UTF-32或UTF-16，与 &lt;code&gt;wchar_t&lt;/code&gt; 的宽度相对应。与</target>
        </trans-unit>
        <trans-unit id="bd789ae89e298186acebd68ef9887011219d47fa" translate="yes" xml:space="preserve">
          <source>Set to 1 if the prefetch hints should be issued for non-constant strides. Set to 0 if prefetch hints should be issued only for strides that are known to be constant and below</source>
          <target state="translated">设置为1,如果对非恒定步长发出预取提示。设置为0,如果只对已知的恒定和低于恒定的步长发出预取提示。</target>
        </trans-unit>
        <trans-unit id="dd1bb2779bea0f760b1f72945047e7f54094a87c" translate="yes" xml:space="preserve">
          <source>Sets a maximum number of hash table slots to use during variable tracking dataflow analysis of any function. If this limit is exceeded with variable tracking at assignments enabled, analysis for that function is retried without it, after removing all debug insns from the function. If the limit is exceeded even without debug insns, var tracking analysis is completely disabled for the function. Setting the parameter to zero makes it unlimited.</source>
          <target state="translated">设置在对任何函数进行变量跟踪数据流分析时使用的最大哈希表槽数。如果在启用变量跟踪赋值时超过了这个限制,那么在删除函数中的所有调试ins后,将在不使用该限制的情况下重试该函数的分析。如果在没有调试insns的情况下也超过了这个限制,则该函数的变量跟踪分析将被完全禁用。将该参数设置为0,则该参数不受限制。</target>
        </trans-unit>
        <trans-unit id="f4f7877852a522804eb61c6aaaac182eccebc50d" translate="yes" xml:space="preserve">
          <source>Sets a maximum number of recursion levels when attempting to map variable names or debug temporaries to value expressions. This trades compilation time for more complete debug information. If this is set too low, value expressions that are available and could be represented in debug information may end up not being used; setting this higher may enable the compiler to find more complex debug expressions, but compile time and memory use may grow.</source>
          <target state="translated">设置当试图将变量名或调试临时变量映射到值表达式时,递归级别的最大数量。这样可以用编译时间换取更完整的调试信息。如果这个值设置得太低,可用的、可以在调试信息中表示的值表达式可能最终不会被使用;设置得更高,可以使编译器找到更复杂的调试表达式,但编译时间和内存使用量可能会增加。</target>
        </trans-unit>
        <trans-unit id="08565d52b6000f5a1a238ccd0e999b10428d5194" translate="yes" xml:space="preserve">
          <source>Sets a threshold on the number of debug markers (e.g. begin stmt markers) to avoid complexity explosion at inlining or expanding to RTL. If a function has more such gimple stmts than the set limit, such stmts will be dropped from the inlined copy of a function, and from its RTL expansion.</source>
          <target state="translated">设置调试标记的数量阈值(例如:begin stmt标记),以避免在内联或扩展到RTL时出现复杂性爆炸。如果一个函数有更多这样的 gimple stmts 超过设定的限制,这些 stmts 将从函数的内联副本和 RTL 扩展中删除。</target>
        </trans-unit>
        <trans-unit id="adcadd51c3ed80675dda04731a772d76952914d2" translate="yes" xml:space="preserve">
          <source>Sets the &amp;lsquo;</source>
          <target state="translated">设置&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="a6ae8e4718c6afa26e8b518098d3712cd253890c" translate="yes" xml:space="preserve">
          <source>Sets the latency the scheduler should assume for typical memory references as seen by the application. This number is highly dependent on the memory access patterns used by the application and the size of the external cache on the machine.</source>
          <target state="translated">设置调度器对应用程序看到的典型内存引用所应承担的延迟。这个数字在很大程度上取决于应用程序使用的内存访问模式和机器上外部缓存的大小。</target>
        </trans-unit>
        <trans-unit id="0fa1baca9f030dc5a8c265ad0c68afe11b1a04b0" translate="yes" xml:space="preserve">
          <source>Sets the model of atomic operations and additional parameters as a comma separated list. For details on the atomic built-in functions see &lt;a href=&quot;_005f_005fatomic-builtins#g_t_005f_005fatomic-Builtins&quot;&gt;__atomic Builtins&lt;/a&gt;. The following models and parameters are supported:</source>
          <target state="translated">将原子操作和附加参数的模型设置为逗号分隔的列表。有关原子内置函数的详细信息，请参见&lt;a href=&quot;_005f_005fatomic-builtins#g_t_005f_005fatomic-Builtins&quot;&gt;__atomic Builtins&lt;/a&gt;。支持以下模型和参数：</target>
        </trans-unit>
        <trans-unit id="7b750af233a34aa4bcb53aaa3706d626453eaabe" translate="yes" xml:space="preserve">
          <source>Sets the options</source>
          <target state="translated">设置选项</target>
        </trans-unit>
        <trans-unit id="fb449f71834cd30ec14d00c9d50ba85c232186d3" translate="yes" xml:space="preserve">
          <source>Setting</source>
          <target state="translated">Setting</target>
        </trans-unit>
        <trans-unit id="d6ea280156ba317ca69c3a8a9a76acf1203369c2" translate="yes" xml:space="preserve">
          <source>Setting &lt;code&gt;GCC_COMPARE_DEBUG&lt;/code&gt; is nearly equivalent to passing</source>
          <target state="translated">设置 &lt;code&gt;GCC_COMPARE_DEBUG&lt;/code&gt; 几乎等同于通过</target>
        </trans-unit>
        <trans-unit id="4baf79749a36e87ddec4441787603ea1ca97f46a" translate="yes" xml:space="preserve">
          <source>Setting the rounding of floating-point operations to less than the default 80 bits can speed some programs by 2% or more. Note that some mathematical libraries assume that extended-precision (80-bit) floating-point operations are enabled by default; routines in such libraries could suffer significant loss of accuracy, typically through so-called &amp;ldquo;catastrophic cancellation&amp;rdquo;, when this option is used to set the precision to less than extended precision.</source>
          <target state="translated">将浮点运算的舍入设置为小于默认的80位可以使某些程序的速度提高2％或更多。请注意，某些数学库假定默认情况下启用了扩展精度（80位）浮点运算。当使用此选项将精度设置为小于扩展精度时，此类库中的例程可能会遭受严重的精度损失，通常是通过所谓的&amp;ldquo;灾难性取消&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="159856f2826a4750f12fa9fc42e4ec6a3bb1171a" translate="yes" xml:space="preserve">
          <source>Several parameters control the tree inliner used in GCC. This number sets the maximum number of instructions (counted in GCC&amp;rsquo;s internal representation) in a single function that the tree inliner considers for inlining. This only affects functions declared inline and methods implemented in a class declaration (C++).</source>
          <target state="translated">几个参数控制GCC中使用的树内衬。此数字设置树内联器考虑用于内联的单个函数中的最大指令数（以GCC内部表示方式计数）。这仅影响内联声明的函数和在类声明（C ++）中实现的方法。</target>
        </trans-unit>
        <trans-unit id="c8709090fc808377d68cf694b1141ced48d2601f" translate="yes" xml:space="preserve">
          <source>Shift amount register</source>
          <target state="translated">移位金额寄存器</target>
        </trans-unit>
        <trans-unit id="7fc448ecaaa6700b369be5c5a12e31cfde0d7dab" translate="yes" xml:space="preserve">
          <source>Shift count operand.</source>
          <target state="translated">移位计数操作数。</target>
        </trans-unit>
        <trans-unit id="42345631131c9de97e00bb02984b6911be9a2bc4" translate="yes" xml:space="preserve">
          <source>Shift count operands are probably signed more often than unsigned. Warning about this would cause far more annoyance than good.</source>
          <target state="translated">移位计数操作数可能是有符号的多于无符号的。警告这一点会引起更多的烦恼,而不是好事。</target>
        </trans-unit>
        <trans-unit id="dfe491f4c15e6a3a57cef7ef5658d06a18ca9681" translate="yes" xml:space="preserve">
          <source>Short Table of Contents</source>
          <target state="translated">简要目录</target>
        </trans-unit>
        <trans-unit id="a3534d8b3591be1366a119ae1eea2780cd912060" translate="yes" xml:space="preserve">
          <source>Short instructions are used opportunistically.</source>
          <target state="translated">短指令的使用是机会性的。</target>
        </trans-unit>
        <trans-unit id="4826dabecb65371171f46aae0549ce70f11c795f" translate="yes" xml:space="preserve">
          <source>Short structures and unions are those whose size and alignment match that of some integer type.</source>
          <target state="translated">短结构和联合体是指那些大小和对齐方式与某个整数类型相匹配的结构。</target>
        </trans-unit>
        <trans-unit id="daad79e8ea5157946382f52ca69c7ec66d0706c4" translate="yes" xml:space="preserve">
          <source>Shorten some address references at link time, when possible; uses the linker option</source>
          <target state="translated">在可能的情况下,在链接时缩短一些地址引用;使用链接器选项。</target>
        </trans-unit>
        <trans-unit id="bf389fd92901d9498a4ee5b421310db154ba5af7" translate="yes" xml:space="preserve">
          <source>Shrink-wrap separate parts of the prologue and epilogue separately, so that those parts are only executed when needed. This option is on by default, but has no effect unless</source>
          <target state="translated">分别收缩包装序幕和尾声的各个部分,以便这些部分只在需要时才执行。这个选项默认是打开的,但没有任何效果,除非</target>
        </trans-unit>
        <trans-unit id="3f90a5630eb62603c02b0eff8ce0d082b77006ba" translate="yes" xml:space="preserve">
          <source>Sign bit count. Return the number of consecutive bits in &lt;var&gt;value&lt;/var&gt; that have the same value as the sign bit. The result is the number of leading sign bits minus one, giving the number of redundant sign bits in &lt;var&gt;value&lt;/var&gt;.</source>
          <target state="translated">符号位计数。返回在连续的比特数 &lt;var&gt;value&lt;/var&gt; 具有相同的值作为符号位。结果是前导符号位的数量减一，从而得出 &lt;var&gt;value&lt;/var&gt; 中的冗余符号位的数量。</target>
        </trans-unit>
        <trans-unit id="e061183cc39dbc6eb9f3804e7d82ef6aa01d7857" translate="yes" xml:space="preserve">
          <source>Signed 11-bit integer constant</source>
          <target state="translated">有符号的11位整数常数</target>
        </trans-unit>
        <trans-unit id="17824e219e7e79f7144971183788b809379ad314" translate="yes" xml:space="preserve">
          <source>Signed 12-bit integer constant, for use in MOVI instructions</source>
          <target state="translated">带符号的12位整数常数,用于MOVI指令。</target>
        </trans-unit>
        <trans-unit id="2e366745a62f714ade88d7c0bd1a8931142b604e" translate="yes" xml:space="preserve">
          <source>Signed 13-bit constant</source>
          <target state="translated">有符号的13位常数</target>
        </trans-unit>
        <trans-unit id="4994a9f7bbfde0f98689a94230ffb2b0e3e5762e" translate="yes" xml:space="preserve">
          <source>Signed 13-bit constant, sign-extended to 32 or 64 bits</source>
          <target state="translated">有符号的13位常数,符号扩展到32或64位。</target>
        </trans-unit>
        <trans-unit id="7551ab4b6a7325d726d85dd8a288a32c7ad688ad" translate="yes" xml:space="preserve">
          <source>Signed 14-bit integer constant</source>
          <target state="translated">有符号的14位整数常数</target>
        </trans-unit>
        <trans-unit id="db68d6aa5c4dcc27204f228e4dfa27c519354e21" translate="yes" xml:space="preserve">
          <source>Signed 16 bit integer (in the range -32768 to 32767)</source>
          <target state="translated">有符号的16位整数(范围为-32768至32767)</target>
        </trans-unit>
        <trans-unit id="d6ec7293b64cddf6362ece0a6f483e55c61b7cd4" translate="yes" xml:space="preserve">
          <source>Signed 16-bit constant</source>
          <target state="translated">有符号的16位常数</target>
        </trans-unit>
        <trans-unit id="d5fed732c6b8716304eae31b104725b0d08b2445" translate="yes" xml:space="preserve">
          <source>Signed 16-bit constant (-32768&amp;ndash;32767)</source>
          <target state="translated">有符号16位常量（-32768&amp;ndash;32767）</target>
        </trans-unit>
        <trans-unit id="404101bb3dac0d3736cddd146de5ec8c922d9a53" translate="yes" xml:space="preserve">
          <source>Signed 16-bit constant shifted left 16 bits</source>
          <target state="translated">有符号的16位常数,左移16位。</target>
        </trans-unit>
        <trans-unit id="98375bb355d2181393a2db0e74a7f1e184e3c272" translate="yes" xml:space="preserve">
          <source>Signed 16-bit constant shifted left 16 bits. (Used with &lt;code&gt;l.movhi&lt;/code&gt;)</source>
          <target state="translated">有符号16位常量向左移16位。（与 &lt;code&gt;l.movhi&lt;/code&gt; 一起使用）</target>
        </trans-unit>
        <trans-unit id="fdfaee517f78cd79192cde0e2bb40ec8bf507d88" translate="yes" xml:space="preserve">
          <source>Signed 16-bit integer constant.</source>
          <target state="translated">有符号的16位整数常数。</target>
        </trans-unit>
        <trans-unit id="8577a9d2f5d95e6a261403245526b07f6b430127" translate="yes" xml:space="preserve">
          <source>Signed 3 bit integer (in the range -3 to 4)</source>
          <target state="translated">有符号的3位整数(范围为-3至4)</target>
        </trans-unit>
        <trans-unit id="258aee98ee71baaef5cdc776f36eef32bd26c55b" translate="yes" xml:space="preserve">
          <source>Signed 4 bit integer (in the range -8 to 7)</source>
          <target state="translated">有符号的4位整数(范围为-8至7)</target>
        </trans-unit>
        <trans-unit id="7a883110530359bda18df559e5a279936aa50db5" translate="yes" xml:space="preserve">
          <source>Signed 5-bit constant</source>
          <target state="translated">有符号的5位常数</target>
        </trans-unit>
        <trans-unit id="2e5e45d0ac38a40e675de10e051b4dbe8bc4276a" translate="yes" xml:space="preserve">
          <source>Signed 5-bit constant integer that can be loaded into an altivec register.</source>
          <target state="translated">有符号的5位常数,可以加载到altivec寄存器中。</target>
        </trans-unit>
        <trans-unit id="5f652f0cc47ab3c928aefe77d9c5b400f8c289d3" translate="yes" xml:space="preserve">
          <source>Signed 5-bit integer constant</source>
          <target state="translated">有符号的5位整数常数</target>
        </trans-unit>
        <trans-unit id="c9e48c645aa0b87a95100fbbeff86623f971b222" translate="yes" xml:space="preserve">
          <source>Signed 7 bit integer (in the range -64 to 63)</source>
          <target state="translated">有符号的7位整数(范围为-64至63)。</target>
        </trans-unit>
        <trans-unit id="a86e1174fb545f9d4ebd6f20bf01348603efafe4" translate="yes" xml:space="preserve">
          <source>Signed 8-bit integer constant, for use in ADDI instructions</source>
          <target state="translated">有符号的8位整数常数,用于ADDI指令。</target>
        </trans-unit>
        <trans-unit id="4c94edb4279f10dbe5d95209fe71d0f96db252dc" translate="yes" xml:space="preserve">
          <source>Signed 8-bit integer constant.</source>
          <target state="translated">有符号的8位整数常数。</target>
        </trans-unit>
        <trans-unit id="d272c273c51624f1dfdb18228a674026c85385e3" translate="yes" xml:space="preserve">
          <source>Signed constant that fits in 32 bits</source>
          <target state="translated">适合32位的有符号常数</target>
        </trans-unit>
        <trans-unit id="f1265b4b3d2e744579f9692016435bbe3b254213" translate="yes" xml:space="preserve">
          <source>Signed constant that fits in 4 bits</source>
          <target state="translated">适合4位的有符号常数</target>
        </trans-unit>
        <trans-unit id="5fe2facf8fa221348236eecc0c22b38ad313e882" translate="yes" xml:space="preserve">
          <source>Signed constant that fits in 5 bits</source>
          <target state="translated">5位的有符号常数</target>
        </trans-unit>
        <trans-unit id="545b5582447a4f3516b54b2967e68fc278ea9ad8" translate="yes" xml:space="preserve">
          <source>Signed constant that fits in 6 bits</source>
          <target state="translated">6位的有符号常数</target>
        </trans-unit>
        <trans-unit id="fd73c4e772cdc0f6e26ab1480292e828319d76b5" translate="yes" xml:space="preserve">
          <source>Signed immediate 10-bit value.</source>
          <target state="translated">签名的即时10位值。</target>
        </trans-unit>
        <trans-unit id="c5a8dbe6ead600b15b992c7b4bcf2efdb71ef681" translate="yes" xml:space="preserve">
          <source>Signed immediate 11-bit value.</source>
          <target state="translated">签名的即时11位值。</target>
        </trans-unit>
        <trans-unit id="a9356a59861e3c3eddcf1709eba030136286aebc" translate="yes" xml:space="preserve">
          <source>Signed immediate 15-bit value.</source>
          <target state="translated">签名的即时15位值。</target>
        </trans-unit>
        <trans-unit id="bd0cffbf0853e1a9f6e67fd93c760a34d836c070" translate="yes" xml:space="preserve">
          <source>Signed immediate 16-bit value.</source>
          <target state="translated">签名的即时16位值。</target>
        </trans-unit>
        <trans-unit id="a37369d99fd2a342362e9005528625a1180d725a" translate="yes" xml:space="preserve">
          <source>Signed immediate 17-bit value.</source>
          <target state="translated">签名的即时17位值。</target>
        </trans-unit>
        <trans-unit id="58ba7a0e897855d208deefd5f1aafdaebb7cbcad" translate="yes" xml:space="preserve">
          <source>Signed immediate 19-bit value.</source>
          <target state="translated">签名的即时19位值。</target>
        </trans-unit>
        <trans-unit id="d83875e20f0c4256559e6ad41957f6681f0f9fa4" translate="yes" xml:space="preserve">
          <source>Signed immediate 20-bit value.</source>
          <target state="translated">签名的即时20位值。</target>
        </trans-unit>
        <trans-unit id="772df3ebaa8079e1347500ef9b5a7974d1afc6fb" translate="yes" xml:space="preserve">
          <source>Signed immediate 5-bit value.</source>
          <target state="translated">签名的即时5位值。</target>
        </trans-unit>
        <trans-unit id="bed3d07e5abfe469789a6ad8fe518ca8c515cc56" translate="yes" xml:space="preserve">
          <source>Signed number whose magnitude is greater than 0x100</source>
          <target state="translated">大于0x100的有符号数字</target>
        </trans-unit>
        <trans-unit id="7dd7717c5fdb2f197d7bb925e85ce43ecfb76df1" translate="yes" xml:space="preserve">
          <source>Signed number whose magnitude is greater than 0x80</source>
          <target state="translated">大于0x80的有符号数字</target>
        </trans-unit>
        <trans-unit id="0939c3fe5c0d5d2bff40d1b5db20a06321bba976" translate="yes" xml:space="preserve">
          <source>Similar to</source>
          <target state="translated">类似于</target>
        </trans-unit>
        <trans-unit id="d539a06616b59e9c0b7a9e23630c3741a65d5d1c" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;__builtin_alloca_with_align&lt;/code&gt; but takes an extra argument specifying an upper bound for &lt;var&gt;size&lt;/var&gt; in case its value cannot be computed at compile time, for use by</source>
          <target state="translated">与 &lt;code&gt;__builtin_alloca_with_align&lt;/code&gt; 相似，但是采用一个额外的参数来指定 &lt;var&gt;size&lt;/var&gt; 的上限，以防在编译时无法计算其值，以供</target>
        </trans-unit>
        <trans-unit id="ea1f6fc78d2de9307f7b88ab0282a15257495c59" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;__builtin_bswap16&lt;/code&gt;, except the argument and return types are 32 bit.</source>
          <target state="translated">与 &lt;code&gt;__builtin_bswap16&lt;/code&gt; 相似，不同之处在于参数和返回类型均为32位。</target>
        </trans-unit>
        <trans-unit id="287de43f15b38812ca35a70d4d7f3e0bbc21298b" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;__builtin_bswap32&lt;/code&gt;, except the argument and return types are 64 bit.</source>
          <target state="translated">与 &lt;code&gt;__builtin_bswap32&lt;/code&gt; 类似，不同之处在于参数和返回类型为64位。</target>
        </trans-unit>
        <trans-unit id="103307679937d9d214ea5a77118584bb62226212" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;__builtin_clrsb&lt;/code&gt;, except the argument type is &lt;code&gt;long long&lt;/code&gt;.</source>
          <target state="translated">与 &lt;code&gt;__builtin_clrsb&lt;/code&gt; 类似，不同的是参数类型为 &lt;code&gt;long long&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d9811f01cbffd069bcc5462448b89027d4f2ec50" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;__builtin_clrsb&lt;/code&gt;, except the argument type is &lt;code&gt;long&lt;/code&gt;.</source>
          <target state="translated">与 &lt;code&gt;__builtin_clrsb&lt;/code&gt; 类似，不同的是参数类型为 &lt;code&gt;long&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="df68abde10040a09c09e6b0b67f91ab09e952842" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;__builtin_clz&lt;/code&gt;, except the argument type is &lt;code&gt;unsigned long long&lt;/code&gt;.</source>
          <target state="translated">与 &lt;code&gt;__builtin_clz&lt;/code&gt; 类似，不同的是参数类型为 &lt;code&gt;unsigned long long&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f59576794aa7ba8bdf20faea4b1656733f7cd810" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;__builtin_clz&lt;/code&gt;, except the argument type is &lt;code&gt;unsigned long&lt;/code&gt;.</source>
          <target state="translated">与 &lt;code&gt;__builtin_clz&lt;/code&gt; 类似，不同之处在于参数类型为 &lt;code&gt;unsigned long&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ba918034130e18befe466fce358d135c77bcf300" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;__builtin_ctz&lt;/code&gt;, except the argument type is &lt;code&gt;unsigned long long&lt;/code&gt;.</source>
          <target state="translated">与 &lt;code&gt;__builtin_ctz&lt;/code&gt; 相似，不同之处在于参数类型为 &lt;code&gt;unsigned long long&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="18c0fbde15c08851968dc27a9a4c9c3e731fb512" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;__builtin_ctz&lt;/code&gt;, except the argument type is &lt;code&gt;unsigned long&lt;/code&gt;.</source>
          <target state="translated">与 &lt;code&gt;__builtin_ctz&lt;/code&gt; 相似，不同之处在于参数类型为 &lt;code&gt;unsigned long&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c02104ee06367b8a197baa2a19b2abc09a1e31d1" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;__builtin_ffs&lt;/code&gt;, except the argument type is &lt;code&gt;long long&lt;/code&gt;.</source>
          <target state="translated">与 &lt;code&gt;__builtin_ffs&lt;/code&gt; 类似，不同的是参数类型为 &lt;code&gt;long long&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d1d6beb2a9ac335ca9f6e943f00f7fb214000908" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;__builtin_ffs&lt;/code&gt;, except the argument type is &lt;code&gt;long&lt;/code&gt;.</source>
          <target state="translated">与 &lt;code&gt;__builtin_ffs&lt;/code&gt; 类似，不同的是参数类型为 &lt;code&gt;long&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="41c22622d956d1ffb73b5455c532f810279add42" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;__builtin_huge_val&lt;/code&gt;, except a warning is generated if the target floating-point format does not support infinities.</source>
          <target state="translated">与 &lt;code&gt;__builtin_huge_val&lt;/code&gt; 相似，不同之处在于，如果目标浮点格式不支持无限，则会生成警告。</target>
        </trans-unit>
        <trans-unit id="a3824e629002ce80fc504751d9f1603b9da7d561" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;__builtin_huge_val&lt;/code&gt;, except the return type is &lt;code&gt;_Float&lt;var&gt;n&lt;/var&gt;&lt;/code&gt;.</source>
          <target state="translated">类似于 &lt;code&gt;__builtin_huge_val&lt;/code&gt; ，不同之处在于返回类型为 &lt;code&gt;_Float&lt;var&gt;n&lt;/var&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="008da3964b6f0002d0e9671a9ad995b6c420ce79" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;__builtin_huge_val&lt;/code&gt;, except the return type is &lt;code&gt;_Float&lt;var&gt;n&lt;/var&gt;x&lt;/code&gt;.</source>
          <target state="translated">类似于 &lt;code&gt;__builtin_huge_val&lt;/code&gt; ，不同之处在于返回类型为 &lt;code&gt;_Float&lt;var&gt;n&lt;/var&gt;x&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e3a7adf1a6224d5bf5cb7c613e9a778b88a8c44b" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;__builtin_huge_val&lt;/code&gt;, except the return type is &lt;code&gt;__float128&lt;/code&gt;.</source>
          <target state="translated">类似于 &lt;code&gt;__builtin_huge_val&lt;/code&gt; ，不同之处在于返回类型为 &lt;code&gt;__float128&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c1ffbe411a36969832b5f38087ea616365eec591" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;__builtin_huge_val&lt;/code&gt;, except the return type is &lt;code&gt;float&lt;/code&gt;.</source>
          <target state="translated">类似于 &lt;code&gt;__builtin_huge_val&lt;/code&gt; ，不同之处在于返回类型为 &lt;code&gt;float&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="186ce490303bc44a81961f86210149a388cbfd93" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;__builtin_huge_val&lt;/code&gt;, except the return type is &lt;code&gt;long double&lt;/code&gt;.</source>
          <target state="translated">类似于 &lt;code&gt;__builtin_huge_val&lt;/code&gt; ，不同之处在于返回类型为 &lt;code&gt;long double&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4256a1779131be828664fbc4607bd86235fc8f63" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;__builtin_inf&lt;/code&gt;, except the return type is &lt;code&gt;_Decimal128&lt;/code&gt;.</source>
          <target state="translated">与 &lt;code&gt;__builtin_inf&lt;/code&gt; 相似，不同之处在于返回类型为 &lt;code&gt;_Decimal128&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a3fc9b57c65d245ef2ebac66b67318e250147f5d" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;__builtin_inf&lt;/code&gt;, except the return type is &lt;code&gt;_Decimal32&lt;/code&gt;.</source>
          <target state="translated">与 &lt;code&gt;__builtin_inf&lt;/code&gt; 相似，不同之处在于返回类型为 &lt;code&gt;_Decimal32&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ec19c1b8f5bd592906a07150f56b4d809cec3b3a" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;__builtin_inf&lt;/code&gt;, except the return type is &lt;code&gt;_Decimal64&lt;/code&gt;.</source>
          <target state="translated">与 &lt;code&gt;__builtin_inf&lt;/code&gt; 相似，不同之处在于返回类型为 &lt;code&gt;_Decimal64&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="57f4cede60e9110addaf6366460fd28f55f54667" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;__builtin_inf&lt;/code&gt;, except the return type is &lt;code&gt;_Float&lt;var&gt;n&lt;/var&gt;&lt;/code&gt;.</source>
          <target state="translated">与 &lt;code&gt;__builtin_inf&lt;/code&gt; 相似，不同之处在于返回类型为 &lt;code&gt;_Float&lt;var&gt;n&lt;/var&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="59d4025e2d73946d427adb0f6d32cc098e01d334" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;__builtin_inf&lt;/code&gt;, except the return type is &lt;code&gt;_Float&lt;var&gt;n&lt;/var&gt;x&lt;/code&gt;.</source>
          <target state="translated">与 &lt;code&gt;__builtin_inf&lt;/code&gt; 相似，不同之处在于返回类型为 &lt;code&gt;_Float&lt;var&gt;n&lt;/var&gt;x&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c1d67c7c6c9f71b26da8ec675376459c0921c713" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;__builtin_inf&lt;/code&gt;, except the return type is &lt;code&gt;__float128&lt;/code&gt;.</source>
          <target state="translated">与 &lt;code&gt;__builtin_inf&lt;/code&gt; 相似，不同之处在于返回类型为 &lt;code&gt;__float128&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="896466811c11f3c4ee9e850f02d545950afb9b4d" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;__builtin_inf&lt;/code&gt;, except the return type is &lt;code&gt;float&lt;/code&gt;. This function is suitable for implementing the ISO C99 macro &lt;code&gt;INFINITY&lt;/code&gt;.</source>
          <target state="translated">类似于 &lt;code&gt;__builtin_inf&lt;/code&gt; ，不同之处在于返回类型为 &lt;code&gt;float&lt;/code&gt; 。此函数适合于实现ISO C99宏 &lt;code&gt;INFINITY&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="76bb498c29da1b35254a143c1ace9763a1b7c3a7" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;__builtin_inf&lt;/code&gt;, except the return type is &lt;code&gt;long double&lt;/code&gt;.</source>
          <target state="translated">与 &lt;code&gt;__builtin_inf&lt;/code&gt; 相似，不同之处在于返回类型为 &lt;code&gt;long double&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1d97d51092a352913796ed842ffe0791359432b2" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;__builtin_nan&lt;/code&gt;, except the return type is &lt;code&gt;_Decimal128&lt;/code&gt;.</source>
          <target state="translated">类似于 &lt;code&gt;__builtin_nan&lt;/code&gt; ，不同之处在于返回类型为 &lt;code&gt;_Decimal128&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="53d0a1658ae40e15391cc06844539577593fad36" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;__builtin_nan&lt;/code&gt;, except the return type is &lt;code&gt;_Decimal32&lt;/code&gt;.</source>
          <target state="translated">类似于 &lt;code&gt;__builtin_nan&lt;/code&gt; ，不同之处在于返回类型为 &lt;code&gt;_Decimal32&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d0fb2196b87a982f142cbeace7c2dfa53a9a5586" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;__builtin_nan&lt;/code&gt;, except the return type is &lt;code&gt;_Decimal64&lt;/code&gt;.</source>
          <target state="translated">类似于 &lt;code&gt;__builtin_nan&lt;/code&gt; ，不同之处在于返回类型为 &lt;code&gt;_Decimal64&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="972fe72faee34d4a1bafa2164a917e9478d32f29" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;__builtin_nan&lt;/code&gt;, except the return type is &lt;code&gt;_Float&lt;var&gt;n&lt;/var&gt;&lt;/code&gt;.</source>
          <target state="translated">类似于 &lt;code&gt;__builtin_nan&lt;/code&gt; ，不同之处在于返回类型为 &lt;code&gt;_Float&lt;var&gt;n&lt;/var&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="517865e97371f1de64149fe1cc44de8533e7d916" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;__builtin_nan&lt;/code&gt;, except the return type is &lt;code&gt;_Float&lt;var&gt;n&lt;/var&gt;x&lt;/code&gt;.</source>
          <target state="translated">与 &lt;code&gt;__builtin_nan&lt;/code&gt; 类似，不同之处在于返回类型为 &lt;code&gt;_Float&lt;var&gt;n&lt;/var&gt;x&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="80a4f0bb5594bf8db6aa07b69d98290c7b0cb4d2" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;__builtin_nan&lt;/code&gt;, except the return type is &lt;code&gt;__float128&lt;/code&gt;.</source>
          <target state="translated">类似于 &lt;code&gt;__builtin_nan&lt;/code&gt; ，不同之处在于返回类型为 &lt;code&gt;__float128&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ee7af1fac130e9139e3597fcacf0ac51e23ffa68" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;__builtin_nan&lt;/code&gt;, except the return type is &lt;code&gt;float&lt;/code&gt;.</source>
          <target state="translated">类似于 &lt;code&gt;__builtin_nan&lt;/code&gt; ，不同之处在于返回类型为 &lt;code&gt;float&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7f02308aa234b8f5dba187e0535ecce86dade187" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;__builtin_nan&lt;/code&gt;, except the return type is &lt;code&gt;long double&lt;/code&gt;.</source>
          <target state="translated">与 &lt;code&gt;__builtin_nan&lt;/code&gt; 类似，不同之处在于返回类型为 &lt;code&gt;long double&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7c9ad9b208b6e73ec53236ae7ef08d2a9f0beabb" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;__builtin_nan&lt;/code&gt;, except the significand is forced to be a signaling NaN. The &lt;code&gt;nans&lt;/code&gt; function is proposed by &lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg14/www/docs/n965.htm&quot;&gt;WG14 N965&lt;/a&gt;.</source>
          <target state="translated">类似于 &lt;code&gt;__builtin_nan&lt;/code&gt; ，除了有效位数被强制为信号NaN。该 &lt;code&gt;nans&lt;/code&gt; 功能是通过提出&lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg14/www/docs/n965.htm&quot;&gt;WG14 N965&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="25d07b665f89fcc40387d17242580a6c52085352" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;__builtin_nans&lt;/code&gt;, except the return type is &lt;code&gt;_Float&lt;var&gt;n&lt;/var&gt;&lt;/code&gt;.</source>
          <target state="translated">与 &lt;code&gt;__builtin_nans&lt;/code&gt; 相似，不同之处在于返回类型为 &lt;code&gt;_Float&lt;var&gt;n&lt;/var&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="125a42543c42a9a4c876178d1cd519e3e1ac3337" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;__builtin_nans&lt;/code&gt;, except the return type is &lt;code&gt;_Float&lt;var&gt;n&lt;/var&gt;x&lt;/code&gt;.</source>
          <target state="translated">与 &lt;code&gt;__builtin_nans&lt;/code&gt; 相似，不同之处在于返回类型为 &lt;code&gt;_Float&lt;var&gt;n&lt;/var&gt;x&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c928fffe5233a8745a6b29699edadd2bd3d1840c" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;__builtin_nans&lt;/code&gt;, except the return type is &lt;code&gt;__float128&lt;/code&gt;.</source>
          <target state="translated">类似于 &lt;code&gt;__builtin_nans&lt;/code&gt; ，除了返回类型为 &lt;code&gt;__float128&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c71386ef3f149c7961c5dd435e803b5b814adc62" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;__builtin_nans&lt;/code&gt;, except the return type is &lt;code&gt;float&lt;/code&gt;.</source>
          <target state="translated">与 &lt;code&gt;__builtin_nans&lt;/code&gt; 类似，不同之处在于返回类型为 &lt;code&gt;float&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d3b4d3c3ce7578550309b9e1b7c63b2aeae76345" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;__builtin_nans&lt;/code&gt;, except the return type is &lt;code&gt;long double&lt;/code&gt;.</source>
          <target state="translated">与 &lt;code&gt;__builtin_nans&lt;/code&gt; 类似，不同之处在于返回类型为 &lt;code&gt;long double&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="88f8bef8cb3e9f1b7034b6cd67d536931b56ab97" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;__builtin_parity&lt;/code&gt;, except the argument type is &lt;code&gt;unsigned long long&lt;/code&gt;.</source>
          <target state="translated">与 &lt;code&gt;__builtin_parity&lt;/code&gt; 相似，不同的是参数类型为 &lt;code&gt;unsigned long long&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7b8444edd220546f2658052bf55756594cf3d7e6" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;__builtin_parity&lt;/code&gt;, except the argument type is &lt;code&gt;unsigned long&lt;/code&gt;.</source>
          <target state="translated">与 &lt;code&gt;__builtin_parity&lt;/code&gt; 相似，不同的是参数类型为 &lt;code&gt;unsigned long&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e6da5b45f1e360ae211b94e56690a0b8fa88ee21" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;__builtin_popcount&lt;/code&gt;, except the argument type is &lt;code&gt;unsigned long long&lt;/code&gt;.</source>
          <target state="translated">与 &lt;code&gt;__builtin_popcount&lt;/code&gt; 相似，不同的是参数类型为 &lt;code&gt;unsigned long long&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ff3e55487db84f15ffa29a16f3d14063de2220f3" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;__builtin_popcount&lt;/code&gt;, except the argument type is &lt;code&gt;unsigned long&lt;/code&gt;.</source>
          <target state="translated">与 &lt;code&gt;__builtin_popcount&lt;/code&gt; 类似，不同的是参数类型为 &lt;code&gt;unsigned long&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f6bdffa702ce1bb4acc9747edb48016c4599e76d" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;__builtin_powi&lt;/code&gt;, except the argument and return types are &lt;code&gt;float&lt;/code&gt;.</source>
          <target state="translated">类似于 &lt;code&gt;__builtin_powi&lt;/code&gt; ，不同之处在于参数和返回类型为 &lt;code&gt;float&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c49d8fe4e2b5fa5d1e76762b1beb13a3295e5948" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;__builtin_powi&lt;/code&gt;, except the argument and return types are &lt;code&gt;long double&lt;/code&gt;.</source>
          <target state="translated">与 &lt;code&gt;__builtin_powi&lt;/code&gt; 类似，不同之处在于参数和返回类型为 &lt;code&gt;long double&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2c1e3e4bbd07650298754513f3e3a44bed8e82b1" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;isinf&lt;/code&gt;, except the return value is -1 for an argument of &lt;code&gt;-Inf&lt;/code&gt; and 1 for an argument of &lt;code&gt;+Inf&lt;/code&gt;. Note while the parameter list is an ellipsis, this function only accepts exactly one floating-point argument. GCC treats this parameter as type-generic, which means it does not do default promotion from float to double.</source>
          <target state="translated">类似于 &lt;code&gt;isinf&lt;/code&gt; ，除了返回值是-1的一个参数 &lt;code&gt;-Inf&lt;/code&gt; 为的参数与1 &lt;code&gt;+Inf&lt;/code&gt; 文件。请注意，虽然参数列表是省略号，但是此函数仅接受一个浮点参数。GCC将此参数视为泛型，这意味着它不会将默认值从float提升为double。</target>
        </trans-unit>
        <trans-unit id="f30b0c19d239509bdc4a9dccfa54aa40be3c10c1" translate="yes" xml:space="preserve">
          <source>Similar to the stack- data- and const-align options above, these options arrange for stack frame, writable data and constants to all be 32-bit, 16-bit or 8-bit aligned. The default is 32-bit alignment.</source>
          <target state="translated">与上面的 stack-data-和 const-align 选项类似,这些选项将堆栈框架、可写数据和常量都安排为 32 位、16 位或 8 位对齐。默认为32位对齐。</target>
        </trans-unit>
        <trans-unit id="b4b6e8c3d6c60e969147af3a81dfe25b7338a216" translate="yes" xml:space="preserve">
          <source>Similarly to</source>
          <target state="translated">类似于</target>
        </trans-unit>
        <trans-unit id="8599edec7c2ed57ef8914ff45d22cb4fe06042cc" translate="yes" xml:space="preserve">
          <source>Similarly, access by taking the address, casting the resulting pointer and dereferencing the result has undefined behavior, even if the cast uses a union type, e.g.:</source>
          <target state="translated">同样地,通过获取地址、铸造产生的指针和取消引用结果的访问具有未定义的行为,即使铸造使用了联合类型,例如:。</target>
        </trans-unit>
        <trans-unit id="41ba9557152bce164799d0130f0eb9f9280e308f" translate="yes" xml:space="preserve">
          <source>Similarly, compiling code with G++ that must use a C++ library other than the GNU C++ library requires specifying the location of the header files for that other library.</source>
          <target state="translated">同样,用G++编译代码时,如果必须使用GNU C++库以外的C++库,则需要指定该其他库的头文件的位置。</target>
        </trans-unit>
        <trans-unit id="638ae03227c9ec9c0ea2e3c27a8de52a23a69e64" translate="yes" xml:space="preserve">
          <source>Similarly, it is not safe to access the global register variables from signal handlers or from more than one thread of control. Unless you recompile them specially for the task at hand, the system library routines may temporarily use the register for other things. Furthermore, since the register is not reserved exclusively for the variable, accessing it from handlers of asynchronous signals may observe unrelated temporary values residing in the register.</source>
          <target state="translated">同样,从信号处理程序或从一个以上的控制线程访问全局寄存器变量也是不安全的。除非你专门为手头的任务重新编译它们,否则系统库例程可能会暂时将寄存器用于其他事情。此外,由于寄存器不是专门为变量保留的,从异步信号的处理程序访问它可能会观察到寄存器中残留的无关的临时值。</target>
        </trans-unit>
        <trans-unit id="0b5c7c9387d15f3c833c95ff75e1127cc7558092" translate="yes" xml:space="preserve">
          <source>Simplify interprocedural analysis by computing the effect of certain calls, rather than exploring all paths through the function from callsite to each possible return.</source>
          <target state="translated">通过计算某些调用的效果来简化程序间的分析,而不是探索从callite到每个可能返回的函数的所有路径。</target>
        </trans-unit>
        <trans-unit id="22a4ed66c623d273a571652cc9ae1a89577a837f" translate="yes" xml:space="preserve">
          <source>Since</source>
          <target state="translated">Since</target>
        </trans-unit>
        <trans-unit id="33c848578be7e9d6967258af62c4197dfe644969" translate="yes" xml:space="preserve">
          <source>Since &lt;code&gt;spu_add&lt;/code&gt; is a macro, the vector constant in the example is treated as four separate arguments. Wrap the entire argument in parentheses for this to work.</source>
          <target state="translated">由于 &lt;code&gt;spu_add&lt;/code&gt; 是宏，因此示例中的向量常量被视为四个单独的参数。将整个参数括在括号中以使其起作用。</target>
        </trans-unit>
        <trans-unit id="59c049b9dd5a46fabeed926b81db03e50fbbf544" translate="yes" xml:space="preserve">
          <source>Since &lt;code&gt;vec_add&lt;/code&gt; is a macro, the vector constant in the example is treated as four separate arguments. Wrap the entire argument in parentheses for this to work.</source>
          <target state="translated">由于 &lt;code&gt;vec_add&lt;/code&gt; 是宏，因此示例中的向量常量被视为四个单独的参数。将整个参数括在括号中以使其起作用。</target>
        </trans-unit>
        <trans-unit id="21c7fe9d52d84289272bf156d75da1baf041f576" translate="yes" xml:space="preserve">
          <source>Since G++ now defaults to updating the ABI with each major release, normally</source>
          <target state="translated">由于G++现在默认在每个主要版本中都会更新ABI,因此通常情况下</target>
        </trans-unit>
        <trans-unit id="f22660df453a96c806164b9cde945b16ac8135b9" translate="yes" xml:space="preserve">
          <source>Since GCC does not parse the assembler template, it has no visibility of any symbols it references. This may result in GCC discarding those symbols as unreferenced unless they are also listed as input, output, or goto operands.</source>
          <target state="translated">由于GCC不解析汇编器模板,所以它对任何引用的符号都不可见。这可能导致GCC将这些符号作为未引用的符号丢弃,除非它们也被列为输入、输出或goto操作数。</target>
        </trans-unit>
        <trans-unit id="b000a8b411ebdceb551939a35ee69b160bbe25b6" translate="yes" xml:space="preserve">
          <source>Since ISO C99 defines this function in terms of &lt;code&gt;strtod&lt;/code&gt;, which we do not implement, a description of the parsing is in order. The string is parsed as by &lt;code&gt;strtol&lt;/code&gt;; that is, the base is recognized by leading &amp;lsquo;</source>
          <target state="translated">由于ISO C99根据我们未实现的 &lt;code&gt;strtod&lt;/code&gt; 定义了此功能，因此对解析的描述是有序的。字符串由 &lt;code&gt;strtol&lt;/code&gt; 解析；也就是说，该基数被&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="892917377ab8c3ffb653fb42e72d9ed1bdd00343" translate="yes" xml:space="preserve">
          <source>Since the &lt;code&gt;__builtin_alloca&lt;/code&gt; function doesn&amp;rsquo;t validate its argument it is the responsibility of its caller to make sure the argument doesn&amp;rsquo;t cause it to exceed the stack size limit. The &lt;code&gt;__builtin_alloca&lt;/code&gt; function is provided to make it possible to allocate on the stack arrays of bytes with an upper bound that may be computed at run time. Since C99 Variable Length Arrays offer similar functionality under a portable, more convenient, and safer interface they are recommended instead, in both C99 and C++ programs where GCC provides them as an extension. See &lt;a href=&quot;variable-length#Variable-Length&quot;&gt;Variable Length&lt;/a&gt;, for details.</source>
          <target state="translated">由于 &lt;code&gt;__builtin_alloca&lt;/code&gt; 函数不会验证其参数，因此调用方有责任确保该参数不会导致其超出堆栈大小限制。所述 &lt;code&gt;__builtin_alloca&lt;/code&gt; 提供功能，使有可能在字节的堆叠阵列分配有上限，可能在运行时计算。由于C99可变长度数组在可移植，更方便和更安全的界面下提供了类似的功能，因此建议在GCC将其作为扩展的C99和C ++程序中使用它们。有关详细信息，请参见&lt;a href=&quot;variable-length#Variable-Length&quot;&gt;可变长度&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4baf9c380b14381cf54e66f25724ec841c6dbbc1" translate="yes" xml:space="preserve">
          <source>Since the &lt;code&gt;__builtin_alloca_with_align&lt;/code&gt; function doesn&amp;rsquo;t validate its &lt;var&gt;size&lt;/var&gt; argument it is the responsibility of its caller to make sure the argument doesn&amp;rsquo;t cause it to exceed the stack size limit. The &lt;code&gt;__builtin_alloca_with_align&lt;/code&gt; function is provided to make it possible to allocate on the stack overaligned arrays of bytes with an upper bound that may be computed at run time. Since C99 Variable Length Arrays offer the same functionality under a portable, more convenient, and safer interface they are recommended instead, in both C99 and C++ programs where GCC provides them as an extension. See &lt;a href=&quot;variable-length#Variable-Length&quot;&gt;Variable Length&lt;/a&gt;, for details.</source>
          <target state="translated">由于 &lt;code&gt;__builtin_alloca_with_align&lt;/code&gt; 函数不会验证其 &lt;var&gt;size&lt;/var&gt; 参数，因此调用方有责任确保该参数不会导致其超出堆栈大小限制。所述 &lt;code&gt;__builtin_alloca_with_align&lt;/code&gt; 提供功能，使有可能在字节堆栈overaligned阵列分配有上限，可能在运行时计算。由于C99可变长度数组在可移植，更方便和更安全的界面下提供了相同的功能，因此建议在GCC将其作为扩展的C99和C ++程序中使用它们。有关详细信息，请参见&lt;a href=&quot;variable-length#Variable-Length&quot;&gt;可变长度&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0258c9861f729a6d6a1e77969495b52ec885eef9" translate="yes" xml:space="preserve">
          <source>Since the two variable &lt;code&gt;i&lt;/code&gt; in the example above have incompatible types, enabling only</source>
          <target state="translated">由于上面示例中的两个变量 &lt;code&gt;i&lt;/code&gt; 具有不兼容的类型，因此仅启用</target>
        </trans-unit>
        <trans-unit id="d388c0730bf40209b77631102dd7aa30902cc328" translate="yes" xml:space="preserve">
          <source>Since there are occasions where a switch case fall through is desirable, GCC provides an attribute, &lt;code&gt;__attribute__ ((fallthrough))&lt;/code&gt;, that is to be used along with a null statement to suppress this warning that would normally occur:</source>
          <target state="translated">由于在某些情况下需要进行切换，因此GCC提供了 &lt;code&gt;__attribute__ ((fallthrough))&lt;/code&gt; 属性，该属性将与null语句一起使用以抑制通常会发生的此警告：</target>
        </trans-unit>
        <trans-unit id="9d33bdb0c97347197e4dad14823945cd2f7cbcbd" translate="yes" xml:space="preserve">
          <source>Single functions can be exempted from inlining by marking them with the &lt;code&gt;noinline&lt;/code&gt; attribute.</source>
          <target state="translated">通过使用 &lt;code&gt;noinline&lt;/code&gt; 属性标记单个函数，可以免除它们的内联。</target>
        </trans-unit>
        <trans-unit id="e677e33f125717883b72d6689c2a09bd6ab65171" translate="yes" xml:space="preserve">
          <source>Single-precision floating point:</source>
          <target state="translated">单精度浮点数。</target>
        </trans-unit>
        <trans-unit id="76bd493ed8bb81652313a482dd8f8e1005d241c8" translate="yes" xml:space="preserve">
          <source>Size of max partition for WHOPR (in estimated instructions). to provide an upper bound for individual size of partition. Meant to be used only with balanced partitioning.</source>
          <target state="translated">WHOPR 的最大分区大小(以估计指令为单位),用于提供单个分区大小的上限。仅用于平衡分区。</target>
        </trans-unit>
        <trans-unit id="e240bffdb5210e2a9fb3c1ceaef0728216aabbc4" translate="yes" xml:space="preserve">
          <source>Size of minimal partition for WHOPR (in estimated instructions). This prevents expenses of splitting very small programs into too many partitions.</source>
          <target state="translated">WHOPR最小分区的大小(以估计指令为单位)。这可以避免将很小的程序分割到太多的分区。</target>
        </trans-unit>
        <trans-unit id="feac389ca59136d24edc664765fb58951d1a7cbe" translate="yes" xml:space="preserve">
          <source>Slightly looser rules for escaped newlines.</source>
          <target state="translated">对于转义的新行的规则稍微宽松一些。</target>
        </trans-unit>
        <trans-unit id="6ae97113b3cf739a346d55e68c010f462fdbf99d" translate="yes" xml:space="preserve">
          <source>Small integer constants can use a shared data structure, reducing the compiler&amp;rsquo;s memory usage and increasing its speed. This sets the maximum value of a shared integer constant.</source>
          <target state="translated">小整数常量可以使用共享的数据结构，从而减少了编译器的内存使用量并提高了速度。这将设置共享整数常量的最大值。</target>
        </trans-unit>
        <trans-unit id="3c352006f28e617e3092550875bb98a37c3e499d" translate="yes" xml:space="preserve">
          <source>Small model objects live in the lower 16MB of memory (so that their addresses can be loaded with the &lt;code&gt;ld24&lt;/code&gt; instruction), and are callable with the &lt;code&gt;bl&lt;/code&gt; instruction.</source>
          <target state="translated">小型模型对象位于较低的16MB内存中（以便可以通过 &lt;code&gt;ld24&lt;/code&gt; 指令加载其地址），并且可以通过 &lt;code&gt;bl&lt;/code&gt; 指令调用它们。</target>
        </trans-unit>
        <trans-unit id="a3714fde637fe384ead8d5eb02c1a4c25f02d146" translate="yes" xml:space="preserve">
          <source>Small model objects live in the lower 16MB of memory (so that their addresses can be loaded with the &lt;code&gt;ld24&lt;/code&gt; instruction).</source>
          <target state="translated">小型模型对象位于较低的16MB内存中（以便可以使用 &lt;code&gt;ld24&lt;/code&gt; 指令加载其地址）。</target>
        </trans-unit>
        <trans-unit id="87cc781515efd4b579bb2ce6bb66d4b4e6b7b78a" translate="yes" xml:space="preserve">
          <source>So the first alternative for the 68000&amp;rsquo;s logical-or could be written as &lt;code&gt;&quot;+m&quot; (output) : &quot;ir&quot; (input)&lt;/code&gt;. The second could be &lt;code&gt;&quot;+r&quot; 
(output): &quot;irm&quot; (input)&lt;/code&gt;. However, the fact that two memory locations cannot be used in a single instruction prevents simply using &lt;code&gt;&quot;+rm&quot; 
(output) : &quot;irm&quot; (input)&lt;/code&gt;. Using multi-alternatives, this might be written as &lt;code&gt;&quot;+m,r&quot; (output) : &quot;ir,irm&quot; (input)&lt;/code&gt;. This describes all the available alternatives to the compiler, allowing it to choose the most efficient one for the current conditions.</source>
          <target state="translated">因此，68000的逻辑或的第一种选择可以写为 &lt;code&gt;&quot;+m&quot; (output) : &quot;ir&quot; (input)&lt;/code&gt; 。第二个可以是 &lt;code&gt;&quot;+r&quot; (output): &quot;irm&quot; (input)&lt;/code&gt; 。但是，不能在单个指令中使用两个内存位置这一事实阻止了仅使用 &lt;code&gt;&quot;+rm&quot; (output) : &quot;irm&quot; (input)&lt;/code&gt; 。使用多种选择，可以写成 &lt;code&gt;&quot;+m,r&quot; (output) : &quot;ir,irm&quot; (input)&lt;/code&gt; 。这描述了编译器的所有可用替代方案，从而使它可以为当前条件选择最有效的替代方案。</target>
        </trans-unit>
        <trans-unit id="3274a855ec94ec43ea5e4111fdadde792b5b93db" translate="yes" xml:space="preserve">
          <source>So, for example,</source>
          <target state="translated">所以,比如说:</target>
        </trans-unit>
        <trans-unit id="059987d18facbbac8112608278433db26ec67739" translate="yes" xml:space="preserve">
          <source>Software developers also use coverage testing in concert with testsuites, to make sure software is actually good enough for a release. Testsuites can verify that a program works as expected; a coverage program tests to see how much of the program is exercised by the testsuite. Developers can then determine what kinds of test cases need to be added to the testsuites to create both better testing and a better final product.</source>
          <target state="translated">软件开发人员还将覆盖率测试与测试套件协同使用,以确保软件实际足够好,可以发布。测试套件可以验证一个程序是否能按预期工作;覆盖率程序测试则是看测试套件行使了多少程序。然后,开发人员可以确定需要在测试套件中添加什么样的测试用例,以创建更好的测试和更好的最终产品。</target>
        </trans-unit>
        <trans-unit id="3fb15357d03c25c5a9704aae9669697852ee9b79" translate="yes" xml:space="preserve">
          <source>Solaris targets support the &lt;code&gt;cmn_err&lt;/code&gt; (or &lt;code&gt;__cmn_err__&lt;/code&gt;) format check. &lt;code&gt;cmn_err&lt;/code&gt; accepts a subset of the standard &lt;code&gt;printf&lt;/code&gt; conversions, and the two-argument &lt;code&gt;%b&lt;/code&gt; conversion for displaying bit-fields. See the Solaris man page for &lt;code&gt;cmn_err&lt;/code&gt; for more information.</source>
          <target state="translated">Solaris目标支持 &lt;code&gt;cmn_err&lt;/code&gt; （或 &lt;code&gt;__cmn_err__&lt;/code&gt; ）格式检查。 &lt;code&gt;cmn_err&lt;/code&gt; 接受标准 &lt;code&gt;printf&lt;/code&gt; 转换的子集，以及用于显示位字段的两个参数 &lt;code&gt;%b&lt;/code&gt; 转换。有关更多信息，请参见Solaris手册页的 &lt;code&gt;cmn_err&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="00b2aad45d07b70e1b7eefea74316913901b6e42" translate="yes" xml:space="preserve">
          <source>Some</source>
          <target state="translated">Some</target>
        </trans-unit>
        <trans-unit id="50992012bdba46e4be18c1991255dee68fa34161" translate="yes" xml:space="preserve">
          <source>Some 387 emulators do not support the &lt;code&gt;sin&lt;/code&gt;, &lt;code&gt;cos&lt;/code&gt; and &lt;code&gt;sqrt&lt;/code&gt; instructions for the 387. Specify this option to avoid generating those instructions. This option is overridden when</source>
          <target state="translated">某些387仿真器不支持387的 &lt;code&gt;sin&lt;/code&gt; ， &lt;code&gt;cos&lt;/code&gt; 和 &lt;code&gt;sqrt&lt;/code&gt; 指令。指定此选项以避免生成那些指令。该选项在以下情况下被覆盖</target>
        </trans-unit>
        <trans-unit id="e8e19b82266af7db1443a3fea1acad2ebf9ad814" translate="yes" xml:space="preserve">
          <source>Some &lt;code&gt;asm&lt;/code&gt; statements may need extra stack space for internal calculations. This can be guaranteed by clobbering stack registers unrelated to the inputs and outputs.</source>
          <target state="translated">一些 &lt;code&gt;asm&lt;/code&gt; 语句可能需要额外的堆栈空间来进行内部计算。这可以通过破坏与输入和输出无关的堆栈寄存器来保证。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
