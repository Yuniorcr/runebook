<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="gcc">
    <body>
      <group id="gcc">
        <trans-unit id="e9932d75815f4a1da8b9c3167803247d114d4d3e" translate="yes" xml:space="preserve">
          <source>Some AVR devices (AT90S8515, ATmega103) must not skip 32-bit instructions because of a hardware erratum. Skip instructions are &lt;code&gt;SBRS&lt;/code&gt;, &lt;code&gt;SBRC&lt;/code&gt;, &lt;code&gt;SBIS&lt;/code&gt;, &lt;code&gt;SBIC&lt;/code&gt; and &lt;code&gt;CPSE&lt;/code&gt;. The second macro is only defined if &lt;code&gt;__AVR_HAVE_JMP_CALL__&lt;/code&gt; is also set.</source>
          <target state="translated">由于硬件问题，某些AVR设备（AT90S8515，ATmega103）不得跳过32位指令。跳过指令为 &lt;code&gt;SBRS&lt;/code&gt; ， &lt;code&gt;SBRC&lt;/code&gt; ， &lt;code&gt;SBIS&lt;/code&gt; ， &lt;code&gt;SBIC&lt;/code&gt; 和 &lt;code&gt;CPSE&lt;/code&gt; 。仅当还设置了 &lt;code&gt;__AVR_HAVE_JMP_CALL__&lt;/code&gt; 时,才定义第二个宏。</target>
        </trans-unit>
        <trans-unit id="b8587f1a252be44a26b4bf83b41b8cacfabe3c53" translate="yes" xml:space="preserve">
          <source>Some AVR devices support memories larger than the 64 KiB range that can be accessed with 16-bit pointers. To access memory locations outside this 64 KiB range, the content of a &lt;code&gt;RAMP&lt;/code&gt; register is used as high part of the address: The &lt;code&gt;X&lt;/code&gt;, &lt;code&gt;Y&lt;/code&gt;, &lt;code&gt;Z&lt;/code&gt; address register is concatenated with the &lt;code&gt;RAMPX&lt;/code&gt;, &lt;code&gt;RAMPY&lt;/code&gt;, &lt;code&gt;RAMPZ&lt;/code&gt; special function register, respectively, to get a wide address. Similarly, &lt;code&gt;RAMPD&lt;/code&gt; is used together with direct addressing.</source>
          <target state="translated">某些AVR设备支持的内存大于可以使用16位指针访问的64 KiB范围。要访问此64 KiB范围以外的存储器位置， &lt;code&gt;RAMP&lt;/code&gt; 寄存器的内容用作地址的高位部分： &lt;code&gt;X&lt;/code&gt; ， &lt;code&gt;Y&lt;/code&gt; ， &lt;code&gt;Z&lt;/code&gt; 地址寄存器分别与 &lt;code&gt;RAMPX&lt;/code&gt; ， &lt;code&gt;RAMPY&lt;/code&gt; ， &lt;code&gt;RAMPZ&lt;/code&gt; 特殊功能寄存器串联，以获取广泛的地址。同样， &lt;code&gt;RAMPD&lt;/code&gt; 与直接寻址一起使用。</target>
        </trans-unit>
        <trans-unit id="b652248718bfad5072f0c61fa63785c614519d9b" translate="yes" xml:space="preserve">
          <source>Some Cortex-M3 cores can cause data corruption when &lt;code&gt;ldrd&lt;/code&gt; instructions with overlapping destination and base registers are used. This option avoids generating these instructions. This option is enabled by default when</source>
          <target state="translated">当使用目标地址和基址寄存器重叠的 &lt;code&gt;ldrd&lt;/code&gt; 指令时，某些Cortex-M3内核可能会导致数据损坏。此选项避免生成这些指令。默认情况下，此选项处于启用状态</target>
        </trans-unit>
        <trans-unit id="de0fd695fef81a6e3c397b49019c4e2e00e1f0cc" translate="yes" xml:space="preserve">
          <source>Some GCC compilation options cause the compiler to generate code that does not conform to the platform&amp;rsquo;s default ABI. Other options cause different program behavior for implementation-defined features that are not covered by an ABI. These options are provided for consistency with other compilers that do not follow the platform&amp;rsquo;s default ABI or the usual behavior of implementation-defined features for the platform. Be very careful about using such options.</source>
          <target state="translated">一些GCC编译选项会导致编译器生成不符合平台默认ABI的代码。其他选项会导致ABI并未涵盖的针对实现定义的功能的不同程序行为。提供这些选项是为了与不遵循平台默认ABI或平台实现定义功能的通常行为的其他编译器保持一致。使用此类选项时要非常小心。</target>
        </trans-unit>
        <trans-unit id="0325ca2d082f6bb9f5d1e5e855cb8121b2560adb" translate="yes" xml:space="preserve">
          <source>Some ISO C testsuites report failure when the compiler does not produce an error message for a certain program.</source>
          <target state="translated">当编译器没有为某个程序产生错误信息时,一些ISO C测试套件会报告失败。</target>
        </trans-unit>
        <trans-unit id="84f1bb1b30ec55b3fd5d6eb1c7f6faa03400485d" translate="yes" xml:space="preserve">
          <source>Some additional environment variables affect the behavior of the preprocessor.</source>
          <target state="translated">一些额外的环境变量会影响预处理器的行为。</target>
        </trans-unit>
        <trans-unit id="5045e735a2d8c7129e122a97ea30410aa9319aed" translate="yes" xml:space="preserve">
          <source>Some assemblers only support this flag when &lt;var&gt;n&lt;/var&gt; is a power of two; in that case, it is rounded up.</source>
          <target state="translated">某些汇编程序仅在 &lt;var&gt;n&lt;/var&gt; 为2的幂时才支持此标志。在这种情况下，将其四舍五入。</target>
        </trans-unit>
        <trans-unit id="2ceba313d16765bb5b6ec17c1ebb8d3d9c14df42" translate="yes" xml:space="preserve">
          <source>Some attributes only make sense for C++ programs.</source>
          <target state="translated">有些属性只对C++程序有意义。</target>
        </trans-unit>
        <trans-unit id="81c2a3663ddcd2a93314c07f339088b18a9513ff" translate="yes" xml:space="preserve">
          <source>Some cases of unnamed fields in structures and unions are only accepted with this option. See &lt;a href=&quot;unnamed-fields#Unnamed-Fields&quot;&gt;Unnamed struct/union fields within structs/unions&lt;/a&gt;, for details.</source>
          <target state="translated">仅在此选项中接受结构和联合中未命名字段的某些情况。有关详细信息，请参见&lt;a href=&quot;unnamed-fields#Unnamed-Fields&quot;&gt;结构/联合中的未命名结构/联合字段&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="15750fff39388c96e233f1fff7614239f8996f69" translate="yes" xml:space="preserve">
          <source>Some characters in ISO 10646 have distinct meanings but look identical in some fonts or display methodologies, especially once formatting has been applied. For instance &lt;code&gt;\u207F&lt;/code&gt;, &amp;ldquo;SUPERSCRIPT LATIN SMALL LETTER N&amp;rdquo;, displays just like a regular &lt;code&gt;n&lt;/code&gt; that has been placed in a superscript. ISO 10646 defines the &lt;em&gt;NFKC&lt;/em&gt; normalization scheme to convert all these into a standard form as well, and GCC warns if your code is not in NFKC if you use</source>
          <target state="translated">ISO 10646中的某些字符具有不同的含义，但是在某些字体或显示方法上看起来相同，尤其是在应用格式后。例如 &lt;code&gt;\u207F&lt;/code&gt; ，&amp;ldquo; SUPERSCRIPT 拉丁文小写字母 N&amp;rdquo;，显示的方式就像放置在上标中的常规 &lt;code&gt;n&lt;/code&gt; 一样。ISO 10646定义了&lt;em&gt;NFKC&lt;/em&gt;规范化方案，也将所有这些都转换为标准格式，如果您使用的代码不在NFKC中，则GCC会发出警告</target>
        </trans-unit>
        <trans-unit id="5d2e5736cfa0533f11cc548a18ee8de7127f23cf" translate="yes" xml:space="preserve">
          <source>Some checkers are disabled by default (even with</source>
          <target state="translated">有些检查器是默认禁用的(即使是在使用了</target>
        </trans-unit>
        <trans-unit id="06da659fa22deee4cc3d56729c6b4abce7edba00" translate="yes" xml:space="preserve">
          <source>Some choices depend on the externally determined ABI for the platform (including standard character encodings) which GCC follows; these are listed as &amp;ldquo;determined by ABI&amp;rdquo; below. See &lt;a href=&quot;compatibility#Compatibility&quot;&gt;Binary Compatibility&lt;/a&gt;, and &lt;a href=&quot;http://gcc.gnu.org/readings.html&quot;&gt;http://gcc.gnu.org/readings.html&lt;/a&gt;. Some choices are documented in the preprocessor manual. See &lt;a href=&quot;http://gcc.gnu.org/onlinedocs/cpp/Implementation_002ddefined-behavior.html#Implementation_002ddefined-behavior&quot;&gt;Implementation-defined behavior&lt;/a&gt; in The C Preprocessor. Some choices are documented in the corresponding document for the C language. See &lt;a href=&quot;c-implementation#C-Implementation&quot;&gt;C Implementation&lt;/a&gt;. Some choices are made by the library and operating system (or other environment when compiling for a freestanding environment); refer to their documentation for details.</source>
          <target state="translated">一些选择取决于GCC遵循的平台的外部确定的ABI（包括标准字符编码）。这些在下面被列为&amp;ldquo;由ABI决定&amp;rdquo;。请参阅&lt;a href=&quot;compatibility#Compatibility&quot;&gt;二进制兼容性&lt;/a&gt;，以及&lt;a href=&quot;http://gcc.gnu.org/readings.html&quot;&gt;http://gcc.gnu.org/readings.html&lt;/a&gt;。预处理程序手册中记录了一些选择。请参见C预处理器中&lt;a href=&quot;http://gcc.gnu.org/onlinedocs/cpp/Implementation_002ddefined-behavior.html#Implementation_002ddefined-behavior&quot;&gt;实现定义的行为&lt;/a&gt;。一些选择记录在C语言的相应文档中。请参见&lt;a href=&quot;c-implementation#C-Implementation&quot;&gt;C实现&lt;/a&gt;。库和操作系统（或为独立环境编译时的其他环境）做出了一些选择；有关详细信息，请参阅其文档。</target>
        </trans-unit>
        <trans-unit id="258878cc764e88fa980c6c9ddf4a6f80e9d5cd8f" translate="yes" xml:space="preserve">
          <source>Some choices depend on the externally determined ABI for the platform (including standard character encodings) which GCC follows; these are listed as &amp;ldquo;determined by ABI&amp;rdquo; below. See &lt;a href=&quot;compatibility#Compatibility&quot;&gt;Binary Compatibility&lt;/a&gt;, and &lt;a href=&quot;http://gcc.gnu.org/readings.html&quot;&gt;http://gcc.gnu.org/readings.html&lt;/a&gt;. Some choices are documented in the preprocessor manual. See &lt;a href=&quot;http://gcc.gnu.org/onlinedocs/cpp/Implementation_002ddefined-behavior.html#Implementation_002ddefined-behavior&quot;&gt;Implementation-defined behavior&lt;/a&gt; in The C Preprocessor. Some choices are made by the library and operating system (or other environment when compiling for a freestanding environment); refer to their documentation for details.</source>
          <target state="translated">一些选择取决于GCC遵循的平台的外部确定的ABI（包括标准字符编码）。这些在下面被列为&amp;ldquo;由ABI决定&amp;rdquo;。请参阅&lt;a href=&quot;compatibility#Compatibility&quot;&gt;二进制兼容性&lt;/a&gt;，以及&lt;a href=&quot;http://gcc.gnu.org/readings.html&quot;&gt;http://gcc.gnu.org/readings.html&lt;/a&gt;。预处理程序手册中记录了一些选择。请参见C预处理器中&lt;a href=&quot;http://gcc.gnu.org/onlinedocs/cpp/Implementation_002ddefined-behavior.html#Implementation_002ddefined-behavior&quot;&gt;实现定义的行为&lt;/a&gt;。库和操作系统（或为独立环境编译时的其他环境）做出了一些选择；有关详细信息，请参阅其文档。</target>
        </trans-unit>
        <trans-unit id="15506c8b8d5d6b275040aeee640a2a5a3f7d4d37" translate="yes" xml:space="preserve">
          <source>Some common examples of pure functions are &lt;code&gt;strlen&lt;/code&gt; or &lt;code&gt;memcmp&lt;/code&gt;. Interesting non-pure functions are functions with infinite loops or those depending on volatile memory or other system resource, that may change between consecutive calls (such as the standard C &lt;code&gt;feof&lt;/code&gt; function in a multithreading environment).</source>
          <target state="translated">纯函数的一些常见示例是 &lt;code&gt;strlen&lt;/code&gt; 或 &lt;code&gt;memcmp&lt;/code&gt; 。有趣的非纯函数是具有无限循环的函数或取决于易失性内存或其他系统资源的函数，这些函数可能会在连续调用之间改变（例如，多线程环境中的标准C &lt;code&gt;feof&lt;/code&gt; 函数）。</target>
        </trans-unit>
        <trans-unit id="12ce1dfd34507685834493a64bea0bb0f207ab99" translate="yes" xml:space="preserve">
          <source>Some computer manufacturers have published Application Binary Interface standards which specify that plain bit-fields should be unsigned. It is a mistake, however, to say anything about this issue in an ABI. This is because the handling of plain bit-fields distinguishes two dialects of C. Both dialects are meaningful on every type of machine. Whether a particular object file was compiled using signed bit-fields or unsigned is of no concern to other object files, even if they access the same bit-fields in the same data structures.</source>
          <target state="translated">一些计算机制造商已经发布了应用二进制接口标准,规定纯位字段应该是无符号的。然而,在ABI中对这个问题说三道四是个错误。这是因为对明码位字的处理区分了两种C语言,这两种语言在每一种机器上都是有意义的。一个特定的对象文件是使用有符号的位字段还是无符号的位字段编译的,对于其他的对象文件来说是没有关系的,即使它们在相同的数据结构中访问相同的位字段。</target>
        </trans-unit>
        <trans-unit id="71e1ac9ab0109c68aee90fe9c98e8024ac2ba20a" translate="yes" xml:space="preserve">
          <source>Some configurations of the compiler also support additional target-specific options, usually for compatibility with other compilers on the same platform.</source>
          <target state="translated">编译器的某些配置还支持额外的特定目标选项,通常是为了与同一平台上的其他编译器兼容。</target>
        </trans-unit>
        <trans-unit id="efc299e6d6d519531f7a42935a2ff0371856c97e" translate="yes" xml:space="preserve">
          <source>Some developers use Local Register Variables in an attempt to improve gcc&amp;rsquo;s allocation of registers, especially in large functions. In this case the register name is essentially a hint to the register allocator. While in some instances this can generate better code, improvements are subject to the whims of the allocator/optimizers. Since there are no guarantees that your improvements won&amp;rsquo;t be lost, this usage of Local Register Variables is discouraged.</source>
          <target state="translated">一些开发人员使用本地寄存器变量来尝试改善gcc的寄存器分配，特别是在大型函数中。在这种情况下，寄存器名称实际上是对寄存器分配器的提示。虽然在某些情况下这可以生成更好的代码，但改进取决于分配器/优化器的要求。由于不能保证您的改进不会丢失，因此不建议使用此本地寄存器变量。</target>
        </trans-unit>
        <trans-unit id="cd13c19c4da21f1c5afd2756424c80ed7c852869" translate="yes" xml:space="preserve">
          <source>Some devices support reading from flash memory by means of &lt;code&gt;LD*&lt;/code&gt; instructions. The flash memory is seen in the data address space at an offset of &lt;code&gt;__AVR_PM_BASE_ADDRESS__&lt;/code&gt;. If this macro is not defined, this feature is not available. If defined, the address space is linear and there is no need to put &lt;code&gt;.rodata&lt;/code&gt; into RAM. This is handled by the default linker description file, and is currently available for &lt;code&gt;avrtiny&lt;/code&gt; and &lt;code&gt;avrxmega3&lt;/code&gt;. Even more convenient, there is no need to use address spaces like &lt;code&gt;__flash&lt;/code&gt; or features like attribute &lt;code&gt;progmem&lt;/code&gt; and &lt;code&gt;pgm_read_*&lt;/code&gt;.</source>
          <target state="translated">某些设备支持通过 &lt;code&gt;LD*&lt;/code&gt; 指令从闪存读取。闪存在数据地址空间中以 &lt;code&gt;__AVR_PM_BASE_ADDRESS__&lt;/code&gt; 的偏移量出现。如果未定义此宏，则此功能不可用。如果已定义，则地址空间是线性的，无需将 &lt;code&gt;.rodata&lt;/code&gt; 放入RAM。这由默认链接器描述文件处理，并且当前可用于 &lt;code&gt;avrtiny&lt;/code&gt; 和 &lt;code&gt;avrxmega3&lt;/code&gt; 。更方便的是，无需使用诸如 &lt;code&gt;__flash&lt;/code&gt; 之类的地址空间或诸如 &lt;code&gt;progmem&lt;/code&gt; 和 &lt;code&gt;pgm_read_*&lt;/code&gt; 之类的功能。</target>
        </trans-unit>
        <trans-unit id="12cca45385c65440f1fac5331dbdc800f8010a0a" translate="yes" xml:space="preserve">
          <source>Some features that are in ISO C99 but not C90 or C++ are also, as extensions, accepted by GCC in C90 mode and in C++.</source>
          <target state="translated">一些在ISO C99中,但在C90或C++中没有的功能,作为扩展,在C90模式和C++中也被GCC接受。</target>
        </trans-unit>
        <trans-unit id="768fab3712868916420b11c9d81a46a5d1e9bab0" translate="yes" xml:space="preserve">
          <source>Some file formats do not support arbitrary sections so the &lt;code&gt;section&lt;/code&gt; attribute is not available on all platforms. If you need to map the entire contents of a module to a particular section, consider using the facilities of the linker instead.</source>
          <target state="translated">某些文件格式不支持任意节，因此 &lt;code&gt;section&lt;/code&gt; 属性在所有平台上均不可用。如果需要将模块的全部内容映射到特定部分，请考虑改用链接器的功能。</target>
        </trans-unit>
        <trans-unit id="63737560dbee375bb4595f35dcce3b604d447957" translate="yes" xml:space="preserve">
          <source>Some function attributes take one or more arguments that refer to the function&amp;rsquo;s parameters by their positions within the function parameter list. Such attribute arguments are referred to as &lt;em&gt;positional arguments&lt;/em&gt;. Unless specified otherwise, positional arguments that specify properties of parameters with pointer types can also specify the same properties of the implicit C++ &lt;code&gt;this&lt;/code&gt; argument in non-static member functions, and of parameters of reference to a pointer type. For ordinary functions, position one refers to the first parameter on the list. In C++ non-static member functions, position one refers to the implicit &lt;code&gt;this&lt;/code&gt; pointer. The same restrictions and effects apply to function attributes used with ordinary functions or C++ member functions.</source>
          <target state="translated">某些函数属性采用一个或多个参数，这些参数通过它们在函数参数列表中的位置来引用函数的参数。这种属性参数称为&lt;em&gt;位置参数&lt;/em&gt;。除非另有说明，否则使用指针类型指定参数属性的位置参数还可指定与非静态成员函数中的隐式C ++ &lt;code&gt;this&lt;/code&gt; 参数以及引用指针类型的参数相同的属性。对于普通功能，位置一是指列表中的第一个参数。在C ++非静态成员函数中，位置1引用隐式 &lt;code&gt;this&lt;/code&gt; 指针。相同的限制和效果适用于与普通函数或C ++成员函数一起使用的函数属性。</target>
        </trans-unit>
        <trans-unit id="fb33f99a987006c02f399310559443d2a427b3a7" translate="yes" xml:space="preserve">
          <source>Some lines of information at the start have &lt;var&gt;line_number&lt;/var&gt; of zero. These preamble lines are of the form</source>
          <target state="translated">开头的某些信息行的 &lt;var&gt;line_number&lt;/var&gt; 为零。这些前导行的形式为</target>
        </trans-unit>
        <trans-unit id="9e5021e481328ac057640ef2a536800d9166dbbe" translate="yes" xml:space="preserve">
          <source>Some linkers are capable of detecting out-of-range calls and generating glue code on the fly. On these systems, long calls are unnecessary and generate slower code. As of this writing, the AIX linker can do this, as can the GNU linker for PowerPC/64. It is planned to add this feature to the GNU linker for 32-bit PowerPC systems as well.</source>
          <target state="translated">有些链接器能够检测范围外的调用,并在飞行中生成胶水代码。在这些系统上,长调用是不必要的,而且生成的代码也比较慢。到目前为止,AIX链接器可以做到这一点,PowerPC/64的GNU链接器也可以。计划在32位PowerPC系统的GNU链接器中也增加这个功能。</target>
        </trans-unit>
        <trans-unit id="e7ded2d98e8ad6e738cfb416e0e144f7c6488a8f" translate="yes" xml:space="preserve">
          <source>Some machines never actually require alignment; they allow references to any data type even at an odd address. For these machines, &lt;code&gt;__alignof__&lt;/code&gt; reports the smallest alignment that GCC gives the data type, usually as mandated by the target ABI.</source>
          <target state="translated">有些机器实际上从来不需要对齐；它们甚至允许在奇数地址处引用任何数据类型。对于这些机器， &lt;code&gt;__alignof__&lt;/code&gt; 报告通常由目标ABI要求的GCC给出数据类型的最小对齐方式。</target>
        </trans-unit>
        <trans-unit id="e609cdc1429a6fcb8d2a4566b95c795a179f9f38" translate="yes" xml:space="preserve">
          <source>Some more examples of the use of &lt;code&gt;typeof&lt;/code&gt;:</source>
          <target state="translated">使用 &lt;code&gt;typeof&lt;/code&gt; 的更多示例：</target>
        </trans-unit>
        <trans-unit id="97a9b6bbb4ff568061400bba291a0fa95f27baca" translate="yes" xml:space="preserve">
          <source>Some object formats, like ELF, allow interposing of symbols by the dynamic linker. This means that for symbols exported from the DSO, the compiler cannot perform interprocedural propagation, inlining and other optimizations in anticipation that the function or variable in question may change. While this feature is useful, for example, to rewrite memory allocation functions by a debugging implementation, it is expensive in the terms of code quality. With</source>
          <target state="translated">有些对象格式,如ELF,允许动态链接器对符号进行穿插。这意味着对于从DSO导出的符号,编译器不能在预期有关函数或变量可能发生变化的情况下进行程序间传播、内联和其他优化。虽然这个功能很有用,例如,由调试实现重写内存分配函数,但从代码质量的角度来看,这个功能是昂贵的。有了</target>
        </trans-unit>
        <trans-unit id="53b2cdebe3092f05376eba4dc6edb1163b208474" translate="yes" xml:space="preserve">
          <source>Some of these problems are due to bugs in other software, some are missing features that are too much work to add, and some are places where people&amp;rsquo;s opinions differ as to what is best.</source>
          <target state="translated">这些问题中的一些是由于其他软件的错误所致，有些是缺少功能而又无法添加的功能，还有一些是人们对最佳方法有不同意见的地方。</target>
        </trans-unit>
        <trans-unit id="e5a8bcdbd9732dbb47db6e251241faa598f69eaa" translate="yes" xml:space="preserve">
          <source>Some operands need to be in particular places on the stack. All output operands fall in this category&amp;mdash;GCC has no other way to know which registers the outputs appear in unless you indicate this in the constraints.</source>
          <target state="translated">一些操作数需要放在堆栈中的特定位置。所有输出操作数都属于此类别-GCC没有其他方法可以知道输出出现在哪个寄存器中，除非您在约束中指出。</target>
        </trans-unit>
        <trans-unit id="7bc3611475871be65cea3ae1eb8a4118c1e3da02" translate="yes" xml:space="preserve">
          <source>Some options for compiling C programs, such as</source>
          <target state="translated">编译C程序的一些选项,如</target>
        </trans-unit>
        <trans-unit id="9aab2dd921eb504a0a6bf04d60fa17f07ef07e59" translate="yes" xml:space="preserve">
          <source>Some options take one or more arguments typically separated either by a space or by the equals sign (&amp;lsquo;</source>
          <target state="translated">一些选项采用一个或多个参数，通常以空格或等号（'</target>
        </trans-unit>
        <trans-unit id="b09c01fb6d97b0be636c36b27746781fe632f575" translate="yes" xml:space="preserve">
          <source>Some options, such as</source>
          <target state="translated">一些选项,如</target>
        </trans-unit>
        <trans-unit id="8b764d6df82f9df721fda3ecd882ae472b0abef6" translate="yes" xml:space="preserve">
          <source>Some other command-line options starting with</source>
          <target state="translated">其他一些以</target>
        </trans-unit>
        <trans-unit id="2b1de7c862240cc77fd4597210b6bd463edb0754" translate="yes" xml:space="preserve">
          <source>Some spurious warnings can be avoided if you declare all the functions you use that never return as &lt;code&gt;noreturn&lt;/code&gt;. See &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;Function Attributes&lt;/a&gt;.</source>
          <target state="translated">如果你申报你使用有去无回的功能，可避免一些虚假的警告 &lt;code&gt;noreturn&lt;/code&gt; 。请参阅&lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;函数属性&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0b7a7ebb3620b1d731c5783bb7dadf2877e0be61" translate="yes" xml:space="preserve">
          <source>Some targets have a special register that holds the &amp;ldquo;flags&amp;rdquo; for the result of an operation or comparison. Normally, the contents of that register are either unmodifed by the asm, or the &lt;code&gt;asm&lt;/code&gt; statement is considered to clobber the contents.</source>
          <target state="translated">一些目标有一个特殊的寄存器，用于保存操作或比较结果的&amp;ldquo;标志&amp;rdquo;。通常，该寄存器的内容不会被asm修改，或者将 &lt;code&gt;asm&lt;/code&gt; 语句视为破坏内容。</target>
        </trans-unit>
        <trans-unit id="ece7407fc707518ca6db13a249080d20314edfb1" translate="yes" xml:space="preserve">
          <source>Some targets require that GCC track the size of each instruction used in order to generate correct code. Because the final length of the code produced by an &lt;code&gt;asm&lt;/code&gt; statement is only known by the assembler, GCC must make an estimate as to how big it will be. It does this by counting the number of instructions in the pattern of the &lt;code&gt;asm&lt;/code&gt; and multiplying that by the length of the longest instruction supported by that processor. (When working out the number of instructions, it assumes that any occurrence of a newline or of whatever statement separator character is supported by the assembler &amp;mdash; typically &amp;lsquo;</source>
          <target state="translated">有些目标要求GCC跟踪使用的每条指令的大小，以便生成正确的代码。由于 &lt;code&gt;asm&lt;/code&gt; 语句生成的代码的最终长度仅由汇编程序知道，因此GCC必须估算其大小。它通过对 &lt;code&gt;asm&lt;/code&gt; 模式中的指令数进行计数并将其乘以该处理器支持的最长指令的长度来实现。 （计算指令数时，假定汇编程序支持出现换行符或任何语句分隔符的情况，通常是&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="d9a576a0cb85284fa181b1af5cb015b4bd820399" translate="yes" xml:space="preserve">
          <source>Some targets, e.g. x86 and PowerPC, support the &lt;code&gt;#pragma ms_struct&lt;/code&gt; directive which lays out structures and unions subsequently defined as the documented &lt;code&gt;__attribute__ ((ms_struct))&lt;/code&gt;.</source>
          <target state="translated">某些目标（例如x86和PowerPC）支持 &lt;code&gt;#pragma ms_struct&lt;/code&gt; 指令，该指令列出了随后定义为已记录的 &lt;code&gt;__attribute__ ((ms_struct))&lt;/code&gt; 结构和联合。</target>
        </trans-unit>
        <trans-unit id="32c528c0b130160ed58ee14f8bbba2d7a132054b" translate="yes" xml:space="preserve">
          <source>Some users try to use</source>
          <target state="translated">一些用户尝试使用</target>
        </trans-unit>
        <trans-unit id="c714f3fa36461f2e5681ce26cd399297f4a56453" translate="yes" xml:space="preserve">
          <source>Some users try to use &lt;code&gt;__STDC__&lt;/code&gt; to check for the availability of certain library facilities. This is actually incorrect usage in an ISO C program, because the ISO C standard says that a conforming freestanding implementation should define &lt;code&gt;__STDC__&lt;/code&gt; even though it does not have the library facilities. &amp;lsquo;</source>
          <target state="translated">一些用户尝试使用 &lt;code&gt;__STDC__&lt;/code&gt; 来检查某些图书馆设施的可用性。这实际上在ISO C程序中是不正确的用法，因为ISO C标准规定，即使没有库工具，一个 &lt;code&gt;__STDC__&lt;/code&gt; 独立实现也应定义__STDC__。'</target>
        </trans-unit>
        <trans-unit id="6c0811681aff3d220c177a6ae42df51a4668d70d" translate="yes" xml:space="preserve">
          <source>Sometimes a single instruction has multiple alternative sets of possible operands. For example, on the 68000, a logical-or instruction can combine register or an immediate value into memory, or it can combine any kind of operand into a register; but it cannot combine one memory location into another.</source>
          <target state="translated">有时,一条指令有多套可能的操作数。例如,在68000上,一条逻辑-or指令可以将寄存器或一个即时值合并到内存中,或者它可以将任何类型的操作数合并到一个寄存器中;但它不能将一个内存位置合并到另一个内存位置。</target>
        </trans-unit>
        <trans-unit id="bcdf40850f5e7d0e40bbaa8bc961e1b76a034440" translate="yes" xml:space="preserve">
          <source>Sometimes it is desirable to write code using a mix of generic vector operations (for clarity) and machine-specific vector intrinsics (to access vector instructions that are not exposed via generic built-ins). On x86, intrinsic functions for integer vectors typically use the same vector type &lt;code&gt;__m128i&lt;/code&gt; irrespective of how they interpret the vector, making it necessary to cast their arguments and return values from/to other vector types. In C, you can make use of a &lt;code&gt;union&lt;/code&gt; type:</source>
          <target state="translated">有时，需要结合使用通用向量操作（为清楚起见）和机器特定的向量内在函数（以访问未通过通用内置函数公开的向量指令）来编写代码。在x86上，整数向量的内在函数通常使用相同的向量类型 &lt;code&gt;__m128i&lt;/code&gt; ,而不管它们如何解释向量，从而有必要强制转换其参数并从其他向量类型返回值。在C中，您可以使用 &lt;code&gt;union&lt;/code&gt; 类型：</target>
        </trans-unit>
        <trans-unit id="e7b9f7e78924f4429d79b3875d59ae1541b656fb" translate="yes" xml:space="preserve">
          <source>Sometimes people say that defining &lt;code&gt;__STDC__&lt;/code&gt; in a compiler that does not completely conform to the ISO C standard somehow violates the standard. This is illogical. The standard is a standard for compilers that claim to support ISO C, such as &amp;lsquo;</source>
          <target state="translated">有时，人们会说在不完全符合ISO C标准的编译器中定义 &lt;code&gt;__STDC__&lt;/code&gt; 会违反该标准。这是不合逻辑的。该标准是声称支持ISO C的编译器的标准，例如&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="c41073d5b9e69b8696bff1b0838e6f995522031e" translate="yes" xml:space="preserve">
          <source>Sort the symbols according to size.</source>
          <target state="translated">根据大小对符号进行排序。</target>
        </trans-unit>
        <trans-unit id="f71bf34c2cf4ef01fa642de620de6d3ffbf6ba33" translate="yes" xml:space="preserve">
          <source>Sort the symbols alphabetically.</source>
          <target state="translated">按字母顺序对符号进行排序。</target>
        </trans-unit>
        <trans-unit id="8110c50df0a3ae32bff485105c38a69468d7fdd2" translate="yes" xml:space="preserve">
          <source>Special constraints for some particular machines.</source>
          <target state="translated">对一些特殊机器的特殊限制。</target>
        </trans-unit>
        <trans-unit id="2ba4930cab85f2e9501af3573b08b92708f7a0ae" translate="yes" xml:space="preserve">
          <source>Special format strings</source>
          <target state="translated">特殊格式字符串</target>
        </trans-unit>
        <trans-unit id="2a9d5504a562859df5546c189640d36f2ebdc1bd" translate="yes" xml:space="preserve">
          <source>Special syntax for implementing &lt;code&gt;offsetof&lt;/code&gt;.</source>
          <target state="translated">实现 &lt;code&gt;offsetof&lt;/code&gt; 的特殊语法。</target>
        </trans-unit>
        <trans-unit id="253477bfce70caeee68c5d46f4cbdd5958d04b09" translate="yes" xml:space="preserve">
          <source>Specifier</source>
          <target state="translated">Specifier</target>
        </trans-unit>
        <trans-unit id="fae65de83d82c109b91ff281d719a67482b13328" translate="yes" xml:space="preserve">
          <source>Specifies a C lvalue expression to hold the output, typically a variable name. The enclosing parentheses are a required part of the syntax.</source>
          <target state="translated">指定一个C lvalue表达式来保存输出,通常是一个变量名。括号是语法的必要部分。</target>
        </trans-unit>
        <trans-unit id="05513a361baed0fc6bc2b4e7e1181bfda41a5c6c" translate="yes" xml:space="preserve">
          <source>Specifies a symbolic name for the operand. Reference the name in the assembler template by enclosing it in square brackets (i.e. &amp;lsquo;</source>
          <target state="translated">指定操作数的符号名称。通过在方括号中将名称括起来（例如，&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="c765ec9a6362d918fb2bf1565e87927ec8cd6358" translate="yes" xml:space="preserve">
          <source>Specifies general-purposes registers that the processor automatically saves/restores on interrupt entry and exit. &lt;var&gt;register-range&lt;/var&gt; is specified as two registers separated by a dash. The register range always starts with &lt;code&gt;r0&lt;/code&gt;, the upper limit is &lt;code&gt;fp&lt;/code&gt; register. &lt;var&gt;blink&lt;/var&gt; and &lt;var&gt;lp_count&lt;/var&gt; are optional. This option is only valid for ARC EM and ARC HS cores.</source>
          <target state="translated">指定处理器在中断进入和退出时自动保存/恢复的通用寄存器。 &lt;var&gt;register-range&lt;/var&gt; 指定为两个用破折号分隔的寄存器。寄存器范围始终以 &lt;code&gt;r0&lt;/code&gt; 开头，上限为 &lt;code&gt;fp&lt;/code&gt; 寄存器。 &lt;var&gt;blink&lt;/var&gt; 和 &lt;var&gt;lp_count&lt;/var&gt; 是可选的。此选项仅对ARC EM和ARC HS内核有效。</target>
        </trans-unit>
        <trans-unit id="f3854791e88bad573a0be4f46ed869cefa1b475c" translate="yes" xml:space="preserve">
          <source>Specifies maximal growth of large function caused by inlining in percents. For example, parameter value 100 limits large function growth to 2.0 times the original size.</source>
          <target state="translated">指定由内衬引起的大函数的最大增长,单位为百分数。例如,参数值100限制大函数增长到原来的2.0倍。</target>
        </trans-unit>
        <trans-unit id="dfe06371f415167055f13157f6cd31af5c5dbd88" translate="yes" xml:space="preserve">
          <source>Specifies maximal growth of large stack frames caused by inlining in percents. For example, parameter value 1000 limits large stack frame growth to 11 times the original size.</source>
          <target state="translated">以百分比为单位,指定由inlining引起的大堆栈框架的最大增长。例如,参数值1000限制了大堆栈框架的增长,使其达到原始大小的11倍。</target>
        </trans-unit>
        <trans-unit id="94731e3c8ea6ab127a428ca6dbbe480337db1263" translate="yes" xml:space="preserve">
          <source>Specifies maximal overall growth of the compilation unit caused by inlining. For example, parameter value 20 limits unit growth to 1.2 times the original size. Cold functions (either marked cold via an attribute or by profile feedback) are not accounted into the unit size.</source>
          <target state="translated">指定内联导致的编译单元的最大整体增长。例如,参数值20限制了单元增长到原始大小的1.2倍。冷函数(通过属性或配置文件反馈标记为冷函数)不计入单元大小。</target>
        </trans-unit>
        <trans-unit id="f6a6169df4d1b9f4ae3a854ae149c4bc3eb831c7" translate="yes" xml:space="preserve">
          <source>Specifies maximal overall growth of the compilation unit caused by interprocedural constant propagation. For example, parameter value 10 limits unit growth to 1.1 times the original size.</source>
          <target state="translated">指定由程序间常数传播引起的编译单元的最大整体增长。例如,参数值10将单位增长限制为原始大小的1.1倍。</target>
        </trans-unit>
        <trans-unit id="c09858fd018d531b5e4ff4ecd665a6f14de1bdc3" translate="yes" xml:space="preserve">
          <source>Specifies that interrupt handler functions should preserve the MDUC registers. This is only necessary if normal code might use the MDUC registers, for example because it performs multiplication and division operations. The default is to ignore the MDUC registers as this makes the interrupt handlers faster. The target option -mg13 needs to be passed for this to work as this feature is only available on the G13 target (S2 core). The MDUC registers will only be saved if the interrupt handler performs a multiplication or division operation or it calls another function.</source>
          <target state="translated">指定中断处理函数应保留 MDUC 寄存器。只有当正常的代码可能使用 MDUC 寄存器时才需要这样做,例如,因为它执行乘法和除法操作。默认情况下是忽略 MDUC 寄存器,因为这样可以使中断处理程序更快。需要通过目标选项 -mg13 来实现这一功能,因为这一功能只在 G13 目标(S2 内核)上可用。只有当中断处理程序执行乘法或除法操作或调用其他函数时,才会保存 MDUC 寄存器。</target>
        </trans-unit>
        <trans-unit id="e16a3667d78dbf88b960c5650973c17d00b701b4" translate="yes" xml:space="preserve">
          <source>Specifies that interrupt handler functions should preserve the accumulator register. This is only necessary if normal code might use the accumulator register, for example because it performs 64-bit multiplications. The default is to ignore the accumulator as this makes the interrupt handlers faster.</source>
          <target state="translated">指定中断处理函数应保留累加器寄存器。只有当普通代码可能使用累加器寄存器时,才需要这样做,例如,因为它执行64位乘法。默认值是忽略累加器,因为这样可以使中断处理程序更快。</target>
        </trans-unit>
        <trans-unit id="b7effad23ab12e24339284e6f0eafe7d16434faa" translate="yes" xml:space="preserve">
          <source>Specifies that the PRU CTABLE entry given by &lt;var&gt;index&lt;/var&gt; has the value &lt;var&gt;constant_address&lt;/var&gt;. This enables GCC to emit LBCO/SBCO instructions when the load/store address is known and can be addressed with some CTABLE entry. For example:</source>
          <target state="translated">指定 &lt;var&gt;index&lt;/var&gt; 给出的PRU CTABLE条目的值为 &lt;var&gt;constant_address&lt;/var&gt; 。当加载/存储地址已知并且可以通过某些CTABLE条目进行寻址时，这使GCC能够发出LBCO / SBCO指令。例如：</target>
        </trans-unit>
        <trans-unit id="dd671f6f6086870972e15aa7905ec8f7db267ac7" translate="yes" xml:space="preserve">
          <source>Specifies that the cache cannot be flushed by using a trap.</source>
          <target state="translated">指定不能通过使用陷阱来刷新缓存。</target>
        </trans-unit>
        <trans-unit id="47947b45b4744585e55d8f763014a0ae39516e00" translate="yes" xml:space="preserve">
          <source>Specifies that the program will be run on the simulator. This causes an alternate runtime library to be linked in which supports, for example, file I/O. You must not use this option when generating programs that will run on real hardware; you must provide your own runtime library for whatever I/O functions are needed.</source>
          <target state="translated">指定程序将在模拟器上运行。这将导致一个支持文件I/O的备用运行时库被链接进来。当生成将在真实硬件上运行的程序时,你不能使用这个选项;你必须为任何需要的I/O功能提供自己的运行时库。</target>
        </trans-unit>
        <trans-unit id="92a7b7c9a6c346e8818d5fec33b1b2c04de8591c" translate="yes" xml:space="preserve">
          <source>Specifies that the program will be run on the simulator. This causes an alternate runtime startup and library to be linked. You must not use this option when generating programs that will run on real hardware; you must provide your own runtime library for whatever I/O functions are needed.</source>
          <target state="translated">指定程序将在模拟器上运行。这将导致一个备用的运行时启动和库被链接。当生成将在真实硬件上运行的程序时,不能使用这个选项;你必须为任何需要的I/O功能提供自己的运行时库。</target>
        </trans-unit>
        <trans-unit id="cc31c50b75b75e6cf86f872d21ade4b77825de9f" translate="yes" xml:space="preserve">
          <source>Specifies that the program will be run on the simulator. This causes the simulator BSP provided by libgloss to be linked in. This option has effect only for &amp;lsquo;</source>
          <target state="translated">指定程序将在模拟器上运行。这将导致libgloss提供的模拟器BSP被链接到。此选项仅对'</target>
        </trans-unit>
        <trans-unit id="4b908ebdba88cf2c2a293fda93618017153fd58b" translate="yes" xml:space="preserve">
          <source>Specifies the ABI type to use for vectorizing intrinsics using an external library. Supported values for &lt;var&gt;type&lt;/var&gt; are &amp;lsquo;</source>
          <target state="translated">指定用于使用外部库向量化内在函数的ABI类型。支持的 &lt;var&gt;type&lt;/var&gt; 值为&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="df8e8fddb7d07761c1b84aad23b4814d921c564b" translate="yes" xml:space="preserve">
          <source>Specifies the ABI type to use for vectorizing intrinsics using an external library. The only type supported at present is &amp;lsquo;</source>
          <target state="translated">指定用于使用外部库向量化内在函数的ABI类型。目前支持的唯一类型是&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="3e1277fdc0689b726ff15cccd084ddbac36979fe" translate="yes" xml:space="preserve">
          <source>Specifies the ISA to use. Accepted values are &amp;lsquo;</source>
          <target state="translated">指定要使用的ISA。可接受的值为&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="5ca955df8b960b04d79d7dd74115e500bda85663" translate="yes" xml:space="preserve">
          <source>Specifies the RL78 core to target. The default is the G14 core, also known as an S3 core or just RL78. The G13 or S2 core does not have multiply or divide instructions, instead it uses a hardware peripheral for these operations. The G10 or S1 core does not have register banks, so it uses a different calling convention.</source>
          <target state="translated">指定要瞄准的RL78核心。默认值是G14核,也称为S3核或仅仅是RL78核。G13或S2核没有乘法或除法指令,而是使用硬件外设进行这些操作。G10或S1核没有寄存器库,所以它使用不同的调用惯例。</target>
        </trans-unit>
        <trans-unit id="f635669de18bf56a687958d1a8c71186afb495b2" translate="yes" xml:space="preserve">
          <source>Specifies the TLS dialect to use for this function. The behavior and permissible arguments are the same as for the command-line option</source>
          <target state="translated">指定本函数使用的TLS方言。其行为和允许的参数与命令行选项-------------------------------------------相同。</target>
        </trans-unit>
        <trans-unit id="c52b2c30fecaf2eb67f980f2baf7835c6acbf2e9" translate="yes" xml:space="preserve">
          <source>Specifies the architecture version and architectural extensions to use for this function. The behavior and permissible arguments are the same as for the</source>
          <target state="translated">指定本函数要使用的架构版本和架构扩展。其行为和允许的参数与本函数的</target>
        </trans-unit>
        <trans-unit id="dbbb7ebc147f28ae0dcd4250f31f3d8fd9cac55e" translate="yes" xml:space="preserve">
          <source>Specifies the core for which to tune the performance of this function and also whose architectural features to use. The behavior and valid arguments are the same as for the</source>
          <target state="translated">指定用于调整该函数性能的核心,以及使用其架构特征。的行为和有效参数与</target>
        </trans-unit>
        <trans-unit id="fe58a5c95595be8f2a1ff92d9451c73415b5a99d" translate="yes" xml:space="preserve">
          <source>Specifies the core for which to tune the performance of this function. The behavior and permissible arguments are the same as for the</source>
          <target state="translated">指定要调整该函数性能的核心。行为和允许的参数与函数的</target>
        </trans-unit>
        <trans-unit id="28873c2fbf7d823a74544bebc8a6344119496c82" translate="yes" xml:space="preserve">
          <source>Specifies the fpu for which to tune the performance of this function. The behavior and permissible arguments are the same as for the</source>
          <target state="translated">指定要调整该函数性能的fpu。其行为和允许的参数与函数的</target>
        </trans-unit>
        <trans-unit id="cce88289fcb8b24761c893dbf247fdd528b95133" translate="yes" xml:space="preserve">
          <source>Specifies the function to call to flush the I and D caches, or to not call any such function. If called, the function must take the same arguments as the common &lt;code&gt;_flush_func&lt;/code&gt;, that is, the address of the memory range for which the cache is being flushed, the size of the memory range, and the number 3 (to flush both caches). The default depends on the target GCC was configured for, but commonly is either &lt;code&gt;_flush_func&lt;/code&gt; or &lt;code&gt;__cpu_flush&lt;/code&gt;.</source>
          <target state="translated">指定要调用以刷新I和D高速缓存或不调用任何此类函数的函数。如果被调用，该函数必须采用与通用 &lt;code&gt;_flush_func&lt;/code&gt; 相同的参数，即，要为其刷新缓存的内存范围的地址，内存范围的大小和数字3（以刷新两个缓存）。默认值取决于配置的目​​标GCC，但通常是 &lt;code&gt;_flush_func&lt;/code&gt; 或 &lt;code&gt;__cpu_flush&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7671feaad590d7ec398f51bb4af652d4dc88ce38" translate="yes" xml:space="preserve">
          <source>Specifies the identification number of the ID-based shared library being compiled. Specifying a value of 0 generates more compact code; specifying other values forces the allocation of that number to the current library but is no more space- or time-efficient than omitting this option.</source>
          <target state="translated">指定正在编译的基于ID的共享库的标识号。指定0的值会产生更紧凑的代码;指定其他值会强制将该编号分配给当前库,但不会比省略该选项更节省空间和时间。</target>
        </trans-unit>
        <trans-unit id="99738458ed498047e95197f3c00800b279d2d584" translate="yes" xml:space="preserve">
          <source>Specifies the identification number of the ID-based shared library being compiled. Specifying a value of 0 generates more compact code; specifying other values forces the allocation of that number to the current library, but is no more space- or time-efficient than omitting this option.</source>
          <target state="translated">指定正在编译的基于ID的共享库的标识号。指定0的值会产生更紧凑的代码;指定其他值会强制将该编号分配给当前库,但不会比省略该选项更节省空间和时间。</target>
        </trans-unit>
        <trans-unit id="c1e382c74800682d2e9f3b74a1844826dd2ecb62" translate="yes" xml:space="preserve">
          <source>Specifies the maximum number of instructions an out-of-line copy of a self-recursive inline function can grow into by performing recursive inlining.</source>
          <target state="translated">指定自递归内联函数的行外副本通过执行递归内联可以成长为的最大指令数。</target>
        </trans-unit>
        <trans-unit id="a5e540e476e706af7ae2a630f97b45afd6de5bb3" translate="yes" xml:space="preserve">
          <source>Specifies the maximum recursion depth used for recursive inlining.</source>
          <target state="translated">指定用于递归内联的最大递归深度。</target>
        </trans-unit>
        <trans-unit id="842831f7e4e5d29f3e7d0beec2854a0216bc6e42" translate="yes" xml:space="preserve">
          <source>Specifies the maximum size in bytes of global and static variables which can be placed into the small data area. Using the small data area can lead to smaller and faster code, but the size of area is limited and it is up to the programmer to ensure that the area does not overflow. Also when the small data area is used one of the RX&amp;rsquo;s registers (usually &lt;code&gt;r13&lt;/code&gt;) is reserved for use pointing to this area, so it is no longer available for use by the compiler. This could result in slower and/or larger code if variables are pushed onto the stack instead of being held in this register.</source>
          <target state="translated">指定可以放置在小数据区域中的全局变量和静态变量的最大字节大小。使用较小的数据区域可以导致代码更小和更快，但是区域的大小是有限的，程序员必须确保该区域不会溢出。同样，当使用小数据区域时，RX的寄存器之一（通常为 &lt;code&gt;r13&lt;/code&gt; ）保留供指向该区域的使用，因此编译器将不再使用它。如果将变量压入堆栈而不是保存在该寄存器中，则可能导致代码变慢和/或变大。</target>
        </trans-unit>
        <trans-unit id="7412a6cb9b0e0f8b6e7f0d0e77fd2140ccfb86a1" translate="yes" xml:space="preserve">
          <source>Specifies the maximum size, in bytes, of a constant that can be used as an operand in a RX instruction. Although the RX instruction set does allow constants of up to 4 bytes in length to be used in instructions, a longer value equates to a longer instruction. Thus in some circumstances it can be beneficial to restrict the size of constants that are used in instructions. Constants that are too big are instead placed into a constant pool and referenced via register indirection.</source>
          <target state="translated">指定在RX指令中作为操作数使用的常量的最大大小,以字节为单位。尽管RX指令集允许在指令中使用长度为4字节的常量,但较长的常量相当于较长的指令。因此在某些情况下,限制指令中使用的常量的大小可能是有益的。太大的常量会被放入常量池中,通过寄存器间接引用。</target>
        </trans-unit>
        <trans-unit id="f498cab10962b0798c0931ba2f63475387ade694" translate="yes" xml:space="preserve">
          <source>Specifies the name of the operating system function to call to flush the cache. The default is &amp;lsquo;</source>
          <target state="translated">指定要调用以刷新缓存的操作系统功能的名称。默认值为&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="4cb9f9dd93932f78051a635c26202d7d8e5535cd" translate="yes" xml:space="preserve">
          <source>Specifies the name of the target Blackfin processor. Currently, &lt;var&gt;cpu&lt;/var&gt; can be one of &amp;lsquo;</source>
          <target state="translated">指定目标Blackfin处理器的名称。目前， &lt;var&gt;cpu&lt;/var&gt; 可以是&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="c0803aab785a2e20aedd243e17212d6d9ce8548e" translate="yes" xml:space="preserve">
          <source>Specifies the number of memory-based pseudo-registers GCC uses during code generation. These pseudo-registers are used like real registers, so there is a tradeoff between GCC&amp;rsquo;s ability to fit the code into available registers, and the performance penalty of using memory instead of registers. Note that all modules in a program must be compiled with the same value for this option. Because of that, you must not use this option with GCC&amp;rsquo;s default runtime libraries.</source>
          <target state="translated">指定GCC在代码生成过程中使用的基于内存的伪寄存器的数量。这些伪寄存器的使用与实际寄存器一样，因此在GCC将代码适合可用寄存器的能力与使用内存而不是寄存器的性能损失之间存在折衷。请注意，对于此选项，程序中的所有模块都必须使用相同的值进行编译。因此，不得将此选项与GCC的默认运行时库一起使用。</target>
        </trans-unit>
        <trans-unit id="22f3ed905850cb42bd6d50bb52af7907bc7a581e" translate="yes" xml:space="preserve">
          <source>Specifies the number of registers replicated in second register bank on entry to fast interrupt. Fast interrupts are interrupts with the highest priority level P0. These interrupts save only PC and STATUS32 registers to avoid memory transactions during interrupt entry and exit sequences. Use this option when you are using fast interrupts in an ARC V2 family processor. Permitted values are 4, 8, 16, and 32.</source>
          <target state="translated">指定进入快速中断时第二寄存器库中复制的寄存器数。快速中断是指优先级最高的P0的中断,这些中断只保存PC和STATUS32寄存器,以避免在中断进入和退出序列中的内存事务。这些中断只保存PC和STATUS32寄存器,以避免在中断进入和退出序列中的内存事务。当您在ARC V2系列处理器中使用快速中断时,请使用此选项。允许的值是4、8、16和32。</target>
        </trans-unit>
        <trans-unit id="affdb413ade6c559688aa8325514465c16425b76" translate="yes" xml:space="preserve">
          <source>Specifies the trap number to use to flush the cache. The default is 12. Valid numbers are between 0 and 15 inclusive.</source>
          <target state="translated">指定用于刷新缓存的陷阱数量。默认值是12。有效数字在0到15之间。</target>
        </trans-unit>
        <trans-unit id="c90e51847549c6d7bfb26f9d83f651beb9507ea1" translate="yes" xml:space="preserve">
          <source>Specifies the type of hardware multiplication and division support to be used. The simplest is &lt;code&gt;none&lt;/code&gt;, which uses software for both multiplication and division. This is the default. The &lt;code&gt;g13&lt;/code&gt; value is for the hardware multiply/divide peripheral found on the RL78/G13 (S2 core) targets. The &lt;code&gt;g14&lt;/code&gt; value selects the use of the multiplication and division instructions supported by the RL78/G14 (S3 core) parts. The value &lt;code&gt;rl78&lt;/code&gt; is an alias for &lt;code&gt;g14&lt;/code&gt; and the value &lt;code&gt;mg10&lt;/code&gt; is an alias for &lt;code&gt;none&lt;/code&gt;.</source>
          <target state="translated">指定要使用的硬件乘法和除法支持的类型。最简单的方法是 &lt;code&gt;none&lt;/code&gt; ，它使用软件进行乘法和除法运算。这是默认值。的 &lt;code&gt;g13&lt;/code&gt; 值对于硬件乘法/除法上RL78 / G13（S2芯的）目标外围发现的。的 &lt;code&gt;g14&lt;/code&gt; 值选择使用由RL78 / G14（S3芯）部分支持的乘法和除法指令。值 &lt;code&gt;rl78&lt;/code&gt; 是 &lt;code&gt;g14&lt;/code&gt; 的别名，值 &lt;code&gt;mg10&lt;/code&gt; 是 &lt;code&gt;none&lt;/code&gt; 的别名。</target>
        </trans-unit>
        <trans-unit id="6f81d16d95cc0305e73b474da06956f8e11e96d3" translate="yes" xml:space="preserve">
          <source>Specifies whether FP exceptions are enabled. This affects how FP instructions are scheduled for some processors. The default is that FP exceptions are enabled.</source>
          <target state="translated">指定是否启用FP异常。这将影响一些处理器的FP指令的调度方式。默认情况下是启用FP异常。</target>
        </trans-unit>
        <trans-unit id="72b43446cb2dd4e94fe26ad69b18b9bf05535ef3" translate="yes" xml:space="preserve">
          <source>Specifies which coprocessor registers are available to the register allocator. &lt;var&gt;registers&lt;/var&gt; may be a single register, register range separated by ellipses, or comma-separated list of those. Example:</source>
          <target state="translated">指定哪些协处理器寄存器可用于寄存器分配器。 &lt;var&gt;registers&lt;/var&gt; 可以是单个寄存器，寄存器范围可以用椭圆分隔，也可以用逗号分隔。例：</target>
        </trans-unit>
        <trans-unit id="0598db288f6f533223b56d068b56fd87125317c1" translate="yes" xml:space="preserve">
          <source>Specifies which coprocessor registers are to be saved and restored by any function using them. &lt;var&gt;registers&lt;/var&gt; may be a single register, register range separated by ellipses, or comma-separated list of those. Example:</source>
          <target state="translated">指定通过使用它们的任何功能要保存和恢复的协处理器寄存器。 &lt;var&gt;registers&lt;/var&gt; 可以是单个寄存器，寄存器范围可以用椭圆分隔，也可以用逗号分隔。例：</target>
        </trans-unit>
        <trans-unit id="c1b3620228a9a55d3a61b6172646e0fda8c7d9e2" translate="yes" xml:space="preserve">
          <source>Specifies which floating-point ABI to use. Permissible values are: &amp;lsquo;</source>
          <target state="translated">指定要使用的浮点ABI。允许值为：</target>
        </trans-unit>
        <trans-unit id="a477d8dab7ef5cc90c58a41d06ca3494aeba078f" translate="yes" xml:space="preserve">
          <source>Specify</source>
          <target state="translated">Specify</target>
        </trans-unit>
        <trans-unit id="b7d7c4da380841e46021fb0ca037b1a5efba92c6" translate="yes" xml:space="preserve">
          <source>Specify &lt;var&gt;prefix&lt;/var&gt; as the prefix for subsequent</source>
          <target state="translated">指定 &lt;var&gt;prefix&lt;/var&gt; 作为后续的前缀</target>
        </trans-unit>
        <trans-unit id="a1b75d36373bf0a158266aad4b0685acf54bdd9f" translate="yes" xml:space="preserve">
          <source>Specify Atmel AVR instruction set architectures (ISA) or MCU type.</source>
          <target state="translated">指定 Atmel AVR 指令集架构 (ISA)或 MCU 类型。</target>
        </trans-unit>
        <trans-unit id="d5ced711925ce2b86f2945855d11a9f765bdf3b8" translate="yes" xml:space="preserve">
          <source>Specify a register to hold the constant -1, which makes loading small negative constants and certain bitmasks faster. Allowable values for &lt;var&gt;reg&lt;/var&gt; are &amp;lsquo;</source>
          <target state="translated">指定一个寄存器来保存常数-1，这将使加载较小的负常数和某些位掩码更快。 &lt;var&gt;reg&lt;/var&gt; 的允许值为&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="ee4e72d685bf13ccdca2b955146686e94f4dd820" translate="yes" xml:space="preserve">
          <source>Specify bit size of immediate TLS offsets. Valid values are 12, 24, 32, 48. This option requires binutils 2.26 or newer.</source>
          <target state="translated">指定即时TLS偏移量的位数大小,有效值为12、24、32、48。有效值是12、24、32、48。这个选项需要binutils 2.26或更新版本。</target>
        </trans-unit>
        <trans-unit id="0ee5fd4c06f208dc72a94346beb5b066cc520b6c" translate="yes" xml:space="preserve">
          <source>Specify bit size of immediate TLS offsets. Valid values are 14, 22, and 64.</source>
          <target state="translated">指定即时TLS偏移量的位数大小,有效值为14、22和64。有效值是14、22和64。</target>
        </trans-unit>
        <trans-unit id="e3d343f19f5a896581a51d8a250efd477d791df5" translate="yes" xml:space="preserve">
          <source>Specify both</source>
          <target state="translated">指定两个</target>
        </trans-unit>
        <trans-unit id="790583d2504db1e70b776b6337942849b2d5671c" translate="yes" xml:space="preserve">
          <source>Specify default compute dimensions for parallel offload regions that do not explicitly specify. The &lt;var&gt;geom&lt;/var&gt; value is a triple of &amp;rsquo;:&amp;rsquo;-separated sizes, in order &amp;rsquo;gang&amp;rsquo;, &amp;rsquo;worker&amp;rsquo; and, &amp;rsquo;vector&amp;rsquo;. A size can be omitted, to use a target-specific default value.</source>
          <target state="translated">为未明确指定的并行卸载区域指定默认计算维度。所述 &lt;var&gt;geom&lt;/var&gt; 值是三重的&amp;ldquo;：&amp;rdquo; -分离尺寸，为了&amp;ldquo;团伙&amp;rdquo;，&amp;ldquo;工&amp;rdquo;和&amp;ldquo;矢量&amp;rdquo;。可以省略大小，以使用特定于目标的默认值。</target>
        </trans-unit>
        <trans-unit id="d0c09fd54e93619fc886af47d25ab910da3f1f1d" translate="yes" xml:space="preserve">
          <source>Specify desired number of partitions produced during WHOPR compilation. The number of partitions should exceed the number of CPUs used for compilation.</source>
          <target state="translated">指定在WHOPR编译过程中产生的分区数量。分区的数量应该超过用于编译的CPU数量。</target>
        </trans-unit>
        <trans-unit id="ddd74922c1fffe0660ee607e7c8c05e6b9c36231" translate="yes" xml:space="preserve">
          <source>Specify either the directory containing the gcov data files, or the object path name. The</source>
          <target state="translated">指定包含gcov数据文件的目录或对象路径名。对象路径名。</target>
        </trans-unit>
        <trans-unit id="a8bb63ac54bf2ea3fd989f2a3dede75fee9c409d" translate="yes" xml:space="preserve">
          <source>Specify explicitly the &lt;var&gt;language&lt;/var&gt; for the following input files (rather than letting the compiler choose a default based on the file name suffix). This option applies to all following input files until the next</source>
          <target state="translated">明确指定以下输入文件的 &lt;var&gt;language&lt;/var&gt; （而不是让编译器根据文件名后缀选择默认语言）。此选项适用于所有后续输入文件，直到下一个</target>
        </trans-unit>
        <trans-unit id="1dece3d1baf820f578333563e62b95b8ee062ffd" translate="yes" xml:space="preserve">
          <source>Specify growth that the early inliner can make. In effect it increases the amount of inlining for code having a large abstraction penalty.</source>
          <target state="translated">指定早期内联器可以做出的增长。实际上,它增加了具有较大抽象惩罚的代码的内联量。</target>
        </trans-unit>
        <trans-unit id="8b0123ff59c8271225f538f6c8fc4517d3e5946e" translate="yes" xml:space="preserve">
          <source>Specify how many &lt;var&gt;bytes&lt;/var&gt; of stack space will be requested for each GPU thread (wave-front). Beware that there may be many threads and limited memory available. The size of the stack allocation may also have an impact on run-time performance. The default is 32KB when using OpenACC or OpenMP, and 1MB otherwise.</source>
          <target state="translated">指定每个GPU线程（波前）将请求多少 &lt;var&gt;bytes&lt;/var&gt; 堆栈空间字节。请注意，可能有许多线程和有限的可用内存。堆栈分配的大小也可能会影响运行时性能。使用OpenACC或OpenMP时，默认值为32KB，否则为1MB。</target>
        </trans-unit>
        <trans-unit id="6b4cd64add8e5ab4a64ac446bfe3679786b4245a" translate="yes" xml:space="preserve">
          <source>Specify how to print paths of control-flow events for diagnostics that have such a path associated with them.</source>
          <target state="translated">指定如何打印具有相关路径的诊断程序的控制流事件的路径。</target>
        </trans-unit>
        <trans-unit id="de9c99e300af9c8b6bed1288c468edd9f4ff0049" translate="yes" xml:space="preserve">
          <source>Specify integer and floating-point calling convention. &lt;var&gt;ABI-string&lt;/var&gt; contains two parts: the size of integer types and the registers used for floating-point types. For example &amp;lsquo;</source>
          <target state="translated">指定整数和浮点调用约定。 &lt;var&gt;ABI-string&lt;/var&gt; 包含两个部分：整数类型的大小和用于浮点类型的寄存器。例如 '</target>
        </trans-unit>
        <trans-unit id="d83c8944a923ba0afcb420deeb5f2d35c92d90c2" translate="yes" xml:space="preserve">
          <source>Specify that intrinsic library functions are being compiled, passing all values in registers, no matter the size.</source>
          <target state="translated">指定正在编译固有库函数,在寄存器中传递所有值,无论大小。</target>
        </trans-unit>
        <trans-unit id="ece1c6c2bc5985e3475fb38d94d339c81045f6ff" translate="yes" xml:space="preserve">
          <source>Specify that the assembler should encode SSE instructions with VEX prefix. The option</source>
          <target state="translated">指定汇编器应该用VEX前缀编码SSE指令。选项</target>
        </trans-unit>
        <trans-unit id="b6e1f7a9d2a1718382e7b4d035866fa5b223eb27" translate="yes" xml:space="preserve">
          <source>Specify that the program entry point is &lt;var&gt;entry&lt;/var&gt;. The argument is interpreted by the linker; the GNU linker accepts either a symbol name or an address.</source>
          <target state="translated">指定程序入口点为 &lt;var&gt;entry&lt;/var&gt; 。参数由链接器解释；GNU链接器接受符号名称或地址。</target>
        </trans-unit>
        <trans-unit id="109f76cb76b9bdcac0640d708d9f5aa531701516" translate="yes" xml:space="preserve">
          <source>Specify that the target processor is the V850.</source>
          <target state="translated">指定目标处理器为V850。</target>
        </trans-unit>
        <trans-unit id="e795d47484c6aa284871594487a90d959a680146" translate="yes" xml:space="preserve">
          <source>Specify that the target processor is the V850E. The preprocessor constant &lt;code&gt;__v850e__&lt;/code&gt; is defined if this option is used.</source>
          <target state="translated">指定目标处理器为V850E。如果使用此选项，则定义预处理器常量 &lt;code&gt;__v850e__&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8b95c4ac2d723888f85d1eb5d22f7c525dcae0da" translate="yes" xml:space="preserve">
          <source>Specify that the target processor is the V850E1. The preprocessor constants &lt;code&gt;__v850e1__&lt;/code&gt; and &lt;code&gt;__v850e__&lt;/code&gt; are defined if this option is used.</source>
          <target state="translated">指定目标处理器为V850E1。如果使用此选项，则定义预处理器常量 &lt;code&gt;__v850e1__&lt;/code&gt; 和 &lt;code&gt;__v850e__&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="978d09824c615036a75f151e3f181a0c030be29d" translate="yes" xml:space="preserve">
          <source>Specify that the target processor is the V850E2. The preprocessor constant &lt;code&gt;__v850e2__&lt;/code&gt; is defined if this option is used.</source>
          <target state="translated">指定目标处理器为V850E2。如果使用此选项，则定义预处理器常量 &lt;code&gt;__v850e2__&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ed32c1d3fe9b0d91dac78559f89b829020d693b3" translate="yes" xml:space="preserve">
          <source>Specify that the target processor is the V850E2V3. The preprocessor constant &lt;code&gt;__v850e2v3__&lt;/code&gt; is defined if this option is used.</source>
          <target state="translated">指定目标处理器为V850E2V3。如果使用此选项，则定义预处理器常量 &lt;code&gt;__v850e2v3__&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="45dfef0c4ebf051e18bbb6d800fab624cbb970fb" translate="yes" xml:space="preserve">
          <source>Specify that the target processor is the V850E3V5. The preprocessor constant &lt;code&gt;__v850e3v5__&lt;/code&gt; is defined if this option is used.</source>
          <target state="translated">指定目标处理器为V850E3V5。如果使用此选项，则定义预处理器常量 &lt;code&gt;__v850e3v5__&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c53303aa9a3d3e7e971e5fac1f2e4c19510c6915" translate="yes" xml:space="preserve">
          <source>Specify that the target processor is the V850E3V5. This is an alias for the</source>
          <target state="translated">指定目标处理器为V850E3V5。的别名。</target>
        </trans-unit>
        <trans-unit id="f54503d1104c416ab9f70cb3eb9892d2467505fc" translate="yes" xml:space="preserve">
          <source>Specify that the target processor is the V850ES. This is an alias for the</source>
          <target state="translated">指定目标处理器为V850ES。这是V850ES的别名。</target>
        </trans-unit>
        <trans-unit id="ffbfc8af222c9971b65ff46dc8c44a1dab74c77d" translate="yes" xml:space="preserve">
          <source>Specify the ABI variant to output code for.</source>
          <target state="translated">指定要输出代码的ABI变体。</target>
        </trans-unit>
        <trans-unit id="20a7ba111bd81efdcb44d105c109fea8a9201317" translate="yes" xml:space="preserve">
          <source>Specify the C-SKY target architecture. Valid values for &lt;var&gt;arch&lt;/var&gt; are: &amp;lsquo;</source>
          <target state="translated">指定C-SKY目标体系结构。 &lt;var&gt;arch&lt;/var&gt; 的有效值为：</target>
        </trans-unit>
        <trans-unit id="11e0bbd00da02b87a4bf01c5c95da5cd4e1c7d2f" translate="yes" xml:space="preserve">
          <source>Specify the C-SKY target processor. Valid values for &lt;var&gt;cpu&lt;/var&gt; are: &amp;lsquo;</source>
          <target state="translated">指定C-SKY目标处理器。 &lt;var&gt;cpu&lt;/var&gt; 的有效值为：</target>
        </trans-unit>
        <trans-unit id="fbd43e450dfe7c7020abde276dbd9a11edafebb9" translate="yes" xml:space="preserve">
          <source>Specify the PRU MCU variant to use. Check Newlib for the exact list of supported MCUs.</source>
          <target state="translated">指定要使用的 PRU MCU 变体。查看Newlib,了解支持的MCU的确切列表。</target>
        </trans-unit>
        <trans-unit id="bc89fadc7861eb9269a2f0ab8fd00ec9f83fdfcb" translate="yes" xml:space="preserve">
          <source>Specify the SCORE5 as the target architecture.</source>
          <target state="translated">指定SCORE5为目标架构。</target>
        </trans-unit>
        <trans-unit id="80ac17f93e6b558b7b64a2653f4a0db05f2f20e9" translate="yes" xml:space="preserve">
          <source>Specify the SCORE5U of the target architecture.</source>
          <target state="translated">指定目标架构的SCORE5U。</target>
        </trans-unit>
        <trans-unit id="e2e0fec7f878028d3e3295fde4a330a4137fef1a" translate="yes" xml:space="preserve">
          <source>Specify the SCORE7 as the target architecture. This is the default.</source>
          <target state="translated">指定SCORE7为目标架构。这是默认的。</target>
        </trans-unit>
        <trans-unit id="3faa14b10ee7726e8a0c19877d4b1bbbf4106dd0" translate="yes" xml:space="preserve">
          <source>Specify the SCORE7D as the target architecture.</source>
          <target state="translated">指定SCORE7D为目标架构。</target>
        </trans-unit>
        <trans-unit id="7c8f7f5802b742a1c6e69d2f1fd902f62c599e4f" translate="yes" xml:space="preserve">
          <source>Specify the access model for the thread local storage pointer. The valid models are &amp;lsquo;</source>
          <target state="translated">指定线程本地存储指针的访问模型。有效模型为&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="4fe4d9d926d51c315bc40fdf7c449529e2dcee8d" translate="yes" xml:space="preserve">
          <source>Specify the architecture to generate code for in compiling the function.</source>
          <target state="translated">指定编译函数时要生成代码的架构。</target>
        </trans-unit>
        <trans-unit id="13ac0518f9e486f66b03f2a62260517f22563228" translate="yes" xml:space="preserve">
          <source>Specify the architecture to generate code for when compiling the function. If you select the &lt;code&gt;target(&quot;cpu=power7&quot;)&lt;/code&gt; attribute when generating 32-bit code, VSX and AltiVec instructions are not generated unless you use the</source>
          <target state="translated">指定用于编译功能时生成代码的体系结构。如果在生成32位代码时选择 &lt;code&gt;target(&quot;cpu=power7&quot;)&lt;/code&gt; 属性，则除非使用以下命令，否则不会生成VSX和AltiVec指令</target>
        </trans-unit>
        <trans-unit id="815118b1ba2fa776327569310aabc51b60f85457" translate="yes" xml:space="preserve">
          <source>Specify the architecture to tune for in compiling the function.</source>
          <target state="translated">指定编译函数时要调整的架构。</target>
        </trans-unit>
        <trans-unit id="c736ab6b1828855a9d2fe005636f63dbc18a00fc" translate="yes" xml:space="preserve">
          <source>Specify the architecture to tune for when compiling the function. If you do not specify the &lt;code&gt;target(&quot;tune=&lt;var&gt;TUNE&lt;/var&gt;&quot;)&lt;/code&gt; attribute and you do specify the &lt;code&gt;target(&quot;cpu=&lt;var&gt;CPU&lt;/var&gt;&quot;)&lt;/code&gt; attribute, compilation tunes for the &lt;var&gt;CPU&lt;/var&gt; architecture, and not the default tuning specified on the command line.</source>
          <target state="translated">指定编译功能时要调整的体系结构。如果您未指定 &lt;code&gt;target(&quot;tune=&lt;var&gt;TUNE&lt;/var&gt;&quot;)&lt;/code&gt; 属性，而是指定了 &lt;code&gt;target(&quot;cpu=&lt;var&gt;CPU&lt;/var&gt;&quot;)&lt;/code&gt; 属性，则编译会针对 &lt;var&gt;CPU&lt;/var&gt; 体系结构进行调整，而不是在命令行上指定的默认调整。</target>
        </trans-unit>
        <trans-unit id="cb717a175d86a7113193ef8b41cb494223988553" translate="yes" xml:space="preserve">
          <source>Specify the dialect to use for accessing thread local storage. Two &lt;var&gt;dialect&lt;/var&gt;s are supported&amp;mdash;&amp;lsquo;</source>
          <target state="translated">指定用于访问线程本地存储的方言。支持两种 &lt;var&gt;dialect&lt;/var&gt; '</target>
        </trans-unit>
        <trans-unit id="b0bb1382b2b688a4ca78557929489507a5c35134" translate="yes" xml:space="preserve">
          <source>Specify the format of the &lt;code&gt;__fp16&lt;/code&gt; half-precision floating-point type. Permissible names are &amp;lsquo;</source>
          <target state="translated">指定 &lt;code&gt;__fp16&lt;/code&gt; 半精度浮点类型的格式。允许的名称是&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="54ccdaa4f82b5c59817de75dfddfa096068b5632" translate="yes" xml:space="preserve">
          <source>Specify the name of the target architecture and, optionally, one or more feature modifiers. This option has the form</source>
          <target state="translated">指定目标架构的名称,并可选地指定一个或多个特征修饰符。这个选项的形式是</target>
        </trans-unit>
        <trans-unit id="db2ae06942e745baa6c648898511743a3997f671" translate="yes" xml:space="preserve">
          <source>Specify the name of the target architecture.</source>
          <target state="translated">指定目标架构的名称。</target>
        </trans-unit>
        <trans-unit id="5bd735b6bf455d85d0ce6fea68c71abb062c337b" translate="yes" xml:space="preserve">
          <source>Specify the name of the target processor for which GCC should tune the performance of the code. Permissible values for this option are: &amp;lsquo;</source>
          <target state="translated">指定GCC为其调整代码性能的目标处理器的名称。该选项的允许值为：</target>
        </trans-unit>
        <trans-unit id="4403ce6e54a70cfa6d14c2a2335877fa18af0100" translate="yes" xml:space="preserve">
          <source>Specify the name of the target processor, optionally suffixed by one or more feature modifiers. This option has the form</source>
          <target state="translated">指定目标处理器的名称,可选择用一个或多个特征修饰符作为后缀。这个选项的形式是</target>
        </trans-unit>
        <trans-unit id="4092610bf9412a688b5dccb4c11f819e1c6c07fc" translate="yes" xml:space="preserve">
          <source>Specify the number of bits in an SVE vector register. This option only has an effect when SVE is enabled.</source>
          <target state="translated">指定SVE向量寄存器的位数。这个选项只有在启用SVE时才有效果。</target>
        </trans-unit>
        <trans-unit id="e688b24a3a041ea4cb98f3c1a8d73b1e4471b5fc" translate="yes" xml:space="preserve">
          <source>Specify the number of registers to reserve for fast interrupt handler functions. The value &lt;var&gt;N&lt;/var&gt; can be between 0 and 4. A value of 1 means that register &lt;code&gt;r13&lt;/code&gt; is reserved for the exclusive use of fast interrupt handlers. A value of 2 reserves &lt;code&gt;r13&lt;/code&gt; and &lt;code&gt;r12&lt;/code&gt;. A value of 3 reserves &lt;code&gt;r13&lt;/code&gt;, &lt;code&gt;r12&lt;/code&gt; and &lt;code&gt;r11&lt;/code&gt;, and a value of 4 reserves &lt;code&gt;r13&lt;/code&gt; through &lt;code&gt;r10&lt;/code&gt;. A value of 0, the default, does not reserve any registers.</source>
          <target state="translated">指定为快速中断处理程序功能保留的寄存器数。值 &lt;var&gt;N&lt;/var&gt; 可以在0到4之间。值1表示寄存器 &lt;code&gt;r13&lt;/code&gt; 保留供快速中断处理程序专用。2的值保留 &lt;code&gt;r13&lt;/code&gt; 和 &lt;code&gt;r12&lt;/code&gt; 。值为3的储备 &lt;code&gt;r13&lt;/code&gt; ， &lt;code&gt;r12&lt;/code&gt; 和 &lt;code&gt;r11&lt;/code&gt; ，以及值为4的储备 &lt;code&gt;r13&lt;/code&gt; 至 &lt;code&gt;r10&lt;/code&gt; 。默认值0不保留任何寄存器。</target>
        </trans-unit>
        <trans-unit id="96cf955f0da2fdbcd4bc1c6671a0522d71316b38" translate="yes" xml:space="preserve">
          <source>Specify the partitioning algorithm used by the link-time optimizer. The value is either &amp;lsquo;</source>
          <target state="translated">指定链接时间优化器使用的分区算法。该值可以是&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="5f46dcee93a04ae249c6b3def708b00260f2a519" translate="yes" xml:space="preserve">
          <source>Specify the register to be used for PIC addressing. For standard PIC base case, the default is any suitable register determined by compiler. For single PIC base case, the default is &amp;lsquo;</source>
          <target state="translated">指定用于PIC寻址的寄存器。对于标准PIC基本情况，默认值为编译器确定的任何合适的寄存器。对于单个PIC基本情况，默认值为'</target>
        </trans-unit>
        <trans-unit id="9157006b777e209a57da158df2f68846623d8678" translate="yes" xml:space="preserve">
          <source>Specify the size of each cache block, which must be a power of 2 between 4 and 512.</source>
          <target state="translated">指定每个缓存块的大小,它必须是4到512之间的2的幂。</target>
        </trans-unit>
        <trans-unit id="edab8f619041277bee138aa740d3f8bdb844feca" translate="yes" xml:space="preserve">
          <source>Specify the size of each interrupt vector, which must be 4 or 16.</source>
          <target state="translated">指定每个中断向量的大小,必须是4或16。</target>
        </trans-unit>
        <trans-unit id="dde0e6e48055b68c9dfa72618fe117ee2653e7c8" translate="yes" xml:space="preserve">
          <source>Specify the size of the operating system provided stack guard as 2 raised to &lt;var&gt;num&lt;/var&gt; bytes. Higher values may reduce the number of explicit probes, but a value larger than the operating system provided guard will leave code vulnerable to stack clash style attacks.</source>
          <target state="translated">将操作系统提供的堆栈保护的大小指定为2（增加到 &lt;var&gt;num&lt;/var&gt; 个字节）。较高的值可能会减少显式探针的数量，但是该值大于操作系统提供的保护措施后，将使代码容易受到堆栈冲突样式攻击。</target>
        </trans-unit>
        <trans-unit id="4bee625f3585900ec98450bcf9d2c818f2c00803" translate="yes" xml:space="preserve">
          <source>Specify the struct-like types for which the compiler generates debug information. The intent is to reduce duplicate struct debug information between different object files within the same program.</source>
          <target state="translated">指定编译器生成调试信息的类结构类型。目的是为了减少同一程序中不同对象文件之间重复的结构体调试信息。</target>
        </trans-unit>
        <trans-unit id="4e0fd0bd7b4133166f8983f5ca490beae5286735" translate="yes" xml:space="preserve">
          <source>Specify the width of the &lt;code&gt;lp_count&lt;/code&gt; register. Valid values for &lt;var&gt;width&lt;/var&gt; are 8, 16, 20, 24, 28 and 32 bits. The default width is fixed to 32 bits. If the width is less than 32, the compiler does not attempt to transform loops in your program to use the zero-delay loop mechanism unless it is known that the &lt;code&gt;lp_count&lt;/code&gt; register can hold the required loop-counter value. Depending on the width specified, the compiler and run-time library might continue to use the loop mechanism for various needs. This option defines macro &lt;code&gt;__ARC_LPC_WIDTH__&lt;/code&gt; with the value of &lt;var&gt;width&lt;/var&gt;.</source>
          <target state="translated">指定 &lt;code&gt;lp_count&lt;/code&gt; 寄存器的宽度。有效的 &lt;var&gt;width&lt;/var&gt; 值为8、16、20、24、28和32位。默认宽度固定为32位。如果宽度小于32，则除非知道 &lt;code&gt;lp_count&lt;/code&gt; 寄存器可以保存所需的循环计数器值，否则编译器不会尝试将程序中的循环转换为使用零延迟循环机制。根据指定的宽度，编译器和运行时库可能会继续使用循环机制来满足各种需求。此选项使用 &lt;var&gt;width&lt;/var&gt; 的值定义宏 &lt;code&gt;__ARC_LPC_WIDTH__&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ef84b64c518f868fe3c1456dcd8b940ed2f5f518" translate="yes" xml:space="preserve">
          <source>Specify thread pointer register number.</source>
          <target state="translated">指定线程指针寄存器编号。</target>
        </trans-unit>
        <trans-unit id="0795a2fa90067cc8a239666f6041471cc59a29ac" translate="yes" xml:space="preserve">
          <source>Specify whether GCC may generate code that reads from executable sections. There are three possible settings:</source>
          <target state="translated">指定GCC是否可以生成从可执行部分读取的代码。有三种可能的设置。</target>
        </trans-unit>
        <trans-unit id="d19282618f9569137fcb9b5340c3ea42b2a33ba2" translate="yes" xml:space="preserve">
          <source>Specify whether GCC should insert cache barriers to avoid the side effects of speculation on R10K processors.</source>
          <target state="translated">指定GCC是否应该插入缓存障碍,以避免投机对R10K处理器的副作用。</target>
        </trans-unit>
        <trans-unit id="1440f232d0fc9c6f8894e1bd99ffd6ec679cd656" translate="yes" xml:space="preserve">
          <source>Specify which floating-point unit to use. You must specify the &lt;code&gt;target(&quot;fpmath=sse,387&quot;)&lt;/code&gt; option as &lt;code&gt;target(&quot;fpmath=sse+387&quot;)&lt;/code&gt; because the comma would separate different options.</source>
          <target state="translated">指定要使用的浮点单位。您必须将 &lt;code&gt;target(&quot;fpmath=sse,387&quot;)&lt;/code&gt; 选项指定为 &lt;code&gt;target(&quot;fpmath=sse+387&quot;)&lt;/code&gt; 因为逗号会分隔不同的选项。</target>
        </trans-unit>
        <trans-unit id="f360040b863c4a298bd666b8b6b30d2471ac8011" translate="yes" xml:space="preserve">
          <source>Specifying</source>
          <target state="translated">Specifying</target>
        </trans-unit>
        <trans-unit id="99167fd0d0a95abb4e35db3c3f342b56f873f72a" translate="yes" xml:space="preserve">
          <source>Specifying &amp;lsquo;</source>
          <target state="translated">指定&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="d1885b005623a5f02d47b85a83ced0900c30f8b7" translate="yes" xml:space="preserve">
          <source>Specifying a combination that is not valid for the current architecture causes GCC to synthesize the instructions using a narrower mode. For example, if you specify a variable of type &lt;code&gt;V4SI&lt;/code&gt; and your architecture does not allow for this specific SIMD type, GCC produces code that uses 4 &lt;code&gt;SIs&lt;/code&gt;.</source>
          <target state="translated">指定对当前架构无效的组合会导致GCC使用较窄的模式来合成指令。例如，如果您指定类型为 &lt;code&gt;V4SI&lt;/code&gt; 的变量，并且您的体系结构不允许该特定的SIMD类型，则GCC会生成使用4个 &lt;code&gt;SIs&lt;/code&gt; 代码。</target>
        </trans-unit>
        <trans-unit id="2e7e05645dcca05e87ea389d828aa6bfe5f9fa1f" translate="yes" xml:space="preserve">
          <source>Specifying a larger number can produce faster, more efficient code, but can also increase the size of the program. Different values are potentially incompatible. Code compiled with one value cannot necessarily expect to work with code or libraries compiled with another value, if they exchange information using structures or unions.</source>
          <target state="translated">指定一个较大的数字可以产生更快更有效的代码,但也会增加程序的大小。不同的值有可能是不兼容的。用一个值编译的代码不一定能指望与用另一个值编译的代码或库一起工作,如果它们使用结构或联合交换信息的话。</target>
        </trans-unit>
        <trans-unit id="03c6ae3356882b0eeb6636e77ccaa0aba81823b0" translate="yes" xml:space="preserve">
          <source>Specifying attributes of types.</source>
          <target state="translated">指定类型的属性。</target>
        </trans-unit>
        <trans-unit id="9e1c53b45f7e03f5a8d931294deb320e271bf08b" translate="yes" xml:space="preserve">
          <source>Specifying attributes of variables.</source>
          <target state="translated">指定变量的属性。</target>
        </trans-unit>
        <trans-unit id="5db2ee21c24dcdf45bcae194cf2ecad708afe6a7" translate="yes" xml:space="preserve">
          <source>Specifying attributes on enumerators.</source>
          <target state="translated">在枚举器上指定属性。</target>
        </trans-unit>
        <trans-unit id="ae68580bc0d24f5d44a4b1108b3374a4cbf533b1" translate="yes" xml:space="preserve">
          <source>Specifying attributes on labels.</source>
          <target state="translated">在标签上指定属性。</target>
        </trans-unit>
        <trans-unit id="6f4d8f85b31cb45df6efc5370ca55a06e5b2185a" translate="yes" xml:space="preserve">
          <source>Specifying attributes on statements.</source>
          <target state="translated">在语句上指定属性。</target>
        </trans-unit>
        <trans-unit id="c4fb77efc8cd285dcec19a190e5fd370517a59b0" translate="yes" xml:space="preserve">
          <source>Specifying conventions for function calls, data layout and register usage.</source>
          <target state="translated">指定函数调用、数据布局和寄存器使用的约定。</target>
        </trans-unit>
        <trans-unit id="8a322c1f2da20dac777d0e24ef37843a3925d344" translate="yes" xml:space="preserve">
          <source>Specifying libraries and so on.</source>
          <target state="translated">指定库等。</target>
        </trans-unit>
        <trans-unit id="35c808a95c8bd97d1d48f311fe3d1ff9cbb26d16" translate="yes" xml:space="preserve">
          <source>Specifying target attributes on individual functions or performing link-time optimization across translation units compiled with different target options can affect function inlining rules:</source>
          <target state="translated">在单个函数上指定目标属性或在用不同目标选项编译的翻译单元之间执行链接时间优化会影响函数内联规则。</target>
        </trans-unit>
        <trans-unit id="4ee9cc1aa83bf2a8aaa7d549089eae697b9df2fe" translate="yes" xml:space="preserve">
          <source>Specifying the</source>
          <target state="translated">指定</target>
        </trans-unit>
        <trans-unit id="be769970f9d0ab94f326ad5f60920cc958cef495" translate="yes" xml:space="preserve">
          <source>Specifying the assembler name to use for a C symbol.</source>
          <target state="translated">指定C符号要使用的汇编器名称。</target>
        </trans-unit>
        <trans-unit id="b768e2f08c0d665e3b9b9a2f57c49ac37e0b4986" translate="yes" xml:space="preserve">
          <source>Speculation Barrier Instruction.</source>
          <target state="translated">投机壁垒指示。</target>
        </trans-unit>
        <trans-unit id="e39eb4a0ece25ea3aad502401ffe4e7271da49e1" translate="yes" xml:space="preserve">
          <source>Speculatively hoist loads from both branches of an if-then-else if the loads are from adjacent locations in the same structure and the target architecture has a conditional move instruction. This flag is enabled by default at</source>
          <target state="translated">如果负载来自同一结构中的相邻位置,并且目标架构有条件移动指令,则从if-then-else的两个分支中随机提升负载。这个标志默认在</target>
        </trans-unit>
        <trans-unit id="e6c7808e8703d45ea319f5ac9cfea72c1d3b2c26" translate="yes" xml:space="preserve">
          <source>Split 32-byte AVX unaligned load and store.</source>
          <target state="translated">分割32字节的AVX未对齐加载和存储。</target>
        </trans-unit>
        <trans-unit id="a66f8bdb0cdd7c740f8bab1b871317c083f59cec" translate="yes" xml:space="preserve">
          <source>Split a loop into two if it contains a condition that&amp;rsquo;s always true for one side of the iteration space and false for the other.</source>
          <target state="translated">如果循环包含一个条件，该条件对于迭代空间的一侧始终为true，而对于另一侧则始终为false，则将其分为两部分。</target>
        </trans-unit>
        <trans-unit id="7e793f0b9e2c47f7ff51cea5a83ac494564f9b01" translate="yes" xml:space="preserve">
          <source>Split paths leading to loop backedges. This can improve dead code elimination and common subexpression elimination. This is enabled by default at</source>
          <target state="translated">分割路径导致循环后缀。这可以改善死代码的消除和普通子表达式的消除。默认情况下,这个功能在</target>
        </trans-unit>
        <trans-unit id="c19cf5ca00368b6bf60823f07c7f7db52961a1db" translate="yes" xml:space="preserve">
          <source>Split the include path. This option has been deprecated. Please use</source>
          <target state="translated">分割包含路径。这个选项已经被废止。请使用</target>
        </trans-unit>
        <trans-unit id="03d6628c91b12235f628c3f0849b814233af5af3" translate="yes" xml:space="preserve">
          <source>Split vector moves into single word moves before reload. In theory this can give better register allocation, but so far the reverse seems to be generally the case.</source>
          <target state="translated">在重新加载之前,将向量移动分割成单字移动。理论上,这可以提供更好的寄存器分配,但到目前为止,一般情况下是相反的。</target>
        </trans-unit>
        <trans-unit id="9b6e2276ec4ca5446d91dd4b3bca6fc9336a2104" translate="yes" xml:space="preserve">
          <source>Stack clash protection involves probing stack space as it is allocated. This param controls the maximum distance between probes into the stack as 2 raised to &lt;var&gt;num&lt;/var&gt; bytes. Higher values may reduce the number of explicit probes, but a value larger than the operating system provided guard will leave code vulnerable to stack clash style attacks.</source>
          <target state="translated">堆栈冲突保护涉及在分配堆栈空间时对其进行探测。该参数控制探针到堆栈中的最大距离，将2提升到 &lt;var&gt;num&lt;/var&gt; 个字节。较高的值可能会减少显式探针的数量，但是该值大于操作系统提供的保护措施后，将使代码容易受到堆栈冲突样式攻击。</target>
        </trans-unit>
        <trans-unit id="42423254dd8ef2b598b3ee0e697e74e7db04abbc" translate="yes" xml:space="preserve">
          <source>Stack pointer register (SP).</source>
          <target state="translated">堆栈指针寄存器(SP)。</target>
        </trans-unit>
        <trans-unit id="1d47e20f0d3ac51ec48cf366af32c77c2669b54f" translate="yes" xml:space="preserve">
          <source>Stack pointer register (SPH:SPL)</source>
          <target state="translated">堆栈指针寄存器(SPH:SPL)</target>
        </trans-unit>
        <trans-unit id="d8ceeae642420027f1322393a2a3a2e2bcca2060" translate="yes" xml:space="preserve">
          <source>Stack register $sp.</source>
          <target state="translated">叠加注册$sp。</target>
        </trans-unit>
        <trans-unit id="19b7dc1683e0d583c27f00412d344ea74bdf5a0a" translate="yes" xml:space="preserve">
          <source>Stack variables are not affected by linker restrictions; GCC can properly align them on any target.</source>
          <target state="translated">堆栈变量不受链接器限制的影响;GCC可以在任何目标上正确对齐它们。</target>
        </trans-unit>
        <trans-unit id="ac5a8f549a994c1b8e4dd80d24db9f3996eea422" translate="yes" xml:space="preserve">
          <source>Standard 80387 floating point constant.</source>
          <target state="translated">标准80387浮点常数。</target>
        </trans-unit>
        <trans-unit id="257c765fd4761dbfb8a7c22158ae9ccc2a9c0d89" translate="yes" xml:space="preserve">
          <source>Standard C requires that pointer types used with &lt;code&gt;va_arg&lt;/code&gt; in functions with variable argument lists either must be compatible with that of the actual argument, or that one type must be a pointer to &lt;code&gt;void&lt;/code&gt; and the other a pointer to a character type. GNU C implements the POSIX XSI extension that additionally permits the use of &lt;code&gt;va_arg&lt;/code&gt; with a pointer type to receive arguments of any other pointer type.</source>
          <target state="translated">标准C要求具有可变参数列表的函数中与 &lt;code&gt;va_arg&lt;/code&gt; 一起使用的指针类型必须与实际参数的指针类型兼容，或者一种类型必须是指向 &lt;code&gt;void&lt;/code&gt; 的指针，另一种类型是指向字符类型的指针。GNU C实现了POSIX XSI扩展，该扩展另外允许将 &lt;code&gt;va_arg&lt;/code&gt; 与指针类型一起使用以接收任何其他指针类型的参数。</target>
        </trans-unit>
        <trans-unit id="6f7654adc68a64f36e03bf390845ec45238411d8" translate="yes" xml:space="preserve">
          <source>Standard C90 requires the elements of an initializer to appear in a fixed order, the same as the order of the elements in the array or structure being initialized.</source>
          <target state="translated">标准C90要求初始化器的元素以固定的顺序出现,与被初始化的数组或结构中元素的顺序相同。</target>
        </trans-unit>
        <trans-unit id="b23b0b38a39d349a3165d9fefce6588293b09611" translate="yes" xml:space="preserve">
          <source>Standard system directories are scanned.</source>
          <target state="translated">扫描标准系统目录。</target>
        </trans-unit>
        <trans-unit id="7f3657857ae8fa83a5a6acb61ee0490999a1f0da" translate="yes" xml:space="preserve">
          <source>Start a RTM (Restricted Transactional Memory) transaction. Returns &lt;code&gt;_XBEGIN_STARTED&lt;/code&gt; when the transaction started successfully (note this is not 0, so the constant has to be explicitly tested).</source>
          <target state="translated">启动RTM（受限事务内存）事务。事务成功启动时返回 &lt;code&gt;_XBEGIN_STARTED&lt;/code&gt; （请注意，该值不是0，因此必须显式测试该常数）。</target>
        </trans-unit>
        <trans-unit id="d321cb5e91b977aa5f4a76bb28fcd908795d2d2b" translate="yes" xml:space="preserve">
          <source>Start lock elision on a lock variable. Memory order must be &lt;code&gt;__ATOMIC_ACQUIRE&lt;/code&gt; or stronger.</source>
          <target state="translated">在锁变量上启动锁省略。内存顺序必须为 &lt;code&gt;__ATOMIC_ACQUIRE&lt;/code&gt; 或更强。</target>
        </trans-unit>
        <trans-unit id="d710b21a9b9bf4c6c45243e4c0bf0c7460f48764" translate="yes" xml:space="preserve">
          <source>Starting with GCC 3.2, GCC binary conventions for C++ are based on a written, vendor-neutral C++ ABI that was designed to be specific to 64-bit Itanium but also includes generic specifications that apply to any platform. This C++ ABI is also implemented by other compiler vendors on some platforms, notably GNU/Linux and BSD systems. We have tried hard to provide a stable ABI that will be compatible with future GCC releases, but it is possible that we will encounter problems that make this difficult. Such problems could include different interpretations of the C++ ABI by different vendors, bugs in the ABI, or bugs in the implementation of the ABI in different compilers. GCC&amp;rsquo;s</source>
          <target state="translated">从GCC 3.2开始，C ++的GCC二进制约定基于书面的，与供应商无关的C ++ ABI，该CBI专为64位Itanium设计，但也包括适用于任何平台的通用规范。此C ++ ABI也由其他编译器供应商在某些平台上实现，尤其是GNU / Linux和BSD系统。我们已经尽力提供一个稳定的ABI，该ABI与将来的GCC版本兼容，但是我们可能会遇到使之困难的问题。此类问题可能包括不同供应商对C ++ ABI的不同解释，ABI中的错误或在不同编译器中实现ABI的错误。海湾合作委员会的</target>
        </trans-unit>
        <trans-unit id="e0603cbbfdea44aa94fc492612a783b691bd4ebd" translate="yes" xml:space="preserve">
          <source>Starting with GCC 4.7.0, the traditional GNU runtime API is no longer available.</source>
          <target state="translated">从GCC 4.7.0开始,传统的GNU运行时API不再可用。</target>
        </trans-unit>
        <trans-unit id="0d99177a777348b93d27364c0bfe456087ad31a7" translate="yes" xml:space="preserve">
          <source>Statement Attributes</source>
          <target state="translated">声明属性</target>
        </trans-unit>
        <trans-unit id="9a5ff5b401235fc57fb6c95d79c8c8b7116e1c37" translate="yes" xml:space="preserve">
          <source>States an expression as an assumption, and if possible, verifies that the assumption is valid. For example, &lt;code&gt;assume(n &amp;gt; 0)&lt;/code&gt;.</source>
          <target state="translated">将表达式陈述为假设，并在可能的情况下验证该假设有效。例如， &lt;code&gt;assume(n &amp;gt; 0)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c22f2edc68615de37762f51b4fa28235f463b8f3" translate="yes" xml:space="preserve">
          <source>Static Analyzer Options</source>
          <target state="translated">静态分析器选项</target>
        </trans-unit>
        <trans-unit id="0f44280770a4ee1097a4edddc52f0cd05d85a900" translate="yes" xml:space="preserve">
          <source>Static libraries are archives of object files, and have file names like</source>
          <target state="translated">静态库是对象文件的归档,文件名有如</target>
        </trans-unit>
        <trans-unit id="c46e734f5fd8510b9e062efd2082eeb14db6af81" translate="yes" xml:space="preserve">
          <source>Static member declarations are not definitions</source>
          <target state="translated">静态成员声明不是定义。</target>
        </trans-unit>
        <trans-unit id="d94ff9dc4d646834a0535298621e393784d6f1d3" translate="yes" xml:space="preserve">
          <source>Stop after the preprocessing stage; do not run the compiler proper. The output is in the form of preprocessed source code, which is sent to the standard output.</source>
          <target state="translated">在预处理阶段后停止,不要运行编译器正。输出的形式是预处理后的源代码,发送到标准输出。</target>
        </trans-unit>
        <trans-unit id="2daee47861dfd3c59bf8ff060a32e292f65fec05" translate="yes" xml:space="preserve">
          <source>Stop after the stage of compilation proper; do not assemble. The output is in the form of an assembler code file for each non-assembler input file specified.</source>
          <target state="translated">在适当的编译阶段后停止,不进行汇编。输出的形式是为每个指定的非汇编器输入文件提供汇编器代码文件。</target>
        </trans-unit>
        <trans-unit id="8347e9bfc02ac3a60787813c10d80e9ff680d75e" translate="yes" xml:space="preserve">
          <source>Stop forward growth if the best edge has probability lower than this threshold.</source>
          <target state="translated">如果最佳边缘的概率低于这个阈值,则停止向前生长。</target>
        </trans-unit>
        <trans-unit id="93e3b1851a75fdb25f8f9ca9807e49174553cf12" translate="yes" xml:space="preserve">
          <source>Stop forward growth if the probability of best edge is less than this threshold (in percent). Used when profile feedback is available.</source>
          <target state="translated">如果最佳边缘的概率小于该阈值(百分比),则停止向前生长。当有轮廓反馈时使用。</target>
        </trans-unit>
        <trans-unit id="5b2c101566fb4988550c86b87f1d88d336f66263" translate="yes" xml:space="preserve">
          <source>Stop reverse growth when the reverse probability of best edge is less than this threshold (in percent).</source>
          <target state="translated">当最佳边缘的反向概率小于此阈值时,停止反向增长(单位:%)。</target>
        </trans-unit>
        <trans-unit id="5b4aff278c0fdce3e7f55f32e7c895daaa47f804" translate="yes" xml:space="preserve">
          <source>Stop tail duplication once code growth has reached given percentage. This is a rather artificial limit, as most of the duplicates are eliminated later in cross jumping, so it may be set to much higher values than is the desired code growth.</source>
          <target state="translated">一旦代码增长达到给定的百分比,就停止尾部重复。这是一个相当人为的限制,因为大部分的重复都会在以后的交叉跳转中被消除,所以它可能被设置为比期望的代码增长高得多的值。</target>
        </trans-unit>
        <trans-unit id="e5524f873f830633dc8a23de8cf2d30b3d74c34d" translate="yes" xml:space="preserve">
          <source>Store (do not store) the address of the caller&amp;rsquo;s frame as backchain pointer into the callee&amp;rsquo;s stack frame. A backchain may be needed to allow debugging using tools that do not understand DWARF call frame information. When</source>
          <target state="translated">将调用方框架的地址作为后链指针存储（不存储）在被调用方的堆栈框架中。可能需要使用反向链才能使用不了解DWARF调用帧信息的工具进行调试。什么时候</target>
        </trans-unit>
        <trans-unit id="b16037d0dfeba50e99ce7619111826617ed26b77" translate="yes" xml:space="preserve">
          <source>Store data (but not code) in the big-endian format. The default is</source>
          <target state="translated">将数据(但不包括代码)以大英汉格式存储。默认为</target>
        </trans-unit>
        <trans-unit id="d1b3895de4641414ac79dc4d41b3d54519e0dbbf" translate="yes" xml:space="preserve">
          <source>Store the usual &amp;ldquo;temporary&amp;rdquo; intermediate files permanently. If the</source>
          <target state="translated">永久存储通常的&amp;ldquo;临时&amp;rdquo;中间文件。如果</target>
        </trans-unit>
        <trans-unit id="825a3542481737ba30d5e3c1a289571cd11217e5" translate="yes" xml:space="preserve">
          <source>Store the usual &amp;ldquo;temporary&amp;rdquo; intermediate files permanently; place them in the current directory and name them based on the source file. Thus, compiling</source>
          <target state="translated">永久存储通常的&amp;ldquo;临时&amp;rdquo;中间文件；将它们放在当前目录中，并根据源文件命名。因此，编译</target>
        </trans-unit>
        <trans-unit id="6a52a11a90147dcb5f7e83906aec646860b00234" translate="yes" xml:space="preserve">
          <source>Storing into the pointer can be done likewise with the same union.</source>
          <target state="translated">储存到指针中同样可以用同样的联合来完成。</target>
        </trans-unit>
        <trans-unit id="7e43c92861ad3e02cc7239ce0887aa080085a685" translate="yes" xml:space="preserve">
          <source>Storing the new address in &lt;code&gt;*&lt;var&gt;ra-address&lt;/var&gt;&lt;/code&gt;, if &lt;var&gt;ra-address&lt;/var&gt; is nonnull.</source>
          <target state="translated">如果 &lt;var&gt;ra-address&lt;/var&gt; 为非null ，则将新地址存储在 &lt;code&gt;*&lt;var&gt;ra-address&lt;/var&gt;&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="d51f83d4384be85e0661264f111bae505e048852" translate="yes" xml:space="preserve">
          <source>Stream extra information needed for aggressive devirtualization when running the link-time optimizer in local transformation mode. This option enables more devirtualization but significantly increases the size of streamed data. For this reason it is disabled by default.</source>
          <target state="translated">在本地转换模式下运行链路时间优化器时,流化激进的去虚拟化所需的额外信息。该选项可以实现更多的虚拟化,但会显著增加流数据的大小。因此,默认情况下,该选项是禁用的。</target>
        </trans-unit>
        <trans-unit id="474bfcc8400d6e8dacea61eec4b30865208de5b9" translate="yes" xml:space="preserve">
          <source>Structure members are stored sequentially in the order in which they are declared: the first member has the lowest memory address and the last member the highest.</source>
          <target state="translated">结构成员按其声明的顺序依次存储:第一个成员的内存地址最低,最后一个成员的内存地址最高。</target>
        </trans-unit>
        <trans-unit id="c3de1ed2a463e2a1c2ff86baf892b9da62d4e4d8" translate="yes" xml:space="preserve">
          <source>Structure of the JSON is following:</source>
          <target state="translated">JSON的结构如下。</target>
        </trans-unit>
        <trans-unit id="4a4ea855e21caf3a76611861328cfb1249cb6b2a" translate="yes" xml:space="preserve">
          <source>Structures with no members.</source>
          <target state="translated">没有成员的结构;</target>
        </trans-unit>
        <trans-unit id="9075bc2ab7ab689b643437d474f305a0857530db" translate="yes" xml:space="preserve">
          <source>Stubs are generated automatically by the linker if the following two conditions are met:</source>
          <target state="translated">如果满足以下两个条件,则由链接器自动生成存根。</target>
        </trans-unit>
        <trans-unit id="9013b380508240de43628bfd190a9b994da8e678" translate="yes" xml:space="preserve">
          <source>Substitute a file name that has suffix &lt;var&gt;suffix&lt;/var&gt; and is chosen once per compilation, and mark the argument in the same way as &amp;lsquo;</source>
          <target state="translated">替换后缀为 &lt;var&gt;suffix&lt;/var&gt; 且每次编译都选择一次的文件名，并以与'</target>
        </trans-unit>
        <trans-unit id="5a84f064e80a6c0f3317c7855f9c6ac2c41131d2" translate="yes" xml:space="preserve">
          <source>Substitute any of</source>
          <target state="translated">用以下任何一种替代</target>
        </trans-unit>
        <trans-unit id="998b2b0ec7c7cc0618199202723cd62e2208d036" translate="yes" xml:space="preserve">
          <source>Substitute one &amp;lsquo;</source>
          <target state="translated">替换一个'</target>
        </trans-unit>
        <trans-unit id="2d0f6708feea91da92348701c1acca054bd497b6" translate="yes" xml:space="preserve">
          <source>Substitute the basename of the input file being processed. This is the substring up to (and not including) the last period and not including the directory.</source>
          <target state="translated">替换正在处理的输入文件的基名。这是最后一个句号为止(不包括)的子串,不包括目录。</target>
        </trans-unit>
        <trans-unit id="1de1b430997906cd235f8cdbc3a04979f0ce1846" translate="yes" xml:space="preserve">
          <source>Substitute the contents of spec string &lt;var&gt;name&lt;/var&gt; at this point.</source>
          <target state="translated">此时，请替换规范字符串 &lt;var&gt;name&lt;/var&gt; 的内容。</target>
        </trans-unit>
        <trans-unit id="fd2fde2ae73c8516cb1a3cac098e2359e8a7c33a" translate="yes" xml:space="preserve">
          <source>Substitute the name of the input file being processed.</source>
          <target state="translated">代替正在处理的输入文件的名称。</target>
        </trans-unit>
        <trans-unit id="ae8eaa414e533e6922c45c08150cca1cb19b9be1" translate="yes" xml:space="preserve">
          <source>Substitute the variable part of a matched option. See below. Note that each comma in the substituted string is replaced by a single space.</source>
          <target state="translated">替换匹配期权的变量部分。见下文。请注意,被替换的字符串中的每个逗号都会被一个空格代替。</target>
        </trans-unit>
        <trans-unit id="43dec03cdd027bda7c71fa5dcb7ea1dab00d8963" translate="yes" xml:space="preserve">
          <source>Substitutes &lt;code&gt;X&lt;/code&gt; if either &lt;code&gt;-S&lt;/code&gt; or &lt;code&gt;-P&lt;/code&gt; is given to GCC. This may be combined with &amp;lsquo;</source>
          <target state="translated">如果将 &lt;code&gt;-S&lt;/code&gt; 或 &lt;code&gt;-P&lt;/code&gt; 给GCC，则替换 &lt;code&gt;X&lt;/code&gt; 。这可能与&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="e6be527872250ba01c3017e89b857046ca96045c" translate="yes" xml:space="preserve">
          <source>Substitutes &lt;code&gt;X&lt;/code&gt; if one or more switches whose names start with &lt;code&gt;-S&lt;/code&gt; are specified to GCC. Normally &lt;code&gt;X&lt;/code&gt; is substituted only once, no matter how many such switches appeared. However, if &lt;code&gt;%*&lt;/code&gt; appears somewhere in &lt;code&gt;X&lt;/code&gt;, then &lt;code&gt;X&lt;/code&gt; is substituted once for each matching switch, with the &lt;code&gt;%*&lt;/code&gt; replaced by the part of that switch matching the &lt;code&gt;*&lt;/code&gt;.</source>
          <target state="translated">如果将一个或多个名称以 &lt;code&gt;-S&lt;/code&gt; 开头的开关指定给GCC，则用 &lt;code&gt;X&lt;/code&gt; 代替。通常，无论出现多少这样的开关， &lt;code&gt;X&lt;/code&gt; 只会被替换一次。然而，如果 &lt;code&gt;%*&lt;/code&gt; 某处出现在 &lt;code&gt;X&lt;/code&gt; ，则 &lt;code&gt;X&lt;/code&gt; 是取代一次为每个匹配开关，用 &lt;code&gt;%*&lt;/code&gt; 由开关匹配的部分替换 &lt;code&gt;*&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="786d7f6a8f7f27970f79f53feb14051559d33597" translate="yes" xml:space="preserve">
          <source>Substitutes &lt;code&gt;X&lt;/code&gt;, if &lt;em&gt;not&lt;/em&gt; processing a file with suffix &lt;code&gt;S&lt;/code&gt;.</source>
          <target state="translated">替补 &lt;code&gt;X&lt;/code&gt; ，如果&lt;em&gt;不&lt;/em&gt;处理与后缀的文件 &lt;code&gt;S&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="864ccc2fa9d07c116ad04b8eeaefd7787e81b65c" translate="yes" xml:space="preserve">
          <source>Substitutes &lt;code&gt;X&lt;/code&gt;, if not processing a file for language &lt;code&gt;S&lt;/code&gt;.</source>
          <target state="translated">替补 &lt;code&gt;X&lt;/code&gt; ，如果不处理语言文件 &lt;code&gt;S&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="64dfa62f2736f224c236543aa31324e1526b2435" translate="yes" xml:space="preserve">
          <source>Substitutes &lt;code&gt;X&lt;/code&gt;, if processing a file for language &lt;code&gt;S&lt;/code&gt;.</source>
          <target state="translated">替补 &lt;code&gt;X&lt;/code&gt; ，如果处理语言文件 &lt;code&gt;S&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a6dded313927000e1a3934ea810bce16c0a202a3" translate="yes" xml:space="preserve">
          <source>Substitutes &lt;code&gt;X&lt;/code&gt;, if processing a file with suffix &lt;code&gt;S&lt;/code&gt;.</source>
          <target state="translated">替补 &lt;code&gt;X&lt;/code&gt; ，如果处理与后缀的文件 &lt;code&gt;S&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d0531e0f44345fcee0b59ff85181d8e187cb0d34" translate="yes" xml:space="preserve">
          <source>Substitutes &lt;code&gt;X&lt;/code&gt;, if the</source>
          <target state="translated">替换 &lt;code&gt;X&lt;/code&gt; ，如果</target>
        </trans-unit>
        <trans-unit id="381da79492b4d41df2595656917a76e838b4035d" translate="yes" xml:space="preserve">
          <source>Substitutes &lt;var&gt;.SUFFIX&lt;/var&gt; for the suffixes of a matched switch&amp;rsquo;s args when it is subsequently output with &amp;lsquo;</source>
          <target state="translated">匹配的开关的args后缀 &lt;var&gt;.SUFFIX&lt;/var&gt; 替换为随后输出的'</target>
        </trans-unit>
        <trans-unit id="330d507dbe426595b8910e78b9c215b447059d1c" translate="yes" xml:space="preserve">
          <source>Substitutes all the switches specified to GCC whose names start with &lt;code&gt;-S&lt;/code&gt;, but which also take an argument. This is used for switches like</source>
          <target state="translated">替换所有指定给GCC的开关，这些开关的名称以 &lt;code&gt;-S&lt;/code&gt; 开头，但也带有一个参数。这用于像</target>
        </trans-unit>
        <trans-unit id="83c0a4e01bdd2a1adfb064f09d23d09f40d1cc63" translate="yes" xml:space="preserve">
          <source>Substitutes the &lt;code&gt;-S&lt;/code&gt; switch, if that switch is given to GCC. If that switch is not specified, this substitutes nothing. Note that the leading dash is omitted when specifying this option, and it is automatically inserted if the substitution is performed. Thus the spec string &amp;lsquo;</source>
          <target state="translated">如果将 &lt;code&gt;-S&lt;/code&gt; 开关分配给GCC，则将其替换。如果未指定该开关，则不会替代任何内容。请注意，指定此选项时省略了前划线，如果执行替换，它将自动插入。因此，规范字符串'</target>
        </trans-unit>
        <trans-unit id="3c13db3d4f7d55a97362e7f68ba24cf3424c2837" translate="yes" xml:space="preserve">
          <source>Substitutes the last file name generated with &amp;lsquo;</source>
          <target state="translated">替换用'生成的最后一个文件名</target>
        </trans-unit>
        <trans-unit id="4b4f52841be7dd8b1c205fb48bea71f8dc73cc8b" translate="yes" xml:space="preserve">
          <source>Substitutes the name of the &lt;code&gt;HOST_BIT_BUCKET&lt;/code&gt;, if any, and if it is writable, and if</source>
          <target state="translated">替换 &lt;code&gt;HOST_BIT_BUCKET&lt;/code&gt; 的名称（如果有），是否可写以及</target>
        </trans-unit>
        <trans-unit id="510d92a70f7a6df088d50db8add12d77997610de" translate="yes" xml:space="preserve">
          <source>Substitutes the names of all the output files, with spaces automatically placed around them. You should write spaces around the &amp;lsquo;</source>
          <target state="translated">替换所有输出文件的名称，并在它们周围自动放置空格。您应该在&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="37e406a2f9f9f2524ce85dd8f1df47e0fcb53fb6" translate="yes" xml:space="preserve">
          <source>Substitutes the standard macro predefinitions for the current target machine. Use this when running &lt;code&gt;cpp&lt;/code&gt;.</source>
          <target state="translated">将标准宏预定义替换为当前目标计算机。运行 &lt;code&gt;cpp&lt;/code&gt; 时使用它。</target>
        </trans-unit>
        <trans-unit id="601b96766181d9e1c5aa982978f52e20aab04d35" translate="yes" xml:space="preserve">
          <source>Substitutes the suffix for object files. Note that this is handled specially when it immediately follows &amp;lsquo;</source>
          <target state="translated">将后缀替换为目标文件。请注意，当它紧跟在'</target>
        </trans-unit>
        <trans-unit id="ebb148237b08e3751f6fc1e4dce1cbcd763ff06d" translate="yes" xml:space="preserve">
          <source>Subtraction, multiplication, division, and the logical operations operate in a similar manner. Likewise, the result of using the unary minus or complement operators on a vector type is a vector whose elements are the negative or complemented values of the corresponding elements in the operand.</source>
          <target state="translated">减法、乘法、除法和逻辑运算的操作方式类似。同样,在向量类型上使用单利减或补运算符的结果是一个向量,其元素是操作数中相应元素的负值或补值。</target>
        </trans-unit>
        <trans-unit id="9ed92f9622e5eda43509c60bb3049fa12fe5ec7f" translate="yes" xml:space="preserve">
          <source>Such a feature would work only occasionally&amp;mdash;only for calls that appear in the same file as the called function, following the definition. The only way to check all calls reliably is to add a prototype for the function. But adding a prototype eliminates the motivation for this feature. So the feature is not worthwhile.</source>
          <target state="translated">此类功能仅在偶然情况下起作用-仅适用于遵循定义的，与被调用函数位于同一文件中的调用。可靠地检查所有调用的唯一方法是为函数添加原型。但是添加原型消除了此功能的动机。因此该功能不值得。</target>
        </trans-unit>
        <trans-unit id="5af0feab651599b508e437900c6cfc81abd2fe41" translate="yes" xml:space="preserve">
          <source>Such accesses are supported, subject to the same requirements for synchronization for concurrent accesses as for concurrent accesses to any object.</source>
          <target state="translated">支持这种访问,但对并发访问的同步要求与对任何对象的并发访问相同。</target>
        </trans-unit>
        <trans-unit id="4cfbaa1bf62e72b4bca886bc067e3bd96ad98df4" translate="yes" xml:space="preserve">
          <source>Such an array of label values serves a purpose much like that of the &lt;code&gt;switch&lt;/code&gt; statement. The &lt;code&gt;switch&lt;/code&gt; statement is cleaner, so use that rather than an array unless the problem does not fit a &lt;code&gt;switch&lt;/code&gt; statement very well.</source>
          <target state="translated">这样的标签值数组的用途非常类似于 &lt;code&gt;switch&lt;/code&gt; 语句。该 &lt;code&gt;switch&lt;/code&gt; 语句是清洁的，所以使用，而不是一个数组，除非这个问题不适合一个 &lt;code&gt;switch&lt;/code&gt; 语句非常好。</target>
        </trans-unit>
        <trans-unit id="4348530a5b230f9786021cf2cdbed2168537bbe7" translate="yes" xml:space="preserve">
          <source>Such an object is normally accessed by pointers and used for accessing hardware. In most expressions, it is intuitively obvious what is a read and what is a write. For example</source>
          <target state="translated">这样的对象通常是通过指针访问的,用于访问硬件。在大多数表达式中,什么是读,什么是写,直观上是很明显的。例如</target>
        </trans-unit>
        <trans-unit id="7e9903330f56016812404c897216c2074bedf62f" translate="yes" xml:space="preserve">
          <source>Such argument passing is supported, using the same pass-by-invisible-reference approach used for normal function arguments of such types.</source>
          <target state="translated">支持这样的参数传递,使用与此类类型的普通函数参数相同的按不可见引用传递的方法。</target>
        </trans-unit>
        <trans-unit id="fdaf5b5f6a3d1715a900b4b2779de302364392a5" translate="yes" xml:space="preserve">
          <source>Such assignments must be very common; warning about them would cause more annoyance than good.</source>
          <target state="translated">这样的作业一定是非常普遍的,如果对其进行警告,会造成更多的烦恼,而不是好事。</target>
        </trans-unit>
        <trans-unit id="fc536d9f079301ea3cff9bd45f17bf843dbe50ad" translate="yes" xml:space="preserve">
          <source>Such built-in functions are provided for &lt;code&gt;memcpy&lt;/code&gt;, &lt;code&gt;mempcpy&lt;/code&gt;, &lt;code&gt;memmove&lt;/code&gt;, &lt;code&gt;memset&lt;/code&gt;, &lt;code&gt;strcpy&lt;/code&gt;, &lt;code&gt;stpcpy&lt;/code&gt;, &lt;code&gt;strncpy&lt;/code&gt;, &lt;code&gt;strcat&lt;/code&gt; and &lt;code&gt;strncat&lt;/code&gt;.</source>
          <target state="translated">为 &lt;code&gt;memcpy&lt;/code&gt; ， &lt;code&gt;mempcpy&lt;/code&gt; ， &lt;code&gt;memmove&lt;/code&gt; ， &lt;code&gt;memset&lt;/code&gt; ， &lt;code&gt;strcpy&lt;/code&gt; ， &lt;code&gt;stpcpy&lt;/code&gt; ， &lt;code&gt;strncpy&lt;/code&gt; ， &lt;code&gt;strcat&lt;/code&gt; 和 &lt;code&gt;strncat&lt;/code&gt; 提供了此类内置函数。</target>
        </trans-unit>
        <trans-unit id="7a73b44a4d02b7ee2f589148448bb9f1b269841d" translate="yes" xml:space="preserve">
          <source>Such code is suitable for level 0 PA systems and kernels.</source>
          <target state="translated">这种代码适用于0级PA系统和内核。</target>
        </trans-unit>
        <trans-unit id="221482fe63639c70a1d813f43faebcec11cd2c30" translate="yes" xml:space="preserve">
          <source>Such expressions are rvalues, and GCC implements this as a read of the volatile object being pointed to.</source>
          <target state="translated">这样的表达式是rvalues,GCC将其实现为对被指向的volatile对象的读取。</target>
        </trans-unit>
        <trans-unit id="44cf0f4f846947a1f248438be1e959f7db481213" translate="yes" xml:space="preserve">
          <source>Such tokens may not be concatenated.</source>
          <target state="translated">此类令牌不可连用。</target>
        </trans-unit>
        <trans-unit id="2bba52ae9199f8bd23584e0938f470a93242074f" translate="yes" xml:space="preserve">
          <source>Support &lt;em&gt;IBM RS/6000 SP&lt;/em&gt;&lt;em&gt;Parallel Environment&lt;/em&gt; (PE). Link an application written to use message passing with special startup code to enable the application to run. The system must have PE installed in the standard location (</source>
          <target state="translated">支持&lt;em&gt;IBM RS / 6000 SP &lt;/em&gt;&lt;em&gt;并行环境&lt;/em&gt;（PE）。链接编写的使用消息传递的应用程序和特殊的启动代码，以使应用程序能够运行。系统必须在标准位置安装了PE（</target>
        </trans-unit>
        <trans-unit id="075bd5530c2b703c7849a9e331065651957bda71" translate="yes" xml:space="preserve">
          <source>Support ISO C trigraphs. These are three-character sequences, all starting with &amp;lsquo;</source>
          <target state="translated">支持ISO C三部曲。这些是三个字符的序列，都以&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="8219e8938cf7630391bdb51b3542081a049cff2c" translate="yes" xml:space="preserve">
          <source>Support all ISO C90 programs (certain GNU extensions that conflict with ISO C90 are disabled). Same as</source>
          <target state="translated">支持所有ISO C90程序(某些与ISO C90冲突的GNU扩展名被禁用)。同</target>
        </trans-unit>
        <trans-unit id="54fea23628caa918a67b27ac084d811f983c065d" translate="yes" xml:space="preserve">
          <source>Support for &lt;code&gt;+resolveInstanceMethod:&lt;/code&gt; and &lt;code&gt;resolveClassMethod:&lt;/code&gt; was added to the GNU Objective-C runtime in GCC version 4.6.</source>
          <target state="translated">对 &lt;code&gt;+resolveInstanceMethod:&lt;/code&gt; 和 &lt;code&gt;resolveClassMethod:&lt;/code&gt; 的支持已添加到GCC 4.6版的GNU Objective-C运行时中。</target>
        </trans-unit>
        <trans-unit id="dd68cf9e9a0ec7bc0fc781d9f962022790ff0418" translate="yes" xml:space="preserve">
          <source>Support for decimal floating types includes the arithmetic operators add, subtract, multiply, divide; unary arithmetic operators; relational operators; equality operators; and conversions to and from integer and other floating types. Use a suffix &amp;lsquo;</source>
          <target state="translated">对十进制浮点类型的支持包括算术运算符加，减，乘，除；一元算术运算符；关系运算符；平等经营者；以及与整数和其他浮动类型之间的转换。使用后缀'</target>
        </trans-unit>
        <trans-unit id="81ca39c921120d2adfd04ac948aaa079d0c3ae01" translate="yes" xml:space="preserve">
          <source>Support for fixed-point types includes:</source>
          <target state="translated">对定点类型的支持包括:</target>
        </trans-unit>
        <trans-unit id="5e968c4a4e334d0a74a0d1d72a11bad05634a930" translate="yes" xml:space="preserve">
          <source>Support for garbage collection with the GNU runtime has been added by using a powerful conservative garbage collector, known as the Boehm-Demers-Weiser conservative garbage collector.</source>
          <target state="translated">通过使用一个强大的保守型垃圾收集器,即Boehm-Demers-Weiser保守型垃圾收集器,增加了对GNU运行时垃圾收集的支持。</target>
        </trans-unit>
        <trans-unit id="03b50bd9ac9ebf90f9a5662b1d0f6ab814a76b5a" translate="yes" xml:space="preserve">
          <source>Support for streams has been removed and the string to be printed will always be sent to stdout via the &lt;code&gt;write&lt;/code&gt; syscall. The string is not buffered before it is sent to write.</source>
          <target state="translated">对流的支持已删除，要打印的字符串将始终通过 &lt;code&gt;write&lt;/code&gt; syscall发送到stdout 。该字符串在发送前不进行缓冲写入。</target>
        </trans-unit>
        <trans-unit id="0504a68e0c39cc0a79b57df0e39cf16b54d9e942" translate="yes" xml:space="preserve">
          <source>Support for these additional types includes the arithmetic operators: add, subtract, multiply, divide; unary arithmetic operators; relational operators; equality operators; and conversions to and from integer and other floating types. Use a suffix &amp;lsquo;</source>
          <target state="translated">对这些附加类型的支持包括算术运算符：加，减，乘，除；一元算术运算符；关系运算符；平等经营者；以及与整数和其他浮动类型之间的转换。使用后缀'</target>
        </trans-unit>
        <trans-unit id="43f86c51be480704f6fd0e7ee0fe1bad4e5dee50" translate="yes" xml:space="preserve">
          <source>Support thread-safe exception handling on MinGW. Programs that rely on thread-safe exception handling must compile and link all code with the</source>
          <target state="translated">在MinGW上支持线程安全异常处理。依赖于线程安全异常处理的程序必须编译并将所有的代码与线程安全异常处理链接起来。</target>
        </trans-unit>
        <trans-unit id="b789d7421ca6bd2ef122f7c0fe30f55f0075ed29" translate="yes" xml:space="preserve">
          <source>Supported values for &lt;var&gt;cpu&lt;/var&gt; are</source>
          <target state="translated">为支持的值 &lt;var&gt;cpu&lt;/var&gt; 是</target>
        </trans-unit>
        <trans-unit id="4bb84e33320d5d24d55a608a57ed95d8069c1f60" translate="yes" xml:space="preserve">
          <source>Supported values for &lt;var&gt;cpu_type&lt;/var&gt; are</source>
          <target state="translated">为支持的值 &lt;var&gt;cpu_type&lt;/var&gt; 的是</target>
        </trans-unit>
        <trans-unit id="e586e3e5b6ddb947a96ee95bbf9931e047b7a75c" translate="yes" xml:space="preserve">
          <source>Suppose for example you have a &lt;code&gt;FileStream&lt;/code&gt; class that declares &lt;code&gt;Stdin&lt;/code&gt;, &lt;code&gt;Stdout&lt;/code&gt; and &lt;code&gt;Stderr&lt;/code&gt; as global variables, like below:</source>
          <target state="translated">假设比如你有一个 &lt;code&gt;FileStream&lt;/code&gt; 声明类 &lt;code&gt;Stdin&lt;/code&gt; ， &lt;code&gt;Stdout&lt;/code&gt; 和 &lt;code&gt;Stderr&lt;/code&gt; 为全局变量，象下面这样：</target>
        </trans-unit>
        <trans-unit id="e59b9335cfc4b19ac5e0c2f6fad649ab56af701c" translate="yes" xml:space="preserve">
          <source>Suppose the type &lt;code&gt;uid_t&lt;/code&gt; happens to be &lt;code&gt;short&lt;/code&gt;. ISO C does not allow this example, because subword arguments in old-style non-prototype definitions are promoted. Therefore in this example the function definition&amp;rsquo;s argument is really an &lt;code&gt;int&lt;/code&gt;, which does not match the prototype argument type of &lt;code&gt;short&lt;/code&gt;.</source>
          <target state="translated">假设 &lt;code&gt;uid_t&lt;/code&gt; 类型恰好是 &lt;code&gt;short&lt;/code&gt; 。ISO C不允许使用此示例，因为会提升旧式非原型定义中的子字参数。因此，在此示例中，函数定义的参数实际上是一个 &lt;code&gt;int&lt;/code&gt; ，它与 &lt;code&gt;short&lt;/code&gt; 的原型参数类型不匹配。</target>
        </trans-unit>
        <trans-unit id="48ba8dd72d18863780aea11859486731c35e5eea" translate="yes" xml:space="preserve">
          <source>Suppress the generation of link options to search libdld.sl when the</source>
          <target state="translated">时,禁止生成搜索libdld.sl的链接选项。</target>
        </trans-unit>
        <trans-unit id="d35c9ca6cfae417ba88541dbae7bd0b48fb96152" translate="yes" xml:space="preserve">
          <source>Suppress warning messages emitted by &lt;code&gt;#warning&lt;/code&gt; directives.</source>
          <target state="translated">禁止 &lt;code&gt;#warning&lt;/code&gt; 指令发出的警告消息。</target>
        </trans-unit>
        <trans-unit id="7f779f6a3dd8fc46f68f940fe5b38cc8f0332cb0" translate="yes" xml:space="preserve">
          <source>Suppress warnings about inheriting from a virtual base with a non-trivial C++11 move assignment operator. This is dangerous because if the virtual base is reachable along more than one path, it is moved multiple times, which can mean both objects end up in the moved-from state. If the move assignment operator is written to avoid moving from a moved-from object, this warning can be disabled.</source>
          <target state="translated">抑制关于使用非平凡的 C++11 移动分配操作符从虚拟基继承的警告。这是很危险的,因为如果虚拟基地可以沿着一条以上的路径到达,那么它就会被多次移动,这可能意味着两个对象最终都处于moved-from状态。如果编写的移动赋值运算符是为了避免从moved-from对象移动,那么这个警告可以被禁用。</target>
        </trans-unit>
        <trans-unit id="48a42269132ea484d01ac088e414c9e42de642c6" translate="yes" xml:space="preserve">
          <source>Suppress warnings about use of C++11 inheriting constructors when the base class inherited from has a C variadic constructor; the warning is on by default because the ellipsis is not inherited.</source>
          <target state="translated">当继承的基类有C变量构造函数时,抑制对使用C++11继承构造函数的警告;由于省略号没有被继承,所以该警告默认为开启。</target>
        </trans-unit>
        <trans-unit id="cb3aae6f5324c78295db9baccb5bafa853510ca1" translate="yes" xml:space="preserve">
          <source>Suppress warnings from applying the &lt;code&gt;offsetof&lt;/code&gt; macro to a non-POD type. According to the 2014 ISO C++ standard, applying &lt;code&gt;offsetof&lt;/code&gt; to a non-standard-layout type is undefined. In existing C++ implementations, however, &lt;code&gt;offsetof&lt;/code&gt; typically gives meaningful results. This flag is for users who are aware that they are writing nonportable code and who have deliberately chosen to ignore the warning about it.</source>
          <target state="translated">禁止将 &lt;code&gt;offsetof&lt;/code&gt; 宏应用于非POD类型的警告。根据2014 ISO C ++标准，未将 &lt;code&gt;offsetof&lt;/code&gt; 应用于非标准布局类型。但是，在现有的C ++实现中， &lt;code&gt;offsetof&lt;/code&gt; 通常会给出有意义的结果。该标志适用于意识到自己正在编写不可移植的代码并且故意选择忽略有关该警告的用户。</target>
        </trans-unit>
        <trans-unit id="ba83304e4c99868bbbe79f9fdcf9011c9415eab0" translate="yes" xml:space="preserve">
          <source>Suppress warnings from casts from a pointer to an integer type of a different size.</source>
          <target state="translated">抑制从指针投掷到不同大小的整数类型的警告。</target>
        </trans-unit>
        <trans-unit id="ef9b18daa97b7e3ff555e42290cbf027c56dba77" translate="yes" xml:space="preserve">
          <source>Suppress warnings from casts to pointer type of an integer of a different size. In C++, casting to a pointer type of smaller size is an error.</source>
          <target state="translated">抑制对不同大小的整数指针类型的投掷的警告。在C++中,投射到一个较小的指针类型是一个错误。</target>
        </trans-unit>
        <trans-unit id="d5c7bd9509193e71d10cdb667e9063dd06de3280" translate="yes" xml:space="preserve">
          <source>Suppress warnings when a positional initializer is used to initialize a structure that has been marked with the &lt;code&gt;designated_init&lt;/code&gt; attribute.</source>
          <target state="translated">当使用位置初始值设定项来初始化已用 &lt;code&gt;designated_init&lt;/code&gt; 属性标记的结构时，禁止显示警告。</target>
        </trans-unit>
        <trans-unit id="b5db30b4023b1a002e3bf61c91080c305981c620" translate="yes" xml:space="preserve">
          <source>Switch ARM/Thumb modes on alternating functions. This option is provided for regression testing of mixed Thumb/ARM code generation, and is not intended for ordinary use in compiling code.</source>
          <target state="translated">在交替函数上切换ARM/Thumb模式。此选项是为Thumb/ARM混合代码生成的回归测试而提供的,并不打算在编译代码时作普通使用。</target>
        </trans-unit>
        <trans-unit id="d7301da94a751f6929a8a4eed4be94e8d5777d3a" translate="yes" xml:space="preserve">
          <source>Switch initialization conversion refuses to create arrays that are bigger than</source>
          <target state="translated">交换机初始化转换拒绝创建大于</target>
        </trans-unit>
        <trans-unit id="aaf2d10ad0dec99d41b3214114d91b1b2422b89f" translate="yes" xml:space="preserve">
          <source>Switch to code generation variant that allows to execute all threads in each warp, while maintaining memory state and side effects as if only one thread in each warp was active outside of OpenMP SIMD regions. All atomic operations and calls to runtime (malloc, free, vprintf) are conditionally executed (iff current lane index equals the master lane index), and the register being assigned is copied via a shuffle instruction from the master lane. Outside of SIMD regions lane 0 is the master; inside, each thread sees itself as the master. Shared memory array &lt;code&gt;int __nvptx_uni[]&lt;/code&gt; stores all-zeros or all-ones bitmasks for each warp, indicating current mode (0 outside of SIMD regions). Each thread can bitwise-and the bitmask at position &lt;code&gt;tid.y&lt;/code&gt; with current lane index to compute the master lane index.</source>
          <target state="translated">切换到代码生成变量，该变量允许在每个warp中执行所有线程，同时保持内存状态和副作用，就好像每个warp中只有一个线程在OpenMP SIMD区域之外处于活动状态。所有原子操作和对运行时的调用（malloc，free，vprintf）都将有条件地执行（当前通道索引等于主通道索引），并且通过主指令通过shuffle指令复制要分配的寄存器。在SIMD区域之外，通道0是主通道；在内部，每个线程都将自己视为主线程。共享内存数组 &lt;code&gt;int __nvptx_uni[]&lt;/code&gt; 为每个扭曲存储全零或全一的位掩码，指示当前模式（SIMD区域之外的0）。每个线程都可以按位-并且位掩码位于位置 &lt;code&gt;tid.y&lt;/code&gt; 使用当前车道索引来计算主车道索引。</target>
        </trans-unit>
        <trans-unit id="df31493a786b81749ab4d7d1c6bbb6b81f2ef537" translate="yes" xml:space="preserve">
          <source>Symbolic constant for call/jump instruction.</source>
          <target state="translated">用于调用/跳转指令的符号常数。</target>
        </trans-unit>
        <trans-unit id="d02b75640f5617b344a6fd481b4fcf74a33c7dab" translate="yes" xml:space="preserve">
          <source>Synonyms for</source>
          <target state="translated">同义词</target>
        </trans-unit>
        <trans-unit id="a7f02fe7170bb60802488281e7b6535e4525bc7a" translate="yes" xml:space="preserve">
          <source>Syntax without an explicit &lt;var&gt;opts&lt;/var&gt; parameter is deprecated. It is equivalent to specifying an &lt;var&gt;opts&lt;/var&gt; list of:</source>
          <target state="translated">不建议使用不带显式 &lt;var&gt;opts&lt;/var&gt; 参数的语法。它相当于指定 &lt;var&gt;opts&lt;/var&gt; 的列表：</target>
        </trans-unit>
        <trans-unit id="fb5461d0f57b9c531d984331d59cfb9c2b43a2f9" translate="yes" xml:space="preserve">
          <source>System V Release 4 small data area reference</source>
          <target state="translated">系统五第4版小数据区参考</target>
        </trans-unit>
        <trans-unit id="e4a39789bd7be8b8dfec91a966c5aa35d6a313b6" translate="yes" xml:space="preserve">
          <source>TI ABI specifies that function (code) pointers are 16-bit, whereas GNU supports only 32-bit data and code pointers.</source>
          <target state="translated">TI ABI规定函数(代码)指针为16位,而GNU只支持32位数据和代码指针。</target>
        </trans-unit>
        <trans-unit id="2218a74f01f0ccb4e48f5247664f57112a4f0aaf" translate="yes" xml:space="preserve">
          <source>TI C6X family&amp;mdash;</source>
          <target state="translated">TI C6X系列&amp;mdash;</target>
        </trans-unit>
        <trans-unit id="c941de06f499163c146e2988a363757665dd2da4" translate="yes" xml:space="preserve">
          <source>TILE-Gx&amp;mdash;</source>
          <target state="translated">TILE-Gx&amp;mdash;</target>
        </trans-unit>
        <trans-unit id="94413aebaec1d35ed29622efe6a91644c6c91dd4" translate="yes" xml:space="preserve">
          <source>TILEPro&amp;mdash;</source>
          <target state="translated">TILEPro&amp;mdash;</target>
        </trans-unit>
        <trans-unit id="9730d4326a7b8a0d13c2be3b7fe29b80ad152bf6" translate="yes" xml:space="preserve">
          <source>Table of Contents</source>
          <target state="translated">目录</target>
        </trans-unit>
        <trans-unit id="ecd7eecc4f728ae74383a27923d7203db8bfeb4c" translate="yes" xml:space="preserve">
          <source>Take advantage of linker relaxations to reduce the number of instructions required to materialize symbol addresses. The default is to take advantage of linker relaxations.</source>
          <target state="translated">利用链接器松弛来减少实现符号地址所需的指令数量。默认情况下是利用链接器松弛。</target>
        </trans-unit>
        <trans-unit id="01d35405dd4f6f085c687c5306bb4a6e617f2e88" translate="yes" xml:space="preserve">
          <source>Taking the address of a &lt;code&gt;union&lt;/code&gt; or a &lt;code&gt;struct&lt;/code&gt; with reverse scalar storage order is permitted.</source>
          <target state="translated">允许采用标量存储顺序相反的 &lt;code&gt;union&lt;/code&gt; 或 &lt;code&gt;struct&lt;/code&gt; 的地址。</target>
        </trans-unit>
        <trans-unit id="9ff36b684e3489808b01be7efb64c6849f9ba0f5" translate="yes" xml:space="preserve">
          <source>Taking the address of a label may generate errors from the HP-UX PA assembler. GAS for the PA does not have this problem.</source>
          <target state="translated">取标签的地址可能会从HP-UX PA汇编器中产生错误。而PA的GAS则没有这个问题。</target>
        </trans-unit>
        <trans-unit id="8c7129ffec0f9a33a9ffe8b44de153b8593725b3" translate="yes" xml:space="preserve">
          <source>Taking the address of a scalar field of a &lt;code&gt;union&lt;/code&gt; or a &lt;code&gt;struct&lt;/code&gt; with reverse scalar storage order is not permitted and yields an error.</source>
          <target state="translated">不允许使用标量存储顺序相反的 &lt;code&gt;union&lt;/code&gt; 或 &lt;code&gt;struct&lt;/code&gt; 的标量字段的地址，并且会产生错误。</target>
        </trans-unit>
        <trans-unit id="9f5bfaf20daa2c55100557696546e467c263a569" translate="yes" xml:space="preserve">
          <source>Taking the address of an array field, whose component is scalar, of a &lt;code&gt;union&lt;/code&gt; or a &lt;code&gt;struct&lt;/code&gt; with reverse scalar storage order is permitted but yields a warning, unless</source>
          <target state="translated">允许采用具有标量存储顺序相反的 &lt;code&gt;union&lt;/code&gt; 或 &lt;code&gt;struct&lt;/code&gt; 的数组字段（其成分为标量）的地址，但会产生警告，除非</target>
        </trans-unit>
        <trans-unit id="eb41297adae8dd10c30aff884697e8695add6957" translate="yes" xml:space="preserve">
          <source>Taking this into account, it is important to note the following:</source>
          <target state="translated">考虑到这一点,必须注意以下几点:</target>
        </trans-unit>
        <trans-unit id="c69e706d0180e6de86eaea828036822f65c39e90" translate="yes" xml:space="preserve">
          <source>Target architectures are encouraged to provide their own patterns for each of the atomic built-in functions. If no target is provided, the original non-memory model set of &amp;lsquo;</source>
          <target state="translated">鼓励目标体系结构为每个原子内置函数提供其自己的模式。如果未提供目标，则原始的非内存模型集为&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="f7c745960637a96625efff80e3b7b6cb80a28125" translate="yes" xml:space="preserve">
          <source>Target has split instruction and data space. Implies -m45.</source>
          <target state="translated">目标有分割的指令和数据空间。意味着-m45。</target>
        </trans-unit>
        <trans-unit id="70857ff656af8497b29b5cea7cede66fd2b8d04e" translate="yes" xml:space="preserve">
          <source>Target-specific attributes that affect the identity of a type, such as ia32 calling conventions on a function type (stdcall, regparm, etc.), did not affect the mangled name, leading to name collisions when function pointers were used as template arguments.</source>
          <target state="translated">影响类型身份的特定目标属性,如函数类型上的ia32调用约定(stdcall、regparm等),并不影响乱名,导致函数指针被用作模板参数时出现名称碰撞。</target>
        </trans-unit>
        <trans-unit id="55ac9adb172fe07da9b52a8103d4a87829fbaae5" translate="yes" xml:space="preserve">
          <source>Target-specific options, such as compiling for a specific processor variant.</source>
          <target state="translated">特定于目标的选项,例如为特定的处理器变种编译。</target>
        </trans-unit>
        <trans-unit id="82a660e45a245ce196b4fdfa2d1b2b50ce849614" translate="yes" xml:space="preserve">
          <source>Tell the MIPS assembler to not run its preprocessor over user assembler files (with a &amp;lsquo;</source>
          <target state="translated">告诉MIPS汇编程序不要在用户汇编程序文件上运行其预处理程序（使用'</target>
        </trans-unit>
        <trans-unit id="68c3b5335b5c0cc22332ebfdb31ac1bb53445273" translate="yes" xml:space="preserve">
          <source>Tells the compiler that any variable marked with the &lt;code&gt;io&lt;/code&gt; attribute is to be considered volatile.</source>
          <target state="translated">告诉编译器将任何带有 &lt;code&gt;io&lt;/code&gt; 属性标记的变量视为易失性。</target>
        </trans-unit>
        <trans-unit id="6c80eca69977e6b469c44eecba1a817d3b44f7d0" translate="yes" xml:space="preserve">
          <source>Tells the compiler to perform function calls by first loading the address of the function into a register and then performing a subroutine call on this register. This switch is needed if the target function lies outside of the 24-bit addressing range of the offset-based version of subroutine call instruction.</source>
          <target state="translated">告诉编译器在执行函数调用时,首先将函数的地址加载到一个寄存器中,然后对这个寄存器进行子程序调用。如果目标函数位于基于偏移量的子程序调用指令版本的24位寻址范围之外,则需要这个开关。</target>
        </trans-unit>
        <trans-unit id="f7974b9f9368d29b382ac1425edcaf88973b1540" translate="yes" xml:space="preserve">
          <source>Tells the compiler to perform function calls by first loading the address of the function into a register and then performing a subroutine call on this register. This switch is needed if the target function lies outside of the 64-megabyte addressing range of the offset-based version of subroutine call instruction.</source>
          <target state="translated">告诉编译器在执行函数调用时,首先将函数的地址加载到一个寄存器中,然后对这个寄存器进行子程序调用。如果目标函数位于基于偏移的子程序调用指令版本的64兆字节寻址范围之外,则需要这个开关。</target>
        </trans-unit>
        <trans-unit id="4035c3eab8e73aa47237d7e7a48fe4ab59208c8f" translate="yes" xml:space="preserve">
          <source>Template Instantiations</source>
          <target state="translated">模板实例</target>
        </trans-unit>
        <trans-unit id="eb2cd45b5c86db640ab845c9538624992d63586f" translate="yes" xml:space="preserve">
          <source>Temporaries may vanish before you expect</source>
          <target state="translated">暂时性的可能在你意料之外消失</target>
        </trans-unit>
        <trans-unit id="9f5670dc2252e3e0202f196c05a183f0e891e7ce" translate="yes" xml:space="preserve">
          <source>Temporary assist register $ta (i.e. $r15).</source>
          <target state="translated">临时助理登记费ta元(即15元)。</target>
        </trans-unit>
        <trans-unit id="f01689c0a988a52e1980b89817f9a193bf32f058" translate="yes" xml:space="preserve">
          <source>Temporary register r0</source>
          <target state="translated">临时寄存器r0</target>
        </trans-unit>
        <trans-unit id="eb69100c455a5efc5c637f0862041f54fcc63021" translate="yes" xml:space="preserve">
          <source>That code overwrites the variable &lt;code&gt;Index&lt;/code&gt; (&amp;lsquo;</source>
          <target state="translated">该代码将覆盖变量 &lt;code&gt;Index&lt;/code&gt; （'</target>
        </trans-unit>
        <trans-unit id="93ef0dd827103681fcee453b78be2ff14e1a261d" translate="yes" xml:space="preserve">
          <source>The</source>
          <target state="translated">The</target>
        </trans-unit>
        <trans-unit id="3d372c7173ccc49ed5f8266482156df6e30a1a0e" translate="yes" xml:space="preserve">
          <source>The &amp;ldquo;bool&amp;rdquo; version returns &lt;code&gt;true&lt;/code&gt; if the comparison is successful and &lt;var&gt;newval&lt;/var&gt; is written. The &amp;ldquo;val&amp;rdquo; version returns the contents of &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt; before the operation.</source>
          <target state="translated">如果比较成功并且写入了 &lt;var&gt;newval&lt;/var&gt; ,则&amp;ldquo; bool&amp;rdquo;版本将返回 &lt;code&gt;true&lt;/code&gt; 。&amp;ldquo; val&amp;rdquo;版本在操作之前返回 &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt; &lt;var&gt;ptr&lt;/var&gt; 的内容。</target>
        </trans-unit>
        <trans-unit id="09bc8f2a14ab55c654c682384317bfec0642af39" translate="yes" xml:space="preserve">
          <source>The &amp;ldquo;signature&amp;rdquo; is a null-terminated string, composed of the following:</source>
          <target state="translated">&amp;ldquo;签名&amp;rdquo;是一个以零结尾的字符串，由以下内容组成：</target>
        </trans-unit>
        <trans-unit id="4c06e97499a27f0f80d31e89637ece588d8ec278" translate="yes" xml:space="preserve">
          <source>The &amp;ldquo;user time&amp;rdquo; and the &amp;ldquo;system time&amp;rdquo; are moved before the program name, and the options passed to the program are displayed, so that one can later tell what file was being compiled, and with which options.</source>
          <target state="translated">将&amp;ldquo;用户时间&amp;rdquo;和&amp;ldquo;系统时间&amp;rdquo;移到程序名称之前，并显示传递给程序的选项，以便以后可以知道正在编译的文件以及使用的选项。</target>
        </trans-unit>
        <trans-unit id="0ed4c9f9933dd9e4b8da3ca824145866c18f6a63" translate="yes" xml:space="preserve">
          <source>The &amp;lsquo;</source>
          <target state="translated">'</target>
        </trans-unit>
        <trans-unit id="9820649111d032078a2e341b12a064c77a65bbc2" translate="yes" xml:space="preserve">
          <source>The 16-bit &lt;code&gt;R10&lt;/code&gt; register.</source>
          <target state="translated">16位 &lt;code&gt;R10&lt;/code&gt; 寄存器。</target>
        </trans-unit>
        <trans-unit id="8cd88b0aaf75b51696b24c3768a2b1a20915edac" translate="yes" xml:space="preserve">
          <source>The 16-bit &lt;code&gt;R8&lt;/code&gt; register.</source>
          <target state="translated">16位 &lt;code&gt;R8&lt;/code&gt; 寄存器。</target>
        </trans-unit>
        <trans-unit id="b1272239002f51f4809e26667c1b13c1b964633d" translate="yes" xml:space="preserve">
          <source>The 1998 ISO C++ standard plus the 2003 technical corrigendum and some additional defect reports. Same as</source>
          <target state="translated">1998年的ISO C++标准加上2003年的技术更正和一些额外的缺陷报告。同上。</target>
        </trans-unit>
        <trans-unit id="cfd06b261fe64d273c59c563a73adcb4a19fda6b" translate="yes" xml:space="preserve">
          <source>The 2011 ISO C++ standard plus amendments. The name &amp;lsquo;</source>
          <target state="translated">2011 ISO C ++标准以及修订版。名字 '</target>
        </trans-unit>
        <trans-unit id="e0824fd4223b0cb3aeed48d8b77f3a1b17acde06" translate="yes" xml:space="preserve">
          <source>The 2014 ISO C++ standard plus amendments. The name &amp;lsquo;</source>
          <target state="translated">2014 ISO C ++标准及其修订版。名字 '</target>
        </trans-unit>
        <trans-unit id="d75bfd00cf21586d8e597fcc9ed0b86883eb1dfa" translate="yes" xml:space="preserve">
          <source>The 2017 ISO C++ standard plus amendments. The name &amp;lsquo;</source>
          <target state="translated">2017 ISO C ++标准及其修订版。名字 '</target>
        </trans-unit>
        <trans-unit id="9e4484fd6590cd7f36b6fdf94168a5387d0e46c3" translate="yes" xml:space="preserve">
          <source>The 4.1, 4.2 and 4.3 series of GCC ignore the &lt;code&gt;packed&lt;/code&gt; attribute on bit-fields of type &lt;code&gt;char&lt;/code&gt;. This has been fixed in GCC 4.4 but the change can lead to differences in the structure layout. GCC informs you when the offset of such a field has changed in GCC 4.4. For example there is no longer a 4-bit padding between field &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; in this structure:</source>
          <target state="translated">GCC的4.1、4.2和4.3系列忽略了 &lt;code&gt;char&lt;/code&gt; 类型的位字段上的 &lt;code&gt;packed&lt;/code&gt; 属性。此问题已在GCC 4.4中修复，但更改可能导致结构布局不同。 GCC 4.4会在此类字段的偏移量发生更改时通知您。例如，在此结构中，字段 &lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;b&lt;/code&gt; 之间不再存在4位填充：</target>
        </trans-unit>
        <trans-unit id="8937102670278bcd3018a5a5c9e549b76146be93" translate="yes" xml:space="preserve">
          <source>The 4.1, 4.2 and 4.3 series of GCC ignore the &lt;code&gt;packed&lt;/code&gt; attribute on bit-fields of type &lt;code&gt;char&lt;/code&gt;. This was fixed in GCC 4.4 but the change can lead to differences in the structure layout. GCC informs you when the offset of such a field has changed in GCC 4.4. For example there is no longer a 4-bit padding between field &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; in this structure:</source>
          <target state="translated">GCC的4.1、4.2和4.3系列忽略了 &lt;code&gt;char&lt;/code&gt; 类型的位字段上的 &lt;code&gt;packed&lt;/code&gt; 属性。这在GCC 4.4中已修复，但更改可能导致结构布局上的差异。当GCC 4.4中的此类字段的偏移量发生更改时，GCC会通知您。例如，在此结构中，字段 &lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;b&lt;/code&gt; 之间不再存在4位填充：</target>
        </trans-unit>
        <trans-unit id="909967fe10a21a246a86aeb337d0842e478f43ac" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&quot;cc&quot;&lt;/code&gt; clobber indicates that the assembler code modifies the flags register. On some machines, GCC represents the condition codes as a specific hardware register; &lt;code&gt;&quot;cc&quot;&lt;/code&gt; serves to name this register. On other machines, condition code handling is different, and specifying &lt;code&gt;&quot;cc&quot;&lt;/code&gt; has no effect. But it is valid no matter what the target.</source>
          <target state="translated">的 &lt;code&gt;&quot;cc&quot;&lt;/code&gt; 撞表示汇编代码修改标志寄存器。在某些机器上，GCC将条件代码表示为特定的硬件寄存器。 &lt;code&gt;&quot;cc&quot;&lt;/code&gt; 用于命名该寄存器。在其他机器上，条件代码的处理有所不同，并且指定 &lt;code&gt;&quot;cc&quot;&lt;/code&gt; 无效。但这是有效的，无论目标是什么。</target>
        </trans-unit>
        <trans-unit id="f2534a799a74c45e086749f66cd7d314d0f206ea" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&quot;memory&quot;&lt;/code&gt; clobber tells the compiler that the assembly code performs memory reads or writes to items other than those listed in the input and output operands (for example, accessing the memory pointed to by one of the input parameters). To ensure memory contains correct values, GCC may need to flush specific register values to memory before executing the &lt;code&gt;asm&lt;/code&gt;. Further, the compiler does not assume that any values read from memory before an &lt;code&gt;asm&lt;/code&gt; remain unchanged after that &lt;code&gt;asm&lt;/code&gt;; it reloads them as needed. Using the &lt;code&gt;&quot;memory&quot;&lt;/code&gt; clobber effectively forms a read/write memory barrier for the compiler.</source>
          <target state="translated">的 &lt;code&gt;&quot;memory&quot;&lt;/code&gt; 撞告诉编译器，汇编代码执行存储器读或写操作比在输入和输出操作数列出的其他项目（例如，访问存储器由输入参数中的一个指向的）。为了确保内存中包含正确的值，GCC可能需要在执行 &lt;code&gt;asm&lt;/code&gt; 之前将特定的寄存器值刷新到内存中。此外，编译器不假定任何值从存储器中读取前一 &lt;code&gt;asm&lt;/code&gt; 保持该后保持不变 &lt;code&gt;asm&lt;/code&gt; ;它会根据需要重新加载它们。使用 &lt;code&gt;&quot;memory&quot;&lt;/code&gt; 缓冲区对编译器有效地形成了读/写内存屏障。</target>
        </trans-unit>
        <trans-unit id="287b2b66c9a7de19b9dd84de221d8d45c3b97aec" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;#pragma GCC target&lt;/code&gt; pragma is presently implemented for x86, ARM, AArch64, PowerPC, S/390, and Nios II targets only.</source>
          <target state="translated">所述 &lt;code&gt;#pragma GCC target&lt;/code&gt; 编译指示目前用于x86实现，ARM，AArch64，PowerPC上，S / 390和Nios II的目标只。</target>
        </trans-unit>
        <trans-unit id="3ccfce523413ade3933dc06559f7495350ab0dd4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;amp;&amp;amp;foo&lt;/code&gt; expressions for the same label might have different values if the containing function is inlined or cloned. If a program relies on them being always the same, &lt;code&gt;__attribute__((__noinline__,__noclone__))&lt;/code&gt; should be used to prevent inlining and cloning. If &lt;code&gt;&amp;amp;&amp;amp;foo&lt;/code&gt; is used in a static variable initializer, inlining and cloning is forbidden.</source>
          <target state="translated">如果包含函数被内联或克隆，则同一标签的 &lt;code&gt;&amp;amp;&amp;amp;foo&lt;/code&gt; 表达式可能具有不同的值。如果程序依赖于它们始终相同，则应使用 &lt;code&gt;__attribute__((__noinline__,__noclone__))&lt;/code&gt; 防止内联和克隆。如果在静态变量初始化器中使用 &lt;code&gt;&amp;amp;&amp;amp;foo&lt;/code&gt; ，则禁止内联和克隆。</target>
        </trans-unit>
        <trans-unit id="33e1502637058c6ab49c207cf28a3e3142aca9a4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;+load&lt;/code&gt; implementation in the GNU runtime guarantees you the following things:</source>
          <target state="translated">GNU运行时中的 &lt;code&gt;+load&lt;/code&gt; 实现可为您提供以下保证：</target>
        </trans-unit>
        <trans-unit id="91dd9757303b9f56bf3b6cb9119e24fe8a8727f5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;+load&lt;/code&gt; is a method that is not overridden by categories. If a class and a category of it both implement &lt;code&gt;+load&lt;/code&gt;, both methods are invoked. This allows some additional initializations to be performed in a category.</source>
          <target state="translated">的 &lt;code&gt;+load&lt;/code&gt; 是不按类别覆盖的方法。如果一个类及其类别都实现 &lt;code&gt;+load&lt;/code&gt; ，则将同时调用这两种方法。这允许在类别中执行一些其他初始化。</target>
        </trans-unit>
        <trans-unit id="772d2fc6151afb4fb1792207ec49f4a45839a16b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;+load&lt;/code&gt; method is also invoked when a bundle is dynamically loaded into your running program. This happens automatically without any intervening operation from you. When you write bundles and you need to write &lt;code&gt;+load&lt;/code&gt; you can safely create and send messages to objects whose classes already exist in the running program. The same restrictions as above apply to classes defined in bundle.</source>
          <target state="translated">的 &lt;code&gt;+load&lt;/code&gt; 当包被动态加载到正在运行的程序也被调用的方法。这会自动发生，而无需您进行任何干预。当您编写捆绑软件并且需要编写 &lt;code&gt;+load&lt;/code&gt; 时，可以安全地创建消息并将消息发送到其对象已在运行程序中存在的对象。与上述相同的限制适用于bundle中定义的类。</target>
        </trans-unit>
        <trans-unit id="dc6d2c3cb15d85f1417842f0fbdf998d14486ba5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;- (id) .cxx_construct&lt;/code&gt; and &lt;code&gt;- (void) .cxx_destruct&lt;/code&gt; methods thusly generated only operate on instance variables declared in the current Objective-C class, and not those inherited from superclasses. It is the responsibility of the Objective-C runtime to invoke all such methods in an object&amp;rsquo;s inheritance hierarchy. The &lt;code&gt;- (id) .cxx_construct&lt;/code&gt; methods are invoked by the runtime immediately after a new object instance is allocated; the &lt;code&gt;- (void) .cxx_destruct&lt;/code&gt; methods are invoked immediately before the runtime deallocates an object instance.</source>
          <target state="translated">这样生成的 &lt;code&gt;- (id) .cxx_construct&lt;/code&gt; 和 &lt;code&gt;- (void) .cxx_destruct&lt;/code&gt; 方法仅对在当前Objective-C类中声明的实例变量起作用，而对从超类继承的实例变量无效。在对象的继承层次结构中调用所有此类方法是Objective-C运行时的职责。在 &lt;code&gt;- (id) .cxx_construct&lt;/code&gt; 方法是通过一个新的对象实例分配后立即运行调用;的 &lt;code&gt;- (void) .cxx_destruct&lt;/code&gt; 方法立即运行时重新分配的对象实例之前调用。</target>
        </trans-unit>
        <trans-unit id="e7108ce8eed259a604477fdf012b421d600214df" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@finally&lt;/code&gt; clause, if present, will be executed upon exit from the immediately preceding &lt;code&gt;@try &amp;hellip; @catch&lt;/code&gt; section. This will happen regardless of whether any exceptions are thrown, caught or rethrown inside the &lt;code&gt;@try &amp;hellip; @catch&lt;/code&gt; section, analogously to the behavior of the &lt;code&gt;finally&lt;/code&gt; clause in Java.</source>
          <target state="translated">的 &lt;code&gt;@finally&lt;/code&gt; 子句，如果存在，将被退出时从前次执行 &lt;code&gt;@try &amp;hellip; @catch&lt;/code&gt; 部。无论是否在 &lt;code&gt;@try &amp;hellip; @catch&lt;/code&gt; 部分中引发，捕获或重新抛出任何异常，都将发生这种情况，类似于Java中 &lt;code&gt;finally&lt;/code&gt; 子句的行为。</target>
        </trans-unit>
        <trans-unit id="478f5300c419fd9f1ddbebddc4f1aa8b783e2f52" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@throw&lt;/code&gt; statement may appear anywhere in an Objective-C or Objective-C++ program; when used inside of a &lt;code&gt;@catch&lt;/code&gt; block, the &lt;code&gt;@throw&lt;/code&gt; may appear without an argument (as shown above), in which case the object caught by the &lt;code&gt;@catch&lt;/code&gt; will be rethrown.</source>
          <target state="translated">所述 &lt;code&gt;@throw&lt;/code&gt; 语句可能在一个Objective-C或Objective-C ++程序的任何地方出现; 当在 &lt;code&gt;@catch&lt;/code&gt; 块中使用时， &lt;code&gt;@throw&lt;/code&gt; 可能没有参数显示（如上所示），在这种情况下，由 &lt;code&gt;@catch&lt;/code&gt; 捕获的对象将被重新抛出。</target>
        </trans-unit>
        <trans-unit id="e66bfb70bc3d8564c8867b596c9daf7ef51239bc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;A&lt;/code&gt; register.</source>
          <target state="translated">在 &lt;code&gt;A&lt;/code&gt; 寄存器。</target>
        </trans-unit>
        <trans-unit id="7abbdb5d09af41601d4b6214589f91ad242a72c1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;AX&lt;/code&gt; register.</source>
          <target state="translated">在 &lt;code&gt;AX&lt;/code&gt; 寄存器。</target>
        </trans-unit>
        <trans-unit id="e8869263f41399bf1548d77cd0b06fdeab5b6090" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;B&lt;/code&gt; register.</source>
          <target state="translated">在 &lt;code&gt;B&lt;/code&gt; 寄存器。</target>
        </trans-unit>
        <trans-unit id="00b8662f23339aa40fc33f83b8bce9ef615fd089" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;BC&lt;/code&gt; register.</source>
          <target state="translated">在 &lt;code&gt;BC&lt;/code&gt; 寄存器。</target>
        </trans-unit>
        <trans-unit id="fafb503a49e3e2b7cffac8865ce407955e8ba5c4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;C&lt;/code&gt; register.</source>
          <target state="translated">该 &lt;code&gt;C&lt;/code&gt; 寄存器。</target>
        </trans-unit>
        <trans-unit id="c945285a14de09364b5e9d34fc7e6e4e9171bb55" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;D&lt;/code&gt; register.</source>
          <target state="translated">该 &lt;code&gt;D&lt;/code&gt; 寄存器。</target>
        </trans-unit>
        <trans-unit id="f334445b19ebbcdfd81f6a6a62d0c7c6a38f5f11" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;DE&lt;/code&gt; register.</source>
          <target state="translated">在 &lt;code&gt;DE&lt;/code&gt; 寄存器。</target>
        </trans-unit>
        <trans-unit id="84d9046824f2223a9b4a7038c1fdd6a7981413ef" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;E&lt;/code&gt; register.</source>
          <target state="translated">该 &lt;code&gt;E&lt;/code&gt; 寄存器。</target>
        </trans-unit>
        <trans-unit id="5f8a2094444afcd8a79b22ed65059e8f2a29f862" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;H&lt;/code&gt; register.</source>
          <target state="translated">该 &lt;code&gt;H&lt;/code&gt; 寄存器。</target>
        </trans-unit>
        <trans-unit id="2d1c2a880567113429c4b1cc1d7e5ee3f5c01334" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;HL&lt;/code&gt; register.</source>
          <target state="translated">该 &lt;code&gt;HL&lt;/code&gt; 寄存器。</target>
        </trans-unit>
        <trans-unit id="eb2a84b1e54ac92e546337e928dcc83ba5c11f03" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;L&lt;/code&gt; register.</source>
          <target state="translated">在 &lt;code&gt;L&lt;/code&gt; 寄存器。</target>
        </trans-unit>
        <trans-unit id="d88299e2896aeb367bb70fd25b9a5db675642c06" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;LC_CTYPE&lt;/code&gt; environment variable specifies character classification. GCC uses it to determine the character boundaries in a string; this is needed for some multibyte encodings that contain quote and escape characters that are otherwise interpreted as a string end or escape.</source>
          <target state="translated">该 &lt;code&gt;LC_CTYPE&lt;/code&gt; 环境变量指定的字符分类。GCC使用它来确定字符串中的字符边界；对于某些包含引号和转义符的多字节编码，这是必需的，否则它们会被解释为字符串结尾或转义。</target>
        </trans-unit>
        <trans-unit id="fd95cbfac63c17d00419fc1cfbc5f410bf724a2e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;LC_MESSAGES&lt;/code&gt; environment variable specifies the language to use in diagnostic messages.</source>
          <target state="translated">该 &lt;code&gt;LC_MESSAGES&lt;/code&gt; 环境变量指定的语言来诊断消息中使用。</target>
        </trans-unit>
        <trans-unit id="59d7ad50b2abf1611438129375bb15e01da761cf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;OS_main&lt;/code&gt; attribute can be used when there &lt;em&gt;is guarantee&lt;/em&gt; that interrupts are disabled at the time when the function is entered. This saves resources when the stack pointer has to be changed to set up a frame for local variables.</source>
          <target state="translated">该 &lt;code&gt;OS_main&lt;/code&gt; 当有属性可以用于&lt;em&gt;为保证&lt;/em&gt;中断处于当时禁止进入的功能时。当必须更改堆栈指针以为局部变量设置框架时，这可以节省资源。</target>
        </trans-unit>
        <trans-unit id="20f1e35a5360b1f14267221fb24f61e47178d10d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;OS_task&lt;/code&gt; attribute can be used when there is &lt;em&gt;no guarantee&lt;/em&gt; that interrupts are disabled at that time when the function is entered like for, e.g. task functions in a multi-threading operating system. In that case, changing the stack pointer register is guarded by save/clear/restore of the global interrupt enable flag.</source>
          <target state="translated">该 &lt;code&gt;OS_task&lt;/code&gt; 当有属性可用于&lt;em&gt;不保证&lt;/em&gt;该中断在多线程操作系统当时被禁用时，进入像功能，如任务功能。在这种情况下，通过全局中断允许标志的保存/清除/恢复来保护更改堆栈指针寄存器。</target>
        </trans-unit>
        <trans-unit id="973b834abbbf1594a420dbfab9c679298adbbcc2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;PSW&lt;/code&gt; register.</source>
          <target state="translated">该 &lt;code&gt;PSW&lt;/code&gt; 寄存器。</target>
        </trans-unit>
        <trans-unit id="03b6c46fda7548d67fe293013e4597e13b6cc3ae" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SP&lt;/code&gt; register.</source>
          <target state="translated">该 &lt;code&gt;SP&lt;/code&gt; 寄存器。</target>
        </trans-unit>
        <trans-unit id="77c3ff8f2bcfaf9382aab427535123ecf6e87b0c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;X&lt;/code&gt; register.</source>
          <target state="translated">在 &lt;code&gt;X&lt;/code&gt; 寄存器。</target>
        </trans-unit>
        <trans-unit id="f7925d7fc0ef32aa9ba1ce9e18d90f31a2b1041d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;_Float128&lt;/code&gt; type is supported on all systems where &lt;code&gt;__float128&lt;/code&gt; is supported or where &lt;code&gt;long double&lt;/code&gt; has the IEEE binary128 format. The &lt;code&gt;_Float64x&lt;/code&gt; type is supported on all systems where &lt;code&gt;__float128&lt;/code&gt; is supported. The &lt;code&gt;_Float32&lt;/code&gt; type is supported on all systems supporting IEEE binary32; the &lt;code&gt;_Float64&lt;/code&gt; and &lt;code&gt;_Float32x&lt;/code&gt; types are supported on all systems supporting IEEE binary64. The &lt;code&gt;_Float16&lt;/code&gt; type is supported on AArch64 systems by default, and on ARM systems when the IEEE format for 16-bit floating-point types is selected with</source>
          <target state="translated">在支持 &lt;code&gt;__float128&lt;/code&gt; 或 &lt;code&gt;long double&lt;/code&gt; 具有IEEE binary128格式的所有系统上都支持 &lt;code&gt;_Float128&lt;/code&gt; 类型。该 &lt;code&gt;_Float64x&lt;/code&gt; 类型支持所有系统 &lt;code&gt;__float128&lt;/code&gt; 支持。该 &lt;code&gt;_Float32&lt;/code&gt; 类型支持，支持IEEE binary32所有系统; 在 &lt;code&gt;_Float64&lt;/code&gt; 和 &lt;code&gt;_Float32x&lt;/code&gt; 类型的支持上，支持IEEE binary64所有系统。所述 &lt;code&gt;_Float16&lt;/code&gt; 型被支承在由缺省AArch64系统和ARM系统上时被选择用于16位浮点类型的IEEE格式与</target>
        </trans-unit>
        <trans-unit id="85103cf2482f16ae09dc93810b2ec0258970e808" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;_HTM_FIRST_USER_ABORT_CODE&lt;/code&gt; defined in &lt;code&gt;htmintrin.h&lt;/code&gt; specifies the first abort code which can be used for &lt;code&gt;__builtin_tabort&lt;/code&gt;. Values below this threshold are reserved for machine use.</source>
          <target state="translated">所述 &lt;code&gt;_HTM_FIRST_USER_ABORT_CODE&lt;/code&gt; 中定义 &lt;code&gt;htmintrin.h&lt;/code&gt; 指定了可用于在第一终止代码 &lt;code&gt;__builtin_tabort&lt;/code&gt; 。低于此阈值的值保留供机器使用。</target>
        </trans-unit>
        <trans-unit id="392542e4dc2c75d48ed6b1e9e4e666156b2ab35d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;__attribute__&lt;/code&gt; keyword is followed by an attribute specification enclosed in double parentheses.</source>
          <target state="translated">该 &lt;code&gt;__attribute__&lt;/code&gt; 关键字后面括在双括号的属性规范。</target>
        </trans-unit>
        <trans-unit id="0f8acb405a5cf121cc5773d2c4339fe65a77bcf5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;__builtin_alloca&lt;/code&gt; function must be called at block scope. The function allocates an object &lt;var&gt;size&lt;/var&gt; bytes large on the stack of the calling function. The object is aligned on the default stack alignment boundary for the target determined by the &lt;code&gt;__BIGGEST_ALIGNMENT__&lt;/code&gt; macro. The &lt;code&gt;__builtin_alloca&lt;/code&gt; function returns a pointer to the first byte of the allocated object. The lifetime of the allocated object ends just before the calling function returns to its caller. This is so even when &lt;code&gt;__builtin_alloca&lt;/code&gt; is called within a nested block.</source>
          <target state="translated">该 &lt;code&gt;__builtin_alloca&lt;/code&gt; 功能必须在块范围内被调用。该函数在调用函数的堆栈上分配较大的对象 &lt;var&gt;size&lt;/var&gt; 字节。对象在由 &lt;code&gt;__BIGGEST_ALIGNMENT__&lt;/code&gt; 宏确定的目标的默认堆栈对齐边界上对齐。所述 &lt;code&gt;__builtin_alloca&lt;/code&gt; 函数返回一个指向分配对象的第一个字节。分配的对象的生存期刚好在调用函数返回其调用者之前结束。即使在嵌套块中调用 &lt;code&gt;__builtin_alloca&lt;/code&gt; 时也是如此。</target>
        </trans-unit>
        <trans-unit id="699047c637b673c64e86fa3b74734bf759b728ff" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;__builtin_alloca_with_align&lt;/code&gt; function must be called at block scope. The function allocates an object &lt;var&gt;size&lt;/var&gt; bytes large on the stack of the calling function. The allocated object is aligned on the boundary specified by the argument &lt;var&gt;alignment&lt;/var&gt; whose unit is given in bits (not bytes). The &lt;var&gt;size&lt;/var&gt; argument must be positive and not exceed the stack size limit. The &lt;var&gt;alignment&lt;/var&gt; argument must be a constant integer expression that evaluates to a power of 2 greater than or equal to &lt;code&gt;CHAR_BIT&lt;/code&gt; and less than some unspecified maximum. Invocations with other values are rejected with an error indicating the valid bounds. The function returns a pointer to the first byte of the allocated object. The lifetime of the allocated object ends at the end of the block in which the function was called. The allocated storage is released no later than just before the calling function returns to its caller, but may be released at the end of the block in which the function was called.</source>
          <target state="translated">该 &lt;code&gt;__builtin_alloca_with_align&lt;/code&gt; 功能必须在块范围内被调用。该函数在调用函数的堆栈上分配较大的对象 &lt;var&gt;size&lt;/var&gt; 字节。分配的对象在参数 &lt;var&gt;alignment&lt;/var&gt; 指定的边界上对齐，参数对齐方式以位（而非字节）为单位。该 &lt;var&gt;size&lt;/var&gt; 参数必须是积极的，不超过堆栈大小限制。的 &lt;var&gt;alignment&lt;/var&gt; 参数必须是恒定整数表达式，其值大于2的功率或等于 &lt;code&gt;CHAR_BIT&lt;/code&gt; 并且小于一些未指定的最大值。使用其他值的调用将被拒绝，并显示一个指示有效范围的错误。该函数返回一个指向所分配对象的第一个字节的指针。分配对象的生存期在调用该函数的块的末尾结束。所分配的存储至少要在调用函数返回其调用者之前释放，但是可以在调用该函数的块的末尾释放。</target>
        </trans-unit>
        <trans-unit id="d14b3efa7fa2847225bae57a72e4dc716953742d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;__builtin_byte_in_range&lt;/code&gt; and &lt;code&gt;__builtin_byte_in_either_range&lt;/code&gt; require an environment supporting ISA 3.0 or later. For these two functions, the &lt;code&gt;range&lt;/code&gt; argument is encoded as 4 bytes, organized as &lt;code&gt;hi_1:lo_1:hi_2:lo_2&lt;/code&gt;. The &lt;code&gt;__builtin_byte_in_range&lt;/code&gt; function returns a non-zero value if and only if its &lt;code&gt;u&lt;/code&gt; argument is within the range bounded between &lt;code&gt;lo_2&lt;/code&gt; and &lt;code&gt;hi_2&lt;/code&gt; inclusive. The &lt;code&gt;__builtin_byte_in_either_range&lt;/code&gt; function returns non-zero if and only if its &lt;code&gt;u&lt;/code&gt; argument is within either the range bounded between &lt;code&gt;lo_1&lt;/code&gt; and &lt;code&gt;hi_1&lt;/code&gt; inclusive or the range bounded between &lt;code&gt;lo_2&lt;/code&gt; and &lt;code&gt;hi_2&lt;/code&gt; inclusive.</source>
          <target state="translated">该 &lt;code&gt;__builtin_byte_in_range&lt;/code&gt; 和 &lt;code&gt;__builtin_byte_in_either_range&lt;/code&gt; 需要配套ISA 3.0或更高版本的环境。对于这两个函数， &lt;code&gt;range&lt;/code&gt; 参数编码为4个字节，组织为 &lt;code&gt;hi_1:lo_1:hi_2:lo_2&lt;/code&gt; 。当且仅当 &lt;code&gt;__builtin_byte_in_range&lt;/code&gt; 函数的 &lt;code&gt;u&lt;/code&gt; 参数在 &lt;code&gt;lo_2&lt;/code&gt; 和 &lt;code&gt;hi_2&lt;/code&gt; (含）之间的范围内时，该函数才返回非零值。所述 &lt;code&gt;__builtin_byte_in_either_range&lt;/code&gt; 函数返回非零当且仅当其 &lt;code&gt;u&lt;/code&gt; 参数是任一之间界定的范围内 &lt;code&gt;lo_1&lt;/code&gt; 和 &lt;code&gt;hi_1&lt;/code&gt; 包含或包含 &lt;code&gt;lo_2&lt;/code&gt; 和 &lt;code&gt;hi_2&lt;/code&gt; (含）之间的范围。</target>
        </trans-unit>
        <trans-unit id="e9c90a92a294d6da36a67b6812f4d7f784a68c50" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;__builtin_byte_in_set&lt;/code&gt; function requires a 64-bit environment supporting ISA 3.0 or later. This function returns a non-zero value if and only if its &lt;code&gt;u&lt;/code&gt; argument exactly equals one of the eight bytes contained within its 64-bit &lt;code&gt;set&lt;/code&gt; argument.</source>
          <target state="translated">所述 &lt;code&gt;__builtin_byte_in_set&lt;/code&gt; 函数需要一个64位的环境中支持ISA 3.0或更高版本。当且仅当其 &lt;code&gt;u&lt;/code&gt; 参数恰好等于其64位 &lt;code&gt;set&lt;/code&gt; 参数中包含的八个字节之一时，此函数才返回非零值。</target>
        </trans-unit>
        <trans-unit id="fb729367b3d36e784ee118ae00a98821f8cbe5c9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;__builtin_cmpb&lt;/code&gt; function performs a byte-wise compare on the contents of its two arguments, returning the result of the byte-wise comparison as the returned value. For each byte comparison, the corresponding byte of the return value holds 0xff if the input bytes are equal and 0 if the input bytes are not equal. If either of the arguments to this built-in function is wider than 32 bits, the function call expands into the form that expects &lt;code&gt;unsigned long long int&lt;/code&gt; arguments which is only available on 64-bit targets.</source>
          <target state="translated">该 &lt;code&gt;__builtin_cmpb&lt;/code&gt; 功能进行逐字节比较在它的两个参数的内容，返回作为返回值的逐个字节比较的结果。对于每个字节比较，如果输入字节相等，则返回值的对应字节保持为0xff，如果输入字节不相等，则返回值保持为0。如果此内置函数的任何一个参数的宽度大于32位，则该函数调用将扩展为期望使用 &lt;code&gt;unsigned long long int&lt;/code&gt; 参数的形式，该形式仅在64位目标上可用。</target>
        </trans-unit>
        <trans-unit id="26cf6e5166e71a9dc3d72ae3910f453428861ff1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;__builtin_cpu_is&lt;/code&gt; function requires GLIBC 2.23 or newer which exports the hardware capability bits. GCC defines the macro &lt;code&gt;__BUILTIN_CPU_SUPPORTS__&lt;/code&gt; if the &lt;code&gt;__builtin_cpu_supports&lt;/code&gt; built-in function is fully supported.</source>
          <target state="translated">该 &lt;code&gt;__builtin_cpu_is&lt;/code&gt; 功能需要GLIBC 2.23或更高版本，其出口的硬件功能位。如果完全支持 &lt;code&gt;__builtin_cpu_supports&lt;/code&gt; 内置函数，则GCC定义宏 &lt;code&gt;__BUILTIN_CPU_SUPPORTS__&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="225ecb4eafc9e778fee170a226e93b379e52b096" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;__builtin_cpu_supports&lt;/code&gt; function requires GLIBC 2.23 or newer which exports the hardware capability bits. GCC defines the macro &lt;code&gt;__BUILTIN_CPU_SUPPORTS__&lt;/code&gt; if the &lt;code&gt;__builtin_cpu_supports&lt;/code&gt; built-in function is fully supported.</source>
          <target state="translated">该 &lt;code&gt;__builtin_cpu_supports&lt;/code&gt; 功能需要GLIBC 2.23或更高版本，其出口的硬件功能位。如果完全支持 &lt;code&gt;__builtin_cpu_supports&lt;/code&gt; 内置函数，则GCC定义宏 &lt;code&gt;__BUILTIN_CPU_SUPPORTS__&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9d549e750824586a0354c272406d5e4e5816a0ee" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;__builtin_darn&lt;/code&gt; and &lt;code&gt;__builtin_darn_raw&lt;/code&gt; functions require a 64-bit environment supporting ISA 3.0 or later. The &lt;code&gt;__builtin_darn&lt;/code&gt; function provides a 64-bit conditioned random number. The &lt;code&gt;__builtin_darn_raw&lt;/code&gt; function provides a 64-bit raw random number. The &lt;code&gt;__builtin_darn_32&lt;/code&gt; function provides a 32-bit conditioned random number.</source>
          <target state="translated">的 &lt;code&gt;__builtin_darn&lt;/code&gt; 和 &lt;code&gt;__builtin_darn_raw&lt;/code&gt; 功能需要一个64位的环境中支持ISA 3.0或更高版本。所述 &lt;code&gt;__builtin_darn&lt;/code&gt; 功能提供了一个64位的空调随机数。所述 &lt;code&gt;__builtin_darn_raw&lt;/code&gt; 功能提供了一个64位的原始随机数。所述 &lt;code&gt;__builtin_darn_32&lt;/code&gt; 功能提供了一个32位的空调随机数。</target>
        </trans-unit>
        <trans-unit id="fc4f02a6f5765f9e617ea8ee9a4170e4b962d403" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;__builtin_dfp_dtstsfi_eq&lt;/code&gt; function returns a non-zero value if and only if the number of signficant digits of its &lt;code&gt;value&lt;/code&gt; argument equals its &lt;code&gt;comparison&lt;/code&gt; argument. The &lt;code&gt;__builtin_dfp_dtstsfi_eq_dd&lt;/code&gt; and &lt;code&gt;__builtin_dfp_dtstsfi_eq_td&lt;/code&gt; functions behave similarly, but require that the type of the &lt;code&gt;value&lt;/code&gt; argument be &lt;code&gt;__Decimal64&lt;/code&gt; and &lt;code&gt;__Decimal128&lt;/code&gt; respectively.</source>
          <target state="translated">当且仅当 &lt;code&gt;__builtin_dfp_dtstsfi_eq&lt;/code&gt; 函数的 &lt;code&gt;value&lt;/code&gt; 参数的有效位数等于其 &lt;code&gt;comparison&lt;/code&gt; 参数时，该函数才返回非零值。的 &lt;code&gt;__builtin_dfp_dtstsfi_eq_dd&lt;/code&gt; 和 &lt;code&gt;__builtin_dfp_dtstsfi_eq_td&lt;/code&gt; 功能行为相似，但要求该类型 &lt;code&gt;value&lt;/code&gt; 参数是 &lt;code&gt;__Decimal64&lt;/code&gt; 和 &lt;code&gt;__Decimal128&lt;/code&gt; 分别。</target>
        </trans-unit>
        <trans-unit id="57591fb5134dd8d315ee0a2d1522ee30d9827c9f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;__builtin_dfp_dtstsfi_gt&lt;/code&gt; function returns a non-zero value if and only if the number of signficant digits of its &lt;code&gt;value&lt;/code&gt; argument is greater than its &lt;code&gt;comparison&lt;/code&gt; argument. The &lt;code&gt;__builtin_dfp_dtstsfi_gt_dd&lt;/code&gt; and &lt;code&gt;__builtin_dfp_dtstsfi_gt_td&lt;/code&gt; functions behave similarly, but require that the type of the &lt;code&gt;value&lt;/code&gt; argument be &lt;code&gt;__Decimal64&lt;/code&gt; and &lt;code&gt;__Decimal128&lt;/code&gt; respectively.</source>
          <target state="translated">当且仅当 &lt;code&gt;__builtin_dfp_dtstsfi_gt&lt;/code&gt; 函数的 &lt;code&gt;value&lt;/code&gt; 参数的有效位数大于其 &lt;code&gt;comparison&lt;/code&gt; 参数时，该函数才返回非零值。的 &lt;code&gt;__builtin_dfp_dtstsfi_gt_dd&lt;/code&gt; 和 &lt;code&gt;__builtin_dfp_dtstsfi_gt_td&lt;/code&gt; 功能行为相似，但要求该类型 &lt;code&gt;value&lt;/code&gt; 参数是 &lt;code&gt;__Decimal64&lt;/code&gt; 和 &lt;code&gt;__Decimal128&lt;/code&gt; 分别。</target>
        </trans-unit>
        <trans-unit id="b01dbf5e64c194eb164595e23ee9b740573ded8e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;__builtin_dfp_dtstsfi_lt&lt;/code&gt; function returns a non-zero value if and only if the number of signficant digits of its &lt;code&gt;value&lt;/code&gt; argument is less than its &lt;code&gt;comparison&lt;/code&gt; argument. The &lt;code&gt;__builtin_dfp_dtstsfi_lt_dd&lt;/code&gt; and &lt;code&gt;__builtin_dfp_dtstsfi_lt_td&lt;/code&gt; functions behave similarly, but require that the type of the &lt;code&gt;value&lt;/code&gt; argument be &lt;code&gt;__Decimal64&lt;/code&gt; and &lt;code&gt;__Decimal128&lt;/code&gt; respectively.</source>
          <target state="translated">当且仅当 &lt;code&gt;__builtin_dfp_dtstsfi_lt&lt;/code&gt; 函数的 &lt;code&gt;value&lt;/code&gt; 参数的有效位数小于其 &lt;code&gt;comparison&lt;/code&gt; 参数时，该函数才返回非零值。的 &lt;code&gt;__builtin_dfp_dtstsfi_lt_dd&lt;/code&gt; 和 &lt;code&gt;__builtin_dfp_dtstsfi_lt_td&lt;/code&gt; 功能行为相似，但要求该类型 &lt;code&gt;value&lt;/code&gt; 参数是 &lt;code&gt;__Decimal64&lt;/code&gt; 和 &lt;code&gt;__Decimal128&lt;/code&gt; 分别。</target>
        </trans-unit>
        <trans-unit id="b4420e5d860b7c4bb7ba6d7a8d1a6213bfe7043a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;__builtin_dfp_dtstsfi_ov&lt;/code&gt; function returns a non-zero value if and only if its &lt;code&gt;value&lt;/code&gt; argument has an undefined number of significant digits, such as when &lt;code&gt;value&lt;/code&gt; is an encoding of &lt;code&gt;NaN&lt;/code&gt;. The &lt;code&gt;__builtin_dfp_dtstsfi_ov_dd&lt;/code&gt; and &lt;code&gt;__builtin_dfp_dtstsfi_ov_td&lt;/code&gt; functions behave similarly, but require that the type of the &lt;code&gt;value&lt;/code&gt; argument be &lt;code&gt;__Decimal64&lt;/code&gt; and &lt;code&gt;__Decimal128&lt;/code&gt; respectively.</source>
          <target state="translated">且仅当其 &lt;code&gt;__builtin_dfp_dtstsfi_ov&lt;/code&gt; 函数_ 返回且函数值非零，且仅当其 &lt;code&gt;value&lt;/code&gt; 参数具有未定义的有效数字位数时（例如 &lt;code&gt;value&lt;/code&gt; 是 &lt;code&gt;NaN&lt;/code&gt; 的编码时）才返回非零值。的 &lt;code&gt;__builtin_dfp_dtstsfi_ov_dd&lt;/code&gt; 和 &lt;code&gt;__builtin_dfp_dtstsfi_ov_td&lt;/code&gt; 功能行为相似，但要求该类型 &lt;code&gt;value&lt;/code&gt; 参数是 &lt;code&gt;__Decimal64&lt;/code&gt; 和 &lt;code&gt;__Decimal128&lt;/code&gt; 分别。</target>
        </trans-unit>
        <trans-unit id="a0bfeb225a5faf6d6577d095e4bb9f94249f0a3d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;__builtin_has_attribute&lt;/code&gt; function evaluates to an integer constant expression equal to &lt;code&gt;true&lt;/code&gt; if the symbol or type referenced by the &lt;var&gt;type-or-expression&lt;/var&gt; argument has been declared with the &lt;var&gt;attribute&lt;/var&gt; referenced by the second argument. For an &lt;var&gt;type-or-expression&lt;/var&gt; argument that does not reference a symbol, since attributes do not apply to expressions the built-in consider the type of the argument. Neither argument is evaluated. The &lt;var&gt;type-or-expression&lt;/var&gt; argument is subject to the same restrictions as the argument to &lt;code&gt;typeof&lt;/code&gt; (see &lt;a href=&quot;typeof#Typeof&quot;&gt;Typeof&lt;/a&gt;). The &lt;var&gt;attribute&lt;/var&gt; argument is an attribute name optionally followed by a comma-separated list of arguments enclosed in parentheses. Both forms of attribute names&amp;mdash;with and without double leading and trailing underscores&amp;mdash;are recognized. See &lt;a href=&quot;attribute-syntax#Attribute-Syntax&quot;&gt;Attribute Syntax&lt;/a&gt;, for details. When no attribute arguments are specified for an attribute that expects one or more arguments the function returns &lt;code&gt;true&lt;/code&gt; if &lt;var&gt;type-or-expression&lt;/var&gt; has been declared with the attribute regardless of the attribute argument values. Arguments provided for an attribute that expects some are validated and matched up to the provided number. The function returns &lt;code&gt;true&lt;/code&gt; if all provided arguments match. For example, the first call to the function below evaluates to &lt;code&gt;true&lt;/code&gt; because &lt;code&gt;x&lt;/code&gt; is declared with the &lt;code&gt;aligned&lt;/code&gt; attribute but the second call evaluates to &lt;code&gt;false&lt;/code&gt; because &lt;code&gt;x&lt;/code&gt; is declared &lt;code&gt;aligned (8)&lt;/code&gt; and not &lt;code&gt;aligned (4)&lt;/code&gt;.</source>
          <target state="translated">所述 &lt;code&gt;__builtin_has_attribute&lt;/code&gt; 函数的计算结果为一个整数常量表达式等于 &lt;code&gt;true&lt;/code&gt; 如果由所引用的符号或类型 &lt;var&gt;type-or-expression&lt;/var&gt; 参数已被宣布与 &lt;var&gt;attribute&lt;/var&gt; 由第二个参数被引用。对于不引用符号的 &lt;var&gt;type-or-expression&lt;/var&gt; 变量，由于属性不适用于内置表达式，因此内置函数会考虑自变量的类型。这两个参数均未评估。的 &lt;var&gt;type-or-expression&lt;/var&gt; 参数是受到相同的限制作为参数 &lt;code&gt;typeof&lt;/code&gt; （参见&lt;a href=&quot;typeof#Typeof&quot;&gt;typeof运算&lt;/a&gt;）。该 &lt;var&gt;attribute&lt;/var&gt; 参数是一个属性名称，可以选择在其后跟随用括号括起来的逗号分隔的参数列表。可以识别两种形式的属性名称-带和不带双下划线和下划线。有关详细信息，请参见&lt;a href=&quot;attribute-syntax#Attribute-Syntax&quot;&gt;属性语法&lt;/a&gt;。当没有属性参数都为一个期望的一个或多个参数的函数返回一个属性指定的 &lt;code&gt;true&lt;/code&gt; 如果 &lt;var&gt;type-or-expression&lt;/var&gt; 已经被宣布与属性不论属性的参数值。为期望某些属性的参数提供的参数经过验证，并与提供的数字匹配。如果所有提供的参数都匹配，则该函数返回 &lt;code&gt;true&lt;/code&gt; 。例如，第一次调用下面的函数的结果为 &lt;code&gt;true&lt;/code&gt; 因为 &lt;code&gt;x&lt;/code&gt; 是使用 &lt;code&gt;aligned&lt;/code&gt; 属性声明的，但是第二次调用的结果为 &lt;code&gt;false&lt;/code&gt; ,因为 &lt;code&gt;x&lt;/code&gt; 是声明为 &lt;code&gt;aligned (8)&lt;/code&gt; 而不是 &lt;code&gt;aligned (4)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5cbfc7ec73fa262c76440a5134fc2d0584d6a4cf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;__builtin_is_constant_evaluated&lt;/code&gt; function is available only in C++. The built-in is intended to be used by implementations of the &lt;code&gt;std::is_constant_evaluated&lt;/code&gt; C++ function. Programs should make use of the latter function rather than invoking the built-in directly.</source>
          <target state="translated">该 &lt;code&gt;__builtin_is_constant_evaluated&lt;/code&gt; 功能只在C ++是可用的。内置供 &lt;code&gt;std::is_constant_evaluated&lt;/code&gt; C ++函数的实现使用。程序应利用后者的功能，而不是直接调用内置函数。</target>
        </trans-unit>
        <trans-unit id="8c4494406f2455746a4c649b18a2c01e01f2fd9b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;__builtin_mffsl&lt;/code&gt; uses the ISA 3.0 &lt;code&gt;mffsl&lt;/code&gt; instruction to read the FPSCR. The instruction is a lower latency version of the &lt;code&gt;mffs&lt;/code&gt; instruction. If the &lt;code&gt;mffsl&lt;/code&gt; instruction is not available, then the builtin uses the older &lt;code&gt;mffs&lt;/code&gt; instruction to read the FPSCR.</source>
          <target state="translated">该 &lt;code&gt;__builtin_mffsl&lt;/code&gt; 使用ISA 3.0 &lt;code&gt;mffsl&lt;/code&gt; 指令读FPSCR。该指令是 &lt;code&gt;mffs&lt;/code&gt; 指令的低延迟版本。如果 &lt;code&gt;mffsl&lt;/code&gt; 指令不可用，则内置 &lt;code&gt;mffs&lt;/code&gt; 将使用较旧的mffs指令读取FPSCR。</target>
        </trans-unit>
        <trans-unit id="1c6f10224f071b484a2f23cb973dde539bd04b1f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;__builtin_pack_ibm128&lt;/code&gt; function takes two &lt;code&gt;double&lt;/code&gt; arguments and returns a &lt;code&gt;__ibm128&lt;/code&gt; value that combines the two arguments.</source>
          <target state="translated">该 &lt;code&gt;__builtin_pack_ibm128&lt;/code&gt; 函数有两个 &lt;code&gt;double&lt;/code&gt; 参数，并返回 &lt;code&gt;__ibm128&lt;/code&gt; 值，它结合了两个参数。</target>
        </trans-unit>
        <trans-unit id="ce45c9f46fdb649818045c7651274a51c7c9b814" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;__builtin_pack_longdouble&lt;/code&gt; function takes two &lt;code&gt;double&lt;/code&gt; arguments and returns a &lt;code&gt;long double&lt;/code&gt; value that combines the two arguments. The &lt;code&gt;__builtin_pack_longdouble&lt;/code&gt; function is only available if &lt;code&gt;long double&lt;/code&gt; uses the IBM extended double representation.</source>
          <target state="translated">该 &lt;code&gt;__builtin_pack_longdouble&lt;/code&gt; 函数有两个 &lt;code&gt;double&lt;/code&gt; 参数，并返回 &lt;code&gt;long double&lt;/code&gt; 的值，它结合了两个参数。仅当 &lt;code&gt;long double&lt;/code&gt; 使用IBM扩展double表示形式时， &lt;code&gt;__builtin_pack_longdouble&lt;/code&gt; 函数才可用。</target>
        </trans-unit>
        <trans-unit id="8465d06a8e70b59990aa3c2108eef59db7b2906e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;__builtin_ppc_get_timebase&lt;/code&gt; and &lt;code&gt;__builtin_ppc_mftb&lt;/code&gt; functions generate instructions to read the Time Base Register. The &lt;code&gt;__builtin_ppc_get_timebase&lt;/code&gt; function may generate multiple instructions and always returns the 64 bits of the Time Base Register. The &lt;code&gt;__builtin_ppc_mftb&lt;/code&gt; function always generates one instruction and returns the Time Base Register value as an unsigned long, throwing away the most significant word on 32-bit environments. The &lt;code&gt;__builtin_mffs&lt;/code&gt; return the value of the FPSCR register. Note, ISA 3.0 supports the &lt;code&gt;__builtin_mffsl()&lt;/code&gt; which permits software to read the control and non-sticky status bits in the FSPCR without the higher latency associated with accessing the sticky status bits. The &lt;code&gt;__builtin_mtfsb0&lt;/code&gt; and &lt;code&gt;__builtin_mtfsb1&lt;/code&gt; take the bit to change as an argument. The valid bit range is between 0 and 31. The builtins map to the &lt;code&gt;mtfsb0&lt;/code&gt; and &lt;code&gt;mtfsb1&lt;/code&gt; instructions which take the argument and add 32. Hence these instructions only modify the FPSCR[32:63] bits by changing the specified bit to a zero or one respectively. The &lt;code&gt;__builtin_set_fpscr_rn&lt;/code&gt; builtin allows changing both of the floating point rounding mode bits. The argument is a 2-bit value. The argument can either be a &lt;code&gt;const int&lt;/code&gt; or stored in a variable. The builtin uses the ISA 3.0 instruction &lt;code&gt;mffscrn&lt;/code&gt; if available, otherwise it reads the FPSCR, masks the current rounding mode bits out and OR&amp;rsquo;s in the new value.</source>
          <target state="translated">该 &lt;code&gt;__builtin_ppc_get_timebase&lt;/code&gt; 和 &lt;code&gt;__builtin_ppc_mftb&lt;/code&gt; 函数生成的指令读取时基寄存器。该 &lt;code&gt;__builtin_ppc_get_timebase&lt;/code&gt; 功能可以产生多个指令，并始终返回时基寄存器的64位。该 &lt;code&gt;__builtin_ppc_mftb&lt;/code&gt; 长函数总是产生一个指令后返回时间基准寄存器值作为一个无符号，在32位环境中丢掉最显著字。该 &lt;code&gt;__builtin_mffs&lt;/code&gt; 返回FPSCR寄存器的值。注意，ISA 3.0支持 &lt;code&gt;__builtin_mffsl()&lt;/code&gt; 这样一来，软件就可以读取FSPCR中的控制状态位和非粘性状态位，而不会因访问粘性状态位带来更高的延迟。该 &lt;code&gt;__builtin_mtfsb0&lt;/code&gt; 和 &lt;code&gt;__builtin_mtfsb1&lt;/code&gt; 走位变化作为参数。有效位范围在0到31之间。内建 &lt;code&gt;mtfsb0&lt;/code&gt; 映射到mtfsb0和 &lt;code&gt;mtfsb1&lt;/code&gt; 指令，这些指令采用参数并加32。因此，这些指令仅通过将指定的位更改为零或一来修改FPSCR [32:63]位。分别。内置的 &lt;code&gt;__builtin_set_fpscr_rn&lt;/code&gt; 允许更改两个浮点舍入模式位。参数为2位值。参数可以是 &lt;code&gt;const int&lt;/code&gt; 或存储在变量中。内置命令使用ISA 3.0指令 &lt;code&gt;mffscrn&lt;/code&gt; (如果可用），否则它将读取FPSCR，将当前舍入模式位屏蔽掉，并将OR 替换为新值。</target>
        </trans-unit>
        <trans-unit id="f74488ec411590dcc75315f19183a037dc14b9ec" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;__builtin_ppc_get_timebase&lt;/code&gt; and &lt;code&gt;__builtin_ppc_mftb&lt;/code&gt; functions generate instructions to read the Time Base Register. The &lt;code&gt;__builtin_ppc_get_timebase&lt;/code&gt; function may generate multiple instructions and always returns the 64 bits of the Time Base Register. The &lt;code&gt;__builtin_ppc_mftb&lt;/code&gt; function always generates one instruction and returns the Time Base Register value as an unsigned long, throwing away the most significant word on 32-bit environments. The &lt;code&gt;__builtin_mffs&lt;/code&gt; return the value of the FPSCR register. Note, ISA 3.0 supports the &lt;code&gt;__builtin_mffsl()&lt;/code&gt; which permits software to read the control and non-sticky status bits in the FSPCR without the higher latency associated with accessing the sticky status bits. The &lt;code&gt;__builtin_mtfsf&lt;/code&gt; takes a constant 8-bit integer field mask and a double precision floating point argument and generates the &lt;code&gt;mtfsf&lt;/code&gt; (extended mnemonic) instruction to write new values to selected fields of the FPSCR. The &lt;code&gt;__builtin_mtfsb0&lt;/code&gt; and &lt;code&gt;__builtin_mtfsb1&lt;/code&gt; take the bit to change as an argument. The valid bit range is between 0 and 31. The builtins map to the &lt;code&gt;mtfsb0&lt;/code&gt; and &lt;code&gt;mtfsb1&lt;/code&gt; instructions which take the argument and add 32. Hence these instructions only modify the FPSCR[32:63] bits by changing the specified bit to a zero or one respectively. The &lt;code&gt;__builtin_set_fpscr_rn&lt;/code&gt; builtin allows changing both of the floating point rounding mode bits. The argument is a 2-bit value. The argument can either be a &lt;code&gt;const int&lt;/code&gt; or stored in a variable. The builtin uses the ISA 3.0 instruction &lt;code&gt;mffscrn&lt;/code&gt; if available, otherwise it reads the FPSCR, masks the current rounding mode bits out and OR&amp;rsquo;s in the new value.</source>
          <target state="translated">该 &lt;code&gt;__builtin_ppc_get_timebase&lt;/code&gt; 和 &lt;code&gt;__builtin_ppc_mftb&lt;/code&gt; 函数生成的指令读取时基寄存器。该 &lt;code&gt;__builtin_ppc_get_timebase&lt;/code&gt; 功能可以产生多个指令，并始终返回时基寄存器的64位。该 &lt;code&gt;__builtin_ppc_mftb&lt;/code&gt; 长函数总是产生一个指令后返回时间基准寄存器值作为一个无符号，在32位环境中丢掉最显著字。该 &lt;code&gt;__builtin_mffs&lt;/code&gt; 返回FPSCR寄存器的值。注意，ISA 3.0支持 &lt;code&gt;__builtin_mffsl()&lt;/code&gt; 这样一来，软件就可以读取FSPCR中的控制状态位和非粘性状态位，而不会因访问粘性状态位而导致更高的延迟。所述 &lt;code&gt;__builtin_mtfsf&lt;/code&gt; 需要一个常数8位整数场掩模和一个双精度浮点参数，并生成 &lt;code&gt;mtfsf&lt;/code&gt; （扩展助记符）指令写入新值FPSCR的选定字段。该 &lt;code&gt;__builtin_mtfsb0&lt;/code&gt; 和 &lt;code&gt;__builtin_mtfsb1&lt;/code&gt; 走位变化作为参数。有效位范围在0到31之间。内建 &lt;code&gt;mtfsb0&lt;/code&gt; 映射到mtfsb0和 &lt;code&gt;mtfsb1&lt;/code&gt; 这些指令采用参数并加32。因此，这些指令仅通过将指定的位分别更改为零或一来修改FPSCR [32:63]位。内置的 &lt;code&gt;__builtin_set_fpscr_rn&lt;/code&gt; 允许更改两个浮点舍入模式位。参数为2位值。参数可以是 &lt;code&gt;const int&lt;/code&gt; 或存储在变量中。内置命令使用ISA 3.0指令 &lt;code&gt;mffscrn&lt;/code&gt; (如果可用），否则它将读取FPSCR，屏蔽当前舍入模式位，并将新值&amp;ldquo;或&amp;rdquo;掩盖。</target>
        </trans-unit>
        <trans-unit id="198788e1a597fcc05831a074890ff7147c3e1998" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;__builtin_recipdiv&lt;/code&gt;, and &lt;code&gt;__builtin_recipdivf&lt;/code&gt; functions generate multiple instructions to implement division using the reciprocal estimate instructions.</source>
          <target state="translated">的 &lt;code&gt;__builtin_recipdiv&lt;/code&gt; ，和 &lt;code&gt;__builtin_recipdivf&lt;/code&gt; 函数生成多个指令以实现除法使用倒数估计的指令。</target>
        </trans-unit>
        <trans-unit id="eca84e06c376750982f7cbde8f6e8edd81f796b7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;__builtin_unpack_ibm128&lt;/code&gt; function takes a &lt;code&gt;__ibm128&lt;/code&gt; argument and a compile time constant of 0 or 1. If the constant is 0, the first &lt;code&gt;double&lt;/code&gt; within the &lt;code&gt;__ibm128&lt;/code&gt; is returned, otherwise the second &lt;code&gt;double&lt;/code&gt; is returned.</source>
          <target state="translated">所述 &lt;code&gt;__builtin_unpack_ibm128&lt;/code&gt; 函数采用一个 &lt;code&gt;__ibm128&lt;/code&gt; 参数，并如果该常数为0时，所述第一的0或1。一个编译时间常数 &lt;code&gt;double&lt;/code&gt; 所述内 &lt;code&gt;__ibm128&lt;/code&gt; 被返回，否则该第二 &lt;code&gt;double&lt;/code&gt; 被返回。</target>
        </trans-unit>
        <trans-unit id="48855b25f6a50b8b8736a064f19a8b37e730a064" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;__builtin_unpack_longdouble&lt;/code&gt; function takes a &lt;code&gt;long double&lt;/code&gt; argument and a compile time constant of 0 or 1. If the constant is 0, the first &lt;code&gt;double&lt;/code&gt; within the &lt;code&gt;long double&lt;/code&gt; is returned, otherwise the second &lt;code&gt;double&lt;/code&gt; is returned. The &lt;code&gt;__builtin_unpack_longdouble&lt;/code&gt; function is only available if &lt;code&gt;long double&lt;/code&gt; uses the IBM extended double representation.</source>
          <target state="translated">所述 &lt;code&gt;__builtin_unpack_longdouble&lt;/code&gt; 函数需要一个 &lt;code&gt;long double&lt;/code&gt; 参数和0或1。如果常数是0编译时间常数，所述第一 &lt;code&gt;double&lt;/code&gt; 内的 &lt;code&gt;long double&lt;/code&gt; 返回，否则该第二 &lt;code&gt;double&lt;/code&gt; 被返回。仅当 &lt;code&gt;long double&lt;/code&gt; 使用IBM扩展double表示形式时， &lt;code&gt;__builtin_unpack_longdouble&lt;/code&gt; 函数才可用。</target>
        </trans-unit>
        <trans-unit id="cf7f4f10325e1d8819fa9c82ff898e127032c07d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;__flash&lt;/code&gt; qualifier locates data in the &lt;code&gt;.progmem.data&lt;/code&gt; section. Data is read using the &lt;code&gt;LPM&lt;/code&gt; instruction. Pointers to this address space are 16 bits wide.</source>
          <target state="translated">该 &lt;code&gt;__flash&lt;/code&gt; 预选赛中的定位数据 &lt;code&gt;.progmem.data&lt;/code&gt; 部分。使用 &lt;code&gt;LPM&lt;/code&gt; 指令读取数据。指向该地址空间的指针为16位宽。</target>
        </trans-unit>
        <trans-unit id="097ea3d6342e0a23a9235845e85db17d4022ac6d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;__fp16&lt;/code&gt; type may only be used as an argument to intrinsics defined in &lt;code&gt;&amp;lt;arm_fp16.h&amp;gt;&lt;/code&gt;, or as a storage format. For purposes of arithmetic and other operations, &lt;code&gt;__fp16&lt;/code&gt; values in C or C++ expressions are automatically promoted to &lt;code&gt;float&lt;/code&gt;.</source>
          <target state="translated">所述 &lt;code&gt;__fp16&lt;/code&gt; 类型可以仅被用作一个参数所限定内在 &lt;code&gt;&amp;lt;arm_fp16.h&amp;gt;&lt;/code&gt; ，或作为存储格式。为了进行算术运算和其他运算，C或C ++表达式中的 &lt;code&gt;__fp16&lt;/code&gt; 值会自动提升为 &lt;code&gt;float&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ec03917f805a8e50fbb98586530e665bfe69da73" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;__thread&lt;/code&gt; specifier can be applied only to the names of objects and to anonymous unions.</source>
          <target state="translated">该 &lt;code&gt;__thread&lt;/code&gt; 说明符只能应用到对象的名称和匿名联合。</target>
        </trans-unit>
        <trans-unit id="f3af60ab1131c66623c0fb9cd375a6e888cff899" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;__thread&lt;/code&gt; specifier may be applied to any global, file-scoped static, function-scoped static, or static data member of a class. It may not be applied to block-scoped automatic or non-static data member.</source>
          <target state="translated">所述 &lt;code&gt;__thread&lt;/code&gt; 说明符可以被应用到任何全局，文件范围的静态的，功能范围的静态，或一个类的静态数据成员。它可能不适用于块作用域自动或非静态数据成员。</target>
        </trans-unit>
        <trans-unit id="d8177fe879ae4fe2cff503c3513d84606c176b85" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;__thread&lt;/code&gt; specifier may be used alone, with the &lt;code&gt;extern&lt;/code&gt; or &lt;code&gt;static&lt;/code&gt; specifiers, but with no other storage class specifier. When used with &lt;code&gt;extern&lt;/code&gt; or &lt;code&gt;static&lt;/code&gt;, &lt;code&gt;__thread&lt;/code&gt; must appear immediately after the other storage class specifier.</source>
          <target state="translated">该 &lt;code&gt;__thread&lt;/code&gt; 说明符可单独使用，与 &lt;code&gt;extern&lt;/code&gt; 或 &lt;code&gt;static&lt;/code&gt; 符，但没有其他存储类说明。与 &lt;code&gt;extern&lt;/code&gt; 或 &lt;code&gt;static&lt;/code&gt; 一起使用时， &lt;code&gt;__thread&lt;/code&gt; 必须立即出现在其他存储类说明符之后。</target>
        </trans-unit>
        <trans-unit id="63dae9f24b29dc710773ce4dac88b4e87c3c52d2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;__thread&lt;/code&gt; specifier shall be used only with variables.</source>
          <target state="translated">该 &lt;code&gt;__thread&lt;/code&gt; 说明符只能使用变量使用。</target>
        </trans-unit>
        <trans-unit id="adf603edfc142efac4a9a3b77d51d44293820a8f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;__trampolines_start&lt;/code&gt; symbol is defined in the linker script.</source>
          <target state="translated">&lt;code&gt;__trampolines_start&lt;/code&gt; 符号在链接描述文件中定义。</target>
        </trans-unit>
        <trans-unit id="375e8541e5237f24ef902439af8b3c21cd835020" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;d&lt;/code&gt; registers. This class is used for instructions that return double word results in the &lt;code&gt;ax:dx&lt;/code&gt; register pair. Single word values will be allocated either in &lt;code&gt;ax&lt;/code&gt; or &lt;code&gt;dx&lt;/code&gt;. For example on i386 the following implements &lt;code&gt;rdtsc&lt;/code&gt;:</source>
          <target state="translated">的 &lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;d&lt;/code&gt; 的寄存器。此类用于在 &lt;code&gt;ax:dx&lt;/code&gt; 寄存器对中返回双字结果的指令。单个单词值将以 &lt;code&gt;ax&lt;/code&gt; 或 &lt;code&gt;dx&lt;/code&gt; 分配。例如，在i386上，以下实现 &lt;code&gt;rdtsc&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="a0d40f91f92592e29ec24cddc648e15fc94fdbdb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;a&lt;/code&gt; register.</source>
          <target state="translated">在 &lt;code&gt;a&lt;/code&gt; 寄存器。</target>
        </trans-unit>
        <trans-unit id="bf9b97f6ebb578cc8aa854722849a8e5b4602c9c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;abi_tag&lt;/code&gt; attribute can be applied to a function, variable, or class declaration. It modifies the mangled name of the entity to incorporate the tag name, in order to distinguish the function or class from an earlier version with a different ABI; perhaps the class has changed size, or the function has a different return type that is not encoded in the mangled name.</source>
          <target state="translated">所述 &lt;code&gt;abi_tag&lt;/code&gt; 属性可以被应用于一个函数，变量，或类声明。它修改实体的变形名称以合并标签名称，以便将功能或类与具有不同ABI的早期版本区分开；可能是该类的大小已更改，或者该函数具有其他返回类型，该返回类型未编码在错误的名称中。</target>
        </trans-unit>
        <trans-unit id="7fe3aef8751a598cb1fd1f579f51dc2e77fc03d5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;access&lt;/code&gt; attribute enables the detection of invalid or unsafe accesses by functions to which they apply or their callers, as well as write-only accesses to objects that are never read from. Such accesses may be diagnosed by warnings such as</source>
          <target state="translated">通过 &lt;code&gt;access&lt;/code&gt; 属性可以使用它们所应用的函数或其调用者来检测无效或不安全的访问，以及对永不读取的对象的仅写访问。此类访问可通过警告（例如）来诊断</target>
        </trans-unit>
        <trans-unit id="3485b263c83290ae97682123760b0adc0b05426c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;access&lt;/code&gt; attribute specifies that a function to whose by-reference arguments the attribute applies accesses the referenced object according to &lt;var&gt;access-mode&lt;/var&gt;. The &lt;var&gt;access-mode&lt;/var&gt; argument is required and must be one of three names: &lt;code&gt;read_only&lt;/code&gt;, &lt;code&gt;read_write&lt;/code&gt;, or &lt;code&gt;write_only&lt;/code&gt;. The remaining two are positional arguments.</source>
          <target state="translated">的 &lt;code&gt;access&lt;/code&gt; 属性指定到通过引用其自变量的属性应用一个函数根据访问被引用的对象 &lt;var&gt;access-mode&lt;/var&gt; 。该 &lt;var&gt;access-mode&lt;/var&gt; 参数是必需的，而且必须是三个名字之一： &lt;code&gt;read_only&lt;/code&gt; ， &lt;code&gt;read_write&lt;/code&gt; 或 &lt;code&gt;write_only&lt;/code&gt; 。其余两个是位置参数。</target>
        </trans-unit>
        <trans-unit id="2ecdfed9d96d6be598a27e07d494142206025586" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;alias&lt;/code&gt; attribute causes the declaration to be emitted as an alias for another symbol, which must be specified. For instance,</source>
          <target state="translated">的 &lt;code&gt;alias&lt;/code&gt; 属性促使声明被发射以用于另一个符号的别名，它必须被指定。例如，</target>
        </trans-unit>
        <trans-unit id="7e61edae77066dd3dc159fcdac928cd068378010" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;alias&lt;/code&gt; attribute causes the declaration to be emitted as an alias for another symbol, which must have been previously declared with the same type, and for variables, also the same size and alignment. Declaring an alias with a different type than the target is undefined and may be diagnosed. As an example, the following declarations:</source>
          <target state="translated">的 &lt;code&gt;alias&lt;/code&gt; 属性促使声明被发射以用于另一个符号的别名，它必须用相同类型的先前声明，和用于变量，也具有相同的尺寸和对齐。声明别名与目标类型不同的别名是未定义的，可能会被诊断。例如，以下声明：</target>
        </trans-unit>
        <trans-unit id="eb2be5f23f4d95994e296cf8157df7b27aa96115" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;alias&lt;/code&gt; variable attribute causes the declaration to be emitted as an alias for another symbol known as an &lt;em&gt;alias target&lt;/em&gt;. Except for top-level qualifiers the alias target must have the same type as the alias. For instance, the following</source>
          <target state="translated">的 &lt;code&gt;alias&lt;/code&gt; 变量属性促使声明被发射以用于已知为另一符号的别名&lt;em&gt;的别名目标&lt;/em&gt;。除顶级限定符外，别名目标必须与别名具有相同的类型。例如，以下</target>
        </trans-unit>
        <trans-unit id="0bf61029ae4ce438827c598f61cf786192d3f583" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;aligned&lt;/code&gt; attribute can also be used for functions (see &lt;a href=&quot;common-function-attributes#Common-Function-Attributes&quot;&gt;Common Function Attributes&lt;/a&gt;.)</source>
          <target state="translated">该 &lt;code&gt;aligned&lt;/code&gt; 属性还可以用于函数（见&lt;a href=&quot;common-function-attributes#Common-Function-Attributes&quot;&gt;常用功能属性&lt;/a&gt;。）</target>
        </trans-unit>
        <trans-unit id="116110dd4cf7976fa8985541dcc415370c4044c0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;aligned&lt;/code&gt; attribute can also be used for variables and fields (see &lt;a href=&quot;variable-attributes#Variable-Attributes&quot;&gt;Variable Attributes&lt;/a&gt;.)</source>
          <target state="translated">所述 &lt;code&gt;aligned&lt;/code&gt; 属性还可以用于变量和字段（参见&lt;a href=&quot;variable-attributes#Variable-Attributes&quot;&gt;变量属性&lt;/a&gt;。）</target>
        </trans-unit>
        <trans-unit id="5b5ae34d39ede17878fd463e5860c5561589d603" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;aligned&lt;/code&gt; attribute specifies a minimum alignment (in bytes) for variables of the specified type. When specified, &lt;var&gt;alignment&lt;/var&gt; must be a power of 2. Specifying no &lt;var&gt;alignment&lt;/var&gt; argument implies the maximum alignment for the target, which is often, but by no means always, 8 or 16 bytes. For example, the declarations:</source>
          <target state="translated">所述 &lt;code&gt;aligned&lt;/code&gt; 属性指定指定类型的变量的最小对齐（以字节计）。指定时， &lt;var&gt;alignment&lt;/var&gt; 必须是2的幂。不指定 &lt;var&gt;alignment&lt;/var&gt; 参数意味着目标的最大对齐方式，这通常是8字节或16字节，但并非总是如此。例如，声明：</target>
        </trans-unit>
        <trans-unit id="84a176d406c41abb708c1f3ca71eadfaf0924f9d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;aligned&lt;/code&gt; attribute specifies a minimum alignment for the first instruction of the function, measured in bytes. When specified, &lt;var&gt;alignment&lt;/var&gt; must be an integer constant power of 2. Specifying no &lt;var&gt;alignment&lt;/var&gt; argument implies the ideal alignment for the target. The &lt;code&gt;__alignof__&lt;/code&gt; operator can be used to determine what that is (see &lt;a href=&quot;alignment#Alignment&quot;&gt;Alignment&lt;/a&gt;). The attribute has no effect when a definition for the function is not provided in the same translation unit.</source>
          <target state="translated">所述 &lt;code&gt;aligned&lt;/code&gt; 属性指定功能的第一个指令，以字节为单位测量的最小对齐。指定时， &lt;var&gt;alignment&lt;/var&gt; 必须是2的整数常数幂。不指定 &lt;var&gt;alignment&lt;/var&gt; 参数就意味着目标的理想对齐方式。该 &lt;code&gt;__alignof__&lt;/code&gt; 操作符可以用来确定那是什么（见&lt;a href=&quot;alignment#Alignment&quot;&gt;对齐&lt;/a&gt;）。当在同一转换单元中未提供功能定义时，该属性无效。</target>
        </trans-unit>
        <trans-unit id="8ba9bd3f254f0cc2bc69cd8b105c1d09efd2f77c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;aligned&lt;/code&gt; attribute specifies a minimum alignment for the variable or structure field, measured in bytes. When specified, &lt;var&gt;alignment&lt;/var&gt; must be an integer constant power of 2. Specifying no &lt;var&gt;alignment&lt;/var&gt; argument implies the maximum alignment for the target, which is often, but by no means always, 8 or 16 bytes.</source>
          <target state="translated">所述 &lt;code&gt;aligned&lt;/code&gt; 属性指定以字节为单位对所述可变或结构字段一个最小对齐。指定时， &lt;var&gt;alignment&lt;/var&gt; 必须是2的整数常数幂。不指定 &lt;var&gt;alignment&lt;/var&gt; 参数就意味着目标的最大对齐方式，这通常（但并非总是）为8或16个字节。</target>
        </trans-unit>
        <trans-unit id="f46b2b0bb9e3e850ca63944ddf914702b4818ed3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;alloc_align&lt;/code&gt; attribute may be applied to a function that returns a pointer and takes at least one argument of an integer or enumerated type. It indicates that the returned pointer is aligned on a boundary given by the function argument at &lt;var&gt;position&lt;/var&gt;. Meaningful alignments are powers of 2 greater than one. GCC uses this information to improve pointer alignment analysis.</source>
          <target state="translated">所述 &lt;code&gt;alloc_align&lt;/code&gt; 属性可以被应用到一个返回指针和取整数或枚举类型中的至少一个参数的函数。它指示返回的指针在 &lt;var&gt;position&lt;/var&gt; 处由函数参数指定的边界上对齐。有意义的对齐方式是2的幂乘以1。GCC使用此信息来改进指针对齐分析。</target>
        </trans-unit>
        <trans-unit id="8797cd128649602028c5dfdc7369a0575f411979" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;alloc_size&lt;/code&gt; attribute may be applied to a function that returns a pointer and takes at least one argument of an integer or enumerated type. It indicates that the returned pointer points to memory whose size is given by the function argument at &lt;var&gt;position-1&lt;/var&gt;, or by the product of the arguments at &lt;var&gt;position-1&lt;/var&gt; and &lt;var&gt;position-2&lt;/var&gt;. Meaningful sizes are positive values less than &lt;code&gt;PTRDIFF_MAX&lt;/code&gt;. GCC uses this information to improve the results of &lt;code&gt;__builtin_object_size&lt;/code&gt;.</source>
          <target state="translated">所述 &lt;code&gt;alloc_size&lt;/code&gt; 属性可以被应用于一个函数返回一个指针和取整数或枚举类型中的至少一个参数。它指示返回的指针指向内存，该内存的大小由 &lt;var&gt;position-1&lt;/var&gt; 处的函数自变量或 &lt;var&gt;position-1&lt;/var&gt; 与 &lt;var&gt;position-2&lt;/var&gt; 处的自变量的乘积给出。有意义的大小是小于 &lt;code&gt;PTRDIFF_MAX&lt;/code&gt; 的正值。 GCC使用此信息来改善 &lt;code&gt;__builtin_object_size&lt;/code&gt; 的结果。</target>
        </trans-unit>
        <trans-unit id="f06aab07630994254a1a8fb1c75da104d280fc4e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;alloc_size&lt;/code&gt; type attribute may be applied to the definition of a type of a function that returns a pointer and takes at least one argument of an integer type. It indicates that the returned pointer points to an object whose size is given by the function argument at &lt;var&gt;position-1&lt;/var&gt;, or by the product of the arguments at &lt;var&gt;position-1&lt;/var&gt; and &lt;var&gt;position-2&lt;/var&gt;. Meaningful sizes are positive values less than &lt;code&gt;PTRDIFF_MAX&lt;/code&gt;. Other sizes are disagnosed when detected. GCC uses this information to improve the results of &lt;code&gt;__builtin_object_size&lt;/code&gt;.</source>
          <target state="translated">可以将 &lt;code&gt;alloc_size&lt;/code&gt; 类型属性应用于返回指针并采用至少一个整数类型参数的函数类型的定义。它指示返回的指针指向一个对象，该对象的大小由 &lt;var&gt;position-1&lt;/var&gt; 处的函数自变量或 &lt;var&gt;position-1&lt;/var&gt; 与 &lt;var&gt;position-2&lt;/var&gt; 处的自变量的乘积给出。有意义的大小是小于 &lt;code&gt;PTRDIFF_MAX&lt;/code&gt; 的正值。检测到其他尺寸时将被忽略。 GCC使用此信息来改善 &lt;code&gt;__builtin_object_size&lt;/code&gt; 的结果。</target>
        </trans-unit>
        <trans-unit id="065a219ddaff6d679a0be49eb2bd7f719e312c3d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;alloc_size&lt;/code&gt; variable attribute may be applied to the declaration of a pointer to a function that returns a pointer and takes at least one argument of an integer type. It indicates that the returned pointer points to an object whose size is given by the function argument at &lt;var&gt;position-1&lt;/var&gt;, or by the product of the arguments at &lt;var&gt;position-1&lt;/var&gt; and &lt;var&gt;position-2&lt;/var&gt;. Meaningful sizes are positive values less than &lt;code&gt;PTRDIFF_MAX&lt;/code&gt;. Other sizes are disagnosed when detected. GCC uses this information to improve the results of &lt;code&gt;__builtin_object_size&lt;/code&gt;.</source>
          <target state="translated">可以将 &lt;code&gt;alloc_size&lt;/code&gt; 变量属性应用于指向函数的指针的声明，该函数返回一个指针并采用至少一个整数类型的参数。它指示返回的指针指向一个对象，该对象的大小由 &lt;var&gt;position-1&lt;/var&gt; 处的函数自变量或 &lt;var&gt;position-1&lt;/var&gt; 与 &lt;var&gt;position-2&lt;/var&gt; 处的自变量的乘积给出。有意义的大小是小于 &lt;code&gt;PTRDIFF_MAX&lt;/code&gt; 的正值。检测到其他尺寸时将被忽略。 GCC使用此信息来改善 &lt;code&gt;__builtin_object_size&lt;/code&gt; 的结果。</target>
        </trans-unit>
        <trans-unit id="cbdc1421fb579e3bcb9c9ed2bb5181ffe0b47ee4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;asm&lt;/code&gt; keyword allows you to embed assembler instructions within C code. GCC provides two forms of inline &lt;code&gt;asm&lt;/code&gt; statements. A &lt;em&gt;basic &lt;code&gt;asm&lt;/code&gt;&lt;/em&gt; statement is one with no operands (see &lt;a href=&quot;basic-asm#Basic-Asm&quot;&gt;Basic Asm&lt;/a&gt;), while an &lt;em&gt;extended &lt;code&gt;asm&lt;/code&gt;&lt;/em&gt; statement (see &lt;a href=&quot;extended-asm#Extended-Asm&quot;&gt;Extended Asm&lt;/a&gt;) includes one or more operands. The extended form is preferred for mixing C and assembly language within a function, but to include assembly language at top level you must use basic &lt;code&gt;asm&lt;/code&gt;.</source>
          <target state="translated">使用 &lt;code&gt;asm&lt;/code&gt; 关键字可以将汇编程序指令嵌入C代码中。GCC提供了两种形式的内联 &lt;code&gt;asm&lt;/code&gt; 语句。一个&lt;em&gt;基本的 &lt;code&gt;asm&lt;/code&gt; &lt;/em&gt;语句是一个没有操作数（请参阅&lt;a href=&quot;basic-asm#Basic-Asm&quot;&gt;基本ASM&lt;/a&gt;），而在&lt;em&gt;扩展 &lt;code&gt;asm&lt;/code&gt; &lt;/em&gt;声明（见&lt;a href=&quot;extended-asm#Extended-Asm&quot;&gt;扩展ASM&lt;/a&gt;）包括一个或多个操作数。扩展形式是在函数中混合使用C和汇编语言的首选，但是要在顶层包含汇编语言，则必须使用basic &lt;code&gt;asm&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c83f20d0e6ffe18a83c8f1ea64e1025e8b4e3b79" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;asm&lt;/code&gt; keyword is a GNU extension. When writing code that can be compiled with</source>
          <target state="translated">该 &lt;code&gt;asm&lt;/code&gt; 关键字是GNU扩展。在编写可以使用以下代码编译的代码时</target>
        </trans-unit>
        <trans-unit id="5154cd3afb55ec67fd254011d045e0b4c9d93a08" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;asm&lt;/code&gt; statement allows you to include assembly instructions directly within C code. This may help you to maximize performance in time-sensitive code or to access assembly instructions that are not readily available to C programs.</source>
          <target state="translated">使用 &lt;code&gt;asm&lt;/code&gt; 语句可以将汇编指令直接包含在C代码中。这可以帮助您在对时间敏感的代码中最大化性能，或者访问C程序不容易使用的汇编指令。</target>
        </trans-unit>
        <trans-unit id="889a71d5c542b05221a1fea4fb081bfa156749e5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;assume_aligned&lt;/code&gt; attribute may be applied to a function that returns a pointer. It indicates that the returned pointer is aligned on a boundary given by &lt;var&gt;alignment&lt;/var&gt;. If the attribute has two arguments, the second argument is misalignment &lt;var&gt;offset&lt;/var&gt;. Meaningful values of &lt;var&gt;alignment&lt;/var&gt; are powers of 2 greater than one. Meaningful values of &lt;var&gt;offset&lt;/var&gt; are greater than zero and less than &lt;var&gt;alignment&lt;/var&gt;.</source>
          <target state="translated">所述 &lt;code&gt;assume_aligned&lt;/code&gt; 属性可被应用于一个返回指针的函数。它指示返回的指针在 &lt;var&gt;alignment&lt;/var&gt; 给定的边界上对齐。如果该属性具有两个参数，则第二个参数为misalignment &lt;var&gt;offset&lt;/var&gt; 。 &lt;var&gt;alignment&lt;/var&gt; 有意义的值是2的幂乘以1。有意义的 &lt;var&gt;offset&lt;/var&gt; 值大于零且小于 &lt;var&gt;alignment&lt;/var&gt; 。</target>
        </trans-unit>
        <trans-unit id="e7eb78f1e02d22076254e95ec303c8093068484f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;aux&lt;/code&gt; attribute is used to directly access the ARC&amp;rsquo;s auxiliary register space from C. The auxilirary register number is given via attribute argument.</source>
          <target state="translated">的 &lt;code&gt;aux&lt;/code&gt; 属性用于直接访问ARC的从C的auxilirary寄存器号码经由属性参数给出辅助寄存器空间。</target>
        </trans-unit>
        <trans-unit id="b63bd6b23aa2da11430c3217df7f40955b5b703f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;b&lt;/code&gt; register.</source>
          <target state="translated">在 &lt;code&gt;b&lt;/code&gt; 寄存器。</target>
        </trans-unit>
        <trans-unit id="0166d882668eb629f4c81b26d5f43ba89f13484a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;c&lt;/code&gt; register.</source>
          <target state="translated">该 &lt;code&gt;c&lt;/code&gt; 寄存器。</target>
        </trans-unit>
        <trans-unit id="07fada73a7cf214a1328d2a6e8cd842b7cf5c1a8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cf_check&lt;/code&gt; attribute on a function is used to inform the compiler that ENDBR instruction should be placed at the function entry when</source>
          <target state="translated">函数上的 &lt;code&gt;cf_check&lt;/code&gt; 属性用于通知编译器在以下情况下应将ENDBR指令放置在函数条目中：</target>
        </trans-unit>
        <trans-unit id="ca2675a5f39c8ca20fe391d93c61cca5056e32cc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cleanup&lt;/code&gt; attribute runs a function when the variable goes out of scope. This attribute can only be applied to auto function scope variables; it may not be applied to parameters or variables with static storage duration. The function must take one parameter, a pointer to a type compatible with the variable. The return value of the function (if any) is ignored.</source>
          <target state="translated">所述 &lt;code&gt;cleanup&lt;/code&gt; 属性当变量超出范围出运行的函数。此属性只能应用于自动功能范围变量；它可能不适用于具有静态存储持续时间的参数或变量。该函数必须带有一个参数，即指向与该变量兼容的类型的指针。该函数的返回值（如果有）将被忽略。</target>
        </trans-unit>
        <trans-unit id="85d44203c9f2ae9c43811502121d3c877febd137" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cold&lt;/code&gt; attribute on functions is used to inform the compiler that the function is unlikely to be executed. The function is optimized for size rather than speed and on many targets it is placed into a special subsection of the text section so all cold functions appear close together, improving code locality of non-cold parts of program. The paths leading to calls of cold functions within code are marked as unlikely by the branch prediction mechanism. It is thus useful to mark functions used to handle unlikely conditions, such as &lt;code&gt;perror&lt;/code&gt;, as cold to improve optimization of hot functions that do call marked functions in rare occasions.</source>
          <target state="translated">函数的 &lt;code&gt;cold&lt;/code&gt; 属性用于通知编译器该函数不太可能执行。该函数针对大小而不是速度进行了优化，并且在许多目标上将其放置在文本节的特殊子节中，因此所有冷函数都显示在一起，从而提高了程序非冷部分的代码局部性。分支预测机制将导致调用代码中冷函数的路径标记为不太可能。因此，将用于处理不太可能的情况（例如 &lt;code&gt;perror&lt;/code&gt; )的函数标记为冷是有用的，以改善在极少数情况下确实会调用标记函数的热函数的优化。</target>
        </trans-unit>
        <trans-unit id="baaebf592a1c26312204d234ba4d0961fa9cfdc4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cold&lt;/code&gt; attribute on labels is used to inform the compiler that the path following the label is unlikely to be executed. This attribute is used in cases where &lt;code&gt;__builtin_expect&lt;/code&gt; cannot be used, for instance with computed goto or &lt;code&gt;asm goto&lt;/code&gt;.</source>
          <target state="translated">标签上的 &lt;code&gt;cold&lt;/code&gt; 属性用于通知编译器该标签后面的路径不太可能被执行。在无法使用 &lt;code&gt;__builtin_expect&lt;/code&gt; 的情况下（例如，对于计算出的goto或 &lt;code&gt;asm goto&lt;/code&gt; )，可以使用此属性。</target>
        </trans-unit>
        <trans-unit id="84aae041fbfd493303c7dc6f97608b2aa0f0cfea" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;common&lt;/code&gt; attribute requests GCC to place a variable in &amp;ldquo;common&amp;rdquo; storage. The &lt;code&gt;nocommon&lt;/code&gt; attribute requests the opposite&amp;mdash;to allocate space for it directly.</source>
          <target state="translated">该 &lt;code&gt;common&lt;/code&gt; 属性要求GCC放置在&amp;ldquo;常用&amp;rdquo;存储的变量。所述 &lt;code&gt;nocommon&lt;/code&gt; 属性请求对方-为它直接分配空间。</target>
        </trans-unit>
        <trans-unit id="09440712407e39d94a0cdcf960e85948cfc3c350" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;const&lt;/code&gt; attribute imposes greater restrictions on a function&amp;rsquo;s definition than the similar &lt;code&gt;pure&lt;/code&gt; attribute. Declaring the same function with both the &lt;code&gt;const&lt;/code&gt; and the &lt;code&gt;pure&lt;/code&gt; attribute is diagnosed. Because a const function cannot have any observable side effects it does not make sense for it to return &lt;code&gt;void&lt;/code&gt;. Declaring such a function is diagnosed.</source>
          <target state="translated">该 &lt;code&gt;const&lt;/code&gt; 属性规定了比同类功能的定义更严格的限制 &lt;code&gt;pure&lt;/code&gt; 属性。诊断使用 &lt;code&gt;const&lt;/code&gt; 和 &lt;code&gt;pure&lt;/code&gt; 属性声明相同的功能。因为const函数不能有任何可观察到的副作用，所以使其返回 &lt;code&gt;void&lt;/code&gt; 没有意义。诊断出声明了这样的功能。</target>
        </trans-unit>
        <trans-unit id="db8d892c81dcdfdd626d5be4bd09dab512df4f9b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;const&lt;/code&gt; attribute prohibits a function from reading objects that affect its return value between successive invocations. However, functions declared with the attribute can safely read objects that do not change their return value, such as non-volatile constants.</source>
          <target state="translated">该 &lt;code&gt;const&lt;/code&gt; 属性从阅读影响连续调用之间的返回值对象禁止功能。但是，使用该属性声明的函数可以安全地读取不更改其返回值的对象，例如非易失性常量。</target>
        </trans-unit>
        <trans-unit id="99106b80230d2cf73a73b452a0a31c02c4de491f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;constructor&lt;/code&gt; attribute causes the function to be called automatically before execution enters &lt;code&gt;main ()&lt;/code&gt;. Similarly, the &lt;code&gt;destructor&lt;/code&gt; attribute causes the function to be called automatically after &lt;code&gt;main ()&lt;/code&gt; completes or &lt;code&gt;exit ()&lt;/code&gt; is called. Functions with these attributes are useful for initializing data that is used implicitly during the execution of the program.</source>
          <target state="translated">的 &lt;code&gt;constructor&lt;/code&gt; 属性导致函数被自动调用之前执行进入 &lt;code&gt;main ()&lt;/code&gt; 。同样， &lt;code&gt;destructor&lt;/code&gt; 属性使函数在 &lt;code&gt;main ()&lt;/code&gt; 完成或调用 &lt;code&gt;exit ()&lt;/code&gt; 之后自动被调用。具有这些属性的函数对于初始化在程序执行期间隐式使用的数据很有用。</target>
        </trans-unit>
        <trans-unit id="7f891d087177f42fcc2b6b6abd03f036315d60bd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;copy&lt;/code&gt; attribute applies the set of attributes with which &lt;var&gt;function&lt;/var&gt; has been declared to the declaration of the function to which the attribute is applied. The attribute is designed for libraries that define aliases or function resolvers that are expected to specify the same set of attributes as their targets. The &lt;code&gt;copy&lt;/code&gt; attribute can be used with functions, variables, or types. However, the kind of symbol to which the attribute is applied (either function or variable) must match the kind of symbol to which the argument refers. The &lt;code&gt;copy&lt;/code&gt; attribute copies only syntactic and semantic attributes but not attributes that affect a symbol&amp;rsquo;s linkage or visibility such as &lt;code&gt;alias&lt;/code&gt;, &lt;code&gt;visibility&lt;/code&gt;, or &lt;code&gt;weak&lt;/code&gt;. The &lt;code&gt;deprecated&lt;/code&gt; and &lt;code&gt;target_clones&lt;/code&gt; attribute are also not copied. See &lt;a href=&quot;common-type-attributes#Common-Type-Attributes&quot;&gt;Common Type Attributes&lt;/a&gt;. See &lt;a href=&quot;common-variable-attributes#Common-Variable-Attributes&quot;&gt;Common Variable Attributes&lt;/a&gt;.</source>
          <target state="translated">该 &lt;code&gt;copy&lt;/code&gt; 的属性应用一组与属性的 &lt;var&gt;function&lt;/var&gt; 已被宣布为是应用该属性的函数的声明。该属性是为定义别名或函数解析器的库而设计的，这些别名或函数解析器应指定与其目标相同的属性集。的 &lt;code&gt;copy&lt;/code&gt; 属性可以与函数，变量，或类型一起使用。但是，应用属性的符号类型（函数或变量）必须与参数所引用的符号类型匹配。该 &lt;code&gt;copy&lt;/code&gt; 属性仅复制句法和语义属性，但不是属性，这些属性影响元件的链接或知名度，如 &lt;code&gt;alias&lt;/code&gt; ， &lt;code&gt;visibility&lt;/code&gt; 或 &lt;code&gt;weak&lt;/code&gt; 。在 &lt;code&gt;deprecated&lt;/code&gt; 和 &lt;code&gt;target_clones&lt;/code&gt; 属性也不会被复制。请参阅&amp;ldquo;&lt;a href=&quot;common-type-attributes#Common-Type-Attributes&quot;&gt;通用类型属性&amp;rdquo;&lt;/a&gt;。请参见&lt;a href=&quot;common-variable-attributes#Common-Variable-Attributes&quot;&gt;通用变量属性&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1214564b5cbc84df3e7da6094de27b7006df5a48" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;copy&lt;/code&gt; attribute applies the set of attributes with which &lt;var&gt;function&lt;/var&gt; has been declared to the declaration of the function to which the attribute is applied. The attribute is designed for libraries that define aliases or function resolvers that are expected to specify the same set of attributes as their targets. The &lt;code&gt;copy&lt;/code&gt; attribute can be used with functions, variables, or types. However, the kind of symbol to which the attribute is applied (either function or variable) must match the kind of symbol to which the argument refers. The &lt;code&gt;copy&lt;/code&gt; attribute copies only syntactic and semantic attributes but not attributes that affect a symbol&amp;rsquo;s linkage or visibility such as &lt;code&gt;alias&lt;/code&gt;, &lt;code&gt;visibility&lt;/code&gt;, or &lt;code&gt;weak&lt;/code&gt;. The &lt;code&gt;deprecated&lt;/code&gt; attribute is also not copied. See &lt;a href=&quot;common-type-attributes#Common-Type-Attributes&quot;&gt;Common Type Attributes&lt;/a&gt;. See &lt;a href=&quot;common-variable-attributes#Common-Variable-Attributes&quot;&gt;Common Variable Attributes&lt;/a&gt;.</source>
          <target state="translated">该 &lt;code&gt;copy&lt;/code&gt; 的属性应用一组与属性的 &lt;var&gt;function&lt;/var&gt; 已被宣布为是应用该属性的函数的声明。该属性是为定义别名或函数解析器的库而设计的，这些别名或函数解析器应指定与其目标相同的属性集。的 &lt;code&gt;copy&lt;/code&gt; 属性可以与函数，变量，或类型一起使用。但是，应用属性的符号类型（函数或变量）必须与参数所引用的符号类型匹配。该 &lt;code&gt;copy&lt;/code&gt; 属性仅复制句法和语义属性，但不是属性，这些属性影响元件的链接或知名度，如 &lt;code&gt;alias&lt;/code&gt; ， &lt;code&gt;visibility&lt;/code&gt; 或 &lt;code&gt;weak&lt;/code&gt; 。该 &lt;code&gt;deprecated&lt;/code&gt; 属性也不会被复制。请参阅&amp;ldquo; &lt;a href=&quot;common-type-attributes#Common-Type-Attributes&quot;&gt;通用类型属性&amp;rdquo;&lt;/a&gt;。请参见&lt;a href=&quot;common-variable-attributes#Common-Variable-Attributes&quot;&gt;通用变量属性&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="592273a5e05d6744ed0bd5dc37c91bbe97b23cb1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;copy&lt;/code&gt; attribute applies the set of attributes with which &lt;var&gt;variable&lt;/var&gt; has been declared to the declaration of the variable to which the attribute is applied. The attribute is designed for libraries that define aliases that are expected to specify the same set of attributes as the aliased symbols. The &lt;code&gt;copy&lt;/code&gt; attribute can be used with variables, functions or types. However, the kind of symbol to which the attribute is applied (either varible or function) must match the kind of symbol to which the argument refers. The &lt;code&gt;copy&lt;/code&gt; attribute copies only syntactic and semantic attributes but not attributes that affect a symbol&amp;rsquo;s linkage or visibility such as &lt;code&gt;alias&lt;/code&gt;, &lt;code&gt;visibility&lt;/code&gt;, or &lt;code&gt;weak&lt;/code&gt;. The &lt;code&gt;deprecated&lt;/code&gt; attribute is also not copied. See &lt;a href=&quot;common-function-attributes#Common-Function-Attributes&quot;&gt;Common Function Attributes&lt;/a&gt;. See &lt;a href=&quot;common-type-attributes#Common-Type-Attributes&quot;&gt;Common Type Attributes&lt;/a&gt;.</source>
          <target state="translated">该 &lt;code&gt;copy&lt;/code&gt; 的属性应用一组与属性的 &lt;var&gt;variable&lt;/var&gt; 已经宣布，其应用属性变量的声明。该属性是为定义别名的库而设计的，这些别名应指定与别名符号相同的属性集。的 &lt;code&gt;copy&lt;/code&gt; 属性可以与变量，函数或类型一起使用。但是，应用属性的符号类型（变量或函数）必须与参数所引用的符号类型匹配。该 &lt;code&gt;copy&lt;/code&gt; 属性仅复制句法和语义属性，但不是属性，这些属性影响元件的链接或知名度，如 &lt;code&gt;alias&lt;/code&gt; ， &lt;code&gt;visibility&lt;/code&gt; ，或 &lt;code&gt;weak&lt;/code&gt; 。该 &lt;code&gt;deprecated&lt;/code&gt; 属性也不会被复制。请参阅&lt;a href=&quot;common-function-attributes#Common-Function-Attributes&quot;&gt;通用功能属性&lt;/a&gt;。请参阅&amp;ldquo; &lt;a href=&quot;common-type-attributes#Common-Type-Attributes&quot;&gt;通用类型属性&amp;rdquo;&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a505e2a0a73ab045449836d4a18bec5c0bc8127e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;copy&lt;/code&gt; attribute applies the set of attributes with which the type of the &lt;var&gt;expression&lt;/var&gt; has been declared to the declaration of the type to which the attribute is applied. The attribute is designed for libraries that define aliases that are expected to specify the same set of attributes as the aliased symbols. The &lt;code&gt;copy&lt;/code&gt; attribute can be used with types, variables, or functions. However, the kind of symbol to which the attribute is applied (either varible or function) must match the kind of symbol to which the argument refers. The &lt;code&gt;copy&lt;/code&gt; attribute copies only syntactic and semantic attributes but not attributes that affect a symbol&amp;rsquo;s linkage or visibility such as &lt;code&gt;alias&lt;/code&gt;, &lt;code&gt;visibility&lt;/code&gt;, or &lt;code&gt;weak&lt;/code&gt;. The &lt;code&gt;deprecated&lt;/code&gt; attribute is also not copied. See &lt;a href=&quot;common-function-attributes#Common-Function-Attributes&quot;&gt;Common Function Attributes&lt;/a&gt;. See &lt;a href=&quot;common-variable-attributes#Common-Variable-Attributes&quot;&gt;Common Variable Attributes&lt;/a&gt;.</source>
          <target state="translated">的 &lt;code&gt;copy&lt;/code&gt; 属性适用的集合与该类型属性的 &lt;var&gt;expression&lt;/var&gt; 已被宣布为被施加所述属性的类型的声明。该属性是为定义别名的库而设计的，这些别名应指定与别名符号相同的属性集。的 &lt;code&gt;copy&lt;/code&gt; 属性可以与类型，变量，或功能一起使用。但是，应用属性的符号类型（变量或函数）必须与参数所引用的符号类型匹配。该 &lt;code&gt;copy&lt;/code&gt; 属性仅复制句法和语义属性，但不是属性，这些属性影响元件的链接或知名度，如 &lt;code&gt;alias&lt;/code&gt; ， &lt;code&gt;visibility&lt;/code&gt; ，或 &lt;code&gt;weak&lt;/code&gt; 。该 &lt;code&gt;deprecated&lt;/code&gt; 属性也不会被复制。请参阅&lt;a href=&quot;common-function-attributes#Common-Function-Attributes&quot;&gt;通用功能属性&lt;/a&gt;。请参见&lt;a href=&quot;common-variable-attributes#Common-Variable-Attributes&quot;&gt;通用变量属性&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f8a4a7841fe7fe34c4f48a65b187a7fb8df9b582" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;d&lt;/code&gt; register.</source>
          <target state="translated">该 &lt;code&gt;d&lt;/code&gt; 寄存器。</target>
        </trans-unit>
        <trans-unit id="024895282c898bc3d4211d4724e2af4880224cde" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;deprecated&lt;/code&gt; attribute can also be used for functions and types (see &lt;a href=&quot;common-function-attributes#Common-Function-Attributes&quot;&gt;Common Function Attributes&lt;/a&gt;, see &lt;a href=&quot;common-type-attributes#Common-Type-Attributes&quot;&gt;Common Type Attributes&lt;/a&gt;).</source>
          <target state="translated">的 &lt;code&gt;deprecated&lt;/code&gt; 属性也可用于功能和类型的（参见&lt;a href=&quot;common-function-attributes#Common-Function-Attributes&quot;&gt;常用功能属性&lt;/a&gt;，见&lt;a href=&quot;common-type-attributes#Common-Type-Attributes&quot;&gt;普通类型属性&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="162fc2b6ed9e6c2908900a7eb89f4726020462d4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;deprecated&lt;/code&gt; attribute can also be used for functions and variables (see &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;Function Attributes&lt;/a&gt;, see &lt;a href=&quot;variable-attributes#Variable-Attributes&quot;&gt;Variable Attributes&lt;/a&gt;.)</source>
          <target state="translated">的 &lt;code&gt;deprecated&lt;/code&gt; 属性还可以用于函数和变量（见&lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;功能属性&lt;/a&gt;，参见&lt;a href=&quot;variable-attributes#Variable-Attributes&quot;&gt;变量属性&lt;/a&gt;。）</target>
        </trans-unit>
        <trans-unit id="b2cfdb164eda8f42cf6433c514a0ea224366c785" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;deprecated&lt;/code&gt; attribute can also be used for variables and types (see &lt;a href=&quot;variable-attributes#Variable-Attributes&quot;&gt;Variable Attributes&lt;/a&gt;, see &lt;a href=&quot;type-attributes#Type-Attributes&quot;&gt;Type Attributes&lt;/a&gt;.)</source>
          <target state="translated">的 &lt;code&gt;deprecated&lt;/code&gt; 属性还可以用于变量和类型（参见&lt;a href=&quot;variable-attributes#Variable-Attributes&quot;&gt;变量属性&lt;/a&gt;，参见&lt;a href=&quot;type-attributes#Type-Attributes&quot;&gt;类型属性&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="cad1e87fce264d36291150600cb66c57e91c1432" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;deprecated&lt;/code&gt; attribute results in a warning if the enumerator is used anywhere in the source file. This is useful when identifying enumerators that are expected to be removed in a future version of a program. The warning also includes the location of the declaration of the deprecated enumerator, to enable users to easily find further information about why the enumerator is deprecated, or what they should do instead. Note that the warnings only occurs for uses.</source>
          <target state="translated">如果在源文件中的任何位置使用了枚举数， &lt;code&gt;deprecated&lt;/code&gt; 属性将产生警告。当确定预期在程序的将来版本中删除的枚举器时，此功能很有用。该警告还包括不赞成使用的枚举器的声明的位置，以使用户可以轻松找到有关为什么不赞成使用该枚举器或应该做什么的更多信息。请注意，警告仅在使用时出现。</target>
        </trans-unit>
        <trans-unit id="20e0cb154d9e21da1f2de2ead88f358575c22b29" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;deprecated&lt;/code&gt; attribute results in a warning if the function is used anywhere in the source file. This is useful when identifying functions that are expected to be removed in a future version of a program. The warning also includes the location of the declaration of the deprecated function, to enable users to easily find further information about why the function is deprecated, or what they should do instead. Note that the warnings only occurs for uses:</source>
          <target state="translated">如果在源文件中的任何位置使用该功能， &lt;code&gt;deprecated&lt;/code&gt; 属性将产生警告。当识别预期在程序的将来版本中删除的功能时，此功能很有用。该警告还包括不赞成使用的函数的声明的位置，以使用户可以轻松找到有关不赞成使用该函数的原因或应采取的措施的进一步信息。请注意，警告仅针对以下用途：</target>
        </trans-unit>
        <trans-unit id="7280557c8bb44f2fb4dbaff815426552ad4804e8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;deprecated&lt;/code&gt; attribute results in a warning if the type is used anywhere in the source file. This is useful when identifying types that are expected to be removed in a future version of a program. If possible, the warning also includes the location of the declaration of the deprecated type, to enable users to easily find further information about why the type is deprecated, or what they should do instead. Note that the warnings only occur for uses and then only if the type is being applied to an identifier that itself is not being declared as deprecated.</source>
          <target state="translated">如果在源文件中的任何位置使用了该类型， &lt;code&gt;deprecated&lt;/code&gt; 属性将导致警告。当标识预期在程序的将来版本中删除的类型时，这很有用。如果可能的话，警告还包括不赞成使用的类型的声明的位置，以使用户可以轻松地找到有关为什么不赞成使用该类型或应该做什么的更多信息。请注意，警告仅在使用时发生，然后仅在将类型应用于未声明为不推荐使用的标识符时才发生。</target>
        </trans-unit>
        <trans-unit id="597712de9335903c130e7df57d7a0ba95b08639b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;deprecated&lt;/code&gt; attribute results in a warning if the variable is used anywhere in the source file. This is useful when identifying variables that are expected to be removed in a future version of a program. The warning also includes the location of the declaration of the deprecated variable, to enable users to easily find further information about why the variable is deprecated, or what they should do instead. Note that the warning only occurs for uses:</source>
          <target state="translated">该 &lt;code&gt;deprecated&lt;/code&gt; 的警告属性的结果，如果变量在源文件中的任何地方使用。当标识预期在程序的将来版本中删除的变量时，这很有用。该警告还包括不赞成使用的变量的声明的位置，以使用户可以轻松地找到有关不赞成使用该变量的原因或应采取的行动的进一步信息。请注意，警告仅在以下情况下发生：</target>
        </trans-unit>
        <trans-unit id="344b31eee254fd7731082259002ff33f9b48b98f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;di&lt;/code&gt; register.</source>
          <target state="translated">在 &lt;code&gt;di&lt;/code&gt; 寄存器。</target>
        </trans-unit>
        <trans-unit id="1650914162ce3f6c59a952f96564a05c9635bff9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;dllimport&lt;/code&gt; and &lt;code&gt;dllexport&lt;/code&gt; attributes are described in &lt;a href=&quot;microsoft-windows-function-attributes#Microsoft-Windows-Function-Attributes&quot;&gt;Microsoft Windows Function Attributes&lt;/a&gt;.</source>
          <target state="translated">该 &lt;code&gt;dllimport&lt;/code&gt; 的和 &lt;code&gt;dllexport&lt;/code&gt; 属性中描述&lt;a href=&quot;microsoft-windows-function-attributes#Microsoft-Windows-Function-Attributes&quot;&gt;的Microsoft Windows功能属性&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="602269999e7f262d03410dcdc10e151a9ba7ec4f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;either&lt;/code&gt; attribute is special. It tells the linker to place the object into the corresponding &lt;code&gt;lower&lt;/code&gt; section if there is room for it. If there is insufficient room then the object is placed into the corresponding &lt;code&gt;upper&lt;/code&gt; section instead. Note that the placement algorithm is not very sophisticated. It does not attempt to find an optimal packing of the &lt;code&gt;lower&lt;/code&gt; sections. It just makes one pass over the objects and does the best that it can. Using the</source>
          <target state="translated">该 &lt;code&gt;either&lt;/code&gt; 属性是特殊的。它告诉链接器是否有空间将其放置在相应的 &lt;code&gt;lower&lt;/code&gt; 区域中。如果没有足够的空间，则将对象放置在相应的 &lt;code&gt;upper&lt;/code&gt; 。注意，放置算法不是很复杂。它没有尝试找到 &lt;code&gt;lower&lt;/code&gt; 的最佳包装。它仅使对象越过并尽其所能。使用</target>
        </trans-unit>
        <trans-unit id="127ffb86a9524294853f3ef1fc5800cb8a1c3768" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;fallthrough&lt;/code&gt; attribute with a null statement serves as a fallthrough statement. It hints to the compiler that a statement that falls through to another case label, or user-defined label in a switch statement is intentional and thus the</source>
          <target state="translated">具有空语句的 &lt;code&gt;fallthrough&lt;/code&gt; 属性用作fallthrough语句。它向编译器暗示一个语句落入另一个case标签或switch语句中的用户定义标签是故意的，因此</target>
        </trans-unit>
        <trans-unit id="6830b1617bcd576d4ef6cff9b6f00ee4b5966d52" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;fixincludes&lt;/code&gt; script interacts badly with automounters; if the directory of system header files is automounted, it tends to be unmounted while &lt;code&gt;fixincludes&lt;/code&gt; is running. This would seem to be a bug in the automounter. We don&amp;rsquo;t know any good way to work around it.</source>
          <target state="translated">该 &lt;code&gt;fixincludes&lt;/code&gt; 脚本交互严重与automounters; 如果系统头文件的目录是自动挂载的，则在运行 &lt;code&gt;fixincludes&lt;/code&gt; 时倾向于将其卸载。这似乎是自动安装程序中的错误。我们不知道有什么好的方法来解决它。</target>
        </trans-unit>
        <trans-unit id="c63425a2cbc7b99cbe7ca99c3dbf9d57e95519bb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;format&lt;/code&gt; attribute allows you to identify your own functions that take format strings as arguments, so that GCC can check the calls to these functions for errors. The compiler always (unless</source>
          <target state="translated">该 &lt;code&gt;format&lt;/code&gt; 属性可以让你找出自己的函数以格式字符串作为参数，使GCC可以检查这些功能的调用有无错误。编译器始终（除非</target>
        </trans-unit>
        <trans-unit id="8186a0d48987dddde9af17dcccbd13ea17379b53" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;format&lt;/code&gt; attribute specifies that a function takes &lt;code&gt;printf&lt;/code&gt;, &lt;code&gt;scanf&lt;/code&gt;, &lt;code&gt;strftime&lt;/code&gt; or &lt;code&gt;strfmon&lt;/code&gt; style arguments that should be type-checked against a format string. For example, the declaration:</source>
          <target state="translated">该 &lt;code&gt;format&lt;/code&gt; 属性指定一个函数具有 &lt;code&gt;printf&lt;/code&gt; 的， &lt;code&gt;scanf&lt;/code&gt; 函数， &lt;code&gt;strftime&lt;/code&gt; 的或 &lt;code&gt;strfmon&lt;/code&gt; 风格的参数应该是类型检查与格式字符串。例如，声明：</target>
        </trans-unit>
        <trans-unit id="85cee214b83f923e35c9402c26181e376eaa3ea2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;format_arg&lt;/code&gt; attribute allows you to identify your own functions that modify format strings, so that GCC can check the calls to &lt;code&gt;printf&lt;/code&gt;, &lt;code&gt;scanf&lt;/code&gt;, &lt;code&gt;strftime&lt;/code&gt; or &lt;code&gt;strfmon&lt;/code&gt; type function whose operands are a call to one of your own function. The compiler always treats &lt;code&gt;gettext&lt;/code&gt;, &lt;code&gt;dgettext&lt;/code&gt;, and &lt;code&gt;dcgettext&lt;/code&gt; in this manner except when strict ISO C support is requested by</source>
          <target state="translated">该 &lt;code&gt;format_arg&lt;/code&gt; 属性可以让你找出自己的函数修改格式字符串，使GCC可以检查调用 &lt;code&gt;printf&lt;/code&gt; ， &lt;code&gt;scanf&lt;/code&gt; 函数， &lt;code&gt;strftime&lt;/code&gt; 的或 &lt;code&gt;strfmon&lt;/code&gt; 类型的函数，其操作数到自己的函数之一的调用。编译器始终以这种方式处理 &lt;code&gt;gettext&lt;/code&gt; ， &lt;code&gt;dgettext&lt;/code&gt; 和 &lt;code&gt;dcgettext&lt;/code&gt; ，除非在以下情况下要求严格的ISO C支持</target>
        </trans-unit>
        <trans-unit id="3daa7d7140f7871d6b8af467ff44e71c895472e1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;format_arg&lt;/code&gt; attribute specifies that a function takes one or more format strings for a &lt;code&gt;printf&lt;/code&gt;, &lt;code&gt;scanf&lt;/code&gt;, &lt;code&gt;strftime&lt;/code&gt; or &lt;code&gt;strfmon&lt;/code&gt; style function and modifies it (for example, to translate it into another language), so the result can be passed to a &lt;code&gt;printf&lt;/code&gt;, &lt;code&gt;scanf&lt;/code&gt;, &lt;code&gt;strftime&lt;/code&gt; or &lt;code&gt;strfmon&lt;/code&gt; style function (with the remaining arguments to the format function the same as they would have been for the unmodified string). Multiple &lt;code&gt;format_arg&lt;/code&gt; attributes may be applied to the same function, each designating a distinct parameter as a format string. For example, the declaration:</source>
          <target state="translated">该 &lt;code&gt;format_arg&lt;/code&gt; 属性指定一个函数使用一个或多个格式字符串 &lt;code&gt;printf&lt;/code&gt; ， &lt;code&gt;scanf&lt;/code&gt; 函数， &lt;code&gt;strftime&lt;/code&gt; 的或 &lt;code&gt;strfmon&lt;/code&gt; 风格的函数，并修改它（例如，把它翻译成另一种语言），这样的结果可以被传递到 &lt;code&gt;printf&lt;/code&gt; ， &lt;code&gt;scanf&lt;/code&gt; 函数， &lt;code&gt;strftime&lt;/code&gt; 或 &lt;code&gt;strfmon&lt;/code&gt; 样式函数（格式函数的其余参数与未修改的字符串相同）。可以将多个 &lt;code&gt;format_arg&lt;/code&gt; 属性应用于同一函数，每个属性都将不同的参数指定为格式字符串。例如，声明：</target>
        </trans-unit>
        <trans-unit id="cca4e3fc744cfd6bb4409a911b1eaa70a4a7b0f8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;gcc&lt;/code&gt; program accepts options and file names as operands. Many options have multi-letter names; therefore multiple single-letter options may &lt;em&gt;not&lt;/em&gt; be grouped:</source>
          <target state="translated">在 &lt;code&gt;gcc&lt;/code&gt; 程序接受选项和文件名作为操作数。许多选项都有多字母名称；因此，多个单字母选项可能&lt;em&gt;不会&lt;/em&gt;分组：</target>
        </trans-unit>
        <trans-unit id="13501a1cf6115328de048bf9d04f10c4c82f956e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;getenv&lt;/code&gt; spec function takes two arguments: an environment variable name and a string. If the environment variable is not defined, a fatal error is issued. Otherwise, the return value is the value of the environment variable concatenated with the string. For example, if &lt;code&gt;TOPDIR&lt;/code&gt; is defined as</source>
          <target state="translated">该 &lt;code&gt;getenv&lt;/code&gt; 的规范函数有两个参数：一个环境变量名和一个字符串。如果未定义环境变量，则会发出致命错误。否则，返回值是与字符串连接的环境变量的值。例如，如果 &lt;code&gt;TOPDIR&lt;/code&gt; 定义为</target>
        </trans-unit>
        <trans-unit id="7e47220a0b9fe1eafb603003bb97378e81c55693" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;hot&lt;/code&gt; attribute on a function is used to inform the compiler that the function is a hot spot of the compiled program. The function is optimized more aggressively and on many targets it is placed into a special subsection of the text section so all hot functions appear close together, improving locality.</source>
          <target state="translated">函数上的 &lt;code&gt;hot&lt;/code&gt; 属性用于通知编译器该函数是已编译程序的热点。该功能得到了更积极的优化，并且在许多目标上都将其放置在文本部分的特殊子区域中，因此所有热功能均显示在一起，从而提高了局部性。</target>
        </trans-unit>
        <trans-unit id="bdc71e7bb730a8ac55c634493d73dbda68f4ce5e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;hot&lt;/code&gt; attribute on a label is used to inform the compiler that the path following the label is more likely than paths that are not so annotated. This attribute is used in cases where &lt;code&gt;__builtin_expect&lt;/code&gt; cannot be used, for instance with computed goto or &lt;code&gt;asm goto&lt;/code&gt;.</source>
          <target state="translated">标签上的 &lt;code&gt;hot&lt;/code&gt; 属性用于通知编译器，标签后的路径比未注释的路径更有可能。在无法使用 &lt;code&gt;__builtin_expect&lt;/code&gt; 的情况下（例如，对于计算出的goto或 &lt;code&gt;asm goto&lt;/code&gt; )，可以使用此属性。</target>
        </trans-unit>
        <trans-unit id="f61dd8421805c3f1f1761646164b13228bc83b34" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;if-exists-else&lt;/code&gt; spec function is similar to the &lt;code&gt;if-exists&lt;/code&gt; spec function, except that it takes two arguments. The first argument is an absolute pathname to a file. If the file exists, &lt;code&gt;if-exists-else&lt;/code&gt; returns the pathname. If it does not exist, it returns the second argument. This way, &lt;code&gt;if-exists-else&lt;/code&gt; can be used to select one file or another, based on the existence of the first. Here is a small example of its usage:</source>
          <target state="translated">在 &lt;code&gt;if-exists-else&lt;/code&gt; 规格功能类似于 &lt;code&gt;if-exists&lt;/code&gt; 规范功能，但它有两个参数。第一个参数是文件的绝对路径名。如果文件存在， &lt;code&gt;if-exists-else&lt;/code&gt; 返回路径名。如果不存在，则返回第二个参数。这样， &lt;code&gt;if-exists-else&lt;/code&gt; 可以用于根据一个文件的存在来选择一个文件或另一个文件。这是其用法的一个小例子：</target>
        </trans-unit>
        <trans-unit id="ca2fcf31ed2dc4dabd85a0634ae9ce4991a720f4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;if-exists&lt;/code&gt; spec function takes one argument, an absolute pathname to a file. If the file exists, &lt;code&gt;if-exists&lt;/code&gt; returns the pathname. Here is a small example of its usage:</source>
          <target state="translated">在 &lt;code&gt;if-exists&lt;/code&gt; 规范函数有一个参数，绝对路径名的文件。如果文件存在， &lt;code&gt;if-exists&lt;/code&gt; 返回路径名。这是其用法的一个小例子：</target>
        </trans-unit>
        <trans-unit id="2f39b443650f9aa0609294fd86fb2e3c92efa3ec" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ifunc&lt;/code&gt; attribute is used to mark a function as an indirect function using the STT_GNU_IFUNC symbol type extension to the ELF standard. This allows the resolution of the symbol value to be determined dynamically at load time, and an optimized version of the routine to be selected for the particular processor or other system characteristics determined then. To use this attribute, first define the implementation functions available, and a resolver function that returns a pointer to the selected implementation function. The implementation functions&amp;rsquo; declarations must match the API of the function being implemented. The resolver should be declared to be a function taking no arguments and returning a pointer to a function of the same type as the implementation. For example:</source>
          <target state="translated">所述 &lt;code&gt;ifunc&lt;/code&gt; 属性用于标记一个函数作为使用STT_GNU_IFUNC符号类型扩展，ELF标准的间接功能。这允许在加载时动态确定符号值的分辨率，并为特定处理器或随后确定的其他系统特性选择例程的优化版本。要使用此属性，首先定义可用的实现功能，以及一个解析器功能，该功能返回指向所选实现功能的指针。实现函数的声明必须与要实现的函数的API相匹配。应该将解析器声明为不带参数的函数，并返回指向与实现类型相同的函数的指针。例如：</target>
        </trans-unit>
        <trans-unit id="c93b19f3af6a498a18dbae7f15fda07496789c8c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;indirect_return&lt;/code&gt; attribute can be applied to a function, as well as variable or type of function pointer to inform the compiler that the function may return via indirect branch.</source>
          <target state="translated">所述 &lt;code&gt;indirect_return&lt;/code&gt; 属性可以被应用于一个函数，以及变量或函数指针的类型通知编译器该功能可以经由间接分支返回。</target>
        </trans-unit>
        <trans-unit id="f9d323a0cf85010c427cc0692ec1f74e288bfb70" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;int&lt;/code&gt; type specifies the &lt;em&gt;base type&lt;/em&gt;, while the attribute specifies the vector size for the variable, measured in bytes. For example, the declaration above causes the compiler to set the mode for the &lt;code&gt;v4si&lt;/code&gt; type to be 16 bytes wide and divided into &lt;code&gt;int&lt;/code&gt; sized units. For a 32-bit &lt;code&gt;int&lt;/code&gt; this means a vector of 4 units of 4 bytes, and the corresponding mode of &lt;code&gt;foo&lt;/code&gt; is V4SI.</source>
          <target state="translated">的 &lt;code&gt;int&lt;/code&gt; 类型指定&lt;em&gt;基类型&lt;/em&gt;，而属性指定为变量的矢量的大小，以字节为单位。例如，上面的声明使编译器将 &lt;code&gt;v4si&lt;/code&gt; 类型的模式设置为16字节宽，并分成 &lt;code&gt;int&lt;/code&gt; 大小的单位。对于32位 &lt;code&gt;int&lt;/code&gt; ,这意味着4个4字节单位的向量，并且 &lt;code&gt;foo&lt;/code&gt; 的对应模式为V4SI。</target>
        </trans-unit>
        <trans-unit id="2ad85eea7d52841e376253f17a96317ee40b42d4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;lo&lt;/code&gt; register. Use this register to store values that are no bigger than a word.</source>
          <target state="translated">该 &lt;code&gt;lo&lt;/code&gt; 寄存器。使用该寄存器存储不超过一个字的值。</target>
        </trans-unit>
        <trans-unit id="d59f696ee7163d6ae5bf39bf73c4a8eee9fb142c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;longcall&lt;/code&gt; attribute indicates that the function might be far away from the call site and require a different (more expensive) calling sequence. The &lt;code&gt;shortcall&lt;/code&gt; attribute indicates that the function is always close enough for the shorter calling sequence to be used. These attributes override both the</source>
          <target state="translated">该 &lt;code&gt;longcall&lt;/code&gt; 属性表示该功能可能会远离调用点，需要不同的（更贵）调用序列。该 &lt;code&gt;shortcall&lt;/code&gt; 属性表示该功能总是接近足够使用的短调用序列。这些属性会覆盖</target>
        </trans-unit>
        <trans-unit id="fcca42c392befdcaa88d2e6501ea9388ada93b12" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;longcall&lt;/code&gt; attribute indicates that the function might be far away from the call site and require a different (more expensive) calling sequence. The &lt;code&gt;shortcall&lt;/code&gt; attribute indicates that the function is always close enough for the shorter calling sequence to be used. These attributes override the</source>
          <target state="translated">该 &lt;code&gt;longcall&lt;/code&gt; 属性表示该功能可能会远离调用点，需要不同的（更贵）调用序列。该 &lt;code&gt;shortcall&lt;/code&gt; 属性表示该功能总是接近足够使用的短调用序列。这些属性覆盖</target>
        </trans-unit>
        <trans-unit id="dc876d3a5eef5293c3403c1a8361253a45afc935" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;movf&lt;/code&gt; functions are similar but use &lt;code&gt;movf.ps&lt;/code&gt; instead of &lt;code&gt;movt.ps&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;movf&lt;/code&gt; 功能相似，但使用 &lt;code&gt;movf.ps&lt;/code&gt; 代替 &lt;code&gt;movt.ps&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7edfc9a06b3d4812f5bd4584647b1d884b0e5206" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;movt&lt;/code&gt; functions return the value &lt;var&gt;x&lt;/var&gt; computed by:</source>
          <target state="translated">所述 &lt;code&gt;movt&lt;/code&gt; 函数返回值 &lt;var&gt;x&lt;/var&gt; 计算由：</target>
        </trans-unit>
        <trans-unit id="2610b35bdca1d94154ca3ae8683caf9dc99891a8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;mutationsPtr&lt;/code&gt; field of the &lt;code&gt;NSFastEnumerationState&lt;/code&gt; is used to keep track of mutations. It should point to a number; before working on each object, the fast enumeration loop will check that this number has not changed. If it has, a mutation has happened and the fast enumeration will abort. So, &lt;code&gt;mutationsPtr&lt;/code&gt; could be set to point to some sort of version number of your collection, which is increased by one every time there is a change (for example when an object is added or removed). Or, if you are content with less strict mutation checks, it could point to the number of objects in your collection or some other value that can be checked to perform an approximate check that the collection has not been mutated.</source>
          <target state="translated">&lt;code&gt;NSFastEnumerationState&lt;/code&gt; 的 &lt;code&gt;mutationsPtr&lt;/code&gt; 字段用于跟踪突变。它应该指向一个数字；在处理每个对象之前，快速枚举循环将检查该数字是否保持不变。如果已存在，则发生了突变，并且快速枚举将中止。因此， &lt;code&gt;mutationsPtr&lt;/code&gt; 可以设置为指向您集合的某种版本号，每次更改时该版本号都会增加一个（例如，添加或删除对象时）。或者，如果您对突变检查的要求不高，则它可能指向集合中对象的数量或可以检查以对集合未进行突变进行近似检查的其他一些值。</target>
        </trans-unit>
        <trans-unit id="eba0a2fef84c6754af39561a4cc5765385e357d6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;no_profile_instrument_function&lt;/code&gt; attribute on functions is used to inform the compiler that it should not process any profile feedback based optimization code instrumentation.</source>
          <target state="translated">函数上的 &lt;code&gt;no_profile_instrument_function&lt;/code&gt; 属性用于通知编译器它不应处理任何基于配置文件反馈的优化代码工具。</target>
        </trans-unit>
        <trans-unit id="0918428dc764c04c359b85f748a679bc412726a0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;no_sanitize&lt;/code&gt; attribute on functions is used to inform the compiler that it should not do sanitization of all options mentioned in &lt;var&gt;sanitize_option&lt;/var&gt;. A list of values acceptable by</source>
          <target state="translated">函数上的 &lt;code&gt;no_sanitize&lt;/code&gt; 属性用于通知编译器，它不应对 &lt;var&gt;sanitize_option&lt;/var&gt; 中提到的所有选项进行清理。可接受的值列表</target>
        </trans-unit>
        <trans-unit id="9e7127aec5521f1afa980b41ce3dbea36752798e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;no_sanitize&lt;/code&gt; attribute on functions is used to inform the compiler that it should not do sanitization of any option mentioned in &lt;var&gt;sanitize_option&lt;/var&gt;. A list of values acceptable by the</source>
          <target state="translated">函数上的 &lt;code&gt;no_sanitize&lt;/code&gt; 属性用于通知编译器，它不应对 &lt;var&gt;sanitize_option&lt;/var&gt; 中提到的任何选项进行清理。可接受的值列表</target>
        </trans-unit>
        <trans-unit id="598d3a3720c7288dc59d302cd06d4d62ac827b23" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;no_sanitize_address&lt;/code&gt; attribute on functions is used to inform the compiler that it should not instrument memory accesses in the function when compiling with the</source>
          <target state="translated">函数上的 &lt;code&gt;no_sanitize_address&lt;/code&gt; 属性用于通知编译器，当使用</target>
        </trans-unit>
        <trans-unit id="b0f00909d80fd99a1bd86005010002c8eae19649" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;no_sanitize_thread&lt;/code&gt; attribute on functions is used to inform the compiler that it should not instrument memory accesses in the function when compiling with the</source>
          <target state="translated">函数的 &lt;code&gt;no_sanitize_thread&lt;/code&gt; 属性用于通知编译器，当使用.NET进行编译时，不应在函数中检测内存访问。</target>
        </trans-unit>
        <trans-unit id="7a12b0e3b686d055271b195be15ed20337782164" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;no_sanitize_undefined&lt;/code&gt; attribute on functions is used to inform the compiler that it should not check for undefined behavior in the function when compiling with the</source>
          <target state="translated">函数上的 &lt;code&gt;no_sanitize_undefined&lt;/code&gt; 属性用于通知编译器，当使用.NET进行编译时，不应检查函数中未定义的行为。</target>
        </trans-unit>
        <trans-unit id="fc8d4f077478dc90f16e53c6d13ee06401059297" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;nocf_check&lt;/code&gt; attribute is applied to an object&amp;rsquo;s type. In case of assignment of a function address or a function pointer to another pointer, the attribute is not carried over from the right-hand object&amp;rsquo;s type; the type of left-hand object stays unchanged. The compiler checks for &lt;code&gt;nocf_check&lt;/code&gt; attribute mismatch and reports a warning in case of mismatch.</source>
          <target state="translated">所述 &lt;code&gt;nocf_check&lt;/code&gt; 属性应用于一个对象的类型。如果将一个函数地址或一个函数指针分配给另一个指针，则该属性不会从右侧对象的类型继承。左侧对象的类型保持不变。编译器检查 &lt;code&gt;nocf_check&lt;/code&gt; 属性是否不匹配，并在不匹配的情况下报告警告。</target>
        </trans-unit>
        <trans-unit id="037064bc2bccfb10212ace859111994bc55ff79f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;nocf_check&lt;/code&gt; attribute on a function is used to inform the compiler that the function&amp;rsquo;s prologue should not be instrumented when compiled with the</source>
          <target state="translated">函数的 &lt;code&gt;nocf_check&lt;/code&gt; 属性用于通知编译器，当使用</target>
        </trans-unit>
        <trans-unit id="59968503e9385085cb3eaa290a16cdafff616101" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;nocf_check&lt;/code&gt; attribute on a type of pointer to function is used to inform the compiler that a call through the pointer should not be instrumented when compiled with the</source>
          <target state="translated">函数指针类型上的 &lt;code&gt;nocf_check&lt;/code&gt; 属性用于通知编译器，当使用</target>
        </trans-unit>
        <trans-unit id="814b4e15c6c880738e37bebfa650ba3630bcdb26" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;nonnull&lt;/code&gt; attribute may be applied to a function that takes at least one argument of a pointer type. It indicates that the referenced arguments must be non-null pointers. For instance, the declaration:</source>
          <target state="translated">可以将 &lt;code&gt;nonnull&lt;/code&gt; 属性应用于采用至少一个指针类型参数的函数。它指示引用的参数必须是非空指针。例如，声明：</target>
        </trans-unit>
        <trans-unit id="390c2fb36f2ab88e24c7fbba27c3b067ccacf7b5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;nonstring&lt;/code&gt; variable attribute specifies that an object or member declaration with type array of &lt;code&gt;char&lt;/code&gt;, &lt;code&gt;signed char&lt;/code&gt;, or &lt;code&gt;unsigned char&lt;/code&gt;, or pointer to such a type is intended to store character arrays that do not necessarily contain a terminating &lt;code&gt;NUL&lt;/code&gt;. This is useful in detecting uses of such arrays or pointers with functions that expect &lt;code&gt;NUL&lt;/code&gt;-terminated strings, and to avoid warnings when such an array or pointer is used as an argument to a bounded string manipulation function such as &lt;code&gt;strncpy&lt;/code&gt;. For example, without the attribute, GCC will issue a warning for the &lt;code&gt;strncpy&lt;/code&gt; call below because it may truncate the copy without appending the terminating &lt;code&gt;NUL&lt;/code&gt; character. Using the attribute makes it possible to suppress the warning. However, when the array is declared with the attribute the call to &lt;code&gt;strlen&lt;/code&gt; is diagnosed because when the array doesn&amp;rsquo;t contain a &lt;code&gt;NUL&lt;/code&gt;-terminated string the call is undefined. To copy, compare, of search non-string character arrays use the &lt;code&gt;memcpy&lt;/code&gt;, &lt;code&gt;memcmp&lt;/code&gt;, &lt;code&gt;memchr&lt;/code&gt;, and other functions that operate on arrays of bytes. In addition, calling &lt;code&gt;strnlen&lt;/code&gt; and &lt;code&gt;strndup&lt;/code&gt; with such arrays is safe provided a suitable bound is specified, and not diagnosed.</source>
          <target state="translated">所述 &lt;code&gt;nonstring&lt;/code&gt; 变量属性指定与类型数组的对象或成员声明 &lt;code&gt;char&lt;/code&gt; ， &lt;code&gt;signed char&lt;/code&gt; ，或 &lt;code&gt;unsigned char&lt;/code&gt; ，或指针这样的类型意欲不一定包含终止存储字符阵列 &lt;code&gt;NUL&lt;/code&gt; 。这对于检测此类数组或指针与期望以 &lt;code&gt;NUL&lt;/code&gt; 终止的字符串的函数的使用非常有用，并且在将此类数组或指针用作有界字符串操作函数（例如 &lt;code&gt;strncpy&lt;/code&gt; )的参数时避免发出警告。例如，如果没有该属性，GCC将为 &lt;code&gt;strncpy&lt;/code&gt; 发出警告请致电以下，因为它可能会截断副本而不会附加终止 &lt;code&gt;NUL&lt;/code&gt; 字符。使用该属性可以抑制警告。但是，使用属性声明数组时，将诊断对 &lt;code&gt;strlen&lt;/code&gt; 的调用，因为当数组不包含以 &lt;code&gt;NUL&lt;/code&gt; 终止的字符串时，该调用是不确定的。要复制，比较搜索非字符串字符数组，请使用 &lt;code&gt;memcpy&lt;/code&gt; ， &lt;code&gt;memcmp&lt;/code&gt; ， &lt;code&gt;memchr&lt;/code&gt; 和其他对字节数组进行操作的函数。此外，如果指定了适当的绑定并且未对其进行诊断，则使用此类数组调用 &lt;code&gt;strnlen&lt;/code&gt; 和 &lt;code&gt;strndup&lt;/code&gt; 是安全的。</target>
        </trans-unit>
        <trans-unit id="bfce49165a44d874594bfffebd1dbb2dbd0c7094" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;noplt&lt;/code&gt; attribute is the counterpart to option</source>
          <target state="translated">该 &lt;code&gt;noplt&lt;/code&gt; 属性是对口选项</target>
        </trans-unit>
        <trans-unit id="0300bf5cb9eee09bcd3c5b59946b4122f915396c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;noplt&lt;/code&gt; attribute on function &lt;code&gt;foo&lt;/code&gt; tells the compiler to assume that the function &lt;code&gt;foo&lt;/code&gt; is externally defined and that the call to &lt;code&gt;foo&lt;/code&gt; must avoid the PLT in position-independent code.</source>
          <target state="translated">函数 &lt;code&gt;foo&lt;/code&gt; 的 &lt;code&gt;noplt&lt;/code&gt; 属性告诉编译器假定函数 &lt;code&gt;foo&lt;/code&gt; 是在外部定义的，并且对 &lt;code&gt;foo&lt;/code&gt; 的调用必须避免位置无关代码中的PLT。</target>
        </trans-unit>
        <trans-unit id="3e2a9d3dba3dc91ebe5e03bbafab67f8838787f0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;noreturn&lt;/code&gt; keyword does not affect the exceptional path when that applies: a &lt;code&gt;noreturn&lt;/code&gt;-marked function may still return to the caller by throwing an exception or calling &lt;code&gt;longjmp&lt;/code&gt;.</source>
          <target state="translated">在 &lt;code&gt;noreturn&lt;/code&gt; 一个：时适用的关键字不影响特殊路径 &lt;code&gt;noreturn&lt;/code&gt; -marked功能仍然可以通过抛出异常或调用返回给调用者 &lt;code&gt;longjmp&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0ede64b6031c14f35d5f8cb3935b7f6f8ada1843" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;noreturn&lt;/code&gt; keyword tells the compiler to assume that &lt;code&gt;fatal&lt;/code&gt; cannot return. It can then optimize without regard to what would happen if &lt;code&gt;fatal&lt;/code&gt; ever did return. This makes slightly better code. More importantly, it helps avoid spurious warnings of uninitialized variables.</source>
          <target state="translated">在 &lt;code&gt;noreturn&lt;/code&gt; 关键字告诉编译器假定 &lt;code&gt;fatal&lt;/code&gt; 不能返回。然后，它可以进行优化，而不必考虑如果 &lt;code&gt;fatal&lt;/code&gt; 事件再次发生会发生什么情况。这使代码更好一些。更重要的是，它有助于避免对未初始化变量的虚假警告。</target>
        </trans-unit>
        <trans-unit id="322a4c52099d05e4a78d3c92d5bcf0059fa4fd77" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;nothrow&lt;/code&gt; attribute is used to inform the compiler that a function cannot throw an exception. For example, most functions in the standard C library can be guaranteed not to throw an exception with the notable exceptions of &lt;code&gt;qsort&lt;/code&gt; and &lt;code&gt;bsearch&lt;/code&gt; that take function pointer arguments.</source>
          <target state="translated">在 &lt;code&gt;nothrow&lt;/code&gt; 属性用来告诉编译器，一个函数不能抛出异常。例如，可以保证标准C库中的大多数函数都不会抛出异常，而带有函数指针参数的 &lt;code&gt;qsort&lt;/code&gt; 和 &lt;code&gt;bsearch&lt;/code&gt; 异常例外。</target>
        </trans-unit>
        <trans-unit id="207d7791a2ec8b451439c9235cbe7bcf5c27be6d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;optimize&lt;/code&gt; attribute is used to specify that a function is to be compiled with different optimization options than specified on the command line. Valid arguments are constant non-negative integers and strings. Each numeric argument specifies an optimization &lt;var&gt;level&lt;/var&gt;. Each &lt;var&gt;string&lt;/var&gt; argument consists of one or more comma-separated substrings. Each substring that begins with the letter &lt;code&gt;O&lt;/code&gt; refers to an optimization option such as</source>
          <target state="translated">最 &lt;code&gt;optimize&lt;/code&gt; 属性用于指定要使用与命令行上指定的优化选项不同的优化选项来编译功能。有效参数是常量非负整数和字符串。每个数字参数指定一个优化 &lt;var&gt;level&lt;/var&gt; 。每个 &lt;var&gt;string&lt;/var&gt; 参数均包含一个或多个逗号分隔的子字符串。以字母 &lt;code&gt;O&lt;/code&gt; 开头的每个子字符串均指一个优化选项，例如</target>
        </trans-unit>
        <trans-unit id="826d9e0c3c8b85ab7196ae31fb079d73a80bdae9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;packed&lt;/code&gt; attribute specifies that a structure member should have the smallest possible alignment&amp;mdash;one bit for a bit-field and one byte otherwise, unless a larger value is specified with the &lt;code&gt;aligned&lt;/code&gt; attribute. The attribute does not apply to non-member objects.</source>
          <target state="translated">所述 &lt;code&gt;packed&lt;/code&gt; 属性指定的结构构件应具有一个比特字段中的最小的可能取向的一个比特和一个字节否则，除非与指定的较大的值 &lt;code&gt;aligned&lt;/code&gt; 属性。该属性不适用于非成员对象。</target>
        </trans-unit>
        <trans-unit id="39beb9f00633eee839c4a2a5158a15d6e464e28e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pass-through-libs&lt;/code&gt; spec function takes any number of arguments. It finds any</source>
          <target state="translated">该 &lt;code&gt;pass-through-libs&lt;/code&gt; 规范函数可以用任何数量的参数。它发现任何</target>
        </trans-unit>
        <trans-unit id="89c9a7db255ec3b8e7cca6652c90ae20f65b9a86" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;patchable_function_entry&lt;/code&gt; function attribute can be used to change the number of NOPs to any desired value. The two-value syntax is the same as for the command-line switch</source>
          <target state="translated">所述 &lt;code&gt;patchable_function_entry&lt;/code&gt; 功能属性可以被用来NOP的数目改变到任何希望的值。二值语法与命令行开关的语法相同</target>
        </trans-unit>
        <trans-unit id="e838ae744489fc704636367520fe3b637d47e7f1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pcs&lt;/code&gt; attribute can be used to control the calling convention used for a function on ARM. The attribute takes an argument that specifies the calling convention to use.</source>
          <target state="translated">该 &lt;code&gt;pcs&lt;/code&gt; 属性可以用来控制用于ARM上的函数调用约定。该属性采用一个参数，该参数指定要使用的调用约定。</target>
        </trans-unit>
        <trans-unit id="bbf4d6b72a577c7b95004980e1bce0048594d8dd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;print-asm-header&lt;/code&gt; function takes no arguments and simply prints a banner like:</source>
          <target state="translated">在 &lt;code&gt;print-asm-header&lt;/code&gt; 功能没有参数，只是打印的一面旗帜，如：</target>
        </trans-unit>
        <trans-unit id="cb4fc17c6269a43f696bb9bef92ec98733094225" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pure&lt;/code&gt; attribute imposes similar but looser restrictions on a function&amp;rsquo;s definition than the &lt;code&gt;const&lt;/code&gt; attribute: &lt;code&gt;pure&lt;/code&gt; allows the function to read any non-volatile memory, even if it changes in between successive invocations of the function. Declaring the same function with both the &lt;code&gt;pure&lt;/code&gt; and the &lt;code&gt;const&lt;/code&gt; attribute is diagnosed. Because a pure function cannot have any observable side effects it does not make sense for such a function to return &lt;code&gt;void&lt;/code&gt;. Declaring such a function is diagnosed.</source>
          <target state="translated">该 &lt;code&gt;pure&lt;/code&gt; 属性规定了比一个函数的定义类似，但宽松的限制 &lt;code&gt;const&lt;/code&gt; 属性： &lt;code&gt;pure&lt;/code&gt; 允许函数读取任何非易失性存储器，即使在函数的连续调用之间变化。诊断使用 &lt;code&gt;pure&lt;/code&gt; 和 &lt;code&gt;const&lt;/code&gt; 属性声明相同的功能。由于纯函数不能具有任何可观察到的副作用，因此使此类函数返回 &lt;code&gt;void&lt;/code&gt; 没有意义。诊断出声明了这样的功能。</target>
        </trans-unit>
        <trans-unit id="323eb04f8039811b3bb58c82bccb097f2a6f7bce" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pure&lt;/code&gt; attribute prohibits a function from modifying the state of the program that is observable by means other than inspecting the function&amp;rsquo;s return value. However, functions declared with the &lt;code&gt;pure&lt;/code&gt; attribute can safely read any non-volatile objects, and modify the value of objects in a way that does not affect their return value or the observable state of the program.</source>
          <target state="translated">所述 &lt;code&gt;pure&lt;/code&gt; 属性从修改是由比检查函数的返回值其它手段观察到的所述程序的状态禁止的功能。但是，使用 &lt;code&gt;pure&lt;/code&gt; 属性声明的函数可以安全地读取任何非易失性对象，并以不影响其返回值或程序可观察状态的方式修改对象的值。</target>
        </trans-unit>
        <trans-unit id="24119821985c46d89b11400454926b0593b3b50d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;read_only&lt;/code&gt; access mode specifies that the pointer to which it applies is used to read the referenced object but not write to it. Unless the argument specifying the size of the access denoted by &lt;var&gt;size-index&lt;/var&gt; is zero, the referenced object must be initialized. The mode implies a stronger guarantee than the &lt;code&gt;const&lt;/code&gt; qualifier which, when cast away from a pointer, does not prevent the pointed-to object from being modified. Examples of the use of the &lt;code&gt;read_only&lt;/code&gt; access mode is the argument to the &lt;code&gt;puts&lt;/code&gt; function, or the second and third arguments to the &lt;code&gt;memcpy&lt;/code&gt; function.</source>
          <target state="translated">所述 &lt;code&gt;read_only&lt;/code&gt; 存取模式指定其所适用的指针用于读取被引用的对象但不写入。除非用 &lt;var&gt;size-index&lt;/var&gt; 表示指定访问大小的参数为零，否则必须初始化被引用的对象。该模式比 &lt;code&gt;const&lt;/code&gt; 限定符具有更强的保证力，而const限定符在抛弃指针时不会阻止指向的对象被修改。使用 &lt;code&gt;read_only&lt;/code&gt; 访问模式的示例是 &lt;code&gt;puts&lt;/code&gt; 函数的参数，或者 &lt;code&gt;memcpy&lt;/code&gt; 函数的第二个和第三个参数。</target>
        </trans-unit>
        <trans-unit id="88a3f3d3b23da8341683a81df31a980b08cf319c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;read_write&lt;/code&gt; access mode applies to arguments of pointer types without the &lt;code&gt;const&lt;/code&gt; qualifier. It specifies that the pointer to which it applies is used to both read and write the referenced object. Unless the argument specifying the size of the access denoted by &lt;var&gt;size-index&lt;/var&gt; is zero, the object referenced by the pointer must be initialized. An example of the use of the &lt;code&gt;read_write&lt;/code&gt; access mode is the first argument to the &lt;code&gt;strcat&lt;/code&gt; function.</source>
          <target state="translated">该 &lt;code&gt;read_write&lt;/code&gt; 访问模式适用于指针类型的参数，而不 &lt;code&gt;const&lt;/code&gt; 限定符。它指定将其应用于的指针用于读取和写入引用的对象。除非用 &lt;var&gt;size-index&lt;/var&gt; 表示指定访问大小的参数为零，否则必须初始化指针引用的对象。使用 &lt;code&gt;read_write&lt;/code&gt; 访问模式的一个示例是 &lt;code&gt;strcat&lt;/code&gt; 函数的第一个参数。</target>
        </trans-unit>
        <trans-unit id="1720331b79d485f642342587a0a4961224f570c6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;register&lt;/code&gt; specifier affects code generation only in these ways:</source>
          <target state="translated">该 &lt;code&gt;register&lt;/code&gt; 说明符只影响在这些方面的代码生成：</target>
        </trans-unit>
        <trans-unit id="a5258162416b278a0bfac9c4c7558d341c9154f5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;remove-outfile&lt;/code&gt; spec function takes one argument. It looks for the first argument in the outfiles array and removes it. Here is a small example its usage:</source>
          <target state="translated">在 &lt;code&gt;remove-outfile&lt;/code&gt; 规范函数有一个参数。它在outfiles数组中查找第一个参数并将其删除。这是其用法的一个小示例：</target>
        </trans-unit>
        <trans-unit id="55bb4e8d3fe19956428bf774ea204bd862418b82" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;replace-outfile&lt;/code&gt; spec function takes two arguments. It looks for the first argument in the outfiles array and replaces it with the second argument. Here is a small example of its usage:</source>
          <target state="translated">在 &lt;code&gt;replace-outfile&lt;/code&gt; 规范函数有两个参数。它在outfiles数组中查找第一个参数，并将其替换为第二个参数。这是其用法的一个小例子：</target>
        </trans-unit>
        <trans-unit id="9408f2030b23dd54137985158e8c003e073220be" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;returns_nonnull&lt;/code&gt; attribute specifies that the function return value should be a non-null pointer. For instance, the declaration:</source>
          <target state="translated">该 &lt;code&gt;returns_nonnull&lt;/code&gt; 属性指定函数的返回值应该是一个非空指针。例如，声明：</target>
        </trans-unit>
        <trans-unit id="3e04bc9de35eb5e502accce1b00b75bbadd857dc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;returns_twice&lt;/code&gt; attribute tells the compiler that a function may return more than one time. The compiler ensures that all registers are dead before calling such a function and emits a warning about the variables that may be clobbered after the second return from the function. Examples of such functions are &lt;code&gt;setjmp&lt;/code&gt; and &lt;code&gt;vfork&lt;/code&gt;. The &lt;code&gt;longjmp&lt;/code&gt;-like counterpart of such function, if any, might need to be marked with the &lt;code&gt;noreturn&lt;/code&gt; attribute.</source>
          <target state="translated">该 &lt;code&gt;returns_twice&lt;/code&gt; 属性告诉编译器，函数可能会返回一个以上的时间。编译器确保在调用该函数之前所有寄存器均已失效，并发出有关该函数第二次返回后可能被破坏的变量的警告。此类功能的示例是 &lt;code&gt;setjmp&lt;/code&gt; 和 &lt;code&gt;vfork&lt;/code&gt; 。此类函数的类似 &lt;code&gt;longjmp&lt;/code&gt; 的对应项（如果有）可能需要用 &lt;code&gt;noreturn&lt;/code&gt; 属性标记。</target>
        </trans-unit>
        <trans-unit id="d109540c91de909173d68023125715d31c5696c6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;rtd&lt;/code&gt; instruction is supported by the 68010, 68020, 68030, 68040, 68060 and CPU32 processors, but not by the 68000 or 5200.</source>
          <target state="translated">该 &lt;code&gt;rtd&lt;/code&gt; 指令由68010，68020，68030，68040，68060和CPU32处理器的支持，而不是由68000或5200。</target>
        </trans-unit>
        <trans-unit id="d6a97b87fbba98b99c49488ce8d99f3965e9820d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;scalar_cmp_exp_gt&lt;/code&gt;, &lt;code&gt;scalar_cmp_exp_lt&lt;/code&gt;, &lt;code&gt;scalar_cmp_exp_eq&lt;/code&gt;, and &lt;code&gt;scalar_cmp_exp_unordered&lt;/code&gt; built-in functions return a non-zero value if &lt;code&gt;arg1&lt;/code&gt; is greater than, less than, equal to, or not comparable to &lt;code&gt;arg2&lt;/code&gt; respectively. The arguments are not comparable if one or the other equals NaN (not a number).</source>
          <target state="translated">的 &lt;code&gt;scalar_cmp_exp_gt&lt;/code&gt; ， &lt;code&gt;scalar_cmp_exp_lt&lt;/code&gt; ， &lt;code&gt;scalar_cmp_exp_eq&lt;/code&gt; ，和 &lt;code&gt;scalar_cmp_exp_unordered&lt;/code&gt; 内置函数返回一个非零值，如果 &lt;code&gt;arg1&lt;/code&gt; 大于，小于，等于，或无法相比的 &lt;code&gt;arg2&lt;/code&gt; 的分别。如果一个或另一个等于NaN（不是数字），则参数不可比较。</target>
        </trans-unit>
        <trans-unit id="8ed56e8dd6f8e41dde6e37a24332591f1ce27f7a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;scalar_extract_exp&lt;/code&gt; and &lt;code&gt;scalar_extract_sig&lt;/code&gt; functions require a 64-bit environment supporting ISA 3.0 or later. The &lt;code&gt;scalar_extract_exp&lt;/code&gt; and &lt;code&gt;scalar_extract_sig&lt;/code&gt; built-in functions return the significand and the biased exponent value respectively of their &lt;code&gt;source&lt;/code&gt; arguments. When supplied with a 64-bit &lt;code&gt;source&lt;/code&gt; argument, the result returned by &lt;code&gt;scalar_extract_sig&lt;/code&gt; has the &lt;code&gt;0x0010000000000000&lt;/code&gt; bit set if the function&amp;rsquo;s &lt;code&gt;source&lt;/code&gt; argument is in normalized form. Otherwise, this bit is set to 0. When supplied with a 128-bit &lt;code&gt;source&lt;/code&gt; argument, the &lt;code&gt;0x00010000000000000000000000000000&lt;/code&gt; bit of the result is treated similarly. Note that the sign of the significand is not represented in the result returned from the &lt;code&gt;scalar_extract_sig&lt;/code&gt; function. Use the &lt;code&gt;scalar_test_neg&lt;/code&gt; function to test the sign of its &lt;code&gt;double&lt;/code&gt; argument.</source>
          <target state="translated">的 &lt;code&gt;scalar_extract_exp&lt;/code&gt; 和 &lt;code&gt;scalar_extract_sig&lt;/code&gt; 功能需要一个64位的环境中支持ISA 3.0或更高版本。该 &lt;code&gt;scalar_extract_exp&lt;/code&gt; 和 &lt;code&gt;scalar_extract_sig&lt;/code&gt; 内置函数分别返回自己的尾数和偏置指数值 &lt;code&gt;source&lt;/code&gt; 的参数。当提供64位 &lt;code&gt;source&lt;/code&gt; 参数时，如果函数的 &lt;code&gt;source&lt;/code&gt; 参数采用规范化形式，则 &lt;code&gt;scalar_extract_sig&lt;/code&gt; 返回的结果将设置为 &lt;code&gt;0x0010000000000000&lt;/code&gt; 。否则，此位设置为0。提供128位 &lt;code&gt;source&lt;/code&gt; 参数时，为 &lt;code&gt;0x00010000000000000000000000000000&lt;/code&gt; 000000结果的一点也被类似地对待。请注意，在 &lt;code&gt;scalar_extract_sig&lt;/code&gt; 函数返回的结果中未显示有效数的符号。使用 &lt;code&gt;scalar_test_neg&lt;/code&gt; 函数测试其 &lt;code&gt;double&lt;/code&gt; 参数的符号。</target>
        </trans-unit>
        <trans-unit id="1f38aa375929331668f316b9a82c74ab6cc36489" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;scalar_extract_exp&lt;/code&gt; and &lt;code&gt;scalar_extract_sig&lt;/code&gt; functions require a 64-bit environment supporting ISA 3.0 or later. The &lt;code&gt;scalar_extract_exp&lt;/code&gt; and &lt;code&gt;scalar_extract_sig&lt;/code&gt; built-in functions return the significand and the biased exponent value respectively of their &lt;code&gt;source&lt;/code&gt; arguments. When supplied with a 64-bit &lt;code&gt;source&lt;/code&gt; argument, the result returned by &lt;code&gt;scalar_extract_sig&lt;/code&gt; has the &lt;code&gt;0x0010000000000000&lt;/code&gt; bit set if the function&amp;rsquo;s &lt;code&gt;source&lt;/code&gt; argument is in normalized form. Otherwise, this bit is set to 0. When supplied with a 128-bit &lt;code&gt;source&lt;/code&gt; argument, the &lt;code&gt;0x00010000000000000000000000000000&lt;/code&gt; bit of the result is treated similarly. Note that the sign of the significand is not represented in the result returned from the &lt;code&gt;scalar_extract_sig&lt;/code&gt; function. Use the &lt;code&gt;scalar_test_neg&lt;/code&gt; function to test the sign of its &lt;code&gt;double&lt;/code&gt; argument. The &lt;code&gt;vec_msum&lt;/code&gt; functions perform a vector multiply-sum, returning the result of arg1*arg2+arg3. ISA 3.0 adds support for vec_msum returning a vector int128 result.</source>
          <target state="translated">的 &lt;code&gt;scalar_extract_exp&lt;/code&gt; 和 &lt;code&gt;scalar_extract_sig&lt;/code&gt; 功能需要一个64位的环境中支持ISA 3.0或更高版本。该 &lt;code&gt;scalar_extract_exp&lt;/code&gt; 和 &lt;code&gt;scalar_extract_sig&lt;/code&gt; 内置函数分别返回自己的尾数和偏置指数值 &lt;code&gt;source&lt;/code&gt; 的参数。当提供64位 &lt;code&gt;source&lt;/code&gt; 参数时，如果函数的 &lt;code&gt;source&lt;/code&gt; 参数采用规范化形式，则 &lt;code&gt;scalar_extract_sig&lt;/code&gt; 返回的结果将设置为 &lt;code&gt;0x0010000000000000&lt;/code&gt; 。否则，此位设置为0。提供128位 &lt;code&gt;source&lt;/code&gt; 参数时，为 &lt;code&gt;0x00010000000000000000000000000000&lt;/code&gt; 000000结果的位被类似地对待。请注意，在 &lt;code&gt;scalar_extract_sig&lt;/code&gt; 函数返回的结果中未显示有效数的符号。使用 &lt;code&gt;scalar_test_neg&lt;/code&gt; 函数测试其 &lt;code&gt;double&lt;/code&gt; 参数的符号。所述 &lt;code&gt;vec_msum&lt;/code&gt; 功能执行矢量乘法-求和，返回ARG1 * ARG2 + ARG3的结果。 ISA 3.0增加了对vec_msum的支持，该向量返回矢量int128结果。</target>
        </trans-unit>
        <trans-unit id="a572c2c2b0d3df765ec4322dbf92c35c2e4cbc19" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;scalar_insert_exp&lt;/code&gt; functions require a 64-bit environment supporting ISA 3.0 or later. When supplied with a 64-bit first argument, the &lt;code&gt;scalar_insert_exp&lt;/code&gt; built-in function returns a double-precision floating point value that is constructed by assembling the values of its &lt;code&gt;significand&lt;/code&gt; and &lt;code&gt;exponent&lt;/code&gt; arguments. The sign of the result is copied from the most significant bit of the &lt;code&gt;significand&lt;/code&gt; argument. The significand and exponent components of the result are composed of the least significant 11 bits of the &lt;code&gt;exponent&lt;/code&gt; argument and the least significant 52 bits of the &lt;code&gt;significand&lt;/code&gt; argument respectively.</source>
          <target state="translated">所述 &lt;code&gt;scalar_insert_exp&lt;/code&gt; 函数需要一个64位的环境中支持ISA 3.0或更高版本。当提供了64位第一个参数时， &lt;code&gt;scalar_insert_exp&lt;/code&gt; 内置函数将返回一个双精度浮点值，该值是通过组合其 &lt;code&gt;significand&lt;/code&gt; 和 &lt;code&gt;exponent&lt;/code&gt; 参数的值而构造的。从 &lt;code&gt;significand&lt;/code&gt; 参数的最高有效位复制结果的符号。结果的有效数和指数部件由所述的至少显著11个比特的 &lt;code&gt;exponent&lt;/code&gt; 参数和所述的至少显著52位 &lt;code&gt;significand&lt;/code&gt; 分别论点。</target>
        </trans-unit>
        <trans-unit id="30e5f673754badb55457e9f6e18bad2fb7c8867f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;scalar_test_data_class&lt;/code&gt; built-in function returns 1 if any of the condition tests enabled by the value of the &lt;code&gt;condition&lt;/code&gt; variable are true, and 0 otherwise. The &lt;code&gt;condition&lt;/code&gt; argument must be a compile-time constant integer with value not exceeding 127. The &lt;code&gt;condition&lt;/code&gt; argument is encoded as a bitmask with each bit enabling the testing of a different condition, as characterized by the following:</source>
          <target state="translated">所述 &lt;code&gt;scalar_test_data_class&lt;/code&gt; 内置函数返回1，如果任何通过的值使能条件测试 &lt;code&gt;condition&lt;/code&gt; 变量为真，否则为0。的 &lt;code&gt;condition&lt;/code&gt; 参数必须是一个编译时间常数整数，值不超过127。 &lt;code&gt;condition&lt;/code&gt; 参数被编码为与每个位使一个不同的条件下的测试的位掩码，因为其特征在于通过以下：</target>
        </trans-unit>
        <trans-unit id="8baf3f4610726735a8a214eff212593a1cbf0b19" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;scalar_test_neg&lt;/code&gt; built-in function returns 1 if its &lt;code&gt;source&lt;/code&gt; argument holds a negative value, 0 otherwise.</source>
          <target state="translated">如果 &lt;code&gt;scalar_test_neg&lt;/code&gt; 内置函数的 &lt;code&gt;source&lt;/code&gt; 参数保持负值，则返回1 ，否则返回0。</target>
        </trans-unit>
        <trans-unit id="312b5b4b73e9b711ee72f43d70d664005613348e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;selectany&lt;/code&gt; attribute causes an initialized global variable to have link-once semantics. When multiple definitions of the variable are encountered by the linker, the first is selected and the remainder are discarded. Following usage by the Microsoft compiler, the linker is told &lt;em&gt;not&lt;/em&gt; to warn about size or content differences of the multiple definitions.</source>
          <target state="translated">该 &lt;code&gt;selectany&lt;/code&gt; 属性导致初始化的全局变量有联系一次语义。当链接器遇到变量的多个定义时，将选择第一个，其余的将被丢弃。在Microsoft编译器使用之后，告诉链接器&lt;em&gt;不要&lt;/em&gt;警告多个定义的大小或内容差异。</target>
        </trans-unit>
        <trans-unit id="7bbd5708df7b8ad51e26c82827c5a8837087e1d7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;selectany&lt;/code&gt; attribute is only available on Microsoft Windows targets. You can use &lt;code&gt;__declspec (selectany)&lt;/code&gt; as a synonym for &lt;code&gt;__attribute__ ((selectany))&lt;/code&gt; for compatibility with other compilers.</source>
          <target state="translated">该 &lt;code&gt;selectany&lt;/code&gt; 属性仅在Microsoft Windows目标可用。您可以使用 &lt;code&gt;__declspec (selectany)&lt;/code&gt; 作为 &lt;code&gt;__attribute__ ((selectany))&lt;/code&gt; 的同义词，以与其他编译器兼容。</target>
        </trans-unit>
        <trans-unit id="14873a7d123565ace388d75f6ab559389f994c52" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;shared&lt;/code&gt; attribute is only available on Microsoft Windows.</source>
          <target state="translated">该 &lt;code&gt;shared&lt;/code&gt; 属性仅在Microsoft Windows上使用。</target>
        </trans-unit>
        <trans-unit id="9085a2da6609ed3bc0fa42e0bccb84c58724a810" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;si&lt;/code&gt; register.</source>
          <target state="translated">该 &lt;code&gt;si&lt;/code&gt; 寄存器。</target>
        </trans-unit>
        <trans-unit id="5a2831e5752e0e20c3cf70a499fe35cbe998dc8c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;state&lt;/code&gt; and &lt;code&gt;extra&lt;/code&gt; fields of the &lt;code&gt;NSFastEnumerationState&lt;/code&gt; structure allows your collection object to keep track of the state of the enumeration. In a simple array implementation, &lt;code&gt;state&lt;/code&gt; may keep track of the index of the last object that was returned, and &lt;code&gt;extra&lt;/code&gt; may be unused.</source>
          <target state="translated">&lt;code&gt;NSFastEnumerationState&lt;/code&gt; 结构的 &lt;code&gt;state&lt;/code&gt; 和 &lt;code&gt;extra&lt;/code&gt; 字段使您的集合对象可以跟踪枚举的状态。在一个简单的数组实现中， &lt;code&gt;state&lt;/code&gt; 可以跟踪返回的最后一个对象的索引，并且可能未使用 &lt;code&gt;extra&lt;/code&gt; 对象。</target>
        </trans-unit>
        <trans-unit id="3c61038602bd0b5479d4058a6d4baafd6a0c2107" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;struct __htm_tdb&lt;/code&gt; defined in &lt;code&gt;htmintrin.h&lt;/code&gt; describes the structure of the transaction diagnostic block as specified in the Principles of Operation manual chapter 5-91.</source>
          <target state="translated">的 &lt;code&gt;struct __htm_tdb&lt;/code&gt; 中定义 &lt;code&gt;htmintrin.h&lt;/code&gt; 描述为在操作手册章5-91的原则指定的交易诊断块的结构。</target>
        </trans-unit>
        <trans-unit id="1669605966a6a01f0ff15b0d1cc0c388abd2971a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;target&lt;/code&gt; attribute can be used for instance to have a function compiled with a different ISA (instruction set architecture) than the default. &amp;lsquo;</source>
          <target state="translated">的 &lt;code&gt;target&lt;/code&gt; 属性可以用于例如以具有与不同的ISA（指令集架构）比默认编译的函数。'</target>
        </trans-unit>
        <trans-unit id="9c500ff15f72b79070a64c0e0436e7dcdc9aaf0d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;target_clones&lt;/code&gt; attribute is used to specify that a function be cloned into multiple versions compiled with different target options than specified on the command line. The supported options and restrictions are the same as for &lt;code&gt;target&lt;/code&gt; attribute.</source>
          <target state="translated">所述 &lt;code&gt;target_clones&lt;/code&gt; 属性用来指定一个函数被克隆到具有比命令行上指定不同的目标选项编译多个版本。支持的选项和限制与 &lt;code&gt;target&lt;/code&gt; 属性相同。</target>
        </trans-unit>
        <trans-unit id="ccf91998c7f416dcbd90db0b120c7a4f8d3b089f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;tls_model&lt;/code&gt; attribute sets thread-local storage model (see &lt;a href=&quot;thread_002dlocal#Thread_002dLocal&quot;&gt;Thread-Local&lt;/a&gt;) of a particular &lt;code&gt;__thread&lt;/code&gt; variable, overriding</source>
          <target state="translated">该 &lt;code&gt;tls_model&lt;/code&gt; 属性设置线程本地存储模式（参见&lt;a href=&quot;thread_002dlocal#Thread_002dLocal&quot;&gt;线程局部&lt;/a&gt;）特定的 &lt;code&gt;__thread&lt;/code&gt; 变量，覆盖</target>
        </trans-unit>
        <trans-unit id="2f43feeb5f6870d9594f888564bad52895276f45" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;vec_absd&lt;/code&gt;, &lt;code&gt;vec_absdb&lt;/code&gt;, &lt;code&gt;vec_absdh&lt;/code&gt;, and &lt;code&gt;vec_absdw&lt;/code&gt; built-in functions each computes the absolute differences of the pairs of vector elements supplied in its two vector arguments, placing the absolute differences into the corresponding elements of the vector result.</source>
          <target state="translated">的 &lt;code&gt;vec_absd&lt;/code&gt; ， &lt;code&gt;vec_absdb&lt;/code&gt; ， &lt;code&gt;vec_absdh&lt;/code&gt; ，和 &lt;code&gt;vec_absdw&lt;/code&gt; 内置函数每单位计算矢量元素的在它的两个向量的参数所提供的对，将所述绝对差到载体结果的对应的元素的绝对差。</target>
        </trans-unit>
        <trans-unit id="cc17321076f6146e9d0eff176ccfd2642bdf04e8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;vec_all_nez&lt;/code&gt;, &lt;code&gt;vec_any_eqz&lt;/code&gt;, and &lt;code&gt;vec_cmpnez&lt;/code&gt; perform pairwise comparisons between the elements at the same positions within their two vector arguments. The &lt;code&gt;vec_all_nez&lt;/code&gt; function returns a non-zero value if and only if all pairwise comparisons are not equal and no element of either vector argument contains a zero. The &lt;code&gt;vec_any_eqz&lt;/code&gt; function returns a non-zero value if and only if at least one pairwise comparison is equal or if at least one element of either vector argument contains a zero. The &lt;code&gt;vec_cmpnez&lt;/code&gt; function returns a vector of the same type as its two arguments, within which each element consists of all ones to denote that either the corresponding elements of the incoming arguments are not equal or that at least one of the corresponding elements contains zero. Otherwise, the element of the returned vector contains all zeros.</source>
          <target state="translated">的 &lt;code&gt;vec_all_nez&lt;/code&gt; ， &lt;code&gt;vec_any_eqz&lt;/code&gt; 和 &lt;code&gt;vec_cmpnez&lt;/code&gt; 执行在它们的两个矢量的参数内的相同位置中的元素之间的成对比较。当且仅当所有成对比较都不相等且两个向量自变量的任何元素都不包含零时， &lt;code&gt;vec_all_nez&lt;/code&gt; 函数才会返回非零值。所述 &lt;code&gt;vec_any_eqz&lt;/code&gt; 函数返回一个非零值当且仅当至少一个成对比较等于或如果任一向量参数中的至少一个元件包含一个零。该 &lt;code&gt;vec_cmpnez&lt;/code&gt; 函数返回与其两个参数相同类型的向量，其中每个元素都由全1组成，表示传入参数的对应元素不相等，或者至少一个对应元素包含零。否则，返回向量的元素包含全零。</target>
        </trans-unit>
        <trans-unit id="a9ea2035fded0002d7bb2f5901563d260d2323cd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;vec_cntlz_lsbb&lt;/code&gt; function returns the count of the number of consecutive leading byte elements (starting from position 0 within the supplied vector argument) for which the least-significant bit equals zero. The &lt;code&gt;vec_cnttz_lsbb&lt;/code&gt; function returns the count of the number of consecutive trailing byte elements (starting from position 15 and counting backwards within the supplied vector argument) for which the least-significant bit equals zero.</source>
          <target state="translated">所述 &lt;code&gt;vec_cntlz_lsbb&lt;/code&gt; 函数返回连续的前导字节元件的数量的计数的量，至少-显著位等于零（从提供矢量参数中位置0开始）。所述 &lt;code&gt;vec_cnttz_lsbb&lt;/code&gt; 函数返回连续的尾随字节元件的数量的计数（从15位置开始和所提供的矢量参数内倒数）的量，至少-显著位等于零。</target>
        </trans-unit>
        <trans-unit id="01b02bbdd65d95e68fbfa45f0222f7cae6e029b5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;vec_extract_sig&lt;/code&gt; and &lt;code&gt;vec_extract_exp&lt;/code&gt; built-in functions return vectors representing the significands and biased exponent values of their &lt;code&gt;source&lt;/code&gt; arguments respectively. Within the result vector returned by &lt;code&gt;vec_extract_sig&lt;/code&gt;, the &lt;code&gt;0x800000&lt;/code&gt; bit of each vector element returned when the function&amp;rsquo;s &lt;code&gt;source&lt;/code&gt; argument is of type &lt;code&gt;float&lt;/code&gt; is set to 1 if the corresponding floating point value is in normalized form. Otherwise, this bit is set to 0. When the &lt;code&gt;source&lt;/code&gt; argument is of type &lt;code&gt;double&lt;/code&gt;, the &lt;code&gt;0x10000000000000&lt;/code&gt; bit within each of the result vector&amp;rsquo;s elements is set according to the same rules. Note that the sign of the significand is not represented in the result returned from the &lt;code&gt;vec_extract_sig&lt;/code&gt; function. To extract the sign bits, use the &lt;code&gt;vec_cpsgn&lt;/code&gt; function, which returns a new vector within which all of the sign bits of its second argument vector are overwritten with the sign bits copied from the coresponding elements of its first argument vector, and all other (non-sign) bits of the second argument vector are copied unchanged into the result vector.</source>
          <target state="translated">的 &lt;code&gt;vec_extract_sig&lt;/code&gt; 和 &lt;code&gt;vec_extract_exp&lt;/code&gt; 内置函数返回一个表示的他们的有效数和偏置指数值矢量 &lt;code&gt;source&lt;/code&gt; 分别参数。在 &lt;code&gt;vec_extract_sig&lt;/code&gt; 返回的结果向量内，如果函数的 &lt;code&gt;source&lt;/code&gt; 参数为 &lt;code&gt;float&lt;/code&gt; 类型，则返回的每个向量元素的 &lt;code&gt;0x800000&lt;/code&gt; 位设置为1（如果相应的浮点值采用规范化形式）。否则，此位设置为0。当 &lt;code&gt;source&lt;/code&gt; 参数的类型为 &lt;code&gt;double&lt;/code&gt; 时，则为 &lt;code&gt;0x10000000000000&lt;/code&gt; 每个结果向量元素内的位均根据相同规则设置。请注意，从 &lt;code&gt;vec_extract_sig&lt;/code&gt; 函数返回的结果中未显示有效数的符号。要提取符号位，请使用 &lt;code&gt;vec_cpsgn&lt;/code&gt; 函数，该函数返回一个新向量，在该向量中，其第二个自变量向量的所有符号位均会被从其第一个自变量向量的核心对应元素复制的符号位以及所有其他（非第二个自变量向量的（-sign）位不变地复制到结果向量中。</target>
        </trans-unit>
        <trans-unit id="5a829a08652f6801fcbd433b37bbf07c5d838fb5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;vec_insert_exp&lt;/code&gt; built-in functions return a vector of single- or double-precision floating point values constructed by assembling the values of their &lt;code&gt;significands&lt;/code&gt; and &lt;code&gt;exponents&lt;/code&gt; arguments into the corresponding elements of the returned vector. The sign of each element of the result is copied from the most significant bit of the corresponding entry within the &lt;code&gt;significands&lt;/code&gt; argument. Note that the relevant bits of the &lt;code&gt;significands&lt;/code&gt; argument are the same, for both integer and floating point types. The significand and exponent components of each element of the result are composed of the least significant bits of the corresponding &lt;code&gt;significands&lt;/code&gt; element and the least significant bits of the corresponding &lt;code&gt;exponents&lt;/code&gt; element.</source>
          <target state="translated">所述 &lt;code&gt;vec_insert_exp&lt;/code&gt; 内置函数返回通过组装其的值构成的单或双精度浮点值的矢量 &lt;code&gt;significands&lt;/code&gt; 和 &lt;code&gt;exponents&lt;/code&gt; 参数到返回向量的相应的元件。从 &lt;code&gt;significands&lt;/code&gt; 参数中相应条目的最高有效位复制结果的每个元素的符号。请注意，对于整数和浮点类型， &lt;code&gt;significands&lt;/code&gt; 参数的相关位相同。结果每个元素的有效和指数成分由相应 &lt;code&gt;significands&lt;/code&gt; 数的最低有效位组成元素和相应 &lt;code&gt;exponents&lt;/code&gt; 元素的最低有效位。</target>
        </trans-unit>
        <trans-unit id="0a91af05019f6d272dc741d0e069fe70406b3512" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;vec_revb&lt;/code&gt; built-in function reverses the bytes on an element by element basis. A vector of &lt;code&gt;vector unsigned char&lt;/code&gt; or &lt;code&gt;vector signed char&lt;/code&gt; reverses the bytes in the whole word.</source>
          <target state="translated">该 &lt;code&gt;vec_revb&lt;/code&gt; 内置功能反转由元素的基础元素的字节。的载体 &lt;code&gt;vector unsigned char&lt;/code&gt; 或 &lt;code&gt;vector signed char&lt;/code&gt; 反转在整个字中的字节。</target>
        </trans-unit>
        <trans-unit id="9de89009a6ac207492ea21a351e324b964d19bce" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;vec_rsqrt&lt;/code&gt;, &lt;code&gt;__builtin_rsqrt&lt;/code&gt;, and &lt;code&gt;__builtin_rsqrtf&lt;/code&gt; functions generate multiple instructions to implement the reciprocal sqrt functionality using reciprocal sqrt estimate instructions.</source>
          <target state="translated">的 &lt;code&gt;vec_rsqrt&lt;/code&gt; ， &lt;code&gt;__builtin_rsqrt&lt;/code&gt; 和 &lt;code&gt;__builtin_rsqrtf&lt;/code&gt; 功能生成的多个指令使用倒数平方根估计指令，以实现倒数平方根功能。</target>
        </trans-unit>
        <trans-unit id="246e48e9c9edd5f446bb04be8d23c0491da1918c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;vec_slv&lt;/code&gt; and &lt;code&gt;vec_srv&lt;/code&gt; functions operate on all of the bytes of their &lt;code&gt;src&lt;/code&gt; and &lt;code&gt;shift_distance&lt;/code&gt; arguments in parallel. The behavior of the &lt;code&gt;vec_slv&lt;/code&gt; is as if there existed a temporary array of 17 unsigned characters &lt;code&gt;slv_array&lt;/code&gt; within which elements 0 through 15 are the same as the entries in the &lt;code&gt;src&lt;/code&gt; array and element 16 equals 0. The result returned from the &lt;code&gt;vec_slv&lt;/code&gt; function is a &lt;code&gt;__vector&lt;/code&gt; of 16 unsigned characters within which element &lt;code&gt;i&lt;/code&gt; is computed using the C expression &lt;code&gt;0xff &amp;amp; (*((unsigned short *)(slv_array + i)) &amp;lt;&amp;lt; (0x07 &amp;amp;
shift_distance[i]))&lt;/code&gt;, with this resulting value coerced to the &lt;code&gt;unsigned char&lt;/code&gt; type. The behavior of the &lt;code&gt;vec_srv&lt;/code&gt; is as if there existed a temporary array of 17 unsigned characters &lt;code&gt;srv_array&lt;/code&gt; within which element 0 equals zero and elements 1 through 16 equal the elements 0 through 15 of the &lt;code&gt;src&lt;/code&gt; array. The result returned from the &lt;code&gt;vec_srv&lt;/code&gt; function is a &lt;code&gt;__vector&lt;/code&gt; of 16 unsigned characters within which element &lt;code&gt;i&lt;/code&gt; is computed using the C expression &lt;code&gt;0xff &amp;amp; (*((unsigned short *)(srv_array + i)) &amp;gt;&amp;gt;
(0x07 &amp;amp; shift_distance[i]))&lt;/code&gt;, with this resulting value coerced to the &lt;code&gt;unsigned char&lt;/code&gt; type.</source>
          <target state="translated">的 &lt;code&gt;vec_slv&lt;/code&gt; 和 &lt;code&gt;vec_srv&lt;/code&gt; 函数对所有的它们的字节的操作 &lt;code&gt;src&lt;/code&gt; 和 &lt;code&gt;shift_distance&lt;/code&gt; 并联参数。 &lt;code&gt;vec_slv&lt;/code&gt; 的行为就像存在一个由17个无符号字符 &lt;code&gt;slv_array&lt;/code&gt; 组成的临时数组，其中元素0到15与 &lt;code&gt;src&lt;/code&gt; 数组中的条目相同，元素16等于 &lt;code&gt;vec_slv&lt;/code&gt; 函数返回的结果是 &lt;code&gt;__vector&lt;/code&gt; 16个无符号字符，其中使用C表达式计算元素 &lt;code&gt;i&lt;/code&gt; &lt;code&gt;0xff &amp;amp; (*((unsigned short *)(slv_array + i)) &amp;lt;&amp;lt; (0x07 &amp;amp; shift_distance[i]))&lt;/code&gt; ，此结果值强制转换为 &lt;code&gt;unsigned char&lt;/code&gt; 类型。 &lt;code&gt;vec_srv&lt;/code&gt; 的行为好像存在一个由17个无符号字符 &lt;code&gt;srv_array&lt;/code&gt; 组成的临时数组，其中元素0等于零，元素1到16等于 &lt;code&gt;src&lt;/code&gt; 数组的元素0到15 。从 &lt;code&gt;vec_srv&lt;/code&gt; 函数返回的结果是一个由16个无符号字符组成的 &lt;code&gt;__vector&lt;/code&gt; ，在其中使用 &lt;code&gt;i&lt;/code&gt; C表达式 &lt;code&gt;0xff &amp;amp; (*((unsigned short *)(srv_array + i)) &amp;gt;&amp;gt; (0x07 &amp;amp; shift_distance[i]))&lt;/code&gt; 计算元素i ），并将此结果值强制转换为 &lt;code&gt;unsigned char&lt;/code&gt; 类型。</target>
        </trans-unit>
        <trans-unit id="6a1b591d1d5bc9da82b7b03dcf8d2e3d88da8bb6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;vec_test_data_class&lt;/code&gt; built-in function returns a vector representing the results of testing the &lt;code&gt;source&lt;/code&gt; vector for the condition selected by the &lt;code&gt;condition&lt;/code&gt; argument. The &lt;code&gt;condition&lt;/code&gt; argument must be a compile-time constant integer with value not exceeding 127. The &lt;code&gt;condition&lt;/code&gt; argument is encoded as a bitmask with each bit enabling the testing of a different condition, as characterized by the following:</source>
          <target state="translated">所述 &lt;code&gt;vec_test_data_class&lt;/code&gt; 内置函数返回表示测试的结果的矢量 &lt;code&gt;source&lt;/code&gt; 用于由被选择的条件向量 &lt;code&gt;condition&lt;/code&gt; 的参数。的 &lt;code&gt;condition&lt;/code&gt; 参数必须是一个编译时间常数整数，值不超过127。 &lt;code&gt;condition&lt;/code&gt; 参数被编码为与每个位使一个不同的条件下的测试的位掩码，因为其特征在于通过以下：</target>
        </trans-unit>
        <trans-unit id="991ae395a453d861dfb8c7b24fc2cbc3ce4b3da0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;vec_xl_len&lt;/code&gt; and &lt;code&gt;vec_xst_len&lt;/code&gt; functions require a 64-bit environment supporting ISA 3.0 or later. The &lt;code&gt;vec_xl_len&lt;/code&gt; function loads a variable length vector from memory. The &lt;code&gt;vec_xst_len&lt;/code&gt; function stores a variable length vector to memory. With both the &lt;code&gt;vec_xl_len&lt;/code&gt; and &lt;code&gt;vec_xst_len&lt;/code&gt; functions, the &lt;code&gt;addr&lt;/code&gt; argument represents the memory address to or from which data will be transferred, and the &lt;code&gt;len&lt;/code&gt; argument represents the number of bytes to be transferred, as computed by the C expression &lt;code&gt;min((len &amp;amp; 0xff), 16)&lt;/code&gt;. If this expression&amp;rsquo;s value is not a multiple of the vector element&amp;rsquo;s size, the behavior of this function is undefined. In the case that the underlying computer is configured to run in big-endian mode, the data transfer moves bytes 0 to &lt;code&gt;(len - 1)&lt;/code&gt; of the corresponding vector. In little-endian mode, the data transfer moves bytes &lt;code&gt;(16 - len)&lt;/code&gt; to &lt;code&gt;15&lt;/code&gt; of the corresponding vector. For the load function, any bytes of the result vector that are not loaded from memory are set to zero. The value of the &lt;code&gt;addr&lt;/code&gt; argument need not be aligned on a multiple of the vector&amp;rsquo;s element size.</source>
          <target state="translated">的 &lt;code&gt;vec_xl_len&lt;/code&gt; 和 &lt;code&gt;vec_xst_len&lt;/code&gt; 功能需要一个64位的环境中支持ISA 3.0或更高版本。所述 &lt;code&gt;vec_xl_len&lt;/code&gt; 函数从存储器加载的可变长度向量。所述 &lt;code&gt;vec_xst_len&lt;/code&gt; 功能存储的可变长度向量到存储器。使用 &lt;code&gt;vec_xl_len&lt;/code&gt; 和 &lt;code&gt;vec_xst_len&lt;/code&gt; 函数时， &lt;code&gt;addr&lt;/code&gt; 参数表示要向其传输数据或从其传输数据的内存地址，而 &lt;code&gt;len&lt;/code&gt; 参数表示要传输的字节数，由C表达式 &lt;code&gt;min((len &amp;amp; 0xff), 16)&lt;/code&gt; 。如果此表达式的值不是向量元素大小的倍数，则此函数的行为不确定。在将基础计算机配置为以big-endian模式运行的情况下，数据传输会将字节0移到相应向量的 &lt;code&gt;(len - 1)&lt;/code&gt; 。在小端模式下，数据传输将字节 &lt;code&gt;(16 - len)&lt;/code&gt; 移至相应向量的 &lt;code&gt;15&lt;/code&gt; 。对于装入功能，未从内存中装入的结果向量的所有字节均设置为零。 &lt;code&gt;addr&lt;/code&gt; 参数的值不必与向量元素大小的倍数对齐。</target>
        </trans-unit>
        <trans-unit id="32f436c7a33759092d0385b9b27659581036ece3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;vec_xlx&lt;/code&gt; and &lt;code&gt;vec_xrx&lt;/code&gt; functions extract the single element selected by the &lt;code&gt;index&lt;/code&gt; argument from the vector represented by the &lt;code&gt;data&lt;/code&gt; argument. The &lt;code&gt;index&lt;/code&gt; argument always specifies a byte offset, regardless of the size of the vector element. With &lt;code&gt;vec_xlx&lt;/code&gt;, &lt;code&gt;index&lt;/code&gt; is the offset of the first byte of the element to be extracted. With &lt;code&gt;vec_xrx&lt;/code&gt;, &lt;code&gt;index&lt;/code&gt; represents the last byte of the element to be extracted, measured from the right end of the vector. In other words, the last byte of the element to be extracted is found at position &lt;code&gt;(15 - index)&lt;/code&gt;. There is no requirement that &lt;code&gt;index&lt;/code&gt; be a multiple of the vector element size. However, if the size of the vector element added to &lt;code&gt;index&lt;/code&gt; is greater than 15, the content of the returned value is undefined.</source>
          <target state="translated">的 &lt;code&gt;vec_xlx&lt;/code&gt; 和 &lt;code&gt;vec_xrx&lt;/code&gt; 功能提取由所选择的单一元素 &lt;code&gt;index&lt;/code&gt; 从由所表示的矢量的参数 &lt;code&gt;data&lt;/code&gt; 的参数。所述 &lt;code&gt;index&lt;/code&gt; 参数总是指定向量元素的大小无关一个字节偏移量。使用 &lt;code&gt;vec_xlx&lt;/code&gt; 时， &lt;code&gt;index&lt;/code&gt; 是要提取的元素的第一个字节的偏移量。使用 &lt;code&gt;vec_xrx&lt;/code&gt; 时， &lt;code&gt;index&lt;/code&gt; 表示要提取的元素的最后一个字节，从向量的右端开始测量。换句话说，要提取的元素的最后一个字节位于位置 &lt;code&gt;(15 - index)&lt;/code&gt; 。不需要 &lt;code&gt;index&lt;/code&gt; 是向量元素大小的倍数。但是，如果添加到 &lt;code&gt;index&lt;/code&gt; 的矢量元素的大小大于15，则返回值的内容不确定。</target>
        </trans-unit>
        <trans-unit id="1ebaac2fb10fbefef121de501464e717714b8367" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;vector_size&lt;/code&gt; attribute is only applicable to integral and floating scalars, although arrays, pointers, and function return values are allowed in conjunction with this construct. Only sizes that are positive power-of-two multiples of the base type size are currently allowed.</source>
          <target state="translated">所述 &lt;code&gt;vector_size&lt;/code&gt; 属性仅适用整型和浮点标量，虽然阵列，指针和函数返回值被允许在用该构建体结合使用。当前仅允许使用基本类型大小的2的正整数倍的大小。</target>
        </trans-unit>
        <trans-unit id="837b5049d27cb5d3caabb0997e45a1cbb234446d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;vliw&lt;/code&gt; attribute tells the compiler to emit instructions in VLIW mode instead of core mode. Note that this attribute is not allowed unless a VLIW coprocessor has been configured and enabled through command-line options.</source>
          <target state="translated">该 &lt;code&gt;vliw&lt;/code&gt; 属性告诉编译器在VLIW模式下，而不是核心模式EMIT指令。请注意，除非已通过命令行选项配置并启用了VLIW协处理器，否则不允许使用此属性。</target>
        </trans-unit>
        <trans-unit id="42d2812dccb310da3b37a59c6a8e7a142b29dac3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;warn_unused_result&lt;/code&gt; attribute causes a warning to be emitted if a caller of the function with this attribute does not use its return value. This is useful for functions where not checking the result is either a security problem or always a bug, such as &lt;code&gt;realloc&lt;/code&gt;.</source>
          <target state="translated">如果具有此属性的函数的调用者不使用其返回值，则 &lt;code&gt;warn_unused_result&lt;/code&gt; 属性会导致发出警告。对于不检查结果是安全性问题还是总是有错误的函数（例如 &lt;code&gt;realloc&lt;/code&gt; )，这很有用。</target>
        </trans-unit>
        <trans-unit id="0d86cabe39f6b2eca4b3f76217c522746181a80f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;weak&lt;/code&gt; attribute causes a declaration of an external symbol to be emitted as a weak symbol rather than a global. This is primarily useful in defining library functions that can be overridden in user code, though it can also be used with non-function declarations. The overriding symbol must have the same type as the weak symbol. In addition, if it designates a variable it must also have the same size and alignment as the weak symbol. Weak symbols are supported for ELF targets, and also for a.out targets when using the GNU assembler and linker.</source>
          <target state="translated">所述 &lt;code&gt;weak&lt;/code&gt; 属性使外部符号的声明被发射以弱符号，而不是全局的。尽管它也可以与非函数声明一起使用，但是这在定义可以在用户代码中覆盖的库函数时非常有用。覆盖符号必须与弱符号具有相同的类型。另外，如果它指定一个变量，它还必须具有与弱符号相同的大小和对齐方式。使用GNU汇编器和链接器时，ELF目标和a.out目标均支持弱符号。</target>
        </trans-unit>
        <trans-unit id="d64e3cfe5255e69eafb7d485c8c088e61fa4d8a4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;weak&lt;/code&gt; attribute causes the declaration to be emitted as a weak symbol rather than a global. This is primarily useful in defining library functions that can be overridden in user code, though it can also be used with non-function declarations. Weak symbols are supported for ELF targets, and also for a.out targets when using the GNU assembler and linker.</source>
          <target state="translated">在 &lt;code&gt;weak&lt;/code&gt; 属性导致要发出作为一个弱符号，而不是一个全球性的声明。尽管它也可以与非函数声明一起使用，但是这在定义可以在用户代码中覆盖的库函数时非常有用。使用GNU汇编器和链接器时，ELF目标和a.out目标均支持弱符号。</target>
        </trans-unit>
        <trans-unit id="4250f8084c2d37890c56691349397dd644e93eba" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;weak&lt;/code&gt; attribute is described in &lt;a href=&quot;common-function-attributes#Common-Function-Attributes&quot;&gt;Common Function Attributes&lt;/a&gt;.</source>
          <target state="translated">该 &lt;code&gt;weak&lt;/code&gt; 属性描述&lt;a href=&quot;common-function-attributes#Common-Function-Attributes&quot;&gt;常用功能属性&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0fd7b693a88b68899809d3dfabebee19f1a4688b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;weakref&lt;/code&gt; attribute marks a declaration as a weak reference. Without arguments, it should be accompanied by an &lt;code&gt;alias&lt;/code&gt; attribute naming the target symbol. Alternatively, &lt;var&gt;target&lt;/var&gt; may be given as an argument to &lt;code&gt;weakref&lt;/code&gt; itself, naming the target definition of the alias. The &lt;var&gt;target&lt;/var&gt; must have the same type as the declaration. In addition, if it designates a variable it must also have the same size and alignment as the declaration. In either form of the declaration &lt;code&gt;weakref&lt;/code&gt; implicitly marks the declared symbol as &lt;code&gt;weak&lt;/code&gt;. Without a &lt;var&gt;target&lt;/var&gt; given as an argument to &lt;code&gt;weakref&lt;/code&gt; or to &lt;code&gt;alias&lt;/code&gt;, &lt;code&gt;weakref&lt;/code&gt; is equivalent to &lt;code&gt;weak&lt;/code&gt; (in that case the declaration may be &lt;code&gt;extern&lt;/code&gt;).</source>
          <target state="translated">该 &lt;code&gt;weakref&lt;/code&gt; 属性标记的声明视为弱引用。不带参数的情况下，应伴有命名目标符号的 &lt;code&gt;alias&lt;/code&gt; 属性。或者，可以将 &lt;var&gt;target&lt;/var&gt; 指定为 &lt;code&gt;weakref&lt;/code&gt; 本身的参数，并命名别名的目标定义。该 &lt;var&gt;target&lt;/var&gt; 必须具有相同类型的声明。另外，如果它指定一个变量，它还必须具有与声明相同的大小和对齐方式。无论采用哪种声明形式， &lt;code&gt;weakref&lt;/code&gt; 都会将声明的符号隐式标记为 &lt;code&gt;weak&lt;/code&gt; 。如果没有将 &lt;var&gt;target&lt;/var&gt; 指定为 &lt;code&gt;weakref&lt;/code&gt; 或 &lt;code&gt;alias&lt;/code&gt; 的参数， &lt;code&gt;weakref&lt;/code&gt; 相当于 &lt;code&gt;weak&lt;/code&gt; （在这种情况下，声明可以 &lt;code&gt;extern&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="362aefd1f311374abf7ac9d8d10e9633ea762db5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;weakref&lt;/code&gt; attribute marks a declaration as a weak reference. Without arguments, it should be accompanied by an &lt;code&gt;alias&lt;/code&gt; attribute naming the target symbol. Optionally, the &lt;var&gt;target&lt;/var&gt; may be given as an argument to &lt;code&gt;weakref&lt;/code&gt; itself. In either case, &lt;code&gt;weakref&lt;/code&gt; implicitly marks the declaration as &lt;code&gt;weak&lt;/code&gt;. Without a &lt;var&gt;target&lt;/var&gt;, given as an argument to &lt;code&gt;weakref&lt;/code&gt; or to &lt;code&gt;alias&lt;/code&gt;, &lt;code&gt;weakref&lt;/code&gt; is equivalent to &lt;code&gt;weak&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;weakref&lt;/code&gt; 属性标记的声明视为弱引用。不带参数的情况下，应伴有命名目标符号的 &lt;code&gt;alias&lt;/code&gt; 属性。可以选择将 &lt;var&gt;target&lt;/var&gt; 作为 &lt;code&gt;weakref&lt;/code&gt; 本身的参数给出。无论哪种情况， &lt;code&gt;weakref&lt;/code&gt; 都会将声明隐式标记为 &lt;code&gt;weak&lt;/code&gt; 。如果没有 &lt;var&gt;target&lt;/var&gt; ，指定作为参数来 &lt;code&gt;weakref&lt;/code&gt; 或 &lt;code&gt;alias&lt;/code&gt; ， &lt;code&gt;weakref&lt;/code&gt; 相当于 &lt;code&gt;weak&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="31c2b38693187358ef61afd2bbcd821fce4cea47" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;write_only&lt;/code&gt; access mode applies to arguments of pointer types without the &lt;code&gt;const&lt;/code&gt; qualifier. It specifies that the pointer to which it applies is used to write to the referenced object but not read from it. The object referenced by the pointer need not be initialized. An example of the use of the &lt;code&gt;write_only&lt;/code&gt; access mode is the first argument to the &lt;code&gt;strcpy&lt;/code&gt; function, or the first two arguments to the &lt;code&gt;fgets&lt;/code&gt; function.</source>
          <target state="translated">只 &lt;code&gt;write_only&lt;/code&gt; 访问模式适用于没有 &lt;code&gt;const&lt;/code&gt; 限定符的指针类型的参数。它指定将其应用于的指针用于写入引用的对象，但不能从其读取。指针引用的对象无需初始化。使用 &lt;code&gt;write_only&lt;/code&gt; 访问模式的一个示例是 &lt;code&gt;strcpy&lt;/code&gt; 函数的第一个参数，或者 &lt;code&gt;fgets&lt;/code&gt; 函数的前两个参数。</target>
        </trans-unit>
        <trans-unit id="a5580c84e305bbd75698ac25971a0df43ef6cc5f" translate="yes" xml:space="preserve">
          <source>The &lt;var&gt;call_exp&lt;/var&gt; expression must be a function call, and the &lt;var&gt;pointer_exp&lt;/var&gt; expression must be a pointer. The &lt;var&gt;pointer_exp&lt;/var&gt; is passed to the function call in the target&amp;rsquo;s static chain location. The result of builtin is the result of the function call.</source>
          <target state="translated">所述 &lt;var&gt;call_exp&lt;/var&gt; 表达式必须是一个函数调用，并且 &lt;var&gt;pointer_exp&lt;/var&gt; 表达式必须是一个指针。将 &lt;var&gt;pointer_exp&lt;/var&gt; 传递到目标的静态链位置中的函数调用。内建的结果是函数调用的结果。</target>
        </trans-unit>
        <trans-unit id="47808f5c44d74211446dd3107371068aa638bc2f" translate="yes" xml:space="preserve">
          <source>The &lt;var&gt;information&lt;/var&gt; is human readable, but designed to be simple enough for machine parsing too.</source>
          <target state="translated">该 &lt;var&gt;information&lt;/var&gt; 是人类可读的，但也设计得足够简单以用于机器解析。</target>
        </trans-unit>
        <trans-unit id="2e82b6b86f048807c7ae6131df8cf24c8fb6345a" translate="yes" xml:space="preserve">
          <source>The &lt;var&gt;level&lt;/var&gt; argument must be a constant integer.</source>
          <target state="translated">该 &lt;var&gt;level&lt;/var&gt; 参数必须是整型常量。</target>
        </trans-unit>
        <trans-unit id="2457707eff68e08cd199be4e3c699bc3aefc86a0" translate="yes" xml:space="preserve">
          <source>The &lt;var&gt;level&lt;/var&gt; argument should be one of the following:</source>
          <target state="translated">该 &lt;var&gt;level&lt;/var&gt; 参数应该是以下情况之一：</target>
        </trans-unit>
        <trans-unit id="9e08ee76b1da2a0a7eab6aae9dc5ab5a92291dc1" translate="yes" xml:space="preserve">
          <source>The &lt;var&gt;level&lt;/var&gt; can be one of:</source>
          <target state="translated">该 &lt;var&gt;level&lt;/var&gt; 可以是一个：</target>
        </trans-unit>
        <trans-unit id="07133152e9a0d85287182cf9221be477141dff40" translate="yes" xml:space="preserve">
          <source>The &lt;var&gt;oldname&lt;/var&gt; used by &lt;code&gt;#pragma redefine_extname&lt;/code&gt; is always the C-language name.</source>
          <target state="translated">&lt;code&gt;#pragma redefine_extname&lt;/code&gt; 使用的 &lt;var&gt;oldname&lt;/var&gt; 名称始终是C语言名称。</target>
        </trans-unit>
        <trans-unit id="f9388ad5137ed5dfa5588bcfa11755abc3ce7181" translate="yes" xml:space="preserve">
          <source>The &lt;var&gt;options&lt;/var&gt; can be divided into three groups:</source>
          <target state="translated">该 &lt;var&gt;options&lt;/var&gt; 可以分为三类：</target>
        </trans-unit>
        <trans-unit id="c19aabaea762edf72b5cc0612746c317d8ff2de8" translate="yes" xml:space="preserve">
          <source>The &lt;var&gt;os&lt;/var&gt; argument is the object size &lt;var&gt;s&lt;/var&gt; points to, like in the other built-in functions. There is a small difference in the behavior though, if &lt;var&gt;os&lt;/var&gt; is &lt;code&gt;(size_t) -1&lt;/code&gt;, the built-in functions are optimized into the non-checking functions only if &lt;var&gt;flag&lt;/var&gt; is 0, otherwise the checking function is called with &lt;var&gt;os&lt;/var&gt; argument set to &lt;code&gt;(size_t) -1&lt;/code&gt;.</source>
          <target state="translated">的 &lt;var&gt;os&lt;/var&gt; 参数是对象的大小 &lt;var&gt;s&lt;/var&gt; 点，像在其他的内置函数。不过，行为上有细微的差别，如果 &lt;var&gt;os&lt;/var&gt; 为 &lt;code&gt;(size_t) -1&lt;/code&gt; ，则仅当 &lt;var&gt;flag&lt;/var&gt; 为0时，才会将内置函数优化为非检查函数，否则，将 &lt;var&gt;os&lt;/var&gt; 参数设置为 &lt;code&gt;(size_t) -1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="99051c6bb8529049d31b5150a695460a96f0eb50" translate="yes" xml:space="preserve">
          <source>The &lt;var&gt;string&lt;/var&gt; can either be a number (decimal, octal or hex) or an arbitrary string (in which case it&amp;rsquo;s converted to a number by computing CRC32).</source>
          <target state="translated">该 &lt;var&gt;string&lt;/var&gt; 可以是数字（十进制，八进制或十六进制）或任意字符串（在这种情况下，可以通过计算CRC32将其转换为数字）。</target>
        </trans-unit>
        <trans-unit id="e2a9a665b951d617734d12093bb7933ae309b7f0" translate="yes" xml:space="preserve">
          <source>The &lt;var&gt;string&lt;/var&gt; should be different for every file you compile.</source>
          <target state="translated">对于您编译的每个文件， &lt;var&gt;string&lt;/var&gt; 都应该不同。</target>
        </trans-unit>
        <trans-unit id="e5cf6b74b693d7f4748254b48ea16e3b5621f730" translate="yes" xml:space="preserve">
          <source>The ABI tags apply to a name, so all instantiations and specializations of a template have the same tags. The attribute will be ignored if applied to an explicit specialization or instantiation.</source>
          <target state="translated">ABI标签适用于一个名称,因此模板的所有实例化和特殊化都有相同的标签。如果应用于明确的特化或实例,则该属性将被忽略。</target>
        </trans-unit>
        <trans-unit id="d6e578589905c0491635616be2b8a8085308fc15" translate="yes" xml:space="preserve">
          <source>The AIX calling convention was extended but not initially documented to handle an obscure K&amp;amp;R C case of calling a function that takes the address of its arguments with fewer arguments than declared. IBM XL compilers access floating-point arguments that do not fit in the RSA from the stack when a subroutine is compiled without optimization. Because always storing floating-point arguments on the stack is inefficient and rarely needed, this option is not enabled by default and only is necessary when calling subroutines compiled by IBM XL compilers without optimization.</source>
          <target state="translated">AIX调用约定得到了扩展，但最初并未进行记录，以处理调用函数的模糊K＆R C情况，该函数采用比声明少的参数来接收其参数的地址。当未经优化而编译子例程时，IBM XL编译器将从堆栈中访问不适合RSA的浮点参数。因为始终将浮点参数存储在堆栈上效率很低并且很少需要，所以缺省情况下不启用此选项，只有在调用未经优化的IBM XL编译器编译的子例程时才需要此选项。</target>
        </trans-unit>
        <trans-unit id="0286e5ab4aaa67941386b2ad2370f9a09da6cea5" translate="yes" xml:space="preserve">
          <source>The ARM attribute &lt;code&gt;Tag_CPU_unaligned_access&lt;/code&gt; is set in the generated object file to either true or false, depending upon the setting of this option. If unaligned access is enabled then the preprocessor symbol &lt;code&gt;__ARM_FEATURE_UNALIGNED&lt;/code&gt; is also defined.</source>
          <target state="translated">根据此选项的设置，在生成的目标文件 &lt;code&gt;Tag_CPU_unaligned_access&lt;/code&gt; ARM属性Tag_CPU_unaligned_access设置为true或false。如果启用了未对齐访问，则还将定义预处理器符号 &lt;code&gt;__ARM_FEATURE_UNALIGNED&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="38b655dda41c627fb0c53750526171175cc9f72b" translate="yes" xml:space="preserve">
          <source>The ARM target defines pragmas for controlling the default addition of &lt;code&gt;long_call&lt;/code&gt; and &lt;code&gt;short_call&lt;/code&gt; attributes to functions. See &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;Function Attributes&lt;/a&gt;, for information about the effects of these attributes.</source>
          <target state="translated">ARM目标定义了用于控制在函数中默认添加 &lt;code&gt;long_call&lt;/code&gt; 和 &lt;code&gt;short_call&lt;/code&gt; 属性的编译指示。有关这些属性的影响的信息，请参见&lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;功能属性&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="180b9a433ddcfbb50e74358632373510b9ae0866" translate="yes" xml:space="preserve">
          <source>The ARM target provides hardware support for conversions between &lt;code&gt;__fp16&lt;/code&gt; and &lt;code&gt;float&lt;/code&gt; values as an extension to VFP and NEON (Advanced SIMD), and from ARMv8-A provides hardware support for conversions between &lt;code&gt;__fp16&lt;/code&gt; and &lt;code&gt;double&lt;/code&gt; values. GCC generates code using these hardware instructions if you compile with options to select an FPU that provides them; for example,</source>
          <target state="translated">ARM的目标提供了一种用于之间的转换的硬件支持 &lt;code&gt;__fp16&lt;/code&gt; 和 &lt;code&gt;float&lt;/code&gt; 值作为一个扩展VFP和氖（高级SIMD），并从ARMv8-A提供了用于之间的转换的硬件支持 &lt;code&gt;__fp16&lt;/code&gt; 和 &lt;code&gt;double&lt;/code&gt; 值。如果您编译带有选择提供它们的FPU的选项，则GCC会使用这些硬件指令来生成代码。例如，</target>
        </trans-unit>
        <trans-unit id="74677651175ff4a21af34df2adc4b16af0c62864" translate="yes" xml:space="preserve">
          <source>The ARM-state integer division instructions.</source>
          <target state="translated">ARM状态下的整数除法指令。</target>
        </trans-unit>
        <trans-unit id="25504eb2b5db6b1309f7e3ea71e7847bbe69ef9e" translate="yes" xml:space="preserve">
          <source>The ARMv8-A Advanced SIMD and floating-point instructions.</source>
          <target state="translated">ARMv8-A高级SIMD和浮点指令。</target>
        </trans-unit>
        <trans-unit id="7f8a18de7f60ebb2b7344b3e4891cc4342f1a12d" translate="yes" xml:space="preserve">
          <source>The ARMv8.1-A Advanced SIMD and floating-point instructions.</source>
          <target state="translated">ARMv8.1-A高级SIMD和浮点指令。</target>
        </trans-unit>
        <trans-unit id="33734522bf6eef68d24bf96c977fe3c147340232" translate="yes" xml:space="preserve">
          <source>The ARMv8.3-A Advanced SIMD and floating-point instructions as well as the Dot Product extension.</source>
          <target state="translated">ARMv8.3-A高级SIMD和浮点指令以及Dot产品扩展。</target>
        </trans-unit>
        <trans-unit id="2e1c8ef545821a2ae5bcfc55a26fd3b81629816e" translate="yes" xml:space="preserve">
          <source>The AT&amp;amp;T C++ translator, Cfront, solved the template instantiation problem by creating the notion of a template repository, an automatically maintained place where template instances are stored. A more modern version of the repository works as follows: As individual object files are built, the compiler places any template definitions and instantiations encountered in the repository. At link time, the link wrapper adds in the objects in the repository and compiles any needed instances that were not previously emitted. The advantages of this model are more optimal compilation speed and the ability to use the system linker; to implement the Borland model a compiler vendor also needs to replace the linker. The disadvantages are vastly increased complexity, and thus potential for error; for some code this can be just as transparent, but in practice it can been very difficult to build multiple programs in one directory and one program in multiple directories. Code written for this model tends to separate definitions of non-inline member templates into a separate file, which should be compiled separately.</source>
          <target state="translated">AT＆T C ++转换器Cfront通过创建模板存储库的概念来解决了模板实例化问题，模板存储库是模板实例的自动维护位置。较新版本的存储库的工作方式如下：在构建单个目标文件时，编译器会将所有模板定义和实例化放置在存储库中。在链接时，链接包装器将添加存储库中的对象，并编译以前未发出的任何所需实例。该模型的优点是优化编译速度和使用系统链接程序的能力。为了实现Borland模型，编译器供应商还需要替换链接器。缺点是极大地增加了复杂性，并因此有可能出错；对于某些代码，它可以一样透明，但是实际上，在一个目录中构建多个程序，在多个目录中构建一个程序可能非常困难。为此模型编写的代码趋向于将非内联成员模板的定义分为一个单独的文件，该文件应单独编译。</target>
        </trans-unit>
        <trans-unit id="b2f96e374cb7c3be8b863693d2e8387693d91334" translate="yes" xml:space="preserve">
          <source>The AVR hardware globally disables interrupts when an interrupt is executed. Interrupt handler functions defined with the &lt;code&gt;signal&lt;/code&gt; attribute do not re-enable interrupts. It is save to enable interrupts in a &lt;code&gt;signal&lt;/code&gt; handler. This &amp;ldquo;save&amp;rdquo; only applies to the code generated by the compiler and not to the IRQ layout of the application which is responsibility of the application.</source>
          <target state="translated">执行中断时，AVR硬件会全局禁用中断。用 &lt;code&gt;signal&lt;/code&gt; 属性定义的中断处理程序函数不会重新启用中断。保存以启用 &lt;code&gt;signal&lt;/code&gt; 处理程序中的中断。此&amp;ldquo;保存&amp;rdquo;仅适用于由编译器生成的代码，不适用于应用程序负责的应用程序的IRQ布局。</target>
        </trans-unit>
        <trans-unit id="819e5dd1ebff38014ce3cc47fe71028f5e880298" translate="yes" xml:space="preserve">
          <source>The Advanced SIMD (Neon) v1 and the VFPv3 floating-point instructions, with the half-precision floating-point conversion operations.</source>
          <target state="translated">高级SIMD(Neon)v1和VFPv3浮点指令,具有半精度浮点转换操作。</target>
        </trans-unit>
        <trans-unit id="04a974f086b15b184d16af3fa03c2b5403d55b20" translate="yes" xml:space="preserve">
          <source>The Advanced SIMD (Neon) v1 and the VFPv3 floating-point instructions. The extension &amp;lsquo;</source>
          <target state="translated">Advanced SIMD（Neon）v1和VFPv3浮点指令。扩展名'</target>
        </trans-unit>
        <trans-unit id="3b1828fb03b38714492461b5c83b7a35d9811c07" translate="yes" xml:space="preserve">
          <source>The Advanced SIMD (Neon) v1 and the VFPv3 floating-point instructions. The extensions &amp;lsquo;</source>
          <target state="translated">Advanced SIMD（Neon）v1和VFPv3浮点指令。扩展名'</target>
        </trans-unit>
        <trans-unit id="25f15c2fd3a5e4f09bf2de0e8dd88934f187e30c" translate="yes" xml:space="preserve">
          <source>The Advanced SIMD (Neon) v2 and the VFPv4 floating-point instructions.</source>
          <target state="translated">高级SIMD(Neon)v2和VFPv4浮点指令。</target>
        </trans-unit>
        <trans-unit id="8fb627100c24fb77ea39c11992a8aa490fe9b6bf" translate="yes" xml:space="preserve">
          <source>The Advanced SIMD (Neon) v2 and the VFPv4 floating-point instructions. The extension &amp;lsquo;</source>
          <target state="translated">Advanced SIMD（Neon）v2和VFPv4浮点指令。扩展名'</target>
        </trans-unit>
        <trans-unit id="a0b4e865040163440dd355cb51993ec44628f3a4" translate="yes" xml:space="preserve">
          <source>The Alpha architecture implements floating-point hardware optimized for maximum performance. It is mostly compliant with the IEEE floating-point standard. However, for full compliance, software assistance is required. This option generates code fully IEEE-compliant code &lt;em&gt;except&lt;/em&gt; that the &lt;var&gt;inexact-flag&lt;/var&gt; is not maintained (see below). If this option is turned on, the preprocessor macro &lt;code&gt;_IEEE_FP&lt;/code&gt; is defined during compilation. The resulting code is less efficient but is able to correctly support denormalized numbers and exceptional IEEE values such as not-a-number and plus/minus infinity. Other Alpha compilers call this option</source>
          <target state="translated">Alpha体系结构实现了针对最大性能进行了优化的浮点硬件。它主要符合IEEE浮点标准。但是，为了完全合规，需要软件帮助。该选项生成代码符合IEEE标准的充分代码&lt;em&gt;除了&lt;/em&gt;该 &lt;var&gt;inexact-flag&lt;/var&gt; 没有被维持（见下文）。如果打开此选项，则在编译期间定义预处理程序宏 &lt;code&gt;_IEEE_FP&lt;/code&gt; 。生成的代码效率较低，但能够正确支持非规范化数字和特殊的IEEE值，例如非数字和正负无穷大。其他Alpha编译器将此选项称为</target>
        </trans-unit>
        <trans-unit id="a224b29d0d210a4ad06df789e64da22f568f6054" translate="yes" xml:space="preserve">
          <source>The AltiVec built-in functions described in this section are available on the PowerPC family of processors starting with ISA 2.06 or later. These are normally enabled by adding</source>
          <target state="translated">本节所述的AltiVec内置功能在ISA 2.06或更高版本的PowerPC系列处理器上可用。这些功能通常是通过添加</target>
        </trans-unit>
        <trans-unit id="224e64a8094f6a857fb86e36e422aa4067f4740c" translate="yes" xml:space="preserve">
          <source>The C and C++ language specifications differ when an object is accessed in a void context:</source>
          <target state="translated">当一个对象在void上下文中被访问时,C和C++语言规范有所不同。</target>
        </trans-unit>
        <trans-unit id="0ef06715d23eab6e0953d0e3dffa82f688ece5af" translate="yes" xml:space="preserve">
          <source>The C and C++ standards define the order in which expressions in a C/C++ program are evaluated in terms of &lt;em&gt;sequence points&lt;/em&gt;, which represent a partial ordering between the execution of parts of the program: those executed before the sequence point, and those executed after it. These occur after the evaluation of a full expression (one which is not part of a larger expression), after the evaluation of the first operand of a &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;, &lt;code&gt;||&lt;/code&gt;, &lt;code&gt;? :&lt;/code&gt; or &lt;code&gt;,&lt;/code&gt; (comma) operator, before a function is called (but after the evaluation of its arguments and the expression denoting the called function), and in certain other places. Other than as expressed by the sequence point rules, the order of evaluation of subexpressions of an expression is not specified. All these rules describe only a partial order rather than a total order, since, for example, if two functions are called within one expression with no sequence point between them, the order in which the functions are called is not specified. However, the standards committee have ruled that function calls do not overlap.</source>
          <target state="translated">C和C ++标准定义了按&lt;em&gt;顺序点&lt;/em&gt;对C / C ++程序中的表达式进行求值的&lt;em&gt;顺序&lt;/em&gt;，&lt;em&gt;顺序点&lt;/em&gt;代表程序各部分执行之间的部分顺序：在顺序点之前执行的部分以及在顺序点之后执行的部分它。这些发生在对完整表达式（不是较大表达式的一部分）进行求值之后，对 &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; ， &lt;code&gt;||&lt;/code&gt; 的第一个操作数求值之后。， &lt;code&gt;? :&lt;/code&gt; 或者 &lt;code&gt;,&lt;/code&gt; （逗号）运算符，在调用函数之前（但在评估其参数和表示被调用函数的表达式之后），以及在某些其他位置。除了序列点规则所表示的以外，未指定表达式的子表达式的求值顺序。所有这些规则仅描述部分顺序，而不描述全部顺序，因为例如，如果在一个表达式中调用两个函数而它们之间没有序列点，则不会指定调用函数的顺序。但是，标准委员会已裁定功能调用不得重叠。</target>
        </trans-unit>
        <trans-unit id="ef19b8344a45aab20d25a471f2eb0b887d44fb1e" translate="yes" xml:space="preserve">
          <source>The C++ ABI requires multiple entry points for constructors and destructors: one for a base subobject, one for a complete object, and one for a virtual destructor that calls operator delete afterwards. For a hierarchy with virtual bases, the base and complete variants are clones, which means two copies of the function. With this option, the base and complete variants are changed to be thunks that call a common implementation.</source>
          <target state="translated">C++ABI要求构造函数和析构函数有多个入口点:一个是基底子对象,一个是完整对象,一个是虚拟析构函数,之后调用运算符删除。对于有虚拟基的层次结构,基子和完整变体是克隆的,也就是两个函数的副本。通过这个选项,基础变体和完整变体被改为调用共同实现的thunks。</target>
        </trans-unit>
        <trans-unit id="e88e1274e3c31338e664afbec99b09eac3f5a529" translate="yes" xml:space="preserve">
          <source>The C++ front end implements syntactic extensions that allow compile-time determination of various characteristics of a type (or of a pair of types).</source>
          <target state="translated">C++前端实现了语法扩展,允许在编译时确定一个类型(或一对类型)的各种特性。</target>
        </trans-unit>
        <trans-unit id="ec04375b745b1f1c4ce1f6fa5f903e079a94852c" translate="yes" xml:space="preserve">
          <source>The C++ language was further revised in 2017 and ISO/IEC 14882:2017 was published. This is referred to as C++17, and before publication was often referred to as C++1z. GCC supports all the changes in the new specification. For further details see &lt;a href=&quot;https://gcc.gnu.org/projects/cxx-status.html#cxx1z&quot;&gt;https://gcc.gnu.org/projects/cxx-status.html#cxx1z&lt;/a&gt;. Use the option</source>
          <target state="translated">C ++语言在2017年进行了进一步修订，并发布了ISO / IEC 14882：2017。这被称为C ++ 17，并且在发布前通常被称为C ++ 1z。GCC支持新规范中的所有更改。有关更多详细信息，请参见&lt;a href=&quot;https://gcc.gnu.org/projects/cxx-status.html#cxx1z&quot;&gt;https://gcc.gnu.org/projects/cxx-status.html#cxx1z&lt;/a&gt;。使用选项</target>
        </trans-unit>
        <trans-unit id="bcdb3a64fa68982d2e2c4cbdd5d9be1a69decab7" translate="yes" xml:space="preserve">
          <source>The C++ library used with a C++ compiler includes the Standard C++ Library, with functionality defined in the C++ Standard, plus language runtime support. The runtime support is included in a C++ ABI, but there is no formal ABI for the Standard C++ Library. Two implementations of that library are interoperable if one follows the de-facto ABI of the other and if they are both built with the same compiler, or with compilers that conform to the same ABI for C++ compiler and runtime support.</source>
          <target state="translated">与C++编译器一起使用的C++库包括标准C++库,其功能在C++标准中定义,加上语言运行时支持。运行时支持包含在C++ABI中,但标准C++库没有正式的ABI。该库的两个实现,如果一个遵循另一个的事实ABI,如果它们都是用同一个编译器,或者用符合相同的C++编译器和运行时支持ABI的编译器来构建,那么它们是可以互操作的。</target>
        </trans-unit>
        <trans-unit id="b030a2dbb3c8b3c3ceafa77d7dbaf4d97c312843" translate="yes" xml:space="preserve">
          <source>The C++ standard allows an implementation to omit creating a temporary that is only used to initialize another object of the same type. Specifying this option disables that optimization, and forces G++ to call the copy constructor in all cases. This option also causes G++ to call trivial member functions which otherwise would be expanded inline.</source>
          <target state="translated">C++标准允许一个实现省略创建一个仅用于初始化另一个同类型对象的临时对象。指定这个选项会禁用这种优化,并强制G++在所有情况下调用复制构造函数。这个选项也会导致G++调用琐碎的成员函数,否则这些函数会被内联扩展。</target>
        </trans-unit>
        <trans-unit id="c549c47d787f5172f4a63d73dccb4d86a5de3eaa" translate="yes" xml:space="preserve">
          <source>The C++ standard differs from the C standard in its treatment of volatile objects. It fails to specify what constitutes a volatile access, except to say that C++ should behave in a similar manner to C with respect to volatiles, where possible. However, the different lvalueness of expressions between C and C++ complicate the behavior. G++ behaves the same as GCC for volatile access, See &lt;a href=&quot;c-extensions#C-Extensions&quot;&gt;Volatiles&lt;/a&gt;, for a description of GCC&amp;rsquo;s behavior.</source>
          <target state="translated">C ++标准在处理易失性对象方面不同于C标准。它没有指定构成易失性访问的内容，只是说在可能的情况下，C ++对于易失性的行为应类似于C。但是，C和C ++之间不同的表达式左值使行为复杂化。对于volatile访问，G ++的行为与GCC相同，有关GCC行为的描述，请参见&lt;a href=&quot;c-extensions#C-Extensions&quot;&gt;Volatiles&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="949a50a0730c5f7ad89696edd9c2072338129167" translate="yes" xml:space="preserve">
          <source>The C++ standard just uses the term &amp;ldquo;dependent&amp;rdquo; for names that depend on the type or value of template parameters. This shorter term will also be used in the rest of this section.</source>
          <target state="translated">对于依赖于模板参数的类型或值的名称，C ++标准仅使用术语&amp;ldquo;从属&amp;rdquo;。在本节的其余部分中还将使用该较短的术语。</target>
        </trans-unit>
        <trans-unit id="7681d0e5c1533a0361ba254a5958bd845de12e17" translate="yes" xml:space="preserve">
          <source>The C++ standard prescribes that all names that are not dependent on template parameters are bound to their present definitions when parsing a template function or class.&lt;a href=&quot;#FOOT5&quot; id=&quot;DOCF5&quot; name=&quot;DOCF5&quot;&gt;&lt;sup&gt;5&lt;/sup&gt;&lt;/a&gt; Only names that are dependent are looked up at the point of instantiation. For example, consider</source>
          <target state="translated">C ++标准规定，在解析模板函数或类时，所有不依赖模板参数的名称都必须绑定到其当前定义。&lt;a href=&quot;#FOOT5&quot; id=&quot;DOCF5&quot; name=&quot;DOCF5&quot;&gt;&lt;sup&gt;5&lt;/sup&gt;&lt;/a&gt;在实例化点仅查找依赖的名称。例如，考虑</target>
        </trans-unit>
        <trans-unit id="253e6af722c0841d38d6e4f298c9a3cde3c002be" translate="yes" xml:space="preserve">
          <source>The C++ standard specifies that &amp;lsquo;</source>
          <target state="translated">C ++标准规定&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="7e51d56fadfe74149ae162a54ac1fe3c8b16dbb0" translate="yes" xml:space="preserve">
          <source>The C++ standard specifies that such expressions do not undergo lvalue to rvalue conversion, and that the type of the dereferenced object may be incomplete. The C++ standard does not specify explicitly that it is lvalue to rvalue conversion that is responsible for causing an access. There is reason to believe that it is, because otherwise certain simple expressions become undefined. However, because it would surprise most programmers, G++ treats dereferencing a pointer to volatile object of complete type as GCC would do for an equivalent type in C. When the object has incomplete type, G++ issues a warning; if you wish to force an error, you must force a conversion to rvalue with, for instance, a static cast.</source>
          <target state="translated">C++标准规定,这种表达式不进行lvalue到rvalue的转换,而且被解除引用对象的类型可能是不完整的。C++标准没有明确规定是lvalue到rvalue的转换导致了访问。我们有理由相信是这样的,因为否则某些简单表达式就会变得没有定义。然而,因为这会让大多数程序员感到惊讶,所以G++对待对完整类型的易失性对象指针的解除引用,就像GCC对待C语言中的等价类型一样,当对象具有不完整类型时,G++会发出警告;如果想强制出错,就必须用例如静态转换来强制转换为rvalue。</target>
        </trans-unit>
        <trans-unit id="73a31b9577ac049499e169205951815b4d802407" translate="yes" xml:space="preserve">
          <source>The C++11 and OpenMP standards allow &lt;code&gt;thread_local&lt;/code&gt; and &lt;code&gt;threadprivate&lt;/code&gt; variables to have dynamic (runtime) initialization. To support this, any use of such a variable goes through a wrapper function that performs any necessary initialization. When the use and definition of the variable are in the same translation unit, this overhead can be optimized away, but when the use is in a different translation unit there is significant overhead even if the variable doesn&amp;rsquo;t actually need dynamic initialization. If the programmer can be sure that no use of the variable in a non-defining TU needs to trigger dynamic initialization (either because the variable is statically initialized, or a use of the variable in the defining TU will be executed before any uses in another TU), they can avoid this overhead with the</source>
          <target state="translated">C ++ 11和OpenMP标准允许 &lt;code&gt;thread_local&lt;/code&gt; 和 &lt;code&gt;threadprivate&lt;/code&gt; 具有动态（运行时）初始化的变量。为了支持这一点，对此类变量的任何使用都将通过执行任何必要的初始化的包装函数。当变量的使用和定义位于同一转换单元中时，可以优化此开销，但是当变量位于不同的转换单元中时，即使该变量实际上不需要动态初始化，也存在相当大的开销。如果程序员可以确定在未定义的TU中不需要使用该变量来触发动态初始化（要么是因为该变量是静态初始化的，要么是在定义的TU中使用了该变量的使用，然后才能在另一个TU中使用该变量。 TU），他们可以通过</target>
        </trans-unit>
        <trans-unit id="da8ab7209d2ba607c1022648449bd576dc30ecb4" translate="yes" xml:space="preserve">
          <source>The C++17 standard will define the order of evaluation of operands in more cases: in particular it requires that the right-hand side of an assignment be evaluated before the left-hand side, so the above examples are no longer undefined. But this option will still warn about them, to help people avoid writing code that is undefined in C and earlier revisions of C++.</source>
          <target state="translated">C++17标准将在更多的情况下定义操作数的评估顺序:特别是它要求赋值的右手边必须在左手边之前进行评估,所以上面的例子不再是未定义的。但这个选项仍然会对它们发出警告,以帮助人们避免写出在C和C++早期版本中未定义的代码。</target>
        </trans-unit>
        <trans-unit id="463aa5596934552e20b1c86daa9eff2befcfafd9" translate="yes" xml:space="preserve">
          <source>The C++17 standard will define the order of evaluation of operands in more cases: in particular it requires that the right-hand side of an assignment be evaluated before the left-hand side, so the above examples are no longer undefined. But this warning will still warn about them, to help people avoid writing code that is undefined in C and earlier revisions of C++.</source>
          <target state="translated">C++17标准将在更多的情况下定义操作数的评估顺序:特别是它要求赋值的右手边必须先于左手边进行评估,所以上面的例子不再是未定义的。但这个警告仍然会对它们提出警告,以帮助人们避免写出在C和C++早期修订版中未定义的代码。</target>
        </trans-unit>
        <trans-unit id="3f8518a5ffcdc724e580f436c8e8861c47a79dbf" translate="yes" xml:space="preserve">
          <source>The CC register.</source>
          <target state="translated">CC登记册;</target>
        </trans-unit>
        <trans-unit id="aac83138ffc7dedbba141af64e9e3833a7581060" translate="yes" xml:space="preserve">
          <source>The Cyclic Redundancy Check (CRC) instructions.</source>
          <target state="translated">循环冗余检查(CRC)指令。</target>
        </trans-unit>
        <trans-unit id="26d3b88b25735a58406b058569b742cd7ef6e371" translate="yes" xml:space="preserve">
          <source>The DSP instructions.</source>
          <target state="translated">DSP指令。</target>
        </trans-unit>
        <trans-unit id="8a394fdb5f659a018583a4b282fa046a537ed960" translate="yes" xml:space="preserve">
          <source>The Darwin tools vary in their behavior when presented with an ISA mismatch. The assembler,</source>
          <target state="translated">当出现ISA不匹配时,达尔文工具的行为各不相同。汇编器。</target>
        </trans-unit>
        <trans-unit id="c474ab61fc35bcc3be354a3a5837d9c0d40e8830" translate="yes" xml:space="preserve">
          <source>The GCC port for AArch64 only supports the IEEE 754-2008 format, and does not require use of the</source>
          <target state="translated">AArch64的GCC端口只支持IEEE 754-2008格式,不需要使用</target>
        </trans-unit>
        <trans-unit id="0079c12261c57d6bab6a15c723b1304a15531596" translate="yes" xml:space="preserve">
          <source>The GNU C compiler supports both dialects; you can specify the signed dialect with</source>
          <target state="translated">GNU C编译器支持这两种方言;你可以使用</target>
        </trans-unit>
        <trans-unit id="9a9482fb99a743f48dbd7859a7e8e12b5401b580" translate="yes" xml:space="preserve">
          <source>The GNU C preprocessor recognizes several pragmas in addition to the compiler pragmas documented here. Refer to the CPP manual for more information.</source>
          <target state="translated">GNU C预处理器除了这里记录的编译器语法外,还能识别一些语法。更多信息请参考CPP手册。</target>
        </trans-unit>
        <trans-unit id="0227d0ba5f10912bdc54f8efb32ad7ab5a1942f8" translate="yes" xml:space="preserve">
          <source>The GNU Objective-C runtime provides a hook, called &lt;code&gt;__objc_msg_forward2&lt;/code&gt;, which is called by &lt;code&gt;objc_msg_lookup()&lt;/code&gt; when it cannot find a method implementation in the runtime tables and after calling &lt;code&gt;+resolveInstanceMethod:&lt;/code&gt; and &lt;code&gt;+resolveClassMethod:&lt;/code&gt; has been attempted and did not succeed in dynamically registering the method.</source>
          <target state="translated">GNU Objective-C运行时提供了一个名为 &lt;code&gt;__objc_msg_forward2&lt;/code&gt; 的钩子，当它无法在运行时表中找到方法实现时，并且尝试了 &lt;code&gt;+resolveInstanceMethod:&lt;/code&gt; 和 &lt;code&gt;+resolveClassMethod:&lt;/code&gt; 之后，尝试了该钩子，并由 &lt;code&gt;objc_msg_lookup()&lt;/code&gt; 调用了该钩子，并且没有成功地动态完成注册方法。</target>
        </trans-unit>
        <trans-unit id="c32c2c0d5cf1c06ca2fc7f8fc5108f046c90f6d6" translate="yes" xml:space="preserve">
          <source>The GNU Objective-C runtime provides a way that allows you to execute code before the execution of the program enters the &lt;code&gt;main&lt;/code&gt; function. The code is executed on a per-class and a per-category basis, through a special class method &lt;code&gt;+load&lt;/code&gt;.</source>
          <target state="translated">GNU Objective-C运行时提供了一种方法，允许您在程序执行进入 &lt;code&gt;main&lt;/code&gt; 函数之前执行代码。通过特殊的类方法 &lt;code&gt;+load&lt;/code&gt; ，可以按类别和类别执行代码。</target>
        </trans-unit>
        <trans-unit id="6204b4438d0b4bf08e65cf328298ab3f8520d1f5" translate="yes" xml:space="preserve">
          <source>The GNU Objective-C runtime provides an API that allows you to interact with the Objective-C runtime system, querying the live runtime structures and even manipulating them. This allows you for example to inspect and navigate classes, methods and protocols; to define new classes or new methods, and even to modify existing classes or protocols.</source>
          <target state="translated">GNU Objective-C运行时提供了一个API,它允许你与Objective-C运行时系统进行交互,查询实时运行时结构,甚至操作它们。例如,你可以检查和浏览类、方法和协议;定义新的类或新的方法,甚至修改现有的类或协议。</target>
        </trans-unit>
        <trans-unit id="4882007657bbd3b9904317ecd7c9122b201adae0" translate="yes" xml:space="preserve">
          <source>The GNU Objective-C runtime provides an API which is similar to the one provided by the &amp;ldquo;Objective-C 2.0&amp;rdquo; Apple/NeXT Objective-C runtime. The API is documented in the public header files of the GNU Objective-C runtime:</source>
          <target state="translated">GNU Objective-C运行时提供的API与&amp;ldquo; Objective-C 2.0&amp;rdquo; Apple / NeXT Objective-C运行时提供的API相似。该API记录在GNU Objective-C运行时的公共头文件中：</target>
        </trans-unit>
        <trans-unit id="bda523f70e2cc81aec3a5420312f2dc14631e90d" translate="yes" xml:space="preserve">
          <source>The GNU Objective-C runtime used to provide a different API, which we call the &amp;ldquo;traditional&amp;rdquo; GNU Objective-C runtime API. Functions belonging to this API are easy to recognize because they use a different naming convention, such as &lt;code&gt;class_get_super_class()&lt;/code&gt; (traditional API) instead of &lt;code&gt;class_getSuperclass()&lt;/code&gt; (modern API). Software using this API includes the file</source>
          <target state="translated">用来提供不同API的GNU Objective-C运行时API，我们称为&amp;ldquo;传统&amp;rdquo; GNU Objective-C运行时API。属于此API的函数很容易识别，因为它们使用不同的命名约定，例如 &lt;code&gt;class_get_super_class()&lt;/code&gt; （传统API）而不是 &lt;code&gt;class_getSuperclass()&lt;/code&gt; （现代API）。使用此API的软件包含该文件</target>
        </trans-unit>
        <trans-unit id="a580b32a37e3e1afb84412437056129293c1db6e" translate="yes" xml:space="preserve">
          <source>The GNU Project and GNU/Linux</source>
          <target state="translated">GNU项目和GNU/Linux</target>
        </trans-unit>
        <trans-unit id="fbf08e863571f4a8147fed0d98f89d3a6cc1c1c5" translate="yes" xml:space="preserve">
          <source>The GNU Project and GNU/Linux.</source>
          <target state="translated">GNU项目和GNU/Linux。</target>
        </trans-unit>
        <trans-unit id="565581be4558eda62440473a382dca36e2293950" translate="yes" xml:space="preserve">
          <source>The GNU compiler can produce two kinds of diagnostics: errors and warnings. Each kind has a different purpose:</source>
          <target state="translated">GNU编译器可以产生两种诊断程序:错误和警告。每种诊断都有不同的目的。</target>
        </trans-unit>
        <trans-unit id="0ef6aa50a29b9e95c494d3259dc5f4a2758d594d" translate="yes" xml:space="preserve">
          <source>The GNU compiler provides these extensions to the C++ language (and you can also use most of the C language extensions in your C++ programs). If you want to write code that checks whether these features are available, you can test for the GNU compiler the same way as for C programs: check for a predefined macro &lt;code&gt;__GNUC__&lt;/code&gt;. You can also use &lt;code&gt;__GNUG__&lt;/code&gt; to test specifically for GNU C++ (see &lt;a href=&quot;http://gcc.gnu.org/onlinedocs/cpp/Common-Predefined-Macros.html#Common-Predefined-Macros&quot;&gt;Predefined Macros&lt;/a&gt; in The GNU C Preprocessor).</source>
          <target state="translated">GNU编译器提供了C ++语言的这些扩展（您也可以在C ++程序中使用大多数C语言扩展）。如果要编写代码来检查这些功能是否可用，则可以使用与C程序相同的方式测试GNU编译器：检查预定义的宏 &lt;code&gt;__GNUC__&lt;/code&gt; 。您还可以使用 &lt;code&gt;__GNUG__&lt;/code&gt; 专门针对GNU C ++进行测试（请参见GNU C预处理程序中的&lt;a href=&quot;http://gcc.gnu.org/onlinedocs/cpp/Common-Predefined-Macros.html#Common-Predefined-Macros&quot;&gt;预定义宏&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="fdd4d4c02d395886b71e823798e0aedf04f540c0" translate="yes" xml:space="preserve">
          <source>The GNU linker (beginning with version 2.16) has the necessary support for this option. If your linker does not support this option, the header file aspect of</source>
          <target state="translated">GNU linker(从2.16版本开始)对这个选项有必要的支持。如果你的链接器不支持这个选项,则在</target>
        </trans-unit>
        <trans-unit id="649e8f725ce325928e9d3758e5501f5eb08d8098" translate="yes" xml:space="preserve">
          <source>The HP-UX implementation of setlocale in libc has a dependency on libdld.sl. There isn&amp;rsquo;t an archive version of libdld.sl. Thus, when the</source>
          <target state="translated">libc中setlocale的HP-UX实现依赖于libdld.sl。没有libdld.sl的存档版本。因此，当</target>
        </trans-unit>
        <trans-unit id="e6712fd16e48687aa09a28dcd06ca5cfec22cf46" translate="yes" xml:space="preserve">
          <source>The HTM builtins (with the exception of &lt;code&gt;__builtin_tbegin&lt;/code&gt;) return the full 4-bit condition register value set by their associated hardware instruction. The header file &lt;code&gt;htmintrin.h&lt;/code&gt; defines some macros that can be used to decipher the return value. The &lt;code&gt;__builtin_tbegin&lt;/code&gt; builtin returns a simple &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt; value depending on whether a transaction was successfully started or not. The arguments of the builtins match exactly the type and order of the associated hardware instruction&amp;rsquo;s operands, except for the &lt;code&gt;__builtin_tcheck&lt;/code&gt; builtin, which does not take any input arguments. Refer to the ISA manual for a description of each instruction&amp;rsquo;s operands.</source>
          <target state="translated">HTM内置函数（ &lt;code&gt;__builtin_tbegin&lt;/code&gt; 除外）将返回由其关联的硬件指令设置的完整4位条件寄存器值。头文件 &lt;code&gt;htmintrin.h&lt;/code&gt; 定义了一些可用于解密返回值的宏。该 &lt;code&gt;__builtin_tbegin&lt;/code&gt; 内置一个简单的返回 &lt;code&gt;true&lt;/code&gt; 或 &lt;code&gt;false&lt;/code&gt; 取决于交易是否成功启动或没有价值。内置的参数与关联的硬件指令的操作数的类型和顺序完全匹配，除了 &lt;code&gt;__builtin_tcheck&lt;/code&gt; 内置的参数外，该参数不接受任何输入参数。有关每个指令的操作数的说明，请参阅ISA手册。</target>
        </trans-unit>
        <trans-unit id="87dbb117c6f13df65961818e4b7b41562cf362b8" translate="yes" xml:space="preserve">
          <source>The IA-64 back end supports the following variable attribute:</source>
          <target state="translated">IA-64后端支持以下变量属性。</target>
        </trans-unit>
        <trans-unit id="03f6d255f23aeee8dc7ee63e3c04d489d6fd6b28" translate="yes" xml:space="preserve">
          <source>The ISA and hardware multiply supported for the different MCUs is hard-coded into GCC. However, an external &amp;lsquo;</source>
          <target state="translated">不同MCU支持的ISA和硬件乘法被硬编码到GCC中。但是，外部&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="a2f39a7601ef937b791997651319caebaf1d1db8" translate="yes" xml:space="preserve">
          <source>The ISO C standard defines (in clause 4) two classes of conforming implementation. A &lt;em&gt;conforming hosted implementation&lt;/em&gt; supports the whole standard including all the library facilities; a &lt;em&gt;conforming freestanding implementation&lt;/em&gt; is only required to provide certain library facilities: those in &lt;code&gt;&amp;lt;float.h&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;limits.h&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;stdarg.h&amp;gt;&lt;/code&gt;, and &lt;code&gt;&amp;lt;stddef.h&amp;gt;&lt;/code&gt;; since AMD1, also those in &lt;code&gt;&amp;lt;iso646.h&amp;gt;&lt;/code&gt;; since C99, also those in &lt;code&gt;&amp;lt;stdbool.h&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;stdint.h&amp;gt;&lt;/code&gt;; and since C11, also those in &lt;code&gt;&amp;lt;stdalign.h&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;stdnoreturn.h&amp;gt;&lt;/code&gt;. In addition, complex types, added in C99, are not required for freestanding implementations.</source>
          <target state="translated">ISO C标准定义（在第4节中）两类符合性的实现。一个&lt;em&gt;符合托管实现&lt;/em&gt;支持整个标准包括所有图书馆设施; 仅需提供某些库工具即可使用&lt;em&gt;符合标准的独立实现&lt;/em&gt;： &lt;code&gt;&amp;lt;float.h&amp;gt;&lt;/code&gt; ， &lt;code&gt;&amp;lt;limits.h&amp;gt;&lt;/code&gt; ， &lt;code&gt;&amp;lt;stdarg.h&amp;gt;&lt;/code&gt; 和 &lt;code&gt;&amp;lt;stddef.h&amp;gt;&lt;/code&gt; 中的那些库；从AMD1开始， &lt;code&gt;&amp;lt;iso646.h&amp;gt;&lt;/code&gt; 中的那些；从C99开始， &lt;code&gt;&amp;lt;stdbool.h&amp;gt;&lt;/code&gt; 和 &lt;code&gt;&amp;lt;stdint.h&amp;gt;&lt;/code&gt; 中的那些也开始；从C11开始， &lt;code&gt;&amp;lt;stdalign.h&amp;gt;&lt;/code&gt; 和 &lt;code&gt;&amp;lt;stdnoreturn.h&amp;gt;&lt;/code&gt; 中的那些。此外，独立实现不需要C99中添加的复杂类型。</target>
        </trans-unit>
        <trans-unit id="4df8e4ece265376ae0055a7b2b932c764c91156b" translate="yes" xml:space="preserve">
          <source>The ISO C standard leaves it up to the implementation whether a bit-field declared plain &lt;code&gt;int&lt;/code&gt; is signed or not. This in effect creates two alternative dialects of C.</source>
          <target state="translated">无论是否声明了声明为plain &lt;code&gt;int&lt;/code&gt; 的位字段，ISO C标准都将其留给实现。实际上，这创建了C的两个替代方言。</target>
        </trans-unit>
        <trans-unit id="bced80c01ede6829408bc604cd122f3ce07d3569" translate="yes" xml:space="preserve">
          <source>The ISO C++14 library also defines the &amp;lsquo;</source>
          <target state="translated">ISO C ++ 14库还定义了&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="de0f27c3596685d686fd3d285d5ba869620aa947" translate="yes" xml:space="preserve">
          <source>The ISO C90 functions &lt;code&gt;abort&lt;/code&gt;, &lt;code&gt;abs&lt;/code&gt;, &lt;code&gt;acos&lt;/code&gt;, &lt;code&gt;asin&lt;/code&gt;, &lt;code&gt;atan2&lt;/code&gt;, &lt;code&gt;atan&lt;/code&gt;, &lt;code&gt;calloc&lt;/code&gt;, &lt;code&gt;ceil&lt;/code&gt;, &lt;code&gt;cosh&lt;/code&gt;, &lt;code&gt;cos&lt;/code&gt;, &lt;code&gt;exit&lt;/code&gt;, &lt;code&gt;exp&lt;/code&gt;, &lt;code&gt;fabs&lt;/code&gt;, &lt;code&gt;floor&lt;/code&gt;, &lt;code&gt;fmod&lt;/code&gt;, &lt;code&gt;fprintf&lt;/code&gt;, &lt;code&gt;fputs&lt;/code&gt;, &lt;code&gt;free&lt;/code&gt;, &lt;code&gt;frexp&lt;/code&gt;, &lt;code&gt;fscanf&lt;/code&gt;, &lt;code&gt;isalnum&lt;/code&gt;, &lt;code&gt;isalpha&lt;/code&gt;, &lt;code&gt;iscntrl&lt;/code&gt;, &lt;code&gt;isdigit&lt;/code&gt;, &lt;code&gt;isgraph&lt;/code&gt;, &lt;code&gt;islower&lt;/code&gt;, &lt;code&gt;isprint&lt;/code&gt;, &lt;code&gt;ispunct&lt;/code&gt;, &lt;code&gt;isspace&lt;/code&gt;, &lt;code&gt;isupper&lt;/code&gt;, &lt;code&gt;isxdigit&lt;/code&gt;, &lt;code&gt;tolower&lt;/code&gt;, &lt;code&gt;toupper&lt;/code&gt;, &lt;code&gt;labs&lt;/code&gt;, &lt;code&gt;ldexp&lt;/code&gt;, &lt;code&gt;log10&lt;/code&gt;, &lt;code&gt;log&lt;/code&gt;, &lt;code&gt;malloc&lt;/code&gt;, &lt;code&gt;memchr&lt;/code&gt;, &lt;code&gt;memcmp&lt;/code&gt;, &lt;code&gt;memcpy&lt;/code&gt;, &lt;code&gt;memset&lt;/code&gt;, &lt;code&gt;modf&lt;/code&gt;, &lt;code&gt;pow&lt;/code&gt;, &lt;code&gt;printf&lt;/code&gt;, &lt;code&gt;putchar&lt;/code&gt;, &lt;code&gt;puts&lt;/code&gt;, &lt;code&gt;realloc&lt;/code&gt;, &lt;code&gt;scanf&lt;/code&gt;, &lt;code&gt;sinh&lt;/code&gt;, &lt;code&gt;sin&lt;/code&gt;, &lt;code&gt;snprintf&lt;/code&gt;, &lt;code&gt;sprintf&lt;/code&gt;, &lt;code&gt;sqrt&lt;/code&gt;, &lt;code&gt;sscanf&lt;/code&gt;, &lt;code&gt;strcat&lt;/code&gt;, &lt;code&gt;strchr&lt;/code&gt;, &lt;code&gt;strcmp&lt;/code&gt;, &lt;code&gt;strcpy&lt;/code&gt;, &lt;code&gt;strcspn&lt;/code&gt;, &lt;code&gt;strlen&lt;/code&gt;, &lt;code&gt;strncat&lt;/code&gt;, &lt;code&gt;strncmp&lt;/code&gt;, &lt;code&gt;strncpy&lt;/code&gt;, &lt;code&gt;strpbrk&lt;/code&gt;, &lt;code&gt;strrchr&lt;/code&gt;, &lt;code&gt;strspn&lt;/code&gt;, &lt;code&gt;strstr&lt;/code&gt;, &lt;code&gt;tanh&lt;/code&gt;, &lt;code&gt;tan&lt;/code&gt;, &lt;code&gt;vfprintf&lt;/code&gt;, &lt;code&gt;vprintf&lt;/code&gt; and &lt;code&gt;vsprintf&lt;/code&gt; are all recognized as built-in functions unless</source>
          <target state="translated">ISO C90函数 &lt;code&gt;abort&lt;/code&gt; ， &lt;code&gt;abs&lt;/code&gt; ， &lt;code&gt;acos&lt;/code&gt; ， &lt;code&gt;asin&lt;/code&gt; ， &lt;code&gt;atan2&lt;/code&gt; ， &lt;code&gt;atan&lt;/code&gt; ， &lt;code&gt;calloc&lt;/code&gt; ， &lt;code&gt;ceil&lt;/code&gt; ， &lt;code&gt;cosh&lt;/code&gt; ， &lt;code&gt;cos&lt;/code&gt; ， &lt;code&gt;exit&lt;/code&gt; ， &lt;code&gt;exp&lt;/code&gt; ， &lt;code&gt;fabs&lt;/code&gt; ， &lt;code&gt;floor&lt;/code&gt; ， &lt;code&gt;fmod&lt;/code&gt; ， &lt;code&gt;fprintf&lt;/code&gt; ， &lt;code&gt;fputs&lt;/code&gt; ， &lt;code&gt;free&lt;/code&gt; ， &lt;code&gt;frexp&lt;/code&gt; ， &lt;code&gt;fscanf&lt;/code&gt; ， &lt;code&gt;isalnum&lt;/code&gt; ， &lt;code&gt;isalpha&lt;/code&gt; ， &lt;code&gt;iscntrl&lt;/code&gt; ， &lt;code&gt;isdigit&lt;/code&gt; ， &lt;code&gt;isgraph&lt;/code&gt; ， &lt;code&gt;islower&lt;/code&gt; ， &lt;code&gt;isprint&lt;/code&gt; ， &lt;code&gt;ispunct&lt;/code&gt; ， &lt;code&gt;isspace&lt;/code&gt; ， &lt;code&gt;isupper&lt;/code&gt; ， &lt;code&gt;isxdigit&lt;/code&gt; ， &lt;code&gt;tolower&lt;/code&gt; ， &lt;code&gt;toupper&lt;/code&gt; ， &lt;code&gt;labs&lt;/code&gt; ， &lt;code&gt;ldexp&lt;/code&gt; ， &lt;code&gt;log10&lt;/code&gt; ， &lt;code&gt;log&lt;/code&gt; ， &lt;code&gt;malloc&lt;/code&gt; ， &lt;code&gt;memchr&lt;/code&gt; ， &lt;code&gt;memcmp&lt;/code&gt; ， &lt;code&gt;memcpy&lt;/code&gt; ， &lt;code&gt;memset&lt;/code&gt; ， &lt;code&gt;modf&lt;/code&gt; ， &lt;code&gt;pow&lt;/code&gt; ， &lt;code&gt;printf&lt;/code&gt; ， &lt;code&gt;putchar&lt;/code&gt; ， &lt;code&gt;puts&lt;/code&gt; ，puts， &lt;code&gt;realloc&lt;/code&gt; ， &lt;code&gt;scanf&lt;/code&gt; ， &lt;code&gt;sinh&lt;/code&gt; ， &lt;code&gt;sin&lt;/code&gt; ， &lt;code&gt;snprintf&lt;/code&gt; ， &lt;code&gt;sprintf&lt;/code&gt; 的， &lt;code&gt;sqrt&lt;/code&gt; ， &lt;code&gt;sscanf&lt;/code&gt; 的， &lt;code&gt;strcat&lt;/code&gt; 的， &lt;code&gt;strchr&lt;/code&gt; ， &lt;code&gt;strcmp&lt;/code&gt; ， &lt;code&gt;strcpy&lt;/code&gt; 的， &lt;code&gt;strcspn&lt;/code&gt; ， &lt;code&gt;strlen&lt;/code&gt; 的， &lt;code&gt;strncat&lt;/code&gt; 函数， &lt;code&gt;strncmp&lt;/code&gt; ， &lt;code&gt;strncpy&lt;/code&gt; ()函数， &lt;code&gt;strpbrk&lt;/code&gt; ， &lt;code&gt;strrchr&lt;/code&gt; ， &lt;code&gt;strspn&lt;/code&gt; ， &lt;code&gt;strstr&lt;/code&gt; ， &lt;code&gt;tanh&lt;/code&gt; ， &lt;code&gt;tan&lt;/code&gt; ， &lt;code&gt;vfprintf&lt;/code&gt; ， &lt;code&gt;vprintf&lt;/code&gt; 和 &lt;code&gt;vsprintf&lt;/code&gt; 中都被认定为内置在功能上除非</target>
        </trans-unit>
        <trans-unit id="67ca06952bac1aee629481893fc1242a0df75d20" translate="yes" xml:space="preserve">
          <source>The ISO C90 functions &lt;code&gt;abort&lt;/code&gt;, &lt;code&gt;abs&lt;/code&gt;, &lt;code&gt;acos&lt;/code&gt;, &lt;code&gt;asin&lt;/code&gt;, &lt;code&gt;atan2&lt;/code&gt;, &lt;code&gt;atan&lt;/code&gt;, &lt;code&gt;calloc&lt;/code&gt;, &lt;code&gt;ceil&lt;/code&gt;, &lt;code&gt;cosh&lt;/code&gt;, &lt;code&gt;cos&lt;/code&gt;, &lt;code&gt;exit&lt;/code&gt;, &lt;code&gt;exp&lt;/code&gt;, &lt;code&gt;fabs&lt;/code&gt;, &lt;code&gt;floor&lt;/code&gt;, &lt;code&gt;fmod&lt;/code&gt;, &lt;code&gt;fprintf&lt;/code&gt;, &lt;code&gt;fputs&lt;/code&gt;, &lt;code&gt;frexp&lt;/code&gt;, &lt;code&gt;fscanf&lt;/code&gt;, &lt;code&gt;isalnum&lt;/code&gt;, &lt;code&gt;isalpha&lt;/code&gt;, &lt;code&gt;iscntrl&lt;/code&gt;, &lt;code&gt;isdigit&lt;/code&gt;, &lt;code&gt;isgraph&lt;/code&gt;, &lt;code&gt;islower&lt;/code&gt;, &lt;code&gt;isprint&lt;/code&gt;, &lt;code&gt;ispunct&lt;/code&gt;, &lt;code&gt;isspace&lt;/code&gt;, &lt;code&gt;isupper&lt;/code&gt;, &lt;code&gt;isxdigit&lt;/code&gt;, &lt;code&gt;tolower&lt;/code&gt;, &lt;code&gt;toupper&lt;/code&gt;, &lt;code&gt;labs&lt;/code&gt;, &lt;code&gt;ldexp&lt;/code&gt;, &lt;code&gt;log10&lt;/code&gt;, &lt;code&gt;log&lt;/code&gt;, &lt;code&gt;malloc&lt;/code&gt;, &lt;code&gt;memchr&lt;/code&gt;, &lt;code&gt;memcmp&lt;/code&gt;, &lt;code&gt;memcpy&lt;/code&gt;, &lt;code&gt;memset&lt;/code&gt;, &lt;code&gt;modf&lt;/code&gt;, &lt;code&gt;pow&lt;/code&gt;, &lt;code&gt;printf&lt;/code&gt;, &lt;code&gt;putchar&lt;/code&gt;, &lt;code&gt;puts&lt;/code&gt;, &lt;code&gt;scanf&lt;/code&gt;, &lt;code&gt;sinh&lt;/code&gt;, &lt;code&gt;sin&lt;/code&gt;, &lt;code&gt;snprintf&lt;/code&gt;, &lt;code&gt;sprintf&lt;/code&gt;, &lt;code&gt;sqrt&lt;/code&gt;, &lt;code&gt;sscanf&lt;/code&gt;, &lt;code&gt;strcat&lt;/code&gt;, &lt;code&gt;strchr&lt;/code&gt;, &lt;code&gt;strcmp&lt;/code&gt;, &lt;code&gt;strcpy&lt;/code&gt;, &lt;code&gt;strcspn&lt;/code&gt;, &lt;code&gt;strlen&lt;/code&gt;, &lt;code&gt;strncat&lt;/code&gt;, &lt;code&gt;strncmp&lt;/code&gt;, &lt;code&gt;strncpy&lt;/code&gt;, &lt;code&gt;strpbrk&lt;/code&gt;, &lt;code&gt;strrchr&lt;/code&gt;, &lt;code&gt;strspn&lt;/code&gt;, &lt;code&gt;strstr&lt;/code&gt;, &lt;code&gt;tanh&lt;/code&gt;, &lt;code&gt;tan&lt;/code&gt;, &lt;code&gt;vfprintf&lt;/code&gt;, &lt;code&gt;vprintf&lt;/code&gt; and &lt;code&gt;vsprintf&lt;/code&gt; are all recognized as built-in functions unless</source>
          <target state="translated">ISO C90函数 &lt;code&gt;abort&lt;/code&gt; ， &lt;code&gt;abs&lt;/code&gt; ， &lt;code&gt;acos&lt;/code&gt; ， &lt;code&gt;asin&lt;/code&gt; ， &lt;code&gt;atan2&lt;/code&gt; ， &lt;code&gt;atan&lt;/code&gt; ， &lt;code&gt;calloc&lt;/code&gt; ， &lt;code&gt;ceil&lt;/code&gt; ， &lt;code&gt;cosh&lt;/code&gt; ， &lt;code&gt;cos&lt;/code&gt; ， &lt;code&gt;exit&lt;/code&gt; ， &lt;code&gt;exp&lt;/code&gt; ， &lt;code&gt;fabs&lt;/code&gt; ， &lt;code&gt;floor&lt;/code&gt; ， &lt;code&gt;fmod&lt;/code&gt; ， &lt;code&gt;fprintf&lt;/code&gt; ， &lt;code&gt;fputs&lt;/code&gt; ， &lt;code&gt;frexp&lt;/code&gt; ， &lt;code&gt;fscanf&lt;/code&gt; ， &lt;code&gt;isalnum&lt;/code&gt; ， &lt;code&gt;isalpha&lt;/code&gt; ， &lt;code&gt;iscntrl&lt;/code&gt; ， &lt;code&gt;isdigit&lt;/code&gt; ， &lt;code&gt;isgraph&lt;/code&gt; ， &lt;code&gt;islower&lt;/code&gt; 判断， &lt;code&gt;isprint&lt;/code&gt; ， &lt;code&gt;ispunct&lt;/code&gt; ， &lt;code&gt;isspace&lt;/code&gt; ， &lt;code&gt;isupper&lt;/code&gt; ， &lt;code&gt;isxdigit&lt;/code&gt; ， &lt;code&gt;tolower&lt;/code&gt; ， &lt;code&gt;toupper&lt;/code&gt; ， &lt;code&gt;labs&lt;/code&gt; ， &lt;code&gt;ldexp&lt;/code&gt; ， &lt;code&gt;log10&lt;/code&gt; ， &lt;code&gt;log&lt;/code&gt; ， &lt;code&gt;malloc&lt;/code&gt; ， &lt;code&gt;memchr&lt;/code&gt; ， &lt;code&gt;memcmp&lt;/code&gt; ， &lt;code&gt;memcpy&lt;/code&gt; ， &lt;code&gt;memset&lt;/code&gt; ， &lt;code&gt;modf&lt;/code&gt; ， &lt;code&gt;pow&lt;/code&gt; ， &lt;code&gt;printf&lt;/code&gt; ， &lt;code&gt;putchar&lt;/code&gt; ， &lt;code&gt;puts&lt;/code&gt; ， &lt;code&gt;scanf&lt;/code&gt; ， &lt;code&gt;sinh&lt;/code&gt; ， &lt;code&gt;sin&lt;/code&gt; ， &lt;code&gt;snprintf&lt;/code&gt; ， &lt;code&gt;sprintf&lt;/code&gt; 的， &lt;code&gt;sqrt&lt;/code&gt; ， &lt;code&gt;sscanf&lt;/code&gt; 的， &lt;code&gt;strcat&lt;/code&gt; 的， &lt;code&gt;strchr&lt;/code&gt; ， &lt;code&gt;strcmp&lt;/code&gt; ， &lt;code&gt;strcpy&lt;/code&gt; 的， &lt;code&gt;strcspn&lt;/code&gt; ， &lt;code&gt;strlen&lt;/code&gt; 的， &lt;code&gt;strncat&lt;/code&gt; 函数， &lt;code&gt;strncmp&lt;/code&gt; ， &lt;code&gt;strncpy&lt;/code&gt; ()函数， &lt;code&gt;strpbrk&lt;/code&gt; ， &lt;code&gt;strrchr&lt;/code&gt; ， &lt;code&gt;strspn&lt;/code&gt; ， &lt;code&gt;strstr&lt;/code&gt; ， &lt;code&gt;tanh&lt;/code&gt; ， &lt;code&gt;tan&lt;/code&gt; ， &lt;code&gt;vfprintf&lt;/code&gt; ， &lt;code&gt;vprintf&lt;/code&gt; 和 &lt;code&gt;vsprintf&lt;/code&gt; 中都被认为是内置的功能，除非</target>
        </trans-unit>
        <trans-unit id="ae47f0c159fa493b3beadffa3ea4146c32c1e50a" translate="yes" xml:space="preserve">
          <source>The ISO C94 functions &lt;code&gt;iswalnum&lt;/code&gt;, &lt;code&gt;iswalpha&lt;/code&gt;, &lt;code&gt;iswcntrl&lt;/code&gt;, &lt;code&gt;iswdigit&lt;/code&gt;, &lt;code&gt;iswgraph&lt;/code&gt;, &lt;code&gt;iswlower&lt;/code&gt;, &lt;code&gt;iswprint&lt;/code&gt;, &lt;code&gt;iswpunct&lt;/code&gt;, &lt;code&gt;iswspace&lt;/code&gt;, &lt;code&gt;iswupper&lt;/code&gt;, &lt;code&gt;iswxdigit&lt;/code&gt;, &lt;code&gt;towlower&lt;/code&gt; and &lt;code&gt;towupper&lt;/code&gt; are handled as built-in functions except in strict ISO C90 mode (</source>
          <target state="translated">ISO C94函数 &lt;code&gt;iswalnum&lt;/code&gt; ， &lt;code&gt;iswalpha&lt;/code&gt; ， &lt;code&gt;iswcntrl&lt;/code&gt; ， &lt;code&gt;iswdigit&lt;/code&gt; ， &lt;code&gt;iswgraph&lt;/code&gt; ， &lt;code&gt;iswlower&lt;/code&gt; ， &lt;code&gt;iswprint&lt;/code&gt; ， &lt;code&gt;iswpunct&lt;/code&gt; ， &lt;code&gt;iswspace&lt;/code&gt; ， &lt;code&gt;iswupper&lt;/code&gt; ， &lt;code&gt;iswxdigit&lt;/code&gt; ， &lt;code&gt;towlower&lt;/code&gt; 和 &lt;code&gt;towupper&lt;/code&gt; 被视为内置函数，但在严格的ISO C90模式下除外（</target>
        </trans-unit>
        <trans-unit id="6cca21d213324c7eb2448728bd34ae61f7e19024" translate="yes" xml:space="preserve">
          <source>The ISO C99 functions &lt;code&gt;_Exit&lt;/code&gt;, &lt;code&gt;acoshf&lt;/code&gt;, &lt;code&gt;acoshl&lt;/code&gt;, &lt;code&gt;acosh&lt;/code&gt;, &lt;code&gt;asinhf&lt;/code&gt;, &lt;code&gt;asinhl&lt;/code&gt;, &lt;code&gt;asinh&lt;/code&gt;, &lt;code&gt;atanhf&lt;/code&gt;, &lt;code&gt;atanhl&lt;/code&gt;, &lt;code&gt;atanh&lt;/code&gt;, &lt;code&gt;cabsf&lt;/code&gt;, &lt;code&gt;cabsl&lt;/code&gt;, &lt;code&gt;cabs&lt;/code&gt;, &lt;code&gt;cacosf&lt;/code&gt;, &lt;code&gt;cacoshf&lt;/code&gt;, &lt;code&gt;cacoshl&lt;/code&gt;, &lt;code&gt;cacosh&lt;/code&gt;, &lt;code&gt;cacosl&lt;/code&gt;, &lt;code&gt;cacos&lt;/code&gt;, &lt;code&gt;cargf&lt;/code&gt;, &lt;code&gt;cargl&lt;/code&gt;, &lt;code&gt;carg&lt;/code&gt;, &lt;code&gt;casinf&lt;/code&gt;, &lt;code&gt;casinhf&lt;/code&gt;, &lt;code&gt;casinhl&lt;/code&gt;, &lt;code&gt;casinh&lt;/code&gt;, &lt;code&gt;casinl&lt;/code&gt;, &lt;code&gt;casin&lt;/code&gt;, &lt;code&gt;catanf&lt;/code&gt;, &lt;code&gt;catanhf&lt;/code&gt;, &lt;code&gt;catanhl&lt;/code&gt;, &lt;code&gt;catanh&lt;/code&gt;, &lt;code&gt;catanl&lt;/code&gt;, &lt;code&gt;catan&lt;/code&gt;, &lt;code&gt;cbrtf&lt;/code&gt;, &lt;code&gt;cbrtl&lt;/code&gt;, &lt;code&gt;cbrt&lt;/code&gt;, &lt;code&gt;ccosf&lt;/code&gt;, &lt;code&gt;ccoshf&lt;/code&gt;, &lt;code&gt;ccoshl&lt;/code&gt;, &lt;code&gt;ccosh&lt;/code&gt;, &lt;code&gt;ccosl&lt;/code&gt;, &lt;code&gt;ccos&lt;/code&gt;, &lt;code&gt;cexpf&lt;/code&gt;, &lt;code&gt;cexpl&lt;/code&gt;, &lt;code&gt;cexp&lt;/code&gt;, &lt;code&gt;cimagf&lt;/code&gt;, &lt;code&gt;cimagl&lt;/code&gt;, &lt;code&gt;cimag&lt;/code&gt;, &lt;code&gt;clogf&lt;/code&gt;, &lt;code&gt;clogl&lt;/code&gt;, &lt;code&gt;clog&lt;/code&gt;, &lt;code&gt;conjf&lt;/code&gt;, &lt;code&gt;conjl&lt;/code&gt;, &lt;code&gt;conj&lt;/code&gt;, &lt;code&gt;copysignf&lt;/code&gt;, &lt;code&gt;copysignl&lt;/code&gt;, &lt;code&gt;copysign&lt;/code&gt;, &lt;code&gt;cpowf&lt;/code&gt;, &lt;code&gt;cpowl&lt;/code&gt;, &lt;code&gt;cpow&lt;/code&gt;, &lt;code&gt;cprojf&lt;/code&gt;, &lt;code&gt;cprojl&lt;/code&gt;, &lt;code&gt;cproj&lt;/code&gt;, &lt;code&gt;crealf&lt;/code&gt;, &lt;code&gt;creall&lt;/code&gt;, &lt;code&gt;creal&lt;/code&gt;, &lt;code&gt;csinf&lt;/code&gt;, &lt;code&gt;csinhf&lt;/code&gt;, &lt;code&gt;csinhl&lt;/code&gt;, &lt;code&gt;csinh&lt;/code&gt;, &lt;code&gt;csinl&lt;/code&gt;, &lt;code&gt;csin&lt;/code&gt;, &lt;code&gt;csqrtf&lt;/code&gt;, &lt;code&gt;csqrtl&lt;/code&gt;, &lt;code&gt;csqrt&lt;/code&gt;, &lt;code&gt;ctanf&lt;/code&gt;, &lt;code&gt;ctanhf&lt;/code&gt;, &lt;code&gt;ctanhl&lt;/code&gt;, &lt;code&gt;ctanh&lt;/code&gt;, &lt;code&gt;ctanl&lt;/code&gt;, &lt;code&gt;ctan&lt;/code&gt;, &lt;code&gt;erfcf&lt;/code&gt;, &lt;code&gt;erfcl&lt;/code&gt;, &lt;code&gt;erfc&lt;/code&gt;, &lt;code&gt;erff&lt;/code&gt;, &lt;code&gt;erfl&lt;/code&gt;, &lt;code&gt;erf&lt;/code&gt;, &lt;code&gt;exp2f&lt;/code&gt;, &lt;code&gt;exp2l&lt;/code&gt;, &lt;code&gt;exp2&lt;/code&gt;, &lt;code&gt;expm1f&lt;/code&gt;, &lt;code&gt;expm1l&lt;/code&gt;, &lt;code&gt;expm1&lt;/code&gt;, &lt;code&gt;fdimf&lt;/code&gt;, &lt;code&gt;fdiml&lt;/code&gt;, &lt;code&gt;fdim&lt;/code&gt;, &lt;code&gt;fmaf&lt;/code&gt;, &lt;code&gt;fmal&lt;/code&gt;, &lt;code&gt;fmaxf&lt;/code&gt;, &lt;code&gt;fmaxl&lt;/code&gt;, &lt;code&gt;fmax&lt;/code&gt;, &lt;code&gt;fma&lt;/code&gt;, &lt;code&gt;fminf&lt;/code&gt;, &lt;code&gt;fminl&lt;/code&gt;, &lt;code&gt;fmin&lt;/code&gt;, &lt;code&gt;hypotf&lt;/code&gt;, &lt;code&gt;hypotl&lt;/code&gt;, &lt;code&gt;hypot&lt;/code&gt;, &lt;code&gt;ilogbf&lt;/code&gt;, &lt;code&gt;ilogbl&lt;/code&gt;, &lt;code&gt;ilogb&lt;/code&gt;, &lt;code&gt;imaxabs&lt;/code&gt;, &lt;code&gt;isblank&lt;/code&gt;, &lt;code&gt;iswblank&lt;/code&gt;, &lt;code&gt;lgammaf&lt;/code&gt;, &lt;code&gt;lgammal&lt;/code&gt;, &lt;code&gt;lgamma&lt;/code&gt;, &lt;code&gt;llabs&lt;/code&gt;, &lt;code&gt;llrintf&lt;/code&gt;, &lt;code&gt;llrintl&lt;/code&gt;, &lt;code&gt;llrint&lt;/code&gt;, &lt;code&gt;llroundf&lt;/code&gt;, &lt;code&gt;llroundl&lt;/code&gt;, &lt;code&gt;llround&lt;/code&gt;, &lt;code&gt;log1pf&lt;/code&gt;, &lt;code&gt;log1pl&lt;/code&gt;, &lt;code&gt;log1p&lt;/code&gt;, &lt;code&gt;log2f&lt;/code&gt;, &lt;code&gt;log2l&lt;/code&gt;, &lt;code&gt;log2&lt;/code&gt;, &lt;code&gt;logbf&lt;/code&gt;, &lt;code&gt;logbl&lt;/code&gt;, &lt;code&gt;logb&lt;/code&gt;, &lt;code&gt;lrintf&lt;/code&gt;, &lt;code&gt;lrintl&lt;/code&gt;, &lt;code&gt;lrint&lt;/code&gt;, &lt;code&gt;lroundf&lt;/code&gt;, &lt;code&gt;lroundl&lt;/code&gt;, &lt;code&gt;lround&lt;/code&gt;, &lt;code&gt;nearbyintf&lt;/code&gt;, &lt;code&gt;nearbyintl&lt;/code&gt;, &lt;code&gt;nearbyint&lt;/code&gt;, &lt;code&gt;nextafterf&lt;/code&gt;, &lt;code&gt;nextafterl&lt;/code&gt;, &lt;code&gt;nextafter&lt;/code&gt;, &lt;code&gt;nexttowardf&lt;/code&gt;, &lt;code&gt;nexttowardl&lt;/code&gt;, &lt;code&gt;nexttoward&lt;/code&gt;, &lt;code&gt;remainderf&lt;/code&gt;, &lt;code&gt;remainderl&lt;/code&gt;, &lt;code&gt;remainder&lt;/code&gt;, &lt;code&gt;remquof&lt;/code&gt;, &lt;code&gt;remquol&lt;/code&gt;, &lt;code&gt;remquo&lt;/code&gt;, &lt;code&gt;rintf&lt;/code&gt;, &lt;code&gt;rintl&lt;/code&gt;, &lt;code&gt;rint&lt;/code&gt;, &lt;code&gt;roundf&lt;/code&gt;, &lt;code&gt;roundl&lt;/code&gt;, &lt;code&gt;round&lt;/code&gt;, &lt;code&gt;scalblnf&lt;/code&gt;, &lt;code&gt;scalblnl&lt;/code&gt;, &lt;code&gt;scalbln&lt;/code&gt;, &lt;code&gt;scalbnf&lt;/code&gt;, &lt;code&gt;scalbnl&lt;/code&gt;, &lt;code&gt;scalbn&lt;/code&gt;, &lt;code&gt;snprintf&lt;/code&gt;, &lt;code&gt;tgammaf&lt;/code&gt;, &lt;code&gt;tgammal&lt;/code&gt;, &lt;code&gt;tgamma&lt;/code&gt;, &lt;code&gt;truncf&lt;/code&gt;, &lt;code&gt;truncl&lt;/code&gt;, &lt;code&gt;trunc&lt;/code&gt;, &lt;code&gt;vfscanf&lt;/code&gt;, &lt;code&gt;vscanf&lt;/code&gt;, &lt;code&gt;vsnprintf&lt;/code&gt; and &lt;code&gt;vsscanf&lt;/code&gt; are handled as built-in functions except in strict ISO C90 mode (</source>
          <target state="translated">在ISO C99功能 &lt;code&gt;_Exit&lt;/code&gt; ， &lt;code&gt;acoshf&lt;/code&gt; ， &lt;code&gt;acoshl&lt;/code&gt; ， &lt;code&gt;acosh&lt;/code&gt; ， &lt;code&gt;asinhf&lt;/code&gt; ， &lt;code&gt;asinhl&lt;/code&gt; ， &lt;code&gt;asinh&lt;/code&gt; ， &lt;code&gt;atanhf&lt;/code&gt; ， &lt;code&gt;atanhl&lt;/code&gt; ， &lt;code&gt;atanh&lt;/code&gt; ， &lt;code&gt;cabsf&lt;/code&gt; ， &lt;code&gt;cabsl&lt;/code&gt; ， &lt;code&gt;cabs&lt;/code&gt; ， &lt;code&gt;cacosf&lt;/code&gt; ， &lt;code&gt;cacoshf&lt;/code&gt; ， &lt;code&gt;cacoshl&lt;/code&gt; ， &lt;code&gt;cacosh&lt;/code&gt; ， &lt;code&gt;cacosl&lt;/code&gt; ， &lt;code&gt;cacos&lt;/code&gt; ， &lt;code&gt;cargf&lt;/code&gt; ， &lt;code&gt;cargl&lt;/code&gt; ， &lt;code&gt;carg&lt;/code&gt; ， &lt;code&gt;casinf&lt;/code&gt; ， &lt;code&gt;casinhf&lt;/code&gt; ， &lt;code&gt;casinhl&lt;/code&gt; ， &lt;code&gt;casinh&lt;/code&gt; ， &lt;code&gt;casinl&lt;/code&gt; ， &lt;code&gt;casin&lt;/code&gt; ， &lt;code&gt;catanf&lt;/code&gt; ， &lt;code&gt;catanhf&lt;/code&gt; ， &lt;code&gt;catanhl&lt;/code&gt; ， &lt;code&gt;catanh&lt;/code&gt; ， &lt;code&gt;catanl&lt;/code&gt; ， &lt;code&gt;catan&lt;/code&gt; ， &lt;code&gt;cbrtf&lt;/code&gt; ， &lt;code&gt;cbrtl&lt;/code&gt; ， &lt;code&gt;cbrt&lt;/code&gt; ， &lt;code&gt;ccosf&lt;/code&gt; ， &lt;code&gt;ccoshf&lt;/code&gt; ， &lt;code&gt;ccoshl&lt;/code&gt; ， &lt;code&gt;ccosh&lt;/code&gt; ， &lt;code&gt;ccosl&lt;/code&gt; ， &lt;code&gt;ccos&lt;/code&gt; ， &lt;code&gt;cexpf&lt;/code&gt; ， &lt;code&gt;cexpl&lt;/code&gt; ， &lt;code&gt;cexp&lt;/code&gt; ， &lt;code&gt;cimagf&lt;/code&gt; ， &lt;code&gt;cimagl&lt;/code&gt; ， &lt;code&gt;cimag&lt;/code&gt; ， &lt;code&gt;clogf&lt;/code&gt; ， &lt;code&gt;clogl&lt;/code&gt; ， &lt;code&gt;clog&lt;/code&gt; ， &lt;code&gt;conjf&lt;/code&gt; ， &lt;code&gt;conjl&lt;/code&gt; ， &lt;code&gt;conj&lt;/code&gt; ， &lt;code&gt;copysignf&lt;/code&gt; ， &lt;code&gt;copysignl&lt;/code&gt; ， &lt;code&gt;copysign&lt;/code&gt; ， &lt;code&gt;cpowf&lt;/code&gt; ， &lt;code&gt;cpowl&lt;/code&gt; ， &lt;code&gt;cpow&lt;/code&gt; ， &lt;code&gt;cprojf&lt;/code&gt; ， &lt;code&gt;cprojl&lt;/code&gt; ， &lt;code&gt;cproj&lt;/code&gt; ， &lt;code&gt;crealf&lt;/code&gt; ， &lt;code&gt;creall&lt;/code&gt; ， &lt;code&gt;creal&lt;/code&gt; ， &lt;code&gt;csinf&lt;/code&gt; ， &lt;code&gt;csinhf&lt;/code&gt; ， &lt;code&gt;csinhl&lt;/code&gt; ， &lt;code&gt;csinh&lt;/code&gt; ， &lt;code&gt;csinl&lt;/code&gt; ， &lt;code&gt;csin&lt;/code&gt; ， &lt;code&gt;csqrtf&lt;/code&gt; ， &lt;code&gt;csqrtl&lt;/code&gt; ， &lt;code&gt;csqrt&lt;/code&gt; ， &lt;code&gt;ctanf&lt;/code&gt; ， &lt;code&gt;ctanhf&lt;/code&gt; ， &lt;code&gt;ctanhl&lt;/code&gt; ， &lt;code&gt;ctanh&lt;/code&gt; ， &lt;code&gt;ctanl&lt;/code&gt; ， &lt;code&gt;ctan&lt;/code&gt; ， &lt;code&gt;erfcf&lt;/code&gt; ， &lt;code&gt;erfcl&lt;/code&gt; ， &lt;code&gt;erfc&lt;/code&gt; ， &lt;code&gt;erff&lt;/code&gt; ， &lt;code&gt;erfl&lt;/code&gt; ， &lt;code&gt;erf&lt;/code&gt; ， &lt;code&gt;exp2f&lt;/code&gt; ， &lt;code&gt;exp2l&lt;/code&gt; ， &lt;code&gt;exp2&lt;/code&gt; ， &lt;code&gt;expm1f&lt;/code&gt; ， &lt;code&gt;expm1l&lt;/code&gt; ,它们， &lt;code&gt;expm1&lt;/code&gt; ， &lt;code&gt;fdimf&lt;/code&gt; ， &lt;code&gt;fdiml&lt;/code&gt; ， &lt;code&gt;fdim&lt;/code&gt; ， &lt;code&gt;fmaf&lt;/code&gt; ， &lt;code&gt;fmal&lt;/code&gt; ， &lt;code&gt;fmaxf&lt;/code&gt; ， &lt;code&gt;fmaxl&lt;/code&gt; ， &lt;code&gt;fmax&lt;/code&gt; ， &lt;code&gt;fma&lt;/code&gt; ， &lt;code&gt;fminf&lt;/code&gt; ， &lt;code&gt;fminl&lt;/code&gt; ， &lt;code&gt;fmin&lt;/code&gt; ， &lt;code&gt;hypotf&lt;/code&gt; ， &lt;code&gt;hypotl&lt;/code&gt; ， &lt;code&gt;hypot&lt;/code&gt; 将， &lt;code&gt;ilogbf&lt;/code&gt; ， &lt;code&gt;ilogbl&lt;/code&gt; ， &lt;code&gt;ilogb&lt;/code&gt; ， &lt;code&gt;imaxabs&lt;/code&gt; ， &lt;code&gt;isblank&lt;/code&gt; ， &lt;code&gt;iswblank&lt;/code&gt; ， &lt;code&gt;lgammaf&lt;/code&gt; ， &lt;code&gt;lgammal&lt;/code&gt; ， &lt;code&gt;lgamma&lt;/code&gt; 函数， &lt;code&gt;llabs&lt;/code&gt; ， &lt;code&gt;llrintf&lt;/code&gt; ， &lt;code&gt;llrintl&lt;/code&gt; ， &lt;code&gt;llrint&lt;/code&gt; ， &lt;code&gt;llroundf&lt;/code&gt; ， &lt;code&gt;llroundl&lt;/code&gt; ， &lt;code&gt;llround&lt;/code&gt; ， &lt;code&gt;log1pf&lt;/code&gt; ， &lt;code&gt;log1pl&lt;/code&gt; ,它们， &lt;code&gt;log1p&lt;/code&gt; ， &lt;code&gt;log2f&lt;/code&gt; ， &lt;code&gt;log2l&lt;/code&gt; ， &lt;code&gt;log2&lt;/code&gt; ， &lt;code&gt;logbf&lt;/code&gt; ， &lt;code&gt;logbl&lt;/code&gt; ， &lt;code&gt;logb&lt;/code&gt; ， &lt;code&gt;lrintf&lt;/code&gt; ， &lt;code&gt;lrintl&lt;/code&gt; ， &lt;code&gt;lrint&lt;/code&gt; ， &lt;code&gt;lroundf&lt;/code&gt; ， &lt;code&gt;lroundl&lt;/code&gt; ， &lt;code&gt;lround&lt;/code&gt; ， &lt;code&gt;nearbyintf&lt;/code&gt; ， &lt;code&gt;nearbyintl&lt;/code&gt; ， &lt;code&gt;nearbyint&lt;/code&gt; ， &lt;code&gt;nextafterf&lt;/code&gt; ， &lt;code&gt;nextafterl&lt;/code&gt; ， &lt;code&gt;nextafter&lt;/code&gt; ， &lt;code&gt;nexttowardf&lt;/code&gt; ， &lt;code&gt;nexttowardl&lt;/code&gt; ， &lt;code&gt;nexttoward&lt;/code&gt; ， &lt;code&gt;remainderf&lt;/code&gt; ， &lt;code&gt;remainderl&lt;/code&gt; ， &lt;code&gt;remainder&lt;/code&gt; ， &lt;code&gt;remquof&lt;/code&gt; ， &lt;code&gt;remquol&lt;/code&gt; ， &lt;code&gt;remquo&lt;/code&gt; ， &lt;code&gt;rintf&lt;/code&gt; ， &lt;code&gt;rintl&lt;/code&gt; ， &lt;code&gt;rint&lt;/code&gt; ， &lt;code&gt;roundf&lt;/code&gt; ， &lt;code&gt;roundl&lt;/code&gt; ， &lt;code&gt;round&lt;/code&gt; ， &lt;code&gt;scalblnf&lt;/code&gt; ， &lt;code&gt;scalblnl&lt;/code&gt; ， &lt;code&gt;scalbln&lt;/code&gt; ， &lt;code&gt;scalbnf&lt;/code&gt; ， &lt;code&gt;scalbnl&lt;/code&gt; ， &lt;code&gt;scalbn&lt;/code&gt; ， &lt;code&gt;snprintf&lt;/code&gt; 的， &lt;code&gt;tgammaf&lt;/code&gt; ， &lt;code&gt;tgammal&lt;/code&gt; ， &lt;code&gt;tgamma&lt;/code&gt; ， &lt;code&gt;truncf&lt;/code&gt; ， &lt;code&gt;truncl&lt;/code&gt; ， &lt;code&gt;trunc&lt;/code&gt; ， &lt;code&gt;vfscanf&lt;/code&gt; ， &lt;code&gt;vscanf&lt;/code&gt; ， &lt;code&gt;vsnprintf&lt;/code&gt; 和 &lt;code&gt;vsscanf&lt;/code&gt; 均作为内置函数处理，但在严格的ISO C90模式下（</target>
        </trans-unit>
        <trans-unit id="2784e50b776c95c529ea8bb486ce2750890944bf" translate="yes" xml:space="preserve">
          <source>The ISO type of an integer constant has a different width or signedness from its traditional type. This warning is only issued if the base of the constant is ten. I.e. hexadecimal or octal values, which typically represent bit patterns, are not warned about.</source>
          <target state="translated">一个整数常量的ISO类型与传统类型的宽度或签名不同。只有当常量的基数是十时,才会发出这个警告。即十六进制或八进制值,通常代表位模式,不会被警告。</target>
        </trans-unit>
        <trans-unit id="82a12be836835137fbdc59e2c7d2766dbca00a8c" translate="yes" xml:space="preserve">
          <source>The JSON is emitted as one line, without formatting; the examples below have been formatted for clarity.</source>
          <target state="translated">JSON是以一行的形式发出的,没有格式化;为了清楚起见,下面的例子已经进行了格式化。</target>
        </trans-unit>
        <trans-unit id="a08b3636d7c444216df0829b96c5cf7186a63397" translate="yes" xml:space="preserve">
          <source>The M-Profile Vector Extension (MVE) integer and single precision floating-point instructions.</source>
          <target state="translated">M-Profile向量扩展(MVE)整数和单精度浮点指令。</target>
        </trans-unit>
        <trans-unit id="121628a4764ae0bea2f22e038677fd81cecafe48" translate="yes" xml:space="preserve">
          <source>The M-Profile Vector Extension (MVE) integer instructions.</source>
          <target state="translated">M-Profile Vector Extension(MVE)整数指令。</target>
        </trans-unit>
        <trans-unit id="4a22ef3a7780246abe5b933d687f802ceaac7fd9" translate="yes" xml:space="preserve">
          <source>The MIPS DSP Application-Specific Extension (ASE) includes new instructions that are designed to improve the performance of DSP and media applications. It provides instructions that operate on packed 8-bit/16-bit integer data, Q7, Q15 and Q31 fractional data.</source>
          <target state="translated">MIPS DSP特定应用扩展(ASE)包括旨在提高DSP和媒体应用性能的新指令。它提供了对打包的8位/16位整数数据、Q7、Q15和Q31小数数据进行操作的指令。</target>
        </trans-unit>
        <trans-unit id="f5ed4155655f597ba1ea8fb1a082975a691dee38" translate="yes" xml:space="preserve">
          <source>The MIPS-3D Application-Specific Extension (ASE) includes additional paired-single instructions that are designed to improve the performance of 3D graphics operations. Support for these instructions is controlled by the</source>
          <target state="translated">MIPS-3D特定应用扩展(ASE)包括额外的配对-单条指令,旨在提高3D图形操作的性能。对这些指令的支持是由</target>
        </trans-unit>
        <trans-unit id="2568887586875d72638add2c316850a652079522" translate="yes" xml:space="preserve">
          <source>The MIPS64 architecture includes a number of instructions that operate on pairs of single-precision floating-point values. Each pair is packed into a 64-bit floating-point register, with one element being designated the &amp;ldquo;upper half&amp;rdquo; and the other being designated the &amp;ldquo;lower half&amp;rdquo;.</source>
          <target state="translated">MIPS64体系结构包括许多指令，它们对成对的单精度浮点值进行操作。每对都封装在一个64位浮点寄存器中，其中一个元素称为&amp;ldquo;上半部分&amp;rdquo;，另一元素称为&amp;ldquo;下半部分&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="19791c6fc0c7878cc7c0d81440fdc8b3deac6cc4" translate="yes" xml:space="preserve">
          <source>The MSP430 hardware ensures that interrupts are disabled on entry to &lt;code&gt;interrupt&lt;/code&gt; functions, and restores the previous interrupt state on exit. The &lt;code&gt;critical&lt;/code&gt; attribute is therefore redundant on &lt;code&gt;interrupt&lt;/code&gt; functions.</source>
          <target state="translated">MSP430硬件可确保在进入 &lt;code&gt;interrupt&lt;/code&gt; 功能时禁止中断，并在退出时恢复先前的中断状态。因此， &lt;code&gt;critical&lt;/code&gt; 属性在 &lt;code&gt;interrupt&lt;/code&gt; 功能上是多余的。</target>
        </trans-unit>
        <trans-unit id="324add0fab22223316ad270b660243d491e201b4" translate="yes" xml:space="preserve">
          <source>The MeP target has a number of addressing modes and busses. The &lt;code&gt;near&lt;/code&gt; space spans the standard memory space&amp;rsquo;s first 16 megabytes (24 bits). The &lt;code&gt;far&lt;/code&gt; space spans the entire 32-bit memory space. The &lt;code&gt;based&lt;/code&gt; space is a 128-byte region in the memory space that is addressed relative to the &lt;code&gt;$tp&lt;/code&gt; register. The &lt;code&gt;tiny&lt;/code&gt; space is a 65536-byte region relative to the &lt;code&gt;$gp&lt;/code&gt; register. In addition to these memory regions, the MeP target has a separate 16-bit control bus which is specified with &lt;code&gt;cb&lt;/code&gt; attributes.</source>
          <target state="translated">MeP目标具有许多寻址模式和总线。的 &lt;code&gt;near&lt;/code&gt; 空间跨越标准内存空间的第一16兆字节（24位）。的 &lt;code&gt;far&lt;/code&gt; 空间跨度整个32位的内存空间。的 &lt;code&gt;based&lt;/code&gt; 空间是在被寻址相对于所述存储器空间中的128字节的区域 &lt;code&gt;$tp&lt;/code&gt; 寄存器。相对于 &lt;code&gt;$gp&lt;/code&gt; 寄存器， &lt;code&gt;tiny&lt;/code&gt; 空间是65536字节的区域。除这些存储区域外，MeP目标还有一个单独的16位控制总线，该总线由 &lt;code&gt;cb&lt;/code&gt; 属性指定。</target>
        </trans-unit>
        <trans-unit id="5d8a7015c96baf068daea7c993c23e530f568f5f" translate="yes" xml:space="preserve">
          <source>The Medium/Anywhere code model for embedded systems: 64-bit addresses, the text and data segments must be less than 2GB in size, both starting anywhere in memory (determined at link time). The global register %g4 points to the base of the data segment. Programs are statically linked and PIC is not supported.</source>
          <target state="translated">嵌入式系统的Medium/Anywhere代码模型。64位地址,文本和数据段的大小必须小于2GB,两者都从内存的任何地方开始(在链接时确定)。全局寄存器%g4指向数据段的基座。程序是静态链接的,不支持PIC。</target>
        </trans-unit>
        <trans-unit id="cc31a18cddf7a0f78efe693458fe2d9afe6d7019" translate="yes" xml:space="preserve">
          <source>The Medium/Anywhere code model: 64-bit addresses, programs may be linked anywhere in memory, the text and data segments must be less than 2GB in size and the data segment must be located within 2GB of the text segment.</source>
          <target state="translated">中/任意位置代码模式。64位地址,程序可连接到内存的任何地方,文本和数据段的大小必须小于2GB,数据段必须位于文本段的2GB以内。</target>
        </trans-unit>
        <trans-unit id="7e3c5ad40e25357a2525dfa3cd571c1d3bd7d34a" translate="yes" xml:space="preserve">
          <source>The Medium/Low code model: 64-bit addresses, programs must be linked in the low 32 bits of memory. Programs can be statically or dynamically linked.</source>
          <target state="translated">中/低码模式。64位地址,程序必须在低32位内存中链接。程序可以是静态链接,也可以是动态链接。</target>
        </trans-unit>
        <trans-unit id="3b39ba546b4adedbbf99b1b31d01ec7fac76520a" translate="yes" xml:space="preserve">
          <source>The Medium/Middle code model: 64-bit addresses, programs must be linked in the low 44 bits of memory, the text and data segments must be less than 2GB in size and the data segment must be located within 2GB of the text segment.</source>
          <target state="translated">中/中码模式。64位地址,程序必须连接在低44位内存中,文本和数据段的大小必须小于2GB,数据段必须位于文本段的2GB以内。</target>
        </trans-unit>
        <trans-unit id="da2b29936b818cfc1e5a3a58f7738a9fa0c881c1" translate="yes" xml:space="preserve">
          <source>The Microsoft structure layout algorithm is fairly simple with the exception of the bit-field packing. The padding and alignment of members of structures and whether a bit-field can straddle a storage-unit boundary are determine by these rules:</source>
          <target state="translated">微软的结构布局算法相当简单,除了位场打包。结构成员的填充和排列,以及位域是否可以跨越存储单元边界都是由这些规则决定的。</target>
        </trans-unit>
        <trans-unit id="aeff520b5677f801f6da4eeb7f1e51a9a569cd01" translate="yes" xml:space="preserve">
          <source>The NOP instructions are inserted at&amp;mdash;and maybe before, depending on &lt;var&gt;M&lt;/var&gt;&amp;mdash;the function entry address, even before the prologue.</source>
          <target state="translated">NOP指令甚至在序言之前，也可能根据功能 &lt;var&gt;M&lt;/var&gt; 插入到函数入口地址（可能取决于M）之前。</target>
        </trans-unit>
        <trans-unit id="ff55b141ae724be4a1c090f09197c4cc8d0b49e5" translate="yes" xml:space="preserve">
          <source>The Objective-C 2.0 language extensions and features are automatically enabled; they include properties (via the &lt;code&gt;@property&lt;/code&gt;, &lt;code&gt;@synthesize&lt;/code&gt; and &lt;code&gt;@dynamic keywords&lt;/code&gt;), fast enumeration (not available in Objective-C++), attributes for methods (such as &lt;code&gt;deprecated&lt;/code&gt;, &lt;code&gt;noreturn&lt;/code&gt;, &lt;code&gt;sentinel&lt;/code&gt;, &lt;code&gt;format&lt;/code&gt;), the &lt;code&gt;unused&lt;/code&gt; attribute for method arguments, the &lt;code&gt;@package&lt;/code&gt; keyword for instance variables and the &lt;code&gt;@optional&lt;/code&gt; and &lt;code&gt;@required&lt;/code&gt; keywords in protocols. You can disable all these Objective-C 2.0 language extensions with the option</source>
          <target state="translated">Objective-C 2.0语言扩展和功能会自动启用。它们包括性质（通过 &lt;code&gt;@property&lt;/code&gt; ， &lt;code&gt;@synthesize&lt;/code&gt; 和 &lt;code&gt;@dynamic keywords&lt;/code&gt; ），快速枚举（在Objective-C ++不可用），属性方法（如 &lt;code&gt;deprecated&lt;/code&gt; ， &lt;code&gt;noreturn&lt;/code&gt; ， &lt;code&gt;sentinel&lt;/code&gt; ， &lt;code&gt;format&lt;/code&gt; ），则 &lt;code&gt;unused&lt;/code&gt; 方法参数属性，协议中实例变量的 &lt;code&gt;@package&lt;/code&gt; 关键字以及协议中的 &lt;code&gt;@optional&lt;/code&gt; 和 &lt;code&gt;@required&lt;/code&gt; 关键字。您可以使用选项禁用所有这些Objective-C 2.0语言扩展</target>
        </trans-unit>
        <trans-unit id="c6923a9108193e35102064afa9eda743cb37bdd9" translate="yes" xml:space="preserve">
          <source>The Objective-C compiler generates type encodings for all the types. These type encodings are used at runtime to find out information about selectors and methods and about objects and classes.</source>
          <target state="translated">Objective-C编译器为所有的类型生成类型编码,这些类型编码在运行时用于查找选择器和方法以及对象和类的信息。这些类型编码在运行时被用来找出关于选择器和方法以及对象和类的信息。</target>
        </trans-unit>
        <trans-unit id="e464bd6510d0d75994dbae5961cb9df5baed7b28" translate="yes" xml:space="preserve">
          <source>The Objective-C exception and synchronization syntax (that is, the keywords &lt;code&gt;@try&lt;/code&gt;, &lt;code&gt;@throw&lt;/code&gt;, &lt;code&gt;@catch&lt;/code&gt;, &lt;code&gt;@finally&lt;/code&gt; and &lt;code&gt;@synchronized&lt;/code&gt;) is supported by GCC and is enabled with the option</source>
          <target state="translated">Objective-C的异常，并同步语法（即关键字 &lt;code&gt;@try&lt;/code&gt; ， &lt;code&gt;@throw&lt;/code&gt; ， &lt;code&gt;@catch&lt;/code&gt; ， &lt;code&gt;@finally&lt;/code&gt; 和 &lt;code&gt;@synchronized&lt;/code&gt; ）由GCC支持，并与选项启用</target>
        </trans-unit>
        <trans-unit id="504b920d3ddaa29eaf4f4d2837867a09bb928c21" translate="yes" xml:space="preserve">
          <source>The One Definition Rule is relaxed for types without explicit visibility specifications that are defined in more than one shared object: those declarations are permitted if they are permitted when this option is not used.</source>
          <target state="translated">对于在多个共享对象中定义的没有显式可见性规范的类型,放宽了 &quot;一个定义 &quot;规则:如果不使用这个选项时,这些声明是允许的。</target>
        </trans-unit>
        <trans-unit id="2d22810fdfaa073bc94d2050ac8533154c085f11" translate="yes" xml:space="preserve">
          <source>The RL78 back end supports the &lt;code&gt;saddr&lt;/code&gt; variable attribute. This specifies placement of the corresponding variable in the SADDR area, which can be accessed more efficiently than the default memory region.</source>
          <target state="translated">RL78后端支持 &lt;code&gt;saddr&lt;/code&gt; 变量属性。这指定了将相应变量放置在SADDR区域中，该区域可以比默认存储区域更有效地进行访问。</target>
        </trans-unit>
        <trans-unit id="1c75a1f23dddf5a55d85a877757468d10500aab3" translate="yes" xml:space="preserve">
          <source>The RS/6000 and PowerPC targets define one pragma for controlling whether or not the &lt;code&gt;longcall&lt;/code&gt; attribute is added to function declarations by default. This pragma overrides the</source>
          <target state="translated">RS / 6000和PowerPC目标定义了一个 &lt;code&gt;longcall&lt;/code&gt; 用于控制是否将longcall属性默认添加到函数声明中。此实用程序优先于</target>
        </trans-unit>
        <trans-unit id="549fc0bcd99c9fa57f4b149326299d99007e47ae" translate="yes" xml:space="preserve">
          <source>The SCOUNT and POS bits of the DSP control register are global. The WRDSP, EXTPDP, EXTPDPV and MTHLIP instructions modify the SCOUNT and POS bits. During optimization, the compiler does not delete these instructions and it does not delete calls to functions containing these instructions.</source>
          <target state="translated">DSP控制寄存器的SCOUNT和POS位是全局的。WRDSP、EXTPDP、EXTPDPV和MTHLIP指令会修改SCOUNT和POS位。在优化过程中,编译器不会删除这些指令,也不会删除对包含这些指令的函数的调用。</target>
        </trans-unit>
        <trans-unit id="feed8b7325d666bcdf4c1efd5aa692caea9e4e2d" translate="yes" xml:space="preserve">
          <source>The SPU supports the &lt;code&gt;spu_vector&lt;/code&gt; attribute for variables. For documentation of this attribute please see the documentation in &lt;a href=&quot;type-attributes#SPU-Type-Attributes&quot;&gt;SPU Type Attributes&lt;/a&gt;.</source>
          <target state="translated">SPU支持变量的 &lt;code&gt;spu_vector&lt;/code&gt; 属性。有关此属性的文档，请参阅&lt;a href=&quot;type-attributes#SPU-Type-Attributes&quot;&gt;SPU Type Attributes中&lt;/a&gt;的文档。</target>
        </trans-unit>
        <trans-unit id="e00194fefd3abe9f6e9c4ed0e24c5f1cdb3e71d6" translate="yes" xml:space="preserve">
          <source>The Solaris target supports &lt;code&gt;#pragma redefine_extname&lt;/code&gt; (see &lt;a href=&quot;symbol_002drenaming-pragmas#Symbol_002dRenaming-Pragmas&quot;&gt;Symbol-Renaming Pragmas&lt;/a&gt;). It also supports additional &lt;code&gt;#pragma&lt;/code&gt; directives for compatibility with the system compiler.</source>
          <target state="translated">Solaris目标支持 &lt;code&gt;#pragma redefine_extname&lt;/code&gt; （请参见&lt;a href=&quot;symbol_002drenaming-pragmas#Symbol_002dRenaming-Pragmas&quot;&gt;Symbol-Renaming Pragmas&lt;/a&gt;）。它还支持其他 &lt;code&gt;#pragma&lt;/code&gt; 指令，以与系统编译器兼容。</target>
        </trans-unit>
        <trans-unit id="b577e7bfa4d5d277a90aa967bc9fa309870fa29b" translate="yes" xml:space="preserve">
          <source>The V850 back end supports these function attributes:</source>
          <target state="translated">V850后端支持这些功能属性。</target>
        </trans-unit>
        <trans-unit id="87ba99adc7a79652db01be899ada60245b8a9d21" translate="yes" xml:space="preserve">
          <source>The VFPv2 floating-point instructions. The extension &amp;lsquo;</source>
          <target state="translated">VFPv2浮点指令。扩展名'</target>
        </trans-unit>
        <trans-unit id="259f6621f353addf35de203c6cc21ec70166871f" translate="yes" xml:space="preserve">
          <source>The VFPv3 floating-point instructions with 16 double-precision registers and the half-precision floating-point conversion operations.</source>
          <target state="translated">VFPv3浮点指令具有16个双精度寄存器和半精度浮点转换操作。</target>
        </trans-unit>
        <trans-unit id="69bbc2d35ac5910370025649743d2c9e7aba8bec" translate="yes" xml:space="preserve">
          <source>The VFPv3 floating-point instructions with 16 double-precision registers. The extension +vfpv3-d16 can be used as an alias for this extension.</source>
          <target state="translated">带有16个双精度寄存器的VFPv3浮点指令。扩展名+vfpv3-d16可以作为该扩展名的别名。</target>
        </trans-unit>
        <trans-unit id="7d392f4c1ad45a7ce6a0755dbe2047b64e45ba0e" translate="yes" xml:space="preserve">
          <source>The VFPv3 floating-point instructions, with 16 double-precision registers and the half-precision floating-point conversion operations.</source>
          <target state="translated">VFPv3浮点指令,有16个双精度寄存器和半精度浮点转换操作。</target>
        </trans-unit>
        <trans-unit id="9ea0bf30af6241dd74e66058037f24ca2aa3b024" translate="yes" xml:space="preserve">
          <source>The VFPv3 floating-point instructions, with 16 double-precision registers.</source>
          <target state="translated">VFPv3浮点指令,有16个双精度寄存器。</target>
        </trans-unit>
        <trans-unit id="8c44d40609c70bac64a3214e9aba6ea5f2799b31" translate="yes" xml:space="preserve">
          <source>The VFPv3 floating-point instructions, with 16 double-precision registers. The extension &amp;lsquo;</source>
          <target state="translated">VFPv3浮点指令具有16个双精度寄存器。扩展名'</target>
        </trans-unit>
        <trans-unit id="69ba42177cf602fb7a0ed600eac827a8de6a449b" translate="yes" xml:space="preserve">
          <source>The VFPv3 floating-point instructions, with 32 double-precision registers and the half-precision floating-point conversion operations.</source>
          <target state="translated">VFPv3浮点指令,有32个双精度寄存器和半精度浮点转换操作。</target>
        </trans-unit>
        <trans-unit id="193d13643a69320727d206517bd62145a8c8f03c" translate="yes" xml:space="preserve">
          <source>The VFPv3 floating-point instructions, with 32 double-precision registers.</source>
          <target state="translated">VFPv3浮点指令,有32个双精度寄存器。</target>
        </trans-unit>
        <trans-unit id="a0936e97cd9c57c2c85efdbe6388f42baca5f03d" translate="yes" xml:space="preserve">
          <source>The VFPv4 floating-point instructions, with 16 double-precision registers.</source>
          <target state="translated">VFPv4浮点指令,有16个双精度寄存器。</target>
        </trans-unit>
        <trans-unit id="103d1acc3dfe417798e6bd838ba4fc9709451552" translate="yes" xml:space="preserve">
          <source>The VFPv4 floating-point instructions, with 16 double-precision registers. The extension &amp;lsquo;</source>
          <target state="translated">VFPv4浮点指令，带有16个双精度寄存器。扩展名'</target>
        </trans-unit>
        <trans-unit id="06ddcf864547f4dbeda808689e788fca6e819171" translate="yes" xml:space="preserve">
          <source>The VFPv4 floating-point instructions, with 32 double-precision registers.</source>
          <target state="translated">VFPv4浮点指令,有32个双精度寄存器。</target>
        </trans-unit>
        <trans-unit id="9285ccf7646c59c98d31930bdd84e56c45d5fd26" translate="yes" xml:space="preserve">
          <source>The VR4130 pipeline is two-way superscalar, but can only issue two instructions together if the first one is 8-byte aligned. When this option is enabled, GCC aligns pairs of instructions that it thinks should execute in parallel.</source>
          <target state="translated">VR4130流水线是双向超标量的,但只有在第一条指令是8字节对齐的情况下才能一起发出两条指令。当启用这个选项时,GCC会将它认为应该并行执行的指令对对齐。</target>
        </trans-unit>
        <trans-unit id="cb154aff394215a4189b3dafa08992907beaeea3" translate="yes" xml:space="preserve">
          <source>The VSX instruction set (</source>
          <target state="translated">VSX指令集(</target>
        </trans-unit>
        <trans-unit id="5a0171ba1b31d3315fbbfaace918d589c6b61613" translate="yes" xml:space="preserve">
          <source>The abbreviation &lt;em&gt;GCC&lt;/em&gt; has multiple meanings in common use. The current official meaning is &amp;ldquo;GNU Compiler Collection&amp;rdquo;, which refers generically to the complete suite of tools. The name historically stood for &amp;ldquo;GNU C Compiler&amp;rdquo;, and this usage is still common when the emphasis is on compiling C programs. Finally, the name is also used when speaking of the &lt;em&gt;language-independent&lt;/em&gt; component of GCC: code shared among the compilers for all supported languages.</source>
          <target state="translated">缩写&lt;em&gt;GCC&lt;/em&gt;具有多种常用含义。当前的正式含义是&amp;ldquo; GNU编译器集合&amp;rdquo;，通常指完整的工具套件。该名称在历史上代表&amp;ldquo; GNU C编译器&amp;rdquo;，当强调编译C程序时，这种用法仍然很常见。最后，在谈到GCC &lt;em&gt;的独立&lt;/em&gt;于&lt;em&gt;语言的&lt;/em&gt;组件时，也使用该名称：所有支持的语言在编译器之间共享的代码。</target>
        </trans-unit>
        <trans-unit id="3a9d23d169ba3b72eeef6725cec43a13a50013c2" translate="yes" xml:space="preserve">
          <source>The above generates bytecode for</source>
          <target state="translated">以上生成的字节码为</target>
        </trans-unit>
        <trans-unit id="34a36dd9deec63b753f5d433c0dd87cbce7edcf4" translate="yes" xml:space="preserve">
          <source>The above lines are equivalent to the following:</source>
          <target state="translated">以上行文相当于:</target>
        </trans-unit>
        <trans-unit id="a39976e643ac6d1dc6fe3e4366ed3a13dea2466b" translate="yes" xml:space="preserve">
          <source>The above target attributes can be specified as follows:</source>
          <target state="translated">上述目标属性可以指定如下:</target>
        </trans-unit>
        <trans-unit id="ed1f637f7dae694f5c4cfc72955bdf63e2cee6a2" translate="yes" xml:space="preserve">
          <source>The accuracy is unknown.</source>
          <target state="translated">准确性未知。</target>
        </trans-unit>
        <trans-unit id="120b6f184277986efda6f906c93a195e4dc7e853" translate="yes" xml:space="preserve">
          <source>The accuracy of the floating-point operations and of the library functions in &lt;code&gt;&amp;lt;math.h&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;complex.h&amp;gt;&lt;/code&gt; that return floating-point results (C90, C99 and C11 5.2.4.2.2).</source>
          <target state="translated">浮点运算和 &lt;code&gt;&amp;lt;math.h&amp;gt;&lt;/code&gt; 和 &lt;code&gt;&amp;lt;complex.h&amp;gt;&lt;/code&gt; 中的库函数的精度，这些精度返回浮点结果（C90，C99和C11 5.2.4.2.2）。</target>
        </trans-unit>
        <trans-unit id="80f0b076d52d6244bc6636b163e80827a773f50c" translate="yes" xml:space="preserve">
          <source>The actual register chosen to hold the constant data base address depends upon whether the</source>
          <target state="translated">实际选择哪一个寄存器来存放恒定的数据基地址,要看是否是由</target>
        </trans-unit>
        <trans-unit id="a30a65f7051569a9a9c6241a0c50efdd3d1de863" translate="yes" xml:space="preserve">
          <source>The added &lt;var&gt;flag&lt;/var&gt; argument is passed unchanged to &lt;code&gt;__sprintf_chk&lt;/code&gt; etc. functions and can contain implementation specific flags on what additional security measures the checking function might take, such as handling &lt;code&gt;%n&lt;/code&gt; differently.</source>
          <target state="translated">添加的 &lt;var&gt;flag&lt;/var&gt; 参数将 &lt;code&gt;__sprintf_chk&lt;/code&gt; 传递给__sprintf_chk等函数，并且可以包含实现特定的标志，这些标志说明了检查函数可能采取的其他附加安全措施，例如以不同方式处理 &lt;code&gt;%n&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8e6f66f554f454fd60e4196cbe8c25320dedb4b7" translate="yes" xml:space="preserve">
          <source>The added comments include:</source>
          <target state="translated">增加的意见包括:</target>
        </trans-unit>
        <trans-unit id="5c6f1012ead9ec76811fd2e9243c4b72f326472d" translate="yes" xml:space="preserve">
          <source>The additional block information is of the form</source>
          <target state="translated">附加块信息的形式是</target>
        </trans-unit>
        <trans-unit id="79eafbe5ef62b1bf562656c8ccc8660f517c4542" translate="yes" xml:space="preserve">
          <source>The address as returned by &lt;code&gt;__builtin_return_address&lt;/code&gt; may have to be fed through this function to get the actual encoded address. For example, on the 31-bit S/390 platform the highest bit has to be masked out, or on SPARC platforms an offset has to be added for the true next instruction to be executed.</source>
          <target state="translated">&lt;code&gt;__builtin_return_address&lt;/code&gt; 返回的地址可能必须通过此函数提供，才能获得实际的编码地址。例如，在31位S / 390平台上，最高位必须被屏蔽掉，或者在SPARC平台上，必须添加偏移量才能执行真正的下一条指令。</target>
        </trans-unit>
        <trans-unit id="9133fefd38b502d139962641eb1473acc29ca6ef" translate="yes" xml:space="preserve">
          <source>The addressability of a particular object can be set with the &lt;code&gt;model&lt;/code&gt; attribute.</source>
          <target state="translated">可以使用 &lt;code&gt;model&lt;/code&gt; 属性设置特定对象的可寻址性。</target>
        </trans-unit>
        <trans-unit id="8b38ea0caa823f37a2f086f0d1bc57b4b47d283c" translate="yes" xml:space="preserve">
          <source>The alignment of non-bit-field members of structures (C90 6.5.2.1, C99 and C11 6.7.2.1).</source>
          <target state="translated">结构中非位域成员的排列(C90 6.5.2.1、C99和C11 6.7.2.1);</target>
        </trans-unit>
        <trans-unit id="322481284c6908feb9887b9dd7bb912960123985" translate="yes" xml:space="preserve">
          <source>The alternate keywords &lt;code&gt;__asm__&lt;/code&gt;, &lt;code&gt;__extension__&lt;/code&gt;, &lt;code&gt;__inline__&lt;/code&gt; and &lt;code&gt;__typeof__&lt;/code&gt; continue to work despite</source>
          <target state="translated">备用关键字 &lt;code&gt;__asm__&lt;/code&gt; ， &lt;code&gt;__extension__&lt;/code&gt; ， &lt;code&gt;__inline__&lt;/code&gt; 和 &lt;code&gt;__typeof__&lt;/code&gt; 继续工作，尽管</target>
        </trans-unit>
        <trans-unit id="8e728c9fa7b9e6ce4962fad39896909da2bde1ee" translate="yes" xml:space="preserve">
          <source>The analogous feature in Fortran is called an assigned goto, but that name seems inappropriate in C, where one can do more than simply store label addresses in label variables.</source>
          <target state="translated">在Fortran中,类似的功能叫做赋值的goto,但在C语言中,这个名字似乎并不合适,在C语言中,人们可以做的不仅仅是将标签地址存储在标签变量中。</target>
        </trans-unit>
        <trans-unit id="14c11777761d5f46c1a9fb516ac0c2ee4a9cb68d" translate="yes" xml:space="preserve">
          <source>The application binary interface implemented by a C or C++ compiler affects code generation and runtime support for:</source>
          <target state="translated">C或C++编译器实现的应用二进制接口会影响代码的生成和运行时的支持。</target>
        </trans-unit>
        <trans-unit id="29b549ce42574a44cc4510011757b7ba9fd1935c" translate="yes" xml:space="preserve">
          <source>The approximate maximum amount of memory that can be allocated in order to perform the global common subexpression elimination optimization. If more memory than specified is required, the optimization is not done.</source>
          <target state="translated">为了执行全局通用子表达式消除优化,可以分配的大约最大内存量。如果需要的内存比指定的多,则不进行优化。</target>
        </trans-unit>
        <trans-unit id="01165ed876927994264f7a9cab383ccc4af10540" translate="yes" xml:space="preserve">
          <source>The argument can be a list of strings of arbitrary length. The strings are sorted on output, so the order of the list is unimportant.</source>
          <target state="translated">参数可以是一个任意长度的字符串列表。这些字符串在输出时是排序的,所以列表的顺序并不重要。</target>
        </trans-unit>
        <trans-unit id="59d49582cbfaa16c6712e0f374a5a6c15a857459" translate="yes" xml:space="preserve">
          <source>The argument to</source>
          <target state="translated">论点:</target>
        </trans-unit>
        <trans-unit id="d44a319a963da0f3902d413f244d251258e282dd" translate="yes" xml:space="preserve">
          <source>The arguments to &lt;code&gt;__builtin_tgmath&lt;/code&gt; are at least two pointers to functions, followed by the arguments to the type-generic macro (which will be passed as arguments to the selected function). All the pointers to functions must be pointers to prototyped functions, none of which may have variable arguments, and all of which must have the same number of parameters; the number of parameters of the first function determines how many arguments to &lt;code&gt;__builtin_tgmath&lt;/code&gt; are interpreted as function pointers, and how many as the arguments to the called function.</source>
          <target state="translated">&lt;code&gt;__builtin_tgmath&lt;/code&gt; 的参数至少是两个指向函数的指针，其后是指向类型通用宏的参数（它将作为参数传递给所选函数）。所有指向函数的指针都必须是原型函数的指针，它们都不能具有可变参数，并且它们都必须具有相同数量的参数。第一个函数的参数数量确定将 &lt;code&gt;__builtin_tgmath&lt;/code&gt; 的参数解释为函数指针，以及将多少作为调用函数的参数。</target>
        </trans-unit>
        <trans-unit id="966ac956bf197ec8f0ba6771423c919858f24a7d" translate="yes" xml:space="preserve">
          <source>The arguments to the built-in functions can be divided into three groups: register numbers, compile-time constants and run-time values. In order to make this classification clear at a glance, the arguments and return values are given the following pseudo types:</source>
          <target state="translated">内建函数的参数可以分为三类:寄存器号、编译时常量和运行时值。为了使这种分类一目了然,参数和返回值被赋予以下伪类型。</target>
        </trans-unit>
        <trans-unit id="c829863ade5431c1682f5d64360267aae12a2fb8" translate="yes" xml:space="preserve">
          <source>The attribute can also be applied to an inline namespace, but does not affect the mangled name of the namespace; in this case it is only used for</source>
          <target state="translated">该属性也可以应用于内联命名空间,但不影响命名空间的乱名;在这种情况下,它只用于</target>
        </trans-unit>
        <trans-unit id="ed02eb26a29f10b556adacd30701241deccd245e" translate="yes" xml:space="preserve">
          <source>The attribute cannot be used to decrease the alignment of a function previously declared with a more restrictive alignment; only to increase it. Attempts to do otherwise are diagnosed. Some targets specify a minimum default alignment for functions that is greater than 1. On such targets, specifying a less restrictive alignment is silently ignored. Using the attribute overrides the effect of the</source>
          <target state="translated">该属性不能用于减少先前声明的函数的限制性对齐,只能用于增加它。否则会被诊断。在这样的目标上,指定一个限制性较小的对齐方式会被默默地忽略。使用该属性会覆盖</target>
        </trans-unit>
        <trans-unit id="ae26e49e643c3950ed6f72c5632f4fffd355af07" translate="yes" xml:space="preserve">
          <source>The attribute has no effect on functions defined within the current compilation unit. This is to allow easy merging of multiple compilation units into one, for example, by using the link-time optimization. For this reason the attribute is not allowed on types to annotate indirect calls.</source>
          <target state="translated">该属性对当前编译单元中定义的函数没有影响。这是为了允许将多个编译单元合并成一个单元,例如,通过使用链接时间优化。由于这个原因,该属性不允许在类型上注释间接调用。</target>
        </trans-unit>
        <trans-unit id="87e6916763209960cf7a9bdaddf003a5218d3bef" translate="yes" xml:space="preserve">
          <source>The attribute is automatically set with a position of 0 for the built-in functions &lt;code&gt;execl&lt;/code&gt; and &lt;code&gt;execlp&lt;/code&gt;. The built-in function &lt;code&gt;execle&lt;/code&gt; has the attribute set with a position of 1.</source>
          <target state="translated">内置函数 &lt;code&gt;execl&lt;/code&gt; 和 &lt;code&gt;execlp&lt;/code&gt; 的位置自动设置为0 。内置函数 &lt;code&gt;execle&lt;/code&gt; 的属性设置为位置1。</target>
        </trans-unit>
        <trans-unit id="fe2a754094a48aee11cc854617f21a28a6c915b2" translate="yes" xml:space="preserve">
          <source>The attribute is ignored for undefined symbols.</source>
          <target state="translated">对于未定义的符号,该属性将被忽略。</target>
        </trans-unit>
        <trans-unit id="c20b877bf7007b2fcc50da9d21f8618882a3644d" translate="yes" xml:space="preserve">
          <source>The attribute is intended for library functions to improve dataflow analysis. The compiler takes the hint that any data not escaping the current compilation unit cannot be used or modified by the leaf function. For example, the &lt;code&gt;sin&lt;/code&gt; function is a leaf function, but &lt;code&gt;qsort&lt;/code&gt; is not.</source>
          <target state="translated">该属性用于库功能以改善数据流分析。编译器提示，叶子函数无法使用或修改任何未转义当前编译单元的数据。例如， &lt;code&gt;sin&lt;/code&gt; 函数是叶函数，而 &lt;code&gt;qsort&lt;/code&gt; 不是。</target>
        </trans-unit>
        <trans-unit id="cdb101c8aa868b197540d1e1e07e514397c2827e" translate="yes" xml:space="preserve">
          <source>The attribute parameters configure what values are passed into the kernel function by the GPU drivers, via the initial register state. Some values are used by the compiler, and therefore forced on. Enabling other options may break assumptions in the compiler and/or run-time libraries.</source>
          <target state="translated">属性参数配置了GPU驱动通过初始寄存器状态传递到内核函数中的值。有些值被编译器使用,因此被强制开启。启用其他选项可能会破坏编译器和/或运行时库的假设。</target>
        </trans-unit>
        <trans-unit id="f37e3b5bceea5d68174fbdb23337f013d5dc061b" translate="yes" xml:space="preserve">
          <source>The attributes work in conjunction with a linker script that has been augmented to specify where to place sections with a &lt;code&gt;.lower&lt;/code&gt; and a &lt;code&gt;.upper&lt;/code&gt; prefix. So, for example, as well as placing the &lt;code&gt;.data&lt;/code&gt; section, the script also specifies the placement of a &lt;code&gt;.lower.data&lt;/code&gt; and a &lt;code&gt;.upper.data&lt;/code&gt; section. The intention is that &lt;code&gt;lower&lt;/code&gt; sections are placed into a small but easier to access memory region and the upper sections are placed into a larger, but slower to access, region.</source>
          <target state="translated">这些属性与链接程序脚本协同工作，该链接程序脚本已得到增强，可以指定在何处放置带有 &lt;code&gt;.lower&lt;/code&gt; 和 &lt;code&gt;.upper&lt;/code&gt; 前缀的节。因此，例如，除了放置 &lt;code&gt;.data&lt;/code&gt; 节外，该脚本还指定 &lt;code&gt;.lower.data&lt;/code&gt; 和 &lt;code&gt;.upper.data&lt;/code&gt; 节的位置。目的是将 &lt;code&gt;lower&lt;/code&gt; 放置在较小但易于访问的存储区域中，而将上部放置在较大但访问较慢的区域中。</target>
        </trans-unit>
        <trans-unit id="10feff4fc0898bcb9645a7662553ea298f34abd3" translate="yes" xml:space="preserve">
          <source>The authoritative manual on Objective-C 2.0 is available from Apple:</source>
          <target state="translated">Objective-C 2.0的权威手册可以从苹果公司获得。</target>
        </trans-unit>
        <trans-unit id="f6ef9f24ededd45d5c51229d5801270991d5579a" translate="yes" xml:space="preserve">
          <source>The basic built-in functions described in this section are available on the PowerPC family of processors starting with ISA 2.05 or later. Unless specific options are explicitly disabled on the command line, specifying option</source>
          <target state="translated">本节中描述的基本内置功能在ISA 2.05或更高版本的PowerPC系列处理器上是可用的。除非在命令行中明确禁止特定的选项,否则指定选项</target>
        </trans-unit>
        <trans-unit id="edbf04361cb171c9ec574af51f9f9931b1811352" translate="yes" xml:space="preserve">
          <source>The basic built-in functions described in this section are available on the PowerPC family of processors starting with ISA 2.07 or later. Unless specific options are explicitly disabled on the command line, specifying option</source>
          <target state="translated">本节中描述的基本内置功能在ISA 2.07或更高版本的PowerPC系列处理器上可用。除非在命令行中明确禁止特定的选项,否则指定选项</target>
        </trans-unit>
        <trans-unit id="70f8648696a80bbf371453c7d66873b6ed3c1e9f" translate="yes" xml:space="preserve">
          <source>The basic built-in functions described in this section are available on the PowerPC family of processors starting with ISA 3.0 or later. Unless specific options are explicitly disabled on the command line, specifying option</source>
          <target state="translated">本节中描述的基本内置功能在ISA 3.0或更高版本的PowerPC系列处理器上是可用的。除非在命令行中明确禁止特定的选项,否则指定选项</target>
        </trans-unit>
        <trans-unit id="b5753c392332963f289e128617ea50b9de09b52f" translate="yes" xml:space="preserve">
          <source>The behavior of most of these points are dependent on the implementation of the C library, and are not defined by GCC itself.</source>
          <target state="translated">这些点的行为大多取决于C库的实现,而不是由GCC自己定义的。</target>
        </trans-unit>
        <trans-unit id="12799856c643d4a305ab2b4319a6be1f011a91bc" translate="yes" xml:space="preserve">
          <source>The behavior of these points are dependent on the implementation of the C library, and are not defined by GCC itself.</source>
          <target state="translated">这些点的行为取决于C库的实现,而不是由GCC自己定义的。</target>
        </trans-unit>
        <trans-unit id="98ca99f07d3faae58eb40bce10f1e4e864f854e3" translate="yes" xml:space="preserve">
          <source>The behavior of this switch is not quite the same as marking the methods as hidden directly, because it does not affect static variables local to the function or cause the compiler to deduce that the function is defined in only one shared object.</source>
          <target state="translated">这个开关的行为与直接将方法标记为隐藏不太一样,因为它不会影响函数本地的静态变量,也不会导致编译器推断出函数只在一个共享对象中定义。</target>
        </trans-unit>
        <trans-unit id="7d6b7cdf4a6f4c034253043f3e78682296fde54a" translate="yes" xml:space="preserve">
          <source>The behavior on each recognized non-&lt;code&gt;STDC #pragma&lt;/code&gt; directive (C90 6.8.6, C99 and C11 6.10.6).</source>
          <target state="translated">每个公认的非 &lt;code&gt;STDC #pragma&lt;/code&gt; 指令（C90 6.8.6，C99和C11 6.10.6）上的行为。</target>
        </trans-unit>
        <trans-unit id="78838b89d1e6169626813ca34b5663bfb106ff9a" translate="yes" xml:space="preserve">
          <source>The best solution to such a problem is to put the text into an actual C comment delimited by &amp;lsquo;</source>
          <target state="translated">此类问题的最佳解决方案是将文本放入以'分隔的实际C注释中。</target>
        </trans-unit>
        <trans-unit id="cbc968ad31a477faa2208668bddbf016d38a55ba" translate="yes" xml:space="preserve">
          <source>The built-in compare types&amp;ndash;eq, ne, gtu, ltu, geu, and leu.</source>
          <target state="translated">内置的比较类型-eq，ne，gtu，ltu，geu和leu。</target>
        </trans-unit>
        <trans-unit id="ce0a88d34ad669c64ab3760c61374b2e37e4cc3c" translate="yes" xml:space="preserve">
          <source>The built-in function &lt;code&gt;__builtin_complex&lt;/code&gt; is provided for use in implementing the ISO C11 macros &lt;code&gt;CMPLXF&lt;/code&gt;, &lt;code&gt;CMPLX&lt;/code&gt; and &lt;code&gt;CMPLXL&lt;/code&gt;. &lt;var&gt;real&lt;/var&gt; and &lt;var&gt;imag&lt;/var&gt; must have the same type, a real binary floating-point type, and the result has the corresponding complex type with real and imaginary parts &lt;var&gt;real&lt;/var&gt; and &lt;var&gt;imag&lt;/var&gt;. Unlike &amp;lsquo;</source>
          <target state="translated">提供了内置函数 &lt;code&gt;__builtin_complex&lt;/code&gt; ，用于实现ISO C11宏 &lt;code&gt;CMPLXF&lt;/code&gt; ， &lt;code&gt;CMPLX&lt;/code&gt; 和 &lt;code&gt;CMPLXL&lt;/code&gt; 。 &lt;var&gt;real&lt;/var&gt; 和 &lt;var&gt;imag&lt;/var&gt; 必须具有相同的类型，即实数二进制浮点类型，并且结果具有对应的复杂类型，其中实数和虚数部分为 &lt;var&gt;real&lt;/var&gt; 和 &lt;var&gt;imag&lt;/var&gt; 。与&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="4172235cf37ce3bd8136a03cb1f1f52ca1bd1d30" translate="yes" xml:space="preserve">
          <source>The built-in function &lt;code&gt;__builtin_tgmath&lt;/code&gt;, available only for C and Objective-C, calls a function determined according to the rules of &lt;code&gt;&amp;lt;tgmath.h&amp;gt;&lt;/code&gt; macros. It is intended to be used in implementations of that header, so that expansions of macros from that header only expand each of their arguments once, to avoid problems when calls to such macros are nested inside the arguments of other calls to such macros; in addition, it results in better diagnostics for invalid calls to &lt;code&gt;&amp;lt;tgmath.h&amp;gt;&lt;/code&gt; macros than implementations using other GNU C language features. For example, the &lt;code&gt;pow&lt;/code&gt; type-generic macro might be defined as:</source>
          <target state="translated">内置函数 &lt;code&gt;__builtin_tgmath&lt;/code&gt; （仅适用于C和Objective-C）调用根据 &lt;code&gt;&amp;lt;tgmath.h&amp;gt;&lt;/code&gt; 宏规则确定的函数。它打算用于该标头的实现中，以便从该标头扩展宏只能将其每个参数扩展一次，以避免在将对此类宏的调用嵌套在对此类宏的其他调用的参数中时出现的问题；此外，与使用其他GNU C语言功能的实现相比，它可以更好地诊断对 &lt;code&gt;&amp;lt;tgmath.h&amp;gt;&lt;/code&gt; 宏的无效调用。例如， &lt;code&gt;pow&lt;/code&gt; 类型通用宏可以定义为：</target>
        </trans-unit>
        <trans-unit id="a4ab6bdc7a525221a10db36f04ba0ea776ca5cba" translate="yes" xml:space="preserve">
          <source>The built-in function can be used where a variable appears to be used in a safe way, but the CPU, due to speculative execution may temporarily ignore the bounds checks. Consider, for example, the following function:</source>
          <target state="translated">内建函数可以用在一个变量看似安全使用,但CPU由于投机性执行可能暂时忽略边界检查的情况下。例如,考虑以下函数。</target>
        </trans-unit>
        <trans-unit id="a003f5f8fd45a849966ac7beaa6dcf85e370f177" translate="yes" xml:space="preserve">
          <source>The built-in function will either cause execution to stall until the conditional branch has been fully resolved, or it may permit speculative execution to continue, but using 0 instead of &lt;code&gt;untrusted_value&lt;/code&gt; if that exceeds the limit.</source>
          <target state="translated">内置函数将导致执行停止，直到条件分支已完全解决为止，或者它可以允许推测执行继续进行，但如果超出限制，则使用0而不是 &lt;code&gt;untrusted_value&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="23fbf2c81175bf34ed4b14a9d7849c7a6ed67337" translate="yes" xml:space="preserve">
          <source>The built-in functions are optimized into the normal string functions like &lt;code&gt;memcpy&lt;/code&gt; if the last argument is &lt;code&gt;(size_t) -1&lt;/code&gt; or if it is known at compile time that the destination object will not be overflowed. If the compiler can determine at compile time that the object will always be overflowed, it issues a warning.</source>
          <target state="translated">如果最后一个参数为 &lt;code&gt;(size_t) -1&lt;/code&gt; 或在编译时得知目标对象不会溢出，则将内置函数优化为诸如 &lt;code&gt;memcpy&lt;/code&gt; 之类的常规字符串函数。如果编译器可以在编译时确定该对象将始终被溢出，则会发出警告。</target>
        </trans-unit>
        <trans-unit id="97b0909bb726639d57f4621d69b4f030cedbb5e2" translate="yes" xml:space="preserve">
          <source>The built-in functions promote the first two operands into infinite precision signed type and perform addition on those promoted operands. The result is then cast to the type of the third argument. If the cast result is equal to the infinite precision result, the built-in functions return &lt;code&gt;false&lt;/code&gt;, otherwise they return &lt;code&gt;true&lt;/code&gt;. The value of the third argument is ignored, just the side effects in the third argument are evaluated, and no integral argument promotions are performed on the last argument. If the third argument is a bit-field, the type used for the result cast has the precision and signedness of the given bit-field, rather than precision and signedness of the underlying type.</source>
          <target state="translated">内置函数将前两个操作数提升为无限精度带符号类型，并对这些提升的操作数执行加法运算。然后将结果转换为第三个参数的类型。如果强制转换结果等于无限精度结果，则内置函数返回 &lt;code&gt;false&lt;/code&gt; ，否则返回 &lt;code&gt;true&lt;/code&gt; 。将忽略第三个参数的值，仅评估第三个参数中的副作用，并且不对最后一个参数执行积分参数提升。如果第三个参数是位字段，则用于结果强制转换的类型具有给定位字段的精度和正负号，而不是基础类型的精度和正负号。</target>
        </trans-unit>
        <trans-unit id="b3bbc4c3c1cb9c4fe70210b2dfdbc17fe5153882" translate="yes" xml:space="preserve">
          <source>The built-in functions supported are:</source>
          <target state="translated">支持的内置功能有:</target>
        </trans-unit>
        <trans-unit id="334b3175e81dee6f1e168a0be44f3b7d957b1be7" translate="yes" xml:space="preserve">
          <source>The built-in macros&amp;rsquo; names follow the scheme &lt;code&gt;__AVR_&lt;var&gt;Device&lt;/var&gt;__&lt;/code&gt; where &lt;var&gt;Device&lt;/var&gt; is the device name as from the AVR user manual. The difference between &lt;var&gt;Device&lt;/var&gt; in the built-in macro and &lt;var&gt;device&lt;/var&gt; in</source>
          <target state="translated">内置宏的名称遵循 &lt;code&gt;__AVR_&lt;var&gt;Device&lt;/var&gt;__&lt;/code&gt; 方案，其中 &lt;var&gt;Device&lt;/var&gt; 是AVR用户手册中的设备名称。内置宏中的 &lt;var&gt;device&lt;/var&gt; 与设备中的 &lt;var&gt;Device&lt;/var&gt; 之间的区别</target>
        </trans-unit>
        <trans-unit id="62f099d3393656bddb7d8b0dd222e5a223f8d688" translate="yes" xml:space="preserve">
          <source>The built-in versions of these functions use GCC&amp;rsquo;s normal mechanisms to save and restore registers using the stack on function entry and exit. The jump buffer argument &lt;var&gt;buf&lt;/var&gt; holds only the information needed to restore the stack frame, rather than the entire set of saved register values.</source>
          <target state="translated">这些函数的内置版本使用GCC的常规机制通过函数进入和退出时的堆栈来保存和恢复寄存器。跳转缓冲区参数 &lt;var&gt;buf&lt;/var&gt; 仅保存恢复堆栈帧所需的信息，而不保存整个保存的寄存器值集。</target>
        </trans-unit>
        <trans-unit id="4488c1d75b7b81f78b64d60c26fdf9ed24d8f3bf" translate="yes" xml:space="preserve">
          <source>The call-clobbered integer registers.</source>
          <target state="translated">调用的整数寄存器。</target>
        </trans-unit>
        <trans-unit id="0b277cbf75c7f621fb1dabe16f1a3a2fa8a7f4cc" translate="yes" xml:space="preserve">
          <source>The caller copies function arguments passed by hidden reference. This option should be used with care as it is not compatible with the default 32-bit runtime. However, only aggregates larger than eight bytes are passed by hidden reference and the option provides better compatibility with OpenMP.</source>
          <target state="translated">调用者复制通过隐藏引用传递的函数参数。这个选项应该谨慎使用,因为它与默认的32位运行时不兼容。然而,只有大于8个字节的集合才会通过隐藏引用传递,而且该选项与OpenMP有更好的兼容性。</target>
        </trans-unit>
        <trans-unit id="b583bb229dda327522feb6b40a364f4908fd1bf3" translate="yes" xml:space="preserve">
          <source>The carry register.</source>
          <target state="translated">携带登记簿。</target>
        </trans-unit>
        <trans-unit id="c7287b1af6a41a31db6c4fc8adca45c0df1d456b" translate="yes" xml:space="preserve">
          <source>The change to the types of UTF-8 string and character literals introduces incompatibilities with ISO C++11 and later standards. For example, the following code is well-formed under ISO C++11, but is ill-formed when</source>
          <target state="translated">对UTF-8字符串和字符类型的改变,导致了与ISO C++11和更高标准的不兼容。例如,下面的代码在ISO C++11下格式良好,但在以下情况下格式不正确</target>
        </trans-unit>
        <trans-unit id="9023ce61724bbabe84554211f1682a5b7d26a59b" translate="yes" xml:space="preserve">
          <source>The character &amp;lsquo;</source>
          <target state="translated">人物 '</target>
        </trans-unit>
        <trans-unit id="519631b15cf0936ab9bd0c60033ca6acf8715c58" translate="yes" xml:space="preserve">
          <source>The choices for &lt;var&gt;cpu-type&lt;/var&gt; are the same as for</source>
          <target state="translated">&lt;var&gt;cpu-type&lt;/var&gt; 的选择与for 相同</target>
        </trans-unit>
        <trans-unit id="682ea402eec35d575ae857912b781a6cde1e0d53" translate="yes" xml:space="preserve">
          <source>The choices for &lt;var&gt;cpu-type&lt;/var&gt; are:</source>
          <target state="translated">&lt;var&gt;cpu-type&lt;/var&gt; 的选择是：</target>
        </trans-unit>
        <trans-unit id="8623d02fccd10cdf135414efb4d8dedf3d5298b1" translate="yes" xml:space="preserve">
          <source>The code above would iterate over all objects in &lt;code&gt;array&lt;/code&gt;. For each of them, it assigns it to &lt;code&gt;object&lt;/code&gt;, then executes the &lt;code&gt;Do something with 'object'&lt;/code&gt; statements.</source>
          <target state="translated">上面的代码将遍历 &lt;code&gt;array&lt;/code&gt; 中的所有对象。对于每个 &lt;code&gt;object&lt;/code&gt; ，它将其分配给object，然后执行 &lt;code&gt;Do something with 'object'&lt;/code&gt; 语句执行&amp;ldquo;做某事&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="990cbdb236536d3c2c7b3b4ad41a30dc08b70c1d" translate="yes" xml:space="preserve">
          <source>The colors are defined by the environment variable &lt;code&gt;GCC_COLORS&lt;/code&gt;. Its value is a colon-separated list of capabilities and Select Graphic Rendition (SGR) substrings. SGR commands are interpreted by the terminal or terminal emulator. (See the section in the documentation of your text terminal for permitted values and their meanings as character attributes.) These substring values are integers in decimal representation and can be concatenated with semicolons. Common values to concatenate include &amp;lsquo;</source>
          <target state="translated">颜色由环境变量 &lt;code&gt;GCC_COLORS&lt;/code&gt; 定义。它的值是用冒号分隔的功能和选择图形渲染（SGR）子字符串列表。SGR命令由终端或终端仿真器解释。（有关允许的值及其作为字符属性的含义，请参见文本终端文档中的部分。）这些子字符串值是十进制表示形式的整数，可以与分号连接。连接的常见值包括&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="34aa8249352c8e598246fe5c42924ea343806e93" translate="yes" xml:space="preserve">
          <source>The comment needs to be followed after optional whitespace and other comments by &lt;code&gt;case&lt;/code&gt; or &lt;code&gt;default&lt;/code&gt; keywords or by a user label that precedes some &lt;code&gt;case&lt;/code&gt; or &lt;code&gt;default&lt;/code&gt; label.</source>
          <target state="translated">注释需要在可选的空格和其他注释之后加上 &lt;code&gt;case&lt;/code&gt; 或 &lt;code&gt;default&lt;/code&gt; 关键字，或者在某些 &lt;code&gt;case&lt;/code&gt; 或 &lt;code&gt;default&lt;/code&gt; 标签之前的用户标签之后。</target>
        </trans-unit>
        <trans-unit id="f4f1f40d78278988845f6e6d5dd1df865371c25c" translate="yes" xml:space="preserve">
          <source>The comments are intended for humans rather than machines and hence the precise format of the comments is subject to change.</source>
          <target state="translated">评论的对象是人而不是机器,因此评论的精确格式可能会发生变化。</target>
        </trans-unit>
        <trans-unit id="92f39136333428ef92d0ab34cd6ec4175f20f2a6" translate="yes" xml:space="preserve">
          <source>The common src/dest memory addressing modes.</source>
          <target state="translated">常见的Src/est内存寻址模式。</target>
        </trans-unit>
        <trans-unit id="23d24a28b1d2dd308a7ff9954bb96ae5aaa048ba" translate="yes" xml:space="preserve">
          <source>The common subset of the ARMv7-A, ARMv7-R and ARMv7-M architectures.</source>
          <target state="translated">ARMv7-A、ARMv7-R和ARMv7-M架构的通用子集。</target>
        </trans-unit>
        <trans-unit id="17c10738c483ffe85f7448f4cbfe545afae5514b" translate="yes" xml:space="preserve">
          <source>The compiler assumes that &lt;code&gt;EIND&lt;/code&gt; never changes during the startup code or during the application. In particular, &lt;code&gt;EIND&lt;/code&gt; is not saved/restored in function or interrupt service routine prologue/epilogue.</source>
          <target state="translated">编译器假定 &lt;code&gt;EIND&lt;/code&gt; 在启动代码或应用程序期间不会改变。特别是， &lt;code&gt;EIND&lt;/code&gt; 不会保存/恢复到功能中，也不会中断服务程序的序言/结尾。</target>
        </trans-unit>
        <trans-unit id="8983abbfe719941604e388ad4f86efe2a35d89a4" translate="yes" xml:space="preserve">
          <source>The compiler automatically sets the alignment for the declared variable or field to &lt;code&gt;__BIGGEST_ALIGNMENT__&lt;/code&gt;. Doing this can often make copy operations more efficient, because the compiler can use whatever instructions copy the biggest chunks of memory when performing copies to or from the variables or fields that you have aligned this way. Note that the value of &lt;code&gt;__BIGGEST_ALIGNMENT__&lt;/code&gt; may change depending on command-line options.</source>
          <target state="translated">编译器会自动将声明的变量或字段的对齐方式设置为 &lt;code&gt;__BIGGEST_ALIGNMENT__&lt;/code&gt; 。这样做通常可以使复制操作更有效率，因为在执行以这种方式对齐的变量或字段或从中进行复制时，编译器可以使用任何指令来复制最大的内存块。请注意， &lt;code&gt;__BIGGEST_ALIGNMENT__&lt;/code&gt; 的值可能会更改，具体取决于命令行选项。</target>
        </trans-unit>
        <trans-unit id="9e7e2956c5fa63410dcde9892cdb317e8b9bdabe" translate="yes" xml:space="preserve">
          <source>The compiler can accept several base standards, such as &amp;lsquo;</source>
          <target state="translated">编译器可以接受几种基本标准，例如&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="ae77b7d999c147c822471a0c6078013beaa6bc78" translate="yes" xml:space="preserve">
          <source>The compiler checks to see if the path provided by</source>
          <target state="translated">编译器检查是否由</target>
        </trans-unit>
        <trans-unit id="e75bc3167776cc7681a2a3309af02b07eee5f4ff" translate="yes" xml:space="preserve">
          <source>The compiler contains estimates of the number of clock cycles for &amp;ldquo;typical&amp;rdquo; EV4 &amp;amp; EV5 hardware for the Level 1, 2 &amp;amp; 3 caches (also called Dcache, Scache, and Bcache), as well as to main memory. Note that L3 is only valid for EV5.</source>
          <target state="translated">编译器包含对1级，2级和3级缓存（也称为Dcache，Scache和Bcache）以及主内存的&amp;ldquo;典型&amp;rdquo; EV4和EV5硬件的时钟周期数的估计。请注意，L3仅对EV5有效。</target>
        </trans-unit>
        <trans-unit id="8338416b67f14201602d466304368b7f468175f5" translate="yes" xml:space="preserve">
          <source>The compiler copies the assembler instructions in a basic &lt;code&gt;asm&lt;/code&gt; verbatim to the assembly language output file, without processing dialects or any of the &amp;lsquo;</source>
          <target state="translated">编译器将基本 &lt;code&gt;asm&lt;/code&gt; 语言中的汇编程序指令逐字复制到汇编语言输出文件中，而无需处理方言或任何&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="d28532eae1da814b4665d28f7dd4fbb9e0aec8b2" translate="yes" xml:space="preserve">
          <source>The compiler driver program runs one or more of the subprograms &lt;code&gt;cpp&lt;/code&gt;, &lt;code&gt;cc1&lt;/code&gt;, &lt;code&gt;as&lt;/code&gt; and &lt;code&gt;ld&lt;/code&gt;. It tries &lt;var&gt;prefix&lt;/var&gt; as a prefix for each program it tries to run, both with and without &amp;lsquo;</source>
          <target state="translated">编译器驱动程序运行一个或多个子程序 &lt;code&gt;cpp&lt;/code&gt; ， &lt;code&gt;cc1&lt;/code&gt; ， &lt;code&gt;as&lt;/code&gt; 和 &lt;code&gt;ld&lt;/code&gt; 。它尝试将 &lt;var&gt;prefix&lt;/var&gt; 作为尝试运行的每个程序的前缀，无论是否使用'</target>
        </trans-unit>
        <trans-unit id="9b9b15ff6acdc5c85d5777579b9105147bc703cb" translate="yes" xml:space="preserve">
          <source>The compiler emits such &lt;code&gt;gs&lt;/code&gt; modifiers for code labels in the following situations:</source>
          <target state="translated">在以下情况下，编译器会为代码标签发出此类 &lt;code&gt;gs&lt;/code&gt; 修饰符：</target>
        </trans-unit>
        <trans-unit id="1aa76bdb9ae1bbf7aa774ff7d0e6d298e86f04a3" translate="yes" xml:space="preserve">
          <source>The compiler generates special code to access the variable &lt;code&gt;i&lt;/code&gt;. It may use runtime library support, or generate special machine instructions to access that address space.</source>
          <target state="translated">编译器生成特殊代码以访问变量 &lt;code&gt;i&lt;/code&gt; 。它可以使用运行时库支持，或生成特殊的机器指令来访问该地址空间。</target>
        </trans-unit>
        <trans-unit id="6d157d680a0dc51afbbd2163137f4b54277c4701" translate="yes" xml:space="preserve">
          <source>The compiler is configured to be used together with AVR-Libc. See the</source>
          <target state="translated">编译器被配置为与AVR-Libc一起使用。参见</target>
        </trans-unit>
        <trans-unit id="fdab34c680d8fa9373eabc63f94733d605cf2016" translate="yes" xml:space="preserve">
          <source>The compiler may generate calls to &lt;code&gt;memcmp&lt;/code&gt;, &lt;code&gt;memset&lt;/code&gt;, &lt;code&gt;memcpy&lt;/code&gt; and &lt;code&gt;memmove&lt;/code&gt;. These entries are usually resolved by entries in libc. These entry points should be supplied through some other mechanism when this option is specified.</source>
          <target state="translated">编译器可能会生成对 &lt;code&gt;memcmp&lt;/code&gt; ， &lt;code&gt;memset&lt;/code&gt; ， &lt;code&gt;memcpy&lt;/code&gt; 和 &lt;code&gt;memmove&lt;/code&gt; 的调用。这些条目通常由libc中的条目解析。指定此选项后，应通过其他某种机制来提供这些入口点。</target>
        </trans-unit>
        <trans-unit id="197f6accb1b57a2d3b7bbd9dc901a8f9853c9909" translate="yes" xml:space="preserve">
          <source>The compiler may move the addition back before the &lt;code&gt;volatile asm&lt;/code&gt; statement. To make it work as expected, add an artificial dependency to the &lt;code&gt;asm&lt;/code&gt; by referencing a variable in the subsequent code, for example:</source>
          <target state="translated">编译器可以将附加项移回 &lt;code&gt;volatile asm&lt;/code&gt; 语句之前。为了使它按预期工作，请通过在后续代码中引用一个变量，将人工依赖项添加到 &lt;code&gt;asm&lt;/code&gt; 中，例如：</target>
        </trans-unit>
        <trans-unit id="2d9dc939c11511961a2efd9a38375989ea973bee" translate="yes" xml:space="preserve">
          <source>The compiler never sets &lt;code&gt;EIND&lt;/code&gt;.</source>
          <target state="translated">编译器从不设置 &lt;code&gt;EIND&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d5c65d66d80d8006703599470ce9ad6d678c7518" translate="yes" xml:space="preserve">
          <source>The compiler performs optimization based on the knowledge it has of the program. Compiling multiple files at once to a single output file mode allows the compiler to use information gained from all of the files when compiling each of them.</source>
          <target state="translated">编译器根据它对程序的了解进行优化。一次编译多个文件到一个输出文件模式,编译器在编译每个文件时,可以使用从所有文件中获得的信息。</target>
        </trans-unit>
        <trans-unit id="059a79983e1d0cd8bbb8de563c5411cbd5695493" translate="yes" xml:space="preserve">
          <source>The compiler rearranges the member initializers for &lt;code&gt;i&lt;/code&gt; and &lt;code&gt;j&lt;/code&gt; to match the declaration order of the members, emitting a warning to that effect. This warning is enabled by</source>
          <target state="translated">编译器重新排列 &lt;code&gt;i&lt;/code&gt; 和 &lt;code&gt;j&lt;/code&gt; 的成员初始化器，以匹配成员的声明顺序，从而发出警告。此警告通过以下方式启用</target>
        </trans-unit>
        <trans-unit id="6f7ea77386532c48049a0ac434d425f5c9cdb9e9" translate="yes" xml:space="preserve">
          <source>The compiler uses &lt;code&gt;EIND&lt;/code&gt; implicitly in &lt;code&gt;EICALL&lt;/code&gt;/&lt;code&gt;EIJMP&lt;/code&gt; instructions or might read &lt;code&gt;EIND&lt;/code&gt; directly in order to emulate an indirect call/jump by means of a &lt;code&gt;RET&lt;/code&gt; instruction.</source>
          <target state="translated">编译器在 &lt;code&gt;EICALL&lt;/code&gt; / &lt;code&gt;EIJMP&lt;/code&gt; 指令中隐式使用 &lt;code&gt;EIND&lt;/code&gt; ，或者可能直接读取 &lt;code&gt;EIND&lt;/code&gt; 以便通过 &lt;code&gt;RET&lt;/code&gt; 指令模拟间接调用/跳转。</target>
        </trans-unit>
        <trans-unit id="a697129b447131da9ef72d7d16ecc19d13cde06f" translate="yes" xml:space="preserve">
          <source>The compiler uses a variety of heuristics to determine whether or not to inline a function. For example, the compiler takes into account the size of the function being inlined and the amount of inlining that has already been done in the current function. Therefore, seemingly insignificant changes in the source program can cause the warnings produced by</source>
          <target state="translated">编译器使用各种启发式方法来决定是否对一个函数进行内联。例如,编译器会考虑被内联的函数的大小和当前函数中已经完成的内联量。因此,源程序中看似微不足道的变化,都可能导致由</target>
        </trans-unit>
        <trans-unit id="37e71b48c058bf8bd050867961b9167f5825927e" translate="yes" xml:space="preserve">
          <source>The compiler will attempt to use hardware instructions to implement these built-in functions where possible, like conditional jump on overflow after addition, conditional jump on carry etc.</source>
          <target state="translated">编译器会尽量使用硬件指令来实现这些内置函数,比如加法后溢出时的条件跳转,携带时的条件跳转等。</target>
        </trans-unit>
        <trans-unit id="1f76bb0a6a769fd6051ac5f386b3821fb4f8794e" translate="yes" xml:space="preserve">
          <source>The concatenated &lt;code&gt;hi&lt;/code&gt; and &lt;code&gt;lo&lt;/code&gt; registers. Use this register to store doubleword values.</source>
          <target state="translated">串联的 &lt;code&gt;hi&lt;/code&gt; 和 &lt;code&gt;lo&lt;/code&gt; 寄存器。使用该寄存器存储双字值。</target>
        </trans-unit>
        <trans-unit id="99e27c97d9f5e63a4ed1ab3fd7f4a5a1d329e043" translate="yes" xml:space="preserve">
          <source>The conditional text &lt;code&gt;X&lt;/code&gt; in a &amp;lsquo;</source>
          <target state="translated">有条件的文字 &lt;code&gt;X&lt;/code&gt; 在'</target>
        </trans-unit>
        <trans-unit id="a43dc662cd7d08ba0c1419ce7462e0ce31ad7cad" translate="yes" xml:space="preserve">
          <source>The constant -1</source>
          <target state="translated">常数-1</target>
        </trans-unit>
        <trans-unit id="b06d0b57697105de48b17a361b846597d95ea06a" translate="yes" xml:space="preserve">
          <source>The constant 0.</source>
          <target state="translated">常数0。</target>
        </trans-unit>
        <trans-unit id="40c6bdbaee6c04b3fea04b89e43f4576ad393c2b" translate="yes" xml:space="preserve">
          <source>The constant 4096</source>
          <target state="translated">常数4096</target>
        </trans-unit>
        <trans-unit id="2dcf3547f5273811228bed3353ffa4e638845233" translate="yes" xml:space="preserve">
          <source>The constant all-ones, for floating-point.</source>
          <target state="translated">常数全一,为浮点数。</target>
        </trans-unit>
        <trans-unit id="d766b475adfc1a095915836fa6b0ad31150ade7f" translate="yes" xml:space="preserve">
          <source>The constant string objects are by default instances of the &lt;code&gt;NXConstantString&lt;/code&gt; class which is provided by the GNU Objective-C runtime. To get the definition of this class you must include the</source>
          <target state="translated">常量字符串对象默认情况下是GNU Objective-C运行时提供的 &lt;code&gt;NXConstantString&lt;/code&gt; 类的实例。要获取此类的定义，您必须包含</target>
        </trans-unit>
        <trans-unit id="66bea79ec7c08d8354c118573be3f32ece7da1fe" translate="yes" xml:space="preserve">
          <source>The constant zero</source>
          <target state="translated">常数为零</target>
        </trans-unit>
        <trans-unit id="0934955261fabaea67e58ba0c7b8bdff156718f6" translate="yes" xml:space="preserve">
          <source>The constant zero or one</source>
          <target state="translated">常数零或一</target>
        </trans-unit>
        <trans-unit id="910f5457ff53fa25b37247787227a27d85f14892" translate="yes" xml:space="preserve">
          <source>The constraint matches if the specified part of a constant has a value different from its other parts.</source>
          <target state="translated">如果一个常量的指定部分的值与其他部分的值不同,则约束条件匹配。</target>
        </trans-unit>
        <trans-unit id="d2273d82451da8273035b5677a47ae31f7f347c8" translate="yes" xml:space="preserve">
          <source>The contents of &lt;var&gt;definition&lt;/var&gt; are tokenized and processed as if they appeared during translation phase three in a &amp;lsquo;</source>
          <target state="translated">对 &lt;var&gt;definition&lt;/var&gt; 的内容进行标记和处理，就像它们出现在翻译的第三阶段中，</target>
        </trans-unit>
        <trans-unit id="3b752ddcb3035f47ee09a797efcd12407968ef21" translate="yes" xml:space="preserve">
          <source>The convenience of this extension is that &lt;code&gt;f1&lt;/code&gt; has the desired type, eliminating the need to consistently refer to &lt;code&gt;f2.f1&lt;/code&gt;.</source>
          <target state="translated">此扩展的便利之处在于 &lt;code&gt;f1&lt;/code&gt; 具有所需的类型，从而无需始终引用 &lt;code&gt;f2.f1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6eb402cf1ad5d2ebe2ca4cbf79d4710d25aab043" translate="yes" xml:space="preserve">
          <source>The correct solution of the above problem is to use the &lt;code&gt;+load&lt;/code&gt; method instead of &lt;code&gt;+initialize&lt;/code&gt;:</source>
          <target state="translated">上述问题的正确解决方案是使用 &lt;code&gt;+load&lt;/code&gt; 方法而不是 &lt;code&gt;+initialize&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="195548e33bab5979c07277ae9248599cd2872bd1" translate="yes" xml:space="preserve">
          <source>The count register, &lt;code&gt;ctr&lt;/code&gt;.</source>
          <target state="translated">计数寄存器 &lt;code&gt;ctr&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f5773d425eed0cc1da37ec24e48650c9ef1f3309" translate="yes" xml:space="preserve">
          <source>The cryptographic instructions.</source>
          <target state="translated">加密指令。</target>
        </trans-unit>
        <trans-unit id="3b148cbd7e0801501003f1c6b7a5b5ed93ac8a89" translate="yes" xml:space="preserve">
          <source>The cryptographic instructions. This also enables the Advanced SIMD and floating-point instructions as well as the Dot Product extension.</source>
          <target state="translated">的加密指令。这也使得高级SIMD和浮点指令以及Dot Product扩展成为可能。</target>
        </trans-unit>
        <trans-unit id="bebf33834922696e2e3f146a7028c6f38f3d8ce5" translate="yes" xml:space="preserve">
          <source>The cryptographic instructions. This also enables the Advanced SIMD and floating-point instructions.</source>
          <target state="translated">的加密指令。这也使高级SIMD和浮点指令成为可能。</target>
        </trans-unit>
        <trans-unit id="3b57febbf4c477f2667a31f8b5a1e7554fec41ce" translate="yes" xml:space="preserve">
          <source>The current</source>
          <target state="translated">当前</target>
        </trans-unit>
        <trans-unit id="0c616918c11c60074662af2cce8d7bf0b00b006e" translate="yes" xml:space="preserve">
          <source>The current implementation of LTO makes no attempt to generate bytecode that is portable between different types of hosts. The bytecode files are versioned and there is a strict version check, so bytecode files generated in one version of GCC do not work with an older or newer version of GCC.</source>
          <target state="translated">目前LTO的实现并没有尝试生成可在不同类型主机之间移植的字节码。字节码文件是有版本的,并且有严格的版本检查,所以在一个版本的GCC中生成的字节码文件不能在旧版本或新版本的GCC中使用。</target>
        </trans-unit>
        <trans-unit id="3c2f64218f4b3df3bf76a18bea506a72c2b53fb3" translate="yes" xml:space="preserve">
          <source>The current locale used to convert a wide character constant consisting of a single multibyte character that maps to a member of the extended execution character set into a corresponding wide character code (C90 6.1.3.4, C99 and C11 6.4.4.4).</source>
          <target state="translated">当前用于将由单个多字节字符组成的宽字符常量转换为相应的宽字符代码的locale(C90 6.1.3.4,C99和C11 6.4.4.4),该字符常量映射到扩展执行字符集的一个成员。</target>
        </trans-unit>
        <trans-unit id="a8b517f5ebe96bc26ba29bd9df7b451bc7264848" translate="yes" xml:space="preserve">
          <source>The current locale used to convert a wide string literal into corresponding wide character codes (C90 6.1.4, C99 and C11 6.4.5).</source>
          <target state="translated">当前用于将宽字符串文字转换为相应宽字符代码的locale(C90 6.1.4、C99和C11 6.4.5)。</target>
        </trans-unit>
        <trans-unit id="cdee0986787f12266222c4757db3c96510d2856b" translate="yes" xml:space="preserve">
          <source>The data in the</source>
          <target state="translated">的数据。</target>
        </trans-unit>
        <trans-unit id="ad21981df5f9d5df0a92c3202b31e09f62748eca" translate="yes" xml:space="preserve">
          <source>The data segment must be within 512KB while the read-only data segment can be within 4GB addressing space. The text segment should be still within 16MB addressing space.</source>
          <target state="translated">数据段必须在512KB以内,而只读数据段可以在4GB寻址空间内。文本段仍应在16MB寻址空间内。</target>
        </trans-unit>
        <trans-unit id="308218254edaf858c826e3717d9728c20e8ea1e8" translate="yes" xml:space="preserve">
          <source>The decimal floating types are &lt;code&gt;_Decimal32&lt;/code&gt;, &lt;code&gt;_Decimal64&lt;/code&gt;, and &lt;code&gt;_Decimal128&lt;/code&gt;. They use a radix of ten, unlike the floating types &lt;code&gt;float&lt;/code&gt;, &lt;code&gt;double&lt;/code&gt;, and &lt;code&gt;long double&lt;/code&gt; whose radix is not specified by the C standard but is usually two.</source>
          <target state="translated">十进制浮点类型是 &lt;code&gt;_Decimal32&lt;/code&gt; ， &lt;code&gt;_Decimal64&lt;/code&gt; 和 &lt;code&gt;_Decimal128&lt;/code&gt; 。它们使用的基数为十，这与浮动类型 &lt;code&gt;float&lt;/code&gt; ， &lt;code&gt;double&lt;/code&gt; 和 &lt;code&gt;long double&lt;/code&gt; 不同,后者的基数不是C标准指定的，但通常为2。</target>
        </trans-unit>
        <trans-unit id="4ed195636dddaed157754b6f5efb512126f16823" translate="yes" xml:space="preserve">
          <source>The declaration of an identifier for a variable that has block scope that specifies &lt;code&gt;__thread&lt;/code&gt; shall also specify either &lt;code&gt;extern&lt;/code&gt; or &lt;code&gt;static&lt;/code&gt;.</source>
          <target state="translated">具有块范围指定 &lt;code&gt;__thread&lt;/code&gt; 的变量的标识符的声明也应指定 &lt;code&gt;extern&lt;/code&gt; 或 &lt;code&gt;static&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="539622d22b3611e1a0d2bdec661bbb3d138ab211" translate="yes" xml:space="preserve">
          <source>The default</source>
          <target state="translated">默认的</target>
        </trans-unit>
        <trans-unit id="2d93ba84906186c36a266b5450164ecc57295a2f" translate="yes" xml:space="preserve">
          <source>The default &lt;code&gt;GCC_COLORS&lt;/code&gt; is</source>
          <target state="translated">默认的 &lt;code&gt;GCC_COLORS&lt;/code&gt; 是</target>
        </trans-unit>
        <trans-unit id="cd78088e10f5ca7d05051ca6c08ccd0393bc0395" translate="yes" xml:space="preserve">
          <source>The default choice depends on the target.</source>
          <target state="translated">默认选择取决于目标。</target>
        </trans-unit>
        <trans-unit id="24583facb0777645f4006ae576dc03c661b296bf" translate="yes" xml:space="preserve">
          <source>The default depends on how the compiler has been configured. It can be any of the above &lt;var&gt;WHEN&lt;/var&gt; options.</source>
          <target state="translated">默认值取决于编译器的配置方式。它可以是以上任何 &lt;var&gt;WHEN&lt;/var&gt; 选项。</target>
        </trans-unit>
        <trans-unit id="821efaa8e812e852d4a90373d231a1a43df2b45f" translate="yes" xml:space="preserve">
          <source>The default depends on the specific target configuration. Note that the LP64 and ILP32 ABIs are not link-compatible; you must compile your entire program with the same ABI, and link with a compatible set of libraries.</source>
          <target state="translated">默认值取决于特定的目标配置。注意 LP64 和 ILP32 ABI 是不兼容链接的;你必须用相同的 ABI 编译你的整个程序,并与一组兼容的库链接。</target>
        </trans-unit>
        <trans-unit id="073f483a59a39bdd6290fbf3294619a632dc2b8a" translate="yes" xml:space="preserve">
          <source>The default depends on the specific target configuration. Note that the hard-float and soft-float ABIs are not link-compatible; you must compile your entire program with the same ABI, and link with a compatible set of libraries.</source>
          <target state="translated">默认值取决于特定的目标配置。请注意,硬浮点和软浮点 ABI 不兼容链接;您必须使用相同的 ABI 编译整个程序,并使用兼容的库集进行链接。</target>
        </trans-unit>
        <trans-unit id="83926f7ff8324784f23d17c03f2640efad441ea9" translate="yes" xml:space="preserve">
          <source>The default for</source>
          <target state="translated">默认的</target>
        </trans-unit>
        <trans-unit id="c9e7e18cf6d489e9159a83316e730a739e99cc90" translate="yes" xml:space="preserve">
          <source>The default for this argument is system dependent, users who want a specific calling convention should specify one explicitly. The valid calling conventions are: &amp;lsquo;</source>
          <target state="translated">此参数的默认值取决于系统，需要特定调用约定的用户应明确指定一个。有效的调用约定为：'</target>
        </trans-unit>
        <trans-unit id="92d2141e4257c252bb28809158d1f4e1362f7a44" translate="yes" xml:space="preserve">
          <source>The default for this option is &amp;lsquo;</source>
          <target state="translated">此选项的默认值为&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="5842694f6173b42e85122f8c60c286aa7ddb9932" translate="yes" xml:space="preserve">
          <source>The default is</source>
          <target state="translated">默认为</target>
        </trans-unit>
        <trans-unit id="f12e5a4f7dd6f8646e20a0f33147742e17617209" translate="yes" xml:space="preserve">
          <source>The default is &amp;lsquo;</source>
          <target state="translated">默认值为&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="5d068c3eaa8d9ce215b5361f4b44c855149b5984" translate="yes" xml:space="preserve">
          <source>The default is 30% + 70% * (RAM/1GB) with an upper bound of 100% when RAM &amp;gt;= 1GB. If &lt;code&gt;getrlimit&lt;/code&gt; is available, the notion of &amp;ldquo;RAM&amp;rdquo; is the smallest of actual RAM and &lt;code&gt;RLIMIT_DATA&lt;/code&gt; or &lt;code&gt;RLIMIT_AS&lt;/code&gt;. If GCC is not able to calculate RAM on a particular platform, the lower bound of 30% is used. Setting this parameter and</source>
          <target state="translated">当RAM&amp;gt; = 1GB时，默认值为30％+ 70％*（RAM / 1GB），上限为100％。如果 &lt;code&gt;getrlimit&lt;/code&gt; 可用，则&amp;ldquo; RAM&amp;rdquo;的概念是实际RAM和 &lt;code&gt;RLIMIT_DATA&lt;/code&gt; 或 &lt;code&gt;RLIMIT_AS&lt;/code&gt; 中的最小值。如果GCC无法在特定平台上计算RAM，则使用30％的下限。设置此参数和</target>
        </trans-unit>
        <trans-unit id="cce96b424afaca2d610cda8bfb3dce73bc563484" translate="yes" xml:space="preserve">
          <source>The default is the smaller of RAM/8, RLIMIT_RSS, or a limit that tries to ensure that RLIMIT_DATA or RLIMIT_AS are not exceeded, but with a lower bound of 4096 (four megabytes) and an upper bound of 131072 (128 megabytes). If GCC is not able to calculate RAM on a particular platform, the lower bound is used. Setting this parameter very large effectively disables garbage collection. Setting this parameter and</source>
          <target state="translated">默认值是RAM/8、RLIMIT_RSS或试图确保不超过RLIMIT_DATA或RLIMIT_AS的限制中的较小值,但下限为4096(4兆),上限为131072(128兆)。如果GCC无法计算特定平台上的RAM,则使用下限。把这个参数设置得非常大,就会有效地禁止垃圾收集。设置这个参数和</target>
        </trans-unit>
        <trans-unit id="cfa3b0a93016b2ef8689d14e510c93e9df2d4e56" translate="yes" xml:space="preserve">
          <source>The default is to allow these instructions, but it is not possible for GCC to reliably detect all circumstances where a string instruction might be used to access an I/O register, so their use cannot be disabled automatically. Instead it is reliant upon the programmer to use the</source>
          <target state="translated">默认情况下是允许这些指令的,但GCC不可能可靠地检测到所有可能使用字符串指令访问I/O寄存器的情况,所以不能自动禁止使用它们。相反,它依赖于程序员使用的</target>
        </trans-unit>
        <trans-unit id="b3f67e8f5424b41ebf8e66523efa318016a862fb" translate="yes" xml:space="preserve">
          <source>The default is to not maintain the backchain.</source>
          <target state="translated">默认情况是不维护后链。</target>
        </trans-unit>
        <trans-unit id="a0a0e13c8768face52cb8f602f8efb80a446348b" translate="yes" xml:space="preserve">
          <source>The default is to not use the packed stack layout.</source>
          <target state="translated">默认情况是不使用打包的堆栈布局。</target>
        </trans-unit>
        <trans-unit id="edb857f688cb7de8ba1fbdc52989269bb35500d9" translate="yes" xml:space="preserve">
          <source>The default is usually</source>
          <target state="translated">默认值通常是</target>
        </trans-unit>
        <trans-unit id="d74d1893ecb7357c9e0df6cf36fc2bbcbd00a365" translate="yes" xml:space="preserve">
          <source>The default linker script is arranged for code with &lt;code&gt;EIND = 0&lt;/code&gt;. If code is supposed to work for a setup with &lt;code&gt;EIND != 0&lt;/code&gt;, a custom linker script has to be used in order to place the sections whose name start with &lt;code&gt;.trampolines&lt;/code&gt; into the segment where &lt;code&gt;EIND&lt;/code&gt; points to.</source>
          <target state="translated">默认链接程序脚本是为 &lt;code&gt;EIND = 0&lt;/code&gt; 代码安排的。如果代码应适用于 &lt;code&gt;EIND != 0&lt;/code&gt; 的设置，则必须使用自定义链接程序脚本，以便将名称以 &lt;code&gt;.trampolines&lt;/code&gt; 开头的部分 &lt;code&gt;EIND&lt;/code&gt; 指向的段中。</target>
        </trans-unit>
        <trans-unit id="27ca561e84dd9753757548b177e64c001dc72487" translate="yes" xml:space="preserve">
          <source>The default memory model for the processor and operating system.</source>
          <target state="translated">处理器和操作系统的默认内存型号。</target>
        </trans-unit>
        <trans-unit id="1d2c3331e29b4e0f75190cbcac7d2cc2935baa6d" translate="yes" xml:space="preserve">
          <source>The default size of &lt;code&gt;int&lt;/code&gt;s, &lt;code&gt;long&lt;/code&gt;s and pointers depends on the ABI. All the supported ABIs use 32-bit &lt;code&gt;int&lt;/code&gt;s. The n64 ABI uses 64-bit &lt;code&gt;long&lt;/code&gt;s, as does the 64-bit EABI; the others use 32-bit &lt;code&gt;long&lt;/code&gt;s. Pointers are the same size as &lt;code&gt;long&lt;/code&gt;s, or the same size as integer registers, whichever is smaller.</source>
          <target state="translated">&lt;code&gt;int&lt;/code&gt; ， &lt;code&gt;long&lt;/code&gt; s和指针的默认大小取决于ABI。所有受支持的ABI都使用32位 &lt;code&gt;int&lt;/code&gt; 。n64 ABI 和64位EABI一样使用64位 &lt;code&gt;long&lt;/code&gt; 。其他使用32位 &lt;code&gt;long&lt;/code&gt; 。指针的大小与 &lt;code&gt;long&lt;/code&gt; 相同，或与整数寄存器相同，以较小者为准。</target>
        </trans-unit>
        <trans-unit id="c7b0f9504e79ddd153856cb5f4d8eb1074e6f4cb" translate="yes" xml:space="preserve">
          <source>The default state for the &lt;code&gt;FENV_ACCESS&lt;/code&gt; pragma (C99 and C11 7.6.1).</source>
          <target state="translated">&lt;code&gt;FENV_ACCESS&lt;/code&gt; 编译指示的默认状态（C99和C11 7.6.1）。</target>
        </trans-unit>
        <trans-unit id="177e9fccdcf6129808c994646c54fbba2a07d2f1" translate="yes" xml:space="preserve">
          <source>The default state for the &lt;code&gt;FP_CONTRACT&lt;/code&gt; pragma (C99 and C11 7.12.2).</source>
          <target state="translated">&lt;code&gt;FP_CONTRACT&lt;/code&gt; 编译指示的默认状态（C99和C11 7.12.2）。</target>
        </trans-unit>
        <trans-unit id="2aba487b3647bdb911ee4d93a6d6e3bbfd1ab912" translate="yes" xml:space="preserve">
          <source>The default target is automatically quoted, as if it were given with</source>
          <target state="translated">默认的目标是自动引用的,就像用</target>
        </trans-unit>
        <trans-unit id="33b715cc53246030b15f24132e973369879e225c" translate="yes" xml:space="preserve">
          <source>The default value is zero, which disables this feature. Note, this feature is not enabled by default with higher optimization levels (</source>
          <target state="translated">默认值为零,禁用该功能。请注意,如果优化级别较高,默认情况下不会启用此功能 (</target>
        </trans-unit>
        <trans-unit id="bbd9601e22b31b48a224ffc4033c0ab4f7fbfa78" translate="yes" xml:space="preserve">
          <source>The default value of &lt;code&gt;GCC_EXEC_PREFIX&lt;/code&gt; is</source>
          <target state="translated">的默认值 &lt;code&gt;GCC_EXEC_PREFIX&lt;/code&gt; 是</target>
        </trans-unit>
        <trans-unit id="209814b876827ae56a611572209eb49a8bba5de1" translate="yes" xml:space="preserve">
          <source>The default value of this option is determined by the application binary interface for the target processor.</source>
          <target state="translated">该选项的默认值由目标处理器的应用二进制接口决定。</target>
        </trans-unit>
        <trans-unit id="59182b861f448516d9a37ab74276ea6b6b33c147" translate="yes" xml:space="preserve">
          <source>The default value of this option is enabled, thus the only useful form of the option is</source>
          <target state="translated">该选项的默认值是启用,因此该选项的唯一有用形式是</target>
        </trans-unit>
        <trans-unit id="1a823e9ffdad4eb9044013582624dc9752e06eea" translate="yes" xml:space="preserve">
          <source>The default warning level of the</source>
          <target state="translated">的默认警告级别。</target>
        </trans-unit>
        <trans-unit id="c7308db0e02a6c747424ae6a4742ab7d5a6523ec" translate="yes" xml:space="preserve">
          <source>The default when in a standards compliant mode (</source>
          <target state="translated">在标准兼容模式下的默认值 (</target>
        </trans-unit>
        <trans-unit id="c45a650c66e86b129ff1159a971751cec60bc96d" translate="yes" xml:space="preserve">
          <source>The default without</source>
          <target state="translated">默认不含</target>
        </trans-unit>
        <trans-unit id="ecb6ca065b9096c7acde0b3f9da92272ca10172c" translate="yes" xml:space="preserve">
          <source>The default x86-32 ABI assumes that the callee pops the stack for hidden pointer. However, on x86-32 Microsoft Windows targets, the compiler assumes that the caller pops the stack for hidden pointer.</source>
          <target state="translated">默认的x86-32 ABI假设被调用者弹出堆栈以获得隐藏的指针。然而,在x86-32 Microsoft Windows目标上,编译器假设调用者会弹出栈中的隐藏指针。</target>
        </trans-unit>
        <trans-unit id="a2e6fba24182b6c22f37f14e5bbdf01ab49ea815" translate="yes" xml:space="preserve">
          <source>The default, if no C language dialect options are given, is</source>
          <target state="translated">如果没有给定C语言方言选项,则默认为</target>
        </trans-unit>
        <trans-unit id="94e40f79f518daef10239cd573498a0a9fbea872" translate="yes" xml:space="preserve">
          <source>The default, if no C++ language dialect options are given, is</source>
          <target state="translated">如果没有给定C++语言方言选项,则默认为</target>
        </trans-unit>
        <trans-unit id="63d161b7c381e191c75f2893e8fc452452e1e3d3" translate="yes" xml:space="preserve">
          <source>The definition given in the Intel documentation allows only for the use of the types &lt;code&gt;int&lt;/code&gt;, &lt;code&gt;long&lt;/code&gt;, &lt;code&gt;long long&lt;/code&gt; or their unsigned counterparts. GCC allows any scalar type that is 1, 2, 4 or 8 bytes in size other than the C type &lt;code&gt;_Bool&lt;/code&gt; or the C++ type &lt;code&gt;bool&lt;/code&gt;. Operations on pointer arguments are performed as if the operands were of the &lt;code&gt;uintptr_t&lt;/code&gt; type. That is, they are not scaled by the size of the type to which the pointer points.</source>
          <target state="translated">英特尔文档中给出的定义仅允许使用 &lt;code&gt;int&lt;/code&gt; ， &lt;code&gt;long&lt;/code&gt; ， &lt;code&gt;long long&lt;/code&gt; 或它们的无符号对应类型。除了C类型 &lt;code&gt;_Bool&lt;/code&gt; 或C ++类型 &lt;code&gt;bool&lt;/code&gt; 之外，GCC允许大小为1、2、4或8个字节的任何标量类型。对指针参数的操作就像操作数是 &lt;code&gt;uintptr_t&lt;/code&gt; 类型一样执行。也就是说，它们不会按指针指向的类型的大小进行缩放。</target>
        </trans-unit>
        <trans-unit id="12d18656502db6e4e9c93de0479a82b56cb9d524" translate="yes" xml:space="preserve">
          <source>The definitions for &lt;code&gt;__DATE__&lt;/code&gt; and &lt;code&gt;__TIME__&lt;/code&gt; when respectively, the date and time of translation are not available (C90 6.8.8, C99 6.10.8, C11 6.10.8.1).</source>
          <target state="translated">&lt;code&gt;__DATE__&lt;/code&gt; 和 &lt;code&gt;__TIME__&lt;/code&gt; 的定义（分别是翻译的日期和时间）不可用（C90 6.8.8，C99 6.10.8，C11 6.10.8.1）。</target>
        </trans-unit>
        <trans-unit id="d50e31983578e620136495305e55ed145625f1a3" translate="yes" xml:space="preserve">
          <source>The denominator n of fraction 1/n of the execution frequency of the entry block of a function that a basic block of this function needs to at least have in order to be considered hot. The default is 1000, which means that a basic block is considered hot in a function if it is executed more frequently than 1/1000 of the frequency of the entry block of the function. 0 means that it is never considered hot.</source>
          <target state="translated">函数入口块执行频率的分数1/n的分母n,这个函数的基本块至少需要有这个分母才能被认为是热块。默认值为1000,即如果一个基本块的执行频率超过函数入口块频率的1/1000,则该函数中的基本块被认为是热的。0意味着它永远不会被认为是热函数。</target>
        </trans-unit>
        <trans-unit id="75cdf285dab576e728fe4c1726581875dabc3071" translate="yes" xml:space="preserve">
          <source>The denominator n of fraction 1/n of the maximal execution count of a basic block in the entire program that a basic block needs to at least have in order to be considered hot. The default is 10000, which means that a basic block is considered hot if its execution count is greater than 1/10000 of the maximal execution count. 0 means that it is never considered hot. Used in non-LTO mode.</source>
          <target state="translated">在整个程序中,基本块的最大执行次数的分数1/n的分母n,一个基本块至少需要有这个分母才能被认为是热块。默认值是10000,也就是说,如果一个基本块的执行数大于最大执行数的1/10000,则被认为是热块。0意味着它永远不会被认为是热块,在非LTO模式下使用。在非LTO模式下使用。</target>
        </trans-unit>
        <trans-unit id="d8711313846a248f0818ef2198a1524b06952be7" translate="yes" xml:space="preserve">
          <source>The denominator n of fraction 1/n of the number of profiled runs of the entire program below which the execution count of a basic block must be in order for the basic block to be considered unlikely executed. The default is 20, which means that a basic block is considered unlikely executed if it is executed in fewer than 1/20, or 5%, of the runs of the program. 0 means that it is always considered unlikely executed.</source>
          <target state="translated">整个程序的运行次数的分数1/n的分母n,基本块的执行次数必须低于这个分数,才能认为基本块不太可能被执行。默认值是20,这意味着如果一个基本块的执行次数少于程序运行次数的1/20,或5%,则被认为不太可能被执行。0意味着它总是被认为不可能被执行。</target>
        </trans-unit>
        <trans-unit id="a09ae46c0bc04395fafa29f4371d3dd1f0905098" translate="yes" xml:space="preserve">
          <source>The depth of search in the dominator tree for expressions to hoist. This is used to avoid quadratic behavior in hoisting algorithm. The value of 0 does not limit on the search, but may slow down compilation of huge functions.</source>
          <target state="translated">在主导树中搜索要提升的表达式的深度。这个值是用来避免葫芦算法中的二次元行为。值为0不会限制搜索深度,但可能会减慢巨大函数的编译速度。</target>
        </trans-unit>
        <trans-unit id="14934208c61e859a6e7eb6b441a06008f55e391f" translate="yes" xml:space="preserve">
          <source>The device / architecture belongs to the XMEGA family of devices.</source>
          <target state="translated">该器件/架构属于XMEGA系列器件。</target>
        </trans-unit>
        <trans-unit id="0848b55d6ef92bf5b121f28a3f70167cf843e9f0" translate="yes" xml:space="preserve">
          <source>The device has Read-Modify-Write instructions (XCH, LAC, LAS and LAT).</source>
          <target state="translated">器件有读-改-写指令(XCH、LAC、LAS和LAT)。</target>
        </trans-unit>
        <trans-unit id="c94be4f62c4adcfc5a43023ae724a73e574f4d44" translate="yes" xml:space="preserve">
          <source>The device has a hardware multiplier.</source>
          <target state="translated">该设备有一个硬件乘法器。</target>
        </trans-unit>
        <trans-unit id="40eec38c7059a6f4d65d7d4102f16aec3f9f23ce" translate="yes" xml:space="preserve">
          <source>The device has the &lt;code&gt;EIJMP&lt;/code&gt; and &lt;code&gt;EICALL&lt;/code&gt; instructions. This is the case for devices with more than 128 KiB of program memory. This also means that the program counter (PC) is 3 bytes wide.</source>
          <target state="translated">该设备具有 &lt;code&gt;EIJMP&lt;/code&gt; 和 &lt;code&gt;EICALL&lt;/code&gt; 指令。对于具有超过128 KiB程序存储器的设备，就是这种情况。这也意味着程序计数器（PC）为3字节宽。</target>
        </trans-unit>
        <trans-unit id="7183cfd675e5fad71be960e9de6faa5f999d51c4" translate="yes" xml:space="preserve">
          <source>The device has the &lt;code&gt;ELPM R&lt;var&gt;n&lt;/var&gt;,Z&lt;/code&gt; and &lt;code&gt;ELPM
R&lt;var&gt;n&lt;/var&gt;,Z+&lt;/code&gt; instructions.</source>
          <target state="translated">该设备具有 &lt;code&gt;ELPM R&lt;var&gt;n&lt;/var&gt;,Z&lt;/code&gt; 和 &lt;code&gt;ELPM R&lt;var&gt;n&lt;/var&gt;,Z+&lt;/code&gt; 指令。</target>
        </trans-unit>
        <trans-unit id="124acdeb9487e33b6bf2adad9222c95480d5e077" translate="yes" xml:space="preserve">
          <source>The device has the &lt;code&gt;ELPM&lt;/code&gt; instruction.</source>
          <target state="translated">该设备具有 &lt;code&gt;ELPM&lt;/code&gt; 指令。</target>
        </trans-unit>
        <trans-unit id="ace169ce6eef96ce4c8d2efd5bee4eef88f9d4da" translate="yes" xml:space="preserve">
          <source>The device has the &lt;code&gt;JMP&lt;/code&gt; and &lt;code&gt;CALL&lt;/code&gt; instructions. This is the case for devices with more than 8 KiB of program memory.</source>
          <target state="translated">该设备具有 &lt;code&gt;JMP&lt;/code&gt; 和 &lt;code&gt;CALL&lt;/code&gt; 指令。对于具有超过8 KiB程序存储器的设备，情况就是这样。</target>
        </trans-unit>
        <trans-unit id="c648d34bf5dc6505ae5b97362b5aa073400b3ded" translate="yes" xml:space="preserve">
          <source>The device has the &lt;code&gt;LPM R&lt;var&gt;n&lt;/var&gt;,Z&lt;/code&gt; and &lt;code&gt;LPM R&lt;var&gt;n&lt;/var&gt;,Z+&lt;/code&gt; instructions.</source>
          <target state="translated">该设备具有 &lt;code&gt;LPM R&lt;var&gt;n&lt;/var&gt;,Z&lt;/code&gt; 和 &lt;code&gt;LPM R&lt;var&gt;n&lt;/var&gt;,Z+&lt;/code&gt; 指令。</target>
        </trans-unit>
        <trans-unit id="aeb599358087e9ab1d870c33d3b39e9eeb6c15cf" translate="yes" xml:space="preserve">
          <source>The device has the &lt;code&gt;MOVW&lt;/code&gt; instruction to perform 16-bit register-register moves.</source>
          <target state="translated">器件具有 &lt;code&gt;MOVW&lt;/code&gt; 指令来执行16位寄存器-寄存器移动。</target>
        </trans-unit>
        <trans-unit id="83a1356b9ac9ce24c84c12bd07e29feb04f94c12" translate="yes" xml:space="preserve">
          <source>The device has the &lt;code&gt;RAMPD&lt;/code&gt;, &lt;code&gt;RAMPX&lt;/code&gt;, &lt;code&gt;RAMPY&lt;/code&gt;, &lt;code&gt;RAMPZ&lt;/code&gt; special function register, respectively.</source>
          <target state="translated">该设备分别具有 &lt;code&gt;RAMPD&lt;/code&gt; ， &lt;code&gt;RAMPX&lt;/code&gt; ， &lt;code&gt;RAMPY&lt;/code&gt; 和 &lt;code&gt;RAMPZ&lt;/code&gt; 特殊功能寄存器。</target>
        </trans-unit>
        <trans-unit id="7440edf5c9a0d8bde64b1ecefe74df7b62918795" translate="yes" xml:space="preserve">
          <source>The device has the SPH (high part of stack pointer) special function register or has an 8-bit stack pointer, respectively. The definition of these macros is affected by</source>
          <target state="translated">器件分别具有SPH(堆栈指针的高位部分)特殊功能寄存器或具有8位堆栈指针。这些宏的定义受</target>
        </trans-unit>
        <trans-unit id="a15f34c198926a24e4b29d121787f367b6273a1a" translate="yes" xml:space="preserve">
          <source>The diff may or may not be colorized, following the same rules as for diagnostics (see</source>
          <target state="translated">差值可以被着色,也可以不着色,遵循与诊断程序相同的规则(参见</target>
        </trans-unit>
        <trans-unit id="bfb8bac86341e0faa063bc2c7464731f3754920b" translate="yes" xml:space="preserve">
          <source>The differences to the &lt;code&gt;naked&lt;/code&gt; function attribute are:</source>
          <target state="translated">&lt;code&gt;naked&lt;/code&gt; 函数属性的区别是：</target>
        </trans-unit>
        <trans-unit id="caa2f3d0586724648ad5dc95b2dd6a57770fcc55" translate="yes" xml:space="preserve">
          <source>The direction of rounding when a floating-point number is converted to a narrower floating-point number (C90 6.2.1.4, C99 and C11 6.3.1.5).</source>
          <target state="translated">当浮点数转换为较窄的浮点数时,四舍五入的方向(C90 6.2.1.4,C99和C11 6.3.1.5)。</target>
        </trans-unit>
        <trans-unit id="26fb3de478c5cf1596d7cf8a88ab611eedc18b11" translate="yes" xml:space="preserve">
          <source>The direction of rounding when an integer is converted to a floating-point number that cannot exactly represent the original value (C90 6.2.1.3, C99 and C11 6.3.1.4).</source>
          <target state="translated">当整数转换成不能完全代表原值的浮点数时,四舍五入的方向(C90 6.2.1.3,C99和C11 6.3.1.4)。</target>
        </trans-unit>
        <trans-unit id="9c2a89eb8a493cddb0e17d65209367b348e4e331" translate="yes" xml:space="preserve">
          <source>The earliest version of MacOS X that this executable will run on is &lt;var&gt;version&lt;/var&gt;. Typical values of &lt;var&gt;version&lt;/var&gt; include &lt;code&gt;10.1&lt;/code&gt;, &lt;code&gt;10.2&lt;/code&gt;, and &lt;code&gt;10.3.9&lt;/code&gt;.</source>
          <target state="translated">此可执行文件将在其上运行的最早的MacOS X &lt;var&gt;version&lt;/var&gt; 是version。的典型值 &lt;var&gt;version&lt;/var&gt; 包括 &lt;code&gt;10.1&lt;/code&gt; ， &lt;code&gt;10.2&lt;/code&gt; ，和 &lt;code&gt;10.3.9&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4dc00d4d1ee11aa29f8972e4481c89ebd51afb01" translate="yes" xml:space="preserve">
          <source>The easiest way of satisfying these restrictions is to compile and link every module with the same</source>
          <target state="translated">满足这些限制的最简单的方法是编译和链接每一个模块,用相同的</target>
        </trans-unit>
        <trans-unit id="ee24dbb06c4125c8c59c873450e471ac0298f125" translate="yes" xml:space="preserve">
          <source>The effect is equivalent to moving all references to the alias to a separate translation unit, renaming the alias to the aliased symbol, declaring it as weak, compiling the two separate translation units and performing a link with relocatable output (i.e. &lt;code&gt;ld -r&lt;/code&gt;) on them.</source>
          <target state="translated">效果等同于将对别名的所有引用移动到单独的翻译单元，将别名重命名为别名符号，声明别名为弱符号，编译两个单独的翻译单元，并执行具有可重定位输出（即 &lt;code&gt;ld -r&lt;/code&gt; ）的链接。他们。</target>
        </trans-unit>
        <trans-unit id="40ce96812102dd380fc896f02591a99db980d416" translate="yes" xml:space="preserve">
          <source>The effect is equivalent to moving all references to the alias to a separate translation unit, renaming the alias to the aliased symbol, declaring it as weak, compiling the two separate translation units and performing a link with relocatable output (ie: &lt;code&gt;ld -r&lt;/code&gt;) on them.</source>
          <target state="translated">效果等同于将对别名的所有引用移动到单独的翻译单元，将别名重命名为别名符号，声明别名为弱符号，编译两个单独的翻译单元，并执行具有可重定位输出的链接（即 &lt;code&gt;ld -r&lt;/code&gt; ）在他们。</target>
        </trans-unit>
        <trans-unit id="2fcdd3faf7319592c843ba96ea56c638eff89d9c" translate="yes" xml:space="preserve">
          <source>The effect of this is that GCC may, effectively, mark inline methods with &lt;code&gt;__attribute__ ((visibility (&quot;hidden&quot;)))&lt;/code&gt; so that they do not appear in the export table of a DSO and do not require a PLT indirection when used within the DSO. Enabling this option can have a dramatic effect on load and link times of a DSO as it massively reduces the size of the dynamic export table when the library makes heavy use of templates.</source>
          <target state="translated">这样的效果是，GCC可以有效地用 &lt;code&gt;__attribute__ ((visibility (&quot;hidden&quot;)))&lt;/code&gt; 标记内联方法，以使它们不会出现在DSO的导出表中，并且在内部使用时不需要PLT间接调用。DSO。启用此选项会对DSO的负载和链接时间产生显着影响，因为当库大量使用模板时，它会大大减小动态导出表的大小。</target>
        </trans-unit>
        <trans-unit id="0339dc59fd2ec7a99f69b1c58fc9500261d6af02" translate="yes" xml:space="preserve">
          <source>The effectiveness of some warnings depends on optimizations also being enabled. For example</source>
          <target state="translated">一些警告的有效性取决于是否也启用了优化。例如</target>
        </trans-unit>
        <trans-unit id="a80b8b3ee96e1537d805054b77f62723800f759b" translate="yes" xml:space="preserve">
          <source>The elements of the input vectors are numbered in memory ordering of &lt;var&gt;vec0&lt;/var&gt; beginning at 0 and &lt;var&gt;vec1&lt;/var&gt; beginning at &lt;var&gt;N&lt;/var&gt;. The elements of &lt;var&gt;mask&lt;/var&gt; are considered modulo &lt;var&gt;N&lt;/var&gt; in the single-operand case and modulo &lt;em&gt;2*&lt;var&gt;N&lt;/var&gt;&lt;/em&gt; in the two-operand case.</source>
          <target state="translated">输入向量的元素的序号的存储器排序 &lt;var&gt;vec0&lt;/var&gt; 在0开始和 &lt;var&gt;vec1&lt;/var&gt; 开始在 &lt;var&gt;N&lt;/var&gt; 。 &lt;var&gt;mask&lt;/var&gt; 的元素在单操作数情况下被认为是模 &lt;var&gt;N&lt;/var&gt; ，在两操作数情况下被认为是&lt;em&gt;2 * &lt;var&gt;N&lt;/var&gt; &lt;/em&gt;模。</target>
        </trans-unit>
        <trans-unit id="03329c8955d8e056ec3aa9ef42249119fe358d03" translate="yes" xml:space="preserve">
          <source>The encoding of any of &lt;code&gt;wchar_t&lt;/code&gt;, &lt;code&gt;char16_t&lt;/code&gt;, and &lt;code&gt;char32_t&lt;/code&gt; where the corresponding standard encoding macro (&lt;code&gt;__STDC_ISO_10646__&lt;/code&gt;, &lt;code&gt;__STDC_UTF_16__&lt;/code&gt;, or &lt;code&gt;__STDC_UTF_32__&lt;/code&gt;) is not defined (C11 6.10.8.2).</source>
          <target state="translated">&lt;code&gt;wchar_t&lt;/code&gt; ， &lt;code&gt;char16_t&lt;/code&gt; 和 &lt;code&gt;char32_t&lt;/code&gt; 中任何一个的编码都没有定义相应的标准编码宏（ &lt;code&gt;__STDC_ISO_10646__&lt;/code&gt; ， &lt;code&gt;__STDC_UTF_16__&lt;/code&gt; 或 &lt;code&gt;__STDC_UTF_32__&lt;/code&gt; ）（C11 6.10.8.2）。</target>
        </trans-unit>
        <trans-unit id="f0c42b29af2e3bb28afd21f635c0f39721670e06" translate="yes" xml:space="preserve">
          <source>The encoding of bit-fields has changed to allow bit-fields to be properly handled by the runtime functions that compute sizes and alignments of types that contain bit-fields. The previous encoding contained only the size of the bit-field. Using only this information it is not possible to reliably compute the size occupied by the bit-field. This is very important in the presence of the Boehm&amp;rsquo;s garbage collector because the objects are allocated using the typed memory facility available in this collector. The typed memory allocation requires information about where the pointers are located inside the object.</source>
          <target state="translated">位域的编码已更改，以允许运行时函数正确处理位域，这些运行时函数可计算包含位域的类型的大小和对齐方式。先前的编码仅包含位字段的大小。仅使用此信息就不可能可靠地计算出位域占用的大小。对于Boehm的垃圾收集器，这非常重要，因为使用该收集器中可用的类型化内存工具分配对象。类型化的内存分配需要有关指针在对象内部的位置的信息。</target>
        </trans-unit>
        <trans-unit id="32de7cb2a746befc3519adabd406682f138c91dc" translate="yes" xml:space="preserve">
          <source>The encoding of the branch hint instruction limits the hint to be within 256 instructions of the branch it is affecting. By default, GCC makes sure it is within 125.</source>
          <target state="translated">分支提示指令的编码限制了提示在它所影响的分支的256条指令之内。默认情况下,GCC会确保它在125条指令范围内。</target>
        </trans-unit>
        <trans-unit id="86931df671f82bbbca9166c366a69eb90410e2f2" translate="yes" xml:space="preserve">
          <source>The environment variable &lt;code&gt;GCC_COMPARE_DEBUG&lt;/code&gt;, if defined, non-empty and nonzero, implicitly enables</source>
          <target state="translated">环境变量 &lt;code&gt;GCC_COMPARE_DEBUG&lt;/code&gt; （如果已定义）非空且非零，则隐式启用</target>
        </trans-unit>
        <trans-unit id="f1abddc031f4887620e779e03fa9bce246eca769" translate="yes" xml:space="preserve">
          <source>The error is only generated if the pragma is present in the code after pre-processing has been completed. It does not matter however if the code containing the pragma is unreachable:</source>
          <target state="translated">只有在预处理完成后,pragma出现在代码中,才会产生错误。但是,如果包含该Pragma的代码无法访问,则不会产生错误。</target>
        </trans-unit>
        <trans-unit id="62217b180fda693fac806123c3cedff899bcd7c2" translate="yes" xml:space="preserve">
          <source>The evaluation methods characterized by non-standard negative values of &lt;code&gt;FLT_EVAL_METHOD&lt;/code&gt; (C99 and C11 5.2.4.2.2).</source>
          <target state="translated">评估方法以 &lt;code&gt;FLT_EVAL_METHOD&lt;/code&gt; （C99和C11 5.2.4.2.2）的非标准负值为特征。</target>
        </trans-unit>
        <trans-unit id="e7ca0d5b7ee5cf7cc21b906f53631f0432c41aa1" translate="yes" xml:space="preserve">
          <source>The example above is correctly written as:</source>
          <target state="translated">上面的例子正确的写法是:。</target>
        </trans-unit>
        <trans-unit id="2262d7979d1e6f669d9d267628d7f1a5e043c047" translate="yes" xml:space="preserve">
          <source>The execution counts are cumulative. If the example program were executed again without removing the</source>
          <target state="translated">执行次数是累计的。如果示例程序再次执行时没有删除</target>
        </trans-unit>
        <trans-unit id="30cd9cacada80b254b465216587c60514745e9e0" translate="yes" xml:space="preserve">
          <source>The exported header file declaring the function the user calls would contain:</source>
          <target state="translated">输出的头文件声明用户调用的函数将包含。</target>
        </trans-unit>
        <trans-unit id="6a3b0d1b517a2735ccea32622e6c16bbe062c918" translate="yes" xml:space="preserve">
          <source>The extended version of &lt;code&gt;__builtin_expect&lt;/code&gt; is not supported.</source>
          <target state="translated">不支持 &lt;code&gt;__builtin_expect&lt;/code&gt; 的扩展版本。</target>
        </trans-unit>
        <trans-unit id="e5f79933f130a6010408a53873b5c18d791196b0" translate="yes" xml:space="preserve">
          <source>The extended version of the ARMv7-A architecture with support for virtualization.</source>
          <target state="translated">ARMv7-A架构的扩展版本,支持虚拟化。</target>
        </trans-unit>
        <trans-unit id="f69903151111d03e37009b513bcf8f14816a93e4" translate="yes" xml:space="preserve">
          <source>The extent to which suggestions made by using the &lt;code&gt;register&lt;/code&gt; storage-class specifier are effective (C90 6.5.1, C99 and C11 6.7.1).</source>
          <target state="translated">使用 &lt;code&gt;register&lt;/code&gt; 存储类说明符提出的建议在多大程度上有效（C90 6.5.1，C99和C11 6.7.1）。</target>
        </trans-unit>
        <trans-unit id="99d4acdb059ef7e8275eb6991f7b3fdb57cb4d7e" translate="yes" xml:space="preserve">
          <source>The extent to which suggestions made by using the inline function specifier are effective (C99 and C11 6.7.4).</source>
          <target state="translated">使用内联函数指定器提出的建议的有效程度(C99和C11 6.7.4);</target>
        </trans-unit>
        <trans-unit id="04fbc7508d5d457aedc840547581d13fb785d13c" translate="yes" xml:space="preserve">
          <source>The file</source>
          <target state="translated">该文件</target>
        </trans-unit>
        <trans-unit id="be1544009a06e2ed9b8c04313febbe4a5054a34c" translate="yes" xml:space="preserve">
          <source>The filename and replacement string escape backslash as &amp;ldquo;\\&quot;, tab as &amp;ldquo;\t&amp;rdquo;, newline as &amp;ldquo;\n&amp;rdquo;, double quotes as &amp;ldquo;\&quot;&amp;rdquo;, non-printable characters as octal (e.g. vertical tab as &amp;ldquo;\013&amp;rdquo;).</source>
          <target state="translated">文件名和替换字符串以反斜杠转义为&amp;ldquo; \\&amp;rdquo;，制表符为&amp;ldquo; \ t&amp;rdquo;，换行符为&amp;ldquo; \ n&amp;rdquo;，双引号为&amp;ldquo; \&amp;rdquo;，不可打印字符为八进制（例如，垂直制表符为&amp;ldquo; \ 013&amp;rdquo; ）。</target>
        </trans-unit>
        <trans-unit id="052b9a9ce595b22df1664059ccb4ac71ceb3b652" translate="yes" xml:space="preserve">
          <source>The files used by gcov.</source>
          <target state="translated">gcov使用的文件。</target>
        </trans-unit>
        <trans-unit id="5f9146bf44aa8a552083fbcdde4f12b382de6ccc" translate="yes" xml:space="preserve">
          <source>The first argument is the address of the start of the current function, which may be looked up exactly in the symbol table.</source>
          <target state="translated">第一个参数是当前函数的起始地址,可在符号表中准确查找。</target>
        </trans-unit>
        <trans-unit id="d40b2392c804eafb9e2a38b040dcc6ad4b8a38cb" translate="yes" xml:space="preserve">
          <source>The first argument, &lt;var&gt;auxv&lt;/var&gt;, is the address of an auxiliary register, the second argument, &lt;var&gt;val&lt;/var&gt;, is a compile time constant to be written to the register. Generates:</source>
          <target state="translated">第一个参数 &lt;var&gt;auxv&lt;/var&gt; 是辅助寄存器的地址，第二个参数 &lt;var&gt;val&lt;/var&gt; 是要写入该寄存器的编译时间常数。产生：</target>
        </trans-unit>
        <trans-unit id="1bb8468783d812fcfe3a90c5c3005fc31c3a8b43" translate="yes" xml:space="preserve">
          <source>The first built-in function allows arbitrary integral types for operands and the result type must be pointer to some integral type other than enumerated or boolean type, the rest of the built-in functions have explicit integer types.</source>
          <target state="translated">第一个内置函数允许操作数的任意积分类型,结果类型必须是指向枚举型或布尔型以外的某个积分类型的指针,其余的内置函数都有明确的整数类型。</target>
        </trans-unit>
        <trans-unit id="766dbe1354f0d010e9b9752b025269447d8bacdc" translate="yes" xml:space="preserve">
          <source>The first number on each line is the &amp;ldquo;user time&amp;rdquo;, that is time spent executing the program itself. The second number is &amp;ldquo;system time&amp;rdquo;, time spent executing operating system routines on behalf of the program. Both numbers are in seconds.</source>
          <target state="translated">每行的第一个数字是&amp;ldquo;用户时间&amp;rdquo;，即执行程序本身所花费的时间。第二个数字是&amp;ldquo;系统时间&amp;rdquo;，代表该程序执行操作系统例程所花费的时间。两个数字都以秒为单位。</target>
        </trans-unit>
        <trans-unit id="7705a0a1f8fdbe72b6eed476ebaac5e4596393cb" translate="yes" xml:space="preserve">
          <source>The first operand is the number of a register to be written, the second operand is a compile time constant to write into that register. Generates:</source>
          <target state="translated">第一个操作数是要写入的寄存器的编号,第二个操作数是要写入该寄存器的编译时间常数。生成。</target>
        </trans-unit>
        <trans-unit id="5403326826a0ff4e3670389f165daf4e08127b0b" translate="yes" xml:space="preserve">
          <source>The first step in using these extensions is to provide the necessary data types. This should be done using an appropriate &lt;code&gt;typedef&lt;/code&gt;:</source>
          <target state="translated">使用这些扩展的第一步是提供必要的数据类型。这应该使用适当的 &lt;code&gt;typedef&lt;/code&gt; 来完成：</target>
        </trans-unit>
        <trans-unit id="0180fb5f9566434bbaf5187f78b901ca8a7ed3d8" translate="yes" xml:space="preserve">
          <source>The first two invocations to GCC save a bytecode representation of GIMPLE into special ELF sections inside</source>
          <target state="translated">对GCC的前两次调用将GIMPLE的字节码表示保存到特殊的ELF部分,在</target>
        </trans-unit>
        <trans-unit id="d7463018cc3efdf04fea2a1a9520f2dcaa8a917d" translate="yes" xml:space="preserve">
          <source>The fixed-point types are &lt;code&gt;short _Fract&lt;/code&gt;, &lt;code&gt;_Fract&lt;/code&gt;, &lt;code&gt;long _Fract&lt;/code&gt;, &lt;code&gt;long long _Fract&lt;/code&gt;, &lt;code&gt;unsigned short _Fract&lt;/code&gt;, &lt;code&gt;unsigned _Fract&lt;/code&gt;, &lt;code&gt;unsigned long _Fract&lt;/code&gt;, &lt;code&gt;unsigned long long _Fract&lt;/code&gt;, &lt;code&gt;_Sat short _Fract&lt;/code&gt;, &lt;code&gt;_Sat _Fract&lt;/code&gt;, &lt;code&gt;_Sat long _Fract&lt;/code&gt;, &lt;code&gt;_Sat long long _Fract&lt;/code&gt;, &lt;code&gt;_Sat unsigned short _Fract&lt;/code&gt;, &lt;code&gt;_Sat unsigned _Fract&lt;/code&gt;, &lt;code&gt;_Sat unsigned long _Fract&lt;/code&gt;, &lt;code&gt;_Sat unsigned long long _Fract&lt;/code&gt;, &lt;code&gt;short _Accum&lt;/code&gt;, &lt;code&gt;_Accum&lt;/code&gt;, &lt;code&gt;long _Accum&lt;/code&gt;, &lt;code&gt;long long _Accum&lt;/code&gt;, &lt;code&gt;unsigned short _Accum&lt;/code&gt;, &lt;code&gt;unsigned _Accum&lt;/code&gt;, &lt;code&gt;unsigned long _Accum&lt;/code&gt;, &lt;code&gt;unsigned long long _Accum&lt;/code&gt;, &lt;code&gt;_Sat short _Accum&lt;/code&gt;, &lt;code&gt;_Sat _Accum&lt;/code&gt;, &lt;code&gt;_Sat long _Accum&lt;/code&gt;, &lt;code&gt;_Sat long long _Accum&lt;/code&gt;, &lt;code&gt;_Sat unsigned short _Accum&lt;/code&gt;, &lt;code&gt;_Sat unsigned _Accum&lt;/code&gt;, &lt;code&gt;_Sat unsigned long _Accum&lt;/code&gt;, &lt;code&gt;_Sat unsigned long long _Accum&lt;/code&gt;.</source>
          <target state="translated">定点类型是 &lt;code&gt;short _Fract&lt;/code&gt; ， &lt;code&gt;_Fract&lt;/code&gt; ， &lt;code&gt;long _Fract&lt;/code&gt; ， &lt;code&gt;long long _Fract&lt;/code&gt; ， &lt;code&gt;unsigned short _Fract&lt;/code&gt; ， &lt;code&gt;unsigned _Fract&lt;/code&gt; ， &lt;code&gt;unsigned long _Fract&lt;/code&gt; ， &lt;code&gt;unsigned long long _Fract&lt;/code&gt; ， &lt;code&gt;_Sat short _Fract&lt;/code&gt; ， &lt;code&gt;_Sat _Fract&lt;/code&gt; ， &lt;code&gt;_Sat long _Fract&lt;/code&gt; ， &lt;code&gt;_Sat long long _Fract&lt;/code&gt; ， &lt;code&gt;_Sat unsigned short _Fract&lt;/code&gt; ， &lt;code&gt;_Sat unsigned _Fract&lt;/code&gt; ， &lt;code&gt;_Sat unsigned long _Fract&lt;/code&gt; ， &lt;code&gt;_Sat unsigned long long _Fract&lt;/code&gt; ， &lt;code&gt;short _Accum&lt;/code&gt; ， &lt;code&gt;_Accum&lt;/code&gt; ， &lt;code&gt;long _Accum&lt;/code&gt; ， &lt;code&gt;long long _Accum&lt;/code&gt; ， &lt;code&gt;unsigned short _Accum&lt;/code&gt; ， &lt;code&gt;unsigned _Accum&lt;/code&gt; ， &lt;code&gt;unsigned long _Accum&lt;/code&gt; ， &lt;code&gt;unsigned long long _Accum&lt;/code&gt; ， &lt;code&gt;_Sat short _Accum&lt;/code&gt; ， &lt;code&gt;_Sat _Accum&lt;/code&gt; ， &lt;code&gt;_Sat long _Accum&lt;/code&gt; ， &lt;code&gt;_Sat long long _Accum&lt;/code&gt; ， &lt;code&gt;_Sat unsigned short _Accum&lt;/code&gt; ， &lt;code&gt;_Sat unsigned _Accum&lt;/code&gt; ， &lt;code&gt;_Sat unsigned long _Accum&lt;/code&gt; ， &lt;code&gt;_Sat unsigned long long _Accum&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3caefb409c9894c159fb9e3de06457a892f7b065" translate="yes" xml:space="preserve">
          <source>The flag makes these changes to GCC&amp;rsquo;s linkage model:</source>
          <target state="translated">该标志对GCC的链接模型进行了以下更改：</target>
        </trans-unit>
        <trans-unit id="e89357c25217d9e6ea0399e085ee6ac916e2228f" translate="yes" xml:space="preserve">
          <source>The flag output constraints are not supported in thumb1 mode.</source>
          <target state="translated">在thumb1模式下不支持标志输出约束。</target>
        </trans-unit>
        <trans-unit id="398abcfd0bda984ca55650d923231a3e23d99caf" translate="yes" xml:space="preserve">
          <source>The flag output constraints for the ARM family are of the form &amp;lsquo;</source>
          <target state="translated">ARM系列的标志输出约束形式为'</target>
        </trans-unit>
        <trans-unit id="467579e58b2ed3f9e1f5da092ecc00a08220e553" translate="yes" xml:space="preserve">
          <source>The flag output constraints for the x86 family are of the form &amp;lsquo;</source>
          <target state="translated">x86系列的标志输出约束形式为'</target>
        </trans-unit>
        <trans-unit id="08b70c97084691cff3ef37f7ca63544f38157171" translate="yes" xml:space="preserve">
          <source>The flags register.</source>
          <target state="translated">旗帜寄存器。</target>
        </trans-unit>
        <trans-unit id="bdec47de335eba5411aba4ed82b1290026a8b9df" translate="yes" xml:space="preserve">
          <source>The floating-point constant 0.0</source>
          <target state="translated">浮点数常数 0.0</target>
        </trans-unit>
        <trans-unit id="ec2c9b05e5630a06e86a36a4fbe950b6561191c6" translate="yes" xml:space="preserve">
          <source>The following</source>
          <target state="translated">以下是</target>
        </trans-unit>
        <trans-unit id="3c5af523cdaaa4e1970de9cf32fc6b6194b0929d" translate="yes" xml:space="preserve">
          <source>The following CPU names can be detected:</source>
          <target state="translated">可以检测到以下CPU名称。</target>
        </trans-unit>
        <trans-unit id="5f10647ac5c4280bde68061d0442176ac21bf7e2" translate="yes" xml:space="preserve">
          <source>The following additional built-in functions are also available for the PowerPC family of processors, starting with ISA 3.0 (</source>
          <target state="translated">从ISA 3.0开始,PowerPC系列处理器还可以使用以下附加的内置功能(</target>
        </trans-unit>
        <trans-unit id="1929bf7289a9ecdc2dad5969b2604877133b0494" translate="yes" xml:space="preserve">
          <source>The following additional built-in functions are also available for the PowerPC family of processors, starting with ISA 3.0 or later:</source>
          <target state="translated">从ISA 3.0或更高版本开始,PowerPC系列处理器还可以使用以下附加的内置功能。</target>
        </trans-unit>
        <trans-unit id="8b6e450e5b4547d8cc58a1ea785d39c551b41c7f" translate="yes" xml:space="preserve">
          <source>The following are a set of changes to ISO/IEC 14882:1998 (aka C++98) that document the exact semantics of the language extension.</source>
          <target state="translated">以下是对ISO/IEC 14882:1998(又名C++98)的一系列修改,记录了语言扩展的确切语义。</target>
        </trans-unit>
        <trans-unit id="973ba60cc5ca780083859b39f3e2346700d51250" translate="yes" xml:space="preserve">
          <source>The following are a set of changes to ISO/IEC 9899:1999 (aka C99) that document the exact semantics of the language extension.</source>
          <target state="translated">以下是对ISO/IEC 9899:1999(又名C99)的一系列修改,记录了语言扩展的确切语义。</target>
        </trans-unit>
        <trans-unit id="ebfbe098b1dd5eca0cbfbb3ca87cce639c317631" translate="yes" xml:space="preserve">
          <source>The following attributes are available on Microsoft Windows and Symbian OS targets.</source>
          <target state="translated">以下属性在Microsoft Windows和Symbian OS目标上可用。</target>
        </trans-unit>
        <trans-unit id="75d2d7b6e92a2c518243634b77f2438ea7a789b2" translate="yes" xml:space="preserve">
          <source>The following attributes are supported on most targets.</source>
          <target state="translated">大多数目标都支持以下属性:</target>
        </trans-unit>
        <trans-unit id="f3abf3f6e4762f0945d50d1dadcf30c08d9bb36f" translate="yes" xml:space="preserve">
          <source>The following basic built-in functions require</source>
          <target state="translated">以下基本的内置功能需要</target>
        </trans-unit>
        <trans-unit id="e3618b6444ab4403d286bb790c65250955a9b750" translate="yes" xml:space="preserve">
          <source>The following basic built-in functions, which are also supported on x86 targets, require</source>
          <target state="translated">以下基本的内置函数,在x86目标上也是支持的,但需要用到</target>
        </trans-unit>
        <trans-unit id="369096374260c4b128f072244e93419c1bf1630f" translate="yes" xml:space="preserve">
          <source>The following built-in function is always available.</source>
          <target state="translated">以下内置功能始终可用。</target>
        </trans-unit>
        <trans-unit id="d0dad43e81aa335fef875c6f114a13ef9920a9d7" translate="yes" xml:space="preserve">
          <source>The following built-in function is available when</source>
          <target state="translated">下列内置功能在以下情况下可用</target>
        </trans-unit>
        <trans-unit id="04398186d020848766aea5fdd0b1552e99124d98" translate="yes" xml:space="preserve">
          <source>The following built-in functions allow checking if simple arithmetic operation would overflow.</source>
          <target state="translated">下列内置函数可以检查简单的算术运算是否会溢出。</target>
        </trans-unit>
        <trans-unit id="3c890e563c5fad880f7759533a175fe222845037" translate="yes" xml:space="preserve">
          <source>The following built-in functions allow performing simple arithmetic operations together with checking whether the operations overflowed.</source>
          <target state="translated">下面的内置函数可以执行简单的算术运算,并检查运算是否溢出。</target>
        </trans-unit>
        <trans-unit id="036eb93cb5a048428c65535ab685e9ef099b6ed1" translate="yes" xml:space="preserve">
          <source>The following built-in functions approximately match the requirements for the C++11 memory model. They are all identified by being prefixed with &amp;lsquo;</source>
          <target state="translated">以下内置函数大致符合C ++ 11内存模型的要求。它们都以&amp;ldquo;'</target>
        </trans-unit>
        <trans-unit id="bdf24977f571452f19f365486502e966dab5d0e9" translate="yes" xml:space="preserve">
          <source>The following built-in functions are also available for the PowerPC family of processors, starting with ISA 3.0 or later (</source>
          <target state="translated">从ISA 3.0或更高版本开始,下列内置功能也适用于PowerPC系列处理器(</target>
        </trans-unit>
        <trans-unit id="3d2195469599cbd3dc33d7718d1e125824d6001b" translate="yes" xml:space="preserve">
          <source>The following built-in functions are also available on all PowerPC processors:</source>
          <target state="translated">以下内置功能在所有PowerPC处理器上也是可用的。</target>
        </trans-unit>
        <trans-unit id="813e5a763e7aaceeb023e2843416ac3c7a436f0e" translate="yes" xml:space="preserve">
          <source>The following built-in functions are always available and can be used to check the target platform type.</source>
          <target state="translated">以下内置函数始终可用,可用于检查目标平台类型。</target>
        </trans-unit>
        <trans-unit id="a3a8ba0cceaa78de81b273be464b1e1bbe129653" translate="yes" xml:space="preserve">
          <source>The following built-in functions are always available.</source>
          <target state="translated">以下内置功能始终可用。</target>
        </trans-unit>
        <trans-unit id="ecfceed60efae2019076e7ea0c389384453f2603" translate="yes" xml:space="preserve">
          <source>The following built-in functions are always available. They all generate a Nios II Custom Instruction. The name of the function represents the types that the function takes and returns. The letter before the &lt;code&gt;n&lt;/code&gt; is the return type or void if absent. The &lt;code&gt;n&lt;/code&gt; represents the first parameter to all the custom instructions, the custom instruction number. The two letters after the &lt;code&gt;n&lt;/code&gt; represent the up to two parameters to the function.</source>
          <target state="translated">以下内置功能始终可用。它们都生成Nios II自定义指令。函数的名称表示该函数采用并返回的类型。 &lt;code&gt;n&lt;/code&gt; 之前的字母是返回类型，如果没有，则为空。该 &lt;code&gt;n&lt;/code&gt; 代表的第一个参数的所有定制指令，定制指令号。 &lt;code&gt;n&lt;/code&gt; 后面的两个字母代表该函数的最多两个参数。</target>
        </trans-unit>
        <trans-unit id="1af31ca0a6a69044f40261c9e3766a7bcb45f606" translate="yes" xml:space="preserve">
          <source>The following built-in functions are always available. They all generate the machine instruction that is part of the name.</source>
          <target state="translated">以下内置函数始终可用。它们都能生成作为名称一部分的机器指令。</target>
        </trans-unit>
        <trans-unit id="f2ff9df600bfad81ae439ad951e20e63358dbf59" translate="yes" xml:space="preserve">
          <source>The following built-in functions are always with</source>
          <target state="translated">以下内置函数始终与</target>
        </trans-unit>
        <trans-unit id="458872e50bacb1837e94edbee1f56e422633f9ac" translate="yes" xml:space="preserve">
          <source>The following built-in functions are available for eBPF targets.</source>
          <target state="translated">以下是eBPF目标的内置功能。</target>
        </trans-unit>
        <trans-unit id="a04c80c36791193b7507cbe8aa1b633c63c489df" translate="yes" xml:space="preserve">
          <source>The following built-in functions are available for the PowerPC family of processors, starting with ISA 3.0 or later (</source>
          <target state="translated">从ISA 3.0或更高版本开始,下列内置功能可用于PowerPC系列处理器(</target>
        </trans-unit>
        <trans-unit id="f55e084e6b2bbe2c1d4a74d78f9b5a79a08af791" translate="yes" xml:space="preserve">
          <source>The following built-in functions are available on Linux 64-bit systems that use the ISA 3.0 instruction set (</source>
          <target state="translated">在使用ISA 3.0指令集的Linux 64位系统中,以下内置功能是可用的(</target>
        </trans-unit>
        <trans-unit id="60ee9c1229ed14f7445701a16ac0e8900c850fff" translate="yes" xml:space="preserve">
          <source>The following built-in functions are available on systems that use the OSF/1 PALcode. Normally they invoke the &lt;code&gt;rduniq&lt;/code&gt; and &lt;code&gt;wruniq&lt;/code&gt; PAL calls, but when invoked with</source>
          <target state="translated">以下内置功能在使用OSF / 1 PALcode的系统上可用。通常，它们会调用 &lt;code&gt;rduniq&lt;/code&gt; 和 &lt;code&gt;wruniq&lt;/code&gt; PAL调用，但是当使用</target>
        </trans-unit>
        <trans-unit id="b74dd20c718ebc6e02b444b4df3b1293b7b777b2" translate="yes" xml:space="preserve">
          <source>The following built-in functions are available when</source>
          <target state="translated">下列内置功能在以下情况下可用</target>
        </trans-unit>
        <trans-unit id="776fae37ac2c3903c04468f14c58000c2d1da4aa" translate="yes" xml:space="preserve">
          <source>The following built-in functions are available when hardware decimal floating point (</source>
          <target state="translated">当硬件十进制浮点运算 (</target>
        </trans-unit>
        <trans-unit id="8714301d00c50c02cc49a9653de9815ca07de516" translate="yes" xml:space="preserve">
          <source>The following built-in functions are changed to generate new SSE4.1 instructions when</source>
          <target state="translated">以下的内置函数在以下情况下会产生新的SSE4.1指令。</target>
        </trans-unit>
        <trans-unit id="b44b1444a99a16bc850f8161bf3acb0269e3baa5" translate="yes" xml:space="preserve">
          <source>The following built-in functions are changed to generate new SSE4.2 instructions when</source>
          <target state="translated">以下的内置函数在以下情况下会产生新的SSE4.2指令。</target>
        </trans-unit>
        <trans-unit id="eabb92d44c62afaf48fdd22b40e596e4fd090919" translate="yes" xml:space="preserve">
          <source>The following built-in functions are intended to be compatible with those described in the Intel Itanium Processor-specific Application Binary Interface, section 7.4. As such, they depart from normal GCC practice by not using the &amp;lsquo;</source>
          <target state="translated">以下内置功能旨在与特定于Intel Itanium处理器的应用程序二进制接口，第7.4节中描述的功能兼容。因此，它们不使用&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="831ee0ed207b248768e0caf3e133139a3eef8c8d" translate="yes" xml:space="preserve">
          <source>The following built-in functions are made available by</source>
          <target state="translated">下列内置功能可由</target>
        </trans-unit>
        <trans-unit id="919b7b433192dee8b53ccb79ce4649060e122b82" translate="yes" xml:space="preserve">
          <source>The following built-in functions are made available either with</source>
          <target state="translated">以下内置功能可以通过以下两种方式实现</target>
        </trans-unit>
        <trans-unit id="6ccb74ff52e53e43a5c01fd32034e69dc2ae153d" translate="yes" xml:space="preserve">
          <source>The following built-in functions are provided for ARC targets. The built-ins generate the corresponding assembly instructions. In the examples given below, the generated code often requires an operand or result to be in a register. Where necessary further code will be generated to ensure this is true, but for brevity this is not described in each case.</source>
          <target state="translated">以下是为ARC目标提供的内置功能。内置函数生成相应的汇编指令。在下面给出的例子中,生成的代码通常要求操作数或结果在寄存器中。在必要的情况下,将生成进一步的代码以确保这是真的,但为了简洁起见,并没有在每个例子中描述。</target>
        </trans-unit>
        <trans-unit id="75e740a11dbfb99edbd20d26c1a8e83fccd42794" translate="yes" xml:space="preserve">
          <source>The following built-in functions are supported on the SH1, SH2, SH3 and SH4 families of processors:</source>
          <target state="translated">SH1、SH2、SH3和SH4系列处理器支持以下内置功能。</target>
        </trans-unit>
        <trans-unit id="f89feba67398daada2fcc2ab442cabeeabf1732a" translate="yes" xml:space="preserve">
          <source>The following built-in functions map directly to a particular MIPS DSP REV 2 instruction. Please refer to the architecture specification for details on what each instruction does.</source>
          <target state="translated">以下内置功能直接映射到特定的MIPS DSP REV 2指令。关于每条指令的详细功能,请参考架构规范。</target>
        </trans-unit>
        <trans-unit id="f21bc507e92bf45d2cc2ac3a1f9c044c10482e71" translate="yes" xml:space="preserve">
          <source>The following built-in functions map directly to a particular MIPS DSP instruction. Please refer to the architecture specification for details on what each instruction does.</source>
          <target state="translated">以下内置函数直接映射到特定的MIPS DSP指令。请参考架构规范,了解每条指令的详细功能。</target>
        </trans-unit>
        <trans-unit id="b9487d4f044e41716b6891b45e9753c6c90cda37" translate="yes" xml:space="preserve">
          <source>The following built-in spec functions are provided:</source>
          <target state="translated">提供以下内置的规格函数。</target>
        </trans-unit>
        <trans-unit id="2786d4ea3cbfa4ab2030f517cdaa8499a49060e7" translate="yes" xml:space="preserve">
          <source>The following built-in vector functions are available for the PowerPC family of processors, starting with ISA 3.0 or later (</source>
          <target state="translated">从ISA 3.0或更高版本开始,下列内置向量函数可用于PowerPC系列处理器(</target>
        </trans-unit>
        <trans-unit id="1a38882cce5b0e920f7bd6e773e987b24fc62b96" translate="yes" xml:space="preserve">
          <source>The following choices of &lt;var&gt;name&lt;/var&gt; are available on AArch64 targets:</source>
          <target state="translated">在AArch64目标上可以使用以下 &lt;var&gt;name&lt;/var&gt; 选择：</target>
        </trans-unit>
        <trans-unit id="ffd16ee07975a361776687491f1d62adb24d9f69" translate="yes" xml:space="preserve">
          <source>The following code initializes a variable &lt;code&gt;pfoo&lt;/code&gt; located in static storage with a 24-bit address:</source>
          <target state="translated">以下代码使用24位地址初始化位于静态存储中的变量 &lt;code&gt;pfoo&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="8780ef62a5e7e11e92254999b8a74301b194fac1" translate="yes" xml:space="preserve">
          <source>The following example demonstrates a case where you need to use the &lt;code&gt;volatile&lt;/code&gt; qualifier. It uses the x86 &lt;code&gt;rdtsc&lt;/code&gt; instruction, which reads the computer&amp;rsquo;s time-stamp counter. Without the &lt;code&gt;volatile&lt;/code&gt; qualifier, the optimizers might assume that the &lt;code&gt;asm&lt;/code&gt; block will always return the same value and therefore optimize away the second call.</source>
          <target state="translated">以下示例演示了需要使用 &lt;code&gt;volatile&lt;/code&gt; 限定符的情况。它使用x86 &lt;code&gt;rdtsc&lt;/code&gt; 指令，该指令读取计算机的时间戳计数器。如果没有 &lt;code&gt;volatile&lt;/code&gt; 限定符，优化器可能会假设 &lt;code&gt;asm&lt;/code&gt; 块将始终返回相同的值，因此优化了第二个调用。</target>
        </trans-unit>
        <trans-unit id="4b55ceed13d64aeb896ca2cdaff9ea36b6ca968e" translate="yes" xml:space="preserve">
          <source>The following example shows an &lt;code&gt;asm goto&lt;/code&gt; that uses a memory clobber.</source>
          <target state="translated">以下示例显示了使用内存破坏者的 &lt;code&gt;asm goto&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1ff7cf2e98d1cdb33c85dfebf8c45ca797099418" translate="yes" xml:space="preserve">
          <source>The following examples are all valid uses of these attributes on Epiphany targets:</source>
          <target state="translated">下面的例子都是这些属性在Epiphany目标上的有效使用。</target>
        </trans-unit>
        <trans-unit id="133fac7dc52d4be5d02e2ee9f610bd07e27fcb98" translate="yes" xml:space="preserve">
          <source>The following extension options are common to the listed CPUs:</source>
          <target state="translated">以下扩展选项是所列CPU通用的。</target>
        </trans-unit>
        <trans-unit id="585cd94a6c81e37ef942855a4e92760bf2aec5f9" translate="yes" xml:space="preserve">
          <source>The following features can be detected:</source>
          <target state="translated">可以检测到以下特征:</target>
        </trans-unit>
        <trans-unit id="4cbf90dbd434ca4f2150e22b1aa4b1a78b14c334" translate="yes" xml:space="preserve">
          <source>The following floating-point built-in functions are always available. All of them implement the function that is part of the name.</source>
          <target state="translated">以下是浮点函数的内置函数,它们都可以实现名称中的函数。所有这些函数都实现了名称中的函数。</target>
        </trans-unit>
        <trans-unit id="e1be7f4828f104915bab6627d884213aaa11c9fc" translate="yes" xml:space="preserve">
          <source>The following functions require</source>
          <target state="translated">以下功能需要</target>
        </trans-unit>
        <trans-unit id="31dedf0887f3cce8587f9fc85d3da325ab3058ce" translate="yes" xml:space="preserve">
          <source>The following functions require option</source>
          <target state="translated">以下功能需要选项</target>
        </trans-unit>
        <trans-unit id="f640e02367945c84624ea0fa79ae818fc5491bf9" translate="yes" xml:space="preserve">
          <source>The following high level HTM interface is made available by including &lt;code&gt;&amp;lt;htmxlintrin.h&amp;gt;&lt;/code&gt; and using</source>
          <target state="translated">通过包含 &lt;code&gt;&amp;lt;htmxlintrin.h&amp;gt;&lt;/code&gt; 并使用以下高级HTM接口</target>
        </trans-unit>
        <trans-unit id="102c1a366ea24351d92a6971e3810fc18f2df2f4" translate="yes" xml:space="preserve">
          <source>The following i386 example uses the &lt;var&gt;asmSymbolicName&lt;/var&gt; syntax. It produces the same result as the code above, but some may consider it more readable or more maintainable since reordering index numbers is not necessary when adding or removing operands. The names &lt;code&gt;aIndex&lt;/code&gt; and &lt;code&gt;aMask&lt;/code&gt; are only used in this example to emphasize which names get used where. It is acceptable to reuse the names &lt;code&gt;Index&lt;/code&gt; and &lt;code&gt;Mask&lt;/code&gt;.</source>
          <target state="translated">以下i386示例使用 &lt;var&gt;asmSymbolicName&lt;/var&gt; 语法。它产生的结果与上面的代码相同，但有些人可能认为它更具可读性或可维护性，因为在添加或删除操作数时不需要对索引号进行重新排序。名称 &lt;code&gt;aIndex&lt;/code&gt; 和 &lt;code&gt;aMask&lt;/code&gt; 仅在此示例中用于强调哪些名称在何处使用。重用名称 &lt;code&gt;Index&lt;/code&gt; 和 &lt;code&gt;Mask&lt;/code&gt; 是可以接受的。</target>
        </trans-unit>
        <trans-unit id="b6e6249e0b2946138511bcb4a6acddccaf21d75a" translate="yes" xml:space="preserve">
          <source>The following interfaces are supported for the generic and specific AltiVec operations and the AltiVec predicates. In cases where there is a direct mapping between generic and specific operations, only the generic names are shown here, although the specific operations can also be used.</source>
          <target state="translated">以下是支持通用和特定AltiVec操作以及AltiVec谓词的接口。如果通用操作和特定操作之间有直接的映射,这里只显示通用名称,但也可以使用特定操作。</target>
        </trans-unit>
        <trans-unit id="641482ab6aae43e810063e867385af29b325d058" translate="yes" xml:space="preserve">
          <source>The following is a complete list of all the SIMD built-ins provided for ARC, grouped by calling signature.</source>
          <target state="translated">下面是为ARC提供的所有SIMD内建模块的完整列表,按调用签名分组。</target>
        </trans-unit>
        <trans-unit id="59aaf754b53dd8275d60f36863885f1f7f538958" translate="yes" xml:space="preserve">
          <source>The following keywords are reserved for concepts.</source>
          <target state="translated">以下关键词为概念保留。</target>
        </trans-unit>
        <trans-unit id="1ea9055e3c282c50c68c6d2aeac0047e44355ae3" translate="yes" xml:space="preserve">
          <source>The following language-independent options do not enable specific warnings but control the kinds of diagnostics produced by GCC.</source>
          <target state="translated">以下与语言无关的选项不启用特定的警告,但可以控制GCC产生的诊断类型。</target>
        </trans-unit>
        <trans-unit id="d9f20c0f07be1621f3a5ece2a524e2a15cb445a2" translate="yes" xml:space="preserve">
          <source>The following low level built-in functions are available with</source>
          <target state="translated">下列低级内置功能可用于</target>
        </trans-unit>
        <trans-unit id="b73379da25dc8349b928d96eecb55babb0495892" translate="yes" xml:space="preserve">
          <source>The following machine modes are available for use with MMX built-in functions (see &lt;a href=&quot;vector-extensions#Vector-Extensions&quot;&gt;Vector Extensions&lt;/a&gt;): &lt;code&gt;V2SI&lt;/code&gt; for a vector of two 32-bit integers, &lt;code&gt;V4HI&lt;/code&gt; for a vector of four 16-bit integers, and &lt;code&gt;V8QI&lt;/code&gt; for a vector of eight 8-bit integers. Some of the built-in functions operate on MMX registers as a whole 64-bit entity, these use &lt;code&gt;V1DI&lt;/code&gt; as their mode.</source>
          <target state="translated">以下机器模式可用于MMX内置功能（请参见&lt;a href=&quot;vector-extensions#Vector-Extensions&quot;&gt;Vector Extensions&lt;/a&gt;）： &lt;code&gt;V2SI&lt;/code&gt; 用于两个32位整数的向量， &lt;code&gt;V4HI&lt;/code&gt; 用于四个16位整数的向量，以及 &lt;code&gt;V8QI&lt;/code&gt; 用于八个8的向量位整数。一些内置功能作为整体64位实体在MMX寄存器上运行，这些功能使用 &lt;code&gt;V1DI&lt;/code&gt; 作为其模式。</target>
        </trans-unit>
        <trans-unit id="7cf3a8e89705f68be72e746786d162672425cfef" translate="yes" xml:space="preserve">
          <source>The following multi-instruction functions are also available. In each case, &lt;var&gt;cond&lt;/var&gt; can be any of the 16 floating-point conditions: &lt;code&gt;f&lt;/code&gt;, &lt;code&gt;un&lt;/code&gt;, &lt;code&gt;eq&lt;/code&gt;, &lt;code&gt;ueq&lt;/code&gt;, &lt;code&gt;olt&lt;/code&gt;, &lt;code&gt;ult&lt;/code&gt;, &lt;code&gt;ole&lt;/code&gt;, &lt;code&gt;ule&lt;/code&gt;, &lt;code&gt;sf&lt;/code&gt;, &lt;code&gt;ngle&lt;/code&gt;, &lt;code&gt;seq&lt;/code&gt;, &lt;code&gt;ngl&lt;/code&gt;, &lt;code&gt;lt&lt;/code&gt;, &lt;code&gt;nge&lt;/code&gt;, &lt;code&gt;le&lt;/code&gt; or &lt;code&gt;ngt&lt;/code&gt;.</source>
          <target state="translated">还可以使用以下多指令功能。在每种情况下， &lt;var&gt;cond&lt;/var&gt; 可以是任何的16浮点条件： &lt;code&gt;f&lt;/code&gt; ， &lt;code&gt;un&lt;/code&gt; ， &lt;code&gt;eq&lt;/code&gt; ， &lt;code&gt;ueq&lt;/code&gt; ， &lt;code&gt;olt&lt;/code&gt; ， &lt;code&gt;ult&lt;/code&gt; ， &lt;code&gt;ole&lt;/code&gt; ， &lt;code&gt;ule&lt;/code&gt; ， &lt;code&gt;sf&lt;/code&gt; ， &lt;code&gt;ngle&lt;/code&gt; ， &lt;code&gt;seq&lt;/code&gt; ， &lt;code&gt;ngl&lt;/code&gt; ， &lt;code&gt;lt&lt;/code&gt; ， &lt;code&gt;nge&lt;/code&gt; ， &lt;code&gt;le&lt;/code&gt; 或 &lt;code&gt;ngt&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5d0ee4cac44eb1ea6ef3d346a27ca60807cc0101" translate="yes" xml:space="preserve">
          <source>The following option controls the dump verbosity:</source>
          <target state="translated">下面的选项可以控制转储的语气。</target>
        </trans-unit>
        <trans-unit id="abb8267f4643a3a1e1226701a4af5aa70991f141" translate="yes" xml:space="preserve">
          <source>The following options are enabled:</source>
          <target state="translated">启用了以下选项:</target>
        </trans-unit>
        <trans-unit id="81ad9c293f6f20ff40e11231422dcfe5f5c7994f" translate="yes" xml:space="preserve">
          <source>The following options are maintained for backward compatibility, but are now deprecated and will be removed in a future release:</source>
          <target state="translated">以下选项是为了向后兼容而保留的,但现在已被废弃,并将在未来的版本中删除。</target>
        </trans-unit>
        <trans-unit id="830e32827e2b8144f32b52b0121c8d7081e1b6a0" translate="yes" xml:space="preserve">
          <source>The following options are passed through to the assembler, and also define preprocessor macro symbols.</source>
          <target state="translated">以下选项被传递给汇编器,同时也定义了预处理器宏符号。</target>
        </trans-unit>
        <trans-unit id="3893bff29544ccfaa517cc2326f9ca49c8a38aa9" translate="yes" xml:space="preserve">
          <source>The following options are passed through to the linker:</source>
          <target state="translated">以下选项被传递给链接器。</target>
        </trans-unit>
        <trans-unit id="3c36d7938f4b3037d603daaacf0e18dc02039404" translate="yes" xml:space="preserve">
          <source>The following options control compiler behavior regarding floating-point arithmetic. These options trade off between speed and correctness. All must be specifically enabled.</source>
          <target state="translated">以下是控制编译器对浮点运算行为的选项。这些选项可以在速度和正确性之间进行权衡。所有的选项都必须特别启用。</target>
        </trans-unit>
        <trans-unit id="86976c9ace4c113da10573eddefe715e4cb2f672" translate="yes" xml:space="preserve">
          <source>The following options control how the assembly code is annotated:</source>
          <target state="translated">以下选项控制汇编代码的注释方式。</target>
        </trans-unit>
        <trans-unit id="14f279a10a5e010786a9e225f2aacc08d5d8248b" translate="yes" xml:space="preserve">
          <source>The following options control optimizations that may improve performance, but are not enabled by any</source>
          <target state="translated">以下选项控制了可能会提高性能的优化,但不是由任何一个选项启用的</target>
        </trans-unit>
        <trans-unit id="55fd5087fff35ad2ed3317068955b447140094de" translate="yes" xml:space="preserve">
          <source>The following options control specific optimizations. They are either activated by</source>
          <target state="translated">以下是控制特定优化的选项。它们可以通过以下方式激活</target>
        </trans-unit>
        <trans-unit id="97f1dd31a84415d7a8f21c8572a9ef06924b80bb" translate="yes" xml:space="preserve">
          <source>The following options control the analyzer.</source>
          <target state="translated">以下是控制分析仪的选项。</target>
        </trans-unit>
        <trans-unit id="d75b9b815cb70c1acb6a0a4fa3f69dee634495bb" translate="yes" xml:space="preserve">
          <source>The following options control the architecture variant for which code is being compiled:</source>
          <target state="translated">以下选项控制代码被编译的架构变体。</target>
        </trans-unit>
        <trans-unit id="99d7d28f2f9b185e45e491d2e2f8457796b4ee30" translate="yes" xml:space="preserve">
          <source>The following options control the dialect of C (or languages derived from C, such as C++, Objective-C and Objective-C++) that the compiler accepts:</source>
          <target state="translated">以下选项控制了编译器接受的C语言(或由C语言派生的语言,如C++、Objective-C和Objective-C++)的方言。</target>
        </trans-unit>
        <trans-unit id="813aeaa760a029b92e3d877fed33fc8e7a96dc7f" translate="yes" xml:space="preserve">
          <source>The following options control the semantics of generated code:</source>
          <target state="translated">以下选项控制生成代码的语义。</target>
        </trans-unit>
        <trans-unit id="d3598ddb012ba205521fc6ee02e575b5bc46a933" translate="yes" xml:space="preserve">
          <source>The following options control which kinds of messages should be emitted:</source>
          <target state="translated">下面的选项控制了哪些类型的信息应该被发送。</target>
        </trans-unit>
        <trans-unit id="4d212367144c7ffb5256031004f3dbec4705f316" translate="yes" xml:space="preserve">
          <source>The following options fine tune code generation:</source>
          <target state="translated">以下选项可以对代码生成进行微调。</target>
        </trans-unit>
        <trans-unit id="e686313bb7d2bb5ed9fc2b2f596d5d6ba9508b34" translate="yes" xml:space="preserve">
          <source>The following paired-single functions map directly to a particular MIPS instruction. Please refer to the architecture specification for details on what each instruction does.</source>
          <target state="translated">以下的配对-单功能直接映射到特定的MIPS指令。请参考架构规范,了解每条指令的详细功能。</target>
        </trans-unit>
        <trans-unit id="d31f26e42333950d2b2ffa071557eac8358219f6" translate="yes" xml:space="preserve">
          <source>The following pragmas are available for all architectures running the Darwin operating system. These are useful for compatibility with other Mac OS compilers.</source>
          <target state="translated">以下实用程序适用于运行Darwin操作系统的所有架构。这些对于与其他Mac OS编译器的兼容性非常有用。</target>
        </trans-unit>
        <trans-unit id="5efd4f1d1fe7f21c34100607d9ffdb85cb1ed570" translate="yes" xml:space="preserve">
          <source>The following set of built-in functions are available to gain access to the HTM specific special purpose registers.</source>
          <target state="translated">以下一组内置函数可用于访问HTM特定的特殊用途寄存器。</target>
        </trans-unit>
        <trans-unit id="fe37409b5b6fb37c45d0db10dbe34cd37d4dfd29" translate="yes" xml:space="preserve">
          <source>The following statements are identical:</source>
          <target state="translated">下列说法相同的是:</target>
        </trans-unit>
        <trans-unit id="4c95f76a6048996b1dcedbb4002de26c05b62460" translate="yes" xml:space="preserve">
          <source>The following take a &lt;code&gt;__v8hi&lt;/code&gt; argument and three &lt;code&gt;int&lt;/code&gt; arguments and return no result. The second argument must be a 3-bit compile-time constant, identifying the 16-bit sub-register to be stored, the third argument must be a 3-bit compile time constants, indicating one the registers I0-I7, and the fourth argument must be an 8-bit compile time constant.</source>
          <target state="translated">以下内容使用 &lt;code&gt;__v8hi&lt;/code&gt; 参数和三个 &lt;code&gt;int&lt;/code&gt; 参数，但不返回结果。第二个参数必须是3位编译时常数，标识要存储的16位子寄存器，第三个参数必须是3位编译时常数，指示寄存器I0-I7，第四个参数参数必须是8位编译时间常数。</target>
        </trans-unit>
        <trans-unit id="5da4f813451b70864b4ac68a9c6bb25ff058833e" translate="yes" xml:space="preserve">
          <source>The following take a &lt;code&gt;__v8hi&lt;/code&gt; argument and two &lt;code&gt;int&lt;/code&gt; arguments and return a &lt;code&gt;__v8hi&lt;/code&gt; result. The second argument must be a 3-bit compile time constants, indicating one the registers I0-I7, and the third argument must be an 8-bit compile time constant.</source>
          <target state="translated">以下代码接受 &lt;code&gt;__v8hi&lt;/code&gt; 参数和两个 &lt;code&gt;int&lt;/code&gt; 参数，并返回 &lt;code&gt;__v8hi&lt;/code&gt; 结果。第二个参数必须是3位编译时间常数，指示寄存器I0-I7，第三个参数必须是8位编译时间常数。</target>
        </trans-unit>
        <trans-unit id="559f51894eceb199907d056ff4f4a6285c76d1d1" translate="yes" xml:space="preserve">
          <source>The following take a &lt;code&gt;__v8hi&lt;/code&gt; argument and two &lt;code&gt;int&lt;/code&gt; arguments and return no result. The second argument must be a 3-bit compile time constants, indicating one the registers I0-I7, and the third argument must be an 8-bit compile time constant.</source>
          <target state="translated">以下代码接受 &lt;code&gt;__v8hi&lt;/code&gt; 参数和两个 &lt;code&gt;int&lt;/code&gt; 参数，并且不返回结果。第二个参数必须是3位编译时间常数，指示寄存器I0-I7，第三个参数必须是8位编译时间常数。</target>
        </trans-unit>
        <trans-unit id="19babaec618194855f5c8b00e66e42a23a7c9b80" translate="yes" xml:space="preserve">
          <source>The following take a single &lt;code&gt;__v8hi&lt;/code&gt; argument and return a &lt;code&gt;__v8hi&lt;/code&gt; result:</source>
          <target state="translated">以下代码接受一个 &lt;code&gt;__v8hi&lt;/code&gt; 参数，并返回 &lt;code&gt;__v8hi&lt;/code&gt; 结果：</target>
        </trans-unit>
        <trans-unit id="24b4a9f9391a5e9fb5aa4cf91d4033a4a1ba3911" translate="yes" xml:space="preserve">
          <source>The following take an &lt;code&gt;int&lt;/code&gt; argument and return no result:</source>
          <target state="translated">以下内容采用 &lt;code&gt;int&lt;/code&gt; 参数，但不返回结果：</target>
        </trans-unit>
        <trans-unit id="1708876febe0e46c893dfd70681ac1b1b3aa8762" translate="yes" xml:space="preserve">
          <source>The following take one &lt;code&gt;__v8hi&lt;/code&gt; and one &lt;code&gt;int&lt;/code&gt; argument and return a &lt;code&gt;__v8hi&lt;/code&gt; result:</source>
          <target state="translated">以下代码采用一个 &lt;code&gt;__v8hi&lt;/code&gt; 和一个 &lt;code&gt;int&lt;/code&gt; 参数，并返回 &lt;code&gt;__v8hi&lt;/code&gt; 结果：</target>
        </trans-unit>
        <trans-unit id="3ad9bd81f972d4f83266bbddb59970dde24eddc0" translate="yes" xml:space="preserve">
          <source>The following take one &lt;code&gt;__v8hi&lt;/code&gt; argument and one &lt;code&gt;int&lt;/code&gt; argument which must be a 3-bit compile time constant indicating a register number I0-I7. They return a &lt;code&gt;__v8hi&lt;/code&gt; result.</source>
          <target state="translated">以下采用一个 &lt;code&gt;__v8hi&lt;/code&gt; 参数和一个 &lt;code&gt;int&lt;/code&gt; 参数，它们必须是3位编译时间常数，指示寄存器号I0-I7。他们返回 &lt;code&gt;__v8hi&lt;/code&gt; 结果。</target>
        </trans-unit>
        <trans-unit id="bc2a1ecceb07161357bd0a5bf4b1cca5ccc19add" translate="yes" xml:space="preserve">
          <source>The following take one &lt;code&gt;__v8hi&lt;/code&gt; argument and one &lt;code&gt;int&lt;/code&gt; argument which must be a 6-bit compile time constant. They return a &lt;code&gt;__v8hi&lt;/code&gt; result.</source>
          <target state="translated">以下内容采用一个 &lt;code&gt;__v8hi&lt;/code&gt; 参数和一个 &lt;code&gt;int&lt;/code&gt; 参数，它们必须是6位编译时间常数。他们返回 &lt;code&gt;__v8hi&lt;/code&gt; 结果。</target>
        </trans-unit>
        <trans-unit id="c720afe018ece35380697d65f42b49460f2c3700" translate="yes" xml:space="preserve">
          <source>The following take one &lt;code&gt;__v8hi&lt;/code&gt; argument and one &lt;code&gt;int&lt;/code&gt; argument which must be a 8-bit compile time constant. They return a &lt;code&gt;__v8hi&lt;/code&gt; result.</source>
          <target state="translated">以下内容采用一个 &lt;code&gt;__v8hi&lt;/code&gt; 参数和一个 &lt;code&gt;int&lt;/code&gt; 参数，它们必须是8位编译时间常数。他们返回 &lt;code&gt;__v8hi&lt;/code&gt; 结果。</target>
        </trans-unit>
        <trans-unit id="0015b52d89388ff44035be55e55280be0b4aaeb6" translate="yes" xml:space="preserve">
          <source>The following take two &lt;code&gt;__v8hi&lt;/code&gt; arguments and return a &lt;code&gt;__v8hi&lt;/code&gt; result:</source>
          <target state="translated">以下代码接受两个 &lt;code&gt;__v8hi&lt;/code&gt; 参数，并返回 &lt;code&gt;__v8hi&lt;/code&gt; 结果：</target>
        </trans-unit>
        <trans-unit id="074063c3bbf2515afebb90aeb39ce860c2e31da4" translate="yes" xml:space="preserve">
          <source>The following take two &lt;code&gt;int&lt;/code&gt; arguments and return a &lt;code&gt;__v8hi&lt;/code&gt; result. The first argument must be a 3-bit compile time constants, indicating one the registers I0-I7, and the second argument must be an 8-bit compile time constant.</source>
          <target state="translated">以下采用两个 &lt;code&gt;int&lt;/code&gt; 参数，并返回 &lt;code&gt;__v8hi&lt;/code&gt; 结果。第一个参数必须是3位编译时间常数，指示寄存器I0-I7，第二个参数必须是8位编译时间常数。</target>
        </trans-unit>
        <trans-unit id="e5b1b82914edb80d2ca00848561437d84a1f1eb2" translate="yes" xml:space="preserve">
          <source>The following take two &lt;code&gt;int&lt;/code&gt; arguments and return no result. The first argument must a 3-bit compile time constant indicating one of the DR0-DR7 DMA setup channels:</source>
          <target state="translated">以下采用两个 &lt;code&gt;int&lt;/code&gt; 参数，但不返回结果。第一个参数必须是3位编译时间常数，指示DR0-DR7 DMA设置通道之一：</target>
        </trans-unit>
        <trans-unit id="14c057c170ec53d564774b373c4a36cf121034de" translate="yes" xml:space="preserve">
          <source>The following take two &lt;code&gt;int&lt;/code&gt; arguments and return no result:</source>
          <target state="translated">以下采用两个 &lt;code&gt;int&lt;/code&gt; 参数，但不返回结果：</target>
        </trans-unit>
        <trans-unit id="c73d90b3764a03700faea9b5a80499c3a3c6ee74" translate="yes" xml:space="preserve">
          <source>The following take two &lt;code&gt;int&lt;/code&gt; arguments, the second of which which must be a 8-bit compile time constant. They return a &lt;code&gt;__v8hi&lt;/code&gt; result:</source>
          <target state="translated">以下采用两个 &lt;code&gt;int&lt;/code&gt; 参数，其中第二个必须为8位编译时间常数。他们返回 &lt;code&gt;__v8hi&lt;/code&gt; 结果：</target>
        </trans-unit>
        <trans-unit id="7604a9689ceddf3a88ac390cfb640c35daa9929f" translate="yes" xml:space="preserve">
          <source>The following target-specific function attributes are available for the AArch64 target. For the most part, these options mirror the behavior of similar command-line options (see &lt;a href=&quot;aarch64-options#AArch64-Options&quot;&gt;AArch64 Options&lt;/a&gt;), but on a per-function basis.</source>
          <target state="translated">以下特定于目标的功能属性可用于AArch64目标。在大多数情况下，这些选项反映了相似的命令行选项的行为（请参阅&lt;a href=&quot;aarch64-options#AArch64-Options&quot;&gt;AArch64 Options&lt;/a&gt;），但是基于每个功能。</target>
        </trans-unit>
        <trans-unit id="2a9dcb7afea2063b88c3f0d0bf8b210d678cf434" translate="yes" xml:space="preserve">
          <source>The following type attributes are supported on most targets.</source>
          <target state="translated">大多数目标都支持以下类型属性:</target>
        </trans-unit>
        <trans-unit id="7ea3e81960cea1d06fa9fca33b75a29a1d4f2d4a" translate="yes" xml:space="preserve">
          <source>The following values of &lt;var&gt;insn&lt;/var&gt; are supported. Except as otherwise noted, floating-point operations are expected to be implemented with normal IEEE 754 semantics and correspond directly to the C operators or the equivalent GCC built-in functions (see &lt;a href=&quot;other-builtins#Other-Builtins&quot;&gt;Other Builtins&lt;/a&gt;).</source>
          <target state="translated">支持以下 &lt;var&gt;insn&lt;/var&gt; 值。除非另有说明，否则浮点运算应以普通的IEEE 754语义实现，并直接对应于C运算符或等效的GCC内置函数（请参见&lt;a href=&quot;other-builtins#Other-Builtins&quot;&gt;Other Builtins&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="da10b4f1472639ab267cde98b6118ed2bb143912" translate="yes" xml:space="preserve">
          <source>The formats are checked against the format features supported by GNU libc version 2.2. These include all ISO C90 and C99 features, as well as features from the Single Unix Specification and some BSD and GNU extensions. Other library implementations may not support all these features; GCC does not support warning about features that go beyond a particular library&amp;rsquo;s limitations. However, if</source>
          <target state="translated">对照GNU libc 2.2版支持的格式功能检查格式。这些功能包括所有ISO C90和C99功能，以及Single Unix Specification中的功能以及某些BSD和GNU扩展。其他库实现可能不支持所有这些功能。 GCC不支持有关超出特定库限制的功能的警告。但是，如果</target>
        </trans-unit>
        <trans-unit id="3fd329b7b6e510f8c7f38ab04501976f2c6f4c71" translate="yes" xml:space="preserve">
          <source>The forwarding method implementation thus created is returned by &lt;code&gt;objc_msg_lookup()&lt;/code&gt; and is executed as if it was a normal method implementation. When the forwarding method implementation is called, it is usually expected to pack all arguments into some sort of object (typically, an &lt;code&gt;NSInvocation&lt;/code&gt; in a &amp;ldquo;Foundation&amp;rdquo; library), and hand it over to the programmer (&lt;code&gt;forwardInvocation:&lt;/code&gt;) who is then allowed to manipulate the method invocation using a high-level API provided by the &amp;ldquo;Foundation&amp;rdquo; library. For example, the programmer may want to examine the method invocation arguments and name and potentially change them before forwarding the method invocation to one or more local objects (&lt;code&gt;performInvocation:&lt;/code&gt;) or even to remote objects (by using Distributed Objects or some other mechanism). When all this completes, the return value is passed back and must be returned correctly to the original caller.</source>
          <target state="translated">如此创建的转发方法实现由 &lt;code&gt;objc_msg_lookup()&lt;/code&gt; 返回，并像正常方法实现一样执行。调用转发方法实现时，通常希望将所有参数打包到某种对象中（通常是&amp;ldquo; Foundation&amp;rdquo;库中的 &lt;code&gt;NSInvocation&lt;/code&gt; ），然后将其交给程序员（ &lt;code&gt;forwardInvocation:&lt;/code&gt; )，然后由程序员进行操作。使用&amp;ldquo;基础&amp;rdquo;库提供的高级API来操作方法调用。例如，程序员可能想检查方法调用参数和名称，并可能在将方法调用转发到一个或多个本地对象（ &lt;code&gt;performInvocation:&lt;/code&gt; ）甚至远程对象（通过使用分布式对象或其他某种机制）。完成所有这些操作后，返回值将被传递回，并且必须正确返回给原始调用方。</target>
        </trans-unit>
        <trans-unit id="370cce3123cd6103545b49952aa7ecfe80d28686" translate="yes" xml:space="preserve">
          <source>The four non-arithmetic functions (load, store, exchange, and compare_exchange) all have a generic version as well. This generic version works on any data type. It uses the lock-free built-in function if the specific data type size makes that possible; otherwise, an external call is left to be resolved at run time. This external call is the same format with the addition of a &amp;lsquo;</source>
          <target state="translated">四个非算术函数（加载，存储，交换和compare_exchange）也都具有通用版本。此通用版本适用于任何数据类型。如果特定的数据类型大小可以实现，它将使用无锁内置函数。否则，将在运行时解决外部呼叫。此外部通话的格式相同，但增加了&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="bc7082dbfb46d172471e10794421761522292732" translate="yes" xml:space="preserve">
          <source>The frame is the area on the stack that holds local variables and saved registers. The frame address is normally the address of the first word pushed on to the stack by the function. However, the exact definition depends upon the processor and the calling convention. If the processor has a dedicated frame pointer register, and the function has a frame, then &lt;code&gt;__builtin_frame_address&lt;/code&gt; returns the value of the frame pointer register.</source>
          <target state="translated">框架是堆栈上保存局部变量和已保存寄存器的区域。帧地址通常是该函数压入堆栈的第一个字的地址。但是，确切的定义取决于处理器和调用约定。如果处理器具有专用的帧指针寄存器，而函数具有帧，则 &lt;code&gt;__builtin_frame_address&lt;/code&gt; 返回帧指针寄存器的值。</target>
        </trans-unit>
        <trans-unit id="91be25b4a97f2d4dcdca61df07841207c68074ea" translate="yes" xml:space="preserve">
          <source>The front end also exposes a number of internal mechanism that can be used to simplify the writing of type traits. Note that some of these traits are likely to be removed in the future.</source>
          <target state="translated">前端还暴露了一些内部机制,可以用来简化类型特征的编写。请注意,这些特征中的一些可能会在将来被删除。</target>
        </trans-unit>
        <trans-unit id="0002fd6e851a03368550f6c8393985028e5a22a9" translate="yes" xml:space="preserve">
          <source>The function may cause execution to pause until it is known that the code is no-longer being executed speculatively (in which case &lt;var&gt;val&lt;/var&gt; can be returned, as above); or</source>
          <target state="translated">该函数可能导致执行暂停，直到知道不再通过推测方式执行代码为止（在这种情况下，可以如上所述返回 &lt;var&gt;val&lt;/var&gt; ）；要么</target>
        </trans-unit>
        <trans-unit id="c285a5c6cfe9015607ff4a0e2ac733ad987d0e25" translate="yes" xml:space="preserve">
          <source>The function may use target-dependent speculation tracking state to cause &lt;var&gt;failval&lt;/var&gt; to be returned when it is known that speculative execution has incorrectly predicted a conditional branch operation.</source>
          <target state="translated">当已知推测执行已错误地预测了条件分支操作时，该函数可以使用依赖于目标的推测跟踪状态来使 &lt;var&gt;failval&lt;/var&gt; 返回。</target>
        </trans-unit>
        <trans-unit id="1910cbf4d249572210143c348f1416c66e710621" translate="yes" xml:space="preserve">
          <source>The function parameter denoting the allocated alignment is specified by one constant integer argument whose number is the argument of the attribute. Argument numbering starts at one.</source>
          <target state="translated">表示分配的对齐方式的函数参数由一个常数整数参数指定,其编号是属性的参数。参数编号从1开始。</target>
        </trans-unit>
        <trans-unit id="3b052040572f76188271e0e3e0c80c35be66f2c8" translate="yes" xml:space="preserve">
          <source>The function parameter(s) denoting the allocated size are specified by one or two integer arguments supplied to the attribute. The allocated size is either the value of the single function argument specified or the product of the two function arguments specified. Argument numbering starts at one for ordinary functions, and at two for C++ non-static member functions.</source>
          <target state="translated">表示分配大小的函数参数由提供给属性的一个或两个整数参数指定。分配的大小是指定的单个函数参数的值或指定的两个函数参数的乘积。对于普通函数,参数编号从1开始,对于C++非静态成员函数,参数编号从2开始。</target>
        </trans-unit>
        <trans-unit id="0ca979696b9a2800aa34523d4083bf5a14d799aa" translate="yes" xml:space="preserve">
          <source>The function saves the arg pointer register, structure value address, and all registers that might be used to pass arguments to a function into a block of memory allocated on the stack. Then it returns the address of that block.</source>
          <target state="translated">该函数将arg指针寄存器、结构值地址以及所有可能用于向函数传递参数的寄存器保存到堆栈上分配的一个内存块中。然后返回该内存块的地址。</target>
        </trans-unit>
        <trans-unit id="6872e4d72d8fbbd9743faadfaad51d5d8e08d8dc" translate="yes" xml:space="preserve">
          <source>The functions listed below map directly to FR-V I-type instructions.</source>
          <target state="translated">下面列出的功能直接映射到FR-V I型说明书。</target>
        </trans-unit>
        <trans-unit id="c602f6bdf5c7225fe620c26f84e8de50c7071a07" translate="yes" xml:space="preserve">
          <source>The functions listed below map directly to FR-V M-type instructions.</source>
          <target state="translated">下面列出的功能直接映射到FR-V M型说明书。</target>
        </trans-unit>
        <trans-unit id="d757b37f17b7bb17dc67a24428e9f56b268f5c5e" translate="yes" xml:space="preserve">
          <source>The functions listed below map directly to a particular MIPS-3D instruction. Please refer to the architecture specification for more details on what each instruction does.</source>
          <target state="translated">下面列出的功能直接映射到特定的MIPS-3D指令。请参考架构规范,了解每条指令的更多细节。</target>
        </trans-unit>
        <trans-unit id="636b8102a37675bf78355f0f6bba2ff462438334" translate="yes" xml:space="preserve">
          <source>The functions supported are:</source>
          <target state="translated">支持的功能有:</target>
        </trans-unit>
        <trans-unit id="ad7023ac286f3db88bfb11b7cae18fc097b31af2" translate="yes" xml:space="preserve">
          <source>The half-precision floating-point data processing instructions. This also enables the Advanced SIMD and floating-point instructions as well as the Dot Product extension and the half-precision floating-point fmla extension.</source>
          <target state="translated">半精度浮点数据处理指令。这也使高级SIMD和浮点指令以及Dot Product扩展和半精度浮点fmla扩展成为可能。</target>
        </trans-unit>
        <trans-unit id="58f4f715483c2871dde2ce2ca0d2db8aca84c869" translate="yes" xml:space="preserve">
          <source>The half-precision floating-point data processing instructions. This also enables the Advanced SIMD and floating-point instructions.</source>
          <target state="translated">半精度浮点数据处理指令。这也使高级SIMD和浮点指令得以实现。</target>
        </trans-unit>
        <trans-unit id="11520bb64917989439d0bd1e50b448954652e968" translate="yes" xml:space="preserve">
          <source>The half-precision floating-point fmla extension. This also enables the half-precision floating-point extension and Advanced SIMD and floating-point instructions.</source>
          <target state="translated">半精度浮点fmla扩展。这也使半精度浮点扩展和高级SIMD和浮点指令成为可能。</target>
        </trans-unit>
        <trans-unit id="ddd47b9fa117c203d0b4afbba7a0a4bc59d68406" translate="yes" xml:space="preserve">
          <source>The hardware multiply routines disable interrupts whilst running and restore the previous interrupt state when they finish. This makes them safe to use inside interrupt handlers as well as in normal code.</source>
          <target state="translated">硬件乘法例程在运行时禁用中断,并在结束时恢复以前的中断状态。这使得它们可以安全地在中断处理程序内以及普通代码中使用。</target>
        </trans-unit>
        <trans-unit id="1700f28ed95fcc91e5f3613066db6eabb50e9b1f" translate="yes" xml:space="preserve">
          <source>The header files contain detailed documentation for each function in the GNU Objective-C runtime API.</source>
          <target state="translated">头文件包含GNU Objective-C运行时API中每个函数的详细文档。</target>
        </trans-unit>
        <trans-unit id="bef3ae0649be61ff8ea14c16eb476e462ede9be4" translate="yes" xml:space="preserve">
          <source>The high part (bits 12 and upwards) of the pc-relative address of a symbol within 4GB of the instruction</source>
          <target state="translated">在指令的4GB范围内,一个符号的pc相关地址的高位部分(第12位以上)。</target>
        </trans-unit>
        <trans-unit id="ea0d4a97e0e09b3d462961a102c172f60bf94df3" translate="yes" xml:space="preserve">
          <source>The iWMMX GR registers.</source>
          <target state="translated">iWMMX GR寄存器。</target>
        </trans-unit>
        <trans-unit id="2ad23a41b556be75b4554217ab7b7da89d6570d2" translate="yes" xml:space="preserve">
          <source>The iWMMX co-processor registers.</source>
          <target state="translated">iWMMX协处理器寄存器。</target>
        </trans-unit>
        <trans-unit id="b46a70e92f765a7f4dbecade6890d0ae606db8e1" translate="yes" xml:space="preserve">
          <source>The idea behind this is that sometimes it is convenient (for the programmer) to consider floating-point values as approximations to infinitely precise real numbers. If you are doing this, then you need to compute (by analyzing the code, or in some other way) the maximum or likely maximum error that the computation introduces, and allow for it when performing comparisons (and when producing output, but that&amp;rsquo;s a different problem). In particular, instead of testing for equality, you should check to see whether the two values have ranges that overlap; and this is done with the relational operators, so equality comparisons are probably mistaken.</source>
          <target state="translated">其背后的想法是，有时（对于程序员而言）将浮点值视为无限精确的实数的近似值很方便。如果执行此操作，则需要计算（通过分析代码或通过其他方式）计算所引入的最大或可能的最大误差，并在进行比较（以及生成输出时）允许它，但这是不同的问题）。特别是，您应该检查两个值是否具有重叠的范围，而不是测试是否相等。并且这是通过关系运算符完成的，因此相等比较可能是错误的。</target>
        </trans-unit>
        <trans-unit id="c0a98af2de248cc10c278826d9411559e39eee26" translate="yes" xml:space="preserve">
          <source>The identifier &lt;code&gt;__func__&lt;/code&gt; is implicitly declared by the translator as if, immediately following the opening brace of each function definition, the declaration</source>
          <target state="translated">标识符 &lt;code&gt;__func__&lt;/code&gt; 由翻译器隐式声明，就像在紧随每个函数定义的大括号之后进行声明一样</target>
        </trans-unit>
        <trans-unit id="13fbfb86cc636b25b4f8dbf9788be6becd2407c7" translate="yes" xml:space="preserve">
          <source>The immediate value 0x01.</source>
          <target state="translated">即时值0x01。</target>
        </trans-unit>
        <trans-unit id="52de78dd0ef761fa638ed2df23930f5359ca4c01" translate="yes" xml:space="preserve">
          <source>The immediate value 0x7ff.</source>
          <target state="translated">即时值0x7ff。</target>
        </trans-unit>
        <trans-unit id="178295c2520a8328225a3e14f6430b205aa477b7" translate="yes" xml:space="preserve">
          <source>The immediate value 0xff.</source>
          <target state="translated">即时值0xff。</target>
        </trans-unit>
        <trans-unit id="ba38c21b26ea7ac3618ca4682f483633c0168822" translate="yes" xml:space="preserve">
          <source>The immediate value 0xffff.</source>
          <target state="translated">即时值0xffffff。</target>
        </trans-unit>
        <trans-unit id="f3edc2d2bcd9f411eb9c02f201cf5906b594ce1b" translate="yes" xml:space="preserve">
          <source>The immediate value that can be simply set high 20-bit.</source>
          <target state="translated">可简单设置高20位的即时值。</target>
        </trans-unit>
        <trans-unit id="f3b3ce3b975ce4bb65c0a8ad20428b556134b6e5" translate="yes" xml:space="preserve">
          <source>The immediate value with power of 2 minus 1.</source>
          <target state="translated">2的幂数的立即值减1。</target>
        </trans-unit>
        <trans-unit id="cdad57dc1c93e8c86249089910e5d64e47612ed8" translate="yes" xml:space="preserve">
          <source>The immediate value with power of 2.</source>
          <target state="translated">2的幂数的眼前的值。</target>
        </trans-unit>
        <trans-unit id="292bc2fc3bad9eb92ff6853193b506ffc6d78c40" translate="yes" xml:space="preserve">
          <source>The impacted functions are determined by the compiler&amp;rsquo;s interprocedural optimizations. For example, a caller is impacted when inlining a function into its caller, cloning a function and changing its caller to call this new clone, or extracting a function&amp;rsquo;s pureness/constness information to optimize its direct or indirect callers, etc.</source>
          <target state="translated">受影响的功能由编译器的过程间优化确定。例如，在将函数内联到其调用方，克隆函数并更改其调用方以调用此新克隆，或提取函数的纯净度/常数信息以优化其直接或间接调用方时，调用方会受到影响。</target>
        </trans-unit>
        <trans-unit id="788e9c101326291dabb53f85af22d398e9b836ec" translate="yes" xml:space="preserve">
          <source>The implementation of messaging in the GNU Objective-C runtime is designed to be portable, and so is based on standard C.</source>
          <target state="translated">在GNU Objective-C运行时中,消息传递的实现被设计成可移植的,所以是基于标准的C语言。</target>
        </trans-unit>
        <trans-unit id="4de99bcf5ddd6a719a8ac7733daede651bd9f548" translate="yes" xml:space="preserve">
          <source>The important thing to keep in mind is that to enable link-time optimizations you need to use the GCC driver to perform the link step. GCC automatically performs link-time optimization if any of the objects involved were compiled with the</source>
          <target state="translated">需要注意的是,要启用链接时间优化,需要使用GCC驱动来执行链接步骤。如果所涉及的任何对象是用GCC驱动编译的,GCC会自动执行链接时间优化。</target>
        </trans-unit>
        <trans-unit id="9a2b4fb08fe8eee4956db02cb6f8d3c3fb54b6e4" translate="yes" xml:space="preserve">
          <source>The index values must be constant expressions, even if the array being initialized is automatic.</source>
          <target state="translated">索引值必须是常量表达式,即使被初始化的数组是自动的。</target>
        </trans-unit>
        <trans-unit id="20238db563baf6821f8bed87f8777e30be3fd316" translate="yes" xml:space="preserve">
          <source>The induction variable optimizations give up on loops that contain more induction variable uses.</source>
          <target state="translated">归纳变量优化放弃了包含较多归纳变量用法的循环。</target>
        </trans-unit>
        <trans-unit id="99b9ae56dc4f69f455cd2846f1efc86548a4f0b0" translate="yes" xml:space="preserve">
          <source>The instructions generated by the following builtins are not considered as candidates for scheduling. They are not moved around by the compiler during scheduling, and thus can be expected to appear where they are put in the C code:</source>
          <target state="translated">以下内置程序生成的指令不被视为调度的候选指令,它们在调度过程中不会被编译器移动,因此可以期待它们出现在C代码中的位置。编译器在调度过程中不会移动它们,因此可以预期它们会出现在C代码中的位置。</target>
        </trans-unit>
        <trans-unit id="0143a1fa40596d46b920e516a49bccafb05c6756" translate="yes" xml:space="preserve">
          <source>The integer constant -1.</source>
          <target state="translated">整数常数-1。</target>
        </trans-unit>
        <trans-unit id="0304e4a19fa9d570fa64154ef073c85be9e9d234" translate="yes" xml:space="preserve">
          <source>The integer constant -2.</source>
          <target state="translated">整数常数-2。</target>
        </trans-unit>
        <trans-unit id="20219359f9654d4bb60ad841282922f1407f31ff" translate="yes" xml:space="preserve">
          <source>The integer constant 0.</source>
          <target state="translated">整数常数0。</target>
        </trans-unit>
        <trans-unit id="84b9a3c5e77c93a53f2664cad25c5af25a563160" translate="yes" xml:space="preserve">
          <source>The integer constant 0xffffffff.</source>
          <target state="translated">整数常数0xffffffffff。</target>
        </trans-unit>
        <trans-unit id="0900ba8234ff692dd368ac2562960d9c24b87490" translate="yes" xml:space="preserve">
          <source>The integer constant 0xffffffff00000000.</source>
          <target state="translated">整数常数0xffffffff00000000。</target>
        </trans-unit>
        <trans-unit id="1704120ef6a8406a0d73d119b3bae3d2fd6db0c7" translate="yes" xml:space="preserve">
          <source>The integer constant 1.</source>
          <target state="translated">整数常数1。</target>
        </trans-unit>
        <trans-unit id="f7733e70947e25f6ba4f15b855fbc6bb56230e77" translate="yes" xml:space="preserve">
          <source>The integer constant 2.</source>
          <target state="translated">整数常数2。</target>
        </trans-unit>
        <trans-unit id="2e4afdbd5f6f64969b9a9086ed5845106d1e1df4" translate="yes" xml:space="preserve">
          <source>The integer type compatible with each enumerated type (C90 6.5.2.2, C99 and C11 6.7.2.2).</source>
          <target state="translated">与每个枚举类型兼容的整数类型(C90 6.5.2.2,C99和C11 6.7.2.2)。</target>
        </trans-unit>
        <trans-unit id="d4f4c82404325b1bedf2b678bda8824c1372dc16" translate="yes" xml:space="preserve">
          <source>The integer zero constant.</source>
          <target state="translated">整数零常数。</target>
        </trans-unit>
        <trans-unit id="7f5eb05da6eb2941255dd1f24db7755004fe0fb6" translate="yes" xml:space="preserve">
          <source>The intended use can be e.g.</source>
          <target state="translated">预期用途可以是,例如:</target>
        </trans-unit>
        <trans-unit id="eec03e559122067c46321a3d23e2fe242aaa628b" translate="yes" xml:space="preserve">
          <source>The intrinsic &lt;code&gt;void __tile_network_barrier (void)&lt;/code&gt; is used to guarantee that no network operations before it are reordered with those after it.</source>
          <target state="translated">固有的 &lt;code&gt;void __tile_network_barrier (void)&lt;/code&gt; 用于确保在将网络操作与其后的操作重新排序之前，没有网络操作。</target>
        </trans-unit>
        <trans-unit id="2b326f68cedc113119b7cfc329617004f7ca5d0f" translate="yes" xml:space="preserve">
          <source>The intrinsics provided are listed below; each is named after the machine instruction to which it corresponds, with suffixes added as appropriate to distinguish intrinsics that expand to the same machine instruction yet have different argument types. Refer to the architecture documentation for a description of the functionality of each instruction.</source>
          <target state="translated">所提供的本征在下面列出;每个本征都以其对应的机器指令命名,并酌情添加后缀,以区分扩展到同一机器指令但具有不同参数类型的本征。关于每条指令的功能描述,请参考架构文档。</target>
        </trans-unit>
        <trans-unit id="3a0e26ddf5eff18eeea3fbd0b9d1cb136b8b4213" translate="yes" xml:space="preserve">
          <source>The intrinsics provided are listed below; each is named after the machine instruction.</source>
          <target state="translated">提供的本体如下;每个本体以机器指令命名。</target>
        </trans-unit>
        <trans-unit id="3eef6d5321de2f795448068015c7c54f1ed1296f" translate="yes" xml:space="preserve">
          <source>The keyword &lt;code&gt;@compatibility_alias&lt;/code&gt; allows you to define a class name as equivalent to another class name. For example:</source>
          <target state="translated">关键字 &lt;code&gt;@compatibility_alias&lt;/code&gt; 允许您将一个类名定义为等效于另一个类名。例如：</target>
        </trans-unit>
        <trans-unit id="dae34f2a2b2a52f07242474e58c01e8458c373a3" translate="yes" xml:space="preserve">
          <source>The keyword &lt;code&gt;__alignof__&lt;/code&gt; determines the alignment requirement of a function, object, or a type, or the minimum alignment usually required by a type. Its syntax is just like &lt;code&gt;sizeof&lt;/code&gt; and C11 &lt;code&gt;_Alignof&lt;/code&gt;.</source>
          <target state="translated">关键字 &lt;code&gt;__alignof__&lt;/code&gt; 确定函数，对象或类型的对齐要求，或类型通常所需的最小对齐。它的语法就像 &lt;code&gt;sizeof&lt;/code&gt; 和C11 &lt;code&gt;_Alignof&lt;/code&gt; 一样。</target>
        </trans-unit>
        <trans-unit id="0e11754fcd951a085d6544dab003aaba8cd78a6c" translate="yes" xml:space="preserve">
          <source>The keyword &lt;code&gt;__attribute__&lt;/code&gt; allows you to specify special properties of variables, function parameters, or structure, union, and, in C++, class members. This &lt;code&gt;__attribute__&lt;/code&gt; keyword is followed by an attribute specification enclosed in double parentheses. Some attributes are currently defined generically for variables. Other attributes are defined for variables on particular target systems. Other attributes are available for functions (see &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;Function Attributes&lt;/a&gt;), labels (see &lt;a href=&quot;label-attributes#Label-Attributes&quot;&gt;Label Attributes&lt;/a&gt;), enumerators (see &lt;a href=&quot;enumerator-attributes#Enumerator-Attributes&quot;&gt;Enumerator Attributes&lt;/a&gt;), statements (see &lt;a href=&quot;statement-attributes#Statement-Attributes&quot;&gt;Statement Attributes&lt;/a&gt;), and for types (see &lt;a href=&quot;type-attributes#Type-Attributes&quot;&gt;Type Attributes&lt;/a&gt;). Other front ends might define more attributes (see &lt;a href=&quot;c_002b_002b-extensions#C_002b_002b-Extensions&quot;&gt;Extensions to the C++ Language&lt;/a&gt;).</source>
          <target state="translated">关键字 &lt;code&gt;__attribute__&lt;/code&gt; 允许您指定变量，函数参数或结构，联合以及在C ++中的类成员的特殊属性。该 &lt;code&gt;__attribute__&lt;/code&gt; 关键字后跟一个用双括号括起来的属性规范。当前通常为变量定义一些属性。为特定目标系统上的变量定义了其他属性。其他属性可用于函数（请参见&lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;函数属性&lt;/a&gt;），标签（请参见&lt;a href=&quot;label-attributes#Label-Attributes&quot;&gt;Label Attributes&lt;/a&gt;），枚举器（请参见&lt;a href=&quot;enumerator-attributes#Enumerator-Attributes&quot;&gt;Enumerator Attributes&lt;/a&gt;），语句（请参见&lt;a href=&quot;statement-attributes#Statement-Attributes&quot;&gt;Statement Attributes&lt;/a&gt;）和类型（请参见&lt;a href=&quot;type-attributes#Type-Attributes&quot;&gt;Type Attributes&lt;/a&gt;）。其他前端可能会定义更多属性（请参阅&lt;a href=&quot;c_002b_002b-extensions#C_002b_002b-Extensions&quot;&gt;C ++语言的扩展&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="a4cf059503889f054506ae99e86330f0d94efc6c" translate="yes" xml:space="preserve">
          <source>The keyword &lt;code&gt;__attribute__&lt;/code&gt; allows you to specify various special properties of types. Some type attributes apply only to structure and union types, and in C++, also class types, while others can apply to any type defined via a &lt;code&gt;typedef&lt;/code&gt; declaration. Unless otherwise specified, the same restrictions and effects apply to attributes regardless of whether a type is a trivial structure or a C++ class with user-defined constructors, destructors, or a copy assignment.</source>
          <target state="translated">关键字 &lt;code&gt;__attribute__&lt;/code&gt; 允许您指定类型的各种特殊属性。一些类型属性仅适用于结构和联合类型，在C ++中也适用于类类型，而其他一些属性则适用于通过 &lt;code&gt;typedef&lt;/code&gt; 声明定义的任何类型。除非另有说明，否则无论类型是琐碎的结构还是带有用户定义的构造函数，析构函数或副本分配的C ++类，相同的限制和效果都将应用于属性。</target>
        </trans-unit>
        <trans-unit id="1572dc96be7f5e014878efc69fdfd49b0ae87eea" translate="yes" xml:space="preserve">
          <source>The keyword &lt;code&gt;__thread&lt;/code&gt; applied to a non-local object gives the object thread storage duration.</source>
          <target state="translated">应用于非本地对象的关键字 &lt;code&gt;__thread&lt;/code&gt; 给出了对象线程的存储时间。</target>
        </trans-unit>
        <trans-unit id="39b19603ff8ee793099ac42a05990562491ebaf2" translate="yes" xml:space="preserve">
          <source>The label declaration defines the label &lt;em&gt;name&lt;/em&gt;, but does not define the label itself. You must do this in the usual way, with &lt;code&gt;&lt;var&gt;label&lt;/var&gt;:&lt;/code&gt;, within the statements of the statement expression.</source>
          <target state="translated">标签声明定义标签&lt;em&gt;名称&lt;/em&gt;，但不定义标签本身。您必须以通常的方式，在语句表达式的语句中使用 &lt;code&gt;&lt;var&gt;label&lt;/var&gt;:&lt;/code&gt; 来执行此操作。</target>
        </trans-unit>
        <trans-unit id="428f4e4c9e8e6a37b249e009bb97c82a44c2fb8f" translate="yes" xml:space="preserve">
          <source>The language-independent component of GCC includes the majority of the optimizers, as well as the &amp;ldquo;back ends&amp;rdquo; that generate machine code for various processors.</source>
          <target state="translated">GCC的与语言无关的组件包括大多数优化器，以及为各种处理器生成机器代码的&amp;ldquo;后端&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="005fac6b181ca927cb2a738c000f5da953afe1b7" translate="yes" xml:space="preserve">
          <source>The last thing in the compound statement should be an expression followed by a semicolon; the value of this subexpression serves as the value of the entire construct. (If you use some other kind of statement last within the braces, the construct has type &lt;code&gt;void&lt;/code&gt;, and thus effectively no value.)</source>
          <target state="translated">复合语句中的最后一件事应该是一个表达式，后跟一个分号。该子表达式的值用作整个构造的值。（如果最后在花括号内使用其他类型的语句，则该构造的类型为 &lt;code&gt;void&lt;/code&gt; ，因此实际上没有任何值。）</target>
        </trans-unit>
        <trans-unit id="206e1d46d7d3ee120b67ca48c1a3f104346b70ef" translate="yes" xml:space="preserve">
          <source>The length of an array is computed once when the storage is allocated and is remembered for the scope of the array in case you access it with &lt;code&gt;sizeof&lt;/code&gt;.</source>
          <target state="translated">分配存储空间后，数组的长度将被计算一次，并记住该数组的范围，以防您使用 &lt;code&gt;sizeof&lt;/code&gt; 访问它。</target>
        </trans-unit>
        <trans-unit id="ce058b55eed72e669ebdbd6e3aba9093499b97c5" translate="yes" xml:space="preserve">
          <source>The letters represent the following data types:</source>
          <target state="translated">这些字母代表以下数据类型:</target>
        </trans-unit>
        <trans-unit id="77263b459d57cfcd71f0acd14e32e54e7be714c9" translate="yes" xml:space="preserve">
          <source>The lifetime of a compiler generated temporary is well defined by the C++ standard. When a lifetime of a temporary ends, and if the temporary lives in memory, the optimizing compiler has the freedom to reuse its stack space with other temporaries or scoped local variables whose live range does not overlap with it. However some of the legacy code relies on the behavior of older compilers in which temporaries&amp;rsquo; stack space is not reused, the aggressive stack reuse can lead to runtime errors. This option is used to control the temporary stack reuse optimization.</source>
          <target state="translated">C ++标准很好地定义了编译器生成的临时文件的生命周期。当临时变量的生存期结束并且临时变量驻留在内存中时，优化编译器可以自由地将其堆栈空间与其他临时变量或作用域范围不重叠的局部作用域局部变量重用。但是，某些遗留代码依赖于较旧的编译器的行为，在这些行为中，临时器的堆栈空间未得到重用，激进的堆栈重用会导致运行时错误。此选项用于控制临时堆栈重用优化。</target>
        </trans-unit>
        <trans-unit id="499ee472bf57c8d5ea52c4b866109362dfcc7841" translate="yes" xml:space="preserve">
          <source>The limit applies &lt;em&gt;after&lt;/em&gt; string constant concatenation, and does not count the trailing NUL. In C90, the limit was 509 characters; in C99, it was raised to 4095. C++98 does not specify a normative minimum maximum, so we do not diagnose overlength strings in C++.</source>
          <target state="translated">该限制&lt;em&gt;在&lt;/em&gt;字符串常量连接&lt;em&gt;之后&lt;/em&gt;适用，并且不计算尾随的NUL。在C90中，限制为509个字符；在C99中，它被提高到4095。C++ 98没有指定规范的最小最大值，因此我们无法在C ++中诊断超长字符串。</target>
        </trans-unit>
        <trans-unit id="e6c688d4fc373af85820537cf244755f93f3571e" translate="yes" xml:space="preserve">
          <source>The limit specifying large stack frames. While inlining the algorithm is trying to not grow past this limit too much.</source>
          <target state="translated">规定大堆栈框架的限制。在内联时,算法尽量不要超过这个限制太多。</target>
        </trans-unit>
        <trans-unit id="85f90ab304447934cd7fe1bd66dac4bb5697c076" translate="yes" xml:space="preserve">
          <source>The limit specifying large translation unit. Growth caused by inlining of units larger than this limit is limited by</source>
          <target state="translated">指定大翻译单位的限制。大于此限制的单位内嵌引起的增长受以下限制</target>
        </trans-unit>
        <trans-unit id="24d66aaeb77b8d51a696a30383b9a88d8d0ffec4" translate="yes" xml:space="preserve">
          <source>The limit specifying really large functions. For functions larger than this limit after inlining, inlining is constrained by</source>
          <target state="translated">指定真正大函数的限制。对于内联后大于此限值的函数,内联的限制条件是</target>
        </trans-unit>
        <trans-unit id="c3e28be9ccc81004da7fffd01a2901be4871fc54" translate="yes" xml:space="preserve">
          <source>The link register, &lt;code&gt;lr&lt;/code&gt;.</source>
          <target state="translated">链接寄存器 &lt;code&gt;lr&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="26f2bb016c8b0766650946224b7ac36870093175" translate="yes" xml:space="preserve">
          <source>The linker searches a standard list of directories for the library. The directories searched include several standard system directories plus any that you specify with</source>
          <target state="translated">链接器为库搜索一个标准的目录列表。搜索的目录包括几个标准的系统目录和任何你用</target>
        </trans-unit>
        <trans-unit id="78e4e4eb1e36ecbe1ce8c7bd81da2158dd82d6a9" translate="yes" xml:space="preserve">
          <source>The loader for SPU does not handle dynamic relocations. By default, GCC gives an error when it generates code that requires a dynamic relocation.</source>
          <target state="translated">SPU的加载器不处理动态重定位。默认情况下,GCC在生成需要动态重定位的代码时,会给出一个错误。</target>
        </trans-unit>
        <trans-unit id="168977c575f70c81d88c067d5911fa44bdb4a1dc" translate="yes" xml:space="preserve">
          <source>The local label feature is useful for complex macros. If a macro contains nested loops, a &lt;code&gt;goto&lt;/code&gt; can be useful for breaking out of them. However, an ordinary label whose scope is the whole function cannot be used: if the macro can be expanded several times in one function, the label is multiply defined in that function. A local label avoids this problem. For example:</source>
          <target state="translated">本地标签功能对复杂的宏很有用。如果宏包含嵌套循环，则 &lt;code&gt;goto&lt;/code&gt; 可用于打破它们。但是，不能使用范围为整个函数的普通标签：如果宏可以在一个函数中扩展多次，则该标签会在该函数中被乘以定义。本地标签可避免此问题。例如：</target>
        </trans-unit>
        <trans-unit id="d40c92db025f666809a32030712abb46e10389b2" translate="yes" xml:space="preserve">
          <source>The location is expressed as a half-open range, expressed as a count of bytes, starting at byte 1 for the initial column. In the above example, bytes 3 through 20 of line 45 of &amp;ldquo;test.c&amp;rdquo; are to be replaced with the given string:</source>
          <target state="translated">该位置表示为半开范围，表示为字节数，从初始列的字节1开始。在上面的示例中，&amp;ldquo; test.c&amp;rdquo;的第45行的字节3到20将用给定的字符串替换：</target>
        </trans-unit>
        <trans-unit id="068a4b98cf23f1dbecfe9f83dd38994bfe05765c" translate="yes" xml:space="preserve">
          <source>The locations within &lt;code&gt;#pragma&lt;/code&gt; directives where header name preprocessing tokens are recognized (C11 6.4, C11 6.4.7).</source>
          <target state="translated">内的位置 &lt;code&gt;#pragma&lt;/code&gt; 其中标题名称预处理标记被识别指令（C11 6.4，C11 6.4.7）。</target>
        </trans-unit>
        <trans-unit id="fc6965c74c684a5066713cd45514db9bb14c9963" translate="yes" xml:space="preserve">
          <source>The long long types are only implemented for 64-bit code generation.</source>
          <target state="translated">长长类型只在64位代码生成时实现。</target>
        </trans-unit>
        <trans-unit id="6b21e2c583138d02ccff65c0acb02831c06a2211" translate="yes" xml:space="preserve">
          <source>The low registers r0 - r15.</source>
          <target state="translated">低位寄存器r0-r15。</target>
        </trans-unit>
        <trans-unit id="ed4899b603c3d7a32aa6ba260f62f9b063dd80a8" translate="yes" xml:space="preserve">
          <source>The macro &lt;code&gt;__CET__&lt;/code&gt; is defined when</source>
          <target state="translated">宏 &lt;code&gt;__CET__&lt;/code&gt; 在以下情况下定义</target>
        </trans-unit>
        <trans-unit id="835cec1112f64c57bd44cb4fd1c6251993152130" translate="yes" xml:space="preserve">
          <source>The macro &lt;code&gt;__STRICT_ANSI__&lt;/code&gt; is predefined when the</source>
          <target state="translated">宏 &lt;code&gt;__STRICT_ANSI__&lt;/code&gt; 是在</target>
        </trans-unit>
        <trans-unit id="4af0e1087a3dafe7b329598208d0e7bd6efe70c3" translate="yes" xml:space="preserve">
          <source>The main use case of the built-in is to determine whether a &lt;code&gt;constexpr&lt;/code&gt; function is being called in a &lt;code&gt;constexpr&lt;/code&gt; context. A call to the function evaluates to a core constant expression with the value &lt;code&gt;true&lt;/code&gt; if and only if it occurs within the evaluation of an expression or conversion that is manifestly constant-evaluated as defined in the C++ standard. Manifestly constant-evaluated contexts include constant-expressions, the conditions of &lt;code&gt;constexpr if&lt;/code&gt; statements, constraint-expressions, and initializers of variables usable in constant expressions. For more details refer to the latest revision of the C++ standard.</source>
          <target state="translated">内置的主要用例是确定是否在 &lt;code&gt;constexpr&lt;/code&gt; 上下文中调用 &lt;code&gt;constexpr&lt;/code&gt; 函数。当且仅当函数调用出现在按照C ++标准定义的表达式或转换的求值中，且该求值明显地是常量求值时，对函数的调用才会求值为值为 &lt;code&gt;true&lt;/code&gt; 的核心常量表达式。显然，常量求值的上下文包括常量表达式， &lt;code&gt;constexpr if&lt;/code&gt; 语句的条件，约束表达式以及可在常量表达式中使用的变量的初始化程序。有关更多详细信息，请参考C ++标准的最新版本。</target>
        </trans-unit>
        <trans-unit id="44703f46619b4bb3387fbb3a9a4987ca25838ebf" translate="yes" xml:space="preserve">
          <source>The mangling was changed in</source>
          <target state="translated">mangling被改变在</target>
        </trans-unit>
        <trans-unit id="86f9d67774b219fd5194ad2624b61ab77f3088cf" translate="yes" xml:space="preserve">
          <source>The mapping between physical source file multibyte characters and the source character set in translation phase 1 (C90, C99 and C11 5.1.1.2).</source>
          <target state="translated">物理源文件多字节字符与翻译阶段1中的源字符集之间的映射(C90、C99和C11 5.1.1.2)。</target>
        </trans-unit>
        <trans-unit id="63322b3a774c9974339e8944410fb9a8c6f8ebf4" translate="yes" xml:space="preserve">
          <source>The mapping of members of the source character set (in character constants and string literals) to members of the execution character set (C90 6.1.3.4, C99 and C11 6.4.4.4, C90, C99 and C11 5.1.1.2).</source>
          <target state="translated">源字符集成员(以字符常量和字符串字元为单位)到执行字符集成员的映射(C90 6.1.3.4,C99和C11 6.4.4.4,C90、C99和C11 5.1.1.2)。</target>
        </trans-unit>
        <trans-unit id="6bc3864d5e277c6ac4690c5e9d3fdbf817cb1a7c" translate="yes" xml:space="preserve">
          <source>The max number of reload pseudos which are considered during spilling a non-reload pseudo.</source>
          <target state="translated">溢出非重装伪装时考虑的最大重装伪装数量。</target>
        </trans-unit>
        <trans-unit id="4f47dce047d8beaa87edf8a1fdc1bf827620a7f2" translate="yes" xml:space="preserve">
          <source>The maximum alignment for SIMD vector mode types. &lt;var&gt;num&lt;/var&gt; may be 4 or 8. The default is 8. Note that this is an ABI change, even though many library function interfaces are unaffected if they don&amp;rsquo;t use SIMD vector modes in places that affect size and/or alignment of relevant types.</source>
          <target state="translated">SIMD矢量模式类型的最大对齐方式。 &lt;var&gt;num&lt;/var&gt; 可以是4或8。默认值是8。请注意，这是ABI更改，即使许多库函数接口在不影响相关类型的大小和/或对齐的地方不使用SIMD矢量模式也不受影响。</target>
        </trans-unit>
        <trans-unit id="666ee1692153a86b3ec75a197326eda3a0d60489" translate="yes" xml:space="preserve">
          <source>The maximum amount of iterations of the pass over the function. This is used to limit compilation time in tree tail merging.</source>
          <target state="translated">pass over函数的最大迭代量。用于限制树尾合并的编译时间。</target>
        </trans-unit>
        <trans-unit id="89ecfe4db21e974dbc1daddf5e580b9450304991" translate="yes" xml:space="preserve">
          <source>The maximum amount of similar bbs to compare a bb with. This is used to avoid quadratic behavior in tree tail merging.</source>
          <target state="translated">比较相似的bbs的最大数量。这是为了避免树尾合并中的二次元行为。</target>
        </trans-unit>
        <trans-unit id="b6556ebb0621924348132da881ea97c1a248f5ac" translate="yes" xml:space="preserve">
          <source>The maximum code size expansion factor when copying basic blocks instead of jumping. The expansion is relative to a jump instruction.</source>
          <target state="translated">复制基本块而不是跳转时的最大代码大小扩展因子。膨胀系数是相对于跳转指令而言的。</target>
        </trans-unit>
        <trans-unit id="fce841f0d7fbba4e3b6b48cb84aa6e927eb09594" translate="yes" xml:space="preserve">
          <source>The maximum code size growth ratio when expanding into a jump table (in percent). The parameter is used when optimizing for size.</source>
          <target state="translated">扩展到跳转表时的最大代码大小增长比率(百分比)。该参数在优化大小时使用。</target>
        </trans-unit>
        <trans-unit id="e2d12fa5294a85cba03b250f3a5bea21673f3bb2" translate="yes" xml:space="preserve">
          <source>The maximum code size growth ratio when expanding into a jump table (in percent). The parameter is used when optimizing for speed.</source>
          <target state="translated">扩展到跳转表时的最大代码大小增长比率(百分比)。该参数在优化速度时使用。</target>
        </trans-unit>
        <trans-unit id="936a590636d845b92624c7728a4827fce9d92d06" translate="yes" xml:space="preserve">
          <source>The maximum conflict delay for an insn to be considered for speculative motion.</source>
          <target state="translated">在推测性动议中考虑的最大冲突延迟。</target>
        </trans-unit>
        <trans-unit id="fbb7200dcbf807a75160beecc432fa62ed3e9728" translate="yes" xml:space="preserve">
          <source>The maximum depth of a loop nest suitable for complete peeling.</source>
          <target state="translated">适宜完全剥离的环形窝的最大深度。</target>
        </trans-unit>
        <trans-unit id="26a797ef806eaaf765b7a781b669b0a1ee2786d8" translate="yes" xml:space="preserve">
          <source>The maximum depth of recursive inlining for non-inline functions.</source>
          <target state="translated">非内联函数递归内联的最大深度。</target>
        </trans-unit>
        <trans-unit id="20b08dcc7587be3ab6eef2848d7ad81b5a152655" translate="yes" xml:space="preserve">
          <source>The maximum length of a constant string for a builtin string cmp call eligible for inlining.</source>
          <target state="translated">符合内联条件的内置字符串cmp调用的常量字符串的最大长度。</target>
        </trans-unit>
        <trans-unit id="be0d3936975ebff6f26b92e20318105d1c7db49a" translate="yes" xml:space="preserve">
          <source>The maximum number of &amp;rsquo;after supernode&amp;rsquo; exploded nodes within the analyzer per supernode, before terminating analysis.</source>
          <target state="translated">终止分析之前，每个超节点在分析器中&amp;ldquo;超节点之后&amp;rdquo;爆炸节点的最大数量。</target>
        </trans-unit>
        <trans-unit id="38e85e4670d6f7ac0961160fd225824b117f4e1d" translate="yes" xml:space="preserve">
          <source>The maximum number of &lt;code&gt;case&lt;/code&gt; values in a &lt;code&gt;switch&lt;/code&gt; statement (C90 6.6.4.2).</source>
          <target state="translated">&lt;code&gt;switch&lt;/code&gt; 语句（C90 6.6.4.2）中的最大 &lt;code&gt;case&lt;/code&gt; 值数。</target>
        </trans-unit>
        <trans-unit id="0a2afaa6d3ae61c2d6492935df7934433f87eae8" translate="yes" xml:space="preserve">
          <source>The maximum number of SSA_NAME assignments to follow in determining a property of a variable such as its value. This limits the number of iterations or recursive calls GCC performs when optimizing certain statements or when determining their validity prior to issuing diagnostics.</source>
          <target state="translated">在确定一个变量的属性(如其值)时要遵循的SSA_NAME赋值的最大次数。这限制了GCC在优化某些语句或在发出诊断程序之前确定其有效性时执行的迭代或递归调用的次数。</target>
        </trans-unit>
        <trans-unit id="f915c9b0ddf0bbc0779c3cf7dd483c9574fb303a" translate="yes" xml:space="preserve">
          <source>The maximum number of artificial accesses that Scalar Replacement of Aggregates (SRA) will track, per one local variable, in order to facilitate copy propagation.</source>
          <target state="translated">Scalar Replacement of Aggregates (SRA)为了便于复制传播,每一个局部变量将跟踪的最大人工访问次数。</target>
        </trans-unit>
        <trans-unit id="1cfdd5d91556b4dd893a62b6a75874eee03cf513" translate="yes" xml:space="preserve">
          <source>The maximum number of assertions to add along the default edge of a switch statement during VRP.</source>
          <target state="translated">在VRP期间,沿着交换机语句的默认边缘添加的最大断言数量。</target>
        </trans-unit>
        <trans-unit id="c6e6bc4dbd514d325e3c749eca0229393e1fb788" translate="yes" xml:space="preserve">
          <source>The maximum number of backtrack attempts the scheduler should make when modulo scheduling a loop. Larger values can exponentially increase compilation time.</source>
          <target state="translated">调度器在模数调度一个循环时,应该进行的最大回溯尝试次数。数值越大,编译时间就会成倍增加。</target>
        </trans-unit>
        <trans-unit id="018c7375a2caf17039c26fd694620cad7ebfaa5f" translate="yes" xml:space="preserve">
          <source>The maximum number of basic blocks on path that CSE considers.</source>
          <target state="translated">CSE考虑的路径上的最大基本块数。</target>
        </trans-unit>
        <trans-unit id="c79967caf66fa10b13e953918175f64b9fd85351" translate="yes" xml:space="preserve">
          <source>The maximum number of best instructions in the ready list that are considered for renaming in the selective scheduler.</source>
          <target state="translated">准备就绪列表中,在选择性调度器中考虑重命名的最佳指令的最大数量。</target>
        </trans-unit>
        <trans-unit id="79a02e3d5ce6c0b561178810954860635f75b277" translate="yes" xml:space="preserve">
          <source>The maximum number of blocks in a region to be considered for interblock scheduling.</source>
          <target state="translated">一个区域内考虑区块间调度的最大区块数。</target>
        </trans-unit>
        <trans-unit id="3225f5aa45adb6a455e07adb58dbc4331ca98962" translate="yes" xml:space="preserve">
          <source>The maximum number of blocks in a region to be considered for pipelining in the selective scheduler.</source>
          <target state="translated">选择性调度器中考虑流水线的区域的最大块数。</target>
        </trans-unit>
        <trans-unit id="d26d722dd2f733f712aeb0f605ec58066091d632" translate="yes" xml:space="preserve">
          <source>The maximum number of branches on the hot path through the peeled sequence.</source>
          <target state="translated">通过剥离序列的热路径上的最大分支数。</target>
        </trans-unit>
        <trans-unit id="d2fe875bfce475e08e430e98ccc72ad1afca879e" translate="yes" xml:space="preserve">
          <source>The maximum number of branches unswitched in a single loop.</source>
          <target state="translated">单个回路中未切换的最大分支数。</target>
        </trans-unit>
        <trans-unit id="9965c595ccb073bed98dc2ae6e76b73f1d6e9fe2" translate="yes" xml:space="preserve">
          <source>The maximum number of conditional store pairs that can be sunk. Set to 0 if either vectorization (</source>
          <target state="translated">可以下沉的条件存储对的最大数量。设为0,如果矢量化(</target>
        </trans-unit>
        <trans-unit id="126cc6769740c4d71bac9ace9af0b249f19d3967" translate="yes" xml:space="preserve">
          <source>The maximum number of declarators that may modify an arithmetic, structure or union type (C90 6.5.4).</source>
          <target state="translated">可以修改算术类型、结构类型或联合类型的声明符的最大数量(C90 6.5.4)。</target>
        </trans-unit>
        <trans-unit id="4d5793f890c15f6b518ebfeeddd6bdf92fc933a4" translate="yes" xml:space="preserve">
          <source>The maximum number of exploded nodes per program point within the analyzer, before terminating analysis of that point.</source>
          <target state="translated">分析器内每个程序点在终止分析该点之前的最大爆炸节点数。</target>
        </trans-unit>
        <trans-unit id="046b54d8dec00a923499bbe98f2011a4caa2c4d1" translate="yes" xml:space="preserve">
          <source>The maximum number of incoming edges to consider for cross-jumping. The algorithm used by</source>
          <target state="translated">考虑交叉跳转的最大传入边数。使用的算法是</target>
        </trans-unit>
        <trans-unit id="23db9a7b1aa156bfdeb79b1a74ceb92745f99df4" translate="yes" xml:space="preserve">
          <source>The maximum number of insns in a region to be considered for interblock scheduling.</source>
          <target state="translated">一个区域内考虑进行区块间调度的最大insn数量。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
