<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="gcc">
    <body>
      <group id="gcc">
        <trans-unit id="f6ee8357cf66d468fce21ce87f6e1455c61c9d71" translate="yes" xml:space="preserve">
          <source>8.2. +load: Executing Code before main</source>
          <target state="translated">8.2.+load:在main之前执行代码</target>
        </trans-unit>
        <trans-unit id="0e37b3bc6a72bc7a45aefe525b01b3bcbc69dc62" translate="yes" xml:space="preserve">
          <source>8.2.1 What You Can and Cannot Do in +load</source>
          <target state="translated">8.2.1 在+load中可以和不可以做的事情</target>
        </trans-unit>
        <trans-unit id="7514eae887431bc2b23c9f91ceeb2b8927f90957" translate="yes" xml:space="preserve">
          <source>8.2.1 What You Can and Cannot Do in &lt;code&gt;+load&lt;/code&gt;</source>
          <target state="translated">8.2.1在 &lt;code&gt;+load&lt;/code&gt; 中可以做什么和不能做什么</target>
        </trans-unit>
        <trans-unit id="8bc74bfbf57cd10928d01b916e6fa71d6d37346e" translate="yes" xml:space="preserve">
          <source>8.2.1. What You Can and Cannot Do in +load</source>
          <target state="translated">8.2.1.在+load中可以和不可以做什么?</target>
        </trans-unit>
        <trans-unit id="ac17a28fe0400efdbbf27dc0a3aa19d768882f50" translate="yes" xml:space="preserve">
          <source>8.3 Type Encoding</source>
          <target state="translated">8.3 类型编码</target>
        </trans-unit>
        <trans-unit id="0b5a28a401e5caa1731675ca56a84d444c15fa81" translate="yes" xml:space="preserve">
          <source>8.3. Type Encoding</source>
          <target state="translated">8.3.类型编码</target>
        </trans-unit>
        <trans-unit id="f6228ff4737811227a708bc22b6ff3a77b75cceb" translate="yes" xml:space="preserve">
          <source>8.3.1 Legacy Type Encoding</source>
          <target state="translated">8.3.1 传统类型编码</target>
        </trans-unit>
        <trans-unit id="7bec6b4bee7afdb83a43730a9fe5c4d6d085e864" translate="yes" xml:space="preserve">
          <source>8.3.1. Legacy Type Encoding</source>
          <target state="translated">8.3.1.遗留类型编码</target>
        </trans-unit>
        <trans-unit id="5527244afdb6dfb3dca3ad889987c2fef987074e" translate="yes" xml:space="preserve">
          <source>8.3.2 &lt;code&gt;@encode&lt;/code&gt;</source>
          <target state="translated">8.3.2 &lt;code&gt;@encode&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="978fa94702c6bb2aa016de617938fd819d570db4" translate="yes" xml:space="preserve">
          <source>8.3.2 @encode</source>
          <target state="translated">8.3.2 @encode</target>
        </trans-unit>
        <trans-unit id="4493f310bc1651626e01d4c07ee677385159442c" translate="yes" xml:space="preserve">
          <source>8.3.2. @encode</source>
          <target state="translated">8.3.2.@encode</target>
        </trans-unit>
        <trans-unit id="e76f8c08ebb07739970dc34b59461ba675ae7b31" translate="yes" xml:space="preserve">
          <source>8.3.3 Method Signatures</source>
          <target state="translated">8.3.3 方法签名</target>
        </trans-unit>
        <trans-unit id="0cd2b9090f85dc474192078b9cdd2977a7b93ce8" translate="yes" xml:space="preserve">
          <source>8.3.3. Method Signatures</source>
          <target state="translated">8.3.3.方法签名</target>
        </trans-unit>
        <trans-unit id="8dc0bdb621513ef296dfe1ccb8a8e69178e55c00" translate="yes" xml:space="preserve">
          <source>8.4 Garbage Collection</source>
          <target state="translated">8.4 垃圾收集</target>
        </trans-unit>
        <trans-unit id="f07f1c7fc14cbe1fbcf43d8205938600aba5fb3a" translate="yes" xml:space="preserve">
          <source>8.4. Garbage Collection</source>
          <target state="translated">8.4.垃圾收集</target>
        </trans-unit>
        <trans-unit id="7a1c9992cbe3a8eb5bac4598d41c0f55497fcfd0" translate="yes" xml:space="preserve">
          <source>8.5 Constant String Objects</source>
          <target state="translated">8.5 常量字符串对象</target>
        </trans-unit>
        <trans-unit id="4a2eeb0e04646c0d1d5dde7596bb4e3ab441cf85" translate="yes" xml:space="preserve">
          <source>8.5. Constant String Objects</source>
          <target state="translated">8.5.常量字符串对象</target>
        </trans-unit>
        <trans-unit id="1ad03b99d44944113a02e8b2d43422e1fb50690e" translate="yes" xml:space="preserve">
          <source>8.6 &lt;code&gt;compatibility_alias&lt;/code&gt;</source>
          <target state="translated">8.6 &lt;code&gt;compatibility_alias&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="16a6371cd4eb99b88acbb876c48214d1528996b9" translate="yes" xml:space="preserve">
          <source>8.6 compatibility_alias</source>
          <target state="translated">8.6 兼容性_利亚斯</target>
        </trans-unit>
        <trans-unit id="68169a32cc1b2c0d8e0fdd12ac28ee8a4f88ccd1" translate="yes" xml:space="preserve">
          <source>8.6. compatibility_alias</source>
          <target state="translated">8.6.兼容性_利亚斯</target>
        </trans-unit>
        <trans-unit id="477e0b2d2877013fc309d42abd04b7a7fac95b0e" translate="yes" xml:space="preserve">
          <source>8.7 Exceptions</source>
          <target state="translated">8.7 例外情况</target>
        </trans-unit>
        <trans-unit id="16af8614813519947458cd70b76429228a166bf8" translate="yes" xml:space="preserve">
          <source>8.7. Exceptions</source>
          <target state="translated">8.7.8.7.例外情况</target>
        </trans-unit>
        <trans-unit id="74543d3119c6680f587a9317c42b3e80f7812525" translate="yes" xml:space="preserve">
          <source>8.8 Synchronization</source>
          <target state="translated">8.8 同步化</target>
        </trans-unit>
        <trans-unit id="083f9b1455cca391952297e65a5f3c8e7fb0c091" translate="yes" xml:space="preserve">
          <source>8.8. Synchronization</source>
          <target state="translated">8.8.同步化</target>
        </trans-unit>
        <trans-unit id="7338c2122f2c6512086917a88263a1ffa319037d" translate="yes" xml:space="preserve">
          <source>8.9 Fast Enumeration</source>
          <target state="translated">8.9 快速枚举</target>
        </trans-unit>
        <trans-unit id="ec7154738dfa0ae117df4872a446a28e2a0711e7" translate="yes" xml:space="preserve">
          <source>8.9. Fast Enumeration</source>
          <target state="translated">8.9.快速列举</target>
        </trans-unit>
        <trans-unit id="c5c48c9ddc1c6eec5370a9f3cc1d2da53b4277bc" translate="yes" xml:space="preserve">
          <source>8.9.1 Using Fast Enumeration</source>
          <target state="translated">8.9.1 使用快速枚举法</target>
        </trans-unit>
        <trans-unit id="6ad2c7a48f39c65d867329ec2c7335528dcac484" translate="yes" xml:space="preserve">
          <source>8.9.1. Using Fast Enumeration</source>
          <target state="translated">8.9.1.使用快速枚举</target>
        </trans-unit>
        <trans-unit id="d4e4b02de8979958bbc292a9013946837f1fa2de" translate="yes" xml:space="preserve">
          <source>8.9.2 C99-Like Fast Enumeration Syntax</source>
          <target state="translated">8.9.2 类似C99的快速枚举语法</target>
        </trans-unit>
        <trans-unit id="c0c8d7e4c548cb334b0077b49fb8d7954fa1bc7a" translate="yes" xml:space="preserve">
          <source>8.9.2. C99-Like Fast Enumeration Syntax</source>
          <target state="translated">8.9.2.类似C99的快速枚举语法</target>
        </trans-unit>
        <trans-unit id="fc941982a158e238821dd94fbed3bb5cab331767" translate="yes" xml:space="preserve">
          <source>8.9.3 Fast Enumeration Details</source>
          <target state="translated">8.9.3 快速枚举详情</target>
        </trans-unit>
        <trans-unit id="1e69e987b4483c072c99556446bfbd580c89a6c7" translate="yes" xml:space="preserve">
          <source>8.9.3. Fast Enumeration Details</source>
          <target state="translated">8.9.3.快速列举细节</target>
        </trans-unit>
        <trans-unit id="66afcdf52d12c5936c393d8a7d4415ca40641c8c" translate="yes" xml:space="preserve">
          <source>8.9.4 Fast Enumeration Protocol</source>
          <target state="translated">8.9.4 快速枚举议定书</target>
        </trans-unit>
        <trans-unit id="af86351ac19c6a92b0fadb75de17d30680748abf" translate="yes" xml:space="preserve">
          <source>8.9.4. Fast Enumeration Protocol</source>
          <target state="translated">8.9.4.快速枚举协议</target>
        </trans-unit>
        <trans-unit id="2a24cd506294a07c6a0446f8badafaf3201f2507" translate="yes" xml:space="preserve">
          <source>9 Binary Compatibility</source>
          <target state="translated">9 二进制兼容性</target>
        </trans-unit>
        <trans-unit id="aaf34f43b56348453c9670867bbe710bc4cff1f1" translate="yes" xml:space="preserve">
          <source>9-bit signed integer constant for load and store postincrements</source>
          <target state="translated">9位有符号的整数常数,用于加载和存储后增量。</target>
        </trans-unit>
        <trans-unit id="f5866ff425b2380665d4757e884a24f7c0c34afd" translate="yes" xml:space="preserve">
          <source>9. Binary Compatibility</source>
          <target state="translated">9.二进制兼容性</target>
        </trans-unit>
        <trans-unit id="05a79f06cf3f67f726dae68d18a2290f6c9a50c9" translate="yes" xml:space="preserve">
          <source>:</source>
          <target state="translated">:</target>
        </trans-unit>
        <trans-unit id="0e96f6929feaa8c7f7735055f893a7b75a845c22" translate="yes" xml:space="preserve">
          <source>: even though it may help make the global offset table smaller, it trades 1 instruction for 4. With</source>
          <target state="translated">：即使可以帮助减小全局偏移表，也可以将1条指令换成4条指令。</target>
        </trans-unit>
        <trans-unit id="63347315fe8e655bf95e9a504d6fcbb0f9ecd9f0" translate="yes" xml:space="preserve">
          <source>: this header declares a public runtime API threading layer that is only provided by the GNU Objective-C runtime. It declares functions such as &lt;code&gt;objc_mutex_lock()&lt;/code&gt;, which provide a platform-independent set of threading functions.</source>
          <target state="translated">：此标头声明了仅由GNU Objective-C运行时提供的公共运行时API线程层。它声明了诸如 &lt;code&gt;objc_mutex_lock()&lt;/code&gt; 之类的函数，这些函数提供了与平台无关的一组线程函数。</target>
        </trans-unit>
        <trans-unit id="30dd56b7640731d14fa9ecac2bbbbb504e1a5176" translate="yes" xml:space="preserve">
          <source>: this header declares most of the public runtime API functions allowing you to inspect and manipulate the Objective-C runtime data structures. These functions are fairly standardized across Objective-C runtimes and are almost identical to the Apple/NeXT Objective-C runtime ones. It does not declare functions in some specialized areas (constructing and forwarding message invocations, threading) which are in the other headers below. You have to include</source>
          <target state="translated">：此标头声明了大多数公共运行时API函数，使您可以检查和操作Objective-C运行时数据结构。这些功能在Objective-C运行时中已经相当标准化，并且几乎与Apple / NeXT Objective-C运行时相同。它没有在下面的其他标头中的某些专门区域（构造和转发消息调用，线程）中声明函数。你必须包括</target>
        </trans-unit>
        <trans-unit id="26a235338902d41d3db5491024b9576d18742880" translate="yes" xml:space="preserve">
          <source>: this header declares public functions used to construct, deconstruct and forward message invocations. Because messaging is done in quite a different way on different runtimes, functions in this header are specific to the GNU Objective-C runtime implementation.</source>
          <target state="translated">：此标头声明用于构造，解构和转发消息调用的公共函数。因为消息传递是在不同的运行时以完全不同的方式完成的，所以此标头中的函数特定于GNU Objective-C运行时实现。</target>
        </trans-unit>
        <trans-unit id="5a3c29505625144ba68750995731439e9906fdd5" translate="yes" xml:space="preserve">
          <source>: this header declares some public functions related to Objective-C exceptions. For example functions in this header allow you to throw an Objective-C exception from plain C/C++ code.</source>
          <target state="translated">：此标头声明了一些与Objective-C异常相关的公共函数。例如，此标头中的函数使您可以从纯C / C ++代码引发Objective-C异常。</target>
        </trans-unit>
        <trans-unit id="9e5ef08f873716700e594dd3a36d7d64d5272d49" translate="yes" xml:space="preserve">
          <source>: this header declares some public functions related to the Objective-C &lt;code&gt;@synchronized()&lt;/code&gt; syntax, allowing you to emulate an Objective-C &lt;code&gt;@synchronized()&lt;/code&gt; block in plain C/C++ code.</source>
          <target state="translated">：此标头声明了一些与Objective-C &lt;code&gt;@synchronized()&lt;/code&gt; 语法相关的公共函数，使您可以在纯C / C ++代码中模拟Objective-C &lt;code&gt;@synchronized()&lt;/code&gt; 块。</target>
        </trans-unit>
        <trans-unit id="7cc9c1a09bf135868f452e4dc5bbf2907bfed13f" translate="yes" xml:space="preserve">
          <source>: this is the basic Objective-C header file, defining the basic Objective-C types such as &lt;code&gt;id&lt;/code&gt;, &lt;code&gt;Class&lt;/code&gt; and &lt;code&gt;BOOL&lt;/code&gt;. You have to include this header to do almost anything with Objective-C.</source>
          <target state="translated">：这是基本的Objective-C头文件，定义了基本的Objective-C类型，例如 &lt;code&gt;id&lt;/code&gt; ， &lt;code&gt;Class&lt;/code&gt; 和 &lt;code&gt;BOOL&lt;/code&gt; 。您必须包含此标头才能使用Objective-C进行几乎所有操作。</target>
        </trans-unit>
        <trans-unit id="e8c89b6d4332bd3369abe0522644501e5013a432" translate="yes" xml:space="preserve">
          <source>; higher levels are not, and must be explicitly requested.</source>
          <target state="translated">; 没有更高的级别，必须明确要求。</target>
        </trans-unit>
        <trans-unit id="a66283a15e09823e79a5c6a663cf680f2ab5e710" translate="yes" xml:space="preserve">
          <source>; however, use of the backchain for debugging purposes usually requires that the whole binary is built with</source>
          <target state="translated">; 但是，将后链用于调试目的通常需要使用</target>
        </trans-unit>
        <trans-unit id="2e840d8b6d6867941a2eee8b46c7d917829de2b1" translate="yes" xml:space="preserve">
          <source>; it causes the preprocessor to treat comments as tokens in their own right. For example, comments appearing at the start of what would be a directive line have the effect of turning that line into an ordinary source line, since the first token on the line is no longer a &amp;lsquo;</source>
          <target state="translated">; 它使预处理器本身将注释视为标记。例如，在指令行的开头出现的注释会将其变成普通的源代码行，因为该行上的第一个标记不再是'</target>
        </trans-unit>
        <trans-unit id="fe9de4759d0dc5597c891d37b107703d1930a026" translate="yes" xml:space="preserve">
          <source>; it then defines &lt;code&gt;__STDC_HOSTED__&lt;/code&gt; to &lt;code&gt;0&lt;/code&gt; and does not make assumptions about the meanings of function names from the standard library, with exceptions noted below. To build an OS kernel, you may well still need to make your own arrangements for linking and startup. See &lt;a href=&quot;c-dialect-options#C-Dialect-Options&quot;&gt;Options Controlling C Dialect&lt;/a&gt;.</source>
          <target state="translated">; 然后，它将 &lt;code&gt;__STDC_HOSTED__&lt;/code&gt; 定义为 &lt;code&gt;0&lt;/code&gt; ，并且不对标准库中函数名的含义进行假设，但以下情况除外。要构建OS内核，您可能仍然需要自行安排链接和启动。请参阅&lt;a href=&quot;c-dialect-options#C-Dialect-Options&quot;&gt;控制C语言的选项&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0bd28d9793fcd7e9f0549371e16a97a1f053629f" translate="yes" xml:space="preserve">
          <source>; see &lt;a href=&quot;c_002b_002b-dialect-options#C_002b_002b-Dialect-Options&quot;&gt;Options Controlling C++ Dialect&lt;/a&gt;.</source>
          <target state="translated">; 请参阅&lt;a href=&quot;c_002b_002b-dialect-options#C_002b_002b-Dialect-Options&quot;&gt;控制C ++语言的选项&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="50016dac566b707582c4b1fc771e52069b7a937b" translate="yes" xml:space="preserve">
          <source>; the corrections are also applied with</source>
          <target state="translated">; 更正也适用于</target>
        </trans-unit>
        <trans-unit id="3eb04dcb759dd8c0995915b2a5ccb10d6a327b33" translate="yes" xml:space="preserve">
          <source>; the same rule applies to macros defined this way.</source>
          <target state="translated">; 同样的规则适用于以这种方式定义的宏。</target>
        </trans-unit>
        <trans-unit id="00b878f7746de72103ac67a35f0e1d78575bcec7" translate="yes" xml:space="preserve">
          <source>; they do not have this problem.</source>
          <target state="translated">; 他们没有这个问题。</target>
        </trans-unit>
        <trans-unit id="39de10441f5a92f5c2ca38349b7c2fdec8841dcf" translate="yes" xml:space="preserve">
          <source>; this option implies</source>
          <target state="translated">; 此选项暗示</target>
        </trans-unit>
        <trans-unit id="1989c55c1ff2b01f4215828caa4538ad66beba83" translate="yes" xml:space="preserve">
          <source>; to obtain all the diagnostics required by the standard, you should also specify</source>
          <target state="translated">; 要获得标准要求的所有诊断，还应指定</target>
        </trans-unit>
        <trans-unit id="a73b42f7298a4e09fb1e0072c5f63bdced6b9b8c" translate="yes" xml:space="preserve">
          <source>; when linking, it links in a special thread helper library</source>
          <target state="translated">; 链接时，它会链接到特殊的线程帮助器库中</target>
        </trans-unit>
        <trans-unit id="06561510744788a1609ec5f60662cc5908d39e15" translate="yes" xml:space="preserve">
          <source>; you should not need to use it for anything else.</source>
          <target state="translated">; 您无需将其用于其他任何用途。</target>
        </trans-unit>
        <trans-unit id="431058a2491fcbde34064009eece9653a8f5b829" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Example&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;Example&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="01d7c1c3eb993c58806b746668090c8a26bb75db" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Limitations and caveats&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;局限性和警告&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="0424675c89789c8478a359447a9eeb880c777989" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;[basic.start.init]&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;[basic.start.init]&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="e3b972f187fc77684d7b4caf8cb567979becf9f7" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;[basic.start.main]&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;[basic.start.main]&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="b883af22766032bc16303da205cb38fbd19479e1" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;[basic.start.term]&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;[basic.start.term]&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="b18fcd33e6f11059c9a572ef77f16711d1475704" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;[basic.stc.static]&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;[basic.stc.static]&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="0fc91ea62596ffaa9b88e5f5653a875441113bac" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;[basic.stc.thread]&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;[basic.stc.thread]&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="13e2f1e5179d31ce813b6d9c962af8d8f15a52b2" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;[basic.stc]&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;[basic.stc]&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="082e6d5681614613f1cf46008d31795e30341ce2" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;[class.mem]&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;[class.mem]&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="20a71e88049b10a9036fc51e894c28860a33cdaf" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;[dcl.stc]&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;[dcl.stc]&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="51818883b235ce777320b575e0bf8025965510ba" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;[intro.execution]&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;[intro.execution]&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="1a31fbd2e2b9c5c3bb615b7491f612d5a707c3ac" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;[lex.key]&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;[lex.key]&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="5cc4701ea1dbc7c0ae0a60db0f72537871372ebf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;![16,16i]&lt;/code&gt; (alignment depends on the machine)</source>
          <target state="translated">&lt;code&gt;![16,16i]&lt;/code&gt; （对齐方式取决于机器）</target>
        </trans-unit>
        <trans-unit id="cffc58ac2d212878e6c4d3afeb9026603af158fb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;#pragma interface&lt;/code&gt; and &lt;code&gt;#pragma implementation&lt;/code&gt; provide the user with a way of explicitly directing the compiler to emit entities with vague linkage (and debugging information) in a particular translation unit.</source>
          <target state="translated">&lt;code&gt;#pragma interface&lt;/code&gt; 和 &lt;code&gt;#pragma implementation&lt;/code&gt; 为用户提供了一种方法，该方法可明确指导编译器发出在特定翻译单元中具有模糊链接（和调试信息）的实体。</target>
        </trans-unit>
        <trans-unit id="2569b071a9af441d9b6296aa268b56f40df7cca9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;#pragma ms_struct off&lt;/code&gt; turns off the Microsoft layout.</source>
          <target state="translated">&lt;code&gt;#pragma ms_struct off&lt;/code&gt; 关闭Microsoft布局。</target>
        </trans-unit>
        <trans-unit id="5e363473f488b7983412e972ce0eac0f09b14174" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;#pragma ms_struct on&lt;/code&gt; turns on the Microsoft layout.</source>
          <target state="translated">&lt;code&gt;#pragma ms_struct on&lt;/code&gt; 打开Microsoft布局。</target>
        </trans-unit>
        <trans-unit id="107cfa70f66f6e21716326b44d8c2543bd277a0b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;#pragma ms_struct reset&lt;/code&gt; goes back to the default layout.</source>
          <target state="translated">&lt;code&gt;#pragma ms_struct reset&lt;/code&gt; 返回默认布局。</target>
        </trans-unit>
        <trans-unit id="359f3157fca41c8df8f6c827d78d1920672257ff" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;#pragma pack()&lt;/code&gt; sets the alignment to the one that was in effect when compilation started (see also command-line option</source>
          <target state="translated">&lt;code&gt;#pragma pack()&lt;/code&gt; 将对齐方式设置为开始编译时生效的对齐方式（另请参见命令行选项</target>
        </trans-unit>
        <trans-unit id="2da8592b5f1ca4f7c8ec146ce07922d1be68b588" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;#pragma pack(&lt;var&gt;n&lt;/var&gt;)&lt;/code&gt; simply sets the new alignment.</source>
          <target state="translated">&lt;code&gt;#pragma pack(&lt;var&gt;n&lt;/var&gt;)&lt;/code&gt; 仅设置新的对齐方式。</target>
        </trans-unit>
        <trans-unit id="09cd1961f6ec088315967f82b215657a1847a8f3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;#pragma pack(pop)&lt;/code&gt; restores the alignment setting to the one saved at the top of the internal stack (and removes that stack entry). Note that &lt;code&gt;#pragma pack([&lt;var&gt;n&lt;/var&gt;])&lt;/code&gt; does not influence this internal stack; thus it is possible to have &lt;code&gt;#pragma pack(push)&lt;/code&gt; followed by multiple &lt;code&gt;#pragma pack(&lt;var&gt;n&lt;/var&gt;)&lt;/code&gt; instances and finalized by a single &lt;code&gt;#pragma pack(pop)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;#pragma pack(pop)&lt;/code&gt; 将对齐设置恢复为内部堆栈顶部保存的对齐设置（并删除该堆栈条目）。注意， &lt;code&gt;#pragma pack([&lt;var&gt;n&lt;/var&gt;])&lt;/code&gt; 不会影响此内部堆栈；因此，可能有 &lt;code&gt;#pragma pack(push)&lt;/code&gt; 后跟多个 &lt;code&gt;#pragma pack(&lt;var&gt;n&lt;/var&gt;)&lt;/code&gt; 实例，并由单个 &lt;code&gt;#pragma pack(pop)&lt;/code&gt; 完成。</target>
        </trans-unit>
        <trans-unit id="c1f4e8456ee450b615ff464f6ff9615991f7f956" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;#pragma pack(push[,&lt;var&gt;n&lt;/var&gt;])&lt;/code&gt; pushes the current alignment setting on an internal stack and then optionally sets the new alignment.</source>
          <target state="translated">&lt;code&gt;#pragma pack(push[,&lt;var&gt;n&lt;/var&gt;])&lt;/code&gt; 将当前对齐设置推入内部堆栈，然后有选择地设置新的对齐方式。</target>
        </trans-unit>
        <trans-unit id="8d404d78e391f3edc2a1e7fe1018546d3f145abe" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;#pragma scalar_storage_order big-endian&lt;/code&gt; sets the storage order of the scalar fields to big-endian.</source>
          <target state="translated">&lt;code&gt;#pragma scalar_storage_order big-endian&lt;/code&gt; 将标量字段的存储顺序设置为big-endian。</target>
        </trans-unit>
        <trans-unit id="791d1af4df580d4926f6784307622e913fe6169f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;#pragma scalar_storage_order default&lt;/code&gt; goes back to the endianness that was in effect when compilation started (see also command-line option</source>
          <target state="translated">&lt;code&gt;#pragma scalar_storage_order default&lt;/code&gt; 返回到开始编译时生效的字节序（另请参阅命令行选项）</target>
        </trans-unit>
        <trans-unit id="9e92ce5f2b8e8dd2da4f3a23c57c175f27849093" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;#pragma scalar_storage_order little-endian&lt;/code&gt; sets the storage order of the scalar fields to little-endian.</source>
          <target state="translated">&lt;code&gt;#pragma scalar_storage_order little-endian&lt;/code&gt; 将标量字段的存储顺序设置为little-endian。</target>
        </trans-unit>
        <trans-unit id="d7b3947b00665c0273f8ee03de6b46c48b82e923" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;+load&lt;/code&gt; is to be used only as a last resort. Because it is executed very early, most of the Objective-C runtime machinery will not be ready when &lt;code&gt;+load&lt;/code&gt; is executed; hence &lt;code&gt;+load&lt;/code&gt; works best for executing C code that is independent on the Objective-C runtime.</source>
          <target state="translated">&lt;code&gt;+load&lt;/code&gt; 只能用作不得已的方法。因为它执行得很早，所以大多数的Objective-C运行时机器在执行 &lt;code&gt;+load&lt;/code&gt; 时都不会准备好；因此 &lt;code&gt;+load&lt;/code&gt; 最适合执行独立于Objective-C运行时的C代码。</target>
        </trans-unit>
        <trans-unit id="2a3b66c50c6331da3456637374283bba0d9341b7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;-2147483648&lt;/code&gt; is positive.</source>
          <target state="translated">&lt;code&gt;-2147483648&lt;/code&gt; 为正。</target>
        </trans-unit>
        <trans-unit id="ff73f3bc9136cfe683f6e1000d6ea1e5f0b6d324" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;0xFF&lt;/code&gt; or &lt;code&gt;0xFFFF&lt;/code&gt;, for andsi as a zero-extending move.</source>
          <target state="translated">&lt;code&gt;0xFF&lt;/code&gt; 或 &lt;code&gt;0xFFFF&lt;/code&gt; ，用于andsi作为零扩展移动。</target>
        </trans-unit>
        <trans-unit id="69970b695b65687a239461624104cc1d44b36e13" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;100&lt;/code&gt;, &lt;code&gt;102&lt;/code&gt;, &lt;code&gt;103&lt;/code&gt;, &lt;code&gt;104&lt;/code&gt;, &lt;code&gt;105&lt;/code&gt;, &lt;code&gt;106&lt;/code&gt;, &lt;code&gt;107&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;100&lt;/code&gt; ， &lt;code&gt;102&lt;/code&gt; ， &lt;code&gt;103&lt;/code&gt; ， &lt;code&gt;104&lt;/code&gt; ， &lt;code&gt;105&lt;/code&gt; ， &lt;code&gt;106&lt;/code&gt; ， &lt;code&gt;107&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f94cae98ac3d64f04d19f0b2e99e2c0a60564f25" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;2&lt;/code&gt;, &lt;code&gt;25&lt;/code&gt;, &lt;code&gt;3&lt;/code&gt;, &lt;code&gt;31&lt;/code&gt;, &lt;code&gt;35&lt;/code&gt;, &lt;code&gt;4&lt;/code&gt;, &lt;code&gt;5&lt;/code&gt;, &lt;code&gt;51&lt;/code&gt;, &lt;code&gt;6&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;2&lt;/code&gt; ， &lt;code&gt;25&lt;/code&gt; ， &lt;code&gt;3&lt;/code&gt; ， &lt;code&gt;31&lt;/code&gt; ， &lt;code&gt;35&lt;/code&gt; ， &lt;code&gt;4&lt;/code&gt; ， &lt;code&gt;5&lt;/code&gt; ， &lt;code&gt;51&lt;/code&gt; ， &lt;code&gt;6&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1bd49a42c06dc5b5614602b595d1eb861097847b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&lt;var&gt;collection expression&lt;/var&gt;&lt;/code&gt; is evaluated exactly once and the result is used as the collection object to iterate over. This means it is safe to write code such as &lt;code&gt;for (object in [NSDictionary
keyEnumerator]) &amp;hellip;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;var&gt;collection expression&lt;/var&gt;&lt;/code&gt; 只计算一次，结果用作迭代的集合对象。这意味着编写诸如 &lt;code&gt;for (object in [NSDictionary keyEnumerator]) &amp;hellip;&lt;/code&gt; 代码是安全的。</target>
        </trans-unit>
        <trans-unit id="3eba358d191709438321ae5dbb3501eb47389e2e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&lt;var&gt;statements&lt;/var&gt;&lt;/code&gt; can contain &lt;code&gt;break&lt;/code&gt; and &lt;code&gt;continue&lt;/code&gt; commands, which will abort the iteration or skip to the next loop iteration as expected.</source>
          <target state="translated">&lt;code&gt;&lt;var&gt;statements&lt;/var&gt;&lt;/code&gt; 可以包含 &lt;code&gt;break&lt;/code&gt; 和 &lt;code&gt;continue&lt;/code&gt; 命令，它们将按预期中止迭代或跳至下一个循环迭代。</target>
        </trans-unit>
        <trans-unit id="61531b33eb2db1449ceab15f5f279c4b2f1791b6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&lt;var&gt;statements&lt;/var&gt;&lt;/code&gt; must not make any changes to the collection object; if they do, it is a hard error and the fast enumeration terminates by invoking &lt;code&gt;objc_enumerationMutation&lt;/code&gt;, a runtime function that normally aborts the program but which can be customized by Foundation libraries via &lt;code&gt;objc_set_mutation_handler&lt;/code&gt; to do something different, such as raising an exception.</source>
          <target state="translated">&lt;code&gt;&lt;var&gt;statements&lt;/var&gt;&lt;/code&gt; 不能对集合对象进行任何更改；如果这样做，将是一个硬错误，并且通过调用 &lt;code&gt;objc_enumerationMutation&lt;/code&gt; 终止快速枚举，该运行时函数通常会中止程序，但是可以由Foundation库通过 &lt;code&gt;objc_set_mutation_handler&lt;/code&gt; 对其进行自定义以执行其他操作，例如引发异常。</target>
        </trans-unit>
        <trans-unit id="9d58742173ee42448629f6db4422e3203e474e70" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;@encode&lt;/code&gt; does not support type qualifiers other than &lt;code&gt;const&lt;/code&gt;. For example, &lt;code&gt;@encode(const char*)&lt;/code&gt; is valid and is compiled into &lt;code&gt;&quot;r*&quot;&lt;/code&gt;, while &lt;code&gt;@encode(bycopy char *)&lt;/code&gt; is invalid and will cause a compilation error.</source>
          <target state="translated">&lt;code&gt;@encode&lt;/code&gt; 不支持 &lt;code&gt;const&lt;/code&gt; 以外的类型限定符。例如， &lt;code&gt;@encode(const char*)&lt;/code&gt; 是有效的并且被编译为 &lt;code&gt;&quot;r*&quot;&lt;/code&gt; ，而 &lt;code&gt;@encode(bycopy char *)&lt;/code&gt; 无效并且将导致编译错误。</target>
        </trans-unit>
        <trans-unit id="06f7d071955d8af36c31b170590dbc2a8f025b17" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;A&lt;/code&gt; through &lt;code&gt;L&lt;/code&gt; registers.</source>
          <target state="translated">&lt;code&gt;A&lt;/code&gt; 至 &lt;code&gt;L&lt;/code&gt; 寄存器。</target>
        </trans-unit>
        <trans-unit id="80d0c9344feef2e94b4f1747dfadf5bbe5585ef0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;CPATH&lt;/code&gt; specifies a list of directories to be searched as if specified with</source>
          <target state="translated">&lt;code&gt;CPATH&lt;/code&gt; 指定要搜索的目录列表，就像用</target>
        </trans-unit>
        <trans-unit id="789e53d1b037b549885585694fb4b6c06a41dc94" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;GSWApplication&lt;/code&gt; (the real class) must be an existing class.</source>
          <target state="translated">&lt;code&gt;GSWApplication&lt;/code&gt; （真实类）必须是现有类。</target>
        </trans-unit>
        <trans-unit id="372485e67dabbb2f6f7563c915c0d05a5bb7796c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;NXConstantString&lt;/code&gt; inherits from &lt;code&gt;Object&lt;/code&gt;; user class libraries may choose to inherit the customized constant string class from a different class than &lt;code&gt;Object&lt;/code&gt;. There is no requirement in the methods the constant string class has to implement, but the final ivar layout of the class must be the compatible with the given structure.</source>
          <target state="translated">&lt;code&gt;NXConstantString&lt;/code&gt; 从 &lt;code&gt;Object&lt;/code&gt; 继承；用户类库可以选择从不同于 &lt;code&gt;Object&lt;/code&gt; 的类继承自定义常量字符串类。常量字符串类必须实现的方法没有要求，但是该类的最终ivar布局必须与给定的结构兼容。</target>
        </trans-unit>
        <trans-unit id="b73742c69a964b14887fe5c58b748cbc6ead8dbc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;V&lt;/code&gt; is a special modifier which prints the name of the full integer register without &lt;code&gt;%&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;V&lt;/code&gt; 是一个特殊的修饰符，它打印不带 &lt;code&gt;%&lt;/code&gt; 的完整整数寄存器的名称。</target>
        </trans-unit>
        <trans-unit id="e9680743302272f4d21a0ca0fcf6f7d2fc4b4f89" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;WOApplication&lt;/code&gt; (the alias) must not be an existing class;</source>
          <target state="translated">&lt;code&gt;WOApplication&lt;/code&gt; （别名）不能为现有类；</target>
        </trans-unit>
        <trans-unit id="ee6195175737171e4b0021bc7dc79c772162ab99" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__FUNCTION__&lt;/code&gt; is another name for &lt;code&gt;__func__&lt;/code&gt;, provided for backward compatibility with old versions of GCC.</source>
          <target state="translated">&lt;code&gt;__FUNCTION__&lt;/code&gt; 是 &lt;code&gt;__func__&lt;/code&gt; 的另一个名称，旨在与旧版本的GCC向后兼容。</target>
        </trans-unit>
        <trans-unit id="f2c1ea03a8f41c269c203f97859a30953067ac6d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__attribute ((const))&lt;/code&gt; and &lt;code&gt;noreturn&lt;/code&gt; were mangled as type qualifiers, and &lt;code&gt;decltype&lt;/code&gt; of a plain declaration was folded away.</source>
          <target state="translated">&lt;code&gt;__attribute ((const))&lt;/code&gt; 和 &lt;code&gt;noreturn&lt;/code&gt; 被修饰为类型限定符，并且普通声明的 &lt;code&gt;decltype&lt;/code&gt; 被折叠掉了。</target>
        </trans-unit>
        <trans-unit id="31d52aa69bfef9deeeff9d7920e4c48f0f233481" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__builtin_mips_set_fcsr&lt;/code&gt; can be used to change any bit of the register except the condition codes, which GCC assumes are preserved.</source>
          <target state="translated">&lt;code&gt;__builtin_mips_set_fcsr&lt;/code&gt; 可用于更改寄存器的任何位（条件代码除外），条件代码假定GCC被保留。</target>
        </trans-unit>
        <trans-unit id="dd0179ef987e379ce17d15225812657b396c054c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__const__&lt;/code&gt;, &lt;code&gt;__asm__&lt;/code&gt;, etc., for header files.</source>
          <target state="translated">&lt;code&gt;__const__&lt;/code&gt; ， &lt;code&gt;__asm__&lt;/code&gt; 等，头文件。</target>
        </trans-unit>
        <trans-unit id="7473df93d6fe52ceeeb6718adea22f662c95bc6a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__float128&lt;/code&gt; is available on i386, x86_64, IA-64, and hppa HP-UX, as well as on PowerPC GNU/Linux targets that enable the vector scalar (VSX) instruction set. &lt;code&gt;__float128&lt;/code&gt; supports the 128-bit floating type. On i386, x86_64, PowerPC, and IA-64 other than HP-UX, &lt;code&gt;__float128&lt;/code&gt; is an alias for &lt;code&gt;_Float128&lt;/code&gt;. On hppa and IA-64 HP-UX, &lt;code&gt;__float128&lt;/code&gt; is an alias for &lt;code&gt;long
double&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;__float128&lt;/code&gt; 在i386，x86_64，IA-64和hppa HP-UX上以及在启用矢量标量（VSX）指令集的PowerPC GNU / Linux目标上可用。 &lt;code&gt;__float128&lt;/code&gt; 支持128位浮点类型。在i386上，x86_64的，PowerPC和IA-64比HP-UX等， &lt;code&gt;__float128&lt;/code&gt; 是一个别名 &lt;code&gt;_Float128&lt;/code&gt; 。在hppa和IA-64 HP-UX上， &lt;code&gt;__float128&lt;/code&gt; 是 &lt;code&gt;long double&lt;/code&gt; 的别名。</target>
        </trans-unit>
        <trans-unit id="ffb2bf9a670bef293cfa77a116c8f843376e5401" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__float80&lt;/code&gt; is available on the i386, x86_64, and IA-64 targets, and supports the 80-bit (&lt;code&gt;XFmode&lt;/code&gt;) floating type. It is an alias for the type name &lt;code&gt;_Float64x&lt;/code&gt; on these targets.</source>
          <target state="translated">&lt;code&gt;__float80&lt;/code&gt; 在i386，x86_64和IA-64目标上可用，并且支持80位（ &lt;code&gt;XFmode&lt;/code&gt; ）浮点类型。这是这些目标上类型名称 &lt;code&gt;_Float64x&lt;/code&gt; 的别名。</target>
        </trans-unit>
        <trans-unit id="7ec6ed15db3de1e0e785dbadf3953c59dadef3f7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__ibm128&lt;/code&gt; is available on PowerPC targets, and provides access to the IBM extended double format which is the current format used for &lt;code&gt;long double&lt;/code&gt;. When &lt;code&gt;long double&lt;/code&gt; transitions to &lt;code&gt;__float128&lt;/code&gt; on PowerPC in the future, &lt;code&gt;__ibm128&lt;/code&gt; will remain for use in conversions between the two types.</source>
          <target state="translated">&lt;code&gt;__ibm128&lt;/code&gt; 在PowerPC目标上可用，并提供对IBM扩展双精度格式的访问，该格式是用于 &lt;code&gt;long double&lt;/code&gt; 的当前格式。当 &lt;code&gt;long double&lt;/code&gt; 过渡到 &lt;code&gt;__float128&lt;/code&gt; 在未来的PowerPC上， &lt;code&gt;__ibm128&lt;/code&gt; 将继续使用这两种类型之间的转换。</target>
        </trans-unit>
        <trans-unit id="9e3a9ed7baa3bf65df3ff05f513613983a9587ab" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;acc&lt;/code&gt; arguments are evaluated at compile time and specify the number of an accumulator register. For example, an &lt;code&gt;acc&lt;/code&gt; argument of 2 selects the ACC2 register.</source>
          <target state="translated">&lt;code&gt;acc&lt;/code&gt; 参数在编译时求值，并指定累加器寄存器的数量。例如， &lt;code&gt;acc&lt;/code&gt; 参数2选择ACC2寄存器。</target>
        </trans-unit>
        <trans-unit id="15fdbd93cf947c8849cb1d5a35f4090a626ff637" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;array&lt;/code&gt; needs to be an Objective-C object (usually a collection object, for example an array, a dictionary or a set) which implements the &amp;ldquo;Fast Enumeration Protocol&amp;rdquo; (see below). If you are using a Foundation library such as GNUstep Base or Apple Cocoa Foundation, all collection objects in the library implement this protocol and can be used in this way.</source>
          <target state="translated">&lt;code&gt;array&lt;/code&gt; 必须是实现&amp;ldquo;快速枚举协议&amp;rdquo;（见下文）的Objective-C对象（通常是集合对象，例如数组，字典或集合）。如果您使用的是GNUstep Base或Apple Cocoa Foundation之类的基础库，则该库中的所有集合对象都将实现此协议，并且可以通过这种方式使用。</target>
        </trans-unit>
        <trans-unit id="426e3d34f5d2b8cc641dc2d655c2412b3ba31507" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;asm goto&lt;/code&gt; allows assembly code to jump to one or more C labels. The &lt;var&gt;GotoLabels&lt;/var&gt; section in an &lt;code&gt;asm goto&lt;/code&gt; statement contains a comma-separated list of all C labels to which the assembler code may jump. GCC assumes that &lt;code&gt;asm&lt;/code&gt; execution falls through to the next statement (if this is not the case, consider using the &lt;code&gt;__builtin_unreachable&lt;/code&gt; intrinsic after the &lt;code&gt;asm&lt;/code&gt; statement). Optimization of &lt;code&gt;asm goto&lt;/code&gt; may be improved by using the &lt;code&gt;hot&lt;/code&gt; and &lt;code&gt;cold&lt;/code&gt; label attributes (see &lt;a href=&quot;label-attributes#Label-Attributes&quot;&gt;Label Attributes&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;asm goto&lt;/code&gt; 允许汇编代码跳转到一个或多个C标签。 &lt;code&gt;asm goto&lt;/code&gt; 语句中的 &lt;var&gt;GotoLabels&lt;/var&gt; 部分包含用逗号分隔的所有C标签列表，汇编代码可能会跳转到这些列表。 GCC假定 &lt;code&gt;asm&lt;/code&gt; 的执行会一直执行到下一条语句（如果不是这种情况，请考虑在 &lt;code&gt;asm&lt;/code&gt; 语句之后使用 &lt;code&gt;__builtin_unreachable&lt;/code&gt; 内部函数）。通过使用 &lt;code&gt;hot&lt;/code&gt; 标签标签和 &lt;code&gt;cold&lt;/code&gt; 标签属性，可以改善 &lt;code&gt;asm goto&lt;/code&gt; 的优化（请参见&lt;a href=&quot;label-attributes#Label-Attributes&quot;&gt;标签属性&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="c9823fe22f97e1ec190b250dc2a2fdf94a1ee857" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;asm&lt;/code&gt; statements may not perform jumps into other &lt;code&gt;asm&lt;/code&gt; statements, only to the listed &lt;var&gt;GotoLabels&lt;/var&gt;. GCC&amp;rsquo;s optimizers do not know about other jumps; therefore they cannot take account of them when deciding how to optimize.</source>
          <target state="translated">&lt;code&gt;asm&lt;/code&gt; 语句可能不会跳转到其他 &lt;code&gt;asm&lt;/code&gt; 语句，而只会跳转到列出的 &lt;var&gt;GotoLabels&lt;/var&gt; 。GCC的优化器不知道其他跳跃。因此，他们在决定如何优化时无法考虑它们。</target>
        </trans-unit>
        <trans-unit id="62977bb50d3c5a19ea5904a3a299ffd7ea5dbd29" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;asm&lt;/code&gt; statements may not perform jumps into other &lt;code&gt;asm&lt;/code&gt; statements. GCC does not know about these jumps, and therefore cannot take account of them when deciding how to optimize. Jumps from &lt;code&gt;asm&lt;/code&gt; to C labels are only supported in extended &lt;code&gt;asm&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;asm&lt;/code&gt; 语句可能不会执行跳转到其他 &lt;code&gt;asm&lt;/code&gt; 语句的操作。GCC不了解这些跳跃，因此在决定如何优化时无法考虑它们。仅在扩展的 &lt;code&gt;asm&lt;/code&gt; 中支持从 &lt;code&gt;asm&lt;/code&gt; 到C标签的跳转。</target>
        </trans-unit>
        <trans-unit id="c9448d646265094e46fad56b4a1ad54b2c75f890" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;asm&lt;/code&gt; supports operand modifiers on operands (for example &amp;lsquo;</source>
          <target state="translated">&lt;code&gt;asm&lt;/code&gt; 支持对操作数进行操作数修饰符（例如'</target>
        </trans-unit>
        <trans-unit id="47c475345b4b6683f86ef0bd1304fa403571227e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;b&lt;/code&gt; followed by the starting position of the bit-field, the type of the bit-field and the size of the bit-field (the bit-fields encoding was changed from the NeXT&amp;rsquo;s compiler encoding, see below)</source>
          <target state="translated">&lt;code&gt;b&lt;/code&gt; 然后是位域的起始位置，位域的类型和位域的大小（位域编码已从NeXT的编译器编码中更改，请参见下文）</target>
        </trans-unit>
        <trans-unit id="fd931d3282f78cf10b6e109fc3d87523a40b1c70" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;const int*&lt;/code&gt; is a pointer to a &lt;code&gt;const int&lt;/code&gt;, and so is encoded as &lt;code&gt;^ri&lt;/code&gt;. &lt;code&gt;int* const&lt;/code&gt;, instead, is a &lt;code&gt;const&lt;/code&gt; pointer to an &lt;code&gt;int&lt;/code&gt;, and so is encoded as &lt;code&gt;r^i&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;const int*&lt;/code&gt; 是一个指向 &lt;code&gt;const int&lt;/code&gt; 的，所以被编码为 &lt;code&gt;^ri&lt;/code&gt; 。相反， &lt;code&gt;int* const&lt;/code&gt; 是指向 &lt;code&gt;int&lt;/code&gt; 的 &lt;code&gt;const&lt;/code&gt; 指针，因此被编码为 &lt;code&gt;r^i&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8cc303077f2d42536c4b3baafc5729fd35626b25" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;const&lt;/code&gt; arguments represent immediate operands in the underlying FR-V instructions. They must be compile-time constants.</source>
          <target state="translated">&lt;code&gt;const&lt;/code&gt; 参数表示基础FR-V指令中的立即操作数。它们必须是编译时常量。</target>
        </trans-unit>
        <trans-unit id="deb6088d1e3cb9956bb32715c4b9b0433c0fb80e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;decltype(nullptr)&lt;/code&gt; incorrectly had an alignment of 1, leading to unaligned accesses. Note that this did not affect the ABI of a function with a &lt;code&gt;nullptr_t&lt;/code&gt; parameter, as parameters have a minimum alignment.</source>
          <target state="translated">&lt;code&gt;decltype(nullptr)&lt;/code&gt; 的对齐方式错误地为1，导致未对齐的访问。请注意，这不会影响具有 &lt;code&gt;nullptr_t&lt;/code&gt; 参数的函数的ABI ，因为参数具有最小对齐方式。</target>
        </trans-unit>
        <trans-unit id="13371da4b8a0998cda9c846517eca9aac42602d3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;enum foo;&lt;/code&gt;, with details to follow.</source>
          <target state="translated">&lt;code&gt;enum foo;&lt;/code&gt; ，并附有详细信息。</target>
        </trans-unit>
        <trans-unit id="9e91e48e9653d7d4d932a05bfbd83b09588c7939" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;enum&lt;/code&gt;s are always encoded as &amp;rsquo;i&amp;rsquo; (int) even if they are actually unsigned or long.</source>
          <target state="translated">&lt;code&gt;enum&lt;/code&gt; s始终被编码为'i'（int），即使它们实际上是无符号的或很长的。</target>
        </trans-unit>
        <trans-unit id="9a12395e61d19efb5c294812d6196468603d44b6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;extern&lt;/code&gt; declarations are not affected by</source>
          <target state="translated">&lt;code&gt;extern&lt;/code&gt; 声明不受以下影响</target>
        </trans-unit>
        <trans-unit id="4b6de559d80875c4a2043040ec9b3a928c196dad" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;float&lt;/code&gt; for return type and parameter type</source>
          <target state="translated">&lt;code&gt;float&lt;/code&gt; 返回类型和参数类型的float</target>
        </trans-unit>
        <trans-unit id="43f52ce2765906e82519d10c80ebb890c471c9d3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;gcc&lt;/code&gt; is a driver program. It performs its job by invoking a sequence of other programs to do the work of compiling, assembling and linking. GCC interprets its command-line parameters and uses these to deduce which programs it should invoke, and which command-line options it ought to place on their command lines. This behavior is controlled by &lt;em&gt;spec strings&lt;/em&gt;. In most cases there is one spec string for each program that GCC can invoke, but a few programs have multiple spec strings to control their behavior. The spec strings built into GCC can be overridden by using the</source>
          <target state="translated">&lt;code&gt;gcc&lt;/code&gt; 是一个驱动程序。它通过调用一系列其他程序来完成其工作，以进行编译，组装和链接。GCC解释其命令行参数，并使用这些参数推断应调用的程序以及应在命令行上放置的命令行选项。此行为由&lt;em&gt;规范字符串&lt;/em&gt;控制。在大多数情况下，GCC可以为每个程序调用一个规范字符串，但是少数程序具有多个规范字符串来控制其行为。可以使用以下命令覆盖GCC内置的规范字符串</target>
        </trans-unit>
        <trans-unit id="78e0e9f2c419ee9f240f0845bc755717d55d3a97" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;gcov-dump&lt;/code&gt; accepts the following options:</source>
          <target state="translated">&lt;code&gt;gcov-dump&lt;/code&gt; 接受以下选项：</target>
        </trans-unit>
        <trans-unit id="57d6fe4b10a5a2126cbfcec6595777a79798d69e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;gcov-dump&lt;/code&gt; is a tool you can use in conjunction with GCC to dump content of gcda and gcno profile files offline.</source>
          <target state="translated">&lt;code&gt;gcov-dump&lt;/code&gt; 是可以与GCC结合使用的工具，可以离线转储gcda和gcno配置文件的内容。</target>
        </trans-unit>
        <trans-unit id="2878b99530b4f0ab8508c0886d2f8099475e075b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;gcov-dump&lt;/code&gt;&amp;mdash;an offline gcda and gcno profile dump tool.</source>
          <target state="translated">&lt;code&gt;gcov-dump&lt;/code&gt; -脱机gcda和gcno配置文件转储工具。</target>
        </trans-unit>
        <trans-unit id="8557e16ee11b3bb8a6161e3b196a98d4d9ef3676" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;gcov-tool&lt;/code&gt; accepts the following options:</source>
          <target state="translated">&lt;code&gt;gcov-tool&lt;/code&gt; 接受以下选项：</target>
        </trans-unit>
        <trans-unit id="834e3a72a863342de668198a9b180e31689bb9fa" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;gcov-tool&lt;/code&gt; is a tool you can use in conjunction with GCC to manipulate or process gcda profile files offline.</source>
          <target state="translated">&lt;code&gt;gcov-tool&lt;/code&gt; 是可以与GCC结合使用的工具，可以离线操作或处理gcda配置文件。</target>
        </trans-unit>
        <trans-unit id="8966e78c51b409536bc0ea171add9c067eaae6cb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;gcov-tool&lt;/code&gt; is an offline tool to process gcc&amp;rsquo;s gcda profile files.</source>
          <target state="translated">&lt;code&gt;gcov-tool&lt;/code&gt; 是一个离线工具，用于处理gcc的gcda配置文件。</target>
        </trans-unit>
        <trans-unit id="70183d08ebe3785a624a3a0d2f54f5da4fcf92c8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;gcov-tool&lt;/code&gt;&amp;mdash;an offline gcda profile processing program.</source>
          <target state="translated">&lt;code&gt;gcov-tool&lt;/code&gt; &amp;mdash;脱机gcda配置文件处理程序。</target>
        </trans-unit>
        <trans-unit id="432fd55f9f3348b69e564e9e68b9ac68338b2330" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;gcov&lt;/code&gt; accepts the following options:</source>
          <target state="translated">&lt;code&gt;gcov&lt;/code&gt; 接受以下选项：</target>
        </trans-unit>
        <trans-unit id="ef7fa5c92c81ba37950cfb7081e034b38df44ee1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;gcov&lt;/code&gt; creates a logfile called</source>
          <target state="translated">&lt;code&gt;gcov&lt;/code&gt; 创建一个名为</target>
        </trans-unit>
        <trans-unit id="fa86b3b9c4851aca0143ed5eebf12b37ac982caa" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;gcov&lt;/code&gt; is a test coverage program. Use it in concert with GCC to analyze your programs to help create more efficient, faster running code and to discover untested parts of your program. You can use &lt;code&gt;gcov&lt;/code&gt; as a profiling tool to help discover where your optimization efforts will best affect your code. You can also use &lt;code&gt;gcov&lt;/code&gt; along with the other profiling tool, &lt;code&gt;gprof&lt;/code&gt;, to assess which parts of your code use the greatest amount of computing time.</source>
          <target state="translated">&lt;code&gt;gcov&lt;/code&gt; 是一个测试覆盖程序。与GCC配合使用，可以分析您的程序，以帮助创建更高效​​，更快速的代码，并发现未经测试的程序部分。您可以将 &lt;code&gt;gcov&lt;/code&gt; 用作性能分析工具，以帮助发现优化工作最能影响代码的地方。您还可以将 &lt;code&gt;gcov&lt;/code&gt; 与其他分析工具 &lt;code&gt;gprof&lt;/code&gt; 一起使用，以评估代码的哪些部分使用了最多的计算时间。</target>
        </trans-unit>
        <trans-unit id="ec4c7d87db361b8b7217252e79155f330d87180c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;gcov&lt;/code&gt; is a tool you can use in conjunction with GCC to test code coverage in your programs.</source>
          <target state="translated">&lt;code&gt;gcov&lt;/code&gt; 是可以与GCC结合使用以测试程序中代码覆盖率的工具。</target>
        </trans-unit>
        <trans-unit id="74c1eaafeae6a0c3622569a9b97608b21c035122" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;gcov&lt;/code&gt; should be run with the current directory the same as that when you invoked the compiler. Otherwise it will not be able to locate the source files. &lt;code&gt;gcov&lt;/code&gt; produces files called</source>
          <target state="translated">&lt;code&gt;gcov&lt;/code&gt; 应该在当前目录下运行，与调用编译器时的目录相同。否则它将无法找到源文件。 &lt;code&gt;gcov&lt;/code&gt; 产生名为</target>
        </trans-unit>
        <trans-unit id="54f992c071dcdc4cf317b5dc2c2e8150dab3baed" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;gcov&lt;/code&gt; uses two files for profiling. The names of these files are derived from the original &lt;em&gt;object&lt;/em&gt; file by substituting the file suffix with either</source>
          <target state="translated">&lt;code&gt;gcov&lt;/code&gt; 使用两个文件进行概要分析。这些文件的名称从原始&lt;em&gt;目标&lt;/em&gt;文件派生而来，方法是将文件后缀替换为</target>
        </trans-unit>
        <trans-unit id="e0e281a8c455e080b9c9615f521b0af9f3afc81d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;gcov&lt;/code&gt; works only on code compiled with GCC. It is not compatible with any other profiling or test coverage mechanism.</source>
          <target state="translated">&lt;code&gt;gcov&lt;/code&gt; 仅适用于使用GCC编译的代码。它与任何其他配置文件或测试覆盖率机制不兼容。</target>
        </trans-unit>
        <trans-unit id="e18b2104276bf04773cc9483f7f381c6d995630f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;gcov&lt;/code&gt;&amp;mdash;a test coverage program.</source>
          <target state="translated">&lt;code&gt;gcov&lt;/code&gt; -测试覆盖率程序。</target>
        </trans-unit>
        <trans-unit id="0adbd472f7e4a6a8700ee625ca50b5065e7189f2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;i32, i64, u32, u64, f32, f64&lt;/code&gt;, defined as follows:</source>
          <target state="translated">&lt;code&gt;i32, i64, u32, u64, f32, f64&lt;/code&gt; ，定义如下：</target>
        </trans-unit>
        <trans-unit id="c651bda5c1e10d455f6b6c7f62a6f71255f9e521" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;iacc&lt;/code&gt; arguments are similar to &lt;code&gt;acc&lt;/code&gt; arguments but specify the number of an IACC register. See see &lt;a href=&quot;other-built_002din-functions#Other-Built_002din-Functions&quot;&gt;Other Built-in Functions&lt;/a&gt; for more details.</source>
          <target state="translated">&lt;code&gt;iacc&lt;/code&gt; 参数类似于 &lt;code&gt;acc&lt;/code&gt; 参数，但指定IACC寄存器的编号。有关更多详细信息，请参见&lt;a href=&quot;other-built_002din-functions#Other-Built_002din-Functions&quot;&gt;其他内置函数&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="bf79502e7b46209589262e2429120814cbb13c52" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;imm0_15&lt;/code&gt;, an integer literal in range 0 to 15;</source>
          <target state="translated">&lt;code&gt;imm0_15&lt;/code&gt; ，范围为0到15的整数文字；</target>
        </trans-unit>
        <trans-unit id="ccc2033cd80d019d5fd83cb192150729b7904cf6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;imm0_1&lt;/code&gt;, an integer literal in range 0 to 1;</source>
          <target state="translated">&lt;code&gt;imm0_1&lt;/code&gt; ，范围为0到1的整数。</target>
        </trans-unit>
        <trans-unit id="f624a59ec5d313a1c0a203fc5cdfd4a3666bdad5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;imm0_255&lt;/code&gt;, an integer literal in range 0 to 255;</source>
          <target state="translated">&lt;code&gt;imm0_255&lt;/code&gt; ，范围为0到255的整数。</target>
        </trans-unit>
        <trans-unit id="45c72131be83eef97ea9ee3eff2a0bdba7519f47" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;imm0_31&lt;/code&gt;, an integer literal in range 0 to 31;</source>
          <target state="translated">&lt;code&gt;imm0_31&lt;/code&gt; ，范围为0到31的整数。</target>
        </trans-unit>
        <trans-unit id="cde4836239d0583916a4b3f7436c408e99e7f181" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;imm0_3&lt;/code&gt;, an integer literal in range 0 to 3;</source>
          <target state="translated">&lt;code&gt;imm0_3&lt;/code&gt; ，范围为0到3的整数文字；</target>
        </trans-unit>
        <trans-unit id="51e823a1bbc6ba2a324f7474f9da47e3b2690272" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;imm0_63&lt;/code&gt;, an integer literal in range 0 to 63;</source>
          <target state="translated">&lt;code&gt;imm0_63&lt;/code&gt; ，范围为0到63的整数文字；</target>
        </trans-unit>
        <trans-unit id="62f6834f1b1628360d13102cd8355d1bff98dfb5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;imm0_7&lt;/code&gt;, an integer literal in range 0 to 7;</source>
          <target state="translated">&lt;code&gt;imm0_7&lt;/code&gt; ，范围为0到7的整数文字；</target>
        </trans-unit>
        <trans-unit id="06869e0d4af1794473183f20d27a91d5c322515b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;imm1_4&lt;/code&gt;, an integer literal in range 1 to 4;</source>
          <target state="translated">&lt;code&gt;imm1_4&lt;/code&gt; ，范围为1到4的整数。</target>
        </trans-unit>
        <trans-unit id="26b8f3ccab339df690ac564365568e69734e0e95" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;imm_n1024_1022&lt;/code&gt;, an integer literal in range -512 to 511 left shifted by 1 bit, i.e., -1024, -1022, &amp;hellip;, 1020, 1022;</source>
          <target state="translated">&lt;code&gt;imm_n1024_1022&lt;/code&gt; ，它是在-512到511之间左移1位的整数，即-1024，-1022，...，1020、1022；</target>
        </trans-unit>
        <trans-unit id="53f347dd23c9ce86f4bf63425a73319aeca2e71a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;imm_n16_15&lt;/code&gt;, an integer literal in range -16 to 15;</source>
          <target state="translated">&lt;code&gt;imm_n16_15&lt;/code&gt; ，介于-16到15之间的整数文字；</target>
        </trans-unit>
        <trans-unit id="c764a9f154679364bdd3af401c15760d950c39d4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;imm_n2048_2044&lt;/code&gt;, an integer literal in range -512 to 511 left shifted by 2 bits, i.e., -2048, -2044, &amp;hellip;, 2040, 2044;</source>
          <target state="translated">&lt;code&gt;imm_n2048_2044&lt;/code&gt; ，它是在-512到511之间左移2位的整数，即-2048，-2044，&amp;hellip;，2040、2044；</target>
        </trans-unit>
        <trans-unit id="d8621ae125b08b357812594db312fcdb8bd2e201" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;imm_n4096_4088&lt;/code&gt;, an integer literal in range -512 to 511 left shifted by 3 bits, i.e., -4096, -4088, &amp;hellip;, 4080, 4088;</source>
          <target state="translated">&lt;code&gt;imm_n4096_4088&lt;/code&gt; ，在-512至511范围内左移3位的整数，即-4096，-4088，&amp;hellip;，4080、4088；</target>
        </trans-unit>
        <trans-unit id="43bcd7d1a4a29ac9e7f1c73f1912ac48e5ce1624" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;imm_n512_511&lt;/code&gt;, an integer literal in range -512 to 511;</source>
          <target state="translated">&lt;code&gt;imm_n512_511&lt;/code&gt; ，介于-512到511之间的整数文字；</target>
        </trans-unit>
        <trans-unit id="f04c7ff5dca47e97ec5511198b36d3aa9615e32d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;int16x4_t&lt;/code&gt;, a vector of four signed 16-bit integers;</source>
          <target state="translated">&lt;code&gt;int16x4_t&lt;/code&gt; ，它是四个有符号的16位整数的向量；</target>
        </trans-unit>
        <trans-unit id="d63e9df03ecc48a8a23928c599b1004cd533f6d6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;int32x2_t&lt;/code&gt;, a vector of two signed 32-bit integers.</source>
          <target state="translated">&lt;code&gt;int32x2_t&lt;/code&gt; ，两个有符号的32位整数的向量。</target>
        </trans-unit>
        <trans-unit id="91184ef12147d2f6b1bdaa56fe5d9583a6f4e83a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;int8x8_t&lt;/code&gt;, a vector of eight signed 8-bit integers;</source>
          <target state="translated">&lt;code&gt;int8x8_t&lt;/code&gt; ，它是八个有符号的8位整数的向量；</target>
        </trans-unit>
        <trans-unit id="9a7265111af471ce530480c106de4c972fb277fa" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;int&lt;/code&gt; for return type and parameter type</source>
          <target state="translated">&lt;code&gt;int&lt;/code&gt; 返回类型和参数类型的int</target>
        </trans-unit>
        <trans-unit id="3e0d50378937884eeb028aecd3fcc684e4a49b74" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;j&lt;/code&gt; followed by the inner type. For example &lt;code&gt;_Complex double&lt;/code&gt; is encoded as &quot;jd&quot;.</source>
          <target state="translated">&lt;code&gt;j&lt;/code&gt; 后跟内部类型。例如， &lt;code&gt;_Complex double&lt;/code&gt; 被编码为&amp;ldquo; jd&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="0871af21d28c83f64c804091ade1492e9664c30b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lto-dump&lt;/code&gt; accepts the following options:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea8422e33957287d90215f0f4f8087a0305f1d44" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lto-dump&lt;/code&gt; is a tool you can use in conjunction with GCC to dump link time optimization object files.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a51997ac3a8fdd69732aefc35a59335c494052e0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lto-dump&lt;/code&gt;&amp;mdash;Tool for dumping LTO object files.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f711a37cb98098d461731b92b78a9d7c2b5ec6f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;movn.ps&lt;/code&gt;/&lt;code&gt;movz.ps&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;movn.ps&lt;/code&gt;/&lt;code&gt;movz.ps&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bb1626a9beed4fd0495f07220bec199cc6d6bd0a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;naked&lt;/code&gt; functions do not have a return instruction whereas &lt;code&gt;OS_main&lt;/code&gt; and &lt;code&gt;OS_task&lt;/code&gt; functions have a &lt;code&gt;RET&lt;/code&gt; or &lt;code&gt;RETI&lt;/code&gt; return instruction.</source>
          <target state="translated">&lt;code&gt;naked&lt;/code&gt; 函数没有返回指令，而 &lt;code&gt;OS_main&lt;/code&gt; 和 &lt;code&gt;OS_task&lt;/code&gt; 函数具有 &lt;code&gt;RET&lt;/code&gt; 或 &lt;code&gt;RETI&lt;/code&gt; 返回指令。</target>
        </trans-unit>
        <trans-unit id="f91f91e06fe6fe3ed6698c6a7170097cb9c11482" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;naked&lt;/code&gt; functions do not set up a frame for local variables or a frame pointer whereas &lt;code&gt;OS_main&lt;/code&gt; and &lt;code&gt;OS_task&lt;/code&gt; do this as needed.</source>
          <target state="translated">&lt;code&gt;naked&lt;/code&gt; 函数不会为局部变量或帧指针设置框架，而 &lt;code&gt;OS_main&lt;/code&gt; 和 &lt;code&gt;OS_task&lt;/code&gt; 会根据需要执行此操作。</target>
        </trans-unit>
        <trans-unit id="e1ec8966dbb2d024c34ce202400922786b20bf42" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;q31&lt;/code&gt; and &lt;code&gt;i32&lt;/code&gt; are actually the same as &lt;code&gt;int&lt;/code&gt;, but we use &lt;code&gt;q31&lt;/code&gt; to indicate a Q31 fractional value and &lt;code&gt;i32&lt;/code&gt; to indicate a 32-bit integer value. Similarly, &lt;code&gt;a64&lt;/code&gt; is the same as &lt;code&gt;long long&lt;/code&gt;, but we use &lt;code&gt;a64&lt;/code&gt; to indicate values that are placed in one of the four DSP accumulators (&lt;code&gt;$ac0&lt;/code&gt;, &lt;code&gt;$ac1&lt;/code&gt;, &lt;code&gt;$ac2&lt;/code&gt; or &lt;code&gt;$ac3&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;q31&lt;/code&gt; 和 &lt;code&gt;i32&lt;/code&gt; 实际上与 &lt;code&gt;int&lt;/code&gt; 相同，但是我们使用 &lt;code&gt;q31&lt;/code&gt; 表示Q31的分数值，使用 &lt;code&gt;i32&lt;/code&gt; 表示32位整数值。同样， &lt;code&gt;a64&lt;/code&gt; 与 &lt;code&gt;long long&lt;/code&gt; 相同，但是我们使用 &lt;code&gt;a64&lt;/code&gt; 表示放置在四个DSP累加器（ &lt;code&gt;$ac0&lt;/code&gt; ， &lt;code&gt;$ac1&lt;/code&gt; ， &lt;code&gt;$ac2&lt;/code&gt; 或 &lt;code&gt;$ac3&lt;/code&gt; ）之一中的值。</target>
        </trans-unit>
        <trans-unit id="ea0054c5fec474c155dbd98ae3adc8592ccc0ad9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;strict-align&lt;/code&gt; indicates that the compiler should not assume that unaligned memory references are handled by the system. To allow the compiler to assume that aligned memory references are handled by the system, the inverse attribute &lt;code&gt;no-strict-align&lt;/code&gt; can be specified. The behavior is same as for the command-line option</source>
          <target state="translated">&lt;code&gt;strict-align&lt;/code&gt; 表示编译器不应假定未对齐的内存引用由系统处理。为了允许编译器假定对齐的内存引用由系统处理，可以指定反向属性 &lt;code&gt;no-strict-align&lt;/code&gt; 。行为与命令行选项相同</target>
        </trans-unit>
        <trans-unit id="0ce41d50092061190708b7c5fd578471925d484e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;tbegin&lt;/code&gt; has been executed as part of normal processing. The transaction body is supposed to be executed.</source>
          <target state="translated">&lt;code&gt;tbegin&lt;/code&gt; 已作为常规处理的一部分执行。交易主体应该被执行。</target>
        </trans-unit>
        <trans-unit id="90a2359fdefeabe506da21e5ceeb1ec6dfb149dc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;type_info&lt;/code&gt; objects</source>
          <target state="translated">&lt;code&gt;type_info&lt;/code&gt; 对象</target>
        </trans-unit>
        <trans-unit id="972569711d57266ec65a8196096540c87f973793" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;typeof&lt;/code&gt; is often useful in conjunction with statement expressions (see &lt;a href=&quot;statement-exprs#Statement-Exprs&quot;&gt;Statement Exprs&lt;/a&gt;). Here is how the two together can be used to define a safe &amp;ldquo;maximum&amp;rdquo; macro which operates on any arithmetic type and evaluates each of its arguments exactly once:</source>
          <target state="translated">&lt;code&gt;typeof&lt;/code&gt; 通常与语句表达式结合使用（请参阅&lt;a href=&quot;statement-exprs#Statement-Exprs&quot;&gt;Statement Exprs&lt;/a&gt;）。这是将两者一起用于定义一个安全的&amp;ldquo;最大&amp;rdquo;宏的方法，该宏可在任何算术类型上运行，并且仅对每个参数进行一次赋值：</target>
        </trans-unit>
        <trans-unit id="01dc66305ee017274a8f90b9afb7de83e8f46c89" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;typeof&lt;/code&gt;: referring to the type of an expression.</source>
          <target state="translated">&lt;code&gt;typeof&lt;/code&gt; ：引用表达式的类型。</target>
        </trans-unit>
        <trans-unit id="8c7b90f2794ef9994bb660999c0f322a942bf8f4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;uint16x4_t&lt;/code&gt;, a vector of four unsigned 16-bit integers;</source>
          <target state="translated">&lt;code&gt;uint16x4_t&lt;/code&gt; ，它是四个无符号的16位整数的向量；</target>
        </trans-unit>
        <trans-unit id="b0558ac59824429cd7d9d4b1f36c21a2ee0fe3e7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;uint32x2_t&lt;/code&gt;, a vector of two unsigned 32-bit integers;</source>
          <target state="translated">&lt;code&gt;uint32x2_t&lt;/code&gt; ，两个无符号32位整数的向量；</target>
        </trans-unit>
        <trans-unit id="2d69c68962c47d62e79bf31389c4415c2f200ee4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;uint8x8_t&lt;/code&gt;, a vector of eight unsigned 8-bit integers;</source>
          <target state="translated">&lt;code&gt;uint8x8_t&lt;/code&gt; ，是八个无符号8位整数的向量；</target>
        </trans-unit>
        <trans-unit id="dbb644e8ba42f8f623407a24fa989ae31fed8572" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;union U&lt;/code&gt; is always passed in memory.</source>
          <target state="translated">&lt;code&gt;union U&lt;/code&gt; 总是在内存中传递。</target>
        </trans-unit>
        <trans-unit id="1db4672f93c338ff587750e17356ae256986573e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;union U&lt;/code&gt; is now always passed in memory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fadc8e6d5e8d31b3a291f79221d6f051c12b8821" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;v16i8&lt;/code&gt;, a vector of sixteen signed 8-bit integers;</source>
          <target state="translated">&lt;code&gt;v16i8&lt;/code&gt; ，它是十六个带符号的8位整数的向量；</target>
        </trans-unit>
        <trans-unit id="131a161af4f7e0b4ea5ae1747e0ea7514b0c83b0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;v16u8&lt;/code&gt;, a vector of sixteen unsigned 8-bit integers;</source>
          <target state="translated">&lt;code&gt;v16u8&lt;/code&gt; ，它是十六个无符号的8位整数的向量；</target>
        </trans-unit>
        <trans-unit id="1b29406a43f217bd305e13cb54ba71e651d5bba2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;v2f64&lt;/code&gt;, a vector of two 64-bit doubles.</source>
          <target state="translated">&lt;code&gt;v2f64&lt;/code&gt; ，两个64位double的向量。</target>
        </trans-unit>
        <trans-unit id="7512973093e5491713fd6ebd5358156e9bc4a1dc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;v2i64&lt;/code&gt;, a vector of two signed 64-bit integers;</source>
          <target state="translated">&lt;code&gt;v2i64&lt;/code&gt; ，两个带符号的64位整数的向量；</target>
        </trans-unit>
        <trans-unit id="9db6b88b33ec3aa8ad125c2d46beb5f476bec0d1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;v2sf&lt;/code&gt; values are initialized in the same way as aggregates. For example:</source>
          <target state="translated">&lt;code&gt;v2sf&lt;/code&gt; 值的初始化方式与聚合相同。例如：</target>
        </trans-unit>
        <trans-unit id="c3855d3df800b3ae2c45c123aa6cb8ce5e785ead" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;v2u64&lt;/code&gt;, a vector of two unsigned 64-bit integers;</source>
          <target state="translated">&lt;code&gt;v2u64&lt;/code&gt; ，两个无符号的64位整数的向量；</target>
        </trans-unit>
        <trans-unit id="6ad31881d9c216547f22d1f2a2db29238b4dc646" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;v4f32&lt;/code&gt;, a vector of four 32-bit floats;</source>
          <target state="translated">&lt;code&gt;v4f32&lt;/code&gt; ，它是四个32位浮点数的向量；</target>
        </trans-unit>
        <trans-unit id="31c7877922fb039b6c0292daf271e4981078508f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;v4i32&lt;/code&gt;, a vector of four signed 32-bit integers;</source>
          <target state="translated">&lt;code&gt;v4i32&lt;/code&gt; ，它是四个有符号的32位整数的向量；</target>
        </trans-unit>
        <trans-unit id="17a0ec2f60a3d3e13fba7b775b40060a5c47ab58" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;v4i8&lt;/code&gt;, &lt;code&gt;v4q7&lt;/code&gt;, &lt;code&gt;v2i16&lt;/code&gt; and &lt;code&gt;v2q15&lt;/code&gt; values are initialized in the same way as aggregates. For example:</source>
          <target state="translated">&lt;code&gt;v4i8&lt;/code&gt; ， &lt;code&gt;v4q7&lt;/code&gt; ， &lt;code&gt;v2i16&lt;/code&gt; 和 &lt;code&gt;v2q15&lt;/code&gt; 值的初始化方式与聚合相同。例如：</target>
        </trans-unit>
        <trans-unit id="6b9f0632a60f7e2199e33eae5df860d977b737c0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;v4u32&lt;/code&gt;, a vector of four unsigned 32-bit integers;</source>
          <target state="translated">&lt;code&gt;v4u32&lt;/code&gt; ，它是四个无符号32位整数的向量；</target>
        </trans-unit>
        <trans-unit id="15eeca02c95cac6ccf4d38d5e71572806fbe59c8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;v8i16&lt;/code&gt;, a vector of eight signed 16-bit integers;</source>
          <target state="translated">&lt;code&gt;v8i16&lt;/code&gt; ，它是八个有符号的16位整数的向量；</target>
        </trans-unit>
        <trans-unit id="18c14a5e3dac281031739c8daafc626ba35c9efb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;v8u16&lt;/code&gt;, a vector of eight unsigned 16-bit integers;</source>
          <target state="translated">&lt;code&gt;v8u16&lt;/code&gt; ，是八个无符号16位整数的向量；</target>
        </trans-unit>
        <trans-unit id="d6a4e5bb9ed4a03346a1e5335ca402c064f0fe3e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;void *&lt;/code&gt; for return type and parameter type</source>
          <target state="translated">&lt;code&gt;void *&lt;/code&gt; 用于返回类型和参数类型</target>
        </trans-unit>
        <trans-unit id="931138ba5a2507ee2e7e0fc42f85c661aad3ee17" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;void&lt;/code&gt; for return type and no parameter for parameter types.</source>
          <target state="translated">&lt;code&gt;void&lt;/code&gt; 返回类型为void，参数类型为无参数。</target>
        </trans-unit>
        <trans-unit id="5a5d5c4a2842d52363078341ffbf5ff1c71da9e6" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;AArch64 Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;AArch64选项&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6a14ea9b56847cb67e896fe9ed92e829c46db4c8" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;AMD GCN Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;AMD GCN选项&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="867c24fe4dbfd5ccbf6133610e3056cd4490ebb2" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;ARC Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;ARC选项&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a804dffc1734b11346a4329fb8b712484dc062a9" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;ARM Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;ARM选项&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="42007853e2d2e5ee57f43b159004f83209e6c120" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;AVR Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;AVR选项&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9aab5cdb90e0e7068aace684de244f8deb97788a" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Adapteva Epiphany Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Adapteva主显节选项&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="ae87c6342c250828b19327bd7929eed321e39d53" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Blackfin Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Blackfin选项&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="77196484bdd6bd4585004c0d69f5afd921d39aeb" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;C-SKY Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;C-SKY选项&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="be9ad0c2e9c89a60e3ec15f581550300b8820f0d" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;C6X Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;C6X选项&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="fd379f819a2900908cff60cb928d58f868b9db54" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;CR16 Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;CR16选项&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="cfc7c2eba72f3e5ff0469155a3c3406b2e006fe3" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;CRIS Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;CRIS选项&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="0bcedc624ee2d8bc0dc1dde9e3ffd94d702c3815" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;DEC Alpha Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;DEC Alpha选项&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="3c720ccb25061b11c148efb66e96f845b91fa6ad" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Darwin Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;达尔文期权&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="95f44dfbf82d62481da460c42b5fb7c35274dcea" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Errors&lt;/em&gt; report problems that make it impossible to compile your program. GCC reports errors with the source file name and line number where the problem is apparent.</source>
          <target state="translated">&lt;em&gt;错误&lt;/em&gt;报告了无法编译程序的问题。GCC报告出现问题的源文件名和行号错误。</target>
        </trans-unit>
        <trans-unit id="089e6e509d8caabf29e30ec3bbbe964fc2afe250" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;FR30 Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;FR30选项&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="091553d3f3e8974e90f05c57755746679c1fdd3a" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;FRV Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;FRV选项&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="70b7d6e356f2d0708ee860d4fc3fd1c61ab2eed5" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;FT32 Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;FT32选件&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="98ffc4ee3ad54f42a4735dcc174d96d9c6c59ac5" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;GNU/Linux Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;GNU / Linux选项&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="0822ea35a43e7bcfdcf9fd3e546d607438735455" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;H8/300 Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;H8 / 300选件&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="fdf83e6772f30030bb2fc1476c4b6aba2fad8a80" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;HPPA Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;HPPA选项&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d5c413dcc96c0d8d85ccbfd5c8edb509e5cdc1c4" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;IA-64 Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;IA-64选项&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="72b634d41b068d05c153c5acbd927a150eda46f1" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;LM32 Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;LM32选项&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e939059a018e2d2ed5fcec7a81d238219702f1a6" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;M32C Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;M32C选项&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="41423d489b98fe3519ae5cbb7b050e878b6bd6b0" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;M32R/D Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;M32R / D选项&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="3d6bc2eaf8866182e321b20849ed96413e122e84" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;M680x0 Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;M680x0选项&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="7869c6ee0bb9ef2d45291f35d9736bbbaaacc30a" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;MCore Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;MCore选项&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f92ee1798eb5d8b5d7a11c3903d764ec6e437af6" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;MIPS Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;MIPS选项&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6811edeb78aee90d2929700d84423144700748a5" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;MMIX Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;MMIX选项&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1c6c421dea99cc933fb54d01b9291e1f3cc15403" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;MN10300 Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;MN10300选项&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1ae829c80944d42f892c7e2fcafa7795e50814c5" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;MSP430 Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;MSP430选件&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="995202556b55cd172ec8bc628d585bb4f9d60357" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;MeP Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;MeP选项&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e6d8110270e3200546987d8ee1384e2734ad7589" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;MicroBlaze Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;MicroBlaze选项&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b56c00142a2adf77adfc3b717573e363224b9028" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Moxie Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Moxie选项&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="56ac1cd6a6c4ddc7383020e1168c9487d3c77648" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;NDS32 Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;NDS32选项&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="0489603a8178bb1a03c11b5a827e58b0d976d54d" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Nios II Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Nios II选项&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6a71b3dbe832df819e003067a1cc89679cd5065c" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note:&lt;/em&gt; Although the equivalent hardware instructions do not take an SIMD register as an operand, these builtins overwrite the relevant bits of the &lt;code&gt;__v8hi&lt;/code&gt; register provided as the first argument with the value loaded from the &lt;code&gt;[Ib, u8]&lt;/code&gt; location in the SDM.</source>
          <target state="translated">&lt;em&gt;注意：&lt;/em&gt;尽管等效的硬件指令不会将SIMD寄存器用作操作数，但是这些内置函数会使用从SDM中 &lt;code&gt;[Ib, u8]&lt;/code&gt; 位置加载的值覆盖作为第一个参数提供的 &lt;code&gt;__v8hi&lt;/code&gt; 寄存器的相关位。</target>
        </trans-unit>
        <trans-unit id="906695ffc11fbd6c29f6a7c5fffdd87c61dd0062" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note:&lt;/em&gt; GCC 4.4 and later implement &lt;code&gt;__sync_fetch_and_nand&lt;/code&gt; as &lt;code&gt;*ptr = ~(tmp &amp;amp; value)&lt;/code&gt; instead of &lt;code&gt;*ptr = ~tmp &amp;amp; value&lt;/code&gt;.</source>
          <target state="translated">&lt;em&gt;注意：&lt;/em&gt; GCC 4.4和更高版本将 &lt;code&gt;__sync_fetch_and_nand&lt;/code&gt; 实现为 &lt;code&gt;*ptr = ~(tmp &amp;amp; value)&lt;/code&gt; 而不是 &lt;code&gt;*ptr = ~tmp &amp;amp; value&lt;/code&gt; 〜tmp ＆value。</target>
        </trans-unit>
        <trans-unit id="32481d3d57648f7ac3b59915a8b343ab8f94362a" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note:&lt;/em&gt; GCC 4.4 and later implement &lt;code&gt;__sync_nand_and_fetch&lt;/code&gt; as &lt;code&gt;*ptr = ~(*ptr &amp;amp; value)&lt;/code&gt; instead of &lt;code&gt;*ptr = ~*ptr &amp;amp; value&lt;/code&gt;.</source>
          <target state="translated">&lt;em&gt;注意：&lt;/em&gt; GCC 4.4和更高版本将 &lt;code&gt;__sync_nand_and_fetch&lt;/code&gt; 实现为 &lt;code&gt;*ptr = ~(*ptr &amp;amp; value)&lt;/code&gt; 而不是 &lt;code&gt;*ptr = ~*ptr &amp;amp; value&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="aa1f3ae46628635e862095cde321a13674e15cd0" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note:&lt;/em&gt; If GCOV_PREFIX_STRIP is set without GCOV_PREFIX is undefined, then a relative path is made out of the hardwired absolute paths.</source>
          <target state="translated">&lt;em&gt;注意：&lt;/em&gt;如果在未定义GCOV_PREFIX的情况下设置了GCOV_PREFIX_STRIP，则将从硬连线的绝对路径中创建相对路径。</target>
        </trans-unit>
        <trans-unit id="ea491177a79dc64abd09c78a1e151400a239c1ba" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note:&lt;/em&gt; If a macro is actually used, but only used in skipped conditional blocks, then the preprocessor reports it as unused. To avoid the warning in such a case, you might improve the scope of the macro&amp;rsquo;s definition by, for example, moving it into the first skipped block. Alternatively, you could provide a dummy use with something like:</source>
          <target state="translated">&lt;em&gt;注意：&lt;/em&gt;如果实际使用了宏，但仅在跳过的条件块中使用了宏，则预处理器会将其报告为未使用。为了避免这种情况下的警告，您可以通过例如将宏移到第一个跳过的块中来改善宏定义的范围。或者，您可以提供类似以下内容的虚拟使用：</target>
        </trans-unit>
        <trans-unit id="513ca629c61e9f50ec1060bb038d882eda72087c" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note:&lt;/em&gt; If the chosen key method is later defined as inline, the vtable is still emitted in every translation unit that defines it. Make sure that any inline virtuals are declared inline in the class body, even if they are not defined there.</source>
          <target state="translated">&lt;em&gt;注意：&lt;/em&gt;如果以后将选定的key方法定义为内联，则在定义它的每个转换单元中仍会发出vtable。确保在类主体中将所有内联虚函数声明为内联，即使未在其中定义它们也是如此。</target>
        </trans-unit>
        <trans-unit id="5909e9b7c2f203286387e1708a17c1db3ad3cfd7" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note:&lt;/em&gt; Only the &lt;code&gt;&amp;lt;altivec.h&amp;gt;&lt;/code&gt; interface is supported. Internally, GCC uses built-in functions to achieve the functionality in the aforementioned header file, but they are not supported and are subject to change without notice.</source>
          <target state="translated">&lt;em&gt;注意：&lt;/em&gt;仅支持 &lt;code&gt;&amp;lt;altivec.h&amp;gt;&lt;/code&gt; 接口。在内部，GCC使用内置函数来实现上述头文件中的功能，但不支持它们，如有更改，恕不另行通知。</target>
        </trans-unit>
        <trans-unit id="2e7d99f36188d0a0ae9bd36f15a8de72013df3fb" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note:&lt;/em&gt; Only the interface described in the aforementioned specification is supported. Internally, GCC uses built-in functions to implement the required functionality, but these are not supported and are subject to change without notice.</source>
          <target state="translated">&lt;em&gt;注意：&lt;/em&gt;仅支持上述规范中描述的接口。在内部，GCC使用内置函数来实现所需的功能，但是不支持这些功能，如有更改，恕不另行通知。</target>
        </trans-unit>
        <trans-unit id="60f5a5be3206ed7a5edc1d0306252ee653ebb15f" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note:&lt;/em&gt; Q7, Q15 and Q31 values must be initialized with their integer representation. As shown in this example, the integer representation of a Q7 value can be obtained by multiplying the fractional value by &lt;code&gt;0x1.0p7&lt;/code&gt;. The equivalent for Q15 values is to multiply by &lt;code&gt;0x1.0p15&lt;/code&gt;. The equivalent for Q31 values is to multiply by &lt;code&gt;0x1.0p31&lt;/code&gt;.</source>
          <target state="translated">&lt;em&gt;注意：&lt;/em&gt; Q7，Q15和Q31值必须使用其整数表示形式进行初始化。如本示例所示，可以通过将分数值乘以 &lt;code&gt;0x1.0p7&lt;/code&gt; 来获得Q7值的整数表示。Q15值的等效值乘以 &lt;code&gt;0x1.0p15&lt;/code&gt; 。Q31值的等效值乘以 &lt;code&gt;0x1.0p31&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ecefd38e47b465f12582422275b6c1c7fc5ba3d0" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note:&lt;/em&gt; The 4.1, 4.2 and 4.3 series of GCC ignore the &lt;code&gt;packed&lt;/code&gt; attribute on bit-fields of type &lt;code&gt;char&lt;/code&gt;. This has been fixed in GCC 4.4 but the change can lead to differences in the structure layout. See the documentation of</source>
          <target state="translated">&lt;em&gt;注意：&lt;/em&gt; GCC的4.1、4.2和4.3系列会忽略 &lt;code&gt;char&lt;/code&gt; 类型的位字段上的 &lt;code&gt;packed&lt;/code&gt; 属性。此问题已在GCC 4.4中修复，但更改可能导致结构布局不同。请参阅的文档</target>
        </trans-unit>
        <trans-unit id="83a8626dc0b2f71c9d50349e2149ee36fab186fa" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note:&lt;/em&gt; The CPU&amp;rsquo;s endianness determines the order in which values are packed. On little-endian targets, the first value is the least significant and the last value is the most significant. The opposite order applies to big-endian targets. For example, the code above sets the lowest byte of &lt;code&gt;a&lt;/code&gt; to &lt;code&gt;1&lt;/code&gt; on little-endian targets and &lt;code&gt;4&lt;/code&gt; on big-endian targets.</source>
          <target state="translated">&lt;em&gt;注意：&lt;/em&gt; CPU的字节顺序决定了打包值的顺序。在小尾数目标上，第一个值的最低有效，而最后一个值的最高有效。相反的顺序适用于大端目标。例如，上面的代码在小端目标上将 &lt;code&gt;a&lt;/code&gt; 的最低字节设置为 &lt;code&gt;1&lt;/code&gt; ,在大端目标上将a的最低字节设置为 &lt;code&gt;4&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5b93697e5f9fd5103a0a7f14fc065355825c4168" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note:&lt;/em&gt; The CPU&amp;rsquo;s endianness determines which value is stored in the upper half of a register and which value is stored in the lower half. On little-endian targets, the first value is the lower one and the second value is the upper one. The opposite order applies to big-endian targets. For example, the code above sets the lower half of &lt;code&gt;a&lt;/code&gt; to &lt;code&gt;1.5&lt;/code&gt; on little-endian targets and &lt;code&gt;9.1&lt;/code&gt; on big-endian targets.</source>
          <target state="translated">&lt;em&gt;注意：&lt;/em&gt; CPU的字节序确定哪个值存储在寄存器的上半部分，哪个值存储在寄存器的下半部分。在小尾数目标上，第一个值是较低的值，第二个值是较高的值。相反的顺序适用于大端目标。例如，上面的代码在小端目标上将 &lt;code&gt;a&lt;/code&gt; 的下半部分设置为 &lt;code&gt;1.5&lt;/code&gt; ,在大端目标上将a的下半部分设置为 &lt;code&gt;9.1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b6f29631325fd85cd0fed1160021c6ec9cde3b5c" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note:&lt;/em&gt; The generic GCC command-line option</source>
          <target state="translated">&lt;em&gt;注意：&lt;/em&gt;通用GCC命令行选项</target>
        </trans-unit>
        <trans-unit id="ed06dff3e4ef6bf04ce2ce52a8b9fd81cb4cb441" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note:&lt;/em&gt; The value of the third parameter must be 0 or 4 modulo 8, otherwise the result is unpredictable. Please read the instruction description for details.</source>
          <target state="translated">&lt;em&gt;注意：&lt;/em&gt;第三个参数的值必须为0或4模8，否则结果将不可预测。有关详细信息，请阅读说明。</target>
        </trans-unit>
        <trans-unit id="72153d9d5813664a3177200e0649d766dc189c8b" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note:&lt;/em&gt; These &lt;code&gt;#pragma&lt;/code&gt;s have been superceded as of GCC 2.7.2 by COMDAT support and the &amp;ldquo;key method&amp;rdquo; heuristic mentioned in &lt;a href=&quot;vague-linkage#Vague-Linkage&quot;&gt;Vague Linkage&lt;/a&gt;. Using them can actually cause your program to grow due to unnecessary out-of-line copies of inline functions.</source>
          <target state="translated">&lt;em&gt;注意：&lt;/em&gt;从GCC 2.7.2开始，这些 &lt;code&gt;#pragma&lt;/code&gt; 已被COMDAT支持和&lt;a href=&quot;vague-linkage#Vague-Linkage&quot;&gt;Vague Linkage中&lt;/a&gt;提到的&amp;ldquo;关键方法&amp;rdquo;启发式方法所取代。使用它们实际上会由于不必要的内联函数的离线副本而导致程序增长。</target>
        </trans-unit>
        <trans-unit id="a7b139d88803f100cdd95a55602837bc153be904" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note:&lt;/em&gt; This builtin is only available for C. This builtin can be used to call Go closures from C.</source>
          <target state="translated">&lt;em&gt;注意：&lt;/em&gt;此内置函数仅适用于C。此内置函数可用于从C调用Go闭包。</target>
        </trans-unit>
        <trans-unit id="2d97839275dd23b736dcd3d659869aced8cae5cf" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note:&lt;/em&gt; This construct is only available for C.</source>
          <target state="translated">&lt;em&gt;注意：&lt;/em&gt;此构造仅适用于C。</target>
        </trans-unit>
        <trans-unit id="eacbc4a00a6df067f8f96e363a35fd76d48bed27" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note:&lt;/em&gt; This construct is only available for C. Furthermore, the unused expression (&lt;var&gt;exp1&lt;/var&gt; or &lt;var&gt;exp2&lt;/var&gt; depending on the value of &lt;var&gt;const_exp&lt;/var&gt;) may still generate syntax errors. This may change in future revisions.</source>
          <target state="translated">&lt;em&gt;注意：&lt;/em&gt;此构造仅可用于C。此外，未使用的表达式（ &lt;var&gt;exp1&lt;/var&gt; 或 &lt;var&gt;exp2&lt;/var&gt; 取决于 &lt;var&gt;const_exp&lt;/var&gt; 的值）可能仍会生成语法错误。这可能会在将来的版本中更改。</target>
        </trans-unit>
        <trans-unit id="5e7e557ba1661093fe7151e1bdc289cf424df86b" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note:&lt;/em&gt; Using a built-in to generate an instruction not supported by a target may cause problems. At present the compiler is not guaranteed to detect such misuse, and as a result an internal compiler error may be generated.</source>
          <target state="translated">&lt;em&gt;注意：&lt;/em&gt;使用内置函数生成目标不支持的指令可能会导致问题。当前，不能保证编译器会检测到这种滥用，结果可能会产生内部编译器错误。</target>
        </trans-unit>
        <trans-unit id="1a1eec5083716264a52a5668d0e808764085fd67" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note:&lt;/em&gt; When compiling a program using computed gotos, a GCC extension, you may get better run-time performance if you disable the global common subexpression elimination pass by adding</source>
          <target state="translated">&lt;em&gt;注意：&lt;/em&gt;当使用计算得到的goto（GCC扩展）编译程序时，如果通过添加以下内容来禁用全局通用子表达式消除过程，则可能会获得更好的运行时性能：</target>
        </trans-unit>
        <trans-unit id="c3ceb34dafdbbccb7b3f4a9bc3198076a8bb038d" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note:&lt;/em&gt; pseudo instruction represents, in this particular context, an abstract measurement of function&amp;rsquo;s size. In no way does it represent a count of assembly instructions and as such its exact meaning might change from one release to an another.</source>
          <target state="translated">&lt;em&gt;注意：&lt;/em&gt;在此特定上下文中，伪指令表示函数大小的抽象度量。它绝不代表汇编指令的数量，因此其确切含义可能会从一个发行版更改为另一个发行版。</target>
        </trans-unit>
        <trans-unit id="64cd29898900abd284b24ce0046a12f2a889805e" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note:&lt;/em&gt; there may be no value to</source>
          <target state="translated">&lt;em&gt;注意：&lt;/em&gt;可能没有任何价值</target>
        </trans-unit>
        <trans-unit id="34f20bbbcdb20cd93bc0b28a39e05bcb36620def" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note&lt;/em&gt; If the</source>
          <target state="translated">&lt;em&gt;注意&lt;/em&gt;如果</target>
        </trans-unit>
        <trans-unit id="cc501835fd0037936c2300c5863d1305c99d13dc" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Nvidia PTX Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Nvidia PTX选项&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="7857f3cff032f30c80ecfb8270b8c04e4e9d6efc" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;OpenRISC Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;OpenRISC选项&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="022f17d65bf2f852a9bf52143c3cab7582dddc12" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;PDP-11 Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;PDP-11选件&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="bc7124a8b758cba8598057dd8d025c193f4f022a" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;PRU Options&lt;/em&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc36ba8a70957c05f0128aeed8b3ffa01e74a202" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;PowerPC Options&lt;/em&gt; See RS/6000 and PowerPC Options.</source>
          <target state="translated">&lt;em&gt;PowerPC选项&lt;/em&gt;请参阅RS / 6000和PowerPC选项。</target>
        </trans-unit>
        <trans-unit id="7d12212e9493501d271a126a834619cd825cc637" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;RISC-V Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;RISC-V选项&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="51deeb74b7040696523eac8e9b50aaa9f0c160b2" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;RL78 Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;RL78选项&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e0525fb0f4921d4b454f0867178cc3f2e709dd05" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;RS/6000 and PowerPC Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;RS / 6000和PowerPC选件&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="39cbc4dfd74b5b6e0fa9efd8a12d1162bb681080" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;RX Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;接收选项&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="736a44f00f2782082aa29882ffc21518d1f4a4e8" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;S/390 and zSeries Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;S / 390和zSeries选项&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="41e4a234f5bb49cd0264fa22972792fc9da3bcbf" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;SH Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;SH选项&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="56bc7167620d3c71b9cb584d08f274377f44bf2a" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;SPARC Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;SPARC选项&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="dc670533970668fe64148e47e0fafdaea94cb03b" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;SPU Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;SPU选项&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c56413d87d2da9557912d35dbc2cfbca82836384" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Score Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;分数选项&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="62b914fb373470c0b2ac9d74fa9f6fe2b909d5de" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Solaris 2 Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Solaris 2选项&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d42fb76fd4341ca34cfd6fb2f6c0a0d677895a40" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Spec files&lt;/em&gt; are plain-text files that are used to construct spec strings. They consist of a sequence of directives separated by blank lines. The type of directive is determined by the first non-whitespace character on the line, which can be one of the following:</source>
          <target state="translated">&lt;em&gt;规格文件&lt;/em&gt;是用于构造规格字符串的纯文本文件。它们由用空行分隔的一系列指令组成。指令的类型由该行上的第一个非空白字符决定，该字符可以是下列之一：</target>
        </trans-unit>
        <trans-unit id="db99a02bf9325a0446b3d3660f54ae1be166577f" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Spec strings&lt;/em&gt; are a list of command-line options to be passed to their corresponding program. In addition, the spec strings can contain &amp;lsquo;</source>
          <target state="translated">&lt;em&gt;规范字符串&lt;/em&gt;是要传递到其相应程序的命令行选项的列表。此外，规范字符串可以包含&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="5a15016eaf2ae61e798c9e92b569358a39e86710" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;System V Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;系统V选项&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="feb127030e9fe13464eefbb656da5c5e59f1ec48" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;TILE-Gx Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;TILE-Gx选项&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e6e6e9084306dd7d17aba875acb7fea1ed46ce39" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;TILEPro Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;TILEPro选项&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1e1e262e710aa664259e0fd18b86e9454a54d4a6" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;V850 Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;V850选件&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="fc271d88c785f840f6cf51c476df618f74b1cbef" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;VAX Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;VAX选项&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e143e075ae3bdac97703feadb897d0df26906759" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;VMS Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;VMS选项&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d28ef093233a29030bf54382ba024a105f45890e" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Visium Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Visium选项&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="fe1a73e1bcb98976a3dfe16f3ba0939cee97b5b0" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;VxWorks Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;VxWorks选项&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a7aee4d537121bb2f423daebb8bdece70ad36a69" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Warning:&lt;/em&gt; In the above example, be aware that a register (for example &lt;code&gt;r0&lt;/code&gt;) can be call-clobbered by subsequent code, including function calls and library calls for arithmetic operators on other variables (for example the initialization of &lt;code&gt;p2&lt;/code&gt;). In this case, use temporary variables for expressions between the register assignments:</source>
          <target state="translated">&lt;em&gt;警告：&lt;/em&gt;在上面的示例中，请注意，后续代码可以调用寄存器（例如 &lt;code&gt;r0&lt;/code&gt; ），包括后续的代码，包括函数调用和其他变量上算术运算符的库调用（例如 &lt;code&gt;p2&lt;/code&gt; 的初始化）。在这种情况下，对寄存器分配之间的表达式使用临时变量：</target>
        </trans-unit>
        <trans-unit id="816a932da8e0bd79bd86e31e2bb7d68625f97793" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Warnings&lt;/em&gt; report other unusual conditions in your code that &lt;em&gt;may&lt;/em&gt; indicate a problem, although compilation can (and does) proceed. Warning messages also report the source file name and line number, but include the text &amp;lsquo;</source>
          <target state="translated">&lt;em&gt;警告会&lt;/em&gt;报告您代码中的其他异常情况，这些异常情况&lt;em&gt;可能&lt;/em&gt;表明存在问题，尽管可以（并且确实）进行编译。警告消息还会报告源文件名和行号，但包括文本&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="4b143c44f6aab624c938e93ad2f6b4f657e59153" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Xstormy16 Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Xstormy16选项&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="18ac74c0cb677176c306ff128a293af591f367d3" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Xtensa Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Xtensa选项&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="135f91287a5ce57a17a4eafa0bb5f1e2e6a72df9" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;eBPF Options&lt;/em&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95e5f6791684d95443cdbb8fd6680f023a74362e" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;picoChip Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;picoChip选项&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a2dbd6047aac87327270d92252817d5d79e582ce" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;x86 Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;x86选项&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2372ad60b474adcacc8813df7ea55f14799cf6b4" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;x86 Windows Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;x86 Windows选项&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="636b6c51fd4e87f012cdd524f840607ddf80c3c5" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;zSeries Options&lt;/em&gt; See S/390 and zSeries Options.</source>
          <target state="translated">&lt;em&gt;zSeries选项&lt;/em&gt;请参阅S / 390和zSeries选项。</target>
        </trans-unit>
        <trans-unit id="05b073d8b145e3b7b4fe9382c836fb5ca8365004" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&amp;lsquo;&lt;samp&gt;-mcpu&lt;/samp&gt;&amp;rsquo; arguments&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;'&lt;samp&gt;-mcpu&lt;/samp&gt;的论点&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0ca73c3cb15b2a6924f0a26af33432a71a16d184" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Be careful:&lt;/strong&gt; Write spaces around the &lt;code&gt;...&lt;/code&gt;, for otherwise it may be parsed wrong when you use it with integer values. For example, write this:</source>
          <target state="translated">&lt;strong&gt;注意：&lt;/strong&gt;在 &lt;code&gt;...&lt;/code&gt; 周围写空格，否则在将其与整数值一起使用时可能会被解析为错误。例如，编写以下代码：</target>
        </trans-unit>
        <trans-unit id="5b296bb4d7e000ba38a77aa5d36e6fe239ea357d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Family&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Family&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1ce6e314b705bb119112642204e6ae779116bafe" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; Do &lt;em&gt;not&lt;/em&gt; modify the contents of input-only operands (except for inputs tied to outputs). The compiler assumes that on exit from the &lt;code&gt;asm&lt;/code&gt; statement these operands contain the same values as they had before executing the statement. It is &lt;em&gt;not&lt;/em&gt; possible to use clobbers to inform the compiler that the values in these inputs are changing. One common work-around is to tie the changing input variable to an output variable that never gets used. Note, however, that if the code that follows the &lt;code&gt;asm&lt;/code&gt; statement makes no use of any of the output operands, the GCC optimizers may discard the &lt;code&gt;asm&lt;/code&gt; statement as unneeded (see &lt;a href=&quot;#Volatile&quot;&gt;Volatile&lt;/a&gt;).</source>
          <target state="translated">&lt;strong&gt;警告：&lt;/strong&gt;待办事项&lt;em&gt;不&lt;/em&gt;修改仅输入操作数的内容（除了输入绑输出）。编译器假定从 &lt;code&gt;asm&lt;/code&gt; 语句退出时，这些操作数包含的值与执行该语句之前的值相同。这是&lt;em&gt;不是&lt;/em&gt;可以使用则会覆盖通知，在这些输入的值就会改变编译器。一种常见的解决方法是将变化的输入变量与永远不会使用的输出变量联系起来。但是请注意，如果 &lt;code&gt;asm&lt;/code&gt; 语句后的代码不使用任何输出操作数，则GCC优化器可能会丢弃 &lt;code&gt;asm&lt;/code&gt; 语句为不必要的内容（请参见&lt;a href=&quot;#Volatile&quot;&gt;Volatile&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="a41c6abd653a33317410ef0db731418bdf245365" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; If you use this switch, then you must build all modules with the same value, including any libraries. This includes the system libraries and startup modules.</source>
          <target state="translated">&lt;strong&gt;警告：&lt;/strong&gt;如果使用此开关，则必须使用相同的值构建所有模块，包括任何库。这包括系统库和启动模块。</target>
        </trans-unit>
        <trans-unit id="9f8a7fec506fe7c2f6084ea58dbd6ac51571b5ae" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; Since RAX register is used to avoid unnecessarily saving vector registers on stack when passing variable arguments, the impacts of this option are callees may waste some stack space, misbehave or jump to a random location. GCC 4.4 or newer don&amp;rsquo;t have those issues, regardless the RAX register value.</source>
          <target state="translated">&lt;strong&gt;警告：&lt;/strong&gt;由于使用RAX寄存器来避免在传递变量参数时将向量寄存器不必要地保存在堆栈上，因此此选项的影响是被调用方可能会浪费一些堆栈空间，行为不当或跳转到随机位置。无论RAX寄存器的值如何，GCC 4.4或更高版本都不会出现这些问题。</target>
        </trans-unit>
        <trans-unit id="715534c76b05f27a336cac5eca1f15bb1ba0531b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; The</source>
          <target state="translated">&lt;strong&gt;警告：&lt;/strong&gt;本</target>
        </trans-unit>
        <trans-unit id="e163e3f64318185967d993e343b277921267102a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; The C standards do not specify semantics for &lt;code&gt;asm&lt;/code&gt;, making it a potential source of incompatibilities between compilers. These incompatibilities may not produce compiler warnings/errors.</source>
          <target state="translated">&lt;strong&gt;警告：&lt;/strong&gt; C标准没有为 &lt;code&gt;asm&lt;/code&gt; 指定语义，这使其成为编译器之间不兼容的潜在来源。这些不兼容性可能不会产生编译器警告/错误。</target>
        </trans-unit>
        <trans-unit id="e86cc1401a696068f7f847fa2efe8d1c2b4f1d91" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; When an application does not properly join all threads (or creates an detached thread), a profile file can be still corrupted.</source>
          <target state="translated">&lt;strong&gt;警告：&lt;/strong&gt;如果应用程序未正确加入所有线程（或创建了分离的线程），则配置文件仍可能损坏。</target>
        </trans-unit>
        <trans-unit id="edb6152c62df55204f513a2bd268c824cd742794" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; When generating code for the x86-64 architecture with SSE extensions disabled,</source>
          <target state="translated">&lt;strong&gt;警告：&lt;/strong&gt;当为禁用了SSE扩展的x86-64体系结构生成代码时，</target>
        </trans-unit>
        <trans-unit id="6d3e02f67e0426840cf2eab0fa386a7a0d8f3f4f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; code compiled with the</source>
          <target state="translated">&lt;strong&gt;警告：&lt;/strong&gt;使用</target>
        </trans-unit>
        <trans-unit id="81d77d1a721cb0e9d979c46fa00adb7925430d90" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; if you override the default value for your target ABI, this changes the size of structures and arrays containing &lt;code&gt;long double&lt;/code&gt; variables, as well as modifying the function calling convention for functions taking &lt;code&gt;long double&lt;/code&gt;. Hence they are not binary-compatible with code compiled without that switch.</source>
          <target state="translated">&lt;strong&gt;警告：&lt;/strong&gt;如果您覆盖目标ABI的默认值，则将更改包含 &lt;code&gt;long double&lt;/code&gt; 变量的结构和数组的大小，并修改采用 &lt;code&gt;long double&lt;/code&gt; 的函数的函数调用约定。因此，它们与没有该开关的编译代码不二进制兼容。</target>
        </trans-unit>
        <trans-unit id="6aef184d39f03952d172b7102530bc7a9cb2fa3c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; if you use the</source>
          <target state="translated">&lt;strong&gt;警告：&lt;/strong&gt;如果您使用</target>
        </trans-unit>
        <trans-unit id="b85ec1ce84c8439a9545fb2c1d7bf94b735aa0a2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; if you use this switch then you must build all modules with the same value, including any libraries. This includes the system libraries and startup modules.</source>
          <target state="translated">&lt;strong&gt;警告：&lt;/strong&gt;如果使用此开关，则必须使用相同的值（包括所有库）构建所有模块。这包括系统库和启动模块。</target>
        </trans-unit>
        <trans-unit id="6580347fe9571154d0b4891b1664cd9202c2acd8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; if you use this switch, and &lt;var&gt;num&lt;/var&gt; is nonzero, then you must build all modules with the same value, including any libraries. This includes the system libraries and startup modules.</source>
          <target state="translated">&lt;strong&gt;警告：&lt;/strong&gt;如果使用此开关，并且 &lt;var&gt;num&lt;/var&gt; 不为零，则必须使用相同的值（包括任何库）构建所有模块。这包括系统库和启动模块。</target>
        </trans-unit>
        <trans-unit id="f2fa2d1c77dc6f956448ba7d671e1de6cedbcd38" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; the</source>
          <target state="translated">&lt;strong&gt;警告：&lt;/strong&gt;在</target>
        </trans-unit>
        <trans-unit id="88c4d51d8f615f3993e3c0cef840662cb24bb857" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; the requisite libraries are not part of GCC. Normally the facilities of the machine&amp;rsquo;s usual C compiler are used, but this cannot be done directly in cross-compilation. You must make your own arrangements to provide suitable library functions for cross-compilation.</source>
          <target state="translated">&lt;strong&gt;警告：&lt;/strong&gt;必需的库不是GCC的一部分。通常使用机器常用的C编译器的功能，但是不能直接在交叉编译中完成。您必须自行安排以提供合适的库函数以进行交叉编译。</target>
        </trans-unit>
        <trans-unit id="776b38edee53ccd0d1e652426154a9a588a26326" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; this calling convention is incompatible with the one normally used on Unix, so you cannot use it if you need to call libraries compiled with the Unix compiler.</source>
          <target state="translated">&lt;strong&gt;警告：&lt;/strong&gt;此调用约定与Unix上通常使用的约定不兼容，因此，如果需要调用使用Unix编译器编译的库，则不能使用它。</target>
        </trans-unit>
        <trans-unit id="8633eef0a9b0178977134e42efd5a0068c9de00b" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;KIND&lt;/var&gt; is &amp;lsquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="136834bf622d717ffa74c10318ba5a8ccd251af2" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;WHEN&lt;/var&gt; is &amp;lsquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14be2a02710f49b8ea2b62d8e69b1cad01176b7f" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;arch&lt;/var&gt; value</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c92b0834b3f6e0b0e166db87ccbdb672bb82648" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;auxname&lt;/var&gt;.gcda</source>
          <target state="translated">&lt;var&gt;auxname&lt;/var&gt;.gcda</target>
        </trans-unit>
        <trans-unit id="9e19d8b5ca485e7de26e8b332e442d8fc54664ea" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;auxname&lt;/var&gt;.gcno</source>
          <target state="translated">&lt;var&gt;auxname&lt;/var&gt;.gcno</target>
        </trans-unit>
        <trans-unit id="85165da2ca5194c5347e3eeeb486f7fe2449eb31" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;b&lt;/var&gt;fx</source>
          <target state="translated">&lt;var&gt;b&lt;/var&gt;fx</target>
        </trans-unit>
        <trans-unit id="e61d261ac414ee0ceb16d824496fad9b5acddd85" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;blocks&lt;/var&gt;: number of blocks that are in the function</source>
          <target state="translated">&lt;var&gt;blocks&lt;/var&gt; ：函数中的块数</target>
        </trans-unit>
        <trans-unit id="8ae8f4fb9cf1118a0551f86c7142bd0ff6bc1464" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;blocks_executed&lt;/var&gt;: number of executed blocks of the function</source>
          <target state="translated">&lt;var&gt;blocks_executed&lt;/var&gt; ：函数已执行的块数</target>
        </trans-unit>
        <trans-unit id="b33636a0ba563901664b6c5f838dee23ec7b7447" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;byte-size&lt;/var&gt; works, but with variable-length arrays.</source>
          <target state="translated">&lt;var&gt;byte-size&lt;/var&gt; 有效，但具有可变长度数组。</target>
        </trans-unit>
        <trans-unit id="3908fe32fbee17ab1091dcbbbcc9d95e8c868d21" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;count&lt;/var&gt;: number of executions of the branch</source>
          <target state="translated">&lt;var&gt;count&lt;/var&gt; ：分支的执行次数</target>
        </trans-unit>
        <trans-unit id="a5a5b0ddbf193f53659eab4ecc8e6518b23dc55a" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;count&lt;/var&gt;: number of executions of the line</source>
          <target state="translated">&lt;var&gt;count&lt;/var&gt; ：该行的执行次数</target>
        </trans-unit>
        <trans-unit id="6dc66d5a71e8f3349f4206d52eb3738739a10355" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;current_working_directory&lt;/var&gt;: working directory where a compilation unit was compiled</source>
          <target state="translated">&lt;var&gt;current_working_directory&lt;/var&gt; ：编译编译单元的工作目录</target>
        </trans-unit>
        <trans-unit id="f2f093923378c09906b260d4e4fef642e8bd4c9b" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;data_file&lt;/var&gt;: name of the data file (GCDA)</source>
          <target state="translated">&lt;var&gt;data_file&lt;/var&gt; ：数据文件的名称（GCDA）</target>
        </trans-unit>
        <trans-unit id="82a3c99596c0803b3cd5b5dc5b7d4f7edcb29691" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;demangled_name&lt;/var&gt;: demangled name of the function</source>
          <target state="translated">&lt;var&gt;demangled_name&lt;/var&gt; ：函数的已取消名称</target>
        </trans-unit>
        <trans-unit id="96756339f8a07464a095163d86ae17ba49c6f2b0" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;dir&lt;/var&gt;/&lt;var&gt;suffix&lt;/var&gt;/usr/include</source>
          <target state="translated">&lt;var&gt;dir&lt;/var&gt;/&lt;var&gt;suffix&lt;/var&gt;/usr/include</target>
        </trans-unit>
        <trans-unit id="457fd18521fb5ee2775888f964e4ddd50de83968" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;dir&lt;/var&gt;/usr/include</source>
          <target state="translated">&lt;var&gt;dir&lt;/var&gt;/usr/include</target>
        </trans-unit>
        <trans-unit id="a2f5c6f857a964db0e9209dc3bc8af9204a69687" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;dir&lt;/var&gt;/usr/lib</source>
          <target state="translated">&lt;var&gt;dir&lt;/var&gt;/usr/lib</target>
        </trans-unit>
        <trans-unit id="710f2aaaa57ae08947b2914f307083f5ba6ecc46" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;end_column&lt;/var&gt;: column in the source file where the function ends</source>
          <target state="translated">&lt;var&gt;end_column&lt;/var&gt; ：函数结束的源文件中的列</target>
        </trans-unit>
        <trans-unit id="77d6abb0099a7849ef1e3e17b19f0755409a5b5e" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;end_line&lt;/var&gt;: line in the source file where the function ends</source>
          <target state="translated">&lt;var&gt;end_line&lt;/var&gt; ：源文件中函数结束的行</target>
        </trans-unit>
        <trans-unit id="bcfb310dcf9e58743c432d6bf3a973817fa1a1e5" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;execution_count&lt;/var&gt;: number of executions of the function</source>
          <target state="translated">&lt;var&gt;execution_count&lt;/var&gt; ：函数的执行次数</target>
        </trans-unit>
        <trans-unit id="07ced02e11442bdc9f19c2804e52ff736e36f64b" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;fallthrough&lt;/var&gt;: true when the branch is a fall through branch</source>
          <target state="translated">&lt;var&gt;fallthrough&lt;/var&gt; ：当分支是直通分支时为true</target>
        </trans-unit>
        <trans-unit id="cb068146736527c3f97548042cc209e45a84344b" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;fieldname&lt;/var&gt;:</source>
          <target state="translated">&lt;var&gt;fieldname&lt;/var&gt;:</target>
        </trans-unit>
        <trans-unit id="bc0ca9277beb7ce53874c5a6ea975087cabd0480" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;file&lt;/var&gt;.&lt;var&gt;passid&lt;/var&gt;.&lt;var&gt;pass&lt;/var&gt;.dot</source>
          <target state="translated">&lt;var&gt;file&lt;/var&gt;.&lt;var&gt;passid&lt;/var&gt;.&lt;var&gt;pass&lt;/var&gt;.dot</target>
        </trans-unit>
        <trans-unit id="185fc61cbdabdd77db10b2b0b60581412f88344f" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;file&lt;/var&gt;.analyzer.txt</source>
          <target state="translated">&lt;var&gt;file&lt;/var&gt;.analyzer.txt</target>
        </trans-unit>
        <trans-unit id="355dc9a2a93abc7e552de9fc5978fd259683b69a" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;file&lt;/var&gt;.callgraph.dot</source>
          <target state="translated">&lt;var&gt;file&lt;/var&gt;.callgraph.dot</target>
        </trans-unit>
        <trans-unit id="aa2d0b0a626af00705d11416adb8472a02b85335" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;file&lt;/var&gt;.eg-&lt;var&gt;id&lt;/var&gt;.txt</source>
          <target state="translated">&lt;var&gt;file&lt;/var&gt;.eg-&lt;var&gt;id&lt;/var&gt;.txt</target>
        </trans-unit>
        <trans-unit id="d51037b1808ab0ab68cf2854624577a0a2363a83" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;file&lt;/var&gt;.eg.dot</source>
          <target state="translated">&lt;var&gt;file&lt;/var&gt;.eg.dot</target>
        </trans-unit>
        <trans-unit id="e8c4ee87a95529e92014956c101d08d19626272a" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;file&lt;/var&gt;.eg.txt</source>
          <target state="translated">&lt;var&gt;file&lt;/var&gt;.eg.txt</target>
        </trans-unit>
        <trans-unit id="434eff9a292fff30f74330fc896652b1272e4265" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;file&lt;/var&gt;.state-purge.dot</source>
          <target state="translated">&lt;var&gt;file&lt;/var&gt;.state-purge.dot</target>
        </trans-unit>
        <trans-unit id="e948a9213200b3530a25cdb5e96fc8a614d0ac69" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;file&lt;/var&gt;.supergraph-eg.dot</source>
          <target state="translated">&lt;var&gt;file&lt;/var&gt;.supergraph-eg.dot</target>
        </trans-unit>
        <trans-unit id="36dd403968851ab1e3b90f91ed5b921efca47df1" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;file&lt;/var&gt;.supergraph.dot</source>
          <target state="translated">&lt;var&gt;file&lt;/var&gt;.supergraph.dot</target>
        </trans-unit>
        <trans-unit id="e36ec986d0d68718176ac505f37684283543d3d9" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;file&lt;/var&gt;&lt;var&gt;target&lt;/var&gt;</source>
          <target state="translated">&lt;var&gt;file&lt;/var&gt;&lt;var&gt;target&lt;/var&gt;</target>
        </trans-unit>
        <trans-unit id="8ec94309621d2424e899ea1b78e55daad7870d18" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;file_name&lt;/var&gt;: name of the source file</source>
          <target state="translated">&lt;var&gt;file_name&lt;/var&gt; ：源文件的名称</target>
        </trans-unit>
        <trans-unit id="cd6f65bdf191a64aaefc5c263459a6f075adc163" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;foo&lt;/var&gt; automatically implies</source>
          <target state="translated">&lt;var&gt;foo&lt;/var&gt; 自动暗示</target>
        </trans-unit>
        <trans-unit id="70afe026807a5e12e476985ab37efbc5dc26d077" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;foo&lt;/var&gt; does not imply anything.</source>
          <target state="translated">&lt;var&gt;foo&lt;/var&gt; 并不表示任何内容。</target>
        </trans-unit>
        <trans-unit id="46fba837f5408f9512a6c400d555a520081bdffd" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;foo&lt;/var&gt;. However,</source>
          <target state="translated">&lt;var&gt;foo&lt;/var&gt; 。然而，</target>
        </trans-unit>
        <trans-unit id="705042d186415d378755a17325dbc0219d4372f1" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;format_version&lt;/var&gt;: semantic version of the format</source>
          <target state="translated">&lt;var&gt;format_version&lt;/var&gt; ：格式的语义版本</target>
        </trans-unit>
        <trans-unit id="58bfbaccb373a1af2e15a00fe6b5acf8e46f5efd" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;function_name&lt;/var&gt;: a name of a function this &lt;var&gt;line&lt;/var&gt; belongs to (for a line with an inlined statements can be not set)</source>
          <target state="translated">&lt;var&gt;function_name&lt;/var&gt; ：此 &lt;var&gt;line&lt;/var&gt; 所属的函数的名称（因为不能设置带有内联语句的行）</target>
        </trans-unit>
        <trans-unit id="7150cb8c780083943181393bffe3746be197596d" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;gcc_version&lt;/var&gt;: version of the GCC compiler</source>
          <target state="translated">&lt;var&gt;gcc_version&lt;/var&gt; ：GCC编译器的版本</target>
        </trans-unit>
        <trans-unit id="ae44b540bd27d10c4dc7e21db41478a671658ee6" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;kind&lt;/var&gt; is &amp;lsquo;</source>
          <target state="translated">&lt;var&gt;kind&lt;/var&gt; 是</target>
        </trans-unit>
        <trans-unit id="8b8203cf510dcd89888a7c10446ebe87c2f89369" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;libexecdir&lt;/var&gt;/gcc/&lt;var&gt;target&lt;/var&gt;/&lt;var&gt;version&lt;/var&gt;/install-tools/</source>
          <target state="translated">&lt;var&gt;libexecdir&lt;/var&gt;/gcc/&lt;var&gt;target&lt;/var&gt;/&lt;var&gt;version&lt;/var&gt;/install-tools/</target>
        </trans-unit>
        <trans-unit id="7e28a7ea5e6f3cd24974425a7e272dd6dab22c97" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;line_number&lt;/var&gt;: line number</source>
          <target state="translated">&lt;var&gt;line_number&lt;/var&gt; ：行号</target>
        </trans-unit>
        <trans-unit id="ea29079cba4e83858223a5ec28bdc6d50bd316b0" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;machine&lt;/var&gt;/&lt;var&gt;version&lt;/var&gt;/</source>
          <target state="translated">&lt;var&gt;machine&lt;/var&gt;/&lt;var&gt;version&lt;/var&gt;/</target>
        </trans-unit>
        <trans-unit id="fb87e55fd40c286be395999f14a4dc6d95b10b8e" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;mangledname&lt;/var&gt;.gcov</source>
          <target state="translated">&lt;var&gt;mangledname&lt;/var&gt;.gcov</target>
        </trans-unit>
        <trans-unit id="f0ce3ea44130cbe877829294966ed36eef7f62f7" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;mode&lt;/var&gt; can be set to one the following values:</source>
          <target state="translated">&lt;var&gt;mode&lt;/var&gt; 可以设置为以下值之一：</target>
        </trans-unit>
        <trans-unit id="0b1b3ce355abf1bec528e4e29cb69b648d32b2c3" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;n&lt;/var&gt;f</source>
          <target state="translated">&lt;var&gt;n&lt;/var&gt;f</target>
        </trans-unit>
        <trans-unit id="2956846802a0f3763419f1cd6721396729e2240a" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;n&lt;/var&gt;f1_1</source>
          <target state="translated">&lt;var&gt;n&lt;/var&gt;f1_1</target>
        </trans-unit>
        <trans-unit id="d0f528c5f50a3a9ca8a7f4d4becb651762709fc6" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;n&lt;/var&gt;f2_1</source>
          <target state="translated">&lt;var&gt;n&lt;/var&gt;f2_1</target>
        </trans-unit>
        <trans-unit id="a64a9113e49c525ccc4593f4075479691d2d779c" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;n&lt;/var&gt;f3_2</source>
          <target state="translated">&lt;var&gt;n&lt;/var&gt;f3_2</target>
        </trans-unit>
        <trans-unit id="0f1c1c81fa999d2f5ca3d601e651ccc54a89eb03" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;n&lt;/var&gt;x</source>
          <target state="translated">&lt;var&gt;n&lt;/var&gt;x</target>
        </trans-unit>
        <trans-unit id="8e4ffce74a745b869371f4d5e4b25a511464db80" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;name&lt;/var&gt;: name of the function</source>
          <target state="translated">&lt;var&gt;name&lt;/var&gt; ：函数名称</target>
        </trans-unit>
        <trans-unit id="97651fa5ce5e8856932bddb384b35a32ca248309" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;number&lt;/var&gt; can only be 1 or 2. If it is 1 then branches are preferred over conditional code, if it is 2, then the opposite applies.</source>
          <target state="translated">&lt;var&gt;number&lt;/var&gt; 只能为1或2。如果为1，则分支比条件代码优先，如果为2，则相反。</target>
        </trans-unit>
        <trans-unit id="50273f37f0b45fd83f80ed0fdeed8ef68524af4d" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;option&lt;/var&gt;=&lt;var&gt;value&lt;/var&gt;</source>
          <target state="translated">&lt;var&gt;option&lt;/var&gt;=&lt;var&gt;value&lt;/var&gt;</target>
        </trans-unit>
        <trans-unit id="d0ce734a96f9558ae28efb50ac75200764dc9df5" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;path&lt;/var&gt; is the name of a file containing AutoFDO profile information. If omitted, it defaults to</source>
          <target state="translated">&lt;var&gt;path&lt;/var&gt; 是包含AutoFDO配置文件信息的文件的名称。如果省略，则默认为</target>
        </trans-unit>
        <trans-unit id="5fc499cb4d5dfe67bd81e09d65c41f73e48f4073" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;path&lt;/var&gt; with &lt;var&gt;path&lt;/var&gt; pointing to the base directory of the build can be used to strip the irrelevant part of the path and keep all file names relative to the main build directory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a043823197d8a0d9d4a3dae48ce610f7a8479fd" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;prefix&lt;/var&gt;/lib/gcc/</source>
          <target state="translated">&lt;var&gt;prefix&lt;/var&gt;/lib/gcc/</target>
        </trans-unit>
        <trans-unit id="75da58a5824259553dc7e89b6ec73fadaabdf8c6" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;profile_dir&lt;/var&gt; and</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26ed21f74315a592f7dd2bab8ba025f5ae695175" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;profile_dir&lt;/var&gt; to inform GCC where is the base directory of built source tree. By default &lt;var&gt;profile_dir&lt;/var&gt; will contain files with mangled absolute paths of all object files in the built project. This is not desirable when directory used to build the instrumented binary differs from the directory used to build the binary optimized with profile feedback because the profile data will not be found during the optimized build. In such setups</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="575dfa2a337b4bc21315c8f8022717c452a4ae62" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;ptr&lt;/var&gt; is an optional pointer to the object that may be used to determine alignment. A value of 0 indicates typical alignment should be used. The compiler may also ignore this parameter.</source>
          <target state="translated">&lt;var&gt;ptr&lt;/var&gt; 是指向对象的可选指针，可用于确定对齐方式。值0表示应使用典型对齐方式。编译器也可以忽略此参数。</target>
        </trans-unit>
        <trans-unit id="8b3c5b36be47a0fa932bdb61b7a90e0c4902fd51" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;real&lt;/var&gt; + I * &lt;var&gt;imag&lt;/var&gt;</source>
          <target state="translated">&lt;var&gt;real&lt;/var&gt; + I * &lt;var&gt;imag&lt;/var&gt;</target>
        </trans-unit>
        <trans-unit id="444cf69e0e22b51ba0c19cf554accc4728339634" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;reg&lt;/var&gt; must be the name of a register. The register names accepted are machine-specific and are defined in the &lt;code&gt;REGISTER_NAMES&lt;/code&gt; macro in the machine description macro file.</source>
          <target state="translated">&lt;var&gt;reg&lt;/var&gt; 必须是寄存器的名称。接受的寄存器名称是特定于计算机的，并且在计算机描述宏文件的 &lt;code&gt;REGISTER_NAMES&lt;/code&gt; 宏中定义。</target>
        </trans-unit>
        <trans-unit id="9fe1c0acef9a1d0caebcd87a22d3dc35ad3b0448" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;source-file&lt;/var&gt;##&lt;var&gt;md5&lt;/var&gt;.gcov</source>
          <target state="translated">&lt;var&gt;source-file&lt;/var&gt;##&lt;var&gt;md5&lt;/var&gt;.gcov</target>
        </trans-unit>
        <trans-unit id="b880a9e002b5a8cc6ab8e5b60ed026a3bd7b4c0f" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;source&lt;/var&gt;.&lt;var&gt;suffix&lt;/var&gt;</source>
          <target state="translated">&lt;var&gt;source&lt;/var&gt;.&lt;var&gt;suffix&lt;/var&gt;</target>
        </trans-unit>
        <trans-unit id="c61509b5e229f01a21d510673ed3415523a72145" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;source&lt;/var&gt;.&lt;var&gt;suffix&lt;/var&gt;.gch</source>
          <target state="translated">&lt;var&gt;source&lt;/var&gt;.&lt;var&gt;suffix&lt;/var&gt;.gch</target>
        </trans-unit>
        <trans-unit id="70db49065f5eba9055c8c455ae0994a97a7b0ff7" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;source&lt;/var&gt;.o</source>
          <target state="translated">&lt;var&gt;source&lt;/var&gt;.o</target>
        </trans-unit>
        <trans-unit id="4b7c7cc9bc07a7bc8b59a106fc41bf34e5bc1bce" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;source&lt;/var&gt;.s</source>
          <target state="translated">&lt;var&gt;source&lt;/var&gt;.s</target>
        </trans-unit>
        <trans-unit id="a72234cee5f73a88a10f2c471d34f2876066e0e2" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;sourcefile&lt;/var&gt;.c</source>
          <target state="translated">&lt;var&gt;sourcefile&lt;/var&gt;.c</target>
        </trans-unit>
        <trans-unit id="fca90e9a21f6a50975b13af845d218e0a2f371d9" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;sourcefile&lt;/var&gt;.gcov</source>
          <target state="translated">&lt;var&gt;sourcefile&lt;/var&gt;.gcov</target>
        </trans-unit>
        <trans-unit id="d01d6365317d600e2664fe58c60f8e16adc09101" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;sourcename&lt;/var&gt;.decl</source>
          <target state="translated">&lt;var&gt;sourcename&lt;/var&gt;.decl</target>
        </trans-unit>
        <trans-unit id="273491f96586620c37b4be341e04ca0866ba515f" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;sourcename&lt;/var&gt;.gcda</source>
          <target state="translated">&lt;var&gt;sourcename&lt;/var&gt;.gcda</target>
        </trans-unit>
        <trans-unit id="b7a20df9ca0090865388e1ede1a8c313cfa2ec03" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;start_column&lt;/var&gt;: column in the source file where the function begins</source>
          <target state="translated">&lt;var&gt;start_column&lt;/var&gt; ：函数开始的源文件中的列</target>
        </trans-unit>
        <trans-unit id="3305d67073def22b0281ddc5b0ab6b21190df394" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;start_line&lt;/var&gt;: line in the source file where the function begins</source>
          <target state="translated">&lt;var&gt;start_line&lt;/var&gt; ：函数开始的源文件中的行</target>
        </trans-unit>
        <trans-unit id="cb4cfaac038ae456ad73674888cd5dee273bede8" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;startfile&lt;/var&gt; is the file name of the startfile (crt0) to use when linking. This option is only useful in conjunction with</source>
          <target state="translated">&lt;var&gt;startfile&lt;/var&gt; 是链接时要使用的起始文件（crt0）的文件名。此选项仅在与</target>
        </trans-unit>
        <trans-unit id="92e2c1df29e70248323ce9841f5738d40e347e46" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;state&lt;/var&gt; configure option.</source>
          <target state="translated">&lt;var&gt;state&lt;/var&gt; 配置选项。</target>
        </trans-unit>
        <trans-unit id="956c0d57ed11241cf2af6705b81cf132c79d5cf4" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;string&lt;/var&gt; may be parenthesized, and is printed with location information. For example,</source>
          <target state="translated">&lt;var&gt;string&lt;/var&gt; 可以用括号括起来，并与位置信息一起打印。例如，</target>
        </trans-unit>
        <trans-unit id="9eedc4fd2f60aed10814958a1668c96d1c3d2760" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;style&lt;/var&gt; is either &lt;code&gt;c11&lt;/code&gt; or &lt;code&gt;ts-18661-3&lt;/code&gt; as appropriate.</source>
          <target state="translated">&lt;var&gt;style&lt;/var&gt; 为 &lt;code&gt;c11&lt;/code&gt; 或 &lt;code&gt;ts-18661-3&lt;/code&gt; (视情况而定）。</target>
        </trans-unit>
        <trans-unit id="756b0ec3e68649366cd0150c58c2eabc74fb8d54" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;systemlib&lt;/var&gt; is the library name of the library that provides low-level system calls required by the C library, e.g. &lt;code&gt;read&lt;/code&gt; and &lt;code&gt;write&lt;/code&gt;. This option is typically used to link with a library provided by a HAL BSP.</source>
          <target state="translated">&lt;var&gt;systemlib&lt;/var&gt; 是该库的库名，它提供C库所需的低级系统调用，例如 &lt;code&gt;read&lt;/code&gt; 和 &lt;code&gt;write&lt;/code&gt; 。此选项通常用于链接HAL BSP提供的库。</target>
        </trans-unit>
        <trans-unit id="f3b5c58dcaf93cade01b7328b68fe8d4178ba8da" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;throw&lt;/var&gt;: true when the branch is an exceptional branch</source>
          <target state="translated">&lt;var&gt;throw&lt;/var&gt; ：当分支是特殊分支时为true</target>
        </trans-unit>
        <trans-unit id="745e86448be042dc8edebfc034c56ccccf38a979" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;type&lt;/var&gt; is an integer constant from 0 to 3. If the least significant bit is clear, objects are whole variables, if it is set, a closest surrounding subobject is considered the object a pointer points to. The second bit determines if maximum or minimum of remaining bytes is computed.</source>
          <target state="translated">&lt;var&gt;type&lt;/var&gt; 是一个从0到3的整数常量。如果最低有效位清楚，则对象是完整变量，如果已设置，则将最接近的周围子对象视为指针指向的对象。第二位确定是否计算剩余字节的最大值或最小值。</target>
        </trans-unit>
        <trans-unit id="342fc24f28a056e632a0b35fb86b8d4dd73bc946" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;unexecuted_block&lt;/var&gt;: flag whether the line contains an unexecuted block (not all statements on the line are executed)</source>
          <target state="translated">&lt;var&gt;unexecuted_block&lt;/var&gt; ：标记该行是否包含未执行的块（不是该行上的所有语句都已执行）</target>
        </trans-unit>
        <trans-unit id="6049c35e012365c54216cf4865563ff7b5c3b373" translate="yes" xml:space="preserve">
          <source>=&lt;var&gt;filename&lt;/var&gt;</source>
          <target state="translated">=&lt;var&gt;filename&lt;/var&gt;</target>
        </trans-unit>
        <trans-unit id="46f10d3b2f96391f996a860a29e922307def05f4" translate="yes" xml:space="preserve">
          <source>=@cc&lt;var&gt;cond&lt;/var&gt;</source>
          <target state="translated">=@cc&lt;var&gt;cond&lt;/var&gt;</target>
        </trans-unit>
        <trans-unit id="2481fc6ffc2fbe4f98d31256e625358325756148" translate="yes" xml:space="preserve">
          <source>=f</source>
          <target state="translated">=f</target>
        </trans-unit>
        <trans-unit id="900f8b38b05989605df65663e5e3869aab5eb789" translate="yes" xml:space="preserve">
          <source>? :</source>
          <target state="translated">？：</target>
        </trans-unit>
        <trans-unit id="6dcd4ce23d88e2ee9568ba546c007c63d9131c1b" translate="yes" xml:space="preserve">
          <source>A</source>
          <target state="translated">A</target>
        </trans-unit>
        <trans-unit id="7025e1843ee6104f357de4a85f21b2b545cac788" translate="yes" xml:space="preserve">
          <source>A &amp;ldquo;stable&amp;rdquo; memory operand; that is, one which does not include any automodification of the base register. This used to be useful when &amp;lsquo;</source>
          <target state="translated">一个&amp;ldquo;稳定&amp;rdquo;的内存操作数；就是说，它不包括对基址寄存器的任何自动修改。在&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="b2a6e604c21235a8a2cf39c25b6821bfb403a2f9" translate="yes" xml:space="preserve">
          <source>A 10-bit signed constant (-512 &amp;hellip; 511)</source>
          <target state="translated">10位有符号常量（-512&amp;hellip;511）</target>
        </trans-unit>
        <trans-unit id="576737d0097b50a261308a427b2851f9873b4e96" translate="yes" xml:space="preserve">
          <source>A 16 bit value with exactly one bit set.</source>
          <target state="translated">一个16位的值,正好设置一个位。</target>
        </trans-unit>
        <trans-unit id="91a340944b7c5084f9cb17cdbbc4b3cfd1b6b8d2" translate="yes" xml:space="preserve">
          <source>A 16-bit fragment of a got, tls, or pc-relative reference.</source>
          <target state="translated">一个16位的got、tls或pc-relative引用的片段。</target>
        </trans-unit>
        <trans-unit id="9d079cc97fa73a6ab6e8c28d5a00eebc59ab7c45" translate="yes" xml:space="preserve">
          <source>A 16-bit signed constant (-32768 &amp;hellip; 32767)</source>
          <target state="translated">16位带符号常量（-32768&amp;hellip;32767）</target>
        </trans-unit>
        <trans-unit id="600f9da68b2b8b3eca45f28f2690b3c739522b91" translate="yes" xml:space="preserve">
          <source>A 16-bit unsigned constant, multiple of 4 (0 &amp;hellip; 65532)</source>
          <target state="translated">16位无符号常量，为4的倍数（0&amp;hellip;65532）</target>
        </trans-unit>
        <trans-unit id="626d08e653ff5fead00da4b2ae1ffdf55de25ac2" translate="yes" xml:space="preserve">
          <source>A 2-element vector constant with identical elements.</source>
          <target state="translated">一个具有相同元素的2元素向量常数。</target>
        </trans-unit>
        <trans-unit id="199076609694aaa8dd531a498d6bd24d81a6cc20" translate="yes" xml:space="preserve">
          <source>A 20-bit signed constant (-524288 &amp;hellip; 524287)</source>
          <target state="translated">20位有符号常量（-524288&amp;hellip;524287）</target>
        </trans-unit>
        <trans-unit id="739e9c986b6796272b083980b6406cba9cf05af2" translate="yes" xml:space="preserve">
          <source>A 3-bit unsigned integer constant.</source>
          <target state="translated">一个3位无符号整数常数。</target>
        </trans-unit>
        <trans-unit id="8d9d9ff6786b090797685cfe7290aeace549fb2c" translate="yes" xml:space="preserve">
          <source>A 4-element vector constant with identical elements.</source>
          <target state="translated">一个4元素的向量常数,元素相同。</target>
        </trans-unit>
        <trans-unit id="809cfd342c5778cebf932a5fb2090f41ac0b8050" translate="yes" xml:space="preserve">
          <source>A 5-bit unsigned immediate for CSR access instructions.</source>
          <target state="translated">用于CSR访问指令的5位无符号立即。</target>
        </trans-unit>
        <trans-unit id="7a0f592094ae133e28a83db08acb3ad80aaa8c6b" translate="yes" xml:space="preserve">
          <source>A 5-bit unsigned integer constant.</source>
          <target state="translated">一个5位无符号整数常数。</target>
        </trans-unit>
        <trans-unit id="2a19359a80d0f6de7d964e539759745df3e07113" translate="yes" xml:space="preserve">
          <source>A 6-bit unsigned integer constant.</source>
          <target state="translated">一个6位无符号整数常数。</target>
        </trans-unit>
        <trans-unit id="4a1d6a6dcc128bafb39f6e3e6579f2614ede9096" translate="yes" xml:space="preserve">
          <source>A 7-bit unsigned integer constant.</source>
          <target state="translated">一个7位无符号整数常数。</target>
        </trans-unit>
        <trans-unit id="4e392016af47c374eef4f8aaf14822a0c557c367" translate="yes" xml:space="preserve">
          <source>A 8-bit unsigned integer constant.</source>
          <target state="translated">一个8位无符号整数常数。</target>
        </trans-unit>
        <trans-unit id="083fa44b7c5e44320ff4ed2ae01244ea90801a78" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;lo_sum&lt;/code&gt; data-linkage-table memory operand</source>
          <target state="translated">甲 &lt;code&gt;lo_sum&lt;/code&gt; 数据联动表存储器的操作数</target>
        </trans-unit>
        <trans-unit id="f9cd2e27d673f56cc94424aa5ac780102659b79a" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;switch&lt;/code&gt; statement has an operand of type &lt;code&gt;long&lt;/code&gt;.</source>
          <target state="translated">一个 &lt;code&gt;switch&lt;/code&gt; 语句类型的操作数 &lt;code&gt;long&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d0eff00ac09b6d2be5766ddb9515db21e223caed" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;typeof&lt;/code&gt; construct can be used anywhere a typedef name can be used. For example, you can use it in a declaration, in a cast, or inside of &lt;code&gt;sizeof&lt;/code&gt; or &lt;code&gt;typeof&lt;/code&gt;.</source>
          <target state="translated">在可以使用typedef名称的任何地方都可以使用 &lt;code&gt;typeof&lt;/code&gt; 构造。例如，可以在声明中， &lt;code&gt;sizeof&lt;/code&gt; 或在sizeof或 &lt;code&gt;typeof&lt;/code&gt; 内部使用它。</target>
        </trans-unit>
        <trans-unit id="0fcc11ba29659026ef90972ee49fd236e8ca7461" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;nested function&lt;/em&gt; is a function defined inside another function. Nested functions are supported as an extension in GNU C, but are not supported by GNU C++.</source>
          <target state="translated">甲&lt;em&gt;嵌套函数&lt;/em&gt;是另一个函数中定义的功能。嵌套函数在GNU C中受支持作为扩展，但GNU C ++不支持。</target>
        </trans-unit>
        <trans-unit id="c55a5d7e9e734b9cfd6d5b793b74655af96e5ff3" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;preprocessing token&lt;/em&gt; is a &lt;em&gt;preprocessing number&lt;/em&gt; if it begins with a digit and is followed by letters, underscores, digits, periods and &amp;lsquo;</source>
          <target state="translated">如果&lt;em&gt;预处理令牌&lt;/em&gt;以&lt;em&gt;数字&lt;/em&gt;开头，后跟字母，下划线，数字，句点和'，则为&lt;em&gt;预处理数字&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="226cffe8593eab9de1b46a1badbfea96e62ee6f4" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;thread&lt;/em&gt; is a flow of control within the abstract machine. It is implementation defined whether or not there may be more than one thread.</source>
          <target state="translated">甲&lt;em&gt;螺纹&lt;/em&gt;是控制的抽象机内的流。由实现定义是否有多个线程。</target>
        </trans-unit>
        <trans-unit id="d63439749e9d375a44c13be44c44d3b25a8cbdd3" translate="yes" xml:space="preserve">
          <source>A C++ namespace declaration can also have the visibility attribute.</source>
          <target state="translated">一个C++命名空间声明也可以有可见性属性。</target>
        </trans-unit>
        <trans-unit id="f6e3cb01289f372ad5685f7b48da04f4e60a84ec" translate="yes" xml:space="preserve">
          <source>A GNU Manual</source>
          <target state="translated">GNU手册</target>
        </trans-unit>
        <trans-unit id="e5ae31d72b84a280dea45cc026a21e380e65748b" translate="yes" xml:space="preserve">
          <source>A VSX register (VSR), &lt;code&gt;vs0&lt;/code&gt;&amp;hellip;&lt;code&gt;vs63&lt;/code&gt;. This is either an FPR (&lt;code&gt;vs0&lt;/code&gt;&amp;hellip;&lt;code&gt;vs31&lt;/code&gt; are &lt;code&gt;f0&lt;/code&gt;&amp;hellip;&lt;code&gt;f31&lt;/code&gt;) or a VR (&lt;code&gt;vs32&lt;/code&gt;&amp;hellip;&lt;code&gt;vs63&lt;/code&gt; are &lt;code&gt;v0&lt;/code&gt;&amp;hellip;&lt;code&gt;v31&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5003442624da7a5396a336fd4ef339c3db6eb07" translate="yes" xml:space="preserve">
          <source>A base register. Like &lt;code&gt;r&lt;/code&gt;, but &lt;code&gt;r0&lt;/code&gt; is not allowed, so &lt;code&gt;r1&lt;/code&gt;&amp;hellip;&lt;code&gt;r31&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd8fd98a94ad304e430ad561d03982387ab58fa2" translate="yes" xml:space="preserve">
          <source>A basic &lt;code&gt;asm&lt;/code&gt; statement has the following syntax:</source>
          <target state="translated">基本的 &lt;code&gt;asm&lt;/code&gt; 语句具有以下语法：</target>
        </trans-unit>
        <trans-unit id="6145aa4e1e7149a673e61fa6c454fd8a42cee7a8" translate="yes" xml:space="preserve">
          <source>A basic block profile count is considered hot if it contributes to the given permillage (i.e. 0...1000) of the entire profiled execution.</source>
          <target state="translated">如果一个基本的区块剖面数对整个剖面执行的给定permillage(即0...1000)有贡献,那么它就被认为是热的。</target>
        </trans-unit>
        <trans-unit id="2df3f34d53b76011b7a6bb1711d67e1df403856d" translate="yes" xml:space="preserve">
          <source>A binary type trait: &lt;code&gt;true&lt;/code&gt; whenever the type arguments are the same.</source>
          <target state="translated">二进制类型特征：只要类型参数相同，则为 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="61a474d3c8a798ad9f41fbc155178fa260c3cbfd" translate="yes" xml:space="preserve">
          <source>A bit mask suitable for the BFINS instruction.</source>
          <target state="translated">适合BFINS指令的位掩码。</target>
        </trans-unit>
        <trans-unit id="1c197853a26bb6b9e64cfe3c20fc4b78dab065a2" translate="yes" xml:space="preserve">
          <source>A bit mask suitable for the MM instruction.</source>
          <target state="translated">适合MM指令的位掩码。</target>
        </trans-unit>
        <trans-unit id="fb82d601263ede6336b3a6d38f27a2db288988de" translate="yes" xml:space="preserve">
          <source>A bitfield mask suitable for bext or bins</source>
          <target state="translated">适用于bext或bins的位场掩码。</target>
        </trans-unit>
        <trans-unit id="95088444b66d4c9478cf588a65f1dca5aa3b6e35" translate="yes" xml:space="preserve">
          <source>A c99-like declaration syntax is also allowed:</source>
          <target state="translated">也允许使用类似c99的声明语法。</target>
        </trans-unit>
        <trans-unit id="242045c1091165567c1e2bc6642eff026733baf4" translate="yes" xml:space="preserve">
          <source>A call clobbered P register.</source>
          <target state="translated">一个电话就把P寄存器给打烂了。</target>
        </trans-unit>
        <trans-unit id="6501e67efab2f7c858c0e0f7b446cd704c13a388" translate="yes" xml:space="preserve">
          <source>A call-used register in register file B (B0&amp;ndash;B9, B16&amp;ndash;B31).</source>
          <target state="translated">寄存器文件B（B0&amp;ndash;B9，B16&amp;ndash;B31）中的已使用调用的寄存器。</target>
        </trans-unit>
        <trans-unit id="5a85a53751233b51746da27b56a87b1a58dd44bc" translate="yes" xml:space="preserve">
          <source>A cast from integer to pointer discards most-significant bits if the pointer representation is smaller than the integer type, extends according to the signedness of the integer type if the pointer representation is larger than the integer type, otherwise the bits are unchanged.</source>
          <target state="translated">从整数到指针的转换,如果指针的表示方式小于整数类型,则丢弃最重要的位,如果指针的表示方式大于整数类型,则根据整数类型的符号性进行扩展,否则位不变。</target>
        </trans-unit>
        <trans-unit id="9579e92267fbbcb00a411d24c34a20ac82cffc52" translate="yes" xml:space="preserve">
          <source>A cast from pointer to integer discards most-significant bits if the pointer representation is larger than the integer type, sign-extends&lt;a href=&quot;#FOOT2&quot; id=&quot;DOCF2&quot; name=&quot;DOCF2&quot;&gt;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt; if the pointer representation is smaller than the integer type, otherwise the bits are unchanged.</source>
          <target state="translated">如果指针表示形式大于整数类型，则从指针到整数的转换将丢弃最高有效位；如果指针表示形式小于整数类型，则将符号扩展到&lt;a href=&quot;#FOOT2&quot; id=&quot;DOCF2&quot; name=&quot;DOCF2&quot;&gt;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt;，否则这些位不变。</target>
        </trans-unit>
        <trans-unit id="8d607e1d6022f86c3f2fb0150398c8747d6a9a20" translate="yes" xml:space="preserve">
          <source>A cast to a union type is a C extension not available in C++. It looks just like ordinary casts with the constraint that the type specified is a union type. You can specify the type either with the &lt;code&gt;union&lt;/code&gt; keyword or with a &lt;code&gt;typedef&lt;/code&gt; name that refers to a union. The result of a cast to a union is a temporary rvalue of the union type with a member whose type matches that of the operand initialized to the value of the operand. The effect of a cast to a union is similar to a compound literal except that it yields an rvalue like standard casts do. See &lt;a href=&quot;compound-literals#Compound-Literals&quot;&gt;Compound Literals&lt;/a&gt;.</source>
          <target state="translated">强制转换为联合类型是C扩展，在C ++中不可用。看起来就像普通的强制类型转换一样，其约束条件是指定的类型是联合类型。您可以使用 &lt;code&gt;union&lt;/code&gt; 关键字或引用联合的 &lt;code&gt;typedef&lt;/code&gt; 名称来指定类型。强制转换为并集的结果是并集类型的临时右值，其成员的类型与初始化为操作数的值的操作数的类型匹配。强制转换为并集的效果类似于复合文字，除了它会像标准强制转换一样产生右值。请参阅&lt;a href=&quot;compound-literals#Compound-Literals&quot;&gt;复合文字&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="75e1479f2ae72adba50e5d40e09a4fb8d576ce4d" translate="yes" xml:space="preserve">
          <source>A combination of</source>
          <target state="translated">组合</target>
        </trans-unit>
        <trans-unit id="de7ce58153dc3aa9a8a53f607567323d0809bd31" translate="yes" xml:space="preserve">
          <source>A comma-separated list of C expressions read by the instructions in the &lt;var&gt;AssemblerTemplate&lt;/var&gt;. An empty list is permitted. See &lt;a href=&quot;#InputOperands&quot;&gt;InputOperands&lt;/a&gt;.</source>
          <target state="translated">由 &lt;var&gt;AssemblerTemplate&lt;/var&gt; 中的指令读取的C表达式的逗号分隔列表。允许使用空列表。请参阅&lt;a href=&quot;#InputOperands&quot;&gt;InputOperands&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5b5d944665cc53cab2f2ad1f645c434c5620d068" translate="yes" xml:space="preserve">
          <source>A comma-separated list of registers or other values changed by the &lt;var&gt;AssemblerTemplate&lt;/var&gt;, beyond those listed as outputs. An empty list is permitted. See &lt;a href=&quot;#Clobbers-and-Scratch-Registers&quot;&gt;Clobbers and Scratch Registers&lt;/a&gt;.</source>
          <target state="translated">用逗号分隔的列表或由 &lt;var&gt;AssemblerTemplate&lt;/var&gt; 更改的其他值，而不是列为输出的列表。允许使用空列表。请参阅&lt;a href=&quot;#Clobbers-and-Scratch-Registers&quot;&gt;Clobbers和暂存寄存器&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="65d21196a0c3e5a9f693ae19ae22931182555110" translate="yes" xml:space="preserve">
          <source>A comma-separated list of the C variables modified by the instructions in the &lt;var&gt;AssemblerTemplate&lt;/var&gt;. An empty list is permitted. See &lt;a href=&quot;#OutputOperands&quot;&gt;OutputOperands&lt;/a&gt;.</source>
          <target state="translated">由 &lt;var&gt;AssemblerTemplate&lt;/var&gt; 中的指令修改的C变量的逗号分隔列表。允许使用空列表。参见&lt;a href=&quot;#OutputOperands&quot;&gt;OutputOperands&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="57ff1562fe61f1f887425ce2cee86f1d3d93e844" translate="yes" xml:space="preserve">
          <source>A compiler conforms to an ABI if it generates code that follows all of the specifications enumerated by that ABI. A library conforms to an ABI if it is implemented according to that ABI. An application conforms to an ABI if it is built using tools that conform to that ABI and does not contain source code that specifically changes behavior specified by the ABI.</source>
          <target state="translated">如果一个编译器生成的代码符合ABI所列举的所有规范,它就符合ABI。如果一个库是根据该ABI实现的,那么它就符合ABI。如果一个应用程序使用符合ABI的工具来构建,并且不包含特别改变ABI指定行为的源代码,那么它就符合ABI。</target>
        </trans-unit>
        <trans-unit id="41c80a94e954da6243e86405854638e4aa3a6477" translate="yes" xml:space="preserve">
          <source>A compound literal looks like a cast of a brace-enclosed aggregate initializer list. Its value is an object of the type specified in the cast, containing the elements specified in the initializer. Unlike the result of a cast, a compound literal is an lvalue. ISO C99 and later support compound literals. As an extension, GCC supports compound literals also in C90 mode and in C++, although as explained below, the C++ semantics are somewhat different.</source>
          <target state="translated">复合文字看起来就像一个括号包围的聚合初始化列表的投递。它的值是一个对象,其类型是在投射中指定的,包含初始化器中指定的元素。与投递的结果不同,复合文字是一个l值,它的值是投递中指定类型的对象,包含初始化器中指定的元素。ISO C99及以后的版本都支持复合文字。作为扩展,GCC在C90模式和C++中也支持复字,尽管正如下面解释的那样,C++的语义有些不同。</target>
        </trans-unit>
        <trans-unit id="f6dd9a1a8f56216b2f65e6b7a8c29b8ee8f55106" translate="yes" xml:space="preserve">
          <source>A compound statement enclosed in parentheses may appear as an expression in GNU C. This allows you to use loops, switches, and local variables within an expression.</source>
          <target state="translated">在GNU C中,括号内的复合语句可以作为表达式出现,这允许您在表达式中使用循环、开关和局部变量。</target>
        </trans-unit>
        <trans-unit id="8a72443d4592827fe4ca85bea82301121049b91e" translate="yes" xml:space="preserve">
          <source>A conforming implementation of ISO C is required to document its choice of behavior in each of the areas that are designated &amp;ldquo;implementation defined&amp;rdquo;. The following lists all such areas, along with the section numbers from the ISO/IEC 9899:1990, ISO/IEC 9899:1999 and ISO/IEC 9899:2011 standards. Some areas are only implementation-defined in one version of the standard.</source>
          <target state="translated">需要采用ISO C的一致实施来记录其在每个指定为&amp;ldquo;实施定义&amp;rdquo;的领域中的行为选择。以下列出了所有此类区域，以及ISO / IEC 9899：1990，ISO / IEC 9899：1999和ISO / IEC 9899：2011标准的章节编号。某些区域仅在标准的一个版本中由实现定义。</target>
        </trans-unit>
        <trans-unit id="d4cb4e2bf524da1d62affddb40dfb630800239af" translate="yes" xml:space="preserve">
          <source>A conforming implementation of ISO C++ is required to document its choice of behavior in each of the areas that are designated &amp;ldquo;implementation defined&amp;rdquo;. The following lists all such areas, along with the section numbers from the ISO/IEC 14882:1998 and ISO/IEC 14882:2003 standards. Some areas are only implementation-defined in one version of the standard.</source>
          <target state="translated">需要使用ISO C ++的一致实施来记录其在每个指定为&amp;ldquo;实施定义&amp;rdquo;的领域中的行为选择。下面列出了所有此类区域，以及ISO / IEC 14882：1998和ISO / IEC 14882：2003标准的章节编号。某些区域仅在标准的一个版本中由实现定义。</target>
        </trans-unit>
        <trans-unit id="7b29cb3b319ec95ede4a30707c842823bf94b7db" translate="yes" xml:space="preserve">
          <source>A consequence of this is that &lt;code&gt;sizeof&lt;/code&gt; is also allowed on &lt;code&gt;void&lt;/code&gt; and on function types, and returns 1.</source>
          <target state="translated">这样的结果是在 &lt;code&gt;void&lt;/code&gt; 和函数类型上也允许 &lt;code&gt;sizeof&lt;/code&gt; ，并返回1。</target>
        </trans-unit>
        <trans-unit id="7cad9a0baf039ead351d859d05c0365e63661fb9" translate="yes" xml:space="preserve">
          <source>A constant between -255 and 0 inclusive.</source>
          <target state="translated">一个介于-255和0(含)之间的常数。</target>
        </trans-unit>
        <trans-unit id="4f8cd8bf499f2d6d54a71ffc2d3e21cf7ef45e36" translate="yes" xml:space="preserve">
          <source>A constant between -3 and 0 inclusive.</source>
          <target state="translated">一个介于-3和0(含)之间的常数。</target>
        </trans-unit>
        <trans-unit id="19428213d0a5f62ee0574191f3ae2f2ddd996015" translate="yes" xml:space="preserve">
          <source>A constant between -4 and -1 inclusive.</source>
          <target state="translated">一个介于-4和-1(含)之间的常数。</target>
        </trans-unit>
        <trans-unit id="d2fbc8414f61903ae333dcf7ac7a844a0c7b23fe" translate="yes" xml:space="preserve">
          <source>A constant between 0 and 255 inclusive.</source>
          <target state="translated">0-255(含)之间的常数。</target>
        </trans-unit>
        <trans-unit id="12f6b4cb352959b8bca5dac3da05fd53e64fa274" translate="yes" xml:space="preserve">
          <source>A constant between 0 and 3 inclusive.</source>
          <target state="translated">0到3(含)之间的常数。</target>
        </trans-unit>
        <trans-unit id="da945b1c391dff3ac6bc6d5fbd2be9149c62266c" translate="yes" xml:space="preserve">
          <source>A constant between 1 and 4 inclusive.</source>
          <target state="translated">1至4(含)之间的常数。</target>
        </trans-unit>
        <trans-unit id="c0aca6087bfc1e63cba0551e38002443555e0fac" translate="yes" xml:space="preserve">
          <source>A constant for a bitfield width (1 &amp;hellip; 16)</source>
          <target state="translated">位域宽度（1&amp;hellip;16）的常数</target>
        </trans-unit>
        <trans-unit id="6d56856d82b6a91412eed6d7df5c640079002d4d" translate="yes" xml:space="preserve">
          <source>A constant in the range -128 to 127, inclusive.</source>
          <target state="translated">在-128至127范围内的一个常数,包括在内。</target>
        </trans-unit>
        <trans-unit id="17b05b4c60ac27d1e72d8030837136d5fa0be31c" translate="yes" xml:space="preserve">
          <source>A constant in the range -256 to 255, inclusive.</source>
          <target state="translated">一个范围为-256至255的常数,包括在内。</target>
        </trans-unit>
        <trans-unit id="695a694abf391bc605e989d6eb5dbacf14f628c2" translate="yes" xml:space="preserve">
          <source>A constant in the range -32768 to 32767, inclusive.</source>
          <target state="translated">一个在-32768至32767范围内的常数,包括在内。</target>
        </trans-unit>
        <trans-unit id="2e51455a9b3294a37777151389f3c055d9628f83" translate="yes" xml:space="preserve">
          <source>A constant in the range -65535 to -1 (inclusive).</source>
          <target state="translated">在-65535至-1(含)范围内的一个常数。</target>
        </trans-unit>
        <trans-unit id="a2eafd56ff7c3244c125e89f98b5047314116000" translate="yes" xml:space="preserve">
          <source>A constant in the range -8388608 to 8388607, inclusive.</source>
          <target state="translated">在-8388608至8388607(含)范围内的一个常数。</target>
        </trans-unit>
        <trans-unit id="097b361ff7733f96fe3db5433e37aba686b852b1" translate="yes" xml:space="preserve">
          <source>A constant in the range 0 to 15, inclusive.</source>
          <target state="translated">0-15(含)范围内的常数。</target>
        </trans-unit>
        <trans-unit id="a36455a425b9727ae75ec8f878c7951252ab00ab" translate="yes" xml:space="preserve">
          <source>A constant in the range 1 to 65535 (inclusive).</source>
          <target state="translated">1至65535(含)范围内的常数。</target>
        </trans-unit>
        <trans-unit id="2a58c4a3cc79eb84153470348476e3f269dac278" translate="yes" xml:space="preserve">
          <source>A constant in the range [-64, 63] for shift/rotate instructions.</source>
          <target state="translated">在[-64,63]范围内的一个常数,用于移位/旋转指令。</target>
        </trans-unit>
        <trans-unit id="10785db1e9d20c3cdec60f076d95570e2881e446" translate="yes" xml:space="preserve">
          <source>A constant in the range of 0 to -255.</source>
          <target state="translated">0至-255范围内的常数。</target>
        </trans-unit>
        <trans-unit id="5b0495335754f2b58bcc5c273f50a0ad47fb4980" translate="yes" xml:space="preserve">
          <source>A constant in the range of 0 to 255.</source>
          <target state="translated">一个范围为0至255的常数。</target>
        </trans-unit>
        <trans-unit id="3df560572af8da9f608ecbfa457628a58591cc1d" translate="yes" xml:space="preserve">
          <source>A constant in the range supported by &lt;code&gt;movcc&lt;/code&gt; instructions (11-bit signed immediate)</source>
          <target state="translated">&lt;code&gt;movcc&lt;/code&gt; 指令支持的范围内的常数（11位带符号立即数）</target>
        </trans-unit>
        <trans-unit id="e6b217cb7e92669add738eef6823abf207c1faff" translate="yes" xml:space="preserve">
          <source>A constant in the range supported by &lt;code&gt;movrcc&lt;/code&gt; instructions (10-bit signed immediate)</source>
          <target state="translated">&lt;code&gt;movrcc&lt;/code&gt; 指令支持的范围内的常数（10位立即签名）</target>
        </trans-unit>
        <trans-unit id="f72ba093b9d9c51600024c95028a46b05718f280" translate="yes" xml:space="preserve">
          <source>A constant that cannot be loaded using &lt;code&gt;lui&lt;/code&gt;, &lt;code&gt;addiu&lt;/code&gt; or &lt;code&gt;ori&lt;/code&gt;.</source>
          <target state="translated">无法使用 &lt;code&gt;lui&lt;/code&gt; ， &lt;code&gt;addiu&lt;/code&gt; 或 &lt;code&gt;ori&lt;/code&gt; 加载的常量。</target>
        </trans-unit>
        <trans-unit id="7c2d44283a3acc9bdc683ea83a3f874e52a46752" translate="yes" xml:space="preserve">
          <source>A constant that has exactly one bit clear.</source>
          <target state="translated">一个常数,正好有一个位清。</target>
        </trans-unit>
        <trans-unit id="cfb3a0520f6d9864d7a1976144208cbbd9174378" translate="yes" xml:space="preserve">
          <source>A constant that has exactly one bit set.</source>
          <target state="translated">一个常数,正好设置了一个位。</target>
        </trans-unit>
        <trans-unit id="f067235028290b700b44d1ece783ed553e206e2b" translate="yes" xml:space="preserve">
          <source>A constant that is not between 2 and 15 inclusive.</source>
          <target state="translated">一个不在2到15(含)之间的常数。</target>
        </trans-unit>
        <trans-unit id="dc8b34473e04adc25852b0eed10f1d174b004494" translate="yes" xml:space="preserve">
          <source>A constant which is not in the range of imm15u but ok for bclr instruction.</source>
          <target state="translated">一个不在imm15u范围内的常数,但可以用于bclr指令。</target>
        </trans-unit>
        <trans-unit id="c6a1b8bc59cee8c8f6571d6cc94e881414d8fd98" translate="yes" xml:space="preserve">
          <source>A constant which is not in the range of imm15u but ok for bset instruction.</source>
          <target state="translated">一个不在imm15u范围内的常数,但可以用于bset指令。</target>
        </trans-unit>
        <trans-unit id="5a081f0e675d939eda6d41b659eb1a4796698f55" translate="yes" xml:space="preserve">
          <source>A constant which is not in the range of imm15u but ok for btgl instruction.</source>
          <target state="translated">一个不在imm15u范围内的常数,但可以用于btgl指令。</target>
        </trans-unit>
        <trans-unit id="739639d0dba642847055adad6d408a8462cefd56" translate="yes" xml:space="preserve">
          <source>A constant whose compliment value is in the range of imm15u and ok for bitci instruction.</source>
          <target state="translated">一个常数,它的补正值在imm15u和ok的范围内,用于bitci指令。</target>
        </trans-unit>
        <trans-unit id="772d4006b3b3b9f5dbb1eb8305ae0da40df09812" translate="yes" xml:space="preserve">
          <source>A decimal number representing clock cycles.</source>
          <target state="translated">代表时钟周期的十进制数。</target>
        </trans-unit>
        <trans-unit id="0e4012d6617bb64507db563d81889013cebe2316" translate="yes" xml:space="preserve">
          <source>A declaration to which &lt;code&gt;weakref&lt;/code&gt; is attached and that is associated with a named &lt;code&gt;target&lt;/code&gt; must be &lt;code&gt;static&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="871d38c63e186ae7cd0f311fcbbf75d49f235704" translate="yes" xml:space="preserve">
          <source>A deprecated synonym for</source>
          <target state="translated">废弃的同义词</target>
        </trans-unit>
        <trans-unit id="35b2c49fceb685c2e6ddfd9b7ccde26327c395da" translate="yes" xml:space="preserve">
          <source>A diagnostic can contain zero or more locations. Each location has up to three positions within it: a &lt;code&gt;caret&lt;/code&gt; position and optional &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;finish&lt;/code&gt; positions. A location can also have an optional &lt;code&gt;label&lt;/code&gt; string. For example, this error:</source>
          <target state="translated">诊断可以包含零个或多个位置。每个位置中最多包含三个位置： &lt;code&gt;caret&lt;/code&gt; 位置以及可选的 &lt;code&gt;start&lt;/code&gt; 和 &lt;code&gt;finish&lt;/code&gt; 位置。位置也可以具有可选的 &lt;code&gt;label&lt;/code&gt; 字符串。例如，此错误：</target>
        </trans-unit>
        <trans-unit id="1d3956dd1850c8ee01dd888bb0a0a3023c553d32" translate="yes" xml:space="preserve">
          <source>A diagnostic has a &lt;code&gt;kind&lt;/code&gt;. If this is &lt;code&gt;warning&lt;/code&gt;, then there is an &lt;code&gt;option&lt;/code&gt; key describing the command-line option controlling the warning.</source>
          <target state="translated">诊断有 &lt;code&gt;kind&lt;/code&gt; 。如果这是 &lt;code&gt;warning&lt;/code&gt; ，则有一个 &lt;code&gt;option&lt;/code&gt; 键描述控制警告的命令行选项。</target>
        </trans-unit>
        <trans-unit id="64d7123704bf7fa0f1e73d01535513a0dc7c2748" translate="yes" xml:space="preserve">
          <source>A different sort of disaster results from the use of this flag for a register in which function values may be returned.</source>
          <target state="translated">如果对一个可以返回函数值的寄存器使用这个标志,就会造成另一种灾难。</target>
        </trans-unit>
        <trans-unit id="c32446d7ea192a83db5ac54835cfe4c3d265fe83" translate="yes" xml:space="preserve">
          <source>A factor for tuning the upper bound that swing modulo scheduler uses for scheduling a loop.</source>
          <target state="translated">用于调整摆动模数调度器用于调度循环的上界的因素。</target>
        </trans-unit>
        <trans-unit id="a7b34a84c6690fd83c05d2fa16fc0c287bb3da1b" translate="yes" xml:space="preserve">
          <source>A feature to report any failure to conform to ISO C might be useful in some instances, but would require considerable additional work and would be quite different from</source>
          <target state="translated">在某些情况下,报告任何不符合ISO C的情况的功能可能是有用的,但需要做大量的额外工作,并将在很大程度上不同于ISO C。</target>
        </trans-unit>
        <trans-unit id="b2a29cc3baea0c08d4a825d0752f1c7c91b7a29c" translate="yes" xml:space="preserve">
          <source>A few standard library functions, such as &lt;code&gt;abort&lt;/code&gt; and &lt;code&gt;exit&lt;/code&gt;, cannot return. GCC knows this automatically. Some programs define their own functions that never return. You can declare them &lt;code&gt;noreturn&lt;/code&gt; to tell the compiler this fact. For example,</source>
          <target state="translated">一些标准库函数（例如 &lt;code&gt;abort&lt;/code&gt; 和 &lt;code&gt;exit&lt;/code&gt; ）无法返回。GCC会自动知道这一点。一些程序定义了自己的永不返回的函数。你可以声明他们 &lt;code&gt;noreturn&lt;/code&gt; 告诉编译器这个事实。例如，</target>
        </trans-unit>
        <trans-unit id="cb463f377ea974dd6c90f4d5e14fe7753fa59c05" translate="yes" xml:space="preserve">
          <source>A file name that does not end in a special recognized suffix is considered to name an object file or library. (Object files are distinguished from libraries by the linker according to the file contents.) If linking is done, these object files are used as input to the linker.</source>
          <target state="translated">文件名如果不以特殊认可的后缀结尾,则被认为是对象文件或库的名称(对象文件和库由链接器根据文件内容区分)。(对象文件与库的区别是由链接器根据文件内容来区分的。)如果进行链接,这些对象文件将作为链接器的输入。</target>
        </trans-unit>
        <trans-unit id="31a3ef8a1f914c346a656751b3762e1f23b6d753" translate="yes" xml:space="preserve">
          <source>A file&amp;rsquo;s &lt;em&gt;basename&lt;/em&gt; is the name stripped of all leading path information and of trailing suffixes, such as &amp;lsquo;</source>
          <target state="translated">文件的&lt;em&gt;基本名称&lt;/em&gt;是指去除所有前导路径信息和后缀后缀的名称，例如&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="3cb6c35b9f770d58e9e6ae1be71711d84191b278" translate="yes" xml:space="preserve">
          <source>A floating point constant 0.0</source>
          <target state="translated">一个浮点常数0.0</target>
        </trans-unit>
        <trans-unit id="ac7c31fdc5f9ddf8dfae82582cc34a55de257130" translate="yes" xml:space="preserve">
          <source>A floating point register (FPR), &lt;code&gt;f0&lt;/code&gt;&amp;hellip;&lt;code&gt;f31&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="637820768e2434914c48d73ef03a77823d03c37c" translate="yes" xml:space="preserve">
          <source>A floating point register. This is the same as &lt;code&gt;f&lt;/code&gt; nowadays; historically &lt;code&gt;f&lt;/code&gt; was for single-precision and &lt;code&gt;d&lt;/code&gt; was for double-precision floating point.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35a05594f7fa158ed7e1a662576eede9b7714efc" translate="yes" xml:space="preserve">
          <source>A floating-point condition code register.</source>
          <target state="translated">一个浮点条件代码寄存器。</target>
        </trans-unit>
        <trans-unit id="6a5e282398dc91c4802485c8333b0a476c54fe7d" translate="yes" xml:space="preserve">
          <source>A floating-point register (if available).</source>
          <target state="translated">一个浮点寄存器(如果有的话)。</target>
        </trans-unit>
        <trans-unit id="f68f63f0de9f100e3091753e0a87b4bdcab324f8" translate="yes" xml:space="preserve">
          <source>A floating-point register (if availiable).</source>
          <target state="translated">一个浮点寄存器(如果有的话)。</target>
        </trans-unit>
        <trans-unit id="1d93f84bcb43d9808ea6d43552092e130f8e5d2b" translate="yes" xml:space="preserve">
          <source>A fourth version of the C standard, known as &lt;em&gt;C11&lt;/em&gt;, was published in 2011 as ISO/IEC 9899:2011. (While in development, drafts of this standard version were referred to as &lt;em&gt;C1X&lt;/em&gt;.) GCC has substantially complete support for this standard, enabled with</source>
          <target state="translated">C标准的第四个版本称为&lt;em&gt;C11&lt;/em&gt;，于2011年发布为ISO / IEC 9899：2011。（在开发过程中，此标准版本的草案被称为&lt;em&gt;C1X&lt;/em&gt;。）GCC对此标准提供了基本完整的支持，并启用了</target>
        </trans-unit>
        <trans-unit id="55257df904754ff4c13989bc1d064dbb261da350" translate="yes" xml:space="preserve">
          <source>A framework directory is a directory with frameworks in it. A framework is a directory with a</source>
          <target state="translated">框架目录是一个有框架的目录。一个框架是一个目录,里面有一个</target>
        </trans-unit>
        <trans-unit id="5ba28f66c2dca176d361d13d2cfcd58e64de11b1" translate="yes" xml:space="preserve">
          <source>A function declared external in one block and then used after the end of the block.</source>
          <target state="translated">在一个区块中声明的外部函数,然后在区块结束后使用。</target>
        </trans-unit>
        <trans-unit id="31442efa0c2c801bce0a5591e6aced95492894fb" translate="yes" xml:space="preserve">
          <source>A function may be given the attribute &lt;code&gt;no_instrument_function&lt;/code&gt;, in which case this instrumentation is not done. This can be used, for example, for the profiling functions listed above, high-priority interrupt routines, and any functions from which the profiling functions cannot safely be called (perhaps signal handlers, if the profiling routines generate output or allocate memory). See &lt;a href=&quot;common-function-attributes#Common-Function-Attributes&quot;&gt;Common Function Attributes&lt;/a&gt;.</source>
          <target state="translated">可以为函数赋予属性 &lt;code&gt;no_instrument_function&lt;/code&gt; ，在这种情况下，不会执行此检测。例如，这可用于上面列出的性能分析函数，高优先级中断例程以及无法安全地从中调用性能概要分析功能的任何函数（如果性能概要分析例程生成输出或分配内存，则可能是信号处理程序）。请参阅&lt;a href=&quot;common-function-attributes#Common-Function-Attributes&quot;&gt;通用功能属性&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a3b5c7a586587400ee92ec622d45d7b4bfd1b3e3" translate="yes" xml:space="preserve">
          <source>A function parameter is declared without a type specifier in K&amp;amp;R-style functions:</source>
          <target state="translated">在K＆R样式的函数中声明的函数参数没有类型说明符：</target>
        </trans-unit>
        <trans-unit id="4a55e26416d74770259268d8b952c442c03d140f" translate="yes" xml:space="preserve">
          <source>A function-like macro that appears without arguments.</source>
          <target state="translated">一个无参数出现的类似函数的宏。</target>
        </trans-unit>
        <trans-unit id="debf2118f99ae7d5fcef4420f2e62948ac9db34c" translate="yes" xml:space="preserve">
          <source>A further version of the C standard, known as &lt;em&gt;C2X&lt;/em&gt;, is under development; experimental and incomplete support for this is enabled with</source>
          <target state="translated">C标准的另一个版本（称为&lt;em&gt;C2X&lt;/em&gt;）正在开发中。实验性和不完整的支持通过以下方式启用</target>
        </trans-unit>
        <trans-unit id="dd4d39a738de423b3a8f7321b1548155edc7437d" translate="yes" xml:space="preserve">
          <source>A general purpose register (GPR), &lt;code&gt;r0&lt;/code&gt;&amp;hellip;&lt;code&gt;r31&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a8db3cc1b660b8c40d207078f962c2f15753e61" translate="yes" xml:space="preserve">
          <source>A general register (&lt;code&gt;r0&lt;/code&gt; to &lt;code&gt;r31&lt;/code&gt;).</source>
          <target state="translated">通用寄存器（ &lt;code&gt;r0&lt;/code&gt; 至 &lt;code&gt;r31&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="4c9d8cf8321530b1a940502b30ac5acf72522d1e" translate="yes" xml:space="preserve">
          <source>A general-purpose register. This is equivalent to &lt;code&gt;r&lt;/code&gt; unless generating MIPS16 code, in which case the MIPS16 register set is used.</source>
          <target state="translated">通用寄存器。除非生成MIPS16代码，否则它等同于 &lt;code&gt;r&lt;/code&gt; ，在这种情况下，将使用MIPS16寄存器集。</target>
        </trans-unit>
        <trans-unit id="d2030f94473ff72afe09286a5000f598b54444ee" translate="yes" xml:space="preserve">
          <source>A generic CPU with 64-bit extensions.</source>
          <target state="translated">64位扩展的通用CPU。</target>
        </trans-unit>
        <trans-unit id="1e6fe121c0bf0b0f224a8bd42e66a0a587219c64" translate="yes" xml:space="preserve">
          <source>A given program is written in one or the other of these two dialects. The program stands a chance to work on most any machine if it is compiled with the proper dialect. It is unlikely to work at all if compiled with the wrong dialect.</source>
          <target state="translated">一个给定的程序是用这两种方言中的一种或另一种编写的。如果用正确的方言编译,该程序有机会在大多数机器上运行,但如果用错误的方言编译,则根本无法运行。如果用错误的方言编译,则根本不可能工作。</target>
        </trans-unit>
        <trans-unit id="6c5058629f496fbd3a9b20ab2118be652c13eb69" translate="yes" xml:space="preserve">
          <source>A good explanation of the benefits offered by ensuring ELF symbols have the correct visibility is given by &amp;ldquo;How To Write Shared Libraries&amp;rdquo; by Ulrich Drepper (which can be found at &lt;a href=&quot;https://www.akkadia.org/drepper/&quot;&gt;https://www.akkadia.org/drepper/&lt;/a&gt;)&amp;mdash;however a superior solution made possible by this option to marking things hidden when the default is public is to make the default hidden and mark things public. This is the norm with DLLs on Windows and with</source>
          <target state="translated">Ulrich Drepper的&amp;ldquo;如何编写共享库&amp;rdquo;（可以在&lt;a href=&quot;https://www.akkadia.org/drepper/&quot;&gt;https://www.akkadia.org/drepper/&lt;/a&gt;上找到）对确保ELF符号具有正确的可见性所带来的好处进行了很好的解释。通过此选项可以在默认设置为public时将事物标记为隐藏的高级解决方案是将默认隐藏并标记为public。这是Windows和DLL上的规范</target>
        </trans-unit>
        <trans-unit id="4b92b6d35d4ef9edd4bc988a5b041656a4bfb9c4" translate="yes" xml:space="preserve">
          <source>A local label declaration looks like this:</source>
          <target state="translated">本地标签声明是这样的。</target>
        </trans-unit>
        <trans-unit id="4eae759733edfeb41cf185aaf992eb0590b9b2a1" translate="yes" xml:space="preserve">
          <source>A local variable or class data member declared both &lt;code&gt;static&lt;/code&gt; and &lt;code&gt;__thread&lt;/code&gt; gives the variable or member thread storage duration.</source>
          <target state="translated">同时声明为 &lt;code&gt;static&lt;/code&gt; 和 &lt;code&gt;__thread&lt;/code&gt; 的局部变量或类数据成员给出了变量或成员线程的存储持续时间。</target>
        </trans-unit>
        <trans-unit id="cbc079ebb13b05a28fc7e6b5c8e9b7e32b012d41" translate="yes" xml:space="preserve">
          <source>A loop expected to iterate at least the selected number of iterations is aligned.</source>
          <target state="translated">一个预期至少迭代选定次数的循环是对齐的。</target>
        </trans-unit>
        <trans-unit id="e6e2fdd4a6e2c1dbe43d588ddf3a77eab778b7d1" translate="yes" xml:space="preserve">
          <source>A member of a union object is accessed using a member of a different type (C90 6.3.2.3).</source>
          <target state="translated">联合对象的成员使用不同类型的成员访问(C90 6.3.2.3)。</target>
        </trans-unit>
        <trans-unit id="d48a8ba2b56e035d8312e0298f36fac9054a9681" translate="yes" xml:space="preserve">
          <source>A memory address based on Y or Z pointer with displacement.</source>
          <target state="translated">基于Y或Z指针的内存地址,并带有位移。</target>
        </trans-unit>
        <trans-unit id="3b84dcc8ac9137874012ebfd9eadab8bb949fee4" translate="yes" xml:space="preserve">
          <source>A memory address suitable for a load/store pair instruction in SI, DI, SF and DF modes</source>
          <target state="translated">适用于SI、DI、SF和DF模式下的加载/存储对指令的内存地址。</target>
        </trans-unit>
        <trans-unit id="0bb3634ff6bc0ca41e70f28fef8acf81311e449f" translate="yes" xml:space="preserve">
          <source>A memory address that will work with the &lt;code&gt;lq&lt;/code&gt; and &lt;code&gt;stq&lt;/code&gt; instructions.</source>
          <target state="translated">可以与 &lt;code&gt;lq&lt;/code&gt; 和 &lt;code&gt;stq&lt;/code&gt; 指令一起使用的内存地址。</target>
        </trans-unit>
        <trans-unit id="e82efce1d813a82c9a30ae4a9287debad5d5c479" translate="yes" xml:space="preserve">
          <source>A memory address which uses a single base register with no offset</source>
          <target state="translated">一个使用单基寄存器的内存地址,没有偏移量。</target>
        </trans-unit>
        <trans-unit id="f6aff7695c779a2c12c72d4158e0a44c684b7687" translate="yes" xml:space="preserve">
          <source>A memory operand accessed with indexed or indirect addressing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9aa32937bb87c45112562669984946bc4a880e43" translate="yes" xml:space="preserve">
          <source>A memory operand addressed by just a base register.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d889b3934276ee507afa50f38217acb1e8a60ca1" translate="yes" xml:space="preserve">
          <source>A memory operand for floating-point loads and stores</source>
          <target state="translated">一个用于浮点加载和存储的内存操作数。</target>
        </trans-unit>
        <trans-unit id="76dff8679e9a8f7ce2eb5bb8fad71047c6747dbc" translate="yes" xml:space="preserve">
          <source>A memory operand is allowed, but only if the address is &lt;em&gt;offsettable&lt;/em&gt;. This means that adding a small integer (actually, the width in bytes of the operand, as determined by its machine mode) may be added to the address and the result is also a valid memory address.</source>
          <target state="translated">允许使用内存操作数，但&lt;em&gt;前提&lt;/em&gt;是地址为&lt;em&gt;offsettable&lt;/em&gt;。这意味着可以将一个小整数（实际上，由操作数的机器模式确定的操作数的字节宽度）添加到该地址，并且结果也是有效的内存地址。</target>
        </trans-unit>
        <trans-unit id="388671fe2c36d60a932779a67c16d85d78ac2d17" translate="yes" xml:space="preserve">
          <source>A memory operand is allowed, with any kind of address that the machine supports in general. Note that the letter used for the general memory constraint can be re-defined by a back end using the &lt;code&gt;TARGET_MEM_CONSTRAINT&lt;/code&gt; macro.</source>
          <target state="translated">允许使用内存操作数，以及机器通常支持的任何类型的地址。注意，用于常规内存约束的字母可以由后端使用 &lt;code&gt;TARGET_MEM_CONSTRAINT&lt;/code&gt; 宏重新定义。</target>
        </trans-unit>
        <trans-unit id="e12c184fcd9f0721bc91e2359dd6f356789155c7" translate="yes" xml:space="preserve">
          <source>A memory operand suitable for Nios II R2 load/store exclusive instructions.</source>
          <target state="translated">一个适合Nios II R2加载/存储专用指令的内存操作数。</target>
        </trans-unit>
        <trans-unit id="7146411d4e212e3eace6ea02064bc67368c7d22e" translate="yes" xml:space="preserve">
          <source>A memory operand suitable for load/store IO and cache instructions.</source>
          <target state="translated">一个适合于加载/存储IO和缓存指令的内存操作数。</target>
        </trans-unit>
        <trans-unit id="40ed4ba7f90bf88673d73789aca447219b51285c" translate="yes" xml:space="preserve">
          <source>A memory operand suitable for the ISA 3.0 vector d-form instructions.</source>
          <target state="translated">适合ISA 3.0向量d型指令的内存操作数。</target>
        </trans-unit>
        <trans-unit id="84bfbe27f0967bbd8165fcff340f78cb41e95ca2" translate="yes" xml:space="preserve">
          <source>A memory operand that can be used as the destination operand of an integer store instruction</source>
          <target state="translated">一个内存操作数,可以作为整数存储指令的目的操作数。</target>
        </trans-unit>
        <trans-unit id="96695f63007ab0923706713901f4b85b969e2a0a" translate="yes" xml:space="preserve">
          <source>A memory operand that is not offsettable. In other words, anything that would fit the &amp;lsquo;</source>
          <target state="translated">不可偏移的内存操作数。换句话说，任何符合&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="1a801a13c9b53ba2ca78c13cc2cdf8d621afb8bd" translate="yes" xml:space="preserve">
          <source>A memory operand whose address is formed by a base register and offset that is suitable for use in instructions with the same addressing mode as &lt;code&gt;ll&lt;/code&gt; and &lt;code&gt;sc&lt;/code&gt;.</source>
          <target state="translated">一个内存操作数，其地址由基址寄存器和偏移量组成，适用于具有与 &lt;code&gt;ll&lt;/code&gt; 和 &lt;code&gt;sc&lt;/code&gt; 相同的寻址模式的指令。</target>
        </trans-unit>
        <trans-unit id="0cf579681538dd24f4c522430fbc1d9db816f237" translate="yes" xml:space="preserve">
          <source>A memory operand with autodecrement addressing (either predecrement or postdecrement) is allowed. In inline &lt;code&gt;asm&lt;/code&gt; this constraint is only allowed if the operand is used exactly once in an instruction that can handle the side effects. Not using an operand with &amp;lsquo;</source>
          <target state="translated">允许使用具有自动减量寻址（前减量或后减量）的内存操作数。 &lt;code&gt;asm&lt;/code&gt; 联汇编中，仅当操作数在可以处理副作用的指令中仅使用一次时，才允许使用此约束。不将操作数与'</target>
        </trans-unit>
        <trans-unit id="cdc334ade8276d0cf5a4c832b12ab9caa48613bc" translate="yes" xml:space="preserve">
          <source>A memory operand with autoincrement addressing (either preincrement or postincrement) is allowed. In inline &lt;code&gt;asm&lt;/code&gt; the same restrictions as for &amp;lsquo;</source>
          <target state="translated">允许使用具有自动递增寻址（预递增或后递增）的内存操作数。内联 &lt;code&gt;asm&lt;/code&gt; 与&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="5ac646a0970be5dfa33196ede31cf6694433d2fe" translate="yes" xml:space="preserve">
          <source>A memory operand. Normally, &lt;code&gt;m&lt;/code&gt; does not allow addresses that update the base register. If the &lt;code&gt;&amp;lt;&lt;/code&gt; or &lt;code&gt;&amp;gt;&lt;/code&gt; constraint is also used, they are allowed and therefore on PowerPC targets in that case it is only safe to use &lt;code&gt;m&amp;lt;&amp;gt;&lt;/code&gt; in an &lt;code&gt;asm&lt;/code&gt; statement if that &lt;code&gt;asm&lt;/code&gt; statement accesses the operand exactly once. The &lt;code&gt;asm&lt;/code&gt; statement must also use &lt;code&gt;%U&lt;var&gt;&amp;lt;opno&amp;gt;&lt;/var&gt;&lt;/code&gt; as a placeholder for the &amp;ldquo;update&amp;rdquo; flag in the corresponding load or store instruction. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4c1412da74dea8e31160c68dd4c58d9ddd39d1e" translate="yes" xml:space="preserve">
          <source>A memory reference suitable for VFP load/store insns (reg+constant offset)</source>
          <target state="translated">适用于VFP加载/存储INS的内存参考(reg+常量偏移)</target>
        </trans-unit>
        <trans-unit id="3a8bf2f192d44bf25c5dafeee0b8eaa22bcc9154" translate="yes" xml:space="preserve">
          <source>A memory reference suitable for iWMMXt load/store instructions.</source>
          <target state="translated">适合iWMMXt加载/存储指令的内存参考。</target>
        </trans-unit>
        <trans-unit id="4b919c81ffb39ef6f8f9eb3d7ccc854afd2048d5" translate="yes" xml:space="preserve">
          <source>A memory reference suitable for the ARMv4 ldrsb instruction.</source>
          <target state="translated">适合ARMv4 ldrsb指令的内存参考。</target>
        </trans-unit>
        <trans-unit id="0281e56b013121500cc01f595e9459e28872a62b" translate="yes" xml:space="preserve">
          <source>A memory reference that is a stack pop.</source>
          <target state="translated">一个内存引用,是一个堆栈弹出。</target>
        </trans-unit>
        <trans-unit id="19169aa6dfaeac0eed19cdca087e18730184a143" translate="yes" xml:space="preserve">
          <source>A memory reference that is a stack push.</source>
          <target state="translated">一个内存引用,是堆栈推送。</target>
        </trans-unit>
        <trans-unit id="9f8594bf5c6cb542733511c9002f352d41b3d7e8" translate="yes" xml:space="preserve">
          <source>A memory reference that is encoded within the opcode, but not auto-increment or auto-decrement.</source>
          <target state="translated">编码在操作码内的内存引用,但不能自动增量或自动减量。</target>
        </trans-unit>
        <trans-unit id="261f1d2ca930e0206ac633c0e47452ba885dfea6" translate="yes" xml:space="preserve">
          <source>A memory reference that is encoded within the opcode.</source>
          <target state="translated">一个在操作码中编码的内存引用。</target>
        </trans-unit>
        <trans-unit id="9cafdb6d926c7b33945a0f45773363bd841f1c97" translate="yes" xml:space="preserve">
          <source>A memory reference that refers to a constant address of known value.</source>
          <target state="translated">一个内存引用,指的是一个已知值的常量地址。</target>
        </trans-unit>
        <trans-unit id="4d28cbf28c6da1c555a93c693a0088131b65d6af" translate="yes" xml:space="preserve">
          <source>A memory reference using &lt;code&gt;AX&lt;/code&gt;, &lt;code&gt;BC&lt;/code&gt;, &lt;code&gt;DE&lt;/code&gt;, or &lt;code&gt;HL&lt;/code&gt; for the address, for calls.</source>
          <target state="translated">使用 &lt;code&gt;AX&lt;/code&gt; ， &lt;code&gt;BC&lt;/code&gt; ， &lt;code&gt;DE&lt;/code&gt; 或 &lt;code&gt;HL&lt;/code&gt; 作为地址的内存引用，用于调用。</target>
        </trans-unit>
        <trans-unit id="ccd702a76b4ec6cf431d1b3b13c087fda1a005cc" translate="yes" xml:space="preserve">
          <source>A memory reference using &lt;code&gt;BC&lt;/code&gt; as a base register, with an optional offset.</source>
          <target state="translated">使用 &lt;code&gt;BC&lt;/code&gt; 作为基址寄存器的内存引用，具有可选的偏移量。</target>
        </trans-unit>
        <trans-unit id="1b8a2311d7274d21eb0ecc9fab5c05d859421673" translate="yes" xml:space="preserve">
          <source>A memory reference using &lt;code&gt;DE&lt;/code&gt; as a base register, with an optional offset.</source>
          <target state="translated">使用 &lt;code&gt;DE&lt;/code&gt; 作为基址寄存器的内存引用，具有可选的偏移量。</target>
        </trans-unit>
        <trans-unit id="70d9c96a11dbdafd4cd2e7e236553a508e4c91e1" translate="yes" xml:space="preserve">
          <source>A memory reference using &lt;code&gt;DE&lt;/code&gt; as a base register, without any offset.</source>
          <target state="translated">使用 &lt;code&gt;DE&lt;/code&gt; 作为基址寄存器的内存引用，无任何偏移。</target>
        </trans-unit>
        <trans-unit id="e072e18db9eb6bf209deec68cb4227fc0ad73751" translate="yes" xml:space="preserve">
          <source>A memory reference using &lt;code&gt;HL&lt;/code&gt; as a base register, with &lt;code&gt;B&lt;/code&gt; or &lt;code&gt;C&lt;/code&gt; as the index register.</source>
          <target state="translated">使用 &lt;code&gt;HL&lt;/code&gt; 作为基址寄存器，使用 &lt;code&gt;B&lt;/code&gt; 或 &lt;code&gt;C&lt;/code&gt; 作为索引寄存器的内存引用。</target>
        </trans-unit>
        <trans-unit id="df6dc5b742ae15cb0c4a64ea30738791b4c31ce2" translate="yes" xml:space="preserve">
          <source>A memory reference using &lt;code&gt;HL&lt;/code&gt; as a base register, with an optional one-byte offset.</source>
          <target state="translated">使用 &lt;code&gt;HL&lt;/code&gt; 作为基址寄存器的内存引用，具有可选的一字节偏移量。</target>
        </trans-unit>
        <trans-unit id="ddc26c1495756f4b844ddb7cea2453b5108af343" translate="yes" xml:space="preserve">
          <source>A memory reference using &lt;code&gt;HL&lt;/code&gt; as a base register, without any offset.</source>
          <target state="translated">使用 &lt;code&gt;HL&lt;/code&gt; 作为基址寄存器的内存引用，没有任何偏移量。</target>
        </trans-unit>
        <trans-unit id="dd84b756a68010a9ef8c97c933ab58752c08401e" translate="yes" xml:space="preserve">
          <source>A memory reference using &lt;code&gt;SP&lt;/code&gt; as a base register, with an optional one-byte offset.</source>
          <target state="translated">使用 &lt;code&gt;SP&lt;/code&gt; 作为基址寄存器的内存引用，具有可选的一字节偏移量。</target>
        </trans-unit>
        <trans-unit id="8838226960a63f5221b0e15609b574e60c61f473" translate="yes" xml:space="preserve">
          <source>A memory reference using any 16-bit register pair for the address, for calls.</source>
          <target state="translated">使用任意16位寄存器对地址的内存引用,用于调用。</target>
        </trans-unit>
        <trans-unit id="4b51e9b71c2545b5652560bf7f6a9647e0035d8a" translate="yes" xml:space="preserve">
          <source>A memory reference where the exact address is in a single register (&amp;lsquo;&amp;lsquo;</source>
          <target state="translated">确切的地址在单个寄存器中的内存引用（''</target>
        </trans-unit>
        <trans-unit id="0139bd65b0b5d2fe4673870edd7d6641449c58e8" translate="yes" xml:space="preserve">
          <source>A memory reference which requires an additional word (address or offset) after the opcode.</source>
          <target state="translated">需要在操作码后增加一个字(地址或偏移量)的内存引用。</target>
        </trans-unit>
        <trans-unit id="9a543e86cece309b6602d80f4120038bbc4ab307" translate="yes" xml:space="preserve">
          <source>A memory reference with an absolute address.</source>
          <target state="translated">一个带有绝对地址的内存引用。</target>
        </trans-unit>
        <trans-unit id="287d82bed5f1580615ce42d8bee2ee48ebecfb48" translate="yes" xml:space="preserve">
          <source>A memory transaction commits all changes to memory in an atomic way, as visible to other threads. If the transaction fails it is rolled back and all side effects discarded.</source>
          <target state="translated">一个内存事务以原子方式提交所有对内存的更改,其他线程可见。如果事务失败,它将被回滚,所有的副作用都被丢弃。</target>
        </trans-unit>
        <trans-unit id="d7f155128a2791cfe10b2a9e15921858bd575c02" translate="yes" xml:space="preserve">
          <source>A nested function always has no linkage. Declaring one with &lt;code&gt;extern&lt;/code&gt; or &lt;code&gt;static&lt;/code&gt; is erroneous. If you need to declare the nested function before its definition, use &lt;code&gt;auto&lt;/code&gt; (which is otherwise meaningless for function declarations).</source>
          <target state="translated">嵌套函数始终没有链接。用 &lt;code&gt;extern&lt;/code&gt; 或 &lt;code&gt;static&lt;/code&gt; 声明一个是错误的。如果需要在定义嵌套函数之前先声明它，请使用 &lt;code&gt;auto&lt;/code&gt; （否则对于函数声明是没有意义的）。</target>
        </trans-unit>
        <trans-unit id="d26414fbc961f98329967917d426b4cbc2efe330" translate="yes" xml:space="preserve">
          <source>A nested function can jump to a label inherited from a containing function, provided the label is explicitly declared in the containing function (see &lt;a href=&quot;local-labels#Local-Labels&quot;&gt;Local Labels&lt;/a&gt;). Such a jump returns instantly to the containing function, exiting the nested function that did the &lt;code&gt;goto&lt;/code&gt; and any intermediate functions as well. Here is an example:</source>
          <target state="translated">嵌套函数可以跳转到从包含函数继承的标签，只要该标签在包含函数中显式声明（请参见&lt;a href=&quot;local-labels#Local-Labels&quot;&gt;Local Labels&lt;/a&gt;）。这样的跳转立即返回到包含函数，退出执行了 &lt;code&gt;goto&lt;/code&gt; 的嵌套函数以及任何中间函数。这是一个例子：</target>
        </trans-unit>
        <trans-unit id="0712d7fc676044f053a72419ea0e38ad815c6a04" translate="yes" xml:space="preserve">
          <source>A new edition of the ISO C standard was published in 1999 as ISO/IEC 9899:1999, and is commonly known as &lt;em&gt;C99&lt;/em&gt;. (While in development, drafts of this standard version were referred to as &lt;em&gt;C9X&lt;/em&gt;.) GCC has substantially complete support for this standard version; see &lt;a href=&quot;http://gcc.gnu.org/c99status.html&quot;&gt;http://gcc.gnu.org/c99status.html&lt;/a&gt; for details. To select this standard, use</source>
          <target state="translated">ISO C标准的新版本于1999年作为ISO / IEC 9899：1999发布，通常称为&lt;em&gt;C99&lt;/em&gt;。（在开发过程中，此标准版本的草案被称为&lt;em&gt;C9X&lt;/em&gt;。）GCC对该标准版本具有基本完整的支持；请参见参考。有关详细信息，请参见&lt;a href=&quot;http://gcc.gnu.org/c99status.html&quot;&gt;http://gcc.gnu.org/c99status.html&lt;/a&gt;。要选择此标准，请使用</target>
        </trans-unit>
        <trans-unit id="c1d3e8da2b16b837e350778965a42d38a1727ecd" translate="yes" xml:space="preserve">
          <source>A non-&lt;code&gt;static&lt;/code&gt; function declaration follows a &lt;code&gt;static&lt;/code&gt; one. This construct is not accepted by some traditional C compilers.</source>
          <target state="translated">非 &lt;code&gt;static&lt;/code&gt; 函数声明跟在 &lt;code&gt;static&lt;/code&gt; 声明之后。一些传统的C编译器不接受此构造。</target>
        </trans-unit>
        <trans-unit id="a1561d49e6959fd563ec43b519d5c367906c49ac" translate="yes" xml:space="preserve">
          <source>A number of bytes.</source>
          <target state="translated">一个字节的数量。</target>
        </trans-unit>
        <trans-unit id="c6e4f37a3cc64090cf8998b7f43d11b497869792" translate="yes" xml:space="preserve">
          <source>A operand which is read by the instruction can be tied to an earlyclobber operand if its only use as an input occurs before the early result is written. Adding alternatives of this form often allows GCC to produce better code when only some of the read operands can be affected by the earlyclobber. See, for example, the &amp;lsquo;</source>
          <target state="translated">如果指令仅将其用作输入，而在写入早期结果之前，则该指令读取的操作数可以与早期用户操作数绑定。当只有部分读取操作数会受到早期用户的影响时，添加这种形式的替代项通常会使GCC产生更好的代码。例如，参见&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="33c89233be593b8efaeda5d8e73bec02c063a6ed" translate="yes" xml:space="preserve">
          <source>A parameter to control whether to use function internal id in profile database lookup. If the value is 0, the compiler uses an id that is based on function assembler name and filename, which makes old profile data more tolerant to source changes such as function reordering etc.</source>
          <target state="translated">一个参数,用于控制是否在配置文件数据库查询中使用函数内部id。如果值为0,编译器会使用一个基于函数汇编器名和文件名的id,这使得旧的profile数据对函数重新排序等源码变化的容忍度更高。</target>
        </trans-unit>
        <trans-unit id="ac02409b28e4665594149c1f072d2a778a5e74f5" translate="yes" xml:space="preserve">
          <source>A pointer is compared against integer zero with &lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;, or &lt;code&gt;&amp;gt;=&lt;/code&gt;.</source>
          <target state="translated">使用 &lt;code&gt;&amp;lt;&lt;/code&gt; ， &lt;code&gt;&amp;lt;=&lt;/code&gt; ， &lt;code&gt;&amp;gt;&lt;/code&gt; 或 &lt;code&gt;&amp;gt;=&lt;/code&gt; 将指针与整数零进行比较。</target>
        </trans-unit>
        <trans-unit id="5e654ce5ba59b63225116cee29f29b754f51ae4a" translate="yes" xml:space="preserve">
          <source>A possibly empty comma-separated list of expressions. For example, &lt;code&gt;format_arg&lt;/code&gt; attributes use this form with the list being a single integer constant expression, and &lt;code&gt;alias&lt;/code&gt; attributes use this form with the list being a single string constant.</source>
          <target state="translated">可能为空的逗号分隔的表达式列表。例如， &lt;code&gt;format_arg&lt;/code&gt; 属性使用此形式，列表为单个整数常量表达式， &lt;code&gt;alias&lt;/code&gt; 属性使用此形式，列表为单个字符串常量。</target>
        </trans-unit>
        <trans-unit id="6f94ad7a128da59e35cfef4198c05f92370ba7a7" translate="yes" xml:space="preserve">
          <source>A precompiled header cannot be used once the first C token is seen. You can have preprocessor directives before a precompiled header; you cannot include a precompiled header from inside another header.</source>
          <target state="translated">一旦看到第一个C标记,就不能使用预编译的头。你可以在预编译头之前有预处理器指令;你不能在另一个头里面包含一个预编译头。</target>
        </trans-unit>
        <trans-unit id="967ed292b7da3d9c381bae6f412c1eb711012203" translate="yes" xml:space="preserve">
          <source>A precompiled header file can be used only when these conditions apply:</source>
          <target state="translated">只有当这些条件适用时,才能使用预编译的头文件。</target>
        </trans-unit>
        <trans-unit id="05035041744377e6b9210288a1d05f98595669e6" translate="yes" xml:space="preserve">
          <source>A precompiled header file is searched for when &lt;code&gt;#include&lt;/code&gt; is seen in the compilation. As it searches for the included file (see &lt;a href=&quot;http://gcc.gnu.org/onlinedocs/cpp/Search-Path.html#Search-Path&quot;&gt;Search Path&lt;/a&gt; in The C Preprocessor) the compiler looks for a precompiled header in each directory just before it looks for the include file in that directory. The name searched for is the name specified in the &lt;code&gt;#include&lt;/code&gt; with &amp;lsquo;</source>
          <target state="translated">当在编译中看到 &lt;code&gt;#include&lt;/code&gt; 时，将搜索预编译的头文件。在搜索包含文件时（请参见C预处理器中的&lt;a href=&quot;http://gcc.gnu.org/onlinedocs/cpp/Search-Path.html#Search-Path&quot;&gt;搜索路径&lt;/a&gt;），编译器将在每个目录中查找包含文件之前，先在每个目录中查找预编译的头。搜索的名称是 &lt;code&gt;#include&lt;/code&gt; 中用'</target>
        </trans-unit>
        <trans-unit id="65201eadf5d675527c7f1ac85fd378b5ccbc08ee" translate="yes" xml:space="preserve">
          <source>A prefix for source file names to remove when generating the output coverage files. This option is useful when building in a separate directory, and the pathname to the source directory is not wanted when determining the output file names. Note that this prefix detection is applied before determining whether the source file is absolute.</source>
          <target state="translated">生成输出覆盖文件时要删除的源文件名的前缀。当在单独的目录中构建,并且在确定输出文件名时不需要源目录的路径名时,该选项非常有用。需要注意的是,这个前缀检测是在确定源文件是否为绝对文件之前应用的。</target>
        </trans-unit>
        <trans-unit id="2f9dfd11eaa793c8913662662201289a00fcaafa" translate="yes" xml:space="preserve">
          <source>A program which performs file I/O and is destined to run on an MCM target should be linked with this option. It causes the libraries libc.a and libdebug.a to be linked. The program should be run on the target under the control of the GDB remote debugging stub.</source>
          <target state="translated">执行文件 I/O 并打算在 MCM 目标机上运行的程序应使用此选项进行链接。它将导致libc.a和libdebug.a库被链接。程序应该在GDB远程调试存根的控制下在目标上运行。</target>
        </trans-unit>
        <trans-unit id="06091d7b0985c9e8feba549f19d66a548c218908" translate="yes" xml:space="preserve">
          <source>A program which performs file I/O and is destined to run on the simulator should be linked with option. This causes libraries libc.a and libsim.a to be linked.</source>
          <target state="translated">一个执行文件I/O并要在模拟器上运行的程序应该用option链接。这将导致库libc.a和libsim.a被链接。</target>
        </trans-unit>
        <trans-unit id="03bc1b8f8194ecc4bd7cc22529202219ccc55928" translate="yes" xml:space="preserve">
          <source>A redeclaration of an entity must not add new ABI tags, since doing so would change the mangled name.</source>
          <target state="translated">实体的重新声明不得添加新的ABI标记,因为这样做会改变被篡改的名称。</target>
        </trans-unit>
        <trans-unit id="72babc8ed783b6f80b238e203c04bb32ab9b7ee7" translate="yes" xml:space="preserve">
          <source>A register indirect memory operand</source>
          <target state="translated">寄存器间接内存操作数</target>
        </trans-unit>
        <trans-unit id="822740a74e2ad86073347ee3e0a96d4ea21793b7" translate="yes" xml:space="preserve">
          <source>A register operand is allowed provided that it is in a general register.</source>
          <target state="translated">寄存器操作数只要是在普通寄存器中就可以。</target>
        </trans-unit>
        <trans-unit id="c6b4e516f4445d7fd0eb4545cb8bd87379ffb2be" translate="yes" xml:space="preserve">
          <source>A register suitable for use in an indirect jump. This will always be &lt;code&gt;$25&lt;/code&gt; for</source>
          <target state="translated">适用于间接跳转的寄存器。这将永远是 &lt;code&gt;$25&lt;/code&gt; 为</target>
        </trans-unit>
        <trans-unit id="bf74def1fd328fca34b37ccd32d0585450fe7d70" translate="yes" xml:space="preserve">
          <source>A register that can hold a 64 bit value.</source>
          <target state="translated">一个可以容纳64位值的寄存器。</target>
        </trans-unit>
        <trans-unit id="40b15fdd982b6acc2dbd0ac15c94e31ec3b3ecb8" translate="yes" xml:space="preserve">
          <source>A revised ISO C++ standard was published in 2011 as ISO/IEC 14882:2011, and is referred to as C++11; before its publication it was commonly referred to as C++0x. C++11 contains several changes to the C++ language, all of which have been implemented in GCC. For details see &lt;a href=&quot;https://gcc.gnu.org/projects/cxx-status.html#cxx11&quot;&gt;https://gcc.gnu.org/projects/cxx-status.html#cxx11&lt;/a&gt;. To select this standard in GCC, use the option</source>
          <target state="translated">修订后的ISO C ++标准于2011年发布为ISO / IEC 14882：2011，被称为C ++ 11。在其发布之前，它通常被称为C ++ 0x。 C ++ 11包含对C ++语言的一些更改，所有这些更改均已在GCC中实现。有关详细信息，请参见&lt;a href=&quot;https://gcc.gnu.org/projects/cxx-status.html#cxx11&quot;&gt;https://gcc.gnu.org/projects/cxx-status.html#cxx11&lt;/a&gt;。要在GCC中选择此标准，请使用</target>
        </trans-unit>
        <trans-unit id="fa1cdaecb062b94545ea6452cf8e926ff17ef618" translate="yes" xml:space="preserve">
          <source>A scalar volatile object is read when it is accessed in a void context:</source>
          <target state="translated">当在void上下文中访问一个标量volatile对象时,就会被读取。</target>
        </trans-unit>
        <trans-unit id="1be35e4d0dcffaec4e53c70345395a20bb71df65" translate="yes" xml:space="preserve">
          <source>A scaled or unscaled indexed memory operand</source>
          <target state="translated">缩放或不缩放的索引存储器操作数。</target>
        </trans-unit>
        <trans-unit id="7561d823e8220cc1324112197c014a5470da6511" translate="yes" xml:space="preserve">
          <source>A signed 10-bit constant for most arithmetic instructions.</source>
          <target state="translated">一个有符号的10位常数,用于大多数算术指令。</target>
        </trans-unit>
        <trans-unit id="d4172f55ed8446ca35d32bcd89906fb5748ddaf8" translate="yes" xml:space="preserve">
          <source>A signed 11-bit constant added to -1. Can only match when the</source>
          <target state="translated">一个有符号的11位常数加到-1。只有当</target>
        </trans-unit>
        <trans-unit id="4dbec6f25e372e0d0975d4d90b4ec971a46651e9" translate="yes" xml:space="preserve">
          <source>A signed 11-bit constant.</source>
          <target state="translated">一个有签名的11位常数。</target>
        </trans-unit>
        <trans-unit id="c5fd23196153b5c02da9d3addd039cf5332baffd" translate="yes" xml:space="preserve">
          <source>A signed 12-bit integer constant.</source>
          <target state="translated">一个有符号的12位整数常数。</target>
        </trans-unit>
        <trans-unit id="5d45116f20daaebe383530883ac080de0bcc23a5" translate="yes" xml:space="preserve">
          <source>A signed 15-bit constant.</source>
          <target state="translated">一个有签名的15位常数。</target>
        </trans-unit>
        <trans-unit id="5e37ec7562e7c67e3ef533934ac18db7a4d66259" translate="yes" xml:space="preserve">
          <source>A signed 16 bit immediate for &lt;code&gt;stop&lt;/code&gt;.</source>
          <target state="translated">立即签名的16位 &lt;code&gt;stop&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5d1f2bec644b602c55ff93653291917c0bee1cb5" translate="yes" xml:space="preserve">
          <source>A signed 16-bit constant (for arithmetic instructions).</source>
          <target state="translated">一个有符号的16位常数(用于算术指令)。</target>
        </trans-unit>
        <trans-unit id="1040a418b2933ba39c0db5d1c19b995428a5db61" translate="yes" xml:space="preserve">
          <source>A signed 16-bit constant shifted left 16 bits.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="426c500fe95b660ec71d2075e660305546d46c08" translate="yes" xml:space="preserve">
          <source>A signed 16-bit constant.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e07498a95ff964b95b70f9332548c0e101c48af" translate="yes" xml:space="preserve">
          <source>A signed 32-bit constant in which the lower 16 bits are zero. Such constants can be loaded using &lt;code&gt;lui&lt;/code&gt;.</source>
          <target state="translated">有符号的32位常量，其中低16位为零。可以使用 &lt;code&gt;lui&lt;/code&gt; 加载此类常量。</target>
        </trans-unit>
        <trans-unit id="536e9bf9352073c69bfd1331260c3d50c75e4c4c" translate="yes" xml:space="preserve">
          <source>A signed 34-bit integer constant if prefixed instructions are supported.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a13d86f9687e787e9b67a4048c3e6f6a0a655af" translate="yes" xml:space="preserve">
          <source>A single register. If &lt;var&gt;n&lt;/var&gt; is in the range 0 to 7, the corresponding D register. If it is &lt;code&gt;A&lt;/code&gt;, then the register P0.</source>
          <target state="translated">一个寄存器。如果 &lt;var&gt;n&lt;/var&gt; 在0到7的范围内，则对应的D寄存器。如果它是 &lt;code&gt;A&lt;/code&gt; ，则寄存器P0。</target>
        </trans-unit>
        <trans-unit id="862eefd77275509cc300d2e8b64b0bd59d6e0627" translate="yes" xml:space="preserve">
          <source>A specification has the syntax [&amp;lsquo;</source>
          <target state="translated">规范的语法为['</target>
        </trans-unit>
        <trans-unit id="8b75792a16ebbcbf75343206f45b552f9ca68dac" translate="yes" xml:space="preserve">
          <source>A status register (&lt;code&gt;rmsr&lt;/code&gt;, &lt;code&gt;$fcc1&lt;/code&gt; to &lt;code&gt;$fcc7&lt;/code&gt;).</source>
          <target state="translated">状态寄存器（ &lt;code&gt;rmsr&lt;/code&gt; ， &lt;code&gt;$fcc1&lt;/code&gt; 至 &lt;code&gt;$fcc7&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="8617da8fc23fdb13a32d7e55b2af3a58c983bdf6" translate="yes" xml:space="preserve">
          <source>A string constant specifying constraints on the placement of the operand; See &lt;a href=&quot;constraints#Constraints&quot;&gt;Constraints&lt;/a&gt;, for details.</source>
          <target state="translated">一个字符串常量，它指定对操作数的放置的限制；有关详细信息，请参见&lt;a href=&quot;constraints#Constraints&quot;&gt;约束&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4bed63450bff092e0c3ca584fb2ddae5e2d82e2a" translate="yes" xml:space="preserve">
          <source>A structure containing a flexible array member, or a union containing such a structure (possibly recursively), may not be a member of a structure or an element of an array. (However, these uses are permitted by GCC as extensions.)</source>
          <target state="translated">一个包含灵活数组成员的结构,或包含这样一个结构的联合体(可能是递归的),不能成为结构的成员或数组的元素。然而,这些用途作为扩展是被GCC所允许的)。</target>
        </trans-unit>
        <trans-unit id="13f3f44cecb7edd4bea911bfc4063d4f75195a8c" translate="yes" xml:space="preserve">
          <source>A symbol in the text segment of the current file</source>
          <target state="translated">当前文件文本段中的一个符号。</target>
        </trans-unit>
        <trans-unit id="55a9278d05f000d4c7a06aca9fe905b8fb5008bb" translate="yes" xml:space="preserve">
          <source>A symbol reference.</source>
          <target state="translated">一个符号参考。</target>
        </trans-unit>
        <trans-unit id="ceac75b89def52cbcbd311ef92b55a54ff3eba6e" translate="yes" xml:space="preserve">
          <source>A symbolic operand, or a 16-bit fragment of a got, tls, or pc-relative reference.</source>
          <target state="translated">一个符号操作数,或一个16位的got、tls或pc-relative引用的片段。</target>
        </trans-unit>
        <trans-unit id="bb721a7785396c7acd1586d0fc279449394dcfd8" translate="yes" xml:space="preserve">
          <source>A template with a non-type template parameter of reference type was mangled incorrectly:</source>
          <target state="translated">引用类型的非类型模板参数的模板被错误地混入。</target>
        </trans-unit>
        <trans-unit id="3af936ccb51639cb634f6ac0a1e094ce5a6bd006" translate="yes" xml:space="preserve">
          <source>A text segment (program memory) constant label.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2953b18cce576e52d1d65cb76238b4c46802eda8" translate="yes" xml:space="preserve">
          <source>A threshold on the average loop count considered by the swing modulo scheduler.</source>
          <target state="translated">摆动模数调度器考虑的平均循环次数的阈值。</target>
        </trans-unit>
        <trans-unit id="7b4948261ad39b1701b8001a691f2c0f51ef54c3" translate="yes" xml:space="preserve">
          <source>A trampoline is a small piece of code that is created at run time on the stack when the address of a nested function is taken, and is used to call the nested function indirectly. Therefore, it requires the stack to be made executable in order for the program to work properly.</source>
          <target state="translated">蹦床是运行时在栈上取嵌套函数地址时产生的一小段代码,用于间接调用嵌套函数。因此,它需要使堆栈可以执行,程序才能正常运行。</target>
        </trans-unit>
        <trans-unit id="78cd7e495c30fc4bf5a59f6f14ffc8c61dbbd59b" translate="yes" xml:space="preserve">
          <source>A true dependence from store to load is costly.</source>
          <target state="translated">从门店到负载,真正的依赖是需要成本的。</target>
        </trans-unit>
        <trans-unit id="5307fd85f09fc936e5444911a1b34c9fbd27e507" translate="yes" xml:space="preserve">
          <source>A typical use of this option is building a kernel that does not use, and hence need not save and restore, any floating-point registers.</source>
          <target state="translated">这个选项的典型用途是构建一个不使用浮点寄存器的内核,因此不需要保存和还原任何浮点寄存器。</target>
        </trans-unit>
        <trans-unit id="7040b335818f1c7fc002704e20a47588f7532dc4" translate="yes" xml:space="preserve">
          <source>A valid &lt;code&gt;NULL&lt;/code&gt; in this context is defined as zero with any object pointer type. If your system defines the &lt;code&gt;NULL&lt;/code&gt; macro with an integer type then you need to add an explicit cast. During installation GCC replaces the system &lt;code&gt;&amp;lt;stddef.h&amp;gt;&lt;/code&gt; header with a copy that redefines NULL appropriately.</source>
          <target state="translated">在任何情况下，任何对象指针类型都将有效 &lt;code&gt;NULL&lt;/code&gt; 定义为零。如果您的系统使用整数类型定义 &lt;code&gt;NULL&lt;/code&gt; 宏，则需要添加显式强制转换。在安装过程中，GCC将系统 &lt;code&gt;&amp;lt;stddef.h&amp;gt;&lt;/code&gt; 标头替换为适当重新定义NULL的副本。</target>
        </trans-unit>
        <trans-unit id="02bba8846c50f28733626cee0f5e6cd6eae5f547" translate="yes" xml:space="preserve">
          <source>A value for this option must be provided; possible values are</source>
          <target state="translated">必须为该选项提供一个值;可能的值是</target>
        </trans-unit>
        <trans-unit id="28bdc15a4774baf30748fb10f9a39ee9576d0acc" translate="yes" xml:space="preserve">
          <source>A value of -1 means we don&amp;rsquo;t have a threshold and therefore prefetch hints can be issued for any constant stride.</source>
          <target state="translated">值为-1表示我们没有阈值，因此可以为任何恒定步幅发出预取提示。</target>
        </trans-unit>
        <trans-unit id="77182ee8e74fbc85f274ec34ad0d067f9159c03c" translate="yes" xml:space="preserve">
          <source>A vector constant</source>
          <target state="translated">一个向量常数</target>
        </trans-unit>
        <trans-unit id="25a5a3c85e4d61bb20e699b708ea293eab97d102" translate="yes" xml:space="preserve">
          <source>A vector constant is a list of constant expressions within curly braces.</source>
          <target state="translated">向量常量是大括号内的常量表达式列表。</target>
        </trans-unit>
        <trans-unit id="4903fd385e6b83744a3f7241ee469fe297e3d890" translate="yes" xml:space="preserve">
          <source>A vector initializer requires no cast if the vector constant is of the same type as the variable it is initializing.</source>
          <target state="translated">如果向量常量与初始化的变量类型相同,那么向量初始化器就不需要投掷。</target>
        </trans-unit>
        <trans-unit id="6ce3f2c4c36ebf953052d74dd8cf41bfa72eda5d" translate="yes" xml:space="preserve">
          <source>A weak reference is an alias that does not by itself require a definition to be given for the target symbol. If the target symbol is only referenced through weak references, then it becomes a &lt;code&gt;weak&lt;/code&gt; undefined symbol. If it is directly referenced, however, then such strong references prevail, and a definition is required for the symbol, not necessarily in the same translation unit.</source>
          <target state="translated">弱引用是一种别名，它本身不需要为目标符号给出定义。如果仅通过弱引用来引用目标符号，则它将变为 &lt;code&gt;weak&lt;/code&gt; 未定义符号。但是，如果直接引用，则以此类引用为准，并且需要对符号进行定义，而不必在同一翻译单元中进行定义。</target>
        </trans-unit>
        <trans-unit id="74b379dc012a6dcd931f8c8cdffa0c221d2777a0" translate="yes" xml:space="preserve">
          <source>AArch64</source>
          <target state="translated">AArch64</target>
        </trans-unit>
        <trans-unit id="d83fa522cc15ecf666a6fc12658b5e4cd5fdc010" translate="yes" xml:space="preserve">
          <source>AArch64 family&amp;mdash;</source>
          <target state="translated">AArch64系列&amp;mdash;</target>
        </trans-unit>
        <trans-unit id="4957a12f9c33bdb7711f6bad443bcf1b59bf30ce" translate="yes" xml:space="preserve">
          <source>ABI conformance</source>
          <target state="translated">ABI一致性</target>
        </trans-unit>
        <trans-unit id="b14e4cc3f9a03a17ac3f6123a6226b7b7d34c952" translate="yes" xml:space="preserve">
          <source>ADDENDUM: How to use this License for your documents</source>
          <target state="translated">附加说明:如何在您的文件中使用本许可证</target>
        </trans-unit>
        <trans-unit id="1f0161097b4d6be2ad809b71f0ab06f4ccc56e03" translate="yes" xml:space="preserve">
          <source>AES instructions.</source>
          <target state="translated">AES指令。</target>
        </trans-unit>
        <trans-unit id="bd84aa567f4fd80f10ee4bdc1fff46ff3f84291a" translate="yes" xml:space="preserve">
          <source>AIX TOC entry</source>
          <target state="translated">AIX TOC条目</target>
        </trans-unit>
        <trans-unit id="00c79d98f4ab13b1e68350376a159f81803c3f05" translate="yes" xml:space="preserve">
          <source>AIX on the RS/6000 provides support (NLS) for environments outside of the United States. Compilers and assemblers use NLS to support locale-specific representations of various objects including floating-point numbers (&amp;lsquo;</source>
          <target state="translated">RS / 6000上的AIX为美国以外的环境提供支持（NLS）。编译器和汇编器使用NLS支持各种对象的特定于语言环境的表示形式，包括浮点数（'</target>
        </trans-unit>
        <trans-unit id="6b42874e3cd20771d93096ec5ce36307a1f2ba14" translate="yes" xml:space="preserve">
          <source>ALL</source>
          <target state="translated">ALL</target>
        </trans-unit>
        <trans-unit id="e38876cb454c616d20b014174318cd23549c31b5" translate="yes" xml:space="preserve">
          <source>AM33</source>
          <target state="translated">AM33</target>
        </trans-unit>
        <trans-unit id="b0f3c857fc3329c9a7706ca2852892a64907ff92" translate="yes" xml:space="preserve">
          <source>AMD Athlon CPU with MMX, 3dNOW!, enhanced 3DNow! and SSE prefetch instructions support.</source>
          <target state="translated">AMD Athlon CPU,支持MMX、3dNOW!、增强型3DNow!和SSE预取指令。</target>
        </trans-unit>
        <trans-unit id="9782812fedc19dae1f691ec0b75b46ce928e9504" translate="yes" xml:space="preserve">
          <source>AMD CPU.</source>
          <target state="translated">AMD的CPU。</target>
        </trans-unit>
        <trans-unit id="4b7804a001f508699c3a5d535226c1c43f89e201" translate="yes" xml:space="preserve">
          <source>AMD Family 10h Barcelona CPU.</source>
          <target state="translated">AMD家族10h巴塞罗那CPU。</target>
        </trans-unit>
        <trans-unit id="f2f426233bd9b4aec7ad7f0935ada0d98f23dc6d" translate="yes" xml:space="preserve">
          <source>AMD Family 10h CPU.</source>
          <target state="translated">AMD家族10h CPU。</target>
        </trans-unit>
        <trans-unit id="a221df99534b6cfd9cc25151f5b88b631e6b6c74" translate="yes" xml:space="preserve">
          <source>AMD Family 10h Istanbul CPU.</source>
          <target state="translated">AMD家族10h伊斯坦布尔CPU。</target>
        </trans-unit>
        <trans-unit id="3c8a317ded567872f2b86eb3a9b2b3142383086c" translate="yes" xml:space="preserve">
          <source>AMD Family 10h Shanghai CPU.</source>
          <target state="translated">AMD家族10h上海CPU。</target>
        </trans-unit>
        <trans-unit id="3a481ec8025706c39f85bf8a74294ffb3a885a4c" translate="yes" xml:space="preserve">
          <source>AMD Family 14h CPU.</source>
          <target state="translated">AMD家族14h CPU。</target>
        </trans-unit>
        <trans-unit id="d69f21954e9736613dfdcb1541757a89581cb747" translate="yes" xml:space="preserve">
          <source>AMD Family 15h Bulldozer version 1.</source>
          <target state="translated">AMD家族15h推土机版本1。</target>
        </trans-unit>
        <trans-unit id="41ba99ffd8cd8d92353e0abf0591f609003e91a0" translate="yes" xml:space="preserve">
          <source>AMD Family 15h Bulldozer version 2.</source>
          <target state="translated">AMD家族15h推土机2版。</target>
        </trans-unit>
        <trans-unit id="c106e6d754b124070881cb0e9b5ffaec83f58ff6" translate="yes" xml:space="preserve">
          <source>AMD Family 15h Bulldozer version 3.</source>
          <target state="translated">AMD家族15h推土机3版。</target>
        </trans-unit>
        <trans-unit id="162b040bafc7dbe0fec77eb2f6b3a8372fec8cf0" translate="yes" xml:space="preserve">
          <source>AMD Family 15h Bulldozer version 4.</source>
          <target state="translated">AMD家族15h推土机4版。</target>
        </trans-unit>
        <trans-unit id="8b550c62094801a9eaabc1a10c1588d01074f61b" translate="yes" xml:space="preserve">
          <source>AMD Family 15h CPU.</source>
          <target state="translated">AMD家族15h CPU。</target>
        </trans-unit>
        <trans-unit id="6adbeef26c0c63ee2016d0b2ac6031e70f73f984" translate="yes" xml:space="preserve">
          <source>AMD Family 15h core based CPUs with x86-64 instruction set support. (This supersets BMI, BMI2, TBM, F16C, FMA, FMA4, FSGSBASE, AVX, AVX2, XOP, LWP, AES, PCLMUL, CX16, MOVBE, MMX, SSE, SSE2, SSE3, SSE4A, SSSE3, SSE4.1, SSE4.2, ABM and 64-bit instruction set extensions.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3dc29f9ebb58544eff2350911f186ade2077e9e7" translate="yes" xml:space="preserve">
          <source>AMD Family 15h core based CPUs with x86-64 instruction set support. (This supersets BMI, BMI2, TBM, F16C, FMA, FMA4, FSGSBASE, AVX, AVX2, XOP, LWP, AES, PCL_MUL, CX16, MOVBE, MMX, SSE, SSE2, SSE3, SSE4A, SSSE3, SSE4.1, SSE4.2, ABM and 64-bit instruction set extensions.</source>
          <target state="translated">支持x86-64指令集的基于AMD家族15h内核的CPU。(这超越了BMI、BMI2、TBM、F16C、FMA、FMA4、FSGSBASE、AVX、AVX2、XOP、LWP、AES、PCL_MUL、CX16、MOVBE、MMX、SSE、SSE2、SSE3、SSE4A、SSSE3、SSE4.1、SSE4.2、ABM和64位指令集扩展。</target>
        </trans-unit>
        <trans-unit id="afaafd936d606f23e0204241163cd5538d5327ed" translate="yes" xml:space="preserve">
          <source>AMD Family 15h core based CPUs with x86-64 instruction set support. (This supersets BMI, TBM, F16C, FMA, FMA4, AVX, XOP, LWP, AES, PCLMUL, CX16, MMX, SSE, SSE2, SSE3, SSE4A, SSSE3, SSE4.1, SSE4.2, ABM and 64-bit instruction set extensions.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0473fd00ce817690842cab967b3016ac67c8acc" translate="yes" xml:space="preserve">
          <source>AMD Family 15h core based CPUs with x86-64 instruction set support. (This supersets BMI, TBM, F16C, FMA, FMA4, AVX, XOP, LWP, AES, PCL_MUL, CX16, MMX, SSE, SSE2, SSE3, SSE4A, SSSE3, SSE4.1, SSE4.2, ABM and 64-bit instruction set extensions.)</source>
          <target state="translated">支持x86-64指令集的基于15h内核的AMD家族CPU。(这超越了BMI、TBM、F16C、FMA、FMA4、AVX、XOP、LWP、AES、PCL_MUL、CX16、MMX、SSE、SSE2、SSE3、SSE4A、SSSE3、SSE4.1、SSE4.2、ABM和64位指令集扩展。)</target>
        </trans-unit>
        <trans-unit id="62e14a811063bd0f1e3f0931b760b915b408af1e" translate="yes" xml:space="preserve">
          <source>AMD Family 15h core based CPUs with x86-64 instruction set support. (This supersets BMI, TBM, F16C, FMA, FMA4, FSGSBASE, AVX, XOP, LWP, AES, PCLMUL, CX16, MMX, SSE, SSE2, SSE3, SSE4A, SSSE3, SSE4.1, SSE4.2, ABM and 64-bit instruction set extensions.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f30ce336c72904fed1286b4744fb02d22539e6b" translate="yes" xml:space="preserve">
          <source>AMD Family 15h core based CPUs with x86-64 instruction set support. (This supersets BMI, TBM, F16C, FMA, FMA4, FSGSBASE, AVX, XOP, LWP, AES, PCL_MUL, CX16, MMX, SSE, SSE2, SSE3, SSE4A, SSSE3, SSE4.1, SSE4.2, ABM and 64-bit instruction set extensions.</source>
          <target state="translated">支持x86-64指令集的基于15h内核的AMD家族CPU。(这超越了BMI、TBM、F16C、FMA、FMA4、FSGSBASE、AVX、XOP、LWP、AES、PCL_MUL、CX16、MMX、SSE、SSE2、SSE3、SSE4A、SSE3、SSE4.1、SSE4.2、ABM和64位指令集扩展。</target>
        </trans-unit>
        <trans-unit id="d1222a05e9ab4d223a98fe2b005e9a8fe6f149c1" translate="yes" xml:space="preserve">
          <source>AMD Family 16h CPU.</source>
          <target state="translated">AMD家族16h CPU。</target>
        </trans-unit>
        <trans-unit id="275cd046e8c73f55e5a1e1661fd4caf48dfc118a" translate="yes" xml:space="preserve">
          <source>AMD Family 17h CPU.</source>
          <target state="translated">AMD家族17h CPU。</target>
        </trans-unit>
        <trans-unit id="8605196ce8298328039162c5b2196f5f20eefce6" translate="yes" xml:space="preserve">
          <source>AMD Family 17h Zen version 1.</source>
          <target state="translated">AMD家族17h Zen版本1.</target>
        </trans-unit>
        <trans-unit id="7ac5c90de82cdae73bde8fdf83f5571edc22b502" translate="yes" xml:space="preserve">
          <source>AMD Family 17h Zen version 2.</source>
          <target state="translated">AMD家族17h Zen版本2.</target>
        </trans-unit>
        <trans-unit id="87a04068ae7b738101f64aab71cef3ecd2846768" translate="yes" xml:space="preserve">
          <source>AMD Family 17h core based CPUs with x86-64 instruction set support. (This supersets BMI, BMI2, ,CLWB, F16C, FMA, FSGSBASE, AVX, AVX2, ADCX, RDSEED, MWAITX, SHA, CLZERO, AES, PCL_MUL, CX16, MOVBE, MMX, SSE, SSE2, SSE3, SSE4A, SSSE3, SSE4.1, SSE4.2, ABM, XSAVEC, XSAVES, CLFLUSHOPT, POPCNT, and 64-bit instruction set extensions.)</source>
          <target state="translated">支持x86-64指令集的基于AMD家族17h核的CPU。(该指令集超前于BMI、BMI2、 ,CLWB、F16C、FMA、FSGSBASE、AVX、AVX2、ADCX、RDSEED、MWAITX、SHA、CLZERO、AES、PCL_MUL、CX16、MOVBE、MMX、SSE、SSE2、SSE3、SSE4A、SSSE3、SSE4.1、SSE4.2、ABM、XSAVEC、XSAVES、CLFLUSHOPT、POPCNT和64位指令。 1、SSE4.2、ABM、XSAVEC、XSAVES、CLFLUSHOPT、POPCNT和64位指令集扩展)。)</target>
        </trans-unit>
        <trans-unit id="26b9464c770316c8957e5f0dd9332edc81fe410d" translate="yes" xml:space="preserve">
          <source>AMD Family 17h core based CPUs with x86-64 instruction set support. (This supersets BMI, BMI2, CLWB, F16C, FMA, FSGSBASE, AVX, AVX2, ADCX, RDSEED, MWAITX, SHA, CLZERO, AES, PCLMUL, CX16, MOVBE, MMX, SSE, SSE2, SSE3, SSE4A, SSSE3, SSE4.1, SSE4.2, ABM, XSAVEC, XSAVES, CLFLUSHOPT, POPCNT, RDPID, WBNOINVD, and 64-bit instruction set extensions.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37e7bb5b5f5ab7650fa5577e6308f180e065ef83" translate="yes" xml:space="preserve">
          <source>AMD Family 17h core based CPUs with x86-64 instruction set support. (This supersets BMI, BMI2, F16C, FMA, FSGSBASE, AVX, AVX2, ADCX, RDSEED, MWAITX, SHA, CLZERO, AES, PCLMUL, CX16, MOVBE, MMX, SSE, SSE2, SSE3, SSE4A, SSSE3, SSE4.1, SSE4.2, ABM, XSAVEC, XSAVES, CLFLUSHOPT, POPCNT, and 64-bit instruction set extensions.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ae2f9839ab0c946ebf780350ccb8eeef28b2d89" translate="yes" xml:space="preserve">
          <source>AMD Family 17h core based CPUs with x86-64 instruction set support. (This supersets BMI, BMI2, F16C, FMA, FSGSBASE, AVX, AVX2, ADCX, RDSEED, MWAITX, SHA, CLZERO, AES, PCL_MUL, CX16, MOVBE, MMX, SSE, SSE2, SSE3, SSE4A, SSSE3, SSE4.1, SSE4.2, ABM, XSAVEC, XSAVES, CLFLUSHOPT, POPCNT, and 64-bit instruction set extensions.</source>
          <target state="translated">基于AMD家族17h核的CPU,支持x86-64指令集。(该指令集超越了BMI、BMI2、F16C、FMA、FSGSBASE、AVX、AVX2、ADCX、RDSEED、MWAITX、SHA、CLZERO、AES、PCL_MUL、CX16、MOVBE、MMX、SSE、SSE2、SSE3、SS4A、SSSE3、SSE4.1、SSE4.2、ABM、XSAVEC、XSAVES、CLFLUSHOPT、POPCNT以及64位指令集扩展。</target>
        </trans-unit>
        <trans-unit id="eb46d89908f8744c91b1c4f45dca8a1acd1ccb27" translate="yes" xml:space="preserve">
          <source>AMD GCN &amp;mdash;</source>
          <target state="translated">AMD GCN &amp;mdash;</target>
        </trans-unit>
        <trans-unit id="db735b251e571e72d1b413e2700f9028689a9a1f" translate="yes" xml:space="preserve">
          <source>AMD Geode embedded processor with MMX and 3DNow! instruction set support.</source>
          <target state="translated">AMD Geode嵌入式处理器,支持MMX和3DNow!指令集。</target>
        </trans-unit>
        <trans-unit id="3c8e48e665e983d9bc0d85fc904dca86423a0640" translate="yes" xml:space="preserve">
          <source>AMD K6 CPU with MMX instruction set support.</source>
          <target state="translated">AMD K6 CPU,支持MMX指令集。</target>
        </trans-unit>
        <trans-unit id="113a97cdab92673636cc95858168822f55ed3094" translate="yes" xml:space="preserve">
          <source>ANY</source>
          <target state="translated">ANY</target>
        </trans-unit>
        <trans-unit id="c23fd1159b1de92b9f559df33e41326ca8f7ed85" translate="yes" xml:space="preserve">
          <source>ARC &amp;mdash;</source>
          <target state="translated">ARC &amp;mdash;</target>
        </trans-unit>
        <trans-unit id="e3246acd95d4fb7aa3011b3fb00ffb954a2152c1" translate="yes" xml:space="preserve">
          <source>ARC FPX (dpfp) 64-bit registers. &lt;code&gt;D0&lt;/code&gt;, &lt;code&gt;D1&lt;/code&gt;.</source>
          <target state="translated">ARC FPX（dpfp）64位寄存器。 &lt;code&gt;D0&lt;/code&gt; ， &lt;code&gt;D1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2ccf1f7f060d37f54120246cfa7dc75a263926f6" translate="yes" xml:space="preserve">
          <source>ARC HS SIMD support.</source>
          <target state="translated">支持ARC HS SIMD。</target>
        </trans-unit>
        <trans-unit id="932a7f099a143287c2dab636f78bab3d7a1ac45d" translate="yes" xml:space="preserve">
          <source>ARC600</source>
          <target state="translated">ARC600</target>
        </trans-unit>
        <trans-unit id="4e11187f8fc082bb81a4560953a7d52297f319ca" translate="yes" xml:space="preserve">
          <source>ARC601</source>
          <target state="translated">ARC601</target>
        </trans-unit>
        <trans-unit id="db9b6f8ec7c62bb078c4ccd2086414ec10283d1a" translate="yes" xml:space="preserve">
          <source>ARC700</source>
          <target state="translated">ARC700</target>
        </trans-unit>
        <trans-unit id="69f32b824b4367437b84027bd88885eef21e2693" translate="yes" xml:space="preserve">
          <source>ARC700-xmac</source>
          <target state="translated">ARC700-xmac</target>
        </trans-unit>
        <trans-unit id="f05a45c9726afd143f3f3902e0d21ab2ae48650f" translate="yes" xml:space="preserve">
          <source>ARC725D</source>
          <target state="translated">ARC725D</target>
        </trans-unit>
        <trans-unit id="c4f837ba2f5ad05063a4e03989e3391dddb8bc79" translate="yes" xml:space="preserve">
          <source>ARC750D</source>
          <target state="translated">ARC750D</target>
        </trans-unit>
        <trans-unit id="29d8dec43e88b47582179de53ef2720d981e8ab1" translate="yes" xml:space="preserve">
          <source>ARM</source>
          <target state="translated">ARM</target>
        </trans-unit>
        <trans-unit id="888c2ab0ae2033359c10fd5cfdf58bbe2d0a940c" translate="yes" xml:space="preserve">
          <source>ARM family&amp;mdash;</source>
          <target state="translated">ARM系列&amp;mdash;</target>
        </trans-unit>
        <trans-unit id="8a9b87087c41304359e59fe26411a54c3b656947" translate="yes" xml:space="preserve">
          <source>ARM targets support two incompatible representations for half-precision floating-point values. You must choose one of the representations and use it consistently in your program.</source>
          <target state="translated">ARM 目标机支持两种不兼容的半精度浮点值表示法。您必须选择其中一种表示法,并在程序中一致使用。</target>
        </trans-unit>
        <trans-unit id="c7649225dad7c2a0e06a3df7785837ccbdcddf7e" translate="yes" xml:space="preserve">
          <source>AVR family&amp;mdash;</source>
          <target state="translated">AVR系列</target>
        </trans-unit>
        <trans-unit id="b6ce34d1fb413b0acbfa365b9e4b9f6fd56b845e" translate="yes" xml:space="preserve">
          <source>AVX instructions.</source>
          <target state="translated">AVX指令。</target>
        </trans-unit>
        <trans-unit id="5360c6483b9a9e1df7abdcb4de1b9b5a31a7db4c" translate="yes" xml:space="preserve">
          <source>AVX2 instructions.</source>
          <target state="translated">AVX2指令。</target>
        </trans-unit>
        <trans-unit id="1d10807c0ae95d634b933c4c91561b625fdd7ee8" translate="yes" xml:space="preserve">
          <source>AVX5124FMAPS instructions.</source>
          <target state="translated">AVX5124FMAPS说明书。</target>
        </trans-unit>
        <trans-unit id="2877f163ba5f992658ca47acc8b1854f3fe91f8e" translate="yes" xml:space="preserve">
          <source>AVX5124VNNIW instructions.</source>
          <target state="translated">AVX5124VNNIW说明书。</target>
        </trans-unit>
        <trans-unit id="6aaaf18e4ab544cbae42a58b9cf1cac769995f49" translate="yes" xml:space="preserve">
          <source>AVX512BITALG instructions.</source>
          <target state="translated">AVX512BITALG指令。</target>
        </trans-unit>
        <trans-unit id="e6c802e92787ca04a74935e0b7ab771a52b734eb" translate="yes" xml:space="preserve">
          <source>AVX512BW instructions.</source>
          <target state="translated">AVX512BW说明书。</target>
        </trans-unit>
        <trans-unit id="ed3621c799203e17dc8a8e2affcd32cfee406953" translate="yes" xml:space="preserve">
          <source>AVX512CD instructions.</source>
          <target state="translated">AVX512CD说明书。</target>
        </trans-unit>
        <trans-unit id="734e989680da5e12fff96a9678b5efdb7f080ad8" translate="yes" xml:space="preserve">
          <source>AVX512DQ instructions.</source>
          <target state="translated">AVX512DQ说明书。</target>
        </trans-unit>
        <trans-unit id="ab4d6a088fb02d341f438d1a8b690b1d06bd6a6f" translate="yes" xml:space="preserve">
          <source>AVX512ER instructions.</source>
          <target state="translated">AVX512ER说明书。</target>
        </trans-unit>
        <trans-unit id="9e79b06b712a8ed9dc7a5818dbaa8055049287e6" translate="yes" xml:space="preserve">
          <source>AVX512F instructions.</source>
          <target state="translated">AVX512F说明书。</target>
        </trans-unit>
        <trans-unit id="a774d2186ac710be1f1d2b1823b920ecc713d1ba" translate="yes" xml:space="preserve">
          <source>AVX512IFMA instructions.</source>
          <target state="translated">AVX512IFMA说明书。</target>
        </trans-unit>
        <trans-unit id="a01464cdaa2c7a778b9758cae6be675e4fe0b633" translate="yes" xml:space="preserve">
          <source>AVX512PF instructions.</source>
          <target state="translated">AVX512PF说明书。</target>
        </trans-unit>
        <trans-unit id="90f8339b23ce90729e637c7a3a364d024582dd8c" translate="yes" xml:space="preserve">
          <source>AVX512VBMI instructions.</source>
          <target state="translated">AVX512VBMI说明书。</target>
        </trans-unit>
        <trans-unit id="60db97c4b4db27b3430715d1af3a5a33414556d6" translate="yes" xml:space="preserve">
          <source>AVX512VBMI2 instructions.</source>
          <target state="translated">AVX512VBMI2说明书。</target>
        </trans-unit>
        <trans-unit id="4be842cb121c07bbfe15b74f0e979638742b0293" translate="yes" xml:space="preserve">
          <source>AVX512VL instructions.</source>
          <target state="translated">AVX512VL说明书。</target>
        </trans-unit>
        <trans-unit id="644733f8c866e0e47cbcfa44a51986c10011d89b" translate="yes" xml:space="preserve">
          <source>AVX512VNNI instructions.</source>
          <target state="translated">AVX512VNNI说明书。</target>
        </trans-unit>
        <trans-unit id="53a0313f00ad630fa2e77fff34864e43bc34cbe7" translate="yes" xml:space="preserve">
          <source>AVX512VPOPCNTDQ instructions.</source>
          <target state="translated">AVX512VPOPCNTDQ说明书。</target>
        </trans-unit>
        <trans-unit id="94e869970cd001add8f88d68dc06d771dcf6a716" translate="yes" xml:space="preserve">
          <source>Abort the current transaction. When no transaction is active this is a no-op. The &lt;var&gt;status&lt;/var&gt; is an 8-bit constant; its value is encoded in the return value from &lt;code&gt;_xbegin&lt;/code&gt;.</source>
          <target state="translated">中止当前交易。当没有事务处于活动状态时，这是无操作的。该 &lt;var&gt;status&lt;/var&gt; 是一个8位的常数; 其值编码在 &lt;code&gt;_xbegin&lt;/code&gt; 的返回值中。</target>
        </trans-unit>
        <trans-unit id="06529d24f685cb943a5ccbec8926618c923b5a20" translate="yes" xml:space="preserve">
          <source>Absolute comparison of two paired-single values (&lt;code&gt;cabs.&lt;var&gt;cond&lt;/var&gt;.ps&lt;/code&gt;, &lt;code&gt;bc1t&lt;/code&gt;/&lt;code&gt;bc1f&lt;/code&gt;).</source>
          <target state="translated">的两个成对的单值的绝对的比较（ &lt;code&gt;cabs.&lt;var&gt;cond&lt;/var&gt;.ps&lt;/code&gt; ， &lt;code&gt;bc1t&lt;/code&gt; / &lt;code&gt;bc1f&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="df073c7d1c50e06cd4608c23a66611cf902ab538" translate="yes" xml:space="preserve">
          <source>Absolute comparison of two scalar values (&lt;code&gt;cabs.&lt;var&gt;cond&lt;/var&gt;.&lt;var&gt;fmt&lt;/var&gt;&lt;/code&gt;, &lt;code&gt;bc1t&lt;/code&gt;/&lt;code&gt;bc1f&lt;/code&gt;).</source>
          <target state="translated">两个标量值（绝对值比较 &lt;code&gt;cabs.&lt;var&gt;cond&lt;/var&gt;.&lt;var&gt;fmt&lt;/var&gt;&lt;/code&gt; ， &lt;code&gt;bc1t&lt;/code&gt; / &lt;code&gt;bc1f&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="f722ac4229dd26c3b68dd80d6e1f64e995895dbe" translate="yes" xml:space="preserve">
          <source>Absolute value (&lt;code&gt;abs.ps&lt;/code&gt;).</source>
          <target state="translated">绝对值（ &lt;code&gt;abs.ps&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="4daf0f1c1f813e9102db1a5994f1b9e8323b97c9" translate="yes" xml:space="preserve">
          <source>Accept &amp;lsquo;</source>
          <target state="translated">接受&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="1b2da276a5f9c648bf9aca0b0668639225e93b2f" translate="yes" xml:space="preserve">
          <source>Accept imaginary, fixed-point, or machine-defined literal number suffixes as GNU extensions. When this option is turned off these suffixes are treated as C++11 user-defined literal numeric suffixes. This is on by default for all pre-C++11 dialects and all GNU dialects:</source>
          <target state="translated">接受虚数、定点或机器定义的字面数字后缀作为GNU扩展。当这个选项被关闭时,这些后缀将被视为C++11用户定义的文字数字后缀。对于所有C++11之前的方言和所有GNU方言来说,这个选项是默认开启的。</target>
        </trans-unit>
        <trans-unit id="a081bde4daabce186fc90fa0db98f145d7ef25aa" translate="yes" xml:space="preserve">
          <source>Accept some non-standard constructs used in Microsoft header files.</source>
          <target state="translated">接受微软头文件中使用的一些非标准结构。</target>
        </trans-unit>
        <trans-unit id="8ce1e6741eac355bc7dded05833655b003ffbcb7" translate="yes" xml:space="preserve">
          <source>Accept some non-standard constructs used in Plan 9 code.</source>
          <target state="translated">接受计划9代码中使用的一些非标准结构。</target>
        </trans-unit>
        <trans-unit id="d6ca16d1d2f90084c15b7909650d30bcccb6d876" translate="yes" xml:space="preserve">
          <source>Accept universal character names and extended characters in identifiers. This option is enabled by default for C99 (and later C standard versions) and C++.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be39a99ef887dbe2361b7a8f01c005db47949d8d" translate="yes" xml:space="preserve">
          <source>Accept universal character names in identifiers. This option is enabled by default for C99 (and later C standard versions) and C++.</source>
          <target state="translated">在标识符中接受通用字符名。这个选项在C99(以及以后的C标准版本)和C++中是默认启用的。</target>
        </trans-unit>
        <trans-unit id="0f43c08aeb944b0a767a69ba0fb81ec15c2500b4" translate="yes" xml:space="preserve">
          <source>Accept variadic functions without named parameters.</source>
          <target state="translated">接受没有命名参数的变量函数。</target>
        </trans-unit>
        <trans-unit id="045e8c6e57a163b8d206267b0ad429f37b12bd4b" translate="yes" xml:space="preserve">
          <source>Accesses through pointers to types with this attribute are not subject to type-based alias analysis, but are instead assumed to be able to alias any other type of objects. In the context of section 6.5 paragraph 7 of the C99 standard, an lvalue expression dereferencing such a pointer is treated like having a character type. See</source>
          <target state="translated">通过指向具有这种属性的类型的指针的访问不受基于类型的别名分析的限制,而是被认为能够别名任何其他类型的对象。在C99标准第6.5节第7段的上下文中,派生这种指针的l值表达式就像具有字符类型一样。参见</target>
        </trans-unit>
        <trans-unit id="0e0bf5b2a877ef7b91241baabde260a26b7a132e" translate="yes" xml:space="preserve">
          <source>Accesses to bit-fields even in volatile objects works by accessing larger objects, such as a byte or a word. You cannot rely on what size of object is accessed in order to read or write the bit-field; it may even vary for a given bit-field according to the precise usage.</source>
          <target state="translated">即使是在易失性对象中访问位字段,也是通过访问更大的对象,如一个字节或一个字来工作的。你不能依靠访问什么大小的对象来读取或写入位字段,对于一个给定的位字段来说,它甚至可能根据精确的用途而变化。</target>
        </trans-unit>
        <trans-unit id="853e90163908be81a9a0fb1ee291ab1b4ba5a6c2" translate="yes" xml:space="preserve">
          <source>Accesses to non-volatile objects are not ordered with respect to volatile accesses. You cannot use a volatile object as a memory barrier to order a sequence of writes to non-volatile memory. For instance:</source>
          <target state="translated">对非易失性对象的访问与易失性访问相比并不排序。你不能使用易失性对象作为内存屏障来排序对非易失性内存的写入序列。比如说,你不能使用易失性对象作为内存屏障来排列对非易失性内存的写入顺序。</target>
        </trans-unit>
        <trans-unit id="c072e2c48755b5522f29c41ec4ff83f53ff94a3e" translate="yes" xml:space="preserve">
          <source>Accesses to the variable may be optimized as usual and the register remains available for allocation and use in any computations, provided that observable values of the variable are not affected.</source>
          <target state="translated">对变量的访问可以像往常一样进行优化,并且在变量的可观察值不受影响的前提下,寄存器仍然可以用于分配和使用任何计算。</target>
        </trans-unit>
        <trans-unit id="5d925b3885b30b4085b6d48f83637a9fdd674d3f" translate="yes" xml:space="preserve">
          <source>Accessing data from C programs without using input/output operands (such as by using global symbols directly from the assembler template) may not work as expected. Similarly, calling functions directly from an assembler template requires a detailed understanding of the target assembler and ABI.</source>
          <target state="translated">在不使用输入/输出操作数的情况下访问C程序中的数据(例如直接从汇编器模板中使用全局符号),可能无法达到预期的效果。同样,直接从汇编器模板中调用函数需要详细了解目标汇编器和ABI。</target>
        </trans-unit>
        <trans-unit id="aea1f643245ad21355d1a144988c7b86dcf2187a" translate="yes" xml:space="preserve">
          <source>According to the C standard, such an expression is an rvalue whose type is the unqualified version of its original type, i.e. &lt;code&gt;int&lt;/code&gt;. Whether GCC interprets this as a read of the volatile object being pointed to or only as a request to evaluate the expression for its side effects depends on this type.</source>
          <target state="translated">根据C标准，这样的表达式是一个右值，其类型是其原始类型的非限定版本，即 &lt;code&gt;int&lt;/code&gt; 。GCC是将其解释为读取指向的易失性对象还是将其解释为评估表达式的副作用的请求取决于此类型。</target>
        </trans-unit>
        <trans-unit id="35037aeb8678de2c00ed45aeca3de92268d726be" translate="yes" xml:space="preserve">
          <source>Accumulate an option for &amp;lsquo;</source>
          <target state="translated">累积&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="a3826f28e4e210d0b17ec990e0a882bb608802f9" translate="yes" xml:space="preserve">
          <source>Accumulate outgoing function arguments and acquire/release the needed stack space for outgoing function arguments once in function prologue/epilogue. Without this option, outgoing arguments are pushed before calling a function and popped afterwards.</source>
          <target state="translated">在函数序幕/序章中,积累传出的函数参数,并为传出的函数参数获取/释放所需的栈空间。如果没有这个选项,则在调用函数前推送外传参数,调用后弹出。</target>
        </trans-unit>
        <trans-unit id="dc171ad6354a6828c71d9648018df6749febe991" translate="yes" xml:space="preserve">
          <source>Accumulator register.</source>
          <target state="translated">累积器寄存器。</target>
        </trans-unit>
        <trans-unit id="554b8869b285c571ad11f29cd87ecd2c94a39e50" translate="yes" xml:space="preserve">
          <source>Ada source code file containing a library unit body (a subprogram or package body). Such files are also called &lt;em&gt;bodies&lt;/em&gt;.</source>
          <target state="translated">包含库单元主体（子程序或包主体）的Ada源代码文件。这样的文件也称为&lt;em&gt;主体&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="4b2989ddb4c2391d408222a27d0f7e97c4843dda" translate="yes" xml:space="preserve">
          <source>Ada source code file that contains a library unit declaration (a declaration of a package, subprogram, or generic, or a generic instantiation), or a library unit renaming declaration (a package, generic, or subprogram renaming declaration). Such files are also called &lt;em&gt;specs&lt;/em&gt;.</source>
          <target state="translated">包含库单元声明（包，子程序或泛型或泛型实例化的声明）或库单元重命名声明（包，泛型或子程序重命名声明）的Ada源代码文件。这样的文件也称为&lt;em&gt;规范&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="885d4a696efd6405b314fabe588d5e90299b2183" translate="yes" xml:space="preserve">
          <source>Add &amp;ldquo;thread storage duration&amp;rdquo; to the list in paragraph 1.</source>
          <target state="translated">将&amp;ldquo;线程存储持续时间&amp;rdquo;添加到第1段的列表中。</target>
        </trans-unit>
        <trans-unit id="b86ee756f777d093031a2ef7598a20edf7c225e4" translate="yes" xml:space="preserve">
          <source>Add 8 bytes to an offsettable memory reference. Useful when accessing the high 8 bytes of SSE values. For a memref in (%rax), it generates</source>
          <target state="translated">向可偏移内存引用增加8个字节。在访问SSE值的高8字节时很有用。对于(%rax)中的memref,它将生成</target>
        </trans-unit>
        <trans-unit id="4790fd26dc16d553ca9f40c8e3122f144c79668c" translate="yes" xml:space="preserve">
          <source>Add &lt;code&gt;__thread&lt;/code&gt; to the list in paragraph 1.</source>
          <target state="translated">将 &lt;code&gt;__thread&lt;/code&gt; 添加到第1段的列表中。</target>
        </trans-unit>
        <trans-unit id="a776e64e6b39926909868acf47332b1f06fea4a3" translate="yes" xml:space="preserve">
          <source>Add &lt;code&gt;__thread&lt;/code&gt; to the list of specifiers in paragraph 3.</source>
          <target state="translated">将 &lt;code&gt;__thread&lt;/code&gt; 添加到第3段的说明符列表中。</target>
        </trans-unit>
        <trans-unit id="7ae62118c00710deaec9ef5e1ca04437d3f24b0d" translate="yes" xml:space="preserve">
          <source>Add &lt;code&gt;__thread&lt;/code&gt; to the list of storage class specifiers in paragraph 1.</source>
          <target state="translated">在第1段的存储类说明符列表中添加 &lt;code&gt;__thread&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ca9035627ef94891bbb5d203d19159bca7ef3d20" translate="yes" xml:space="preserve">
          <source>Add &lt;code&gt;__thread&lt;/code&gt;.</source>
          <target state="translated">添加 &lt;code&gt;__thread&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8d24fa0d264612fefce413cb080bc55058598cb7" translate="yes" xml:space="preserve">
          <source>Add after paragraph 3</source>
          <target state="translated">在第3款后增加:</target>
        </trans-unit>
        <trans-unit id="69d6be3cf4356a47a61429765c19c67c73985946" translate="yes" xml:space="preserve">
          <source>Add after paragraph 4</source>
          <target state="translated">在第4段后增加:</target>
        </trans-unit>
        <trans-unit id="6c93420cec677cdd1b461d1d94e40f0e5ce17fec" translate="yes" xml:space="preserve">
          <source>Add after paragraph 5</source>
          <target state="translated">在第5段后增加:</target>
        </trans-unit>
        <trans-unit id="cf5cebdb7710016b6f480e1dcf7594bfb0735ab9" translate="yes" xml:space="preserve">
          <source>Add after paragraph 6</source>
          <target state="translated">在第6段后增加:</target>
        </trans-unit>
        <trans-unit id="e6ee990db3ecfcd2015326c23234c180361bb454" translate="yes" xml:space="preserve">
          <source>Add code so that program flow &lt;em&gt;arcs&lt;/em&gt; are instrumented. During execution the program records how many times each branch and call is executed and how many times it is taken or returns. On targets that support constructors with priority support, profiling properly handles constructors, destructors and C++ constructors (and destructors) of classes which are used as a type of a global variable.</source>
          <target state="translated">添加代码，以便检测程序流&lt;em&gt;弧&lt;/em&gt;。在执行期间，程序记录每个分支和调用执行了多少次，以及执行或返回了多少次。在支持具有优先级支持的构造函数的目标上，性能分析可以正确处理用作全局变量类型的类的构造函数，析构函数和C ++构造函数（和析构函数）。</target>
        </trans-unit>
        <trans-unit id="79f504a568cb02675dcb4fa7f761de4ec8eef873" translate="yes" xml:space="preserve">
          <source>Add description attributes to some DWARF DIEs that have no name attribute, such as artificial variables, external references and call site parameter DIEs.</source>
          <target state="translated">为一些没有名称属性的DWARF DIE增加描述属性,如人工变量、外部引用和调用站点参数DIE。</target>
        </trans-unit>
        <trans-unit id="71433ea39bacba1c32fb50a6079568ad524eb46d" translate="yes" xml:space="preserve">
          <source>Add directory &lt;var&gt;dir&lt;/var&gt; to the list of directories to be searched for</source>
          <target state="translated">将目录 &lt;var&gt;dir&lt;/var&gt; 添加到要搜索的目录列表中</target>
        </trans-unit>
        <trans-unit id="548bf62a1540dcbb0f428d7f5c59cbf2987dcf8a" translate="yes" xml:space="preserve">
          <source>Add new text after paragraph 1</source>
          <target state="translated">在第1款后增加新的案文</target>
        </trans-unit>
        <trans-unit id="13e160272edc000ac3b59f7e3c239601278b19a4" translate="yes" xml:space="preserve">
          <source>Add new text after paragraph 6</source>
          <target state="translated">在第6段之后增加新的案文</target>
        </trans-unit>
        <trans-unit id="b0ab0cd8ae6eaeee09a517ab6e0fab22009af14c" translate="yes" xml:space="preserve">
          <source>Add new text before paragraph 3</source>
          <target state="translated">在第3款之前增加新的案文</target>
        </trans-unit>
        <trans-unit id="09310e0a5ba6730b457158c35b8623195000a4a3" translate="yes" xml:space="preserve">
          <source>Add support for multithreading with the &lt;em&gt;dce thread&lt;/em&gt; library under HP-UX. This option sets flags for both the preprocessor and linker.</source>
          <target state="translated">使用HP-UX下的&lt;em&gt;dce线程&lt;/em&gt;库添加对多线程的支持。该选项为预处理器和链接器设置标志。</target>
        </trans-unit>
        <trans-unit id="2df2581a5423cd3eaf9365ee07a19f72370b3fc1" translate="yes" xml:space="preserve">
          <source>Add the directory &lt;var&gt;dir&lt;/var&gt; to the list of directories to be searched for header files during preprocessing. If &lt;var&gt;dir&lt;/var&gt; begins with &amp;lsquo;</source>
          <target state="translated">将目录 &lt;var&gt;dir&lt;/var&gt; 添加到要在预处理过程中搜索头文件的目录列表中。如果 &lt;var&gt;dir&lt;/var&gt; 以'</target>
        </trans-unit>
        <trans-unit id="73c333940f1537361f906bee03e2343442706250" translate="yes" xml:space="preserve">
          <source>Add the framework directory &lt;var&gt;dir&lt;/var&gt; to the head of the list of directories to be searched for header files. These directories are interleaved with those specified by</source>
          <target state="translated">将框架目录 &lt;var&gt;dir&lt;/var&gt; 添加到要搜索头文件的目录列表的开头。这些目录与由</target>
        </trans-unit>
        <trans-unit id="6e8c5a8e482b4eb45d5df440bbd4aa57581a1379" translate="yes" xml:space="preserve">
          <source>Additional Floating Types.</source>
          <target state="translated">其他浮动类型:</target>
        </trans-unit>
        <trans-unit id="fbfd7f5a311b0863e336e4d5dd611078e4f5f005" translate="yes" xml:space="preserve">
          <source>Additional block information may succeed each line, when requested by command line option. The &lt;var&gt;execution_count&lt;/var&gt; is &amp;lsquo;</source>
          <target state="translated">当命令行选项请求时，其他的块信息可能会在每行之后。该 &lt;var&gt;execution_count&lt;/var&gt; 是'</target>
        </trans-unit>
        <trans-unit id="3a265ea53c72053fec1245e548879142e841e602" translate="yes" xml:space="preserve">
          <source>Additional built-in functions are available for the 64-bit PowerPC family of processors, for efficient use of 128-bit floating point (&lt;code&gt;__float128&lt;/code&gt;) values.</source>
          <target state="translated">附加的内置功能可用于64位PowerPC系列处理器，以有效利用128位浮点（ &lt;code&gt;__float128&lt;/code&gt; ）值。</target>
        </trans-unit>
        <trans-unit id="4e400fc31f2b8160db0d8588871c49194b1a49e9" translate="yes" xml:space="preserve">
          <source>Additional floating-point exceptions, rounding modes, environments, and classifications, and their macro names (C99 and C11 7.6, C99 and C11 7.12).</source>
          <target state="translated">附加的浮点异常、四舍五入模式、环境和分类,以及它们的宏名称(C99和C11 7.6,C99和C11 7.12)。</target>
        </trans-unit>
        <trans-unit id="9b88de1196308385f5d14de9c11ffbabcd4f7f0a" translate="yes" xml:space="preserve">
          <source>Additional post-processing of the returned value may be needed, see &lt;code&gt;__builtin_extract_return_addr&lt;/code&gt;.</source>
          <target state="translated">可能需要对返回值进行其他后期处理，请参见 &lt;code&gt;__builtin_extract_return_addr&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7b6fd1bd03704b21e269c633949f84ccf5e8856f" translate="yes" xml:space="preserve">
          <source>Additional registers typically used only in prologues and epilogues: RETS, RETN, RETI, RETX, RETE, ASTAT, SEQSTAT and USP.</source>
          <target state="translated">通常只在序言和尾声中使用的附加寄存器。RETS、RETN、RETI、RETX、RETE、ASTAT、SEQSTAT和USP。</target>
        </trans-unit>
        <trans-unit id="880c2173ff65c5e972a9e4536af68b63da90141d" translate="yes" xml:space="preserve">
          <source>Additional restrictions are enforced for types with the reverse scalar storage order with regard to the scalar storage order of the target:</source>
          <target state="translated">在目标的标量存储顺序方面,对具有反向标量存储顺序的类型实施了额外的限制。</target>
        </trans-unit>
        <trans-unit id="09bc67c6276506971828d824b07903a4f5f9de7b" translate="yes" xml:space="preserve">
          <source>Additionally inlining a function compiled with</source>
          <target state="translated">另外,内联一个用</target>
        </trans-unit>
        <trans-unit id="bf8b67741ce8fd715c05645cbb36737b371211d3" translate="yes" xml:space="preserve">
          <source>Additionally on native AArch64 GNU/Linux systems the value &amp;lsquo;</source>
          <target state="translated">此外，在本机AArch64 GNU / Linux系统上，值'</target>
        </trans-unit>
        <trans-unit id="c9983bdb073bd2da3d6b02f0173dccb4761318ac" translate="yes" xml:space="preserve">
          <source>Additionally the &amp;lsquo;</source>
          <target state="translated">此外，</target>
        </trans-unit>
        <trans-unit id="c32c6fe01da4320e1de2565ba6da0578715fa9c4" translate="yes" xml:space="preserve">
          <source>Additionally, &lt;code&gt;CFStringRefs&lt;/code&gt; (defined by the &lt;code&gt;CoreFoundation&lt;/code&gt; headers) may also be used as format arguments. Note that the relevant headers are only likely to be available on Darwin (OSX) installations. On such installations, the XCode and system documentation provide descriptions of &lt;code&gt;CFString&lt;/code&gt;, &lt;code&gt;CFStringRefs&lt;/code&gt; and associated functions.</source>
          <target state="translated">此外， &lt;code&gt;CFStringRefs&lt;/code&gt; （由 &lt;code&gt;CoreFoundation&lt;/code&gt; 标头定义）也可以用作格式参数。请注意，相关的标头仅可能在达尔文（OSX）安装中可用。在此类安装中，XCode和系统文档提供了 &lt;code&gt;CFString&lt;/code&gt; ， &lt;code&gt;CFStringRefs&lt;/code&gt; 和关联函数的描述。</target>
        </trans-unit>
        <trans-unit id="06f45ee380b9da22c173cf9d9231907ee68fe13b" translate="yes" xml:space="preserve">
          <source>Additionally, some messages are logically nested within other messages, reflecting implementation details of the optimization passes.</source>
          <target state="translated">此外,一些消息在逻辑上嵌套在其他消息中,反映了优化通道的实现细节。</target>
        </trans-unit>
        <trans-unit id="0c630e5527eda313a2b833dd18abd8307a6cfdbd" translate="yes" xml:space="preserve">
          <source>Additionally, the architectural extension string may be specified on its own. This can be used to turn on and off particular architectural extensions without having to specify a particular architecture version or core. Example:</source>
          <target state="translated">此外,还可以单独指定架构扩展字符串。这可以用来开启和关闭特定的架构扩展,而不必指定特定的架构版本或核心。例如</target>
        </trans-unit>
        <trans-unit id="e68df41b1d7fdc52b01b88eeb29e9ccd6bf7ed5e" translate="yes" xml:space="preserve">
          <source>Additionally, the following architectures, which lack support for the Thumb execution state, are recognized but support is deprecated: &amp;lsquo;</source>
          <target state="translated">此外，可以识别以下缺少对Thumb执行状态的支持的体系结构，但不建议使用该体系结构：</target>
        </trans-unit>
        <trans-unit id="a870075e1e81be429acf073e584f3d7c7e76cfdf" translate="yes" xml:space="preserve">
          <source>Additionally, the options</source>
          <target state="translated">此外,选项</target>
        </trans-unit>
        <trans-unit id="62846127f56afc07ef1c01a4fc578e26bdf7e831" translate="yes" xml:space="preserve">
          <source>Additionally, this option can specify that GCC should tune the performance of the code for a big.LITTLE system. Permissible names are: &amp;lsquo;</source>
          <target state="translated">此外，此选项可以指定GCC应该为big.LITTLE系统调整代码的性能。允许的名称为：'</target>
        </trans-unit>
        <trans-unit id="c9b7ac484445343c898ee0befeb5554f44a64e88" translate="yes" xml:space="preserve">
          <source>Additionally, warn when a user-defined literal operator is declared with a literal suffix identifier that doesn&amp;rsquo;t begin with an underscore. Literal suffix identifiers that don&amp;rsquo;t begin with an underscore are reserved for future standardization.</source>
          <target state="translated">另外，当声明用户定义的文字运算符带有不以下划线开头的文字后缀标识符时，发出警告。不以下划线开头的文字后缀标识符保留给以后的标准化。</target>
        </trans-unit>
        <trans-unit id="facde292bf415fbdf09a1828e9e0908e4c617e00" translate="yes" xml:space="preserve">
          <source>Address base register</source>
          <target state="translated">地址基础寄存器</target>
        </trans-unit>
        <trans-unit id="ac7731150d1c92cf663f9e708bf71a25213854ca" translate="yes" xml:space="preserve">
          <source>Address base register if 64-bit instructions are enabled or NO_REGS.</source>
          <target state="translated">如果启用64位指令或NO_REGS,则地址基寄存器。</target>
        </trans-unit>
        <trans-unit id="e3421b8898caa7357be908d1653e3653974d758f" translate="yes" xml:space="preserve">
          <source>Address operand that is an indexed or indirect from a register (&amp;lsquo;</source>
          <target state="translated">来自寄存器的索引或间接地址操作数（'</target>
        </trans-unit>
        <trans-unit id="a7b7013cab33d0bd7c179b9b5712968750a0b395" translate="yes" xml:space="preserve">
          <source>Address operand without segment register.</source>
          <target state="translated">地址操作数没有段寄存器。</target>
        </trans-unit>
        <trans-unit id="e849277f25d3c4f30a01955b54c92b602f3ff3ef" translate="yes" xml:space="preserve">
          <source>Address register</source>
          <target state="translated">地址寄存器</target>
        </trans-unit>
        <trans-unit id="a60bc1681a9f62ef4591ab15398d5eb38a430789" translate="yes" xml:space="preserve">
          <source>Address register (general purpose register except r0)</source>
          <target state="translated">地址寄存器(除r0外的通用寄存器)</target>
        </trans-unit>
        <trans-unit id="91d4fb05cb0843e13759b8b72edb33693debf000" translate="yes" xml:space="preserve">
          <source>Address register indirect addressing mode</source>
          <target state="translated">地址寄存器间接寻址模式</target>
        </trans-unit>
        <trans-unit id="3a077484bf2c4ff84f71e4199f510082fe999bf3" translate="yes" xml:space="preserve">
          <source>Address registers</source>
          <target state="translated">地址寄存器</target>
        </trans-unit>
        <trans-unit id="5759236ebd061a0e0392b44c51e565f6ce6fcc43" translate="yes" xml:space="preserve">
          <source>Address registers when they&amp;rsquo;re 16 bits wide.</source>
          <target state="translated">地址寄存器为16位宽时。</target>
        </trans-unit>
        <trans-unit id="fdd0e10bf3a4572e30fda31a40f35542043406cf" translate="yes" xml:space="preserve">
          <source>Address registers when they&amp;rsquo;re 24 bits wide.</source>
          <target state="translated">地址寄存器为24位宽时。</target>
        </trans-unit>
        <trans-unit id="325382a51fa4bc25157b99f44454696d95890fcb" translate="yes" xml:space="preserve">
          <source>Address space identifiers may be used exactly like any other C type qualifier (e.g., &lt;code&gt;const&lt;/code&gt; or &lt;code&gt;volatile&lt;/code&gt;). See the N1275 document for more details.</source>
          <target state="translated">地址空间标识符可以像任何其他C类型限定符（例如 &lt;code&gt;const&lt;/code&gt; 或 &lt;code&gt;volatile&lt;/code&gt; ）一样使用。有关更多详细信息，请参见N1275文档。</target>
        </trans-unit>
        <trans-unit id="b5e65d5c203f07ad3d2623301ca2022f82e6bcd0" translate="yes" xml:space="preserve">
          <source>Address space layout randomization (ASLR) can lead to not binary identical PCH files. If you rely on stable PCH file contents disable ASLR when generating PCH files.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f0d1ee78feebd358e9ac4716831efeab01368b7" translate="yes" xml:space="preserve">
          <source>Adjacent bit-fields are packed into the same 1-, 2-, or 4-byte allocation unit if the integral types are the same size and if the next bit-field fits into the current allocation unit without crossing the boundary imposed by the common alignment requirements of the bit-fields.</source>
          <target state="translated">如果积分类型大小相同,并且下一个位字段适合当前的分配单元,而不越过位字段的共同对齐要求所规定的边界,相邻的位字段就会被装入同一个1、2或4字节的分配单元。</target>
        </trans-unit>
        <trans-unit id="94636fe0e41073552acb8d30375f7c2b9b7fa2c2" translate="yes" xml:space="preserve">
          <source>After defining a global register variable, for the current compilation unit:</source>
          <target state="translated">在定义了一个全局寄存器变量后,对于当前的编译单元。</target>
        </trans-unit>
        <trans-unit id="a160b9211c156fcb59476123ceefb14233c30de0" translate="yes" xml:space="preserve">
          <source>After register allocation and post-register allocation instruction splitting, identify arithmetic instructions that compute processor flags similar to a comparison operation based on that arithmetic. If possible, eliminate the explicit comparison operation.</source>
          <target state="translated">在寄存器分配和寄存器分配后的指令拆分后,确定计算处理器标志的算术指令,类似于基于该算术的比较操作。如果可能的话,取消明确的比较操作。</target>
        </trans-unit>
        <trans-unit id="9cd493414e0c8a63ccc996f89446d267fe9e1e5f" translate="yes" xml:space="preserve">
          <source>After register allocation and post-register allocation instruction splitting, perform a copy-propagation pass to try to reduce scheduling dependencies and occasionally eliminate the copy.</source>
          <target state="translated">在寄存器分配和寄存器分配后的指令拆分后,进行复制传播传递,尽量减少调度依赖性,偶尔消除复制。</target>
        </trans-unit>
        <trans-unit id="a0c15aec2fc1e009f616402ab13a6a8f9c982cca" translate="yes" xml:space="preserve">
          <source>After running a program compiled with</source>
          <target state="translated">在运行一个用</target>
        </trans-unit>
        <trans-unit id="1454e9ea83225a76df4ee5fd8a44b04ac91ebb88" translate="yes" xml:space="preserve">
          <source>After the prefix, there must be one or more additional constraints (see &lt;a href=&quot;constraints#Constraints&quot;&gt;Constraints&lt;/a&gt;) that describe where the value resides. Common constraints include &amp;lsquo;</source>
          <target state="translated">在前缀之后，必须有一个或多个其他约束（请参见&lt;a href=&quot;constraints#Constraints&quot;&gt;Constraints&lt;/a&gt;）来描述该值所在的位置。常见限制包括</target>
        </trans-unit>
        <trans-unit id="87d629b413e62d8e858ca1323306d594503312be" translate="yes" xml:space="preserve">
          <source>Again, the call to &lt;code&gt;f()&lt;/code&gt; is not dependent on template arguments (there are no arguments that depend on the type &lt;code&gt;T&lt;/code&gt;, and it is also not otherwise specified that the call should be in a dependent context). Thus a global declaration of such a function must be available, since the one in the base class is not visible until instantiation time. The compiler will consequently produce the following error message:</source>
          <target state="translated">同样，对 &lt;code&gt;f()&lt;/code&gt; 的调用不依赖于模板参数（不存在依赖于类型 &lt;code&gt;T&lt;/code&gt; 的参数，并且也没有以其他方式指定该调用应位于依赖上下文中）。因此，此类函数的全局声明必须可用，因为直到实例化时间，基类中的该声明才可见。编译器将因此产生以下错误消息：</target>
        </trans-unit>
        <trans-unit id="e15a8d239570fd7618da66d01432b0ca503636ad" translate="yes" xml:space="preserve">
          <source>Aggregates with this attribute are invalid, even if they are of the same size as a corresponding scalar. For example, the declaration:</source>
          <target state="translated">具有该属性的集合是无效的,即使它们与对应的标量大小相同。例如,声明:</target>
        </trans-unit>
        <trans-unit id="9ffe001744d57fb7d843a75b3de19edfb4a4cd40" translate="yes" xml:space="preserve">
          <source>Aliases of</source>
          <target state="translated">别名</target>
        </trans-unit>
        <trans-unit id="2f7b5a2fcf03ab39f29a64817524ffd647a4fc18" translate="yes" xml:space="preserve">
          <source>Align all branch targets to a power-of-two boundary.</source>
          <target state="translated">将所有的分支目标对准二幂的边界。</target>
        </trans-unit>
        <trans-unit id="784e20f54ecda5213d66bcc1bc3f5f199a64e7ea" translate="yes" xml:space="preserve">
          <source>Align all loops to a 32-byte boundary.</source>
          <target state="translated">将所有的循环排列到一个32字节的边界。</target>
        </trans-unit>
        <trans-unit id="a2e1e4cb8c2ddc659aedc1c3a6dfffeb002bdbe7" translate="yes" xml:space="preserve">
          <source>Align branch targets to a power-of-two boundary, for branch targets where the targets can only be reached by jumping. In this case, no dummy operations need be executed.</source>
          <target state="translated">将分支目标对准二的幂级边界,对于只有通过跳跃才能到达目标的分支目标。在这种情况下,不需要执行虚操作。</target>
        </trans-unit>
        <trans-unit id="2e8345e97e639fae1caa53fafd777f32b2148811" translate="yes" xml:space="preserve">
          <source>Align doubles at 64-bit boundaries. Note that this changes the calling conventions, and thus some functions from the standard C library do not work unless you recompile it first with</source>
          <target state="translated">在64位边界对齐双数。请注意,这改变了调用约定,因此一些来自标准 C 库的函数不能使用,除非你先用</target>
        </trans-unit>
        <trans-unit id="36a2b427b91139b8587d4cbfe16eb7a63f8affad" translate="yes" xml:space="preserve">
          <source>Align loops to a power-of-two boundary. If the loops are executed many times, this makes up for any execution of the dummy padding instructions.</source>
          <target state="translated">将循环对齐到二的幂级边界。如果循环被多次执行,这将弥补任何执行的虚填充指令。</target>
        </trans-unit>
        <trans-unit id="fb4c088e2c0ec9d07a3a585878097d5ea3d18362" translate="yes" xml:space="preserve">
          <source>Align the start of functions to the next power-of-two greater than &lt;var&gt;n&lt;/var&gt;, skipping up to &lt;var&gt;m&lt;/var&gt;-1 bytes. This ensures that at least the first &lt;var&gt;m&lt;/var&gt; bytes of the function can be fetched by the CPU without crossing an &lt;var&gt;n&lt;/var&gt;-byte alignment boundary.</source>
          <target state="translated">将函数的开头与下一个大于 &lt;var&gt;n&lt;/var&gt; 的2的幂次对齐，最多跳过 &lt;var&gt;m&lt;/var&gt; -1个字节。这样确保了CPU 至少可以获取函数的前 &lt;var&gt;m&lt;/var&gt; 个字节，而不会跨越 &lt;var&gt;n&lt;/var&gt; 个字节的对齐边界。</target>
        </trans-unit>
        <trans-unit id="c4d41afbffbc15906243cd5ff7feb6499dec3822" translate="yes" xml:space="preserve">
          <source>Align the start of functions to the next power-of-two greater than or equal to &lt;var&gt;n&lt;/var&gt;, skipping up to &lt;var&gt;m&lt;/var&gt;-1 bytes. This ensures that at least the first &lt;var&gt;m&lt;/var&gt; bytes of the function can be fetched by the CPU without crossing an &lt;var&gt;n&lt;/var&gt;-byte alignment boundary.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="790e74268060e0e6ade88cfb9c482c2bc048f9d0" translate="yes" xml:space="preserve">
          <source>Align variable (&lt;code&gt;alnv.ps&lt;/code&gt;).</source>
          <target state="translated">对齐变量（ &lt;code&gt;alnv.ps&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="6a72085653e4c5be8c7640c868ef787cbcf063d1" translate="yes" xml:space="preserve">
          <source>All</source>
          <target state="translated">All</target>
        </trans-unit>
        <trans-unit id="19bd4f0f0123a61d6b94fd1f26c48a5b466015b1" translate="yes" xml:space="preserve">
          <source>All condition registers: SCC, VCCZ, EXECZ</source>
          <target state="translated">所有条件寄存器。SCC、VCCZ、EXECZ。</target>
        </trans-unit>
        <trans-unit id="0ebe806ad92438745f4bad14dde213851c8a70c2" translate="yes" xml:space="preserve">
          <source>All dependences are costly.</source>
          <target state="translated">所有的依仗都是昂贵的。</target>
        </trans-unit>
        <trans-unit id="0cca1530229b7b9e550b891f9a9b113625c13de2" translate="yes" xml:space="preserve">
          <source>All files specified by</source>
          <target state="translated">指定的所有文件</target>
        </trans-unit>
        <trans-unit id="0eaba1cfa9a00eb4bd0b12d5b7310a8e6e1fa4c5" translate="yes" xml:space="preserve">
          <source>All implicitly popped input registers must be closer to the top of the reg-stack than any input that is not implicitly popped.</source>
          <target state="translated">所有隐式弹出的输入寄存器必须比任何没有隐式弹出的输入更接近reg-stack的顶部。</target>
        </trans-unit>
        <trans-unit id="3b1c013be47e44ec0e7b3eeaa220c1f24b9203e3" translate="yes" xml:space="preserve">
          <source>All memory orders are valid.</source>
          <target state="translated">所有的内存订单都是有效的。</target>
        </trans-unit>
        <trans-unit id="71ff0e08a090942eb8e784cba6de91a4fd99fb49" translate="yes" xml:space="preserve">
          <source>All modules should be compiled with the same</source>
          <target state="translated">所有的模块都应该用相同的</target>
        </trans-unit>
        <trans-unit id="f0bcaa344128e72d0d5e1b94c3b2fa0090b0e882" translate="yes" xml:space="preserve">
          <source>All objects that have neither thread storage duration, dynamic storage duration nor are local [&amp;hellip;].</source>
          <target state="translated">所有既没有线程存储持续时间，动态存储持续时间也不是本地[&amp;hellip;]的对象。</target>
        </trans-unit>
        <trans-unit id="ec2545f5d42fce7e86616e30c2d782de4749997a" translate="yes" xml:space="preserve">
          <source>All of the routines are described in the Intel documentation to take &amp;ldquo;an optional list of variables protected by the memory barrier&amp;rdquo;. It&amp;rsquo;s not clear what is meant by that; it could mean that &lt;em&gt;only&lt;/em&gt; the listed variables are protected, or it could mean a list of additional variables to be protected. The list is ignored by GCC which treats it as empty. GCC interprets an empty list as meaning that all globally accessible variables should be protected.</source>
          <target state="translated">英特尔文档中将所有例程描述为&amp;ldquo;受内存屏障保护的变量的可选列表&amp;rdquo;。目前尚不清楚这是什么意思。这可能意味着&lt;em&gt;仅&lt;/em&gt;列出的变量受到保护，或者可能意味着要保护的其他变量的列表。该列表会被GCC忽略，它将视为空列表。GCC将一个空列表解释为意味着应保护所有全局可访问变量。</target>
        </trans-unit>
        <trans-unit id="2dc38cb28fe09de761809c6899ec0dfab5c95980" translate="yes" xml:space="preserve">
          <source>All other attributes</source>
          <target state="translated">所有其他属性</target>
        </trans-unit>
        <trans-unit id="4e1fe3c41d4a92f980feaffab352908a5ae600b4" translate="yes" xml:space="preserve">
          <source>All the above</source>
          <target state="translated">以上所有</target>
        </trans-unit>
        <trans-unit id="72ca116b6b2d46153e83f38824f95e8a5d694cf5" translate="yes" xml:space="preserve">
          <source>All the basic integer types can be used as base types, both as signed and as unsigned: &lt;code&gt;char&lt;/code&gt;, &lt;code&gt;short&lt;/code&gt;, &lt;code&gt;int&lt;/code&gt;, &lt;code&gt;long&lt;/code&gt;, &lt;code&gt;long long&lt;/code&gt;. In addition, &lt;code&gt;float&lt;/code&gt; and &lt;code&gt;double&lt;/code&gt; can be used to build floating-point vector types.</source>
          <target state="translated">所有基本整数类型都可以用作有符号和无符号的基本类型： &lt;code&gt;char&lt;/code&gt; ， &lt;code&gt;short&lt;/code&gt; ， &lt;code&gt;int&lt;/code&gt; ， &lt;code&gt;long&lt;/code&gt; ， &lt;code&gt;long long&lt;/code&gt; 。此外， &lt;code&gt;float&lt;/code&gt; 和 &lt;code&gt;double&lt;/code&gt; 可以用于构建浮点向量类型。</target>
        </trans-unit>
        <trans-unit id="b8115dc4041976655c63e593fd53f619ce3ca975" translate="yes" xml:space="preserve">
          <source>All the data and read-only data segments must be within 512KB addressing space. The text segment must be within 16MB addressing space.</source>
          <target state="translated">所有数据和只读数据段必须在512KB寻址空间内。文本段必须在16MB寻址空间内。</target>
        </trans-unit>
        <trans-unit id="a642a04a04ca54e997a623213186ae992d1e6e8c" translate="yes" xml:space="preserve">
          <source>All the text and data segments can be within 4GB addressing space.</source>
          <target state="translated">所有的文本和数据段都可以在4GB寻址空间内。</target>
        </trans-unit>
        <trans-unit id="bd8b82ccf3682d163d774079a9dc8ccb0aa660ee" translate="yes" xml:space="preserve">
          <source>All visibilities are supported on many, but not all, ELF targets (supported when the assembler supports the &amp;lsquo;</source>
          <target state="translated">在所有但不是所有ELF目标上都支持所有可见性（当汇编器支持&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="622f4dc5287fcd41d6f3a24869b2a0df614a0723" translate="yes" xml:space="preserve">
          <source>Allocate to an &lt;code&gt;enum&lt;/code&gt; type only as many bytes as it needs for the declared range of possible values. Specifically, the &lt;code&gt;enum&lt;/code&gt; type is equivalent to the smallest integer type that has enough room.</source>
          <target state="translated">仅为声明的可能值范围分配一个 &lt;code&gt;enum&lt;/code&gt; 类型所需的字节数。具体来说， &lt;code&gt;enum&lt;/code&gt; 类型等效于具有足够空间的最小整数类型。</target>
        </trans-unit>
        <trans-unit id="1b577848b6e6ae4af92719e79079d9951a50047f" translate="yes" xml:space="preserve">
          <source>Allocate variables to the read-only data section first if possible, then next in the small data section if possible, otherwise in data. This gives slightly slower code than the default, but reduces the amount of RAM required when executing, and thus may be preferred for some embedded systems.</source>
          <target state="translated">如果可能的话,先将变量分配到只读数据部分,然后尽可能在小数据部分下一步,否则在数据中。这样做的代码速度比默认的略慢,但减少了执行时所需的RAM量,因此对于一些嵌入式系统来说,可能是首选。</target>
        </trans-unit>
        <trans-unit id="482b6f74ff2eb85ead91bf4d63cb82360d5be63f" translate="yes" xml:space="preserve">
          <source>Allow (or do not allow) GCC to use the LOOP instruction.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12f3f43a7ca9147ffe2ba31d63c2ea8ec201486c" translate="yes" xml:space="preserve">
          <source>Allow arbitrary-sized immediates in bit operations.</source>
          <target state="translated">允许在位操作中使用任意大小的即时器。</target>
        </trans-unit>
        <trans-unit id="ac2c75532a2e292a21a77540eaedf29f5c432d5a" translate="yes" xml:space="preserve">
          <source>Allow conditional expressions with mismatched types in the second and third arguments. The value of such an expression is void. This option is not supported for C++.</source>
          <target state="translated">允许在第二个和第三个参数中使用类型不匹配的条件表达式。这种表达式的值是void。C++不支持这个选项。</target>
        </trans-unit>
        <trans-unit id="8d58e8c4bb0f63ea94500caf667ca947fcaa1a82" translate="yes" xml:space="preserve">
          <source>Allow fast jumps to the message dispatcher. On Darwin this is accomplished via the comm page.</source>
          <target state="translated">允许快速跳转到消息发送器。在达尔文上,这是通过通讯页面实现的。</target>
        </trans-unit>
        <trans-unit id="c73dadda8d4b49fb004b5103de76106d4f0b8557" translate="yes" xml:space="preserve">
          <source>Allow implicit conversions between vectors with differing numbers of elements and/or incompatible element types. This option should not be used for new code.</source>
          <target state="translated">允许在元素数量不同和/或元素类型不兼容的向量之间进行隐式转换。这个选项不应该用于新代码。</target>
        </trans-unit>
        <trans-unit id="d0dbb659ed768befd508acb2601c588f49ddaa57" translate="yes" xml:space="preserve">
          <source>Allow optimizations for floating-point arithmetic that (a) assume that arguments and results are valid and (b) may violate IEEE or ANSI standards. When used at link time, it may include libraries or startup files that change the default FPU control word or other similar optimizations.</source>
          <target state="translated">允许对浮点算术进行优化,(a)假设参数和结果有效,(b)可能违反IEEE或ANSI标准。在链接时使用时,它可能包括改变默认FPU控制字或其他类似优化的库或启动文件。</target>
        </trans-unit>
        <trans-unit id="773a6288517f96a4a7283887bb99a6fba71c957c" translate="yes" xml:space="preserve">
          <source>Allow optimizations for floating-point arithmetic that assume that arguments and results are not NaNs or +-Infs.</source>
          <target state="translated">允许对浮点运算进行优化,假设参数和结果不是NaNs或+Infs。</target>
        </trans-unit>
        <trans-unit id="1e06113b53f739fa9c85ec94358e3f373eb320f8" translate="yes" xml:space="preserve">
          <source>Allow optimizations for floating-point arithmetic that ignore the signedness of zero. IEEE arithmetic specifies the behavior of distinct +0.0 and -0.0 values, which then prohibits simplification of expressions such as x+0.0 or 0.0*x (even with</source>
          <target state="translated">允许对浮点算术进行优化,忽略零的符号性。IEEE算术规定了不同的+0.0和-0.0值的行为,这就禁止简化表达式,如x+0.0或0.0*x(即使是在使用了</target>
        </trans-unit>
        <trans-unit id="0eea9d2d0ec6a801c6ef5293eae12c7fbb21b59c" translate="yes" xml:space="preserve">
          <source>Allow optimizers to introduce new data races on stores. Set to 1 to allow, otherwise to 0.</source>
          <target state="translated">允许优化器在存储上引入新的数据竞赛。设置为1为允许,否则为0。</target>
        </trans-unit>
        <trans-unit id="c60cf758a077c6f503981387a6b0345419874bea" translate="yes" xml:space="preserve">
          <source>Allow or disallow the compiler to emit the &lt;code&gt;fsca&lt;/code&gt; instruction for sine and cosine approximations. The option</source>
          <target state="translated">允许或禁止编译器发出 &lt;code&gt;fsca&lt;/code&gt; 指令以表示正弦和余弦近似值。选项</target>
        </trans-unit>
        <trans-unit id="70331cead1dc233186888055e035642315d5054e" translate="yes" xml:space="preserve">
          <source>Allow or disallow the compiler to emit the &lt;code&gt;fsrra&lt;/code&gt; instruction for reciprocal square root approximations. The option</source>
          <target state="translated">允许或禁止编译器发出 &lt;code&gt;fsrra&lt;/code&gt; 指令以求倒数平方根近似值。选项</target>
        </trans-unit>
        <trans-unit id="57cbe965449910b6f59559b0a1874d0d198b696a" translate="yes" xml:space="preserve">
          <source>Allow re-association of operands in series of floating-point operations. This violates the ISO C and C++ language standard by possibly changing computation result. NOTE: re-ordering may change the sign of zero as well as ignore NaNs and inhibit or create underflow or overflow (and thus cannot be used on code that relies on rounding behavior like &lt;code&gt;(x + 2**52) - 2**52&lt;/code&gt;. May also reorder floating-point comparisons and thus may not be used when ordered comparisons are required. This option requires that both</source>
          <target state="translated">允许在一系列浮点运算中重新关联操作数。通过可能更改计算结果，这违反了ISO C和C ++语言标准。注意：重新排序可能会更改零的符号，并忽略NaN并抑制或创建下溢或上溢（因此不能用于依赖舍入行为的代码，例如 &lt;code&gt;(x + 2**52) - 2**52&lt;/code&gt; 可能还会对浮点比较进行重新排序，因此在需要进行顺序比较时可能无法使用。</target>
        </trans-unit>
        <trans-unit id="54ce20d4ec16fad4cd32f197249fdc3fb1dac290" translate="yes" xml:space="preserve">
          <source>Allow speculative motion of more load instructions. This only makes sense when scheduling before register allocation, i.e. with</source>
          <target state="translated">允许更多负载指令的投机运动。这只有在寄存器分配前进行调度时才有意义,即用</target>
        </trans-unit>
        <trans-unit id="1b47c26e732fcedac3b1858953b01853eb8422ec" translate="yes" xml:space="preserve">
          <source>Allow speculative motion of some load instructions. This only makes sense when scheduling before register allocation, i.e. with</source>
          <target state="translated">允许一些加载指令的投机运动。这只有在寄存器分配前进行调度时才有意义,即用</target>
        </trans-unit>
        <trans-unit id="f926321cb4f3fc49097c6857a3e7d152a19de395" translate="yes" xml:space="preserve">
          <source>Allow stop bits to be placed earlier than immediately preceding the instruction that triggered the stop bit. This can improve instruction scheduling, but does not always do so.</source>
          <target state="translated">允许将停止位放在比紧挨着触发停止位的指令之前的位置。这可以改善指令调度,但并不总是这样做。</target>
        </trans-unit>
        <trans-unit id="7905fb7386b21750ad5a1d1722446a6fdeb43598" translate="yes" xml:space="preserve">
          <source>Allow the compiler to assume the strictest aliasing rules applicable to the language being compiled. For C (and C++), this activates optimizations based on the type of expressions. In particular, an object of one type is assumed never to reside at the same address as an object of a different type, unless the types are almost the same. For example, an &lt;code&gt;unsigned int&lt;/code&gt; can alias an &lt;code&gt;int&lt;/code&gt;, but not a &lt;code&gt;void*&lt;/code&gt; or a &lt;code&gt;double&lt;/code&gt;. A character type may alias any other type.</source>
          <target state="translated">允许编译器采用适用于所编译语言的最严格的别名规则。对于C（和C ++），这会根据表达式的类型激活优化。特别是，除非类型几乎相同，否则假定一种类型的对象永远不会与其他类型的对象位于相同的地址。例如， &lt;code&gt;unsigned int&lt;/code&gt; 可以为 &lt;code&gt;int&lt;/code&gt; 别名，但不能为 &lt;code&gt;void*&lt;/code&gt; 或 &lt;code&gt;double&lt;/code&gt; 别名。字符类型可以别名任何其他类型。</target>
        </trans-unit>
        <trans-unit id="bc2aa80da8f5ff65f45ae97b354110390c96c42f" translate="yes" xml:space="preserve">
          <source>Allow the compiler to generate &lt;em&gt;Long Instruction Word&lt;/em&gt; instructions if the target is the &amp;lsquo;</source>
          <target state="translated">让编译器生成&lt;em&gt;超长指令字&lt;/em&gt;的说明，如果目标是'</target>
        </trans-unit>
        <trans-unit id="f39db7389fdae7630a67f4845ba2f639259c8a4a" translate="yes" xml:space="preserve">
          <source>Allow the compiler to generate the &lt;em&gt;SETLB&lt;/em&gt; and &lt;em&gt;Lcc&lt;/em&gt; instructions if the target is the &amp;lsquo;</source>
          <target state="translated">如果目标是''，则允许编译器生成&lt;em&gt;SETLB&lt;/em&gt;和&lt;em&gt;Lcc&lt;/em&gt;指令。</target>
        </trans-unit>
        <trans-unit id="57b9d18f30c753317a363448d4ac2396bae27e7d" translate="yes" xml:space="preserve">
          <source>Allow the compiler to introduce new data races on stores.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa7a919d8fa035f96c5d1af049879f0dd62e1421" translate="yes" xml:space="preserve">
          <source>Allow the compiler to optimize using the assumption that a value of enumerated type can only be one of the values of the enumeration (as defined in the C++ standard; basically, a value that can be represented in the minimum number of bits needed to represent all the enumerators). This assumption may not be valid if the program uses a cast to convert an arbitrary integer value to the enumerated type.</source>
          <target state="translated">允许编译器使用以下假设进行优化:一个枚举类型的值只能是枚举的值之一(如C++标准中所定义的那样;基本上,一个可以用表示所有枚举器所需的最少位数表示的值)。如果程序使用转码将任意整数值转换为枚举类型,这个假设可能不成立。</target>
        </trans-unit>
        <trans-unit id="33fc8a715b12ca22462902ef833240995e04a5d4" translate="yes" xml:space="preserve">
          <source>Allow the compiler to use all of the available registers. By default registers &lt;code&gt;r24..r31&lt;/code&gt; are reserved for use in interrupt handlers. With this option enabled these registers can be used in ordinary functions as well.</source>
          <target state="translated">允许编译器使用所有可用寄存器。默认情况下，寄存器 &lt;code&gt;r24..r31&lt;/code&gt; 保留供中断处理程序使用。启用此选项后，这些寄存器也可以用于普通功能。</target>
        </trans-unit>
        <trans-unit id="6303c2c94b5f256a55d06aa2be50e19fcb0df737" translate="yes" xml:space="preserve">
          <source>Allow the reciprocal of a value to be used instead of dividing by the value if this enables optimizations. For example &lt;code&gt;x / y&lt;/code&gt; can be replaced with &lt;code&gt;x * (1/y)&lt;/code&gt;, which is useful if &lt;code&gt;(1/y)&lt;/code&gt; is subject to common subexpression elimination. Note that this loses precision and increases the number of flops operating on the value.</source>
          <target state="translated">如果启用优化，则允许使用值的倒数而不是除以该值。例如 &lt;code&gt;x / y&lt;/code&gt; 可以替换为 &lt;code&gt;x * (1/y)&lt;/code&gt; ，如果这是有用的 &lt;code&gt;(1/y)&lt;/code&gt; 是受公共子表达式消除。请注意，这会失去精度，并增加了根据该值进行操作的触发器数量。</target>
        </trans-unit>
        <trans-unit id="5cbc7a77a073ec8e91de85701bbe563110739962" translate="yes" xml:space="preserve">
          <source>Allow the store merging pass to introduce unaligned stores if it is legal to do so.</source>
          <target state="translated">在合法的情况下,允许店铺合并通引入不结盟店铺。</target>
        </trans-unit>
        <trans-unit id="b8c16f16485e58470d06579755ecbd0f929ac7fa" translate="yes" xml:space="preserve">
          <source>Allow to use truncation instead of rounding towards zero for fractional fixed-point types.</source>
          <target state="translated">对于小数定点类型,允许使用截断而不是四舍五入。</target>
        </trans-unit>
        <trans-unit id="8834a22ee0acee1821ccfc8e148c6cbb34655847" translate="yes" xml:space="preserve">
          <source>Allow using extensions of later DWARF standard version than selected with</source>
          <target state="translated">允许使用DWARF标准版本以后的扩展,而不是选择的标准版本。</target>
        </trans-unit>
        <trans-unit id="98ea6e4c4f75e6a8f8033c8b750f3d749cc09003" translate="yes" xml:space="preserve">
          <source>Allow/disallow treating the &lt;code&gt;__ea&lt;/code&gt; address space as superset of the generic address space. This enables explicit type casts between &lt;code&gt;__ea&lt;/code&gt; and generic pointer as well as implicit conversions of generic pointers to &lt;code&gt;__ea&lt;/code&gt; pointers. The default is to allow address space pointer conversions.</source>
          <target state="translated">允许/禁止将 &lt;code&gt;__ea&lt;/code&gt; 地址空间视为通用地址空间的超集。这样可以在 &lt;code&gt;__ea&lt;/code&gt; 和通用指针之间进行显式类型转换，以及将通用指针隐式转换为 &lt;code&gt;__ea&lt;/code&gt; 指针。默认值为允许地址空间指针转换。</target>
        </trans-unit>
        <trans-unit id="74a5bb83513cc4e38a6504a7eaa0f1d977ac61b9" translate="yes" xml:space="preserve">
          <source>Allowable bit-field types other than &lt;code&gt;_Bool&lt;/code&gt;, &lt;code&gt;signed int&lt;/code&gt;, and &lt;code&gt;unsigned int&lt;/code&gt; (C99 and C11 6.7.2.1).</source>
          <target state="translated">&lt;code&gt;_Bool&lt;/code&gt; ， &lt;code&gt;signed int&lt;/code&gt; 和 &lt;code&gt;unsigned int&lt;/code&gt; 以外的允许位域类型（C99和C11 6.7.2.1）。</target>
        </trans-unit>
        <trans-unit id="9672aa21a92b454bca4334e1b73511ba859e3019" translate="yes" xml:space="preserve">
          <source>Allows calls via function pointers (including virtual functions) to execute correctly regardless of whether the target code has been compiled for interworking or not. There is a small overhead in the cost of executing a function pointer if this option is enabled. This option is not valid in AAPCS configurations because interworking is enabled by default.</source>
          <target state="translated">允许通过函数指针(包括虚拟函数)的调用正确执行,无论目标代码是否已被编译为互操作。如果启用这个选项,执行函数指针的成本会有一个小的开销。这个选项在AAPCS配置中是无效的,因为默认情况下是启用了互操作。</target>
        </trans-unit>
        <trans-unit id="9fab16002619dc077a62263507de1c970a51b300" translate="yes" xml:space="preserve">
          <source>Also note that GCC emits the above sequence with additional Newton-Raphson step for vectorized single-float division and vectorized &lt;code&gt;sqrtf(&lt;var&gt;x&lt;/var&gt;)&lt;/code&gt; already with</source>
          <target state="translated">还要注意的是GCC发射具有用于向量化单浮除法附加牛顿-拉夫逊步骤和矢量上述序列 &lt;code&gt;sqrtf(&lt;var&gt;x&lt;/var&gt;)&lt;/code&gt; 已经与</target>
        </trans-unit>
        <trans-unit id="1a461c1e71dd5c0a03740ad367bc2a7b24233082" translate="yes" xml:space="preserve">
          <source>Also note that an &lt;code&gt;asm goto&lt;/code&gt; statement is always implicitly considered volatile.</source>
          <target state="translated">还要注意， &lt;code&gt;asm goto&lt;/code&gt; 语句始终被隐式认为是易失的。</target>
        </trans-unit>
        <trans-unit id="767bf94dfe72662ddbd8e20120050c8f90e9046e" translate="yes" xml:space="preserve">
          <source>Also warn about cases where the compiler reduces the magnitude of a constant involved in a comparison. For example: &lt;code&gt;x + 2 &amp;gt; y&lt;/code&gt; is simplified to &lt;code&gt;x + 1 &amp;gt;= y&lt;/code&gt;. This is reported only at the highest warning level because this simplification applies to many comparisons, so this warning level gives a very large number of false positives.</source>
          <target state="translated">还警告编译器减小比较所涉及的常数的大小的情况。例如： &lt;code&gt;x + 2 &amp;gt; y&lt;/code&gt; 简化为 &lt;code&gt;x + 1 &amp;gt;= y&lt;/code&gt; 。仅在最高警告级别上报告此事件，因为此简化适用于许多比较，因此此警告级别给出了大量误报。</target>
        </trans-unit>
        <trans-unit id="c15f6772b26643b0ff617a164130fae2096f2324" translate="yes" xml:space="preserve">
          <source>Also warn about other cases where a comparison is simplified to a constant. For example: &lt;code&gt;abs (x) &amp;gt;= 0&lt;/code&gt;. This can only be simplified when signed integer overflow is undefined, because &lt;code&gt;abs (INT_MIN)&lt;/code&gt; overflows to &lt;code&gt;INT_MIN&lt;/code&gt;, which is less than zero.</source>
          <target state="translated">还警告将比较简化为常数的其他情况。例如： &lt;code&gt;abs (x) &amp;gt;= 0&lt;/code&gt; 。仅当未定义有符号整数溢出时才可以简化此操作，因为 &lt;code&gt;abs (INT_MIN)&lt;/code&gt; 溢出到小于零的 &lt;code&gt;INT_MIN&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e8e800b6cdd36533f8ba6ba58f938d89e7317e5b" translate="yes" xml:space="preserve">
          <source>Also warn about other cases where a comparison is simplified. For example: &lt;code&gt;x + 1 &amp;gt; 1&lt;/code&gt; is simplified to &lt;code&gt;x &amp;gt; 0&lt;/code&gt;.</source>
          <target state="translated">还警告简化比较的其他情况。例如： &lt;code&gt;x + 1 &amp;gt; 1&lt;/code&gt; 简化为 &lt;code&gt;x &amp;gt; 0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f2eccf451b029841db2d4f52cb1371fa4ffd7cc2" translate="yes" xml:space="preserve">
          <source>Also warn about other simplifications not covered by the above cases. For example: &lt;code&gt;(x * 10) / 5&lt;/code&gt; is simplified to &lt;code&gt;x * 2&lt;/code&gt;.</source>
          <target state="translated">还警告上述情况未涵盖的其他简化方法。例如： &lt;code&gt;(x * 10) / 5&lt;/code&gt; 简化为 &lt;code&gt;x * 2&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="aaf71652d194ffb84805956fe1b5940083ae517e" translate="yes" xml:space="preserve">
          <source>Also warn for dangerous uses of the GNU extension to &lt;code&gt;?:&lt;/code&gt; with omitted middle operand. When the condition in the &lt;code&gt;?&lt;/code&gt;: operator is a boolean expression, the omitted value is always 1. Often programmers expect it to be a value computed inside the conditional expression instead.</source>
          <target state="translated">还警告GNU扩展到 &lt;code&gt;?:&lt;/code&gt; 的危险用途，并省略中间操作数。当条件在 &lt;code&gt;?&lt;/code&gt; ：运算符是一个布尔表达式，忽略的值始终为1。程序员通常希望它是在条件表达式中计算的值。</target>
        </trans-unit>
        <trans-unit id="0777d5422fc8bc8f5bababa57c28335fb0cdc795" translate="yes" xml:space="preserve">
          <source>Also warn if a comparison like &lt;code&gt;x&amp;lt;=y&amp;lt;=z&lt;/code&gt; appears; this is equivalent to &lt;code&gt;(x&amp;lt;=y ? 1 : 0) &amp;lt;= z&lt;/code&gt;, which is a different interpretation from that of ordinary mathematical notation.</source>
          <target state="translated">如果出现类似 &lt;code&gt;x&amp;lt;=y&amp;lt;=z&lt;/code&gt; 的比较，也要发出警告；这等效于 &lt;code&gt;(x&amp;lt;=y ? 1 : 0) &amp;lt;= z&lt;/code&gt; ，它与普通数学符号的解释不同。</target>
        </trans-unit>
        <trans-unit id="4e45248057e2324494ad069a7abd8071c0384ad1" translate="yes" xml:space="preserve">
          <source>Also warn when making a cast that introduces a type qualifier in an unsafe way. For example, casting &lt;code&gt;char **&lt;/code&gt; to &lt;code&gt;const char **&lt;/code&gt; is unsafe, as in this example:</source>
          <target state="translated">在进行以不安全方式引入类型限定符的强制转换时也要发出警告。例如，将 &lt;code&gt;char **&lt;/code&gt; 强制转换为 &lt;code&gt;const char **&lt;/code&gt; 是不安全的，如以下示例所示：</target>
        </trans-unit>
        <trans-unit id="ebdf7f49c076ed9ff3a97d65da78f8767a5691c7" translate="yes" xml:space="preserve">
          <source>Also, some built-in functions prefer or require immediate numbers as parameters, because the corresponding DSP instructions accept both immediate numbers and register operands, or accept immediate numbers only. The immediate parameters are listed as follows.</source>
          <target state="translated">另外,由于相应的DSP指令既接受即时数,又接受寄存器操作数,或者只接受即时数,所以有些内置函数喜欢或需要即时数作为参数。即时数参数列举如下。</target>
        </trans-unit>
        <trans-unit id="f5b2a9f079522dadbd70f5a362997b267591505d" translate="yes" xml:space="preserve">
          <source>Also, the ABI changed the mangling of template argument packs, &lt;code&gt;const_cast&lt;/code&gt;, &lt;code&gt;static_cast&lt;/code&gt;, prefix increment/decrement, and a class scope function used as a template argument.</source>
          <target state="translated">此外，ABI更改了模板参数包 &lt;code&gt;const_cast&lt;/code&gt; ， &lt;code&gt;static_cast&lt;/code&gt; ，前缀增量/减量和用作模板参数的类范围函数的处理。</target>
        </trans-unit>
        <trans-unit id="bedbe72286a46ec20159c0af50884180a15a3619" translate="yes" xml:space="preserve">
          <source>Also, there are two special clobber arguments:</source>
          <target state="translated">另外,还有两个特殊的口水论证。</target>
        </trans-unit>
        <trans-unit id="1793f4a326dd636d187c7ec419e47dec37d6305e" translate="yes" xml:space="preserve">
          <source>Also, you must provide function prototypes for all functions that take variable numbers of arguments (including &lt;code&gt;printf&lt;/code&gt;); otherwise incorrect code is generated for calls to those functions.</source>
          <target state="translated">同样，您必须为所有带有可变数量参数（包括 &lt;code&gt;printf&lt;/code&gt; ）的函数提供函数原型；否则，将为调用这些函数生成错误的代码。</target>
        </trans-unit>
        <trans-unit id="b85df36ab018e13c039dd34eb2302708663f4af2" translate="yes" xml:space="preserve">
          <source>Alter the cost model used for vectorization of loops marked with the OpenMP simd directive. The &lt;var&gt;model&lt;/var&gt; argument should be one of &amp;lsquo;</source>
          <target state="translated">更改用于对带有OpenMP simd指令标记的循环进行矢量化处理的成本模型。该 &lt;var&gt;model&lt;/var&gt; 参数应该是一个&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="f431f1054230ce8fcc7bc5eae8ec9ced8a86a188" translate="yes" xml:space="preserve">
          <source>Alter the cost model used for vectorization. The &lt;var&gt;model&lt;/var&gt; argument should be one of &amp;lsquo;</source>
          <target state="translated">更改用于向量化的成本模型。该 &lt;var&gt;model&lt;/var&gt; 参数应该是一个&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="9fc71ca35ab8d8d40760c8ef39bc71ee861a4bcc" translate="yes" xml:space="preserve">
          <source>Alter the thread-local storage model to be used (see &lt;a href=&quot;thread_002dlocal#Thread_002dLocal&quot;&gt;Thread-Local&lt;/a&gt;). The &lt;var&gt;model&lt;/var&gt; argument should be one of &amp;lsquo;</source>
          <target state="translated">更改要使用的线程本地存储模型（请参阅&lt;a href=&quot;thread_002dlocal#Thread_002dLocal&quot;&gt;Thread-Local&lt;/a&gt;）。该 &lt;var&gt;model&lt;/var&gt; 参数应该是一个&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="2d63c6f25ef5c2c6707d16e831a6091cc8c50e17" translate="yes" xml:space="preserve">
          <source>Alter the update method for an application instrumented for profile feedback based optimization. The &lt;var&gt;method&lt;/var&gt; argument should be one of &amp;lsquo;</source>
          <target state="translated">为基于概要文件反馈优化的应用程序更改更新方法。所述 &lt;var&gt;method&lt;/var&gt; 参数应该是一个'</target>
        </trans-unit>
        <trans-unit id="a7ba2917cba97115bf3adee00dd20256ca8bef51" translate="yes" xml:space="preserve">
          <source>Alternately, you can reference labels using the actual C label name enclosed in brackets. For example, to reference a label named &lt;code&gt;carry&lt;/code&gt;, you can use &amp;lsquo;</source>
          <target state="translated">或者，您可以使用括号中的实际C标签名称引用标签。例如，要引用名为 &lt;code&gt;carry&lt;/code&gt; 的标签，可以使用'</target>
        </trans-unit>
        <trans-unit id="c04a618f555219675642e22c54d794ab28d7300f" translate="yes" xml:space="preserve">
          <source>Alternatively you can discover which binary optimizations are enabled by</source>
          <target state="translated">另外,您也可以通过以下方式发现哪些二进制优化是被启用的。</target>
        </trans-unit>
        <trans-unit id="1b2db455af7c311c86d9a9e68fe99ec219f1fdb6" translate="yes" xml:space="preserve">
          <source>Alternatively, the function attribute &lt;code&gt;noplt&lt;/code&gt; can be used to avoid calls through the PLT for specific external functions.</source>
          <target state="translated">或者，可以使用函数属性 &lt;code&gt;noplt&lt;/code&gt; 来避免通过PLT调用特定的外部函数。</target>
        </trans-unit>
        <trans-unit id="724d746f6afeb6dcb4048f896627e2174930b360" translate="yes" xml:space="preserve">
          <source>Alternatively, you might decide to put the precompiled header file in a directory and use</source>
          <target state="translated">或者,你可以决定将预编译的头文件放在一个目录中,然后使用</target>
        </trans-unit>
        <trans-unit id="95f269cf4efa79d9433eb0cf9a5bd7a136f8f62d" translate="yes" xml:space="preserve">
          <source>Although IRA uses a sophisticated algorithm to compress the conflict table, the table can still require excessive amounts of memory for huge functions. If the conflict table for a function could be more than the size in MB given by this parameter, the register allocator instead uses a faster, simpler, and lower-quality algorithm that does not require building a pseudo-register conflict table.</source>
          <target state="translated">虽然IRA使用了一种复杂的算法来压缩冲突表,但对于巨大的函数来说,该表仍然需要过多的内存。如果一个函数的冲突表可能超过这个参数给出的MB大小,寄存器分配器就会使用更快、更简单、更低质量的算法,不需要建立伪寄存器冲突表。</target>
        </trans-unit>
        <trans-unit id="9b0be486c711e5de323bb610f3f803e2869a722a" translate="yes" xml:space="preserve">
          <source>Although an effort has been made to warn about all such cases, there are probably some cases that are not warned about, even though G++ is generating incompatible code. There may also be cases where warnings are emitted even though the code that is generated is compatible.</source>
          <target state="translated">虽然我们已经努力对所有这些情况发出警告,但可能有一些情况没有被警告,即使G++生成的是不兼容的代码。还有一些情况,即使生成的代码是兼容的,也会发出警告。</target>
        </trans-unit>
        <trans-unit id="91a8f5762db94ffdfef370246b2c12c4c385d73d" translate="yes" xml:space="preserve">
          <source>Although it is possible to define such a function, this is not very useful as it is not possible to read the arguments. This is only supported for C as this construct is allowed by C++.</source>
          <target state="translated">虽然可以定义这样一个函数,但由于无法读取参数,所以用处不大。这只在C语言中得到支持,因为C++允许这种结构。</target>
        </trans-unit>
        <trans-unit id="3aea130ff16faac0f0a72d4c21d30b19934fa1e8" translate="yes" xml:space="preserve">
          <source>Although the behavior is similar to the Gold Linker&amp;rsquo;s ICF optimization, GCC ICF works on different levels and thus the optimizations are not same - there are equivalences that are found only by GCC and equivalences found only by Gold.</source>
          <target state="translated">尽管其行为类似于Gold Linker的ICF优化，但GCC ICF的工作水平不同，因此优化也不相同-有些等效项仅由GCC查找，而等效项仅由Gold查找。</target>
        </trans-unit>
        <trans-unit id="cf2ebe14b431087c27c2301bbb04cfe4eb87ea4a" translate="yes" xml:space="preserve">
          <source>Although the primary usage of this attribute is for POD types, the attribute can also be applied to global C++ objects that are initialized by a constructor. In this case, the static initialization and destruction code for the object is emitted in each translation defining the object, but the calls to the constructor and destructor are protected by a link-once guard variable.</source>
          <target state="translated">虽然这个属性的主要用途是用于POD类型,但这个属性也可以应用于由构造函数初始化的全局C++对象。在这种情况下,对象的静态初始化和销毁代码会在每个定义对象的翻译中发出,但对构造函数和销毁函数的调用是由一个link-once guard变量保护的。</target>
        </trans-unit>
        <trans-unit id="419e2ab79b9a72e513efa7d620ba40673796ae3c" translate="yes" xml:space="preserve">
          <source>Although the size of a zero-length array is zero, an array member of this kind may increase the size of the enclosing type as a result of tail padding. The offset of a zero-length array member from the beginning of the enclosing structure is the same as the offset of an array with one or more elements of the same type. The alignment of a zero-length array is the same as the alignment of its elements.</source>
          <target state="translated">虽然零长度数组的大小为零,但这种数组成员可能会因为尾部填充而增加包围类型的大小。零长度数组成员从包围结构开始的偏移量与有一个或多个相同类型元素的数组的偏移量相同。零长度数组的对齐方式与元素的对齐方式相同。</target>
        </trans-unit>
        <trans-unit id="48a0b2e6239d57c9c30535eae8caf6619e4d8826" translate="yes" xml:space="preserve">
          <source>Altivec register if</source>
          <target state="translated">Altivec注册,如果</target>
        </trans-unit>
        <trans-unit id="43210ad7cdf91a35ea9e54b8ca8e28c22c6e9fd2" translate="yes" xml:space="preserve">
          <source>Altivec register to use for double loads/stores or NO_REGS.</source>
          <target state="translated">Altivec 寄存器用于双重负载/存储或 NO_REGS。</target>
        </trans-unit>
        <trans-unit id="1e72319ddb65cddc1596b72314174c11a529e4e9" translate="yes" xml:space="preserve">
          <source>Altivec register to use for float/32-bit int loads/stores or NO_REGS.</source>
          <target state="translated">Altivec 寄存器用于浮点/32位的int load/stores或NO_REGS。</target>
        </trans-unit>
        <trans-unit id="27667baa779021dc30ceb24d0b6298a36d1ae73c" translate="yes" xml:space="preserve">
          <source>Altivec vector register</source>
          <target state="translated">Altivec向量寄存器</target>
        </trans-unit>
        <trans-unit id="7213a39022a1a221aa305b421707bb55dfa13ff8" translate="yes" xml:space="preserve">
          <source>Always treat bit-fields as &lt;code&gt;int&lt;/code&gt;-sized.</source>
          <target state="translated">始终将位字段视为 &lt;code&gt;int&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="549d944304e895a2c1d4531ead649e8cbf5063ad" translate="yes" xml:space="preserve">
          <source>Always use a library call.</source>
          <target state="translated">总是使用库调用。</target>
        </trans-unit>
        <trans-unit id="0b4062f8987d50153e0838000ddb5e4f41ad4e24" translate="yes" xml:space="preserve">
          <source>Among the consequences of these changes are that static data members of the same type with the same name but defined in different shared objects are different, so changing one does not change the other; and that pointers to function members defined in different shared objects may not compare equal. When this flag is given, it is a violation of the ODR to define types with the same name differently.</source>
          <target state="translated">这些变化的后果包括:同一类型的同名静态数据成员,但在不同的共享对象中定义的静态数据成员是不同的,所以改变一个不会改变另一个;在不同的共享对象中定义的函数成员的指针可能不会比较相等。当给出这个标志时,对同名的类型进行不同的定义是违反ODR的。</target>
        </trans-unit>
        <trans-unit id="99690d58d4abd10cd0938a7adcb56ded08ef66ad" translate="yes" xml:space="preserve">
          <source>An</source>
          <target state="translated">An</target>
        </trans-unit>
        <trans-unit id="c5009a6f1efb8810f35df0d2766e52237ed673ad" translate="yes" xml:space="preserve">
          <source>An 8 bit value with exactly one bit set.</source>
          <target state="translated">一个8位的值,正好设置一个位。</target>
        </trans-unit>
        <trans-unit id="73fdb3be2e0086894a1e44f055f6c3c5fe05581e" translate="yes" xml:space="preserve">
          <source>An 8-element vector constant with identical elements.</source>
          <target state="translated">一个具有相同元素的8元素向量常数。</target>
        </trans-unit>
        <trans-unit id="42e73ea7df5141021212bafc4bcfa0e59c8e090d" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;asm goto&lt;/code&gt; statement cannot have outputs. This is due to an internal restriction of the compiler: control transfer instructions cannot have outputs. If the assembler code does modify anything, use the &lt;code&gt;&quot;memory&quot;&lt;/code&gt; clobber to force the optimizers to flush all register values to memory and reload them if necessary after the &lt;code&gt;asm&lt;/code&gt; statement.</source>
          <target state="translated">一个 &lt;code&gt;asm goto&lt;/code&gt; 语句不能有输出。这是由于编译器的内部限制：控制传递指令不能具有输出。如果汇编代码确实进行了任何修改，请使用 &lt;code&gt;&quot;memory&quot;&lt;/code&gt; 缓冲程序强制优化器将所有寄存器值刷新到内存中，并在 &lt;code&gt;asm&lt;/code&gt; 语句之后根据需要重新加载它们。</target>
        </trans-unit>
        <trans-unit id="04db20c14b6b3a82ba6832f795aabb1d2758d6a2" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;asm&lt;/code&gt; statement has zero or more output operands indicating the names of C variables modified by the assembler code.</source>
          <target state="translated">一个 &lt;code&gt;asm&lt;/code&gt; 语句具有零个或多个输出操作数，这些输出操作数指示由汇编代码修改的C变量的名称。</target>
        </trans-unit>
        <trans-unit id="c3ecf57ab1f86499d0414e65689faa519df6b817" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;enum&lt;/code&gt; type is not considered to be compatible with another &lt;code&gt;enum&lt;/code&gt; type even if both are compatible with the same integer type; this is what the C standard specifies. For example, &lt;code&gt;enum {foo, bar}&lt;/code&gt; is not similar to &lt;code&gt;enum {hot, dog}&lt;/code&gt;.</source>
          <target state="translated">一个 &lt;code&gt;enum&lt;/code&gt; 类型不被认为与另一个 &lt;code&gt;enum&lt;/code&gt; 类型兼容，即使它们都与同一整数类型兼容；这就是C标准指定的内容。例如， &lt;code&gt;enum {foo, bar}&lt;/code&gt; 与 &lt;code&gt;enum {hot, dog}&lt;/code&gt; 不相似。</target>
        </trans-unit>
        <trans-unit id="197244fadb4ff328f7464f8fb593d34255a64886" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;attribute specifier list&lt;/em&gt; is a sequence of one or more attribute specifiers, not separated by any other tokens.</source>
          <target state="translated">一个&lt;em&gt;属性说明符列表&lt;/em&gt;是一个或多个属性说明符的序列，而不是由任何其他代币分离。</target>
        </trans-unit>
        <trans-unit id="4db760995f077b22b4a4d97b7a5f59e2f43ffc2f" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;attribute specifier&lt;/em&gt; is of the form &lt;code&gt;__attribute__ ((&lt;var&gt;attribute-list&lt;/var&gt;))&lt;/code&gt;. An &lt;em&gt;attribute list&lt;/em&gt; is a possibly empty comma-separated sequence of &lt;em&gt;attributes&lt;/em&gt;, where each attribute is one of the following:</source>
          <target state="translated">一个&lt;em&gt;属性指定符&lt;/em&gt;的形式是 &lt;code&gt;__attribute__ ((&lt;var&gt;attribute-list&lt;/var&gt;))&lt;/code&gt; 。一个&lt;em&gt;属性列表&lt;/em&gt;是一个可能是空的逗号分隔的序列&lt;em&gt;的属性&lt;/em&gt;，其中每个属性是以下之一：</target>
        </trans-unit>
        <trans-unit id="7298880ccde6d5d2f135cff890ce9dd813a48a5a" translate="yes" xml:space="preserve">
          <source>An Altivec vector register (VR), &lt;code&gt;v0&lt;/code&gt;&amp;hellip;&lt;code&gt;v31&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="caef8d867ec8d279c62d15ef41539390101b886c" translate="yes" xml:space="preserve">
          <source>An I-type 12-bit signed immediate.</source>
          <target state="translated">一个I型12位签名的立即。</target>
        </trans-unit>
        <trans-unit id="06327d0e0884e8359c3aeb898ee10e76eb6687a6" translate="yes" xml:space="preserve">
          <source>An absolute address</source>
          <target state="translated">绝对地址</target>
        </trans-unit>
        <trans-unit id="78c6a7cdfe8551206974bd67b2a089dc6fe26252" translate="yes" xml:space="preserve">
          <source>An absolute symbolic address or a label reference</source>
          <target state="translated">一个绝对的符号地址或标签引用</target>
        </trans-unit>
        <trans-unit id="986b6a4e37803f27663b870d347fe309ea3ea740" translate="yes" xml:space="preserve">
          <source>An address suitable for a &lt;code&gt;prefetch&lt;/code&gt; instruction, or for any other instruction with the same addressing mode as &lt;code&gt;prefetch&lt;/code&gt;.</source>
          <target state="translated">适用于 &lt;code&gt;prefetch&lt;/code&gt; 指令或与 &lt;code&gt;prefetch&lt;/code&gt; 具有相同寻址模式的任何其他指令的地址。</target>
        </trans-unit>
        <trans-unit id="892155354f6089e8dd5e479a72ea4a1751091291" translate="yes" xml:space="preserve">
          <source>An address that can be used in a non-macro load or store.</source>
          <target state="translated">一个可用于非宏加载或存储的地址。</target>
        </trans-unit>
        <trans-unit id="ff106250bd6a1ea035dee107e3b2d2773c2aecc2" translate="yes" xml:space="preserve">
          <source>An address that is held in a general-purpose register.</source>
          <target state="translated">通用寄存器中的地址。</target>
        </trans-unit>
        <trans-unit id="ebfbf78a988fb6bc16aa1ac07630bba74056e531" translate="yes" xml:space="preserve">
          <source>An address which does not involve register indirect addressing or pre/post increment/decrement addressing.</source>
          <target state="translated">不涉及寄存器间接寻址或前/后增/减寻址的地址。</target>
        </trans-unit>
        <trans-unit id="e3211e293506f09ee6205a6286105b13b8dd093c" translate="yes" xml:space="preserve">
          <source>An alternate way to write the above example is</source>
          <target state="translated">上述例子的另一种写法是</target>
        </trans-unit>
        <trans-unit id="7ed98e3e9e5fb257c8559031222af1c4e1303971" translate="yes" xml:space="preserve">
          <source>An alternative syntax for this that has been obsolete since GCC 2.5 but GCC still accepts is to write &amp;lsquo;</source>
          <target state="translated">自GCC 2.5以来，这种替代语法已经过时了，但GCC仍然接受的是写'</target>
        </trans-unit>
        <trans-unit id="0ba051ca8ecdb334d29fa5a48a0711170d4503f7" translate="yes" xml:space="preserve">
          <source>An alternative to increasing the size of the destination buffer is to constrain the range of formatted values. The maximum length of string arguments can be bounded by specifying the precision in the format directive. When numeric arguments of format directives can be assumed to be bounded by less than the precision of their type, choosing an appropriate length modifier to the format specifier will reduce the required buffer size. For example, if &lt;var&gt;a&lt;/var&gt; and &lt;var&gt;b&lt;/var&gt; in the example above can be assumed to be within the precision of the &lt;code&gt;short int&lt;/code&gt; type then using either the &lt;code&gt;%hi&lt;/code&gt; format directive or casting the argument to &lt;code&gt;short&lt;/code&gt; reduces the maximum required size of the buffer to 24 bytes.</source>
          <target state="translated">增加目标缓冲区大小的另一种方法是限制格式化值的范围。可以通过在format指令中指定精度来限制字符串参数的最大长度。当可以假定格式指令的数字参数的边界小于其类型的精度时，为格式说明符选择适当的长度修饰符将减小所需的缓冲区大小。例如，如果可以将上面示例中的 &lt;var&gt;a&lt;/var&gt; 和 &lt;var&gt;b&lt;/var&gt; 假定为 &lt;code&gt;short int&lt;/code&gt; 类型的精度之内，则使用 &lt;code&gt;%hi&lt;/code&gt; format指令或将参数强制转换为 &lt;code&gt;short&lt;/code&gt; 会将缓冲区的最大所需大小减少到24个字节。</target>
        </trans-unit>
        <trans-unit id="90ac40bd537abd77f944ca782b1d8e24e3e93586" translate="yes" xml:space="preserve">
          <source>An amendment to the 1990 standard was published in 1995. This amendment added digraphs and &lt;code&gt;__STDC_VERSION__&lt;/code&gt; to the language, but otherwise concerned the library. This amendment is commonly known as &lt;em&gt;AMD1&lt;/em&gt;; the amended standard is sometimes known as &lt;em&gt;C94&lt;/em&gt; or &lt;em&gt;C95&lt;/em&gt;. To select this standard in GCC, use the option</source>
          <target state="translated">1995年发布了对1990年标准的修订。此修订在语言中增加了 &lt;code&gt;__STDC_VERSION__&lt;/code&gt; 和__STDC_VERSION__，但是与图书馆有关。此修正案通常称为&lt;em&gt;AMD1&lt;/em&gt;；修订后的标准有时称为&lt;em&gt;C94&lt;/em&gt;或&lt;em&gt;C95&lt;/em&gt;。要在GCC中选择此标准，请使用</target>
        </trans-unit>
        <trans-unit id="5ec9ea45e6f6d2866eabdf39502663d30e59ccdc" translate="yes" xml:space="preserve">
          <source>An application can interpose its own definition of functions for functions invoked by</source>
          <target state="translated">应用程序可以将自己对函数的定义插入到由</target>
        </trans-unit>
        <trans-unit id="79eafbcf2b7c5c25e774d3009d7ad66460a67d81" translate="yes" xml:space="preserve">
          <source>An area where the difference is most apparent is name mangling. The use of different name mangling is intentional, to protect you from more subtle problems. Compilers differ as to many internal details of C++ implementation, including: how class instances are laid out, how multiple inheritance is implemented, and how virtual function calls are handled. If the name encoding were made the same, your programs would link against libraries provided from other compilers&amp;mdash;but the programs would then crash when run. Incompatible libraries are then detected at link time, rather than at run time.</source>
          <target state="translated">差异最明显的区域是名称修饰。故意使用不同的名称修饰，以保护您免受更细微的问题的困扰。编译器在C ++实现的许多内部细节方面有所不同，包括：类实例的布局方式，如何实现多重继承以及如何处理虚拟函数调用。如果名称编码相同，则您的程序将与其他编译器提供的库链接，但是程序在运行时将崩溃。然后在链接时而非运行时检测到不兼容的库。</target>
        </trans-unit>
        <trans-unit id="a97545d568f0ddabc50a6a6e190b9c96c3da5965" translate="yes" xml:space="preserve">
          <source>An assembler template is a literal string containing assembler instructions. The compiler replaces tokens in the template that refer to inputs, outputs, and goto labels, and then outputs the resulting string to the assembler. The string can contain any instructions recognized by the assembler, including directives. GCC does not parse the assembler instructions themselves and does not know what they mean or even whether they are valid assembler input. However, it does count the statements (see &lt;a href=&quot;size-of-an-asm#Size-of-an-asm&quot;&gt;Size of an asm&lt;/a&gt;).</source>
          <target state="translated">汇编器模板是包含汇编器指令的文字字符串。编译器替换引用输入，输出和goto标签的模板中的标记，然后将结果字符串输出到汇编器。该字符串可以包含汇编程序可识别的任何指令，包括指令。GCC不会自行解析汇编程序指令，也不知道它们的含义，甚至不知道它们是否是有效的汇编程序输入。但是，它确实对语句进行计数（请参见&lt;a href=&quot;size-of-an-asm#Size-of-an-asm&quot;&gt;asm的大小&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="cf8ae718bdcb577716b49e495b23a5d728121d19" translate="yes" xml:space="preserve">
          <source>An atomic operation can both constrain code motion and be mapped to hardware instructions for synchronization between threads (e.g., a fence). To which extent this happens is controlled by the memory orders, which are listed here in approximately ascending order of strength. The description of each memory order is only meant to roughly illustrate the effects and is not a specification; see the C++11 memory model for precise semantics.</source>
          <target state="translated">一个原子操作既可以约束代码的运动,也可以映射到硬件指令,以便在线程之间进行同步(例如,栅栏)。这种情况在多大程度上发生是由内存顺序控制的,这里大致按强度升序列出。对每个内存顺序的描述只是为了粗略地说明效果,并不是规范,精确的语义请参见C++11内存模型。</target>
        </trans-unit>
        <trans-unit id="4d88b31282dc4372978d47c4d528de2e00c16901" translate="yes" xml:space="preserve">
          <source>An attribute name (which may be an identifier such as &lt;code&gt;unused&lt;/code&gt;, or a reserved word such as &lt;code&gt;const&lt;/code&gt;).</source>
          <target state="translated">属性名称（可以是诸如 &lt;code&gt;unused&lt;/code&gt; 的标识符，也可以是诸如 &lt;code&gt;const&lt;/code&gt; 的保留字）。</target>
        </trans-unit>
        <trans-unit id="f65131f3242824d199035927efcf93043285cd45" translate="yes" xml:space="preserve">
          <source>An attribute name followed by a parenthesized list of parameters for the attribute. These parameters take one of the following forms:</source>
          <target state="translated">一个属性名称,后面是一个括号内的属性参数列表。这些参数采用以下形式之一:</target>
        </trans-unit>
        <trans-unit id="7d755f91a373e17fad5f0c5626bbbba251cf643a" translate="yes" xml:space="preserve">
          <source>An attribute specifier list may appear as part of a &lt;code&gt;struct&lt;/code&gt;, &lt;code&gt;union&lt;/code&gt; or &lt;code&gt;enum&lt;/code&gt; specifier. It may go either immediately after the &lt;code&gt;struct&lt;/code&gt;, &lt;code&gt;union&lt;/code&gt; or &lt;code&gt;enum&lt;/code&gt; keyword, or after the closing brace. The former syntax is preferred. Where attribute specifiers follow the closing brace, they are considered to relate to the structure, union or enumerated type defined, not to any enclosing declaration the type specifier appears in, and the type defined is not complete until after the attribute specifiers.</source>
          <target state="translated">属性说明符列表可能显示为 &lt;code&gt;struct&lt;/code&gt; ， &lt;code&gt;union&lt;/code&gt; 或 &lt;code&gt;enum&lt;/code&gt; 说明符的一部分。它可以紧跟在 &lt;code&gt;struct&lt;/code&gt; ， &lt;code&gt;union&lt;/code&gt; 或 &lt;code&gt;enum&lt;/code&gt; 关键字之后，或在右括号之后。前一种语法是首选。在属性说明符紧跟右括号的情况下，它们被认为与定义的结构，联合或枚举类型有关，而不与该类型说明符出现在其中的任何封闭声明有关，并且定义的类型直到属性说明符之后才是完整的。</target>
        </trans-unit>
        <trans-unit id="9e5e73e14616e06a74db1d5feee8111efc621957" translate="yes" xml:space="preserve">
          <source>An attribute specifier list may appear at the start of a nested declarator. At present, there are some limitations in this usage: the attributes correctly apply to the declarator, but for most individual attributes the semantics this implies are not implemented. When attribute specifiers follow the &lt;code&gt;*&lt;/code&gt; of a pointer declarator, they may be mixed with any type qualifiers present. The following describes the formal semantics of this syntax. It makes the most sense if you are familiar with the formal specification of declarators in the ISO C standard.</source>
          <target state="translated">属性说明符列表可能会出现在嵌套声明符的开头。当前，此用法有一些限制：属性正确地应用于声明符，但是对于大多数单独的属性，此暗示的语义尚未实现。当属性说明符在指针声明符的 &lt;code&gt;*&lt;/code&gt; 后面时，它们可以与存在的任何类型限定符混合使用。下面介绍此语法的形式语义。如果您熟悉ISO C标准中声明符的正式规范，这将是最有意义的。</target>
        </trans-unit>
        <trans-unit id="90c786fbc073ea725818acf8d9cbe4bc390cf984" translate="yes" xml:space="preserve">
          <source>An attribute specifier list may appear immediately before a declarator (other than the first) in a comma-separated list of declarators in a declaration of more than one identifier using a single list of specifiers and qualifiers. Such attribute specifiers apply only to the identifier before whose declarator they appear. For example, in</source>
          <target state="translated">在使用一个单一的指定符和限定符列表的多个标识符的声明中,属性指定符列表可以紧接出现在一个以逗号分隔的声明符列表中的声明符(第一个声明符除外)之前。这种属性规定符只适用于它们出现在其声明符之前的标识符。例如,在</target>
        </trans-unit>
        <trans-unit id="be5978cee71999e28113db755252c2c229b75be6" translate="yes" xml:space="preserve">
          <source>An attribute specifier list may appear immediately before the comma, &lt;code&gt;=&lt;/code&gt; or semicolon terminating the declaration of an identifier other than a function definition. Such attribute specifiers apply to the declared object or function. Where an assembler name for an object or function is specified (see &lt;a href=&quot;asm-labels#Asm-Labels&quot;&gt;Asm Labels&lt;/a&gt;), the attribute must follow the &lt;code&gt;asm&lt;/code&gt; specification.</source>
          <target state="translated">属性说明符列表可能紧接在逗号， &lt;code&gt;=&lt;/code&gt; 或分号之前，终止了除函数定义以外的标识符声明。这样的属性说明符适用于声明的对象或函数。如果指定了对象或函数的汇编器名称（请参见&lt;a href=&quot;asm-labels#Asm-Labels&quot;&gt;Asm Labels&lt;/a&gt;），则该属性必须遵循 &lt;code&gt;asm&lt;/code&gt; 规范。</target>
        </trans-unit>
        <trans-unit id="06c400bc0897dcce315e482021ea5ac2d0b133c9" translate="yes" xml:space="preserve">
          <source>An attribute specifier list may, in future, be permitted to appear after the declarator in a function definition (before any old-style parameter declarations or the function body).</source>
          <target state="translated">将来可能会允许属性指定器列表出现在函数定义中的声明符之后(在任何旧式参数声明或函数主体之前)。</target>
        </trans-unit>
        <trans-unit id="a74a1d3ff08634b1a7446e5738ed8abb53ee53ac" translate="yes" xml:space="preserve">
          <source>An empty replacement string indicates that the given range is to be removed. An empty range (e.g. &amp;ldquo;45:3-45:3&amp;rdquo;) indicates that the string is to be inserted at the given position.</source>
          <target state="translated">空的替换字符串表示要删除给定范围。空范围（例如&amp;ldquo; 45：3-45：3&amp;rdquo;）指示字符串将被插入到给定位置。</target>
        </trans-unit>
        <trans-unit id="0ae58fb99fa1b71a549f28d943d2b614039f2208" translate="yes" xml:space="preserve">
          <source>An identifier followed by a comma and a non-empty comma-separated list of expressions. For example, &lt;code&gt;format&lt;/code&gt; attributes use this form.</source>
          <target state="translated">一个标识符，后跟一个逗号和一个非空逗号分隔的表达式列表。例如， &lt;code&gt;format&lt;/code&gt; 属性使用此形式。</target>
        </trans-unit>
        <trans-unit id="68d7bc1885869717ff785880a55a84832370a8cc" translate="yes" xml:space="preserve">
          <source>An identifier. For example, &lt;code&gt;mode&lt;/code&gt; attributes use this form.</source>
          <target state="translated">标识符。例如， &lt;code&gt;mode&lt;/code&gt; 属性使用此形式。</target>
        </trans-unit>
        <trans-unit id="1ec5ac33481525fe53d426cd6db6a12a229bec4c" translate="yes" xml:space="preserve">
          <source>An immediate floating operand (expression code &lt;code&gt;const_double&lt;/code&gt; or &lt;code&gt;const_vector&lt;/code&gt;) is allowed.</source>
          <target state="translated">允许使用立即数浮动操作数（表达式代码 &lt;code&gt;const_double&lt;/code&gt; 或 &lt;code&gt;const_vector&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="594d6eba8a97b362385ec37bc0e852d2a80c0ac2" translate="yes" xml:space="preserve">
          <source>An immediate floating operand (expression code &lt;code&gt;const_double&lt;/code&gt;) is allowed, but only if the target floating point format is the same as that of the host machine (on which the compiler is running).</source>
          <target state="translated">仅当目标浮点格式与主机（在其上运行编译器）的浮点格式相同时，才允许使用立即浮点操作数（表达式代码 &lt;code&gt;const_double&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="0c315fd75b55a96544e61998f54c1ece5842737a" translate="yes" xml:space="preserve">
          <source>An immediate for and/xor/or instructions. const_int is sign extended as a 128 bit.</source>
          <target state="translated">const_int是符号扩展为128位。</target>
        </trans-unit>
        <trans-unit id="5ccfcfe71dbbefbcc7083b3111e73c588704efb6" translate="yes" xml:space="preserve">
          <source>An immediate for and/xor/or instructions. const_int is treated as a 32 bit value.</source>
          <target state="translated">const_int作为32位值处理。</target>
        </trans-unit>
        <trans-unit id="37a74b5a5b038401ba585b82ac648a38ee34ae7d" translate="yes" xml:space="preserve">
          <source>An immediate for and/xor/or instructions. const_int is treated as a 64 bit value.</source>
          <target state="translated">const_int被视为64位的值。</target>
        </trans-unit>
        <trans-unit id="724f31235beec2d91358f29c81609301ddfe064d" translate="yes" xml:space="preserve">
          <source>An immediate for most arithmetic instructions. const_int is treated as a 32 bit value.</source>
          <target state="translated">const_int被视为一个32位的值。</target>
        </trans-unit>
        <trans-unit id="ba5952eb86810c12a13a67307b761f420789e80d" translate="yes" xml:space="preserve">
          <source>An immediate for shift and rotate instructions. const_int is treated as a 32 bit value.</source>
          <target state="translated">const_int作为32位值处理。</target>
        </trans-unit>
        <trans-unit id="4f576fc6545e2a7ed32b49891eee7158495619f8" translate="yes" xml:space="preserve">
          <source>An immediate for the &lt;code&gt;iohl&lt;/code&gt; instruction. const_int is sign extended to 128 bit.</source>
          <target state="translated">&lt;code&gt;iohl&lt;/code&gt; 指令的立即数。const_int被符号扩展到128位。</target>
        </trans-unit>
        <trans-unit id="fa46e8c9174bfc14d1e6484c608422836253b5fc" translate="yes" xml:space="preserve">
          <source>An immediate for the &lt;code&gt;iohl&lt;/code&gt; instruction. const_int is treated as a 32 bit value.</source>
          <target state="translated">&lt;code&gt;iohl&lt;/code&gt; 指令的立即数。const_int被视为32位值。</target>
        </trans-unit>
        <trans-unit id="a4ad2e9f47c35dba5c3a654586cfbfd37c2d1074" translate="yes" xml:space="preserve">
          <source>An immediate for the &lt;code&gt;iohl&lt;/code&gt; instruction. const_int is treated as a 64 bit value.</source>
          <target state="translated">&lt;code&gt;iohl&lt;/code&gt; 指令的立即数。const_int被视为64位值。</target>
        </trans-unit>
        <trans-unit id="fb6b5c59189bcd298a8c54b0d5b72012198931a3" translate="yes" xml:space="preserve">
          <source>An immediate integer operand (one with constant value) is allowed. This includes symbolic constants whose values will be known only at assembly time or later.</source>
          <target state="translated">允许使用直接的整数操作数(具有常量值的操作数),这包括只有在装配时或以后才知道其值的符号常量。这包括那些只有在装配时或以后才知道其值的符号常数。</target>
        </trans-unit>
        <trans-unit id="e84f183cbd16bd54d89a362096c570a83e737d81" translate="yes" xml:space="preserve">
          <source>An immediate integer operand whose value is not an explicit integer is allowed.</source>
          <target state="translated">允许使用值不是显式整数的立即整数操作数。</target>
        </trans-unit>
        <trans-unit id="3dcd4c571d6303522812fd66511c9efeae10aff4" translate="yes" xml:space="preserve">
          <source>An immediate integer operand with a known numeric value is allowed. Many systems cannot support assembly-time constants for operands less than a word wide. Constraints for these operands should use &amp;lsquo;</source>
          <target state="translated">允许使用具有已知数值的立即整数操作数。许多系统不能支持小于一字宽的操作数的汇编时常数。这些操作数的约束应使用'</target>
        </trans-unit>
        <trans-unit id="fead0cb9bc3652a20a6803e3e14fb097bc244e18" translate="yes" xml:space="preserve">
          <source>An immediate operand for R2 andchi/andci instructions.</source>
          <target state="translated">R2和chi/andci指令的直接操作数。</target>
        </trans-unit>
        <trans-unit id="ac68e335d064a71570d610173f680ac5fbe05513" translate="yes" xml:space="preserve">
          <source>An immediate which can be loaded with &lt;code&gt;fsmbi&lt;/code&gt;.</source>
          <target state="translated">可以加载 &lt;code&gt;fsmbi&lt;/code&gt; 的立即数。</target>
        </trans-unit>
        <trans-unit id="ea450ed2fe096f001d0fa25412cdd9e4110db1ae" translate="yes" xml:space="preserve">
          <source>An immediate which can be loaded with the il/ila/ilh/ilhu instructions. const_int is sign extended to 128 bit.</source>
          <target state="translated">可以用il/ila/ilh/ilhu指令来加载的即时指令。 const_int是符号扩展到128位。</target>
        </trans-unit>
        <trans-unit id="7c728956eab601b71ea1ef8510f9ed46b01e9678" translate="yes" xml:space="preserve">
          <source>An immediate which can be loaded with the il/ila/ilh/ilhu instructions. const_int is treated as a 32 bit value.</source>
          <target state="translated">可以用il/ila/ilh/ilhu指令来加载的即时值。 const_int被视为32位的值。</target>
        </trans-unit>
        <trans-unit id="8b91f62ddf90eb3045924f61638e2ed286dc7c16" translate="yes" xml:space="preserve">
          <source>An immediate which can be loaded with the il/ila/ilh/ilhu instructions. const_int is treated as a 64 bit value.</source>
          <target state="translated">一个可以用il/ila/ilh/ilhu指令加载的即时值。 const_int被视为64位值。</target>
        </trans-unit>
        <trans-unit id="d6e53dc412a13c67bb00bedf4c0eac4f87ba77c1" translate="yes" xml:space="preserve">
          <source>An important caveat is that GCC arranges to save and restore only those registers known to the specific architecture variant being compiled for. This can make &lt;code&gt;__builtin_setjmp&lt;/code&gt; and &lt;code&gt;__builtin_longjmp&lt;/code&gt; more efficient than their library counterparts in some cases, but it can also cause incorrect and mysterious behavior when mixing with code that uses the full register set.</source>
          <target state="translated">一个重要的警告是，GCC安排仅保存和恢复正在编译的特定体系结构变体已知的那些寄存器。在某些情况下，这可以使 &lt;code&gt;__builtin_setjmp&lt;/code&gt; 和 &lt;code&gt;__builtin_longjmp&lt;/code&gt; 效率比其库同类文件更高，但在与使用完整寄存器集的代码混合时，也可能导致错误和神秘的行为。</target>
        </trans-unit>
        <trans-unit id="4bb50275db5ef990a5c71386c85806595b867df5" translate="yes" xml:space="preserve">
          <source>An indexed or indirect address.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e86c0eceb044416401abb04a6e463d5b6094cd25" translate="yes" xml:space="preserve">
          <source>An input register that is implicitly popped by the &lt;code&gt;asm&lt;/code&gt; must be explicitly clobbered, unless it is constrained to match an output operand.</source>
          <target state="translated">除非被约束为与输出操作数匹配，否则必须显式破坏由 &lt;code&gt;asm&lt;/code&gt; 隐式弹出的输入寄存器。</target>
        </trans-unit>
        <trans-unit id="7c249498e8a7c24a4e363a078596ccff4c5734ab" translate="yes" xml:space="preserve">
          <source>An integer constant in the range -255 &amp;hellip; 0</source>
          <target state="translated">范围为-255&amp;hellip;0的整数常量</target>
        </trans-unit>
        <trans-unit id="9dc7773cc8d9e6deceeb329e43d478d46251dfd7" translate="yes" xml:space="preserve">
          <source>An integer constant in the range 0 &amp;hellip; 255.</source>
          <target state="translated">一个整数常量，范围为0&amp;hellip;255。</target>
        </trans-unit>
        <trans-unit id="5b08127ba5b721033e68de80fdaced9cd1b46db8" translate="yes" xml:space="preserve">
          <source>An integer constant in the range 1 &amp;hellip; 15.</source>
          <target state="translated">范围为1&amp;hellip;15的整数常量。</target>
        </trans-unit>
        <trans-unit id="e28d87e9d901db2966f212d84f0e7048b61d9b95" translate="yes" xml:space="preserve">
          <source>An integer constant in the range 1 &amp;hellip; 7.</source>
          <target state="translated">范围为1&amp;hellip;7的整数常量。</target>
        </trans-unit>
        <trans-unit id="bcc6027cc8de73ec51a063277dae667199da440f" translate="yes" xml:space="preserve">
          <source>An integer constant that does not meet the constraints for codes &amp;lsquo;</source>
          <target state="translated">不符合代码&amp;ldquo;&amp;rdquo;约束的整数常量</target>
        </trans-unit>
        <trans-unit id="c84f7429b210360fa5c85dafb3a76127af085fed" translate="yes" xml:space="preserve">
          <source>An integer constant that fits in 16 bits.</source>
          <target state="translated">一个适合16位的整数常数。</target>
        </trans-unit>
        <trans-unit id="7ea8f3048d5d170816523d297bd8775793dabcbf" translate="yes" xml:space="preserve">
          <source>An integer constant whose low order 16 bits are zero.</source>
          <target state="translated">一个整数常数,其低阶16位为零。</target>
        </trans-unit>
        <trans-unit id="91669a0b9c65d1cc6722fd1ac4e811cb3b9462cf" translate="yes" xml:space="preserve">
          <source>An integer constant with all bits set except exactly one.</source>
          <target state="translated">一个整数常数,所有的位都被设置了,除了一个。</target>
        </trans-unit>
        <trans-unit id="21493d2e6936d92d54e34c6a9c53ba6429a374d6" translate="yes" xml:space="preserve">
          <source>An integer constant with exactly a single bit set.</source>
          <target state="translated">一个整数常数,正好设置了一个位。</target>
        </trans-unit>
        <trans-unit id="148e29efc3e25eee684ae13925c5fb8932f17d90" translate="yes" xml:space="preserve">
          <source>An integer equal to one of the MACFLAG_XXX constants that is suitable for use only with accumulator A1.</source>
          <target state="translated">一个等于MACFLAG_XXX常数的整数,只适合用于累加器A1。</target>
        </trans-unit>
        <trans-unit id="f4afba48092a6cec863cdd332d5c5c0ad22e2831" translate="yes" xml:space="preserve">
          <source>An integer equal to one of the MACFLAG_XXX constants that is suitable for use with either accumulator.</source>
          <target state="translated">一个等于MACFLAG_XXX常数的整数,适合与任何一个累加器一起使用。</target>
        </trans-unit>
        <trans-unit id="ff1c35a13fe5ef99c7a9d9e7d6ae5125aea6469c" translate="yes" xml:space="preserve">
          <source>An interrupt handler must be declared with a mandatory pointer argument:</source>
          <target state="translated">中断处理程序必须声明一个强制性的指针参数。</target>
        </trans-unit>
        <trans-unit id="d371e86b4fb307c14a25adf02422873dfe31a1a2" translate="yes" xml:space="preserve">
          <source>An inverted bitfield mask suitable for bext or bins</source>
          <target state="translated">适用于bext或bins的倒置位场掩码。</target>
        </trans-unit>
        <trans-unit id="d009fe9b76c291a5aa0c7f6c1e8d1138fabbeb43" translate="yes" xml:space="preserve">
          <source>An item in the constant pool</source>
          <target state="translated">常量池中的一个项目</target>
        </trans-unit>
        <trans-unit id="4793f292bc93fcd62120f48245f5e44fb822389b" translate="yes" xml:space="preserve">
          <source>An object file to be fed straight into linking. Any file name with no recognized suffix is treated this way.</source>
          <target state="translated">要直接送入链接的对象文件。任何没有公认后缀的文件名都会被这样处理。</target>
        </trans-unit>
        <trans-unit id="bf8b9f9703de2f2ca710a30d52808d7dca0bcb72" translate="yes" xml:space="preserve">
          <source>An object whose identifier is declared with the storage-class specifier &lt;code&gt;__thread&lt;/code&gt; has &lt;em&gt;thread storage duration&lt;/em&gt;. Its lifetime is the entire execution of the thread, and its stored value is initialized only once, prior to thread startup.</source>
          <target state="translated">使用存储类说明 &lt;code&gt;__thread&lt;/code&gt; 声明其标识符的对象具有&lt;em&gt;线程存储期限&lt;/em&gt;。它的生命周期是线程的整个执行过程，并且在线程启动之前，它的存储值仅初始化一次。</target>
        </trans-unit>
        <trans-unit id="52a7967fec1a33e4d839edd6eff5a38decb9b59d" translate="yes" xml:space="preserve">
          <source>An offset address</source>
          <target state="translated">一个偏移地址</target>
        </trans-unit>
        <trans-unit id="89feeff33c633de750f5bb644b0891d21925addb" translate="yes" xml:space="preserve">
          <source>An offset address.</source>
          <target state="translated">一个偏移地址。</target>
        </trans-unit>
        <trans-unit id="aa367c1ec44c9cba3102e666432b6606342ed893" translate="yes" xml:space="preserve">
          <source>An operand that is a valid memory address is allowed. This is for &amp;ldquo;load address&amp;rdquo; and &amp;ldquo;push address&amp;rdquo; instructions.</source>
          <target state="translated">允许的操作数是有效的内存地址。这用于&amp;ldquo;加载地址&amp;rdquo;和&amp;ldquo;推送地址&amp;rdquo;指令。</target>
        </trans-unit>
        <trans-unit id="44a3bc3b1208cdb1273c2b09519bfd9e1cfc45ea" translate="yes" xml:space="preserve">
          <source>An operand that matches the specified operand number is allowed. If a digit is used together with letters within the same alternative, the digit should come last.</source>
          <target state="translated">允许使用与指定操作数相匹配的操作数。如果一个数字与字母在同一选项中同时使用,则该数字应排在最后。</target>
        </trans-unit>
        <trans-unit id="d0d03643cf5743c896341a88665563cee4e7f14b" translate="yes" xml:space="preserve">
          <source>An optimization that assumes that signed overflow does not occur is perfectly safe if the values of the variables involved are such that overflow never does, in fact, occur. Therefore this warning can easily give a false positive: a warning about code that is not actually a problem. To help focus on important issues, several warning levels are defined. No warnings are issued for the use of undefined signed overflow when estimating how many iterations a loop requires, in particular when determining whether a loop will be executed at all.</source>
          <target state="translated">假设不会发生签名溢出的优化是完全安全的,如果所涉及的变量的值是这样的,溢出实际上从未发生。因此,这个警告很容易给出一个假阳性:一个关于实际上没有问题的代码的警告。为了帮助关注重要的问题,我们定义了几个警告级别。在估计一个循环需要多少次迭代时,特别是在确定一个循环是否会被执行时,使用未定义的符号溢出不会发出警告。</target>
        </trans-unit>
        <trans-unit id="b187d1cbe2c1e6182a8dd178f33fdc1911f0fd4c" translate="yes" xml:space="preserve">
          <source>An overview of these techniques, their benefits and how to use them is at &lt;a href=&quot;http://gcc.gnu.org/wiki/Visibility&quot;&gt;http://gcc.gnu.org/wiki/Visibility&lt;/a&gt;.</source>
          <target state="translated">有关这些技术及其优势以及使用方法的概述，请&lt;a href=&quot;http://gcc.gnu.org/wiki/Visibility&quot;&gt;参见http://gcc.gnu.org/wiki/Visibility&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="78963be09ff63d4ade4602b745f27f40ed01fe1b" translate="yes" xml:space="preserve">
          <source>An unsigned 16-bit constant (for logic instructions).</source>
          <target state="translated">一个无符号的16位常数(用于逻辑指令)。</target>
        </trans-unit>
        <trans-unit id="5b34b8bcf92baede87b31604702d88f2552f8622" translate="yes" xml:space="preserve">
          <source>An unsigned 16-bit constant for &lt;code&gt;iohl&lt;/code&gt; and &lt;code&gt;fsmbi&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;iohl&lt;/code&gt; 和 &lt;code&gt;fsmbi&lt;/code&gt; 的无符号16位常量。</target>
        </trans-unit>
        <trans-unit id="c10f415d71c7e7066c4b909d3f1393b2cce4e125" translate="yes" xml:space="preserve">
          <source>An unsigned 16-bit constant shifted left 16 bits (use &lt;code&gt;L&lt;/code&gt; instead for &lt;code&gt;SImode&lt;/code&gt; constants).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8cb9a0ccfe5c932918592859dcea72edc71b9826" translate="yes" xml:space="preserve">
          <source>An unsigned 16-bit constant.</source>
          <target state="translated">一个无符号的16位常数。</target>
        </trans-unit>
        <trans-unit id="bb28e9e819d64e02267cdf40ed8e86dabcf29201" translate="yes" xml:space="preserve">
          <source>An unsigned 16-bit integer constant.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40ef4bae4950c14cd2a335ebce3f24b00931f1ee" translate="yes" xml:space="preserve">
          <source>An unsigned 3-bit constant for 16-byte rotates and shifts</source>
          <target state="translated">一个无符号的3位常数,用于16字节的旋转和移位。</target>
        </trans-unit>
        <trans-unit id="95ddaf18fc4d2ab678603464648f03bb8de98a4d" translate="yes" xml:space="preserve">
          <source>An unsigned 5-bit constant.</source>
          <target state="translated">一个无符号的5位常数。</target>
        </trans-unit>
        <trans-unit id="7983abc6cf90ba7d41ddff4f3b8b3d5f6d999d50" translate="yes" xml:space="preserve">
          <source>An unsigned 5-bit integer constant (for shift counts).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6a00eda1fa05aab415bb11f10e795bf964e4785" translate="yes" xml:space="preserve">
          <source>An unsigned 7-bit constant for conversion/nop/channel instructions.</source>
          <target state="translated">一个无符号的7位常数,用于转换/nop/通道指令。</target>
        </trans-unit>
        <trans-unit id="5b0bf2d7544790a0320ec8391816f55aa165f088" translate="yes" xml:space="preserve">
          <source>An unsigned 7-bit constant whose 3 least significant bits are 0.</source>
          <target state="translated">一个无符号的7位常数,其3个最小有效位为0。</target>
        </trans-unit>
        <trans-unit id="d8264da1da251da38e16c7abcf0200adc7f6c27d" translate="yes" xml:space="preserve">
          <source>An unsigned 8-bit integer constant.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e8a3cd83ae17cf2c173ff325905d55cd210117b" translate="yes" xml:space="preserve">
          <source>An x86 example where the string memory argument is of unknown length.</source>
          <target state="translated">一个x86的例子,其中字符串内存参数是未知长度。</target>
        </trans-unit>
        <trans-unit id="8157a3070b0a23e585bb72291a5f64fac3066253" translate="yes" xml:space="preserve">
          <source>And the function names are:</source>
          <target state="translated">而函数名称是:</target>
        </trans-unit>
        <trans-unit id="cce6aeb578cc150b67e8e4f1acfc181fb9996f38" translate="yes" xml:space="preserve">
          <source>Annotate assembler instructions with estimated addresses.</source>
          <target state="translated">用估计地址来注释汇编器指令。</target>
        </trans-unit>
        <trans-unit id="295ae69532c434798f968812e2201e5c3fd052fa" translate="yes" xml:space="preserve">
          <source>Annotate assignments to user variables early in the compilation and attempt to carry the annotations over throughout the compilation all the way to the end, in an attempt to improve debug information while optimizing. Use of</source>
          <target state="translated">在编译初期对用户变量的赋值进行注释,并试图在整个编译过程中一直将注释延续到最后,试图在优化的同时改善调试信息。使用</target>
        </trans-unit>
        <trans-unit id="71fb5f4abaa1eaa677691ec6945ce018c8d3cc8a" translate="yes" xml:space="preserve">
          <source>Annotate the assembler output with a comment indicating which pattern and alternative is used. The length and cost of each instruction are also printed.</source>
          <target state="translated">在汇编器输出中加注注释,说明使用了哪种模式和替代方案。每条指令的长度和成本也被打印出来。</target>
        </trans-unit>
        <trans-unit id="93a92e7968152fb0b277671cc51df48b140f38ff" translate="yes" xml:space="preserve">
          <source>Annotate the assembler output with miscellaneous debugging information.</source>
          <target state="translated">对汇编器输出的杂项调试信息进行注释。</target>
        </trans-unit>
        <trans-unit id="989a73be7d945cbd818654da9eb44b704400138e" translate="yes" xml:space="preserve">
          <source>Another (simpler) way to enable link-time optimization is:</source>
          <target state="translated">另一种(更简单的)启用链接时间优化的方法是:。</target>
        </trans-unit>
        <trans-unit id="68f160715f630ab62644e4593ac2d81e2aac8d1b" translate="yes" xml:space="preserve">
          <source>Another consequence is that &lt;code&gt;sscanf&lt;/code&gt; does not work on some very old systems when passed a string constant as its format control string or input. This is because &lt;code&gt;sscanf&lt;/code&gt; incorrectly tries to write into the string constant. Likewise &lt;code&gt;fscanf&lt;/code&gt; and &lt;code&gt;scanf&lt;/code&gt;.</source>
          <target state="translated">另一个结果是，当将字符串常量作为格式控制字符串或输入传递时， &lt;code&gt;sscanf&lt;/code&gt; 在某些非常旧的系统上不起作用。这是因为 &lt;code&gt;sscanf&lt;/code&gt; 错误地尝试写入字符串常量。同样是 &lt;code&gt;fscanf&lt;/code&gt; 和 &lt;code&gt;scanf&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dedf5ccdeb6bf446ef7cfb01d8db4c4b042b2078" translate="yes" xml:space="preserve">
          <source>Another example:</source>
          <target state="translated">另一个例子:</target>
        </trans-unit>
        <trans-unit id="3114d5262ea0b2a7df098211946bd465d7ca75ca" translate="yes" xml:space="preserve">
          <source>Another feature of LTO is that it is possible to apply interprocedural optimizations on files written in different languages:</source>
          <target state="translated">LTO的另一个特点是可以对用不同语言编写的文件进行程序间优化。</target>
        </trans-unit>
        <trans-unit id="800bcf1831a315ef5fa60f82c87dd864fc821d9c" translate="yes" xml:space="preserve">
          <source>Another restriction is that the clobber list should not contain the stack pointer register. This is because the compiler requires the value of the stack pointer to be the same after an &lt;code&gt;asm&lt;/code&gt; statement as it was on entry to the statement. However, previous versions of GCC did not enforce this rule and allowed the stack pointer to appear in the list, with unclear semantics. This behavior is deprecated and listing the stack pointer may become an error in future versions of GCC.</source>
          <target state="translated">另一个限制是，Clobber列表不应包含堆栈指针寄存器。这是因为编译器要求在 &lt;code&gt;asm&lt;/code&gt; 语句之后，堆栈指针的值必须与进入该语句时的堆栈指针的值相同。但是，以前版本的GCC并未强制执行此规则，并允许堆栈指针以不明确的语义出现在列表中。不建议使用此行为，并且在将来的GCC版本中列出堆栈指针可能会成为错误。</target>
        </trans-unit>
        <trans-unit id="06cec1a74ddd904f5065125e6e0eba36e86de4da" translate="yes" xml:space="preserve">
          <source>Another revised ISO C++ standard was published in 2014 as ISO/IEC 14882:2014, and is referred to as C++14; before its publication it was sometimes referred to as C++1y. C++14 contains several further changes to the C++ language, all of which have been implemented in GCC. For details see &lt;a href=&quot;https://gcc.gnu.org/projects/cxx-status.html#cxx14&quot;&gt;https://gcc.gnu.org/projects/cxx-status.html#cxx14&lt;/a&gt;. To select this standard in GCC, use the option</source>
          <target state="translated">另一个修订的ISO C ++标准在2014年发布为ISO / IEC 14882：2014，被称为C ++ 14；在其发布之前，它有时被称为C ++ 1y。C ++ 14对C ++语言进行了进一步的更改，所有这些更改均已在GCC中实现。有关详细信息，请参见&lt;a href=&quot;https://gcc.gnu.org/projects/cxx-status.html#cxx14&quot;&gt;https://gcc.gnu.org/projects/cxx-status.html#cxx14&lt;/a&gt;。要在GCC中选择此标准，请使用</target>
        </trans-unit>
        <trans-unit id="100b9161d8847e18a3c098c1597e4c27bddc1e4a" translate="yes" xml:space="preserve">
          <source>Another syntax that has the same meaning, obsolete since GCC 2.5, is &amp;lsquo;</source>
          <target state="translated">自GCC 2.5起已过时的另一种具有相同含义的语法是&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="8d4503c0d7b11d51381b2775fa2f1d0bc68346b0" translate="yes" xml:space="preserve">
          <source>Another use for &lt;code&gt;__builtin_unreachable&lt;/code&gt; is following a call a function that never returns but that is not declared &lt;code&gt;__attribute__((noreturn))&lt;/code&gt;, as in this example:</source>
          <target state="translated">&lt;code&gt;__builtin_unreachable&lt;/code&gt; 的另一种用法是在调用之后执行永不返回但未声明 &lt;code&gt;__attribute__((noreturn))&lt;/code&gt; ，如本例所示：</target>
        </trans-unit>
        <trans-unit id="b5c0df1874478fedada2f09d07323584aaf952db" translate="yes" xml:space="preserve">
          <source>Another use of label values is in an interpreter for threaded code. The labels within the interpreter function can be stored in the threaded code for super-fast dispatching.</source>
          <target state="translated">标签值的另一个用途是在线程代码的解释器中。解释器函数中的标签可以存储在线程代码中,以实现超快的调度。</target>
        </trans-unit>
        <trans-unit id="054bb42dabc9a19f68ad68065d19f8cf04a8d0cf" translate="yes" xml:space="preserve">
          <source>Another way to refer to the type of an expression is with &lt;code&gt;typeof&lt;/code&gt;. The syntax of using of this keyword looks like &lt;code&gt;sizeof&lt;/code&gt;, but the construct acts semantically like a type name defined with &lt;code&gt;typedef&lt;/code&gt;.</source>
          <target state="translated">引用表达式类型的另一种方法是使用 &lt;code&gt;typeof&lt;/code&gt; 。使用此关键字的语法看起来像 &lt;code&gt;sizeof&lt;/code&gt; ，但是该构造在语义上类似于使用 &lt;code&gt;typedef&lt;/code&gt; 定义的类型名称。</target>
        </trans-unit>
        <trans-unit id="a721e97bbca8eab5f82eabfccb957a729c8f492f" translate="yes" xml:space="preserve">
          <source>Another way to specify a prefix much like the</source>
          <target state="translated">另一种指定前缀的方式很像</target>
        </trans-unit>
        <trans-unit id="96409c8e4594c5ca23408453d9c7d3939d189e53" translate="yes" xml:space="preserve">
          <source>Another, similar example involves calling member functions of a base class:</source>
          <target state="translated">另一个类似的例子是调用基类的成员函数。</target>
        </trans-unit>
        <trans-unit id="53491a8e8187c94a2d02f53706e5a4e898389bcf" translate="yes" xml:space="preserve">
          <source>Any 80387 floating-point (stack) register.</source>
          <target state="translated">任何80387浮点(栈)寄存器。</target>
        </trans-unit>
        <trans-unit id="b3758814c17061e556dad37977ffba674151e160" translate="yes" xml:space="preserve">
          <source>Any &lt;code&gt;symbol_ref&lt;/code&gt; or &lt;code&gt;label_ref&lt;/code&gt;</source>
          <target state="translated">任何 &lt;code&gt;symbol_ref&lt;/code&gt; 或 &lt;code&gt;label_ref&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b2f752342a0bbfde2ec460c7e0098752d0a9c8ba" translate="yes" xml:space="preserve">
          <source>Any &lt;code&gt;unspec&lt;/code&gt;</source>
          <target state="translated">任何不 &lt;code&gt;unspec&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="08321582787b969fc3f46ec2caec6f021be74d45" translate="yes" xml:space="preserve">
          <source>Any D, P, B, M, I or L register.</source>
          <target state="translated">任何D、P、B、M、I或L寄存器。</target>
        </trans-unit>
        <trans-unit id="a4d7faf7c72e44e81295ee83f9349235dc1598af" translate="yes" xml:space="preserve">
          <source>Any EVEX encodable SSE register (&lt;code&gt;%xmm0-%xmm31&lt;/code&gt;).</source>
          <target state="translated">任何EVEX可编码的SSE寄存器（ &lt;code&gt;%xmm0-%xmm31&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="162a9ef967e5306147bc46c88126767e87c35020" translate="yes" xml:space="preserve">
          <source>Any MMX register.</source>
          <target state="translated">任何MMX寄存器。</target>
        </trans-unit>
        <trans-unit id="6c6a18dc34784ab21c4ba11b353b499414254204" translate="yes" xml:space="preserve">
          <source>Any SSE register.</source>
          <target state="translated">任何上交所登记。</target>
        </trans-unit>
        <trans-unit id="6050748b38d243b476a4baca6c16743585fafbd7" translate="yes" xml:space="preserve">
          <source>Any SYMBOL_REF.</source>
          <target state="translated">任何SYMBOL_REF。</target>
        </trans-unit>
        <trans-unit id="458f2948a2c464f5746c7ffc43449a651a2011cd" translate="yes" xml:space="preserve">
          <source>Any VSX register if the</source>
          <target state="translated">任何VSX寄存器,如果</target>
        </trans-unit>
        <trans-unit id="d8389ba5b054471dbefb65e013349dc9adfee3c7" translate="yes" xml:space="preserve">
          <source>Any array can be subscripted, even if not an lvalue.</source>
          <target state="translated">任何数组都可以下标,即使不是一个l值。</target>
        </trans-unit>
        <trans-unit id="b906590ae8882826b85c1f14c38d4cf1bfbb5d1f" translate="yes" xml:space="preserve">
          <source>Any condition register field, &lt;code&gt;cr0&lt;/code&gt;&amp;hellip;&lt;code&gt;cr7&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14b564784ad63437bf2bebc716f7f298f61a5028" translate="yes" xml:space="preserve">
          <source>Any const_double value.</source>
          <target state="translated">任何const_double值。</target>
        </trans-unit>
        <trans-unit id="1e9dc0d4d4d3fa3953a7b89d1659a04266824dc2" translate="yes" xml:space="preserve">
          <source>Any control register, when they&amp;rsquo;re 16 bits wide (nothing if control registers are 24 bits wide)</source>
          <target state="translated">任何控制寄存器，当它们为16位宽时（如果控制寄存器为24位宽则什么都不是）</target>
        </trans-unit>
        <trans-unit id="dcdd92208f9952a1f355fdf3b7526b8f7a44d2c0" translate="yes" xml:space="preserve">
          <source>Any control register, when they&amp;rsquo;re 24 bits wide.</source>
          <target state="translated">任何控制寄存器，当它们为24位宽时。</target>
        </trans-unit>
        <trans-unit id="7e9a960c7b57410e9d4ca5df2e5f2e42c59f7d8b" translate="yes" xml:space="preserve">
          <source>Any data or pointers to the non-generic address spaces must be qualified as &lt;code&gt;const&lt;/code&gt;, i.e. as read-only data. This still applies if the data in one of these address spaces like software version number or calibration lookup table are intended to be changed after load time by, say, a boot loader. In this case the right qualification is &lt;code&gt;const&lt;/code&gt;&lt;code&gt;volatile&lt;/code&gt; so that the compiler must not optimize away known values or insert them as immediates into operands of instructions.</source>
          <target state="translated">指向非通用地址空间的任何数据或指针都必须被限定为 &lt;code&gt;const&lt;/code&gt; ，即只读数据。如果打算在加载时间之后通过引导加载程序更改这些地址空间之一中的数据（例如软件版本号或校准查找表）中的数据，则该设置仍然适用。在这种情况下，正确的限定是 &lt;code&gt;const&lt;/code&gt; &lt;code&gt;volatile&lt;/code&gt; 因此编译器不得优化已知值或将它们作为立即数插入指令操作数中。</target>
        </trans-unit>
        <trans-unit id="05a587b8fa898666a201d21b98455df1bf047bae" translate="yes" xml:space="preserve">
          <source>Any data with the &lt;code&gt;noinit&lt;/code&gt; attribute will not be initialised by the C runtime startup code, or the program loader. Not initialising data in this way can reduce program startup times.</source>
          <target state="translated">具有 &lt;code&gt;noinit&lt;/code&gt; 属性的任何数据都不会由C运行时启动代码或程序加载器初始化。不以这种方式初始化数据可以减少程序启动时间。</target>
        </trans-unit>
        <trans-unit id="b31ade70b5b6adb7eda689c140579a407cbd5f8e" translate="yes" xml:space="preserve">
          <source>Any data with the &lt;code&gt;noinit&lt;/code&gt; attribute will not be initialized by the C runtime startup code, or the program loader. Not initializing data in this way can reduce program startup times. This attribute is specific to ELF targets and relies on the linker to place such data in the right location</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1647cf01ffb6c880e2cc9ddc546cf116110a80e6" translate="yes" xml:space="preserve">
          <source>Any dependence for which the latency is greater than or equal to &lt;var&gt;number&lt;/var&gt; is costly.</source>
          <target state="translated">延迟大于或等于 &lt;var&gt;number&lt;/var&gt; 任何依赖关系成本很高。</target>
        </trans-unit>
        <trans-unit id="54d255d43091079c6ba1e5343929cbd0d4605f04" translate="yes" xml:space="preserve">
          <source>Any dependence from store to load is costly.</source>
          <target state="translated">从门店到负载的任何依赖性都是昂贵的。</target>
        </trans-unit>
        <trans-unit id="32b989b6176274d8479bf98d4817d8a49a56f0e0" translate="yes" xml:space="preserve">
          <source>Any directories specified with</source>
          <target state="translated">任何用</target>
        </trans-unit>
        <trans-unit id="1d356594a5d83b50830291445eb406f59dd05afc" translate="yes" xml:space="preserve">
          <source>Any expression of type &lt;code&gt;void *&lt;/code&gt; is allowed.</source>
          <target state="translated">允许使用任何类型为 &lt;code&gt;void *&lt;/code&gt; 的表达式。</target>
        </trans-unit>
        <trans-unit id="68030c2dfbf4d205419f4c53b98009b37766c0cb" translate="yes" xml:space="preserve">
          <source>Any extended integer types that exist in the implementation (C99 and C11 6.2.5).</source>
          <target state="translated">执行中存在的任何扩展整数类型(C99和C11 6.2.5)。</target>
        </trans-unit>
        <trans-unit id="6f1de0dfba46a4460bfe571dd6ce87a521e49944" translate="yes" xml:space="preserve">
          <source>Any interruptible-without-stack-switch code must be compiled with</source>
          <target state="translated">任何无堆栈开关的可中断代码都必须用以下方法编译</target>
        </trans-unit>
        <trans-unit id="d0a99fee73d1a0400c42d60b6ea95667d276cf8e" translate="yes" xml:space="preserve">
          <source>Any list of specifiers and qualifiers at the start of a declaration may contain attribute specifiers, whether or not such a list may in that context contain storage class specifiers. (Some attributes, however, are essentially in the nature of storage class specifiers, and only make sense where storage class specifiers may be used; for example, &lt;code&gt;section&lt;/code&gt;.) There is one necessary limitation to this syntax: the first old-style parameter declaration in a function definition cannot begin with an attribute specifier, because such an attribute applies to the function instead by syntax described below (which, however, is not yet implemented in this case). In some other cases, attribute specifiers are permitted by this grammar but not yet supported by the compiler. All attribute specifiers in this place relate to the declaration as a whole. In the obsolescent usage where a type of &lt;code&gt;int&lt;/code&gt; is implied by the absence of type specifiers, such a list of specifiers and qualifiers may be an attribute specifier list with no other specifiers or qualifiers.</source>
          <target state="translated">声明开始处的任何说明符和限定符列表都可以包含属性说明符，无论该列表在该上下文中是否可以包含存储类说明符。（但是，某些属性本质上是存储类说明符的性质，并且仅在可以使用存储类说明符的地方有意义；例如， &lt;code&gt;section&lt;/code&gt; 。）对该语法有一个必要的限制：函数定义中的第一个旧式参数声明不能​​以属性说明符开头，因为这样的属性适用于函数，而不是通过下面描述的语法（但是还没有）在这种情况下实施）。在某些其他情况下，该语法允许属性说明符，但编译器尚不支持属性说明符。这个地方的所有属性说明符都与整个声明有关。在由于没有类型说明符而隐含 &lt;code&gt;int&lt;/code&gt; 类型的过时用法中，此类说明符和限定符的列表可能是没有其他说明符或限定符的属性说明符列表。</target>
        </trans-unit>
        <trans-unit id="c6c0071eb01b7f92c396e6d09604df6a2e8de02f" translate="yes" xml:space="preserve">
          <source>Any macros defined before the precompiled header is included must either be defined in the same way as when the precompiled header was generated, or must not affect the precompiled header, which usually means that they don&amp;rsquo;t appear in the precompiled header at all.</source>
          <target state="translated">包含预编译头之前定义的任何宏都必须以与生成预编译头时相同的方式定义，或者必须不影响预编译头，这通常意味着它们根本不会出现在预编译头中。</target>
        </trans-unit>
        <trans-unit id="0b92c247ae43e16cb2206e363e27a0e1ea146660" translate="yes" xml:space="preserve">
          <source>Any memory reference to an address in the far address space.</source>
          <target state="translated">对远地址空间中一个地址的任何内存引用。</target>
        </trans-unit>
        <trans-unit id="e16a334f229304e5f8dc7cc1bd4372e8b13392d9" translate="yes" xml:space="preserve">
          <source>Any memory reference to an address in the near address space.</source>
          <target state="translated">对近地址空间中地址的任何内存引用。</target>
        </trans-unit>
        <trans-unit id="fd3f2043c21601ac2916c25995530fdcaff3e36d" translate="yes" xml:space="preserve">
          <source>Any mode at function entry is valid, and retained or restored when the function returns, and when it calls other functions. This mode is useful for compiling libraries or other compilation units you might want to incorporate into different programs with different prevailing FPU modes, and the convenience of being able to use a single object file outweighs the size and speed overhead for any extra mode switching that might be needed, compared with what would be needed with a more specific choice of prevailing FPU mode.</source>
          <target state="translated">在函数进入时的任何模式都是有效的,并且在函数返回时,以及调用其他函数时保留或恢复。这种模式对于编译库或其他编译单元很有用,你可能想将其纳入到不同的程序中,并采用不同的盛行FPU模式,与更具体的盛行FPU模式选择相比,能够使用单个对象文件的便利性超过了可能需要的任何额外模式切换的大小和速度开销。</target>
        </trans-unit>
        <trans-unit id="22db441873bce8bb93866379f320414a736631d8" translate="yes" xml:space="preserve">
          <source>Any of the SVE predicate registers (&lt;code&gt;P0&lt;/code&gt; to &lt;code&gt;P15&lt;/code&gt;)</source>
          <target state="translated">任何SVE谓词寄存器（ &lt;code&gt;P0&lt;/code&gt; 至 &lt;code&gt;P15&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="adb9f4f59a4cdd5c36fdb71fd2855542ab27a73f" translate="yes" xml:space="preserve">
          <source>Any of the floating point registers (AC0 through AC5).</source>
          <target state="translated">任何一个浮点寄存器(AC0至AC5)。</target>
        </trans-unit>
        <trans-unit id="9b07ecf518f850aa2d367035bbfbe9f027595c80" translate="yes" xml:space="preserve">
          <source>Any operand whatsoever is allowed.</source>
          <target state="translated">任何操作数都是允许的。</target>
        </trans-unit>
        <trans-unit id="f68eb98cf68489e1273e0a62b2ba59241c457e20" translate="yes" xml:space="preserve">
          <source>Any register</source>
          <target state="translated">任何登记册</target>
        </trans-unit>
        <trans-unit id="3553311a1c2384ac5d5327beb00f7dd79264da05" translate="yes" xml:space="preserve">
          <source>Any register accessible as &lt;code&gt;&lt;var&gt;r&lt;/var&gt;h&lt;/code&gt;: &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt;, &lt;code&gt;c&lt;/code&gt;, and &lt;code&gt;d&lt;/code&gt;.</source>
          <target state="translated">任何可作为 &lt;code&gt;&lt;var&gt;r&lt;/var&gt;h&lt;/code&gt; 访问的寄存器： &lt;code&gt;a&lt;/code&gt; ， &lt;code&gt;b&lt;/code&gt; ， &lt;code&gt;c&lt;/code&gt; 和 &lt;code&gt;d&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0809f627bf7826a77322582ca3922a14c79d5ea4" translate="yes" xml:space="preserve">
          <source>Any register accessible as &lt;code&gt;&lt;var&gt;r&lt;/var&gt;l&lt;/code&gt;. In 32-bit mode, &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt;, &lt;code&gt;c&lt;/code&gt;, and &lt;code&gt;d&lt;/code&gt;; in 64-bit mode, any integer register.</source>
          <target state="translated">任何可作为 &lt;code&gt;&lt;var&gt;r&lt;/var&gt;l&lt;/code&gt; 访问的寄存器。在32位模式下， &lt;code&gt;a&lt;/code&gt; ， &lt;code&gt;b&lt;/code&gt; ， &lt;code&gt;c&lt;/code&gt; 和 &lt;code&gt;d&lt;/code&gt; ；在64位模式下，任何整数寄存器。</target>
        </trans-unit>
        <trans-unit id="c586b6a4345439cd7c8437d618d713fde64e21d5" translate="yes" xml:space="preserve">
          <source>Any register except accumulators or CC.</source>
          <target state="translated">除累加器或CC外的任何寄存器。</target>
        </trans-unit>
        <trans-unit id="6f5e5f5ddbf2830c0d8f5e8f65ca789f3fd09903" translate="yes" xml:space="preserve">
          <source>Any register, memory or immediate integer operand is allowed, except for registers that are not general registers.</source>
          <target state="translated">除了不是一般寄存器的寄存器外,任何寄存器、存储器或立即整数操作数都是允许的。</target>
        </trans-unit>
        <trans-unit id="7d047e8a746fffe93cd425189ec60df3684116e7" translate="yes" xml:space="preserve">
          <source>Any variable with the &lt;code&gt;based&lt;/code&gt; attribute is assigned to the &lt;code&gt;.based&lt;/code&gt; section, and is accessed with relative to the &lt;code&gt;$tp&lt;/code&gt; register.</source>
          <target state="translated">与任何变量 &lt;code&gt;based&lt;/code&gt; 属性分配给 &lt;code&gt;.based&lt;/code&gt; 截面，并且相对于所访问的 &lt;code&gt;$tp&lt;/code&gt; 寄存器。</target>
        </trans-unit>
        <trans-unit id="8e967d4316910c49c908407ba08671d2b2599c34" translate="yes" xml:space="preserve">
          <source>Any variable with the &lt;code&gt;persistent&lt;/code&gt; attribute will not be initialised by the C runtime startup code. Instead its value will be set once, when the application is loaded, and then never initialised again, even if the processor is reset or the program restarts. Persistent data is intended to be placed into FLASH RAM, where its value will be retained across resets. The linker script being used to create the application should ensure that persistent data is correctly placed.</source>
          <target state="translated">具有 &lt;code&gt;persistent&lt;/code&gt; 属性的任何变量都不会由C运行时启动代码初始化。取而代之的是，它的值将在加载应用程序时设置一次，然后再也不会初始化，即使处理器已重置或程序重新启动也是如此。永久性数据应放入闪存RAM中，在复位后将保留其值。用于创建应用程序的链接描述文件应确保正确放置了持久数据。</target>
        </trans-unit>
        <trans-unit id="6814c1eba0c0bb145d77465185a812135711db30" translate="yes" xml:space="preserve">
          <source>Append &lt;var&gt;dir&lt;/var&gt; to the prefix specified previously with</source>
          <target state="translated">将 &lt;var&gt;dir&lt;/var&gt; 附加到先前指定的前缀</target>
        </trans-unit>
        <trans-unit id="812a14ffbe77d828291132cdec93d807373c47c5" translate="yes" xml:space="preserve">
          <source>Application register residing in I-unit</source>
          <target state="translated">居住在I单元的申请登记册</target>
        </trans-unit>
        <trans-unit id="1236d15ff73551e90456786e45b32e0be147101a" translate="yes" xml:space="preserve">
          <source>Application register residing in M-unit</source>
          <target state="translated">居住在M单元的申请登记册</target>
        </trans-unit>
        <trans-unit id="157c651a499c80b5c8fd2d703d99af67d3154b57" translate="yes" xml:space="preserve">
          <source>Apply partitioned execution optimizations. This is the default when any level of optimization is selected.</source>
          <target state="translated">应用分区执行优化。当选择任何级别的优化时,这是默认的。</target>
        </trans-unit>
        <trans-unit id="1782ef9fd22ce5aa8daf22e12703623a7b69b3eb" translate="yes" xml:space="preserve">
          <source>Apply the &lt;code&gt;longcall&lt;/code&gt; attribute to all subsequent function declarations.</source>
          <target state="translated">将 &lt;code&gt;longcall&lt;/code&gt; 属性应用于所有后续函数声明。</target>
        </trans-unit>
        <trans-unit id="282eae08ca98891b7edf1b6d8797fd6b87a9eaef" translate="yes" xml:space="preserve">
          <source>Apply unroll and jam transformations on feasible loops. In a loop nest this unrolls the outer loop by some factor and fuses the resulting multiple inner loops. This flag is enabled by default at</source>
          <target state="translated">在可行的循环上应用展开和卡位变换。在一个循环嵌套中,这将外循环按一定的系数展开,并将产生的多个内循环融合。这个标志默认在</target>
        </trans-unit>
        <trans-unit id="b040b4179b8b00702858fdb4c1afec3d6d284509" translate="yes" xml:space="preserve">
          <source>Architecture</source>
          <target state="translated">Architecture</target>
        </trans-unit>
        <trans-unit id="5180e6ec8c8c3a9e7de475a7424e90e67f44108f" translate="yes" xml:space="preserve">
          <source>Arguments of type &lt;code&gt;uh&lt;/code&gt;, &lt;code&gt;uw1&lt;/code&gt;, &lt;code&gt;sw1&lt;/code&gt;, &lt;code&gt;uw2&lt;/code&gt; and &lt;code&gt;sw2&lt;/code&gt; are evaluated at run time. They correspond to register operands in the underlying FR-V instructions.</source>
          <target state="translated">在运行时评估类型 &lt;code&gt;uh&lt;/code&gt; ， &lt;code&gt;uw1&lt;/code&gt; ， &lt;code&gt;sw1&lt;/code&gt; ， &lt;code&gt;uw2&lt;/code&gt; 和 &lt;code&gt;sw2&lt;/code&gt; 的参数。它们对应于基础FR-V指令中的寄存器操作数。</target>
        </trans-unit>
        <trans-unit id="27b636e6a8cfc32ea746d5e97119c5c9f0abb374" translate="yes" xml:space="preserve">
          <source>Arguments that are documented as &lt;code&gt;const int&lt;/code&gt; require literal integral values within the range required for that operation.</source>
          <target state="translated">记录为 &lt;code&gt;const int&lt;/code&gt; 的参数需要该操作所需范围内的文字整数值。</target>
        </trans-unit>
        <trans-unit id="56dc33ad93362bc115e17a1a1f9e847be1eea766" translate="yes" xml:space="preserve">
          <source>Arithmetic on &lt;code&gt;void&lt;/code&gt;-pointers and function pointers.</source>
          <target state="translated">&lt;code&gt;void&lt;/code&gt; 指针和函数指针的算术运算。</target>
        </trans-unit>
        <trans-unit id="69bbb6fc13a2914af3927b07e93cd7741bc9feb7" translate="yes" xml:space="preserve">
          <source>Armv8-A</source>
          <target state="translated">Armv8-A</target>
        </trans-unit>
        <trans-unit id="660e1e41a2fb561d4417587f9d3cb0a826807dab" translate="yes" xml:space="preserve">
          <source>Armv8.1-A</source>
          <target state="translated">Armv8.1-A</target>
        </trans-unit>
        <trans-unit id="068702f6b509e3ebf3a7362a3b6109bad1bc317c" translate="yes" xml:space="preserve">
          <source>Armv8.2-A</source>
          <target state="translated">Armv8.2-A</target>
        </trans-unit>
        <trans-unit id="9fe2d2038a9bf766f6b65dbcea4a2090d8403b7b" translate="yes" xml:space="preserve">
          <source>Armv8.3-A</source>
          <target state="translated">Armv8.3-A</target>
        </trans-unit>
        <trans-unit id="0c3f33729a39f559eae20d5545e995ad551dd902" translate="yes" xml:space="preserve">
          <source>Armv8.4-A</source>
          <target state="translated">Armv8.4-A</target>
        </trans-unit>
        <trans-unit id="255ee3b7801398dad2fbbd56f35d7d60c8e0a39d" translate="yes" xml:space="preserve">
          <source>Armv8.5-A</source>
          <target state="translated">Armv8.5-A</target>
        </trans-unit>
        <trans-unit id="4b5d9fa165aea4d969d0093fec00424d91bb68a1" translate="yes" xml:space="preserve">
          <source>Armv8.6-A</source>
          <target state="translated">Armv8.6-A</target>
        </trans-unit>
        <trans-unit id="b47ecbfd9e2fe292a564bf4865f526df3c8781c7" translate="yes" xml:space="preserve">
          <source>Arrays whose length is computed at run time.</source>
          <target state="translated">数组的长度是在运行时计算的。</target>
        </trans-unit>
        <trans-unit id="62bbe9126770d1f883012b542af60463a81fc16c" translate="yes" xml:space="preserve">
          <source>As a GNU extension, GCC allows initialization of objects with static storage duration by compound literals (which is not possible in ISO C99 because the initializer is not a constant). It is handled as if the object were initialized only with the brace-enclosed list if the types of the compound literal and the object match. The elements of the compound literal must be constant. If the object being initialized has array type of unknown size, the size is determined by the size of the compound literal.</source>
          <target state="translated">作为GNU的扩展,GCC允许通过复合字元初始化具有静态存储持续时间的对象(这在ISO C99中是不可能的,因为初始化器不是一个常量)。如果复合文字的类型和对象的类型相匹配,它的处理方式就像只用括号封闭的列表初始化对象一样。复合文字的元素必须是常数。如果被初始化的对象具有未知大小的数组类型,其大小由复合文字的大小决定。</target>
        </trans-unit>
        <trans-unit id="f0b14342b73dd91f2d28adcdc3851266c0e2adc9" translate="yes" xml:space="preserve">
          <source>As a part of ACLE, GCC implements extensions for Advanced SIMD as described in the ARM C Language Extensions Specification. The complete list of Advanced SIMD intrinsics can be found at &lt;a href=&quot;http://infocenter.arm.com/help/topic/com.arm.doc.ihi0073a/IHI0073A_arm_neon_intrinsics_ref.pdf&quot;&gt;http://infocenter.arm.com/help/topic/com.arm.doc.ihi0073a/IHI0073A_arm_neon_intrinsics_ref.pdf&lt;/a&gt;. The built-in intrinsics for the Advanced SIMD extension are available when NEON is enabled.</source>
          <target state="translated">作为ACLE的一部分，GCC实现了ARM C语言扩展规范中描述的Advanced SIMD扩展。可以在&lt;a href=&quot;http://infocenter.arm.com/help/topic/com.arm.doc.ihi0073a/IHI0073A_arm_neon_intrinsics_ref.pdf&quot;&gt;http://infocenter.arm.com/help/topic/com.arm.doc.ihi0073a/IHI0073A_arm_neon_intrinsics_ref.pdf&lt;/a&gt;上找到Advanced SIMD内部函数的完整列表。启用NEON时，可以使用Advanced SIMD扩展的内置内在函数。</target>
        </trans-unit>
        <trans-unit id="3bf025a6b55c5b2b4d36feb2983875ada48832c0" translate="yes" xml:space="preserve">
          <source>As a result, if a function compiled with Sun CC takes the address of an argument of type &lt;code&gt;double&lt;/code&gt; and passes this pointer of type &lt;code&gt;double *&lt;/code&gt; to a function compiled with GCC, dereferencing the pointer may cause a fatal signal.</source>
          <target state="translated">结果，如果使用Sun CC编译的函数采用 &lt;code&gt;double&lt;/code&gt; 精度类型的参数的地址，并将该类型为 &lt;code&gt;double *&lt;/code&gt; 的指针传递给使用GCC编译的函数，则取消引用该指针可能会导致致命信号。</target>
        </trans-unit>
        <trans-unit id="70fe12b60268d72ed32d2dad542457f63b7450a6" translate="yes" xml:space="preserve">
          <source>As a result, when a file is compiled with the</source>
          <target state="translated">因此,当一个文件用</target>
        </trans-unit>
        <trans-unit id="de76cec1a0ee40014e9d6de2336c465c8c2b9403" translate="yes" xml:space="preserve">
          <source>As a special kludge, if the path provided by</source>
          <target state="translated">作为一个特殊的小工具,如果路径由</target>
        </trans-unit>
        <trans-unit id="b70ccdaa2f1d44ed8f039d89a64ebf9722e0436b" translate="yes" xml:space="preserve">
          <source>As an alternative to providing a spec string, the text following a suffix directive can be one of the following:</source>
          <target state="translated">作为提供规格字符串的替代方法,后缀指令后面的文本可以是以下内容之一。</target>
        </trans-unit>
        <trans-unit id="dddf73cd98dcce7c884fe24956533693e61e8e3f" translate="yes" xml:space="preserve">
          <source>As an example:</source>
          <target state="translated">举个例子:</target>
        </trans-unit>
        <trans-unit id="733120310e3f16a7d9b6ceb479247f71058a2dab" translate="yes" xml:space="preserve">
          <source>As an extension the integer scalar type &lt;code&gt;__int128&lt;/code&gt; is supported for targets which have an integer mode wide enough to hold 128 bits. Simply write &lt;code&gt;__int128&lt;/code&gt; for a signed 128-bit integer, or &lt;code&gt;unsigned __int128&lt;/code&gt; for an unsigned 128-bit integer. There is no support in GCC for expressing an integer constant of type &lt;code&gt;__int128&lt;/code&gt; for targets with &lt;code&gt;long long&lt;/code&gt; integer less than 128 bits wide.</source>
          <target state="translated">作为扩展，整数标量类型 &lt;code&gt;__int128&lt;/code&gt; 支持具有整数模式且宽度足以容纳128位的目标。只需为有符号的128位整数写 &lt;code&gt;__int128&lt;/code&gt; ，或为无符号的128位整数写 &lt;code&gt;unsigned __int128&lt;/code&gt; 。GCC不支持为 &lt;code&gt;long long&lt;/code&gt; 小于128位宽的长整数的目标表示类型为 &lt;code&gt;__int128&lt;/code&gt; 的整数常量。</target>
        </trans-unit>
        <trans-unit id="a3f87270bea18e65d71a654a8f0baf39b38c480a" translate="yes" xml:space="preserve">
          <source>As an extension to the C language, GCC does not use the latitude given in C99 and C11 only to treat certain aspects of signed &amp;lsquo;</source>
          <target state="translated">作为对C语言的扩展，GCC不仅使用C99和C11中给出的纬度来对待带符号的&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="4513679ee7e9cc2a019ac56fe5e24f303a414ac9" translate="yes" xml:space="preserve">
          <source>As an extension, GCC accepts variable-length arrays as a member of a structure or a union. For example:</source>
          <target state="translated">作为一种扩展,GCC接受可变长度的数组作为结构体或联合体的成员。例如:&quot;GCC接受可变长度的数组作为结构或联合体的成员。</target>
        </trans-unit>
        <trans-unit id="27e4f48620a93a562285a400297cd393c63d1803" translate="yes" xml:space="preserve">
          <source>As an extension, GNU C and GNU C++ support additional floating types, which are not supported by all targets.</source>
          <target state="translated">作为扩展,GNU C和GNU C++支持额外的浮动类型,但并非所有目标都支持。</target>
        </trans-unit>
        <trans-unit id="697b66e118a429cde99672cf767b29bbf7517cb2" translate="yes" xml:space="preserve">
          <source>As an extension, GNU C supports decimal floating types as defined in the N1312 draft of ISO/IEC WDTR24732. Support for decimal floating types in GCC will evolve as the draft technical report changes. Calling conventions for any target might also change. Not all targets support decimal floating types.</source>
          <target state="translated">作为扩展,GNU C支持ISO/IEC WDTR24732的N1312草案中定义的十进制浮动类型。GCC中对十进制浮动类型的支持将随着技术报告草案的变化而变化。任何目标的调用约定也可能会改变。并非所有目标都支持十进制浮动类型。</target>
        </trans-unit>
        <trans-unit id="1e14a45ce2c917a5c2a3b3b95aa86553c2d0d4a7" translate="yes" xml:space="preserve">
          <source>As an extension, GNU C supports fixed-point types as defined in the N1169 draft of ISO/IEC DTR 18037. Support for fixed-point types in GCC will evolve as the draft technical report changes. Calling conventions for any target might also change. Not all targets support fixed-point types.</source>
          <target state="translated">作为扩展,GNU C支持ISO/IEC DTR 18037的N1169草案中定义的定点类型。GCC对定点类型的支持将随着技术报告草案的变化而变化。任何目标的调用惯例也可能发生变化。并非所有目标都支持定点类型。</target>
        </trans-unit>
        <trans-unit id="6505eef47254e959e5dceda5b17ed5092c6fdad3" translate="yes" xml:space="preserve">
          <source>As an extension, GNU C supports named address spaces as defined in the N1275 draft of ISO/IEC DTR 18037. Support for named address spaces in GCC will evolve as the draft technical report changes. Calling conventions for any target might also change. At present, only the AVR, M32C, RL78, and x86 targets support address spaces other than the generic address space.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7086d776842151d1d2c42c2e5523eaf5840573e5" translate="yes" xml:space="preserve">
          <source>As an extension, GNU C supports named address spaces as defined in the N1275 draft of ISO/IEC DTR 18037. Support for named address spaces in GCC will evolve as the draft technical report changes. Calling conventions for any target might also change. At present, only the AVR, SPU, M32C, RL78, and x86 targets support address spaces other than the generic address space.</source>
          <target state="translated">作为扩展,GNU C支持ISO/IEC DTR 18037的N1275草案中定义的命名地址空间。GCC中对命名地址空间的支持将随着技术报告草案的变化而变化。任何目标的调用约定也可能会改变。目前,只有AVR、SPU、M32C、RL78和x86目标支持通用地址空间以外的地址空间。</target>
        </trans-unit>
        <trans-unit id="adca7822f575134857a5ee57f78ae4fe66d4c44f" translate="yes" xml:space="preserve">
          <source>As an optimization, G++ sometimes gives array compound literals longer lifetimes: when the array either appears outside a function or has a &lt;code&gt;const&lt;/code&gt;-qualified type. If &lt;code&gt;foo&lt;/code&gt; and its initializer had elements of type &lt;code&gt;char *const&lt;/code&gt; rather than &lt;code&gt;char *&lt;/code&gt;, or if &lt;code&gt;foo&lt;/code&gt; were a global variable, the array would have static storage duration. But it is probably safest just to avoid the use of array compound literals in C++ code.</source>
          <target state="translated">作为一种优化，G ++有时使数组复合文字的寿命更长：当数组出现在函数外部或具有 &lt;code&gt;const&lt;/code&gt; 限定类型时。如果 &lt;code&gt;foo&lt;/code&gt; 及其初始值设定项的元素类型为 &lt;code&gt;char *const&lt;/code&gt; 而不是 &lt;code&gt;char *&lt;/code&gt; ，或者如果 &lt;code&gt;foo&lt;/code&gt; 是全局变量，则数组将具有静态存储持续时间。但是，仅避免在C ++代码中使用数组复合文字可能是最安全的。</target>
        </trans-unit>
        <trans-unit id="4440512ea926e0e3e9623211be65c0fe001b769e" translate="yes" xml:space="preserve">
          <source>As another example,</source>
          <target state="translated">再举个例子:</target>
        </trans-unit>
        <trans-unit id="c2d7d2d398b725a8ff7f6339f33b58fb71e37c73" translate="yes" xml:space="preserve">
          <source>As another example, the following call to &lt;code&gt;strncpy&lt;/code&gt; results in copying to &lt;code&gt;d&lt;/code&gt; just the characters preceding the terminating NUL, without appending the NUL to the end. Assuming the result of &lt;code&gt;strncpy&lt;/code&gt; is necessarily a NUL-terminated string is a common mistake, and so the call is diagnosed. To avoid the warning when the result is not expected to be NUL-terminated, call &lt;code&gt;memcpy&lt;/code&gt; instead.</source>
          <target state="translated">作为另一个示例，对 &lt;code&gt;strncpy&lt;/code&gt; 的以下调用导致仅将终止NUL之前的字符复制到 &lt;code&gt;d&lt;/code&gt; ，而没有将NUL附加到末尾。假定 &lt;code&gt;strncpy&lt;/code&gt; 的结果必然是NUL终止的字符串是一个常见错误，因此可以对调用进行诊断。为了避免在预期结果不会被NUL终止时发出警告，请改为调用 &lt;code&gt;memcpy&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f22e08722bb8e7ce646a0894d86b714e1a18ddc2" translate="yes" xml:space="preserve">
          <source>As bit-fields are not individually addressable, volatile bit-fields may be implicitly read when written to, or when adjacent bit-fields are accessed. Bit-field operations may be optimized such that adjacent bit-fields are only partially accessed, if they straddle a storage unit boundary. For these reasons it is unwise to use volatile bit-fields to access hardware.</source>
          <target state="translated">由于位字段不是单独可寻址的,所以当写入或访问相邻位字段时,易失性位字段可能被隐式读取。比特字段的操作可能会被优化,如果相邻的比特字段跨越了存储单元的边界,那么它们只能被部分访问。由于这些原因,使用易失性位场来访问硬件是不明智的。</target>
        </trans-unit>
        <trans-unit id="54cb09a605966e1ec9e0e0780e8355b83cacd9f7" translate="yes" xml:space="preserve">
          <source>As discussed in &lt;a href=&quot;common-function-attributes#Common-Function-Attributes&quot;&gt;Common Function Attributes&lt;/a&gt;, this attribute allows specification of target-specific compilation options.</source>
          <target state="translated">如&amp;ldquo; &lt;a href=&quot;common-function-attributes#Common-Function-Attributes&quot;&gt;公共功能属性&amp;rdquo;中所述&lt;/a&gt;，此属性允许指定特定于目标的编译选项。</target>
        </trans-unit>
        <trans-unit id="c47f4f2d2c816a9b7574ec5c08de30912daa2a80" translate="yes" xml:space="preserve">
          <source>As for &amp;lsquo;</source>
          <target state="translated">至于&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="71478357402c28a54c8c6fca58d451aad7e53ab5" translate="yes" xml:space="preserve">
          <source>As in standard C++ and ISO C99, the elements of an aggregate initializer for an automatic variable are not required to be constant expressions in GNU C. Here is an example of an initializer with run-time varying elements:</source>
          <target state="translated">如同在标准C++和ISO C99中一样,在GNU C中,一个自动变量的聚合初始化器的元素不需要是常量表达式,下面是一个运行时元素变化的初始化器的例子。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
