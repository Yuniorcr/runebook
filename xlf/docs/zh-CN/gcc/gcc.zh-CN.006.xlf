<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="gcc">
    <body>
      <group id="gcc">
        <trans-unit id="5e37ec7562e7c67e3ef533934ac18db7a4d66259" translate="yes" xml:space="preserve">
          <source>A signed 16 bit immediate for &lt;code&gt;stop&lt;/code&gt;.</source>
          <target state="translated">立即签名的16位 &lt;code&gt;stop&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5d1f2bec644b602c55ff93653291917c0bee1cb5" translate="yes" xml:space="preserve">
          <source>A signed 16-bit constant (for arithmetic instructions).</source>
          <target state="translated">一个有符号的16位常数(用于算术指令)。</target>
        </trans-unit>
        <trans-unit id="6e07498a95ff964b95b70f9332548c0e101c48af" translate="yes" xml:space="preserve">
          <source>A signed 32-bit constant in which the lower 16 bits are zero. Such constants can be loaded using &lt;code&gt;lui&lt;/code&gt;.</source>
          <target state="translated">有符号的32位常量，其中低16位为零。可以使用 &lt;code&gt;lui&lt;/code&gt; 加载此类常量。</target>
        </trans-unit>
        <trans-unit id="3a13d86f9687e787e9b67a4048c3e6f6a0a655af" translate="yes" xml:space="preserve">
          <source>A single register. If &lt;var&gt;n&lt;/var&gt; is in the range 0 to 7, the corresponding D register. If it is &lt;code&gt;A&lt;/code&gt;, then the register P0.</source>
          <target state="translated">一个寄存器。如果 &lt;var&gt;n&lt;/var&gt; 在0到7的范围内，则对应的D寄存器。如果它是 &lt;code&gt;A&lt;/code&gt; ，则寄存器P0。</target>
        </trans-unit>
        <trans-unit id="862eefd77275509cc300d2e8b64b0bd59d6e0627" translate="yes" xml:space="preserve">
          <source>A specification has the syntax [&amp;lsquo;</source>
          <target state="translated">规范的语法为['</target>
        </trans-unit>
        <trans-unit id="8b75792a16ebbcbf75343206f45b552f9ca68dac" translate="yes" xml:space="preserve">
          <source>A status register (&lt;code&gt;rmsr&lt;/code&gt;, &lt;code&gt;$fcc1&lt;/code&gt; to &lt;code&gt;$fcc7&lt;/code&gt;).</source>
          <target state="translated">状态寄存器（ &lt;code&gt;rmsr&lt;/code&gt; ， &lt;code&gt;$fcc1&lt;/code&gt; 至 &lt;code&gt;$fcc7&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="8617da8fc23fdb13a32d7e55b2af3a58c983bdf6" translate="yes" xml:space="preserve">
          <source>A string constant specifying constraints on the placement of the operand; See &lt;a href=&quot;constraints#Constraints&quot;&gt;Constraints&lt;/a&gt;, for details.</source>
          <target state="translated">一个字符串常量，它指定对操作数的放置的限制；有关详细信息，请参见&lt;a href=&quot;constraints#Constraints&quot;&gt;约束&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4bed63450bff092e0c3ca584fb2ddae5e2d82e2a" translate="yes" xml:space="preserve">
          <source>A structure containing a flexible array member, or a union containing such a structure (possibly recursively), may not be a member of a structure or an element of an array. (However, these uses are permitted by GCC as extensions.)</source>
          <target state="translated">一个包含灵活数组成员的结构,或包含这样一个结构的联合体(可能是递归的),不能成为结构的成员或数组的元素。然而,这些用途作为扩展是被GCC所允许的)。</target>
        </trans-unit>
        <trans-unit id="13f3f44cecb7edd4bea911bfc4063d4f75195a8c" translate="yes" xml:space="preserve">
          <source>A symbol in the text segment of the current file</source>
          <target state="translated">当前文件文本段中的一个符号。</target>
        </trans-unit>
        <trans-unit id="55a9278d05f000d4c7a06aca9fe905b8fb5008bb" translate="yes" xml:space="preserve">
          <source>A symbol reference.</source>
          <target state="translated">一个符号参考。</target>
        </trans-unit>
        <trans-unit id="ceac75b89def52cbcbd311ef92b55a54ff3eba6e" translate="yes" xml:space="preserve">
          <source>A symbolic operand, or a 16-bit fragment of a got, tls, or pc-relative reference.</source>
          <target state="translated">一个符号操作数,或一个16位的got、tls或pc-relative引用的片段。</target>
        </trans-unit>
        <trans-unit id="bb721a7785396c7acd1586d0fc279449394dcfd8" translate="yes" xml:space="preserve">
          <source>A template with a non-type template parameter of reference type was mangled incorrectly:</source>
          <target state="translated">引用类型的非类型模板参数的模板被错误地混入。</target>
        </trans-unit>
        <trans-unit id="2953b18cce576e52d1d65cb76238b4c46802eda8" translate="yes" xml:space="preserve">
          <source>A threshold on the average loop count considered by the swing modulo scheduler.</source>
          <target state="translated">摆动模数调度器考虑的平均循环次数的阈值。</target>
        </trans-unit>
        <trans-unit id="7b4948261ad39b1701b8001a691f2c0f51ef54c3" translate="yes" xml:space="preserve">
          <source>A trampoline is a small piece of code that is created at run time on the stack when the address of a nested function is taken, and is used to call the nested function indirectly. Therefore, it requires the stack to be made executable in order for the program to work properly.</source>
          <target state="translated">蹦床是运行时在栈上取嵌套函数地址时产生的一小段代码,用于间接调用嵌套函数。因此,它需要使堆栈可以执行,程序才能正常运行。</target>
        </trans-unit>
        <trans-unit id="78cd7e495c30fc4bf5a59f6f14ffc8c61dbbd59b" translate="yes" xml:space="preserve">
          <source>A true dependence from store to load is costly.</source>
          <target state="translated">从门店到负载,真正的依赖是需要成本的。</target>
        </trans-unit>
        <trans-unit id="5307fd85f09fc936e5444911a1b34c9fbd27e507" translate="yes" xml:space="preserve">
          <source>A typical use of this option is building a kernel that does not use, and hence need not save and restore, any floating-point registers.</source>
          <target state="translated">这个选项的典型用途是构建一个不使用浮点寄存器的内核,因此不需要保存和还原任何浮点寄存器。</target>
        </trans-unit>
        <trans-unit id="7040b335818f1c7fc002704e20a47588f7532dc4" translate="yes" xml:space="preserve">
          <source>A valid &lt;code&gt;NULL&lt;/code&gt; in this context is defined as zero with any object pointer type. If your system defines the &lt;code&gt;NULL&lt;/code&gt; macro with an integer type then you need to add an explicit cast. During installation GCC replaces the system &lt;code&gt;&amp;lt;stddef.h&amp;gt;&lt;/code&gt; header with a copy that redefines NULL appropriately.</source>
          <target state="translated">在任何情况下，任何对象指针类型都将有效 &lt;code&gt;NULL&lt;/code&gt; 定义为零。如果您的系统使用整数类型定义 &lt;code&gt;NULL&lt;/code&gt; 宏，则需要添加显式强制转换。在安装过程中，GCC将系统 &lt;code&gt;&amp;lt;stddef.h&amp;gt;&lt;/code&gt; 标头替换为适当重新定义NULL的副本。</target>
        </trans-unit>
        <trans-unit id="02bba8846c50f28733626cee0f5e6cd6eae5f547" translate="yes" xml:space="preserve">
          <source>A value for this option must be provided; possible values are</source>
          <target state="translated">必须为该选项提供一个值;可能的值是</target>
        </trans-unit>
        <trans-unit id="28bdc15a4774baf30748fb10f9a39ee9576d0acc" translate="yes" xml:space="preserve">
          <source>A value of -1 means we don&amp;rsquo;t have a threshold and therefore prefetch hints can be issued for any constant stride.</source>
          <target state="translated">值为-1表示我们没有阈值，因此可以为任何恒定步幅发出预取提示。</target>
        </trans-unit>
        <trans-unit id="77182ee8e74fbc85f274ec34ad0d067f9159c03c" translate="yes" xml:space="preserve">
          <source>A vector constant</source>
          <target state="translated">一个向量常数</target>
        </trans-unit>
        <trans-unit id="25a5a3c85e4d61bb20e699b708ea293eab97d102" translate="yes" xml:space="preserve">
          <source>A vector constant is a list of constant expressions within curly braces.</source>
          <target state="translated">向量常量是大括号内的常量表达式列表。</target>
        </trans-unit>
        <trans-unit id="4903fd385e6b83744a3f7241ee469fe297e3d890" translate="yes" xml:space="preserve">
          <source>A vector initializer requires no cast if the vector constant is of the same type as the variable it is initializing.</source>
          <target state="translated">如果向量常量与初始化的变量类型相同,那么向量初始化器就不需要投掷。</target>
        </trans-unit>
        <trans-unit id="6ce3f2c4c36ebf953052d74dd8cf41bfa72eda5d" translate="yes" xml:space="preserve">
          <source>A weak reference is an alias that does not by itself require a definition to be given for the target symbol. If the target symbol is only referenced through weak references, then it becomes a &lt;code&gt;weak&lt;/code&gt; undefined symbol. If it is directly referenced, however, then such strong references prevail, and a definition is required for the symbol, not necessarily in the same translation unit.</source>
          <target state="translated">弱引用是一种别名，它本身不需要为目标符号给出定义。如果仅通过弱引用来引用目标符号，则它将变为 &lt;code&gt;weak&lt;/code&gt; 未定义符号。但是，如果直接引用，则以此类引用为准，并且需要对符号进行定义，而不必在同一翻译单元中进行定义。</target>
        </trans-unit>
        <trans-unit id="d83fa522cc15ecf666a6fc12658b5e4cd5fdc010" translate="yes" xml:space="preserve">
          <source>AArch64 family&amp;mdash;</source>
          <target state="translated">AArch64系列&amp;mdash;</target>
        </trans-unit>
        <trans-unit id="4957a12f9c33bdb7711f6bad443bcf1b59bf30ce" translate="yes" xml:space="preserve">
          <source>ABI conformance</source>
          <target state="translated">ABI一致性</target>
        </trans-unit>
        <trans-unit id="b14e4cc3f9a03a17ac3f6123a6226b7b7d34c952" translate="yes" xml:space="preserve">
          <source>ADDENDUM: How to use this License for your documents</source>
          <target state="translated">附加说明:如何在您的文件中使用本许可证</target>
        </trans-unit>
        <trans-unit id="1f0161097b4d6be2ad809b71f0ab06f4ccc56e03" translate="yes" xml:space="preserve">
          <source>AES instructions.</source>
          <target state="translated">AES指令。</target>
        </trans-unit>
        <trans-unit id="bd84aa567f4fd80f10ee4bdc1fff46ff3f84291a" translate="yes" xml:space="preserve">
          <source>AIX TOC entry</source>
          <target state="translated">AIX TOC条目</target>
        </trans-unit>
        <trans-unit id="00c79d98f4ab13b1e68350376a159f81803c3f05" translate="yes" xml:space="preserve">
          <source>AIX on the RS/6000 provides support (NLS) for environments outside of the United States. Compilers and assemblers use NLS to support locale-specific representations of various objects including floating-point numbers (&amp;lsquo;</source>
          <target state="translated">RS / 6000上的AIX为美国以外的环境提供支持（NLS）。编译器和汇编器使用NLS支持各种对象的特定于语言环境的表示形式，包括浮点数（'</target>
        </trans-unit>
        <trans-unit id="6b42874e3cd20771d93096ec5ce36307a1f2ba14" translate="yes" xml:space="preserve">
          <source>ALL</source>
          <target state="translated">ALL</target>
        </trans-unit>
        <trans-unit id="e38876cb454c616d20b014174318cd23549c31b5" translate="yes" xml:space="preserve">
          <source>AM33</source>
          <target state="translated">AM33</target>
        </trans-unit>
        <trans-unit id="b0f3c857fc3329c9a7706ca2852892a64907ff92" translate="yes" xml:space="preserve">
          <source>AMD Athlon CPU with MMX, 3dNOW!, enhanced 3DNow! and SSE prefetch instructions support.</source>
          <target state="translated">AMD Athlon CPU,支持MMX、3dNOW!、增强型3DNow!和SSE预取指令。</target>
        </trans-unit>
        <trans-unit id="9782812fedc19dae1f691ec0b75b46ce928e9504" translate="yes" xml:space="preserve">
          <source>AMD CPU.</source>
          <target state="translated">AMD的CPU。</target>
        </trans-unit>
        <trans-unit id="4b7804a001f508699c3a5d535226c1c43f89e201" translate="yes" xml:space="preserve">
          <source>AMD Family 10h Barcelona CPU.</source>
          <target state="translated">AMD家族10h巴塞罗那CPU。</target>
        </trans-unit>
        <trans-unit id="f2f426233bd9b4aec7ad7f0935ada0d98f23dc6d" translate="yes" xml:space="preserve">
          <source>AMD Family 10h CPU.</source>
          <target state="translated">AMD家族10h CPU。</target>
        </trans-unit>
        <trans-unit id="a221df99534b6cfd9cc25151f5b88b631e6b6c74" translate="yes" xml:space="preserve">
          <source>AMD Family 10h Istanbul CPU.</source>
          <target state="translated">AMD家族10h伊斯坦布尔CPU。</target>
        </trans-unit>
        <trans-unit id="3c8a317ded567872f2b86eb3a9b2b3142383086c" translate="yes" xml:space="preserve">
          <source>AMD Family 10h Shanghai CPU.</source>
          <target state="translated">AMD家族10h上海CPU。</target>
        </trans-unit>
        <trans-unit id="3a481ec8025706c39f85bf8a74294ffb3a885a4c" translate="yes" xml:space="preserve">
          <source>AMD Family 14h CPU.</source>
          <target state="translated">AMD家族14h CPU。</target>
        </trans-unit>
        <trans-unit id="d69f21954e9736613dfdcb1541757a89581cb747" translate="yes" xml:space="preserve">
          <source>AMD Family 15h Bulldozer version 1.</source>
          <target state="translated">AMD家族15h推土机版本1。</target>
        </trans-unit>
        <trans-unit id="41ba99ffd8cd8d92353e0abf0591f609003e91a0" translate="yes" xml:space="preserve">
          <source>AMD Family 15h Bulldozer version 2.</source>
          <target state="translated">AMD家族15h推土机2版。</target>
        </trans-unit>
        <trans-unit id="c106e6d754b124070881cb0e9b5ffaec83f58ff6" translate="yes" xml:space="preserve">
          <source>AMD Family 15h Bulldozer version 3.</source>
          <target state="translated">AMD家族15h推土机3版。</target>
        </trans-unit>
        <trans-unit id="162b040bafc7dbe0fec77eb2f6b3a8372fec8cf0" translate="yes" xml:space="preserve">
          <source>AMD Family 15h Bulldozer version 4.</source>
          <target state="translated">AMD家族15h推土机4版。</target>
        </trans-unit>
        <trans-unit id="8b550c62094801a9eaabc1a10c1588d01074f61b" translate="yes" xml:space="preserve">
          <source>AMD Family 15h CPU.</source>
          <target state="translated">AMD家族15h CPU。</target>
        </trans-unit>
        <trans-unit id="3dc29f9ebb58544eff2350911f186ade2077e9e7" translate="yes" xml:space="preserve">
          <source>AMD Family 15h core based CPUs with x86-64 instruction set support. (This supersets BMI, BMI2, TBM, F16C, FMA, FMA4, FSGSBASE, AVX, AVX2, XOP, LWP, AES, PCL_MUL, CX16, MOVBE, MMX, SSE, SSE2, SSE3, SSE4A, SSSE3, SSE4.1, SSE4.2, ABM and 64-bit instruction set extensions.</source>
          <target state="translated">支持x86-64指令集的基于AMD家族15h内核的CPU。(这超越了BMI、BMI2、TBM、F16C、FMA、FMA4、FSGSBASE、AVX、AVX2、XOP、LWP、AES、PCL_MUL、CX16、MOVBE、MMX、SSE、SSE2、SSE3、SSE4A、SSSE3、SSE4.1、SSE4.2、ABM和64位指令集扩展。</target>
        </trans-unit>
        <trans-unit id="a0473fd00ce817690842cab967b3016ac67c8acc" translate="yes" xml:space="preserve">
          <source>AMD Family 15h core based CPUs with x86-64 instruction set support. (This supersets BMI, TBM, F16C, FMA, FMA4, AVX, XOP, LWP, AES, PCL_MUL, CX16, MMX, SSE, SSE2, SSE3, SSE4A, SSSE3, SSE4.1, SSE4.2, ABM and 64-bit instruction set extensions.)</source>
          <target state="translated">支持x86-64指令集的基于15h内核的AMD家族CPU。(这超越了BMI、TBM、F16C、FMA、FMA4、AVX、XOP、LWP、AES、PCL_MUL、CX16、MMX、SSE、SSE2、SSE3、SSE4A、SSSE3、SSE4.1、SSE4.2、ABM和64位指令集扩展。)</target>
        </trans-unit>
        <trans-unit id="4f30ce336c72904fed1286b4744fb02d22539e6b" translate="yes" xml:space="preserve">
          <source>AMD Family 15h core based CPUs with x86-64 instruction set support. (This supersets BMI, TBM, F16C, FMA, FMA4, FSGSBASE, AVX, XOP, LWP, AES, PCL_MUL, CX16, MMX, SSE, SSE2, SSE3, SSE4A, SSSE3, SSE4.1, SSE4.2, ABM and 64-bit instruction set extensions.</source>
          <target state="translated">支持x86-64指令集的基于15h内核的AMD家族CPU。(这超越了BMI、TBM、F16C、FMA、FMA4、FSGSBASE、AVX、XOP、LWP、AES、PCL_MUL、CX16、MMX、SSE、SSE2、SSE3、SSE4A、SSE3、SSE4.1、SSE4.2、ABM和64位指令集扩展。</target>
        </trans-unit>
        <trans-unit id="d1222a05e9ab4d223a98fe2b005e9a8fe6f149c1" translate="yes" xml:space="preserve">
          <source>AMD Family 16h CPU.</source>
          <target state="translated">AMD家族16h CPU。</target>
        </trans-unit>
        <trans-unit id="275cd046e8c73f55e5a1e1661fd4caf48dfc118a" translate="yes" xml:space="preserve">
          <source>AMD Family 17h CPU.</source>
          <target state="translated">AMD家族17h CPU。</target>
        </trans-unit>
        <trans-unit id="8605196ce8298328039162c5b2196f5f20eefce6" translate="yes" xml:space="preserve">
          <source>AMD Family 17h Zen version 1.</source>
          <target state="translated">AMD家族17h Zen版本1.</target>
        </trans-unit>
        <trans-unit id="7ac5c90de82cdae73bde8fdf83f5571edc22b502" translate="yes" xml:space="preserve">
          <source>AMD Family 17h Zen version 2.</source>
          <target state="translated">AMD家族17h Zen版本2.</target>
        </trans-unit>
        <trans-unit id="87a04068ae7b738101f64aab71cef3ecd2846768" translate="yes" xml:space="preserve">
          <source>AMD Family 17h core based CPUs with x86-64 instruction set support. (This supersets BMI, BMI2, ,CLWB, F16C, FMA, FSGSBASE, AVX, AVX2, ADCX, RDSEED, MWAITX, SHA, CLZERO, AES, PCL_MUL, CX16, MOVBE, MMX, SSE, SSE2, SSE3, SSE4A, SSSE3, SSE4.1, SSE4.2, ABM, XSAVEC, XSAVES, CLFLUSHOPT, POPCNT, and 64-bit instruction set extensions.)</source>
          <target state="translated">支持x86-64指令集的基于AMD家族17h核的CPU。(该指令集超前于BMI、BMI2、 ,CLWB、F16C、FMA、FSGSBASE、AVX、AVX2、ADCX、RDSEED、MWAITX、SHA、CLZERO、AES、PCL_MUL、CX16、MOVBE、MMX、SSE、SSE2、SSE3、SSE4A、SSSE3、SSE4.1、SSE4.2、ABM、XSAVEC、XSAVES、CLFLUSHOPT、POPCNT和64位指令。 1、SSE4.2、ABM、XSAVEC、XSAVES、CLFLUSHOPT、POPCNT和64位指令集扩展)。)</target>
        </trans-unit>
        <trans-unit id="2ae2f9839ab0c946ebf780350ccb8eeef28b2d89" translate="yes" xml:space="preserve">
          <source>AMD Family 17h core based CPUs with x86-64 instruction set support. (This supersets BMI, BMI2, F16C, FMA, FSGSBASE, AVX, AVX2, ADCX, RDSEED, MWAITX, SHA, CLZERO, AES, PCL_MUL, CX16, MOVBE, MMX, SSE, SSE2, SSE3, SSE4A, SSSE3, SSE4.1, SSE4.2, ABM, XSAVEC, XSAVES, CLFLUSHOPT, POPCNT, and 64-bit instruction set extensions.</source>
          <target state="translated">基于AMD家族17h核的CPU,支持x86-64指令集。(该指令集超越了BMI、BMI2、F16C、FMA、FSGSBASE、AVX、AVX2、ADCX、RDSEED、MWAITX、SHA、CLZERO、AES、PCL_MUL、CX16、MOVBE、MMX、SSE、SSE2、SSE3、SS4A、SSSE3、SSE4.1、SSE4.2、ABM、XSAVEC、XSAVES、CLFLUSHOPT、POPCNT以及64位指令集扩展。</target>
        </trans-unit>
        <trans-unit id="eb46d89908f8744c91b1c4f45dca8a1acd1ccb27" translate="yes" xml:space="preserve">
          <source>AMD GCN &amp;mdash;</source>
          <target state="translated">AMD GCN &amp;mdash;</target>
        </trans-unit>
        <trans-unit id="db735b251e571e72d1b413e2700f9028689a9a1f" translate="yes" xml:space="preserve">
          <source>AMD Geode embedded processor with MMX and 3DNow! instruction set support.</source>
          <target state="translated">AMD Geode嵌入式处理器,支持MMX和3DNow!指令集。</target>
        </trans-unit>
        <trans-unit id="3c8e48e665e983d9bc0d85fc904dca86423a0640" translate="yes" xml:space="preserve">
          <source>AMD K6 CPU with MMX instruction set support.</source>
          <target state="translated">AMD K6 CPU,支持MMX指令集。</target>
        </trans-unit>
        <trans-unit id="113a97cdab92673636cc95858168822f55ed3094" translate="yes" xml:space="preserve">
          <source>ANY</source>
          <target state="translated">ANY</target>
        </trans-unit>
        <trans-unit id="c23fd1159b1de92b9f559df33e41326ca8f7ed85" translate="yes" xml:space="preserve">
          <source>ARC &amp;mdash;</source>
          <target state="translated">ARC &amp;mdash;</target>
        </trans-unit>
        <trans-unit id="e3246acd95d4fb7aa3011b3fb00ffb954a2152c1" translate="yes" xml:space="preserve">
          <source>ARC FPX (dpfp) 64-bit registers. &lt;code&gt;D0&lt;/code&gt;, &lt;code&gt;D1&lt;/code&gt;.</source>
          <target state="translated">ARC FPX（dpfp）64位寄存器。 &lt;code&gt;D0&lt;/code&gt; ， &lt;code&gt;D1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2ccf1f7f060d37f54120246cfa7dc75a263926f6" translate="yes" xml:space="preserve">
          <source>ARC HS SIMD support.</source>
          <target state="translated">支持ARC HS SIMD。</target>
        </trans-unit>
        <trans-unit id="932a7f099a143287c2dab636f78bab3d7a1ac45d" translate="yes" xml:space="preserve">
          <source>ARC600</source>
          <target state="translated">ARC600</target>
        </trans-unit>
        <trans-unit id="4e11187f8fc082bb81a4560953a7d52297f319ca" translate="yes" xml:space="preserve">
          <source>ARC601</source>
          <target state="translated">ARC601</target>
        </trans-unit>
        <trans-unit id="db9b6f8ec7c62bb078c4ccd2086414ec10283d1a" translate="yes" xml:space="preserve">
          <source>ARC700</source>
          <target state="translated">ARC700</target>
        </trans-unit>
        <trans-unit id="69f32b824b4367437b84027bd88885eef21e2693" translate="yes" xml:space="preserve">
          <source>ARC700-xmac</source>
          <target state="translated">ARC700-xmac</target>
        </trans-unit>
        <trans-unit id="f05a45c9726afd143f3f3902e0d21ab2ae48650f" translate="yes" xml:space="preserve">
          <source>ARC725D</source>
          <target state="translated">ARC725D</target>
        </trans-unit>
        <trans-unit id="c4f837ba2f5ad05063a4e03989e3391dddb8bc79" translate="yes" xml:space="preserve">
          <source>ARC750D</source>
          <target state="translated">ARC750D</target>
        </trans-unit>
        <trans-unit id="888c2ab0ae2033359c10fd5cfdf58bbe2d0a940c" translate="yes" xml:space="preserve">
          <source>ARM family&amp;mdash;</source>
          <target state="translated">ARM系列&amp;mdash;</target>
        </trans-unit>
        <trans-unit id="8a9b87087c41304359e59fe26411a54c3b656947" translate="yes" xml:space="preserve">
          <source>ARM targets support two incompatible representations for half-precision floating-point values. You must choose one of the representations and use it consistently in your program.</source>
          <target state="translated">ARM 目标机支持两种不兼容的半精度浮点值表示法。您必须选择其中一种表示法,并在程序中一致使用。</target>
        </trans-unit>
        <trans-unit id="c7649225dad7c2a0e06a3df7785837ccbdcddf7e" translate="yes" xml:space="preserve">
          <source>AVR family&amp;mdash;</source>
          <target state="translated">AVR系列</target>
        </trans-unit>
        <trans-unit id="b6ce34d1fb413b0acbfa365b9e4b9f6fd56b845e" translate="yes" xml:space="preserve">
          <source>AVX instructions.</source>
          <target state="translated">AVX指令。</target>
        </trans-unit>
        <trans-unit id="5360c6483b9a9e1df7abdcb4de1b9b5a31a7db4c" translate="yes" xml:space="preserve">
          <source>AVX2 instructions.</source>
          <target state="translated">AVX2指令。</target>
        </trans-unit>
        <trans-unit id="1d10807c0ae95d634b933c4c91561b625fdd7ee8" translate="yes" xml:space="preserve">
          <source>AVX5124FMAPS instructions.</source>
          <target state="translated">AVX5124FMAPS说明书。</target>
        </trans-unit>
        <trans-unit id="2877f163ba5f992658ca47acc8b1854f3fe91f8e" translate="yes" xml:space="preserve">
          <source>AVX5124VNNIW instructions.</source>
          <target state="translated">AVX5124VNNIW说明书。</target>
        </trans-unit>
        <trans-unit id="6aaaf18e4ab544cbae42a58b9cf1cac769995f49" translate="yes" xml:space="preserve">
          <source>AVX512BITALG instructions.</source>
          <target state="translated">AVX512BITALG指令。</target>
        </trans-unit>
        <trans-unit id="e6c802e92787ca04a74935e0b7ab771a52b734eb" translate="yes" xml:space="preserve">
          <source>AVX512BW instructions.</source>
          <target state="translated">AVX512BW说明书。</target>
        </trans-unit>
        <trans-unit id="ed3621c799203e17dc8a8e2affcd32cfee406953" translate="yes" xml:space="preserve">
          <source>AVX512CD instructions.</source>
          <target state="translated">AVX512CD说明书。</target>
        </trans-unit>
        <trans-unit id="734e989680da5e12fff96a9678b5efdb7f080ad8" translate="yes" xml:space="preserve">
          <source>AVX512DQ instructions.</source>
          <target state="translated">AVX512DQ说明书。</target>
        </trans-unit>
        <trans-unit id="ab4d6a088fb02d341f438d1a8b690b1d06bd6a6f" translate="yes" xml:space="preserve">
          <source>AVX512ER instructions.</source>
          <target state="translated">AVX512ER说明书。</target>
        </trans-unit>
        <trans-unit id="9e79b06b712a8ed9dc7a5818dbaa8055049287e6" translate="yes" xml:space="preserve">
          <source>AVX512F instructions.</source>
          <target state="translated">AVX512F说明书。</target>
        </trans-unit>
        <trans-unit id="a774d2186ac710be1f1d2b1823b920ecc713d1ba" translate="yes" xml:space="preserve">
          <source>AVX512IFMA instructions.</source>
          <target state="translated">AVX512IFMA说明书。</target>
        </trans-unit>
        <trans-unit id="a01464cdaa2c7a778b9758cae6be675e4fe0b633" translate="yes" xml:space="preserve">
          <source>AVX512PF instructions.</source>
          <target state="translated">AVX512PF说明书。</target>
        </trans-unit>
        <trans-unit id="90f8339b23ce90729e637c7a3a364d024582dd8c" translate="yes" xml:space="preserve">
          <source>AVX512VBMI instructions.</source>
          <target state="translated">AVX512VBMI说明书。</target>
        </trans-unit>
        <trans-unit id="60db97c4b4db27b3430715d1af3a5a33414556d6" translate="yes" xml:space="preserve">
          <source>AVX512VBMI2 instructions.</source>
          <target state="translated">AVX512VBMI2说明书。</target>
        </trans-unit>
        <trans-unit id="4be842cb121c07bbfe15b74f0e979638742b0293" translate="yes" xml:space="preserve">
          <source>AVX512VL instructions.</source>
          <target state="translated">AVX512VL说明书。</target>
        </trans-unit>
        <trans-unit id="644733f8c866e0e47cbcfa44a51986c10011d89b" translate="yes" xml:space="preserve">
          <source>AVX512VNNI instructions.</source>
          <target state="translated">AVX512VNNI说明书。</target>
        </trans-unit>
        <trans-unit id="53a0313f00ad630fa2e77fff34864e43bc34cbe7" translate="yes" xml:space="preserve">
          <source>AVX512VPOPCNTDQ instructions.</source>
          <target state="translated">AVX512VPOPCNTDQ说明书。</target>
        </trans-unit>
        <trans-unit id="94e869970cd001add8f88d68dc06d771dcf6a716" translate="yes" xml:space="preserve">
          <source>Abort the current transaction. When no transaction is active this is a no-op. The &lt;var&gt;status&lt;/var&gt; is an 8-bit constant; its value is encoded in the return value from &lt;code&gt;_xbegin&lt;/code&gt;.</source>
          <target state="translated">中止当前交易。当没有事务处于活动状态时，这是无操作的。该 &lt;var&gt;status&lt;/var&gt; 是一个8位的常数; 其值编码在 &lt;code&gt;_xbegin&lt;/code&gt; 的返回值中。</target>
        </trans-unit>
        <trans-unit id="06529d24f685cb943a5ccbec8926618c923b5a20" translate="yes" xml:space="preserve">
          <source>Absolute comparison of two paired-single values (&lt;code&gt;cabs.&lt;var&gt;cond&lt;/var&gt;.ps&lt;/code&gt;, &lt;code&gt;bc1t&lt;/code&gt;/&lt;code&gt;bc1f&lt;/code&gt;).</source>
          <target state="translated">的两个成对的单值的绝对的比较（ &lt;code&gt;cabs.&lt;var&gt;cond&lt;/var&gt;.ps&lt;/code&gt; ， &lt;code&gt;bc1t&lt;/code&gt; / &lt;code&gt;bc1f&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="df073c7d1c50e06cd4608c23a66611cf902ab538" translate="yes" xml:space="preserve">
          <source>Absolute comparison of two scalar values (&lt;code&gt;cabs.&lt;var&gt;cond&lt;/var&gt;.&lt;var&gt;fmt&lt;/var&gt;&lt;/code&gt;, &lt;code&gt;bc1t&lt;/code&gt;/&lt;code&gt;bc1f&lt;/code&gt;).</source>
          <target state="translated">两个标量值（绝对值比较 &lt;code&gt;cabs.&lt;var&gt;cond&lt;/var&gt;.&lt;var&gt;fmt&lt;/var&gt;&lt;/code&gt; ， &lt;code&gt;bc1t&lt;/code&gt; / &lt;code&gt;bc1f&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="f722ac4229dd26c3b68dd80d6e1f64e995895dbe" translate="yes" xml:space="preserve">
          <source>Absolute value (&lt;code&gt;abs.ps&lt;/code&gt;).</source>
          <target state="translated">绝对值（ &lt;code&gt;abs.ps&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="4daf0f1c1f813e9102db1a5994f1b9e8323b97c9" translate="yes" xml:space="preserve">
          <source>Accept &amp;lsquo;</source>
          <target state="translated">接受&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="1b2da276a5f9c648bf9aca0b0668639225e93b2f" translate="yes" xml:space="preserve">
          <source>Accept imaginary, fixed-point, or machine-defined literal number suffixes as GNU extensions. When this option is turned off these suffixes are treated as C++11 user-defined literal numeric suffixes. This is on by default for all pre-C++11 dialects and all GNU dialects:</source>
          <target state="translated">接受虚数、定点或机器定义的字面数字后缀作为GNU扩展。当这个选项被关闭时,这些后缀将被视为C++11用户定义的文字数字后缀。对于所有C++11之前的方言和所有GNU方言来说,这个选项是默认开启的。</target>
        </trans-unit>
        <trans-unit id="a081bde4daabce186fc90fa0db98f145d7ef25aa" translate="yes" xml:space="preserve">
          <source>Accept some non-standard constructs used in Microsoft header files.</source>
          <target state="translated">接受微软头文件中使用的一些非标准结构。</target>
        </trans-unit>
        <trans-unit id="8ce1e6741eac355bc7dded05833655b003ffbcb7" translate="yes" xml:space="preserve">
          <source>Accept some non-standard constructs used in Plan 9 code.</source>
          <target state="translated">接受计划9代码中使用的一些非标准结构。</target>
        </trans-unit>
        <trans-unit id="be39a99ef887dbe2361b7a8f01c005db47949d8d" translate="yes" xml:space="preserve">
          <source>Accept universal character names in identifiers. This option is enabled by default for C99 (and later C standard versions) and C++.</source>
          <target state="translated">在标识符中接受通用字符名。这个选项在C99(以及以后的C标准版本)和C++中是默认启用的。</target>
        </trans-unit>
        <trans-unit id="0f43c08aeb944b0a767a69ba0fb81ec15c2500b4" translate="yes" xml:space="preserve">
          <source>Accept variadic functions without named parameters.</source>
          <target state="translated">接受没有命名参数的变量函数。</target>
        </trans-unit>
        <trans-unit id="045e8c6e57a163b8d206267b0ad429f37b12bd4b" translate="yes" xml:space="preserve">
          <source>Accesses through pointers to types with this attribute are not subject to type-based alias analysis, but are instead assumed to be able to alias any other type of objects. In the context of section 6.5 paragraph 7 of the C99 standard, an lvalue expression dereferencing such a pointer is treated like having a character type. See</source>
          <target state="translated">通过指向具有这种属性的类型的指针的访问不受基于类型的别名分析的限制,而是被认为能够别名任何其他类型的对象。在C99标准第6.5节第7段的上下文中,派生这种指针的l值表达式就像具有字符类型一样。参见</target>
        </trans-unit>
        <trans-unit id="0e0bf5b2a877ef7b91241baabde260a26b7a132e" translate="yes" xml:space="preserve">
          <source>Accesses to bit-fields even in volatile objects works by accessing larger objects, such as a byte or a word. You cannot rely on what size of object is accessed in order to read or write the bit-field; it may even vary for a given bit-field according to the precise usage.</source>
          <target state="translated">即使是在易失性对象中访问位字段,也是通过访问更大的对象,如一个字节或一个字来工作的。你不能依靠访问什么大小的对象来读取或写入位字段,对于一个给定的位字段来说,它甚至可能根据精确的用途而变化。</target>
        </trans-unit>
        <trans-unit id="853e90163908be81a9a0fb1ee291ab1b4ba5a6c2" translate="yes" xml:space="preserve">
          <source>Accesses to non-volatile objects are not ordered with respect to volatile accesses. You cannot use a volatile object as a memory barrier to order a sequence of writes to non-volatile memory. For instance:</source>
          <target state="translated">对非易失性对象的访问与易失性访问相比并不排序。你不能使用易失性对象作为内存屏障来排序对非易失性内存的写入序列。比如说,你不能使用易失性对象作为内存屏障来排列对非易失性内存的写入顺序。</target>
        </trans-unit>
        <trans-unit id="c072e2c48755b5522f29c41ec4ff83f53ff94a3e" translate="yes" xml:space="preserve">
          <source>Accesses to the variable may be optimized as usual and the register remains available for allocation and use in any computations, provided that observable values of the variable are not affected.</source>
          <target state="translated">对变量的访问可以像往常一样进行优化,并且在变量的可观察值不受影响的前提下,寄存器仍然可以用于分配和使用任何计算。</target>
        </trans-unit>
        <trans-unit id="5d925b3885b30b4085b6d48f83637a9fdd674d3f" translate="yes" xml:space="preserve">
          <source>Accessing data from C programs without using input/output operands (such as by using global symbols directly from the assembler template) may not work as expected. Similarly, calling functions directly from an assembler template requires a detailed understanding of the target assembler and ABI.</source>
          <target state="translated">在不使用输入/输出操作数的情况下访问C程序中的数据(例如直接从汇编器模板中使用全局符号),可能无法达到预期的效果。同样,直接从汇编器模板中调用函数需要详细了解目标汇编器和ABI。</target>
        </trans-unit>
        <trans-unit id="aea1f643245ad21355d1a144988c7b86dcf2187a" translate="yes" xml:space="preserve">
          <source>According to the C standard, such an expression is an rvalue whose type is the unqualified version of its original type, i.e. &lt;code&gt;int&lt;/code&gt;. Whether GCC interprets this as a read of the volatile object being pointed to or only as a request to evaluate the expression for its side effects depends on this type.</source>
          <target state="translated">根据C标准，这样的表达式是一个右值，其类型是其原始类型的非限定版本，即 &lt;code&gt;int&lt;/code&gt; 。GCC是将其解释为读取指向的易失性对象还是将其解释为评估表达式的副作用的请求取决于此类型。</target>
        </trans-unit>
        <trans-unit id="35037aeb8678de2c00ed45aeca3de92268d726be" translate="yes" xml:space="preserve">
          <source>Accumulate an option for &amp;lsquo;</source>
          <target state="translated">累积&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="a3826f28e4e210d0b17ec990e0a882bb608802f9" translate="yes" xml:space="preserve">
          <source>Accumulate outgoing function arguments and acquire/release the needed stack space for outgoing function arguments once in function prologue/epilogue. Without this option, outgoing arguments are pushed before calling a function and popped afterwards.</source>
          <target state="translated">在函数序幕/序章中,积累传出的函数参数,并为传出的函数参数获取/释放所需的栈空间。如果没有这个选项,则在调用函数前推送外传参数,调用后弹出。</target>
        </trans-unit>
        <trans-unit id="dc171ad6354a6828c71d9648018df6749febe991" translate="yes" xml:space="preserve">
          <source>Accumulator register.</source>
          <target state="translated">累积器寄存器。</target>
        </trans-unit>
        <trans-unit id="554b8869b285c571ad11f29cd87ecd2c94a39e50" translate="yes" xml:space="preserve">
          <source>Ada source code file containing a library unit body (a subprogram or package body). Such files are also called &lt;em&gt;bodies&lt;/em&gt;.</source>
          <target state="translated">包含库单元主体（子程序或包主体）的Ada源代码文件。这样的文件也称为&lt;em&gt;主体&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="4b2989ddb4c2391d408222a27d0f7e97c4843dda" translate="yes" xml:space="preserve">
          <source>Ada source code file that contains a library unit declaration (a declaration of a package, subprogram, or generic, or a generic instantiation), or a library unit renaming declaration (a package, generic, or subprogram renaming declaration). Such files are also called &lt;em&gt;specs&lt;/em&gt;.</source>
          <target state="translated">包含库单元声明（包，子程序或泛型或泛型实例化的声明）或库单元重命名声明（包，泛型或子程序重命名声明）的Ada源代码文件。这样的文件也称为&lt;em&gt;规范&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="885d4a696efd6405b314fabe588d5e90299b2183" translate="yes" xml:space="preserve">
          <source>Add &amp;ldquo;thread storage duration&amp;rdquo; to the list in paragraph 1.</source>
          <target state="translated">将&amp;ldquo;线程存储持续时间&amp;rdquo;添加到第1段的列表中。</target>
        </trans-unit>
        <trans-unit id="b86ee756f777d093031a2ef7598a20edf7c225e4" translate="yes" xml:space="preserve">
          <source>Add 8 bytes to an offsettable memory reference. Useful when accessing the high 8 bytes of SSE values. For a memref in (%rax), it generates</source>
          <target state="translated">向可偏移内存引用增加8个字节。在访问SSE值的高8字节时很有用。对于(%rax)中的memref,它将生成</target>
        </trans-unit>
        <trans-unit id="4790fd26dc16d553ca9f40c8e3122f144c79668c" translate="yes" xml:space="preserve">
          <source>Add &lt;code&gt;__thread&lt;/code&gt; to the list in paragraph 1.</source>
          <target state="translated">将 &lt;code&gt;__thread&lt;/code&gt; 添加到第1段的列表中。</target>
        </trans-unit>
        <trans-unit id="a776e64e6b39926909868acf47332b1f06fea4a3" translate="yes" xml:space="preserve">
          <source>Add &lt;code&gt;__thread&lt;/code&gt; to the list of specifiers in paragraph 3.</source>
          <target state="translated">将 &lt;code&gt;__thread&lt;/code&gt; 添加到第3段的说明符列表中。</target>
        </trans-unit>
        <trans-unit id="7ae62118c00710deaec9ef5e1ca04437d3f24b0d" translate="yes" xml:space="preserve">
          <source>Add &lt;code&gt;__thread&lt;/code&gt; to the list of storage class specifiers in paragraph 1.</source>
          <target state="translated">在第1段的存储类说明符列表中添加 &lt;code&gt;__thread&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ca9035627ef94891bbb5d203d19159bca7ef3d20" translate="yes" xml:space="preserve">
          <source>Add &lt;code&gt;__thread&lt;/code&gt;.</source>
          <target state="translated">添加 &lt;code&gt;__thread&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8d24fa0d264612fefce413cb080bc55058598cb7" translate="yes" xml:space="preserve">
          <source>Add after paragraph 3</source>
          <target state="translated">在第3款后增加:</target>
        </trans-unit>
        <trans-unit id="69d6be3cf4356a47a61429765c19c67c73985946" translate="yes" xml:space="preserve">
          <source>Add after paragraph 4</source>
          <target state="translated">在第4段后增加:</target>
        </trans-unit>
        <trans-unit id="6c93420cec677cdd1b461d1d94e40f0e5ce17fec" translate="yes" xml:space="preserve">
          <source>Add after paragraph 5</source>
          <target state="translated">在第5段后增加:</target>
        </trans-unit>
        <trans-unit id="cf5cebdb7710016b6f480e1dcf7594bfb0735ab9" translate="yes" xml:space="preserve">
          <source>Add after paragraph 6</source>
          <target state="translated">在第6段后增加:</target>
        </trans-unit>
        <trans-unit id="e6ee990db3ecfcd2015326c23234c180361bb454" translate="yes" xml:space="preserve">
          <source>Add code so that program flow &lt;em&gt;arcs&lt;/em&gt; are instrumented. During execution the program records how many times each branch and call is executed and how many times it is taken or returns. On targets that support constructors with priority support, profiling properly handles constructors, destructors and C++ constructors (and destructors) of classes which are used as a type of a global variable.</source>
          <target state="translated">添加代码，以便检测程序流&lt;em&gt;弧&lt;/em&gt;。在执行期间，程序记录每个分支和调用执行了多少次，以及执行或返回了多少次。在支持具有优先级支持的构造函数的目标上，性能分析可以正确处理用作全局变量类型的类的构造函数，析构函数和C ++构造函数（和析构函数）。</target>
        </trans-unit>
        <trans-unit id="79f504a568cb02675dcb4fa7f761de4ec8eef873" translate="yes" xml:space="preserve">
          <source>Add description attributes to some DWARF DIEs that have no name attribute, such as artificial variables, external references and call site parameter DIEs.</source>
          <target state="translated">为一些没有名称属性的DWARF DIE增加描述属性,如人工变量、外部引用和调用站点参数DIE。</target>
        </trans-unit>
        <trans-unit id="71433ea39bacba1c32fb50a6079568ad524eb46d" translate="yes" xml:space="preserve">
          <source>Add directory &lt;var&gt;dir&lt;/var&gt; to the list of directories to be searched for</source>
          <target state="translated">将目录 &lt;var&gt;dir&lt;/var&gt; 添加到要搜索的目录列表中</target>
        </trans-unit>
        <trans-unit id="548bf62a1540dcbb0f428d7f5c59cbf2987dcf8a" translate="yes" xml:space="preserve">
          <source>Add new text after paragraph 1</source>
          <target state="translated">在第1款后增加新的案文</target>
        </trans-unit>
        <trans-unit id="13e160272edc000ac3b59f7e3c239601278b19a4" translate="yes" xml:space="preserve">
          <source>Add new text after paragraph 6</source>
          <target state="translated">在第6段之后增加新的案文</target>
        </trans-unit>
        <trans-unit id="b0ab0cd8ae6eaeee09a517ab6e0fab22009af14c" translate="yes" xml:space="preserve">
          <source>Add new text before paragraph 3</source>
          <target state="translated">在第3款之前增加新的案文</target>
        </trans-unit>
        <trans-unit id="09310e0a5ba6730b457158c35b8623195000a4a3" translate="yes" xml:space="preserve">
          <source>Add support for multithreading with the &lt;em&gt;dce thread&lt;/em&gt; library under HP-UX. This option sets flags for both the preprocessor and linker.</source>
          <target state="translated">使用HP-UX下的&lt;em&gt;dce线程&lt;/em&gt;库添加对多线程的支持。该选项为预处理器和链接器设置标志。</target>
        </trans-unit>
        <trans-unit id="2df2581a5423cd3eaf9365ee07a19f72370b3fc1" translate="yes" xml:space="preserve">
          <source>Add the directory &lt;var&gt;dir&lt;/var&gt; to the list of directories to be searched for header files during preprocessing. If &lt;var&gt;dir&lt;/var&gt; begins with &amp;lsquo;</source>
          <target state="translated">将目录 &lt;var&gt;dir&lt;/var&gt; 添加到要在预处理过程中搜索头文件的目录列表中。如果 &lt;var&gt;dir&lt;/var&gt; 以'</target>
        </trans-unit>
        <trans-unit id="73c333940f1537361f906bee03e2343442706250" translate="yes" xml:space="preserve">
          <source>Add the framework directory &lt;var&gt;dir&lt;/var&gt; to the head of the list of directories to be searched for header files. These directories are interleaved with those specified by</source>
          <target state="translated">将框架目录 &lt;var&gt;dir&lt;/var&gt; 添加到要搜索头文件的目录列表的开头。这些目录与由</target>
        </trans-unit>
        <trans-unit id="6e8c5a8e482b4eb45d5df440bbd4aa57581a1379" translate="yes" xml:space="preserve">
          <source>Additional Floating Types.</source>
          <target state="translated">其他浮动类型:</target>
        </trans-unit>
        <trans-unit id="fbfd7f5a311b0863e336e4d5dd611078e4f5f005" translate="yes" xml:space="preserve">
          <source>Additional block information may succeed each line, when requested by command line option. The &lt;var&gt;execution_count&lt;/var&gt; is &amp;lsquo;</source>
          <target state="translated">当命令行选项请求时，其他的块信息可能会在每行之后。该 &lt;var&gt;execution_count&lt;/var&gt; 是'</target>
        </trans-unit>
        <trans-unit id="3a265ea53c72053fec1245e548879142e841e602" translate="yes" xml:space="preserve">
          <source>Additional built-in functions are available for the 64-bit PowerPC family of processors, for efficient use of 128-bit floating point (&lt;code&gt;__float128&lt;/code&gt;) values.</source>
          <target state="translated">附加的内置功能可用于64位PowerPC系列处理器，以有效利用128位浮点（ &lt;code&gt;__float128&lt;/code&gt; ）值。</target>
        </trans-unit>
        <trans-unit id="4e400fc31f2b8160db0d8588871c49194b1a49e9" translate="yes" xml:space="preserve">
          <source>Additional floating-point exceptions, rounding modes, environments, and classifications, and their macro names (C99 and C11 7.6, C99 and C11 7.12).</source>
          <target state="translated">附加的浮点异常、四舍五入模式、环境和分类,以及它们的宏名称(C99和C11 7.6,C99和C11 7.12)。</target>
        </trans-unit>
        <trans-unit id="9b88de1196308385f5d14de9c11ffbabcd4f7f0a" translate="yes" xml:space="preserve">
          <source>Additional post-processing of the returned value may be needed, see &lt;code&gt;__builtin_extract_return_addr&lt;/code&gt;.</source>
          <target state="translated">可能需要对返回值进行其他后期处理，请参见 &lt;code&gt;__builtin_extract_return_addr&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7b6fd1bd03704b21e269c633949f84ccf5e8856f" translate="yes" xml:space="preserve">
          <source>Additional registers typically used only in prologues and epilogues: RETS, RETN, RETI, RETX, RETE, ASTAT, SEQSTAT and USP.</source>
          <target state="translated">通常只在序言和尾声中使用的附加寄存器。RETS、RETN、RETI、RETX、RETE、ASTAT、SEQSTAT和USP。</target>
        </trans-unit>
        <trans-unit id="880c2173ff65c5e972a9e4536af68b63da90141d" translate="yes" xml:space="preserve">
          <source>Additional restrictions are enforced for types with the reverse scalar storage order with regard to the scalar storage order of the target:</source>
          <target state="translated">在目标的标量存储顺序方面,对具有反向标量存储顺序的类型实施了额外的限制。</target>
        </trans-unit>
        <trans-unit id="09bc67c6276506971828d824b07903a4f5f9de7b" translate="yes" xml:space="preserve">
          <source>Additionally inlining a function compiled with</source>
          <target state="translated">另外,内联一个用</target>
        </trans-unit>
        <trans-unit id="bf8b67741ce8fd715c05645cbb36737b371211d3" translate="yes" xml:space="preserve">
          <source>Additionally on native AArch64 GNU/Linux systems the value &amp;lsquo;</source>
          <target state="translated">此外，在本机AArch64 GNU / Linux系统上，值'</target>
        </trans-unit>
        <trans-unit id="c9983bdb073bd2da3d6b02f0173dccb4761318ac" translate="yes" xml:space="preserve">
          <source>Additionally the &amp;lsquo;</source>
          <target state="translated">此外，</target>
        </trans-unit>
        <trans-unit id="c32c6fe01da4320e1de2565ba6da0578715fa9c4" translate="yes" xml:space="preserve">
          <source>Additionally, &lt;code&gt;CFStringRefs&lt;/code&gt; (defined by the &lt;code&gt;CoreFoundation&lt;/code&gt; headers) may also be used as format arguments. Note that the relevant headers are only likely to be available on Darwin (OSX) installations. On such installations, the XCode and system documentation provide descriptions of &lt;code&gt;CFString&lt;/code&gt;, &lt;code&gt;CFStringRefs&lt;/code&gt; and associated functions.</source>
          <target state="translated">此外， &lt;code&gt;CFStringRefs&lt;/code&gt; （由 &lt;code&gt;CoreFoundation&lt;/code&gt; 标头定义）也可以用作格式参数。请注意，相关的标头仅可能在达尔文（OSX）安装中可用。在此类安装中，XCode和系统文档提供了 &lt;code&gt;CFString&lt;/code&gt; ， &lt;code&gt;CFStringRefs&lt;/code&gt; 和关联函数的描述。</target>
        </trans-unit>
        <trans-unit id="06f45ee380b9da22c173cf9d9231907ee68fe13b" translate="yes" xml:space="preserve">
          <source>Additionally, some messages are logically nested within other messages, reflecting implementation details of the optimization passes.</source>
          <target state="translated">此外,一些消息在逻辑上嵌套在其他消息中,反映了优化通道的实现细节。</target>
        </trans-unit>
        <trans-unit id="0c630e5527eda313a2b833dd18abd8307a6cfdbd" translate="yes" xml:space="preserve">
          <source>Additionally, the architectural extension string may be specified on its own. This can be used to turn on and off particular architectural extensions without having to specify a particular architecture version or core. Example:</source>
          <target state="translated">此外,还可以单独指定架构扩展字符串。这可以用来开启和关闭特定的架构扩展,而不必指定特定的架构版本或核心。例如</target>
        </trans-unit>
        <trans-unit id="e68df41b1d7fdc52b01b88eeb29e9ccd6bf7ed5e" translate="yes" xml:space="preserve">
          <source>Additionally, the following architectures, which lack support for the Thumb execution state, are recognized but support is deprecated: &amp;lsquo;</source>
          <target state="translated">此外，可以识别以下缺少对Thumb执行状态的支持的体系结构，但不建议使用该体系结构：</target>
        </trans-unit>
        <trans-unit id="a870075e1e81be429acf073e584f3d7c7e76cfdf" translate="yes" xml:space="preserve">
          <source>Additionally, the options</source>
          <target state="translated">此外,选项</target>
        </trans-unit>
        <trans-unit id="62846127f56afc07ef1c01a4fc578e26bdf7e831" translate="yes" xml:space="preserve">
          <source>Additionally, this option can specify that GCC should tune the performance of the code for a big.LITTLE system. Permissible names are: &amp;lsquo;</source>
          <target state="translated">此外，此选项可以指定GCC应该为big.LITTLE系统调整代码的性能。允许的名称为：'</target>
        </trans-unit>
        <trans-unit id="c9b7ac484445343c898ee0befeb5554f44a64e88" translate="yes" xml:space="preserve">
          <source>Additionally, warn when a user-defined literal operator is declared with a literal suffix identifier that doesn&amp;rsquo;t begin with an underscore. Literal suffix identifiers that don&amp;rsquo;t begin with an underscore are reserved for future standardization.</source>
          <target state="translated">另外，当声明用户定义的文字运算符带有不以下划线开头的文字后缀标识符时，发出警告。不以下划线开头的文字后缀标识符保留给以后的标准化。</target>
        </trans-unit>
        <trans-unit id="facde292bf415fbdf09a1828e9e0908e4c617e00" translate="yes" xml:space="preserve">
          <source>Address base register</source>
          <target state="translated">地址基础寄存器</target>
        </trans-unit>
        <trans-unit id="ac7731150d1c92cf663f9e708bf71a25213854ca" translate="yes" xml:space="preserve">
          <source>Address base register if 64-bit instructions are enabled or NO_REGS.</source>
          <target state="translated">如果启用64位指令或NO_REGS,则地址基寄存器。</target>
        </trans-unit>
        <trans-unit id="e3421b8898caa7357be908d1653e3653974d758f" translate="yes" xml:space="preserve">
          <source>Address operand that is an indexed or indirect from a register (&amp;lsquo;</source>
          <target state="translated">来自寄存器的索引或间接地址操作数（'</target>
        </trans-unit>
        <trans-unit id="a7b7013cab33d0bd7c179b9b5712968750a0b395" translate="yes" xml:space="preserve">
          <source>Address operand without segment register.</source>
          <target state="translated">地址操作数没有段寄存器。</target>
        </trans-unit>
        <trans-unit id="e849277f25d3c4f30a01955b54c92b602f3ff3ef" translate="yes" xml:space="preserve">
          <source>Address register</source>
          <target state="translated">地址寄存器</target>
        </trans-unit>
        <trans-unit id="a60bc1681a9f62ef4591ab15398d5eb38a430789" translate="yes" xml:space="preserve">
          <source>Address register (general purpose register except r0)</source>
          <target state="translated">地址寄存器(除r0外的通用寄存器)</target>
        </trans-unit>
        <trans-unit id="91d4fb05cb0843e13759b8b72edb33693debf000" translate="yes" xml:space="preserve">
          <source>Address register indirect addressing mode</source>
          <target state="translated">地址寄存器间接寻址模式</target>
        </trans-unit>
        <trans-unit id="3a077484bf2c4ff84f71e4199f510082fe999bf3" translate="yes" xml:space="preserve">
          <source>Address registers</source>
          <target state="translated">地址寄存器</target>
        </trans-unit>
        <trans-unit id="5759236ebd061a0e0392b44c51e565f6ce6fcc43" translate="yes" xml:space="preserve">
          <source>Address registers when they&amp;rsquo;re 16 bits wide.</source>
          <target state="translated">地址寄存器为16位宽时。</target>
        </trans-unit>
        <trans-unit id="fdd0e10bf3a4572e30fda31a40f35542043406cf" translate="yes" xml:space="preserve">
          <source>Address registers when they&amp;rsquo;re 24 bits wide.</source>
          <target state="translated">地址寄存器为24位宽时。</target>
        </trans-unit>
        <trans-unit id="325382a51fa4bc25157b99f44454696d95890fcb" translate="yes" xml:space="preserve">
          <source>Address space identifiers may be used exactly like any other C type qualifier (e.g., &lt;code&gt;const&lt;/code&gt; or &lt;code&gt;volatile&lt;/code&gt;). See the N1275 document for more details.</source>
          <target state="translated">地址空间标识符可以像任何其他C类型限定符（例如 &lt;code&gt;const&lt;/code&gt; 或 &lt;code&gt;volatile&lt;/code&gt; ）一样使用。有关更多详细信息，请参见N1275文档。</target>
        </trans-unit>
        <trans-unit id="5f0d1ee78feebd358e9ac4716831efeab01368b7" translate="yes" xml:space="preserve">
          <source>Adjacent bit-fields are packed into the same 1-, 2-, or 4-byte allocation unit if the integral types are the same size and if the next bit-field fits into the current allocation unit without crossing the boundary imposed by the common alignment requirements of the bit-fields.</source>
          <target state="translated">如果积分类型大小相同,并且下一个位字段适合当前的分配单元,而不越过位字段的共同对齐要求所规定的边界,相邻的位字段就会被装入同一个1、2或4字节的分配单元。</target>
        </trans-unit>
        <trans-unit id="94636fe0e41073552acb8d30375f7c2b9b7fa2c2" translate="yes" xml:space="preserve">
          <source>After defining a global register variable, for the current compilation unit:</source>
          <target state="translated">在定义了一个全局寄存器变量后,对于当前的编译单元。</target>
        </trans-unit>
        <trans-unit id="a160b9211c156fcb59476123ceefb14233c30de0" translate="yes" xml:space="preserve">
          <source>After register allocation and post-register allocation instruction splitting, identify arithmetic instructions that compute processor flags similar to a comparison operation based on that arithmetic. If possible, eliminate the explicit comparison operation.</source>
          <target state="translated">在寄存器分配和寄存器分配后的指令拆分后,确定计算处理器标志的算术指令,类似于基于该算术的比较操作。如果可能的话,取消明确的比较操作。</target>
        </trans-unit>
        <trans-unit id="9cd493414e0c8a63ccc996f89446d267fe9e1e5f" translate="yes" xml:space="preserve">
          <source>After register allocation and post-register allocation instruction splitting, perform a copy-propagation pass to try to reduce scheduling dependencies and occasionally eliminate the copy.</source>
          <target state="translated">在寄存器分配和寄存器分配后的指令拆分后,进行复制传播传递,尽量减少调度依赖性,偶尔消除复制。</target>
        </trans-unit>
        <trans-unit id="a0c15aec2fc1e009f616402ab13a6a8f9c982cca" translate="yes" xml:space="preserve">
          <source>After running a program compiled with</source>
          <target state="translated">在运行一个用</target>
        </trans-unit>
        <trans-unit id="1454e9ea83225a76df4ee5fd8a44b04ac91ebb88" translate="yes" xml:space="preserve">
          <source>After the prefix, there must be one or more additional constraints (see &lt;a href=&quot;constraints#Constraints&quot;&gt;Constraints&lt;/a&gt;) that describe where the value resides. Common constraints include &amp;lsquo;</source>
          <target state="translated">在前缀之后，必须有一个或多个其他约束（请参见&lt;a href=&quot;constraints#Constraints&quot;&gt;Constraints&lt;/a&gt;）来描述该值所在的位置。常见限制包括</target>
        </trans-unit>
        <trans-unit id="87d629b413e62d8e858ca1323306d594503312be" translate="yes" xml:space="preserve">
          <source>Again, the call to &lt;code&gt;f()&lt;/code&gt; is not dependent on template arguments (there are no arguments that depend on the type &lt;code&gt;T&lt;/code&gt;, and it is also not otherwise specified that the call should be in a dependent context). Thus a global declaration of such a function must be available, since the one in the base class is not visible until instantiation time. The compiler will consequently produce the following error message:</source>
          <target state="translated">同样，对 &lt;code&gt;f()&lt;/code&gt; 的调用不依赖于模板参数（不存在依赖于类型 &lt;code&gt;T&lt;/code&gt; 的参数，并且也没有以其他方式指定该调用应位于依赖上下文中）。因此，此类函数的全局声明必须可用，因为直到实例化时间，基类中的该声明才可见。编译器将因此产生以下错误消息：</target>
        </trans-unit>
        <trans-unit id="e15a8d239570fd7618da66d01432b0ca503636ad" translate="yes" xml:space="preserve">
          <source>Aggregates with this attribute are invalid, even if they are of the same size as a corresponding scalar. For example, the declaration:</source>
          <target state="translated">具有该属性的集合是无效的,即使它们与对应的标量大小相同。例如,声明:</target>
        </trans-unit>
        <trans-unit id="9ffe001744d57fb7d843a75b3de19edfb4a4cd40" translate="yes" xml:space="preserve">
          <source>Aliases of</source>
          <target state="translated">别名</target>
        </trans-unit>
        <trans-unit id="2f7b5a2fcf03ab39f29a64817524ffd647a4fc18" translate="yes" xml:space="preserve">
          <source>Align all branch targets to a power-of-two boundary.</source>
          <target state="translated">将所有的分支目标对准二幂的边界。</target>
        </trans-unit>
        <trans-unit id="784e20f54ecda5213d66bcc1bc3f5f199a64e7ea" translate="yes" xml:space="preserve">
          <source>Align all loops to a 32-byte boundary.</source>
          <target state="translated">将所有的循环排列到一个32字节的边界。</target>
        </trans-unit>
        <trans-unit id="a2e1e4cb8c2ddc659aedc1c3a6dfffeb002bdbe7" translate="yes" xml:space="preserve">
          <source>Align branch targets to a power-of-two boundary, for branch targets where the targets can only be reached by jumping. In this case, no dummy operations need be executed.</source>
          <target state="translated">将分支目标对准二的幂级边界,对于只有通过跳跃才能到达目标的分支目标。在这种情况下,不需要执行虚操作。</target>
        </trans-unit>
        <trans-unit id="2e8345e97e639fae1caa53fafd777f32b2148811" translate="yes" xml:space="preserve">
          <source>Align doubles at 64-bit boundaries. Note that this changes the calling conventions, and thus some functions from the standard C library do not work unless you recompile it first with</source>
          <target state="translated">在64位边界对齐双数。请注意,这改变了调用约定,因此一些来自标准 C 库的函数不能使用,除非你先用</target>
        </trans-unit>
        <trans-unit id="36a2b427b91139b8587d4cbfe16eb7a63f8affad" translate="yes" xml:space="preserve">
          <source>Align loops to a power-of-two boundary. If the loops are executed many times, this makes up for any execution of the dummy padding instructions.</source>
          <target state="translated">将循环对齐到二的幂级边界。如果循环被多次执行,这将弥补任何执行的虚填充指令。</target>
        </trans-unit>
        <trans-unit id="fb4c088e2c0ec9d07a3a585878097d5ea3d18362" translate="yes" xml:space="preserve">
          <source>Align the start of functions to the next power-of-two greater than &lt;var&gt;n&lt;/var&gt;, skipping up to &lt;var&gt;m&lt;/var&gt;-1 bytes. This ensures that at least the first &lt;var&gt;m&lt;/var&gt; bytes of the function can be fetched by the CPU without crossing an &lt;var&gt;n&lt;/var&gt;-byte alignment boundary.</source>
          <target state="translated">将函数的开头与下一个大于 &lt;var&gt;n&lt;/var&gt; 的2的幂次对齐，最多跳过 &lt;var&gt;m&lt;/var&gt; -1个字节。这样确保了CPU 至少可以获取函数的前 &lt;var&gt;m&lt;/var&gt; 个字节，而不会跨越 &lt;var&gt;n&lt;/var&gt; 个字节的对齐边界。</target>
        </trans-unit>
        <trans-unit id="790e74268060e0e6ade88cfb9c482c2bc048f9d0" translate="yes" xml:space="preserve">
          <source>Align variable (&lt;code&gt;alnv.ps&lt;/code&gt;).</source>
          <target state="translated">对齐变量（ &lt;code&gt;alnv.ps&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="6a72085653e4c5be8c7640c868ef787cbcf063d1" translate="yes" xml:space="preserve">
          <source>All</source>
          <target state="translated">All</target>
        </trans-unit>
        <trans-unit id="19bd4f0f0123a61d6b94fd1f26c48a5b466015b1" translate="yes" xml:space="preserve">
          <source>All condition registers: SCC, VCCZ, EXECZ</source>
          <target state="translated">所有条件寄存器。SCC、VCCZ、EXECZ。</target>
        </trans-unit>
        <trans-unit id="0ebe806ad92438745f4bad14dde213851c8a70c2" translate="yes" xml:space="preserve">
          <source>All dependences are costly.</source>
          <target state="translated">所有的依仗都是昂贵的。</target>
        </trans-unit>
        <trans-unit id="0cca1530229b7b9e550b891f9a9b113625c13de2" translate="yes" xml:space="preserve">
          <source>All files specified by</source>
          <target state="translated">指定的所有文件</target>
        </trans-unit>
        <trans-unit id="0eaba1cfa9a00eb4bd0b12d5b7310a8e6e1fa4c5" translate="yes" xml:space="preserve">
          <source>All implicitly popped input registers must be closer to the top of the reg-stack than any input that is not implicitly popped.</source>
          <target state="translated">所有隐式弹出的输入寄存器必须比任何没有隐式弹出的输入更接近reg-stack的顶部。</target>
        </trans-unit>
        <trans-unit id="3b1c013be47e44ec0e7b3eeaa220c1f24b9203e3" translate="yes" xml:space="preserve">
          <source>All memory orders are valid.</source>
          <target state="translated">所有的内存订单都是有效的。</target>
        </trans-unit>
        <trans-unit id="71ff0e08a090942eb8e784cba6de91a4fd99fb49" translate="yes" xml:space="preserve">
          <source>All modules should be compiled with the same</source>
          <target state="translated">所有的模块都应该用相同的</target>
        </trans-unit>
        <trans-unit id="f0bcaa344128e72d0d5e1b94c3b2fa0090b0e882" translate="yes" xml:space="preserve">
          <source>All objects that have neither thread storage duration, dynamic storage duration nor are local [&amp;hellip;].</source>
          <target state="translated">所有既没有线程存储持续时间，动态存储持续时间也不是本地[&amp;hellip;]的对象。</target>
        </trans-unit>
        <trans-unit id="ec2545f5d42fce7e86616e30c2d782de4749997a" translate="yes" xml:space="preserve">
          <source>All of the routines are described in the Intel documentation to take &amp;ldquo;an optional list of variables protected by the memory barrier&amp;rdquo;. It&amp;rsquo;s not clear what is meant by that; it could mean that &lt;em&gt;only&lt;/em&gt; the listed variables are protected, or it could mean a list of additional variables to be protected. The list is ignored by GCC which treats it as empty. GCC interprets an empty list as meaning that all globally accessible variables should be protected.</source>
          <target state="translated">英特尔文档中将所有例程描述为&amp;ldquo;受内存屏障保护的变量的可选列表&amp;rdquo;。目前尚不清楚这是什么意思。这可能意味着&lt;em&gt;仅&lt;/em&gt;列出的变量受到保护，或者可能意味着要保护的其他变量的列表。该列表会被GCC忽略，它将视为空列表。GCC将一个空列表解释为意味着应保护所有全局可访问变量。</target>
        </trans-unit>
        <trans-unit id="2dc38cb28fe09de761809c6899ec0dfab5c95980" translate="yes" xml:space="preserve">
          <source>All other attributes</source>
          <target state="translated">所有其他属性</target>
        </trans-unit>
        <trans-unit id="4e1fe3c41d4a92f980feaffab352908a5ae600b4" translate="yes" xml:space="preserve">
          <source>All the above</source>
          <target state="translated">以上所有</target>
        </trans-unit>
        <trans-unit id="72ca116b6b2d46153e83f38824f95e8a5d694cf5" translate="yes" xml:space="preserve">
          <source>All the basic integer types can be used as base types, both as signed and as unsigned: &lt;code&gt;char&lt;/code&gt;, &lt;code&gt;short&lt;/code&gt;, &lt;code&gt;int&lt;/code&gt;, &lt;code&gt;long&lt;/code&gt;, &lt;code&gt;long long&lt;/code&gt;. In addition, &lt;code&gt;float&lt;/code&gt; and &lt;code&gt;double&lt;/code&gt; can be used to build floating-point vector types.</source>
          <target state="translated">所有基本整数类型都可以用作有符号和无符号的基本类型： &lt;code&gt;char&lt;/code&gt; ， &lt;code&gt;short&lt;/code&gt; ， &lt;code&gt;int&lt;/code&gt; ， &lt;code&gt;long&lt;/code&gt; ， &lt;code&gt;long long&lt;/code&gt; 。此外， &lt;code&gt;float&lt;/code&gt; 和 &lt;code&gt;double&lt;/code&gt; 可以用于构建浮点向量类型。</target>
        </trans-unit>
        <trans-unit id="b8115dc4041976655c63e593fd53f619ce3ca975" translate="yes" xml:space="preserve">
          <source>All the data and read-only data segments must be within 512KB addressing space. The text segment must be within 16MB addressing space.</source>
          <target state="translated">所有数据和只读数据段必须在512KB寻址空间内。文本段必须在16MB寻址空间内。</target>
        </trans-unit>
        <trans-unit id="a642a04a04ca54e997a623213186ae992d1e6e8c" translate="yes" xml:space="preserve">
          <source>All the text and data segments can be within 4GB addressing space.</source>
          <target state="translated">所有的文本和数据段都可以在4GB寻址空间内。</target>
        </trans-unit>
        <trans-unit id="bd8b82ccf3682d163d774079a9dc8ccb0aa660ee" translate="yes" xml:space="preserve">
          <source>All visibilities are supported on many, but not all, ELF targets (supported when the assembler supports the &amp;lsquo;</source>
          <target state="translated">在所有但不是所有ELF目标上都支持所有可见性（当汇编器支持&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="622f4dc5287fcd41d6f3a24869b2a0df614a0723" translate="yes" xml:space="preserve">
          <source>Allocate to an &lt;code&gt;enum&lt;/code&gt; type only as many bytes as it needs for the declared range of possible values. Specifically, the &lt;code&gt;enum&lt;/code&gt; type is equivalent to the smallest integer type that has enough room.</source>
          <target state="translated">仅为声明的可能值范围分配一个 &lt;code&gt;enum&lt;/code&gt; 类型所需的字节数。具体来说， &lt;code&gt;enum&lt;/code&gt; 类型等效于具有足够空间的最小整数类型。</target>
        </trans-unit>
        <trans-unit id="1b577848b6e6ae4af92719e79079d9951a50047f" translate="yes" xml:space="preserve">
          <source>Allocate variables to the read-only data section first if possible, then next in the small data section if possible, otherwise in data. This gives slightly slower code than the default, but reduces the amount of RAM required when executing, and thus may be preferred for some embedded systems.</source>
          <target state="translated">如果可能的话,先将变量分配到只读数据部分,然后尽可能在小数据部分下一步,否则在数据中。这样做的代码速度比默认的略慢,但减少了执行时所需的RAM量,因此对于一些嵌入式系统来说,可能是首选。</target>
        </trans-unit>
        <trans-unit id="12f3f43a7ca9147ffe2ba31d63c2ea8ec201486c" translate="yes" xml:space="preserve">
          <source>Allow arbitrary-sized immediates in bit operations.</source>
          <target state="translated">允许在位操作中使用任意大小的即时器。</target>
        </trans-unit>
        <trans-unit id="ac2c75532a2e292a21a77540eaedf29f5c432d5a" translate="yes" xml:space="preserve">
          <source>Allow conditional expressions with mismatched types in the second and third arguments. The value of such an expression is void. This option is not supported for C++.</source>
          <target state="translated">允许在第二个和第三个参数中使用类型不匹配的条件表达式。这种表达式的值是void。C++不支持这个选项。</target>
        </trans-unit>
        <trans-unit id="8d58e8c4bb0f63ea94500caf667ca947fcaa1a82" translate="yes" xml:space="preserve">
          <source>Allow fast jumps to the message dispatcher. On Darwin this is accomplished via the comm page.</source>
          <target state="translated">允许快速跳转到消息发送器。在达尔文上,这是通过通讯页面实现的。</target>
        </trans-unit>
        <trans-unit id="c73dadda8d4b49fb004b5103de76106d4f0b8557" translate="yes" xml:space="preserve">
          <source>Allow implicit conversions between vectors with differing numbers of elements and/or incompatible element types. This option should not be used for new code.</source>
          <target state="translated">允许在元素数量不同和/或元素类型不兼容的向量之间进行隐式转换。这个选项不应该用于新代码。</target>
        </trans-unit>
        <trans-unit id="d0dbb659ed768befd508acb2601c588f49ddaa57" translate="yes" xml:space="preserve">
          <source>Allow optimizations for floating-point arithmetic that (a) assume that arguments and results are valid and (b) may violate IEEE or ANSI standards. When used at link time, it may include libraries or startup files that change the default FPU control word or other similar optimizations.</source>
          <target state="translated">允许对浮点算术进行优化,(a)假设参数和结果有效,(b)可能违反IEEE或ANSI标准。在链接时使用时,它可能包括改变默认FPU控制字或其他类似优化的库或启动文件。</target>
        </trans-unit>
        <trans-unit id="773a6288517f96a4a7283887bb99a6fba71c957c" translate="yes" xml:space="preserve">
          <source>Allow optimizations for floating-point arithmetic that assume that arguments and results are not NaNs or +-Infs.</source>
          <target state="translated">允许对浮点运算进行优化,假设参数和结果不是NaNs或+Infs。</target>
        </trans-unit>
        <trans-unit id="1e06113b53f739fa9c85ec94358e3f373eb320f8" translate="yes" xml:space="preserve">
          <source>Allow optimizations for floating-point arithmetic that ignore the signedness of zero. IEEE arithmetic specifies the behavior of distinct +0.0 and -0.0 values, which then prohibits simplification of expressions such as x+0.0 or 0.0*x (even with</source>
          <target state="translated">允许对浮点算术进行优化,忽略零的符号性。IEEE算术规定了不同的+0.0和-0.0值的行为,这就禁止简化表达式,如x+0.0或0.0*x(即使是在使用了</target>
        </trans-unit>
        <trans-unit id="0eea9d2d0ec6a801c6ef5293eae12c7fbb21b59c" translate="yes" xml:space="preserve">
          <source>Allow optimizers to introduce new data races on stores. Set to 1 to allow, otherwise to 0.</source>
          <target state="translated">允许优化器在存储上引入新的数据竞赛。设置为1为允许,否则为0。</target>
        </trans-unit>
        <trans-unit id="c60cf758a077c6f503981387a6b0345419874bea" translate="yes" xml:space="preserve">
          <source>Allow or disallow the compiler to emit the &lt;code&gt;fsca&lt;/code&gt; instruction for sine and cosine approximations. The option</source>
          <target state="translated">允许或禁止编译器发出 &lt;code&gt;fsca&lt;/code&gt; 指令以表示正弦和余弦近似值。选项</target>
        </trans-unit>
        <trans-unit id="70331cead1dc233186888055e035642315d5054e" translate="yes" xml:space="preserve">
          <source>Allow or disallow the compiler to emit the &lt;code&gt;fsrra&lt;/code&gt; instruction for reciprocal square root approximations. The option</source>
          <target state="translated">允许或禁止编译器发出 &lt;code&gt;fsrra&lt;/code&gt; 指令以求倒数平方根近似值。选项</target>
        </trans-unit>
        <trans-unit id="57cbe965449910b6f59559b0a1874d0d198b696a" translate="yes" xml:space="preserve">
          <source>Allow re-association of operands in series of floating-point operations. This violates the ISO C and C++ language standard by possibly changing computation result. NOTE: re-ordering may change the sign of zero as well as ignore NaNs and inhibit or create underflow or overflow (and thus cannot be used on code that relies on rounding behavior like &lt;code&gt;(x + 2**52) - 2**52&lt;/code&gt;. May also reorder floating-point comparisons and thus may not be used when ordered comparisons are required. This option requires that both</source>
          <target state="translated">允许在一系列浮点运算中重新关联操作数。通过可能更改计算结果，这违反了ISO C和C ++语言标准。注意：重新排序可能会更改零的符号，并忽略NaN并抑制或创建下溢或上溢（因此不能用于依赖舍入行为的代码，例如 &lt;code&gt;(x + 2**52) - 2**52&lt;/code&gt; 可能还会对浮点比较进行重新排序，因此在需要进行顺序比较时可能无法使用。</target>
        </trans-unit>
        <trans-unit id="54ce20d4ec16fad4cd32f197249fdc3fb1dac290" translate="yes" xml:space="preserve">
          <source>Allow speculative motion of more load instructions. This only makes sense when scheduling before register allocation, i.e. with</source>
          <target state="translated">允许更多负载指令的投机运动。这只有在寄存器分配前进行调度时才有意义,即用</target>
        </trans-unit>
        <trans-unit id="1b47c26e732fcedac3b1858953b01853eb8422ec" translate="yes" xml:space="preserve">
          <source>Allow speculative motion of some load instructions. This only makes sense when scheduling before register allocation, i.e. with</source>
          <target state="translated">允许一些加载指令的投机运动。这只有在寄存器分配前进行调度时才有意义,即用</target>
        </trans-unit>
        <trans-unit id="f926321cb4f3fc49097c6857a3e7d152a19de395" translate="yes" xml:space="preserve">
          <source>Allow stop bits to be placed earlier than immediately preceding the instruction that triggered the stop bit. This can improve instruction scheduling, but does not always do so.</source>
          <target state="translated">允许将停止位放在比紧挨着触发停止位的指令之前的位置。这可以改善指令调度,但并不总是这样做。</target>
        </trans-unit>
        <trans-unit id="7905fb7386b21750ad5a1d1722446a6fdeb43598" translate="yes" xml:space="preserve">
          <source>Allow the compiler to assume the strictest aliasing rules applicable to the language being compiled. For C (and C++), this activates optimizations based on the type of expressions. In particular, an object of one type is assumed never to reside at the same address as an object of a different type, unless the types are almost the same. For example, an &lt;code&gt;unsigned int&lt;/code&gt; can alias an &lt;code&gt;int&lt;/code&gt;, but not a &lt;code&gt;void*&lt;/code&gt; or a &lt;code&gt;double&lt;/code&gt;. A character type may alias any other type.</source>
          <target state="translated">允许编译器采用适用于所编译语言的最严格的别名规则。对于C（和C ++），这会根据表达式的类型激活优化。特别是，除非类型几乎相同，否则假定一种类型的对象永远不会与其他类型的对象位于相同的地址。例如， &lt;code&gt;unsigned int&lt;/code&gt; 可以为 &lt;code&gt;int&lt;/code&gt; 别名，但不能为 &lt;code&gt;void*&lt;/code&gt; 或 &lt;code&gt;double&lt;/code&gt; 别名。字符类型可以别名任何其他类型。</target>
        </trans-unit>
        <trans-unit id="bc2aa80da8f5ff65f45ae97b354110390c96c42f" translate="yes" xml:space="preserve">
          <source>Allow the compiler to generate &lt;em&gt;Long Instruction Word&lt;/em&gt; instructions if the target is the &amp;lsquo;</source>
          <target state="translated">让编译器生成&lt;em&gt;超长指令字&lt;/em&gt;的说明，如果目标是'</target>
        </trans-unit>
        <trans-unit id="f39db7389fdae7630a67f4845ba2f639259c8a4a" translate="yes" xml:space="preserve">
          <source>Allow the compiler to generate the &lt;em&gt;SETLB&lt;/em&gt; and &lt;em&gt;Lcc&lt;/em&gt; instructions if the target is the &amp;lsquo;</source>
          <target state="translated">如果目标是''，则允许编译器生成&lt;em&gt;SETLB&lt;/em&gt;和&lt;em&gt;Lcc&lt;/em&gt;指令。</target>
        </trans-unit>
        <trans-unit id="fa7a919d8fa035f96c5d1af049879f0dd62e1421" translate="yes" xml:space="preserve">
          <source>Allow the compiler to optimize using the assumption that a value of enumerated type can only be one of the values of the enumeration (as defined in the C++ standard; basically, a value that can be represented in the minimum number of bits needed to represent all the enumerators). This assumption may not be valid if the program uses a cast to convert an arbitrary integer value to the enumerated type.</source>
          <target state="translated">允许编译器使用以下假设进行优化:一个枚举类型的值只能是枚举的值之一(如C++标准中所定义的那样;基本上,一个可以用表示所有枚举器所需的最少位数表示的值)。如果程序使用转码将任意整数值转换为枚举类型,这个假设可能不成立。</target>
        </trans-unit>
        <trans-unit id="33fc8a715b12ca22462902ef833240995e04a5d4" translate="yes" xml:space="preserve">
          <source>Allow the compiler to use all of the available registers. By default registers &lt;code&gt;r24..r31&lt;/code&gt; are reserved for use in interrupt handlers. With this option enabled these registers can be used in ordinary functions as well.</source>
          <target state="translated">允许编译器使用所有可用寄存器。默认情况下，寄存器 &lt;code&gt;r24..r31&lt;/code&gt; 保留供中断处理程序使用。启用此选项后，这些寄存器也可以用于普通功能。</target>
        </trans-unit>
        <trans-unit id="6303c2c94b5f256a55d06aa2be50e19fcb0df737" translate="yes" xml:space="preserve">
          <source>Allow the reciprocal of a value to be used instead of dividing by the value if this enables optimizations. For example &lt;code&gt;x / y&lt;/code&gt; can be replaced with &lt;code&gt;x * (1/y)&lt;/code&gt;, which is useful if &lt;code&gt;(1/y)&lt;/code&gt; is subject to common subexpression elimination. Note that this loses precision and increases the number of flops operating on the value.</source>
          <target state="translated">如果启用优化，则允许使用值的倒数而不是除以该值。例如 &lt;code&gt;x / y&lt;/code&gt; 可以替换为 &lt;code&gt;x * (1/y)&lt;/code&gt; ，如果这是有用的 &lt;code&gt;(1/y)&lt;/code&gt; 是受公共子表达式消除。请注意，这会失去精度，并增加了根据该值进行操作的触发器数量。</target>
        </trans-unit>
        <trans-unit id="5cbc7a77a073ec8e91de85701bbe563110739962" translate="yes" xml:space="preserve">
          <source>Allow the store merging pass to introduce unaligned stores if it is legal to do so.</source>
          <target state="translated">在合法的情况下,允许店铺合并通引入不结盟店铺。</target>
        </trans-unit>
        <trans-unit id="b8c16f16485e58470d06579755ecbd0f929ac7fa" translate="yes" xml:space="preserve">
          <source>Allow to use truncation instead of rounding towards zero for fractional fixed-point types.</source>
          <target state="translated">对于小数定点类型,允许使用截断而不是四舍五入。</target>
        </trans-unit>
        <trans-unit id="8834a22ee0acee1821ccfc8e148c6cbb34655847" translate="yes" xml:space="preserve">
          <source>Allow using extensions of later DWARF standard version than selected with</source>
          <target state="translated">允许使用DWARF标准版本以后的扩展,而不是选择的标准版本。</target>
        </trans-unit>
        <trans-unit id="98ea6e4c4f75e6a8f8033c8b750f3d749cc09003" translate="yes" xml:space="preserve">
          <source>Allow/disallow treating the &lt;code&gt;__ea&lt;/code&gt; address space as superset of the generic address space. This enables explicit type casts between &lt;code&gt;__ea&lt;/code&gt; and generic pointer as well as implicit conversions of generic pointers to &lt;code&gt;__ea&lt;/code&gt; pointers. The default is to allow address space pointer conversions.</source>
          <target state="translated">允许/禁止将 &lt;code&gt;__ea&lt;/code&gt; 地址空间视为通用地址空间的超集。这样可以在 &lt;code&gt;__ea&lt;/code&gt; 和通用指针之间进行显式类型转换，以及将通用指针隐式转换为 &lt;code&gt;__ea&lt;/code&gt; 指针。默认值为允许地址空间指针转换。</target>
        </trans-unit>
        <trans-unit id="74a5bb83513cc4e38a6504a7eaa0f1d977ac61b9" translate="yes" xml:space="preserve">
          <source>Allowable bit-field types other than &lt;code&gt;_Bool&lt;/code&gt;, &lt;code&gt;signed int&lt;/code&gt;, and &lt;code&gt;unsigned int&lt;/code&gt; (C99 and C11 6.7.2.1).</source>
          <target state="translated">&lt;code&gt;_Bool&lt;/code&gt; ， &lt;code&gt;signed int&lt;/code&gt; 和 &lt;code&gt;unsigned int&lt;/code&gt; 以外的允许位域类型（C99和C11 6.7.2.1）。</target>
        </trans-unit>
        <trans-unit id="9672aa21a92b454bca4334e1b73511ba859e3019" translate="yes" xml:space="preserve">
          <source>Allows calls via function pointers (including virtual functions) to execute correctly regardless of whether the target code has been compiled for interworking or not. There is a small overhead in the cost of executing a function pointer if this option is enabled. This option is not valid in AAPCS configurations because interworking is enabled by default.</source>
          <target state="translated">允许通过函数指针(包括虚拟函数)的调用正确执行,无论目标代码是否已被编译为互操作。如果启用这个选项,执行函数指针的成本会有一个小的开销。这个选项在AAPCS配置中是无效的,因为默认情况下是启用了互操作。</target>
        </trans-unit>
        <trans-unit id="9fab16002619dc077a62263507de1c970a51b300" translate="yes" xml:space="preserve">
          <source>Also note that GCC emits the above sequence with additional Newton-Raphson step for vectorized single-float division and vectorized &lt;code&gt;sqrtf(&lt;var&gt;x&lt;/var&gt;)&lt;/code&gt; already with</source>
          <target state="translated">还要注意的是GCC发射具有用于向量化单浮除法附加牛顿-拉夫逊步骤和矢量上述序列 &lt;code&gt;sqrtf(&lt;var&gt;x&lt;/var&gt;)&lt;/code&gt; 已经与</target>
        </trans-unit>
        <trans-unit id="1a461c1e71dd5c0a03740ad367bc2a7b24233082" translate="yes" xml:space="preserve">
          <source>Also note that an &lt;code&gt;asm goto&lt;/code&gt; statement is always implicitly considered volatile.</source>
          <target state="translated">还要注意， &lt;code&gt;asm goto&lt;/code&gt; 语句始终被隐式认为是易失的。</target>
        </trans-unit>
        <trans-unit id="767bf94dfe72662ddbd8e20120050c8f90e9046e" translate="yes" xml:space="preserve">
          <source>Also warn about cases where the compiler reduces the magnitude of a constant involved in a comparison. For example: &lt;code&gt;x + 2 &amp;gt; y&lt;/code&gt; is simplified to &lt;code&gt;x + 1 &amp;gt;= y&lt;/code&gt;. This is reported only at the highest warning level because this simplification applies to many comparisons, so this warning level gives a very large number of false positives.</source>
          <target state="translated">还警告编译器减小比较所涉及的常数的大小的情况。例如： &lt;code&gt;x + 2 &amp;gt; y&lt;/code&gt; 简化为 &lt;code&gt;x + 1 &amp;gt;= y&lt;/code&gt; 。仅在最高警告级别上报告此事件，因为此简化适用于许多比较，因此此警告级别给出了大量误报。</target>
        </trans-unit>
        <trans-unit id="c15f6772b26643b0ff617a164130fae2096f2324" translate="yes" xml:space="preserve">
          <source>Also warn about other cases where a comparison is simplified to a constant. For example: &lt;code&gt;abs (x) &amp;gt;= 0&lt;/code&gt;. This can only be simplified when signed integer overflow is undefined, because &lt;code&gt;abs (INT_MIN)&lt;/code&gt; overflows to &lt;code&gt;INT_MIN&lt;/code&gt;, which is less than zero.</source>
          <target state="translated">还警告将比较简化为常数的其他情况。例如： &lt;code&gt;abs (x) &amp;gt;= 0&lt;/code&gt; 。仅当未定义有符号整数溢出时才可以简化此操作，因为 &lt;code&gt;abs (INT_MIN)&lt;/code&gt; 溢出到小于零的 &lt;code&gt;INT_MIN&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e8e800b6cdd36533f8ba6ba58f938d89e7317e5b" translate="yes" xml:space="preserve">
          <source>Also warn about other cases where a comparison is simplified. For example: &lt;code&gt;x + 1 &amp;gt; 1&lt;/code&gt; is simplified to &lt;code&gt;x &amp;gt; 0&lt;/code&gt;.</source>
          <target state="translated">还警告简化比较的其他情况。例如： &lt;code&gt;x + 1 &amp;gt; 1&lt;/code&gt; 简化为 &lt;code&gt;x &amp;gt; 0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f2eccf451b029841db2d4f52cb1371fa4ffd7cc2" translate="yes" xml:space="preserve">
          <source>Also warn about other simplifications not covered by the above cases. For example: &lt;code&gt;(x * 10) / 5&lt;/code&gt; is simplified to &lt;code&gt;x * 2&lt;/code&gt;.</source>
          <target state="translated">还警告上述情况未涵盖的其他简化方法。例如： &lt;code&gt;(x * 10) / 5&lt;/code&gt; 简化为 &lt;code&gt;x * 2&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="aaf71652d194ffb84805956fe1b5940083ae517e" translate="yes" xml:space="preserve">
          <source>Also warn for dangerous uses of the GNU extension to &lt;code&gt;?:&lt;/code&gt; with omitted middle operand. When the condition in the &lt;code&gt;?&lt;/code&gt;: operator is a boolean expression, the omitted value is always 1. Often programmers expect it to be a value computed inside the conditional expression instead.</source>
          <target state="translated">还警告GNU扩展到 &lt;code&gt;?:&lt;/code&gt; 的危险用途，并省略中间操作数。当条件在 &lt;code&gt;?&lt;/code&gt; ：运算符是一个布尔表达式，忽略的值始终为1。程序员通常希望它是在条件表达式中计算的值。</target>
        </trans-unit>
        <trans-unit id="0777d5422fc8bc8f5bababa57c28335fb0cdc795" translate="yes" xml:space="preserve">
          <source>Also warn if a comparison like &lt;code&gt;x&amp;lt;=y&amp;lt;=z&lt;/code&gt; appears; this is equivalent to &lt;code&gt;(x&amp;lt;=y ? 1 : 0) &amp;lt;= z&lt;/code&gt;, which is a different interpretation from that of ordinary mathematical notation.</source>
          <target state="translated">如果出现类似 &lt;code&gt;x&amp;lt;=y&amp;lt;=z&lt;/code&gt; 的比较，也要发出警告；这等效于 &lt;code&gt;(x&amp;lt;=y ? 1 : 0) &amp;lt;= z&lt;/code&gt; ，它与普通数学符号的解释不同。</target>
        </trans-unit>
        <trans-unit id="4e45248057e2324494ad069a7abd8071c0384ad1" translate="yes" xml:space="preserve">
          <source>Also warn when making a cast that introduces a type qualifier in an unsafe way. For example, casting &lt;code&gt;char **&lt;/code&gt; to &lt;code&gt;const char **&lt;/code&gt; is unsafe, as in this example:</source>
          <target state="translated">在进行以不安全方式引入类型限定符的强制转换时也要发出警告。例如，将 &lt;code&gt;char **&lt;/code&gt; 强制转换为 &lt;code&gt;const char **&lt;/code&gt; 是不安全的，如以下示例所示：</target>
        </trans-unit>
        <trans-unit id="ebdf7f49c076ed9ff3a97d65da78f8767a5691c7" translate="yes" xml:space="preserve">
          <source>Also, some built-in functions prefer or require immediate numbers as parameters, because the corresponding DSP instructions accept both immediate numbers and register operands, or accept immediate numbers only. The immediate parameters are listed as follows.</source>
          <target state="translated">另外,由于相应的DSP指令既接受即时数,又接受寄存器操作数,或者只接受即时数,所以有些内置函数喜欢或需要即时数作为参数。即时数参数列举如下。</target>
        </trans-unit>
        <trans-unit id="f5b2a9f079522dadbd70f5a362997b267591505d" translate="yes" xml:space="preserve">
          <source>Also, the ABI changed the mangling of template argument packs, &lt;code&gt;const_cast&lt;/code&gt;, &lt;code&gt;static_cast&lt;/code&gt;, prefix increment/decrement, and a class scope function used as a template argument.</source>
          <target state="translated">此外，ABI更改了模板参数包 &lt;code&gt;const_cast&lt;/code&gt; ， &lt;code&gt;static_cast&lt;/code&gt; ，前缀增量/减量和用作模板参数的类范围函数的处理。</target>
        </trans-unit>
        <trans-unit id="bedbe72286a46ec20159c0af50884180a15a3619" translate="yes" xml:space="preserve">
          <source>Also, there are two special clobber arguments:</source>
          <target state="translated">另外,还有两个特殊的口水论证。</target>
        </trans-unit>
        <trans-unit id="1793f4a326dd636d187c7ec419e47dec37d6305e" translate="yes" xml:space="preserve">
          <source>Also, you must provide function prototypes for all functions that take variable numbers of arguments (including &lt;code&gt;printf&lt;/code&gt;); otherwise incorrect code is generated for calls to those functions.</source>
          <target state="translated">同样，您必须为所有带有可变数量参数（包括 &lt;code&gt;printf&lt;/code&gt; ）的函数提供函数原型；否则，将为调用这些函数生成错误的代码。</target>
        </trans-unit>
        <trans-unit id="b85df36ab018e13c039dd34eb2302708663f4af2" translate="yes" xml:space="preserve">
          <source>Alter the cost model used for vectorization of loops marked with the OpenMP simd directive. The &lt;var&gt;model&lt;/var&gt; argument should be one of &amp;lsquo;</source>
          <target state="translated">更改用于对带有OpenMP simd指令标记的循环进行矢量化处理的成本模型。该 &lt;var&gt;model&lt;/var&gt; 参数应该是一个&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="f431f1054230ce8fcc7bc5eae8ec9ced8a86a188" translate="yes" xml:space="preserve">
          <source>Alter the cost model used for vectorization. The &lt;var&gt;model&lt;/var&gt; argument should be one of &amp;lsquo;</source>
          <target state="translated">更改用于向量化的成本模型。该 &lt;var&gt;model&lt;/var&gt; 参数应该是一个&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="9fc71ca35ab8d8d40760c8ef39bc71ee861a4bcc" translate="yes" xml:space="preserve">
          <source>Alter the thread-local storage model to be used (see &lt;a href=&quot;thread_002dlocal#Thread_002dLocal&quot;&gt;Thread-Local&lt;/a&gt;). The &lt;var&gt;model&lt;/var&gt; argument should be one of &amp;lsquo;</source>
          <target state="translated">更改要使用的线程本地存储模型（请参阅&lt;a href=&quot;thread_002dlocal#Thread_002dLocal&quot;&gt;Thread-Local&lt;/a&gt;）。该 &lt;var&gt;model&lt;/var&gt; 参数应该是一个&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="2d63c6f25ef5c2c6707d16e831a6091cc8c50e17" translate="yes" xml:space="preserve">
          <source>Alter the update method for an application instrumented for profile feedback based optimization. The &lt;var&gt;method&lt;/var&gt; argument should be one of &amp;lsquo;</source>
          <target state="translated">为基于概要文件反馈优化的应用程序更改更新方法。所述 &lt;var&gt;method&lt;/var&gt; 参数应该是一个'</target>
        </trans-unit>
        <trans-unit id="a7ba2917cba97115bf3adee00dd20256ca8bef51" translate="yes" xml:space="preserve">
          <source>Alternately, you can reference labels using the actual C label name enclosed in brackets. For example, to reference a label named &lt;code&gt;carry&lt;/code&gt;, you can use &amp;lsquo;</source>
          <target state="translated">或者，您可以使用括号中的实际C标签名称引用标签。例如，要引用名为 &lt;code&gt;carry&lt;/code&gt; 的标签，可以使用'</target>
        </trans-unit>
        <trans-unit id="c04a618f555219675642e22c54d794ab28d7300f" translate="yes" xml:space="preserve">
          <source>Alternatively you can discover which binary optimizations are enabled by</source>
          <target state="translated">另外,您也可以通过以下方式发现哪些二进制优化是被启用的。</target>
        </trans-unit>
        <trans-unit id="1b2db455af7c311c86d9a9e68fe99ec219f1fdb6" translate="yes" xml:space="preserve">
          <source>Alternatively, the function attribute &lt;code&gt;noplt&lt;/code&gt; can be used to avoid calls through the PLT for specific external functions.</source>
          <target state="translated">或者，可以使用函数属性 &lt;code&gt;noplt&lt;/code&gt; 来避免通过PLT调用特定的外部函数。</target>
        </trans-unit>
        <trans-unit id="724d746f6afeb6dcb4048f896627e2174930b360" translate="yes" xml:space="preserve">
          <source>Alternatively, you might decide to put the precompiled header file in a directory and use</source>
          <target state="translated">或者,你可以决定将预编译的头文件放在一个目录中,然后使用</target>
        </trans-unit>
        <trans-unit id="95f269cf4efa79d9433eb0cf9a5bd7a136f8f62d" translate="yes" xml:space="preserve">
          <source>Although IRA uses a sophisticated algorithm to compress the conflict table, the table can still require excessive amounts of memory for huge functions. If the conflict table for a function could be more than the size in MB given by this parameter, the register allocator instead uses a faster, simpler, and lower-quality algorithm that does not require building a pseudo-register conflict table.</source>
          <target state="translated">虽然IRA使用了一种复杂的算法来压缩冲突表,但对于巨大的函数来说,该表仍然需要过多的内存。如果一个函数的冲突表可能超过这个参数给出的MB大小,寄存器分配器就会使用更快、更简单、更低质量的算法,不需要建立伪寄存器冲突表。</target>
        </trans-unit>
        <trans-unit id="9b0be486c711e5de323bb610f3f803e2869a722a" translate="yes" xml:space="preserve">
          <source>Although an effort has been made to warn about all such cases, there are probably some cases that are not warned about, even though G++ is generating incompatible code. There may also be cases where warnings are emitted even though the code that is generated is compatible.</source>
          <target state="translated">虽然我们已经努力对所有这些情况发出警告,但可能有一些情况没有被警告,即使G++生成的是不兼容的代码。还有一些情况,即使生成的代码是兼容的,也会发出警告。</target>
        </trans-unit>
        <trans-unit id="91a8f5762db94ffdfef370246b2c12c4c385d73d" translate="yes" xml:space="preserve">
          <source>Although it is possible to define such a function, this is not very useful as it is not possible to read the arguments. This is only supported for C as this construct is allowed by C++.</source>
          <target state="translated">虽然可以定义这样一个函数,但由于无法读取参数,所以用处不大。这只在C语言中得到支持,因为C++允许这种结构。</target>
        </trans-unit>
        <trans-unit id="3aea130ff16faac0f0a72d4c21d30b19934fa1e8" translate="yes" xml:space="preserve">
          <source>Although the behavior is similar to the Gold Linker&amp;rsquo;s ICF optimization, GCC ICF works on different levels and thus the optimizations are not same - there are equivalences that are found only by GCC and equivalences found only by Gold.</source>
          <target state="translated">尽管其行为类似于Gold Linker的ICF优化，但GCC ICF的工作水平不同，因此优化也不相同-有些等效项仅由GCC查找，而等效项仅由Gold查找。</target>
        </trans-unit>
        <trans-unit id="cf2ebe14b431087c27c2301bbb04cfe4eb87ea4a" translate="yes" xml:space="preserve">
          <source>Although the primary usage of this attribute is for POD types, the attribute can also be applied to global C++ objects that are initialized by a constructor. In this case, the static initialization and destruction code for the object is emitted in each translation defining the object, but the calls to the constructor and destructor are protected by a link-once guard variable.</source>
          <target state="translated">虽然这个属性的主要用途是用于POD类型,但这个属性也可以应用于由构造函数初始化的全局C++对象。在这种情况下,对象的静态初始化和销毁代码会在每个定义对象的翻译中发出,但对构造函数和销毁函数的调用是由一个link-once guard变量保护的。</target>
        </trans-unit>
        <trans-unit id="419e2ab79b9a72e513efa7d620ba40673796ae3c" translate="yes" xml:space="preserve">
          <source>Although the size of a zero-length array is zero, an array member of this kind may increase the size of the enclosing type as a result of tail padding. The offset of a zero-length array member from the beginning of the enclosing structure is the same as the offset of an array with one or more elements of the same type. The alignment of a zero-length array is the same as the alignment of its elements.</source>
          <target state="translated">虽然零长度数组的大小为零,但这种数组成员可能会因为尾部填充而增加包围类型的大小。零长度数组成员从包围结构开始的偏移量与有一个或多个相同类型元素的数组的偏移量相同。零长度数组的对齐方式与元素的对齐方式相同。</target>
        </trans-unit>
        <trans-unit id="48a0b2e6239d57c9c30535eae8caf6619e4d8826" translate="yes" xml:space="preserve">
          <source>Altivec register if</source>
          <target state="translated">Altivec注册,如果</target>
        </trans-unit>
        <trans-unit id="43210ad7cdf91a35ea9e54b8ca8e28c22c6e9fd2" translate="yes" xml:space="preserve">
          <source>Altivec register to use for double loads/stores or NO_REGS.</source>
          <target state="translated">Altivec 寄存器用于双重负载/存储或 NO_REGS。</target>
        </trans-unit>
        <trans-unit id="1e72319ddb65cddc1596b72314174c11a529e4e9" translate="yes" xml:space="preserve">
          <source>Altivec register to use for float/32-bit int loads/stores or NO_REGS.</source>
          <target state="translated">Altivec 寄存器用于浮点/32位的int load/stores或NO_REGS。</target>
        </trans-unit>
        <trans-unit id="27667baa779021dc30ceb24d0b6298a36d1ae73c" translate="yes" xml:space="preserve">
          <source>Altivec vector register</source>
          <target state="translated">Altivec向量寄存器</target>
        </trans-unit>
        <trans-unit id="7213a39022a1a221aa305b421707bb55dfa13ff8" translate="yes" xml:space="preserve">
          <source>Always treat bit-fields as &lt;code&gt;int&lt;/code&gt;-sized.</source>
          <target state="translated">始终将位字段视为 &lt;code&gt;int&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="549d944304e895a2c1d4531ead649e8cbf5063ad" translate="yes" xml:space="preserve">
          <source>Always use a library call.</source>
          <target state="translated">总是使用库调用。</target>
        </trans-unit>
        <trans-unit id="0b4062f8987d50153e0838000ddb5e4f41ad4e24" translate="yes" xml:space="preserve">
          <source>Among the consequences of these changes are that static data members of the same type with the same name but defined in different shared objects are different, so changing one does not change the other; and that pointers to function members defined in different shared objects may not compare equal. When this flag is given, it is a violation of the ODR to define types with the same name differently.</source>
          <target state="translated">这些变化的后果包括:同一类型的同名静态数据成员,但在不同的共享对象中定义的静态数据成员是不同的,所以改变一个不会改变另一个;在不同的共享对象中定义的函数成员的指针可能不会比较相等。当给出这个标志时,对同名的类型进行不同的定义是违反ODR的。</target>
        </trans-unit>
        <trans-unit id="99690d58d4abd10cd0938a7adcb56ded08ef66ad" translate="yes" xml:space="preserve">
          <source>An</source>
          <target state="translated">An</target>
        </trans-unit>
        <trans-unit id="c5009a6f1efb8810f35df0d2766e52237ed673ad" translate="yes" xml:space="preserve">
          <source>An 8 bit value with exactly one bit set.</source>
          <target state="translated">一个8位的值,正好设置一个位。</target>
        </trans-unit>
        <trans-unit id="73fdb3be2e0086894a1e44f055f6c3c5fe05581e" translate="yes" xml:space="preserve">
          <source>An 8-element vector constant with identical elements.</source>
          <target state="translated">一个具有相同元素的8元素向量常数。</target>
        </trans-unit>
        <trans-unit id="42e73ea7df5141021212bafc4bcfa0e59c8e090d" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;asm goto&lt;/code&gt; statement cannot have outputs. This is due to an internal restriction of the compiler: control transfer instructions cannot have outputs. If the assembler code does modify anything, use the &lt;code&gt;&quot;memory&quot;&lt;/code&gt; clobber to force the optimizers to flush all register values to memory and reload them if necessary after the &lt;code&gt;asm&lt;/code&gt; statement.</source>
          <target state="translated">一个 &lt;code&gt;asm goto&lt;/code&gt; 语句不能有输出。这是由于编译器的内部限制：控制传递指令不能具有输出。如果汇编代码确实进行了任何修改，请使用 &lt;code&gt;&quot;memory&quot;&lt;/code&gt; 缓冲程序强制优化器将所有寄存器值刷新到内存中，并在 &lt;code&gt;asm&lt;/code&gt; 语句之后根据需要重新加载它们。</target>
        </trans-unit>
        <trans-unit id="04db20c14b6b3a82ba6832f795aabb1d2758d6a2" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;asm&lt;/code&gt; statement has zero or more output operands indicating the names of C variables modified by the assembler code.</source>
          <target state="translated">一个 &lt;code&gt;asm&lt;/code&gt; 语句具有零个或多个输出操作数，这些输出操作数指示由汇编代码修改的C变量的名称。</target>
        </trans-unit>
        <trans-unit id="c3ecf57ab1f86499d0414e65689faa519df6b817" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;enum&lt;/code&gt; type is not considered to be compatible with another &lt;code&gt;enum&lt;/code&gt; type even if both are compatible with the same integer type; this is what the C standard specifies. For example, &lt;code&gt;enum {foo, bar}&lt;/code&gt; is not similar to &lt;code&gt;enum {hot, dog}&lt;/code&gt;.</source>
          <target state="translated">一个 &lt;code&gt;enum&lt;/code&gt; 类型不被认为与另一个 &lt;code&gt;enum&lt;/code&gt; 类型兼容，即使它们都与同一整数类型兼容；这就是C标准指定的内容。例如， &lt;code&gt;enum {foo, bar}&lt;/code&gt; 与 &lt;code&gt;enum {hot, dog}&lt;/code&gt; 不相似。</target>
        </trans-unit>
        <trans-unit id="197244fadb4ff328f7464f8fb593d34255a64886" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;attribute specifier list&lt;/em&gt; is a sequence of one or more attribute specifiers, not separated by any other tokens.</source>
          <target state="translated">一个&lt;em&gt;属性说明符列表&lt;/em&gt;是一个或多个属性说明符的序列，而不是由任何其他代币分离。</target>
        </trans-unit>
        <trans-unit id="4db760995f077b22b4a4d97b7a5f59e2f43ffc2f" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;attribute specifier&lt;/em&gt; is of the form &lt;code&gt;__attribute__ ((&lt;var&gt;attribute-list&lt;/var&gt;))&lt;/code&gt;. An &lt;em&gt;attribute list&lt;/em&gt; is a possibly empty comma-separated sequence of &lt;em&gt;attributes&lt;/em&gt;, where each attribute is one of the following:</source>
          <target state="translated">一个&lt;em&gt;属性指定符&lt;/em&gt;的形式是 &lt;code&gt;__attribute__ ((&lt;var&gt;attribute-list&lt;/var&gt;))&lt;/code&gt; 。一个&lt;em&gt;属性列表&lt;/em&gt;是一个可能是空的逗号分隔的序列&lt;em&gt;的属性&lt;/em&gt;，其中每个属性是以下之一：</target>
        </trans-unit>
        <trans-unit id="caef8d867ec8d279c62d15ef41539390101b886c" translate="yes" xml:space="preserve">
          <source>An I-type 12-bit signed immediate.</source>
          <target state="translated">一个I型12位签名的立即。</target>
        </trans-unit>
        <trans-unit id="06327d0e0884e8359c3aeb898ee10e76eb6687a6" translate="yes" xml:space="preserve">
          <source>An absolute address</source>
          <target state="translated">绝对地址</target>
        </trans-unit>
        <trans-unit id="78c6a7cdfe8551206974bd67b2a089dc6fe26252" translate="yes" xml:space="preserve">
          <source>An absolute symbolic address or a label reference</source>
          <target state="translated">一个绝对的符号地址或标签引用</target>
        </trans-unit>
        <trans-unit id="986b6a4e37803f27663b870d347fe309ea3ea740" translate="yes" xml:space="preserve">
          <source>An address suitable for a &lt;code&gt;prefetch&lt;/code&gt; instruction, or for any other instruction with the same addressing mode as &lt;code&gt;prefetch&lt;/code&gt;.</source>
          <target state="translated">适用于 &lt;code&gt;prefetch&lt;/code&gt; 指令或与 &lt;code&gt;prefetch&lt;/code&gt; 具有相同寻址模式的任何其他指令的地址。</target>
        </trans-unit>
        <trans-unit id="892155354f6089e8dd5e479a72ea4a1751091291" translate="yes" xml:space="preserve">
          <source>An address that can be used in a non-macro load or store.</source>
          <target state="translated">一个可用于非宏加载或存储的地址。</target>
        </trans-unit>
        <trans-unit id="ff106250bd6a1ea035dee107e3b2d2773c2aecc2" translate="yes" xml:space="preserve">
          <source>An address that is held in a general-purpose register.</source>
          <target state="translated">通用寄存器中的地址。</target>
        </trans-unit>
        <trans-unit id="ebfbf78a988fb6bc16aa1ac07630bba74056e531" translate="yes" xml:space="preserve">
          <source>An address which does not involve register indirect addressing or pre/post increment/decrement addressing.</source>
          <target state="translated">不涉及寄存器间接寻址或前/后增/减寻址的地址。</target>
        </trans-unit>
        <trans-unit id="e3211e293506f09ee6205a6286105b13b8dd093c" translate="yes" xml:space="preserve">
          <source>An alternate way to write the above example is</source>
          <target state="translated">上述例子的另一种写法是</target>
        </trans-unit>
        <trans-unit id="7ed98e3e9e5fb257c8559031222af1c4e1303971" translate="yes" xml:space="preserve">
          <source>An alternative syntax for this that has been obsolete since GCC 2.5 but GCC still accepts is to write &amp;lsquo;</source>
          <target state="translated">自GCC 2.5以来，这种替代语法已经过时了，但GCC仍然接受的是写'</target>
        </trans-unit>
        <trans-unit id="0ba051ca8ecdb334d29fa5a48a0711170d4503f7" translate="yes" xml:space="preserve">
          <source>An alternative to increasing the size of the destination buffer is to constrain the range of formatted values. The maximum length of string arguments can be bounded by specifying the precision in the format directive. When numeric arguments of format directives can be assumed to be bounded by less than the precision of their type, choosing an appropriate length modifier to the format specifier will reduce the required buffer size. For example, if &lt;var&gt;a&lt;/var&gt; and &lt;var&gt;b&lt;/var&gt; in the example above can be assumed to be within the precision of the &lt;code&gt;short int&lt;/code&gt; type then using either the &lt;code&gt;%hi&lt;/code&gt; format directive or casting the argument to &lt;code&gt;short&lt;/code&gt; reduces the maximum required size of the buffer to 24 bytes.</source>
          <target state="translated">增加目标缓冲区大小的另一种方法是限制格式化值的范围。可以通过在format指令中指定精度来限制字符串参数的最大长度。当可以假定格式指令的数字参数的边界小于其类型的精度时，为格式说明符选择适当的长度修饰符将减小所需的缓冲区大小。例如，如果可以将上面示例中的 &lt;var&gt;a&lt;/var&gt; 和 &lt;var&gt;b&lt;/var&gt; 假定为 &lt;code&gt;short int&lt;/code&gt; 类型的精度之内，则使用 &lt;code&gt;%hi&lt;/code&gt; format指令或将参数强制转换为 &lt;code&gt;short&lt;/code&gt; 会将缓冲区的最大所需大小减少到24个字节。</target>
        </trans-unit>
        <trans-unit id="90ac40bd537abd77f944ca782b1d8e24e3e93586" translate="yes" xml:space="preserve">
          <source>An amendment to the 1990 standard was published in 1995. This amendment added digraphs and &lt;code&gt;__STDC_VERSION__&lt;/code&gt; to the language, but otherwise concerned the library. This amendment is commonly known as &lt;em&gt;AMD1&lt;/em&gt;; the amended standard is sometimes known as &lt;em&gt;C94&lt;/em&gt; or &lt;em&gt;C95&lt;/em&gt;. To select this standard in GCC, use the option</source>
          <target state="translated">1995年发布了对1990年标准的修订。此修订在语言中增加了 &lt;code&gt;__STDC_VERSION__&lt;/code&gt; 和__STDC_VERSION__，但是与图书馆有关。此修正案通常称为&lt;em&gt;AMD1&lt;/em&gt;；修订后的标准有时称为&lt;em&gt;C94&lt;/em&gt;或&lt;em&gt;C95&lt;/em&gt;。要在GCC中选择此标准，请使用</target>
        </trans-unit>
        <trans-unit id="5ec9ea45e6f6d2866eabdf39502663d30e59ccdc" translate="yes" xml:space="preserve">
          <source>An application can interpose its own definition of functions for functions invoked by</source>
          <target state="translated">应用程序可以将自己对函数的定义插入到由</target>
        </trans-unit>
        <trans-unit id="79eafbcf2b7c5c25e774d3009d7ad66460a67d81" translate="yes" xml:space="preserve">
          <source>An area where the difference is most apparent is name mangling. The use of different name mangling is intentional, to protect you from more subtle problems. Compilers differ as to many internal details of C++ implementation, including: how class instances are laid out, how multiple inheritance is implemented, and how virtual function calls are handled. If the name encoding were made the same, your programs would link against libraries provided from other compilers&amp;mdash;but the programs would then crash when run. Incompatible libraries are then detected at link time, rather than at run time.</source>
          <target state="translated">差异最明显的区域是名称修饰。故意使用不同的名称修饰，以保护您免受更细微的问题的困扰。编译器在C ++实现的许多内部细节方面有所不同，包括：类实例的布局方式，如何实现多重继承以及如何处理虚拟函数调用。如果名称编码相同，则您的程序将与其他编译器提供的库链接，但是程序在运行时将崩溃。然后在链接时而非运行时检测到不兼容的库。</target>
        </trans-unit>
        <trans-unit id="a97545d568f0ddabc50a6a6e190b9c96c3da5965" translate="yes" xml:space="preserve">
          <source>An assembler template is a literal string containing assembler instructions. The compiler replaces tokens in the template that refer to inputs, outputs, and goto labels, and then outputs the resulting string to the assembler. The string can contain any instructions recognized by the assembler, including directives. GCC does not parse the assembler instructions themselves and does not know what they mean or even whether they are valid assembler input. However, it does count the statements (see &lt;a href=&quot;size-of-an-asm#Size-of-an-asm&quot;&gt;Size of an asm&lt;/a&gt;).</source>
          <target state="translated">汇编器模板是包含汇编器指令的文字字符串。编译器替换引用输入，输出和goto标签的模板中的标记，然后将结果字符串输出到汇编器。该字符串可以包含汇编程序可识别的任何指令，包括指令。GCC不会自行解析汇编程序指令，也不知道它们的含义，甚至不知道它们是否是有效的汇编程序输入。但是，它确实对语句进行计数（请参见&lt;a href=&quot;size-of-an-asm#Size-of-an-asm&quot;&gt;asm的大小&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="cf8ae718bdcb577716b49e495b23a5d728121d19" translate="yes" xml:space="preserve">
          <source>An atomic operation can both constrain code motion and be mapped to hardware instructions for synchronization between threads (e.g., a fence). To which extent this happens is controlled by the memory orders, which are listed here in approximately ascending order of strength. The description of each memory order is only meant to roughly illustrate the effects and is not a specification; see the C++11 memory model for precise semantics.</source>
          <target state="translated">一个原子操作既可以约束代码的运动,也可以映射到硬件指令,以便在线程之间进行同步(例如,栅栏)。这种情况在多大程度上发生是由内存顺序控制的,这里大致按强度升序列出。对每个内存顺序的描述只是为了粗略地说明效果,并不是规范,精确的语义请参见C++11内存模型。</target>
        </trans-unit>
        <trans-unit id="4d88b31282dc4372978d47c4d528de2e00c16901" translate="yes" xml:space="preserve">
          <source>An attribute name (which may be an identifier such as &lt;code&gt;unused&lt;/code&gt;, or a reserved word such as &lt;code&gt;const&lt;/code&gt;).</source>
          <target state="translated">属性名称（可以是诸如 &lt;code&gt;unused&lt;/code&gt; 的标识符，也可以是诸如 &lt;code&gt;const&lt;/code&gt; 的保留字）。</target>
        </trans-unit>
        <trans-unit id="f65131f3242824d199035927efcf93043285cd45" translate="yes" xml:space="preserve">
          <source>An attribute name followed by a parenthesized list of parameters for the attribute. These parameters take one of the following forms:</source>
          <target state="translated">一个属性名称,后面是一个括号内的属性参数列表。这些参数采用以下形式之一:</target>
        </trans-unit>
        <trans-unit id="7d755f91a373e17fad5f0c5626bbbba251cf643a" translate="yes" xml:space="preserve">
          <source>An attribute specifier list may appear as part of a &lt;code&gt;struct&lt;/code&gt;, &lt;code&gt;union&lt;/code&gt; or &lt;code&gt;enum&lt;/code&gt; specifier. It may go either immediately after the &lt;code&gt;struct&lt;/code&gt;, &lt;code&gt;union&lt;/code&gt; or &lt;code&gt;enum&lt;/code&gt; keyword, or after the closing brace. The former syntax is preferred. Where attribute specifiers follow the closing brace, they are considered to relate to the structure, union or enumerated type defined, not to any enclosing declaration the type specifier appears in, and the type defined is not complete until after the attribute specifiers.</source>
          <target state="translated">属性说明符列表可能显示为 &lt;code&gt;struct&lt;/code&gt; ， &lt;code&gt;union&lt;/code&gt; 或 &lt;code&gt;enum&lt;/code&gt; 说明符的一部分。它可以紧跟在 &lt;code&gt;struct&lt;/code&gt; ， &lt;code&gt;union&lt;/code&gt; 或 &lt;code&gt;enum&lt;/code&gt; 关键字之后，或在右括号之后。前一种语法是首选。在属性说明符紧跟右括号的情况下，它们被认为与定义的结构，联合或枚举类型有关，而不与该类型说明符出现在其中的任何封闭声明有关，并且定义的类型直到属性说明符之后才是完整的。</target>
        </trans-unit>
        <trans-unit id="9e5e73e14616e06a74db1d5feee8111efc621957" translate="yes" xml:space="preserve">
          <source>An attribute specifier list may appear at the start of a nested declarator. At present, there are some limitations in this usage: the attributes correctly apply to the declarator, but for most individual attributes the semantics this implies are not implemented. When attribute specifiers follow the &lt;code&gt;*&lt;/code&gt; of a pointer declarator, they may be mixed with any type qualifiers present. The following describes the formal semantics of this syntax. It makes the most sense if you are familiar with the formal specification of declarators in the ISO C standard.</source>
          <target state="translated">属性说明符列表可能会出现在嵌套声明符的开头。当前，此用法有一些限制：属性正确地应用于声明符，但是对于大多数单独的属性，此暗示的语义尚未实现。当属性说明符在指针声明符的 &lt;code&gt;*&lt;/code&gt; 后面时，它们可以与存在的任何类型限定符混合使用。下面介绍此语法的形式语义。如果您熟悉ISO C标准中声明符的正式规范，这将是最有意义的。</target>
        </trans-unit>
        <trans-unit id="90c786fbc073ea725818acf8d9cbe4bc390cf984" translate="yes" xml:space="preserve">
          <source>An attribute specifier list may appear immediately before a declarator (other than the first) in a comma-separated list of declarators in a declaration of more than one identifier using a single list of specifiers and qualifiers. Such attribute specifiers apply only to the identifier before whose declarator they appear. For example, in</source>
          <target state="translated">在使用一个单一的指定符和限定符列表的多个标识符的声明中,属性指定符列表可以紧接出现在一个以逗号分隔的声明符列表中的声明符(第一个声明符除外)之前。这种属性规定符只适用于它们出现在其声明符之前的标识符。例如,在</target>
        </trans-unit>
        <trans-unit id="be5978cee71999e28113db755252c2c229b75be6" translate="yes" xml:space="preserve">
          <source>An attribute specifier list may appear immediately before the comma, &lt;code&gt;=&lt;/code&gt; or semicolon terminating the declaration of an identifier other than a function definition. Such attribute specifiers apply to the declared object or function. Where an assembler name for an object or function is specified (see &lt;a href=&quot;asm-labels#Asm-Labels&quot;&gt;Asm Labels&lt;/a&gt;), the attribute must follow the &lt;code&gt;asm&lt;/code&gt; specification.</source>
          <target state="translated">属性说明符列表可能紧接在逗号， &lt;code&gt;=&lt;/code&gt; 或分号之前，终止了除函数定义以外的标识符声明。这样的属性说明符适用于声明的对象或函数。如果指定了对象或函数的汇编器名称（请参见&lt;a href=&quot;asm-labels#Asm-Labels&quot;&gt;Asm Labels&lt;/a&gt;），则该属性必须遵循 &lt;code&gt;asm&lt;/code&gt; 规范。</target>
        </trans-unit>
        <trans-unit id="06c400bc0897dcce315e482021ea5ac2d0b133c9" translate="yes" xml:space="preserve">
          <source>An attribute specifier list may, in future, be permitted to appear after the declarator in a function definition (before any old-style parameter declarations or the function body).</source>
          <target state="translated">将来可能会允许属性指定器列表出现在函数定义中的声明符之后(在任何旧式参数声明或函数主体之前)。</target>
        </trans-unit>
        <trans-unit id="a74a1d3ff08634b1a7446e5738ed8abb53ee53ac" translate="yes" xml:space="preserve">
          <source>An empty replacement string indicates that the given range is to be removed. An empty range (e.g. &amp;ldquo;45:3-45:3&amp;rdquo;) indicates that the string is to be inserted at the given position.</source>
          <target state="translated">空的替换字符串表示要删除给定范围。空范围（例如&amp;ldquo; 45：3-45：3&amp;rdquo;）指示字符串将被插入到给定位置。</target>
        </trans-unit>
        <trans-unit id="0ae58fb99fa1b71a549f28d943d2b614039f2208" translate="yes" xml:space="preserve">
          <source>An identifier followed by a comma and a non-empty comma-separated list of expressions. For example, &lt;code&gt;format&lt;/code&gt; attributes use this form.</source>
          <target state="translated">一个标识符，后跟一个逗号和一个非空逗号分隔的表达式列表。例如， &lt;code&gt;format&lt;/code&gt; 属性使用此形式。</target>
        </trans-unit>
        <trans-unit id="68d7bc1885869717ff785880a55a84832370a8cc" translate="yes" xml:space="preserve">
          <source>An identifier. For example, &lt;code&gt;mode&lt;/code&gt; attributes use this form.</source>
          <target state="translated">标识符。例如， &lt;code&gt;mode&lt;/code&gt; 属性使用此形式。</target>
        </trans-unit>
        <trans-unit id="1ec5ac33481525fe53d426cd6db6a12a229bec4c" translate="yes" xml:space="preserve">
          <source>An immediate floating operand (expression code &lt;code&gt;const_double&lt;/code&gt; or &lt;code&gt;const_vector&lt;/code&gt;) is allowed.</source>
          <target state="translated">允许使用立即数浮动操作数（表达式代码 &lt;code&gt;const_double&lt;/code&gt; 或 &lt;code&gt;const_vector&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="594d6eba8a97b362385ec37bc0e852d2a80c0ac2" translate="yes" xml:space="preserve">
          <source>An immediate floating operand (expression code &lt;code&gt;const_double&lt;/code&gt;) is allowed, but only if the target floating point format is the same as that of the host machine (on which the compiler is running).</source>
          <target state="translated">仅当目标浮点格式与主机（在其上运行编译器）的浮点格式相同时，才允许使用立即浮点操作数（表达式代码 &lt;code&gt;const_double&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="0c315fd75b55a96544e61998f54c1ece5842737a" translate="yes" xml:space="preserve">
          <source>An immediate for and/xor/or instructions. const_int is sign extended as a 128 bit.</source>
          <target state="translated">const_int是符号扩展为128位。</target>
        </trans-unit>
        <trans-unit id="5ccfcfe71dbbefbcc7083b3111e73c588704efb6" translate="yes" xml:space="preserve">
          <source>An immediate for and/xor/or instructions. const_int is treated as a 32 bit value.</source>
          <target state="translated">const_int作为32位值处理。</target>
        </trans-unit>
        <trans-unit id="37a74b5a5b038401ba585b82ac648a38ee34ae7d" translate="yes" xml:space="preserve">
          <source>An immediate for and/xor/or instructions. const_int is treated as a 64 bit value.</source>
          <target state="translated">const_int被视为64位的值。</target>
        </trans-unit>
        <trans-unit id="724f31235beec2d91358f29c81609301ddfe064d" translate="yes" xml:space="preserve">
          <source>An immediate for most arithmetic instructions. const_int is treated as a 32 bit value.</source>
          <target state="translated">const_int被视为一个32位的值。</target>
        </trans-unit>
        <trans-unit id="ba5952eb86810c12a13a67307b761f420789e80d" translate="yes" xml:space="preserve">
          <source>An immediate for shift and rotate instructions. const_int is treated as a 32 bit value.</source>
          <target state="translated">const_int作为32位值处理。</target>
        </trans-unit>
        <trans-unit id="4f576fc6545e2a7ed32b49891eee7158495619f8" translate="yes" xml:space="preserve">
          <source>An immediate for the &lt;code&gt;iohl&lt;/code&gt; instruction. const_int is sign extended to 128 bit.</source>
          <target state="translated">&lt;code&gt;iohl&lt;/code&gt; 指令的立即数。const_int被符号扩展到128位。</target>
        </trans-unit>
        <trans-unit id="fa46e8c9174bfc14d1e6484c608422836253b5fc" translate="yes" xml:space="preserve">
          <source>An immediate for the &lt;code&gt;iohl&lt;/code&gt; instruction. const_int is treated as a 32 bit value.</source>
          <target state="translated">&lt;code&gt;iohl&lt;/code&gt; 指令的立即数。const_int被视为32位值。</target>
        </trans-unit>
        <trans-unit id="a4ad2e9f47c35dba5c3a654586cfbfd37c2d1074" translate="yes" xml:space="preserve">
          <source>An immediate for the &lt;code&gt;iohl&lt;/code&gt; instruction. const_int is treated as a 64 bit value.</source>
          <target state="translated">&lt;code&gt;iohl&lt;/code&gt; 指令的立即数。const_int被视为64位值。</target>
        </trans-unit>
        <trans-unit id="fb6b5c59189bcd298a8c54b0d5b72012198931a3" translate="yes" xml:space="preserve">
          <source>An immediate integer operand (one with constant value) is allowed. This includes symbolic constants whose values will be known only at assembly time or later.</source>
          <target state="translated">允许使用直接的整数操作数(具有常量值的操作数),这包括只有在装配时或以后才知道其值的符号常量。这包括那些只有在装配时或以后才知道其值的符号常数。</target>
        </trans-unit>
        <trans-unit id="e84f183cbd16bd54d89a362096c570a83e737d81" translate="yes" xml:space="preserve">
          <source>An immediate integer operand whose value is not an explicit integer is allowed.</source>
          <target state="translated">允许使用值不是显式整数的立即整数操作数。</target>
        </trans-unit>
        <trans-unit id="3dcd4c571d6303522812fd66511c9efeae10aff4" translate="yes" xml:space="preserve">
          <source>An immediate integer operand with a known numeric value is allowed. Many systems cannot support assembly-time constants for operands less than a word wide. Constraints for these operands should use &amp;lsquo;</source>
          <target state="translated">允许使用具有已知数值的立即整数操作数。许多系统不能支持小于一字宽的操作数的汇编时常数。这些操作数的约束应使用'</target>
        </trans-unit>
        <trans-unit id="fead0cb9bc3652a20a6803e3e14fb097bc244e18" translate="yes" xml:space="preserve">
          <source>An immediate operand for R2 andchi/andci instructions.</source>
          <target state="translated">R2和chi/andci指令的直接操作数。</target>
        </trans-unit>
        <trans-unit id="ac68e335d064a71570d610173f680ac5fbe05513" translate="yes" xml:space="preserve">
          <source>An immediate which can be loaded with &lt;code&gt;fsmbi&lt;/code&gt;.</source>
          <target state="translated">可以加载 &lt;code&gt;fsmbi&lt;/code&gt; 的立即数。</target>
        </trans-unit>
        <trans-unit id="ea450ed2fe096f001d0fa25412cdd9e4110db1ae" translate="yes" xml:space="preserve">
          <source>An immediate which can be loaded with the il/ila/ilh/ilhu instructions. const_int is sign extended to 128 bit.</source>
          <target state="translated">可以用il/ila/ilh/ilhu指令来加载的即时指令。 const_int是符号扩展到128位。</target>
        </trans-unit>
        <trans-unit id="7c728956eab601b71ea1ef8510f9ed46b01e9678" translate="yes" xml:space="preserve">
          <source>An immediate which can be loaded with the il/ila/ilh/ilhu instructions. const_int is treated as a 32 bit value.</source>
          <target state="translated">可以用il/ila/ilh/ilhu指令来加载的即时值。 const_int被视为32位的值。</target>
        </trans-unit>
        <trans-unit id="8b91f62ddf90eb3045924f61638e2ed286dc7c16" translate="yes" xml:space="preserve">
          <source>An immediate which can be loaded with the il/ila/ilh/ilhu instructions. const_int is treated as a 64 bit value.</source>
          <target state="translated">一个可以用il/ila/ilh/ilhu指令加载的即时值。 const_int被视为64位值。</target>
        </trans-unit>
        <trans-unit id="d6e53dc412a13c67bb00bedf4c0eac4f87ba77c1" translate="yes" xml:space="preserve">
          <source>An important caveat is that GCC arranges to save and restore only those registers known to the specific architecture variant being compiled for. This can make &lt;code&gt;__builtin_setjmp&lt;/code&gt; and &lt;code&gt;__builtin_longjmp&lt;/code&gt; more efficient than their library counterparts in some cases, but it can also cause incorrect and mysterious behavior when mixing with code that uses the full register set.</source>
          <target state="translated">一个重要的警告是，GCC安排仅保存和恢复正在编译的特定体系结构变体已知的那些寄存器。在某些情况下，这可以使 &lt;code&gt;__builtin_setjmp&lt;/code&gt; 和 &lt;code&gt;__builtin_longjmp&lt;/code&gt; 效率比其库同类文件更高，但在与使用完整寄存器集的代码混合时，也可能导致错误和神秘的行为。</target>
        </trans-unit>
        <trans-unit id="e86c0eceb044416401abb04a6e463d5b6094cd25" translate="yes" xml:space="preserve">
          <source>An input register that is implicitly popped by the &lt;code&gt;asm&lt;/code&gt; must be explicitly clobbered, unless it is constrained to match an output operand.</source>
          <target state="translated">除非被约束为与输出操作数匹配，否则必须显式破坏由 &lt;code&gt;asm&lt;/code&gt; 隐式弹出的输入寄存器。</target>
        </trans-unit>
        <trans-unit id="7c249498e8a7c24a4e363a078596ccff4c5734ab" translate="yes" xml:space="preserve">
          <source>An integer constant in the range -255 &amp;hellip; 0</source>
          <target state="translated">范围为-255&amp;hellip;0的整数常量</target>
        </trans-unit>
        <trans-unit id="9dc7773cc8d9e6deceeb329e43d478d46251dfd7" translate="yes" xml:space="preserve">
          <source>An integer constant in the range 0 &amp;hellip; 255.</source>
          <target state="translated">一个整数常量，范围为0&amp;hellip;255。</target>
        </trans-unit>
        <trans-unit id="5b08127ba5b721033e68de80fdaced9cd1b46db8" translate="yes" xml:space="preserve">
          <source>An integer constant in the range 1 &amp;hellip; 15.</source>
          <target state="translated">范围为1&amp;hellip;15的整数常量。</target>
        </trans-unit>
        <trans-unit id="e28d87e9d901db2966f212d84f0e7048b61d9b95" translate="yes" xml:space="preserve">
          <source>An integer constant in the range 1 &amp;hellip; 7.</source>
          <target state="translated">范围为1&amp;hellip;7的整数常量。</target>
        </trans-unit>
        <trans-unit id="bcc6027cc8de73ec51a063277dae667199da440f" translate="yes" xml:space="preserve">
          <source>An integer constant that does not meet the constraints for codes &amp;lsquo;</source>
          <target state="translated">不符合代码&amp;ldquo;&amp;rdquo;约束的整数常量</target>
        </trans-unit>
        <trans-unit id="c84f7429b210360fa5c85dafb3a76127af085fed" translate="yes" xml:space="preserve">
          <source>An integer constant that fits in 16 bits.</source>
          <target state="translated">一个适合16位的整数常数。</target>
        </trans-unit>
        <trans-unit id="7ea8f3048d5d170816523d297bd8775793dabcbf" translate="yes" xml:space="preserve">
          <source>An integer constant whose low order 16 bits are zero.</source>
          <target state="translated">一个整数常数,其低阶16位为零。</target>
        </trans-unit>
        <trans-unit id="91669a0b9c65d1cc6722fd1ac4e811cb3b9462cf" translate="yes" xml:space="preserve">
          <source>An integer constant with all bits set except exactly one.</source>
          <target state="translated">一个整数常数,所有的位都被设置了,除了一个。</target>
        </trans-unit>
        <trans-unit id="21493d2e6936d92d54e34c6a9c53ba6429a374d6" translate="yes" xml:space="preserve">
          <source>An integer constant with exactly a single bit set.</source>
          <target state="translated">一个整数常数,正好设置了一个位。</target>
        </trans-unit>
        <trans-unit id="148e29efc3e25eee684ae13925c5fb8932f17d90" translate="yes" xml:space="preserve">
          <source>An integer equal to one of the MACFLAG_XXX constants that is suitable for use only with accumulator A1.</source>
          <target state="translated">一个等于MACFLAG_XXX常数的整数,只适合用于累加器A1。</target>
        </trans-unit>
        <trans-unit id="f4afba48092a6cec863cdd332d5c5c0ad22e2831" translate="yes" xml:space="preserve">
          <source>An integer equal to one of the MACFLAG_XXX constants that is suitable for use with either accumulator.</source>
          <target state="translated">一个等于MACFLAG_XXX常数的整数,适合与任何一个累加器一起使用。</target>
        </trans-unit>
        <trans-unit id="ff1c35a13fe5ef99c7a9d9e7d6ae5125aea6469c" translate="yes" xml:space="preserve">
          <source>An interrupt handler must be declared with a mandatory pointer argument:</source>
          <target state="translated">中断处理程序必须声明一个强制性的指针参数。</target>
        </trans-unit>
        <trans-unit id="d371e86b4fb307c14a25adf02422873dfe31a1a2" translate="yes" xml:space="preserve">
          <source>An inverted bitfield mask suitable for bext or bins</source>
          <target state="translated">适用于bext或bins的倒置位场掩码。</target>
        </trans-unit>
        <trans-unit id="d009fe9b76c291a5aa0c7f6c1e8d1138fabbeb43" translate="yes" xml:space="preserve">
          <source>An item in the constant pool</source>
          <target state="translated">常量池中的一个项目</target>
        </trans-unit>
        <trans-unit id="4793f292bc93fcd62120f48245f5e44fb822389b" translate="yes" xml:space="preserve">
          <source>An object file to be fed straight into linking. Any file name with no recognized suffix is treated this way.</source>
          <target state="translated">要直接送入链接的对象文件。任何没有公认后缀的文件名都会被这样处理。</target>
        </trans-unit>
        <trans-unit id="bf8b9f9703de2f2ca710a30d52808d7dca0bcb72" translate="yes" xml:space="preserve">
          <source>An object whose identifier is declared with the storage-class specifier &lt;code&gt;__thread&lt;/code&gt; has &lt;em&gt;thread storage duration&lt;/em&gt;. Its lifetime is the entire execution of the thread, and its stored value is initialized only once, prior to thread startup.</source>
          <target state="translated">使用存储类说明 &lt;code&gt;__thread&lt;/code&gt; 声明其标识符的对象具有&lt;em&gt;线程存储期限&lt;/em&gt;。它的生命周期是线程的整个执行过程，并且在线程启动之前，它的存储值仅初始化一次。</target>
        </trans-unit>
        <trans-unit id="52a7967fec1a33e4d839edd6eff5a38decb9b59d" translate="yes" xml:space="preserve">
          <source>An offset address</source>
          <target state="translated">一个偏移地址</target>
        </trans-unit>
        <trans-unit id="89feeff33c633de750f5bb644b0891d21925addb" translate="yes" xml:space="preserve">
          <source>An offset address.</source>
          <target state="translated">一个偏移地址。</target>
        </trans-unit>
        <trans-unit id="aa367c1ec44c9cba3102e666432b6606342ed893" translate="yes" xml:space="preserve">
          <source>An operand that is a valid memory address is allowed. This is for &amp;ldquo;load address&amp;rdquo; and &amp;ldquo;push address&amp;rdquo; instructions.</source>
          <target state="translated">允许的操作数是有效的内存地址。这用于&amp;ldquo;加载地址&amp;rdquo;和&amp;ldquo;推送地址&amp;rdquo;指令。</target>
        </trans-unit>
        <trans-unit id="44a3bc3b1208cdb1273c2b09519bfd9e1cfc45ea" translate="yes" xml:space="preserve">
          <source>An operand that matches the specified operand number is allowed. If a digit is used together with letters within the same alternative, the digit should come last.</source>
          <target state="translated">允许使用与指定操作数相匹配的操作数。如果一个数字与字母在同一选项中同时使用,则该数字应排在最后。</target>
        </trans-unit>
        <trans-unit id="d0d03643cf5743c896341a88665563cee4e7f14b" translate="yes" xml:space="preserve">
          <source>An optimization that assumes that signed overflow does not occur is perfectly safe if the values of the variables involved are such that overflow never does, in fact, occur. Therefore this warning can easily give a false positive: a warning about code that is not actually a problem. To help focus on important issues, several warning levels are defined. No warnings are issued for the use of undefined signed overflow when estimating how many iterations a loop requires, in particular when determining whether a loop will be executed at all.</source>
          <target state="translated">假设不会发生签名溢出的优化是完全安全的,如果所涉及的变量的值是这样的,溢出实际上从未发生。因此,这个警告很容易给出一个假阳性:一个关于实际上没有问题的代码的警告。为了帮助关注重要的问题,我们定义了几个警告级别。在估计一个循环需要多少次迭代时,特别是在确定一个循环是否会被执行时,使用未定义的符号溢出不会发出警告。</target>
        </trans-unit>
        <trans-unit id="b187d1cbe2c1e6182a8dd178f33fdc1911f0fd4c" translate="yes" xml:space="preserve">
          <source>An overview of these techniques, their benefits and how to use them is at &lt;a href=&quot;http://gcc.gnu.org/wiki/Visibility&quot;&gt;http://gcc.gnu.org/wiki/Visibility&lt;/a&gt;.</source>
          <target state="translated">有关这些技术及其优势以及使用方法的概述，请&lt;a href=&quot;http://gcc.gnu.org/wiki/Visibility&quot;&gt;参见http://gcc.gnu.org/wiki/Visibility&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="78963be09ff63d4ade4602b745f27f40ed01fe1b" translate="yes" xml:space="preserve">
          <source>An unsigned 16-bit constant (for logic instructions).</source>
          <target state="translated">一个无符号的16位常数(用于逻辑指令)。</target>
        </trans-unit>
        <trans-unit id="5b34b8bcf92baede87b31604702d88f2552f8622" translate="yes" xml:space="preserve">
          <source>An unsigned 16-bit constant for &lt;code&gt;iohl&lt;/code&gt; and &lt;code&gt;fsmbi&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;iohl&lt;/code&gt; 和 &lt;code&gt;fsmbi&lt;/code&gt; 的无符号16位常量。</target>
        </trans-unit>
        <trans-unit id="8cb9a0ccfe5c932918592859dcea72edc71b9826" translate="yes" xml:space="preserve">
          <source>An unsigned 16-bit constant.</source>
          <target state="translated">一个无符号的16位常数。</target>
        </trans-unit>
        <trans-unit id="40ef4bae4950c14cd2a335ebce3f24b00931f1ee" translate="yes" xml:space="preserve">
          <source>An unsigned 3-bit constant for 16-byte rotates and shifts</source>
          <target state="translated">一个无符号的3位常数,用于16字节的旋转和移位。</target>
        </trans-unit>
        <trans-unit id="95ddaf18fc4d2ab678603464648f03bb8de98a4d" translate="yes" xml:space="preserve">
          <source>An unsigned 5-bit constant.</source>
          <target state="translated">一个无符号的5位常数。</target>
        </trans-unit>
        <trans-unit id="b6a00eda1fa05aab415bb11f10e795bf964e4785" translate="yes" xml:space="preserve">
          <source>An unsigned 7-bit constant for conversion/nop/channel instructions.</source>
          <target state="translated">一个无符号的7位常数,用于转换/nop/通道指令。</target>
        </trans-unit>
        <trans-unit id="5b0bf2d7544790a0320ec8391816f55aa165f088" translate="yes" xml:space="preserve">
          <source>An unsigned 7-bit constant whose 3 least significant bits are 0.</source>
          <target state="translated">一个无符号的7位常数,其3个最小有效位为0。</target>
        </trans-unit>
        <trans-unit id="8e8a3cd83ae17cf2c173ff325905d55cd210117b" translate="yes" xml:space="preserve">
          <source>An x86 example where the string memory argument is of unknown length.</source>
          <target state="translated">一个x86的例子,其中字符串内存参数是未知长度。</target>
        </trans-unit>
        <trans-unit id="8157a3070b0a23e585bb72291a5f64fac3066253" translate="yes" xml:space="preserve">
          <source>And the function names are:</source>
          <target state="translated">而函数名称是:</target>
        </trans-unit>
        <trans-unit id="cce6aeb578cc150b67e8e4f1acfc181fb9996f38" translate="yes" xml:space="preserve">
          <source>Annotate assembler instructions with estimated addresses.</source>
          <target state="translated">用估计地址来注释汇编器指令。</target>
        </trans-unit>
        <trans-unit id="295ae69532c434798f968812e2201e5c3fd052fa" translate="yes" xml:space="preserve">
          <source>Annotate assignments to user variables early in the compilation and attempt to carry the annotations over throughout the compilation all the way to the end, in an attempt to improve debug information while optimizing. Use of</source>
          <target state="translated">在编译初期对用户变量的赋值进行注释,并试图在整个编译过程中一直将注释延续到最后,试图在优化的同时改善调试信息。使用</target>
        </trans-unit>
        <trans-unit id="71fb5f4abaa1eaa677691ec6945ce018c8d3cc8a" translate="yes" xml:space="preserve">
          <source>Annotate the assembler output with a comment indicating which pattern and alternative is used. The length and cost of each instruction are also printed.</source>
          <target state="translated">在汇编器输出中加注注释,说明使用了哪种模式和替代方案。每条指令的长度和成本也被打印出来。</target>
        </trans-unit>
        <trans-unit id="93a92e7968152fb0b277671cc51df48b140f38ff" translate="yes" xml:space="preserve">
          <source>Annotate the assembler output with miscellaneous debugging information.</source>
          <target state="translated">对汇编器输出的杂项调试信息进行注释。</target>
        </trans-unit>
        <trans-unit id="989a73be7d945cbd818654da9eb44b704400138e" translate="yes" xml:space="preserve">
          <source>Another (simpler) way to enable link-time optimization is:</source>
          <target state="translated">另一种(更简单的)启用链接时间优化的方法是:。</target>
        </trans-unit>
        <trans-unit id="68f160715f630ab62644e4593ac2d81e2aac8d1b" translate="yes" xml:space="preserve">
          <source>Another consequence is that &lt;code&gt;sscanf&lt;/code&gt; does not work on some very old systems when passed a string constant as its format control string or input. This is because &lt;code&gt;sscanf&lt;/code&gt; incorrectly tries to write into the string constant. Likewise &lt;code&gt;fscanf&lt;/code&gt; and &lt;code&gt;scanf&lt;/code&gt;.</source>
          <target state="translated">另一个结果是，当将字符串常量作为格式控制字符串或输入传递时， &lt;code&gt;sscanf&lt;/code&gt; 在某些非常旧的系统上不起作用。这是因为 &lt;code&gt;sscanf&lt;/code&gt; 错误地尝试写入字符串常量。同样是 &lt;code&gt;fscanf&lt;/code&gt; 和 &lt;code&gt;scanf&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dedf5ccdeb6bf446ef7cfb01d8db4c4b042b2078" translate="yes" xml:space="preserve">
          <source>Another example:</source>
          <target state="translated">另一个例子:</target>
        </trans-unit>
        <trans-unit id="3114d5262ea0b2a7df098211946bd465d7ca75ca" translate="yes" xml:space="preserve">
          <source>Another feature of LTO is that it is possible to apply interprocedural optimizations on files written in different languages:</source>
          <target state="translated">LTO的另一个特点是可以对用不同语言编写的文件进行程序间优化。</target>
        </trans-unit>
        <trans-unit id="800bcf1831a315ef5fa60f82c87dd864fc821d9c" translate="yes" xml:space="preserve">
          <source>Another restriction is that the clobber list should not contain the stack pointer register. This is because the compiler requires the value of the stack pointer to be the same after an &lt;code&gt;asm&lt;/code&gt; statement as it was on entry to the statement. However, previous versions of GCC did not enforce this rule and allowed the stack pointer to appear in the list, with unclear semantics. This behavior is deprecated and listing the stack pointer may become an error in future versions of GCC.</source>
          <target state="translated">另一个限制是，Clobber列表不应包含堆栈指针寄存器。这是因为编译器要求在 &lt;code&gt;asm&lt;/code&gt; 语句之后，堆栈指针的值必须与进入该语句时的堆栈指针的值相同。但是，以前版本的GCC并未强制执行此规则，并允许堆栈指针以不明确的语义出现在列表中。不建议使用此行为，并且在将来的GCC版本中列出堆栈指针可能会成为错误。</target>
        </trans-unit>
        <trans-unit id="06cec1a74ddd904f5065125e6e0eba36e86de4da" translate="yes" xml:space="preserve">
          <source>Another revised ISO C++ standard was published in 2014 as ISO/IEC 14882:2014, and is referred to as C++14; before its publication it was sometimes referred to as C++1y. C++14 contains several further changes to the C++ language, all of which have been implemented in GCC. For details see &lt;a href=&quot;https://gcc.gnu.org/projects/cxx-status.html#cxx14&quot;&gt;https://gcc.gnu.org/projects/cxx-status.html#cxx14&lt;/a&gt;. To select this standard in GCC, use the option</source>
          <target state="translated">另一个修订的ISO C ++标准在2014年发布为ISO / IEC 14882：2014，被称为C ++ 14；在其发布之前，它有时被称为C ++ 1y。C ++ 14对C ++语言进行了进一步的更改，所有这些更改均已在GCC中实现。有关详细信息，请参见&lt;a href=&quot;https://gcc.gnu.org/projects/cxx-status.html#cxx14&quot;&gt;https://gcc.gnu.org/projects/cxx-status.html#cxx14&lt;/a&gt;。要在GCC中选择此标准，请使用</target>
        </trans-unit>
        <trans-unit id="100b9161d8847e18a3c098c1597e4c27bddc1e4a" translate="yes" xml:space="preserve">
          <source>Another syntax that has the same meaning, obsolete since GCC 2.5, is &amp;lsquo;</source>
          <target state="translated">自GCC 2.5起已过时的另一种具有相同含义的语法是&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="8d4503c0d7b11d51381b2775fa2f1d0bc68346b0" translate="yes" xml:space="preserve">
          <source>Another use for &lt;code&gt;__builtin_unreachable&lt;/code&gt; is following a call a function that never returns but that is not declared &lt;code&gt;__attribute__((noreturn))&lt;/code&gt;, as in this example:</source>
          <target state="translated">&lt;code&gt;__builtin_unreachable&lt;/code&gt; 的另一种用法是在调用之后执行永不返回但未声明 &lt;code&gt;__attribute__((noreturn))&lt;/code&gt; ，如本例所示：</target>
        </trans-unit>
        <trans-unit id="b5c0df1874478fedada2f09d07323584aaf952db" translate="yes" xml:space="preserve">
          <source>Another use of label values is in an interpreter for threaded code. The labels within the interpreter function can be stored in the threaded code for super-fast dispatching.</source>
          <target state="translated">标签值的另一个用途是在线程代码的解释器中。解释器函数中的标签可以存储在线程代码中,以实现超快的调度。</target>
        </trans-unit>
        <trans-unit id="054bb42dabc9a19f68ad68065d19f8cf04a8d0cf" translate="yes" xml:space="preserve">
          <source>Another way to refer to the type of an expression is with &lt;code&gt;typeof&lt;/code&gt;. The syntax of using of this keyword looks like &lt;code&gt;sizeof&lt;/code&gt;, but the construct acts semantically like a type name defined with &lt;code&gt;typedef&lt;/code&gt;.</source>
          <target state="translated">引用表达式类型的另一种方法是使用 &lt;code&gt;typeof&lt;/code&gt; 。使用此关键字的语法看起来像 &lt;code&gt;sizeof&lt;/code&gt; ，但是该构造在语义上类似于使用 &lt;code&gt;typedef&lt;/code&gt; 定义的类型名称。</target>
        </trans-unit>
        <trans-unit id="a721e97bbca8eab5f82eabfccb957a729c8f492f" translate="yes" xml:space="preserve">
          <source>Another way to specify a prefix much like the</source>
          <target state="translated">另一种指定前缀的方式很像</target>
        </trans-unit>
        <trans-unit id="96409c8e4594c5ca23408453d9c7d3939d189e53" translate="yes" xml:space="preserve">
          <source>Another, similar example involves calling member functions of a base class:</source>
          <target state="translated">另一个类似的例子是调用基类的成员函数。</target>
        </trans-unit>
        <trans-unit id="53491a8e8187c94a2d02f53706e5a4e898389bcf" translate="yes" xml:space="preserve">
          <source>Any 80387 floating-point (stack) register.</source>
          <target state="translated">任何80387浮点(栈)寄存器。</target>
        </trans-unit>
        <trans-unit id="b3758814c17061e556dad37977ffba674151e160" translate="yes" xml:space="preserve">
          <source>Any &lt;code&gt;symbol_ref&lt;/code&gt; or &lt;code&gt;label_ref&lt;/code&gt;</source>
          <target state="translated">任何 &lt;code&gt;symbol_ref&lt;/code&gt; 或 &lt;code&gt;label_ref&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b2f752342a0bbfde2ec460c7e0098752d0a9c8ba" translate="yes" xml:space="preserve">
          <source>Any &lt;code&gt;unspec&lt;/code&gt;</source>
          <target state="translated">任何不 &lt;code&gt;unspec&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="08321582787b969fc3f46ec2caec6f021be74d45" translate="yes" xml:space="preserve">
          <source>Any D, P, B, M, I or L register.</source>
          <target state="translated">任何D、P、B、M、I或L寄存器。</target>
        </trans-unit>
        <trans-unit id="a4d7faf7c72e44e81295ee83f9349235dc1598af" translate="yes" xml:space="preserve">
          <source>Any EVEX encodable SSE register (&lt;code&gt;%xmm0-%xmm31&lt;/code&gt;).</source>
          <target state="translated">任何EVEX可编码的SSE寄存器（ &lt;code&gt;%xmm0-%xmm31&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="162a9ef967e5306147bc46c88126767e87c35020" translate="yes" xml:space="preserve">
          <source>Any MMX register.</source>
          <target state="translated">任何MMX寄存器。</target>
        </trans-unit>
        <trans-unit id="6c6a18dc34784ab21c4ba11b353b499414254204" translate="yes" xml:space="preserve">
          <source>Any SSE register.</source>
          <target state="translated">任何上交所登记。</target>
        </trans-unit>
        <trans-unit id="6050748b38d243b476a4baca6c16743585fafbd7" translate="yes" xml:space="preserve">
          <source>Any SYMBOL_REF.</source>
          <target state="translated">任何SYMBOL_REF。</target>
        </trans-unit>
        <trans-unit id="458f2948a2c464f5746c7ffc43449a651a2011cd" translate="yes" xml:space="preserve">
          <source>Any VSX register if the</source>
          <target state="translated">任何VSX寄存器,如果</target>
        </trans-unit>
        <trans-unit id="d8389ba5b054471dbefb65e013349dc9adfee3c7" translate="yes" xml:space="preserve">
          <source>Any array can be subscripted, even if not an lvalue.</source>
          <target state="translated">任何数组都可以下标,即使不是一个l值。</target>
        </trans-unit>
        <trans-unit id="14b564784ad63437bf2bebc716f7f298f61a5028" translate="yes" xml:space="preserve">
          <source>Any const_double value.</source>
          <target state="translated">任何const_double值。</target>
        </trans-unit>
        <trans-unit id="1e9dc0d4d4d3fa3953a7b89d1659a04266824dc2" translate="yes" xml:space="preserve">
          <source>Any control register, when they&amp;rsquo;re 16 bits wide (nothing if control registers are 24 bits wide)</source>
          <target state="translated">任何控制寄存器，当它们为16位宽时（如果控制寄存器为24位宽则什么都不是）</target>
        </trans-unit>
        <trans-unit id="dcdd92208f9952a1f355fdf3b7526b8f7a44d2c0" translate="yes" xml:space="preserve">
          <source>Any control register, when they&amp;rsquo;re 24 bits wide.</source>
          <target state="translated">任何控制寄存器，当它们为24位宽时。</target>
        </trans-unit>
        <trans-unit id="7e9a960c7b57410e9d4ca5df2e5f2e42c59f7d8b" translate="yes" xml:space="preserve">
          <source>Any data or pointers to the non-generic address spaces must be qualified as &lt;code&gt;const&lt;/code&gt;, i.e. as read-only data. This still applies if the data in one of these address spaces like software version number or calibration lookup table are intended to be changed after load time by, say, a boot loader. In this case the right qualification is &lt;code&gt;const&lt;/code&gt;&lt;code&gt;volatile&lt;/code&gt; so that the compiler must not optimize away known values or insert them as immediates into operands of instructions.</source>
          <target state="translated">指向非通用地址空间的任何数据或指针都必须被限定为 &lt;code&gt;const&lt;/code&gt; ，即只读数据。如果打算在加载时间之后通过引导加载程序更改这些地址空间之一中的数据（例如软件版本号或校准查找表）中的数据，则该设置仍然适用。在这种情况下，正确的限定是 &lt;code&gt;const&lt;/code&gt; &lt;code&gt;volatile&lt;/code&gt; 因此编译器不得优化已知值或将它们作为立即数插入指令操作数中。</target>
        </trans-unit>
        <trans-unit id="05a587b8fa898666a201d21b98455df1bf047bae" translate="yes" xml:space="preserve">
          <source>Any data with the &lt;code&gt;noinit&lt;/code&gt; attribute will not be initialised by the C runtime startup code, or the program loader. Not initialising data in this way can reduce program startup times.</source>
          <target state="translated">具有 &lt;code&gt;noinit&lt;/code&gt; 属性的任何数据都不会由C运行时启动代码或程序加载器初始化。不以这种方式初始化数据可以减少程序启动时间。</target>
        </trans-unit>
        <trans-unit id="1647cf01ffb6c880e2cc9ddc546cf116110a80e6" translate="yes" xml:space="preserve">
          <source>Any dependence for which the latency is greater than or equal to &lt;var&gt;number&lt;/var&gt; is costly.</source>
          <target state="translated">延迟大于或等于 &lt;var&gt;number&lt;/var&gt; 任何依赖关系成本很高。</target>
        </trans-unit>
        <trans-unit id="54d255d43091079c6ba1e5343929cbd0d4605f04" translate="yes" xml:space="preserve">
          <source>Any dependence from store to load is costly.</source>
          <target state="translated">从门店到负载的任何依赖性都是昂贵的。</target>
        </trans-unit>
        <trans-unit id="32b989b6176274d8479bf98d4817d8a49a56f0e0" translate="yes" xml:space="preserve">
          <source>Any directories specified with</source>
          <target state="translated">任何用</target>
        </trans-unit>
        <trans-unit id="1d356594a5d83b50830291445eb406f59dd05afc" translate="yes" xml:space="preserve">
          <source>Any expression of type &lt;code&gt;void *&lt;/code&gt; is allowed.</source>
          <target state="translated">允许使用任何类型为 &lt;code&gt;void *&lt;/code&gt; 的表达式。</target>
        </trans-unit>
        <trans-unit id="68030c2dfbf4d205419f4c53b98009b37766c0cb" translate="yes" xml:space="preserve">
          <source>Any extended integer types that exist in the implementation (C99 and C11 6.2.5).</source>
          <target state="translated">执行中存在的任何扩展整数类型(C99和C11 6.2.5)。</target>
        </trans-unit>
        <trans-unit id="6f1de0dfba46a4460bfe571dd6ce87a521e49944" translate="yes" xml:space="preserve">
          <source>Any interruptible-without-stack-switch code must be compiled with</source>
          <target state="translated">任何无堆栈开关的可中断代码都必须用以下方法编译</target>
        </trans-unit>
        <trans-unit id="d0a99fee73d1a0400c42d60b6ea95667d276cf8e" translate="yes" xml:space="preserve">
          <source>Any list of specifiers and qualifiers at the start of a declaration may contain attribute specifiers, whether or not such a list may in that context contain storage class specifiers. (Some attributes, however, are essentially in the nature of storage class specifiers, and only make sense where storage class specifiers may be used; for example, &lt;code&gt;section&lt;/code&gt;.) There is one necessary limitation to this syntax: the first old-style parameter declaration in a function definition cannot begin with an attribute specifier, because such an attribute applies to the function instead by syntax described below (which, however, is not yet implemented in this case). In some other cases, attribute specifiers are permitted by this grammar but not yet supported by the compiler. All attribute specifiers in this place relate to the declaration as a whole. In the obsolescent usage where a type of &lt;code&gt;int&lt;/code&gt; is implied by the absence of type specifiers, such a list of specifiers and qualifiers may be an attribute specifier list with no other specifiers or qualifiers.</source>
          <target state="translated">声明开始处的任何说明符和限定符列表都可以包含属性说明符，无论该列表在该上下文中是否可以包含存储类说明符。（但是，某些属性本质上是存储类说明符的性质，并且仅在可以使用存储类说明符的地方有意义；例如， &lt;code&gt;section&lt;/code&gt; 。）对该语法有一个必要的限制：函数定义中的第一个旧式参数声明不能​​以属性说明符开头，因为这样的属性适用于函数，而不是通过下面描述的语法（但是还没有）在这种情况下实施）。在某些其他情况下，该语法允许属性说明符，但编译器尚不支持属性说明符。这个地方的所有属性说明符都与整个声明有关。在由于没有类型说明符而隐含 &lt;code&gt;int&lt;/code&gt; 类型的过时用法中，此类说明符和限定符的列表可能是没有其他说明符或限定符的属性说明符列表。</target>
        </trans-unit>
        <trans-unit id="c6c0071eb01b7f92c396e6d09604df6a2e8de02f" translate="yes" xml:space="preserve">
          <source>Any macros defined before the precompiled header is included must either be defined in the same way as when the precompiled header was generated, or must not affect the precompiled header, which usually means that they don&amp;rsquo;t appear in the precompiled header at all.</source>
          <target state="translated">包含预编译头之前定义的任何宏都必须以与生成预编译头时相同的方式定义，或者必须不影响预编译头，这通常意味着它们根本不会出现在预编译头中。</target>
        </trans-unit>
        <trans-unit id="0b92c247ae43e16cb2206e363e27a0e1ea146660" translate="yes" xml:space="preserve">
          <source>Any memory reference to an address in the far address space.</source>
          <target state="translated">对远地址空间中一个地址的任何内存引用。</target>
        </trans-unit>
        <trans-unit id="e16a334f229304e5f8dc7cc1bd4372e8b13392d9" translate="yes" xml:space="preserve">
          <source>Any memory reference to an address in the near address space.</source>
          <target state="translated">对近地址空间中地址的任何内存引用。</target>
        </trans-unit>
        <trans-unit id="fd3f2043c21601ac2916c25995530fdcaff3e36d" translate="yes" xml:space="preserve">
          <source>Any mode at function entry is valid, and retained or restored when the function returns, and when it calls other functions. This mode is useful for compiling libraries or other compilation units you might want to incorporate into different programs with different prevailing FPU modes, and the convenience of being able to use a single object file outweighs the size and speed overhead for any extra mode switching that might be needed, compared with what would be needed with a more specific choice of prevailing FPU mode.</source>
          <target state="translated">在函数进入时的任何模式都是有效的,并且在函数返回时,以及调用其他函数时保留或恢复。这种模式对于编译库或其他编译单元很有用,你可能想将其纳入到不同的程序中,并采用不同的盛行FPU模式,与更具体的盛行FPU模式选择相比,能够使用单个对象文件的便利性超过了可能需要的任何额外模式切换的大小和速度开销。</target>
        </trans-unit>
        <trans-unit id="22db441873bce8bb93866379f320414a736631d8" translate="yes" xml:space="preserve">
          <source>Any of the SVE predicate registers (&lt;code&gt;P0&lt;/code&gt; to &lt;code&gt;P15&lt;/code&gt;)</source>
          <target state="translated">任何SVE谓词寄存器（ &lt;code&gt;P0&lt;/code&gt; 至 &lt;code&gt;P15&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="adb9f4f59a4cdd5c36fdb71fd2855542ab27a73f" translate="yes" xml:space="preserve">
          <source>Any of the floating point registers (AC0 through AC5).</source>
          <target state="translated">任何一个浮点寄存器(AC0至AC5)。</target>
        </trans-unit>
        <trans-unit id="9b07ecf518f850aa2d367035bbfbe9f027595c80" translate="yes" xml:space="preserve">
          <source>Any operand whatsoever is allowed.</source>
          <target state="translated">任何操作数都是允许的。</target>
        </trans-unit>
        <trans-unit id="f68eb98cf68489e1273e0a62b2ba59241c457e20" translate="yes" xml:space="preserve">
          <source>Any register</source>
          <target state="translated">任何登记册</target>
        </trans-unit>
        <trans-unit id="3553311a1c2384ac5d5327beb00f7dd79264da05" translate="yes" xml:space="preserve">
          <source>Any register accessible as &lt;code&gt;&lt;var&gt;r&lt;/var&gt;h&lt;/code&gt;: &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt;, &lt;code&gt;c&lt;/code&gt;, and &lt;code&gt;d&lt;/code&gt;.</source>
          <target state="translated">任何可作为 &lt;code&gt;&lt;var&gt;r&lt;/var&gt;h&lt;/code&gt; 访问的寄存器： &lt;code&gt;a&lt;/code&gt; ， &lt;code&gt;b&lt;/code&gt; ， &lt;code&gt;c&lt;/code&gt; 和 &lt;code&gt;d&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0809f627bf7826a77322582ca3922a14c79d5ea4" translate="yes" xml:space="preserve">
          <source>Any register accessible as &lt;code&gt;&lt;var&gt;r&lt;/var&gt;l&lt;/code&gt;. In 32-bit mode, &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt;, &lt;code&gt;c&lt;/code&gt;, and &lt;code&gt;d&lt;/code&gt;; in 64-bit mode, any integer register.</source>
          <target state="translated">任何可作为 &lt;code&gt;&lt;var&gt;r&lt;/var&gt;l&lt;/code&gt; 访问的寄存器。在32位模式下， &lt;code&gt;a&lt;/code&gt; ， &lt;code&gt;b&lt;/code&gt; ， &lt;code&gt;c&lt;/code&gt; 和 &lt;code&gt;d&lt;/code&gt; ；在64位模式下，任何整数寄存器。</target>
        </trans-unit>
        <trans-unit id="c586b6a4345439cd7c8437d618d713fde64e21d5" translate="yes" xml:space="preserve">
          <source>Any register except accumulators or CC.</source>
          <target state="translated">除累加器或CC外的任何寄存器。</target>
        </trans-unit>
        <trans-unit id="6f5e5f5ddbf2830c0d8f5e8f65ca789f3fd09903" translate="yes" xml:space="preserve">
          <source>Any register, memory or immediate integer operand is allowed, except for registers that are not general registers.</source>
          <target state="translated">除了不是一般寄存器的寄存器外,任何寄存器、存储器或立即整数操作数都是允许的。</target>
        </trans-unit>
        <trans-unit id="7d047e8a746fffe93cd425189ec60df3684116e7" translate="yes" xml:space="preserve">
          <source>Any variable with the &lt;code&gt;based&lt;/code&gt; attribute is assigned to the &lt;code&gt;.based&lt;/code&gt; section, and is accessed with relative to the &lt;code&gt;$tp&lt;/code&gt; register.</source>
          <target state="translated">与任何变量 &lt;code&gt;based&lt;/code&gt; 属性分配给 &lt;code&gt;.based&lt;/code&gt; 截面，并且相对于所访问的 &lt;code&gt;$tp&lt;/code&gt; 寄存器。</target>
        </trans-unit>
        <trans-unit id="8e967d4316910c49c908407ba08671d2b2599c34" translate="yes" xml:space="preserve">
          <source>Any variable with the &lt;code&gt;persistent&lt;/code&gt; attribute will not be initialised by the C runtime startup code. Instead its value will be set once, when the application is loaded, and then never initialised again, even if the processor is reset or the program restarts. Persistent data is intended to be placed into FLASH RAM, where its value will be retained across resets. The linker script being used to create the application should ensure that persistent data is correctly placed.</source>
          <target state="translated">具有 &lt;code&gt;persistent&lt;/code&gt; 属性的任何变量都不会由C运行时启动代码初始化。取而代之的是，它的值将在加载应用程序时设置一次，然后再也不会初始化，即使处理器已重置或程序重新启动也是如此。永久性数据应放入闪存RAM中，在复位后将保留其值。用于创建应用程序的链接描述文件应确保正确放置了持久数据。</target>
        </trans-unit>
        <trans-unit id="6814c1eba0c0bb145d77465185a812135711db30" translate="yes" xml:space="preserve">
          <source>Append &lt;var&gt;dir&lt;/var&gt; to the prefix specified previously with</source>
          <target state="translated">将 &lt;var&gt;dir&lt;/var&gt; 附加到先前指定的前缀</target>
        </trans-unit>
        <trans-unit id="812a14ffbe77d828291132cdec93d807373c47c5" translate="yes" xml:space="preserve">
          <source>Application register residing in I-unit</source>
          <target state="translated">居住在I单元的申请登记册</target>
        </trans-unit>
        <trans-unit id="1236d15ff73551e90456786e45b32e0be147101a" translate="yes" xml:space="preserve">
          <source>Application register residing in M-unit</source>
          <target state="translated">居住在M单元的申请登记册</target>
        </trans-unit>
        <trans-unit id="157c651a499c80b5c8fd2d703d99af67d3154b57" translate="yes" xml:space="preserve">
          <source>Apply partitioned execution optimizations. This is the default when any level of optimization is selected.</source>
          <target state="translated">应用分区执行优化。当选择任何级别的优化时,这是默认的。</target>
        </trans-unit>
        <trans-unit id="1782ef9fd22ce5aa8daf22e12703623a7b69b3eb" translate="yes" xml:space="preserve">
          <source>Apply the &lt;code&gt;longcall&lt;/code&gt; attribute to all subsequent function declarations.</source>
          <target state="translated">将 &lt;code&gt;longcall&lt;/code&gt; 属性应用于所有后续函数声明。</target>
        </trans-unit>
        <trans-unit id="282eae08ca98891b7edf1b6d8797fd6b87a9eaef" translate="yes" xml:space="preserve">
          <source>Apply unroll and jam transformations on feasible loops. In a loop nest this unrolls the outer loop by some factor and fuses the resulting multiple inner loops. This flag is enabled by default at</source>
          <target state="translated">在可行的循环上应用展开和卡位变换。在一个循环嵌套中,这将外循环按一定的系数展开,并将产生的多个内循环融合。这个标志默认在</target>
        </trans-unit>
        <trans-unit id="5180e6ec8c8c3a9e7de475a7424e90e67f44108f" translate="yes" xml:space="preserve">
          <source>Arguments of type &lt;code&gt;uh&lt;/code&gt;, &lt;code&gt;uw1&lt;/code&gt;, &lt;code&gt;sw1&lt;/code&gt;, &lt;code&gt;uw2&lt;/code&gt; and &lt;code&gt;sw2&lt;/code&gt; are evaluated at run time. They correspond to register operands in the underlying FR-V instructions.</source>
          <target state="translated">在运行时评估类型 &lt;code&gt;uh&lt;/code&gt; ， &lt;code&gt;uw1&lt;/code&gt; ， &lt;code&gt;sw1&lt;/code&gt; ， &lt;code&gt;uw2&lt;/code&gt; 和 &lt;code&gt;sw2&lt;/code&gt; 的参数。它们对应于基础FR-V指令中的寄存器操作数。</target>
        </trans-unit>
        <trans-unit id="27b636e6a8cfc32ea746d5e97119c5c9f0abb374" translate="yes" xml:space="preserve">
          <source>Arguments that are documented as &lt;code&gt;const int&lt;/code&gt; require literal integral values within the range required for that operation.</source>
          <target state="translated">记录为 &lt;code&gt;const int&lt;/code&gt; 的参数需要该操作所需范围内的文字整数值。</target>
        </trans-unit>
        <trans-unit id="56dc33ad93362bc115e17a1a1f9e847be1eea766" translate="yes" xml:space="preserve">
          <source>Arithmetic on &lt;code&gt;void&lt;/code&gt;-pointers and function pointers.</source>
          <target state="translated">&lt;code&gt;void&lt;/code&gt; 指针和函数指针的算术运算。</target>
        </trans-unit>
        <trans-unit id="b47ecbfd9e2fe292a564bf4865f526df3c8781c7" translate="yes" xml:space="preserve">
          <source>Arrays whose length is computed at run time.</source>
          <target state="translated">数组的长度是在运行时计算的。</target>
        </trans-unit>
        <trans-unit id="62bbe9126770d1f883012b542af60463a81fc16c" translate="yes" xml:space="preserve">
          <source>As a GNU extension, GCC allows initialization of objects with static storage duration by compound literals (which is not possible in ISO C99 because the initializer is not a constant). It is handled as if the object were initialized only with the brace-enclosed list if the types of the compound literal and the object match. The elements of the compound literal must be constant. If the object being initialized has array type of unknown size, the size is determined by the size of the compound literal.</source>
          <target state="translated">作为GNU的扩展,GCC允许通过复合字元初始化具有静态存储持续时间的对象(这在ISO C99中是不可能的,因为初始化器不是一个常量)。如果复合文字的类型和对象的类型相匹配,它的处理方式就像只用括号封闭的列表初始化对象一样。复合文字的元素必须是常数。如果被初始化的对象具有未知大小的数组类型,其大小由复合文字的大小决定。</target>
        </trans-unit>
        <trans-unit id="f0b14342b73dd91f2d28adcdc3851266c0e2adc9" translate="yes" xml:space="preserve">
          <source>As a part of ACLE, GCC implements extensions for Advanced SIMD as described in the ARM C Language Extensions Specification. The complete list of Advanced SIMD intrinsics can be found at &lt;a href=&quot;http://infocenter.arm.com/help/topic/com.arm.doc.ihi0073a/IHI0073A_arm_neon_intrinsics_ref.pdf&quot;&gt;http://infocenter.arm.com/help/topic/com.arm.doc.ihi0073a/IHI0073A_arm_neon_intrinsics_ref.pdf&lt;/a&gt;. The built-in intrinsics for the Advanced SIMD extension are available when NEON is enabled.</source>
          <target state="translated">作为ACLE的一部分，GCC实现了ARM C语言扩展规范中描述的Advanced SIMD扩展。可以在&lt;a href=&quot;http://infocenter.arm.com/help/topic/com.arm.doc.ihi0073a/IHI0073A_arm_neon_intrinsics_ref.pdf&quot;&gt;http://infocenter.arm.com/help/topic/com.arm.doc.ihi0073a/IHI0073A_arm_neon_intrinsics_ref.pdf&lt;/a&gt;上找到Advanced SIMD内部函数的完整列表。启用NEON时，可以使用Advanced SIMD扩展的内置内在函数。</target>
        </trans-unit>
        <trans-unit id="3bf025a6b55c5b2b4d36feb2983875ada48832c0" translate="yes" xml:space="preserve">
          <source>As a result, if a function compiled with Sun CC takes the address of an argument of type &lt;code&gt;double&lt;/code&gt; and passes this pointer of type &lt;code&gt;double *&lt;/code&gt; to a function compiled with GCC, dereferencing the pointer may cause a fatal signal.</source>
          <target state="translated">结果，如果使用Sun CC编译的函数采用 &lt;code&gt;double&lt;/code&gt; 精度类型的参数的地址，并将该类型为 &lt;code&gt;double *&lt;/code&gt; 的指针传递给使用GCC编译的函数，则取消引用该指针可能会导致致命信号。</target>
        </trans-unit>
        <trans-unit id="70fe12b60268d72ed32d2dad542457f63b7450a6" translate="yes" xml:space="preserve">
          <source>As a result, when a file is compiled with the</source>
          <target state="translated">因此,当一个文件用</target>
        </trans-unit>
        <trans-unit id="de76cec1a0ee40014e9d6de2336c465c8c2b9403" translate="yes" xml:space="preserve">
          <source>As a special kludge, if the path provided by</source>
          <target state="translated">作为一个特殊的小工具,如果路径由</target>
        </trans-unit>
        <trans-unit id="b70ccdaa2f1d44ed8f039d89a64ebf9722e0436b" translate="yes" xml:space="preserve">
          <source>As an alternative to providing a spec string, the text following a suffix directive can be one of the following:</source>
          <target state="translated">作为提供规格字符串的替代方法,后缀指令后面的文本可以是以下内容之一。</target>
        </trans-unit>
        <trans-unit id="dddf73cd98dcce7c884fe24956533693e61e8e3f" translate="yes" xml:space="preserve">
          <source>As an example:</source>
          <target state="translated">举个例子:</target>
        </trans-unit>
        <trans-unit id="733120310e3f16a7d9b6ceb479247f71058a2dab" translate="yes" xml:space="preserve">
          <source>As an extension the integer scalar type &lt;code&gt;__int128&lt;/code&gt; is supported for targets which have an integer mode wide enough to hold 128 bits. Simply write &lt;code&gt;__int128&lt;/code&gt; for a signed 128-bit integer, or &lt;code&gt;unsigned __int128&lt;/code&gt; for an unsigned 128-bit integer. There is no support in GCC for expressing an integer constant of type &lt;code&gt;__int128&lt;/code&gt; for targets with &lt;code&gt;long long&lt;/code&gt; integer less than 128 bits wide.</source>
          <target state="translated">作为扩展，整数标量类型 &lt;code&gt;__int128&lt;/code&gt; 支持具有整数模式且宽度足以容纳128位的目标。只需为有符号的128位整数写 &lt;code&gt;__int128&lt;/code&gt; ，或为无符号的128位整数写 &lt;code&gt;unsigned __int128&lt;/code&gt; 。GCC不支持为 &lt;code&gt;long long&lt;/code&gt; 小于128位宽的长整数的目标表示类型为 &lt;code&gt;__int128&lt;/code&gt; 的整数常量。</target>
        </trans-unit>
        <trans-unit id="a3f87270bea18e65d71a654a8f0baf39b38c480a" translate="yes" xml:space="preserve">
          <source>As an extension to the C language, GCC does not use the latitude given in C99 and C11 only to treat certain aspects of signed &amp;lsquo;</source>
          <target state="translated">作为对C语言的扩展，GCC不仅使用C99和C11中给出的纬度来对待带符号的&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="4513679ee7e9cc2a019ac56fe5e24f303a414ac9" translate="yes" xml:space="preserve">
          <source>As an extension, GCC accepts variable-length arrays as a member of a structure or a union. For example:</source>
          <target state="translated">作为一种扩展,GCC接受可变长度的数组作为结构体或联合体的成员。例如:&quot;GCC接受可变长度的数组作为结构或联合体的成员。</target>
        </trans-unit>
        <trans-unit id="27e4f48620a93a562285a400297cd393c63d1803" translate="yes" xml:space="preserve">
          <source>As an extension, GNU C and GNU C++ support additional floating types, which are not supported by all targets.</source>
          <target state="translated">作为扩展,GNU C和GNU C++支持额外的浮动类型,但并非所有目标都支持。</target>
        </trans-unit>
        <trans-unit id="697b66e118a429cde99672cf767b29bbf7517cb2" translate="yes" xml:space="preserve">
          <source>As an extension, GNU C supports decimal floating types as defined in the N1312 draft of ISO/IEC WDTR24732. Support for decimal floating types in GCC will evolve as the draft technical report changes. Calling conventions for any target might also change. Not all targets support decimal floating types.</source>
          <target state="translated">作为扩展,GNU C支持ISO/IEC WDTR24732的N1312草案中定义的十进制浮动类型。GCC中对十进制浮动类型的支持将随着技术报告草案的变化而变化。任何目标的调用约定也可能会改变。并非所有目标都支持十进制浮动类型。</target>
        </trans-unit>
        <trans-unit id="1e14a45ce2c917a5c2a3b3b95aa86553c2d0d4a7" translate="yes" xml:space="preserve">
          <source>As an extension, GNU C supports fixed-point types as defined in the N1169 draft of ISO/IEC DTR 18037. Support for fixed-point types in GCC will evolve as the draft technical report changes. Calling conventions for any target might also change. Not all targets support fixed-point types.</source>
          <target state="translated">作为扩展,GNU C支持ISO/IEC DTR 18037的N1169草案中定义的定点类型。GCC对定点类型的支持将随着技术报告草案的变化而变化。任何目标的调用惯例也可能发生变化。并非所有目标都支持定点类型。</target>
        </trans-unit>
        <trans-unit id="7086d776842151d1d2c42c2e5523eaf5840573e5" translate="yes" xml:space="preserve">
          <source>As an extension, GNU C supports named address spaces as defined in the N1275 draft of ISO/IEC DTR 18037. Support for named address spaces in GCC will evolve as the draft technical report changes. Calling conventions for any target might also change. At present, only the AVR, SPU, M32C, RL78, and x86 targets support address spaces other than the generic address space.</source>
          <target state="translated">作为扩展,GNU C支持ISO/IEC DTR 18037的N1275草案中定义的命名地址空间。GCC中对命名地址空间的支持将随着技术报告草案的变化而变化。任何目标的调用约定也可能会改变。目前,只有AVR、SPU、M32C、RL78和x86目标支持通用地址空间以外的地址空间。</target>
        </trans-unit>
        <trans-unit id="adca7822f575134857a5ee57f78ae4fe66d4c44f" translate="yes" xml:space="preserve">
          <source>As an optimization, G++ sometimes gives array compound literals longer lifetimes: when the array either appears outside a function or has a &lt;code&gt;const&lt;/code&gt;-qualified type. If &lt;code&gt;foo&lt;/code&gt; and its initializer had elements of type &lt;code&gt;char *const&lt;/code&gt; rather than &lt;code&gt;char *&lt;/code&gt;, or if &lt;code&gt;foo&lt;/code&gt; were a global variable, the array would have static storage duration. But it is probably safest just to avoid the use of array compound literals in C++ code.</source>
          <target state="translated">作为一种优化，G ++有时使数组复合文字的寿命更长：当数组出现在函数外部或具有 &lt;code&gt;const&lt;/code&gt; 限定类型时。如果 &lt;code&gt;foo&lt;/code&gt; 及其初始值设定项的元素类型为 &lt;code&gt;char *const&lt;/code&gt; 而不是 &lt;code&gt;char *&lt;/code&gt; ，或者如果 &lt;code&gt;foo&lt;/code&gt; 是全局变量，则数组将具有静态存储持续时间。但是，仅避免在C ++代码中使用数组复合文字可能是最安全的。</target>
        </trans-unit>
        <trans-unit id="4440512ea926e0e3e9623211be65c0fe001b769e" translate="yes" xml:space="preserve">
          <source>As another example,</source>
          <target state="translated">再举个例子:</target>
        </trans-unit>
        <trans-unit id="c2d7d2d398b725a8ff7f6339f33b58fb71e37c73" translate="yes" xml:space="preserve">
          <source>As another example, the following call to &lt;code&gt;strncpy&lt;/code&gt; results in copying to &lt;code&gt;d&lt;/code&gt; just the characters preceding the terminating NUL, without appending the NUL to the end. Assuming the result of &lt;code&gt;strncpy&lt;/code&gt; is necessarily a NUL-terminated string is a common mistake, and so the call is diagnosed. To avoid the warning when the result is not expected to be NUL-terminated, call &lt;code&gt;memcpy&lt;/code&gt; instead.</source>
          <target state="translated">作为另一个示例，对 &lt;code&gt;strncpy&lt;/code&gt; 的以下调用导致仅将终止NUL之前的字符复制到 &lt;code&gt;d&lt;/code&gt; ，而没有将NUL附加到末尾。假定 &lt;code&gt;strncpy&lt;/code&gt; 的结果必然是NUL终止的字符串是一个常见错误，因此可以对调用进行诊断。为了避免在预期结果不会被NUL终止时发出警告，请改为调用 &lt;code&gt;memcpy&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f22e08722bb8e7ce646a0894d86b714e1a18ddc2" translate="yes" xml:space="preserve">
          <source>As bit-fields are not individually addressable, volatile bit-fields may be implicitly read when written to, or when adjacent bit-fields are accessed. Bit-field operations may be optimized such that adjacent bit-fields are only partially accessed, if they straddle a storage unit boundary. For these reasons it is unwise to use volatile bit-fields to access hardware.</source>
          <target state="translated">由于位字段不是单独可寻址的,所以当写入或访问相邻位字段时,易失性位字段可能被隐式读取。比特字段的操作可能会被优化,如果相邻的比特字段跨越了存储单元的边界,那么它们只能被部分访问。由于这些原因,使用易失性位场来访问硬件是不明智的。</target>
        </trans-unit>
        <trans-unit id="54cb09a605966e1ec9e0e0780e8355b83cacd9f7" translate="yes" xml:space="preserve">
          <source>As discussed in &lt;a href=&quot;common-function-attributes#Common-Function-Attributes&quot;&gt;Common Function Attributes&lt;/a&gt;, this attribute allows specification of target-specific compilation options.</source>
          <target state="translated">如&amp;ldquo; &lt;a href=&quot;common-function-attributes#Common-Function-Attributes&quot;&gt;公共功能属性&amp;rdquo;中所述&lt;/a&gt;，此属性允许指定特定于目标的编译选项。</target>
        </trans-unit>
        <trans-unit id="c47f4f2d2c816a9b7574ec5c08de30912daa2a80" translate="yes" xml:space="preserve">
          <source>As for &amp;lsquo;</source>
          <target state="translated">至于&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="71478357402c28a54c8c6fca58d451aad7e53ab5" translate="yes" xml:space="preserve">
          <source>As in standard C++ and ISO C99, the elements of an aggregate initializer for an automatic variable are not required to be constant expressions in GNU C. Here is an example of an initializer with run-time varying elements:</source>
          <target state="translated">如同在标准C++和ISO C99中一样,在GNU C中,一个自动变量的聚合初始化器的元素不需要是常量表达式,下面是一个运行时元素变化的初始化器的例子。</target>
        </trans-unit>
        <trans-unit id="e19fab7ccaf71008439ad46e66a6dd8a8249abc0" translate="yes" xml:space="preserve">
          <source>As in the preceding example, you can explicitly specify the alignment (in bytes) that you wish the compiler to use for a given &lt;code&gt;struct&lt;/code&gt; or &lt;code&gt;union&lt;/code&gt; type. Alternatively, you can leave out the alignment factor and just ask the compiler to align a type to the maximum useful alignment for the target machine you are compiling for. For example, you could write:</source>
          <target state="translated">如上例所示，您可以显式指定希望编译器用于给定 &lt;code&gt;struct&lt;/code&gt; 或 &lt;code&gt;union&lt;/code&gt; 类型的对齐方式（以字节为单位）。另外，您可以忽略对齐因子，而只是要求编译器将类型与要编译的目标计算机的最大有用对齐方式对齐。例如，您可以编写：</target>
        </trans-unit>
        <trans-unit id="b67040c22389d40183c4661602eeb071108d65a1" translate="yes" xml:space="preserve">
          <source>As in the preceding examples, you can explicitly specify the alignment (in bytes) that you wish the compiler to use for a given variable or structure field. Alternatively, you can leave out the alignment factor and just ask the compiler to align a variable or field to the default alignment for the target architecture you are compiling for. The default alignment is sufficient for all scalar types, but may not be enough for all vector types on a target that supports vector operations. The default alignment is fixed for a particular target ABI.</source>
          <target state="translated">和前面的例子一样,你可以明确地指定你希望编译器对一个给定的变量或结构字段使用的对齐方式(以字节为单位)。或者,你也可以不使用对齐因子,只要求编译器将一个变量或字段对齐到你正在编译的目标架构的默认对齐方式。默认对齐对于所有标量类型来说是足够的,但对于支持向量操作的目标上的所有向量类型来说可能是不够的。默认对齐方式对于特定的目标ABI来说是固定的。</target>
        </trans-unit>
        <trans-unit id="4953117cca7e33df31955c24738168de010b1a14" translate="yes" xml:space="preserve">
          <source>As long as the stack frame backchain is not used, code generated with</source>
          <target state="translated">只要不使用堆栈框架回链,用</target>
        </trans-unit>
        <trans-unit id="55612a0f57841c9314e7eae808cb715df500b680" translate="yes" xml:space="preserve">
          <source>As mentioned above, the new exceptions do not support handling types other than Objective-C objects. Furthermore, when used from Objective-C++, the Objective-C exception model does not interoperate with C++ exceptions at this time. This means you cannot &lt;code&gt;@throw&lt;/code&gt; an exception from Objective-C and &lt;code&gt;catch&lt;/code&gt; it in C++, or vice versa (i.e., &lt;code&gt;throw &amp;hellip; @catch&lt;/code&gt;).</source>
          <target state="translated">如上所述，新的异常不支持除Objective-C对象之外的其他处理类型。此外，从Objective-C ++使用时，Objective-C异常模型目前无法与C ++异常互操作。这意味着您不能 &lt;code&gt;@throw&lt;/code&gt; 从Objective-C抛出异常并用C ++ &lt;code&gt;catch&lt;/code&gt; 它，反之亦然（即， &lt;code&gt;throw &amp;hellip; @catch&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="294a250033394e9398ee357e8a3028f8f81f0fc0" translate="yes" xml:space="preserve">
          <source>As new Intel processors are deployed in the marketplace, the behavior of this option will change. Therefore, if you upgrade to a newer version of GCC, code generation controlled by this option will change to reflect the most current Intel processors at the time that version of GCC is released.</source>
          <target state="translated">随着市场上新的英特尔处理器的部署,这个选项的行为将发生变化。因此,如果您升级到较新版本的GCC,由该选项控制的代码生成将改变,以反映该版本GCC发布时最新的Intel处理器。</target>
        </trans-unit>
        <trans-unit id="071c1df1bb91e5145c672769a3ad43fada5e0f32" translate="yes" xml:space="preserve">
          <source>As new processors are deployed in the marketplace, the behavior of this option will change. Therefore, if you upgrade to a newer version of GCC, code generation controlled by this option will change to reflect the processors that are most common at the time that version of GCC is released.</source>
          <target state="translated">随着市场上新处理器的部署,这个选项的行为会发生变化。因此,如果您升级到较新的GCC版本,由该选项控制的代码生成将改变,以反映该版本GCC发布时最常见的处理器。</target>
        </trans-unit>
        <trans-unit id="3744f46b0905194e3e22c08ee725283caaeed6c9" translate="yes" xml:space="preserve">
          <source>As of the GCC 4.7.1 release, GCC supports the Go 1 language standard, described at &lt;a href=&quot;https://golang.org/doc/go1&quot;&gt;https://golang.org/doc/go1&lt;/a&gt;.</source>
          <target state="translated">从GCC 4.7.1版本开始，GCC支持Go 1语言标准，如&lt;a href=&quot;https://golang.org/doc/go1&quot;&gt;https://golang.org/doc/go1所述&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e64c1bee27f99a750cc73752558d5aa035a91d3b" translate="yes" xml:space="preserve">
          <source>As of this writing, only the NeXT runtime on Mac OS X 10.4 and later has support for invoking the &lt;code&gt;- (id) .cxx_construct&lt;/code&gt; and &lt;code&gt;- (void) .cxx_destruct&lt;/code&gt; methods.</source>
          <target state="translated">在撰写本文时，仅Mac OS X 10.4及更高版本上的NeXT运行时支持调用 &lt;code&gt;- (id) .cxx_construct&lt;/code&gt; 和 &lt;code&gt;- (void) .cxx_destruct&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="190838497fcc16bfeb19ed9bf8cb7b33b5859658" translate="yes" xml:space="preserve">
          <source>As of this writing, there are no SPARC implementations that have hardware support for the quad-word floating-point instructions. They all invoke a trap handler for one of these instructions, and then the trap handler emulates the effect of the instruction. Because of the trap handler overhead, this is much slower than calling the ABI library routines. Thus the</source>
          <target state="translated">截至本报告撰写时,还没有任何SPARC实现对四字浮点指令的硬件支持。它们都是为其中一条指令调用一个陷阱处理程序,然后由陷阱处理程序模拟指令的效果。由于陷阱处理程序的开销,这比调用ABI库的例程要慢得多。因此</target>
        </trans-unit>
        <trans-unit id="ea115f65d5a89a6a0ce102bba12e75c8b98c940e" translate="yes" xml:space="preserve">
          <source>As part of the Security Extensions GCC implements the intrinsics below. FPTR is used here to mean any function pointer type.</source>
          <target state="translated">作为安全扩展的一部分,GCC实现了下面的本征。FPTR在这里是指任何函数指针类型。</target>
        </trans-unit>
        <trans-unit id="44e4fff7ccbcdce5ca766f79d5a621ec9dbe0d23" translate="yes" xml:space="preserve">
          <source>As part of the Security Extensions GCC implements two new function attributes: &lt;code&gt;cmse_nonsecure_entry&lt;/code&gt; and &lt;code&gt;cmse_nonsecure_call&lt;/code&gt;.</source>
          <target state="translated">作为安全性扩展的一部分，GCC实现了两个新的函数属性： &lt;code&gt;cmse_nonsecure_entry&lt;/code&gt; 和 &lt;code&gt;cmse_nonsecure_call&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dc6f3f1d276c90c5e06c8b6bf28158a5a889bccd" translate="yes" xml:space="preserve">
          <source>As permitted by ISO C11 and for compatibility with other compilers, GCC allows you to define a structure or union that contains, as fields, structures and unions without names. For example:</source>
          <target state="translated">在ISO C11的允许下,为了与其他编译器兼容,GCC允许你定义一个结构或联合体,它包含了字段、结构和无名联合体。例如:</target>
        </trans-unit>
        <trans-unit id="cd38e2252e3cfbc1562a66af3fc83a7b3476b926" translate="yes" xml:space="preserve">
          <source>As required by ISO C++, GCC considers member functions defined within the body of a class to be marked inline even if they are not explicitly declared with the &lt;code&gt;inline&lt;/code&gt; keyword. You can override this with</source>
          <target state="translated">根据ISO C ++的要求，即使未使用 &lt;code&gt;inline&lt;/code&gt; 关键字明确声明，GCC仍将在类主体内定义的成员函数标记为内联。您可以使用</target>
        </trans-unit>
        <trans-unit id="ee86d176185420b2cd516cd28e0d2c038499f36a" translate="yes" xml:space="preserve">
          <source>As with all outermost parameter qualifiers, &lt;code&gt;__restrict__&lt;/code&gt; is ignored in function definition matching. This means you only need to specify &lt;code&gt;__restrict__&lt;/code&gt; in a function definition, rather than in a function prototype as well.</source>
          <target state="translated">与所有最外面的参数限定符一样， &lt;code&gt;__restrict__&lt;/code&gt; 在函数定义匹配中被忽略。这意味着您只需要在函数定义中指定 &lt;code&gt;__restrict__&lt;/code&gt; ，而无需在函数原型中指定。</target>
        </trans-unit>
        <trans-unit id="ba3fbd93824241c0022727ea0aaa70098dbf8058" translate="yes" xml:space="preserve">
          <source>As with global register variables, it is recommended that you choose a register that is normally saved and restored by function calls on your machine, so that calls to library routines will not clobber it.</source>
          <target state="translated">与全局寄存器变量一样,建议选择一个通常由机器上的函数调用来保存和恢复的寄存器,这样对库例程的调用就不会破坏它。</target>
        </trans-unit>
        <trans-unit id="9d9e595b377650b7d530b408f01a2295e9aa3eb5" translate="yes" xml:space="preserve">
          <source>As with the C front end, G++ understands the C99 feature of restricted pointers, specified with the &lt;code&gt;__restrict__&lt;/code&gt;, or &lt;code&gt;__restrict&lt;/code&gt; type qualifier. Because you cannot compile C++ by specifying the</source>
          <target state="translated">与C前端一样，G ++理解使用 &lt;code&gt;__restrict__&lt;/code&gt; 或 &lt;code&gt;__restrict&lt;/code&gt; 类型限定符指定的受限指针的C99功能。因为您不能通过指定C来编译C ++</target>
        </trans-unit>
        <trans-unit id="21e7da79fc603087dc1baeac067752aa75dc3fe9" translate="yes" xml:space="preserve">
          <source>Assembler Options</source>
          <target state="translated">汇编器选项</target>
        </trans-unit>
        <trans-unit id="bcf5f12f4332ce70ca2c9b5133dda1d57f7cdf19" translate="yes" xml:space="preserve">
          <source>Assembler code that must be preprocessed.</source>
          <target state="translated">必须进行预处理的汇编程序代码。</target>
        </trans-unit>
        <trans-unit id="f9cab59729ce9a72e9592405aff1f8fcf01f46db" translate="yes" xml:space="preserve">
          <source>Assembler code.</source>
          <target state="translated">组装代码。</target>
        </trans-unit>
        <trans-unit id="32b8b4178e9d441788dbf96199839a839961313d" translate="yes" xml:space="preserve">
          <source>Assembler names for data:</source>
          <target state="translated">数据的汇编者名称。</target>
        </trans-unit>
        <trans-unit id="a60468da111a0ab238610d89ab550d7cb3db7634" translate="yes" xml:space="preserve">
          <source>Assembler names for functions:</source>
          <target state="translated">函数的汇编者名称。</target>
        </trans-unit>
        <trans-unit id="c09492c8b5916e81a92681e73286dd4d053d0d64" translate="yes" xml:space="preserve">
          <source>Assembly output</source>
          <target state="translated">组装输出</target>
        </trans-unit>
        <trans-unit id="c20d25392b6fcd428956d9fadf904cf6f25c34c2" translate="yes" xml:space="preserve">
          <source>Assert that compilation targets a freestanding environment. This implies</source>
          <target state="translated">断言编译的目标是一个独立的环境。这意味着</target>
        </trans-unit>
        <trans-unit id="d5b5344f90d89057b5b4c1d64f39bf480cc87ed4" translate="yes" xml:space="preserve">
          <source>Assert that compilation targets a hosted environment. This implies</source>
          <target state="translated">断言编译的目标是托管环境。这意味着</target>
        </trans-unit>
        <trans-unit id="3d6a91afbb703874ed1adcc1fc07fbc355255566" translate="yes" xml:space="preserve">
          <source>Assignments are also expressions and have an rvalue. However when assigning to a scalar volatile, the volatile object is not reread, regardless of whether the assignment expression&amp;rsquo;s rvalue is used or not. If the assignment&amp;rsquo;s rvalue is used, the value is that assigned to the volatile object. For instance, there is no read of &lt;var&gt;vobj&lt;/var&gt; in all the following cases:</source>
          <target state="translated">赋值也是表达式，具有右值。但是，在分配给标量volatile时，无论是否使用赋值表达式的rvalue，都不会重新读取volatile对象。如果使用分配的右值，则该值为分配给易失对象的值。例如，在以下所有情况下，都不会读取 &lt;var&gt;vobj&lt;/var&gt; ：</target>
        </trans-unit>
        <trans-unit id="0c40f851ca2e4b0159b069f87df3cdf0c325569f" translate="yes" xml:space="preserve">
          <source>Assume (do not assume) that all symbols have 32-bit values, regardless of the selected ABI. This option is useful in combination with</source>
          <target state="translated">假定(不要假定)所有符号都具有32位值,无论所选ABI如何。此选项与</target>
        </trans-unit>
        <trans-unit id="29f90ada4a3fec867ca24dbc5026596c24d16fc4" translate="yes" xml:space="preserve">
          <source>Assume (do not assume) that externally-defined data is in a small data section if the size of that data is within the</source>
          <target state="translated">假设(不要假设)外部定义的数据是在一个小数据部分,如果该数据的大小在</target>
        </trans-unit>
        <trans-unit id="2cfe16d43985ee39e482829ca4a8dfdcb2d636f4" translate="yes" xml:space="preserve">
          <source>Assume (do not assume) that the reciprocal estimate instructions provide higher-precision estimates than is mandated by the PowerPC ABI.</source>
          <target state="translated">假设(不要假设)往复估算指令提供的估算精度高于PowerPC ABI规定的精度。</target>
        </trans-unit>
        <trans-unit id="ec6f2df5d90d0e07067a08f77629a109a7baeb7c" translate="yes" xml:space="preserve">
          <source>Assume (do not assume) that the reciprocal estimate instructions provide higher-precision estimates than is mandated by the PowerPC ABI. Selecting</source>
          <target state="translated">假设(不要假设)往复估计指令提供的估计精度高于PowerPC ABI规定的精度。选择</target>
        </trans-unit>
        <trans-unit id="813b5f0f913426f167f43f6e9f2605b43322e0d6" translate="yes" xml:space="preserve">
          <source>Assume (do not assume) that the static and dynamic linkers support PLTs and copy relocations. This option only affects</source>
          <target state="translated">假设(不要假设)静态和动态链接器支持PLT和复制重定位。这个选项只影响</target>
        </trans-unit>
        <trans-unit id="6218242555601cfde6dcb1f0fb4410c65b0c0afe" translate="yes" xml:space="preserve">
          <source>Assume (do not assume) that zero displacement conditional branch instructions &lt;code&gt;bt&lt;/code&gt; and &lt;code&gt;bf&lt;/code&gt; are fast. If</source>
          <target state="translated">假设（不假设）零位移条件分支指令 &lt;code&gt;bt&lt;/code&gt; 和 &lt;code&gt;bf&lt;/code&gt; 很快。如果</target>
        </trans-unit>
        <trans-unit id="4d87b438e6a49fee40ee2b8e75d048b2cb33a8d4" translate="yes" xml:space="preserve">
          <source>Assume &lt;code&gt;int&lt;/code&gt; to be 8-bit integer. This affects the sizes of all types: a &lt;code&gt;char&lt;/code&gt; is 1 byte, an &lt;code&gt;int&lt;/code&gt; is 1 byte, a &lt;code&gt;long&lt;/code&gt; is 2 bytes, and &lt;code&gt;long long&lt;/code&gt; is 4 bytes. Please note that this option does not conform to the C standards, but it results in smaller code size.</source>
          <target state="translated">假设 &lt;code&gt;int&lt;/code&gt; 为8位整数。这会影响所有类型的大小： &lt;code&gt;char&lt;/code&gt; 是1个字节， &lt;code&gt;int&lt;/code&gt; 是1个字节， &lt;code&gt;long&lt;/code&gt; 是2个字节， &lt;code&gt;long long&lt;/code&gt; 是4个字节。请注意，此选项不符合C标准，但会导致代码较小。</target>
        </trans-unit>
        <trans-unit id="5c2bc85ec675432aace4d6922b50129cffa86b60" translate="yes" xml:space="preserve">
          <source>Assume &lt;var&gt;num&lt;/var&gt; to be the cost for a branch instruction. Higher numbers make the compiler try to generate more branch-free code if possible. If not specified the value is selected depending on the processor type that is being compiled for.</source>
          <target state="translated">假设 &lt;var&gt;num&lt;/var&gt; 是分支指令的成本。较大的数字使编译器在可能的情况下尝试生成更多的无分支代码。如果未指定，则根据要为其编译的处理器类型选择该值。</target>
        </trans-unit>
        <trans-unit id="a18b03a98d3895d8de33097ebfdc73e386381f27" translate="yes" xml:space="preserve">
          <source>Assume a large TLS segment when generating thread-local code.</source>
          <target state="translated">生成线程本地代码时,假设TLS段很大。</target>
        </trans-unit>
        <trans-unit id="dcc9240dada623776592057c6e5b8a92da4c9b4e" translate="yes" xml:space="preserve">
          <source>Assume addresses can be loaded as 16-bit unsigned values. This does not apply to function addresses for which</source>
          <target state="translated">假设地址可以加载为16位无符号值。这不适用于以下情况的函数地址</target>
        </trans-unit>
        <trans-unit id="fb31614e67999bd6734c6361178e2cdabb52e555" translate="yes" xml:space="preserve">
          <source>Assume all objects live in the lower 16MB of memory (so that their addresses can be loaded with the &lt;code&gt;ld24&lt;/code&gt; instruction), and assume all subroutines are reachable with the &lt;code&gt;bl&lt;/code&gt; instruction. This is the default.</source>
          <target state="translated">假定所有对象都位于较低的16MB内存中（以便可以通过 &lt;code&gt;ld24&lt;/code&gt; 指令加载其地址），并假定所有子例程都可以通过 &lt;code&gt;bl&lt;/code&gt; 指令访问。这是默认值。</target>
        </trans-unit>
        <trans-unit id="c507ae5c9607f036356273bef8470c3d07a51113" translate="yes" xml:space="preserve">
          <source>Assume inline assembler is using unified asm syntax. The default is currently off which implies divided syntax. This option has no impact on Thumb2. However, this may change in future releases of GCC. Divided syntax should be considered deprecated.</source>
          <target state="translated">假设内联汇编器使用统一的asm语法。目前的默认值是关闭,这意味着分割语法。这个选项对Thumb2没有影响。然而,在未来的GCC版本中可能会改变。分割语法应该被认为是废弃的。</target>
        </trans-unit>
        <trans-unit id="db05f7ded93295035bf91b215647f3c25bb15bd8" translate="yes" xml:space="preserve">
          <source>Assume loading data from flash is slower than fetching instruction. Therefore literal load is minimized for better performance. This option is only supported when compiling for ARMv7 M-profile and off by default. It conflicts with</source>
          <target state="translated">假设从flash加载数据比获取指令慢。因此,为了获得更好的性能,字面加载被最小化。这个选项只在编译ARMv7 M-profile时支持,默认情况下是关闭的。它与</target>
        </trans-unit>
        <trans-unit id="d4a16bcb883f109ce15025d3902db389e542f4a1" translate="yes" xml:space="preserve">
          <source>Assume objects may be anywhere in the 32-bit address space (the compiler generates &lt;code&gt;seth/add3&lt;/code&gt; instructions to load their addresses), and assume all subroutines are reachable with the &lt;code&gt;bl&lt;/code&gt; instruction.</source>
          <target state="translated">假定对象可能在32位地址空间中的任何位置（编译器生成 &lt;code&gt;seth/add3&lt;/code&gt; 指令以加载其地址），并假定 &lt;code&gt;bl&lt;/code&gt; 指令可访问所有子例程。</target>
        </trans-unit>
        <trans-unit id="7d339dd7aa4708a54eb51d13312b9c328ad3f5e5" translate="yes" xml:space="preserve">
          <source>Assume objects may be anywhere in the 32-bit address space (the compiler generates &lt;code&gt;seth/add3&lt;/code&gt; instructions to load their addresses), and assume subroutines may not be reachable with the &lt;code&gt;bl&lt;/code&gt; instruction (the compiler generates the much slower &lt;code&gt;seth/add3/jl&lt;/code&gt; instruction sequence).</source>
          <target state="translated">假设对象可能在32位地址空间中的任何位置（编译器生成 &lt;code&gt;seth/add3&lt;/code&gt; 指令以加载其地址），并假定 &lt;code&gt;bl&lt;/code&gt; 指令可能无法访问子例程（编译器生成慢得多的 &lt;code&gt;seth/add3/jl&lt;/code&gt; 指令）序列）。</target>
        </trans-unit>
        <trans-unit id="c85e043c6d4b72a1f02e91090d703114e74e4f8f" translate="yes" xml:space="preserve">
          <source>Assume that &lt;code&gt;RJMP&lt;/code&gt; and &lt;code&gt;RCALL&lt;/code&gt; can target the whole program memory.</source>
          <target state="translated">假定 &lt;code&gt;RJMP&lt;/code&gt; 和 &lt;code&gt;RCALL&lt;/code&gt; 可以针对整个程序存储器。</target>
        </trans-unit>
        <trans-unit id="33caf9125270759b9ef9dbfd91c8e100e633839c" translate="yes" xml:space="preserve">
          <source>Assume that ICPLBs are enabled at run time. This has an effect on certain anomaly workarounds. For Linux targets, the default is to assume ICPLBs are enabled; for standalone applications the default is off.</source>
          <target state="translated">假设在运行时启用ICPLBs。这对某些异常解决方法有影响。对于Linux目标机,默认是假设ICPLBs已启用;对于独立应用程序,默认是关闭。</target>
        </trans-unit>
        <trans-unit id="ed72c79186a186d46e787e25dd72b1da5c105ed8" translate="yes" xml:space="preserve">
          <source>Assume that all Objective-C message dispatches (&lt;code&gt;[receiver
message:arg]&lt;/code&gt;) in this translation unit ensure that the receiver is not &lt;code&gt;nil&lt;/code&gt;. This allows for more efficient entry points in the runtime to be used. This option is only available in conjunction with the NeXT runtime and ABI version 0 or 1.</source>
          <target state="translated">假定此转换单元中的所有Objective-C消息调度程序（ &lt;code&gt;[receiver message:arg]&lt;/code&gt; ）确保接收者不是 &lt;code&gt;nil&lt;/code&gt; 。这允许在运行时中使用更有效的入口点。该选项仅与NeXT运行时和ABI版本0或1结合使用。</target>
        </trans-unit>
        <trans-unit id="866258482a2aa9fcb54dee6ab333e2e33fa56a9f" translate="yes" xml:space="preserve">
          <source>Assume that all data in static storage can be accessed by LDS / STS instructions. This option has only an effect on reduced Tiny devices like ATtiny40. See also the &lt;code&gt;absdata&lt;/code&gt;&lt;a href=&quot;variable-attributes#AVR-Variable-Attributes&quot;&gt;variable attribute&lt;/a&gt;.</source>
          <target state="translated">假设可以通过LDS / STS指令访问静态存储中的所有数据。此选项仅对减少的Tiny设备（如ATtiny40）有效。另请参见 &lt;code&gt;absdata&lt;/code&gt; &lt;a href=&quot;variable-attributes#AVR-Variable-Attributes&quot;&gt;变量属性&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9ef3d0ef83e6f997acb69f32efa34ce5f18bfd5d" translate="yes" xml:space="preserve">
          <source>Assume that doubles have 8-byte alignment. This is the default.</source>
          <target state="translated">假设双字节有8个字节的对齐方式。这是默认的。</target>
        </trans-unit>
        <trans-unit id="856f36f37f5770dafc37ec4f5ce9ae4ba43b9ab0" translate="yes" xml:space="preserve">
          <source>Assume that floating-point registers are 32 bits wide.</source>
          <target state="translated">假设浮点寄存器的宽度为32位。</target>
        </trans-unit>
        <trans-unit id="89754b304532c00897fca86b5c5a4a2fdb8ea856" translate="yes" xml:space="preserve">
          <source>Assume that floating-point registers are 64 bits wide.</source>
          <target state="translated">假设浮点寄存器的宽度为64位。</target>
        </trans-unit>
        <trans-unit id="6c5971ed7912aa4bcfc190d25dcfc54913916046" translate="yes" xml:space="preserve">
          <source>Assume that floating-point stores and loads are not likely to cause a conflict when placed into the same instruction group. This option is disabled by default.</source>
          <target state="translated">假设浮点存储和加载放到同一个指令组中不会引起冲突。该选项默认为禁用。</target>
        </trans-unit>
        <trans-unit id="79ddd95e70fe2bc8d68e335f2358d8d016cca43e" translate="yes" xml:space="preserve">
          <source>Assume that general-purpose registers are 32 bits wide.</source>
          <target state="translated">假设通用寄存器的宽度为32位。</target>
        </trans-unit>
        <trans-unit id="67b1eea988cecf507f4140115cf0f3a04a0b6bc0" translate="yes" xml:space="preserve">
          <source>Assume that general-purpose registers are 64 bits wide.</source>
          <target state="translated">假设通用寄存器的宽度为64位。</target>
        </trans-unit>
        <trans-unit id="d05b8de7cb58ad911a3c660af041154da0f70378" translate="yes" xml:space="preserve">
          <source>Assume that programs cannot safely dereference null pointers, and that no code or data element resides at address zero. This option enables simple constant folding optimizations at all optimization levels. In addition, other optimization passes in GCC use this flag to control global dataflow analyses that eliminate useless checks for null pointers; these assume that a memory access to address zero always results in a trap, so that if a pointer is checked after it has already been dereferenced, it cannot be null.</source>
          <target state="translated">假设程序不能安全地去引用空指针,并且没有代码或数据元素驻留在零地址。这个选项可以在所有优化级别上实现简单的常量折叠优化。此外,GCC中的其他优化通道使用这个标志来控制全局数据流分析,以消除对空指针的无用检查;这些假设对地址为零的内存访问总是导致陷阱,因此如果一个指针在已经被解除引用后被检查,它就不能是空指针。</target>
        </trans-unit>
        <trans-unit id="076633874f4c1995b07023b5b94aab209c515c86" translate="yes" xml:space="preserve">
          <source>Assume that runtime support has been provided and so omit the simulator library (</source>
          <target state="translated">假设已经提供了运行时支持,因此省略了模拟器库(</target>
        </trans-unit>
        <trans-unit id="42823e20bce5001093b19d4ebc090a1f52fb87fe" translate="yes" xml:space="preserve">
          <source>Assume that runtime support has been provided and so there is no need to include the simulator library (</source>
          <target state="translated">假设已经提供了运行时支持,因此不需要包含模拟器库 (</target>
        </trans-unit>
        <trans-unit id="0d530f525409fd98b58f0bb247b2945e9f43679e" translate="yes" xml:space="preserve">
          <source>Assume that the current compilation unit represents the whole program being compiled. All public functions and variables with the exception of &lt;code&gt;main&lt;/code&gt; and those merged by attribute &lt;code&gt;externally_visible&lt;/code&gt; become static functions and in effect are optimized more aggressively by interprocedural optimizers.</source>
          <target state="translated">假定当前的编译单元代表正在编译的整个程序。除 &lt;code&gt;main&lt;/code&gt; 以外的所有公共函数和变量，以及由属性 &lt;code&gt;externally_visible&lt;/code&gt; 合并的那些公共函数和变量，都变为静态函数，实际上是由过程间优化器更积极地优化的。</target>
        </trans-unit>
        <trans-unit id="d4cfc093a537b06194880f65fa701bc5be05c19f" translate="yes" xml:space="preserve">
          <source>Assume that the device supports the Read-Modify-Write instructions &lt;code&gt;XCH&lt;/code&gt;, &lt;code&gt;LAC&lt;/code&gt;, &lt;code&gt;LAS&lt;/code&gt; and &lt;code&gt;LAT&lt;/code&gt;.</source>
          <target state="translated">假设设备支持Read-Modify-Write指令 &lt;code&gt;XCH&lt;/code&gt; ， &lt;code&gt;LAC&lt;/code&gt; ， &lt;code&gt;LAS&lt;/code&gt; 和 &lt;code&gt;LAT&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="766547e453a1be99c1e3faccd183445d895ac153" translate="yes" xml:space="preserve">
          <source>Assume that the displacement between the text and data segments is fixed at static link time. This allows data to be referenced by offset from start of text address instead of GOT since PC-relative addressing is not supported.</source>
          <target state="translated">假设文本段和数据段之间的位移在静态链接时是固定的。由于不支持PC相关寻址,因此可以用文本地址开始的偏移量而不是GOT来引用数据。</target>
        </trans-unit>
        <trans-unit id="ebfb14654d3ce6ee7fc14d89650e1df706d43a0e" translate="yes" xml:space="preserve">
          <source>Assume that the displacement between the text and data segments is fixed at static link time. This permits using PC-relative addressing operations to access data known to be in the data segment. For non-VxWorks RTP targets, this option is enabled by default. When disabled on such targets, it will enable</source>
          <target state="translated">假设文本段和数据段之间的位移在静态链接时间是固定的。这允许使用PC相对寻址操作来访问数据段中已知的数据。对于非VxWorks RTP目标,该选项默认为启用。当在这些目标上禁用时,它将启用</target>
        </trans-unit>
        <trans-unit id="38bffa713c2a7cd96b200f3894b2b7a3ab419ebb" translate="yes" xml:space="preserve">
          <source>Assume that the flash memory has a size of &lt;var&gt;num&lt;/var&gt; times 64 KiB.</source>
          <target state="translated">假设闪存的大小为 &lt;var&gt;num&lt;/var&gt; 乘以64 KiB。</target>
        </trans-unit>
        <trans-unit id="0381000794bbd2c3b341dcaa9dd877537e5d82e9" translate="yes" xml:space="preserve">
          <source>Assume that the floating-point coprocessor only supports single-precision operations.</source>
          <target state="translated">假设浮点协处理器只支持单精度操作。</target>
        </trans-unit>
        <trans-unit id="da28820fdda9574eb1ba106e15f86ccdafa0352f" translate="yes" xml:space="preserve">
          <source>Assume that the floating-point coprocessor supports double-precision operations. This is the default.</source>
          <target state="translated">假设浮点协处理器支持双精度操作。这是默认的。</target>
        </trans-unit>
        <trans-unit id="fdfa0bfee5480efa2b5e12152c0e653e6cc25473" translate="yes" xml:space="preserve">
          <source>Assume that the handler uses a shadow register set, instead of the main general-purpose registers. An optional argument &lt;code&gt;intstack&lt;/code&gt; is supported to indicate that the shadow register set contains a valid stack pointer.</source>
          <target state="translated">假定处理程序使用影子寄存器集，而不是主要的通用寄存器。支持可选参数 &lt;code&gt;intstack&lt;/code&gt; ，以指示影子寄存器集包含有效的堆栈指针。</target>
        </trans-unit>
        <trans-unit id="cb05f1c18ebd5a07940293ac38328ed8480807dc" translate="yes" xml:space="preserve">
          <source>Assume that the program is arbitrarily large. This is the default.</source>
          <target state="translated">假设程序是任意大的。这是默认的。</target>
        </trans-unit>
        <trans-unit id="bea8e60014028d1c1e2350ea91c13bef18cfe395" translate="yes" xml:space="preserve">
          <source>Assume the incoming stack is aligned to a 2 raised to &lt;var&gt;num&lt;/var&gt; byte boundary. If</source>
          <target state="translated">假定传入的堆栈与2对齐到 &lt;var&gt;num&lt;/var&gt; 个字节的边界对齐。如果</target>
        </trans-unit>
        <trans-unit id="2b0c018c4bbeac1a835b6bc4f97980f45c5201f9" translate="yes" xml:space="preserve">
          <source>At level &lt;var&gt;2&lt;/var&gt;, the call in the example above is again diagnosed, but this time because with &lt;var&gt;a&lt;/var&gt; equal to a 32-bit &lt;code&gt;INT_MIN&lt;/code&gt; the first &lt;code&gt;%i&lt;/code&gt; directive will write some of its digits beyond the end of the destination buffer. To make the call safe regardless of the values of the two variables, the size of the destination buffer must be increased to at least 34 bytes. GCC includes the minimum size of the buffer in an informational note following the warning.</source>
          <target state="translated">在级别 &lt;var&gt;2&lt;/var&gt; ，在上述的例子中，呼叫被再次诊断，但此时，因为与 &lt;var&gt;a&lt;/var&gt; 等于32位 &lt;code&gt;INT_MIN&lt;/code&gt; 第一 &lt;code&gt;%i&lt;/code&gt; 指令将写它的一些数字超出目标缓冲区的末尾。为了使调用安全，而与两个变量的值无关，必须将目标缓冲区的大小增加到至少34个字节。 GCC在警告之后的信息性注释中包括缓冲区的最小大小。</target>
        </trans-unit>
        <trans-unit id="3ddf0f631ce882bb84e3fb93f118fee7f5a7f5f9" translate="yes" xml:space="preserve">
          <source>At present, GCC only provides support for operations on 32-bit vectors. The vector type associated with 8-bit integer data is usually called &lt;code&gt;v4i8&lt;/code&gt;, the vector type associated with Q7 is usually called &lt;code&gt;v4q7&lt;/code&gt;, the vector type associated with 16-bit integer data is usually called &lt;code&gt;v2i16&lt;/code&gt;, and the vector type associated with Q15 is usually called &lt;code&gt;v2q15&lt;/code&gt;. They can be defined in C as follows:</source>
          <target state="translated">目前，GCC仅支持对32位向量的操作。与8位整数数据相关的向量类型通常称为 &lt;code&gt;v4i8&lt;/code&gt; ，与Q7相关的向量类型通常称为 &lt;code&gt;v4q7&lt;/code&gt; ，与16位整数数据有关的向量类型通常称为 &lt;code&gt;v2i16&lt;/code&gt; ，与Q15相关的向量类型通常为称为 &lt;code&gt;v2q15&lt;/code&gt; 。它们可以在C中定义如下：</target>
        </trans-unit>
        <trans-unit id="7562b8145986b9d15bbe747f7453ec31fbcb23e3" translate="yes" xml:space="preserve">
          <source>At present, a declaration to which &lt;code&gt;weakref&lt;/code&gt; is attached can only be &lt;code&gt;static&lt;/code&gt;.</source>
          <target state="translated">目前，附加了 &lt;code&gt;weakref&lt;/code&gt; 的声明只能是 &lt;code&gt;static&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e4135487f1e326a7c07cb63519ab457040bcc6fd" translate="yes" xml:space="preserve">
          <source>At present, the first parameter in a function prototype must have some type specifier that is not an attribute specifier; this resolves an ambiguity in the interpretation of &lt;code&gt;void f(int
(__attribute__((foo)) x))&lt;/code&gt;, but is subject to change. At present, if the parentheses of a function declarator contain only attributes then those attributes are ignored, rather than yielding an error or warning or implying a single parameter of type int, but this is subject to change.</source>
          <target state="translated">当前，函数原型中的第一个参数必须具有某种类型说明符，而不是属性说明符。这解决了 &lt;code&gt;void f(int (__attribute__((foo)) x))&lt;/code&gt; 的解释中的歧义，但可能会发生变化。当前，如果函数声明符的括号仅包含属性，则将忽略这些属性，而不是产生错误或警告或暗示单个int类型的参数，但这可能会发生变化。</target>
        </trans-unit>
        <trans-unit id="aba1eab05ac64c3b09192d2f6e850b4049723108" translate="yes" xml:space="preserve">
          <source>At the user level, the extension is visible with a new storage class keyword: &lt;code&gt;__thread&lt;/code&gt;. For example:</source>
          <target state="translated">在用户级别，可以使用新的存储类关键字 &lt;code&gt;__thread&lt;/code&gt; 看到扩展名。例如：</target>
        </trans-unit>
        <trans-unit id="822a22d01653371bac14c53e07474f5d45325389" translate="yes" xml:space="preserve">
          <source>At this level</source>
          <target state="translated">在这一级</target>
        </trans-unit>
        <trans-unit id="87ea658ed4a4a90d1fc99e8e69012153c56f031c" translate="yes" xml:space="preserve">
          <source>At this level, in addition to diagnosing all the same constructs as at level 1, a diagnostic is also issued for placement new expressions that construct an object in the last member of structure whose type is an array of a single element and whose size is less than the size of the object being constructed. While the previous example would be diagnosed, the following construct makes use of the flexible member array extension to avoid the warning at level 2.</source>
          <target state="translated">在这一级,除了诊断所有与第1级相同的构造外,还对在结构的最后一个成员中构造对象的放置新表达式发出诊断,该对象的类型是一个单元素数组,其大小小于被构造对象的大小。虽然前面的例子会被诊断出来,但下面的构造利用灵活的成员数组扩展来避免第2级的警告。</target>
        </trans-unit>
        <trans-unit id="27bef66661f5c0b03146d1698ca3afb51d9a26fb" translate="yes" xml:space="preserve">
          <source>Atomic built-in functions with memory model.</source>
          <target state="translated">原子内置功能与内存模型。</target>
        </trans-unit>
        <trans-unit id="4ce1364206864236a22c5c48cd625fe86883adb2" translate="yes" xml:space="preserve">
          <source>Atomic types are not permitted for bit-fields.</source>
          <target state="translated">位字段不允许使用原子类型。</target>
        </trans-unit>
        <trans-unit id="b41c8daf0a5d584177e036c6b54eb5d698ff31ca" translate="yes" xml:space="preserve">
          <source>Attempt to avoid false dependencies in scheduled code by making use of registers left over after register allocation. This optimization most benefits processors with lots of registers. Depending on the debug information format adopted by the target, however, it can make debugging impossible, since variables no longer stay in a &amp;ldquo;home register&amp;rdquo;.</source>
          <target state="translated">尝试通过使用寄存器分配后剩余的寄存器来避免调度代码中的虚假依赖关系。这种优化最有利于拥有大量寄存器的处理器。但是，根据目标采用的调试信息格式，由于变量不再停留在&amp;ldquo;本地寄存器&amp;rdquo;中，它可能使调试变得不可能。</target>
        </trans-unit>
        <trans-unit id="c6f5acede0fbb18382444dea8c6c4247f6477d4a" translate="yes" xml:space="preserve">
          <source>Attempt to convert calls to virtual functions to direct calls. This is done both within a procedure and interprocedurally as part of indirect inlining (</source>
          <target state="translated">试图将对虚拟函数的调用转换为直接调用。这既可以在存储过程中进行,也可以作为间接内联的一部分在过程间进行(</target>
        </trans-unit>
        <trans-unit id="23ecd786dc35f08a1baffd99e6e7d5e25ec53b58" translate="yes" xml:space="preserve">
          <source>Attempt to convert calls to virtual functions to speculative direct calls. Based on the analysis of the type inheritance graph, determine for a given call the set of likely targets. If the set is small, preferably of size 1, change the call into a conditional deciding between direct and indirect calls. The speculative calls enable more optimizations, such as inlining. When they seem useless after further optimization, they are converted back into original form.</source>
          <target state="translated">尝试将对虚拟函数的调用转换为投机性直接调用。根据对类型继承图的分析,确定给定调用的可能目标集。如果该集合很小,最好是大小为1,则将调用改为有条件的决定直接调用和间接调用。投机调用可以实现更多的优化,比如内联。当它们在进一步优化后显得无用时,就会被转换回原始形式。</target>
        </trans-unit>
        <trans-unit id="015c279bf199fbda7e73b9795378a6fd0b0af2c9" translate="yes" xml:space="preserve">
          <source>Attempt to decrease register pressure through register live range shrinkage. This is helpful for fast processors with small or moderate size register sets.</source>
          <target state="translated">试图通过收缩寄存器活区来降低寄存器压力。这对具有小型或中等规模寄存器集的快速处理器很有帮助。</target>
        </trans-unit>
        <trans-unit id="687510f6384de354811653c1b3a65669791e13da" translate="yes" xml:space="preserve">
          <source>Attempt to determine location views that can be omitted from location view lists. This requires the compiler to have very accurate insn length estimates, which isn&amp;rsquo;t always the case, and it may cause incorrect view lists to be generated silently when using an assembler that does not support location view lists. The GNU assembler will flag any such error as a &lt;code&gt;view number mismatch&lt;/code&gt;. This is only enabled on ports that define a reliable estimation function.</source>
          <target state="translated">尝试确定可以从位置视图列表中省略的位置视图。这要求编译器具有非常准确的insn长度估计，而这并非总是如此，并且在使用不支持位置视图列表的汇编器时，它可能会导致不正确地生成不正确的视图列表。GNU汇编器会将任何此类错误标记为 &lt;code&gt;view number mismatch&lt;/code&gt; 。仅在定义可靠估计功能的端口上启用此功能。</target>
        </trans-unit>
        <trans-unit id="aac236b78fdffe9d37dcfcf412e47b1651113242" translate="yes" xml:space="preserve">
          <source>Attempt to keep the stack boundary aligned to a 2 raised to &lt;var&gt;num&lt;/var&gt; byte boundary. If</source>
          <target state="translated">尝试使堆栈边界与2对齐，以提高到 &lt;var&gt;num&lt;/var&gt; 字节边界。如果</target>
        </trans-unit>
        <trans-unit id="c862c84dcea1c34fb363ef2530e074c7fb9ff011" translate="yes" xml:space="preserve">
          <source>Attempt to merge identical constants (string constants and floating-point constants) across compilation units.</source>
          <target state="translated">试图将相同的常量(字符串常量和浮点常量)合并到不同的编译单元。</target>
        </trans-unit>
        <trans-unit id="50e4bd95dd66a112841cf4cd0b134789556e574d" translate="yes" xml:space="preserve">
          <source>Attempt to merge identical constants and identical variables.</source>
          <target state="translated">试图合并相同的常量和相同的变量。</target>
        </trans-unit>
        <trans-unit id="0f797d45d3d320c615fd705a20d8464b1c6f92f0" translate="yes" xml:space="preserve">
          <source>Attempt to minimize stack usage. The compiler attempts to use less stack space, even if that makes the program slower. This option implies setting the</source>
          <target state="translated">试图尽量减少堆栈的使用。编译器试图使用更少的堆栈空间,即使这会使程序更慢。这个选项意味着将</target>
        </trans-unit>
        <trans-unit id="1d6331b92854e1a7daaaa3b254ef23d3e2705563" translate="yes" xml:space="preserve">
          <source>Attempt to remove redundant extension instructions. This is especially helpful for the x86-64 architecture, which implicitly zero-extends in 64-bit registers after writing to their lower 32-bit half.</source>
          <target state="translated">试图删除多余的扩展指令。这对x86-64架构特别有帮助,因为x86-64架构在写到64位寄存器的下半部分32位后,会隐式地在64位寄存器中进行零扩展。</target>
        </trans-unit>
        <trans-unit id="af8cd75ee0ed545b02a70bb0db32f4bb7b0a164a" translate="yes" xml:space="preserve">
          <source>Attempt to transform conditional jumps in the innermost loops to branch-less equivalents. The intent is to remove control-flow from the innermost loops in order to improve the ability of the vectorization pass to handle these loops. This is enabled by default if vectorization is enabled.</source>
          <target state="translated">试图将最内部循环中的条件跳转转化为无分支的等价物。这样做的目的是为了去除最内部循环中的控制流,以提高矢量化传递处理这些循环的能力。如果启用了向量化,则默认启用该功能。</target>
        </trans-unit>
        <trans-unit id="a82b9d3f6e114711b5045a6cdf1e499c5d11c4fa" translate="yes" xml:space="preserve">
          <source>Attempt to transform conditional jumps into branch-less equivalents. This includes use of conditional moves, min, max, set flags and abs instructions, and some tricks doable by standard arithmetics. The use of conditional execution on chips where it is available is controlled by</source>
          <target state="translated">试图将条件跳转转化为无分支的等价物。这包括使用条件移动、最小、最大、设置标志和abs指令,以及一些可以通过标准算术来实现的技巧。在可以使用条件执行的芯片上,条件执行的使用是由以下控制的</target>
        </trans-unit>
        <trans-unit id="1ffd089c28cbc3f051c86ecbaa3c75b1a01df17f" translate="yes" xml:space="preserve">
          <source>Attempt to utilize both instruction sets at once. This effectively doubles the amount of available registers, and on chips with separate execution units for 387 and SSE the execution resources too. Use this option with care, as it is still experimental, because the GCC register allocator does not model separate functional units well, resulting in unstable performance.</source>
          <target state="translated">试图同时利用两个指令集。这样可以有效地将可用的寄存器数量增加一倍,在有387和SSE独立执行单元的芯片上,执行资源也会增加一倍。谨慎使用这个选项,因为它还是试验性的,因为GCC寄存器分配器不能很好地模拟单独的功能单元,导致性能不稳定。</target>
        </trans-unit>
        <trans-unit id="768394a0c657893c518e749955ef528cb8973c45" translate="yes" xml:space="preserve">
          <source>Attribute specifiers may be mixed with type qualifiers appearing inside the &lt;code&gt;[]&lt;/code&gt; of a parameter array declarator, in the C99 construct by which such qualifiers are applied to the pointer to which the array is implicitly converted. Such attribute specifiers apply to the pointer, not to the array, but at present this is not implemented and they are ignored.</source>
          <target state="translated">在C99结构中，属性说明符可以与出现在参数数组声明符 &lt;code&gt;[]&lt;/code&gt; 内的类型限定符混合，通过这种限定符将这些限定符应用于隐式转换到数组的指针。此类属性说明符适用于指针，而不适用于数组，但目前尚未实现，因此将被忽略。</target>
        </trans-unit>
        <trans-unit id="f15f9fabc9141a4fd02709ab1f144944da1df77d" translate="yes" xml:space="preserve">
          <source>Attributes considered include &lt;code&gt;alloc_align&lt;/code&gt;, &lt;code&gt;alloc_size&lt;/code&gt;, &lt;code&gt;cold&lt;/code&gt;, &lt;code&gt;const&lt;/code&gt;, &lt;code&gt;hot&lt;/code&gt;, &lt;code&gt;leaf&lt;/code&gt;, &lt;code&gt;malloc&lt;/code&gt;, &lt;code&gt;nonnull&lt;/code&gt;, &lt;code&gt;noreturn&lt;/code&gt;, &lt;code&gt;nothrow&lt;/code&gt;, &lt;code&gt;pure&lt;/code&gt;, &lt;code&gt;returns_nonnull&lt;/code&gt;, and &lt;code&gt;returns_twice&lt;/code&gt;.</source>
          <target state="translated">考虑属性包括 &lt;code&gt;alloc_align&lt;/code&gt; ， &lt;code&gt;alloc_size&lt;/code&gt; ， &lt;code&gt;cold&lt;/code&gt; ， &lt;code&gt;const&lt;/code&gt; ， &lt;code&gt;hot&lt;/code&gt; ， &lt;code&gt;leaf&lt;/code&gt; ， &lt;code&gt;malloc&lt;/code&gt; 的， &lt;code&gt;nonnull&lt;/code&gt; ， &lt;code&gt;noreturn&lt;/code&gt; ， &lt;code&gt;nothrow&lt;/code&gt; ， &lt;code&gt;pure&lt;/code&gt; ， &lt;code&gt;returns_nonnull&lt;/code&gt; 和 &lt;code&gt;returns_twice&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1e72cecf4ee93be8444bf26683f3314180b4f20f" translate="yes" xml:space="preserve">
          <source>Augment variable location lists with progressive view numbers implied from the line number table. This enables debug information consumers to inspect state at certain points of the program, even if no instructions associated with the corresponding source locations are present at that point. If the assembler lacks support for view numbers in line number tables, this will cause the compiler to emit the line number table, which generally makes them somewhat less compact. The augmented line number tables and location lists are fully backward-compatible, so they can be consumed by debug information consumers that are not aware of these augmentations, but they won&amp;rsquo;t derive any benefit from them either.</source>
          <target state="translated">扩充变量位置列表，其中包含行号表中隐含的渐进视图号。这使调试信息使用者能够检查程序某些点的状态，即使在该点不存在与相应源位置关联的指令也是如此。如果汇编程序不支持行号表中的视图号，则将导致编译器发出行号表，这通常会使它们的紧凑性降低。扩展的行号表和位置列表是完全向后兼容的，因此调试信息使用方可以使用它们，这些用户不知道这些扩展，但是它们也不会从中获得任何好处。</target>
        </trans-unit>
        <trans-unit id="e028ddf293b9280450ea608fcf02b6afb803a5cf" translate="yes" xml:space="preserve">
          <source>Automatically convert relative source file names to absolute path names in the</source>
          <target state="translated">自动将相对的源文件名转换为绝对路径名。</target>
        </trans-unit>
        <trans-unit id="5484fc94aa2d1ceccb816e9c671bdaec50d90ef7" translate="yes" xml:space="preserve">
          <source>Average number of iterations of a loop.</source>
          <target state="translated">循环的平均迭代次数。</target>
        </trans-unit>
        <trans-unit id="04f04d96d845a90ad835e69c3cba86443a61a89a" translate="yes" xml:space="preserve">
          <source>Avoid or allow generating memory accesses that may not be aligned on a natural object boundary as described in the architecture specification.</source>
          <target state="translated">避免或允许生成可能不在架构规范中描述的自然对象边界上对齐的内存访问。</target>
        </trans-unit>
        <trans-unit id="ae4f281df5a5d0ff3cad6371f76d5c29b6d953ec" translate="yes" xml:space="preserve">
          <source>B</source>
          <target state="translated">B</target>
        </trans-unit>
        <trans-unit id="25ec48c867ed8bb8e6f96a8b43aad4372bc4578a" translate="yes" xml:space="preserve">
          <source>B register</source>
          <target state="translated">B册</target>
        </trans-unit>
        <trans-unit id="cde782be8b675144b1c3a413d952e5058ca53d38" translate="yes" xml:space="preserve">
          <source>BL</source>
          <target state="translated">BL</target>
        </trans-unit>
        <trans-unit id="7a64a2253d2959f0bf9362ab5d3438b38d98d231" translate="yes" xml:space="preserve">
          <source>BMI instructions.</source>
          <target state="translated">BMI指示。</target>
        </trans-unit>
        <trans-unit id="a694b7ba8977f0d1b0d7c872c114539da755bd3b" translate="yes" xml:space="preserve">
          <source>BMI2 instructions.</source>
          <target state="translated">BMI2说明。</target>
        </trans-unit>
        <trans-unit id="bfdb06081cf1ce665b573d70cc38b7b454902ff9" translate="yes" xml:space="preserve">
          <source>BRIG files (binary representation of HSAIL).</source>
          <target state="translated">BRIG文件(HSAIL的二进制表示);</target>
        </trans-unit>
        <trans-unit id="089ea9746c8cbdc04b34721f820ba603e6881ff2" translate="yes" xml:space="preserve">
          <source>Base pointer register (r28&amp;ndash;r31)</source>
          <target state="translated">基本指针寄存器（r28&amp;ndash;r31）</target>
        </trans-unit>
        <trans-unit id="92f76287d800c12dfd6b51ad7e80eed03e92c213" translate="yes" xml:space="preserve">
          <source>Base::Base</source>
          <target state="translated">Base::Base</target>
        </trans-unit>
        <trans-unit id="9039faeb6333b5e373bf646f9ff036f287abc6be" translate="yes" xml:space="preserve">
          <source>Base::operator=</source>
          <target state="translated">Base::operator=</target>
        </trans-unit>
        <trans-unit id="7b3a608459615b9bc19c9d4a294c3d2c0cd4a8a0" translate="yes" xml:space="preserve">
          <source>Basic use of constraints.</source>
          <target state="translated">约束的基本使用。</target>
        </trans-unit>
        <trans-unit id="d5770040433fcf2fed9fca7319c3ac627f6efe91" translate="yes" xml:space="preserve">
          <source>Be aware of this when performing timing tests, for instance the following loop can be completely removed, provided &lt;code&gt;some_expression&lt;/code&gt; can provably not change any global state.</source>
          <target state="translated">在执行时序测试时，请注意这一点，例如，只要 &lt;code&gt;some_expression&lt;/code&gt; 可证明不更改任何全局状态，则可以完全删除以下循环。</target>
        </trans-unit>
        <trans-unit id="6d4c386efa741fabb074be3b34ff11b267e4e0d7" translate="yes" xml:space="preserve">
          <source>Be aware that headers from outside your project, in particular system headers and headers from any other library you use, may not be expecting to be compiled with visibility other than the default. You may need to explicitly say &lt;code&gt;#pragma GCC visibility push(default)&lt;/code&gt; before including any such headers.</source>
          <target state="translated">请注意，项目外部的标头（尤其是系统标头和您使用的任何其他库的标头）可能不会期望使用默认值以外的可见性进行编译。在包含任何此类标头之前，您可能需要明确地说 &lt;code&gt;#pragma GCC visibility push(default)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b31e54ef88fe124b0da9af9ee2524cfb6800e5f0" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;__builtin_longjmp&lt;/code&gt; depends on the function return mechanism to restore the stack context, it cannot be called from the same function calling &lt;code&gt;__builtin_setjmp&lt;/code&gt; to initialize &lt;var&gt;buf&lt;/var&gt;. It can only be called from a function called (directly or indirectly) from the function calling &lt;code&gt;__builtin_setjmp&lt;/code&gt;.</source>
          <target state="translated">因为 &lt;code&gt;__builtin_longjmp&lt;/code&gt; 依赖于函数返回机制来还原堆栈上下文，所以不能从调用 &lt;code&gt;__builtin_setjmp&lt;/code&gt; 的同一函数中调用它来初始化 &lt;var&gt;buf&lt;/var&gt; 。只能从调用 &lt;code&gt;__builtin_setjmp&lt;/code&gt; 的函数（直接或间接）中调用的函数。</target>
        </trans-unit>
        <trans-unit id="d94ff60e2bbcd755c2d21600b1c5beacc8d88e0e" translate="yes" xml:space="preserve">
          <source>Because of the interactions between synchronization and exception handling, you can only use &lt;code&gt;@synchronized&lt;/code&gt; when compiling with exceptions enabled, that is with the command line option</source>
          <target state="translated">由于同步和异常处理之间存在交互作用，因此仅在启用异常的情况下（即通过命令行选项）进行编译时，才可以使用 &lt;code&gt;@synchronized&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bc31609fad1f0a543a7bf312e8fc7b4e085e75b6" translate="yes" xml:space="preserve">
          <source>Because of the special nature of the flag output operands, the constraint may not include alternatives.</source>
          <target state="translated">由于标志输出操作数的特殊性,约束条件可能不包括替代品。</target>
        </trans-unit>
        <trans-unit id="74b7dab219d7dd89ab8e51f25903de3035d7b00a" translate="yes" xml:space="preserve">
          <source>Because of the way GCC instruments calls, a call count can be shown after a line with no individual blocks. As you can see, line 33 contains a basic block that was not executed.</source>
          <target state="translated">由于GCC工具调用的方式,可以在没有单独块的行后显示调用计数。如你所见,第33行包含了一个没有被执行的基本块。</target>
        </trans-unit>
        <trans-unit id="ba975e496f98093e5f2ea388a49453725d139a4b" translate="yes" xml:space="preserve">
          <source>Because the &lt;code&gt;asm&lt;/code&gt; statement unconditionally transfers control out of the function, control never reaches the end of the function body. The &lt;code&gt;__builtin_unreachable&lt;/code&gt; is in fact unreachable and communicates this fact to the compiler.</source>
          <target state="translated">因为 &lt;code&gt;asm&lt;/code&gt; 语句无条件地将控制权转移到函数之外，所以控制权永远不会到达函数体的末尾。该 &lt;code&gt;__builtin_unreachable&lt;/code&gt; 其实可达并将该事实编译器。</target>
        </trans-unit>
        <trans-unit id="a314cc1449bd666eda6884b69e668c28f95c1087" translate="yes" xml:space="preserve">
          <source>Before you can use this option, you must first generate profiling information. See &lt;a href=&quot;instrumentation-options#Instrumentation-Options&quot;&gt;Instrumentation Options&lt;/a&gt;, for information about the</source>
          <target state="translated">使用此选项之前，必须首先生成分析信息。有关的信息，请参见&lt;a href=&quot;instrumentation-options#Instrumentation-Options&quot;&gt;工具选项&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5788148d39b8d5244dcdc29f7a93a22a6334768d" translate="yes" xml:space="preserve">
          <source>Besides declarations, the file indicates, in comments, the origin of each declaration (source file and line), whether the declaration was implicit, prototyped or unprototyped (&amp;lsquo;</source>
          <target state="translated">除声明外，该文件还在注释中指出每个声明的来源（源文件和行），无论该声明是隐式，原型还是非原型（'</target>
        </trans-unit>
        <trans-unit id="51eccbcd60621399284c614907bba67ce4fca17c" translate="yes" xml:space="preserve">
          <source>Beware that on some ELF systems this attribute is unsuitable for global functions in shared libraries with lazy binding (which is the default). Lazy binding sends the first call via resolving code in the loader, which might assume EAX, EDX and ECX can be clobbered, as per the standard calling conventions. Solaris 8 is affected by this. Systems with the GNU C Library version 2.1 or higher and FreeBSD are believed to be safe since the loaders there save EAX, EDX and ECX. (Lazy binding can be disabled with the linker or the loader if desired, to avoid the problem.)</source>
          <target state="translated">要注意的是,在某些ELF系统中,这个属性不适合使用懒惰绑定(默认)的共享库中的全局函数。懒惰绑定会通过加载器中的解析代码发送第一次调用,这可能会假设 EAX、EDX 和 ECX 可以被 clobbered,按照标准调用惯例。Solaris 8 受此影响。使用 GNU C 库 2.1 或更高版本的系统和 FreeBSD 被认为是安全的,因为那里的加载器会保存 EAX、EDX 和 ECX。(如果需要的话,可以通过链接器或加载器禁用懒惰绑定,以避免这个问题。)</target>
        </trans-unit>
        <trans-unit id="2c5d61cd9cd2849c270a6af03ebe1306ad2048ca" translate="yes" xml:space="preserve">
          <source>Binary Compatibility</source>
          <target state="translated">二进制兼容性</target>
        </trans-unit>
        <trans-unit id="8668d27514898ff49d03fb634b072fd0aba7e0f7" translate="yes" xml:space="preserve">
          <source>Binary arithmetic operations.</source>
          <target state="translated">二进制算术运算。</target>
        </trans-unit>
        <trans-unit id="18e9b92cdcd75a69e0946923d3da4f8d0a7fd71d" translate="yes" xml:space="preserve">
          <source>Binary compatibility encompasses several related concepts:</source>
          <target state="translated">二进制兼容性包含了几个相关的概念。</target>
        </trans-unit>
        <trans-unit id="f8ed98dae9970ec4cee447405cb8c658f46ef706" translate="yes" xml:space="preserve">
          <source>Binary constants using the &amp;lsquo;</source>
          <target state="translated">使用'</target>
        </trans-unit>
        <trans-unit id="666bffac0affe44914b807024f7928a6d6ca6941" translate="yes" xml:space="preserve">
          <source>Bind references to global symbols when building a shared object. Warn about any unresolved references (unless overridden by the link editor option</source>
          <target state="translated">构建共享对象时,将引用绑定到全局符号。对任何未解决的引用发出警告(除非被链接编辑器选项覆盖</target>
        </trans-unit>
        <trans-unit id="628682c1112ff8669d8fed436fe1daac74760ad6" translate="yes" xml:space="preserve">
          <source>Bit reversal. Return the result of reversing the bits in &lt;var&gt;value&lt;/var&gt;. Bit 15 is swapped with bit 0, bit 14 is swapped with bit 1, and so on.</source>
          <target state="translated">位反转。返回反转 &lt;var&gt;value&lt;/var&gt; 中的位的结果。位15与位0交换，位14与位1交换，依此类推。</target>
        </trans-unit>
        <trans-unit id="2eb3706f981c5da19b9c626f35ee7ccc246608e1" translate="yes" xml:space="preserve">
          <source>Bitwise operators act on the representation of the value including both the sign and value bits, where the sign bit is considered immediately above the highest-value value bit. Signed &amp;lsquo;</source>
          <target state="translated">按位运算符作用于包括符号位和值位的值的表示形式，其中符号位被认为紧邻最高值位。签 '</target>
        </trans-unit>
        <trans-unit id="8b063c3045af1663a8359f63f1ffd9a1d853789c" translate="yes" xml:space="preserve">
          <source>Blackfin family&amp;mdash;</source>
          <target state="translated">Blackfin家族&amp;mdash;</target>
        </trans-unit>
        <trans-unit id="0daa776b5dad37eac562c1bddec1cfa040024e9a" translate="yes" xml:space="preserve">
          <source>Borland C++ solved the template instantiation problem by adding the code equivalent of common blocks to their linker; the compiler emits template instances in each translation unit that uses them, and the linker collapses them together. The advantage of this model is that the linker only has to consider the object files themselves; there is no external complexity to worry about. The disadvantage is that compilation time is increased because the template code is being compiled repeatedly. Code written for this model tends to include definitions of all templates in the header file, since they must be seen to be instantiated.</source>
          <target state="translated">Borland C++通过在他们的链接器中加入相当于普通块的代码来解决模板实例化问题;编译器在每个使用它们的翻译单元中发出模板实例,链接器将它们折叠在一起。这种模式的优点是链接器只需要考虑对象文件本身,没有外部复杂性需要担心。缺点是编译时间会增加,因为模板代码会被重复编译。为这种模式编写的代码往往在头文件中包含所有模板的定义,因为必须看到它们被实例化。</target>
        </trans-unit>
        <trans-unit id="200e3a355b82a42f3341fd59904fc5750775b807" translate="yes" xml:space="preserve">
          <source>Borland model</source>
          <target state="translated">Borland模型</target>
        </trans-unit>
        <trans-unit id="06b22f59b253dcf9c37ea4fe24c6526c4dd1e47c" translate="yes" xml:space="preserve">
          <source>Both global and local variables can be associated with a register. The consequences of performing this association are very different between the two, as explained in the sections below.</source>
          <target state="translated">全局变量和局部变量都可以与寄存器进行关联。两者之间进行这种关联的后果是非常不同的,在下面的章节中会有解释。</target>
        </trans-unit>
        <trans-unit id="fc4416d6a83edb82efd0f4cdffd08c5cd70ca428" translate="yes" xml:space="preserve">
          <source>Bound on number of candidates for induction variables, below which all candidates are considered for each use in induction variable optimizations. If there are more candidates than this, only the most relevant ones are considered to avoid quadratic time complexity.</source>
          <target state="translated">归纳变量候选数的约束,低于此数的候选数在归纳变量优化中的每次使用都会被考虑。如果候选变量的数量多于此数,则只考虑最相关的候选变量,以避免二次元时间的复杂性。</target>
        </trans-unit>
        <trans-unit id="430f77e04bd4e8702495c79a5ebb639d2a4812c8" translate="yes" xml:space="preserve">
          <source>Bound on size of expressions used in the scalar evolutions analyzer. Large expressions slow the analyzer.</source>
          <target state="translated">对标量演化分析器中使用的表达式大小进行约束。大的表达式会减慢分析器的速度。</target>
        </trans-unit>
        <trans-unit id="f0e549afa5762802ff68ea72f123883ebb295578" translate="yes" xml:space="preserve">
          <source>Bound on the complexity of the expressions in the scalar evolutions analyzer. Complex expressions slow the analyzer.</source>
          <target state="translated">对标量演化分析器中表达式的复杂性进行约束。复杂的表达式会减慢分析器的速度。</target>
        </trans-unit>
        <trans-unit id="c2a6a8fa6e2e8a317cd5dd66c604413295e3eb45" translate="yes" xml:space="preserve">
          <source>Bound on the cost of an expression to compute the number of iterations.</source>
          <target state="translated">对计算迭代次数的表达式的成本进行约束。</target>
        </trans-unit>
        <trans-unit id="ebb1b62c34f820227fd0537f593962386bf2cc61" translate="yes" xml:space="preserve">
          <source>Branch register</source>
          <target state="translated">分部登记册</target>
        </trans-unit>
        <trans-unit id="a833b9b5c7959a93636f56f73df394e8d3c434e8" translate="yes" xml:space="preserve">
          <source>Branches are present only with &lt;var&gt;-b&lt;/var&gt; option. Fields of the &lt;var&gt;line&lt;/var&gt; element have following semantics:</source>
          <target state="translated">仅在使用 &lt;var&gt;-b&lt;/var&gt; 选项时才存在分支。 &lt;var&gt;line&lt;/var&gt; 元素的字段具有以下语义：</target>
        </trans-unit>
        <trans-unit id="a6495e1aabddcd6526141ce6efe62824f5a7eae3" translate="yes" xml:space="preserve">
          <source>Brief list of all options, without explanations.</source>
          <target state="translated">所有选项的简要清单,不作解释。</target>
        </trans-unit>
        <trans-unit id="654ffe48f6054af226250c2aa3867b5fc4c80bcc" translate="yes" xml:space="preserve">
          <source>Bugs we will fix later.</source>
          <target state="translated">错误我们会在以后修复。</target>
        </trans-unit>
        <trans-unit id="de5bfe3fd9b6538bfa34acbeb7a505866d87ffce" translate="yes" xml:space="preserve">
          <source>Build a standalone application for Core A of BF561 when using the one-application-per-core programming model. Proper start files and link scripts are used to support Core A, and the macro &lt;code&gt;__BFIN_COREA&lt;/code&gt; is defined. This option can only be used in conjunction with</source>
          <target state="translated">使用每核一个应用程序编程模型时，为BF561的Core A构建一个独立的应用程序。正确的启动文件和链接脚本用于支持Core A，并定义了宏 &lt;code&gt;__BFIN_COREA&lt;/code&gt; 。此选项只能与</target>
        </trans-unit>
        <trans-unit id="6320906d93f259f860a69b97e3abeb20581c59d7" translate="yes" xml:space="preserve">
          <source>Build a standalone application for Core B of BF561 when using the one-application-per-core programming model. Proper start files and link scripts are used to support Core B, and the macro &lt;code&gt;__BFIN_COREB&lt;/code&gt; is defined. When this option is used, &lt;code&gt;coreb_main&lt;/code&gt; should be used instead of &lt;code&gt;main&lt;/code&gt;. This option can only be used in conjunction with</source>
          <target state="translated">使用每核一个应用程序编程模型时，为BF561的Core B构建一个独立的应用程序。正确的启动文件和链接脚本用于支持Core B，并定义了宏 &lt;code&gt;__BFIN_COREB&lt;/code&gt; 。使用此选项时，应使用 &lt;code&gt;coreb_main&lt;/code&gt; 而不是 &lt;code&gt;main&lt;/code&gt; 。此选项只能与</target>
        </trans-unit>
        <trans-unit id="e010c48c400b5b030ac052e6ece9a00978fee8f4" translate="yes" xml:space="preserve">
          <source>Build a standalone application for SDRAM. Proper start files and link scripts are used to put the application into SDRAM, and the macro &lt;code&gt;__BFIN_SDRAM&lt;/code&gt; is defined. The loader should initialize SDRAM before loading the application.</source>
          <target state="translated">为SDRAM构建一个独立的应用程序。正确的启动文件和链接脚本用于将应用程序放入SDRAM，并定义了宏 &lt;code&gt;__BFIN_SDRAM&lt;/code&gt; 。加载程序应在加载应用程序之前初始化SDRAM。</target>
        </trans-unit>
        <trans-unit id="93828509d9639cf155e61322b59daf0187eb136a" translate="yes" xml:space="preserve">
          <source>Build a standalone application for multicore Blackfin processors. This option causes proper start files and link scripts supporting multicore to be used, and defines the macro &lt;code&gt;__BFIN_MULTICORE&lt;/code&gt;. It can only be used with</source>
          <target state="translated">为多核Blackfin处理器构建一个独立的应用程序。该选项导致使用支持多核的正确的启动文件和链接脚本，并定义了宏 &lt;code&gt;__BFIN_MULTICORE&lt;/code&gt; 。它只能与</target>
        </trans-unit>
        <trans-unit id="f3ef0f891e9c255998243907e244b5b488c698cb" translate="yes" xml:space="preserve">
          <source>Build-in macro that resolves to a decimal number that identifies the architecture and depends on the</source>
          <target state="translated">内建宏,解析为标识架构的十进制数,并依赖于</target>
        </trans-unit>
        <trans-unit id="2d34970179e2bcbb0ecc79b090b87f98043678d3" translate="yes" xml:space="preserve">
          <source>Building data dependencies is expensive for very large loops. This parameter limits the number of data references in loops that are considered for data dependence analysis. These large loops are no handled by the optimizations using loop data dependencies.</source>
          <target state="translated">对于非常大的循环来说,建立数据依赖性是很昂贵的。这个参数限制了在数据依赖性分析中考虑的循环中数据引用的数量。使用循环数据依赖的优化不会处理这些大型循环。</target>
        </trans-unit>
        <trans-unit id="2d296efa2545fd43e5ab712c86bbcd120531a39c" translate="yes" xml:space="preserve">
          <source>Built-in Function:  &lt;strong id=&quot;index-_005f_005fbuiltin_005fva_005farg_005fpack&quot;&gt;__builtin_va_arg_pack&lt;/strong&gt; ()</source>
          <target state="translated">内置函数： &lt;strong id=&quot;index-_005f_005fbuiltin_005fva_005farg_005fpack&quot;&gt;__builtin_va_arg_pack&lt;/strong&gt;（）</target>
        </trans-unit>
        <trans-unit id="77cea55a1a3d5467f8414836cb770a0b2fa5b655" translate="yes" xml:space="preserve">
          <source>Built-in Function: &lt;var id=&quot;index-_005f_005fatomic_005fadd_005ffetch&quot;&gt;type&lt;/var&gt;&lt;strong&gt;__atomic_add_fetch&lt;/strong&gt; (&lt;var&gt;type&lt;/var&gt; *ptr, &lt;var&gt;type&lt;/var&gt; val, int memorder)</source>
          <target state="translated">内置功能： &lt;var id=&quot;index-_005f_005fatomic_005fadd_005ffetch&quot;&gt;type&lt;/var&gt; &lt;strong&gt;__atomic_add_fetch&lt;/strong&gt;（ &lt;var&gt;type&lt;/var&gt; * PTR， &lt;var&gt;type&lt;/var&gt; 缬氨酸，INT memorder）</target>
        </trans-unit>
        <trans-unit id="65f1c3be3667c2fa06bb169c518b6d4d03675142" translate="yes" xml:space="preserve">
          <source>Built-in Function: &lt;var id=&quot;index-_005f_005fatomic_005fand_005ffetch&quot;&gt;type&lt;/var&gt;&lt;strong&gt;__atomic_and_fetch&lt;/strong&gt; (&lt;var&gt;type&lt;/var&gt; *ptr, &lt;var&gt;type&lt;/var&gt; val, int memorder)</source>
          <target state="translated">内置功能： &lt;var id=&quot;index-_005f_005fatomic_005fand_005ffetch&quot;&gt;type&lt;/var&gt; &lt;strong&gt;__atomic_and_fetch&lt;/strong&gt;（ &lt;var&gt;type&lt;/var&gt; * PTR， &lt;var&gt;type&lt;/var&gt; 缬氨酸，INT memorder）</target>
        </trans-unit>
        <trans-unit id="a03055a0cd281ae02bbb4f07ca3c585700a7af0b" translate="yes" xml:space="preserve">
          <source>Built-in Function: &lt;var id=&quot;index-_005f_005fatomic_005fexchange_005fn&quot;&gt;type&lt;/var&gt;&lt;strong&gt;__atomic_exchange_n&lt;/strong&gt; (&lt;var&gt;type&lt;/var&gt; *ptr, &lt;var&gt;type&lt;/var&gt; val, int memorder)</source>
          <target state="translated">内置功能： &lt;var id=&quot;index-_005f_005fatomic_005fexchange_005fn&quot;&gt;type&lt;/var&gt; &lt;strong&gt;__atomic_exchange_n&lt;/strong&gt;（ &lt;var&gt;type&lt;/var&gt; * PTR， &lt;var&gt;type&lt;/var&gt; 缬氨酸，INT memorder）</target>
        </trans-unit>
        <trans-unit id="6eb648ab26ef838877bc3cc4ee57b8ff3c3ec10d" translate="yes" xml:space="preserve">
          <source>Built-in Function: &lt;var id=&quot;index-_005f_005fatomic_005ffetch_005fadd&quot;&gt;type&lt;/var&gt;&lt;strong&gt;__atomic_fetch_add&lt;/strong&gt; (&lt;var&gt;type&lt;/var&gt; *ptr, &lt;var&gt;type&lt;/var&gt; val, int memorder)</source>
          <target state="translated">内置功能： &lt;var id=&quot;index-_005f_005fatomic_005ffetch_005fadd&quot;&gt;type&lt;/var&gt; &lt;strong&gt;__atomic_fetch_add&lt;/strong&gt;（ &lt;var&gt;type&lt;/var&gt; * PTR， &lt;var&gt;type&lt;/var&gt; 缬氨酸，INT memorder）</target>
        </trans-unit>
        <trans-unit id="caf737dd7d0b652a623f88bdd6fd64fcd63596e4" translate="yes" xml:space="preserve">
          <source>Built-in Function: &lt;var id=&quot;index-_005f_005fatomic_005ffetch_005fand&quot;&gt;type&lt;/var&gt;&lt;strong&gt;__atomic_fetch_and&lt;/strong&gt; (&lt;var&gt;type&lt;/var&gt; *ptr, &lt;var&gt;type&lt;/var&gt; val, int memorder)</source>
          <target state="translated">内置函数： &lt;var id=&quot;index-_005f_005fatomic_005ffetch_005fand&quot;&gt;type&lt;/var&gt; &lt;strong&gt;__atomic_fetch_and&lt;/strong&gt;（ &lt;var&gt;type&lt;/var&gt; * ptr， &lt;var&gt;type&lt;/var&gt; val，int内存）</target>
        </trans-unit>
        <trans-unit id="f9b1604908ceaddf5e7b79ba9db81f0f1c23485e" translate="yes" xml:space="preserve">
          <source>Built-in Function: &lt;var id=&quot;index-_005f_005fatomic_005ffetch_005fnand&quot;&gt;type&lt;/var&gt;&lt;strong&gt;__atomic_fetch_nand&lt;/strong&gt; (&lt;var&gt;type&lt;/var&gt; *ptr, &lt;var&gt;type&lt;/var&gt; val, int memorder)</source>
          <target state="translated">内置函数： &lt;var id=&quot;index-_005f_005fatomic_005ffetch_005fnand&quot;&gt;type&lt;/var&gt; &lt;strong&gt;__atomic_fetch_nand&lt;/strong&gt;（ &lt;var&gt;type&lt;/var&gt; * ptr， &lt;var&gt;type&lt;/var&gt; val，int内存）</target>
        </trans-unit>
        <trans-unit id="45f4365ebf0124211f5cb2705e77bd2bfd90775d" translate="yes" xml:space="preserve">
          <source>Built-in Function: &lt;var id=&quot;index-_005f_005fatomic_005ffetch_005for&quot;&gt;type&lt;/var&gt;&lt;strong&gt;__atomic_fetch_or&lt;/strong&gt; (&lt;var&gt;type&lt;/var&gt; *ptr, &lt;var&gt;type&lt;/var&gt; val, int memorder)</source>
          <target state="translated">内置功能： &lt;var id=&quot;index-_005f_005fatomic_005ffetch_005for&quot;&gt;type&lt;/var&gt; &lt;strong&gt;__atomic_fetch_or&lt;/strong&gt;（ &lt;var&gt;type&lt;/var&gt; * PTR， &lt;var&gt;type&lt;/var&gt; 缬氨酸，INT memorder）</target>
        </trans-unit>
        <trans-unit id="cf646256d882577bfba56a5678e5b9426274e60b" translate="yes" xml:space="preserve">
          <source>Built-in Function: &lt;var id=&quot;index-_005f_005fatomic_005ffetch_005fsub&quot;&gt;type&lt;/var&gt;&lt;strong&gt;__atomic_fetch_sub&lt;/strong&gt; (&lt;var&gt;type&lt;/var&gt; *ptr, &lt;var&gt;type&lt;/var&gt; val, int memorder)</source>
          <target state="translated">内置功能： &lt;var id=&quot;index-_005f_005fatomic_005ffetch_005fsub&quot;&gt;type&lt;/var&gt; &lt;strong&gt;__atomic_fetch_sub&lt;/strong&gt;（ &lt;var&gt;type&lt;/var&gt; * PTR， &lt;var&gt;type&lt;/var&gt; 缬氨酸，INT memorder）</target>
        </trans-unit>
        <trans-unit id="5041b1cf8f3a6577d287aff4388265cba990c15b" translate="yes" xml:space="preserve">
          <source>Built-in Function: &lt;var id=&quot;index-_005f_005fatomic_005ffetch_005fxor&quot;&gt;type&lt;/var&gt;&lt;strong&gt;__atomic_fetch_xor&lt;/strong&gt; (&lt;var&gt;type&lt;/var&gt; *ptr, &lt;var&gt;type&lt;/var&gt; val, int memorder)</source>
          <target state="translated">内置功能： &lt;var id=&quot;index-_005f_005fatomic_005ffetch_005fxor&quot;&gt;type&lt;/var&gt; &lt;strong&gt;__atomic_fetch_xor&lt;/strong&gt;（ &lt;var&gt;type&lt;/var&gt; * PTR， &lt;var&gt;type&lt;/var&gt; 缬氨酸，INT memorder）</target>
        </trans-unit>
        <trans-unit id="75268ab0697eb9af1dc5c6b541d4d1ba8ac4dbf6" translate="yes" xml:space="preserve">
          <source>Built-in Function: &lt;var id=&quot;index-_005f_005fatomic_005fload_005fn&quot;&gt;type&lt;/var&gt;&lt;strong&gt;__atomic_load_n&lt;/strong&gt; (&lt;var&gt;type&lt;/var&gt; *ptr, int memorder)</source>
          <target state="translated">内置函数： &lt;var id=&quot;index-_005f_005fatomic_005fload_005fn&quot;&gt;type&lt;/var&gt; &lt;strong&gt;__atomic_load_n&lt;/strong&gt;（ &lt;var&gt;type&lt;/var&gt; * ptr，int内存）</target>
        </trans-unit>
        <trans-unit id="cd00e4ef24b741036ea643da78829d2849f8f8d7" translate="yes" xml:space="preserve">
          <source>Built-in Function: &lt;var id=&quot;index-_005f_005fatomic_005fnand_005ffetch&quot;&gt;type&lt;/var&gt;&lt;strong&gt;__atomic_nand_fetch&lt;/strong&gt; (&lt;var&gt;type&lt;/var&gt; *ptr, &lt;var&gt;type&lt;/var&gt; val, int memorder)</source>
          <target state="translated">内置功能： &lt;var id=&quot;index-_005f_005fatomic_005fnand_005ffetch&quot;&gt;type&lt;/var&gt; &lt;strong&gt;__atomic_nand_fetch&lt;/strong&gt;（ &lt;var&gt;type&lt;/var&gt; * PTR， &lt;var&gt;type&lt;/var&gt; 缬氨酸，INT memorder）</target>
        </trans-unit>
        <trans-unit id="a4657eb44924236cf67282c47ad4d932f5594137" translate="yes" xml:space="preserve">
          <source>Built-in Function: &lt;var id=&quot;index-_005f_005fatomic_005for_005ffetch&quot;&gt;type&lt;/var&gt;&lt;strong&gt;__atomic_or_fetch&lt;/strong&gt; (&lt;var&gt;type&lt;/var&gt; *ptr, &lt;var&gt;type&lt;/var&gt; val, int memorder)</source>
          <target state="translated">内置功能： &lt;var id=&quot;index-_005f_005fatomic_005for_005ffetch&quot;&gt;type&lt;/var&gt; &lt;strong&gt;__atomic_or_fetch&lt;/strong&gt;（ &lt;var&gt;type&lt;/var&gt; * PTR， &lt;var&gt;type&lt;/var&gt; 缬氨酸，INT memorder）</target>
        </trans-unit>
        <trans-unit id="57b4ecf7d291340ab5ae6cc114b7f02d58e8a705" translate="yes" xml:space="preserve">
          <source>Built-in Function: &lt;var id=&quot;index-_005f_005fatomic_005fsub_005ffetch&quot;&gt;type&lt;/var&gt;&lt;strong&gt;__atomic_sub_fetch&lt;/strong&gt; (&lt;var&gt;type&lt;/var&gt; *ptr, &lt;var&gt;type&lt;/var&gt; val, int memorder)</source>
          <target state="translated">内置功能： &lt;var id=&quot;index-_005f_005fatomic_005fsub_005ffetch&quot;&gt;type&lt;/var&gt; &lt;strong&gt;__atomic_sub_fetch&lt;/strong&gt;（ &lt;var&gt;type&lt;/var&gt; * PTR， &lt;var&gt;type&lt;/var&gt; 缬氨酸，INT memorder）</target>
        </trans-unit>
        <trans-unit id="a52f64419e32735eabc4e3c18aa68dedfb2e4625" translate="yes" xml:space="preserve">
          <source>Built-in Function: &lt;var id=&quot;index-_005f_005fatomic_005fxor_005ffetch&quot;&gt;type&lt;/var&gt;&lt;strong&gt;__atomic_xor_fetch&lt;/strong&gt; (&lt;var&gt;type&lt;/var&gt; *ptr, &lt;var&gt;type&lt;/var&gt; val, int memorder)</source>
          <target state="translated">内置功能： &lt;var id=&quot;index-_005f_005fatomic_005fxor_005ffetch&quot;&gt;type&lt;/var&gt; &lt;strong&gt;__atomic_xor_fetch&lt;/strong&gt;（ &lt;var&gt;type&lt;/var&gt; * PTR， &lt;var&gt;type&lt;/var&gt; 缬氨酸，INT memorder）</target>
        </trans-unit>
        <trans-unit id="1167cb7b44d7d9f620598ea0aefcbfdf9dc55a1f" translate="yes" xml:space="preserve">
          <source>Built-in Function: &lt;var id=&quot;index-_005f_005fbuiltin_005fcall_005fwith_005fstatic_005fchain-1&quot;&gt;type&lt;/var&gt;&lt;strong&gt;__builtin_call_with_static_chain&lt;/strong&gt; (&lt;var&gt;call_exp&lt;/var&gt;, &lt;var&gt;pointer_exp&lt;/var&gt;)</source>
          <target state="translated">内置函数： &lt;var id=&quot;index-_005f_005fbuiltin_005fcall_005fwith_005fstatic_005fchain-1&quot;&gt;type&lt;/var&gt; &lt;strong&gt;__builtin_call_with_static_chain&lt;/strong&gt;（ &lt;var&gt;call_exp&lt;/var&gt; ， &lt;var&gt;pointer_exp&lt;/var&gt; ）</target>
        </trans-unit>
        <trans-unit id="34f799a7c8358da11b0de0991867b1ca62dd416b" translate="yes" xml:space="preserve">
          <source>Built-in Function: &lt;var id=&quot;index-_005f_005fbuiltin_005fchoose_005fexpr&quot;&gt;type&lt;/var&gt;&lt;strong&gt;__builtin_choose_expr&lt;/strong&gt; (&lt;var&gt;const_exp&lt;/var&gt;, &lt;var&gt;exp1&lt;/var&gt;, &lt;var&gt;exp2&lt;/var&gt;)</source>
          <target state="translated">内置函数： &lt;var id=&quot;index-_005f_005fbuiltin_005fchoose_005fexpr&quot;&gt;type&lt;/var&gt; &lt;strong&gt;__builtin_choose_expr&lt;/strong&gt;（ &lt;var&gt;const_exp&lt;/var&gt; ， &lt;var&gt;exp1&lt;/var&gt; ， &lt;var&gt;exp2&lt;/var&gt; ）</target>
        </trans-unit>
        <trans-unit id="11e363a3b892d8f6c1c1fdfdd845f80862a3606b" translate="yes" xml:space="preserve">
          <source>Built-in Function: &lt;var id=&quot;index-_005f_005fbuiltin_005fcomplex&quot;&gt;type&lt;/var&gt;&lt;strong&gt;__builtin_complex&lt;/strong&gt; (&lt;var&gt;real&lt;/var&gt;, &lt;var&gt;imag&lt;/var&gt;)</source>
          <target state="translated">内置函数： &lt;var id=&quot;index-_005f_005fbuiltin_005fcomplex&quot;&gt;type&lt;/var&gt; &lt;strong&gt;__builtin_complex&lt;/strong&gt;（ &lt;var&gt;real&lt;/var&gt; ， &lt;var&gt;imag&lt;/var&gt; ）</target>
        </trans-unit>
        <trans-unit id="9eec0865162048e6dccab85fb3d740aa5f07fc05" translate="yes" xml:space="preserve">
          <source>Built-in Function: &lt;var id=&quot;index-_005f_005fbuiltin_005fspeculation_005fsafe_005fvalue-1&quot;&gt;type&lt;/var&gt;&lt;strong&gt;__builtin_speculation_safe_value&lt;/strong&gt; (&lt;var&gt;type&lt;/var&gt; val, &lt;var&gt;type&lt;/var&gt; failval)</source>
          <target state="translated">内置函数： &lt;var id=&quot;index-_005f_005fbuiltin_005fspeculation_005fsafe_005fvalue-1&quot;&gt;type&lt;/var&gt; &lt;strong&gt;__builtin_speculation_safe_value&lt;/strong&gt;（ &lt;var&gt;type&lt;/var&gt; val， &lt;var&gt;type&lt;/var&gt; failval）</target>
        </trans-unit>
        <trans-unit id="7c5c7616bd765dd4fc8d843ce99908ad16336f51" translate="yes" xml:space="preserve">
          <source>Built-in Function: &lt;var id=&quot;index-_005f_005fbuiltin_005ftgmath&quot;&gt;type&lt;/var&gt;&lt;strong&gt;__builtin_tgmath&lt;/strong&gt; (&lt;var&gt;functions&lt;/var&gt;, &lt;var&gt;arguments&lt;/var&gt;)</source>
          <target state="translated">内置函数： &lt;var id=&quot;index-_005f_005fbuiltin_005ftgmath&quot;&gt;type&lt;/var&gt; &lt;strong&gt;__builtin_tgmath&lt;/strong&gt;（ &lt;var&gt;functions&lt;/var&gt; ， &lt;var&gt;arguments&lt;/var&gt; ）</target>
        </trans-unit>
        <trans-unit id="e3600affbf40f82a1f599528ce0f72402f629874" translate="yes" xml:space="preserve">
          <source>Built-in Function: Pmode &lt;strong id=&quot;index-_005f_005fbuiltin_005fextend_005fpointer-1&quot;&gt;__builtin_extend_pointer&lt;/strong&gt; (void * x)</source>
          <target state="translated">内置函数：Pmode &lt;strong id=&quot;index-_005f_005fbuiltin_005fextend_005fpointer-1&quot;&gt;__builtin_extend_pointer&lt;/strong&gt;（void * x）</target>
        </trans-unit>
        <trans-unit id="b7ca6e3021fea0b720388d29d28e89de6177efaa" translate="yes" xml:space="preserve">
          <source>Built-in Function: _Decimal128 &lt;strong id=&quot;index-_005f_005fbuiltin_005finfd128&quot;&gt;__builtin_infd128&lt;/strong&gt; (void)</source>
          <target state="translated">内置函数：_Decimal128 &lt;strong id=&quot;index-_005f_005fbuiltin_005finfd128&quot;&gt;__builtin_infd128&lt;/strong&gt;（void）</target>
        </trans-unit>
        <trans-unit id="bf8fbba0296cd046f79b2f8fac454e9f96b680c3" translate="yes" xml:space="preserve">
          <source>Built-in Function: _Decimal128 &lt;strong id=&quot;index-_005f_005fbuiltin_005fnand128&quot;&gt;__builtin_nand128&lt;/strong&gt; (const char *str)</source>
          <target state="translated">内置函数：_Decimal128 &lt;strong id=&quot;index-_005f_005fbuiltin_005fnand128&quot;&gt;__builtin_nand128&lt;/strong&gt;（const char * str）</target>
        </trans-unit>
        <trans-unit id="ad3f5c8f497e0e257636ccbaf6459ad1ad8e6479" translate="yes" xml:space="preserve">
          <source>Built-in Function: _Decimal32 &lt;strong id=&quot;index-_005f_005fbuiltin_005finfd32&quot;&gt;__builtin_infd32&lt;/strong&gt; (void)</source>
          <target state="translated">内置函数：_Decimal32 &lt;strong id=&quot;index-_005f_005fbuiltin_005finfd32&quot;&gt;__builtin_infd32&lt;/strong&gt;（无效）</target>
        </trans-unit>
        <trans-unit id="2d12b2517571e9887a8920d94ebf233b53b0d3e9" translate="yes" xml:space="preserve">
          <source>Built-in Function: _Decimal32 &lt;strong id=&quot;index-_005f_005fbuiltin_005fnand32&quot;&gt;__builtin_nand32&lt;/strong&gt; (const char *str)</source>
          <target state="translated">内置函数：_Decimal32 &lt;strong id=&quot;index-_005f_005fbuiltin_005fnand32&quot;&gt;__builtin_nand32&lt;/strong&gt;（const char * str）</target>
        </trans-unit>
        <trans-unit id="c4f59dbda6a0f6f12e013b7d8146bb95b52fddbf" translate="yes" xml:space="preserve">
          <source>Built-in Function: _Decimal64 &lt;strong id=&quot;index-_005f_005fbuiltin_005finfd64&quot;&gt;__builtin_infd64&lt;/strong&gt; (void)</source>
          <target state="translated">内置函数：_Decimal64 &lt;strong id=&quot;index-_005f_005fbuiltin_005finfd64&quot;&gt;__builtin_infd64&lt;/strong&gt;（无效）</target>
        </trans-unit>
        <trans-unit id="dcf12c95c5e2671a78a61f716ad8c91e6ab3dca2" translate="yes" xml:space="preserve">
          <source>Built-in Function: _Decimal64 &lt;strong id=&quot;index-_005f_005fbuiltin_005fnand64&quot;&gt;__builtin_nand64&lt;/strong&gt; (const char *str)</source>
          <target state="translated">内置函数：_Decimal64 &lt;strong id=&quot;index-_005f_005fbuiltin_005fnand64&quot;&gt;__builtin_nand64&lt;/strong&gt;（const char * str）</target>
        </trans-unit>
        <trans-unit id="e065d1bdd11d40eb46afaa76c7e3c275e0e7c656" translate="yes" xml:space="preserve">
          <source>Built-in Function: _Float&lt;var id=&quot;index-_005f_005fbuiltin_005fhuge_005fvalfn&quot;&gt;n&lt;/var&gt;&lt;strong&gt;__builtin_huge_valf&lt;var&gt;n&lt;/var&gt;&lt;/strong&gt; (void)</source>
          <target state="translated">内置函数：_Float &lt;var id=&quot;index-_005f_005fbuiltin_005fhuge_005fvalfn&quot;&gt;n&lt;/var&gt; &lt;strong&gt;__builtin_huge_valf &lt;var&gt;n&lt;/var&gt; &lt;/strong&gt;（无效）</target>
        </trans-unit>
        <trans-unit id="bc1ad27f368302d827ffdedc2f161e1a34576916" translate="yes" xml:space="preserve">
          <source>Built-in Function: _Float&lt;var id=&quot;index-_005f_005fbuiltin_005fhuge_005fvalfnx&quot;&gt;n&lt;/var&gt;x &lt;strong&gt;__builtin_huge_valf&lt;var&gt;n&lt;/var&gt;x&lt;/strong&gt; (void)</source>
          <target state="translated">内置函数：_Float &lt;var id=&quot;index-_005f_005fbuiltin_005fhuge_005fvalfnx&quot;&gt;n&lt;/var&gt; x &lt;strong&gt;__builtin_huge_valf &lt;var&gt;n&lt;/var&gt; x&lt;/strong&gt;（无效）</target>
        </trans-unit>
        <trans-unit id="4f4a5dc00bc657abe7ad80938a7d60c8e79b5015" translate="yes" xml:space="preserve">
          <source>Built-in Function: _Float&lt;var id=&quot;index-_005f_005fbuiltin_005finffn&quot;&gt;n&lt;/var&gt;&lt;strong&gt;__builtin_inff&lt;var&gt;n&lt;/var&gt;&lt;/strong&gt; (void)</source>
          <target state="translated">内置函数：_Float &lt;var id=&quot;index-_005f_005fbuiltin_005finffn&quot;&gt;n&lt;/var&gt; &lt;strong&gt;__builtin_inff &lt;var&gt;n&lt;/var&gt; &lt;/strong&gt;（无效）</target>
        </trans-unit>
        <trans-unit id="28b60d24ae373b1240786dec7b198434f539e010" translate="yes" xml:space="preserve">
          <source>Built-in Function: _Float&lt;var id=&quot;index-_005f_005fbuiltin_005finffnx&quot;&gt;n&lt;/var&gt;&lt;strong&gt;__builtin_inff&lt;var&gt;n&lt;/var&gt;x&lt;/strong&gt; (void)</source>
          <target state="translated">内置函数：_Float &lt;var id=&quot;index-_005f_005fbuiltin_005finffnx&quot;&gt;n&lt;/var&gt; &lt;strong&gt;__builtin_inff &lt;var&gt;n&lt;/var&gt; x&lt;/strong&gt;（无效）</target>
        </trans-unit>
        <trans-unit id="bf9f5f175d78dc2baeeae0348c4b4da7826acad2" translate="yes" xml:space="preserve">
          <source>Built-in Function: _Float&lt;var id=&quot;index-_005f_005fbuiltin_005fnanfn&quot;&gt;n&lt;/var&gt;&lt;strong&gt;__builtin_nanf&lt;var&gt;n&lt;/var&gt;&lt;/strong&gt; (const char *str)</source>
          <target state="translated">内置函数：_Float &lt;var id=&quot;index-_005f_005fbuiltin_005fnanfn&quot;&gt;n&lt;/var&gt; &lt;strong&gt;__builtin_nanf &lt;var&gt;n&lt;/var&gt; &lt;/strong&gt;（const char * str）</target>
        </trans-unit>
        <trans-unit id="d8897a35cb1a3842c5a7b59ff4525f61eb36974a" translate="yes" xml:space="preserve">
          <source>Built-in Function: _Float&lt;var id=&quot;index-_005f_005fbuiltin_005fnanfnx&quot;&gt;n&lt;/var&gt;x &lt;strong&gt;__builtin_nanf&lt;var&gt;n&lt;/var&gt;x&lt;/strong&gt; (const char *str)</source>
          <target state="translated">内置函数：_Float &lt;var id=&quot;index-_005f_005fbuiltin_005fnanfnx&quot;&gt;n&lt;/var&gt; x &lt;strong&gt;__builtin_nanf &lt;var&gt;n&lt;/var&gt; x&lt;/strong&gt;（const char * str）</target>
        </trans-unit>
        <trans-unit id="1bd15fd91da1a9d9a87216c52e010f17bc3d22e6" translate="yes" xml:space="preserve">
          <source>Built-in Function: _Float&lt;var id=&quot;index-_005f_005fbuiltin_005fnansfn&quot;&gt;n&lt;/var&gt;&lt;strong&gt;__builtin_nansf&lt;var&gt;n&lt;/var&gt;&lt;/strong&gt; (const char *str)</source>
          <target state="translated">内置函数：_Float &lt;var id=&quot;index-_005f_005fbuiltin_005fnansfn&quot;&gt;n&lt;/var&gt; &lt;strong&gt;__builtin_nansf &lt;var&gt;n&lt;/var&gt; &lt;/strong&gt;（const char * str）</target>
        </trans-unit>
        <trans-unit id="615e03fdb9ea794729a2a1d7c358b1e301921c3b" translate="yes" xml:space="preserve">
          <source>Built-in Function: _Float&lt;var id=&quot;index-_005f_005fbuiltin_005fnansfnx&quot;&gt;n&lt;/var&gt;x &lt;strong&gt;__builtin_nansf&lt;var&gt;n&lt;/var&gt;x&lt;/strong&gt; (const char *str)</source>
          <target state="translated">内置函数：_Float &lt;var id=&quot;index-_005f_005fbuiltin_005fnansfnx&quot;&gt;n&lt;/var&gt; x &lt;strong&gt;__builtin_nansf &lt;var&gt;n&lt;/var&gt; x&lt;/strong&gt;（const char * str）</target>
        </trans-unit>
        <trans-unit id="f520d1247e2979f87ba6e5662e70795dbd438963" translate="yes" xml:space="preserve">
          <source>Built-in Function: bool &lt;strong id=&quot;index-_005f_005fatomic_005falways_005flock_005ffree&quot;&gt;__atomic_always_lock_free&lt;/strong&gt; (size_t size, void *ptr)</source>
          <target state="translated">内置函数：bool &lt;strong id=&quot;index-_005f_005fatomic_005falways_005flock_005ffree&quot;&gt;__atomic_always_lock_free&lt;/strong&gt;（size_t size，void * ptr）</target>
        </trans-unit>
        <trans-unit id="24b1fe88fa6197e2c0740249ab472fde949dc447" translate="yes" xml:space="preserve">
          <source>Built-in Function: bool &lt;strong id=&quot;index-_005f_005fatomic_005fcompare_005fexchange&quot;&gt;__atomic_compare_exchange&lt;/strong&gt; (&lt;var&gt;type&lt;/var&gt; *ptr, &lt;var&gt;type&lt;/var&gt; *expected, &lt;var&gt;type&lt;/var&gt; *desired, bool weak, int success_memorder, int failure_memorder)</source>
          <target state="translated">内置函数：bool &lt;strong id=&quot;index-_005f_005fatomic_005fcompare_005fexchange&quot;&gt;__atomic_compare_exchange&lt;/strong&gt;（ &lt;var&gt;type&lt;/var&gt; * ptr， &lt;var&gt;type&lt;/var&gt; * expected， &lt;var&gt;type&lt;/var&gt; * desired，布尔强度弱，int success_memorder，int failure_memorder）</target>
        </trans-unit>
        <trans-unit id="e0cae369ba572d6fc730f1208ec5ebfd8c31b5c9" translate="yes" xml:space="preserve">
          <source>Built-in Function: bool &lt;strong id=&quot;index-_005f_005fatomic_005fcompare_005fexchange_005fn&quot;&gt;__atomic_compare_exchange_n&lt;/strong&gt; (&lt;var&gt;type&lt;/var&gt; *ptr, &lt;var&gt;type&lt;/var&gt; *expected, &lt;var&gt;type&lt;/var&gt; desired, bool weak, int success_memorder, int failure_memorder)</source>
          <target state="translated">内置函数：bool &lt;strong id=&quot;index-_005f_005fatomic_005fcompare_005fexchange_005fn&quot;&gt;__atomic_compare_exchange_n&lt;/strong&gt;（ &lt;var&gt;type&lt;/var&gt; * ptr， &lt;var&gt;type&lt;/var&gt; * expected，所需 &lt;var&gt;type&lt;/var&gt; ，布尔值弱，int success_memorder，int failure_memorder）</target>
        </trans-unit>
        <trans-unit id="e6ff9b335ec817f16bd5f09bc44d64b4868726b1" translate="yes" xml:space="preserve">
          <source>Built-in Function: bool &lt;strong id=&quot;index-_005f_005fatomic_005fis_005flock_005ffree&quot;&gt;__atomic_is_lock_free&lt;/strong&gt; (size_t size, void *ptr)</source>
          <target state="translated">内置函数：bool &lt;strong id=&quot;index-_005f_005fatomic_005fis_005flock_005ffree&quot;&gt;__atomic_is_lock_free&lt;/strong&gt;（size_t size，void * ptr）</target>
        </trans-unit>
        <trans-unit id="24aee6114b477fd331dab8c2aef844fb97f49851" translate="yes" xml:space="preserve">
          <source>Built-in Function: bool &lt;strong id=&quot;index-_005f_005fatomic_005ftest_005fand_005fset&quot;&gt;__atomic_test_and_set&lt;/strong&gt; (void *ptr, int memorder)</source>
          <target state="translated">内置函数：bool &lt;strong id=&quot;index-_005f_005fatomic_005ftest_005fand_005fset&quot;&gt;__atomic_test_and_set&lt;/strong&gt;（void * ptr，int memorder）</target>
        </trans-unit>
        <trans-unit id="64b8a4ae04512641547c12a9c73d39675cb460a9" translate="yes" xml:space="preserve">
          <source>Built-in Function: bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fadd_005foverflow&quot;&gt;__builtin_add_overflow&lt;/strong&gt; (&lt;var&gt;type1&lt;/var&gt; a, &lt;var&gt;type2&lt;/var&gt; b, &lt;var&gt;type3&lt;/var&gt; *res)</source>
          <target state="translated">内置函数：bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fadd_005foverflow&quot;&gt;__builtin_add_overflow&lt;/strong&gt;（ &lt;var&gt;type1&lt;/var&gt; a， &lt;var&gt;type2&lt;/var&gt; b， &lt;var&gt;type3&lt;/var&gt; * res）</target>
        </trans-unit>
        <trans-unit id="af59554b89a8bf55a3dc48af48346f20f06e852a" translate="yes" xml:space="preserve">
          <source>Built-in Function: bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fadd_005foverflow_005fp&quot;&gt;__builtin_add_overflow_p&lt;/strong&gt; (&lt;var&gt;type1&lt;/var&gt; a, &lt;var&gt;type2&lt;/var&gt; b, &lt;var&gt;type3&lt;/var&gt; c)</source>
          <target state="translated">内置函数：bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fadd_005foverflow_005fp&quot;&gt;__builtin_add_overflow_p&lt;/strong&gt;（ &lt;var&gt;type1&lt;/var&gt; a， &lt;var&gt;type2&lt;/var&gt; b， &lt;var&gt;type3&lt;/var&gt; c）</target>
        </trans-unit>
        <trans-unit id="be98828c48e0d16aa6b6e2421edf84970dc86a6f" translate="yes" xml:space="preserve">
          <source>Built-in Function: bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fhas_005fattribute-1&quot;&gt;__builtin_has_attribute&lt;/strong&gt; (&lt;var&gt;type-or-expression&lt;/var&gt;, &lt;var&gt;attribute&lt;/var&gt;)</source>
          <target state="translated">内置函数：bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fhas_005fattribute-1&quot;&gt;__builtin_has_attribute&lt;/strong&gt;（ &lt;var&gt;type-or-expression&lt;/var&gt; ， &lt;var&gt;attribute&lt;/var&gt; ）</target>
        </trans-unit>
        <trans-unit id="b7e50b8a64da2b188793a4579bb5cae5cac82268" translate="yes" xml:space="preserve">
          <source>Built-in Function: bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fis_005fconstant_005fevaluated&quot;&gt;__builtin_is_constant_evaluated&lt;/strong&gt; (void)</source>
          <target state="translated">内置函数：bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fis_005fconstant_005fevaluated&quot;&gt;__builtin_is_constant_evaluated&lt;/strong&gt;（void）</target>
        </trans-unit>
        <trans-unit id="ee9d3aabacf2156e5d393cd93749ff7c8037d66e" translate="yes" xml:space="preserve">
          <source>Built-in Function: bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fmul_005foverflow&quot;&gt;__builtin_mul_overflow&lt;/strong&gt; (&lt;var&gt;type1&lt;/var&gt; a, &lt;var&gt;type2&lt;/var&gt; b, &lt;var&gt;type3&lt;/var&gt; *res)</source>
          <target state="translated">内置函数：bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fmul_005foverflow&quot;&gt;__builtin_mul_overflow&lt;/strong&gt;（ &lt;var&gt;type1&lt;/var&gt; a， &lt;var&gt;type2&lt;/var&gt; b， &lt;var&gt;type3&lt;/var&gt; * res）</target>
        </trans-unit>
        <trans-unit id="8fd735437fc9239fd342fe45001594bf9731cdde" translate="yes" xml:space="preserve">
          <source>Built-in Function: bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fmul_005foverflow_005fp&quot;&gt;__builtin_mul_overflow_p&lt;/strong&gt; (&lt;var&gt;type1&lt;/var&gt; a, &lt;var&gt;type2&lt;/var&gt; b, &lt;var&gt;type3&lt;/var&gt; c)</source>
          <target state="translated">内置函数：bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fmul_005foverflow_005fp&quot;&gt;__builtin_mul_overflow_p&lt;/strong&gt;（ &lt;var&gt;type1&lt;/var&gt; a， &lt;var&gt;type2&lt;/var&gt; b， &lt;var&gt;type3&lt;/var&gt; c）</target>
        </trans-unit>
        <trans-unit id="25ee4265411f06ce5b584d4448bc72ef70be2921" translate="yes" xml:space="preserve">
          <source>Built-in Function: bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fsadd_005foverflow&quot;&gt;__builtin_sadd_overflow&lt;/strong&gt; (int a, int b, int *res)</source>
          <target state="translated">内置函数：bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fsadd_005foverflow&quot;&gt;__builtin_sadd_overflow&lt;/strong&gt;（int a，int b，int * res）</target>
        </trans-unit>
        <trans-unit id="69472084a70d9c551110645ab2de32722f859a56" translate="yes" xml:space="preserve">
          <source>Built-in Function: bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fsaddl_005foverflow&quot;&gt;__builtin_saddl_overflow&lt;/strong&gt; (long int a, long int b, long int *res)</source>
          <target state="translated">内置函数：bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fsaddl_005foverflow&quot;&gt;__builtin_saddl_overflow&lt;/strong&gt;（长整数a，长整数b，长整数* res）</target>
        </trans-unit>
        <trans-unit id="d167da624174d67a584837afb39ffafce3529192" translate="yes" xml:space="preserve">
          <source>Built-in Function: bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fsaddll_005foverflow&quot;&gt;__builtin_saddll_overflow&lt;/strong&gt; (long long int a, long long int b, long long int *res)</source>
          <target state="translated">内置函数：bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fsaddll_005foverflow&quot;&gt;__builtin_saddll_overflow&lt;/strong&gt;（long long int a，long long int b，long long int * res）</target>
        </trans-unit>
        <trans-unit id="0751d990e1a6176428723a69b8b9d35eb80fd837" translate="yes" xml:space="preserve">
          <source>Built-in Function: bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fsmul_005foverflow&quot;&gt;__builtin_smul_overflow&lt;/strong&gt; (int a, int b, int *res)</source>
          <target state="translated">内置函数：bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fsmul_005foverflow&quot;&gt;__builtin_smul_overflow&lt;/strong&gt;（int a，int b，int * res）</target>
        </trans-unit>
        <trans-unit id="956b1e662b4c40d70010047e2d0274713e3963f3" translate="yes" xml:space="preserve">
          <source>Built-in Function: bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fsmull_005foverflow&quot;&gt;__builtin_smull_overflow&lt;/strong&gt; (long int a, long int b, long int *res)</source>
          <target state="translated">内置函数：bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fsmull_005foverflow&quot;&gt;__builtin_smull_overflow&lt;/strong&gt;（长整数a，长整数b，长整数* res）</target>
        </trans-unit>
        <trans-unit id="90b14c01667b17099ca43e693ecf1b190d3e0c9b" translate="yes" xml:space="preserve">
          <source>Built-in Function: bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fsmulll_005foverflow&quot;&gt;__builtin_smulll_overflow&lt;/strong&gt; (long long int a, long long int b, long long int *res)</source>
          <target state="translated">内置函数：bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fsmulll_005foverflow&quot;&gt;__builtin_smulll_overflow&lt;/strong&gt;（long long int a，long long int b，long long int * res）</target>
        </trans-unit>
        <trans-unit id="77b2f488874750806435b3aaff4f191420925191" translate="yes" xml:space="preserve">
          <source>Built-in Function: bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fssub_005foverflow&quot;&gt;__builtin_ssub_overflow&lt;/strong&gt; (int a, int b, int *res)</source>
          <target state="translated">内置函数：bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fssub_005foverflow&quot;&gt;__builtin_ssub_overflow&lt;/strong&gt;（int a，int b，int * res）</target>
        </trans-unit>
        <trans-unit id="49724eb9cf1b5f433d9a763058afdd03539a15c8" translate="yes" xml:space="preserve">
          <source>Built-in Function: bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fssubl_005foverflow&quot;&gt;__builtin_ssubl_overflow&lt;/strong&gt; (long int a, long int b, long int *res)</source>
          <target state="translated">内置函数：bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fssubl_005foverflow&quot;&gt;__builtin_ssubl_overflow&lt;/strong&gt;（长整数a，长整数b，长整数* res）</target>
        </trans-unit>
        <trans-unit id="8bb17f1956b296109f50ac2e4c7c8a50ec613924" translate="yes" xml:space="preserve">
          <source>Built-in Function: bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fssubll_005foverflow&quot;&gt;__builtin_ssubll_overflow&lt;/strong&gt; (long long int a, long long int b, long long int *res)</source>
          <target state="translated">内置函数：bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fssubll_005foverflow&quot;&gt;__builtin_ssubll_overflow&lt;/strong&gt;（long long int a，long long int b，long long int * res）</target>
        </trans-unit>
        <trans-unit id="3ca0d6297a605dc41e2b859a3577a44be6641a95" translate="yes" xml:space="preserve">
          <source>Built-in Function: bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fsub_005foverflow&quot;&gt;__builtin_sub_overflow&lt;/strong&gt; (&lt;var&gt;type1&lt;/var&gt; a, &lt;var&gt;type2&lt;/var&gt; b, &lt;var&gt;type3&lt;/var&gt; *res)</source>
          <target state="translated">内置函数：bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fsub_005foverflow&quot;&gt;__builtin_sub_overflow&lt;/strong&gt;（ &lt;var&gt;type1&lt;/var&gt; a， &lt;var&gt;type2&lt;/var&gt; b， &lt;var&gt;type3&lt;/var&gt; * res）</target>
        </trans-unit>
        <trans-unit id="cc3ccbf74e07a994d7fa1a99c72273b8a5afff58" translate="yes" xml:space="preserve">
          <source>Built-in Function: bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fsub_005foverflow_005fp&quot;&gt;__builtin_sub_overflow_p&lt;/strong&gt; (&lt;var&gt;type1&lt;/var&gt; a, &lt;var&gt;type2&lt;/var&gt; b, &lt;var&gt;type3&lt;/var&gt; c)</source>
          <target state="translated">内置函数：bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fsub_005foverflow_005fp&quot;&gt;__builtin_sub_overflow_p&lt;/strong&gt;（ &lt;var&gt;type1&lt;/var&gt; a， &lt;var&gt;type2&lt;/var&gt; b， &lt;var&gt;type3&lt;/var&gt; c）</target>
        </trans-unit>
        <trans-unit id="5b02b9649ef1800e43226f7e7109d8bbef8357dc" translate="yes" xml:space="preserve">
          <source>Built-in Function: bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fuadd_005foverflow&quot;&gt;__builtin_uadd_overflow&lt;/strong&gt; (unsigned int a, unsigned int b, unsigned int *res)</source>
          <target state="translated">内置函数：bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fuadd_005foverflow&quot;&gt;__builtin_uadd_overflow&lt;/strong&gt;（无符号整数a，无符号整数b，无符号整数* res）</target>
        </trans-unit>
        <trans-unit id="567411aa095944ed062923c573393ad7b9494fcc" translate="yes" xml:space="preserve">
          <source>Built-in Function: bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fuaddl_005foverflow&quot;&gt;__builtin_uaddl_overflow&lt;/strong&gt; (unsigned long int a, unsigned long int b, unsigned long int *res)</source>
          <target state="translated">内置函数：bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fuaddl_005foverflow&quot;&gt;__builtin_uaddl_overflow&lt;/strong&gt;（无符号长整数a，无符号长整数b，无符号长整数* res）</target>
        </trans-unit>
        <trans-unit id="a7d580478c24cd4b2a59ce2c1f75d3bbd1e01675" translate="yes" xml:space="preserve">
          <source>Built-in Function: bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fuaddll_005foverflow&quot;&gt;__builtin_uaddll_overflow&lt;/strong&gt; (unsigned long long int a, unsigned long long int b, unsigned long long int *res)</source>
          <target state="translated">内置函数：bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fuaddll_005foverflow&quot;&gt;__builtin_uaddll_overflow&lt;/strong&gt;（unsigned long long int a，unsigned long long int b，unsigned long long int * res）</target>
        </trans-unit>
        <trans-unit id="4df720b89a79aa504ee2325733fecf62f5d154df" translate="yes" xml:space="preserve">
          <source>Built-in Function: bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fumul_005foverflow&quot;&gt;__builtin_umul_overflow&lt;/strong&gt; (unsigned int a, unsigned int b, unsigned int *res)</source>
          <target state="translated">内置函数：bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fumul_005foverflow&quot;&gt;__builtin_umul_overflow&lt;/strong&gt;（无符号整数a，无符号整数b，无符号整数* res）</target>
        </trans-unit>
        <trans-unit id="127b7aa724932fc0c15543b161cf5ca336f40c65" translate="yes" xml:space="preserve">
          <source>Built-in Function: bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fumull_005foverflow&quot;&gt;__builtin_umull_overflow&lt;/strong&gt; (unsigned long int a, unsigned long int b, unsigned long int *res)</source>
          <target state="translated">内置函数：bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fumull_005foverflow&quot;&gt;__builtin_umull_overflow&lt;/strong&gt;（无符号长整数a，无符号长整数b，无符号长整数* res）</target>
        </trans-unit>
        <trans-unit id="6e0e5de085f1421cd056a7b7c2d1ac4593a791e8" translate="yes" xml:space="preserve">
          <source>Built-in Function: bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fumulll_005foverflow&quot;&gt;__builtin_umulll_overflow&lt;/strong&gt; (unsigned long long int a, unsigned long long int b, unsigned long long int *res)</source>
          <target state="translated">内置函数：bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fumulll_005foverflow&quot;&gt;__builtin_umulll_overflow&lt;/strong&gt;（unsigned long long int a，unsigned long long int b，unsigned long long int * res）</target>
        </trans-unit>
        <trans-unit id="43f0099aa9a654a142bfe318e5e28643d8ddc6f6" translate="yes" xml:space="preserve">
          <source>Built-in Function: bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fusub_005foverflow&quot;&gt;__builtin_usub_overflow&lt;/strong&gt; (unsigned int a, unsigned int b, unsigned int *res)</source>
          <target state="translated">内置函数：bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fusub_005foverflow&quot;&gt;__builtin_usub_overflow&lt;/strong&gt;（无符号整数a，无符号整数b，无符号整数* res）</target>
        </trans-unit>
        <trans-unit id="1c5542c5653c759c2ffcd0eb56e8e4fce2653611" translate="yes" xml:space="preserve">
          <source>Built-in Function: bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fusubl_005foverflow&quot;&gt;__builtin_usubl_overflow&lt;/strong&gt; (unsigned long int a, unsigned long int b, unsigned long int *res)</source>
          <target state="translated">内置函数：bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fusubl_005foverflow&quot;&gt;__builtin_usubl_overflow&lt;/strong&gt;（无符号长整数a，无符号长整数b，无符号长整数* res）</target>
        </trans-unit>
        <trans-unit id="8967205f7b6c405e734e918e4030fc20dcc7a6e8" translate="yes" xml:space="preserve">
          <source>Built-in Function: bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fusubll_005foverflow&quot;&gt;__builtin_usubll_overflow&lt;/strong&gt; (unsigned long long int a, unsigned long long int b, unsigned long long int *res)</source>
          <target state="translated">内置函数：bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fusubll_005foverflow&quot;&gt;__builtin_usubll_overflow&lt;/strong&gt;（无符号长整型a，无符号长整型b，无符号长整型* res）</target>
        </trans-unit>
        <trans-unit id="3d3ebe01d55449070f5b00bc45933b6ab0472f70" translate="yes" xml:space="preserve">
          <source>Built-in Function: const char * &lt;strong id=&quot;index-_005f_005fbuiltin_005fFILE&quot;&gt;__builtin_FILE&lt;/strong&gt; ()</source>
          <target state="translated">内置函数：const char * &lt;strong id=&quot;index-_005f_005fbuiltin_005fFILE&quot;&gt;__builtin_FILE&lt;/strong&gt;（）</target>
        </trans-unit>
        <trans-unit id="0721ec3a797458f28da3b2711e9fc2d2af1823e2" translate="yes" xml:space="preserve">
          <source>Built-in Function: const char * &lt;strong id=&quot;index-_005f_005fbuiltin_005fFUNCTION&quot;&gt;__builtin_FUNCTION&lt;/strong&gt; ()</source>
          <target state="translated">内置函数：const char * &lt;strong id=&quot;index-_005f_005fbuiltin_005fFUNCTION&quot;&gt;__builtin_FUNCTION&lt;/strong&gt;（）</target>
        </trans-unit>
        <trans-unit id="2a1712d1ad359c0cac12cd7a3537116bd9e795fc" translate="yes" xml:space="preserve">
          <source>Built-in Function: double &lt;strong id=&quot;index-_005f_005fbuiltin_005fhuge_005fval&quot;&gt;__builtin_huge_val&lt;/strong&gt; (void)</source>
          <target state="translated">内置函数：double &lt;strong id=&quot;index-_005f_005fbuiltin_005fhuge_005fval&quot;&gt;__builtin_huge_val&lt;/strong&gt;（void）</target>
        </trans-unit>
        <trans-unit id="ffafe4d74af74fb9ca60ea9821704b751632b93c" translate="yes" xml:space="preserve">
          <source>Built-in Function: double &lt;strong id=&quot;index-_005f_005fbuiltin_005finf&quot;&gt;__builtin_inf&lt;/strong&gt; (void)</source>
          <target state="translated">内置函数：double &lt;strong id=&quot;index-_005f_005fbuiltin_005finf&quot;&gt;__builtin_inf&lt;/strong&gt;（void）</target>
        </trans-unit>
        <trans-unit id="2864a0d09a57cc7f91ca4ff8697942e0585349f6" translate="yes" xml:space="preserve">
          <source>Built-in Function: double &lt;strong id=&quot;index-_005f_005fbuiltin_005fnan&quot;&gt;__builtin_nan&lt;/strong&gt; (const char *str)</source>
          <target state="translated">内置函数：double &lt;strong id=&quot;index-_005f_005fbuiltin_005fnan&quot;&gt;__builtin_nan&lt;/strong&gt;（const char * str）</target>
        </trans-unit>
        <trans-unit id="51bc6d3e017f472618e17d8b483f22c00009407c" translate="yes" xml:space="preserve">
          <source>Built-in Function: double &lt;strong id=&quot;index-_005f_005fbuiltin_005fnans&quot;&gt;__builtin_nans&lt;/strong&gt; (const char *str)</source>
          <target state="translated">内置函数：double &lt;strong id=&quot;index-_005f_005fbuiltin_005fnans&quot;&gt;__builtin_nans&lt;/strong&gt;（const char * str）</target>
        </trans-unit>
        <trans-unit id="b40603712a54f648b2195d490214834e3f8465f8" translate="yes" xml:space="preserve">
          <source>Built-in Function: double &lt;strong id=&quot;index-_005f_005fbuiltin_005fpowi-1&quot;&gt;__builtin_powi&lt;/strong&gt; (double, int)</source>
          <target state="translated">内置函数：double &lt;strong id=&quot;index-_005f_005fbuiltin_005fpowi-1&quot;&gt;__builtin_powi&lt;/strong&gt;（double，int）</target>
        </trans-unit>
        <trans-unit id="37264a6694867df8b96fcd2a07266108a13c8c2e" translate="yes" xml:space="preserve">
          <source>Built-in Function: float &lt;strong id=&quot;index-_005f_005fbuiltin_005fhuge_005fvalf&quot;&gt;__builtin_huge_valf&lt;/strong&gt; (void)</source>
          <target state="translated">内置函数：float &lt;strong id=&quot;index-_005f_005fbuiltin_005fhuge_005fvalf&quot;&gt;__builtin_huge_valf&lt;/strong&gt;（void）</target>
        </trans-unit>
        <trans-unit id="605b7b7bd5e72cf972739ddb673591e051dadcd8" translate="yes" xml:space="preserve">
          <source>Built-in Function: float &lt;strong id=&quot;index-_005f_005fbuiltin_005finff&quot;&gt;__builtin_inff&lt;/strong&gt; (void)</source>
          <target state="translated">内置函数：float &lt;strong id=&quot;index-_005f_005fbuiltin_005finff&quot;&gt;__builtin_inff&lt;/strong&gt;（void）</target>
        </trans-unit>
        <trans-unit id="a84c6b7adfcd7dc51b670ecde42ed816377e7198" translate="yes" xml:space="preserve">
          <source>Built-in Function: float &lt;strong id=&quot;index-_005f_005fbuiltin_005fnanf&quot;&gt;__builtin_nanf&lt;/strong&gt; (const char *str)</source>
          <target state="translated">内置函数：float &lt;strong id=&quot;index-_005f_005fbuiltin_005fnanf&quot;&gt;__builtin_nanf&lt;/strong&gt;（const char * str）</target>
        </trans-unit>
        <trans-unit id="ae6f3577a561b5595beef7b2c40d9183bbecdc53" translate="yes" xml:space="preserve">
          <source>Built-in Function: float &lt;strong id=&quot;index-_005f_005fbuiltin_005fnansf&quot;&gt;__builtin_nansf&lt;/strong&gt; (const char *str)</source>
          <target state="translated">内置函数：float &lt;strong id=&quot;index-_005f_005fbuiltin_005fnansf&quot;&gt;__builtin_nansf&lt;/strong&gt;（const char * str）</target>
        </trans-unit>
        <trans-unit id="a17547d96b5dcfda1585e7b927ed2efd4413b34e" translate="yes" xml:space="preserve">
          <source>Built-in Function: float &lt;strong id=&quot;index-_005f_005fbuiltin_005fpowif-1&quot;&gt;__builtin_powif&lt;/strong&gt; (float, int)</source>
          <target state="translated">内置函数：float &lt;strong id=&quot;index-_005f_005fbuiltin_005fpowif-1&quot;&gt;__builtin_powif&lt;/strong&gt;（float，int）</target>
        </trans-unit>
        <trans-unit id="5af70608a64ebe69db59d9a08864316c44173d0e" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005fLINE&quot;&gt;__builtin_LINE&lt;/strong&gt; ()</source>
          <target state="translated">内置函数：int &lt;strong id=&quot;index-_005f_005fbuiltin_005fLINE&quot;&gt;__builtin_LINE&lt;/strong&gt;（）</target>
        </trans-unit>
        <trans-unit id="48642fe0ecb713fe1c2c62aceb4756a077c1f773" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005farc_005faligned&quot;&gt;__builtin_arc_aligned&lt;/strong&gt; (void *&lt;var&gt;val&lt;/var&gt;, int &lt;var&gt;alignval&lt;/var&gt;)</source>
          <target state="translated">内置函数：int &lt;strong id=&quot;index-_005f_005fbuiltin_005farc_005faligned&quot;&gt;__builtin_arc_aligned&lt;/strong&gt;（void * &lt;var&gt;val&lt;/var&gt; ，int &lt;var&gt;alignval&lt;/var&gt; ）</target>
        </trans-unit>
        <trans-unit id="d03ad02fdd87a3d6c105f1b3776333e8f10a10d5" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005farc_005fdivaw&quot;&gt;__builtin_arc_divaw&lt;/strong&gt; (int &lt;var&gt;a&lt;/var&gt;, int &lt;var&gt;b&lt;/var&gt;)</source>
          <target state="translated">内置函数：int &lt;strong id=&quot;index-_005f_005fbuiltin_005farc_005fdivaw&quot;&gt;__builtin_arc_divaw&lt;/strong&gt;（int &lt;var&gt;a&lt;/var&gt; ，int &lt;var&gt;b&lt;/var&gt; ）</target>
        </trans-unit>
        <trans-unit id="9c45a4bbd1df9874258bef23963c99d6fdf07ecc" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005farc_005fnorm&quot;&gt;__builtin_arc_norm&lt;/strong&gt; (int &lt;var&gt;src&lt;/var&gt;)</source>
          <target state="translated">内置函数：int &lt;strong id=&quot;index-_005f_005fbuiltin_005farc_005fnorm&quot;&gt;__builtin_arc_norm&lt;/strong&gt;（int &lt;var&gt;src&lt;/var&gt; ）</target>
        </trans-unit>
        <trans-unit id="343cfc12f31c0a60920faf8b433b92fcf3f860cf" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005farc_005fswap&quot;&gt;__builtin_arc_swap&lt;/strong&gt; (int &lt;var&gt;src&lt;/var&gt;)</source>
          <target state="translated">内置函数：int &lt;strong id=&quot;index-_005f_005fbuiltin_005farc_005fswap&quot;&gt;__builtin_arc_swap&lt;/strong&gt;（int &lt;var&gt;src&lt;/var&gt; ）</target>
        </trans-unit>
        <trans-unit id="4d84191dd5a2bd1c0e1ed8ebf20f4a6e76b3cbe6" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005fclrsb&quot;&gt;__builtin_clrsb&lt;/strong&gt; (int x)</source>
          <target state="translated">内置函数：int &lt;strong id=&quot;index-_005f_005fbuiltin_005fclrsb&quot;&gt;__builtin_clrsb&lt;/strong&gt;（int x）</target>
        </trans-unit>
        <trans-unit id="26c48a9f003c2411e7dd88432db5f58cb7b19302" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005fclrsbl&quot;&gt;__builtin_clrsbl&lt;/strong&gt; (long)</source>
          <target state="translated">内置函数：int &lt;strong id=&quot;index-_005f_005fbuiltin_005fclrsbl&quot;&gt;__builtin_clrsbl&lt;/strong&gt;（long）</target>
        </trans-unit>
        <trans-unit id="def7076c73776e0b25f88bdee6855cecbffd2e2a" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005fclrsbll&quot;&gt;__builtin_clrsbll&lt;/strong&gt; (long long)</source>
          <target state="translated">内置函数：int &lt;strong id=&quot;index-_005f_005fbuiltin_005fclrsbll&quot;&gt;__builtin_clrsbll&lt;/strong&gt;（long long）</target>
        </trans-unit>
        <trans-unit id="68a0ab60ba16fc861473b90def46ecb8b60b639d" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005fclz&quot;&gt;__builtin_clz&lt;/strong&gt; (unsigned int x)</source>
          <target state="translated">内置函数：int &lt;strong id=&quot;index-_005f_005fbuiltin_005fclz&quot;&gt;__builtin_clz&lt;/strong&gt;（无符号int x）</target>
        </trans-unit>
        <trans-unit id="af52cee1c123c25328e32f99b41a08f4a5682992" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005fclzl&quot;&gt;__builtin_clzl&lt;/strong&gt; (unsigned long)</source>
          <target state="translated">内置函数：int &lt;strong id=&quot;index-_005f_005fbuiltin_005fclzl&quot;&gt;__builtin_clzl&lt;/strong&gt;（无符号长）</target>
        </trans-unit>
        <trans-unit id="f3a7c4157a06fcdbaf2b34c2852b5f5191d70ac6" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005fclzll&quot;&gt;__builtin_clzll&lt;/strong&gt; (unsigned long long)</source>
          <target state="translated">内置函数：int &lt;strong id=&quot;index-_005f_005fbuiltin_005fclzll&quot;&gt;__builtin_clzll&lt;/strong&gt;（无符号long long）</target>
        </trans-unit>
        <trans-unit id="e47a14a24701e5c3353b9003a2bdd96c5e473a94" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005fconstant_005fp&quot;&gt;__builtin_constant_p&lt;/strong&gt; (&lt;var&gt;exp&lt;/var&gt;)</source>
          <target state="translated">内置函数：int &lt;strong id=&quot;index-_005f_005fbuiltin_005fconstant_005fp&quot;&gt;__builtin_constant_p&lt;/strong&gt;（ &lt;var&gt;exp&lt;/var&gt; ）</target>
        </trans-unit>
        <trans-unit id="ef14ea6a7a4d27be1b6d59915aed4bf7b4b1a9b6" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005fcpu_005fis&quot;&gt;__builtin_cpu_is&lt;/strong&gt; (const char *&lt;var&gt;cpuname&lt;/var&gt;)</source>
          <target state="translated">内置函数：int &lt;strong id=&quot;index-_005f_005fbuiltin_005fcpu_005fis&quot;&gt;__builtin_cpu_is&lt;/strong&gt;（const char * &lt;var&gt;cpuname&lt;/var&gt; ）</target>
        </trans-unit>
        <trans-unit id="b3f1d6da484baf586ba4417cd2ac456d3490d574" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005fcpu_005fis-1&quot;&gt;__builtin_cpu_is&lt;/strong&gt; (const char *&lt;var&gt;cpuname&lt;/var&gt;)</source>
          <target state="translated">内置函数：int &lt;strong id=&quot;index-_005f_005fbuiltin_005fcpu_005fis-1&quot;&gt;__builtin_cpu_is&lt;/strong&gt;（const char * &lt;var&gt;cpuname&lt;/var&gt; ）</target>
        </trans-unit>
        <trans-unit id="8f5e90517840f43dd21b0d12105cc6839b7ba276" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005fcpu_005fsupports&quot;&gt;__builtin_cpu_supports&lt;/strong&gt; (const char *&lt;var&gt;feature&lt;/var&gt;)</source>
          <target state="translated">内置函数：int &lt;strong id=&quot;index-_005f_005fbuiltin_005fcpu_005fsupports&quot;&gt;__builtin_cpu_supports&lt;/strong&gt;（const char * &lt;var&gt;feature&lt;/var&gt; ）</target>
        </trans-unit>
        <trans-unit id="be485791899d037b9a8263a3418dab2b9ad4f3b5" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005fcpu_005fsupports-1&quot;&gt;__builtin_cpu_supports&lt;/strong&gt; (const char *&lt;var&gt;feature&lt;/var&gt;)</source>
          <target state="translated">内置函数：int &lt;strong id=&quot;index-_005f_005fbuiltin_005fcpu_005fsupports-1&quot;&gt;__builtin_cpu_supports&lt;/strong&gt;（const char * &lt;var&gt;feature&lt;/var&gt; ）</target>
        </trans-unit>
        <trans-unit id="7f22b95a5cdd587669aed9814a5480962c20cb7d" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005fctz&quot;&gt;__builtin_ctz&lt;/strong&gt; (unsigned int x)</source>
          <target state="translated">内置函数：int &lt;strong id=&quot;index-_005f_005fbuiltin_005fctz&quot;&gt;__builtin_ctz&lt;/strong&gt;（无符号int x）</target>
        </trans-unit>
        <trans-unit id="8e1e06b0d6fb4ae3123c409271d97e77380c487c" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005fctzl&quot;&gt;__builtin_ctzl&lt;/strong&gt; (unsigned long)</source>
          <target state="translated">内置函数：int &lt;strong id=&quot;index-_005f_005fbuiltin_005fctzl&quot;&gt;__builtin_ctzl&lt;/strong&gt;（无符号长）</target>
        </trans-unit>
        <trans-unit id="20a1238733f66fff846c6029aaa32b6b42066621" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005fctzll&quot;&gt;__builtin_ctzll&lt;/strong&gt; (unsigned long long)</source>
          <target state="translated">内置函数：int &lt;strong id=&quot;index-_005f_005fbuiltin_005fctzll&quot;&gt;__builtin_ctzll&lt;/strong&gt;（unsigned long long）</target>
        </trans-unit>
        <trans-unit id="0937729bdd117da89bde58b2fd5056203d7a7e12" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005fffs&quot;&gt;__builtin_ffs&lt;/strong&gt; (int x)</source>
          <target state="translated">内置函数：int &lt;strong id=&quot;index-_005f_005fbuiltin_005fffs&quot;&gt;__builtin_ffs&lt;/strong&gt;（int x）</target>
        </trans-unit>
        <trans-unit id="c820dda274694fd7c04aa653b01ff9cf75ba5bae" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005fffsl&quot;&gt;__builtin_ffsl&lt;/strong&gt; (long)</source>
          <target state="translated">内置函数：int &lt;strong id=&quot;index-_005f_005fbuiltin_005fffsl&quot;&gt;__builtin_ffsl&lt;/strong&gt;（long）</target>
        </trans-unit>
        <trans-unit id="0419174c77d9db8a178954419d9e7c6e3dc80183" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005fffsll&quot;&gt;__builtin_ffsll&lt;/strong&gt; (long long)</source>
          <target state="translated">内置函数：int &lt;strong id=&quot;index-_005f_005fbuiltin_005fffsll&quot;&gt;__builtin_ffsll&lt;/strong&gt;（long long）</target>
        </trans-unit>
        <trans-unit id="d32b1e79ff752f0a0ce225c7feb84f484de727e9" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005ffpclassify-1&quot;&gt;__builtin_fpclassify&lt;/strong&gt; (int, int, int, int, int, ...)</source>
          <target state="translated">内置函数：int &lt;strong id=&quot;index-_005f_005fbuiltin_005ffpclassify-1&quot;&gt;__builtin_fpclassify&lt;/strong&gt;（int，int，int，int，int，...）</target>
        </trans-unit>
        <trans-unit id="e67b5cb4d37226ea2da9240fb2bf4c5fbfb5a8e1" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005fgoacc_005fparlevel_005fid&quot;&gt;__builtin_goacc_parlevel_id&lt;/strong&gt; (int x)</source>
          <target state="translated">内置函数：int &lt;strong id=&quot;index-_005f_005fbuiltin_005fgoacc_005fparlevel_005fid&quot;&gt;__builtin_goacc_parlevel_id&lt;/strong&gt;（int x）</target>
        </trans-unit>
        <trans-unit id="6e97eb7d6696130c1b12f3a195f09c5fe85037ac" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005fgoacc_005fparlevel_005fsize&quot;&gt;__builtin_goacc_parlevel_size&lt;/strong&gt; (int x)</source>
          <target state="translated">内置函数：int &lt;strong id=&quot;index-_005f_005fbuiltin_005fgoacc_005fparlevel_005fsize&quot;&gt;__builtin_goacc_parlevel_size&lt;/strong&gt;（int x）</target>
        </trans-unit>
        <trans-unit id="6d1c7c86aea003afe938bab829e378b0663f340f" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005fisinf_005fsign-1&quot;&gt;__builtin_isinf_sign&lt;/strong&gt; (...)</source>
          <target state="translated">内置函数：int &lt;strong id=&quot;index-_005f_005fbuiltin_005fisinf_005fsign-1&quot;&gt;__builtin_isinf_sign&lt;/strong&gt;（...）</target>
        </trans-unit>
        <trans-unit id="b6364cb6c54b3f23f200e94c257634d572b72a2b" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005fnds32_005fmfsr&quot;&gt;__builtin_nds32_mfsr&lt;/strong&gt; (int &lt;var&gt;sr&lt;/var&gt;)</source>
          <target state="translated">内置函数：int &lt;strong id=&quot;index-_005f_005fbuiltin_005fnds32_005fmfsr&quot;&gt;__builtin_nds32_mfsr&lt;/strong&gt;（int &lt;var&gt;sr&lt;/var&gt; ）</target>
        </trans-unit>
        <trans-unit id="75355c68c6a70985d49c27c009882adbab77b765" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005fnds32_005fmfusr&quot;&gt;__builtin_nds32_mfusr&lt;/strong&gt; (int &lt;var&gt;usr&lt;/var&gt;)</source>
          <target state="translated">内置函数：int &lt;strong id=&quot;index-_005f_005fbuiltin_005fnds32_005fmfusr&quot;&gt;__builtin_nds32_mfusr&lt;/strong&gt;（int &lt;var&gt;usr&lt;/var&gt; ）</target>
        </trans-unit>
        <trans-unit id="4ea0be9b20abc1e8c8611e711574fc9d068aecdf" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005fparity&quot;&gt;__builtin_parity&lt;/strong&gt; (unsigned int x)</source>
          <target state="translated">内置函数：int &lt;strong id=&quot;index-_005f_005fbuiltin_005fparity&quot;&gt;__builtin_parity&lt;/strong&gt;（无符号int x）</target>
        </trans-unit>
        <trans-unit id="d2674768572b8928e01401026a8478558c974780" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005fparityl&quot;&gt;__builtin_parityl&lt;/strong&gt; (unsigned long)</source>
          <target state="translated">内置函数：int &lt;strong id=&quot;index-_005f_005fbuiltin_005fparityl&quot;&gt;__builtin_parityl&lt;/strong&gt;（无符号长）</target>
        </trans-unit>
        <trans-unit id="ee9664e69ce71d737f813b0b4d98ebf2574871d2" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005fparityll&quot;&gt;__builtin_parityll&lt;/strong&gt; (unsigned long long)</source>
          <target state="translated">内置函数：int &lt;strong id=&quot;index-_005f_005fbuiltin_005fparityll&quot;&gt;__builtin_parityll&lt;/strong&gt;（unsigned long long）</target>
        </trans-unit>
        <trans-unit id="f4ff1595ae9b712ea80b334ac2a6cdea20f82b68" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005fpopcount&quot;&gt;__builtin_popcount&lt;/strong&gt; (unsigned int x)</source>
          <target state="translated">内置函数：int &lt;strong id=&quot;index-_005f_005fbuiltin_005fpopcount&quot;&gt;__builtin_popcount&lt;/strong&gt;（无符号int x）</target>
        </trans-unit>
        <trans-unit id="06a51eea95b9b1a09db27133b891662e30ce0448" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005fpopcountl&quot;&gt;__builtin_popcountl&lt;/strong&gt; (unsigned long)</source>
          <target state="translated">内置函数：int &lt;strong id=&quot;index-_005f_005fbuiltin_005fpopcountl&quot;&gt;__builtin_popcountl&lt;/strong&gt;（无符号长）</target>
        </trans-unit>
        <trans-unit id="cdd076b3e2da0133a80ede36a8b399d240589b8d" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005fpopcountll&quot;&gt;__builtin_popcountll&lt;/strong&gt; (unsigned long long)</source>
          <target state="translated">内置函数：int &lt;strong id=&quot;index-_005f_005fbuiltin_005fpopcountll&quot;&gt;__builtin_popcountll&lt;/strong&gt;（unsigned long long）</target>
        </trans-unit>
        <trans-unit id="81ba97f2fd93c345aa1ebd2ae07061c6b3b1e18d" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005fmvfachi&quot;&gt;__builtin_rx_mvfachi&lt;/strong&gt; (void)</source>
          <target state="translated">内置函数：int &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005fmvfachi&quot;&gt;__builtin_rx_mvfachi&lt;/strong&gt;（无效）</target>
        </trans-unit>
        <trans-unit id="bc349ef1269f6645b577d9e0423a3da86a3c0c64" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005fmvfacmi&quot;&gt;__builtin_rx_mvfacmi&lt;/strong&gt; (void)</source>
          <target state="translated">内置函数：int &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005fmvfacmi&quot;&gt;__builtin_rx_mvfacmi&lt;/strong&gt;（void）</target>
        </trans-unit>
        <trans-unit id="3c6283c7dae9e9bf7ecb0b6d081f4b083bb18c46" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005fmvfc&quot;&gt;__builtin_rx_mvfc&lt;/strong&gt; (int)</source>
          <target state="translated">内置函数：int &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005fmvfc&quot;&gt;__builtin_rx_mvfc&lt;/strong&gt;（int）</target>
        </trans-unit>
        <trans-unit id="061b61de0614f91eda3a2e79ebd09fdb750a9e0f" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005frevw&quot;&gt;__builtin_rx_revw&lt;/strong&gt; (int)</source>
          <target state="translated">内置函数：int &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005frevw&quot;&gt;__builtin_rx_revw&lt;/strong&gt;（int）</target>
        </trans-unit>
        <trans-unit id="90ac1419f6405c9d67980323a8c6db2b17519fa4" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005fsat&quot;&gt;__builtin_rx_sat&lt;/strong&gt; (int)</source>
          <target state="translated">内置函数：int &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005fsat&quot;&gt;__builtin_rx_sat&lt;/strong&gt;（int）</target>
        </trans-unit>
        <trans-unit id="ba08ce759241ad5b54043023fc31cb69ea10ef12" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005fsetjmp&quot;&gt;__builtin_setjmp&lt;/strong&gt; (intptr_t *&lt;var&gt;buf&lt;/var&gt;)</source>
          <target state="translated">内置函数：int &lt;strong id=&quot;index-_005f_005fbuiltin_005fsetjmp&quot;&gt;__builtin_setjmp&lt;/strong&gt;（intptr_t * &lt;var&gt;buf&lt;/var&gt; ）</target>
        </trans-unit>
        <trans-unit id="3b5f4e2e49e883c140bdde81a146113e7826c6e9" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005ftbegin&quot;&gt;__builtin_tbegin&lt;/strong&gt; (void*)</source>
          <target state="translated">内置函数：int &lt;strong id=&quot;index-_005f_005fbuiltin_005ftbegin&quot;&gt;__builtin_tbegin&lt;/strong&gt;（void *）</target>
        </trans-unit>
        <trans-unit id="00769436b2cde422b3b7011657e79f1018006b03" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005ftbegin_005fnofloat&quot;&gt;__builtin_tbegin_nofloat&lt;/strong&gt; (void*)</source>
          <target state="translated">内置函数：int &lt;strong id=&quot;index-_005f_005fbuiltin_005ftbegin_005fnofloat&quot;&gt;__builtin_tbegin_nofloat&lt;/strong&gt;（void *）</target>
        </trans-unit>
        <trans-unit id="b626c4c35bdf8b837ccbdac21dccf04d3259501c" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005ftbegin_005fretry&quot;&gt;__builtin_tbegin_retry&lt;/strong&gt; (void*, int)</source>
          <target state="translated">内置函数：int &lt;strong id=&quot;index-_005f_005fbuiltin_005ftbegin_005fretry&quot;&gt;__builtin_tbegin_retry&lt;/strong&gt;（void *，int）</target>
        </trans-unit>
        <trans-unit id="7b0e1df41de31ed2e428c07e756094f54001f4e6" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005ftbegin_005fretry_005fnofloat&quot;&gt;__builtin_tbegin_retry_nofloat&lt;/strong&gt; (void*, int)</source>
          <target state="translated">内置函数：int &lt;strong id=&quot;index-_005f_005fbuiltin_005ftbegin_005fretry_005fnofloat&quot;&gt;__builtin_tbegin_retry_nofloat&lt;/strong&gt;（void *，int）</target>
        </trans-unit>
        <trans-unit id="5a37cc4aa4480ad9e51ba1642145972ee824d1c3" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005ftend&quot;&gt;__builtin_tend&lt;/strong&gt; (void)</source>
          <target state="translated">内置函数：int &lt;strong id=&quot;index-_005f_005fbuiltin_005ftend&quot;&gt;__builtin_tend&lt;/strong&gt;（void）</target>
        </trans-unit>
        <trans-unit id="b156bfa334cc82648dee3d2f253e789fdf0de655" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005ftx_005fnesting_005fdepth&quot;&gt;__builtin_tx_nesting_depth&lt;/strong&gt; (void)</source>
          <target state="translated">内置函数：int &lt;strong id=&quot;index-_005f_005fbuiltin_005ftx_005fnesting_005fdepth&quot;&gt;__builtin_tx_nesting_depth&lt;/strong&gt;（无效）</target>
        </trans-unit>
        <trans-unit id="7d1b9cf1258d4a3f36ac2384619d6f6feef8480b" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005ftypes_005fcompatible_005fp&quot;&gt;__builtin_types_compatible_p&lt;/strong&gt; (&lt;var&gt;type1&lt;/var&gt;, &lt;var&gt;type2&lt;/var&gt;)</source>
          <target state="translated">内置函数：int &lt;strong id=&quot;index-_005f_005fbuiltin_005ftypes_005fcompatible_005fp&quot;&gt;__builtin_types_compatible_p&lt;/strong&gt;（ &lt;var&gt;type1&lt;/var&gt; ， &lt;var&gt;type2&lt;/var&gt; ）</target>
        </trans-unit>
        <trans-unit id="ab0fd3c8fa261ef1e9881453b5ce3996db8b353f" translate="yes" xml:space="preserve">
          <source>Built-in Function: long &lt;strong id=&quot;index-_005f_005fbuiltin_005fexpect&quot;&gt;__builtin_expect&lt;/strong&gt; (long &lt;var&gt;exp&lt;/var&gt;, long &lt;var&gt;c&lt;/var&gt;)</source>
          <target state="translated">内置函数：long &lt;strong id=&quot;index-_005f_005fbuiltin_005fexpect&quot;&gt;__builtin_expect&lt;/strong&gt;（long &lt;var&gt;exp&lt;/var&gt; ，long &lt;var&gt;c&lt;/var&gt; ）</target>
        </trans-unit>
        <trans-unit id="f748429dddf7f60efd21f75bc9d96a2f04db2076" translate="yes" xml:space="preserve">
          <source>Built-in Function: long &lt;strong id=&quot;index-_005f_005fbuiltin_005fexpect_005fwith_005fprobability&quot;&gt;__builtin_expect_with_probability&lt;/strong&gt;</source>
          <target state="translated">内置函数：long &lt;strong id=&quot;index-_005f_005fbuiltin_005fexpect_005fwith_005fprobability&quot;&gt;__builtin_expect_with_probability&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="971be5dbeae5d7765bfe0bd927cc0410ae39a447" translate="yes" xml:space="preserve">
          <source>Built-in Function: long double &lt;strong id=&quot;index-_005f_005fbuiltin_005fhuge_005fvall&quot;&gt;__builtin_huge_vall&lt;/strong&gt; (void)</source>
          <target state="translated">内置函数：long double &lt;strong id=&quot;index-_005f_005fbuiltin_005fhuge_005fvall&quot;&gt;__builtin_huge_vall&lt;/strong&gt;（无效）</target>
        </trans-unit>
        <trans-unit id="f890816fdc58a1aea60b82df935d886c00b2bf15" translate="yes" xml:space="preserve">
          <source>Built-in Function: long double &lt;strong id=&quot;index-_005f_005fbuiltin_005finfl&quot;&gt;__builtin_infl&lt;/strong&gt; (void)</source>
          <target state="translated">内置函数：long double &lt;strong id=&quot;index-_005f_005fbuiltin_005finfl&quot;&gt;__builtin_infl&lt;/strong&gt;（无效）</target>
        </trans-unit>
        <trans-unit id="4324db719b621df0af588063a194c3f4173810b5" translate="yes" xml:space="preserve">
          <source>Built-in Function: long double &lt;strong id=&quot;index-_005f_005fbuiltin_005fnanl&quot;&gt;__builtin_nanl&lt;/strong&gt; (const char *str)</source>
          <target state="translated">内置函数：long double &lt;strong id=&quot;index-_005f_005fbuiltin_005fnanl&quot;&gt;__builtin_nanl&lt;/strong&gt;（const char * str）</target>
        </trans-unit>
        <trans-unit id="05afbb2ee64f8e1c3ac88b778a44096576c7f966" translate="yes" xml:space="preserve">
          <source>Built-in Function: long double &lt;strong id=&quot;index-_005f_005fbuiltin_005fnansl&quot;&gt;__builtin_nansl&lt;/strong&gt; (const char *str)</source>
          <target state="translated">内置函数：long double &lt;strong id=&quot;index-_005f_005fbuiltin_005fnansl&quot;&gt;__builtin_nansl&lt;/strong&gt;（const char * str）</target>
        </trans-unit>
        <trans-unit id="2b868b2b6ef31f0d2806eabe890d6c604ddddf56" translate="yes" xml:space="preserve">
          <source>Built-in Function: long double &lt;strong id=&quot;index-_005f_005fbuiltin_005fpowil-1&quot;&gt;__builtin_powil&lt;/strong&gt; (long double, int)</source>
          <target state="translated">内置函数：long double &lt;strong id=&quot;index-_005f_005fbuiltin_005fpowil-1&quot;&gt;__builtin_powil&lt;/strong&gt;（long double，int）</target>
        </trans-unit>
        <trans-unit id="d356427c6ff17cd4bc34021c1341be077bc0c8a1" translate="yes" xml:space="preserve">
          <source>Built-in Function: short int &lt;strong id=&quot;index-_005f_005fbuiltin_005farc_005fnormw&quot;&gt;__builtin_arc_normw&lt;/strong&gt; (short int &lt;var&gt;src&lt;/var&gt;)</source>
          <target state="translated">内置函数：short int &lt;strong id=&quot;index-_005f_005fbuiltin_005farc_005fnormw&quot;&gt;__builtin_arc_normw&lt;/strong&gt;（short int &lt;var&gt;src&lt;/var&gt; ）</target>
        </trans-unit>
        <trans-unit id="f029118b8798750fa6c678264c3c7762285f4d28" translate="yes" xml:space="preserve">
          <source>Built-in Function: size_t &lt;strong id=&quot;index-_005f_005fbuiltin_005fobject_005fsize-1&quot;&gt;__builtin_object_size&lt;/strong&gt; (const void * &lt;var&gt;ptr&lt;/var&gt;, int &lt;var&gt;type&lt;/var&gt;)</source>
          <target state="translated">内置函数：size_t &lt;strong id=&quot;index-_005f_005fbuiltin_005fobject_005fsize-1&quot;&gt;__builtin_object_size&lt;/strong&gt;（const void * &lt;var&gt;ptr&lt;/var&gt; ，int &lt;var&gt;type&lt;/var&gt; ）</target>
        </trans-unit>
        <trans-unit id="e7554947332f78bb70c0521290e9a6608845a4d1" translate="yes" xml:space="preserve">
          <source>Built-in Function: size_t &lt;strong id=&quot;index-_005f_005fbuiltin_005fobject_005fsize-3&quot;&gt;__builtin_object_size&lt;/strong&gt; (const void * &lt;var&gt;ptr&lt;/var&gt;, int &lt;var&gt;type&lt;/var&gt;)</source>
          <target state="translated">内置函数：size_t &lt;strong id=&quot;index-_005f_005fbuiltin_005fobject_005fsize-3&quot;&gt;__builtin_object_size&lt;/strong&gt;（const void * &lt;var&gt;ptr&lt;/var&gt; ，int &lt;var&gt;type&lt;/var&gt; ）</target>
        </trans-unit>
        <trans-unit id="989a30653b65ffed34f5682558a8970a9aa0e644" translate="yes" xml:space="preserve">
          <source>Built-in Function: size_t &lt;strong id=&quot;index-_005f_005fbuiltin_005fva_005farg_005fpack_005flen&quot;&gt;__builtin_va_arg_pack_len&lt;/strong&gt; ()</source>
          <target state="translated">内置函数：size_t &lt;strong id=&quot;index-_005f_005fbuiltin_005fva_005farg_005fpack_005flen&quot;&gt;__builtin_va_arg_pack_len&lt;/strong&gt;（）</target>
        </trans-unit>
        <trans-unit id="22d331467c48fe2922c4d1d28e785562b4d984a9" translate="yes" xml:space="preserve">
          <source>Built-in Function: uint16_t &lt;strong id=&quot;index-_005f_005fbuiltin_005fbswap16&quot;&gt;__builtin_bswap16&lt;/strong&gt; (uint16_t x)</source>
          <target state="translated">内置函数：uint16_t &lt;strong id=&quot;index-_005f_005fbuiltin_005fbswap16&quot;&gt;__builtin_bswap16&lt;/strong&gt;（uint16_t x）</target>
        </trans-unit>
        <trans-unit id="c1726e6c424d7f99d5018566837c4927b7db5948" translate="yes" xml:space="preserve">
          <source>Built-in Function: uint32_t &lt;strong id=&quot;index-_005f_005fbuiltin_005fbswap32&quot;&gt;__builtin_bswap32&lt;/strong&gt; (uint32_t x)</source>
          <target state="translated">内置函数：uint32_t &lt;strong id=&quot;index-_005f_005fbuiltin_005fbswap32&quot;&gt;__builtin_bswap32&lt;/strong&gt;（uint32_t x）</target>
        </trans-unit>
        <trans-unit id="3c5352b73e73ceeb994fa2584683f756d8f9d112" translate="yes" xml:space="preserve">
          <source>Built-in Function: uint64_t &lt;strong id=&quot;index-_005f_005fbuiltin_005fbswap64&quot;&gt;__builtin_bswap64&lt;/strong&gt; (uint64_t x)</source>
          <target state="translated">内置函数：uint64_t &lt;strong id=&quot;index-_005f_005fbuiltin_005fbswap64&quot;&gt;__builtin_bswap64&lt;/strong&gt;（uint64_t x）</target>
        </trans-unit>
        <trans-unit id="509ae15fd2e87932ac8b26cb6b1d223cd12aa699" translate="yes" xml:space="preserve">
          <source>Built-in Function: unsigned int &lt;strong id=&quot;index-_005f_005fbuiltin_005farc_005fcore_005fread&quot;&gt;__builtin_arc_core_read&lt;/strong&gt; (unsigned int &lt;var&gt;regno&lt;/var&gt;)</source>
          <target state="translated">内置函数：unsigned int &lt;strong id=&quot;index-_005f_005fbuiltin_005farc_005fcore_005fread&quot;&gt;__builtin_arc_core_read&lt;/strong&gt;（unsigned int &lt;var&gt;regno&lt;/var&gt; ）</target>
        </trans-unit>
        <trans-unit id="930e355c3b80a5a9fc58fc1acd0a189dee429782" translate="yes" xml:space="preserve">
          <source>Built-in Function: unsigned int &lt;strong id=&quot;index-_005f_005fbuiltin_005farc_005flr&quot;&gt;__builtin_arc_lr&lt;/strong&gt; (unsigned int &lt;var&gt;auxr&lt;/var&gt;)</source>
          <target state="translated">内置函数：unsigned int &lt;strong id=&quot;index-_005f_005fbuiltin_005farc_005flr&quot;&gt;__builtin_arc_lr&lt;/strong&gt;（unsigned int &lt;var&gt;auxr&lt;/var&gt; ）</target>
        </trans-unit>
        <trans-unit id="fe43f813f2eb2f9db208678d8efd3062ab0ae06f" translate="yes" xml:space="preserve">
          <source>Built-in Function: unsigned int &lt;strong id=&quot;index-_005f_005fbuiltin_005fsh_005fget_005ffpscr&quot;&gt;__builtin_sh_get_fpscr&lt;/strong&gt; (void)</source>
          <target state="translated">内置函数：unsigned int &lt;strong id=&quot;index-_005f_005fbuiltin_005fsh_005fget_005ffpscr&quot;&gt;__builtin_sh_get_fpscr&lt;/strong&gt;（无效）</target>
        </trans-unit>
        <trans-unit id="7bd053e0e0e0c481f2fd8761cce8fb20e0497500" translate="yes" xml:space="preserve">
          <source>Built-in Function: void * &lt;strong id=&quot;index-_005f_005fbuiltin_005fapply&quot;&gt;__builtin_apply&lt;/strong&gt; (void (*&lt;var&gt;function&lt;/var&gt;)(), void *&lt;var&gt;arguments&lt;/var&gt;, size_t &lt;var&gt;size&lt;/var&gt;)</source>
          <target state="translated">内置函数：void * &lt;strong id=&quot;index-_005f_005fbuiltin_005fapply&quot;&gt;__builtin_apply&lt;/strong&gt;（void（* &lt;var&gt;function&lt;/var&gt; ）（），void * &lt;var&gt;arguments&lt;/var&gt; ，size_t &lt;var&gt;size&lt;/var&gt; ）</target>
        </trans-unit>
        <trans-unit id="34fa5cc333ec1b465b8bc1469ac13a9805646394" translate="yes" xml:space="preserve">
          <source>Built-in Function: void * &lt;strong id=&quot;index-_005f_005fbuiltin_005fapply_005fargs&quot;&gt;__builtin_apply_args&lt;/strong&gt; ()</source>
          <target state="translated">内置函数：void * &lt;strong id=&quot;index-_005f_005fbuiltin_005fapply_005fargs&quot;&gt;__builtin_apply_args&lt;/strong&gt;（）</target>
        </trans-unit>
        <trans-unit id="ae3f4e7eb7b92dd81ca2567a194a5a901d0bfe5f" translate="yes" xml:space="preserve">
          <source>Built-in Function: void * &lt;strong id=&quot;index-_005f_005fbuiltin_005fassume_005faligned&quot;&gt;__builtin_assume_aligned&lt;/strong&gt; (const void *&lt;var&gt;exp&lt;/var&gt;, size_t &lt;var&gt;align&lt;/var&gt;, ...)</source>
          <target state="translated">内置函数：void * &lt;strong id=&quot;index-_005f_005fbuiltin_005fassume_005faligned&quot;&gt;__builtin_assume_aligned&lt;/strong&gt;（const void * &lt;var&gt;exp&lt;/var&gt; ，size_t &lt;var&gt;align&lt;/var&gt; ，...）</target>
        </trans-unit>
        <trans-unit id="89fd532a50930c3b77686313f0365b067e8b2061" translate="yes" xml:space="preserve">
          <source>Built-in Function: void * &lt;strong id=&quot;index-_005f_005fbuiltin_005fextract_005freturn_005faddr&quot;&gt;__builtin_extract_return_addr&lt;/strong&gt; (void *&lt;var&gt;addr&lt;/var&gt;)</source>
          <target state="translated">内置函数：void * &lt;strong id=&quot;index-_005f_005fbuiltin_005fextract_005freturn_005faddr&quot;&gt;__builtin_extract_return_addr&lt;/strong&gt;（void * &lt;var&gt;addr&lt;/var&gt; ）</target>
        </trans-unit>
        <trans-unit id="af5db4b2531bc00d2c26aa89ffd98b83b1ec2ffd" translate="yes" xml:space="preserve">
          <source>Built-in Function: void * &lt;strong id=&quot;index-_005f_005fbuiltin_005fframe_005faddress&quot;&gt;__builtin_frame_address&lt;/strong&gt; (unsigned int &lt;var&gt;level&lt;/var&gt;)</source>
          <target state="translated">内置函数：void * &lt;strong id=&quot;index-_005f_005fbuiltin_005fframe_005faddress&quot;&gt;__builtin_frame_address&lt;/strong&gt;（无符号int &lt;var&gt;level&lt;/var&gt; ）</target>
        </trans-unit>
        <trans-unit id="0ae549b690a18db077d51fc88ddfe8895c32f392" translate="yes" xml:space="preserve">
          <source>Built-in Function: void * &lt;strong id=&quot;index-_005f_005fbuiltin_005ffrob_005freturn_005faddress&quot;&gt;__builtin_frob_return_address&lt;/strong&gt; (void *&lt;var&gt;addr&lt;/var&gt;)</source>
          <target state="translated">内置函数：void * &lt;strong id=&quot;index-_005f_005fbuiltin_005ffrob_005freturn_005faddress&quot;&gt;__builtin_frob_return_address&lt;/strong&gt;（void * &lt;var&gt;addr&lt;/var&gt; ）</target>
        </trans-unit>
        <trans-unit id="570bc19f96ffb431d4ed4e07d4a76a73d90b1bab" translate="yes" xml:space="preserve">
          <source>Built-in Function: void * &lt;strong id=&quot;index-_005f_005fbuiltin_005freturn_005faddress&quot;&gt;__builtin_return_address&lt;/strong&gt; (unsigned int &lt;var&gt;level&lt;/var&gt;)</source>
          <target state="translated">内置函数：void * &lt;strong id=&quot;index-_005f_005fbuiltin_005freturn_005faddress&quot;&gt;__builtin_return_address&lt;/strong&gt;（无符号int &lt;var&gt;level&lt;/var&gt; ）</target>
        </trans-unit>
        <trans-unit id="2a17d8a48dd1cfb01e5eca9e0fefb74ccd1f3e19" translate="yes" xml:space="preserve">
          <source>Built-in Function: void * &lt;strong id=&quot;index-_005f_005fbuiltin_005fthread_005fpointer&quot;&gt;__builtin_thread_pointer&lt;/strong&gt; (void)</source>
          <target state="translated">内置函数：void * &lt;strong id=&quot;index-_005f_005fbuiltin_005fthread_005fpointer&quot;&gt;__builtin_thread_pointer&lt;/strong&gt;（void）</target>
        </trans-unit>
        <trans-unit id="f386f8fa1a3ce61aaddb01d8f87e99be90ce722e" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_002a_005f_005fbuiltin_005falloca&quot;&gt;*__builtin_alloca&lt;/strong&gt; (size_t size)</source>
          <target state="translated">内置函数：void &lt;strong id=&quot;index-_002a_005f_005fbuiltin_005falloca&quot;&gt;* __ builtin_alloca&lt;/strong&gt;（size_t大小）</target>
        </trans-unit>
        <trans-unit id="c063cc66ca8c65c97e5563c39a35ab67426b4796" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_002a_005f_005fbuiltin_005falloca_005fwith_005falign&quot;&gt;*__builtin_alloca_with_align&lt;/strong&gt; (size_t size, size_t alignment)</source>
          <target state="translated">内置函数：void &lt;strong id=&quot;index-_002a_005f_005fbuiltin_005falloca_005fwith_005falign&quot;&gt;* __ builtin_alloca_with_align&lt;/strong&gt;（size_t大小，size_t对齐）</target>
        </trans-unit>
        <trans-unit id="9c9a2cc82b83f94f4d0c65d76c51d114da95b31b" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_002a_005f_005fbuiltin_005falloca_005fwith_005falign_005fand_005fmax&quot;&gt;*__builtin_alloca_with_align_and_max&lt;/strong&gt; (size_t size, size_t alignment, size_t max_size)</source>
          <target state="translated">内置函数：void &lt;strong id=&quot;index-_002a_005f_005fbuiltin_005falloca_005fwith_005falign_005fand_005fmax&quot;&gt;* __ builtin_alloca_with_align_and_max&lt;/strong&gt;（size_t大小，size_t对齐，size_t max_size）</target>
        </trans-unit>
        <trans-unit id="9362d0fd68d2bba012773ea9bf47a7cf19548a71" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fatomic_005fclear&quot;&gt;__atomic_clear&lt;/strong&gt; (bool *ptr, int memorder)</source>
          <target state="translated">内置函数：void &lt;strong id=&quot;index-_005f_005fatomic_005fclear&quot;&gt;__atomic_clear&lt;/strong&gt;（bool * ptr，int内存）</target>
        </trans-unit>
        <trans-unit id="af38ddba7b2c30fcdbcb19cb7f7f28b84121aca6" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fatomic_005fexchange&quot;&gt;__atomic_exchange&lt;/strong&gt; (&lt;var&gt;type&lt;/var&gt; *ptr, &lt;var&gt;type&lt;/var&gt; *val, &lt;var&gt;type&lt;/var&gt; *ret, int memorder)</source>
          <target state="translated">内置函数：void &lt;strong id=&quot;index-_005f_005fatomic_005fexchange&quot;&gt;__atomic_exchange&lt;/strong&gt;（ &lt;var&gt;type&lt;/var&gt; * ptr， &lt;var&gt;type&lt;/var&gt; * val， &lt;var&gt;type&lt;/var&gt; * ret，int内存）</target>
        </trans-unit>
        <trans-unit id="81cf5ada4648091ed72e1aa65aae72b350e8c4d3" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fatomic_005fload&quot;&gt;__atomic_load&lt;/strong&gt; (&lt;var&gt;type&lt;/var&gt; *ptr, &lt;var&gt;type&lt;/var&gt; *ret, int memorder)</source>
          <target state="translated">内置函数：void &lt;strong id=&quot;index-_005f_005fatomic_005fload&quot;&gt;__atomic_load&lt;/strong&gt;（ &lt;var&gt;type&lt;/var&gt; * ptr， &lt;var&gt;type&lt;/var&gt; * ret，int内存）</target>
        </trans-unit>
        <trans-unit id="a339c94ea5a60096d289e4b1ba778af9caadce5c" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fatomic_005fsignal_005ffence&quot;&gt;__atomic_signal_fence&lt;/strong&gt; (int memorder)</source>
          <target state="translated">内置函数：void &lt;strong id=&quot;index-_005f_005fatomic_005fsignal_005ffence&quot;&gt;__atomic_signal_fence&lt;/strong&gt;（int内存）</target>
        </trans-unit>
        <trans-unit id="a1bcb5179154226f5bada80a127d69eae1eb5cec" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fatomic_005fstore&quot;&gt;__atomic_store&lt;/strong&gt; (&lt;var&gt;type&lt;/var&gt; *ptr, &lt;var&gt;type&lt;/var&gt; *val, int memorder)</source>
          <target state="translated">内置函数：void &lt;strong id=&quot;index-_005f_005fatomic_005fstore&quot;&gt;__atomic_store&lt;/strong&gt;（ &lt;var&gt;type&lt;/var&gt; * ptr， &lt;var&gt;type&lt;/var&gt; * val，int内存）</target>
        </trans-unit>
        <trans-unit id="0a97d93631348e25f6183eb76cee2e101979f75e" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fatomic_005fstore_005fn&quot;&gt;__atomic_store_n&lt;/strong&gt; (&lt;var&gt;type&lt;/var&gt; *ptr, &lt;var&gt;type&lt;/var&gt; val, int memorder)</source>
          <target state="translated">内置函数：void &lt;strong id=&quot;index-_005f_005fatomic_005fstore_005fn&quot;&gt;__atomic_store_n&lt;/strong&gt;（ &lt;var&gt;type&lt;/var&gt; * ptr， &lt;var&gt;type&lt;/var&gt; val，int内存）</target>
        </trans-unit>
        <trans-unit id="2d340009d0a0b7de28ca2e66c34cf11a1340bae0" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fatomic_005fthread_005ffence&quot;&gt;__atomic_thread_fence&lt;/strong&gt; (int memorder)</source>
          <target state="translated">内置函数：void &lt;strong id=&quot;index-_005f_005fatomic_005fthread_005ffence&quot;&gt;__atomic_thread_fence&lt;/strong&gt;（int memorder）</target>
        </trans-unit>
        <trans-unit id="de406e12d51eaad788fc9e9d5903dcbf3bcb9513" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005f_005f_005fclear_005fcache&quot;&gt;__builtin___clear_cache&lt;/strong&gt; (void *&lt;var&gt;begin&lt;/var&gt;, void *&lt;var&gt;end&lt;/var&gt;)</source>
          <target state="translated">内置函数：void &lt;strong id=&quot;index-_005f_005fbuiltin_005f_005f_005fclear_005fcache&quot;&gt;__builtin___clear_cache&lt;/strong&gt;（void * &lt;var&gt;begin&lt;/var&gt; ，void * &lt;var&gt;end&lt;/var&gt; ）</target>
        </trans-unit>
        <trans-unit id="fbdc79fbdaaac306ca33e716a38d2039cdbc731c" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005farc_005fbrk&quot;&gt;__builtin_arc_brk&lt;/strong&gt; (void)</source>
          <target state="translated">内置函数：void &lt;strong id=&quot;index-_005f_005fbuiltin_005farc_005fbrk&quot;&gt;__builtin_arc_brk&lt;/strong&gt;（void）</target>
        </trans-unit>
        <trans-unit id="41dfbf690d1f1831d27b0be428eb428d5c08e800" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005farc_005fcore_005fwrite&quot;&gt;__builtin_arc_core_write&lt;/strong&gt; (unsigned int &lt;var&gt;regno&lt;/var&gt;, unsigned int &lt;var&gt;val&lt;/var&gt;)</source>
          <target state="translated">内置函数：void &lt;strong id=&quot;index-_005f_005fbuiltin_005farc_005fcore_005fwrite&quot;&gt;__builtin_arc_core_write&lt;/strong&gt;（unsigned int &lt;var&gt;regno&lt;/var&gt; ，unsigned int &lt;var&gt;val&lt;/var&gt; ）</target>
        </trans-unit>
        <trans-unit id="938747d2d81b773df4eb146dc47c371852f38281" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005farc_005fflag&quot;&gt;__builtin_arc_flag&lt;/strong&gt; (unsigned int &lt;var&gt;a&lt;/var&gt;)</source>
          <target state="translated">内置函数：void &lt;strong id=&quot;index-_005f_005fbuiltin_005farc_005fflag&quot;&gt;__builtin_arc_flag&lt;/strong&gt;（unsigned int &lt;var&gt;a&lt;/var&gt; ）</target>
        </trans-unit>
        <trans-unit id="dacbc2eeaf144c8f5f67ca6a60249f78488adc0b" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005farc_005fmul64&quot;&gt;__builtin_arc_mul64&lt;/strong&gt; (int &lt;var&gt;a&lt;/var&gt;, int &lt;var&gt;b&lt;/var&gt;)</source>
          <target state="translated">内置函数：void &lt;strong id=&quot;index-_005f_005fbuiltin_005farc_005fmul64&quot;&gt;__builtin_arc_mul64&lt;/strong&gt;（int &lt;var&gt;a&lt;/var&gt; ，int &lt;var&gt;b&lt;/var&gt; ）</target>
        </trans-unit>
        <trans-unit id="5df39d3186b8d524cef79461c8ccbf9360ab5670" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005farc_005fmulu64&quot;&gt;__builtin_arc_mulu64&lt;/strong&gt; (unsigned int &lt;var&gt;a&lt;/var&gt;, unsigned int &lt;var&gt;b&lt;/var&gt;)</source>
          <target state="translated">内置函数：void &lt;strong id=&quot;index-_005f_005fbuiltin_005farc_005fmulu64&quot;&gt;__builtin_arc_mulu64&lt;/strong&gt;（unsigned int &lt;var&gt;a&lt;/var&gt; ，unsigned int &lt;var&gt;b&lt;/var&gt; ）</target>
        </trans-unit>
        <trans-unit id="f6b3b375828d6b123d4a73fe0837a99b6630234e" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005farc_005fnop&quot;&gt;__builtin_arc_nop&lt;/strong&gt; (void)</source>
          <target state="translated">内置函数：void &lt;strong id=&quot;index-_005f_005fbuiltin_005farc_005fnop&quot;&gt;__builtin_arc_nop&lt;/strong&gt;（void）</target>
        </trans-unit>
        <trans-unit id="3e99485526d0fd614866e77c7a635130751c7b1d" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005farc_005frtie&quot;&gt;__builtin_arc_rtie&lt;/strong&gt; (void)</source>
          <target state="translated">内置函数：void &lt;strong id=&quot;index-_005f_005fbuiltin_005farc_005frtie&quot;&gt;__builtin_arc_rtie&lt;/strong&gt;（void）</target>
        </trans-unit>
        <trans-unit id="5cc0e84fe67d81076fbea0352fb8f5781564ffca" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005farc_005fsleep&quot;&gt;__builtin_arc_sleep&lt;/strong&gt; (int &lt;var&gt;a&lt;/var&gt;</source>
          <target state="translated">内置函数：void &lt;strong id=&quot;index-_005f_005fbuiltin_005farc_005fsleep&quot;&gt;__builtin_arc_sleep&lt;/strong&gt;（int &lt;var&gt;a&lt;/var&gt;</target>
        </trans-unit>
        <trans-unit id="39ed65244aa708bd181a626a0afcf9435d2147f5" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005farc_005fsr&quot;&gt;__builtin_arc_sr&lt;/strong&gt; (unsigned int &lt;var&gt;auxr&lt;/var&gt;, unsigned int &lt;var&gt;val&lt;/var&gt;)</source>
          <target state="translated">内置函数：void &lt;strong id=&quot;index-_005f_005fbuiltin_005farc_005fsr&quot;&gt;__builtin_arc_sr&lt;/strong&gt;（unsigned int &lt;var&gt;auxr&lt;/var&gt; ，unsigned int &lt;var&gt;val&lt;/var&gt; ）</target>
        </trans-unit>
        <trans-unit id="f420eb345d10d7bfd574d6a3346de63183adc893" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005farc_005fswi&quot;&gt;__builtin_arc_swi&lt;/strong&gt; (void)</source>
          <target state="translated">内置函数：void &lt;strong id=&quot;index-_005f_005fbuiltin_005farc_005fswi&quot;&gt;__builtin_arc_swi&lt;/strong&gt;（void）</target>
        </trans-unit>
        <trans-unit id="b42e0753d14b76f3a20b1e491681f5295a8dc135" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005farc_005fsync&quot;&gt;__builtin_arc_sync&lt;/strong&gt; (void)</source>
          <target state="translated">内置函数：void &lt;strong id=&quot;index-_005f_005fbuiltin_005farc_005fsync&quot;&gt;__builtin_arc_sync&lt;/strong&gt;（void）</target>
        </trans-unit>
        <trans-unit id="78cc7129f46ffcafd69b91e8eda56456c2ecced9" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005farc_005ftrap_005fs&quot;&gt;__builtin_arc_trap_s&lt;/strong&gt; (unsigned int &lt;var&gt;c&lt;/var&gt;)</source>
          <target state="translated">内置函数：void &lt;strong id=&quot;index-_005f_005fbuiltin_005farc_005ftrap_005fs&quot;&gt;__builtin_arc_trap_s&lt;/strong&gt;（unsigned int &lt;var&gt;c&lt;/var&gt; ）</target>
        </trans-unit>
        <trans-unit id="627e1715f16535c4e6e435528706da2168cf77df" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005farc_005funimp_005fs&quot;&gt;__builtin_arc_unimp_s&lt;/strong&gt; (void)</source>
          <target state="translated">内置函数：void &lt;strong id=&quot;index-_005f_005fbuiltin_005farc_005funimp_005fs&quot;&gt;__builtin_arc_unimp_s&lt;/strong&gt;（void）</target>
        </trans-unit>
        <trans-unit id="b29e71f1f17adad688b68068d1063df98d3d4aee" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005fcpu_005finit&quot;&gt;__builtin_cpu_init&lt;/strong&gt; (void)</source>
          <target state="translated">内置函数：void &lt;strong id=&quot;index-_005f_005fbuiltin_005fcpu_005finit&quot;&gt;__builtin_cpu_init&lt;/strong&gt;（void）</target>
        </trans-unit>
        <trans-unit id="ae429fc5f0112c7890dcdff589f10f47deea16dd" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005fcpu_005finit-1&quot;&gt;__builtin_cpu_init&lt;/strong&gt; (void)</source>
          <target state="translated">内置函数：void &lt;strong id=&quot;index-_005f_005fbuiltin_005fcpu_005finit-1&quot;&gt;__builtin_cpu_init&lt;/strong&gt;（void）</target>
        </trans-unit>
        <trans-unit id="d3cd845b205509711bbf6256051511ce8b3607ab" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005flongjmp&quot;&gt;__builtin_longjmp&lt;/strong&gt; (intptr_t *&lt;var&gt;buf&lt;/var&gt;, int &lt;var&gt;val&lt;/var&gt;)</source>
          <target state="translated">内置函数：void &lt;strong id=&quot;index-_005f_005fbuiltin_005flongjmp&quot;&gt;__builtin_longjmp&lt;/strong&gt;（intptr_t * &lt;var&gt;buf&lt;/var&gt; ，int &lt;var&gt;val&lt;/var&gt; ）</target>
        </trans-unit>
        <trans-unit id="fff14e5c46a00a91c0c0603fe5f170bde38d705e" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005fnds32_005fisb&quot;&gt;__builtin_nds32_isb&lt;/strong&gt; (void)</source>
          <target state="translated">内置函数：void &lt;strong id=&quot;index-_005f_005fbuiltin_005fnds32_005fisb&quot;&gt;__builtin_nds32_isb&lt;/strong&gt;（void）</target>
        </trans-unit>
        <trans-unit id="fe5501c6b5d93e7b033487f6a848dd334597db03" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005fnds32_005fisync&quot;&gt;__builtin_nds32_isync&lt;/strong&gt; (int *&lt;var&gt;addr&lt;/var&gt;)</source>
          <target state="translated">内置函数：void &lt;strong id=&quot;index-_005f_005fbuiltin_005fnds32_005fisync&quot;&gt;__builtin_nds32_isync&lt;/strong&gt;（int * &lt;var&gt;addr&lt;/var&gt; ）</target>
        </trans-unit>
        <trans-unit id="841f0b2bab051a37cafce912e8b554544bed4ffb" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005fnds32_005fmtsr&quot;&gt;__builtin_nds32_mtsr&lt;/strong&gt; (int &lt;var&gt;value&lt;/var&gt;, int &lt;var&gt;sr&lt;/var&gt;)</source>
          <target state="translated">内置函数：void &lt;strong id=&quot;index-_005f_005fbuiltin_005fnds32_005fmtsr&quot;&gt;__builtin_nds32_mtsr&lt;/strong&gt;（int &lt;var&gt;value&lt;/var&gt; ，int &lt;var&gt;sr&lt;/var&gt; ）</target>
        </trans-unit>
        <trans-unit id="df8bab86f6689c778da28b14954604543548fb9b" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005fnds32_005fmtusr&quot;&gt;__builtin_nds32_mtusr&lt;/strong&gt; (int &lt;var&gt;value&lt;/var&gt;, int &lt;var&gt;usr&lt;/var&gt;)</source>
          <target state="translated">内置函数：void &lt;strong id=&quot;index-_005f_005fbuiltin_005fnds32_005fmtusr&quot;&gt;__builtin_nds32_mtusr&lt;/strong&gt;（int &lt;var&gt;value&lt;/var&gt; ，int &lt;var&gt;usr&lt;/var&gt; ）</target>
        </trans-unit>
        <trans-unit id="cc7672c01bcce0ae5cb385b443579f1f0e814383" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005fnds32_005fsetgie_005fdis&quot;&gt;__builtin_nds32_setgie_dis&lt;/strong&gt; (void)</source>
          <target state="translated">内置函数：void &lt;strong id=&quot;index-_005f_005fbuiltin_005fnds32_005fsetgie_005fdis&quot;&gt;__builtin_nds32_setgie_dis&lt;/strong&gt;（void）</target>
        </trans-unit>
        <trans-unit id="01c2cb53755ea177e9b7bcabfb291e59bf8c8d8b" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005fnds32_005fsetgie_005fen&quot;&gt;__builtin_nds32_setgie_en&lt;/strong&gt; (void)</source>
          <target state="translated">内置函数：void &lt;strong id=&quot;index-_005f_005fbuiltin_005fnds32_005fsetgie_005fen&quot;&gt;__builtin_nds32_setgie_zh&lt;/strong&gt;（void）</target>
        </trans-unit>
        <trans-unit id="2f23c91db2e471b60a85c1d974b337410d93c4ae" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005fnon_005ftx_005fstore&quot;&gt;__builtin_non_tx_store&lt;/strong&gt; (uint64_t *, uint64_t)</source>
          <target state="translated">内置函数：void &lt;strong id=&quot;index-_005f_005fbuiltin_005fnon_005ftx_005fstore&quot;&gt;__builtin_non_tx_store&lt;/strong&gt;（uint64_t *，uint64_t）</target>
        </trans-unit>
        <trans-unit id="2321505821d1604108a7105b3b6858f231f0c9ea" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005fprefetch&quot;&gt;__builtin_prefetch&lt;/strong&gt; (const void *&lt;var&gt;addr&lt;/var&gt;, ...)</source>
          <target state="translated">内置函数：void &lt;strong id=&quot;index-_005f_005fbuiltin_005fprefetch&quot;&gt;__builtin_prefetch&lt;/strong&gt;（const void * &lt;var&gt;addr&lt;/var&gt; ，...）</target>
        </trans-unit>
        <trans-unit id="fe3fc0ac7968932105d1c1d3ab50d7b85cfe594b" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005freturn&quot;&gt;__builtin_return&lt;/strong&gt; (void *&lt;var&gt;result&lt;/var&gt;)</source>
          <target state="translated">内置函数：void &lt;strong id=&quot;index-_005f_005fbuiltin_005freturn&quot;&gt;__builtin_return&lt;/strong&gt;（void * &lt;var&gt;result&lt;/var&gt; ）</target>
        </trans-unit>
        <trans-unit id="a1a8dfdf0491f60d9f3285d8de87cb556335dd7c" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005fbrk&quot;&gt;__builtin_rx_brk&lt;/strong&gt; (void)</source>
          <target state="translated">内置函数：void &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005fbrk&quot;&gt;__builtin_rx_brk&lt;/strong&gt;（void）</target>
        </trans-unit>
        <trans-unit id="baafeee4f82f6b2b3615bbf58d2dd0b69de47091" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005fclrpsw&quot;&gt;__builtin_rx_clrpsw&lt;/strong&gt; (int)</source>
          <target state="translated">内置函数：void &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005fclrpsw&quot;&gt;__builtin_rx_clrpsw&lt;/strong&gt;（int）</target>
        </trans-unit>
        <trans-unit id="40ac58e52ec8cfeb1ed0ce17f884d6ca28de4bb2" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005fint&quot;&gt;__builtin_rx_int&lt;/strong&gt; (int)</source>
          <target state="translated">内置函数：void &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005fint&quot;&gt;__builtin_rx_int&lt;/strong&gt;（int）</target>
        </trans-unit>
        <trans-unit id="60f5dc479a3c9ca583cab1eca4c28279f3d7220a" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005fmachi&quot;&gt;__builtin_rx_machi&lt;/strong&gt; (int, int)</source>
          <target state="translated">内置函数：void &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005fmachi&quot;&gt;__builtin_rx_machi&lt;/strong&gt;（int，int）</target>
        </trans-unit>
        <trans-unit id="8e28f28fffe61c4b4679e59b89330fa5d0042874" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005fmaclo&quot;&gt;__builtin_rx_maclo&lt;/strong&gt; (int, int)</source>
          <target state="translated">内置函数：void &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005fmaclo&quot;&gt;__builtin_rx_maclo&lt;/strong&gt;（int，int）</target>
        </trans-unit>
        <trans-unit id="46c536195bce3a86157c9c49ee77c45d3577dcc4" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005fmulhi&quot;&gt;__builtin_rx_mulhi&lt;/strong&gt; (int, int)</source>
          <target state="translated">内置函数：void &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005fmulhi&quot;&gt;__builtin_rx_mulhi&lt;/strong&gt;（int，int）</target>
        </trans-unit>
        <trans-unit id="5621acbcbc1163f811efb159aa50ed209c490ad9" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005fmullo&quot;&gt;__builtin_rx_mullo&lt;/strong&gt; (int, int)</source>
          <target state="translated">内置函数：void &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005fmullo&quot;&gt;__builtin_rx_mullo&lt;/strong&gt;（int，int）</target>
        </trans-unit>
        <trans-unit id="227762640b3aca70bd083850fd27548557a69595" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005fmvtachi&quot;&gt;__builtin_rx_mvtachi&lt;/strong&gt; (int)</source>
          <target state="translated">内置函数：void &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005fmvtachi&quot;&gt;__builtin_rx_mvtachi&lt;/strong&gt;（int）</target>
        </trans-unit>
        <trans-unit id="4eefd425b2ddf508a48e8a2189b6454058653fea" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005fmvtaclo&quot;&gt;__builtin_rx_mvtaclo&lt;/strong&gt; (int)</source>
          <target state="translated">内置函数：void &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005fmvtaclo&quot;&gt;__builtin_rx_mvtaclo&lt;/strong&gt;（int）</target>
        </trans-unit>
        <trans-unit id="662dad4c2fd795f4f1dddab9d3e0737c1c8a5708" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005fmvtc&quot;&gt;__builtin_rx_mvtc&lt;/strong&gt; (int reg, int val)</source>
          <target state="translated">内置函数：void &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005fmvtc&quot;&gt;__builtin_rx_mvtc&lt;/strong&gt;（int reg，int val）</target>
        </trans-unit>
        <trans-unit id="276391cb278528b1f872b1280affb29edbd7927c" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005fmvtipl&quot;&gt;__builtin_rx_mvtipl&lt;/strong&gt; (int)</source>
          <target state="translated">内置函数：void &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005fmvtipl&quot;&gt;__builtin_rx_mvtipl&lt;/strong&gt;（int）</target>
        </trans-unit>
        <trans-unit id="700036ac6c5189b95316dbc5c4ae3b0309325df1" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005fracw&quot;&gt;__builtin_rx_racw&lt;/strong&gt; (int)</source>
          <target state="translated">内置函数：void &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005fracw&quot;&gt;__builtin_rx_racw&lt;/strong&gt;（int）</target>
        </trans-unit>
        <trans-unit id="c48b2b82b14ae8b91fdb2fe28e06b8ea0b1cb522" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005frmpa&quot;&gt;__builtin_rx_rmpa&lt;/strong&gt; (void)</source>
          <target state="translated">内置函数：void &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005frmpa&quot;&gt;__builtin_rx_rmpa&lt;/strong&gt;（void）</target>
        </trans-unit>
        <trans-unit id="4595d30c690a3b8c89c7807c08a9959f30d56800" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005fround&quot;&gt;__builtin_rx_round&lt;/strong&gt; (float)</source>
          <target state="translated">内置函数：void &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005fround&quot;&gt;__builtin_rx_round&lt;/strong&gt;（float）</target>
        </trans-unit>
        <trans-unit id="c5948033a96e4003655c71953e27a3f9741045b3" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005fsetpsw&quot;&gt;__builtin_rx_setpsw&lt;/strong&gt; (int)</source>
          <target state="translated">内置函数：void &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005fsetpsw&quot;&gt;__builtin_rx_setpsw&lt;/strong&gt;（int）</target>
        </trans-unit>
        <trans-unit id="f89dbf6d50890784687748f168df8d729aebf79c" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005fwait&quot;&gt;__builtin_rx_wait&lt;/strong&gt; (void)</source>
          <target state="translated">内置函数：void &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005fwait&quot;&gt;__builtin_rx_wait&lt;/strong&gt;（void）</target>
        </trans-unit>
        <trans-unit id="95b218b72a2c6b938556ce1a8c8a3cca255a13b1" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005fset_005fthread_005fpointer&quot;&gt;__builtin_set_thread_pointer&lt;/strong&gt; (void *&lt;var&gt;ptr&lt;/var&gt;)</source>
          <target state="translated">内置函数：void &lt;strong id=&quot;index-_005f_005fbuiltin_005fset_005fthread_005fpointer&quot;&gt;__builtin_set_thread_pointer&lt;/strong&gt;（void * &lt;var&gt;ptr&lt;/var&gt; ）</target>
        </trans-unit>
        <trans-unit id="2db4725d0eae1acd204db5ae18744d85101db3ea" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005fsh_005fset_005ffpscr&quot;&gt;__builtin_sh_set_fpscr&lt;/strong&gt; (unsigned int &lt;var&gt;val&lt;/var&gt;)</source>
          <target state="translated">内置函数：void &lt;strong id=&quot;index-_005f_005fbuiltin_005fsh_005fset_005ffpscr&quot;&gt;__builtin_sh_set_fpscr&lt;/strong&gt;（unsigned int &lt;var&gt;val&lt;/var&gt; ）</target>
        </trans-unit>
        <trans-unit id="f9baaf9b0798ed586e63831552a408b61b1a992c" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005ftabort&quot;&gt;__builtin_tabort&lt;/strong&gt; (int)</source>
          <target state="translated">内置函数：void &lt;strong id=&quot;index-_005f_005fbuiltin_005ftabort&quot;&gt;__builtin_tabort&lt;/strong&gt;（int）</target>
        </trans-unit>
        <trans-unit id="d228c7f65857695f955c2630b92714965d36378f" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005ftbeginc&quot;&gt;__builtin_tbeginc&lt;/strong&gt; (void)</source>
          <target state="translated">内置函数：void &lt;strong id=&quot;index-_005f_005fbuiltin_005ftbeginc&quot;&gt;__builtin_tbeginc&lt;/strong&gt;（void）</target>
        </trans-unit>
        <trans-unit id="94689ecdbd4d60ff7b0fd602ce7245bc7b6beb10" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005ftrap&quot;&gt;__builtin_trap&lt;/strong&gt; (void)</source>
          <target state="translated">内置函数：void &lt;strong id=&quot;index-_005f_005fbuiltin_005ftrap&quot;&gt;__builtin_trap&lt;/strong&gt;（void）</target>
        </trans-unit>
        <trans-unit id="4a1c671de0baf7c15aaf53f248312afd293d5b33" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005ftx_005fassist&quot;&gt;__builtin_tx_assist&lt;/strong&gt; (int)</source>
          <target state="translated">内置函数：void &lt;strong id=&quot;index-_005f_005fbuiltin_005ftx_005fassist&quot;&gt;__builtin_tx_assist&lt;/strong&gt;（int）</target>
        </trans-unit>
        <trans-unit id="5904be3f2c9a60beac8be0103847c267a6f80e80" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005funreachable&quot;&gt;__builtin_unreachable&lt;/strong&gt; (void)</source>
          <target state="translated">内置函数：void &lt;strong id=&quot;index-_005f_005fbuiltin_005funreachable&quot;&gt;__builtin_unreachable&lt;/strong&gt;（void）</target>
        </trans-unit>
        <trans-unit id="836cf5a0e71cae3a60324503179866ad686508a7" translate="yes" xml:space="preserve">
          <source>Built-in functions for limited buffer overflow checking.</source>
          <target state="translated">内置功能,用于有限的缓冲区溢出检查。</target>
        </trans-unit>
        <trans-unit id="d4b5ba0eb7000fc998fff5b209a2516ba2e54a3f" translate="yes" xml:space="preserve">
          <source>Built-in functions specific to particular targets.</source>
          <target state="translated">针对特定目标的内置功能。</target>
        </trans-unit>
        <trans-unit id="253258e2e82600175022e888019e1f8e9ab9c3a1" translate="yes" xml:space="preserve">
          <source>Built-in functions to perform arithmetics and arithmetic overflow checking.</source>
          <target state="translated">内建函数来执行算术和算术溢出检查。</target>
        </trans-unit>
        <trans-unit id="4708bb7371d5b0f788e5028a015745453830a6ee" translate="yes" xml:space="preserve">
          <source>Built-in macros, macros defined on the command line, and macros defined in include files are not warned about.</source>
          <target state="translated">内置宏、在命令行定义的宏和在include文件中定义的宏都不会被警告。</target>
        </trans-unit>
        <trans-unit id="606b68375f39bb1e243e870d45cdf01eab0caad3" translate="yes" xml:space="preserve">
          <source>But if you need to debug a problem with method signatures and need to know how they are implemented (i.e., the &amp;ldquo;ABI&amp;rdquo;), read on.</source>
          <target state="translated">但是，如果您需要调试方法签名的问题，并且需要知道如何实现它们（即&amp;ldquo; ABI&amp;rdquo;），请继续阅读。</target>
        </trans-unit>
        <trans-unit id="18ba03b4395ba58ba0713d75a0907aa6ed34a2f6" translate="yes" xml:space="preserve">
          <source>But in the definition of &lt;code&gt;foo&lt;/code&gt;, the file-scope type is used because that is available to be inherited. Thus, the definition and the prototype do not match, and you get an error.</source>
          <target state="translated">但是在 &lt;code&gt;foo&lt;/code&gt; 的定义中，使用了文件作用域类型，因为它可以被继承。因此，定义和原型不匹配，并且会出现错误。</target>
        </trans-unit>
        <trans-unit id="54f71fd5d9e178736a8b25951cca5312e798d273" translate="yes" xml:space="preserve">
          <source>But in this example, the &lt;code&gt;std::move&lt;/code&gt; call prevents copy elision.</source>
          <target state="translated">但是在此示例中， &lt;code&gt;std::move&lt;/code&gt; 调用可防止复制省略。</target>
        </trans-unit>
        <trans-unit id="cf56c043a9173e054f17c75c7e06c6a5d352b771" translate="yes" xml:space="preserve">
          <source>But this definition computes either &lt;var id=&quot;index-side-effects_002c-macro-argument&quot;&gt;a&lt;/var&gt; or &lt;var&gt;b&lt;/var&gt; twice, with bad results if the operand has side effects. In GNU C, if you know the type of the operands (here taken as &lt;code&gt;int&lt;/code&gt;), you can avoid this problem by defining the macro as follows:</source>
          <target state="translated">但是此定义计算 &lt;var id=&quot;index-side-effects_002c-macro-argument&quot;&gt;a&lt;/var&gt; 或 &lt;var&gt;b&lt;/var&gt; 两次，如果操作数有副作用，则结果会很差。在GNU C中，如果您知道操作数的类型（此处为 &lt;code&gt;int&lt;/code&gt; ），则可以通过如下定义宏来避免此问题：</target>
        </trans-unit>
        <trans-unit id="089c24745336688f5099a4bd50557aedc8fc6fff" translate="yes" xml:space="preserve">
          <source>By contrast, PCC on most target machines returns structures and unions of any size by copying the data into an area of static storage, and then returning the address of that storage as if it were a pointer value. The caller must copy the data from that memory area to the place where the value is wanted. GCC does not use this method because it is slower and nonreentrant.</source>
          <target state="translated">相比之下,大多数目标机上的PCC通过将数据复制到静态存储区域中,然后像返回指针值一样返回该存储区域的地址,从而返回任意大小的结构和联合。调用者必须将数据从那个存储区域复制到想要值的地方。GCC不使用这种方法,因为它比较慢而且不重入。</target>
        </trans-unit>
        <trans-unit id="8e8864b0dc6da1e44443610d33567bb75bb81d17" translate="yes" xml:space="preserve">
          <source>By declaring a function inline, you can direct GCC to make calls to that function faster. One way GCC can achieve this is to integrate that function&amp;rsquo;s code into the code for its callers. This makes execution faster by eliminating the function-call overhead; in addition, if any of the actual argument values are constant, their known values may permit simplifications at compile time so that not all of the inline function&amp;rsquo;s code needs to be included. The effect on code size is less predictable; object code may be larger or smaller with function inlining, depending on the particular case. You can also direct GCC to try to integrate all &amp;ldquo;simple enough&amp;rdquo; functions into their callers with the option</source>
          <target state="translated">通过声明一个函数内联，您可以指示GCC更快地调用该函数。 GCC可以做到这一点的一种方法是将该函数的代码集成到其调用者的代码中。通过消除函数调用开销，这使执行速度更快。另外，如果任何实际参数值是恒定的，则它们的已知值可能会在编译时进行简化，因此不必包括所有内联函数的代码。对代码大小的影响难以预测。根据具体情况，使用函数内联可以使目标代码更大或更小。您还可以指示GCC尝试使用选项将所有&amp;ldquo;足够简单&amp;rdquo;的功能集成到其调用方中</target>
        </trans-unit>
        <trans-unit id="571c61d917cc3bc4c5e2835a5dd40c5c41bd768f" translate="yes" xml:space="preserve">
          <source>By default (unless configured otherwise), GCC generates code for the GR5 variant of the Visium architecture.</source>
          <target state="translated">默认情况下(除非另有配置),GCC会生成Visium架构的GR5变体的代码。</target>
        </trans-unit>
        <trans-unit id="8ff1bd96a4bdcc76b002de9ee97861c9f804a0dc" translate="yes" xml:space="preserve">
          <source>By default (unless configured otherwise), GCC generates code for the V7 variant of the SPARC architecture. With</source>
          <target state="translated">默认情况下(除非另有配置),GCC生成SPARC架构V7变体的代码。如果使用</target>
        </trans-unit>
        <trans-unit id="ee5c102e65c6f170a209b204a4dbc9b094f06846" translate="yes" xml:space="preserve">
          <source>By default GCC inlines string operations only when the destination is known to be aligned to least a 4-byte boundary. This enables more inlining and increases code size, but may improve performance of code that depends on fast &lt;code&gt;memcpy&lt;/code&gt;, &lt;code&gt;strlen&lt;/code&gt;, and &lt;code&gt;memset&lt;/code&gt; for short lengths.</source>
          <target state="translated">默认情况下，仅当已知目标与至少4个字节的边界对齐时，GCC才会内联字符串操作。这样可以进行更多的内联并增加代码大小，但是可以提高依赖于快速 &lt;code&gt;memcpy&lt;/code&gt; ， &lt;code&gt;strlen&lt;/code&gt; 和 &lt;code&gt;memset&lt;/code&gt; 的短长度代码的性能。</target>
        </trans-unit>
        <trans-unit id="828f5d805ef0fc5866d738b0ffbff970c7d7f41f" translate="yes" xml:space="preserve">
          <source>By default assume that all calls are far away so that a longer and more expensive calling sequence is required. This is required for calls farther than 32 megabytes (33,554,432 bytes) from the current location. A short call is generated if the compiler knows the call cannot be that far away. This setting can be overridden by the &lt;code&gt;shortcall&lt;/code&gt; function attribute, or by &lt;code&gt;#pragma
longcall(0)&lt;/code&gt;.</source>
          <target state="translated">默认情况下，假设所有呼叫都在远处，因此需要更长和更昂贵的呼叫顺序。对于距离当前位置超过32兆字节（33,554,432字节）的呼叫，这是必需的。如果编译器知道该调用不能那么远，则会生成一个短调用。可以通过 &lt;code&gt;shortcall&lt;/code&gt; 函数属性或 &lt;code&gt;#pragma longcall(0)&lt;/code&gt; 覆盖此设置。</target>
        </trans-unit>
        <trans-unit id="e7d64d02eb42b84df503cac7606206757e75fdfc" translate="yes" xml:space="preserve">
          <source>By default instance variables in Objective-C can be accessed as if they were local variables from within the methods of the class they&amp;rsquo;re declared in. This can lead to shadowing between instance variables and other variables declared either locally inside a class method or globally with the same name. Specifying the</source>
          <target state="translated">默认情况下，可以访问Objective-C中的实例变量，就好像它们是在声明它们的类的方法内是局部变量一样。这可能导致实例变量与其他在类方法内部或全局声明的变量之间产生阴影。同名。指定</target>
        </trans-unit>
        <trans-unit id="812f601802f8d41b61d44c3f0bd220d17f966e00" translate="yes" xml:space="preserve">
          <source>By default it is treated as &lt;code&gt;signed int&lt;/code&gt; but this may be changed by the</source>
          <target state="translated">默认情况下，它被视为有 &lt;code&gt;signed int&lt;/code&gt; 但这可能会被</target>
        </trans-unit>
        <trans-unit id="42ef9328c623bad5538b4f26249da5459c5c08d3" translate="yes" xml:space="preserve">
          <source>By default or when</source>
          <target state="translated">默认情况下或当</target>
        </trans-unit>
        <trans-unit id="c9b76575429db7ab5c66debc083d774f7e949e1c" translate="yes" xml:space="preserve">
          <source>By default this feature is not enabled. The default can be restored via the</source>
          <target state="translated">默认情况下,该功能未被启用。默认值可以通过</target>
        </trans-unit>
        <trans-unit id="be7bad4b8f0ace00e1f8f2cdea4bdacee4c90882" translate="yes" xml:space="preserve">
          <source>By default when the C++ frontend prints diagnostics showing mismatching template types, common parts of the types are printed as &amp;ldquo;[...]&amp;rdquo; to simplify the error message. For example:</source>
          <target state="translated">默认情况下，当C ++前端打印出显示模板类型不匹配的诊断信息时，这些类型的公共部分将打印为&amp;ldquo; [...]&amp;rdquo;以简化错误消息。例如：</target>
        </trans-unit>
        <trans-unit id="e5c0fdbe4acada00b33542c8af5765b2142c6787" translate="yes" xml:space="preserve">
          <source>By default, GCC also provides some additional extensions to the C++ language that on rare occasions conflict with the C++ standard. See &lt;a href=&quot;c_002b_002b-dialect-options#C_002b_002b-Dialect-Options&quot;&gt;Options Controlling C++ Dialect&lt;/a&gt;. Use of the</source>
          <target state="translated">默认情况下，GCC还为C ++语言提供了一些其他扩展，这些扩展在极少数情况下与C ++标准冲突。请参阅&lt;a href=&quot;c_002b_002b-dialect-options#C_002b_002b-Dialect-Options&quot;&gt;控制C ++语言的选项&lt;/a&gt;。使用</target>
        </trans-unit>
        <trans-unit id="1b721c8be1fed47cd95a2b324cc0ec1f3f3fd2db" translate="yes" xml:space="preserve">
          <source>By default, GCC emits an error message if the feedback profiles do not match the source code. This error can be turned into a warning by using</source>
          <target state="translated">默认情况下,如果反馈配置文件与源代码不匹配,GCC会发出一条错误信息。这个错误可以通过使用</target>
        </trans-unit>
        <trans-unit id="68205120aabfb538f7bc7f4202c9b447a1cf9091" translate="yes" xml:space="preserve">
          <source>By default, GCC generates a branch hint instruction to avoid pipeline stalls for always-taken or probably-taken branches. A hint is not generated closer than 8 instructions away from its branch. There is little reason to disable them, except for debugging purposes, or to make an object a little bit smaller.</source>
          <target state="translated">默认情况下,GCC会生成一个分支提示指令,以避免总是被占用或可能被占用的分支出现管道停顿。在距离分支超过8条指令的地方,不会生成提示指令。除了为了调试的目的,或者为了让对象变得更小一点,没有什么理由禁用它们。</target>
        </trans-unit>
        <trans-unit id="0f0fae0fc27ffb4e00a4f068905f564a20595bd8" translate="yes" xml:space="preserve">
          <source>By default, GCC generates code assuming that addresses are never larger than 18 bits. With</source>
          <target state="translated">默认情况下,GCC生成的代码假定地址永远不会大于18位。如果使用</target>
        </trans-unit>
        <trans-unit id="bfc14d5fdff5ebfd96cb93f60f01d2cd55db824a" translate="yes" xml:space="preserve">
          <source>By default, GCC ignores trigraphs, but in standard-conforming modes it converts them. See the</source>
          <target state="translated">默认情况下,GCC会忽略三角图,但在符合标准的模式下,它会转换三角图。参见</target>
        </trans-unit>
        <trans-unit id="7b2b09a4a457e7ae05463c18b24ed251756826ce" translate="yes" xml:space="preserve">
          <source>By default, GCC inserts NOPs to increase dual issue when it expects it to increase performance. &lt;var&gt;n&lt;/var&gt; can be a value from 0 to 10. A smaller &lt;var&gt;n&lt;/var&gt; inserts fewer NOPs. 10 is the default, 0 is the same as</source>
          <target state="translated">默认情况下，当GCC希望提高性能时，会插入NOP来增加双重问题。 &lt;var&gt;n&lt;/var&gt; 可以是0到10之间的值。较小的 &lt;var&gt;n&lt;/var&gt; 插入较少的NOP。默认值为10，0等于</target>
        </trans-unit>
        <trans-unit id="fb6ff38e6ed640debf4ee9a5067811f24a626ac7" translate="yes" xml:space="preserve">
          <source>By default, GCC limits the size of functions that can be inlined. This flag allows coarse control of this limit. &lt;var&gt;n&lt;/var&gt; is the size of functions that can be inlined in number of pseudo instructions.</source>
          <target state="translated">默认情况下，GCC限制可以内联的函数的大小。该标志允许对该限制进行粗略控制。 &lt;var&gt;n&lt;/var&gt; 是可以内嵌在伪指令数量中的函数的大小。</target>
        </trans-unit>
        <trans-unit id="9bf107b2c0510e1f5a934dedd69183ab9f3da713" translate="yes" xml:space="preserve">
          <source>By default, GCC links against startup code that assumes the SPU-style main function interface (which has an unconventional parameter list). With</source>
          <target state="translated">默认情况下,GCC会针对假定使用SPU风格的主函数接口(它有一个非常规的参数列表)的启动代码进行链接。如果使用</target>
        </trans-unit>
        <trans-unit id="7b2fda2cbe2c03ae974fe1e7172dd8c82c7ece3a" translate="yes" xml:space="preserve">
          <source>By default, GCC provides some extensions to the C language that, on rare occasions conflict with the C standard. See &lt;a href=&quot;c-extensions#C-Extensions&quot;&gt;Extensions to the C Language Family&lt;/a&gt;. Some features that are part of the C99 standard are accepted as extensions in C90 mode, and some features that are part of the C11 standard are accepted as extensions in C90 and C99 modes. Use of the</source>
          <target state="translated">默认情况下，GCC提供了一些C语言扩展，在极少数情况下会与C标准冲突。请参见&lt;a href=&quot;c-extensions#C-Extensions&quot;&gt;C语言家族的扩展&lt;/a&gt;。在C90模式下，某些扩展功能被接受为C99标准的一部分，在C90和C99模式下，某些扩展功能被接受为C11标准的一部分。使用</target>
        </trans-unit>
        <trans-unit id="2e7c9e5570dcde91269bdc30909a64efa434ef4f" translate="yes" xml:space="preserve">
          <source>By default, each diagnostic emitted includes text indicating the command-line option that directly controls the diagnostic (if such an option is known to the diagnostic machinery). Specifying the</source>
          <target state="translated">默认情况下,每个诊断器发出的文本包括指示直接控制诊断器的命令行选项的文本(如果诊断器知道有这样的选项)。指定</target>
        </trans-unit>
        <trans-unit id="6a4309cf8cee66811505f90edea42d61f9045107" translate="yes" xml:space="preserve">
          <source>By default, each diagnostic emitted includes the original source line and a caret &amp;lsquo;</source>
          <target state="translated">默认情况下，发出的每个诊断都包括原始源代码行和插入符号'</target>
        </trans-unit>
        <trans-unit id="7763701cba03a5661d0405bf0959714c47202a4e" translate="yes" xml:space="preserve">
          <source>By default, only &amp;ldquo;high-level&amp;rdquo; messages are emitted. This option enables additional, more detailed, messages, which are likely to only be of interest to GCC developers.</source>
          <target state="translated">默认情况下，仅发出&amp;ldquo;高级&amp;rdquo;消息。此选项启用其他更详细的消息，这些消息可能仅对GCC开发人员感兴趣。</target>
        </trans-unit>
        <trans-unit id="7d31796fedde16b57588ddd5284b3abd8463c996" translate="yes" xml:space="preserve">
          <source>By default, the assembler file name for a source file is made by replacing the suffix &amp;lsquo;</source>
          <target state="translated">默认情况下，源文件的汇编文件名是通过替换后缀'</target>
        </trans-unit>
        <trans-unit id="10caadf2568f37c4e4608d0c62719e2855118ce6" translate="yes" xml:space="preserve">
          <source>By default, the dump will contain messages about successful optimizations (equivalent to</source>
          <target state="translated">默认情况下,dump将包含关于成功优化的消息(相当于</target>
        </trans-unit>
        <trans-unit id="ae9a2b16ff551e2f7ff627c2fd6228056bed25a8" translate="yes" xml:space="preserve">
          <source>By default, the keyword &lt;code&gt;__vector&lt;/code&gt; is added. The macro &lt;code&gt;vector&lt;/code&gt; is defined in &lt;code&gt;&amp;lt;spu_intrinsics.h&amp;gt;&lt;/code&gt; and can be undefined.</source>
          <target state="translated">默认情况下，添加关键字 &lt;code&gt;__vector&lt;/code&gt; 。宏 &lt;code&gt;vector&lt;/code&gt; 在 &lt;code&gt;&amp;lt;spu_intrinsics.h&amp;gt;&lt;/code&gt; 中定义，可以不确定。</target>
        </trans-unit>
        <trans-unit id="b102924aa2fe89599576741a2bd8c5becb0889f6" translate="yes" xml:space="preserve">
          <source>By default, the object file name for a source file is made by replacing the suffix &amp;lsquo;</source>
          <target state="translated">默认情况下，源文件的目标文件名是通过替换后缀'</target>
        </trans-unit>
        <trans-unit id="4e689c10c02894b0d8e0dcec9a7f6bd5f47a0486" translate="yes" xml:space="preserve">
          <source>By default, when printing source code (via</source>
          <target state="translated">默认情况下,当打印源代码时(通过</target>
        </trans-unit>
        <trans-unit id="f618b8855eb83706e0dd5ba4b20f8784c6acdce1" translate="yes" xml:space="preserve">
          <source>Byte swap. Return the result of swapping the upper and lower bytes of &lt;var&gt;value&lt;/var&gt;.</source>
          <target state="translated">字节交换。返回交换 &lt;var&gt;value&lt;/var&gt; 的高低字节的结果。</target>
        </trans-unit>
        <trans-unit id="32096c2e0eff33d844ee6d675407ace18289357d" translate="yes" xml:space="preserve">
          <source>C</source>
          <target state="translated">C</target>
        </trans-unit>
        <trans-unit id="8c7f20acc9bb2d58739f2e1f94cb9494f549d093" translate="yes" xml:space="preserve">
          <source>C Language Options</source>
          <target state="translated">C语言选项</target>
        </trans-unit>
        <trans-unit id="4f2345e5746cc2edc7fabec343cb3f91233c3786" translate="yes" xml:space="preserve">
          <source>C and Objective-C-only Warning Options</source>
          <target state="translated">只有C和Objective-C的警告选项</target>
        </trans-unit>
        <trans-unit id="a16bcf14a78c44b6bfc6c36207ff504cb459f2ef" translate="yes" xml:space="preserve">
          <source>C code</source>
          <target state="translated">C码</target>
        </trans-unit>
        <trans-unit id="43bd1aa29c2f227114eb9168f3aeb20a853ce287" translate="yes" xml:space="preserve">
          <source>C contains many standard functions that return a value that most programs choose to ignore. One obvious example is &lt;code&gt;printf&lt;/code&gt;. Warning about this practice only leads the defensive programmer to clutter programs with dozens of casts to &lt;code&gt;void&lt;/code&gt;. Such casts are required so frequently that they become visual noise. Writing those casts becomes so automatic that they no longer convey useful information about the intentions of the programmer. For functions where the return value should never be ignored, use the &lt;code&gt;warn_unused_result&lt;/code&gt; function attribute (see &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;Function Attributes&lt;/a&gt;).</source>
          <target state="translated">C包含许多标准函数，这些函数返回大多数程序选择忽略的值。一个明显的例子是 &lt;code&gt;printf&lt;/code&gt; 。对这种做法的警告仅会使防御性程序员陷入混乱的程序，数十次强制转换 &lt;code&gt;void&lt;/code&gt; 。如此频繁地需要这样的演员，以至于它们变成视觉噪音。编写这些强制类型转换变得非常自动，以致它们不再传达有关程序员意图的有用信息。对于不应忽略返回值的函数，请使用 &lt;code&gt;warn_unused_result&lt;/code&gt; 函数属性（请参见&lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;函数属性&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="6cc85e5ef0494952e2e594d8f572f0cb62561829" translate="yes" xml:space="preserve">
          <source>C has the concept of volatile objects. These are normally accessed by pointers and used for accessing hardware or inter-thread communication. The standard encourages compilers to refrain from optimizations concerning accesses to volatile objects, but leaves it implementation defined as to what constitutes a volatile access. The minimum requirement is that at a sequence point all previous accesses to volatile objects have stabilized and no subsequent accesses have occurred. Thus an implementation is free to reorder and combine volatile accesses that occur between sequence points, but cannot do so for accesses across a sequence point. The use of volatile does not allow you to violate the restriction on updating objects multiple times between two sequence points.</source>
          <target state="translated">C语言有易失性对象的概念。这些对象通常由指针访问,用于访问硬件或线程间通信。标准鼓励编译器避免对易失性对象的访问进行优化,但对于什么是易失性访问,则让编译器在实施时加以定义。最低要求是在一个序列点上,之前对易失性对象的所有访问都已经稳定下来,并且没有后续的访问发生。因此,实现可以自由地对序列点之间发生的volatile访问进行重新排序和组合,但不能对跨序列点的访问进行排序和组合。使用volatile不允许违反两个序列点之间多次更新对象的限制。</target>
        </trans-unit>
        <trans-unit id="c49f69bf7866959fd041d254d44ecd95bab5ba98" translate="yes" xml:space="preserve">
          <source>C register.</source>
          <target state="translated">C寄存器。</target>
        </trans-unit>
        <trans-unit id="2327d3d6eb8a5f7ce91755caf9e65d7a2e7dc1de" translate="yes" xml:space="preserve">
          <source>C source code that must be preprocessed.</source>
          <target state="translated">必须进行预处理的C源代码。</target>
        </trans-unit>
        <trans-unit id="61f8a2e0d02a243e776c6bb9750832b606cb81e5" translate="yes" xml:space="preserve">
          <source>C source code that should not be preprocessed.</source>
          <target state="translated">不应预处理的C源代码。</target>
        </trans-unit>
        <trans-unit id="11548c240585bf5af759bc0a6b301b88b353e27e" translate="yes" xml:space="preserve">
          <source>C++ Language Options</source>
          <target state="translated">C++语言选项</target>
        </trans-unit>
        <trans-unit id="57f68a93b1bb79e369d8676d696444f1cbbc7bb2" translate="yes" xml:space="preserve">
          <source>C++ comments are recognized.</source>
          <target state="translated">C++注释被认可。</target>
        </trans-unit>
        <trans-unit id="7f61cc8037210ca9970d93d649a42c41aee100de" translate="yes" xml:space="preserve">
          <source>C++ concepts provide much-improved support for generic programming. In particular, they allow the specification of constraints on template arguments. The constraints are used to extend the usual overloading and partial specialization capabilities of the language, allowing generic data structures and algorithms to be &amp;ldquo;refined&amp;rdquo; based on their properties rather than their type names.</source>
          <target state="translated">C ++概念为通用编程提供了大大改进的支持。特别是，它们允许指定对模板参数的约束。约束用于扩展语言的常规重载和部分专业化功能，从而允许根据通用数据结构和算法的属性（而不是类型名称）&amp;ldquo;完善&amp;rdquo;它们。</target>
        </trans-unit>
        <trans-unit id="98cd14ec337b46f3c719029c11a0be19021fb2b8" translate="yes" xml:space="preserve">
          <source>C++ header file to be turned into a precompiled header or Ada spec.</source>
          <target state="translated">将C++头文件转化为预编译的头文件或Ada规范。</target>
        </trans-unit>
        <trans-unit id="f7bc99762b7f83b6b621c845d769390544ce75a0" translate="yes" xml:space="preserve">
          <source>C++ is a complex language and an evolving one, and its standard definition (the ISO C++ standard) was only recently completed. As a result, your C++ compiler may occasionally surprise you, even when its behavior is correct. This section discusses some areas that frequently give rise to questions of this sort.</source>
          <target state="translated">C++是一门复杂的语言,也是一门不断发展的语言,它的标准定义(ISO C++标准)最近才完成。因此,你的C++编译器可能偶尔会让你感到惊讶,即使它的行为是正确的。本节将讨论一些经常引起这类问题的领域。</target>
        </trans-unit>
        <trans-unit id="e84a747565fa51df782491a580d39e6a3f403239" translate="yes" xml:space="preserve">
          <source>C++ requires information about types to be written out in order to implement &amp;lsquo;</source>
          <target state="translated">C ++要求将有关类型的信息写出来，以实现&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="fda8008d202b2d7ff2b02b361c7ea913221a6d44" translate="yes" xml:space="preserve">
          <source>C++ source code that must be preprocessed. Note that in &amp;lsquo;</source>
          <target state="translated">必须预处理的C ++源代码。请注意，</target>
        </trans-unit>
        <trans-unit id="99fa7c5a2c337828c11bc2c4ade3aae26a30fe89" translate="yes" xml:space="preserve">
          <source>C++ source code that should not be preprocessed.</source>
          <target state="translated">不应预处理的C++源码。</target>
        </trans-unit>
        <trans-unit id="cc9e861072d065eff5c8caf3bd72ac42f37e3e61" translate="yes" xml:space="preserve">
          <source>C++ source files conventionally use one of the suffixes &amp;lsquo;</source>
          <target state="translated">C ++源文件通常使用后缀'</target>
        </trans-unit>
        <trans-unit id="e4d70d761fb7676ae22ebe197ff2d2dd053c553d" translate="yes" xml:space="preserve">
          <source>C++ templates were the first language feature to require more intelligence from the environment than was traditionally found on a UNIX system. Somehow the compiler and linker have to make sure that each template instance occurs exactly once in the executable if it is needed, and not at all otherwise. There are two basic approaches to this problem, which are referred to as the Borland model and the Cfront model.</source>
          <target state="translated">C++模板是第一个要求环境提供比传统的UNIX系统更多智能的语言特性。编译器和链接器必须以某种方式确保每个模板实例在可执行文件中准确地出现一次,如果需要的话,否则完全不需要。有两种基本的方法来解决这个问题,它们被称为Borland模型和Cfront模型。</target>
        </trans-unit>
        <trans-unit id="16bd188cbd64c4bf1a17218266102bf9d269e075" translate="yes" xml:space="preserve">
          <source>C++ virtual functions are implemented in most compilers using a lookup table, known as a vtable. The vtable contains pointers to the virtual functions provided by a class, and each object of the class contains a pointer to its vtable (or vtables, in some multiple-inheritance situations). If the class declares any non-inline, non-pure virtual functions, the first one is chosen as the &amp;ldquo;key method&amp;rdquo; for the class, and the vtable is only emitted in the translation unit where the key method is defined.</source>
          <target state="translated">大多数编译器使用查找表（称为vtable）来实现C ++虚函数。vtable包含指向类提供的虚函数的指针，并且该类的每个对象均包含指向其vtable的指针（在某些多继承情况下，该vtable）。如果该类声明了任何非内联非纯虚函数，则将第一个选择为该类的&amp;ldquo;键方法&amp;rdquo;，并且vtable仅在定义了键方法的转换单元中发出。</target>
        </trans-unit>
        <trans-unit id="17265012fdaf7b797d7862b29ff392331cd3a4a0" translate="yes" xml:space="preserve">
          <source>C++17 provides a standard way to suppress the</source>
          <target state="translated">C++17提供了一种标准的方法来抑制</target>
        </trans-unit>
        <trans-unit id="f78d571177e03968d05d81e87283c743f9bd11eb" translate="yes" xml:space="preserve">
          <source>C, C++, Objective-C or Objective-C++ header file to be turned into a precompiled header (default), or C, C++ header file to be turned into an Ada spec (via the</source>
          <target state="translated">C、C++、Objective-C或Objective-C++头文件要变成预编译的头文件(默认),或C、C++头文件要变成Ada规范(经过</target>
        </trans-unit>
        <trans-unit id="6297518e9deb3ffb36cfb4da17e5731d4f43ddd3" translate="yes" xml:space="preserve">
          <source>C-EUCJP</source>
          <target state="translated">C-EUCJP</target>
        </trans-unit>
        <trans-unit id="fea2102020df627a3fcd18f01c6b90d1d1ebc0a5" translate="yes" xml:space="preserve">
          <source>C-JIS</source>
          <target state="translated">C-JIS</target>
        </trans-unit>
        <trans-unit id="8aed662488c94d21a572d72dd344a0c46e870bc0" translate="yes" xml:space="preserve">
          <source>C-SJIS</source>
          <target state="translated">C-SJIS</target>
        </trans-unit>
        <trans-unit id="e1c33b8c4686460cd515031a9d28c68a3cfcef87" translate="yes" xml:space="preserve">
          <source>C-SKY&amp;mdash;</source>
          <target state="translated">C-SKY&amp;mdash;</target>
        </trans-unit>
        <trans-unit id="e66b4865aad9938d99c99c6f4ab23939ca58e09e" translate="yes" xml:space="preserve">
          <source>C99 Annex F is followed.</source>
          <target state="translated">C99附件F得到了遵守。</target>
        </trans-unit>
        <trans-unit id="0817809900308ce7f22b686082215869550cf931" translate="yes" xml:space="preserve">
          <source>C99 restricted pointers and references.</source>
          <target state="translated">C99限制性指针和引用。</target>
        </trans-unit>
        <trans-unit id="792d9ffa119c05fda74148cc441c8be905361027" translate="yes" xml:space="preserve">
          <source>CALL_INSN</source>
          <target state="translated">CALL_INSN</target>
        </trans-unit>
        <trans-unit id="a4c1d0441ce79e81e5b485ea5fcda7d1c56b743e" translate="yes" xml:space="preserve">
          <source>CB</source>
          <target state="translated">CB</target>
        </trans-unit>
        <trans-unit id="7c9c078a9c0f1169f25be27f38940093778bb37c" translate="yes" xml:space="preserve">
          <source>CET Function: ret_type &lt;strong id=&quot;index-_005fget_005fssp&quot;&gt;_get_ssp&lt;/strong&gt; (void)</source>
          <target state="translated">CET功能：ret_type &lt;strong id=&quot;index-_005fget_005fssp&quot;&gt;_get_ssp&lt;/strong&gt;（无效）</target>
        </trans-unit>
        <trans-unit id="01ab10eefead0e21345d5d4e4f22d758ced4568b" translate="yes" xml:space="preserve">
          <source>CET Function: void &lt;strong id=&quot;index-_005finc_005fssp&quot;&gt;_inc_ssp&lt;/strong&gt; (unsigned int)</source>
          <target state="translated">CET函数：void &lt;strong id=&quot;index-_005finc_005fssp&quot;&gt;_inc_ssp&lt;/strong&gt;（无符号int）</target>
        </trans-unit>
        <trans-unit id="feca3790fce7c96d6df26540c7b4128215a81089" translate="yes" xml:space="preserve">
          <source>CMOV instruction.</source>
          <target state="translated">CMOV指令。</target>
        </trans-unit>
        <trans-unit id="c2711a4d5237b1b481ba6a122e49ae7f80826ead" translate="yes" xml:space="preserve">
          <source>CPU does not have a timebase (eg, 601 and 403gx).</source>
          <target state="translated">CPU没有时基(如601和403gx)。</target>
        </trans-unit>
        <trans-unit id="ca704ae8911deda5afe0231823961924eb739a85" translate="yes" xml:space="preserve">
          <source>CPU has a CELL broadband engine.</source>
          <target state="translated">CPU具有CELL宽带引擎。</target>
        </trans-unit>
        <trans-unit id="4f3f4709b09760afc34be4c56dc4c6225a92c342" translate="yes" xml:space="preserve">
          <source>CPU has a SIMD/Vector Unit.</source>
          <target state="translated">CPU有一个SIMD/Vector单元。</target>
        </trans-unit>
        <trans-unit id="7513f4d098c1065cad2f73416dc6c7b6d28bb7ca" translate="yes" xml:space="preserve">
          <source>CPU has a SPE double precision floating point unit.</source>
          <target state="translated">CPU具有SPE双精度浮点单元。</target>
        </trans-unit>
        <trans-unit id="249044ceb00915a3621d91cc9c9342822f5d3a2e" translate="yes" xml:space="preserve">
          <source>CPU has a SPE single precision floating point unit.</source>
          <target state="translated">CPU具有SPE单精度浮点单元。</target>
        </trans-unit>
        <trans-unit id="afc457a7d1f6c70e1a12a91ad1a70b454e13c88b" translate="yes" xml:space="preserve">
          <source>CPU has a decimal floating point unit.</source>
          <target state="translated">CPU有一个十进制浮点单位。</target>
        </trans-unit>
        <trans-unit id="daecf052e0ef6eddacd32a707988a46a48b10a26" translate="yes" xml:space="preserve">
          <source>CPU has a floating point unit.</source>
          <target state="translated">CPU有一个浮点单位。</target>
        </trans-unit>
        <trans-unit id="e350ba25d5b50e7eecaa8cd017e06461b70e0e96" translate="yes" xml:space="preserve">
          <source>CPU has a memory management unit.</source>
          <target state="translated">CPU有一个内存管理单元。</target>
        </trans-unit>
        <trans-unit id="d25b3ec38c741ef05546cfa00487c01e86a288da" translate="yes" xml:space="preserve">
          <source>CPU has a signal processing extension unit.</source>
          <target state="translated">CPU有一个信号处理扩展单元。</target>
        </trans-unit>
        <trans-unit id="a6cdbd18b45d3ceafe188679188c10b0e63fc06b" translate="yes" xml:space="preserve">
          <source>CPU has hardware transaction memory instructions.</source>
          <target state="translated">CPU有硬件事务存储器指令。</target>
        </trans-unit>
        <trans-unit id="817e69cd99aa2fae8e8cb1ea4ccb1e7cade39e36" translate="yes" xml:space="preserve">
          <source>CPU has unified I/D cache.</source>
          <target state="translated">CPU有统一的I/D缓存。</target>
        </trans-unit>
        <trans-unit id="a85030d258895560b198880492e35a8dc7104678" translate="yes" xml:space="preserve">
          <source>CPU support simultaneous multi-threading.</source>
          <target state="translated">CPU支持同时多线程。</target>
        </trans-unit>
        <trans-unit id="1fa8be29b90ade4bb4d6c9abca15ef4efb5cea12" translate="yes" xml:space="preserve">
          <source>CPU supports 128-bit IEEE binary floating point instructions.</source>
          <target state="translated">CPU支持128位IEEE二进制浮点指令。</target>
        </trans-unit>
        <trans-unit id="d0ec10bc634bb744e9ff5bc9b6ccebe2f8a4c1fd" translate="yes" xml:space="preserve">
          <source>CPU supports 32-bit mode execution.</source>
          <target state="translated">CPU支持32位模式执行。</target>
        </trans-unit>
        <trans-unit id="c550c34cceac587d8bfa3d110ce84630536005e1" translate="yes" xml:space="preserve">
          <source>CPU supports 64-bit mode execution.</source>
          <target state="translated">CPU支持64位模式执行。</target>
        </trans-unit>
        <trans-unit id="969f1a1bfc594794e1d088866f33884cafe4c0a3" translate="yes" xml:space="preserve">
          <source>CPU supports ISA 2.00 (eg, POWER4)</source>
          <target state="translated">CPU支持ISA 2.00(如POWER4)。</target>
        </trans-unit>
        <trans-unit id="f021a7b007d311f22fec3723c62516e8f3a0319b" translate="yes" xml:space="preserve">
          <source>CPU supports ISA 2.02 (eg, POWER5)</source>
          <target state="translated">CPU支持ISA 2.02(例如,POWER5)。</target>
        </trans-unit>
        <trans-unit id="ee64c969eb8481f0eae6c612175233cd07361227" translate="yes" xml:space="preserve">
          <source>CPU supports ISA 2.03 (eg, POWER5+)</source>
          <target state="translated">CPU支持ISA 2.03(例如,POWER5+)。</target>
        </trans-unit>
        <trans-unit id="13964fdc29b60cfc0a706e4cb0569a01c55f1208" translate="yes" xml:space="preserve">
          <source>CPU supports ISA 2.05 (eg, POWER6)</source>
          <target state="translated">CPU支持ISA 2.05(例如,POWER6)。</target>
        </trans-unit>
        <trans-unit id="4ba1460155478447375ae1fb486a30ad51582aec" translate="yes" xml:space="preserve">
          <source>CPU supports ISA 2.05 (eg, POWER6) extended opcodes mffgpr and mftgpr.</source>
          <target state="translated">CPU支持ISA 2.05(例如,POWER6)扩展操作码mffgpr和mftgpr。</target>
        </trans-unit>
        <trans-unit id="990b205fa1433a7d0dc63ad9070ee91af0800dd1" translate="yes" xml:space="preserve">
          <source>CPU supports ISA 2.06 (eg, POWER7)</source>
          <target state="translated">CPU支持ISA 2.06(例如,POWER7)。</target>
        </trans-unit>
        <trans-unit id="6a9081f5b37e7737655ad795c102d5fe7087b65d" translate="yes" xml:space="preserve">
          <source>CPU supports ISA 2.07 (eg, POWER8)</source>
          <target state="translated">CPU支持ISA 2.07(例如,POWER8)。</target>
        </trans-unit>
        <trans-unit id="dcf25ddc902c83eba265e85451df12c824bf2a7b" translate="yes" xml:space="preserve">
          <source>CPU supports ISA 3.0 (eg, POWER9)</source>
          <target state="translated">CPU支持ISA 3.0(例如,POWER9)。</target>
        </trans-unit>
        <trans-unit id="055a8304e60c6c298c280b0809896894a417c35e" translate="yes" xml:space="preserve">
          <source>CPU supports a little-endian mode that uses address swizzling.</source>
          <target state="translated">CPU支持使用地址旋转的小恩典模式。</target>
        </trans-unit>
        <trans-unit id="255ddfc220c178db8c2fdf2c3d887268be52afce" translate="yes" xml:space="preserve">
          <source>CPU supports event base branching.</source>
          <target state="translated">CPU支持事件基础分支。</target>
        </trans-unit>
        <trans-unit id="7a546c031cbdf8f942b2e95c5d11fb1b52e9cc57" translate="yes" xml:space="preserve">
          <source>CPU supports hardware transaction memory but does not support the &lt;code&gt;tsuspend.&lt;/code&gt; instruction.</source>
          <target state="translated">CPU支持硬件事务存储器，但不支持 &lt;code&gt;tsuspend.&lt;/code&gt; 指令。</target>
        </trans-unit>
        <trans-unit id="98cc31dee3a3972d6c8549b9b9d63935ff74bd07" translate="yes" xml:space="preserve">
          <source>CPU supports icache snooping capabilities.</source>
          <target state="translated">CPU支持icache snooping功能。</target>
        </trans-unit>
        <trans-unit id="86a7a3dc0108d58ef63d3f6ab2c6e0a72b7c8029" translate="yes" xml:space="preserve">
          <source>CPU supports the &lt;code&gt;darn&lt;/code&gt; (deliver a random number) instruction.</source>
          <target state="translated">CPU支持 &lt;code&gt;darn&lt;/code&gt; （传递随机数）指令。</target>
        </trans-unit>
        <trans-unit id="77d7a3e63ab0326c7992c2322e10e155757df7b2" translate="yes" xml:space="preserve">
          <source>CPU supports the Embedded ISA category.</source>
          <target state="translated">CPU支持嵌入式ISA类别。</target>
        </trans-unit>
        <trans-unit id="c159e0e90690ac6c2f371b7dff8ce2db12767971" translate="yes" xml:space="preserve">
          <source>CPU supports the PA Semi 6T CORE ISA.</source>
          <target state="translated">CPU支持PA Semi 6T CORE ISA。</target>
        </trans-unit>
        <trans-unit id="2267dd90003bf8b5f66bba6f8158082ed6e95240" translate="yes" xml:space="preserve">
          <source>CPU supports the data stream control register.</source>
          <target state="translated">CPU支持数据流控制寄存器。</target>
        </trans-unit>
        <trans-unit id="45a297e9cc9f2eb5df0912ac8e91302da6382422" translate="yes" xml:space="preserve">
          <source>CPU supports the integer select instruction.</source>
          <target state="translated">CPU支持整数选择指令。</target>
        </trans-unit>
        <trans-unit id="99a95efc8023d10b71a08bff59a8789aa22a0fb6" translate="yes" xml:space="preserve">
          <source>CPU supports the old POWER ISA (eg, 601)</source>
          <target state="translated">CPU支持旧的POWER ISA(如601)。</target>
        </trans-unit>
        <trans-unit id="309f8ee6774ef217dd65020d0047499e145915f8" translate="yes" xml:space="preserve">
          <source>CPU supports the set of compatible performance monitoring events.</source>
          <target state="translated">CPU支持一组兼容的性能监控事件。</target>
        </trans-unit>
        <trans-unit id="654d56ee4aa1191ad640c84c9cda741472551b11" translate="yes" xml:space="preserve">
          <source>CPU supports the target address register.</source>
          <target state="translated">CPU支持目标地址寄存器。</target>
        </trans-unit>
        <trans-unit id="2b74cd2604db8f416c0c904f549425dc7576345f" translate="yes" xml:space="preserve">
          <source>CPU supports the vector cryptography instructions.</source>
          <target state="translated">CPU支持向量加密指令。</target>
        </trans-unit>
        <trans-unit id="2910c789b3b4293207054dd9a2e43cc18d433b78" translate="yes" xml:space="preserve">
          <source>CPU supports the vector-scalar extension.</source>
          <target state="translated">CPU支持向量-标量扩展。</target>
        </trans-unit>
        <trans-unit id="41c99496e20c6a12697b36d694855c474afbe5bb" translate="yes" xml:space="preserve">
          <source>CPU supports true little-endian mode.</source>
          <target state="translated">CPU支持真正的小二进制模式。</target>
        </trans-unit>
        <trans-unit id="2ec7e4eb5fc127660ed425c7dcd89cd8eddc4bc5" translate="yes" xml:space="preserve">
          <source>CPUs based on AMD Family 10h cores with x86-64 instruction set support. (This supersets MMX, SSE, SSE2, SSE3, SSE4A, 3DNow!, enhanced 3DNow!, ABM and 64-bit instruction set extensions.)</source>
          <target state="translated">基于AMD家族10h核心的CPU,支持x86-64指令集。(这超越了MMX、SSE、SSE2、SSE3、SSE4A、3DNow!、增强型3DNow!、ABM和64位指令集扩展)。</target>
        </trans-unit>
        <trans-unit id="b84062366ba14fb3f3b6ff6b47d03c475a3828a9" translate="yes" xml:space="preserve">
          <source>CPUs based on AMD Family 14h cores with x86-64 instruction set support. (This supersets MMX, SSE, SSE2, SSE3, SSSE3, SSE4A, CX16, ABM and 64-bit instruction set extensions.)</source>
          <target state="translated">基于AMD家族14h核心的CPU,支持x86-64指令集。(这超越了MMX、SSE、SSE2、SSE3、SSE3、SSE4A、CX16、ABM和64位指令集扩展)。</target>
        </trans-unit>
        <trans-unit id="113524bb3893cb5857442da17502358001cf141b" translate="yes" xml:space="preserve">
          <source>CPUs based on AMD Family 15h cores with x86-64 instruction set support. (This supersets FMA4, AVX, XOP, LWP, AES, PCL_MUL, CX16, MMX, SSE, SSE2, SSE3, SSE4A, SSSE3, SSE4.1, SSE4.2, ABM and 64-bit instruction set extensions.)</source>
          <target state="translated">基于AMD家族15h核心的CPU,支持x86-64指令集。(这超越了FMA4、AVX、XOP、LWP、AES、PCL_MUL、CX16、MMX、SSE、SSE2、SSE3、SSE4A、SSSE3、SSE4.1、SSE4.2、ABM和64位指令集扩展。)</target>
        </trans-unit>
        <trans-unit id="47a0219528807f6268d19e1c7ca96f3e9c601c1e" translate="yes" xml:space="preserve">
          <source>CPUs based on AMD Family 16h cores with x86-64 instruction set support. This includes MOVBE, F16C, BMI, AVX, PCL_MUL, AES, SSE4.2, SSE4.1, CX16, ABM, SSE4A, SSSE3, SSE3, SSE2, SSE, MMX and 64-bit instruction set extensions.</source>
          <target state="translated">基于AMD家族16h内核的CPU,支持x86-64指令集。包括MOVBE、F16C、BMI、AVX、PCL_MUL、AES、SSE4.2、SSE4.1、CX16、ABM、SSE4A、SSE3、SSE3、SSE2、SSE、MMX和64位指令集扩展。</target>
        </trans-unit>
        <trans-unit id="762cf7076b068d306d32ea79b0d0e2277121f2b5" translate="yes" xml:space="preserve">
          <source>CR</source>
          <target state="translated">CR</target>
        </trans-unit>
        <trans-unit id="5e1fb0077df92097ce069aa21ed47aa03c3d5c5d" translate="yes" xml:space="preserve">
          <source>CR16 Architecture&amp;mdash;</source>
          <target state="translated">CR16体系结构&amp;mdash;</target>
        </trans-unit>
        <trans-unit id="f9c744e8c0ecb712753e6342db41d199b59d9bf6" translate="yes" xml:space="preserve">
          <source>CTR</source>
          <target state="translated">CTR</target>
        </trans-unit>
        <trans-unit id="58ad68590efc1385d2b4fd64a16b4b9f8cfaaa44" translate="yes" xml:space="preserve">
          <source>Call operand, const_int, for absolute calls.</source>
          <target state="translated">调用操作数,const_int,用于绝对调用。</target>
        </trans-unit>
        <trans-unit id="3373e7e79f4085d8f7291896ef1d3760c15083be" translate="yes" xml:space="preserve">
          <source>Call operand, reg, for indirect calls</source>
          <target state="translated">调用操作数,reg,用于间接调用</target>
        </trans-unit>
        <trans-unit id="3c51d11770c5ea3546c0d152d73faf160c859f37" translate="yes" xml:space="preserve">
          <source>Call operand, symbol, for relative calls.</source>
          <target state="translated">调用操作数,符号,用于相对调用。</target>
        </trans-unit>
        <trans-unit id="f0c515fe9bf062328bec62182c3bb93d352208ec" translate="yes" xml:space="preserve">
          <source>Call the named function &lt;var&gt;function&lt;/var&gt;, passing it &lt;var&gt;args&lt;/var&gt;. &lt;var&gt;args&lt;/var&gt; is first processed as a nested spec string, then split into an argument vector in the usual fashion. The function returns a string which is processed as if it had appeared literally as part of the current spec.</source>
          <target state="translated">调用命名函数 &lt;var&gt;function&lt;/var&gt; ，将其传递给 &lt;var&gt;args&lt;/var&gt; 。 &lt;var&gt;args&lt;/var&gt; 首先作为嵌套的规范字符串处理，然后以通常的方式拆分为参数向量。该函数返回一个字符串，该字符串的处理方式就好像它确实是当前规范的一部分。</target>
        </trans-unit>
        <trans-unit id="4b1ccc6ccff0a4b4d69b01f9c83e0859c8e4f058" translate="yes" xml:space="preserve">
          <source>Calling conventions are a subset of an ABI that specify of how arguments are passed and function results are returned.</source>
          <target state="translated">调用约定是ABI的一个子集,它指定了如何传递参数和返回函数结果。</target>
        </trans-unit>
        <trans-unit id="8e13d2ff4cf44ed7d75b8cee9472ba906dfafd20" translate="yes" xml:space="preserve">
          <source>Calling this function with a nonzero argument can have unpredictable effects, including crashing the calling program. As a result, calls that are considered unsafe are diagnosed when the</source>
          <target state="translated">用一个非零参数调用这个函数可能会产生不可预知的影响,包括使调用程序崩溃。因此,被认为是不安全的调用会在当</target>
        </trans-unit>
        <trans-unit id="fc12921ff6d4899e4dc68b34cc1cd37e3157e57e" translate="yes" xml:space="preserve">
          <source>Calls a library function that performs the operation in double precision floating point. Division by zero causes a floating-point exception. This is the default for SHcompact with FPU. Specifying this for targets that do not have a double precision FPU defaults to &lt;code&gt;call-div1&lt;/code&gt;.</source>
          <target state="translated">调用以双精度浮点数执行操作的库函数。被零除会导致浮点异常。这是SHcompact与FPU的默认设置。为没有双精度FPU的目标指定此选项的默认值是 &lt;code&gt;call-div1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="29e8cd2fa85f5515142e26b60a518bb56cd4bcb6" translate="yes" xml:space="preserve">
          <source>Calls a library function that uses a lookup table for small divisors and the &lt;code&gt;div1&lt;/code&gt; instruction with case distinction for larger divisors. Division by zero calculates an unspecified result and does not trap. This is the default for SH4. Specifying this for targets that do not have dynamic shift instructions defaults to &lt;code&gt;call-div1&lt;/code&gt;.</source>
          <target state="translated">调用一个库函数，该函数对小除数使用查找表，对大除数使用区分大小写的 &lt;code&gt;div1&lt;/code&gt; 指令。除以零会计算不确定的结果，并且不会捕获。这是SH4的默认设置。为没有动态移位指令的目标指定此选项默认为 &lt;code&gt;call-div1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b66ee13b0a48eb1333567adb5302965969bbf50a" translate="yes" xml:space="preserve">
          <source>Calls a library function that uses the single-step division instruction &lt;code&gt;div1&lt;/code&gt; to perform the operation. Division by zero calculates an unspecified result and does not trap. This is the default except for SH4, SH2A and SHcompact.</source>
          <target state="translated">调用使用单步除法指令 &lt;code&gt;div1&lt;/code&gt; 的库函数来执行该操作。除以零会计算不确定的结果，并且不会捕获。除SH4，SH2A和SHcompact外，这是默认设置。</target>
        </trans-unit>
        <trans-unit id="b45cc51de5de6fd998285ffd2412d7b2646d5ad0" translate="yes" xml:space="preserve">
          <source>Calls to &lt;code&gt;foo&lt;/code&gt; are mapped to calls to &lt;code&gt;foo{20040821}&lt;/code&gt;.</source>
          <target state="translated">对 &lt;code&gt;foo&lt;/code&gt; 的调用将映射到对 &lt;code&gt;foo{20040821}&lt;/code&gt; 调用。</target>
        </trans-unit>
        <trans-unit id="293878ce1781e2ea1bacb79578feb3fbe4be3315" translate="yes" xml:space="preserve">
          <source>Calls to external functions with this attribute must return to the current compilation unit only by return or by exception handling. In particular, a leaf function is not allowed to invoke callback functions passed to it from the current compilation unit, directly call functions exported by the unit, or &lt;code&gt;longjmp&lt;/code&gt; into the unit. Leaf functions might still call functions from other compilation units and thus they are not necessarily leaf in the sense that they contain no function calls at all.</source>
          <target state="translated">使用此属性对外部函数的调用必须仅通过return或通过异常处理才能返回到当前的编译单元。特别是，不允许叶子函数调用从当前编译单元传递给它的回调函数，直接调用由该单元导出的函数或将 &lt;code&gt;longjmp&lt;/code&gt; 放入该单元中。叶子函数可能仍会从其他编译单元调用函数，因此从它们根本不包含任何函数调用的意义上来说，它们不一定是叶子。</target>
        </trans-unit>
        <trans-unit id="4271715ba8546178ce2b0fafe7396f6340205ed7" translate="yes" xml:space="preserve">
          <source>Calls to functions that have no observable effects on the state of the program other than to return a value may lend themselves to optimizations such as common subexpression elimination. Declaring such functions with the &lt;code&gt;pure&lt;/code&gt; attribute allows GCC to avoid emitting some calls in repeated invocations of the function with the same argument values.</source>
          <target state="translated">调用除返回值外对程序状态没有可观察的影响的函数可能有助于进行优化，例如消除公共子表达式。使用 &lt;code&gt;pure&lt;/code&gt; 属性声明此类函数可以使GCC避免在重复调用具有相同参数值的函数时发出某些调用。</target>
        </trans-unit>
        <trans-unit id="3b52d0ab938b444cac1b9e9d1c160806cd6da345" translate="yes" xml:space="preserve">
          <source>Calls to functions whose return value is not affected by changes to the observable state of the program and that have no observable effects on such state other than to return a value may lend themselves to optimizations such as common subexpression elimination. Declaring such functions with the &lt;code&gt;const&lt;/code&gt; attribute allows GCC to avoid emitting some calls in repeated invocations of the function with the same argument values.</source>
          <target state="translated">调用其返回值不受程序可观察状态的更改影响并且对这种状态没有可观察的影响（而不返回值）的函数的调用可以使自己进行优化，例如消除公共子表达式。使用 &lt;code&gt;const&lt;/code&gt; 属性声明此类函数可以使GCC避免在重复调用具有相同参数值的函数时发出某些调用。</target>
        </trans-unit>
        <trans-unit id="f8eba46ecad008a4e218a210a71672db04d7e157" translate="yes" xml:space="preserve">
          <source>Cancel an assertion with the predicate &lt;var&gt;predicate&lt;/var&gt; and answer &lt;var&gt;answer&lt;/var&gt;.</source>
          <target state="translated">取消与谓词断言 &lt;var&gt;predicate&lt;/var&gt; 和答案 &lt;var&gt;answer&lt;/var&gt; 。</target>
        </trans-unit>
        <trans-unit id="59d15eea66865b0282cb17c0e3120ed653071f95" translate="yes" xml:space="preserve">
          <source>Cancel any previous definition of &lt;var&gt;name&lt;/var&gt;, either built in or provided with a</source>
          <target state="translated">取消 &lt;var&gt;name&lt;/var&gt; 的任何以前的定义，该定义是内置的或随附的</target>
        </trans-unit>
        <trans-unit id="192387cfc73b539ff900c725ddee4d021db73db5" translate="yes" xml:space="preserve">
          <source>Casting to union type from any member of the union.</source>
          <target state="translated">从该联盟的任何成员投向联盟类型。</target>
        </trans-unit>
        <trans-unit id="b08eca4544a17d0207cde77668a933d9951e246a" translate="yes" xml:space="preserve">
          <source>Cause gas to print out tomcat statistics.</source>
          <target state="translated">导致气体打印出tomcat统计数据。</target>
        </trans-unit>
        <trans-unit id="5a1bd09378f19d49cb410444dadaeb9f88738a8a" translate="yes" xml:space="preserve">
          <source>Cause the errors having to do with files that have the wrong architecture to be fatal.</source>
          <target state="translated">导致与架构错误的文件有关的错误是致命的。</target>
        </trans-unit>
        <trans-unit id="5019333f8c270c0e57b171951e0397047e39d35e" translate="yes" xml:space="preserve">
          <source>Causes GCC to remember the state of the diagnostics as of each &lt;code&gt;push&lt;/code&gt;, and restore to that point at each &lt;code&gt;pop&lt;/code&gt;. If a &lt;code&gt;pop&lt;/code&gt; has no matching &lt;code&gt;push&lt;/code&gt;, the command-line options are restored.</source>
          <target state="translated">使GCC在每次 &lt;code&gt;push&lt;/code&gt; 记住诊断的状态，并在每次 &lt;code&gt;pop&lt;/code&gt; 恢复到该点。如果某个 &lt;code&gt;pop&lt;/code&gt; 没有匹配的 &lt;code&gt;push&lt;/code&gt; ，则将还原命令行选项。</target>
        </trans-unit>
        <trans-unit id="667cccec716e1283ccef9e29985511e0bdf9e0a0" translate="yes" xml:space="preserve">
          <source>Causes all functions to default to the &lt;code&gt;.far&lt;/code&gt; section. Without this option, functions default to the &lt;code&gt;.near&lt;/code&gt; section.</source>
          <target state="translated">使所有函数默认为 &lt;code&gt;.far&lt;/code&gt; 节。没有此选项，函数默认为 &lt;code&gt;.near&lt;/code&gt; 部分。</target>
        </trans-unit>
        <trans-unit id="e30905206e2b1ac1064f6ac3bbe5bd6c803a6b79" translate="yes" xml:space="preserve">
          <source>Causes all variables to default to the &lt;code&gt;.tiny&lt;/code&gt; section. Note that there is a 65536-byte limit to this section. Accesses to these variables use the &lt;code&gt;%gp&lt;/code&gt; base register.</source>
          <target state="translated">使所有变量默认为 &lt;code&gt;.tiny&lt;/code&gt; 部分。请注意，此部分限制为65536字节。对这些变量的访问使用 &lt;code&gt;%gp&lt;/code&gt; 基址寄存器。</target>
        </trans-unit>
        <trans-unit id="98be0c7de301463de1c80070885a43330018a0b2" translate="yes" xml:space="preserve">
          <source>Causes constant variables to be placed in the &lt;code&gt;.near&lt;/code&gt; section.</source>
          <target state="translated">使常量变量放置在 &lt;code&gt;.near&lt;/code&gt; 节中。</target>
        </trans-unit>
        <trans-unit id="655599ac8eaa0291e221b62364ffdf96a51309de" translate="yes" xml:space="preserve">
          <source>Causes the output file to be marked such that the dynamic linker will bind all undefined references when the file is loaded or launched.</source>
          <target state="translated">导致输出文件被标记为当文件被加载或启动时,动态链接器将绑定所有未定义的引用。</target>
        </trans-unit>
        <trans-unit id="c48452dfc4582d4eee857576d8fb13bb7694884b" translate="yes" xml:space="preserve">
          <source>Causes variables to be assigned to the &lt;code&gt;.far&lt;/code&gt; section by default.</source>
          <target state="translated">导致默认情况下将变量分配给 &lt;code&gt;.far&lt;/code&gt; 部分。</target>
        </trans-unit>
        <trans-unit id="13cb136a09a7c1b01f2dc417dcf7c22b8038c03d" translate="yes" xml:space="preserve">
          <source>Causes variables to be assigned to the &lt;code&gt;.near&lt;/code&gt; section by default.</source>
          <target state="translated">导致默认情况下将变量分配给 &lt;code&gt;.near&lt;/code&gt; 节。</target>
        </trans-unit>
        <trans-unit id="efdb8f56a4df91a529ce6b66e59857019a48ac1f" translate="yes" xml:space="preserve">
          <source>Certain ABI-changing flags are required to match in all compilation units, and trying to override this at link time with a conflicting value is ignored. This includes options such as</source>
          <target state="translated">某些ABI变化的标志在所有编译单元中都需要匹配,在链接时试图用一个冲突的值来覆盖这个标志会被忽略。这包括一些选项,如</target>
        </trans-unit>
        <trans-unit id="a8db3b10d95cbc07c88dbe64efa680baa0d22c3b" translate="yes" xml:space="preserve">
          <source>Certain local variables aren&amp;rsquo;t recognized by debuggers when you compile with optimization.</source>
          <target state="translated">在进行优化编译时，调试器无法识别某些局部变量。</target>
        </trans-unit>
        <trans-unit id="be7c527dd55f67d739c97b4f416bd42f396b0844" translate="yes" xml:space="preserve">
          <source>Cfront model</source>
          <target state="translated">Cfront模型</target>
        </trans-unit>
        <trans-unit id="1aba59b0fc2fb3ed3ce5d3423cf83addc1f152f7" translate="yes" xml:space="preserve">
          <source>Change ABI to use double word insns.</source>
          <target state="translated">将ABI改为使用双字insns。</target>
        </trans-unit>
        <trans-unit id="9f8ed70cb1d356e0b695cceb7ab02d866b216534" translate="yes" xml:space="preserve">
          <source>Change paragraph 1</source>
          <target state="translated">修改第1款</target>
        </trans-unit>
        <trans-unit id="3cb692fbb429d564d86c14c1772ab21a4cec5d73" translate="yes" xml:space="preserve">
          <source>Change paragraph 2</source>
          <target state="translated">修改第2款</target>
        </trans-unit>
        <trans-unit id="9b9fbfc9cacb726e629a9636bbe98d28a8d83b9b" translate="yes" xml:space="preserve">
          <source>Change paragraph 2 to</source>
          <target state="translated">将第2款改为:</target>
        </trans-unit>
        <trans-unit id="cb241f39f5fa8625fba68e7d9da30611af7534b7" translate="yes" xml:space="preserve">
          <source>Change the current ABI to use IBM extended-precision long double. This is not likely to work if your system defaults to using IEEE extended-precision long double. If you change the long double type from IEEE extended-precision, the compiler will issue a warning unless you use the</source>
          <target state="translated">将当前 ABI 更改为使用 IBM 扩展精度长双数。如果您的系统默认使用 IEEE 扩展精度长双数,这不太可能奏效。如果您将长双数类型从 IEEE 扩展精度改为长双数,编译器将发出警告,除非您使用</target>
        </trans-unit>
        <trans-unit id="8b05bb4515e125b765f13f146e5cba54744fff37" translate="yes" xml:space="preserve">
          <source>Change the current ABI to use IEEE extended-precision long double. This is not likely to work if your system defaults to using IBM extended-precision long double. If you change the long double type from IBM extended-precision, the compiler will issue a warning unless you use the</source>
          <target state="translated">将当前 ABI 更改为使用 IEEE 扩展精度长双数。如果您的系统默认使用IBM扩展精度长双数,这不太可能奏效。如果您将长双数类型从 IBM 扩展精度改为长双数,编译器将发出警告,除非您使用了</target>
        </trans-unit>
        <trans-unit id="24cf332293e237ad325e62a5ee2905fadea5402b" translate="yes" xml:space="preserve">
          <source>Change the current ABI to use the ELFv1 ABI. This is the default ABI for big-endian PowerPC 64-bit Linux. Overriding the default ABI requires special system support and is likely to fail in spectacular ways.</source>
          <target state="translated">将当前 ABI 更改为使用 ELFv1 ABI。这是 big-endian PowerPC 64-bit Linux 的默认 ABI。覆盖默认的 ABI 需要特殊的系统支持,并且很可能以惊人的方式失败。</target>
        </trans-unit>
        <trans-unit id="8ed54cd4038a43f7d20137c040c4f60546641dbf" translate="yes" xml:space="preserve">
          <source>Change the current ABI to use the ELFv2 ABI. This is the default ABI for little-endian PowerPC 64-bit Linux. Overriding the default ABI requires special system support and is likely to fail in spectacular ways.</source>
          <target state="translated">将当前 ABI 更改为使用 ELFv2 ABI。这是小字段 PowerPC 64 位 Linux 的默认 ABI。覆盖默认的 ABI 需要特殊的系统支持,并且很可能以惊人的方式失败。</target>
        </trans-unit>
        <trans-unit id="85a1bd4814c92b33b933c24808e3438fdd28e471" translate="yes" xml:space="preserve">
          <source>Change the preferred SIMD mode to SImode. The default is</source>
          <target state="translated">将首选的SIMD模式改为SImode。默认为</target>
        </trans-unit>
        <trans-unit id="1693787c0c1da76f7df927835bc9d253ab1baa96" translate="yes" xml:space="preserve">
          <source>Change the target of the rule emitted by dependency generation. By default CPP takes the name of the main input file, deletes any directory components and any file suffix such as &amp;lsquo;</source>
          <target state="translated">更改依赖项生成所发出的规则的目标。默认情况下，CPP使用主输入文件的名称，删除所有目录组件和任何文件后缀，例如&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="aca39a5b032e87a9c462bafacf2e62ade09bc55e" translate="yes" xml:space="preserve">
          <source>Check calls to &lt;code&gt;printf&lt;/code&gt; and &lt;code&gt;scanf&lt;/code&gt;, etc., to make sure that the arguments supplied have types appropriate to the format string specified, and that the conversions specified in the format string make sense. This includes standard functions, and others specified by format attributes (see &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;Function Attributes&lt;/a&gt;), in the &lt;code&gt;printf&lt;/code&gt;, &lt;code&gt;scanf&lt;/code&gt;, &lt;code&gt;strftime&lt;/code&gt; and &lt;code&gt;strfmon&lt;/code&gt; (an X/Open extension, not in the C standard) families (or other target-specific families). Which functions are checked without format attributes having been specified depends on the standard version selected, and such checks of functions without the attribute specified are disabled by</source>
          <target state="translated">检查对 &lt;code&gt;printf&lt;/code&gt; 和 &lt;code&gt;scanf&lt;/code&gt; 等的调用，以确保提供的参数具有与指定的格式字符串相对应的类型，并且确保在格式字符串中指定的转换有意义。这包括标准函数以及在 &lt;code&gt;printf&lt;/code&gt; ， &lt;code&gt;scanf&lt;/code&gt; ， &lt;code&gt;strftime&lt;/code&gt; 和 &lt;code&gt;strfmon&lt;/code&gt; （X / Open扩展，不是C标准），系列（或其他特定于目标的系列）中由格式属性指定的其他&lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;功能&lt;/a&gt;（请参见功能属性）。在未指定格式属性的情况下检查哪些功能取决于所选的标准版本，而未在未指定属性的情况下进行的功能检查将被禁用</target>
        </trans-unit>
        <trans-unit id="c6a3f453fdd63ac92077276df83570873739aa07" translate="yes" xml:space="preserve">
          <source>Check for 64 bits wide constants for add/sub instructions</source>
          <target state="translated">检查64位宽的加/减指令的常量。</target>
        </trans-unit>
        <trans-unit id="fac4c7c683a989d8b06bb9ece7f678cee49ed294" translate="yes" xml:space="preserve">
          <source>Check that the pointer returned by &lt;code&gt;operator new&lt;/code&gt; is non-null before attempting to modify the storage allocated. This check is normally unnecessary because the C++ standard specifies that &lt;code&gt;operator new&lt;/code&gt; only returns &lt;code&gt;0&lt;/code&gt; if it is declared &lt;code&gt;throw()&lt;/code&gt;, in which case the compiler always checks the return value even without this option. In all other cases, when &lt;code&gt;operator new&lt;/code&gt; has a non-empty exception specification, memory exhaustion is signalled by throwing &lt;code&gt;std::bad_alloc&lt;/code&gt;. See also &amp;lsquo;</source>
          <target state="translated">在尝试修改分配的存储之前，请检查 &lt;code&gt;operator new&lt;/code&gt; 返回的指针是否为非空。通常，此检查是不必要的，因为C ++标准指定 &lt;code&gt;operator new&lt;/code&gt; 如果声明为 &lt;code&gt;throw()&lt;/code&gt; ，则仅返回 &lt;code&gt;0&lt;/code&gt; ，在这种情况下，即使没有此选项，编译器也会始终检查返回值。在所有其他情况下，当 &lt;code&gt;operator new&lt;/code&gt; 具有非空异常规范时，将通过抛出 &lt;code&gt;std::bad_alloc&lt;/code&gt; 来指示内存耗尽。也可以看看 '</target>
        </trans-unit>
        <trans-unit id="81e890de105f29124c3560894740b09b086a655a" translate="yes" xml:space="preserve">
          <source>Check the code for syntax errors, but don&amp;rsquo;t do anything beyond that.</source>
          <target state="translated">检查代码中是否存在语法错误，但不要做其他任何事情。</target>
        </trans-unit>
        <trans-unit id="5b609f7a36a96f87c3d3229801dbbe278531362e" translate="yes" xml:space="preserve">
          <source>Checking the number and type of arguments to a function which has an old-fashioned definition and no prototype.</source>
          <target state="translated">检查一个有老式定义而没有原型的函数的参数数量和类型。</target>
        </trans-unit>
        <trans-unit id="fd9acb009d6a873fdb579dcb1f012d6d507dcf76" translate="yes" xml:space="preserve">
          <source>Choose a data model. The choices for &lt;var&gt;model&lt;/var&gt; are &amp;lsquo;</source>
          <target state="translated">选择一个数据模型。 &lt;var&gt;model&lt;/var&gt; 的选择是</target>
        </trans-unit>
        <trans-unit id="8d3369d8e5fea9b901b46c632d20401df2fdb02c" translate="yes" xml:space="preserve">
          <source>Choose between the two available implementations of</source>
          <target state="translated">在两个可用的</target>
        </trans-unit>
        <trans-unit id="41e3a1c87aff0500a839e105b5b619da6d89b8a6" translate="yes" xml:space="preserve">
          <source>Choose integer type as 32-bit wide.</source>
          <target state="translated">选择整数类型为32位宽。</target>
        </trans-unit>
        <trans-unit id="fd477ac5e4063d79ef6de9d30fdf3c13757351dd" translate="yes" xml:space="preserve">
          <source>Choose startup files and linker script suitable for the simulator.</source>
          <target state="translated">选择适合模拟器的启动文件和链接器脚本。</target>
        </trans-unit>
        <trans-unit id="a7c124dc3d6f2fff1283f2960f19679f618eb758" translate="yes" xml:space="preserve">
          <source>Chopped rounding mode. Floating-point numbers are rounded towards zero.</source>
          <target state="translated">斩波进位模式。浮点数字四舍五入为零。</target>
        </trans-unit>
        <trans-unit id="baeeaf6c90ab7667596e853c19ec9377ba1a6bed" translate="yes" xml:space="preserve">
          <source>Chunk size of omp schedule for loops parallelized by parloops.</source>
          <target state="translated">通过parloops并行化的循环的OMP计划的Chunk大小。</target>
        </trans-unit>
        <trans-unit id="39f6c5316b94c42ede9e8f3c0902f04af5a47ac9" translate="yes" xml:space="preserve">
          <source>Clobber descriptions may not in any way overlap with an input or output operand. For example, you may not have an operand describing a register class with one member when listing that register in the clobber list. Variables declared to live in specific registers (see &lt;a href=&quot;explicit-register-variables#Explicit-Register-Variables&quot;&gt;Explicit Register Variables&lt;/a&gt;) and used as &lt;code&gt;asm&lt;/code&gt; input or output operands must have no part mentioned in the clobber description. In particular, there is no way to specify that input operands get modified without also specifying them as output operands.</source>
          <target state="translated">垃圾描述可能不会与输入或输出操作数重叠。例如，当您将一个寄存器描述在寄存器列表中时，可能没有操作数描述一个成员的寄存器类。声明要存在于特定寄存器中的&lt;a href=&quot;explicit-register-variables#Explicit-Register-Variables&quot;&gt;变量&lt;/a&gt;（请参阅显式寄存器变量），并且用作 &lt;code&gt;asm&lt;/code&gt; 输入或输出操作数的变量，在Clobber描述中必须没有提及。特别是，如果没有将输入操作数也指定为输出操作数，就无法指定对其进行修改。</target>
        </trans-unit>
        <trans-unit id="e7d5e82c3d8cf6aecb50f1c3dec1dfd81862c300" translate="yes" xml:space="preserve">
          <source>Code Generation Options</source>
          <target state="translated">代码生成选项</target>
        </trans-unit>
        <trans-unit id="de73aa04e00c631b2bba60472a9b4cb42f90647b" translate="yes" xml:space="preserve">
          <source>Code generation tweaks that disable, respectively, splitting of 32-bit loads, generation of post-increment addresses, and generation of post-modify addresses. The defaults are</source>
          <target state="translated">代码生成调整,分别禁用32位负载的分割、生成增量后地址和生成修改后地址。默认值是</target>
        </trans-unit>
        <trans-unit id="0acb8ba8662201458fc8762cdc2bfb973da3d9b7" translate="yes" xml:space="preserve">
          <source>Code like this may run successfully under some other compilers, particularly obsolete cfront-based compilers that delete temporaries along with normal local variables. However, the GNU C++ behavior is standard-conforming, so if your program depends on late destruction of temporaries it is not portable.</source>
          <target state="translated">像这样的代码可能会在一些其他编译器下成功运行,特别是那些基于cfront的过时编译器,它们会将临时变量和普通的局部变量一起删除。然而,GNU C++的行为是符合标准的,所以如果你的程序依赖于临时变量的后期销毁,那么它是不可移植的。</target>
        </trans-unit>
        <trans-unit id="d477ef0f890f99da791a35a9c4922d4a6b4caa9b" translate="yes" xml:space="preserve">
          <source>Code that (effectively) clobbers bits of &lt;code&gt;SREG&lt;/code&gt; other than the &lt;code&gt;I&lt;/code&gt;-flag by writing to the memory location of &lt;code&gt;SREG&lt;/code&gt;.</source>
          <target state="translated">通过写入 &lt;code&gt;SREG&lt;/code&gt; 的存储位置（有效地）清除 &lt;code&gt;SREG&lt;/code&gt; 的 &lt;code&gt;I&lt;/code&gt; 标志以外的位的代码。</target>
        </trans-unit>
        <trans-unit id="22aee03764143c3347036737d5c49aa3c48b93fe" translate="yes" xml:space="preserve">
          <source>Code that uses inline assembler to jump to a different function which expects (parts of) the prologue code as outlined above to be present.</source>
          <target state="translated">使用内联汇编器跳转到不同函数的代码,该函数期望(部分)如上所述的序幕代码存在。</target>
        </trans-unit>
        <trans-unit id="a04d4be0af028c55d37a5eda8e2e9e52e00d9883" translate="yes" xml:space="preserve">
          <source>Collect and dump debug information into a temporary file if an internal compiler error (ICE) occurs.</source>
          <target state="translated">如果发生内部编译器错误(ICE),收集并将调试信息转储到一个临时文件中。</target>
        </trans-unit>
        <trans-unit id="3de9bf73c20469d02f33a82c6c1b964c35ca72c5" translate="yes" xml:space="preserve">
          <source>Collect the profiles for different set of inputs, and use this tool to merge them. One can specify the weight to factor in the relative importance of each input.</source>
          <target state="translated">收集不同输入集的剖面图,并使用此工具将其合并。可以指定权重,以考虑每个输入的相对重要性。</target>
        </trans-unit>
        <trans-unit id="674fdd25c0f94978ce5404bf7783af22ebecb1fb" translate="yes" xml:space="preserve">
          <source>Combine increments or decrements of addresses with memory accesses. This pass is always skipped on architectures that do not have instructions to support this. Enabled by default at</source>
          <target state="translated">将地址的增量或减量与内存访问相结合。在没有指令支持这个功能的架构上,这个通道总是被跳过。默认情况下,在</target>
        </trans-unit>
        <trans-unit id="5c675961000becf8ff6422c0eeb1b9242b5fdf0f" translate="yes" xml:space="preserve">
          <source>Combines the effects of both &lt;code&gt;__ATOMIC_ACQUIRE&lt;/code&gt; and &lt;code&gt;__ATOMIC_RELEASE&lt;/code&gt;.</source>
          <target state="translated">结合 &lt;code&gt;__ATOMIC_ACQUIRE&lt;/code&gt; 和 &lt;code&gt;__ATOMIC_RELEASE&lt;/code&gt; 的效果。</target>
        </trans-unit>
        <trans-unit id="4393d8b520a9b50ddef09d9f77984a620fcf38de" translate="yes" xml:space="preserve">
          <source>Combining several classes is possible, although this usually restricts the output so much that there is nothing to display. One case where it does work, however, is when one of the classes is &lt;var&gt;target&lt;/var&gt;. For example, to display all the target-specific optimization options, use:</source>
          <target state="translated">可以组合多个类，尽管这通常会限制输出，以至于无任何显示。但是，它确实起作用的一种情况是当其中一个类是 &lt;var&gt;target&lt;/var&gt; 时。例如，要显示所有特定于目标的优化选项，请使用：</target>
        </trans-unit>
        <trans-unit id="72a257637f31b3509bd8ac95d015b26d1c5d9ce9" translate="yes" xml:space="preserve">
          <source>Command options supported by &amp;lsquo;</source>
          <target state="translated">'支持的命令选项</target>
        </trans-unit>
        <trans-unit id="8e5bbd00924927db3116b7ce896a99d0d6c09a71" translate="yes" xml:space="preserve">
          <source>Commit the current transaction. When no transaction is active this faults. All memory side effects of the transaction become visible to other threads in an atomic manner.</source>
          <target state="translated">提交当前事务。当没有事务活动时,这个故障。事务的所有内存副作用都会以原子方式对其他线程可见。</target>
        </trans-unit>
        <trans-unit id="953dbfff4f1c2d7c9623cfa81345a412c8c95e6f" translate="yes" xml:space="preserve">
          <source>Common misunderstandings with GNU C++.</source>
          <target state="translated">GNU C++的常见误区。</target>
        </trans-unit>
        <trans-unit id="99484341af697bedb30f82944a2b8048a7bd9d3b" translate="yes" xml:space="preserve">
          <source>Compare at most &lt;var&gt;num&lt;/var&gt; string bytes with inline code. If the difference or end of string is not found at the end of the inline compare a call to &lt;code&gt;strcmp&lt;/code&gt; or &lt;code&gt;strncmp&lt;/code&gt; will take care of the rest of the comparison. The default is 64 bytes.</source>
          <target state="translated">将最多 &lt;var&gt;num&lt;/var&gt; 个字符串字节与内联代码进行比较。如果 &lt;code&gt;strncmp&lt;/code&gt; 联比较的末尾未找到字符串的差或结尾，则对 &lt;code&gt;strcmp&lt;/code&gt; 或strncmp的调用将完成其余的比较。默认值为64字节。</target>
        </trans-unit>
        <trans-unit id="7e11797436f7910f8bb83ca2860c72513034685a" translate="yes" xml:space="preserve">
          <source>Comparison of four paired-single values (&lt;code&gt;c.&lt;var&gt;cond&lt;/var&gt;.ps&lt;/code&gt;/&lt;code&gt;cabs.&lt;var&gt;cond&lt;/var&gt;.ps&lt;/code&gt;, &lt;code&gt;bc1any4t&lt;/code&gt;/&lt;code&gt;bc1any4f&lt;/code&gt;).</source>
          <target state="translated">4配对单值的比较（ &lt;code&gt;c.&lt;var&gt;cond&lt;/var&gt;.ps&lt;/code&gt; / &lt;code&gt;cabs.&lt;var&gt;cond&lt;/var&gt;.ps&lt;/code&gt; ， &lt;code&gt;bc1any4t&lt;/code&gt; / &lt;code&gt;bc1any4f&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="c8cb7f422f46057d6869362d0511c9090d3a1fd7" translate="yes" xml:space="preserve">
          <source>Comparison of two paired-single values (&lt;code&gt;c.&lt;var&gt;cond&lt;/var&gt;.ps&lt;/code&gt;, &lt;code&gt;bc1t&lt;/code&gt;/&lt;code&gt;bc1f&lt;/code&gt;).</source>
          <target state="translated">两个成对的单值（比较 &lt;code&gt;c.&lt;var&gt;cond&lt;/var&gt;.ps&lt;/code&gt; ， &lt;code&gt;bc1t&lt;/code&gt; / &lt;code&gt;bc1f&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="11a9160f31b23e32c54ba7fe5458de10730189d9" translate="yes" xml:space="preserve">
          <source>Comparison of two paired-single values (&lt;code&gt;c.&lt;var&gt;cond&lt;/var&gt;.ps&lt;/code&gt;/&lt;code&gt;cabs.&lt;var&gt;cond&lt;/var&gt;.ps&lt;/code&gt;, &lt;code&gt;bc1any2t&lt;/code&gt;/&lt;code&gt;bc1any2f&lt;/code&gt;).</source>
          <target state="translated">两个成对的单值的比较（ &lt;code&gt;c.&lt;var&gt;cond&lt;/var&gt;.ps&lt;/code&gt; / &lt;code&gt;cabs.&lt;var&gt;cond&lt;/var&gt;.ps&lt;/code&gt; ， &lt;code&gt;bc1any2t&lt;/code&gt; / &lt;code&gt;bc1any2f&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="651d13a7683a8781ee0feea932b0d34d198ddce8" translate="yes" xml:space="preserve">
          <source>Comparison operations.</source>
          <target state="translated">比较操作。</target>
        </trans-unit>
        <trans-unit id="1adbeb956bb205e79fa3fa9ca1c2daca593fb1fa" translate="yes" xml:space="preserve">
          <source>Compatibilities with earlier definitions of C++.</source>
          <target state="translated">与C++早期定义的兼容性。</target>
        </trans-unit>
        <trans-unit id="51c2b0659cd05018587a8d43545227600a32a376" translate="yes" xml:space="preserve">
          <source>Compilation can involve up to four stages: preprocessing, compilation proper, assembly and linking, always in that order. GCC is capable of preprocessing and compiling several files either into several assembler input files, or into one assembler input file; then each assembler input file produces an object file, and linking combines all the object files (those newly compiled, and those specified as input) into an executable file.</source>
          <target state="translated">编译最多可以包括四个阶段:预处理、适当编译、汇编和链接,顺序总是如此。GCC能够对若干文件进行预处理,并将其编译成若干个汇编器输入文件或一个汇编器输入文件;然后,每个汇编器输入文件产生一个对象文件,而链接则将所有的对象文件(新编译的文件和指定为输入的文件)合并为一个可执行文件。</target>
        </trans-unit>
        <trans-unit id="1f490d968ba17b1a6b9c49acd428a6392e787830" translate="yes" xml:space="preserve">
          <source>Compile ARCv2 code with a multiplier design option. You can specify the option using either a string or numeric value for &lt;var&gt;multo&lt;/var&gt;. &amp;lsquo;</source>
          <target state="translated">使用乘法器设计选项编译ARCv2代码。您可以使用字符串或 &lt;var&gt;multo&lt;/var&gt; 数值指定选项。'</target>
        </trans-unit>
        <trans-unit id="4a90dd66273f8436ce33369f342227123629a080" translate="yes" xml:space="preserve">
          <source>Compile code assuming that IEEE signaling NaNs may generate user-visible traps during floating-point operations. Setting this option disables optimizations that may change the number of exceptions visible with signaling NaNs. This option implies</source>
          <target state="translated">编译代码时假设IEEE信号NaNs在浮点运算时可能产生用户可见的陷阱。设置该选项可以禁止可能改变信号NaNs可见异常数量的优化。这个选项意味着,在编译代码时,要考虑到IEEE信号NaN可能会在浮点运算时产生用户可见的陷阱。</target>
        </trans-unit>
        <trans-unit id="9970fa5395affc7dc93ea1ed06f8fdd6c082c5bc" translate="yes" xml:space="preserve">
          <source>Compile code assuming that floating-point operations cannot generate user-visible traps. These traps include division by zero, overflow, underflow, inexact result and invalid operation. This option requires that</source>
          <target state="translated">编译代码时假设浮点运算不会产生用户可见的陷阱,这些陷阱包括零除、溢出、底溢、不完全结果和无效运算。这些陷阱包括:零除、溢出、底溢、不精确结果和无效操作。该选项要求</target>
        </trans-unit>
        <trans-unit id="7167229840a9f09cf85e4d3c02813e6e3f7c2954" translate="yes" xml:space="preserve">
          <source>Compile code assuming that pointers to the PPU address space accessed via the &lt;code&gt;__ea&lt;/code&gt; named address space qualifier are either 32 or 64 bits wide. The default is 32 bits. As this is an ABI-changing option, all object code in an executable must be compiled with the same setting.</source>
          <target state="translated">假定通过 &lt;code&gt;__ea&lt;/code&gt; 命名的地址空间限定符访问的PPU地址空间的指针的宽度为32位或64位，则编译代码。默认值为32位。由于这是一个更改ABI的选项，因此必须使用相同的设置来编译可执行文件中的所有目标代码。</target>
        </trans-unit>
        <trans-unit id="31103695d6eecad4fc985951c0af142d11cd5c1a" translate="yes" xml:space="preserve">
          <source>Compile code compatible with Android platform. This is the default on &amp;lsquo;</source>
          <target state="translated">编译与Android平台兼容的代码。这是&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="894efb97728307a39eeed2699c1c4e4bd26dd9dc" translate="yes" xml:space="preserve">
          <source>Compile code for big-endian mode. This is the default.</source>
          <target state="translated">编译大段模式的代码。这是默认的。</target>
        </trans-unit>
        <trans-unit id="d1832ee4b35f2abfa3f4e141edadd28f18085110" translate="yes" xml:space="preserve">
          <source>Compile code for big-endian targets. Use of these options is now deprecated. Big-endian code is supported by configuring GCC to build &lt;code&gt;arceb-elf32&lt;/code&gt; and &lt;code&gt;arceb-linux-uclibc&lt;/code&gt; targets, for which big endian is the default.</source>
          <target state="translated">编译大端目标的代码。现在不建议使用这些选项。通过配置GCC来构建 &lt;code&gt;arceb-elf32&lt;/code&gt; 和 &lt;code&gt;arceb-linux-uclibc&lt;/code&gt; 目标来支持big-endian代码，默认情况下为big endian。</target>
        </trans-unit>
        <trans-unit id="be8c22e36ad1f39109ec2efd6cc1a81d955acd13" translate="yes" xml:space="preserve">
          <source>Compile code for little-endian mode.</source>
          <target state="translated">编译小二烯模式的代码。</target>
        </trans-unit>
        <trans-unit id="9b8ec4f965ec58185bb6754ac805aafeb89d3ae4" translate="yes" xml:space="preserve">
          <source>Compile code for little-endian targets. Use of these options is now deprecated. Little-endian code is supported by configuring GCC to build &lt;code&gt;arc-elf32&lt;/code&gt; and &lt;code&gt;arc-linux-uclibc&lt;/code&gt; targets, for which little endian is the default.</source>
          <target state="translated">编译小端目标的代码。现在不建议使用这些选项。通过配置GCC来构建 &lt;code&gt;arc-elf32&lt;/code&gt; 和 &lt;code&gt;arc-linux-uclibc&lt;/code&gt; 目标，可以支持little-endian代码，对于这些目标，默认为little-endian。</target>
        </trans-unit>
        <trans-unit id="b9cb11574bb395057387b096cea7b6d6f515f971" translate="yes" xml:space="preserve">
          <source>Compile code for the processor in big-endian mode.</source>
          <target state="translated">以大段模式编译处理器的代码。</target>
        </trans-unit>
        <trans-unit id="9f489feb9b6caedf9bb6320c99f84e7364f3077b" translate="yes" xml:space="preserve">
          <source>Compile code for the processor in little-endian mode.</source>
          <target state="translated">以小二烯模式编译处理器的代码。</target>
        </trans-unit>
        <trans-unit id="39bc5e8e166e8b03d8be316efdd326cda59c0f57" translate="yes" xml:space="preserve">
          <source>Compile for ARC 600 CPU with &lt;code&gt;norm&lt;/code&gt; and 32x16-bit multiply instructions enabled.</source>
          <target state="translated">为ARC 600 CPU编译并启用了 &lt;code&gt;norm&lt;/code&gt; 和32x16位乘法指令。</target>
        </trans-unit>
        <trans-unit id="17be7dfb615c6d886c0d693b9048e7e155b99fb6" translate="yes" xml:space="preserve">
          <source>Compile for ARC 600 CPU with &lt;code&gt;norm&lt;/code&gt; and &lt;code&gt;mul64&lt;/code&gt;-family instructions enabled.</source>
          <target state="translated">在启用了 &lt;code&gt;norm&lt;/code&gt; 和 &lt;code&gt;mul64&lt;/code&gt; 系列说明的情况下针对ARC 600 CPU进行编译。</target>
        </trans-unit>
        <trans-unit id="d7f2d72dcd31900923f3da8d539cfc9292aa3f8e" translate="yes" xml:space="preserve">
          <source>Compile for ARC 600 CPU with &lt;code&gt;norm&lt;/code&gt; instructions enabled.</source>
          <target state="translated">在启用了 &lt;code&gt;norm&lt;/code&gt; 指令的情况下针对ARC 600 CPU进行编译。</target>
        </trans-unit>
        <trans-unit id="16696f4c8426aaf6854eeea45ee7e1bd467edd27" translate="yes" xml:space="preserve">
          <source>Compile for ARC 601 CPU with &lt;code&gt;norm&lt;/code&gt; and 32x16-bit multiply instructions enabled.</source>
          <target state="translated">为ARC 601 CPU编译并启用了 &lt;code&gt;norm&lt;/code&gt; 和32x16位乘法指令。</target>
        </trans-unit>
        <trans-unit id="5bca932c9c4e343d44b89be260ad06bfe429ab8a" translate="yes" xml:space="preserve">
          <source>Compile for ARC 601 CPU with &lt;code&gt;norm&lt;/code&gt; and &lt;code&gt;mul64&lt;/code&gt;-family instructions enabled.</source>
          <target state="translated">在启用了 &lt;code&gt;norm&lt;/code&gt; 和 &lt;code&gt;mul64&lt;/code&gt; 系列指令的情况下为ARC 601 CPU进行编译。</target>
        </trans-unit>
        <trans-unit id="02df7632e889a6c5616971f35e12edcc4a5d8c62" translate="yes" xml:space="preserve">
          <source>Compile for ARC 601 CPU with &lt;code&gt;norm&lt;/code&gt; instructions enabled.</source>
          <target state="translated">在启用了 &lt;code&gt;norm&lt;/code&gt; 指令的情况下为ARC 601 CPU进行编译。</target>
        </trans-unit>
        <trans-unit id="b7fdc4d4b7214e5e7819e3d3a90236053d8b22cd" translate="yes" xml:space="preserve">
          <source>Compile for ARC 700 on NPS400 chip.</source>
          <target state="translated">在NPS400芯片上为ARC 700编译。</target>
        </trans-unit>
        <trans-unit id="1e4380f255d2d18d4e8f267e7678f7435eab73b8" translate="yes" xml:space="preserve">
          <source>Compile for ARC EM CPU with no hardware extensions.</source>
          <target state="translated">为ARC EM CPU编译,无硬件扩展。</target>
        </trans-unit>
        <trans-unit id="d617eff21e80138509c5fb71d3dfb75e71687f6e" translate="yes" xml:space="preserve">
          <source>Compile for ARC EM minimalist configuration featuring reduced register set.</source>
          <target state="translated">编译ARC EM最小化配置,减少寄存器集。</target>
        </trans-unit>
        <trans-unit id="75b4e707d87f6b65d51c529906a072e95ff89b29" translate="yes" xml:space="preserve">
          <source>Compile for ARC EM.</source>
          <target state="translated">为ARC EM编译。</target>
        </trans-unit>
        <trans-unit id="da70dd835733600356587db74a19ff09214dbd17" translate="yes" xml:space="preserve">
          <source>Compile for ARC EM4 CPU.</source>
          <target state="translated">为ARC EM4 CPU编译。</target>
        </trans-unit>
        <trans-unit id="a460d3a31969ec154e7b1632e56830c60250b541" translate="yes" xml:space="preserve">
          <source>Compile for ARC EM4 DMIPS CPU with single-precision floating-point and double assist instructions.</source>
          <target state="translated">编译用于ARC EM4 DMIPS CPU的单精度浮点和双辅助指令。</target>
        </trans-unit>
        <trans-unit id="a5b00683884602ca4044736a233bc8c892a0f636" translate="yes" xml:space="preserve">
          <source>Compile for ARC EM4 DMIPS CPU with the single-precision floating-point extension.</source>
          <target state="translated">编译用于ARC EM4 DMIPS CPU的单精度浮点扩展。</target>
        </trans-unit>
        <trans-unit id="88b1ffe9efdf7ea63c9f3422bb5547df94d22ce1" translate="yes" xml:space="preserve">
          <source>Compile for ARC EM4 DMIPS CPU.</source>
          <target state="translated">为ARC EM4 DMIPS CPU编译。</target>
        </trans-unit>
        <trans-unit id="086d9196358fe7f0fa7f3e7051ae4fc4f433b7ae" translate="yes" xml:space="preserve">
          <source>Compile for ARC HS CPU with no hardware extensions except the atomic instructions.</source>
          <target state="translated">为ARC HS CPU编译,除了原子指令外,没有任何硬件扩展。</target>
        </trans-unit>
        <trans-unit id="cacfee18847f11dad685598d36ea6ee3b6957c02" translate="yes" xml:space="preserve">
          <source>Compile for ARC HS.</source>
          <target state="translated">为ARC HS编译。</target>
        </trans-unit>
        <trans-unit id="847cd27652d52b58f36a4f2e5ea5cead4371673c" translate="yes" xml:space="preserve">
          <source>Compile for ARC HS34 CPU.</source>
          <target state="translated">为ARC HS34 CPU编译。</target>
        </trans-unit>
        <trans-unit id="d44b3581972b8ea0a69f39fb0ebefd762b42bbe7" translate="yes" xml:space="preserve">
          <source>Compile for ARC HS38 CPU with all hardware extensions on.</source>
          <target state="translated">为ARC HS38 CPU编译,并开启所有硬件扩展。</target>
        </trans-unit>
        <trans-unit id="4c711906d8e4d4a87fb48440c2cfaa0c80bee620" translate="yes" xml:space="preserve">
          <source>Compile for ARC HS38 CPU.</source>
          <target state="translated">为ARC HS38 CPU编译。</target>
        </trans-unit>
        <trans-unit id="8348ca27592b892d967948ee652e94376f711101" translate="yes" xml:space="preserve">
          <source>Compile for ARC600. Aliases:</source>
          <target state="translated">为ARC600编译。别名:</target>
        </trans-unit>
        <trans-unit id="9c0fc8bbbde2253a58a83a11623bea243e8a7c8b" translate="yes" xml:space="preserve">
          <source>Compile for ARC601. Alias:</source>
          <target state="translated">为ARC601编译。别名:</target>
        </trans-unit>
        <trans-unit id="05e0d990baf06011ef4d82bdf9df53fdce00286b" translate="yes" xml:space="preserve">
          <source>Compile for ARC700. Aliases:</source>
          <target state="translated">为ARC700编译。别名:</target>
        </trans-unit>
        <trans-unit id="e278797da8990f0ccb7f07f045508cd4010b76aa" translate="yes" xml:space="preserve">
          <source>Compile for GCN3 Fiji devices (gfx803).</source>
          <target state="translated">为GCN3 Fiji设备(gfx803)编译。</target>
        </trans-unit>
        <trans-unit id="713b8f86530a1c2d9a5d702e486321c4dc351849" translate="yes" xml:space="preserve">
          <source>Compile for GCN5 Vega 10 devices (gfx900).</source>
          <target state="translated">为GCN5 Vega 10设备(gfx900)编译。</target>
        </trans-unit>
        <trans-unit id="d6c48f84ed7faf104f474152b0d3bc268ee56eba" translate="yes" xml:space="preserve">
          <source>Compile or assemble the source files, but do not link. The linking stage simply is not done. The ultimate output is in the form of an object file for each source file.</source>
          <target state="translated">编译或组装源文件,但不要链接。链接阶段根本没有完成。最终输出的是每个源文件的对象文件形式。</target>
        </trans-unit>
        <trans-unit id="aada22a2dba27d65c33f8d484ca9df970f74fa8a" translate="yes" xml:space="preserve">
          <source>Compile the source files additionally with</source>
          <target state="translated">编译源文件,另外用</target>
        </trans-unit>
        <trans-unit id="8e1d1625ee50b70503b880bddd8c2899625cfd1d" translate="yes" xml:space="preserve">
          <source>Compile the source files with</source>
          <target state="translated">编译源文件时使用</target>
        </trans-unit>
        <trans-unit id="bae2f3f4c4da22165b65f81f0ab47bfdf72e5a74" translate="yes" xml:space="preserve">
          <source>Compile your code with</source>
          <target state="translated">编译你的代码,用</target>
        </trans-unit>
        <trans-unit id="61a5380160ff93557be23ea688dad9be208e4dbd" translate="yes" xml:space="preserve">
          <source>Compile your template-using code with</source>
          <target state="translated">编译你的模板使用代码</target>
        </trans-unit>
        <trans-unit id="bb1fb4ab4c5c8120d8c582a624d0a9ac53f55fe3" translate="yes" xml:space="preserve">
          <source>Compiler encoding</source>
          <target state="translated">编译器编码</target>
        </trans-unit>
        <trans-unit id="24922f29f09454ba5b177fdcf5e81c9543043eef" translate="yes" xml:space="preserve">
          <source>Compiler support for type traits.</source>
          <target state="translated">编译器对类型特征的支持。</target>
        </trans-unit>
        <trans-unit id="2d58377b2111c9408f411d965f3b8abfb37ec05b" translate="yes" xml:space="preserve">
          <source>Compiling C++ programs.</source>
          <target state="translated">编译C++程序。</target>
        </trans-unit>
        <trans-unit id="ed13de84ad4a0f0cd9e6bd0e630f5cc19d816c7d" translate="yes" xml:space="preserve">
          <source>Compiling a header once, and using it many times.</source>
          <target state="translated">编译一次头条,多次使用。</target>
        </trans-unit>
        <trans-unit id="a9cb191f84bf0e0a5fd4e8fafa0cbeb0ce255ebb" translate="yes" xml:space="preserve">
          <source>Compiling with</source>
          <target state="translated">编译</target>
        </trans-unit>
        <trans-unit id="8097f9a2f49c7bb34a8f3d4a23b5682dee4f13c4" translate="yes" xml:space="preserve">
          <source>Complex multiplication and division follow Fortran rules. Range reduction is done as part of complex division, but there is no checking whether the result of a complex multiplication or division is &lt;code&gt;NaN
+ I*NaN&lt;/code&gt;, with an attempt to rescue the situation in that case.</source>
          <target state="translated">复杂的乘法和除法遵循Fortran规则。范围缩小是复数除法的一部分，但是没有检查复数乘法或除法的结果是否为 &lt;code&gt;NaN + I*NaN&lt;/code&gt; ，从而试图挽救这种情况。</target>
        </trans-unit>
        <trans-unit id="e323088fd5a174d70e9a002849c8a4e688bcae61" translate="yes" xml:space="preserve">
          <source>Complex types</source>
          <target state="translated">复杂类型</target>
        </trans-unit>
        <trans-unit id="a513e209b739423b55158eb7f0004ee614ede0ee" translate="yes" xml:space="preserve">
          <source>Comply with the calling conventions defined by Renesas.</source>
          <target state="translated">遵守Renesas定义的调用惯例。</target>
        </trans-unit>
        <trans-unit id="7ca1263e4404b74af40b4e0106fd5b298bab578a" translate="yes" xml:space="preserve">
          <source>Comply with the calling conventions defined for GCC before the Renesas conventions were available. This option is the default for all targets of the SH toolchain.</source>
          <target state="translated">遵守在Renesas约定之前为GCC定义的调用约定。这个选项是所有SH工具链目标的默认值。</target>
        </trans-unit>
        <trans-unit id="8065b09eb57234d64105b727689f45402502d3a0" translate="yes" xml:space="preserve">
          <source>Compound literals for scalar types and union types are also allowed. In the following example the variable &lt;code&gt;i&lt;/code&gt; is initialized to the value &lt;code&gt;2&lt;/code&gt;, the result of incrementing the unnamed object created by the compound literal.</source>
          <target state="translated">标量类型和联合类型的复合文字也被允许。在下面的示例中，变量 &lt;code&gt;i&lt;/code&gt; 初始化为值 &lt;code&gt;2&lt;/code&gt; ，该值是由复合文字创建的未命名对象递增的结果。</target>
        </trans-unit>
        <trans-unit id="a6bff82561ec7274ee97d8914e7822d45d55dda6" translate="yes" xml:space="preserve">
          <source>Compound literals give structures, unions or arrays as values.</source>
          <target state="translated">复合字元给出结构、联合或数组作为值。</target>
        </trans-unit>
        <trans-unit id="9966e73a786b7c65f837b6274e264d2ae3402caf" translate="yes" xml:space="preserve">
          <source>Compress all code using the Ft32B code compression scheme.</source>
          <target state="translated">使用Ft32B代码压缩方案压缩所有代码。</target>
        </trans-unit>
        <trans-unit id="6c77d95794a767632393b14f518d98416da9d81b" translate="yes" xml:space="preserve">
          <source>Compute the overlap score between the two specified profile directories. The overlap score is computed based on the arc profiles. It is defined as the sum of min (p1_counter[i] / p1_sum_all, p2_counter[i] / p2_sum_all), for all arc counter i, where p1_counter[i] and p2_counter[i] are two matched counters and p1_sum_all and p2_sum_all are the sum of counter values in profile 1 and profile 2, respectively.</source>
          <target state="translated">计算两个指定剖面目录之间的重叠得分。重叠得分是根据弧形轮廓计算的。它被定义为所有弧形计数器i的最小值(p1_counter[i]/p1_sum_all,p2_counter[i]/p2_sum_all)之和,其中p1_counter[i]和p2_counter[i]是两个匹配的计数器,p1_sum_all和p2_sum_all分别是剖面1和剖面2的计数器值之和。</target>
        </trans-unit>
        <trans-unit id="e0428c06ffccfdc67cd165569d403d34631d68a4" translate="yes" xml:space="preserve">
          <source>Condition code register</source>
          <target state="translated">条件码注册</target>
        </trans-unit>
        <trans-unit id="e7cba93bc22565aab9f967f87bf72c15fbda6979" translate="yes" xml:space="preserve">
          <source>Conditional move based on absolute comparison (&lt;code&gt;cabs.&lt;var&gt;cond&lt;/var&gt;.ps&lt;/code&gt;, &lt;code&gt;movt.ps&lt;/code&gt;/&lt;code&gt;movf.ps&lt;/code&gt;).</source>
          <target state="translated">基于绝对比较条件移动（ &lt;code&gt;cabs.&lt;var&gt;cond&lt;/var&gt;.ps&lt;/code&gt; ， &lt;code&gt;movt.ps&lt;/code&gt; / &lt;code&gt;movf.ps&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="ef8ee622eb15147934b0f1ea15e7848c0fa98464" translate="yes" xml:space="preserve">
          <source>Conditional move based on floating-point comparison (&lt;code&gt;c.&lt;var&gt;cond&lt;/var&gt;.ps&lt;/code&gt;, &lt;code&gt;movt.ps&lt;/code&gt;/&lt;code&gt;movf.ps&lt;/code&gt;).</source>
          <target state="translated">基于浮点比较条件移动（ &lt;code&gt;c.&lt;var&gt;cond&lt;/var&gt;.ps&lt;/code&gt; ， &lt;code&gt;movt.ps&lt;/code&gt; / &lt;code&gt;movf.ps&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="34fb4ffc803fecfe4e7aef7908f668b60686f196" translate="yes" xml:space="preserve">
          <source>Configure a board specific runtime. This will be passed to the linker for newlib board library linking. The default is &lt;code&gt;or1ksim&lt;/code&gt;.</source>
          <target state="translated">配置主板特定的运行时。这将传递给链接器以进行newlib板库链接。缺省值为 &lt;code&gt;or1ksim&lt;/code&gt; 。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
