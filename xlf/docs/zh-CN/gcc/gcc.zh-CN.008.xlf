<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="gcc">
    <body>
      <group id="gcc">
        <trans-unit id="aeab84fbb87aa1ae0148d00185bbbe64a7f1de75" translate="yes" xml:space="preserve">
          <source>Do/do not align destination of inlined string operations.</source>
          <target state="translated">做/不对齐内联字符串操作的目标。</target>
        </trans-unit>
        <trans-unit id="bc45e676c4601147aa81205b6b35bbce28a0956f" translate="yes" xml:space="preserve">
          <source>Dollar sign is allowed in identifiers.</source>
          <target state="translated">在标识符中允许使用美元符号。</target>
        </trans-unit>
        <trans-unit id="68e93316f665d706cb16fce9b665aecabf389d83" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t (or do) generate assembler code for the DWARF line number debugging info. This may be useful when not using the GNU assembler.</source>
          <target state="translated">不要（或这样做）为DWARF行号调试信息生成汇编代码。当不使用GNU汇编器时，这可能很有用。</target>
        </trans-unit>
        <trans-unit id="c37914471f4a30f8d34225039b83103b924890c2" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t add</source>
          <target state="translated">不要加</target>
        </trans-unit>
        <trans-unit id="f51bdbcf76c028728ebe02e5fd8a3a1a4630491b" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t allocate any register in the range &lt;code&gt;r32&lt;/code&gt;&amp;hellip;&lt;code&gt;r63&lt;/code&gt;. That allows code to run on hardware variants that lack these registers.</source>
          <target state="translated">不要在 &lt;code&gt;r32&lt;/code&gt; &amp;hellip; &lt;code&gt;r63&lt;/code&gt; 范围内分配任何寄存器。这使得代码可以在缺少这些寄存器的硬件变体上运行。</target>
        </trans-unit>
        <trans-unit id="0696f924a6a7aba65bb0c521d005ad21d730a7e5" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t allow (allow) the compiler generating privileged mode code. Specifying</source>
          <target state="translated">不允许（允许）编译器生成特权模式代码。指定</target>
        </trans-unit>
        <trans-unit id="b4aac26fa88db757f99f48797196bd3cbd91bc9d" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t emit code for implicit instantiations of inline templates, either. The default is to handle inlines differently so that compiles with and without optimization need the same set of explicit instantiations.</source>
          <target state="translated">也不为内联模板的隐式实例发出代码。缺省设置是对内联进行不同的处理，因此无论是否进行优化，编译过程都需要使用同一组显式实例化。</target>
        </trans-unit>
        <trans-unit id="c69befd629431a6e029cd45dbc6aab7876d6d7d6" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t generate code to check for violation of exception specifications at run time. This option violates the C++ standard, but may be useful for reducing code size in production builds, much like defining &lt;code&gt;NDEBUG&lt;/code&gt;. This does not give user code permission to throw exceptions in violation of the exception specifications; the compiler still optimizes based on the specifications, so throwing an unexpected exception results in undefined behavior at run time.</source>
          <target state="translated">不要在运行时生成代码来检查是否违反了异常规范。该选项违反了C ++标准，但是对于减少生产版本中的代码大小可能很有用，就像定义 &lt;code&gt;NDEBUG&lt;/code&gt; 一样。这不授予用户代码违反异常规范的权限来抛出异常；编译器仍会根据规范进行优化，因此抛出意外异常会在运行时导致未定义的行为。</target>
        </trans-unit>
        <trans-unit id="f8291058c6a41a1212fed5bdc0b889e02ad54e73" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t generate extra code to prevent CSYNC or SSYNC instructions from occurring too soon after a conditional branch.</source>
          <target state="translated">不要生成额外的代码来防止CSYNC或SSYNC指令在条件分支后过早发生。</target>
        </trans-unit>
        <trans-unit id="92fc05375382df9e90695eff3a44465379a9fc8a" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t generate extra code to prevent speculative loads from occurring.</source>
          <target state="translated">不要生成额外的代码来防止投机负载的发生。</target>
        </trans-unit>
        <trans-unit id="841b2c5913f27dd6d0a0b75be4041ed9060e2a5b" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t indicate any priority for target registers.</source>
          <target state="translated">不要为目标寄存器指定任何优先级。</target>
        </trans-unit>
        <trans-unit id="316b458b3b915800cc227cb589b8354e8997e031" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t insert NOPs.</source>
          <target state="translated">不要插入NOP。</target>
        </trans-unit>
        <trans-unit id="ff257b74ea5cefc2a6c99dc46dcf1ce2fc00c3e9" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t keep the frame pointer in a register for leaf functions. This avoids the instructions to save, set up and restore frame pointers and makes an extra register available in leaf functions.</source>
          <target state="translated">不要将帧指针保存在用于叶函数的寄存器中。这避免了保存，设置和还原帧指针的指令，并在叶函数中提供了额外的寄存器。</target>
        </trans-unit>
        <trans-unit id="29fcb114afda8378c254d0362fee3390fc31a076" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t keep the frame pointer in a register for leaf functions. This avoids the instructions to save, set up, and restore frame pointers and makes an extra register available in leaf functions. The option</source>
          <target state="translated">不要将帧指针保存在用于叶函数的寄存器中。这避免了保存，设置和还原帧指针的说明，并在叶函数中提供了额外的寄存器。选项</target>
        </trans-unit>
        <trans-unit id="ba01c69254f25c86224b738f06e6534bc4f3d911" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t link against AVR-LibC&amp;rsquo;s device specific library &lt;code&gt;lib&amp;lt;mcu&amp;gt;.a&lt;/code&gt;.</source>
          <target state="translated">不要链接到AVR-LibC的设备专用库 &lt;code&gt;lib&amp;lt;mcu&amp;gt;.a&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e29b08debc2f8c83b43cab1a04eee2f4d727ea03" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t output a &lt;code&gt;.size&lt;/code&gt; assembler directive, or anything else that would cause trouble if the function is split in the middle, and the two halves are placed at locations far apart in memory. This option is used when compiling</source>
          <target state="translated">不要输出 &lt;code&gt;.size&lt;/code&gt; 汇编程序指令，否则不要输出任何其他会导致问题的结果，如果函数在中间被拆分，并且两半放在内存中相距较远的位置。编译时使用此选项</target>
        </trans-unit>
        <trans-unit id="d01cd709102ba1930825f66a542ae471f0249850" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t produce a dynamically linked position independent executable.</source>
          <target state="translated">不要产生动态链接的位置无关可执行文件。</target>
        </trans-unit>
        <trans-unit id="0d7422ae3d66c98a5899ca6447dbd9bcec60457e" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t recognize built-in functions that do not begin with &amp;lsquo;</source>
          <target state="translated">无法识别不以'开头的内置函数</target>
        </trans-unit>
        <trans-unit id="700e3402560c020ff640d0360da073b7f29b63b2" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t try to return a reference when you must return an object.</source>
          <target state="translated">当您必须返回对象时，请勿尝试返回引用。</target>
        </trans-unit>
        <trans-unit id="af0c2963603baeac9b84a7601cb10b5b24bf9b5d" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t use less than 25-bit addressing range for calls, which is the offset available for an unconditional branch-and-link instruction. Conditional execution of function calls is suppressed, to allow use of the 25-bit range, rather than the 21-bit range with conditional branch-and-link. This is the default for tool chains built for &lt;code&gt;arc-linux-uclibc&lt;/code&gt; and &lt;code&gt;arceb-linux-uclibc&lt;/code&gt; targets.</source>
          <target state="translated">调用时不要使用少于25位的寻址范围，这是无条件分支和链接指令可用的偏移量。抑制了函数调用的有条件执行，以允许使用25位范围，而不是使用带条件分支和链接的21位范围。这是为 &lt;code&gt;arc-linux-uclibc&lt;/code&gt; 和 &lt;code&gt;arceb-linux-uclibc&lt;/code&gt; 目标构建的工具链的默认设置。</target>
        </trans-unit>
        <trans-unit id="71dc31daaf7ec06b2fa4f05018881b81c4bb5538" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t use the &lt;code&gt;__cxa_get_exception_ptr&lt;/code&gt; runtime routine. This causes &lt;code&gt;std::uncaught_exception&lt;/code&gt; to be incorrect, but is necessary if the runtime routine is not available.</source>
          <target state="translated">不要使用 &lt;code&gt;__cxa_get_exception_ptr&lt;/code&gt; 运行时例程。这会导致 &lt;code&gt;std::uncaught_exception&lt;/code&gt; 不正确，但是如果运行时例程不可用，则有必要。</target>
        </trans-unit>
        <trans-unit id="8dcc5d27681a8bdad6a9cb3ee54a8968b968d227" translate="yes" xml:space="preserve">
          <source>Double-precision floating point:</source>
          <target state="translated">双精度浮点数。</target>
        </trans-unit>
        <trans-unit id="ed1ceb86db6df41816a7c2bb25eb2a7096005f14" translate="yes" xml:space="preserve">
          <source>Double-precision minimum and maximum. These instructions are only generated if</source>
          <target state="translated">双精度的最小值和最大值。只有在以下情况下才会产生这些指令</target>
        </trans-unit>
        <trans-unit id="37d9eb125267c27f5502a1a9d084767dc36a78f0" translate="yes" xml:space="preserve">
          <source>Double-precision trigonometric and exponential functions. These instructions are only generated if</source>
          <target state="translated">双精度三角函数和指数函数。只有在以下情况下才会产生这些指令</target>
        </trans-unit>
        <trans-unit id="6df71cfe44fe533eddb81c22b571782849f6b7cc" translate="yes" xml:space="preserve">
          <source>Double-word integers&amp;mdash;&lt;code&gt;long long int&lt;/code&gt;.</source>
          <target state="translated">双字整数-long &lt;code&gt;long long int&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dc953a7def63cef4cb68fb70c5f14bea1b94cf60" translate="yes" xml:space="preserve">
          <source>Downgrade some diagnostics about nonconformant code from errors to warnings. Thus, using</source>
          <target state="translated">将一些关于不合格代码的诊断从错误降级为警告。因此,使用</target>
        </trans-unit>
        <trans-unit id="01180802e3e84af7a4d8039eea60df66e24e2e3d" translate="yes" xml:space="preserve">
          <source>Due to a limitation the &lt;code&gt;__builtin_has_attribute&lt;/code&gt; function returns &lt;code&gt;false&lt;/code&gt; for the &lt;code&gt;mode&lt;/code&gt; attribute even if the type or variable referenced by the &lt;var&gt;type-or-expression&lt;/var&gt; argument was declared with one. The function is also not supported with labels, and in C with enumerators.</source>
          <target state="translated">由于限制所述 &lt;code&gt;__builtin_has_attribute&lt;/code&gt; 函数返回 &lt;code&gt;false&lt;/code&gt; 的 &lt;code&gt;mode&lt;/code&gt; 即使由所引用的类型或变量属性 &lt;var&gt;type-or-expression&lt;/var&gt; 参数是使用一个所声明的。标签也不支持该功能，C中还没有枚举器支持该功能。</target>
        </trans-unit>
        <trans-unit id="eaa7b08f0e0c97160e76284248f06868dbcb58d2" translate="yes" xml:space="preserve">
          <source>Due to delay slot scheduling and interactions between operand numbers, literal sizes, instruction lengths, and the support for conditional execution, the target-independent pass to generate conditional execution is often lacking, so the ARC port has kept a special pass around that tries to find more conditional execution generation opportunities after register allocation, branch shortening, and delay slot scheduling have been done. This pass generally, but not always, improves performance and code size, at the cost of extra compilation time, which is why there is an option to switch it off. If you have a problem with call instructions exceeding their allowable offset range because they are conditionalized, you should consider using</source>
          <target state="translated">由于延时槽调度以及操作数、字面大小、指令长度之间的相互影响,以及对条件执行的支持,产生条件执行的目标无关的通证往往是缺乏的,所以ARC端口保留了一个特殊的通证,它试图在寄存器分配、分支缩短和延时槽调度完成后,寻找更多的条件执行生成机会。这个通证一般来说,但并不总是能提高性能和代码大小,但代价是额外的编译时间,这就是为什么有一个选项可以关闭它。如果你的调用指令因为被条件化而超过其允许的偏移范围,你应该考虑使用</target>
        </trans-unit>
        <trans-unit id="8570e266a139eea3cf33870c783885655692c297" translate="yes" xml:space="preserve">
          <source>Due to differences in 64-bit ABIs, any Microsoft ABI function that calls a System V ABI function must consider RSI, RDI and XMM6-15 as clobbered. By default, the code for saving and restoring these registers is emitted inline, resulting in fairly lengthy prologues and epilogues. Using</source>
          <target state="translated">由于64位ABI的差异,任何调用System V ABI函数的Microsoft ABI函数必须将RSI、RDI和XMM6-15视为clobbered。默认情况下,保存和恢复这些寄存器的代码是内联发射的,导致相当长的序言和尾声。使用</target>
        </trans-unit>
        <trans-unit id="408f58f18488b8883676547177ce8b939c3a83db" translate="yes" xml:space="preserve">
          <source>Dump a representation of the &amp;ldquo;exploded graph&amp;rdquo; suitable for viewing with GraphViz to</source>
          <target state="translated">将适合用GraphViz查看的&amp;ldquo;爆炸图&amp;rdquo;的表示转储到</target>
        </trans-unit>
        <trans-unit id="169bc667798b22c68aedd5d55d686c15e2808baf" translate="yes" xml:space="preserve">
          <source>Dump a representation of the call graph suitable for viewing with GraphViz to</source>
          <target state="translated">将适合于用GraphViz查看的调用图的表示形式转储到</target>
        </trans-unit>
        <trans-unit id="57d46471a4ce7f3b77f03f78421a9baa93db393b" translate="yes" xml:space="preserve">
          <source>Dump a textual representation of the &amp;ldquo;exploded graph&amp;rdquo; to</source>
          <target state="translated">将&amp;ldquo;分解图&amp;rdquo;的文本表示转储到</target>
        </trans-unit>
        <trans-unit id="ca50a32f407b97e3b5dbaa8c49a491f9e0224426" translate="yes" xml:space="preserve">
          <source>Dump a textual representation of the &amp;ldquo;exploded graph&amp;rdquo; to one dump file per node, to</source>
          <target state="translated">将&amp;ldquo;分解图&amp;rdquo;的文本表示转储到每个节点的一个转储文件中，以</target>
        </trans-unit>
        <trans-unit id="55dc1ed426258fad4287ccc3186c8799b4478fe2" translate="yes" xml:space="preserve">
          <source>Dump after RTL generation.</source>
          <target state="translated">RTL生成后的倾倒。</target>
        </trans-unit>
        <trans-unit id="55112da270658f739f4dfb65c2070abbe0a2de15" translate="yes" xml:space="preserve">
          <source>Dump after all rtl has been unshared.</source>
          <target state="translated">在所有的rtl都被取消共享后,Dump。</target>
        </trans-unit>
        <trans-unit id="17713d860b95f07f88ad9a9c6f46bff3093dd8bf" translate="yes" xml:space="preserve">
          <source>Dump after auto-inc-dec discovery. This pass is only run on architectures that have auto inc or auto dec instructions.</source>
          <target state="translated">在发现auto-inc-dec后进行dump。这个通道只在有自动入库或自动出库指令的架构上运行。</target>
        </trans-unit>
        <trans-unit id="4544c05126cdb19431a178314ee1eee9792fb198" translate="yes" xml:space="preserve">
          <source>Dump after block reordering.</source>
          <target state="translated">块重新排序后的转储。</target>
        </trans-unit>
        <trans-unit id="78c9d4108223d54d2d9b5209aec4c77ba61f990a" translate="yes" xml:space="preserve">
          <source>Dump after branch alignments have been computed.</source>
          <target state="translated">在计算完分支排列后进行转储。</target>
        </trans-unit>
        <trans-unit id="becf6aa3d2a32b64f568f0ff4ffede5097942c5f" translate="yes" xml:space="preserve">
          <source>Dump after cleaning up the barrier instructions.</source>
          <target state="translated">清理完障碍物后倾倒说明。</target>
        </trans-unit>
        <trans-unit id="4157bd0dc462fb4b9de6813e4b6322c3ce89115d" translate="yes" xml:space="preserve">
          <source>Dump after combining stack adjustments.</source>
          <target state="translated">合并堆栈调整后转储。</target>
        </trans-unit>
        <trans-unit id="ca08541014a668445bc90fdf9e0e75729f2449db" translate="yes" xml:space="preserve">
          <source>Dump after common sequence discovery.</source>
          <target state="translated">普通序列发现后的转储。</target>
        </trans-unit>
        <trans-unit id="003a4c3463d2348777de9c3ec96a83fded9a133b" translate="yes" xml:space="preserve">
          <source>Dump after conversion from GCC&amp;rsquo;s &amp;ldquo;flat register file&amp;rdquo; registers to the x87&amp;rsquo;s stack-like registers. This pass is only run on x86 variants.</source>
          <target state="translated">从GCC的&amp;ldquo;平面寄存器文件&amp;rdquo;寄存器转换为x87的类似堆栈的寄存器后转储。此过程仅在x86变体上运行。</target>
        </trans-unit>
        <trans-unit id="83008119d9369fbf18b0ada0441c79a07768ec53" translate="yes" xml:space="preserve">
          <source>Dump after conversion of EH handling range regions.</source>
          <target state="translated">EH处理范围区域转换后的转储。</target>
        </trans-unit>
        <trans-unit id="3bf729ea33ed64d3ed60d59c687162fd5feb227f" translate="yes" xml:space="preserve">
          <source>Dump after converting from cfglayout mode.</source>
          <target state="translated">从cfglayout模式转换后的dump。</target>
        </trans-unit>
        <trans-unit id="8c3c2b3635d622c5e7ba8ea735eb12810fb32bac" translate="yes" xml:space="preserve">
          <source>Dump after converting to cfglayout mode.</source>
          <target state="translated">转换为cfglayout模式后的dump。</target>
        </trans-unit>
        <trans-unit id="c3336c59217d8a52dec6ae53e20f9f151f5f642d" translate="yes" xml:space="preserve">
          <source>Dump after converting virtual registers to hard registers.</source>
          <target state="translated">将虚拟寄存器转换为硬寄存器后的转储。</target>
        </trans-unit>
        <trans-unit id="9e4924e7d7139d25008b3b0767ee0c48540ad8c8" translate="yes" xml:space="preserve">
          <source>Dump after delayed branch scheduling.</source>
          <target state="translated">延迟分支调度后的转储。</target>
        </trans-unit>
        <trans-unit id="d2764959e209d321913a6a9e66c4ca5ca11ad126" translate="yes" xml:space="preserve">
          <source>Dump after duplicating the computed gotos.</source>
          <target state="translated">复制计算出的gotos后进行转储。</target>
        </trans-unit>
        <trans-unit id="6e4665a9117fc08d9bbcca5529570f4270193b64" translate="yes" xml:space="preserve">
          <source>Dump after finalization of EH handling code.</source>
          <target state="translated">在最终确定EH处理代码后,Dump。</target>
        </trans-unit>
        <trans-unit id="0bd2968b703fd689e056f9d8a3839eaca5ddccc9" translate="yes" xml:space="preserve">
          <source>Dump after fixing rtl statements that have unsatisfied in/out constraints.</source>
          <target state="translated">修正有不满意的in/out约束的rtl语句后转储。</target>
        </trans-unit>
        <trans-unit id="1f6440e322c9dbaaa59c98dce4c47af3058d32dc" translate="yes" xml:space="preserve">
          <source>Dump after function inlining.</source>
          <target state="translated">在函数内联后进行转储。</target>
        </trans-unit>
        <trans-unit id="988226cdeaba5c3515016a8a81c5ff5fb6cd975a" translate="yes" xml:space="preserve">
          <source>Dump after generating the function prologues and epilogues.</source>
          <target state="translated">生成函数序言和尾声后的转储。</target>
        </trans-unit>
        <trans-unit id="337d4408dd5282e57a077069c98fc55c719caf17" translate="yes" xml:space="preserve">
          <source>Dump after hard register copy propagation.</source>
          <target state="translated">硬寄存器拷贝传播后的转储。</target>
        </trans-unit>
        <trans-unit id="6cfe830bfa04c4483b1574a46bcfd925bca4b994" translate="yes" xml:space="preserve">
          <source>Dump after iterated register allocation.</source>
          <target state="translated">迭代寄存器分配后的转储。</target>
        </trans-unit>
        <trans-unit id="1332404cd20a620c3e5eef9263282d44f935e6c1" translate="yes" xml:space="preserve">
          <source>Dump after jump bypassing and control flow optimizations.</source>
          <target state="translated">跳转旁路和控制流优化后的转储。</target>
        </trans-unit>
        <trans-unit id="bbeda7ae9b9627b581ee42ee3d7f61a589a6f9b2" translate="yes" xml:space="preserve">
          <source>Dump after live range splitting.</source>
          <target state="translated">活期范围分割后的转储。</target>
        </trans-unit>
        <trans-unit id="35f1d73925595e51018771690ad76fb0f4a1f233" translate="yes" xml:space="preserve">
          <source>Dump after modulo scheduling. This pass is only run on some architectures.</source>
          <target state="translated">模数调度后的转储。这个通道只在某些架构上运行。</target>
        </trans-unit>
        <trans-unit id="d76e4430e6a8233563404db6f071f4d94eacdd64" translate="yes" xml:space="preserve">
          <source>Dump after partitioning hot and cold basic blocks.</source>
          <target state="translated">对冷热基本块进行分区后甩。</target>
        </trans-unit>
        <trans-unit id="93dacaa1e7ab1044d9cdae673b25a3808eaccbc6" translate="yes" xml:space="preserve">
          <source>Dump after performing the machine dependent reorganization pass, if that pass exists.</source>
          <target state="translated">在执行依赖机器的重组通证后进行转储,如果该通证存在的话。</target>
        </trans-unit>
        <trans-unit id="b6bdb28476f2b3244c70b802b4bb64b0a7243f10" translate="yes" xml:space="preserve">
          <source>Dump after post-reload optimizations.</source>
          <target state="translated">重载后优化后的转储。</target>
        </trans-unit>
        <trans-unit id="88e826a50b33b907232b8a297fb0c5a8f9b2749b" translate="yes" xml:space="preserve">
          <source>Dump after register renumbering.</source>
          <target state="translated">在寄存器重新编号后进行转储。</target>
        </trans-unit>
        <trans-unit id="ababff05976fea728752ca7d70fe16f292f0407d" translate="yes" xml:space="preserve">
          <source>Dump after removing redundant mode switches.</source>
          <target state="translated">去掉冗余模式开关后的转储。</target>
        </trans-unit>
        <trans-unit id="017c4f83a9a4f5ea41d958881b5ab4ae0e8a9034" translate="yes" xml:space="preserve">
          <source>Dump after shortening branches.</source>
          <target state="translated">缩短枝条后倾倒。</target>
        </trans-unit>
        <trans-unit id="b3771d727095e3610636bea776ecdc1fc695644e" translate="yes" xml:space="preserve">
          <source>Dump after sibling call optimizations.</source>
          <target state="translated">同级调用优化后的转储。</target>
        </trans-unit>
        <trans-unit id="c8dbbab140317072ef733bc98b57dcf08d1828c7" translate="yes" xml:space="preserve">
          <source>Dump after sign/zero extension elimination.</source>
          <target state="translated">签/零延时消除后的倾销。</target>
        </trans-unit>
        <trans-unit id="e9bbcf22fbbd3795374ba7c5550d62449e5abb59" translate="yes" xml:space="preserve">
          <source>Dump after the RTL instruction combination pass.</source>
          <target state="translated">RTL指令组合通过后的Dump。</target>
        </trans-unit>
        <trans-unit id="feffc80f8e62ccde9b555546a5afb7ff2768d0f7" translate="yes" xml:space="preserve">
          <source>Dump after the computation of the initial value sets.</source>
          <target state="translated">在计算完初始值集后进行转储。</target>
        </trans-unit>
        <trans-unit id="5bf6c1aae6940dca8add6967093968d70664b454" translate="yes" xml:space="preserve">
          <source>Dump after the initialization of the registers.</source>
          <target state="translated">寄存器初始化后的Dump。</target>
        </trans-unit>
        <trans-unit id="d22e8f2d8c89989fe194bf7d0b0983f1d445d944" translate="yes" xml:space="preserve">
          <source>Dump after the peephole pass.</source>
          <target state="translated">在窥视孔通行证后倾倒。</target>
        </trans-unit>
        <trans-unit id="9201f61bd4694de8e9a9ab14f3cc717f0cf63945" translate="yes" xml:space="preserve">
          <source>Dump after the second jump optimization.</source>
          <target state="translated">二次跳转优化后的转储。</target>
        </trans-unit>
        <trans-unit id="418c902efcddfdb022a1c7b5bf343ea52897c514" translate="yes" xml:space="preserve">
          <source>Dump after the standalone dead code elimination passes.</source>
          <target state="translated">单机死码消除通过后,转储。</target>
        </trans-unit>
        <trans-unit id="79702f60e31788035dc7ae01b75a7919074a5bce" translate="yes" xml:space="preserve">
          <source>Dump after variable tracking.</source>
          <target state="translated">变量跟踪后的转储。</target>
        </trans-unit>
        <trans-unit id="907510a3aae3ec8d9be507f0c620d65e786ea7f0" translate="yes" xml:space="preserve">
          <source>Dump all macro definitions, at the end of preprocessing, in addition to normal output.</source>
          <target state="translated">转储所有宏定义,在预处理结束后,除正常输出外。</target>
        </trans-unit>
        <trans-unit id="c5efd5b60f90b713fff2357c80d7db933b0250ab" translate="yes" xml:space="preserve">
          <source>Dump class hierarchy information. Virtual table information is emitted unless &amp;rsquo;</source>
          <target state="translated">转储类层次结构信息。发出虚拟表信息，除非&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="7bc6ef641876378e44aa64caddde9a5c6398af12" translate="yes" xml:space="preserve">
          <source>Dump content of records.</source>
          <target state="translated">转储记录的内容。</target>
        </trans-unit>
        <trans-unit id="b65d037ae2af66afd4c389367c4bc6cdd9830974" translate="yes" xml:space="preserve">
          <source>Dump debugging information generated during the debug generation phase.</source>
          <target state="translated">转储调试生成阶段产生的调试信息。</target>
        </trans-unit>
        <trans-unit id="c9b2d27d13ca1550be85a391df7269704a34e8f9" translate="yes" xml:space="preserve">
          <source>Dump debugging information generated during the early debug generation phase.</source>
          <target state="translated">转储早期调试生成阶段产生的调试信息。</target>
        </trans-unit>
        <trans-unit id="1abef1a2a1cc464ec73ba64187b2cddb0b1c7d96" translate="yes" xml:space="preserve">
          <source>Dump initial values of the variables.</source>
          <target state="translated">转储变量的初始值。</target>
        </trans-unit>
        <trans-unit id="5d5bde1ac03861eb7f209733ddfd1025c1c70bcf" translate="yes" xml:space="preserve">
          <source>Dump instruction size and location in the assembly code.</source>
          <target state="translated">转储指令大小和在汇编代码中的位置。</target>
        </trans-unit>
        <trans-unit id="754b569854e205d185835c2d9673785b92b6f32c" translate="yes" xml:space="preserve">
          <source>Dump interface declarations for all classes seen in the source file to a file named</source>
          <target state="translated">将源文件中所有类的接口声明转储到一个名为</target>
        </trans-unit>
        <trans-unit id="71af018e18b101632a18de688096b3fe9f9a731e" translate="yes" xml:space="preserve">
          <source>Dump internal details about what the analyzer is doing to</source>
          <target state="translated">转储分析器正在做什么的内部细节,以达到以下目的</target>
        </trans-unit>
        <trans-unit id="e377d6eb44f5fb68248439a06aca414e07626287" translate="yes" xml:space="preserve">
          <source>Dump internal details about what the analyzer is doing to stderr. This option overrides</source>
          <target state="translated">将分析器正在做的内部细节转储到stderr。这个选项会覆盖</target>
        </trans-unit>
        <trans-unit id="657cfbab09055c61a05bd93612f91cf2d2f1bab3" translate="yes" xml:space="preserve">
          <source>Dump only the defined symbols.</source>
          <target state="translated">只转储定义的符号。</target>
        </trans-unit>
        <trans-unit id="e881c92154f92df37cd4957d4fba3b310ed362c0" translate="yes" xml:space="preserve">
          <source>Dump out a</source>
          <target state="translated">甩出一个</target>
        </trans-unit>
        <trans-unit id="72d2bf1fd50afe65e57f8ac99ba069fc8e23ed58" translate="yes" xml:space="preserve">
          <source>Dump positions of records.</source>
          <target state="translated">倾倒记录的位置。</target>
        </trans-unit>
        <trans-unit id="62f71366775032a269dc239f7ef38d5ece6fef12" translate="yes" xml:space="preserve">
          <source>Dump representations of the &amp;ldquo;supergraph&amp;rdquo; suitable for viewing with GraphViz to</source>
          <target state="translated">将适用于GraphViz的&amp;ldquo;上标&amp;rdquo;的转储表示形式转储到</target>
        </trans-unit>
        <trans-unit id="09ac4bde087663de0f3a006b963a6f5235611c2d" translate="yes" xml:space="preserve">
          <source>Dump the RTL in the assembler output as a comment before each instruction. Also turns on</source>
          <target state="translated">将汇编器输出中的RTL作为注释在每条指令前倾倒。同时开启</target>
        </trans-unit>
        <trans-unit id="0be5cff07653f79d7c01424690f5d095b8fcbb7d" translate="yes" xml:space="preserve">
          <source>Dump the demangled output.</source>
          <target state="translated">甩掉脱芒的输出。</target>
        </trans-unit>
        <trans-unit id="1726ca951812ad3322375de05b128457cc9a8ced" translate="yes" xml:space="preserve">
          <source>Dump the details of LTO objects.</source>
          <target state="translated">转储LTO对象的详细信息。</target>
        </trans-unit>
        <trans-unit id="171aa9511579073802041f0a2e60b1934e57be91" translate="yes" xml:space="preserve">
          <source>Dump the details of specific symbol.</source>
          <target state="translated">甩出特定符号的细节。</target>
        </trans-unit>
        <trans-unit id="5d265d5ceeb36fc58845a8b5aa258590ef02cc80" translate="yes" xml:space="preserve">
          <source>Dump the final internal representation (RTL) to &lt;var&gt;file&lt;/var&gt;. If the optional argument is omitted (or if &lt;var&gt;file&lt;/var&gt; is &lt;code&gt;.&lt;/code&gt;), the name of the dump file is determined by appending &lt;code&gt;.gkd&lt;/code&gt; to the compilation output file name.</source>
          <target state="translated">转储最终的内部表示（RTL）到 &lt;var&gt;file&lt;/var&gt; 。如果省略了可选参数（或者 &lt;var&gt;file&lt;/var&gt; 为 &lt;code&gt;.&lt;/code&gt; ），则转储文件的名称是通过在编译输出文件名后附加 &lt;code&gt;.gkd&lt;/code&gt; 来确定的。</target>
        </trans-unit>
        <trans-unit id="6290582c1c9788e12ed9d3f73eafdd3bbcd4abf7" translate="yes" xml:space="preserve">
          <source>Dump the raw internal tree data. This option is applicable to C++ only.</source>
          <target state="translated">转储原始内部树数据。这个选项只适用于C++。</target>
        </trans-unit>
        <trans-unit id="1afb37f8221633019abbbb6e4139e775923345d4" translate="yes" xml:space="preserve">
          <source>Dump the specific gimple body.</source>
          <target state="translated">甩开具体的篾片体。</target>
        </trans-unit>
        <trans-unit id="be1097bb2eea2f70c64d4c1cb70ed1c5ba583376" translate="yes" xml:space="preserve">
          <source>Dump the statistics of gimple statements.</source>
          <target state="translated">倾力统计gimple语句。</target>
        </trans-unit>
        <trans-unit id="3a4757ccb92c3f2e13c8881d180d079b3623ccf0" translate="yes" xml:space="preserve">
          <source>Dump the statistics of tree types.</source>
          <target state="translated">对树型进行统计。</target>
        </trans-unit>
        <trans-unit id="1f4cd598ed5041028b59e01e68f001fefceb7ea6" translate="yes" xml:space="preserve">
          <source>Dump the statistics of trees.</source>
          <target state="translated">倾力统计的树木。</target>
        </trans-unit>
        <trans-unit id="3b93daf63f806cdb033463ad6f03043c2e411af3" translate="yes" xml:space="preserve">
          <source>Dump the symbols in order of occurrence.</source>
          <target state="translated">按出现的顺序倾倒符号。</target>
        </trans-unit>
        <trans-unit id="389f264332906b0c1d732e39c64a371de3b149c7" translate="yes" xml:space="preserve">
          <source>Dump the symbols in reverse order.</source>
          <target state="translated">按相反的顺序倾倒符号。</target>
        </trans-unit>
        <trans-unit id="5c09bbbb574ea9794181ca0910564f4164221e71" translate="yes" xml:space="preserve">
          <source>Dumps information about call-graph optimization, unused function removal, and inlining decisions.</source>
          <target state="translated">转储有关调用图优化、未使用的函数删除和内联决策的信息。</target>
        </trans-unit>
        <trans-unit id="3288dac3087a7accf2fa127698249b8034a173fa" translate="yes" xml:space="preserve">
          <source>Dumps list of details of functions and variables.</source>
          <target state="translated">转储函数和变量的细节列表。</target>
        </trans-unit>
        <trans-unit id="c057075d7f6d1311d665f05607d5a1143e726ae5" translate="yes" xml:space="preserve">
          <source>Duplicate instances of a template can be avoided by defining an explicit instantiation in one object file, and preventing the compiler from doing implicit instantiations in any other object files by using an explicit instantiation declaration, using the &lt;code&gt;extern template&lt;/code&gt; syntax:</source>
          <target state="translated">通过在一个目标文件中定义一个显式实例，并使用 &lt;code&gt;extern template&lt;/code&gt; 语法使用显式实例化声明，防止编译器在任何其他目标文件中执行隐式实例，可以避免模板的重复实例：</target>
        </trans-unit>
        <trans-unit id="873001cb1e8e159e206fe4747ed8630083de92b7" translate="yes" xml:space="preserve">
          <source>During its analysis of function bodies, IPA-CP employs alias analysis in order to track values pointed to by function parameters. In order not spend too much time analyzing huge functions, it gives up and consider all memory clobbered after examining</source>
          <target state="translated">在分析函数体的过程中,IPA-CP采用了别名分析,以跟踪函数参数所指向的值。为了不花太多时间分析庞大的函数,它在检查完之后就放弃了,认为所有的内存都被抢光了。</target>
        </trans-unit>
        <trans-unit id="35ad8603f50d24cddaa26acc281e43114f0f03d6" translate="yes" xml:space="preserve">
          <source>During the incremental link (by</source>
          <target state="translated">在增量环节(由</target>
        </trans-unit>
        <trans-unit id="6e5d8e172227784c44cef25322c1d84b5b1ed089" translate="yes" xml:space="preserve">
          <source>During the link-time optimization warn about type mismatches in global declarations from different compilation units. Requires</source>
          <target state="translated">在链接时间优化期间,警告来自不同编译单元的全局声明的类型不匹配。需要</target>
        </trans-unit>
        <trans-unit id="3941436ae2dc30b7d71f0708c7f73c50626caec3" translate="yes" xml:space="preserve">
          <source>During the link-time optimization, do not warn about type mismatches in global declarations from different compilation units. Requires</source>
          <target state="translated">在链接时的优化过程中,不要对来自不同编译单元的全局声明的类型不匹配发出警告。要求</target>
        </trans-unit>
        <trans-unit id="1ed8a7568d4927beb8ca9fcc2f434426a2ed3775" translate="yes" xml:space="preserve">
          <source>Dynamic rounding mode. A field in the floating-point control register (&lt;var&gt;fpcr&lt;/var&gt;, see Alpha architecture reference manual) controls the rounding mode in effect. The C library initializes this register for rounding towards plus infinity. Thus, unless your program modifies the &lt;var&gt;fpcr&lt;/var&gt;, &amp;lsquo;</source>
          <target state="translated">动态舍入模式。浮点控制寄存器（ &lt;var&gt;fpcr&lt;/var&gt; ，请参见Alpha体系结构参考手册）中的字段控制有效的舍入模式。C库初始化此寄存器以使其向加无穷大舍入。因此，除非您的程序修改了 &lt;var&gt;fpcr&lt;/var&gt; ，</target>
        </trans-unit>
        <trans-unit id="ee61e1d4359d2101e0207f1f6ab138bc105fa253" translate="yes" xml:space="preserve">
          <source>Dynamically allocate condition code registers.</source>
          <target state="translated">动态分配条件代码寄存器。</target>
        </trans-unit>
        <trans-unit id="e0184adedf913b076626646d3f52c3b49c39ad6d" translate="yes" xml:space="preserve">
          <source>E</source>
          <target state="translated">E</target>
        </trans-unit>
        <trans-unit id="8424e737649ba7f5ce9529e01136274dd622c253" translate="yes" xml:space="preserve">
          <source>E+</source>
          <target state="translated">E+</target>
        </trans-unit>
        <trans-unit id="b86bd135c70e92d6b2051a988af8d8fd3b21cb67" translate="yes" xml:space="preserve">
          <source>E-</source>
          <target state="translated">E-</target>
        </trans-unit>
        <trans-unit id="fa4a7a170f7075560c98a976572cae386b13a240" translate="yes" xml:space="preserve">
          <source>E.g.</source>
          <target state="translated">E.g.</target>
        </trans-unit>
        <trans-unit id="180b58cf69b13102962b17f297dd40af5fac3b7a" translate="yes" xml:space="preserve">
          <source>EAM register &lt;code&gt;mdb&lt;/code&gt;</source>
          <target state="translated">EAM寄存器 &lt;code&gt;mdb&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4183eec55a2657bd56f5a3f286167e22c41277ca" translate="yes" xml:space="preserve">
          <source>EAM register &lt;code&gt;mdc&lt;/code&gt;</source>
          <target state="translated">EAM寄存器 &lt;code&gt;mdc&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="042b890a506cb1f86b057af9f2065c60f0543326" translate="yes" xml:space="preserve">
          <source>ESC</source>
          <target state="translated">ESC</target>
        </trans-unit>
        <trans-unit id="db3a4c6dcbc964f457aa623cff604baca1fe6abf" translate="yes" xml:space="preserve">
          <source>ESC \</source>
          <target state="translated">ESC</target>
        </trans-unit>
        <trans-unit id="ef29ed353f79614b0af0aa06877e0e8365ad41a3" translate="yes" xml:space="preserve">
          <source>EV</source>
          <target state="translated">EV</target>
        </trans-unit>
        <trans-unit id="8404c13b819cbc829893e6fcf7e6b011dc8afafa" translate="yes" xml:space="preserve">
          <source>EXEC register (EXEC_LO and EXEC_HI)</source>
          <target state="translated">EXEC 寄存器 (EXEC_LO 和 EXEC_HI)</target>
        </trans-unit>
        <trans-unit id="3633746b067241666bc462dcfe7a24ff23a8db68" translate="yes" xml:space="preserve">
          <source>Each</source>
          <target state="translated">Each</target>
        </trans-unit>
        <trans-unit id="ec76a07122ba99b0a9685803ebd0fcbd4bc2bfc8" translate="yes" xml:space="preserve">
          <source>Each &amp;lsquo;</source>
          <target state="translated">每个'</target>
        </trans-unit>
        <trans-unit id="7a238e89c65aac1db813f790141cd6a1706499a7" translate="yes" xml:space="preserve">
          <source>Each &lt;var&gt;branch&lt;/var&gt; has the following form:</source>
          <target state="translated">每个 &lt;var&gt;branch&lt;/var&gt; 具有以下形式：</target>
        </trans-unit>
        <trans-unit id="3994e33e5e0917632f9e9de329b4a0f3ad3998af" translate="yes" xml:space="preserve">
          <source>Each &lt;var&gt;file&lt;/var&gt; has the following form:</source>
          <target state="translated">每个 &lt;var&gt;file&lt;/var&gt; 具有以下形式：</target>
        </trans-unit>
        <trans-unit id="c75857c9773e24edc3bfc44893ae2b0b910e079d" translate="yes" xml:space="preserve">
          <source>Each &lt;var&gt;function&lt;/var&gt; has the following form:</source>
          <target state="translated">每个 &lt;var&gt;function&lt;/var&gt; 具有以下形式：</target>
        </trans-unit>
        <trans-unit id="62acae4631fd900e861a22b9b523800b0a789662" translate="yes" xml:space="preserve">
          <source>Each &lt;var&gt;line&lt;/var&gt; has the following form:</source>
          <target state="translated">每 &lt;var&gt;line&lt;/var&gt; 具有以下形式：</target>
        </trans-unit>
        <trans-unit id="1c50fb88397b0c7346926cd4cd765575f7023e36" translate="yes" xml:space="preserve">
          <source>Each architecture defines additional constraints. These constraints are used by the compiler itself for instruction generation, as well as for &lt;code&gt;asm&lt;/code&gt; statements; therefore, some of the constraints are not particularly useful for &lt;code&gt;asm&lt;/code&gt;. Here is a summary of some of the machine-dependent constraints available on some particular machines; it includes both constraints that are useful for &lt;code&gt;asm&lt;/code&gt; and constraints that aren&amp;rsquo;t. The compiler source file mentioned in the table heading for each architecture is the definitive reference for the meanings of that architecture&amp;rsquo;s constraints.</source>
          <target state="translated">每种体系结构都定义了其他约束。这些约束由编译器本身用于指令生成以及 &lt;code&gt;asm&lt;/code&gt; 语句。因此，某些约束对于 &lt;code&gt;asm&lt;/code&gt; 并不是特别有用。这是某些特定机器上可用的一些与机器有关的约束的摘要。它既包括对 &lt;code&gt;asm&lt;/code&gt; 有用的约束，又包括对asm无用的约束。表标题中针对每种体系结构提到的编译器源文件是该体系结构约束含义的权威参考。</target>
        </trans-unit>
        <trans-unit id="9a8f7e527e362e2f465669113fa77cfedd4d35d0" translate="yes" xml:space="preserve">
          <source>Each argument to the macro appears only once in the expansion of the macro. This prevents the size of the macro expansion growing exponentially when calls to such macros are nested inside arguments of such macros.</source>
          <target state="translated">宏的每个参数在宏的扩展中只出现一次。这就防止了当对这类宏的调用嵌套在这类宏的参数内时,宏扩展的大小成倍增长。</target>
        </trans-unit>
        <trans-unit id="76b41f32117ccc7bbc36f4b00ab7cb610cec2b62" translate="yes" xml:space="preserve">
          <source>Each argument, with the type encoding, followed by the offset (in bytes) of the argument in the list of parameters.</source>
          <target state="translated">每个参数,都有类型编码,后面是参数在参数列表中的偏移量(单位:字节)。</target>
        </trans-unit>
        <trans-unit id="e6b2353f285a19086a3e061a5dcfed498d63a240" translate="yes" xml:space="preserve">
          <source>Each identifier is visible from where it is declared until the end of the enclosing block.</source>
          <target state="translated">每一个标识符从它被声明的地方开始就可见,直到包围块的最后。</target>
        </trans-unit>
        <trans-unit id="01e3221d2b21a8f447ed5a0ced29ddbea2cbee30" translate="yes" xml:space="preserve">
          <source>Each implementation shall include documentation that identifies all conditionally-supported constructs that it does not support (C++0x 1.4).</source>
          <target state="translated">每个实现都应包含文档,以确定它不支持的所有有条件支持的构造(C++0x 1.4)。</target>
        </trans-unit>
        <trans-unit id="701d795fb8ee42f93e3f4a253aa01935ee62e44d" translate="yes" xml:space="preserve">
          <source>Each kind of machine has a default for what &lt;code&gt;char&lt;/code&gt; should be. It is either like &lt;code&gt;unsigned char&lt;/code&gt; by default or like &lt;code&gt;signed char&lt;/code&gt; by default.</source>
          <target state="translated">每种机器都有默认的 &lt;code&gt;char&lt;/code&gt; 字符。默认情况下，它就像 &lt;code&gt;unsigned char&lt;/code&gt; ，或者默认情况下像 &lt;code&gt;signed char&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ef05478f4365f65d0ddfa7b0d492a5a495d01714" translate="yes" xml:space="preserve">
          <source>Each of the following options must be the same when building and using the precompiled header:</source>
          <target state="translated">在构建和使用预编译头时,以下每个选项必须是相同的。</target>
        </trans-unit>
        <trans-unit id="12375fa3bc94216fddfb3082e628f5277fd37349" translate="yes" xml:space="preserve">
          <source>Each of these represents a register constraint for an individual register, from r0 to r10.</source>
          <target state="translated">每一个都代表了一个单独寄存器的寄存器约束,从r0到r10。</target>
        </trans-unit>
        <trans-unit id="c7c856c52d5df36a325270b79c39dbe4777d924c" translate="yes" xml:space="preserve">
          <source>Each target machine supported by GCC can have its own options&amp;mdash;for example, to allow you to compile for a particular processor variant or ABI, or to control optimizations specific to that machine. By convention, the names of machine-specific options start with &amp;lsquo;</source>
          <target state="translated">GCC支持的每个目标计算机都可以有其自己的选项，例如，允许您针对特定的处理器变体或ABI进行编译，或控制特定于该计算机的优化。按照惯例，特定于计算机的选项的名称以'</target>
        </trans-unit>
        <trans-unit id="e1bf5c8e09d672f359406f3ca337be92c84db460" translate="yes" xml:space="preserve">
          <source>Each variable&amp;rsquo;s value is a list of directories separated by a special character, much like &lt;code&gt;PATH&lt;/code&gt;, in which to look for header files. The special character, &lt;code&gt;PATH_SEPARATOR&lt;/code&gt;, is target-dependent and determined at GCC build time. For Microsoft Windows-based targets it is a semicolon, and for almost all other targets it is a colon.</source>
          <target state="translated">每个变量的值都是用特殊字符分隔的目录列表，类似于 &lt;code&gt;PATH&lt;/code&gt; ，在其中查找头文件。特殊字符 &lt;code&gt;PATH_SEPARATOR&lt;/code&gt; 取决于目标，并在GCC构建时确定。对于基于Microsoft Windows的目标，它是一个分号，对于几乎所有其他目标，它是一个冒号。</target>
        </trans-unit>
        <trans-unit id="9fc7669bba8b360ced14bcd0e63ab75ab5c8df7f" translate="yes" xml:space="preserve">
          <source>Embedded statements are not allowed in constant expressions, such as the value of an enumeration constant, the width of a bit-field, or the initial value of a static variable.</source>
          <target state="translated">在常量表达式中不允许嵌入语句,如枚举常量的值、位域的宽度或静态变量的初始值。</target>
        </trans-unit>
        <trans-unit id="948e9b48ea593e051a4153362a7090d684f2c222" translate="yes" xml:space="preserve">
          <source>Emit (do not emit) RISC-V attribute to record extra information into ELF objects. This feature requires at least binutils 2.32.</source>
          <target state="translated">发射(不发射)RISC-V属性,将额外信息记录到ELF对象中。这个功能至少需要 binutils 2.32。</target>
        </trans-unit>
        <trans-unit id="070ac08031f3d1c435e4576ba37695a82ca0786d" translate="yes" xml:space="preserve">
          <source>Emit (do not emit) code that allows &lt;code&gt;_mcount&lt;/code&gt; to modify the calling function&amp;rsquo;s return address. When enabled, this option extends the usual &lt;code&gt;_mcount&lt;/code&gt; interface with a new &lt;var&gt;ra-address&lt;/var&gt; parameter, which has type &lt;code&gt;intptr_t *&lt;/code&gt; and is passed in register &lt;code&gt;$12&lt;/code&gt;. &lt;code&gt;_mcount&lt;/code&gt; can then modify the return address by doing both of the following:</source>
          <target state="translated">发出（不发出）允许 &lt;code&gt;_mcount&lt;/code&gt; 修改调用函数的返回地址的代码。启用后，此选项将使用新的 &lt;var&gt;ra-address&lt;/var&gt; 参数扩展常规 &lt;code&gt;_mcount&lt;/code&gt; 接口，该参数的类型为 &lt;code&gt;intptr_t *&lt;/code&gt; 并在寄存器 &lt;code&gt;$12&lt;/code&gt; 传递。 &lt;code&gt;_mcount&lt;/code&gt; 然后可以通过执行以下两个操作来修改返回地址：</target>
        </trans-unit>
        <trans-unit id="ff5e30537593e35e64b6a16b2c1bdbe42c087863" translate="yes" xml:space="preserve">
          <source>Emit .gnu_attribute assembly directives to set tag/value pairs in a .gnu.attributes section that specify ABI variations in function parameters or return values.</source>
          <target state="translated">发出.gnu_attribute汇编指令,在.gnu.attribute部分设置标签/值对,指定函数参数或返回值的ABI变化。</target>
        </trans-unit>
        <trans-unit id="20bf9a915993aa5a7a1666c72b879d8cd3f7ac3e" translate="yes" xml:space="preserve">
          <source>Emit &lt;code&gt;.stack_size&lt;/code&gt; directives for each function in the assembly output. This option defaults to off.</source>
          <target state="translated">在程序集输出中为每个函数发出 &lt;code&gt;.stack_size&lt;/code&gt; 指令。此选项默认为关闭。</target>
        </trans-unit>
        <trans-unit id="2f04fa21301da1a9e382b512bcad8e362a751619" translate="yes" xml:space="preserve">
          <source>Emit &lt;code&gt;static&lt;/code&gt; functions into the object file, even if the function is never used.</source>
          <target state="translated">将 &lt;code&gt;static&lt;/code&gt; 函数发送到目标文件中，即使从未使用过该函数也是如此。</target>
        </trans-unit>
        <trans-unit id="cb38e0a4e398a1b8eae664d56e6c229db862f612" translate="yes" xml:space="preserve">
          <source>Emit &lt;var&gt;num&lt;/var&gt; NOPs before every other generated instruction.</source>
          <target state="translated">在每隔一条生成的指令之前发出 &lt;var&gt;num&lt;/var&gt; NOP。</target>
        </trans-unit>
        <trans-unit id="3da3562e4f5b4b2c349aec3c276d4ecf1abb3a7e" translate="yes" xml:space="preserve">
          <source>Emit DWARF unwind info as compiler generated &lt;code&gt;.eh_frame&lt;/code&gt; section instead of using GAS &lt;code&gt;.cfi_*&lt;/code&gt; directives.</source>
          <target state="translated">将DWARF展开信息作为编译器生成的 &lt;code&gt;.eh_frame&lt;/code&gt; 节而不是使用GAS &lt;code&gt;.cfi_*&lt;/code&gt; 指令发送。</target>
        </trans-unit>
        <trans-unit id="661cfa361d4a5be25ea38381adeec0544f3162ba" translate="yes" xml:space="preserve">
          <source>Emit a special marker instructing &lt;code&gt;ld(1)&lt;/code&gt; not to statically link in the resulting object file, and allow &lt;code&gt;dyld(1)&lt;/code&gt; to load it in at run time instead. This is used in conjunction with the Fix-and-Continue debugging mode, where the object file in question may be recompiled and dynamically reloaded in the course of program execution, without the need to restart the program itself. Currently, Fix-and-Continue functionality is only available in conjunction with the NeXT runtime on Mac OS X 10.3 and later.</source>
          <target state="translated">发出一个特殊的标记，指示 &lt;code&gt;ld(1)&lt;/code&gt; 不要静态链接到生成的目标文件中，并允许 &lt;code&gt;dyld(1)&lt;/code&gt; 在运行时加载它。这与&amp;ldquo;修复并继续&amp;rdquo;调试模式结合使用，在该模式下，可以在程序执行过程中重新编译并动态重新加载所讨论的目标文件，而无需重新启动程序本身。目前，&amp;ldquo;修复并继续&amp;rdquo;功能仅可与Mac OS X 10.3及更高版本上的NeXT运行时结合使用。</target>
        </trans-unit>
        <trans-unit id="7e8645e36e17a7945813986a8d0a71d3821820d0" translate="yes" xml:space="preserve">
          <source>Emit a warning if the current function exceeds the given frame size. Because this is a compile-time check it doesn&amp;rsquo;t need to be a real problem when the program runs. It is intended to identify functions that most probably cause a stack overflow. It is useful to be used in an environment with limited stack size e.g. the linux kernel.</source>
          <target state="translated">如果当前功能超出给定的帧大小，则发出警告。因为这是编译时检查，所以在程序运行时并不一定是真正的问题。它旨在确定最有可能导致堆栈溢出的功能。在堆栈大小有限的环境中使用该功能很有用，例如linux内核。</target>
        </trans-unit>
        <trans-unit id="e60a4bf4bc37e66d9947816b7195c8391e4776d0" translate="yes" xml:space="preserve">
          <source>Emit a warning if the function calls &lt;code&gt;alloca&lt;/code&gt; or uses dynamically-sized arrays. This is generally a bad idea with a limited stack size.</source>
          <target state="translated">如果函数调用 &lt;code&gt;alloca&lt;/code&gt; 或使用动态大小的数组，则发出警告。通常，在堆栈大小有限的情况下，这是一个坏主意。</target>
        </trans-unit>
        <trans-unit id="9b489883dd494ef67ae3146bb7729487672712a9" translate="yes" xml:space="preserve">
          <source>Emit callgraph information.</source>
          <target state="translated">发出调用信息。</target>
        </trans-unit>
        <trans-unit id="f2b5ec1d50c73d9342d0da2e8de77ea3e8b06bfb" translate="yes" xml:space="preserve">
          <source>Emit debug information for struct-like types only when the base name of the compilation source file matches the base name of file in which the struct is defined.</source>
          <target state="translated">只有当编译源文件的基名与定义结构体的文件基名一致时,才会发出类结构体类型的调试信息。</target>
        </trans-unit>
        <trans-unit id="ea8ad7a3ce89000c68597a212e3b7e178630bf37" translate="yes" xml:space="preserve">
          <source>Emit debug information for struct-like types only when the base name of the compilation source file matches the base name of file in which the type is defined, unless the struct is a template or defined in a system header.</source>
          <target state="translated">只有当编译源文件的基名与定义该类型的文件基名一致时,才会发出类结构类型的调试信息,除非该结构是模板或定义在系统头中。</target>
        </trans-unit>
        <trans-unit id="bcf9409c139607d0741250959d86960d9d3fc823" translate="yes" xml:space="preserve">
          <source>Emit debugging information for all symbols and types.</source>
          <target state="translated">发出所有符号和类型的调试信息。</target>
        </trans-unit>
        <trans-unit id="8a7c3f8e8609e257b077878b6041fc34297f5e52" translate="yes" xml:space="preserve">
          <source>Emit debugging information for symbols that are used. For stabs debugging format, this enables</source>
          <target state="translated">发出使用的符号的调试信息。对于stabs的调试格式,这可以使</target>
        </trans-unit>
        <trans-unit id="c7be7022731d1d4e89f739d3f084947002265870" translate="yes" xml:space="preserve">
          <source>Emit diagnostics showing where nodes in the &amp;ldquo;exploded graph&amp;rdquo; are in relation to the program source.</source>
          <target state="translated">发出诊断信息，以显示&amp;ldquo;爆炸图&amp;rdquo;中的节点相对于程序源的位置。</target>
        </trans-unit>
        <trans-unit id="b01323833aaf7728ad582d052fc8f41810ddeadf" translate="yes" xml:space="preserve">
          <source>Emit extra code to check for buffer overflows, such as stack smashing attacks. This is done by adding a guard variable to functions with vulnerable objects. This includes functions that call &lt;code&gt;alloca&lt;/code&gt;, and functions with buffers larger than 8 bytes. The guards are initialized when a function is entered and then checked when the function exits. If a guard check fails, an error message is printed and the program exits.</source>
          <target state="translated">发出额外的代码以检查缓冲区溢出，例如堆栈破坏攻击。这是通过向具有易受攻击对象的函数添加一个保护变量来完成的。这包括调用 &lt;code&gt;alloca&lt;/code&gt; 的函数以及缓冲区大于8个字节的函数。在进入功能时初始化防护，然后在功能退出时检查。如果防护检查失败，则会显示一条错误消息并退出程序。</target>
        </trans-unit>
        <trans-unit id="0b4704d417754dd3e2fa8536b703ca97736ecd33" translate="yes" xml:space="preserve">
          <source>Emit extra code to check for buffer overflows, such as stack smashing attacks. This is done by adding a guard variable to functions with vulnerable objects. This includes functions that call &lt;code&gt;alloca&lt;/code&gt;, and functions with buffers larger than or equal to 8 bytes. The guards are initialized when a function is entered and then checked when the function exits. If a guard check fails, an error message is printed and the program exits. Only variables that are actually allocated on the stack are considered, optimized away variables or variables allocated in registers don&amp;rsquo;t count.</source>
          <target state="translated">发出额外的代码以检查缓冲区溢出，例如堆栈破坏攻击。这是通过向具有易受攻击对象的函数添加一个保护变量来完成的。这包括调用 &lt;code&gt;alloca&lt;/code&gt; 的函数以及缓冲区大于或等于8个字节的函数。在进入功能时初始化防护，然后在功能退出时检查。如果防护检查失败，则会打印一条错误消息，并退出程序。仅考虑实际分配在堆栈上的变量，优化后的变量或寄存器中分配的变量不计算在内。</target>
        </trans-unit>
        <trans-unit id="141c4b8396ef386665e92dca002cbfbddd934501" translate="yes" xml:space="preserve">
          <source>Emit fix-it hints in a machine-parseable format, suitable for consumption by IDEs. For each fix-it, a line will be printed after the relevant diagnostic, starting with the string &amp;ldquo;fix-it:&amp;rdquo;. For example:</source>
          <target state="translated">以机器可解析的格式发出修复提示，适合IDE使用。对于每个修复程序，将在相关诊断后打印一行，以字符串&amp;ldquo; fix-it：&amp;rdquo;开头。例如：</target>
        </trans-unit>
        <trans-unit id="1a5a47bca88794809e7e2a3bb7e287c60614c83b" translate="yes" xml:space="preserve">
          <source>Emit function prologues only before parts of the function that need it, rather than at the top of the function. This flag is enabled by default at</source>
          <target state="translated">只在需要函数序言的部分之前,而不是在函数的顶部,才会发出函数序言。这个标志默认在</target>
        </trans-unit>
        <trans-unit id="7a29575e26772eb5ddc3404ae8049245b33348e5" translate="yes" xml:space="preserve">
          <source>Emit location column information into DWARF debugging information, rather than just file and line. This option is enabled by default.</source>
          <target state="translated">在DWARF调试信息中输入位置列信息,而不仅仅是文件和行。该选项默认为启用。</target>
        </trans-unit>
        <trans-unit id="669b4b85cda6e8d55a22a680d295c7c66356a584" translate="yes" xml:space="preserve">
          <source>Emit perf-like colored output for hot lines. Legend of the color scale is printed at the very beginning of the output file.</source>
          <target state="translated">发出类似敷衍的彩色输出,用于热线。在输出文件的开头打印色标的图例。</target>
        </trans-unit>
        <trans-unit id="bf88babe6e871b26c963f43a03a560a58bbbd726" translate="yes" xml:space="preserve">
          <source>Emit statistics about front-end processing at the end of the compilation. This option is supported only by the C++ front end, and the information is generally only useful to the G++ development team.</source>
          <target state="translated">在编译结束时发出有关前端处理的统计信息。这个选项只有C++前端支持,这些信息一般只对G++开发团队有用。</target>
        </trans-unit>
        <trans-unit id="986149807dd103440d26581e0c8034fe654a931b" translate="yes" xml:space="preserve">
          <source>Emit variables declared &lt;code&gt;static const&lt;/code&gt; when optimization isn&amp;rsquo;t turned on, even if the variables aren&amp;rsquo;t referenced.</source>
          <target state="translated">在未启用优化的情况下，即使未引用变量，也要发出声明为 &lt;code&gt;static const&lt;/code&gt; 的变量。</target>
        </trans-unit>
        <trans-unit id="7039662b9ecdfee8f51909b1bca797f2d5646847" translate="yes" xml:space="preserve">
          <source>Empty. Empty attributes are ignored.</source>
          <target state="translated">空。空属性被忽略。</target>
        </trans-unit>
        <trans-unit id="dee5764f5fbac8ea9eadf819b59721dd60ce4b7b" translate="yes" xml:space="preserve">
          <source>En_US</source>
          <target state="translated">En_US</target>
        </trans-unit>
        <trans-unit id="20063ad9053289cecaa20ae630ed2dd758282a07" translate="yes" xml:space="preserve">
          <source>Enable</source>
          <target state="translated">Enable</target>
        </trans-unit>
        <trans-unit id="4fa0f6fb6e440f220b80c6c2d4888a44c80062d9" translate="yes" xml:space="preserve">
          <source>Enable &amp;lsquo;</source>
          <target state="translated">启用&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="e92d7b5eafccf1d9c2c8bae0da3467a97bfe43eb" translate="yes" xml:space="preserve">
          <source>Enable (disable) an optimization that pairs consecutive load or store instructions to enable load/store bonding. This option is enabled by default but only takes effect when the selected architecture is known to support bonding.</source>
          <target state="translated">启用(禁用)一项优化,将连续的加载或存储指令配对以启用加载/存储绑定。该选项默认为启用,但只有在已知所选架构支持绑定时才会生效。</target>
        </trans-unit>
        <trans-unit id="a5876c1f4b70b8a6258f54ff9e4b48ce21c8e2cc" translate="yes" xml:space="preserve">
          <source>Enable (disable) frame header optimization in the o32 ABI. When using the o32 ABI, calling functions will allocate 16 bytes on the stack for the called function to write out register arguments. When enabled, this optimization will suppress the allocation of the frame header if it can be determined that it is unused.</source>
          <target state="translated">在o32 ABI中启用(禁用)帧头优化。当使用o32 ABI时,调用函数将在堆栈上分配16个字节供被调用函数写出寄存器参数。当启用时,如果可以确定帧头未被使用,该优化将抑制帧头的分配。</target>
        </trans-unit>
        <trans-unit id="69fa958a8a2e61f2783ede1c3821c1af600c12f1" translate="yes" xml:space="preserve">
          <source>Enable (disable) generation of &lt;code&gt;synci&lt;/code&gt; instructions on architectures that support it. The &lt;code&gt;synci&lt;/code&gt; instructions (if enabled) are generated when &lt;code&gt;__builtin___clear_cache&lt;/code&gt; is compiled.</source>
          <target state="translated">在支持它的体系结构上启用（禁用） &lt;code&gt;synci&lt;/code&gt; 指令的生成。该 &lt;code&gt;synci&lt;/code&gt; 当指令（如果启用）产生 &lt;code&gt;__builtin___clear_cache&lt;/code&gt; 编译。</target>
        </trans-unit>
        <trans-unit id="affa7a90abe6524cdcc085355a0cf87de25de669" translate="yes" xml:space="preserve">
          <source>Enable (disable) the use of the built-in functions that allow direct access to the Hardware Transactional Memory (HTM) instructions that were added in version 2.07 of the PowerPC ISA.</source>
          <target state="translated">启用(禁用)使用内置功能,允许直接访问PowerPC ISA 2.07版本中添加的硬件事务性内存(HTM)指令。</target>
        </trans-unit>
        <trans-unit id="a9d43112761b398944fa6b8aebeadd62b27a6873" translate="yes" xml:space="preserve">
          <source>Enable (disable) use of the &lt;code&gt;%hi()&lt;/code&gt; and &lt;code&gt;%lo()&lt;/code&gt; assembler relocation operators. This option has been superseded by</source>
          <target state="translated">启用（禁用） &lt;code&gt;%hi()&lt;/code&gt; 和 &lt;code&gt;%lo()&lt;/code&gt; 汇编器重定位运算符的使用。此选项已被取代</target>
        </trans-unit>
        <trans-unit id="22e717c26fa88a4531e1982fba5a0708a2d39b81" translate="yes" xml:space="preserve">
          <source>Enable (disable) use of the &lt;code&gt;mad&lt;/code&gt;, &lt;code&gt;madu&lt;/code&gt; and &lt;code&gt;mul&lt;/code&gt; instructions, as provided by the R4650 ISA.</source>
          <target state="translated">启用（禁用）R4650 ISA提供的 &lt;code&gt;mad&lt;/code&gt; ， &lt;code&gt;madu&lt;/code&gt; 和 &lt;code&gt;mul&lt;/code&gt; 指令的使用。</target>
        </trans-unit>
        <trans-unit id="d7e0884ba3d3cc932c864d47a1ad9e75ce9d3f27" translate="yes" xml:space="preserve">
          <source>Enable (disable) use of the &lt;code&gt;madd&lt;/code&gt; and &lt;code&gt;msub&lt;/code&gt; integer instructions. The default is</source>
          <target state="translated">启用（禁用） &lt;code&gt;madd&lt;/code&gt; 和 &lt;code&gt;msub&lt;/code&gt; 整数指令。默认是</target>
        </trans-unit>
        <trans-unit id="fb69f64525577d36a129060c4be04db4c7157197" translate="yes" xml:space="preserve">
          <source>Enable (disable) use of the floating-point multiply-accumulate instructions, when they are available. The default is</source>
          <target state="translated">当浮点乘法累加指令可用时,启用(禁用)这些指令。默认值是</target>
        </trans-unit>
        <trans-unit id="b555e3f0b555bfa87127103aa19a5b771c06eb1e" translate="yes" xml:space="preserve">
          <source>Enable 32-bit Floating point Matrix Multiply instructions. This also enables SVE instructions. Use of this option with architectures prior to Armv8.2-A is not supported.</source>
          <target state="translated">启用32位浮点矩阵乘法指令。这也可以启用SVE指令。不支持在Armv8.2-A之前的架构中使用该选项。</target>
        </trans-unit>
        <trans-unit id="a72dea94649019bb860dd9ef3c4021f60f45fa32" translate="yes" xml:space="preserve">
          <source>Enable 64-bit AIX ABI and calling convention: 64-bit pointers, 64-bit &lt;code&gt;long&lt;/code&gt; type, and the infrastructure needed to support them. Specifying</source>
          <target state="translated">启用64位AIX ABI和调用约定：64位指针，64位 &lt;code&gt;long&lt;/code&gt; 类型以及支持它们的基础结构。指定</target>
        </trans-unit>
        <trans-unit id="7b3c726da78dba7ee2a5726b767895d7cdc32731" translate="yes" xml:space="preserve">
          <source>Enable 64-bit Floating point Matrix Multiply instructions. This also enables SVE instructions. Use of this option with architectures prior to Armv8.2-A is not supported.</source>
          <target state="translated">启用64位浮点矩阵乘法指令。这也可以启用SVE指令。不支持在Armv8.2-A之前的架构中使用该选项。</target>
        </trans-unit>
        <trans-unit id="6ded79f10cf70cf5831bdeffd10c676f4e368113" translate="yes" xml:space="preserve">
          <source>Enable 8-bit Integer Matrix Multiply instructions. This also enables Advanced SIMD and floating-point instructions. This option is enabled by default for</source>
          <target state="translated">启用8位整数矩阵乘法指令。这也启用了高级SIMD和浮点指令。该选项默认为以下指令启用</target>
        </trans-unit>
        <trans-unit id="e8bed769cd5303c03eac96915f98c0018f45868e" translate="yes" xml:space="preserve">
          <source>Enable &lt;code&gt;div&lt;/code&gt; and &lt;code&gt;rem&lt;/code&gt; instructions for ARCv2 cores.</source>
          <target state="translated">启用ARCv2内核的 &lt;code&gt;div&lt;/code&gt; 和 &lt;code&gt;rem&lt;/code&gt; 指令。</target>
        </trans-unit>
        <trans-unit id="2b739befdde9d37b726baa741659e214041a11f0" translate="yes" xml:space="preserve">
          <source>Enable AddressSanitizer for Linux kernel. See &lt;a href=&quot;https://github.com/google/kasan/wiki&quot;&gt;https://github.com/google/kasan/wiki&lt;/a&gt; for more details.</source>
          <target state="translated">为Linux内核启用AddressSanitizer。有关更多详细信息，请参见&lt;a href=&quot;https://github.com/google/kasan/wiki&quot;&gt;https://github.com/google/kasan/wiki&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="dd5750bb548742f5f6797880a8c614d311fe2963" translate="yes" xml:space="preserve">
          <source>Enable AddressSanitizer, a fast memory error detector. Memory access instructions are instrumented to detect out-of-bounds and use-after-free bugs. The option enables</source>
          <target state="translated">启用快速内存错误检测器AddressSanitizer。对内存访问指令进行检测,以检测越界和使用后的错误。该选项可以启用</target>
        </trans-unit>
        <trans-unit id="b884f9df2c0fdf875f501de19eb4a43163aded4e" translate="yes" xml:space="preserve">
          <source>Enable Advanced SIMD instructions. This also enables floating-point instructions. This is on by default for all possible values for options</source>
          <target state="translated">启用高级SIMD指令。这也启用了浮点指令。对于选项的所有可能值,默认为开启</target>
        </trans-unit>
        <trans-unit id="1737ee87e4af9d47c80e040e08ffbf40c4cf4499" translate="yes" xml:space="preserve">
          <source>Enable C-SKY DSP, Enhanced DSP, or Vector DSP instructions, respectively. All of these options default to off.</source>
          <target state="translated">分别启用C-SKY DSP、Enhanced DSP或Vector DSP指令。所有这些选项都默认为关闭。</target>
        </trans-unit>
        <trans-unit id="460dd2625e669a6da5fd8971a359142b70341354" translate="yes" xml:space="preserve">
          <source>Enable C-SKY security instructions; the default is off.</source>
          <target state="translated">启用C-SKY安全指令,默认为关闭。</target>
        </trans-unit>
        <trans-unit id="be1993c993457eac4e123ff5ca8683dff8eb6707" translate="yes" xml:space="preserve">
          <source>Enable C-SKY trust instructions; the default is off.</source>
          <target state="translated">启用C-SKY信任指令,默认为关闭。</target>
        </trans-unit>
        <trans-unit id="db19cd91956a3cc7c7ec589751c003754ab24a04" translate="yes" xml:space="preserve">
          <source>Enable CFG-sensitive rematerialization in LRA. Instead of loading values of spilled pseudos, LRA tries to rematerialize (recalculate) values if it is profitable.</source>
          <target state="translated">在LRA中启用对CFG敏感的再材料化。如果有利可图,LRA会尝试重新材料化(重新计算),而不是加载溢出的伪值。</target>
        </trans-unit>
        <trans-unit id="3228c63b76a89731a999face742dbc8e98e43fb7" translate="yes" xml:space="preserve">
          <source>Enable CRC extension. This is on by default for</source>
          <target state="translated">启用CRC扩展。默认情况下,这对于</target>
        </trans-unit>
        <trans-unit id="6f57bb69abaacf2d80f6a8ad9ba44e14d8d03b75" translate="yes" xml:space="preserve">
          <source>Enable CRIS-specific verbose debug-related information in the assembly code. This option also has the effect of turning off the &amp;lsquo;</source>
          <target state="translated">在汇编代码中启用特定于CRIS的详细调试相关信息。此选项还具有关闭&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="a77b829448e4eeb6288384fb17669c5c039a4b5e" translate="yes" xml:space="preserve">
          <source>Enable Crypto extension. This also enables Advanced SIMD and floating-point instructions.</source>
          <target state="translated">启用Crypto扩展。这也可以启用高级SIMD和浮点指令。</target>
        </trans-unit>
        <trans-unit id="c34f6f6c7e11aa9f0332985736de3e72e193f5ba" translate="yes" xml:space="preserve">
          <source>Enable FP16 extension. This also enables floating-point instructions.</source>
          <target state="translated">启用FP16扩展。这也可以启用浮点指令。</target>
        </trans-unit>
        <trans-unit id="2babb7d5abaf4060eeca52d7ae4316df315816d6" translate="yes" xml:space="preserve">
          <source>Enable FP16 fmla extension. This also enables FP16 extensions and floating-point instructions. This option is enabled by default for</source>
          <target state="translated">启用FP16 fmla扩展。这也启用了FP16扩展和浮点指令。该选项默认为</target>
        </trans-unit>
        <trans-unit id="3a8ba9a41b704d15493ebc76a0b1f017540a81f2" translate="yes" xml:space="preserve">
          <source>Enable IPA pass &lt;var&gt;pass&lt;/var&gt;. &lt;var&gt;pass&lt;/var&gt; is the pass name. If the same pass is statically invoked in the compiler multiple times, the pass name should be appended with a sequential number starting from 1.</source>
          <target state="translated">启用IPA pass &lt;var&gt;pass&lt;/var&gt; 。 &lt;var&gt;pass&lt;/var&gt; 是通过名称。如果在编译器中多次静态调用同一遍，则遍历名称应附加从1开始的序列号。</target>
        </trans-unit>
        <trans-unit id="17d5ca6696a8cdc79b6dc05a7cd14c4945472844" translate="yes" xml:space="preserve">
          <source>Enable Large System Extension instructions. This is on by default for</source>
          <target state="translated">启用大型系统扩展指令。对于以下情况,默认为开启</target>
        </trans-unit>
        <trans-unit id="5313db34f510b6a28a51ef561341a7742309082f" translate="yes" xml:space="preserve">
          <source>Enable LeakSanitizer, a memory leak detector. This option only matters for linking of executables and the executable is linked against a library that overrides &lt;code&gt;malloc&lt;/code&gt; and other allocator functions. See &lt;a href=&quot;https://github.com/google/sanitizers/wiki/AddressSanitizerLeakSanitizer&quot;&gt;https://github.com/google/sanitizers/wiki/AddressSanitizerLeakSanitizer&lt;/a&gt; for more details. The run-time behavior can be influenced using the &lt;code&gt;LSAN_OPTIONS&lt;/code&gt; environment variable. The option cannot be combined with</source>
          <target state="translated">启用内存泄漏检测器LeakSanitizer。此选项仅对链接可执行文件很重要，并且可执行文件是针对覆盖 &lt;code&gt;malloc&lt;/code&gt; 和其他分配程序功能的库的。有关更多详细信息，请参见&lt;a href=&quot;https://github.com/google/sanitizers/wiki/AddressSanitizerLeakSanitizer&quot;&gt;https://github.com/google/sanitizers/wiki/AddressSanitizerLeakSanitizer&lt;/a&gt;。可以使用 &lt;code&gt;LSAN_OPTIONS&lt;/code&gt; 环境变量来影响运行时行为。该选项不能与</target>
        </trans-unit>
        <trans-unit id="963f7996b716be1c17df5a79ae31f2f9bb23a517" translate="yes" xml:space="preserve">
          <source>Enable Local Register Allocation. This is still experimental for ARC, so by default the compiler uses standard reload (i.e.</source>
          <target state="translated">启用本地寄存器分配。这对ARC来说还是试验性的,所以默认情况下,编译器使用标准的重载(即</target>
        </trans-unit>
        <trans-unit id="3bd13a89a3ec768d816679409bb63a5907cc342b" translate="yes" xml:space="preserve">
          <source>Enable Local Register Allocation. This is still experimental for FT32, so by default the compiler uses standard reload.</source>
          <target state="translated">启用本地寄存器分配。这对FT32来说还是试验性的,所以默认情况下,编译器使用标准重载。</target>
        </trans-unit>
        <trans-unit id="7fa9e4dd118db6c43acdd9765995f0465281818a" translate="yes" xml:space="preserve">
          <source>Enable Local Register Allocation. This is the default for SPARC since GCC 7 so</source>
          <target state="translated">启用本地寄存器分配。这是自GCC 7以来SPARC的默认值,所以</target>
        </trans-unit>
        <trans-unit id="89bbfd96b1406df4e9daca603ac86b980c364e5c" translate="yes" xml:space="preserve">
          <source>Enable RTL pass &lt;var&gt;pass&lt;/var&gt;. See</source>
          <target state="translated">启用RTL pass &lt;var&gt;pass&lt;/var&gt; 。看到</target>
        </trans-unit>
        <trans-unit id="f44412802c3209f5d9e4e5d01f1b31cdf41ef7c0" translate="yes" xml:space="preserve">
          <source>Enable Round Double Multiply Accumulate instructions. This is on by default for</source>
          <target state="translated">启用圆周双乘累加指令。默认情况下,这对于</target>
        </trans-unit>
        <trans-unit id="d370af9affe58a56b9b5454d4d92570e141e8b8f" translate="yes" xml:space="preserve">
          <source>Enable SVE2 aes instructions. This also enables SVE2 instructions.</source>
          <target state="translated">启用SVE2 aes指令。这也启用了SVE2指令。</target>
        </trans-unit>
        <trans-unit id="c3f75e37c4e4e45b9963ff233f2e2820dcfb4fb8" translate="yes" xml:space="preserve">
          <source>Enable SVE2 bitperm instructions. This also enables SVE2 instructions.</source>
          <target state="translated">启用SVE2 bitperm指令。这也启用了SVE2指令。</target>
        </trans-unit>
        <trans-unit id="2bbf22cee4e50726f4cae0a5e266998649407231" translate="yes" xml:space="preserve">
          <source>Enable SVE2 sha3 instructions. This also enables SVE2 instructions.</source>
          <target state="translated">启用SVE2 sha3指令。这也可以启用SVE2指令。</target>
        </trans-unit>
        <trans-unit id="2c7cde27311588c6804e4c9ac9068d7a4af84b22" translate="yes" xml:space="preserve">
          <source>Enable SVE2 sm4 instructions. This also enables SVE2 instructions.</source>
          <target state="translated">启用SVE2 sm4指令。这也可以启用SVE2指令。</target>
        </trans-unit>
        <trans-unit id="1332af3411aa268a3ef4a1b41bc0ae5d1edc2594" translate="yes" xml:space="preserve">
          <source>Enable Scalable Vector Extension instructions. This also enables Advanced SIMD and floating-point instructions.</source>
          <target state="translated">启用可扩展向量扩展指令。这也启用了高级SIMD和浮点指令。</target>
        </trans-unit>
        <trans-unit id="082f6e4a45595d5f7a3a2a560115400fb4ee2b89" translate="yes" xml:space="preserve">
          <source>Enable ThreadSanitizer, a fast data race detector. Memory access instructions are instrumented to detect data race bugs. See &lt;a href=&quot;https://github.com/google/sanitizers/wiki#threadsanitizer&quot;&gt;https://github.com/google/sanitizers/wiki#threadsanitizer&lt;/a&gt; for more details. The run-time behavior can be influenced using the &lt;code&gt;TSAN_OPTIONS&lt;/code&gt; environment variable; see &lt;a href=&quot;https://github.com/google/sanitizers/wiki/ThreadSanitizerFlags&quot;&gt;https://github.com/google/sanitizers/wiki/ThreadSanitizerFlags&lt;/a&gt; for a list of supported options. The option cannot be combined with</source>
          <target state="translated">启用ThreadSanitizer，一种快速的数据竞争检测器。内存访问指令用于检测数据争用错误。有关更多详细信息，请参见&lt;a href=&quot;https://github.com/google/sanitizers/wiki#threadsanitizer&quot;&gt;https://github.com/google/sanitizers/wiki#threadsanitizer&lt;/a&gt;。可以使用 &lt;code&gt;TSAN_OPTIONS&lt;/code&gt; 环境变量来影响运行时行为。有关受支持的选项的列表，请参见&lt;a href=&quot;https://github.com/google/sanitizers/wiki/ThreadSanitizerFlags&quot;&gt;https://github.com/google/sanitizers/wiki/ThreadSanitizerFlags&lt;/a&gt;。该选项不能与</target>
        </trans-unit>
        <trans-unit id="949a1a6c2112a203d7294b63f617d43e64b4229c" translate="yes" xml:space="preserve">
          <source>Enable UndefinedBehaviorSanitizer, a fast undefined behavior detector. Various computations are instrumented to detect undefined behavior at runtime. Current suboptions are:</source>
          <target state="translated">启用UndefinedBehaviorSanitizer,一个快速的未定义行为检测器。在运行时通过各种计算工具来检测未定义的行为。当前的子选项有:</target>
        </trans-unit>
        <trans-unit id="96f5c056cf8c5a806da05ed8b96789bc0b6d048b" translate="yes" xml:space="preserve">
          <source>Enable all estimate instructions.</source>
          <target state="translated">启用所有估算指令。</target>
        </trans-unit>
        <trans-unit id="df3c7c5cb30d8d0e87829e7d5c48c82259c25cb7" translate="yes" xml:space="preserve">
          <source>Enable all language-specific dumps.</source>
          <target state="translated">启用所有特定语言的转储。</target>
        </trans-unit>
        <trans-unit id="ae518ed7bc949ae822d65bcaeff9c7041fb826a6" translate="yes" xml:space="preserve">
          <source>Enable allocation of values to registers that are clobbered by function calls, by emitting extra instructions to save and restore the registers around such calls. Such allocation is done only when it seems to result in better code.</source>
          <target state="translated">通过发出额外的指令来保存和恢复这些调用周围的寄存器,从而实现对被函数调用占用的寄存器的值分配。只有当这种分配似乎能带来更好的代码时,才会进行这种分配。</target>
        </trans-unit>
        <trans-unit id="0a0fd86a97f36ba3d21ddbe6e9254e7a16fbfe18" translate="yes" xml:space="preserve">
          <source>Enable and control dumping of pass statistics in a separate file. The file name is generated by appending a suffix ending in &amp;lsquo;</source>
          <target state="translated">在单独的文件中启用和控制通过统计信息的转储。通过添加以'结尾的后缀来生成文件名</target>
        </trans-unit>
        <trans-unit id="f6804494e75f7aaede40247da0a4be9cdb7a84eb" translate="yes" xml:space="preserve">
          <source>Enable asan allocas/VLAs protection.</source>
          <target state="translated">启用asan allocas/VLAs保护。</target>
        </trans-unit>
        <trans-unit id="61fd83dce0b4c24f54b3d95d0aba14e424d6bcbf" translate="yes" xml:space="preserve">
          <source>Enable automatic template instantiation at link time. This option also implies</source>
          <target state="translated">在链接时启用自动模板实例化。这个选项也意味着</target>
        </trans-unit>
        <trans-unit id="803437b7c125524ce44c25382c66dec8a107376e" translate="yes" xml:space="preserve">
          <source>Enable barrel-shift instructions.</source>
          <target state="translated">启用换桶指令。</target>
        </trans-unit>
        <trans-unit id="dd1a569881fabce4df110c82ea43f4ea0973b717" translate="yes" xml:space="preserve">
          <source>Enable bbit peephole2.</source>
          <target state="translated">启用bbit窥视孔2。</target>
        </trans-unit>
        <trans-unit id="180b32141a3f8a46f27f030b1d9db7ce44e7c46b" translate="yes" xml:space="preserve">
          <source>Enable brain half-precision floating-point instructions. This also enables Advanced SIMD and floating-point instructions. This option is enabled by default for</source>
          <target state="translated">启用大脑半精度浮点指令。这也启用了高级SIMD和浮点指令。该选项默认为</target>
        </trans-unit>
        <trans-unit id="1e317e7bf07e0ef1d8933e0c682ab5ffc4c86dfe" translate="yes" xml:space="preserve">
          <source>Enable buffer overflow detection for global objects. This kind of protection is enabled by default if you are using</source>
          <target state="translated">启用全局对象的缓冲区溢出检测。如果您使用了</target>
        </trans-unit>
        <trans-unit id="0ff2936ea712569b3e61003e75e4a3a94ca881aa" translate="yes" xml:space="preserve">
          <source>Enable buffer overflow detection for memory reads. This kind of protection is enabled by default when using</source>
          <target state="translated">启用内存读取的缓冲区溢出检测。这种保护默认在使用</target>
        </trans-unit>
        <trans-unit id="c11c559ccc97fad4b1acec42a5bfc66eb0c4fd61" translate="yes" xml:space="preserve">
          <source>Enable buffer overflow detection for memory writes. This kind of protection is enabled by default when using</source>
          <target state="translated">启用内存写入的缓冲区溢出检测。这种保护默认在使用</target>
        </trans-unit>
        <trans-unit id="c2ab49f5ce7f3d41ded69401c310972e445af621" translate="yes" xml:space="preserve">
          <source>Enable buffer overflow detection for stack objects. This kind of protection is enabled by default when using</source>
          <target state="translated">启用堆栈对象的缓冲区溢出检测。这种保护默认在使用</target>
        </trans-unit>
        <trans-unit id="bcd2fc731b6ca5ce8904f8dd2548970ab5fbc93a" translate="yes" xml:space="preserve">
          <source>Enable cache bypass for volatile references.</source>
          <target state="translated">启用易失性引用的缓存旁路。</target>
        </trans-unit>
        <trans-unit id="dc4973bdf3e5300316096cd00a6ec0877e4070c6" translate="yes" xml:space="preserve">
          <source>Enable code density instructions for ARC EM. This option is on by default for ARC HS.</source>
          <target state="translated">启用ARC EM的代码密度指令。ARC HS的该选项默认为开启。</target>
        </trans-unit>
        <trans-unit id="6f26f87d795cdafd882a37f7cf6106b44c65db50" translate="yes" xml:space="preserve">
          <source>Enable code instrumentation of control-flow transfers to increase program security by checking that target addresses of control-flow transfer instructions (such as indirect function call, function return, indirect jump) are valid. This prevents diverting the flow of control to an unexpected target. This is intended to protect against such threats as Return-oriented Programming (ROP), and similarly call/jmp-oriented programming (COP/JOP).</source>
          <target state="translated">通过检查控制流转移指令(如间接函数调用、函数返回、间接跳转)的目标地址是否有效,启用控制流转移的代码仪表,以提高程序的安全性。这样可以防止将控制流转移到一个意想不到的目标。这样做的目的是为了防止诸如面向返回的编程(ROP),以及类似于面向调用/jmp的编程(COP/JOP)等威胁。</target>
        </trans-unit>
        <trans-unit id="b04ea9a65f69d1ed270cd68689d1e12352618b80" translate="yes" xml:space="preserve">
          <source>Enable compact &lt;code&gt;casesi&lt;/code&gt; pattern. This is the default for</source>
          <target state="translated">启用紧凑的 &lt;code&gt;casesi&lt;/code&gt; 模式。这是默认设置</target>
        </trans-unit>
        <trans-unit id="0c57839724a2712f31a1af12f90ff1f615581733" translate="yes" xml:space="preserve">
          <source>Enable constructor/destructor feature.</source>
          <target state="translated">启用构造函数/析构函数功能。</target>
        </trans-unit>
        <trans-unit id="975ccca01950f97ce533ac489aa7f20116354de0" translate="yes" xml:space="preserve">
          <source>Enable coprocessor instructions; the default is off.</source>
          <target state="translated">启用协处理器指令,默认为关闭。</target>
        </trans-unit>
        <trans-unit id="133e4f830a510ad1f945a9a4b1965c6cdd0bf2e0" translate="yes" xml:space="preserve">
          <source>Enable coverage-guided fuzzing code instrumentation. Inserts a call to &lt;code&gt;__sanitizer_cov_trace_pc&lt;/code&gt; into every basic block.</source>
          <target state="translated">启用覆盖率指导的模糊代码检测。 &lt;code&gt;__sanitizer_cov_trace_pc&lt;/code&gt; 的调用插入到每个基本块中。</target>
        </trans-unit>
        <trans-unit id="787d37d09881b29ce95c34e07e7021e04de78815" translate="yes" xml:space="preserve">
          <source>Enable dataflow guided fuzzing code instrumentation. Inserts a call to &lt;code&gt;__sanitizer_cov_trace_cmp1&lt;/code&gt;, &lt;code&gt;__sanitizer_cov_trace_cmp2&lt;/code&gt;, &lt;code&gt;__sanitizer_cov_trace_cmp4&lt;/code&gt; or &lt;code&gt;__sanitizer_cov_trace_cmp8&lt;/code&gt; for integral comparison with both operands variable or &lt;code&gt;__sanitizer_cov_trace_const_cmp1&lt;/code&gt;, &lt;code&gt;__sanitizer_cov_trace_const_cmp2&lt;/code&gt;, &lt;code&gt;__sanitizer_cov_trace_const_cmp4&lt;/code&gt; or &lt;code&gt;__sanitizer_cov_trace_const_cmp8&lt;/code&gt; for integral comparison with one operand constant, &lt;code&gt;__sanitizer_cov_trace_cmpf&lt;/code&gt; or &lt;code&gt;__sanitizer_cov_trace_cmpd&lt;/code&gt; for float or double comparisons and &lt;code&gt;__sanitizer_cov_trace_switch&lt;/code&gt; for switch statements.</source>
          <target state="translated">启用数据流引导的模糊代码检测。插入到一个呼叫 &lt;code&gt;__sanitizer_cov_trace_cmp1&lt;/code&gt; ， &lt;code&gt;__sanitizer_cov_trace_cmp2&lt;/code&gt; ， &lt;code&gt;__sanitizer_cov_trace_cmp4&lt;/code&gt; 或 &lt;code&gt;__sanitizer_cov_trace_cmp8&lt;/code&gt; 用于与这两个操作数的变量或积分比较 &lt;code&gt;__sanitizer_cov_trace_const_cmp1&lt;/code&gt; ， &lt;code&gt;__sanitizer_cov_trace_const_cmp2&lt;/code&gt; ， &lt;code&gt;__sanitizer_cov_trace_const_cmp4&lt;/code&gt; 或 &lt;code&gt;__sanitizer_cov_trace_const_cmp8&lt;/code&gt; 用于与一个操作数常数，积分比较 &lt;code&gt;__sanitizer_cov_trace_cmpf&lt;/code&gt; 或 &lt;code&gt;__sanitizer_cov_trace_cmpd&lt;/code&gt; 浮法或双比较和 &lt;code&gt;__sanitizer_cov_trace_switch&lt;/code&gt; 用于switch语句。</target>
        </trans-unit>
        <trans-unit id="1af777f40a3150cb8ba378da9ca8aedaaf114176" translate="yes" xml:space="preserve">
          <source>Enable deduction of a template type parameter as &lt;code&gt;std::initializer_list&lt;/code&gt; from a brace-enclosed initializer list, i.e.</source>
          <target state="translated">启用从括号括起来的初始化程序列表中将模板类型参数推导为 &lt;code&gt;std::initializer_list&lt;/code&gt; ，即</target>
        </trans-unit>
        <trans-unit id="699beaa366dd56ec35a2702d45f2103e1f67c4dc" translate="yes" xml:space="preserve">
          <source>Enable detection for built-in functions. This kind of protection is enabled by default when using</source>
          <target state="translated">启用内置功能的检测。当您使用</target>
        </trans-unit>
        <trans-unit id="d53fecd502038ea015d9795c95247289bc1d17ab" translate="yes" xml:space="preserve">
          <source>Enable detection of use-after-return. This kind of protection is enabled by default when using the</source>
          <target state="translated">启用检测返回后的使用。这种保护在使用</target>
        </trans-unit>
        <trans-unit id="22325b2d023fcd4619a9818a760c689af219e959" translate="yes" xml:space="preserve">
          <source>Enable divide and modulus instructions.</source>
          <target state="translated">启用除法和模数指令。</target>
        </trans-unit>
        <trans-unit id="6860f8ad3c912d9de1bc957db83ae37ff4acd2f1" translate="yes" xml:space="preserve">
          <source>Enable double load/store operations for ARC HS cores.</source>
          <target state="translated">启用ARC HS内核的双重加载/存储操作。</target>
        </trans-unit>
        <trans-unit id="f30747b51f35d511a8324038d0ec742af8852f12" translate="yes" xml:space="preserve">
          <source>Enable dumping various statistics about the pass (not honored by every dump option).</source>
          <target state="translated">启用转储关于通证的各种统计信息(并非每个转储选项都能兑现)。</target>
        </trans-unit>
        <trans-unit id="e61159e5abc9e858d3e7dc68248bef77e7e66569" translate="yes" xml:space="preserve">
          <source>Enable dumps from all OMP (Offloading and Multi Processing) optimizations.</source>
          <target state="translated">启用所有OMP(卸载和多处理)优化的转储。</target>
        </trans-unit>
        <trans-unit id="126e933efdf810fc684f2a27ed78c7f4a97f9db5" translate="yes" xml:space="preserve">
          <source>Enable dumps from all inlining optimizations.</source>
          <target state="translated">启用所有内联优化的转储。</target>
        </trans-unit>
        <trans-unit id="d0c94685fdabc0e86d42873897a8642d64c915a0" translate="yes" xml:space="preserve">
          <source>Enable dumps from all interprocedural optimizations.</source>
          <target state="translated">启用所有程序间优化的转储。</target>
        </trans-unit>
        <trans-unit id="f4a495e6ab007e96555960123af4b2e049e343cb" translate="yes" xml:space="preserve">
          <source>Enable dumps from all loop optimizations.</source>
          <target state="translated">启用所有循环优化的转储。</target>
        </trans-unit>
        <trans-unit id="da404a0e7964dc17445f8eab1557032d44193e2a" translate="yes" xml:space="preserve">
          <source>Enable dumps from all optimizations. This is a superset of the optimization groups listed above.</source>
          <target state="translated">启用所有优化的转储。这是上述优化组的超集。</target>
        </trans-unit>
        <trans-unit id="82fd093708bd37548045d3e8dc300297a204bb93" translate="yes" xml:space="preserve">
          <source>Enable dumps from all vectorization optimizations.</source>
          <target state="translated">启用所有矢量化优化的转储。</target>
        </trans-unit>
        <trans-unit id="1ca26bbd13d508b47dfc0ff9aedfd700309873f0" translate="yes" xml:space="preserve">
          <source>Enable emission of special debug stores within HSA kernels which are then read and reported by libgomp plugin. Generation of these stores is disabled by default, use</source>
          <target state="translated">在HSA内核中启用特殊的调试存储,然后由libgomp插件读取和报告。默认情况下,这些存储空间的生成是被禁用的,请使用</target>
        </trans-unit>
        <trans-unit id="92b0248c8870fe4857fc02d723bd02f0d5d911ee" translate="yes" xml:space="preserve">
          <source>Enable exception handling. Generates extra code needed to propagate exceptions. For some targets, this implies GCC generates frame unwind information for all functions, which can produce significant data size overhead, although it does not affect execution. If you do not specify this option, GCC enables it by default for languages like C++ that normally require exception handling, and disables it for languages like C that do not normally require it. However, you may need to enable this option when compiling C code that needs to interoperate properly with exception handlers written in C++. You may also wish to disable this option if you are compiling older C++ programs that don&amp;rsquo;t use exception handling.</source>
          <target state="translated">启用异常处理。生成传播异常所需的额外代码。对于某些目标，这意味着GCC会为所有功能生成帧展开信息，尽管这不会影响执行，但可能会产生大量的数据大小开销。如果未指定此选项，则默认情况下，GCC对通常要求例外处理的C ++语言启用它，而对于通常不要求其处理的C语言，则禁用它。但是，在编译需要与用C ++编写的异常处理程序正确互操作的C代码时，可能需要启用此选项。如果您正在编译不使用异常处理的较旧的C ++程序，则还可能希望禁用此选项。</target>
        </trans-unit>
        <trans-unit id="291b92d09ee9fff716f8b0be8063487213868bdd" translate="yes" xml:space="preserve">
          <source>Enable floating-point instructions. This is on by default for all possible values for options</source>
          <target state="translated">启用浮点指令。对于所有选项的可能值,默认为 &quot;开启&quot;。</target>
        </trans-unit>
        <trans-unit id="39904b8795d477fdb077dab2b449e06a2b1bd74a" translate="yes" xml:space="preserve">
          <source>Enable garbage collection (GC) in Objective-C and Objective-C++ programs. This option is only available with the NeXT runtime; the GNU runtime has a different garbage collection implementation that does not require special compiler flags.</source>
          <target state="translated">在Objective-C和Objective-C++程序中启用垃圾收集(GC)。这个选项只在NeXT运行时可用;GNU运行时有不同的垃圾收集实现,不需要特殊的编译器标志。</target>
        </trans-unit>
        <trans-unit id="eb9fbffb72277aaa3548891dbb1b3b1153391a9e" translate="yes" xml:space="preserve">
          <source>Enable generation of ARC SIMD instructions via target-specific builtins. Only valid for</source>
          <target state="translated">通过目标特定的内建程序来生成ARC SIMD指令。仅对以下情况有效</target>
        </trans-unit>
        <trans-unit id="3476de902c479834e38b15661f3b7c3cc2032cce" translate="yes" xml:space="preserve">
          <source>Enable generation of compare and set flag with immediate (&lt;code&gt;l.sf*i&lt;/code&gt;) instructions. By default extra instructions will be generated to store the immediate to a register first.</source>
          <target state="translated">使用立即（ &lt;code&gt;l.sf*i&lt;/code&gt; ）指令启用比较和设置标志的生成。默认情况下，将生成额外的指令以首先将立即数存储到寄存器。</target>
        </trans-unit>
        <trans-unit id="d50921b35a0d76feb95a28aea9efb5fcae7e1038" translate="yes" xml:space="preserve">
          <source>Enable generation of conditional move (&lt;code&gt;l.cmov&lt;/code&gt;) instructions. By default the equivalent will be generated using set and branch.</source>
          <target state="translated">启用条件移动（ &lt;code&gt;l.cmov&lt;/code&gt; ）指令的生成。默认情况下，等效项将使用set和branch生成。</target>
        </trans-unit>
        <trans-unit id="64de54a950fd518ed74414f068843cdf15d9e810" translate="yes" xml:space="preserve">
          <source>Enable generation of linemarkers in the preprocessor output that let the compiler know the current working directory at the time of preprocessing. When this option is enabled, the preprocessor emits, after the initial linemarker, a second linemarker with the current working directory followed by two slashes. GCC uses this directory, when it&amp;rsquo;s present in the preprocessed input, as the directory emitted as the current working directory in some debugging information formats. This option is implicitly enabled if debugging information is enabled, but this can be inhibited with the negated form</source>
          <target state="translated">在预处理器输出中启用行标记的生成，使编译器在预处理时知道当前的工作目录。启用此选项后，预处理器将在初始行标记之后发出第二个行标记，其中第二行标记带有当前工作目录，后跟两个斜杠。当该目录存在于预处理输入中时，GCC使用该目录作为某些调试信息格式作为当前工作目录发出的目录。如果启用了调试信息，则隐式启用此选项，但是可以使用反数形式将其禁止</target>
        </trans-unit>
        <trans-unit id="588970c3346f8b21ca330055ce039842b7c95dc3" translate="yes" xml:space="preserve">
          <source>Enable generation of rotate right (&lt;code&gt;l.ror&lt;/code&gt;) instructions. By default functions from</source>
          <target state="translated">启用向右旋转（ &lt;code&gt;l.ror&lt;/code&gt; ）指令的生成。默认情况下，以下功能</target>
        </trans-unit>
        <trans-unit id="4410c960b2144b2a5392d7e9052119e5a2916ace" translate="yes" xml:space="preserve">
          <source>Enable generation of rotate right with immediate (&lt;code&gt;l.rori&lt;/code&gt;) instructions. By default functions from</source>
          <target state="translated">使用立即（ &lt;code&gt;l.rori&lt;/code&gt; ）指令启用向右旋转的生成。默认情况下，以下功能</target>
        </trans-unit>
        <trans-unit id="1d2f560a395cf8229af315865d428228064bb2c4" translate="yes" xml:space="preserve">
          <source>Enable generation of shift with immediate (&lt;code&gt;l.srai&lt;/code&gt;, &lt;code&gt;l.srli&lt;/code&gt;, &lt;code&gt;l.slli&lt;/code&gt;) instructions. By default extra instructions will be generated to store the immediate to a register first.</source>
          <target state="translated">使用立即（ &lt;code&gt;l.srai&lt;/code&gt; ， &lt;code&gt;l.srli&lt;/code&gt; ， &lt;code&gt;l.slli&lt;/code&gt; ）指令启用移位的生成。默认情况下，将生成额外的指令以首先将立即数存储到寄存器。</target>
        </trans-unit>
        <trans-unit id="c64d914c46ba456fccc83d7a0d7c17c411a4e40e" translate="yes" xml:space="preserve">
          <source>Enable generation of sign extension (&lt;code&gt;l.ext*&lt;/code&gt;) instructions. By default memory loads are used to perform sign extension.</source>
          <target state="translated">启用符号扩展（ &lt;code&gt;l.ext*&lt;/code&gt; ）指令的生成。默认情况下，内存加载用于执行符号扩展。</target>
        </trans-unit>
        <trans-unit id="4f6c2330300990f23059abacc5ecdfe5f1dc0281" translate="yes" xml:space="preserve">
          <source>Enable generation of unaligned load and store instructions.</source>
          <target state="translated">启用生成未对齐的加载和存储指令。</target>
        </trans-unit>
        <trans-unit id="d26f3d711c1a65ce5ae7ed795204b286f03213ae" translate="yes" xml:space="preserve">
          <source>Enable global interrupt.</source>
          <target state="translated">启用全局中断。</target>
        </trans-unit>
        <trans-unit id="2f452efb25c68aa75fbb01603256e25885a6060f" translate="yes" xml:space="preserve">
          <source>Enable handling of OpenACC directives &lt;code&gt;#pragma acc&lt;/code&gt; in C/C++ and &lt;code&gt;!$acc&lt;/code&gt; in Fortran. When</source>
          <target state="translated">在C / C ++中启用OpenACC指令 &lt;code&gt;#pragma acc&lt;/code&gt; 的处理，在Fortran中启用 &lt;code&gt;!$acc&lt;/code&gt; 的处理。什么时候</target>
        </trans-unit>
        <trans-unit id="2ca92300312c8fc1987b891433bf16fbf5350717" translate="yes" xml:space="preserve">
          <source>Enable handling of OpenMP directives &lt;code&gt;#pragma omp&lt;/code&gt; in C/C++ and &lt;code&gt;!$omp&lt;/code&gt; in Fortran. When</source>
          <target state="translated">在C / C ++中启用OpenMP指令 &lt;code&gt;#pragma omp&lt;/code&gt; 的处理，在Fortran中启用 &lt;code&gt;!$omp&lt;/code&gt; 的处理。什么时候</target>
        </trans-unit>
        <trans-unit id="f764c2e81a54602d1c0862a3fd8d88c71c27e5ef" translate="yes" xml:space="preserve">
          <source>Enable handling of OpenMP&amp;rsquo;s SIMD directives with &lt;code&gt;#pragma omp&lt;/code&gt; in C/C++ and &lt;code&gt;!$omp&lt;/code&gt; in Fortran. Other OpenMP directives are ignored.</source>
          <target state="translated">使用C / C ++中的 &lt;code&gt;#pragma omp&lt;/code&gt; 和Fortran中的 &lt;code&gt;!$omp&lt;/code&gt; 启用对OpenMP SIMD指令的处理。其他OpenMP指令将被忽略。</target>
        </trans-unit>
        <trans-unit id="325afe18f0a625fafbd824b05e823388581382ad" translate="yes" xml:space="preserve">
          <source>Enable inlining of PLT entries in function calls to functions that are not known to bind locally. It has no effect without</source>
          <target state="translated">启用在函数调用中内嵌PLT条目,这些函数不知道是本地绑定的。如果不使用</target>
        </trans-unit>
        <trans-unit id="26c34a078cd9b46fb0bd484cd235d46f5c53f46b" translate="yes" xml:space="preserve">
          <source>Enable internal consistency checking. The default depends on the compiler configuration.</source>
          <target state="translated">启用内部一致性检查。默认值取决于编译器的配置。</target>
        </trans-unit>
        <trans-unit id="b40ab07f35e9ecebed6c91979cb9c80321b2c600" translate="yes" xml:space="preserve">
          <source>Enable interrupt stack instructions; the default is off.</source>
          <target state="translated">启用中断栈指令,默认为关闭。</target>
        </trans-unit>
        <trans-unit id="fd58b676d0e4ba40cac9f6295490ba16f891fad5" translate="yes" xml:space="preserve">
          <source>Enable kernel development mode. The</source>
          <target state="translated">启用内核开发模式。启用内核开发模式。</target>
        </trans-unit>
        <trans-unit id="6942946c621ac80c436737b7a31ee339272c871d" translate="yes" xml:space="preserve">
          <source>Enable lazy binding of function calls. This option is equivalent to</source>
          <target state="translated">启用函数调用的懒惰绑定。这个选项相当于</target>
        </trans-unit>
        <trans-unit id="c3e68f8f7d9888cb3d2e2d66e5738f0a5b7bffcf" translate="yes" xml:space="preserve">
          <source>Enable linker relaxation. Linker relaxation is a process whereby the linker attempts to reduce the size of a program by finding shorter versions of various instructions. Disabled by default.</source>
          <target state="translated">启用链接器松弛。链接器松弛是一个过程,链接器试图通过寻找各种指令的较短版本来减少程序的大小。默认情况下已禁用。</target>
        </trans-unit>
        <trans-unit id="0765f61b18fd9b0cd981b0d3115e02320dabdb7a" translate="yes" xml:space="preserve">
          <source>Enable loop epilogue vectorization using smaller vector size.</source>
          <target state="translated">使用较小的向量大小启用循环尾声向量化。</target>
        </trans-unit>
        <trans-unit id="04769dddbdca1dd3af29e66b89d9df24ccfdaae0" translate="yes" xml:space="preserve">
          <source>Enable more detailed dumps (not honored by every dump option). Also include information from the optimization passes.</source>
          <target state="translated">启用更详细的转储(不是每个转储选项都会遵守)。还包括来自优化通道的信息。</target>
        </trans-unit>
        <trans-unit id="9f3bf571af4fb133a9ed845eaa94347bdecede5e" translate="yes" xml:space="preserve">
          <source>Enable multiply instructions.</source>
          <target state="translated">启用乘法指令。</target>
        </trans-unit>
        <trans-unit id="6bdc85b650029e698104b9394508a12676ccb6ec" translate="yes" xml:space="preserve">
          <source>Enable multiprocessor instructions; the default is off.</source>
          <target state="translated">启用多处理器指令,默认为关闭。</target>
        </trans-unit>
        <trans-unit id="dae98acaa0a30e3960a49dff4e2a8d6c6a98eb29" translate="yes" xml:space="preserve">
          <source>Enable nested conditional execution optimizations (default).</source>
          <target state="translated">启用嵌套条件执行优化(默认)。</target>
        </trans-unit>
        <trans-unit id="0523e9bf64ec1c9137b9f17ae48ec467d581e674" translate="yes" xml:space="preserve">
          <source>Enable optimization of &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; and &lt;code&gt;||&lt;/code&gt; in conditional execution (default).</source>
          <target state="translated">启用 &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; 和 &lt;code&gt;||&lt;/code&gt; 的优化 在条件执行中（默认）。</target>
        </trans-unit>
        <trans-unit id="43cad454d19cf94092ebd0b65a6a9f9c7c63ffa9" translate="yes" xml:space="preserve">
          <source>Enable options usually used for instrumenting application to produce profile useful for later recompilation with profile feedback based optimization. You must use</source>
          <target state="translated">启用通常用于工具应用程序的选项,以产生对以后重新编译有用的基于配置文件反馈的优化的配置文件。您必须使用</target>
        </trans-unit>
        <trans-unit id="9425982687d5465084a29222f1e8d83738debfbc" translate="yes" xml:space="preserve">
          <source>Enable or disable PC-relative literal loads. With this option literal pools are accessed using a single instruction and emitted after each function. This limits the maximum size of functions to 1MB. This is enabled by default for</source>
          <target state="translated">启用或禁用PC相关的文字负载。使用该选项,可以使用单条指令访问文字池,并在每个函数后发出。这将函数的最大大小限制为1MB。默认情况下,该选项被启用,用于</target>
        </trans-unit>
        <trans-unit id="37cd8da3fdbfa9f8188d860129119fec2bfd100c" translate="yes" xml:space="preserve">
          <source>Enable or disable calls to out-of-line helpers to implement atomic operations. These helpers will, at runtime, determine if the LSE instructions from ARMv8.1-A can be used; if not, they will use the load/store-exclusive instructions that are present in the base ARMv8.0 ISA.</source>
          <target state="translated">启用或禁用对行外帮助程序的调用以实现原子操作。这些辅助程序将在运行时确定是否可以使用 ARMv8.1-A 的 LSE 指令;如果不能,它们将使用基本 ARMv8.0 ISA 中的加载/存储专用指令。</target>
        </trans-unit>
        <trans-unit id="1a34d5bdfa8a40aec1348063e5f43f0a38a44e4b" translate="yes" xml:space="preserve">
          <source>Enable or disable calls to out-of-line helpers to implement atomic operations. This corresponds to the behavior of the command line options</source>
          <target state="translated">启用或禁用对行外帮助程序的调用,以实现原子操作。这对应于命令行选项</target>
        </trans-unit>
        <trans-unit id="f213f1158c65a76a7da3e44d0dfb546afeb1c37d" translate="yes" xml:space="preserve">
          <source>Enable or disable emitting &lt;code&gt;mul&lt;/code&gt;, &lt;code&gt;mulx&lt;/code&gt; and &lt;code&gt;div&lt;/code&gt; family of instructions by the compiler. The default is to emit &lt;code&gt;mul&lt;/code&gt; and not emit &lt;code&gt;div&lt;/code&gt; and &lt;code&gt;mulx&lt;/code&gt;.</source>
          <target state="translated">由编译器启用或禁用发出 &lt;code&gt;mul&lt;/code&gt; ， &lt;code&gt;mulx&lt;/code&gt; 和 &lt;code&gt;div&lt;/code&gt; 系列指令。默认设置是发出 &lt;code&gt;mul&lt;/code&gt; 而不发出 &lt;code&gt;div&lt;/code&gt; 和 &lt;code&gt;mulx&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a0c735f45199333d31330ebeb1c39ca77bf91fab" translate="yes" xml:space="preserve">
          <source>Enable or disable generation of Nios II R2 BMX (bit manipulation) and CDX (code density) instructions. Enabling these instructions also requires</source>
          <target state="translated">启用或禁用Nios II R2 BMX(位操作)和CDX(代码密度)指令的生成。启用这些指令还需要</target>
        </trans-unit>
        <trans-unit id="e82224b52a26ba48a5b113f09b7fcf8cc858a9c2" translate="yes" xml:space="preserve">
          <source>Enable or disable generation of additional code to track speculative execution through conditional branches. The tracking state can then be used by the compiler when expanding calls to &lt;code&gt;__builtin_speculation_safe_copy&lt;/code&gt; to permit a more efficient code sequence to be generated.</source>
          <target state="translated">启用或禁用附加代码的生成，以通过条件分支跟踪推测性执行。然后，在扩展对 &lt;code&gt;__builtin_speculation_safe_copy&lt;/code&gt; 的调用以允许生成更有效的代码序列时，编译器可以使用跟踪状态。</target>
        </trans-unit>
        <trans-unit id="8588fb4dd2a8d4f96274711c0f8a3dcffa809a3b" translate="yes" xml:space="preserve">
          <source>Enable or disable the division approximation. This option only has an effect if</source>
          <target state="translated">启用或禁用除法近似。只有在以下情况下,该选项才会生效</target>
        </trans-unit>
        <trans-unit id="da4836dd8fd423982dc5d807088aa304a1a7fb40" translate="yes" xml:space="preserve">
          <source>Enable or disable the reciprocal square root approximation. This option only has an effect if</source>
          <target state="translated">启用或禁用往复平方根近似。此选项只有在以下情况下才会生效</target>
        </trans-unit>
        <trans-unit id="6cd2e01bcd6daa77f123d3562e525b53f2208b99" translate="yes" xml:space="preserve">
          <source>Enable or disable the square root approximation. This option only has an effect if</source>
          <target state="translated">启用或禁用平方根近似。此选项只有在以下情况下才会生效</target>
        </trans-unit>
        <trans-unit id="f6d5d7b63171cb59117cb5da0b6d0ce6a7318345" translate="yes" xml:space="preserve">
          <source>Enable or disable the workaround for the ARM Cortex-A53 erratum number 835769. This involves inserting a NOP instruction between memory instructions and 64-bit integer multiply-accumulate instructions.</source>
          <target state="translated">启用或禁用ARM Cortex-A53错误编号835769的解决方法。这涉及在内存指令和 64 位整数乘法累加指令之间插入 NOP 指令。</target>
        </trans-unit>
        <trans-unit id="1b8e841a5a6d9c6fdc72f5d2c3b9462219761996" translate="yes" xml:space="preserve">
          <source>Enable or disable the workaround for the ARM Cortex-A53 erratum number 843419. This erratum workaround is made at link time and this will only pass the corresponding flag to the linker.</source>
          <target state="translated">启用或禁用 ARM Cortex-A53 勘误号 843419 的变通方法。该勘误工作法是在链接时进行的,这只会将相应的标志传递给链接器。</target>
        </trans-unit>
        <trans-unit id="e8d2c7af76155c379ab5d5ec1df26431744e4771" translate="yes" xml:space="preserve">
          <source>Enable or disable use of &lt;code&gt;CONST16&lt;/code&gt; instructions for loading constant values. The &lt;code&gt;CONST16&lt;/code&gt; instruction is currently not a standard option from Tensilica. When enabled, &lt;code&gt;CONST16&lt;/code&gt; instructions are always used in place of the standard &lt;code&gt;L32R&lt;/code&gt; instructions. The use of &lt;code&gt;CONST16&lt;/code&gt; is enabled by default only if the &lt;code&gt;L32R&lt;/code&gt; instruction is not available.</source>
          <target state="translated">启用或禁用使用 &lt;code&gt;CONST16&lt;/code&gt; 指令加载常量值。目前，Tensilica尚未将 &lt;code&gt;CONST16&lt;/code&gt; 指令作为标准选项。启用后，将始终使用 &lt;code&gt;CONST16&lt;/code&gt; 指令代替标准 &lt;code&gt;L32R&lt;/code&gt; 指令。采用 &lt;code&gt;CONST16&lt;/code&gt; 默认启用仅在 &lt;code&gt;L32R&lt;/code&gt; 指令不可用。</target>
        </trans-unit>
        <trans-unit id="87ea222da3a42af40a5b89fab414b5a2466d4691" translate="yes" xml:space="preserve">
          <source>Enable or disable use of Branch Likely instructions, regardless of the default for the selected architecture. By default, Branch Likely instructions may be generated if they are supported by the selected architecture. An exception is for the MIPS32 and MIPS64 architectures and processors that implement those architectures; for those, Branch Likely instructions are not be generated by default because the MIPS32 and MIPS64 architectures specifically deprecate their use.</source>
          <target state="translated">启用或禁用Branch Likely指令,无论所选架构的默认值如何。默认情况下,如果所选架构支持Branch Likely指令,则可以生成这些指令。MIPS32和MIPS64架构以及实现这些架构的处理器是一个例外;对于这些架构,默认情况下不会生成Branch Likely指令,因为MIPS32和MIPS64架构特别禁止使用这些指令。</target>
        </trans-unit>
        <trans-unit id="6f7c7366f13d27cab3029da7a7c328e36fbdbb28" translate="yes" xml:space="preserve">
          <source>Enable or disable use of fused multiply/add and multiply/subtract instructions in the floating-point option. This has no effect if the floating-point option is not also enabled. Disabling fused multiply/add and multiply/subtract instructions forces the compiler to use separate instructions for the multiply and add/subtract operations. This may be desirable in some cases where strict IEEE 754-compliant results are required: the fused multiply add/subtract instructions do not round the intermediate result, thereby producing results with &lt;em&gt;more&lt;/em&gt; bits of precision than specified by the IEEE standard. Disabling fused multiply add/subtract instructions also ensures that the program output is not sensitive to the compiler&amp;rsquo;s ability to combine multiply and add/subtract operations.</source>
          <target state="translated">在浮点选项中启用或禁用融合的乘法/加法和乘法/减法指令的使用。如果未同时启用浮点选项，则无效。禁用融合的乘法/加法和乘法/减法指令会强制编译器对乘法和加法/减法运算使用单独的指令。这可能是在某些情况下是必需的严格符合IEEE 754结果可取的：该融合乘法加法/减法指令不圆的中间结果，以由此产生的结果&lt;em&gt;更&lt;/em&gt;比IEEE标准所规定的精度的位。禁用融合的乘法加/减指令还可以确保程序输出对编译器组合乘法与加/减运算的能力不敏感。</target>
        </trans-unit>
        <trans-unit id="f2d29f4186409cdd0269837c4398f5ca04568394" translate="yes" xml:space="preserve">
          <source>Enable other detailed optimization information (only available in certain passes).</source>
          <target state="translated">启用其他详细的优化信息(仅在某些通道中可用)。</target>
        </trans-unit>
        <trans-unit id="338cf5f95ce763c97fbfe82953390f719fbef967" translate="yes" xml:space="preserve">
          <source>Enable parsing of function definitions marked with &lt;code&gt;__GIMPLE&lt;/code&gt;. This is an experimental feature that allows unit testing of GIMPLE passes.</source>
          <target state="translated">启用对标记为 &lt;code&gt;__GIMPLE&lt;/code&gt; 的函数定义的解析。这是一项实验功能，可以对GIMPLE通过进行单元测试。</target>
        </trans-unit>
        <trans-unit id="f3fcc68975389b930adf047407384e4de7afa86d" translate="yes" xml:space="preserve">
          <source>Enable pre-reload use of the &lt;code&gt;cbranchsi&lt;/code&gt; pattern.</source>
          <target state="translated">启用 &lt;code&gt;cbranchsi&lt;/code&gt; 模式的预加载使用。</target>
        </trans-unit>
        <trans-unit id="7aca1894ee9ae073c5e50327164b18c35adaf0e4" translate="yes" xml:space="preserve">
          <source>Enable profile feedback-directed optimizations, and the following optimizations, many of which are generally profitable only with profile feedback available:</source>
          <target state="translated">启用配置文件反馈导向的优化,以及以下优化,很多优化一般只有在有配置文件反馈的情况下才能盈利。</target>
        </trans-unit>
        <trans-unit id="dd16226a248d7401935b2178b12d750c5c2d817f" translate="yes" xml:space="preserve">
          <source>Enable reduced code size &lt;code&gt;printf&lt;/code&gt; and &lt;code&gt;puts&lt;/code&gt; library functions. The &amp;lsquo;</source>
          <target state="translated">启用减小的代码大小 &lt;code&gt;printf&lt;/code&gt; 并 &lt;code&gt;puts&lt;/code&gt; 库函数。这 '</target>
        </trans-unit>
        <trans-unit id="9b22143dddf716e38b0694ad2ca7a60178731d02" translate="yes" xml:space="preserve">
          <source>Enable register pressure sensitive insn scheduling before register allocation. This only makes sense when scheduling before register allocation is enabled, i.e. with</source>
          <target state="translated">在寄存器分配前启用寄存器压力敏感的insn调度。只有在启用了寄存器分配前的调度时,这才是有意义的,即在使用</target>
        </trans-unit>
        <trans-unit id="c0432e33b5c323c92ba751b7a0171493013f8ec2" translate="yes" xml:space="preserve">
          <source>Enable sampling-based feedback-directed optimizations, and the following optimizations, many of which are generally profitable only with profile feedback available:</source>
          <target state="translated">启用基于采样的反馈导向优化,以及以下优化,其中很多优化一般只有在有剖面反馈的情况下才能盈利。</target>
        </trans-unit>
        <trans-unit id="9201f89c6bef5151370e84b69891107c6c6b6ade" translate="yes" xml:space="preserve">
          <source>Enable sanitization of local variables to detect use-after-scope bugs. The option sets</source>
          <target state="translated">启用局部变量的净化,以检测使用范围后的错误。该选项设置了</target>
        </trans-unit>
        <trans-unit id="37f6c409f5734729b3dae114f8c39805c8586c4f" translate="yes" xml:space="preserve">
          <source>Enable showing basic block boundaries (disabled in raw dumps).</source>
          <target state="translated">启用显示基本块边界(在原始转储中禁用)。</target>
        </trans-unit>
        <trans-unit id="92f2f939a0618b052e264a0ddefa5df5b7f5e756" translate="yes" xml:space="preserve">
          <source>Enable showing line numbers for statements.</source>
          <target state="translated">启用显示报表的行号。</target>
        </trans-unit>
        <trans-unit id="fd380e6ae8aa5c4cc3cef79ab2ea9026b97f5fbd" translate="yes" xml:space="preserve">
          <source>Enable showing missed optimization information (only available in certain passes).</source>
          <target state="translated">启用显示遗漏的优化信息(仅在某些通道中可用)。</target>
        </trans-unit>
        <trans-unit id="0d329eb30c66df2a8bec3e0f68514d20ab1b9f92" translate="yes" xml:space="preserve">
          <source>Enable showing optimization information (only available in certain passes).</source>
          <target state="translated">启用显示优化信息(仅在某些通道中可用)。</target>
        </trans-unit>
        <trans-unit id="f10fcf4d31c6a2b2451c140a8a88da810228a75d" translate="yes" xml:space="preserve">
          <source>Enable showing scalar evolution analysis details.</source>
          <target state="translated">启用显示标量演变分析细节。</target>
        </trans-unit>
        <trans-unit id="1fa4da5aa5a1df45f7fc17506d98a1fa44e7ec97" translate="yes" xml:space="preserve">
          <source>Enable showing the EH region number holding each statement.</source>
          <target state="translated">启用显示持有每个报表的EH区域号。</target>
        </trans-unit>
        <trans-unit id="c8bfc39b577282d7a982b0609ca5e212d2e36522" translate="yes" xml:space="preserve">
          <source>Enable showing the tree dump for each statement.</source>
          <target state="translated">启用显示每个语句的树形转储。</target>
        </trans-unit>
        <trans-unit id="c1965c688248d83e371ce542160789f937fce791" translate="yes" xml:space="preserve">
          <source>Enable showing the unique ID (&lt;code&gt;DECL_UID&lt;/code&gt;) for each variable.</source>
          <target state="translated">启用显示每个变量的唯一ID（ &lt;code&gt;DECL_UID&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="2c8e86f5a7b56d45f646fe90ecd4602077ea1bdc" translate="yes" xml:space="preserve">
          <source>Enable showing virtual operands for every statement.</source>
          <target state="translated">启用显示每个语句的虚拟操作数。</target>
        </trans-unit>
        <trans-unit id="7287e0e84335a843622d1b816ceb09d5c05aa749" translate="yes" xml:space="preserve">
          <source>Enable sign extend instructions.</source>
          <target state="translated">启用标志扩展指令。</target>
        </trans-unit>
        <trans-unit id="2106aa3d9fb87ebeededad40a76e40f9c935fadd" translate="yes" xml:space="preserve">
          <source>Enable software pipelining of innermost loops during selective scheduling. This option has no effect unless one of</source>
          <target state="translated">在选择性调度期间,启用最内部循环的软件流水线。这个选项没有效果,除非有以下情况之一</target>
        </trans-unit>
        <trans-unit id="523a4757398235b8bbb90229026fc9eed157dbee" translate="yes" xml:space="preserve">
          <source>Enable special code to work around file systems which only permit very short file names, such as MS-DOS.</source>
          <target state="translated">启用特殊代码,以绕过只允许非常短的文件名的文件系统,如MS-DOS。</target>
        </trans-unit>
        <trans-unit id="3536f2d6d38314050bafe0d10aa71b6595a43eae" translate="yes" xml:space="preserve">
          <source>Enable streaming of mangled types names of C++ types and their unification at link time. This increases size of LTO object files, but enables diagnostics about One Definition Rule violations.</source>
          <target state="translated">启用C++类型的杂乱类型名的流式传输,并在链接时对其进行统一。这增加了LTO对象文件的大小,但可以对违反One Definition Rule的行为进行诊断。</target>
        </trans-unit>
        <trans-unit id="07a4edd982a3edcc355177edde03a13c0e84c57f" translate="yes" xml:space="preserve">
          <source>Enable support for &lt;code&gt;char8_t&lt;/code&gt; as adopted for C++2a. This includes the addition of a new &lt;code&gt;char8_t&lt;/code&gt; fundamental type, changes to the types of UTF-8 string and character literals, new signatures for user-defined literals, associated standard library updates, and new &lt;code&gt;__cpp_char8_t&lt;/code&gt; and &lt;code&gt;__cpp_lib_char8_t&lt;/code&gt; feature test macros.</source>
          <target state="translated">启用对C ++ 2a所采用的 &lt;code&gt;char8_t&lt;/code&gt; 的支持。这包括添加新的 &lt;code&gt;char8_t&lt;/code&gt; 基本类型，更改UTF-8字符串和字符文字的类型，用户定义文字的新签名，关联的标准库更新以及新的 &lt;code&gt;__cpp_char8_t&lt;/code&gt; 和 &lt;code&gt;__cpp_lib_char8_t&lt;/code&gt; 功能测试宏。</target>
        </trans-unit>
        <trans-unit id="86deb01ddbea29be60b5e5fa22319efa9cd9ea02" translate="yes" xml:space="preserve">
          <source>Enable support for C++17 &lt;code&gt;new&lt;/code&gt; of types that require more alignment than &lt;code&gt;void* ::operator new(std::size_t)&lt;/code&gt; provides. A numeric argument such as &lt;code&gt;-faligned-new=32&lt;/code&gt; can be used to specify how much alignment (in bytes) is provided by that function, but few users will need to override the default of &lt;code&gt;alignof(std::max_align_t)&lt;/code&gt;.</source>
          <target state="translated">启用对C ++ 17 &lt;code&gt;new&lt;/code&gt; 类型的支持，这些类型需要比 &lt;code&gt;void* ::operator new(std::size_t)&lt;/code&gt; 提供的对齐更多的类型。可以使用 &lt;code&gt;-faligned-new=32&lt;/code&gt; 之类的数字参数来指定该函数提供的对齐方式（以字节为单位），但是很少有用户需要覆盖 &lt;code&gt;alignof(std::max_align_t)&lt;/code&gt; 的默认值。</target>
        </trans-unit>
        <trans-unit id="e96dd7f9b95634f8def4cef0c03097523e0ad470" translate="yes" xml:space="preserve">
          <source>Enable support for the C++ Extensions for Concepts Technical Specification, ISO 19217 (2015), which allows code like</source>
          <target state="translated">启用对C++概念扩展技术规范,ISO 19217(2015)的支持,它允许像这样的代码</target>
        </trans-unit>
        <trans-unit id="14e7ef08a35724e34d06ae98a57c52f37db35541" translate="yes" xml:space="preserve">
          <source>Enable support for the C++ coroutines extension (experimental).</source>
          <target state="translated">启用对C++coroutines扩展的支持(试验性)。</target>
        </trans-unit>
        <trans-unit id="f069479e84a1d7c81e6433a171bacdd46bd05f77" translate="yes" xml:space="preserve">
          <source>Enable syntactic support for structured exception handling in Objective-C, similar to what is offered by C++. This option is required to use the Objective-C keywords &lt;code&gt;@try&lt;/code&gt;, &lt;code&gt;@throw&lt;/code&gt;, &lt;code&gt;@catch&lt;/code&gt;, &lt;code&gt;@finally&lt;/code&gt; and &lt;code&gt;@synchronized&lt;/code&gt;. This option is available with both the GNU runtime and the NeXT runtime (but not available in conjunction with the NeXT runtime on Mac OS X 10.2 and earlier).</source>
          <target state="translated">与C ++相似，在Objective-C中为结构化异常处理启用语法支持。此选项需要使用Objective-C关键字 &lt;code&gt;@try&lt;/code&gt; ， &lt;code&gt;@throw&lt;/code&gt; ， &lt;code&gt;@catch&lt;/code&gt; ， &lt;code&gt;@finally&lt;/code&gt; 和 &lt;code&gt;@synchronized&lt;/code&gt; 。 GNU运行时和NeXT运行时都可以使用此选项（但不能在Mac OS X 10.2和更早版本上与NeXT运行时一起使用）。</target>
        </trans-unit>
        <trans-unit id="2d795a0556dc7d4b23ca50c7c054a8e91a0bb9da" translate="yes" xml:space="preserve">
          <source>Enable the Armv8-a Execution and Data Prediction Restriction instructions. This option is only to enable the extension at the assembler level and does not affect code generation. This option is enabled by default for</source>
          <target state="translated">启用Armv8-a执行和数据预测限制指令。这个选项只是为了在汇编器级别启用扩展,不影响代码的生成。这个选项默认为</target>
        </trans-unit>
        <trans-unit id="9fdfa6853fe490f741b25fcc657be1e589731130" translate="yes" xml:space="preserve">
          <source>Enable the Armv8-a Scalable Vector Extension 2. This also enables SVE instructions.</source>
          <target state="translated">启用Armv8-a可伸缩矢量扩展2。这也可以启用SVE指令。</target>
        </trans-unit>
        <trans-unit id="d449b6d30f1777aba3aa927c43beb1ba1eca16be" translate="yes" xml:space="preserve">
          <source>Enable the Armv8-a Speculation Barrier instruction. This option is only to enable the extension at the assembler level and does not affect code generation. This option is enabled by default for</source>
          <target state="translated">启用Armv8-a Speculation Barrier指令。这个选项只是为了在汇编器级别启用扩展,不影响代码的生成。这个选项默认为</target>
        </trans-unit>
        <trans-unit id="9f3b4e86290c1a4d9bac5d679d03a802d662a426" translate="yes" xml:space="preserve">
          <source>Enable the Armv8-a Speculative Store Bypass Safe instruction. This option is only to enable the extension at the assembler level and does not affect code generation. This option is enabled by default for</source>
          <target state="translated">启用Armv8-a猜测性存储旁路安全指令。这个选项只是为了在汇编器级别启用扩展,不影响代码的生成。这个选项默认为</target>
        </trans-unit>
        <trans-unit id="cb4dff47dd10c4d2d29138894fb337bf731a4703" translate="yes" xml:space="preserve">
          <source>Enable the Armv8-a aes and pmull crypto extension. This also enables Advanced SIMD instructions.</source>
          <target state="translated">启用Armv8-a aes和pmull加密扩展。这也可以启用高级SIMD指令。</target>
        </trans-unit>
        <trans-unit id="e878790ea268c6c3c0f09ca24b1f8d32605101d6" translate="yes" xml:space="preserve">
          <source>Enable the Armv8-a sha2 crypto extension. This also enables Advanced SIMD instructions.</source>
          <target state="translated">启用Armv8-a sha2加密扩展。这也可以启用高级SIMD指令。</target>
        </trans-unit>
        <trans-unit id="712d78d3897110fb983a6b1ce64ceb649bbc8b13" translate="yes" xml:space="preserve">
          <source>Enable the Armv8.5-a Memory Tagging Extensions. This option is only to enable the extension at the assembler level and does not affect code generation.</source>
          <target state="translated">启用Armv8.5-a内存标记扩展。这个选项只是在汇编器层面启用扩展,不影响代码的生成。</target>
        </trans-unit>
        <trans-unit id="9079a098e5a352f9d4734819ee7434e8414e46a7" translate="yes" xml:space="preserve">
          <source>Enable the Armv8.5-a Memory Tagging Extensions. Use of this option with architectures prior to Armv8.5-A is not supported.</source>
          <target state="translated">启用Armv8.5-a内存标记扩展。不支持在Armv8.5-A之前的架构中使用该选项。</target>
        </trans-unit>
        <trans-unit id="95fc60e33111a67c5486993a8b351f8b44d07966" translate="yes" xml:space="preserve">
          <source>Enable the Armv8.5-a Random Number instructions. This option is only to enable the extension at the assembler level and does not affect code generation.</source>
          <target state="translated">启用Armv8.5-a随机数指令。这个选项只是为了在汇编器级别启用扩展,不影响代码的生成。</target>
        </trans-unit>
        <trans-unit id="180be0b78efe4d6cb3cafec86af33875c8613d90" translate="yes" xml:space="preserve">
          <source>Enable the Custom Datapath Extension (CDE) on selected coprocessors according to the numbers given in the options in the range 0 to 7.</source>
          <target state="translated">根据选项中给定的数字(范围为0至7),在选定的协处理器上启用自定义数据路径扩展(CDE)。</target>
        </trans-unit>
        <trans-unit id="5baad961c199027af6ce41f297ba396c80d7b6e4" translate="yes" xml:space="preserve">
          <source>Enable the Dot Product extension. This also enables Advanced SIMD instructions.</source>
          <target state="translated">启用 Dot Product 扩展。这也将启用高级SIMD指令。</target>
        </trans-unit>
        <trans-unit id="75d41529d8ccf751d43eb43b131c2899752ea6dc" translate="yes" xml:space="preserve">
          <source>Enable the P0136 adjustment to the semantics of C++11 constructor inheritance. This is part of C++17 but also considered to be a Defect Report against C++11 and C++14. This flag is enabled by default unless</source>
          <target state="translated">启用P0136调整C++11构造函数继承的语义。这是C++17的一部分,但也被认为是针对C++11和C++14的缺陷报告。这个标志默认是启用的,除非</target>
        </trans-unit>
        <trans-unit id="3336547cc155fdebeb020d2a6fd267e14851b493" translate="yes" xml:space="preserve">
          <source>Enable the P0522 resolution to Core issue 150, template template parameters and default arguments: this allows a template with default template arguments as an argument for a template template parameter with fewer template parameters. This flag is enabled by default for</source>
          <target state="translated">启用P0522解决核心问题150,模板参数和默认参数:这允许一个具有默认模板参数的模板作为模板参数的参数,模板参数较少。该标志默认为</target>
        </trans-unit>
        <trans-unit id="e10cb464cd66cc6979f0f2bd645896f8d79b1002" translate="yes" xml:space="preserve">
          <source>Enable the RcPc extension. This does not change code generation from GCC, but is passed on to the assembler, enabling inline asm statements to use instructions from the RcPc extension.</source>
          <target state="translated">启用RcPc扩展。这不会改变GCC的代码生成,但会传递给汇编器,使内联asm语句能够使用RcPc扩展的指令。</target>
        </trans-unit>
        <trans-unit id="b8bb0e2cd28800659cbb25749c903e1e45881bcd" translate="yes" xml:space="preserve">
          <source>Enable the Statistical Profiling extension. This option is only to enable the extension at the assembler level and does not affect code generation.</source>
          <target state="translated">启用统计分析扩展。这个选项只是为了在汇编器级别启用扩展,不影响代码的生成。</target>
        </trans-unit>
        <trans-unit id="1fe6b0760edee391f1d108920f04662238f04b99" translate="yes" xml:space="preserve">
          <source>Enable the Transactional Memory Extension.</source>
          <target state="translated">启用事务性内存扩展。</target>
        </trans-unit>
        <trans-unit id="d2bf0d0b92eedbfd9d708906c85f1c2c0761dac3" translate="yes" xml:space="preserve">
          <source>Enable the approximation for scalar division.</source>
          <target state="translated">启用标量除法的近似。</target>
        </trans-unit>
        <trans-unit id="089b193263b191426125d1b838990e7a8cad6bd6" translate="yes" xml:space="preserve">
          <source>Enable the approximation for scalar square root.</source>
          <target state="translated">启用标量平方根的近似。</target>
        </trans-unit>
        <trans-unit id="9c93085948ceb9475fc7f62f768a72b094e0ccf8" translate="yes" xml:space="preserve">
          <source>Enable the approximation for vectorized division.</source>
          <target state="translated">启用向量化除法的近似值。</target>
        </trans-unit>
        <trans-unit id="57c9384569cf978709f6ae7436442c4140ae097a" translate="yes" xml:space="preserve">
          <source>Enable the approximation for vectorized square root.</source>
          <target state="translated">启用向量化平方根的近似。</target>
        </trans-unit>
        <trans-unit id="a491c3894437f3620a7562cbc06a8ae940a33c10" translate="yes" xml:space="preserve">
          <source>Enable the built-in global declarations</source>
          <target state="translated">启用内置全局声明</target>
        </trans-unit>
        <trans-unit id="2237d50ade0b28ca43195c6d9a72499aa22da748" translate="yes" xml:space="preserve">
          <source>Enable the compiler to directly use a symbol name as an address in a load/store instruction, without first loading it into a register. Typically, the use of this option generates larger programs, which run faster than when the option isn&amp;rsquo;t used. However, the results vary from program to program, so it is left as a user option, rather than being permanently enabled.</source>
          <target state="translated">使编译器可以直接将符号名称用作加载/存储指令中的地址，而无需先将其加载到寄存器中。通常，使用此选项会生成较大的程序，其运行速度比不使用该选项时要快。但是，结果因程序而异，因此它留作用户选项，而不是永久启用。</target>
        </trans-unit>
        <trans-unit id="41ed1ab2ec5c1611d830306ad10031d9f9977d65" translate="yes" xml:space="preserve">
          <source>Enable the critical-path heuristic in the scheduler. This heuristic favors instructions on the critical path. This is enabled by default when scheduling is enabled, i.e. with</source>
          <target state="translated">在调度器中启用关键路径启发式。这个启发式方法倾向于关键路径上的指令。当启用调度时,即使用</target>
        </trans-unit>
        <trans-unit id="4067ddde2438b48af6e32a24a3e86763ffbd4275" translate="yes" xml:space="preserve">
          <source>Enable the default instructions, equivalent to</source>
          <target state="translated">启用默认指令,相当于</target>
        </trans-unit>
        <trans-unit id="8f1e0508bfc454c7d53eb8b99b0581386011e857" translate="yes" xml:space="preserve">
          <source>Enable the dependent-count heuristic in the scheduler. This heuristic favors the instruction that has more instructions depending on it. This is enabled by default when scheduling is enabled, i.e. with</source>
          <target state="translated">启用调度器中的依赖数量启发式。这个启发式方法倾向于有更多指令依赖的指令。当启用了调度时,即使用了</target>
        </trans-unit>
        <trans-unit id="507033c0f31508a95a83480597cd9ac155e65d9c" translate="yes" xml:space="preserve">
          <source>Enable the documented workaround for the back-to-back store errata of the GR712RC processor.</source>
          <target state="translated">启用GR712RC处理器的背靠背存储勘误的文档化解决方法。</target>
        </trans-unit>
        <trans-unit id="eef2a052e4462aff6add94764479243457e98b05" translate="yes" xml:space="preserve">
          <source>Enable the documented workaround for the back-to-back store errata of the UT699E/UT700 processor.</source>
          <target state="translated">启用UT699E/UT700处理器的背靠背存储勘误的文档化解决方法。</target>
        </trans-unit>
        <trans-unit id="decf2a901923b7e9eb5ca1ab92693295f143a06a" translate="yes" xml:space="preserve">
          <source>Enable the documented workaround for the single erratum of the Atmel AT697F processor (which corresponds to erratum #13 of the AT697E processor).</source>
          <target state="translated">启用 Atmel AT697F 处理器的单一故障(对应于 AT697E 处理器的故障 #13)的文档解决方法。</target>
        </trans-unit>
        <trans-unit id="bcb5bb2598740b13546a58b17f6d5aa7c7ba6853" translate="yes" xml:space="preserve">
          <source>Enable the documented workarounds for the floating-point errata and the data cache nullify errata of the UT699 processor.</source>
          <target state="translated">启用UT699处理器的浮点勘误和数据缓存无效勘误的文档化工作方法。</target>
        </trans-unit>
        <trans-unit id="43eeb910cdee4c766507663e6e771a799fe37d3f" translate="yes" xml:space="preserve">
          <source>Enable the double-precision reciprocal approximation instructions.</source>
          <target state="translated">启用双精度往复逼近指令。</target>
        </trans-unit>
        <trans-unit id="446e6f12ce2775419c21aa646c548678ff1569c1" translate="yes" xml:space="preserve">
          <source>Enable the double-precision reciprocal square root approximation instructions.</source>
          <target state="translated">启用双精度往复平方根逼近指令。</target>
        </trans-unit>
        <trans-unit id="71718fe9aa5b48da1b26c519c152f829f75fb0c0" translate="yes" xml:space="preserve">
          <source>Enable the extended &lt;code&gt;lrw&lt;/code&gt; instruction. This option defaults to on for CK801 and off otherwise.</source>
          <target state="translated">启用扩展的 &lt;code&gt;lrw&lt;/code&gt; 指令。CK801的此选项默认为开，否则为关。</target>
        </trans-unit>
        <trans-unit id="26a17bc6f3de31676776135a782cd9c993e95087" translate="yes" xml:space="preserve">
          <source>Enable the generation of conditional moves.</source>
          <target state="translated">启用条件动作的生成。</target>
        </trans-unit>
        <trans-unit id="04969a109a871e39815667dea2edea4731968533" translate="yes" xml:space="preserve">
          <source>Enable the group heuristic in the scheduler. This heuristic favors the instruction that belongs to a schedule group. This is enabled by default when scheduling is enabled, i.e. with</source>
          <target state="translated">启用调度器中的组启发式。这个启发式方法有利于属于调度组的指令。当调度被启用时,即在使用</target>
        </trans-unit>
        <trans-unit id="74416a1c4632bd2c9719e7f267cc78921917bec4" translate="yes" xml:space="preserve">
          <source>Enable the identity transformation for graphite. For every SCoP we generate the polyhedral representation and transform it back to gimple. Using</source>
          <target state="translated">启用石墨的身份转换。对于每一个SCoP,我们都会生成多面体表示并将其转换回gimple。使用</target>
        </trans-unit>
        <trans-unit id="d52969e42d36857a708d794bd442398a6f2b1d5e" translate="yes" xml:space="preserve">
          <source>Enable the isl based loop nest optimizer. This is a generic loop nest optimizer based on the Pluto optimization algorithms. It calculates a loop structure optimized for data-locality and parallelism. This option is experimental.</source>
          <target state="translated">启用基于isl的循环嵌套优化器。这是一个基于Pluto优化算法的通用循环嵌套优化器。它计算一个针对数据定位和并行性优化的循环结构。这个选项是试验性的。</target>
        </trans-unit>
        <trans-unit id="08b7ee5bf2b0eaab5c12a44d79b227e23ee0c0f5" translate="yes" xml:space="preserve">
          <source>Enable the last-instruction heuristic in the scheduler. This heuristic favors the instruction that is less dependent on the last instruction scheduled. This is enabled by default when scheduling is enabled, i.e. with</source>
          <target state="translated">启用调度器中的最后一条指令启发式。这个启发式方法倾向于对最后一条调度指令依赖性较小的指令。当启用了调度时,即使用了</target>
        </trans-unit>
        <trans-unit id="dc56e6084e464db3d7d083e493fb69fc336bcfc3" translate="yes" xml:space="preserve">
          <source>Enable the optimization pass in the HP-UX linker. Note this makes symbolic debugging impossible. It also triggers a bug in the HP-UX 8 and HP-UX 9 linkers in which they give bogus error messages when linking some programs.</source>
          <target state="translated">启用HP-UX链接器中的优化通道。注意,这使得符号调试变得不可能。它还会触发HP-UX 8和HP-UX 9链接器中的一个错误,当链接某些程序时,它们会给出虚假的错误信息。</target>
        </trans-unit>
        <trans-unit id="8008915ad05d64b6cc01c8698eac6fdda560f6c1" translate="yes" xml:space="preserve">
          <source>Enable the rank heuristic in the scheduler. This heuristic favors the instruction belonging to a basic block with greater size or frequency. This is enabled by default when scheduling is enabled, i.e. with</source>
          <target state="translated">启用调度器中的等级启发式。这个启发式倾向于属于基本块的指令,其大小或频率更高。当启用调度时,默认启用该功能,即使用</target>
        </trans-unit>
        <trans-unit id="e6ed1ceef09b312da3bb73bea4902c46d06845e0" translate="yes" xml:space="preserve">
          <source>Enable the reciprocal approximation instructions for both single and double precision.</source>
          <target state="translated">启用单精度和双精度的往复近似指令。</target>
        </trans-unit>
        <trans-unit id="4c8e53d3299e21b3cf3fba9ff55c2082c7b6b1ec" translate="yes" xml:space="preserve">
          <source>Enable the reciprocal square root approximation instructions for both single and double precision.</source>
          <target state="translated">启用单精度和双精度的往复平方根逼近指令。</target>
        </trans-unit>
        <trans-unit id="21fb72c5396788f3586c523b20f25c7cd0196802" translate="yes" xml:space="preserve">
          <source>Enable the sha512 and sha3 crypto extension. This also enables Advanced SIMD instructions. Use of this option with architectures prior to Armv8.2-A is not supported.</source>
          <target state="translated">启用 sha512 和 sha3 加密扩展。这也可以启用高级SIMD指令。不支持在Armv8.2-A之前的架构中使用该选项。</target>
        </trans-unit>
        <trans-unit id="ac17a049cdd1860b9740d6573dbf1dae4507b37b" translate="yes" xml:space="preserve">
          <source>Enable the single-precision reciprocal approximation instructions.</source>
          <target state="translated">启用单精度往复逼近指令。</target>
        </trans-unit>
        <trans-unit id="a4aef85fc3ef145e7cf3738dcc41b55cc33d82a4" translate="yes" xml:space="preserve">
          <source>Enable the single-precision reciprocal square root approximation instructions.</source>
          <target state="translated">启用单精度往复平方根逼近指令。</target>
        </trans-unit>
        <trans-unit id="0a29cdf0e1f32dd82e6b20680fbd0f552bb364b2" translate="yes" xml:space="preserve">
          <source>Enable the sm3 and sm4 crypto extension. This also enables Advanced SIMD instructions. Use of this option with architectures prior to Armv8.2-A is not supported.</source>
          <target state="translated">启用sm3和sm4加密扩展。这也可以启用高级SIMD指令。不支持在Armv8.2-A之前的架构中使用该选项。</target>
        </trans-unit>
        <trans-unit id="cab5f01ba7747ba0641df8f437ad352196c1c6d3" translate="yes" xml:space="preserve">
          <source>Enable the speculative instruction heuristic in the scheduler. This heuristic favors speculative instructions with greater dependency weakness. This is enabled by default when scheduling is enabled, i.e. with</source>
          <target state="translated">启用调度器中的推测性指令启发式。这个启发式指令倾向于依赖性更弱的推测性指令。当调度被启用时,即在使用</target>
        </trans-unit>
        <trans-unit id="e847a09656f326765748affab74d130a0fbbbfb3" translate="yes" xml:space="preserve">
          <source>Enable the use (disable) of the built-in functions that allow direct access to the cryptographic instructions that were added in version 2.07 of the PowerPC ISA.</source>
          <target state="translated">启用(禁用)内置功能,允许直接访问PowerPC ISA 2.07版本中增加的加密指令。</target>
        </trans-unit>
        <trans-unit id="0beb7325ebbd427ff6f653a5586006076fc19189" translate="yes" xml:space="preserve">
          <source>Enable the use of &lt;code&gt;GPREL&lt;/code&gt; relocations in the FDPIC ABI for data that is known to be in read-only sections. It&amp;rsquo;s enabled by default, except for</source>
          <target state="translated">在FDPIC ABI中启用对 &lt;code&gt;GPREL&lt;/code&gt; 重定位的使用，以用于已知在只读部分中的数据。默认情况下启用，除了</target>
        </trans-unit>
        <trans-unit id="4b3e38bf3ad012b6637b58a91ae68d4399ef997c" translate="yes" xml:space="preserve">
          <source>Enable the use of a minimum runtime environment - no static initializers or constructors. This is intended for memory-constrained devices. The compiler includes special symbols in some objects that tell the linker and runtime which code fragments are required.</source>
          <target state="translated">启用最小运行时环境--没有静态初始化器或构造器。这是为内存受限的设备准备的。编译器在一些对象中包含了特殊的符号,告诉链接器和运行时需要哪些代码片段。</target>
        </trans-unit>
        <trans-unit id="2e3906c56ec37b4268552279d6414d35519910f2" translate="yes" xml:space="preserve">
          <source>Enable the use of assembler directives only GAS understands.</source>
          <target state="translated">启用只有GAS才能理解的汇编器指令。</target>
        </trans-unit>
        <trans-unit id="8315949440093bd19b322b38da5ef593bd5c1273" translate="yes" xml:space="preserve">
          <source>Enable the use of bit manipulation instructions on SH2A.</source>
          <target state="translated">启用SH2A上的位操作指令。</target>
        </trans-unit>
        <trans-unit id="776b7d037afae7efec8fa9845c5ffbd3bad3e0de" translate="yes" xml:space="preserve">
          <source>Enable the use of conditional execution (default).</source>
          <target state="translated">启用条件执行(默认)。</target>
        </trans-unit>
        <trans-unit id="3f92036c53e4d3d87aa05d99ffc56331dbaf7cbe" translate="yes" xml:space="preserve">
          <source>Enable the use of conditional set instructions (default).</source>
          <target state="translated">启用条件集指令的使用(默认)。</target>
        </trans-unit>
        <trans-unit id="f02a7f12f7eb0e41accd67fcdeeacad0f7a7fbae" translate="yes" xml:space="preserve">
          <source>Enable the use of conditional-move instructions (default).</source>
          <target state="translated">启用条件移动指令的使用(默认)。</target>
        </trans-unit>
        <trans-unit id="8bd8c14864a3dc22ad6416f43c205d177280cc14" translate="yes" xml:space="preserve">
          <source>Enable the use of indexed loads. This can be problematic because some optimizers then assume that indexed stores exist, which is not the case.</source>
          <target state="translated">启用索引加载的使用。这可能会有问题,因为有些优化器会认为存在索引存储,而事实并非如此。</target>
        </trans-unit>
        <trans-unit id="fa24f968931ae6f6108870656a7843c7774cc339" translate="yes" xml:space="preserve">
          <source>Enable the use of multiply-accumulate instructions. Disabled by default.</source>
          <target state="translated">启用乘法累加指令的使用。默认情况下已禁用。</target>
        </trans-unit>
        <trans-unit id="d7a1f017f17fab4284673c060b8b2143eec98325" translate="yes" xml:space="preserve">
          <source>Enable the use of odd-numbered single-precision floating-point registers for the o32 ABI. This is the default for processors that are known to support these registers. When using the o32 FPXX ABI,</source>
          <target state="translated">启用o32 ABI使用奇数单精度浮点寄存器。这是已知支持这些寄存器的处理器的默认值。当使用o32 FPXX ABI时。</target>
        </trans-unit>
        <trans-unit id="ea76b09fecc8949f24ae03f9a3f42c9fa0287c50" translate="yes" xml:space="preserve">
          <source>Enable the use of pre/post modify with register displacement.</source>
          <target state="translated">启用前/后修改与寄存器位移的使用。</target>
        </trans-unit>
        <trans-unit id="6635132d2079387847468168f8edcfc7554ca84f" translate="yes" xml:space="preserve">
          <source>Enable the use of the instruction &lt;code&gt;fmovd&lt;/code&gt;. Check</source>
          <target state="translated">启用指令 &lt;code&gt;fmovd&lt;/code&gt; 的使用。检查一下</target>
        </trans-unit>
        <trans-unit id="a2fdf0058d830cee1f93b69f832936392dc9ed46" translate="yes" xml:space="preserve">
          <source>Enable tree pass &lt;var&gt;pass&lt;/var&gt;. See</source>
          <target state="translated">启用tree pass &lt;var&gt;pass&lt;/var&gt; 。看到</target>
        </trans-unit>
        <trans-unit id="b8f020346acd5709653f3c40d525659258a1b9db" translate="yes" xml:space="preserve">
          <source>Enable use of &lt;code&gt;bi&lt;/code&gt; or &lt;code&gt;bih&lt;/code&gt; instructions to implement jump tables.</source>
          <target state="translated">启用使用 &lt;code&gt;bi&lt;/code&gt; 或 &lt;code&gt;bih&lt;/code&gt; 指令来实现跳转表。</target>
        </trans-unit>
        <trans-unit id="79a73d3f193a6e6ff330a4b9de3265b919526bff" translate="yes" xml:space="preserve">
          <source>Enable use of the extended instructions of the FT32B processor.</source>
          <target state="translated">允许使用FT32B处理器的扩展指令。</target>
        </trans-unit>
        <trans-unit id="6d0438ac8bb52c3d5f5f9c3df1e29694d4f64211" translate="yes" xml:space="preserve">
          <source>Enable user-defined instructions.</source>
          <target state="translated">启用用户自定义指令。</target>
        </trans-unit>
        <trans-unit id="289e8ab3bafc79cd3d4d7a33238e966c5c4d7a05" translate="yes" xml:space="preserve">
          <source>Enable verbose cost model dumping in the debug dump files. This option is provided for use in debugging the compiler.</source>
          <target state="translated">在调试转储文件中启用详细的成本模型转储。这个选项是为了在调试编译器时使用。</target>
        </trans-unit>
        <trans-unit id="5698cf3230e865992f3f27c124b887d7d8c62160" translate="yes" xml:space="preserve">
          <source>Enable/disable bit-field layout compatible with the native Microsoft Windows compiler.</source>
          <target state="translated">开启/关闭与本地Microsoft Windows编译器兼容的位域布局。</target>
        </trans-unit>
        <trans-unit id="ec1922decad109f864b4cf7878296aa732c83b64" translate="yes" xml:space="preserve">
          <source>Enable/disable inlining of string operations.</source>
          <target state="translated">开启/关闭字符串操作的内联。</target>
        </trans-unit>
        <trans-unit id="77a9782fdfbab35d94a1e98b3a7fd934623ad240" translate="yes" xml:space="preserve">
          <source>Enable/disable the &lt;var&gt;__float128&lt;/var&gt; keyword for IEEE 128-bit floating point and use either software emulation for IEEE 128-bit floating point or hardware instructions.</source>
          <target state="translated">为IEEE 128位浮点启用/禁用 &lt;var&gt;__float128&lt;/var&gt; 关键字，并为IEEE 128位浮点使用软件仿真或使用硬件指令。</target>
        </trans-unit>
        <trans-unit id="eef257e319b773e37c267992617c97ed3ff87e5c" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of RCPSS, RCPPS, RSQRTSS and RSQRTPS instructions followed an additional Newton-Raphson step instead of doing a floating-point division.</source>
          <target state="translated">启用/禁用RCPSS、RCPPS、RSQRTSS和RSQRTPS指令的生成,这些指令遵循额外的Newton-Raphson步骤,而不是做浮点除法。</target>
        </trans-unit>
        <trans-unit id="ce9687705ccc627a85aa74c6222e1c475cf39951" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of floating point that depends on IEEE arithmetic.</source>
          <target state="translated">开启/关闭依赖于IEEE算术的浮点数的生成。</target>
        </trans-unit>
        <trans-unit id="e06af20ef568b69c3362691eda73268a45b5e6fb" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the 3DNow! instructions.</source>
          <target state="translated">启用/禁用3DNow!指令的生成。</target>
        </trans-unit>
        <trans-unit id="8ea30fdab63dafe3dc7fc652cf67136424f3b625" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the &lt;code&gt;sin&lt;/code&gt;, &lt;code&gt;cos&lt;/code&gt;, and &lt;code&gt;sqrt&lt;/code&gt; instructions on the 387 floating-point unit.</source>
          <target state="translated">在387浮点单元上启用/禁用 &lt;code&gt;sin&lt;/code&gt; ， &lt;code&gt;cos&lt;/code&gt; 和 &lt;code&gt;sqrt&lt;/code&gt; 指令的生成。</target>
        </trans-unit>
        <trans-unit id="d2ce898ea3fbbf85aca7bdcebad5257c4339a871" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the ADX instructions.</source>
          <target state="translated">启用/禁用ADX指令的生成。</target>
        </trans-unit>
        <trans-unit id="8c51cd7ffa80497e01030865d76bb3aa852e4b11" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the AES instructions.</source>
          <target state="translated">启用/禁用AES指令的生成。</target>
        </trans-unit>
        <trans-unit id="139f5148751f41ac5e236f52ce09ecaba429fae5" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the AVX instructions.</source>
          <target state="translated">启用/禁用AVX指令的生成。</target>
        </trans-unit>
        <trans-unit id="c03537f2a6f562c3bdf507ee0385caa610905340" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the AVX2 instructions.</source>
          <target state="translated">启用/禁用AVX2指令的生成。</target>
        </trans-unit>
        <trans-unit id="2f46ca2cd644ae06703a20fd137f758ec86b545b" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the AVX5124FMAPS instructions.</source>
          <target state="translated">启用/禁用AVX5124FMAPS指令的生成。</target>
        </trans-unit>
        <trans-unit id="07c3fb12af13a9cd69b78d9bc8b1bf44bce2f703" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the AVX5124VNNIW instructions.</source>
          <target state="translated">启用/禁用AVX5124VNNIW指令的生成。</target>
        </trans-unit>
        <trans-unit id="3754f28eb3ff315a901b1086241414b36cdc2445" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the AVX512BITALG instructions.</source>
          <target state="translated">启用/禁用AVX512BITALG指令的生成。</target>
        </trans-unit>
        <trans-unit id="9d757b2f48a6a1b6957e3c46cfd35f8cef5e43f2" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the AVX512BW instructions.</source>
          <target state="translated">启用/禁用AVX512BW指令的生成。</target>
        </trans-unit>
        <trans-unit id="d3c2cb946f575c062fed2315966b199b452fa19e" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the AVX512CD instructions.</source>
          <target state="translated">启用/禁用AVX512CD指令的生成。</target>
        </trans-unit>
        <trans-unit id="55f4758594e3826b45c045f868cd0c0b6fe314a5" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the AVX512DQ instructions.</source>
          <target state="translated">启用/禁用AVX512DQ指令的生成。</target>
        </trans-unit>
        <trans-unit id="868a5a7c9ba2cab10b4dbee05b59b72caa86a0f1" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the AVX512ER instructions.</source>
          <target state="translated">启用/禁用AVX512ER指令的生成。</target>
        </trans-unit>
        <trans-unit id="40cf4ec0c6bc30ab932552059f3f09cac003af63" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the AVX512F instructions.</source>
          <target state="translated">启用/禁用AVX512F指令的生成。</target>
        </trans-unit>
        <trans-unit id="ba0e32798c4a1b18ba185f7a8c7a840f7e7480c5" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the AVX512IFMA instructions.</source>
          <target state="translated">启用/禁用AVX512IFMA指令的生成。</target>
        </trans-unit>
        <trans-unit id="cfee43efb9eef88de6b588ce9a55a47d1e02ac8b" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the AVX512PF instructions.</source>
          <target state="translated">启用/禁用AVX512PF指令的生成。</target>
        </trans-unit>
        <trans-unit id="1d9376176900a884770b47d4b38ffe3800952fda" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the AVX512VBMI instructions.</source>
          <target state="translated">启用/禁用AVX512VBMI指令的生成。</target>
        </trans-unit>
        <trans-unit id="5315cd056026db5157cf29bd04c56d18b6d556b6" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the AVX512VBMI2 instructions.</source>
          <target state="translated">启用/禁用AVX512VBMI2指令的生成。</target>
        </trans-unit>
        <trans-unit id="ddf56de8dc48259cd81ab8285e90003fb25e73e2" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the AVX512VL instructions.</source>
          <target state="translated">启用/禁用AVX512VL指令的生成。</target>
        </trans-unit>
        <trans-unit id="26241a02deae96e24160a0ca3f3cc5c41033dbf3" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the AVX512VNNI instructions.</source>
          <target state="translated">启用/禁用AVX512VNNI指令的生成。</target>
        </trans-unit>
        <trans-unit id="84a8ab5234b9fa4c56baeffdaee98c552e89549f" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the AVX512VPOPCNTDQ instructions.</source>
          <target state="translated">启用/禁用AVX512VPOPCNTDQ指令的生成。</target>
        </trans-unit>
        <trans-unit id="dae7d1054e24eee8d8b487043aaad1fc5f1db574" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the BMI instructions.</source>
          <target state="translated">启用/禁用BMI指令的生成。</target>
        </trans-unit>
        <trans-unit id="3d72a8758536f6a87e94a41fe37b66f09beef533" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the BMI2 instructions.</source>
          <target state="translated">启用/禁用BMI2指令的生成。</target>
        </trans-unit>
        <trans-unit id="b738e70323169015d6a48d84ae40dd6c29e5217d" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the CLD before string moves.</source>
          <target state="translated">开启/关闭在字符串移动前生成CLD的功能。</target>
        </trans-unit>
        <trans-unit id="d65d8d65a18d1cfa6dc9c78ebdaad5ad563343cb" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the CLDEMOTE instructions.</source>
          <target state="translated">开启/关闭CLDEMOTE指令的生成。</target>
        </trans-unit>
        <trans-unit id="ccb6f558360b355b894e7ea63cd154a997ed12e8" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the CLFLUSHOPT instructions.</source>
          <target state="translated">开启/关闭CLFLUSHOPT指令的生成。</target>
        </trans-unit>
        <trans-unit id="f0801d5d70f8b9df1efe3aea49e8a0671ca5bfec" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the CLWB instructions.</source>
          <target state="translated">启用/禁用CLWB指令的生成。</target>
        </trans-unit>
        <trans-unit id="94ecea85bbdafb56613082f3e5be7c02237756ed" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the CLZERO instructions.</source>
          <target state="translated">开启/关闭CLZERO指令的生成。</target>
        </trans-unit>
        <trans-unit id="f8d79a3c698ec42fbe32e73864266b011f951b2f" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the CMPXCHG16B instructions.</source>
          <target state="translated">启用/禁用CMPXCHG16B指令的生成。</target>
        </trans-unit>
        <trans-unit id="b0bd05f01479f2861886a517faf455f95df939c9" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the CRC32 instructions.</source>
          <target state="translated">启用/禁用CRC32指令的生成。</target>
        </trans-unit>
        <trans-unit id="d6440333fc0c90bc6217f92335430eaed3b0c3e6" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the F16C instructions.</source>
          <target state="translated">启用/禁用F16C指令的生成。</target>
        </trans-unit>
        <trans-unit id="5cea65073f4a60c1177a3414fc29a42c91b72246" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the FMA instructions.</source>
          <target state="translated">启用/禁用FMA指令的生成。</target>
        </trans-unit>
        <trans-unit id="99871ac8f6615a85bb6ff6e756bf21d0a7db8138" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the FMA4 instructions.</source>
          <target state="translated">启用/禁用FMA4指令的生成。</target>
        </trans-unit>
        <trans-unit id="4820cc9a7748ec354eac413d8f383da9dd67e717" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the FSGSBASE instructions.</source>
          <target state="translated">启用/禁用FSGSBASE指令的生成。</target>
        </trans-unit>
        <trans-unit id="60644d857fe08e2846e93707df49f0bca9fb4a3e" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the FXSR instructions.</source>
          <target state="translated">启用/禁用FXSR指令的生成。</target>
        </trans-unit>
        <trans-unit id="0d58cb597f94125b583603aeaf0cb6d6fac80c1b" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the GFNI instructions.</source>
          <target state="translated">启用/禁用GFNI指令的生成。</target>
        </trans-unit>
        <trans-unit id="9578e9d5e6eece4df004759dd7fc90f39eea18e0" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the HLE instruction prefixes.</source>
          <target state="translated">启用/禁用HLE指令前缀的生成。</target>
        </trans-unit>
        <trans-unit id="549533ddadf886e04d518c98906dae343a33a8ce" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the LWP instructions.</source>
          <target state="translated">开启/关闭LWP指令的生成。</target>
        </trans-unit>
        <trans-unit id="8c3785d4101d06b824b0b36311920e0a30ccd2d9" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the LZCNT instructions.</source>
          <target state="translated">启用/禁用LZCNT指令的生成。</target>
        </trans-unit>
        <trans-unit id="574261210d9c97190453b59ddf32621dc2c86c69" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the MMX instructions.</source>
          <target state="translated">启用/禁用MMX指令的生成。</target>
        </trans-unit>
        <trans-unit id="45a7da12e51c3e52b7908907f0dfac053d1882c4" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the MOVBE instructions.</source>
          <target state="translated">启用/禁用MOVBE指令的生成。</target>
        </trans-unit>
        <trans-unit id="75cfc04edcd4dee4218a715cae2bd3ac7fa16a7e" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the MOVDIR64B instructions.</source>
          <target state="translated">启用/禁用MOVDIR64B指令的生成。</target>
        </trans-unit>
        <trans-unit id="c6371db2050fdd103c6d197692dfd64140187f4a" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the MOVDIRI instructions.</source>
          <target state="translated">启用/禁用MOVDIRI指令的生成。</target>
        </trans-unit>
        <trans-unit id="6e98e7f5d53a1e3439a31b14070244368aebebfe" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the MWAITX instructions.</source>
          <target state="translated">启用/禁用MWAITX指令的生成。</target>
        </trans-unit>
        <trans-unit id="dc37894f7a2ce025aaeba83cdca8f3ca819436f1" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the PCLMUL instructions.</source>
          <target state="translated">启用/禁用PCLMUL指令的生成。</target>
        </trans-unit>
        <trans-unit id="c6ecdb5d5fff5ea045de6d2ca8023861f04ebc4d" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the PCONFIG instructions.</source>
          <target state="translated">开启或关闭PCONFIG指令的生成。</target>
        </trans-unit>
        <trans-unit id="a081a1e7a08745213d7883c3b5236130fe755e13" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the PKU instructions.</source>
          <target state="translated">启用/禁用PKU指令的生成。</target>
        </trans-unit>
        <trans-unit id="e9e69747966699a82f308dbbadb71d6e9fb92d92" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the POPCNT instruction.</source>
          <target state="translated">启用/禁用POPCNT指令的生成。</target>
        </trans-unit>
        <trans-unit id="f9ed3efe60bd11688e60a3f2cb5a1ff252d812d0" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the PREFETCHW instruction.</source>
          <target state="translated">开启或关闭PREFETCHW指令的生成。</target>
        </trans-unit>
        <trans-unit id="006748470b229e9088cb61bc26a1257f2c9a8615" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the PREFETCHWT1 instructions.</source>
          <target state="translated">开启/关闭PREFETCHWT1指令的生成。</target>
        </trans-unit>
        <trans-unit id="2447c34a50f2bd64c3943526353f34051a55f5aa" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the PTWRITE instructions.</source>
          <target state="translated">启用/禁用PTWRITE指令的生成。</target>
        </trans-unit>
        <trans-unit id="5735ee8db2baf84da1ef868849fd1bf84c1f8c11" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the RDPID instructions.</source>
          <target state="translated">启用/禁用RDPID指令的生成。</target>
        </trans-unit>
        <trans-unit id="0b0a5749ac92e20b8e558766d0dd8d71d8adeeaf" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the RDRND instructions.</source>
          <target state="translated">启用/禁用RDRND指令的生成。</target>
        </trans-unit>
        <trans-unit id="4913a7bcb28cb1f12173c4058eaf61ab9315d7d3" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the RDSEED instructions.</source>
          <target state="translated">启用/禁用RDSEED指令的生成。</target>
        </trans-unit>
        <trans-unit id="300142c2ef84f7df525c1aa21af494a1e7bead9f" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the RTM instructions.</source>
          <target state="translated">启用/禁用RTM指令的生成。</target>
        </trans-unit>
        <trans-unit id="0d2ad4e123ffd7abb18aa9c974df2646f0d5508c" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the SAHF instructions.</source>
          <target state="translated">启用/禁用SAHF指令的生成。</target>
        </trans-unit>
        <trans-unit id="632f005a4b74a3843a3298d0871cbe50c5ad6aa9" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the SGX instructions.</source>
          <target state="translated">启用/禁用SGX指令的生成。</target>
        </trans-unit>
        <trans-unit id="6b57bd12c5e2df48fa7d7e43ba31d0995c7f5553" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the SHA instructions.</source>
          <target state="translated">启用/禁用SHA指令的生成。</target>
        </trans-unit>
        <trans-unit id="b5d7ecf6e517427fea4ad12abde111a42bd74cea" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the SSE instructions.</source>
          <target state="translated">启用/禁用SSE指令的生成。</target>
        </trans-unit>
        <trans-unit id="1f0972ae163067735798e2e6f4187300ae1137e4" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the SSE2 instructions.</source>
          <target state="translated">启用/禁用SSE2指令的生成。</target>
        </trans-unit>
        <trans-unit id="b03632fda4a2d3d92f1cf4eac7cca05dbc5a7516" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the SSE3 instructions.</source>
          <target state="translated">启用/禁用SSE3指令的生成。</target>
        </trans-unit>
        <trans-unit id="5e9b999ddb7457a054d66bdaa2de1a8f647ad215" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the SSE4 instructions (both SSE4.1 and SSE4.2).</source>
          <target state="translated">启用/禁用SSE4指令的生成(包括SSE4.1和SSE4.2)。</target>
        </trans-unit>
        <trans-unit id="21d0ef801e5d8043d92d8c50dd3d6daaddab55a0" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the SSE4A instructions.</source>
          <target state="translated">启用/禁用SSE4A指令的生成。</target>
        </trans-unit>
        <trans-unit id="ab7b78506bfd06d655fee8ea1068706000cbeacf" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the SSSE3 instructions.</source>
          <target state="translated">启用/禁用SSSE3指令的生成。</target>
        </trans-unit>
        <trans-unit id="f0e97c519b39b4830d04c86470ddf48b233a76c5" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the TBM instructions.</source>
          <target state="translated">启用/禁用TBM指令的生成。</target>
        </trans-unit>
        <trans-unit id="f3acd83d7172837bca3d0b44672674470b67ff86" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the VAES instructions.</source>
          <target state="translated">开启/关闭VAES指令的生成。</target>
        </trans-unit>
        <trans-unit id="9789894eea8adf6b88ad98db26058bba573138b8" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the VPCLMULQDQ instructions.</source>
          <target state="translated">启用/禁用VPCLMULQDQ指令的生成。</target>
        </trans-unit>
        <trans-unit id="b524ba4aef3ce6873b5b0e11048e23307db06122" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the WAITPKG instructions.</source>
          <target state="translated">开启/关闭WAITPKG指令的生成。</target>
        </trans-unit>
        <trans-unit id="a045e3b2a45d14170b9039170f7578c3d2713015" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the WBNOINVD instructions.</source>
          <target state="translated">开启/关闭WBNOINVD指令的生成。</target>
        </trans-unit>
        <trans-unit id="e40cfbce647b2c7f9ddf7f4f626656cc3a1bc167" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the XOP instructions.</source>
          <target state="translated">启用/禁用XOP指令的生成。</target>
        </trans-unit>
        <trans-unit id="af8da63fa2d12d8f18afd42b233c4d37ee867c63" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the XSAVE instructions.</source>
          <target state="translated">启用/禁用XSAVE指令的生成。</target>
        </trans-unit>
        <trans-unit id="1233b5b867e3f5dba2db3c438d3d6df18bde5ef8" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the XSAVEC instructions.</source>
          <target state="translated">启用/禁用XSAVEC指令的生成。</target>
        </trans-unit>
        <trans-unit id="a0a9e371f8da9a97cd65e604007429c825f18769" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the XSAVEOPT instructions.</source>
          <target state="translated">开启/关闭XSAVEOPT指令的生成。</target>
        </trans-unit>
        <trans-unit id="40e3ea0db494aa36d313e852fcbfd0f81556503b" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the XSAVES instructions.</source>
          <target state="translated">开启/关闭XSAVES指令的生成。</target>
        </trans-unit>
        <trans-unit id="fe009b6bf64ee12df513906e2d5837b5e1c97910" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the advanced bit instructions.</source>
          <target state="translated">启用/禁用高级位指令的生成。</target>
        </trans-unit>
        <trans-unit id="da867b2b85cc94070610ef36f96c5698f745a3ec" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the enhanced 3DNow! instructions.</source>
          <target state="translated">启用/禁用生成增强型3DNow!指令。</target>
        </trans-unit>
        <trans-unit id="7b3bd531bffe003f20aeec31cfccd8602793b41a" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the inline code to do small string operations and calling the library routines for large operations.</source>
          <target state="translated">开启/关闭内联代码的生成,进行小的字符串操作和调用库例程进行大的操作。</target>
        </trans-unit>
        <trans-unit id="902acc4f79ae76c2d32a7b6c514f8deac67c62fb" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the sse4.1 instructions.</source>
          <target state="translated">开启/关闭SSE4.1指令的生成。</target>
        </trans-unit>
        <trans-unit id="2a2818a0c367c053dac063d194f234ec531d06f2" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the sse4.2 instructions.</source>
          <target state="translated">开启/关闭SSE4.2指令的生成。</target>
        </trans-unit>
        <trans-unit id="37e917a07fa74d7e4e6dadb9579fbc16f97ae659" translate="yes" xml:space="preserve">
          <source>Enable/disable the shadow stack built-in functions from CET.</source>
          <target state="translated">开启/关闭CET的影子栈内置功能。</target>
        </trans-unit>
        <trans-unit id="e907f9b58bf0706e2b41d509db8ed99ad239f467" translate="yes" xml:space="preserve">
          <source>Enable/disable using ISA 3.0 hardware instructions to support the &lt;var&gt;__float128&lt;/var&gt; data type.</source>
          <target state="translated">使用ISA 3.0硬件说明启用/禁用以支持 &lt;var&gt;__float128&lt;/var&gt; 数据类型。</target>
        </trans-unit>
        <trans-unit id="41e598e82b094b60e50ff17f84b1a81de5e43516" translate="yes" xml:space="preserve">
          <source>Enabled at level</source>
          <target state="translated">启用的级别</target>
        </trans-unit>
        <trans-unit id="4b32f2d1dc57603e53cae07a8b8cf8dd5b0f7205" translate="yes" xml:space="preserve">
          <source>Enabled at levels</source>
          <target state="translated">启用的级别</target>
        </trans-unit>
        <trans-unit id="a2d7a1ae5b45c7663ff5c6c74c01638ab9ca0806" translate="yes" xml:space="preserve">
          <source>Enabled by</source>
          <target state="translated">通过以下方式启用</target>
        </trans-unit>
        <trans-unit id="87971a35b8aed293eb3378e3d8ac5721ecb5cb96" translate="yes" xml:space="preserve">
          <source>Enabled by default at</source>
          <target state="translated">默认情况下,在</target>
        </trans-unit>
        <trans-unit id="bcd7c586f5c724dfc09404aaf2a878d0206e9f76" translate="yes" xml:space="preserve">
          <source>Enabled by default when</source>
          <target state="translated">在以下情况下默认为启用</target>
        </trans-unit>
        <trans-unit id="4f94ea1c93e5664c46cd416ea64f7cc9936467d8" translate="yes" xml:space="preserve">
          <source>Enabled by default with</source>
          <target state="translated">默认启用</target>
        </trans-unit>
        <trans-unit id="261c7b9c3b776bec501c26a9d2fe4d480d9d16f7" translate="yes" xml:space="preserve">
          <source>Enabled by default.</source>
          <target state="translated">默认为已启用。</target>
        </trans-unit>
        <trans-unit id="d3d5b773827f9c4413a2fc452aae96dd06f591fd" translate="yes" xml:space="preserve">
          <source>Enabled for Alpha, AArch64 and x86 at levels</source>
          <target state="translated">在Alpha,AArch64和x86级别启用。</target>
        </trans-unit>
        <trans-unit id="217f8e562e876828812e90f53725615d6901cc9d" translate="yes" xml:space="preserve">
          <source>Enabled for x86 at levels</source>
          <target state="translated">启用x86的级别</target>
        </trans-unit>
        <trans-unit id="44ce21fc6a64ad296ee8e3cda3bcb2b9759adebf" translate="yes" xml:space="preserve">
          <source>Enabled with</source>
          <target state="translated">启用了</target>
        </trans-unit>
        <trans-unit id="979f6df4ed2e6e9238efa8b3ebc9f087264e476a" translate="yes" xml:space="preserve">
          <source>Enables (</source>
          <target state="translated">启用(</target>
        </trans-unit>
        <trans-unit id="7eae3793cec99e5fa487fe453e12770d55076d5b" translate="yes" xml:space="preserve">
          <source>Enables (or disables) reading and writing of 16- and 32- bit values from addresses that are not 16- or 32- bit aligned. By default unaligned access is disabled for all pre-ARMv6, all ARMv6-M and for ARMv8-M Baseline architectures, and enabled for all other architectures. If unaligned access is not enabled then words in packed data structures are accessed a byte at a time.</source>
          <target state="translated">启用(或禁用)从未对齐的16位或32位地址读写16位和32位值。默认情况下,对于所有preARMv6、所有ARMv6-M和ARMv8-M基线架构,不对齐访问是禁用的,而对于所有其他架构,不对齐访问是启用的。如果不启用不对齐访问,那么打包数据结构中的字每次只访问一个字节。</target>
        </trans-unit>
        <trans-unit id="b65eaeca3be0a544da578e950cb68230b9d67b03" translate="yes" xml:space="preserve">
          <source>Enables IVC2 scheduling. IVC2 is a 64-bit VLIW coprocessor.</source>
          <target state="translated">启用IVC2调度。IVC2是一个64位VLIW协处理器。</target>
        </trans-unit>
        <trans-unit id="f8bfc926b8449de54aa34c3f95b4955d0fe52d4e" translate="yes" xml:space="preserve">
          <source>Enables all inter-procedural analysis dumps.</source>
          <target state="translated">启用所有程序间分析转储。</target>
        </trans-unit>
        <trans-unit id="39e032a23d350be5be02b628822ab23ba3864dfe" translate="yes" xml:space="preserve">
          <source>Enables all the optional instructions&amp;mdash;average, multiply, divide, bit operations, leading zero, absolute difference, min/max, clip, and saturation.</source>
          <target state="translated">启用所有可选指令-平均，乘法，除法，位运算，前导零，绝对差，最小/最大，限幅和饱和度。</target>
        </trans-unit>
        <trans-unit id="dcd06b68e12a4e252dc788f4fd7792582f994c23" translate="yes" xml:space="preserve">
          <source>Enables expression of values of induction variables in later iterations of the unrolled loop using the value in the first iteration. This breaks long dependency chains, thus improving efficiency of the scheduling passes.</source>
          <target state="translated">使得在以后的未滚动循环迭代中,可以使用第一次迭代中的值来表达感应变量的值。这样可以打破长长的依赖链,从而提高调度通道的效率。</target>
        </trans-unit>
        <trans-unit id="7564b980df27ae9794a4d64f8c88854f784c151d" translate="yes" xml:space="preserve">
          <source>Enables or disables the use of the string manipulation instructions &lt;code&gt;SMOVF&lt;/code&gt;, &lt;code&gt;SCMPU&lt;/code&gt;, &lt;code&gt;SMOVB&lt;/code&gt;, &lt;code&gt;SMOVU&lt;/code&gt;, &lt;code&gt;SUNTIL&lt;/code&gt;&lt;code&gt;SWHILE&lt;/code&gt; and also the &lt;code&gt;RMPA&lt;/code&gt; instruction. These instructions may prefetch data, which is not safe to do if accessing an I/O register. (See section 12.2.7 of the RX62N Group User&amp;rsquo;s Manual for more information).</source>
          <target state="translated">启用或禁用字符串操作指令 &lt;code&gt;SMOVF&lt;/code&gt; ， &lt;code&gt;SCMPU&lt;/code&gt; ， &lt;code&gt;SMOVB&lt;/code&gt; ， &lt;code&gt;SMOVU&lt;/code&gt; ， &lt;code&gt;SUNTIL&lt;/code&gt; &lt;code&gt;SWHILE&lt;/code&gt; 以及 &lt;code&gt;RMPA&lt;/code&gt; 指令的使用。这些指令可能会预取数据，如果访问I / O寄存器，这样做是不安全的。（有关更多信息，请参见RX62N组用户手册的12.2.7节）。</target>
        </trans-unit>
        <trans-unit id="b2d56a3e8dc64cdea92b5b177de5eee2ddc022a5" translate="yes" xml:space="preserve">
          <source>Enables support for &lt;code&gt;double&lt;/code&gt; and &lt;code&gt;long long&lt;/code&gt; types to be aligned on 8-byte boundaries. The default is to restrict the alignment of all objects to at most 4-bytes. When</source>
          <target state="translated">启用对 &lt;code&gt;double&lt;/code&gt; 和 &lt;code&gt;long long&lt;/code&gt; 类型的支持，使其在8字节边界上对齐。默认设置是将所有对象的对齐限制为最多4个字节。什么时候</target>
        </trans-unit>
        <trans-unit id="85b9ecfc95ed087be71f719ded533eb947f09555" translate="yes" xml:space="preserve">
          <source>Enables support for all single- and double-precision floating-point hardware extensions. Not available for ARC EM.</source>
          <target state="translated">支持所有单精度和双精度浮点硬件扩展。不适用于ARC EM。</target>
        </trans-unit>
        <trans-unit id="f75e5afbbe9ab70b1263a70cb8894e0664caf0b1" translate="yes" xml:space="preserve">
          <source>Enables support for all single-precision floating-point hardware extensions.</source>
          <target state="translated">启用对所有单精度浮点硬件扩展的支持。</target>
        </trans-unit>
        <trans-unit id="7883565cb4fb9258e363d1f2d7f38e140fa66bc4" translate="yes" xml:space="preserve">
          <source>Enables support for double-precision floating-point and fused multiply and add hardware extensions. This option includes option &amp;lsquo;</source>
          <target state="translated">启用对双精度浮点和融合乘法与添加硬件扩展的支持。此选项包括选项&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="09688a51318111fb1133a1873f85c86a0dd2d24a" translate="yes" xml:space="preserve">
          <source>Enables support for double-precision floating-point hardware extensions using double-precision assist instructions. All single-precision floating-point hardware extensions are also enabled. This option is only available for ARC EM.</source>
          <target state="translated">使用双精度辅助指令支持双精度浮点硬件扩展。所有单精度浮点硬件扩展也被启用。该选项仅适用于ARC EM。</target>
        </trans-unit>
        <trans-unit id="998d962adb014531e7dc98dfd0f68752292543ee" translate="yes" xml:space="preserve">
          <source>Enables support for double-precision floating-point hardware extensions using double-precision assist instructions. The single-precision floating-point and fused multiply and add hardware extensions are also enabled. This option is only available for ARC EM.</source>
          <target state="translated">使用双精度辅助指令支持双精度浮点硬件扩展。单精度浮点和融合乘法和加法硬件扩展也被启用。此选项仅适用于ARC EM。</target>
        </trans-unit>
        <trans-unit id="4d9fab6d5bc5404d7e456a561365555b9e55a46b" translate="yes" xml:space="preserve">
          <source>Enables support for double-precision floating-point hardware extensions using double-precision assist instructions. The single-precision floating-point extension is also enabled. This option is only available for ARC EM.</source>
          <target state="translated">使用双精度辅助指令支持双精度浮点硬件扩展。单精度浮点扩展也被启用。该选项仅适用于ARC EM。</target>
        </trans-unit>
        <trans-unit id="8714aef39627cf0d1b3a7e36332dd7526fef4382" translate="yes" xml:space="preserve">
          <source>Enables support for double-precision floating-point hardware extensions using double-precision assist instructions. The single-precision floating-point, square-root, and divide extensions are also enabled. This option is only available for ARC EM.</source>
          <target state="translated">使用双精度辅助指令,支持双精度浮点硬件扩展,同时启用单精度浮点、平方根和除法扩展。单精度浮点、平方根和除法扩展也被启用。该选项仅适用于ARC EM。</target>
        </trans-unit>
        <trans-unit id="88614dbf859eb550fe6ea83089c08ee2a35b6c5a" translate="yes" xml:space="preserve">
          <source>Enables support for double-precision floating-point hardware extensions. The single-precision floating-point extension is also enabled. Not available for ARC EM.</source>
          <target state="translated">启用对双精度浮点硬件扩展的支持,同时启用单精度浮点扩展。单精度浮点扩展也被启用。不适用于ARC EM。</target>
        </trans-unit>
        <trans-unit id="ed75b445d9416dbdcca6532a5b9e4ba16b46347a" translate="yes" xml:space="preserve">
          <source>Enables support for double-precision floating-point, square-root and divide hardware extensions. This option includes option &amp;lsquo;</source>
          <target state="translated">支持双精度浮点，平方根和除法硬件扩展。此选项包括选项&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="4020a8753a0799a59f9043cec8f1b76a8cbf21f5" translate="yes" xml:space="preserve">
          <source>Enables support for single-precision floating-point and fused multiply and add hardware extensions.</source>
          <target state="translated">实现对单精度浮点和融合乘法和加法硬件扩展的支持。</target>
        </trans-unit>
        <trans-unit id="739ef3a6f4ad193608707def042ed976fbb38794" translate="yes" xml:space="preserve">
          <source>Enables support for single-precision floating-point hardware extensions.</source>
          <target state="translated">启用对单精度浮点硬件扩展的支持。</target>
        </trans-unit>
        <trans-unit id="69030e58955d3b24f425bf1f743dd072b9ea41e4" translate="yes" xml:space="preserve">
          <source>Enables support for single-precision floating-point, square-root and divide hardware extensions.</source>
          <target state="translated">实现对单精度浮点、平方根和除法硬件扩展的支持。</target>
        </trans-unit>
        <trans-unit id="dd589dcd1e2f89f81d2aa1944b9d5b300d0537d9" translate="yes" xml:space="preserve">
          <source>Enables support for specific floating-point hardware extensions for ARCv2 cores. Supported values for &lt;var&gt;fpu&lt;/var&gt; are:</source>
          <target state="translated">为ARCv2内核启用对特定浮点硬件扩展的支持。 &lt;var&gt;fpu&lt;/var&gt; 支持的值为：</target>
        </trans-unit>
        <trans-unit id="40edc654abf50990a91d4feb4df5e9d34bf7f47f" translate="yes" xml:space="preserve">
          <source>Enables support for the RH850 version of the V850 ABI. This is the default. With this version of the ABI the following rules apply:</source>
          <target state="translated">启用对 V850 ABI 的 RH850 版本的支持。这是默认值。对于此版本的 ABI,适用以下规则。</target>
        </trans-unit>
        <trans-unit id="a3ccc0d52f2a100abeb7168c2966e22df181fb16" translate="yes" xml:space="preserve">
          <source>Enables support for the old GCC version of the V850 ABI. With this version of the ABI the following rules apply:</source>
          <target state="translated">启用对 V850 ABI 旧版 GCC 的支持。对于此版本的 ABI,适用以下规则。</target>
        </trans-unit>
        <trans-unit id="13d14b8a88583d4801772d41f78d731f585ac76d" translate="yes" xml:space="preserve">
          <source>Enables the 32-bit coprocessor&amp;rsquo;s instructions.</source>
          <target state="translated">启用32位协处理器的指令。</target>
        </trans-unit>
        <trans-unit id="37f8bcfc01e8c9f171283b3e6b96664748ea2f0b" translate="yes" xml:space="preserve">
          <source>Enables the 64-bit coprocessor&amp;rsquo;s instructions.</source>
          <target state="translated">启用64位协处理器的指令。</target>
        </trans-unit>
        <trans-unit id="866afe4dc503faaed460c73ebf4e30e8a9116810" translate="yes" xml:space="preserve">
          <source>Enables the &lt;code&gt;abs&lt;/code&gt; instruction, which is the absolute difference between two registers.</source>
          <target state="translated">启用 &lt;code&gt;abs&lt;/code&gt; 指令，这是两个寄存器之间的绝对差。</target>
        </trans-unit>
        <trans-unit id="50cf3b6e541adf62bd77b142fc53a61d05fc7c9c" translate="yes" xml:space="preserve">
          <source>Enables the &lt;code&gt;ave&lt;/code&gt; instruction, which computes the average of two registers.</source>
          <target state="translated">启用 &lt;code&gt;ave&lt;/code&gt; 指令，该指令计算两个寄存器的平均值。</target>
        </trans-unit>
        <trans-unit id="2e8478914d75d996b9e9464d4ca7119db6662af4" translate="yes" xml:space="preserve">
          <source>Enables the &lt;code&gt;clip&lt;/code&gt; instruction. Note that</source>
          <target state="translated">启用 &lt;code&gt;clip&lt;/code&gt; 指令。注意</target>
        </trans-unit>
        <trans-unit id="e97f2d1656d0f25d2a745cdd7d099a3de6f71833" translate="yes" xml:space="preserve">
          <source>Enables the &lt;code&gt;div&lt;/code&gt; and &lt;code&gt;divu&lt;/code&gt; instructions.</source>
          <target state="translated">启用 &lt;code&gt;div&lt;/code&gt; 和 &lt;code&gt;divu&lt;/code&gt; 指令。</target>
        </trans-unit>
        <trans-unit id="13fbaebc3f1567a809a1ff5ab5607726671f6a6a" translate="yes" xml:space="preserve">
          <source>Enables the &lt;code&gt;leadz&lt;/code&gt; (leading zero) instruction.</source>
          <target state="translated">启用 &lt;code&gt;leadz&lt;/code&gt; （前导零）指令。</target>
        </trans-unit>
        <trans-unit id="1da519d84df5ff1b705dd7abe77d948ec006a771" translate="yes" xml:space="preserve">
          <source>Enables the &lt;code&gt;min&lt;/code&gt; and &lt;code&gt;max&lt;/code&gt; instructions.</source>
          <target state="translated">启用 &lt;code&gt;min&lt;/code&gt; 和 &lt;code&gt;max&lt;/code&gt; 指令。</target>
        </trans-unit>
        <trans-unit id="4da5357bac4df4fb4da7516696ce5726e90631ac" translate="yes" xml:space="preserve">
          <source>Enables the &lt;code&gt;repeat&lt;/code&gt; and &lt;code&gt;erepeat&lt;/code&gt; instructions, used for low-overhead looping.</source>
          <target state="translated">启用 &lt;code&gt;repeat&lt;/code&gt; 和 &lt;code&gt;erepeat&lt;/code&gt; 指令，用于低开销循环。</target>
        </trans-unit>
        <trans-unit id="b4f230bdb2809992da1b8ee11728eb1397ea6487" translate="yes" xml:space="preserve">
          <source>Enables the bit operation instructions&amp;mdash;bit test (&lt;code&gt;btstm&lt;/code&gt;), set (&lt;code&gt;bsetm&lt;/code&gt;), clear (&lt;code&gt;bclrm&lt;/code&gt;), invert (&lt;code&gt;bnotm&lt;/code&gt;), and test-and-set (&lt;code&gt;tas&lt;/code&gt;).</source>
          <target state="translated">启用位操作指令-位测试（ &lt;code&gt;btstm&lt;/code&gt; ），置位（ &lt;code&gt;bsetm&lt;/code&gt; ），清除（ &lt;code&gt;bclrm&lt;/code&gt; ），取反（ &lt;code&gt;bnotm&lt;/code&gt; ）和测试设置（ &lt;code&gt;tas&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="650b34422af73f1c39adc7884ebaf0f44be9cbe6" translate="yes" xml:space="preserve">
          <source>Enables the coprocessor instructions. By default, this is a 32-bit coprocessor. Note that the coprocessor is normally enabled via the</source>
          <target state="translated">启用协处理器指令。默认情况下,这是一个32位协处理器。请注意,协处理器通常是通过以下方式启用的</target>
        </trans-unit>
        <trans-unit id="849d54c65b67142ad3610bf0ff41505e124671a1" translate="yes" xml:space="preserve">
          <source>Enables the cryptographic instructions on &amp;lsquo;</source>
          <target state="translated">启用&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="e300897cde7331a4be041e33bbcd7fc9ca650ebe" translate="yes" xml:space="preserve">
          <source>Enables the generation of position independent data. When enabled any access to constant data is done via an offset from a base address held in a register. This allows the location of constant data to be determined at run time without requiring the executable to be relocated, which is a benefit to embedded applications with tight memory constraints. Data that can be modified is not affected by this option.</source>
          <target state="translated">启用位置独立数据的生成。当启用时,对常量数据的任何访问都是通过与寄存器中的基地址的偏移来完成的。这允许在运行时确定常量数据的位置,而不需要重新定位可执行文件,这对内存紧张的嵌入式应用是有好处的。可以修改的数据不受此选项的影响。</target>
        </trans-unit>
        <trans-unit id="cf1918bfd22c209206d2846ea3d88a19e3a73f7d" translate="yes" xml:space="preserve">
          <source>Enables the loop invariant motion pass in the RTL loop optimizer. Enabled at level</source>
          <target state="translated">启用RTL循环优化器中的循环不变运动通道。启用级别</target>
        </trans-unit>
        <trans-unit id="ecd974872f6eca7f7d4ae7dac04ee2a0a333973d" translate="yes" xml:space="preserve">
          <source>Enables the multiplication and multiply-accumulate instructions.</source>
          <target state="translated">启用乘法和乘法累加指令。</target>
        </trans-unit>
        <trans-unit id="7fc40693c14939b54a70a171fa80eb19af8d1f4b" translate="yes" xml:space="preserve">
          <source>Enables the saturation instructions. Note that the compiler does not currently generate these itself, but this option is included for compatibility with other tools, like &lt;code&gt;as&lt;/code&gt;.</source>
          <target state="translated">启用饱和度指令。需要注意的是编译器不产生目前这些本身，而是这个选项是为了与其他工具，如兼容性 &lt;code&gt;as&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e1d7284a520ac6d5afcc167354eeade161094006" translate="yes" xml:space="preserve">
          <source>Enables the use of a linker plugin during link-time optimization. This option relies on plugin support in the linker, which is available in gold or in GNU ld 2.21 or newer.</source>
          <target state="translated">在链接时间优化期间启用链接器插件。这个选项依赖于链接器中的插件支持,在gold或GNU ld 2.21或更新版本中可用。</target>
        </trans-unit>
        <trans-unit id="118989c6873866bc4e811127fbd742299b49d5aa" translate="yes" xml:space="preserve">
          <source>Enables the use of the e3v5 LOOP instruction. The use of this instruction is not enabled by default when the e3v5 architecture is selected because its use is still experimental.</source>
          <target state="translated">启用e3v5 LOOP指令的使用。当选择e3v5架构时,该指令的使用默认不启用,因为它的使用仍是试验性的。</target>
        </trans-unit>
        <trans-unit id="e218c1fa9772e443eea87ffbfc5f0dee5a840cd5" translate="yes" xml:space="preserve">
          <source>Enables using Neon to handle scalar 64-bits operations. This is disabled by default since the cost of moving data from core registers to Neon is high.</source>
          <target state="translated">启用Neon处理64位标量操作。由于将数据从核心寄存器转移到Neon的成本很高,所以默认情况下是禁用的。</target>
        </trans-unit>
        <trans-unit id="93ce405e36a27a5a639a5f340a06317ff8160589" translate="yes" xml:space="preserve">
          <source>Enabling profiling and extra run-time error checking.</source>
          <target state="translated">启用剖析和额外的运行时错误检查。</target>
        </trans-unit>
        <trans-unit id="e90d4bd4a0cd6ad11d1267ee1ab362b6754a6129" translate="yes" xml:space="preserve">
          <source>Enabling this option effectively enables the following warnings:</source>
          <target state="translated">启用该选项可有效地启用以下警告:</target>
        </trans-unit>
        <trans-unit id="5821fec7ee87050117e2081a31b307f34868a8ad" translate="yes" xml:space="preserve">
          <source>Encoding</source>
          <target state="translated">Encoding</target>
        </trans-unit>
        <trans-unit id="1819780111faf7544a66daa1d16d7611734230e4" translate="yes" xml:space="preserve">
          <source>End lock elision on a lock variable. Memory order must be &lt;code&gt;__ATOMIC_RELEASE&lt;/code&gt; or stronger.</source>
          <target state="translated">在锁变量上结束锁省略。内存顺序必须为 &lt;code&gt;__ATOMIC_RELEASE&lt;/code&gt; 或更高。</target>
        </trans-unit>
        <trans-unit id="69cc11cd813a9fd03e4e1fc6cf5b510b36e19495" translate="yes" xml:space="preserve">
          <source>Enforces total ordering with all other &lt;code&gt;__ATOMIC_SEQ_CST&lt;/code&gt; operations.</source>
          <target state="translated">与所有其他 &lt;code&gt;__ATOMIC_SEQ_CST&lt;/code&gt; 操作一起强制执行总排序。</target>
        </trans-unit>
        <trans-unit id="73b1dc6c07adcccbcc5d5e8b0eff931a874c6d38" translate="yes" xml:space="preserve">
          <source>Enumerator Attributes</source>
          <target state="translated">枚举者属性</target>
        </trans-unit>
        <trans-unit id="761809a73bf6c1d0fb389d9bcb324c7d577436ca" translate="yes" xml:space="preserve">
          <source>Env vars that affect GCC.</source>
          <target state="translated">影响GCC的环境变量。</target>
        </trans-unit>
        <trans-unit id="ea26afcbc28cf64cc5104756e2576f023e89221a" translate="yes" xml:space="preserve">
          <source>Epiphany&amp;mdash;</source>
          <target state="translated">Epiphany&amp;mdash;</target>
        </trans-unit>
        <trans-unit id="fdd6abe4d3e43555fd6a8a4c1cf45b848e487e53" translate="yes" xml:space="preserve">
          <source>Equivalent to</source>
          <target state="translated">相当于</target>
        </trans-unit>
        <trans-unit id="0492deafa8eba22fc0afe8f6e0c0ba64239ba223" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;r&lt;/code&gt;; retained for backwards compatibility.</source>
          <target state="translated">等效于 &lt;code&gt;r&lt;/code&gt; ; 保留以向后兼容。</target>
        </trans-unit>
        <trans-unit id="5ca07fcd394d3a2e5866991bf00cbd021a139de4" translate="yes" xml:space="preserve">
          <source>Errors in the 1990 ISO C standard were corrected in two Technical Corrigenda published in 1994 and 1996. GCC does not support the uncorrected version.</source>
          <target state="translated">1994年和1996年出版的两份技术更正中纠正了1990年ISO C标准中的错误。GCC不支持未更正的版本。</target>
        </trans-unit>
        <trans-unit id="9bd134a89f5b4b95f3127d3f912224b4af14b70c" translate="yes" xml:space="preserve">
          <source>Errors in the 1999 ISO C standard were corrected in three Technical Corrigenda published in 2001, 2004 and 2007. GCC does not support the uncorrected version.</source>
          <target state="translated">在2001年、2004年和2007年出版的三份技术更正中纠正了1999年ISO C标准中的错误。GCC不支持未更正的版本。</target>
        </trans-unit>
        <trans-unit id="6e25566cabac14a5da9bfa8653af8b052717aff4" translate="yes" xml:space="preserve">
          <source>Estimate on average number of instructions that are executed before prefetch finishes. The distance prefetched ahead is proportional to this constant. Increasing this number may also lead to less streams being prefetched (see</source>
          <target state="translated">估算预取结束前平均执行的指令数。前面预取的距离与这个常数成正比。增加这个数字也可能会导致预取的指令流减少(参见</target>
        </trans-unit>
        <trans-unit id="72b4ac99601ca6a847d5bc2efd8309225cad447d" translate="yes" xml:space="preserve">
          <source>Evaluate member access, array subscripting, and shift expressions in left-to-right order, and evaluate assignment in right-to-left order, as adopted for C++17. Enabled by default with</source>
          <target state="translated">以从左到右的顺序评估成员访问、数组下标和移位表达式,并以从右到左的顺序评估赋值,正如C++17所采用的那样。缺省情况下,启用了</target>
        </trans-unit>
        <trans-unit id="ed6e92089eb6b24b347c4f30cb7670720994b11e" translate="yes" xml:space="preserve">
          <source>Even if</source>
          <target state="translated">即使</target>
        </trans-unit>
        <trans-unit id="8ba62c67150da80165ae50905d020111dae00562" translate="yes" xml:space="preserve">
          <source>Even if a recovery mode is turned on the compiler side, it needs to be also enabled on the runtime library side, otherwise the failures are still fatal. The runtime library defaults to &lt;code&gt;halt_on_error=0&lt;/code&gt; for ThreadSanitizer and UndefinedBehaviorSanitizer, while default value for AddressSanitizer is &lt;code&gt;halt_on_error=1&lt;/code&gt;. This can be overridden through setting the &lt;code&gt;halt_on_error&lt;/code&gt; flag in the corresponding environment variable.</source>
          <target state="translated">即使在编译器端启用了恢复模式，也需要在运行时库端启用它，否则失败仍然是致命的。对于ThreadSanitizer和UndefinedBehaviorSanitizer，运行时库的默认值为 &lt;code&gt;halt_on_error=0&lt;/code&gt; ，而AddressSanitizer的默认值为 &lt;code&gt;halt_on_error=1&lt;/code&gt; 。可以通过在相应的环境变量中设置 &lt;code&gt;halt_on_error&lt;/code&gt; 标志来覆盖它。</target>
        </trans-unit>
        <trans-unit id="da53370f643fa43e1823dc15023009c950cb897a" translate="yes" xml:space="preserve">
          <source>Even if a zero-length bit-field is not followed by a normal bit-field, it may still affect the alignment of the structure:</source>
          <target state="translated">即使零长度的位字段后面没有正常的位字段,也可能影响结构的排列。</target>
        </trans-unit>
        <trans-unit id="9b825b64ce454de632ebee37b594db5436e47422" translate="yes" xml:space="preserve">
          <source>Even if this switch is enabled, not all function calls are turned into long calls. The heuristic is that static functions, functions that have the &lt;code&gt;short_call&lt;/code&gt; attribute, functions that are inside the scope of a &lt;code&gt;#pragma no_long_calls&lt;/code&gt; directive, and functions whose definitions have already been compiled within the current compilation unit are not turned into long calls. The exceptions to this rule are that weak function definitions, functions with the &lt;code&gt;long_call&lt;/code&gt; attribute or the &lt;code&gt;section&lt;/code&gt; attribute, and functions that are within the scope of a &lt;code&gt;#pragma long_calls&lt;/code&gt; directive are always turned into long calls.</source>
          <target state="translated">即使启用此开关，也不是所有的函数调用都变成长调用。启发式方法是，静态函数，具有 &lt;code&gt;short_call&lt;/code&gt; 属性的函数，在 &lt;code&gt;#pragma no_long_calls&lt;/code&gt; 指令范围内的函数以及定义已在当前编译单元中编译的函数不会转换为长调用。该规则的例外是弱函数定义，具有 &lt;code&gt;long_call&lt;/code&gt; 属性或 &lt;code&gt;section&lt;/code&gt; 属性的函数以及在 &lt;code&gt;#pragma long_calls&lt;/code&gt; 指令范围内的函数始终会转换为长调用。</target>
        </trans-unit>
        <trans-unit id="a177b98fd2580c16f017a412cd7670171b404cf0" translate="yes" xml:space="preserve">
          <source>Even if you specify</source>
          <target state="translated">即使你指定了</target>
        </trans-unit>
        <trans-unit id="026e995923c6387a8240f24bd1c3774f9d66883c" translate="yes" xml:space="preserve">
          <source>Even register</source>
          <target state="translated">甚至注册</target>
        </trans-unit>
        <trans-unit id="1873ee5db4140cfb18dab53240c9f43c6ee8669a" translate="yes" xml:space="preserve">
          <source>Even though &lt;code&gt;sum&lt;/code&gt; is accumulated in the loop, no use is made of that summation, so the accumulation can be removed.</source>
          <target state="translated">即使在循环中累积了 &lt;code&gt;sum&lt;/code&gt; ，也没有使用该总和，因此可以删除累积。</target>
        </trans-unit>
        <trans-unit id="0b22f73b585732fa4671fb4003533ee7b0a1cf1d" translate="yes" xml:space="preserve">
          <source>Even-numbered D register</source>
          <target state="translated">偶数D寄存器</target>
        </trans-unit>
        <trans-unit id="7a684983474ccc7c72520e56a87f8aeb051b1c6b" translate="yes" xml:space="preserve">
          <source>Even-numbered accumulator register.</source>
          <target state="translated">偶数的累加器寄存器。</target>
        </trans-unit>
        <trans-unit id="5d57aa9755d20359a2247e4c26c56f18f53bb2c4" translate="yes" xml:space="preserve">
          <source>Every data object has an alignment requirement. The alignment requirement for all data except structures, unions, and arrays is either the size of the object or the current packing size (specified with either the &lt;code&gt;aligned&lt;/code&gt; attribute or the &lt;code&gt;pack&lt;/code&gt; pragma), whichever is less. For structures, unions, and arrays, the alignment requirement is the largest alignment requirement of its members. Every object is allocated an offset so that:</source>
          <target state="translated">每个数据对象都有一个对齐要求。除结构，并集和数组以外的所有数据的对齐要求是对象的大小或当前的包装大小（由 &lt;code&gt;aligned&lt;/code&gt; 属性或 &lt;code&gt;pack&lt;/code&gt; pragma指定），以较小者为准。对于结构，联合和数组，对齐要求是其成员中最大的对齐要求。每个对象都分配有一个偏移量，以便：</target>
        </trans-unit>
        <trans-unit id="f8971cb366f8a5972e5437f17d61872668933fb6" translate="yes" xml:space="preserve">
          <source>Exact power of 2</source>
          <target state="translated">2的精确功率</target>
        </trans-unit>
        <trans-unit id="54ce059465b2a026c1f41bec2bf7eb93331ac554" translate="yes" xml:space="preserve">
          <source>Exactly like</source>
          <target state="translated">就像...</target>
        </trans-unit>
        <trans-unit id="ec471d84b36457f0d9d75c03377c9e3cd5f3de93" translate="yes" xml:space="preserve">
          <source>Example of use:</source>
          <target state="translated">使用实例:</target>
        </trans-unit>
        <trans-unit id="861245b8779c3c0a240081e66f72046983ca7d16" translate="yes" xml:space="preserve">
          <source>Example usage</source>
          <target state="translated">使用实例</target>
        </trans-unit>
        <trans-unit id="98859dfb330cbeca8950e6e5316d288484dfa387" translate="yes" xml:space="preserve">
          <source>Example usage of these low level built-in functions may look like:</source>
          <target state="translated">这些低级内置函数的使用示例可能是这样的。</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="3203ec56f6623a12f68979ebebcaf218b0674056" translate="yes" xml:space="preserve">
          <source>Examples of code with undefined behavior are &lt;code&gt;a = a++;&lt;/code&gt;, &lt;code&gt;a[n]
= b[n++]&lt;/code&gt; and &lt;code&gt;a[i++] = i;&lt;/code&gt;. Some more complicated cases are not diagnosed by this option, and it may give an occasional false positive result, but in general it has been found fairly effective at detecting this sort of problem in programs.</source>
          <target state="translated">具有未定义行为的代码示例为 &lt;code&gt;a = a++;&lt;/code&gt; ， &lt;code&gt;a[n] = b[n++]&lt;/code&gt; 和 &lt;code&gt;a[i++] = i;&lt;/code&gt; 。使用此选项无法诊断出一些更复杂的情况，并且可能偶尔会出现误报的结果，但总的来说，已发现在检测程序中此类问题方面相当有效。</target>
        </trans-unit>
        <trans-unit id="ac2978569b0d96ea67fa55ae3fcac3a58dbeaa7e" translate="yes" xml:space="preserve">
          <source>Examples of the use cases for this tool are:</source>
          <target state="translated">该工具的使用案例有:</target>
        </trans-unit>
        <trans-unit id="fb3447b632f6a431215776dcf254a01001a40c4f" translate="yes" xml:space="preserve">
          <source>Examples:</source>
          <target state="translated">Examples:</target>
        </trans-unit>
        <trans-unit id="911d893025886382ab91769b068aa06459b40499" translate="yes" xml:space="preserve">
          <source>Exception handlers differ from interrupt handlers because the system pushes an error code on the stack. An exception handler declaration is similar to that for an interrupt handler, but with a different mandatory function signature. The compiler arranges to pop the error code off the stack before the &lt;code&gt;IRET&lt;/code&gt; instruction.</source>
          <target state="translated">异常处理程序与中断处理程序不同，因为系统将错误代码压入堆栈。异常处理程序的声明与中断处理程序的声明相似，但是具有不同的强制性函数签名。编译器安排在 &lt;code&gt;IRET&lt;/code&gt; 指令之前从堆栈弹出错误代码。</target>
        </trans-unit>
        <trans-unit id="d60ce999e28bc42ef5590e1790afd26bd6f33f60" translate="yes" xml:space="preserve">
          <source>Exception handlers should only be used for exceptions that push an error code; you should use an interrupt handler in other cases. The system will crash if the wrong kind of handler is used.</source>
          <target state="translated">异常处理程序只能用于推送错误代码的异常,在其他情况下应该使用中断处理程序。如果使用了错误的处理程序,系统会崩溃。</target>
        </trans-unit>
        <trans-unit id="61c358f1bb209146fb6ebbb188045ae7738fdddb" translate="yes" xml:space="preserve">
          <source>Execution and Data Prediction Restriction Instructions.</source>
          <target state="translated">执行和数据预测限制指令。</target>
        </trans-unit>
        <trans-unit id="cd06a6fd64c8b50d4558cb3316fd26ee9feb5746" translate="yes" xml:space="preserve">
          <source>Expand &lt;code&gt;adddi3&lt;/code&gt; and &lt;code&gt;subdi3&lt;/code&gt; at RTL generation time into &lt;code&gt;add.f&lt;/code&gt;, &lt;code&gt;adc&lt;/code&gt; etc. This option is deprecated.</source>
          <target state="translated">在RTL生成时将 &lt;code&gt;adddi3&lt;/code&gt; 和 &lt;code&gt;subdi3&lt;/code&gt; 扩展为 &lt;code&gt;add.f&lt;/code&gt; ， &lt;code&gt;adc&lt;/code&gt; 等。不建议使用此选项。</target>
        </trans-unit>
        <trans-unit id="ad01d735326a2f6603f39ee595dd5b05ec416e8b" translate="yes" xml:space="preserve">
          <source>Expand into an inline loop.</source>
          <target state="translated">展开成一个内联循环。</target>
        </trans-unit>
        <trans-unit id="5ddf0ba44f58c348b4ec4063056d25a8b4689f7a" translate="yes" xml:space="preserve">
          <source>Expand using i386 &lt;code&gt;rep&lt;/code&gt; prefix of the specified size.</source>
          <target state="translated">使用指定大小的i386 &lt;code&gt;rep&lt;/code&gt; 前缀进行扩展。</target>
        </trans-unit>
        <trans-unit id="7720f0269a2d383f2dd786328047f312351d0105" translate="yes" xml:space="preserve">
          <source>Explain what alignment considerations lead to the decision to make an instruction short or long.</source>
          <target state="translated">解释哪些调整考虑因素导致决定使指令变短或变长。</target>
        </trans-unit>
        <trans-unit id="69ccd30207ce48099a948be1541f4d6a441981f8" translate="yes" xml:space="preserve">
          <source>Explicit instantiations can be used for the largest or most frequently duplicated instances, without having to know exactly which other instances are used in the rest of the program. You can scatter the explicit instantiations throughout your program, perhaps putting them in the translation units where the instances are used or the translation units that define the templates themselves; you can put all of the explicit instantiations you need into one big file; or you can create small files like</source>
          <target state="translated">显式实例可以用于最大的或最经常重复的实例,而不需要确切地知道在程序的其余部分使用了哪些其他实例。你可以将显式实例分散在整个程序中,可能将它们放在使用实例的翻译单元中,或者放在定义模板本身的翻译单元中;你可以将所有你需要的显式实例放在一个大文件中;或者你可以创建一些小文件,如</target>
        </trans-unit>
        <trans-unit id="83042939fc50e1e36ef864fc1e78eae1c62725bf" translate="yes" xml:space="preserve">
          <source>Explicitly instantiated inline methods are unaffected by this option as their linkage might otherwise cross a shared library boundary. See &lt;a href=&quot;template-instantiation#Template-Instantiation&quot;&gt;Template Instantiation&lt;/a&gt;.</source>
          <target state="translated">显式实例化的内联方法不受此选项的影响，因为它们的链接可能会跨越共享库的边界。请参阅&lt;a href=&quot;template-instantiation#Template-Instantiation&quot;&gt;模板实例化&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="61bd3ccba4b2c3767215774893d82391e0bc09ab" translate="yes" xml:space="preserve">
          <source>Expressions are currently only contracted if</source>
          <target state="translated">目前只有在以下情况下才会收缩表达式</target>
        </trans-unit>
        <trans-unit id="83c4bb072fc47e954ad84b1ea046adec27e854fd" translate="yes" xml:space="preserve">
          <source>Expressions that may be cast to the union type are those whose type matches at least one of the members of the union. Thus, given the following union and variables:</source>
          <target state="translated">可以投向联合类型的表达式是那些类型至少与联合中的一个成员匹配的表达式。因此,给定以下联合体和变量:</target>
        </trans-unit>
        <trans-unit id="ed9daef21d2e4305e648aee577dd1d6036550745" translate="yes" xml:space="preserve">
          <source>Extend (do not extend) the</source>
          <target state="translated">延长(不延长)</target>
        </trans-unit>
        <trans-unit id="20891f4ff37ed22f4675dae3faaf487875cf701e" translate="yes" xml:space="preserve">
          <source>Extend the current ABI with a particular extension, or remove such extension. Valid values are &amp;lsquo;</source>
          <target state="translated">用特定的扩展名扩展当前的ABI，或删除该扩展名。有效值为'</target>
        </trans-unit>
        <trans-unit id="91653b5f0401d6aa2a22ebdd6efdf9699bdaeb42" translate="yes" xml:space="preserve">
          <source>Extended &lt;code&gt;asm&lt;/code&gt; statements have to be inside a C function, so to write inline assembly language at file scope (&amp;ldquo;top-level&amp;rdquo;), outside of C functions, you must use basic &lt;code&gt;asm&lt;/code&gt;. You can use this technique to emit assembler directives, define assembly language macros that can be invoked elsewhere in the file, or write entire functions in assembly language. Basic &lt;code&gt;asm&lt;/code&gt; statements outside of functions may not use any qualifiers.</source>
          <target state="translated">扩展的 &lt;code&gt;asm&lt;/code&gt; 语句必须在C函数内部，因此要在C函数之外的文件范围（&amp;ldquo;顶级&amp;rdquo;）编写内联汇编语言，必须使用basic &lt;code&gt;asm&lt;/code&gt; 。您可以使用此技术来发出汇编器指令，定义可以在文件中其他位置调用的汇编语言宏，或以汇编语言编写整个函数。函数外部的基本 &lt;code&gt;asm&lt;/code&gt; 语句不能使用任何限定符。</target>
        </trans-unit>
        <trans-unit id="04a315d0cc75470cd36dfd3cb992c3efb5b94ebf" translate="yes" xml:space="preserve">
          <source>Extended alignments up to &lt;em&gt;2^{28}&lt;/em&gt; (bytes) are supported for objects of automatic storage duration. Alignments supported for objects of static and thread storage duration are determined by the ABI.</source>
          <target state="translated">对于自动存储持续时间的对象，最多支持&lt;em&gt;2 ^ {28}&lt;/em&gt;（字节）的扩展对齐方式。静态和线程存储持续时间对象支持的对齐方式由ABI确定。</target>
        </trans-unit>
        <trans-unit id="342b07a4e48b541946d49b2270415ae84b1aef83" translate="yes" xml:space="preserve">
          <source>Extended registers are not stored on stack before execution of function with monitor attribute. Default option is</source>
          <target state="translated">在执行具有监视器属性的函数之前,扩展寄存器不存储在堆栈中。默认选项是</target>
        </trans-unit>
        <trans-unit id="57cf6f586241383946ebaa10651980906e2e7008" translate="yes" xml:space="preserve">
          <source>Extended registers are stored on stack before execution of function with monitor attribute. Default option is</source>
          <target state="translated">扩展寄存器在执行具有监视器属性的函数之前被存储在堆栈中。默认选项是</target>
        </trans-unit>
        <trans-unit id="c9dbca1f0ee851a1a4128829e444f15ff917ef20" translate="yes" xml:space="preserve">
          <source>Extra time accounted by inliner for function overhead such as time needed to execute function prologue and epilogue</source>
          <target state="translated">额外的时间由inliner计入函数开销,如执行函数序幕和尾声所需的时间。</target>
        </trans-unit>
        <trans-unit id="e69f20e9f683920d3fb4329abd951e878b1f9372" translate="yes" xml:space="preserve">
          <source>F</source>
          <target state="translated">F</target>
        </trans-unit>
        <trans-unit id="6b84b9421bc7074ef9cc3088b04a6a18d77c5b2a" translate="yes" xml:space="preserve">
          <source>FMA instructions.</source>
          <target state="translated">FMA指示:</target>
        </trans-unit>
        <trans-unit id="cbf2cb3fe36db407f3a3f0c5e7fef7fc69c6ce00" translate="yes" xml:space="preserve">
          <source>FMA4 instructions.</source>
          <target state="translated">FMA4说明:</target>
        </trans-unit>
        <trans-unit id="b911450c0baee87cf3722095b3e43b717fb436bb" translate="yes" xml:space="preserve">
          <source>FP or VSX register to hold 64-bit doubles for direct moves or NO_REGS.</source>
          <target state="translated">FP或VSX寄存器,用于存放64位的双倍数,用于直接移动或NO_REGS。</target>
        </trans-unit>
        <trans-unit id="faed2456bafb04f8c1fb3d816c3c01f0fb54a75c" translate="yes" xml:space="preserve">
          <source>FP or VSX register to hold 64-bit integers for VSX insns or NO_REGS.</source>
          <target state="translated">FP或VSX寄存器为VSX insns或NO_REGS保存64位整数。</target>
        </trans-unit>
        <trans-unit id="09f3e1a89b6305e70a6393d549d66dbbcfd2f8f3" translate="yes" xml:space="preserve">
          <source>FP or VSX register to hold 64-bit integers for direct moves or NO_REGS.</source>
          <target state="translated">FP或VSX寄存器,用于存放64位整数,用于直接移动或NO_REGS。</target>
        </trans-unit>
        <trans-unit id="ec3d1f378b46e7073f89e8d2b44ffed3f4925fb8" translate="yes" xml:space="preserve">
          <source>FP or VSX register to perform ISA 2.07 float ops or NO_REGS.</source>
          <target state="translated">FP或VSX寄存器执行ISA 2.07浮点运算或NO_REGS。</target>
        </trans-unit>
        <trans-unit id="c07c5ae5e3671f1039b7da098eb0348a7624af7b" translate="yes" xml:space="preserve">
          <source>FP or VSX register to perform float operations under</source>
          <target state="translated">FP 或 VSX 寄存器,以执行浮动运算,在</target>
        </trans-unit>
        <trans-unit id="a924751782c4ee4b5b496793046fc57512ab59f9" translate="yes" xml:space="preserve">
          <source>FP register if</source>
          <target state="translated">FP寄存器,如果</target>
        </trans-unit>
        <trans-unit id="5b1d99e5f9118d7c70848e6ad6167bba8b0b23d3" translate="yes" xml:space="preserve">
          <source>FPSCR</source>
          <target state="translated">FPSCR</target>
        </trans-unit>
        <trans-unit id="ff875f9855f1361e4b30af2d77d0d9c23d4bdca2" translate="yes" xml:space="preserve">
          <source>FRV&amp;mdash;</source>
          <target state="translated">FRV&amp;mdash;</target>
        </trans-unit>
        <trans-unit id="230d241b3d82558160cd5187f1fe9d9c435b18d5" translate="yes" xml:space="preserve">
          <source>FSF GCC on Darwin does not create &amp;ldquo;fat&amp;rdquo; object files; it creates an object file for the single architecture that GCC was built to target. Apple&amp;rsquo;s GCC on Darwin does create &amp;ldquo;fat&amp;rdquo; files if multiple</source>
          <target state="translated">达尔文市的FSF GCC不会创建&amp;ldquo;胖&amp;rdquo;目标文件。它为GCC所针对的单一架构创建了一个目标文件。如果达尔文的Apple GCC确实创建了多个&amp;ldquo;胖&amp;rdquo;文件</target>
        </trans-unit>
        <trans-unit id="7a156574143e4ca84e24da6dfdb279cf456cca04" translate="yes" xml:space="preserve">
          <source>FT32&amp;mdash;</source>
          <target state="translated">FT32&amp;mdash;</target>
        </trans-unit>
        <trans-unit id="599d4afb33240eb91ea2840bb9ba8f1ff44bf581" translate="yes" xml:space="preserve">
          <source>Fat LTO objects are object files that contain both the intermediate language and the object code. This makes them usable for both LTO linking and normal linking. This option is effective only when compiling with</source>
          <target state="translated">胖LTO对象是包含中间语言和对象代码的对象文件。这使得它们既可以用于LTO链接,也可以用于普通链接。这个选项只有在编译时使用</target>
        </trans-unit>
        <trans-unit id="ad565d9d01d0e0bf91fd6a8532f6d81613338901" translate="yes" xml:space="preserve">
          <source>Feature</source>
          <target state="translated">Feature</target>
        </trans-unit>
        <trans-unit id="909a10c01414726d2e86792cc51fea9d589c8fb6" translate="yes" xml:space="preserve">
          <source>Feature Modifiers</source>
          <target state="translated">特征修改器</target>
        </trans-unit>
        <trans-unit id="c796b811ac5dce8d8e36d70db0e07e63b27d5eab" translate="yes" xml:space="preserve">
          <source>Feature modifiers used with</source>
          <target state="translated">使用的特征修饰符</target>
        </trans-unit>
        <trans-unit id="aa0dd17c258c743dbea5c193ddf09bb6cebf5964" translate="yes" xml:space="preserve">
          <source>Fields of the &lt;var&gt;branch&lt;/var&gt; element have following semantics:</source>
          <target state="translated">&lt;var&gt;branch&lt;/var&gt; 元素的字段具有以下语义：</target>
        </trans-unit>
        <trans-unit id="9cc6e9443d376e5757bc3441d57c3f310bf11770" translate="yes" xml:space="preserve">
          <source>Fields of the &lt;var&gt;file&lt;/var&gt; element have following semantics:</source>
          <target state="translated">&lt;var&gt;file&lt;/var&gt; 元素的字段具有以下语义：</target>
        </trans-unit>
        <trans-unit id="95d9f92882f18f3b5a67ac3eeafb040cc8cd3ea3" translate="yes" xml:space="preserve">
          <source>Fields of the &lt;var&gt;function&lt;/var&gt; element have following semantics:</source>
          <target state="translated">&lt;var&gt;function&lt;/var&gt; 元素的字段具有以下语义：</target>
        </trans-unit>
        <trans-unit id="55692b6d4a213073df2d182e70897f1d18b6852c" translate="yes" xml:space="preserve">
          <source>Fields of the root element have following semantics:</source>
          <target state="translated">根元素的字段具有以下语义。</target>
        </trans-unit>
        <trans-unit id="fba211bc33a4751c92e11eae269c5fe4195a12b5" translate="yes" xml:space="preserve">
          <source>Finally &amp;lsquo;</source>
          <target state="translated">最后'</target>
        </trans-unit>
        <trans-unit id="24e09f2eaae1d9afb97c63e8aa6a65a24f91f73b" translate="yes" xml:space="preserve">
          <source>Finally if the parameter is &lt;code&gt;&quot;&lt;var&gt;name2&lt;/var&gt;@@&lt;var&gt;nodename&lt;/var&gt;&quot;&lt;/code&gt; then in addition to creating a symbol version (as if &lt;code&gt;&quot;&lt;var&gt;name2&lt;/var&gt;@&lt;var&gt;nodename&lt;/var&gt;&quot;&lt;/code&gt; was used) the version will be also used to resolve &lt;var&gt;name2&lt;/var&gt; by the linker.</source>
          <target state="translated">最后，如果参数为 &lt;code&gt;&quot;&lt;var&gt;name2&lt;/var&gt;@@&lt;var&gt;nodename&lt;/var&gt;&quot;&lt;/code&gt; 则除了创建符号版本（就像使用了 &lt;code&gt;&quot;&lt;var&gt;name2&lt;/var&gt;@&lt;var&gt;nodename&lt;/var&gt;&quot;&lt;/code&gt; ）之外，链接器还将使用该版本来解析 &lt;var&gt;name2&lt;/var&gt; 。</target>
        </trans-unit>
        <trans-unit id="889bce84d14bf80370f700a385229e627febe04d" translate="yes" xml:space="preserve">
          <source>Finally, GCC will examine &amp;lsquo;</source>
          <target state="translated">最后，海湾合作委员会将审查&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="fa45d699cd27babdae75f4a8d69ed2b5379e7a87" translate="yes" xml:space="preserve">
          <source>Finally, consider:</source>
          <target state="translated">最后,考虑:</target>
        </trans-unit>
        <trans-unit id="6901050dc8495daab10889e0ec9cf3617e7fb433" translate="yes" xml:space="preserve">
          <source>Finally, note how we declared the &lt;code&gt;len&lt;/code&gt; argument and the return value to be of type &lt;code&gt;unsigned long&lt;/code&gt;. They could also be declared to be of type &lt;code&gt;unsigned int&lt;/code&gt; and everything would still work.</source>
          <target state="translated">最后，请注意我们如何将 &lt;code&gt;len&lt;/code&gt; 参数和返回值声明为 &lt;code&gt;unsigned long&lt;/code&gt; 类型。也可以将它们声明为 &lt;code&gt;unsigned int&lt;/code&gt; 类型，并且一切仍将正常进行。</target>
        </trans-unit>
        <trans-unit id="e5f1ab577d27769ef2407d2da5789ec6bcd34e2a" translate="yes" xml:space="preserve">
          <source>Finally, there is a complication when encoding &lt;code&gt;const char *&lt;/code&gt; versus &lt;code&gt;char * const&lt;/code&gt;. Because &lt;code&gt;char *&lt;/code&gt; is encoded as &lt;code&gt;*&lt;/code&gt; and not as &lt;code&gt;^c&lt;/code&gt;, there is no way to express the fact that &lt;code&gt;r&lt;/code&gt; applies to the pointer or to the pointee.</source>
          <target state="translated">最后，在对 &lt;code&gt;const char *&lt;/code&gt; 与 &lt;code&gt;char * const&lt;/code&gt; 编码时会出现复杂情况。因为 &lt;code&gt;char *&lt;/code&gt; 被编码为 &lt;code&gt;*&lt;/code&gt; 而不是 &lt;code&gt;^c&lt;/code&gt; ，所以无法表达 &lt;code&gt;r&lt;/code&gt; 适用于指针或指针的事实。</target>
        </trans-unit>
        <trans-unit id="8d30428380add9f793c9b319edf17d149e4e4f73" translate="yes" xml:space="preserve">
          <source>Find the pass dump in a file whose name is composed of three components separated by a period: the name of the source file GCC was invoked to compile, a numeric suffix indicating the pass number followed by the letter &amp;lsquo;</source>
          <target state="translated">在文件名中查找密码转储，该文件的名称由三个由句点分隔的部分组成：调用源文件GCC的名称进行编译，数字后缀表示密码，后跟字母'</target>
        </trans-unit>
        <trans-unit id="e29b12881247aeb3ff64dc0cee23e3331d67217f" translate="yes" xml:space="preserve">
          <source>Fine-tune size optimization with regards to instruction lengths and alignment. The recognized values for &lt;var&gt;level&lt;/var&gt; are:</source>
          <target state="translated">关于指令长度和对齐方式的大小优化。公认的 &lt;var&gt;level&lt;/var&gt; 值是：</target>
        </trans-unit>
        <trans-unit id="ac0c5ec00d58b3e74a205bd50ea7108335fcb5b8" translate="yes" xml:space="preserve">
          <source>First SSE register (&lt;code&gt;%xmm0&lt;/code&gt;).</source>
          <target state="translated">第一个SSE寄存器（ &lt;code&gt;%xmm0&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="846211171f7db5bd2bab9f64d61f4530995ca5a0" translate="yes" xml:space="preserve">
          <source>First, the argument corresponding to a transparent union type can be of any type in the union; no cast is required. Also, if the union contains a pointer type, the corresponding argument can be a null pointer constant or a void pointer expression; and if the union contains a void pointer type, the corresponding argument can be any pointer expression. If the union member type is a pointer, qualifiers like &lt;code&gt;const&lt;/code&gt; on the referenced type must be respected, just as with normal pointer conversions.</source>
          <target state="translated">首先，与透明联合类型相对应的参数可以是联合中的任何类型。无需强制转换。另外，如果联合包含指针类型，则对应的参数可以是空指针常量或空指针表达式；如果联合包含空指针类型，则对应的参数可以是任何指针表达式。如果联合成员类型是指针，则必须 &lt;code&gt;const&lt;/code&gt; 引用类型上的const等限定符，就像普通的指针转换一样。</target>
        </trans-unit>
        <trans-unit id="15ab13a54971de84d7939a64c563f0a383d5df53" translate="yes" xml:space="preserve">
          <source>Fixed form Fortran source code that must be preprocessed (with the traditional preprocessor).</source>
          <target state="translated">固定形式的Fortran源代码,必须进行预处理(用传统的预处理器)。</target>
        </trans-unit>
        <trans-unit id="5552528a96a767723e84e4196dd1b4ccd0182f5d" translate="yes" xml:space="preserve">
          <source>Fixed form Fortran source code that should not be preprocessed.</source>
          <target state="translated">修正了不应该被预处理的Fortran源代码的形式。</target>
        </trans-unit>
        <trans-unit id="a31ce070cf9649524c3cf990ab1f1ab74aaffaa3" translate="yes" xml:space="preserve">
          <source>Fixed limit on the size of the static frame of functions: when it is topped by a particular function, stack checking is not reliable and a warning is issued by the compiler.</source>
          <target state="translated">修正了对函数静态帧大小的限制:当它被某个函数顶住时,堆栈检查不可靠,编译器会发出警告。</target>
        </trans-unit>
        <trans-unit id="85452dd45f77555cfc8a81ff291dd73781c80f82" translate="yes" xml:space="preserve">
          <source>Fixed-Point Types.</source>
          <target state="translated">定点类型。</target>
        </trans-unit>
        <trans-unit id="9f75981b930fd7189960fca9ba3bbc1796113fd3" translate="yes" xml:space="preserve">
          <source>Fixed-point data values contain fractional and optional integral parts. The format of fixed-point data varies and depends on the target machine.</source>
          <target state="translated">定点数据值包含小数和可选的积分部分。定点数据的格式因目标机器而异。</target>
        </trans-unit>
        <trans-unit id="cb9fd0ce1881fdc78c0697ef42b75b52d214196d" translate="yes" xml:space="preserve">
          <source>Fixed-point types are supported by the DWARF debug information format.</source>
          <target state="translated">DWARF调试信息格式支持固定点类型。</target>
        </trans-unit>
        <trans-unit id="265c5eecf02fb4f371ef39bcfe52b0dfc566b452" translate="yes" xml:space="preserve">
          <source>Flag the first routine whose name starts with &lt;var&gt;prefix&lt;/var&gt; as the main routine for the debugger.</source>
          <target state="translated">将名称以 &lt;var&gt;prefix&lt;/var&gt; 开头的第一个例程标记为调试器的主要例程。</target>
        </trans-unit>
        <trans-unit id="b3390bf7e3c55aee432834653f4b1f941089ffde" translate="yes" xml:space="preserve">
          <source>Flexible array members are written as &lt;code&gt;contents[]&lt;/code&gt; without the &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">灵活的数组成员以不带 &lt;code&gt;0&lt;/code&gt; 的 &lt;code&gt;contents[]&lt;/code&gt; 形式编写。</target>
        </trans-unit>
        <trans-unit id="78dbcf864480c990f48bdd0342e3500b8c1282bd" translate="yes" xml:space="preserve">
          <source>Flexible array members have incomplete type, and so the &lt;code&gt;sizeof&lt;/code&gt; operator may not be applied. As a quirk of the original implementation of zero-length arrays, &lt;code&gt;sizeof&lt;/code&gt; evaluates to zero.</source>
          <target state="translated">灵活数组成员的类型不完整，因此可能不应用 &lt;code&gt;sizeof&lt;/code&gt; 运算符。作为零长度数组的原始实现的怪癖， &lt;code&gt;sizeof&lt;/code&gt; 的值为零。</target>
        </trans-unit>
        <trans-unit id="417d40e05d0999fe399d7881ccf242563a660e4a" translate="yes" xml:space="preserve">
          <source>Flexible array members may only appear as the last member of a &lt;code&gt;struct&lt;/code&gt; that is otherwise non-empty.</source>
          <target state="translated">灵活数组成员只能显示为结构的最后一个成员，否则该 &lt;code&gt;struct&lt;/code&gt; 为非空。</target>
        </trans-unit>
        <trans-unit id="7ffa11ebef97287859a0bb0cd563e4e8b95df556" translate="yes" xml:space="preserve">
          <source>Floating point constant 0.</source>
          <target state="translated">浮点常数0。</target>
        </trans-unit>
        <trans-unit id="4560e48bbc91965a1ad028ff4792c55d56a0a598" translate="yes" xml:space="preserve">
          <source>Floating point constant that can be loaded into a register with one instruction per word</source>
          <target state="translated">浮点常数,可以用每字一条指令加载到寄存器中。</target>
        </trans-unit>
        <trans-unit id="c516f23fc0c0d103a2cd7b68a6433df4fc2451d6" translate="yes" xml:space="preserve">
          <source>Floating point constant that is legal for store immediate</source>
          <target state="translated">浮点常数,是合法的存储即时的。</target>
        </trans-unit>
        <trans-unit id="32a95fa9a487a375449247a65d3193bb1004c1f0" translate="yes" xml:space="preserve">
          <source>Floating point constant that is not a 68881 constant</source>
          <target state="translated">不是68881常数的浮点常数。</target>
        </trans-unit>
        <trans-unit id="79fb00b4bc62aed23a250b86e31fbd72d18840a5" translate="yes" xml:space="preserve">
          <source>Floating point constant zero</source>
          <target state="translated">浮点常数为零</target>
        </trans-unit>
        <trans-unit id="af1bda543b578583ca4289ffad142bd3d77692c3" translate="yes" xml:space="preserve">
          <source>Floating point register</source>
          <target state="translated">浮点寄存器</target>
        </trans-unit>
        <trans-unit id="573ca6d44dc3da178f33a1539aefbe9a7a969613" translate="yes" xml:space="preserve">
          <source>Floating point register (containing 32-bit value)</source>
          <target state="translated">浮点寄存器(含32位值)</target>
        </trans-unit>
        <trans-unit id="b5c02f93e377f6b8a0b2a78a784d0d990452bae9" translate="yes" xml:space="preserve">
          <source>Floating point register (containing 64-bit value)</source>
          <target state="translated">浮点寄存器(含64位值)</target>
        </trans-unit>
        <trans-unit id="ef449f8f1e197b3fc12f9a7bbd29815185c01715" translate="yes" xml:space="preserve">
          <source>Floating point register (deprecated)</source>
          <target state="translated">浮点寄存器(已废弃)</target>
        </trans-unit>
        <trans-unit id="f7558c1a4bb9c6d833aca45e4903e960fa15f358" translate="yes" xml:space="preserve">
          <source>Floating point register if</source>
          <target state="translated">浮点寄存器,如果</target>
        </trans-unit>
        <trans-unit id="c165ca40457d305eb7d330afdb797521f5de1b77" translate="yes" xml:space="preserve">
          <source>Floating point register if direct moves are available, or NO_REGS.</source>
          <target state="translated">浮点寄存器,如果可以直接移动,或者NO_REGS。</target>
        </trans-unit>
        <trans-unit id="5262899d7f774e7136ab629899288cb3977b1a82" translate="yes" xml:space="preserve">
          <source>Floating point register if the LFIWAX instruction is enabled or NO_REGS.</source>
          <target state="translated">浮点寄存器,如果LFIWAX指令被启用或NO_REGS。</target>
        </trans-unit>
        <trans-unit id="37f6e14594705b3a931f7fb11f09da2da0b4cf9c" translate="yes" xml:space="preserve">
          <source>Floating point register if the LFIWZX instruction is enabled or NO_REGS.</source>
          <target state="translated">浮点寄存器,如果启用LFIWZX指令或NO_REGS。</target>
        </trans-unit>
        <trans-unit id="92eb4ccc2dc9e99f2247ac815df53adacfbc08da" translate="yes" xml:space="preserve">
          <source>Floating point register if the STFIWX instruction is enabled or NO_REGS.</source>
          <target state="translated">如果启用STFIWX指令或NO_REGS,则为浮点寄存器。</target>
        </trans-unit>
        <trans-unit id="aaae0bc8bed9980f091aa46b02c6dcb5a52b76ec" translate="yes" xml:space="preserve">
          <source>Floating point register, Advanced SIMD vector register or SVE vector register</source>
          <target state="translated">浮点寄存器,高级SIMD向量寄存器或SVE向量寄存器。</target>
        </trans-unit>
        <trans-unit id="16c68eba878493a77d0c164e7869af76e99d9145" translate="yes" xml:space="preserve">
          <source>Floating point registers AC0 through AC3. These can be loaded from/to memory with a single instruction.</source>
          <target state="translated">浮点寄存器AC0至AC3。这些寄存器可以用一条指令从内存加载到内存。</target>
        </trans-unit>
        <trans-unit id="83ce48a9f40c05895bc4e20f6bb82f032e76933d" translate="yes" xml:space="preserve">
          <source>Floating point registers AC4 and AC5. These cannot be loaded from/to memory with a single instruction.</source>
          <target state="translated">浮点寄存器AC4和AC5。这些寄存器不能用一条指令从内存中加载到内存中。</target>
        </trans-unit>
        <trans-unit id="f58b0d70fd4d764630301aac0286ba68330e3308" translate="yes" xml:space="preserve">
          <source>Floating-point condition code register.</source>
          <target state="translated">浮点条件代码寄存器。</target>
        </trans-unit>
        <trans-unit id="b56c9d5aa5cba048b4016e56db5b37a9156be6f1" translate="yes" xml:space="preserve">
          <source>Floating-point constant 0.0</source>
          <target state="translated">浮点常数 0.0</target>
        </trans-unit>
        <trans-unit id="11ca0595ff5b1cee498ed130d48a9d7ef77d2ce2" translate="yes" xml:space="preserve">
          <source>Floating-point constant 0.0 or 1.0</source>
          <target state="translated">浮点常数0.0或1.0。</target>
        </trans-unit>
        <trans-unit id="3af5f60b6556d63fbe7c6434e046d0c15fe3ffe1" translate="yes" xml:space="preserve">
          <source>Floating-point constant whose integral representation can be moved into an integer register using a high/lo_sum instruction sequence</source>
          <target state="translated">浮点常数,其积分表示法可以通过高/低的指令序列转移到整数寄存器中。</target>
        </trans-unit>
        <trans-unit id="c0e1876d49ff7a36e4b65c8a5784d9cd7a8e4781" translate="yes" xml:space="preserve">
          <source>Floating-point constant whose integral representation can be moved into an integer register using a single mov instruction</source>
          <target state="translated">浮点常数,其积分表示法可以通过一条mov指令移动到一个整数寄存器中。</target>
        </trans-unit>
        <trans-unit id="500223502156611a39a78dc4c23517d86e8a772f" translate="yes" xml:space="preserve">
          <source>Floating-point constant whose integral representation can be moved into an integer register using a single sethi instruction</source>
          <target state="translated">浮点常数,其积分表示法可以通过一条sethi指令转移到整数寄存器中。</target>
        </trans-unit>
        <trans-unit id="95fef479c80cb031fff0832cf86c7d5b4d064fb7" translate="yes" xml:space="preserve">
          <source>Floating-point instructions are only generated for 32-bit floating-point values, however, so the FPU hardware is not used for doubles if the</source>
          <target state="translated">但浮点指令只针对32位浮点值生成,所以FPU硬件不用于双倍值,如果是</target>
        </trans-unit>
        <trans-unit id="f213ef5758f227bd35596edf6ff5e36aed746a21" translate="yes" xml:space="preserve">
          <source>Floating-point minimum and maximum. These instructions are only generated if</source>
          <target state="translated">浮点最小和最大。只有在以下情况下才会产生这些指令</target>
        </trans-unit>
        <trans-unit id="92610c4245848bdded34c9ee994e62b738188b93" translate="yes" xml:space="preserve">
          <source>Floating-point register</source>
          <target state="translated">浮点寄存器</target>
        </trans-unit>
        <trans-unit id="e5380eea89f6db263d5d241526df6bedd0bd11ff" translate="yes" xml:space="preserve">
          <source>Floating-point register on the SPARC-V8 architecture and lower floating-point register on the SPARC-V9 architecture.</source>
          <target state="translated">SPARC-V8架构的浮点寄存器和SPARC-V9架构的低级浮点寄存器。</target>
        </trans-unit>
        <trans-unit id="2b69cf45a938c9e06197f0424f9a02b9aa9f002d" translate="yes" xml:space="preserve">
          <source>Floating-point register. It is equivalent to &amp;lsquo;</source>
          <target state="translated">浮点寄存器。相当于&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="8ed13acd5482c325b73e858b30874f469fb342d2" translate="yes" xml:space="preserve">
          <source>Floating-point register. It is only valid on the SPARC-V9 architecture when the Visual Instruction Set is available.</source>
          <target state="translated">浮点寄存器。只有在SPARC-V9架构上,当可视指令集可用时,它才有效。</target>
        </trans-unit>
        <trans-unit id="d0d6928cc5c4254d825994f1f03f5fa64bf43b02" translate="yes" xml:space="preserve">
          <source>Floating-point trigonometric and exponential functions. These instructions are only generated if</source>
          <target state="translated">浮点三角函数和指数函数。只有在以下情况下才会产生这些指令</target>
        </trans-unit>
        <trans-unit id="cebba3f2674f659c3ac76a05e885a881a3fcce6d" translate="yes" xml:space="preserve">
          <source>Floating-point zero</source>
          <target state="translated">浮点零点</target>
        </trans-unit>
        <trans-unit id="c245efe80db566f234058018cbe48e4698e1bcb0" translate="yes" xml:space="preserve">
          <source>Floating-point zero.</source>
          <target state="translated">浮点数为0。</target>
        </trans-unit>
        <trans-unit id="bc0561e46ee46f1370ce39f7bd133e69f6b47448" translate="yes" xml:space="preserve">
          <source>Flushing registers to memory has performance implications and may be an issue for time-sensitive code. You can provide better information to GCC to avoid this, as shown in the following examples. At a minimum, aliasing rules allow GCC to know what memory &lt;em&gt;doesn&amp;rsquo;t&lt;/em&gt; need to be flushed.</source>
          <target state="translated">将寄存器刷新到内存会影响性能，并且可能是时间敏感代码的问题。您可以向GCC提供更好的信息来避免这种情况，如以下示例所示。至少，重叠规则允许GCC知道内存&lt;em&gt;并不&lt;/em&gt;需要被刷新。</target>
        </trans-unit>
        <trans-unit id="7d035cae4646bbea859b3aa6a64d528d7a19fea6" translate="yes" xml:space="preserve">
          <source>Follow the EABI requirement of always creating a frame pointer whenever a stack frame is allocated. This option is enabled by default and can be disabled with</source>
          <target state="translated">遵循EABI的要求,每当分配一个堆栈帧时,总是创建一个帧指针。这个选项默认是启用的,也可以使用</target>
        </trans-unit>
        <trans-unit id="ec0c3b76630fd745381cc215a284820af75a683a" translate="yes" xml:space="preserve">
          <source>Footnotes</source>
          <target state="translated">Footnotes</target>
        </trans-unit>
        <trans-unit id="9203a30acc55d5bd89f275fd6b63f1da488b512a" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;t2&lt;/code&gt;, &lt;code&gt;bar&lt;/code&gt; is placed at offset 2, rather than offset 1. Accordingly, the size of &lt;code&gt;t2&lt;/code&gt; is 4. For &lt;code&gt;t3&lt;/code&gt;, the zero-length bit-field does not affect the alignment of &lt;code&gt;bar&lt;/code&gt; or, as a result, the size of the structure.</source>
          <target state="translated">对于 &lt;code&gt;t2&lt;/code&gt; ， &lt;code&gt;bar&lt;/code&gt; 放置在偏移量2处，而不是偏移量1处。因此， &lt;code&gt;t2&lt;/code&gt; 的大小为4。对于 &lt;code&gt;t3&lt;/code&gt; ，零长度位域不影响 &lt;code&gt;bar&lt;/code&gt; 的对齐，因此不影响bar的大小。结构。</target>
        </trans-unit>
        <trans-unit id="c0e04e76cdfed448d6c782b7f817b6eea03c0f50" translate="yes" xml:space="preserve">
          <source>For &lt;var&gt;n&lt;/var&gt; greater than zero,</source>
          <target state="translated">对于大于零的 &lt;var&gt;n&lt;/var&gt;</target>
        </trans-unit>
        <trans-unit id="fda527468e7c30de6308efd890e87b3a3fff811b" translate="yes" xml:space="preserve">
          <source>For ARC, a function marked with the &lt;code&gt;long_call&lt;/code&gt; attribute is always called using register-indirect jump-and-link instructions, thereby enabling the called function to be placed anywhere within the 32-bit address space. A function marked with the &lt;code&gt;medium_call&lt;/code&gt; attribute will always be close enough to be called with an unconditional branch-and-link instruction, which has a 25-bit offset from the call site. A function marked with the &lt;code&gt;short_call&lt;/code&gt; attribute will always be close enough to be called with a conditional branch-and-link instruction, which has a 21-bit offset from the call site.</source>
          <target state="translated">对于ARC，始终使用寄存器间接跳转和链接指令调用标有 &lt;code&gt;long_call&lt;/code&gt; 属性的函数，从而使被调用函数可以放置在32位地址空间内的任何位置。标记有 &lt;code&gt;medium_call&lt;/code&gt; 属性的函数将始终足够接近以使用无条件分支和链接指令进行调用，该指令与调用位置的偏移量为25位。标记有 &lt;code&gt;short_call&lt;/code&gt; 属性的函数将始终足够接近以被有条件的分支和链接指令调用，该指令与调用位置的偏移量为21位。</target>
        </trans-unit>
        <trans-unit id="6adc57b693c8942df2cd231eba32d27dd15cba72" translate="yes" xml:space="preserve">
          <source>For C and C++ source and include files, generate corresponding Ada specs. See &lt;a href=&quot;http://gcc.gnu.org/onlinedocs/gnat_ugn/Generating-Ada-Bindings-for-C-and-C_002b_002b-headers.html#Generating-Ada-Bindings-for-C-and-C_002b_002b-headers&quot;&gt;Generating Ada Bindings for C and C++ headers&lt;/a&gt; in GNAT User&amp;rsquo;s Guide, which provides detailed documentation on this feature.</source>
          <target state="translated">对于C和C ++源代码以及包含文件，请生成相应的Ada规范。请参阅&lt;a href=&quot;http://gcc.gnu.org/onlinedocs/gnat_ugn/Generating-Ada-Bindings-for-C-and-C_002b_002b-headers.html#Generating-Ada-Bindings-for-C-and-C_002b_002b-headers&quot;&gt;《&lt;/a&gt; GNAT用户指南》中的为C和C ++头生成Ada绑定，其中提供了有关此功能的详细文档。</target>
        </trans-unit>
        <trans-unit id="a54d6337d3721d977a537facc549a93425ea6c7b" translate="yes" xml:space="preserve">
          <source>For C only, warn about a &lt;code&gt;return&lt;/code&gt; statement with an expression in a function whose return type is &lt;code&gt;void&lt;/code&gt;, unless the expression type is also &lt;code&gt;void&lt;/code&gt;. As a GNU extension, the latter case is accepted without a warning unless</source>
          <target state="translated">仅对于C，警告 &lt;code&gt;return&lt;/code&gt; 语句中包含返回类型为 &lt;code&gt;void&lt;/code&gt; 的函数的表达式，除非表达式类型也为 &lt;code&gt;void&lt;/code&gt; 。作为GNU扩展，除非有警告，否则接受后一种情况，除非</target>
        </trans-unit>
        <trans-unit id="2ec28d96fea6d9177d31ee6cda12fa27a81380e2" translate="yes" xml:space="preserve">
          <source>For C++ this also warns for some cases of unnecessary parentheses in declarations, which can indicate an attempt at a function call instead of a declaration:</source>
          <target state="translated">对于C++来说,这也警告了一些声明中不必要的小括号的情况,这可能表明试图调用一个函数而不是声明。</target>
        </trans-unit>
        <trans-unit id="a1ba0033d082d3c48e09cd4d28a77031c040292c" translate="yes" xml:space="preserve">
          <source>For C++ types with non-trivial constructors and/or destructors it is impossible for the compiler to determine whether a variable of this type is truly unused if it is not referenced. This type attribute informs the compiler that variables of this type should be warned about if they appear to be unused, just like variables of fundamental types.</source>
          <target state="translated">对于具有非平凡的构造函数和/或析构函数的C++类型,如果一个类型的变量没有被引用,编译器就无法确定它是否真的未被使用。这个类型属性告诉编译器,如果这个类型的变量看起来是未使用的,就应该像基本类型的变量一样被警告。</target>
        </trans-unit>
        <trans-unit id="0ae259ea1be0c205a219871342f05ea5c73b071c" translate="yes" xml:space="preserve">
          <source>For C++, also warn for confusing overload resolution for user-defined conversions; and conversions that never use a type conversion operator: conversions to &lt;code&gt;void&lt;/code&gt;, the same type, a base class or a reference to them. Warnings about conversions between signed and unsigned integers are disabled by default in C++ unless</source>
          <target state="translated">对于C ++，还警告用户定义转换时的重载解析混乱；以及从未使用类型转换运算符的转换：转换为 &lt;code&gt;void&lt;/code&gt; ，相同类型，基类或对其的引用。除非在C ++中，否则默认禁用有关有符号和无符号整数之间转换的警告</target>
        </trans-unit>
        <trans-unit id="e062686eecb3f26c45c0833c30627154026b2d61" translate="yes" xml:space="preserve">
          <source>For C++11 and later standards, narrowing conversions are diagnosed by default, as required by the standard. A narrowing conversion from a constant produces an error, and a narrowing conversion from a non-constant produces a warning, but</source>
          <target state="translated">对于C++11及以后的标准,按照标准的要求,缺省会对窄化转换进行诊断。从一个常数进行窄化转换会产生错误,从一个非常数进行窄化转换会产生警告,但</target>
        </trans-unit>
        <trans-unit id="f97e8575f9ec69703e8c96b79759e90bcf7fbfd5" translate="yes" xml:space="preserve">
          <source>For C, overloaded functions are implemented with macros so the following does not work:</source>
          <target state="translated">对于C语言来说,重载函数是用宏来实现的,所以下面的内容不能用。</target>
        </trans-unit>
        <trans-unit id="9bcf8fa5038512fc6bcb9ac1f639a794219e10dd" translate="yes" xml:space="preserve">
          <source>For Microsoft Windows targets the use of the &lt;code&gt;dllimport&lt;/code&gt; attribute on functions is not necessary, but provides a small performance benefit by eliminating a thunk in the DLL. The use of the &lt;code&gt;dllimport&lt;/code&gt; attribute on imported variables can be avoided by passing the</source>
          <target state="translated">对于Microsoft Windows目标，不需要在函数上使用 &lt;code&gt;dllimport&lt;/code&gt; 属性，但是通过消除DLL中的重击，可以提供较小的性能优势。通过传递参数可以避免在导入的变量上使用 &lt;code&gt;dllimport&lt;/code&gt; 属性。</target>
        </trans-unit>
        <trans-unit id="9b439766be6cedb98071044e5f74180de17ccd28" translate="yes" xml:space="preserve">
          <source>For Microsoft Windows targets there are alternative methods for including the symbol in the DLL&amp;rsquo;s export table such as using a</source>
          <target state="translated">对于Microsoft Windows目标，可以使用其他方法将符号包括在DLL的导出表中，例如使用</target>
        </trans-unit>
        <trans-unit id="c0f97011eddc4db6c5d876ee996866a2e41c88d5" translate="yes" xml:space="preserve">
          <source>For Objective-C dialects, &lt;code&gt;NSString&lt;/code&gt; (or &lt;code&gt;__NSString__&lt;/code&gt;) is recognized in the same context. Declarations including these format attributes are parsed for correct syntax, however the result of checking of such format strings is not yet defined, and is not carried out by this version of the compiler.</source>
          <target state="translated">对于Objective-C方言，可以在同一上下文中识别 &lt;code&gt;NSString&lt;/code&gt; （或 &lt;code&gt;__NSString__&lt;/code&gt; ）。解析包含这些格式属性的声明以获取正确的语法，但是尚未定义此类格式字符串的检查结果，并且此版本的编译器无法执行该检查。</target>
        </trans-unit>
        <trans-unit id="7b8c007aa57d34905e4e1143a8c9e0a695e59978" translate="yes" xml:space="preserve">
          <source>For Objective-C dialects, the &lt;code&gt;format-arg&lt;/code&gt; attribute may refer to an &lt;code&gt;NSString&lt;/code&gt; reference for compatibility with the &lt;code&gt;format&lt;/code&gt; attribute above.</source>
          <target state="translated">对于Objective-C方言， &lt;code&gt;format-arg&lt;/code&gt; 属性可以引用 &lt;code&gt;NSString&lt;/code&gt; 参考以与上面的 &lt;code&gt;format&lt;/code&gt; 属性兼容。</target>
        </trans-unit>
        <trans-unit id="92a499e6d28c647e0ab66f857f55afedfae35b1a" translate="yes" xml:space="preserve">
          <source>For PMF constants (i.e. expressions of the form &amp;lsquo;</source>
          <target state="translated">对于PMF常数（即形式为'</target>
        </trans-unit>
        <trans-unit id="da58c329594be0295cc2415f6a69d9838ef88a83" translate="yes" xml:space="preserve">
          <source>For SysV/x86-64, unions with &lt;code&gt;long double&lt;/code&gt; members are passed in memory as specified in psABI. For example:</source>
          <target state="translated">对于SysV / x86-64，具有 &lt;code&gt;long double&lt;/code&gt; 精度成员的并集将按照psABI中的指定在内存中传递。例如：</target>
        </trans-unit>
        <trans-unit id="1f5fce8a743c71e90680bcbdd5fc42205fc0e24c" translate="yes" xml:space="preserve">
          <source>For SysV/x86-64, unions with &lt;code&gt;long double&lt;/code&gt; members are passed in memory as specified in psABI. Prior to GCC 4.4, this was not the case. For example:</source>
          <target state="translated">对于SysV / x86-64，具有 &lt;code&gt;long double&lt;/code&gt; 精度成员的并集将按照psABI中的指定在内存中传递。在GCC 4.4之前，情况并非如此。例如：</target>
        </trans-unit>
        <trans-unit id="1e5082f805fe556d28e82883360f1cc9602556d6" translate="yes" xml:space="preserve">
          <source>For a branch, if it was executed at least once, then a percentage indicating the number of times the branch was taken divided by the number of times the branch was executed will be printed. Otherwise, the message &amp;ldquo;never executed&amp;rdquo; is printed.</source>
          <target state="translated">对于分支，如果执行了至少一次，则将打印一个百分比，该百分比指示分支被执行的次数除以分支被执行的次数。否则，将显示消息&amp;ldquo;从不执行&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="c55de54fa0492ae593f558830d0cb1158609d3e6" translate="yes" xml:space="preserve">
          <source>For a call, if it was executed at least once, then a percentage indicating the number of times the call returned divided by the number of times the call was executed will be printed. This will usually be 100%, but may be less for functions that call &lt;code&gt;exit&lt;/code&gt; or &lt;code&gt;longjmp&lt;/code&gt;, and thus may not return every time they are called.</source>
          <target state="translated">对于一个呼叫，如果它至少执行了一次，则将打印一个百分比，该百分比表示该呼叫返回的次数除以该呼叫执行的次数。通常为100％，但对于调用 &lt;code&gt;exit&lt;/code&gt; 或 &lt;code&gt;longjmp&lt;/code&gt; 的函数而言可能会更少，因此可能不会在每次调用它们时都返回。</target>
        </trans-unit>
        <trans-unit id="0b932ff19c99d589baf49f81de1fc444d2d6fe68" translate="yes" xml:space="preserve">
          <source>For a full description of what the helpers do, the arguments they take, and the returned value, see the</source>
          <target state="translated">关于助记符的作用、参数和返回值的完整描述,请参见</target>
        </trans-unit>
        <trans-unit id="6d3a2fcd90b12dd021860d8f2094fd5bb769b990" translate="yes" xml:space="preserve">
          <source>For all builtins, &lt;code&gt;__builtin_arc_&lt;var&gt;someinsn&lt;/var&gt;&lt;/code&gt;, the header file</source>
          <target state="translated">对于所有内建文件，头文件 &lt;code&gt;__builtin_arc_&lt;var&gt;someinsn&lt;/var&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="faea18cdbc9f914fc830faf9ab42ccd57286882b" translate="yes" xml:space="preserve">
          <source>For all of these except the last, the compiler automatically ignores the precompiled header if the conditions aren&amp;rsquo;t met. If you find an option combination that doesn&amp;rsquo;t work and doesn&amp;rsquo;t cause the precompiled header to be ignored, please consider filing a bug report, see &lt;a href=&quot;https://gcc.gnu.org/onlinedocs/gcc-10.2.0/gcc/Bugs.html#Bugs&quot;&gt;Bugs&lt;/a&gt;.</source>
          <target state="translated">对于除最后一项以外的所有其他条件，如果不满足条件，则编译器会自动忽略预编译的标头。如果您发现一个无效的选项组合并且不会导致忽略预编译的标头，请考虑提交错误报告，请参见&lt;a href=&quot;https://gcc.gnu.org/onlinedocs/gcc-10.2.0/gcc/Bugs.html#Bugs&quot;&gt;错误&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2d0b11d5fd63069d7902f804e3faa32968adf01d" translate="yes" xml:space="preserve">
          <source>For all of these except the last, the compiler automatically ignores the precompiled header if the conditions aren&amp;rsquo;t met. If you find an option combination that doesn&amp;rsquo;t work and doesn&amp;rsquo;t cause the precompiled header to be ignored, please consider filing a bug report, see &lt;a href=&quot;https://gcc.gnu.org/onlinedocs/gcc-9.2.0/gcc/Bugs.html#Bugs&quot;&gt;Bugs&lt;/a&gt;.</source>
          <target state="translated">对于除最后一项以外的所有其他条件，如果不满足条件，则编译器会自动忽略预编译的标头。如果您发现一个无效的选项组合并且不会导致忽略预编译的标头，请考虑提交错误报告，请参阅&lt;a href=&quot;https://gcc.gnu.org/onlinedocs/gcc-9.2.0/gcc/Bugs.html#Bugs&quot;&gt;错误&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="58f02a64f2f86869e0c0753651765b098a5d48fc" translate="yes" xml:space="preserve">
          <source>For an automatic (i.e. local) variable, if there exists a path from the function entry to a use of the variable that is initialized, but there exist some other paths for which the variable is not initialized, the compiler emits a warning if it cannot prove the uninitialized paths are not executed at run time.</source>
          <target state="translated">对于一个自动变量(即局部变量),如果存在一个从函数入口到使用该变量的路径是初始化的,但存在一些其他路径的变量没有初始化,编译器如果不能证明未初始化的路径在运行时没有被执行,就会发出警告。</target>
        </trans-unit>
        <trans-unit id="66413344ffac4ff8769f77f6b83c7166f806eb53" translate="yes" xml:space="preserve">
          <source>For any declared symbols matching &lt;var&gt;name&lt;/var&gt;, this does three things to that symbol: it forces the symbol to be located at the given address (a number), it forces the symbol to be volatile, and it changes the symbol&amp;rsquo;s scope to be static. This pragma exists for compatibility with other compilers, but note that the common &lt;code&gt;1234H&lt;/code&gt; numeric syntax is not supported (use &lt;code&gt;0x1234&lt;/code&gt; instead). Example:</source>
          <target state="translated">对于任何声明的与 &lt;var&gt;name&lt;/var&gt; 匹配的符号，它对该符号执行三件事：强制该符号位于给定的地址（数字）上，强制该符号易变，并且将符号的范围更改为静态。存在该 &lt;code&gt;1234H&lt;/code&gt; 注是为了与其他编译器兼容，但请注意，不支持常见的1234H数字语法（请改用 &lt;code&gt;0x1234&lt;/code&gt; ）。例：</target>
        </trans-unit>
        <trans-unit id="a150049db7b708562952c9c177d8b88f32edb151" translate="yes" xml:space="preserve">
          <source>For any given input file, the file name suffix determines what kind of compilation is done:</source>
          <target state="translated">对于任何给定的输入文件,文件名后缀决定了编译的种类。</target>
        </trans-unit>
        <trans-unit id="07d18512cc77ea85f9b39807bf636696e007c1f0" translate="yes" xml:space="preserve">
          <source>For any input register that is implicitly popped by an &lt;code&gt;asm&lt;/code&gt;, it is necessary to know how to adjust the stack to compensate for the pop. If any non-popped input is closer to the top of the reg-stack than the implicitly popped register, it would not be possible to know what the stack looked like&amp;mdash;it&amp;rsquo;s not clear how the rest of the stack &amp;ldquo;slides up&amp;rdquo;.</source>
          <target state="translated">对于由 &lt;code&gt;asm&lt;/code&gt; 隐式弹出的任何输入寄存器，有必要知道如何调整堆栈以补偿弹出。如果有任何未弹出的输入比隐式弹出的寄存器更靠近reg-stack的顶部，则不可能知道堆栈是什么样子&amp;mdash;尚不清楚其余堆栈如何&amp;ldquo;向上滑动&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="f70c821669087836df1b08a79652756521c81032" translate="yes" xml:space="preserve">
          <source>For basic &lt;code&gt;asm&lt;/code&gt; with non-empty assembler string GCC assumes the assembler block does not change any general purpose registers, but it may read or write any globally accessible variable.</source>
          <target state="translated">对于具有非空汇编程序字符串的基本 &lt;code&gt;asm&lt;/code&gt; ，GCC假定汇编程序块不会更改任何通用寄存器，但可以读取或写入任何全局可访问变量。</target>
        </trans-unit>
        <trans-unit id="5e325c0c804529598de8767ff4c99ad5a3e91e4a" translate="yes" xml:space="preserve">
          <source>For compatibility with Microsoft Windows compilers, GCC supports &amp;lsquo;</source>
          <target state="translated">为了与Microsoft Windows编译器兼容，GCC支持&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="2e68646242b9dd84443ad785c99336fb66a4c416" translate="yes" xml:space="preserve">
          <source>For compatibility with Microsoft Windows compilers, GCC supports a set of &lt;code&gt;#pragma&lt;/code&gt; directives that change the maximum alignment of members of structures (other than zero-width bit-fields), unions, and classes subsequently defined. The &lt;var&gt;n&lt;/var&gt; value below always is required to be a small power of two and specifies the new alignment in bytes.</source>
          <target state="translated">为了与Microsoft Windows编译器兼容，GCC支持一组 &lt;code&gt;#pragma&lt;/code&gt; 指令，这些指令可更改结构成员（零宽度位域除外），并集和随后定义的类的最大对齐方式。始终要求下面的 &lt;var&gt;n&lt;/var&gt; 值为2的小数幂，并以字节为单位指定新的对齐方式。</target>
        </trans-unit>
        <trans-unit id="2922cd58b39e0ff05824f3d77b79c0fe7423d78f" translate="yes" xml:space="preserve">
          <source>For compatibility with SVR4, GCC supports a set of &lt;code&gt;#pragma&lt;/code&gt; directives for declaring symbols to be weak, and defining weak aliases.</source>
          <target state="translated">为了与SVR4兼容，GCC支持一组 &lt;code&gt;#pragma&lt;/code&gt; 指令，用于将符号声明为弱，并定义弱别名。</target>
        </trans-unit>
        <trans-unit id="47783006d3b2d24697c7b14be6b4ca265bdb02d0" translate="yes" xml:space="preserve">
          <source>For compatibility with existing code written for compiler versions that did not implement attributes on nested declarators, some laxity is allowed in the placing of attributes. If an attribute that only applies to types is applied to a declaration, it is treated as applying to the type of that declaration. If an attribute that only applies to declarations is applied to the type of a declaration, it is treated as applying to that declaration; and, for compatibility with code placing the attributes immediately before the identifier declared, such an attribute applied to a function return type is treated as applying to the function type, and such an attribute applied to an array element type is treated as applying to the array type. If an attribute that only applies to function types is applied to a pointer-to-function type, it is treated as applying to the pointer target type; if such an attribute is applied to a function return type that is not a pointer-to-function type, it is treated as applying to the function type.</source>
          <target state="translated">为了兼容为编译器版本编写的现有代码,这些编译器没有在嵌套的声明器上实现属性,在属性的放置上允许有一些宽松。如果一个只适用于类型的属性被应用于一个声明,那么它将被视为应用于该声明的类型。如果一个只适用于声明的属性被应用于声明的类型,那么它被视为应用于该声明;而且,为了与紧接在声明的标识符之前放置属性的代码相兼容,这样一个应用于函数返回类型的属性被视为应用于函数类型,这样一个应用于数组元素类型的属性被视为应用于数组类型。如果一个只适用于函数类型的属性被应用于指针到函数类型,则被视为应用于指针目标类型;如果这样的属性被应用于不是指针到函数类型的函数返回类型,则被视为应用于函数类型。</target>
        </trans-unit>
        <trans-unit id="55c454a21201bdfc3a9a886c367d99786c9c4842" translate="yes" xml:space="preserve">
          <source>For compatibility, it&amp;rsquo;s always newlib for elf now.</source>
          <target state="translated">为了兼容性，它现在始终是elf的newlib。</target>
        </trans-unit>
        <trans-unit id="4859bddb1e6f097bf4875ee4cd32afb8f33d13e6" translate="yes" xml:space="preserve">
          <source>For convenience, it is allowed to use a binary vector operation where one operand is a scalar. In that case the compiler transforms the scalar operand into a vector where each element is the scalar from the operation. The transformation happens only if the scalar could be safely converted to the vector-element type. Consider the following code.</source>
          <target state="translated">为了方便起见,允许使用二进制向量操作,其中一个操作数是一个标量。在这种情况下,编译器会将标量操作数转换为一个向量,其中每个元素都是操作数的标量。只有当标量可以安全地转换为向量元素类型时,才会发生这种转换。考虑以下代码。</target>
        </trans-unit>
        <trans-unit id="3d923f6f173753b3c978292a218e04d22288b211" translate="yes" xml:space="preserve">
          <source>For conversion to a type of width &lt;em&gt;N&lt;/em&gt;, the value is reduced modulo &lt;em&gt;2^N&lt;/em&gt; to be within range of the type; no signal is raised.</source>
          <target state="translated">为了转换为宽度&lt;em&gt;N&lt;/em&gt;的类型，将值模&lt;em&gt;2 ^ N&lt;/em&gt;减小到该类型的范围内；没有信号发出。</target>
        </trans-unit>
        <trans-unit id="c0bc316f0ef750b2316cb1b5e8278752dde4a8ca" translate="yes" xml:space="preserve">
          <source>For deciding the optimization level of body.</source>
          <target state="translated">用于决定身体的优化程度。</target>
        </trans-unit>
        <trans-unit id="3216191fb385483c1e97afafeea464af935a4944" translate="yes" xml:space="preserve">
          <source>For devices not in &lt;code&gt;avrtiny&lt;/code&gt; or &lt;code&gt;avrxmega3&lt;/code&gt;, any data including read-only data is located in RAM (the generic address space) because flash memory is not visible in the RAM address space. In order to locate read-only data in flash memory &lt;em&gt;and&lt;/em&gt; to generate the right instructions to access this data without using (inline) assembler code, special address spaces are needed.</source>
          <target state="translated">对于不在 &lt;code&gt;avrtiny&lt;/code&gt; 或 &lt;code&gt;avrxmega3&lt;/code&gt; 中的设备，包括只读数据在内的任何数据都位于RAM（通用地址空间）中，因为闪存在RAM地址空间中不可见。为了在闪存中定位只读数据&lt;em&gt;并&lt;/em&gt;生成正确的指令以访问该数据而无需使用（内联）汇编代码，需要特殊的地址空间。</target>
        </trans-unit>
        <trans-unit id="0733ee9be6e082cc123e5464c02486573ae7f9cd" translate="yes" xml:space="preserve">
          <source>For documentation of &lt;code&gt;altivec&lt;/code&gt; attribute please see the documentation in &lt;a href=&quot;type-attributes#PowerPC-Type-Attributes&quot;&gt;PowerPC Type Attributes&lt;/a&gt;.</source>
          <target state="translated">有关 &lt;code&gt;altivec&lt;/code&gt; 属性的文档，请参阅&lt;a href=&quot;type-attributes#PowerPC-Type-Attributes&quot;&gt;PowerPC类型属性中&lt;/a&gt;的文档。</target>
        </trans-unit>
        <trans-unit id="eb3f33ef599bbcb991ed9de189514be3fb2765a7" translate="yes" xml:space="preserve">
          <source>For each Objective-C class, check if any of its instance variables is a C++ object with a non-trivial default constructor. If so, synthesize a special &lt;code&gt;- (id) .cxx_construct&lt;/code&gt; instance method which runs non-trivial default constructors on any such instance variables, in order, and then return &lt;code&gt;self&lt;/code&gt;. Similarly, check if any instance variable is a C++ object with a non-trivial destructor, and if so, synthesize a special &lt;code&gt;- (void) .cxx_destruct&lt;/code&gt; method which runs all such default destructors, in reverse order.</source>
          <target state="translated">对于每个Objective-C类，请检查其任何实例变量是否是带有非平凡默认构造函数的C ++对象。如果是这样，请合成一个特殊的 &lt;code&gt;- (id) .cxx_construct&lt;/code&gt; 实例方法，该方法对任何此类实例变量按顺序运行非平凡的默认构造函数，然后返回 &lt;code&gt;self&lt;/code&gt; 。同样，检查任何实例变量是否是带有非平凡析构函数的C ++对象，如果是，则合成一个特殊的 &lt;code&gt;- (void) .cxx_destruct&lt;/code&gt; 方法，该方法以相反的顺序运行所有此类默认析构函数。</target>
        </trans-unit>
        <trans-unit id="ecabcf6fb487210c3e414abe28454af79991a5a8" translate="yes" xml:space="preserve">
          <source>For each basic block, a line is printed after the last line of the basic block describing the branch or call that ends the basic block. There can be multiple branches and calls listed for a single source line if there are multiple basic blocks that end on that line. In this case, the branches and calls are each given a number. There is no simple way to map these branches and calls back to source constructs. In general, though, the lowest numbered branch or call will correspond to the leftmost construct on the source line.</source>
          <target state="translated">对于每个基本块,在基本块的最后一行之后打印一行,描述结束基本块的分支或调用。如果有多个基本块在一条源线上结束,那么可以为该线列出多个分支和调用。在这种情况下,分支和调用都被赋予一个编号。没有简单的方法可以将这些分支和调用映射回源构造。但一般来说,编号最低的分支或调用将对应于源行上最左边的构造。</target>
        </trans-unit>
        <trans-unit id="7d57dddd1f25be9ff5b83775303a0d6d59fce852" translate="yes" xml:space="preserve">
          <source>For each built-in function for AVR, there is an equally named, uppercase built-in macro defined. That way users can easily query if or if not a specific built-in is implemented or not. For example, if &lt;code&gt;__builtin_avr_nop&lt;/code&gt; is available the macro &lt;code&gt;__BUILTIN_AVR_NOP&lt;/code&gt; is defined to &lt;code&gt;1&lt;/code&gt; and undefined otherwise.</source>
          <target state="translated">对于AVR的每个内置函数，都定义了一个同名的大写内置宏。这样，用户可以轻松查询是否实现了特定的内置程序。例如，如果 &lt;code&gt;__builtin_avr_nop&lt;/code&gt; 可用，则宏 &lt;code&gt;__BUILTIN_AVR_NOP&lt;/code&gt; 定义为 &lt;code&gt;1&lt;/code&gt; ，否则未定义。</target>
        </trans-unit>
        <trans-unit id="d11a6b019eb02c22d6e7924e271f0d952fce8600" translate="yes" xml:space="preserve">
          <source>For each function, a line is printed showing how many times the function is called, how many times it returns and what percentage of the function&amp;rsquo;s blocks were executed.</source>
          <target state="translated">对于每个函数，将打印一行以显示该函数被调用了多少次，返回了多少次以及执行了多少百分比的功能块。</target>
        </trans-unit>
        <trans-unit id="4bcb841b4282f8986587d3e6966d3ed8c8dbe585" translate="yes" xml:space="preserve">
          <source>For each language compiled by GCC for which there is a standard, GCC attempts to follow one or more versions of that standard, possibly with some exceptions, and possibly with some extensions.</source>
          <target state="translated">对于GCC编译的每一种有标准的语言,GCC都试图遵循该标准的一个或多个版本,可能有一些例外,也可能有一些扩展。</target>
        </trans-unit>
        <trans-unit id="454897cc2fe9ad183bab2f7040fb6e5f25d9835d" translate="yes" xml:space="preserve">
          <source>For each named address space supported by avr-gcc there is an equally named but uppercase built-in macro defined. The purpose is to facilitate testing if respective address space support is available or not:</source>
          <target state="translated">对于avr-gcc支持的每个命名的地址空间,都定义了一个同样命名但大写的内置宏。这样做的目的是为了方便测试各个地址空间是否支持。</target>
        </trans-unit>
        <trans-unit id="a3f4882138b251f321ad16e203354e1a8d314d76" translate="yes" xml:space="preserve">
          <source>For each of the other indicated dump files (</source>
          <target state="translated">对于其他每个指定的转储文件(</target>
        </trans-unit>
        <trans-unit id="52f8ea439a283b5dc96c21715d0fefc3004bcf28" translate="yes" xml:space="preserve">
          <source>For each subprogram to be run, the compiler driver first tries the</source>
          <target state="translated">对于每个要运行的子程序,编译器驱动程序首先会尝试使用</target>
        </trans-unit>
        <trans-unit id="fdc4fc8f69b51e6f564843d4ff6b4102d66402dd" translate="yes" xml:space="preserve">
          <source>For even more AVR-specific built-in macros see &lt;a href=&quot;named-address-spaces#AVR-Named-Address-Spaces&quot;&gt;AVR Named Address Spaces&lt;/a&gt; and &lt;a href=&quot;avr-built_002din-functions#AVR-Built_002din-Functions&quot;&gt;AVR Built-in Functions&lt;/a&gt;.</source>
          <target state="translated">有关更多特定于AVR的内置宏，请参见&lt;a href=&quot;named-address-spaces#AVR-Named-Address-Spaces&quot;&gt;AVR命名地址空间&lt;/a&gt;和&lt;a href=&quot;avr-built_002din-functions#AVR-Built_002din-Functions&quot;&gt;AVR内置函数&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1baa0cc1603bf61303a12aa930a0094973d11cab" translate="yes" xml:space="preserve">
          <source>For example in the structure below, the member array &lt;code&gt;x&lt;/code&gt; is packed so that it immediately follows &lt;code&gt;a&lt;/code&gt; with no intervening padding:</source>
          <target state="translated">例如，在下面的结构中，成员数组 &lt;code&gt;x&lt;/code&gt; 被打包，因此它紧跟在 &lt;code&gt;a&lt;/code&gt; 之后，中间没有填充：</target>
        </trans-unit>
        <trans-unit id="6db6725e9e7d5c088630e348048d1e73fc7657d3" translate="yes" xml:space="preserve">
          <source>For example,</source>
          <target state="translated">例如:</target>
        </trans-unit>
        <trans-unit id="67c7bfe6911146baef42ccf95311646fa6de1225" translate="yes" xml:space="preserve">
          <source>For example, &amp;lsquo;</source>
          <target state="translated">例如， '</target>
        </trans-unit>
        <trans-unit id="f35aae572eaa511b9e1fec745e2f41aff9a397c4" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;-MT '$(objpfx)foo.o'&lt;/code&gt; might give</source>
          <target state="translated">例如， &lt;code&gt;-MT '$(objpfx)foo.o'&lt;/code&gt; 可能会给出</target>
        </trans-unit>
        <trans-unit id="687851312bf05d13456ec79c098b24da9ffe5635" translate="yes" xml:space="preserve">
          <source>For example, GCC warns about &lt;code&gt;i&lt;/code&gt; being uninitialized in the following snippet only when</source>
          <target state="translated">例如，GCC 仅在以下情况下警告 &lt;code&gt;i&lt;/code&gt; 未在以下代码段中初始化</target>
        </trans-unit>
        <trans-unit id="481bf59d3e774632a4ae291477b6e304f7e4939c" translate="yes" xml:space="preserve">
          <source>For example, a bounded case of &lt;code&gt;alloca&lt;/code&gt; could be:</source>
          <target state="translated">例如， &lt;code&gt;alloca&lt;/code&gt; 的有限情况可能是：</target>
        </trans-unit>
        <trans-unit id="b71521cff46dbe352ddadd34594ed3081919fa62" translate="yes" xml:space="preserve">
          <source>For example, a method with no arguments and returning &lt;code&gt;int&lt;/code&gt; would have the signature &lt;code&gt;i8@0:4&lt;/code&gt; if the size of a pointer is 4. The signature is interpreted as follows: the &lt;code&gt;i&lt;/code&gt; is the return type (an &lt;code&gt;int&lt;/code&gt;), the &lt;code&gt;8&lt;/code&gt; is the total size of the parameters in bytes (two pointers each of size 4), the &lt;code&gt;@0&lt;/code&gt; is the first parameter (an object at byte offset &lt;code&gt;0&lt;/code&gt;) and &lt;code&gt;:4&lt;/code&gt; is the second parameter (a &lt;code&gt;SEL&lt;/code&gt; at byte offset &lt;code&gt;4&lt;/code&gt;).</source>
          <target state="translated">例如，如果一个指针的大小为 &lt;code&gt;i8@0:4&lt;/code&gt; ，则不带参数且返回 &lt;code&gt;int&lt;/code&gt; 的方法的签名为i8 @ 0：4。签名的解释如下： &lt;code&gt;i&lt;/code&gt; 是返回类型（ &lt;code&gt;int&lt;/code&gt; ）， &lt;code&gt;8&lt;/code&gt; 是参数的总大小（以字节为单位）（两个指针，每个指针的大小均为4）， &lt;code&gt;@0&lt;/code&gt; 是第一个参数（对象在字节偏移量 &lt;code&gt;0&lt;/code&gt; 处），而 &lt;code&gt;:4&lt;/code&gt; 是第二个参数（ &lt;code&gt;SEL&lt;/code&gt; 在字节偏移量 &lt;code&gt;4&lt;/code&gt; 处）。</target>
        </trans-unit>
        <trans-unit id="68ba042328cca36e153d2c8dab7d8879565e3845" translate="yes" xml:space="preserve">
          <source>For example, a program may use a function &lt;code&gt;strfunc&lt;/code&gt; that returns &lt;code&gt;string&lt;/code&gt; objects, and another function &lt;code&gt;charfunc&lt;/code&gt; that operates on pointers to &lt;code&gt;char&lt;/code&gt;:</source>
          <target state="translated">例如，程序可以使用函数 &lt;code&gt;strfunc&lt;/code&gt; 返回 &lt;code&gt;string&lt;/code&gt; 对象，而另一个函数 &lt;code&gt;charfunc&lt;/code&gt; 对 &lt;code&gt;char&lt;/code&gt; 的指针进行操作：</target>
        </trans-unit>
        <trans-unit id="88bf56d21a567365b50f7c0d1260f3e77c253d14" translate="yes" xml:space="preserve">
          <source>For example, a spec string like this:</source>
          <target state="translated">例如,像这样的规格字符串。</target>
        </trans-unit>
        <trans-unit id="9636aa78a9470d85d5322503884f630474bbcbd8" translate="yes" xml:space="preserve">
          <source>For example, an address which is constant is offsettable; so is an address that is the sum of a register and a constant (as long as a slightly larger constant is also within the range of address-offsets supported by the machine); but an autoincrement or autodecrement address is not offsettable. More complicated indirect/indexed addresses may or may not be offsettable depending on the other addressing modes that the machine supports.</source>
          <target state="translated">例如,一个常数的地址是可以偏移的;一个寄存器和一个常数之和的地址也是可以偏移的(只要一个稍大的常数也在机器支持的地址偏移范围内);但一个自动增量或自动减量的地址是不可偏移的。更复杂的间接/索引地址可能是可偏移的,也可能是不可偏移的,这取决于机器支持的其他寻址模式。</target>
        </trans-unit>
        <trans-unit id="bb39fad998b5526c7cd037c77aee5706a45b5058" translate="yes" xml:space="preserve">
          <source>For example, by default a structure containing nothing but 8 &lt;code&gt;unsigned&lt;/code&gt; bit-fields of length 1 is aligned to a 4-byte boundary and has a size of 4 bytes. By using</source>
          <target state="translated">例如，默认情况下，仅包含8个长度为1的 &lt;code&gt;unsigned&lt;/code&gt; 位域的结构与4字节边界对齐，并且大小为4字节。通过使用</target>
        </trans-unit>
        <trans-unit id="44c92e45a35c2e3631a1416540d7623d393688e2" translate="yes" xml:space="preserve">
          <source>For example, code using the standard ISA encoding cannot jump directly to MIPS16 or microMIPS code; it must either use a call or an indirect jump.</source>
          <target state="translated">例如,使用标准ISA编码的代码不能直接跳转到MIPS16或microMIPS代码,必须使用调用或间接跳转。</target>
        </trans-unit>
        <trans-unit id="6d3c95f985f19da9d6dbc1a830c9da53b0e26416" translate="yes" xml:space="preserve">
          <source>For example, given this C source file:</source>
          <target state="translated">例如,给定这个C源文件。</target>
        </trans-unit>
        <trans-unit id="f0defbb763ebb18b66cf3162b2b446b84c5034e8" translate="yes" xml:space="preserve">
          <source>For example, if an x86 compiler supports two dialects (&amp;lsquo;</source>
          <target state="translated">例如，如果x86编译器支持两种方言（'</target>
        </trans-unit>
        <trans-unit id="9b3c7e9c23ebc44c980aef19936a5699e234861d" translate="yes" xml:space="preserve">
          <source>For example, if the object file</source>
          <target state="translated">例如,如果对象文件</target>
        </trans-unit>
        <trans-unit id="6277fc8469340ab02cc75749b9fdf00e3b3028a6" translate="yes" xml:space="preserve">
          <source>For example, if the target machine requires a &lt;code&gt;double&lt;/code&gt; value to be aligned on an 8-byte boundary, then &lt;code&gt;__alignof__ (double)&lt;/code&gt; is 8. This is true on many RISC machines. On more traditional machine designs, &lt;code&gt;__alignof__ (double)&lt;/code&gt; is 4 or even 2.</source>
          <target state="translated">例如，如果目标机器需要一个 &lt;code&gt;double&lt;/code&gt; 值到8字节的边界上对齐，然后 &lt;code&gt;__alignof__ (double)&lt;/code&gt; 为8。这是许多RISC机器真。在更传统的机器设计中， &lt;code&gt;__alignof__ (double)&lt;/code&gt; 为4甚至2。</target>
        </trans-unit>
        <trans-unit id="ace71a372dd9faf87968abc19f07a8c712084e3c" translate="yes" xml:space="preserve">
          <source>For example, in the following function the call to &lt;code&gt;g&lt;/code&gt; is unsafe because when &lt;code&gt;overalign&lt;/code&gt; is non-zero, the space allocated by &lt;code&gt;__builtin_alloca_with_align&lt;/code&gt; may have been released at the end of the &lt;code&gt;if&lt;/code&gt; statement in which it was called.</source>
          <target state="translated">例如，在以下函数中，对 &lt;code&gt;g&lt;/code&gt; 的调用是不安全的，因为当 &lt;code&gt;overalign&lt;/code&gt; 不为零时，由 &lt;code&gt;__builtin_alloca_with_align&lt;/code&gt; 分配的空间可能已在其被调用的 &lt;code&gt;if&lt;/code&gt; 语句的末尾释放。</target>
        </trans-unit>
        <trans-unit id="b982bcc761519bf794d14c5f76ed85a5c03967e1" translate="yes" xml:space="preserve">
          <source>For example, in the following, each call to function &lt;code&gt;foo&lt;/code&gt; will print a line similar to &lt;code&gt;&quot;file.c:123: foo: message&quot;&lt;/code&gt; with the name of the file and the line number of the &lt;code&gt;printf&lt;/code&gt; call, the name of the function &lt;code&gt;foo&lt;/code&gt;, followed by the word &lt;code&gt;message&lt;/code&gt;.</source>
          <target state="translated">例如，在下面的代码中，每次对函数 &lt;code&gt;foo&lt;/code&gt; 的调用都将打印类似于 &lt;code&gt;&quot;file.c:123: foo: message&quot;&lt;/code&gt; 的行，并带有文件名和 &lt;code&gt;printf&lt;/code&gt; 调用的行号，即函数 &lt;code&gt;foo&lt;/code&gt; 的名称，然后是 &lt;code&gt;message&lt;/code&gt; 一词。</target>
        </trans-unit>
        <trans-unit id="55f28e4d67f6e114f470b97bac400ac0e25f6328" translate="yes" xml:space="preserve">
          <source>For example, on the 68000 in a fullword instruction it is possible to use an immediate operand; but if the immediate value is between -128 and 127, better code results from loading the value into a register and using the register. This is because the load into the register can be done with a &amp;lsquo;</source>
          <target state="translated">例如，在68000的全字指令中，可以使用立即数操作数。但是如果立即数在-128到127之间，则将值加载到寄存器中并使用该寄存器会产生更好的代码。这是因为可以通过'</target>
        </trans-unit>
        <trans-unit id="2f76b920d411b7e136fa4f9061e5e0a37ad6c0c4" translate="yes" xml:space="preserve">
          <source>For example, since the declaration of the primary function template below makes use of both attribute &lt;code&gt;malloc&lt;/code&gt; and &lt;code&gt;alloc_size&lt;/code&gt; the declaration of the explicit specialization of the template is diagnosed because it is missing one of the attributes.</source>
          <target state="translated">例如，由于下面的主要功能模板的声明同时使用了属性 &lt;code&gt;malloc&lt;/code&gt; 和 &lt;code&gt;alloc_size&lt;/code&gt; ，因此可以诊断模板的显式特化的声明，因为它缺少属性之一。</target>
        </trans-unit>
        <trans-unit id="c1b19cb164dc1a4ab8a759ac490b8fde220e9c5e" translate="yes" xml:space="preserve">
          <source>For example, suppose &lt;code&gt;struct A&lt;/code&gt; below is defined in some third party library header to have the alignment requirement &lt;code&gt;N&lt;/code&gt; and to force a warning whenever a variable of the type is not so aligned due to attribute &lt;code&gt;packed&lt;/code&gt;. Specifying the &lt;code&gt;copy&lt;/code&gt; attribute on the definition on the unrelated &lt;code&gt;struct B&lt;/code&gt; has the effect of copying all relevant attributes from the type referenced by the pointer expression to &lt;code&gt;struct B&lt;/code&gt;.</source>
          <target state="translated">例如，假设下面的 &lt;code&gt;struct A&lt;/code&gt; 在某个第三方库标头中定义为具有对齐要求 &lt;code&gt;N&lt;/code&gt; ,并在由于属性 &lt;code&gt;packed&lt;/code&gt; 而导致类型变量未如此对齐时强制发出警告。在不相关的 &lt;code&gt;struct B&lt;/code&gt; 的定义上指定 &lt;code&gt;copy&lt;/code&gt; 属性具有将所有相关属性从指针表达式引用的类型复制到 &lt;code&gt;struct B&lt;/code&gt; 的作用。</target>
        </trans-unit>
        <trans-unit id="f0be048f3761817dd96f745d3c57100422574646" translate="yes" xml:space="preserve">
          <source>For example, the &lt;code&gt;sprintf&lt;/code&gt; function on SunOS 4.1.3 returns &lt;code&gt;char *&lt;/code&gt; while the C standard says that &lt;code&gt;sprintf&lt;/code&gt; returns an &lt;code&gt;int&lt;/code&gt;. The &lt;code&gt;fixincludes&lt;/code&gt; program could make the prototype for this function match the Standard, but that would be wrong, since the function will still return &lt;code&gt;char *&lt;/code&gt;.</source>
          <target state="translated">例如，SunOS 4.1.3上的 &lt;code&gt;sprintf&lt;/code&gt; 函数返回 &lt;code&gt;char *&lt;/code&gt; ,而C标准表示 &lt;code&gt;sprintf&lt;/code&gt; 返回 &lt;code&gt;int&lt;/code&gt; 。该 &lt;code&gt;fixincludes&lt;/code&gt; 程序可以使原型这一功能相匹配的标准，但这是错误的，因为该功能也会返回 &lt;code&gt;char *&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bd82a792fa22143d94897d2b758fc399175bbe0e" translate="yes" xml:space="preserve">
          <source>For example, the &lt;var&gt;StrongAlias&lt;/var&gt; macro below makes use of the &lt;code&gt;alias&lt;/code&gt; and &lt;code&gt;copy&lt;/code&gt; attributes to define an alias named &lt;var&gt;alloc&lt;/var&gt; for function &lt;var&gt;allocate&lt;/var&gt; declared with attributes &lt;var&gt;alloc_size&lt;/var&gt;, &lt;var&gt;malloc&lt;/var&gt;, and &lt;var&gt;nothrow&lt;/var&gt;. Thanks to the &lt;code&gt;__typeof__&lt;/code&gt; operator the alias has the same type as the target function. As a result of the &lt;code&gt;copy&lt;/code&gt; attribute the alias also shares the same attributes as the target.</source>
          <target state="translated">例如， &lt;var&gt;StrongAlias&lt;/var&gt; 宏观下方品牌使用的 &lt;code&gt;alias&lt;/code&gt; 和 &lt;code&gt;copy&lt;/code&gt; 属性来定义命名的别名 &lt;var&gt;alloc&lt;/var&gt; 的功能 &lt;var&gt;allocate&lt;/var&gt; 与属性声明 &lt;var&gt;alloc_size&lt;/var&gt; ， &lt;var&gt;malloc&lt;/var&gt; 的，并 &lt;var&gt;nothrow&lt;/var&gt; 。多亏了 &lt;code&gt;__typeof__&lt;/code&gt; 运算符，别名与目标函数具有相同的类型。由于 &lt;code&gt;copy&lt;/code&gt; 属性，别名也与目标共享相同的属性。</target>
        </trans-unit>
        <trans-unit id="5df659eda3281e74be2356574e1b1c1a2ec73bd0" translate="yes" xml:space="preserve">
          <source>For example, the call to &lt;code&gt;memset&lt;/code&gt; below is diagnosed by the warning because the function expects a value of type &lt;code&gt;size_t&lt;/code&gt; as its argument but the type of &lt;code&gt;32&lt;/code&gt; is &lt;code&gt;int&lt;/code&gt;. With</source>
          <target state="translated">例如，对以下 &lt;code&gt;memset&lt;/code&gt; 的调用通过警告进行诊断，因为该函数希望将 &lt;code&gt;size_t&lt;/code&gt; 类型的值作为其自变量，而类型 &lt;code&gt;32&lt;/code&gt; 是 &lt;code&gt;int&lt;/code&gt; 。用</target>
        </trans-unit>
        <trans-unit id="aa585d900b6a1decabca1b2daabff17e2775d789" translate="yes" xml:space="preserve">
          <source>For example, the compiler can only unconditionally vectorize the following loop with the pragma:</source>
          <target state="translated">例如,编译器只能用pragma无条件向量化下面的循环。</target>
        </trans-unit>
        <trans-unit id="46fb01ed368f209c80511e7fc1fb91adc3f606e1" translate="yes" xml:space="preserve">
          <source>For example, the declaration of &lt;code&gt;struct Object&lt;/code&gt; in the argument list of &lt;code&gt;draw&lt;/code&gt; triggers the warning. To avoid it, either remove the redundant class-key &lt;code&gt;struct&lt;/code&gt; or replace it with &lt;code&gt;class&lt;/code&gt; to match its definition.</source>
          <target state="translated">例如，在 &lt;code&gt;draw&lt;/code&gt; 参数列表中声明 &lt;code&gt;struct Object&lt;/code&gt; 会触发警告。为了避免这种情况，请删除冗余的class-key &lt;code&gt;struct&lt;/code&gt; 或将其替换为 &lt;code&gt;class&lt;/code&gt; 以匹配其定义。</target>
        </trans-unit>
        <trans-unit id="99f069ed5ba8ea293548f32b787eaedf45bdbd11" translate="yes" xml:space="preserve">
          <source>For example, the declaration:</source>
          <target state="translated">例如,声明:</target>
        </trans-unit>
        <trans-unit id="40a677ec7a2740cf56a10d8e5968835578281034" translate="yes" xml:space="preserve">
          <source>For example, the first two stores in function &lt;code&gt;bad&lt;/code&gt; are diagnosed because the array elements overlap the subsequent members &lt;code&gt;b&lt;/code&gt; and &lt;code&gt;c&lt;/code&gt;. The third store is diagnosed by</source>
          <target state="translated">例如，由于数组元素与后续成员 &lt;code&gt;b&lt;/code&gt; 和 &lt;code&gt;c&lt;/code&gt; 重叠，因此诊断出函数 &lt;code&gt;bad&lt;/code&gt; 中的前两个存储。第三家商店被诊断为</target>
        </trans-unit>
        <trans-unit id="b9ea9d42bbb55f00657375149871784a78c15592" translate="yes" xml:space="preserve">
          <source>For example, the following function allocates eight objects of &lt;code&gt;n&lt;/code&gt; bytes each on the stack, storing a pointer to each in consecutive elements of the array &lt;code&gt;a&lt;/code&gt;. It then passes the array to function &lt;code&gt;g&lt;/code&gt; which can safely use the storage pointed to by each of the array elements.</source>
          <target state="translated">例如，以下函数在堆栈上分配八个 &lt;code&gt;n&lt;/code&gt; 个字节的对象，并在数组 &lt;code&gt;a&lt;/code&gt; 的连续元素中存储指向每个对象的指针。然后，它将数组传递给函数 &lt;code&gt;g&lt;/code&gt; ，该函数可以安全地使用每个数组元素指向的存储。</target>
        </trans-unit>
        <trans-unit id="46ff8877e2ba5b3ad38e512c93a9f9393792e49a" translate="yes" xml:space="preserve">
          <source>For example, the following macro can be used to portably check, at compile-time, whether or not adding two constant integers will overflow, and perform the addition only when it is known to be safe and not to trigger a</source>
          <target state="translated">例如,可以使用下面的宏在编译时可移植地检查两个常数整数相加是否会溢出,只有在已知安全的情况下才执行加法,并且不会触发一个</target>
        </trans-unit>
        <trans-unit id="0a5e19a07f0f940d54dbc5e573ed269580925a99" translate="yes" xml:space="preserve">
          <source>For example, the following:</source>
          <target state="translated">例如,下列情况:</target>
        </trans-unit>
        <trans-unit id="f3e3332c2d5e42f3076c20bce36d2593f9127ee9" translate="yes" xml:space="preserve">
          <source>For example, the implementation of the following function &lt;code&gt;foo&lt;/code&gt;:</source>
          <target state="translated">例如，执行以下函数 &lt;code&gt;foo&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="0e188aff9d720764d35dd90d13b53f0b69cd5a6e" translate="yes" xml:space="preserve">
          <source>For example, the intraprocedural example shown for</source>
          <target state="translated">例如,图中所示的程序内例子为</target>
        </trans-unit>
        <trans-unit id="da4fa7f73b59dbaab5c10c7cbf8d1067ea1077b7" translate="yes" xml:space="preserve">
          <source>For example, the same events as above might be printed as:</source>
          <target state="translated">例如,与上述相同的事件可能被打印成:</target>
        </trans-unit>
        <trans-unit id="71a4e8c7eb0a1fa15ef7a86f7ffb6699626c80d0" translate="yes" xml:space="preserve">
          <source>For example, this function has to be used in &lt;code&gt;ifunc&lt;/code&gt; resolvers that check for CPU type using the built-in functions &lt;code&gt;__builtin_cpu_is&lt;/code&gt; and &lt;code&gt;__builtin_cpu_supports&lt;/code&gt;, or in constructors on targets that don&amp;rsquo;t support constructor priority.</source>
          <target state="translated">例如，必须在使用内置函数 &lt;code&gt;__builtin_cpu_is&lt;/code&gt; 和 &lt;code&gt;__builtin_cpu_supports&lt;/code&gt; 检查CPU类型的 &lt;code&gt;ifunc&lt;/code&gt; 解析器中，或者在不支持构造函数优先级的目标上的构造函数中，使用此函数。</target>
        </trans-unit>
        <trans-unit id="1dddf36660113e27ff669ff510c160e144321d93" translate="yes" xml:space="preserve">
          <source>For example, when the compiler encounters a method invocation such as &lt;code&gt;[object init]&lt;/code&gt;, it compiles it into a call to &lt;code&gt;objc_msg_lookup (object, @selector(init))&lt;/code&gt; followed by a cast of the returned value to the appropriate function pointer type, and then it calls it.</source>
          <target state="translated">例如，当编译器遇到诸如 &lt;code&gt;[object init]&lt;/code&gt; 之类的方法调用时，它会将其编译为对 &lt;code&gt;objc_msg_lookup (object, @selector(init))&lt;/code&gt; 的调用，然后将返回值强制转换为适当的函数指针类型，并且然后它称之为。</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">例如:</target>
        </trans-unit>
        <trans-unit id="25bb7aced1792aec854f4198d7d0398ca1d4713d" translate="yes" xml:space="preserve">
          <source>For full documentation of the struct attributes please see the documentation in &lt;a href=&quot;variable-attributes#x86-Variable-Attributes&quot;&gt;x86 Variable Attributes&lt;/a&gt;.</source>
          <target state="translated">有关struct属性的完整文档，请参见&lt;a href=&quot;variable-attributes#x86-Variable-Attributes&quot;&gt;x86 Variable Attributes中&lt;/a&gt;的文档。</target>
        </trans-unit>
        <trans-unit id="3dc81c80b4604ccbc276f437a5ccc2aaa2515f6c" translate="yes" xml:space="preserve">
          <source>For indirect calls to functions and computed goto, the linker generates &lt;em&gt;stubs&lt;/em&gt;. Stubs are jump pads sometimes also called &lt;em&gt;trampolines&lt;/em&gt;. Thus, the indirect call/jump jumps to such a stub. The stub contains a direct jump to the desired address.</source>
          <target state="translated">对于函数的间接调用和计算出的goto，链接器生成&lt;em&gt;存根&lt;/em&gt;。存根是跳板，有时也称为&lt;em&gt;蹦床&lt;/em&gt;。因此，间接调用/跳转跳转到这样的存根。存根包含直接跳转到所需地址的信息。</target>
        </trans-unit>
        <trans-unit id="b91d6fa4ba31d00f68a512834bc7eb5f8c52df71" translate="yes" xml:space="preserve">
          <source>For information about the O64 ABI, see &lt;a href=&quot;http://gcc.gnu.org/projects/mipso64-abi.html&quot;&gt;http://gcc.gnu.org/projects/mipso64-abi.html&lt;/a&gt;.</source>
          <target state="translated">有关O64 ABI的信息，请参见&lt;a href=&quot;http://gcc.gnu.org/projects/mipso64-abi.html&quot;&gt;http://gcc.gnu.org/projects/mipso64-abi.html&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="56ee49f1a1b16838ed8d136422788b22655be9ea" translate="yes" xml:space="preserve">
          <source>For input files in any language, generate corresponding Go declarations in &lt;var&gt;file&lt;/var&gt;. This generates Go &lt;code&gt;const&lt;/code&gt;, &lt;code&gt;type&lt;/code&gt;, &lt;code&gt;var&lt;/code&gt;, and &lt;code&gt;func&lt;/code&gt; declarations which may be a useful way to start writing a Go interface to code written in some other language.</source>
          <target state="translated">对于任何语言的输入文件，请在 &lt;var&gt;file&lt;/var&gt; 中生成相应的Go声明。这会生成Go &lt;code&gt;const&lt;/code&gt; ， &lt;code&gt;type&lt;/code&gt; ， &lt;code&gt;var&lt;/code&gt; 和 &lt;code&gt;func&lt;/code&gt; 声明，这可能是开始编写Go接口​​以使用其他语言编写的代码的有用方法。</target>
        </trans-unit>
        <trans-unit id="c8ce6c094048677a9f8423fec4581d4ef1bd1e5b" translate="yes" xml:space="preserve">
          <source>For instance</source>
          <target state="translated">比如说</target>
        </trans-unit>
        <trans-unit id="23b7041567e33cbc564ac905e83c0e92b5fee08b" translate="yes" xml:space="preserve">
          <source>For instance,</source>
          <target state="translated">例如:</target>
        </trans-unit>
        <trans-unit id="a8e07e43db118dd56bbb97b1f96ccc89bac7f5fd" translate="yes" xml:space="preserve">
          <source>For instance, if the stack starts at absolute address &amp;lsquo;</source>
          <target state="translated">例如，如果堆栈从绝对地址'开始</target>
        </trans-unit>
        <trans-unit id="6abfd7e7f05346e1123b7bf2021cc93c61b8fbd5" translate="yes" xml:space="preserve">
          <source>For instance, if you have &lt;code&gt;#include &quot;all.h&quot;&lt;/code&gt;, and you have</source>
          <target state="translated">例如，如果您具有 &lt;code&gt;#include &quot;all.h&quot;&lt;/code&gt; ，并且您具有</target>
        </trans-unit>
        <trans-unit id="5b9b6fe2256c52fcd89c847ec80034c7cbe3d49d" translate="yes" xml:space="preserve">
          <source>For instance, on an x86, you could compile a function with &lt;code&gt;target_clones(&quot;sse4.1,avx&quot;)&lt;/code&gt;. GCC creates two function clones, one compiled with</source>
          <target state="translated">例如，在x86上，您可以使用 &lt;code&gt;target_clones(&quot;sse4.1,avx&quot;)&lt;/code&gt; 编译函数。GCC创建了两个函数克隆，其中一个用</target>
        </trans-unit>
        <trans-unit id="175bbce2fc22d4ed1ec7614154a0e449231ccaf1" translate="yes" xml:space="preserve">
          <source>For instance, on an x86, you could declare one function with the &lt;code&gt;target(&quot;sse4.1,arch=core2&quot;)&lt;/code&gt; attribute and another with &lt;code&gt;target(&quot;sse4a,arch=amdfam10&quot;)&lt;/code&gt;. This is equivalent to compiling the first function with</source>
          <target state="translated">例如，在x86上，您可以使用 &lt;code&gt;target(&quot;sse4.1,arch=core2&quot;)&lt;/code&gt; 属性声明一个函数，并使用 &lt;code&gt;target(&quot;sse4a,arch=amdfam10&quot;)&lt;/code&gt; 属性声明另一个函数。这等效于使用</target>
        </trans-unit>
        <trans-unit id="60600b26a9fa03b6c3650e82a7d4514147301ef9" translate="yes" xml:space="preserve">
          <source>For instance, on the SB-1, if FP exceptions are disabled, and we are emitting 64-bit code, then we can use both FP pipes. Otherwise, we can only use one FP pipe.</source>
          <target state="translated">例如,在SB-1上,如果FP异常被禁用,并且我们要发射64位代码,那么我们可以使用两个FP管道。否则,我们只能使用一个FP管道。</target>
        </trans-unit>
        <trans-unit id="4d64dcd6f25c2f8e61dbb8fbe7c56bdb2499ab6d" translate="yes" xml:space="preserve">
          <source>For instance, the following declarations</source>
          <target state="translated">例如,以下声明</target>
        </trans-unit>
        <trans-unit id="fd17d596f35be2211443642e76ceab4e5f526b5c" translate="yes" xml:space="preserve">
          <source>For internal names, all characters are significant. For external names, the number of significant characters are defined by the linker; for almost all targets, all characters are significant.</source>
          <target state="translated">对于内部名称,所有的字符都是重要的。对于外部名称,重要字符的数量由链接器定义;对于几乎所有目标,所有字符都是重要的。</target>
        </trans-unit>
        <trans-unit id="9f99386843936f29083f4368b21c1771def8a251" translate="yes" xml:space="preserve">
          <source>For library code, if you want the library to provide all of the template instantiations it needs, just try to link all of its object files together; the link will fail, but cause the instantiations to be generated as a side effect. Be warned, however, that this may cause conflicts if multiple libraries try to provide the same instantiations. For greater control, use explicit instantiation as described in the next option.</source>
          <target state="translated">对于库代码,如果你想让库提供它所需要的所有模板实例,只需尝试将其所有的对象文件链接在一起;链接会失败,但会导致实例生成的副作用。但要注意,如果多个库试图提供相同的实例,这可能会引起冲突。为了获得更大的控制权,请使用下一个选项中描述的显式实例化。</target>
        </trans-unit>
        <trans-unit id="275df5c8ab338eac0891dfd5fcb7ca333c414d1c" translate="yes" xml:space="preserve">
          <source>For machines that must pop arguments after a function call, always pop the arguments as soon as each function returns. At levels</source>
          <target state="translated">对于必须在函数调用后弹出参数的机器,总是在每个函数返回时立即弹出参数。在级别</target>
        </trans-unit>
        <trans-unit id="4ab62f1721d989066bd88fccf2cddf5cca6c289c" translate="yes" xml:space="preserve">
          <source>For more information concerning the history of Objective-C that is available online, see &lt;a href=&quot;http://gcc.gnu.org/readings.html&quot;&gt;http://gcc.gnu.org/readings.html&lt;/a&gt;</source>
          <target state="translated">有关可在线获得的有关Objective-C历史的更多信息，请参见&lt;a href=&quot;http://gcc.gnu.org/readings.html&quot;&gt;http://gcc.gnu.org/readings.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="af9da95259f3bd0345f2ca30bdb8d3f07bd5caf4" translate="yes" xml:space="preserve">
          <source>For more information on GCC&amp;rsquo;s support for transactional memory, See &lt;a href=&quot;https://gcc.gnu.org/onlinedocs/gcc-10.2.0/libitm/Enabling-libitm.html#Enabling-libitm&quot;&gt;The GNU Transactional Memory Library&lt;/a&gt; in GNU Transactional Memory Library.</source>
          <target state="translated">有关GCC对事务内存的支持的更多信息，请参见&lt;a href=&quot;https://gcc.gnu.org/onlinedocs/gcc-10.2.0/libitm/Enabling-libitm.html#Enabling-libitm&quot;&gt;GNU事务内存库&lt;/a&gt;中的GNU事务内存库。</target>
        </trans-unit>
        <trans-unit id="445882425cb6a5526123dcb90201317cd797b812" translate="yes" xml:space="preserve">
          <source>For more information on GCC&amp;rsquo;s support for transactional memory, See &lt;a href=&quot;https://gcc.gnu.org/onlinedocs/gcc-9.2.0/libitm/Enabling-libitm.html#Enabling-libitm&quot;&gt;The GNU Transactional Memory Library&lt;/a&gt; in GNU Transactional Memory Library.</source>
          <target state="translated">有关GCC对事务内存的支持的更多信息，请参见&lt;a href=&quot;https://gcc.gnu.org/onlinedocs/gcc-9.2.0/libitm/Enabling-libitm.html#Enabling-libitm&quot;&gt;GNU事务内存库&lt;/a&gt;中的GNU事务内存库。</target>
        </trans-unit>
        <trans-unit id="530d01e06da63e3ae60755b1d0e0664f37ce4c56" translate="yes" xml:space="preserve">
          <source>For profile-directed optimizations, compile the source files again with the same optimization and code generation options plus</source>
          <target state="translated">对于配置文件导向的优化,使用相同的优化和代码生成选项再编译一次源文件,加上</target>
        </trans-unit>
        <trans-unit id="1552bee1f905030b453e9bc73123ec457682d5d2" translate="yes" xml:space="preserve">
          <source>For references to Technical Corrigenda, Rationale documents and information concerning the history of C that is available online, see &lt;a href=&quot;http://gcc.gnu.org/readings.html&quot;&gt;http://gcc.gnu.org/readings.html&lt;/a&gt;</source>
          <target state="translated">有关可在线获取的有关技术勘误，基本原理文件和有关C历史的信息的参考，请参见&lt;a href=&quot;http://gcc.gnu.org/readings.html&quot;&gt;http://gcc.gnu.org/readings.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="98fa91b9c573243f46d98173cb5c6bc69a14f37e" translate="yes" xml:space="preserve">
          <source>For run-time identification, the starting addresses of these areas, which correspond to their respective function entries minus &lt;var&gt;M&lt;/var&gt;, are additionally collected in the &lt;code&gt;__patchable_function_entries&lt;/code&gt; section of the resulting binary.</source>
          <target state="translated">为了进行运行时识别，这些区域的起始地址（对应于它们各自的功能条目 &lt;var&gt;M&lt;/var&gt; ）将另外收集在生成的二进制文件的 &lt;code&gt;__patchable_function_entries&lt;/code&gt; 部分中。</target>
        </trans-unit>
        <trans-unit id="ee4662af110f3d316db91e4c9bf088b26f37f6fc" translate="yes" xml:space="preserve">
          <source>For single-precision floating-point comparisons, emit an &lt;code&gt;fsub&lt;/code&gt; instruction and test the flags. This is faster than a software comparison, but can get incorrect results in the presence of NaNs, or when two different small numbers are compared such that their difference is calculated as zero. The default is</source>
          <target state="translated">对于单精度浮点比较，发出 &lt;code&gt;fsub&lt;/code&gt; 指令并测试标志。这比软件比较快，但是在存在NaN时，或者在比较两个不同的小数以至于将它们的差计算为零时，可能会得到不正确的结果。默认是</target>
        </trans-unit>
        <trans-unit id="629fb7062147649cb1707cc8cbe18549c87c4fce" translate="yes" xml:space="preserve">
          <source>For some target machines, GCC supports additional options to the format attribute (see &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;Declaring Attributes of Functions&lt;/a&gt;).</source>
          <target state="translated">对于某些目标计算机，GCC支持format属性的其他选项（请参阅&lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;声明函数的属性&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="8f693ccd95fd0352057c89a84d6dca28111b1d8d" translate="yes" xml:space="preserve">
          <source>For some targets, a suffix is added to the root directory specified with</source>
          <target state="translated">对于某些目标,后缀会被添加到以</target>
        </trans-unit>
        <trans-unit id="1eef11d2e0af6679534eba00e39380a79330c652" translate="yes" xml:space="preserve">
          <source>For string operations of unknown size, use run-time checks with inline code for small blocks and a library call for large blocks.</source>
          <target state="translated">对于未知大小的字符串操作,使用运行时检查,小块用内联代码,大块用库调用。</target>
        </trans-unit>
        <trans-unit id="c54c726dd72dd80b773414b86e870a30d193ec02" translate="yes" xml:space="preserve">
          <source>For systems that use the GNU C Library, the default is on.</source>
          <target state="translated">对于使用GNU C库的系统,默认为开启。</target>
        </trans-unit>
        <trans-unit id="90889da6f3749d2d8e7f525edbcff60563fc34f5" translate="yes" xml:space="preserve">
          <source>For targets that do not support either COMDAT or weak symbols, most entities with vague linkage are emitted as local symbols to avoid duplicate definition errors from the linker. This does not happen for local statics in inlines, however, as having multiple copies almost certainly breaks things.</source>
          <target state="translated">对于既不支持COMDAT也不支持弱符号的目标,大多数具有模糊链接的实体都会以本地符号的形式发出,以避免链接器的重复定义错误。然而,这不会发生在inline中的本地静态,因为有多个副本几乎肯定会破坏事情。</target>
        </trans-unit>
        <trans-unit id="db393fbd5a98ab60023bfd22b5dbbadca9023150" translate="yes" xml:space="preserve">
          <source>For targets that normally need trampolines for nested functions, always generate them instead of using descriptors. Otherwise, for targets that do not need them, like for example HP-PA or IA-64, do nothing.</source>
          <target state="translated">对于那些通常需要使用嵌套函数的目标,总是生成它们而不是使用描述符。否则,对于不需要它们的目标,如HP-PA或IA-64,什么也不做。</target>
        </trans-unit>
        <trans-unit id="3a882a0a0f801f0c1cb983c784834a8c5870b59e" translate="yes" xml:space="preserve">
          <source>For targets, like GNU/Linux, where all user-mode Xtensa code must be position-independent code (PIC), this option disables PIC for compiling kernel code.</source>
          <target state="translated">对于像GNU/Linux这样的目标,所有用户模式的Xtensa代码都必须是独立于位置的代码(PIC),这个选项禁用PIC来编译内核代码。</target>
        </trans-unit>
        <trans-unit id="8b8c7be3bb5a9384ba78f18abd2ee5fc45978a5a" translate="yes" xml:space="preserve">
          <source>For test coverage analysis, use &lt;code&gt;gcov&lt;/code&gt; to produce human readable information from the</source>
          <target state="translated">为了进行测试覆盖率分析，请使用 &lt;code&gt;gcov&lt;/code&gt; 从</target>
        </trans-unit>
        <trans-unit id="cdf3f70fc86ab5862691992f6df51e7ca5f5489e" translate="yes" xml:space="preserve">
          <source>For the NeXT runtime with version 2 of the ABI, check for a nil receiver in method invocations before doing the actual method call. This is the default and can be disabled using</source>
          <target state="translated">对于使用ABI版本2的NeXT运行时,在进行实际的方法调用之前,检查方法调用中的nil接收器。这是默认的,可以使用</target>
        </trans-unit>
        <trans-unit id="96b6c6242e369e6ead381c1d4d982f9072cadf3b" translate="yes" xml:space="preserve">
          <source>For the named functions, the compiler adds code to disable interrupts for the duration of those functions. If any functions so named are not encountered in the source, a warning is emitted that the pragma is not used. Examples:</source>
          <target state="translated">对于被命名的函数,编译器会在这些函数的持续时间内添加代码来禁用中断。如果在源码中没有遇到任何这样命名的函数,则会发出一个警告,说明没有使用这个pragma。例子</target>
        </trans-unit>
        <trans-unit id="b4ae72d8349f09925e7db4912a4034594f70873f" translate="yes" xml:space="preserve">
          <source>For the named functions, the compiler always uses a register-indirect call model when calling the named functions. Examples:</source>
          <target state="translated">对于命名函数,编译器在调用命名函数时,总是采用寄存器直接调用的模式。例如:</target>
        </trans-unit>
        <trans-unit id="b9c34f2bc66483d538061a0df9fde1756b31b97d" translate="yes" xml:space="preserve">
          <source>For the purposes of branch prediction optimizations, the probability that a &lt;code&gt;__builtin_expect&lt;/code&gt; expression is &lt;code&gt;true&lt;/code&gt; is controlled by GCC&amp;rsquo;s &lt;code&gt;builtin-expect-probability&lt;/code&gt; parameter, which defaults to 90%.</source>
          <target state="translated">出于分支预测优化的目的， &lt;code&gt;__builtin_expect&lt;/code&gt; 表达式为 &lt;code&gt;true&lt;/code&gt; 的概率由GCC的 &lt;code&gt;builtin-expect-probability&lt;/code&gt; 参数控制，该参数默认为90％。</target>
        </trans-unit>
        <trans-unit id="0f569d15217aa1a086b40826e8ecc6305b091d9b" translate="yes" xml:space="preserve">
          <source>For the purposes of branch prediction optimizations, the probability that a &lt;code&gt;__builtin_expect&lt;/code&gt; expression is &lt;code&gt;true&lt;/code&gt; is controlled by GCC&amp;rsquo;s &lt;code&gt;builtin-expect-probability&lt;/code&gt; parameter, which defaults to 90%. You can also use &lt;code&gt;__builtin_expect_with_probability&lt;/code&gt; to explicitly assign a probability value to individual expressions.</source>
          <target state="translated">出于分支预测优化的目的， &lt;code&gt;__builtin_expect&lt;/code&gt; 表达式为 &lt;code&gt;true&lt;/code&gt; 的概率由GCC的 &lt;code&gt;builtin-expect-probability&lt;/code&gt; 参数控制，该参数默认为90％。您还可以使用 &lt;code&gt;__builtin_expect_with_probability&lt;/code&gt; 显式地将概率值分配给各个表达式。</target>
        </trans-unit>
        <trans-unit id="bf219c0d4bab1b7372e20c5005cc97b0b9e1bb77" translate="yes" xml:space="preserve">
          <source>For the quote form of the include directive, the directories specified by</source>
          <target state="translated">对于include指令的引用形式,由</target>
        </trans-unit>
        <trans-unit id="754ebda73d52810694ef0086a8c959916039f5fd" translate="yes" xml:space="preserve">
          <source>For the quote form of the include directive, the directory of the current file is searched first.</source>
          <target state="translated">对于引用形式的include指令,会先搜索当前文件的目录。</target>
        </trans-unit>
        <trans-unit id="1d70b004544bcb6341f32cbd058f337db34bac6c" translate="yes" xml:space="preserve">
          <source>For the x86-32 compiler, you must use</source>
          <target state="translated">对于x86-32编译器,你必须使用</target>
        </trans-unit>
        <trans-unit id="9e1a32426c586349d0aa1e4bc4474f828e773b55" translate="yes" xml:space="preserve">
          <source>For those adding visibility support to existing code, you may find &lt;code&gt;#pragma GCC visibility&lt;/code&gt; of use. This works by you enclosing the declarations you wish to set visibility for with (for example) &lt;code&gt;#pragma GCC visibility push(hidden)&lt;/code&gt; and &lt;code&gt;#pragma GCC visibility pop&lt;/code&gt;. Bear in mind that symbol visibility should be viewed &lt;strong&gt;as part of the API interface contract&lt;/strong&gt; and thus all new code should always specify visibility when it is not the default; i.e., declarations only for use within the local DSO should &lt;strong&gt;always&lt;/strong&gt; be marked explicitly as hidden as so to avoid PLT indirection overheads&amp;mdash;making this abundantly clear also aids readability and self-documentation of the code. Note that due to ISO C++ specification requirements, &lt;code&gt;operator new&lt;/code&gt; and &lt;code&gt;operator delete&lt;/code&gt; must always be of default visibility.</source>
          <target state="translated">对于为现有代码添加可见性支持的用户，您可能会发现 &lt;code&gt;#pragma GCC visibility&lt;/code&gt; 使用的可见性。您可以使用 &lt;code&gt;#pragma GCC visibility push(hidden)&lt;/code&gt; 和 &lt;code&gt;#pragma GCC visibility pop&lt;/code&gt; 来封闭希望为其设置可见性的声明。请记住，应将符号可见性视为&lt;strong&gt;API接口协定的一部分，&lt;/strong&gt;因此，所有新代码在不是默认值时都应始终指定可见性；即，仅在本地DSO中使用的声明应&lt;strong&gt;始终&lt;/strong&gt;被显式标记为隐藏，以免发生PLT间接开销-使其充分清楚也有助于代码的可读性和自说明性。请注意，由于ISO C ++规范要求， &lt;code&gt;operator new&lt;/code&gt; &lt;code&gt;operator delete&lt;/code&gt; 符和操作符删除必须始终具有默认可见性。</target>
        </trans-unit>
        <trans-unit id="bb6de8937de1ff830849ca65a0b4291fa1ceadf7" translate="yes" xml:space="preserve">
          <source>Force (do not force) generated code to have a single exit point in each function.</source>
          <target state="translated">强制(不强制)生成的代码在每个函数中只有一个退出点。</target>
        </trans-unit>
        <trans-unit id="acd5ffdf657527d019579abefcb2cc6ad1c27289" translate="yes" xml:space="preserve">
          <source>Force (do not force) the use of &lt;code&gt;memcpy&lt;/code&gt; for non-trivial block moves. The default is</source>
          <target state="translated">对非平凡的块移动强制（不强制）使用 &lt;code&gt;memcpy&lt;/code&gt; 。默认是</target>
        </trans-unit>
        <trans-unit id="f35628fb15f3c423c03af2c93b844cb43e594383" translate="yes" xml:space="preserve">
          <source>Force &lt;code&gt;long&lt;/code&gt; types to be 64 bits wide. See</source>
          <target state="translated">强制将 &lt;code&gt;long&lt;/code&gt; 类型设置为64位宽。看到</target>
        </trans-unit>
        <trans-unit id="df341c9e8e9829ab23b420935fbc32e82bb7a353" translate="yes" xml:space="preserve">
          <source>Force &lt;code&gt;long&lt;/code&gt;, &lt;code&gt;int&lt;/code&gt;, and pointer types to be 32 bits wide.</source>
          <target state="translated">强制 &lt;code&gt;long&lt;/code&gt; ， &lt;code&gt;int&lt;/code&gt; 和指针类型为32位宽。</target>
        </trans-unit>
        <trans-unit id="a65d4b81903833686ba857ca6166053cb9c8d543" translate="yes" xml:space="preserve">
          <source>Force GCC to assign view numbers internally, if</source>
          <target state="translated">强制GCC在内部分配视图编号,如果...。</target>
        </trans-unit>
        <trans-unit id="5c6c2109c0abfbfad2c57ae80b233af1137f54d6" translate="yes" xml:space="preserve">
          <source>Force GCC to generate DWARF2+ line number tables internally, if DWARF2+ line number tables are to be generated.</source>
          <target state="translated">如果要生成DWARF2+行号表,强制GCC在内部生成DWARF2+行号表。</target>
        </trans-unit>
        <trans-unit id="e05ff97a2114aff3fe8702e99f968b0b9b270faf" translate="yes" xml:space="preserve">
          <source>Force all calls to functions to be indirect. This is useful when using Intel Processor Trace where it generates more precise timing information for function calls.</source>
          <target state="translated">强制所有对函数的调用都是间接的。这在使用英特尔处理器跟踪时非常有用,因为它会为函数调用生成更精确的时序信息。</target>
        </trans-unit>
        <trans-unit id="c6aa1876252f253f5c49c98017976af7ef3a9f80" translate="yes" xml:space="preserve">
          <source>Force all functions to be aligned to a 4-byte boundary.</source>
          <target state="translated">强制所有函数对齐到4字节的边界。</target>
        </trans-unit>
        <trans-unit id="5376700e1a5ed02b4facb60bd51b070a514bbd9d" translate="yes" xml:space="preserve">
          <source>Force all load and store instructions to always bypass cache by using I/O variants of the instructions. The default is not to bypass the cache.</source>
          <target state="translated">通过使用指令的I/O变体,强制所有加载和存储指令始终绕过缓存。默认情况是不绕过缓存。</target>
        </trans-unit>
        <trans-unit id="6ba14189273ea29b59425c68e227901a2b9a86ef" translate="yes" xml:space="preserve">
          <source>Force assembly output to always use hex constants. Normally such constants are signed decimals, but this option is available for testsuite and/or aesthetic purposes.</source>
          <target state="translated">强制装配体输出始终使用十六进制常量。通常这种常数是有符号的小数,但这个选项可以用于testuite和/或美学目的。</target>
        </trans-unit>
        <trans-unit id="a09ed1d5a3164af1580e37f843c9d03a7f3d9584" translate="yes" xml:space="preserve">
          <source>Force code generation in the ARM (A32) ISA.</source>
          <target state="translated">在ARM (A32)ISA中强制生成代码。</target>
        </trans-unit>
        <trans-unit id="8cf31b1c6efcebcf276d6ea54117f6f86a1ab3b3" translate="yes" xml:space="preserve">
          <source>Force code generation in the Thumb (T16/T32) ISA, depending on the architecture level.</source>
          <target state="translated">在拇指(T16/T32)ISA中强制生成代码,取决于架构级别。</target>
        </trans-unit>
        <trans-unit id="57fc3d2f95e9a264681cfb6c086d3f11381e6d22" translate="yes" xml:space="preserve">
          <source>Force indirect call and jump via register.</source>
          <target state="translated">通过寄存器强制间接调用和跳转。</target>
        </trans-unit>
        <trans-unit id="c2234a2c2c6fa572bb9aaff40c528a12cc4c9fff" translate="yes" xml:space="preserve">
          <source>Force the usage of delay slots for conditional branches, which stuffs the delay slot with a &lt;code&gt;nop&lt;/code&gt; if a suitable instruction cannot be found. By default this option is disabled. It can be enabled to work around hardware bugs as found in the original SH7055.</source>
          <target state="translated">强制使用条件分支的延迟槽，如果找不到合适的指令，则将延迟槽塞入 &lt;code&gt;nop&lt;/code&gt; 。默认情况下，此选项是禁用的。可以启用它来解决原始SH7055中发现的硬件错误。</target>
        </trans-unit>
        <trans-unit id="accd79a6ab2ab26b14a5acf0e4624a9287eb4f98" translate="yes" xml:space="preserve">
          <source>Force to call a function using jli_s instruction. This option is valid only for ARCv2 architecture.</source>
          <target state="translated">强制使用jli_s指令调用函数。这个选项只对ARCv2架构有效。</target>
        </trans-unit>
        <trans-unit id="bda8d8b269a45b97f862176d65bac6c1e4f4afe4" translate="yes" xml:space="preserve">
          <source>Forces a particular function to be called using &lt;code&gt;jli&lt;/code&gt; instruction. The &lt;code&gt;jli&lt;/code&gt; instruction makes use of a table stored into &lt;code&gt;.jlitab&lt;/code&gt; section, which holds the location of the functions which are addressed using this instruction.</source>
          <target state="translated">强制使用 &lt;code&gt;jli&lt;/code&gt; 指令调用特定功能。所述 &lt;code&gt;jli&lt;/code&gt; 指令利用存储到一个表中的 &lt;code&gt;.jlitab&lt;/code&gt; 部，其保持的哪个正在使用该指令处理的功能的位置。</target>
        </trans-unit>
        <trans-unit id="2f084ee73c513d8f966bbd0c40980e7ab5210b2e" translate="yes" xml:space="preserve">
          <source>Formal syntax for attributes.</source>
          <target state="translated">属性的正式语法。</target>
        </trans-unit>
        <trans-unit id="6e97cc41857aff390c1d1352f1580ff15ac71869" translate="yes" xml:space="preserve">
          <source>Format checks specific to particular targets.</source>
          <target state="translated">特定目标的格式检查。</target>
        </trans-unit>
        <trans-unit id="c4653752f8662d9cf50820b53f4f92b88244d0b2" translate="yes" xml:space="preserve">
          <source>Formerly the &lt;code&gt;hi&lt;/code&gt; register. This constraint is no longer supported.</source>
          <target state="translated">以前是 &lt;code&gt;hi&lt;/code&gt; 寄存器。不再支持此约束。</target>
        </trans-unit>
        <trans-unit id="fb001b2c292ad2f619c8caf6e0ac8afd191aaa76" translate="yes" xml:space="preserve">
          <source>Framework</source>
          <target state="translated">Framework</target>
        </trans-unit>
        <trans-unit id="af39dd055c3ef8226fbe929d048cafb094dc8a51" translate="yes" xml:space="preserve">
          <source>Frameworks</source>
          <target state="translated">Frameworks</target>
        </trans-unit>
        <trans-unit id="a4a10834211c2c0fbcb7eeb4d7d706ce399ad1a9" translate="yes" xml:space="preserve">
          <source>Free form Fortran source code that must be preprocessed (with the traditional preprocessor).</source>
          <target state="translated">自由形式的Fortran源代码,必须进行预处理(用传统的预处理器)。</target>
        </trans-unit>
        <trans-unit id="ab1de10d533c059aa65605ce6bb4a93b10329a51" translate="yes" xml:space="preserve">
          <source>Free form Fortran source code that should not be preprocessed.</source>
          <target state="translated">自由形式的Fortran源代码,不应进行预处理。</target>
        </trans-unit>
        <trans-unit id="79c3d4c459214fa53411ede2a681be19e9178e25" translate="yes" xml:space="preserve">
          <source>Fully split wide types early, instead of very late. This option has no effect unless</source>
          <target state="translated">早期完全分割宽类型,而不是很晚。这个选项没有效果,除非</target>
        </trans-unit>
        <trans-unit id="4b3ade0ff4647a9f20d6dba70ea3a9f2cb1aec15" translate="yes" xml:space="preserve">
          <source>Function Pointer Size</source>
          <target state="translated">函数指针大小</target>
        </trans-unit>
        <trans-unit id="5888490bf4ce1fb3617e200efdb6835e0c4faa44" translate="yes" xml:space="preserve">
          <source>Function attributes are introduced by the &lt;code&gt;__attribute__&lt;/code&gt; keyword in the declaration of a function, followed by an attribute specification enclosed in double parentheses. You can specify multiple attributes in a declaration by separating them by commas within the double parentheses or by immediately following one attribute specification with another. See &lt;a href=&quot;attribute-syntax#Attribute-Syntax&quot;&gt;Attribute Syntax&lt;/a&gt;, for the exact rules on attribute syntax and placement. Compatible attribute specifications on distinct declarations of the same function are merged. An attribute specification that is not compatible with attributes already applied to a declaration of the same function is ignored with a warning.</source>
          <target state="translated">函数属性由函数声明中的 &lt;code&gt;__attribute__&lt;/code&gt; 关键字引入，后跟用双括号括起来的属性规范。您可以在声明中指定多个属性，方法是在双括号内用逗号将它们隔开，或者紧跟在一个属性说明之后。有关&lt;a href=&quot;attribute-syntax#Attribute-Syntax&quot;&gt;属性&lt;/a&gt;语法和放置的确切规则，请参见属性语法。合并了同一功能的不同声明上的兼容属性规范。与警告不兼容的属性规范与已经应用于同一函数的声明的属性不兼容。</target>
        </trans-unit>
        <trans-unit id="f93ed46e6d86f7b87373026d5e663168479db390" translate="yes" xml:space="preserve">
          <source>Function precision. The trap handler can determine the function that caused a floating-point exception.</source>
          <target state="translated">函数精度。陷阱处理程序可以确定引起浮点异常的函数。</target>
        </trans-unit>
        <trans-unit id="d3d655b1f77fc46f162e436abc252a9dc6d8148d" translate="yes" xml:space="preserve">
          <source>Function prototype</source>
          <target state="translated">函数原型</target>
        </trans-unit>
        <trans-unit id="9e039f9c7013d88c23a38a281ed14037c4166f2d" translate="yes" xml:space="preserve">
          <source>Function reordering based on profile instrumentation collects first time of execution of a function and orders these functions in ascending order.</source>
          <target state="translated">基于剖面仪的函数重排序收集函数的首次执行时间,并按升序排列这些函数。</target>
        </trans-unit>
        <trans-unit id="84a74152b608e42b8dbf493e4c08ff7789383e02" translate="yes" xml:space="preserve">
          <source>Function return values larger than 64 bits are passed by using a hidden pointer as the first argument of the function. TI ABI, though, mandates that the pointer can be NULL in case the caller is not using the returned value. GNU always passes and expects a valid return value pointer.</source>
          <target state="translated">大于64位的函数返回值通过使用隐藏指针作为函数的第一个参数来传递。不过TI ABI规定,在调用者不使用返回值的情况下,指针可以是NULL。GNU总是传递并期待一个有效的返回值指针。</target>
        </trans-unit>
        <trans-unit id="d33f90e4120ff23ca44b34b56f5771105ef3b24d" translate="yes" xml:space="preserve">
          <source>Functions are aligned to 16-bit boundaries.</source>
          <target state="translated">函数对准16位边界。</target>
        </trans-unit>
        <trans-unit id="34be57d225a7e4b91308288bf7b00a21a76d0703" translate="yes" xml:space="preserve">
          <source>Functions are aligned to 32-bit boundaries, unless optimizing for size.</source>
          <target state="translated">除非对大小进行优化,否则函数会按照32位边界进行对齐。</target>
        </trans-unit>
        <trans-unit id="5a29ddf72dc39612a3206ea0dfa0993bffe35aee" translate="yes" xml:space="preserve">
          <source>Functions declared with the &lt;code&gt;naked&lt;/code&gt; attribute also require basic &lt;code&gt;asm&lt;/code&gt; (see &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;Function Attributes&lt;/a&gt;).</source>
          <target state="translated">用 &lt;code&gt;naked&lt;/code&gt; 属性声明的函数也需要基本的 &lt;code&gt;asm&lt;/code&gt; （请参见&lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;函数属性&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="b405d9a1c02455968daea5fb86ad7161a05b238c" translate="yes" xml:space="preserve">
          <source>Functions from different modes can be inlined in the caller&amp;rsquo;s mode.</source>
          <target state="translated">可以在调用者的模式中内联来自不同模式的功能。</target>
        </trans-unit>
        <trans-unit id="a51173ce4592b6408dafbf5dcd763cb00409451e" translate="yes" xml:space="preserve">
          <source>Functions prologues/epilogues are expanded as calls to appropriate subroutines. Code size is smaller.</source>
          <target state="translated">函数序言/序幕被扩展为对适当子程序的调用。代码尺寸更小。</target>
        </trans-unit>
        <trans-unit id="958942a81a4fb21510019af4adcbaec4037ab18c" translate="yes" xml:space="preserve">
          <source>Functions that are normally built in but do not have semantics defined by ISO C (such as &lt;code&gt;alloca&lt;/code&gt; and &lt;code&gt;ffs&lt;/code&gt;) are not built-in functions when</source>
          <target state="translated">通常内置的但不具有ISO C定义的语义的函数（例如 &lt;code&gt;alloca&lt;/code&gt; 和 &lt;code&gt;ffs&lt;/code&gt; ）在以下情况下不是内置函数</target>
        </trans-unit>
        <trans-unit id="a77748cc250a919f08dac1cbb97eb54cbd2d36e9" translate="yes" xml:space="preserve">
          <source>Funding Free Software</source>
          <target state="translated">资助自由软件</target>
        </trans-unit>
        <trans-unit id="ad51c11605482040955d96c2db6f7d9f4eca570e" translate="yes" xml:space="preserve">
          <source>Furthermore, if the &lt;em&gt;earlyclobber&lt;/em&gt; operand is also a read/write operand, then that operand is written only after it&amp;rsquo;s used.</source>
          <target state="translated">此外，如果&lt;em&gt;earlyclobber&lt;/em&gt;操作数也是读/写操作数，则仅在使用该操作数后才写入该操作数。</target>
        </trans-unit>
        <trans-unit id="8c1a9865dc580dc97d71f0ac34525d7ff40826cf" translate="yes" xml:space="preserve">
          <source>Future versions of GCC may zero-extend, or use a target-defined &lt;code&gt;ptr_extend&lt;/code&gt; pattern. Do not rely on sign extension.</source>
          <target state="translated">GCC的未来版本可能会零扩展，或使用目标定义的 &lt;code&gt;ptr_extend&lt;/code&gt; 模式。不要依靠符号扩展。</target>
        </trans-unit>
        <trans-unit id="a36a6718f54524d846894fb04b5b885b4e43e63b" translate="yes" xml:space="preserve">
          <source>G</source>
          <target state="translated">G</target>
        </trans-unit>
        <trans-unit id="6ed55690929b9e60aff3a9282723cba6d9ce77ea" translate="yes" xml:space="preserve">
          <source>G++ allows a virtual function returning &amp;lsquo;</source>
          <target state="translated">G ++允许虚拟函数返回'</target>
        </trans-unit>
        <trans-unit id="5114ba459fc06431a44841ea4654eb2a26a6c91e" translate="yes" xml:space="preserve">
          <source>G++ allows anonymous structs and unions to have members that are not public non-static data members (i.e. fields). These extensions are deprecated.</source>
          <target state="translated">G++允许匿名结构和联合体拥有非公共非静态数据成员(即字段)。这些扩展已被废弃。</target>
        </trans-unit>
        <trans-unit id="de3e575c048ce4bfb45f20c4e2302053983a6e85" translate="yes" xml:space="preserve">
          <source>G++ allows attributes to follow a parenthesized direct initializer, e.g. &amp;lsquo;</source>
          <target state="translated">G ++允许属性遵循带括号的直接初始化程序，例如'</target>
        </trans-unit>
        <trans-unit id="4279ad338a301cce60cdfae7e5135ebd09b1878c" translate="yes" xml:space="preserve">
          <source>G++ allows floating-point literals to appear in integral constant expressions, e.g. &amp;lsquo;</source>
          <target state="translated">G ++允许浮点文字出现在整数常量表达式中，例如'</target>
        </trans-unit>
        <trans-unit id="c5b988dd39fdeb99ab7e438425f37e6884df0f08" translate="yes" xml:space="preserve">
          <source>G++ allows static data members of const floating-point type to be declared with an initializer in a class definition. The standard only allows initializers for static members of const integral types and const enumeration types so this extension has been deprecated and will be removed from a future version.</source>
          <target state="translated">G++允许在类定义中用初始化器声明const浮点类型的静态数据成员。标准只允许为const integral类型和const enumeration类型的静态成员提供初始化器,所以这个扩展已经被废弃,并将在未来的版本中删除。</target>
        </trans-unit>
        <trans-unit id="63f7f4841ad757c79aac590be15aedf6621086d6" translate="yes" xml:space="preserve">
          <source>G++ implements the &amp;ldquo;intuitive&amp;rdquo; algorithm for copy-assignment: assign all direct bases, then assign all members. In that algorithm, the virtual base subobject can be encountered more than once. In the example, copying proceeds in the following order: &amp;lsquo;</source>
          <target state="translated">G ++为复制分配实现了&amp;ldquo;直观&amp;rdquo;算法：分配所有直接碱基，然后分配所有成员。在该算法中，可以多次遇到虚拟基础子对象。在该示例中，复制按以下顺序进行：</target>
        </trans-unit>
        <trans-unit id="67e3c9106f6559177c33511b2d979e92d246d3b0" translate="yes" xml:space="preserve">
          <source>G++ implements the Borland model on targets where the linker supports it, including ELF targets (such as GNU/Linux), Mac OS X and Microsoft Windows. Otherwise G++ implements neither automatic model.</source>
          <target state="translated">G++在链接器支持的目标上实现了Borland模型,包括ELF目标(如GNU/Linux)、Mac OS X和Microsoft Windows。否则,G++既不实现自动模型。</target>
        </trans-unit>
        <trans-unit id="31ff568d5d2e9d2f6743afcdc5f3a983bc913e2f" translate="yes" xml:space="preserve">
          <source>G++ implements the same behavior as GCC does when assigning to a volatile object&amp;mdash;there is no reread of the assigned-to object, the assigned rvalue is reused. Note that in C++ assignment expressions are lvalues, and if used as an lvalue, the volatile object is referred to. For instance, &lt;var&gt;vref&lt;/var&gt; refers to &lt;var&gt;vobj&lt;/var&gt;, as expected, in the following example:</source>
          <target state="translated">当分配给易失对象时，G ++实现与GCC相同的行为-没有重新读取分配给的对象，分配的右值被重用。请注意，在C ++赋值表达式中是左值，如果用作左值，则引用volatile对象。例如，在以下示例中， &lt;var&gt;vref&lt;/var&gt; 如所期望地引用了 &lt;var&gt;vobj&lt;/var&gt; ：</target>
        </trans-unit>
        <trans-unit id="a1650ba68fd434ff4571a3ae6e0e946daaa36507" translate="yes" xml:space="preserve">
          <source>G3</source>
          <target state="translated">G3</target>
        </trans-unit>
        <trans-unit id="57c24c56c83113e722078337cfe2d513db43c570" translate="yes" xml:space="preserve">
          <source>G4</source>
          <target state="translated">G4</target>
        </trans-unit>
        <trans-unit id="75cc572d557c39d31a9a311423998e30b6913f73" translate="yes" xml:space="preserve">
          <source>G5</source>
          <target state="translated">G5</target>
        </trans-unit>
        <trans-unit id="47bc5f06e2bc84be8cac3eeae94be31fd0bb67f8" translate="yes" xml:space="preserve">
          <source>GBR</source>
          <target state="translated">GBR</target>
        </trans-unit>
        <trans-unit id="8577b47d2b705ad56be34a1a6a9f6472d1ac1001" translate="yes" xml:space="preserve">
          <source>GCC</source>
          <target state="translated">GCC</target>
        </trans-unit>
        <trans-unit id="2128b3c47a543c2fd225378159dcf1cee572dc1a" translate="yes" xml:space="preserve">
          <source>GCC aims towards being usable as a conforming freestanding implementation, or as the compiler for a conforming hosted implementation. By default, it acts as the compiler for a hosted implementation, defining &lt;code&gt;__STDC_HOSTED__&lt;/code&gt; as &lt;code&gt;1&lt;/code&gt; and presuming that when the names of ISO C functions are used, they have the semantics defined in the standard. To make it act as a conforming freestanding implementation for a freestanding environment, use the option</source>
          <target state="translated">GCC的目标是可用作兼容的独立实现，或用作兼容的托管实现的编译器。默认情况下，它充当托管实现的编译器，将 &lt;code&gt;__STDC_HOSTED__&lt;/code&gt; 定义为 &lt;code&gt;1&lt;/code&gt; ,并假定使用ISO C函数的名称时，它们具有标准中定义的语义。要使其成为独立环境的一致独立实施，请使用选项</target>
        </trans-unit>
        <trans-unit id="a09efcf4281abbe557aa1d8c0037c8b8db485c71" translate="yes" xml:space="preserve">
          <source>GCC allows attributes to be set on C labels. See &lt;a href=&quot;attribute-syntax#Attribute-Syntax&quot;&gt;Attribute Syntax&lt;/a&gt;, for details of the exact syntax for using attributes. Other attributes are available for functions (see &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;Function Attributes&lt;/a&gt;), variables (see &lt;a href=&quot;variable-attributes#Variable-Attributes&quot;&gt;Variable Attributes&lt;/a&gt;), enumerators (see &lt;a href=&quot;enumerator-attributes#Enumerator-Attributes&quot;&gt;Enumerator Attributes&lt;/a&gt;), statements (see &lt;a href=&quot;statement-attributes#Statement-Attributes&quot;&gt;Statement Attributes&lt;/a&gt;), and for types (see &lt;a href=&quot;type-attributes#Type-Attributes&quot;&gt;Type Attributes&lt;/a&gt;).</source>
          <target state="translated">GCC允许在C标签上设置属性。有关使用属性的确切语法的详细信息，请参见&amp;ldquo; &lt;a href=&quot;attribute-syntax#Attribute-Syntax&quot;&gt;属性语法&amp;rdquo;&lt;/a&gt;。其他属性可用于函数（请参见&lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;Function Attributes&lt;/a&gt;），变量（请参见&lt;a href=&quot;variable-attributes#Variable-Attributes&quot;&gt;Variable Attributes&lt;/a&gt;），枚举器（请参见&lt;a href=&quot;enumerator-attributes#Enumerator-Attributes&quot;&gt;Enumerator Attributes&lt;/a&gt;），语句（请参见&lt;a href=&quot;statement-attributes#Statement-Attributes&quot;&gt;Statement Attributes&lt;/a&gt;）和类型（请参见&lt;a href=&quot;type-attributes#Type-Attributes&quot;&gt;Type Attributes&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="188d2c46ce847222650ff9a197ae21b6d36834fd" translate="yes" xml:space="preserve">
          <source>GCC allows attributes to be set on enumerators. See &lt;a href=&quot;attribute-syntax#Attribute-Syntax&quot;&gt;Attribute Syntax&lt;/a&gt;, for details of the exact syntax for using attributes. Other attributes are available for functions (see &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;Function Attributes&lt;/a&gt;), variables (see &lt;a href=&quot;variable-attributes#Variable-Attributes&quot;&gt;Variable Attributes&lt;/a&gt;), labels (see &lt;a href=&quot;label-attributes#Label-Attributes&quot;&gt;Label Attributes&lt;/a&gt;), statements (see &lt;a href=&quot;statement-attributes#Statement-Attributes&quot;&gt;Statement Attributes&lt;/a&gt;), and for types (see &lt;a href=&quot;type-attributes#Type-Attributes&quot;&gt;Type Attributes&lt;/a&gt;).</source>
          <target state="translated">GCC允许在枚举数上设置属性。有关使用属性的确切语法的详细信息，请参见&amp;ldquo; &lt;a href=&quot;attribute-syntax#Attribute-Syntax&quot;&gt;属性语法&amp;rdquo;&lt;/a&gt;。其他属性可用于函数（请参阅&lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;函数属性&lt;/a&gt;），变量（请参见&lt;a href=&quot;variable-attributes#Variable-Attributes&quot;&gt;变量属性&lt;/a&gt;），标签（请参见&lt;a href=&quot;label-attributes#Label-Attributes&quot;&gt;Label Attributes&lt;/a&gt;），语句（请参见&lt;a href=&quot;statement-attributes#Statement-Attributes&quot;&gt;Statement Attributes&lt;/a&gt;）和类型（请参见&lt;a href=&quot;type-attributes#Type-Attributes&quot;&gt;Type Attributes&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="1318f5f0c876968e4d22801744660b2a68a5dbc1" translate="yes" xml:space="preserve">
          <source>GCC allows attributes to be set on null statements. See &lt;a href=&quot;attribute-syntax#Attribute-Syntax&quot;&gt;Attribute Syntax&lt;/a&gt;, for details of the exact syntax for using attributes. Other attributes are available for functions (see &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;Function Attributes&lt;/a&gt;), variables (see &lt;a href=&quot;variable-attributes#Variable-Attributes&quot;&gt;Variable Attributes&lt;/a&gt;), labels (see &lt;a href=&quot;label-attributes#Label-Attributes&quot;&gt;Label Attributes&lt;/a&gt;), enumerators (see &lt;a href=&quot;enumerator-attributes#Enumerator-Attributes&quot;&gt;Enumerator Attributes&lt;/a&gt;), and for types (see &lt;a href=&quot;type-attributes#Type-Attributes&quot;&gt;Type Attributes&lt;/a&gt;).</source>
          <target state="translated">GCC允许在null语句上设置属性。有关使用属性的确切语法的详细信息，请参见&amp;ldquo; &lt;a href=&quot;attribute-syntax#Attribute-Syntax&quot;&gt;属性语法&amp;rdquo;&lt;/a&gt;。其他属性可用于函数（请参见&lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;函数属性&lt;/a&gt;），变量（请参见&lt;a href=&quot;variable-attributes#Variable-Attributes&quot;&gt;变量属性&lt;/a&gt;），标签（请参见&lt;a href=&quot;label-attributes#Label-Attributes&quot;&gt;Label Attributes&lt;/a&gt;），枚举器（请参见&lt;a href=&quot;enumerator-attributes#Enumerator-Attributes&quot;&gt;Enumerator Attributes&lt;/a&gt;）和类型（请参见&lt;a href=&quot;type-attributes#Type-Attributes&quot;&gt;Type Attributes&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="8f7518a10a612c3aa4683ccb174e0aca674b8c50" translate="yes" xml:space="preserve">
          <source>GCC allows static initialization of flexible array members. This is equivalent to defining a new structure containing the original structure followed by an array of sufficient size to contain the data. E.g. in the following, &lt;code&gt;f1&lt;/code&gt; is constructed as if it were declared like &lt;code&gt;f2&lt;/code&gt;.</source>
          <target state="translated">GCC允许对灵活数组成员进行静态初始化。这等效于定义一个包含原始结构的新结构，后跟一个足够大的数组来容纳数据。例如，在下面的示例中， &lt;code&gt;f1&lt;/code&gt; 的构造就像 &lt;code&gt;f2&lt;/code&gt; 一样。</target>
        </trans-unit>
        <trans-unit id="2f25be809d122cad042e0db0bcc9a75b7e95df2b" translate="yes" xml:space="preserve">
          <source>GCC allows the user to selectively enable or disable certain types of diagnostics, and change the kind of the diagnostic. For example, a project&amp;rsquo;s policy might require that all sources compile with</source>
          <target state="translated">GCC允许用户有选择地启用或禁用某些类型的诊断，并更改诊断的类型。例如，项目的政策可能要求所有来源</target>
        </trans-unit>
        <trans-unit id="095246dfc125cf940fca19907500328219191dc3" translate="yes" xml:space="preserve">
          <source>GCC allows using a &lt;code&gt;typedef&lt;/code&gt; name as the type specifier for a vector type, but only under the following circumstances:</source>
          <target state="translated">GCC允许将 &lt;code&gt;typedef&lt;/code&gt; 名称用作向量类型的类型说明符，但仅在以下情况下：</target>
        </trans-unit>
        <trans-unit id="118ab2384628648bceb8c24d3c1faa22f9cfc67a" translate="yes" xml:space="preserve">
          <source>GCC allows using a &lt;code&gt;typedef&lt;/code&gt; name as the type specifier for a vector type.</source>
          <target state="translated">GCC允许将 &lt;code&gt;typedef&lt;/code&gt; 名称用作向量类型的类型说明符。</target>
        </trans-unit>
        <trans-unit id="4dbc0782ac4d82d0f286d4feca2e87d560c81769" translate="yes" xml:space="preserve">
          <source>GCC allows you to declare &lt;em&gt;local labels&lt;/em&gt; in any nested block scope. A local label is just like an ordinary label, but you can only reference it (with a &lt;code&gt;goto&lt;/code&gt; statement, or by taking its address) within the block in which it is declared.</source>
          <target state="translated">GCC允许您在任何嵌套块范围内声明&lt;em&gt;局部标签&lt;/em&gt;。本地标签就像普通标签一样，但是您只能在声明它的块内引用它（使用 &lt;code&gt;goto&lt;/code&gt; 语句，或通过获取其地址）。</target>
        </trans-unit>
        <trans-unit id="11edda20db587e9081a40a5791b651f14e5edef4" translate="yes" xml:space="preserve">
          <source>GCC allows you to use</source>
          <target state="translated">GCC允许您使用</target>
        </trans-unit>
        <trans-unit id="cb8172c4270b6a56a430a2344a1d357df8a89c7e" translate="yes" xml:space="preserve">
          <source>GCC already has an extensive list of suffixes built into it. This directive adds an entry to the end of the list of suffixes, but since the list is searched from the end backwards, it is effectively possible to override earlier entries using this technique.</source>
          <target state="translated">GCC已经有一个广泛的后缀列表。这条指令在后缀列表的末尾添加了一个条目,但由于列表是从末尾开始向后搜索的,所以使用这种技术可以有效地覆盖早期条目。</target>
        </trans-unit>
        <trans-unit id="4946c9e7401c541aac6237c0b11a4f8762636048" translate="yes" xml:space="preserve">
          <source>GCC also defines the macro &lt;code&gt;__m&lt;var&gt;uarch&lt;/var&gt;__&lt;/code&gt; when tuning for ColdFire microarchitecture &lt;var&gt;uarch&lt;/var&gt;, where &lt;var&gt;uarch&lt;/var&gt; is one of the arguments given above.</source>
          <target state="translated">在调整ColdFire微体系结构 &lt;var&gt;uarch&lt;/var&gt; 时，GCC还定义了宏 &lt;code&gt;__m&lt;var&gt;uarch&lt;/var&gt;__&lt;/code&gt; ，其中 &lt;var&gt;uarch&lt;/var&gt; 是上面给出的参数之一。</target>
        </trans-unit>
        <trans-unit id="bd57161c41c158f961b92f3f1147120413b6477d" translate="yes" xml:space="preserve">
          <source>GCC also knows implicitly that arguments starting in</source>
          <target state="translated">GCC也隐含地知道,以</target>
        </trans-unit>
        <trans-unit id="5590aa7708108855eef5df246b0491a821f68f35" translate="yes" xml:space="preserve">
          <source>GCC also offers a simple mechanism for printing messages during compilation.</source>
          <target state="translated">GCC还提供了一个简单的机制来打印编译过程中的信息。</target>
        </trans-unit>
        <trans-unit id="ff5eb1c7d3d1103b9c01d9df5e0e050903b1adc0" translate="yes" xml:space="preserve">
          <source>GCC also provides a target specific macro &lt;code&gt;__BIGGEST_ALIGNMENT__&lt;/code&gt;, which is the largest alignment ever used for any data type on the target machine you are compiling for. For example, you could write:</source>
          <target state="translated">GCC还提供了特定于目标的宏 &lt;code&gt;__BIGGEST_ALIGNMENT__&lt;/code&gt; ，这是有史以来针对要编译的目标计算机上的任何数据类型使用的最大对齐方式。例如，您可以编写：</target>
        </trans-unit>
        <trans-unit id="1ce6a581ce58e7b0e52deb0ba48b6684312e9d7c" translate="yes" xml:space="preserve">
          <source>GCC also provides intrinsics to directly access the network registers. The intrinsics are:</source>
          <target state="translated">GCC还提供了直接访问网络寄存器的固有功能。这些内在因素是:</target>
        </trans-unit>
        <trans-unit id="028d66aa5e30f9984efa701c3d35086edefd3f65" translate="yes" xml:space="preserve">
          <source>GCC also supports attributes on variable declarations (see &lt;a href=&quot;variable-attributes#Variable-Attributes&quot;&gt;Variable Attributes&lt;/a&gt;), labels (see &lt;a href=&quot;label-attributes#Label-Attributes&quot;&gt;Label Attributes&lt;/a&gt;), enumerators (see &lt;a href=&quot;enumerator-attributes#Enumerator-Attributes&quot;&gt;Enumerator Attributes&lt;/a&gt;), statements (see &lt;a href=&quot;statement-attributes#Statement-Attributes&quot;&gt;Statement Attributes&lt;/a&gt;), and types (see &lt;a href=&quot;type-attributes#Type-Attributes&quot;&gt;Type Attributes&lt;/a&gt;).</source>
          <target state="translated">GCC还支持变量声明（请参见&lt;a href=&quot;variable-attributes#Variable-Attributes&quot;&gt;变量属性&lt;/a&gt;），标签（请参见&lt;a href=&quot;label-attributes#Label-Attributes&quot;&gt;Label Attributes&lt;/a&gt;），枚举器（请参见&lt;a href=&quot;enumerator-attributes#Enumerator-Attributes&quot;&gt;Enumerator Attributes&lt;/a&gt;），语句（请参见&lt;a href=&quot;statement-attributes#Statement-Attributes&quot;&gt;Statement Attributes&lt;/a&gt;）和类型（请参见&lt;a href=&quot;type-attributes#Type-Attributes&quot;&gt;Type Attributes&lt;/a&gt;）的属性。</target>
        </trans-unit>
        <trans-unit id="51353b73f0da65e20b68eea37e8d612e8b885954" translate="yes" xml:space="preserve">
          <source>GCC also warns about function definitions that might be candidates for &lt;code&gt;format&lt;/code&gt; attributes. Again, these are only possible candidates. GCC guesses that &lt;code&gt;format&lt;/code&gt; attributes might be appropriate for any function that calls a function like &lt;code&gt;vprintf&lt;/code&gt; or &lt;code&gt;vscanf&lt;/code&gt;, but this might not always be the case, and some functions for which &lt;code&gt;format&lt;/code&gt; attributes are appropriate may not be detected.</source>
          <target state="translated">GCC还警告可能是 &lt;code&gt;format&lt;/code&gt; 属性候选的函数定义。同样，这些只是可能的候选者。 GCC猜测 &lt;code&gt;format&lt;/code&gt; 属性可能适用于任何调用 &lt;code&gt;vprintf&lt;/code&gt; 或 &lt;code&gt;vscanf&lt;/code&gt; 之类的函数的函数，但这并非总是如此，并且某些 &lt;code&gt;format&lt;/code&gt; 属性适用的函数可能无法检测到。</target>
        </trans-unit>
        <trans-unit id="e6346f95ac263c787786ddc66b5d9c0bcd8bac71" translate="yes" xml:space="preserve">
          <source>GCC always follows the C99 and C11 requirement that the result of division is truncated towards zero.</source>
          <target state="translated">GCC始终遵循C99和C11的要求,将除法的结果截为零。</target>
        </trans-unit>
        <trans-unit id="71e58c529399ec16a2da4be1a53c86f1d271b88e" translate="yes" xml:space="preserve">
          <source>GCC always tries to compile your program if possible; it never gratuitously rejects a program whose meaning is clear merely because (for instance) it fails to conform to a standard. In some cases, however, the C and C++ standards specify that certain extensions are forbidden, and a diagnostic &lt;em&gt;must&lt;/em&gt; be issued by a conforming compiler. The</source>
          <target state="translated">GCC会尽可能尝试编译您的程序；它永远不会无故拒绝仅仅因为（例如）不符合标准而明确含义的程序。但是，在某些情况下，C和C ++标准指定禁止某些扩展，并且&lt;em&gt;必须&lt;/em&gt;由合格的编译器发出诊断信息。的</target>
        </trans-unit>
        <trans-unit id="3d850d85ff9e9c0132b4336d9517c8233fd73c22" translate="yes" xml:space="preserve">
          <source>GCC by default uses the GNU Objective-C runtime library, which is part of GCC and is not the same as the Apple/NeXT Objective-C runtime library used on Apple systems. There are a number of differences documented in this manual. The options</source>
          <target state="translated">GCC默认使用GNU Objective-C运行库,它是GCC的一部分,与苹果系统上使用的Apple/NeXT Objective-C运行库不同。本手册中记载了许多不同之处。选项</target>
        </trans-unit>
        <trans-unit id="1c0b38c968b6ef5ec06e42505963f829a108bef3" translate="yes" xml:space="preserve">
          <source>GCC by itself attempts to be a conforming freestanding implementation. See &lt;a href=&quot;standards#Standards&quot;&gt;Language Standards Supported by GCC&lt;/a&gt;, for details of what this means. Beyond the library facilities required of such an implementation, the rest of the C library is supplied by the vendor of the operating system. If that C library doesn&amp;rsquo;t conform to the C standards, then your programs might get warnings (especially when using</source>
          <target state="translated">GCC本身试图成为一个符合标准的独立实现。有关这意味着什么的详细信息，请参见&lt;a href=&quot;standards#Standards&quot;&gt;GCC支持的语言标准&lt;/a&gt;。除了这种实现所需的库功能之外，其余C库由操作系统的供应商提供。如果该C库不符合C标准，则您的程序可能会收到警告（尤其是在使用</target>
        </trans-unit>
        <trans-unit id="a367622db7093a4cc9943cb9b928ad16a228659d" translate="yes" xml:space="preserve">
          <source>GCC can allocate complex automatic variables in a noncontiguous fashion; it&amp;rsquo;s even possible for the real part to be in a register while the imaginary part is on the stack (or vice versa). Only the DWARF debug info format can represent this, so use of DWARF is recommended. If you are using the stabs debug info format, GCC describes a noncontiguous complex variable as if it were two separate variables of noncomplex type. If the variable&amp;rsquo;s actual name is &lt;code&gt;foo&lt;/code&gt;, the two fictitious variables are named &lt;code&gt;foo$real&lt;/code&gt; and &lt;code&gt;foo$imag&lt;/code&gt;. You can examine and set these two fictitious variables with your debugger.</source>
          <target state="translated">GCC可以非连续方式分配复杂的自动变量；甚至当虚部在堆栈上时，实部也可能位于寄存器中（反之亦然）。仅DWARF调试信息格式可以表示此格式，因此建议使用DWARF。如果使用的是stabs调试信息格式，则GCC会将非连续的复杂变量描述为好像是两个单独的非复杂类型的变量。如果变量的实际名称为 &lt;code&gt;foo&lt;/code&gt; ，则两个虚拟变量分别命名为 &lt;code&gt;foo$real&lt;/code&gt; 和 &lt;code&gt;foo$imag&lt;/code&gt; 。您可以使用调试器检查并设置这两个虚拟变量。</target>
        </trans-unit>
        <trans-unit id="8c74211307275623a7dfd79983ff1fca91bf2ce8" translate="yes" xml:space="preserve">
          <source>GCC can also be configured (via the</source>
          <target state="translated">也可以配置GCC(通过</target>
        </trans-unit>
        <trans-unit id="f1f3d3d856350fe50d86862ccf0921b96281e6bd" translate="yes" xml:space="preserve">
          <source>GCC can compile the binary representation (BRIG) of the HSAIL text format as described in HSA Programmer&amp;rsquo;s Reference Manual version 1.0.1. This capability is typically utilized to implement the HSA runtime API&amp;rsquo;s HSAIL finalization extension for a gcc supported processor. HSA standards are freely available at &lt;a href=&quot;http://www.hsafoundation.com/standards/&quot;&gt;http://www.hsafoundation.com/standards/&lt;/a&gt;.</source>
          <target state="translated">GCC可以按照HSA程序员参考手册1.0.1版中的说明编译HSAIL文本格式的二进制表示（BRIG）。此功能通常用于为gcc支持的处理器实现HSA运行时API的HSAIL终结扩展。HSA标准可从&lt;a href=&quot;http://www.hsafoundation.com/standards/&quot;&gt;http://www.hsafoundation.com/standards/&lt;/a&gt;免费获得。</target>
        </trans-unit>
        <trans-unit id="87356dae6f4ed6235c36eedc0fe148afee6229d9" translate="yes" xml:space="preserve">
          <source>GCC can generate code for both VxWorks kernels and real time processes (RTPs). This option switches from the former to the latter. It also defines the preprocessor macro &lt;code&gt;__RTP__&lt;/code&gt;.</source>
          <target state="translated">GCC可以为VxWorks内核和实时进程（RTP）生成代码。此选项从前者切换到后者。它还定义了预处理程序宏 &lt;code&gt;__RTP__&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fb9f5282eec43cb95e4c422b1995ae6896ab686c" translate="yes" xml:space="preserve">
          <source>GCC can only handle one commutative pair in an asm; if you use more, the compiler may fail. Note that you need not use the modifier if the two alternatives are strictly identical; this would only waste time in the reload pass.</source>
          <target state="translated">GCC只能处理asm中的一个换算对,如果使用更多,编译器可能会失败。请注意,如果两个备选方案完全相同,就不需要使用修饰符;这只会在重载传递中浪费时间。</target>
        </trans-unit>
        <trans-unit id="78d74922e82c5075040c6a08c44444ac34a5ad2a" translate="yes" xml:space="preserve">
          <source>GCC comes with shell scripts to fix certain known problems in system header files. They install corrected copies of various header files in a special directory where only GCC will normally look for them. The scripts adapt to various systems by searching all the system header files for the problem cases that we know about.</source>
          <target state="translated">GCC自带的shell脚本可以修复系统头文件中的某些已知问题。它们将各种头文件的修正副本安装在一个特殊的目录中,通常只有GCC才会在这个目录中查找它们。脚本通过搜索所有系统头文件来适应各种系统,寻找我们所知道的问题情况。</target>
        </trans-unit>
        <trans-unit id="cd976cd951c888839dc15c99651c6a379e4c0cac" translate="yes" xml:space="preserve">
          <source>GCC compiled code sometimes emits warnings from the HP-UX assembler of the form:</source>
          <target state="translated">GCC编译后的代码有时会从HP-UX汇编器中发出形式的警告。</target>
        </trans-unit>
        <trans-unit id="81e4ed9eaf205df3f6c599be30d212f56ac91924" translate="yes" xml:space="preserve">
          <source>GCC complains about program fragments such as &amp;lsquo;</source>
          <target state="translated">GCC抱怨程序片段，例如&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="67982454dd3e3b7d64f34362d5f739d9716bb143" translate="yes" xml:space="preserve">
          <source>GCC complains about unterminated character constants inside of preprocessing conditionals that fail. Some programs have English comments enclosed in conditionals that are guaranteed to fail; if these comments contain apostrophes, GCC will probably report an error. For example, this code would produce an error:</source>
          <target state="translated">GCC会抱怨预处理条件中的未加引号的字符常量失败。有些程序的条件中包含了英文注释,这些注释保证会失败;如果这些注释包含了省略号,GCC可能会报告一个错误。例如,这段代码会产生一个错误。</target>
        </trans-unit>
        <trans-unit id="e4bb7adbf45dc4a3fb687d7313280a86480960d6" translate="yes" xml:space="preserve">
          <source>GCC complies with the OpenPOWER 64-Bit ELF V2 ABI Specification, which may be found at &lt;a href=&quot;http://openpowerfoundation.org/wp-content/uploads/resources/leabi-prd/content/index.html&quot;&gt;http://openpowerfoundation.org/wp-content/uploads/resources/leabi-prd/content/index.html&lt;/a&gt;. Appendix A of this document lists the vector API interfaces that must be provided by compliant compilers. Programmers should preferentially use the interfaces described therein. However, historically GCC has provided additional interfaces for access to vector instructions. These are briefly described below.</source>
          <target state="translated">GCC符合OpenPOWER 64位ELF V2 ABI规范，该规范可在&lt;a href=&quot;http://openpowerfoundation.org/wp-content/uploads/resources/leabi-prd/content/index.html&quot;&gt;http://openpowerfoundation.org/wp-content/uploads/resources/leabi-prd/content/index.html中&lt;/a&gt;找到。本文档的附录A列出了兼容的编译器必须提供的矢量API接口。程序员应优先使用其中描述的接口。但是，从历史上看，GCC提供了用于访问矢量指令的其他接口。这些将在下面简要描述。</target>
        </trans-unit>
        <trans-unit id="c80707819ec65b1cb82541da2d3b9e30cf2076e3" translate="yes" xml:space="preserve">
          <source>GCC complies with the OpenPOWER 64-Bit ELF V2 ABI Specification, which may be found at &lt;a href=&quot;https://openpowerfoundation.org/?resource_lib=64-bit-elf-v2-abi-specification-power-architecture&quot;&gt;https://openpowerfoundation.org/?resource_lib=64-bit-elf-v2-abi-specification-power-architecture&lt;/a&gt;. Appendix A of this document lists the vector API interfaces that must be provided by compliant compilers. Programmers should preferentially use the interfaces described therein. However, historically GCC has provided additional interfaces for access to vector instructions. These are briefly described below.</source>
          <target state="translated">GCC符合OpenPOWER 64位ELF V2 ABI规范，该规范可在&lt;a href=&quot;https://openpowerfoundation.org/?resource_lib=64-bit-elf-v2-abi-specification-power-architecture&quot;&gt;https://openpowerfoundation.org/?resource_lib=64-bit-elf-v2-abi-specification-power-architecture中&lt;/a&gt;找到。本文档的附录A列出了兼容编译器必须提供的矢量API接口。程序员应优先使用其中描述的接口。但是，从历史上看，GCC提供了用于访问矢量指令的其他接口。这些将在下面简要描述。</target>
        </trans-unit>
        <trans-unit id="65f9b929facca207bcc2021009f1c0587b957cbf" translate="yes" xml:space="preserve">
          <source>GCC currently emits calls to &lt;code&gt;vmldExp2&lt;/code&gt;, &lt;code&gt;vmldLn2&lt;/code&gt;, &lt;code&gt;vmldLog102&lt;/code&gt;, &lt;code&gt;vmldPow2&lt;/code&gt;, &lt;code&gt;vmldTanh2&lt;/code&gt;, &lt;code&gt;vmldTan2&lt;/code&gt;, &lt;code&gt;vmldAtan2&lt;/code&gt;, &lt;code&gt;vmldAtanh2&lt;/code&gt;, &lt;code&gt;vmldCbrt2&lt;/code&gt;, &lt;code&gt;vmldSinh2&lt;/code&gt;, &lt;code&gt;vmldSin2&lt;/code&gt;, &lt;code&gt;vmldAsinh2&lt;/code&gt;, &lt;code&gt;vmldAsin2&lt;/code&gt;, &lt;code&gt;vmldCosh2&lt;/code&gt;, &lt;code&gt;vmldCos2&lt;/code&gt;, &lt;code&gt;vmldAcosh2&lt;/code&gt;, &lt;code&gt;vmldAcos2&lt;/code&gt;, &lt;code&gt;vmlsExp4&lt;/code&gt;, &lt;code&gt;vmlsLn4&lt;/code&gt;, &lt;code&gt;vmlsLog104&lt;/code&gt;, &lt;code&gt;vmlsPow4&lt;/code&gt;, &lt;code&gt;vmlsTanh4&lt;/code&gt;, &lt;code&gt;vmlsTan4&lt;/code&gt;, &lt;code&gt;vmlsAtan4&lt;/code&gt;, &lt;code&gt;vmlsAtanh4&lt;/code&gt;, &lt;code&gt;vmlsCbrt4&lt;/code&gt;, &lt;code&gt;vmlsSinh4&lt;/code&gt;, &lt;code&gt;vmlsSin4&lt;/code&gt;, &lt;code&gt;vmlsAsinh4&lt;/code&gt;, &lt;code&gt;vmlsAsin4&lt;/code&gt;, &lt;code&gt;vmlsCosh4&lt;/code&gt;, &lt;code&gt;vmlsCos4&lt;/code&gt;, &lt;code&gt;vmlsAcosh4&lt;/code&gt; and &lt;code&gt;vmlsAcos4&lt;/code&gt; for corresponding function type when</source>
          <target state="translated">GCC目前发出的呼吁 &lt;code&gt;vmldExp2&lt;/code&gt; ， &lt;code&gt;vmldLn2&lt;/code&gt; ， &lt;code&gt;vmldLog102&lt;/code&gt; ， &lt;code&gt;vmldPow2&lt;/code&gt; ， &lt;code&gt;vmldTanh2&lt;/code&gt; ， &lt;code&gt;vmldTan2&lt;/code&gt; ， &lt;code&gt;vmldAtan2&lt;/code&gt; ， &lt;code&gt;vmldAtanh2&lt;/code&gt; ， &lt;code&gt;vmldCbrt2&lt;/code&gt; ， &lt;code&gt;vmldSinh2&lt;/code&gt; ， &lt;code&gt;vmldSin2&lt;/code&gt; ， &lt;code&gt;vmldAsinh2&lt;/code&gt; ， &lt;code&gt;vmldAsin2&lt;/code&gt; ， &lt;code&gt;vmldCosh2&lt;/code&gt; ， &lt;code&gt;vmldCos2&lt;/code&gt; ， &lt;code&gt;vmldAcosh2&lt;/code&gt; ， &lt;code&gt;vmldAcos2&lt;/code&gt; ， &lt;code&gt;vmlsExp4&lt;/code&gt; ， &lt;code&gt;vmlsLn4&lt;/code&gt; ， &lt;code&gt;vmlsLog104&lt;/code&gt; ， &lt;code&gt;vmlsPow4&lt;/code&gt; ， &lt;code&gt;vmlsTanh4&lt;/code&gt; ， &lt;code&gt;vmlsTan4&lt;/code&gt; ， &lt;code&gt;vmlsAtan4&lt;/code&gt; ， &lt;code&gt;vmlsAtanh4&lt;/code&gt; ， &lt;code&gt;vmlsCbrt4&lt;/code&gt; ， &lt;code&gt;vmlsSinh4&lt;/code&gt; ， &lt;code&gt;vmlsSin4&lt;/code&gt; ， &lt;code&gt;vmlsAsinh4&lt;/code&gt; ， &lt;code&gt;vmlsAsin4&lt;/code&gt; ， &lt;code&gt;vmlsCosh4&lt;/code&gt; ， &lt;code&gt;vmlsCos4&lt;/code&gt; ， &lt;code&gt;vmlsAcosh4&lt;/code&gt; 和 &lt;code&gt;vmlsAcos4&lt;/code&gt; 对应函数类型时</target>
        </trans-unit>
        <trans-unit id="16f9d8d14967dad5157f0d4d4177e77917294c63" translate="yes" xml:space="preserve">
          <source>GCC defines a macro &lt;code&gt;__mcf&lt;var&gt;arch&lt;/var&gt;__&lt;/code&gt; whenever it is generating code for a ColdFire target. The &lt;var&gt;arch&lt;/var&gt; in this macro is one of the</source>
          <target state="translated">每当GCC 为ColdFire目标生成代码时，它都会定义一个宏 &lt;code&gt;__mcf&lt;var&gt;arch&lt;/var&gt;__&lt;/code&gt; 。此宏中的 &lt;var&gt;arch&lt;/var&gt; 是</target>
        </trans-unit>
        <trans-unit id="9690667ebb3c4d196426b91a67e183bca646b7c4" translate="yes" xml:space="preserve">
          <source>GCC defines a preprocessor macro for the specified &lt;var&gt;cpu&lt;/var&gt;. For the &amp;lsquo;</source>
          <target state="translated">GCC为指定的 &lt;var&gt;cpu&lt;/var&gt; 定义了一个预处理器宏。为了 '</target>
        </trans-unit>
        <trans-unit id="1ee4979d83e119fc65d0b3ce42180431e0b52daf" translate="yes" xml:space="preserve">
          <source>GCC defines several built-in macros so that the user code can test for the presence or absence of features. Almost any of the following built-in macros are deduced from device capabilities and thus triggered by the</source>
          <target state="translated">GCC定义了几个内置宏,以便用户代码可以测试功能的存在或缺失。以下几乎所有的内置宏都是由设备功能推导出来的,因此由</target>
        </trans-unit>
        <trans-unit id="07c2bb68cb370eca1e6a61c97987834533dcec03" translate="yes" xml:space="preserve">
          <source>GCC defines the macro &lt;code&gt;__mcf_cpu_&lt;var&gt;cpu&lt;/var&gt;&lt;/code&gt; when ColdFire target &lt;var&gt;cpu&lt;/var&gt; is selected. It also defines &lt;code&gt;__mcf_family_&lt;var&gt;family&lt;/var&gt;&lt;/code&gt;, where the value of &lt;var&gt;family&lt;/var&gt; is given by the table above.</source>
          <target state="translated">当选择ColdFire目标 &lt;var&gt;cpu&lt;/var&gt; 时，GCC定义宏 &lt;code&gt;__mcf_cpu_&lt;var&gt;cpu&lt;/var&gt;&lt;/code&gt; 。它还定义 &lt;code&gt;__mcf_family_&lt;var&gt;family&lt;/var&gt;&lt;/code&gt; &lt;var&gt;family&lt;/var&gt; ，其中的值 &lt;var&gt;family&lt;/var&gt; 由上述表中给出。</target>
        </trans-unit>
        <trans-unit id="57340a71d3d941522f73fea99d6d51e3e8ce6ff1" translate="yes" xml:space="preserve">
          <source>GCC defines the macro &lt;code&gt;__mcfhwdiv__&lt;/code&gt; when this option is enabled.</source>
          <target state="translated">启用此选项后，GCC会定义宏 &lt;code&gt;__mcfhwdiv__&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6a9b1f894460a8c96f48083896afccfe85c9be79" translate="yes" xml:space="preserve">
          <source>GCC defines the macros &lt;code&gt;__mc&lt;var&gt;arch&lt;/var&gt;&lt;/code&gt; and &lt;code&gt;__mc&lt;var&gt;arch&lt;/var&gt;__&lt;/code&gt; when tuning for 680x0 architecture &lt;var&gt;arch&lt;/var&gt;. It also defines &lt;code&gt;mc&lt;var&gt;arch&lt;/var&gt;&lt;/code&gt; unless either</source>
          <target state="translated">GCC定义了宏 &lt;code&gt;__mc&lt;var&gt;arch&lt;/var&gt;&lt;/code&gt; 和 &lt;code&gt;__mc&lt;var&gt;arch&lt;/var&gt;__&lt;/code&gt; 当调谐为680X0架构 &lt;var&gt;arch&lt;/var&gt; 。它还定义了 &lt;code&gt;mc&lt;var&gt;arch&lt;/var&gt;&lt;/code&gt; 除非</target>
        </trans-unit>
        <trans-unit id="2885698109b0288d9891eaf5f6f566e33bc93a28" translate="yes" xml:space="preserve">
          <source>GCC defines the preprocessor macro &lt;code&gt;__HAVE_BUILTIN_SPECULATION_SAFE_VALUE&lt;/code&gt; for targets that have been updated to support this builtin.</source>
          <target state="translated">GCC 为已更新为支持此内置目标的目标定义了预处理器宏 &lt;code&gt;__HAVE_BUILTIN_SPECULATION_SAFE_VALUE&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9502202879d2e8497b3ab7402351c2cfb4aba65d" translate="yes" xml:space="preserve">
          <source>GCC defines two macros based on the value of this option. The first is &lt;code&gt;_MIPS_ARCH&lt;/code&gt;, which gives the name of target architecture, as a string. The second has the form &lt;code&gt;_MIPS_ARCH_&lt;var&gt;foo&lt;/var&gt;&lt;/code&gt;, where &lt;var&gt;foo&lt;/var&gt; is the capitalized value of &lt;code&gt;_MIPS_ARCH&lt;/code&gt;. For example,</source>
          <target state="translated">GCC根据此选项的值定义两个宏。第一个是 &lt;code&gt;_MIPS_ARCH&lt;/code&gt; ，它以字符串形式给出目标体系结构的名称。第二个格式为 &lt;code&gt;_MIPS_ARCH_&lt;var&gt;foo&lt;/var&gt;&lt;/code&gt; ，其中 &lt;var&gt;foo&lt;/var&gt; 是 &lt;code&gt;_MIPS_ARCH&lt;/code&gt; 的大写值。例如，</target>
        </trans-unit>
        <trans-unit id="a26b5e085873721291414d2146a69ef3ff2df942" translate="yes" xml:space="preserve">
          <source>GCC depresses SSEx instructions when</source>
          <target state="translated">时,GCC压低SSEx指令。</target>
        </trans-unit>
        <trans-unit id="f00d9db0f7babc17a8b2e93a16eaa154dca9484f" translate="yes" xml:space="preserve">
          <source>GCC does not inline any functions when not optimizing unless you specify the &amp;lsquo;</source>
          <target state="translated">如果未进行优化，则GCC不会内联任何功能，除非您指定&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="d979e47341cf32b9e9788a98df7db938c53659aa" translate="yes" xml:space="preserve">
          <source>GCC does not parse basic &lt;code&gt;asm&lt;/code&gt;&amp;rsquo;s &lt;var&gt;AssemblerInstructions&lt;/var&gt;, which means there is no way to communicate to the compiler what is happening inside them. GCC has no visibility of symbols in the &lt;code&gt;asm&lt;/code&gt; and may discard them as unreferenced. It also does not know about side effects of the assembler code, such as modifications to memory or registers. Unlike some compilers, GCC assumes that no changes to general purpose registers occur. This assumption may change in a future release.</source>
          <target state="translated">GCC不会解析基本的 &lt;code&gt;asm&lt;/code&gt; 的 &lt;var&gt;AssemblerInstructions&lt;/var&gt; ，这意味着无法向编译器传达其中发生的情况。 GCC有没有在符号的可视性 &lt;code&gt;asm&lt;/code&gt; 并可能放弃他们作为未引用。它还不知道汇编代码的副作用，例如对内存或寄存器的修改。与某些编译器不同，GCC假定不会更改通用寄存器。此假设可能会在将来的版本中更改。</target>
        </trans-unit>
        <trans-unit id="cd46297b79a48028b406a3a22f8df3c38f23ed53" translate="yes" xml:space="preserve">
          <source>GCC does not provide the C library functionality associated with</source>
          <target state="translated">GCC并没有提供与</target>
        </trans-unit>
        <trans-unit id="96d71d57d6177ab6f3fc682f6b185f4541d680d8" translate="yes" xml:space="preserve">
          <source>GCC does not provide the library facilities required only of hosted implementations, nor yet all the facilities required by C99 of freestanding implementations on all platforms. To use the facilities of a hosted environment, you need to find them elsewhere (for example, in the GNU C library). See &lt;a href=&quot;standard-libraries#Standard-Libraries&quot;&gt;Standard Libraries&lt;/a&gt;.</source>
          <target state="translated">GCC并未提供仅托管实施所需的库设施，也未提供C99在所有平台上的独立实施所需的所有设施。要使用托管环境的功能，您需要在其他位置（例如，在GNU C库中）找到它们。请参阅&lt;a href=&quot;standard-libraries#Standard-Libraries&quot;&gt;标准库&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="86c923d0a51125464840f7ea1874cf6ab2974fb7" translate="yes" xml:space="preserve">
          <source>GCC does not substitute macro arguments when they appear inside of string constants. For example, the following macro in GCC</source>
          <target state="translated">当宏参数出现在字符串常量中时,GCC不会替换它们。例如,GCC中的以下宏</target>
        </trans-unit>
        <trans-unit id="42a91da8639ee03ec161a4bd756ad60809129b66" translate="yes" xml:space="preserve">
          <source>GCC does not support any extended integer types.</source>
          <target state="translated">GCC不支持任何扩展的整数类型。</target>
        </trans-unit>
        <trans-unit id="3ce5b628a549292da4090df5538cf2cd3541c673" translate="yes" xml:space="preserve">
          <source>GCC does not support using this feature with a non-static local variable since such variables do not have assembler names. If you are trying to put the variable in a particular register, see &lt;a href=&quot;explicit-register-variables#Explicit-Register-Variables&quot;&gt;Explicit Register Variables&lt;/a&gt;.</source>
          <target state="translated">GCC不支持将此功能与非静态局部变量一起使用，因为此类变量没有汇编程序名称。如果您试图将变量放入特定的寄存器中，请参见&lt;a href=&quot;explicit-register-variables#Explicit-Register-Variables&quot;&gt;显式寄存器变量&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="057dd4b479d4087929d93c02eca9edfef895599b" translate="yes" xml:space="preserve">
          <source>GCC does not use such values.</source>
          <target state="translated">GCC不使用这种值。</target>
        </trans-unit>
        <trans-unit id="6b22e4a77b39e5fcd62364faba592ec172555481" translate="yes" xml:space="preserve">
          <source>GCC emits warnings based on this attribute by default; use</source>
          <target state="translated">GCC默认会根据这个属性发出警告;使用</target>
        </trans-unit>
        <trans-unit id="6213b35197bfb3bb104e08212f01a4cf35332f2f" translate="yes" xml:space="preserve">
          <source>GCC enables this option by default. If you want to force the compiler to check if a variable is referenced, regardless of whether or not optimization is turned on, use the</source>
          <target state="translated">GCC默认启用这个选项。如果你想强制编译器检查一个变量是否被引用,不管是否开启了优化,请使用</target>
        </trans-unit>
        <trans-unit id="d7b2a859b296fb3f8914b78d7834ccf3e648a510" translate="yes" xml:space="preserve">
          <source>GCC has currently no support for non-fragile instance variables.</source>
          <target state="translated">GCC目前还不支持非脆弱的实例变量。</target>
        </trans-unit>
        <trans-unit id="9b64961814c7627599dfb66d9541dfbc1c55e8a3" translate="yes" xml:space="preserve">
          <source>GCC has long supported variadic macros, and used a different syntax that allowed you to give a name to the variable arguments just like any other argument. Here is an example:</source>
          <target state="translated">GCC长期以来一直支持变量宏,并且使用了一种不同的语法,允许你像其他参数一样给变量参数命名。下面是一个例子。</target>
        </trans-unit>
        <trans-unit id="e677a4ecf07d49ec983c792d6fd35d17489c7528" translate="yes" xml:space="preserve">
          <source>GCC has the following spec strings built into it. Spec files can override these strings or create their own. Note that individual targets can also add their own spec strings to this list.</source>
          <target state="translated">GCC内置了以下规范字符串。规范文件可以覆盖这些字符串或创建自己的字符串。请注意,各个目标也可以将自己的规范字符串添加到这个列表中。</target>
        </trans-unit>
        <trans-unit id="ed8411601030aef9d10cc9d6209db6260f4d910d" translate="yes" xml:space="preserve">
          <source>GCC implements a limited buffer overflow protection mechanism that can prevent some buffer overflow attacks by determining the sizes of objects into which data is about to be written and preventing the writes when the size isn&amp;rsquo;t sufficient. The built-in functions described below yield the best results when used together and when optimization is enabled. For example, to detect object sizes across function boundaries or to follow pointer assignments through non-trivial control flow they rely on various optimization passes enabled with</source>
          <target state="translated">GCC实施了一种有限的缓冲区溢出保护机制，该机制可以通过确定将要写入数据的对象的大小并在大小不足时阻止写入来防止某些缓冲区溢出攻击。一起使用和启用优化后，下面描述的内置函数可产生最佳效果。例如，要检测跨函数边界的对象大小或通过非平凡的控制流遵循指针分配，它们依赖于启用了各种优化的通道</target>
        </trans-unit>
        <trans-unit id="c63f8d617f5fcd74378c430997fb1de4655a5a57" translate="yes" xml:space="preserve">
          <source>GCC implements extensions for C as described in the ARM C Language Extensions (ACLE) specification, which can be found at &lt;a href=&quot;http://infocenter.arm.com/help/topic/com.arm.doc.ihi0053c/IHI0053C_acle_2_0.pdf&quot;&gt;http://infocenter.arm.com/help/topic/com.arm.doc.ihi0053c/IHI0053C_acle_2_0.pdf&lt;/a&gt;.</source>
          <target state="translated">GCC实现了ARM C语言扩展（ACLE）规范中所述的C扩展，可以在&lt;a href=&quot;http://infocenter.arm.com/help/topic/com.arm.doc.ihi0053c/IHI0053C_acle_2_0.pdf&quot;&gt;http://infocenter.arm.com/help/topic/com.arm.doc.ihi0053c/IHI0053C_acle_2_0.pdf中&lt;/a&gt;找到。</target>
        </trans-unit>
        <trans-unit id="293bbd3b2e69a9d930833e11f1b427e7997876a6" translate="yes" xml:space="preserve">
          <source>GCC implements for both C and C++ a syntactic extension to implement the &lt;code&gt;offsetof&lt;/code&gt; macro.</source>
          <target state="translated">GCC为C和C ++实现了语法扩展，以实现 &lt;code&gt;offsetof&lt;/code&gt; 宏。</target>
        </trans-unit>
        <trans-unit id="322077390825044afaea930b7263992ddcea81e8" translate="yes" xml:space="preserve">
          <source>GCC implements taking the address of a nested function using a technique called &lt;em&gt;trampolines&lt;/em&gt;. This technique was described in Lexical Closures for C++ (Thomas M. Breuel, USENIX C++ Conference Proceedings, October 17-21, 1988).</source>
          <target state="translated">GCC使用称为&lt;em&gt;蹦床&lt;/em&gt;的技术来实现嵌套函数的地址。C ++的词法闭包中对此技术进行了描述（Thomas M. Breuel，USENIX C ++会议论文集，1988年10月17日至21日）。</target>
        </trans-unit>
        <trans-unit id="239348ac99d6992297a72fcc17bd9b383a471db0" translate="yes" xml:space="preserve">
          <source>GCC implements the ARMv8-M Security Extensions as described in the ARMv8-M Security Extensions: Requirements on Development Tools Engineering Specification, which can be found at &lt;a href=&quot;http://infocenter.arm.com/help/topic/com.arm.doc.ecm0359818/ECM0359818_armv8m_security_extensions_reqs_on_dev_tools_1_0.pdf&quot;&gt;http://infocenter.arm.com/help/topic/com.arm.doc.ecm0359818/ECM0359818_armv8m_security_extensions_reqs_on_dev_tools_1_0.pdf&lt;/a&gt;.</source>
          <target state="translated">GCC按照《 ARMv8-M安全性扩展：开发工具工程规范的要求》中的说明实施ARMv8-M安全性扩展，可以在&lt;a href=&quot;http://infocenter.arm.com/help/topic/com.arm.doc.ecm0359818/ECM0359818_armv8m_security_extensions_reqs_on_dev_tools_1_0.pdf&quot;&gt;http://infocenter.arm.com/help/topic/com.arm.doc&lt;/a&gt;上找到它。 ecm0359818 / ECM0359818_armv8m_security_extensions_reqs_on_dev_tools_1_0.pdf。</target>
        </trans-unit>
        <trans-unit id="7c1d6efdb055c03457ac985aa41eeb676f9d1c1c" translate="yes" xml:space="preserve">
          <source>GCC implements three different semantics of declaring a function inline. One is available with</source>
          <target state="translated">GCC实现了三种不同语义的内联函数声明。一种是通过</target>
        </trans-unit>
        <trans-unit id="16fab68e571685f848321494bfa65aa76fa12ecf" translate="yes" xml:space="preserve">
          <source>GCC includes built-in versions of many of the functions in the standard C library. These functions come in two forms: one whose names start with the &lt;code&gt;__builtin_&lt;/code&gt; prefix, and the other without. Both forms have the same type (including prototype), the same address (when their address is taken), and the same meaning as the C library functions even if you specify the</source>
          <target state="translated">GCC在标准C库中包含许多功能的内置版本。这些函数有两种形式：一种以 &lt;code&gt;__builtin_&lt;/code&gt; 前缀开头，另一种则不带前缀。两种形式都具有相同的类型（包括原型），相同的地址（采用它们的地址时）以及与C库函数相同的含义，即使您指定了</target>
        </trans-unit>
        <trans-unit id="6ddb06bf023a460b3469518f6828ceb9799c46e8" translate="yes" xml:space="preserve">
          <source>GCC is incompatible with traditional C.</source>
          <target state="translated">GCC与传统C语言不兼容。</target>
        </trans-unit>
        <trans-unit id="d28b24326033740593178727cd1510ca18099b74" translate="yes" xml:space="preserve">
          <source>GCC is only limited by available memory.</source>
          <target state="translated">GCC只受可用内存的限制。</target>
        </trans-unit>
        <trans-unit id="e1b7ed70d92a385236df81656270c5df961819cc" translate="yes" xml:space="preserve">
          <source>GCC needs to install corrected versions of some system header files. This is because most target systems have some header files that won&amp;rsquo;t work with GCC unless they are changed. Some have bugs, some are incompatible with ISO C, and some depend on special features of other compilers.</source>
          <target state="translated">GCC需要安装某些系统头文件的正确版本。这是因为大多数目标系统都有一些头文件，除非更改它们，否则它们将无法与GCC一起使用。一些具有错误，一些与ISO C不兼容，并且一些依赖于其他编译器的特殊功能。</target>
        </trans-unit>
        <trans-unit id="6fec00d5e695a6ba7008f039024af2f2354b9175" translate="yes" xml:space="preserve">
          <source>GCC no longer supports DWARF Version 1, which is substantially different than Version 2 and later. For historical reasons, some other DWARF-related options such as</source>
          <target state="translated">GCC不再支持DWARF第1版,这与第2版及以后的版本有很大的不同。由于历史原因,其他一些与DWARF相关的选项,如</target>
        </trans-unit>
        <trans-unit id="9571fcf4d32ba7634429d5420351196a13337bf1" translate="yes" xml:space="preserve">
          <source>GCC normally defines &lt;code&gt;__STDC__&lt;/code&gt; to be 1, and in addition defines &lt;code&gt;__STRICT_ANSI__&lt;/code&gt; if you specify the</source>
          <target state="translated">GCC通常将 &lt;code&gt;__STDC__&lt;/code&gt; 定义为1，此外，如果您指定 &lt;code&gt;__STRICT_ANSI__&lt;/code&gt; ，</target>
        </trans-unit>
        <trans-unit id="d2a04d28db5bb4fd272285d6f2261f1af937b1aa" translate="yes" xml:space="preserve">
          <source>GCC normally generates special code to handle certain built-in functions more efficiently; for instance, calls to &lt;code&gt;alloca&lt;/code&gt; may become single instructions which adjust the stack directly, and calls to &lt;code&gt;memcpy&lt;/code&gt; may become inline copy loops. The resulting code is often both smaller and faster, but since the function calls no longer appear as such, you cannot set a breakpoint on those calls, nor can you change the behavior of the functions by linking with a different library. In addition, when a function is recognized as a built-in function, GCC may use information about that function to warn about problems with calls to that function, or to generate more efficient code, even if the resulting code still contains calls to that function. For example, warnings are given with</source>
          <target state="translated">GCC通常会生成特殊的代码来更有效地处理某些内置函数；例如，对 &lt;code&gt;alloca&lt;/code&gt; 的调用可能成为直接调整堆栈的单个指令，对 &lt;code&gt;memcpy&lt;/code&gt; 的调用可能成为内联复制循环。生成的代码通常更小且更快，但是由于函数调用不再像这样出现，因此您无法在这些调用上设置断点，也无法通过链接到其他库来更改函数的行为。此外，当某个功能被识别为内置功能时，GCC可能会使用有关该功能的信息来警告对该功能的调用存在问题，或者生成更有效的代码，即使结果代码仍包含对该功能的调用。例如，警告带有</target>
        </trans-unit>
        <trans-unit id="7e6e1ac548faaad8ae2131d82037c03b74f72b7e" translate="yes" xml:space="preserve">
          <source>GCC normally makes string constants read-only. If several identical-looking string constants are used, GCC stores only one copy of the string.</source>
          <target state="translated">GCC通常将字符串常量设为只读。如果使用了几个外观相同的字符串常量,GCC只存储一个字符串的副本。</target>
        </trans-unit>
        <trans-unit id="11a713f18e4fa0802eb282a6537925d48c0259a3" translate="yes" xml:space="preserve">
          <source>GCC normally uses a single instruction to load values from the GOT. While this is relatively efficient, it only works if the GOT is smaller than about 64k. Anything larger causes the linker to report an error such as:</source>
          <target state="translated">GCC通常使用一条指令从GOT中加载值。虽然这样做比较有效率,但只有当GOT小于64k时才有效。更大的则会导致链接器报告一个错误,如:。</target>
        </trans-unit>
        <trans-unit id="be424d75f5ffc48b72e433597659af0ae3069a92" translate="yes" xml:space="preserve">
          <source>GCC option.</source>
          <target state="translated">海合会选项:</target>
        </trans-unit>
        <trans-unit id="0cb280cc3350dd85b51b4e6912bba246b1815ba4" translate="yes" xml:space="preserve">
          <source>GCC permits a C structure to have no members:</source>
          <target state="translated">GCC允许C结构没有成员。</target>
        </trans-unit>
        <trans-unit id="410ccd5268fc842081ec500688897d4eab9d507c" translate="yes" xml:space="preserve">
          <source>GCC provides a couple of special builtin functions to aid in the writing of interrupt handlers in C.</source>
          <target state="translated">GCC提供了几个特殊的内置函数来帮助在C语言中编写中断处理程序。</target>
        </trans-unit>
        <trans-unit id="9a84666be4b2834544f27c65de6a453c576dd60a" translate="yes" xml:space="preserve">
          <source>GCC provides a large number of built-in functions other than the ones mentioned above. Some of these are for internal use in the processing of exceptions or variable-length argument lists and are not documented here because they may change from time to time; we do not recommend general use of these functions.</source>
          <target state="translated">除了上面提到的函数外,GCC还提供了大量的内置函数,其中有一些是内部使用的,用于处理异常或可变长度的参数列表,由于它们可能会时常变化,所以在此不作记录;我们不建议普遍使用这些函数。其中有一些是在处理异常或可变长度参数列表时内部使用的,由于它们可能会时常变化,所以在此不作记录;我们不建议普遍使用这些函数。</target>
        </trans-unit>
        <trans-unit id="dd6c408349b302ebed79b324cb6148ad8750cb77" translate="yes" xml:space="preserve">
          <source>GCC provides an interface for the PowerPC family of processors to access the AltiVec operations described in Motorola&amp;rsquo;s AltiVec Programming Interface Manual. The interface is made available by including &lt;code&gt;&amp;lt;altivec.h&amp;gt;&lt;/code&gt; and using</source>
          <target state="translated">GCC为PowerPC系列处理器提供了一个接口，以访问Motorola的《 AltiVec编程接口手册》中描述的AltiVec操作。通过包含 &lt;code&gt;&amp;lt;altivec.h&amp;gt;&lt;/code&gt; 并使用可以使用该接口</target>
        </trans-unit>
        <trans-unit id="f17fd1e9e7781f60f577293ffbb0fbe50f2aa38c" translate="yes" xml:space="preserve">
          <source>GCC provides an interface to selected machine instructions from the picoChip instruction set.</source>
          <target state="translated">GCC为picoChip指令集中选定的机器指令提供了一个接口。</target>
        </trans-unit>
        <trans-unit id="5ddbeccb51a8011bd71cee78329676c8768e012d" translate="yes" xml:space="preserve">
          <source>GCC provides built-in versions of the ISO C99 floating-point comparison macros that avoid raising exceptions for unordered operands. They have the same names as the standard macros ( &lt;code&gt;isgreater&lt;/code&gt;, &lt;code&gt;isgreaterequal&lt;/code&gt;, &lt;code&gt;isless&lt;/code&gt;, &lt;code&gt;islessequal&lt;/code&gt;, &lt;code&gt;islessgreater&lt;/code&gt;, and &lt;code&gt;isunordered&lt;/code&gt;) , with &lt;code&gt;__builtin_&lt;/code&gt; prefixed. We intend for a library implementor to be able to simply &lt;code&gt;#define&lt;/code&gt; each standard macro to its built-in equivalent. In the same fashion, GCC provides &lt;code&gt;fpclassify&lt;/code&gt;, &lt;code&gt;isfinite&lt;/code&gt;, &lt;code&gt;isinf_sign&lt;/code&gt;, &lt;code&gt;isnormal&lt;/code&gt; and &lt;code&gt;signbit&lt;/code&gt; built-ins used with &lt;code&gt;__builtin_&lt;/code&gt; prefixed. The &lt;code&gt;isinf&lt;/code&gt; and &lt;code&gt;isnan&lt;/code&gt; built-in functions appear both with and without the &lt;code&gt;__builtin_&lt;/code&gt; prefix.</source>
          <target state="translated">GCC提供了ISO C99浮点比较宏的内置版本，可避免引发无序操作数的异常。它们具有与标准宏相同的名称（ &lt;code&gt;isgreater&lt;/code&gt; ， &lt;code&gt;isgreaterequal&lt;/code&gt; ， &lt;code&gt;isless&lt;/code&gt; ， &lt;code&gt;islessequal&lt;/code&gt; ， &lt;code&gt;islessgreater&lt;/code&gt; 和 &lt;code&gt;isunordered&lt;/code&gt; ），并带有 &lt;code&gt;__builtin_&lt;/code&gt; 前缀。我们希望库实现者能够简单地 &lt;code&gt;#define&lt;/code&gt; 每个标准宏为其内置等效项。以同样的方式，GCC提供 &lt;code&gt;fpclassify&lt;/code&gt; ， &lt;code&gt;isfinite&lt;/code&gt; ， &lt;code&gt;isinf_sign&lt;/code&gt; ， &lt;code&gt;isnormal&lt;/code&gt; 和 &lt;code&gt;signbit&lt;/code&gt; 带有 &lt;code&gt;__builtin_&lt;/code&gt; 前缀的内置插件。带有和不带有 &lt;code&gt;__builtin_&lt;/code&gt; 前缀的 &lt;code&gt;isinf&lt;/code&gt; 和 &lt;code&gt;isnan&lt;/code&gt; 内置函数都会出现。</target>
        </trans-unit>
        <trans-unit id="2050dfe83adc5c7628805205b83a18bf6445e1ea" translate="yes" xml:space="preserve">
          <source>GCC provides extensions for the SPU processor as described in the Sony/Toshiba/IBM SPU Language Extensions Specification. GCC&amp;rsquo;s implementation differs in several ways.</source>
          <target state="translated">GCC提供了SPU处理器的扩展，如Sony / Toshiba / IBM SPU语言扩展规范中所述。GCC的实现在几个方面有所不同。</target>
        </trans-unit>
        <trans-unit id="e32059373d4f323b9500c52b6c9f30c837d92c67" translate="yes" xml:space="preserve">
          <source>GCC provides intrinsics to access certain instructions of the TI C6X processors. These intrinsics, listed below, are available after inclusion of the &lt;code&gt;c6x_intrinsics.h&lt;/code&gt; header file. They map directly to C6X instructions.</source>
          <target state="translated">GCC提供了访问TI C6X处理器的某些指令的内在函数。包含 &lt;code&gt;c6x_intrinsics.h&lt;/code&gt; 头文件之后，下面列出的这些内在函数可用。它们直接映射到C6X指令。</target>
        </trans-unit>
        <trans-unit id="4b78e24ee2fcd774983a8458d70a096c1f01f9ae" translate="yes" xml:space="preserve">
          <source>GCC provides intrinsics to access every instruction of the TILE-Gx processor. The intrinsics are of the form:</source>
          <target state="translated">GCC提供了访问TILE-Gx处理器的每条指令的内在因素。本质论的形式是:</target>
        </trans-unit>
        <trans-unit id="9929eef1ea9191b05967ff4d40ec8ba33acf1914" translate="yes" xml:space="preserve">
          <source>GCC provides intrinsics to access every instruction of the TILEPro processor. The intrinsics are of the form:</source>
          <target state="translated">GCC提供了访问TILEPro处理器的每条指令的内在因素。内在函数的形式是:</target>
        </trans-unit>
        <trans-unit id="ce1f47a40b55c4bca6e7d75e5dd0559de5a981c1" translate="yes" xml:space="preserve">
          <source>GCC provides intrinsics to access the SIMD instructions provided by the MSA MIPS SIMD Architecture. The interface is made available by including &lt;code&gt;&amp;lt;msa.h&amp;gt;&lt;/code&gt; and using</source>
          <target state="translated">GCC提供了内部函数来访问由MSA MIPS SIMD体系结构提供的SIMD指令。通过包含 &lt;code&gt;&amp;lt;msa.h&amp;gt;&lt;/code&gt; 并使用可以使用该接口</target>
        </trans-unit>
        <trans-unit id="40749dfbc24dc6f5a0b131fccc39dc31c09ec61c" translate="yes" xml:space="preserve">
          <source>GCC provides intrinsics to access the SIMD instructions provided by the ST Microelectronics Loongson-2E and -2F processors. These intrinsics, available after inclusion of the &lt;code&gt;loongson.h&lt;/code&gt; header file, operate on the following 64-bit vector types:</source>
          <target state="translated">GCC提供了内部函数来访问由ST Microelectronics Loongson-2E和-2F处理器提供的SIMD指令。这些内在函数在包含 &lt;code&gt;loongson.h&lt;/code&gt; 头文件之后可用，它们对以下64位向量类型进行操作：</target>
        </trans-unit>
        <trans-unit id="924dd6007d38ce7b6e1d6cc29626f87cdabebfe1" translate="yes" xml:space="preserve">
          <source>GCC provides many FR-V-specific built-in functions. In general, these functions are intended to be compatible with those described by FR-V Family, Softune C/C++ Compiler Manual (V6), Fujitsu Semiconductor. The two exceptions are &lt;code&gt;__MDUNPACKH&lt;/code&gt; and &lt;code&gt;__MBTOHE&lt;/code&gt;, the GCC forms of which pass 128-bit values by pointer rather than by value.</source>
          <target state="translated">GCC提供了许多FR-V特定的内置功能。通常，这些功能旨在与FUtsutsu Semiconductor的FR-V系列，Softune C / C ++编译器手册（V6）中描述的功能兼容。 &lt;code&gt;__MDUNPACKH&lt;/code&gt; 和 &lt;code&gt;__MBTOHE&lt;/code&gt; 这两个例外，它们的GCC形式通过指针而不是通过值传递128位值。</target>
        </trans-unit>
        <trans-unit id="9e2fa02f56a7975c68bfa6e70c41727409fe7b0c" translate="yes" xml:space="preserve">
          <source>GCC provides other MIPS-specific built-in functions:</source>
          <target state="translated">GCC提供了其他MIPS特有的内置函数。</target>
        </trans-unit>
        <trans-unit id="c10a95a94bae56390209bcb97b207903625a1bc4" translate="yes" xml:space="preserve">
          <source>GCC provides the built-in functions &lt;code&gt;__builtin_setjmp&lt;/code&gt; and &lt;code&gt;__builtin_longjmp&lt;/code&gt; which are similar to, but not interchangeable with, the C library functions &lt;code&gt;setjmp&lt;/code&gt; and &lt;code&gt;longjmp&lt;/code&gt;. The built-in versions are used internally by GCC&amp;rsquo;s libraries to implement exception handling on some targets. You should use the standard C library functions declared in &lt;code&gt;&amp;lt;setjmp.h&amp;gt;&lt;/code&gt; in user code instead of the builtins.</source>
          <target state="translated">GCC提供了内置函数 &lt;code&gt;__builtin_setjmp&lt;/code&gt; 和 &lt;code&gt;__builtin_longjmp&lt;/code&gt; ，它们与C库函数 &lt;code&gt;setjmp&lt;/code&gt; 和 &lt;code&gt;longjmp&lt;/code&gt; 相似，但不能互换。内置版本供GCC的库内部使用，以在某些目标上实现异常处理。您应该在用户代码中使用在 &lt;code&gt;&amp;lt;setjmp.h&amp;gt;&lt;/code&gt; 中声明的标准C库函数，而不要使用内置函数。</target>
        </trans-unit>
        <trans-unit id="9735e9559d39719652bb957e983b7d2a3d2f7126" translate="yes" xml:space="preserve">
          <source>GCC provides three magic constants that hold the name of the current function as a string. In C++11 and later modes, all three are treated as constant expressions and can be used in &lt;code&gt;constexpr&lt;/code&gt; constexts. The first of these constants is &lt;code&gt;__func__&lt;/code&gt;, which is part of the C99 standard:</source>
          <target state="translated">GCC提供了三个魔术常数，它们将当前函数的名称保存为字符串。在C ++ 11和更高版本的模式中，所有这三种都被视为常量表达式，并且可以在 &lt;code&gt;constexpr&lt;/code&gt; 上下文中使用。这些常量的第一个是 &lt;code&gt;__func__&lt;/code&gt; ，它是C99标准的一部分：</target>
        </trans-unit>
        <trans-unit id="2948277f494886df96fe31449754e2666c1dabe5" translate="yes" xml:space="preserve">
          <source>GCC provides two interfaces for accessing the Hardware Transactional Memory (HTM) instructions available on some of the PowerPC family of processors (eg, POWER8). The two interfaces come in a low level interface, consisting of built-in functions specific to PowerPC and a higher level interface consisting of inline functions that are common between PowerPC and S/390.</source>
          <target state="translated">GCC提供了两个接口,用于访问某些PowerPC系列处理器(如POWER8)上可用的硬件事务存储器(HTM)指令。这两个接口有一个低级接口,由PowerPC特有的内置函数组成,还有一个高级接口,由PowerPC和S/390之间通用的内联函数组成。</target>
        </trans-unit>
        <trans-unit id="0504373821c4265dbbe47258f3675e81d3bda382" translate="yes" xml:space="preserve">
          <source>GCC searches for the &amp;lsquo;</source>
          <target state="translated">GCC搜索&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="f29e392d59a7180cc6e4238e88b7157ffcf6417f" translate="yes" xml:space="preserve">
          <source>GCC stands for &amp;ldquo;GNU Compiler Collection&amp;rdquo;. GCC is an integrated distribution of compilers for several major programming languages. These languages currently include C, C++, Objective-C, Objective-C++, Fortran, Ada, D, Go, and BRIG (HSAIL).</source>
          <target state="translated">GCC代表&amp;ldquo; GNU编译器集合&amp;rdquo;。GCC是几种主要编程语言的编译器的集成发行版。这些语言当前包括C，C ++，Objective-C，Objective-C ++，Fortran，Ada，D，Go和BRIG（HSAIL）。</target>
        </trans-unit>
        <trans-unit id="1d5a85fa7b27fa126424357ffe5ddd8aadcd2aa6" translate="yes" xml:space="preserve">
          <source>GCC support of decimal float as specified by the draft technical report is incomplete:</source>
          <target state="translated">海合会对技术报告草案规定的十进制浮点数的支持是不完整的。</target>
        </trans-unit>
        <trans-unit id="28561e4b3e7debdbfb6dbdfe238413f5b85b54ce" translate="yes" xml:space="preserve">
          <source>GCC support of fixed-point types as specified by the draft technical report is incomplete:</source>
          <target state="translated">GCC对技术报告草案规定的定点类型的支持是不完整的。</target>
        </trans-unit>
        <trans-unit id="1fa5de60932a0f2deade437763dee9d9034d0c2f" translate="yes" xml:space="preserve">
          <source>GCC supports &amp;ldquo;traditional&amp;rdquo; Objective-C (also known as &amp;ldquo;Objective-C 1.0&amp;rdquo;) and contains support for the Objective-C exception and synchronization syntax. It has also support for a number of &amp;ldquo;Objective-C 2.0&amp;rdquo; language extensions, including properties, fast enumeration (only for Objective-C), method attributes and the @optional and @required keywords in protocols. GCC supports Objective-C++ and features available in Objective-C are also available in Objective-C++.</source>
          <target state="translated">GCC支持&amp;ldquo;传统&amp;rdquo; Objective-C（也称为&amp;ldquo; Objective-C 1.0&amp;rdquo;），并包含对Objective-C异常和同步语法的支持。它还支持许多&amp;ldquo; Objective-C 2.0&amp;rdquo;语言扩展，包括属性，快速枚举（仅适用于Objective-C），方法属性以及协议中的@optional和@required关键字。GCC支持Objective-C ++，Objective-C中可用的功能也在Objective-C ++中可用。</target>
        </trans-unit>
        <trans-unit id="830690076ebfb70e332b381ddb9fe46655004637" translate="yes" xml:space="preserve">
          <source>GCC supports MIPS DSP operations using both the generic vector extensions (see &lt;a href=&quot;vector-extensions#Vector-Extensions&quot;&gt;Vector Extensions&lt;/a&gt;) and a collection of MIPS-specific built-in functions. Both kinds of support are enabled by the</source>
          <target state="translated">GCC同时使用通用向量扩展（请参阅&lt;a href=&quot;vector-extensions#Vector-Extensions&quot;&gt;Vector Extensions&lt;/a&gt;）和特定于MIPS的内置函数的集合来支持MIPS DSP操作。两种支持均由</target>
        </trans-unit>
        <trans-unit id="8d83e55eff0bd290fe83057edfb4aff0d4da11fc" translate="yes" xml:space="preserve">
          <source>GCC supports SIMD operations on the SPARC using both the generic vector extensions (see &lt;a href=&quot;vector-extensions#Vector-Extensions&quot;&gt;Vector Extensions&lt;/a&gt;) as well as built-in functions for the SPARC Visual Instruction Set (VIS). When you use the</source>
          <target state="translated">GCC使用通用矢量扩展名（请参见&lt;a href=&quot;vector-extensions#Vector-Extensions&quot;&gt;Vector Extensions&lt;/a&gt;）以及SPARC可视指令集（VIS）的内置函数，支持SPARC上的SIMD操作。当您使用</target>
        </trans-unit>
        <trans-unit id="76e5e7f27add586f752fd2c88bf216b480271ed7" translate="yes" xml:space="preserve">
          <source>GCC supports a &lt;code&gt;#pragma&lt;/code&gt; directive that changes the name used in assembly for a given declaration. While this pragma is supported on all platforms, it is intended primarily to provide compatibility with the Solaris system headers. This effect can also be achieved using the asm labels extension (see &lt;a href=&quot;asm-labels#Asm-Labels&quot;&gt;Asm Labels&lt;/a&gt;).</source>
          <target state="translated">GCC支持 &lt;code&gt;#pragma&lt;/code&gt; 指令，该指令可更改给定声明在汇编中使用的名称。尽管所有平台都支持此编译指示，但其主要目的是提供与Solaris系统标头的兼容性。使用asm标签扩展名也可以实现这种效果（请参阅&lt;a href=&quot;asm-labels#Asm-Labels&quot;&gt;Asm Labels&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="498314540c8d67676764e9f766eda8fd96a7daed" translate="yes" xml:space="preserve">
          <source>GCC supports a number of command-line options that control adding run-time instrumentation to the code it normally generates. For example, one purpose of instrumentation is collect profiling statistics for use in finding program hot spots, code coverage analysis, or profile-guided optimizations. Another class of program instrumentation is adding run-time checking to detect programming errors like invalid pointer dereferences or out-of-bounds array accesses, as well as deliberately hostile attacks such as stack smashing or C++ vtable hijacking. There is also a general hook which can be used to implement other forms of tracing or function-level instrumentation for debug or program analysis purposes.</source>
          <target state="translated">GCC支持许多命令行选项,这些选项可以控制在它通常生成的代码中添加运行时工具。例如,工具化的一个目的是收集剖析统计数据,用于查找程序热点、代码覆盖率分析或剖析引导的优化。另一类程序工具化是增加运行时检查,以检测程序错误,如无效指针取消引用或越界数组访问,以及故意的敌对攻击,如堆栈粉碎或C++vtable hijacking。还有一个通用的钩子,可以用来实现其他形式的跟踪或函数级工具,以达到调试或程序分析的目的。</target>
        </trans-unit>
        <trans-unit id="1030e6dea2c81b69bdc7270b03b39b5f569ad6fa" translate="yes" xml:space="preserve">
          <source>GCC supports a variant of the o32 ABI in which floating-point registers are 64 rather than 32 bits wide. You can select this combination with</source>
          <target state="translated">GCC支持o32 ABI的变体,其中浮点寄存器的宽度是64位而不是32位。您可以用</target>
        </trans-unit>
        <trans-unit id="c3965449e7a5dc4d5ed8a9dc3199dec909c35dc5" translate="yes" xml:space="preserve">
          <source>GCC supports only two&amp;rsquo;s complement integer types, and all bit patterns are ordinary values.</source>
          <target state="translated">GCC仅支持二进制补码类型，所有位模式均为普通值。</target>
        </trans-unit>
        <trans-unit id="83dd0c21621e0a6e0dd523c863cbfaef04449bd4" translate="yes" xml:space="preserve">
          <source>GCC supports paired-single operations using both the generic vector extensions (see &lt;a href=&quot;vector-extensions#Vector-Extensions&quot;&gt;Vector Extensions&lt;/a&gt;) and a collection of MIPS-specific built-in functions. Both kinds of support are enabled by the</source>
          <target state="translated">GCC支持使用通用向量扩展名（请参见&lt;a href=&quot;vector-extensions#Vector-Extensions&quot;&gt;Vector Extensions&lt;/a&gt;）和一组MIPS特定的内置函数来进行成对的单操作。两种支持均由</target>
        </trans-unit>
        <trans-unit id="b55fc398fe2655fec7265522ba909be632a50b88" translate="yes" xml:space="preserve">
          <source>GCC supports several types of pragmas, primarily in order to compile code originally written for other compilers. Note that in general we do not recommend the use of pragmas; See &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;Function Attributes&lt;/a&gt;, for further explanation.</source>
          <target state="translated">GCC支持多种类型的编译指示，主要是为了编译最初为其他编译器编写的代码。请注意，一般而言，我们不建议您使用编译指示。有关更多说明，请参见&lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;功能属性&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="653525fcb8a016916ca28e1dd65b18ab8839e4b5" translate="yes" xml:space="preserve">
          <source>GCC supports some of the RX instructions which cannot be expressed in the C programming language via the use of built-in functions. The following functions are supported:</source>
          <target state="translated">GCC支持一些无法通过使用内置函数在C语言编程中表达的RX指令。支持以下函数:</target>
        </trans-unit>
        <trans-unit id="4b0cba78b946248aec959caf8a965144462518ce" translate="yes" xml:space="preserve">
          <source>GCC supports the D 2.0 programming language. The D language itself is currently defined by its reference implementation and supporting language specification, described at &lt;a href=&quot;https://dlang.org/spec/spec.html&quot;&gt;https://dlang.org/spec/spec.html&lt;/a&gt;.</source>
          <target state="translated">GCC支持D 2.0编程语言。D语言本身当前由其参考实现和支持的语言规范定义，请参见&lt;a href=&quot;https://dlang.org/spec/spec.html&quot;&gt;https://dlang.org/spec/spec.html&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="359d53772696a2b7864fe27fe3565593d8a4b28c" translate="yes" xml:space="preserve">
          <source>GCC supports the following AVR devices and ISAs:</source>
          <target state="translated">GCC支持以下AVR设备和ISA。</target>
        </trans-unit>
        <trans-unit id="2ea7c76cda0c4fbb899bd829aa15b4c8a69297f6" translate="yes" xml:space="preserve">
          <source>GCC supports the original ISO C++ standard published in 1998, and the 2011 and 2014 revisions.</source>
          <target state="translated">GCC支持1998年发布的原始ISO C++标准,以及2011年和2014年的修订版。</target>
        </trans-unit>
        <trans-unit id="858a69c7492112ce45741ecc79e61821fd61a803" translate="yes" xml:space="preserve">
          <source>GCC supports these options when compiling for C-SKY V2 processors.</source>
          <target state="translated">在为C-SKY V2处理器编译时,GCC支持这些选项。</target>
        </trans-unit>
        <trans-unit id="0dc67ad6d4b46256a65720385ae1177b91b75554" translate="yes" xml:space="preserve">
          <source>GCC supports two forms of SVE code generation: &amp;ldquo;vector-length agnostic&amp;rdquo; output that works with any size of vector register and &amp;ldquo;vector-length specific&amp;rdquo; output that allows GCC to make assumptions about the vector length when it is useful for optimization reasons. The possible values of &amp;lsquo;</source>
          <target state="translated">GCC支持两种形式的SVE代码生成：&amp;ldquo;向量长度不可知&amp;rdquo;输出可与任何大小的向量寄存器一起使用，&amp;ldquo;向量长度特定&amp;rdquo;输出可让GCC在出于优化原因而有用时对向量长度进行假设。'的可能值</target>
        </trans-unit>
        <trans-unit id="5b3ded850043ac176423c8bd10dd3fbbab6dc5cd" translate="yes" xml:space="preserve">
          <source>GCC treats all characters of identifiers as significant. According to K&amp;amp;R-1 (2.2), &amp;ldquo;No more than the first eight characters are significant, although more may be used.&amp;rdquo;. Also according to K&amp;amp;R-1 (2.2), &amp;ldquo;An identifier is a sequence of letters and digits; the first character must be a letter. The underscore _ counts as a letter.&amp;rdquo;, but GCC also allows dollar signs in identifiers.</source>
          <target state="translated">GCC将标识符的所有字符视为有效字符。根据K＆R-1（2.2），&amp;ldquo;虽然可以使用更多的字符，但前八个字符的有效位数不超过。&amp;rdquo;。同样根据K＆R-1（2.2），&amp;ldquo;标识符是由字母和数字组成的序列；第一个字符必须是字母。下划线_视为字母。&amp;rdquo;，但GCC还允许在标识符中使用美元符号。</target>
        </trans-unit>
        <trans-unit id="feaee8cb866302ba1b5ec59a1ce37d673602a1f3" translate="yes" xml:space="preserve">
          <source>GCC uses &lt;var&gt;name&lt;/var&gt; to determine what kind of instructions it can emit when generating assembly code (as if by</source>
          <target state="translated">GCC使用 &lt;var&gt;name&lt;/var&gt; 来确定在生成汇编代码时可以发出哪种指令（就像通过</target>
        </trans-unit>
        <trans-unit id="66e1ddf3758925ad2362fd6f220c229932999055" translate="yes" xml:space="preserve">
          <source>GCC uses &lt;var&gt;name&lt;/var&gt; to determine what kind of instructions it can emit when generating assembly code. If</source>
          <target state="translated">GCC使用 &lt;var&gt;name&lt;/var&gt; 来确定生成汇编代码时可以发出的指令类型。如果</target>
        </trans-unit>
        <trans-unit id="813ae2789d4b6769128e82ee496ab87522d87f2b" translate="yes" xml:space="preserve">
          <source>GCC uses a garbage collector to manage its own memory allocation. This parameter specifies the minimum percentage by which the garbage collector&amp;rsquo;s heap should be allowed to expand between collections. Tuning this may improve compilation speed; it has no effect on code generation.</source>
          <target state="translated">GCC使用垃圾回收器来管理自己的内存分配。此参数指定允许垃圾收集器的堆在收集之间扩展的最小百分比。进行调整可以提高编译速度；它对代码生成没有影响。</target>
        </trans-unit>
        <trans-unit id="ae9ac11b129e57b155bc25157be869b1b76e80ad" translate="yes" xml:space="preserve">
          <source>GCC uses corrected versions of system header files. This is necessary, but doesn&amp;rsquo;t always work smoothly.</source>
          <target state="translated">GCC使用系统头文件的更正版本。这是必要的，但并不总是能顺利进行。</target>
        </trans-unit>
        <trans-unit id="819a72ed7eaf70f991d756c9fa760994a62ab526" translate="yes" xml:space="preserve">
          <source>GCC uses heuristics to guess branch probabilities if they are not provided by profiling feedback (</source>
          <target state="translated">GCC使用启发式方法来猜测分支概率,如果它们不是由剖析反馈提供的(</target>
        </trans-unit>
        <trans-unit id="1a8376e3c4e7645e0b124141064b06d15d9df6a1" translate="yes" xml:space="preserve">
          <source>GCC uses the system C library, which might not be compliant with the ISO C standard.</source>
          <target state="translated">GCC使用系统C库,可能不符合ISO C标准。</target>
        </trans-unit>
        <trans-unit id="ca6cd448f1a33799ac2da1a0d9dfa000cd6841ec" translate="yes" xml:space="preserve">
          <source>GCC will not inline any functions if the</source>
          <target state="translated">GCC将不会内联任何函数,如果在</target>
        </trans-unit>
        <trans-unit id="8a47996357771546a1d05e5991be4fe03520b6e5" translate="yes" xml:space="preserve">
          <source>GCC&amp;rsquo;s default behavior is to emit all inline functions with the &lt;code&gt;dllexport&lt;/code&gt; attribute. Since this can cause object file-size bloat, you can use</source>
          <target state="translated">GCC的默认行为是发出所有具有 &lt;code&gt;dllexport&lt;/code&gt; 属性的内联函数。由于这可能会导致目标文件大小膨胀，因此可以使用</target>
        </trans-unit>
        <trans-unit id="af8e45be98e36024842dc1bd8893718108d0574b" translate="yes" xml:space="preserve">
          <source>GCC&amp;rsquo;s implementation of the high-level language interface available from C and C++ code differs from Motorola&amp;rsquo;s documentation in several ways.</source>
          <target state="translated">GCC对C和C ++代码提供的高级语言接口的实现在几个方面与Motorola的文档不同。</target>
        </trans-unit>
        <trans-unit id="e78ca1e1182b55c5bde4b195b5d85015058a98d0" translate="yes" xml:space="preserve">
          <source>GCC&amp;rsquo;s optimizers do not treat this code like the non-volatile code in the earlier examples. They do not move it out of loops or omit it on the assumption that the result from a previous call is still valid.</source>
          <target state="translated">GCC的优化器不会像前面示例中的非易失性代码那样对待此代码。他们不会将其移出循环，也不会在先前调用结果仍然有效的前提下忽略它。</target>
        </trans-unit>
        <trans-unit id="dbc61f28ee0b681eff97897cb82a2c8d282dc076" translate="yes" xml:space="preserve">
          <source>GCC&amp;rsquo;s optimizers sometimes discard &lt;code&gt;asm&lt;/code&gt; statements if they determine there is no need for the output variables. Also, the optimizers may move code out of loops if they believe that the code will always return the same result (i.e. none of its input values change between calls). Using the &lt;code&gt;volatile&lt;/code&gt; qualifier disables these optimizations. &lt;code&gt;asm&lt;/code&gt; statements that have no output operands, including &lt;code&gt;asm goto&lt;/code&gt; statements, are implicitly volatile.</source>
          <target state="translated">如果GCC的优化程序确定不需要输出变量，则有时会丢弃 &lt;code&gt;asm&lt;/code&gt; 语句。同样，如果优化人员认为代码将始终返回相同的结果（即，两次调用之间的输入值均不变），则可以将代码移出循环。使用 &lt;code&gt;volatile&lt;/code&gt; 限定词将禁用这些优化。没有输出操作数的 &lt;code&gt;asm&lt;/code&gt; 语句（包括 &lt;code&gt;asm goto&lt;/code&gt; 语句）是隐式易失的。</target>
        </trans-unit>
        <trans-unit id="1e750d3c829a6b818589899b42ede982312a7f98" translate="yes" xml:space="preserve">
          <source>GCOV_ERROR_FILE</source>
          <target state="translated">GCOV_ERROR_FILE</target>
        </trans-unit>
        <trans-unit id="e485aa772b73ea7b58dcf4966c0a2d3b9c745805" translate="yes" xml:space="preserve">
          <source>GCOV_EXIT_AT_ERROR</source>
          <target state="translated">GCOV_EXIT_AT_ERROR</target>
        </trans-unit>
        <trans-unit id="80aecc9b56754f32438dd132183cddc7e4df32f1" translate="yes" xml:space="preserve">
          <source>GCOV_PREFIX contains the prefix to add to the absolute paths in the object file. Prefix can be absolute, or relative. The default is no prefix.</source>
          <target state="translated">GCOV_PREFIX包含了要添加到对象文件中绝对路径的前缀。前缀可以是绝对的,也可以是相对的。默认情况下是没有前缀。</target>
        </trans-unit>
        <trans-unit id="891aee4538b1a332bb00b85c9e7c43d1cf40d1d1" translate="yes" xml:space="preserve">
          <source>GCOV_PREFIX=/target/run</source>
          <target state="translated">GCOV_PREFIX=/target/run</target>
        </trans-unit>
        <trans-unit id="f0bcf8de4466a3194e31ce81577ad85f4f449ccb" translate="yes" xml:space="preserve">
          <source>GCOV_PREFIX_STRIP indicates the how many initial directory names to strip off the hardwired absolute paths. Default value is 0.</source>
          <target state="translated">GCOV_PREFIX_STRIP 表示要从硬线绝对路径上剥离多少个初始目录名。默认值为0。</target>
        </trans-unit>
        <trans-unit id="7069713a73584b12e5e1b6c6673abb78172fe103" translate="yes" xml:space="preserve">
          <source>GCOV_PREFIX_STRIP=1</source>
          <target state="translated">GCOV_PREFIX_STRIP=1</target>
        </trans-unit>
        <trans-unit id="a007084938316d2847460b0f869fd2dab151324f" translate="yes" xml:space="preserve">
          <source>GFNI instructions.</source>
          <target state="translated">GFNI指示:</target>
        </trans-unit>
        <trans-unit id="768001d59e5da45e8ce2de4652950a5db0123cf5" translate="yes" xml:space="preserve">
          <source>GNU C allows you to associate specific hardware registers with C variables. In almost all cases, allowing the compiler to assign registers produces the best code. However under certain unusual circumstances, more precise control over the variable storage is required.</source>
          <target state="translated">GNU C允许您将特定的硬件寄存器与C变量相关联。几乎在所有情况下,允许编译器分配寄存器都能产生最好的代码。但是在某些特殊情况下,需要对变量的存储进行更精确的控制。</target>
        </trans-unit>
        <trans-unit id="1282a7948680a82fce143391cee57deb8d315356" translate="yes" xml:space="preserve">
          <source>GNU C extends ISO C to allow a function prototype to override a later old-style non-prototype definition. Consider the following example:</source>
          <target state="translated">GNU C扩展了ISO C,允许一个函数原型覆盖一个后来的旧式非原型定义。请看下面的例子。</target>
        </trans-unit>
        <trans-unit id="e77e07d95404402b67fc9bef0aec0c9a34ecc38f" translate="yes" xml:space="preserve">
          <source>GNU C provides several language features not found in ISO standard C. (The</source>
          <target state="translated">GNU C提供了一些ISO标准C中没有的语言特性。</target>
        </trans-unit>
        <trans-unit id="d45fbb49066a76f230e9020bfe458e74293358d2" translate="yes" xml:space="preserve">
          <source>GNU C++ does not support old-style function definitions, so this extension is irrelevant.</source>
          <target state="translated">GNU C++不支持旧式函数定义,所以这个扩展是不相关的。</target>
        </trans-unit>
        <trans-unit id="2ba257a10dfda1a80f343df43a5f9faccbca64b3" translate="yes" xml:space="preserve">
          <source>GNU CPP has two further variadic macro extensions, and permits them to be used with either of the above forms of macro definition.</source>
          <target state="translated">GNU CPP 又有两个变量宏扩展,并允许它们与上述任何一种形式的宏定义一起使用。</target>
        </trans-unit>
        <trans-unit id="9dbaa828d6809d3452cb2a6728f3023aae5a8b22" translate="yes" xml:space="preserve">
          <source>GNU CPP permits you to completely omit the variable arguments in this way. In the above examples, the compiler would complain, though since the expansion of the macro still has the extra comma after the format string.</source>
          <target state="translated">GNU CPP 允许你用这种方式完全省略变量参数。在上面的例子中,虽然编译器会抱怨,但因为宏的扩展仍然在格式字符串后多了一个逗号。</target>
        </trans-unit>
        <trans-unit id="0e4ec8a54cfff9c2845fa38842cb6cd1bdea197d" translate="yes" xml:space="preserve">
          <source>GNU Free Documentation License</source>
          <target state="translated">GNU 自由文档许可证</target>
        </trans-unit>
        <trans-unit id="d9cbf0740e34d88c506fb7df6e17deeabd18660c" translate="yes" xml:space="preserve">
          <source>GNU General Public License</source>
          <target state="translated">GNU通用公共许可证</target>
        </trans-unit>
        <trans-unit id="ea5447d52819458fc788d8fe66484dcf6f8b58c5" translate="yes" xml:space="preserve">
          <source>GNU General Public License says how you can copy and share GCC.</source>
          <target state="translated">GNU通用公共许可证规定了如何复制和共享GCC。</target>
        </trans-unit>
        <trans-unit id="a21d2651a31b14abba6b9f4cc89e6d16156a2f47" translate="yes" xml:space="preserve">
          <source>GNU Objective-C provides constant string objects that are generated directly by the compiler. You declare a constant string object by prefixing a C constant string with the character &amp;lsquo;</source>
          <target state="translated">GNU Objective-C提供了由编译器直接生成的常量字符串对象。您可以通过在C常量字符串前面添加字符'来声明常量字符串对象</target>
        </trans-unit>
        <trans-unit id="d4b0f24c5578d309a3a80bcf9db1efef7dc80491" translate="yes" xml:space="preserve">
          <source>GNU Objective-C provides exception support built into the language, as in the following example:</source>
          <target state="translated">GNU Objective-C提供了内置于语言中的异常支持,如下面的例子。</target>
        </trans-unit>
        <trans-unit id="183b8b6fa7f0ebe7cc24b6e6b64ea37e46538bc2" translate="yes" xml:space="preserve">
          <source>GNU Objective-C provides support for synchronized blocks:</source>
          <target state="translated">GNU Objective-C提供了对同步块的支持。</target>
        </trans-unit>
        <trans-unit id="5a76f04c435b8a53e2673208f47df13d27337155" translate="yes" xml:space="preserve">
          <source>GNU Objective-C provides support for the fast enumeration syntax:</source>
          <target state="translated">GNU Objective-C提供了对快速枚举语法的支持。</target>
        </trans-unit>
        <trans-unit id="bd8453bc7fd0b5c5a5eb0b2fb1cc7653d6106ce4" translate="yes" xml:space="preserve">
          <source>GNU Objective-C runtime features.</source>
          <target state="translated">GNU Objective-C运行时特性。</target>
        </trans-unit>
        <trans-unit id="dc4139cbd1ca2e4ec1fdbaf154a309856bbea2a6" translate="yes" xml:space="preserve">
          <source>GNU Objective-C supports the &lt;code&gt;@encode&lt;/code&gt; syntax that allows you to create a type encoding from a C/Objective-C type. For example, &lt;code&gt;@encode(int)&lt;/code&gt; is compiled by the compiler into &lt;code&gt;&quot;i&quot;&lt;/code&gt;.</source>
          <target state="translated">GNU Objective-C支持 &lt;code&gt;@encode&lt;/code&gt; 语法，该语法允许您从C / Objective-C类型创建类型编码。例如， &lt;code&gt;@encode(int)&lt;/code&gt; 由编译器编译为 &lt;code&gt;&quot;i&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="72bdab580bf81d58abe49ef7feb3d22b198aca72" translate="yes" xml:space="preserve">
          <source>GNU dialect of</source>
          <target state="translated">GNU方言</target>
        </trans-unit>
        <trans-unit id="0cce44d2e046653755b9171f853b5aa7f7510c0f" translate="yes" xml:space="preserve">
          <source>GNU dialect of ISO C11. The name &amp;lsquo;</source>
          <target state="translated">ISO C11的GNU方言。名字 '</target>
        </trans-unit>
        <trans-unit id="17c597be9d56a306b84e8b735a051e0b49bf682b" translate="yes" xml:space="preserve">
          <source>GNU dialect of ISO C17. This is the default for C code.</source>
          <target state="translated">ISO C17的GNU方言。这是C代码的默认值。</target>
        </trans-unit>
        <trans-unit id="cd7ba84a6cf37a43cdd1bd215e060138c20d80ef" translate="yes" xml:space="preserve">
          <source>GNU dialect of ISO C90 (including some C99 features).</source>
          <target state="translated">ISO C90的GNU方言(包括一些C99特性)。</target>
        </trans-unit>
        <trans-unit id="5a96bf0e0eb1648d92a5415bbf82f314f50fc95d" translate="yes" xml:space="preserve">
          <source>GNU dialect of ISO C99. The name &amp;lsquo;</source>
          <target state="translated">ISO C99的GNU方言。名字 '</target>
        </trans-unit>
        <trans-unit id="c7513a88e6766734c8fff0b65e9260cb06e07819" translate="yes" xml:space="preserve">
          <source>GNU extensions to the C language family.</source>
          <target state="translated">GNU对C语言家族的扩展。</target>
        </trans-unit>
        <trans-unit id="90b8cbfe3e7aa922a28ad77fd2468b165d25db6d" translate="yes" xml:space="preserve">
          <source>GNU extensions to the C++ language.</source>
          <target state="translated">GNU对C++语言的扩展。</target>
        </trans-unit>
        <trans-unit id="73a49c549f68005dbe48c29ca2788c5808080012" translate="yes" xml:space="preserve">
          <source>General purpose register if 64-bit instructions are enabled or NO_REGS.</source>
          <target state="translated">如果启用64位指令或NO_REGS,则为通用寄存器。</target>
        </trans-unit>
        <trans-unit id="005c5bd36bc2dae00112330a475935d63f7703b1" translate="yes" xml:space="preserve">
          <source>General register 1</source>
          <target state="translated">总登记册1</target>
        </trans-unit>
        <trans-unit id="b09ef9c6988403ff1cf426fea1c658c5b1f6be6e" translate="yes" xml:space="preserve">
          <source>General register &lt;code&gt;r0&lt;/code&gt; to &lt;code&gt;r3&lt;/code&gt; for &lt;code&gt;addl&lt;/code&gt; instruction</source>
          <target state="translated">用于 &lt;code&gt;addl&lt;/code&gt; 指令的通用寄存器 &lt;code&gt;r0&lt;/code&gt; 至 &lt;code&gt;r3&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e89cc1c76441abdf1cb24c29330f5f35d304a8e7" translate="yes" xml:space="preserve">
          <source>General register, but not &lt;code&gt;r29&lt;/code&gt;, &lt;code&gt;r30&lt;/code&gt; and &lt;code&gt;r31&lt;/code&gt;</source>
          <target state="translated">通用寄存器，但不是 &lt;code&gt;r29&lt;/code&gt; ， &lt;code&gt;r30&lt;/code&gt; 和 &lt;code&gt;r31&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="10bd548f00f5df8e11316ab27529f8ec0d489ead" translate="yes" xml:space="preserve">
          <source>General-purpose 32-bit register</source>
          <target state="translated">通用32位寄存器</target>
        </trans-unit>
        <trans-unit id="d86490a439329533a7fda073910d458d177b7499" translate="yes" xml:space="preserve">
          <source>Generally there is no guarantee that a memory transaction ever succeeds and suitable fallback code always needs to be supplied.</source>
          <target state="translated">一般来说,不能保证内存事务永远成功,总是需要提供合适的回退代码。</target>
        </trans-unit>
        <trans-unit id="c220eb05478a76fade659e7f472b8e896908bfb7" translate="yes" xml:space="preserve">
          <source>Generally, functions are not inlined unless optimization is specified. For functions declared inline, this attribute inlines the function independent of any restrictions that otherwise apply to inlining. Failure to inline such a function is diagnosed as an error. Note that if such a function is called indirectly the compiler may or may not inline it depending on optimization level and a failure to inline an indirect call may or may not be diagnosed.</source>
          <target state="translated">一般来说,除非指定优化,否则函数不会内联。对于声明为内联的函数,该属性将内联该函数,而不受任何其他适用于内联的限制。未能内联这样的函数会被诊断为错误。请注意,如果这样的函数被间接调用,编译器可能会根据优化级别对其进行内联,也可能不会对间接调用进行内联诊断。</target>
        </trans-unit>
        <trans-unit id="84a7c319c3d7d28e18ecbf416836eecf761297c6" translate="yes" xml:space="preserve">
          <source>Generally, inlining into a function is limited. For a function marked with this attribute, every call inside this function is inlined, if possible. Functions declared with attribute &lt;code&gt;noinline&lt;/code&gt; and similar are not inlined. Whether the function itself is considered for inlining depends on its size and the current inlining parameters.</source>
          <target state="translated">通常，内联到函数是有限的。对于标有该属性的函数，如果可能，将内联该函数内的每个调用。用属性 &lt;code&gt;noinline&lt;/code&gt; 和类似属性声明的函数不进行内联。是否考虑对函数本身进行内联取决于其大小和当前的内联参数。</target>
        </trans-unit>
        <trans-unit id="da79890df831b8b599903d6736d5d918432eda2d" translate="yes" xml:space="preserve">
          <source>Generally, options specified at link time override those specified at compile time, although in some cases GCC attempts to infer link-time options from the settings used to compile the input files.</source>
          <target state="translated">一般来说,在链接时指定的选项会覆盖在编译时指定的选项,尽管在某些情况下,GCC会尝试从编译输入文件的设置中推断链接时的选项。</target>
        </trans-unit>
        <trans-unit id="ba4adeb327e032d99cfca5b51d0fd4daaa9b56fc" translate="yes" xml:space="preserve">
          <source>Generate (do not generate) ColdFire hardware divide and remainder instructions. If</source>
          <target state="translated">生成(不生成)ColdFire硬件除法和余数指令。如果</target>
        </trans-unit>
        <trans-unit id="0fe80a59bc1a906ccb8af3fc3416cadc3264624c" translate="yes" xml:space="preserve">
          <source>Generate (do not generate) GP-relative accesses. The following &lt;var&gt;option&lt;/var&gt; names are recognized:</source>
          <target state="translated">生成（不生成）GP相对访问。可以识别以下 &lt;var&gt;option&lt;/var&gt; 名称：</target>
        </trans-unit>
        <trans-unit id="09abd950717c564f7150fc3aedac403b36224304" translate="yes" xml:space="preserve">
          <source>Generate (do not generate) MIPS16 code. If GCC is targeting a MIPS32 or MIPS64 architecture, it makes use of the MIPS16e ASE.</source>
          <target state="translated">生成(不生成)MIPS16代码。如果GCC的目标是MIPS32或MIPS64架构,它就会使用MIPS16e ASE。</target>
        </trans-unit>
        <trans-unit id="7322f1cb41e6457edd178c659eebf99bfcbafd3c" translate="yes" xml:space="preserve">
          <source>Generate (do not generate) addressing modes using prefixed load and store instructions when the option</source>
          <target state="translated">生成(不生成)寻址模式,使用前缀加载和存储指令,当选择</target>
        </trans-unit>
        <trans-unit id="188ec1e266203e4853a13748340fc36d3e35234e" translate="yes" xml:space="preserve">
          <source>Generate (do not generate) code that is fully position-independent, and that can therefore be linked into shared libraries. This option only affects</source>
          <target state="translated">生成(不生成)完全与位置无关的代码,因此可以链接到共享库中。这个选项只适用于</target>
        </trans-unit>
        <trans-unit id="0a056a294949b854726ab099acb14488ae9baeac" translate="yes" xml:space="preserve">
          <source>Generate (do not generate) code that is suitable for SVR4-style dynamic objects.</source>
          <target state="translated">生成(不生成)适合SVR4风格的动态对象的代码。</target>
        </trans-unit>
        <trans-unit id="200f92cbd3d74fb5f3e648ecaaea7b69d566f040" translate="yes" xml:space="preserve">
          <source>Generate (do not generate) code that uses &lt;em&gt;base addresses&lt;/em&gt;. Using a base address automatically generates a request (handled by the assembler and the linker) for a constant to be set up in a global register. The register is used for one or more base address requests within the range 0 to 255 from the value held in the register. The generally leads to short and fast code, but the number of different data items that can be addressed is limited. This means that a program that uses lots of static data may require</source>
          <target state="translated">生成（不生成）使用&lt;em&gt;基地址的&lt;/em&gt;代码。使用基地址会自动生成一个请求（由汇编器和链接器处理），以请求在全局寄存器中设置一个常量。该寄存器用于从寄存器中保存的值开始的0到255范围内的一个或多个基址请求。通常导致短而快速的代码，但是可以寻址的不同数据项的数量是有限的。这意味着使用大量静态数据的程序可能需要</target>
        </trans-unit>
        <trans-unit id="fc8c5a89f214acd8179a09f487fb87bbd0d7c872" translate="yes" xml:space="preserve">
          <source>Generate (do not generate) code to load up the static chain register (&lt;code&gt;r11&lt;/code&gt;) when calling through a pointer on AIX and 64-bit Linux systems where a function pointer points to a 3-word descriptor giving the function address, TOC value to be loaded in register &lt;code&gt;r2&lt;/code&gt;, and static chain value to be loaded in register &lt;code&gt;r11&lt;/code&gt;. The</source>
          <target state="translated">在AIX和64位Linux系统上通过指针进行调用时，生成（不生成）代码以加载静态链寄存器（ &lt;code&gt;r11&lt;/code&gt; ），其中函数指针指向3字描述符，给出函数地址，TOC值为加载到寄存器 &lt;code&gt;r2&lt;/code&gt; 中，并将静态链值加载到寄存器 &lt;code&gt;r11&lt;/code&gt; 中。的</target>
        </trans-unit>
        <trans-unit id="813e9e6ca1642f726fee97bfddf02338960484b7" translate="yes" xml:space="preserve">
          <source>Generate (do not generate) code to pass structure parameters with a maximum alignment of 64 bits, for compatibility with older versions of GCC.</source>
          <target state="translated">生成(不生成)传递结构参数的代码,最大对齐度为64位,以兼容旧版本的GCC。</target>
        </trans-unit>
        <trans-unit id="55cac71e3fa8543a26a5b7f404ac565adfa17f28" translate="yes" xml:space="preserve">
          <source>Generate (do not generate) code to save the TOC value in the reserved stack location in the function prologue if the function calls through a pointer on AIX and 64-bit Linux systems. If the TOC value is not saved in the prologue, it is saved just before the call through the pointer. The</source>
          <target state="translated">在AIX和64位Linux系统上,如果函数通过指针调用,则生成(不生成)代码将TOC值保存在函数序幕中保留的栈位置。如果TOC值没有保存在序幕中,则会在通过指针调用之前保存。在</target>
        </trans-unit>
        <trans-unit id="492f533f0926b6f12aa3c20775f6e3689bd7771b" translate="yes" xml:space="preserve">
          <source>Generate (do not generate) microMIPS code.</source>
          <target state="translated">生成(不生成)microMIPS代码。</target>
        </trans-unit>
        <trans-unit id="3996f10552777a166b0e49d921b421c578c5e2f7" translate="yes" xml:space="preserve">
          <source>Generate (do not generate) pc-relative addressing when the option</source>
          <target state="translated">选项时,生成(不生成)pc相对寻址。</target>
        </trans-unit>
        <trans-unit id="c38ed93b70630b073ac9de0cd53b30eca713a227" translate="yes" xml:space="preserve">
          <source>Generate (do not generate) the &lt;code&gt;friz&lt;/code&gt; instruction when the</source>
          <target state="translated">当以下情况时生成（不生成） &lt;code&gt;friz&lt;/code&gt; 指令</target>
        </trans-unit>
        <trans-unit id="59dec4f42737e1a4ee2b102faf59b8bbec911145" translate="yes" xml:space="preserve">
          <source>Generate (do not generate) the MMA instructions when the option</source>
          <target state="translated">生成(不生成)MMA指令,当选项</target>
        </trans-unit>
        <trans-unit id="87be6d200ff57766f2cf75cef2026526e7116620" translate="yes" xml:space="preserve">
          <source>Generate (or do not generate) code using the &lt;code&gt;bras&lt;/code&gt; instruction to do subroutine calls. This only works reliably if the total executable size does not exceed 64k. The default is to use the &lt;code&gt;basr&lt;/code&gt; instruction instead, which does not have this limitation.</source>
          <target state="translated">使用 &lt;code&gt;bras&lt;/code&gt; 指令生成（或不生成）代码以进行子例程调用。仅当可执行文件总大小不超过64k时，此方法才能可靠地工作。缺省情况是改用 &lt;code&gt;basr&lt;/code&gt; 指令，它没有此限制。</target>
        </trans-unit>
        <trans-unit id="dac8cd11137e120330b4b9ae84e6593137818e9a" translate="yes" xml:space="preserve">
          <source>Generate (or do not generate) code using the &lt;code&gt;mvcle&lt;/code&gt; instruction to perform block moves. When</source>
          <target state="translated">使用 &lt;code&gt;mvcle&lt;/code&gt; 指令生成（或不生成）代码以执行块移动。什么时候</target>
        </trans-unit>
        <trans-unit id="2e0545421416cf516c0b942352accf8dc6b0a0d5" translate="yes" xml:space="preserve">
          <source>Generate (or don&amp;rsquo;t) &amp;lsquo;</source>
          <target state="translated">生成（或不生成）&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="05dd2841d03433fc0ea5db0c7e0df3c7599676c8" translate="yes" xml:space="preserve">
          <source>Generate (or don&amp;rsquo;t) a stop bit immediately before and after volatile asm statements.</source>
          <target state="translated">在volatile asm语句之前和之后立即生成（或不生成）停止位。</target>
        </trans-unit>
        <trans-unit id="a0784cc5b984b19815bf9eec6e275ae1a59c3b0f" translate="yes" xml:space="preserve">
          <source>Generate (or don&amp;rsquo;t) code for the GNU assembler. This is the default.</source>
          <target state="translated">为GNU汇编器生成（或不生成）代码。这是默认值。</target>
        </trans-unit>
        <trans-unit id="2516ed040d38a5388dd7fe01c44239d79052cf2e" translate="yes" xml:space="preserve">
          <source>Generate (or don&amp;rsquo;t) code for the GNU linker. This is the default.</source>
          <target state="translated">为GNU链接器生成（或不生成）代码。这是默认值。</target>
        </trans-unit>
        <trans-unit id="3e316b54c0eaa7bda512b60e40414c689d945ab8" translate="yes" xml:space="preserve">
          <source>Generate 16-bit instructions.</source>
          <target state="translated">生成16位指令。</target>
        </trans-unit>
        <trans-unit id="a52620c65360885e469f926c554c75bd50dd9583" translate="yes" xml:space="preserve">
          <source>Generate 3-instruction load and store sequences as sometimes required by the HP-UX 10 linker. This is equivalent to the &amp;lsquo;</source>
          <target state="translated">根据HP-UX 10链接器有时的要求，生成3指令加载并存储序列。这等效于&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="b384dbdcdcc6be12f32b73f9469c3ba6b9f1dccf" translate="yes" xml:space="preserve">
          <source>Generate 32x16-bit multiply and multiply-accumulate instructions.</source>
          <target state="translated">生成32x16位乘法和乘法累加指令。</target>
        </trans-unit>
        <trans-unit id="0ccaaa46afb8881f4f3a477c92bc05eae68e0c4a" translate="yes" xml:space="preserve">
          <source>Generate &lt;code&gt;.debug_pubnames&lt;/code&gt; and &lt;code&gt;.debug_pubtypes&lt;/code&gt; sections in a format suitable for conversion into a GDB index. This option is only useful with a linker that can produce GDB index version 7.</source>
          <target state="translated">以适合于转换为GDB索引的格式生成 &lt;code&gt;.debug_pubnames&lt;/code&gt; 和 &lt;code&gt;.debug_pubtypes&lt;/code&gt; 部分。该选项仅对可生成GDB索引版本7的链接器有用。</target>
        </trans-unit>
        <trans-unit id="828612c6e2cc35cf1bee3972f49446cb2047aba1" translate="yes" xml:space="preserve">
          <source>Generate &lt;code&gt;mul64&lt;/code&gt; and &lt;code&gt;mulu64&lt;/code&gt; instructions. Only valid for</source>
          <target state="translated">生成 &lt;code&gt;mul64&lt;/code&gt; 和 &lt;code&gt;mulu64&lt;/code&gt; 指令。仅对</target>
        </trans-unit>
        <trans-unit id="f37d583fd1aea916d55ab9e91fa3002c399aaf84" translate="yes" xml:space="preserve">
          <source>Generate &lt;code&gt;norm&lt;/code&gt; instructions. This is the default if</source>
          <target state="translated">生成 &lt;code&gt;norm&lt;/code&gt; 说明。这是默认设置，如果</target>
        </trans-unit>
        <trans-unit id="2934019de0c741342611be8077a1571f0c44928a" translate="yes" xml:space="preserve">
          <source>Generate &lt;code&gt;swap&lt;/code&gt; instructions.</source>
          <target state="translated">生成 &lt;code&gt;swap&lt;/code&gt; 指令。</target>
        </trans-unit>
        <trans-unit id="586858db58f3f2f4e0ba5be27cc76fd1d37e386f" translate="yes" xml:space="preserve">
          <source>Generate &lt;var&gt;N&lt;/var&gt; NOPs right at the beginning of each function, with the function entry point before the &lt;var&gt;M&lt;/var&gt;th NOP. If &lt;var&gt;M&lt;/var&gt; is omitted, it defaults to &lt;code&gt;0&lt;/code&gt; so the function entry points to the address just at the first NOP. The NOP instructions reserve extra space which can be used to patch in any desired instrumentation at run time, provided that the code segment is writable. The amount of space is controllable indirectly via the number of NOPs; the NOP instruction used corresponds to the instruction emitted by the internal GCC back-end interface &lt;code&gt;gen_nop&lt;/code&gt;. This behavior is target-specific and may also depend on the architecture variant and/or other compilation options.</source>
          <target state="translated">在每个函数的开头立即生成 &lt;var&gt;N&lt;/var&gt; 个 NOP，函数入口点位于第 &lt;var&gt;M&lt;/var&gt; 个NOP 之前。如果省略 &lt;var&gt;M&lt;/var&gt; ，则默认为 &lt;code&gt;0&lt;/code&gt; ,因此函数条目指向第一个NOP处的地址。 NOP指令保留了额外的空间，只要代码段可写，就可以在运行时修补任何所需的仪器。空间的数量可以通过NOP的数量间接控制；使用的NOP指令对应于内部GCC后端接口 &lt;code&gt;gen_nop&lt;/code&gt; 发出的指令。此行为是特定于目标的，并且还可能取决于体系结构变体和/或其他编译选项。</target>
        </trans-unit>
        <trans-unit id="b56d0340e46553074756e8938fdcc9bc10345ee9" translate="yes" xml:space="preserve">
          <source>Generate C header describing the largest structure that is passed by value, if any.</source>
          <target state="translated">生成描述最大结构的C头,如果有的话,通过值传递。</target>
        </trans-unit>
        <trans-unit id="497d1946c219789282a881eeb57aa9b71f210579" translate="yes" xml:space="preserve">
          <source>Generate DWARF &lt;code&gt;.debug_pubnames&lt;/code&gt; and &lt;code&gt;.debug_pubtypes&lt;/code&gt; sections.</source>
          <target state="translated">生成DWARF &lt;code&gt;.debug_pubnames&lt;/code&gt; 和 &lt;code&gt;.debug_pubtypes&lt;/code&gt; 部分。</target>
        </trans-unit>
        <trans-unit id="2f0d6b717c142d078ddbdb831a6e380bea411850" translate="yes" xml:space="preserve">
          <source>Generate GNU/Linux compatible gUSA software atomic sequences for the atomic built-in functions. The generated atomic sequences require additional support from the interrupt/exception handling code of the system and are only suitable for SH3* and SH4* single-core systems. This option is enabled by default when the target is &lt;code&gt;sh*-*-linux*&lt;/code&gt; and SH3* or SH4*. When the target is SH4A, this option also partially utilizes the hardware atomic instructions &lt;code&gt;movli.l&lt;/code&gt; and &lt;code&gt;movco.l&lt;/code&gt; to create more efficient code, unless &amp;lsquo;</source>
          <target state="translated">为原子内置函数生成GNU / Linux兼容的gUSA软件原子序列。生成的原子序列需要系统的中断/异常处理代码的额外支持，并且仅适用于SH3 *和SH4 *单核系统。当目标是 &lt;code&gt;sh*-*-linux*&lt;/code&gt; 和SH3 *或SH4 * 时，默认情况下启用此选项。当目标是SH4A时，该选项还部分利用硬件原子指令 &lt;code&gt;movli.l&lt;/code&gt; 和 &lt;code&gt;movco.l&lt;/code&gt; 来创建更有效的代码，除非&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="bf2d938e1c1ea97f318900579ce3c50a9ae898af" translate="yes" xml:space="preserve">
          <source>Generate GP-relative accesses for all data objects in the program. If you use this option, the entire data and BSS segments of your program must fit in 64K of memory and you must use an appropriate linker script to allocate them within the addressable range of the global pointer.</source>
          <target state="translated">为程序中的所有数据对象生成GP相关访问。如果你使用这个选项,你的程序中的整个数据和BSS段必须适合64K的内存,你必须使用适当的链接器脚本在全局指针的可寻址范围内分配它们。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
