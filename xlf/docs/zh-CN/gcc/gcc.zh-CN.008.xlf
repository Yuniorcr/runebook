<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="gcc">
    <body>
      <group id="gcc">
        <trans-unit id="2f76b920d411b7e136fa4f9061e5e0a37ad6c0c4" translate="yes" xml:space="preserve">
          <source>For example, since the declaration of the primary function template below makes use of both attribute &lt;code&gt;malloc&lt;/code&gt; and &lt;code&gt;alloc_size&lt;/code&gt; the declaration of the explicit specialization of the template is diagnosed because it is missing one of the attributes.</source>
          <target state="translated">例如，由于下面的主要功能模板的声明同时使用了属性 &lt;code&gt;malloc&lt;/code&gt; 和 &lt;code&gt;alloc_size&lt;/code&gt; ，因此可以诊断模板的显式特化的声明，因为它缺少属性之一。</target>
        </trans-unit>
        <trans-unit id="c1b19cb164dc1a4ab8a759ac490b8fde220e9c5e" translate="yes" xml:space="preserve">
          <source>For example, suppose &lt;code&gt;struct A&lt;/code&gt; below is defined in some third party library header to have the alignment requirement &lt;code&gt;N&lt;/code&gt; and to force a warning whenever a variable of the type is not so aligned due to attribute &lt;code&gt;packed&lt;/code&gt;. Specifying the &lt;code&gt;copy&lt;/code&gt; attribute on the definition on the unrelated &lt;code&gt;struct B&lt;/code&gt; has the effect of copying all relevant attributes from the type referenced by the pointer expression to &lt;code&gt;struct B&lt;/code&gt;.</source>
          <target state="translated">例如，假设下面的 &lt;code&gt;struct A&lt;/code&gt; 在某个第三方库标头中定义为具有对齐要求 &lt;code&gt;N&lt;/code&gt; ,并在由于属性 &lt;code&gt;packed&lt;/code&gt; 而导致类型变量未如此对齐时强制发出警告。在不相关的 &lt;code&gt;struct B&lt;/code&gt; 的定义上指定 &lt;code&gt;copy&lt;/code&gt; 属性具有将所有相关属性从指针表达式引用的类型复制到 &lt;code&gt;struct B&lt;/code&gt; 的作用。</target>
        </trans-unit>
        <trans-unit id="f0be048f3761817dd96f745d3c57100422574646" translate="yes" xml:space="preserve">
          <source>For example, the &lt;code&gt;sprintf&lt;/code&gt; function on SunOS 4.1.3 returns &lt;code&gt;char *&lt;/code&gt; while the C standard says that &lt;code&gt;sprintf&lt;/code&gt; returns an &lt;code&gt;int&lt;/code&gt;. The &lt;code&gt;fixincludes&lt;/code&gt; program could make the prototype for this function match the Standard, but that would be wrong, since the function will still return &lt;code&gt;char *&lt;/code&gt;.</source>
          <target state="translated">例如，SunOS 4.1.3上的 &lt;code&gt;sprintf&lt;/code&gt; 函数返回 &lt;code&gt;char *&lt;/code&gt; ,而C标准表示 &lt;code&gt;sprintf&lt;/code&gt; 返回 &lt;code&gt;int&lt;/code&gt; 。该 &lt;code&gt;fixincludes&lt;/code&gt; 程序可以使原型这一功能相匹配的标准，但这是错误的，因为该功能也会返回 &lt;code&gt;char *&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bd82a792fa22143d94897d2b758fc399175bbe0e" translate="yes" xml:space="preserve">
          <source>For example, the &lt;var&gt;StrongAlias&lt;/var&gt; macro below makes use of the &lt;code&gt;alias&lt;/code&gt; and &lt;code&gt;copy&lt;/code&gt; attributes to define an alias named &lt;var&gt;alloc&lt;/var&gt; for function &lt;var&gt;allocate&lt;/var&gt; declared with attributes &lt;var&gt;alloc_size&lt;/var&gt;, &lt;var&gt;malloc&lt;/var&gt;, and &lt;var&gt;nothrow&lt;/var&gt;. Thanks to the &lt;code&gt;__typeof__&lt;/code&gt; operator the alias has the same type as the target function. As a result of the &lt;code&gt;copy&lt;/code&gt; attribute the alias also shares the same attributes as the target.</source>
          <target state="translated">例如， &lt;var&gt;StrongAlias&lt;/var&gt; 宏观下方品牌使用的 &lt;code&gt;alias&lt;/code&gt; 和 &lt;code&gt;copy&lt;/code&gt; 属性来定义命名的别名 &lt;var&gt;alloc&lt;/var&gt; 的功能 &lt;var&gt;allocate&lt;/var&gt; 与属性声明 &lt;var&gt;alloc_size&lt;/var&gt; ， &lt;var&gt;malloc&lt;/var&gt; 的，并 &lt;var&gt;nothrow&lt;/var&gt; 。多亏了 &lt;code&gt;__typeof__&lt;/code&gt; 运算符，别名与目标函数具有相同的类型。由于 &lt;code&gt;copy&lt;/code&gt; 属性，别名也与目标共享相同的属性。</target>
        </trans-unit>
        <trans-unit id="5df659eda3281e74be2356574e1b1c1a2ec73bd0" translate="yes" xml:space="preserve">
          <source>For example, the call to &lt;code&gt;memset&lt;/code&gt; below is diagnosed by the warning because the function expects a value of type &lt;code&gt;size_t&lt;/code&gt; as its argument but the type of &lt;code&gt;32&lt;/code&gt; is &lt;code&gt;int&lt;/code&gt;. With</source>
          <target state="translated">例如，对以下 &lt;code&gt;memset&lt;/code&gt; 的调用通过警告进行诊断，因为该函数希望将 &lt;code&gt;size_t&lt;/code&gt; 类型的值作为其自变量，而类型 &lt;code&gt;32&lt;/code&gt; 是 &lt;code&gt;int&lt;/code&gt; 。用</target>
        </trans-unit>
        <trans-unit id="aa585d900b6a1decabca1b2daabff17e2775d789" translate="yes" xml:space="preserve">
          <source>For example, the compiler can only unconditionally vectorize the following loop with the pragma:</source>
          <target state="translated">例如,编译器只能用pragma无条件向量化下面的循环。</target>
        </trans-unit>
        <trans-unit id="99f069ed5ba8ea293548f32b787eaedf45bdbd11" translate="yes" xml:space="preserve">
          <source>For example, the declaration:</source>
          <target state="translated">例如,声明:</target>
        </trans-unit>
        <trans-unit id="b9ea9d42bbb55f00657375149871784a78c15592" translate="yes" xml:space="preserve">
          <source>For example, the following function allocates eight objects of &lt;code&gt;n&lt;/code&gt; bytes each on the stack, storing a pointer to each in consecutive elements of the array &lt;code&gt;a&lt;/code&gt;. It then passes the array to function &lt;code&gt;g&lt;/code&gt; which can safely use the storage pointed to by each of the array elements.</source>
          <target state="translated">例如，以下函数在堆栈上分配八个 &lt;code&gt;n&lt;/code&gt; 个字节的对象，并在数组 &lt;code&gt;a&lt;/code&gt; 的连续元素中存储指向每个对象的指针。然后，它将数组传递给函数 &lt;code&gt;g&lt;/code&gt; ，该函数可以安全地使用每个数组元素指向的存储。</target>
        </trans-unit>
        <trans-unit id="46ff8877e2ba5b3ad38e512c93a9f9393792e49a" translate="yes" xml:space="preserve">
          <source>For example, the following macro can be used to portably check, at compile-time, whether or not adding two constant integers will overflow, and perform the addition only when it is known to be safe and not to trigger a</source>
          <target state="translated">例如,可以使用下面的宏在编译时可移植地检查两个常数整数相加是否会溢出,只有在已知安全的情况下才执行加法,并且不会触发一个</target>
        </trans-unit>
        <trans-unit id="0a5e19a07f0f940d54dbc5e573ed269580925a99" translate="yes" xml:space="preserve">
          <source>For example, the following:</source>
          <target state="translated">例如,下列情况:</target>
        </trans-unit>
        <trans-unit id="f3e3332c2d5e42f3076c20bce36d2593f9127ee9" translate="yes" xml:space="preserve">
          <source>For example, the implementation of the following function &lt;code&gt;foo&lt;/code&gt;:</source>
          <target state="translated">例如，执行以下函数 &lt;code&gt;foo&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="71a4e8c7eb0a1fa15ef7a86f7ffb6699626c80d0" translate="yes" xml:space="preserve">
          <source>For example, this function has to be used in &lt;code&gt;ifunc&lt;/code&gt; resolvers that check for CPU type using the built-in functions &lt;code&gt;__builtin_cpu_is&lt;/code&gt; and &lt;code&gt;__builtin_cpu_supports&lt;/code&gt;, or in constructors on targets that don&amp;rsquo;t support constructor priority.</source>
          <target state="translated">例如，必须在使用内置函数 &lt;code&gt;__builtin_cpu_is&lt;/code&gt; 和 &lt;code&gt;__builtin_cpu_supports&lt;/code&gt; 检查CPU类型的 &lt;code&gt;ifunc&lt;/code&gt; 解析器中，或者在不支持构造函数优先级的目标上的构造函数中，使用此函数。</target>
        </trans-unit>
        <trans-unit id="1dddf36660113e27ff669ff510c160e144321d93" translate="yes" xml:space="preserve">
          <source>For example, when the compiler encounters a method invocation such as &lt;code&gt;[object init]&lt;/code&gt;, it compiles it into a call to &lt;code&gt;objc_msg_lookup (object, @selector(init))&lt;/code&gt; followed by a cast of the returned value to the appropriate function pointer type, and then it calls it.</source>
          <target state="translated">例如，当编译器遇到诸如 &lt;code&gt;[object init]&lt;/code&gt; 之类的方法调用时，它会将其编译为对 &lt;code&gt;objc_msg_lookup (object, @selector(init))&lt;/code&gt; 的调用，然后将返回值强制转换为适当的函数指针类型，并且然后它称之为。</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">例如:</target>
        </trans-unit>
        <trans-unit id="25bb7aced1792aec854f4198d7d0398ca1d4713d" translate="yes" xml:space="preserve">
          <source>For full documentation of the struct attributes please see the documentation in &lt;a href=&quot;variable-attributes#x86-Variable-Attributes&quot;&gt;x86 Variable Attributes&lt;/a&gt;.</source>
          <target state="translated">有关struct属性的完整文档，请参见&lt;a href=&quot;variable-attributes#x86-Variable-Attributes&quot;&gt;x86 Variable Attributes中&lt;/a&gt;的文档。</target>
        </trans-unit>
        <trans-unit id="3dc81c80b4604ccbc276f437a5ccc2aaa2515f6c" translate="yes" xml:space="preserve">
          <source>For indirect calls to functions and computed goto, the linker generates &lt;em&gt;stubs&lt;/em&gt;. Stubs are jump pads sometimes also called &lt;em&gt;trampolines&lt;/em&gt;. Thus, the indirect call/jump jumps to such a stub. The stub contains a direct jump to the desired address.</source>
          <target state="translated">对于函数的间接调用和计算出的goto，链接器生成&lt;em&gt;存根&lt;/em&gt;。存根是跳板，有时也称为&lt;em&gt;蹦床&lt;/em&gt;。因此，间接调用/跳转跳转到这样的存根。存根包含直接跳转到所需地址的信息。</target>
        </trans-unit>
        <trans-unit id="b91d6fa4ba31d00f68a512834bc7eb5f8c52df71" translate="yes" xml:space="preserve">
          <source>For information about the O64 ABI, see &lt;a href=&quot;http://gcc.gnu.org/projects/mipso64-abi.html&quot;&gt;http://gcc.gnu.org/projects/mipso64-abi.html&lt;/a&gt;.</source>
          <target state="translated">有关O64 ABI的信息，请参见&lt;a href=&quot;http://gcc.gnu.org/projects/mipso64-abi.html&quot;&gt;http://gcc.gnu.org/projects/mipso64-abi.html&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="56ee49f1a1b16838ed8d136422788b22655be9ea" translate="yes" xml:space="preserve">
          <source>For input files in any language, generate corresponding Go declarations in &lt;var&gt;file&lt;/var&gt;. This generates Go &lt;code&gt;const&lt;/code&gt;, &lt;code&gt;type&lt;/code&gt;, &lt;code&gt;var&lt;/code&gt;, and &lt;code&gt;func&lt;/code&gt; declarations which may be a useful way to start writing a Go interface to code written in some other language.</source>
          <target state="translated">对于任何语言的输入文件，请在 &lt;var&gt;file&lt;/var&gt; 中生成相应的Go声明。这会生成Go &lt;code&gt;const&lt;/code&gt; ， &lt;code&gt;type&lt;/code&gt; ， &lt;code&gt;var&lt;/code&gt; 和 &lt;code&gt;func&lt;/code&gt; 声明，这可能是开始编写Go接口​​以使用其他语言编写的代码的有用方法。</target>
        </trans-unit>
        <trans-unit id="c8ce6c094048677a9f8423fec4581d4ef1bd1e5b" translate="yes" xml:space="preserve">
          <source>For instance</source>
          <target state="translated">比如说</target>
        </trans-unit>
        <trans-unit id="23b7041567e33cbc564ac905e83c0e92b5fee08b" translate="yes" xml:space="preserve">
          <source>For instance,</source>
          <target state="translated">例如:</target>
        </trans-unit>
        <trans-unit id="a8e07e43db118dd56bbb97b1f96ccc89bac7f5fd" translate="yes" xml:space="preserve">
          <source>For instance, if the stack starts at absolute address &amp;lsquo;</source>
          <target state="translated">例如，如果堆栈从绝对地址'开始</target>
        </trans-unit>
        <trans-unit id="6abfd7e7f05346e1123b7bf2021cc93c61b8fbd5" translate="yes" xml:space="preserve">
          <source>For instance, if you have &lt;code&gt;#include &quot;all.h&quot;&lt;/code&gt;, and you have</source>
          <target state="translated">例如，如果您具有 &lt;code&gt;#include &quot;all.h&quot;&lt;/code&gt; ，并且您具有</target>
        </trans-unit>
        <trans-unit id="5b9b6fe2256c52fcd89c847ec80034c7cbe3d49d" translate="yes" xml:space="preserve">
          <source>For instance, on an x86, you could compile a function with &lt;code&gt;target_clones(&quot;sse4.1,avx&quot;)&lt;/code&gt;. GCC creates two function clones, one compiled with</source>
          <target state="translated">例如，在x86上，您可以使用 &lt;code&gt;target_clones(&quot;sse4.1,avx&quot;)&lt;/code&gt; 编译函数。GCC创建了两个函数克隆，其中一个用</target>
        </trans-unit>
        <trans-unit id="175bbce2fc22d4ed1ec7614154a0e449231ccaf1" translate="yes" xml:space="preserve">
          <source>For instance, on an x86, you could declare one function with the &lt;code&gt;target(&quot;sse4.1,arch=core2&quot;)&lt;/code&gt; attribute and another with &lt;code&gt;target(&quot;sse4a,arch=amdfam10&quot;)&lt;/code&gt;. This is equivalent to compiling the first function with</source>
          <target state="translated">例如，在x86上，您可以使用 &lt;code&gt;target(&quot;sse4.1,arch=core2&quot;)&lt;/code&gt; 属性声明一个函数，并使用 &lt;code&gt;target(&quot;sse4a,arch=amdfam10&quot;)&lt;/code&gt; 属性声明另一个函数。这等效于使用</target>
        </trans-unit>
        <trans-unit id="60600b26a9fa03b6c3650e82a7d4514147301ef9" translate="yes" xml:space="preserve">
          <source>For instance, on the SB-1, if FP exceptions are disabled, and we are emitting 64-bit code, then we can use both FP pipes. Otherwise, we can only use one FP pipe.</source>
          <target state="translated">例如,在SB-1上,如果FP异常被禁用,并且我们要发射64位代码,那么我们可以使用两个FP管道。否则,我们只能使用一个FP管道。</target>
        </trans-unit>
        <trans-unit id="4d64dcd6f25c2f8e61dbb8fbe7c56bdb2499ab6d" translate="yes" xml:space="preserve">
          <source>For instance, the following declarations</source>
          <target state="translated">例如,以下声明</target>
        </trans-unit>
        <trans-unit id="fd17d596f35be2211443642e76ceab4e5f526b5c" translate="yes" xml:space="preserve">
          <source>For internal names, all characters are significant. For external names, the number of significant characters are defined by the linker; for almost all targets, all characters are significant.</source>
          <target state="translated">对于内部名称,所有的字符都是重要的。对于外部名称,重要字符的数量由链接器定义;对于几乎所有目标,所有字符都是重要的。</target>
        </trans-unit>
        <trans-unit id="9f99386843936f29083f4368b21c1771def8a251" translate="yes" xml:space="preserve">
          <source>For library code, if you want the library to provide all of the template instantiations it needs, just try to link all of its object files together; the link will fail, but cause the instantiations to be generated as a side effect. Be warned, however, that this may cause conflicts if multiple libraries try to provide the same instantiations. For greater control, use explicit instantiation as described in the next option.</source>
          <target state="translated">对于库代码,如果你想让库提供它所需要的所有模板实例,只需尝试将其所有的对象文件链接在一起;链接会失败,但会导致实例生成的副作用。但要注意,如果多个库试图提供相同的实例,这可能会引起冲突。为了获得更大的控制权,请使用下一个选项中描述的显式实例化。</target>
        </trans-unit>
        <trans-unit id="275df5c8ab338eac0891dfd5fcb7ca333c414d1c" translate="yes" xml:space="preserve">
          <source>For machines that must pop arguments after a function call, always pop the arguments as soon as each function returns. At levels</source>
          <target state="translated">对于必须在函数调用后弹出参数的机器,总是在每个函数返回时立即弹出参数。在级别</target>
        </trans-unit>
        <trans-unit id="4ab62f1721d989066bd88fccf2cddf5cca6c289c" translate="yes" xml:space="preserve">
          <source>For more information concerning the history of Objective-C that is available online, see &lt;a href=&quot;http://gcc.gnu.org/readings.html&quot;&gt;http://gcc.gnu.org/readings.html&lt;/a&gt;</source>
          <target state="translated">有关可在线获得的有关Objective-C历史的更多信息，请参见&lt;a href=&quot;http://gcc.gnu.org/readings.html&quot;&gt;http://gcc.gnu.org/readings.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="445882425cb6a5526123dcb90201317cd797b812" translate="yes" xml:space="preserve">
          <source>For more information on GCC&amp;rsquo;s support for transactional memory, See &lt;a href=&quot;https://gcc.gnu.org/onlinedocs/gcc-9.2.0/libitm/Enabling-libitm.html#Enabling-libitm&quot;&gt;The GNU Transactional Memory Library&lt;/a&gt; in GNU Transactional Memory Library.</source>
          <target state="translated">有关GCC对事务内存的支持的更多信息，请参见&lt;a href=&quot;https://gcc.gnu.org/onlinedocs/gcc-9.2.0/libitm/Enabling-libitm.html#Enabling-libitm&quot;&gt;GNU事务内存库&lt;/a&gt;中的GNU事务内存库。</target>
        </trans-unit>
        <trans-unit id="530d01e06da63e3ae60755b1d0e0664f37ce4c56" translate="yes" xml:space="preserve">
          <source>For profile-directed optimizations, compile the source files again with the same optimization and code generation options plus</source>
          <target state="translated">对于配置文件导向的优化,使用相同的优化和代码生成选项再编译一次源文件,加上</target>
        </trans-unit>
        <trans-unit id="1552bee1f905030b453e9bc73123ec457682d5d2" translate="yes" xml:space="preserve">
          <source>For references to Technical Corrigenda, Rationale documents and information concerning the history of C that is available online, see &lt;a href=&quot;http://gcc.gnu.org/readings.html&quot;&gt;http://gcc.gnu.org/readings.html&lt;/a&gt;</source>
          <target state="translated">有关可在线获取的有关技术勘误，基本原理文件和有关C历史的信息的参考，请参见&lt;a href=&quot;http://gcc.gnu.org/readings.html&quot;&gt;http://gcc.gnu.org/readings.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="98fa91b9c573243f46d98173cb5c6bc69a14f37e" translate="yes" xml:space="preserve">
          <source>For run-time identification, the starting addresses of these areas, which correspond to their respective function entries minus &lt;var&gt;M&lt;/var&gt;, are additionally collected in the &lt;code&gt;__patchable_function_entries&lt;/code&gt; section of the resulting binary.</source>
          <target state="translated">为了进行运行时识别，这些区域的起始地址（对应于它们各自的功能条目 &lt;var&gt;M&lt;/var&gt; ）将另外收集在生成的二进制文件的 &lt;code&gt;__patchable_function_entries&lt;/code&gt; 部分中。</target>
        </trans-unit>
        <trans-unit id="ee4662af110f3d316db91e4c9bf088b26f37f6fc" translate="yes" xml:space="preserve">
          <source>For single-precision floating-point comparisons, emit an &lt;code&gt;fsub&lt;/code&gt; instruction and test the flags. This is faster than a software comparison, but can get incorrect results in the presence of NaNs, or when two different small numbers are compared such that their difference is calculated as zero. The default is</source>
          <target state="translated">对于单精度浮点比较，发出 &lt;code&gt;fsub&lt;/code&gt; 指令并测试标志。这比软件比较快，但是在存在NaN时，或者在比较两个不同的小数以至于将它们的差计算为零时，可能会得到不正确的结果。默认是</target>
        </trans-unit>
        <trans-unit id="629fb7062147649cb1707cc8cbe18549c87c4fce" translate="yes" xml:space="preserve">
          <source>For some target machines, GCC supports additional options to the format attribute (see &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;Declaring Attributes of Functions&lt;/a&gt;).</source>
          <target state="translated">对于某些目标计算机，GCC支持format属性的其他选项（请参阅&lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;声明函数的属性&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="8f693ccd95fd0352057c89a84d6dca28111b1d8d" translate="yes" xml:space="preserve">
          <source>For some targets, a suffix is added to the root directory specified with</source>
          <target state="translated">对于某些目标,后缀会被添加到以</target>
        </trans-unit>
        <trans-unit id="1eef11d2e0af6679534eba00e39380a79330c652" translate="yes" xml:space="preserve">
          <source>For string operations of unknown size, use run-time checks with inline code for small blocks and a library call for large blocks.</source>
          <target state="translated">对于未知大小的字符串操作,使用运行时检查,小块用内联代码,大块用库调用。</target>
        </trans-unit>
        <trans-unit id="c54c726dd72dd80b773414b86e870a30d193ec02" translate="yes" xml:space="preserve">
          <source>For systems that use the GNU C Library, the default is on.</source>
          <target state="translated">对于使用GNU C库的系统,默认为开启。</target>
        </trans-unit>
        <trans-unit id="90889da6f3749d2d8e7f525edbcff60563fc34f5" translate="yes" xml:space="preserve">
          <source>For targets that do not support either COMDAT or weak symbols, most entities with vague linkage are emitted as local symbols to avoid duplicate definition errors from the linker. This does not happen for local statics in inlines, however, as having multiple copies almost certainly breaks things.</source>
          <target state="translated">对于既不支持COMDAT也不支持弱符号的目标,大多数具有模糊链接的实体都会以本地符号的形式发出,以避免链接器的重复定义错误。然而,这不会发生在inline中的本地静态,因为有多个副本几乎肯定会破坏事情。</target>
        </trans-unit>
        <trans-unit id="db393fbd5a98ab60023bfd22b5dbbadca9023150" translate="yes" xml:space="preserve">
          <source>For targets that normally need trampolines for nested functions, always generate them instead of using descriptors. Otherwise, for targets that do not need them, like for example HP-PA or IA-64, do nothing.</source>
          <target state="translated">对于那些通常需要使用嵌套函数的目标,总是生成它们而不是使用描述符。否则,对于不需要它们的目标,如HP-PA或IA-64,什么也不做。</target>
        </trans-unit>
        <trans-unit id="3a882a0a0f801f0c1cb983c784834a8c5870b59e" translate="yes" xml:space="preserve">
          <source>For targets, like GNU/Linux, where all user-mode Xtensa code must be position-independent code (PIC), this option disables PIC for compiling kernel code.</source>
          <target state="translated">对于像GNU/Linux这样的目标,所有用户模式的Xtensa代码都必须是独立于位置的代码(PIC),这个选项禁用PIC来编译内核代码。</target>
        </trans-unit>
        <trans-unit id="8b8c7be3bb5a9384ba78f18abd2ee5fc45978a5a" translate="yes" xml:space="preserve">
          <source>For test coverage analysis, use &lt;code&gt;gcov&lt;/code&gt; to produce human readable information from the</source>
          <target state="translated">为了进行测试覆盖率分析，请使用 &lt;code&gt;gcov&lt;/code&gt; 从</target>
        </trans-unit>
        <trans-unit id="cdf3f70fc86ab5862691992f6df51e7ca5f5489e" translate="yes" xml:space="preserve">
          <source>For the NeXT runtime with version 2 of the ABI, check for a nil receiver in method invocations before doing the actual method call. This is the default and can be disabled using</source>
          <target state="translated">对于使用ABI版本2的NeXT运行时,在进行实际的方法调用之前,检查方法调用中的nil接收器。这是默认的,可以使用</target>
        </trans-unit>
        <trans-unit id="96b6c6242e369e6ead381c1d4d982f9072cadf3b" translate="yes" xml:space="preserve">
          <source>For the named functions, the compiler adds code to disable interrupts for the duration of those functions. If any functions so named are not encountered in the source, a warning is emitted that the pragma is not used. Examples:</source>
          <target state="translated">对于被命名的函数,编译器会在这些函数的持续时间内添加代码来禁用中断。如果在源码中没有遇到任何这样命名的函数,则会发出一个警告,说明没有使用这个pragma。例子</target>
        </trans-unit>
        <trans-unit id="b4ae72d8349f09925e7db4912a4034594f70873f" translate="yes" xml:space="preserve">
          <source>For the named functions, the compiler always uses a register-indirect call model when calling the named functions. Examples:</source>
          <target state="translated">对于命名函数,编译器在调用命名函数时,总是采用寄存器直接调用的模式。例如:</target>
        </trans-unit>
        <trans-unit id="0f569d15217aa1a086b40826e8ecc6305b091d9b" translate="yes" xml:space="preserve">
          <source>For the purposes of branch prediction optimizations, the probability that a &lt;code&gt;__builtin_expect&lt;/code&gt; expression is &lt;code&gt;true&lt;/code&gt; is controlled by GCC&amp;rsquo;s &lt;code&gt;builtin-expect-probability&lt;/code&gt; parameter, which defaults to 90%. You can also use &lt;code&gt;__builtin_expect_with_probability&lt;/code&gt; to explicitly assign a probability value to individual expressions.</source>
          <target state="translated">出于分支预测优化的目的， &lt;code&gt;__builtin_expect&lt;/code&gt; 表达式为 &lt;code&gt;true&lt;/code&gt; 的概率由GCC的 &lt;code&gt;builtin-expect-probability&lt;/code&gt; 参数控制，该参数默认为90％。您还可以使用 &lt;code&gt;__builtin_expect_with_probability&lt;/code&gt; 显式地将概率值分配给各个表达式。</target>
        </trans-unit>
        <trans-unit id="bf219c0d4bab1b7372e20c5005cc97b0b9e1bb77" translate="yes" xml:space="preserve">
          <source>For the quote form of the include directive, the directories specified by</source>
          <target state="translated">对于include指令的引用形式,由</target>
        </trans-unit>
        <trans-unit id="754ebda73d52810694ef0086a8c959916039f5fd" translate="yes" xml:space="preserve">
          <source>For the quote form of the include directive, the directory of the current file is searched first.</source>
          <target state="translated">对于引用形式的include指令,会先搜索当前文件的目录。</target>
        </trans-unit>
        <trans-unit id="1d70b004544bcb6341f32cbd058f337db34bac6c" translate="yes" xml:space="preserve">
          <source>For the x86-32 compiler, you must use</source>
          <target state="translated">对于x86-32编译器,你必须使用</target>
        </trans-unit>
        <trans-unit id="9e1a32426c586349d0aa1e4bc4474f828e773b55" translate="yes" xml:space="preserve">
          <source>For those adding visibility support to existing code, you may find &lt;code&gt;#pragma GCC visibility&lt;/code&gt; of use. This works by you enclosing the declarations you wish to set visibility for with (for example) &lt;code&gt;#pragma GCC visibility push(hidden)&lt;/code&gt; and &lt;code&gt;#pragma GCC visibility pop&lt;/code&gt;. Bear in mind that symbol visibility should be viewed &lt;strong&gt;as part of the API interface contract&lt;/strong&gt; and thus all new code should always specify visibility when it is not the default; i.e., declarations only for use within the local DSO should &lt;strong&gt;always&lt;/strong&gt; be marked explicitly as hidden as so to avoid PLT indirection overheads&amp;mdash;making this abundantly clear also aids readability and self-documentation of the code. Note that due to ISO C++ specification requirements, &lt;code&gt;operator new&lt;/code&gt; and &lt;code&gt;operator delete&lt;/code&gt; must always be of default visibility.</source>
          <target state="translated">对于为现有代码添加可见性支持的用户，您可能会发现 &lt;code&gt;#pragma GCC visibility&lt;/code&gt; 使用的可见性。您可以使用 &lt;code&gt;#pragma GCC visibility push(hidden)&lt;/code&gt; 和 &lt;code&gt;#pragma GCC visibility pop&lt;/code&gt; 来封闭希望为其设置可见性的声明。请记住，应将符号可见性视为&lt;strong&gt;API接口协定的一部分，&lt;/strong&gt;因此，所有新代码在不是默认值时都应始终指定可见性；即，仅在本地DSO中使用的声明应&lt;strong&gt;始终&lt;/strong&gt;被显式标记为隐藏，以免发生PLT间接开销-使其充分清楚也有助于代码的可读性和自说明性。请注意，由于ISO C ++规范要求， &lt;code&gt;operator new&lt;/code&gt; &lt;code&gt;operator delete&lt;/code&gt; 符和操作符删除必须始终具有默认可见性。</target>
        </trans-unit>
        <trans-unit id="bb6de8937de1ff830849ca65a0b4291fa1ceadf7" translate="yes" xml:space="preserve">
          <source>Force (do not force) generated code to have a single exit point in each function.</source>
          <target state="translated">强制(不强制)生成的代码在每个函数中只有一个退出点。</target>
        </trans-unit>
        <trans-unit id="acd5ffdf657527d019579abefcb2cc6ad1c27289" translate="yes" xml:space="preserve">
          <source>Force (do not force) the use of &lt;code&gt;memcpy&lt;/code&gt; for non-trivial block moves. The default is</source>
          <target state="translated">对非平凡的块移动强制（不强制）使用 &lt;code&gt;memcpy&lt;/code&gt; 。默认是</target>
        </trans-unit>
        <trans-unit id="f35628fb15f3c423c03af2c93b844cb43e594383" translate="yes" xml:space="preserve">
          <source>Force &lt;code&gt;long&lt;/code&gt; types to be 64 bits wide. See</source>
          <target state="translated">强制将 &lt;code&gt;long&lt;/code&gt; 类型设置为64位宽。看到</target>
        </trans-unit>
        <trans-unit id="df341c9e8e9829ab23b420935fbc32e82bb7a353" translate="yes" xml:space="preserve">
          <source>Force &lt;code&gt;long&lt;/code&gt;, &lt;code&gt;int&lt;/code&gt;, and pointer types to be 32 bits wide.</source>
          <target state="translated">强制 &lt;code&gt;long&lt;/code&gt; ， &lt;code&gt;int&lt;/code&gt; 和指针类型为32位宽。</target>
        </trans-unit>
        <trans-unit id="a65d4b81903833686ba857ca6166053cb9c8d543" translate="yes" xml:space="preserve">
          <source>Force GCC to assign view numbers internally, if</source>
          <target state="translated">强制GCC在内部分配视图编号,如果...。</target>
        </trans-unit>
        <trans-unit id="5c6c2109c0abfbfad2c57ae80b233af1137f54d6" translate="yes" xml:space="preserve">
          <source>Force GCC to generate DWARF2+ line number tables internally, if DWARF2+ line number tables are to be generated.</source>
          <target state="translated">如果要生成DWARF2+行号表,强制GCC在内部生成DWARF2+行号表。</target>
        </trans-unit>
        <trans-unit id="e05ff97a2114aff3fe8702e99f968b0b9b270faf" translate="yes" xml:space="preserve">
          <source>Force all calls to functions to be indirect. This is useful when using Intel Processor Trace where it generates more precise timing information for function calls.</source>
          <target state="translated">强制所有对函数的调用都是间接的。这在使用英特尔处理器跟踪时非常有用,因为它会为函数调用生成更精确的时序信息。</target>
        </trans-unit>
        <trans-unit id="c6aa1876252f253f5c49c98017976af7ef3a9f80" translate="yes" xml:space="preserve">
          <source>Force all functions to be aligned to a 4-byte boundary.</source>
          <target state="translated">强制所有函数对齐到4字节的边界。</target>
        </trans-unit>
        <trans-unit id="5376700e1a5ed02b4facb60bd51b070a514bbd9d" translate="yes" xml:space="preserve">
          <source>Force all load and store instructions to always bypass cache by using I/O variants of the instructions. The default is not to bypass the cache.</source>
          <target state="translated">通过使用指令的I/O变体,强制所有加载和存储指令始终绕过缓存。默认情况是不绕过缓存。</target>
        </trans-unit>
        <trans-unit id="6ba14189273ea29b59425c68e227901a2b9a86ef" translate="yes" xml:space="preserve">
          <source>Force assembly output to always use hex constants. Normally such constants are signed decimals, but this option is available for testsuite and/or aesthetic purposes.</source>
          <target state="translated">强制装配体输出始终使用十六进制常量。通常这种常数是有符号的小数,但这个选项可以用于testuite和/或美学目的。</target>
        </trans-unit>
        <trans-unit id="a09ed1d5a3164af1580e37f843c9d03a7f3d9584" translate="yes" xml:space="preserve">
          <source>Force code generation in the ARM (A32) ISA.</source>
          <target state="translated">在ARM (A32)ISA中强制生成代码。</target>
        </trans-unit>
        <trans-unit id="8cf31b1c6efcebcf276d6ea54117f6f86a1ab3b3" translate="yes" xml:space="preserve">
          <source>Force code generation in the Thumb (T16/T32) ISA, depending on the architecture level.</source>
          <target state="translated">在拇指(T16/T32)ISA中强制生成代码,取决于架构级别。</target>
        </trans-unit>
        <trans-unit id="57fc3d2f95e9a264681cfb6c086d3f11381e6d22" translate="yes" xml:space="preserve">
          <source>Force indirect call and jump via register.</source>
          <target state="translated">通过寄存器强制间接调用和跳转。</target>
        </trans-unit>
        <trans-unit id="c2234a2c2c6fa572bb9aaff40c528a12cc4c9fff" translate="yes" xml:space="preserve">
          <source>Force the usage of delay slots for conditional branches, which stuffs the delay slot with a &lt;code&gt;nop&lt;/code&gt; if a suitable instruction cannot be found. By default this option is disabled. It can be enabled to work around hardware bugs as found in the original SH7055.</source>
          <target state="translated">强制使用条件分支的延迟槽，如果找不到合适的指令，则将延迟槽塞入 &lt;code&gt;nop&lt;/code&gt; 。默认情况下，此选项是禁用的。可以启用它来解决原始SH7055中发现的硬件错误。</target>
        </trans-unit>
        <trans-unit id="accd79a6ab2ab26b14a5acf0e4624a9287eb4f98" translate="yes" xml:space="preserve">
          <source>Force to call a function using jli_s instruction. This option is valid only for ARCv2 architecture.</source>
          <target state="translated">强制使用jli_s指令调用函数。这个选项只对ARCv2架构有效。</target>
        </trans-unit>
        <trans-unit id="bda8d8b269a45b97f862176d65bac6c1e4f4afe4" translate="yes" xml:space="preserve">
          <source>Forces a particular function to be called using &lt;code&gt;jli&lt;/code&gt; instruction. The &lt;code&gt;jli&lt;/code&gt; instruction makes use of a table stored into &lt;code&gt;.jlitab&lt;/code&gt; section, which holds the location of the functions which are addressed using this instruction.</source>
          <target state="translated">强制使用 &lt;code&gt;jli&lt;/code&gt; 指令调用特定功能。所述 &lt;code&gt;jli&lt;/code&gt; 指令利用存储到一个表中的 &lt;code&gt;.jlitab&lt;/code&gt; 部，其保持的哪个正在使用该指令处理的功能的位置。</target>
        </trans-unit>
        <trans-unit id="2f084ee73c513d8f966bbd0c40980e7ab5210b2e" translate="yes" xml:space="preserve">
          <source>Formal syntax for attributes.</source>
          <target state="translated">属性的正式语法。</target>
        </trans-unit>
        <trans-unit id="6e97cc41857aff390c1d1352f1580ff15ac71869" translate="yes" xml:space="preserve">
          <source>Format checks specific to particular targets.</source>
          <target state="translated">特定目标的格式检查。</target>
        </trans-unit>
        <trans-unit id="c4653752f8662d9cf50820b53f4f92b88244d0b2" translate="yes" xml:space="preserve">
          <source>Formerly the &lt;code&gt;hi&lt;/code&gt; register. This constraint is no longer supported.</source>
          <target state="translated">以前是 &lt;code&gt;hi&lt;/code&gt; 寄存器。不再支持此约束。</target>
        </trans-unit>
        <trans-unit id="fb001b2c292ad2f619c8caf6e0ac8afd191aaa76" translate="yes" xml:space="preserve">
          <source>Framework</source>
          <target state="translated">Framework</target>
        </trans-unit>
        <trans-unit id="af39dd055c3ef8226fbe929d048cafb094dc8a51" translate="yes" xml:space="preserve">
          <source>Frameworks</source>
          <target state="translated">Frameworks</target>
        </trans-unit>
        <trans-unit id="a4a10834211c2c0fbcb7eeb4d7d706ce399ad1a9" translate="yes" xml:space="preserve">
          <source>Free form Fortran source code that must be preprocessed (with the traditional preprocessor).</source>
          <target state="translated">自由形式的Fortran源代码,必须进行预处理(用传统的预处理器)。</target>
        </trans-unit>
        <trans-unit id="ab1de10d533c059aa65605ce6bb4a93b10329a51" translate="yes" xml:space="preserve">
          <source>Free form Fortran source code that should not be preprocessed.</source>
          <target state="translated">自由形式的Fortran源代码,不应进行预处理。</target>
        </trans-unit>
        <trans-unit id="5888490bf4ce1fb3617e200efdb6835e0c4faa44" translate="yes" xml:space="preserve">
          <source>Function attributes are introduced by the &lt;code&gt;__attribute__&lt;/code&gt; keyword in the declaration of a function, followed by an attribute specification enclosed in double parentheses. You can specify multiple attributes in a declaration by separating them by commas within the double parentheses or by immediately following one attribute specification with another. See &lt;a href=&quot;attribute-syntax#Attribute-Syntax&quot;&gt;Attribute Syntax&lt;/a&gt;, for the exact rules on attribute syntax and placement. Compatible attribute specifications on distinct declarations of the same function are merged. An attribute specification that is not compatible with attributes already applied to a declaration of the same function is ignored with a warning.</source>
          <target state="translated">函数属性由函数声明中的 &lt;code&gt;__attribute__&lt;/code&gt; 关键字引入，后跟用双括号括起来的属性规范。您可以在声明中指定多个属性，方法是在双括号内用逗号将它们隔开，或者紧跟在一个属性说明之后。有关&lt;a href=&quot;attribute-syntax#Attribute-Syntax&quot;&gt;属性&lt;/a&gt;语法和放置的确切规则，请参见属性语法。合并了同一功能的不同声明上的兼容属性规范。与警告不兼容的属性规范与已经应用于同一函数的声明的属性不兼容。</target>
        </trans-unit>
        <trans-unit id="f93ed46e6d86f7b87373026d5e663168479db390" translate="yes" xml:space="preserve">
          <source>Function precision. The trap handler can determine the function that caused a floating-point exception.</source>
          <target state="translated">函数精度。陷阱处理程序可以确定引起浮点异常的函数。</target>
        </trans-unit>
        <trans-unit id="d3d655b1f77fc46f162e436abc252a9dc6d8148d" translate="yes" xml:space="preserve">
          <source>Function prototype</source>
          <target state="translated">函数原型</target>
        </trans-unit>
        <trans-unit id="9e039f9c7013d88c23a38a281ed14037c4166f2d" translate="yes" xml:space="preserve">
          <source>Function reordering based on profile instrumentation collects first time of execution of a function and orders these functions in ascending order.</source>
          <target state="translated">基于剖面仪的函数重排序收集函数的首次执行时间,并按升序排列这些函数。</target>
        </trans-unit>
        <trans-unit id="d33f90e4120ff23ca44b34b56f5771105ef3b24d" translate="yes" xml:space="preserve">
          <source>Functions are aligned to 16-bit boundaries.</source>
          <target state="translated">函数对准16位边界。</target>
        </trans-unit>
        <trans-unit id="34be57d225a7e4b91308288bf7b00a21a76d0703" translate="yes" xml:space="preserve">
          <source>Functions are aligned to 32-bit boundaries, unless optimizing for size.</source>
          <target state="translated">除非对大小进行优化,否则函数会按照32位边界进行对齐。</target>
        </trans-unit>
        <trans-unit id="5a29ddf72dc39612a3206ea0dfa0993bffe35aee" translate="yes" xml:space="preserve">
          <source>Functions declared with the &lt;code&gt;naked&lt;/code&gt; attribute also require basic &lt;code&gt;asm&lt;/code&gt; (see &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;Function Attributes&lt;/a&gt;).</source>
          <target state="translated">用 &lt;code&gt;naked&lt;/code&gt; 属性声明的函数也需要基本的 &lt;code&gt;asm&lt;/code&gt; （请参见&lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;函数属性&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="b405d9a1c02455968daea5fb86ad7161a05b238c" translate="yes" xml:space="preserve">
          <source>Functions from different modes can be inlined in the caller&amp;rsquo;s mode.</source>
          <target state="translated">可以在调用者的模式中内联来自不同模式的功能。</target>
        </trans-unit>
        <trans-unit id="a51173ce4592b6408dafbf5dcd763cb00409451e" translate="yes" xml:space="preserve">
          <source>Functions prologues/epilogues are expanded as calls to appropriate subroutines. Code size is smaller.</source>
          <target state="translated">函数序言/序幕被扩展为对适当子程序的调用。代码尺寸更小。</target>
        </trans-unit>
        <trans-unit id="958942a81a4fb21510019af4adcbaec4037ab18c" translate="yes" xml:space="preserve">
          <source>Functions that are normally built in but do not have semantics defined by ISO C (such as &lt;code&gt;alloca&lt;/code&gt; and &lt;code&gt;ffs&lt;/code&gt;) are not built-in functions when</source>
          <target state="translated">通常内置的但不具有ISO C定义的语义的函数（例如 &lt;code&gt;alloca&lt;/code&gt; 和 &lt;code&gt;ffs&lt;/code&gt; ）在以下情况下不是内置函数</target>
        </trans-unit>
        <trans-unit id="a77748cc250a919f08dac1cbb97eb54cbd2d36e9" translate="yes" xml:space="preserve">
          <source>Funding Free Software</source>
          <target state="translated">资助自由软件</target>
        </trans-unit>
        <trans-unit id="ad51c11605482040955d96c2db6f7d9f4eca570e" translate="yes" xml:space="preserve">
          <source>Furthermore, if the &lt;em&gt;earlyclobber&lt;/em&gt; operand is also a read/write operand, then that operand is written only after it&amp;rsquo;s used.</source>
          <target state="translated">此外，如果&lt;em&gt;earlyclobber&lt;/em&gt;操作数也是读/写操作数，则仅在使用该操作数后才写入该操作数。</target>
        </trans-unit>
        <trans-unit id="8c1a9865dc580dc97d71f0ac34525d7ff40826cf" translate="yes" xml:space="preserve">
          <source>Future versions of GCC may zero-extend, or use a target-defined &lt;code&gt;ptr_extend&lt;/code&gt; pattern. Do not rely on sign extension.</source>
          <target state="translated">GCC的未来版本可能会零扩展，或使用目标定义的 &lt;code&gt;ptr_extend&lt;/code&gt; 模式。不要依靠符号扩展。</target>
        </trans-unit>
        <trans-unit id="a36a6718f54524d846894fb04b5b885b4e43e63b" translate="yes" xml:space="preserve">
          <source>G</source>
          <target state="translated">G</target>
        </trans-unit>
        <trans-unit id="6ed55690929b9e60aff3a9282723cba6d9ce77ea" translate="yes" xml:space="preserve">
          <source>G++ allows a virtual function returning &amp;lsquo;</source>
          <target state="translated">G ++允许虚拟函数返回'</target>
        </trans-unit>
        <trans-unit id="5114ba459fc06431a44841ea4654eb2a26a6c91e" translate="yes" xml:space="preserve">
          <source>G++ allows anonymous structs and unions to have members that are not public non-static data members (i.e. fields). These extensions are deprecated.</source>
          <target state="translated">G++允许匿名结构和联合体拥有非公共非静态数据成员(即字段)。这些扩展已被废弃。</target>
        </trans-unit>
        <trans-unit id="de3e575c048ce4bfb45f20c4e2302053983a6e85" translate="yes" xml:space="preserve">
          <source>G++ allows attributes to follow a parenthesized direct initializer, e.g. &amp;lsquo;</source>
          <target state="translated">G ++允许属性遵循带括号的直接初始化程序，例如'</target>
        </trans-unit>
        <trans-unit id="4279ad338a301cce60cdfae7e5135ebd09b1878c" translate="yes" xml:space="preserve">
          <source>G++ allows floating-point literals to appear in integral constant expressions, e.g. &amp;lsquo;</source>
          <target state="translated">G ++允许浮点文字出现在整数常量表达式中，例如'</target>
        </trans-unit>
        <trans-unit id="c5b988dd39fdeb99ab7e438425f37e6884df0f08" translate="yes" xml:space="preserve">
          <source>G++ allows static data members of const floating-point type to be declared with an initializer in a class definition. The standard only allows initializers for static members of const integral types and const enumeration types so this extension has been deprecated and will be removed from a future version.</source>
          <target state="translated">G++允许在类定义中用初始化器声明const浮点类型的静态数据成员。标准只允许为const integral类型和const enumeration类型的静态成员提供初始化器,所以这个扩展已经被废弃,并将在未来的版本中删除。</target>
        </trans-unit>
        <trans-unit id="63f7f4841ad757c79aac590be15aedf6621086d6" translate="yes" xml:space="preserve">
          <source>G++ implements the &amp;ldquo;intuitive&amp;rdquo; algorithm for copy-assignment: assign all direct bases, then assign all members. In that algorithm, the virtual base subobject can be encountered more than once. In the example, copying proceeds in the following order: &amp;lsquo;</source>
          <target state="translated">G ++为复制分配实现了&amp;ldquo;直观&amp;rdquo;算法：分配所有直接碱基，然后分配所有成员。在该算法中，可以多次遇到虚拟基础子对象。在该示例中，复制按以下顺序进行：</target>
        </trans-unit>
        <trans-unit id="67e3c9106f6559177c33511b2d979e92d246d3b0" translate="yes" xml:space="preserve">
          <source>G++ implements the Borland model on targets where the linker supports it, including ELF targets (such as GNU/Linux), Mac OS X and Microsoft Windows. Otherwise G++ implements neither automatic model.</source>
          <target state="translated">G++在链接器支持的目标上实现了Borland模型,包括ELF目标(如GNU/Linux)、Mac OS X和Microsoft Windows。否则,G++既不实现自动模型。</target>
        </trans-unit>
        <trans-unit id="31ff568d5d2e9d2f6743afcdc5f3a983bc913e2f" translate="yes" xml:space="preserve">
          <source>G++ implements the same behavior as GCC does when assigning to a volatile object&amp;mdash;there is no reread of the assigned-to object, the assigned rvalue is reused. Note that in C++ assignment expressions are lvalues, and if used as an lvalue, the volatile object is referred to. For instance, &lt;var&gt;vref&lt;/var&gt; refers to &lt;var&gt;vobj&lt;/var&gt;, as expected, in the following example:</source>
          <target state="translated">当分配给易失对象时，G ++实现与GCC相同的行为-没有重新读取分配给的对象，分配的右值被重用。请注意，在C ++赋值表达式中是左值，如果用作左值，则引用volatile对象。例如，在以下示例中， &lt;var&gt;vref&lt;/var&gt; 如所期望地引用了 &lt;var&gt;vobj&lt;/var&gt; ：</target>
        </trans-unit>
        <trans-unit id="a1650ba68fd434ff4571a3ae6e0e946daaa36507" translate="yes" xml:space="preserve">
          <source>G3</source>
          <target state="translated">G3</target>
        </trans-unit>
        <trans-unit id="57c24c56c83113e722078337cfe2d513db43c570" translate="yes" xml:space="preserve">
          <source>G4</source>
          <target state="translated">G4</target>
        </trans-unit>
        <trans-unit id="75cc572d557c39d31a9a311423998e30b6913f73" translate="yes" xml:space="preserve">
          <source>G5</source>
          <target state="translated">G5</target>
        </trans-unit>
        <trans-unit id="47bc5f06e2bc84be8cac3eeae94be31fd0bb67f8" translate="yes" xml:space="preserve">
          <source>GBR</source>
          <target state="translated">GBR</target>
        </trans-unit>
        <trans-unit id="8577b47d2b705ad56be34a1a6a9f6472d1ac1001" translate="yes" xml:space="preserve">
          <source>GCC</source>
          <target state="translated">GCC</target>
        </trans-unit>
        <trans-unit id="2128b3c47a543c2fd225378159dcf1cee572dc1a" translate="yes" xml:space="preserve">
          <source>GCC aims towards being usable as a conforming freestanding implementation, or as the compiler for a conforming hosted implementation. By default, it acts as the compiler for a hosted implementation, defining &lt;code&gt;__STDC_HOSTED__&lt;/code&gt; as &lt;code&gt;1&lt;/code&gt; and presuming that when the names of ISO C functions are used, they have the semantics defined in the standard. To make it act as a conforming freestanding implementation for a freestanding environment, use the option</source>
          <target state="translated">GCC的目标是可用作兼容的独立实现，或用作兼容的托管实现的编译器。默认情况下，它充当托管实现的编译器，将 &lt;code&gt;__STDC_HOSTED__&lt;/code&gt; 定义为 &lt;code&gt;1&lt;/code&gt; ,并假定使用ISO C函数的名称时，它们具有标准中定义的语义。要使其成为独立环境的一致独立实施，请使用选项</target>
        </trans-unit>
        <trans-unit id="a09efcf4281abbe557aa1d8c0037c8b8db485c71" translate="yes" xml:space="preserve">
          <source>GCC allows attributes to be set on C labels. See &lt;a href=&quot;attribute-syntax#Attribute-Syntax&quot;&gt;Attribute Syntax&lt;/a&gt;, for details of the exact syntax for using attributes. Other attributes are available for functions (see &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;Function Attributes&lt;/a&gt;), variables (see &lt;a href=&quot;variable-attributes#Variable-Attributes&quot;&gt;Variable Attributes&lt;/a&gt;), enumerators (see &lt;a href=&quot;enumerator-attributes#Enumerator-Attributes&quot;&gt;Enumerator Attributes&lt;/a&gt;), statements (see &lt;a href=&quot;statement-attributes#Statement-Attributes&quot;&gt;Statement Attributes&lt;/a&gt;), and for types (see &lt;a href=&quot;type-attributes#Type-Attributes&quot;&gt;Type Attributes&lt;/a&gt;).</source>
          <target state="translated">GCC允许在C标签上设置属性。有关使用属性的确切语法的详细信息，请参见&amp;ldquo; &lt;a href=&quot;attribute-syntax#Attribute-Syntax&quot;&gt;属性语法&amp;rdquo;&lt;/a&gt;。其他属性可用于函数（请参见&lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;Function Attributes&lt;/a&gt;），变量（请参见&lt;a href=&quot;variable-attributes#Variable-Attributes&quot;&gt;Variable Attributes&lt;/a&gt;），枚举器（请参见&lt;a href=&quot;enumerator-attributes#Enumerator-Attributes&quot;&gt;Enumerator Attributes&lt;/a&gt;），语句（请参见&lt;a href=&quot;statement-attributes#Statement-Attributes&quot;&gt;Statement Attributes&lt;/a&gt;）和类型（请参见&lt;a href=&quot;type-attributes#Type-Attributes&quot;&gt;Type Attributes&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="188d2c46ce847222650ff9a197ae21b6d36834fd" translate="yes" xml:space="preserve">
          <source>GCC allows attributes to be set on enumerators. See &lt;a href=&quot;attribute-syntax#Attribute-Syntax&quot;&gt;Attribute Syntax&lt;/a&gt;, for details of the exact syntax for using attributes. Other attributes are available for functions (see &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;Function Attributes&lt;/a&gt;), variables (see &lt;a href=&quot;variable-attributes#Variable-Attributes&quot;&gt;Variable Attributes&lt;/a&gt;), labels (see &lt;a href=&quot;label-attributes#Label-Attributes&quot;&gt;Label Attributes&lt;/a&gt;), statements (see &lt;a href=&quot;statement-attributes#Statement-Attributes&quot;&gt;Statement Attributes&lt;/a&gt;), and for types (see &lt;a href=&quot;type-attributes#Type-Attributes&quot;&gt;Type Attributes&lt;/a&gt;).</source>
          <target state="translated">GCC允许在枚举数上设置属性。有关使用属性的确切语法的详细信息，请参见&amp;ldquo; &lt;a href=&quot;attribute-syntax#Attribute-Syntax&quot;&gt;属性语法&amp;rdquo;&lt;/a&gt;。其他属性可用于函数（请参阅&lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;函数属性&lt;/a&gt;），变量（请参见&lt;a href=&quot;variable-attributes#Variable-Attributes&quot;&gt;变量属性&lt;/a&gt;），标签（请参见&lt;a href=&quot;label-attributes#Label-Attributes&quot;&gt;Label Attributes&lt;/a&gt;），语句（请参见&lt;a href=&quot;statement-attributes#Statement-Attributes&quot;&gt;Statement Attributes&lt;/a&gt;）和类型（请参见&lt;a href=&quot;type-attributes#Type-Attributes&quot;&gt;Type Attributes&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="1318f5f0c876968e4d22801744660b2a68a5dbc1" translate="yes" xml:space="preserve">
          <source>GCC allows attributes to be set on null statements. See &lt;a href=&quot;attribute-syntax#Attribute-Syntax&quot;&gt;Attribute Syntax&lt;/a&gt;, for details of the exact syntax for using attributes. Other attributes are available for functions (see &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;Function Attributes&lt;/a&gt;), variables (see &lt;a href=&quot;variable-attributes#Variable-Attributes&quot;&gt;Variable Attributes&lt;/a&gt;), labels (see &lt;a href=&quot;label-attributes#Label-Attributes&quot;&gt;Label Attributes&lt;/a&gt;), enumerators (see &lt;a href=&quot;enumerator-attributes#Enumerator-Attributes&quot;&gt;Enumerator Attributes&lt;/a&gt;), and for types (see &lt;a href=&quot;type-attributes#Type-Attributes&quot;&gt;Type Attributes&lt;/a&gt;).</source>
          <target state="translated">GCC允许在null语句上设置属性。有关使用属性的确切语法的详细信息，请参见&amp;ldquo; &lt;a href=&quot;attribute-syntax#Attribute-Syntax&quot;&gt;属性语法&amp;rdquo;&lt;/a&gt;。其他属性可用于函数（请参见&lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;函数属性&lt;/a&gt;），变量（请参见&lt;a href=&quot;variable-attributes#Variable-Attributes&quot;&gt;变量属性&lt;/a&gt;），标签（请参见&lt;a href=&quot;label-attributes#Label-Attributes&quot;&gt;Label Attributes&lt;/a&gt;），枚举器（请参见&lt;a href=&quot;enumerator-attributes#Enumerator-Attributes&quot;&gt;Enumerator Attributes&lt;/a&gt;）和类型（请参见&lt;a href=&quot;type-attributes#Type-Attributes&quot;&gt;Type Attributes&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="8f7518a10a612c3aa4683ccb174e0aca674b8c50" translate="yes" xml:space="preserve">
          <source>GCC allows static initialization of flexible array members. This is equivalent to defining a new structure containing the original structure followed by an array of sufficient size to contain the data. E.g. in the following, &lt;code&gt;f1&lt;/code&gt; is constructed as if it were declared like &lt;code&gt;f2&lt;/code&gt;.</source>
          <target state="translated">GCC允许对灵活数组成员进行静态初始化。这等效于定义一个包含原始结构的新结构，后跟一个足够大的数组来容纳数据。例如，在下面的示例中， &lt;code&gt;f1&lt;/code&gt; 的构造就像 &lt;code&gt;f2&lt;/code&gt; 一样。</target>
        </trans-unit>
        <trans-unit id="2f25be809d122cad042e0db0bcc9a75b7e95df2b" translate="yes" xml:space="preserve">
          <source>GCC allows the user to selectively enable or disable certain types of diagnostics, and change the kind of the diagnostic. For example, a project&amp;rsquo;s policy might require that all sources compile with</source>
          <target state="translated">GCC允许用户有选择地启用或禁用某些类型的诊断，并更改诊断的类型。例如，项目的政策可能要求所有来源</target>
        </trans-unit>
        <trans-unit id="095246dfc125cf940fca19907500328219191dc3" translate="yes" xml:space="preserve">
          <source>GCC allows using a &lt;code&gt;typedef&lt;/code&gt; name as the type specifier for a vector type, but only under the following circumstances:</source>
          <target state="translated">GCC允许将 &lt;code&gt;typedef&lt;/code&gt; 名称用作向量类型的类型说明符，但仅在以下情况下：</target>
        </trans-unit>
        <trans-unit id="118ab2384628648bceb8c24d3c1faa22f9cfc67a" translate="yes" xml:space="preserve">
          <source>GCC allows using a &lt;code&gt;typedef&lt;/code&gt; name as the type specifier for a vector type.</source>
          <target state="translated">GCC允许将 &lt;code&gt;typedef&lt;/code&gt; 名称用作向量类型的类型说明符。</target>
        </trans-unit>
        <trans-unit id="4dbc0782ac4d82d0f286d4feca2e87d560c81769" translate="yes" xml:space="preserve">
          <source>GCC allows you to declare &lt;em&gt;local labels&lt;/em&gt; in any nested block scope. A local label is just like an ordinary label, but you can only reference it (with a &lt;code&gt;goto&lt;/code&gt; statement, or by taking its address) within the block in which it is declared.</source>
          <target state="translated">GCC允许您在任何嵌套块范围内声明&lt;em&gt;局部标签&lt;/em&gt;。本地标签就像普通标签一样，但是您只能在声明它的块内引用它（使用 &lt;code&gt;goto&lt;/code&gt; 语句，或通过获取其地址）。</target>
        </trans-unit>
        <trans-unit id="11edda20db587e9081a40a5791b651f14e5edef4" translate="yes" xml:space="preserve">
          <source>GCC allows you to use</source>
          <target state="translated">GCC允许您使用</target>
        </trans-unit>
        <trans-unit id="cb8172c4270b6a56a430a2344a1d357df8a89c7e" translate="yes" xml:space="preserve">
          <source>GCC already has an extensive list of suffixes built into it. This directive adds an entry to the end of the list of suffixes, but since the list is searched from the end backwards, it is effectively possible to override earlier entries using this technique.</source>
          <target state="translated">GCC已经有一个广泛的后缀列表。这条指令在后缀列表的末尾添加了一个条目,但由于列表是从末尾开始向后搜索的,所以使用这种技术可以有效地覆盖早期条目。</target>
        </trans-unit>
        <trans-unit id="4946c9e7401c541aac6237c0b11a4f8762636048" translate="yes" xml:space="preserve">
          <source>GCC also defines the macro &lt;code&gt;__m&lt;var&gt;uarch&lt;/var&gt;__&lt;/code&gt; when tuning for ColdFire microarchitecture &lt;var&gt;uarch&lt;/var&gt;, where &lt;var&gt;uarch&lt;/var&gt; is one of the arguments given above.</source>
          <target state="translated">在调整ColdFire微体系结构 &lt;var&gt;uarch&lt;/var&gt; 时，GCC还定义了宏 &lt;code&gt;__m&lt;var&gt;uarch&lt;/var&gt;__&lt;/code&gt; ，其中 &lt;var&gt;uarch&lt;/var&gt; 是上面给出的参数之一。</target>
        </trans-unit>
        <trans-unit id="bd57161c41c158f961b92f3f1147120413b6477d" translate="yes" xml:space="preserve">
          <source>GCC also knows implicitly that arguments starting in</source>
          <target state="translated">GCC也隐含地知道,以</target>
        </trans-unit>
        <trans-unit id="5590aa7708108855eef5df246b0491a821f68f35" translate="yes" xml:space="preserve">
          <source>GCC also offers a simple mechanism for printing messages during compilation.</source>
          <target state="translated">GCC还提供了一个简单的机制来打印编译过程中的信息。</target>
        </trans-unit>
        <trans-unit id="ff5eb1c7d3d1103b9c01d9df5e0e050903b1adc0" translate="yes" xml:space="preserve">
          <source>GCC also provides a target specific macro &lt;code&gt;__BIGGEST_ALIGNMENT__&lt;/code&gt;, which is the largest alignment ever used for any data type on the target machine you are compiling for. For example, you could write:</source>
          <target state="translated">GCC还提供了特定于目标的宏 &lt;code&gt;__BIGGEST_ALIGNMENT__&lt;/code&gt; ，这是有史以来针对要编译的目标计算机上的任何数据类型使用的最大对齐方式。例如，您可以编写：</target>
        </trans-unit>
        <trans-unit id="1ce6a581ce58e7b0e52deb0ba48b6684312e9d7c" translate="yes" xml:space="preserve">
          <source>GCC also provides intrinsics to directly access the network registers. The intrinsics are:</source>
          <target state="translated">GCC还提供了直接访问网络寄存器的固有功能。这些内在因素是:</target>
        </trans-unit>
        <trans-unit id="028d66aa5e30f9984efa701c3d35086edefd3f65" translate="yes" xml:space="preserve">
          <source>GCC also supports attributes on variable declarations (see &lt;a href=&quot;variable-attributes#Variable-Attributes&quot;&gt;Variable Attributes&lt;/a&gt;), labels (see &lt;a href=&quot;label-attributes#Label-Attributes&quot;&gt;Label Attributes&lt;/a&gt;), enumerators (see &lt;a href=&quot;enumerator-attributes#Enumerator-Attributes&quot;&gt;Enumerator Attributes&lt;/a&gt;), statements (see &lt;a href=&quot;statement-attributes#Statement-Attributes&quot;&gt;Statement Attributes&lt;/a&gt;), and types (see &lt;a href=&quot;type-attributes#Type-Attributes&quot;&gt;Type Attributes&lt;/a&gt;).</source>
          <target state="translated">GCC还支持变量声明（请参见&lt;a href=&quot;variable-attributes#Variable-Attributes&quot;&gt;变量属性&lt;/a&gt;），标签（请参见&lt;a href=&quot;label-attributes#Label-Attributes&quot;&gt;Label Attributes&lt;/a&gt;），枚举器（请参见&lt;a href=&quot;enumerator-attributes#Enumerator-Attributes&quot;&gt;Enumerator Attributes&lt;/a&gt;），语句（请参见&lt;a href=&quot;statement-attributes#Statement-Attributes&quot;&gt;Statement Attributes&lt;/a&gt;）和类型（请参见&lt;a href=&quot;type-attributes#Type-Attributes&quot;&gt;Type Attributes&lt;/a&gt;）的属性。</target>
        </trans-unit>
        <trans-unit id="51353b73f0da65e20b68eea37e8d612e8b885954" translate="yes" xml:space="preserve">
          <source>GCC also warns about function definitions that might be candidates for &lt;code&gt;format&lt;/code&gt; attributes. Again, these are only possible candidates. GCC guesses that &lt;code&gt;format&lt;/code&gt; attributes might be appropriate for any function that calls a function like &lt;code&gt;vprintf&lt;/code&gt; or &lt;code&gt;vscanf&lt;/code&gt;, but this might not always be the case, and some functions for which &lt;code&gt;format&lt;/code&gt; attributes are appropriate may not be detected.</source>
          <target state="translated">GCC还警告可能是 &lt;code&gt;format&lt;/code&gt; 属性候选的函数定义。同样，这些只是可能的候选者。 GCC猜测 &lt;code&gt;format&lt;/code&gt; 属性可能适用于任何调用 &lt;code&gt;vprintf&lt;/code&gt; 或 &lt;code&gt;vscanf&lt;/code&gt; 之类的函数的函数，但这并非总是如此，并且某些 &lt;code&gt;format&lt;/code&gt; 属性适用的函数可能无法检测到。</target>
        </trans-unit>
        <trans-unit id="e6346f95ac263c787786ddc66b5d9c0bcd8bac71" translate="yes" xml:space="preserve">
          <source>GCC always follows the C99 and C11 requirement that the result of division is truncated towards zero.</source>
          <target state="translated">GCC始终遵循C99和C11的要求,将除法的结果截为零。</target>
        </trans-unit>
        <trans-unit id="71e58c529399ec16a2da4be1a53c86f1d271b88e" translate="yes" xml:space="preserve">
          <source>GCC always tries to compile your program if possible; it never gratuitously rejects a program whose meaning is clear merely because (for instance) it fails to conform to a standard. In some cases, however, the C and C++ standards specify that certain extensions are forbidden, and a diagnostic &lt;em&gt;must&lt;/em&gt; be issued by a conforming compiler. The</source>
          <target state="translated">GCC会尽可能尝试编译您的程序；它永远不会无故拒绝仅仅因为（例如）不符合标准而明确含义的程序。但是，在某些情况下，C和C ++标准指定禁止某些扩展，并且&lt;em&gt;必须&lt;/em&gt;由合格的编译器发出诊断信息。的</target>
        </trans-unit>
        <trans-unit id="3d850d85ff9e9c0132b4336d9517c8233fd73c22" translate="yes" xml:space="preserve">
          <source>GCC by default uses the GNU Objective-C runtime library, which is part of GCC and is not the same as the Apple/NeXT Objective-C runtime library used on Apple systems. There are a number of differences documented in this manual. The options</source>
          <target state="translated">GCC默认使用GNU Objective-C运行库,它是GCC的一部分,与苹果系统上使用的Apple/NeXT Objective-C运行库不同。本手册中记载了许多不同之处。选项</target>
        </trans-unit>
        <trans-unit id="1c0b38c968b6ef5ec06e42505963f829a108bef3" translate="yes" xml:space="preserve">
          <source>GCC by itself attempts to be a conforming freestanding implementation. See &lt;a href=&quot;standards#Standards&quot;&gt;Language Standards Supported by GCC&lt;/a&gt;, for details of what this means. Beyond the library facilities required of such an implementation, the rest of the C library is supplied by the vendor of the operating system. If that C library doesn&amp;rsquo;t conform to the C standards, then your programs might get warnings (especially when using</source>
          <target state="translated">GCC本身试图成为一个符合标准的独立实现。有关这意味着什么的详细信息，请参见&lt;a href=&quot;standards#Standards&quot;&gt;GCC支持的语言标准&lt;/a&gt;。除了这种实现所需的库功能之外，其余C库由操作系统的供应商提供。如果该C库不符合C标准，则您的程序可能会收到警告（尤其是在使用</target>
        </trans-unit>
        <trans-unit id="a367622db7093a4cc9943cb9b928ad16a228659d" translate="yes" xml:space="preserve">
          <source>GCC can allocate complex automatic variables in a noncontiguous fashion; it&amp;rsquo;s even possible for the real part to be in a register while the imaginary part is on the stack (or vice versa). Only the DWARF debug info format can represent this, so use of DWARF is recommended. If you are using the stabs debug info format, GCC describes a noncontiguous complex variable as if it were two separate variables of noncomplex type. If the variable&amp;rsquo;s actual name is &lt;code&gt;foo&lt;/code&gt;, the two fictitious variables are named &lt;code&gt;foo$real&lt;/code&gt; and &lt;code&gt;foo$imag&lt;/code&gt;. You can examine and set these two fictitious variables with your debugger.</source>
          <target state="translated">GCC可以非连续方式分配复杂的自动变量；甚至当虚部在堆栈上时，实部也可能位于寄存器中（反之亦然）。仅DWARF调试信息格式可以表示此格式，因此建议使用DWARF。如果使用的是stabs调试信息格式，则GCC会将非连续的复杂变量描述为好像是两个单独的非复杂类型的变量。如果变量的实际名称为 &lt;code&gt;foo&lt;/code&gt; ，则两个虚拟变量分别命名为 &lt;code&gt;foo$real&lt;/code&gt; 和 &lt;code&gt;foo$imag&lt;/code&gt; 。您可以使用调试器检查并设置这两个虚拟变量。</target>
        </trans-unit>
        <trans-unit id="f1f3d3d856350fe50d86862ccf0921b96281e6bd" translate="yes" xml:space="preserve">
          <source>GCC can compile the binary representation (BRIG) of the HSAIL text format as described in HSA Programmer&amp;rsquo;s Reference Manual version 1.0.1. This capability is typically utilized to implement the HSA runtime API&amp;rsquo;s HSAIL finalization extension for a gcc supported processor. HSA standards are freely available at &lt;a href=&quot;http://www.hsafoundation.com/standards/&quot;&gt;http://www.hsafoundation.com/standards/&lt;/a&gt;.</source>
          <target state="translated">GCC可以按照HSA程序员参考手册1.0.1版中的说明编译HSAIL文本格式的二进制表示（BRIG）。此功能通常用于为gcc支持的处理器实现HSA运行时API的HSAIL终结扩展。HSA标准可从&lt;a href=&quot;http://www.hsafoundation.com/standards/&quot;&gt;http://www.hsafoundation.com/standards/&lt;/a&gt;免费获得。</target>
        </trans-unit>
        <trans-unit id="87356dae6f4ed6235c36eedc0fe148afee6229d9" translate="yes" xml:space="preserve">
          <source>GCC can generate code for both VxWorks kernels and real time processes (RTPs). This option switches from the former to the latter. It also defines the preprocessor macro &lt;code&gt;__RTP__&lt;/code&gt;.</source>
          <target state="translated">GCC可以为VxWorks内核和实时进程（RTP）生成代码。此选项从前者切换到后者。它还定义了预处理程序宏 &lt;code&gt;__RTP__&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fb9f5282eec43cb95e4c422b1995ae6896ab686c" translate="yes" xml:space="preserve">
          <source>GCC can only handle one commutative pair in an asm; if you use more, the compiler may fail. Note that you need not use the modifier if the two alternatives are strictly identical; this would only waste time in the reload pass.</source>
          <target state="translated">GCC只能处理asm中的一个换算对,如果使用更多,编译器可能会失败。请注意,如果两个备选方案完全相同,就不需要使用修饰符;这只会在重载传递中浪费时间。</target>
        </trans-unit>
        <trans-unit id="78d74922e82c5075040c6a08c44444ac34a5ad2a" translate="yes" xml:space="preserve">
          <source>GCC comes with shell scripts to fix certain known problems in system header files. They install corrected copies of various header files in a special directory where only GCC will normally look for them. The scripts adapt to various systems by searching all the system header files for the problem cases that we know about.</source>
          <target state="translated">GCC自带的shell脚本可以修复系统头文件中的某些已知问题。它们将各种头文件的修正副本安装在一个特殊的目录中,通常只有GCC才会在这个目录中查找它们。脚本通过搜索所有系统头文件来适应各种系统,寻找我们所知道的问题情况。</target>
        </trans-unit>
        <trans-unit id="cd976cd951c888839dc15c99651c6a379e4c0cac" translate="yes" xml:space="preserve">
          <source>GCC compiled code sometimes emits warnings from the HP-UX assembler of the form:</source>
          <target state="translated">GCC编译后的代码有时会从HP-UX汇编器中发出形式的警告。</target>
        </trans-unit>
        <trans-unit id="81e4ed9eaf205df3f6c599be30d212f56ac91924" translate="yes" xml:space="preserve">
          <source>GCC complains about program fragments such as &amp;lsquo;</source>
          <target state="translated">GCC抱怨程序片段，例如&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="67982454dd3e3b7d64f34362d5f739d9716bb143" translate="yes" xml:space="preserve">
          <source>GCC complains about unterminated character constants inside of preprocessing conditionals that fail. Some programs have English comments enclosed in conditionals that are guaranteed to fail; if these comments contain apostrophes, GCC will probably report an error. For example, this code would produce an error:</source>
          <target state="translated">GCC会抱怨预处理条件中的未加引号的字符常量失败。有些程序的条件中包含了英文注释,这些注释保证会失败;如果这些注释包含了省略号,GCC可能会报告一个错误。例如,这段代码会产生一个错误。</target>
        </trans-unit>
        <trans-unit id="e4bb7adbf45dc4a3fb687d7313280a86480960d6" translate="yes" xml:space="preserve">
          <source>GCC complies with the OpenPOWER 64-Bit ELF V2 ABI Specification, which may be found at &lt;a href=&quot;http://openpowerfoundation.org/wp-content/uploads/resources/leabi-prd/content/index.html&quot;&gt;http://openpowerfoundation.org/wp-content/uploads/resources/leabi-prd/content/index.html&lt;/a&gt;. Appendix A of this document lists the vector API interfaces that must be provided by compliant compilers. Programmers should preferentially use the interfaces described therein. However, historically GCC has provided additional interfaces for access to vector instructions. These are briefly described below.</source>
          <target state="translated">GCC符合OpenPOWER 64位ELF V2 ABI规范，该规范可在&lt;a href=&quot;http://openpowerfoundation.org/wp-content/uploads/resources/leabi-prd/content/index.html&quot;&gt;http://openpowerfoundation.org/wp-content/uploads/resources/leabi-prd/content/index.html中&lt;/a&gt;找到。本文档的附录A列出了兼容的编译器必须提供的矢量API接口。程序员应优先使用其中描述的接口。但是，从历史上看，GCC提供了用于访问矢量指令的其他接口。这些将在下面简要描述。</target>
        </trans-unit>
        <trans-unit id="65f9b929facca207bcc2021009f1c0587b957cbf" translate="yes" xml:space="preserve">
          <source>GCC currently emits calls to &lt;code&gt;vmldExp2&lt;/code&gt;, &lt;code&gt;vmldLn2&lt;/code&gt;, &lt;code&gt;vmldLog102&lt;/code&gt;, &lt;code&gt;vmldPow2&lt;/code&gt;, &lt;code&gt;vmldTanh2&lt;/code&gt;, &lt;code&gt;vmldTan2&lt;/code&gt;, &lt;code&gt;vmldAtan2&lt;/code&gt;, &lt;code&gt;vmldAtanh2&lt;/code&gt;, &lt;code&gt;vmldCbrt2&lt;/code&gt;, &lt;code&gt;vmldSinh2&lt;/code&gt;, &lt;code&gt;vmldSin2&lt;/code&gt;, &lt;code&gt;vmldAsinh2&lt;/code&gt;, &lt;code&gt;vmldAsin2&lt;/code&gt;, &lt;code&gt;vmldCosh2&lt;/code&gt;, &lt;code&gt;vmldCos2&lt;/code&gt;, &lt;code&gt;vmldAcosh2&lt;/code&gt;, &lt;code&gt;vmldAcos2&lt;/code&gt;, &lt;code&gt;vmlsExp4&lt;/code&gt;, &lt;code&gt;vmlsLn4&lt;/code&gt;, &lt;code&gt;vmlsLog104&lt;/code&gt;, &lt;code&gt;vmlsPow4&lt;/code&gt;, &lt;code&gt;vmlsTanh4&lt;/code&gt;, &lt;code&gt;vmlsTan4&lt;/code&gt;, &lt;code&gt;vmlsAtan4&lt;/code&gt;, &lt;code&gt;vmlsAtanh4&lt;/code&gt;, &lt;code&gt;vmlsCbrt4&lt;/code&gt;, &lt;code&gt;vmlsSinh4&lt;/code&gt;, &lt;code&gt;vmlsSin4&lt;/code&gt;, &lt;code&gt;vmlsAsinh4&lt;/code&gt;, &lt;code&gt;vmlsAsin4&lt;/code&gt;, &lt;code&gt;vmlsCosh4&lt;/code&gt;, &lt;code&gt;vmlsCos4&lt;/code&gt;, &lt;code&gt;vmlsAcosh4&lt;/code&gt; and &lt;code&gt;vmlsAcos4&lt;/code&gt; for corresponding function type when</source>
          <target state="translated">GCC目前发出的呼吁 &lt;code&gt;vmldExp2&lt;/code&gt; ， &lt;code&gt;vmldLn2&lt;/code&gt; ， &lt;code&gt;vmldLog102&lt;/code&gt; ， &lt;code&gt;vmldPow2&lt;/code&gt; ， &lt;code&gt;vmldTanh2&lt;/code&gt; ， &lt;code&gt;vmldTan2&lt;/code&gt; ， &lt;code&gt;vmldAtan2&lt;/code&gt; ， &lt;code&gt;vmldAtanh2&lt;/code&gt; ， &lt;code&gt;vmldCbrt2&lt;/code&gt; ， &lt;code&gt;vmldSinh2&lt;/code&gt; ， &lt;code&gt;vmldSin2&lt;/code&gt; ， &lt;code&gt;vmldAsinh2&lt;/code&gt; ， &lt;code&gt;vmldAsin2&lt;/code&gt; ， &lt;code&gt;vmldCosh2&lt;/code&gt; ， &lt;code&gt;vmldCos2&lt;/code&gt; ， &lt;code&gt;vmldAcosh2&lt;/code&gt; ， &lt;code&gt;vmldAcos2&lt;/code&gt; ， &lt;code&gt;vmlsExp4&lt;/code&gt; ， &lt;code&gt;vmlsLn4&lt;/code&gt; ， &lt;code&gt;vmlsLog104&lt;/code&gt; ， &lt;code&gt;vmlsPow4&lt;/code&gt; ， &lt;code&gt;vmlsTanh4&lt;/code&gt; ， &lt;code&gt;vmlsTan4&lt;/code&gt; ， &lt;code&gt;vmlsAtan4&lt;/code&gt; ， &lt;code&gt;vmlsAtanh4&lt;/code&gt; ， &lt;code&gt;vmlsCbrt4&lt;/code&gt; ， &lt;code&gt;vmlsSinh4&lt;/code&gt; ， &lt;code&gt;vmlsSin4&lt;/code&gt; ， &lt;code&gt;vmlsAsinh4&lt;/code&gt; ， &lt;code&gt;vmlsAsin4&lt;/code&gt; ， &lt;code&gt;vmlsCosh4&lt;/code&gt; ， &lt;code&gt;vmlsCos4&lt;/code&gt; ， &lt;code&gt;vmlsAcosh4&lt;/code&gt; 和 &lt;code&gt;vmlsAcos4&lt;/code&gt; 对应函数类型时</target>
        </trans-unit>
        <trans-unit id="16f9d8d14967dad5157f0d4d4177e77917294c63" translate="yes" xml:space="preserve">
          <source>GCC defines a macro &lt;code&gt;__mcf&lt;var&gt;arch&lt;/var&gt;__&lt;/code&gt; whenever it is generating code for a ColdFire target. The &lt;var&gt;arch&lt;/var&gt; in this macro is one of the</source>
          <target state="translated">每当GCC 为ColdFire目标生成代码时，它都会定义一个宏 &lt;code&gt;__mcf&lt;var&gt;arch&lt;/var&gt;__&lt;/code&gt; 。此宏中的 &lt;var&gt;arch&lt;/var&gt; 是</target>
        </trans-unit>
        <trans-unit id="9690667ebb3c4d196426b91a67e183bca646b7c4" translate="yes" xml:space="preserve">
          <source>GCC defines a preprocessor macro for the specified &lt;var&gt;cpu&lt;/var&gt;. For the &amp;lsquo;</source>
          <target state="translated">GCC为指定的 &lt;var&gt;cpu&lt;/var&gt; 定义了一个预处理器宏。为了 '</target>
        </trans-unit>
        <trans-unit id="1ee4979d83e119fc65d0b3ce42180431e0b52daf" translate="yes" xml:space="preserve">
          <source>GCC defines several built-in macros so that the user code can test for the presence or absence of features. Almost any of the following built-in macros are deduced from device capabilities and thus triggered by the</source>
          <target state="translated">GCC定义了几个内置宏,以便用户代码可以测试功能的存在或缺失。以下几乎所有的内置宏都是由设备功能推导出来的,因此由</target>
        </trans-unit>
        <trans-unit id="07c2bb68cb370eca1e6a61c97987834533dcec03" translate="yes" xml:space="preserve">
          <source>GCC defines the macro &lt;code&gt;__mcf_cpu_&lt;var&gt;cpu&lt;/var&gt;&lt;/code&gt; when ColdFire target &lt;var&gt;cpu&lt;/var&gt; is selected. It also defines &lt;code&gt;__mcf_family_&lt;var&gt;family&lt;/var&gt;&lt;/code&gt;, where the value of &lt;var&gt;family&lt;/var&gt; is given by the table above.</source>
          <target state="translated">当选择ColdFire目标 &lt;var&gt;cpu&lt;/var&gt; 时，GCC定义宏 &lt;code&gt;__mcf_cpu_&lt;var&gt;cpu&lt;/var&gt;&lt;/code&gt; 。它还定义 &lt;code&gt;__mcf_family_&lt;var&gt;family&lt;/var&gt;&lt;/code&gt; &lt;var&gt;family&lt;/var&gt; ，其中的值 &lt;var&gt;family&lt;/var&gt; 由上述表中给出。</target>
        </trans-unit>
        <trans-unit id="57340a71d3d941522f73fea99d6d51e3e8ce6ff1" translate="yes" xml:space="preserve">
          <source>GCC defines the macro &lt;code&gt;__mcfhwdiv__&lt;/code&gt; when this option is enabled.</source>
          <target state="translated">启用此选项后，GCC会定义宏 &lt;code&gt;__mcfhwdiv__&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6a9b1f894460a8c96f48083896afccfe85c9be79" translate="yes" xml:space="preserve">
          <source>GCC defines the macros &lt;code&gt;__mc&lt;var&gt;arch&lt;/var&gt;&lt;/code&gt; and &lt;code&gt;__mc&lt;var&gt;arch&lt;/var&gt;__&lt;/code&gt; when tuning for 680x0 architecture &lt;var&gt;arch&lt;/var&gt;. It also defines &lt;code&gt;mc&lt;var&gt;arch&lt;/var&gt;&lt;/code&gt; unless either</source>
          <target state="translated">GCC定义了宏 &lt;code&gt;__mc&lt;var&gt;arch&lt;/var&gt;&lt;/code&gt; 和 &lt;code&gt;__mc&lt;var&gt;arch&lt;/var&gt;__&lt;/code&gt; 当调谐为680X0架构 &lt;var&gt;arch&lt;/var&gt; 。它还定义了 &lt;code&gt;mc&lt;var&gt;arch&lt;/var&gt;&lt;/code&gt; 除非</target>
        </trans-unit>
        <trans-unit id="2885698109b0288d9891eaf5f6f566e33bc93a28" translate="yes" xml:space="preserve">
          <source>GCC defines the preprocessor macro &lt;code&gt;__HAVE_BUILTIN_SPECULATION_SAFE_VALUE&lt;/code&gt; for targets that have been updated to support this builtin.</source>
          <target state="translated">GCC 为已更新为支持此内置目标的目标定义了预处理器宏 &lt;code&gt;__HAVE_BUILTIN_SPECULATION_SAFE_VALUE&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9502202879d2e8497b3ab7402351c2cfb4aba65d" translate="yes" xml:space="preserve">
          <source>GCC defines two macros based on the value of this option. The first is &lt;code&gt;_MIPS_ARCH&lt;/code&gt;, which gives the name of target architecture, as a string. The second has the form &lt;code&gt;_MIPS_ARCH_&lt;var&gt;foo&lt;/var&gt;&lt;/code&gt;, where &lt;var&gt;foo&lt;/var&gt; is the capitalized value of &lt;code&gt;_MIPS_ARCH&lt;/code&gt;. For example,</source>
          <target state="translated">GCC根据此选项的值定义两个宏。第一个是 &lt;code&gt;_MIPS_ARCH&lt;/code&gt; ，它以字符串形式给出目标体系结构的名称。第二个格式为 &lt;code&gt;_MIPS_ARCH_&lt;var&gt;foo&lt;/var&gt;&lt;/code&gt; ，其中 &lt;var&gt;foo&lt;/var&gt; 是 &lt;code&gt;_MIPS_ARCH&lt;/code&gt; 的大写值。例如，</target>
        </trans-unit>
        <trans-unit id="a26b5e085873721291414d2146a69ef3ff2df942" translate="yes" xml:space="preserve">
          <source>GCC depresses SSEx instructions when</source>
          <target state="translated">时,GCC压低SSEx指令。</target>
        </trans-unit>
        <trans-unit id="f00d9db0f7babc17a8b2e93a16eaa154dca9484f" translate="yes" xml:space="preserve">
          <source>GCC does not inline any functions when not optimizing unless you specify the &amp;lsquo;</source>
          <target state="translated">如果未进行优化，则GCC不会内联任何功能，除非您指定&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="d979e47341cf32b9e9788a98df7db938c53659aa" translate="yes" xml:space="preserve">
          <source>GCC does not parse basic &lt;code&gt;asm&lt;/code&gt;&amp;rsquo;s &lt;var&gt;AssemblerInstructions&lt;/var&gt;, which means there is no way to communicate to the compiler what is happening inside them. GCC has no visibility of symbols in the &lt;code&gt;asm&lt;/code&gt; and may discard them as unreferenced. It also does not know about side effects of the assembler code, such as modifications to memory or registers. Unlike some compilers, GCC assumes that no changes to general purpose registers occur. This assumption may change in a future release.</source>
          <target state="translated">GCC不会解析基本的 &lt;code&gt;asm&lt;/code&gt; 的 &lt;var&gt;AssemblerInstructions&lt;/var&gt; ，这意味着无法向编译器传达其中发生的情况。 GCC有没有在符号的可视性 &lt;code&gt;asm&lt;/code&gt; 并可能放弃他们作为未引用。它还不知道汇编代码的副作用，例如对内存或寄存器的修改。与某些编译器不同，GCC假定不会更改通用寄存器。此假设可能会在将来的版本中更改。</target>
        </trans-unit>
        <trans-unit id="cd46297b79a48028b406a3a22f8df3c38f23ed53" translate="yes" xml:space="preserve">
          <source>GCC does not provide the C library functionality associated with</source>
          <target state="translated">GCC并没有提供与</target>
        </trans-unit>
        <trans-unit id="96d71d57d6177ab6f3fc682f6b185f4541d680d8" translate="yes" xml:space="preserve">
          <source>GCC does not provide the library facilities required only of hosted implementations, nor yet all the facilities required by C99 of freestanding implementations on all platforms. To use the facilities of a hosted environment, you need to find them elsewhere (for example, in the GNU C library). See &lt;a href=&quot;standard-libraries#Standard-Libraries&quot;&gt;Standard Libraries&lt;/a&gt;.</source>
          <target state="translated">GCC并未提供仅托管实施所需的库设施，也未提供C99在所有平台上的独立实施所需的所有设施。要使用托管环境的功能，您需要在其他位置（例如，在GNU C库中）找到它们。请参阅&lt;a href=&quot;standard-libraries#Standard-Libraries&quot;&gt;标准库&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="86c923d0a51125464840f7ea1874cf6ab2974fb7" translate="yes" xml:space="preserve">
          <source>GCC does not substitute macro arguments when they appear inside of string constants. For example, the following macro in GCC</source>
          <target state="translated">当宏参数出现在字符串常量中时,GCC不会替换它们。例如,GCC中的以下宏</target>
        </trans-unit>
        <trans-unit id="42a91da8639ee03ec161a4bd756ad60809129b66" translate="yes" xml:space="preserve">
          <source>GCC does not support any extended integer types.</source>
          <target state="translated">GCC不支持任何扩展的整数类型。</target>
        </trans-unit>
        <trans-unit id="3ce5b628a549292da4090df5538cf2cd3541c673" translate="yes" xml:space="preserve">
          <source>GCC does not support using this feature with a non-static local variable since such variables do not have assembler names. If you are trying to put the variable in a particular register, see &lt;a href=&quot;explicit-register-variables#Explicit-Register-Variables&quot;&gt;Explicit Register Variables&lt;/a&gt;.</source>
          <target state="translated">GCC不支持将此功能与非静态局部变量一起使用，因为此类变量没有汇编程序名称。如果您试图将变量放入特定的寄存器中，请参见&lt;a href=&quot;explicit-register-variables#Explicit-Register-Variables&quot;&gt;显式寄存器变量&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="057dd4b479d4087929d93c02eca9edfef895599b" translate="yes" xml:space="preserve">
          <source>GCC does not use such values.</source>
          <target state="translated">GCC不使用这种值。</target>
        </trans-unit>
        <trans-unit id="6b22e4a77b39e5fcd62364faba592ec172555481" translate="yes" xml:space="preserve">
          <source>GCC emits warnings based on this attribute by default; use</source>
          <target state="translated">GCC默认会根据这个属性发出警告;使用</target>
        </trans-unit>
        <trans-unit id="6213b35197bfb3bb104e08212f01a4cf35332f2f" translate="yes" xml:space="preserve">
          <source>GCC enables this option by default. If you want to force the compiler to check if a variable is referenced, regardless of whether or not optimization is turned on, use the</source>
          <target state="translated">GCC默认启用这个选项。如果你想强制编译器检查一个变量是否被引用,不管是否开启了优化,请使用</target>
        </trans-unit>
        <trans-unit id="d7b2a859b296fb3f8914b78d7834ccf3e648a510" translate="yes" xml:space="preserve">
          <source>GCC has currently no support for non-fragile instance variables.</source>
          <target state="translated">GCC目前还不支持非脆弱的实例变量。</target>
        </trans-unit>
        <trans-unit id="9b64961814c7627599dfb66d9541dfbc1c55e8a3" translate="yes" xml:space="preserve">
          <source>GCC has long supported variadic macros, and used a different syntax that allowed you to give a name to the variable arguments just like any other argument. Here is an example:</source>
          <target state="translated">GCC长期以来一直支持变量宏,并且使用了一种不同的语法,允许你像其他参数一样给变量参数命名。下面是一个例子。</target>
        </trans-unit>
        <trans-unit id="e677a4ecf07d49ec983c792d6fd35d17489c7528" translate="yes" xml:space="preserve">
          <source>GCC has the following spec strings built into it. Spec files can override these strings or create their own. Note that individual targets can also add their own spec strings to this list.</source>
          <target state="translated">GCC内置了以下规范字符串。规范文件可以覆盖这些字符串或创建自己的字符串。请注意,各个目标也可以将自己的规范字符串添加到这个列表中。</target>
        </trans-unit>
        <trans-unit id="ed8411601030aef9d10cc9d6209db6260f4d910d" translate="yes" xml:space="preserve">
          <source>GCC implements a limited buffer overflow protection mechanism that can prevent some buffer overflow attacks by determining the sizes of objects into which data is about to be written and preventing the writes when the size isn&amp;rsquo;t sufficient. The built-in functions described below yield the best results when used together and when optimization is enabled. For example, to detect object sizes across function boundaries or to follow pointer assignments through non-trivial control flow they rely on various optimization passes enabled with</source>
          <target state="translated">GCC实施了一种有限的缓冲区溢出保护机制，该机制可以通过确定将要写入数据的对象的大小并在大小不足时阻止写入来防止某些缓冲区溢出攻击。一起使用和启用优化后，下面描述的内置函数可产生最佳效果。例如，要检测跨函数边界的对象大小或通过非平凡的控制流遵循指针分配，它们依赖于启用了各种优化的通道</target>
        </trans-unit>
        <trans-unit id="c63f8d617f5fcd74378c430997fb1de4655a5a57" translate="yes" xml:space="preserve">
          <source>GCC implements extensions for C as described in the ARM C Language Extensions (ACLE) specification, which can be found at &lt;a href=&quot;http://infocenter.arm.com/help/topic/com.arm.doc.ihi0053c/IHI0053C_acle_2_0.pdf&quot;&gt;http://infocenter.arm.com/help/topic/com.arm.doc.ihi0053c/IHI0053C_acle_2_0.pdf&lt;/a&gt;.</source>
          <target state="translated">GCC实现了ARM C语言扩展（ACLE）规范中所述的C扩展，可以在&lt;a href=&quot;http://infocenter.arm.com/help/topic/com.arm.doc.ihi0053c/IHI0053C_acle_2_0.pdf&quot;&gt;http://infocenter.arm.com/help/topic/com.arm.doc.ihi0053c/IHI0053C_acle_2_0.pdf中&lt;/a&gt;找到。</target>
        </trans-unit>
        <trans-unit id="293bbd3b2e69a9d930833e11f1b427e7997876a6" translate="yes" xml:space="preserve">
          <source>GCC implements for both C and C++ a syntactic extension to implement the &lt;code&gt;offsetof&lt;/code&gt; macro.</source>
          <target state="translated">GCC为C和C ++实现了语法扩展，以实现 &lt;code&gt;offsetof&lt;/code&gt; 宏。</target>
        </trans-unit>
        <trans-unit id="322077390825044afaea930b7263992ddcea81e8" translate="yes" xml:space="preserve">
          <source>GCC implements taking the address of a nested function using a technique called &lt;em&gt;trampolines&lt;/em&gt;. This technique was described in Lexical Closures for C++ (Thomas M. Breuel, USENIX C++ Conference Proceedings, October 17-21, 1988).</source>
          <target state="translated">GCC使用称为&lt;em&gt;蹦床&lt;/em&gt;的技术来实现嵌套函数的地址。C ++的词法闭包中对此技术进行了描述（Thomas M. Breuel，USENIX C ++会议论文集，1988年10月17日至21日）。</target>
        </trans-unit>
        <trans-unit id="239348ac99d6992297a72fcc17bd9b383a471db0" translate="yes" xml:space="preserve">
          <source>GCC implements the ARMv8-M Security Extensions as described in the ARMv8-M Security Extensions: Requirements on Development Tools Engineering Specification, which can be found at &lt;a href=&quot;http://infocenter.arm.com/help/topic/com.arm.doc.ecm0359818/ECM0359818_armv8m_security_extensions_reqs_on_dev_tools_1_0.pdf&quot;&gt;http://infocenter.arm.com/help/topic/com.arm.doc.ecm0359818/ECM0359818_armv8m_security_extensions_reqs_on_dev_tools_1_0.pdf&lt;/a&gt;.</source>
          <target state="translated">GCC按照《 ARMv8-M安全性扩展：开发工具工程规范的要求》中的说明实施ARMv8-M安全性扩展，可以在&lt;a href=&quot;http://infocenter.arm.com/help/topic/com.arm.doc.ecm0359818/ECM0359818_armv8m_security_extensions_reqs_on_dev_tools_1_0.pdf&quot;&gt;http://infocenter.arm.com/help/topic/com.arm.doc&lt;/a&gt;上找到它。 ecm0359818 / ECM0359818_armv8m_security_extensions_reqs_on_dev_tools_1_0.pdf。</target>
        </trans-unit>
        <trans-unit id="7c1d6efdb055c03457ac985aa41eeb676f9d1c1c" translate="yes" xml:space="preserve">
          <source>GCC implements three different semantics of declaring a function inline. One is available with</source>
          <target state="translated">GCC实现了三种不同语义的内联函数声明。一种是通过</target>
        </trans-unit>
        <trans-unit id="16fab68e571685f848321494bfa65aa76fa12ecf" translate="yes" xml:space="preserve">
          <source>GCC includes built-in versions of many of the functions in the standard C library. These functions come in two forms: one whose names start with the &lt;code&gt;__builtin_&lt;/code&gt; prefix, and the other without. Both forms have the same type (including prototype), the same address (when their address is taken), and the same meaning as the C library functions even if you specify the</source>
          <target state="translated">GCC在标准C库中包含许多功能的内置版本。这些函数有两种形式：一种以 &lt;code&gt;__builtin_&lt;/code&gt; 前缀开头，另一种则不带前缀。两种形式都具有相同的类型（包括原型），相同的地址（采用它们的地址时）以及与C库函数相同的含义，即使您指定了</target>
        </trans-unit>
        <trans-unit id="6ddb06bf023a460b3469518f6828ceb9799c46e8" translate="yes" xml:space="preserve">
          <source>GCC is incompatible with traditional C.</source>
          <target state="translated">GCC与传统C语言不兼容。</target>
        </trans-unit>
        <trans-unit id="d28b24326033740593178727cd1510ca18099b74" translate="yes" xml:space="preserve">
          <source>GCC is only limited by available memory.</source>
          <target state="translated">GCC只受可用内存的限制。</target>
        </trans-unit>
        <trans-unit id="e1b7ed70d92a385236df81656270c5df961819cc" translate="yes" xml:space="preserve">
          <source>GCC needs to install corrected versions of some system header files. This is because most target systems have some header files that won&amp;rsquo;t work with GCC unless they are changed. Some have bugs, some are incompatible with ISO C, and some depend on special features of other compilers.</source>
          <target state="translated">GCC需要安装某些系统头文件的正确版本。这是因为大多数目标系统都有一些头文件，除非更改它们，否则它们将无法与GCC一起使用。一些具有错误，一些与ISO C不兼容，并且一些依赖于其他编译器的特殊功能。</target>
        </trans-unit>
        <trans-unit id="6fec00d5e695a6ba7008f039024af2f2354b9175" translate="yes" xml:space="preserve">
          <source>GCC no longer supports DWARF Version 1, which is substantially different than Version 2 and later. For historical reasons, some other DWARF-related options such as</source>
          <target state="translated">GCC不再支持DWARF第1版,这与第2版及以后的版本有很大的不同。由于历史原因,其他一些与DWARF相关的选项,如</target>
        </trans-unit>
        <trans-unit id="9571fcf4d32ba7634429d5420351196a13337bf1" translate="yes" xml:space="preserve">
          <source>GCC normally defines &lt;code&gt;__STDC__&lt;/code&gt; to be 1, and in addition defines &lt;code&gt;__STRICT_ANSI__&lt;/code&gt; if you specify the</source>
          <target state="translated">GCC通常将 &lt;code&gt;__STDC__&lt;/code&gt; 定义为1，此外，如果您指定 &lt;code&gt;__STRICT_ANSI__&lt;/code&gt; ，</target>
        </trans-unit>
        <trans-unit id="d2a04d28db5bb4fd272285d6f2261f1af937b1aa" translate="yes" xml:space="preserve">
          <source>GCC normally generates special code to handle certain built-in functions more efficiently; for instance, calls to &lt;code&gt;alloca&lt;/code&gt; may become single instructions which adjust the stack directly, and calls to &lt;code&gt;memcpy&lt;/code&gt; may become inline copy loops. The resulting code is often both smaller and faster, but since the function calls no longer appear as such, you cannot set a breakpoint on those calls, nor can you change the behavior of the functions by linking with a different library. In addition, when a function is recognized as a built-in function, GCC may use information about that function to warn about problems with calls to that function, or to generate more efficient code, even if the resulting code still contains calls to that function. For example, warnings are given with</source>
          <target state="translated">GCC通常会生成特殊的代码来更有效地处理某些内置函数；例如，对 &lt;code&gt;alloca&lt;/code&gt; 的调用可能成为直接调整堆栈的单个指令，对 &lt;code&gt;memcpy&lt;/code&gt; 的调用可能成为内联复制循环。生成的代码通常更小且更快，但是由于函数调用不再像这样出现，因此您无法在这些调用上设置断点，也无法通过链接到其他库来更改函数的行为。此外，当某个功能被识别为内置功能时，GCC可能会使用有关该功能的信息来警告对该功能的调用存在问题，或者生成更有效的代码，即使结果代码仍包含对该功能的调用。例如，警告带有</target>
        </trans-unit>
        <trans-unit id="7e6e1ac548faaad8ae2131d82037c03b74f72b7e" translate="yes" xml:space="preserve">
          <source>GCC normally makes string constants read-only. If several identical-looking string constants are used, GCC stores only one copy of the string.</source>
          <target state="translated">GCC通常将字符串常量设为只读。如果使用了几个外观相同的字符串常量,GCC只存储一个字符串的副本。</target>
        </trans-unit>
        <trans-unit id="11a713f18e4fa0802eb282a6537925d48c0259a3" translate="yes" xml:space="preserve">
          <source>GCC normally uses a single instruction to load values from the GOT. While this is relatively efficient, it only works if the GOT is smaller than about 64k. Anything larger causes the linker to report an error such as:</source>
          <target state="translated">GCC通常使用一条指令从GOT中加载值。虽然这样做比较有效率,但只有当GOT小于64k时才有效。更大的则会导致链接器报告一个错误,如:。</target>
        </trans-unit>
        <trans-unit id="be424d75f5ffc48b72e433597659af0ae3069a92" translate="yes" xml:space="preserve">
          <source>GCC option.</source>
          <target state="translated">海合会选项:</target>
        </trans-unit>
        <trans-unit id="0cb280cc3350dd85b51b4e6912bba246b1815ba4" translate="yes" xml:space="preserve">
          <source>GCC permits a C structure to have no members:</source>
          <target state="translated">GCC允许C结构没有成员。</target>
        </trans-unit>
        <trans-unit id="410ccd5268fc842081ec500688897d4eab9d507c" translate="yes" xml:space="preserve">
          <source>GCC provides a couple of special builtin functions to aid in the writing of interrupt handlers in C.</source>
          <target state="translated">GCC提供了几个特殊的内置函数来帮助在C语言中编写中断处理程序。</target>
        </trans-unit>
        <trans-unit id="9a84666be4b2834544f27c65de6a453c576dd60a" translate="yes" xml:space="preserve">
          <source>GCC provides a large number of built-in functions other than the ones mentioned above. Some of these are for internal use in the processing of exceptions or variable-length argument lists and are not documented here because they may change from time to time; we do not recommend general use of these functions.</source>
          <target state="translated">除了上面提到的函数外,GCC还提供了大量的内置函数,其中有一些是内部使用的,用于处理异常或可变长度的参数列表,由于它们可能会时常变化,所以在此不作记录;我们不建议普遍使用这些函数。其中有一些是在处理异常或可变长度参数列表时内部使用的,由于它们可能会时常变化,所以在此不作记录;我们不建议普遍使用这些函数。</target>
        </trans-unit>
        <trans-unit id="dd6c408349b302ebed79b324cb6148ad8750cb77" translate="yes" xml:space="preserve">
          <source>GCC provides an interface for the PowerPC family of processors to access the AltiVec operations described in Motorola&amp;rsquo;s AltiVec Programming Interface Manual. The interface is made available by including &lt;code&gt;&amp;lt;altivec.h&amp;gt;&lt;/code&gt; and using</source>
          <target state="translated">GCC为PowerPC系列处理器提供了一个接口，以访问Motorola的《 AltiVec编程接口手册》中描述的AltiVec操作。通过包含 &lt;code&gt;&amp;lt;altivec.h&amp;gt;&lt;/code&gt; 并使用可以使用该接口</target>
        </trans-unit>
        <trans-unit id="f17fd1e9e7781f60f577293ffbb0fbe50f2aa38c" translate="yes" xml:space="preserve">
          <source>GCC provides an interface to selected machine instructions from the picoChip instruction set.</source>
          <target state="translated">GCC为picoChip指令集中选定的机器指令提供了一个接口。</target>
        </trans-unit>
        <trans-unit id="5ddbeccb51a8011bd71cee78329676c8768e012d" translate="yes" xml:space="preserve">
          <source>GCC provides built-in versions of the ISO C99 floating-point comparison macros that avoid raising exceptions for unordered operands. They have the same names as the standard macros ( &lt;code&gt;isgreater&lt;/code&gt;, &lt;code&gt;isgreaterequal&lt;/code&gt;, &lt;code&gt;isless&lt;/code&gt;, &lt;code&gt;islessequal&lt;/code&gt;, &lt;code&gt;islessgreater&lt;/code&gt;, and &lt;code&gt;isunordered&lt;/code&gt;) , with &lt;code&gt;__builtin_&lt;/code&gt; prefixed. We intend for a library implementor to be able to simply &lt;code&gt;#define&lt;/code&gt; each standard macro to its built-in equivalent. In the same fashion, GCC provides &lt;code&gt;fpclassify&lt;/code&gt;, &lt;code&gt;isfinite&lt;/code&gt;, &lt;code&gt;isinf_sign&lt;/code&gt;, &lt;code&gt;isnormal&lt;/code&gt; and &lt;code&gt;signbit&lt;/code&gt; built-ins used with &lt;code&gt;__builtin_&lt;/code&gt; prefixed. The &lt;code&gt;isinf&lt;/code&gt; and &lt;code&gt;isnan&lt;/code&gt; built-in functions appear both with and without the &lt;code&gt;__builtin_&lt;/code&gt; prefix.</source>
          <target state="translated">GCC提供了ISO C99浮点比较宏的内置版本，可避免引发无序操作数的异常。它们具有与标准宏相同的名称（ &lt;code&gt;isgreater&lt;/code&gt; ， &lt;code&gt;isgreaterequal&lt;/code&gt; ， &lt;code&gt;isless&lt;/code&gt; ， &lt;code&gt;islessequal&lt;/code&gt; ， &lt;code&gt;islessgreater&lt;/code&gt; 和 &lt;code&gt;isunordered&lt;/code&gt; ），并带有 &lt;code&gt;__builtin_&lt;/code&gt; 前缀。我们希望库实现者能够简单地 &lt;code&gt;#define&lt;/code&gt; 每个标准宏为其内置等效项。以同样的方式，GCC提供 &lt;code&gt;fpclassify&lt;/code&gt; ， &lt;code&gt;isfinite&lt;/code&gt; ， &lt;code&gt;isinf_sign&lt;/code&gt; ， &lt;code&gt;isnormal&lt;/code&gt; 和 &lt;code&gt;signbit&lt;/code&gt; 带有 &lt;code&gt;__builtin_&lt;/code&gt; 前缀的内置插件。带有和不带有 &lt;code&gt;__builtin_&lt;/code&gt; 前缀的 &lt;code&gt;isinf&lt;/code&gt; 和 &lt;code&gt;isnan&lt;/code&gt; 内置函数都会出现。</target>
        </trans-unit>
        <trans-unit id="2050dfe83adc5c7628805205b83a18bf6445e1ea" translate="yes" xml:space="preserve">
          <source>GCC provides extensions for the SPU processor as described in the Sony/Toshiba/IBM SPU Language Extensions Specification. GCC&amp;rsquo;s implementation differs in several ways.</source>
          <target state="translated">GCC提供了SPU处理器的扩展，如Sony / Toshiba / IBM SPU语言扩展规范中所述。GCC的实现在几个方面有所不同。</target>
        </trans-unit>
        <trans-unit id="e32059373d4f323b9500c52b6c9f30c837d92c67" translate="yes" xml:space="preserve">
          <source>GCC provides intrinsics to access certain instructions of the TI C6X processors. These intrinsics, listed below, are available after inclusion of the &lt;code&gt;c6x_intrinsics.h&lt;/code&gt; header file. They map directly to C6X instructions.</source>
          <target state="translated">GCC提供了访问TI C6X处理器的某些指令的内在函数。包含 &lt;code&gt;c6x_intrinsics.h&lt;/code&gt; 头文件之后，下面列出的这些内在函数可用。它们直接映射到C6X指令。</target>
        </trans-unit>
        <trans-unit id="4b78e24ee2fcd774983a8458d70a096c1f01f9ae" translate="yes" xml:space="preserve">
          <source>GCC provides intrinsics to access every instruction of the TILE-Gx processor. The intrinsics are of the form:</source>
          <target state="translated">GCC提供了访问TILE-Gx处理器的每条指令的内在因素。本质论的形式是:</target>
        </trans-unit>
        <trans-unit id="9929eef1ea9191b05967ff4d40ec8ba33acf1914" translate="yes" xml:space="preserve">
          <source>GCC provides intrinsics to access every instruction of the TILEPro processor. The intrinsics are of the form:</source>
          <target state="translated">GCC提供了访问TILEPro处理器的每条指令的内在因素。内在函数的形式是:</target>
        </trans-unit>
        <trans-unit id="ce1f47a40b55c4bca6e7d75e5dd0559de5a981c1" translate="yes" xml:space="preserve">
          <source>GCC provides intrinsics to access the SIMD instructions provided by the MSA MIPS SIMD Architecture. The interface is made available by including &lt;code&gt;&amp;lt;msa.h&amp;gt;&lt;/code&gt; and using</source>
          <target state="translated">GCC提供了内部函数来访问由MSA MIPS SIMD体系结构提供的SIMD指令。通过包含 &lt;code&gt;&amp;lt;msa.h&amp;gt;&lt;/code&gt; 并使用可以使用该接口</target>
        </trans-unit>
        <trans-unit id="40749dfbc24dc6f5a0b131fccc39dc31c09ec61c" translate="yes" xml:space="preserve">
          <source>GCC provides intrinsics to access the SIMD instructions provided by the ST Microelectronics Loongson-2E and -2F processors. These intrinsics, available after inclusion of the &lt;code&gt;loongson.h&lt;/code&gt; header file, operate on the following 64-bit vector types:</source>
          <target state="translated">GCC提供了内部函数来访问由ST Microelectronics Loongson-2E和-2F处理器提供的SIMD指令。这些内在函数在包含 &lt;code&gt;loongson.h&lt;/code&gt; 头文件之后可用，它们对以下64位向量类型进行操作：</target>
        </trans-unit>
        <trans-unit id="924dd6007d38ce7b6e1d6cc29626f87cdabebfe1" translate="yes" xml:space="preserve">
          <source>GCC provides many FR-V-specific built-in functions. In general, these functions are intended to be compatible with those described by FR-V Family, Softune C/C++ Compiler Manual (V6), Fujitsu Semiconductor. The two exceptions are &lt;code&gt;__MDUNPACKH&lt;/code&gt; and &lt;code&gt;__MBTOHE&lt;/code&gt;, the GCC forms of which pass 128-bit values by pointer rather than by value.</source>
          <target state="translated">GCC提供了许多FR-V特定的内置功能。通常，这些功能旨在与FUtsutsu Semiconductor的FR-V系列，Softune C / C ++编译器手册（V6）中描述的功能兼容。 &lt;code&gt;__MDUNPACKH&lt;/code&gt; 和 &lt;code&gt;__MBTOHE&lt;/code&gt; 这两个例外，它们的GCC形式通过指针而不是通过值传递128位值。</target>
        </trans-unit>
        <trans-unit id="9e2fa02f56a7975c68bfa6e70c41727409fe7b0c" translate="yes" xml:space="preserve">
          <source>GCC provides other MIPS-specific built-in functions:</source>
          <target state="translated">GCC提供了其他MIPS特有的内置函数。</target>
        </trans-unit>
        <trans-unit id="c10a95a94bae56390209bcb97b207903625a1bc4" translate="yes" xml:space="preserve">
          <source>GCC provides the built-in functions &lt;code&gt;__builtin_setjmp&lt;/code&gt; and &lt;code&gt;__builtin_longjmp&lt;/code&gt; which are similar to, but not interchangeable with, the C library functions &lt;code&gt;setjmp&lt;/code&gt; and &lt;code&gt;longjmp&lt;/code&gt;. The built-in versions are used internally by GCC&amp;rsquo;s libraries to implement exception handling on some targets. You should use the standard C library functions declared in &lt;code&gt;&amp;lt;setjmp.h&amp;gt;&lt;/code&gt; in user code instead of the builtins.</source>
          <target state="translated">GCC提供了内置函数 &lt;code&gt;__builtin_setjmp&lt;/code&gt; 和 &lt;code&gt;__builtin_longjmp&lt;/code&gt; ，它们与C库函数 &lt;code&gt;setjmp&lt;/code&gt; 和 &lt;code&gt;longjmp&lt;/code&gt; 相似，但不能互换。内置版本供GCC的库内部使用，以在某些目标上实现异常处理。您应该在用户代码中使用在 &lt;code&gt;&amp;lt;setjmp.h&amp;gt;&lt;/code&gt; 中声明的标准C库函数，而不要使用内置函数。</target>
        </trans-unit>
        <trans-unit id="9735e9559d39719652bb957e983b7d2a3d2f7126" translate="yes" xml:space="preserve">
          <source>GCC provides three magic constants that hold the name of the current function as a string. In C++11 and later modes, all three are treated as constant expressions and can be used in &lt;code&gt;constexpr&lt;/code&gt; constexts. The first of these constants is &lt;code&gt;__func__&lt;/code&gt;, which is part of the C99 standard:</source>
          <target state="translated">GCC提供了三个魔术常数，它们将当前函数的名称保存为字符串。在C ++ 11和更高版本的模式中，所有这三种都被视为常量表达式，并且可以在 &lt;code&gt;constexpr&lt;/code&gt; 上下文中使用。这些常量的第一个是 &lt;code&gt;__func__&lt;/code&gt; ，它是C99标准的一部分：</target>
        </trans-unit>
        <trans-unit id="2948277f494886df96fe31449754e2666c1dabe5" translate="yes" xml:space="preserve">
          <source>GCC provides two interfaces for accessing the Hardware Transactional Memory (HTM) instructions available on some of the PowerPC family of processors (eg, POWER8). The two interfaces come in a low level interface, consisting of built-in functions specific to PowerPC and a higher level interface consisting of inline functions that are common between PowerPC and S/390.</source>
          <target state="translated">GCC提供了两个接口,用于访问某些PowerPC系列处理器(如POWER8)上可用的硬件事务存储器(HTM)指令。这两个接口有一个低级接口,由PowerPC特有的内置函数组成,还有一个高级接口,由PowerPC和S/390之间通用的内联函数组成。</target>
        </trans-unit>
        <trans-unit id="f29e392d59a7180cc6e4238e88b7157ffcf6417f" translate="yes" xml:space="preserve">
          <source>GCC stands for &amp;ldquo;GNU Compiler Collection&amp;rdquo;. GCC is an integrated distribution of compilers for several major programming languages. These languages currently include C, C++, Objective-C, Objective-C++, Fortran, Ada, D, Go, and BRIG (HSAIL).</source>
          <target state="translated">GCC代表&amp;ldquo; GNU编译器集合&amp;rdquo;。GCC是几种主要编程语言的编译器的集成发行版。这些语言当前包括C，C ++，Objective-C，Objective-C ++，Fortran，Ada，D，Go和BRIG（HSAIL）。</target>
        </trans-unit>
        <trans-unit id="1d5a85fa7b27fa126424357ffe5ddd8aadcd2aa6" translate="yes" xml:space="preserve">
          <source>GCC support of decimal float as specified by the draft technical report is incomplete:</source>
          <target state="translated">海合会对技术报告草案规定的十进制浮点数的支持是不完整的。</target>
        </trans-unit>
        <trans-unit id="28561e4b3e7debdbfb6dbdfe238413f5b85b54ce" translate="yes" xml:space="preserve">
          <source>GCC support of fixed-point types as specified by the draft technical report is incomplete:</source>
          <target state="translated">GCC对技术报告草案规定的定点类型的支持是不完整的。</target>
        </trans-unit>
        <trans-unit id="1fa5de60932a0f2deade437763dee9d9034d0c2f" translate="yes" xml:space="preserve">
          <source>GCC supports &amp;ldquo;traditional&amp;rdquo; Objective-C (also known as &amp;ldquo;Objective-C 1.0&amp;rdquo;) and contains support for the Objective-C exception and synchronization syntax. It has also support for a number of &amp;ldquo;Objective-C 2.0&amp;rdquo; language extensions, including properties, fast enumeration (only for Objective-C), method attributes and the @optional and @required keywords in protocols. GCC supports Objective-C++ and features available in Objective-C are also available in Objective-C++.</source>
          <target state="translated">GCC支持&amp;ldquo;传统&amp;rdquo; Objective-C（也称为&amp;ldquo; Objective-C 1.0&amp;rdquo;），并包含对Objective-C异常和同步语法的支持。它还支持许多&amp;ldquo; Objective-C 2.0&amp;rdquo;语言扩展，包括属性，快速枚举（仅适用于Objective-C），方法属性以及协议中的@optional和@required关键字。GCC支持Objective-C ++，Objective-C中可用的功能也在Objective-C ++中可用。</target>
        </trans-unit>
        <trans-unit id="830690076ebfb70e332b381ddb9fe46655004637" translate="yes" xml:space="preserve">
          <source>GCC supports MIPS DSP operations using both the generic vector extensions (see &lt;a href=&quot;vector-extensions#Vector-Extensions&quot;&gt;Vector Extensions&lt;/a&gt;) and a collection of MIPS-specific built-in functions. Both kinds of support are enabled by the</source>
          <target state="translated">GCC同时使用通用向量扩展（请参阅&lt;a href=&quot;vector-extensions#Vector-Extensions&quot;&gt;Vector Extensions&lt;/a&gt;）和特定于MIPS的内置函数的集合来支持MIPS DSP操作。两种支持均由</target>
        </trans-unit>
        <trans-unit id="8d83e55eff0bd290fe83057edfb4aff0d4da11fc" translate="yes" xml:space="preserve">
          <source>GCC supports SIMD operations on the SPARC using both the generic vector extensions (see &lt;a href=&quot;vector-extensions#Vector-Extensions&quot;&gt;Vector Extensions&lt;/a&gt;) as well as built-in functions for the SPARC Visual Instruction Set (VIS). When you use the</source>
          <target state="translated">GCC使用通用矢量扩展名（请参见&lt;a href=&quot;vector-extensions#Vector-Extensions&quot;&gt;Vector Extensions&lt;/a&gt;）以及SPARC可视指令集（VIS）的内置函数，支持SPARC上的SIMD操作。当您使用</target>
        </trans-unit>
        <trans-unit id="76e5e7f27add586f752fd2c88bf216b480271ed7" translate="yes" xml:space="preserve">
          <source>GCC supports a &lt;code&gt;#pragma&lt;/code&gt; directive that changes the name used in assembly for a given declaration. While this pragma is supported on all platforms, it is intended primarily to provide compatibility with the Solaris system headers. This effect can also be achieved using the asm labels extension (see &lt;a href=&quot;asm-labels#Asm-Labels&quot;&gt;Asm Labels&lt;/a&gt;).</source>
          <target state="translated">GCC支持 &lt;code&gt;#pragma&lt;/code&gt; 指令，该指令可更改给定声明在汇编中使用的名称。尽管所有平台都支持此编译指示，但其主要目的是提供与Solaris系统标头的兼容性。使用asm标签扩展名也可以实现这种效果（请参阅&lt;a href=&quot;asm-labels#Asm-Labels&quot;&gt;Asm Labels&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="498314540c8d67676764e9f766eda8fd96a7daed" translate="yes" xml:space="preserve">
          <source>GCC supports a number of command-line options that control adding run-time instrumentation to the code it normally generates. For example, one purpose of instrumentation is collect profiling statistics for use in finding program hot spots, code coverage analysis, or profile-guided optimizations. Another class of program instrumentation is adding run-time checking to detect programming errors like invalid pointer dereferences or out-of-bounds array accesses, as well as deliberately hostile attacks such as stack smashing or C++ vtable hijacking. There is also a general hook which can be used to implement other forms of tracing or function-level instrumentation for debug or program analysis purposes.</source>
          <target state="translated">GCC支持许多命令行选项,这些选项可以控制在它通常生成的代码中添加运行时工具。例如,工具化的一个目的是收集剖析统计数据,用于查找程序热点、代码覆盖率分析或剖析引导的优化。另一类程序工具化是增加运行时检查,以检测程序错误,如无效指针取消引用或越界数组访问,以及故意的敌对攻击,如堆栈粉碎或C++vtable hijacking。还有一个通用的钩子,可以用来实现其他形式的跟踪或函数级工具,以达到调试或程序分析的目的。</target>
        </trans-unit>
        <trans-unit id="1030e6dea2c81b69bdc7270b03b39b5f569ad6fa" translate="yes" xml:space="preserve">
          <source>GCC supports a variant of the o32 ABI in which floating-point registers are 64 rather than 32 bits wide. You can select this combination with</source>
          <target state="translated">GCC支持o32 ABI的变体,其中浮点寄存器的宽度是64位而不是32位。您可以用</target>
        </trans-unit>
        <trans-unit id="c3965449e7a5dc4d5ed8a9dc3199dec909c35dc5" translate="yes" xml:space="preserve">
          <source>GCC supports only two&amp;rsquo;s complement integer types, and all bit patterns are ordinary values.</source>
          <target state="translated">GCC仅支持二进制补码类型，所有位模式均为普通值。</target>
        </trans-unit>
        <trans-unit id="83dd0c21621e0a6e0dd523c863cbfaef04449bd4" translate="yes" xml:space="preserve">
          <source>GCC supports paired-single operations using both the generic vector extensions (see &lt;a href=&quot;vector-extensions#Vector-Extensions&quot;&gt;Vector Extensions&lt;/a&gt;) and a collection of MIPS-specific built-in functions. Both kinds of support are enabled by the</source>
          <target state="translated">GCC支持使用通用向量扩展名（请参见&lt;a href=&quot;vector-extensions#Vector-Extensions&quot;&gt;Vector Extensions&lt;/a&gt;）和一组MIPS特定的内置函数来进行成对的单操作。两种支持均由</target>
        </trans-unit>
        <trans-unit id="b55fc398fe2655fec7265522ba909be632a50b88" translate="yes" xml:space="preserve">
          <source>GCC supports several types of pragmas, primarily in order to compile code originally written for other compilers. Note that in general we do not recommend the use of pragmas; See &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;Function Attributes&lt;/a&gt;, for further explanation.</source>
          <target state="translated">GCC支持多种类型的编译指示，主要是为了编译最初为其他编译器编写的代码。请注意，一般而言，我们不建议您使用编译指示。有关更多说明，请参见&lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;功能属性&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="653525fcb8a016916ca28e1dd65b18ab8839e4b5" translate="yes" xml:space="preserve">
          <source>GCC supports some of the RX instructions which cannot be expressed in the C programming language via the use of built-in functions. The following functions are supported:</source>
          <target state="translated">GCC支持一些无法通过使用内置函数在C语言编程中表达的RX指令。支持以下函数:</target>
        </trans-unit>
        <trans-unit id="4b0cba78b946248aec959caf8a965144462518ce" translate="yes" xml:space="preserve">
          <source>GCC supports the D 2.0 programming language. The D language itself is currently defined by its reference implementation and supporting language specification, described at &lt;a href=&quot;https://dlang.org/spec/spec.html&quot;&gt;https://dlang.org/spec/spec.html&lt;/a&gt;.</source>
          <target state="translated">GCC支持D 2.0编程语言。D语言本身当前由其参考实现和支持的语言规范定义，请参见&lt;a href=&quot;https://dlang.org/spec/spec.html&quot;&gt;https://dlang.org/spec/spec.html&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="359d53772696a2b7864fe27fe3565593d8a4b28c" translate="yes" xml:space="preserve">
          <source>GCC supports the following AVR devices and ISAs:</source>
          <target state="translated">GCC支持以下AVR设备和ISA。</target>
        </trans-unit>
        <trans-unit id="2ea7c76cda0c4fbb899bd829aa15b4c8a69297f6" translate="yes" xml:space="preserve">
          <source>GCC supports the original ISO C++ standard published in 1998, and the 2011 and 2014 revisions.</source>
          <target state="translated">GCC支持1998年发布的原始ISO C++标准,以及2011年和2014年的修订版。</target>
        </trans-unit>
        <trans-unit id="858a69c7492112ce45741ecc79e61821fd61a803" translate="yes" xml:space="preserve">
          <source>GCC supports these options when compiling for C-SKY V2 processors.</source>
          <target state="translated">在为C-SKY V2处理器编译时,GCC支持这些选项。</target>
        </trans-unit>
        <trans-unit id="0dc67ad6d4b46256a65720385ae1177b91b75554" translate="yes" xml:space="preserve">
          <source>GCC supports two forms of SVE code generation: &amp;ldquo;vector-length agnostic&amp;rdquo; output that works with any size of vector register and &amp;ldquo;vector-length specific&amp;rdquo; output that allows GCC to make assumptions about the vector length when it is useful for optimization reasons. The possible values of &amp;lsquo;</source>
          <target state="translated">GCC支持两种形式的SVE代码生成：&amp;ldquo;向量长度不可知&amp;rdquo;输出可与任何大小的向量寄存器一起使用，&amp;ldquo;向量长度特定&amp;rdquo;输出可让GCC在出于优化原因而有用时对向量长度进行假设。'的可能值</target>
        </trans-unit>
        <trans-unit id="5b3ded850043ac176423c8bd10dd3fbbab6dc5cd" translate="yes" xml:space="preserve">
          <source>GCC treats all characters of identifiers as significant. According to K&amp;amp;R-1 (2.2), &amp;ldquo;No more than the first eight characters are significant, although more may be used.&amp;rdquo;. Also according to K&amp;amp;R-1 (2.2), &amp;ldquo;An identifier is a sequence of letters and digits; the first character must be a letter. The underscore _ counts as a letter.&amp;rdquo;, but GCC also allows dollar signs in identifiers.</source>
          <target state="translated">GCC将标识符的所有字符视为有效字符。根据K＆R-1（2.2），&amp;ldquo;虽然可以使用更多的字符，但前八个字符的有效位数不超过。&amp;rdquo;。同样根据K＆R-1（2.2），&amp;ldquo;标识符是由字母和数字组成的序列；第一个字符必须是字母。下划线_视为字母。&amp;rdquo;，但GCC还允许在标识符中使用美元符号。</target>
        </trans-unit>
        <trans-unit id="feaee8cb866302ba1b5ec59a1ce37d673602a1f3" translate="yes" xml:space="preserve">
          <source>GCC uses &lt;var&gt;name&lt;/var&gt; to determine what kind of instructions it can emit when generating assembly code (as if by</source>
          <target state="translated">GCC使用 &lt;var&gt;name&lt;/var&gt; 来确定在生成汇编代码时可以发出哪种指令（就像通过</target>
        </trans-unit>
        <trans-unit id="66e1ddf3758925ad2362fd6f220c229932999055" translate="yes" xml:space="preserve">
          <source>GCC uses &lt;var&gt;name&lt;/var&gt; to determine what kind of instructions it can emit when generating assembly code. If</source>
          <target state="translated">GCC使用 &lt;var&gt;name&lt;/var&gt; 来确定生成汇编代码时可以发出的指令类型。如果</target>
        </trans-unit>
        <trans-unit id="813ae2789d4b6769128e82ee496ab87522d87f2b" translate="yes" xml:space="preserve">
          <source>GCC uses a garbage collector to manage its own memory allocation. This parameter specifies the minimum percentage by which the garbage collector&amp;rsquo;s heap should be allowed to expand between collections. Tuning this may improve compilation speed; it has no effect on code generation.</source>
          <target state="translated">GCC使用垃圾回收器来管理自己的内存分配。此参数指定允许垃圾收集器的堆在收集之间扩展的最小百分比。进行调整可以提高编译速度；它对代码生成没有影响。</target>
        </trans-unit>
        <trans-unit id="ae9ac11b129e57b155bc25157be869b1b76e80ad" translate="yes" xml:space="preserve">
          <source>GCC uses corrected versions of system header files. This is necessary, but doesn&amp;rsquo;t always work smoothly.</source>
          <target state="translated">GCC使用系统头文件的更正版本。这是必要的，但并不总是能顺利进行。</target>
        </trans-unit>
        <trans-unit id="819a72ed7eaf70f991d756c9fa760994a62ab526" translate="yes" xml:space="preserve">
          <source>GCC uses heuristics to guess branch probabilities if they are not provided by profiling feedback (</source>
          <target state="translated">GCC使用启发式方法来猜测分支概率,如果它们不是由剖析反馈提供的(</target>
        </trans-unit>
        <trans-unit id="1a8376e3c4e7645e0b124141064b06d15d9df6a1" translate="yes" xml:space="preserve">
          <source>GCC uses the system C library, which might not be compliant with the ISO C standard.</source>
          <target state="translated">GCC使用系统C库,可能不符合ISO C标准。</target>
        </trans-unit>
        <trans-unit id="ca6cd448f1a33799ac2da1a0d9dfa000cd6841ec" translate="yes" xml:space="preserve">
          <source>GCC will not inline any functions if the</source>
          <target state="translated">GCC将不会内联任何函数,如果在</target>
        </trans-unit>
        <trans-unit id="8a47996357771546a1d05e5991be4fe03520b6e5" translate="yes" xml:space="preserve">
          <source>GCC&amp;rsquo;s default behavior is to emit all inline functions with the &lt;code&gt;dllexport&lt;/code&gt; attribute. Since this can cause object file-size bloat, you can use</source>
          <target state="translated">GCC的默认行为是发出所有具有 &lt;code&gt;dllexport&lt;/code&gt; 属性的内联函数。由于这可能会导致目标文件大小膨胀，因此可以使用</target>
        </trans-unit>
        <trans-unit id="af8e45be98e36024842dc1bd8893718108d0574b" translate="yes" xml:space="preserve">
          <source>GCC&amp;rsquo;s implementation of the high-level language interface available from C and C++ code differs from Motorola&amp;rsquo;s documentation in several ways.</source>
          <target state="translated">GCC对C和C ++代码提供的高级语言接口的实现在几个方面与Motorola的文档不同。</target>
        </trans-unit>
        <trans-unit id="e78ca1e1182b55c5bde4b195b5d85015058a98d0" translate="yes" xml:space="preserve">
          <source>GCC&amp;rsquo;s optimizers do not treat this code like the non-volatile code in the earlier examples. They do not move it out of loops or omit it on the assumption that the result from a previous call is still valid.</source>
          <target state="translated">GCC的优化器不会像前面示例中的非易失性代码那样对待此代码。他们不会将其移出循环，也不会在先前调用结果仍然有效的前提下忽略它。</target>
        </trans-unit>
        <trans-unit id="dbc61f28ee0b681eff97897cb82a2c8d282dc076" translate="yes" xml:space="preserve">
          <source>GCC&amp;rsquo;s optimizers sometimes discard &lt;code&gt;asm&lt;/code&gt; statements if they determine there is no need for the output variables. Also, the optimizers may move code out of loops if they believe that the code will always return the same result (i.e. none of its input values change between calls). Using the &lt;code&gt;volatile&lt;/code&gt; qualifier disables these optimizations. &lt;code&gt;asm&lt;/code&gt; statements that have no output operands, including &lt;code&gt;asm goto&lt;/code&gt; statements, are implicitly volatile.</source>
          <target state="translated">如果GCC的优化程序确定不需要输出变量，则有时会丢弃 &lt;code&gt;asm&lt;/code&gt; 语句。同样，如果优化人员认为代码将始终返回相同的结果（即，两次调用之间的输入值均不变），则可以将代码移出循环。使用 &lt;code&gt;volatile&lt;/code&gt; 限定词将禁用这些优化。没有输出操作数的 &lt;code&gt;asm&lt;/code&gt; 语句（包括 &lt;code&gt;asm goto&lt;/code&gt; 语句）是隐式易失的。</target>
        </trans-unit>
        <trans-unit id="1e750d3c829a6b818589899b42ede982312a7f98" translate="yes" xml:space="preserve">
          <source>GCOV_ERROR_FILE</source>
          <target state="translated">GCOV_ERROR_FILE</target>
        </trans-unit>
        <trans-unit id="e485aa772b73ea7b58dcf4966c0a2d3b9c745805" translate="yes" xml:space="preserve">
          <source>GCOV_EXIT_AT_ERROR</source>
          <target state="translated">GCOV_EXIT_AT_ERROR</target>
        </trans-unit>
        <trans-unit id="80aecc9b56754f32438dd132183cddc7e4df32f1" translate="yes" xml:space="preserve">
          <source>GCOV_PREFIX contains the prefix to add to the absolute paths in the object file. Prefix can be absolute, or relative. The default is no prefix.</source>
          <target state="translated">GCOV_PREFIX包含了要添加到对象文件中绝对路径的前缀。前缀可以是绝对的,也可以是相对的。默认情况下是没有前缀。</target>
        </trans-unit>
        <trans-unit id="891aee4538b1a332bb00b85c9e7c43d1cf40d1d1" translate="yes" xml:space="preserve">
          <source>GCOV_PREFIX=/target/run</source>
          <target state="translated">GCOV_PREFIX=/target/run</target>
        </trans-unit>
        <trans-unit id="f0bcf8de4466a3194e31ce81577ad85f4f449ccb" translate="yes" xml:space="preserve">
          <source>GCOV_PREFIX_STRIP indicates the how many initial directory names to strip off the hardwired absolute paths. Default value is 0.</source>
          <target state="translated">GCOV_PREFIX_STRIP 表示要从硬线绝对路径上剥离多少个初始目录名。默认值为0。</target>
        </trans-unit>
        <trans-unit id="7069713a73584b12e5e1b6c6673abb78172fe103" translate="yes" xml:space="preserve">
          <source>GCOV_PREFIX_STRIP=1</source>
          <target state="translated">GCOV_PREFIX_STRIP=1</target>
        </trans-unit>
        <trans-unit id="a007084938316d2847460b0f869fd2dab151324f" translate="yes" xml:space="preserve">
          <source>GFNI instructions.</source>
          <target state="translated">GFNI指示:</target>
        </trans-unit>
        <trans-unit id="768001d59e5da45e8ce2de4652950a5db0123cf5" translate="yes" xml:space="preserve">
          <source>GNU C allows you to associate specific hardware registers with C variables. In almost all cases, allowing the compiler to assign registers produces the best code. However under certain unusual circumstances, more precise control over the variable storage is required.</source>
          <target state="translated">GNU C允许您将特定的硬件寄存器与C变量相关联。几乎在所有情况下,允许编译器分配寄存器都能产生最好的代码。但是在某些特殊情况下,需要对变量的存储进行更精确的控制。</target>
        </trans-unit>
        <trans-unit id="1282a7948680a82fce143391cee57deb8d315356" translate="yes" xml:space="preserve">
          <source>GNU C extends ISO C to allow a function prototype to override a later old-style non-prototype definition. Consider the following example:</source>
          <target state="translated">GNU C扩展了ISO C,允许一个函数原型覆盖一个后来的旧式非原型定义。请看下面的例子。</target>
        </trans-unit>
        <trans-unit id="e77e07d95404402b67fc9bef0aec0c9a34ecc38f" translate="yes" xml:space="preserve">
          <source>GNU C provides several language features not found in ISO standard C. (The</source>
          <target state="translated">GNU C提供了一些ISO标准C中没有的语言特性。</target>
        </trans-unit>
        <trans-unit id="d45fbb49066a76f230e9020bfe458e74293358d2" translate="yes" xml:space="preserve">
          <source>GNU C++ does not support old-style function definitions, so this extension is irrelevant.</source>
          <target state="translated">GNU C++不支持旧式函数定义,所以这个扩展是不相关的。</target>
        </trans-unit>
        <trans-unit id="2ba257a10dfda1a80f343df43a5f9faccbca64b3" translate="yes" xml:space="preserve">
          <source>GNU CPP has two further variadic macro extensions, and permits them to be used with either of the above forms of macro definition.</source>
          <target state="translated">GNU CPP 又有两个变量宏扩展,并允许它们与上述任何一种形式的宏定义一起使用。</target>
        </trans-unit>
        <trans-unit id="9dbaa828d6809d3452cb2a6728f3023aae5a8b22" translate="yes" xml:space="preserve">
          <source>GNU CPP permits you to completely omit the variable arguments in this way. In the above examples, the compiler would complain, though since the expansion of the macro still has the extra comma after the format string.</source>
          <target state="translated">GNU CPP 允许你用这种方式完全省略变量参数。在上面的例子中,虽然编译器会抱怨,但因为宏的扩展仍然在格式字符串后多了一个逗号。</target>
        </trans-unit>
        <trans-unit id="0e4ec8a54cfff9c2845fa38842cb6cd1bdea197d" translate="yes" xml:space="preserve">
          <source>GNU Free Documentation License</source>
          <target state="translated">GNU 自由文档许可证</target>
        </trans-unit>
        <trans-unit id="d9cbf0740e34d88c506fb7df6e17deeabd18660c" translate="yes" xml:space="preserve">
          <source>GNU General Public License</source>
          <target state="translated">GNU通用公共许可证</target>
        </trans-unit>
        <trans-unit id="ea5447d52819458fc788d8fe66484dcf6f8b58c5" translate="yes" xml:space="preserve">
          <source>GNU General Public License says how you can copy and share GCC.</source>
          <target state="translated">GNU通用公共许可证规定了如何复制和共享GCC。</target>
        </trans-unit>
        <trans-unit id="a21d2651a31b14abba6b9f4cc89e6d16156a2f47" translate="yes" xml:space="preserve">
          <source>GNU Objective-C provides constant string objects that are generated directly by the compiler. You declare a constant string object by prefixing a C constant string with the character &amp;lsquo;</source>
          <target state="translated">GNU Objective-C提供了由编译器直接生成的常量字符串对象。您可以通过在C常量字符串前面添加字符'来声明常量字符串对象</target>
        </trans-unit>
        <trans-unit id="d4b0f24c5578d309a3a80bcf9db1efef7dc80491" translate="yes" xml:space="preserve">
          <source>GNU Objective-C provides exception support built into the language, as in the following example:</source>
          <target state="translated">GNU Objective-C提供了内置于语言中的异常支持,如下面的例子。</target>
        </trans-unit>
        <trans-unit id="183b8b6fa7f0ebe7cc24b6e6b64ea37e46538bc2" translate="yes" xml:space="preserve">
          <source>GNU Objective-C provides support for synchronized blocks:</source>
          <target state="translated">GNU Objective-C提供了对同步块的支持。</target>
        </trans-unit>
        <trans-unit id="5a76f04c435b8a53e2673208f47df13d27337155" translate="yes" xml:space="preserve">
          <source>GNU Objective-C provides support for the fast enumeration syntax:</source>
          <target state="translated">GNU Objective-C提供了对快速枚举语法的支持。</target>
        </trans-unit>
        <trans-unit id="bd8453bc7fd0b5c5a5eb0b2fb1cc7653d6106ce4" translate="yes" xml:space="preserve">
          <source>GNU Objective-C runtime features.</source>
          <target state="translated">GNU Objective-C运行时特性。</target>
        </trans-unit>
        <trans-unit id="dc4139cbd1ca2e4ec1fdbaf154a309856bbea2a6" translate="yes" xml:space="preserve">
          <source>GNU Objective-C supports the &lt;code&gt;@encode&lt;/code&gt; syntax that allows you to create a type encoding from a C/Objective-C type. For example, &lt;code&gt;@encode(int)&lt;/code&gt; is compiled by the compiler into &lt;code&gt;&quot;i&quot;&lt;/code&gt;.</source>
          <target state="translated">GNU Objective-C支持 &lt;code&gt;@encode&lt;/code&gt; 语法，该语法允许您从C / Objective-C类型创建类型编码。例如， &lt;code&gt;@encode(int)&lt;/code&gt; 由编译器编译为 &lt;code&gt;&quot;i&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="72bdab580bf81d58abe49ef7feb3d22b198aca72" translate="yes" xml:space="preserve">
          <source>GNU dialect of</source>
          <target state="translated">GNU方言</target>
        </trans-unit>
        <trans-unit id="0cce44d2e046653755b9171f853b5aa7f7510c0f" translate="yes" xml:space="preserve">
          <source>GNU dialect of ISO C11. The name &amp;lsquo;</source>
          <target state="translated">ISO C11的GNU方言。名字 '</target>
        </trans-unit>
        <trans-unit id="17c597be9d56a306b84e8b735a051e0b49bf682b" translate="yes" xml:space="preserve">
          <source>GNU dialect of ISO C17. This is the default for C code.</source>
          <target state="translated">ISO C17的GNU方言。这是C代码的默认值。</target>
        </trans-unit>
        <trans-unit id="cd7ba84a6cf37a43cdd1bd215e060138c20d80ef" translate="yes" xml:space="preserve">
          <source>GNU dialect of ISO C90 (including some C99 features).</source>
          <target state="translated">ISO C90的GNU方言(包括一些C99特性)。</target>
        </trans-unit>
        <trans-unit id="5a96bf0e0eb1648d92a5415bbf82f314f50fc95d" translate="yes" xml:space="preserve">
          <source>GNU dialect of ISO C99. The name &amp;lsquo;</source>
          <target state="translated">ISO C99的GNU方言。名字 '</target>
        </trans-unit>
        <trans-unit id="c7513a88e6766734c8fff0b65e9260cb06e07819" translate="yes" xml:space="preserve">
          <source>GNU extensions to the C language family.</source>
          <target state="translated">GNU对C语言家族的扩展。</target>
        </trans-unit>
        <trans-unit id="90b8cbfe3e7aa922a28ad77fd2468b165d25db6d" translate="yes" xml:space="preserve">
          <source>GNU extensions to the C++ language.</source>
          <target state="translated">GNU对C++语言的扩展。</target>
        </trans-unit>
        <trans-unit id="73a49c549f68005dbe48c29ca2788c5808080012" translate="yes" xml:space="preserve">
          <source>General purpose register if 64-bit instructions are enabled or NO_REGS.</source>
          <target state="translated">如果启用64位指令或NO_REGS,则为通用寄存器。</target>
        </trans-unit>
        <trans-unit id="005c5bd36bc2dae00112330a475935d63f7703b1" translate="yes" xml:space="preserve">
          <source>General register 1</source>
          <target state="translated">总登记册1</target>
        </trans-unit>
        <trans-unit id="b09ef9c6988403ff1cf426fea1c658c5b1f6be6e" translate="yes" xml:space="preserve">
          <source>General register &lt;code&gt;r0&lt;/code&gt; to &lt;code&gt;r3&lt;/code&gt; for &lt;code&gt;addl&lt;/code&gt; instruction</source>
          <target state="translated">用于 &lt;code&gt;addl&lt;/code&gt; 指令的通用寄存器 &lt;code&gt;r0&lt;/code&gt; 至 &lt;code&gt;r3&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e89cc1c76441abdf1cb24c29330f5f35d304a8e7" translate="yes" xml:space="preserve">
          <source>General register, but not &lt;code&gt;r29&lt;/code&gt;, &lt;code&gt;r30&lt;/code&gt; and &lt;code&gt;r31&lt;/code&gt;</source>
          <target state="translated">通用寄存器，但不是 &lt;code&gt;r29&lt;/code&gt; ， &lt;code&gt;r30&lt;/code&gt; 和 &lt;code&gt;r31&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="10bd548f00f5df8e11316ab27529f8ec0d489ead" translate="yes" xml:space="preserve">
          <source>General-purpose 32-bit register</source>
          <target state="translated">通用32位寄存器</target>
        </trans-unit>
        <trans-unit id="d86490a439329533a7fda073910d458d177b7499" translate="yes" xml:space="preserve">
          <source>Generally there is no guarantee that a memory transaction ever succeeds and suitable fallback code always needs to be supplied.</source>
          <target state="translated">一般来说,不能保证内存事务永远成功,总是需要提供合适的回退代码。</target>
        </trans-unit>
        <trans-unit id="c220eb05478a76fade659e7f472b8e896908bfb7" translate="yes" xml:space="preserve">
          <source>Generally, functions are not inlined unless optimization is specified. For functions declared inline, this attribute inlines the function independent of any restrictions that otherwise apply to inlining. Failure to inline such a function is diagnosed as an error. Note that if such a function is called indirectly the compiler may or may not inline it depending on optimization level and a failure to inline an indirect call may or may not be diagnosed.</source>
          <target state="translated">一般来说,除非指定优化,否则函数不会内联。对于声明为内联的函数,该属性将内联该函数,而不受任何其他适用于内联的限制。未能内联这样的函数会被诊断为错误。请注意,如果这样的函数被间接调用,编译器可能会根据优化级别对其进行内联,也可能不会对间接调用进行内联诊断。</target>
        </trans-unit>
        <trans-unit id="84a7c319c3d7d28e18ecbf416836eecf761297c6" translate="yes" xml:space="preserve">
          <source>Generally, inlining into a function is limited. For a function marked with this attribute, every call inside this function is inlined, if possible. Functions declared with attribute &lt;code&gt;noinline&lt;/code&gt; and similar are not inlined. Whether the function itself is considered for inlining depends on its size and the current inlining parameters.</source>
          <target state="translated">通常，内联到函数是有限的。对于标有该属性的函数，如果可能，将内联该函数内的每个调用。用属性 &lt;code&gt;noinline&lt;/code&gt; 和类似属性声明的函数不进行内联。是否考虑对函数本身进行内联取决于其大小和当前的内联参数。</target>
        </trans-unit>
        <trans-unit id="da79890df831b8b599903d6736d5d918432eda2d" translate="yes" xml:space="preserve">
          <source>Generally, options specified at link time override those specified at compile time, although in some cases GCC attempts to infer link-time options from the settings used to compile the input files.</source>
          <target state="translated">一般来说,在链接时指定的选项会覆盖在编译时指定的选项,尽管在某些情况下,GCC会尝试从编译输入文件的设置中推断链接时的选项。</target>
        </trans-unit>
        <trans-unit id="ba4adeb327e032d99cfca5b51d0fd4daaa9b56fc" translate="yes" xml:space="preserve">
          <source>Generate (do not generate) ColdFire hardware divide and remainder instructions. If</source>
          <target state="translated">生成(不生成)ColdFire硬件除法和余数指令。如果</target>
        </trans-unit>
        <trans-unit id="0fe80a59bc1a906ccb8af3fc3416cadc3264624c" translate="yes" xml:space="preserve">
          <source>Generate (do not generate) GP-relative accesses. The following &lt;var&gt;option&lt;/var&gt; names are recognized:</source>
          <target state="translated">生成（不生成）GP相对访问。可以识别以下 &lt;var&gt;option&lt;/var&gt; 名称：</target>
        </trans-unit>
        <trans-unit id="09abd950717c564f7150fc3aedac403b36224304" translate="yes" xml:space="preserve">
          <source>Generate (do not generate) MIPS16 code. If GCC is targeting a MIPS32 or MIPS64 architecture, it makes use of the MIPS16e ASE.</source>
          <target state="translated">生成(不生成)MIPS16代码。如果GCC的目标是MIPS32或MIPS64架构,它就会使用MIPS16e ASE。</target>
        </trans-unit>
        <trans-unit id="188ec1e266203e4853a13748340fc36d3e35234e" translate="yes" xml:space="preserve">
          <source>Generate (do not generate) code that is fully position-independent, and that can therefore be linked into shared libraries. This option only affects</source>
          <target state="translated">生成(不生成)完全与位置无关的代码,因此可以链接到共享库中。这个选项只适用于</target>
        </trans-unit>
        <trans-unit id="0a056a294949b854726ab099acb14488ae9baeac" translate="yes" xml:space="preserve">
          <source>Generate (do not generate) code that is suitable for SVR4-style dynamic objects.</source>
          <target state="translated">生成(不生成)适合SVR4风格的动态对象的代码。</target>
        </trans-unit>
        <trans-unit id="200f92cbd3d74fb5f3e648ecaaea7b69d566f040" translate="yes" xml:space="preserve">
          <source>Generate (do not generate) code that uses &lt;em&gt;base addresses&lt;/em&gt;. Using a base address automatically generates a request (handled by the assembler and the linker) for a constant to be set up in a global register. The register is used for one or more base address requests within the range 0 to 255 from the value held in the register. The generally leads to short and fast code, but the number of different data items that can be addressed is limited. This means that a program that uses lots of static data may require</source>
          <target state="translated">生成（不生成）使用&lt;em&gt;基地址的&lt;/em&gt;代码。使用基地址会自动生成一个请求（由汇编器和链接器处理），以请求在全局寄存器中设置一个常量。该寄存器用于从寄存器中保存的值开始的0到255范围内的一个或多个基址请求。通常导致短而快速的代码，但是可以寻址的不同数据项的数量是有限的。这意味着使用大量静态数据的程序可能需要</target>
        </trans-unit>
        <trans-unit id="fc8c5a89f214acd8179a09f487fb87bbd0d7c872" translate="yes" xml:space="preserve">
          <source>Generate (do not generate) code to load up the static chain register (&lt;code&gt;r11&lt;/code&gt;) when calling through a pointer on AIX and 64-bit Linux systems where a function pointer points to a 3-word descriptor giving the function address, TOC value to be loaded in register &lt;code&gt;r2&lt;/code&gt;, and static chain value to be loaded in register &lt;code&gt;r11&lt;/code&gt;. The</source>
          <target state="translated">在AIX和64位Linux系统上通过指针进行调用时，生成（不生成）代码以加载静态链寄存器（ &lt;code&gt;r11&lt;/code&gt; ），其中函数指针指向3字描述符，给出函数地址，TOC值为加载到寄存器 &lt;code&gt;r2&lt;/code&gt; 中，并将静态链值加载到寄存器 &lt;code&gt;r11&lt;/code&gt; 中。的</target>
        </trans-unit>
        <trans-unit id="813e9e6ca1642f726fee97bfddf02338960484b7" translate="yes" xml:space="preserve">
          <source>Generate (do not generate) code to pass structure parameters with a maximum alignment of 64 bits, for compatibility with older versions of GCC.</source>
          <target state="translated">生成(不生成)传递结构参数的代码,最大对齐度为64位,以兼容旧版本的GCC。</target>
        </trans-unit>
        <trans-unit id="55cac71e3fa8543a26a5b7f404ac565adfa17f28" translate="yes" xml:space="preserve">
          <source>Generate (do not generate) code to save the TOC value in the reserved stack location in the function prologue if the function calls through a pointer on AIX and 64-bit Linux systems. If the TOC value is not saved in the prologue, it is saved just before the call through the pointer. The</source>
          <target state="translated">在AIX和64位Linux系统上,如果函数通过指针调用,则生成(不生成)代码将TOC值保存在函数序幕中保留的栈位置。如果TOC值没有保存在序幕中,则会在通过指针调用之前保存。在</target>
        </trans-unit>
        <trans-unit id="492f533f0926b6f12aa3c20775f6e3689bd7771b" translate="yes" xml:space="preserve">
          <source>Generate (do not generate) microMIPS code.</source>
          <target state="translated">生成(不生成)microMIPS代码。</target>
        </trans-unit>
        <trans-unit id="c38ed93b70630b073ac9de0cd53b30eca713a227" translate="yes" xml:space="preserve">
          <source>Generate (do not generate) the &lt;code&gt;friz&lt;/code&gt; instruction when the</source>
          <target state="translated">当以下情况时生成（不生成） &lt;code&gt;friz&lt;/code&gt; 指令</target>
        </trans-unit>
        <trans-unit id="87be6d200ff57766f2cf75cef2026526e7116620" translate="yes" xml:space="preserve">
          <source>Generate (or do not generate) code using the &lt;code&gt;bras&lt;/code&gt; instruction to do subroutine calls. This only works reliably if the total executable size does not exceed 64k. The default is to use the &lt;code&gt;basr&lt;/code&gt; instruction instead, which does not have this limitation.</source>
          <target state="translated">使用 &lt;code&gt;bras&lt;/code&gt; 指令生成（或不生成）代码以进行子例程调用。仅当可执行文件总大小不超过64k时，此方法才能可靠地工作。缺省情况是改用 &lt;code&gt;basr&lt;/code&gt; 指令，它没有此限制。</target>
        </trans-unit>
        <trans-unit id="dac8cd11137e120330b4b9ae84e6593137818e9a" translate="yes" xml:space="preserve">
          <source>Generate (or do not generate) code using the &lt;code&gt;mvcle&lt;/code&gt; instruction to perform block moves. When</source>
          <target state="translated">使用 &lt;code&gt;mvcle&lt;/code&gt; 指令生成（或不生成）代码以执行块移动。什么时候</target>
        </trans-unit>
        <trans-unit id="2e0545421416cf516c0b942352accf8dc6b0a0d5" translate="yes" xml:space="preserve">
          <source>Generate (or don&amp;rsquo;t) &amp;lsquo;</source>
          <target state="translated">生成（或不生成）&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="05dd2841d03433fc0ea5db0c7e0df3c7599676c8" translate="yes" xml:space="preserve">
          <source>Generate (or don&amp;rsquo;t) a stop bit immediately before and after volatile asm statements.</source>
          <target state="translated">在volatile asm语句之前和之后立即生成（或不生成）停止位。</target>
        </trans-unit>
        <trans-unit id="a0784cc5b984b19815bf9eec6e275ae1a59c3b0f" translate="yes" xml:space="preserve">
          <source>Generate (or don&amp;rsquo;t) code for the GNU assembler. This is the default.</source>
          <target state="translated">为GNU汇编器生成（或不生成）代码。这是默认值。</target>
        </trans-unit>
        <trans-unit id="2516ed040d38a5388dd7fe01c44239d79052cf2e" translate="yes" xml:space="preserve">
          <source>Generate (or don&amp;rsquo;t) code for the GNU linker. This is the default.</source>
          <target state="translated">为GNU链接器生成（或不生成）代码。这是默认值。</target>
        </trans-unit>
        <trans-unit id="3e316b54c0eaa7bda512b60e40414c689d945ab8" translate="yes" xml:space="preserve">
          <source>Generate 16-bit instructions.</source>
          <target state="translated">生成16位指令。</target>
        </trans-unit>
        <trans-unit id="a52620c65360885e469f926c554c75bd50dd9583" translate="yes" xml:space="preserve">
          <source>Generate 3-instruction load and store sequences as sometimes required by the HP-UX 10 linker. This is equivalent to the &amp;lsquo;</source>
          <target state="translated">根据HP-UX 10链接器有时的要求，生成3指令加载并存储序列。这等效于&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="b384dbdcdcc6be12f32b73f9469c3ba6b9f1dccf" translate="yes" xml:space="preserve">
          <source>Generate 32x16-bit multiply and multiply-accumulate instructions.</source>
          <target state="translated">生成32x16位乘法和乘法累加指令。</target>
        </trans-unit>
        <trans-unit id="0ccaaa46afb8881f4f3a477c92bc05eae68e0c4a" translate="yes" xml:space="preserve">
          <source>Generate &lt;code&gt;.debug_pubnames&lt;/code&gt; and &lt;code&gt;.debug_pubtypes&lt;/code&gt; sections in a format suitable for conversion into a GDB index. This option is only useful with a linker that can produce GDB index version 7.</source>
          <target state="translated">以适合于转换为GDB索引的格式生成 &lt;code&gt;.debug_pubnames&lt;/code&gt; 和 &lt;code&gt;.debug_pubtypes&lt;/code&gt; 部分。该选项仅对可生成GDB索引版本7的链接器有用。</target>
        </trans-unit>
        <trans-unit id="828612c6e2cc35cf1bee3972f49446cb2047aba1" translate="yes" xml:space="preserve">
          <source>Generate &lt;code&gt;mul64&lt;/code&gt; and &lt;code&gt;mulu64&lt;/code&gt; instructions. Only valid for</source>
          <target state="translated">生成 &lt;code&gt;mul64&lt;/code&gt; 和 &lt;code&gt;mulu64&lt;/code&gt; 指令。仅对</target>
        </trans-unit>
        <trans-unit id="f37d583fd1aea916d55ab9e91fa3002c399aaf84" translate="yes" xml:space="preserve">
          <source>Generate &lt;code&gt;norm&lt;/code&gt; instructions. This is the default if</source>
          <target state="translated">生成 &lt;code&gt;norm&lt;/code&gt; 说明。这是默认设置，如果</target>
        </trans-unit>
        <trans-unit id="2934019de0c741342611be8077a1571f0c44928a" translate="yes" xml:space="preserve">
          <source>Generate &lt;code&gt;swap&lt;/code&gt; instructions.</source>
          <target state="translated">生成 &lt;code&gt;swap&lt;/code&gt; 指令。</target>
        </trans-unit>
        <trans-unit id="586858db58f3f2f4e0ba5be27cc76fd1d37e386f" translate="yes" xml:space="preserve">
          <source>Generate &lt;var&gt;N&lt;/var&gt; NOPs right at the beginning of each function, with the function entry point before the &lt;var&gt;M&lt;/var&gt;th NOP. If &lt;var&gt;M&lt;/var&gt; is omitted, it defaults to &lt;code&gt;0&lt;/code&gt; so the function entry points to the address just at the first NOP. The NOP instructions reserve extra space which can be used to patch in any desired instrumentation at run time, provided that the code segment is writable. The amount of space is controllable indirectly via the number of NOPs; the NOP instruction used corresponds to the instruction emitted by the internal GCC back-end interface &lt;code&gt;gen_nop&lt;/code&gt;. This behavior is target-specific and may also depend on the architecture variant and/or other compilation options.</source>
          <target state="translated">在每个函数的开头立即生成 &lt;var&gt;N&lt;/var&gt; 个 NOP，函数入口点位于第 &lt;var&gt;M&lt;/var&gt; 个NOP 之前。如果省略 &lt;var&gt;M&lt;/var&gt; ，则默认为 &lt;code&gt;0&lt;/code&gt; ,因此函数条目指向第一个NOP处的地址。 NOP指令保留了额外的空间，只要代码段可写，就可以在运行时修补任何所需的仪器。空间的数量可以通过NOP的数量间接控制；使用的NOP指令对应于内部GCC后端接口 &lt;code&gt;gen_nop&lt;/code&gt; 发出的指令。此行为是特定于目标的，并且还可能取决于体系结构变体和/或其他编译选项。</target>
        </trans-unit>
        <trans-unit id="b56d0340e46553074756e8938fdcc9bc10345ee9" translate="yes" xml:space="preserve">
          <source>Generate C header describing the largest structure that is passed by value, if any.</source>
          <target state="translated">生成描述最大结构的C头,如果有的话,通过值传递。</target>
        </trans-unit>
        <trans-unit id="497d1946c219789282a881eeb57aa9b71f210579" translate="yes" xml:space="preserve">
          <source>Generate DWARF &lt;code&gt;.debug_pubnames&lt;/code&gt; and &lt;code&gt;.debug_pubtypes&lt;/code&gt; sections.</source>
          <target state="translated">生成DWARF &lt;code&gt;.debug_pubnames&lt;/code&gt; 和 &lt;code&gt;.debug_pubtypes&lt;/code&gt; 部分。</target>
        </trans-unit>
        <trans-unit id="2f0d6b717c142d078ddbdb831a6e380bea411850" translate="yes" xml:space="preserve">
          <source>Generate GNU/Linux compatible gUSA software atomic sequences for the atomic built-in functions. The generated atomic sequences require additional support from the interrupt/exception handling code of the system and are only suitable for SH3* and SH4* single-core systems. This option is enabled by default when the target is &lt;code&gt;sh*-*-linux*&lt;/code&gt; and SH3* or SH4*. When the target is SH4A, this option also partially utilizes the hardware atomic instructions &lt;code&gt;movli.l&lt;/code&gt; and &lt;code&gt;movco.l&lt;/code&gt; to create more efficient code, unless &amp;lsquo;</source>
          <target state="translated">为原子内置函数生成GNU / Linux兼容的gUSA软件原子序列。生成的原子序列需要系统的中断/异常处理代码的额外支持，并且仅适用于SH3 *和SH4 *单核系统。当目标是 &lt;code&gt;sh*-*-linux*&lt;/code&gt; 和SH3 *或SH4 * 时，默认情况下启用此选项。当目标是SH4A时，该选项还部分利用硬件原子指令 &lt;code&gt;movli.l&lt;/code&gt; 和 &lt;code&gt;movco.l&lt;/code&gt; 来创建更有效的代码，除非&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="bf2d938e1c1ea97f318900579ce3c50a9ae898af" translate="yes" xml:space="preserve">
          <source>Generate GP-relative accesses for all data objects in the program. If you use this option, the entire data and BSS segments of your program must fit in 64K of memory and you must use an appropriate linker script to allocate them within the addressable range of the global pointer.</source>
          <target state="translated">为程序中的所有数据对象生成GP相关访问。如果你使用这个选项,你的程序中的整个数据和BSS段必须适合64K的内存,你必须使用适当的链接器脚本在全局指针的可寻址范围内分配它们。</target>
        </trans-unit>
        <trans-unit id="1fc88c33c3fc53124fa0f92092082efc85a7cdc0" translate="yes" xml:space="preserve">
          <source>Generate GP-relative accesses for small data objects that are not external, weak, or uninitialized common symbols. Also use GP-relative addressing for objects that have been explicitly placed in a small data section via a &lt;code&gt;section&lt;/code&gt; attribute.</source>
          <target state="translated">为不是外部符号，弱符号或未初始化的通用符号的小型数据对象生成GP相对访问。对于通过 &lt;code&gt;section&lt;/code&gt; 属性明确放置在小数据段中的对象，也请使用GP相对寻址。</target>
        </trans-unit>
        <trans-unit id="548a87f5ac4837154b7b55bf3a0684dbbd7b3056" translate="yes" xml:space="preserve">
          <source>Generate GP-relative addresses for function pointers as well as data pointers. If you use this option, the entire text, data, and BSS segments of your program must fit in 64K of memory and you must use an appropriate linker script to allocate them within the addressable range of the global pointer.</source>
          <target state="translated">为函数指针以及数据指针生成GP相关地址。如果你使用这个选项,你的程序中的整个文本、数据和BSS段必须放在64K的内存中,你必须使用适当的链接器脚本在全局指针的可寻址范围内分配它们。</target>
        </trans-unit>
        <trans-unit id="9f3a196b430f925ff0ff89b9ccb1a7bf625049d2" translate="yes" xml:space="preserve">
          <source>Generate MIPS16 code on alternating functions. This option is provided for regression testing of mixed MIPS16/non-MIPS16 code generation, and is not intended for ordinary use in compiling user code.</source>
          <target state="translated">在交替函数上生成MIPS16代码。这个选项是为MIPS16/非MIPS16混合代码生成的回归测试而提供的,并不打算在编译用户代码时普通使用。</target>
        </trans-unit>
        <trans-unit id="b7aa3b59b611b18a6a4ec60f9d9a319cc049bd6b" translate="yes" xml:space="preserve">
          <source>Generate PowerPC64 code for the large model: The TOC may be up to 4G in size. Other data and code is only limited by the 64-bit address space.</source>
          <target state="translated">生成大型号的PowerPC64代码。TOC的大小可以达到4G。其他数据和代码只受64位地址空间的限制。</target>
        </trans-unit>
        <trans-unit id="c7a74518f21d3c00aafcfd3b084cf7c00aee1848" translate="yes" xml:space="preserve">
          <source>Generate PowerPC64 code for the medium model: The TOC and other static data may be up to a total of 4G in size. This is the default for 64-bit Linux.</source>
          <target state="translated">生成中等型号的PowerPC64代码。TOC和其他静态数据可以达到4G的总大小。这是64位Linux的默认值。</target>
        </trans-unit>
        <trans-unit id="8cfde8c4df8b2eb989bc818febefc0e7c28874e7" translate="yes" xml:space="preserve">
          <source>Generate PowerPC64 code for the small model: The TOC is limited to 64k.</source>
          <target state="translated">生成小模型的PowerPC64代码。TOC限制在64k以内。</target>
        </trans-unit>
        <trans-unit id="c7ea62356cd3157102c66b58a868e34df2a5c060" translate="yes" xml:space="preserve">
          <source>Generate VRSAVE instructions when generating AltiVec code.</source>
          <target state="translated">在生成AltiVec代码时,生成VRSAVE指令。</target>
        </trans-unit>
        <trans-unit id="0bd45272345d657871ab9cf111cdd01907672885" translate="yes" xml:space="preserve">
          <source>Generate a __return_loc section pointing to all return instrumentation code.</source>
          <target state="translated">生成一个指向所有返回工具代码的__return_loc部分。</target>
        </trans-unit>
        <trans-unit id="2cf42b0393916fe85d4396c2a4ea44c0c0b17c4a" translate="yes" xml:space="preserve">
          <source>Generate a call to the function &lt;code&gt;abort&lt;/code&gt; at the end of a &lt;code&gt;noreturn&lt;/code&gt; function. It is executed if the function tries to return.</source>
          <target state="translated">在 &lt;code&gt;noreturn&lt;/code&gt; 函数结束时生成对函数 &lt;code&gt;abort&lt;/code&gt; 的调用。如果函数尝试返回，则执行它。</target>
        </trans-unit>
        <trans-unit id="0bfebab0f7716c6c7d48b3db2e26f828205f2eb0" translate="yes" xml:space="preserve">
          <source>Generate a stack frame that is compliant with the ARM Procedure Call Standard for all functions, even if this is not strictly necessary for correct execution of the code. Specifying</source>
          <target state="translated">为所有函数生成符合ARM过程调用标准的堆栈框架,即使这对于正确执行代码并非严格必要。指定</target>
        </trans-unit>
        <trans-unit id="09e70235b2ae102fe1ff7ae3b745820674b997a0" translate="yes" xml:space="preserve">
          <source>Generate a stack frame that is compliant with the Thumb Procedure Call Standard for all leaf functions. (A leaf function is one that does not call any other functions.) The default is</source>
          <target state="translated">为所有叶函数生成一个符合Thumb Procedure Call Standard标准的堆栈框架。(叶函数是指不调用任何其他函数的函数。)默认值是</target>
        </trans-unit>
        <trans-unit id="4e955728a6de82a9bddec4fed62b648dcfc40e9a" translate="yes" xml:space="preserve">
          <source>Generate a stack frame that is compliant with the Thumb Procedure Call Standard for all non-leaf functions. (A leaf function is one that does not call any other functions.) The default is</source>
          <target state="translated">为所有非叶函数生成一个符合Thumb Procedure Call Standard标准的堆栈框架。叶函数是指不调用任何其他函数的函数。)默认是</target>
        </trans-unit>
        <trans-unit id="4839b3bf0bbd769aa7c0e4fcd67cdaaed9746bd5" translate="yes" xml:space="preserve">
          <source>Generate an executable in the ELF format, rather than the default &amp;lsquo;</source>
          <target state="translated">生成ELF格式的可执行文件，而不是默认的'</target>
        </trans-unit>
        <trans-unit id="6c98697c08dfd7f201b6b9c98efc4af59466b6c7" translate="yes" xml:space="preserve">
          <source>Generate an inline expansion using loop code for all block compares that are less than or equal to &lt;var&gt;num&lt;/var&gt; bytes, but greater than the limit for non-loop inline block compare expansion. If the block length is not constant, at most &lt;var&gt;num&lt;/var&gt; bytes will be compared before &lt;code&gt;memcmp&lt;/code&gt; is called to compare the remainder of the block. The default value is target-specific.</source>
          <target state="translated">使用循环代码为小于或等于 &lt;var&gt;num&lt;/var&gt; 字节但大于非循环内联块比较扩展限制的所有块比较生成内联扩展。如果块长度不是恒定的，则在调用 &lt;code&gt;memcmp&lt;/code&gt; 来比较块的其余部分之前，最多将比较 &lt;var&gt;num&lt;/var&gt; 个字节。默认值为特定于目标的。</target>
        </trans-unit>
        <trans-unit id="ee53ff6577ff7bdeec45265bba557ddc96dc42d1" translate="yes" xml:space="preserve">
          <source>Generate big-endian code.</source>
          <target state="translated">生成大段代码。</target>
        </trans-unit>
        <trans-unit id="faa1ec28121e6f94c7459039f3f456a29482ffe4" translate="yes" xml:space="preserve">
          <source>Generate big-endian code. This is the default for &amp;lsquo;</source>
          <target state="translated">生成大端代码。这是&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="497dec8a0e83106900bb3f13f33208ac13cc564e" translate="yes" xml:space="preserve">
          <source>Generate big-endian code. This is the default when GCC is configured for an &amp;lsquo;</source>
          <target state="translated">生成大端代码。当将GCC配置为&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="9f5c216ca40ddba6d0b7e0356dfb54eddd239c13" translate="yes" xml:space="preserve">
          <source>Generate calls as register indirect calls, thus providing access to the full 32-bit address range.</source>
          <target state="translated">以寄存器间接调用的方式生成调用,从而提供对整个32位地址范围的访问。</target>
        </trans-unit>
        <trans-unit id="daf711e932fbd2a210fbf658c2ed048fe589f322" translate="yes" xml:space="preserve">
          <source>Generate checks for control speculation in selective scheduling. This flag is disabled by default.</source>
          <target state="translated">在选择性调度中生成控制推测的检查。该标志默认为禁用。</target>
        </trans-unit>
        <trans-unit id="340f82c2c0a45e961b4cd414df01b6dcda27429e" translate="yes" xml:space="preserve">
          <source>Generate code containing floating-point instructions. This is the default.</source>
          <target state="translated">生成包含浮点指令的代码。这是默认的。</target>
        </trans-unit>
        <trans-unit id="d1eb9be83c7705dec7853ee52d8e983f54f63d2c" translate="yes" xml:space="preserve">
          <source>Generate code containing library calls for floating-point.</source>
          <target state="translated">生成包含浮点函数库调用的代码。</target>
        </trans-unit>
        <trans-unit id="ffda305054ff95e7394bd4003326530b52f9583d" translate="yes" xml:space="preserve">
          <source>Generate code for 32-bit or 64-bit ABI.</source>
          <target state="translated">为32位或64位ABI生成代码。</target>
        </trans-unit>
        <trans-unit id="b67c6b7cf041ab09d12159e623bf4650fd97244d" translate="yes" xml:space="preserve">
          <source>Generate code for 32-bit or 64-bit environments of Darwin and SVR4 targets (including GNU/Linux). The 32-bit environment sets int, long and pointer to 32 bits and generates code that runs on any PowerPC variant. The 64-bit environment sets int to 32 bits and long and pointer to 64 bits, and generates code for PowerPC64, as for</source>
          <target state="translated">为Darwin和SVR4目标(包括GNU/Linux)的32位或64位环境生成代码。32位环境将int、long和指针设置为32位,并生成可在任何PowerPC变体上运行的代码。64位环境将int设置为32位,将long和指针设置为64位,并生成在PowerPC64上运行的代码,如为</target>
        </trans-unit>
        <trans-unit id="a4491a667cb7d0b6c838f6faaee6a864eadc20bd" translate="yes" xml:space="preserve">
          <source>Generate code for CR16C or CR16C+ architecture. CR16C+ architecture is default.</source>
          <target state="translated">生成CR16C或CR16C+架构的代码。CR16C+架构是默认的。</target>
        </trans-unit>
        <trans-unit id="67648931cfe6b959b11bf696abb5438c66a26217" translate="yes" xml:space="preserve">
          <source>Generate code for SH4-100 assuming the floating-point unit is in single-precision mode by default.</source>
          <target state="translated">假设浮点单元默认为单精度模式,生成SH4-100的代码。</target>
        </trans-unit>
        <trans-unit id="de1af2a9972c47a564f5e7fcce23d995d6ae1b8b" translate="yes" xml:space="preserve">
          <source>Generate code for SH4-100 in such a way that no double-precision floating-point operations are used.</source>
          <target state="translated">生成SH4-100的代码时,不使用双精度浮点运算。</target>
        </trans-unit>
        <trans-unit id="107ca25d9739e824d4175850436b6598a742f5a1" translate="yes" xml:space="preserve">
          <source>Generate code for SH4-100 in such a way that the floating-point unit is not used.</source>
          <target state="translated">以不使用浮点单元的方式生成SH4-100的代码。</target>
        </trans-unit>
        <trans-unit id="f4838bc707d842b8a2b2e768456d1b164bf348d3" translate="yes" xml:space="preserve">
          <source>Generate code for SH4-100.</source>
          <target state="translated">生成SH4-100的代码。</target>
        </trans-unit>
        <trans-unit id="eb7eb15dc4aa3c46b2283b182c63acf0a395433d" translate="yes" xml:space="preserve">
          <source>Generate code for SH4-200 assuming the floating-point unit is in single-precision mode by default.</source>
          <target state="translated">假设浮点单元默认为单精度模式,生成SH4-200的代码。</target>
        </trans-unit>
        <trans-unit id="c7c33168087299c03364283296e9feb1a533b788" translate="yes" xml:space="preserve">
          <source>Generate code for SH4-200 in such a way that no double-precision floating-point operations are used.</source>
          <target state="translated">生成SH4-200的代码时,不使用双精度浮点运算。</target>
        </trans-unit>
        <trans-unit id="b14c102c6af7d5f6fb411b3d326830a45f2aceb0" translate="yes" xml:space="preserve">
          <source>Generate code for SH4-200 without in such a way that the floating-point unit is not used.</source>
          <target state="translated">生成SH4-200的代码,不使用浮点单元。</target>
        </trans-unit>
        <trans-unit id="5283c23e1460ff21798ade4588312627145b49aa" translate="yes" xml:space="preserve">
          <source>Generate code for SH4-200.</source>
          <target state="translated">生成SH4-200的代码。</target>
        </trans-unit>
        <trans-unit id="2fb0dbc9dfbf231f5e57962b75a086351c1f46b3" translate="yes" xml:space="preserve">
          <source>Generate code for SH4-300 in such a way that no double-precision floating-point operations are used.</source>
          <target state="translated">生成SH4-300的代码,不使用双精度浮点运算。</target>
        </trans-unit>
        <trans-unit id="ff44e3f28e2fd7daaa679641ff86e04eab85fb68" translate="yes" xml:space="preserve">
          <source>Generate code for SH4-300 without in such a way that the floating-point unit is not used.</source>
          <target state="translated">生成SH4-300的代码,不使用浮点单元。</target>
        </trans-unit>
        <trans-unit id="5dd69911ae792e28eb1d16efd78aa149dec9b0b1" translate="yes" xml:space="preserve">
          <source>Generate code for SH4-300.</source>
          <target state="translated">生成SH4-300的代码。</target>
        </trans-unit>
        <trans-unit id="3190f28d97b238beea538765e992a0880400111e" translate="yes" xml:space="preserve">
          <source>Generate code for SH4-340 (no MMU, no FPU).</source>
          <target state="translated">生成SH4-340的代码(在MMU、FPU中)。</target>
        </trans-unit>
        <trans-unit id="964d89eec4f49e488b7e663bfb784df7de2d9807" translate="yes" xml:space="preserve">
          <source>Generate code for SH4-500 (no FPU). Passes</source>
          <target state="translated">为SH4-500(无FPU)生成代码。通过</target>
        </trans-unit>
        <trans-unit id="bd07f25b5dfd9dc83556617396ced4ced292840d" translate="yes" xml:space="preserve">
          <source>Generate code for Smart Mode, using only registers numbered 0-7 to allow use of 16-bit instructions. This option is ignored for CK801 where this is the required behavior, and it defaults to on for CK802. For other targets, the default is off.</source>
          <target state="translated">为智能模式生成代码,只使用编号为0-7的寄存器,允许使用16位指令。对于CK801来说,这个选项被忽略,因为这是必要的行为,而对于CK802来说,它的默认值是on。对于其他目标,默认为关闭。</target>
        </trans-unit>
        <trans-unit id="d1ef13a03c7e2ed855aab73fe845bb318c6bf94c" translate="yes" xml:space="preserve">
          <source>Generate code for a 16-bit, 32-bit or 64-bit environment. The</source>
          <target state="translated">为16位、32位或64位环境生成代码。该</target>
        </trans-unit>
        <trans-unit id="6f846bc35b4ddbb63662daaf0b8a0b9a36eafb1b" translate="yes" xml:space="preserve">
          <source>Generate code for a 32-bit environment, which sets int, long, and pointer to 32 bits. This is the only supported behavior so the flag is essentially ignored.</source>
          <target state="translated">生成32位环境的代码,将int、long和指针设置为32位。这是唯一支持的行为,所以该标志基本被忽略。</target>
        </trans-unit>
        <trans-unit id="c70fb6bc63f54c3dd3b6636fb15aabdae1032dda" translate="yes" xml:space="preserve">
          <source>Generate code for a 32-bit or 64-bit environment. The 32-bit environment sets int, long and pointer to 32 bits. The 64-bit environment sets int to 32 bits and long and pointer to 64 bits.</source>
          <target state="translated">为32位或64位环境生成代码。32位环境将int、long和指针设置为32位。64位环境将int设置为32位,long和指针设置为64位。</target>
        </trans-unit>
        <trans-unit id="25466413f97413255c5d54e631be1e6a23f5330d" translate="yes" xml:space="preserve">
          <source>Generate code for a 32-bit or 64-bit environment. The 32-bit environment sets int, long and pointer to 32 bits. The 64-bit environment sets int to 32 bits and long and pointer to 64 bits. These are HP-UX specific flags.</source>
          <target state="translated">为32位或64位环境生成代码。32位环境将int、long和指针设置为32位。64位环境将int设置为32位,long和指针设置为64位。这些是HP-UX特有的标志。</target>
        </trans-unit>
        <trans-unit id="89222a0849ae48c73c6bd1624ef4d88ea3c84874" translate="yes" xml:space="preserve">
          <source>Generate code for a 32-bit or 64-bit environment. The 32-bit environment sets int, long, and pointer to 32 bits. The 64-bit environment sets int to 32 bits and long and pointer to 64 bits.</source>
          <target state="translated">为32位或64位环境生成代码。32位环境将int、long和指针设置为32位。64位环境将int设置为32位,long和指针设置为64位。</target>
        </trans-unit>
        <trans-unit id="7a6899675bc409f91ebf1c2951874d09f2171d0a" translate="yes" xml:space="preserve">
          <source>Generate code for a PDP-11/10. Implies -msoft-float -mno-split.</source>
          <target state="translated">为PDP-11/10生成代码。意味着-msoft-float -mno-split。</target>
        </trans-unit>
        <trans-unit id="bee1deaf455b6a6b4cdb2bb13d6ee23ad81f5012" translate="yes" xml:space="preserve">
          <source>Generate code for a PDP-11/40. Implies -msoft-float -mno-split.</source>
          <target state="translated">生成PDP-11/40的代码。意味着-msoft-float -mno-split。</target>
        </trans-unit>
        <trans-unit id="d9780d13a5a51c47480c939a428413699ac3ed17" translate="yes" xml:space="preserve">
          <source>Generate code for a PDP-11/45. This is the default.</source>
          <target state="translated">生成PDP-11/45的代码。这是默认的。</target>
        </trans-unit>
        <trans-unit id="92b920e8ba8535d90a16588551ee999d568f0291" translate="yes" xml:space="preserve">
          <source>Generate code for a big-endian target.</source>
          <target state="translated">生成大段目标的代码。</target>
        </trans-unit>
        <trans-unit id="d68254cfeddff60f3b9cadfb72e8acbde8b8a455" translate="yes" xml:space="preserve">
          <source>Generate code for a big-endian target. This is the default for HP-UX.</source>
          <target state="translated">生成大段目标的代码,这是HP-UX的默认值。这是HP-UX的默认值。</target>
        </trans-unit>
        <trans-unit id="5fbe216af63a08f8f99c457d81f72aa33271a249" translate="yes" xml:space="preserve">
          <source>Generate code for a little-endian target.</source>
          <target state="translated">生成一个小二烯目标的代码。</target>
        </trans-unit>
        <trans-unit id="7fec6c67ff3977f6cbf34379a4b039899b9238d9" translate="yes" xml:space="preserve">
          <source>Generate code for a little-endian target. This is the default for AIX5 and GNU/Linux.</source>
          <target state="translated">生成一个小迭代目标的代码,这是AIX5和GNU/Linux的默认值。这是AIX5和GNU/Linux的默认值。</target>
        </trans-unit>
        <trans-unit id="12a32136f06def3f80692a9e99c0d8f9b7d0b140" translate="yes" xml:space="preserve">
          <source>Generate code for a little-endian target. This is the default.</source>
          <target state="translated">生成小段目标的代码。这是默认的。</target>
        </trans-unit>
        <trans-unit id="86cf4bd8b15db1a7bae18b7503fdfe578d14ff3d" translate="yes" xml:space="preserve">
          <source>Generate code for a processor running in big-endian mode; the default is to compile code for a little-endian processor.</source>
          <target state="translated">为运行在big-endian模式下的处理器生成代码;默认情况下是为little-endian处理器编译代码。</target>
        </trans-unit>
        <trans-unit id="b9c63b6f7dde24a56bfd3b0c8c39dff387d09612" translate="yes" xml:space="preserve">
          <source>Generate code for a processor running in little-endian mode. This is the default for all standard configurations.</source>
          <target state="translated">为运行在小段模式下的处理器生成代码。这是所有标准配置的默认值。</target>
        </trans-unit>
        <trans-unit id="7c9d614db21563decf26e4450a12e8ff0db080a3" translate="yes" xml:space="preserve">
          <source>Generate code for a specific M680x0 or ColdFire instruction set architecture. Permissible values of &lt;var&gt;arch&lt;/var&gt; for M680x0 architectures are: &amp;lsquo;</source>
          <target state="translated">为特定的M680x0或ColdFire指令集架构生成代码。M680x0架构允许的 &lt;var&gt;arch&lt;/var&gt; 值为：'</target>
        </trans-unit>
        <trans-unit id="4756b1c10e780d22755d4efd055be671187986d0" translate="yes" xml:space="preserve">
          <source>Generate code for a specific M680x0 or ColdFire processor. The M680x0 &lt;var&gt;cpu&lt;/var&gt;s are: &amp;lsquo;</source>
          <target state="translated">为特定的M680x0或ColdFire处理器生成代码。M680x0 &lt;var&gt;cpu&lt;/var&gt; 为：</target>
        </trans-unit>
        <trans-unit id="cf0efda24e55f61b98734329e006dab8159c05d8" translate="yes" xml:space="preserve">
          <source>Generate code for given RISC-V ISA (e.g. &amp;lsquo;</source>
          <target state="translated">为给定的RISC-V ISA生成代码（例如，&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="1cc9f255978b92385d0966d847bc3f1f4feff36e" translate="yes" xml:space="preserve">
          <source>Generate code for given the specified PTX ISA (e.g. &amp;lsquo;</source>
          <target state="translated">为给定的指定PTX ISA生成代码（例如，&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="4b8a962abd2bc5357f263a724ad7ce6201860ac4" translate="yes" xml:space="preserve">
          <source>Generate code for hardware which requires divide instruction emulation.</source>
          <target state="translated">为需要除法指令仿真的硬件生成代码。</target>
        </trans-unit>
        <trans-unit id="0ff05f7bfb6de148dd31e5b918468ff58be8cc2b" translate="yes" xml:space="preserve">
          <source>Generate code for hardware which requires multiply instruction emulation.</source>
          <target state="translated">为需要乘法指令仿真的硬件生成代码。</target>
        </trans-unit>
        <trans-unit id="9d141b4aab656e3ada981384fd6736554ccf4fe3" translate="yes" xml:space="preserve">
          <source>Generate code for hardware which supports divide instructions. This is the default.</source>
          <target state="translated">为支持除法指令的硬件生成代码。这是默认的。</target>
        </trans-unit>
        <trans-unit id="63b8cd12a9a7b77524e7516bc8342264efc809e2" translate="yes" xml:space="preserve">
          <source>Generate code for hardware which supports multiply instructions. This is the default.</source>
          <target state="translated">为支持乘法指令的硬件生成代码。这是默认的。</target>
        </trans-unit>
        <trans-unit id="f67b905d0c7d601714b6d40130d650c8841556d5" translate="yes" xml:space="preserve">
          <source>Generate code for hardware which supports rotate right instructions.</source>
          <target state="translated">为支持右旋指令的硬件生成代码。</target>
        </trans-unit>
        <trans-unit id="d8901265c038359c4cabcecef69c62a4ad403284" translate="yes" xml:space="preserve">
          <source>Generate code for hardware which supports set flag immediate (&lt;code&gt;l.sf*i&lt;/code&gt;) instructions.</source>
          <target state="translated">为支持设置标志立即数（ &lt;code&gt;l.sf*i&lt;/code&gt; ）指令的硬件生成代码。</target>
        </trans-unit>
        <trans-unit id="cb0dc185d9cce6eac6a0da7c5fde4468c232eb00" translate="yes" xml:space="preserve">
          <source>Generate code for hardware which supports shift immediate related instructions (i.e. &lt;code&gt;l.srai&lt;/code&gt;, &lt;code&gt;l.srli&lt;/code&gt;, &lt;code&gt;l.slli&lt;/code&gt;, &lt;code&gt;1.rori&lt;/code&gt;). Note, to enable generation of the &lt;code&gt;l.rori&lt;/code&gt; instruction the</source>
          <target state="translated">为支持移位立即相关指令的硬件生成代码（即 &lt;code&gt;l.srai&lt;/code&gt; ， &lt;code&gt;l.srli&lt;/code&gt; ， &lt;code&gt;l.slli&lt;/code&gt; ， &lt;code&gt;1.rori&lt;/code&gt; ）。注意，要启用生成 &lt;code&gt;l.rori&lt;/code&gt; 指令，</target>
        </trans-unit>
        <trans-unit id="56c0dd74c2b5f08d1195605802098a996d48ddaa" translate="yes" xml:space="preserve">
          <source>Generate code for hardware which supports sign-extension instructions.</source>
          <target state="translated">为支持符号扩展指令的硬件生成代码。</target>
        </trans-unit>
        <trans-unit id="c6c9d0431f616f47453feb5bcfe61cef592a68b7" translate="yes" xml:space="preserve">
          <source>Generate code for hardware which supports the conditional move (&lt;code&gt;l.cmov&lt;/code&gt;) instruction.</source>
          <target state="translated">为支持条件移动（ &lt;code&gt;l.cmov&lt;/code&gt; ）指令的硬件生成代码。</target>
        </trans-unit>
        <trans-unit id="bf79d7ac3430cd100137adc751a91365b039edd3" translate="yes" xml:space="preserve">
          <source>Generate code for inline divides of floating-point values using the maximum throughput algorithm.</source>
          <target state="translated">使用最大吞吐量算法生成浮点值内联除法的代码。</target>
        </trans-unit>
        <trans-unit id="3cedd11fcbf120218332b498654e7e4160f8c76d" translate="yes" xml:space="preserve">
          <source>Generate code for inline divides of floating-point values using the minimum latency algorithm.</source>
          <target state="translated">使用最小延迟算法生成浮点值内联除法的代码。</target>
        </trans-unit>
        <trans-unit id="1cc7790f16d0c4d4d91471e6f5d653df0c747e44" translate="yes" xml:space="preserve">
          <source>Generate code for inline divides of integer values using the maximum throughput algorithm.</source>
          <target state="translated">使用最大吞吐量算法生成整数值内联除法的代码。</target>
        </trans-unit>
        <trans-unit id="faf94b4d20f983cdf533f47ec33942d0ce63586d" translate="yes" xml:space="preserve">
          <source>Generate code for inline divides of integer values using the minimum latency algorithm.</source>
          <target state="translated">使用最小延迟算法生成整数值内联除法的代码。</target>
        </trans-unit>
        <trans-unit id="5418fa0a1b1b281d2485d7060d2309afdebd6ff4" translate="yes" xml:space="preserve">
          <source>Generate code for inline square roots using the maximum throughput algorithm.</source>
          <target state="translated">使用最大吞吐量算法生成内联方根的代码。</target>
        </trans-unit>
        <trans-unit id="83ef176a0741f8d1f5fe6e111f7583e6807956ad" translate="yes" xml:space="preserve">
          <source>Generate code for inline square roots using the minimum latency algorithm.</source>
          <target state="translated">使用最小延迟算法生成内联平方根的代码。</target>
        </trans-unit>
        <trans-unit id="00979759a61ef121145bed1163bfbd0399a7b98b" translate="yes" xml:space="preserve">
          <source>Generate code for long address mode. This is only supported for 64-bit and x32 environments. It is the default address mode for 64-bit environments.</source>
          <target state="translated">生成长地址模式的代码。这只支持64位和x32环境。它是64位环境的默认地址模式。</target>
        </trans-unit>
        <trans-unit id="8adaf3135394010293585c029db12629ab7fdcf7" translate="yes" xml:space="preserve">
          <source>Generate code for short address mode. This is only supported for 32-bit and x32 environments. It is the default address mode for 32-bit and x32 environments.</source>
          <target state="translated">生成短地址模式的代码。这只支持32位和x32环境。这是32位和x32环境的默认地址模式。</target>
        </trans-unit>
        <trans-unit id="694f6014654115d073cccf62f6b995dc2510f9c1" translate="yes" xml:space="preserve">
          <source>Generate code for the 210 processor.</source>
          <target state="translated">为210处理器生成代码。</target>
        </trans-unit>
        <trans-unit id="85e35fc91e0af86a193c565f8d6f2a96d089e373" translate="yes" xml:space="preserve">
          <source>Generate code for the C-SKY compiler runtime instead of libgcc. This option defaults to off.</source>
          <target state="translated">为C-SKY编译器运行时生成代码,而不是libgcc。这个选项的默认值是off。</target>
        </trans-unit>
        <trans-unit id="27e854c2e0908c3f4c936f01364c648aa32b367c" translate="yes" xml:space="preserve">
          <source>Generate code for the H8/300H.</source>
          <target state="translated">生成H8/300H的代码。</target>
        </trans-unit>
        <trans-unit id="bb83090e60c2fc757a89c80487c241185ee5d95a" translate="yes" xml:space="preserve">
          <source>Generate code for the H8S and H8/300H in the normal mode. This switch must be used either with</source>
          <target state="translated">在正常模式下为H8S和H8/300H生成代码。该开关必须与</target>
        </trans-unit>
        <trans-unit id="d052e6239d8f301fe0a2b7da20c249087f96d45d" translate="yes" xml:space="preserve">
          <source>Generate code for the H8S.</source>
          <target state="translated">生成H8S的代码。</target>
        </trans-unit>
        <trans-unit id="6d5ff3e2bd91c0a262161bf6efa2cdef6971233e" translate="yes" xml:space="preserve">
          <source>Generate code for the H8S/2600. This switch must be used with</source>
          <target state="translated">生成H8S/2600的代码。该开关必须与</target>
        </trans-unit>
        <trans-unit id="d28ff0fda5a5612fbf86e8ebd7c80cabd4110b85" translate="yes" xml:space="preserve">
          <source>Generate code for the M32R. This is the default.</source>
          <target state="translated">为M32R生成代码。这是默认的。</target>
        </trans-unit>
        <trans-unit id="20e08fc2eddd3584a33dc2a59b26172bf1281828" translate="yes" xml:space="preserve">
          <source>Generate code for the M32R/2.</source>
          <target state="translated">生成M32R/2的代码。</target>
        </trans-unit>
        <trans-unit id="1939be789de09c47e008a34d88743773021de724" translate="yes" xml:space="preserve">
          <source>Generate code for the M32R/X.</source>
          <target state="translated">为M32R/X生成代码。</target>
        </trans-unit>
        <trans-unit id="df8817f533054f34d7acf449e4e33f38657d304e" translate="yes" xml:space="preserve">
          <source>Generate code for the SH1.</source>
          <target state="translated">生成SH1的代码。</target>
        </trans-unit>
        <trans-unit id="050479be73754de25483a6e1712e26489d053e34" translate="yes" xml:space="preserve">
          <source>Generate code for the SH2.</source>
          <target state="translated">生成SH2的代码。</target>
        </trans-unit>
        <trans-unit id="3723c95f415c4a4c6a69d66a7f758a27732147a1" translate="yes" xml:space="preserve">
          <source>Generate code for the SH2a without FPU, or for a SH2a-FPU in such a way that the floating-point unit is not used.</source>
          <target state="translated">生成没有FPU的SH2a的代码,或者不用浮点单元的SH2a-FPU的代码。</target>
        </trans-unit>
        <trans-unit id="bc412156cf20c916e946ffa4cbe84584eb6567a5" translate="yes" xml:space="preserve">
          <source>Generate code for the SH2a-FPU assuming the floating-point unit is in double-precision mode by default.</source>
          <target state="translated">生成SH2a-FPU的代码,假设浮点单元默认为双精度模式。</target>
        </trans-unit>
        <trans-unit id="34abdbdae2fa95db6713e96853be2eca7e9c05eb" translate="yes" xml:space="preserve">
          <source>Generate code for the SH2a-FPU assuming the floating-point unit is in single-precision mode by default.</source>
          <target state="translated">生成SH2a-FPU的代码,假设浮点单元默认为单精度模式。</target>
        </trans-unit>
        <trans-unit id="1f2673d8ddd54030d4d4878de69f24422a5fdba0" translate="yes" xml:space="preserve">
          <source>Generate code for the SH2a-FPU, in such a way that no double-precision floating-point operations are used.</source>
          <target state="translated">为SH2a-FPU生成代码,不使用双精度浮点运算。</target>
        </trans-unit>
        <trans-unit id="483cb3ca44e923a4b1df433858f80751ca9f93aa" translate="yes" xml:space="preserve">
          <source>Generate code for the SH2e.</source>
          <target state="translated">生成SH2e的代码。</target>
        </trans-unit>
        <trans-unit id="1a936c359ffaab90c574043388b2920044ce94c5" translate="yes" xml:space="preserve">
          <source>Generate code for the SH3.</source>
          <target state="translated">生成SH3的代码。</target>
        </trans-unit>
        <trans-unit id="52624bfb24aef64a24903a711fc58d43129edfce" translate="yes" xml:space="preserve">
          <source>Generate code for the SH3e.</source>
          <target state="translated">生成SH3e的代码。</target>
        </trans-unit>
        <trans-unit id="3974fd9acf25ff513cb6f41c5bd4a7bda9784a55" translate="yes" xml:space="preserve">
          <source>Generate code for the SH4 assuming the floating-point unit is in single-precision mode by default.</source>
          <target state="translated">假设浮点单元默认为单精度模式,生成SH4的代码。</target>
        </trans-unit>
        <trans-unit id="75d92b5b6d76cda99c6a173e1dd53216d0ca8f31" translate="yes" xml:space="preserve">
          <source>Generate code for the SH4 with a floating-point unit that only supports single-precision arithmetic.</source>
          <target state="translated">生成SH4的代码,浮点单元只支持单精度算术。</target>
        </trans-unit>
        <trans-unit id="162b02716f568279c8d0d5122c58fd1e1d0d9f75" translate="yes" xml:space="preserve">
          <source>Generate code for the SH4 without a floating-point unit.</source>
          <target state="translated">生成没有浮点单元的SH4的代码。</target>
        </trans-unit>
        <trans-unit id="63daf68bdeb08d26dfc7feca667cc330215f1c9b" translate="yes" xml:space="preserve">
          <source>Generate code for the SH4.</source>
          <target state="translated">生成SH4的代码。</target>
        </trans-unit>
        <trans-unit id="e752d163eaf5a23bc2b7e20cedab4af27f30919d" translate="yes" xml:space="preserve">
          <source>Generate code for the SH4a assuming the floating-point unit is in single-precision mode by default.</source>
          <target state="translated">假设浮点单元默认为单精度模式,生成SH4a的代码。</target>
        </trans-unit>
        <trans-unit id="9bfcba29114940deb31d10a6d0e6239fe06706a5" translate="yes" xml:space="preserve">
          <source>Generate code for the SH4a, in such a way that no double-precision floating-point operations are used.</source>
          <target state="translated">生成SH4a的代码,不使用双精度浮点运算。</target>
        </trans-unit>
        <trans-unit id="c9b792a4628ba5fbcf5191ba54ebda633615fe85" translate="yes" xml:space="preserve">
          <source>Generate code for the SH4a.</source>
          <target state="translated">生成SH4a的代码。</target>
        </trans-unit>
        <trans-unit id="e7ae153f4f4ad9faa39e7795dea14788da791715" translate="yes" xml:space="preserve">
          <source>Generate code for the SH4al-dsp, or for a SH4a in such a way that the floating-point unit is not used.</source>
          <target state="translated">为SH4al-dsp或SH4a生成不使用浮点单元的代码。</target>
        </trans-unit>
        <trans-unit id="b868662932b00739d50db318aa2ddd01fc4bd249" translate="yes" xml:space="preserve">
          <source>Generate code for the given ABI.</source>
          <target state="translated">为给定的ABI生成代码。</target>
        </trans-unit>
        <trans-unit id="54f462554c550dbd112a2f944735d38c4f45d0bc" translate="yes" xml:space="preserve">
          <source>Generate code for the kernel code model. The kernel runs in the negative 2 GB of the address space. This model has to be used for Linux kernel code.</source>
          <target state="translated">生成内核代码模型的代码。内核运行在负2GB的地址空间中。这个模型必须用于Linux内核代码。</target>
        </trans-unit>
        <trans-unit id="9f7119380ad6e8c2c7924710a3b532b63b7c448f" translate="yes" xml:space="preserve">
          <source>Generate code for the large code model. This makes no assumptions about addresses and sizes of sections. Programs can be statically linked only.</source>
          <target state="translated">生成大代码模型的代码。这不对各部分的地址和大小做任何假设。程序只能是静态链接。</target>
        </trans-unit>
        <trans-unit id="e3f449db1f29f06f736e88f3d496de39caace854" translate="yes" xml:space="preserve">
          <source>Generate code for the large model. There is no limitation on call distance, pc-relative addresses, or absolute addresses.</source>
          <target state="translated">生成大模型的代码。对呼叫距离、pc相关地址或绝对地址没有限制。</target>
        </trans-unit>
        <trans-unit id="9e0fcd5ba89af087e24036d07076369bc21de870" translate="yes" xml:space="preserve">
          <source>Generate code for the large model. This model makes no assumptions about addresses and sizes of sections.</source>
          <target state="translated">生成大型模型的代码。该模型不假设地址和部分的大小。</target>
        </trans-unit>
        <trans-unit id="0971940cc08a4932dadb19e61d4f634d86124a27" translate="yes" xml:space="preserve">
          <source>Generate code for the medium model: the program is linked in the lower 2 GB of the address space. Small symbols are also placed there. Symbols with sizes larger than</source>
          <target state="translated">生成中等模型的代码:程序链接在地址空间的下2GB中。小符号也放在那里。符号的大小大于</target>
        </trans-unit>
        <trans-unit id="59ca259d5568c2d002dd2ccbe8f095a11b92f1df" translate="yes" xml:space="preserve">
          <source>Generate code for the medium-any code model. The program and its statically defined symbols must be within any single 2 GiB address range. Programs can be statically or dynamically linked.</source>
          <target state="translated">生成中任何代码模型的代码。程序及其静态定义的符号必须在任何一个2 GiB地址范围内。程序可以是静态或动态链接的。</target>
        </trans-unit>
        <trans-unit id="504796a714036a0c76db86fa41cc45a9fb08427c" translate="yes" xml:space="preserve">
          <source>Generate code for the medium-low code model. The program and its statically defined symbols must lie within a single 2 GiB address range and must lie between absolute addresses -2 GiB and +2 GiB. Programs can be statically or dynamically linked. This is the default code model.</source>
          <target state="translated">生成中低码模型的代码。程序及其静态定义的符号必须位于一个2 GiB的地址范围内,并且必须位于绝对地址-2 GiB和+2 GiB之间。程序可以是静态的,也可以是动态链接的。这是默认的代码模型。</target>
        </trans-unit>
        <trans-unit id="071c751072fdeed9625e903fca26e27c829fa3e5" translate="yes" xml:space="preserve">
          <source>Generate code for the small code model. The program and its statically defined symbols must be within 4GB of each other. Programs can be statically or dynamically linked. This is the default code model.</source>
          <target state="translated">生成小代码模型的代码。程序和其静态定义的符号必须在4GB以内。程序可以是静态或动态链接的。这是默认的代码模型。</target>
        </trans-unit>
        <trans-unit id="051a1860ec3526f5a9b8c1256cff7e9959d2ec61" translate="yes" xml:space="preserve">
          <source>Generate code for the small code model: the program and its symbols must be linked in the lower 2 GB of the address space. Pointers are 64 bits. Programs can be statically or dynamically linked. This is the default code model.</source>
          <target state="translated">生成小代码模型的代码:程序及其符号必须链接在地址空间的下2GB中。指针为64位。程序可以是静态的,也可以是动态链接的。这是默认的代码模型。</target>
        </trans-unit>
        <trans-unit id="fccb732c10311c882aff8903c1dae6926a19b9e0" translate="yes" xml:space="preserve">
          <source>Generate code for the small model. The distance for direct calls is limited to 500M in either direction. PC-relative addresses are 32 bits. Absolute addresses support the full address range.</source>
          <target state="translated">生成小模型的代码。直接调用的距离限制为双向500M。PC相关地址为32位。绝对地址支持全地址范围。</target>
        </trans-unit>
        <trans-unit id="245e4a42ebe1fc23a573492e82ac616ceb7b3a60" translate="yes" xml:space="preserve">
          <source>Generate code for the specified ABI. Permissible values are: &amp;lsquo;</source>
          <target state="translated">为指定的ABI生成代码。允许值为：</target>
        </trans-unit>
        <trans-unit id="62cd08507f5129c0313b216b3b312e1f38339400" translate="yes" xml:space="preserve">
          <source>Generate code for the specified architecture. The choices for &lt;var&gt;architecture-type&lt;/var&gt; are &amp;lsquo;</source>
          <target state="translated">生成指定体系结构的代码。 &lt;var&gt;architecture-type&lt;/var&gt; 的选择是&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="fa0e2168d621855d66b05e248a41636b81294293" translate="yes" xml:space="preserve">
          <source>Generate code for the specified calling convention. Permissible values are &amp;lsquo;</source>
          <target state="translated">为指定的调用约定生成代码。允许值为&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="d43b1f64836a5b0a5d775d2376c530695500c9a6" translate="yes" xml:space="preserve">
          <source>Generate code for the specified data model. Permissible values are &amp;lsquo;</source>
          <target state="translated">为指定的数据模型生成代码。允许值为&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="e12f5237878118905a68ef1df9fd8353d31db89f" translate="yes" xml:space="preserve">
          <source>Generate code for the supervisor mode, where there are no restrictions on the access to general registers. This is the default.</source>
          <target state="translated">生成主管模式的代码,对一般寄存器的访问没有限制。这是默认的。</target>
        </trans-unit>
        <trans-unit id="e6c40e69179c553d840354dee8e09afd6afb670e" translate="yes" xml:space="preserve">
          <source>Generate code for the tiny code model. The program and its statically defined symbols must be within 1MB of each other. Programs can be statically or dynamically linked.</source>
          <target state="translated">生成微小代码模型的代码。程序和其静态定义的符号之间必须在1MB以内。程序可以是静态或动态链接的。</target>
        </trans-unit>
        <trans-unit id="9e11e5ef71d66be04277bc1f01b5f5278d9a40a3" translate="yes" xml:space="preserve">
          <source>Generate code for the user mode, where the access to some general registers is forbidden: on the GR5, registers r24 to r31 cannot be accessed in this mode; on the GR6, only registers r29 to r31 are affected.</source>
          <target state="translated">生成用户模式的代码,在该模式下,禁止访问一些通用寄存器:在GR5上,在该模式下不能访问寄存器r24至r31;在GR6上,只有寄存器r29至r31受到影响。</target>
        </trans-unit>
        <trans-unit id="bd8c4bf394db1eaf7b115e9a97579b1aa69d5063" translate="yes" xml:space="preserve">
          <source>Generate code for use in OpenMP offloading: enables</source>
          <target state="translated">生成用于OpenMP卸载的代码:启用。</target>
        </trans-unit>
        <trans-unit id="16c4c1a05d2b765d07aab8ca18577dc3fd7c3686" translate="yes" xml:space="preserve">
          <source>Generate code in big-endian mode.</source>
          <target state="translated">以大段模式生成代码。</target>
        </trans-unit>
        <trans-unit id="617c48669c81ce32d047fdd88ab6cc36cefe714c" translate="yes" xml:space="preserve">
          <source>Generate code in big/little endian mode, respectively.</source>
          <target state="translated">分别以大/小恩迪安模式生成代码。</target>
        </trans-unit>
        <trans-unit id="f467368c82a003e89d9528f03fca80cb77bf1e51" translate="yes" xml:space="preserve">
          <source>Generate code in little-endian mode.</source>
          <target state="translated">以小二烯模式生成代码。</target>
        </trans-unit>
        <trans-unit id="d2870658bf99f10270c562aaa0ce69afd3724aea" translate="yes" xml:space="preserve">
          <source>Generate code suitable for big switch tables. Use this option only if the assembler/linker complain about out of range branches within a switch table.</source>
          <target state="translated">生成适合大的开关表的代码。只有当汇编器/链接器抱怨开关表内的分支超出范围时才使用这个选项。</target>
        </trans-unit>
        <trans-unit id="31742c20f6d08e41957b4759da6c2e20cfa33560" translate="yes" xml:space="preserve">
          <source>Generate code suitable for fast turnaround development, such as to allow GDB to dynamically load</source>
          <target state="translated">生成适合快速周转开发的代码,比如让GDB动态加载。</target>
        </trans-unit>
        <trans-unit id="f9c5e3444f60e6e1d269aebfea1614af0e0ffa27" translate="yes" xml:space="preserve">
          <source>Generate code that adds (does not add) in TPF OS specific branches to trace routines in the operating system. This option is off by default, even when compiling for the TPF OS.</source>
          <target state="translated">生成在 TPF OS 特定分支中添加(不添加)到操作系统中跟踪例程的代码。即使在为 TPF OS 编译时,该选项默认为关闭。</target>
        </trans-unit>
        <trans-unit id="cf132e8fd4ca1bac8a3c035b0896be35d4f95248" translate="yes" xml:space="preserve">
          <source>Generate code that allows (does not allow) a static executable to be relocated to a different address at run time. A simple embedded PowerPC system loader should relocate the entire contents of &lt;code&gt;.got2&lt;/code&gt; and 4-byte locations listed in the &lt;code&gt;.fixup&lt;/code&gt; section, a table of 32-bit addresses generated by this option. For this to work, all objects linked together must be compiled with</source>
          <target state="translated">生成允许（不允许）静态可执行文件在运行时重定位到其他地址的代码。一个简单的嵌入式PowerPC系统加载器应重新 &lt;code&gt;.got2&lt;/code&gt; &lt;code&gt;.fixup&lt;/code&gt; 部分中列出的.got2和4字节位置的全部内容，此选项是此选项生成的32位地址表。为此，必须使用以下命令编译链接在一起的所有对象：</target>
        </trans-unit>
        <trans-unit id="86d1c7c8ebb812df3d75ca440f1dd938fb6de6fb" translate="yes" xml:space="preserve">
          <source>Generate code that allows &lt;code&gt;ld&lt;/code&gt; and &lt;code&gt;ld.so&lt;/code&gt; to build executables and shared libraries with non-executable &lt;code&gt;.plt&lt;/code&gt; and &lt;code&gt;.got&lt;/code&gt; sections. This is a PowerPC 32-bit SYSV ABI option.</source>
          <target state="translated">生成允许 &lt;code&gt;ld&lt;/code&gt; 和 &lt;code&gt;ld.so&lt;/code&gt; 使用不可执行的 &lt;code&gt;.plt&lt;/code&gt; 和 &lt;code&gt;.got&lt;/code&gt; 节构建可执行文件和共享库的代码。这是PowerPC 32位SYSV ABI选项。</target>
        </trans-unit>
        <trans-unit id="2493e6ad3aa4a2943864620cf6ffd109b6ddb3da" translate="yes" xml:space="preserve">
          <source>Generate code that allows the data segment to be located in a different area of memory from the text segment. This allows for execute in place in an environment without virtual memory management by eliminating relocations against the text section.</source>
          <target state="translated">生成代码,使数据段与文本段位于不同的内存区域。这样就可以在没有虚拟内存管理的环境中就地执行,消除对文本段的重新定位。</target>
        </trans-unit>
        <trans-unit id="eb6f87eee15c30331198259c5e0fa884666e3b45" translate="yes" xml:space="preserve">
          <source>Generate code that allows the data segment to be located in a different area of memory from the text segment. This allows for execute-in-place in an environment without virtual memory management. This option implies</source>
          <target state="translated">生成代码,允许数据段与文本段位于不同的内存区域。这允许在没有虚拟内存管理的环境中就地执行。这个选项意味着</target>
        </trans-unit>
        <trans-unit id="338b24d92797baf1f472014c3eb7e81cad28ab15" translate="yes" xml:space="preserve">
          <source>Generate code that allows trapping instructions to throw exceptions. Note that this requires platform-specific runtime support that does not exist everywhere. Moreover, it only allows &lt;em&gt;trapping&lt;/em&gt; instructions to throw exceptions, i.e. memory references or floating-point instructions. It does not allow exceptions to be thrown from arbitrary signal handlers such as &lt;code&gt;SIGALRM&lt;/code&gt;.</source>
          <target state="translated">生成允许捕获指令引发异常的代码。请注意，这需要特定于平台的运行时支持，而该支持并非在每个地方都存在。此外，它仅允许&lt;em&gt;陷阱&lt;/em&gt;指令引发异常，即内存引用或浮点指令。它不允许从任意信号处理程序（例如 &lt;code&gt;SIGALRM&lt;/code&gt; )引发异常。</target>
        </trans-unit>
        <trans-unit id="fbd1ec35fb62e61a3c0c9ad20b949b97f631374a" translate="yes" xml:space="preserve">
          <source>Generate code that assumes (does not assume) that all calls are far away so that a longer more expensive calling sequence is required.</source>
          <target state="translated">生成代码,假设(不假设)所有的调用都很远,这样就需要一个较长的较贵的调用序列。</target>
        </trans-unit>
        <trans-unit id="8f709a2890cb93e8763f592a97bd90453baa9bc3" translate="yes" xml:space="preserve">
          <source>Generate code that assumes calls never cross space boundaries. This allows GCC to emit code that performs faster indirect calls.</source>
          <target state="translated">生成假设调用永远不会跨越空间边界的代码。这使得GCC能够发出执行更快的间接调用的代码。</target>
        </trans-unit>
        <trans-unit id="16b9beb60bdc4afff878eec93b064cf17ba08cf6" translate="yes" xml:space="preserve">
          <source>Generate code that assumes that the data segment follows the text segment. This is the default.</source>
          <target state="translated">生成的代码假定数据段在文本段之后。这是默认的。</target>
        </trans-unit>
        <trans-unit id="336489e1da74ce723400b7df9bbae17f47d7009a" translate="yes" xml:space="preserve">
          <source>Generate code that assumes the target has no space registers. This allows GCC to generate faster indirect calls and use unscaled index address modes.</source>
          <target state="translated">生成假设目标没有空间寄存器的代码。这使得GCC可以生成更快的间接调用,并使用不缩放的索引地址模式。</target>
        </trans-unit>
        <trans-unit id="918ffaae0c58edeaaf21af8db9990d1e80c480af" translate="yes" xml:space="preserve">
          <source>Generate code that does not use (uses) the floating-point register set. Software floating-point emulation is provided if you use the</source>
          <target state="translated">生成不使用浮点寄存器集的代码。如果您使用的是</target>
        </trans-unit>
        <trans-unit id="c1d77eef17962d23aa2b64213060026efae223d1" translate="yes" xml:space="preserve">
          <source>Generate code that does not use &lt;code&gt;.local&lt;/code&gt; memory directly for stack storage. Instead, a per-warp stack pointer is maintained explicitly. This enables variable-length stack allocation (with variable-length arrays or &lt;code&gt;alloca&lt;/code&gt;), and when global memory is used for underlying storage, makes it possible to access automatic variables from other threads, or with atomic instructions. This code generation variant is used for OpenMP offloading, but the option is exposed on its own for the purpose of testing the compiler; to generate code suitable for linking into programs using OpenMP offloading, use option</source>
          <target state="translated">生成不直接将 &lt;code&gt;.local&lt;/code&gt; 内存用于堆栈存储的代码。而是显式地维护每个扭曲堆栈指针。这将启用可变长度堆栈分配（使用可变长度数组或 &lt;code&gt;alloca&lt;/code&gt; ），并且在将全局内存用于基础存储时，可以从其他线程或原子指令访问自动变量。此代码生成变体用于OpenMP卸载，但是为了测试编译器，该选项单独显示。要使用OpenMP卸载生成适合链接到程序的代码，请使用option</target>
        </trans-unit>
        <trans-unit id="44ab5ca5f8364ad55909ace91a8c6e880674fbc6" translate="yes" xml:space="preserve">
          <source>Generate code that does not use a global pointer register. The result is not position independent code, and violates the IA-64 ABI.</source>
          <target state="translated">生成不使用全局指针寄存器的代码。其结果不是独立于位置的代码,并违反了IA-64 ABI。</target>
        </trans-unit>
        <trans-unit id="60de4e859809d0c4dc8e855c46af0110311ff144" translate="yes" xml:space="preserve">
          <source>Generate code that doesn&amp;rsquo;t assume ID-based shared libraries are being used. This is the default.</source>
          <target state="translated">生成不假定使用基于ID的共享库的代码。这是默认值。</target>
        </trans-unit>
        <trans-unit id="354fbc6c3e514e9f7e68643c90303161a363d508" translate="yes" xml:space="preserve">
          <source>Generate code that is self-relocatable. This implies</source>
          <target state="translated">生成可自重定位的代码。这意味着</target>
        </trans-unit>
        <trans-unit id="13b5daaeeae847dab7bba6f104ed44e1ab6ee054" translate="yes" xml:space="preserve">
          <source>Generate code that keeps (does not keeps) some integer operations adjacent so that the instructions can be fused together on power8 and later processors.</source>
          <target state="translated">生成保持(不保持)一些整数运算相邻的代码,以便在power8及以后的处理器上可以将指令融合在一起。</target>
        </trans-unit>
        <trans-unit id="ebb2d4ebaa412c3ca6bb8549fd5605ffef2b8a3c" translate="yes" xml:space="preserve">
          <source>Generate code that passes function parameters and return values that (in the called function) are seen as registers &lt;code&gt;$0&lt;/code&gt; and up, as opposed to the GNU ABI which uses global registers &lt;code&gt;$231&lt;/code&gt; and up.</source>
          <target state="translated">生成传递函数参数并返回值（在调用的函数中）视为寄存器 &lt;code&gt;$0&lt;/code&gt; 及更高版本的代码，与使用全局寄存器 &lt;code&gt;$231&lt;/code&gt; 及更高版本的GNU ABI相反。</target>
        </trans-unit>
        <trans-unit id="572a137e555b3b3423721fc0e3626b6e8b160c46" translate="yes" xml:space="preserve">
          <source>Generate code that runs on &lt;var&gt;arch&lt;/var&gt;, which can be the name of a generic MIPS ISA, or the name of a particular processor. The ISA names are: &amp;lsquo;</source>
          <target state="translated">生成在 &lt;var&gt;arch&lt;/var&gt; 上运行的代码，该代码可以是通用MIPS ISA的名称，也可以是特定处理器的名称。ISA名称为：</target>
        </trans-unit>
        <trans-unit id="e20973741c69f13efd8aaaa56fd8109762470570" translate="yes" xml:space="preserve">
          <source>Generate code that runs on &lt;var&gt;cpu-type&lt;/var&gt;, which is the name of a system representing a certain processor type. Possible values for &lt;var&gt;cpu-type&lt;/var&gt; are &amp;lsquo;</source>
          <target state="translated">生成运行在 &lt;var&gt;cpu-type&lt;/var&gt; 上的代码，cpu-type是表示某种处理器类型的系统的名称。 &lt;var&gt;cpu-type&lt;/var&gt; 的可能值为'</target>
        </trans-unit>
        <trans-unit id="2afe5cce361ce178d21f1f9e300c77965e025f71" translate="yes" xml:space="preserve">
          <source>Generate code that supports calling between the ARM and Thumb instruction sets. Without this option, on pre-v5 architectures, the two instruction sets cannot be reliably used inside one program. The default is</source>
          <target state="translated">生成支持在ARM和Thumb指令集之间调用的代码。如果没有这个选项,在pre-v5架构上,两个指令集不能在一个程序中可靠地使用。默认值是</target>
        </trans-unit>
        <trans-unit id="1e1b0c53abd34ffe18acaa9b5781550d29a84379" translate="yes" xml:space="preserve">
          <source>Generate code that supports shared libraries via the library ID method, but assumes that this library or executable won&amp;rsquo;t link against any other ID shared libraries. That allows the compiler to use faster code for jumps and calls.</source>
          <target state="translated">通过库ID方法生成支持共享库的代码，但假定该库或可执行文件不会链接到任何其他ID共享库。这使编译器可以使用更快的代码进行跳转和调用。</target>
        </trans-unit>
        <trans-unit id="19a4d4ef1ca305d055c2c43578e68d17e9af2a97" translate="yes" xml:space="preserve">
          <source>Generate code that supports shared libraries via the library ID method. This allows for execute in place and shared libraries in an environment without virtual memory management. This option implies</source>
          <target state="translated">通过库ID方法生成支持共享库的代码。这允许在没有虚拟内存管理的环境中执行原地和共享库。这个选项意味着</target>
        </trans-unit>
        <trans-unit id="d499e8859196b03e31f4b5d6d30e4cb073e79ae2" translate="yes" xml:space="preserve">
          <source>Generate code that supports shared libraries via the library ID method. This allows for execute-in-place and shared libraries in an environment without virtual memory management. This option implies</source>
          <target state="translated">通过库ID方法生成支持共享库的代码。这允许在没有虚拟内存管理的环境中执行原地和共享库。这个选项意味着</target>
        </trans-unit>
        <trans-unit id="3080019b4a448b8d2f42e11601716bd17c75e272" translate="yes" xml:space="preserve">
          <source>Generate code that tries to avoid (not avoid) the use of indexed load or store instructions.</source>
          <target state="translated">生成试图避免(不是避免)使用索引加载或存储指令的代码。</target>
        </trans-unit>
        <trans-unit id="1d7d0f8dbe32444b165a61440094a0d21d656220" translate="yes" xml:space="preserve">
          <source>Generate code that tries to avoid (not avoid) the use of indexed load or store instructions. These instructions can incur a performance penalty on Power6 processors in certain situations, such as when stepping through large arrays that cross a 16M boundary. This option is enabled by default when targeting Power6 and disabled otherwise.</source>
          <target state="translated">生成代码,尽量避免(而不是避免)使用索引加载或存储指令。在某些情况下,这些指令可能会在Power6处理器上招致性能惩罚,例如在步入跨越16M边界的大型数组时。该选项在针对Power6时默认启用,否则禁用。</target>
        </trans-unit>
        <trans-unit id="bf98fe716d964a094592ad1d59afe4951cb9d36f" translate="yes" xml:space="preserve">
          <source>Generate code that uses (does not use) AltiVec instructions, and also enable the use of built-in functions that allow more direct access to the AltiVec instruction set. You may also need to set</source>
          <target state="translated">生成使用(不使用)AltiVec指令的代码,也可以启用内置函数,允许更直接地访问AltiVec指令集。您可能还需要设置</target>
        </trans-unit>
        <trans-unit id="2f5b28537613ef22817b9ba8bf63c4e1f2104514" translate="yes" xml:space="preserve">
          <source>Generate code that uses (does not use) AltiVec instructions. In 32-bit code, you cannot enable AltiVec instructions unless</source>
          <target state="translated">生成使用(不使用)AltiVec指令的代码。在32位代码中,你不能启用AltiVec指令,除非</target>
        </trans-unit>
        <trans-unit id="8c04238a31ea4511a013025b49118e3c3e42e84e" translate="yes" xml:space="preserve">
          <source>Generate code that uses (does not use) ISEL instruction.</source>
          <target state="translated">生成使用(不使用)ISEL指令的代码。</target>
        </trans-unit>
        <trans-unit id="92155be900bc9933add2300c7a5d23503087ce0e" translate="yes" xml:space="preserve">
          <source>Generate code that uses (does not use) VAX F and G floating-point arithmetic instead of IEEE single and double precision.</source>
          <target state="translated">生成使用(不使用)VAX F和G浮点算术而不是IEEE单精度和双精度的代码。</target>
        </trans-unit>
        <trans-unit id="b95c7c98a27a75ea4aed9a1312a1f6d81d84fc5d" translate="yes" xml:space="preserve">
          <source>Generate code that uses (does not use) the FP move to/from general purpose register instructions implemented on the POWER6X processor and other processors that support the extended PowerPC V2.05 architecture.</source>
          <target state="translated">生成使用(不使用)在POWER6X处理器和其他支持扩展的PowerPC V2.05架构的处理器上实现的FP移动到/从通用寄存器指令的代码。</target>
        </trans-unit>
        <trans-unit id="a2c4f9d3a1eb191b5662b1d07619055360c468c4" translate="yes" xml:space="preserve">
          <source>Generate code that uses (does not use) the FP round to integer instructions implemented on the POWER5+ processor and other processors that support the PowerPC V2.03 architecture.</source>
          <target state="translated">生成使用(不使用)POWER5+处理器和其他支持PowerPC V2.03架构的处理器上实现的FP舍入到整数指令的代码。</target>
        </trans-unit>
        <trans-unit id="46d6eec21f4fa802b85560d860276b9199fed94b" translate="yes" xml:space="preserve">
          <source>Generate code that uses (does not use) the atomic quad word memory instructions. The</source>
          <target state="translated">生成使用(不使用)原子四字内存指令的代码。该</target>
        </trans-unit>
        <trans-unit id="262e0fd3e027fbfbead855b3f29a870f608f4f72" translate="yes" xml:space="preserve">
          <source>Generate code that uses (does not use) the compare bytes instruction implemented on the POWER6 processor and other processors that support the PowerPC V2.05 architecture.</source>
          <target state="translated">生成使用(不使用)POWER6处理器和其他支持PowerPC V2.05架构的处理器上实现的比较字节指令的代码。</target>
        </trans-unit>
        <trans-unit id="08b86aae00b13e22b96514a69b5b064be8919eb4" translate="yes" xml:space="preserve">
          <source>Generate code that uses (does not use) the decimal floating-point instructions implemented on some POWER processors.</source>
          <target state="translated">生成使用(不使用)某些POWER处理器上实现的十进制浮点指令的代码。</target>
        </trans-unit>
        <trans-unit id="3131d9ab648d637f7f2b9519e03b551e9a374743" translate="yes" xml:space="preserve">
          <source>Generate code that uses (does not use) the floating-point multiply and accumulate instructions. These instructions are generated by default if hardware floating point is used.</source>
          <target state="translated">生成使用(不使用)浮点乘法和累加指令的代码。如果使用硬件浮点,则默认生成这些指令。</target>
        </trans-unit>
        <trans-unit id="c04a8a825b0f94e2eb07f4e8f21cb84241b2efaf" translate="yes" xml:space="preserve">
          <source>Generate code that uses (does not use) the floating-point multiply and accumulate instructions. These instructions are generated by default if hardware floating point is used. The machine-dependent</source>
          <target state="translated">生成使用(不使用)浮点乘法和累加指令的代码。如果使用硬件浮点,则默认生成这些指令。依赖于机器的</target>
        </trans-unit>
        <trans-unit id="61eadf2cc65c85da3c9ba20e0d77a3b18047c546" translate="yes" xml:space="preserve">
          <source>Generate code that uses (does not use) the floating-point register set.</source>
          <target state="translated">生成使用(不使用)浮点寄存器集的代码。</target>
        </trans-unit>
        <trans-unit id="32b3b39a373f02faec1c8e47cea1029610f3648e" translate="yes" xml:space="preserve">
          <source>Generate code that uses (does not use) the generation of PAIRED simd instructions.</source>
          <target state="translated">生成使用(不使用)生成paired simd指令的代码。</target>
        </trans-unit>
        <trans-unit id="a16384b2cc48decd8d149f4edeab3b4637c6c2dd" translate="yes" xml:space="preserve">
          <source>Generate code that uses (does not use) the half-word multiply and multiply-accumulate instructions on the IBM 405, 440, 464 and 476 processors. These instructions are generated by default when targeting those processors.</source>
          <target state="translated">生成使用(不使用)IBM 405、440、464和476处理器上的半字乘法和乘法累加指令的代码。当针对这些处理器时,这些指令是默认生成的。</target>
        </trans-unit>
        <trans-unit id="0ae0cd2b0200a8b41b70cb257df1cc0c71cf4ea9" translate="yes" xml:space="preserve">
          <source>Generate code that uses (does not use) the load multiple word instructions and the store multiple word instructions.</source>
          <target state="translated">生成使用(不使用)加载多字指令和存储多字指令的代码。</target>
        </trans-unit>
        <trans-unit id="2c52b95b537c53566c2534b67e93882f9aca68b1" translate="yes" xml:space="preserve">
          <source>Generate code that uses (does not use) the load multiple word instructions and the store multiple word instructions. These instructions are generated by default on POWER systems, and not generated on PowerPC systems. Do not use</source>
          <target state="translated">生成使用(不使用)加载多字指令和存储多字指令的代码。这些指令在POWER系统上默认生成,在PowerPC系统上不生成。请不要使用</target>
        </trans-unit>
        <trans-unit id="fd774e2be13b8cb13d5052ff903f2b6dbbaa0be4" translate="yes" xml:space="preserve">
          <source>Generate code that uses (does not use) the load or store instructions that update the base register to the address of the calculated memory location.</source>
          <target state="translated">生成使用(不使用)加载或存储指令的代码,将基本寄存器更新到计算出的内存位置的地址。</target>
        </trans-unit>
        <trans-unit id="a22e11f108e540ae0805ccbff5751fce923b96a4" translate="yes" xml:space="preserve">
          <source>Generate code that uses (does not use) the load or store instructions that update the base register to the address of the calculated memory location. These instructions are generated by default. If you use</source>
          <target state="translated">生成使用(不使用)加载或存储指令的代码,这些指令将基本寄存器更新到计算的内存位置的地址。这些指令是默认生成的。如果您使用</target>
        </trans-unit>
        <trans-unit id="0770f3e5c30f3b0aaaeba94f431ff5516808b06c" translate="yes" xml:space="preserve">
          <source>Generate code that uses (does not use) the load string instructions and the store string word instructions to save multiple registers and do small block moves.</source>
          <target state="translated">生成使用(不使用)加载字符串指令和存储字符串字指令来保存多个寄存器并进行小块移动的代码。</target>
        </trans-unit>
        <trans-unit id="386b3e18aecf301e2272c3303cef5b3408b3d72f" translate="yes" xml:space="preserve">
          <source>Generate code that uses (does not use) the move from condition register field instruction implemented on the POWER4 processor and other processors that support the PowerPC V2.01 architecture.</source>
          <target state="translated">生成使用(不使用)POWER4处理器和其他支持PowerPC V2.01架构的处理器上实现的从条件寄存器字段指令的代码。</target>
        </trans-unit>
        <trans-unit id="87adae88954ee8917f3f31be376d9936d82cd4bc" translate="yes" xml:space="preserve">
          <source>Generate code that uses (does not use) the non-atomic quad word memory instructions. The</source>
          <target state="translated">生成使用(不使用)非原子四字内存指令的代码。该</target>
        </trans-unit>
        <trans-unit id="fc8745a466eb796ef7f9c5a441c7003ed311977e" translate="yes" xml:space="preserve">
          <source>Generate code that uses (does not use) the optional PowerPC architecture instructions in the General Purpose group, including floating-point square root.</source>
          <target state="translated">生成使用(不使用)通用组中可选的PowerPC架构指令的代码,包括浮点平方根。</target>
        </trans-unit>
        <trans-unit id="27810752cbb1f58324d02017084ca261477ff314" translate="yes" xml:space="preserve">
          <source>Generate code that uses (does not use) the optional PowerPC architecture instructions in the Graphics group, including floating-point select.</source>
          <target state="translated">生成使用(不使用)图形组中可选的PowerPC架构指令的代码,包括浮点选择。</target>
        </trans-unit>
        <trans-unit id="98f0227605ad4df08722181505cb7a14d55e9799" translate="yes" xml:space="preserve">
          <source>Generate code that uses (does not use) the popcount and double-precision FP reciprocal estimate instruction implemented on the POWER5 processor and other processors that support the PowerPC V2.02 architecture.</source>
          <target state="translated">生成使用(不使用)POWER5处理器和其他支持PowerPC V2.02架构的处理器上实现的popcount和双精度FP往复估计指令的代码。</target>
        </trans-unit>
        <trans-unit id="c07537f1993a55be984ad5f397058498e67120dd" translate="yes" xml:space="preserve">
          <source>Generate code that uses (does not use) the popcount instruction implemented on the POWER7 processor and other processors that support the PowerPC V2.06 architecture.</source>
          <target state="translated">生成使用(不使用)POWER7处理器和其他支持PowerPC V2.06架构的处理器上实现的popcount指令的代码。</target>
        </trans-unit>
        <trans-unit id="4b15de7f2b7f03ed6e1790dbf982c588fb5b3528" translate="yes" xml:space="preserve">
          <source>Generate code that uses (does not use) the string-search &amp;lsquo;</source>
          <target state="translated">生成使用（不使用）字符串搜索'</target>
        </trans-unit>
        <trans-unit id="ab7a2922566d7313797a3ac188f3c0be7688df71" translate="yes" xml:space="preserve">
          <source>Generate code that uses (does not use) the vector and scalar instructions that were added in version 2.07 of the PowerPC ISA. Also enable the use of built-in functions that allow more direct access to the vector instructions.</source>
          <target state="translated">生成使用(不使用)PowerPC ISA 2.07版本中新增的向量和标量指令的代码。还可以使用内置函数,允许更直接地访问向量指令。</target>
        </trans-unit>
        <trans-unit id="f7dd4f67d21a30765965ab7e7de435cac230ac64" translate="yes" xml:space="preserve">
          <source>Generate code that uses (does not use) vector/scalar (VSX) instructions, and also enable the use of built-in functions that allow more direct access to the VSX instruction set.</source>
          <target state="translated">生成使用(不使用)矢量/标量(VSX)指令的代码,还可以使用内置函数,允许更直接地访问VSX指令集。</target>
        </trans-unit>
        <trans-unit id="05ca89c3814bc0cbed05cab7398d230442544564" translate="yes" xml:space="preserve">
          <source>Generate code that uses (does not use) vector/scalar (VSX) instructions, and also enable the use of built-in functions that allow more direct access to the VSX instruction set. In 32-bit code, you cannot enable VSX or AltiVec instructions unless</source>
          <target state="translated">生成使用(不使用)矢量/标量(VSX)指令的代码,还可以启用内置函数,允许更直接地访问VSX指令集。在32位代码中,不能启用VSX或AltiVec指令,除非</target>
        </trans-unit>
        <trans-unit id="67b86bb995294b5ded4deb3fb6384281013e8cde" translate="yes" xml:space="preserve">
          <source>Generate code that uses a BSS &lt;code&gt;.plt&lt;/code&gt; section that &lt;code&gt;ld.so&lt;/code&gt; fills in, and requires &lt;code&gt;.plt&lt;/code&gt; and &lt;code&gt;.got&lt;/code&gt; sections that are both writable and executable. This is a PowerPC 32-bit SYSV ABI option.</source>
          <target state="translated">生成使用 &lt;code&gt;ld.so&lt;/code&gt; 填充的BSS &lt;code&gt;.plt&lt;/code&gt; 节的代码，并需要可写和可执行的 &lt;code&gt;.plt&lt;/code&gt; 和 &lt;code&gt;.got&lt;/code&gt; 节。这是PowerPC 32位SYSV ABI选项。</target>
        </trans-unit>
        <trans-unit id="6beeb427ddc734bea4c58516baa43a91d09099d2" translate="yes" xml:space="preserve">
          <source>Generate code that uses a single constant global pointer value. This is useful when compiling kernel code.</source>
          <target state="translated">生成使用单个常量全局指针值的代码。这在编译内核代码时很有用。</target>
        </trans-unit>
        <trans-unit id="6f2e6ea4728870634a5f76e2497b052f725aed62" translate="yes" xml:space="preserve">
          <source>Generate code that uses long call sequences. This ensures that a call is always able to reach linker generated stubs. The default is to generate long calls only when the distance from the call site to the beginning of the function or translation unit, as the case may be, exceeds a predefined limit set by the branch type being used. The limits for normal calls are 7,600,000 and 240,000 bytes, respectively for the PA 2.0 and PA 1.X architectures. Sibcalls are always limited at 240,000 bytes.</source>
          <target state="translated">生成使用长调用序列的代码。这确保调用总是能够到达链接器生成的存根。默认情况下,只有当从调用站点到函数或翻译单元(视情况而定)的开始的距离超过由正在使用的分支类型设置的预定义限制时,才会生成长调用。PA 2.0 和 PA 1.X 架构的普通调用限制分别为 7,600,000 和 240,000 字节。Sibcalls 始终限制在 240,000 字节。</target>
        </trans-unit>
        <trans-unit id="0ddfa4b3d16d23a89e5776522951b15e62426fdc" translate="yes" xml:space="preserve">
          <source>Generate code that uses only the general-purpose registers. This prevents the compiler from using floating-point, vector, mask and bound registers.</source>
          <target state="translated">生成只使用通用寄存器的代码。这可以防止编译器使用浮点、向量、掩码和绑定寄存器。</target>
        </trans-unit>
        <trans-unit id="baac973b3b5994adc6aef021db0133816bd28382" translate="yes" xml:space="preserve">
          <source>Generate code to access thread-local storage using the &amp;lsquo;</source>
          <target state="translated">使用'生成代码以访问线程本地存储</target>
        </trans-unit>
        <trans-unit id="c88cdcf77b77d16255b95669179f017ca5ceda39" translate="yes" xml:space="preserve">
          <source>Generate code to automatically split the stack before it overflows. The resulting program has a discontiguous stack which can only overflow if the program is unable to allocate any more memory. This is most useful when running threaded programs, as it is no longer necessary to calculate a good stack size to use for each thread. This is currently only implemented for the x86 targets running GNU/Linux.</source>
          <target state="translated">生成代码,在堆栈溢出之前自动分割堆栈。生成的程序有一个不连续的栈,只有在程序无法分配更多的内存时才会溢出。这在运行线程程序时最为有用,因为它不再需要为每个线程计算一个好的堆栈大小。目前只有运行GNU/Linux的x86目标才会实现这个功能。</target>
        </trans-unit>
        <trans-unit id="915ccec10fdc8928f52708c97467282540464b8a" translate="yes" xml:space="preserve">
          <source>Generate code to avoid bugs in the multiply instructions for the MN10300 processors. This is the default.</source>
          <target state="translated">生成代码以避免MN10300处理器的乘法指令出现错误。这是默认值。</target>
        </trans-unit>
        <trans-unit id="0df3e04d22344e23f6649b40a52c7d6f0c186350" translate="yes" xml:space="preserve">
          <source>Generate code to ensure that the stack does not grow beyond a certain value, either the value of a register or the address of a symbol. If a larger stack is required, a signal is raised at run time. For most targets, the signal is raised before the stack overruns the boundary, so it is possible to catch the signal without taking special precautions.</source>
          <target state="translated">生成代码,以确保堆栈的增长不超过某个值,无论是寄存器的值还是符号的地址。如果需要更大的栈,在运行时就会发出信号。对于大多数目标来说,信号会在堆栈超过边界之前就被提出,因此可以不采取特殊的预防措施来捕捉信号。</target>
        </trans-unit>
        <trans-unit id="1b66c9f22b9ae2f51f7b68dcb90be43a732528ba" translate="yes" xml:space="preserve">
          <source>Generate code to prevent stack clash style attacks. When this option is enabled, the compiler will only allocate one page of stack space at a time and each page is accessed immediately after allocation. Thus, it prevents allocations from jumping over any stack guard page provided by the operating system.</source>
          <target state="translated">生成代码以防止堆栈冲突式攻击。启用该选项后,编译器每次只分配一页堆栈空间,且每一页在分配后立即被访问。因此,它可以防止分配跳过操作系统提供的任何堆栈保护页。</target>
        </trans-unit>
        <trans-unit id="dd0c489c581360afbf7f7a5091b3992e53e109af" translate="yes" xml:space="preserve">
          <source>Generate code to verify that you do not go beyond the boundary of the stack. You should specify this flag if you are running in an environment with multiple threads, but you only rarely need to specify it in a single-threaded environment since stack overflow is automatically detected on nearly all systems if there is only one stack.</source>
          <target state="translated">生成代码来验证你是否没有超出栈的边界。如果你运行在有多个线程的环境中,你应该指定这个标志,但在单线程环境中,你只需要很少指定这个标志,因为如果只有一个栈,几乎所有系统都会自动检测到栈溢出。</target>
        </trans-unit>
        <trans-unit id="f09658f66e71e4832575a43871e37604d20cbdbd" translate="yes" xml:space="preserve">
          <source>Generate code treating the given register range as fixed registers. A fixed register is one that the register allocator cannot use. This is useful when compiling kernel code. A register range is specified as two registers separated by a dash. Multiple register ranges can be specified separated by a comma.</source>
          <target state="translated">生成将给定寄存器范围作为固定寄存器的代码。固定寄存器是指寄存器分配器不能使用的寄存器。这在编译内核代码时很有用。一个寄存器范围被指定为两个用破折号分隔的寄存器。可以用逗号分隔指定多个寄存器范围。</target>
        </trans-unit>
        <trans-unit id="69365c978ad182890bcb4e65e053170c8830231a" translate="yes" xml:space="preserve">
          <source>Generate code using &lt;code&gt;push&lt;/code&gt; and &lt;code&gt;pop&lt;/code&gt; instructions. This option defaults to on.</source>
          <target state="translated">使用 &lt;code&gt;push&lt;/code&gt; 和 &lt;code&gt;pop&lt;/code&gt; 指令生成代码。此选项默认为打开。</target>
        </trans-unit>
        <trans-unit id="7f296d4ed278effc8fa87bfb0e530628874d3432" translate="yes" xml:space="preserve">
          <source>Generate code using &lt;code&gt;stm&lt;/code&gt; and &lt;code&gt;ldm&lt;/code&gt; instructions. This option isn&amp;rsquo;t supported on CK801 but is enabled by default on other processors.</source>
          <target state="translated">使用 &lt;code&gt;stm&lt;/code&gt; 和 &lt;code&gt;ldm&lt;/code&gt; 指令生成代码。CK801不支持此选项，但默认情况下在其他处理器上启用此选项。</target>
        </trans-unit>
        <trans-unit id="ba4d33b91d9e6ab2d69e87dce44c7244b439ed9e" translate="yes" xml:space="preserve">
          <source>Generate code using features specific to the AM33 processor.</source>
          <target state="translated">使用AM33处理器特有的功能生成代码。</target>
        </trans-unit>
        <trans-unit id="b0f3f1a0016506b7432a6808d95156263172db1a" translate="yes" xml:space="preserve">
          <source>Generate code using features specific to the AM33/2.0 processor.</source>
          <target state="translated">使用AM33/2.0处理器特有的功能生成代码。</target>
        </trans-unit>
        <trans-unit id="4d51b4beaa1d3a18f186ce7d15002cb82d47e204" translate="yes" xml:space="preserve">
          <source>Generate code using features specific to the AM34 processor.</source>
          <target state="translated">使用AM34处理器特有的功能生成代码。</target>
        </trans-unit>
        <trans-unit id="c282f618bb7db95f0feff29b3266b2478e4e252b" translate="yes" xml:space="preserve">
          <source>Generate code using global anchor symbol addresses.</source>
          <target state="translated">使用全局锚符号地址生成代码。</target>
        </trans-unit>
        <trans-unit id="cb509e9252b480e0a1aeb49faf8b1ef18fa7edf6" translate="yes" xml:space="preserve">
          <source>Generate code using the FDPIC ABI.</source>
          <target state="translated">使用FDPIC ABI生成代码。</target>
        </trans-unit>
        <trans-unit id="404e8a65099de95616c40afb1bc863ffa2523650" translate="yes" xml:space="preserve">
          <source>Generate code using the high registers numbered 16-31. This option is not supported on CK801, CK802, or CK803, and is enabled by default for other processors.</source>
          <target state="translated">使用编号为16-31的高位寄存器生成代码,CK801、CK802或CK803不支持该选项,其他处理器默认启用。CK801、CK802或CK803不支持此选项,其他处理器默认启用。</target>
        </trans-unit>
        <trans-unit id="4cb05ce3f6ef091d20d86e01a77fc7f4a59d0bcc" translate="yes" xml:space="preserve">
          <source>Generate code which uses only the general-purpose registers. This will prevent the compiler from using floating-point and Advanced SIMD registers but will not impose any restrictions on the assembler.</source>
          <target state="translated">生成只使用通用寄存器的代码。这将阻止编译器使用浮点和高级SIMD寄存器,但不会对汇编器施加任何限制。</target>
        </trans-unit>
        <trans-unit id="9cce76ef82a38c3b96967249a0f61e0fb26b9334" translate="yes" xml:space="preserve">
          <source>Generate compiler predefines and select a startfile for the specified UNIX standard. The choices for &lt;var&gt;unix-std&lt;/var&gt; are &amp;lsquo;</source>
          <target state="translated">生成编译器预定义并为指定的UNIX标准选择一个起始文件。 &lt;var&gt;unix-std&lt;/var&gt; 的选择是'</target>
        </trans-unit>
        <trans-unit id="a678e34a31471d170303da9eda1b930e2324a992" translate="yes" xml:space="preserve">
          <source>Generate conditional move instructions.</source>
          <target state="translated">生成有条件的移动指令。</target>
        </trans-unit>
        <trans-unit id="d72e8c8e0f9b51ca898631ea4a5646d5c76664c2" translate="yes" xml:space="preserve">
          <source>Generate divide instructions. Default is off.</source>
          <target state="translated">生成除法指令。默认为关闭。</target>
        </trans-unit>
        <trans-unit id="16d77d1fe0a8bda494d3925636feea2c269c0e3f" translate="yes" xml:space="preserve">
          <source>Generate double-precision FPX instructions, tuned for the compact implementation.</source>
          <target state="translated">生成双精度FPX指令,针对紧凑的实现进行调整。</target>
        </trans-unit>
        <trans-unit id="c229df63f7c476d6f9fecd75b4ac0f6491159589" translate="yes" xml:space="preserve">
          <source>Generate double-precision FPX instructions, tuned for the fast implementation.</source>
          <target state="translated">生成双精度FPX指令,调整为快速实现。</target>
        </trans-unit>
        <trans-unit id="efd3351263c1d9caa26ca401350421bfc7b35243" translate="yes" xml:space="preserve">
          <source>Generate extended arithmetic instructions. Currently only &lt;code&gt;divaw&lt;/code&gt;, &lt;code&gt;adds&lt;/code&gt;, &lt;code&gt;subs&lt;/code&gt;, and &lt;code&gt;sat16&lt;/code&gt; are supported. This is always enabled for</source>
          <target state="translated">生成扩展的算术指令。当前仅支持 &lt;code&gt;divaw&lt;/code&gt; ， &lt;code&gt;adds&lt;/code&gt; ， &lt;code&gt;subs&lt;/code&gt; 和 &lt;code&gt;sat16&lt;/code&gt; 。始终启用</target>
        </trans-unit>
        <trans-unit id="6856e99222352076039e94fbdf5c31806c05feaa" translate="yes" xml:space="preserve">
          <source>Generate extended debug information for inlined functions. Location view tracking markers are inserted at inlined entry points, so that address and view numbers can be computed and output in debug information. This can be enabled independently of location views, in which case the view numbers won&amp;rsquo;t be output, but it can only be enabled along with statement frontiers, and it is only enabled by default if location views are enabled.</source>
          <target state="translated">生成内联函数的扩展调试信息。将位置视图跟踪标记插入到内联的入口点，以便可以计算地址和视图编号并将其输出到调试信息中。可以独立于位置视图启用此功能，在这种情况下，将不会输出视图编号，但只能与语句边界一起启用，并且仅在启用位置视图的情况下默认启用。</target>
        </trans-unit>
        <trans-unit id="5d0b2408362730cc5b4ed897b120cdb4b4cc4031" translate="yes" xml:space="preserve">
          <source>Generate extra code to write profile information suitable for the analysis program &lt;code&gt;prof&lt;/code&gt; (for</source>
          <target state="translated">生成额外的代码以编写适合分析程序 &lt;code&gt;prof&lt;/code&gt; 配置文件信息（用于</target>
        </trans-unit>
        <trans-unit id="c6eeb91a33862dbf10594e59a0033583feb5fde5" translate="yes" xml:space="preserve">
          <source>Generate floating-point arithmetic for selected unit &lt;var&gt;unit&lt;/var&gt;. The choices for &lt;var&gt;unit&lt;/var&gt; are:</source>
          <target state="translated">为选定的单位 &lt;var&gt;unit&lt;/var&gt; 生成浮点算法。 &lt;var&gt;unit&lt;/var&gt; 的选择是：</target>
        </trans-unit>
        <trans-unit id="79ec4a91ff56b1468e2e0960559756f702528e59" translate="yes" xml:space="preserve">
          <source>Generate floating-point comparison instructions that compare with respect to the &lt;code&gt;rE&lt;/code&gt; epsilon register.</source>
          <target state="translated">生成与 &lt;code&gt;rE&lt;/code&gt; epsilon寄存器进行比较的浮点比较指令。</target>
        </trans-unit>
        <trans-unit id="5184b7fbfd727379c1835aa4d91abffedcc6f989" translate="yes" xml:space="preserve">
          <source>Generate floating-point instructions. This is the default for 68020 and above, and for ColdFire devices that have an FPU. It defines the macro &lt;code&gt;__HAVE_68881__&lt;/code&gt; on M680x0 targets and &lt;code&gt;__mcffpu__&lt;/code&gt; on ColdFire targets.</source>
          <target state="translated">生成浮点指令。对于68020及更高版本以及具有FPU的ColdFire设备，这是默认设置。它定义了宏 &lt;code&gt;__HAVE_68881__&lt;/code&gt; 上M680x0目标和 &lt;code&gt;__mcffpu__&lt;/code&gt; 上的ColdFire目标。</target>
        </trans-unit>
        <trans-unit id="6ff3989b144109cfd18ff049af7f71f4c3c9f86e" translate="yes" xml:space="preserve">
          <source>Generate hardware atomic sequences using the &lt;code&gt;movli.l&lt;/code&gt; and &lt;code&gt;movco.l&lt;/code&gt; instructions only. This is only available on SH4A and is suitable for multi-core systems. Since the hardware instructions support only 32 bit atomic variables access to 8 or 16 bit variables is emulated with 32 bit accesses. Code compiled with this option is also compatible with other software atomic model interrupt/exception handling systems if executed on an SH4A system. Additional support from the interrupt/exception handling code of the system is not required for this model.</source>
          <target state="translated">仅使用 &lt;code&gt;movli.l&lt;/code&gt; 和 &lt;code&gt;movco.l&lt;/code&gt; 指令生成硬件原子序列。仅在SH4A上可用，并且适用于多核系统。由于硬件指令仅支持32位原子变量，因此使用32位访问模拟对8位或16位变量的访问。如果在SH4A系统上执行，使用此选项编译的代码也与其他软件原子模型中断/异常处理系统兼容。该型号不需要系统的中断/异常处理代码的额外支持。</target>
        </trans-unit>
        <trans-unit id="d8debf693e895754ae8dfa412a7398684e52957b" translate="yes" xml:space="preserve">
          <source>Generate instructions for the machine type &lt;var&gt;cpu-type&lt;/var&gt;. In contrast to</source>
          <target state="translated">为机器类型 &lt;var&gt;cpu-type&lt;/var&gt; 生成指令。与之相反</target>
        </trans-unit>
        <trans-unit id="4d9806e63398f5c7206d46ddf2dd393879704321" translate="yes" xml:space="preserve">
          <source>Generate instructions supported by barrel shifter. This is the default unless</source>
          <target state="translated">生成桶式移位器支持的指令。这是默认的,除非</target>
        </trans-unit>
        <trans-unit id="a86b264be3b7927eef8b4d4ec32bd6e0abb23e9a" translate="yes" xml:space="preserve">
          <source>Generate instrumentation calls for entry and exit to functions. Just after function entry and just before function exit, the following profiling functions are called with the address of the current function and its call site. (On some platforms, &lt;code&gt;__builtin_return_address&lt;/code&gt; does not work beyond the current function, so the call site information may not be available to the profiling functions otherwise.)</source>
          <target state="translated">生成用于调用和退出函数的检测调用。在函数进入之后和函数退出之前，将使用当前函数的地址及其调用位置来调用以下概要分析函数。（在某些平台上， &lt;code&gt;__builtin_return_address&lt;/code&gt; 在当前功能之外无法正常工作，因此，否则分析功能可能无法使用呼叫站点信息。）</target>
        </trans-unit>
        <trans-unit id="a558056c364dd801f66dea4bd9ff5d7025049fb1" translate="yes" xml:space="preserve">
          <source>Generate little-endian (default) or big-endian (experimental) code, respectively.</source>
          <target state="translated">分别生成小二烯(默认)或大二烯(实验)代码。</target>
        </trans-unit>
        <trans-unit id="8c624983438064d33fb3b88653aa23aaa51afa20" translate="yes" xml:space="preserve">
          <source>Generate little-endian code.</source>
          <target state="translated">生成小二烯码。</target>
        </trans-unit>
        <trans-unit id="d362bc65e7c53091f19c9e25dc0b1f5baf698d4a" translate="yes" xml:space="preserve">
          <source>Generate little-endian code. This is the default for &amp;lsquo;</source>
          <target state="translated">生成小端代码。这是&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="66047ec2f64b4bd1b8fdd5fa2877f3f85b442eac" translate="yes" xml:space="preserve">
          <source>Generate little-endian code. This is the default when GCC is configured for an &amp;lsquo;</source>
          <target state="translated">生成小端代码。当将GCC配置为&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="e76d98abdce9e7fa1b4a7b7f0a6241f584dc592c" translate="yes" xml:space="preserve">
          <source>Generate mul.x and umul.x instructions. This is the default for &amp;lsquo;</source>
          <target state="translated">生成mul.x和umul.x指令。这是&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="11b3830c8f1fe1ef2c6dc043ba7fa4b0665f2d6d" translate="yes" xml:space="preserve">
          <source>Generate non-looping inline code for all block compares (such as calls to &lt;code&gt;memcmp&lt;/code&gt; or structure compares) less than or equal to &lt;var&gt;num&lt;/var&gt; bytes. If &lt;var&gt;num&lt;/var&gt; is 0, all inline expansion (non-loop and loop) of block compare is disabled. The default value is target-specific.</source>
          <target state="translated">为所有小于或等于 &lt;var&gt;num&lt;/var&gt; 个字节的块比较（例如，调用 &lt;code&gt;memcmp&lt;/code&gt; 或结构比较）生成非循环内联代码。如果 &lt;var&gt;num&lt;/var&gt; 为0，则禁用块比较的所有内联扩展（非循环和循环）。默认值为特定于目标的。</target>
        </trans-unit>
        <trans-unit id="726e8e558f2a846b8999b9aeb3c7faa8d320b08e" translate="yes" xml:space="preserve">
          <source>Generate object code compatible with the standard GNU Objective-C runtime. This is the default for most types of systems.</source>
          <target state="translated">生成与标准GNU Objective-C运行时兼容的对象代码。这是大多数类型系统的默认值。</target>
        </trans-unit>
        <trans-unit id="5f828fdb836a3167f3a117e320f8c23966c29566" translate="yes" xml:space="preserve">
          <source>Generate output compatible with the NeXT runtime. This is the default for NeXT-based systems, including Darwin and Mac OS X. The macro &lt;code&gt;__NEXT_RUNTIME__&lt;/code&gt; is predefined if (and only if) this option is used.</source>
          <target state="translated">生成与NeXT运行时兼容的输出。这是基于NeXT的系统（包括Darwin和Mac OS X）的默认设置。如果（且仅）使用此选项，则预定义了宏 &lt;code&gt;__NEXT_RUNTIME__&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3b10b8584ef5629375b0697c006157af2562811c" translate="yes" xml:space="preserve">
          <source>Generate output containing 80387 instructions for floating point.</source>
          <target state="translated">生成包含80387条浮点指令的输出。</target>
        </trans-unit>
        <trans-unit id="4ac64fa385d79df6893e650d3c87094e5fab8e8d" translate="yes" xml:space="preserve">
          <source>Generate output containing floating-point instructions. This is the default.</source>
          <target state="translated">生成包含浮点指令的输出。这是默认的。</target>
        </trans-unit>
        <trans-unit id="a54c9d559afdf54011312401dae184f34851998d" translate="yes" xml:space="preserve">
          <source>Generate output containing library calls for floating point.</source>
          <target state="translated">生成包含浮点函数库调用的输出。</target>
        </trans-unit>
        <trans-unit id="b68715959fa47ba0ff79de672b756a42be41a84c" translate="yes" xml:space="preserve">
          <source>Generate output containing library calls for floating point. &lt;strong&gt;Warning:&lt;/strong&gt; the requisite libraries are not available for all HPPA targets. Normally the facilities of the machine&amp;rsquo;s usual C compiler are used, but this cannot be done directly in cross-compilation. You must make your own arrangements to provide suitable library functions for cross-compilation.</source>
          <target state="translated">生成包含浮点库调用的输出。&lt;strong&gt;警告：&lt;/strong&gt;并非所有HPPA目标都必须具备必需的库。通常使用机器常用的C编译器的功能，但是不能直接在交叉编译中完成。您必须自行安排以提供合适的库函数以进行交叉编译。</target>
        </trans-unit>
        <trans-unit id="123686fdd6543b04616633629545ce470b234181" translate="yes" xml:space="preserve">
          <source>Generate output containing library calls for floating point. &lt;strong&gt;Warning:&lt;/strong&gt; the requisite libraries are not available for all SPARC targets. Normally the facilities of the machine&amp;rsquo;s usual C compiler are used, but this cannot be done directly in cross-compilation. You must make your own arrangements to provide suitable library functions for cross-compilation. The embedded targets &amp;lsquo;</source>
          <target state="translated">生成包含浮点库调用的输出。&lt;strong&gt;警告：&lt;/strong&gt;并非所有SPARC目标都必须具备必需的库。通常使用机器常用的C编译器的功能，但是不能直接在交叉编译中完成。您必须自行安排以提供合适的库函数以进行交叉编译。嵌入式目标&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="374b214aae9f131ecd8bd8fbf3ba7e20116baf86" translate="yes" xml:space="preserve">
          <source>Generate output containing library calls for quad-word (long double) floating-point instructions. The functions called are those specified in the SPARC ABI. This is the default.</source>
          <target state="translated">生成包含四字(长双)浮点指令的库调用的输出。调用的函数是SPARC ABI中指定的函数。这是默认的。</target>
        </trans-unit>
        <trans-unit id="e778386ad4f7c29303d76d557065f8b2cddd1a1e" translate="yes" xml:space="preserve">
          <source>Generate output containing quad-word (long double) floating-point instructions.</source>
          <target state="translated">生成包含四字(长双)浮点指令的输出。</target>
        </trans-unit>
        <trans-unit id="72b8d6815f1c63fef196e30ed85ba66e28021cd2" translate="yes" xml:space="preserve">
          <source>Generate output for a 5206e ColdFire CPU. The option is now deprecated in favor of the equivalent</source>
          <target state="translated">为5206e ColdFire CPU生成输出。该选项现在已被废止,改用了等效的</target>
        </trans-unit>
        <trans-unit id="64050f292f81abd70f3bb1391b078794170aa43c" translate="yes" xml:space="preserve">
          <source>Generate output for a 520X ColdFire CPU. This is the default when the compiler is configured for 520X-based systems. It is equivalent to</source>
          <target state="translated">为520X ColdFire CPU生成输出。当编译器被配置为基于520X的系统时,这是默认的。它相当于</target>
        </trans-unit>
        <trans-unit id="4e6125bf5e16c60081ffba73c18391756b953da9" translate="yes" xml:space="preserve">
          <source>Generate output for a 68000. This is the default when the compiler is configured for 68000-based systems. It is equivalent to</source>
          <target state="translated">为68000生成输出。当编译器被配置为基于68000的系统时,这是默认的。它相当于</target>
        </trans-unit>
        <trans-unit id="293fc36513894f8af34456d5d4568e3a8a660df3" translate="yes" xml:space="preserve">
          <source>Generate output for a 68010. This is the default when the compiler is configured for 68010-based systems. It is equivalent to</source>
          <target state="translated">为68010生成输出。当编译器被配置为基于68010的系统时,这是默认的。它相当于</target>
        </trans-unit>
        <trans-unit id="3de0124e7fb5a143b3bdb1e5bf42ea00b8dc1041" translate="yes" xml:space="preserve">
          <source>Generate output for a 68020. This is the default when the compiler is configured for 68020-based systems. It is equivalent to</source>
          <target state="translated">为68020生成输出。当编译器被配置为基于68020的系统时,这是默认的。它相当于</target>
        </trans-unit>
        <trans-unit id="a2125889bc447fbbe5141c63e65b9cc93af2774c" translate="yes" xml:space="preserve">
          <source>Generate output for a 68030. This is the default when the compiler is configured for 68030-based systems. It is equivalent to</source>
          <target state="translated">为68030生成输出。当编译器被配置为基于68030的系统时,这是默认的。它相当于</target>
        </trans-unit>
        <trans-unit id="dcd8a9aedf0282928a86db993cf8d4ff8070b038" translate="yes" xml:space="preserve">
          <source>Generate output for a 68040, without using any of the new instructions. This results in code that can run relatively efficiently on either a 68020/68881 or a 68030 or a 68040. The generated code does use the 68881 instructions that are emulated on the 68040.</source>
          <target state="translated">在不使用任何新指令的情况下,为68040生成输出。这样产生的代码可以比较有效地在68020/68881或68030或68040上运行。生成的代码确实使用了68040上模拟的68881指令。</target>
        </trans-unit>
        <trans-unit id="dd4119d908a2b18c651ef46f26b46cd2bc8b0de2" translate="yes" xml:space="preserve">
          <source>Generate output for a 68040. This is the default when the compiler is configured for 68040-based systems. It is equivalent to</source>
          <target state="translated">为68040生成输出。当编译器被配置为基于68040的系统时,这是默认的。它相当于</target>
        </trans-unit>
        <trans-unit id="c0e33f0f063c998bb9f2f1ad28f52830efcc367f" translate="yes" xml:space="preserve">
          <source>Generate output for a 68060, without using any of the new instructions. This results in code that can run relatively efficiently on either a 68020/68881 or a 68030 or a 68040. The generated code does use the 68881 instructions that are emulated on the 68060.</source>
          <target state="translated">在不使用任何新指令的情况下,为68060生成输出。这样产生的代码可以比较有效地在68020/68881或68030或68040上运行。生成的代码确实使用了68060上模拟的68881指令。</target>
        </trans-unit>
        <trans-unit id="4e0aa817ee3651021250220786d7a8ddadf8d908" translate="yes" xml:space="preserve">
          <source>Generate output for a 68060. This is the default when the compiler is configured for 68060-based systems. It is equivalent to</source>
          <target state="translated">为68060生成输出。当编译器被配置为基于68060的系统时,这是默认的。它相当于</target>
        </trans-unit>
        <trans-unit id="ea5be8485d83583c41e5d8584b5916331ad44880" translate="yes" xml:space="preserve">
          <source>Generate output for a CPU32. This is the default when the compiler is configured for CPU32-based systems. It is equivalent to</source>
          <target state="translated">为CPU32生成输出。当编译器被配置为基于CPU32的系统时,这是默认的。它相当于</target>
        </trans-unit>
        <trans-unit id="e1d15ac03ce80d2a7972245b867ea55ebdb92c9b" translate="yes" xml:space="preserve">
          <source>Generate output for a ColdFire 5307 CPU. The option is now deprecated in favor of the equivalent</source>
          <target state="translated">为ColdFire 5307 CPU生成输出。该选项现在已被废弃,改用等效的</target>
        </trans-unit>
        <trans-unit id="8e01c68482064d3161a9a189e69a1cae2c323dfb" translate="yes" xml:space="preserve">
          <source>Generate output for a ColdFire 5407 CPU. The option is now deprecated in favor of the equivalent</source>
          <target state="translated">为ColdFire 5407 CPU生成输出。这个选项现在已经被废止了,改用了等效的</target>
        </trans-unit>
        <trans-unit id="0aa9f4c3f64933730b3c4adacac26f4b2456673a" translate="yes" xml:space="preserve">
          <source>Generate output for a ColdFire V4e family CPU (e.g. 547x/548x). This includes use of hardware floating-point instructions. The option is equivalent to</source>
          <target state="translated">为ColdFire V4e系列CPU(如547x/548x)生成输出。这包括使用硬件浮点指令。该选项相当于</target>
        </trans-unit>
        <trans-unit id="e7347e49e1182821745b1b659d00df4d824a3e04" translate="yes" xml:space="preserve">
          <source>Generate output for a member of the ColdFire 528X family. The option is now deprecated in favor of the equivalent</source>
          <target state="translated">为 ColdFire 528X 系列的成员生成输出。该选项现在已被废止,改用等效的</target>
        </trans-unit>
        <trans-unit id="18dcb26797382565521c621a512430444b4e53d3" translate="yes" xml:space="preserve">
          <source>Generate performance extension 2 instructions.</source>
          <target state="translated">生成性能扩展2指令。</target>
        </trans-unit>
        <trans-unit id="bd6544f4b4eb02ec7c1103af517606738fd2ba09" translate="yes" xml:space="preserve">
          <source>Generate performance extension instructions.</source>
          <target state="translated">生成性能扩展指令。</target>
        </trans-unit>
        <trans-unit id="d399ee7f07dc0a2fb4ab33398b031c9b688f806f" translate="yes" xml:space="preserve">
          <source>Generate position-independent EABI code.</source>
          <target state="translated">生成与位置无关的EABI代码。</target>
        </trans-unit>
        <trans-unit id="1d1142004c8111e7c50b740035c14c26ae3a4d40" translate="yes" xml:space="preserve">
          <source>Generate position-independent code (PIC) suitable for use in a shared library, if supported for the target machine. Such code accesses all constant addresses through a global offset table (GOT). The dynamic loader resolves the GOT entries when the program starts (the dynamic loader is not part of GCC; it is part of the operating system). If the GOT size for the linked executable exceeds a machine-specific maximum size, you get an error message from the linker indicating that</source>
          <target state="translated">生成适合在共享库中使用的位置无关代码(PIC),如果目标机器支持的话。这种代码通过全局偏移表(GOT)访问所有常数地址。动态加载器在程序启动时解析GOT条目(动态加载器不是GCC的一部分,它是操作系统的一部分)。如果被链接的可执行文件的GOT大小超过了特定机器的最大大小,你会从链接器中得到一条错误信息,表明</target>
        </trans-unit>
        <trans-unit id="48b952028eaadcc5cf5b2652a4f09475aac1135d" translate="yes" xml:space="preserve">
          <source>Generate secure code as per the &quot;ARMv8-M Security Extensions: Requirements on Development Tools Engineering Specification&quot;, which can be found on &lt;a href=&quot;http://infocenter.arm.com/help/topic/com.arm.doc.ecm0359818/ECM0359818_armv8m_security_extensions_reqs_on_dev_tools_1_0.pdf&quot;&gt;http://infocenter.arm.com/help/topic/com.arm.doc.ecm0359818/ECM0359818_armv8m_security_extensions_reqs_on_dev_tools_1_0.pdf&lt;/a&gt;.</source>
          <target state="translated">根据&amp;ldquo; ARMv8-M安全扩展：开发工具工程规范的要求&amp;rdquo;生成安全代码，该代码可在&lt;a href=&quot;http://infocenter.arm.com/help/topic/com.arm.doc.ecm0359818/ECM0359818_armv8m_security_extensions_reqs_on_dev_tools_1_0.pdf&quot;&gt;http://infocenter.arm.com/help/topic/com.arm.doc.ecm0359818/ECM0359818_armv8m_security_extensions_reqs_on_dev_tools_1_0中&lt;/a&gt;找到。 PDF格式。</target>
        </trans-unit>
        <trans-unit id="61825c7f7fe0283dfaa12a0bf7f79986a97151b2" translate="yes" xml:space="preserve">
          <source>Generate single-precision FPX instructions, tuned for the compact implementation.</source>
          <target state="translated">生成单精度FPX指令,针对紧凑的实现进行调整。</target>
        </trans-unit>
        <trans-unit id="57fc66010a803fb795da295b4fbe9fac5a8dbfd1" translate="yes" xml:space="preserve">
          <source>Generate single-precision FPX instructions, tuned for the fast implementation.</source>
          <target state="translated">生成单精度FPX指令,调整为快速实现。</target>
        </trans-unit>
        <trans-unit id="03e730324ac713e9445bac5587ed90df17b4e2e3" translate="yes" xml:space="preserve">
          <source>Generate software atomic sequences that temporarily disable interrupts by setting &lt;code&gt;SR.IMASK = 1111&lt;/code&gt;. This model works only when the program runs in privileged mode and is only suitable for single-core systems. Additional support from the interrupt/exception handling code of the system is not required. This model is enabled by default when the target is &lt;code&gt;sh*-*-linux*&lt;/code&gt; and SH1* or SH2*.</source>
          <target state="translated">通过设置 &lt;code&gt;SR.IMASK = 1111&lt;/code&gt; 生成暂时禁用中断的软件原子序列。仅当程序在特权模式下运行时，此模型才有效，并且仅适用于单核系统。不需要系统的中断/异常处理代码的额外支持。当目标为 &lt;code&gt;sh*-*-linux*&lt;/code&gt; 和SH1 *或SH2 * 时，默认情况下启用此模型。</target>
        </trans-unit>
        <trans-unit id="adcbfbeac80cfe6a3e4b55a0bdfaf3f19f30fbea" translate="yes" xml:space="preserve">
          <source>Generate software atomic sequences that use a variable in the thread control block. This is a variation of the gUSA sequences which can also be used on SH1* and SH2* targets. The generated atomic sequences require additional support from the interrupt/exception handling code of the system and are only suitable for single-core systems. When using this model, the &amp;lsquo;</source>
          <target state="translated">生成使用原子控制块中的变量的软件原子序列。这是gUSA序列的变体，也可以用于SH1 *和SH2 *靶标。生成的原子序列需要系统中断/异常处理代码的额外支持，并且仅适用于单核系统。使用此模型时，</target>
        </trans-unit>
        <trans-unit id="7e273affad800c8c4cf1d009bbdccfc4d50d0a21" translate="yes" xml:space="preserve">
          <source>Generate stack protection code using canary at &lt;var&gt;guard&lt;/var&gt;. Supported locations are &amp;lsquo;</source>
          <target state="translated">使用canary at &lt;var&gt;guard&lt;/var&gt; 生成堆栈保护代码。支持的位置是&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="b8a639f56facade8c98595f71ed5d4db9ac64830" translate="yes" xml:space="preserve">
          <source>Generate string extension instructions.</source>
          <target state="translated">生成字符串扩展指令。</target>
        </trans-unit>
        <trans-unit id="8a1f94259681f1ae170bbb57344c845c25fbbd90" translate="yes" xml:space="preserve">
          <source>Generate the &lt;code&gt;tas.b&lt;/code&gt; opcode for &lt;code&gt;__atomic_test_and_set&lt;/code&gt;. Notice that depending on the particular hardware and software configuration this can degrade overall performance due to the operand cache line flushes that are implied by the &lt;code&gt;tas.b&lt;/code&gt; instruction. On multi-core SH4A processors the &lt;code&gt;tas.b&lt;/code&gt; instruction must be used with caution since it can result in data corruption for certain cache configurations.</source>
          <target state="translated">为 &lt;code&gt;__atomic_test_and_set&lt;/code&gt; 生成 &lt;code&gt;tas.b&lt;/code&gt; 操作码。注意，由于特定的硬件和软件配置，这可能会降低整体性能，因为 &lt;code&gt;tas.b&lt;/code&gt; 指令隐含了操作数缓存行刷新。在多核SH4A处理器上，必须谨慎使用 &lt;code&gt;tas.b&lt;/code&gt; 指令，因为它可能导致某些高速缓存配置的数据损坏。</target>
        </trans-unit>
        <trans-unit id="33b6af1538444b86d0ad7d0fedaceadc538e6781" translate="yes" xml:space="preserve">
          <source>Generate the predefine, &lt;code&gt;_SIO&lt;/code&gt;, for server IO. The default is</source>
          <target state="translated">为服务器IO 生成预定义 &lt;code&gt;_SIO&lt;/code&gt; 。默认是</target>
        </trans-unit>
        <trans-unit id="556e10b173cc8258302ad6ae7353988cc9258bb9" translate="yes" xml:space="preserve">
          <source>Generate unwind table in DWARF format, if supported by target machine. The table is exact at each instruction boundary, so it can be used for stack unwinding from asynchronous events (such as debugger or garbage collector).</source>
          <target state="translated">如果目标机器支持,生成DWARF格式的解卷表。该表在每个指令边界处都是精确的,所以它可以用于异步事件(如调试器或垃圾收集器)的堆栈解卷。</target>
        </trans-unit>
        <trans-unit id="57527d83fd3616a340b11bb579911dbfd64f477e" translate="yes" xml:space="preserve">
          <source>Generate v3 push25/pop25 instructions.</source>
          <target state="translated">生成v3 push25/pop25指令。</target>
        </trans-unit>
        <trans-unit id="fb9942d737ee06d15159ff521f994cc01ae69210" translate="yes" xml:space="preserve">
          <source>Generated code is not compatible with hardware interrupts. Code size is smaller.</source>
          <target state="translated">生成的代码与硬件中断不兼容。代码大小较小。</target>
        </trans-unit>
        <trans-unit id="95fc43dc3dce502b8d3a439f3daa647aaa660090" translate="yes" xml:space="preserve">
          <source>Generates</source>
          <target state="translated">Generates</target>
        </trans-unit>
        <trans-unit id="847361d2a7401aea217f81327402896d9c474e00" translate="yes" xml:space="preserve">
          <source>Generates &lt;code&gt;sbit&lt;/code&gt;/&lt;code&gt;cbit&lt;/code&gt; instructions for bit manipulations.</source>
          <target state="translated">生成用于位操作的 &lt;code&gt;sbit&lt;/code&gt; / &lt;code&gt;cbit&lt;/code&gt; 指令。</target>
        </trans-unit>
        <trans-unit id="8c23e71aebd89fa525027dc7a4570046a7a64ce0" translate="yes" xml:space="preserve">
          <source>Generates an error message. This pragma &lt;em&gt;is&lt;/em&gt; considered to indicate an error in the compilation, and it will be treated as such.</source>
          <target state="translated">生成错误消息。该编译指示&lt;em&gt;被&lt;/em&gt;认为指示编译&lt;em&gt;中&lt;/em&gt;的错误，将被视为错误。</target>
        </trans-unit>
        <trans-unit id="b4a08a286760cba742dec264941903cd2180c988" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;brk&lt;/code&gt; machine instruction.</source>
          <target state="translated">生成 &lt;code&gt;brk&lt;/code&gt; 机器指令。</target>
        </trans-unit>
        <trans-unit id="de0ffdd1afe0ff10e18f301f3481e988ec1af918" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;clrpsw&lt;/code&gt; machine instruction to clear the specified bit in the processor status word.</source>
          <target state="translated">生成 &lt;code&gt;clrpsw&lt;/code&gt; 机器指令以清除处理器状态字中的指定位。</target>
        </trans-unit>
        <trans-unit id="e384966166fe10a7e3cda9622b8d991e42dbafb8" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;crc32b&lt;/code&gt; machine instruction.</source>
          <target state="translated">生成 &lt;code&gt;crc32b&lt;/code&gt; 机器指令。</target>
        </trans-unit>
        <trans-unit id="097e8495f2e00512011587a86cec2af02faf3293" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;crc32l&lt;/code&gt; machine instruction.</source>
          <target state="translated">生成 &lt;code&gt;crc32l&lt;/code&gt; 机器指令。</target>
        </trans-unit>
        <trans-unit id="257268a989f9b93ff19c2d7c87cb2336d607cc4f" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;crc32q&lt;/code&gt; machine instruction.</source>
          <target state="translated">生成 &lt;code&gt;crc32q&lt;/code&gt; 机器指令。</target>
        </trans-unit>
        <trans-unit id="b6ee9ffc23cac162df8a9b520916fe8eb4063947" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;crc32w&lt;/code&gt; machine instruction.</source>
          <target state="translated">生成 &lt;code&gt;crc32w&lt;/code&gt; 机器指令。</target>
        </trans-unit>
        <trans-unit id="9c0298bd9ac40c51cad36ed168d5ebaa6178f1de" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;etnd&lt;/code&gt; machine instruction. The current nesting depth is returned as integer value. For a nesting depth of 0 the code is not executed as part of an transaction.</source>
          <target state="translated">生成 &lt;code&gt;etnd&lt;/code&gt; 机器指令。当前嵌套深度以整数值形式返回。如果嵌套深度为0，则代码不会作为事务的一部分执行。</target>
        </trans-unit>
        <trans-unit id="ba9daaa604a3528f1838ae3869b5e548870970eb" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;extractps&lt;/code&gt; machine instruction.</source>
          <target state="translated">生成 &lt;code&gt;extractps&lt;/code&gt; 机器指令。</target>
        </trans-unit>
        <trans-unit id="89f2857c101ed877edbedb096cf0c5b70642f1a6" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;insertps&lt;/code&gt; machine instruction.</source>
          <target state="translated">生成 &lt;code&gt;insertps&lt;/code&gt; 机器指令。</target>
        </trans-unit>
        <trans-unit id="bddf0335c49f41b446b0994e140cc0b296730b66" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;int&lt;/code&gt; machine instruction to generate an interrupt with the specified value.</source>
          <target state="translated">生成 &lt;code&gt;int&lt;/code&gt; 机器指令以生成具有指定值的中断。</target>
        </trans-unit>
        <trans-unit id="cc578c8838d75de69df84505da3623cd37d917cc" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;machi&lt;/code&gt; machine instruction to add the result of multiplying the top 16 bits of the two arguments into the accumulator.</source>
          <target state="translated">生成 &lt;code&gt;machi&lt;/code&gt; 机器指令，以将两个自变量的高16位相乘的结果相加到累加器中。</target>
        </trans-unit>
        <trans-unit id="99eacdb7a1185745b3f8d3546aa5c195c4ffc120" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;maclo&lt;/code&gt; machine instruction to add the result of multiplying the bottom 16 bits of the two arguments into the accumulator.</source>
          <target state="translated">生成 &lt;code&gt;maclo&lt;/code&gt; 机器指令，以将两个参数的低16位相乘的结果相加到累加器中。</target>
        </trans-unit>
        <trans-unit id="7a0ca51423d0e24c5de865392e13bff92dec8a47" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;movhps&lt;/code&gt; machine instruction as a load from memory.</source>
          <target state="translated">从内存生成 &lt;code&gt;movhps&lt;/code&gt; 机器指令作为负载。</target>
        </trans-unit>
        <trans-unit id="a6336fc5b41c1f5923ae66b48c6856394b9f7d5d" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;movhps&lt;/code&gt; machine instruction as a store to memory.</source>
          <target state="translated">生成 &lt;code&gt;movhps&lt;/code&gt; 机器指令作为存储器存储。</target>
        </trans-unit>
        <trans-unit id="81a1c47a7ece45e98596dc9420085617e89d6661" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;movlps&lt;/code&gt; machine instruction as a load from memory</source>
          <target state="translated">从内存生成 &lt;code&gt;movlps&lt;/code&gt; 机器指令作为负载</target>
        </trans-unit>
        <trans-unit id="1e491626b2ecf306727f7b2f326dde340a6befb6" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;movlps&lt;/code&gt; machine instruction as a store to memory.</source>
          <target state="translated">生成 &lt;code&gt;movlps&lt;/code&gt; 机器指令作为存储器存储。</target>
        </trans-unit>
        <trans-unit id="ac79e7ffaaf077d95a6d1ffa3d8fb253edbeb451" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;movss&lt;/code&gt; machine instruction as a load from memory.</source>
          <target state="translated">从内存生成 &lt;code&gt;movss&lt;/code&gt; 机器指令作为负载。</target>
        </trans-unit>
        <trans-unit id="2dc4d75da1c01f01ac98af15d63b74a7af18475d" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;movups&lt;/code&gt; machine instruction as a load from memory.</source>
          <target state="translated">从内存生成 &lt;code&gt;movups&lt;/code&gt; 机器指令作为负载。</target>
        </trans-unit>
        <trans-unit id="363646d48f8bc2356c5c4e7f637ebc00c96d25d3" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;movups&lt;/code&gt; machine instruction as a store to memory.</source>
          <target state="translated">生成 &lt;code&gt;movups&lt;/code&gt; 机器指令作为存储器存储。</target>
        </trans-unit>
        <trans-unit id="bc35453eece3fefcd1bc15a0d478b36419def393" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;mulhi&lt;/code&gt; machine instruction to place the result of multiplying the top 16 bits of the two arguments into the accumulator.</source>
          <target state="translated">生成 &lt;code&gt;mulhi&lt;/code&gt; 机器指令，以将两个自变量的高16位相乘的结果放入累加器。</target>
        </trans-unit>
        <trans-unit id="52d614340e6bcb9b13e27d9daf3f3ec4c3e7003e" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;mullo&lt;/code&gt; machine instruction to place the result of multiplying the bottom 16 bits of the two arguments into the accumulator.</source>
          <target state="translated">生成 &lt;code&gt;mullo&lt;/code&gt; 机器指令，以将两个自变量的低16位相乘的结果放入累加器。</target>
        </trans-unit>
        <trans-unit id="37702a0f744e0973c9767b2a0ae0b071d0ab6011" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;mvfachi&lt;/code&gt; machine instruction to read the top 32 bits of the accumulator.</source>
          <target state="translated">生成 &lt;code&gt;mvfachi&lt;/code&gt; 机器指令以读取累加器的高32位。</target>
        </trans-unit>
        <trans-unit id="e5e940957ba8e9f4e4a5a9b38f5ec9bacccdcd1d" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;mvfacmi&lt;/code&gt; machine instruction to read the middle 32 bits of the accumulator.</source>
          <target state="translated">生成 &lt;code&gt;mvfacmi&lt;/code&gt; 机器指令以读取累加器的中间32位。</target>
        </trans-unit>
        <trans-unit id="84ea7bb4390bbd29b42442b2c0df648769428770" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;mvfc&lt;/code&gt; machine instruction which reads the control register specified in its argument and returns its value.</source>
          <target state="translated">生成 &lt;code&gt;mvfc&lt;/code&gt; 机器指令，该指令读取其参数中指定的控制寄存器并返回其值。</target>
        </trans-unit>
        <trans-unit id="9a7f85fadc166c23e3a73720a98d17ae8d98c867" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;mvtachi&lt;/code&gt; machine instruction to set the top 32 bits of the accumulator.</source>
          <target state="translated">生成 &lt;code&gt;mvtachi&lt;/code&gt; 机器指令以设置累加器的高32位。</target>
        </trans-unit>
        <trans-unit id="c2fa5a8c449853ed0e286fabb00686c6c4684432" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;mvtaclo&lt;/code&gt; machine instruction to set the bottom 32 bits of the accumulator.</source>
          <target state="translated">生成 &lt;code&gt;mvtaclo&lt;/code&gt; 机器指令以设置累加器的低32位。</target>
        </trans-unit>
        <trans-unit id="0c726977269ab1aef450eb4579a182f674e2891b" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;mvtc&lt;/code&gt; machine instruction which sets control register number &lt;code&gt;reg&lt;/code&gt; to &lt;code&gt;val&lt;/code&gt;.</source>
          <target state="translated">生成将控制寄存器号 &lt;code&gt;reg&lt;/code&gt; 设置为 &lt;code&gt;val&lt;/code&gt; 的 &lt;code&gt;mvtc&lt;/code&gt; 机器指令。</target>
        </trans-unit>
        <trans-unit id="e73288099a5726fcb09aeebaa5734e10714eb5f2" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;mvtipl&lt;/code&gt; machine instruction set the interrupt priority level.</source>
          <target state="translated">生成 &lt;code&gt;mvtipl&lt;/code&gt; 机器指令集的中断优先级。</target>
        </trans-unit>
        <trans-unit id="c95405f984d5d6abab06b81618d6b2d88c6bce16" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;ntstg&lt;/code&gt; machine instruction. The second argument is written to the first arguments location. The store operation will not be rolled-back in case of an transaction abort.</source>
          <target state="translated">生成 &lt;code&gt;ntstg&lt;/code&gt; 机器指令。第二个参数写入第一个参数位置。如果事务中止，则不会回滚存储操作。</target>
        </trans-unit>
        <trans-unit id="221810e17f3f5b7b6eee2c597dcc35e9560d5c1a" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;pause&lt;/code&gt; machine instruction with a compiler memory barrier.</source>
          <target state="translated">生成带有编译器内存屏障的 &lt;code&gt;pause&lt;/code&gt; 机器指令。</target>
        </trans-unit>
        <trans-unit id="fabcc577b37bbc75f15d4acfc478723f40e312bf" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;pclmulqdq&lt;/code&gt; machine instruction.</source>
          <target state="translated">生成 &lt;code&gt;pclmulqdq&lt;/code&gt; 机器指令。</target>
        </trans-unit>
        <trans-unit id="138581c28238370fdca095f892b8bcc2f037ebde" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;pextrb&lt;/code&gt; machine instruction.</source>
          <target state="translated">生成 &lt;code&gt;pextrb&lt;/code&gt; 机器指令。</target>
        </trans-unit>
        <trans-unit id="cc89464fd0e0ffc62121a43ea4c78a22a765f79b" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;pextrd&lt;/code&gt; machine instruction.</source>
          <target state="translated">生成 &lt;code&gt;pextrd&lt;/code&gt; 机器指令。</target>
        </trans-unit>
        <trans-unit id="6995305b1713c32c1cb9c1c29aa123fa501311ad" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;pextrq&lt;/code&gt; machine instruction in 64bit mode.</source>
          <target state="translated">在64位模式下生成 &lt;code&gt;pextrq&lt;/code&gt; 机器指令。</target>
        </trans-unit>
        <trans-unit id="7afd0d12563bc8ecde0ac65ab4ecf09a6388cc0c" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;pinsrb&lt;/code&gt; machine instruction.</source>
          <target state="translated">生成 &lt;code&gt;pinsrb&lt;/code&gt; 机器指令。</target>
        </trans-unit>
        <trans-unit id="587eac9a0053b04618284992d46512728f7465b0" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;pinsrd&lt;/code&gt; machine instruction.</source>
          <target state="translated">生成 &lt;code&gt;pinsrd&lt;/code&gt; 机器指令。</target>
        </trans-unit>
        <trans-unit id="e89f9467a7fdb5f2511c4d93da028b6494b1db2e" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;pinsrq&lt;/code&gt; machine instruction in 64bit mode.</source>
          <target state="translated">在64位模式下生成 &lt;code&gt;pinsrq&lt;/code&gt; 机器指令。</target>
        </trans-unit>
        <trans-unit id="167d17fe5058f3ef0cb33d59903eebaaf6162e68" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;popcntl&lt;/code&gt; machine instruction.</source>
          <target state="translated">生成 &lt;code&gt;popcntl&lt;/code&gt; 机器指令。</target>
        </trans-unit>
        <trans-unit id="6cb126029514e2d5bfcb6bca148eb150b8aba8a4" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;popcntl&lt;/code&gt; or &lt;code&gt;popcntq&lt;/code&gt; machine instruction, depending on the size of &lt;code&gt;unsigned long&lt;/code&gt;.</source>
          <target state="translated">根据 &lt;code&gt;unsigned long&lt;/code&gt; 的大小，生成 &lt;code&gt;popcntl&lt;/code&gt; 或 &lt;code&gt;popcntq&lt;/code&gt; 机器指令。</target>
        </trans-unit>
        <trans-unit id="c32c9ad948f2048e1fcb6de749499d83eb38bfdd" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;popcntq&lt;/code&gt; machine instruction.</source>
          <target state="translated">生成 &lt;code&gt;popcntq&lt;/code&gt; 机器指令。</target>
        </trans-unit>
        <trans-unit id="c6a384a17f6c55681ebb99e208e7e76367ba0a5f" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;ppa rX,rY,1&lt;/code&gt; machine instruction. Where the integer parameter is loaded into rX and a value of zero is loaded into rY. The integer parameter specifies the number of times the transaction repeatedly aborted.</source>
          <target state="translated">生成 &lt;code&gt;ppa rX,rY,1&lt;/code&gt; 机器指令。其中将整数参数加载到rX中，将零值加载到rY中。整数参数指定事务重复中止的次数。</target>
        </trans-unit>
        <trans-unit id="2ad4e7198804a310937a6c8bd6ea66807f131d33" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;racw&lt;/code&gt; machine instruction to round the accumulator according to the specified mode.</source>
          <target state="translated">生成 &lt;code&gt;racw&lt;/code&gt; 机器指令以根据指定模式对累加器进行取整。</target>
        </trans-unit>
        <trans-unit id="94afa89c73a482e7f60ea3534ec6652b684e5611" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;revw&lt;/code&gt; machine instruction which swaps the bytes in the argument so that bits 0&amp;ndash;7 now occupy bits 8&amp;ndash;15 and vice versa, and also bits 16&amp;ndash;23 occupy bits 24&amp;ndash;31 and vice versa.</source>
          <target state="translated">生成 &lt;code&gt;revw&lt;/code&gt; machine指令，该指令交换参数中的字节，以使位0-7现在占据位8-15，反之亦然，位16-23也占据位24-31，反之亦然。</target>
        </trans-unit>
        <trans-unit id="6d19e7f0e193910eff939ea1df5fd508cf81e1dd" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;rmpa&lt;/code&gt; machine instruction which initiates a repeated multiply and accumulate sequence.</source>
          <target state="translated">生成 &lt;code&gt;rmpa&lt;/code&gt; 机器指令，该指令启动重复的乘法和累加序列。</target>
        </trans-unit>
        <trans-unit id="3a3c845817720a1abf8f57c24608a050c45caf15" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;round&lt;/code&gt; machine instruction which returns the floating-point argument rounded according to the current rounding mode set in the floating-point status word register.</source>
          <target state="translated">生成 &lt;code&gt;round&lt;/code&gt; 机器指令，该指令返回根据在浮点状态字寄存器中设置的当前舍入模式舍入的浮点参数。</target>
        </trans-unit>
        <trans-unit id="693bacff2407833725bfd8a8b85cfbf1bb7e034c" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;sat&lt;/code&gt; machine instruction which returns the saturated value of the argument.</source>
          <target state="translated">生成 &lt;code&gt;sat&lt;/code&gt; 机器指令，该指令返回参数的饱和值。</target>
        </trans-unit>
        <trans-unit id="0bd4f2535ab0460fd7e26bbf4e95465d1caef5d0" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;setpsw&lt;/code&gt; machine instruction to set the specified bit in the processor status word.</source>
          <target state="translated">生成 &lt;code&gt;setpsw&lt;/code&gt; 机器指令以设置处理器状态字中的指定位。</target>
        </trans-unit>
        <trans-unit id="86af23191f84ff6e1646de29e1379a9fa322b441" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;tabort&lt;/code&gt; machine instruction with the specified abort code. Abort codes from 0 through 255 are reserved and will result in an error message.</source>
          <target state="translated">使用指定的中止代码生成 &lt;code&gt;tabort&lt;/code&gt; 机器指令。保留从0到255的中止代码，这将导致错误消息。</target>
        </trans-unit>
        <trans-unit id="41fafa8bbaf148ec213bd90ff158b6b99b4cd68d" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;tbegin&lt;/code&gt; machine instruction starting a non-constrained hardware transaction. If the parameter is non-NULL the memory area is used to store the transaction diagnostic buffer and will be passed as first operand to &lt;code&gt;tbegin&lt;/code&gt;. This buffer can be defined using the &lt;code&gt;struct __htm_tdb&lt;/code&gt; C struct defined in &lt;code&gt;htmintrin.h&lt;/code&gt; and must reside on a double-word boundary. The second tbegin operand is set to &lt;code&gt;0xff0c&lt;/code&gt;. This enables save/restore of all GPRs and disables aborts for FPR and AR manipulations inside the transaction body. The condition code set by the tbegin instruction is returned as integer value. The tbegin instruction by definition overwrites the content of all FPRs. The compiler will generate code which saves and restores the FPRs. For soft-float code it is recommended to used the &lt;code&gt;*_nofloat&lt;/code&gt; variant. In order to prevent a TDB from being written it is required to pass a constant zero value as parameter. Passing a zero value through a variable is not sufficient. Although modifications of access registers inside the transaction will not trigger an transaction abort it is not supported to actually modify them. Access registers do not get saved when entering a transaction. They will have undefined state when reaching the abort code.</source>
          <target state="translated">生成 &lt;code&gt;tbegin&lt;/code&gt; 机器指令，开始无约束的硬件事务。如果参数为非NULL，则将使用内存区域存储事务诊断缓冲区，并将其作为第一个操作数传递给 &lt;code&gt;tbegin&lt;/code&gt; 。该缓冲器可以使用被限定 &lt;code&gt;struct __htm_tdb&lt;/code&gt; 中所定义的C结构 &lt;code&gt;htmintrin.h&lt;/code&gt; 和必须驻留在双字边界上。第二个tbegin操作数设置为 &lt;code&gt;0xff0c&lt;/code&gt; 。这将启用所有GPR的保存/恢复，并禁用事务主体内FPR和AR操作的中止。由tbegin指令设置的条件代码以整数值形式返回。根据定义，tbegin指令将覆盖所有FPR的内容。编译器将生成保存和还原FPR的代码。对于软浮点代码，建议使用 &lt;code&gt;*_nofloat&lt;/code&gt; 变体。为了防止写入TDB，需要传递一个恒定的零值作为参数。通过变量传递零值是不够的。尽管修改事务内部的访问寄存器不会触发事务中止，但实际上不支持对其进行修改。进入交易时不会保存访问寄存器。到达中止代码时，它们将具有未定义的状态。</target>
        </trans-unit>
        <trans-unit id="e6827eb1aea4f7107218c612803fe4d6ada64dff" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;tbeginc&lt;/code&gt; machine instruction starting a constrained hardware transaction. The second operand is set to &lt;code&gt;0xff08&lt;/code&gt;.</source>
          <target state="translated">生成启动受限硬件事务的 &lt;code&gt;tbeginc&lt;/code&gt; 机器指令。第二个操作数设置为 &lt;code&gt;0xff08&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1623696be46dd23fac7b3be91a9dabc88baaf7ab" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;tend&lt;/code&gt; machine instruction finishing a transaction and making the changes visible to other threads. The condition code generated by tend is returned as integer value.</source>
          <target state="translated">生成 &lt;code&gt;tend&lt;/code&gt; 机器指令，以完成事务并使更改对其他线程可见。由tend生成的条件代码将作为整数值返回。</target>
        </trans-unit>
        <trans-unit id="98be0f38fb4c5ac278186b26e4d1c15696ff51bf" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;wait&lt;/code&gt; machine instruction.</source>
          <target state="translated">生成 &lt;code&gt;wait&lt;/code&gt; 机器指令。</target>
        </trans-unit>
        <trans-unit id="0edb628a9542a14f813bd7de9f8386b56c8a58b5" translate="yes" xml:space="preserve">
          <source>Generates:</source>
          <target state="translated">Generates:</target>
        </trans-unit>
        <trans-unit id="ea3f79632679059de141d66e9dca3bc06851d467" translate="yes" xml:space="preserve">
          <source>Generic VIA Nano CPU with x86-64, MMX, SSE, SSE2, SSE3 and SSSE3 instruction set support. (No scheduling is implemented for this chip.)</source>
          <target state="translated">通用的威盛Nano CPU,支持x86-64、MMX、SSE、SSE2、SSE3和SSSE3指令集。(该芯片没有实现调度。)</target>
        </trans-unit>
        <trans-unit id="9aea01d94f58ef40baf7a92523ddcc334efa83d3" translate="yes" xml:space="preserve">
          <source>Get and set the contents of the floating-point control and status register (FPU control register 31). These functions are only available in hard-float code but can be called in both MIPS16 and non-MIPS16 contexts.</source>
          <target state="translated">获取和设置浮点控制和状态寄存器(FPU控制寄存器31)的内容。这些函数只在硬浮点代码中可用,但在MIPS16和非MIPS16的情况下都可以调用。</target>
        </trans-unit>
        <trans-unit id="93019384bd85aa8984f35ea4b05d12346052144c" translate="yes" xml:space="preserve">
          <source>Get the current value of shadow stack pointer if shadow stack support from Intel CET is enabled in the hardware or &lt;code&gt;0&lt;/code&gt; otherwise. The &lt;code&gt;ret_type&lt;/code&gt; is &lt;code&gt;unsigned long long&lt;/code&gt; for 64-bit targets and &lt;code&gt;unsigned int&lt;/code&gt; for 32-bit targets.</source>
          <target state="translated">如果硬件中启用了Intel CET的影子堆栈支持，则获取影子堆栈指针的当前值；否则，获取 &lt;code&gt;0&lt;/code&gt; 。所述 &lt;code&gt;ret_type&lt;/code&gt; 是 &lt;code&gt;unsigned long long&lt;/code&gt; 64位的目标和 &lt;code&gt;unsigned int&lt;/code&gt; 32位的目标。</target>
        </trans-unit>
        <trans-unit id="242390092876b4a7227130b506459512d744c5bd" translate="yes" xml:space="preserve">
          <source>Getting pointers to labels, and computed gotos.</source>
          <target state="translated">获取指向标签的指针,并计算出gotos。</target>
        </trans-unit>
        <trans-unit id="fbec048bbd1449a0bc11388da4d5291473184989" translate="yes" xml:space="preserve">
          <source>Getting the return or frame address of a function.</source>
          <target state="translated">获取函数的返回或帧地址。</target>
        </trans-unit>
        <trans-unit id="5bde8fdcb7065ba19c1a32d2b6a67073b7fb1601" translate="yes" xml:space="preserve">
          <source>Give a warning when a value of type &lt;code&gt;float&lt;/code&gt; is implicitly promoted to &lt;code&gt;double&lt;/code&gt;. CPUs with a 32-bit &amp;ldquo;single-precision&amp;rdquo; floating-point unit implement &lt;code&gt;float&lt;/code&gt; in hardware, but emulate &lt;code&gt;double&lt;/code&gt; in software. On such a machine, doing computations using &lt;code&gt;double&lt;/code&gt; values is much more expensive because of the overhead required for software emulation.</source>
          <target state="translated">当 &lt;code&gt;float&lt;/code&gt; 类型的值隐式提升为 &lt;code&gt;double&lt;/code&gt; 时发出警告。具有32位&amp;ldquo;单精度&amp;rdquo;浮点单元的CPU 在硬件中实现 &lt;code&gt;float&lt;/code&gt; ，但在软件中实现 &lt;code&gt;double&lt;/code&gt; 仿真。在这样的机器上，由于软件仿真所需的开销，使用 &lt;code&gt;double&lt;/code&gt; 值进行计算要昂贵得多。</target>
        </trans-unit>
        <trans-unit id="133654b9660498348bca9e7a9d9666b1d3206bc1" translate="yes" xml:space="preserve">
          <source>Give a warning whenever a function is used before being declared. In C99 mode (</source>
          <target state="translated">每当在声明之前使用一个函数时,都会给出一个警告。在C99模式下(</target>
        </trans-unit>
        <trans-unit id="ce9ec4f1d36927037e489058adc0d7c699b3e5d0" translate="yes" xml:space="preserve">
          <source>Give an error whenever the &lt;em&gt;base standard&lt;/em&gt; (see</source>
          <target state="translated">只要&lt;em&gt;基本标准&lt;/em&gt;（请参阅</target>
        </trans-unit>
        <trans-unit id="10288103238e1aab071f91b995853a568ee8af72" translate="yes" xml:space="preserve">
          <source>Given a set of input registers that die in an &lt;code&gt;asm&lt;/code&gt;, it is necessary to know which are implicitly popped by the &lt;code&gt;asm&lt;/code&gt;, and which must be explicitly popped by GCC.</source>
          <target state="translated">给定一组在 &lt;code&gt;asm&lt;/code&gt; 中死亡的输入寄存器，有必要知道哪些由 &lt;code&gt;asm&lt;/code&gt; 隐式弹出，哪些必须由GCC显式弹出。</target>
        </trans-unit>
        <trans-unit id="d87967442824754978f26c181e17cc9e46db44dd" translate="yes" xml:space="preserve">
          <source>Gives all externally visible functions in the file being compiled an ARM instruction set header which switches to Thumb mode before executing the rest of the function. This allows these functions to be called from non-interworking code. This option is not valid in AAPCS configurations because interworking is enabled by default.</source>
          <target state="translated">给正在编译的文件中的所有外部可见的函数一个ARM指令集头,该指令集头在执行函数的其余部分之前切换到Thumb模式。这允许从非互操作代码中调用这些函数。此选项在 AAPCS 配置中无效,因为默认情况下已启用了互操作。</target>
        </trans-unit>
        <trans-unit id="28fd2d80d56f82ae132cdb0c4269c770aa941c82" translate="yes" xml:space="preserve">
          <source>Global register variables cannot have initial values, because an executable file has no means to supply initial contents for a register.</source>
          <target state="translated">全局寄存器变量不能有初始值,因为可执行文件没有办法为寄存器提供初始内容。</target>
        </trans-unit>
        <trans-unit id="e1edbfbe92e2bd9d3f1182eb37f4bcfb20acdde5" translate="yes" xml:space="preserve">
          <source>Go source code.</source>
          <target state="translated">去源码。</target>
        </trans-unit>
        <trans-unit id="0104e918e01eb5413cf5e7e2b781b5b40dca1b8d" translate="yes" xml:space="preserve">
          <source>Guide linker to relax instructions.</source>
          <target state="translated">引导联结者放松指示。</target>
        </trans-unit>
        <trans-unit id="7cf184f4c67ad58283ecb19349720b0cae756829" translate="yes" xml:space="preserve">
          <source>H</source>
          <target state="translated">H</target>
        </trans-unit>
        <trans-unit id="c2d31434fb0f344cb4feeec0b0e57232ab31c7ad" translate="yes" xml:space="preserve">
          <source>HI and LO registers.</source>
          <target state="translated">HI和LO寄存器。</target>
        </trans-unit>
        <trans-unit id="ae1313e0d197443a538cfdaa0498460e61bc9b40" translate="yes" xml:space="preserve">
          <source>HI register.</source>
          <target state="translated">HI注册。</target>
        </trans-unit>
        <trans-unit id="9ffcbdd38d89bcb3eaa62489fe7281d06ece8295" translate="yes" xml:space="preserve">
          <source>HIGH register class $r12 to $r14, $r20 to $r31.</source>
          <target state="translated">高注册班12元至14元,20元至31元。</target>
        </trans-unit>
        <trans-unit id="3cb15a163b8ebe83004d3a7496bed1214d5c34ea" translate="yes" xml:space="preserve">
          <source>HK</source>
          <target state="translated">HK</target>
        </trans-unit>
        <trans-unit id="f187928fdb223e7f3b7b0396e72e2d59a5f12b29" translate="yes" xml:space="preserve">
          <source>HR</source>
          <target state="translated">HR</target>
        </trans-unit>
        <trans-unit id="85df07a121977d0d0044781e9eeed44012e5da35" translate="yes" xml:space="preserve">
          <source>Half-Precision Floating Point.</source>
          <target state="translated">半精度浮点运算。</target>
        </trans-unit>
        <trans-unit id="98b9b2da1252ae05155633eda47b6a7d5cf72927" translate="yes" xml:space="preserve">
          <source>Halt. The processor stops execution. This built-in is useful for implementing assertions.</source>
          <target state="translated">Halt.处理器停止执行。这个内置对于实现断言很有用。</target>
        </trans-unit>
        <trans-unit id="04a52ed9fb0a2eefbc17a28c7b4e166c12cd47d4" translate="yes" xml:space="preserve">
          <source>Hardware autoprefetcher scheduler model control flag. Number of lookahead cycles the model looks into; at &amp;rsquo; &amp;rsquo; only enable instruction sorting heuristic.</source>
          <target state="translated">硬件自动预取程序调度程序模型控制标志。模型研究的超前循环次数；在&amp;ldquo;&amp;rdquo;仅启用指令排序启发式。</target>
        </trans-unit>
        <trans-unit id="073339b2e7c4ff717e46d7be967106262132c9d4" translate="yes" xml:space="preserve">
          <source>Hardware multiplies are normally performed by calling a library routine. This saves space in the generated code. When compiling at</source>
          <target state="translated">硬件乘法通常是通过调用一个库例程来执行的。这样可以节省生成代码的空间。当以</target>
        </trans-unit>
        <trans-unit id="f483db45c59b64e904de79b67a44935e8bf546fe" translate="yes" xml:space="preserve">
          <source>Have &lt;code&gt;operator=&lt;/code&gt; return a reference to &lt;code&gt;*this&lt;/code&gt;.</source>
          <target state="translated">让 &lt;code&gt;operator=&lt;/code&gt; 返回对 &lt;code&gt;*this&lt;/code&gt; 的引用。</target>
        </trans-unit>
        <trans-unit id="520de7443d00d6ff4dc3ababbbf6cfbe0b74f4ec" translate="yes" xml:space="preserve">
          <source>Headers</source>
          <target state="translated">Headers</target>
        </trans-unit>
        <trans-unit id="42b05fc1afa3da7a89484cda5a6cb36dbe6e8a78" translate="yes" xml:space="preserve">
          <source>Hence, it is assumed as a convention that &lt;code&gt;r*&lt;/code&gt; means &lt;code&gt;const
char *&lt;/code&gt; (since it is what is most often meant), and there is no way to encode &lt;code&gt;char *const&lt;/code&gt;. &lt;code&gt;char *const&lt;/code&gt; would simply be encoded as &lt;code&gt;*&lt;/code&gt;, and the &lt;code&gt;const&lt;/code&gt; is lost.</source>
          <target state="translated">因此，假设惯例是 &lt;code&gt;r*&lt;/code&gt; 表示 &lt;code&gt;const char *&lt;/code&gt; （因为这是最常用的意思），并且无法对 &lt;code&gt;char *const&lt;/code&gt; 进行编码。 &lt;code&gt;char *const&lt;/code&gt; 将被简单地编码为 &lt;code&gt;*&lt;/code&gt; ，而 &lt;code&gt;const&lt;/code&gt; 将丢失。</target>
        </trans-unit>
        <trans-unit id="c6ff03b9e0183ccfd153d29e4ebb71b3afc43687" translate="yes" xml:space="preserve">
          <source>Here &amp;lsquo;</source>
          <target state="translated">这里 '</target>
        </trans-unit>
        <trans-unit id="63fa474126b5fb0e84bc0e1276f71b4f5949c4a7" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;a&lt;/code&gt; may or may not be restored to its first value when the &lt;code&gt;longjmp&lt;/code&gt; occurs. If &lt;code&gt;a&lt;/code&gt; is allocated in a register, then its first value is restored; otherwise, it keeps the last value stored in it.</source>
          <target state="translated">当 &lt;code&gt;longjmp&lt;/code&gt; 发生时，此处 &lt;code&gt;a&lt;/code&gt; 可能会或可能不会恢复为其第一个值。如果将 &lt;code&gt;a&lt;/code&gt; 分配到寄存器中，则将恢复其第一个值；否则，它将最后一个值存储在其中。</target>
        </trans-unit>
        <trans-unit id="6c22abcd7bcbe4b705f9506a92dff2b4514bc0a5" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;r12&lt;/code&gt; is the name of the register that should be used. Note that this is the same syntax used for defining global register variables, but for a local variable the declaration appears within a function. The &lt;code&gt;register&lt;/code&gt; keyword is required, and cannot be combined with &lt;code&gt;static&lt;/code&gt;. The register name must be a valid register name for the target platform.</source>
          <target state="translated">这里 &lt;code&gt;r12&lt;/code&gt; 是要使用的寄存器名。请注意，这与用于定义全局寄存器变量的语法相同，但是对于局部变量，声明出现在函数内。该 &lt;code&gt;register&lt;/code&gt; 关键字是必需的，并且不能与结合 &lt;code&gt;static&lt;/code&gt; 。寄存器名称必须是目标平台的有效寄存器名称。</target>
        </trans-unit>
        <trans-unit id="e629674ac2ffa8c8e6f920770dda44cae02f866e" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;r12&lt;/code&gt; is the name of the register that should be used. Note that this is the same syntax used for defining local register variables, but for a global variable the declaration appears outside a function. The &lt;code&gt;register&lt;/code&gt; keyword is required, and cannot be combined with &lt;code&gt;static&lt;/code&gt;. The register name must be a valid register name for the target platform.</source>
          <target state="translated">这里 &lt;code&gt;r12&lt;/code&gt; 是要使用的寄存器名。请注意，这与用于定义本地寄存器变量的语法相同，但是对于全局变量，声明显示在函数外部。该 &lt;code&gt;register&lt;/code&gt; 关键字是必需的，并且不能与结合 &lt;code&gt;static&lt;/code&gt; 。寄存器名称必须是目标平台的有效寄存器名称。</target>
        </trans-unit>
        <trans-unit id="1bd41698f09a234c8d3f5259448a5e29c338b76f" translate="yes" xml:space="preserve">
          <source>Here are constraint modifier characters.</source>
          <target state="translated">这里是约束修饰符。</target>
        </trans-unit>
        <trans-unit id="13c7c696c96d9253d198dc3e9c528b8ff4863b3b" translate="yes" xml:space="preserve">
          <source>Here are some examples showing uses of these options.</source>
          <target state="translated">下面是一些使用这些选项的例子。</target>
        </trans-unit>
        <trans-unit id="a2f0dcf3cf944a4192020c4b10f40e42e5e117ae" translate="yes" xml:space="preserve">
          <source>Here are some more examples of output operands.</source>
          <target state="translated">这里还有一些输出操作数的例子。</target>
        </trans-unit>
        <trans-unit id="25efdeb982b817cc2032012465d473ceaf58d073" translate="yes" xml:space="preserve">
          <source>Here are some types and their encodings, as they are generated by the compiler on an i386 machine:</source>
          <target state="translated">下面是一些类型和它们的编码,因为它们是由i386机器上的编译器生成的。</target>
        </trans-unit>
        <trans-unit id="807544d18135eba132f45e4832519a518a98b736" translate="yes" xml:space="preserve">
          <source>Here are specific details on what constraint letters you can use with &lt;code&gt;asm&lt;/code&gt; operands. Constraints can say whether an operand may be in a register, and which kinds of register; whether the operand can be a memory reference, and which kinds of address; whether the operand may be an immediate constant, and which possible values it may have. Constraints can also require two operands to match. Side-effects aren&amp;rsquo;t allowed in operands of inline &lt;code&gt;asm&lt;/code&gt;, unless &amp;lsquo;</source>
          <target state="translated">以下是有关可与 &lt;code&gt;asm&lt;/code&gt; 操作数一起使用的约束字母的特定详细信息。约束可以说明操作数是否可以在寄存器中，以及哪种寄存器；操作数是否可以是内存引用，以及哪种地址；操作数是否可以是立即数，以及它可能具有哪些值。约束也可能需要两个操作数匹配。内联 &lt;code&gt;asm&lt;/code&gt; 的操作数中不允许有副作用，除非&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="8169e79c24e48ad827616f09316f377a5693db58" translate="yes" xml:space="preserve">
          <source>Here is a fictitious &lt;code&gt;*z++ = *x++ * *y++&lt;/code&gt; instruction. Notice that the &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt; and &lt;code&gt;z&lt;/code&gt; pointer registers must be specified as input/output because the &lt;code&gt;asm&lt;/code&gt; modifies them.</source>
          <target state="translated">这是一个虚拟的 &lt;code&gt;*z++ = *x++ * *y++&lt;/code&gt; 指令。请注意，必须将 &lt;code&gt;x&lt;/code&gt; ， &lt;code&gt;y&lt;/code&gt; 和 &lt;code&gt;z&lt;/code&gt; 指针寄存器指定为输入/输出，因为 &lt;code&gt;asm&lt;/code&gt; 会对其进行修改。</target>
        </trans-unit>
        <trans-unit id="b840ee95bd53e4b94e99eb87178d11fd9afdba38" translate="yes" xml:space="preserve">
          <source>Here is a fictitious sum of squares instruction, that takes two pointers to floating point values in memory and produces a floating point register output. Notice that &lt;code&gt;x&lt;/code&gt;, and &lt;code&gt;y&lt;/code&gt; both appear twice in the &lt;code&gt;asm&lt;/code&gt; parameters, once to specify memory accessed, and once to specify a base register used by the &lt;code&gt;asm&lt;/code&gt;. You won&amp;rsquo;t normally be wasting a register by doing this as GCC can use the same register for both purposes. However, it would be foolish to use both &lt;code&gt;%1&lt;/code&gt; and &lt;code&gt;%3&lt;/code&gt; for &lt;code&gt;x&lt;/code&gt; in this &lt;code&gt;asm&lt;/code&gt; and expect them to be the same. In fact, &lt;code&gt;%3&lt;/code&gt; may well not be a register. It might be a symbolic memory reference to the object pointed to by &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">这是一个虚拟的平方和指令，它使用两个指针指向内存中的浮点值，并产生一个浮点寄存器输出。请注意， &lt;code&gt;x&lt;/code&gt; 和 &lt;code&gt;y&lt;/code&gt; 都在 &lt;code&gt;asm&lt;/code&gt; 参数中出现两次，一次是指定要访问的内存，一次是指定 &lt;code&gt;asm&lt;/code&gt; 使用的基址寄存器。通常，您这样做不会浪费寄存器，因为GCC可以将相同的寄存器用于这两个目的。但是，在此 &lt;code&gt;asm&lt;/code&gt; 中为 &lt;code&gt;x&lt;/code&gt; 使用 &lt;code&gt;%1&lt;/code&gt; 和 &lt;code&gt;%3&lt;/code&gt; 都是愚蠢的，并期望它们相同。实际上， &lt;code&gt;%3&lt;/code&gt; 可能不是寄存器。它可能是对 &lt;code&gt;x&lt;/code&gt; 指向的对象的符号内存引用。</target>
        </trans-unit>
        <trans-unit id="989c5915dce017df7249cda1058c0a0b75ec727b" translate="yes" xml:space="preserve">
          <source>Here is a fully worked-out example using a Foundation library (which provides the implementation of &lt;code&gt;NSArray&lt;/code&gt;, &lt;code&gt;NSString&lt;/code&gt; and &lt;code&gt;NSLog&lt;/code&gt;):</source>
          <target state="translated">这是一个使用Foundation库的完全解决的示例（提供了 &lt;code&gt;NSArray&lt;/code&gt; ， &lt;code&gt;NSString&lt;/code&gt; 和 &lt;code&gt;NSLog&lt;/code&gt; 的实现）：</target>
        </trans-unit>
        <trans-unit id="0837d871cde10d5f686c43af16d467ea239dcffc" translate="yes" xml:space="preserve">
          <source>Here is a list of each supported architecture and their supported implementations.</source>
          <target state="translated">下面是每个支持的架构及其支持的实现的列表。</target>
        </trans-unit>
        <trans-unit id="6bbe295750387ad466f92bad763fdcf85832b55b" translate="yes" xml:space="preserve">
          <source>Here is a list of options that are &lt;em&gt;only&lt;/em&gt; for compiling C++ programs:</source>
          <target state="translated">以下是&lt;em&gt;仅&lt;/em&gt;用于编译C ++程序的选项列表：</target>
        </trans-unit>
        <trans-unit id="9c6de7709b9bd71702ea864b6b84c7a93a1c5dfe" translate="yes" xml:space="preserve">
          <source>Here is a list of options that are &lt;em&gt;only&lt;/em&gt; for compiling Objective-C and Objective-C++ programs:</source>
          <target state="translated">这是&lt;em&gt;仅&lt;/em&gt;用于编译Objective-C和Objective-C ++程序的选项列表：</target>
        </trans-unit>
        <trans-unit id="3d287577ba4a1613932b539025d50b64c148479a" translate="yes" xml:space="preserve">
          <source>Here is a more technical description with the gory details. Consider the code</source>
          <target state="translated">下面是一个比较技术性的描述,有血淋淋的细节。请看下面的代码</target>
        </trans-unit>
        <trans-unit id="1f5c95b6edb6a49dd54cd8ace0a3af7f6b8efa6e" translate="yes" xml:space="preserve">
          <source>Here is a realistic example for the VAX showing the use of clobbered registers:</source>
          <target state="translated">下面是VAX的一个实际例子,展示了clobbered寄存器的使用。</target>
        </trans-unit>
        <trans-unit id="fab100c4848d525a51e3c94ffe939c5c90d217c1" translate="yes" xml:space="preserve">
          <source>Here is a small example of a spec file:</source>
          <target state="translated">下面是一个规范文件的小例子。</target>
        </trans-unit>
        <trans-unit id="fd38f38bfeb097a932215690af5b2bcebdd18296" translate="yes" xml:space="preserve">
          <source>Here is a summary of all the options, grouped by type. Explanations are in the following sections.</source>
          <target state="translated">以下是所有选项的摘要,按类型分类。以下各节将对其进行解释。</target>
        </trans-unit>
        <trans-unit id="776e1d0b1f7cf817731495ac8a0bb9e5528c2c48" translate="yes" xml:space="preserve">
          <source>Here is a table of all defined &amp;lsquo;</source>
          <target state="translated">这是所有已定义的&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="72ec126b11c4f7e2b3f6db181072684dbe3a798e" translate="yes" xml:space="preserve">
          <source>Here is a truncated example from the ARM port of &lt;code&gt;gcc&lt;/code&gt;:</source>
          <target state="translated">这是 &lt;code&gt;gcc&lt;/code&gt; 的ARM端口的截断示例：</target>
        </trans-unit>
        <trans-unit id="816eebea82d67ac72ae8e305241f89073b0b966e" translate="yes" xml:space="preserve">
          <source>Here is an example of &lt;code&gt;asm goto&lt;/code&gt; for i386:</source>
          <target state="translated">这是i386 的 &lt;code&gt;asm goto&lt;/code&gt; 示例：</target>
        </trans-unit>
        <trans-unit id="ddf77123eb0a199270833915774797e456c51dd3" translate="yes" xml:space="preserve">
          <source>Here is an example of a PowerPC vector scale implemented in assembly, complete with vector and condition code clobbers, and some initialized offset registers that are unchanged by the &lt;code&gt;asm&lt;/code&gt;.</source>
          <target state="translated">这是一个以汇编形式实现的PowerPC矢量比例的示例，其中包括矢量和条件代码修饰符，以及一些经 &lt;code&gt;asm&lt;/code&gt; 不变的初始化偏移寄存器。</target>
        </trans-unit>
        <trans-unit id="874ef7a4fb34e57091c1bf1216dfbb76680c0a4d" translate="yes" xml:space="preserve">
          <source>Here is an example of basic &lt;code&gt;asm&lt;/code&gt; for i386:</source>
          <target state="translated">这是i386 的基本 &lt;code&gt;asm&lt;/code&gt; 示例：</target>
        </trans-unit>
        <trans-unit id="578c29000b6f8a220ff3bd98b1f6dac59cfc8f4c" translate="yes" xml:space="preserve">
          <source>Here is an example of constructing a &lt;code&gt;struct foo&lt;/code&gt; with a compound literal:</source>
          <target state="translated">这是使用复合文字构造 &lt;code&gt;struct foo&lt;/code&gt; 的示例：</target>
        </trans-unit>
        <trans-unit id="b487a854c417efabdfc0cd516c584d94dc1d4a11" translate="yes" xml:space="preserve">
          <source>Here is an example of how to use this feature. Suppose you want to implement a class whose instances hold a weak pointer reference; the following class does this:</source>
          <target state="translated">下面是一个如何使用这个特性的例子。假设你想实现一个实例持有弱指针引用的类,下面的类就能实现这个功能。</target>
        </trans-unit>
        <trans-unit id="ab5b5e88b81c892525543bbf2b441bfb5667f5c0" translate="yes" xml:space="preserve">
          <source>Here is an example showing handling for &lt;code&gt;_XABORT_RETRY&lt;/code&gt; and a fallback path for other failures:</source>
          <target state="translated">这是一个显示 &lt;code&gt;_XABORT_RETRY&lt;/code&gt; 的处理以及其他失败的后备路径的示例：</target>
        </trans-unit>
        <trans-unit id="156d8468259daa1a9f530dd9ec7054117c896faf" translate="yes" xml:space="preserve">
          <source>Here is an example using symbolic names.</source>
          <target state="translated">下面是一个使用符号名称的例子。</target>
        </trans-unit>
        <trans-unit id="aa58661567f951b6e91b047e11c73d9fb7a1db05" translate="yes" xml:space="preserve">
          <source>Here is an example with a typename as the argument:</source>
          <target state="translated">下面是一个以类型名为参数的例子。</target>
        </trans-unit>
        <trans-unit id="540ee2aaf7182c6dfc449b18e5accb694e3b0894" translate="yes" xml:space="preserve">
          <source>Here is an example:</source>
          <target state="translated">下面是一个例子。</target>
        </trans-unit>
        <trans-unit id="26a60c8be4c01c6ccc45bd8984830035c8dc1a26" translate="yes" xml:space="preserve">
          <source>Here the two output filenames</source>
          <target state="translated">这里有两个输出文件名</target>
        </trans-unit>
        <trans-unit id="00b4a6c83965e727380186cb35a7faefe39e2601" translate="yes" xml:space="preserve">
          <source>Here the type described is that of pointers to &lt;code&gt;int&lt;/code&gt;.</source>
          <target state="translated">这里描述的类型是指向 &lt;code&gt;int&lt;/code&gt; 的指针的类型。</target>
        </trans-unit>
        <trans-unit id="df28516bc4139f3f069071685fe09b0059baa73c" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;d&lt;/code&gt; may either be in a register or in memory. Since the compiler might already have the current value of the &lt;code&gt;uint32_t&lt;/code&gt; location pointed to by &lt;code&gt;e&lt;/code&gt; in a register, you can enable it to choose the best location for &lt;code&gt;d&lt;/code&gt; by specifying both constraints.</source>
          <target state="translated">此处， &lt;code&gt;d&lt;/code&gt; 可以在寄存器中或在内存中。由于编译器可能已经在寄存器中具有 &lt;code&gt;e&lt;/code&gt; 指向的 &lt;code&gt;uint32_t&lt;/code&gt; 位置的当前值，因此可以通过指定两个约束使编译器为 &lt;code&gt;d&lt;/code&gt; 选择最佳位置。</target>
        </trans-unit>
        <trans-unit id="d245b0ad9046b148b54dc212babce2d8a4b44886" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;t4&lt;/code&gt; takes up 4 bytes.</source>
          <target state="translated">在此， &lt;code&gt;t4&lt;/code&gt; 占用4个字节。</target>
        </trans-unit>
        <trans-unit id="46a3f0b1a7f9b9f0c9d86a3230e304304bee1bda" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;t5&lt;/code&gt; takes up 2 bytes.</source>
          <target state="translated">在此， &lt;code&gt;t5&lt;/code&gt; 占用2个字节。</target>
        </trans-unit>
        <trans-unit id="f9dddf42b68435ab0aa7d4d6b86db289bd3db824" translate="yes" xml:space="preserve">
          <source>Here, the &lt;code&gt;std::move&lt;/code&gt; call is redundant. Because G++ implements Core Issue 1579, another example is:</source>
          <target state="translated">在这里， &lt;code&gt;std::move&lt;/code&gt; 调用是多余的。由于G ++实现了核心问题1579，因此另一个示例是：</target>
        </trans-unit>
        <trans-unit id="94a1520d218a1c0edb195732392c054a4dc1a61d" translate="yes" xml:space="preserve">
          <source>Here, the function &lt;code&gt;intermediate&lt;/code&gt; receives the address of &lt;code&gt;store&lt;/code&gt; as an argument. If &lt;code&gt;intermediate&lt;/code&gt; calls &lt;code&gt;store&lt;/code&gt;, the arguments given to &lt;code&gt;store&lt;/code&gt; are used to store into &lt;code&gt;array&lt;/code&gt;. But this technique works only so long as the containing function (&lt;code&gt;hack&lt;/code&gt;, in this example) does not exit.</source>
          <target state="translated">在此， &lt;code&gt;intermediate&lt;/code&gt; 函数将接收 &lt;code&gt;store&lt;/code&gt; 地址作为参数。如果是 &lt;code&gt;intermediate&lt;/code&gt; 调用 &lt;code&gt;store&lt;/code&gt; ，则给store的参数 &lt;code&gt;store&lt;/code&gt; 用于存储到 &lt;code&gt;array&lt;/code&gt; 中。但是，只有在不退出包含函数（在此示例中为 &lt;code&gt;hack&lt;/code&gt; )的情况下，此技术才有效。</target>
        </trans-unit>
        <trans-unit id="8e86d7a0668faeeae59dff730b5c0908c7e965fa" translate="yes" xml:space="preserve">
          <source>Here, the names &lt;code&gt;foo&lt;/code&gt; and &lt;code&gt;N&lt;/code&gt; appear in a context that does not depend on the type of &lt;code&gt;T&lt;/code&gt;. The compiler will thus require that they are defined in the context of use in the template, not only before the point of instantiation, and will here use &lt;code&gt;::foo(double)&lt;/code&gt; and &lt;code&gt;A::N&lt;/code&gt;, respectively. In particular, it will convert the integer value to a &lt;code&gt;double&lt;/code&gt; when passing it to &lt;code&gt;::foo(double)&lt;/code&gt;.</source>
          <target state="translated">在这里，名称 &lt;code&gt;foo&lt;/code&gt; 和 &lt;code&gt;N&lt;/code&gt; 出现在不依赖于 &lt;code&gt;T&lt;/code&gt; 类型的上下文中。因此，编译器会要求他们在使用的情况下，不仅之前实例化的点，将在这里使用已定义的模板 &lt;code&gt;::foo(double)&lt;/code&gt; 和 &lt;code&gt;A::N&lt;/code&gt; ，分别。特别是，当将其传递给 &lt;code&gt;::foo(double)&lt;/code&gt; 时，它将整数值转换为 &lt;code&gt;double&lt;/code&gt; 值。</target>
        </trans-unit>
        <trans-unit id="8a9da0e5c138e6d84a3e4a12f0c523bc1f369e0f" translate="yes" xml:space="preserve">
          <source>Hewlett-Packard PA-RISC&amp;mdash;</source>
          <target state="translated">惠普PA-RISC &amp;mdash;</target>
        </trans-unit>
        <trans-unit id="9e735341d337ae137df7758e8465bb4d998cc55a" translate="yes" xml:space="preserve">
          <source>Hexadecimal floating-point constants.</source>
          <target state="translated">十六进制浮点常数。</target>
        </trans-unit>
        <trans-unit id="26e165ccce457fee42636ec531aa349640cf4392" translate="yes" xml:space="preserve">
          <source>Hidden visibility indicates that the entity declared has a new form of linkage, which we call &amp;ldquo;hidden linkage&amp;rdquo;. Two declarations of an object with hidden linkage refer to the same object if they are in the same shared object.</source>
          <target state="translated">隐藏可见性表明所声明的实体具有新的链接形式，我们称为&amp;ldquo;隐藏链接&amp;rdquo;。如果具有隐藏链接的对象的两个声明位于同一共享对象中，则它们引用同一对象。</target>
        </trans-unit>
        <trans-unit id="29464505836db623029950c0312fcb03cbd85481" translate="yes" xml:space="preserve">
          <source>Historically, GCC has not deleted &amp;ldquo;empty&amp;rdquo; loops under the assumption that the most likely reason you would put one in a program is to have a delay, so deleting them will not make real programs run any faster.</source>
          <target state="translated">从历史上看，GCC并未删除&amp;ldquo;空&amp;rdquo;循环，但前提是您将一个空循环放入程序的最可能原因是延迟，因此删除它们不会使实际程序运行得更快。</target>
        </trans-unit>
        <trans-unit id="25855108b662a0e8c1ed703787f979b815d2d1a6" translate="yes" xml:space="preserve">
          <source>Historically, compilers for many languages, including C++ and Fortran, have been implemented as &amp;ldquo;preprocessors&amp;rdquo; which emit another high level language such as C. None of the compilers included in GCC are implemented this way; they all generate machine code directly. This sort of preprocessor should not be confused with the &lt;em&gt;C preprocessor&lt;/em&gt;, which is an integral feature of the C, C++, Objective-C and Objective-C++ languages.</source>
          <target state="translated">从历史上看，用于多种语言（包括C ++和Fortran）的编译器已实现为&amp;ldquo;预处理器&amp;rdquo;，发出了诸如C的另一种高级语言。它们都直接生成机器代码。此类预处理器不应与&lt;em&gt;C预处理器&lt;/em&gt;混淆，&lt;em&gt;C预处理器&lt;/em&gt;是C，C ++，Objective-C和Objective-C ++语言的不可或缺的功能。</target>
        </trans-unit>
        <trans-unit id="1df0e52c96207e60432f242eee2da9b8ff549d2b" translate="yes" xml:space="preserve">
          <source>How GCC calculates the size of an &lt;code&gt;asm&lt;/code&gt; block.</source>
          <target state="translated">GCC如何计算 &lt;code&gt;asm&lt;/code&gt; 块的大小。</target>
        </trans-unit>
        <trans-unit id="3f9040ed129a83c15932559ac6449ffd679075c3" translate="yes" xml:space="preserve">
          <source>How GCC implements the ISO C specification.</source>
          <target state="translated">GCC如何实现ISO C规范。</target>
        </trans-unit>
        <trans-unit id="f79f60bc97ae69f938083d6bd71809804c4831c5" translate="yes" xml:space="preserve">
          <source>How GCC implements the ISO C++ specification.</source>
          <target state="translated">GCC如何实现ISO C++规范。</target>
        </trans-unit>
        <trans-unit id="62fab6a3b6832fb352405ce63e5b735618b3cef7" translate="yes" xml:space="preserve">
          <source>How To Get Help with GCC</source>
          <target state="translated">如何获得GCC的帮助</target>
        </trans-unit>
        <trans-unit id="3e63c682de797883ae23802bc327411231cc31a8" translate="yes" xml:space="preserve">
          <source>How a diagnostic is identified (C90 3.7, C99 and C11 3.10, C90, C99 and C11 5.1.1.3).</source>
          <target state="translated">如何确定诊断(C90 3.7、C99和C11 3.10、C90、C99和C11 5.1.1.3);</target>
        </trans-unit>
        <trans-unit id="a123b2bec235da6dad3dc58f234c2574673ff822" translate="yes" xml:space="preserve">
          <source>How much optimization?</source>
          <target state="translated">优化多少?</target>
        </trans-unit>
        <trans-unit id="31524a9fb30368b64541b8aeb51e1826b2eb3b0a" translate="yes" xml:space="preserve">
          <source>How picky should the compiler be?</source>
          <target state="translated">编译器应该如何挑剔?</target>
        </trans-unit>
        <trans-unit id="1e2b472e6c532fe8af4932714956f74293f46083" translate="yes" xml:space="preserve">
          <source>How sequences in both forms of header names are mapped to headers or external source file names (C90 6.1.7, C99 and C11 6.4.7).</source>
          <target state="translated">如何将两种形式的头名中的序列映射到头名或外部源文件名上(C90 6.1.7、C99和C11 6.4.7);</target>
        </trans-unit>
        <trans-unit id="848f6ad2348dcee59d13596577066e141ef4d0ad" translate="yes" xml:space="preserve">
          <source>How the named source file is searched for in an included &amp;lsquo;</source>
          <target state="translated">如何在包含的&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="130378b21f742b32140465d74f388cb06f5001cf" translate="yes" xml:space="preserve">
          <source>How the nearest representable value or the larger or smaller representable value immediately adjacent to the nearest representable value is chosen for certain floating constants (C90 6.1.3.1, C99 and C11 6.4.4.2).</source>
          <target state="translated">对于某些浮动常数,如何选择最近的可表示值或紧邻最近可表示值的较大或较小的可表示值(C90 6.1.3.1,C99和C11 6.4.4.2)。</target>
        </trans-unit>
        <trans-unit id="606b9fa050c9f5a8165f3052560ba0c7d8b85fa0" translate="yes" xml:space="preserve">
          <source>How to contribute to testing and developing GCC.</source>
          <target state="translated">如何为测试和开发GCC做贡献。</target>
        </trans-unit>
        <trans-unit id="25170558e581aabef161dcb92e9a6de67ff5f448" translate="yes" xml:space="preserve">
          <source>How to help assure funding for free software.</source>
          <target state="translated">如何帮助保证免费软件的资金。</target>
        </trans-unit>
        <trans-unit id="488dee81569b2dc10244c6b537b50c3cc87269e1" translate="yes" xml:space="preserve">
          <source>How to pass switches to sub-processes.</source>
          <target state="translated">如何将开关传递给子进程。</target>
        </trans-unit>
        <trans-unit id="8c1e8efdd3392d7ad8138bb7223322e34b90c240" translate="yes" xml:space="preserve">
          <source>How to use gcov-dump.</source>
          <target state="translated">如何使用gcov-dump。</target>
        </trans-unit>
        <trans-unit id="f7d8be53e9f165a3a11bb6dadca7af891ced365f" translate="yes" xml:space="preserve">
          <source>How to use gcov-tool.</source>
          <target state="translated">如何使用gcov-tool。</target>
        </trans-unit>
        <trans-unit id="dde16118c9faa27675fdfe5cf0405564b55597c4" translate="yes" xml:space="preserve">
          <source>How to use gcov.</source>
          <target state="translated">如何使用gcov。</target>
        </trans-unit>
        <trans-unit id="4e461b3cc6748ec681eab8b558da86d4b08a95ab" translate="yes" xml:space="preserve">
          <source>How you can copy and share this manual.</source>
          <target state="translated">如何复制和分享本手册。</target>
        </trans-unit>
        <trans-unit id="9e8e4dbcb1b211f7b5ab31c6c59b3a79ec59dd4f" translate="yes" xml:space="preserve">
          <source>How, why and where to report bugs.</source>
          <target state="translated">如何、为什么以及在哪里报告错误。</target>
        </trans-unit>
        <trans-unit id="0e3275b465f023e98f74ae720920ad438e50264c" translate="yes" xml:space="preserve">
          <source>However, &lt;code&gt;(union foo) FLT_MAX;&lt;/code&gt; is not a valid cast because the union has no member of type &lt;code&gt;float&lt;/code&gt;.</source>
          <target state="translated">但是， &lt;code&gt;(union foo) FLT_MAX;&lt;/code&gt; 不是有效的类型转换，因为联合没有 &lt;code&gt;float&lt;/code&gt; 类型的成员。</target>
        </trans-unit>
        <trans-unit id="9ea71fd7ca0b24f50560578a479dbd93975ddc25" translate="yes" xml:space="preserve">
          <source>However, if a library or main executable is supposed to throw or catch exceptions, you must link it using the G++ driver, or using the option</source>
          <target state="translated">但是,如果一个库或主可执行文件应该抛出或捕获异常,你必须使用G++驱动或使用选项</target>
        </trans-unit>
        <trans-unit id="68ad5ea0590b2a354fce31707da021a7a4908783" translate="yes" xml:space="preserve">
          <source>However, if the volatile storage is not being modified, and the value of the volatile storage is not used, then the situation is less obvious. For example</source>
          <target state="translated">但是,如果不修改易失性存储,不使用易失性存储的值,那么情况就不那么明显了。比如说</target>
        </trans-unit>
        <trans-unit id="3955f23a3aaffbcd48d8f54a3969fb80a9687bcd" translate="yes" xml:space="preserve">
          <source>However, the rationale here is that optimization of a nonempty loop cannot produce an empty one. This held for carefully written C compiled with less powerful optimizers but is not always the case for carefully written C++ or with more powerful optimizers. Thus GCC will remove operations from loops whenever it can determine those operations are not externally visible (apart from the time taken to execute them, of course). In case the loop can be proved to be finite, GCC will also remove the loop itself.</source>
          <target state="translated">然而,这里的原理是,对一个非空循环的优化不能产生一个空循环。这对于用功能较弱的优化器精心编写的C编译来说是成立的,但对于精心编写的C++或功能较强的优化器来说就不一定了。因此,GCC只要能够确定这些操作在外部不可见,就会从循环中删除这些操作(当然,除了执行这些操作所花费的时间)。在可以证明循环是有限的情况下,GCC也会删除循环本身。</target>
        </trans-unit>
        <trans-unit id="9091ae1dd68a17c85dd2a3885c0a623d65f81f37" translate="yes" xml:space="preserve">
          <source>However, the use of &lt;code&gt;gcc&lt;/code&gt; does not add the C++ library. &lt;code&gt;g++&lt;/code&gt; is a program that calls GCC and automatically specifies linking against the C++ library. It treats &amp;lsquo;</source>
          <target state="translated">但是，使用 &lt;code&gt;gcc&lt;/code&gt; 不会添加C ++库。 &lt;code&gt;g++&lt;/code&gt; 是一个调用GCC并自动指定针对C ++库的链接的程序。它对待</target>
        </trans-unit>
        <trans-unit id="25970c1ebc6bb12a4ef702c744afb1bf31667e71" translate="yes" xml:space="preserve">
          <source>However, these built-in functions may interact badly with some sophisticated features or other extensions of the language. It is, therefore, not recommended to use them outside very simple functions acting as mere forwarders for their arguments.</source>
          <target state="translated">然而,这些内置函数可能会与一些复杂的功能或语言的其他扩展产生不良互动。因此,不建议在非常简单的函数之外使用它们,而只是作为其参数的转发者。</target>
        </trans-unit>
        <trans-unit id="ca73ab65568cd125c2d27a22bbd9e863c10b675d" translate="yes" xml:space="preserve">
          <source>I</source>
          <target state="translated">I</target>
        </trans-unit>
        <trans-unit id="5035ba1d98ecd402c64867de896608b2100e61c1" translate="yes" xml:space="preserve">
          <source>I register</source>
          <target state="translated">我注册</target>
        </trans-unit>
        <trans-unit id="0d25569c1c1c38b68b7adac7a2691f92a581fc48" translate="yes" xml:space="preserve">
          <source>IBM 970 Server CPU (ie, Apple G5).</source>
          <target state="translated">IBM 970服务器CPU(即苹果G5)。</target>
        </trans-unit>
        <trans-unit id="7ff989fdaf3c65fbe049204ca8d2d3b298dcd55a" translate="yes" xml:space="preserve">
          <source>IBM A2 64-bit Embedded CPU</source>
          <target state="translated">IBM A2 64位嵌入式CPU</target>
        </trans-unit>
        <trans-unit id="7ebf129d97228e5e38b88ee3a2bf7cb0f28dd1fe" translate="yes" xml:space="preserve">
          <source>IBM POWER4 Server CPU.</source>
          <target state="translated">IBM POWER4服务器CPU。</target>
        </trans-unit>
        <trans-unit id="60fedee6d379816b90140e69a6cb94f8d8a8d0f3" translate="yes" xml:space="preserve">
          <source>IBM POWER5 Server CPU.</source>
          <target state="translated">IBM POWER5服务器CPU。</target>
        </trans-unit>
        <trans-unit id="d3878c6f9c9f4047fa51bbea5fff4ce5c35e5af1" translate="yes" xml:space="preserve">
          <source>IBM POWER5+ Server CPU.</source>
          <target state="translated">IBM POWER5+服务器CPU。</target>
        </trans-unit>
        <trans-unit id="738e9fd792342dee79476051b27ac20d78ee9cda" translate="yes" xml:space="preserve">
          <source>IBM POWER6 Server CPU (Architected mode).</source>
          <target state="translated">IBM POWER6服务器CPU(架构模式)。</target>
        </trans-unit>
        <trans-unit id="a1d93b9cb2926fb05ec1f665abf51961f777a207" translate="yes" xml:space="preserve">
          <source>IBM POWER6 Server CPU (RAW mode).</source>
          <target state="translated">IBM POWER6服务器CPU(RAW模式)。</target>
        </trans-unit>
        <trans-unit id="dbb9a20762f1a0c1106412992e6cc65c84bffc0f" translate="yes" xml:space="preserve">
          <source>IBM POWER7 Server CPU.</source>
          <target state="translated">IBM POWER7服务器CPU。</target>
        </trans-unit>
        <trans-unit id="a9a9c9a90077a9f8cbd67dc15b93836e1c987d49" translate="yes" xml:space="preserve">
          <source>IBM POWER8 Server CPU.</source>
          <target state="translated">IBM POWER8服务器CPU。</target>
        </trans-unit>
        <trans-unit id="c65507ef531be00847ba2a33296dc99803a18664" translate="yes" xml:space="preserve">
          <source>IBM POWER9 Server CPU.</source>
          <target state="translated">IBM POWER9服务器CPU。</target>
        </trans-unit>
        <trans-unit id="5ad8015703e3cb16c9df6da3a8d9e97de8f9cd44" translate="yes" xml:space="preserve">
          <source>IBM PowerPC 464 32-bit Embedded CPU.</source>
          <target state="translated">IBM PowerPC 464 32位嵌入式CPU。</target>
        </trans-unit>
        <trans-unit id="a548cb73c6f0d35ac7d906f9a02a9350c2eb6114" translate="yes" xml:space="preserve">
          <source>IBM PowerPC 476FP 32-bit Embedded CPU.</source>
          <target state="translated">IBM PowerPC 476FP 32位嵌入式CPU。</target>
        </trans-unit>
        <trans-unit id="f3afdcbb4bda95413d989775a1a1f73e05c37f36" translate="yes" xml:space="preserve">
          <source>IBM PowerPC Cell Broadband Engine Architecture CPU.</source>
          <target state="translated">IBM PowerPC小区宽带引擎架构CPU。</target>
        </trans-unit>
        <trans-unit id="981e760991adb048080be646b9e1438966c192d0" translate="yes" xml:space="preserve">
          <source>IDT WinChip 2 CPU, dealt in same way as i486 with additional MMX and 3DNow! instruction set support.</source>
          <target state="translated">IDT WinChip 2 CPU,处理方式与i486相同,额外支持MMX和3DNow!指令集。</target>
        </trans-unit>
        <trans-unit id="e642e2d5acc8e35a06fd449f3d95c2b4f1486f5e" translate="yes" xml:space="preserve">
          <source>IDT WinChip C6 CPU, dealt in same way as i486 with additional MMX instruction set support.</source>
          <target state="translated">IDT WinChip C6 CPU,处理方式与i486相同,但增加了MMX指令集支持。</target>
        </trans-unit>
        <trans-unit id="ec8566180afc9d36e3493dbd47d7e2d1e9ae9485" translate="yes" xml:space="preserve">
          <source>IPA-CP attempts to track all possible values and types passed to a function&amp;rsquo;s parameter in order to propagate them and perform devirtualization.</source>
          <target state="translated">IPA-CP尝试跟踪传递给函数参数的所有可能的值和类型，以传播它们并执行虚拟化。</target>
        </trans-unit>
        <trans-unit id="f55eb535889fe2d3f53ef9f4b4a57453862d05ea" translate="yes" xml:space="preserve">
          <source>IPA-CP calculates its own score of cloning profitability heuristics and performs those cloning opportunities with scores that exceed</source>
          <target state="translated">IPA-CP计算自己的克隆盈利启发式得分,并执行那些得分超过的克隆机会</target>
        </trans-unit>
        <trans-unit id="18432c18c0adba44c26c2a586731fb98a9d6d897" translate="yes" xml:space="preserve">
          <source>IPA-CP is also capable to propagate a number of scalar values passed in an aggregate.</source>
          <target state="translated">IPA-CP也能够传播一些集合中传递的标量值。</target>
        </trans-unit>
        <trans-unit id="6522b0ebe1c355ebd160511e9d28107d63eb735d" translate="yes" xml:space="preserve">
          <source>IPA-SRA replaces a pointer to an aggregate with one or more new parameters only when their cumulative size is less or equal to</source>
          <target state="translated">IPA-SRA只有当一个或多个新参数的累积大小小于或等于</target>
        </trans-unit>
        <trans-unit id="b5db770cbd54ca7a4734eeb3ccbfba61d7f93149" translate="yes" xml:space="preserve">
          <source>IRA can be used to evaluate more accurate register pressure in loops for decisions to move loop invariants (see</source>
          <target state="translated">IRA可以用来评估环路中更精确的寄存器压力,以决定移动环路不变量(见图3)。</target>
        </trans-unit>
        <trans-unit id="3c1b099cab9d31b532499457a148771feb1ef850" translate="yes" xml:space="preserve">
          <source>IRA uses regional register allocation by default. If a function contains more loops than the number given by this parameter, only at most the given number of the most frequently-executed loops form regions for regional register allocation.</source>
          <target state="translated">IRA默认使用区域寄存器分配。如果一个函数包含的循环数量超过了这个参数所给的数量,那么最多只有给定数量的最频繁执行的循环才会形成区域寄存器分配的区域。</target>
        </trans-unit>
        <trans-unit id="e1a35fb9a6e6329c3bd0cf9dd057013f4b706fa3" translate="yes" xml:space="preserve">
          <source>ISA 3.0 of the PowerPC added new atomic memory operation (amo) instructions. GCC provides support for these instructions in 64-bit environments. All of the functions are declared in the include file &lt;code&gt;amo.h&lt;/code&gt;.</source>
          <target state="translated">PowerPC的ISA 3.0添加了新的原子存储操作（amo）指令。GCC在64位环境中为这些指令提供支持。所有功能都在包含文件 &lt;code&gt;amo.h&lt;/code&gt; 中声明。</target>
        </trans-unit>
        <trans-unit id="7cc00c6a2a5486718b4fd3642b097add2ed40af8" translate="yes" xml:space="preserve">
          <source>ISO C does not permit such a construct.</source>
          <target state="translated">ISO C不允许这种结构。</target>
        </trans-unit>
        <trans-unit id="fff460d30b4f47f8adc19f1a9e29c9166acd036b" translate="yes" xml:space="preserve">
          <source>ISO C requires a &amp;ldquo;diagnostic&amp;rdquo; message for certain kinds of invalid programs, but a warning is defined by GCC to count as a diagnostic. If GCC produces a warning but not an error, that is correct ISO C support. If testsuites call this &amp;ldquo;failure&amp;rdquo;, they should be run with the GCC option</source>
          <target state="translated">ISO C要求对某些种类的无效程序发出&amp;ldquo;诊断&amp;rdquo;消息，但是GCC定义了警告以算作诊断。如果GCC发出警告而不是错误，则说明ISO C是正确的支持。如果测试人员称此为&amp;ldquo;失败&amp;rdquo;，则应使用GCC选项运行它们</target>
        </trans-unit>
        <trans-unit id="50648f88649c1f5dd7bf2cb4554ff39825b6b2bb" translate="yes" xml:space="preserve">
          <source>ISO C11, the 2011 revision of the ISO C standard. This standard is substantially completely supported, modulo bugs, floating-point issues (mainly but not entirely relating to optional C11 features from Annexes F and G) and the optional Annexes K (Bounds-checking interfaces) and L (Analyzability). The name &amp;lsquo;</source>
          <target state="translated">ISO C11，ISO C标准的2011年修订版。基本上完全支持此标准，模错误，浮点问题（主要但不完全与附件F和G中的可选C11功能有关）以及可选附件K（边界检查接口）和L（可分析性）。名字 '</target>
        </trans-unit>
        <trans-unit id="a94be837facd76378c47084c4afa22ac2ddb78d6" translate="yes" xml:space="preserve">
          <source>ISO C17, the 2017 revision of the ISO C standard (published in 2018). This standard is same as C11 except for corrections of defects (all of which are also applied with</source>
          <target state="translated">ISO C17,是ISO C标准的2017年修订版(2018年发布)。该标准除缺陷的纠正外,其他与C11相同(均与</target>
        </trans-unit>
        <trans-unit id="835b0fe47c2b2521e64ab3b466f790da05e1cf2c" translate="yes" xml:space="preserve">
          <source>ISO C90 as modified in amendment 1.</source>
          <target state="translated">经第1修正案修改的ISO C90。</target>
        </trans-unit>
        <trans-unit id="dd3ae16769f5e30cd0e25b181c241be07701badf" translate="yes" xml:space="preserve">
          <source>ISO C99 and ISO C++ allow declarations and code to be freely mixed within compound statements. As an extension, GNU C also allows this in C90 mode. For example, you could do:</source>
          <target state="translated">ISO C99和ISO C++允许声明和代码在复合语句中自由混合。作为扩展,GNU C也允许在C90模式下这样做。例如,你可以这样做。</target>
        </trans-unit>
        <trans-unit id="fd9df382c7a9e275bf54293954eb3cea3a9394da" translate="yes" xml:space="preserve">
          <source>ISO C99 and ISO C++11 support data types for integers that are at least 64 bits wide, and as an extension GCC supports them in C90 and C++98 modes. Simply write &lt;code&gt;long long int&lt;/code&gt; for a signed integer, or &lt;code&gt;unsigned long long int&lt;/code&gt; for an unsigned integer. To make an integer constant of type &lt;code&gt;long long int&lt;/code&gt;, add the suffix &amp;lsquo;</source>
          <target state="translated">ISO C99和ISO C ++ 11支持至少64位宽的整数的数据类型，并且作为扩展，GCC在C90和C ++ 98模式下支持它们。只需为有符号整数写 &lt;code&gt;long long int&lt;/code&gt; 或为无符号整数写 &lt;code&gt;unsigned long long int&lt;/code&gt; 。要使 &lt;code&gt;long long int&lt;/code&gt; 类型的整数常量，请添加后缀'</target>
        </trans-unit>
        <trans-unit id="8b83453de486a892e712e76d4673bb12ab84c153" translate="yes" xml:space="preserve">
          <source>ISO C99 and ISO C++17 support floating-point numbers written not only in the usual decimal notation, such as &lt;code&gt;1.55e1&lt;/code&gt;, but also numbers such as &lt;code&gt;0x1.fp3&lt;/code&gt; written in hexadecimal format. As a GNU extension, GCC supports this in C90 mode (except in some cases when strictly conforming) and in C++98, C++11 and C++14 modes. In that format the &amp;lsquo;</source>
          <target state="translated">ISO C99和ISO C ++ 17不但支持以十进制表示的 &lt;code&gt;1.55e1&lt;/code&gt; （例如1.55e1），还 &lt;code&gt;0x1.fp3&lt;/code&gt; 以十六进制格式写的数字（例如0x1.fp3）。作为GNU扩展，GCC在C90模式（在某些情况下严格遵循要求时除外）以及C ++ 98，C ++ 11和C ++ 14模式都支持此功能。以这种格式，&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="f45bb32dfebc99db4671808e81b5e06e1a3ae3f3" translate="yes" xml:space="preserve">
          <source>ISO C99 supports complex floating data types, and as an extension GCC supports them in C90 mode and in C++. GCC also supports complex integer data types which are not part of ISO C99. You can declare complex types using the keyword &lt;code&gt;_Complex&lt;/code&gt;. As an extension, the older GNU keyword &lt;code&gt;__complex__&lt;/code&gt; is also supported.</source>
          <target state="translated">ISO C99支持复杂的浮动数据类型，作为扩展，GCC在C90模式和C ++中支持它们。GCC还支持不属于ISO C99的复杂整数数据类型。您可以使用关键字 &lt;code&gt;_Complex&lt;/code&gt; 声明复杂类型。作为扩展，还支持较旧的GNU关键字 &lt;code&gt;__complex__&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="84c793c819960394587c5cc12a67f14b20b38119" translate="yes" xml:space="preserve">
          <source>ISO C99. This standard is substantially completely supported, modulo bugs and floating-point issues (mainly but not entirely relating to optional C99 features from Annexes F and G). See &lt;a href=&quot;http://gcc.gnu.org/c99status.html&quot;&gt;http://gcc.gnu.org/c99status.html&lt;/a&gt; for more information. The names &amp;lsquo;</source>
          <target state="translated">ISO C99。基本上完全支持该标准，模错误和浮点问题（主要但不完全与附件F和G中的可选C99功能有关）。有关更多信息，请参见&lt;a href=&quot;http://gcc.gnu.org/c99status.html&quot;&gt;http://gcc.gnu.org/c99status.html&lt;/a&gt;。名字 '</target>
        </trans-unit>
        <trans-unit id="b19dfb0d72b128922f94144b3b4ef7616d4f13d5" translate="yes" xml:space="preserve">
          <source>ISO/IEC TS 18661-3 defines new permissible values for &lt;code&gt;FLT_EVAL_METHOD&lt;/code&gt; that indicate that operations and constants with a semantic type that is an interchange or extended format should be evaluated to the precision and range of that type. These new values are a superset of those permitted under C99/C11, which does not specify the meaning of other positive values of &lt;code&gt;FLT_EVAL_METHOD&lt;/code&gt;. As such, code conforming to C11 may not have been written expecting the possibility of the new values.</source>
          <target state="translated">ISO / IEC TS 18661-3定义了 &lt;code&gt;FLT_EVAL_METHOD&lt;/code&gt; 的新允许值，该值指示应将语义类型为互换或扩展格式的操作和常量评估为该类型的精度和范围。这些新值是C99 / C11所允许的值的超集，该值未指定 &lt;code&gt;FLT_EVAL_METHOD&lt;/code&gt; 的其他正值的含义。这样，可能尚未编写符合C11的代码，并期望有新值。</target>
        </trans-unit>
        <trans-unit id="0704127df0a170eee2b3d8c1f35e3e35e1e33e3c" translate="yes" xml:space="preserve">
          <source>ISO/IEC TS 18661-3:2015 defines C support for additional floating types &lt;code&gt;_Float&lt;var&gt;n&lt;/var&gt;&lt;/code&gt; and &lt;code&gt;_Float&lt;var&gt;n&lt;/var&gt;x&lt;/code&gt;, and GCC supports these type names; the set of types supported depends on the target architecture. These types are not supported when compiling C++. Constants with these types use suffixes &lt;code&gt;f&lt;var&gt;n&lt;/var&gt;&lt;/code&gt; or &lt;code&gt;F&lt;var&gt;n&lt;/var&gt;&lt;/code&gt; and &lt;code&gt;f&lt;var&gt;n&lt;/var&gt;x&lt;/code&gt; or &lt;code&gt;F&lt;var&gt;n&lt;/var&gt;x&lt;/code&gt;. These type names can be used together with &lt;code&gt;_Complex&lt;/code&gt; to declare complex types.</source>
          <target state="translated">ISO / IEC TS 18661-3：2015定义了对其他浮点类型 &lt;code&gt;_Float&lt;var&gt;n&lt;/var&gt;&lt;/code&gt; 和 &lt;code&gt;_Float&lt;var&gt;n&lt;/var&gt;x&lt;/code&gt; C支持，而GCC支持这些类型名。支持的类型集取决于目标体系结构。编译C ++时不支持这些类型。这些类型的常量使用后缀 &lt;code&gt;f&lt;var&gt;n&lt;/var&gt;&lt;/code&gt; 或 &lt;code&gt;F&lt;var&gt;n&lt;/var&gt;&lt;/code&gt; 以及 &lt;code&gt;f&lt;var&gt;n&lt;/var&gt;x&lt;/code&gt; 或 &lt;code&gt;F&lt;var&gt;n&lt;/var&gt;x&lt;/code&gt; 后缀。这些类型名称可以与 &lt;code&gt;_Complex&lt;/code&gt; 一起使用以声明复杂类型。</target>
        </trans-unit>
        <trans-unit id="beeb64c7eeaed20d36a340ce018bf60cf4a13bf4" translate="yes" xml:space="preserve">
          <source>Ideally, a portable program should always use &lt;code&gt;signed char&lt;/code&gt; or &lt;code&gt;unsigned char&lt;/code&gt; when it depends on the signedness of an object. But many programs have been written to use plain &lt;code&gt;char&lt;/code&gt; and expect it to be signed, or expect it to be unsigned, depending on the machines they were written for. This option, and its inverse, let you make such a program work with the opposite default.</source>
          <target state="translated">理想情况下，当可移植程序依赖于对象的 &lt;code&gt;unsigned char&lt;/code&gt; 时，应始终使用有 &lt;code&gt;signed char&lt;/code&gt; 或无符号字符。但是，已经编写了许多使用纯 &lt;code&gt;char&lt;/code&gt; 并希望它们可以被签名，或者期望它是未签名的，这取决于编写它们的机器。此选项及其相反的选项使您可以使用相反的默认值使此类程序正常工作。</target>
        </trans-unit>
        <trans-unit id="ab2f71fc75bf24fc42ea67b7b9de3bc2377f68da" translate="yes" xml:space="preserve">
          <source>Identical like the above one, but the location of the function in the &lt;code&gt;jli&lt;/code&gt; table is known and given as an attribute parameter.</source>
          <target state="translated">与上述方法相同，但是函数在 &lt;code&gt;jli&lt;/code&gt; 表中的位置是已知的，并作为属性参数给出。</target>
        </trans-unit>
        <trans-unit id="06758e7fffb077a661e9d5cfb54c15702892df80" translate="yes" xml:space="preserve">
          <source>Identifier conflicts with labels. Traditional C lacks a separate namespace for labels.</source>
          <target state="translated">标识符与标签冲突。传统C语言缺乏单独的标签命名空间。</target>
        </trans-unit>
        <trans-unit id="5a6386123e656c29d067b76006564d3382accf62" translate="yes" xml:space="preserve">
          <source>Identify the versions of each tool used by the compiler, in a &lt;code&gt;.ident&lt;/code&gt; assembler directive in the output.</source>
          <target state="translated">在输出中的 &lt;code&gt;.ident&lt;/code&gt; 汇编程序伪指令中，标识编译器使用的每个工具的版本。</target>
        </trans-unit>
        <trans-unit id="751c68a3471b1c791efaee0a8e7c24ea0c266efd" translate="yes" xml:space="preserve">
          <source>If</source>
          <target state="translated">If</target>
        </trans-unit>
        <trans-unit id="b94b85388613ff812132cfe4fbfdcb534fff787e" translate="yes" xml:space="preserve">
          <source>If &amp;lsquo;</source>
          <target state="translated">如果</target>
        </trans-unit>
        <trans-unit id="8cfab80fece1ea34402901dd4726bddf817b9cff" translate="yes" xml:space="preserve">
          <source>If 3DNow! extensions are enabled, &lt;code&gt;V2SF&lt;/code&gt; is used as a mode for a vector of two 32-bit floating-point values.</source>
          <target state="translated">如果是3DNow！启用扩展， &lt;code&gt;V2SF&lt;/code&gt; 用作两个32位浮点值的向量的模式。</target>
        </trans-unit>
        <trans-unit id="23030af34d65c4d0b445c2e6bf477bf6b1f5c071" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;%*&lt;/code&gt; appears as the last part of a spec sequence then a space is added after the end of the last substitution. If there is more text in the sequence, however, then a space is not generated. This allows the &lt;code&gt;%*&lt;/code&gt; substitution to be used as part of a larger string. For example, a spec string like this:</source>
          <target state="translated">如果 &lt;code&gt;%*&lt;/code&gt; 作为规范序列的最后一部分出现，则在最后一个替换结束之后添加一个空格。但是，如果序列中有更多文本，则不会生成空格。这允许将 &lt;code&gt;%*&lt;/code&gt; 替换用作较大字符串的一部分。例如，如下所示的规范字符串：</target>
        </trans-unit>
        <trans-unit id="539ea1d3aa99e1f5670827ce3f6d748af1cde993" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;+resolveInstanceMethod:&lt;/code&gt; (or &lt;code&gt;+resolveClassMethod:&lt;/code&gt;) is not implemented or returns &lt;code&gt;NO&lt;/code&gt;, the runtime then tries the forwarding hook.</source>
          <target state="translated">如果未实现 &lt;code&gt;+resolveInstanceMethod:&lt;/code&gt; 或 &lt;code&gt;+resolveClassMethod:&lt;/code&gt; ：）或返回 &lt;code&gt;NO&lt;/code&gt; ，那么运行时将尝试转发挂钩。</target>
        </trans-unit>
        <trans-unit id="3f8dd7c3c9fed3437a52aa9c603d614b32cf2d92" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;-Walloca-larger-than=500&lt;/code&gt; were passed, the above would trigger a warning, but this time because of the lack of bounds checking.</source>
          <target state="translated">如果 &lt;code&gt;-Walloca-larger-than=500&lt;/code&gt; ，则上面的命令将触发警告，但这一次是由于缺少边界检查。</target>
        </trans-unit>
        <trans-unit id="ca79581e5d9acfa9f2b20401cffd3a6d08f404f9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;D1&lt;/code&gt; has the form &lt;code&gt;( &lt;var&gt;attribute-specifier-list&lt;/var&gt; D )&lt;/code&gt;, and the declaration &lt;code&gt;T D&lt;/code&gt; specifies the type &amp;ldquo;&lt;var&gt;derived-declarator-type-list&lt;/var&gt;&lt;var&gt;Type&lt;/var&gt;&amp;rdquo; for &lt;var&gt;ident&lt;/var&gt;, then &lt;code&gt;T D1&lt;/code&gt; specifies the type &amp;ldquo;&lt;var&gt;derived-declarator-type-list&lt;/var&gt;&lt;var&gt;attribute-specifier-list&lt;/var&gt;&lt;var&gt;Type&lt;/var&gt;&amp;rdquo; for &lt;var&gt;ident&lt;/var&gt;.</source>
          <target state="translated">如果 &lt;code&gt;D1&lt;/code&gt; 的格式为 &lt;code&gt;( &lt;var&gt;attribute-specifier-list&lt;/var&gt; D )&lt;/code&gt; ，并且声明 &lt;code&gt;T D&lt;/code&gt; 为 &lt;var&gt;ident&lt;/var&gt; 指定类型&amp;ldquo; &lt;var&gt;derived-declarator-type-list&lt;/var&gt; &lt;var&gt;Type&lt;/var&gt; &amp;rdquo; ，则 &lt;code&gt;T D1&lt;/code&gt; 指定类型为&amp;ldquo; &lt;var&gt;derived-declarator-type-list&lt;/var&gt; &lt;var&gt;attribute-specifier-list&lt;/var&gt; &lt;var&gt;ident&lt;/var&gt; 的 &amp;ldquo; 说明符列表 &lt;var&gt;Type&lt;/var&gt; &amp;rdquo; 。</target>
        </trans-unit>
        <trans-unit id="bce12bf3e38781beccd90d07d87af63b34ed169d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;D1&lt;/code&gt; has the form &lt;code&gt;*
&lt;var&gt;type-qualifier-and-attribute-specifier-list&lt;/var&gt; D&lt;/code&gt;, and the declaration &lt;code&gt;T D&lt;/code&gt; specifies the type &amp;ldquo;&lt;var&gt;derived-declarator-type-list&lt;/var&gt;&lt;var&gt;Type&lt;/var&gt;&amp;rdquo; for &lt;var&gt;ident&lt;/var&gt;, then &lt;code&gt;T D1&lt;/code&gt; specifies the type &amp;ldquo;&lt;var&gt;derived-declarator-type-list&lt;/var&gt;&lt;var&gt;type-qualifier-and-attribute-specifier-list&lt;/var&gt; pointer to &lt;var&gt;Type&lt;/var&gt;&amp;rdquo; for &lt;var&gt;ident&lt;/var&gt;.</source>
          <target state="translated">如果 &lt;code&gt;D1&lt;/code&gt; 的形式为 &lt;code&gt;* &lt;var&gt;type-qualifier-and-attribute-specifier-list&lt;/var&gt; D&lt;/code&gt; ，并且声明 &lt;code&gt;T D&lt;/code&gt; 为 &lt;var&gt;ident&lt;/var&gt; 指定类型&amp;ldquo; &lt;var&gt;derived-declarator-type-list&lt;/var&gt; &lt;var&gt;Type&lt;/var&gt; &amp;rdquo; ，则 &lt;code&gt;T D1&lt;/code&gt; 指定类型为&amp;ldquo; &lt;var&gt;derived-declarator-type-list&lt;/var&gt; - d &amp;rdquo; 类型列表 &lt;var&gt;type-qualifier-and-attribute-specifier-list&lt;/var&gt; 指向 &lt;var&gt;ident&lt;/var&gt; 的 &amp;ldquo; &lt;var&gt;Type&lt;/var&gt; &amp;rdquo;的指针。</target>
        </trans-unit>
        <trans-unit id="fdf6957ed3c287429ab808fa75095697e4d021d5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;DECL_ASSEMBLER_NAME&lt;/code&gt; has been set for a given decl, use that in the dump instead of &lt;code&gt;DECL_NAME&lt;/code&gt;. Its primary use is ease of use working backward from mangled names in the assembly file.</source>
          <target state="translated">如果已为给定的decl设置了 &lt;code&gt;DECL_ASSEMBLER_NAME&lt;/code&gt; ，请在转储中使用它而不是 &lt;code&gt;DECL_NAME&lt;/code&gt; 。它的主要用途是易于使用，从汇编文件中的错误名称向后进行操作。</target>
        </trans-unit>
        <trans-unit id="647ff2c6b0ee66be47ceb0fe277c3fe135fc84e9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;GCC_EXEC_PREFIX&lt;/code&gt; is not set, GCC attempts to figure out an appropriate prefix to use based on the pathname it is invoked with.</source>
          <target state="translated">如果未设置 &lt;code&gt;GCC_EXEC_PREFIX&lt;/code&gt; ，则GCC会根据调用它的路径名尝试找出要使用的适当前缀。</target>
        </trans-unit>
        <trans-unit id="7fc3d06e6177481bf26c022c74076e71f4e1f421" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;GCC_EXEC_PREFIX&lt;/code&gt; is set, it specifies a prefix to use in the names of the subprograms executed by the compiler. No slash is added when this prefix is combined with the name of a subprogram, but you can specify a prefix that ends with a slash if you wish.</source>
          <target state="translated">如果设置了 &lt;code&gt;GCC_EXEC_PREFIX&lt;/code&gt; ，则它指定要在编译器执行的子程序名称中使用的前缀。当该前缀与子程序的名称结合使用时，不会添加任何斜杠，但是如果需要，您可以指定以斜杠结尾的前缀。</target>
        </trans-unit>
        <trans-unit id="dec8a7933acf37b1c0fdc778b779b3f382d54a7a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;LANG&lt;/code&gt; is not defined, or if it has some other value, then the compiler uses &lt;code&gt;mblen&lt;/code&gt; and &lt;code&gt;mbtowc&lt;/code&gt; as defined by the default locale to recognize and translate multibyte characters.</source>
          <target state="translated">如果未定义 &lt;code&gt;LANG&lt;/code&gt; 或具有其他值，则编译器将使用默认语言环境定义的 &lt;code&gt;mblen&lt;/code&gt; 和 &lt;code&gt;mbtowc&lt;/code&gt; 来识别和转换多字节字符。</target>
        </trans-unit>
        <trans-unit id="e1943099aece965452d744a5c53ffc07f2bc9f16" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;S&lt;/code&gt; is given to GCC, substitutes &lt;code&gt;X&lt;/code&gt;; else if &lt;code&gt;T&lt;/code&gt; is given to GCC, substitutes &lt;code&gt;Y&lt;/code&gt;; else substitutes &lt;code&gt;D&lt;/code&gt;. There can be as many clauses as you need. This may be combined with &lt;code&gt;.&lt;/code&gt;, &lt;code&gt;,&lt;/code&gt;, &lt;code&gt;!&lt;/code&gt;, &lt;code&gt;|&lt;/code&gt;, and &lt;code&gt;*&lt;/code&gt; as needed.</source>
          <target state="translated">如果将 &lt;code&gt;S&lt;/code&gt; 赋予GCC，则替换 &lt;code&gt;X&lt;/code&gt; ；否则，如果将 &lt;code&gt;T&lt;/code&gt; 赋予T，则替换 &lt;code&gt;Y&lt;/code&gt; ；其他替代品 &lt;code&gt;D&lt;/code&gt; 。您可以根据需要设置任意多个子句。可以与结合使用 &lt;code&gt;.&lt;/code&gt; ， &lt;code&gt;,&lt;/code&gt; ， &lt;code&gt;!&lt;/code&gt; ， &lt;code&gt;|&lt;/code&gt; ，并根据需要添加 &lt;code&gt;*&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="404ec67951a627fb06995708ad6a0e24dc041fa8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;TMPDIR&lt;/code&gt; is set, it specifies the directory to use for temporary files. GCC uses temporary files to hold the output of one stage of compilation which is to be used as input to the next stage: for example, the output of the preprocessor, which is the input to the compiler proper.</source>
          <target state="translated">如果设置了 &lt;code&gt;TMPDIR&lt;/code&gt; ，它将指定用于临时文件的目录。GCC使用临时文件保存一个编译阶段的输出，该输出将用作下一阶段的输入：例如，预处理器的输出，这是编译器本身的输入。</target>
        </trans-unit>
        <trans-unit id="1953caa75083ee28850ca171a34b26fd4eb8373f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;__has_trivial_constructor (type)&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; then the trait is &lt;code&gt;true&lt;/code&gt;, else if &lt;code&gt;type&lt;/code&gt; is a cv class or union type (or array thereof) with a default constructor that is known not to throw an exception then the trait is &lt;code&gt;true&lt;/code&gt;, else it is &lt;code&gt;false&lt;/code&gt;. Requires: &lt;code&gt;type&lt;/code&gt; shall be a complete type, (possibly cv-qualified) &lt;code&gt;void&lt;/code&gt;, or an array of unknown bound.</source>
          <target state="translated">如果 &lt;code&gt;__has_trivial_constructor (type)&lt;/code&gt; 为 &lt;code&gt;true&lt;/code&gt; ,则特征为 &lt;code&gt;true&lt;/code&gt; ，否则，如果 &lt;code&gt;type&lt;/code&gt; 是具有默认构造函数的cv类或联合类型（或其数组），并且已知该构造函数不会引发异常，则trait为 &lt;code&gt;true&lt;/code&gt; ，否则为 &lt;code&gt;false&lt;/code&gt; 。要求： &lt;code&gt;type&lt;/code&gt; 应该是一个完整的类型，（可能是cv限定的） &lt;code&gt;void&lt;/code&gt; ，或者是一个未知范围的数组。</target>
        </trans-unit>
        <trans-unit id="763c1f95adec0e6f2c3d89c3c9b77ea1bcae352d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;__has_trivial_copy (type)&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; then the trait is &lt;code&gt;true&lt;/code&gt;, else if &lt;code&gt;type&lt;/code&gt; is a cv-qualified class or union type with copy constructors that are known not to throw an exception then the trait is &lt;code&gt;true&lt;/code&gt;, else it is &lt;code&gt;false&lt;/code&gt;. Requires: &lt;code&gt;type&lt;/code&gt; shall be a complete type, (possibly cv-qualified) &lt;code&gt;void&lt;/code&gt;, or an array of unknown bound.</source>
          <target state="translated">如果 &lt;code&gt;__has_trivial_copy (type)&lt;/code&gt; 为 &lt;code&gt;true&lt;/code&gt; ,则特征为 &lt;code&gt;true&lt;/code&gt; ，否则，如果 &lt;code&gt;type&lt;/code&gt; 是具有cv限定的类或具有复制构造函数的联合类型（已知不会抛出异常），则特征为 &lt;code&gt;true&lt;/code&gt; ，否则为 &lt;code&gt;false&lt;/code&gt; 。要求： &lt;code&gt;type&lt;/code&gt; 应该是一个完整的类型，（可能是cv限定的） &lt;code&gt;void&lt;/code&gt; ，或者是一个未知范围的数组。</target>
        </trans-unit>
        <trans-unit id="348b274e4746ccb17d0ad8ccc31192a6601178b6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;__is_class (type)&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt; then the trait is &lt;code&gt;false&lt;/code&gt;. Otherwise &lt;code&gt;type&lt;/code&gt; is considered empty if and only if: &lt;code&gt;type&lt;/code&gt; has no non-static data members, or all non-static data members, if any, are bit-fields of length 0, and &lt;code&gt;type&lt;/code&gt; has no virtual members, and &lt;code&gt;type&lt;/code&gt; has no virtual base classes, and &lt;code&gt;type&lt;/code&gt; has no base classes &lt;code&gt;base_type&lt;/code&gt; for which &lt;code&gt;__is_empty (base_type)&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;. Requires: &lt;code&gt;type&lt;/code&gt; shall be a complete type, (possibly cv-qualified) &lt;code&gt;void&lt;/code&gt;, or an array of unknown bound.</source>
          <target state="translated">如果 &lt;code&gt;__is_class (type)&lt;/code&gt; 为 &lt;code&gt;false&lt;/code&gt; ,则特征为 &lt;code&gt;false&lt;/code&gt; 。否则 &lt;code&gt;type&lt;/code&gt; 被认为是空当且仅当： &lt;code&gt;type&lt;/code&gt; 没有非静态数据成员，或所有的非静态数据成员，如果有的话，是一个长度为0的位字段，和 &lt;code&gt;type&lt;/code&gt; 没有虚成员， &lt;code&gt;type&lt;/code&gt; 没有虚基类，和 &lt;code&gt;type&lt;/code&gt; 没有基类 &lt;code&gt;base_type&lt;/code&gt; 为其 &lt;code&gt;__is_empty (base_type)&lt;/code&gt; 是 &lt;code&gt;false&lt;/code&gt; 。要求： &lt;code&gt;type&lt;/code&gt; 应该是一个完整的类型，（可能是cv限定的） &lt;code&gt;void&lt;/code&gt; ，或者是一个未知范围的数组。</target>
        </trans-unit>
        <trans-unit id="3fb256b452a67db2fcf29b7d6c9eb3c3b57425ef" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;__is_pod (type)&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;type&lt;/code&gt; is a reference type then the trait is &lt;code&gt;true&lt;/code&gt;, else if &lt;code&gt;type&lt;/code&gt; is a cv class or union type (or array thereof) with a trivial destructor ([class.dtor]) then the trait is &lt;code&gt;true&lt;/code&gt;, else it is &lt;code&gt;false&lt;/code&gt;. Requires: &lt;code&gt;type&lt;/code&gt; shall be a complete type, (possibly cv-qualified) &lt;code&gt;void&lt;/code&gt;, or an array of unknown bound.</source>
          <target state="translated">如果 &lt;code&gt;__is_pod (type)&lt;/code&gt; 为 &lt;code&gt;true&lt;/code&gt; 或 &lt;code&gt;type&lt;/code&gt; 为引用类型，则特征为 &lt;code&gt;true&lt;/code&gt; ，否则，如果 &lt;code&gt;type&lt;/code&gt; 为具有琐碎析构函数（[class.dtor]）的cv类或联合类型（或其数组），则特征为 &lt;code&gt;true&lt;/code&gt; 否则为 &lt;code&gt;false&lt;/code&gt; 。要求： &lt;code&gt;type&lt;/code&gt; 应该是一个完整的类型，（可能是cv限定的） &lt;code&gt;void&lt;/code&gt; ，或者是一个未知范围的数组。</target>
        </trans-unit>
        <trans-unit id="d1bf9587539b51be90adc4a1e785e99e947f0059" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;__is_pod (type)&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;type&lt;/code&gt; is a reference type then the trait is &lt;code&gt;true&lt;/code&gt;, else if &lt;code&gt;type&lt;/code&gt; is a cv class or union type with a trivial copy constructor ([class.copy]) then the trait is &lt;code&gt;true&lt;/code&gt;, else it is &lt;code&gt;false&lt;/code&gt;. Requires: &lt;code&gt;type&lt;/code&gt; shall be a complete type, (possibly cv-qualified) &lt;code&gt;void&lt;/code&gt;, or an array of unknown bound.</source>
          <target state="translated">如果 &lt;code&gt;__is_pod (type)&lt;/code&gt; 是 &lt;code&gt;true&lt;/code&gt; 或 &lt;code&gt;type&lt;/code&gt; 是引用类型，则trait是 &lt;code&gt;true&lt;/code&gt; ，否则，如果 &lt;code&gt;type&lt;/code&gt; 是具有简单复制构造函数（[class.copy]）的cv类或联合类型，则trait是 &lt;code&gt;true&lt;/code&gt; ，否则是 &lt;code&gt;false&lt;/code&gt; 。要求： &lt;code&gt;type&lt;/code&gt; 应该是一个完整的类型，（可能是cv限定的） &lt;code&gt;void&lt;/code&gt; ，或者是一个未知范围的数组。</target>
        </trans-unit>
        <trans-unit id="2f38bb6a2ade7b8693787a1194261c7451943ac5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;__is_pod (type)&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; then the trait is &lt;code&gt;true&lt;/code&gt;, else if &lt;code&gt;type&lt;/code&gt; is a cv-qualified class or union type (or array thereof) with a trivial default constructor ([class.ctor]) then the trait is &lt;code&gt;true&lt;/code&gt;, else it is &lt;code&gt;false&lt;/code&gt;. Requires: &lt;code&gt;type&lt;/code&gt; shall be a complete type, (possibly cv-qualified) &lt;code&gt;void&lt;/code&gt;, or an array of unknown bound.</source>
          <target state="translated">如果 &lt;code&gt;__is_pod (type)&lt;/code&gt; 为 &lt;code&gt;true&lt;/code&gt; ,则特征为 &lt;code&gt;true&lt;/code&gt; ，否则，如果 &lt;code&gt;type&lt;/code&gt; 是具有普通构造函数（[class.ctor]）的cv限定类或联合类型（或其数组），则特征为 &lt;code&gt;true&lt;/code&gt; ，否则它为true是 &lt;code&gt;false&lt;/code&gt; 。要求： &lt;code&gt;type&lt;/code&gt; 应该是一个完整的类型，（可能是cv限定的） &lt;code&gt;void&lt;/code&gt; ，或者是一个未知范围的数组。</target>
        </trans-unit>
        <trans-unit id="d19955ce7ffa6060ce61b406573fd7fa063dda62" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;base_type&lt;/code&gt; is a base class of &lt;code&gt;derived_type&lt;/code&gt; ([class.derived]) then the trait is &lt;code&gt;true&lt;/code&gt;, otherwise it is &lt;code&gt;false&lt;/code&gt;. Top-level cv-qualifications of &lt;code&gt;base_type&lt;/code&gt; and &lt;code&gt;derived_type&lt;/code&gt; are ignored. For the purposes of this trait, a class type is considered is own base. Requires: if &lt;code&gt;__is_class (base_type)&lt;/code&gt; and &lt;code&gt;__is_class (derived_type)&lt;/code&gt; are &lt;code&gt;true&lt;/code&gt; and &lt;code&gt;base_type&lt;/code&gt; and &lt;code&gt;derived_type&lt;/code&gt; are not the same type (disregarding cv-qualifiers), &lt;code&gt;derived_type&lt;/code&gt; shall be a complete type. A diagnostic is produced if this requirement is not met.</source>
          <target state="translated">如果 &lt;code&gt;base_type&lt;/code&gt; 是 &lt;code&gt;derived_type&lt;/code&gt; （[class.derived]）的基类，则特征为 &lt;code&gt;true&lt;/code&gt; ，否则为 &lt;code&gt;false&lt;/code&gt; 。 &lt;code&gt;base_type&lt;/code&gt; 和 &lt;code&gt;derived_type&lt;/code&gt; 的顶级简历资格将被忽略。出于此特征的目的，将类类型视为自己的基础。要求：如果 &lt;code&gt;__is_class (base_type)&lt;/code&gt; 和 &lt;code&gt;__is_class (derived_type)&lt;/code&gt; 为 &lt;code&gt;true&lt;/code&gt; ,并且 &lt;code&gt;base_type&lt;/code&gt; 和 &lt;code&gt;derived_type&lt;/code&gt; 不是同一类型（不考虑cv限定词），则 &lt;code&gt;derived_type&lt;/code&gt; 应为完整类型。如果不满足此要求，则会生成诊断。</target>
        </trans-unit>
        <trans-unit id="9ad52c7e701f6b6ac16fc011e5c3a814b836cace" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;objc_msg_lookup()&lt;/code&gt; does not find a suitable method implementation, because the receiver does not implement the required method, it tries to see if the class can dynamically register the method.</source>
          <target state="translated">如果 &lt;code&gt;objc_msg_lookup()&lt;/code&gt; 未找到合适的方法实现，因为接收方未实现所需的方法，它将尝试查看该类是否可以动态注册该方法。</target>
        </trans-unit>
        <trans-unit id="de0324724a4ecec17009f5551872ea4de764d9cf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;packed&lt;/code&gt; is used on a structure, or if bit-fields are used, it may be that the Microsoft ABI lays out the structure differently than the way GCC normally does. Particularly when moving packed data between functions compiled with GCC and the native Microsoft compiler (either via function call or as data in a file), it may be necessary to access either format.</source>
          <target state="translated">如果在结构上使用 &lt;code&gt;packed&lt;/code&gt; 或使用位字段，则可能是Microsoft ABI对结构的布局不同于GCC正常进行的布局。特别是在通过GCC编译的函数和本机Microsoft编译器之间（通过函数调用或作为文件中的数据）在移动打包数据时，可能需要访问这两种格式。</target>
        </trans-unit>
        <trans-unit id="6f7ba7dbf5e57d92bfe72102ff6203af39a12a8c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;signed&lt;/code&gt; or &lt;code&gt;unsigned&lt;/code&gt; is omitted, the signedness of the vector type is the default signedness of the base type. The default varies depending on the operating system, so a portable program should always specify the signedness.</source>
          <target state="translated">如果省略有 &lt;code&gt;signed&lt;/code&gt; 或 &lt;code&gt;unsigned&lt;/code&gt; ，则向量类型的有符号性是基本类型的默认有符号性。默认值因操作系统而异，因此可移植程序应始终指定签名。</target>
        </trans-unit>
        <trans-unit id="ffd246c0a3fbb949c1fa9d8cc2260944e77a3bfb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;type&lt;/code&gt; is &lt;code&gt;const&lt;/code&gt;- qualified or is a reference type then the trait is &lt;code&gt;false&lt;/code&gt;. Otherwise if &lt;code&gt;__is_pod (type)&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; then the trait is &lt;code&gt;true&lt;/code&gt;, else if &lt;code&gt;type&lt;/code&gt; is a cv-qualified class or union type with a trivial copy assignment ([class.copy]) then the trait is &lt;code&gt;true&lt;/code&gt;, else it is &lt;code&gt;false&lt;/code&gt;. Requires: &lt;code&gt;type&lt;/code&gt; shall be a complete type, (possibly cv-qualified) &lt;code&gt;void&lt;/code&gt;, or an array of unknown bound.</source>
          <target state="translated">如果 &lt;code&gt;type&lt;/code&gt; 为 &lt;code&gt;const&lt;/code&gt; 限定或为引用类型，则特征为 &lt;code&gt;false&lt;/code&gt; 。否则，如果 &lt;code&gt;__is_pod (type)&lt;/code&gt; 为 &lt;code&gt;true&lt;/code&gt; ,则特征为 &lt;code&gt;true&lt;/code&gt; ；否则，如果 &lt;code&gt;type&lt;/code&gt; 是具有cv限定资格的类或联合类型且具有琐碎的拷贝分配（[class.copy]），则特征为 &lt;code&gt;true&lt;/code&gt; ，否则为 &lt;code&gt;false&lt;/code&gt; 。要求： &lt;code&gt;type&lt;/code&gt; 应该是一个完整的类型，（可能是cv限定的） &lt;code&gt;void&lt;/code&gt; ，或者是一个未知范围的数组。</target>
        </trans-unit>
        <trans-unit id="283cf2672e55770fc0551d9647cca120a4bb630b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;type&lt;/code&gt; is &lt;code&gt;const&lt;/code&gt;-qualified or is a reference type then the trait is &lt;code&gt;false&lt;/code&gt;. Otherwise if &lt;code&gt;__has_trivial_assign (type)&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; then the trait is &lt;code&gt;true&lt;/code&gt;, else if &lt;code&gt;type&lt;/code&gt; is a cv-qualified class or union type with copy assignment operators that are known not to throw an exception then the trait is &lt;code&gt;true&lt;/code&gt;, else it is &lt;code&gt;false&lt;/code&gt;. Requires: &lt;code&gt;type&lt;/code&gt; shall be a complete type, (possibly cv-qualified) &lt;code&gt;void&lt;/code&gt;, or an array of unknown bound.</source>
          <target state="translated">如果 &lt;code&gt;type&lt;/code&gt; 为 &lt;code&gt;const&lt;/code&gt; 限定或为引用类型，则trait为 &lt;code&gt;false&lt;/code&gt; 。否则，如果 &lt;code&gt;__has_trivial_assign (type)&lt;/code&gt; 为 &lt;code&gt;true&lt;/code&gt; ,则特征为 &lt;code&gt;true&lt;/code&gt; ；否则，如果 &lt;code&gt;type&lt;/code&gt; 是具有副本赋值运算符的cv限定类或联合类型，并且已知不会抛出异常，则该特征为 &lt;code&gt;true&lt;/code&gt; ，否则为 &lt;code&gt;false&lt;/code&gt; 。要求： &lt;code&gt;type&lt;/code&gt; 应该是一个完整的类型，（可能是cv限定的） &lt;code&gt;void&lt;/code&gt; ，或者是一个未知范围的数组。</target>
        </trans-unit>
        <trans-unit id="63c11c8bb0212d553ee20398c564d16b6ec7e69f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;type&lt;/code&gt; is a class type with a virtual destructor ([class.dtor]) then the trait is &lt;code&gt;true&lt;/code&gt;, else it is &lt;code&gt;false&lt;/code&gt;. Requires: &lt;code&gt;type&lt;/code&gt; shall be a complete type, (possibly cv-qualified) &lt;code&gt;void&lt;/code&gt;, or an array of unknown bound.</source>
          <target state="translated">如果 &lt;code&gt;type&lt;/code&gt; 是具有虚拟析构函数（[class.dtor]）的类类型，则特征为 &lt;code&gt;true&lt;/code&gt; ，否则为 &lt;code&gt;false&lt;/code&gt; 。要求： &lt;code&gt;type&lt;/code&gt; 应该是一个完整的类型，（可能是cv限定的） &lt;code&gt;void&lt;/code&gt; ，或者是一个未知范围的数组。</target>
        </trans-unit>
        <trans-unit id="3c2e0cd65d0655c5ce8c12d2d2d4a097d810e389" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;type&lt;/code&gt; is a cv POD type ([basic.types]) then the trait is &lt;code&gt;true&lt;/code&gt;, else it is &lt;code&gt;false&lt;/code&gt;. Requires: &lt;code&gt;type&lt;/code&gt; shall be a complete type, (possibly cv-qualified) &lt;code&gt;void&lt;/code&gt;, or an array of unknown bound.</source>
          <target state="translated">如果 &lt;code&gt;type&lt;/code&gt; 是cv POD类型（[basic.types]），则特征为 &lt;code&gt;true&lt;/code&gt; ，否则为 &lt;code&gt;false&lt;/code&gt; 。要求： &lt;code&gt;type&lt;/code&gt; 应该是一个完整的类型，（可能是cv限定的） &lt;code&gt;void&lt;/code&gt; ，或者是一个未知范围的数组。</target>
        </trans-unit>
        <trans-unit id="723863e0b5a8fce8c661ff18582b201e84983629" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;type&lt;/code&gt; is a cv enumeration type ([basic.compound]) the trait is &lt;code&gt;true&lt;/code&gt;, else it is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;type&lt;/code&gt; 是cv枚举类型（[basic.compound]），则特征为 &lt;code&gt;true&lt;/code&gt; ，否则为 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6b7975a53cee041123902e4671962591f8c2cbd7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;type&lt;/code&gt; is a cv union type ([basic.compound]) the trait is &lt;code&gt;true&lt;/code&gt;, else it is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;type&lt;/code&gt; 是cv联合类型（[basic.compound]），则特征为 &lt;code&gt;true&lt;/code&gt; ，否则为 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="89ab4b13f03f8e9b77ccbec6378e569d290932f7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;type&lt;/code&gt; is a cv-qualified class type, and not a union type ([basic.compound]) the trait is &lt;code&gt;true&lt;/code&gt;, else it is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;type&lt;/code&gt; 是cv限定的类类型，而不是联合类型（[basic.compound]），则特征为 &lt;code&gt;true&lt;/code&gt; ，否则为 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d6c08c113aac15208c2698077a3dc6d2ee08e364" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;type&lt;/code&gt; is a literal type ([basic.types]) the trait is &lt;code&gt;true&lt;/code&gt;, else it is &lt;code&gt;false&lt;/code&gt;. Requires: &lt;code&gt;type&lt;/code&gt; shall be a complete type, (possibly cv-qualified) &lt;code&gt;void&lt;/code&gt;, or an array of unknown bound.</source>
          <target state="translated">如果 &lt;code&gt;type&lt;/code&gt; 是文字类型（[basic.types]），则特征为 &lt;code&gt;true&lt;/code&gt; ，否则为 &lt;code&gt;false&lt;/code&gt; 。要求： &lt;code&gt;type&lt;/code&gt; 应该是一个完整的类型，（可能是cv限定的） &lt;code&gt;void&lt;/code&gt; ，或者是一个未知范围的数组。</target>
        </trans-unit>
        <trans-unit id="44c42d9c3a648a4586d6d80ed2afeb43acc1f98c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;type&lt;/code&gt; is a polymorphic class ([class.virtual]) then the trait is &lt;code&gt;true&lt;/code&gt;, else it is &lt;code&gt;false&lt;/code&gt;. Requires: &lt;code&gt;type&lt;/code&gt; shall be a complete type, (possibly cv-qualified) &lt;code&gt;void&lt;/code&gt;, or an array of unknown bound.</source>
          <target state="translated">如果 &lt;code&gt;type&lt;/code&gt; 是多态类（[class.virtual]），则特征为 &lt;code&gt;true&lt;/code&gt; ，否则为 &lt;code&gt;false&lt;/code&gt; 。要求： &lt;code&gt;type&lt;/code&gt; 应该是一个完整的类型，（可能是cv限定的） &lt;code&gt;void&lt;/code&gt; ，或者是一个未知范围的数组。</target>
        </trans-unit>
        <trans-unit id="902c4582059f6f78c8c47e8d4db16bfd414011e3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;type&lt;/code&gt; is a standard-layout type ([basic.types]) the trait is &lt;code&gt;true&lt;/code&gt;, else it is &lt;code&gt;false&lt;/code&gt;. Requires: &lt;code&gt;type&lt;/code&gt; shall be a complete type, (possibly cv-qualified) &lt;code&gt;void&lt;/code&gt;, or an array of unknown bound.</source>
          <target state="translated">如果 &lt;code&gt;type&lt;/code&gt; 是标准布局类型（[basic.types]），则特征为 &lt;code&gt;true&lt;/code&gt; ，否则为 &lt;code&gt;false&lt;/code&gt; 。要求： &lt;code&gt;type&lt;/code&gt; 应该是一个完整的类型，（可能是cv限定的） &lt;code&gt;void&lt;/code&gt; ，或者是一个未知范围的数组。</target>
        </trans-unit>
        <trans-unit id="c53c71f1f92604372ad3a40e885b3e290ad04715" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;type&lt;/code&gt; is a trivial type ([basic.types]) the trait is &lt;code&gt;true&lt;/code&gt;, else it is &lt;code&gt;false&lt;/code&gt;. Requires: &lt;code&gt;type&lt;/code&gt; shall be a complete type, (possibly cv-qualified) &lt;code&gt;void&lt;/code&gt;, or an array of unknown bound.</source>
          <target state="translated">如果 &lt;code&gt;type&lt;/code&gt; 是琐碎的类型（[basic.types]），则特征为 &lt;code&gt;true&lt;/code&gt; ，否则为 &lt;code&gt;false&lt;/code&gt; 。要求： &lt;code&gt;type&lt;/code&gt; 应该是一个完整的类型，（可能是cv限定的） &lt;code&gt;void&lt;/code&gt; ，或者是一个未知范围的数组。</target>
        </trans-unit>
        <trans-unit id="ffe6e21bc41957ab0a00219c12663528f239f642" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;type&lt;/code&gt; is an abstract class ([class.abstract]) then the trait is &lt;code&gt;true&lt;/code&gt;, else it is &lt;code&gt;false&lt;/code&gt;. Requires: &lt;code&gt;type&lt;/code&gt; shall be a complete type, (possibly cv-qualified) &lt;code&gt;void&lt;/code&gt;, or an array of unknown bound.</source>
          <target state="translated">如果 &lt;code&gt;type&lt;/code&gt; 是抽象类（[class.abstract]），则特征为 &lt;code&gt;true&lt;/code&gt; ，否则为 &lt;code&gt;false&lt;/code&gt; 。要求： &lt;code&gt;type&lt;/code&gt; 应该是一个完整的类型，（可能是cv限定的） &lt;code&gt;void&lt;/code&gt; ，或者是一个未知范围的数组。</target>
        </trans-unit>
        <trans-unit id="911911ebb73f24baa4568a362dcf6545a5e8bd9f" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;X&lt;/var&gt; is &lt;code&gt;0xf&lt;/code&gt;, then the &lt;var&gt;n&lt;/var&gt;-th bit of &lt;var&gt;val&lt;/var&gt; is returned unaltered.</source>
          <target state="translated">如果 &lt;var&gt;X&lt;/var&gt; 为 &lt;code&gt;0xf&lt;/code&gt; ，则返回 &lt;var&gt;val&lt;/var&gt; 的第 &lt;var&gt;n&lt;/var&gt; 位不变。</target>
        </trans-unit>
        <trans-unit id="529d14d76239ac927a58af9240682db818e156fc" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;desired&lt;/var&gt; is written into &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt; then &lt;code&gt;true&lt;/code&gt; is returned and memory is affected according to the memory order specified by &lt;var&gt;success_memorder&lt;/var&gt;. There are no restrictions on what memory order can be used here.</source>
          <target state="translated">如果 &lt;var&gt;desired&lt;/var&gt; 将其写入 &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt; ,则返回 &lt;code&gt;true&lt;/code&gt; ，并且内存会根据 &lt;var&gt;success_memorder&lt;/var&gt; 指定的内存顺序受到影响。在这里可以使用什么存储顺序没有限制。</target>
        </trans-unit>
        <trans-unit id="90eefc597dfd05335fdc76d585991dd479f5699e" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;device&lt;/var&gt; is not a device but only a core architecture like &amp;lsquo;</source>
          <target state="translated">如果 &lt;var&gt;device&lt;/var&gt; 不是设备，而只是诸如&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="37aede7b841b819868fc3f607fc7588d32233439" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;exp1&lt;/var&gt; is returned, the return type is the same as &lt;var&gt;exp1&lt;/var&gt;&amp;rsquo;s type. Similarly, if &lt;var&gt;exp2&lt;/var&gt; is returned, its return type is the same as &lt;var&gt;exp2&lt;/var&gt;.</source>
          <target state="translated">如果返回 &lt;var&gt;exp1&lt;/var&gt; ，则返回类型与 &lt;var&gt;exp1&lt;/var&gt; 的类型相同。同样，如果返回 &lt;var&gt;exp2&lt;/var&gt; ，则其返回类型与 &lt;var&gt;exp2&lt;/var&gt; 相同。</target>
        </trans-unit>
        <trans-unit id="43726f9389a16cd86ccc87693856924d076a1cd7" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;file&lt;/var&gt; is</source>
          <target state="translated">如果 &lt;var&gt;file&lt;/var&gt; 是</target>
        </trans-unit>
        <trans-unit id="5b94a494d8a93062d1fb2f08cf22419880d46ae7" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;m&lt;/var&gt; is not specified, it defaults to &lt;var&gt;n&lt;/var&gt;.</source>
          <target state="translated">如果未指定 &lt;var&gt;m&lt;/var&gt; ，则默认为 &lt;var&gt;n&lt;/var&gt; 。</target>
        </trans-unit>
        <trans-unit id="96e30c03c390fa37f95beff815a87bdc5f2296a9" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;n&lt;/var&gt; is not specified or is zero, use a machine-dependent default which is very likely to be &amp;lsquo;</source>
          <target state="translated">如果未指定 &lt;var&gt;n&lt;/var&gt; 或为n，请使用与机器相关的默认值，该默认值很可能是'</target>
        </trans-unit>
        <trans-unit id="4f4c9abfe6823ac3226b1f95cfb68ae207a767d4" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;n&lt;/var&gt; is not specified or is zero, use a machine-dependent default.</source>
          <target state="translated">如果未指定 &lt;var&gt;n&lt;/var&gt; 或为n，则使用与机器有关的默认值。</target>
        </trans-unit>
        <trans-unit id="edea744d98224ea825d53a93f917e0198d6b4e4e" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;n&lt;/var&gt; is not specified or is zero, use a machine-dependent default. The maximum allowed &lt;var&gt;n&lt;/var&gt; option value is 65536.</source>
          <target state="translated">如果未指定 &lt;var&gt;n&lt;/var&gt; 或为n，则使用与机器有关的默认值。 &lt;var&gt;n&lt;/var&gt; 选项的最大允许值为65536。</target>
        </trans-unit>
        <trans-unit id="759dfcc7101124f098c766f1c7cd00bcc6b949db" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;options&lt;/var&gt; is omitted, it defaults to &amp;lsquo;</source>
          <target state="translated">如果省略 &lt;var&gt;options&lt;/var&gt; ，则默认为'</target>
        </trans-unit>
        <trans-unit id="4a58d0d422304ea0f155ce08523224eb514fe6b5" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;path&lt;/var&gt; is specified, GCC looks at the &lt;var&gt;path&lt;/var&gt; to find the profile feedback data files. See</source>
          <target state="translated">如果 &lt;var&gt;path&lt;/var&gt; 指定，GCC着眼于 &lt;var&gt;path&lt;/var&gt; 寻找配置文件反馈数据文件。看到</target>
        </trans-unit>
        <trans-unit id="424b9b0e5144f1c216be7ac998c97fd4f7a0b3fa" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;type&lt;/var&gt; is &amp;lsquo;</source>
          <target state="translated">如果 &lt;var&gt;type&lt;/var&gt; 为&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="a48f8bd6ddf94d7b46204690dc61b7e1c17bca21" translate="yes" xml:space="preserve">
          <source>If GCC cannot find the subprogram using the specified prefix, it tries looking in the usual places for the subprogram.</source>
          <target state="translated">如果GCC不能用指定的前缀找到子程序,它将尝试在通常的地方寻找子程序。</target>
        </trans-unit>
        <trans-unit id="49e516aa2892d9e488e19e4de501aef3c975c28a" translate="yes" xml:space="preserve">
          <source>If GCC was configured to use a GLIBC before 2.23, the built-in function &lt;code&gt;__builtin_cpu_is&lt;/code&gt; always returns a 0 and the compiler issues a warning.</source>
          <target state="translated">如果将GCC配置为在2.23之前使用GLIBC，则内置函数 &lt;code&gt;__builtin_cpu_is&lt;/code&gt; 始终返回0，并且编译器会发出警告。</target>
        </trans-unit>
        <trans-unit id="009bc2728024c27e5f3a38c77a771a92e70da809" translate="yes" xml:space="preserve">
          <source>If GCC was configured to use a GLIBC before 2.23, the built-in function &lt;code&gt;__builtin_cpu_suports&lt;/code&gt; always returns a 0 and the compiler issues a warning.</source>
          <target state="translated">如果将GCC配置为在2.23之前使用GLIBC，则内置函数 &lt;code&gt;__builtin_cpu_suports&lt;/code&gt; 始终返回0，并且编译器会发出警告。</target>
        </trans-unit>
        <trans-unit id="3d3dbe293db43d1939fa63d41a62ea0fb70dc054" translate="yes" xml:space="preserve">
          <source>If LTO encounters objects with C linkage declared with incompatible types in separate translation units to be linked together (undefined behavior according to ISO C99 6.2.7), a non-fatal diagnostic may be issued. The behavior is still undefined at run time. Similar diagnostics may be raised for other languages.</source>
          <target state="translated">如果LTO在单独的翻译单元中遇到用不兼容类型声明的C链接对象要链接在一起(根据ISO C99 6.2.7,行为未定义),可能会发出一个非致命的诊断。该行为在运行时仍未定义。对于其他语言,可能会发出类似的诊断。</target>
        </trans-unit>
        <trans-unit id="8064195381cae5ba1afd9e1080f901756518ee59" translate="yes" xml:space="preserve">
          <source>If SSE extensions are enabled, &lt;code&gt;V4SF&lt;/code&gt; is used for a vector of four 32-bit floating-point values. Some instructions use a vector of four 32-bit integers, these use &lt;code&gt;V4SI&lt;/code&gt;. Finally, some instructions operate on an entire vector register, interpreting it as a 128-bit integer, these use mode &lt;code&gt;TI&lt;/code&gt;.</source>
          <target state="translated">如果启用了SSE扩展， &lt;code&gt;V4SF&lt;/code&gt; 用于四个32位浮点值的向量。一些指令使用四个32位整数的向量，这些指令使用 &lt;code&gt;V4SI&lt;/code&gt; 。最后，一些指令对整个向量寄存器进行操作，将其解释为128位整数，这些指令使用模式 &lt;code&gt;TI&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c8aa3d549316941fe06d6dfd92787397e613a82c" translate="yes" xml:space="preserve">
          <source>If X is in the range 0&amp;hellip;7, then the &lt;var&gt;n&lt;/var&gt;-th result bit is set to the &lt;var&gt;X&lt;/var&gt;-th bit of &lt;var&gt;bits&lt;/var&gt;</source>
          <target state="translated">如果X的范围是0&amp;hellip;7，则将第 &lt;var&gt;n&lt;/var&gt; 个结果位设置为第 &lt;var&gt;X&lt;/var&gt; 个 &lt;var&gt;bits&lt;/var&gt;</target>
        </trans-unit>
        <trans-unit id="4795ba768ec1950f8dcd780b40f59791bb2c3400" translate="yes" xml:space="preserve">
          <source>If X is in the range 8&amp;hellip;&lt;code&gt;0xe&lt;/code&gt;, then the &lt;var&gt;n&lt;/var&gt;-th result bit is undefined.</source>
          <target state="translated">如果X的范围是8&amp;hellip; &lt;code&gt;0xe&lt;/code&gt; ，那么第 &lt;var&gt;n&lt;/var&gt; 个结果位是不确定的。</target>
        </trans-unit>
        <trans-unit id="77a0a28430753763f9053f0aed3455f25006e137" translate="yes" xml:space="preserve">
          <source>If a &lt;a href=&quot;named-address-spaces#AVR-Named-Address-Spaces&quot;&gt;named address space&lt;/a&gt; other than generic or &lt;code&gt;__flash&lt;/code&gt; is used, then &lt;code&gt;RAMPZ&lt;/code&gt; is set as needed before the operation.</source>
          <target state="translated">如果使用了通用或 &lt;code&gt;__flash&lt;/code&gt; 以外的&lt;a href=&quot;named-address-spaces#AVR-Named-Address-Spaces&quot;&gt;命名地址空间&lt;/a&gt;，则在操作之前根据需要设置 &lt;code&gt;RAMPZ&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e78a838d8422ed3d9e1991db7c391d81f3fd283d" translate="yes" xml:space="preserve">
          <source>If a class is declared to implement a protocol, a warning is issued for every method in the protocol that is not implemented by the class. The default behavior is to issue a warning for every method not explicitly implemented in the class, even if a method implementation is inherited from the superclass. If you use the</source>
          <target state="translated">如果一个类被声明实现了一个协议,那么对于协议中每一个没有被类实现的方法都会发出警告。默认的行为是为类中没有明确实现的每一个方法发出警告,即使一个方法的实现是从超类中继承的。如果你使用</target>
        </trans-unit>
        <trans-unit id="29f23802437b44fdcdb64561f47637459cfd3577" translate="yes" xml:space="preserve">
          <source>If a diagnostic contains fix-it hints, it has a &lt;code&gt;fixits&lt;/code&gt; array, consisting of half-open intervals, similar to the output of</source>
          <target state="translated">如果诊断程序包含fix-it提示，则它具有一个 &lt;code&gt;fixits&lt;/code&gt; 数组，该数组由半开间隔组成，类似于的输出。</target>
        </trans-unit>
        <trans-unit id="e94ab481666483b349181850cc8e39b26f438c5d" translate="yes" xml:space="preserve">
          <source>If a function returns a temporary &lt;code&gt;initializer_list&lt;/code&gt;, or a local &lt;code&gt;initializer_list&lt;/code&gt; variable, the array&amp;rsquo;s lifetime ends at the end of the return statement, so the value returned has a dangling pointer.</source>
          <target state="translated">如果函数返回临时的 &lt;code&gt;initializer_list&lt;/code&gt; 或局部的 &lt;code&gt;initializer_list&lt;/code&gt; 变量，则数组的生存期在return语句的结尾处结束，因此返回的值具有悬空指针。</target>
        </trans-unit>
        <trans-unit id="51be4d38853f3a30d7f15e3610ea69ae54265c4e" translate="yes" xml:space="preserve">
          <source>If a loop iterates over an array with a variable stride, create another version of the loop that assumes the stride is always one. For example:</source>
          <target state="translated">如果一个循环在一个有变量跨度的数组上迭代,那么创建另一个版本的循环,假设跨度总是1。例如:如果在一个数组上迭代一个变量stride,那么创建另一个版本的循环,假设stride总是一。</target>
        </trans-unit>
        <trans-unit id="e603935699eb5e105e69e65a9021ca2022ac4213" translate="yes" xml:space="preserve">
          <source>If a new-expression creates an &lt;code&gt;initializer_list&lt;/code&gt;, the array only lives until the end of the enclosing full-expression, so the &lt;code&gt;initializer_list&lt;/code&gt; in the heap has a dangling pointer.</source>
          <target state="translated">如果new-expression创建了 &lt;code&gt;initializer_list&lt;/code&gt; ，则该数组仅生存到封闭的full-expression的末尾，因此堆中的 &lt;code&gt;initializer_list&lt;/code&gt; 具有悬空的指针。</target>
        </trans-unit>
        <trans-unit id="dcc181452125b891816dee9715c4c073b739c819" translate="yes" xml:space="preserve">
          <source>If a program must use a different C++ library and it&amp;rsquo;s not possible to do the final link using a C++ driver that uses that library by default, it is necessary to tell &lt;code&gt;g++&lt;/code&gt; the location and name of that library. It might also be necessary to specify different startup files and other runtime support libraries, and to suppress the use of GCC&amp;rsquo;s support libraries with one or more of the options</source>
          <target state="translated">如果程序必须使用其他C ++库，并且无法使用默认使用该库的C ++驱动程序进行最终链接，则必须告知 &lt;code&gt;g++&lt;/code&gt; 该库的位置和名称。可能还需要指定不同的启动文件和其他运行时支持库，并使用一个或多个选项来禁止使用GCC的支持库。</target>
        </trans-unit>
        <trans-unit id="e84c4785b4be9bc72195941ed1f8c2b45255457e" translate="yes" xml:space="preserve">
          <source>If a standard system include directory, or a directory specified with</source>
          <target state="translated">如果是标准的系统包含目录,或者是用</target>
        </trans-unit>
        <trans-unit id="5c3be2ab717ecd782733ce9b93456fcb31fc4af7" translate="yes" xml:space="preserve">
          <source>If a variable has the &lt;code&gt;below100&lt;/code&gt; attribute (&lt;code&gt;BELOW100&lt;/code&gt; is allowed also), GCC places the variable in the first 0x100 bytes of memory and use special opcodes to access it. Such variables are placed in either the &lt;code&gt;.bss_below100&lt;/code&gt; section or the &lt;code&gt;.data_below100&lt;/code&gt; section.</source>
          <target state="translated">如果变量具有 &lt;code&gt;below100&lt;/code&gt; 属性（也允许使用 &lt;code&gt;BELOW100&lt;/code&gt; ），则GCC会将变量放置在内存的前0x100字节中，并使用特殊的操作码进行访问。此类变量放在 &lt;code&gt;.bss_below100&lt;/code&gt; 节或 &lt;code&gt;.data_below100&lt;/code&gt; 节中。</target>
        </trans-unit>
        <trans-unit id="38c3454c59e77e91336081ab769819e7fd53ba65" translate="yes" xml:space="preserve">
          <source>If a zero-length bit-field follows a normal bit-field, the type of the zero-length bit-field may affect the alignment of the structure as whole. For example, &lt;code&gt;t2&lt;/code&gt; has a size of 4 bytes, since the zero-length bit-field follows a normal bit-field, and is of type short.</source>
          <target state="translated">如果零长度位域跟随正常位域，则零长度位域的类型可能会影响整个结构的对齐方式。例如， &lt;code&gt;t2&lt;/code&gt; 的大小为4个字节，这是因为零长度的位字段跟随普通的位字段，并且类型为short。</target>
        </trans-unit>
        <trans-unit id="3930dc0fc00c26bd7cfbb87588dd5cf1e2064acf" translate="yes" xml:space="preserve">
          <source>If a zero-length bit-field is inserted after a bit-field, &lt;code&gt;foo&lt;/code&gt;, and the alignment of the zero-length bit-field is greater than the member that follows it, &lt;code&gt;bar&lt;/code&gt;, &lt;code&gt;bar&lt;/code&gt; is aligned as the type of the zero-length bit-field.</source>
          <target state="translated">如果将零长度位域插入到位域 &lt;code&gt;foo&lt;/code&gt; 之后，并且零长度位域的对齐方式大于其后的成员 &lt;code&gt;bar&lt;/code&gt; ， &lt;code&gt;bar&lt;/code&gt; ，则将其对齐为零长度的类型。长度位字段。</target>
        </trans-unit>
        <trans-unit id="487b9fa86178ee0fe71d79bf284c4ff7466101a0" translate="yes" xml:space="preserve">
          <source>If a zero-length bit-field is inserted between two bit-fields that are normally coalesced, the bit-fields are not coalesced.</source>
          <target state="translated">如果在两个正常聚合的位字段之间插入一个零长度的位字段,则位字段不聚合。</target>
        </trans-unit>
        <trans-unit id="fce50e2e3a2f90483694041f1d50957c036fd376" translate="yes" xml:space="preserve">
          <source>If accessing any memory location is potentially unsafe when speculative execution is incorrect, then the code can be rewritten as</source>
          <target state="translated">如果在投机执行不正确的情况下,访问任何内存位置都是潜在的不安全的,那么可以将代码改写为</target>
        </trans-unit>
        <trans-unit id="19dee42123d1606545b47bdc1aee4dced42d70ef" translate="yes" xml:space="preserve">
          <source>If all calls to a given function are integrated, and the function is declared &lt;code&gt;static&lt;/code&gt;, then the function is normally not output as assembler code in its own right.</source>
          <target state="translated">如果集成了对给定函数的所有调用，并且将该函数声明为 &lt;code&gt;static&lt;/code&gt; ，则该函数通常不会单独以汇编代码的形式输出。</target>
        </trans-unit>
        <trans-unit id="6747ee18a18040e35fcb4f80dbfe422de83e0b1d" translate="yes" xml:space="preserve">
          <source>If an explicit version number is provided and</source>
          <target state="translated">如果提供了一个明确的版本号,并且</target>
        </trans-unit>
        <trans-unit id="2a42f93a55377bd2fb4570f085c309d8859bae77" translate="yes" xml:space="preserve">
          <source>If an instruction only takes Altivec registers, you do not want to use &lt;code&gt;%x&amp;lt;n&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">如果一条指令仅使用Altivec寄存器，则不希望使用 &lt;code&gt;%x&amp;lt;n&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="364981cd1f151ee605ed86bfcc1747b52ebe7a19" translate="yes" xml:space="preserve">
          <source>If any of</source>
          <target state="translated">如果有任何</target>
        </trans-unit>
        <trans-unit id="d4335275a2f1edfde414bbe1e986ac43ea3a56a9" translate="yes" xml:space="preserve">
          <source>If any of the enabled test conditions is true, the corresponding entry in the result vector is -1. Otherwise (all of the enabled test conditions are false), the corresponding entry of the result vector is 0.</source>
          <target state="translated">如果任何一个启用的测试条件为真,结果向量的相应条目为-1。否则(所有启用的测试条件都是假的),结果向量的相应条目为0。</target>
        </trans-unit>
        <trans-unit id="b0cb0b3f3853386544ffbd0fa1ea4935f0522535" translate="yes" xml:space="preserve">
          <source>If any of these options is used, then the linker is not run, and object file names should not be used as arguments. See &lt;a href=&quot;overall-options#Overall-Options&quot;&gt;Overall Options&lt;/a&gt;.</source>
          <target state="translated">如果使用这些选项中的任何一个，则不会运行链接器，并且不应将目标文件名用作参数。请参阅&lt;a href=&quot;overall-options#Overall-Options&quot;&gt;总体选项&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="66bff0fe442c04caa45d8e4b29fa05e61e69952b" translate="yes" xml:space="preserve">
          <source>If application code relies on copy-assignment, a user-defined copy-assignment operator removes any uncertainties. With such an operator, the application can define whether and how the virtual base subobject is assigned.</source>
          <target state="translated">如果应用程序代码依赖于复制分配,用户定义的复制分配操作符可以消除任何不确定性。有了这样的操作符,应用程序可以定义是否以及如何分配虚拟基础子对象。</target>
        </trans-unit>
        <trans-unit id="3e6fe2d65d6ae8e8dddd4d9d96db3ba491946874" translate="yes" xml:space="preserve">
          <source>If both &lt;code&gt;signal&lt;/code&gt; and &lt;code&gt;interrupt&lt;/code&gt; are specified for the same function, &lt;code&gt;signal&lt;/code&gt; is silently ignored.</source>
          <target state="translated">如果 &lt;code&gt;signal&lt;/code&gt; 和 &lt;code&gt;interrupt&lt;/code&gt; 都指定用于同一功能，则将忽略 &lt;code&gt;signal&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9edaf55b500443b684dd1328cbcf6a8752769f40" translate="yes" xml:space="preserve">
          <source>If both arguments are zero, hotpatching is disabled.</source>
          <target state="translated">如果两个参数都是0,则禁用热补丁。</target>
        </trans-unit>
        <trans-unit id="32b3bc364441ca8a7ce5db371cd86527cc2b0b55" translate="yes" xml:space="preserve">
          <source>If both the template and enclosing class have explicit visibility, the visibility from the template is used.</source>
          <target state="translated">如果模板和包围类都有显式可见性,则使用模板的可见性。</target>
        </trans-unit>
        <trans-unit id="02529d20c3d2e23aefd28ee9dcdbc7281d16eb72" translate="yes" xml:space="preserve">
          <source>If combined with</source>
          <target state="translated">如果结合</target>
        </trans-unit>
        <trans-unit id="af3104b1407804a82ad43f4fa2a84131be37f920" translate="yes" xml:space="preserve">
          <source>If control flow reaches the point of the &lt;code&gt;__builtin_unreachable&lt;/code&gt;, the program is undefined. It is useful in situations where the compiler cannot deduce the unreachability of the code.</source>
          <target state="translated">如果控制流到达 &lt;code&gt;__builtin_unreachable&lt;/code&gt; 的点，则该程序未定义。在编译器无法推断代码无法到达的情况下，此方法很有用。</target>
        </trans-unit>
        <trans-unit id="36b8c90f4b777d0cb2020f4d21e6ac15532c3ad9" translate="yes" xml:space="preserve">
          <source>If debugging information is output when using the precompiled header, using</source>
          <target state="translated">如果使用预编译头时输出调试信息,使用</target>
        </trans-unit>
        <trans-unit id="402b191a6d5b620de512d8843ce1f34d7777a814" translate="yes" xml:space="preserve">
          <source>If either of the ways of changing the assembly name of a declaration are applied to a declaration whose assembly name has already been determined (either by a previous use of one of these features, or because the compiler needed the assembly name in order to generate code), and the new name is different, a warning issues and the name does not change.</source>
          <target state="translated">如果改变声明的汇编名的任何一种方式被应用到一个已经确定了汇编名的声明上(或者是通过以前对这些特性之一的使用,或者是因为编译器需要汇编名来生成代码),而新的名称是不同的,那么就会发出一个警告,并且名称不会改变。</target>
        </trans-unit>
        <trans-unit id="8e6cf380114ced6b961e13544b6be03dfc3354e5" translate="yes" xml:space="preserve">
          <source>If enabled, control-speculative instructions are chosen for schedule only if there are no other choices at the moment. This makes the use of the control speculation much more conservative. The default setting is disabled.</source>
          <target state="translated">如果启用,只有在当前没有其他选择的情况下,才会选择控制投机指令进行调度。这使得控制推测的使用更加保守。默认设置为禁用。</target>
        </trans-unit>
        <trans-unit id="c9aeee8753743f519ff715357d9285071a0d9d86" translate="yes" xml:space="preserve">
          <source>If enabled, data-speculative instructions are chosen for schedule only if there are no other choices at the moment. This makes the use of the data speculation much more conservative. The default setting is disabled.</source>
          <target state="translated">如果启用,只有在当前没有其他选择的情况下,才会选择数据投机指令进行调度。这使得数据推测的使用更加保守。默认设置为禁用。</target>
        </trans-unit>
        <trans-unit id="12c5281bb30137f5a28029f336bddc2453ae8835" translate="yes" xml:space="preserve">
          <source>If enabled, speculative dependencies are considered during computation of the instructions priorities. This makes the use of the speculation a bit more conservative. The default setting is disabled.</source>
          <target state="translated">如果启用,在计算指令优先级的过程中会考虑推测依赖性。这使得推测的使用更加保守一些。默认设置为禁用。</target>
        </trans-unit>
        <trans-unit id="9d63d7ff73f8a910b7cb613706af4cc8bb2d95b9" translate="yes" xml:space="preserve">
          <source>If enabled, the maximum amount of space required for outgoing arguments is computed in the function prologue. This is faster on most modern CPUs because of reduced dependencies, improved scheduling and reduced stack usage when the preferred stack boundary is not equal to 2. The drawback is a notable increase in code size. This switch implies</source>
          <target state="translated">如果启用,则在函数prologue中计算出出站参数所需的最大空间。这在大多数现代CPU上速度更快,因为减少了依赖性,改进了调度,当首选堆栈边界不等于2时,减少了堆栈的使用。 缺点是代码大小明显增加。这种切换意味着</target>
        </trans-unit>
        <trans-unit id="40d23331ec805b8693bd0e7ed41af8f41bbbeef4" translate="yes" xml:space="preserve">
          <source>If functions are defined in one file and are called in another file, then be sure to write this declaration in both files.</source>
          <target state="translated">如果在一个文件中定义了函数,并在另一个文件中被调用,那么一定要在两个文件中写下这个声明。</target>
        </trans-unit>
        <trans-unit id="5a84ad9332942b0583d76324d55388fa827b1dc5" translate="yes" xml:space="preserve">
          <source>If it is a scalar type, or on most targets an aggregate type whose only member object is of a scalar type, or a union type whose member objects are of scalar types, the expression is interpreted by GCC as a read of the volatile object; in the other cases, the expression is only evaluated for its side effects.</source>
          <target state="translated">如果它是一个标量类型,或者在大多数目标上是一个集合类型,其唯一的成员对象是标量类型,或者是一个联合类型,其成员对象是标量类型,该表达式被GCC解释为对volatile对象的读取;在其他情况下,该表达式只对其副作用进行评估。</target>
        </trans-unit>
        <trans-unit id="79c1054be8ddf1396d899393bbaa81764a2eed88" translate="yes" xml:space="preserve">
          <source>If multiple</source>
          <target state="translated">如果多个</target>
        </trans-unit>
        <trans-unit id="e94921c7bd35daddf444608f5259a29f5f4c8cc8" translate="yes" xml:space="preserve">
          <source>If neither</source>
          <target state="translated">如果没有</target>
        </trans-unit>
        <trans-unit id="afb8c1ba0a7e5bf800f44e5494e9d700db801b00" translate="yes" xml:space="preserve">
          <source>If new system header files are installed, nothing automatically arranges to update the corrected header files. They can be updated using the &lt;code&gt;mkheaders&lt;/code&gt; script installed in</source>
          <target state="translated">如果安装了新的系统头文件，则不会自动安排任何操作来更新更正的头文件。可以使用安装在以下位置的 &lt;code&gt;mkheaders&lt;/code&gt; 脚本来更新它们</target>
        </trans-unit>
        <trans-unit id="b7def704de696eb922c5e5ba1f5217476d727ef7" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;NSFastEnumerationState&lt;/code&gt; is defined in your code, the compiler will automatically replace &lt;code&gt;NSFastEnumerationState *&lt;/code&gt; with &lt;code&gt;struct __objcFastEnumerationState *&lt;/code&gt;, where that type is silently defined by the compiler in an identical way. This can be confusing and we recommend that you define &lt;code&gt;NSFastEnumerationState&lt;/code&gt; (as shown above) instead.</source>
          <target state="translated">如果没有 &lt;code&gt;NSFastEnumerationState&lt;/code&gt; 在你的代码中定义，编译器会自动更换 &lt;code&gt;NSFastEnumerationState *&lt;/code&gt; 与 &lt;code&gt;struct __objcFastEnumerationState *&lt;/code&gt; ，其中，该类型是由编译器以相同的方式默默的定义。这可能会造成混淆，建议您 &lt;code&gt;NSFastEnumerationState&lt;/code&gt; 定义NSFastEnumerationState（如上所示）。</target>
        </trans-unit>
        <trans-unit id="089bb39031737c14c4b1a0b430296a1926daaea0" translate="yes" xml:space="preserve">
          <source>If no &lt;var&gt;arg-index&lt;/var&gt; is given to the &lt;code&gt;nonnull&lt;/code&gt; attribute, all pointer arguments are marked as non-null. To illustrate, the following declaration is equivalent to the previous example:</source>
          <target state="translated">如果未将 &lt;var&gt;arg-index&lt;/var&gt; 赋予 &lt;code&gt;nonnull&lt;/code&gt; 属性，则所有指针参数都标记为non-null。为了说明这一点，下面的声明与前面的示例等效：</target>
        </trans-unit>
        <trans-unit id="73b44337d5bc4559e8e1c4b6db36d411b8aef133" translate="yes" xml:space="preserve">
          <source>If no error occurs during compilation, run the compiler a second time, adding &lt;var&gt;opts&lt;/var&gt; and</source>
          <target state="translated">如果在编译过程中没有发生错误，请再次运行编译器，并添加 &lt;var&gt;opts&lt;/var&gt; 和</target>
        </trans-unit>
        <trans-unit id="0e662391588b3d6a0fd25b9abb8a35c922931e60" translate="yes" xml:space="preserve">
          <source>If no fixup is needed, this function simply passes through &lt;var&gt;addr&lt;/var&gt;.</source>
          <target state="translated">如果不需要修复，则此函数仅通过 &lt;var&gt;addr&lt;/var&gt; 传递。</target>
        </trans-unit>
        <trans-unit id="2c0304f8188faa2beb1f6913883824900b9fd415" translate="yes" xml:space="preserve">
          <source>If not otherwise specified by an attribute, assume all calls might be beyond the offset range of the &lt;code&gt;b&lt;/code&gt; / &lt;code&gt;bl&lt;/code&gt; instructions, and therefore load the function address into a register before performing a (otherwise direct) call. This is the default.</source>
          <target state="translated">如果没有通过属性另外指定，则假定所有调用都可能超出 &lt;code&gt;b&lt;/code&gt; / &lt;code&gt;bl&lt;/code&gt; 指令的偏移范围，因此在执行（否则直接调用）之前将函数地址加载到寄存器中。这是默认值。</target>
        </trans-unit>
        <trans-unit id="4019c8219c3b5cd2dda4dbb0cb3bf4c2a485adff" translate="yes" xml:space="preserve">
          <source>If not otherwise specified by an attribute, assume all direct calls are in the range of the &lt;code&gt;b&lt;/code&gt; / &lt;code&gt;bl&lt;/code&gt; instructions, so use these instructions for direct calls. The default is</source>
          <target state="translated">如果没有通过属性另外指定，则假定所有直接调用都在 &lt;code&gt;b&lt;/code&gt; / &lt;code&gt;bl&lt;/code&gt; 指令的范围内，因此请将这些指令用于直接调用。默认是</target>
        </trans-unit>
        <trans-unit id="12a28d9821da145a465f7298f6e4c4d208680d82" translate="yes" xml:space="preserve">
          <source>If number of memory accesses in function being instrumented is greater or equal to this number, use callbacks instead of inline checks. E.g. to disable inline code use</source>
          <target state="translated">如果被检测的函数的内存访问次数大于或等于这个数字,则使用回调代替内联检查。例如,如果要禁用内联代码,可以使用 &quot;回调 &quot;来代替内联检查。</target>
        </trans-unit>
        <trans-unit id="5104c1df665f6fc4dddeb5595f01af321de5cad6" translate="yes" xml:space="preserve">
          <source>If object files containing GIMPLE bytecode are stored in a library archive, say</source>
          <target state="translated">如果包含 GIMPLE 字节码的对象文件存储在库存档中,比如说</target>
        </trans-unit>
        <trans-unit id="1debeabea3e55864c791086673e07af5641e2395" translate="yes" xml:space="preserve">
          <source>If patchable function entries are enabled globally using the command-line option</source>
          <target state="translated">如果使用命令行选项全局启用了可打补丁的函数项</target>
        </trans-unit>
        <trans-unit id="7ae6684dfcfa35ba16cecacd5ec92f0fb9e0c04e" translate="yes" xml:space="preserve">
          <source>If profiling is active (</source>
          <target state="translated">如果剖析处于活动状态 (</target>
        </trans-unit>
        <trans-unit id="88f3c4dd1f2c3c978031ca46886480a0ad40a791" translate="yes" xml:space="preserve">
          <source>If supported by the target machine, generate instructions to prefetch memory to improve the performance of loops that access large arrays.</source>
          <target state="translated">如果目标机器支持,生成预取内存的指令,以提高访问大型数组的循环的性能。</target>
        </trans-unit>
        <trans-unit id="8bfe7e580871525d66e6234642f97096fcdef387" translate="yes" xml:space="preserve">
          <source>If supported for the target machine, attempt to reorder instructions to eliminate execution stalls due to required data being unavailable. This helps machines that have slow floating point or memory load instructions by allowing other instructions to be issued until the result of the load or floating-point instruction is required.</source>
          <target state="translated">如果目标机器支持,则尝试重新排序指令,以消除由于所需数据不可用而导致的执行停滞。这有助于那些浮点或内存加载指令速度较慢的机器,因为它允许发出其他指令,直到需要加载或浮点指令的结果。</target>
        </trans-unit>
        <trans-unit id="3428a2e4a1d11936eea0f07c36277bc2aa02d581" translate="yes" xml:space="preserve">
          <source>If supported for the target machine, attempt to reorder instructions to exploit instruction slots available after delayed branch instructions.</source>
          <target state="translated">如果目标机器支持,则尝试重新排序指令,以利用延迟分支指令后可用的指令槽。</target>
        </trans-unit>
        <trans-unit id="324f5e0a0812879119b6243a7b551f6c87385665" translate="yes" xml:space="preserve">
          <source>If supported for the target machine, emit position-independent code, suitable for dynamic linking and avoiding any limit on the size of the global offset table. This option makes a difference on AArch64, m68k, PowerPC and SPARC.</source>
          <target state="translated">如果目标机器支持,则发出与位置无关的代码,适用于动态链接,避免对全局偏移表的大小进行任何限制。这个选项在 AArch64、m68k、PowerPC 和 SPARC 上有区别。</target>
        </trans-unit>
        <trans-unit id="3d9b7696c9777c3fdef5f5f1690ef14ee23382d9" translate="yes" xml:space="preserve">
          <source>If the</source>
          <target state="translated">如果</target>
        </trans-unit>
        <trans-unit id="848af5bfa5ce573c8e5c9af3ee618628d308338c" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;LC_ALL&lt;/code&gt; environment variable is set, it overrides the value of &lt;code&gt;LC_CTYPE&lt;/code&gt; and &lt;code&gt;LC_MESSAGES&lt;/code&gt;; otherwise, &lt;code&gt;LC_CTYPE&lt;/code&gt; and &lt;code&gt;LC_MESSAGES&lt;/code&gt; default to the value of the &lt;code&gt;LANG&lt;/code&gt; environment variable. If none of these variables are set, GCC defaults to traditional C English behavior.</source>
          <target state="translated">如果设置了 &lt;code&gt;LC_ALL&lt;/code&gt; 环境变量，它将覆盖 &lt;code&gt;LC_CTYPE&lt;/code&gt; 和 &lt;code&gt;LC_MESSAGES&lt;/code&gt; 的值；否则， &lt;code&gt;LC_CTYPE&lt;/code&gt; 和 &lt;code&gt;LC_MESSAGES&lt;/code&gt; 默认为 &lt;code&gt;LANG&lt;/code&gt; 环境变量的值。如果未设置这些变量，则GCC默认为传统的C英语行为。</target>
        </trans-unit>
        <trans-unit id="927b034e0a10d14fe57f4acd375117bf77534e22" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;error&lt;/code&gt; or &lt;code&gt;warning&lt;/code&gt; attribute is used on a function declaration and a call to such a function is not eliminated through dead code elimination or other optimizations, an error or warning (respectively) that includes &lt;var&gt;message&lt;/var&gt; is diagnosed. This is useful for compile-time checking, especially together with &lt;code&gt;__builtin_constant_p&lt;/code&gt; and inline functions where checking the inline function arguments is not possible through &lt;code&gt;extern char [(condition) ? 1 : -1];&lt;/code&gt; tricks.</source>
          <target state="translated">如果在函数声明上使用了 &lt;code&gt;error&lt;/code&gt; 或 &lt;code&gt;warning&lt;/code&gt; 属性，并且没有通过消除无效代码或进行其他优化来消除了对该函数的调用，则会分别诊断出包含 &lt;var&gt;message&lt;/var&gt; 的错误或警告。这对于编译时检查很有用，特别是与 &lt;code&gt;__builtin_constant_p&lt;/code&gt; 和内联函数一起使用时，无法通过 &lt;code&gt;extern char [(condition) ? 1 : -1];&lt;/code&gt; 检查内联函数参数。1：-1]；技巧。</target>
        </trans-unit>
        <trans-unit id="20d0c6878745134aa8d904b0690e4fcbddc7d599" translate="yes" xml:space="preserve">
          <source>If the &lt;var&gt;filename&lt;/var&gt; is provided, then the dumps from all the applicable optimizations are concatenated into the &lt;var&gt;filename&lt;/var&gt;. Otherwise the dump is output onto</source>
          <target state="translated">如果提供了 &lt;var&gt;filename&lt;/var&gt; ，则来自所有适用优化的转储将串联到 &lt;var&gt;filename&lt;/var&gt; 。否则将转储输出到</target>
        </trans-unit>
        <trans-unit id="9215ad70f2e3e9c6cab1765215d93885159eaa97" translate="yes" xml:space="preserve">
          <source>If the C code that follows the &lt;code&gt;asm&lt;/code&gt; makes no use of any of the output operands, use &lt;code&gt;volatile&lt;/code&gt; for the &lt;code&gt;asm&lt;/code&gt; statement to prevent the optimizers from discarding the &lt;code&gt;asm&lt;/code&gt; statement as unneeded (see &lt;a href=&quot;#Volatile&quot;&gt;Volatile&lt;/a&gt;).</source>
          <target state="translated">如果 &lt;code&gt;asm&lt;/code&gt; 后面的C代码不使用任何输出操作数，则对 &lt;code&gt;asm&lt;/code&gt; 语句使用 &lt;code&gt;volatile&lt;/code&gt; 可以防止优化程序不必要地丢弃 &lt;code&gt;asm&lt;/code&gt; 语句（请参见&lt;a href=&quot;#Volatile&quot;&gt;Volatile&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="2aa76d6986dfd258dee402c2c95ca11459599c59" translate="yes" xml:space="preserve">
          <source>If the CPU is executing speculatively then either:</source>
          <target state="translated">如果CPU执行得很投机,那么无论是。</target>
        </trans-unit>
        <trans-unit id="8fe995e077eb81e27ea124938efd43a017d00001" translate="yes" xml:space="preserve">
          <source>If the CPU is not speculatively executing the code, then &lt;var&gt;val&lt;/var&gt; is returned.</source>
          <target state="translated">如果CPU没有以推测方式执行代码，则返回 &lt;var&gt;val&lt;/var&gt; 。</target>
        </trans-unit>
        <trans-unit id="c68ba352d7c54da4de70d37cd280b24a3feb4442" translate="yes" xml:space="preserve">
          <source>If the ISA 2.07 additions to the vector/scalar (power8-vector) instruction set are available, the following additional functions are available for 64-bit targets. New vector types (&lt;var&gt;vector __int128&lt;/var&gt; and &lt;var&gt;vector __uint128&lt;/var&gt;) are available to hold the &lt;var&gt;__int128&lt;/var&gt; and &lt;var&gt;__uint128&lt;/var&gt; types to use these builtins.</source>
          <target state="translated">如果对向量/标量（power8-vector）指令集增加了ISA 2.07，则以下附加功能可用于64位目标。新的向量类型（ &lt;var&gt;vector __int128&lt;/var&gt; 和 &lt;var&gt;vector __uint128&lt;/var&gt; ）可用于容纳 &lt;var&gt;__int128&lt;/var&gt; 和 &lt;var&gt;__uint128&lt;/var&gt; 类型以使用这些内置函数。</target>
        </trans-unit>
        <trans-unit id="7ad5ced5d695028f0b739572f683d981d7b325cd" translate="yes" xml:space="preserve">
          <source>If the ISA 2.07 additions to the vector/scalar (power8-vector) instruction set are available, the following additional functions are available for both 32-bit and 64-bit targets. For 64-bit targets, you can use &lt;var&gt;vector long&lt;/var&gt; instead of &lt;var&gt;vector long long&lt;/var&gt;, &lt;var&gt;vector bool long&lt;/var&gt; instead of &lt;var&gt;vector bool long long&lt;/var&gt;, and &lt;var&gt;vector unsigned long&lt;/var&gt; instead of &lt;var&gt;vector unsigned long long&lt;/var&gt;.</source>
          <target state="translated">如果对向量/标量（power8-vector）指令集增加了ISA 2.07，则以下附加功能可用于32位和64位目标。对于64位目标，可以使用 &lt;var&gt;vector long&lt;/var&gt; 代替 &lt;var&gt;vector long long&lt;/var&gt; ，使用 &lt;var&gt;vector bool long&lt;/var&gt; 代替 &lt;var&gt;vector bool long long&lt;/var&gt; ，使用 &lt;var&gt;vector unsigned long&lt;/var&gt; 代替 &lt;var&gt;vector unsigned long long&lt;/var&gt; 。</target>
        </trans-unit>
        <trans-unit id="c22a3317bedd3145de7eb3a31ecc603e64eb80be" translate="yes" xml:space="preserve">
          <source>If the ISA 3.0 instruction set additions (</source>
          <target state="translated">如果ISA 3.0指令集的添加(</target>
        </trans-unit>
        <trans-unit id="424b99254d8407b86c2beca1ac6e71a6fca8ab99" translate="yes" xml:space="preserve">
          <source>If the ISA 3.0 instruction set additions are enabled (</source>
          <target state="translated">如果启用ISA 3.0指令集添加(</target>
        </trans-unit>
        <trans-unit id="b3ba2117601e3a207db62aaa0d548209b490cb82" translate="yes" xml:space="preserve">
          <source>If the argument to the macro has variably modified type, it is evaluated only once when using &lt;code&gt;__auto_type&lt;/code&gt;, but twice if &lt;code&gt;typeof&lt;/code&gt; is used.</source>
          <target state="translated">如果参数给宏已可变类型，它使用时只计算一次 &lt;code&gt;__auto_type&lt;/code&gt; ，但如果两次 &lt;code&gt;typeof&lt;/code&gt; 被使用。</target>
        </trans-unit>
        <trans-unit id="e5db05160eb702af65a65d649789a2509aade574" translate="yes" xml:space="preserve">
          <source>If the attribute is specified and &lt;code&gt;#pragma omp declare simd&lt;/code&gt; is present on a declaration and the</source>
          <target state="translated">如果指定了属性，并且 &lt;code&gt;#pragma omp declare simd&lt;/code&gt; 出现在声明中，并且</target>
        </trans-unit>
        <trans-unit id="d120c6bfa80fbe55cec1d9862d7e2421db795ea2" translate="yes" xml:space="preserve">
          <source>If the compiler was built to use the system&amp;rsquo;s headers by default, then the default for this option is the system version on which the compiler is running, otherwise the default is to make choices that are compatible with as many systems and code bases as possible.</source>
          <target state="translated">如果默认情况下编译器被构建为使用系统的标头，则此选项的默认值为运行编译器的系统版本，否则默认为做出与尽可能多的系统和代码库兼容的选择。</target>
        </trans-unit>
        <trans-unit id="d67b52944ba9df1fde368725db64f0de08228c75" translate="yes" xml:space="preserve">
          <source>If the compiler&amp;rsquo;s optimization uses a function&amp;rsquo;s body or information extracted from its body to optimize/change another function, the latter is called an impacted function of the former. If a function is patched, its impacted functions should be patched too.</source>
          <target state="translated">如果编译器的优化使用函数的主体或从其主体中提取的信息来优化/更改另一个函数，则后者称为前者的受影响函数。如果对功能进行了修补，则其受影响的功能也应进行修补。</target>
        </trans-unit>
        <trans-unit id="b237760180d1507d3e5ec309754cc736d88da667" translate="yes" xml:space="preserve">
          <source>If the cryptographic instructions are enabled (</source>
          <target state="translated">如果启用了加密指令(</target>
        </trans-unit>
        <trans-unit id="4fb7464a62433bc1b1813aee95893c7c7b12fed7" translate="yes" xml:space="preserve">
          <source>If the device comes with a specific &lt;code&gt;RAMP&lt;/code&gt; register, the ISR prologue/epilogue saves/restores that SFR and initializes it with zero in case the ISR code might (implicitly) use it.</source>
          <target state="translated">如果设备带有特定的 &lt;code&gt;RAMP&lt;/code&gt; 寄存器，则ISR序言/结尾将保存/恢复SFR，并将其初始化为零，以防ISR代码可能（隐式）使用它。</target>
        </trans-unit>
        <trans-unit id="f359291701f84a5c952e96591467d10e46106142" translate="yes" xml:space="preserve">
          <source>If the device supports RAM larger than 64 KiB and the compiler needs to change &lt;code&gt;RAMPZ&lt;/code&gt; to accomplish an operation, &lt;code&gt;RAMPZ&lt;/code&gt; is reset to zero after the operation.</source>
          <target state="translated">如果设备支持大于64 KiB的RAM，并且编译器需要更改 &lt;code&gt;RAMPZ&lt;/code&gt; 才能完成操作，则操作后 &lt;code&gt;RAMPZ&lt;/code&gt; 会重置为零。</target>
        </trans-unit>
        <trans-unit id="4b99e2eb0f30f6704cb82d8729d610b9c040ff67" translate="yes" xml:space="preserve">
          <source>If the equal sign is omitted, the default</source>
          <target state="translated">如果省略等号,则默认为</target>
        </trans-unit>
        <trans-unit id="d2b152efe933ab511c3240207de045545a59413b" translate="yes" xml:space="preserve">
          <source>If the forwarding hook does not exist or returns &lt;code&gt;NULL&lt;/code&gt;, the runtime currently attempts forwarding using an older, deprecated API, and if that fails, it aborts the program. In future versions of the GNU Objective-C runtime, the runtime will immediately abort.</source>
          <target state="translated">如果转发钩子不存在或返回 &lt;code&gt;NULL&lt;/code&gt; ，则运行时当前会尝试使用旧的，已弃用的API进行转发，如果失败，它将中止程序。在将来的GNU Objective-C运行时版本中，运行时将立即终止。</target>
        </trans-unit>
        <trans-unit id="fb3ee17ffd6e7e71752206840400cc69026ba54d" translate="yes" xml:space="preserve">
          <source>If the function is called repeatedly with &lt;code&gt;untrusted_index&lt;/code&gt; less than the limit of 500, then a branch predictor will learn that the block of code that returns a value stored in &lt;code&gt;array&lt;/code&gt; will be executed. If the function is subsequently called with an out-of-range value it will still try to execute that block of code first until the CPU determines that the prediction was incorrect (the CPU will unwind any incorrect operations at that point). However, depending on how the result of the function is used, it might be possible to leave traces in the cache that can reveal what was stored at the out-of-bounds location. The built-in function can be used to provide some protection against leaking data in this way by changing the code to:</source>
          <target state="translated">如果使用 &lt;code&gt;untrusted_index&lt;/code&gt; 小于500的限制重复调用该函数，则分支预测器将获悉将执行返回存储在 &lt;code&gt;array&lt;/code&gt; 的值的代码块。如果随后使用超出范围的值调用该函数，它将仍然首先尝试执行该代码块，直到CPU确定预测不正确为止（此时，CPU将取消所有不正确的操作）。但是，根据函数结果的使用方式，可能会在缓存中留下一些痕迹，这些痕迹可以揭示出存储在越界位置的内容。通过将代码更改为以下内容，可以使用内置函数以这种方式提供一些保护，以防止数据泄漏：</target>
        </trans-unit>
        <trans-unit id="4966bfe90659d4fba00a57263dad419daa50166b" translate="yes" xml:space="preserve">
          <source>If the function is declared &lt;code&gt;extern&lt;/code&gt;, then this definition of the function is used only for inlining. In no case is the function compiled as a standalone function, not even if you take its address explicitly. Such an address becomes an external reference, as if you had only declared the function, and had not defined it. This has almost the effect of a macro. The way to use this is to put a function definition in a header file with this attribute, and put another copy of the function, without &lt;code&gt;extern&lt;/code&gt;, in a library file. The definition in the header file causes most calls to the function to be inlined. If any uses of the function remain, they refer to the single copy in the library. Note that the two definitions of the functions need not be precisely the same, although if they do not have the same effect your program may behave oddly.</source>
          <target state="translated">如果将函数声明为 &lt;code&gt;extern&lt;/code&gt; ，则此函数定义仅用于内联。绝对不会将函数编译为独立函数，即使您显式获取其地址也是如此。这样的地址将成为一个外部引用，就好像您仅声明了该函数而未定义它一样。这几乎具有宏的作用。使用此方法的方法是将函数定义放入具有此属性的头文件中，并放置函数的另一个副本，而无需 &lt;code&gt;extern&lt;/code&gt; ，在库文件中。头文件中的定义导致对函数的大多数调用被内联。如果仍然使用该功能，则它们引用库中的单个副本。请注意，函数的两个定义不必完全相同，尽管如果它们的效果不同，则您的程序可能会表现得很奇怪。</target>
        </trans-unit>
        <trans-unit id="b771c97ff2c33b584d16ad8091b88c7d383e2d71" translate="yes" xml:space="preserve">
          <source>If the function is inlined in several places, the block structure in each location might not be the same. For instance, a condition might now be calculable at compile time in some instances. Because the coverage of all the uses of the inline function will be shown for the same source lines, the line counts themselves might seem inconsistent.</source>
          <target state="translated">如果函数在多个地方内联,每个地方的块结构可能不一样。例如,在某些情况下,一个条件现在可能在编译时可以计算。因为内联函数的所有使用的覆盖范围将显示为相同的源行,所以行数本身可能看起来不一致。</target>
        </trans-unit>
        <trans-unit id="f54a0365a2045222faa9a6a632a364c211ec115e" translate="yes" xml:space="preserve">
          <source>If the function is not inlined, the compiler must emit an out of line copy of the function, in any object file that needs it. If</source>
          <target state="translated">如果函数没有内联,编译器必须在任何需要它的对象文件中,发出一个函数的外行副本。如果</target>
        </trans-unit>
        <trans-unit id="1d41e4e5598657e0dd5a304d5f9d42468e2c3eb3" translate="yes" xml:space="preserve">
          <source>If the hotpatch option is enabled, a &amp;ldquo;hot-patching&amp;rdquo; function prologue is generated for all functions in the compilation unit. The funtion label is prepended with the given number of two-byte NOP instructions (&lt;var&gt;pre-halfwords&lt;/var&gt;, maximum 1000000). After the label, 2 * &lt;var&gt;post-halfwords&lt;/var&gt; bytes are appended, using the largest NOP like instructions the architecture allows (maximum 1000000).</source>
          <target state="translated">如果启用了hotpatch选项，则会为编译单元中的所有功能生成一个&amp;ldquo;热补丁&amp;rdquo;功能序言。给功能标签加上给定数目的两字节NOP指令（ &lt;var&gt;pre-halfwords&lt;/var&gt; ，最大1000000）。标签之后，使用体系结构允许的最大NOP指令（最大1000000）附加2 * &lt;var&gt;post-halfwords&lt;/var&gt; 字节。</target>
        </trans-unit>
        <trans-unit id="1afbfd9c64402361ab2fa39f9fdbd1e3be8c266e" translate="yes" xml:space="preserve">
          <source>If the input program contains a function declaration such as:</source>
          <target state="translated">如果输入的程序包含一个函数声明,如:</target>
        </trans-unit>
        <trans-unit id="d87ca5a862edf69ec778f2863678b3c80b02aa1b" translate="yes" xml:space="preserve">
          <source>If the linker complains that an application is using too much small data, you might want to try rebuilding the less performance-critical parts with</source>
          <target state="translated">如果链接器抱怨应用程序使用了太多的小数据,你可能想尝试使用</target>
        </trans-unit>
        <trans-unit id="2bf1dd3a359ed16413542f38135a6d9bd4288cff" translate="yes" xml:space="preserve">
          <source>If the number of candidates in the set is smaller than this value, always try to remove unnecessary ivs from the set when adding a new one.</source>
          <target state="translated">如果集合中的候选人数量小于这个值,在添加新的候选人时,一定要尽量从集合中删除不必要的ivs。</target>
        </trans-unit>
        <trans-unit id="e7428a6a85aa26ccfc1d34f1f1cde51cd5cd4798" translate="yes" xml:space="preserve">
          <source>If the operand of &lt;code&gt;__alignof__&lt;/code&gt; is an lvalue rather than a type, its value is the required alignment for its type, taking into account any minimum alignment specified by attribute &lt;code&gt;aligned&lt;/code&gt; (see &lt;a href=&quot;common-variable-attributes#Common-Variable-Attributes&quot;&gt;Common Variable Attributes&lt;/a&gt;). For example, after this declaration:</source>
          <target state="translated">如果 &lt;code&gt;__alignof__&lt;/code&gt; 的操作数是左值而不是类型，则它的值是其类型所需的对齐方式，同时考虑到由属性 &lt;code&gt;aligned&lt;/code&gt; 指定的任何最小对齐方式（请参见&lt;a href=&quot;common-variable-attributes#Common-Variable-Attributes&quot;&gt;Common Variable Attributes&lt;/a&gt;）。例如，在此声明之后：</target>
        </trans-unit>
        <trans-unit id="a5fda9cca36b52c744155ff2696d3cbfb80c2db1" translate="yes" xml:space="preserve">
          <source>If the operand of the &lt;code&gt;__alignof__&lt;/code&gt; expression is a function, the expression evaluates to the alignment of the function which may be specified by attribute &lt;code&gt;aligned&lt;/code&gt; (see &lt;a href=&quot;common-function-attributes#Common-Function-Attributes&quot;&gt;Common Function Attributes&lt;/a&gt;).</source>
          <target state="translated">如果 &lt;code&gt;__alignof__&lt;/code&gt; 表达式的操作数是一个函数，则该表达式将求值该函数的对齐方式，该对齐方式可以由属性 &lt;code&gt;aligned&lt;/code&gt; 指定（请参见&lt;a href=&quot;common-function-attributes#Common-Function-Attributes&quot;&gt;Common Function Attributes&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="716641ab8a53f52206a358470c323b2f23eaf7fa" translate="yes" xml:space="preserve">
          <source>If the ratio of expression insertions to deletions is larger than this value for any expression, then RTL PRE inserts or removes the expression and thus leaves partially redundant computations in the instruction stream.</source>
          <target state="translated">如果对任何表达式来说,表达式插入与删除的比例大于这个值,那么RTL PRE就会插入或删除表达式,从而在指令流中留下部分冗余计算。</target>
        </trans-unit>
        <trans-unit id="05912318b76a1009d770bd192ecd133075c5fc90" translate="yes" xml:space="preserve">
          <source>If the register is a call-saved register, call ABI is affected: the register will not be restored in function epilogue sequences after the variable has been assigned. Therefore, functions cannot safely return to callers that assume standard ABI.</source>
          <target state="translated">如果寄存器是一个调用保存的寄存器,调用ABI就会受到影响:在变量被赋值后,寄存器在函数上句序列中不会被恢复。因此,函数不能安全地返回给假设标准ABI的调用者。</target>
        </trans-unit>
        <trans-unit id="9d80c0f0c0e0e7931ed927bbb4a8416d7ae0d80f" translate="yes" xml:space="preserve">
          <source>If the same field is initialized multiple times, or overlapping fields of a union are initialized, the value from the last initialization is used. When a field of a union is itself a structure, the entire structure from the last field initialized is used. If any previous initializer has side effect, it is unspecified whether the side effect happens or not. Currently, GCC discards the side-effecting initializer expressions and issues a warning.</source>
          <target state="translated">如果同一个字段被多次初始化,或者一个联合体的重叠字段被初始化,则使用最后一次初始化的值。当一个联合体的字段本身是一个结构体时,使用最后一次初始化的字段的整个结构体。如果之前的初始化器有副作用,那么副作用的发生与否是不明确的。目前,GCC会丢弃有副作用的初始化表达式并发出警告。</target>
        </trans-unit>
        <trans-unit id="60d643b079de10a712e4f0092195d4a678550bd1" translate="yes" xml:space="preserve">
          <source>If the second argument of a shift operation is within range, check that the result of a shift operation is not undefined. Note that what exactly is considered undefined differs slightly between C and C++, as well as between ISO C90 and C99, etc.</source>
          <target state="translated">如果移位操作的第二个参数在范围内,则检查移位操作的结果是否为未定义。需要注意的是,到底什么是未定义,在C和C++之间,以及ISO C90和C99等之间都略有不同。</target>
        </trans-unit>
        <trans-unit id="a31cdc2866161da54d441996165823d561084f93" translate="yes" xml:space="preserve">
          <source>If the selected floating-point hardware includes the NEON extension (e.g.</source>
          <target state="translated">如果所选的浮点硬件包含NEON扩展(如</target>
        </trans-unit>
        <trans-unit id="ba7e4ec3c7ed6c8b730bc79d728df15242bb6315" translate="yes" xml:space="preserve">
          <source>If the size of a local variable in bytes is smaller or equal to this number, directly poison (or unpoison) shadow memory instead of using run-time callbacks.</source>
          <target state="translated">如果一个局部变量的字节大小小于或等于这个数字,直接毒害(或解除毒害)影子内存,而不是使用运行时回调。</target>
        </trans-unit>
        <trans-unit id="417bd3fd4051d252d11a2c9158594ed0d6e39230" translate="yes" xml:space="preserve">
          <source>If the stack usage is (partly) dynamic and not bounded, it&amp;rsquo;s:</source>
          <target state="translated">如果堆栈使用情况（部分）是动态的且不受限制，则为：</target>
        </trans-unit>
        <trans-unit id="b6665e1bf11576c0ed34f60f152094f72a6d33b1" translate="yes" xml:space="preserve">
          <source>If the stack usage is (partly) dynamic but bounded, it&amp;rsquo;s:</source>
          <target state="translated">如果堆栈使用率是（部分）动态但有界的，则为：</target>
        </trans-unit>
        <trans-unit id="6185bf1adb7da0baa58ee0f68d56a9ef418a48d1" translate="yes" xml:space="preserve">
          <source>If the stack usage is fully static but exceeds the specified amount, it&amp;rsquo;s:</source>
          <target state="translated">如果堆栈使用情况是完全静态的，但超过了指定的数量，则为：</target>
        </trans-unit>
        <trans-unit id="d70267f0ff1a52892efb70d9a08fcf6abe326706" translate="yes" xml:space="preserve">
          <source>If the target does not require instruction cache flushes, &lt;code&gt;__builtin___clear_cache&lt;/code&gt; has no effect. Otherwise either instructions are emitted in-line to clear the instruction cache or a call to the &lt;code&gt;__clear_cache&lt;/code&gt; function in libgcc is made.</source>
          <target state="translated">如果目标不需要刷新指令高速缓存，则 &lt;code&gt;__builtin___clear_cache&lt;/code&gt; 无效。否则，将 &lt;code&gt;__clear_cache&lt;/code&gt; 方式发出指令以清除指令缓存，或者对libgcc中的__clear_cache函数进行调用。</target>
        </trans-unit>
        <trans-unit id="095e473e81d277e85bb1ebdb8df1dacc96479003" translate="yes" xml:space="preserve">
          <source>If the target does not support data prefetch, the address expression is evaluated if it includes side effects but no other code is generated and GCC does not issue a warning.</source>
          <target state="translated">如果目标不支持数据预取,如果地址表达式中包含副作用,则会对其进行评估,但不会生成其他代码,GCC也不会发出警告。</target>
        </trans-unit>
        <trans-unit id="063fcca71547a7fd5efc66500b8f981bd9c39ed3" translate="yes" xml:space="preserve">
          <source>If the target supports a BSS section, GCC by default puts variables that are initialized to zero into BSS. This can save space in the resulting code.</source>
          <target state="translated">如果目标支持BSS部分,GCC默认将初始化为0的变量放入BSS。这可以节省生成代码的空间。</target>
        </trans-unit>
        <trans-unit id="3918a65b7ea046bcd3f9722a5e8050706b67b421" translate="yes" xml:space="preserve">
          <source>If the transaction aborts, all side effects are undone and an abort code encoded as a bit mask is returned. The following macros are defined:</source>
          <target state="translated">如果交易中止,所有的副作用都被撤销,并返回一个以位掩码编码的中止代码。定义了以下宏。</target>
        </trans-unit>
        <trans-unit id="52878fb9a18ac14d0e8c56cabf2833c060108631" translate="yes" xml:space="preserve">
          <source>If the value in it has side effects, the side effects happen only once, not for each initialized field by the range initializer.</source>
          <target state="translated">如果其中的值有副作用,副作用只发生一次,而不是对每一个被范围初始化器初始化的字段。</target>
        </trans-unit>
        <trans-unit id="eea091306a656215179432ee609d12ba3a9d954d" translate="yes" xml:space="preserve">
          <source>If the value of &lt;code&gt;y&lt;/code&gt; is always 1, 2 or 3, then &lt;code&gt;x&lt;/code&gt; is always initialized, but GCC doesn&amp;rsquo;t know this. To suppress the warning, you need to provide a default case with assert(0) or similar code.</source>
          <target state="translated">如果 &lt;code&gt;y&lt;/code&gt; 的值始终是1、2或3，则 &lt;code&gt;x&lt;/code&gt; 总是被初始化，但是GCC不知道这一点。要取消显示警告，您需要提供一个带有assert（0）或类似代码的默认情况。</target>
        </trans-unit>
        <trans-unit id="6a0552d924c971b406818fb3dc8c14b487a51639" translate="yes" xml:space="preserve">
          <source>If the variable is referenced in inline assembly, the type of access must be provided to the compiler via constraints (see &lt;a href=&quot;constraints#Constraints&quot;&gt;Constraints&lt;/a&gt;). Accesses from basic asms are not supported.</source>
          <target state="translated">如果在内联汇编中引用了变量，则必须通过约束向编译器提供访问类型（请参见&lt;a href=&quot;constraints#Constraints&quot;&gt;Constraints&lt;/a&gt;）。不支持从基本asms访问。</target>
        </trans-unit>
        <trans-unit id="710a7177647056e46d73c6a14fa58cb0a4d39cb4" translate="yes" xml:space="preserve">
          <source>If there are no output operands but there are input operands, place two consecutive colons where the output operands would go:</source>
          <target state="translated">如果没有输出操作数,但有输入操作数,则将两个连续的冒号放在输出操作数的位置。</target>
        </trans-unit>
        <trans-unit id="ba1e7edd0bd3070d7470d6998361492b87d52104" translate="yes" xml:space="preserve">
          <source>If there is no pattern or mechanism to provide a lock-free instruction sequence, a call is made to an external routine with the same parameters to be resolved at run time.</source>
          <target state="translated">如果没有提供无锁指令序列的模式或机制,则调用外部例程,在运行时用相同的参数进行解析。</target>
        </trans-unit>
        <trans-unit id="76caf5beb996fc90102a47daa7e154a5cb406f3a" translate="yes" xml:space="preserve">
          <source>If these options are provided the S/390 back end emits additional instructions in the function prologue that trigger a trap if the stack size is &lt;var&gt;stack-guard&lt;/var&gt; bytes above the &lt;var&gt;stack-size&lt;/var&gt; (remember that the stack on S/390 grows downward). If the &lt;var&gt;stack-guard&lt;/var&gt; option is omitted the smallest power of 2 larger than the frame size of the compiled function is chosen. These options are intended to be used to help debugging stack overflow problems. The additionally emitted code causes only little overhead and hence can also be used in production-like systems without greater performance degradation. The given values have to be exact powers of 2 and &lt;var&gt;stack-size&lt;/var&gt; has to be greater than &lt;var&gt;stack-guard&lt;/var&gt; without exceeding 64k. In order to be efficient the extra code makes the assumption that the stack starts at an address aligned to the value given by &lt;var&gt;stack-size&lt;/var&gt;. The &lt;var&gt;stack-guard&lt;/var&gt; option can only be used in conjunction with &lt;var&gt;stack-size&lt;/var&gt;.</source>
          <target state="translated">如果提供这些选项的S / 390的后端射出在于触发如果堆栈尺寸是一个陷阱函数序言附加指令 &lt;var&gt;stack-guard&lt;/var&gt; 上述字节 &lt;var&gt;stack-size&lt;/var&gt; （记住，在S / 390的堆栈向下增长）。如果省略了 &lt;var&gt;stack-guard&lt;/var&gt; 选项，则选择比已编译函数的帧大小大2的最小幂。这些选项旨在用于帮助调试堆栈溢出问题。额外发出的代码仅引起很少的开销，因此也可以在类似生产的系统中使用，而不会造成更大的性能下降。给定的值必须是2的精确幂，并且 &lt;var&gt;stack-size&lt;/var&gt; 必须大于 &lt;var&gt;stack-guard&lt;/var&gt; 不超过64k。为了提高效率，额外的代码假设堆栈从与 &lt;var&gt;stack-size&lt;/var&gt; 给定值对齐的地址开始。所述 &lt;var&gt;stack-guard&lt;/var&gt; 选项只能在配合使用 &lt;var&gt;stack-size&lt;/var&gt; 。</target>
        </trans-unit>
        <trans-unit id="a905ee4ba472cb30116f3f77a848f112c04b6376" translate="yes" xml:space="preserve">
          <source>If this happens, you should recompile your code with</source>
          <target state="translated">如果发生这种情况,你应该用以下方法重新编译你的代码</target>
        </trans-unit>
        <trans-unit id="1cc1d69b5f6b24d749c4393c1e5384e6327ba002" translate="yes" xml:space="preserve">
          <source>If this option appears multiple times in the command line with different values specified, &amp;lsquo;</source>
          <target state="translated">如果此选项在命令行中多次出现且指定了不同的值，则&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="7d789a669772c260255b8f486a50720c5dbf98e3" translate="yes" xml:space="preserve">
          <source>If this option is disabled, the compiler uses the most efficient instruction. In the previous example, that might be a 32-bit load instruction, even though that accesses bytes that do not contain any portion of the bit-field, or memory-mapped registers unrelated to the one being updated.</source>
          <target state="translated">如果禁用这个选项,编译器就会使用效率最高的指令。在前面的例子中,这可能是一条32位的加载指令,尽管它访问的字节不包含位场的任何部分,或与被更新的寄存器无关的内存映射寄存器。</target>
        </trans-unit>
        <trans-unit id="eaaa3704bd89671f3908d72dc5973515cc911101" translate="yes" xml:space="preserve">
          <source>If this option is enabled, the compiler tries to avoid unnecessarily overaligning functions. It attempts to instruct the assembler to align by the amount specified by</source>
          <target state="translated">如果启用这个选项,编译器就会尝试避免不必要的过度对齐函数。它试图指示汇编器按照由</target>
        </trans-unit>
        <trans-unit id="7074bcc3f488dbf4492fda0d639c0f8273ca6d14" translate="yes" xml:space="preserve">
          <source>If this option is not provided but</source>
          <target state="translated">如果没有提供这一选项,但</target>
        </trans-unit>
        <trans-unit id="b89db9dde06a530a5dff7a4661614320224ef048" translate="yes" xml:space="preserve">
          <source>If this option is not used, the single-core application programming model is used.</source>
          <target state="translated">如果不使用该选项,则使用单核应用编程模型。</target>
        </trans-unit>
        <trans-unit id="58f2a7b1d53a81872af6e83acac9efe5419c83d5" translate="yes" xml:space="preserve">
          <source>If this option is set it also selects the type of hardware multiply support to use, unless this is overridden by an explicit</source>
          <target state="translated">如果设置了这个选项,它也会选择要使用的硬件乘法支持类型,除非这个选项被显式的</target>
        </trans-unit>
        <trans-unit id="13cec7c0becaf2d393aabd05cb427709a6c05830" translate="yes" xml:space="preserve">
          <source>If this option is used, the compiler will warn for declarations of variable-length arrays whose size is either unbounded, or bounded by an argument that allows the array size to exceed &lt;var&gt;byte-size&lt;/var&gt; bytes. This is similar to how</source>
          <target state="translated">如果使用此选项，则编译器将警告声明长度可变的数组，该数组的大小不受限制，或者由允许数组大小超过 &lt;var&gt;byte-size&lt;/var&gt; 字节的参数限制。这类似于</target>
        </trans-unit>
        <trans-unit id="c3115ee12356444486b8dfe277e34da87b4c9653" translate="yes" xml:space="preserve">
          <source>If this variable is set, its value specifies a UNIX timestamp to be used in replacement of the current date and time in the &lt;code&gt;__DATE__&lt;/code&gt; and &lt;code&gt;__TIME__&lt;/code&gt; macros, so that the embedded timestamps become reproducible.</source>
          <target state="translated">如果设置了此变量，则其值指定一个UNIX时间戳，用于替换 &lt;code&gt;__DATE__&lt;/code&gt; 和 &lt;code&gt;__TIME__&lt;/code&gt; 宏中的当前日期和时间，以便嵌入的时间戳可重现。</target>
        </trans-unit>
        <trans-unit id="9e2fd261f951c508769059b9f0362dce31b86177" translate="yes" xml:space="preserve">
          <source>If this variable is set, its value specifies how to output dependencies for Make based on the non-system header files processed by the compiler. System header files are ignored in the dependency output.</source>
          <target state="translated">如果设置了这个变量,它的值会指定如何根据编译器处理的非系统头文件来输出Make的依赖关系。系统头文件在依赖关系输出中会被忽略。</target>
        </trans-unit>
        <trans-unit id="a402efdff3876f11c94bdea172224e741634fd39" translate="yes" xml:space="preserve">
          <source>If used for a function, print the PLT suffix and generate PIC code. For example, emit &lt;code&gt;foo@PLT&lt;/code&gt; instead of &amp;rsquo;foo&amp;rsquo; for the function foo(). If used for a constant, drop all syntax-specific prefixes and issue the bare constant. See &lt;code&gt;p&lt;/code&gt; above.</source>
          <target state="translated">如果用于功能，请打印PLT后缀并生成PIC代码。例如，为函数foo（）发出 &lt;code&gt;foo@PLT&lt;/code&gt; 而不是'foo'。如果用于常量，则删除所有特定于语法的前缀并发出裸常量。参见上面的 &lt;code&gt;p&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0aee4afea693faf480212e1e7dfd95c798d52751" translate="yes" xml:space="preserve">
          <source>If you are invoking the preprocessor from a shell or shell-like program you may need to use the shell&amp;rsquo;s quoting syntax to protect characters such as spaces that have a meaning in the shell syntax.</source>
          <target state="translated">如果要从Shell或类似Shell的程序中调用预处理器，则可能需要使用Shell的引号语法来保护字符（例如在Shell语法中具有含义的空格）。</target>
        </trans-unit>
        <trans-unit id="12dd6be4f44a03f04923a3d7c38a665528824bfc" translate="yes" xml:space="preserve">
          <source>If you are not using a linker with plugin support and/or do not enable the linker plugin, then the objects inside</source>
          <target state="translated">如果你没有使用支持插件的链接器和/或没有启用链接器插件,那么在</target>
        </trans-unit>
        <trans-unit id="dadbd9ac438963390bc7bff3cc4c1fa602dc81f8" translate="yes" xml:space="preserve">
          <source>If you are not using some other optimization option, consider using</source>
          <target state="translated">如果您没有使用其他优化选项,可以考虑使用</target>
        </trans-unit>
        <trans-unit id="c0c121f354142152248081fdee3df09a5e0cff31" translate="yes" xml:space="preserve">
          <source>If you are using Cfront-model code, you can probably get away with not using</source>
          <target state="translated">如果你使用的是Cfront-model代码,你可能可以不使用</target>
        </trans-unit>
        <trans-unit id="670c5a80eac2c68f98a0b7952c25d85ec989c07c" translate="yes" xml:space="preserve">
          <source>If you are using a &amp;ldquo;Foundation&amp;rdquo; library such as GNUstep-Base, this library will provide you with a rich set of functionality to do most of the inspection tasks, and you probably will only need direct access to the GNU Objective-C runtime API to define new classes or methods.</source>
          <target state="translated">如果您使用的是诸如GNUstep-Base之类的&amp;ldquo;基础&amp;rdquo;库，则该库将为您提供丰富的功能集来执行大多数检查任务，并且您可能可能仅需要直接访问GNU Objective-C运行时API。定义新的类或方法。</target>
        </trans-unit>
        <trans-unit id="f60cfeeeec61609632220d7b04102d2cfb0874a6" translate="yes" xml:space="preserve">
          <source>If you are writing a header file that must work when included in ISO C programs, write &lt;code&gt;__typeof__&lt;/code&gt; instead of &lt;code&gt;typeof&lt;/code&gt;. See &lt;a href=&quot;alternate-keywords#Alternate-Keywords&quot;&gt;Alternate Keywords&lt;/a&gt;.</source>
          <target state="translated">如果要编写的标头文件必须包含在ISO C程序中才能工作，请编写 &lt;code&gt;__typeof__&lt;/code&gt; 而不是 &lt;code&gt;typeof&lt;/code&gt; 。请参阅&lt;a href=&quot;alternate-keywords#Alternate-Keywords&quot;&gt;备用关键字&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="047e86cc1cc9d18346ee9ad5f63aecd5602b5f99" translate="yes" xml:space="preserve">
          <source>If you are writing a header file to be included in ISO C90 programs, write &lt;code&gt;__inline__&lt;/code&gt; instead of &lt;code&gt;inline&lt;/code&gt;. See &lt;a href=&quot;alternate-keywords#Alternate-Keywords&quot;&gt;Alternate Keywords&lt;/a&gt;.</source>
          <target state="translated">如果要编写要包含在ISO C90程序中的头文件，请编写 &lt;code&gt;__inline__&lt;/code&gt; 而不是 &lt;code&gt;inline&lt;/code&gt; 。请参阅&lt;a href=&quot;alternate-keywords#Alternate-Keywords&quot;&gt;备用关键字&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="dbd2d15a4f5e85df131685d7eb92f6861e37e279" translate="yes" xml:space="preserve">
          <source>If you care about controlling the amount of memory that is accessed, use volatile but do not use bit-fields.</source>
          <target state="translated">如果你关心控制访问内存的数量,请使用易失性,但不要使用位字段。</target>
        </trans-unit>
        <trans-unit id="0103e1abfe788f8d50e7fc73d958416e72e0b9c1" translate="yes" xml:space="preserve">
          <source>If you compile a module &lt;var&gt;Mod&lt;/var&gt; with</source>
          <target state="translated">如果您编译模块 &lt;var&gt;Mod&lt;/var&gt; 与</target>
        </trans-unit>
        <trans-unit id="47d85eced409c6f6fef0defc52869795ed0b0f14" translate="yes" xml:space="preserve">
          <source>If you define a class in a header file marked with &amp;lsquo;</source>
          <target state="translated">如果您在标有&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="8af3483bb66c1cf78841141fb90f1ef9efc295a7" translate="yes" xml:space="preserve">
          <source>If you do not specify an optimization level option</source>
          <target state="translated">如果您没有指定优化级别选项</target>
        </trans-unit>
        <trans-unit id="0524dbf059780b836548e3795cd65f22c493bbb4" translate="yes" xml:space="preserve">
          <source>If you do use differing options when generating and using the precompiled header, the actual behavior is a mixture of the behavior for the options. For instance, if you use</source>
          <target state="translated">如果您在生成和使用预编译头时使用了不同的选项,那么实际的行为就是这些选项的混合行为。例如,如果您使用</target>
        </trans-unit>
        <trans-unit id="6615402a003808b60f77e922f8fff7dc102cea3e" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t know the type of the operand, you can still do this, but you must use &lt;code&gt;typeof&lt;/code&gt; or &lt;code&gt;__auto_type&lt;/code&gt; (see &lt;a href=&quot;typeof#Typeof&quot;&gt;Typeof&lt;/a&gt;).</source>
          <target state="translated">如果您不知道操作数的类型，仍然可以执行此操作，但是必须使用 &lt;code&gt;typeof&lt;/code&gt; 或 &lt;code&gt;__auto_type&lt;/code&gt; （请参见&lt;a href=&quot;typeof#Typeof&quot;&gt;Typeof&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="c085ab8b04d2de8c46788dc7f554d15750ff8940" translate="yes" xml:space="preserve">
          <source>If you have trouble using GCC.</source>
          <target state="translated">如果你在使用GCC时遇到困难。</target>
        </trans-unit>
        <trans-unit id="4152886dce97a4266954e0590ef45338d28d4f3b" translate="yes" xml:space="preserve">
          <source>If you invoke &lt;code&gt;gcov&lt;/code&gt; with multiple input files, the contributions from each input file are summed. Typically you would invoke it with the same list of files as the final link of your executable.</source>
          <target state="translated">如果您使用多个输入文件调用 &lt;code&gt;gcov&lt;/code&gt; ，则将每个输入文件的贡献求和。通常，您将使用与可执行文件的最终链接相同的文件列表来调用它。</target>
        </trans-unit>
        <trans-unit id="f78ebb50b8c8401143c21ca977cd992331a9d441" translate="yes" xml:space="preserve">
          <source>If you invoke GCC in parallel, compiling several different source files that share a common base name in different subdirectories or the same source file compiled for multiple output destinations, it is likely that the different parallel compilers will interfere with each other, and overwrite the temporary files. For instance:</source>
          <target state="translated">如果并行调用GCC,在不同的子目录下编译多个共用基名的不同源文件,或者为多个输出目的地编译同一个源文件,很可能会出现不同的并行编译器相互干扰,覆盖临时文件的情况。比如说</target>
        </trans-unit>
        <trans-unit id="339873ba9c437ffb773ea97b43d76bef2cd414b1" translate="yes" xml:space="preserve">
          <source>If you know the above will only be reading a ten byte array then you could instead use a memory input like: &lt;code&gt;&quot;m&quot; (*(const char (*)[10]) p)&lt;/code&gt;.</source>
          <target state="translated">如果您知道上述内容只会读取一个十字节的数组，则可以改用内存输入，例如： &lt;code&gt;&quot;m&quot; (*(const char (*)[10]) p)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="888965c4f3b549f1f0054a0f4c6ff67115a7146e" translate="yes" xml:space="preserve">
          <source>If you need a Standard compliant library, then you need to find one, as GCC does not provide one. The GNU C library (called &lt;code&gt;glibc&lt;/code&gt;) provides ISO C, POSIX, BSD, SystemV and X/Open compatibility for GNU/Linux and HURD-based GNU systems; no recent version of it supports other systems, though some very old versions did. Version 2.2 of the GNU C library includes nearly complete C99 support. You could also ask your operating system vendor if newer libraries are available.</source>
          <target state="translated">如果您需要符合标准的库，则需要查找一个库，因为GCC不提供该库。GNU C库（称为 &lt;code&gt;glibc&lt;/code&gt; ）为GNU / Linux和基于HURD的GNU系统提供了ISO C，POSIX，BSD，SystemV和X / Open兼容性。它的最新版本不支持其他系统，尽管有些非常旧的版本支持。GNU C库的2.2版包括几乎完整的C99支持。您还可以询问操作系统供应商是否提供了更新的库。</target>
        </trans-unit>
        <trans-unit id="2295b8a8afca796af761f37955429fb2dfb303ab" translate="yes" xml:space="preserve">
          <source>If you need to precompile the same header file for different languages, targets, or compiler options, you can instead make a &lt;em&gt;directory&lt;/em&gt; named like</source>
          <target state="translated">如果需要针对不同的语言，目标或编译器选项预编译相同的头文件，则可以改成名为like 的&lt;em&gt;目录&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="66af9e4f8d685ec9e9b50745c5edb5982da51a9b" translate="yes" xml:space="preserve">
          <source>If you need to read the volatile object after an assignment has occurred, you must use a separate expression with an intervening sequence point.</source>
          <target state="translated">如果需要在赋值发生后读取易失性对象,必须使用一个单独的表达式,中间有一个序列点。</target>
        </trans-unit>
        <trans-unit id="4adf572d889db0dbe74d88ef8bb1d09b3f0a1cca" translate="yes" xml:space="preserve">
          <source>If you only want some of the stages of compilation, you can use</source>
          <target state="translated">如果你只想要编译的一些阶段,你可以使用</target>
        </trans-unit>
        <trans-unit id="0a3a127b379e27c78040de67c2f4f38df68d44ac" translate="yes" xml:space="preserve">
          <source>If you plan to use &lt;code&gt;gcov&lt;/code&gt; to help optimize your code, you must first compile your program with a special GCC option &amp;lsquo;</source>
          <target state="translated">如果您打算使用 &lt;code&gt;gcov&lt;/code&gt; 来帮助优化代码，则必须首先使用特殊的GCC选项&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="89a00b1663443b615a5e906a67310faf3ab9d3e4" translate="yes" xml:space="preserve">
          <source>If you receive a linker error message that saying you have overflowed the available TOC space, you can reduce the amount of TOC space used with the</source>
          <target state="translated">如果你收到一个链接器错误信息,说你已经溢出了可用的TOC空间,你可以通过使用</target>
        </trans-unit>
        <trans-unit id="be0941cee2405a3cef991d81a7e61b7d98631fbb" translate="yes" xml:space="preserve">
          <source>If you replaced &lt;code&gt;short_a&lt;/code&gt; with &lt;code&gt;short&lt;/code&gt; in the variable declaration, the above program would abort when compiled with</source>
          <target state="translated">如果在变量声明 &lt;code&gt;short_a&lt;/code&gt; 替换为 &lt;code&gt;short&lt;/code&gt; ，则使用以下命令编译时上述程序将中止</target>
        </trans-unit>
        <trans-unit id="35d1d8ed39d0b8c7b146243c81d4152cdc148fcf" translate="yes" xml:space="preserve">
          <source>If you specify &amp;lsquo;</source>
          <target state="translated">如果您指定&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="4ecc2b870bc1bb7d3b980a000c9f6dcec5995fb9" translate="yes" xml:space="preserve">
          <source>If you specify both &lt;code&gt;inline&lt;/code&gt; and &lt;code&gt;extern&lt;/code&gt; in the function definition, then the definition is used only for inlining. In no case is the function compiled on its own, not even if you refer to its address explicitly. Such an address becomes an external reference, as if you had only declared the function, and had not defined it.</source>
          <target state="translated">如果在函数定义中同时指定 &lt;code&gt;inline&lt;/code&gt; 和 &lt;code&gt;extern&lt;/code&gt; ，则该定义仅用于内联。在任何情况下，即使您显式引用其地址，该函数也不会自行编译。这样的地址将成为一个外部引用，就好像您仅声明了该函数而未定义它一样。</target>
        </trans-unit>
        <trans-unit id="5d47cb731371550330a13465931e86c5d293dfdf" translate="yes" xml:space="preserve">
          <source>If you specify command-line switches such as</source>
          <target state="translated">如果你指定命令行开关,如</target>
        </trans-unit>
        <trans-unit id="6dac1f1fb59b9ffca6f761fa60561e481b2e6270" translate="yes" xml:space="preserve">
          <source>If you specify neither</source>
          <target state="translated">如果您既没有指定</target>
        </trans-unit>
        <trans-unit id="c921e7f4f95a0df5eb637ba56c7aabab978aaee6" translate="yes" xml:space="preserve">
          <source>If you specify the optional &lt;var&gt;n&lt;/var&gt;, the optimization and code generation done at link time is executed in parallel using &lt;var&gt;n&lt;/var&gt; parallel jobs by utilizing an installed &lt;code&gt;make&lt;/code&gt; program. The environment variable &lt;code&gt;MAKE&lt;/code&gt; may be used to override the program used. The default value for &lt;var&gt;n&lt;/var&gt; is 1.</source>
          <target state="translated">如果指定了可选的 &lt;var&gt;n&lt;/var&gt; ，则通过使用已安装的 &lt;code&gt;make&lt;/code&gt; 程序，使用 &lt;var&gt;n&lt;/var&gt; 个并行作业并行执行链接时完成的优化和代码生成。环境变量 &lt;code&gt;MAKE&lt;/code&gt; 可用于覆盖所使用的程序。 &lt;var&gt;n&lt;/var&gt; 的默认值为1。</target>
        </trans-unit>
        <trans-unit id="925aa9cac99e94c7e1b3007e94e2857fd742f461" translate="yes" xml:space="preserve">
          <source>If you still run out of space in the TOC even when you specify both of these options, specify</source>
          <target state="translated">如果您指定了这两个选项后,TOC中的空间仍然不够用,请指定</target>
        </trans-unit>
        <trans-unit id="e9f3b7bcc19fa8799f793151f5d918c0eb44cc5c" translate="yes" xml:space="preserve">
          <source>If you try to call the nested function through its address after the containing function exits, all hell breaks loose. If you try to call it after a containing scope level exits, and if it refers to some of the variables that are no longer in scope, you may be lucky, but it&amp;rsquo;s not wise to take the risk. If, however, the nested function does not refer to anything that has gone out of scope, you should be safe.</source>
          <target state="translated">如果您尝试在包含函数退出后通过其地址调用嵌套函数，那么所有地狱都会变得松散。如果您尝试在包含作用域级别退出之后调用它，并且如果它引用了不再在作用域中的某些变量，则可能很幸运，但是冒险是不明智的。但是，如果嵌套函数未引用超出范围的任何内容，那么您应该是安全的。</target>
        </trans-unit>
        <trans-unit id="f927a3385a1b1e51d949287257534f3a4443c5fc" translate="yes" xml:space="preserve">
          <source>If you update the system&amp;rsquo;s header files, such as by installing a new system version, the fixed header files of GCC are not automatically updated. They can be updated using the &lt;code&gt;mkheaders&lt;/code&gt; script installed in</source>
          <target state="translated">如果您更新系统的头文件（例如通过安装新的系统版本），则GCC的固定头文件不会自动更新。可以使用安装在以下位置的 &lt;code&gt;mkheaders&lt;/code&gt; 脚本来更新它们</target>
        </trans-unit>
        <trans-unit id="41fb10bf832524090b9ab05176d0ed5567a508f5" translate="yes" xml:space="preserve">
          <source>If you use</source>
          <target state="translated">如果您使用</target>
        </trans-unit>
        <trans-unit id="6a51a2c7443f8a2b859ded2344689b9dd5a96d35" translate="yes" xml:space="preserve">
          <source>If you use &amp;lsquo;</source>
          <target state="translated">如果您使用&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="1eb60252a45f0973d8c5683aecd8b85683d307d3" translate="yes" xml:space="preserve">
          <source>If you use both this option and the</source>
          <target state="translated">如果您同时使用该选项和</target>
        </trans-unit>
        <trans-unit id="daf14f5a30ee5ca1525b7be167b116e92944e7ce" translate="yes" xml:space="preserve">
          <source>If you use multiple</source>
          <target state="translated">如果您使用多个</target>
        </trans-unit>
        <trans-unit id="9b9352d7bdc60d6db5e3f97a4150de5fffc4de3b" translate="yes" xml:space="preserve">
          <source>If you use one big file to do the instantiations, you may want to compile it without</source>
          <target state="translated">如果你用一个大文件来做实例化,你可能想在编译时不使用</target>
        </trans-unit>
        <trans-unit id="d5658f3cda5684fd922808fa10e4319b5a492e30" translate="yes" xml:space="preserve">
          <source>If you use one of the &lt;code&gt;__flash&lt;var&gt;N&lt;/var&gt;&lt;/code&gt; address spaces you must arrange your linker script to locate the &lt;code&gt;.progmem&lt;var&gt;N&lt;/var&gt;.data&lt;/code&gt; sections according to your needs.</source>
          <target state="translated">如果使用 &lt;code&gt;__flash&lt;var&gt;N&lt;/var&gt;&lt;/code&gt; 地址空间之一，则必须根据需要安排链接描述文件以找到 &lt;code&gt;.progmem&lt;var&gt;N&lt;/var&gt;.data&lt;/code&gt; 节。</target>
        </trans-unit>
        <trans-unit id="d09fff5b63f8a00b0aa50a2fbc9e05727d5eaa55" translate="yes" xml:space="preserve">
          <source>If you use the</source>
          <target state="translated">如果您使用</target>
        </trans-unit>
        <trans-unit id="0c2eabb891cc235e2e02c3ade4b4c6be5a7c7761" translate="yes" xml:space="preserve">
          <source>If you use the &lt;code&gt;inline&lt;/code&gt; qualifier, then for inlining purposes the size of the &lt;code&gt;asm&lt;/code&gt; statement is taken as the smallest size possible (see &lt;a href=&quot;size-of-an-asm#Size-of-an-asm&quot;&gt;Size of an asm&lt;/a&gt;).</source>
          <target state="translated">如果使用 &lt;code&gt;inline&lt;/code&gt; 限定符，则出于内联目的，将 &lt;code&gt;asm&lt;/code&gt; 语句的大小视为可能的最小大小（请参见&lt;a href=&quot;size-of-an-asm#Size-of-an-asm&quot;&gt;asm的大小&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="1d0a1d145962ca52d117f00e82a8a34efa685f04" translate="yes" xml:space="preserve">
          <source>If you use the ISA 3.0 instruction set (</source>
          <target state="translated">如果您使用ISA 3.0指令集(</target>
        </trans-unit>
        <trans-unit id="3b409b718d6983a24e16eccb9909125cc43f2697" translate="yes" xml:space="preserve">
          <source>If you want to pass an option that takes a separate argument, you must use</source>
          <target state="translated">如果你想传递一个需要单独参数的选项,你必须使用</target>
        </trans-unit>
        <trans-unit id="01e57dac3d1293541430d1619103f3be6de91e09" translate="yes" xml:space="preserve">
          <source>If you want to pass an option that takes an argument, you must use</source>
          <target state="translated">如果你想传递一个接受参数的选项,你必须使用</target>
        </trans-unit>
        <trans-unit id="57c0d52053735b1deca65f8fe95302a40e91aba4" translate="yes" xml:space="preserve">
          <source>If you want to pass the array first and the length afterward, you can use a forward declaration in the parameter list&amp;mdash;another GNU extension.</source>
          <target state="translated">如果要先传递数组，然后传递长度，则可以在参数列表中使用前向声明（另一个GNU扩展）。</target>
        </trans-unit>
        <trans-unit id="714721fbe0a57745166a774e2ee80658db42639e" translate="yes" xml:space="preserve">
          <source>If you want to recompile source files that do not actually use your global register variable so they do not use the specified register for any other purpose, you need not actually add the global register declaration to their source code. It suffices to specify the compiler option</source>
          <target state="translated">如果你想重新编译那些没有实际使用全局寄存器变量的源文件,使它们不为任何其他目的使用指定的寄存器,你实际上不需要在它们的源代码中添加全局寄存器声明。只需指定编译器选项</target>
        </trans-unit>
        <trans-unit id="63035fe8f0fef33a809f5df21a239bff0f434564" translate="yes" xml:space="preserve">
          <source>If you want to warn about code that uses the uninitialized value of the variable in its own initializer, use the</source>
          <target state="translated">如果你想警告那些在自己的初始化器中使用未初始化的变量值的代码,可以使用</target>
        </trans-unit>
        <trans-unit id="1f9d39a0d621d29f6b4df2f19650e527eb6087e6" translate="yes" xml:space="preserve">
          <source>If you want your own collection object to be usable with fast enumeration, you need to have it implement the method</source>
          <target state="translated">如果你想让你自己的集合对象可以使用快速枚举,你需要让它实现方法</target>
        </trans-unit>
        <trans-unit id="66ce7bf0d3f3a0ea10a8e8123399a75d9055c922" translate="yes" xml:space="preserve">
          <source>If you wish to define a function-like macro on the command line, write its argument list with surrounding parentheses before the equals sign (if any). Parentheses are meaningful to most shells, so you should quote the option. With &lt;code&gt;sh&lt;/code&gt; and &lt;code&gt;csh&lt;/code&gt;,</source>
          <target state="translated">如果要在命令行上定义类似函数的宏，请在等号之前（如果有的话）在参数列表中加上括号。括号对大多数shell有意义，因此您应该引用该选项。使用 &lt;code&gt;sh&lt;/code&gt; 和 &lt;code&gt;csh&lt;/code&gt; ，</target>
        </trans-unit>
        <trans-unit id="344eca13d4f5455ce9ed14a9174152844b040aa2" translate="yes" xml:space="preserve">
          <source>If your code needs to support multiple assembler dialects (for example, if you are writing public headers that need to support a variety of compilation options), use constructs of this form:</source>
          <target state="translated">如果你的代码需要支持多种汇编器方言(例如,如果你编写的公有头文件需要支持多种编译选项),请使用这种形式的构造。</target>
        </trans-unit>
        <trans-unit id="489624b43d62801c5096e0cef6c84a4128aa3f2e" translate="yes" xml:space="preserve">
          <source>If, for some reason, you want to include letter &amp;lsquo;</source>
          <target state="translated">如果出于某种原因要添加字母&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="8ae25dcd1480cd59f0776f409a8f3b4cc8c76dee" translate="yes" xml:space="preserve">
          <source>If, instead, you use the GCC driver to create shared libraries, you may find that they are not always linked with the shared</source>
          <target state="translated">如果您使用GCC驱动程序来创建共享库,您可能会发现它们并不总是与共享的</target>
        </trans-unit>
        <trans-unit id="7d34e1e1ae89800680b004320ebb086b09cf39f6" translate="yes" xml:space="preserve">
          <source>Ignore the &lt;code&gt;#ident&lt;/code&gt; directive.</source>
          <target state="translated">忽略 &lt;code&gt;#ident&lt;/code&gt; 指令。</target>
        </trans-unit>
        <trans-unit id="2e82df27ea7fceb83aac6e28c3926e8f714c2de0" translate="yes" xml:space="preserve">
          <source>Immediate 15-bit unsigned integer</source>
          <target state="translated">即时15位无符号整数</target>
        </trans-unit>
        <trans-unit id="25ebf6700b63624d3804d20faa7de74e2dccc87c" translate="yes" xml:space="preserve">
          <source>Immediate 16-bit signed integer</source>
          <target state="translated">即时16位有符号整数</target>
        </trans-unit>
        <trans-unit id="c2ce26e27211c1d69d3a406bee1c55a3cfc3b488" translate="yes" xml:space="preserve">
          <source>Immediate 32-bit integer in range -16..4294967295 (i.e. 32-bit unsigned integer or &amp;lsquo;</source>
          <target state="translated">范围-16..4294967295的直接32位整数（即32位无符号整数或'</target>
        </trans-unit>
        <trans-unit id="7ce04d3df5932775f166ab61ebe67634f6cff4f5" translate="yes" xml:space="preserve">
          <source>Immediate 32-bit signed integer that can be attached to an instruction encoding</source>
          <target state="translated">即时32位有符号的整数,可以附加到指令编码中。</target>
        </trans-unit>
        <trans-unit id="95af07c0237447c6b15292985f8e2b14ec413d35" translate="yes" xml:space="preserve">
          <source>Immediate 64-bit constant that can be split into two &amp;lsquo;</source>
          <target state="translated">直接的64位常量，可以分为两个'</target>
        </trans-unit>
        <trans-unit id="aea4f97beb4642aabcdf84f409c00fa5cd5c2c91" translate="yes" xml:space="preserve">
          <source>Immediate constant -1</source>
          <target state="translated">即时常数-1</target>
        </trans-unit>
        <trans-unit id="293172a51e9ef5dbf0bb7e7f454796275cc1f905" translate="yes" xml:space="preserve">
          <source>Immediate constant that can be inlined in an instruction encoding: integer -16..64, or float 0.0, +/-0.5, +/-1.0, +/-2.0, +/-4.0, 1.0/(2.0*PI)</source>
          <target state="translated">可在指令编码中内联的即时常数:整数-16...64,或浮点数0.0、+/-0.5、+/-1.0、+/-2.0、+/-4.0、1.0/(2.0*PI)</target>
        </trans-unit>
        <trans-unit id="a56a5101429aaf4e851ed409b055e85e8d91d6b8" translate="yes" xml:space="preserve">
          <source>Immediate integer in the range -16 to 64</source>
          <target state="translated">即时整数,范围为-16至64。</target>
        </trans-unit>
        <trans-unit id="bf320f9d296e81a49f73cab866d640531aefcfad" translate="yes" xml:space="preserve">
          <source>Implement (do not implement) -fno-plt and long calls using an inline PLT call sequence that supports lazy linking and long calls to functions in dlopen&amp;rsquo;d shared libraries. Inline PLT calls are only supported on PowerPC64 ELFv2 and 32-bit PowerPC systems with newer GNU linkers, and are enabled by default if the support is detected when configuring GCC, and, in the case of 32-bit PowerPC, if GCC is configured with</source>
          <target state="translated">使用内联PLT调用序列实现（不实现）-fno-plt和长调用，该序列支持延迟链接和对dlopen共享库中函数的长调用。内联PLT调用仅在具有较新GNU链接器的PowerPC64 ELFv2和32位PowerPC系统上受支持，如果在配置GCC时检测到支持，则默认启用内联PLT调用；在32位PowerPC的情况下，如果GCC配置为</target>
        </trans-unit>
        <trans-unit id="f6c8b1a3b3ce20b0f24d10325bb5a9fda3cc0723" translate="yes" xml:space="preserve">
          <source>Implies no inter-thread ordering constraints.</source>
          <target state="translated">意味着没有线程间的排序约束。</target>
        </trans-unit>
        <trans-unit id="fe96af122b5bf84f1ddc818f1e5f57ac3e7dac8c" translate="yes" xml:space="preserve">
          <source>Improved AMD Athlon CPU with MMX, 3DNow!, enhanced 3DNow! and full SSE instruction set support.</source>
          <target state="translated">改进的AMD Athlon CPU,具有MMX、3DNow!、增强的3DNow!和完整的SSE指令集支持。</target>
        </trans-unit>
        <trans-unit id="6774c0ca18d629c919e07781b4bc4345f81613ce" translate="yes" xml:space="preserve">
          <source>Improved support for generic programming.</source>
          <target state="translated">改进对通用方案编制的支持。</target>
        </trans-unit>
        <trans-unit id="bb701b014b08c67fb59b6b752448015c50d54c43" translate="yes" xml:space="preserve">
          <source>Improved version of Intel Pentium 4 CPU with 64-bit extensions, MMX, SSE, SSE2 and SSE3 instruction set support.</source>
          <target state="translated">Intel Pentium 4 CPU的改进版,支持64位扩展、MMX、SSE、SSE2和SSE3指令集。</target>
        </trans-unit>
        <trans-unit id="ed782143dc7e1163d3eb2323e646f10006e40097" translate="yes" xml:space="preserve">
          <source>Improved version of Intel Pentium 4 CPU with MMX, SSE, SSE2 and SSE3 instruction set support.</source>
          <target state="translated">Intel Pentium 4 CPU的改进版,支持MMX、SSE、SSE2和SSE3指令集。</target>
        </trans-unit>
        <trans-unit id="8a73deb51d5b08d19d0486183c731c2e4df58a6c" translate="yes" xml:space="preserve">
          <source>Improved versions of AMD K6 CPU with MMX and 3DNow! instruction set support.</source>
          <target state="translated">改进版AMD K6 CPU,支持MMX和3DNow!指令集。</target>
        </trans-unit>
        <trans-unit id="0640019f239b6c731b94ce729c56eafeb42fbdce" translate="yes" xml:space="preserve">
          <source>Improved versions of AMD K8 cores with SSE3 instruction set support.</source>
          <target state="translated">改进版的AMD K8内核,支持SSE3指令集。</target>
        </trans-unit>
        <trans-unit id="faa77d9eb98f8c3bb3a99e6c2fd6a673c7a1ef4f" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;&amp;lt;stddef.h&amp;gt;&lt;/code&gt;, &lt;code&gt;NULL&lt;/code&gt; expands to &lt;code&gt;((void *)0)&lt;/code&gt;. GCC does not provide the other headers which define &lt;code&gt;NULL&lt;/code&gt; and some library implementations may use other definitions in those headers.</source>
          <target state="translated">在 &lt;code&gt;&amp;lt;stddef.h&amp;gt;&lt;/code&gt; 中， &lt;code&gt;NULL&lt;/code&gt; 扩展为 &lt;code&gt;((void *)0)&lt;/code&gt; 。GCC不提供其他定义 &lt;code&gt;NULL&lt;/code&gt; 的标头，某些库实现可能在这些标头中使用其他定义。</target>
        </trans-unit>
        <trans-unit id="94f792f5735cf258c95fd93f04f6f7c58a83d70b" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;get_i()&lt;/code&gt;, &lt;code&gt;i&lt;/code&gt; is not used in a dependent context, so the compiler will look for a name declared at the enclosing namespace scope (which is the global scope here). It will not look into the base class, since that is dependent and you may declare specializations of &lt;code&gt;Base&lt;/code&gt; even after declaring &lt;code&gt;Derived&lt;/code&gt;, so the compiler cannot really know what &lt;code&gt;i&lt;/code&gt; would refer to. If there is no global variable &lt;code&gt;i&lt;/code&gt;, then you will get an error message.</source>
          <target state="translated">在 &lt;code&gt;get_i()&lt;/code&gt; 中， &lt;code&gt;i&lt;/code&gt; 不在依赖上下文中使用，因此编译器将查找在封闭的名称空间范围（此处为全局范围）中声明的名称。它不会查看基类，因为它是依赖的，即使在声明 &lt;code&gt;Derived&lt;/code&gt; 之后，您也可以声明 &lt;code&gt;Base&lt;/code&gt; 的特化，因此编译器无法真正知道 &lt;code&gt;i&lt;/code&gt; 要指的是什么。如果没有全局变量 &lt;code&gt;i&lt;/code&gt; ，那么您将收到一条错误消息。</target>
        </trans-unit>
        <trans-unit id="1efd435b2fd7ff4eeb1d3caefe51e97ec2eabff1" translate="yes" xml:space="preserve">
          <source>In C code, this option controls the placement of global variables defined without an initializer, known as &lt;em&gt;tentative definitions&lt;/em&gt; in the C standard. Tentative definitions are distinct from declarations of a variable with the &lt;code&gt;extern&lt;/code&gt; keyword, which do not allocate storage.</source>
          <target state="translated">在C代码中，此选项控制在没有初始化程序的情况下定义的全局变量的放置，在C标准中称为&lt;em&gt;临时定义&lt;/em&gt;。临时定义不同于使用 &lt;code&gt;extern&lt;/code&gt; 关键字声明的变量，后者不分配存储空间。</target>
        </trans-unit>
        <trans-unit id="986d71cafa07e6d2f235ac194e79a8e70cb9cccf" translate="yes" xml:space="preserve">
          <source>In C mode, this is equivalent to</source>
          <target state="translated">在C模式下,这相当于</target>
        </trans-unit>
        <trans-unit id="6e29cf5656ff22cce837fe364a063ee35412d5b9" translate="yes" xml:space="preserve">
          <source>In C this option does not warn about the universal zero initializer &amp;lsquo;</source>
          <target state="translated">在C中，此选项不会警告通用零初始化器'</target>
        </trans-unit>
        <trans-unit id="2f3a5ba446573452e29640c8fc16cb4e894d48dc" translate="yes" xml:space="preserve">
          <source>In C++ code, this allows member names in structures to be similar to previous types declarations.</source>
          <target state="translated">在C++代码中,这使得结构中的成员名与之前的类型声明相似。</target>
        </trans-unit>
        <trans-unit id="c8175f71005ecf03750f6f6a8eb8dfe31c736137" translate="yes" xml:space="preserve">
          <source>In C++ the value of an object is only affected by changes within its lifetime: when the constructor begins, the object has an indeterminate value, and any changes during the lifetime of the object are dead when the object is destroyed. Normally dead store elimination will take advantage of this; if your code relies on the value of the object storage persisting beyond the lifetime of the object, you can use this flag to disable this optimization. To preserve stores before the constructor starts (e.g. because your operator new clears the object storage) but still treat the object as dead after the destructor you, can use</source>
          <target state="translated">在C++中,对象的值只受其生命期内的变化影响:当构造函数开始时,对象的值是不确定的,当对象被销毁时,对象生命期内的任何变化都是死的。通常死存储消除会利用这一点;如果你的代码依赖于对象存储的值在对象的生命期之后持久存在,你可以使用这个标志来禁用这个优化。要在构造函数开始之前保留存储(例如,因为你的操作符new清除了对象存储),但在destructor之后仍然将对象视为死存储,你,可以使用</target>
        </trans-unit>
        <trans-unit id="168fb41a49baf3aa442f73f3ecb6a40cd4d6ca59" translate="yes" xml:space="preserve">
          <source>In C++, &amp;lsquo;</source>
          <target state="translated">在C ++中，</target>
        </trans-unit>
        <trans-unit id="1bcce97889f7dbf32fa6b64e8c64b08099b3f7a1" translate="yes" xml:space="preserve">
          <source>In C++, attribute visibility (see &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;Function Attributes&lt;/a&gt;) can also be applied to class, struct, union and enum types. Unlike other type attributes, the attribute must appear between the initial keyword and the name of the type; it cannot appear after the body of the type.</source>
          <target state="translated">在C ++中，属性可见性（请参见&lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;函数属性&lt;/a&gt;）也可以应用于类，结构，联合和枚举类型。与其他类型属性不同，该属性必须出现在初始关键字和类型名称之间；它不能出现在类型的正文之后。</target>
        </trans-unit>
        <trans-unit id="41407820aea4af6aceb3725e14d20bcfa5717ed8" translate="yes" xml:space="preserve">
          <source>In C++, if a template argument has limited visibility, this restriction is implicitly propagated to the template instantiation. Otherwise, template instantiations and specializations default to the visibility of their template.</source>
          <target state="translated">在C++中,如果一个模板参数具有有限的可见性,这个限制会隐式地传播给模板实例化。否则,模板实例化和特殊化会默认为其模板的可见性。</target>
        </trans-unit>
        <trans-unit id="453e27477f405b0f81788514a49ffd79d08ff550" translate="yes" xml:space="preserve">
          <source>In C++, if an initializer is present for a thread-local variable, it must be a &lt;var&gt;constant-expression&lt;/var&gt;, as defined in 5.19.2 of the ANSI/ISO C++ standard.</source>
          <target state="translated">在C ++中，如果存在用于线程局部变量的初始化器，则它必须是ANSI / ISO C ++标准5.19.2中定义的 &lt;var&gt;constant-expression&lt;/var&gt; 。</target>
        </trans-unit>
        <trans-unit id="9e8da9f4a402f87aeb0e1e0768c85b6e521a3ae7" translate="yes" xml:space="preserve">
          <source>In C++, pointer to member functions (PMFs) are implemented using a wide pointer of sorts to handle all the possible call mechanisms; the PMF needs to store information about how to adjust the &amp;lsquo;</source>
          <target state="translated">在C ++中，使用多种指针来实现成员函数（PMF）的指针，以处理所有可能的调用机制。PMF需要存储有关如何调整&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="34a26947af0331ebcf8b3ff5e4127f49a113bd19" translate="yes" xml:space="preserve">
          <source>In C++, the &lt;code&gt;ifunc&lt;/code&gt; attribute takes a string that is the mangled name of the resolver function. A C++ resolver for a non-static member function of class &lt;code&gt;C&lt;/code&gt; should be declared to return a pointer to a non-member function taking pointer to &lt;code&gt;C&lt;/code&gt; as the first argument, followed by the same arguments as of the implementation function. G++ checks the signatures of the two functions and issues a</source>
          <target state="translated">在C ++中， &lt;code&gt;ifunc&lt;/code&gt; 属性采用一个字符串，该字符串是解析器函数的错误名称。应该声明一个用于类 &lt;code&gt;C&lt;/code&gt; 的非静态成员函数的C ++解析器，以返回指向非成员函数的指针，该指针以指向 &lt;code&gt;C&lt;/code&gt; 的指针作为第一个参数，后跟与实现函数相同的参数。G ++检查两个函数的签名并发出</target>
        </trans-unit>
        <trans-unit id="dae3c25a08855a03a679edfb667679b322123fbc" translate="yes" xml:space="preserve">
          <source>In C++, the logic operators &lt;code&gt;!, &amp;amp;&amp;amp;, ||&lt;/code&gt; are available for vectors. &lt;code&gt;!v&lt;/code&gt; is equivalent to &lt;code&gt;v == 0&lt;/code&gt;, &lt;code&gt;a &amp;amp;&amp;amp; b&lt;/code&gt; is equivalent to &lt;code&gt;a!=0 &amp;amp; b!=0&lt;/code&gt; and &lt;code&gt;a || b&lt;/code&gt; is equivalent to &lt;code&gt;a!=0 | b!=0&lt;/code&gt;. For mixed operations between a scalar &lt;code&gt;s&lt;/code&gt; and a vector &lt;code&gt;v&lt;/code&gt;, &lt;code&gt;s &amp;amp;&amp;amp; v&lt;/code&gt; is equivalent to &lt;code&gt;s?v!=0:0&lt;/code&gt; (the evaluation is short-circuit) and &lt;code&gt;v &amp;amp;&amp;amp; s&lt;/code&gt; is equivalent to &lt;code&gt;v!=0 &amp;amp; (s?-1:0)&lt;/code&gt;.</source>
          <target state="translated">在C ++中，逻辑运算符 &lt;code&gt;!, &amp;amp;&amp;amp;, ||&lt;/code&gt; 可用于矢量。 &lt;code&gt;!v&lt;/code&gt; 等效于 &lt;code&gt;v == 0&lt;/code&gt; ， &lt;code&gt;a &amp;amp;&amp;amp; b&lt;/code&gt; 等效于 &lt;code&gt;a!=0 &amp;amp; b!=0&lt;/code&gt; 和 &lt;code&gt;a || b&lt;/code&gt; 等于 &lt;code&gt;a!=0 | b!=0&lt;/code&gt; 。对于标量 &lt;code&gt;s&lt;/code&gt; 与向量 &lt;code&gt;v&lt;/code&gt; 之间的混合运算， &lt;code&gt;s &amp;amp;&amp;amp; v&lt;/code&gt; 等于 &lt;code&gt;s?v!=0:0&lt;/code&gt; （评估为短路），而 &lt;code&gt;v &amp;amp;&amp;amp; s&lt;/code&gt; 等于 &lt;code&gt;v!=0 &amp;amp; (s?-1:0)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="260b901dabc2f639a1fcfb92f83b3a8bfc6792cb" translate="yes" xml:space="preserve">
          <source>In C++, the ternary operator &lt;code&gt;?:&lt;/code&gt; is available. &lt;code&gt;a?b:c&lt;/code&gt;, where &lt;code&gt;b&lt;/code&gt; and &lt;code&gt;c&lt;/code&gt; are vectors of the same type and &lt;code&gt;a&lt;/code&gt; is an integer vector with the same number of elements of the same size as &lt;code&gt;b&lt;/code&gt; and &lt;code&gt;c&lt;/code&gt;, computes all three arguments and creates a vector &lt;code&gt;{a[0]?b[0]:c[0], a[1]?b[1]:c[1], &amp;hellip;}&lt;/code&gt;. Note that unlike in OpenCL, &lt;code&gt;a&lt;/code&gt; is thus interpreted as &lt;code&gt;a != 0&lt;/code&gt; and not &lt;code&gt;a &amp;lt; 0&lt;/code&gt;. As in the case of binary operations, this syntax is also accepted when one of &lt;code&gt;b&lt;/code&gt; or &lt;code&gt;c&lt;/code&gt; is a scalar that is then transformed into a vector. If both &lt;code&gt;b&lt;/code&gt; and &lt;code&gt;c&lt;/code&gt; are scalars and the type of &lt;code&gt;true?b:c&lt;/code&gt; has the same size as the element type of &lt;code&gt;a&lt;/code&gt;, then &lt;code&gt;b&lt;/code&gt; and &lt;code&gt;c&lt;/code&gt; are converted to a vector type whose elements have this type and with the same number of elements as &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">在C ++中，三元运算符 &lt;code&gt;?:&lt;/code&gt; 是可用的。 &lt;code&gt;a?b:c&lt;/code&gt; ，其中 &lt;code&gt;b&lt;/code&gt; 和 &lt;code&gt;c&lt;/code&gt; 是相同类型的向量， &lt;code&gt;a&lt;/code&gt; 是具有与 &lt;code&gt;b&lt;/code&gt; 和 &lt;code&gt;c&lt;/code&gt; 相同大小的相同数量元素的整数向量，计算所有三个参数并创建向量 &lt;code&gt;{a[0]?b[0]:c[0], a[1]?b[1]:c[1], &amp;hellip;}&lt;/code&gt; 。请注意，与OpenCL不同， &lt;code&gt;a&lt;/code&gt; 因此被解释为 &lt;code&gt;a != 0&lt;/code&gt; 而不是 &lt;code&gt;a &amp;lt; 0&lt;/code&gt; 。与二进制运算的情况一样，当 &lt;code&gt;b&lt;/code&gt; 或 &lt;code&gt;c&lt;/code&gt; 之一是标量然后转换为向量时，也接受此语法。如果都 &lt;code&gt;b&lt;/code&gt; 和 &lt;code&gt;c&lt;/code&gt; 是标量，并且 &lt;code&gt;true?b:c&lt;/code&gt; 的类型与 &lt;code&gt;a&lt;/code&gt; 的元素类型具有相同的大小，然后 &lt;code&gt;b&lt;/code&gt; 和 &lt;code&gt;c&lt;/code&gt; 转换为向量类型，该向量类型的元素具有此类型并且元素数与 &lt;code&gt;a&lt;/code&gt; 相同。</target>
        </trans-unit>
        <trans-unit id="9e8e3384895cb64dc59dfb4ef3c2eae30e005995" translate="yes" xml:space="preserve">
          <source>In C++, the visibility attribute applies to types as well as functions and objects, because in C++ types have linkage. A class must not have greater visibility than its non-static data member types and bases, and class members default to the visibility of their class. Also, a declaration without explicit visibility is limited to the visibility of its type.</source>
          <target state="translated">在C++中,可见性属性既适用于类型,也适用于函数和对象,因为在C++中,类型具有链接性。一个类的可见性不能大于它的非静态数据成员类型和基,类成员默认为其类的可见性。另外,没有显式可见性的声明也仅限于其类型的可见性。</target>
        </trans-unit>
        <trans-unit id="9870b14c476e69190f3f39c0be8be66122cac26a" translate="yes" xml:space="preserve">
          <source>In C++, the warning is issued when an explicit specialization of a primary template declared with attribute &lt;code&gt;alloc_align&lt;/code&gt;, &lt;code&gt;alloc_size&lt;/code&gt;, &lt;code&gt;assume_aligned&lt;/code&gt;, &lt;code&gt;format&lt;/code&gt;, &lt;code&gt;format_arg&lt;/code&gt;, &lt;code&gt;malloc&lt;/code&gt;, or &lt;code&gt;nonnull&lt;/code&gt; is declared without it. Attributes &lt;code&gt;deprecated&lt;/code&gt;, &lt;code&gt;error&lt;/code&gt;, and &lt;code&gt;warning&lt;/code&gt; suppress the warning. (see &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;Function Attributes&lt;/a&gt;).</source>
          <target state="translated">在C ++中，当主模板的明确分工与属性声明发出警告 &lt;code&gt;alloc_align&lt;/code&gt; ， &lt;code&gt;alloc_size&lt;/code&gt; ， &lt;code&gt;assume_aligned&lt;/code&gt; ， &lt;code&gt;format&lt;/code&gt; ， &lt;code&gt;format_arg&lt;/code&gt; ， &lt;code&gt;malloc&lt;/code&gt; 的，或者 &lt;code&gt;nonnull&lt;/code&gt; 不声明它。 &lt;code&gt;deprecated&lt;/code&gt; 属性， &lt;code&gt;error&lt;/code&gt; 和 &lt;code&gt;warning&lt;/code&gt; 禁止显示警告。（请参阅&lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;功能属性&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="9914fa32f31272fbd1b3c9fd5655fe7c161328ef" translate="yes" xml:space="preserve">
          <source>In C++, this attribute does not depend on &lt;code&gt;extern&lt;/code&gt; in any way, but it still requires the &lt;code&gt;inline&lt;/code&gt; keyword to enable its special behavior.</source>
          <target state="translated">在C ++中，此属性不以任何方式依赖于 &lt;code&gt;extern&lt;/code&gt; ，但是它仍然需要 &lt;code&gt;inline&lt;/code&gt; 关键字来启用其特殊行为。</target>
        </trans-unit>
        <trans-unit id="1330ec9305a2cf36952504f041eeaa71d08a1559" translate="yes" xml:space="preserve">
          <source>In C++, this pragma silently applies only to declarations with &amp;ldquo;C&amp;rdquo; linkage. Again, &lt;code&gt;asm&lt;/code&gt; labels do not have this restriction.</source>
          <target state="translated">在C ++中，此编译指示仅适用于具有&amp;ldquo; C&amp;rdquo;链接的声明。同样， &lt;code&gt;asm&lt;/code&gt; 标签没有此限制。</target>
        </trans-unit>
        <trans-unit id="4f1560146bfb02b0050b7346bcee56f1168f8456" translate="yes" xml:space="preserve">
          <source>In C++, this switch only affects the &lt;code&gt;typeof&lt;/code&gt; keyword, since &lt;code&gt;asm&lt;/code&gt; and &lt;code&gt;inline&lt;/code&gt; are standard keywords. You may want to use the</source>
          <target state="translated">在C ++中，此开关仅影响 &lt;code&gt;typeof&lt;/code&gt; 关键字，因为 &lt;code&gt;asm&lt;/code&gt; 和 &lt;code&gt;inline&lt;/code&gt; 是标准关键字。您可能要使用</target>
        </trans-unit>
        <trans-unit id="83513182660c016337c6a43ced48177d4ad0ef0c" translate="yes" xml:space="preserve">
          <source>In C++, you can mark member functions and static member variables of a class with the visibility attribute. This is useful if you know a particular method or static member variable should only be used from one shared object; then you can mark it hidden while the rest of the class has default visibility. Care must be taken to avoid breaking the One Definition Rule; for example, it is usually not useful to mark an inline method as hidden without marking the whole class as hidden.</source>
          <target state="translated">在C++中,你可以用可见性属性标记一个类的成员函数和静态成员变量。如果你知道一个特定的方法或静态成员变量应该只从一个共享对象中使用,那么这很有用;然后你可以将它标记为隐藏,而类的其他部分具有默认可见性。必须注意避免破坏 &quot;一个定义规则&quot;;例如,在没有将整个类标记为隐藏的情况下,将一个内联方法标记为隐藏通常是没有用的。</target>
        </trans-unit>
        <trans-unit id="1263d4b3bd19eaa09ddd9de78312a5a79d915aa7" translate="yes" xml:space="preserve">
          <source>In C++14, &lt;code&gt;f&lt;/code&gt; calls &lt;code&gt;f&amp;lt;void(*)()&amp;gt;&lt;/code&gt;, but in C++17 it calls &lt;code&gt;f&amp;lt;void(*)()noexcept&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">在C ++ 14中， &lt;code&gt;f&lt;/code&gt; 调用 &lt;code&gt;f&amp;lt;void(*)()&amp;gt;&lt;/code&gt; ，但在C ++ 17中它调用 &lt;code&gt;f&amp;lt;void(*)()noexcept&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a3eaf8f9d1fd2934be9e06d429d221c630b5bf0a" translate="yes" xml:space="preserve">
          <source>In C++17, the compiler is required to omit these temporaries, but this option still affects trivial member functions.</source>
          <target state="translated">在C++17中,编译器被要求省略这些时序,但这个选项仍然会影响琐碎的成员函数。</target>
        </trans-unit>
        <trans-unit id="2fd9362a64ee90151b4f33ed9f7535e5f0047820" translate="yes" xml:space="preserve">
          <source>In C, &lt;code&gt;__PRETTY_FUNCTION__&lt;/code&gt; is yet another name for &lt;code&gt;__func__&lt;/code&gt;, except that at file (or, in C++, namespace scope), it evaluates to the string &lt;code&gt;&quot;top level&quot;&lt;/code&gt;. In addition, in C++, &lt;code&gt;__PRETTY_FUNCTION__&lt;/code&gt; contains the signature of the function as well as its bare name. For example, this program:</source>
          <target state="translated">在C中， &lt;code&gt;__PRETTY_FUNCTION__&lt;/code&gt; &lt;code&gt;__func__&lt;/code&gt; 是__func__的另一个名称，除了在文件（或在C ++中，名称空间范围）中，它的计算结果为字符串 &lt;code&gt;&quot;top level&quot;&lt;/code&gt; 。另外，在C ++中， &lt;code&gt;__PRETTY_FUNCTION__&lt;/code&gt; 包含函数的签名及其裸名。例如，该程序：</target>
        </trans-unit>
        <trans-unit id="89c3cbeabc9fb0c94d32392b571a5dbe1ffa12b0" translate="yes" xml:space="preserve">
          <source>In C, a compound literal designates an unnamed object with static or automatic storage duration. In C++, a compound literal designates a temporary object that only lives until the end of its full-expression. As a result, well-defined C code that takes the address of a subobject of a compound literal can be undefined in C++, so G++ rejects the conversion of a temporary array to a pointer. For instance, if the array compound literal example above appeared inside a function, any subsequent use of &lt;code&gt;foo&lt;/code&gt; in C++ would have undefined behavior because the lifetime of the array ends after the declaration of &lt;code&gt;foo&lt;/code&gt;.</source>
          <target state="translated">在C中，复合文字表示具有静态或自动存储持续时间的未命名对象。在C ++中，复合文字表示一个临时对象，该对象仅在其完整表达式结束之前一直存在。结果，可以在C ++中未定义定义良好的C代码（采用复合文字的子对象的地址），因此G ++拒绝将临时数组转换为指针。例如，如果上面的数组复合文字示例出现在函数内部，则C ++中对 &lt;code&gt;foo&lt;/code&gt; 的任何后续使用都将具有未定义的行为，因为数组的生存期在声明 &lt;code&gt;foo&lt;/code&gt; 之后结束。</target>
        </trans-unit>
        <trans-unit id="b955553d29e649b19193fbacbc412a24a27d538d" translate="yes" xml:space="preserve">
          <source>In C, emit &lt;code&gt;static&lt;/code&gt; functions that are declared &lt;code&gt;inline&lt;/code&gt; into the object file, even if the function has been inlined into all of its callers. This switch does not affect functions using the &lt;code&gt;extern inline&lt;/code&gt; extension in GNU C90. In C++, emit any and all inline functions into the object file.</source>
          <target state="translated">在C语言中，发出被 &lt;code&gt;inline&lt;/code&gt; 声明到目标文件中的 &lt;code&gt;static&lt;/code&gt; 函数，即使该函数已内联到其所有调用程序中。此开关不影响使用GNU C90中的 &lt;code&gt;extern inline&lt;/code&gt; 扩展名的功能。在C ++中，将任何和所有内联函数发送到目标文件中。</target>
        </trans-unit>
        <trans-unit id="3058a9d60ea1ade68bb14049e675f5bf83c7026b" translate="yes" xml:space="preserve">
          <source>In C, if the function is neither &lt;code&gt;extern&lt;/code&gt; nor &lt;code&gt;static&lt;/code&gt;, then the function is compiled as a standalone function, as well as being inlined where possible.</source>
          <target state="translated">在C语言中，如果函数既不是 &lt;code&gt;extern&lt;/code&gt; 也不是 &lt;code&gt;static&lt;/code&gt; ，则该函数将编译为独立函数，并在可能的情况下内联。</target>
        </trans-unit>
        <trans-unit id="e352da7bd9ce1ec016de9e2458664a9340519a89" translate="yes" xml:space="preserve">
          <source>In C/C++, every &lt;code&gt;else&lt;/code&gt; branch belongs to the innermost possible &lt;code&gt;if&lt;/code&gt; statement, which in this example is &lt;code&gt;if (b)&lt;/code&gt;. This is often not what the programmer expected, as illustrated in the above example by indentation the programmer chose. When there is the potential for this confusion, GCC issues a warning when this flag is specified. To eliminate the warning, add explicit braces around the innermost &lt;code&gt;if&lt;/code&gt; statement so there is no way the &lt;code&gt;else&lt;/code&gt; can belong to the enclosing &lt;code&gt;if&lt;/code&gt;. The resulting code looks like this:</source>
          <target state="translated">在C / C ++中，每个 &lt;code&gt;else&lt;/code&gt; 分支都属于最里面的 &lt;code&gt;if&lt;/code&gt; 语句，在此示例中为 &lt;code&gt;if (b)&lt;/code&gt; 。如上例中程序员选择的缩进所示，这通常不是程序员期望的。如果有可能造成这种混乱，则在指定此标志时，GCC会发出警告。为了消除警告，请在最里面的 &lt;code&gt;if&lt;/code&gt; 语句周围添加大括号，以便 &lt;code&gt;else&lt;/code&gt; 不能属于封闭的 &lt;code&gt;if&lt;/code&gt; 。产生的代码如下所示：</target>
        </trans-unit>
        <trans-unit id="69cc3b441acbdbe11472c325735b27c046d27c5c" translate="yes" xml:space="preserve">
          <source>In G++, the result value of a statement expression undergoes array and function pointer decay, and is returned by value to the enclosing expression. For instance, if &lt;code&gt;A&lt;/code&gt; is a class, then</source>
          <target state="translated">在G ++中，语句表达式的结果值经历数组和函数指针的衰减，并按值返回到封闭的表达式。例如，如果 &lt;code&gt;A&lt;/code&gt; 是一个类，则</target>
        </trans-unit>
        <trans-unit id="2b79b7c58963843a8ca543d9e2a4ed22f6af9388" translate="yes" xml:space="preserve">
          <source>In GNU C and C++, you can use function attributes to specify certain function properties that may help the compiler optimize calls or check code more carefully for correctness. For example, you can use attributes to specify that a function never returns (&lt;code&gt;noreturn&lt;/code&gt;), returns a value depending only on the values of its arguments (&lt;code&gt;const&lt;/code&gt;), or has &lt;code&gt;printf&lt;/code&gt;-style arguments (&lt;code&gt;format&lt;/code&gt;).</source>
          <target state="translated">在GNU C和C ++中，可以使用函数属性来指定某些函数属性，这些属性可以帮助编译器优化调用或更仔细地检查代码的正确性。例如，您可以使用属性来指定函数从不返回（ &lt;code&gt;noreturn&lt;/code&gt; ），仅根据其参数的值（ &lt;code&gt;const&lt;/code&gt; ）返回值或具有 &lt;code&gt;printf&lt;/code&gt; 样式的参数（ &lt;code&gt;format&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="099e4a52fb6ed11fab7818dcdc84803658fe6ac9" translate="yes" xml:space="preserve">
          <source>In GNU C, addition and subtraction operations are supported on pointers to &lt;code&gt;void&lt;/code&gt; and on pointers to functions. This is done by treating the size of a &lt;code&gt;void&lt;/code&gt; or of a function as 1.</source>
          <target state="translated">在GNU C中，指向 &lt;code&gt;void&lt;/code&gt; 的指针和指向函数的指针支持加法和减法运算。通过将 &lt;code&gt;void&lt;/code&gt; 或函数的大小视为1 来完成此操作。</target>
        </trans-unit>
        <trans-unit id="cca3c66936552d4dc4ee0493549030694bbe3a79" translate="yes" xml:space="preserve">
          <source>In GNU C, an attribute specifier list may appear after the colon following a label, other than a &lt;code&gt;case&lt;/code&gt; or &lt;code&gt;default&lt;/code&gt; label. GNU C++ only permits attributes on labels if the attribute specifier is immediately followed by a semicolon (i.e., the label applies to an empty statement). If the semicolon is missing, C++ label attributes are ambiguous, as it is permissible for a declaration, which could begin with an attribute list, to be labelled in C++. Declarations cannot be labelled in C90 or C99, so the ambiguity does not arise there.</source>
          <target state="translated">在GNU C中，属性说明符列表可能会出现在冒号之后的标签之后，而不是 &lt;code&gt;case&lt;/code&gt; 或 &lt;code&gt;default&lt;/code&gt; 标签。如果属性说明符后紧跟一个分号（即，标签适用于空语句），则GNU C ++仅允许标签上的属性。如果缺少分号，则C ++标签属性是不明确的，因为声明可以使用C ++进行标记，该声明可以以属性列表开头。声明不能在C90或C99中标记，因此不会在此处引起歧义。</target>
        </trans-unit>
        <trans-unit id="00f091378926e345c0e4332aa146832525cddb05" translate="yes" xml:space="preserve">
          <source>In GNU C, an attribute specifier list may appear as part of a null statement. The attribute goes before the semicolon.</source>
          <target state="translated">在GNU C中,属性指定器列表可以作为null语句的一部分出现。属性放在分号之前。</target>
        </trans-unit>
        <trans-unit id="1b43625a41fcbb3b41411d6343924dd766870911" translate="yes" xml:space="preserve">
          <source>In GNU C, an attribute specifier list may appear as part of an enumerator. The attribute goes after the enumeration constant, before &lt;code&gt;=&lt;/code&gt;, if present. The optional attribute in the enumerator appertains to the enumeration constant. It is not possible to place the attribute after the constant expression, if present.</source>
          <target state="translated">在GNU C中，属性说明符列表可能作为枚举器的一部分出现。该属性位于枚举常量之后 &lt;code&gt;=&lt;/code&gt; 之前（如果存在）。枚举器中的可选属性与枚举常量有关。如果存在，则无法将属性放在常量表达式之后。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
