<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="gcc">
    <body>
      <group id="gcc">
        <trans-unit id="1fc88c33c3fc53124fa0f92092082efc85a7cdc0" translate="yes" xml:space="preserve">
          <source>Generate GP-relative accesses for small data objects that are not external, weak, or uninitialized common symbols. Also use GP-relative addressing for objects that have been explicitly placed in a small data section via a &lt;code&gt;section&lt;/code&gt; attribute.</source>
          <target state="translated">为不是外部符号，弱符号或未初始化的通用符号的小型数据对象生成GP相对访问。对于通过 &lt;code&gt;section&lt;/code&gt; 属性明确放置在小数据段中的对象，也请使用GP相对寻址。</target>
        </trans-unit>
        <trans-unit id="548a87f5ac4837154b7b55bf3a0684dbbd7b3056" translate="yes" xml:space="preserve">
          <source>Generate GP-relative addresses for function pointers as well as data pointers. If you use this option, the entire text, data, and BSS segments of your program must fit in 64K of memory and you must use an appropriate linker script to allocate them within the addressable range of the global pointer.</source>
          <target state="translated">为函数指针以及数据指针生成GP相关地址。如果你使用这个选项,你的程序中的整个文本、数据和BSS段必须放在64K的内存中,你必须使用适当的链接器脚本在全局指针的可寻址范围内分配它们。</target>
        </trans-unit>
        <trans-unit id="9f3a196b430f925ff0ff89b9ccb1a7bf625049d2" translate="yes" xml:space="preserve">
          <source>Generate MIPS16 code on alternating functions. This option is provided for regression testing of mixed MIPS16/non-MIPS16 code generation, and is not intended for ordinary use in compiling user code.</source>
          <target state="translated">在交替函数上生成MIPS16代码。这个选项是为MIPS16/非MIPS16混合代码生成的回归测试而提供的,并不打算在编译用户代码时普通使用。</target>
        </trans-unit>
        <trans-unit id="b7aa3b59b611b18a6a4ec60f9d9a319cc049bd6b" translate="yes" xml:space="preserve">
          <source>Generate PowerPC64 code for the large model: The TOC may be up to 4G in size. Other data and code is only limited by the 64-bit address space.</source>
          <target state="translated">生成大型号的PowerPC64代码。TOC的大小可以达到4G。其他数据和代码只受64位地址空间的限制。</target>
        </trans-unit>
        <trans-unit id="c7a74518f21d3c00aafcfd3b084cf7c00aee1848" translate="yes" xml:space="preserve">
          <source>Generate PowerPC64 code for the medium model: The TOC and other static data may be up to a total of 4G in size. This is the default for 64-bit Linux.</source>
          <target state="translated">生成中等型号的PowerPC64代码。TOC和其他静态数据可以达到4G的总大小。这是64位Linux的默认值。</target>
        </trans-unit>
        <trans-unit id="8cfde8c4df8b2eb989bc818febefc0e7c28874e7" translate="yes" xml:space="preserve">
          <source>Generate PowerPC64 code for the small model: The TOC is limited to 64k.</source>
          <target state="translated">生成小模型的PowerPC64代码。TOC限制在64k以内。</target>
        </trans-unit>
        <trans-unit id="c7ea62356cd3157102c66b58a868e34df2a5c060" translate="yes" xml:space="preserve">
          <source>Generate VRSAVE instructions when generating AltiVec code.</source>
          <target state="translated">在生成AltiVec代码时,生成VRSAVE指令。</target>
        </trans-unit>
        <trans-unit id="0bd45272345d657871ab9cf111cdd01907672885" translate="yes" xml:space="preserve">
          <source>Generate a __return_loc section pointing to all return instrumentation code.</source>
          <target state="translated">生成一个指向所有返回工具代码的__return_loc部分。</target>
        </trans-unit>
        <trans-unit id="2cf42b0393916fe85d4396c2a4ea44c0c0b17c4a" translate="yes" xml:space="preserve">
          <source>Generate a call to the function &lt;code&gt;abort&lt;/code&gt; at the end of a &lt;code&gt;noreturn&lt;/code&gt; function. It is executed if the function tries to return.</source>
          <target state="translated">在 &lt;code&gt;noreturn&lt;/code&gt; 函数结束时生成对函数 &lt;code&gt;abort&lt;/code&gt; 的调用。如果函数尝试返回，则执行它。</target>
        </trans-unit>
        <trans-unit id="0bfebab0f7716c6c7d48b3db2e26f828205f2eb0" translate="yes" xml:space="preserve">
          <source>Generate a stack frame that is compliant with the ARM Procedure Call Standard for all functions, even if this is not strictly necessary for correct execution of the code. Specifying</source>
          <target state="translated">为所有函数生成符合ARM过程调用标准的堆栈框架,即使这对于正确执行代码并非严格必要。指定</target>
        </trans-unit>
        <trans-unit id="09e70235b2ae102fe1ff7ae3b745820674b997a0" translate="yes" xml:space="preserve">
          <source>Generate a stack frame that is compliant with the Thumb Procedure Call Standard for all leaf functions. (A leaf function is one that does not call any other functions.) The default is</source>
          <target state="translated">为所有叶函数生成一个符合Thumb Procedure Call Standard标准的堆栈框架。(叶函数是指不调用任何其他函数的函数。)默认值是</target>
        </trans-unit>
        <trans-unit id="4e955728a6de82a9bddec4fed62b648dcfc40e9a" translate="yes" xml:space="preserve">
          <source>Generate a stack frame that is compliant with the Thumb Procedure Call Standard for all non-leaf functions. (A leaf function is one that does not call any other functions.) The default is</source>
          <target state="translated">为所有非叶函数生成一个符合Thumb Procedure Call Standard标准的堆栈框架。叶函数是指不调用任何其他函数的函数。)默认是</target>
        </trans-unit>
        <trans-unit id="4839b3bf0bbd769aa7c0e4fcd67cdaaed9746bd5" translate="yes" xml:space="preserve">
          <source>Generate an executable in the ELF format, rather than the default &amp;lsquo;</source>
          <target state="translated">生成ELF格式的可执行文件，而不是默认的'</target>
        </trans-unit>
        <trans-unit id="6c98697c08dfd7f201b6b9c98efc4af59466b6c7" translate="yes" xml:space="preserve">
          <source>Generate an inline expansion using loop code for all block compares that are less than or equal to &lt;var&gt;num&lt;/var&gt; bytes, but greater than the limit for non-loop inline block compare expansion. If the block length is not constant, at most &lt;var&gt;num&lt;/var&gt; bytes will be compared before &lt;code&gt;memcmp&lt;/code&gt; is called to compare the remainder of the block. The default value is target-specific.</source>
          <target state="translated">使用循环代码为小于或等于 &lt;var&gt;num&lt;/var&gt; 字节但大于非循环内联块比较扩展限制的所有块比较生成内联扩展。如果块长度不是恒定的，则在调用 &lt;code&gt;memcmp&lt;/code&gt; 来比较块的其余部分之前，最多将比较 &lt;var&gt;num&lt;/var&gt; 个字节。默认值为特定于目标的。</target>
        </trans-unit>
        <trans-unit id="ee53ff6577ff7bdeec45265bba557ddc96dc42d1" translate="yes" xml:space="preserve">
          <source>Generate big-endian code.</source>
          <target state="translated">生成大段代码。</target>
        </trans-unit>
        <trans-unit id="faa1ec28121e6f94c7459039f3f456a29482ffe4" translate="yes" xml:space="preserve">
          <source>Generate big-endian code. This is the default for &amp;lsquo;</source>
          <target state="translated">生成大端代码。这是&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="497dec8a0e83106900bb3f13f33208ac13cc564e" translate="yes" xml:space="preserve">
          <source>Generate big-endian code. This is the default when GCC is configured for an &amp;lsquo;</source>
          <target state="translated">生成大端代码。当将GCC配置为&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="9f5c216ca40ddba6d0b7e0356dfb54eddd239c13" translate="yes" xml:space="preserve">
          <source>Generate calls as register indirect calls, thus providing access to the full 32-bit address range.</source>
          <target state="translated">以寄存器间接调用的方式生成调用,从而提供对整个32位地址范围的访问。</target>
        </trans-unit>
        <trans-unit id="daf711e932fbd2a210fbf658c2ed048fe589f322" translate="yes" xml:space="preserve">
          <source>Generate checks for control speculation in selective scheduling. This flag is disabled by default.</source>
          <target state="translated">在选择性调度中生成控制推测的检查。该标志默认为禁用。</target>
        </trans-unit>
        <trans-unit id="340f82c2c0a45e961b4cd414df01b6dcda27429e" translate="yes" xml:space="preserve">
          <source>Generate code containing floating-point instructions. This is the default.</source>
          <target state="translated">生成包含浮点指令的代码。这是默认的。</target>
        </trans-unit>
        <trans-unit id="d1eb9be83c7705dec7853ee52d8e983f54f63d2c" translate="yes" xml:space="preserve">
          <source>Generate code containing library calls for floating-point.</source>
          <target state="translated">生成包含浮点函数库调用的代码。</target>
        </trans-unit>
        <trans-unit id="ffda305054ff95e7394bd4003326530b52f9583d" translate="yes" xml:space="preserve">
          <source>Generate code for 32-bit or 64-bit ABI.</source>
          <target state="translated">为32位或64位ABI生成代码。</target>
        </trans-unit>
        <trans-unit id="b67c6b7cf041ab09d12159e623bf4650fd97244d" translate="yes" xml:space="preserve">
          <source>Generate code for 32-bit or 64-bit environments of Darwin and SVR4 targets (including GNU/Linux). The 32-bit environment sets int, long and pointer to 32 bits and generates code that runs on any PowerPC variant. The 64-bit environment sets int to 32 bits and long and pointer to 64 bits, and generates code for PowerPC64, as for</source>
          <target state="translated">为Darwin和SVR4目标(包括GNU/Linux)的32位或64位环境生成代码。32位环境将int、long和指针设置为32位,并生成可在任何PowerPC变体上运行的代码。64位环境将int设置为32位,将long和指针设置为64位,并生成在PowerPC64上运行的代码,如为</target>
        </trans-unit>
        <trans-unit id="a4491a667cb7d0b6c838f6faaee6a864eadc20bd" translate="yes" xml:space="preserve">
          <source>Generate code for CR16C or CR16C+ architecture. CR16C+ architecture is default.</source>
          <target state="translated">生成CR16C或CR16C+架构的代码。CR16C+架构是默认的。</target>
        </trans-unit>
        <trans-unit id="67648931cfe6b959b11bf696abb5438c66a26217" translate="yes" xml:space="preserve">
          <source>Generate code for SH4-100 assuming the floating-point unit is in single-precision mode by default.</source>
          <target state="translated">假设浮点单元默认为单精度模式,生成SH4-100的代码。</target>
        </trans-unit>
        <trans-unit id="de1af2a9972c47a564f5e7fcce23d995d6ae1b8b" translate="yes" xml:space="preserve">
          <source>Generate code for SH4-100 in such a way that no double-precision floating-point operations are used.</source>
          <target state="translated">生成SH4-100的代码时,不使用双精度浮点运算。</target>
        </trans-unit>
        <trans-unit id="107ca25d9739e824d4175850436b6598a742f5a1" translate="yes" xml:space="preserve">
          <source>Generate code for SH4-100 in such a way that the floating-point unit is not used.</source>
          <target state="translated">以不使用浮点单元的方式生成SH4-100的代码。</target>
        </trans-unit>
        <trans-unit id="f4838bc707d842b8a2b2e768456d1b164bf348d3" translate="yes" xml:space="preserve">
          <source>Generate code for SH4-100.</source>
          <target state="translated">生成SH4-100的代码。</target>
        </trans-unit>
        <trans-unit id="eb7eb15dc4aa3c46b2283b182c63acf0a395433d" translate="yes" xml:space="preserve">
          <source>Generate code for SH4-200 assuming the floating-point unit is in single-precision mode by default.</source>
          <target state="translated">假设浮点单元默认为单精度模式,生成SH4-200的代码。</target>
        </trans-unit>
        <trans-unit id="c7c33168087299c03364283296e9feb1a533b788" translate="yes" xml:space="preserve">
          <source>Generate code for SH4-200 in such a way that no double-precision floating-point operations are used.</source>
          <target state="translated">生成SH4-200的代码时,不使用双精度浮点运算。</target>
        </trans-unit>
        <trans-unit id="b14c102c6af7d5f6fb411b3d326830a45f2aceb0" translate="yes" xml:space="preserve">
          <source>Generate code for SH4-200 without in such a way that the floating-point unit is not used.</source>
          <target state="translated">生成SH4-200的代码,不使用浮点单元。</target>
        </trans-unit>
        <trans-unit id="5283c23e1460ff21798ade4588312627145b49aa" translate="yes" xml:space="preserve">
          <source>Generate code for SH4-200.</source>
          <target state="translated">生成SH4-200的代码。</target>
        </trans-unit>
        <trans-unit id="2fb0dbc9dfbf231f5e57962b75a086351c1f46b3" translate="yes" xml:space="preserve">
          <source>Generate code for SH4-300 in such a way that no double-precision floating-point operations are used.</source>
          <target state="translated">生成SH4-300的代码,不使用双精度浮点运算。</target>
        </trans-unit>
        <trans-unit id="ff44e3f28e2fd7daaa679641ff86e04eab85fb68" translate="yes" xml:space="preserve">
          <source>Generate code for SH4-300 without in such a way that the floating-point unit is not used.</source>
          <target state="translated">生成SH4-300的代码,不使用浮点单元。</target>
        </trans-unit>
        <trans-unit id="5dd69911ae792e28eb1d16efd78aa149dec9b0b1" translate="yes" xml:space="preserve">
          <source>Generate code for SH4-300.</source>
          <target state="translated">生成SH4-300的代码。</target>
        </trans-unit>
        <trans-unit id="3190f28d97b238beea538765e992a0880400111e" translate="yes" xml:space="preserve">
          <source>Generate code for SH4-340 (no MMU, no FPU).</source>
          <target state="translated">生成SH4-340的代码(在MMU、FPU中)。</target>
        </trans-unit>
        <trans-unit id="964d89eec4f49e488b7e663bfb784df7de2d9807" translate="yes" xml:space="preserve">
          <source>Generate code for SH4-500 (no FPU). Passes</source>
          <target state="translated">为SH4-500(无FPU)生成代码。通过</target>
        </trans-unit>
        <trans-unit id="bd07f25b5dfd9dc83556617396ced4ced292840d" translate="yes" xml:space="preserve">
          <source>Generate code for Smart Mode, using only registers numbered 0-7 to allow use of 16-bit instructions. This option is ignored for CK801 where this is the required behavior, and it defaults to on for CK802. For other targets, the default is off.</source>
          <target state="translated">为智能模式生成代码,只使用编号为0-7的寄存器,允许使用16位指令。对于CK801来说,这个选项被忽略,因为这是必要的行为,而对于CK802来说,它的默认值是on。对于其他目标,默认为关闭。</target>
        </trans-unit>
        <trans-unit id="d1ef13a03c7e2ed855aab73fe845bb318c6bf94c" translate="yes" xml:space="preserve">
          <source>Generate code for a 16-bit, 32-bit or 64-bit environment. The</source>
          <target state="translated">为16位、32位或64位环境生成代码。该</target>
        </trans-unit>
        <trans-unit id="6f846bc35b4ddbb63662daaf0b8a0b9a36eafb1b" translate="yes" xml:space="preserve">
          <source>Generate code for a 32-bit environment, which sets int, long, and pointer to 32 bits. This is the only supported behavior so the flag is essentially ignored.</source>
          <target state="translated">生成32位环境的代码,将int、long和指针设置为32位。这是唯一支持的行为,所以该标志基本被忽略。</target>
        </trans-unit>
        <trans-unit id="c70fb6bc63f54c3dd3b6636fb15aabdae1032dda" translate="yes" xml:space="preserve">
          <source>Generate code for a 32-bit or 64-bit environment. The 32-bit environment sets int, long and pointer to 32 bits. The 64-bit environment sets int to 32 bits and long and pointer to 64 bits.</source>
          <target state="translated">为32位或64位环境生成代码。32位环境将int、long和指针设置为32位。64位环境将int设置为32位,long和指针设置为64位。</target>
        </trans-unit>
        <trans-unit id="25466413f97413255c5d54e631be1e6a23f5330d" translate="yes" xml:space="preserve">
          <source>Generate code for a 32-bit or 64-bit environment. The 32-bit environment sets int, long and pointer to 32 bits. The 64-bit environment sets int to 32 bits and long and pointer to 64 bits. These are HP-UX specific flags.</source>
          <target state="translated">为32位或64位环境生成代码。32位环境将int、long和指针设置为32位。64位环境将int设置为32位,long和指针设置为64位。这些是HP-UX特有的标志。</target>
        </trans-unit>
        <trans-unit id="89222a0849ae48c73c6bd1624ef4d88ea3c84874" translate="yes" xml:space="preserve">
          <source>Generate code for a 32-bit or 64-bit environment. The 32-bit environment sets int, long, and pointer to 32 bits. The 64-bit environment sets int to 32 bits and long and pointer to 64 bits.</source>
          <target state="translated">为32位或64位环境生成代码。32位环境将int、long和指针设置为32位。64位环境将int设置为32位,long和指针设置为64位。</target>
        </trans-unit>
        <trans-unit id="7a6899675bc409f91ebf1c2951874d09f2171d0a" translate="yes" xml:space="preserve">
          <source>Generate code for a PDP-11/10. Implies -msoft-float -mno-split.</source>
          <target state="translated">为PDP-11/10生成代码。意味着-msoft-float -mno-split。</target>
        </trans-unit>
        <trans-unit id="bee1deaf455b6a6b4cdb2bb13d6ee23ad81f5012" translate="yes" xml:space="preserve">
          <source>Generate code for a PDP-11/40. Implies -msoft-float -mno-split.</source>
          <target state="translated">生成PDP-11/40的代码。意味着-msoft-float -mno-split。</target>
        </trans-unit>
        <trans-unit id="d9780d13a5a51c47480c939a428413699ac3ed17" translate="yes" xml:space="preserve">
          <source>Generate code for a PDP-11/45. This is the default.</source>
          <target state="translated">生成PDP-11/45的代码。这是默认的。</target>
        </trans-unit>
        <trans-unit id="92b920e8ba8535d90a16588551ee999d568f0291" translate="yes" xml:space="preserve">
          <source>Generate code for a big-endian target.</source>
          <target state="translated">生成大段目标的代码。</target>
        </trans-unit>
        <trans-unit id="d68254cfeddff60f3b9cadfb72e8acbde8b8a455" translate="yes" xml:space="preserve">
          <source>Generate code for a big-endian target. This is the default for HP-UX.</source>
          <target state="translated">生成大段目标的代码,这是HP-UX的默认值。这是HP-UX的默认值。</target>
        </trans-unit>
        <trans-unit id="5fbe216af63a08f8f99c457d81f72aa33271a249" translate="yes" xml:space="preserve">
          <source>Generate code for a little-endian target.</source>
          <target state="translated">生成一个小二烯目标的代码。</target>
        </trans-unit>
        <trans-unit id="7fec6c67ff3977f6cbf34379a4b039899b9238d9" translate="yes" xml:space="preserve">
          <source>Generate code for a little-endian target. This is the default for AIX5 and GNU/Linux.</source>
          <target state="translated">生成一个小迭代目标的代码,这是AIX5和GNU/Linux的默认值。这是AIX5和GNU/Linux的默认值。</target>
        </trans-unit>
        <trans-unit id="12a32136f06def3f80692a9e99c0d8f9b7d0b140" translate="yes" xml:space="preserve">
          <source>Generate code for a little-endian target. This is the default.</source>
          <target state="translated">生成小段目标的代码。这是默认的。</target>
        </trans-unit>
        <trans-unit id="86cf4bd8b15db1a7bae18b7503fdfe578d14ff3d" translate="yes" xml:space="preserve">
          <source>Generate code for a processor running in big-endian mode; the default is to compile code for a little-endian processor.</source>
          <target state="translated">为运行在big-endian模式下的处理器生成代码;默认情况下是为little-endian处理器编译代码。</target>
        </trans-unit>
        <trans-unit id="b9c63b6f7dde24a56bfd3b0c8c39dff387d09612" translate="yes" xml:space="preserve">
          <source>Generate code for a processor running in little-endian mode. This is the default for all standard configurations.</source>
          <target state="translated">为运行在小段模式下的处理器生成代码。这是所有标准配置的默认值。</target>
        </trans-unit>
        <trans-unit id="7c9d614db21563decf26e4450a12e8ff0db080a3" translate="yes" xml:space="preserve">
          <source>Generate code for a specific M680x0 or ColdFire instruction set architecture. Permissible values of &lt;var&gt;arch&lt;/var&gt; for M680x0 architectures are: &amp;lsquo;</source>
          <target state="translated">为特定的M680x0或ColdFire指令集架构生成代码。M680x0架构允许的 &lt;var&gt;arch&lt;/var&gt; 值为：'</target>
        </trans-unit>
        <trans-unit id="4756b1c10e780d22755d4efd055be671187986d0" translate="yes" xml:space="preserve">
          <source>Generate code for a specific M680x0 or ColdFire processor. The M680x0 &lt;var&gt;cpu&lt;/var&gt;s are: &amp;lsquo;</source>
          <target state="translated">为特定的M680x0或ColdFire处理器生成代码。M680x0 &lt;var&gt;cpu&lt;/var&gt; 为：</target>
        </trans-unit>
        <trans-unit id="cf0efda24e55f61b98734329e006dab8159c05d8" translate="yes" xml:space="preserve">
          <source>Generate code for given RISC-V ISA (e.g. &amp;lsquo;</source>
          <target state="translated">为给定的RISC-V ISA生成代码（例如，&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="1cc9f255978b92385d0966d847bc3f1f4feff36e" translate="yes" xml:space="preserve">
          <source>Generate code for given the specified PTX ISA (e.g. &amp;lsquo;</source>
          <target state="translated">为给定的指定PTX ISA生成代码（例如，&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="4b8a962abd2bc5357f263a724ad7ce6201860ac4" translate="yes" xml:space="preserve">
          <source>Generate code for hardware which requires divide instruction emulation.</source>
          <target state="translated">为需要除法指令仿真的硬件生成代码。</target>
        </trans-unit>
        <trans-unit id="0ff05f7bfb6de148dd31e5b918468ff58be8cc2b" translate="yes" xml:space="preserve">
          <source>Generate code for hardware which requires multiply instruction emulation.</source>
          <target state="translated">为需要乘法指令仿真的硬件生成代码。</target>
        </trans-unit>
        <trans-unit id="9d141b4aab656e3ada981384fd6736554ccf4fe3" translate="yes" xml:space="preserve">
          <source>Generate code for hardware which supports divide instructions. This is the default.</source>
          <target state="translated">为支持除法指令的硬件生成代码。这是默认的。</target>
        </trans-unit>
        <trans-unit id="63b8cd12a9a7b77524e7516bc8342264efc809e2" translate="yes" xml:space="preserve">
          <source>Generate code for hardware which supports multiply instructions. This is the default.</source>
          <target state="translated">为支持乘法指令的硬件生成代码。这是默认的。</target>
        </trans-unit>
        <trans-unit id="f67b905d0c7d601714b6d40130d650c8841556d5" translate="yes" xml:space="preserve">
          <source>Generate code for hardware which supports rotate right instructions.</source>
          <target state="translated">为支持右旋指令的硬件生成代码。</target>
        </trans-unit>
        <trans-unit id="d8901265c038359c4cabcecef69c62a4ad403284" translate="yes" xml:space="preserve">
          <source>Generate code for hardware which supports set flag immediate (&lt;code&gt;l.sf*i&lt;/code&gt;) instructions.</source>
          <target state="translated">为支持设置标志立即数（ &lt;code&gt;l.sf*i&lt;/code&gt; ）指令的硬件生成代码。</target>
        </trans-unit>
        <trans-unit id="cb0dc185d9cce6eac6a0da7c5fde4468c232eb00" translate="yes" xml:space="preserve">
          <source>Generate code for hardware which supports shift immediate related instructions (i.e. &lt;code&gt;l.srai&lt;/code&gt;, &lt;code&gt;l.srli&lt;/code&gt;, &lt;code&gt;l.slli&lt;/code&gt;, &lt;code&gt;1.rori&lt;/code&gt;). Note, to enable generation of the &lt;code&gt;l.rori&lt;/code&gt; instruction the</source>
          <target state="translated">为支持移位立即相关指令的硬件生成代码（即 &lt;code&gt;l.srai&lt;/code&gt; ， &lt;code&gt;l.srli&lt;/code&gt; ， &lt;code&gt;l.slli&lt;/code&gt; ， &lt;code&gt;1.rori&lt;/code&gt; ）。注意，要启用生成 &lt;code&gt;l.rori&lt;/code&gt; 指令，</target>
        </trans-unit>
        <trans-unit id="56c0dd74c2b5f08d1195605802098a996d48ddaa" translate="yes" xml:space="preserve">
          <source>Generate code for hardware which supports sign-extension instructions.</source>
          <target state="translated">为支持符号扩展指令的硬件生成代码。</target>
        </trans-unit>
        <trans-unit id="c6c9d0431f616f47453feb5bcfe61cef592a68b7" translate="yes" xml:space="preserve">
          <source>Generate code for hardware which supports the conditional move (&lt;code&gt;l.cmov&lt;/code&gt;) instruction.</source>
          <target state="translated">为支持条件移动（ &lt;code&gt;l.cmov&lt;/code&gt; ）指令的硬件生成代码。</target>
        </trans-unit>
        <trans-unit id="bf79d7ac3430cd100137adc751a91365b039edd3" translate="yes" xml:space="preserve">
          <source>Generate code for inline divides of floating-point values using the maximum throughput algorithm.</source>
          <target state="translated">使用最大吞吐量算法生成浮点值内联除法的代码。</target>
        </trans-unit>
        <trans-unit id="3cedd11fcbf120218332b498654e7e4160f8c76d" translate="yes" xml:space="preserve">
          <source>Generate code for inline divides of floating-point values using the minimum latency algorithm.</source>
          <target state="translated">使用最小延迟算法生成浮点值内联除法的代码。</target>
        </trans-unit>
        <trans-unit id="1cc7790f16d0c4d4d91471e6f5d653df0c747e44" translate="yes" xml:space="preserve">
          <source>Generate code for inline divides of integer values using the maximum throughput algorithm.</source>
          <target state="translated">使用最大吞吐量算法生成整数值内联除法的代码。</target>
        </trans-unit>
        <trans-unit id="faf94b4d20f983cdf533f47ec33942d0ce63586d" translate="yes" xml:space="preserve">
          <source>Generate code for inline divides of integer values using the minimum latency algorithm.</source>
          <target state="translated">使用最小延迟算法生成整数值内联除法的代码。</target>
        </trans-unit>
        <trans-unit id="5418fa0a1b1b281d2485d7060d2309afdebd6ff4" translate="yes" xml:space="preserve">
          <source>Generate code for inline square roots using the maximum throughput algorithm.</source>
          <target state="translated">使用最大吞吐量算法生成内联方根的代码。</target>
        </trans-unit>
        <trans-unit id="83ef176a0741f8d1f5fe6e111f7583e6807956ad" translate="yes" xml:space="preserve">
          <source>Generate code for inline square roots using the minimum latency algorithm.</source>
          <target state="translated">使用最小延迟算法生成内联平方根的代码。</target>
        </trans-unit>
        <trans-unit id="00979759a61ef121145bed1163bfbd0399a7b98b" translate="yes" xml:space="preserve">
          <source>Generate code for long address mode. This is only supported for 64-bit and x32 environments. It is the default address mode for 64-bit environments.</source>
          <target state="translated">生成长地址模式的代码。这只支持64位和x32环境。它是64位环境的默认地址模式。</target>
        </trans-unit>
        <trans-unit id="8adaf3135394010293585c029db12629ab7fdcf7" translate="yes" xml:space="preserve">
          <source>Generate code for short address mode. This is only supported for 32-bit and x32 environments. It is the default address mode for 32-bit and x32 environments.</source>
          <target state="translated">生成短地址模式的代码。这只支持32位和x32环境。这是32位和x32环境的默认地址模式。</target>
        </trans-unit>
        <trans-unit id="694f6014654115d073cccf62f6b995dc2510f9c1" translate="yes" xml:space="preserve">
          <source>Generate code for the 210 processor.</source>
          <target state="translated">为210处理器生成代码。</target>
        </trans-unit>
        <trans-unit id="85e35fc91e0af86a193c565f8d6f2a96d089e373" translate="yes" xml:space="preserve">
          <source>Generate code for the C-SKY compiler runtime instead of libgcc. This option defaults to off.</source>
          <target state="translated">为C-SKY编译器运行时生成代码,而不是libgcc。这个选项的默认值是off。</target>
        </trans-unit>
        <trans-unit id="27e854c2e0908c3f4c936f01364c648aa32b367c" translate="yes" xml:space="preserve">
          <source>Generate code for the H8/300H.</source>
          <target state="translated">生成H8/300H的代码。</target>
        </trans-unit>
        <trans-unit id="bb83090e60c2fc757a89c80487c241185ee5d95a" translate="yes" xml:space="preserve">
          <source>Generate code for the H8S and H8/300H in the normal mode. This switch must be used either with</source>
          <target state="translated">在正常模式下为H8S和H8/300H生成代码。该开关必须与</target>
        </trans-unit>
        <trans-unit id="d052e6239d8f301fe0a2b7da20c249087f96d45d" translate="yes" xml:space="preserve">
          <source>Generate code for the H8S.</source>
          <target state="translated">生成H8S的代码。</target>
        </trans-unit>
        <trans-unit id="6d5ff3e2bd91c0a262161bf6efa2cdef6971233e" translate="yes" xml:space="preserve">
          <source>Generate code for the H8S/2600. This switch must be used with</source>
          <target state="translated">生成H8S/2600的代码。该开关必须与</target>
        </trans-unit>
        <trans-unit id="d28ff0fda5a5612fbf86e8ebd7c80cabd4110b85" translate="yes" xml:space="preserve">
          <source>Generate code for the M32R. This is the default.</source>
          <target state="translated">为M32R生成代码。这是默认的。</target>
        </trans-unit>
        <trans-unit id="20e08fc2eddd3584a33dc2a59b26172bf1281828" translate="yes" xml:space="preserve">
          <source>Generate code for the M32R/2.</source>
          <target state="translated">生成M32R/2的代码。</target>
        </trans-unit>
        <trans-unit id="1939be789de09c47e008a34d88743773021de724" translate="yes" xml:space="preserve">
          <source>Generate code for the M32R/X.</source>
          <target state="translated">为M32R/X生成代码。</target>
        </trans-unit>
        <trans-unit id="df8817f533054f34d7acf449e4e33f38657d304e" translate="yes" xml:space="preserve">
          <source>Generate code for the SH1.</source>
          <target state="translated">生成SH1的代码。</target>
        </trans-unit>
        <trans-unit id="050479be73754de25483a6e1712e26489d053e34" translate="yes" xml:space="preserve">
          <source>Generate code for the SH2.</source>
          <target state="translated">生成SH2的代码。</target>
        </trans-unit>
        <trans-unit id="3723c95f415c4a4c6a69d66a7f758a27732147a1" translate="yes" xml:space="preserve">
          <source>Generate code for the SH2a without FPU, or for a SH2a-FPU in such a way that the floating-point unit is not used.</source>
          <target state="translated">生成没有FPU的SH2a的代码,或者不用浮点单元的SH2a-FPU的代码。</target>
        </trans-unit>
        <trans-unit id="bc412156cf20c916e946ffa4cbe84584eb6567a5" translate="yes" xml:space="preserve">
          <source>Generate code for the SH2a-FPU assuming the floating-point unit is in double-precision mode by default.</source>
          <target state="translated">生成SH2a-FPU的代码,假设浮点单元默认为双精度模式。</target>
        </trans-unit>
        <trans-unit id="34abdbdae2fa95db6713e96853be2eca7e9c05eb" translate="yes" xml:space="preserve">
          <source>Generate code for the SH2a-FPU assuming the floating-point unit is in single-precision mode by default.</source>
          <target state="translated">生成SH2a-FPU的代码,假设浮点单元默认为单精度模式。</target>
        </trans-unit>
        <trans-unit id="1f2673d8ddd54030d4d4878de69f24422a5fdba0" translate="yes" xml:space="preserve">
          <source>Generate code for the SH2a-FPU, in such a way that no double-precision floating-point operations are used.</source>
          <target state="translated">为SH2a-FPU生成代码,不使用双精度浮点运算。</target>
        </trans-unit>
        <trans-unit id="483cb3ca44e923a4b1df433858f80751ca9f93aa" translate="yes" xml:space="preserve">
          <source>Generate code for the SH2e.</source>
          <target state="translated">生成SH2e的代码。</target>
        </trans-unit>
        <trans-unit id="1a936c359ffaab90c574043388b2920044ce94c5" translate="yes" xml:space="preserve">
          <source>Generate code for the SH3.</source>
          <target state="translated">生成SH3的代码。</target>
        </trans-unit>
        <trans-unit id="52624bfb24aef64a24903a711fc58d43129edfce" translate="yes" xml:space="preserve">
          <source>Generate code for the SH3e.</source>
          <target state="translated">生成SH3e的代码。</target>
        </trans-unit>
        <trans-unit id="3974fd9acf25ff513cb6f41c5bd4a7bda9784a55" translate="yes" xml:space="preserve">
          <source>Generate code for the SH4 assuming the floating-point unit is in single-precision mode by default.</source>
          <target state="translated">假设浮点单元默认为单精度模式,生成SH4的代码。</target>
        </trans-unit>
        <trans-unit id="75d92b5b6d76cda99c6a173e1dd53216d0ca8f31" translate="yes" xml:space="preserve">
          <source>Generate code for the SH4 with a floating-point unit that only supports single-precision arithmetic.</source>
          <target state="translated">生成SH4的代码,浮点单元只支持单精度算术。</target>
        </trans-unit>
        <trans-unit id="162b02716f568279c8d0d5122c58fd1e1d0d9f75" translate="yes" xml:space="preserve">
          <source>Generate code for the SH4 without a floating-point unit.</source>
          <target state="translated">生成没有浮点单元的SH4的代码。</target>
        </trans-unit>
        <trans-unit id="63daf68bdeb08d26dfc7feca667cc330215f1c9b" translate="yes" xml:space="preserve">
          <source>Generate code for the SH4.</source>
          <target state="translated">生成SH4的代码。</target>
        </trans-unit>
        <trans-unit id="e752d163eaf5a23bc2b7e20cedab4af27f30919d" translate="yes" xml:space="preserve">
          <source>Generate code for the SH4a assuming the floating-point unit is in single-precision mode by default.</source>
          <target state="translated">假设浮点单元默认为单精度模式,生成SH4a的代码。</target>
        </trans-unit>
        <trans-unit id="9bfcba29114940deb31d10a6d0e6239fe06706a5" translate="yes" xml:space="preserve">
          <source>Generate code for the SH4a, in such a way that no double-precision floating-point operations are used.</source>
          <target state="translated">生成SH4a的代码,不使用双精度浮点运算。</target>
        </trans-unit>
        <trans-unit id="c9b792a4628ba5fbcf5191ba54ebda633615fe85" translate="yes" xml:space="preserve">
          <source>Generate code for the SH4a.</source>
          <target state="translated">生成SH4a的代码。</target>
        </trans-unit>
        <trans-unit id="e7ae153f4f4ad9faa39e7795dea14788da791715" translate="yes" xml:space="preserve">
          <source>Generate code for the SH4al-dsp, or for a SH4a in such a way that the floating-point unit is not used.</source>
          <target state="translated">为SH4al-dsp或SH4a生成不使用浮点单元的代码。</target>
        </trans-unit>
        <trans-unit id="b868662932b00739d50db318aa2ddd01fc4bd249" translate="yes" xml:space="preserve">
          <source>Generate code for the given ABI.</source>
          <target state="translated">为给定的ABI生成代码。</target>
        </trans-unit>
        <trans-unit id="54f462554c550dbd112a2f944735d38c4f45d0bc" translate="yes" xml:space="preserve">
          <source>Generate code for the kernel code model. The kernel runs in the negative 2 GB of the address space. This model has to be used for Linux kernel code.</source>
          <target state="translated">生成内核代码模型的代码。内核运行在负2GB的地址空间中。这个模型必须用于Linux内核代码。</target>
        </trans-unit>
        <trans-unit id="9f7119380ad6e8c2c7924710a3b532b63b7c448f" translate="yes" xml:space="preserve">
          <source>Generate code for the large code model. This makes no assumptions about addresses and sizes of sections. Programs can be statically linked only.</source>
          <target state="translated">生成大代码模型的代码。这不对各部分的地址和大小做任何假设。程序只能是静态链接。</target>
        </trans-unit>
        <trans-unit id="1e1198ebae196f98c194fd331b5a616e80bed1c4" translate="yes" xml:space="preserve">
          <source>Generate code for the large code model. This makes no assumptions about addresses and sizes of sections. Programs can be statically linked only. The</source>
          <target state="translated">生成大代码模型的代码。这不对各部分的地址和大小做任何假设。程序只能是静态链接。程式的</target>
        </trans-unit>
        <trans-unit id="e3f449db1f29f06f736e88f3d496de39caace854" translate="yes" xml:space="preserve">
          <source>Generate code for the large model. There is no limitation on call distance, pc-relative addresses, or absolute addresses.</source>
          <target state="translated">生成大模型的代码。对呼叫距离、pc相关地址或绝对地址没有限制。</target>
        </trans-unit>
        <trans-unit id="9e0fcd5ba89af087e24036d07076369bc21de870" translate="yes" xml:space="preserve">
          <source>Generate code for the large model. This model makes no assumptions about addresses and sizes of sections.</source>
          <target state="translated">生成大型模型的代码。该模型不假设地址和部分的大小。</target>
        </trans-unit>
        <trans-unit id="0971940cc08a4932dadb19e61d4f634d86124a27" translate="yes" xml:space="preserve">
          <source>Generate code for the medium model: the program is linked in the lower 2 GB of the address space. Small symbols are also placed there. Symbols with sizes larger than</source>
          <target state="translated">生成中等模型的代码:程序链接在地址空间的下2GB中。小符号也放在那里。符号的大小大于</target>
        </trans-unit>
        <trans-unit id="59ca259d5568c2d002dd2ccbe8f095a11b92f1df" translate="yes" xml:space="preserve">
          <source>Generate code for the medium-any code model. The program and its statically defined symbols must be within any single 2 GiB address range. Programs can be statically or dynamically linked.</source>
          <target state="translated">生成中任何代码模型的代码。程序及其静态定义的符号必须在任何一个2 GiB地址范围内。程序可以是静态或动态链接的。</target>
        </trans-unit>
        <trans-unit id="504796a714036a0c76db86fa41cc45a9fb08427c" translate="yes" xml:space="preserve">
          <source>Generate code for the medium-low code model. The program and its statically defined symbols must lie within a single 2 GiB address range and must lie between absolute addresses -2 GiB and +2 GiB. Programs can be statically or dynamically linked. This is the default code model.</source>
          <target state="translated">生成中低码模型的代码。程序及其静态定义的符号必须位于一个2 GiB的地址范围内,并且必须位于绝对地址-2 GiB和+2 GiB之间。程序可以是静态的,也可以是动态链接的。这是默认的代码模型。</target>
        </trans-unit>
        <trans-unit id="071c751072fdeed9625e903fca26e27c829fa3e5" translate="yes" xml:space="preserve">
          <source>Generate code for the small code model. The program and its statically defined symbols must be within 4GB of each other. Programs can be statically or dynamically linked. This is the default code model.</source>
          <target state="translated">生成小代码模型的代码。程序和其静态定义的符号必须在4GB以内。程序可以是静态或动态链接的。这是默认的代码模型。</target>
        </trans-unit>
        <trans-unit id="051a1860ec3526f5a9b8c1256cff7e9959d2ec61" translate="yes" xml:space="preserve">
          <source>Generate code for the small code model: the program and its symbols must be linked in the lower 2 GB of the address space. Pointers are 64 bits. Programs can be statically or dynamically linked. This is the default code model.</source>
          <target state="translated">生成小代码模型的代码:程序及其符号必须链接在地址空间的下2GB中。指针为64位。程序可以是静态的,也可以是动态链接的。这是默认的代码模型。</target>
        </trans-unit>
        <trans-unit id="fccb732c10311c882aff8903c1dae6926a19b9e0" translate="yes" xml:space="preserve">
          <source>Generate code for the small model. The distance for direct calls is limited to 500M in either direction. PC-relative addresses are 32 bits. Absolute addresses support the full address range.</source>
          <target state="translated">生成小模型的代码。直接调用的距离限制为双向500M。PC相关地址为32位。绝对地址支持全地址范围。</target>
        </trans-unit>
        <trans-unit id="245e4a42ebe1fc23a573492e82ac616ceb7b3a60" translate="yes" xml:space="preserve">
          <source>Generate code for the specified ABI. Permissible values are: &amp;lsquo;</source>
          <target state="translated">为指定的ABI生成代码。允许值为：</target>
        </trans-unit>
        <trans-unit id="62cd08507f5129c0313b216b3b312e1f38339400" translate="yes" xml:space="preserve">
          <source>Generate code for the specified architecture. The choices for &lt;var&gt;architecture-type&lt;/var&gt; are &amp;lsquo;</source>
          <target state="translated">生成指定体系结构的代码。 &lt;var&gt;architecture-type&lt;/var&gt; 的选择是&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="fa0e2168d621855d66b05e248a41636b81294293" translate="yes" xml:space="preserve">
          <source>Generate code for the specified calling convention. Permissible values are &amp;lsquo;</source>
          <target state="translated">为指定的调用约定生成代码。允许值为&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="d43b1f64836a5b0a5d775d2376c530695500c9a6" translate="yes" xml:space="preserve">
          <source>Generate code for the specified data model. Permissible values are &amp;lsquo;</source>
          <target state="translated">为指定的数据模型生成代码。允许值为&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="e12f5237878118905a68ef1df9fd8353d31db89f" translate="yes" xml:space="preserve">
          <source>Generate code for the supervisor mode, where there are no restrictions on the access to general registers. This is the default.</source>
          <target state="translated">生成主管模式的代码,对一般寄存器的访问没有限制。这是默认的。</target>
        </trans-unit>
        <trans-unit id="e6c40e69179c553d840354dee8e09afd6afb670e" translate="yes" xml:space="preserve">
          <source>Generate code for the tiny code model. The program and its statically defined symbols must be within 1MB of each other. Programs can be statically or dynamically linked.</source>
          <target state="translated">生成微小代码模型的代码。程序和其静态定义的符号之间必须在1MB以内。程序可以是静态或动态链接的。</target>
        </trans-unit>
        <trans-unit id="9e11e5ef71d66be04277bc1f01b5f5278d9a40a3" translate="yes" xml:space="preserve">
          <source>Generate code for the user mode, where the access to some general registers is forbidden: on the GR5, registers r24 to r31 cannot be accessed in this mode; on the GR6, only registers r29 to r31 are affected.</source>
          <target state="translated">生成用户模式的代码,在该模式下,禁止访问一些通用寄存器:在GR5上,在该模式下不能访问寄存器r24至r31;在GR6上,只有寄存器r29至r31受到影响。</target>
        </trans-unit>
        <trans-unit id="bd8c4bf394db1eaf7b115e9a97579b1aa69d5063" translate="yes" xml:space="preserve">
          <source>Generate code for use in OpenMP offloading: enables</source>
          <target state="translated">生成用于OpenMP卸载的代码:启用。</target>
        </trans-unit>
        <trans-unit id="16c4c1a05d2b765d07aab8ca18577dc3fd7c3686" translate="yes" xml:space="preserve">
          <source>Generate code in big-endian mode.</source>
          <target state="translated">以大段模式生成代码。</target>
        </trans-unit>
        <trans-unit id="617c48669c81ce32d047fdd88ab6cc36cefe714c" translate="yes" xml:space="preserve">
          <source>Generate code in big/little endian mode, respectively.</source>
          <target state="translated">分别以大/小恩迪安模式生成代码。</target>
        </trans-unit>
        <trans-unit id="f467368c82a003e89d9528f03fca80cb77bf1e51" translate="yes" xml:space="preserve">
          <source>Generate code in little-endian mode.</source>
          <target state="translated">以小二烯模式生成代码。</target>
        </trans-unit>
        <trans-unit id="d2870658bf99f10270c562aaa0ce69afd3724aea" translate="yes" xml:space="preserve">
          <source>Generate code suitable for big switch tables. Use this option only if the assembler/linker complain about out of range branches within a switch table.</source>
          <target state="translated">生成适合大的开关表的代码。只有当汇编器/链接器抱怨开关表内的分支超出范围时才使用这个选项。</target>
        </trans-unit>
        <trans-unit id="31742c20f6d08e41957b4759da6c2e20cfa33560" translate="yes" xml:space="preserve">
          <source>Generate code suitable for fast turnaround development, such as to allow GDB to dynamically load</source>
          <target state="translated">生成适合快速周转开发的代码,比如让GDB动态加载。</target>
        </trans-unit>
        <trans-unit id="f9c5e3444f60e6e1d269aebfea1614af0e0ffa27" translate="yes" xml:space="preserve">
          <source>Generate code that adds (does not add) in TPF OS specific branches to trace routines in the operating system. This option is off by default, even when compiling for the TPF OS.</source>
          <target state="translated">生成在 TPF OS 特定分支中添加(不添加)到操作系统中跟踪例程的代码。即使在为 TPF OS 编译时,该选项默认为关闭。</target>
        </trans-unit>
        <trans-unit id="cf132e8fd4ca1bac8a3c035b0896be35d4f95248" translate="yes" xml:space="preserve">
          <source>Generate code that allows (does not allow) a static executable to be relocated to a different address at run time. A simple embedded PowerPC system loader should relocate the entire contents of &lt;code&gt;.got2&lt;/code&gt; and 4-byte locations listed in the &lt;code&gt;.fixup&lt;/code&gt; section, a table of 32-bit addresses generated by this option. For this to work, all objects linked together must be compiled with</source>
          <target state="translated">生成允许（不允许）静态可执行文件在运行时重定位到其他地址的代码。一个简单的嵌入式PowerPC系统加载器应重新 &lt;code&gt;.got2&lt;/code&gt; &lt;code&gt;.fixup&lt;/code&gt; 部分中列出的.got2和4字节位置的全部内容，此选项是此选项生成的32位地址表。为此，必须使用以下命令编译链接在一起的所有对象：</target>
        </trans-unit>
        <trans-unit id="86d1c7c8ebb812df3d75ca440f1dd938fb6de6fb" translate="yes" xml:space="preserve">
          <source>Generate code that allows &lt;code&gt;ld&lt;/code&gt; and &lt;code&gt;ld.so&lt;/code&gt; to build executables and shared libraries with non-executable &lt;code&gt;.plt&lt;/code&gt; and &lt;code&gt;.got&lt;/code&gt; sections. This is a PowerPC 32-bit SYSV ABI option.</source>
          <target state="translated">生成允许 &lt;code&gt;ld&lt;/code&gt; 和 &lt;code&gt;ld.so&lt;/code&gt; 使用不可执行的 &lt;code&gt;.plt&lt;/code&gt; 和 &lt;code&gt;.got&lt;/code&gt; 节构建可执行文件和共享库的代码。这是PowerPC 32位SYSV ABI选项。</target>
        </trans-unit>
        <trans-unit id="2493e6ad3aa4a2943864620cf6ffd109b6ddb3da" translate="yes" xml:space="preserve">
          <source>Generate code that allows the data segment to be located in a different area of memory from the text segment. This allows for execute in place in an environment without virtual memory management by eliminating relocations against the text section.</source>
          <target state="translated">生成代码,使数据段与文本段位于不同的内存区域。这样就可以在没有虚拟内存管理的环境中就地执行,消除对文本段的重新定位。</target>
        </trans-unit>
        <trans-unit id="eb6f87eee15c30331198259c5e0fa884666e3b45" translate="yes" xml:space="preserve">
          <source>Generate code that allows the data segment to be located in a different area of memory from the text segment. This allows for execute-in-place in an environment without virtual memory management. This option implies</source>
          <target state="translated">生成代码,允许数据段与文本段位于不同的内存区域。这允许在没有虚拟内存管理的环境中就地执行。这个选项意味着</target>
        </trans-unit>
        <trans-unit id="338b24d92797baf1f472014c3eb7e81cad28ab15" translate="yes" xml:space="preserve">
          <source>Generate code that allows trapping instructions to throw exceptions. Note that this requires platform-specific runtime support that does not exist everywhere. Moreover, it only allows &lt;em&gt;trapping&lt;/em&gt; instructions to throw exceptions, i.e. memory references or floating-point instructions. It does not allow exceptions to be thrown from arbitrary signal handlers such as &lt;code&gt;SIGALRM&lt;/code&gt;.</source>
          <target state="translated">生成允许捕获指令引发异常的代码。请注意，这需要特定于平台的运行时支持，而该支持并非在每个地方都存在。此外，它仅允许&lt;em&gt;陷阱&lt;/em&gt;指令引发异常，即内存引用或浮点指令。它不允许从任意信号处理程序（例如 &lt;code&gt;SIGALRM&lt;/code&gt; )引发异常。</target>
        </trans-unit>
        <trans-unit id="fbd1ec35fb62e61a3c0c9ad20b949b97f631374a" translate="yes" xml:space="preserve">
          <source>Generate code that assumes (does not assume) that all calls are far away so that a longer more expensive calling sequence is required.</source>
          <target state="translated">生成代码,假设(不假设)所有的调用都很远,这样就需要一个较长的较贵的调用序列。</target>
        </trans-unit>
        <trans-unit id="8f709a2890cb93e8763f592a97bd90453baa9bc3" translate="yes" xml:space="preserve">
          <source>Generate code that assumes calls never cross space boundaries. This allows GCC to emit code that performs faster indirect calls.</source>
          <target state="translated">生成假设调用永远不会跨越空间边界的代码。这使得GCC能够发出执行更快的间接调用的代码。</target>
        </trans-unit>
        <trans-unit id="16b9beb60bdc4afff878eec93b064cf17ba08cf6" translate="yes" xml:space="preserve">
          <source>Generate code that assumes that the data segment follows the text segment. This is the default.</source>
          <target state="translated">生成的代码假定数据段在文本段之后。这是默认的。</target>
        </trans-unit>
        <trans-unit id="336489e1da74ce723400b7df9bbae17f47d7009a" translate="yes" xml:space="preserve">
          <source>Generate code that assumes the target has no space registers. This allows GCC to generate faster indirect calls and use unscaled index address modes.</source>
          <target state="translated">生成假设目标没有空间寄存器的代码。这使得GCC可以生成更快的间接调用,并使用不缩放的索引地址模式。</target>
        </trans-unit>
        <trans-unit id="355b3cfdddf15ceae95ec40c1959bb7baa77194d" translate="yes" xml:space="preserve">
          <source>Generate code that changes (does not change) the default branch targets enabled by</source>
          <target state="translated">生成改变(不改变)默认分支目标的代码。</target>
        </trans-unit>
        <trans-unit id="918ffaae0c58edeaaf21af8db9990d1e80c480af" translate="yes" xml:space="preserve">
          <source>Generate code that does not use (uses) the floating-point register set. Software floating-point emulation is provided if you use the</source>
          <target state="translated">生成不使用浮点寄存器集的代码。如果您使用的是</target>
        </trans-unit>
        <trans-unit id="c1d77eef17962d23aa2b64213060026efae223d1" translate="yes" xml:space="preserve">
          <source>Generate code that does not use &lt;code&gt;.local&lt;/code&gt; memory directly for stack storage. Instead, a per-warp stack pointer is maintained explicitly. This enables variable-length stack allocation (with variable-length arrays or &lt;code&gt;alloca&lt;/code&gt;), and when global memory is used for underlying storage, makes it possible to access automatic variables from other threads, or with atomic instructions. This code generation variant is used for OpenMP offloading, but the option is exposed on its own for the purpose of testing the compiler; to generate code suitable for linking into programs using OpenMP offloading, use option</source>
          <target state="translated">生成不直接将 &lt;code&gt;.local&lt;/code&gt; 内存用于堆栈存储的代码。而是显式地维护每个扭曲堆栈指针。这将启用可变长度堆栈分配（使用可变长度数组或 &lt;code&gt;alloca&lt;/code&gt; ），并且在将全局内存用于基础存储时，可以从其他线程或原子指令访问自动变量。此代码生成变体用于OpenMP卸载，但是为了测试编译器，该选项单独显示。要使用OpenMP卸载生成适合链接到程序的代码，请使用option</target>
        </trans-unit>
        <trans-unit id="44ab5ca5f8364ad55909ace91a8c6e880674fbc6" translate="yes" xml:space="preserve">
          <source>Generate code that does not use a global pointer register. The result is not position independent code, and violates the IA-64 ABI.</source>
          <target state="translated">生成不使用全局指针寄存器的代码。其结果不是独立于位置的代码,并违反了IA-64 ABI。</target>
        </trans-unit>
        <trans-unit id="60de4e859809d0c4dc8e855c46af0110311ff144" translate="yes" xml:space="preserve">
          <source>Generate code that doesn&amp;rsquo;t assume ID-based shared libraries are being used. This is the default.</source>
          <target state="translated">生成不假定使用基于ID的共享库的代码。这是默认值。</target>
        </trans-unit>
        <trans-unit id="354fbc6c3e514e9f7e68643c90303161a363d508" translate="yes" xml:space="preserve">
          <source>Generate code that is self-relocatable. This implies</source>
          <target state="translated">生成可自重定位的代码。这意味着</target>
        </trans-unit>
        <trans-unit id="13b5daaeeae847dab7bba6f104ed44e1ab6ee054" translate="yes" xml:space="preserve">
          <source>Generate code that keeps (does not keeps) some integer operations adjacent so that the instructions can be fused together on power8 and later processors.</source>
          <target state="translated">生成保持(不保持)一些整数运算相邻的代码,以便在power8及以后的处理器上可以将指令融合在一起。</target>
        </trans-unit>
        <trans-unit id="ebb2d4ebaa412c3ca6bb8549fd5605ffef2b8a3c" translate="yes" xml:space="preserve">
          <source>Generate code that passes function parameters and return values that (in the called function) are seen as registers &lt;code&gt;$0&lt;/code&gt; and up, as opposed to the GNU ABI which uses global registers &lt;code&gt;$231&lt;/code&gt; and up.</source>
          <target state="translated">生成传递函数参数并返回值（在调用的函数中）视为寄存器 &lt;code&gt;$0&lt;/code&gt; 及更高版本的代码，与使用全局寄存器 &lt;code&gt;$231&lt;/code&gt; 及更高版本的GNU ABI相反。</target>
        </trans-unit>
        <trans-unit id="572a137e555b3b3423721fc0e3626b6e8b160c46" translate="yes" xml:space="preserve">
          <source>Generate code that runs on &lt;var&gt;arch&lt;/var&gt;, which can be the name of a generic MIPS ISA, or the name of a particular processor. The ISA names are: &amp;lsquo;</source>
          <target state="translated">生成在 &lt;var&gt;arch&lt;/var&gt; 上运行的代码，该代码可以是通用MIPS ISA的名称，也可以是特定处理器的名称。ISA名称为：</target>
        </trans-unit>
        <trans-unit id="e20973741c69f13efd8aaaa56fd8109762470570" translate="yes" xml:space="preserve">
          <source>Generate code that runs on &lt;var&gt;cpu-type&lt;/var&gt;, which is the name of a system representing a certain processor type. Possible values for &lt;var&gt;cpu-type&lt;/var&gt; are &amp;lsquo;</source>
          <target state="translated">生成运行在 &lt;var&gt;cpu-type&lt;/var&gt; 上的代码，cpu-type是表示某种处理器类型的系统的名称。 &lt;var&gt;cpu-type&lt;/var&gt; 的可能值为'</target>
        </trans-unit>
        <trans-unit id="2afe5cce361ce178d21f1f9e300c77965e025f71" translate="yes" xml:space="preserve">
          <source>Generate code that supports calling between the ARM and Thumb instruction sets. Without this option, on pre-v5 architectures, the two instruction sets cannot be reliably used inside one program. The default is</source>
          <target state="translated">生成支持在ARM和Thumb指令集之间调用的代码。如果没有这个选项,在pre-v5架构上,两个指令集不能在一个程序中可靠地使用。默认值是</target>
        </trans-unit>
        <trans-unit id="1e1b0c53abd34ffe18acaa9b5781550d29a84379" translate="yes" xml:space="preserve">
          <source>Generate code that supports shared libraries via the library ID method, but assumes that this library or executable won&amp;rsquo;t link against any other ID shared libraries. That allows the compiler to use faster code for jumps and calls.</source>
          <target state="translated">通过库ID方法生成支持共享库的代码，但假定该库或可执行文件不会链接到任何其他ID共享库。这使编译器可以使用更快的代码进行跳转和调用。</target>
        </trans-unit>
        <trans-unit id="19a4d4ef1ca305d055c2c43578e68d17e9af2a97" translate="yes" xml:space="preserve">
          <source>Generate code that supports shared libraries via the library ID method. This allows for execute in place and shared libraries in an environment without virtual memory management. This option implies</source>
          <target state="translated">通过库ID方法生成支持共享库的代码。这允许在没有虚拟内存管理的环境中执行原地和共享库。这个选项意味着</target>
        </trans-unit>
        <trans-unit id="d499e8859196b03e31f4b5d6d30e4cb073e79ae2" translate="yes" xml:space="preserve">
          <source>Generate code that supports shared libraries via the library ID method. This allows for execute-in-place and shared libraries in an environment without virtual memory management. This option implies</source>
          <target state="translated">通过库ID方法生成支持共享库的代码。这允许在没有虚拟内存管理的环境中执行原地和共享库。这个选项意味着</target>
        </trans-unit>
        <trans-unit id="3080019b4a448b8d2f42e11601716bd17c75e272" translate="yes" xml:space="preserve">
          <source>Generate code that tries to avoid (not avoid) the use of indexed load or store instructions.</source>
          <target state="translated">生成试图避免(不是避免)使用索引加载或存储指令的代码。</target>
        </trans-unit>
        <trans-unit id="1d7d0f8dbe32444b165a61440094a0d21d656220" translate="yes" xml:space="preserve">
          <source>Generate code that tries to avoid (not avoid) the use of indexed load or store instructions. These instructions can incur a performance penalty on Power6 processors in certain situations, such as when stepping through large arrays that cross a 16M boundary. This option is enabled by default when targeting Power6 and disabled otherwise.</source>
          <target state="translated">生成代码,尽量避免(而不是避免)使用索引加载或存储指令。在某些情况下,这些指令可能会在Power6处理器上招致性能惩罚,例如在步入跨越16M边界的大型数组时。该选项在针对Power6时默认启用,否则禁用。</target>
        </trans-unit>
        <trans-unit id="bf98fe716d964a094592ad1d59afe4951cb9d36f" translate="yes" xml:space="preserve">
          <source>Generate code that uses (does not use) AltiVec instructions, and also enable the use of built-in functions that allow more direct access to the AltiVec instruction set. You may also need to set</source>
          <target state="translated">生成使用(不使用)AltiVec指令的代码,也可以启用内置函数,允许更直接地访问AltiVec指令集。您可能还需要设置</target>
        </trans-unit>
        <trans-unit id="2f5b28537613ef22817b9ba8bf63c4e1f2104514" translate="yes" xml:space="preserve">
          <source>Generate code that uses (does not use) AltiVec instructions. In 32-bit code, you cannot enable AltiVec instructions unless</source>
          <target state="translated">生成使用(不使用)AltiVec指令的代码。在32位代码中,你不能启用AltiVec指令,除非</target>
        </trans-unit>
        <trans-unit id="8c04238a31ea4511a013025b49118e3c3e42e84e" translate="yes" xml:space="preserve">
          <source>Generate code that uses (does not use) ISEL instruction.</source>
          <target state="translated">生成使用(不使用)ISEL指令的代码。</target>
        </trans-unit>
        <trans-unit id="92155be900bc9933add2300c7a5d23503087ce0e" translate="yes" xml:space="preserve">
          <source>Generate code that uses (does not use) VAX F and G floating-point arithmetic instead of IEEE single and double precision.</source>
          <target state="translated">生成使用(不使用)VAX F和G浮点算术而不是IEEE单精度和双精度的代码。</target>
        </trans-unit>
        <trans-unit id="b95c7c98a27a75ea4aed9a1312a1f6d81d84fc5d" translate="yes" xml:space="preserve">
          <source>Generate code that uses (does not use) the FP move to/from general purpose register instructions implemented on the POWER6X processor and other processors that support the extended PowerPC V2.05 architecture.</source>
          <target state="translated">生成使用(不使用)在POWER6X处理器和其他支持扩展的PowerPC V2.05架构的处理器上实现的FP移动到/从通用寄存器指令的代码。</target>
        </trans-unit>
        <trans-unit id="a2c4f9d3a1eb191b5662b1d07619055360c468c4" translate="yes" xml:space="preserve">
          <source>Generate code that uses (does not use) the FP round to integer instructions implemented on the POWER5+ processor and other processors that support the PowerPC V2.03 architecture.</source>
          <target state="translated">生成使用(不使用)POWER5+处理器和其他支持PowerPC V2.03架构的处理器上实现的FP舍入到整数指令的代码。</target>
        </trans-unit>
        <trans-unit id="46d6eec21f4fa802b85560d860276b9199fed94b" translate="yes" xml:space="preserve">
          <source>Generate code that uses (does not use) the atomic quad word memory instructions. The</source>
          <target state="translated">生成使用(不使用)原子四字内存指令的代码。该</target>
        </trans-unit>
        <trans-unit id="262e0fd3e027fbfbead855b3f29a870f608f4f72" translate="yes" xml:space="preserve">
          <source>Generate code that uses (does not use) the compare bytes instruction implemented on the POWER6 processor and other processors that support the PowerPC V2.05 architecture.</source>
          <target state="translated">生成使用(不使用)POWER6处理器和其他支持PowerPC V2.05架构的处理器上实现的比较字节指令的代码。</target>
        </trans-unit>
        <trans-unit id="08b86aae00b13e22b96514a69b5b064be8919eb4" translate="yes" xml:space="preserve">
          <source>Generate code that uses (does not use) the decimal floating-point instructions implemented on some POWER processors.</source>
          <target state="translated">生成使用(不使用)某些POWER处理器上实现的十进制浮点指令的代码。</target>
        </trans-unit>
        <trans-unit id="3131d9ab648d637f7f2b9519e03b551e9a374743" translate="yes" xml:space="preserve">
          <source>Generate code that uses (does not use) the floating-point multiply and accumulate instructions. These instructions are generated by default if hardware floating point is used.</source>
          <target state="translated">生成使用(不使用)浮点乘法和累加指令的代码。如果使用硬件浮点,则默认生成这些指令。</target>
        </trans-unit>
        <trans-unit id="c04a8a825b0f94e2eb07f4e8f21cb84241b2efaf" translate="yes" xml:space="preserve">
          <source>Generate code that uses (does not use) the floating-point multiply and accumulate instructions. These instructions are generated by default if hardware floating point is used. The machine-dependent</source>
          <target state="translated">生成使用(不使用)浮点乘法和累加指令的代码。如果使用硬件浮点,则默认生成这些指令。依赖于机器的</target>
        </trans-unit>
        <trans-unit id="61eadf2cc65c85da3c9ba20e0d77a3b18047c546" translate="yes" xml:space="preserve">
          <source>Generate code that uses (does not use) the floating-point register set.</source>
          <target state="translated">生成使用(不使用)浮点寄存器集的代码。</target>
        </trans-unit>
        <trans-unit id="32b3b39a373f02faec1c8e47cea1029610f3648e" translate="yes" xml:space="preserve">
          <source>Generate code that uses (does not use) the generation of PAIRED simd instructions.</source>
          <target state="translated">生成使用(不使用)生成paired simd指令的代码。</target>
        </trans-unit>
        <trans-unit id="a16384b2cc48decd8d149f4edeab3b4637c6c2dd" translate="yes" xml:space="preserve">
          <source>Generate code that uses (does not use) the half-word multiply and multiply-accumulate instructions on the IBM 405, 440, 464 and 476 processors. These instructions are generated by default when targeting those processors.</source>
          <target state="translated">生成使用(不使用)IBM 405、440、464和476处理器上的半字乘法和乘法累加指令的代码。当针对这些处理器时,这些指令是默认生成的。</target>
        </trans-unit>
        <trans-unit id="0ae0cd2b0200a8b41b70cb257df1cc0c71cf4ea9" translate="yes" xml:space="preserve">
          <source>Generate code that uses (does not use) the load multiple word instructions and the store multiple word instructions.</source>
          <target state="translated">生成使用(不使用)加载多字指令和存储多字指令的代码。</target>
        </trans-unit>
        <trans-unit id="2c52b95b537c53566c2534b67e93882f9aca68b1" translate="yes" xml:space="preserve">
          <source>Generate code that uses (does not use) the load multiple word instructions and the store multiple word instructions. These instructions are generated by default on POWER systems, and not generated on PowerPC systems. Do not use</source>
          <target state="translated">生成使用(不使用)加载多字指令和存储多字指令的代码。这些指令在POWER系统上默认生成,在PowerPC系统上不生成。请不要使用</target>
        </trans-unit>
        <trans-unit id="fd774e2be13b8cb13d5052ff903f2b6dbbaa0be4" translate="yes" xml:space="preserve">
          <source>Generate code that uses (does not use) the load or store instructions that update the base register to the address of the calculated memory location.</source>
          <target state="translated">生成使用(不使用)加载或存储指令的代码,将基本寄存器更新到计算出的内存位置的地址。</target>
        </trans-unit>
        <trans-unit id="a22e11f108e540ae0805ccbff5751fce923b96a4" translate="yes" xml:space="preserve">
          <source>Generate code that uses (does not use) the load or store instructions that update the base register to the address of the calculated memory location. These instructions are generated by default. If you use</source>
          <target state="translated">生成使用(不使用)加载或存储指令的代码,这些指令将基本寄存器更新到计算的内存位置的地址。这些指令是默认生成的。如果您使用</target>
        </trans-unit>
        <trans-unit id="0770f3e5c30f3b0aaaeba94f431ff5516808b06c" translate="yes" xml:space="preserve">
          <source>Generate code that uses (does not use) the load string instructions and the store string word instructions to save multiple registers and do small block moves.</source>
          <target state="translated">生成使用(不使用)加载字符串指令和存储字符串字指令来保存多个寄存器并进行小块移动的代码。</target>
        </trans-unit>
        <trans-unit id="386b3e18aecf301e2272c3303cef5b3408b3d72f" translate="yes" xml:space="preserve">
          <source>Generate code that uses (does not use) the move from condition register field instruction implemented on the POWER4 processor and other processors that support the PowerPC V2.01 architecture.</source>
          <target state="translated">生成使用(不使用)POWER4处理器和其他支持PowerPC V2.01架构的处理器上实现的从条件寄存器字段指令的代码。</target>
        </trans-unit>
        <trans-unit id="87adae88954ee8917f3f31be376d9936d82cd4bc" translate="yes" xml:space="preserve">
          <source>Generate code that uses (does not use) the non-atomic quad word memory instructions. The</source>
          <target state="translated">生成使用(不使用)非原子四字内存指令的代码。该</target>
        </trans-unit>
        <trans-unit id="fc8745a466eb796ef7f9c5a441c7003ed311977e" translate="yes" xml:space="preserve">
          <source>Generate code that uses (does not use) the optional PowerPC architecture instructions in the General Purpose group, including floating-point square root.</source>
          <target state="translated">生成使用(不使用)通用组中可选的PowerPC架构指令的代码,包括浮点平方根。</target>
        </trans-unit>
        <trans-unit id="27810752cbb1f58324d02017084ca261477ff314" translate="yes" xml:space="preserve">
          <source>Generate code that uses (does not use) the optional PowerPC architecture instructions in the Graphics group, including floating-point select.</source>
          <target state="translated">生成使用(不使用)图形组中可选的PowerPC架构指令的代码,包括浮点选择。</target>
        </trans-unit>
        <trans-unit id="98f0227605ad4df08722181505cb7a14d55e9799" translate="yes" xml:space="preserve">
          <source>Generate code that uses (does not use) the popcount and double-precision FP reciprocal estimate instruction implemented on the POWER5 processor and other processors that support the PowerPC V2.02 architecture.</source>
          <target state="translated">生成使用(不使用)POWER5处理器和其他支持PowerPC V2.02架构的处理器上实现的popcount和双精度FP往复估计指令的代码。</target>
        </trans-unit>
        <trans-unit id="c07537f1993a55be984ad5f397058498e67120dd" translate="yes" xml:space="preserve">
          <source>Generate code that uses (does not use) the popcount instruction implemented on the POWER7 processor and other processors that support the PowerPC V2.06 architecture.</source>
          <target state="translated">生成使用(不使用)POWER7处理器和其他支持PowerPC V2.06架构的处理器上实现的popcount指令的代码。</target>
        </trans-unit>
        <trans-unit id="4b15de7f2b7f03ed6e1790dbf982c588fb5b3528" translate="yes" xml:space="preserve">
          <source>Generate code that uses (does not use) the string-search &amp;lsquo;</source>
          <target state="translated">生成使用（不使用）字符串搜索'</target>
        </trans-unit>
        <trans-unit id="ab7a2922566d7313797a3ac188f3c0be7688df71" translate="yes" xml:space="preserve">
          <source>Generate code that uses (does not use) the vector and scalar instructions that were added in version 2.07 of the PowerPC ISA. Also enable the use of built-in functions that allow more direct access to the vector instructions.</source>
          <target state="translated">生成使用(不使用)PowerPC ISA 2.07版本中新增的向量和标量指令的代码。还可以使用内置函数,允许更直接地访问向量指令。</target>
        </trans-unit>
        <trans-unit id="f7dd4f67d21a30765965ab7e7de435cac230ac64" translate="yes" xml:space="preserve">
          <source>Generate code that uses (does not use) vector/scalar (VSX) instructions, and also enable the use of built-in functions that allow more direct access to the VSX instruction set.</source>
          <target state="translated">生成使用(不使用)矢量/标量(VSX)指令的代码,还可以使用内置函数,允许更直接地访问VSX指令集。</target>
        </trans-unit>
        <trans-unit id="05ca89c3814bc0cbed05cab7398d230442544564" translate="yes" xml:space="preserve">
          <source>Generate code that uses (does not use) vector/scalar (VSX) instructions, and also enable the use of built-in functions that allow more direct access to the VSX instruction set. In 32-bit code, you cannot enable VSX or AltiVec instructions unless</source>
          <target state="translated">生成使用(不使用)矢量/标量(VSX)指令的代码,还可以启用内置函数,允许更直接地访问VSX指令集。在32位代码中,不能启用VSX或AltiVec指令,除非</target>
        </trans-unit>
        <trans-unit id="67b86bb995294b5ded4deb3fb6384281013e8cde" translate="yes" xml:space="preserve">
          <source>Generate code that uses a BSS &lt;code&gt;.plt&lt;/code&gt; section that &lt;code&gt;ld.so&lt;/code&gt; fills in, and requires &lt;code&gt;.plt&lt;/code&gt; and &lt;code&gt;.got&lt;/code&gt; sections that are both writable and executable. This is a PowerPC 32-bit SYSV ABI option.</source>
          <target state="translated">生成使用 &lt;code&gt;ld.so&lt;/code&gt; 填充的BSS &lt;code&gt;.plt&lt;/code&gt; 节的代码，并需要可写和可执行的 &lt;code&gt;.plt&lt;/code&gt; 和 &lt;code&gt;.got&lt;/code&gt; 节。这是PowerPC 32位SYSV ABI选项。</target>
        </trans-unit>
        <trans-unit id="6beeb427ddc734bea4c58516baa43a91d09099d2" translate="yes" xml:space="preserve">
          <source>Generate code that uses a single constant global pointer value. This is useful when compiling kernel code.</source>
          <target state="translated">生成使用单个常量全局指针值的代码。这在编译内核代码时很有用。</target>
        </trans-unit>
        <trans-unit id="6f2e6ea4728870634a5f76e2497b052f725aed62" translate="yes" xml:space="preserve">
          <source>Generate code that uses long call sequences. This ensures that a call is always able to reach linker generated stubs. The default is to generate long calls only when the distance from the call site to the beginning of the function or translation unit, as the case may be, exceeds a predefined limit set by the branch type being used. The limits for normal calls are 7,600,000 and 240,000 bytes, respectively for the PA 2.0 and PA 1.X architectures. Sibcalls are always limited at 240,000 bytes.</source>
          <target state="translated">生成使用长调用序列的代码。这确保调用总是能够到达链接器生成的存根。默认情况下,只有当从调用站点到函数或翻译单元(视情况而定)的开始的距离超过由正在使用的分支类型设置的预定义限制时,才会生成长调用。PA 2.0 和 PA 1.X 架构的普通调用限制分别为 7,600,000 和 240,000 字节。Sibcalls 始终限制在 240,000 字节。</target>
        </trans-unit>
        <trans-unit id="0ddfa4b3d16d23a89e5776522951b15e62426fdc" translate="yes" xml:space="preserve">
          <source>Generate code that uses only the general-purpose registers. This prevents the compiler from using floating-point, vector, mask and bound registers.</source>
          <target state="translated">生成只使用通用寄存器的代码。这可以防止编译器使用浮点、向量、掩码和绑定寄存器。</target>
        </trans-unit>
        <trans-unit id="baac973b3b5994adc6aef021db0133816bd28382" translate="yes" xml:space="preserve">
          <source>Generate code to access thread-local storage using the &amp;lsquo;</source>
          <target state="translated">使用'生成代码以访问线程本地存储</target>
        </trans-unit>
        <trans-unit id="c88cdcf77b77d16255b95669179f017ca5ceda39" translate="yes" xml:space="preserve">
          <source>Generate code to automatically split the stack before it overflows. The resulting program has a discontiguous stack which can only overflow if the program is unable to allocate any more memory. This is most useful when running threaded programs, as it is no longer necessary to calculate a good stack size to use for each thread. This is currently only implemented for the x86 targets running GNU/Linux.</source>
          <target state="translated">生成代码,在堆栈溢出之前自动分割堆栈。生成的程序有一个不连续的栈,只有在程序无法分配更多的内存时才会溢出。这在运行线程程序时最为有用,因为它不再需要为每个线程计算一个好的堆栈大小。目前只有运行GNU/Linux的x86目标才会实现这个功能。</target>
        </trans-unit>
        <trans-unit id="915ccec10fdc8928f52708c97467282540464b8a" translate="yes" xml:space="preserve">
          <source>Generate code to avoid bugs in the multiply instructions for the MN10300 processors. This is the default.</source>
          <target state="translated">生成代码以避免MN10300处理器的乘法指令出现错误。这是默认值。</target>
        </trans-unit>
        <trans-unit id="0df3e04d22344e23f6649b40a52c7d6f0c186350" translate="yes" xml:space="preserve">
          <source>Generate code to ensure that the stack does not grow beyond a certain value, either the value of a register or the address of a symbol. If a larger stack is required, a signal is raised at run time. For most targets, the signal is raised before the stack overruns the boundary, so it is possible to catch the signal without taking special precautions.</source>
          <target state="translated">生成代码,以确保堆栈的增长不超过某个值,无论是寄存器的值还是符号的地址。如果需要更大的栈,在运行时就会发出信号。对于大多数目标来说,信号会在堆栈超过边界之前就被提出,因此可以不采取特殊的预防措施来捕捉信号。</target>
        </trans-unit>
        <trans-unit id="1b66c9f22b9ae2f51f7b68dcb90be43a732528ba" translate="yes" xml:space="preserve">
          <source>Generate code to prevent stack clash style attacks. When this option is enabled, the compiler will only allocate one page of stack space at a time and each page is accessed immediately after allocation. Thus, it prevents allocations from jumping over any stack guard page provided by the operating system.</source>
          <target state="translated">生成代码以防止堆栈冲突式攻击。启用该选项后,编译器每次只分配一页堆栈空间,且每一页在分配后立即被访问。因此,它可以防止分配跳过操作系统提供的任何堆栈保护页。</target>
        </trans-unit>
        <trans-unit id="dd0c489c581360afbf7f7a5091b3992e53e109af" translate="yes" xml:space="preserve">
          <source>Generate code to verify that you do not go beyond the boundary of the stack. You should specify this flag if you are running in an environment with multiple threads, but you only rarely need to specify it in a single-threaded environment since stack overflow is automatically detected on nearly all systems if there is only one stack.</source>
          <target state="translated">生成代码来验证你是否没有超出栈的边界。如果你运行在有多个线程的环境中,你应该指定这个标志,但在单线程环境中,你只需要很少指定这个标志,因为如果只有一个栈,几乎所有系统都会自动检测到栈溢出。</target>
        </trans-unit>
        <trans-unit id="f09658f66e71e4832575a43871e37604d20cbdbd" translate="yes" xml:space="preserve">
          <source>Generate code treating the given register range as fixed registers. A fixed register is one that the register allocator cannot use. This is useful when compiling kernel code. A register range is specified as two registers separated by a dash. Multiple register ranges can be specified separated by a comma.</source>
          <target state="translated">生成将给定寄存器范围作为固定寄存器的代码。固定寄存器是指寄存器分配器不能使用的寄存器。这在编译内核代码时很有用。一个寄存器范围被指定为两个用破折号分隔的寄存器。可以用逗号分隔指定多个寄存器范围。</target>
        </trans-unit>
        <trans-unit id="69365c978ad182890bcb4e65e053170c8830231a" translate="yes" xml:space="preserve">
          <source>Generate code using &lt;code&gt;push&lt;/code&gt; and &lt;code&gt;pop&lt;/code&gt; instructions. This option defaults to on.</source>
          <target state="translated">使用 &lt;code&gt;push&lt;/code&gt; 和 &lt;code&gt;pop&lt;/code&gt; 指令生成代码。此选项默认为打开。</target>
        </trans-unit>
        <trans-unit id="7f296d4ed278effc8fa87bfb0e530628874d3432" translate="yes" xml:space="preserve">
          <source>Generate code using &lt;code&gt;stm&lt;/code&gt; and &lt;code&gt;ldm&lt;/code&gt; instructions. This option isn&amp;rsquo;t supported on CK801 but is enabled by default on other processors.</source>
          <target state="translated">使用 &lt;code&gt;stm&lt;/code&gt; 和 &lt;code&gt;ldm&lt;/code&gt; 指令生成代码。CK801不支持此选项，但默认情况下在其他处理器上启用此选项。</target>
        </trans-unit>
        <trans-unit id="ba4d33b91d9e6ab2d69e87dce44c7244b439ed9e" translate="yes" xml:space="preserve">
          <source>Generate code using features specific to the AM33 processor.</source>
          <target state="translated">使用AM33处理器特有的功能生成代码。</target>
        </trans-unit>
        <trans-unit id="b0f3f1a0016506b7432a6808d95156263172db1a" translate="yes" xml:space="preserve">
          <source>Generate code using features specific to the AM33/2.0 processor.</source>
          <target state="translated">使用AM33/2.0处理器特有的功能生成代码。</target>
        </trans-unit>
        <trans-unit id="4d51b4beaa1d3a18f186ce7d15002cb82d47e204" translate="yes" xml:space="preserve">
          <source>Generate code using features specific to the AM34 processor.</source>
          <target state="translated">使用AM34处理器特有的功能生成代码。</target>
        </trans-unit>
        <trans-unit id="c282f618bb7db95f0feff29b3266b2478e4e252b" translate="yes" xml:space="preserve">
          <source>Generate code using global anchor symbol addresses.</source>
          <target state="translated">使用全局锚符号地址生成代码。</target>
        </trans-unit>
        <trans-unit id="cb509e9252b480e0a1aeb49faf8b1ef18fa7edf6" translate="yes" xml:space="preserve">
          <source>Generate code using the FDPIC ABI.</source>
          <target state="translated">使用FDPIC ABI生成代码。</target>
        </trans-unit>
        <trans-unit id="404e8a65099de95616c40afb1bc863ffa2523650" translate="yes" xml:space="preserve">
          <source>Generate code using the high registers numbered 16-31. This option is not supported on CK801, CK802, or CK803, and is enabled by default for other processors.</source>
          <target state="translated">使用编号为16-31的高位寄存器生成代码,CK801、CK802或CK803不支持该选项,其他处理器默认启用。CK801、CK802或CK803不支持此选项,其他处理器默认启用。</target>
        </trans-unit>
        <trans-unit id="4cb05ce3f6ef091d20d86e01a77fc7f4a59d0bcc" translate="yes" xml:space="preserve">
          <source>Generate code which uses only the general-purpose registers. This will prevent the compiler from using floating-point and Advanced SIMD registers but will not impose any restrictions on the assembler.</source>
          <target state="translated">生成只使用通用寄存器的代码。这将阻止编译器使用浮点和高级SIMD寄存器,但不会对汇编器施加任何限制。</target>
        </trans-unit>
        <trans-unit id="9cce76ef82a38c3b96967249a0f61e0fb26b9334" translate="yes" xml:space="preserve">
          <source>Generate compiler predefines and select a startfile for the specified UNIX standard. The choices for &lt;var&gt;unix-std&lt;/var&gt; are &amp;lsquo;</source>
          <target state="translated">生成编译器预定义并为指定的UNIX标准选择一个起始文件。 &lt;var&gt;unix-std&lt;/var&gt; 的选择是'</target>
        </trans-unit>
        <trans-unit id="a678e34a31471d170303da9eda1b930e2324a992" translate="yes" xml:space="preserve">
          <source>Generate conditional move instructions.</source>
          <target state="translated">生成有条件的移动指令。</target>
        </trans-unit>
        <trans-unit id="d72e8c8e0f9b51ca898631ea4a5646d5c76664c2" translate="yes" xml:space="preserve">
          <source>Generate divide instructions. Default is off.</source>
          <target state="translated">生成除法指令。默认为关闭。</target>
        </trans-unit>
        <trans-unit id="16d77d1fe0a8bda494d3925636feea2c269c0e3f" translate="yes" xml:space="preserve">
          <source>Generate double-precision FPX instructions, tuned for the compact implementation.</source>
          <target state="translated">生成双精度FPX指令,针对紧凑的实现进行调整。</target>
        </trans-unit>
        <trans-unit id="c229df63f7c476d6f9fecd75b4ac0f6491159589" translate="yes" xml:space="preserve">
          <source>Generate double-precision FPX instructions, tuned for the fast implementation.</source>
          <target state="translated">生成双精度FPX指令,调整为快速实现。</target>
        </trans-unit>
        <trans-unit id="6b4a611d12d60ad206db3327cb2ea87939e3d6cb" translate="yes" xml:space="preserve">
          <source>Generate extended arithmetic instructions. Currently only &lt;code&gt;divaw&lt;/code&gt;, &lt;code&gt;adds&lt;/code&gt;, &lt;code&gt;subs&lt;/code&gt;, and &lt;code&gt;sat16&lt;/code&gt; are supported. Only valid for</source>
          <target state="translated">生成扩展的算术指令。当前仅支持 &lt;code&gt;divaw&lt;/code&gt; ， &lt;code&gt;adds&lt;/code&gt; ， &lt;code&gt;subs&lt;/code&gt; 和 &lt;code&gt;sat16&lt;/code&gt; 。仅对</target>
        </trans-unit>
        <trans-unit id="efd3351263c1d9caa26ca401350421bfc7b35243" translate="yes" xml:space="preserve">
          <source>Generate extended arithmetic instructions. Currently only &lt;code&gt;divaw&lt;/code&gt;, &lt;code&gt;adds&lt;/code&gt;, &lt;code&gt;subs&lt;/code&gt;, and &lt;code&gt;sat16&lt;/code&gt; are supported. This is always enabled for</source>
          <target state="translated">生成扩展的算术指令。当前仅支持 &lt;code&gt;divaw&lt;/code&gt; ， &lt;code&gt;adds&lt;/code&gt; ， &lt;code&gt;subs&lt;/code&gt; 和 &lt;code&gt;sat16&lt;/code&gt; 。始终启用</target>
        </trans-unit>
        <trans-unit id="6856e99222352076039e94fbdf5c31806c05feaa" translate="yes" xml:space="preserve">
          <source>Generate extended debug information for inlined functions. Location view tracking markers are inserted at inlined entry points, so that address and view numbers can be computed and output in debug information. This can be enabled independently of location views, in which case the view numbers won&amp;rsquo;t be output, but it can only be enabled along with statement frontiers, and it is only enabled by default if location views are enabled.</source>
          <target state="translated">生成内联函数的扩展调试信息。将位置视图跟踪标记插入到内联的入口点，以便可以计算地址和视图编号并将其输出到调试信息中。可以独立于位置视图启用此功能，在这种情况下，将不会输出视图编号，但只能与语句边界一起启用，并且仅在启用位置视图的情况下默认启用。</target>
        </trans-unit>
        <trans-unit id="5d0b2408362730cc5b4ed897b120cdb4b4cc4031" translate="yes" xml:space="preserve">
          <source>Generate extra code to write profile information suitable for the analysis program &lt;code&gt;prof&lt;/code&gt; (for</source>
          <target state="translated">生成额外的代码以编写适合分析程序 &lt;code&gt;prof&lt;/code&gt; 配置文件信息（用于</target>
        </trans-unit>
        <trans-unit id="c6eeb91a33862dbf10594e59a0033583feb5fde5" translate="yes" xml:space="preserve">
          <source>Generate floating-point arithmetic for selected unit &lt;var&gt;unit&lt;/var&gt;. The choices for &lt;var&gt;unit&lt;/var&gt; are:</source>
          <target state="translated">为选定的单位 &lt;var&gt;unit&lt;/var&gt; 生成浮点算法。 &lt;var&gt;unit&lt;/var&gt; 的选择是：</target>
        </trans-unit>
        <trans-unit id="79ec4a91ff56b1468e2e0960559756f702528e59" translate="yes" xml:space="preserve">
          <source>Generate floating-point comparison instructions that compare with respect to the &lt;code&gt;rE&lt;/code&gt; epsilon register.</source>
          <target state="translated">生成与 &lt;code&gt;rE&lt;/code&gt; epsilon寄存器进行比较的浮点比较指令。</target>
        </trans-unit>
        <trans-unit id="5184b7fbfd727379c1835aa4d91abffedcc6f989" translate="yes" xml:space="preserve">
          <source>Generate floating-point instructions. This is the default for 68020 and above, and for ColdFire devices that have an FPU. It defines the macro &lt;code&gt;__HAVE_68881__&lt;/code&gt; on M680x0 targets and &lt;code&gt;__mcffpu__&lt;/code&gt; on ColdFire targets.</source>
          <target state="translated">生成浮点指令。对于68020及更高版本以及具有FPU的ColdFire设备，这是默认设置。它定义了宏 &lt;code&gt;__HAVE_68881__&lt;/code&gt; 上M680x0目标和 &lt;code&gt;__mcffpu__&lt;/code&gt; 上的ColdFire目标。</target>
        </trans-unit>
        <trans-unit id="6ff3989b144109cfd18ff049af7f71f4c3c9f86e" translate="yes" xml:space="preserve">
          <source>Generate hardware atomic sequences using the &lt;code&gt;movli.l&lt;/code&gt; and &lt;code&gt;movco.l&lt;/code&gt; instructions only. This is only available on SH4A and is suitable for multi-core systems. Since the hardware instructions support only 32 bit atomic variables access to 8 or 16 bit variables is emulated with 32 bit accesses. Code compiled with this option is also compatible with other software atomic model interrupt/exception handling systems if executed on an SH4A system. Additional support from the interrupt/exception handling code of the system is not required for this model.</source>
          <target state="translated">仅使用 &lt;code&gt;movli.l&lt;/code&gt; 和 &lt;code&gt;movco.l&lt;/code&gt; 指令生成硬件原子序列。仅在SH4A上可用，并且适用于多核系统。由于硬件指令仅支持32位原子变量，因此使用32位访问模拟对8位或16位变量的访问。如果在SH4A系统上执行，使用此选项编译的代码也与其他软件原子模型中断/异常处理系统兼容。该型号不需要系统的中断/异常处理代码的额外支持。</target>
        </trans-unit>
        <trans-unit id="d8debf693e895754ae8dfa412a7398684e52957b" translate="yes" xml:space="preserve">
          <source>Generate instructions for the machine type &lt;var&gt;cpu-type&lt;/var&gt;. In contrast to</source>
          <target state="translated">为机器类型 &lt;var&gt;cpu-type&lt;/var&gt; 生成指令。与之相反</target>
        </trans-unit>
        <trans-unit id="4d9806e63398f5c7206d46ddf2dd393879704321" translate="yes" xml:space="preserve">
          <source>Generate instructions supported by barrel shifter. This is the default unless</source>
          <target state="translated">生成桶式移位器支持的指令。这是默认的,除非</target>
        </trans-unit>
        <trans-unit id="a86b264be3b7927eef8b4d4ec32bd6e0abb23e9a" translate="yes" xml:space="preserve">
          <source>Generate instrumentation calls for entry and exit to functions. Just after function entry and just before function exit, the following profiling functions are called with the address of the current function and its call site. (On some platforms, &lt;code&gt;__builtin_return_address&lt;/code&gt; does not work beyond the current function, so the call site information may not be available to the profiling functions otherwise.)</source>
          <target state="translated">生成用于调用和退出函数的检测调用。在函数进入之后和函数退出之前，将使用当前函数的地址及其调用位置来调用以下概要分析函数。（在某些平台上， &lt;code&gt;__builtin_return_address&lt;/code&gt; 在当前功能之外无法正常工作，因此，否则分析功能可能无法使用呼叫站点信息。）</target>
        </trans-unit>
        <trans-unit id="a558056c364dd801f66dea4bd9ff5d7025049fb1" translate="yes" xml:space="preserve">
          <source>Generate little-endian (default) or big-endian (experimental) code, respectively.</source>
          <target state="translated">分别生成小二烯(默认)或大二烯(实验)代码。</target>
        </trans-unit>
        <trans-unit id="8c624983438064d33fb3b88653aa23aaa51afa20" translate="yes" xml:space="preserve">
          <source>Generate little-endian code.</source>
          <target state="translated">生成小二烯码。</target>
        </trans-unit>
        <trans-unit id="d362bc65e7c53091f19c9e25dc0b1f5baf698d4a" translate="yes" xml:space="preserve">
          <source>Generate little-endian code. This is the default for &amp;lsquo;</source>
          <target state="translated">生成小端代码。这是&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="66047ec2f64b4bd1b8fdd5fa2877f3f85b442eac" translate="yes" xml:space="preserve">
          <source>Generate little-endian code. This is the default when GCC is configured for an &amp;lsquo;</source>
          <target state="translated">生成小端代码。当将GCC配置为&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="e76d98abdce9e7fa1b4a7b7f0a6241f584dc592c" translate="yes" xml:space="preserve">
          <source>Generate mul.x and umul.x instructions. This is the default for &amp;lsquo;</source>
          <target state="translated">生成mul.x和umul.x指令。这是&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="11b3830c8f1fe1ef2c6dc043ba7fa4b0665f2d6d" translate="yes" xml:space="preserve">
          <source>Generate non-looping inline code for all block compares (such as calls to &lt;code&gt;memcmp&lt;/code&gt; or structure compares) less than or equal to &lt;var&gt;num&lt;/var&gt; bytes. If &lt;var&gt;num&lt;/var&gt; is 0, all inline expansion (non-loop and loop) of block compare is disabled. The default value is target-specific.</source>
          <target state="translated">为所有小于或等于 &lt;var&gt;num&lt;/var&gt; 个字节的块比较（例如，调用 &lt;code&gt;memcmp&lt;/code&gt; 或结构比较）生成非循环内联代码。如果 &lt;var&gt;num&lt;/var&gt; 为0，则禁用块比较的所有内联扩展（非循环和循环）。默认值为特定于目标的。</target>
        </trans-unit>
        <trans-unit id="726e8e558f2a846b8999b9aeb3c7faa8d320b08e" translate="yes" xml:space="preserve">
          <source>Generate object code compatible with the standard GNU Objective-C runtime. This is the default for most types of systems.</source>
          <target state="translated">生成与标准GNU Objective-C运行时兼容的对象代码。这是大多数类型系统的默认值。</target>
        </trans-unit>
        <trans-unit id="5f828fdb836a3167f3a117e320f8c23966c29566" translate="yes" xml:space="preserve">
          <source>Generate output compatible with the NeXT runtime. This is the default for NeXT-based systems, including Darwin and Mac OS X. The macro &lt;code&gt;__NEXT_RUNTIME__&lt;/code&gt; is predefined if (and only if) this option is used.</source>
          <target state="translated">生成与NeXT运行时兼容的输出。这是基于NeXT的系统（包括Darwin和Mac OS X）的默认设置。如果（且仅）使用此选项，则预定义了宏 &lt;code&gt;__NEXT_RUNTIME__&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3b10b8584ef5629375b0697c006157af2562811c" translate="yes" xml:space="preserve">
          <source>Generate output containing 80387 instructions for floating point.</source>
          <target state="translated">生成包含80387条浮点指令的输出。</target>
        </trans-unit>
        <trans-unit id="4ac64fa385d79df6893e650d3c87094e5fab8e8d" translate="yes" xml:space="preserve">
          <source>Generate output containing floating-point instructions. This is the default.</source>
          <target state="translated">生成包含浮点指令的输出。这是默认的。</target>
        </trans-unit>
        <trans-unit id="a54c9d559afdf54011312401dae184f34851998d" translate="yes" xml:space="preserve">
          <source>Generate output containing library calls for floating point.</source>
          <target state="translated">生成包含浮点函数库调用的输出。</target>
        </trans-unit>
        <trans-unit id="b68715959fa47ba0ff79de672b756a42be41a84c" translate="yes" xml:space="preserve">
          <source>Generate output containing library calls for floating point. &lt;strong&gt;Warning:&lt;/strong&gt; the requisite libraries are not available for all HPPA targets. Normally the facilities of the machine&amp;rsquo;s usual C compiler are used, but this cannot be done directly in cross-compilation. You must make your own arrangements to provide suitable library functions for cross-compilation.</source>
          <target state="translated">生成包含浮点库调用的输出。&lt;strong&gt;警告：&lt;/strong&gt;并非所有HPPA目标都必须具备必需的库。通常使用机器常用的C编译器的功能，但是不能直接在交叉编译中完成。您必须自行安排以提供合适的库函数以进行交叉编译。</target>
        </trans-unit>
        <trans-unit id="123686fdd6543b04616633629545ce470b234181" translate="yes" xml:space="preserve">
          <source>Generate output containing library calls for floating point. &lt;strong&gt;Warning:&lt;/strong&gt; the requisite libraries are not available for all SPARC targets. Normally the facilities of the machine&amp;rsquo;s usual C compiler are used, but this cannot be done directly in cross-compilation. You must make your own arrangements to provide suitable library functions for cross-compilation. The embedded targets &amp;lsquo;</source>
          <target state="translated">生成包含浮点库调用的输出。&lt;strong&gt;警告：&lt;/strong&gt;并非所有SPARC目标都必须具备必需的库。通常使用机器常用的C编译器的功能，但是不能直接在交叉编译中完成。您必须自行安排以提供合适的库函数以进行交叉编译。嵌入式目标&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="374b214aae9f131ecd8bd8fbf3ba7e20116baf86" translate="yes" xml:space="preserve">
          <source>Generate output containing library calls for quad-word (long double) floating-point instructions. The functions called are those specified in the SPARC ABI. This is the default.</source>
          <target state="translated">生成包含四字(长双)浮点指令的库调用的输出。调用的函数是SPARC ABI中指定的函数。这是默认的。</target>
        </trans-unit>
        <trans-unit id="e778386ad4f7c29303d76d557065f8b2cddd1a1e" translate="yes" xml:space="preserve">
          <source>Generate output containing quad-word (long double) floating-point instructions.</source>
          <target state="translated">生成包含四字(长双)浮点指令的输出。</target>
        </trans-unit>
        <trans-unit id="72b8d6815f1c63fef196e30ed85ba66e28021cd2" translate="yes" xml:space="preserve">
          <source>Generate output for a 5206e ColdFire CPU. The option is now deprecated in favor of the equivalent</source>
          <target state="translated">为5206e ColdFire CPU生成输出。该选项现在已被废止,改用了等效的</target>
        </trans-unit>
        <trans-unit id="64050f292f81abd70f3bb1391b078794170aa43c" translate="yes" xml:space="preserve">
          <source>Generate output for a 520X ColdFire CPU. This is the default when the compiler is configured for 520X-based systems. It is equivalent to</source>
          <target state="translated">为520X ColdFire CPU生成输出。当编译器被配置为基于520X的系统时,这是默认的。它相当于</target>
        </trans-unit>
        <trans-unit id="4e6125bf5e16c60081ffba73c18391756b953da9" translate="yes" xml:space="preserve">
          <source>Generate output for a 68000. This is the default when the compiler is configured for 68000-based systems. It is equivalent to</source>
          <target state="translated">为68000生成输出。当编译器被配置为基于68000的系统时,这是默认的。它相当于</target>
        </trans-unit>
        <trans-unit id="293fc36513894f8af34456d5d4568e3a8a660df3" translate="yes" xml:space="preserve">
          <source>Generate output for a 68010. This is the default when the compiler is configured for 68010-based systems. It is equivalent to</source>
          <target state="translated">为68010生成输出。当编译器被配置为基于68010的系统时,这是默认的。它相当于</target>
        </trans-unit>
        <trans-unit id="3de0124e7fb5a143b3bdb1e5bf42ea00b8dc1041" translate="yes" xml:space="preserve">
          <source>Generate output for a 68020. This is the default when the compiler is configured for 68020-based systems. It is equivalent to</source>
          <target state="translated">为68020生成输出。当编译器被配置为基于68020的系统时,这是默认的。它相当于</target>
        </trans-unit>
        <trans-unit id="a2125889bc447fbbe5141c63e65b9cc93af2774c" translate="yes" xml:space="preserve">
          <source>Generate output for a 68030. This is the default when the compiler is configured for 68030-based systems. It is equivalent to</source>
          <target state="translated">为68030生成输出。当编译器被配置为基于68030的系统时,这是默认的。它相当于</target>
        </trans-unit>
        <trans-unit id="dcd8a9aedf0282928a86db993cf8d4ff8070b038" translate="yes" xml:space="preserve">
          <source>Generate output for a 68040, without using any of the new instructions. This results in code that can run relatively efficiently on either a 68020/68881 or a 68030 or a 68040. The generated code does use the 68881 instructions that are emulated on the 68040.</source>
          <target state="translated">在不使用任何新指令的情况下,为68040生成输出。这样产生的代码可以比较有效地在68020/68881或68030或68040上运行。生成的代码确实使用了68040上模拟的68881指令。</target>
        </trans-unit>
        <trans-unit id="dd4119d908a2b18c651ef46f26b46cd2bc8b0de2" translate="yes" xml:space="preserve">
          <source>Generate output for a 68040. This is the default when the compiler is configured for 68040-based systems. It is equivalent to</source>
          <target state="translated">为68040生成输出。当编译器被配置为基于68040的系统时,这是默认的。它相当于</target>
        </trans-unit>
        <trans-unit id="c0e33f0f063c998bb9f2f1ad28f52830efcc367f" translate="yes" xml:space="preserve">
          <source>Generate output for a 68060, without using any of the new instructions. This results in code that can run relatively efficiently on either a 68020/68881 or a 68030 or a 68040. The generated code does use the 68881 instructions that are emulated on the 68060.</source>
          <target state="translated">在不使用任何新指令的情况下,为68060生成输出。这样产生的代码可以比较有效地在68020/68881或68030或68040上运行。生成的代码确实使用了68060上模拟的68881指令。</target>
        </trans-unit>
        <trans-unit id="4e0aa817ee3651021250220786d7a8ddadf8d908" translate="yes" xml:space="preserve">
          <source>Generate output for a 68060. This is the default when the compiler is configured for 68060-based systems. It is equivalent to</source>
          <target state="translated">为68060生成输出。当编译器被配置为基于68060的系统时,这是默认的。它相当于</target>
        </trans-unit>
        <trans-unit id="ea5be8485d83583c41e5d8584b5916331ad44880" translate="yes" xml:space="preserve">
          <source>Generate output for a CPU32. This is the default when the compiler is configured for CPU32-based systems. It is equivalent to</source>
          <target state="translated">为CPU32生成输出。当编译器被配置为基于CPU32的系统时,这是默认的。它相当于</target>
        </trans-unit>
        <trans-unit id="e1d15ac03ce80d2a7972245b867ea55ebdb92c9b" translate="yes" xml:space="preserve">
          <source>Generate output for a ColdFire 5307 CPU. The option is now deprecated in favor of the equivalent</source>
          <target state="translated">为ColdFire 5307 CPU生成输出。该选项现在已被废弃,改用等效的</target>
        </trans-unit>
        <trans-unit id="8e01c68482064d3161a9a189e69a1cae2c323dfb" translate="yes" xml:space="preserve">
          <source>Generate output for a ColdFire 5407 CPU. The option is now deprecated in favor of the equivalent</source>
          <target state="translated">为ColdFire 5407 CPU生成输出。这个选项现在已经被废止了,改用了等效的</target>
        </trans-unit>
        <trans-unit id="0aa9f4c3f64933730b3c4adacac26f4b2456673a" translate="yes" xml:space="preserve">
          <source>Generate output for a ColdFire V4e family CPU (e.g. 547x/548x). This includes use of hardware floating-point instructions. The option is equivalent to</source>
          <target state="translated">为ColdFire V4e系列CPU(如547x/548x)生成输出。这包括使用硬件浮点指令。该选项相当于</target>
        </trans-unit>
        <trans-unit id="e7347e49e1182821745b1b659d00df4d824a3e04" translate="yes" xml:space="preserve">
          <source>Generate output for a member of the ColdFire 528X family. The option is now deprecated in favor of the equivalent</source>
          <target state="translated">为 ColdFire 528X 系列的成员生成输出。该选项现在已被废止,改用等效的</target>
        </trans-unit>
        <trans-unit id="18dcb26797382565521c621a512430444b4e53d3" translate="yes" xml:space="preserve">
          <source>Generate performance extension 2 instructions.</source>
          <target state="translated">生成性能扩展2指令。</target>
        </trans-unit>
        <trans-unit id="bd6544f4b4eb02ec7c1103af517606738fd2ba09" translate="yes" xml:space="preserve">
          <source>Generate performance extension instructions.</source>
          <target state="translated">生成性能扩展指令。</target>
        </trans-unit>
        <trans-unit id="d399ee7f07dc0a2fb4ab33398b031c9b688f806f" translate="yes" xml:space="preserve">
          <source>Generate position-independent EABI code.</source>
          <target state="translated">生成与位置无关的EABI代码。</target>
        </trans-unit>
        <trans-unit id="1d1142004c8111e7c50b740035c14c26ae3a4d40" translate="yes" xml:space="preserve">
          <source>Generate position-independent code (PIC) suitable for use in a shared library, if supported for the target machine. Such code accesses all constant addresses through a global offset table (GOT). The dynamic loader resolves the GOT entries when the program starts (the dynamic loader is not part of GCC; it is part of the operating system). If the GOT size for the linked executable exceeds a machine-specific maximum size, you get an error message from the linker indicating that</source>
          <target state="translated">生成适合在共享库中使用的位置无关代码(PIC),如果目标机器支持的话。这种代码通过全局偏移表(GOT)访问所有常数地址。动态加载器在程序启动时解析GOT条目(动态加载器不是GCC的一部分,它是操作系统的一部分)。如果被链接的可执行文件的GOT大小超过了特定机器的最大大小,你会从链接器中得到一条错误信息,表明</target>
        </trans-unit>
        <trans-unit id="48b952028eaadcc5cf5b2652a4f09475aac1135d" translate="yes" xml:space="preserve">
          <source>Generate secure code as per the &quot;ARMv8-M Security Extensions: Requirements on Development Tools Engineering Specification&quot;, which can be found on &lt;a href=&quot;http://infocenter.arm.com/help/topic/com.arm.doc.ecm0359818/ECM0359818_armv8m_security_extensions_reqs_on_dev_tools_1_0.pdf&quot;&gt;http://infocenter.arm.com/help/topic/com.arm.doc.ecm0359818/ECM0359818_armv8m_security_extensions_reqs_on_dev_tools_1_0.pdf&lt;/a&gt;.</source>
          <target state="translated">根据&amp;ldquo; ARMv8-M安全扩展：开发工具工程规范的要求&amp;rdquo;生成安全代码，该代码可在&lt;a href=&quot;http://infocenter.arm.com/help/topic/com.arm.doc.ecm0359818/ECM0359818_armv8m_security_extensions_reqs_on_dev_tools_1_0.pdf&quot;&gt;http://infocenter.arm.com/help/topic/com.arm.doc.ecm0359818/ECM0359818_armv8m_security_extensions_reqs_on_dev_tools_1_0中&lt;/a&gt;找到。 PDF格式。</target>
        </trans-unit>
        <trans-unit id="61825c7f7fe0283dfaa12a0bf7f79986a97151b2" translate="yes" xml:space="preserve">
          <source>Generate single-precision FPX instructions, tuned for the compact implementation.</source>
          <target state="translated">生成单精度FPX指令,针对紧凑的实现进行调整。</target>
        </trans-unit>
        <trans-unit id="57fc66010a803fb795da295b4fbe9fac5a8dbfd1" translate="yes" xml:space="preserve">
          <source>Generate single-precision FPX instructions, tuned for the fast implementation.</source>
          <target state="translated">生成单精度FPX指令,调整为快速实现。</target>
        </trans-unit>
        <trans-unit id="03e730324ac713e9445bac5587ed90df17b4e2e3" translate="yes" xml:space="preserve">
          <source>Generate software atomic sequences that temporarily disable interrupts by setting &lt;code&gt;SR.IMASK = 1111&lt;/code&gt;. This model works only when the program runs in privileged mode and is only suitable for single-core systems. Additional support from the interrupt/exception handling code of the system is not required. This model is enabled by default when the target is &lt;code&gt;sh*-*-linux*&lt;/code&gt; and SH1* or SH2*.</source>
          <target state="translated">通过设置 &lt;code&gt;SR.IMASK = 1111&lt;/code&gt; 生成暂时禁用中断的软件原子序列。仅当程序在特权模式下运行时，此模型才有效，并且仅适用于单核系统。不需要系统的中断/异常处理代码的额外支持。当目标为 &lt;code&gt;sh*-*-linux*&lt;/code&gt; 和SH1 *或SH2 * 时，默认情况下启用此模型。</target>
        </trans-unit>
        <trans-unit id="adcbfbeac80cfe6a3e4b55a0bdfaf3f19f30fbea" translate="yes" xml:space="preserve">
          <source>Generate software atomic sequences that use a variable in the thread control block. This is a variation of the gUSA sequences which can also be used on SH1* and SH2* targets. The generated atomic sequences require additional support from the interrupt/exception handling code of the system and are only suitable for single-core systems. When using this model, the &amp;lsquo;</source>
          <target state="translated">生成使用原子控制块中的变量的软件原子序列。这是gUSA序列的变体，也可以用于SH1 *和SH2 *靶标。生成的原子序列需要系统中断/异常处理代码的额外支持，并且仅适用于单核系统。使用此模型时，</target>
        </trans-unit>
        <trans-unit id="7e273affad800c8c4cf1d009bbdccfc4d50d0a21" translate="yes" xml:space="preserve">
          <source>Generate stack protection code using canary at &lt;var&gt;guard&lt;/var&gt;. Supported locations are &amp;lsquo;</source>
          <target state="translated">使用canary at &lt;var&gt;guard&lt;/var&gt; 生成堆栈保护代码。支持的位置是&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="b8a639f56facade8c98595f71ed5d4db9ac64830" translate="yes" xml:space="preserve">
          <source>Generate string extension instructions.</source>
          <target state="translated">生成字符串扩展指令。</target>
        </trans-unit>
        <trans-unit id="8a1f94259681f1ae170bbb57344c845c25fbbd90" translate="yes" xml:space="preserve">
          <source>Generate the &lt;code&gt;tas.b&lt;/code&gt; opcode for &lt;code&gt;__atomic_test_and_set&lt;/code&gt;. Notice that depending on the particular hardware and software configuration this can degrade overall performance due to the operand cache line flushes that are implied by the &lt;code&gt;tas.b&lt;/code&gt; instruction. On multi-core SH4A processors the &lt;code&gt;tas.b&lt;/code&gt; instruction must be used with caution since it can result in data corruption for certain cache configurations.</source>
          <target state="translated">为 &lt;code&gt;__atomic_test_and_set&lt;/code&gt; 生成 &lt;code&gt;tas.b&lt;/code&gt; 操作码。注意，由于特定的硬件和软件配置，这可能会降低整体性能，因为 &lt;code&gt;tas.b&lt;/code&gt; 指令隐含了操作数缓存行刷新。在多核SH4A处理器上，必须谨慎使用 &lt;code&gt;tas.b&lt;/code&gt; 指令，因为它可能导致某些高速缓存配置的数据损坏。</target>
        </trans-unit>
        <trans-unit id="33b6af1538444b86d0ad7d0fedaceadc538e6781" translate="yes" xml:space="preserve">
          <source>Generate the predefine, &lt;code&gt;_SIO&lt;/code&gt;, for server IO. The default is</source>
          <target state="translated">为服务器IO 生成预定义 &lt;code&gt;_SIO&lt;/code&gt; 。默认是</target>
        </trans-unit>
        <trans-unit id="556e10b173cc8258302ad6ae7353988cc9258bb9" translate="yes" xml:space="preserve">
          <source>Generate unwind table in DWARF format, if supported by target machine. The table is exact at each instruction boundary, so it can be used for stack unwinding from asynchronous events (such as debugger or garbage collector).</source>
          <target state="translated">如果目标机器支持,生成DWARF格式的解卷表。该表在每个指令边界处都是精确的,所以它可以用于异步事件(如调试器或垃圾收集器)的堆栈解卷。</target>
        </trans-unit>
        <trans-unit id="57527d83fd3616a340b11bb579911dbfd64f477e" translate="yes" xml:space="preserve">
          <source>Generate v3 push25/pop25 instructions.</source>
          <target state="translated">生成v3 push25/pop25指令。</target>
        </trans-unit>
        <trans-unit id="fb9942d737ee06d15159ff521f994cc01ae69210" translate="yes" xml:space="preserve">
          <source>Generated code is not compatible with hardware interrupts. Code size is smaller.</source>
          <target state="translated">生成的代码与硬件中断不兼容。代码大小较小。</target>
        </trans-unit>
        <trans-unit id="95fc43dc3dce502b8d3a439f3daa647aaa660090" translate="yes" xml:space="preserve">
          <source>Generates</source>
          <target state="translated">Generates</target>
        </trans-unit>
        <trans-unit id="847361d2a7401aea217f81327402896d9c474e00" translate="yes" xml:space="preserve">
          <source>Generates &lt;code&gt;sbit&lt;/code&gt;/&lt;code&gt;cbit&lt;/code&gt; instructions for bit manipulations.</source>
          <target state="translated">生成用于位操作的 &lt;code&gt;sbit&lt;/code&gt; / &lt;code&gt;cbit&lt;/code&gt; 指令。</target>
        </trans-unit>
        <trans-unit id="8c23e71aebd89fa525027dc7a4570046a7a64ce0" translate="yes" xml:space="preserve">
          <source>Generates an error message. This pragma &lt;em&gt;is&lt;/em&gt; considered to indicate an error in the compilation, and it will be treated as such.</source>
          <target state="translated">生成错误消息。该编译指示&lt;em&gt;被&lt;/em&gt;认为指示编译&lt;em&gt;中&lt;/em&gt;的错误，将被视为错误。</target>
        </trans-unit>
        <trans-unit id="b4a08a286760cba742dec264941903cd2180c988" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;brk&lt;/code&gt; machine instruction.</source>
          <target state="translated">生成 &lt;code&gt;brk&lt;/code&gt; 机器指令。</target>
        </trans-unit>
        <trans-unit id="de0ffdd1afe0ff10e18f301f3481e988ec1af918" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;clrpsw&lt;/code&gt; machine instruction to clear the specified bit in the processor status word.</source>
          <target state="translated">生成 &lt;code&gt;clrpsw&lt;/code&gt; 机器指令以清除处理器状态字中的指定位。</target>
        </trans-unit>
        <trans-unit id="e384966166fe10a7e3cda9622b8d991e42dbafb8" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;crc32b&lt;/code&gt; machine instruction.</source>
          <target state="translated">生成 &lt;code&gt;crc32b&lt;/code&gt; 机器指令。</target>
        </trans-unit>
        <trans-unit id="097e8495f2e00512011587a86cec2af02faf3293" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;crc32l&lt;/code&gt; machine instruction.</source>
          <target state="translated">生成 &lt;code&gt;crc32l&lt;/code&gt; 机器指令。</target>
        </trans-unit>
        <trans-unit id="257268a989f9b93ff19c2d7c87cb2336d607cc4f" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;crc32q&lt;/code&gt; machine instruction.</source>
          <target state="translated">生成 &lt;code&gt;crc32q&lt;/code&gt; 机器指令。</target>
        </trans-unit>
        <trans-unit id="b6ee9ffc23cac162df8a9b520916fe8eb4063947" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;crc32w&lt;/code&gt; machine instruction.</source>
          <target state="translated">生成 &lt;code&gt;crc32w&lt;/code&gt; 机器指令。</target>
        </trans-unit>
        <trans-unit id="9c0298bd9ac40c51cad36ed168d5ebaa6178f1de" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;etnd&lt;/code&gt; machine instruction. The current nesting depth is returned as integer value. For a nesting depth of 0 the code is not executed as part of an transaction.</source>
          <target state="translated">生成 &lt;code&gt;etnd&lt;/code&gt; 机器指令。当前嵌套深度以整数值形式返回。如果嵌套深度为0，则代码不会作为事务的一部分执行。</target>
        </trans-unit>
        <trans-unit id="ba9daaa604a3528f1838ae3869b5e548870970eb" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;extractps&lt;/code&gt; machine instruction.</source>
          <target state="translated">生成 &lt;code&gt;extractps&lt;/code&gt; 机器指令。</target>
        </trans-unit>
        <trans-unit id="89f2857c101ed877edbedb096cf0c5b70642f1a6" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;insertps&lt;/code&gt; machine instruction.</source>
          <target state="translated">生成 &lt;code&gt;insertps&lt;/code&gt; 机器指令。</target>
        </trans-unit>
        <trans-unit id="bddf0335c49f41b446b0994e140cc0b296730b66" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;int&lt;/code&gt; machine instruction to generate an interrupt with the specified value.</source>
          <target state="translated">生成 &lt;code&gt;int&lt;/code&gt; 机器指令以生成具有指定值的中断。</target>
        </trans-unit>
        <trans-unit id="cc578c8838d75de69df84505da3623cd37d917cc" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;machi&lt;/code&gt; machine instruction to add the result of multiplying the top 16 bits of the two arguments into the accumulator.</source>
          <target state="translated">生成 &lt;code&gt;machi&lt;/code&gt; 机器指令，以将两个自变量的高16位相乘的结果相加到累加器中。</target>
        </trans-unit>
        <trans-unit id="99eacdb7a1185745b3f8d3546aa5c195c4ffc120" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;maclo&lt;/code&gt; machine instruction to add the result of multiplying the bottom 16 bits of the two arguments into the accumulator.</source>
          <target state="translated">生成 &lt;code&gt;maclo&lt;/code&gt; 机器指令，以将两个参数的低16位相乘的结果相加到累加器中。</target>
        </trans-unit>
        <trans-unit id="7a0ca51423d0e24c5de865392e13bff92dec8a47" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;movhps&lt;/code&gt; machine instruction as a load from memory.</source>
          <target state="translated">从内存生成 &lt;code&gt;movhps&lt;/code&gt; 机器指令作为负载。</target>
        </trans-unit>
        <trans-unit id="a6336fc5b41c1f5923ae66b48c6856394b9f7d5d" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;movhps&lt;/code&gt; machine instruction as a store to memory.</source>
          <target state="translated">生成 &lt;code&gt;movhps&lt;/code&gt; 机器指令作为存储器存储。</target>
        </trans-unit>
        <trans-unit id="81a1c47a7ece45e98596dc9420085617e89d6661" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;movlps&lt;/code&gt; machine instruction as a load from memory</source>
          <target state="translated">从内存生成 &lt;code&gt;movlps&lt;/code&gt; 机器指令作为负载</target>
        </trans-unit>
        <trans-unit id="1e491626b2ecf306727f7b2f326dde340a6befb6" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;movlps&lt;/code&gt; machine instruction as a store to memory.</source>
          <target state="translated">生成 &lt;code&gt;movlps&lt;/code&gt; 机器指令作为存储器存储。</target>
        </trans-unit>
        <trans-unit id="ac79e7ffaaf077d95a6d1ffa3d8fb253edbeb451" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;movss&lt;/code&gt; machine instruction as a load from memory.</source>
          <target state="translated">从内存生成 &lt;code&gt;movss&lt;/code&gt; 机器指令作为负载。</target>
        </trans-unit>
        <trans-unit id="2dc4d75da1c01f01ac98af15d63b74a7af18475d" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;movups&lt;/code&gt; machine instruction as a load from memory.</source>
          <target state="translated">从内存生成 &lt;code&gt;movups&lt;/code&gt; 机器指令作为负载。</target>
        </trans-unit>
        <trans-unit id="363646d48f8bc2356c5c4e7f637ebc00c96d25d3" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;movups&lt;/code&gt; machine instruction as a store to memory.</source>
          <target state="translated">生成 &lt;code&gt;movups&lt;/code&gt; 机器指令作为存储器存储。</target>
        </trans-unit>
        <trans-unit id="bc35453eece3fefcd1bc15a0d478b36419def393" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;mulhi&lt;/code&gt; machine instruction to place the result of multiplying the top 16 bits of the two arguments into the accumulator.</source>
          <target state="translated">生成 &lt;code&gt;mulhi&lt;/code&gt; 机器指令，以将两个自变量的高16位相乘的结果放入累加器。</target>
        </trans-unit>
        <trans-unit id="52d614340e6bcb9b13e27d9daf3f3ec4c3e7003e" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;mullo&lt;/code&gt; machine instruction to place the result of multiplying the bottom 16 bits of the two arguments into the accumulator.</source>
          <target state="translated">生成 &lt;code&gt;mullo&lt;/code&gt; 机器指令，以将两个自变量的低16位相乘的结果放入累加器。</target>
        </trans-unit>
        <trans-unit id="37702a0f744e0973c9767b2a0ae0b071d0ab6011" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;mvfachi&lt;/code&gt; machine instruction to read the top 32 bits of the accumulator.</source>
          <target state="translated">生成 &lt;code&gt;mvfachi&lt;/code&gt; 机器指令以读取累加器的高32位。</target>
        </trans-unit>
        <trans-unit id="e5e940957ba8e9f4e4a5a9b38f5ec9bacccdcd1d" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;mvfacmi&lt;/code&gt; machine instruction to read the middle 32 bits of the accumulator.</source>
          <target state="translated">生成 &lt;code&gt;mvfacmi&lt;/code&gt; 机器指令以读取累加器的中间32位。</target>
        </trans-unit>
        <trans-unit id="84ea7bb4390bbd29b42442b2c0df648769428770" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;mvfc&lt;/code&gt; machine instruction which reads the control register specified in its argument and returns its value.</source>
          <target state="translated">生成 &lt;code&gt;mvfc&lt;/code&gt; 机器指令，该指令读取其参数中指定的控制寄存器并返回其值。</target>
        </trans-unit>
        <trans-unit id="9a7f85fadc166c23e3a73720a98d17ae8d98c867" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;mvtachi&lt;/code&gt; machine instruction to set the top 32 bits of the accumulator.</source>
          <target state="translated">生成 &lt;code&gt;mvtachi&lt;/code&gt; 机器指令以设置累加器的高32位。</target>
        </trans-unit>
        <trans-unit id="c2fa5a8c449853ed0e286fabb00686c6c4684432" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;mvtaclo&lt;/code&gt; machine instruction to set the bottom 32 bits of the accumulator.</source>
          <target state="translated">生成 &lt;code&gt;mvtaclo&lt;/code&gt; 机器指令以设置累加器的低32位。</target>
        </trans-unit>
        <trans-unit id="0c726977269ab1aef450eb4579a182f674e2891b" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;mvtc&lt;/code&gt; machine instruction which sets control register number &lt;code&gt;reg&lt;/code&gt; to &lt;code&gt;val&lt;/code&gt;.</source>
          <target state="translated">生成将控制寄存器号 &lt;code&gt;reg&lt;/code&gt; 设置为 &lt;code&gt;val&lt;/code&gt; 的 &lt;code&gt;mvtc&lt;/code&gt; 机器指令。</target>
        </trans-unit>
        <trans-unit id="e73288099a5726fcb09aeebaa5734e10714eb5f2" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;mvtipl&lt;/code&gt; machine instruction set the interrupt priority level.</source>
          <target state="translated">生成 &lt;code&gt;mvtipl&lt;/code&gt; 机器指令集的中断优先级。</target>
        </trans-unit>
        <trans-unit id="c95405f984d5d6abab06b81618d6b2d88c6bce16" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;ntstg&lt;/code&gt; machine instruction. The second argument is written to the first arguments location. The store operation will not be rolled-back in case of an transaction abort.</source>
          <target state="translated">生成 &lt;code&gt;ntstg&lt;/code&gt; 机器指令。第二个参数写入第一个参数位置。如果事务中止，则不会回滚存储操作。</target>
        </trans-unit>
        <trans-unit id="221810e17f3f5b7b6eee2c597dcc35e9560d5c1a" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;pause&lt;/code&gt; machine instruction with a compiler memory barrier.</source>
          <target state="translated">生成带有编译器内存屏障的 &lt;code&gt;pause&lt;/code&gt; 机器指令。</target>
        </trans-unit>
        <trans-unit id="fabcc577b37bbc75f15d4acfc478723f40e312bf" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;pclmulqdq&lt;/code&gt; machine instruction.</source>
          <target state="translated">生成 &lt;code&gt;pclmulqdq&lt;/code&gt; 机器指令。</target>
        </trans-unit>
        <trans-unit id="138581c28238370fdca095f892b8bcc2f037ebde" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;pextrb&lt;/code&gt; machine instruction.</source>
          <target state="translated">生成 &lt;code&gt;pextrb&lt;/code&gt; 机器指令。</target>
        </trans-unit>
        <trans-unit id="cc89464fd0e0ffc62121a43ea4c78a22a765f79b" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;pextrd&lt;/code&gt; machine instruction.</source>
          <target state="translated">生成 &lt;code&gt;pextrd&lt;/code&gt; 机器指令。</target>
        </trans-unit>
        <trans-unit id="6995305b1713c32c1cb9c1c29aa123fa501311ad" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;pextrq&lt;/code&gt; machine instruction in 64bit mode.</source>
          <target state="translated">在64位模式下生成 &lt;code&gt;pextrq&lt;/code&gt; 机器指令。</target>
        </trans-unit>
        <trans-unit id="7afd0d12563bc8ecde0ac65ab4ecf09a6388cc0c" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;pinsrb&lt;/code&gt; machine instruction.</source>
          <target state="translated">生成 &lt;code&gt;pinsrb&lt;/code&gt; 机器指令。</target>
        </trans-unit>
        <trans-unit id="587eac9a0053b04618284992d46512728f7465b0" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;pinsrd&lt;/code&gt; machine instruction.</source>
          <target state="translated">生成 &lt;code&gt;pinsrd&lt;/code&gt; 机器指令。</target>
        </trans-unit>
        <trans-unit id="e89f9467a7fdb5f2511c4d93da028b6494b1db2e" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;pinsrq&lt;/code&gt; machine instruction in 64bit mode.</source>
          <target state="translated">在64位模式下生成 &lt;code&gt;pinsrq&lt;/code&gt; 机器指令。</target>
        </trans-unit>
        <trans-unit id="167d17fe5058f3ef0cb33d59903eebaaf6162e68" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;popcntl&lt;/code&gt; machine instruction.</source>
          <target state="translated">生成 &lt;code&gt;popcntl&lt;/code&gt; 机器指令。</target>
        </trans-unit>
        <trans-unit id="6cb126029514e2d5bfcb6bca148eb150b8aba8a4" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;popcntl&lt;/code&gt; or &lt;code&gt;popcntq&lt;/code&gt; machine instruction, depending on the size of &lt;code&gt;unsigned long&lt;/code&gt;.</source>
          <target state="translated">根据 &lt;code&gt;unsigned long&lt;/code&gt; 的大小，生成 &lt;code&gt;popcntl&lt;/code&gt; 或 &lt;code&gt;popcntq&lt;/code&gt; 机器指令。</target>
        </trans-unit>
        <trans-unit id="c32c9ad948f2048e1fcb6de749499d83eb38bfdd" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;popcntq&lt;/code&gt; machine instruction.</source>
          <target state="translated">生成 &lt;code&gt;popcntq&lt;/code&gt; 机器指令。</target>
        </trans-unit>
        <trans-unit id="c6a384a17f6c55681ebb99e208e7e76367ba0a5f" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;ppa rX,rY,1&lt;/code&gt; machine instruction. Where the integer parameter is loaded into rX and a value of zero is loaded into rY. The integer parameter specifies the number of times the transaction repeatedly aborted.</source>
          <target state="translated">生成 &lt;code&gt;ppa rX,rY,1&lt;/code&gt; 机器指令。其中将整数参数加载到rX中，将零值加载到rY中。整数参数指定事务重复中止的次数。</target>
        </trans-unit>
        <trans-unit id="2ad4e7198804a310937a6c8bd6ea66807f131d33" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;racw&lt;/code&gt; machine instruction to round the accumulator according to the specified mode.</source>
          <target state="translated">生成 &lt;code&gt;racw&lt;/code&gt; 机器指令以根据指定模式对累加器进行取整。</target>
        </trans-unit>
        <trans-unit id="94afa89c73a482e7f60ea3534ec6652b684e5611" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;revw&lt;/code&gt; machine instruction which swaps the bytes in the argument so that bits 0&amp;ndash;7 now occupy bits 8&amp;ndash;15 and vice versa, and also bits 16&amp;ndash;23 occupy bits 24&amp;ndash;31 and vice versa.</source>
          <target state="translated">生成 &lt;code&gt;revw&lt;/code&gt; machine指令，该指令交换参数中的字节，以使位0-7现在占据位8-15，反之亦然，位16-23也占据位24-31，反之亦然。</target>
        </trans-unit>
        <trans-unit id="6d19e7f0e193910eff939ea1df5fd508cf81e1dd" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;rmpa&lt;/code&gt; machine instruction which initiates a repeated multiply and accumulate sequence.</source>
          <target state="translated">生成 &lt;code&gt;rmpa&lt;/code&gt; 机器指令，该指令启动重复的乘法和累加序列。</target>
        </trans-unit>
        <trans-unit id="3a3c845817720a1abf8f57c24608a050c45caf15" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;round&lt;/code&gt; machine instruction which returns the floating-point argument rounded according to the current rounding mode set in the floating-point status word register.</source>
          <target state="translated">生成 &lt;code&gt;round&lt;/code&gt; 机器指令，该指令返回根据在浮点状态字寄存器中设置的当前舍入模式舍入的浮点参数。</target>
        </trans-unit>
        <trans-unit id="693bacff2407833725bfd8a8b85cfbf1bb7e034c" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;sat&lt;/code&gt; machine instruction which returns the saturated value of the argument.</source>
          <target state="translated">生成 &lt;code&gt;sat&lt;/code&gt; 机器指令，该指令返回参数的饱和值。</target>
        </trans-unit>
        <trans-unit id="0bd4f2535ab0460fd7e26bbf4e95465d1caef5d0" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;setpsw&lt;/code&gt; machine instruction to set the specified bit in the processor status word.</source>
          <target state="translated">生成 &lt;code&gt;setpsw&lt;/code&gt; 机器指令以设置处理器状态字中的指定位。</target>
        </trans-unit>
        <trans-unit id="86af23191f84ff6e1646de29e1379a9fa322b441" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;tabort&lt;/code&gt; machine instruction with the specified abort code. Abort codes from 0 through 255 are reserved and will result in an error message.</source>
          <target state="translated">使用指定的中止代码生成 &lt;code&gt;tabort&lt;/code&gt; 机器指令。保留从0到255的中止代码，这将导致错误消息。</target>
        </trans-unit>
        <trans-unit id="41fafa8bbaf148ec213bd90ff158b6b99b4cd68d" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;tbegin&lt;/code&gt; machine instruction starting a non-constrained hardware transaction. If the parameter is non-NULL the memory area is used to store the transaction diagnostic buffer and will be passed as first operand to &lt;code&gt;tbegin&lt;/code&gt;. This buffer can be defined using the &lt;code&gt;struct __htm_tdb&lt;/code&gt; C struct defined in &lt;code&gt;htmintrin.h&lt;/code&gt; and must reside on a double-word boundary. The second tbegin operand is set to &lt;code&gt;0xff0c&lt;/code&gt;. This enables save/restore of all GPRs and disables aborts for FPR and AR manipulations inside the transaction body. The condition code set by the tbegin instruction is returned as integer value. The tbegin instruction by definition overwrites the content of all FPRs. The compiler will generate code which saves and restores the FPRs. For soft-float code it is recommended to used the &lt;code&gt;*_nofloat&lt;/code&gt; variant. In order to prevent a TDB from being written it is required to pass a constant zero value as parameter. Passing a zero value through a variable is not sufficient. Although modifications of access registers inside the transaction will not trigger an transaction abort it is not supported to actually modify them. Access registers do not get saved when entering a transaction. They will have undefined state when reaching the abort code.</source>
          <target state="translated">生成 &lt;code&gt;tbegin&lt;/code&gt; 机器指令，开始无约束的硬件事务。如果参数为非NULL，则将使用内存区域存储事务诊断缓冲区，并将其作为第一个操作数传递给 &lt;code&gt;tbegin&lt;/code&gt; 。该缓冲器可以使用被限定 &lt;code&gt;struct __htm_tdb&lt;/code&gt; 中所定义的C结构 &lt;code&gt;htmintrin.h&lt;/code&gt; 和必须驻留在双字边界上。第二个tbegin操作数设置为 &lt;code&gt;0xff0c&lt;/code&gt; 。这将启用所有GPR的保存/恢复，并禁用事务主体内FPR和AR操作的中止。由tbegin指令设置的条件代码以整数值形式返回。根据定义，tbegin指令将覆盖所有FPR的内容。编译器将生成保存和还原FPR的代码。对于软浮点代码，建议使用 &lt;code&gt;*_nofloat&lt;/code&gt; 变体。为了防止写入TDB，需要传递一个恒定的零值作为参数。通过变量传递零值是不够的。尽管修改事务内部的访问寄存器不会触发事务中止，但实际上不支持对其进行修改。进入交易时不会保存访问寄存器。到达中止代码时，它们将具有未定义的状态。</target>
        </trans-unit>
        <trans-unit id="e6827eb1aea4f7107218c612803fe4d6ada64dff" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;tbeginc&lt;/code&gt; machine instruction starting a constrained hardware transaction. The second operand is set to &lt;code&gt;0xff08&lt;/code&gt;.</source>
          <target state="translated">生成启动受限硬件事务的 &lt;code&gt;tbeginc&lt;/code&gt; 机器指令。第二个操作数设置为 &lt;code&gt;0xff08&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1623696be46dd23fac7b3be91a9dabc88baaf7ab" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;tend&lt;/code&gt; machine instruction finishing a transaction and making the changes visible to other threads. The condition code generated by tend is returned as integer value.</source>
          <target state="translated">生成 &lt;code&gt;tend&lt;/code&gt; 机器指令，以完成事务并使更改对其他线程可见。由tend生成的条件代码将作为整数值返回。</target>
        </trans-unit>
        <trans-unit id="98be0f38fb4c5ac278186b26e4d1c15696ff51bf" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;wait&lt;/code&gt; machine instruction.</source>
          <target state="translated">生成 &lt;code&gt;wait&lt;/code&gt; 机器指令。</target>
        </trans-unit>
        <trans-unit id="0edb628a9542a14f813bd7de9f8386b56c8a58b5" translate="yes" xml:space="preserve">
          <source>Generates:</source>
          <target state="translated">Generates:</target>
        </trans-unit>
        <trans-unit id="ea3f79632679059de141d66e9dca3bc06851d467" translate="yes" xml:space="preserve">
          <source>Generic VIA Nano CPU with x86-64, MMX, SSE, SSE2, SSE3 and SSSE3 instruction set support. (No scheduling is implemented for this chip.)</source>
          <target state="translated">通用的威盛Nano CPU,支持x86-64、MMX、SSE、SSE2、SSE3和SSSE3指令集。(该芯片没有实现调度。)</target>
        </trans-unit>
        <trans-unit id="9aea01d94f58ef40baf7a92523ddcc334efa83d3" translate="yes" xml:space="preserve">
          <source>Get and set the contents of the floating-point control and status register (FPU control register 31). These functions are only available in hard-float code but can be called in both MIPS16 and non-MIPS16 contexts.</source>
          <target state="translated">获取和设置浮点控制和状态寄存器(FPU控制寄存器31)的内容。这些函数只在硬浮点代码中可用,但在MIPS16和非MIPS16的情况下都可以调用。</target>
        </trans-unit>
        <trans-unit id="93019384bd85aa8984f35ea4b05d12346052144c" translate="yes" xml:space="preserve">
          <source>Get the current value of shadow stack pointer if shadow stack support from Intel CET is enabled in the hardware or &lt;code&gt;0&lt;/code&gt; otherwise. The &lt;code&gt;ret_type&lt;/code&gt; is &lt;code&gt;unsigned long long&lt;/code&gt; for 64-bit targets and &lt;code&gt;unsigned int&lt;/code&gt; for 32-bit targets.</source>
          <target state="translated">如果硬件中启用了Intel CET的影子堆栈支持，则获取影子堆栈指针的当前值；否则，获取 &lt;code&gt;0&lt;/code&gt; 。所述 &lt;code&gt;ret_type&lt;/code&gt; 是 &lt;code&gt;unsigned long long&lt;/code&gt; 64位的目标和 &lt;code&gt;unsigned int&lt;/code&gt; 32位的目标。</target>
        </trans-unit>
        <trans-unit id="242390092876b4a7227130b506459512d744c5bd" translate="yes" xml:space="preserve">
          <source>Getting pointers to labels, and computed gotos.</source>
          <target state="translated">获取指向标签的指针,并计算出gotos。</target>
        </trans-unit>
        <trans-unit id="fbec048bbd1449a0bc11388da4d5291473184989" translate="yes" xml:space="preserve">
          <source>Getting the return or frame address of a function.</source>
          <target state="translated">获取函数的返回或帧地址。</target>
        </trans-unit>
        <trans-unit id="5bde8fdcb7065ba19c1a32d2b6a67073b7fb1601" translate="yes" xml:space="preserve">
          <source>Give a warning when a value of type &lt;code&gt;float&lt;/code&gt; is implicitly promoted to &lt;code&gt;double&lt;/code&gt;. CPUs with a 32-bit &amp;ldquo;single-precision&amp;rdquo; floating-point unit implement &lt;code&gt;float&lt;/code&gt; in hardware, but emulate &lt;code&gt;double&lt;/code&gt; in software. On such a machine, doing computations using &lt;code&gt;double&lt;/code&gt; values is much more expensive because of the overhead required for software emulation.</source>
          <target state="translated">当 &lt;code&gt;float&lt;/code&gt; 类型的值隐式提升为 &lt;code&gt;double&lt;/code&gt; 时发出警告。具有32位&amp;ldquo;单精度&amp;rdquo;浮点单元的CPU 在硬件中实现 &lt;code&gt;float&lt;/code&gt; ，但在软件中实现 &lt;code&gt;double&lt;/code&gt; 仿真。在这样的机器上，由于软件仿真所需的开销，使用 &lt;code&gt;double&lt;/code&gt; 值进行计算要昂贵得多。</target>
        </trans-unit>
        <trans-unit id="133654b9660498348bca9e7a9d9666b1d3206bc1" translate="yes" xml:space="preserve">
          <source>Give a warning whenever a function is used before being declared. In C99 mode (</source>
          <target state="translated">每当在声明之前使用一个函数时,都会给出一个警告。在C99模式下(</target>
        </trans-unit>
        <trans-unit id="ce9ec4f1d36927037e489058adc0d7c699b3e5d0" translate="yes" xml:space="preserve">
          <source>Give an error whenever the &lt;em&gt;base standard&lt;/em&gt; (see</source>
          <target state="translated">只要&lt;em&gt;基本标准&lt;/em&gt;（请参阅</target>
        </trans-unit>
        <trans-unit id="10288103238e1aab071f91b995853a568ee8af72" translate="yes" xml:space="preserve">
          <source>Given a set of input registers that die in an &lt;code&gt;asm&lt;/code&gt;, it is necessary to know which are implicitly popped by the &lt;code&gt;asm&lt;/code&gt;, and which must be explicitly popped by GCC.</source>
          <target state="translated">给定一组在 &lt;code&gt;asm&lt;/code&gt; 中死亡的输入寄存器，有必要知道哪些由 &lt;code&gt;asm&lt;/code&gt; 隐式弹出，哪些必须由GCC显式弹出。</target>
        </trans-unit>
        <trans-unit id="d87967442824754978f26c181e17cc9e46db44dd" translate="yes" xml:space="preserve">
          <source>Gives all externally visible functions in the file being compiled an ARM instruction set header which switches to Thumb mode before executing the rest of the function. This allows these functions to be called from non-interworking code. This option is not valid in AAPCS configurations because interworking is enabled by default.</source>
          <target state="translated">给正在编译的文件中的所有外部可见的函数一个ARM指令集头,该指令集头在执行函数的其余部分之前切换到Thumb模式。这允许从非互操作代码中调用这些函数。此选项在 AAPCS 配置中无效,因为默认情况下已启用了互操作。</target>
        </trans-unit>
        <trans-unit id="28fd2d80d56f82ae132cdb0c4269c770aa941c82" translate="yes" xml:space="preserve">
          <source>Global register variables cannot have initial values, because an executable file has no means to supply initial contents for a register.</source>
          <target state="translated">全局寄存器变量不能有初始值,因为可执行文件没有办法为寄存器提供初始内容。</target>
        </trans-unit>
        <trans-unit id="e1edbfbe92e2bd9d3f1182eb37f4bcfb20acdde5" translate="yes" xml:space="preserve">
          <source>Go source code.</source>
          <target state="translated">去源码。</target>
        </trans-unit>
        <trans-unit id="0104e918e01eb5413cf5e7e2b781b5b40dca1b8d" translate="yes" xml:space="preserve">
          <source>Guide linker to relax instructions.</source>
          <target state="translated">引导联结者放松指示。</target>
        </trans-unit>
        <trans-unit id="7cf184f4c67ad58283ecb19349720b0cae756829" translate="yes" xml:space="preserve">
          <source>H</source>
          <target state="translated">H</target>
        </trans-unit>
        <trans-unit id="c2d31434fb0f344cb4feeec0b0e57232ab31c7ad" translate="yes" xml:space="preserve">
          <source>HI and LO registers.</source>
          <target state="translated">HI和LO寄存器。</target>
        </trans-unit>
        <trans-unit id="ae1313e0d197443a538cfdaa0498460e61bc9b40" translate="yes" xml:space="preserve">
          <source>HI register.</source>
          <target state="translated">HI注册。</target>
        </trans-unit>
        <trans-unit id="9ffcbdd38d89bcb3eaa62489fe7281d06ece8295" translate="yes" xml:space="preserve">
          <source>HIGH register class $r12 to $r14, $r20 to $r31.</source>
          <target state="translated">高注册班12元至14元,20元至31元。</target>
        </trans-unit>
        <trans-unit id="3cb15a163b8ebe83004d3a7496bed1214d5c34ea" translate="yes" xml:space="preserve">
          <source>HK</source>
          <target state="translated">HK</target>
        </trans-unit>
        <trans-unit id="f187928fdb223e7f3b7b0396e72e2d59a5f12b29" translate="yes" xml:space="preserve">
          <source>HR</source>
          <target state="translated">HR</target>
        </trans-unit>
        <trans-unit id="85df07a121977d0d0044781e9eeed44012e5da35" translate="yes" xml:space="preserve">
          <source>Half-Precision Floating Point.</source>
          <target state="translated">半精度浮点运算。</target>
        </trans-unit>
        <trans-unit id="98b9b2da1252ae05155633eda47b6a7d5cf72927" translate="yes" xml:space="preserve">
          <source>Halt. The processor stops execution. This built-in is useful for implementing assertions.</source>
          <target state="translated">Halt.处理器停止执行。这个内置对于实现断言很有用。</target>
        </trans-unit>
        <trans-unit id="04a52ed9fb0a2eefbc17a28c7b4e166c12cd47d4" translate="yes" xml:space="preserve">
          <source>Hardware autoprefetcher scheduler model control flag. Number of lookahead cycles the model looks into; at &amp;rsquo; &amp;rsquo; only enable instruction sorting heuristic.</source>
          <target state="translated">硬件自动预取程序调度程序模型控制标志。模型研究的超前循环次数；在&amp;ldquo;&amp;rdquo;仅启用指令排序启发式。</target>
        </trans-unit>
        <trans-unit id="073339b2e7c4ff717e46d7be967106262132c9d4" translate="yes" xml:space="preserve">
          <source>Hardware multiplies are normally performed by calling a library routine. This saves space in the generated code. When compiling at</source>
          <target state="translated">硬件乘法通常是通过调用一个库例程来执行的。这样可以节省生成代码的空间。当以</target>
        </trans-unit>
        <trans-unit id="f483db45c59b64e904de79b67a44935e8bf546fe" translate="yes" xml:space="preserve">
          <source>Have &lt;code&gt;operator=&lt;/code&gt; return a reference to &lt;code&gt;*this&lt;/code&gt;.</source>
          <target state="translated">让 &lt;code&gt;operator=&lt;/code&gt; 返回对 &lt;code&gt;*this&lt;/code&gt; 的引用。</target>
        </trans-unit>
        <trans-unit id="520de7443d00d6ff4dc3ababbbf6cfbe0b74f4ec" translate="yes" xml:space="preserve">
          <source>Headers</source>
          <target state="translated">Headers</target>
        </trans-unit>
        <trans-unit id="42b05fc1afa3da7a89484cda5a6cb36dbe6e8a78" translate="yes" xml:space="preserve">
          <source>Hence, it is assumed as a convention that &lt;code&gt;r*&lt;/code&gt; means &lt;code&gt;const
char *&lt;/code&gt; (since it is what is most often meant), and there is no way to encode &lt;code&gt;char *const&lt;/code&gt;. &lt;code&gt;char *const&lt;/code&gt; would simply be encoded as &lt;code&gt;*&lt;/code&gt;, and the &lt;code&gt;const&lt;/code&gt; is lost.</source>
          <target state="translated">因此，假设惯例是 &lt;code&gt;r*&lt;/code&gt; 表示 &lt;code&gt;const char *&lt;/code&gt; （因为这是最常用的意思），并且无法对 &lt;code&gt;char *const&lt;/code&gt; 进行编码。 &lt;code&gt;char *const&lt;/code&gt; 将被简单地编码为 &lt;code&gt;*&lt;/code&gt; ，而 &lt;code&gt;const&lt;/code&gt; 将丢失。</target>
        </trans-unit>
        <trans-unit id="c6ff03b9e0183ccfd153d29e4ebb71b3afc43687" translate="yes" xml:space="preserve">
          <source>Here &amp;lsquo;</source>
          <target state="translated">这里 '</target>
        </trans-unit>
        <trans-unit id="63fa474126b5fb0e84bc0e1276f71b4f5949c4a7" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;a&lt;/code&gt; may or may not be restored to its first value when the &lt;code&gt;longjmp&lt;/code&gt; occurs. If &lt;code&gt;a&lt;/code&gt; is allocated in a register, then its first value is restored; otherwise, it keeps the last value stored in it.</source>
          <target state="translated">当 &lt;code&gt;longjmp&lt;/code&gt; 发生时，此处 &lt;code&gt;a&lt;/code&gt; 可能会或可能不会恢复为其第一个值。如果将 &lt;code&gt;a&lt;/code&gt; 分配到寄存器中，则将恢复其第一个值；否则，它将最后一个值存储在其中。</target>
        </trans-unit>
        <trans-unit id="6c22abcd7bcbe4b705f9506a92dff2b4514bc0a5" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;r12&lt;/code&gt; is the name of the register that should be used. Note that this is the same syntax used for defining global register variables, but for a local variable the declaration appears within a function. The &lt;code&gt;register&lt;/code&gt; keyword is required, and cannot be combined with &lt;code&gt;static&lt;/code&gt;. The register name must be a valid register name for the target platform.</source>
          <target state="translated">这里 &lt;code&gt;r12&lt;/code&gt; 是要使用的寄存器名。请注意，这与用于定义全局寄存器变量的语法相同，但是对于局部变量，声明出现在函数内。该 &lt;code&gt;register&lt;/code&gt; 关键字是必需的，并且不能与结合 &lt;code&gt;static&lt;/code&gt; 。寄存器名称必须是目标平台的有效寄存器名称。</target>
        </trans-unit>
        <trans-unit id="e629674ac2ffa8c8e6f920770dda44cae02f866e" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;r12&lt;/code&gt; is the name of the register that should be used. Note that this is the same syntax used for defining local register variables, but for a global variable the declaration appears outside a function. The &lt;code&gt;register&lt;/code&gt; keyword is required, and cannot be combined with &lt;code&gt;static&lt;/code&gt;. The register name must be a valid register name for the target platform.</source>
          <target state="translated">这里 &lt;code&gt;r12&lt;/code&gt; 是要使用的寄存器名。请注意，这与用于定义本地寄存器变量的语法相同，但是对于全局变量，声明显示在函数外部。该 &lt;code&gt;register&lt;/code&gt; 关键字是必需的，并且不能与结合 &lt;code&gt;static&lt;/code&gt; 。寄存器名称必须是目标平台的有效寄存器名称。</target>
        </trans-unit>
        <trans-unit id="1bd41698f09a234c8d3f5259448a5e29c338b76f" translate="yes" xml:space="preserve">
          <source>Here are constraint modifier characters.</source>
          <target state="translated">这里是约束修饰符。</target>
        </trans-unit>
        <trans-unit id="13c7c696c96d9253d198dc3e9c528b8ff4863b3b" translate="yes" xml:space="preserve">
          <source>Here are some examples showing uses of these options.</source>
          <target state="translated">下面是一些使用这些选项的例子。</target>
        </trans-unit>
        <trans-unit id="a2f0dcf3cf944a4192020c4b10f40e42e5e117ae" translate="yes" xml:space="preserve">
          <source>Here are some more examples of output operands.</source>
          <target state="translated">这里还有一些输出操作数的例子。</target>
        </trans-unit>
        <trans-unit id="25efdeb982b817cc2032012465d473ceaf58d073" translate="yes" xml:space="preserve">
          <source>Here are some types and their encodings, as they are generated by the compiler on an i386 machine:</source>
          <target state="translated">下面是一些类型和它们的编码,因为它们是由i386机器上的编译器生成的。</target>
        </trans-unit>
        <trans-unit id="807544d18135eba132f45e4832519a518a98b736" translate="yes" xml:space="preserve">
          <source>Here are specific details on what constraint letters you can use with &lt;code&gt;asm&lt;/code&gt; operands. Constraints can say whether an operand may be in a register, and which kinds of register; whether the operand can be a memory reference, and which kinds of address; whether the operand may be an immediate constant, and which possible values it may have. Constraints can also require two operands to match. Side-effects aren&amp;rsquo;t allowed in operands of inline &lt;code&gt;asm&lt;/code&gt;, unless &amp;lsquo;</source>
          <target state="translated">以下是有关可与 &lt;code&gt;asm&lt;/code&gt; 操作数一起使用的约束字母的特定详细信息。约束可以说明操作数是否可以在寄存器中，以及哪种寄存器；操作数是否可以是内存引用，以及哪种地址；操作数是否可以是立即数，以及它可能具有哪些值。约束也可能需要两个操作数匹配。内联 &lt;code&gt;asm&lt;/code&gt; 的操作数中不允许有副作用，除非&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="8169e79c24e48ad827616f09316f377a5693db58" translate="yes" xml:space="preserve">
          <source>Here is a fictitious &lt;code&gt;*z++ = *x++ * *y++&lt;/code&gt; instruction. Notice that the &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt; and &lt;code&gt;z&lt;/code&gt; pointer registers must be specified as input/output because the &lt;code&gt;asm&lt;/code&gt; modifies them.</source>
          <target state="translated">这是一个虚拟的 &lt;code&gt;*z++ = *x++ * *y++&lt;/code&gt; 指令。请注意，必须将 &lt;code&gt;x&lt;/code&gt; ， &lt;code&gt;y&lt;/code&gt; 和 &lt;code&gt;z&lt;/code&gt; 指针寄存器指定为输入/输出，因为 &lt;code&gt;asm&lt;/code&gt; 会对其进行修改。</target>
        </trans-unit>
        <trans-unit id="b840ee95bd53e4b94e99eb87178d11fd9afdba38" translate="yes" xml:space="preserve">
          <source>Here is a fictitious sum of squares instruction, that takes two pointers to floating point values in memory and produces a floating point register output. Notice that &lt;code&gt;x&lt;/code&gt;, and &lt;code&gt;y&lt;/code&gt; both appear twice in the &lt;code&gt;asm&lt;/code&gt; parameters, once to specify memory accessed, and once to specify a base register used by the &lt;code&gt;asm&lt;/code&gt;. You won&amp;rsquo;t normally be wasting a register by doing this as GCC can use the same register for both purposes. However, it would be foolish to use both &lt;code&gt;%1&lt;/code&gt; and &lt;code&gt;%3&lt;/code&gt; for &lt;code&gt;x&lt;/code&gt; in this &lt;code&gt;asm&lt;/code&gt; and expect them to be the same. In fact, &lt;code&gt;%3&lt;/code&gt; may well not be a register. It might be a symbolic memory reference to the object pointed to by &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">这是一个虚拟的平方和指令，它使用两个指针指向内存中的浮点值，并产生一个浮点寄存器输出。请注意， &lt;code&gt;x&lt;/code&gt; 和 &lt;code&gt;y&lt;/code&gt; 都在 &lt;code&gt;asm&lt;/code&gt; 参数中出现两次，一次是指定要访问的内存，一次是指定 &lt;code&gt;asm&lt;/code&gt; 使用的基址寄存器。通常，您这样做不会浪费寄存器，因为GCC可以将相同的寄存器用于这两个目的。但是，在此 &lt;code&gt;asm&lt;/code&gt; 中为 &lt;code&gt;x&lt;/code&gt; 使用 &lt;code&gt;%1&lt;/code&gt; 和 &lt;code&gt;%3&lt;/code&gt; 都是愚蠢的，并期望它们相同。实际上， &lt;code&gt;%3&lt;/code&gt; 可能不是寄存器。它可能是对 &lt;code&gt;x&lt;/code&gt; 指向的对象的符号内存引用。</target>
        </trans-unit>
        <trans-unit id="989c5915dce017df7249cda1058c0a0b75ec727b" translate="yes" xml:space="preserve">
          <source>Here is a fully worked-out example using a Foundation library (which provides the implementation of &lt;code&gt;NSArray&lt;/code&gt;, &lt;code&gt;NSString&lt;/code&gt; and &lt;code&gt;NSLog&lt;/code&gt;):</source>
          <target state="translated">这是一个使用Foundation库的完全解决的示例（提供了 &lt;code&gt;NSArray&lt;/code&gt; ， &lt;code&gt;NSString&lt;/code&gt; 和 &lt;code&gt;NSLog&lt;/code&gt; 的实现）：</target>
        </trans-unit>
        <trans-unit id="0837d871cde10d5f686c43af16d467ea239dcffc" translate="yes" xml:space="preserve">
          <source>Here is a list of each supported architecture and their supported implementations.</source>
          <target state="translated">下面是每个支持的架构及其支持的实现的列表。</target>
        </trans-unit>
        <trans-unit id="6bbe295750387ad466f92bad763fdcf85832b55b" translate="yes" xml:space="preserve">
          <source>Here is a list of options that are &lt;em&gt;only&lt;/em&gt; for compiling C++ programs:</source>
          <target state="translated">以下是&lt;em&gt;仅&lt;/em&gt;用于编译C ++程序的选项列表：</target>
        </trans-unit>
        <trans-unit id="9c6de7709b9bd71702ea864b6b84c7a93a1c5dfe" translate="yes" xml:space="preserve">
          <source>Here is a list of options that are &lt;em&gt;only&lt;/em&gt; for compiling Objective-C and Objective-C++ programs:</source>
          <target state="translated">这是&lt;em&gt;仅&lt;/em&gt;用于编译Objective-C和Objective-C ++程序的选项列表：</target>
        </trans-unit>
        <trans-unit id="3d287577ba4a1613932b539025d50b64c148479a" translate="yes" xml:space="preserve">
          <source>Here is a more technical description with the gory details. Consider the code</source>
          <target state="translated">下面是一个比较技术性的描述,有血淋淋的细节。请看下面的代码</target>
        </trans-unit>
        <trans-unit id="1f5c95b6edb6a49dd54cd8ace0a3af7f6b8efa6e" translate="yes" xml:space="preserve">
          <source>Here is a realistic example for the VAX showing the use of clobbered registers:</source>
          <target state="translated">下面是VAX的一个实际例子,展示了clobbered寄存器的使用。</target>
        </trans-unit>
        <trans-unit id="fab100c4848d525a51e3c94ffe939c5c90d217c1" translate="yes" xml:space="preserve">
          <source>Here is a small example of a spec file:</source>
          <target state="translated">下面是一个规范文件的小例子。</target>
        </trans-unit>
        <trans-unit id="fd38f38bfeb097a932215690af5b2bcebdd18296" translate="yes" xml:space="preserve">
          <source>Here is a summary of all the options, grouped by type. Explanations are in the following sections.</source>
          <target state="translated">以下是所有选项的摘要,按类型分类。以下各节将对其进行解释。</target>
        </trans-unit>
        <trans-unit id="776e1d0b1f7cf817731495ac8a0bb9e5528c2c48" translate="yes" xml:space="preserve">
          <source>Here is a table of all defined &amp;lsquo;</source>
          <target state="translated">这是所有已定义的&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="72ec126b11c4f7e2b3f6db181072684dbe3a798e" translate="yes" xml:space="preserve">
          <source>Here is a truncated example from the ARM port of &lt;code&gt;gcc&lt;/code&gt;:</source>
          <target state="translated">这是 &lt;code&gt;gcc&lt;/code&gt; 的ARM端口的截断示例：</target>
        </trans-unit>
        <trans-unit id="816eebea82d67ac72ae8e305241f89073b0b966e" translate="yes" xml:space="preserve">
          <source>Here is an example of &lt;code&gt;asm goto&lt;/code&gt; for i386:</source>
          <target state="translated">这是i386 的 &lt;code&gt;asm goto&lt;/code&gt; 示例：</target>
        </trans-unit>
        <trans-unit id="ddf77123eb0a199270833915774797e456c51dd3" translate="yes" xml:space="preserve">
          <source>Here is an example of a PowerPC vector scale implemented in assembly, complete with vector and condition code clobbers, and some initialized offset registers that are unchanged by the &lt;code&gt;asm&lt;/code&gt;.</source>
          <target state="translated">这是一个以汇编形式实现的PowerPC矢量比例的示例，其中包括矢量和条件代码修饰符，以及一些经 &lt;code&gt;asm&lt;/code&gt; 不变的初始化偏移寄存器。</target>
        </trans-unit>
        <trans-unit id="874ef7a4fb34e57091c1bf1216dfbb76680c0a4d" translate="yes" xml:space="preserve">
          <source>Here is an example of basic &lt;code&gt;asm&lt;/code&gt; for i386:</source>
          <target state="translated">这是i386 的基本 &lt;code&gt;asm&lt;/code&gt; 示例：</target>
        </trans-unit>
        <trans-unit id="578c29000b6f8a220ff3bd98b1f6dac59cfc8f4c" translate="yes" xml:space="preserve">
          <source>Here is an example of constructing a &lt;code&gt;struct foo&lt;/code&gt; with a compound literal:</source>
          <target state="translated">这是使用复合文字构造 &lt;code&gt;struct foo&lt;/code&gt; 的示例：</target>
        </trans-unit>
        <trans-unit id="b487a854c417efabdfc0cd516c584d94dc1d4a11" translate="yes" xml:space="preserve">
          <source>Here is an example of how to use this feature. Suppose you want to implement a class whose instances hold a weak pointer reference; the following class does this:</source>
          <target state="translated">下面是一个如何使用这个特性的例子。假设你想实现一个实例持有弱指针引用的类,下面的类就能实现这个功能。</target>
        </trans-unit>
        <trans-unit id="ab5b5e88b81c892525543bbf2b441bfb5667f5c0" translate="yes" xml:space="preserve">
          <source>Here is an example showing handling for &lt;code&gt;_XABORT_RETRY&lt;/code&gt; and a fallback path for other failures:</source>
          <target state="translated">这是一个显示 &lt;code&gt;_XABORT_RETRY&lt;/code&gt; 的处理以及其他失败的后备路径的示例：</target>
        </trans-unit>
        <trans-unit id="156d8468259daa1a9f530dd9ec7054117c896faf" translate="yes" xml:space="preserve">
          <source>Here is an example using symbolic names.</source>
          <target state="translated">下面是一个使用符号名称的例子。</target>
        </trans-unit>
        <trans-unit id="aa58661567f951b6e91b047e11c73d9fb7a1db05" translate="yes" xml:space="preserve">
          <source>Here is an example with a typename as the argument:</source>
          <target state="translated">下面是一个以类型名为参数的例子。</target>
        </trans-unit>
        <trans-unit id="540ee2aaf7182c6dfc449b18e5accb694e3b0894" translate="yes" xml:space="preserve">
          <source>Here is an example:</source>
          <target state="translated">下面是一个例子。</target>
        </trans-unit>
        <trans-unit id="26a60c8be4c01c6ccc45bd8984830035c8dc1a26" translate="yes" xml:space="preserve">
          <source>Here the two output filenames</source>
          <target state="translated">这里有两个输出文件名</target>
        </trans-unit>
        <trans-unit id="00b4a6c83965e727380186cb35a7faefe39e2601" translate="yes" xml:space="preserve">
          <source>Here the type described is that of pointers to &lt;code&gt;int&lt;/code&gt;.</source>
          <target state="translated">这里描述的类型是指向 &lt;code&gt;int&lt;/code&gt; 的指针的类型。</target>
        </trans-unit>
        <trans-unit id="df28516bc4139f3f069071685fe09b0059baa73c" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;d&lt;/code&gt; may either be in a register or in memory. Since the compiler might already have the current value of the &lt;code&gt;uint32_t&lt;/code&gt; location pointed to by &lt;code&gt;e&lt;/code&gt; in a register, you can enable it to choose the best location for &lt;code&gt;d&lt;/code&gt; by specifying both constraints.</source>
          <target state="translated">此处， &lt;code&gt;d&lt;/code&gt; 可以在寄存器中或在内存中。由于编译器可能已经在寄存器中具有 &lt;code&gt;e&lt;/code&gt; 指向的 &lt;code&gt;uint32_t&lt;/code&gt; 位置的当前值，因此可以通过指定两个约束使编译器为 &lt;code&gt;d&lt;/code&gt; 选择最佳位置。</target>
        </trans-unit>
        <trans-unit id="d245b0ad9046b148b54dc212babce2d8a4b44886" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;t4&lt;/code&gt; takes up 4 bytes.</source>
          <target state="translated">在此， &lt;code&gt;t4&lt;/code&gt; 占用4个字节。</target>
        </trans-unit>
        <trans-unit id="46a3f0b1a7f9b9f0c9d86a3230e304304bee1bda" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;t5&lt;/code&gt; takes up 2 bytes.</source>
          <target state="translated">在此， &lt;code&gt;t5&lt;/code&gt; 占用2个字节。</target>
        </trans-unit>
        <trans-unit id="f9dddf42b68435ab0aa7d4d6b86db289bd3db824" translate="yes" xml:space="preserve">
          <source>Here, the &lt;code&gt;std::move&lt;/code&gt; call is redundant. Because G++ implements Core Issue 1579, another example is:</source>
          <target state="translated">在这里， &lt;code&gt;std::move&lt;/code&gt; 调用是多余的。由于G ++实现了核心问题1579，因此另一个示例是：</target>
        </trans-unit>
        <trans-unit id="94a1520d218a1c0edb195732392c054a4dc1a61d" translate="yes" xml:space="preserve">
          <source>Here, the function &lt;code&gt;intermediate&lt;/code&gt; receives the address of &lt;code&gt;store&lt;/code&gt; as an argument. If &lt;code&gt;intermediate&lt;/code&gt; calls &lt;code&gt;store&lt;/code&gt;, the arguments given to &lt;code&gt;store&lt;/code&gt; are used to store into &lt;code&gt;array&lt;/code&gt;. But this technique works only so long as the containing function (&lt;code&gt;hack&lt;/code&gt;, in this example) does not exit.</source>
          <target state="translated">在此， &lt;code&gt;intermediate&lt;/code&gt; 函数将接收 &lt;code&gt;store&lt;/code&gt; 地址作为参数。如果是 &lt;code&gt;intermediate&lt;/code&gt; 调用 &lt;code&gt;store&lt;/code&gt; ，则给store的参数 &lt;code&gt;store&lt;/code&gt; 用于存储到 &lt;code&gt;array&lt;/code&gt; 中。但是，只有在不退出包含函数（在此示例中为 &lt;code&gt;hack&lt;/code&gt; )的情况下，此技术才有效。</target>
        </trans-unit>
        <trans-unit id="8e86d7a0668faeeae59dff730b5c0908c7e965fa" translate="yes" xml:space="preserve">
          <source>Here, the names &lt;code&gt;foo&lt;/code&gt; and &lt;code&gt;N&lt;/code&gt; appear in a context that does not depend on the type of &lt;code&gt;T&lt;/code&gt;. The compiler will thus require that they are defined in the context of use in the template, not only before the point of instantiation, and will here use &lt;code&gt;::foo(double)&lt;/code&gt; and &lt;code&gt;A::N&lt;/code&gt;, respectively. In particular, it will convert the integer value to a &lt;code&gt;double&lt;/code&gt; when passing it to &lt;code&gt;::foo(double)&lt;/code&gt;.</source>
          <target state="translated">在这里，名称 &lt;code&gt;foo&lt;/code&gt; 和 &lt;code&gt;N&lt;/code&gt; 出现在不依赖于 &lt;code&gt;T&lt;/code&gt; 类型的上下文中。因此，编译器会要求他们在使用的情况下，不仅之前实例化的点，将在这里使用已定义的模板 &lt;code&gt;::foo(double)&lt;/code&gt; 和 &lt;code&gt;A::N&lt;/code&gt; ，分别。特别是，当将其传递给 &lt;code&gt;::foo(double)&lt;/code&gt; 时，它将整数值转换为 &lt;code&gt;double&lt;/code&gt; 值。</target>
        </trans-unit>
        <trans-unit id="8a9da0e5c138e6d84a3e4a12f0c523bc1f369e0f" translate="yes" xml:space="preserve">
          <source>Hewlett-Packard PA-RISC&amp;mdash;</source>
          <target state="translated">惠普PA-RISC &amp;mdash;</target>
        </trans-unit>
        <trans-unit id="9e735341d337ae137df7758e8465bb4d998cc55a" translate="yes" xml:space="preserve">
          <source>Hexadecimal floating-point constants.</source>
          <target state="translated">十六进制浮点常数。</target>
        </trans-unit>
        <trans-unit id="26e165ccce457fee42636ec531aa349640cf4392" translate="yes" xml:space="preserve">
          <source>Hidden visibility indicates that the entity declared has a new form of linkage, which we call &amp;ldquo;hidden linkage&amp;rdquo;. Two declarations of an object with hidden linkage refer to the same object if they are in the same shared object.</source>
          <target state="translated">隐藏可见性表明所声明的实体具有新的链接形式，我们称为&amp;ldquo;隐藏链接&amp;rdquo;。如果具有隐藏链接的对象的两个声明位于同一共享对象中，则它们引用同一对象。</target>
        </trans-unit>
        <trans-unit id="29464505836db623029950c0312fcb03cbd85481" translate="yes" xml:space="preserve">
          <source>Historically, GCC has not deleted &amp;ldquo;empty&amp;rdquo; loops under the assumption that the most likely reason you would put one in a program is to have a delay, so deleting them will not make real programs run any faster.</source>
          <target state="translated">从历史上看，GCC并未删除&amp;ldquo;空&amp;rdquo;循环，但前提是您将一个空循环放入程序的最可能原因是延迟，因此删除它们不会使实际程序运行得更快。</target>
        </trans-unit>
        <trans-unit id="25855108b662a0e8c1ed703787f979b815d2d1a6" translate="yes" xml:space="preserve">
          <source>Historically, compilers for many languages, including C++ and Fortran, have been implemented as &amp;ldquo;preprocessors&amp;rdquo; which emit another high level language such as C. None of the compilers included in GCC are implemented this way; they all generate machine code directly. This sort of preprocessor should not be confused with the &lt;em&gt;C preprocessor&lt;/em&gt;, which is an integral feature of the C, C++, Objective-C and Objective-C++ languages.</source>
          <target state="translated">从历史上看，用于多种语言（包括C ++和Fortran）的编译器已实现为&amp;ldquo;预处理器&amp;rdquo;，发出了诸如C的另一种高级语言。它们都直接生成机器代码。此类预处理器不应与&lt;em&gt;C预处理器&lt;/em&gt;混淆，&lt;em&gt;C预处理器&lt;/em&gt;是C，C ++，Objective-C和Objective-C ++语言的不可或缺的功能。</target>
        </trans-unit>
        <trans-unit id="1df0e52c96207e60432f242eee2da9b8ff549d2b" translate="yes" xml:space="preserve">
          <source>How GCC calculates the size of an &lt;code&gt;asm&lt;/code&gt; block.</source>
          <target state="translated">GCC如何计算 &lt;code&gt;asm&lt;/code&gt; 块的大小。</target>
        </trans-unit>
        <trans-unit id="3f9040ed129a83c15932559ac6449ffd679075c3" translate="yes" xml:space="preserve">
          <source>How GCC implements the ISO C specification.</source>
          <target state="translated">GCC如何实现ISO C规范。</target>
        </trans-unit>
        <trans-unit id="f79f60bc97ae69f938083d6bd71809804c4831c5" translate="yes" xml:space="preserve">
          <source>How GCC implements the ISO C++ specification.</source>
          <target state="translated">GCC如何实现ISO C++规范。</target>
        </trans-unit>
        <trans-unit id="62fab6a3b6832fb352405ce63e5b735618b3cef7" translate="yes" xml:space="preserve">
          <source>How To Get Help with GCC</source>
          <target state="translated">如何获得GCC的帮助</target>
        </trans-unit>
        <trans-unit id="3e63c682de797883ae23802bc327411231cc31a8" translate="yes" xml:space="preserve">
          <source>How a diagnostic is identified (C90 3.7, C99 and C11 3.10, C90, C99 and C11 5.1.1.3).</source>
          <target state="translated">如何确定诊断(C90 3.7、C99和C11 3.10、C90、C99和C11 5.1.1.3);</target>
        </trans-unit>
        <trans-unit id="a123b2bec235da6dad3dc58f234c2574673ff822" translate="yes" xml:space="preserve">
          <source>How much optimization?</source>
          <target state="translated">优化多少?</target>
        </trans-unit>
        <trans-unit id="31524a9fb30368b64541b8aeb51e1826b2eb3b0a" translate="yes" xml:space="preserve">
          <source>How picky should the compiler be?</source>
          <target state="translated">编译器应该如何挑剔?</target>
        </trans-unit>
        <trans-unit id="1e2b472e6c532fe8af4932714956f74293f46083" translate="yes" xml:space="preserve">
          <source>How sequences in both forms of header names are mapped to headers or external source file names (C90 6.1.7, C99 and C11 6.4.7).</source>
          <target state="translated">如何将两种形式的头名中的序列映射到头名或外部源文件名上(C90 6.1.7、C99和C11 6.4.7);</target>
        </trans-unit>
        <trans-unit id="848f6ad2348dcee59d13596577066e141ef4d0ad" translate="yes" xml:space="preserve">
          <source>How the named source file is searched for in an included &amp;lsquo;</source>
          <target state="translated">如何在包含的&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="130378b21f742b32140465d74f388cb06f5001cf" translate="yes" xml:space="preserve">
          <source>How the nearest representable value or the larger or smaller representable value immediately adjacent to the nearest representable value is chosen for certain floating constants (C90 6.1.3.1, C99 and C11 6.4.4.2).</source>
          <target state="translated">对于某些浮动常数,如何选择最近的可表示值或紧邻最近可表示值的较大或较小的可表示值(C90 6.1.3.1,C99和C11 6.4.4.2)。</target>
        </trans-unit>
        <trans-unit id="606b9fa050c9f5a8165f3052560ba0c7d8b85fa0" translate="yes" xml:space="preserve">
          <source>How to contribute to testing and developing GCC.</source>
          <target state="translated">如何为测试和开发GCC做贡献。</target>
        </trans-unit>
        <trans-unit id="25170558e581aabef161dcb92e9a6de67ff5f448" translate="yes" xml:space="preserve">
          <source>How to help assure funding for free software.</source>
          <target state="translated">如何帮助保证免费软件的资金。</target>
        </trans-unit>
        <trans-unit id="488dee81569b2dc10244c6b537b50c3cc87269e1" translate="yes" xml:space="preserve">
          <source>How to pass switches to sub-processes.</source>
          <target state="translated">如何将开关传递给子进程。</target>
        </trans-unit>
        <trans-unit id="8c1e8efdd3392d7ad8138bb7223322e34b90c240" translate="yes" xml:space="preserve">
          <source>How to use gcov-dump.</source>
          <target state="translated">如何使用gcov-dump。</target>
        </trans-unit>
        <trans-unit id="f7d8be53e9f165a3a11bb6dadca7af891ced365f" translate="yes" xml:space="preserve">
          <source>How to use gcov-tool.</source>
          <target state="translated">如何使用gcov-tool。</target>
        </trans-unit>
        <trans-unit id="dde16118c9faa27675fdfe5cf0405564b55597c4" translate="yes" xml:space="preserve">
          <source>How to use gcov.</source>
          <target state="translated">如何使用gcov。</target>
        </trans-unit>
        <trans-unit id="235eb3fbbc41bc188e100c67a4cfb3682e2f4f2a" translate="yes" xml:space="preserve">
          <source>How to use lto-dump.</source>
          <target state="translated">如何使用lto-dump。</target>
        </trans-unit>
        <trans-unit id="4e461b3cc6748ec681eab8b558da86d4b08a95ab" translate="yes" xml:space="preserve">
          <source>How you can copy and share this manual.</source>
          <target state="translated">如何复制和分享本手册。</target>
        </trans-unit>
        <trans-unit id="9e8e4dbcb1b211f7b5ab31c6c59b3a79ec59dd4f" translate="yes" xml:space="preserve">
          <source>How, why and where to report bugs.</source>
          <target state="translated">如何、为什么以及在哪里报告错误。</target>
        </trans-unit>
        <trans-unit id="0e3275b465f023e98f74ae720920ad438e50264c" translate="yes" xml:space="preserve">
          <source>However, &lt;code&gt;(union foo) FLT_MAX;&lt;/code&gt; is not a valid cast because the union has no member of type &lt;code&gt;float&lt;/code&gt;.</source>
          <target state="translated">但是， &lt;code&gt;(union foo) FLT_MAX;&lt;/code&gt; 不是有效的类型转换，因为联合没有 &lt;code&gt;float&lt;/code&gt; 类型的成员。</target>
        </trans-unit>
        <trans-unit id="485c9587b5b19b4655aac341ac1212bc65c7e3c5" translate="yes" xml:space="preserve">
          <source>However, even with</source>
          <target state="translated">然而,即使有</target>
        </trans-unit>
        <trans-unit id="9ea71fd7ca0b24f50560578a479dbd93975ddc25" translate="yes" xml:space="preserve">
          <source>However, if a library or main executable is supposed to throw or catch exceptions, you must link it using the G++ driver, or using the option</source>
          <target state="translated">但是,如果一个库或主可执行文件应该抛出或捕获异常,你必须使用G++驱动或使用选项</target>
        </trans-unit>
        <trans-unit id="68ad5ea0590b2a354fce31707da021a7a4908783" translate="yes" xml:space="preserve">
          <source>However, if the volatile storage is not being modified, and the value of the volatile storage is not used, then the situation is less obvious. For example</source>
          <target state="translated">但是,如果不修改易失性存储,不使用易失性存储的值,那么情况就不那么明显了。比如说</target>
        </trans-unit>
        <trans-unit id="3955f23a3aaffbcd48d8f54a3969fb80a9687bcd" translate="yes" xml:space="preserve">
          <source>However, the rationale here is that optimization of a nonempty loop cannot produce an empty one. This held for carefully written C compiled with less powerful optimizers but is not always the case for carefully written C++ or with more powerful optimizers. Thus GCC will remove operations from loops whenever it can determine those operations are not externally visible (apart from the time taken to execute them, of course). In case the loop can be proved to be finite, GCC will also remove the loop itself.</source>
          <target state="translated">然而,这里的原理是,对一个非空循环的优化不能产生一个空循环。这对于用功能较弱的优化器精心编写的C编译来说是成立的,但对于精心编写的C++或功能较强的优化器来说就不一定了。因此,GCC只要能够确定这些操作在外部不可见,就会从循环中删除这些操作(当然,除了执行这些操作所花费的时间)。在可以证明循环是有限的情况下,GCC也会删除循环本身。</target>
        </trans-unit>
        <trans-unit id="9091ae1dd68a17c85dd2a3885c0a623d65f81f37" translate="yes" xml:space="preserve">
          <source>However, the use of &lt;code&gt;gcc&lt;/code&gt; does not add the C++ library. &lt;code&gt;g++&lt;/code&gt; is a program that calls GCC and automatically specifies linking against the C++ library. It treats &amp;lsquo;</source>
          <target state="translated">但是，使用 &lt;code&gt;gcc&lt;/code&gt; 不会添加C ++库。 &lt;code&gt;g++&lt;/code&gt; 是一个调用GCC并自动指定针对C ++库的链接的程序。它对待</target>
        </trans-unit>
        <trans-unit id="25970c1ebc6bb12a4ef702c744afb1bf31667e71" translate="yes" xml:space="preserve">
          <source>However, these built-in functions may interact badly with some sophisticated features or other extensions of the language. It is, therefore, not recommended to use them outside very simple functions acting as mere forwarders for their arguments.</source>
          <target state="translated">然而,这些内置函数可能会与一些复杂的功能或语言的其他扩展产生不良互动。因此,不建议在非常简单的函数之外使用它们,而只是作为其参数的转发者。</target>
        </trans-unit>
        <trans-unit id="ca73ab65568cd125c2d27a22bbd9e863c10b675d" translate="yes" xml:space="preserve">
          <source>I</source>
          <target state="translated">I</target>
        </trans-unit>
        <trans-unit id="5035ba1d98ecd402c64867de896608b2100e61c1" translate="yes" xml:space="preserve">
          <source>I register</source>
          <target state="translated">我注册</target>
        </trans-unit>
        <trans-unit id="0d25569c1c1c38b68b7adac7a2691f92a581fc48" translate="yes" xml:space="preserve">
          <source>IBM 970 Server CPU (ie, Apple G5).</source>
          <target state="translated">IBM 970服务器CPU(即苹果G5)。</target>
        </trans-unit>
        <trans-unit id="7ff989fdaf3c65fbe049204ca8d2d3b298dcd55a" translate="yes" xml:space="preserve">
          <source>IBM A2 64-bit Embedded CPU</source>
          <target state="translated">IBM A2 64位嵌入式CPU</target>
        </trans-unit>
        <trans-unit id="3bd4304c8c79a3c3382925e10c0656323fb15790" translate="yes" xml:space="preserve">
          <source>IBM POWER10 Server CPU.</source>
          <target state="translated">IBM POWER10服务器CPU。</target>
        </trans-unit>
        <trans-unit id="7ebf129d97228e5e38b88ee3a2bf7cb0f28dd1fe" translate="yes" xml:space="preserve">
          <source>IBM POWER4 Server CPU.</source>
          <target state="translated">IBM POWER4服务器CPU。</target>
        </trans-unit>
        <trans-unit id="60fedee6d379816b90140e69a6cb94f8d8a8d0f3" translate="yes" xml:space="preserve">
          <source>IBM POWER5 Server CPU.</source>
          <target state="translated">IBM POWER5服务器CPU。</target>
        </trans-unit>
        <trans-unit id="d3878c6f9c9f4047fa51bbea5fff4ce5c35e5af1" translate="yes" xml:space="preserve">
          <source>IBM POWER5+ Server CPU.</source>
          <target state="translated">IBM POWER5+服务器CPU。</target>
        </trans-unit>
        <trans-unit id="738e9fd792342dee79476051b27ac20d78ee9cda" translate="yes" xml:space="preserve">
          <source>IBM POWER6 Server CPU (Architected mode).</source>
          <target state="translated">IBM POWER6服务器CPU(架构模式)。</target>
        </trans-unit>
        <trans-unit id="a1d93b9cb2926fb05ec1f665abf51961f777a207" translate="yes" xml:space="preserve">
          <source>IBM POWER6 Server CPU (RAW mode).</source>
          <target state="translated">IBM POWER6服务器CPU(RAW模式)。</target>
        </trans-unit>
        <trans-unit id="dbb9a20762f1a0c1106412992e6cc65c84bffc0f" translate="yes" xml:space="preserve">
          <source>IBM POWER7 Server CPU.</source>
          <target state="translated">IBM POWER7服务器CPU。</target>
        </trans-unit>
        <trans-unit id="a9a9c9a90077a9f8cbd67dc15b93836e1c987d49" translate="yes" xml:space="preserve">
          <source>IBM POWER8 Server CPU.</source>
          <target state="translated">IBM POWER8服务器CPU。</target>
        </trans-unit>
        <trans-unit id="c65507ef531be00847ba2a33296dc99803a18664" translate="yes" xml:space="preserve">
          <source>IBM POWER9 Server CPU.</source>
          <target state="translated">IBM POWER9服务器CPU。</target>
        </trans-unit>
        <trans-unit id="5ad8015703e3cb16c9df6da3a8d9e97de8f9cd44" translate="yes" xml:space="preserve">
          <source>IBM PowerPC 464 32-bit Embedded CPU.</source>
          <target state="translated">IBM PowerPC 464 32位嵌入式CPU。</target>
        </trans-unit>
        <trans-unit id="a548cb73c6f0d35ac7d906f9a02a9350c2eb6114" translate="yes" xml:space="preserve">
          <source>IBM PowerPC 476FP 32-bit Embedded CPU.</source>
          <target state="translated">IBM PowerPC 476FP 32位嵌入式CPU。</target>
        </trans-unit>
        <trans-unit id="f3afdcbb4bda95413d989775a1a1f73e05c37f36" translate="yes" xml:space="preserve">
          <source>IBM PowerPC Cell Broadband Engine Architecture CPU.</source>
          <target state="translated">IBM PowerPC小区宽带引擎架构CPU。</target>
        </trans-unit>
        <trans-unit id="981e760991adb048080be646b9e1438966c192d0" translate="yes" xml:space="preserve">
          <source>IDT WinChip 2 CPU, dealt in same way as i486 with additional MMX and 3DNow! instruction set support.</source>
          <target state="translated">IDT WinChip 2 CPU,处理方式与i486相同,额外支持MMX和3DNow!指令集。</target>
        </trans-unit>
        <trans-unit id="e642e2d5acc8e35a06fd449f3d95c2b4f1486f5e" translate="yes" xml:space="preserve">
          <source>IDT WinChip C6 CPU, dealt in same way as i486 with additional MMX instruction set support.</source>
          <target state="translated">IDT WinChip C6 CPU,处理方式与i486相同,但增加了MMX指令集支持。</target>
        </trans-unit>
        <trans-unit id="ec8566180afc9d36e3493dbd47d7e2d1e9ae9485" translate="yes" xml:space="preserve">
          <source>IPA-CP attempts to track all possible values and types passed to a function&amp;rsquo;s parameter in order to propagate them and perform devirtualization.</source>
          <target state="translated">IPA-CP尝试跟踪传递给函数参数的所有可能的值和类型，以传播它们并执行虚拟化。</target>
        </trans-unit>
        <trans-unit id="f55eb535889fe2d3f53ef9f4b4a57453862d05ea" translate="yes" xml:space="preserve">
          <source>IPA-CP calculates its own score of cloning profitability heuristics and performs those cloning opportunities with scores that exceed</source>
          <target state="translated">IPA-CP计算自己的克隆盈利启发式得分,并执行那些得分超过的克隆机会</target>
        </trans-unit>
        <trans-unit id="18432c18c0adba44c26c2a586731fb98a9d6d897" translate="yes" xml:space="preserve">
          <source>IPA-CP is also capable to propagate a number of scalar values passed in an aggregate.</source>
          <target state="translated">IPA-CP也能够传播一些集合中传递的标量值。</target>
        </trans-unit>
        <trans-unit id="8556958b5ec1035f0a6b05619f3cd2d467506614" translate="yes" xml:space="preserve">
          <source>IPA-CP will analyze conditional statement that references some function parameter to estimate benefit for cloning upon certain constant value. But if number of operations in a parameter expression exceeds</source>
          <target state="translated">IPA-CP会对引用某个函数参数的条件语句进行分析,根据某个常量值来估计克隆的收益。但如果参数表达式中的操作次数超过了</target>
        </trans-unit>
        <trans-unit id="6522b0ebe1c355ebd160511e9d28107d63eb735d" translate="yes" xml:space="preserve">
          <source>IPA-SRA replaces a pointer to an aggregate with one or more new parameters only when their cumulative size is less or equal to</source>
          <target state="translated">IPA-SRA只有当一个或多个新参数的累积大小小于或等于</target>
        </trans-unit>
        <trans-unit id="b5db770cbd54ca7a4734eeb3ccbfba61d7f93149" translate="yes" xml:space="preserve">
          <source>IRA can be used to evaluate more accurate register pressure in loops for decisions to move loop invariants (see</source>
          <target state="translated">IRA可以用来评估环路中更精确的寄存器压力,以决定移动环路不变量(见图3)。</target>
        </trans-unit>
        <trans-unit id="3c1b099cab9d31b532499457a148771feb1ef850" translate="yes" xml:space="preserve">
          <source>IRA uses regional register allocation by default. If a function contains more loops than the number given by this parameter, only at most the given number of the most frequently-executed loops form regions for regional register allocation.</source>
          <target state="translated">IRA默认使用区域寄存器分配。如果一个函数包含的循环数量超过了这个参数所给的数量,那么最多只有给定数量的最频繁执行的循环才会形成区域寄存器分配的区域。</target>
        </trans-unit>
        <trans-unit id="e1a35fb9a6e6329c3bd0cf9dd057013f4b706fa3" translate="yes" xml:space="preserve">
          <source>ISA 3.0 of the PowerPC added new atomic memory operation (amo) instructions. GCC provides support for these instructions in 64-bit environments. All of the functions are declared in the include file &lt;code&gt;amo.h&lt;/code&gt;.</source>
          <target state="translated">PowerPC的ISA 3.0添加了新的原子存储操作（amo）指令。GCC在64位环境中为这些指令提供支持。所有功能都在包含文件 &lt;code&gt;amo.h&lt;/code&gt; 中声明。</target>
        </trans-unit>
        <trans-unit id="5e4fcacd5131358ff23946df8c2180ba0733f8f2" translate="yes" xml:space="preserve">
          <source>ISA 3.1 of the PowerPC added new Matrix-Multiply Assist (MMA) instructions. GCC provides support for these instructions through the following built-in functions which are enabled with the &lt;code&gt;-mmma&lt;/code&gt; option. The vec_t type below is defined to be a normal vector unsigned char type.&amp;Acirc; The uint2, uint4 and uint8 parameters are 2-bit, 4-bit and 8-bit unsigned integer constants respectively.&amp;Acirc; The compiler will verify that they are constants and that their values are within range.&amp;Acirc;</source>
          <target state="translated">PowerPC的ISA 3.1添加了新的矩阵乘法辅助（MMA）指令。GCC通过以下内置功能为这些指令提供支持，这些内置功能通过 &lt;code&gt;-mmma&lt;/code&gt; 选项启用。下面的vec_t类型定义为普通向量无符号char类型。uint2，uint4和uint8参数分别是2位，4位和8位无符号整数常量。它们的值在范围内。</target>
        </trans-unit>
        <trans-unit id="7cc00c6a2a5486718b4fd3642b097add2ed40af8" translate="yes" xml:space="preserve">
          <source>ISO C does not permit such a construct.</source>
          <target state="translated">ISO C不允许这种结构。</target>
        </trans-unit>
        <trans-unit id="fff460d30b4f47f8adc19f1a9e29c9166acd036b" translate="yes" xml:space="preserve">
          <source>ISO C requires a &amp;ldquo;diagnostic&amp;rdquo; message for certain kinds of invalid programs, but a warning is defined by GCC to count as a diagnostic. If GCC produces a warning but not an error, that is correct ISO C support. If testsuites call this &amp;ldquo;failure&amp;rdquo;, they should be run with the GCC option</source>
          <target state="translated">ISO C要求对某些种类的无效程序发出&amp;ldquo;诊断&amp;rdquo;消息，但是GCC定义了警告以算作诊断。如果GCC发出警告而不是错误，则说明ISO C是正确的支持。如果测试人员称此为&amp;ldquo;失败&amp;rdquo;，则应使用GCC选项运行它们</target>
        </trans-unit>
        <trans-unit id="50648f88649c1f5dd7bf2cb4554ff39825b6b2bb" translate="yes" xml:space="preserve">
          <source>ISO C11, the 2011 revision of the ISO C standard. This standard is substantially completely supported, modulo bugs, floating-point issues (mainly but not entirely relating to optional C11 features from Annexes F and G) and the optional Annexes K (Bounds-checking interfaces) and L (Analyzability). The name &amp;lsquo;</source>
          <target state="translated">ISO C11，ISO C标准的2011年修订版。基本上完全支持此标准，模错误，浮点问题（主要但不完全与附件F和G中的可选C11功能有关）以及可选附件K（边界检查接口）和L（可分析性）。名字 '</target>
        </trans-unit>
        <trans-unit id="a94be837facd76378c47084c4afa22ac2ddb78d6" translate="yes" xml:space="preserve">
          <source>ISO C17, the 2017 revision of the ISO C standard (published in 2018). This standard is same as C11 except for corrections of defects (all of which are also applied with</source>
          <target state="translated">ISO C17,是ISO C标准的2017年修订版(2018年发布)。该标准除缺陷的纠正外,其他与C11相同(均与</target>
        </trans-unit>
        <trans-unit id="835b0fe47c2b2521e64ab3b466f790da05e1cf2c" translate="yes" xml:space="preserve">
          <source>ISO C90 as modified in amendment 1.</source>
          <target state="translated">经第1修正案修改的ISO C90。</target>
        </trans-unit>
        <trans-unit id="dd3ae16769f5e30cd0e25b181c241be07701badf" translate="yes" xml:space="preserve">
          <source>ISO C99 and ISO C++ allow declarations and code to be freely mixed within compound statements. As an extension, GNU C also allows this in C90 mode. For example, you could do:</source>
          <target state="translated">ISO C99和ISO C++允许声明和代码在复合语句中自由混合。作为扩展,GNU C也允许在C90模式下这样做。例如,你可以这样做。</target>
        </trans-unit>
        <trans-unit id="fd9df382c7a9e275bf54293954eb3cea3a9394da" translate="yes" xml:space="preserve">
          <source>ISO C99 and ISO C++11 support data types for integers that are at least 64 bits wide, and as an extension GCC supports them in C90 and C++98 modes. Simply write &lt;code&gt;long long int&lt;/code&gt; for a signed integer, or &lt;code&gt;unsigned long long int&lt;/code&gt; for an unsigned integer. To make an integer constant of type &lt;code&gt;long long int&lt;/code&gt;, add the suffix &amp;lsquo;</source>
          <target state="translated">ISO C99和ISO C ++ 11支持至少64位宽的整数的数据类型，并且作为扩展，GCC在C90和C ++ 98模式下支持它们。只需为有符号整数写 &lt;code&gt;long long int&lt;/code&gt; 或为无符号整数写 &lt;code&gt;unsigned long long int&lt;/code&gt; 。要使 &lt;code&gt;long long int&lt;/code&gt; 类型的整数常量，请添加后缀'</target>
        </trans-unit>
        <trans-unit id="8b83453de486a892e712e76d4673bb12ab84c153" translate="yes" xml:space="preserve">
          <source>ISO C99 and ISO C++17 support floating-point numbers written not only in the usual decimal notation, such as &lt;code&gt;1.55e1&lt;/code&gt;, but also numbers such as &lt;code&gt;0x1.fp3&lt;/code&gt; written in hexadecimal format. As a GNU extension, GCC supports this in C90 mode (except in some cases when strictly conforming) and in C++98, C++11 and C++14 modes. In that format the &amp;lsquo;</source>
          <target state="translated">ISO C99和ISO C ++ 17不但支持以十进制表示的 &lt;code&gt;1.55e1&lt;/code&gt; （例如1.55e1），还 &lt;code&gt;0x1.fp3&lt;/code&gt; 以十六进制格式写的数字（例如0x1.fp3）。作为GNU扩展，GCC在C90模式（在某些情况下严格遵循要求时除外）以及C ++ 98，C ++ 11和C ++ 14模式都支持此功能。以这种格式，&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="f45bb32dfebc99db4671808e81b5e06e1a3ae3f3" translate="yes" xml:space="preserve">
          <source>ISO C99 supports complex floating data types, and as an extension GCC supports them in C90 mode and in C++. GCC also supports complex integer data types which are not part of ISO C99. You can declare complex types using the keyword &lt;code&gt;_Complex&lt;/code&gt;. As an extension, the older GNU keyword &lt;code&gt;__complex__&lt;/code&gt; is also supported.</source>
          <target state="translated">ISO C99支持复杂的浮动数据类型，作为扩展，GCC在C90模式和C ++中支持它们。GCC还支持不属于ISO C99的复杂整数数据类型。您可以使用关键字 &lt;code&gt;_Complex&lt;/code&gt; 声明复杂类型。作为扩展，还支持较旧的GNU关键字 &lt;code&gt;__complex__&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="84c793c819960394587c5cc12a67f14b20b38119" translate="yes" xml:space="preserve">
          <source>ISO C99. This standard is substantially completely supported, modulo bugs and floating-point issues (mainly but not entirely relating to optional C99 features from Annexes F and G). See &lt;a href=&quot;http://gcc.gnu.org/c99status.html&quot;&gt;http://gcc.gnu.org/c99status.html&lt;/a&gt; for more information. The names &amp;lsquo;</source>
          <target state="translated">ISO C99。基本上完全支持该标准，模错误和浮点问题（主要但不完全与附件F和G中的可选C99功能有关）。有关更多信息，请参见&lt;a href=&quot;http://gcc.gnu.org/c99status.html&quot;&gt;http://gcc.gnu.org/c99status.html&lt;/a&gt;。名字 '</target>
        </trans-unit>
        <trans-unit id="b19dfb0d72b128922f94144b3b4ef7616d4f13d5" translate="yes" xml:space="preserve">
          <source>ISO/IEC TS 18661-3 defines new permissible values for &lt;code&gt;FLT_EVAL_METHOD&lt;/code&gt; that indicate that operations and constants with a semantic type that is an interchange or extended format should be evaluated to the precision and range of that type. These new values are a superset of those permitted under C99/C11, which does not specify the meaning of other positive values of &lt;code&gt;FLT_EVAL_METHOD&lt;/code&gt;. As such, code conforming to C11 may not have been written expecting the possibility of the new values.</source>
          <target state="translated">ISO / IEC TS 18661-3定义了 &lt;code&gt;FLT_EVAL_METHOD&lt;/code&gt; 的新允许值，该值指示应将语义类型为互换或扩展格式的操作和常量评估为该类型的精度和范围。这些新值是C99 / C11所允许的值的超集，该值未指定 &lt;code&gt;FLT_EVAL_METHOD&lt;/code&gt; 的其他正值的含义。这样，可能尚未编写符合C11的代码，并期望有新值。</target>
        </trans-unit>
        <trans-unit id="0704127df0a170eee2b3d8c1f35e3e35e1e33e3c" translate="yes" xml:space="preserve">
          <source>ISO/IEC TS 18661-3:2015 defines C support for additional floating types &lt;code&gt;_Float&lt;var&gt;n&lt;/var&gt;&lt;/code&gt; and &lt;code&gt;_Float&lt;var&gt;n&lt;/var&gt;x&lt;/code&gt;, and GCC supports these type names; the set of types supported depends on the target architecture. These types are not supported when compiling C++. Constants with these types use suffixes &lt;code&gt;f&lt;var&gt;n&lt;/var&gt;&lt;/code&gt; or &lt;code&gt;F&lt;var&gt;n&lt;/var&gt;&lt;/code&gt; and &lt;code&gt;f&lt;var&gt;n&lt;/var&gt;x&lt;/code&gt; or &lt;code&gt;F&lt;var&gt;n&lt;/var&gt;x&lt;/code&gt;. These type names can be used together with &lt;code&gt;_Complex&lt;/code&gt; to declare complex types.</source>
          <target state="translated">ISO / IEC TS 18661-3：2015定义了对其他浮点类型 &lt;code&gt;_Float&lt;var&gt;n&lt;/var&gt;&lt;/code&gt; 和 &lt;code&gt;_Float&lt;var&gt;n&lt;/var&gt;x&lt;/code&gt; C支持，而GCC支持这些类型名。支持的类型集取决于目标体系结构。编译C ++时不支持这些类型。这些类型的常量使用后缀 &lt;code&gt;f&lt;var&gt;n&lt;/var&gt;&lt;/code&gt; 或 &lt;code&gt;F&lt;var&gt;n&lt;/var&gt;&lt;/code&gt; 以及 &lt;code&gt;f&lt;var&gt;n&lt;/var&gt;x&lt;/code&gt; 或 &lt;code&gt;F&lt;var&gt;n&lt;/var&gt;x&lt;/code&gt; 后缀。这些类型名称可以与 &lt;code&gt;_Complex&lt;/code&gt; 一起使用以声明复杂类型。</target>
        </trans-unit>
        <trans-unit id="beeb64c7eeaed20d36a340ce018bf60cf4a13bf4" translate="yes" xml:space="preserve">
          <source>Ideally, a portable program should always use &lt;code&gt;signed char&lt;/code&gt; or &lt;code&gt;unsigned char&lt;/code&gt; when it depends on the signedness of an object. But many programs have been written to use plain &lt;code&gt;char&lt;/code&gt; and expect it to be signed, or expect it to be unsigned, depending on the machines they were written for. This option, and its inverse, let you make such a program work with the opposite default.</source>
          <target state="translated">理想情况下，当可移植程序依赖于对象的 &lt;code&gt;unsigned char&lt;/code&gt; 时，应始终使用有 &lt;code&gt;signed char&lt;/code&gt; 或无符号字符。但是，已经编写了许多使用纯 &lt;code&gt;char&lt;/code&gt; 并希望它们可以被签名，或者期望它是未签名的，这取决于编写它们的机器。此选项及其相反的选项使您可以使用相反的默认值使此类程序正常工作。</target>
        </trans-unit>
        <trans-unit id="ab2f71fc75bf24fc42ea67b7b9de3bc2377f68da" translate="yes" xml:space="preserve">
          <source>Identical like the above one, but the location of the function in the &lt;code&gt;jli&lt;/code&gt; table is known and given as an attribute parameter.</source>
          <target state="translated">与上述方法相同，但是函数在 &lt;code&gt;jli&lt;/code&gt; 表中的位置是已知的，并作为属性参数给出。</target>
        </trans-unit>
        <trans-unit id="06758e7fffb077a661e9d5cfb54c15702892df80" translate="yes" xml:space="preserve">
          <source>Identifier conflicts with labels. Traditional C lacks a separate namespace for labels.</source>
          <target state="translated">标识符与标签冲突。传统C语言缺乏单独的标签命名空间。</target>
        </trans-unit>
        <trans-unit id="5a6386123e656c29d067b76006564d3382accf62" translate="yes" xml:space="preserve">
          <source>Identify the versions of each tool used by the compiler, in a &lt;code&gt;.ident&lt;/code&gt; assembler directive in the output.</source>
          <target state="translated">在输出中的 &lt;code&gt;.ident&lt;/code&gt; 汇编程序伪指令中，标识编译器使用的每个工具的版本。</target>
        </trans-unit>
        <trans-unit id="751c68a3471b1c791efaee0a8e7c24ea0c266efd" translate="yes" xml:space="preserve">
          <source>If</source>
          <target state="translated">If</target>
        </trans-unit>
        <trans-unit id="b94b85388613ff812132cfe4fbfdcb534fff787e" translate="yes" xml:space="preserve">
          <source>If &amp;lsquo;</source>
          <target state="translated">如果</target>
        </trans-unit>
        <trans-unit id="8cfab80fece1ea34402901dd4726bddf817b9cff" translate="yes" xml:space="preserve">
          <source>If 3DNow! extensions are enabled, &lt;code&gt;V2SF&lt;/code&gt; is used as a mode for a vector of two 32-bit floating-point values.</source>
          <target state="translated">如果是3DNow！启用扩展， &lt;code&gt;V2SF&lt;/code&gt; 用作两个32位浮点值的向量的模式。</target>
        </trans-unit>
        <trans-unit id="23030af34d65c4d0b445c2e6bf477bf6b1f5c071" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;%*&lt;/code&gt; appears as the last part of a spec sequence then a space is added after the end of the last substitution. If there is more text in the sequence, however, then a space is not generated. This allows the &lt;code&gt;%*&lt;/code&gt; substitution to be used as part of a larger string. For example, a spec string like this:</source>
          <target state="translated">如果 &lt;code&gt;%*&lt;/code&gt; 作为规范序列的最后一部分出现，则在最后一个替换结束之后添加一个空格。但是，如果序列中有更多文本，则不会生成空格。这允许将 &lt;code&gt;%*&lt;/code&gt; 替换用作较大字符串的一部分。例如，如下所示的规范字符串：</target>
        </trans-unit>
        <trans-unit id="539ea1d3aa99e1f5670827ce3f6d748af1cde993" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;+resolveInstanceMethod:&lt;/code&gt; (or &lt;code&gt;+resolveClassMethod:&lt;/code&gt;) is not implemented or returns &lt;code&gt;NO&lt;/code&gt;, the runtime then tries the forwarding hook.</source>
          <target state="translated">如果未实现 &lt;code&gt;+resolveInstanceMethod:&lt;/code&gt; 或 &lt;code&gt;+resolveClassMethod:&lt;/code&gt; ：）或返回 &lt;code&gt;NO&lt;/code&gt; ，那么运行时将尝试转发挂钩。</target>
        </trans-unit>
        <trans-unit id="3f8dd7c3c9fed3437a52aa9c603d614b32cf2d92" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;-Walloca-larger-than=500&lt;/code&gt; were passed, the above would trigger a warning, but this time because of the lack of bounds checking.</source>
          <target state="translated">如果 &lt;code&gt;-Walloca-larger-than=500&lt;/code&gt; ，则上面的命令将触发警告，但这一次是由于缺少边界检查。</target>
        </trans-unit>
        <trans-unit id="ca79581e5d9acfa9f2b20401cffd3a6d08f404f9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;D1&lt;/code&gt; has the form &lt;code&gt;( &lt;var&gt;attribute-specifier-list&lt;/var&gt; D )&lt;/code&gt;, and the declaration &lt;code&gt;T D&lt;/code&gt; specifies the type &amp;ldquo;&lt;var&gt;derived-declarator-type-list&lt;/var&gt;&lt;var&gt;Type&lt;/var&gt;&amp;rdquo; for &lt;var&gt;ident&lt;/var&gt;, then &lt;code&gt;T D1&lt;/code&gt; specifies the type &amp;ldquo;&lt;var&gt;derived-declarator-type-list&lt;/var&gt;&lt;var&gt;attribute-specifier-list&lt;/var&gt;&lt;var&gt;Type&lt;/var&gt;&amp;rdquo; for &lt;var&gt;ident&lt;/var&gt;.</source>
          <target state="translated">如果 &lt;code&gt;D1&lt;/code&gt; 的格式为 &lt;code&gt;( &lt;var&gt;attribute-specifier-list&lt;/var&gt; D )&lt;/code&gt; ，并且声明 &lt;code&gt;T D&lt;/code&gt; 为 &lt;var&gt;ident&lt;/var&gt; 指定类型&amp;ldquo; &lt;var&gt;derived-declarator-type-list&lt;/var&gt; &lt;var&gt;Type&lt;/var&gt; &amp;rdquo; ，则 &lt;code&gt;T D1&lt;/code&gt; 指定类型为&amp;ldquo; &lt;var&gt;derived-declarator-type-list&lt;/var&gt; &lt;var&gt;attribute-specifier-list&lt;/var&gt; &lt;var&gt;ident&lt;/var&gt; 的 &amp;ldquo; 说明符列表 &lt;var&gt;Type&lt;/var&gt; &amp;rdquo; 。</target>
        </trans-unit>
        <trans-unit id="bce12bf3e38781beccd90d07d87af63b34ed169d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;D1&lt;/code&gt; has the form &lt;code&gt;*
&lt;var&gt;type-qualifier-and-attribute-specifier-list&lt;/var&gt; D&lt;/code&gt;, and the declaration &lt;code&gt;T D&lt;/code&gt; specifies the type &amp;ldquo;&lt;var&gt;derived-declarator-type-list&lt;/var&gt;&lt;var&gt;Type&lt;/var&gt;&amp;rdquo; for &lt;var&gt;ident&lt;/var&gt;, then &lt;code&gt;T D1&lt;/code&gt; specifies the type &amp;ldquo;&lt;var&gt;derived-declarator-type-list&lt;/var&gt;&lt;var&gt;type-qualifier-and-attribute-specifier-list&lt;/var&gt; pointer to &lt;var&gt;Type&lt;/var&gt;&amp;rdquo; for &lt;var&gt;ident&lt;/var&gt;.</source>
          <target state="translated">如果 &lt;code&gt;D1&lt;/code&gt; 的形式为 &lt;code&gt;* &lt;var&gt;type-qualifier-and-attribute-specifier-list&lt;/var&gt; D&lt;/code&gt; ，并且声明 &lt;code&gt;T D&lt;/code&gt; 为 &lt;var&gt;ident&lt;/var&gt; 指定类型&amp;ldquo; &lt;var&gt;derived-declarator-type-list&lt;/var&gt; &lt;var&gt;Type&lt;/var&gt; &amp;rdquo; ，则 &lt;code&gt;T D1&lt;/code&gt; 指定类型为&amp;ldquo; &lt;var&gt;derived-declarator-type-list&lt;/var&gt; - d &amp;rdquo; 类型列表 &lt;var&gt;type-qualifier-and-attribute-specifier-list&lt;/var&gt; 指向 &lt;var&gt;ident&lt;/var&gt; 的 &amp;ldquo; &lt;var&gt;Type&lt;/var&gt; &amp;rdquo;的指针。</target>
        </trans-unit>
        <trans-unit id="fdf6957ed3c287429ab808fa75095697e4d021d5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;DECL_ASSEMBLER_NAME&lt;/code&gt; has been set for a given decl, use that in the dump instead of &lt;code&gt;DECL_NAME&lt;/code&gt;. Its primary use is ease of use working backward from mangled names in the assembly file.</source>
          <target state="translated">如果已为给定的decl设置了 &lt;code&gt;DECL_ASSEMBLER_NAME&lt;/code&gt; ，请在转储中使用它而不是 &lt;code&gt;DECL_NAME&lt;/code&gt; 。它的主要用途是易于使用，从汇编文件中的错误名称向后进行操作。</target>
        </trans-unit>
        <trans-unit id="647ff2c6b0ee66be47ceb0fe277c3fe135fc84e9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;GCC_EXEC_PREFIX&lt;/code&gt; is not set, GCC attempts to figure out an appropriate prefix to use based on the pathname it is invoked with.</source>
          <target state="translated">如果未设置 &lt;code&gt;GCC_EXEC_PREFIX&lt;/code&gt; ，则GCC会根据调用它的路径名尝试找出要使用的适当前缀。</target>
        </trans-unit>
        <trans-unit id="7fc3d06e6177481bf26c022c74076e71f4e1f421" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;GCC_EXEC_PREFIX&lt;/code&gt; is set, it specifies a prefix to use in the names of the subprograms executed by the compiler. No slash is added when this prefix is combined with the name of a subprogram, but you can specify a prefix that ends with a slash if you wish.</source>
          <target state="translated">如果设置了 &lt;code&gt;GCC_EXEC_PREFIX&lt;/code&gt; ，则它指定要在编译器执行的子程序名称中使用的前缀。当该前缀与子程序的名称结合使用时，不会添加任何斜杠，但是如果需要，您可以指定以斜杠结尾的前缀。</target>
        </trans-unit>
        <trans-unit id="dec8a7933acf37b1c0fdc778b779b3f382d54a7a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;LANG&lt;/code&gt; is not defined, or if it has some other value, then the compiler uses &lt;code&gt;mblen&lt;/code&gt; and &lt;code&gt;mbtowc&lt;/code&gt; as defined by the default locale to recognize and translate multibyte characters.</source>
          <target state="translated">如果未定义 &lt;code&gt;LANG&lt;/code&gt; 或具有其他值，则编译器将使用默认语言环境定义的 &lt;code&gt;mblen&lt;/code&gt; 和 &lt;code&gt;mbtowc&lt;/code&gt; 来识别和转换多字节字符。</target>
        </trans-unit>
        <trans-unit id="e1943099aece965452d744a5c53ffc07f2bc9f16" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;S&lt;/code&gt; is given to GCC, substitutes &lt;code&gt;X&lt;/code&gt;; else if &lt;code&gt;T&lt;/code&gt; is given to GCC, substitutes &lt;code&gt;Y&lt;/code&gt;; else substitutes &lt;code&gt;D&lt;/code&gt;. There can be as many clauses as you need. This may be combined with &lt;code&gt;.&lt;/code&gt;, &lt;code&gt;,&lt;/code&gt;, &lt;code&gt;!&lt;/code&gt;, &lt;code&gt;|&lt;/code&gt;, and &lt;code&gt;*&lt;/code&gt; as needed.</source>
          <target state="translated">如果将 &lt;code&gt;S&lt;/code&gt; 赋予GCC，则替换 &lt;code&gt;X&lt;/code&gt; ；否则，如果将 &lt;code&gt;T&lt;/code&gt; 赋予T，则替换 &lt;code&gt;Y&lt;/code&gt; ；其他替代品 &lt;code&gt;D&lt;/code&gt; 。您可以根据需要设置任意多个子句。可以与结合使用 &lt;code&gt;.&lt;/code&gt; ， &lt;code&gt;,&lt;/code&gt; ， &lt;code&gt;!&lt;/code&gt; ， &lt;code&gt;|&lt;/code&gt; ，并根据需要添加 &lt;code&gt;*&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="404ec67951a627fb06995708ad6a0e24dc041fa8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;TMPDIR&lt;/code&gt; is set, it specifies the directory to use for temporary files. GCC uses temporary files to hold the output of one stage of compilation which is to be used as input to the next stage: for example, the output of the preprocessor, which is the input to the compiler proper.</source>
          <target state="translated">如果设置了 &lt;code&gt;TMPDIR&lt;/code&gt; ，它将指定用于临时文件的目录。GCC使用临时文件保存一个编译阶段的输出，该输出将用作下一阶段的输入：例如，预处理器的输出，这是编译器本身的输入。</target>
        </trans-unit>
        <trans-unit id="1953caa75083ee28850ca171a34b26fd4eb8373f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;__has_trivial_constructor (type)&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; then the trait is &lt;code&gt;true&lt;/code&gt;, else if &lt;code&gt;type&lt;/code&gt; is a cv class or union type (or array thereof) with a default constructor that is known not to throw an exception then the trait is &lt;code&gt;true&lt;/code&gt;, else it is &lt;code&gt;false&lt;/code&gt;. Requires: &lt;code&gt;type&lt;/code&gt; shall be a complete type, (possibly cv-qualified) &lt;code&gt;void&lt;/code&gt;, or an array of unknown bound.</source>
          <target state="translated">如果 &lt;code&gt;__has_trivial_constructor (type)&lt;/code&gt; 为 &lt;code&gt;true&lt;/code&gt; ,则特征为 &lt;code&gt;true&lt;/code&gt; ，否则，如果 &lt;code&gt;type&lt;/code&gt; 是具有默认构造函数的cv类或联合类型（或其数组），并且已知该构造函数不会引发异常，则trait为 &lt;code&gt;true&lt;/code&gt; ，否则为 &lt;code&gt;false&lt;/code&gt; 。要求： &lt;code&gt;type&lt;/code&gt; 应该是一个完整的类型，（可能是cv限定的） &lt;code&gt;void&lt;/code&gt; ，或者是一个未知范围的数组。</target>
        </trans-unit>
        <trans-unit id="763c1f95adec0e6f2c3d89c3c9b77ea1bcae352d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;__has_trivial_copy (type)&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; then the trait is &lt;code&gt;true&lt;/code&gt;, else if &lt;code&gt;type&lt;/code&gt; is a cv-qualified class or union type with copy constructors that are known not to throw an exception then the trait is &lt;code&gt;true&lt;/code&gt;, else it is &lt;code&gt;false&lt;/code&gt;. Requires: &lt;code&gt;type&lt;/code&gt; shall be a complete type, (possibly cv-qualified) &lt;code&gt;void&lt;/code&gt;, or an array of unknown bound.</source>
          <target state="translated">如果 &lt;code&gt;__has_trivial_copy (type)&lt;/code&gt; 为 &lt;code&gt;true&lt;/code&gt; ,则特征为 &lt;code&gt;true&lt;/code&gt; ，否则，如果 &lt;code&gt;type&lt;/code&gt; 是具有cv限定的类或具有复制构造函数的联合类型（已知不会抛出异常），则特征为 &lt;code&gt;true&lt;/code&gt; ，否则为 &lt;code&gt;false&lt;/code&gt; 。要求： &lt;code&gt;type&lt;/code&gt; 应该是一个完整的类型，（可能是cv限定的） &lt;code&gt;void&lt;/code&gt; ，或者是一个未知范围的数组。</target>
        </trans-unit>
        <trans-unit id="348b274e4746ccb17d0ad8ccc31192a6601178b6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;__is_class (type)&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt; then the trait is &lt;code&gt;false&lt;/code&gt;. Otherwise &lt;code&gt;type&lt;/code&gt; is considered empty if and only if: &lt;code&gt;type&lt;/code&gt; has no non-static data members, or all non-static data members, if any, are bit-fields of length 0, and &lt;code&gt;type&lt;/code&gt; has no virtual members, and &lt;code&gt;type&lt;/code&gt; has no virtual base classes, and &lt;code&gt;type&lt;/code&gt; has no base classes &lt;code&gt;base_type&lt;/code&gt; for which &lt;code&gt;__is_empty (base_type)&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;. Requires: &lt;code&gt;type&lt;/code&gt; shall be a complete type, (possibly cv-qualified) &lt;code&gt;void&lt;/code&gt;, or an array of unknown bound.</source>
          <target state="translated">如果 &lt;code&gt;__is_class (type)&lt;/code&gt; 为 &lt;code&gt;false&lt;/code&gt; ,则特征为 &lt;code&gt;false&lt;/code&gt; 。否则 &lt;code&gt;type&lt;/code&gt; 被认为是空当且仅当： &lt;code&gt;type&lt;/code&gt; 没有非静态数据成员，或所有的非静态数据成员，如果有的话，是一个长度为0的位字段，和 &lt;code&gt;type&lt;/code&gt; 没有虚成员， &lt;code&gt;type&lt;/code&gt; 没有虚基类，和 &lt;code&gt;type&lt;/code&gt; 没有基类 &lt;code&gt;base_type&lt;/code&gt; 为其 &lt;code&gt;__is_empty (base_type)&lt;/code&gt; 是 &lt;code&gt;false&lt;/code&gt; 。要求： &lt;code&gt;type&lt;/code&gt; 应该是一个完整的类型，（可能是cv限定的） &lt;code&gt;void&lt;/code&gt; ，或者是一个未知范围的数组。</target>
        </trans-unit>
        <trans-unit id="3fb256b452a67db2fcf29b7d6c9eb3c3b57425ef" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;__is_pod (type)&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;type&lt;/code&gt; is a reference type then the trait is &lt;code&gt;true&lt;/code&gt;, else if &lt;code&gt;type&lt;/code&gt; is a cv class or union type (or array thereof) with a trivial destructor ([class.dtor]) then the trait is &lt;code&gt;true&lt;/code&gt;, else it is &lt;code&gt;false&lt;/code&gt;. Requires: &lt;code&gt;type&lt;/code&gt; shall be a complete type, (possibly cv-qualified) &lt;code&gt;void&lt;/code&gt;, or an array of unknown bound.</source>
          <target state="translated">如果 &lt;code&gt;__is_pod (type)&lt;/code&gt; 为 &lt;code&gt;true&lt;/code&gt; 或 &lt;code&gt;type&lt;/code&gt; 为引用类型，则特征为 &lt;code&gt;true&lt;/code&gt; ，否则，如果 &lt;code&gt;type&lt;/code&gt; 为具有琐碎析构函数（[class.dtor]）的cv类或联合类型（或其数组），则特征为 &lt;code&gt;true&lt;/code&gt; 否则为 &lt;code&gt;false&lt;/code&gt; 。要求： &lt;code&gt;type&lt;/code&gt; 应该是一个完整的类型，（可能是cv限定的） &lt;code&gt;void&lt;/code&gt; ，或者是一个未知范围的数组。</target>
        </trans-unit>
        <trans-unit id="d1bf9587539b51be90adc4a1e785e99e947f0059" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;__is_pod (type)&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;type&lt;/code&gt; is a reference type then the trait is &lt;code&gt;true&lt;/code&gt;, else if &lt;code&gt;type&lt;/code&gt; is a cv class or union type with a trivial copy constructor ([class.copy]) then the trait is &lt;code&gt;true&lt;/code&gt;, else it is &lt;code&gt;false&lt;/code&gt;. Requires: &lt;code&gt;type&lt;/code&gt; shall be a complete type, (possibly cv-qualified) &lt;code&gt;void&lt;/code&gt;, or an array of unknown bound.</source>
          <target state="translated">如果 &lt;code&gt;__is_pod (type)&lt;/code&gt; 是 &lt;code&gt;true&lt;/code&gt; 或 &lt;code&gt;type&lt;/code&gt; 是引用类型，则trait是 &lt;code&gt;true&lt;/code&gt; ，否则，如果 &lt;code&gt;type&lt;/code&gt; 是具有简单复制构造函数（[class.copy]）的cv类或联合类型，则trait是 &lt;code&gt;true&lt;/code&gt; ，否则是 &lt;code&gt;false&lt;/code&gt; 。要求： &lt;code&gt;type&lt;/code&gt; 应该是一个完整的类型，（可能是cv限定的） &lt;code&gt;void&lt;/code&gt; ，或者是一个未知范围的数组。</target>
        </trans-unit>
        <trans-unit id="2f38bb6a2ade7b8693787a1194261c7451943ac5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;__is_pod (type)&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; then the trait is &lt;code&gt;true&lt;/code&gt;, else if &lt;code&gt;type&lt;/code&gt; is a cv-qualified class or union type (or array thereof) with a trivial default constructor ([class.ctor]) then the trait is &lt;code&gt;true&lt;/code&gt;, else it is &lt;code&gt;false&lt;/code&gt;. Requires: &lt;code&gt;type&lt;/code&gt; shall be a complete type, (possibly cv-qualified) &lt;code&gt;void&lt;/code&gt;, or an array of unknown bound.</source>
          <target state="translated">如果 &lt;code&gt;__is_pod (type)&lt;/code&gt; 为 &lt;code&gt;true&lt;/code&gt; ,则特征为 &lt;code&gt;true&lt;/code&gt; ，否则，如果 &lt;code&gt;type&lt;/code&gt; 是具有普通构造函数（[class.ctor]）的cv限定类或联合类型（或其数组），则特征为 &lt;code&gt;true&lt;/code&gt; ，否则它为true是 &lt;code&gt;false&lt;/code&gt; 。要求： &lt;code&gt;type&lt;/code&gt; 应该是一个完整的类型，（可能是cv限定的） &lt;code&gt;void&lt;/code&gt; ，或者是一个未知范围的数组。</target>
        </trans-unit>
        <trans-unit id="d19955ce7ffa6060ce61b406573fd7fa063dda62" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;base_type&lt;/code&gt; is a base class of &lt;code&gt;derived_type&lt;/code&gt; ([class.derived]) then the trait is &lt;code&gt;true&lt;/code&gt;, otherwise it is &lt;code&gt;false&lt;/code&gt;. Top-level cv-qualifications of &lt;code&gt;base_type&lt;/code&gt; and &lt;code&gt;derived_type&lt;/code&gt; are ignored. For the purposes of this trait, a class type is considered is own base. Requires: if &lt;code&gt;__is_class (base_type)&lt;/code&gt; and &lt;code&gt;__is_class (derived_type)&lt;/code&gt; are &lt;code&gt;true&lt;/code&gt; and &lt;code&gt;base_type&lt;/code&gt; and &lt;code&gt;derived_type&lt;/code&gt; are not the same type (disregarding cv-qualifiers), &lt;code&gt;derived_type&lt;/code&gt; shall be a complete type. A diagnostic is produced if this requirement is not met.</source>
          <target state="translated">如果 &lt;code&gt;base_type&lt;/code&gt; 是 &lt;code&gt;derived_type&lt;/code&gt; （[class.derived]）的基类，则特征为 &lt;code&gt;true&lt;/code&gt; ，否则为 &lt;code&gt;false&lt;/code&gt; 。 &lt;code&gt;base_type&lt;/code&gt; 和 &lt;code&gt;derived_type&lt;/code&gt; 的顶级简历资格将被忽略。出于此特征的目的，将类类型视为自己的基础。要求：如果 &lt;code&gt;__is_class (base_type)&lt;/code&gt; 和 &lt;code&gt;__is_class (derived_type)&lt;/code&gt; 为 &lt;code&gt;true&lt;/code&gt; ,并且 &lt;code&gt;base_type&lt;/code&gt; 和 &lt;code&gt;derived_type&lt;/code&gt; 不是同一类型（不考虑cv限定词），则 &lt;code&gt;derived_type&lt;/code&gt; 应为完整类型。如果不满足此要求，则会生成诊断。</target>
        </trans-unit>
        <trans-unit id="9ad52c7e701f6b6ac16fc011e5c3a814b836cace" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;objc_msg_lookup()&lt;/code&gt; does not find a suitable method implementation, because the receiver does not implement the required method, it tries to see if the class can dynamically register the method.</source>
          <target state="translated">如果 &lt;code&gt;objc_msg_lookup()&lt;/code&gt; 未找到合适的方法实现，因为接收方未实现所需的方法，它将尝试查看该类是否可以动态注册该方法。</target>
        </trans-unit>
        <trans-unit id="de0324724a4ecec17009f5551872ea4de764d9cf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;packed&lt;/code&gt; is used on a structure, or if bit-fields are used, it may be that the Microsoft ABI lays out the structure differently than the way GCC normally does. Particularly when moving packed data between functions compiled with GCC and the native Microsoft compiler (either via function call or as data in a file), it may be necessary to access either format.</source>
          <target state="translated">如果在结构上使用 &lt;code&gt;packed&lt;/code&gt; 或使用位字段，则可能是Microsoft ABI对结构的布局不同于GCC正常进行的布局。特别是在通过GCC编译的函数和本机Microsoft编译器之间（通过函数调用或作为文件中的数据）在移动打包数据时，可能需要访问这两种格式。</target>
        </trans-unit>
        <trans-unit id="6f7ba7dbf5e57d92bfe72102ff6203af39a12a8c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;signed&lt;/code&gt; or &lt;code&gt;unsigned&lt;/code&gt; is omitted, the signedness of the vector type is the default signedness of the base type. The default varies depending on the operating system, so a portable program should always specify the signedness.</source>
          <target state="translated">如果省略有 &lt;code&gt;signed&lt;/code&gt; 或 &lt;code&gt;unsigned&lt;/code&gt; ，则向量类型的有符号性是基本类型的默认有符号性。默认值因操作系统而异，因此可移植程序应始终指定签名。</target>
        </trans-unit>
        <trans-unit id="ffd246c0a3fbb949c1fa9d8cc2260944e77a3bfb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;type&lt;/code&gt; is &lt;code&gt;const&lt;/code&gt;- qualified or is a reference type then the trait is &lt;code&gt;false&lt;/code&gt;. Otherwise if &lt;code&gt;__is_pod (type)&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; then the trait is &lt;code&gt;true&lt;/code&gt;, else if &lt;code&gt;type&lt;/code&gt; is a cv-qualified class or union type with a trivial copy assignment ([class.copy]) then the trait is &lt;code&gt;true&lt;/code&gt;, else it is &lt;code&gt;false&lt;/code&gt;. Requires: &lt;code&gt;type&lt;/code&gt; shall be a complete type, (possibly cv-qualified) &lt;code&gt;void&lt;/code&gt;, or an array of unknown bound.</source>
          <target state="translated">如果 &lt;code&gt;type&lt;/code&gt; 为 &lt;code&gt;const&lt;/code&gt; 限定或为引用类型，则特征为 &lt;code&gt;false&lt;/code&gt; 。否则，如果 &lt;code&gt;__is_pod (type)&lt;/code&gt; 为 &lt;code&gt;true&lt;/code&gt; ,则特征为 &lt;code&gt;true&lt;/code&gt; ；否则，如果 &lt;code&gt;type&lt;/code&gt; 是具有cv限定资格的类或联合类型且具有琐碎的拷贝分配（[class.copy]），则特征为 &lt;code&gt;true&lt;/code&gt; ，否则为 &lt;code&gt;false&lt;/code&gt; 。要求： &lt;code&gt;type&lt;/code&gt; 应该是一个完整的类型，（可能是cv限定的） &lt;code&gt;void&lt;/code&gt; ，或者是一个未知范围的数组。</target>
        </trans-unit>
        <trans-unit id="283cf2672e55770fc0551d9647cca120a4bb630b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;type&lt;/code&gt; is &lt;code&gt;const&lt;/code&gt;-qualified or is a reference type then the trait is &lt;code&gt;false&lt;/code&gt;. Otherwise if &lt;code&gt;__has_trivial_assign (type)&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; then the trait is &lt;code&gt;true&lt;/code&gt;, else if &lt;code&gt;type&lt;/code&gt; is a cv-qualified class or union type with copy assignment operators that are known not to throw an exception then the trait is &lt;code&gt;true&lt;/code&gt;, else it is &lt;code&gt;false&lt;/code&gt;. Requires: &lt;code&gt;type&lt;/code&gt; shall be a complete type, (possibly cv-qualified) &lt;code&gt;void&lt;/code&gt;, or an array of unknown bound.</source>
          <target state="translated">如果 &lt;code&gt;type&lt;/code&gt; 为 &lt;code&gt;const&lt;/code&gt; 限定或为引用类型，则trait为 &lt;code&gt;false&lt;/code&gt; 。否则，如果 &lt;code&gt;__has_trivial_assign (type)&lt;/code&gt; 为 &lt;code&gt;true&lt;/code&gt; ,则特征为 &lt;code&gt;true&lt;/code&gt; ；否则，如果 &lt;code&gt;type&lt;/code&gt; 是具有副本赋值运算符的cv限定类或联合类型，并且已知不会抛出异常，则该特征为 &lt;code&gt;true&lt;/code&gt; ，否则为 &lt;code&gt;false&lt;/code&gt; 。要求： &lt;code&gt;type&lt;/code&gt; 应该是一个完整的类型，（可能是cv限定的） &lt;code&gt;void&lt;/code&gt; ，或者是一个未知范围的数组。</target>
        </trans-unit>
        <trans-unit id="63c11c8bb0212d553ee20398c564d16b6ec7e69f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;type&lt;/code&gt; is a class type with a virtual destructor ([class.dtor]) then the trait is &lt;code&gt;true&lt;/code&gt;, else it is &lt;code&gt;false&lt;/code&gt;. Requires: &lt;code&gt;type&lt;/code&gt; shall be a complete type, (possibly cv-qualified) &lt;code&gt;void&lt;/code&gt;, or an array of unknown bound.</source>
          <target state="translated">如果 &lt;code&gt;type&lt;/code&gt; 是具有虚拟析构函数（[class.dtor]）的类类型，则特征为 &lt;code&gt;true&lt;/code&gt; ，否则为 &lt;code&gt;false&lt;/code&gt; 。要求： &lt;code&gt;type&lt;/code&gt; 应该是一个完整的类型，（可能是cv限定的） &lt;code&gt;void&lt;/code&gt; ，或者是一个未知范围的数组。</target>
        </trans-unit>
        <trans-unit id="3c2e0cd65d0655c5ce8c12d2d2d4a097d810e389" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;type&lt;/code&gt; is a cv POD type ([basic.types]) then the trait is &lt;code&gt;true&lt;/code&gt;, else it is &lt;code&gt;false&lt;/code&gt;. Requires: &lt;code&gt;type&lt;/code&gt; shall be a complete type, (possibly cv-qualified) &lt;code&gt;void&lt;/code&gt;, or an array of unknown bound.</source>
          <target state="translated">如果 &lt;code&gt;type&lt;/code&gt; 是cv POD类型（[basic.types]），则特征为 &lt;code&gt;true&lt;/code&gt; ，否则为 &lt;code&gt;false&lt;/code&gt; 。要求： &lt;code&gt;type&lt;/code&gt; 应该是一个完整的类型，（可能是cv限定的） &lt;code&gt;void&lt;/code&gt; ，或者是一个未知范围的数组。</target>
        </trans-unit>
        <trans-unit id="723863e0b5a8fce8c661ff18582b201e84983629" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;type&lt;/code&gt; is a cv enumeration type ([basic.compound]) the trait is &lt;code&gt;true&lt;/code&gt;, else it is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;type&lt;/code&gt; 是cv枚举类型（[basic.compound]），则特征为 &lt;code&gt;true&lt;/code&gt; ，否则为 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6b7975a53cee041123902e4671962591f8c2cbd7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;type&lt;/code&gt; is a cv union type ([basic.compound]) the trait is &lt;code&gt;true&lt;/code&gt;, else it is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;type&lt;/code&gt; 是cv联合类型（[basic.compound]），则特征为 &lt;code&gt;true&lt;/code&gt; ，否则为 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="89ab4b13f03f8e9b77ccbec6378e569d290932f7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;type&lt;/code&gt; is a cv-qualified class type, and not a union type ([basic.compound]) the trait is &lt;code&gt;true&lt;/code&gt;, else it is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;type&lt;/code&gt; 是cv限定的类类型，而不是联合类型（[basic.compound]），则特征为 &lt;code&gt;true&lt;/code&gt; ，否则为 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d6c08c113aac15208c2698077a3dc6d2ee08e364" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;type&lt;/code&gt; is a literal type ([basic.types]) the trait is &lt;code&gt;true&lt;/code&gt;, else it is &lt;code&gt;false&lt;/code&gt;. Requires: &lt;code&gt;type&lt;/code&gt; shall be a complete type, (possibly cv-qualified) &lt;code&gt;void&lt;/code&gt;, or an array of unknown bound.</source>
          <target state="translated">如果 &lt;code&gt;type&lt;/code&gt; 是文字类型（[basic.types]），则特征为 &lt;code&gt;true&lt;/code&gt; ，否则为 &lt;code&gt;false&lt;/code&gt; 。要求： &lt;code&gt;type&lt;/code&gt; 应该是一个完整的类型，（可能是cv限定的） &lt;code&gt;void&lt;/code&gt; ，或者是一个未知范围的数组。</target>
        </trans-unit>
        <trans-unit id="44c42d9c3a648a4586d6d80ed2afeb43acc1f98c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;type&lt;/code&gt; is a polymorphic class ([class.virtual]) then the trait is &lt;code&gt;true&lt;/code&gt;, else it is &lt;code&gt;false&lt;/code&gt;. Requires: &lt;code&gt;type&lt;/code&gt; shall be a complete type, (possibly cv-qualified) &lt;code&gt;void&lt;/code&gt;, or an array of unknown bound.</source>
          <target state="translated">如果 &lt;code&gt;type&lt;/code&gt; 是多态类（[class.virtual]），则特征为 &lt;code&gt;true&lt;/code&gt; ，否则为 &lt;code&gt;false&lt;/code&gt; 。要求： &lt;code&gt;type&lt;/code&gt; 应该是一个完整的类型，（可能是cv限定的） &lt;code&gt;void&lt;/code&gt; ，或者是一个未知范围的数组。</target>
        </trans-unit>
        <trans-unit id="902c4582059f6f78c8c47e8d4db16bfd414011e3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;type&lt;/code&gt; is a standard-layout type ([basic.types]) the trait is &lt;code&gt;true&lt;/code&gt;, else it is &lt;code&gt;false&lt;/code&gt;. Requires: &lt;code&gt;type&lt;/code&gt; shall be a complete type, (possibly cv-qualified) &lt;code&gt;void&lt;/code&gt;, or an array of unknown bound.</source>
          <target state="translated">如果 &lt;code&gt;type&lt;/code&gt; 是标准布局类型（[basic.types]），则特征为 &lt;code&gt;true&lt;/code&gt; ，否则为 &lt;code&gt;false&lt;/code&gt; 。要求： &lt;code&gt;type&lt;/code&gt; 应该是一个完整的类型，（可能是cv限定的） &lt;code&gt;void&lt;/code&gt; ，或者是一个未知范围的数组。</target>
        </trans-unit>
        <trans-unit id="c53c71f1f92604372ad3a40e885b3e290ad04715" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;type&lt;/code&gt; is a trivial type ([basic.types]) the trait is &lt;code&gt;true&lt;/code&gt;, else it is &lt;code&gt;false&lt;/code&gt;. Requires: &lt;code&gt;type&lt;/code&gt; shall be a complete type, (possibly cv-qualified) &lt;code&gt;void&lt;/code&gt;, or an array of unknown bound.</source>
          <target state="translated">如果 &lt;code&gt;type&lt;/code&gt; 是琐碎的类型（[basic.types]），则特征为 &lt;code&gt;true&lt;/code&gt; ，否则为 &lt;code&gt;false&lt;/code&gt; 。要求： &lt;code&gt;type&lt;/code&gt; 应该是一个完整的类型，（可能是cv限定的） &lt;code&gt;void&lt;/code&gt; ，或者是一个未知范围的数组。</target>
        </trans-unit>
        <trans-unit id="ffe6e21bc41957ab0a00219c12663528f239f642" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;type&lt;/code&gt; is an abstract class ([class.abstract]) then the trait is &lt;code&gt;true&lt;/code&gt;, else it is &lt;code&gt;false&lt;/code&gt;. Requires: &lt;code&gt;type&lt;/code&gt; shall be a complete type, (possibly cv-qualified) &lt;code&gt;void&lt;/code&gt;, or an array of unknown bound.</source>
          <target state="translated">如果 &lt;code&gt;type&lt;/code&gt; 是抽象类（[class.abstract]），则特征为 &lt;code&gt;true&lt;/code&gt; ，否则为 &lt;code&gt;false&lt;/code&gt; 。要求： &lt;code&gt;type&lt;/code&gt; 应该是一个完整的类型，（可能是cv限定的） &lt;code&gt;void&lt;/code&gt; ，或者是一个未知范围的数组。</target>
        </trans-unit>
        <trans-unit id="911911ebb73f24baa4568a362dcf6545a5e8bd9f" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;X&lt;/var&gt; is &lt;code&gt;0xf&lt;/code&gt;, then the &lt;var&gt;n&lt;/var&gt;-th bit of &lt;var&gt;val&lt;/var&gt; is returned unaltered.</source>
          <target state="translated">如果 &lt;var&gt;X&lt;/var&gt; 为 &lt;code&gt;0xf&lt;/code&gt; ，则返回 &lt;var&gt;val&lt;/var&gt; 的第 &lt;var&gt;n&lt;/var&gt; 位不变。</target>
        </trans-unit>
        <trans-unit id="529d14d76239ac927a58af9240682db818e156fc" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;desired&lt;/var&gt; is written into &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt; then &lt;code&gt;true&lt;/code&gt; is returned and memory is affected according to the memory order specified by &lt;var&gt;success_memorder&lt;/var&gt;. There are no restrictions on what memory order can be used here.</source>
          <target state="translated">如果 &lt;var&gt;desired&lt;/var&gt; 将其写入 &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt; ,则返回 &lt;code&gt;true&lt;/code&gt; ，并且内存会根据 &lt;var&gt;success_memorder&lt;/var&gt; 指定的内存顺序受到影响。在这里可以使用什么存储顺序没有限制。</target>
        </trans-unit>
        <trans-unit id="90eefc597dfd05335fdc76d585991dd479f5699e" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;device&lt;/var&gt; is not a device but only a core architecture like &amp;lsquo;</source>
          <target state="translated">如果 &lt;var&gt;device&lt;/var&gt; 不是设备，而只是诸如&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="37aede7b841b819868fc3f607fc7588d32233439" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;exp1&lt;/var&gt; is returned, the return type is the same as &lt;var&gt;exp1&lt;/var&gt;&amp;rsquo;s type. Similarly, if &lt;var&gt;exp2&lt;/var&gt; is returned, its return type is the same as &lt;var&gt;exp2&lt;/var&gt;.</source>
          <target state="translated">如果返回 &lt;var&gt;exp1&lt;/var&gt; ，则返回类型与 &lt;var&gt;exp1&lt;/var&gt; 的类型相同。同样，如果返回 &lt;var&gt;exp2&lt;/var&gt; ，则其返回类型与 &lt;var&gt;exp2&lt;/var&gt; 相同。</target>
        </trans-unit>
        <trans-unit id="43726f9389a16cd86ccc87693856924d076a1cd7" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;file&lt;/var&gt; is</source>
          <target state="translated">如果 &lt;var&gt;file&lt;/var&gt; 是</target>
        </trans-unit>
        <trans-unit id="5b94a494d8a93062d1fb2f08cf22419880d46ae7" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;m&lt;/var&gt; is not specified, it defaults to &lt;var&gt;n&lt;/var&gt;.</source>
          <target state="translated">如果未指定 &lt;var&gt;m&lt;/var&gt; ，则默认为 &lt;var&gt;n&lt;/var&gt; 。</target>
        </trans-unit>
        <trans-unit id="96e30c03c390fa37f95beff815a87bdc5f2296a9" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;n&lt;/var&gt; is not specified or is zero, use a machine-dependent default which is very likely to be &amp;lsquo;</source>
          <target state="translated">如果未指定 &lt;var&gt;n&lt;/var&gt; 或为n，请使用与机器相关的默认值，该默认值很可能是'</target>
        </trans-unit>
        <trans-unit id="4f4c9abfe6823ac3226b1f95cfb68ae207a767d4" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;n&lt;/var&gt; is not specified or is zero, use a machine-dependent default.</source>
          <target state="translated">如果未指定 &lt;var&gt;n&lt;/var&gt; 或为n，则使用与机器有关的默认值。</target>
        </trans-unit>
        <trans-unit id="edea744d98224ea825d53a93f917e0198d6b4e4e" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;n&lt;/var&gt; is not specified or is zero, use a machine-dependent default. The maximum allowed &lt;var&gt;n&lt;/var&gt; option value is 65536.</source>
          <target state="translated">如果未指定 &lt;var&gt;n&lt;/var&gt; 或为n，则使用与机器有关的默认值。 &lt;var&gt;n&lt;/var&gt; 选项的最大允许值为65536。</target>
        </trans-unit>
        <trans-unit id="759dfcc7101124f098c766f1c7cd00bcc6b949db" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;options&lt;/var&gt; is omitted, it defaults to &amp;lsquo;</source>
          <target state="translated">如果省略 &lt;var&gt;options&lt;/var&gt; ，则默认为'</target>
        </trans-unit>
        <trans-unit id="4a58d0d422304ea0f155ce08523224eb514fe6b5" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;path&lt;/var&gt; is specified, GCC looks at the &lt;var&gt;path&lt;/var&gt; to find the profile feedback data files. See</source>
          <target state="translated">如果 &lt;var&gt;path&lt;/var&gt; 指定，GCC着眼于 &lt;var&gt;path&lt;/var&gt; 寻找配置文件反馈数据文件。看到</target>
        </trans-unit>
        <trans-unit id="9d543a6e5b2a62c41981e6b57e0c00240c859530" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;path&lt;/var&gt; is specified, GCC saves</source>
          <target state="translated">如果指定了 &lt;var&gt;path&lt;/var&gt; ，则GCC会保存</target>
        </trans-unit>
        <trans-unit id="424b9b0e5144f1c216be7ac998c97fd4f7a0b3fa" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;type&lt;/var&gt; is &amp;lsquo;</source>
          <target state="translated">如果 &lt;var&gt;type&lt;/var&gt; 为&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="a48f8bd6ddf94d7b46204690dc61b7e1c17bca21" translate="yes" xml:space="preserve">
          <source>If GCC cannot find the subprogram using the specified prefix, it tries looking in the usual places for the subprogram.</source>
          <target state="translated">如果GCC不能用指定的前缀找到子程序,它将尝试在通常的地方寻找子程序。</target>
        </trans-unit>
        <trans-unit id="49e516aa2892d9e488e19e4de501aef3c975c28a" translate="yes" xml:space="preserve">
          <source>If GCC was configured to use a GLIBC before 2.23, the built-in function &lt;code&gt;__builtin_cpu_is&lt;/code&gt; always returns a 0 and the compiler issues a warning.</source>
          <target state="translated">如果将GCC配置为在2.23之前使用GLIBC，则内置函数 &lt;code&gt;__builtin_cpu_is&lt;/code&gt; 始终返回0，并且编译器会发出警告。</target>
        </trans-unit>
        <trans-unit id="009bc2728024c27e5f3a38c77a771a92e70da809" translate="yes" xml:space="preserve">
          <source>If GCC was configured to use a GLIBC before 2.23, the built-in function &lt;code&gt;__builtin_cpu_suports&lt;/code&gt; always returns a 0 and the compiler issues a warning.</source>
          <target state="translated">如果将GCC配置为在2.23之前使用GLIBC，则内置函数 &lt;code&gt;__builtin_cpu_suports&lt;/code&gt; 始终返回0，并且编译器会发出警告。</target>
        </trans-unit>
        <trans-unit id="3d3dbe293db43d1939fa63d41a62ea0fb70dc054" translate="yes" xml:space="preserve">
          <source>If LTO encounters objects with C linkage declared with incompatible types in separate translation units to be linked together (undefined behavior according to ISO C99 6.2.7), a non-fatal diagnostic may be issued. The behavior is still undefined at run time. Similar diagnostics may be raised for other languages.</source>
          <target state="translated">如果LTO在单独的翻译单元中遇到用不兼容类型声明的C链接对象要链接在一起(根据ISO C99 6.2.7,行为未定义),可能会发出一个非致命的诊断。该行为在运行时仍未定义。对于其他语言,可能会发出类似的诊断。</target>
        </trans-unit>
        <trans-unit id="8064195381cae5ba1afd9e1080f901756518ee59" translate="yes" xml:space="preserve">
          <source>If SSE extensions are enabled, &lt;code&gt;V4SF&lt;/code&gt; is used for a vector of four 32-bit floating-point values. Some instructions use a vector of four 32-bit integers, these use &lt;code&gt;V4SI&lt;/code&gt;. Finally, some instructions operate on an entire vector register, interpreting it as a 128-bit integer, these use mode &lt;code&gt;TI&lt;/code&gt;.</source>
          <target state="translated">如果启用了SSE扩展， &lt;code&gt;V4SF&lt;/code&gt; 用于四个32位浮点值的向量。一些指令使用四个32位整数的向量，这些指令使用 &lt;code&gt;V4SI&lt;/code&gt; 。最后，一些指令对整个向量寄存器进行操作，将其解释为128位整数，这些指令使用模式 &lt;code&gt;TI&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c8aa3d549316941fe06d6dfd92787397e613a82c" translate="yes" xml:space="preserve">
          <source>If X is in the range 0&amp;hellip;7, then the &lt;var&gt;n&lt;/var&gt;-th result bit is set to the &lt;var&gt;X&lt;/var&gt;-th bit of &lt;var&gt;bits&lt;/var&gt;</source>
          <target state="translated">如果X的范围是0&amp;hellip;7，则将第 &lt;var&gt;n&lt;/var&gt; 个结果位设置为第 &lt;var&gt;X&lt;/var&gt; 个 &lt;var&gt;bits&lt;/var&gt;</target>
        </trans-unit>
        <trans-unit id="4795ba768ec1950f8dcd780b40f59791bb2c3400" translate="yes" xml:space="preserve">
          <source>If X is in the range 8&amp;hellip;&lt;code&gt;0xe&lt;/code&gt;, then the &lt;var&gt;n&lt;/var&gt;-th result bit is undefined.</source>
          <target state="translated">如果X的范围是8&amp;hellip; &lt;code&gt;0xe&lt;/code&gt; ，那么第 &lt;var&gt;n&lt;/var&gt; 个结果位是不确定的。</target>
        </trans-unit>
        <trans-unit id="77a0a28430753763f9053f0aed3455f25006e137" translate="yes" xml:space="preserve">
          <source>If a &lt;a href=&quot;named-address-spaces#AVR-Named-Address-Spaces&quot;&gt;named address space&lt;/a&gt; other than generic or &lt;code&gt;__flash&lt;/code&gt; is used, then &lt;code&gt;RAMPZ&lt;/code&gt; is set as needed before the operation.</source>
          <target state="translated">如果使用了通用或 &lt;code&gt;__flash&lt;/code&gt; 以外的&lt;a href=&quot;named-address-spaces#AVR-Named-Address-Spaces&quot;&gt;命名地址空间&lt;/a&gt;，则在操作之前根据需要设置 &lt;code&gt;RAMPZ&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e78a838d8422ed3d9e1991db7c391d81f3fd283d" translate="yes" xml:space="preserve">
          <source>If a class is declared to implement a protocol, a warning is issued for every method in the protocol that is not implemented by the class. The default behavior is to issue a warning for every method not explicitly implemented in the class, even if a method implementation is inherited from the superclass. If you use the</source>
          <target state="translated">如果一个类被声明实现了一个协议,那么对于协议中每一个没有被类实现的方法都会发出警告。默认的行为是为类中没有明确实现的每一个方法发出警告,即使一个方法的实现是从超类中继承的。如果你使用</target>
        </trans-unit>
        <trans-unit id="29f23802437b44fdcdb64561f47637459cfd3577" translate="yes" xml:space="preserve">
          <source>If a diagnostic contains fix-it hints, it has a &lt;code&gt;fixits&lt;/code&gt; array, consisting of half-open intervals, similar to the output of</source>
          <target state="translated">如果诊断程序包含fix-it提示，则它具有一个 &lt;code&gt;fixits&lt;/code&gt; 数组，该数组由半开间隔组成，类似于的输出。</target>
        </trans-unit>
        <trans-unit id="e94ab481666483b349181850cc8e39b26f438c5d" translate="yes" xml:space="preserve">
          <source>If a function returns a temporary &lt;code&gt;initializer_list&lt;/code&gt;, or a local &lt;code&gt;initializer_list&lt;/code&gt; variable, the array&amp;rsquo;s lifetime ends at the end of the return statement, so the value returned has a dangling pointer.</source>
          <target state="translated">如果函数返回临时的 &lt;code&gt;initializer_list&lt;/code&gt; 或局部的 &lt;code&gt;initializer_list&lt;/code&gt; 变量，则数组的生存期在return语句的结尾处结束，因此返回的值具有悬空指针。</target>
        </trans-unit>
        <trans-unit id="51be4d38853f3a30d7f15e3610ea69ae54265c4e" translate="yes" xml:space="preserve">
          <source>If a loop iterates over an array with a variable stride, create another version of the loop that assumes the stride is always one. For example:</source>
          <target state="translated">如果一个循环在一个有变量跨度的数组上迭代,那么创建另一个版本的循环,假设跨度总是1。例如:如果在一个数组上迭代一个变量stride,那么创建另一个版本的循环,假设stride总是一。</target>
        </trans-unit>
        <trans-unit id="e603935699eb5e105e69e65a9021ca2022ac4213" translate="yes" xml:space="preserve">
          <source>If a new-expression creates an &lt;code&gt;initializer_list&lt;/code&gt;, the array only lives until the end of the enclosing full-expression, so the &lt;code&gt;initializer_list&lt;/code&gt; in the heap has a dangling pointer.</source>
          <target state="translated">如果new-expression创建了 &lt;code&gt;initializer_list&lt;/code&gt; ，则该数组仅生存到封闭的full-expression的末尾，因此堆中的 &lt;code&gt;initializer_list&lt;/code&gt; 具有悬空的指针。</target>
        </trans-unit>
        <trans-unit id="dcc181452125b891816dee9715c4c073b739c819" translate="yes" xml:space="preserve">
          <source>If a program must use a different C++ library and it&amp;rsquo;s not possible to do the final link using a C++ driver that uses that library by default, it is necessary to tell &lt;code&gt;g++&lt;/code&gt; the location and name of that library. It might also be necessary to specify different startup files and other runtime support libraries, and to suppress the use of GCC&amp;rsquo;s support libraries with one or more of the options</source>
          <target state="translated">如果程序必须使用其他C ++库，并且无法使用默认使用该库的C ++驱动程序进行最终链接，则必须告知 &lt;code&gt;g++&lt;/code&gt; 该库的位置和名称。可能还需要指定不同的启动文件和其他运行时支持库，并使用一个或多个选项来禁止使用GCC的支持库。</target>
        </trans-unit>
        <trans-unit id="e84c4785b4be9bc72195941ed1f8c2b45255457e" translate="yes" xml:space="preserve">
          <source>If a standard system include directory, or a directory specified with</source>
          <target state="translated">如果是标准的系统包含目录,或者是用</target>
        </trans-unit>
        <trans-unit id="5c3be2ab717ecd782733ce9b93456fcb31fc4af7" translate="yes" xml:space="preserve">
          <source>If a variable has the &lt;code&gt;below100&lt;/code&gt; attribute (&lt;code&gt;BELOW100&lt;/code&gt; is allowed also), GCC places the variable in the first 0x100 bytes of memory and use special opcodes to access it. Such variables are placed in either the &lt;code&gt;.bss_below100&lt;/code&gt; section or the &lt;code&gt;.data_below100&lt;/code&gt; section.</source>
          <target state="translated">如果变量具有 &lt;code&gt;below100&lt;/code&gt; 属性（也允许使用 &lt;code&gt;BELOW100&lt;/code&gt; ），则GCC会将变量放置在内存的前0x100字节中，并使用特殊的操作码进行访问。此类变量放在 &lt;code&gt;.bss_below100&lt;/code&gt; 节或 &lt;code&gt;.data_below100&lt;/code&gt; 节中。</target>
        </trans-unit>
        <trans-unit id="38c3454c59e77e91336081ab769819e7fd53ba65" translate="yes" xml:space="preserve">
          <source>If a zero-length bit-field follows a normal bit-field, the type of the zero-length bit-field may affect the alignment of the structure as whole. For example, &lt;code&gt;t2&lt;/code&gt; has a size of 4 bytes, since the zero-length bit-field follows a normal bit-field, and is of type short.</source>
          <target state="translated">如果零长度位域跟随正常位域，则零长度位域的类型可能会影响整个结构的对齐方式。例如， &lt;code&gt;t2&lt;/code&gt; 的大小为4个字节，这是因为零长度的位字段跟随普通的位字段，并且类型为short。</target>
        </trans-unit>
        <trans-unit id="3930dc0fc00c26bd7cfbb87588dd5cf1e2064acf" translate="yes" xml:space="preserve">
          <source>If a zero-length bit-field is inserted after a bit-field, &lt;code&gt;foo&lt;/code&gt;, and the alignment of the zero-length bit-field is greater than the member that follows it, &lt;code&gt;bar&lt;/code&gt;, &lt;code&gt;bar&lt;/code&gt; is aligned as the type of the zero-length bit-field.</source>
          <target state="translated">如果将零长度位域插入到位域 &lt;code&gt;foo&lt;/code&gt; 之后，并且零长度位域的对齐方式大于其后的成员 &lt;code&gt;bar&lt;/code&gt; ， &lt;code&gt;bar&lt;/code&gt; ，则将其对齐为零长度的类型。长度位字段。</target>
        </trans-unit>
        <trans-unit id="487b9fa86178ee0fe71d79bf284c4ff7466101a0" translate="yes" xml:space="preserve">
          <source>If a zero-length bit-field is inserted between two bit-fields that are normally coalesced, the bit-fields are not coalesced.</source>
          <target state="translated">如果在两个正常聚合的位字段之间插入一个零长度的位字段,则位字段不聚合。</target>
        </trans-unit>
        <trans-unit id="fce50e2e3a2f90483694041f1d50957c036fd376" translate="yes" xml:space="preserve">
          <source>If accessing any memory location is potentially unsafe when speculative execution is incorrect, then the code can be rewritten as</source>
          <target state="translated">如果在投机执行不正确的情况下,访问任何内存位置都是潜在的不安全的,那么可以将代码改写为</target>
        </trans-unit>
        <trans-unit id="19dee42123d1606545b47bdc1aee4dced42d70ef" translate="yes" xml:space="preserve">
          <source>If all calls to a given function are integrated, and the function is declared &lt;code&gt;static&lt;/code&gt;, then the function is normally not output as assembler code in its own right.</source>
          <target state="translated">如果集成了对给定函数的所有调用，并且将该函数声明为 &lt;code&gt;static&lt;/code&gt; ，则该函数通常不会单独以汇编代码的形式输出。</target>
        </trans-unit>
        <trans-unit id="6747ee18a18040e35fcb4f80dbfe422de83e0b1d" translate="yes" xml:space="preserve">
          <source>If an explicit version number is provided and</source>
          <target state="translated">如果提供了一个明确的版本号,并且</target>
        </trans-unit>
        <trans-unit id="2a42f93a55377bd2fb4570f085c309d8859bae77" translate="yes" xml:space="preserve">
          <source>If an instruction only takes Altivec registers, you do not want to use &lt;code&gt;%x&amp;lt;n&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">如果一条指令仅使用Altivec寄存器，则不希望使用 &lt;code&gt;%x&amp;lt;n&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="364981cd1f151ee605ed86bfcc1747b52ebe7a19" translate="yes" xml:space="preserve">
          <source>If any of</source>
          <target state="translated">如果有任何</target>
        </trans-unit>
        <trans-unit id="d4335275a2f1edfde414bbe1e986ac43ea3a56a9" translate="yes" xml:space="preserve">
          <source>If any of the enabled test conditions is true, the corresponding entry in the result vector is -1. Otherwise (all of the enabled test conditions are false), the corresponding entry of the result vector is 0.</source>
          <target state="translated">如果任何一个启用的测试条件为真,结果向量的相应条目为-1。否则(所有启用的测试条件都是假的),结果向量的相应条目为0。</target>
        </trans-unit>
        <trans-unit id="b0cb0b3f3853386544ffbd0fa1ea4935f0522535" translate="yes" xml:space="preserve">
          <source>If any of these options is used, then the linker is not run, and object file names should not be used as arguments. See &lt;a href=&quot;overall-options#Overall-Options&quot;&gt;Overall Options&lt;/a&gt;.</source>
          <target state="translated">如果使用这些选项中的任何一个，则不会运行链接器，并且不应将目标文件名用作参数。请参阅&lt;a href=&quot;overall-options#Overall-Options&quot;&gt;总体选项&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="66bff0fe442c04caa45d8e4b29fa05e61e69952b" translate="yes" xml:space="preserve">
          <source>If application code relies on copy-assignment, a user-defined copy-assignment operator removes any uncertainties. With such an operator, the application can define whether and how the virtual base subobject is assigned.</source>
          <target state="translated">如果应用程序代码依赖于复制分配,用户定义的复制分配操作符可以消除任何不确定性。有了这样的操作符,应用程序可以定义是否以及如何分配虚拟基础子对象。</target>
        </trans-unit>
        <trans-unit id="3e6fe2d65d6ae8e8dddd4d9d96db3ba491946874" translate="yes" xml:space="preserve">
          <source>If both &lt;code&gt;signal&lt;/code&gt; and &lt;code&gt;interrupt&lt;/code&gt; are specified for the same function, &lt;code&gt;signal&lt;/code&gt; is silently ignored.</source>
          <target state="translated">如果 &lt;code&gt;signal&lt;/code&gt; 和 &lt;code&gt;interrupt&lt;/code&gt; 都指定用于同一功能，则将忽略 &lt;code&gt;signal&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9edaf55b500443b684dd1328cbcf6a8752769f40" translate="yes" xml:space="preserve">
          <source>If both arguments are zero, hotpatching is disabled.</source>
          <target state="translated">如果两个参数都是0,则禁用热补丁。</target>
        </trans-unit>
        <trans-unit id="32b3bc364441ca8a7ce5db371cd86527cc2b0b55" translate="yes" xml:space="preserve">
          <source>If both the template and enclosing class have explicit visibility, the visibility from the template is used.</source>
          <target state="translated">如果模板和包围类都有显式可见性,则使用模板的可见性。</target>
        </trans-unit>
        <trans-unit id="02529d20c3d2e23aefd28ee9dcdbc7281d16eb72" translate="yes" xml:space="preserve">
          <source>If combined with</source>
          <target state="translated">如果结合</target>
        </trans-unit>
        <trans-unit id="af3104b1407804a82ad43f4fa2a84131be37f920" translate="yes" xml:space="preserve">
          <source>If control flow reaches the point of the &lt;code&gt;__builtin_unreachable&lt;/code&gt;, the program is undefined. It is useful in situations where the compiler cannot deduce the unreachability of the code.</source>
          <target state="translated">如果控制流到达 &lt;code&gt;__builtin_unreachable&lt;/code&gt; 的点，则该程序未定义。在编译器无法推断代码无法到达的情况下，此方法很有用。</target>
        </trans-unit>
        <trans-unit id="36b8c90f4b777d0cb2020f4d21e6ac15532c3ad9" translate="yes" xml:space="preserve">
          <source>If debugging information is output when using the precompiled header, using</source>
          <target state="translated">如果使用预编译头时输出调试信息,使用</target>
        </trans-unit>
        <trans-unit id="402b191a6d5b620de512d8843ce1f34d7777a814" translate="yes" xml:space="preserve">
          <source>If either of the ways of changing the assembly name of a declaration are applied to a declaration whose assembly name has already been determined (either by a previous use of one of these features, or because the compiler needed the assembly name in order to generate code), and the new name is different, a warning issues and the name does not change.</source>
          <target state="translated">如果改变声明的汇编名的任何一种方式被应用到一个已经确定了汇编名的声明上(或者是通过以前对这些特性之一的使用,或者是因为编译器需要汇编名来生成代码),而新的名称是不同的,那么就会发出一个警告,并且名称不会改变。</target>
        </trans-unit>
        <trans-unit id="880d85143795b8a0d51003e3aa0f6bbac2bee006" translate="yes" xml:space="preserve">
          <source>If enabled, call summaries are only used for functions with more than one call site, and that are sufficiently complicated (as per</source>
          <target state="translated">如果启用,调用摘要只用于有多个调用点,并且足够复杂的函数(按照</target>
        </trans-unit>
        <trans-unit id="8e6cf380114ced6b961e13544b6be03dfc3354e5" translate="yes" xml:space="preserve">
          <source>If enabled, control-speculative instructions are chosen for schedule only if there are no other choices at the moment. This makes the use of the control speculation much more conservative. The default setting is disabled.</source>
          <target state="translated">如果启用,只有在当前没有其他选择的情况下,才会选择控制投机指令进行调度。这使得控制推测的使用更加保守。默认设置为禁用。</target>
        </trans-unit>
        <trans-unit id="c9aeee8753743f519ff715357d9285071a0d9d86" translate="yes" xml:space="preserve">
          <source>If enabled, data-speculative instructions are chosen for schedule only if there are no other choices at the moment. This makes the use of the data speculation much more conservative. The default setting is disabled.</source>
          <target state="translated">如果启用,只有在当前没有其他选择的情况下,才会选择数据投机指令进行调度。这使得数据推测的使用更加保守。默认设置为禁用。</target>
        </trans-unit>
        <trans-unit id="12c5281bb30137f5a28029f336bddc2453ae8835" translate="yes" xml:space="preserve">
          <source>If enabled, speculative dependencies are considered during computation of the instructions priorities. This makes the use of the speculation a bit more conservative. The default setting is disabled.</source>
          <target state="translated">如果启用,在计算指令优先级的过程中会考虑推测依赖性。这使得推测的使用更加保守一些。默认设置为禁用。</target>
        </trans-unit>
        <trans-unit id="9d63d7ff73f8a910b7cb613706af4cc8bb2d95b9" translate="yes" xml:space="preserve">
          <source>If enabled, the maximum amount of space required for outgoing arguments is computed in the function prologue. This is faster on most modern CPUs because of reduced dependencies, improved scheduling and reduced stack usage when the preferred stack boundary is not equal to 2. The drawback is a notable increase in code size. This switch implies</source>
          <target state="translated">如果启用,则在函数prologue中计算出出站参数所需的最大空间。这在大多数现代CPU上速度更快,因为减少了依赖性,改进了调度,当首选堆栈边界不等于2时,减少了堆栈的使用。 缺点是代码大小明显增加。这种切换意味着</target>
        </trans-unit>
        <trans-unit id="40d23331ec805b8693bd0e7ed41af8f41bbbeef4" translate="yes" xml:space="preserve">
          <source>If functions are defined in one file and are called in another file, then be sure to write this declaration in both files.</source>
          <target state="translated">如果在一个文件中定义了函数,并在另一个文件中被调用,那么一定要在两个文件中写下这个声明。</target>
        </trans-unit>
        <trans-unit id="5a84ad9332942b0583d76324d55388fa827b1dc5" translate="yes" xml:space="preserve">
          <source>If it is a scalar type, or on most targets an aggregate type whose only member object is of a scalar type, or a union type whose member objects are of scalar types, the expression is interpreted by GCC as a read of the volatile object; in the other cases, the expression is only evaluated for its side effects.</source>
          <target state="translated">如果它是一个标量类型,或者在大多数目标上是一个集合类型,其唯一的成员对象是标量类型,或者是一个联合类型,其成员对象是标量类型,该表达式被GCC解释为对volatile对象的读取;在其他情况下,该表达式只对其副作用进行评估。</target>
        </trans-unit>
        <trans-unit id="79c1054be8ddf1396d899393bbaa81764a2eed88" translate="yes" xml:space="preserve">
          <source>If multiple</source>
          <target state="translated">如果多个</target>
        </trans-unit>
        <trans-unit id="e94921c7bd35daddf444608f5259a29f5f4c8cc8" translate="yes" xml:space="preserve">
          <source>If neither</source>
          <target state="translated">如果没有</target>
        </trans-unit>
        <trans-unit id="afb8c1ba0a7e5bf800f44e5494e9d700db801b00" translate="yes" xml:space="preserve">
          <source>If new system header files are installed, nothing automatically arranges to update the corrected header files. They can be updated using the &lt;code&gt;mkheaders&lt;/code&gt; script installed in</source>
          <target state="translated">如果安装了新的系统头文件，则不会自动安排任何操作来更新更正的头文件。可以使用安装在以下位置的 &lt;code&gt;mkheaders&lt;/code&gt; 脚本来更新它们</target>
        </trans-unit>
        <trans-unit id="b7def704de696eb922c5e5ba1f5217476d727ef7" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;NSFastEnumerationState&lt;/code&gt; is defined in your code, the compiler will automatically replace &lt;code&gt;NSFastEnumerationState *&lt;/code&gt; with &lt;code&gt;struct __objcFastEnumerationState *&lt;/code&gt;, where that type is silently defined by the compiler in an identical way. This can be confusing and we recommend that you define &lt;code&gt;NSFastEnumerationState&lt;/code&gt; (as shown above) instead.</source>
          <target state="translated">如果没有 &lt;code&gt;NSFastEnumerationState&lt;/code&gt; 在你的代码中定义，编译器会自动更换 &lt;code&gt;NSFastEnumerationState *&lt;/code&gt; 与 &lt;code&gt;struct __objcFastEnumerationState *&lt;/code&gt; ，其中，该类型是由编译器以相同的方式默默的定义。这可能会造成混淆，建议您 &lt;code&gt;NSFastEnumerationState&lt;/code&gt; 定义NSFastEnumerationState（如上所示）。</target>
        </trans-unit>
        <trans-unit id="089bb39031737c14c4b1a0b430296a1926daaea0" translate="yes" xml:space="preserve">
          <source>If no &lt;var&gt;arg-index&lt;/var&gt; is given to the &lt;code&gt;nonnull&lt;/code&gt; attribute, all pointer arguments are marked as non-null. To illustrate, the following declaration is equivalent to the previous example:</source>
          <target state="translated">如果未将 &lt;var&gt;arg-index&lt;/var&gt; 赋予 &lt;code&gt;nonnull&lt;/code&gt; 属性，则所有指针参数都标记为non-null。为了说明这一点，下面的声明与前面的示例等效：</target>
        </trans-unit>
        <trans-unit id="73b44337d5bc4559e8e1c4b6db36d411b8aef133" translate="yes" xml:space="preserve">
          <source>If no error occurs during compilation, run the compiler a second time, adding &lt;var&gt;opts&lt;/var&gt; and</source>
          <target state="translated">如果在编译过程中没有发生错误，请再次运行编译器，并添加 &lt;var&gt;opts&lt;/var&gt; 和</target>
        </trans-unit>
        <trans-unit id="0e662391588b3d6a0fd25b9abb8a35c922931e60" translate="yes" xml:space="preserve">
          <source>If no fixup is needed, this function simply passes through &lt;var&gt;addr&lt;/var&gt;.</source>
          <target state="translated">如果不需要修复，则此函数仅通过 &lt;var&gt;addr&lt;/var&gt; 传递。</target>
        </trans-unit>
        <trans-unit id="23e134435009fd7bc4ece425ce52605621edbf3d" translate="yes" xml:space="preserve">
          <source>If none of the above search methods find &amp;lsquo;</source>
          <target state="translated">如果以上搜索方法均未找到&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="2c0304f8188faa2beb1f6913883824900b9fd415" translate="yes" xml:space="preserve">
          <source>If not otherwise specified by an attribute, assume all calls might be beyond the offset range of the &lt;code&gt;b&lt;/code&gt; / &lt;code&gt;bl&lt;/code&gt; instructions, and therefore load the function address into a register before performing a (otherwise direct) call. This is the default.</source>
          <target state="translated">如果没有通过属性另外指定，则假定所有调用都可能超出 &lt;code&gt;b&lt;/code&gt; / &lt;code&gt;bl&lt;/code&gt; 指令的偏移范围，因此在执行（否则直接调用）之前将函数地址加载到寄存器中。这是默认值。</target>
        </trans-unit>
        <trans-unit id="4019c8219c3b5cd2dda4dbb0cb3bf4c2a485adff" translate="yes" xml:space="preserve">
          <source>If not otherwise specified by an attribute, assume all direct calls are in the range of the &lt;code&gt;b&lt;/code&gt; / &lt;code&gt;bl&lt;/code&gt; instructions, so use these instructions for direct calls. The default is</source>
          <target state="translated">如果没有通过属性另外指定，则假定所有直接调用都在 &lt;code&gt;b&lt;/code&gt; / &lt;code&gt;bl&lt;/code&gt; 指令的范围内，因此请将这些指令用于直接调用。默认是</target>
        </trans-unit>
        <trans-unit id="12a28d9821da145a465f7298f6e4c4d208680d82" translate="yes" xml:space="preserve">
          <source>If number of memory accesses in function being instrumented is greater or equal to this number, use callbacks instead of inline checks. E.g. to disable inline code use</source>
          <target state="translated">如果被检测的函数的内存访问次数大于或等于这个数字,则使用回调代替内联检查。例如,如果要禁用内联代码,可以使用 &quot;回调 &quot;来代替内联检查。</target>
        </trans-unit>
        <trans-unit id="5104c1df665f6fc4dddeb5595f01af321de5cad6" translate="yes" xml:space="preserve">
          <source>If object files containing GIMPLE bytecode are stored in a library archive, say</source>
          <target state="translated">如果包含 GIMPLE 字节码的对象文件存储在库存档中,比如说</target>
        </trans-unit>
        <trans-unit id="1debeabea3e55864c791086673e07af5641e2395" translate="yes" xml:space="preserve">
          <source>If patchable function entries are enabled globally using the command-line option</source>
          <target state="translated">如果使用命令行选项全局启用了可打补丁的函数项</target>
        </trans-unit>
        <trans-unit id="7ae6684dfcfa35ba16cecacd5ec92f0fb9e0c04e" translate="yes" xml:space="preserve">
          <source>If profiling is active (</source>
          <target state="translated">如果剖析处于活动状态 (</target>
        </trans-unit>
        <trans-unit id="88f3c4dd1f2c3c978031ca46886480a0ad40a791" translate="yes" xml:space="preserve">
          <source>If supported by the target machine, generate instructions to prefetch memory to improve the performance of loops that access large arrays.</source>
          <target state="translated">如果目标机器支持,生成预取内存的指令,以提高访问大型数组的循环的性能。</target>
        </trans-unit>
        <trans-unit id="8bfe7e580871525d66e6234642f97096fcdef387" translate="yes" xml:space="preserve">
          <source>If supported for the target machine, attempt to reorder instructions to eliminate execution stalls due to required data being unavailable. This helps machines that have slow floating point or memory load instructions by allowing other instructions to be issued until the result of the load or floating-point instruction is required.</source>
          <target state="translated">如果目标机器支持,则尝试重新排序指令,以消除由于所需数据不可用而导致的执行停滞。这有助于那些浮点或内存加载指令速度较慢的机器,因为它允许发出其他指令,直到需要加载或浮点指令的结果。</target>
        </trans-unit>
        <trans-unit id="3428a2e4a1d11936eea0f07c36277bc2aa02d581" translate="yes" xml:space="preserve">
          <source>If supported for the target machine, attempt to reorder instructions to exploit instruction slots available after delayed branch instructions.</source>
          <target state="translated">如果目标机器支持,则尝试重新排序指令,以利用延迟分支指令后可用的指令槽。</target>
        </trans-unit>
        <trans-unit id="324f5e0a0812879119b6243a7b551f6c87385665" translate="yes" xml:space="preserve">
          <source>If supported for the target machine, emit position-independent code, suitable for dynamic linking and avoiding any limit on the size of the global offset table. This option makes a difference on AArch64, m68k, PowerPC and SPARC.</source>
          <target state="translated">如果目标机器支持,则发出与位置无关的代码,适用于动态链接,避免对全局偏移表的大小进行任何限制。这个选项在 AArch64、m68k、PowerPC 和 SPARC 上有区别。</target>
        </trans-unit>
        <trans-unit id="3d9b7696c9777c3fdef5f5f1690ef14ee23382d9" translate="yes" xml:space="preserve">
          <source>If the</source>
          <target state="translated">如果</target>
        </trans-unit>
        <trans-unit id="848af5bfa5ce573c8e5c9af3ee618628d308338c" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;LC_ALL&lt;/code&gt; environment variable is set, it overrides the value of &lt;code&gt;LC_CTYPE&lt;/code&gt; and &lt;code&gt;LC_MESSAGES&lt;/code&gt;; otherwise, &lt;code&gt;LC_CTYPE&lt;/code&gt; and &lt;code&gt;LC_MESSAGES&lt;/code&gt; default to the value of the &lt;code&gt;LANG&lt;/code&gt; environment variable. If none of these variables are set, GCC defaults to traditional C English behavior.</source>
          <target state="translated">如果设置了 &lt;code&gt;LC_ALL&lt;/code&gt; 环境变量，它将覆盖 &lt;code&gt;LC_CTYPE&lt;/code&gt; 和 &lt;code&gt;LC_MESSAGES&lt;/code&gt; 的值；否则， &lt;code&gt;LC_CTYPE&lt;/code&gt; 和 &lt;code&gt;LC_MESSAGES&lt;/code&gt; 默认为 &lt;code&gt;LANG&lt;/code&gt; 环境变量的值。如果未设置这些变量，则GCC默认为传统的C英语行为。</target>
        </trans-unit>
        <trans-unit id="927b034e0a10d14fe57f4acd375117bf77534e22" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;error&lt;/code&gt; or &lt;code&gt;warning&lt;/code&gt; attribute is used on a function declaration and a call to such a function is not eliminated through dead code elimination or other optimizations, an error or warning (respectively) that includes &lt;var&gt;message&lt;/var&gt; is diagnosed. This is useful for compile-time checking, especially together with &lt;code&gt;__builtin_constant_p&lt;/code&gt; and inline functions where checking the inline function arguments is not possible through &lt;code&gt;extern char [(condition) ? 1 : -1];&lt;/code&gt; tricks.</source>
          <target state="translated">如果在函数声明上使用了 &lt;code&gt;error&lt;/code&gt; 或 &lt;code&gt;warning&lt;/code&gt; 属性，并且没有通过消除无效代码或进行其他优化来消除了对该函数的调用，则会分别诊断出包含 &lt;var&gt;message&lt;/var&gt; 的错误或警告。这对于编译时检查很有用，特别是与 &lt;code&gt;__builtin_constant_p&lt;/code&gt; 和内联函数一起使用时，无法通过 &lt;code&gt;extern char [(condition) ? 1 : -1];&lt;/code&gt; 检查内联函数参数。1：-1]；技巧。</target>
        </trans-unit>
        <trans-unit id="20d0c6878745134aa8d904b0690e4fcbddc7d599" translate="yes" xml:space="preserve">
          <source>If the &lt;var&gt;filename&lt;/var&gt; is provided, then the dumps from all the applicable optimizations are concatenated into the &lt;var&gt;filename&lt;/var&gt;. Otherwise the dump is output onto</source>
          <target state="translated">如果提供了 &lt;var&gt;filename&lt;/var&gt; ，则来自所有适用优化的转储将串联到 &lt;var&gt;filename&lt;/var&gt; 。否则将转储输出到</target>
        </trans-unit>
        <trans-unit id="9215ad70f2e3e9c6cab1765215d93885159eaa97" translate="yes" xml:space="preserve">
          <source>If the C code that follows the &lt;code&gt;asm&lt;/code&gt; makes no use of any of the output operands, use &lt;code&gt;volatile&lt;/code&gt; for the &lt;code&gt;asm&lt;/code&gt; statement to prevent the optimizers from discarding the &lt;code&gt;asm&lt;/code&gt; statement as unneeded (see &lt;a href=&quot;#Volatile&quot;&gt;Volatile&lt;/a&gt;).</source>
          <target state="translated">如果 &lt;code&gt;asm&lt;/code&gt; 后面的C代码不使用任何输出操作数，则对 &lt;code&gt;asm&lt;/code&gt; 语句使用 &lt;code&gt;volatile&lt;/code&gt; 可以防止优化程序不必要地丢弃 &lt;code&gt;asm&lt;/code&gt; 语句（请参见&lt;a href=&quot;#Volatile&quot;&gt;Volatile&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="2aa76d6986dfd258dee402c2c95ca11459599c59" translate="yes" xml:space="preserve">
          <source>If the CPU is executing speculatively then either:</source>
          <target state="translated">如果CPU执行得很投机,那么无论是。</target>
        </trans-unit>
        <trans-unit id="8fe995e077eb81e27ea124938efd43a017d00001" translate="yes" xml:space="preserve">
          <source>If the CPU is not speculatively executing the code, then &lt;var&gt;val&lt;/var&gt; is returned.</source>
          <target state="translated">如果CPU没有以推测方式执行代码，则返回 &lt;var&gt;val&lt;/var&gt; 。</target>
        </trans-unit>
        <trans-unit id="c68ba352d7c54da4de70d37cd280b24a3feb4442" translate="yes" xml:space="preserve">
          <source>If the ISA 2.07 additions to the vector/scalar (power8-vector) instruction set are available, the following additional functions are available for 64-bit targets. New vector types (&lt;var&gt;vector __int128&lt;/var&gt; and &lt;var&gt;vector __uint128&lt;/var&gt;) are available to hold the &lt;var&gt;__int128&lt;/var&gt; and &lt;var&gt;__uint128&lt;/var&gt; types to use these builtins.</source>
          <target state="translated">如果对向量/标量（power8-vector）指令集增加了ISA 2.07，则以下附加功能可用于64位目标。新的向量类型（ &lt;var&gt;vector __int128&lt;/var&gt; 和 &lt;var&gt;vector __uint128&lt;/var&gt; ）可用于容纳 &lt;var&gt;__int128&lt;/var&gt; 和 &lt;var&gt;__uint128&lt;/var&gt; 类型以使用这些内置函数。</target>
        </trans-unit>
        <trans-unit id="7ad5ced5d695028f0b739572f683d981d7b325cd" translate="yes" xml:space="preserve">
          <source>If the ISA 2.07 additions to the vector/scalar (power8-vector) instruction set are available, the following additional functions are available for both 32-bit and 64-bit targets. For 64-bit targets, you can use &lt;var&gt;vector long&lt;/var&gt; instead of &lt;var&gt;vector long long&lt;/var&gt;, &lt;var&gt;vector bool long&lt;/var&gt; instead of &lt;var&gt;vector bool long long&lt;/var&gt;, and &lt;var&gt;vector unsigned long&lt;/var&gt; instead of &lt;var&gt;vector unsigned long long&lt;/var&gt;.</source>
          <target state="translated">如果对向量/标量（power8-vector）指令集增加了ISA 2.07，则以下附加功能可用于32位和64位目标。对于64位目标，可以使用 &lt;var&gt;vector long&lt;/var&gt; 代替 &lt;var&gt;vector long long&lt;/var&gt; ，使用 &lt;var&gt;vector bool long&lt;/var&gt; 代替 &lt;var&gt;vector bool long long&lt;/var&gt; ，使用 &lt;var&gt;vector unsigned long&lt;/var&gt; 代替 &lt;var&gt;vector unsigned long long&lt;/var&gt; 。</target>
        </trans-unit>
        <trans-unit id="c22a3317bedd3145de7eb3a31ecc603e64eb80be" translate="yes" xml:space="preserve">
          <source>If the ISA 3.0 instruction set additions (</source>
          <target state="translated">如果ISA 3.0指令集的添加(</target>
        </trans-unit>
        <trans-unit id="424b99254d8407b86c2beca1ac6e71a6fca8ab99" translate="yes" xml:space="preserve">
          <source>If the ISA 3.0 instruction set additions are enabled (</source>
          <target state="translated">如果启用ISA 3.0指令集添加(</target>
        </trans-unit>
        <trans-unit id="b3ba2117601e3a207db62aaa0d548209b490cb82" translate="yes" xml:space="preserve">
          <source>If the argument to the macro has variably modified type, it is evaluated only once when using &lt;code&gt;__auto_type&lt;/code&gt;, but twice if &lt;code&gt;typeof&lt;/code&gt; is used.</source>
          <target state="translated">如果参数给宏已可变类型，它使用时只计算一次 &lt;code&gt;__auto_type&lt;/code&gt; ，但如果两次 &lt;code&gt;typeof&lt;/code&gt; 被使用。</target>
        </trans-unit>
        <trans-unit id="e5db05160eb702af65a65d649789a2509aade574" translate="yes" xml:space="preserve">
          <source>If the attribute is specified and &lt;code&gt;#pragma omp declare simd&lt;/code&gt; is present on a declaration and the</source>
          <target state="translated">如果指定了属性，并且 &lt;code&gt;#pragma omp declare simd&lt;/code&gt; 出现在声明中，并且</target>
        </trans-unit>
        <trans-unit id="d120c6bfa80fbe55cec1d9862d7e2421db795ea2" translate="yes" xml:space="preserve">
          <source>If the compiler was built to use the system&amp;rsquo;s headers by default, then the default for this option is the system version on which the compiler is running, otherwise the default is to make choices that are compatible with as many systems and code bases as possible.</source>
          <target state="translated">如果默认情况下编译器被构建为使用系统的标头，则此选项的默认值为运行编译器的系统版本，否则默认为做出与尽可能多的系统和代码库兼容的选择。</target>
        </trans-unit>
        <trans-unit id="d67b52944ba9df1fde368725db64f0de08228c75" translate="yes" xml:space="preserve">
          <source>If the compiler&amp;rsquo;s optimization uses a function&amp;rsquo;s body or information extracted from its body to optimize/change another function, the latter is called an impacted function of the former. If a function is patched, its impacted functions should be patched too.</source>
          <target state="translated">如果编译器的优化使用函数的主体或从其主体中提取的信息来优化/更改另一个函数，则后者称为前者的受影响函数。如果对功能进行了修补，则其受影响的功能也应进行修补。</target>
        </trans-unit>
        <trans-unit id="b237760180d1507d3e5ec309754cc736d88da667" translate="yes" xml:space="preserve">
          <source>If the cryptographic instructions are enabled (</source>
          <target state="translated">如果启用了加密指令(</target>
        </trans-unit>
        <trans-unit id="4fb7464a62433bc1b1813aee95893c7c7b12fed7" translate="yes" xml:space="preserve">
          <source>If the device comes with a specific &lt;code&gt;RAMP&lt;/code&gt; register, the ISR prologue/epilogue saves/restores that SFR and initializes it with zero in case the ISR code might (implicitly) use it.</source>
          <target state="translated">如果设备带有特定的 &lt;code&gt;RAMP&lt;/code&gt; 寄存器，则ISR序言/结尾将保存/恢复SFR，并将其初始化为零，以防ISR代码可能（隐式）使用它。</target>
        </trans-unit>
        <trans-unit id="f359291701f84a5c952e96591467d10e46106142" translate="yes" xml:space="preserve">
          <source>If the device supports RAM larger than 64 KiB and the compiler needs to change &lt;code&gt;RAMPZ&lt;/code&gt; to accomplish an operation, &lt;code&gt;RAMPZ&lt;/code&gt; is reset to zero after the operation.</source>
          <target state="translated">如果设备支持大于64 KiB的RAM，并且编译器需要更改 &lt;code&gt;RAMPZ&lt;/code&gt; 才能完成操作，则操作后 &lt;code&gt;RAMPZ&lt;/code&gt; 会重置为零。</target>
        </trans-unit>
        <trans-unit id="f00789f645166f6c5f009a2c80467dcc5f52da72" translate="yes" xml:space="preserve">
          <source>If the diagnostic has a path of control-flow events associated with it, it has a &lt;code&gt;path&lt;/code&gt; array of objects representing the events. Each event object has a &lt;code&gt;description&lt;/code&gt; string, a &lt;code&gt;location&lt;/code&gt; object, along with a &lt;code&gt;function&lt;/code&gt; string and a &lt;code&gt;depth&lt;/code&gt; number for representing interprocedural paths. The &lt;code&gt;function&lt;/code&gt; represents the current function at that event, and the &lt;code&gt;depth&lt;/code&gt; represents the stack depth relative to some baseline: the higher, the more frames are within the stack.</source>
          <target state="translated">如果诊断程序具有与之关联的控制流事件的 &lt;code&gt;path&lt;/code&gt; ，则它具有表示事件的对象的路径数组。每个事件对象都有一个 &lt;code&gt;description&lt;/code&gt; 字符串，一个 &lt;code&gt;location&lt;/code&gt; 对象，以及一个用于表示过程间路径的 &lt;code&gt;function&lt;/code&gt; 字符串和 &lt;code&gt;depth&lt;/code&gt; 编号。该 &lt;code&gt;function&lt;/code&gt; 代表在该事件中的当前功能，和 &lt;code&gt;depth&lt;/code&gt; 表示相对于基线一些堆栈深度：越高，更多的帧在堆栈内。</target>
        </trans-unit>
        <trans-unit id="4b99e2eb0f30f6704cb82d8729d610b9c040ff67" translate="yes" xml:space="preserve">
          <source>If the equal sign is omitted, the default</source>
          <target state="translated">如果省略等号,则默认为</target>
        </trans-unit>
        <trans-unit id="d2b152efe933ab511c3240207de045545a59413b" translate="yes" xml:space="preserve">
          <source>If the forwarding hook does not exist or returns &lt;code&gt;NULL&lt;/code&gt;, the runtime currently attempts forwarding using an older, deprecated API, and if that fails, it aborts the program. In future versions of the GNU Objective-C runtime, the runtime will immediately abort.</source>
          <target state="translated">如果转发钩子不存在或返回 &lt;code&gt;NULL&lt;/code&gt; ，则运行时当前会尝试使用旧的，已弃用的API进行转发，如果失败，它将中止程序。在将来的GNU Objective-C运行时版本中，运行时将立即终止。</target>
        </trans-unit>
        <trans-unit id="fb3ee17ffd6e7e71752206840400cc69026ba54d" translate="yes" xml:space="preserve">
          <source>If the function is called repeatedly with &lt;code&gt;untrusted_index&lt;/code&gt; less than the limit of 500, then a branch predictor will learn that the block of code that returns a value stored in &lt;code&gt;array&lt;/code&gt; will be executed. If the function is subsequently called with an out-of-range value it will still try to execute that block of code first until the CPU determines that the prediction was incorrect (the CPU will unwind any incorrect operations at that point). However, depending on how the result of the function is used, it might be possible to leave traces in the cache that can reveal what was stored at the out-of-bounds location. The built-in function can be used to provide some protection against leaking data in this way by changing the code to:</source>
          <target state="translated">如果使用 &lt;code&gt;untrusted_index&lt;/code&gt; 小于500的限制重复调用该函数，则分支预测器将获悉将执行返回存储在 &lt;code&gt;array&lt;/code&gt; 的值的代码块。如果随后使用超出范围的值调用该函数，它将仍然首先尝试执行该代码块，直到CPU确定预测不正确为止（此时，CPU将取消所有不正确的操作）。但是，根据函数结果的使用方式，可能会在缓存中留下一些痕迹，这些痕迹可以揭示出存储在越界位置的内容。通过将代码更改为以下内容，可以使用内置函数以这种方式提供一些保护，以防止数据泄漏：</target>
        </trans-unit>
        <trans-unit id="4966bfe90659d4fba00a57263dad419daa50166b" translate="yes" xml:space="preserve">
          <source>If the function is declared &lt;code&gt;extern&lt;/code&gt;, then this definition of the function is used only for inlining. In no case is the function compiled as a standalone function, not even if you take its address explicitly. Such an address becomes an external reference, as if you had only declared the function, and had not defined it. This has almost the effect of a macro. The way to use this is to put a function definition in a header file with this attribute, and put another copy of the function, without &lt;code&gt;extern&lt;/code&gt;, in a library file. The definition in the header file causes most calls to the function to be inlined. If any uses of the function remain, they refer to the single copy in the library. Note that the two definitions of the functions need not be precisely the same, although if they do not have the same effect your program may behave oddly.</source>
          <target state="translated">如果将函数声明为 &lt;code&gt;extern&lt;/code&gt; ，则此函数定义仅用于内联。绝对不会将函数编译为独立函数，即使您显式获取其地址也是如此。这样的地址将成为一个外部引用，就好像您仅声明了该函数而未定义它一样。这几乎具有宏的作用。使用此方法的方法是将函数定义放入具有此属性的头文件中，并放置函数的另一个副本，而无需 &lt;code&gt;extern&lt;/code&gt; ，在库文件中。头文件中的定义导致对函数的大多数调用被内联。如果仍然使用该功能，则它们引用库中的单个副本。请注意，函数的两个定义不必完全相同，尽管如果它们的效果不同，则您的程序可能会表现得很奇怪。</target>
        </trans-unit>
        <trans-unit id="b771c97ff2c33b584d16ad8091b88c7d383e2d71" translate="yes" xml:space="preserve">
          <source>If the function is inlined in several places, the block structure in each location might not be the same. For instance, a condition might now be calculable at compile time in some instances. Because the coverage of all the uses of the inline function will be shown for the same source lines, the line counts themselves might seem inconsistent.</source>
          <target state="translated">如果函数在多个地方内联,每个地方的块结构可能不一样。例如,在某些情况下,一个条件现在可能在编译时可以计算。因为内联函数的所有使用的覆盖范围将显示为相同的源行,所以行数本身可能看起来不一致。</target>
        </trans-unit>
        <trans-unit id="f54a0365a2045222faa9a6a632a364c211ec115e" translate="yes" xml:space="preserve">
          <source>If the function is not inlined, the compiler must emit an out of line copy of the function, in any object file that needs it. If</source>
          <target state="translated">如果函数没有内联,编译器必须在任何需要它的对象文件中,发出一个函数的外行副本。如果</target>
        </trans-unit>
        <trans-unit id="1d41e4e5598657e0dd5a304d5f9d42468e2c3eb3" translate="yes" xml:space="preserve">
          <source>If the hotpatch option is enabled, a &amp;ldquo;hot-patching&amp;rdquo; function prologue is generated for all functions in the compilation unit. The funtion label is prepended with the given number of two-byte NOP instructions (&lt;var&gt;pre-halfwords&lt;/var&gt;, maximum 1000000). After the label, 2 * &lt;var&gt;post-halfwords&lt;/var&gt; bytes are appended, using the largest NOP like instructions the architecture allows (maximum 1000000).</source>
          <target state="translated">如果启用了hotpatch选项，则会为编译单元中的所有功能生成一个&amp;ldquo;热补丁&amp;rdquo;功能序言。给功能标签加上给定数目的两字节NOP指令（ &lt;var&gt;pre-halfwords&lt;/var&gt; ，最大1000000）。标签之后，使用体系结构允许的最大NOP指令（最大1000000）附加2 * &lt;var&gt;post-halfwords&lt;/var&gt; 字节。</target>
        </trans-unit>
        <trans-unit id="1afbfd9c64402361ab2fa39f9fdbd1e3be8c266e" translate="yes" xml:space="preserve">
          <source>If the input program contains a function declaration such as:</source>
          <target state="translated">如果输入的程序包含一个函数声明,如:</target>
        </trans-unit>
        <trans-unit id="d87ca5a862edf69ec778f2863678b3c80b02aa1b" translate="yes" xml:space="preserve">
          <source>If the linker complains that an application is using too much small data, you might want to try rebuilding the less performance-critical parts with</source>
          <target state="translated">如果链接器抱怨应用程序使用了太多的小数据,你可能想尝试使用</target>
        </trans-unit>
        <trans-unit id="2bf1dd3a359ed16413542f38135a6d9bd4288cff" translate="yes" xml:space="preserve">
          <source>If the number of candidates in the set is smaller than this value, always try to remove unnecessary ivs from the set when adding a new one.</source>
          <target state="translated">如果集合中的候选人数量小于这个值,在添加新的候选人时,一定要尽量从集合中删除不必要的ivs。</target>
        </trans-unit>
        <trans-unit id="e7428a6a85aa26ccfc1d34f1f1cde51cd5cd4798" translate="yes" xml:space="preserve">
          <source>If the operand of &lt;code&gt;__alignof__&lt;/code&gt; is an lvalue rather than a type, its value is the required alignment for its type, taking into account any minimum alignment specified by attribute &lt;code&gt;aligned&lt;/code&gt; (see &lt;a href=&quot;common-variable-attributes#Common-Variable-Attributes&quot;&gt;Common Variable Attributes&lt;/a&gt;). For example, after this declaration:</source>
          <target state="translated">如果 &lt;code&gt;__alignof__&lt;/code&gt; 的操作数是左值而不是类型，则它的值是其类型所需的对齐方式，同时考虑到由属性 &lt;code&gt;aligned&lt;/code&gt; 指定的任何最小对齐方式（请参见&lt;a href=&quot;common-variable-attributes#Common-Variable-Attributes&quot;&gt;Common Variable Attributes&lt;/a&gt;）。例如，在此声明之后：</target>
        </trans-unit>
        <trans-unit id="a5fda9cca36b52c744155ff2696d3cbfb80c2db1" translate="yes" xml:space="preserve">
          <source>If the operand of the &lt;code&gt;__alignof__&lt;/code&gt; expression is a function, the expression evaluates to the alignment of the function which may be specified by attribute &lt;code&gt;aligned&lt;/code&gt; (see &lt;a href=&quot;common-function-attributes#Common-Function-Attributes&quot;&gt;Common Function Attributes&lt;/a&gt;).</source>
          <target state="translated">如果 &lt;code&gt;__alignof__&lt;/code&gt; 表达式的操作数是一个函数，则该表达式将求值该函数的对齐方式，该对齐方式可以由属性 &lt;code&gt;aligned&lt;/code&gt; 指定（请参见&lt;a href=&quot;common-function-attributes#Common-Function-Attributes&quot;&gt;Common Function Attributes&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="716641ab8a53f52206a358470c323b2f23eaf7fa" translate="yes" xml:space="preserve">
          <source>If the ratio of expression insertions to deletions is larger than this value for any expression, then RTL PRE inserts or removes the expression and thus leaves partially redundant computations in the instruction stream.</source>
          <target state="translated">如果对任何表达式来说,表达式插入与删除的比例大于这个值,那么RTL PRE就会插入或删除表达式,从而在指令流中留下部分冗余计算。</target>
        </trans-unit>
        <trans-unit id="05912318b76a1009d770bd192ecd133075c5fc90" translate="yes" xml:space="preserve">
          <source>If the register is a call-saved register, call ABI is affected: the register will not be restored in function epilogue sequences after the variable has been assigned. Therefore, functions cannot safely return to callers that assume standard ABI.</source>
          <target state="translated">如果寄存器是一个调用保存的寄存器,调用ABI就会受到影响:在变量被赋值后,寄存器在函数上句序列中不会被恢复。因此,函数不能安全地返回给假设标准ABI的调用者。</target>
        </trans-unit>
        <trans-unit id="9d80c0f0c0e0e7931ed927bbb4a8416d7ae0d80f" translate="yes" xml:space="preserve">
          <source>If the same field is initialized multiple times, or overlapping fields of a union are initialized, the value from the last initialization is used. When a field of a union is itself a structure, the entire structure from the last field initialized is used. If any previous initializer has side effect, it is unspecified whether the side effect happens or not. Currently, GCC discards the side-effecting initializer expressions and issues a warning.</source>
          <target state="translated">如果同一个字段被多次初始化,或者一个联合体的重叠字段被初始化,则使用最后一次初始化的值。当一个联合体的字段本身是一个结构体时,使用最后一次初始化的字段的整个结构体。如果之前的初始化器有副作用,那么副作用的发生与否是不明确的。目前,GCC会丢弃有副作用的初始化表达式并发出警告。</target>
        </trans-unit>
        <trans-unit id="60d643b079de10a712e4f0092195d4a678550bd1" translate="yes" xml:space="preserve">
          <source>If the second argument of a shift operation is within range, check that the result of a shift operation is not undefined. Note that what exactly is considered undefined differs slightly between C and C++, as well as between ISO C90 and C99, etc.</source>
          <target state="translated">如果移位操作的第二个参数在范围内,则检查移位操作的结果是否为未定义。需要注意的是,到底什么是未定义,在C和C++之间,以及ISO C90和C99等之间都略有不同。</target>
        </trans-unit>
        <trans-unit id="a31cdc2866161da54d441996165823d561084f93" translate="yes" xml:space="preserve">
          <source>If the selected floating-point hardware includes the NEON extension (e.g.</source>
          <target state="translated">如果所选的浮点硬件包含NEON扩展(如</target>
        </trans-unit>
        <trans-unit id="ba7e4ec3c7ed6c8b730bc79d728df15242bb6315" translate="yes" xml:space="preserve">
          <source>If the size of a local variable in bytes is smaller or equal to this number, directly poison (or unpoison) shadow memory instead of using run-time callbacks.</source>
          <target state="translated">如果一个局部变量的字节大小小于或等于这个数字,直接毒害(或解除毒害)影子内存,而不是使用运行时回调。</target>
        </trans-unit>
        <trans-unit id="417bd3fd4051d252d11a2c9158594ed0d6e39230" translate="yes" xml:space="preserve">
          <source>If the stack usage is (partly) dynamic and not bounded, it&amp;rsquo;s:</source>
          <target state="translated">如果堆栈使用情况（部分）是动态的且不受限制，则为：</target>
        </trans-unit>
        <trans-unit id="b6665e1bf11576c0ed34f60f152094f72a6d33b1" translate="yes" xml:space="preserve">
          <source>If the stack usage is (partly) dynamic but bounded, it&amp;rsquo;s:</source>
          <target state="translated">如果堆栈使用率是（部分）动态但有界的，则为：</target>
        </trans-unit>
        <trans-unit id="6185bf1adb7da0baa58ee0f68d56a9ef418a48d1" translate="yes" xml:space="preserve">
          <source>If the stack usage is fully static but exceeds the specified amount, it&amp;rsquo;s:</source>
          <target state="translated">如果堆栈使用情况是完全静态的，但超过了指定的数量，则为：</target>
        </trans-unit>
        <trans-unit id="d70267f0ff1a52892efb70d9a08fcf6abe326706" translate="yes" xml:space="preserve">
          <source>If the target does not require instruction cache flushes, &lt;code&gt;__builtin___clear_cache&lt;/code&gt; has no effect. Otherwise either instructions are emitted in-line to clear the instruction cache or a call to the &lt;code&gt;__clear_cache&lt;/code&gt; function in libgcc is made.</source>
          <target state="translated">如果目标不需要刷新指令高速缓存，则 &lt;code&gt;__builtin___clear_cache&lt;/code&gt; 无效。否则，将 &lt;code&gt;__clear_cache&lt;/code&gt; 方式发出指令以清除指令缓存，或者对libgcc中的__clear_cache函数进行调用。</target>
        </trans-unit>
        <trans-unit id="095e473e81d277e85bb1ebdb8df1dacc96479003" translate="yes" xml:space="preserve">
          <source>If the target does not support data prefetch, the address expression is evaluated if it includes side effects but no other code is generated and GCC does not issue a warning.</source>
          <target state="translated">如果目标不支持数据预取,如果地址表达式中包含副作用,则会对其进行评估,但不会生成其他代码,GCC也不会发出警告。</target>
        </trans-unit>
        <trans-unit id="063fcca71547a7fd5efc66500b8f981bd9c39ed3" translate="yes" xml:space="preserve">
          <source>If the target supports a BSS section, GCC by default puts variables that are initialized to zero into BSS. This can save space in the resulting code.</source>
          <target state="translated">如果目标支持BSS部分,GCC默认将初始化为0的变量放入BSS。这可以节省生成代码的空间。</target>
        </trans-unit>
        <trans-unit id="3918a65b7ea046bcd3f9722a5e8050706b67b421" translate="yes" xml:space="preserve">
          <source>If the transaction aborts, all side effects are undone and an abort code encoded as a bit mask is returned. The following macros are defined:</source>
          <target state="translated">如果交易中止,所有的副作用都被撤销,并返回一个以位掩码编码的中止代码。定义了以下宏。</target>
        </trans-unit>
        <trans-unit id="52878fb9a18ac14d0e8c56cabf2833c060108631" translate="yes" xml:space="preserve">
          <source>If the value in it has side effects, the side effects happen only once, not for each initialized field by the range initializer.</source>
          <target state="translated">如果其中的值有副作用,副作用只发生一次,而不是对每一个被范围初始化器初始化的字段。</target>
        </trans-unit>
        <trans-unit id="eea091306a656215179432ee609d12ba3a9d954d" translate="yes" xml:space="preserve">
          <source>If the value of &lt;code&gt;y&lt;/code&gt; is always 1, 2 or 3, then &lt;code&gt;x&lt;/code&gt; is always initialized, but GCC doesn&amp;rsquo;t know this. To suppress the warning, you need to provide a default case with assert(0) or similar code.</source>
          <target state="translated">如果 &lt;code&gt;y&lt;/code&gt; 的值始终是1、2或3，则 &lt;code&gt;x&lt;/code&gt; 总是被初始化，但是GCC不知道这一点。要取消显示警告，您需要提供一个带有assert（0）或类似代码的默认情况。</target>
        </trans-unit>
        <trans-unit id="6a0552d924c971b406818fb3dc8c14b487a51639" translate="yes" xml:space="preserve">
          <source>If the variable is referenced in inline assembly, the type of access must be provided to the compiler via constraints (see &lt;a href=&quot;constraints#Constraints&quot;&gt;Constraints&lt;/a&gt;). Accesses from basic asms are not supported.</source>
          <target state="translated">如果在内联汇编中引用了变量，则必须通过约束向编译器提供访问类型（请参见&lt;a href=&quot;constraints#Constraints&quot;&gt;Constraints&lt;/a&gt;）。不支持从基本asms访问。</target>
        </trans-unit>
        <trans-unit id="710a7177647056e46d73c6a14fa58cb0a4d39cb4" translate="yes" xml:space="preserve">
          <source>If there are no output operands but there are input operands, place two consecutive colons where the output operands would go:</source>
          <target state="translated">如果没有输出操作数,但有输入操作数,则将两个连续的冒号放在输出操作数的位置。</target>
        </trans-unit>
        <trans-unit id="ba1e7edd0bd3070d7470d6998361492b87d52104" translate="yes" xml:space="preserve">
          <source>If there is no pattern or mechanism to provide a lock-free instruction sequence, a call is made to an external routine with the same parameters to be resolved at run time.</source>
          <target state="translated">如果没有提供无锁指令序列的模式或机制,则调用外部例程,在运行时用相同的参数进行解析。</target>
        </trans-unit>
        <trans-unit id="76caf5beb996fc90102a47daa7e154a5cb406f3a" translate="yes" xml:space="preserve">
          <source>If these options are provided the S/390 back end emits additional instructions in the function prologue that trigger a trap if the stack size is &lt;var&gt;stack-guard&lt;/var&gt; bytes above the &lt;var&gt;stack-size&lt;/var&gt; (remember that the stack on S/390 grows downward). If the &lt;var&gt;stack-guard&lt;/var&gt; option is omitted the smallest power of 2 larger than the frame size of the compiled function is chosen. These options are intended to be used to help debugging stack overflow problems. The additionally emitted code causes only little overhead and hence can also be used in production-like systems without greater performance degradation. The given values have to be exact powers of 2 and &lt;var&gt;stack-size&lt;/var&gt; has to be greater than &lt;var&gt;stack-guard&lt;/var&gt; without exceeding 64k. In order to be efficient the extra code makes the assumption that the stack starts at an address aligned to the value given by &lt;var&gt;stack-size&lt;/var&gt;. The &lt;var&gt;stack-guard&lt;/var&gt; option can only be used in conjunction with &lt;var&gt;stack-size&lt;/var&gt;.</source>
          <target state="translated">如果提供这些选项的S / 390的后端射出在于触发如果堆栈尺寸是一个陷阱函数序言附加指令 &lt;var&gt;stack-guard&lt;/var&gt; 上述字节 &lt;var&gt;stack-size&lt;/var&gt; （记住，在S / 390的堆栈向下增长）。如果省略了 &lt;var&gt;stack-guard&lt;/var&gt; 选项，则选择比已编译函数的帧大小大2的最小幂。这些选项旨在用于帮助调试堆栈溢出问题。额外发出的代码仅引起很少的开销，因此也可以在类似生产的系统中使用，而不会造成更大的性能下降。给定的值必须是2的精确幂，并且 &lt;var&gt;stack-size&lt;/var&gt; 必须大于 &lt;var&gt;stack-guard&lt;/var&gt; 不超过64k。为了提高效率，额外的代码假设堆栈从与 &lt;var&gt;stack-size&lt;/var&gt; 给定值对齐的地址开始。所述 &lt;var&gt;stack-guard&lt;/var&gt; 选项只能在配合使用 &lt;var&gt;stack-size&lt;/var&gt; 。</target>
        </trans-unit>
        <trans-unit id="a905ee4ba472cb30116f3f77a848f112c04b6376" translate="yes" xml:space="preserve">
          <source>If this happens, you should recompile your code with</source>
          <target state="translated">如果发生这种情况,你应该用以下方法重新编译你的代码</target>
        </trans-unit>
        <trans-unit id="53d537c555f3b94f5d31bf2fb2f1a8bc63f88e46" translate="yes" xml:space="preserve">
          <source>If this is option is provided then the stack depth will be printed for each run of events within</source>
          <target state="translated">如果提供了这个选项,那么堆栈深度将被打印出来,用于在</target>
        </trans-unit>
        <trans-unit id="1cc1d69b5f6b24d749c4393c1e5384e6327ba002" translate="yes" xml:space="preserve">
          <source>If this option appears multiple times in the command line with different values specified, &amp;lsquo;</source>
          <target state="translated">如果此选项在命令行中多次出现且指定了不同的值，则&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="7d789a669772c260255b8f486a50720c5dbf98e3" translate="yes" xml:space="preserve">
          <source>If this option is disabled, the compiler uses the most efficient instruction. In the previous example, that might be a 32-bit load instruction, even though that accesses bytes that do not contain any portion of the bit-field, or memory-mapped registers unrelated to the one being updated.</source>
          <target state="translated">如果禁用这个选项,编译器就会使用效率最高的指令。在前面的例子中,这可能是一条32位的加载指令,尽管它访问的字节不包含位场的任何部分,或与被更新的寄存器无关的内存映射寄存器。</target>
        </trans-unit>
        <trans-unit id="eaaa3704bd89671f3908d72dc5973515cc911101" translate="yes" xml:space="preserve">
          <source>If this option is enabled, the compiler tries to avoid unnecessarily overaligning functions. It attempts to instruct the assembler to align by the amount specified by</source>
          <target state="translated">如果启用这个选项,编译器就会尝试避免不必要的过度对齐函数。它试图指示汇编器按照由</target>
        </trans-unit>
        <trans-unit id="7074bcc3f488dbf4492fda0d639c0f8273ca6d14" translate="yes" xml:space="preserve">
          <source>If this option is not provided but</source>
          <target state="translated">如果没有提供这一选项,但</target>
        </trans-unit>
        <trans-unit id="b89db9dde06a530a5dff7a4661614320224ef048" translate="yes" xml:space="preserve">
          <source>If this option is not used, the single-core application programming model is used.</source>
          <target state="translated">如果不使用该选项,则使用单核应用编程模型。</target>
        </trans-unit>
        <trans-unit id="58f2a7b1d53a81872af6e83acac9efe5419c83d5" translate="yes" xml:space="preserve">
          <source>If this option is set it also selects the type of hardware multiply support to use, unless this is overridden by an explicit</source>
          <target state="translated">如果设置了这个选项,它也会选择要使用的硬件乘法支持类型,除非这个选项被显式的</target>
        </trans-unit>
        <trans-unit id="8f5657470cc0e8b94374de4f09052f6ad27d3937" translate="yes" xml:space="preserve">
          <source>If this option is used, the compiler warns for declarations of variable-length arrays whose size is either unbounded, or bounded by an argument that allows the array size to exceed &lt;var&gt;byte-size&lt;/var&gt; bytes. This is similar to how</source>
          <target state="translated">如果使用此选项，则编译器会警告您声明变长数组，其大小可以是无界的，也可以由允许数组大小超过 &lt;var&gt;byte-size&lt;/var&gt; 字节的参数限制。这类似于</target>
        </trans-unit>
        <trans-unit id="13cec7c0becaf2d393aabd05cb427709a6c05830" translate="yes" xml:space="preserve">
          <source>If this option is used, the compiler will warn for declarations of variable-length arrays whose size is either unbounded, or bounded by an argument that allows the array size to exceed &lt;var&gt;byte-size&lt;/var&gt; bytes. This is similar to how</source>
          <target state="translated">如果使用此选项，则编译器将警告声明长度可变的数组，该数组的大小不受限制，或者由允许数组大小超过 &lt;var&gt;byte-size&lt;/var&gt; 字节的参数限制。这类似于</target>
        </trans-unit>
        <trans-unit id="c3115ee12356444486b8dfe277e34da87b4c9653" translate="yes" xml:space="preserve">
          <source>If this variable is set, its value specifies a UNIX timestamp to be used in replacement of the current date and time in the &lt;code&gt;__DATE__&lt;/code&gt; and &lt;code&gt;__TIME__&lt;/code&gt; macros, so that the embedded timestamps become reproducible.</source>
          <target state="translated">如果设置了此变量，则其值指定一个UNIX时间戳，用于替换 &lt;code&gt;__DATE__&lt;/code&gt; 和 &lt;code&gt;__TIME__&lt;/code&gt; 宏中的当前日期和时间，以便嵌入的时间戳可重现。</target>
        </trans-unit>
        <trans-unit id="9e2fd261f951c508769059b9f0362dce31b86177" translate="yes" xml:space="preserve">
          <source>If this variable is set, its value specifies how to output dependencies for Make based on the non-system header files processed by the compiler. System header files are ignored in the dependency output.</source>
          <target state="translated">如果设置了这个变量,它的值会指定如何根据编译器处理的非系统头文件来输出Make的依赖关系。系统头文件在依赖关系输出中会被忽略。</target>
        </trans-unit>
        <trans-unit id="a402efdff3876f11c94bdea172224e741634fd39" translate="yes" xml:space="preserve">
          <source>If used for a function, print the PLT suffix and generate PIC code. For example, emit &lt;code&gt;foo@PLT&lt;/code&gt; instead of &amp;rsquo;foo&amp;rsquo; for the function foo(). If used for a constant, drop all syntax-specific prefixes and issue the bare constant. See &lt;code&gt;p&lt;/code&gt; above.</source>
          <target state="translated">如果用于功能，请打印PLT后缀并生成PIC代码。例如，为函数foo（）发出 &lt;code&gt;foo@PLT&lt;/code&gt; 而不是'foo'。如果用于常量，则删除所有特定于语法的前缀并发出裸常量。参见上面的 &lt;code&gt;p&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0aee4afea693faf480212e1e7dfd95c798d52751" translate="yes" xml:space="preserve">
          <source>If you are invoking the preprocessor from a shell or shell-like program you may need to use the shell&amp;rsquo;s quoting syntax to protect characters such as spaces that have a meaning in the shell syntax.</source>
          <target state="translated">如果要从Shell或类似Shell的程序中调用预处理器，则可能需要使用Shell的引号语法来保护字符（例如在Shell语法中具有含义的空格）。</target>
        </trans-unit>
        <trans-unit id="12dd6be4f44a03f04923a3d7c38a665528824bfc" translate="yes" xml:space="preserve">
          <source>If you are not using a linker with plugin support and/or do not enable the linker plugin, then the objects inside</source>
          <target state="translated">如果你没有使用支持插件的链接器和/或没有启用链接器插件,那么在</target>
        </trans-unit>
        <trans-unit id="dadbd9ac438963390bc7bff3cc4c1fa602dc81f8" translate="yes" xml:space="preserve">
          <source>If you are not using some other optimization option, consider using</source>
          <target state="translated">如果您没有使用其他优化选项,可以考虑使用</target>
        </trans-unit>
        <trans-unit id="c0c121f354142152248081fdee3df09a5e0cff31" translate="yes" xml:space="preserve">
          <source>If you are using Cfront-model code, you can probably get away with not using</source>
          <target state="translated">如果你使用的是Cfront-model代码,你可能可以不使用</target>
        </trans-unit>
        <trans-unit id="670c5a80eac2c68f98a0b7952c25d85ec989c07c" translate="yes" xml:space="preserve">
          <source>If you are using a &amp;ldquo;Foundation&amp;rdquo; library such as GNUstep-Base, this library will provide you with a rich set of functionality to do most of the inspection tasks, and you probably will only need direct access to the GNU Objective-C runtime API to define new classes or methods.</source>
          <target state="translated">如果您使用的是诸如GNUstep-Base之类的&amp;ldquo;基础&amp;rdquo;库，则该库将为您提供丰富的功能集来执行大多数检查任务，并且您可能可能仅需要直接访问GNU Objective-C运行时API。定义新的类或方法。</target>
        </trans-unit>
        <trans-unit id="f60cfeeeec61609632220d7b04102d2cfb0874a6" translate="yes" xml:space="preserve">
          <source>If you are writing a header file that must work when included in ISO C programs, write &lt;code&gt;__typeof__&lt;/code&gt; instead of &lt;code&gt;typeof&lt;/code&gt;. See &lt;a href=&quot;alternate-keywords#Alternate-Keywords&quot;&gt;Alternate Keywords&lt;/a&gt;.</source>
          <target state="translated">如果要编写的标头文件必须包含在ISO C程序中才能工作，请编写 &lt;code&gt;__typeof__&lt;/code&gt; 而不是 &lt;code&gt;typeof&lt;/code&gt; 。请参阅&lt;a href=&quot;alternate-keywords#Alternate-Keywords&quot;&gt;备用关键字&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="047e86cc1cc9d18346ee9ad5f63aecd5602b5f99" translate="yes" xml:space="preserve">
          <source>If you are writing a header file to be included in ISO C90 programs, write &lt;code&gt;__inline__&lt;/code&gt; instead of &lt;code&gt;inline&lt;/code&gt;. See &lt;a href=&quot;alternate-keywords#Alternate-Keywords&quot;&gt;Alternate Keywords&lt;/a&gt;.</source>
          <target state="translated">如果要编写要包含在ISO C90程序中的头文件，请编写 &lt;code&gt;__inline__&lt;/code&gt; 而不是 &lt;code&gt;inline&lt;/code&gt; 。请参阅&lt;a href=&quot;alternate-keywords#Alternate-Keywords&quot;&gt;备用关键字&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="dbd2d15a4f5e85df131685d7eb92f6861e37e279" translate="yes" xml:space="preserve">
          <source>If you care about controlling the amount of memory that is accessed, use volatile but do not use bit-fields.</source>
          <target state="translated">如果你关心控制访问内存的数量,请使用易失性,但不要使用位字段。</target>
        </trans-unit>
        <trans-unit id="0103e1abfe788f8d50e7fc73d958416e72e0b9c1" translate="yes" xml:space="preserve">
          <source>If you compile a module &lt;var&gt;Mod&lt;/var&gt; with</source>
          <target state="translated">如果您编译模块 &lt;var&gt;Mod&lt;/var&gt; 与</target>
        </trans-unit>
        <trans-unit id="47d85eced409c6f6fef0defc52869795ed0b0f14" translate="yes" xml:space="preserve">
          <source>If you define a class in a header file marked with &amp;lsquo;</source>
          <target state="translated">如果您在标有&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="8af3483bb66c1cf78841141fb90f1ef9efc295a7" translate="yes" xml:space="preserve">
          <source>If you do not specify an optimization level option</source>
          <target state="translated">如果您没有指定优化级别选项</target>
        </trans-unit>
        <trans-unit id="0524dbf059780b836548e3795cd65f22c493bbb4" translate="yes" xml:space="preserve">
          <source>If you do use differing options when generating and using the precompiled header, the actual behavior is a mixture of the behavior for the options. For instance, if you use</source>
          <target state="translated">如果您在生成和使用预编译头时使用了不同的选项,那么实际的行为就是这些选项的混合行为。例如,如果您使用</target>
        </trans-unit>
        <trans-unit id="6615402a003808b60f77e922f8fff7dc102cea3e" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t know the type of the operand, you can still do this, but you must use &lt;code&gt;typeof&lt;/code&gt; or &lt;code&gt;__auto_type&lt;/code&gt; (see &lt;a href=&quot;typeof#Typeof&quot;&gt;Typeof&lt;/a&gt;).</source>
          <target state="translated">如果您不知道操作数的类型，仍然可以执行此操作，但是必须使用 &lt;code&gt;typeof&lt;/code&gt; 或 &lt;code&gt;__auto_type&lt;/code&gt; （请参见&lt;a href=&quot;typeof#Typeof&quot;&gt;Typeof&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="c085ab8b04d2de8c46788dc7f554d15750ff8940" translate="yes" xml:space="preserve">
          <source>If you have trouble using GCC.</source>
          <target state="translated">如果你在使用GCC时遇到困难。</target>
        </trans-unit>
        <trans-unit id="4152886dce97a4266954e0590ef45338d28d4f3b" translate="yes" xml:space="preserve">
          <source>If you invoke &lt;code&gt;gcov&lt;/code&gt; with multiple input files, the contributions from each input file are summed. Typically you would invoke it with the same list of files as the final link of your executable.</source>
          <target state="translated">如果您使用多个输入文件调用 &lt;code&gt;gcov&lt;/code&gt; ，则将每个输入文件的贡献求和。通常，您将使用与可执行文件的最终链接相同的文件列表来调用它。</target>
        </trans-unit>
        <trans-unit id="f78ebb50b8c8401143c21ca977cd992331a9d441" translate="yes" xml:space="preserve">
          <source>If you invoke GCC in parallel, compiling several different source files that share a common base name in different subdirectories or the same source file compiled for multiple output destinations, it is likely that the different parallel compilers will interfere with each other, and overwrite the temporary files. For instance:</source>
          <target state="translated">如果并行调用GCC,在不同的子目录下编译多个共用基名的不同源文件,或者为多个输出目的地编译同一个源文件,很可能会出现不同的并行编译器相互干扰,覆盖临时文件的情况。比如说</target>
        </trans-unit>
        <trans-unit id="339873ba9c437ffb773ea97b43d76bef2cd414b1" translate="yes" xml:space="preserve">
          <source>If you know the above will only be reading a ten byte array then you could instead use a memory input like: &lt;code&gt;&quot;m&quot; (*(const char (*)[10]) p)&lt;/code&gt;.</source>
          <target state="translated">如果您知道上述内容只会读取一个十字节的数组，则可以改用内存输入，例如： &lt;code&gt;&quot;m&quot; (*(const char (*)[10]) p)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="888965c4f3b549f1f0054a0f4c6ff67115a7146e" translate="yes" xml:space="preserve">
          <source>If you need a Standard compliant library, then you need to find one, as GCC does not provide one. The GNU C library (called &lt;code&gt;glibc&lt;/code&gt;) provides ISO C, POSIX, BSD, SystemV and X/Open compatibility for GNU/Linux and HURD-based GNU systems; no recent version of it supports other systems, though some very old versions did. Version 2.2 of the GNU C library includes nearly complete C99 support. You could also ask your operating system vendor if newer libraries are available.</source>
          <target state="translated">如果您需要符合标准的库，则需要查找一个库，因为GCC不提供该库。GNU C库（称为 &lt;code&gt;glibc&lt;/code&gt; ）为GNU / Linux和基于HURD的GNU系统提供了ISO C，POSIX，BSD，SystemV和X / Open兼容性。它的最新版本不支持其他系统，尽管有些非常旧的版本支持。GNU C库的2.2版包括几乎完整的C99支持。您还可以询问操作系统供应商是否提供了更新的库。</target>
        </trans-unit>
        <trans-unit id="2295b8a8afca796af761f37955429fb2dfb303ab" translate="yes" xml:space="preserve">
          <source>If you need to precompile the same header file for different languages, targets, or compiler options, you can instead make a &lt;em&gt;directory&lt;/em&gt; named like</source>
          <target state="translated">如果需要针对不同的语言，目标或编译器选项预编译相同的头文件，则可以改成名为like 的&lt;em&gt;目录&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="66af9e4f8d685ec9e9b50745c5edb5982da51a9b" translate="yes" xml:space="preserve">
          <source>If you need to read the volatile object after an assignment has occurred, you must use a separate expression with an intervening sequence point.</source>
          <target state="translated">如果需要在赋值发生后读取易失性对象,必须使用一个单独的表达式,中间有一个序列点。</target>
        </trans-unit>
        <trans-unit id="4adf572d889db0dbe74d88ef8bb1d09b3f0a1cca" translate="yes" xml:space="preserve">
          <source>If you only want some of the stages of compilation, you can use</source>
          <target state="translated">如果你只想要编译的一些阶段,你可以使用</target>
        </trans-unit>
        <trans-unit id="0a3a127b379e27c78040de67c2f4f38df68d44ac" translate="yes" xml:space="preserve">
          <source>If you plan to use &lt;code&gt;gcov&lt;/code&gt; to help optimize your code, you must first compile your program with a special GCC option &amp;lsquo;</source>
          <target state="translated">如果您打算使用 &lt;code&gt;gcov&lt;/code&gt; 来帮助优化代码，则必须首先使用特殊的GCC选项&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="89a00b1663443b615a5e906a67310faf3ab9d3e4" translate="yes" xml:space="preserve">
          <source>If you receive a linker error message that saying you have overflowed the available TOC space, you can reduce the amount of TOC space used with the</source>
          <target state="translated">如果你收到一个链接器错误信息,说你已经溢出了可用的TOC空间,你可以通过使用</target>
        </trans-unit>
        <trans-unit id="be0941cee2405a3cef991d81a7e61b7d98631fbb" translate="yes" xml:space="preserve">
          <source>If you replaced &lt;code&gt;short_a&lt;/code&gt; with &lt;code&gt;short&lt;/code&gt; in the variable declaration, the above program would abort when compiled with</source>
          <target state="translated">如果在变量声明 &lt;code&gt;short_a&lt;/code&gt; 替换为 &lt;code&gt;short&lt;/code&gt; ，则使用以下命令编译时上述程序将中止</target>
        </trans-unit>
        <trans-unit id="35d1d8ed39d0b8c7b146243c81d4152cdc148fcf" translate="yes" xml:space="preserve">
          <source>If you specify &amp;lsquo;</source>
          <target state="translated">如果您指定&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="4ecc2b870bc1bb7d3b980a000c9f6dcec5995fb9" translate="yes" xml:space="preserve">
          <source>If you specify both &lt;code&gt;inline&lt;/code&gt; and &lt;code&gt;extern&lt;/code&gt; in the function definition, then the definition is used only for inlining. In no case is the function compiled on its own, not even if you refer to its address explicitly. Such an address becomes an external reference, as if you had only declared the function, and had not defined it.</source>
          <target state="translated">如果在函数定义中同时指定 &lt;code&gt;inline&lt;/code&gt; 和 &lt;code&gt;extern&lt;/code&gt; ，则该定义仅用于内联。在任何情况下，即使您显式引用其地址，该函数也不会自行编译。这样的地址将成为一个外部引用，就好像您仅声明了该函数而未定义它一样。</target>
        </trans-unit>
        <trans-unit id="5d47cb731371550330a13465931e86c5d293dfdf" translate="yes" xml:space="preserve">
          <source>If you specify command-line switches such as</source>
          <target state="translated">如果你指定命令行开关,如</target>
        </trans-unit>
        <trans-unit id="6dac1f1fb59b9ffca6f761fa60561e481b2e6270" translate="yes" xml:space="preserve">
          <source>If you specify neither</source>
          <target state="translated">如果您既没有指定</target>
        </trans-unit>
        <trans-unit id="6cae6e383580c515521bd2b40fbda23cacc80529" translate="yes" xml:space="preserve">
          <source>If you specify the optional &lt;var&gt;n&lt;/var&gt;, the optimization and code generation done at link time is executed in parallel using &lt;var&gt;n&lt;/var&gt; parallel jobs by utilizing an installed &lt;code&gt;make&lt;/code&gt; program. The environment variable &lt;code&gt;MAKE&lt;/code&gt; may be used to override the program used.</source>
          <target state="translated">如果指定了可选的 &lt;var&gt;n&lt;/var&gt; ，则通过使用已安装的 &lt;code&gt;make&lt;/code&gt; 程序，使用 &lt;var&gt;n&lt;/var&gt; 个并行作业并行执行链接时完成的优化和代码生成。环境变量 &lt;code&gt;MAKE&lt;/code&gt; 可用于覆盖所使用的程序。</target>
        </trans-unit>
        <trans-unit id="c921e7f4f95a0df5eb637ba56c7aabab978aaee6" translate="yes" xml:space="preserve">
          <source>If you specify the optional &lt;var&gt;n&lt;/var&gt;, the optimization and code generation done at link time is executed in parallel using &lt;var&gt;n&lt;/var&gt; parallel jobs by utilizing an installed &lt;code&gt;make&lt;/code&gt; program. The environment variable &lt;code&gt;MAKE&lt;/code&gt; may be used to override the program used. The default value for &lt;var&gt;n&lt;/var&gt; is 1.</source>
          <target state="translated">如果指定了可选的 &lt;var&gt;n&lt;/var&gt; ，则通过使用已安装的 &lt;code&gt;make&lt;/code&gt; 程序，使用 &lt;var&gt;n&lt;/var&gt; 个并行作业并行执行链接时完成的优化和代码生成。环境变量 &lt;code&gt;MAKE&lt;/code&gt; 可用于覆盖所使用的程序。 &lt;var&gt;n&lt;/var&gt; 的默认值为1。</target>
        </trans-unit>
        <trans-unit id="925aa9cac99e94c7e1b3007e94e2857fd742f461" translate="yes" xml:space="preserve">
          <source>If you still run out of space in the TOC even when you specify both of these options, specify</source>
          <target state="translated">如果您指定了这两个选项后,TOC中的空间仍然不够用,请指定</target>
        </trans-unit>
        <trans-unit id="e9f3b7bcc19fa8799f793151f5d918c0eb44cc5c" translate="yes" xml:space="preserve">
          <source>If you try to call the nested function through its address after the containing function exits, all hell breaks loose. If you try to call it after a containing scope level exits, and if it refers to some of the variables that are no longer in scope, you may be lucky, but it&amp;rsquo;s not wise to take the risk. If, however, the nested function does not refer to anything that has gone out of scope, you should be safe.</source>
          <target state="translated">如果您尝试在包含函数退出后通过其地址调用嵌套函数，那么所有地狱都会变得松散。如果您尝试在包含作用域级别退出之后调用它，并且如果它引用了不再在作用域中的某些变量，则可能很幸运，但是冒险是不明智的。但是，如果嵌套函数未引用超出范围的任何内容，那么您应该是安全的。</target>
        </trans-unit>
        <trans-unit id="f927a3385a1b1e51d949287257534f3a4443c5fc" translate="yes" xml:space="preserve">
          <source>If you update the system&amp;rsquo;s header files, such as by installing a new system version, the fixed header files of GCC are not automatically updated. They can be updated using the &lt;code&gt;mkheaders&lt;/code&gt; script installed in</source>
          <target state="translated">如果您更新系统的头文件（例如通过安装新的系统版本），则GCC的固定头文件不会自动更新。可以使用安装在以下位置的 &lt;code&gt;mkheaders&lt;/code&gt; 脚本来更新它们</target>
        </trans-unit>
        <trans-unit id="41fb10bf832524090b9ab05176d0ed5567a508f5" translate="yes" xml:space="preserve">
          <source>If you use</source>
          <target state="translated">如果您使用</target>
        </trans-unit>
        <trans-unit id="6a51a2c7443f8a2b859ded2344689b9dd5a96d35" translate="yes" xml:space="preserve">
          <source>If you use &amp;lsquo;</source>
          <target state="translated">如果您使用&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="1eb60252a45f0973d8c5683aecd8b85683d307d3" translate="yes" xml:space="preserve">
          <source>If you use both this option and the</source>
          <target state="translated">如果您同时使用该选项和</target>
        </trans-unit>
        <trans-unit id="daf14f5a30ee5ca1525b7be167b116e92944e7ce" translate="yes" xml:space="preserve">
          <source>If you use multiple</source>
          <target state="translated">如果您使用多个</target>
        </trans-unit>
        <trans-unit id="9b9352d7bdc60d6db5e3f97a4150de5fffc4de3b" translate="yes" xml:space="preserve">
          <source>If you use one big file to do the instantiations, you may want to compile it without</source>
          <target state="translated">如果你用一个大文件来做实例化,你可能想在编译时不使用</target>
        </trans-unit>
        <trans-unit id="d5658f3cda5684fd922808fa10e4319b5a492e30" translate="yes" xml:space="preserve">
          <source>If you use one of the &lt;code&gt;__flash&lt;var&gt;N&lt;/var&gt;&lt;/code&gt; address spaces you must arrange your linker script to locate the &lt;code&gt;.progmem&lt;var&gt;N&lt;/var&gt;.data&lt;/code&gt; sections according to your needs.</source>
          <target state="translated">如果使用 &lt;code&gt;__flash&lt;var&gt;N&lt;/var&gt;&lt;/code&gt; 地址空间之一，则必须根据需要安排链接描述文件以找到 &lt;code&gt;.progmem&lt;var&gt;N&lt;/var&gt;.data&lt;/code&gt; 节。</target>
        </trans-unit>
        <trans-unit id="d09fff5b63f8a00b0aa50a2fbc9e05727d5eaa55" translate="yes" xml:space="preserve">
          <source>If you use the</source>
          <target state="translated">如果您使用</target>
        </trans-unit>
        <trans-unit id="0c2eabb891cc235e2e02c3ade4b4c6be5a7c7761" translate="yes" xml:space="preserve">
          <source>If you use the &lt;code&gt;inline&lt;/code&gt; qualifier, then for inlining purposes the size of the &lt;code&gt;asm&lt;/code&gt; statement is taken as the smallest size possible (see &lt;a href=&quot;size-of-an-asm#Size-of-an-asm&quot;&gt;Size of an asm&lt;/a&gt;).</source>
          <target state="translated">如果使用 &lt;code&gt;inline&lt;/code&gt; 限定符，则出于内联目的，将 &lt;code&gt;asm&lt;/code&gt; 语句的大小视为可能的最小大小（请参见&lt;a href=&quot;size-of-an-asm#Size-of-an-asm&quot;&gt;asm的大小&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="1d0a1d145962ca52d117f00e82a8a34efa685f04" translate="yes" xml:space="preserve">
          <source>If you use the ISA 3.0 instruction set (</source>
          <target state="translated">如果您使用ISA 3.0指令集(</target>
        </trans-unit>
        <trans-unit id="3b409b718d6983a24e16eccb9909125cc43f2697" translate="yes" xml:space="preserve">
          <source>If you want to pass an option that takes a separate argument, you must use</source>
          <target state="translated">如果你想传递一个需要单独参数的选项,你必须使用</target>
        </trans-unit>
        <trans-unit id="01e57dac3d1293541430d1619103f3be6de91e09" translate="yes" xml:space="preserve">
          <source>If you want to pass an option that takes an argument, you must use</source>
          <target state="translated">如果你想传递一个接受参数的选项,你必须使用</target>
        </trans-unit>
        <trans-unit id="57c0d52053735b1deca65f8fe95302a40e91aba4" translate="yes" xml:space="preserve">
          <source>If you want to pass the array first and the length afterward, you can use a forward declaration in the parameter list&amp;mdash;another GNU extension.</source>
          <target state="translated">如果要先传递数组，然后传递长度，则可以在参数列表中使用前向声明（另一个GNU扩展）。</target>
        </trans-unit>
        <trans-unit id="714721fbe0a57745166a774e2ee80658db42639e" translate="yes" xml:space="preserve">
          <source>If you want to recompile source files that do not actually use your global register variable so they do not use the specified register for any other purpose, you need not actually add the global register declaration to their source code. It suffices to specify the compiler option</source>
          <target state="translated">如果你想重新编译那些没有实际使用全局寄存器变量的源文件,使它们不为任何其他目的使用指定的寄存器,你实际上不需要在它们的源代码中添加全局寄存器声明。只需指定编译器选项</target>
        </trans-unit>
        <trans-unit id="63035fe8f0fef33a809f5df21a239bff0f434564" translate="yes" xml:space="preserve">
          <source>If you want to warn about code that uses the uninitialized value of the variable in its own initializer, use the</source>
          <target state="translated">如果你想警告那些在自己的初始化器中使用未初始化的变量值的代码,可以使用</target>
        </trans-unit>
        <trans-unit id="1f9d39a0d621d29f6b4df2f19650e527eb6087e6" translate="yes" xml:space="preserve">
          <source>If you want your own collection object to be usable with fast enumeration, you need to have it implement the method</source>
          <target state="translated">如果你想让你自己的集合对象可以使用快速枚举,你需要让它实现方法</target>
        </trans-unit>
        <trans-unit id="66ce7bf0d3f3a0ea10a8e8123399a75d9055c922" translate="yes" xml:space="preserve">
          <source>If you wish to define a function-like macro on the command line, write its argument list with surrounding parentheses before the equals sign (if any). Parentheses are meaningful to most shells, so you should quote the option. With &lt;code&gt;sh&lt;/code&gt; and &lt;code&gt;csh&lt;/code&gt;,</source>
          <target state="translated">如果要在命令行上定义类似函数的宏，请在等号之前（如果有的话）在参数列表中加上括号。括号对大多数shell有意义，因此您应该引用该选项。使用 &lt;code&gt;sh&lt;/code&gt; 和 &lt;code&gt;csh&lt;/code&gt; ，</target>
        </trans-unit>
        <trans-unit id="344eca13d4f5455ce9ed14a9174152844b040aa2" translate="yes" xml:space="preserve">
          <source>If your code needs to support multiple assembler dialects (for example, if you are writing public headers that need to support a variety of compilation options), use constructs of this form:</source>
          <target state="translated">如果你的代码需要支持多种汇编器方言(例如,如果你编写的公有头文件需要支持多种编译选项),请使用这种形式的构造。</target>
        </trans-unit>
        <trans-unit id="489624b43d62801c5096e0cef6c84a4128aa3f2e" translate="yes" xml:space="preserve">
          <source>If, for some reason, you want to include letter &amp;lsquo;</source>
          <target state="translated">如果出于某种原因要添加字母&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="8ae25dcd1480cd59f0776f409a8f3b4cc8c76dee" translate="yes" xml:space="preserve">
          <source>If, instead, you use the GCC driver to create shared libraries, you may find that they are not always linked with the shared</source>
          <target state="translated">如果您使用GCC驱动程序来创建共享库,您可能会发现它们并不总是与共享的</target>
        </trans-unit>
        <trans-unit id="7d34e1e1ae89800680b004320ebb086b09cf39f6" translate="yes" xml:space="preserve">
          <source>Ignore the &lt;code&gt;#ident&lt;/code&gt; directive.</source>
          <target state="translated">忽略 &lt;code&gt;#ident&lt;/code&gt; 指令。</target>
        </trans-unit>
        <trans-unit id="2e82df27ea7fceb83aac6e28c3926e8f714c2de0" translate="yes" xml:space="preserve">
          <source>Immediate 15-bit unsigned integer</source>
          <target state="translated">即时15位无符号整数</target>
        </trans-unit>
        <trans-unit id="25ebf6700b63624d3804d20faa7de74e2dccc87c" translate="yes" xml:space="preserve">
          <source>Immediate 16-bit signed integer</source>
          <target state="translated">即时16位有符号整数</target>
        </trans-unit>
        <trans-unit id="c2ce26e27211c1d69d3a406bee1c55a3cfc3b488" translate="yes" xml:space="preserve">
          <source>Immediate 32-bit integer in range -16..4294967295 (i.e. 32-bit unsigned integer or &amp;lsquo;</source>
          <target state="translated">范围-16..4294967295的直接32位整数（即32位无符号整数或'</target>
        </trans-unit>
        <trans-unit id="7ce04d3df5932775f166ab61ebe67634f6cff4f5" translate="yes" xml:space="preserve">
          <source>Immediate 32-bit signed integer that can be attached to an instruction encoding</source>
          <target state="translated">即时32位有符号的整数,可以附加到指令编码中。</target>
        </trans-unit>
        <trans-unit id="95af07c0237447c6b15292985f8e2b14ec413d35" translate="yes" xml:space="preserve">
          <source>Immediate 64-bit constant that can be split into two &amp;lsquo;</source>
          <target state="translated">直接的64位常量，可以分为两个'</target>
        </trans-unit>
        <trans-unit id="aea4f97beb4642aabcdf84f409c00fa5cd5c2c91" translate="yes" xml:space="preserve">
          <source>Immediate constant -1</source>
          <target state="translated">即时常数-1</target>
        </trans-unit>
        <trans-unit id="293172a51e9ef5dbf0bb7e7f454796275cc1f905" translate="yes" xml:space="preserve">
          <source>Immediate constant that can be inlined in an instruction encoding: integer -16..64, or float 0.0, +/-0.5, +/-1.0, +/-2.0, +/-4.0, 1.0/(2.0*PI)</source>
          <target state="translated">可在指令编码中内联的即时常数:整数-16...64,或浮点数0.0、+/-0.5、+/-1.0、+/-2.0、+/-4.0、1.0/(2.0*PI)</target>
        </trans-unit>
        <trans-unit id="a56a5101429aaf4e851ed409b055e85e8d91d6b8" translate="yes" xml:space="preserve">
          <source>Immediate integer in the range -16 to 64</source>
          <target state="translated">即时整数,范围为-16至64。</target>
        </trans-unit>
        <trans-unit id="bf320f9d296e81a49f73cab866d640531aefcfad" translate="yes" xml:space="preserve">
          <source>Implement (do not implement) -fno-plt and long calls using an inline PLT call sequence that supports lazy linking and long calls to functions in dlopen&amp;rsquo;d shared libraries. Inline PLT calls are only supported on PowerPC64 ELFv2 and 32-bit PowerPC systems with newer GNU linkers, and are enabled by default if the support is detected when configuring GCC, and, in the case of 32-bit PowerPC, if GCC is configured with</source>
          <target state="translated">使用内联PLT调用序列实现（不实现）-fno-plt和长调用，该序列支持延迟链接和对dlopen共享库中函数的长调用。内联PLT调用仅在具有较新GNU链接器的PowerPC64 ELFv2和32位PowerPC系统上受支持，如果在配置GCC时检测到支持，则默认启用内联PLT调用；在32位PowerPC的情况下，如果GCC配置为</target>
        </trans-unit>
        <trans-unit id="f6c8b1a3b3ce20b0f24d10325bb5a9fda3cc0723" translate="yes" xml:space="preserve">
          <source>Implies no inter-thread ordering constraints.</source>
          <target state="translated">意味着没有线程间的排序约束。</target>
        </trans-unit>
        <trans-unit id="fe96af122b5bf84f1ddc818f1e5f57ac3e7dac8c" translate="yes" xml:space="preserve">
          <source>Improved AMD Athlon CPU with MMX, 3DNow!, enhanced 3DNow! and full SSE instruction set support.</source>
          <target state="translated">改进的AMD Athlon CPU,具有MMX、3DNow!、增强的3DNow!和完整的SSE指令集支持。</target>
        </trans-unit>
        <trans-unit id="6774c0ca18d629c919e07781b4bc4345f81613ce" translate="yes" xml:space="preserve">
          <source>Improved support for generic programming.</source>
          <target state="translated">改进对通用方案编制的支持。</target>
        </trans-unit>
        <trans-unit id="bb701b014b08c67fb59b6b752448015c50d54c43" translate="yes" xml:space="preserve">
          <source>Improved version of Intel Pentium 4 CPU with 64-bit extensions, MMX, SSE, SSE2 and SSE3 instruction set support.</source>
          <target state="translated">Intel Pentium 4 CPU的改进版,支持64位扩展、MMX、SSE、SSE2和SSE3指令集。</target>
        </trans-unit>
        <trans-unit id="ed782143dc7e1163d3eb2323e646f10006e40097" translate="yes" xml:space="preserve">
          <source>Improved version of Intel Pentium 4 CPU with MMX, SSE, SSE2 and SSE3 instruction set support.</source>
          <target state="translated">Intel Pentium 4 CPU的改进版,支持MMX、SSE、SSE2和SSE3指令集。</target>
        </trans-unit>
        <trans-unit id="8a73deb51d5b08d19d0486183c731c2e4df58a6c" translate="yes" xml:space="preserve">
          <source>Improved versions of AMD K6 CPU with MMX and 3DNow! instruction set support.</source>
          <target state="translated">改进版AMD K6 CPU,支持MMX和3DNow!指令集。</target>
        </trans-unit>
        <trans-unit id="0640019f239b6c731b94ce729c56eafeb42fbdce" translate="yes" xml:space="preserve">
          <source>Improved versions of AMD K8 cores with SSE3 instruction set support.</source>
          <target state="translated">改进版的AMD K8内核,支持SSE3指令集。</target>
        </trans-unit>
        <trans-unit id="faa77d9eb98f8c3bb3a99e6c2fd6a673c7a1ef4f" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;&amp;lt;stddef.h&amp;gt;&lt;/code&gt;, &lt;code&gt;NULL&lt;/code&gt; expands to &lt;code&gt;((void *)0)&lt;/code&gt;. GCC does not provide the other headers which define &lt;code&gt;NULL&lt;/code&gt; and some library implementations may use other definitions in those headers.</source>
          <target state="translated">在 &lt;code&gt;&amp;lt;stddef.h&amp;gt;&lt;/code&gt; 中， &lt;code&gt;NULL&lt;/code&gt; 扩展为 &lt;code&gt;((void *)0)&lt;/code&gt; 。GCC不提供其他定义 &lt;code&gt;NULL&lt;/code&gt; 的标头，某些库实现可能在这些标头中使用其他定义。</target>
        </trans-unit>
        <trans-unit id="94f792f5735cf258c95fd93f04f6f7c58a83d70b" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;get_i()&lt;/code&gt;, &lt;code&gt;i&lt;/code&gt; is not used in a dependent context, so the compiler will look for a name declared at the enclosing namespace scope (which is the global scope here). It will not look into the base class, since that is dependent and you may declare specializations of &lt;code&gt;Base&lt;/code&gt; even after declaring &lt;code&gt;Derived&lt;/code&gt;, so the compiler cannot really know what &lt;code&gt;i&lt;/code&gt; would refer to. If there is no global variable &lt;code&gt;i&lt;/code&gt;, then you will get an error message.</source>
          <target state="translated">在 &lt;code&gt;get_i()&lt;/code&gt; 中， &lt;code&gt;i&lt;/code&gt; 不在依赖上下文中使用，因此编译器将查找在封闭的名称空间范围（此处为全局范围）中声明的名称。它不会查看基类，因为它是依赖的，即使在声明 &lt;code&gt;Derived&lt;/code&gt; 之后，您也可以声明 &lt;code&gt;Base&lt;/code&gt; 的特化，因此编译器无法真正知道 &lt;code&gt;i&lt;/code&gt; 要指的是什么。如果没有全局变量 &lt;code&gt;i&lt;/code&gt; ，那么您将收到一条错误消息。</target>
        </trans-unit>
        <trans-unit id="1efd435b2fd7ff4eeb1d3caefe51e97ec2eabff1" translate="yes" xml:space="preserve">
          <source>In C code, this option controls the placement of global variables defined without an initializer, known as &lt;em&gt;tentative definitions&lt;/em&gt; in the C standard. Tentative definitions are distinct from declarations of a variable with the &lt;code&gt;extern&lt;/code&gt; keyword, which do not allocate storage.</source>
          <target state="translated">在C代码中，此选项控制在没有初始化程序的情况下定义的全局变量的放置，在C标准中称为&lt;em&gt;临时定义&lt;/em&gt;。临时定义不同于使用 &lt;code&gt;extern&lt;/code&gt; 关键字声明的变量，后者不分配存储空间。</target>
        </trans-unit>
        <trans-unit id="986d71cafa07e6d2f235ac194e79a8e70cb9cccf" translate="yes" xml:space="preserve">
          <source>In C mode, this is equivalent to</source>
          <target state="translated">在C模式下,这相当于</target>
        </trans-unit>
        <trans-unit id="6e29cf5656ff22cce837fe364a063ee35412d5b9" translate="yes" xml:space="preserve">
          <source>In C this option does not warn about the universal zero initializer &amp;lsquo;</source>
          <target state="translated">在C中，此选项不会警告通用零初始化器'</target>
        </trans-unit>
        <trans-unit id="2f3a5ba446573452e29640c8fc16cb4e894d48dc" translate="yes" xml:space="preserve">
          <source>In C++ code, this allows member names in structures to be similar to previous types declarations.</source>
          <target state="translated">在C++代码中,这使得结构中的成员名与之前的类型声明相似。</target>
        </trans-unit>
        <trans-unit id="c8175f71005ecf03750f6f6a8eb8dfe31c736137" translate="yes" xml:space="preserve">
          <source>In C++ the value of an object is only affected by changes within its lifetime: when the constructor begins, the object has an indeterminate value, and any changes during the lifetime of the object are dead when the object is destroyed. Normally dead store elimination will take advantage of this; if your code relies on the value of the object storage persisting beyond the lifetime of the object, you can use this flag to disable this optimization. To preserve stores before the constructor starts (e.g. because your operator new clears the object storage) but still treat the object as dead after the destructor you, can use</source>
          <target state="translated">在C++中,对象的值只受其生命期内的变化影响:当构造函数开始时,对象的值是不确定的,当对象被销毁时,对象生命期内的任何变化都是死的。通常死存储消除会利用这一点;如果你的代码依赖于对象存储的值在对象的生命期之后持久存在,你可以使用这个标志来禁用这个优化。要在构造函数开始之前保留存储(例如,因为你的操作符new清除了对象存储),但在destructor之后仍然将对象视为死存储,你,可以使用</target>
        </trans-unit>
        <trans-unit id="56ef40910d39bd9b38715d5759edee181d6be40d" translate="yes" xml:space="preserve">
          <source>In C++ the value of an object is only affected by changes within its lifetime: when the constructor begins, the object has an indeterminate value, and any changes during the lifetime of the object are dead when the object is destroyed. Normally dead store elimination will take advantage of this; if your code relies on the value of the object storage persisting beyond the lifetime of the object, you can use this flag to disable this optimization. To preserve stores before the constructor starts (e.g. because your operator new clears the object storage) but still treat the object as dead after the destructor, you can use</source>
          <target state="translated">在C++中,对象的值只受其生命期内的变化影响:当构造函数开始时,对象的值是不确定的,当对象被销毁时,对象生命期内的任何变化都是死的。通常死存储消除会利用这一点;如果你的代码依赖于对象存储的值在对象的生命期之后持久存在,你可以使用这个标志来禁用这个优化。要在构造函数启动前保留存储(例如,因为你的操作符new清除了对象存储),但在destructor之后仍然将对象视为死存储,你可以使用</target>
        </trans-unit>
        <trans-unit id="168fb41a49baf3aa442f73f3ecb6a40cd4d6ca59" translate="yes" xml:space="preserve">
          <source>In C++, &amp;lsquo;</source>
          <target state="translated">在C ++中，</target>
        </trans-unit>
        <trans-unit id="1bcce97889f7dbf32fa6b64e8c64b08099b3f7a1" translate="yes" xml:space="preserve">
          <source>In C++, attribute visibility (see &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;Function Attributes&lt;/a&gt;) can also be applied to class, struct, union and enum types. Unlike other type attributes, the attribute must appear between the initial keyword and the name of the type; it cannot appear after the body of the type.</source>
          <target state="translated">在C ++中，属性可见性（请参见&lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;函数属性&lt;/a&gt;）也可以应用于类，结构，联合和枚举类型。与其他类型属性不同，该属性必须出现在初始关键字和类型名称之间；它不能出现在类型的正文之后。</target>
        </trans-unit>
        <trans-unit id="41407820aea4af6aceb3725e14d20bcfa5717ed8" translate="yes" xml:space="preserve">
          <source>In C++, if a template argument has limited visibility, this restriction is implicitly propagated to the template instantiation. Otherwise, template instantiations and specializations default to the visibility of their template.</source>
          <target state="translated">在C++中,如果一个模板参数具有有限的可见性,这个限制会隐式地传播给模板实例化。否则,模板实例化和特殊化会默认为其模板的可见性。</target>
        </trans-unit>
        <trans-unit id="453e27477f405b0f81788514a49ffd79d08ff550" translate="yes" xml:space="preserve">
          <source>In C++, if an initializer is present for a thread-local variable, it must be a &lt;var&gt;constant-expression&lt;/var&gt;, as defined in 5.19.2 of the ANSI/ISO C++ standard.</source>
          <target state="translated">在C ++中，如果存在用于线程局部变量的初始化器，则它必须是ANSI / ISO C ++标准5.19.2中定义的 &lt;var&gt;constant-expression&lt;/var&gt; 。</target>
        </trans-unit>
        <trans-unit id="9e8da9f4a402f87aeb0e1e0768c85b6e521a3ae7" translate="yes" xml:space="preserve">
          <source>In C++, pointer to member functions (PMFs) are implemented using a wide pointer of sorts to handle all the possible call mechanisms; the PMF needs to store information about how to adjust the &amp;lsquo;</source>
          <target state="translated">在C ++中，使用多种指针来实现成员函数（PMF）的指针，以处理所有可能的调用机制。PMF需要存储有关如何调整&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="34a26947af0331ebcf8b3ff5e4127f49a113bd19" translate="yes" xml:space="preserve">
          <source>In C++, the &lt;code&gt;ifunc&lt;/code&gt; attribute takes a string that is the mangled name of the resolver function. A C++ resolver for a non-static member function of class &lt;code&gt;C&lt;/code&gt; should be declared to return a pointer to a non-member function taking pointer to &lt;code&gt;C&lt;/code&gt; as the first argument, followed by the same arguments as of the implementation function. G++ checks the signatures of the two functions and issues a</source>
          <target state="translated">在C ++中， &lt;code&gt;ifunc&lt;/code&gt; 属性采用一个字符串，该字符串是解析器函数的错误名称。应该声明一个用于类 &lt;code&gt;C&lt;/code&gt; 的非静态成员函数的C ++解析器，以返回指向非成员函数的指针，该指针以指向 &lt;code&gt;C&lt;/code&gt; 的指针作为第一个参数，后跟与实现函数相同的参数。G ++检查两个函数的签名并发出</target>
        </trans-unit>
        <trans-unit id="dae3c25a08855a03a679edfb667679b322123fbc" translate="yes" xml:space="preserve">
          <source>In C++, the logic operators &lt;code&gt;!, &amp;amp;&amp;amp;, ||&lt;/code&gt; are available for vectors. &lt;code&gt;!v&lt;/code&gt; is equivalent to &lt;code&gt;v == 0&lt;/code&gt;, &lt;code&gt;a &amp;amp;&amp;amp; b&lt;/code&gt; is equivalent to &lt;code&gt;a!=0 &amp;amp; b!=0&lt;/code&gt; and &lt;code&gt;a || b&lt;/code&gt; is equivalent to &lt;code&gt;a!=0 | b!=0&lt;/code&gt;. For mixed operations between a scalar &lt;code&gt;s&lt;/code&gt; and a vector &lt;code&gt;v&lt;/code&gt;, &lt;code&gt;s &amp;amp;&amp;amp; v&lt;/code&gt; is equivalent to &lt;code&gt;s?v!=0:0&lt;/code&gt; (the evaluation is short-circuit) and &lt;code&gt;v &amp;amp;&amp;amp; s&lt;/code&gt; is equivalent to &lt;code&gt;v!=0 &amp;amp; (s?-1:0)&lt;/code&gt;.</source>
          <target state="translated">在C ++中，逻辑运算符 &lt;code&gt;!, &amp;amp;&amp;amp;, ||&lt;/code&gt; 可用于矢量。 &lt;code&gt;!v&lt;/code&gt; 等效于 &lt;code&gt;v == 0&lt;/code&gt; ， &lt;code&gt;a &amp;amp;&amp;amp; b&lt;/code&gt; 等效于 &lt;code&gt;a!=0 &amp;amp; b!=0&lt;/code&gt; 和 &lt;code&gt;a || b&lt;/code&gt; 等于 &lt;code&gt;a!=0 | b!=0&lt;/code&gt; 。对于标量 &lt;code&gt;s&lt;/code&gt; 与向量 &lt;code&gt;v&lt;/code&gt; 之间的混合运算， &lt;code&gt;s &amp;amp;&amp;amp; v&lt;/code&gt; 等于 &lt;code&gt;s?v!=0:0&lt;/code&gt; （评估为短路），而 &lt;code&gt;v &amp;amp;&amp;amp; s&lt;/code&gt; 等于 &lt;code&gt;v!=0 &amp;amp; (s?-1:0)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="260b901dabc2f639a1fcfb92f83b3a8bfc6792cb" translate="yes" xml:space="preserve">
          <source>In C++, the ternary operator &lt;code&gt;?:&lt;/code&gt; is available. &lt;code&gt;a?b:c&lt;/code&gt;, where &lt;code&gt;b&lt;/code&gt; and &lt;code&gt;c&lt;/code&gt; are vectors of the same type and &lt;code&gt;a&lt;/code&gt; is an integer vector with the same number of elements of the same size as &lt;code&gt;b&lt;/code&gt; and &lt;code&gt;c&lt;/code&gt;, computes all three arguments and creates a vector &lt;code&gt;{a[0]?b[0]:c[0], a[1]?b[1]:c[1], &amp;hellip;}&lt;/code&gt;. Note that unlike in OpenCL, &lt;code&gt;a&lt;/code&gt; is thus interpreted as &lt;code&gt;a != 0&lt;/code&gt; and not &lt;code&gt;a &amp;lt; 0&lt;/code&gt;. As in the case of binary operations, this syntax is also accepted when one of &lt;code&gt;b&lt;/code&gt; or &lt;code&gt;c&lt;/code&gt; is a scalar that is then transformed into a vector. If both &lt;code&gt;b&lt;/code&gt; and &lt;code&gt;c&lt;/code&gt; are scalars and the type of &lt;code&gt;true?b:c&lt;/code&gt; has the same size as the element type of &lt;code&gt;a&lt;/code&gt;, then &lt;code&gt;b&lt;/code&gt; and &lt;code&gt;c&lt;/code&gt; are converted to a vector type whose elements have this type and with the same number of elements as &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">在C ++中，三元运算符 &lt;code&gt;?:&lt;/code&gt; 是可用的。 &lt;code&gt;a?b:c&lt;/code&gt; ，其中 &lt;code&gt;b&lt;/code&gt; 和 &lt;code&gt;c&lt;/code&gt; 是相同类型的向量， &lt;code&gt;a&lt;/code&gt; 是具有与 &lt;code&gt;b&lt;/code&gt; 和 &lt;code&gt;c&lt;/code&gt; 相同大小的相同数量元素的整数向量，计算所有三个参数并创建向量 &lt;code&gt;{a[0]?b[0]:c[0], a[1]?b[1]:c[1], &amp;hellip;}&lt;/code&gt; 。请注意，与OpenCL不同， &lt;code&gt;a&lt;/code&gt; 因此被解释为 &lt;code&gt;a != 0&lt;/code&gt; 而不是 &lt;code&gt;a &amp;lt; 0&lt;/code&gt; 。与二进制运算的情况一样，当 &lt;code&gt;b&lt;/code&gt; 或 &lt;code&gt;c&lt;/code&gt; 之一是标量然后转换为向量时，也接受此语法。如果都 &lt;code&gt;b&lt;/code&gt; 和 &lt;code&gt;c&lt;/code&gt; 是标量，并且 &lt;code&gt;true?b:c&lt;/code&gt; 的类型与 &lt;code&gt;a&lt;/code&gt; 的元素类型具有相同的大小，然后 &lt;code&gt;b&lt;/code&gt; 和 &lt;code&gt;c&lt;/code&gt; 转换为向量类型，该向量类型的元素具有此类型并且元素数与 &lt;code&gt;a&lt;/code&gt; 相同。</target>
        </trans-unit>
        <trans-unit id="9e8e3384895cb64dc59dfb4ef3c2eae30e005995" translate="yes" xml:space="preserve">
          <source>In C++, the visibility attribute applies to types as well as functions and objects, because in C++ types have linkage. A class must not have greater visibility than its non-static data member types and bases, and class members default to the visibility of their class. Also, a declaration without explicit visibility is limited to the visibility of its type.</source>
          <target state="translated">在C++中,可见性属性既适用于类型,也适用于函数和对象,因为在C++中,类型具有链接性。一个类的可见性不能大于它的非静态数据成员类型和基,类成员默认为其类的可见性。另外,没有显式可见性的声明也仅限于其类型的可见性。</target>
        </trans-unit>
        <trans-unit id="9870b14c476e69190f3f39c0be8be66122cac26a" translate="yes" xml:space="preserve">
          <source>In C++, the warning is issued when an explicit specialization of a primary template declared with attribute &lt;code&gt;alloc_align&lt;/code&gt;, &lt;code&gt;alloc_size&lt;/code&gt;, &lt;code&gt;assume_aligned&lt;/code&gt;, &lt;code&gt;format&lt;/code&gt;, &lt;code&gt;format_arg&lt;/code&gt;, &lt;code&gt;malloc&lt;/code&gt;, or &lt;code&gt;nonnull&lt;/code&gt; is declared without it. Attributes &lt;code&gt;deprecated&lt;/code&gt;, &lt;code&gt;error&lt;/code&gt;, and &lt;code&gt;warning&lt;/code&gt; suppress the warning. (see &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;Function Attributes&lt;/a&gt;).</source>
          <target state="translated">在C ++中，当主模板的明确分工与属性声明发出警告 &lt;code&gt;alloc_align&lt;/code&gt; ， &lt;code&gt;alloc_size&lt;/code&gt; ， &lt;code&gt;assume_aligned&lt;/code&gt; ， &lt;code&gt;format&lt;/code&gt; ， &lt;code&gt;format_arg&lt;/code&gt; ， &lt;code&gt;malloc&lt;/code&gt; 的，或者 &lt;code&gt;nonnull&lt;/code&gt; 不声明它。 &lt;code&gt;deprecated&lt;/code&gt; 属性， &lt;code&gt;error&lt;/code&gt; 和 &lt;code&gt;warning&lt;/code&gt; 禁止显示警告。（请参阅&lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;功能属性&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="9914fa32f31272fbd1b3c9fd5655fe7c161328ef" translate="yes" xml:space="preserve">
          <source>In C++, this attribute does not depend on &lt;code&gt;extern&lt;/code&gt; in any way, but it still requires the &lt;code&gt;inline&lt;/code&gt; keyword to enable its special behavior.</source>
          <target state="translated">在C ++中，此属性不以任何方式依赖于 &lt;code&gt;extern&lt;/code&gt; ，但是它仍然需要 &lt;code&gt;inline&lt;/code&gt; 关键字来启用其特殊行为。</target>
        </trans-unit>
        <trans-unit id="1330ec9305a2cf36952504f041eeaa71d08a1559" translate="yes" xml:space="preserve">
          <source>In C++, this pragma silently applies only to declarations with &amp;ldquo;C&amp;rdquo; linkage. Again, &lt;code&gt;asm&lt;/code&gt; labels do not have this restriction.</source>
          <target state="translated">在C ++中，此编译指示仅适用于具有&amp;ldquo; C&amp;rdquo;链接的声明。同样， &lt;code&gt;asm&lt;/code&gt; 标签没有此限制。</target>
        </trans-unit>
        <trans-unit id="4f1560146bfb02b0050b7346bcee56f1168f8456" translate="yes" xml:space="preserve">
          <source>In C++, this switch only affects the &lt;code&gt;typeof&lt;/code&gt; keyword, since &lt;code&gt;asm&lt;/code&gt; and &lt;code&gt;inline&lt;/code&gt; are standard keywords. You may want to use the</source>
          <target state="translated">在C ++中，此开关仅影响 &lt;code&gt;typeof&lt;/code&gt; 关键字，因为 &lt;code&gt;asm&lt;/code&gt; 和 &lt;code&gt;inline&lt;/code&gt; 是标准关键字。您可能要使用</target>
        </trans-unit>
        <trans-unit id="83513182660c016337c6a43ced48177d4ad0ef0c" translate="yes" xml:space="preserve">
          <source>In C++, you can mark member functions and static member variables of a class with the visibility attribute. This is useful if you know a particular method or static member variable should only be used from one shared object; then you can mark it hidden while the rest of the class has default visibility. Care must be taken to avoid breaking the One Definition Rule; for example, it is usually not useful to mark an inline method as hidden without marking the whole class as hidden.</source>
          <target state="translated">在C++中,你可以用可见性属性标记一个类的成员函数和静态成员变量。如果你知道一个特定的方法或静态成员变量应该只从一个共享对象中使用,那么这很有用;然后你可以将它标记为隐藏,而类的其他部分具有默认可见性。必须注意避免破坏 &quot;一个定义规则&quot;;例如,在没有将整个类标记为隐藏的情况下,将一个内联方法标记为隐藏通常是没有用的。</target>
        </trans-unit>
        <trans-unit id="1263d4b3bd19eaa09ddd9de78312a5a79d915aa7" translate="yes" xml:space="preserve">
          <source>In C++14, &lt;code&gt;f&lt;/code&gt; calls &lt;code&gt;f&amp;lt;void(*)()&amp;gt;&lt;/code&gt;, but in C++17 it calls &lt;code&gt;f&amp;lt;void(*)()noexcept&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">在C ++ 14中， &lt;code&gt;f&lt;/code&gt; 调用 &lt;code&gt;f&amp;lt;void(*)()&amp;gt;&lt;/code&gt; ，但在C ++ 17中它调用 &lt;code&gt;f&amp;lt;void(*)()noexcept&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a3eaf8f9d1fd2934be9e06d429d221c630b5bf0a" translate="yes" xml:space="preserve">
          <source>In C++17, the compiler is required to omit these temporaries, but this option still affects trivial member functions.</source>
          <target state="translated">在C++17中,编译器被要求省略这些时序,但这个选项仍然会影响琐碎的成员函数。</target>
        </trans-unit>
        <trans-unit id="2fd9362a64ee90151b4f33ed9f7535e5f0047820" translate="yes" xml:space="preserve">
          <source>In C, &lt;code&gt;__PRETTY_FUNCTION__&lt;/code&gt; is yet another name for &lt;code&gt;__func__&lt;/code&gt;, except that at file (or, in C++, namespace scope), it evaluates to the string &lt;code&gt;&quot;top level&quot;&lt;/code&gt;. In addition, in C++, &lt;code&gt;__PRETTY_FUNCTION__&lt;/code&gt; contains the signature of the function as well as its bare name. For example, this program:</source>
          <target state="translated">在C中， &lt;code&gt;__PRETTY_FUNCTION__&lt;/code&gt; &lt;code&gt;__func__&lt;/code&gt; 是__func__的另一个名称，除了在文件（或在C ++中，名称空间范围）中，它的计算结果为字符串 &lt;code&gt;&quot;top level&quot;&lt;/code&gt; 。另外，在C ++中， &lt;code&gt;__PRETTY_FUNCTION__&lt;/code&gt; 包含函数的签名及其裸名。例如，该程序：</target>
        </trans-unit>
        <trans-unit id="fdc98ae804a4e7fb53930f663d8637b51c1dfdb4" translate="yes" xml:space="preserve">
          <source>In C, &lt;code&gt;__PRETTY_FUNCTION__&lt;/code&gt; is yet another name for &lt;code&gt;__func__&lt;/code&gt;, except that at file scope (or, in C++, namespace scope), it evaluates to the string &lt;code&gt;&quot;top level&quot;&lt;/code&gt;. In addition, in C++, &lt;code&gt;__PRETTY_FUNCTION__&lt;/code&gt; contains the signature of the function as well as its bare name. For example, this program:</source>
          <target state="translated">在C中， &lt;code&gt;__PRETTY_FUNCTION__&lt;/code&gt; &lt;code&gt;__func__&lt;/code&gt; 是__func__的另一个名称，除了在文件作用域（或在C ++中，名称空间作用域）中，它的计算结果为字符串 &lt;code&gt;&quot;top level&quot;&lt;/code&gt; 。另外，在C ++中， &lt;code&gt;__PRETTY_FUNCTION__&lt;/code&gt; 包含函数的签名及其裸名。例如，该程序：</target>
        </trans-unit>
        <trans-unit id="89c3cbeabc9fb0c94d32392b571a5dbe1ffa12b0" translate="yes" xml:space="preserve">
          <source>In C, a compound literal designates an unnamed object with static or automatic storage duration. In C++, a compound literal designates a temporary object that only lives until the end of its full-expression. As a result, well-defined C code that takes the address of a subobject of a compound literal can be undefined in C++, so G++ rejects the conversion of a temporary array to a pointer. For instance, if the array compound literal example above appeared inside a function, any subsequent use of &lt;code&gt;foo&lt;/code&gt; in C++ would have undefined behavior because the lifetime of the array ends after the declaration of &lt;code&gt;foo&lt;/code&gt;.</source>
          <target state="translated">在C中，复合文字表示具有静态或自动存储持续时间的未命名对象。在C ++中，复合文字表示一个临时对象，该对象仅在其完整表达式结束之前一直存在。结果，可以在C ++中未定义定义良好的C代码（采用复合文字的子对象的地址），因此G ++拒绝将临时数组转换为指针。例如，如果上面的数组复合文字示例出现在函数内部，则C ++中对 &lt;code&gt;foo&lt;/code&gt; 的任何后续使用都将具有未定义的行为，因为数组的生存期在声明 &lt;code&gt;foo&lt;/code&gt; 之后结束。</target>
        </trans-unit>
        <trans-unit id="b955553d29e649b19193fbacbc412a24a27d538d" translate="yes" xml:space="preserve">
          <source>In C, emit &lt;code&gt;static&lt;/code&gt; functions that are declared &lt;code&gt;inline&lt;/code&gt; into the object file, even if the function has been inlined into all of its callers. This switch does not affect functions using the &lt;code&gt;extern inline&lt;/code&gt; extension in GNU C90. In C++, emit any and all inline functions into the object file.</source>
          <target state="translated">在C语言中，发出被 &lt;code&gt;inline&lt;/code&gt; 声明到目标文件中的 &lt;code&gt;static&lt;/code&gt; 函数，即使该函数已内联到其所有调用程序中。此开关不影响使用GNU C90中的 &lt;code&gt;extern inline&lt;/code&gt; 扩展名的功能。在C ++中，将任何和所有内联函数发送到目标文件中。</target>
        </trans-unit>
        <trans-unit id="3058a9d60ea1ade68bb14049e675f5bf83c7026b" translate="yes" xml:space="preserve">
          <source>In C, if the function is neither &lt;code&gt;extern&lt;/code&gt; nor &lt;code&gt;static&lt;/code&gt;, then the function is compiled as a standalone function, as well as being inlined where possible.</source>
          <target state="translated">在C语言中，如果函数既不是 &lt;code&gt;extern&lt;/code&gt; 也不是 &lt;code&gt;static&lt;/code&gt; ，则该函数将编译为独立函数，并在可能的情况下内联。</target>
        </trans-unit>
        <trans-unit id="e352da7bd9ce1ec016de9e2458664a9340519a89" translate="yes" xml:space="preserve">
          <source>In C/C++, every &lt;code&gt;else&lt;/code&gt; branch belongs to the innermost possible &lt;code&gt;if&lt;/code&gt; statement, which in this example is &lt;code&gt;if (b)&lt;/code&gt;. This is often not what the programmer expected, as illustrated in the above example by indentation the programmer chose. When there is the potential for this confusion, GCC issues a warning when this flag is specified. To eliminate the warning, add explicit braces around the innermost &lt;code&gt;if&lt;/code&gt; statement so there is no way the &lt;code&gt;else&lt;/code&gt; can belong to the enclosing &lt;code&gt;if&lt;/code&gt;. The resulting code looks like this:</source>
          <target state="translated">在C / C ++中，每个 &lt;code&gt;else&lt;/code&gt; 分支都属于最里面的 &lt;code&gt;if&lt;/code&gt; 语句，在此示例中为 &lt;code&gt;if (b)&lt;/code&gt; 。如上例中程序员选择的缩进所示，这通常不是程序员期望的。如果有可能造成这种混乱，则在指定此标志时，GCC会发出警告。为了消除警告，请在最里面的 &lt;code&gt;if&lt;/code&gt; 语句周围添加大括号，以便 &lt;code&gt;else&lt;/code&gt; 不能属于封闭的 &lt;code&gt;if&lt;/code&gt; 。产生的代码如下所示：</target>
        </trans-unit>
        <trans-unit id="69cc3b441acbdbe11472c325735b27c046d27c5c" translate="yes" xml:space="preserve">
          <source>In G++, the result value of a statement expression undergoes array and function pointer decay, and is returned by value to the enclosing expression. For instance, if &lt;code&gt;A&lt;/code&gt; is a class, then</source>
          <target state="translated">在G ++中，语句表达式的结果值经历数组和函数指针的衰减，并按值返回到封闭的表达式。例如，如果 &lt;code&gt;A&lt;/code&gt; 是一个类，则</target>
        </trans-unit>
        <trans-unit id="2b79b7c58963843a8ca543d9e2a4ed22f6af9388" translate="yes" xml:space="preserve">
          <source>In GNU C and C++, you can use function attributes to specify certain function properties that may help the compiler optimize calls or check code more carefully for correctness. For example, you can use attributes to specify that a function never returns (&lt;code&gt;noreturn&lt;/code&gt;), returns a value depending only on the values of its arguments (&lt;code&gt;const&lt;/code&gt;), or has &lt;code&gt;printf&lt;/code&gt;-style arguments (&lt;code&gt;format&lt;/code&gt;).</source>
          <target state="translated">在GNU C和C ++中，可以使用函数属性来指定某些函数属性，这些属性可以帮助编译器优化调用或更仔细地检查代码的正确性。例如，您可以使用属性来指定函数从不返回（ &lt;code&gt;noreturn&lt;/code&gt; ），仅根据其参数的值（ &lt;code&gt;const&lt;/code&gt; ）返回值或具有 &lt;code&gt;printf&lt;/code&gt; 样式的参数（ &lt;code&gt;format&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="099e4a52fb6ed11fab7818dcdc84803658fe6ac9" translate="yes" xml:space="preserve">
          <source>In GNU C, addition and subtraction operations are supported on pointers to &lt;code&gt;void&lt;/code&gt; and on pointers to functions. This is done by treating the size of a &lt;code&gt;void&lt;/code&gt; or of a function as 1.</source>
          <target state="translated">在GNU C中，指向 &lt;code&gt;void&lt;/code&gt; 的指针和指向函数的指针支持加法和减法运算。通过将 &lt;code&gt;void&lt;/code&gt; 或函数的大小视为1 来完成此操作。</target>
        </trans-unit>
        <trans-unit id="cca3c66936552d4dc4ee0493549030694bbe3a79" translate="yes" xml:space="preserve">
          <source>In GNU C, an attribute specifier list may appear after the colon following a label, other than a &lt;code&gt;case&lt;/code&gt; or &lt;code&gt;default&lt;/code&gt; label. GNU C++ only permits attributes on labels if the attribute specifier is immediately followed by a semicolon (i.e., the label applies to an empty statement). If the semicolon is missing, C++ label attributes are ambiguous, as it is permissible for a declaration, which could begin with an attribute list, to be labelled in C++. Declarations cannot be labelled in C90 or C99, so the ambiguity does not arise there.</source>
          <target state="translated">在GNU C中，属性说明符列表可能会出现在冒号之后的标签之后，而不是 &lt;code&gt;case&lt;/code&gt; 或 &lt;code&gt;default&lt;/code&gt; 标签。如果属性说明符后紧跟一个分号（即，标签适用于空语句），则GNU C ++仅允许标签上的属性。如果缺少分号，则C ++标签属性是不明确的，因为声明可以使用C ++进行标记，该声明可以以属性列表开头。声明不能在C90或C99中标记，因此不会在此处引起歧义。</target>
        </trans-unit>
        <trans-unit id="00f091378926e345c0e4332aa146832525cddb05" translate="yes" xml:space="preserve">
          <source>In GNU C, an attribute specifier list may appear as part of a null statement. The attribute goes before the semicolon.</source>
          <target state="translated">在GNU C中,属性指定器列表可以作为null语句的一部分出现。属性放在分号之前。</target>
        </trans-unit>
        <trans-unit id="1b43625a41fcbb3b41411d6343924dd766870911" translate="yes" xml:space="preserve">
          <source>In GNU C, an attribute specifier list may appear as part of an enumerator. The attribute goes after the enumeration constant, before &lt;code&gt;=&lt;/code&gt;, if present. The optional attribute in the enumerator appertains to the enumeration constant. It is not possible to place the attribute after the constant expression, if present.</source>
          <target state="translated">在GNU C中，属性说明符列表可能作为枚举器的一部分出现。该属性位于枚举常量之后 &lt;code&gt;=&lt;/code&gt; 之前（如果存在）。枚举器中的可选属性与枚举常量有关。如果存在，则无法将属性放在常量表达式之后。</target>
        </trans-unit>
        <trans-unit id="50d3726425717c2c21e872422eba9b6e01ec20e3" translate="yes" xml:space="preserve">
          <source>In GNU C, but not GNU C++, you may also declare the type of a variable as &lt;code&gt;__auto_type&lt;/code&gt;. In that case, the declaration must declare only one variable, whose declarator must just be an identifier, the declaration must be initialized, and the type of the variable is determined by the initializer; the name of the variable is not in scope until after the initializer. (In C++, you should use C++11 &lt;code&gt;auto&lt;/code&gt; for this purpose.) Using &lt;code&gt;__auto_type&lt;/code&gt;, the &amp;ldquo;maximum&amp;rdquo; macro above could be written as:</source>
          <target state="translated">在GNU C中，但在GNU C ++中，您还可以将变量的类型声明为 &lt;code&gt;__auto_type&lt;/code&gt; 。在这种情况下，声明必须仅声明一个变量，其声明符必须只是一个标识符，声明必须被初始化，并且变量的类型由初始化程序确定；直到初始化之后，变量名才在作用域内。 （在C ++中，您应为此目的使用C ++ 11 &lt;code&gt;auto&lt;/code&gt; 。）使用 &lt;code&gt;__auto_type&lt;/code&gt; ，上面的&amp;ldquo; maximum&amp;rdquo;宏可以写为：</target>
        </trans-unit>
        <trans-unit id="161e108f588ab6d10ef611d46f160cd49c4d5897" translate="yes" xml:space="preserve">
          <source>In GNU C, pointers to arrays with qualifiers work similar to pointers to other qualified types. For example, a value of type &lt;code&gt;int (*)[5]&lt;/code&gt; can be used to initialize a variable of type &lt;code&gt;const int (*)[5]&lt;/code&gt;. These types are incompatible in ISO C because the &lt;code&gt;const&lt;/code&gt; qualifier is formally attached to the element type of the array and not the array itself.</source>
          <target state="translated">在GNU C中，指向带有限定符的数组的指针的工作方式类似于指向其他限定类型的指针。例如，类型 &lt;code&gt;int (*)[5]&lt;/code&gt; 值可用于初始化 &lt;code&gt;const int (*)[5]&lt;/code&gt; 类型的变量。这些类型在ISO C中不兼容，因为 &lt;code&gt;const&lt;/code&gt; 限定符正式附加到数组的元素类型，而不是数组本身。</target>
        </trans-unit>
        <trans-unit id="30928a7827c13008efbc31a4cd47ef8c080ec55d" translate="yes" xml:space="preserve">
          <source>In GNU C, you may normally use dollar signs in identifier names. This is because many traditional C implementations allow such identifiers. However, dollar signs in identifiers are not supported on a few target machines, typically because the target assembler does not allow them.</source>
          <target state="translated">在GNU C中,通常可以在标识符名称中使用美元符号。这是因为许多传统的C语言实现都允许使用这种标识符。然而,在少数目标机器上不支持在标识符中使用美元符号,通常是因为目标汇编器不允许使用美元符号。</target>
        </trans-unit>
        <trans-unit id="42c17a04ef25e4ac6774717de0dc2e63f588b7db" translate="yes" xml:space="preserve">
          <source>In GNU C, you may use C++ style comments, which start with &amp;lsquo;</source>
          <target state="translated">在GNU C中，您可以使用C ++样式的注释，该注释以&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="2f24585b9162dc03bf874f7e503f710293aefabe" translate="yes" xml:space="preserve">
          <source>In ISO C and ISO C++, two identifiers are different if they are different sequences of characters. However, sometimes when characters outside the basic ASCII character set are used, you can have two different character sequences that look the same. To avoid confusion, the ISO 10646 standard sets out some &lt;em&gt;normalization rules&lt;/em&gt; which when applied ensure that two sequences that look the same are turned into the same sequence. GCC can warn you if you are using identifiers that have not been normalized; this option controls that warning.</source>
          <target state="translated">在ISO C和ISO C ++中，如果两个标识符是不同的字符序列，则它们是不同的。但是，有时当使用基本ASCII字符集以外的字符时，您可以具有两个看起来相同的不同字符序列。为避免混淆，ISO 10646标准制定了一些&lt;em&gt;规范化规则&lt;/em&gt;，这些&lt;em&gt;规范&lt;/em&gt;在应用时可确保将看起来相同的两个序列转换为相同的序列。如果您使用的是未规范化的标识符，GCC会警告您。此选项控制该警告。</target>
        </trans-unit>
        <trans-unit id="ae9542423c752a021f2d6e4fc0443b96ae1d5030" translate="yes" xml:space="preserve">
          <source>In ISO C, this is not allowed: &lt;code&gt;long&lt;/code&gt; and other type modifiers require an explicit &lt;code&gt;int&lt;/code&gt;.</source>
          <target state="translated">在ISO C中，这是不允许的： &lt;code&gt;long&lt;/code&gt; 和其他类型修饰符需要显式的 &lt;code&gt;int&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a83c2089c56e85f19efece977b66d33d39dca615" translate="yes" xml:space="preserve">
          <source>In ISO C99 you can give the elements in any order, specifying the array indices or structure field names they apply to, and GNU C allows this as an extension in C90 mode as well. This extension is not implemented in GNU C++.</source>
          <target state="translated">在ISO C99中,你可以按任意顺序给出元素,指定它们适用的数组索引或结构字段名,GNU C也允许在C90模式下将其作为一种扩展。这个扩展在GNU C++中没有实现。</target>
        </trans-unit>
        <trans-unit id="ee146e8637f31533cbc25f2e770067e2245618cc" translate="yes" xml:space="preserve">
          <source>In ISO C99, arrays that are not lvalues still decay to pointers, and may be subscripted, although they may not be modified or used after the next sequence point and the unary &amp;lsquo;</source>
          <target state="translated">在ISO C99中，不是左值的数组仍然会衰减到指针，并且可以被下标，尽管在下一个序列点和一元'之后不能对其进行修改或使用。</target>
        </trans-unit>
        <trans-unit id="8675eb52335a427e8b8fe6e8d5660e8a4778f71b" translate="yes" xml:space="preserve">
          <source>In Standard C++, objects defined at namespace scope are guaranteed to be initialized in an order in strict accordance with that of their definitions &lt;em&gt;in a given translation unit&lt;/em&gt;. No guarantee is made for initializations across translation units. However, GNU C++ allows users to control the order of initialization of objects defined at namespace scope with the &lt;code&gt;init_priority&lt;/code&gt; attribute by specifying a relative &lt;var&gt;priority&lt;/var&gt;, a constant integral expression currently bounded between 101 and 65535 inclusive. Lower numbers indicate a higher priority.</source>
          <target state="translated">在Standard C ++中，保证在命名空间范围内定义的对象必须严格按照&lt;em&gt;给定转换单元&lt;/em&gt;中其定义的顺序进行初始化。不保证跨翻译单元的初始化。但是，GNU C ++允许用户通过指定相对 &lt;var&gt;priority&lt;/var&gt; 来控制在命名空间范围内使用 &lt;code&gt;init_priority&lt;/code&gt; 属性定义的对象的初始化顺序，该相对优先级是当前范围介于101和65535（含）之间的常数整数表达式。较低的数字表示较高的优先级。</target>
        </trans-unit>
        <trans-unit id="7083740b732c482c66c0773b79daf9926d12ffe7" translate="yes" xml:space="preserve">
          <source>In Thumb State the core registers &lt;code&gt;r0&lt;/code&gt;-&lt;code&gt;r7&lt;/code&gt;. In ARM state this is an alias for the &lt;code&gt;r&lt;/code&gt; constraint.</source>
          <target state="translated">在Thumb状态下，核心寄存器 &lt;code&gt;r0&lt;/code&gt; - &lt;code&gt;r7&lt;/code&gt; 。在ARM状态下，这是 &lt;code&gt;r&lt;/code&gt; 约束的别名。</target>
        </trans-unit>
        <trans-unit id="d1d4e1edbad74d306db2f222651915a6d0f5858a" translate="yes" xml:space="preserve">
          <source>In Thumb state, the core registers &lt;code&gt;r8&lt;/code&gt;-&lt;code&gt;r15&lt;/code&gt;.</source>
          <target state="translated">在Thumb状态下，核心寄存器 &lt;code&gt;r8&lt;/code&gt; - &lt;code&gt;r15&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6352795921f416092911448041e5d77f4ed5cab2" translate="yes" xml:space="preserve">
          <source>In a statement expression, any temporaries created within a statement are destroyed at that statement&amp;rsquo;s end. This makes statement expressions inside macros slightly different from function calls. In the latter case temporaries introduced during argument evaluation are destroyed at the end of the statement that includes the function call. In the statement expression case they are destroyed during the statement expression. For instance,</source>
          <target state="translated">在语句表达式中，在语句中创建的任何临时对象都将在该语句的末尾销毁。这使得宏内部的语句表达式与函数调用略有不同。在后一种情况下，在参数评估期间引入的临时变量会在包含函数调用的语句末尾销毁。在语句表达式的情况下，它们在语句表达式期间被销毁。例如，</target>
        </trans-unit>
        <trans-unit id="5ba9aa0570b135c995bc38a76f20798c8cb8905c" translate="yes" xml:space="preserve">
          <source>In a structure initializer, specify the name of a field to initialize with &amp;lsquo;</source>
          <target state="translated">在结构初始化程序中，指定要使用'初始化的字段的名称</target>
        </trans-unit>
        <trans-unit id="b60fb2c19e13e2004512b51ba3ef992aebaa1e2a" translate="yes" xml:space="preserve">
          <source>In a typical forwarding implementation, the &lt;code&gt;__objc_msg_forward2&lt;/code&gt; hook function determines the argument and return type of the method that is being looked up, and then creates a function that takes these arguments and has that return type, and returns it to the caller. Creating this function is non-trivial and is typically performed using a dedicated library such as &lt;code&gt;libffi&lt;/code&gt;.</source>
          <target state="translated">在典型的转发实现中， &lt;code&gt;__objc_msg_forward2&lt;/code&gt; 挂钩函数确定正在查找的方法的参数和返回类型，然后创建一个接受这些参数并具有该返回类型的函数，并将其返回给调用方。创建此函数并 &lt;code&gt;libffi&lt;/code&gt; 通常使用专用库（例如libffi）执行。</target>
        </trans-unit>
        <trans-unit id="54dd00baa71ef2667fe6e28112deacb360520410" translate="yes" xml:space="preserve">
          <source>In addition a C preprocessor macro is defined, based upon the setting of this option. Possible values are: &lt;code&gt;__RL78_G10__&lt;/code&gt;, &lt;code&gt;__RL78_G13__&lt;/code&gt; or &lt;code&gt;__RL78_G14__&lt;/code&gt;.</source>
          <target state="translated">另外，基于此选项的设置，定义了C预处理程序宏。可能的值为： &lt;code&gt;__RL78_G10__&lt;/code&gt; ， &lt;code&gt;__RL78_G13__&lt;/code&gt; 或 &lt;code&gt;__RL78_G14__&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ea9e02775fab3d62ec695ffb7a117d5587d95e84" translate="yes" xml:space="preserve">
          <source>In addition a C preprocessor macro is defined, based upon the setting of this option. Possible values are: &lt;code&gt;__RL78_MUL_NONE__&lt;/code&gt;, &lt;code&gt;__RL78_MUL_G13__&lt;/code&gt; or &lt;code&gt;__RL78_MUL_G14__&lt;/code&gt;.</source>
          <target state="translated">另外，基于此选项的设置，定义了C预处理程序宏。可能的值为： &lt;code&gt;__RL78_MUL_NONE__&lt;/code&gt; ， &lt;code&gt;__RL78_MUL_G13__&lt;/code&gt; 或 &lt;code&gt;__RL78_MUL_G14__&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8837c405f2a2c41529e9b5f823973ab02322956f" translate="yes" xml:space="preserve">
          <source>In addition an MCU-specific linker script is added to the linker command line. The script&amp;rsquo;s name is the name of the MCU with</source>
          <target state="translated">此外，MCU特定的链接描述文件已添加到链接描述文件命令行中。脚本的名称是带有以下内容的MCU的名称</target>
        </trans-unit>
        <trans-unit id="62b95995af660527c1e8f21b9d4ad0c066623058" translate="yes" xml:space="preserve">
          <source>In addition to &lt;code&gt;__builtin_tbegin&lt;/code&gt; a loop for transient failures is generated. If tbegin returns a condition code of 2 the transaction will be retried as often as specified in the second argument. The perform processor assist instruction is used to tell the CPU about the number of fails so far.</source>
          <target state="translated">除了 &lt;code&gt;__builtin_tbegin&lt;/code&gt; 之外，还会生成一个用于瞬态故障的循环。如果tbegin返回条件代码2，则将按照第二个参数中指定的频率重试事务。执行处理器辅助指令用于告知CPU到目前为止的失败次数。</target>
        </trans-unit>
        <trans-unit id="eced644e577e40c96cd49fe30f0f7fd6120dd908" translate="yes" xml:space="preserve">
          <source>In addition to all the flags that</source>
          <target state="translated">除了所有的旗帜之外</target>
        </trans-unit>
        <trans-unit id="565a2d203f5b02e7460006ace0af95f26a347995" translate="yes" xml:space="preserve">
          <source>In addition to allowing restricted pointers, you can specify restricted references, which indicate that the reference is not aliased in the local context.</source>
          <target state="translated">除了允许受限制的指针外,还可以指定受限制的引用,这表明该引用在本地上下文中不被别名。</target>
        </trans-unit>
        <trans-unit id="b4b514e38fd4621ee545768450d76575b94e288e" translate="yes" xml:space="preserve">
          <source>In addition to forward declaration of explicit instantiations (with &lt;code&gt;extern&lt;/code&gt;), G++ has extended the template instantiation syntax to support instantiation of the compiler support data for a template class (i.e. the vtable) without instantiating any of its members (with &lt;code&gt;inline&lt;/code&gt;), and instantiation of only the static data members of a template class, without the support data or member functions (with &lt;code&gt;static&lt;/code&gt;):</source>
          <target state="translated">除了向前声明显式实例化（使用 &lt;code&gt;extern&lt;/code&gt; ）之外，G ++还扩展了模板实例化语法，以支持模板类（即vtable）的编译器支持数据的实例化，而无需实例化其任何成员（使用 &lt;code&gt;inline&lt;/code&gt; ）和实例化。仅包含模板类的静态数据成员，不包含支持数据或成员函数（带有 &lt;code&gt;static&lt;/code&gt; ）：</target>
        </trans-unit>
        <trans-unit id="6439cc01a9774bbc0ce4a99e0995283f7780b83f" translate="yes" xml:space="preserve">
          <source>In addition to reordering basic blocks in the compiled function, in order to reduce number of taken branches, partitions hot and cold basic blocks into separate sections of the assembly and</source>
          <target state="translated">除了对编译函数中的基本块进行重新排序外,为了减少所取的分支数量,还将热基本块和冷基本块划分到装配体的不同部分,并将这些基本块分成不同的部分。</target>
        </trans-unit>
        <trans-unit id="b8e7d51ee0ff5509475a8b0b3cef903395f3e89e" translate="yes" xml:space="preserve">
          <source>In addition to that, the NeXT runtime uses a different encoding for bitfields. It encodes them as &lt;code&gt;b&lt;/code&gt; followed by the size, without a bit offset or the underlying field type.</source>
          <target state="translated">除此之外，NeXT运行时对位域使用不同的编码。它将它们编码为 &lt;code&gt;b&lt;/code&gt; ,后跟大小，没有位偏移或基础字段类型。</target>
        </trans-unit>
        <trans-unit id="f8c503d521df2902eea004c571a88a7aaf261eea" translate="yes" xml:space="preserve">
          <source>In addition to the above HTM built-ins, we have added built-ins for some common extended mnemonics of the HTM instructions:</source>
          <target state="translated">除了以上的HTM内置,我们还增加了一些HTM指令的常用扩展口诀的内置。</target>
        </trans-unit>
        <trans-unit id="084c327f43e99f5eed11f3cfccf089fdeb010185" translate="yes" xml:space="preserve">
          <source>In addition to the attributes documented here, GCC plugins may provide their own attributes.</source>
          <target state="translated">除了这里记载的属性外,GCC插件还可以提供自己的属性。</target>
        </trans-unit>
        <trans-unit id="59aaa6ec676f5bdbed99a7053eff5202675d0852" translate="yes" xml:space="preserve">
          <source>In addition to the full set of format archetypes (attribute format style arguments such as &lt;code&gt;printf&lt;/code&gt;, &lt;code&gt;scanf&lt;/code&gt;, &lt;code&gt;strftime&lt;/code&gt;, and &lt;code&gt;strfmon&lt;/code&gt;), Darwin targets also support the &lt;code&gt;CFString&lt;/code&gt; (or &lt;code&gt;__CFString__&lt;/code&gt;) archetype in the &lt;code&gt;format&lt;/code&gt; attribute. Declarations with this archetype are parsed for correct syntax and argument types. However, parsing of the format string itself and validating arguments against it in calls to such functions is currently not performed.</source>
          <target state="translated">除了完整的格式原型集（属性格式样式参数，例如 &lt;code&gt;printf&lt;/code&gt; ， &lt;code&gt;scanf&lt;/code&gt; ， &lt;code&gt;strftime&lt;/code&gt; 和 &lt;code&gt;strfmon&lt;/code&gt; ）之外，Darwin目标还在 &lt;code&gt;format&lt;/code&gt; 属性中支持 &lt;code&gt;CFString&lt;/code&gt; （或 &lt;code&gt;__CFString__&lt;/code&gt; ）原型。解析具有该原型的声明以获取正确的语法和参数类型。但是，当前不执行对格式字符串本身的解析以及在对此类函数的调用中对其进行验证的参数。</target>
        </trans-unit>
        <trans-unit id="5bd7b4c6a1206aaa445d7deaac33eb27ef613d77" translate="yes" xml:space="preserve">
          <source>In addition to the options listed here, there are a number of options to control search paths for include files documented in &lt;a href=&quot;directory-options#Directory-Options&quot;&gt;Directory Options&lt;/a&gt;. Options to control preprocessor diagnostics are listed in &lt;a href=&quot;warning-options#Warning-Options&quot;&gt;Warning Options&lt;/a&gt;.</source>
          <target state="translated">除了此处列出的选项外，还有许多选项可控制&amp;ldquo; &lt;a href=&quot;directory-options#Directory-Options&quot;&gt;目录选项&amp;rdquo;中&lt;/a&gt;记录的包含文件的搜索路径。&lt;a href=&quot;warning-options#Warning-Options&quot;&gt;警告选项&lt;/a&gt;中列出了用于控制预处理器诊断的选项。</target>
        </trans-unit>
        <trans-unit id="71f7076b5c36e97c5be103bbb5410f7a8e3b889f" translate="yes" xml:space="preserve">
          <source>In addition to the side effects of the</source>
          <target state="translated">的副作用。</target>
        </trans-unit>
        <trans-unit id="3678577a99df8db4bb55d5c4af98383773644309" translate="yes" xml:space="preserve">
          <source>In addition to the tokens described by the input, output, and goto operands, these tokens have special meanings in the assembler template:</source>
          <target state="translated">除了输入、输出和goto操作数所描述的标记外,这些标记在汇编器模板中还有特殊的含义。</target>
        </trans-unit>
        <trans-unit id="4906f7c8d95701a33b767af39ebc70e032dc64d0" translate="yes" xml:space="preserve">
          <source>In addition to the traps enabled by &amp;lsquo;</source>
          <target state="translated">除了由'启用的陷阱</target>
        </trans-unit>
        <trans-unit id="8e62f62dfa434b0bbfd42f77c43f2e3f4b28a77e" translate="yes" xml:space="preserve">
          <source>In addition to the types the compiler also encodes the type specifiers. The table below describes the encoding of the current Objective-C type specifiers:</source>
          <target state="translated">除了类型之外,编译器还对类型指定符进行编码。下表描述了当前Objective-C类型指定符的编码。</target>
        </trans-unit>
        <trans-unit id="07e2b4620d71805ca7178b4ed737fff6b9e3c7bc" translate="yes" xml:space="preserve">
          <source>In addition to this, there are checking built-in functions &lt;code&gt;__builtin___printf_chk&lt;/code&gt;, &lt;code&gt;__builtin___vprintf_chk&lt;/code&gt;, &lt;code&gt;__builtin___fprintf_chk&lt;/code&gt; and &lt;code&gt;__builtin___vfprintf_chk&lt;/code&gt;. These have just one additional argument, &lt;var&gt;flag&lt;/var&gt;, right before format string &lt;var&gt;fmt&lt;/var&gt;. If the compiler is able to optimize them to &lt;code&gt;fputc&lt;/code&gt; etc. functions, it does, otherwise the checking function is called and the &lt;var&gt;flag&lt;/var&gt; argument passed to it.</source>
          <target state="translated">除此之外，还有检查内置函数 &lt;code&gt;__builtin___printf_chk&lt;/code&gt; ， &lt;code&gt;__builtin___vprintf_chk&lt;/code&gt; ， &lt;code&gt;__builtin___fprintf_chk&lt;/code&gt; 和 &lt;code&gt;__builtin___vfprintf_chk&lt;/code&gt; 。它们仅在格式字符串 &lt;var&gt;fmt&lt;/var&gt; 之前有一个附加参数 &lt;var&gt;flag&lt;/var&gt; 。如果编译器能够将它们优化为 &lt;code&gt;fputc&lt;/code&gt; 等函数，则可以，否则，将调用checking函数并将 &lt;var&gt;flag&lt;/var&gt; 参数传递给它。</target>
        </trans-unit>
        <trans-unit id="af9d69a85de071c5503c968b6878570e7a051f81" translate="yes" xml:space="preserve">
          <source>In addition,</source>
          <target state="translated">此外:</target>
        </trans-unit>
        <trans-unit id="ac54bbc55b4419b170b9ec36b5935081a1cdb3e2" translate="yes" xml:space="preserve">
          <source>In addition, alignment of loops and of code after barriers are dropped.</source>
          <target state="translated">此外,在丢弃障碍后,循环和代码的对齐。</target>
        </trans-unit>
        <trans-unit id="3781d09a3dc831734b5b02916076ee6266e64979" translate="yes" xml:space="preserve">
          <source>In addition, all of the following transfer instructions for internal registers X and Y must be provided to use any of the double-precision floating-point instructions. Custom instructions taking two double-precision source operands expect the first operand in the 64-bit register X. The other operand (or only operand of a unary operation) is given to the custom arithmetic instruction with the least significant half in source register &lt;var&gt;src1&lt;/var&gt; and the most significant half in &lt;var&gt;src2&lt;/var&gt;. A custom instruction that returns a double-precision result returns the most significant 32 bits in the destination register and the other half in 32-bit register Y. GCC automatically generates the necessary code sequences to write register X and/or read register Y when double-precision floating-point instructions are used.</source>
          <target state="translated">此外，必须提供以下用于内部寄存器X和Y的所有传输指令，才能使用任何双精度浮点指令。带有两个双精度源操作数的自定义指令期望64位寄存器X中的第一个操作数。另一个操作数（或一元运算的唯一操作数）被提供给自定义算术指令，源寄存器 &lt;var&gt;src1&lt;/var&gt; 和src1中的最低有效半数 &lt;var&gt;src2&lt;/var&gt; 中最重要的一半。一条返回双精度结果的自定义指令将返回目标寄存器中的最高有效32位，并返回32位寄存器Y中的另一半。GCC自动生成必要的代码序列，以在双精度时写入寄存器X和/或读取寄存器Y。 -使用精确的浮点指令。</target>
        </trans-unit>
        <trans-unit id="fef0ea4de76cead18315e4916cf4d5b385d79842" translate="yes" xml:space="preserve">
          <source>In addition, many header files are written to provide prototypes in ISO C but not in traditional C. Many of these header files can work without change in C++ provided &lt;code&gt;__STDC__&lt;/code&gt; is defined. If &lt;code&gt;__STDC__&lt;/code&gt; is not defined, they will all fail, and will all need to be changed to test explicitly for C++ as well.</source>
          <target state="translated">另外，编写了许多头文件以提供ISO C中的原型，但没有提供传统C中的原型。只要定义了 &lt;code&gt;__STDC__&lt;/code&gt; ，这些头文件中的许多头文件就可以在C ++中工作而无需更改。如果未定义 &lt;code&gt;__STDC__&lt;/code&gt; ，它们将全部失败，并且都将需要更改以针对C ++进行显式测试。</target>
        </trans-unit>
        <trans-unit id="69f2b7c74d79a65e34a188c54ca6206079621349" translate="yes" xml:space="preserve">
          <source>In addition, optional data alignment is dropped, and the option</source>
          <target state="translated">此外,可选择的数据对齐方式被取消,而选项</target>
        </trans-unit>
        <trans-unit id="f5228c4c2186ef6ab55d19754c2564a752819979" translate="yes" xml:space="preserve">
          <source>In addition, seriously incorrect code results if you call a function with too many arguments. (Normally, extra arguments are harmlessly ignored.)</source>
          <target state="translated">此外,如果你调用一个有太多参数的函数,会导致严重的错误代码。(通常情况下,额外的参数被无害地忽略了。)</target>
        </trans-unit>
        <trans-unit id="e473178ce28eda4321e03738b81ae5d066682365" translate="yes" xml:space="preserve">
          <source>In addition, the application binary interface implemented by a C++ compiler affects code generation and runtime support for:</source>
          <target state="translated">此外,C++编译器实现的应用二进制接口会影响代码生成和运行时对。</target>
        </trans-unit>
        <trans-unit id="f27cb290fe4b9fbefe17d7b31e3d8d9c930761f0" translate="yes" xml:space="preserve">
          <source>In addition, the prefix is used in an unusual way in finding the directories to search for header files. For each of the standard directories whose name normally begins with &amp;lsquo;</source>
          <target state="translated">另外，在查找目录以搜索头文件时，前缀以不寻常的方式使用。对于每个名称通常以&amp;ldquo;'&amp;rdquo;开头的标准目录</target>
        </trans-unit>
        <trans-unit id="5527ccace27f3e086df478c816bee689b9fc66e3" translate="yes" xml:space="preserve">
          <source>In addition, these optimization, warning, and code generation options have meanings only for C++ programs:</source>
          <target state="translated">此外,这些优化、警告和代码生成选项只对C++程序有意义。</target>
        </trans-unit>
        <trans-unit id="44ad112ffeb1cd8d7fe00b8c03ab2d8724483140" translate="yes" xml:space="preserve">
          <source>In addition, these warning options have meanings only for C++ programs:</source>
          <target state="translated">此外,这些警告选项只对C++程序有意义。</target>
        </trans-unit>
        <trans-unit id="9ebc6f9e6bacdd5dfc6bdf2f0b70b8aa1ddf9898" translate="yes" xml:space="preserve">
          <source>In all these variables, an empty element instructs the compiler to search its current working directory. Empty elements can appear at the beginning or end of a path. For instance, if the value of &lt;code&gt;CPATH&lt;/code&gt; is &lt;code&gt;:/special/include&lt;/code&gt;, that has the same effect as &amp;lsquo;</source>
          <target state="translated">在所有这些变量中，一个空元素指示编译器搜索其当前工作目录。空元素可以出现在路径的开头或结尾。例如，如果 &lt;code&gt;CPATH&lt;/code&gt; 的值为 &lt;code&gt;:/special/include&lt;/code&gt; ，则与'</target>
        </trans-unit>
        <trans-unit id="c45a725203acab43d85b1db22ebc2d67b4410490" translate="yes" xml:space="preserve">
          <source>In an application, for a function being called once, this attribute saves at least 8 bytes of code; and if other successive calls are being made to the same function, it saves 2 bytes of code per each of these calls.</source>
          <target state="translated">在一个应用程序中,对于一个被调用一次的函数,这个属性至少可以节省8个字节的代码;如果对同一个函数进行其他连续的调用,则每一次调用可以节省2个字节的代码。</target>
        </trans-unit>
        <trans-unit id="112621cd575ed0f9bd039d93d7933cb0a5997ed6" translate="yes" xml:space="preserve">
          <source>In both of these common cases, the program behaves the same as if you had not used the &lt;code&gt;inline&lt;/code&gt; keyword, except for its speed.</source>
          <target state="translated">在这两种常见情况下，该程序的行为与您未使用 &lt;code&gt;inline&lt;/code&gt; 关键字的行为相同，只是其速度不同。</target>
        </trans-unit>
        <trans-unit id="45ec19e142c4b27b0fe325e46bb4808fe673f706" translate="yes" xml:space="preserve">
          <source>In calls to a function declared with more than one &lt;code&gt;format_arg&lt;/code&gt; attribute, each with a distinct argument value, the corresponding actual function arguments are checked against all format strings designated by the attributes. This capability is designed to support the GNU &lt;code&gt;ngettext&lt;/code&gt; family of functions.</source>
          <target state="translated">在对使用多个 &lt;code&gt;format_arg&lt;/code&gt; 属性声明的函数的调用中，每个属性具有不同的参数值时，将根据属性指定的所有格式字符串检查相应的实际函数参数。此功能旨在支持GNU &lt;code&gt;ngettext&lt;/code&gt; 系列功能。</target>
        </trans-unit>
        <trans-unit id="02aea3bf160a5791ea88be98400d993055dab8e4" translate="yes" xml:space="preserve">
          <source>In case the target&amp;rsquo;s text segment can be made writable at run time by any means, padding the function entry with a number of NOPs can be used to provide a universal tool for instrumentation.</source>
          <target state="translated">如果可以在运行时通过任何方式使目标文本段可写，则可以在函数条目中填充大量NOP，以提供一种通用的工具。</target>
        </trans-unit>
        <trans-unit id="9874bbe3a17ce137014e4f267a820e02a459cd83" translate="yes" xml:space="preserve">
          <source>In common subexpression elimination (CSE), scan through jump instructions when the target of the jump is not reached by any other path. For example, when CSE encounters an &lt;code&gt;if&lt;/code&gt; statement with an &lt;code&gt;else&lt;/code&gt; clause, CSE follows the jump when the condition tested is false.</source>
          <target state="translated">在通用子表达式消除（CSE）中，当任何其他路径都未达到跳转目标时，请扫描跳转指令。例如，当CSE遇到带有 &lt;code&gt;else&lt;/code&gt; 子句的 &lt;code&gt;if&lt;/code&gt; 语句时，当测试的条件为false时，CSE跟随跳转。</target>
        </trans-unit>
        <trans-unit id="0d002f9e5ac95dd6140d2236721894e943a8d321" translate="yes" xml:space="preserve">
          <source>In common with many processors, the R10K tries to predict the outcome of a conditional branch and speculatively executes instructions from the &amp;ldquo;taken&amp;rdquo; branch. It later aborts these instructions if the predicted outcome is wrong. However, on the R10K, even aborted instructions can have side effects.</source>
          <target state="translated">与许多处理器一样，R10K尝试预测条件分支的结果，并推测性地执行&amp;ldquo; taked&amp;rdquo;分支中的指令。如果预测结果错误，则稍后中止这些指令。但是，在R10K上，即使中止的指令也会产生副作用。</target>
        </trans-unit>
        <trans-unit id="efdf71d142bfbc79dd5b3bcc72b386e56b413dad" translate="yes" xml:space="preserve">
          <source>In conjunction with</source>
          <target state="translated">结合</target>
        </trans-unit>
        <trans-unit id="55aaa1ae89f88214a90bc2fc53bf852861a0ee3c" translate="yes" xml:space="preserve">
          <source>In conjunction with an option such as</source>
          <target state="translated">与以下选项相结合,如</target>
        </trans-unit>
        <trans-unit id="133d5d5b4d70459f3ec35b8411d0a144d606b9d7" translate="yes" xml:space="preserve">
          <source>In contrast to the use of GP-relative addressing for small data, zero-based addressing is never generated by default and there are no conventional section names used in standard linker scripts for sections in the low or high areas of memory.</source>
          <target state="translated">与对小数据使用GP相关寻址不同的是,基于零的寻址在默认情况下从未生成,而且在标准链接器脚本中没有用于内存低区或高区的传统部分名称。</target>
        </trans-unit>
        <trans-unit id="6c721c449943a687c21935f7f759a9b08f371a66" translate="yes" xml:space="preserve">
          <source>In each case, the &lt;var&gt;value&lt;/var&gt; is an integer. The allowable choices for &lt;var&gt;name&lt;/var&gt; are:</source>
          <target state="translated">在每种情况下，该 &lt;var&gt;value&lt;/var&gt; 整数。 &lt;var&gt;name&lt;/var&gt; 的允许选择为：</target>
        </trans-unit>
        <trans-unit id="114b94c6fa09db558271708b17c4b748f9cd7a69" translate="yes" xml:space="preserve">
          <source>In each case, the &lt;var&gt;value&lt;/var&gt; is an integer. The following choices of &lt;var&gt;name&lt;/var&gt; are recognized for all targets:</source>
          <target state="translated">在每种情况下，该 &lt;var&gt;value&lt;/var&gt; 整数。所有目标均可识别以下 &lt;var&gt;name&lt;/var&gt; 选择：</target>
        </trans-unit>
        <trans-unit id="b8fca13e59c9eabf00cc2843d8091a8272a3dfca" translate="yes" xml:space="preserve">
          <source>In extremely rare cases involving some very large functions you may receive errors from the AIX Assembler complaining about a displacement that is too large. If you should run into it, you can work around by making your function smaller.</source>
          <target state="translated">在极少数情况下,涉及到一些非常大的函数时,你可能会收到AIX Assembler抱怨位移太大的错误。如果你遇到这种情况,你可以通过将函数变小来解决。</target>
        </trans-unit>
        <trans-unit id="2aed0db0e41463dc20e3d5ead025ac9ef7859b51" translate="yes" xml:space="preserve">
          <source>In extremely rare cases involving some very large functions you may receive errors from the HP linker complaining about an out of bounds unconditional branch offset. This used to occur more often in previous versions of GCC, but is now exceptionally rare. If you should run into it, you can work around by making your function smaller.</source>
          <target state="translated">在极少数情况下,涉及到一些非常大的函数时,你可能会收到HP链接器抱怨越界的无条件分支偏移的错误。这种情况在以前的GCC版本中经常发生,但现在已经非常罕见了。如果你遇到这种情况,你可以通过把你的函数变小来解决。</target>
        </trans-unit>
        <trans-unit id="00a48cd8543b2af5e751023419b48f45c985af5f" translate="yes" xml:space="preserve">
          <source>In general, code compiled with</source>
          <target state="translated">一般来说,用</target>
        </trans-unit>
        <trans-unit id="8355c0879f482055d04fc677fc9eeb1be4e895fa" translate="yes" xml:space="preserve">
          <source>In most cases, these built-in functions are considered a &lt;em&gt;full barrier&lt;/em&gt;. That is, no memory operand is moved across the operation, either forward or backward. Further, instructions are issued as necessary to prevent the processor from speculating loads across the operation and from queuing stores after the operation.</source>
          <target state="translated">在大多数情况下，这些内置功能被视为&lt;em&gt;完全障碍&lt;/em&gt;。也就是说，没有内存操作数在操作中向前或向后移动。此外，根据需要发出指令，以防止处理器推测整个操作的负载以及在操作之后排队存储。</target>
        </trans-unit>
        <trans-unit id="8dfbf43c73d9e540dd9c54a0b6d437a60ee32ec6" translate="yes" xml:space="preserve">
          <source>In new code it is better to use</source>
          <target state="translated">在新代码中,最好使用</target>
        </trans-unit>
        <trans-unit id="62929241db8cf48751f4d6a5beb9e5db94e0fcf8" translate="yes" xml:space="preserve">
          <source>In order to facilitate indirect jump on devices with more than 128 Ki bytes of program memory space, there is a special function register called &lt;code&gt;EIND&lt;/code&gt; that serves as most significant part of the target address when &lt;code&gt;EICALL&lt;/code&gt; or &lt;code&gt;EIJMP&lt;/code&gt; instructions are used.</source>
          <target state="translated">为了便于在程序存储空间超过128 Ki字节的设备上进行间接跳转，当使用 &lt;code&gt;EICALL&lt;/code&gt; 或 &lt;code&gt;EIJMP&lt;/code&gt; 指令时，有一个称为 &lt;code&gt;EIND&lt;/code&gt; 的特殊功能寄存器用作目标地址的最高有效部分。</target>
        </trans-unit>
        <trans-unit id="142019152633ff8b7d8e1d63884c100e78b27ae7" translate="yes" xml:space="preserve">
          <source>In order to get a warning about an unused function parameter, you must either specify</source>
          <target state="translated">为了得到一个未使用的函数参数的警告,你必须指定</target>
        </trans-unit>
        <trans-unit id="c494a40c1966ba85c60ab283de3d77a3dbd352eb" translate="yes" xml:space="preserve">
          <source>In order to get minimal, maximal and default value of a parameter, one can use</source>
          <target state="translated">为了获得参数的最小值、最大值和默认值,可以使用</target>
        </trans-unit>
        <trans-unit id="aac1d3e632375c3d26f5a99a3c3744709b4cc7cf" translate="yes" xml:space="preserve">
          <source>In order to make it clear that you want the member of the base class, you need to defer lookup until instantiation time, at which the base class is known. For this, you need to access &lt;code&gt;i&lt;/code&gt; in a dependent context, by either using &lt;code&gt;this-&amp;gt;i&lt;/code&gt; (remember that &lt;code&gt;this&lt;/code&gt; is of type &lt;code&gt;Derived&amp;lt;T&amp;gt;*&lt;/code&gt;, so is obviously dependent), or using &lt;code&gt;Base&amp;lt;T&amp;gt;::i&lt;/code&gt;. Alternatively, &lt;code&gt;Base&amp;lt;T&amp;gt;::i&lt;/code&gt; might be brought into scope by a &lt;code&gt;using&lt;/code&gt;-declaration.</source>
          <target state="translated">为了清楚表明您想要基类的成员，您需要将查找推迟到实例化时间为止，在该时间知道基类。对于这一点，需要访问 &lt;code&gt;i&lt;/code&gt; 在依赖于上下文，通过使用 &lt;code&gt;this-&amp;gt;i&lt;/code&gt; （记住， &lt;code&gt;this&lt;/code&gt; 是类型的 &lt;code&gt;Derived&amp;lt;T&amp;gt;*&lt;/code&gt; ，所以显然是相关的），或者使用 &lt;code&gt;Base&amp;lt;T&amp;gt;::i&lt;/code&gt; 。或者，可以通过 &lt;code&gt;using&lt;/code&gt; -declaration 将 &lt;code&gt;Base&amp;lt;T&amp;gt;::i&lt;/code&gt; 纳入范围。</target>
        </trans-unit>
        <trans-unit id="8d32cad4da98f43c6d843c991432c09408caaf0e" translate="yes" xml:space="preserve">
          <source>In order to preserve backtraces, GCC will never turn calls to &lt;code&gt;noreturn&lt;/code&gt; functions into tail calls.</source>
          <target state="translated">为了保留回溯，GCC绝不会将对 &lt;code&gt;noreturn&lt;/code&gt; 函数的调用转换为尾调用。</target>
        </trans-unit>
        <trans-unit id="8051ea04a019f5cadfa6ef75e3e8fdfb4199ab11" translate="yes" xml:space="preserve">
          <source>In order to use &lt;code&gt;_Float128&lt;/code&gt;, &lt;code&gt;__float128&lt;/code&gt;, and &lt;code&gt;__ibm128&lt;/code&gt; on PowerPC Linux systems, you must use the</source>
          <target state="translated">为了在PowerPC Linux系统上使用 &lt;code&gt;_Float128&lt;/code&gt; ， &lt;code&gt;__float128&lt;/code&gt; 和 &lt;code&gt;__ibm128&lt;/code&gt; ，必须使用</target>
        </trans-unit>
        <trans-unit id="0b53b26d6553c2df239324a926065719ab4a8ddb" translate="yes" xml:space="preserve">
          <source>In other words, this environment variable is equivalent to combining the options</source>
          <target state="translated">换句话说,这个环境变量相当于将选项</target>
        </trans-unit>
        <trans-unit id="60319e85faea62862eceee65393b98d81d541246" translate="yes" xml:space="preserve">
          <source>In particular, a caller function can inline a callee function only if the architectural features available to the callee are a subset of the features available to the caller. For example: A function &lt;code&gt;foo&lt;/code&gt; compiled with</source>
          <target state="translated">特别是，仅当被调用方可用的体系结构功能是调用方可用功能的子集时，调用方功能才能内联被调用方功能。例如：使用以下命令编译的函数 &lt;code&gt;foo&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="dfcf3dce47ea75abfa11b8f210c50bb328c92b22" translate="yes" xml:space="preserve">
          <source>In particular, in GNU C &amp;lsquo;</source>
          <target state="translated">特别是在GNU C'</target>
        </trans-unit>
        <trans-unit id="752fbae7c4ca268deafc3b5be65444a5caccc6bb" translate="yes" xml:space="preserve">
          <source>In particular, the following things, even if they can work in a particular case, are not guaranteed:</source>
          <target state="translated">尤其是以下事情,即使在特定的情况下能够发挥作用,也不能保证。</target>
        </trans-unit>
        <trans-unit id="fc7e4e23d46d87fd7427f9d533a75885300d9f17" translate="yes" xml:space="preserve">
          <source>In position-dependent code, a few targets also convert calls to functions that are marked to not use the PLT to use the GOT instead.</source>
          <target state="translated">在位置相关的代码中,少数目标也会将对那些标记为不使用PLT的函数的调用转换为使用GOT来代替。</target>
        </trans-unit>
        <trans-unit id="689474804d315625babc4fa837c13bb94860852e" translate="yes" xml:space="preserve">
          <source>In processor names, a final &amp;lsquo;</source>
          <target state="translated">在处理器名称中，最后一个'</target>
        </trans-unit>
        <trans-unit id="a2387332e373acd28cba30f5a2036e7dd3dc49b3" translate="yes" xml:space="preserve">
          <source>In situations where a character array is intended to store a sequence of bytes with no terminating &lt;code&gt;NUL&lt;/code&gt; such an array may be annotated with attribute &lt;code&gt;nonstring&lt;/code&gt; to avoid this warning. Such arrays, however, are not suitable arguments to functions that expect &lt;code&gt;NUL&lt;/code&gt;-terminated strings. To help detect accidental misuses of such arrays GCC issues warnings unless it can prove that the use is safe. See &lt;a href=&quot;common-variable-attributes#Common-Variable-Attributes&quot;&gt;Common Variable Attributes&lt;/a&gt;.</source>
          <target state="translated">在字符数组旨在存储不带任何终止 &lt;code&gt;NUL&lt;/code&gt; 的字节序列的情况下，可以使用属性 &lt;code&gt;nonstring&lt;/code&gt; 注释该数组，以避免出现此警告。但是，此类数组不适用于期望以 &lt;code&gt;NUL&lt;/code&gt; 终止的字符串的函数。为帮助检测意外滥用此类阵列，GCC会发出警告，除非可以证明使用是安全的。请参见&lt;a href=&quot;common-variable-attributes#Common-Variable-Attributes&quot;&gt;通用变量属性&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ecfec26cb0ac5a0a1c1e85b523feb3ed95ffb03b" translate="yes" xml:space="preserve">
          <source>In some cases, such as when the &lt;code&gt;packed&lt;/code&gt; attribute is applied to a structure field, it may not be possible to access the field with a single read or write that is correctly aligned for the target machine. In this case GCC falls back to generating multiple accesses rather than code that will fault or truncate the result at run time.</source>
          <target state="translated">在某些情况下，例如，当将 &lt;code&gt;packed&lt;/code&gt; 属性应用于结构字段时，可能无法使用针对目标计算机正确对齐的单个读取或写入来访问该字段。在这种情况下，GCC会退回到生成多个访问，而不是在运行时生成错误或截断结果的代码。</target>
        </trans-unit>
        <trans-unit id="6658650e6720d9733c30a8ad0be8becc792aaec5" translate="yes" xml:space="preserve">
          <source>In some other C compilers, an &lt;code&gt;extern&lt;/code&gt; declaration affects all the rest of the file even if it happens within a block.</source>
          <target state="translated">在其他一些C编译器中，即使文件内部发生在块中， &lt;code&gt;extern&lt;/code&gt; 声明也会影响文件的所有其余部分。</target>
        </trans-unit>
        <trans-unit id="c8c50a3ca24a6c45c0c4b47ae136e3f0a0a01c74" translate="yes" xml:space="preserve">
          <source>In some places, GCC uses various constants to control the amount of optimization that is done. For example, GCC does not inline functions that contain more than a certain number of instructions. You can control some of these constants on the command line using the</source>
          <target state="translated">在某些地方,GCC使用各种常量来控制优化的数量。例如,GCC不内联包含超过一定数量指令的函数。您可以在命令行中使用</target>
        </trans-unit>
        <trans-unit id="f69acb29f3e047877fe023942587da5b98d97826" translate="yes" xml:space="preserve">
          <source>In standard C, you are not allowed to leave the variable argument out entirely; but you are allowed to pass an empty argument. For example, this invocation is invalid in ISO C, because there is no comma after the string:</source>
          <target state="translated">在标准C语言中,你不允许完全不使用变量参数;但你可以传递一个空参数。例如,这个调用在ISO C中是无效的,因为字符串后面没有逗号。</target>
        </trans-unit>
        <trans-unit id="58989f3f4b9eea02c0ec4c1059a86cfbe8cdb94e" translate="yes" xml:space="preserve">
          <source>In the Alpha architecture, floating-point traps are imprecise. This means without software assistance it is impossible to recover from a floating trap and program execution normally needs to be terminated. GCC can generate code that can assist operating system trap handlers in determining the exact location that caused a floating-point trap. Depending on the requirements of an application, different levels of precisions can be selected:</source>
          <target state="translated">在Alpha架构中,浮点陷阱是不精确的。这意味着如果没有软件的帮助,就无法从浮点陷阱中恢复,通常需要终止程序的执行。GCC可以生成代码,帮助操作系统陷阱处理程序确定引起浮点陷阱的准确位置。根据应用程序的要求,可以选择不同的精度等级。</target>
        </trans-unit>
        <trans-unit id="6bf5f3b4f4b7b32e9468d2fe59cdb7f94586ed94" translate="yes" xml:space="preserve">
          <source>In the C++ frontend, when printing diagnostics showing mismatching template types, such as:</source>
          <target state="translated">在C++前端,当打印诊断结果显示模板类型不匹配时,如。</target>
        </trans-unit>
        <trans-unit id="30e98524998c5d7c58be11e9d977beb07b3f8a4e" translate="yes" xml:space="preserve">
          <source>In the ISO C standard of 1999, a macro can be declared to accept a variable number of arguments much as a function can. The syntax for defining the macro is similar to that of a function. Here is an example:</source>
          <target state="translated">在1999年的ISO C标准中,可以声明一个宏,像函数一样接受可变数量的参数。定义宏的语法与函数的语法相似。下面是一个例子。</target>
        </trans-unit>
        <trans-unit id="d2c1baab4661a523e3364f174cd970aa12806955" translate="yes" xml:space="preserve">
          <source>In the above example, &lt;var&gt;n&lt;/var&gt; could be negative, causing a larger than expected argument to be implicitly cast into the &lt;code&gt;alloca&lt;/code&gt; call.</source>
          <target state="translated">在上面的示例中， &lt;var&gt;n&lt;/var&gt; 可能为负，导致比预期参数大的隐式转换为 &lt;code&gt;alloca&lt;/code&gt; 调用。</target>
        </trans-unit>
        <trans-unit id="23d4340feaa11dd8e5b284a54d802e8107a80100" translate="yes" xml:space="preserve">
          <source>In the above example, four versions of function foo are created. The first version of foo with the target attribute &quot;default&quot; is the default version. This version gets executed when no other target specific version qualifies for execution on a particular platform. A new version of foo is created by using the same function signature but with a different target string. Function foo is called or a pointer to it is taken just like a regular function. GCC takes care of doing the dispatching to call the right version at runtime. Refer to the &lt;a href=&quot;http://gcc.gnu.org/wiki/FunctionMultiVersioning&quot;&gt;GCC wiki on Function Multiversioning&lt;/a&gt; for more details.</source>
          <target state="translated">在上面的示例中，创建了foo函数的四个版本。具有目标属性&amp;ldquo;默认&amp;rdquo;的foo的第一个版本是默认版本。当没有其他目标特定版本符合在特定平台上执行的条件时，将执行此版本。通过使用相同的函数签名但目标字符串不同来创建foo的新版本。就像常规函数一样，将调用函数foo或使用指向它的指针。 GCC负责在运行时进行调度以调用正确的版本。有关更多详细信息，请参见&lt;a href=&quot;http://gcc.gnu.org/wiki/FunctionMultiVersioning&quot;&gt;GCC Wiki上的Function Multiversioning&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a1bff041cccec6e7eb7b11056100ded2af52d7c9" translate="yes" xml:space="preserve">
          <source>In the above example, passing &lt;code&gt;-Walloca-larger-than=1000&lt;/code&gt; would not issue a warning because the call to &lt;code&gt;alloca&lt;/code&gt; is known to be at most 1000 bytes. However, if &lt;code&gt;-Walloca-larger-than=500&lt;/code&gt; were passed, the compiler would emit a warning.</source>
          <target state="translated">在上面的示例中，传递 &lt;code&gt;-Walloca-larger-than=1000&lt;/code&gt; 不会发出警告，因为已知对 &lt;code&gt;alloca&lt;/code&gt; 的调用最多为1000个字节。但是，如果 &lt;code&gt;-Walloca-larger-than=500&lt;/code&gt; ，则编译器将发出警告。</target>
        </trans-unit>
        <trans-unit id="332968dc71142314e45ea6ca9e33a5109f2af711" translate="yes" xml:space="preserve">
          <source>In the absence of the zero-length array extension, in ISO C90 the &lt;code&gt;contents&lt;/code&gt; array in the example above would typically be declared to have a single element. Unlike a zero-length array which only contributes to the size of the enclosing structure for the purposes of alignment, a one-element array always occupies at least as much space as a single object of the type. Although using one-element arrays this way is discouraged, GCC handles accesses to trailing one-element array members analogously to zero-length arrays.</source>
          <target state="translated">在没有零长度数组扩展名的情况下，在ISO C90 中，通常将上述示例中的 &lt;code&gt;contents&lt;/code&gt; 数组声明为具有单个元素。与零长度的数组仅出于对齐目的而影响封闭结构的大小不同，单元素数组始终至少占用与该类型的单个对象一样多的空间。尽管不鼓励以这种方式使用一元素数组，但GCC类似于零长度数组，处理对尾随一元素数组成员的访问。</target>
        </trans-unit>
        <trans-unit id="c5606a80dd3681d695be85b469a76a47b51736f5" translate="yes" xml:space="preserve">
          <source>In the body of &lt;code&gt;fn&lt;/code&gt;, &lt;var&gt;rptr&lt;/var&gt; points to an unaliased integer and &lt;var&gt;rref&lt;/var&gt; refers to a (different) unaliased integer.</source>
          <target state="translated">在 &lt;code&gt;fn&lt;/code&gt; 的主体中， &lt;var&gt;rptr&lt;/var&gt; 指向一个非别名的整数， &lt;var&gt;rref&lt;/var&gt; 指向一个（不同的）非别名的整数。</target>
        </trans-unit>
        <trans-unit id="72adaffc52e227090554b141dc851c2ba2acd228" translate="yes" xml:space="preserve">
          <source>In the call to &lt;code&gt;f1&lt;/code&gt; inside &lt;code&gt;f2&lt;/code&gt;, the pointer &lt;code&gt;p&lt;/code&gt; is converted into a pointer to the anonymous field.</source>
          <target state="translated">在调用 &lt;code&gt;f1&lt;/code&gt; 内 &lt;code&gt;f2&lt;/code&gt; ，指针 &lt;code&gt;p&lt;/code&gt; 被转换成一个指针到匿名字段。</target>
        </trans-unit>
        <trans-unit id="0a8054866654e30e64690afd790ea604bf91b2c2" translate="yes" xml:space="preserve">
          <source>In the case of mixed tabs and spaces, the warning uses the</source>
          <target state="translated">在混合使用制表符和空格的情况下,警告使用的是</target>
        </trans-unit>
        <trans-unit id="ad595b872596498a83b3124d23704c11425d8f05" translate="yes" xml:space="preserve">
          <source>In the case of the &lt;code&gt;section&lt;/code&gt; attribute, the section name given will be used, and the &lt;code&gt;.lower&lt;/code&gt; prefix will not be added.</source>
          <target state="translated">对于 &lt;code&gt;section&lt;/code&gt; 属性，将使用给定的部分名称，并且不会添加 &lt;code&gt;.lower&lt;/code&gt; 前缀。</target>
        </trans-unit>
        <trans-unit id="668ede8f3b6b3725bfdad3d893282dd8102b4a7b" translate="yes" xml:space="preserve">
          <source>In the example above, if the size of each &lt;code&gt;short&lt;/code&gt; is 2 bytes, then the size of the entire &lt;code&gt;struct S&lt;/code&gt; type is 6 bytes. The smallest power of two that is greater than or equal to that is 8, so the compiler sets the alignment for the entire &lt;code&gt;struct S&lt;/code&gt; type to 8 bytes.</source>
          <target state="translated">在上面的示例中，如果每个 &lt;code&gt;short&lt;/code&gt; 的大小为2个字节，则整个 &lt;code&gt;struct S&lt;/code&gt; 类型的大小为6个字节。大于或等于8的2的最小乘方，因此编译器将整个 &lt;code&gt;struct S&lt;/code&gt; 类型的对齐方式设置为8个字节。</target>
        </trans-unit>
        <trans-unit id="d611872451077c2adcf065d60aa97d23e192a616" translate="yes" xml:space="preserve">
          <source>In the example above, the format string (&lt;code&gt;my_format&lt;/code&gt;) is the second argument of the function &lt;code&gt;my_print&lt;/code&gt;, and the arguments to check start with the third argument, so the correct parameters for the format attribute are 2 and 3.</source>
          <target state="translated">在上面的示例中，格式字符串（ &lt;code&gt;my_format&lt;/code&gt; ）是函数 &lt;code&gt;my_print&lt;/code&gt; 的第二个参数，要检查的参数从第三个参数开始，因此format属性的正确参数是2和3。</target>
        </trans-unit>
        <trans-unit id="c81e2f387793e8f74907d44b15263e2ac578ba9c" translate="yes" xml:space="preserve">
          <source>In the following example 2 bytes are saved for each call to function &lt;code&gt;foo&lt;/code&gt;.</source>
          <target state="translated">在下面的示例中，每次调用 &lt;code&gt;foo&lt;/code&gt; 时将保存2个字节。</target>
        </trans-unit>
        <trans-unit id="f2582be090e1c1dbe5968b20143ec726da1f7d9e" translate="yes" xml:space="preserve">
          <source>In the following example &lt;code&gt;struct my_packed_struct&lt;/code&gt;&amp;rsquo;s members are packed closely together, but the internal layout of its &lt;code&gt;s&lt;/code&gt; member is not packed&amp;mdash;to do that, &lt;code&gt;struct my_unpacked_struct&lt;/code&gt; needs to be packed too.</source>
          <target state="translated">在下面的示例中， &lt;code&gt;struct my_packed_struct&lt;/code&gt; 的成员紧密打包在一起，但是其 &lt;code&gt;s&lt;/code&gt; 成员的内部布局没有打包，为此， &lt;code&gt;struct my_unpacked_struct&lt;/code&gt; 也需要打包。</target>
        </trans-unit>
        <trans-unit id="2ad9bba785d38d1a703efec0ed08be1c07a3d9c1" translate="yes" xml:space="preserve">
          <source>In the following example, &lt;code&gt;A&lt;/code&gt; would normally be created before &lt;code&gt;B&lt;/code&gt;, but the &lt;code&gt;init_priority&lt;/code&gt; attribute reverses that order:</source>
          <target state="translated">在以下示例中， &lt;code&gt;A&lt;/code&gt; 通常将之前创建 &lt;code&gt;B&lt;/code&gt; ，但 &lt;code&gt;init_priority&lt;/code&gt; 属性反转顺序：</target>
        </trans-unit>
        <trans-unit id="eab6b57c27507ae55bdb9c6e5a0691baa5974d49" translate="yes" xml:space="preserve">
          <source>In the following example, the call to &amp;ldquo;bar&amp;rdquo; is misleadingly indented as if it were guarded by the &amp;ldquo;if&amp;rdquo; conditional.</source>
          <target state="translated">在以下示例中，对&amp;ldquo; bar&amp;rdquo;的调用被误导了缩进，好像它受到&amp;ldquo; if&amp;rdquo;条件的保护。</target>
        </trans-unit>
        <trans-unit id="5d55b7c384eed91ea4e21f8b8e99933dea2beab9" translate="yes" xml:space="preserve">
          <source>In the following example, the call to &lt;code&gt;strncat&lt;/code&gt; specifies a bound that is less than the length of the source string. As a result, the copy of the source will be truncated and so the call is diagnosed. To avoid the warning use &lt;code&gt;bufsize - strlen (buf) - 1)&lt;/code&gt; as the bound.</source>
          <target state="translated">在下面的示例中，对 &lt;code&gt;strncat&lt;/code&gt; 的调用指定的界限小于源字符串的长度。结果，源的副本将被截断，因此将诊断呼叫。为避免警告，请使用 &lt;code&gt;bufsize - strlen (buf) - 1)&lt;/code&gt; 作为界限。</target>
        </trans-unit>
        <trans-unit id="99023364872044963c7ac2454f86695e7bf39529" translate="yes" xml:space="preserve">
          <source>In the following example, the call to &lt;code&gt;strncpy&lt;/code&gt; specifies the size of the destination buffer as the bound. If the length of the source string is equal to or greater than this size the result of the copy will not be NUL-terminated. Therefore, the call is also diagnosed. To avoid the warning, specify &lt;code&gt;sizeof buf - 1&lt;/code&gt; as the bound and set the last element of the buffer to &lt;code&gt;NUL&lt;/code&gt;.</source>
          <target state="translated">在下面的示例中，对 &lt;code&gt;strncpy&lt;/code&gt; 的调用将目标缓冲区的大小指定为边界。如果源字符串的长度等于或大于此大小，则副本的结果将不会以NUL终止。因此，该呼叫也被诊断。为避免警告，将 &lt;code&gt;sizeof buf - 1&lt;/code&gt; 指定为界限，并将缓冲区的最后一个元素设置为 &lt;code&gt;NUL&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b2205cf9915c94cb78e3ab81cd7cb0eabf600a0e" translate="yes" xml:space="preserve">
          <source>In the following example, the optimization info is output to</source>
          <target state="translated">在下面的例子中,优化信息被输出至</target>
        </trans-unit>
        <trans-unit id="090624bc5f542a6200f2b5db31c7a96042440439" translate="yes" xml:space="preserve">
          <source>In the future, GCC may ignore all longcall specifications when the linker is known to generate glue.</source>
          <target state="translated">未来,当已知链接器会产生胶水时,GCC可能会忽略所有的长调用规范。</target>
        </trans-unit>
        <trans-unit id="9b65ba979b01328e9229388df23c21da9df9f6b9" translate="yes" xml:space="preserve">
          <source>In the past, the GNU C++ compiler was extended to experiment with new features, at a time when the C++ language was still evolving. Now that the C++ standard is complete, some of those features are superseded by superior alternatives. Using the old features might cause a warning in some cases that the feature will be dropped in the future. In other cases, the feature might be gone already.</source>
          <target state="translated">过去,在C++语言还在不断发展的时候,GNU C++编译器被扩展为试验新功能。现在,C++标准已经完成,其中一些特性已经被更优秀的替代品所取代。在某些情况下,使用旧的特性可能会引起一个警告,即该特性将来会被放弃。在其他情况下,该功能可能已经消失了。</target>
        </trans-unit>
        <trans-unit id="2ec007d1b8fb8c7647c245995b76441efba1c6d6" translate="yes" xml:space="preserve">
          <source>In the situation where no matching handler is found, it is implementation-defined whether or not the stack is unwound before std::terminate() is called (C++98 15.5.1).</source>
          <target state="translated">在没有找到匹配的处理程序的情况下,在调用std::terminate()之前,栈是否被释放是由实现定义的(C++98 15.5.1)。</target>
        </trans-unit>
        <trans-unit id="2b3b9b011b7a600b4b0a236d7a6052525d44af3c" translate="yes" xml:space="preserve">
          <source>In the x86-64 compiler,</source>
          <target state="translated">在x86-64编译器中。</target>
        </trans-unit>
        <trans-unit id="69fa1e0803241118d47ffd49449baa41bc17a296" translate="yes" xml:space="preserve">
          <source>In this case, &lt;code&gt;PRId64&lt;/code&gt; is treated as a separate preprocessing token.</source>
          <target state="translated">在这种情况下， &lt;code&gt;PRId64&lt;/code&gt; 被视为单独的预处理令牌。</target>
        </trans-unit>
        <trans-unit id="5e608c39601145b6331e6e0d1f6c70cd4fe12595" translate="yes" xml:space="preserve">
          <source>In this code, &lt;code&gt;C::C&lt;/code&gt; is exported from the current DLL, but the virtual table for &lt;code&gt;C&lt;/code&gt; is not exported. (You can use &lt;code&gt;__attribute__&lt;/code&gt; instead of &lt;code&gt;__declspec&lt;/code&gt; if you prefer, but most Symbian OS code uses &lt;code&gt;__declspec&lt;/code&gt;.)</source>
          <target state="translated">在此代码中， &lt;code&gt;C::C&lt;/code&gt; 是从当前DLL导出的，但是 &lt;code&gt;C&lt;/code&gt; 的虚拟表未导出。（如果愿意，可以使用 &lt;code&gt;__attribute__&lt;/code&gt; 代替 &lt;code&gt;__declspec&lt;/code&gt; ，但是大多数Symbian OS代码使用 &lt;code&gt;__declspec&lt;/code&gt; 。）</target>
        </trans-unit>
        <trans-unit id="cf74d98117e616fffd8931f1489225a69f862b46" translate="yes" xml:space="preserve">
          <source>In this example &lt;code&gt;target(&quot;+crc+nocrypto&quot;)&lt;/code&gt; enables the &lt;code&gt;crc&lt;/code&gt; extension and disables the &lt;code&gt;crypto&lt;/code&gt; extension for the function &lt;code&gt;foo&lt;/code&gt; without modifying an existing</source>
          <target state="translated">在此示例中， &lt;code&gt;target(&quot;+crc+nocrypto&quot;)&lt;/code&gt; 启用 &lt;code&gt;crc&lt;/code&gt; 扩展并禁用函数 &lt;code&gt;foo&lt;/code&gt; 的 &lt;code&gt;crypto&lt;/code&gt; 扩展，而无需修改现有的</target>
        </trans-unit>
        <trans-unit id="58a4adc7d0429a642a388d8bfe0b7fe702edd6d4" translate="yes" xml:space="preserve">
          <source>In this example using the fictitious &lt;code&gt;combine&lt;/code&gt; instruction, the constraint &lt;code&gt;&quot;0&quot;&lt;/code&gt; for input operand 1 says that it must occupy the same location as output operand 0. Only input operands may use numbers in constraints, and they must each refer to an output operand. Only a number (or the symbolic assembler name) in the constraint can guarantee that one operand is in the same place as another. The mere fact that &lt;code&gt;foo&lt;/code&gt; is the value of both operands is not enough to guarantee that they are in the same place in the generated assembler code.</source>
          <target state="translated">在使用虚拟 &lt;code&gt;combine&lt;/code&gt; 指令的示例中，输入操作数1 的约束 &lt;code&gt;&quot;0&quot;&lt;/code&gt; 表示它必须与输出操作数0占据相同的位置。只有输入操作数可以在约束中使用数字，并且它们每个都必须引用输出操作数。约束中只有数字（或符号汇编程序名称）可以保证一个操作数与另一个操作数位于同一位置。仅 &lt;code&gt;foo&lt;/code&gt; 是两个操作数的值这一事实不足以保证它们在生成的汇编代码中位于同一位置。</target>
        </trans-unit>
        <trans-unit id="520980bd6ea541d3639c3a33ef889a8d9a6daa19" translate="yes" xml:space="preserve">
          <source>In this example,</source>
          <target state="translated">在这个例子中。</target>
        </trans-unit>
        <trans-unit id="319dc8c090a6daef3a9c5df24c2d9cdc65374743" translate="yes" xml:space="preserve">
          <source>In this example, copy elision isn&amp;rsquo;t applicable because the type of the expression being returned and the function return type differ, yet G++ treats the return value as if it were designated by an rvalue.</source>
          <target state="translated">在此示例中，复制省略不适用，因为返回的表达式类型和函数返回类型不同，但是G ++会将返回值视为由右值指定。</target>
        </trans-unit>
        <trans-unit id="4e8bd971ddd095859a278a42bd750e7f78bf378c" translate="yes" xml:space="preserve">
          <source>In this example, only</source>
          <target state="translated">在这个例子中,只有</target>
        </trans-unit>
        <trans-unit id="9d08184dfe71cd797666be2ee4c2240b6d577d4d" translate="yes" xml:space="preserve">
          <source>In this example, the definition of X as 1 is saved by &lt;code&gt;#pragma
push_macro&lt;/code&gt; and restored by &lt;code&gt;#pragma pop_macro&lt;/code&gt;.</source>
          <target state="translated">在此实例中，X为1的定义是由保存 &lt;code&gt;#pragma push_macro&lt;/code&gt; 和由恢复 &lt;code&gt;#pragma pop_macro&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="21ecdc81f33fba4861729ef952b0d8145291cd18" translate="yes" xml:space="preserve">
          <source>In this example, the initialization of &lt;code&gt;Stdin&lt;/code&gt;, &lt;code&gt;Stdout&lt;/code&gt; and &lt;code&gt;Stderr&lt;/code&gt; in &lt;code&gt;+initialize&lt;/code&gt; occurs too late. The programmer can send a message to one of these objects before the variables are actually initialized, thus sending messages to the &lt;code&gt;nil&lt;/code&gt; object. The &lt;code&gt;+initialize&lt;/code&gt; method which actually initializes the global variables is not invoked until the first message is sent to the class object. The solution would require these variables to be initialized just before entering &lt;code&gt;main&lt;/code&gt;.</source>
          <target state="translated">在这个例子中，初始化 &lt;code&gt;Stdin&lt;/code&gt; ， &lt;code&gt;Stdout&lt;/code&gt; 和 &lt;code&gt;Stderr&lt;/code&gt; 在 &lt;code&gt;+initialize&lt;/code&gt; 时为时已晚。程序员可以在变量实际初始化之前将消息发送到这些对象之一，从而将消息发送到 &lt;code&gt;nil&lt;/code&gt; 对象。在将第一条消息发送到类对象之前，不会调用实际初始化全局变量的 &lt;code&gt;+initialize&lt;/code&gt; 方法。解决方案将要求在输入 &lt;code&gt;main&lt;/code&gt; 之前初始化这些变量。</target>
        </trans-unit>
        <trans-unit id="9aaba03579077debce898734e55c1aab4715c942" translate="yes" xml:space="preserve">
          <source>In this example, using the &lt;code&gt;restrict&lt;/code&gt; qualifier had the same effect. In the following example, that would not be possible. Assume &lt;em&gt;k &amp;lt; -m&lt;/em&gt; or &lt;em&gt;k &amp;gt;= m&lt;/em&gt;. Only with the pragma, the compiler knows that it can unconditionally vectorize the following loop:</source>
          <target state="translated">在此示例中，使用 &lt;code&gt;restrict&lt;/code&gt; 限定符具有相同的效果。在以下示例中，这是不可能的。假设&lt;em&gt;k &amp;lt;-m&lt;/em&gt;或&lt;em&gt;k&amp;gt; = m&lt;/em&gt;。只有有了编译指示，编译器才能知道它可以无条件地向量化以下循环：</target>
        </trans-unit>
        <trans-unit id="faacd98f76b275362fdf70ef063e37d5684ab5f2" translate="yes" xml:space="preserve">
          <source>In this example, you are able to access members of the unnamed union with code like &amp;lsquo;</source>
          <target state="translated">在此示例中，您可以使用以下代码访问未命名联合的成员：</target>
        </trans-unit>
        <trans-unit id="11ec4b5f708bff6df3841d797062db8a50e96ffa" translate="yes" xml:space="preserve">
          <source>In this i386 example, &lt;code&gt;old&lt;/code&gt; (referred to in the template string as &lt;code&gt;%0&lt;/code&gt;) and &lt;code&gt;*Base&lt;/code&gt; (as &lt;code&gt;%1&lt;/code&gt;) are outputs and &lt;code&gt;Offset&lt;/code&gt; (&lt;code&gt;%2&lt;/code&gt;) is an input:</source>
          <target state="translated">在此i386示例中， &lt;code&gt;old&lt;/code&gt; （在模板字符串中称为 &lt;code&gt;%0&lt;/code&gt; ）和 &lt;code&gt;*Base&lt;/code&gt; （作为 &lt;code&gt;%1&lt;/code&gt; ）是输出，而 &lt;code&gt;Offset&lt;/code&gt; （ &lt;code&gt;%2&lt;/code&gt; ）是输入：</target>
        </trans-unit>
        <trans-unit id="baf1ef107e11e79f68ce627953735497e89d197f" translate="yes" xml:space="preserve">
          <source>In this mode, each basic block is only shown on one line &amp;ndash; the last line of the block. A multi-line block will only contribute to the execution count of that last line, and other lines will not be shown to contain code, unless previous blocks end on those lines. The total execution count of a line is shown and subsequent lines show the execution counts for individual blocks that end on that line. After each block, the branch and call counts of the block will be shown, if the</source>
          <target state="translated">在此模式下，每个基本块仅显示在一行（块的最后一行）上。多行块只会增加最后一行的执行计数，其他行不会显示为包含代码，除非先前的块在这些行上结束。显示了一行的总执行计数，随后的行显示了在该行结束的各个块的执行计数。在每个块之后，将显示该块的分支和调用计数，如果</target>
        </trans-unit>
        <trans-unit id="f98f506a6c9d396979e78ddb03cc339a44caf644" translate="yes" xml:space="preserve">
          <source>In this simple case, the ability to omit the middle operand is not especially useful. When it becomes useful is when the first operand does, or may (if it is a macro argument), contain a side effect. Then repeating the operand in the middle would perform the side effect twice. Omitting the middle operand uses the value already computed without the undesirable effects of recomputing it.</source>
          <target state="translated">在这种简单的情况下,省略中间操作数的能力不是特别有用。当它变得有用的时候,是当第一个操作数确实或可能(如果它是一个宏参数),包含一个副作用。那么重复中间的操作数就会两次执行副效应。省略中间的操作数会使用已经计算出来的值,而不会产生重新计算的不良后果。</target>
        </trans-unit>
        <trans-unit id="30850ac01d9d951fde54525545edac5180129639" translate="yes" xml:space="preserve">
          <source>In this situation, it may seem reasonable to save a pointer to the C string returned by the &lt;code&gt;c_str&lt;/code&gt; member function and use that rather than call &lt;code&gt;c_str&lt;/code&gt; repeatedly. However, the temporary string created by the call to &lt;code&gt;strfunc&lt;/code&gt; is destroyed after &lt;code&gt;p&lt;/code&gt; is initialized, at which point &lt;code&gt;p&lt;/code&gt; is left pointing to freed memory.</source>
          <target state="translated">在这种情况下，保存指向由 &lt;code&gt;c_str&lt;/code&gt; 成员函数返回的C字符串的指针并使用该指针而不是重复调用 &lt;code&gt;c_str&lt;/code&gt; 似乎是合理的。但是，初始化 &lt;code&gt;p&lt;/code&gt; 之后，销毁 &lt;code&gt;strfunc&lt;/code&gt; 所创建的临时字符串将被销毁，此时 &lt;code&gt;p&lt;/code&gt; 仍指向释放的内存。</target>
        </trans-unit>
        <trans-unit id="9c79c74c33310ccb6338d0595028b7084d9d04e6" translate="yes" xml:space="preserve">
          <source>In traditional C, some preprocessor directives did not exist. Traditional preprocessors only considered a line to be a directive if the &amp;lsquo;</source>
          <target state="translated">在传统的C语言中，不存在某些预处理程序指令。传统预处理器仅在以下情况下将行视为指令：</target>
        </trans-unit>
        <trans-unit id="af6d48f148638b92ad84fcdf9e5cab97ac9e3711" translate="yes" xml:space="preserve">
          <source>In traditional C, you can combine &lt;code&gt;long&lt;/code&gt;, etc., with a typedef name, as shown here:</source>
          <target state="translated">在传统C语言中，您可以将 &lt;code&gt;long&lt;/code&gt; 等与typedef名称结合使用，如下所示：</target>
        </trans-unit>
        <trans-unit id="337c46940ff663b0e38af630f4ae21daa389738f" translate="yes" xml:space="preserve">
          <source>Include path specified with &lt;code&gt;-I&lt;/code&gt; and &lt;code&gt;-L&lt;/code&gt;</source>
          <target state="translated">包含用 &lt;code&gt;-I&lt;/code&gt; 和 &lt;code&gt;-L&lt;/code&gt; 指定的路径</target>
        </trans-unit>
        <trans-unit id="a6cc27c788d1407147380009a18cb3a8d2d00752" translate="yes" xml:space="preserve">
          <source>Includes by default</source>
          <target state="translated">包括默认的</target>
        </trans-unit>
        <trans-unit id="ba953d2d262b9f5a9a993ae297fa4814ea4c549d" translate="yes" xml:space="preserve">
          <source>Increase the minimum alignment of each &lt;var&gt;variable&lt;/var&gt; to &lt;var&gt;alignment&lt;/var&gt;. This is the same as GCC&amp;rsquo;s &lt;code&gt;aligned&lt;/code&gt; attribute see &lt;a href=&quot;variable-attributes#Variable-Attributes&quot;&gt;Variable Attributes&lt;/a&gt;). Macro expansion occurs on the arguments to this pragma when compiling C and Objective-C. It does not currently occur when compiling C++, but this is a bug which may be fixed in a future release.</source>
          <target state="translated">将每个 &lt;var&gt;variable&lt;/var&gt; 的最小对齐方式增加到 &lt;var&gt;alignment&lt;/var&gt; 。这与GCC的 &lt;code&gt;aligned&lt;/code&gt; 属性相同（请参见&lt;a href=&quot;variable-attributes#Variable-Attributes&quot;&gt;变量属性&lt;/a&gt;）。编译C和Objective-C时，对此指令的参数进行宏扩展。目前在编译C ++时不发生此错误，但这是一个错误，将来的版本中可能会修复该错误。</target>
        </trans-unit>
        <trans-unit id="3a36ae001267163487813c67072e72529ac1fc44" translate="yes" xml:space="preserve">
          <source>Increment the current shadow stack pointer by the size specified by the function argument. The argument is masked to a byte value for security reasons, so to increment by more than 255 bytes you must call the function multiple times.</source>
          <target state="translated">按函数参数指定的大小递增当前影子堆栈指针。为了安全起见,参数被屏蔽为一个字节值,所以如果要增加超过255个字节,必须多次调用该函数。</target>
        </trans-unit>
        <trans-unit id="a77ff871b762622ee18fb03c8d6e4821448c4ba7" translate="yes" xml:space="preserve">
          <source>Index of concepts and symbol names.</source>
          <target state="translated">概念和符号名称的索引。</target>
        </trans-unit>
        <trans-unit id="fc043d0a8b4563d771d031e44dbc955b74387769" translate="yes" xml:space="preserve">
          <source>Index to command line options.</source>
          <target state="translated">命令行选项的索引。</target>
        </trans-unit>
        <trans-unit id="420ef9e906b8f54c4b93394265974a605cf160bb" translate="yes" xml:space="preserve">
          <source>Indicate target register priority for r0..r3 / r12..r15.</source>
          <target state="translated">表示r0...r3/r12...r15的目标寄存器优先级。</target>
        </trans-unit>
        <trans-unit id="d7462beabb9f4e989c2289174fc3246820893fad" translate="yes" xml:space="preserve">
          <source>Indicate to the linker that it should perform a relaxation optimization pass to shorten branches, calls and absolute memory addresses. This option only has an effect when used on the command line for the final link step.</source>
          <target state="translated">向链接器表明它应该执行一个放松优化通道,以缩短分支、调用和绝对内存地址。这个选项只有在命令行中用于最后的链接步骤时才有效果。</target>
        </trans-unit>
        <trans-unit id="6fbdf91a468c725e57cb1a980eb023240915fbde" translate="yes" xml:space="preserve">
          <source>Indicate to the preprocessor that the input file has already been preprocessed. This suppresses things like macro expansion, trigraph conversion, escaped newline splicing, and processing of most directives. The preprocessor still recognizes and removes comments, so that you can pass a file preprocessed with</source>
          <target state="translated">向预处理器表明输入文件已经被预处理。这将抑制诸如宏扩展、三段式转换、转义换行拼接以及大多数指令的处理。预处理器仍然会识别和删除注释,因此你可以将一个已经用</target>
        </trans-unit>
        <trans-unit id="68073a6ddfa5de56b268fec01a6e6dd0d5ff13eb" translate="yes" xml:space="preserve">
          <source>Indicate whether GCC should generate code to use the optional BWX, CIX, FIX and MAX instruction sets. The default is to use the instruction sets supported by the CPU type specified via</source>
          <target state="translated">指定GCC是否应该生成使用可选的BWX、CIX、FIX和MAX指令集的代码。默认情况下,使用通过</target>
        </trans-unit>
        <trans-unit id="be40fe5ecac7625ba1093b2709ac8dc3be8fddd9" translate="yes" xml:space="preserve">
          <source>Indicates that code should be generated for a particular code model for this function. The behavior and permissible arguments are the same as for the command line option</source>
          <target state="translated">表示应该为这个函数的特定代码模型生成代码。其行为和允许的参数与命令行选项的相同。</target>
        </trans-unit>
        <trans-unit id="b7d51ac61701200efc681b006d913292e4425e50" translate="yes" xml:space="preserve">
          <source>Indicates that no floating-point or Advanced SIMD registers should be used when generating code for this function. If the function explicitly uses floating-point code, then the compiler gives an error. This is the same behavior as that of the command-line option</source>
          <target state="translated">表示在生成该函数的代码时,不应使用浮点或高级SIMD寄存器。如果函数明确使用了浮点代码,那么编译器会给出一个错误。这与命令行选项的行为相同。</target>
        </trans-unit>
        <trans-unit id="96da1f4a760883d4e09985b3e134953d179eb7dd" translate="yes" xml:space="preserve">
          <source>Indicates that the frame pointer should be omitted for a leaf function call. To keep the frame pointer, the inverse attribute &lt;code&gt;no-omit-leaf-frame-pointer&lt;/code&gt; can be specified. These attributes have the same behavior as the command-line options</source>
          <target state="translated">指示叶函数调用应省略帧指针。为了保留帧指针，可以指定反向属性 &lt;code&gt;no-omit-leaf-frame-pointer&lt;/code&gt; 。这些属性与命令行选项具有相同的行为</target>
        </trans-unit>
        <trans-unit id="fee4cd3e78cab50081b4e8f5d0006d9ed8234377" translate="yes" xml:space="preserve">
          <source>Indicates that the workaround for the Cortex-A53 erratum 835769 should be applied to this function. To explicitly disable the workaround for this function specify the negated form: &lt;code&gt;no-fix-cortex-a53-835769&lt;/code&gt;. This corresponds to the behavior of the command line options</source>
          <target state="translated">表示应将Cortex-A53勘误835769的变通办法应用于此功能。要明确禁用此功能的解决方法，请指定否定形式： &lt;code&gt;no-fix-cortex-a53-835769&lt;/code&gt; 。这对应于命令行选项的行为</target>
        </trans-unit>
        <trans-unit id="aeccc2135e57d183072ddb1eb0451783b85ba84e" translate="yes" xml:space="preserve">
          <source>Indicates that there is no OS function for flushing the cache.</source>
          <target state="translated">表示没有刷新缓存的操作系统功能。</target>
        </trans-unit>
        <trans-unit id="3b9239fee5592f778e9dc693d4e38e7027710f85" translate="yes" xml:space="preserve">
          <source>Indirect functions cannot be weak. Binutils version 2.20.1 or higher and GNU C Library version 2.11.1 are required to use this feature.</source>
          <target state="translated">间接函数不能是弱函数。使用此功能需要Binutils 2.20.1或更高版本和GNU C库2.11.1版本。</target>
        </trans-unit>
        <trans-unit id="0a81ae1d4de3c814c6c4d2e18a5c858ca409fcdb" translate="yes" xml:space="preserve">
          <source>Indirect jumps and calls on these devices are handled as follows by the compiler and are subject to some limitations:</source>
          <target state="translated">这些设备上的间接跳转和调用由编译器按如下方式处理,并受到一些限制。</target>
        </trans-unit>
        <trans-unit id="9f398b6aa8bfe6a67d6b37c29d0d17a413b5679b" translate="yes" xml:space="preserve">
          <source>Inefficiency: because of both the modified allocation strategy and the generic implementation, code performance is hampered.</source>
          <target state="translated">效率低下:由于修改后的分配策略和通用实现,代码性能受到影响。</target>
        </trans-unit>
        <trans-unit id="102a9633450074424f655c619be378c7b15f449d" translate="yes" xml:space="preserve">
          <source>Inform the compiler that the assembler supports &lt;code&gt;.loc&lt;/code&gt; directives. It may then use them for the assembler to generate DWARF2+ line number tables.</source>
          <target state="translated">通知编译器汇编器支持 &lt;code&gt;.loc&lt;/code&gt; 指令。然后，可以将它们用于汇编程序以生成DWARF2 +行号表。</target>
        </trans-unit>
        <trans-unit id="25aeb41e0e10d4686e4fd03645c7ee0ccf628c50" translate="yes" xml:space="preserve">
          <source>Inform the compiler that the assembler supports &lt;code&gt;view&lt;/code&gt; assignment and reset assertion checking in &lt;code&gt;.loc&lt;/code&gt; directives.</source>
          <target state="translated">通知编译器汇编器支持 &lt;code&gt;view&lt;/code&gt; 分配并重置 &lt;code&gt;.loc&lt;/code&gt; 指令中的断言检查。</target>
        </trans-unit>
        <trans-unit id="b50c3134100dc83deb9c57710a2383b61f03ab15" translate="yes" xml:space="preserve">
          <source>Inhibit all warning messages.</source>
          <target state="translated">抑制所有警告信息。</target>
        </trans-unit>
        <trans-unit id="080f1e9a6e2cab41869cd5a7281f008e51e71667" translate="yes" xml:space="preserve">
          <source>Inhibit generation of linemarkers in the output from the preprocessor. This might be useful when running the preprocessor on something that is not C code, and will be sent to a program which might be confused by the linemarkers.</source>
          <target state="translated">禁止在预处理器的输出中生成行标记。当预处理器在非C代码上运行时,这可能是有用的,因为预处理器将被发送到一个可能会被行标记所混淆的程序。</target>
        </trans-unit>
        <trans-unit id="fa7703731fa04f07d423f5b7d1cd54384f1143c1" translate="yes" xml:space="preserve">
          <source>Initialization of automatic aggregates.</source>
          <target state="translated">自动汇总的初始化。</target>
        </trans-unit>
        <trans-unit id="11b16505aae7a8cef6f4bca8519967cba1c19746" translate="yes" xml:space="preserve">
          <source>Initialization of unions. If the initializer is zero, the warning is omitted. This is done under the assumption that the zero initializer in user code appears conditioned on e.g. &lt;code&gt;__STDC__&lt;/code&gt; to avoid missing initializer warnings and relies on default initialization to zero in the traditional C case.</source>
          <target state="translated">工会的初始化。如果初始值设定项为零，则忽略警告。这是在以下假设下完成的：用户代码中的零初始值设定项似乎以 &lt;code&gt;__STDC__&lt;/code&gt; 为条件，以避免丢失初始值设定项警告，并且在传统C情况下依赖于默认初始化为零。</target>
        </trans-unit>
        <trans-unit id="b60019f47df04ae92897fa912c6748a6013313fa" translate="yes" xml:space="preserve">
          <source>Inline Functions</source>
          <target state="translated">内联功能</target>
        </trans-unit>
        <trans-unit id="20eedc8fe9e9a35e534ae1ecdbec914e536d314f" translate="yes" xml:space="preserve">
          <source>Inline all block moves (such as calls to &lt;code&gt;memcpy&lt;/code&gt; or structure copies) less than or equal to &lt;var&gt;num&lt;/var&gt; bytes. The minimum value for &lt;var&gt;num&lt;/var&gt; is 32 bytes on 32-bit targets and 64 bytes on 64-bit targets. The default value is target-specific.</source>
          <target state="translated">内联所有小于或等于 &lt;var&gt;num&lt;/var&gt; 个字节的块移动（例如对 &lt;code&gt;memcpy&lt;/code&gt; 或结构副本的调用）。 &lt;var&gt;num&lt;/var&gt; 的最小值在32位目标上为32字节，在64位目标上为64字节。默认值为特定于目标的。</target>
        </trans-unit>
        <trans-unit id="19b0a018d37cfb0b1d0545d49bb366c506acf3ce" translate="yes" xml:space="preserve">
          <source>Inline also indirect calls that are discovered to be known at compile time thanks to previous inlining. This option has any effect only when inlining itself is turned on by the</source>
          <target state="translated">内联还包括在编译时由于之前的内联而被发现的间接调用。这个选项只有当内联本身由</target>
        </trans-unit>
        <trans-unit id="fafe5cb70796ac6434a1aca1419cbd95d727be6c" translate="yes" xml:space="preserve">
          <source>Inline assembler with operands.</source>
          <target state="translated">带有操作数的内联汇编器。</target>
        </trans-unit>
        <trans-unit id="14e6ac3d090072cf48a1a85932e7b4359138b15c" translate="yes" xml:space="preserve">
          <source>Inline assembler without operands.</source>
          <target state="translated">无操作数的内联汇编器。</target>
        </trans-unit>
        <trans-unit id="894882df2e980808e76bd468c0679a5b444a90d9" translate="yes" xml:space="preserve">
          <source>Inline code to invalidate instruction cache entries after setting up nested function trampolines. This option has no effect if</source>
          <target state="translated">在设置嵌套函数 trampolines 后,用于使指令缓存条目无效的内联代码。该选项在以下情况下没有效果</target>
        </trans-unit>
        <trans-unit id="f4aac95ae4ed684541a98bc144426b8b8c5823e2" translate="yes" xml:space="preserve">
          <source>Inline constants into the code stream if it can be done in two instructions or less.</source>
          <target state="translated">如果可以在两个指令或更少的时间内完成,则将常量内联到代码流中。</target>
        </trans-unit>
        <trans-unit id="116dec339b590ba4e7b045ac4254203eac5168bf" translate="yes" xml:space="preserve">
          <source>Inline functions are typically defined in a header file which can be included in many different compilations. Hopefully they can usually be inlined, but sometimes an out-of-line copy is necessary, if the address of the function is taken or if inlining fails. In general, we emit an out-of-line copy in all translation units where one is needed. As an exception, we only emit inline virtual functions with the vtable, since it always requires a copy.</source>
          <target state="translated">内联函数通常定义在一个头文件中,它可以包含在许多不同的编译中。希望它们通常可以被内联,但有时如果函数的地址被占用或内联失败,则需要一个外联副本。一般来说,我们在所有需要翻译单元的地方都会发出一个行外副本。作为例外,我们只用vtable发出内联虚拟函数,因为它总是需要一个副本。</target>
        </trans-unit>
        <trans-unit id="91795d77f30dd9a95fe0227642128a77b706a436" translate="yes" xml:space="preserve">
          <source>Inline functions marked by &lt;code&gt;always_inline&lt;/code&gt; and functions whose body seems smaller than the function call overhead early before doing</source>
          <target state="translated">以 &lt;code&gt;always_inline&lt;/code&gt; 标记的内联函数以及其主体似乎小于该函数的函数会在执行之前提早调用开销</target>
        </trans-unit>
        <trans-unit id="873b9f05fa871d467703c76988bb2508081a72a8" translate="yes" xml:space="preserve">
          <source>Inline parts of functions. This option has any effect only when inlining itself is turned on by the</source>
          <target state="translated">函数的内联部分。这个选项只有当内联本身由</target>
        </trans-unit>
        <trans-unit id="6695d9e4d931f3bbf61149758e9dd6a876eef21a" translate="yes" xml:space="preserve">
          <source>Inlineable functions can create unexpected line counts. Line counts are shown for the source code of the inlineable function, but what is shown depends on where the function is inlined, or if it is not inlined at all.</source>
          <target state="translated">可内联函数会产生意想不到的行数。可内联函数的源代码会显示行数,但显示的行数取决于函数内联的位置,或者根本没有内联。</target>
        </trans-unit>
        <trans-unit id="d9ba93d99f300a33841b732c50e4886ea39ea97f" translate="yes" xml:space="preserve">
          <source>Inlining is actually controlled by a number of parameters, which may be specified individually by using</source>
          <target state="translated">内嵌实际上是由一些参数控制的,这些参数可以通过使用</target>
        </trans-unit>
        <trans-unit id="5482ac6acd5628aa80debf07d0b113dce510f9a8" translate="yes" xml:space="preserve">
          <source>Input constraint strings may not begin with either &amp;lsquo;</source>
          <target state="translated">输入约束字符串不能以'</target>
        </trans-unit>
        <trans-unit id="b80748d19a1a87bf6f0f8e345598d0900573298f" translate="yes" xml:space="preserve">
          <source>Input constraints can also be digits (for example, &lt;code&gt;&quot;0&quot;&lt;/code&gt;). This indicates that the specified input must be in the same place as the output constraint at the (zero-based) index in the output constraint list. When using &lt;var&gt;asmSymbolicName&lt;/var&gt; syntax for the output operands, you may use these names (enclosed in brackets &amp;lsquo;</source>
          <target state="translated">输入约束也可以是数字（例如 &lt;code&gt;&quot;0&quot;&lt;/code&gt; ）。这表明在输出约束列表中（从零开始）索引处，指定的输入必须与输出约束位于同一位置。将 &lt;var&gt;asmSymbolicName&lt;/var&gt; 语法用于输出操作数时，可以使用以下名称（括在方括号'</target>
        </trans-unit>
        <trans-unit id="dab23b44a9c445e4c1ef121f24288981557e7ceb" translate="yes" xml:space="preserve">
          <source>Input files that don&amp;rsquo;t require compilation are ignored.</source>
          <target state="translated">不需要编译的输入文件将被忽略。</target>
        </trans-unit>
        <trans-unit id="9cfdbdf047fb129da10e8b15031d32fae6737df1" translate="yes" xml:space="preserve">
          <source>Input files that don&amp;rsquo;t require preprocessing are ignored.</source>
          <target state="translated">不需要预处理的输入文件将被忽略。</target>
        </trans-unit>
        <trans-unit id="0a9931474c689da17fc13937907d59216f561db0" translate="yes" xml:space="preserve">
          <source>Input operands make values from C variables and expressions available to the assembly code.</source>
          <target state="translated">输入操作数使C变量和表达式的值可用于汇编代码。</target>
        </trans-unit>
        <trans-unit id="1e2fe59177e98538b3f70c61c4f5e289c840eb88" translate="yes" xml:space="preserve">
          <source>Insert &lt;var&gt;count&lt;/var&gt;&lt;code&gt;NOP&lt;/code&gt; instructions. The number of instructions must be a compile-time integer constant.</source>
          <target state="translated">插入 &lt;var&gt;count&lt;/var&gt; &lt;code&gt;NOP&lt;/code&gt; 指令。指令数必须是编译时整数常量。</target>
        </trans-unit>
        <trans-unit id="80ef9bd4f5c2793b85eb597a6f564354bfd5ad04" translate="yes" xml:space="preserve">
          <source>Insert ENDBR instruction at function entry only via the &lt;code&gt;cf_check&lt;/code&gt; function attribute. This is useful when used with the option</source>
          <target state="translated">仅通过 &lt;code&gt;cf_check&lt;/code&gt; 函数属性将ENDBR指令插入函数入口。与选项一起使用时，这很有用</target>
        </trans-unit>
        <trans-unit id="7e304b0a6f8c78bdb7728a0243dd358487c2e9b4" translate="yes" xml:space="preserve">
          <source>Insert NOPs to force costly dependent insns into separate groups. Insert &lt;var&gt;number&lt;/var&gt; NOPs to force an insn to a new group.</source>
          <target state="translated">插入NOP可以将成本高昂的依赖insn分为不同的组。插入 &lt;var&gt;number&lt;/var&gt; NOP以将insn强制为新组。</target>
        </trans-unit>
        <trans-unit id="5093204ba172ea889ff043021567428c590f67d7" translate="yes" xml:space="preserve">
          <source>Insert NOPs to force costly dependent insns into separate groups. Insert exactly as many NOPs as needed to force an insn to a new group, according to the estimated processor grouping.</source>
          <target state="translated">插入NOPs来强制昂贵的依赖性insn进入单独的组。根据估计的处理器分组情况,插入所需数量的NOPs,将一个insn强制到一个新的组。</target>
        </trans-unit>
        <trans-unit id="da911af1e2c13a9407a1ba5438f240e7adaf4534" translate="yes" xml:space="preserve">
          <source>Insert a &amp;lsquo;</source>
          <target state="translated">插入&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="f7312b3d8cfcdef6b49830b93ffae1a5aa1b9a7e" translate="yes" xml:space="preserve">
          <source>Insert a cache barrier before a load or store that might be speculatively executed and that might have side effects even if aborted.</source>
          <target state="translated">在可能被投机执行的加载或存储前插入一个缓存屏障,即使被中止也可能产生副作用。</target>
        </trans-unit>
        <trans-unit id="0d1ec5c206dd0a56248bac70a97eb7b49297f48d" translate="yes" xml:space="preserve">
          <source>Insert a cache barrier before a store that might be speculatively executed and that might have side effects even if aborted.</source>
          <target state="translated">在可能被投机执行的存储前插入一个缓存屏障,即使被中止也可能产生副作用。</target>
        </trans-unit>
        <trans-unit id="613b69ab72c3cdbf33646040c8aaf33daa5e69f7" translate="yes" xml:space="preserve">
          <source>Insert an ISB instruction into the instruction stream.</source>
          <target state="translated">在指令流中插入一条ISB指令。</target>
        </trans-unit>
        <trans-unit id="698e6e70baffc9a9c2b3857106b77a97d6d36fc3" translate="yes" xml:space="preserve">
          <source>Insert an ISYNC instruction into the instruction stream where &lt;var&gt;addr&lt;/var&gt; is an instruction address for serialization.</source>
          <target state="translated">将ISYNC指令插入指令流，其中 &lt;var&gt;addr&lt;/var&gt; 是用于序列化的指令地址。</target>
        </trans-unit>
        <trans-unit id="ae82250f19f4a7ef9b7f40de2bc48433366c0b9a" translate="yes" xml:space="preserve">
          <source>Insert bits from &lt;var&gt;bits&lt;/var&gt; into &lt;var&gt;val&lt;/var&gt; and return the resulting value. The nibbles of &lt;var&gt;map&lt;/var&gt; determine how the insertion is performed: Let &lt;var&gt;X&lt;/var&gt; be the &lt;var&gt;n&lt;/var&gt;-th nibble of &lt;var&gt;map&lt;/var&gt;</source>
          <target state="translated">将位中的 &lt;var&gt;bits&lt;/var&gt; 插入 &lt;var&gt;val&lt;/var&gt; 并返回结果值。的啃 &lt;var&gt;map&lt;/var&gt; 确定如何执行插入：设 &lt;var&gt;X&lt;/var&gt; 是 &lt;var&gt;n&lt;/var&gt; 个半字节的 &lt;var&gt;map&lt;/var&gt;</target>
        </trans-unit>
        <trans-unit id="1b3701c0f8e0fee3d402f64923ea901bb1d7943e" translate="yes" xml:space="preserve">
          <source>Installing GCC automatically creates and installs the fixed header files, by running a program called &lt;code&gt;fixincludes&lt;/code&gt;. Normally, you don&amp;rsquo;t need to pay attention to this. But there are cases where it doesn&amp;rsquo;t do the right thing automatically.</source>
          <target state="translated">安装GCC可以通过运行一个名为 &lt;code&gt;fixincludes&lt;/code&gt; 的程序来自动创建并安装固定的头文件。通常，您不需要注意这一点。但是在某些情况下，它不会自动执行正确的操作。</target>
        </trans-unit>
        <trans-unit id="e4d7156bb86c9e4e2a11b97b329fef2be7147327" translate="yes" xml:space="preserve">
          <source>Instead of emitting debugging information for a C++ class in only one object file, emit it in all object files using the class. This option should be used only with debuggers that are unable to handle the way GCC normally emits debugging information for classes because using this option increases the size of debugging information by as much as a factor of two.</source>
          <target state="translated">不要只在一个对象文件中发布一个C++类的调试信息,而是在使用该类的所有对象文件中发布。这个选项应该只用于无法处理GCC通常为类发出调试信息的方式的调试器,因为使用这个选项会使调试信息的大小增加2倍之多。</target>
        </trans-unit>
        <trans-unit id="be3fc5710abd7790f590b73876140d19f165f83e" translate="yes" xml:space="preserve">
          <source>Instead of outputting the result of preprocessing, output a rule suitable for &lt;code&gt;make&lt;/code&gt; describing the dependencies of the main source file. The preprocessor outputs one &lt;code&gt;make&lt;/code&gt; rule containing the object file name for that source file, a colon, and the names of all the included files, including those coming from</source>
          <target state="translated">而不是输出预处理结果，而是输出适用于 &lt;code&gt;make&lt;/code&gt; 描述主源文件的依赖关系的规则。预处理器输出一个 &lt;code&gt;make&lt;/code&gt; 规则，其中包含该源文件的目标文件名，一个冒号以及所有包含的文件的名称，包括那些来自</target>
        </trans-unit>
        <trans-unit id="77341899c1b278a6893d86a8271c991e7d1d0365" translate="yes" xml:space="preserve">
          <source>Instead of the normal output, generate a list of &amp;lsquo;</source>
          <target state="translated">代替正常输出，生成一个&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="a34650e9f39910beff75fbecd84557b57d4a5454" translate="yes" xml:space="preserve">
          <source>Instead, a stub has to be set up, i.e. the function has to be called through a symbol (&lt;code&gt;func_4&lt;/code&gt; in the example):</source>
          <target state="translated">相反，必须设置存根，即必须通过符号（在示例中为 &lt;code&gt;func_4&lt;/code&gt; ）调用函数：</target>
        </trans-unit>
        <trans-unit id="c7ff7b3be05374bf926227d5a6cce16675add1a0" translate="yes" xml:space="preserve">
          <source>Instruction precision. The trap handler can determine the exact instruction that caused a floating-point exception.</source>
          <target state="translated">指令精度。陷阱处理程序可以确定引起浮点异常的准确指令。</target>
        </trans-unit>
        <trans-unit id="6b7ec2b988946f38d8fde29ac1dc412bf003f9ab" translate="yes" xml:space="preserve">
          <source>Instructions and corresponding built-ins may have additional restrictions and/or input/output values manipulated:</source>
          <target state="translated">指令和相应的内置模块可能有额外的限制和/或输入/输出值被操纵。</target>
        </trans-unit>
        <trans-unit id="60de57ec73ea7d3697a15749f6ec729f6774747c" translate="yes" xml:space="preserve">
          <source>Instructions and extensions for interfacing C with assembler.</source>
          <target state="translated">C与汇编器接口的说明和扩展。</target>
        </trans-unit>
        <trans-unit id="00371913daeb498043597ab2a3f06503732e4834" translate="yes" xml:space="preserve">
          <source>Instructions may freely access executable sections. This is the default setting.</source>
          <target state="translated">指令可以自由访问可执行部分。这是默认设置。</target>
        </trans-unit>
        <trans-unit id="728907072b85d2aba92847d49d68ef5c24bb45d9" translate="yes" xml:space="preserve">
          <source>Instructions must not access executable sections. This option can be useful on targets that are configured to have a dual instruction/data SRAM interface but that (unlike the M4K) do not automatically redirect PC-relative loads to the instruction RAM.</source>
          <target state="translated">指令不得访问可执行部分。这个选项对于那些被配置为具有双指令/数据SRAM接口,但(与M4K不同)不会自动将PC相关负载重定向到指令RAM的目标来说很有用。</target>
        </trans-unit>
        <trans-unit id="77c99e564d8632f1532735d88bcf4dbafa41656e" translate="yes" xml:space="preserve">
          <source>Instructions that can address I/O special function registers directly like &lt;code&gt;IN&lt;/code&gt;, &lt;code&gt;OUT&lt;/code&gt;, &lt;code&gt;SBI&lt;/code&gt;, etc. may use a different address as if addressed by an instruction to access RAM like &lt;code&gt;LD&lt;/code&gt; or &lt;code&gt;STS&lt;/code&gt;. This offset depends on the device architecture and has to be subtracted from the RAM address in order to get the respective I/O address.</source>
          <target state="translated">可以直接寻址I / O特殊功能寄存器的指令（例如 &lt;code&gt;IN&lt;/code&gt; ， &lt;code&gt;OUT&lt;/code&gt; ， &lt;code&gt;SBI&lt;/code&gt; 等）可能使用不同的地址，就好像该指令寻址了访问 &lt;code&gt;LD&lt;/code&gt; 或 &lt;code&gt;STS&lt;/code&gt; 这样的RAM一样。该偏移量取决于设备架构，必须从RAM地址中减去该偏移量才能获得相应的I / O地址。</target>
        </trans-unit>
        <trans-unit id="cfee5983fd7c9714339e56871463e3d57aa0eec5" translate="yes" xml:space="preserve">
          <source>Instructions that initiate or test completion of DMA must not be reordered with respect to loads and stores of the memory that is being accessed. With</source>
          <target state="translated">启动或测试完成DMA的指令,不得对正在访问的存储器的负载和存储进行重新排序。随着</target>
        </trans-unit>
        <trans-unit id="1ce9914ad99ce6285279f0d2872eb791125e8521" translate="yes" xml:space="preserve">
          <source>Instrument comparison operation (&amp;lt;, &amp;lt;=, &amp;gt;, &amp;gt;=) with pointer operands. The option must be combined with either</source>
          <target state="translated">带有指针操作数的仪器比较操作（&amp;lt;，&amp;lt;=，&amp;gt;，&amp;gt; =）。该选项必须与以下任意一项结合使用</target>
        </trans-unit>
        <trans-unit id="f9387cf45ec340cf769d2b6bfd22820dfe0ee0f4" translate="yes" xml:space="preserve">
          <source>Instrument function exit in -pg -mfentry instrumented functions with call to specified function. This only instruments true returns ending with ret, but not sibling calls ending with jump. Valid types are &lt;var&gt;none&lt;/var&gt; to not instrument, &lt;var&gt;call&lt;/var&gt; to generate a call to __return__, or &lt;var&gt;nop5&lt;/var&gt; to generate a 5 byte nop.</source>
          <target state="translated">仪器函数在-pg -mfentry仪器函数中退出，并调用指定函数。这仅会检测以ret结尾的true返回，而不会检测以jump结尾的同级调用。有效类型包括： &lt;var&gt;none&lt;/var&gt; ，不生成工具， &lt;var&gt;call&lt;/var&gt; 以生成对__return__的调用，或 &lt;var&gt;nop5&lt;/var&gt; 生成5字节的nop。</target>
        </trans-unit>
        <trans-unit id="c422d699b98760b3dc7f3d9f1edcf402a69024bc" translate="yes" xml:space="preserve">
          <source>Instrument only functions from files where names do not match all the regular expressions (separated by a semi-colon).</source>
          <target state="translated">仪器只从名字不符合所有正则表达式(用分号分隔)的文件中提取函数。</target>
        </trans-unit>
        <trans-unit id="65fc966a722098cb273080c59ea2c31dc9cc3d92" translate="yes" xml:space="preserve">
          <source>Instrument only functions from files where names match any regular expression (separated by a semi-colon).</source>
          <target state="translated">仪器只从名称符合任何正则表达式(用分号隔开)的文件中提取函数。</target>
        </trans-unit>
        <trans-unit id="55915d652d64c067aae4ac13787cd5f4e2697a1d" translate="yes" xml:space="preserve">
          <source>Instrument subtraction with pointer operands. The option must be combined with either</source>
          <target state="translated">用指针操作数进行仪器减法。这个选项必须与</target>
        </trans-unit>
        <trans-unit id="f97527e405387e5a9385fec8790b4168dd1d8deb" translate="yes" xml:space="preserve">
          <source>Int constant that is the element number of the 64-bit scalar in a vector.</source>
          <target state="translated">Int常数,是一个向量中64位标量的元素号。</target>
        </trans-unit>
        <trans-unit id="2c6ce795cf7dec61b5fb3d9cd78c430001b2fa7a" translate="yes" xml:space="preserve">
          <source>Int constant that is the element number that the MFVSRLD instruction. targets.</source>
          <target state="translated">Int常数,是MFVSRLD指令所针对的元素编号。</target>
        </trans-unit>
        <trans-unit id="da3ed23012cb8789d59d48ce6671ae83734c67c3" translate="yes" xml:space="preserve">
          <source>Integer constant -1</source>
          <target state="translated">整数常数-1</target>
        </trans-unit>
        <trans-unit id="4c803cf324e7329fee610f61a0c7d3b490694d57" translate="yes" xml:space="preserve">
          <source>Integer constant -1^20..1^19.</source>
          <target state="translated">整数常数-1^20...1^19。</target>
        </trans-unit>
        <trans-unit id="2d5c0333af76728cebb79e955757484473872b82" translate="yes" xml:space="preserve">
          <source>Integer constant 0</source>
          <target state="translated">整数常数0</target>
        </trans-unit>
        <trans-unit id="ec0deff2b158ad4cb0e8bfb80bf58b629d319506" translate="yes" xml:space="preserve">
          <source>Integer constant 1-4.</source>
          <target state="translated">整数常数1-4。</target>
        </trans-unit>
        <trans-unit id="f8ce91b7924266e877123b863072a4c805b14605" translate="yes" xml:space="preserve">
          <source>Integer constant 1.</source>
          <target state="translated">整数常数1。</target>
        </trans-unit>
        <trans-unit id="1c45cb8e2489b4f0de7b30a15f87854cc65bcd1c" translate="yes" xml:space="preserve">
          <source>Integer constant 31</source>
          <target state="translated">整数常数 31</target>
        </trans-unit>
        <trans-unit id="8a25d342105560c6220c4d21018dbd66f4909ac2" translate="yes" xml:space="preserve">
          <source>Integer constant 32</source>
          <target state="translated">整数常数 32</target>
        </trans-unit>
        <trans-unit id="0886d513058a9038f440a00ef02c6efc4d8b2b92" translate="yes" xml:space="preserve">
          <source>Integer constant 63</source>
          <target state="translated">整数常数 63</target>
        </trans-unit>
        <trans-unit id="e5d7234c4cec0b69e9a17de13e13f7813e3fe736" translate="yes" xml:space="preserve">
          <source>Integer constant in the range -16 &amp;hellip; 15.</source>
          <target state="translated">整数常数，范围为-16&amp;hellip;15。</target>
        </trans-unit>
        <trans-unit id="1565cd95bbecf4f27341ea540e96d5e245a3ed87" translate="yes" xml:space="preserve">
          <source>Integer constant in the range -31 &amp;hellip; 0.</source>
          <target state="translated">整数常数，范围为-31&amp;hellip;0。</target>
        </trans-unit>
        <trans-unit id="61fb232c331445cfab1e14db8fe240ad44ae23ee" translate="yes" xml:space="preserve">
          <source>Integer constant in the range -32768 &amp;hellip; 32767.</source>
          <target state="translated">整数常数，范围为-32768&amp;hellip;32767。</target>
        </trans-unit>
        <trans-unit id="41e8e6f2af1c63e52d1b0b7e46462d22a537cb51" translate="yes" xml:space="preserve">
          <source>Integer constant in the range -65535 .. -1 (16-bit negative immediate)</source>
          <target state="translated">整数常数,范围为-65535 ...-1 (16位负立即)</target>
        </trans-unit>
        <trans-unit id="61d203086fb27478ca235c1af13878c2c9eb4b69" translate="yes" xml:space="preserve">
          <source>Integer constant in the range 0 &amp;hellip; 15.</source>
          <target state="translated">整数常数，范围为0&amp;hellip;15。</target>
        </trans-unit>
        <trans-unit id="23ba3688657355d36ab63c4cf135962636a98aed" translate="yes" xml:space="preserve">
          <source>Integer constant in the range 0 &amp;hellip; 31, for 32-bit shifts.</source>
          <target state="translated">整数常数，范围为0&amp;hellip;31，用于32位移位。</target>
        </trans-unit>
        <trans-unit id="8a5ce6a50ce7c04ba5c11f9521a26c518ec2f5a9" translate="yes" xml:space="preserve">
          <source>Integer constant in the range 0 &amp;hellip; 31.</source>
          <target state="translated">整数常数，范围为0&amp;hellip;31。</target>
        </trans-unit>
        <trans-unit id="139ee936a79aaecfdde7d9044eb41363a8396bbf" translate="yes" xml:space="preserve">
          <source>Integer constant in the range 0 &amp;hellip; 63, for 64-bit shifts.</source>
          <target state="translated">对于64位移位，整数常数在0&amp;hellip;63的范围内。</target>
        </trans-unit>
        <trans-unit id="dbc4a22dc2be34fbbf4cb0f86cc5f6d5bed6c2db" translate="yes" xml:space="preserve">
          <source>Integer constant in the range 0 &amp;hellip; 65535.</source>
          <target state="translated">整数常数，范围为0&amp;hellip;65535。</target>
        </trans-unit>
        <trans-unit id="c3baf5f98ff3b5c0b48fedbf2ab36c7ce3d9b574" translate="yes" xml:space="preserve">
          <source>Integer constant in the range 0 .. 65535 (16-bit immediate)</source>
          <target state="translated">整数常数,范围为 0 ...65535 (16 位立即生效)</target>
        </trans-unit>
        <trans-unit id="2eb542fcd23b06c609f45ce695bf858099197e4a" translate="yes" xml:space="preserve">
          <source>Integer constant in the range 1 .. 31 (5-bit immediate)</source>
          <target state="translated">整数常数,范围为 1 ...31 (5 位立即生效)</target>
        </trans-unit>
        <trans-unit id="3a4a963907c182d517ccab65869d0178be683b92" translate="yes" xml:space="preserve">
          <source>Integer constant in the range 1 to 4 for &lt;code&gt;shladd&lt;/code&gt; instruction</source>
          <target state="translated">&lt;code&gt;shladd&lt;/code&gt; 指令的整数常数，范围为1到4</target>
        </trans-unit>
        <trans-unit id="ed5ad237aa0c579aead190a4dde0d33acad46194" translate="yes" xml:space="preserve">
          <source>Integer constant in the range &lt;em&gt;-2^{20}&lt;/em&gt; &amp;hellip; &lt;em&gt;2^{20} - 1&lt;/em&gt;.</source>
          <target state="translated">整数常数，范围为&lt;em&gt;-2 ^ {20}&lt;/em&gt; &amp;hellip; &lt;em&gt;2 ^ {20}-1&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="39cf676267018369b0349969938433de83ddfa88" translate="yes" xml:space="preserve">
          <source>Integer constant that can be deposited with a &lt;code&gt;zdepi&lt;/code&gt; instruction</source>
          <target state="translated">可以使用 &lt;code&gt;zdepi&lt;/code&gt; 指令存储的整数常量</target>
        </trans-unit>
        <trans-unit id="583d118a63d65e988fe09c84c0b83aa8b38f16dd" translate="yes" xml:space="preserve">
          <source>Integer constant that can be loaded with a &lt;code&gt;ldil&lt;/code&gt; instruction</source>
          <target state="translated">可以使用 &lt;code&gt;ldil&lt;/code&gt; 指令加载的整数常量</target>
        </trans-unit>
        <trans-unit id="d48f93a4a200fa761b79e46b5d40a57efc3b0da5" translate="yes" xml:space="preserve">
          <source>Integer constant that can be the operand of an ADDA or a SUBA insn.</source>
          <target state="translated">整数常量,可以是ADDA或SUBA insn的操作数。</target>
        </trans-unit>
        <trans-unit id="4a8ae929e4e263dbb7f6fd66766fe30d1987a3a1" translate="yes" xml:space="preserve">
          <source>Integer constant that can be used for &lt;code&gt;and&lt;/code&gt; operations in &lt;code&gt;depi&lt;/code&gt; and &lt;code&gt;extru&lt;/code&gt; instructions</source>
          <target state="translated">可用于整型常量 &lt;code&gt;and&lt;/code&gt; 运营 &lt;code&gt;depi&lt;/code&gt; 和 &lt;code&gt;extru&lt;/code&gt; 说明</target>
        </trans-unit>
        <trans-unit id="2dba2c70cd49d15853d2fcbcd40ffda61228a146" translate="yes" xml:space="preserve">
          <source>Integer constant that can be used with a 32-bit logical instruction</source>
          <target state="translated">可与32位逻辑指令一起使用的整数常数。</target>
        </trans-unit>
        <trans-unit id="8b060ea2730a272f1b73ae50c5eba4cb144cbe70" translate="yes" xml:space="preserve">
          <source>Integer constant that can be used with a 64-bit logical instruction</source>
          <target state="translated">可用于64位逻辑指令的整数常数。</target>
        </trans-unit>
        <trans-unit id="b5725eeea2176684ac75dce07a938b4978d11776" translate="yes" xml:space="preserve">
          <source>Integer constant that fits in one signed byte when incremented (-129 &amp;hellip; 126), but excluding -1.</source>
          <target state="translated">递增（-129&amp;hellip;126）时适合一个有符号字节的整数常量，但不包括-1。</target>
        </trans-unit>
        <trans-unit id="3b5d9aff7d40b143bd6daff2c6a766259ab8b1fb" translate="yes" xml:space="preserve">
          <source>Integer constant that fits in one signed byte when incremented by one (-129 &amp;hellip; 126).</source>
          <target state="translated">整数常数，当递增1（-129&amp;hellip;126）时，它适合一个有符号字节。</target>
        </trans-unit>
        <trans-unit id="51f11e6766d50aacca9af72d19a2ad4ee44d8420" translate="yes" xml:space="preserve">
          <source>Integer constant that has all 1 bits consecutive and starting at bit 0.</source>
          <target state="translated">整数常数,所有的1位都是连续的,从0位开始。</target>
        </trans-unit>
        <trans-unit id="5b3c28e6f072c668f6a58d9fd92384f1db7f2163" translate="yes" xml:space="preserve">
          <source>Integer constant that is a byte tiled out eight times.</source>
          <target state="translated">整数常数,是一个字节的八倍。</target>
        </trans-unit>
        <trans-unit id="b7536bc6ddcc73d7874ea428acf5799f76f79b75" translate="yes" xml:space="preserve">
          <source>Integer constant that is a byte tiled out four times.</source>
          <target state="translated">整数常数,是一个字节的四次平移。</target>
        </trans-unit>
        <trans-unit id="9097601fede0f9d62a8556f7fb948f72c7e42669" translate="yes" xml:space="preserve">
          <source>Integer constant that is a sign-extended byte tiled out as four shorts.</source>
          <target state="translated">整数常数,是一个符号扩展的字节,平铺出四个短线。</target>
        </trans-unit>
        <trans-unit id="a1aafaaeb369802b9c5b5f7500539f8ecf40fe8f" translate="yes" xml:space="preserve">
          <source>Integer constant that is a sign-extended byte tiled out as two shorts.</source>
          <target state="translated">整数常数,是一个符号扩展的字节,作为两个短字节平铺出来。</target>
        </trans-unit>
        <trans-unit id="f7398c389ada177deaf12a34ecfa3423b7af8637" translate="yes" xml:space="preserve">
          <source>Integer constant that is a valid mask for the clr instruction.</source>
          <target state="translated">整数常量,是clr指令的有效掩码。</target>
        </trans-unit>
        <trans-unit id="b75d0ad68a107d1647765566cd4e4331ec877550" translate="yes" xml:space="preserve">
          <source>Integer constant that is a valid mask for the set instruction.</source>
          <target state="translated">整数常量,是设置指令的有效掩码。</target>
        </trans-unit>
        <trans-unit id="6deb8c44627243fffa30bdcea50916656d673936" translate="yes" xml:space="preserve">
          <source>Integer constant that is valid as an immediate operand in a 32-bit &lt;code&gt;MOV&lt;/code&gt; pseudo instruction. The &lt;code&gt;MOV&lt;/code&gt; may be assembled to one of several different machine instructions depending on the value</source>
          <target state="translated">在32位 &lt;code&gt;MOV&lt;/code&gt; 伪指令中作为立即操作数有效的整数常量。根据值的不同， &lt;code&gt;MOV&lt;/code&gt; 可以组装为几种不同的机器指令之一</target>
        </trans-unit>
        <trans-unit id="4a87d8c398f8df47aa819b51612d3b210718b178" translate="yes" xml:space="preserve">
          <source>Integer constant that is valid as an immediate operand in a 64-bit &lt;code&gt;MOV&lt;/code&gt; pseudo instruction</source>
          <target state="translated">有效为64位 &lt;code&gt;MOV&lt;/code&gt; 伪指令中立即数的整数常量</target>
        </trans-unit>
        <trans-unit id="835371f7edd442337ddaf558ccf33428685fd64a" translate="yes" xml:space="preserve">
          <source>Integer constant that is valid as an immediate operand in a &lt;code&gt;SUB&lt;/code&gt; instruction (once negated)</source>
          <target state="translated">有效为 &lt;code&gt;SUB&lt;/code&gt; 指令中立即数的整数常量（一次取反）</target>
        </trans-unit>
        <trans-unit id="b60b6a4c6d01417f64595177f963b401572f1d12" translate="yes" xml:space="preserve">
          <source>Integer constant that is valid as an immediate operand in an &lt;code&gt;ADD&lt;/code&gt; instruction</source>
          <target state="translated">有效为 &lt;code&gt;ADD&lt;/code&gt; 指令中立即数的整数常量</target>
        </trans-unit>
        <trans-unit id="87c79859b391fe886f4983ce7831a89b4adb68fe" translate="yes" xml:space="preserve">
          <source>Integer constant valid for BccI instructions</source>
          <target state="translated">整数常数,对BccI指令有效</target>
        </trans-unit>
        <trans-unit id="85ce5abeb1e3fd38a5870ac5e6ed6f9d365a68ef" translate="yes" xml:space="preserve">
          <source>Integer constant whose value plus one is a power of 2</source>
          <target state="translated">整数常数,其值加1是2的幂。</target>
        </trans-unit>
        <trans-unit id="a5c600b3e3e20d77f480eccf6ab83a9d32d44088" translate="yes" xml:space="preserve">
          <source>Integer constant zero</source>
          <target state="translated">完整性常数为零</target>
        </trans-unit>
        <trans-unit id="c3722e4be24bd097c1e77d6a4d941d39b4c012e9" translate="yes" xml:space="preserve">
          <source>Integer constant zero.</source>
          <target state="translated">整数常数零。</target>
        </trans-unit>
        <trans-unit id="dbf06f652fea58e9dd29649e240ec804969a5dd2" translate="yes" xml:space="preserve">
          <source>Integer constants 0 through 3; shifts by these amounts are handled as multiple single-bit shifts rather than a single variable-length shift.</source>
          <target state="translated">整数常数0到3;这些数量的移位是作为多个单位移位而不是单个可变长度移位来处理的。</target>
        </trans-unit>
        <trans-unit id="8ac2f4ad59dbab77a56696249eb809853e9615f0" translate="yes" xml:space="preserve">
          <source>Integer constants can be written as binary constants, consisting of a sequence of &amp;lsquo;</source>
          <target state="translated">整数常量可以写成二进制常量，由一系列'</target>
        </trans-unit>
        <trans-unit id="f41a13c6db375bed842d479bfe5b3e0010d33bf8" translate="yes" xml:space="preserve">
          <source>Integer in the range -4095 to 4095</source>
          <target state="translated">整数,范围为-4095至4095。</target>
        </trans-unit>
        <trans-unit id="c3fa9d65e6a7c1536f875f2bf419adf966cd23e9" translate="yes" xml:space="preserve">
          <source>Integer in the range -8 to -1</source>
          <target state="translated">范围为-8至-1的整数</target>
        </trans-unit>
        <trans-unit id="3328ae7578dc6597eb774fb278c9e73ac29b9573" translate="yes" xml:space="preserve">
          <source>Integer in the range 0 to 32</source>
          <target state="translated">0-32范围内的整数</target>
        </trans-unit>
        <trans-unit id="e2a38f8fa6e98406bcdf4c312d8238e5cfaf61be" translate="yes" xml:space="preserve">
          <source>Integer in the range 1 to 8</source>
          <target state="translated">1-8范围内的整数</target>
        </trans-unit>
        <trans-unit id="a9929ab1a333ba5cc9ace240e37dbafefb59c7f4" translate="yes" xml:space="preserve">
          <source>Integer sized structures and unions are returned in register &lt;code&gt;r10&lt;/code&gt;.</source>
          <target state="translated">整数大小的结构和联合将在寄存器 &lt;code&gt;r10&lt;/code&gt; 中返回。</target>
        </trans-unit>
        <trans-unit id="aeae103003a2aa38881e355310bf8ec9d365ac20" translate="yes" xml:space="preserve">
          <source>Integer sized structures and unions are returned via a memory pointer rather than a register.</source>
          <target state="translated">整数大小的结构和联合体是通过一个内存指针而不是寄存器返回的。</target>
        </trans-unit>
        <trans-unit id="ec38048bade6f626a61ac1474e93bfb38c7df1c6" translate="yes" xml:space="preserve">
          <source>Integer that is valid as an immediate operand for a custom instruction opcode. Range 0 to 255.</source>
          <target state="translated">作为自定义指令操作码的直接操作数有效的整数。范围为0~255。</target>
        </trans-unit>
        <trans-unit id="fe9f5b3e08a16acbb4c74692fda365cc43d2472f" translate="yes" xml:space="preserve">
          <source>Integer that is valid as an immediate operand for a shift instruction. Range 0 to 31.</source>
          <target state="translated">作为移位指令的直接操作数的整数。范围为0~31。</target>
        </trans-unit>
        <trans-unit id="890df9207d827aca96b399580bd0f8412e42f7e4" translate="yes" xml:space="preserve">
          <source>Integer that is valid as an immediate operand for only the value 0. Can be used in conjunction with the format modifier &lt;code&gt;z&lt;/code&gt; to use &lt;code&gt;r0&lt;/code&gt; instead of &lt;code&gt;0&lt;/code&gt; in the assembly output.</source>
          <target state="translated">仅作为值0的立即数有效的整数。可以与格式修饰符 &lt;code&gt;z&lt;/code&gt; 结合使用，以在汇编输出中使用 &lt;code&gt;r0&lt;/code&gt; 而不是 &lt;code&gt;0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="96f19b7b3636f22386cbe0a9f69dade2dd82e04c" translate="yes" xml:space="preserve">
          <source>Integer that is valid as an immediate operand in a data processing instruction. That is, an integer in the range 0 to 255 rotated by a multiple of 2</source>
          <target state="translated">在数据处理指令中作为直接操作数有效的整数。也就是将0~255范围内的整数旋转2的倍数。</target>
        </trans-unit>
        <trans-unit id="ac46ec6d366341fdb4af14310403ae3145f3b15e" translate="yes" xml:space="preserve">
          <source>Integer that is valid as an immediate operand in an instruction taking a signed 16-bit number. Range -32768 to 32767.</source>
          <target state="translated">整数,在取一个有符号的16位数的指令中作为直接操作数有效。范围为-32768至32767。</target>
        </trans-unit>
        <trans-unit id="498c2e8d0733c4db6411b6bc3ce46dadd5e77698" translate="yes" xml:space="preserve">
          <source>Integer that is valid as an immediate operand in an instruction taking an unsigned 16-bit number. Range 0 to 65535.</source>
          <target state="translated">在取无符号16位数的指令中,作为直接操作数有效的整数。范围为0~65535。</target>
        </trans-unit>
        <trans-unit id="e29f49d17b7fc198ce0fa7cb4201b18268e8d536" translate="yes" xml:space="preserve">
          <source>Integer that is valid as an immediate operand in an instruction taking only the upper 16-bits of a 32-bit number. Range 32-bit numbers with the lower 16-bits being 0.</source>
          <target state="translated">整数,在指令中作为直接操作数有效,只取32位数的上16位。32位数的范围,低16位为0。</target>
        </trans-unit>
        <trans-unit id="ef774527e73685dd482562595abea32f82ae8d26" translate="yes" xml:space="preserve">
          <source>Integer that satisfies constraint &amp;lsquo;</source>
          <target state="translated">满足约束的整数</target>
        </trans-unit>
        <trans-unit id="cd276dc30e78674723811469b75093e4347a5ec8" translate="yes" xml:space="preserve">
          <source>Integer zero.</source>
          <target state="translated">整数零。</target>
        </trans-unit>
        <trans-unit id="02a8d3d0cb0f8a8a1f06403c05ed166f02853b82" translate="yes" xml:space="preserve">
          <source>Integer/Floating point constant that can be loaded into a register using three instructions</source>
          <target state="translated">整数/浮点常数,可以通过三条指令加载到寄存器中。</target>
        </trans-unit>
        <trans-unit id="96638e8b977a410fa8a46154d5e4a6ec900c666f" translate="yes" xml:space="preserve">
          <source>Integers valid for a moveq followed by a swap</source>
          <target state="translated">整数有效的移动q和交换后的整数</target>
        </trans-unit>
        <trans-unit id="d5c9a136f34c3dd6a7b63f408e1d675a9e1d38b5" translate="yes" xml:space="preserve">
          <source>Integers valid for mvq</source>
          <target state="translated">对mvq有效的整数</target>
        </trans-unit>
        <trans-unit id="62e557d83b66a9b174581d03e3369a916272f333" translate="yes" xml:space="preserve">
          <source>Integers valid for mvs</source>
          <target state="translated">对mvs有效的整数</target>
        </trans-unit>
        <trans-unit id="f4c85b8fad56b772bc4edffa020d9ee37f46fcc9" translate="yes" xml:space="preserve">
          <source>Integers valid for mvz</source>
          <target state="translated">对mvz有效的整数</target>
        </trans-unit>
        <trans-unit id="813e6a224069c7c2d70896d18ba42a603d4d9749" translate="yes" xml:space="preserve">
          <source>Integrate functions into their callers when their body is smaller than expected function call code (so overall size of program gets smaller). The compiler heuristically decides which functions are simple enough to be worth integrating in this way. This inlining applies to all functions, even those not declared inline.</source>
          <target state="translated">当函数的主体比预期的函数调用代码小时,将函数集成到它们的调用器中(所以程序的整体大小变小)。编译器会启发式地决定哪些函数足够简单,值得用这种方式集成。这种内联适用于所有函数,即使是那些没有内联声明的函数。</target>
        </trans-unit>
        <trans-unit id="e91f1a6f03354a5b4184e1f82704c900a6e46315" translate="yes" xml:space="preserve">
          <source>Intel Atom Bonnell CPU.</source>
          <target state="translated">英特尔Atom Bonnell CPU。</target>
        </trans-unit>
        <trans-unit id="e74ed473994f92acf9d6f6cf74055640eea6c5fe" translate="yes" xml:space="preserve">
          <source>Intel Atom CPU.</source>
          <target state="translated">英特尔Atom CPU。</target>
        </trans-unit>
        <trans-unit id="98be980f2e14c7ddb3a22e21977f5c70a3b827ac" translate="yes" xml:space="preserve">
          <source>Intel Atom Goldmont CPU.</source>
          <target state="translated">Intel Atom Goldmont CPU。</target>
        </trans-unit>
        <trans-unit id="8826cac9bbaea239ec6b025d2e96062e97854111" translate="yes" xml:space="preserve">
          <source>Intel Atom Goldmont Plus CPU.</source>
          <target state="translated">Intel Atom Goldmont Plus CPU。</target>
        </trans-unit>
        <trans-unit id="a870596d824025354ebffc8dc4c34386d2eeee36" translate="yes" xml:space="preserve">
          <source>Intel Atom Silvermont CPU.</source>
          <target state="translated">Intel Atom Silvermont CPU。</target>
        </trans-unit>
        <trans-unit id="19971c3133f23a6216254229cc2f489858e4b628" translate="yes" xml:space="preserve">
          <source>Intel Atom Tremont CPU.</source>
          <target state="translated">Intel Atom Tremont CPU。</target>
        </trans-unit>
        <trans-unit id="753d5fc029292ebb3d94e473e03912bd930c9f2d" translate="yes" xml:space="preserve">
          <source>Intel Bonnell CPU with 64-bit extensions, MOVBE, MMX, SSE, SSE2, SSE3 and SSSE3 instruction set support.</source>
          <target state="translated">英特尔Bonnell CPU具有64位扩展功能,支持MOVBE、MMX、SSE、SSE2、SSE3和SSSE3指令集。</target>
        </trans-unit>
        <trans-unit id="7edbccc518975fa2abcfd847cddd45d3bdf2e5eb" translate="yes" xml:space="preserve">
          <source>Intel Broadwell CPU with 64-bit extensions, MOVBE, MMX, SSE, SSE2, SSE3, SSSE3, SSE4.1, SSE4.2, POPCNT, AVX, AVX2, AES, PCLMUL, FSGSBASE, RDRND, FMA, BMI, BMI2, F16C, RDSEED, ADCX and PREFETCHW instruction set support.</source>
          <target state="translated">英特尔Broadwell CPU,支持64位扩展、MOVBE、MMX、SSE、SSE3、SSE4.1、SSE4.2、POPCNT、AVX、AVX2、AES、PCLMUL、FSGSBASE、RDRND、FMA、BMI、BMI2、F16C、RDSEED、ADCX和PREFETCHW指令集。</target>
        </trans-unit>
        <trans-unit id="2c6d2ee594a13260b5d6fa3f46182be446bfcf73" translate="yes" xml:space="preserve">
          <source>Intel CPU.</source>
          <target state="translated">英特尔CPU。</target>
        </trans-unit>
        <trans-unit id="b3c18e4c2ec250a1137d5aca17aa4c1bc104e36c" translate="yes" xml:space="preserve">
          <source>Intel Cannonlake Server CPU with 64-bit extensions, MOVBE, MMX, SSE, SSE2, SSE3, SSSE3, SSE4.1, SSE4.2, POPCNT, PKU, AVX, AVX2, AES, PCLMUL, FSGSBASE, RDRND, FMA, BMI, BMI2, F16C, RDSEED, ADCX, PREFETCHW, CLFLUSHOPT, XSAVEC, XSAVES, AVX512F, AVX512VL, AVX512BW, AVX512DQ, AVX512CD, AVX512VBMI, AVX512IFMA, SHA and UMIP instruction set support.</source>
          <target state="translated">英特尔Cannonlake服务器CPU的64位扩展,MOVBE,MMX,SSE,SSE2,SSE3,SSE3,SSE4.1,SSE4.2,POPCNT,PKU,AVX,AVX2,AES,PCLMUL,FSGSBASE,RDRND,FMA,BMI,BMI2,F16C,RDSEED,ADC。 2、POPCNT、PKU、AVX、AVX2、AES、PCLMUL、FSGSBASE、RDRND、FMA、BMI、BMI2、F16C、RDSEED、ADCX、PREFETCHW、CLFLUSHOPT、XSAVEC。支持XSAVES、AVX512F、AVX512VL、AVX512BW、AVX512DQ、AVX512CD、AVX512VBMI、AVX512IFMA、SHA和UMIP指令集。</target>
        </trans-unit>
        <trans-unit id="d0663fbf8e5631514b2db57500466ab8f139387f" translate="yes" xml:space="preserve">
          <source>Intel Cascadelake CPU with 64-bit extensions, MOVBE, MMX, SSE, SSE2, SSE3, SSSE3, SSE4.1, SSE4.2, POPCNT, PKU, AVX, AVX2, AES, PCLMUL, FSGSBASE, RDRND, FMA, BMI, BMI2, F16C, RDSEED, ADCX, PREFETCHW, CLFLUSHOPT, XSAVEC, XSAVES, AVX512F, CLWB, AVX512VL, AVX512BW, AVX512DQ, AVX512CD and AVX512VNNI instruction set support.</source>
          <target state="translated">英特尔Cascadelake CPU的64位扩展,MOVBE,MMX,SSE,SSE2,SSE3,SSSE4.1,SSE4.2、POPCNT、PKU、AVX、AVX2、AES、PCLMUL、FSGSBASE、RDRND、FMA、BMI、BMI2、F16C、RDSEED、ADCX、PREFETCHW、CLFLUSHOPT、XSAVEC、XSAVES、AVX512F、CLWB、AVX512VL、AVX512BW、AVX512DQ、AVX512CD和AVX512VNNI指令集支持。</target>
        </trans-unit>
        <trans-unit id="9e3cc9cc4cb7f234d7785740a07261c4e8d9725a" translate="yes" xml:space="preserve">
          <source>Intel Core 2 CPU with 64-bit extensions, MMX, SSE, SSE2, SSE3 and SSSE3 instruction set support.</source>
          <target state="translated">英特尔酷睿2 CPU,支持64位扩展,MMX、SSE、SSE2、SSE3和SSSE3指令集。</target>
        </trans-unit>
        <trans-unit id="b2638689948cd6d31eb928296bcce10234faa67e" translate="yes" xml:space="preserve">
          <source>Intel Core 2 CPU.</source>
          <target state="translated">Intel Core 2 CPU。</target>
        </trans-unit>
        <trans-unit id="38efa0dcd9f562f810c407371ffbbef6853b6616" translate="yes" xml:space="preserve">
          <source>Intel Core i7 Broadwell CPU.</source>
          <target state="translated">英特尔酷睿i7 Broadwell CPU。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
