<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="gcc">
    <body>
      <group id="gcc">
        <trans-unit id="ea3c4fdc7ae483f6eeee71767d6d7c25afd3b747" translate="yes" xml:space="preserve">
          <source>ULLK</source>
          <target state="translated">ULLK</target>
        </trans-unit>
        <trans-unit id="bd9c57578a5fa70fa2923dfa1948bb1047652950" translate="yes" xml:space="preserve">
          <source>ULLR</source>
          <target state="translated">ULLR</target>
        </trans-unit>
        <trans-unit id="181f09b6cf6ff48fe2bced4f8717c409974c7ccb" translate="yes" xml:space="preserve">
          <source>ULR</source>
          <target state="translated">ULR</target>
        </trans-unit>
        <trans-unit id="fdf943dd853f60e8f066b9ff1db365525dfa7714" translate="yes" xml:space="preserve">
          <source>UR</source>
          <target state="translated">UR</target>
        </trans-unit>
        <trans-unit id="b92dcc34c6f88a2b085f0fcf11324b5c2cf08f22" translate="yes" xml:space="preserve">
          <source>Unary absolute value.</source>
          <target state="translated">单元绝对值。</target>
        </trans-unit>
        <trans-unit id="63b13d71007c4da2df4ac38a9e58dea596e4161f" translate="yes" xml:space="preserve">
          <source>Unary negation.</source>
          <target state="translated">单元否定。</target>
        </trans-unit>
        <trans-unit id="5b74b98336e7267fb4f37f0b361c833e21dc0aa0" translate="yes" xml:space="preserve">
          <source>Unary square root operation.</source>
          <target state="translated">单元平方根运算。</target>
        </trans-unit>
        <trans-unit id="00399f106390204b9e8a47f8e8e78be426150d13" translate="yes" xml:space="preserve">
          <source>Unbounded uses, on the other hand, are uses of &lt;code&gt;alloca&lt;/code&gt; with no controlling predicate constraining its integer argument. For example:</source>
          <target state="translated">另一方面， &lt;code&gt;alloca&lt;/code&gt; 使用是没有控制谓词约束其整数参数的alloca的使用。例如：</target>
        </trans-unit>
        <trans-unit id="d6ba59d2b5ffc5c4e08397a280a30fb560e8436a" translate="yes" xml:space="preserve">
          <source>Undefining &lt;code id=&quot;index-std-3&quot;&gt;__STDC__&lt;/code&gt; when</source>
          <target state="translated">取消定义 &lt;code id=&quot;index-std-3&quot;&gt;__STDC__&lt;/code&gt; 时</target>
        </trans-unit>
        <trans-unit id="f070a98f1b801c2b6e78c0be33c88683a70671cf" translate="yes" xml:space="preserve">
          <source>Undefining &lt;code&gt;__STDC__&lt;/code&gt; in C++.</source>
          <target state="translated">在C ++中未定义 &lt;code&gt;__STDC__&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ca3f9bb4feba0ac0f3a9b154b20506b4c489b2f4" translate="yes" xml:space="preserve">
          <source>Under certain circumstances, GCC may duplicate (or remove duplicates of) your assembly code when optimizing. This can lead to unexpected duplicate symbol errors during compilation if your &lt;code&gt;asm&lt;/code&gt; code defines symbols or labels. Using &amp;lsquo;</source>
          <target state="translated">在某些情况下，GCC可能会在优化时复制（或删除重复的）汇编代码。如果您的 &lt;code&gt;asm&lt;/code&gt; 代码定义了符号或标签，则可能导致在编译期间出现意外的重复符号错误。使用&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="199aae5416e814ba38647e12711c671c6b6db5a1" translate="yes" xml:space="preserve">
          <source>Under certain circumstances, GCC may duplicate (or remove duplicates of) your assembly code when optimizing. This can lead to unexpected duplicate symbol errors during compilation if your assembly code defines symbols or labels.</source>
          <target state="translated">在某些情况下,GCC在优化时可能会重复(或删除重复的)您的汇编代码。如果您的汇编代码定义了符号或标签,这可能会导致编译过程中出现意外的重复符号错误。</target>
        </trans-unit>
        <trans-unit id="72b29a25fd6f124cae730e139b0e10b10a80e560" translate="yes" xml:space="preserve">
          <source>Unfortunately, historically GCC used to have a number of bugs in its encoding code. The NeXT runtime expects GCC to emit type encodings in this historical format (compatible with GCC-3.3), so when using the NeXT runtime, GCC will introduce on purpose a number of incorrect encodings:</source>
          <target state="translated">不幸的是,历史上GCC曾经在编码代码中存在一些错误。NeXT运行时希望GCC能以这种历史格式(与GCC-3.3兼容)发出类型编码,所以在使用NeXT运行时时,GCC会故意引入一些不正确的编码。</target>
        </trans-unit>
        <trans-unit id="aeee418a8137652ee6d9ab3008a38b4d74bc2a2f" translate="yes" xml:space="preserve">
          <source>Unfortunately, there are some characters allowed in identifiers by ISO C and ISO C++ that, when turned into NFC, are not allowed in identifiers. That is, there&amp;rsquo;s no way to use these symbols in portable ISO C or C++ and have all your identifiers in NFC.</source>
          <target state="translated">不幸的是，ISO C和ISO C ++的标识符中允许使用某些字符，当转换为NFC时，标识符中不允许使用这些字符。也就是说，无法在便携式ISO C或C ++中使用这些符号，而将所有标识符都包含在NFC中。</target>
        </trans-unit>
        <trans-unit id="5ddc1e63d4f989177759a83df41bd4b7dad20371" translate="yes" xml:space="preserve">
          <source>Unix C compilers have traditionally allocated storage for uninitialized global variables in a common block. This allows the linker to resolve all tentative definitions of the same variable in different compilation units to the same object, or to a non-tentative definition. This is the behavior specified by</source>
          <target state="translated">Unix C编译器传统上将未初始化的全局变量的存储分配在一个公共块中。这使得链接器可以将同一变量在不同编译单元中的所有暂定定义解析为同一个对象,或者解析为一个非暂定定义。这是由</target>
        </trans-unit>
        <trans-unit id="fc9481ccc42310377001eaf4b65f0ba7f43291d9" translate="yes" xml:space="preserve">
          <source>Unless</source>
          <target state="translated">Unless</target>
        </trans-unit>
        <trans-unit id="d6a3e0eb54ec1efd8ae1e1735e817354b9b6421f" translate="yes" xml:space="preserve">
          <source>Unless &lt;var&gt;*ptr&lt;/var&gt; and &lt;var&gt;vobj&lt;/var&gt; can be aliased, it is not guaranteed that the write to &lt;var&gt;*ptr&lt;/var&gt; occurs by the time the update of &lt;var&gt;vobj&lt;/var&gt; happens. If you need this guarantee, you must use a stronger memory barrier such as:</source>
          <target state="translated">除非可以为 &lt;var&gt;*ptr&lt;/var&gt; 和 &lt;var&gt;vobj&lt;/var&gt; 加上别名，否则不能保证在更新 &lt;var&gt;vobj&lt;/var&gt; 时对 &lt;var&gt;*ptr&lt;/var&gt; 进行写操作。如果需要此保证，则必须使用更强的内存屏障，例如：</target>
        </trans-unit>
        <trans-unit id="c9e3382936f0af0d7125a8bf9b98d564d02b82c4" translate="yes" xml:space="preserve">
          <source>Unless specified explicitly (with</source>
          <target state="translated">除非明确规定(用</target>
        </trans-unit>
        <trans-unit id="5eaa8563a22dc64db7ac666eb5d3e5ba11cc1996" translate="yes" xml:space="preserve">
          <source>Unlike Java, Objective-C does not allow for entire methods to be marked &lt;code&gt;@synchronized&lt;/code&gt;. Note that throwing exceptions out of &lt;code&gt;@synchronized&lt;/code&gt; blocks is allowed, and will cause the guarding object to be unlocked properly.</source>
          <target state="translated">与Java不同，Objective-C不允许将整个方法标记为 &lt;code&gt;@synchronized&lt;/code&gt; 。请注意，允许从 &lt;code&gt;@synchronized&lt;/code&gt; 块中抛出异常，这将导致保护对象被正确解锁。</target>
        </trans-unit>
        <trans-unit id="0cd317bbd72a217068977127c104995a9862be9b" translate="yes" xml:space="preserve">
          <source>Unlike for floating-point numbers in the decimal notation the exponent is always required in the hexadecimal notation. Otherwise the compiler would not be able to resolve the ambiguity of, e.g., &lt;code&gt;0x1.f&lt;/code&gt;. This could mean &lt;code&gt;1.0f&lt;/code&gt; or &lt;code&gt;1.9375&lt;/code&gt; since &amp;lsquo;</source>
          <target state="translated">与十进制表示法中的浮点数不同，十六进制表示法中始终需要指数。否则，编译器将无法解决例如 &lt;code&gt;0x1.f&lt;/code&gt; 的歧义。这可能意味着 &lt;code&gt;1.0f&lt;/code&gt; 或 &lt;code&gt;1.9375&lt;/code&gt; ,因为&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="c540371c5127336fc94b6b29fa3c46f81c44897b" translate="yes" xml:space="preserve">
          <source>Unlike in C, in C++, flowing off the end of a non-&lt;code&gt;void&lt;/code&gt; function other than &lt;code&gt;main&lt;/code&gt; results in undefined behavior even when the value of the function is not used.</source>
          <target state="translated">与C中的C语言不同，在C ++中，即使没有使用函数的值，从 &lt;code&gt;main&lt;/code&gt; 函数以外的非 &lt;code&gt;void&lt;/code&gt; 函数的末尾流出也会导致未定义的行为。</target>
        </trans-unit>
        <trans-unit id="2a830c95434f7db0cbf0fd8fd9277c1d051a3f31" translate="yes" xml:space="preserve">
          <source>Unnamed struct/union fields within structs/unions.</source>
          <target state="translated">结构/联盟中未命名的结构/联盟字段。</target>
        </trans-unit>
        <trans-unit id="205edf29824c8a0cb244fc56417458952c504c66" translate="yes" xml:space="preserve">
          <source>Unrecognized input files, not requiring compilation or assembly, are ignored.</source>
          <target state="translated">未识别的输入文件,不需要编译或组装,将被忽略。</target>
        </trans-unit>
        <trans-unit id="a51fd22f926dc0631cc272a22033e9d7fec59c36" translate="yes" xml:space="preserve">
          <source>Unroll all loops, even if their number of iterations is uncertain when the loop is entered. This usually makes programs run more slowly.</source>
          <target state="translated">释放所有的循环,即使在进入循环时它们的迭代次数不确定。这通常会使程序运行更慢。</target>
        </trans-unit>
        <trans-unit id="fc450b83181b0c2161a73acfdbf2dc658513bec3" translate="yes" xml:space="preserve">
          <source>Unroll loops whose number of iterations can be determined at compile time or upon entry to the loop.</source>
          <target state="translated">释放循环,其迭代次数可以在编译时或进入循环时确定。</target>
        </trans-unit>
        <trans-unit id="ad4d059f80e723b4d81766ec66adc71e8b2e5c48" translate="yes" xml:space="preserve">
          <source>Unsigned 12-bit constant (0&amp;ndash;4095)</source>
          <target state="translated">无符号12位常量（0&amp;ndash;4095）</target>
        </trans-unit>
        <trans-unit id="aec081f8e4cecc49f843970cd77df1a02a1c1643" translate="yes" xml:space="preserve">
          <source>Unsigned 16 bit integer (in the range 0 to 65535)</source>
          <target state="translated">无符号16位整数(范围0-65535)</target>
        </trans-unit>
        <trans-unit id="01dcb67eb6663625a6596ec55251e6ebe419078e" translate="yes" xml:space="preserve">
          <source>Unsigned 16-bit constant</source>
          <target state="translated">无符号16位常数</target>
        </trans-unit>
        <trans-unit id="005d69054eb4a9d53e3d7fc838909272fcdf1d1e" translate="yes" xml:space="preserve">
          <source>Unsigned 16-bit constant shifted left 16 bits (use &amp;lsquo;</source>
          <target state="translated">无符号16位常数左移16位（使用'</target>
        </trans-unit>
        <trans-unit id="803ea2cff434611bd7a889a5f8f4e2a80e2f6534" translate="yes" xml:space="preserve">
          <source>Unsigned 16-bit integer constant.</source>
          <target state="translated">无符号的16位整数常数。</target>
        </trans-unit>
        <trans-unit id="baffe105924a920d4f7c404a4974ebe483612051" translate="yes" xml:space="preserve">
          <source>Unsigned 3 bit integer (in the range 0 to 7)</source>
          <target state="translated">无符号的3位整数(范围为0至7)</target>
        </trans-unit>
        <trans-unit id="5d0b43b79f775a23c99274c057849b2132918314" translate="yes" xml:space="preserve">
          <source>Unsigned 5 bit integer (in the range 0 to 31)</source>
          <target state="translated">无符号的5位整数(范围为0至31)</target>
        </trans-unit>
        <trans-unit id="ee9e535a39880e194545226484f376dc9293656d" translate="yes" xml:space="preserve">
          <source>Unsigned 7 bit integer (in the range 0 to 127)</source>
          <target state="translated">无符号的7位整数(范围为0至127)</target>
        </trans-unit>
        <trans-unit id="64587bc80a139da54c64da1869304a4854d6ae7d" translate="yes" xml:space="preserve">
          <source>Unsigned 8-bit constant (0&amp;ndash;255)</source>
          <target state="translated">无符号8位常量（0&amp;ndash;255）</target>
        </trans-unit>
        <trans-unit id="389b98b2eb7e556938b37c1b397214bf77e480bb" translate="yes" xml:space="preserve">
          <source>Unsigned 8-bit integer constant (for &lt;code&gt;in&lt;/code&gt; and &lt;code&gt;out&lt;/code&gt; instructions).</source>
          <target state="translated">无符号的8位整数常量（用于 &lt;code&gt;in&lt;/code&gt; 和 &lt;code&gt;out&lt;/code&gt; 指令）。</target>
        </trans-unit>
        <trans-unit id="8f0359d8e4b83d3d17663b1351a70fc1f8166d35" translate="yes" xml:space="preserve">
          <source>Unsigned constant that fits in 4 bits</source>
          <target state="translated">4位的无符号常数</target>
        </trans-unit>
        <trans-unit id="2b90c224883efa79af0519ac0faa9b9d93afd6a8" translate="yes" xml:space="preserve">
          <source>Unsigned constant valid for BccUI instructions</source>
          <target state="translated">对BccUI指令有效的无符号常数</target>
        </trans-unit>
        <trans-unit id="6f39b25ebfb39b4238321ae23982857dd100a843" translate="yes" xml:space="preserve">
          <source>Unsigned immediate 15-bit value.</source>
          <target state="translated">无符号即时15位值。</target>
        </trans-unit>
        <trans-unit id="643476a0dd6f53437ba7e1cc7fb664b7f588a51c" translate="yes" xml:space="preserve">
          <source>Unsigned immediate 3-bit value.</source>
          <target state="translated">无符号即时3位值。</target>
        </trans-unit>
        <trans-unit id="45a42311f5f53acd8a7d22cb085352156026813a" translate="yes" xml:space="preserve">
          <source>Unsigned immediate 4-bit value.</source>
          <target state="translated">无符号即时4位值。</target>
        </trans-unit>
        <trans-unit id="39b8bb86545b9e829db3c4d0a8f246e834af0861" translate="yes" xml:space="preserve">
          <source>Unsigned immediate 5-bit value for movpi45 instruction with range 16&amp;ndash;47.</source>
          <target state="translated">movpi45指令的无符号立即数5位值，范围为16-47。</target>
        </trans-unit>
        <trans-unit id="899fe6e57441b37398096e6133a6ef0bf027d95b" translate="yes" xml:space="preserve">
          <source>Unsigned immediate 5-bit value.</source>
          <target state="translated">无符号即时5位值。</target>
        </trans-unit>
        <trans-unit id="deb14acda231f891d200f45725f5e7e68bae6ef4" translate="yes" xml:space="preserve">
          <source>Unsigned immediate 6-bit value constraint for addri36.sp instruction.</source>
          <target state="translated">addri36.sp指令的无符号即时6位值约束。</target>
        </trans-unit>
        <trans-unit id="4d84bf34896cf4e54d3ca29c18d4eaac197e6b98" translate="yes" xml:space="preserve">
          <source>Unsigned immediate 8-bit value.</source>
          <target state="translated">无符号即时8位值。</target>
        </trans-unit>
        <trans-unit id="0063ff83a123db3db2d8d12d6f824ef8fd590f5b" translate="yes" xml:space="preserve">
          <source>Unsigned immediate 9-bit value.</source>
          <target state="translated">无符号即时9位值。</target>
        </trans-unit>
        <trans-unit id="39e06dafd3f0aedfc6583e0a42cd32ba3116cfa2" translate="yes" xml:space="preserve">
          <source>Up: &lt;a href=&quot;executing-code-before-main#Executing-code-before-main&quot;&gt;Executing code before main&lt;/a&gt; [&lt;a href=&quot;index#SEC_Contents&quot;&gt;Contents&lt;/a&gt;][&lt;a href=&quot;https://gcc.gnu.org/onlinedocs/gcc-9.2.0/gcc/Option-Index.html#Option-Index&quot;&gt;Index&lt;/a&gt;]</source>
          <target state="translated">上：&lt;a href=&quot;executing-code-before-main#Executing-code-before-main&quot;&gt;在主要&lt;/a&gt; [ &lt;a href=&quot;index#SEC_Contents&quot;&gt;目录&lt;/a&gt; ] [ &lt;a href=&quot;https://gcc.gnu.org/onlinedocs/gcc-9.2.0/gcc/Option-Index.html#Option-Index&quot;&gt;索引&lt;/a&gt; ] 之前执行代码</target>
        </trans-unit>
        <trans-unit id="a632eb28fbdc638221eda735f91ebefbd97cd0d5" translate="yes" xml:space="preserve">
          <source>Up: &lt;a href=&quot;mips-simd-architecture-_0028msa_0029-support#MIPS-SIMD-Architecture-_0028MSA_0029-Support&quot;&gt;MIPS SIMD Architecture (MSA) Support&lt;/a&gt; [&lt;a href=&quot;index#SEC_Contents&quot;&gt;Contents&lt;/a&gt;][&lt;a href=&quot;https://gcc.gnu.org/onlinedocs/gcc-9.2.0/gcc/Option-Index.html#Option-Index&quot;&gt;Index&lt;/a&gt;]</source>
          <target state="translated">上一篇：&lt;a href=&quot;mips-simd-architecture-_0028msa_0029-support#MIPS-SIMD-Architecture-_0028MSA_0029-Support&quot;&gt;MIPS SIMD架构（MSA）支持&lt;/a&gt; [ &lt;a href=&quot;index#SEC_Contents&quot;&gt;目录&lt;/a&gt; ] [ &lt;a href=&quot;https://gcc.gnu.org/onlinedocs/gcc-9.2.0/gcc/Option-Index.html#Option-Index&quot;&gt;索引&lt;/a&gt; ]</target>
        </trans-unit>
        <trans-unit id="62c310f2ecc602f87c21d2fd813dc1c5d88ab539" translate="yes" xml:space="preserve">
          <source>Upon entering the &lt;code&gt;@synchronized&lt;/code&gt; block, a thread of execution shall first check whether a lock has been placed on the corresponding &lt;code&gt;guard&lt;/code&gt; object by another thread. If it has, the current thread shall wait until the other thread relinquishes its lock. Once &lt;code&gt;guard&lt;/code&gt; becomes available, the current thread will place its own lock on it, execute the code contained in the &lt;code&gt;@synchronized&lt;/code&gt; block, and finally relinquish the lock (thereby making &lt;code&gt;guard&lt;/code&gt; available to other threads).</source>
          <target state="translated">进入 &lt;code&gt;@synchronized&lt;/code&gt; 块后，执行线程应首先检查另一个线程是否已在相应的 &lt;code&gt;guard&lt;/code&gt; 对象上放置了锁。如果有，当前线程将等待，直到另一个线程放弃其锁。一旦 &lt;code&gt;guard&lt;/code&gt; 可用，当前线程将在其上放置自己的锁，执行 &lt;code&gt;@synchronized&lt;/code&gt; 块中包含的代码，最后放弃该锁（从而使 &lt;code&gt;guard&lt;/code&gt; 可用于其他线程）。</target>
        </trans-unit>
        <trans-unit id="b8aaa5b821490b029c1a6fe5ed310256ca59552f" translate="yes" xml:space="preserve">
          <source>Upper floating point register (32-bit), floating point register (64-bit)</source>
          <target state="translated">上浮点寄存器(32位)、浮点寄存器(64位)。</target>
        </trans-unit>
        <trans-unit id="06ee1205db8b9a4061f4febc2c51ef1b19f3d539" translate="yes" xml:space="preserve">
          <source>Usage of ISO string concatenation is detected.</source>
          <target state="translated">检测到ISO字符串连接的使用。</target>
        </trans-unit>
        <trans-unit id="89c2b631459be5cbc1277d90f51cb2dcbd76dfd6" translate="yes" xml:space="preserve">
          <source>Use (do not use) &amp;lsquo;</source>
          <target state="translated">使用（不使用）'</target>
        </trans-unit>
        <trans-unit id="6c996ac92914ff016f27df663925672950a9f247" translate="yes" xml:space="preserve">
          <source>Use (do not use) GP-relative accesses for symbols that are known to be in a small data section; see</source>
          <target state="translated">对已知在小数据部分的符号使用(不使用)GP相关访问;见</target>
        </trans-unit>
        <trans-unit id="841162f62263bc7378cda3013dbe47b1df4ab93e" translate="yes" xml:space="preserve">
          <source>Use (do not use) MIPS Digital Media Extension instructions. This option can only be used when generating 64-bit code and requires hardware floating-point support to be enabled.</source>
          <target state="translated">使用(不使用)MIPS数字媒体扩展指令。该选项只能在生成64位代码时使用,并且需要启用硬件浮点支持。</target>
        </trans-unit>
        <trans-unit id="b20024dc2d601c71b4e717f07d0f9b2a6822d063" translate="yes" xml:space="preserve">
          <source>Use (do not use) MT Multithreading instructions.</source>
          <target state="translated">使用(不使用)MT多线程指令。</target>
        </trans-unit>
        <trans-unit id="4c4c87eb21af6765217c1c52b2b2d0c31fe5b0c7" translate="yes" xml:space="preserve">
          <source>Use (do not use) assembler relocation operators when dealing with symbolic addresses. The alternative, selected by</source>
          <target state="translated">在处理符号地址时,使用(不使用)汇编器重定位运算符。选择的替代方案,由</target>
        </trans-unit>
        <trans-unit id="e2fb9fc1fd117af3b437fc4e8c7a5214e20addd7" translate="yes" xml:space="preserve">
          <source>Use (do not use) paired-single floating-point instructions. See &lt;a href=&quot;mips-paired_002dsingle-support#MIPS-Paired_002dSingle-Support&quot;&gt;MIPS Paired-Single Support&lt;/a&gt;. This option requires hardware floating-point support to be enabled.</source>
          <target state="translated">使用（不使用）成对的单浮点指令。请参阅&lt;a href=&quot;mips-paired_002dsingle-support#MIPS-Paired_002dSingle-Support&quot;&gt;MIPS配对单支持&lt;/a&gt;。此选项需要启用硬件浮点支持。</target>
        </trans-unit>
        <trans-unit id="f6259aa651c4c62a1528ed119090031f79dd3a9c" translate="yes" xml:space="preserve">
          <source>Use (do not use) revision 1 of the MIPS DSP ASE. See &lt;a href=&quot;mips-dsp-built_002din-functions#MIPS-DSP-Built_002din-Functions&quot;&gt;MIPS DSP Built-in Functions&lt;/a&gt;. This option defines the preprocessor macro &lt;code&gt;__mips_dsp&lt;/code&gt;. It also defines &lt;code&gt;__mips_dsp_rev&lt;/code&gt; to 1.</source>
          <target state="translated">使用（不使用）MIPS DSP ASE的修订版1。请参阅&lt;a href=&quot;mips-dsp-built_002din-functions#MIPS-DSP-Built_002din-Functions&quot;&gt;MIPS DSP内置函数&lt;/a&gt;。此选项定义预处理器宏 &lt;code&gt;__mips_dsp&lt;/code&gt; 。它还将 &lt;code&gt;__mips_dsp_rev&lt;/code&gt; 定义为1。</target>
        </trans-unit>
        <trans-unit id="84f11c6cd6e5cf30011af44cf15833421d85ad29" translate="yes" xml:space="preserve">
          <source>Use (do not use) revision 2 of the MIPS DSP ASE. See &lt;a href=&quot;mips-dsp-built_002din-functions#MIPS-DSP-Built_002din-Functions&quot;&gt;MIPS DSP Built-in Functions&lt;/a&gt;. This option defines the preprocessor macros &lt;code&gt;__mips_dsp&lt;/code&gt; and &lt;code&gt;__mips_dspr2&lt;/code&gt;. It also defines &lt;code&gt;__mips_dsp_rev&lt;/code&gt; to 2.</source>
          <target state="translated">使用（不使用）MIPS DSP ASE的修订版2。请参阅&lt;a href=&quot;mips-dsp-built_002din-functions#MIPS-DSP-Built_002din-Functions&quot;&gt;MIPS DSP内置函数&lt;/a&gt;。此选项定义预处理器宏 &lt;code&gt;__mips_dsp&lt;/code&gt; 和 &lt;code&gt;__mips_dspr2&lt;/code&gt; 。它还将 &lt;code&gt;__mips_dsp_rev&lt;/code&gt; 定义为2。</target>
        </trans-unit>
        <trans-unit id="f05f23d689cc06c1b3087b4a4cee4ab4e3b531c1" translate="yes" xml:space="preserve">
          <source>Use (do not use) the MIPS Cyclic Redundancy Check (CRC) instructions.</source>
          <target state="translated">使用(不使用)MIPS循环冗余检查(CRC)指令。</target>
        </trans-unit>
        <trans-unit id="41957dbedef9adbd80884a4e90cb75e57229baa1" translate="yes" xml:space="preserve">
          <source>Use (do not use) the MIPS Enhanced Virtual Addressing instructions.</source>
          <target state="translated">使用(不使用)MIPS增强型虚拟寻址指令。</target>
        </trans-unit>
        <trans-unit id="d449a2af21b4cd68389988954d474d0704ce78ae" translate="yes" xml:space="preserve">
          <source>Use (do not use) the MIPS Global INValidate (GINV) instructions.</source>
          <target state="translated">使用(不要使用)MIPS全局无效(GINV)指令。</target>
        </trans-unit>
        <trans-unit id="321d2808ff8ddfa8d27e08fae5ef2b18bb82a26d" translate="yes" xml:space="preserve">
          <source>Use (do not use) the MIPS Loongson EXTensions (EXT) instructions.</source>
          <target state="translated">使用(不要使用)MIPS Loongson EXTensions(EXT)说明。</target>
        </trans-unit>
        <trans-unit id="7e1498ad7af62c3d7182f6f503ffa752981eda71" translate="yes" xml:space="preserve">
          <source>Use (do not use) the MIPS Loongson EXTensions r2 (EXT2) instructions.</source>
          <target state="translated">使用(不要使用)MIPS Loongson EXTensions r2(EXT2)说明。</target>
        </trans-unit>
        <trans-unit id="2dd360e823e7db9203619f4657c5c205b972d79d" translate="yes" xml:space="preserve">
          <source>Use (do not use) the MIPS Loongson MultiMedia extensions Instructions (MMI).</source>
          <target state="translated">使用(不要使用)MIPS Loongson MultiMedia Extensions Instructions (MMI)。</target>
        </trans-unit>
        <trans-unit id="5f61baef9b142c63c1358980a670d3440a0eab96" translate="yes" xml:space="preserve">
          <source>Use (do not use) the MIPS MCU ASE instructions.</source>
          <target state="translated">使用(不使用)MIPS MCU ASE指令。</target>
        </trans-unit>
        <trans-unit id="8ec8692f1855f7387d01c2d894055d7cd55aa28a" translate="yes" xml:space="preserve">
          <source>Use (do not use) the MIPS SmartMIPS ASE.</source>
          <target state="translated">使用(不使用)MIPS SmartMIPS ASE。</target>
        </trans-unit>
        <trans-unit id="5ea0be9e9db2179c015e95d8d46f2c8b505a9fe4" translate="yes" xml:space="preserve">
          <source>Use (do not use) the MIPS Virtualization (VZ) instructions.</source>
          <target state="translated">使用(不要使用)MIPS虚拟化(VZ)说明。</target>
        </trans-unit>
        <trans-unit id="a2cdb6f5e1b2e85269c8ddd06af937bfeb499e18" translate="yes" xml:space="preserve">
          <source>Use (do not use) the MIPS eXtended Physical Address (XPA) instructions.</source>
          <target state="translated">使用(不要使用)MIPS eXtended Physical Address(XPA)指令。</target>
        </trans-unit>
        <trans-unit id="36354659118438f767b17fe9c67973e669f59454" translate="yes" xml:space="preserve">
          <source>Use (do not use) the MIPS-3D ASE. See &lt;a href=&quot;mips_002d3d-built_002din-functions#MIPS_002d3D-Built_002din-Functions&quot;&gt;MIPS-3D Built-in Functions&lt;/a&gt;. The option</source>
          <target state="translated">使用（不使用）MIPS-3D ASE。请参阅&lt;a href=&quot;mips_002d3d-built_002din-functions#MIPS_002d3D-Built_002din-Functions&quot;&gt;MIPS-3D内置函数&lt;/a&gt;。选项</target>
        </trans-unit>
        <trans-unit id="9ef75b208cd56b64585639240694bc21bc152e3d" translate="yes" xml:space="preserve">
          <source>Use (do not use) the hardware decimal-floating-point instructions for decimal-floating-point operations. When</source>
          <target state="translated">使用(不使用)硬件小数-浮点指令进行小数-浮点运算。当</target>
        </trans-unit>
        <trans-unit id="bf41f711c39d909ef84416fdb9864104894d7725" translate="yes" xml:space="preserve">
          <source>Use (do not use) the hardware floating-point instructions and registers for floating-point operations. When</source>
          <target state="translated">使用(不使用)硬件浮点指令和寄存器进行浮点运算。当</target>
        </trans-unit>
        <trans-unit id="de7cd0fb38e7a6dbf8bf51e3e0d617effe989eb9" translate="yes" xml:space="preserve">
          <source>Use (do not use) the hardware floating-point instructions for floating-point operations. When</source>
          <target state="translated">使用(不使用)硬件浮点指令进行浮点运算。当</target>
        </trans-unit>
        <trans-unit id="bd5d0dcb1bead4c9931bcc516462cf8c519e7f83" translate="yes" xml:space="preserve">
          <source>Use (do not use) the packed stack layout. When</source>
          <target state="translated">使用(不使用)打包的堆栈布局。当</target>
        </trans-unit>
        <trans-unit id="cbc7bc66fe33b21f66fff87d1b33e82b9091e241" translate="yes" xml:space="preserve">
          <source>Use (do not use) the probable-branch instructions, when static branch prediction indicates a probable branch.</source>
          <target state="translated">使用(不使用)可能分支指令,当静态分支预测表明可能分支时。</target>
        </trans-unit>
        <trans-unit id="f319b3952ec422e138086d2e7e1d3e6616dd87b3" translate="yes" xml:space="preserve">
          <source>Use 16-bit &lt;code&gt;int&lt;/code&gt;. This is the default.</source>
          <target state="translated">使用16位 &lt;code&gt;int&lt;/code&gt; 。这是默认值。</target>
        </trans-unit>
        <trans-unit id="89aa31a04c6ac47e58631515dc9a5eacae0d2be9" translate="yes" xml:space="preserve">
          <source>Use 32-bit &lt;code&gt;int&lt;/code&gt;.</source>
          <target state="translated">使用32位 &lt;code&gt;int&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="41a727b715072a7a83f64450d014d46413f9d7b5" translate="yes" xml:space="preserve">
          <source>Use 32-bit offsets in &lt;code&gt;switch&lt;/code&gt; tables. The default is to use 16-bit offsets.</source>
          <target state="translated">在 &lt;code&gt;switch&lt;/code&gt; 表中使用32位偏移量。默认值为使用16位偏移量。</target>
        </trans-unit>
        <trans-unit id="88f9f3c158d922b7a42c33cd301395b97a6091ab" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;brk_interrupt&lt;/code&gt; instead of &lt;code&gt;interrupt&lt;/code&gt; for handlers intended to be used with the &lt;code&gt;BRK&lt;/code&gt; opcode (i.e. those that must end with &lt;code&gt;RETB&lt;/code&gt; instead of &lt;code&gt;RETI&lt;/code&gt;).</source>
          <target state="translated">对于打算与 &lt;code&gt;BRK&lt;/code&gt; 操作码一起使用的处理程序（即，必须以 &lt;code&gt;RETB&lt;/code&gt; 而不是 &lt;code&gt;RETI&lt;/code&gt; 结尾的处理程序），请使用 &lt;code&gt;brk_interrupt&lt;/code&gt; 而不是 &lt;code&gt;interrupt&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a90fcb500090afb38bb3e24622641ed3199bfbe3" translate="yes" xml:space="preserve">
          <source>Use &lt;var&gt;class-name&lt;/var&gt; as the name of the class to instantiate for each literal string specified with the syntax &lt;code&gt;@&quot;&amp;hellip;&quot;&lt;/code&gt;. The default class name is &lt;code&gt;NXConstantString&lt;/code&gt; if the GNU runtime is being used, and &lt;code&gt;NSConstantString&lt;/code&gt; if the NeXT runtime is being used (see below). The</source>
          <target state="translated">使用 &lt;var&gt;class-name&lt;/var&gt; 作为类的名称，以使用语法 &lt;code&gt;@&quot;&amp;hellip;&quot;&lt;/code&gt; 指定的每个文字字符串实例化。如果使用的是GNU运行时，则默认的类名称为 &lt;code&gt;NXConstantString&lt;/code&gt; ;如果使用的是NeXT运行时， &lt;code&gt;NSConstantString&lt;/code&gt; （请参见下文）。的</target>
        </trans-unit>
        <trans-unit id="eb4639975214bd02baed9aee7811250d9713b6c2" translate="yes" xml:space="preserve">
          <source>Use &lt;var&gt;dir&lt;/var&gt; as a subdirectory of the directory containing target-specific C++ headers.</source>
          <target state="translated">将 &lt;var&gt;dir&lt;/var&gt; 用作包含特定于目标的C ++标头的目录的子目录。</target>
        </trans-unit>
        <trans-unit id="6e0e3e325ab15f9c4ea6c1c5a12adf0dc5651ccc" translate="yes" xml:space="preserve">
          <source>Use &lt;var&gt;dir&lt;/var&gt; as the logical root directory for headers and libraries. For example, if the compiler normally searches for headers in</source>
          <target state="translated">使用 &lt;var&gt;dir&lt;/var&gt; 作为标头和库的逻辑根目录。例如，如果编译器通常在以下位置搜索标头</target>
        </trans-unit>
        <trans-unit id="6f28e148765dfa527c350e4d6f8a2d064b3f5447" translate="yes" xml:space="preserve">
          <source>Use &lt;var&gt;script&lt;/var&gt; as the linker script. This option is supported by most systems using the GNU linker. On some targets, such as bare-board targets without an operating system, the</source>
          <target state="translated">使用 &lt;var&gt;script&lt;/var&gt; 作为链接描述文件。大多数使用GNU链接器的系统都支持此选项。在某些目标上，例如没有操作系统的裸板目标，</target>
        </trans-unit>
        <trans-unit id="603c63161e45119aff170517df5f944adaf08316" translate="yes" xml:space="preserve">
          <source>Use Bionic C library. This is the default on &amp;lsquo;</source>
          <target state="translated">使用仿生C库。这是&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="e1b7e66656ee6fc5c3b9eff78bd1af4ab51c4a01" translate="yes" xml:space="preserve">
          <source>Use DEC assembler syntax.</source>
          <target state="translated">使用DEC汇编器语法。</target>
        </trans-unit>
        <trans-unit id="cf5c1a8e637cc6c211fb5b791033642a96c7344a" translate="yes" xml:space="preserve">
          <source>Use GNU assembler syntax. This is the default.</source>
          <target state="translated">使用GNU汇编器语法。这是默认的。</target>
        </trans-unit>
        <trans-unit id="4ca68a7754f649f50b2ce419251af4261f6f0855" translate="yes" xml:space="preserve">
          <source>Use GP-relative &lt;code&gt;.sdata&lt;/code&gt;/&lt;code&gt;.sbss&lt;/code&gt; sections.</source>
          <target state="translated">使用相对于GP的 &lt;code&gt;.sdata&lt;/code&gt; / &lt;code&gt;.sbss&lt;/code&gt; 部分。</target>
        </trans-unit>
        <trans-unit id="5a4f813886fea8ad38a8f2df1482e30df599c3e3" translate="yes" xml:space="preserve">
          <source>Use IRA to evaluate register pressure in loops for decisions to move loop invariants. This option usually results in generation of faster and smaller code on machines with large register files (&amp;gt;= 32 registers), but it can slow the compiler down.</source>
          <target state="translated">使用IRA评估循环中的寄存器压力，以决定是否移动循环不变式。此选项通常会导致在具有大寄存器文件（&amp;gt; = 32个寄存器）的机器上生成更快，更小的代码，但是它可能会使编译器变慢。</target>
        </trans-unit>
        <trans-unit id="9fa83817840cfc83225757a8f388ff5927c560a5" translate="yes" xml:space="preserve">
          <source>Use IRA to evaluate register pressure in the code hoisting pass for decisions to hoist expressions. This option usually results in smaller code, but it can slow the compiler down.</source>
          <target state="translated">使用 IRA 在代码提升通道中评估寄存器压力,以决定提升表达式。这个选项通常会导致更小的代码,但它会拖慢编译器的速度。</target>
        </trans-unit>
        <trans-unit id="cf05afd7829c886cb42acb12e1e8f5c401d38cca" translate="yes" xml:space="preserve">
          <source>Use PC-relative switch case tables to enable case table shortening. This is the default for</source>
          <target state="translated">使用PC相关的交换机案例表来启用案例表缩短。这是默认的</target>
        </trans-unit>
        <trans-unit id="00b72e087f73e29c719a0c570f2c43c4886f6d49" translate="yes" xml:space="preserve">
          <source>Use PUSH operations to store outgoing parameters. This method is shorter and usually equally fast as method using SUB/MOV operations and is enabled by default. In some cases disabling it may improve performance because of improved scheduling and reduced dependencies.</source>
          <target state="translated">使用PUSH操作来存储输出参数。这种方法与使用SUB/MOV操作的方法相比,时间更短,速度通常同样快,并且默认启用。在某些情况下,由于改进了调度和减少了依赖性,禁用它可以提高性能。</target>
        </trans-unit>
        <trans-unit id="3d45d39c4ac78022d817a61ee97d331c721c6435" translate="yes" xml:space="preserve">
          <source>Use SSE register passing conventions for float and double arguments and return values. You can control this behavior for a specific function by using the function attribute &lt;code&gt;sseregparm&lt;/code&gt;. See &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;Function Attributes&lt;/a&gt;.</source>
          <target state="translated">将SSE寄存器传递约定用于float和double参数以及返回值。您可以使用功能属性 &lt;code&gt;sseregparm&lt;/code&gt; 来控制特定功能的此行为。请参见&lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;函数属性&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b404c19baa5a518d1cdcd1a18e31cedc71ed3a2b" translate="yes" xml:space="preserve">
          <source>Use TLS descriptors as the thread-local storage mechanism for dynamic accesses of TLS variables. This is the default.</source>
          <target state="translated">使用TLS描述符作为动态访问TLS变量的线程本地存储机制。这是默认的。</target>
        </trans-unit>
        <trans-unit id="e3576757916332969b16cf2fe6a0dad2cf57cc25" translate="yes" xml:space="preserve">
          <source>Use Unix assembler syntax.</source>
          <target state="translated">使用Unix汇编器语法。</target>
        </trans-unit>
        <trans-unit id="203b2b8006e8188de9ec3c4dca584f80e20ca5d1" translate="yes" xml:space="preserve">
          <source>Use a different function-calling convention, in which functions that take a fixed number of arguments return with the &lt;code&gt;ret &lt;var&gt;num&lt;/var&gt;&lt;/code&gt; instruction, which pops their arguments while returning. This saves one instruction in the caller since there is no need to pop the arguments there.</source>
          <target state="translated">使用不同的函数调用约定，在该约定中，带有固定数量参数的函数将通过 &lt;code&gt;ret &lt;var&gt;num&lt;/var&gt;&lt;/code&gt; 指令返回，该指令会在返回时弹出其参数。由于无需在此处弹出参数，因此在调用方中保存了一条指令。</target>
        </trans-unit>
        <trans-unit id="da4193d8552139570f953ba462e87b5070659dde" translate="yes" xml:space="preserve">
          <source>Use a different function-calling convention, in which functions that take a fixed number of arguments return with the &lt;code&gt;rtd&lt;/code&gt; instruction, which pops their arguments while returning. This saves one instruction in the caller since there is no need to pop the arguments there.</source>
          <target state="translated">使用不同的函数调用约定，在该约定中，带有固定数量参数的函数将通过 &lt;code&gt;rtd&lt;/code&gt; 指令返回，该指令会在返回时弹出其参数。由于无需在此处弹出参数，因此在调用方中保存了一条指令。</target>
        </trans-unit>
        <trans-unit id="331cc29755f1e26195a1d5ecc670eb6f5d017ee2" translate="yes" xml:space="preserve">
          <source>Use a simple check for control speculation. This option is on by default.</source>
          <target state="translated">使用简单的控制投机检查。该选项默认为开启。</target>
        </trans-unit>
        <trans-unit id="d6f85727b6057ae83760d6f97594f9ace81b0f7f" translate="yes" xml:space="preserve">
          <source>Use a simple data speculation check. This option is on by default.</source>
          <target state="translated">使用简单的数据推测检查。该选项默认为开启。</target>
        </trans-unit>
        <trans-unit id="ca6587349df9a9ae271539d7763d513420cd65bb" translate="yes" xml:space="preserve">
          <source>Use a suffix in a fixed-point literal constant:</source>
          <target state="translated">在定点文字常数中使用后缀。</target>
        </trans-unit>
        <trans-unit id="0eca7aa56a0b3e6cf63ecaa0b25877af246ac580" translate="yes" xml:space="preserve">
          <source>Use address register &lt;code&gt;X&lt;/code&gt; in a way proposed by the hardware. This means that &lt;code&gt;X&lt;/code&gt; is only used in indirect, post-increment or pre-decrement addressing.</source>
          <target state="translated">以硬件建议的方式使用地址寄存器 &lt;code&gt;X&lt;/code&gt; 。这意味着 &lt;code&gt;X&lt;/code&gt; 仅用于间接，后递增或递减寻址。</target>
        </trans-unit>
        <trans-unit id="3b89385a22047536803090fc547fb07c50377d4f" translate="yes" xml:space="preserve">
          <source>Use all 64 floating-point registers.</source>
          <target state="translated">使用全部64个浮点寄存器。</target>
        </trans-unit>
        <trans-unit id="feaeb911667dc1becc91e63f2c1dd1a8d7da1545" translate="yes" xml:space="preserve">
          <source>Use all 64 general-purpose registers.</source>
          <target state="translated">使用全部64个通用寄存器。</target>
        </trans-unit>
        <trans-unit id="b82e484b31c31a6751f032044a77e4b8d923804b" translate="yes" xml:space="preserve">
          <source>Use all eight media accumulator registers.</source>
          <target state="translated">使用全部8个介质蓄能器寄存器。</target>
        </trans-unit>
        <trans-unit id="2f6df81f72a01bee304049bedcc53aa9e70e7e34" translate="yes" xml:space="preserve">
          <source>Use all functions as a single region. This typically results in the smallest code size, and is enabled by default for</source>
          <target state="translated">将所有函数作为单一区域使用。这通常会导致最小的代码大小,并且默认为</target>
        </trans-unit>
        <trans-unit id="ba424a2a390669d654a999945050b535cb620662" translate="yes" xml:space="preserve">
          <source>Use all loops as register allocation regions. This can give the best results for machines with a small and/or irregular register set.</source>
          <target state="translated">将所有循环作为寄存器分配区域。这对于小的和/或不规则的寄存器集的机器来说,可以得到最好的结果。</target>
        </trans-unit>
        <trans-unit id="a043a5ff8ff9ce3ddafabde6a2ea3b417ae65cc6" translate="yes" xml:space="preserve">
          <source>Use all loops except for loops with small register pressure as the regions. This value usually gives the best results in most cases and for most architectures, and is enabled by default when compiling with optimization for speed (</source>
          <target state="translated">使用除寄存器压力小的循环外的所有循环作为区域。这个值通常在大多数情况下为大多数架构提供了最好的结果,并且在编译速度优化时默认启用 (</target>
        </trans-unit>
        <trans-unit id="812a6d3805650c2a1098b0f9c55012ae713394e0" translate="yes" xml:space="preserve">
          <source>Use caller save registers for allocation if those registers are not used by any called function. In that case it is not necessary to save and restore them around calls. This is only possible if called functions are part of same compilation unit as current function and they are compiled before it.</source>
          <target state="translated">如果这些寄存器不被任何被调用的函数使用,则使用调用者保存寄存器进行分配。在这种情况下,没有必要在调用时保存和恢复它们。只有当被调用的函数与当前函数属于同一个编译单元,并且它们在函数之前被编译时,才可以这样做。</target>
        </trans-unit>
        <trans-unit id="4382016563c1274a421ee87c295b12ebd4559c24" translate="yes" xml:space="preserve">
          <source>Use color in diagnostics. &lt;var&gt;WHEN&lt;/var&gt; is &amp;lsquo;</source>
          <target state="translated">在诊断中使用颜色。 &lt;var&gt;WHEN&lt;/var&gt; 是'</target>
        </trans-unit>
        <trans-unit id="40d7328de5846368928e724db703acd82494276b" translate="yes" xml:space="preserve">
          <source>Use colors for lines of code that have zero coverage. We use red color for non-exceptional lines and cyan for exceptional. Same colors are used for basic blocks with</source>
          <target state="translated">使用颜色表示覆盖率为零的代码行。我们对非特殊的行使用红色,对特殊的行使用青色。同样的颜色用于基本块与</target>
        </trans-unit>
        <trans-unit id="b78480b3c04e31f02a22c6b9fc0432c39f656a99" translate="yes" xml:space="preserve">
          <source>Use conditional execution (where available) to transform conditional jumps into branch-less equivalents.</source>
          <target state="translated">使用条件执行(在可用的情况下)将条件跳转转化为无分支的等价物。</target>
        </trans-unit>
        <trans-unit id="cfd175a21aedd34017c2ac1e6f5bcb8597ba832d" translate="yes" xml:space="preserve">
          <source>Use features of, and schedule code for, the given CPU. Supported values are in the format &amp;lsquo;</source>
          <target state="translated">使用给定CPU的功能并计划代码。支持的值格式为&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="3784fc1428664a00120c0092c2a68e1d52938803" translate="yes" xml:space="preserve">
          <source>Use floating-point coprocessor instructions.</source>
          <target state="translated">使用浮点协处理器指令。</target>
        </trans-unit>
        <trans-unit id="b74dc5c253b5d41873111acddddd0a6e12b4df73" translate="yes" xml:space="preserve">
          <source>Use floating-point double instructions.</source>
          <target state="translated">使用浮点双指令。</target>
        </trans-unit>
        <trans-unit id="92af032aeee5f8e42b7b1aaa0f92eee3c63e96e3" translate="yes" xml:space="preserve">
          <source>Use full-set registers for register allocation.</source>
          <target state="translated">使用全集寄存器进行寄存器分配。</target>
        </trans-unit>
        <trans-unit id="16451ea3ea1710752acecdfbc9b28aca9f971795" translate="yes" xml:space="preserve">
          <source>Use hardware FPP floating point. This is the default. (FIS floating point on the PDP-11/40 is not supported.) Implies -m45.</source>
          <target state="translated">使用硬件FPP浮点运算。这是默认值。(PDP-11/40上不支持FIS浮点。)意味着-m45。</target>
        </trans-unit>
        <trans-unit id="1d53b0a05bad4ee0582a36e272217d96ad44c641" translate="yes" xml:space="preserve">
          <source>Use hardware floating-point conversion instructions.</source>
          <target state="translated">使用硬件浮点转换指令。</target>
        </trans-unit>
        <trans-unit id="7c8d9f72c2a09e8bf637992aee381f0538cc91ce" translate="yes" xml:space="preserve">
          <source>Use hardware floating-point instructions.</source>
          <target state="translated">使用硬件浮点指令。</target>
        </trans-unit>
        <trans-unit id="0a53c63d0196fe12e50c8354a0f08f23a9436376" translate="yes" xml:space="preserve">
          <source>Use hardware floating-point square root instruction.</source>
          <target state="translated">使用硬件浮点平方根指令。</target>
        </trans-unit>
        <trans-unit id="9299be4448e9c807bf8ea8d91a628cfcd14cfa8d" translate="yes" xml:space="preserve">
          <source>Use hardware instructions for floating-point operations.</source>
          <target state="translated">使用硬件指令进行浮点运算。</target>
        </trans-unit>
        <trans-unit id="d1208904e1c443035a1b8ffe0c523b26cf7b7a8b" translate="yes" xml:space="preserve">
          <source>Use indirect addressing to call functions outside the current compilation unit. This allows the functions to be placed anywhere within the 32-bit address space.</source>
          <target state="translated">使用间接寻址来调用当前编译单元之外的函数。这允许函数被放置在32位地址空间内的任何地方。</target>
        </trans-unit>
        <trans-unit id="78fc9788b47e65039b1b1b871970de2bb141152a" translate="yes" xml:space="preserve">
          <source>Use large-model addressing (20-bit pointers, 32-bit &lt;code&gt;size_t&lt;/code&gt;).</source>
          <target state="translated">使用大型模型寻址（20位指针，32位 &lt;code&gt;size_t&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="da84f773a2b422eeb1cc59880ada32d1f5127685" translate="yes" xml:space="preserve">
          <source>Use library routines for floating-point operations.</source>
          <target state="translated">使用库例程进行浮点运算。</target>
        </trans-unit>
        <trans-unit id="089ac39a7bb68a3ed32ee7b6986eee393acae4e9" translate="yes" xml:space="preserve">
          <source>Use media instructions.</source>
          <target state="translated">使用介质说明。</target>
        </trans-unit>
        <trans-unit id="0eb15f40fe2c97b8f815cbb7844e284b610d0dac" translate="yes" xml:space="preserve">
          <source>Use multiply and add/subtract instructions.</source>
          <target state="translated">使用乘法和加/减法指令。</target>
        </trans-unit>
        <trans-unit id="3113eba3d237f18c9452620ae8a871803037c9fe" translate="yes" xml:space="preserve">
          <source>Use multiply high instructions for high part of 32x32 multiply.</source>
          <target state="translated">32x32乘法的高部分使用乘法高指令。</target>
        </trans-unit>
        <trans-unit id="274542aa04ed64b151c2d6a22c787feacea52bb1" translate="yes" xml:space="preserve">
          <source>Use of ISO C style function definitions. This warning intentionally is &lt;em&gt;not&lt;/em&gt; issued for prototype declarations or variadic functions because these ISO C features appear in your code when using libiberty&amp;rsquo;s traditional C compatibility macros, &lt;code&gt;PARAMS&lt;/code&gt; and &lt;code&gt;VPARAMS&lt;/code&gt;. This warning is also bypassed for nested functions because that feature is already a GCC extension and thus not relevant to traditional C compatibility.</source>
          <target state="translated">使用ISO C样式函数定义。&lt;em&gt;不会&lt;/em&gt;为原型声明或可变参数发出此警告，因为在使用libiberty的传统C兼容性宏 &lt;code&gt;PARAMS&lt;/code&gt; 和 &lt;code&gt;VPARAMS&lt;/code&gt; 时，这些ISO C功能会出现在您的代码中。嵌套函数也绕过此警告，因为该功能已经是GCC扩展，因此与传统C兼容性无关。</target>
        </trans-unit>
        <trans-unit id="158fc2002245113de73abd265a7ea7ceaec3a883" translate="yes" xml:space="preserve">
          <source>Use of these options requires the</source>
          <target state="translated">使用这些选项需要</target>
        </trans-unit>
        <trans-unit id="c4cc269c9473450b3919e9b442477125758842d4" translate="yes" xml:space="preserve">
          <source>Use only (or not only) &lt;code&gt;JSR&lt;/code&gt; instructions to access functions. This option can be used when code size exceeds the range of &lt;code&gt;BSR&lt;/code&gt; instructions. Note that</source>
          <target state="translated">仅（或不仅限于）使用 &lt;code&gt;JSR&lt;/code&gt; 指令来访问功能。当代码大小超出 &lt;code&gt;BSR&lt;/code&gt; 指令的范围时，可以使用此选项。注意</target>
        </trans-unit>
        <trans-unit id="3d7a23d4b8552ff506438fdaad793f73e9ba8b5c" translate="yes" xml:space="preserve">
          <source>Use only the first 32 floating-point registers.</source>
          <target state="translated">只使用前32个浮点寄存器。</target>
        </trans-unit>
        <trans-unit id="514349ebdaf390b152f0baa20866afbb16f28603" translate="yes" xml:space="preserve">
          <source>Use only the first four media accumulator registers.</source>
          <target state="translated">只使用前四个介质累加器寄存器。</target>
        </trans-unit>
        <trans-unit id="dbcdb22850ebf5d2eaa31bb7774cbe3b9ea3b9b1" translate="yes" xml:space="preserve">
          <source>Use options specific to GNU &lt;code&gt;ld&lt;/code&gt;. This passes</source>
          <target state="translated">使用特定于GNU &lt;code&gt;ld&lt;/code&gt; 的选项。这通过</target>
        </trans-unit>
        <trans-unit id="d0990e1967b634e363212e972c2e0f4cff8a380b" translate="yes" xml:space="preserve">
          <source>Use options specific to HP &lt;code&gt;ld&lt;/code&gt;. This passes</source>
          <target state="translated">使用特定于HP &lt;code&gt;ld&lt;/code&gt; 的选项。这通过</target>
        </trans-unit>
        <trans-unit id="b612fc229c98c8b45507f89276f4127d6c212de2" translate="yes" xml:space="preserve">
          <source>Use or do not use assembler relocation operators when dealing with symbolic addresses. The alternative is to use assembler macros instead, which may limit optimization.</source>
          <target state="translated">在处理符号地址时,使用或不使用汇编器重定位操作符。另一种方法是使用汇编器宏,这可能会限制优化。</target>
        </trans-unit>
        <trans-unit id="0d238a2890f95ffe47564d56929f04ca231d7f2f" translate="yes" xml:space="preserve">
          <source>Use ordinarily cached memory accesses for volatile references. This is the default.</source>
          <target state="translated">对易失性引用使用通常的缓存内存访问。这是默认的。</target>
        </trans-unit>
        <trans-unit id="561289d64c63454cbaa3cc42d60da8f4f3023750" translate="yes" xml:space="preserve">
          <source>Use pattern compare instructions.</source>
          <target state="translated">使用模式比较说明。</target>
        </trans-unit>
        <trans-unit id="040518cc797faf0101d0aa9c313c620444e4ee87" translate="yes" xml:space="preserve">
          <source>Use pipes rather than temporary files for communication between the various stages of compilation. This fails to work on some systems where the assembler is unable to read from a pipe; but the GNU assembler has no trouble.</source>
          <target state="translated">在编译的各个阶段之间使用管道而不是临时文件进行通信。这在某些系统上无法工作,因为汇编器无法从管道中读取;但GNU汇编器却没有问题。</target>
        </trans-unit>
        <trans-unit id="f48e58d8b4ccb76ce170698e169b17f602f7b800" translate="yes" xml:space="preserve">
          <source>Use reduced-set registers for register allocation.</source>
          <target state="translated">使用减集寄存器进行寄存器分配。</target>
        </trans-unit>
        <trans-unit id="2593d8520ea117d76ab84232fac04161f6934239" translate="yes" xml:space="preserve">
          <source>Use reorder instructions (swap and byte reversed load/store).</source>
          <target state="translated">使用重新排序指令(交换和字节反向加载/存储)。</target>
        </trans-unit>
        <trans-unit id="e07ac16585fa1254cfa0cb9da67063979e26bb7c" translate="yes" xml:space="preserve">
          <source>Use scalar floating-point instructions present in the SSE instruction set. This instruction set is supported by Pentium III and newer chips, and in the AMD line by Athlon-4, Athlon XP and Athlon MP chips. The earlier version of the SSE instruction set supports only single-precision arithmetic, thus the double and extended-precision arithmetic are still done using 387. A later version, present only in Pentium 4 and AMD x86-64 chips, supports double-precision arithmetic too.</source>
          <target state="translated">使用SSE指令集中存在的标量浮点指令。Pentium III及更新的芯片支持该指令集,AMD产品线中的Athlon-4、Athlon XP和Athlon MP芯片也支持该指令集。早期版本的SSE指令集只支持单精度算子,因此双精度和扩展精度算子仍然使用387来完成。后来的版本,只存在于Pentium 4和AMD x86-64芯片中,也支持双精度算术。</target>
        </trans-unit>
        <trans-unit id="d6e4ef6e570b37c45555a81f6cdc377b4bae049b" translate="yes" xml:space="preserve">
          <source>Use small-model addressing (16-bit pointers, 16-bit &lt;code&gt;size_t&lt;/code&gt;).</source>
          <target state="translated">使用小型模型寻址（16位指针，16位 &lt;code&gt;size_t&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="427046297d0e2e2fa23aa9bbce2f51b1069e5680" translate="yes" xml:space="preserve">
          <source>Use software emulation for divides (default).</source>
          <target state="translated">使用软件仿真进行分割(默认)。</target>
        </trans-unit>
        <trans-unit id="28d4c98240044920040873705d9156aeeb423961" translate="yes" xml:space="preserve">
          <source>Use software emulation for floating point (default).</source>
          <target state="translated">对浮点数使用软件仿真(默认)。</target>
        </trans-unit>
        <trans-unit id="1da6f7e54a7af9cc7e53be95e1caa19cec640f21" translate="yes" xml:space="preserve">
          <source>Use software multiply emulation (default).</source>
          <target state="translated">使用软件乘法仿真(默认)。</target>
        </trans-unit>
        <trans-unit id="51ebd4110af8f919b9d1120fda4a348de24109ee" translate="yes" xml:space="preserve">
          <source>Use specified regions for the integrated register allocator. The &lt;var&gt;region&lt;/var&gt; argument should be one of the following:</source>
          <target state="translated">将指定的区域用于集成寄存器分配器。该 &lt;var&gt;region&lt;/var&gt; 参数应该是以下情况之一：</target>
        </trans-unit>
        <trans-unit id="8bf48e2b51779d631071d9653fad6d3f53bf023b" translate="yes" xml:space="preserve">
          <source>Use table lookup optimization for small signed integer divisions.</source>
          <target state="translated">使用表查找优化小符号整数除法。</target>
        </trans-unit>
        <trans-unit id="22aeb5074275903d6cc2bc285a95ec6de6392b7d" translate="yes" xml:space="preserve">
          <source>Use the &amp;lsquo;</source>
          <target state="translated">使用 '</target>
        </trans-unit>
        <trans-unit id="4c08ac9947cb5cb5ba71955417b6bbe576595e7e" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;bfd&lt;/code&gt; linker instead of the default linker.</source>
          <target state="translated">使用 &lt;code&gt;bfd&lt;/code&gt; 链接器而不是默认链接器。</target>
        </trans-unit>
        <trans-unit id="49f654b96f5c6203d75686fb510717eb4b09cb8c" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;dcpl&lt;/code&gt; instruction to load the contents of address &lt;var&gt;x&lt;/var&gt; into the data cache.</source>
          <target state="translated">使用 &lt;code&gt;dcpl&lt;/code&gt; 指令将地址 &lt;var&gt;x&lt;/var&gt; 的内容加载到数据高速缓存中。</target>
        </trans-unit>
        <trans-unit id="bf6f4ab92454be3b8a7530a2bda919c27587ed37" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;gold&lt;/code&gt; linker instead of the default linker.</source>
          <target state="translated">使用 &lt;code&gt;gold&lt;/code&gt; 链接器而不是默认链接器。</target>
        </trans-unit>
        <trans-unit id="6ce5962b43b6bd52ef348d693006572a8183c27a" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;nldub&lt;/code&gt; instruction to load the contents of address &lt;var&gt;x&lt;/var&gt; into the data cache. The instruction is issued in slot I1.</source>
          <target state="translated">使用 &lt;code&gt;nldub&lt;/code&gt; 指令将地址 &lt;var&gt;x&lt;/var&gt; 的内容加载到数据高速缓存中。该指令在插槽I1中发出。</target>
        </trans-unit>
        <trans-unit id="867d5a75d613034d3b5e7a22efb5a5d5d0038d5f" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;section&lt;/code&gt; attribute with &lt;em&gt;global&lt;/em&gt; variables and not &lt;em&gt;local&lt;/em&gt; variables, as shown in the example.</source>
          <target state="translated">使用 &lt;code&gt;section&lt;/code&gt; 与属性&lt;em&gt;全局&lt;/em&gt;变量而不是&lt;em&gt;局部&lt;/em&gt;变量，在本例中，如图所示。</target>
        </trans-unit>
        <trans-unit id="9a7c0df6001ba89f4adccf5164b3cb2c7ebaeebd" translate="yes" xml:space="preserve">
          <source>Use the GNU C library. This is the default except on &amp;lsquo;</source>
          <target state="translated">使用GNU C库。这是默认设置，但&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="750d7f5d1705c279b333b6c74a4ba7e65ef492b9" translate="yes" xml:space="preserve">
          <source>Use the Graphite data dependence analysis to identify loops that can be parallelized. Parallelize all the loops that can be analyzed to not contain loop carried dependences without checking that it is profitable to parallelize the loops.</source>
          <target state="translated">使用 Graphite 数据依赖性分析来确定可以并行化的循环。在不检查并行化循环是否有利可图的情况下,对所有可以分析的循环进行并行化,以不包含循环携带的依赖性。</target>
        </trans-unit>
        <trans-unit id="7a211de8053eb75fc4551a2253a98b04c844e3fd" translate="yes" xml:space="preserve">
          <source>Use the LLVM &lt;code&gt;lld&lt;/code&gt; linker instead of the default linker.</source>
          <target state="translated">使用LLVM &lt;code&gt;lld&lt;/code&gt; 链接器代替默认链接器。</target>
        </trans-unit>
        <trans-unit id="04b872414955ba2ec914569c9ca7e852388533f1" translate="yes" xml:space="preserve">
          <source>Use the divide instruction. (Enabled by default).</source>
          <target state="translated">使用除法指令。(默认为启用)。</target>
        </trans-unit>
        <trans-unit id="558e68bc0e42df73038edd83e1eeba8d09d26633" translate="yes" xml:space="preserve">
          <source>Use the hardware barrel shifter.</source>
          <target state="translated">使用五金桶式变速箱。</target>
        </trans-unit>
        <trans-unit id="3ddc7c28193ef0a55228689dee7a52062a4edc76" translate="yes" xml:space="preserve">
          <source>Use the musl C library. This is the default on &amp;lsquo;</source>
          <target state="translated">使用musl C库。这是&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="1f0e93cc02e9fe65de10db69a6186e0dc79df964" translate="yes" xml:space="preserve">
          <source>Use the new LRA register allocator. By default, the old &amp;ldquo;reload&amp;rdquo; allocator is used.</source>
          <target state="translated">使用新的LRA寄存器分配器。默认情况下，使用旧的&amp;ldquo;重载&amp;rdquo;分配器。</target>
        </trans-unit>
        <trans-unit id="b8160c2417cc8a5cdcd5adcb2b4ace153689638e" translate="yes" xml:space="preserve">
          <source>Use the pc-relative addressing mode of the 68000 directly, instead of using a global offset table. At present, this option implies</source>
          <target state="translated">直接使用68000的pc相对寻址模式,而不是使用全局偏移表。目前,这个选项意味着</target>
        </trans-unit>
        <trans-unit id="f07a2b31cfd22ad424266d7caad833e89dee9597" translate="yes" xml:space="preserve">
          <source>Use the portable calling conventions proposed by HP for ELF systems.</source>
          <target state="translated">使用惠普公司为ELF系统提出的便携式呼叫惯例。</target>
        </trans-unit>
        <trans-unit id="0b4db49c13b2cd9f44e64e88aadae4892b55bc28" translate="yes" xml:space="preserve">
          <source>Use the simulator runtime. The default is to use the libgloss board-specific runtime.</source>
          <target state="translated">使用模拟器运行时。默认是使用libgloss板专用的运行时。</target>
        </trans-unit>
        <trans-unit id="41338fd388f1668b19ad991f249f38977077076b" translate="yes" xml:space="preserve">
          <source>Use the small address space model. This can produce smaller code, but it does assume that all symbolic values and addresses fit into a 20-bit range.</source>
          <target state="translated">使用小地址空间模型。这可以产生更小的代码,但它假设所有的符号值和地址都适合在20位范围内。</target>
        </trans-unit>
        <trans-unit id="13568366d19d7f746b8b97efedd41fb9de7088bc" translate="yes" xml:space="preserve">
          <source>Use the specified algorithm for basic block reordering. The &lt;var&gt;algorithm&lt;/var&gt; argument can be &amp;lsquo;</source>
          <target state="translated">使用指定的算法进行基本块重新排序。该 &lt;var&gt;algorithm&lt;/var&gt; 参数可以是&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="ab53cd8c99a5cd67bf095646da8562b04af28820" translate="yes" xml:space="preserve">
          <source>Use the specified coloring algorithm for the integrated register allocator. The &lt;var&gt;algorithm&lt;/var&gt; argument can be &amp;lsquo;</source>
          <target state="translated">对集成寄存器分配器使用指定的着色算法。该 &lt;var&gt;algorithm&lt;/var&gt; 参数可以是&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="c25bc5036e9135cfbfa139415172d379794c44f1" translate="yes" xml:space="preserve">
          <source>Use the standard 387 floating-point coprocessor present on the majority of chips and emulated otherwise. Code compiled with this option runs almost everywhere. The temporary results are computed in 80-bit precision instead of the precision specified by the type, resulting in slightly different results compared to most of other chips. See</source>
          <target state="translated">使用标准的387浮点协处理器,大多数芯片上都有,否则会被仿真。用这个选项编译的代码几乎可以在任何地方运行。临时结果以80位精度计算,而不是以类型指定的精度计算,结果与大多数其他芯片相比略有不同。参见</target>
        </trans-unit>
        <trans-unit id="5c3eebf40b38ef456cf7b33dffd08d0bed4ad5c6" translate="yes" xml:space="preserve">
          <source>Use the string argument if you want a single implementation file to include code from multiple header files. (You must also use &amp;lsquo;</source>
          <target state="translated">如果要单个实现文件包含来自多个头文件的代码，请使用字符串参数。（您还必须使用'</target>
        </trans-unit>
        <trans-unit id="8b250eb8bd58bde677af68374494bb2406d4bfb9" translate="yes" xml:space="preserve">
          <source>Use the timing characteristics of the indicated CPU type when scheduling instructions. This does not change the targeted processor type. The CPU type must be one of &amp;lsquo;</source>
          <target state="translated">安排指令时，请使用指示的CPU类型的时序特性。这不会更改目标处理器的类型。CPU类型必须为'</target>
        </trans-unit>
        <trans-unit id="e509cf065cb591da77c6d1b119a1c9955ae2884c" translate="yes" xml:space="preserve">
          <source>Use these attributes on the Blackfin to place the variable into L1 Data SRAM. Variables with &lt;code&gt;l1_data&lt;/code&gt; attribute are put into the specific section named &lt;code&gt;.l1.data&lt;/code&gt;. Those with &lt;code&gt;l1_data_A&lt;/code&gt; attribute are put into the specific section named &lt;code&gt;.l1.data.A&lt;/code&gt;. Those with &lt;code&gt;l1_data_B&lt;/code&gt; attribute are put into the specific section named &lt;code&gt;.l1.data.B&lt;/code&gt;.</source>
          <target state="translated">在Blackfin上使用这些属性可将变量放入L1数据SRAM中。具有 &lt;code&gt;l1_data&lt;/code&gt; 属性的变量被放入名为 &lt;code&gt;.l1.data&lt;/code&gt; 的特定节中。具有 &lt;code&gt;l1_data_A&lt;/code&gt; 属性的那些文件将放入名为 &lt;code&gt;.l1.data.A&lt;/code&gt; 的特定节中。具有 &lt;code&gt;l1_data_B&lt;/code&gt; 属性的那些文件将放入名为 &lt;code&gt;.l1.data.B&lt;/code&gt; 的特定节中。</target>
        </trans-unit>
        <trans-unit id="160cca57d4e5e0f9858135c86f73f6c1abb97d0c" translate="yes" xml:space="preserve">
          <source>Use these attributes to indicate that the specified function is an interrupt handler. The compiler generates function entry and exit sequences suitable for use in an interrupt handler when either attribute is present.</source>
          <target state="translated">使用这些属性来指示指定的函数是一个中断处理程序。当任一属性存在时,编译器会生成适合在中断处理程序中使用的函数进入和退出序列。</target>
        </trans-unit>
        <trans-unit id="bf93b175e1b39a6bc44235ab705a17a9dd4f6b45" translate="yes" xml:space="preserve">
          <source>Use these attributes to indicate that the specified function is an interrupt handler. The compiler generates function entry and exit sequences suitable for use in an interrupt handler when either of these attributes are present.</source>
          <target state="translated">使用这些属性来指示指定的函数是一个中断处理程序,当这些属性中的任何一个出现时,编译器会生成适合在中断处理程序中使用的函数进入和退出序列。当这些属性中的任何一个存在时,编译器会生成适合在中断处理程序中使用的函数进入和退出序列。</target>
        </trans-unit>
        <trans-unit id="713ae23784c01f8e2dec060c72284704315954a7" translate="yes" xml:space="preserve">
          <source>Use these options on systems where the linker can perform optimizations to improve locality of reference in the instruction space. Most systems using the ELF object format have linkers with such optimizations. On AIX, the linker rearranges sections (CSECTs) based on the call graph. The performance impact varies.</source>
          <target state="translated">在链接器可以进行优化以提高指令空间中引用的位置性的系统上使用这些选项。大多数使用ELF对象格式的系统的链接器都具有这样的优化功能。在AIX上,链接器会根据调用图重新排列部分(CSECT)。对性能的影响各不相同。</target>
        </trans-unit>
        <trans-unit id="78e3ee99ed9959a22e988df0584ccd7d00c7b9a6" translate="yes" xml:space="preserve">
          <source>Use this attribute on ARM to write Interrupt Service Routines. This is an alias to the &lt;code&gt;interrupt&lt;/code&gt; attribute above.</source>
          <target state="translated">在ARM上使用此属性可以编写中断服务例程。这是上述 &lt;code&gt;interrupt&lt;/code&gt; 属性的别名。</target>
        </trans-unit>
        <trans-unit id="6c570cb3577b10adeb554e34c1e75804adbd4ff0" translate="yes" xml:space="preserve">
          <source>Use this attribute on SH targets to indicate that an &lt;code&gt;interrupt_handler&lt;/code&gt; function should not save and restore registers R0..R7. This can be used on SH3* and SH4* targets that have a second R0..R7 register bank for non-reentrant interrupt handlers.</source>
          <target state="translated">在SH目标上使用此属性来指示 &lt;code&gt;interrupt_handler&lt;/code&gt; 函数不应保存和恢复寄存器R0..R7。可以在具有第二个R0..R7寄存器组（用于非重入中断处理程序）的SH3 *和SH4 *目标上使用。</target>
        </trans-unit>
        <trans-unit id="f5c77347991d0824e6e1b28414143e53ed7d053c" translate="yes" xml:space="preserve">
          <source>Use this attribute on fido, a subarchitecture of the m68k, to indicate that the specified function is an interrupt handler that is designed to run as a thread. The compiler omits generate prologue/epilogue sequences and replaces the return instruction with a &lt;code&gt;sleep&lt;/code&gt; instruction. This attribute is available only on fido.</source>
          <target state="translated">在f68（m68k的子体系结构）上使用此属性可指示指定的函数是设计为作为线程运行的中断处理程序。编译器忽略生成序言/结尾序列，并用 &lt;code&gt;sleep&lt;/code&gt; 指令替换返回指令。此属性仅在fido上可用。</target>
        </trans-unit>
        <trans-unit id="d1f324113425943e40b53dec4caee6bc8c992d2f" translate="yes" xml:space="preserve">
          <source>Use this attribute on the AVR to indicate that the specified function is an interrupt handler. The compiler generates function entry and exit sequences suitable for use in an interrupt handler when this attribute is present.</source>
          <target state="translated">在AVR上使用这个属性来指示指定的函数是一个中断处理程序。当此属性存在时,编译器会生成适合在中断处理程序中使用的函数进入和退出序列。</target>
        </trans-unit>
        <trans-unit id="a5bf0a65e4d4990ce1711a80366a15b5a93d0b22" translate="yes" xml:space="preserve">
          <source>Use this attribute on the Blackfin to indicate that the specified function is an NMI handler. The compiler generates function entry and exit sequences suitable for use in an NMI handler when this attribute is present.</source>
          <target state="translated">在Blackfin上使用此属性来表明指定的函数是一个NMI处理程序。当此属性存在时,编译器会生成适合在NMI处理程序中使用的函数进入和退出序列。</target>
        </trans-unit>
        <trans-unit id="dfb0dab0829881fae4719db2bc2a5d4b0371e0d9" translate="yes" xml:space="preserve">
          <source>Use this attribute on the Blackfin to indicate that the specified function is an exception handler. The compiler generates function entry and exit sequences suitable for use in an exception handler when this attribute is present.</source>
          <target state="translated">在Blackfin上使用这个属性来表明指定的函数是一个异常处理程序。当此属性存在时,编译器会生成适合在异常处理程序中使用的函数进入和退出序列。</target>
        </trans-unit>
        <trans-unit id="8869ad65102c3d5175ee58c9a5d4d12dd9377ae3" translate="yes" xml:space="preserve">
          <source>Use this attribute on the Blackfin to place the variable into L2 SRAM. Variables with &lt;code&gt;l2&lt;/code&gt; attribute are put into the specific section named &lt;code&gt;.l2.data&lt;/code&gt;.</source>
          <target state="translated">在Blackfin上使用此属性可将变量放入L2 SRAM。具有 &lt;code&gt;l2&lt;/code&gt; 属性的变量被放入名为 &lt;code&gt;.l2.data&lt;/code&gt; 的特定部分。</target>
        </trans-unit>
        <trans-unit id="77ba6ef03647597caec122d43f2ce8b19030a7ba" translate="yes" xml:space="preserve">
          <source>Use this attribute on the H8/300, H8/300H, and H8S to indicate that all registers except the stack pointer should be saved in the prologue regardless of whether they are used or not.</source>
          <target state="translated">在H8/300、H8/300H和H8S上使用该属性,表示除堆栈指针外的所有寄存器都应保存在序幕中,无论它们是否被使用。</target>
        </trans-unit>
        <trans-unit id="df02a088eeed2ddabe9512b735b51f56751782bf" translate="yes" xml:space="preserve">
          <source>Use this attribute on the H8/300, H8/300H, and H8S to indicate that the specified function is an interrupt handler. The compiler generates function entry and exit sequences suitable for use in an interrupt handler when this attribute is present.</source>
          <target state="translated">在H8/300、H8/300H和H8S上使用此属性来指示指定的函数是一个中断处理程序。当此属性存在时,编译器会生成适合用于中断处理程序的函数进入和退出序列。</target>
        </trans-unit>
        <trans-unit id="fd7a5bf8f68787afcff36ce2f74606dfa6e83fb2" translate="yes" xml:space="preserve">
          <source>Use this attribute on the H8/300, H8/300H, and H8S to indicate that the specified function should be called through the function vector. Calling a function through the function vector reduces code size; however, the function vector has a limited size (maximum 128 entries on the H8/300 and 64 entries on the H8/300H and H8S) and shares space with the interrupt vector.</source>
          <target state="translated">在H8/300、H8/300H和H8S上使用这个属性来表明指定的函数应该通过函数向量来调用。通过函数向量调用函数可以减少代码大小;但是,函数向量的大小是有限的(H8/300上最多128个条目,H8/300H和H8S上最多64个条目),并且与中断向量共享空间。</target>
        </trans-unit>
        <trans-unit id="599c44ccc726a6980df5cc0406dd5d4d98bf81c0" translate="yes" xml:space="preserve">
          <source>Use this attribute on the H8/300, H8/300H, and H8S to indicate that the specified variable should be placed into the eight-bit data section. The compiler generates more efficient code for certain operations on data in the eight-bit data area. Note the eight-bit data area is limited to 256 bytes of data.</source>
          <target state="translated">在H8/300、H8/300H和H8S上使用此属性,表示指定的变量应放入八位数据区。编译器对八位数据区的数据进行某些操作时,会生成更有效的代码。注意八位数据区的数据限制为256字节。</target>
        </trans-unit>
        <trans-unit id="a601987d8058a933f8472ba9226cb9a2f96a02f6" translate="yes" xml:space="preserve">
          <source>Use this attribute on the H8/300H and H8S to indicate that the specified variable should be placed into the tiny data section. The compiler generates more efficient code for loads and stores on data in the tiny data section. Note the tiny data area is limited to slightly under 32KB of data.</source>
          <target state="translated">在H8/300H和H8S上使用这个属性来指示指定的变量应该被放入微小数据部分。编译器会生成更高效的代码,用于在微小数据区中加载和存储数据。注意微小数据区的数据量限制在32KB以下。</target>
        </trans-unit>
        <trans-unit id="85d60dec57fe15c501fdf7e341a3a258fde629e1" translate="yes" xml:space="preserve">
          <source>Use this attribute on the M32C port to indicate that the specified function is a fast interrupt handler. This is just like the &lt;code&gt;interrupt&lt;/code&gt; attribute, except that &lt;code&gt;freit&lt;/code&gt; is used to return instead of &lt;code&gt;reit&lt;/code&gt;.</source>
          <target state="translated">在M32C端口上使用此属性可指示指定的功能是快速中断处理程序。就像 &lt;code&gt;interrupt&lt;/code&gt; 属性一样，除了 &lt;code&gt;freit&lt;/code&gt; 用于返回而不是 &lt;code&gt;reit&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="297c80fc49a65c78b7920bfb2bee0762b9925dea" translate="yes" xml:space="preserve">
          <source>Use this attribute on the M32R/D to set the addressability of an object. The identifier &lt;var&gt;model-name&lt;/var&gt; is one of &lt;code&gt;small&lt;/code&gt;, &lt;code&gt;medium&lt;/code&gt;, or &lt;code&gt;large&lt;/code&gt;, representing each of the code models.</source>
          <target state="translated">在M32R / D上使用此属性可以设置对象的可寻址性。标识符 &lt;var&gt;model-name&lt;/var&gt; 是 &lt;code&gt;small&lt;/code&gt; ， &lt;code&gt;medium&lt;/code&gt; 或 &lt;code&gt;large&lt;/code&gt; 之一，代表每个代码模型。</target>
        </trans-unit>
        <trans-unit id="96da4205ef51f9f643ebc02b337015bd75a20bc4" translate="yes" xml:space="preserve">
          <source>Use this attribute on the NDS32 target to indicate that the specified function is a reset handler. The compiler will generate corresponding sections for use in a reset handler. You can use the following attributes to provide extra exception handling:</source>
          <target state="translated">在NDS32目标上使用这个属性来表明指定的函数是一个复位处理程序。编译器将生成相应的部分供复位处理程序使用。您可以使用以下属性来提供额外的异常处理。</target>
        </trans-unit>
        <trans-unit id="baa8e68af06ff2588951a9683b9bf9ad21db1c70" translate="yes" xml:space="preserve">
          <source>Use this attribute on the NDS32 target to indicate that the specified function is an exception handler. The compiler will generate corresponding sections for use in an exception handler.</source>
          <target state="translated">在NDS32目标上使用这个属性来表明指定的函数是一个异常处理程序。编译器将生成相应的部分供异常处理程序使用。</target>
        </trans-unit>
        <trans-unit id="420b4fa6a036410c655f106a939e0146c5f824c7" translate="yes" xml:space="preserve">
          <source>Use this attribute on the RX port to indicate that the specified function is a fast interrupt handler. This is just like the &lt;code&gt;interrupt&lt;/code&gt; attribute, except that &lt;code&gt;freit&lt;/code&gt; is used to return instead of &lt;code&gt;reit&lt;/code&gt;.</source>
          <target state="translated">在RX端口上使用此属性可指示指定的功能是快速中断处理程序。就像 &lt;code&gt;interrupt&lt;/code&gt; 属性一样，除了 &lt;code&gt;freit&lt;/code&gt; 用于返回而不是 &lt;code&gt;reit&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8551dfbdf943cb7774be60c5de8ba39aba7167f2" translate="yes" xml:space="preserve">
          <source>Use this attribute on the SH for an &lt;code&gt;interrupt_handler&lt;/code&gt; to return using &lt;code&gt;trapa&lt;/code&gt; instead of &lt;code&gt;rte&lt;/code&gt;. This attribute expects an integer argument specifying the trap number to be used.</source>
          <target state="translated">使用的SH这个属性对于 &lt;code&gt;interrupt_handler&lt;/code&gt; 使用返回 &lt;code&gt;trapa&lt;/code&gt; 代替 &lt;code&gt;rte&lt;/code&gt; 。此属性需要一个整数参数来指定要使用的陷阱号。</target>
        </trans-unit>
        <trans-unit id="96f131ead8b3e83868bdd55e3669cea512c61c77" translate="yes" xml:space="preserve">
          <source>Use this attribute on the SH to indicate an &lt;code&gt;interrupt_handler&lt;/code&gt; function should switch to an alternate stack. It expects a string argument that names a global variable holding the address of the alternate stack.</source>
          <target state="translated">在SH上使用此属性来指示 &lt;code&gt;interrupt_handler&lt;/code&gt; 函数应切换到备用堆栈。它需要一个字符串参数，该参数命名一个包含备用堆栈地址的全局变量。</target>
        </trans-unit>
        <trans-unit id="7835a2a9ca1e1170ad95a6f19a530b6da32924fa" translate="yes" xml:space="preserve">
          <source>Use this attribute to explicitly place a variable in the first 32 kilobytes of memory.</source>
          <target state="translated">使用此属性可明确地将变量放置在内存的前32千字节中。</target>
        </trans-unit>
        <trans-unit id="6f81bc7b08ff6f3b4d15b67ecb7306d1b4cac77a" translate="yes" xml:space="preserve">
          <source>Use this attribute to explicitly place a variable in the small data area, which can hold up to 64 kilobytes.</source>
          <target state="translated">使用此属性可将变量显式地放置在小数据区中,小数据区最多可容纳64千字节。</target>
        </trans-unit>
        <trans-unit id="25a478a508b894220fe0716716b37246794c924f" translate="yes" xml:space="preserve">
          <source>Use this attribute to explicitly place a variable in the tiny data area, which can hold up to 256 bytes in total.</source>
          <target state="translated">使用此属性可以明确地将一个变量放置在微小的数据区域中,该区域总共可以容纳256个字节。</target>
        </trans-unit>
        <trans-unit id="236f15e780f5078ecf100afe1366fac4aadd1410" translate="yes" xml:space="preserve">
          <source>Use this attribute to indicate that all registers except the stack pointer should be saved in the prologue regardless of whether they are used or not.</source>
          <target state="translated">使用该属性表示除了堆栈指针之外的所有寄存器都应该保存在序章中,无论它们是否被使用。</target>
        </trans-unit>
        <trans-unit id="764c3380316fc59c0e08f071dd7a44fb3d9e29ae" translate="yes" xml:space="preserve">
          <source>Use this attribute to indicate that the function is an interrupt handler. All volatile registers (in addition to non-volatile registers) are saved in the function prologue. If the function is a leaf function, only volatiles used by the function are saved. A normal function return is generated instead of a return from interrupt.</source>
          <target state="translated">使用该属性表示该函数是一个中断处理程序。所有的易失性寄存器(除了非易失性寄存器)都被保存在函数序章中,如果函数是叶函数,则只保存函数使用的易失性寄存器。如果函数是叶函数,则只保存函数使用的易失性寄存器。产生一个正常的函数返回,而不是从中断返回。</target>
        </trans-unit>
        <trans-unit id="e7371ecf2ac4e4a5beb340500a4170b79e5aeb2e" translate="yes" xml:space="preserve">
          <source>Use this attribute to indicate that the specified function has no caller-saved registers. That is, all registers are callee-saved. For example, this attribute can be used for a function called from an interrupt handler. The compiler generates proper function entry and exit sequences to save and restore any modified registers, except for the EFLAGS register. Since GCC doesn&amp;rsquo;t preserve SSE, MMX nor x87 states, the GCC option</source>
          <target state="translated">使用此属性指示指定的函数没有调用者保存的寄存器。也就是说，所有寄存器都被保存了被调用者。例如，此属性可用于从中断处理程序调用的函数。编译器会生成适当的函数进入和退出序列，以保存和恢复除EFLAGS寄存器外的所有已修改寄存器。由于GCC不会保留SSE，MMX或x87状态，因此GCC选项</target>
        </trans-unit>
        <trans-unit id="7d075359795fbb683e03390ae2ab96a3eb2f08a2" translate="yes" xml:space="preserve">
          <source>Use this attribute to indicate that the specified function is a break handler. The compiler generates function entry and exit sequences suitable for use in an break handler when this attribute is present. The return from &lt;code&gt;break_handler&lt;/code&gt; is done through the &lt;code&gt;rtbd&lt;/code&gt; instead of &lt;code&gt;rtsd&lt;/code&gt;.</source>
          <target state="translated">使用此属性指示指定的函数是中断处理程序。当存在此属性时，编译器会生成适合在中断处理程序中使用的函数进入和退出序列。 &lt;code&gt;break_handler&lt;/code&gt; 的返回是通过 &lt;code&gt;rtbd&lt;/code&gt; 而不是 &lt;code&gt;rtsd&lt;/code&gt; 完成的。</target>
        </trans-unit>
        <trans-unit id="2edc9f687349668f0ff9d21a9fd536ad89ad9e2f" translate="yes" xml:space="preserve">
          <source>Use this attribute to indicate that the specified function is an interrupt handler or an exception handler (depending on parameters passed to the function, explained further). The compiler generates function entry and exit sequences suitable for use in an interrupt handler when this attribute is present. The &lt;code&gt;IRET&lt;/code&gt; instruction, instead of the &lt;code&gt;RET&lt;/code&gt; instruction, is used to return from interrupt handlers. All registers, except for the EFLAGS register which is restored by the &lt;code&gt;IRET&lt;/code&gt; instruction, are preserved by the compiler. Since GCC doesn&amp;rsquo;t preserve SSE, MMX nor x87 states, the GCC option</source>
          <target state="translated">使用此属性指示指定的函数是中断处理程序还是异常处理程序（取决于传递给该函数的参数，进一步说明）。存在此属性时，编译器会生成适合在中断处理程序中使用的函数进入和退出序列。在 &lt;code&gt;IRET&lt;/code&gt; 指令，代替的 &lt;code&gt;RET&lt;/code&gt; 指令，用于从中断处理程序返回。除由 &lt;code&gt;IRET&lt;/code&gt; 指令恢复的EFLAGS寄存器外，所有寄存器均由编译器保留。由于GCC不会保留SSE，MMX或x87状态，因此GCC选项</target>
        </trans-unit>
        <trans-unit id="0c30254e85a0958ba0ac7ce6feb29ae31661d530" translate="yes" xml:space="preserve">
          <source>Use this attribute to indicate that the specified function is an interrupt handler. The compiler generates function entry and exit sequences suitable for use in an interrupt handler when this attribute is present.</source>
          <target state="translated">使用此属性表示指定的函数是一个中断处理程序。当此属性存在时,编译器会生成适合在中断处理程序中使用的函数进入和退出序列。</target>
        </trans-unit>
        <trans-unit id="d47a65245a7242658fd94eba35172dfdbe8eccc4" translate="yes" xml:space="preserve">
          <source>Use this attribute to indicate that the specified function is an interrupt handler. The compiler generates function entry and exit sequences suitable for use in an interrupt handler when this attribute is present. An optional argument is supported for the interrupt attribute which allows the interrupt mode to be described. By default GCC assumes the external interrupt controller (EIC) mode is in use, this can be explicitly set using &lt;code&gt;eic&lt;/code&gt;. When interrupts are non-masked then the requested Interrupt Priority Level (IPL) is copied to the current IPL which has the effect of only enabling higher priority interrupts. To use vectored interrupt mode use the argument &lt;code&gt;vector=[sw0|sw1|hw0|hw1|hw2|hw3|hw4|hw5]&lt;/code&gt;, this will change the behavior of the non-masked interrupt support and GCC will arrange to mask all interrupts from sw0 up to and including the specified interrupt vector.</source>
          <target state="translated">使用此属性指示指定的函数是中断处理程序。当存在此属性时，编译器会生成适合在中断处理程序中使用的函数进入和退出序列。中断属性支持一个可选参数，该参数允许描述中断模式。默认情况下，GCC假定正在使用外部中断控制器（EIC）模式，可以使用 &lt;code&gt;eic&lt;/code&gt; 对其进行显式设置。如果未屏蔽中断，则将请求的中断优先级（IPL）复制到当前IPL，其作用是仅启用更高优先级的中断。要使用向量中断模式，请使用参数 &lt;code&gt;vector=[sw0|sw1|hw0|hw1|hw2|hw3|hw4|hw5]&lt;/code&gt; ，这将改变非屏蔽中断支持的行为，GCC将安排屏蔽从sw0到指定中断向量（包括指定中断向量）的所有中断。</target>
        </trans-unit>
        <trans-unit id="0ace02ca61dedf94a751682f5d4174fdf42f160d" translate="yes" xml:space="preserve">
          <source>Use this attribute to indicate that the specified function is an interrupt handler. The compiler generates function entry and exit sequences suitable for use in an interrupt handler when this attribute is present. Either name may be used.</source>
          <target state="translated">使用此属性表示指定的函数是一个中断处理程序。当此属性存在时,编译器会生成适合在中断处理程序中使用的函数进入和退出序列。可以使用任一名称。</target>
        </trans-unit>
        <trans-unit id="bb60152fa1da7627a1b21880311cc9395167dfd1" translate="yes" xml:space="preserve">
          <source>Use this attribute to indicate that the specified function is an interrupt handler. The compiler generates function entry and exit sequences suitable for use in an interrupt handler when this attribute is present. It may also generate a special section with code to initialize the interrupt vector table.</source>
          <target state="translated">使用此属性表示指定的函数是一个中断处理程序。当此属性存在时,编译器会生成适合在中断处理程序中使用的函数进入和退出序列。它还可能生成一个特殊部分,其中包含初始化中断向量表的代码。</target>
        </trans-unit>
        <trans-unit id="ea92b79a9f3c03589b9a2bec6c52bb535643eb63" translate="yes" xml:space="preserve">
          <source>Use this attribute to place a variable in the &lt;code&gt;.shared&lt;/code&gt; memory space. This memory space is private to each cooperative thread array; only threads within one thread block refer to the same instance of the variable. The runtime does not initialize variables in this memory space.</source>
          <target state="translated">使用此属性可将变量放置在 &lt;code&gt;.shared&lt;/code&gt; 内存空间中。该内存空间是每个协作线程数组专用的；只有一个线程块中的线程引用该变量的相同实例。运行时不会在此内存空间中初始化变量。</target>
        </trans-unit>
        <trans-unit id="b1ecdb3757207ea0940932cf33695720d7e7f73c" translate="yes" xml:space="preserve">
          <source>Use this attribute together with &lt;code&gt;interrupt_handler&lt;/code&gt;, &lt;code&gt;exception_handler&lt;/code&gt; or &lt;code&gt;nmi_handler&lt;/code&gt; to indicate that the function entry code should enable nested interrupts or exceptions.</source>
          <target state="translated">将此属性与 &lt;code&gt;interrupt_handler&lt;/code&gt; ， &lt;code&gt;exception_handler&lt;/code&gt; 或 &lt;code&gt;nmi_handler&lt;/code&gt; 一起使用，以指示函数入口代码应启用嵌套的中断或异常。</target>
        </trans-unit>
        <trans-unit id="01448e4d9272cc29bf3907d177e8611ce1e38ee0" translate="yes" xml:space="preserve">
          <source>Use this directive in &lt;em&gt;header files&lt;/em&gt; that define object classes, to save space in most of the object files that use those classes. Normally, local copies of certain information (backup copies of inline member functions, debugging information, and the internal tables that implement virtual functions) must be kept in each object file that includes class definitions. You can use this pragma to avoid such duplication. When a header file containing &amp;lsquo;</source>
          <target state="translated">在定义对象类的&lt;em&gt;头文件&lt;/em&gt;中使用此伪指令，以节省使用这些类的大多数对象文件中的空间。通常，某些信息的本地副本（内联成员函数的备份副本，调试信息以及实现虚拟功能的内部表）必须保留在每个包含类定义的对象文件中。您可以使用此编译指示来避免此类重复。当头文件包含&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="d280eeca70b31bee4ab8a083eaebf1bfa7fbe798" translate="yes" xml:space="preserve">
          <source>Use this option for microcontroller with a 5200 core, including the MCF5202, MCF5203, MCF5204 and MCF5206.</source>
          <target state="translated">对于采用5200内核的微控制器,包括MCF5202、MCF5203、MCF5204和MCF5206,使用此选项。</target>
        </trans-unit>
        <trans-unit id="a112527843e5614605b4e3f46e7e6138969c47d8" translate="yes" xml:space="preserve">
          <source>Use this option for microcontrollers with a 68000 or EC000 core, including the 68008, 68302, 68306, 68307, 68322, 68328 and 68356.</source>
          <target state="translated">将此选项用于具有68000或EC000内核的微控制器,包括68008、68302、68306、68307、68322、68328和68356。</target>
        </trans-unit>
        <trans-unit id="63187c5307bd577a4586510b3b1f06b54dea5f9f" translate="yes" xml:space="preserve">
          <source>Use this option for microcontrollers with a CPU32 or CPU32+ core, including the 68330, 68331, 68332, 68333, 68334, 68336, 68340, 68341, 68349 and 68360.</source>
          <target state="translated">将此选项用于具有CPU32或CPU32+内核的微控制器,包括68330、68331、68332、68333、68334、68336、68340、68341、68349和68360。</target>
        </trans-unit>
        <trans-unit id="41f23198542e0d6a3a5d2900310d1b7abe9d3260" translate="yes" xml:space="preserve">
          <source>Use this option to require GCC to construct &lt;em&gt;all&lt;/em&gt; integer constants using code, even if it takes more instructions (the maximum is six).</source>
          <target state="translated">使用此选项要求GCC 使用代码构造&lt;em&gt;所有&lt;/em&gt;整数常量，即使它需要更多指令（最多六个）。</target>
        </trans-unit>
        <trans-unit id="6aa829df1806f0740110776091d0764dbe5ca6cc" translate="yes" xml:space="preserve">
          <source>Use this pragma in a &lt;em&gt;main input file&lt;/em&gt;, when you want full output from included header files to be generated (and made globally visible). The included header file, in turn, should use &amp;lsquo;</source>
          <target state="translated">当您想要从包含的头文件中生成完整的输出（并使其全局可见）时，请在&lt;em&gt;主输入文件中&lt;/em&gt;使用此编译指示。反过来，包含的头文件应使用'</target>
        </trans-unit>
        <trans-unit id="cf5e8f8ca29a0892846d7e7fbb28cf80ccb1a6dd" translate="yes" xml:space="preserve">
          <source>Use traditional TLS as the thread-local storage mechanism for dynamic accesses of TLS variables.</source>
          <target state="translated">使用传统的TLS作为线程本地存储机制来动态访问TLS变量。</target>
        </trans-unit>
        <trans-unit id="d8a60407e03b2ced230c36ef1b80cb979fd89c1c" translate="yes" xml:space="preserve">
          <source>Use uClibc C library. This is the default on &amp;lsquo;</source>
          <target state="translated">使用uClibc C库。这是&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="5a7b4e094ebc57080c3754943807a6fa36611b6e" translate="yes" xml:space="preserve">
          <source>Use uids starting at this parameter for nondebug insns. The range below the parameter is reserved exclusively for debug insns created by</source>
          <target state="translated">对非调试ns使用以该参数开始的ids。该参数下面的范围是专门为由</target>
        </trans-unit>
        <trans-unit id="5c902a2c872ceeb654d592edec56cf917fe25417" translate="yes" xml:space="preserve">
          <source>Use version &lt;var&gt;n&lt;/var&gt; of the C++ ABI. The default is version 0.</source>
          <target state="translated">使用C ++ ABI的版本 &lt;var&gt;n&lt;/var&gt; 。默认值为版本0。</target>
        </trans-unit>
        <trans-unit id="80654292da05f375c19f860e1835e2717583ea50" translate="yes" xml:space="preserve">
          <source>Use version &lt;var&gt;n&lt;/var&gt; of the Objective-C ABI for the selected runtime. This option is currently supported only for the NeXT runtime. In that case, Version 0 is the traditional (32-bit) ABI without support for properties and other Objective-C 2.0 additions. Version 1 is the traditional (32-bit) ABI with support for properties and other Objective-C 2.0 additions. Version 2 is the modern (64-bit) ABI. If nothing is specified, the default is Version 0 on 32-bit target machines, and Version 2 on 64-bit target machines.</source>
          <target state="translated">将Objective-C ABI的版本 &lt;var&gt;n&lt;/var&gt; 用于选定的运行时。当前仅NeXT运行时支持此选项。在这种情况下，版本0是传统的（32位）ABI，不支持属性和其他Objective-C 2.0附加功能。版本1是传统的（32位）ABI，支持属性和其他Objective-C 2.0附加功能。版本2是现代的（64位）ABI。如果未指定任何内容，则默认值为32位目标计算机上的版本0，以及64位目标计算机上的版本2。</target>
        </trans-unit>
        <trans-unit id="60277ce820e41f7e776a5ef4d10492797080b9c8" translate="yes" xml:space="preserve">
          <source>User defined libraries may want to implement their own constant string class. To be able to support them, the GNU Objective-C compiler provides a new command line options</source>
          <target state="translated">用户定义的库可能希望实现他们自己的常量字符串类,为了支持他们,GNU Objective-C编译器提供了新的命令行选项。为了能够支持它们,GNU Objective-C编译器提供了一个新的命令行选项,即</target>
        </trans-unit>
        <trans-unit id="6d924128c5dfe7331fc4ebe7adabf4aa651b95c3" translate="yes" xml:space="preserve">
          <source>Users often think it is a bug when GCC reports an error for code like this:</source>
          <target state="translated">当GCC对这样的代码报错时,用户往往认为这是一个bug。</target>
        </trans-unit>
        <trans-unit id="af3138cc282360a8600ef75867abc1b680f535c7" translate="yes" xml:space="preserve">
          <source>Using &amp;lsquo;</source>
          <target state="translated">使用&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="c673f0c8f99a2c8acaf1de1f7743b24ea2d61bf5" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;__auto_type&lt;/code&gt; instead of &lt;code&gt;typeof&lt;/code&gt; has two advantages:</source>
          <target state="translated">使用 &lt;code&gt;__auto_type&lt;/code&gt; 代替 &lt;code&gt;typeof&lt;/code&gt; 有两个优点：</target>
        </trans-unit>
        <trans-unit id="ae16306fd8fc8ae70da39e8eba7d569ba5d4c5f6" translate="yes" xml:space="preserve">
          <source>Using extended &lt;code&gt;asm&lt;/code&gt; (see &lt;a href=&quot;extended-asm#Extended-Asm&quot;&gt;Extended Asm&lt;/a&gt;) typically produces smaller, safer, and more efficient code, and in most cases it is a better solution than basic &lt;code&gt;asm&lt;/code&gt;. However, there are two situations where only basic &lt;code&gt;asm&lt;/code&gt; can be used:</source>
          <target state="translated">使用扩展 &lt;code&gt;asm&lt;/code&gt; （请参阅&lt;a href=&quot;extended-asm#Extended-Asm&quot;&gt;Extended Asm&lt;/a&gt;）通常会生成更小，更安全，更高效的代码，并且在大多数情况下，它是比基本 &lt;code&gt;asm&lt;/code&gt; 更好的解决方案。但是，在两种情况下只能使用基本的 &lt;code&gt;asm&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="fdb3b64210e267abb96c2653531b3f456e595b0e" translate="yes" xml:space="preserve">
          <source>Using floating point parameters for indirect calls to static functions will not work when using the HP assembler. There simply is no way for GCC to specify what registers hold arguments for static functions when using the HP assembler. GAS for the PA does not have this problem.</source>
          <target state="translated">在使用HP汇编器时,使用浮点参数间接调用静态函数是行不通的。当使用HP汇编器时,GCC根本无法指定哪些寄存器持有静态函数的参数。GAS for the PA则没有这个问题。</target>
        </trans-unit>
        <trans-unit id="7f26807350569d85ac77ce79b84cf07a635bf81a" translate="yes" xml:space="preserve">
          <source>Using gcov with GCC optimization.</source>
          <target state="translated">使用gcov与GCC优化。</target>
        </trans-unit>
        <trans-unit id="057195ec8f49950ab0bbd7ddf35c8adeaad3604e" translate="yes" xml:space="preserve">
          <source>Using that same compiler, this code:</source>
          <target state="translated">使用同样的编译器,这段代码。</target>
        </trans-unit>
        <trans-unit id="2e7015f3209d38900be9cab70f20fe385b6b0e2e" translate="yes" xml:space="preserve">
          <source>Using the GNU Compiler Collection (GCC)</source>
          <target state="translated">使用GNU编译器集合(GCC)</target>
        </trans-unit>
        <trans-unit id="e084cdbad1b5de611e7b01b9c20a68e2bf4e6eb3" translate="yes" xml:space="preserve">
          <source>Using the argument forms of the &lt;code&gt;constructor&lt;/code&gt; and &lt;code&gt;destructor&lt;/code&gt; attributes on targets where the feature is not supported is rejected with an error.</source>
          <target state="translated">在不支持该功能的目标上使用 &lt;code&gt;constructor&lt;/code&gt; 和 &lt;code&gt;destructor&lt;/code&gt; 属性的参数形式会被错误拒绝。</target>
        </trans-unit>
        <trans-unit id="b7a3e4a21bb4f065c09ef23587c979ac36262bbb" translate="yes" xml:space="preserve">
          <source>Using the built-in functions described below, you can record the arguments a function received, and call another function with the same arguments, without knowing the number or types of the arguments.</source>
          <target state="translated">使用下面描述的内置函数,你可以记录一个函数收到的参数,并调用另一个具有相同参数的函数,而不知道参数的数量或类型。</target>
        </trans-unit>
        <trans-unit id="4a1d87094917525e3f4fb29e2aa35aa01c301737" translate="yes" xml:space="preserve">
          <source>Using the cast as the right-hand side of an assignment to a variable of union type is equivalent to storing in a member of the union with the same type</source>
          <target state="translated">使用转储作为联合类型变量赋值的右手边,等同于在联合的成员中存储相同类型的变量。</target>
        </trans-unit>
        <trans-unit id="db9a503a051e32ac0fce6e9c55331f5affaaa22c" translate="yes" xml:space="preserve">
          <source>Using the variable</source>
          <target state="translated">使用变量</target>
        </trans-unit>
        <trans-unit id="b34c5d037644130f54f15d5f39b3ad23e6aef200" translate="yes" xml:space="preserve">
          <source>Using these common set of HTM inline functions, we can create a more portable version of the HTM example in the previous section that will work on either PowerPC or S/390:</source>
          <target state="translated">利用这些常用的HTM内联函数集,我们可以创建上一节中的HTM例子的一个更便携的版本,它可以在PowerPC或S/390上工作。</target>
        </trans-unit>
        <trans-unit id="e5427ab978358d5a7992aa85bab4f2f802b870d2" translate="yes" xml:space="preserve">
          <source>Using this attribute can improve optimization. Compiler predicts that a function with the attribute returns non-null in most cases. Functions like &lt;code&gt;malloc&lt;/code&gt; and &lt;code&gt;calloc&lt;/code&gt; have this property because they return a pointer to uninitialized or zeroed-out storage. However, functions like &lt;code&gt;realloc&lt;/code&gt; do not have this property, as they can return a pointer to storage containing pointers.</source>
          <target state="translated">使用此属性可以改善优化。编译器预测，在大多数情况下，具有属性的函数将返回非null。诸如 &lt;code&gt;malloc&lt;/code&gt; 和 &lt;code&gt;calloc&lt;/code&gt; 之类的函数具有此属性，因为它们返回指向未初始化或归零存储的指针。但是，像 &lt;code&gt;realloc&lt;/code&gt; 这样的函数不具有此属性，因为它们可以将指针返回包含指针的存储。</target>
        </trans-unit>
        <trans-unit id="1b49b124c3d34a77d39d66c92e391e732c60826d" translate="yes" xml:space="preserve">
          <source>Using vector instructions through built-in functions.</source>
          <target state="translated">通过内置函数使用矢量指令。</target>
        </trans-unit>
        <trans-unit id="2dfe46da755d749792dfc6596d3900b7c7d1225d" translate="yes" xml:space="preserve">
          <source>Usually, the more IPA optimizations enabled, the larger the number of impacted functions for each function. In order to control the number of impacted functions and more easily compute the list of impacted function, IPA optimizations can be partially enabled at two different levels.</source>
          <target state="translated">通常情况下,启用的IPA优化越多,每个函数受影响的函数数量就越多。为了控制受影响函数的数量和更容易计算受影响函数的列表,可以在两个不同的层次上部分启用IPA优化。</target>
        </trans-unit>
        <trans-unit id="75ec5cdb7f54185163f339da83a6bb1078cb8cdf" translate="yes" xml:space="preserve">
          <source>Usually, the specified type of a compound literal is a structure. Assume that &lt;code&gt;struct foo&lt;/code&gt; and &lt;code&gt;structure&lt;/code&gt; are declared as shown:</source>
          <target state="translated">通常，复合文字的指定类型是结构。假设 &lt;code&gt;struct foo&lt;/code&gt; 和 &lt;code&gt;structure&lt;/code&gt; 的声明如下所示：</target>
        </trans-unit>
        <trans-unit id="c9ee5681d3c59f7541c27a38b67edf46259e187b" translate="yes" xml:space="preserve">
          <source>V</source>
          <target state="translated">V</target>
        </trans-unit>
        <trans-unit id="574d16a752ab33d0cef891f9de30707743042305" translate="yes" xml:space="preserve">
          <source>V850E2V3</source>
          <target state="translated">V850E2V3</target>
        </trans-unit>
        <trans-unit id="18daea8d25a1ff1128b31b35345423541b18cfb9" translate="yes" xml:space="preserve">
          <source>VFP floating-point registers &lt;code&gt;d0&lt;/code&gt;-&lt;code&gt;d31&lt;/code&gt; and the appropriate subset &lt;code&gt;d0&lt;/code&gt;-&lt;code&gt;d15&lt;/code&gt; based on command line options. Used for 64 bit values only. Not valid for Thumb1.</source>
          <target state="translated">VFP浮点寄存器 &lt;code&gt;d0&lt;/code&gt; - &lt;code&gt;d31&lt;/code&gt; 和相应的子集 &lt;code&gt;d0&lt;/code&gt; - &lt;code&gt;d15&lt;/code&gt; 基于命令行选项。仅用于64位值。对Thumb1无效。</target>
        </trans-unit>
        <trans-unit id="9cbb2d892b07e55db914e77fcb2ce30c1ce00bae" translate="yes" xml:space="preserve">
          <source>VFP floating-point registers &lt;code&gt;s0&lt;/code&gt;-&lt;code&gt;s31&lt;/code&gt;. Used for 32 bit values.</source>
          <target state="translated">VFP浮点寄存器 &lt;code&gt;s0&lt;/code&gt; - &lt;code&gt;s31&lt;/code&gt; 。用于32位值。</target>
        </trans-unit>
        <trans-unit id="3d910167fb4f24dfbb3904aef13e596ce47de5f7" translate="yes" xml:space="preserve">
          <source>VGPR register</source>
          <target state="translated">VGPR寄存器</target>
        </trans-unit>
        <trans-unit id="d5387553aab64197b27321b5224709eacf46c07a" translate="yes" xml:space="preserve">
          <source>VIA C3 CPU with MMX and 3DNow! instruction set support. (No scheduling is implemented for this chip.)</source>
          <target state="translated">威盛C3 CPU,支持MMX和3DNow!指令集。(该芯片没有实现调度。)</target>
        </trans-unit>
        <trans-unit id="488b543fd950a74701b966446818fb5fe7d6e4bc" translate="yes" xml:space="preserve">
          <source>VIA C3-2 (Nehemiah/C5XL) CPU with MMX and SSE instruction set support. (No scheduling is implemented for this chip.)</source>
          <target state="translated">威盛C3-2(Nehemiah/C5XL)CPU,支持MMX和SSE指令集。(该芯片没有实现调度。)</target>
        </trans-unit>
        <trans-unit id="ea585482eb4a4acc3a6360d2898743a7c9373beb" translate="yes" xml:space="preserve">
          <source>VIA C7 (Esther) CPU with MMX, SSE, SSE2 and SSE3 instruction set support. (No scheduling is implemented for this chip.)</source>
          <target state="translated">威盛C7(Esther)CPU,支持MMX、SSE、SSE2和SSE3指令集。(该芯片没有实现调度。)</target>
        </trans-unit>
        <trans-unit id="f935a35014da34c94c36f4bd8a1a050285f9d495" translate="yes" xml:space="preserve">
          <source>VIA Eden Esther CPU with MMX, SSE, SSE2 and SSE3 instruction set support. (No scheduling is implemented for this chip.)</source>
          <target state="translated">威盛Eden Esther CPU,支持MMX、SSE、SSE2和SSE3指令集。(该芯片没有实现调度。)</target>
        </trans-unit>
        <trans-unit id="c111443ef87aeb29107b8a68909620c76e8f94c1" translate="yes" xml:space="preserve">
          <source>VIA Eden Nehemiah CPU with MMX and SSE instruction set support. (No scheduling is implemented for this chip.)</source>
          <target state="translated">威盛Eden Nehemiah CPU,支持MMX和SSE指令集。(该芯片没有实现调度。)</target>
        </trans-unit>
        <trans-unit id="8cce1c624bb9c2543acc6d544b6d1ed27c2158a4" translate="yes" xml:space="preserve">
          <source>VIA Eden Samuel 2 CPU with MMX and 3DNow! instruction set support. (No scheduling is implemented for this chip.)</source>
          <target state="translated">VIA Eden Samuel 2 CPU,支持MMX和3DNow!指令集。(该芯片没有实现调度。)</target>
        </trans-unit>
        <trans-unit id="2151cc7927e87e8f1c1dda8e6327ac4e0a64b7a2" translate="yes" xml:space="preserve">
          <source>VIA Eden X2 CPU with x86-64, MMX, SSE, SSE2 and SSE3 instruction set support. (No scheduling is implemented for this chip.)</source>
          <target state="translated">威盛Eden X2 CPU,支持x86-64、MMX、SSE、SSE2和SSE3指令集。(该芯片没有实现调度)。</target>
        </trans-unit>
        <trans-unit id="1d98ef012706e83dddd4d35e5d791491017f3e46" translate="yes" xml:space="preserve">
          <source>VIA Eden X4 CPU with x86-64, MMX, SSE, SSE2, SSE3, SSSE3, SSE4.1, SSE4.2, AVX and AVX2 instruction set support. (No scheduling is implemented for this chip.)</source>
          <target state="translated">威盛Eden X4 CPU,支持x86-64、MMX、SSE、SSE2、SSE3、SSE3、SSE4.1、SSE4.2、AVX和AVX2指令集。(该芯片没有实现调度)。</target>
        </trans-unit>
        <trans-unit id="b8b4d4a862d49f8ff0f8c10fa3fdc814a539ab87" translate="yes" xml:space="preserve">
          <source>VIA Nano 1xxx CPU with x86-64, MMX, SSE, SSE2, SSE3 and SSSE3 instruction set support. (No scheduling is implemented for this chip.)</source>
          <target state="translated">威盛Nano 1xxx CPU,支持x86-64、MMX、SSE、SSE2、SSE3、SSSE3指令集。(该芯片没有实现调度。)</target>
        </trans-unit>
        <trans-unit id="dd719c7a93195bbf6d07de4c172b28d8c80267d3" translate="yes" xml:space="preserve">
          <source>VIA Nano 2xxx CPU with x86-64, MMX, SSE, SSE2, SSE3 and SSSE3 instruction set support. (No scheduling is implemented for this chip.)</source>
          <target state="translated">威盛Nano 2xxx CPU,支持x86-64、MMX、SSE、SSE2、SSE3、SSSE3指令集。(该芯片没有实现调度。)</target>
        </trans-unit>
        <trans-unit id="01f9fedc3d4f11e857e6f0d9dcaa2b13176b8f56" translate="yes" xml:space="preserve">
          <source>VIA Nano 3xxx CPU with x86-64, MMX, SSE, SSE2, SSE3, SSSE3 and SSE4.1 instruction set support. (No scheduling is implemented for this chip.)</source>
          <target state="translated">威盛Nano 3xxx CPU,支持x86-64、MMX、SSE、SSE2、SSE3和SSE4.1指令集。(该芯片没有实现调度。)</target>
        </trans-unit>
        <trans-unit id="06b544d4bdd7d18ca4149d3c750f4127e9f983b2" translate="yes" xml:space="preserve">
          <source>VIA Nano Dual Core CPU with x86-64, MMX, SSE, SSE2, SSE3, SSSE3 and SSE4.1 instruction set support. (No scheduling is implemented for this chip.)</source>
          <target state="translated">威盛Nano双核CPU,支持x86-64、MMX、SSE、SSE2、SSE3和SSE4.1指令集。(该芯片没有实现调度。)</target>
        </trans-unit>
        <trans-unit id="a67ea4083339300c1d547f346d07c9d5764525af" translate="yes" xml:space="preserve">
          <source>VIA Nano Quad Core CPU with x86-64, MMX, SSE, SSE2, SSE3, SSSE3 and SSE4.1 instruction set support. (No scheduling is implemented for this chip.)</source>
          <target state="translated">威盛Nano四核CPU,支持x86-64、MMX、SSE、SSE2、SSE3和SSE4.1指令集。(该芯片没有实现调度。)</target>
        </trans-unit>
        <trans-unit id="04026107ef9bdc35c4d06c69d4d8d9bd034df2b9" translate="yes" xml:space="preserve">
          <source>VPCLMULQDQ instructions.</source>
          <target state="translated">VPCLMULQDQ指令。</target>
        </trans-unit>
        <trans-unit id="47b598fadc542503a4dfb3ab0e7c08963d810a39" translate="yes" xml:space="preserve">
          <source>VRSAVE</source>
          <target state="translated">VRSAVE</target>
        </trans-unit>
        <trans-unit id="55aa2f856c0f4ab3cdcac26a348778a588a6f8d7" translate="yes" xml:space="preserve">
          <source>VSIB address operand.</source>
          <target state="translated">VSIB地址操作数。</target>
        </trans-unit>
        <trans-unit id="1e028c813fc89395b126781b62fe740e1e2e5612" translate="yes" xml:space="preserve">
          <source>VSX register if direct move instructions are enabled, or NO_REGS.</source>
          <target state="translated">如果启用了直接移动指令,则为VSX寄存器,否则为NO_REGS。</target>
        </trans-unit>
        <trans-unit id="b1bf4ce917ea0e342c5ba87416d3c1425045396d" translate="yes" xml:space="preserve">
          <source>VSX register if the</source>
          <target state="translated">VSX 寄存器,如果</target>
        </trans-unit>
        <trans-unit id="fa37e771ee1559b7e1a74968d2d6f9d21bbad3f8" translate="yes" xml:space="preserve">
          <source>VSX register to use for IEEE 128-bit floating point TFmode, or NO_REGS.</source>
          <target state="translated">VSX寄存器用于IEEE 128位浮点TFmode,或NO_REGS。</target>
        </trans-unit>
        <trans-unit id="dceb09e56dc6976e2ceb44b306b90d48c16cdbfa" translate="yes" xml:space="preserve">
          <source>VSX register to use for IEEE 128-bit floating point, or NO_REGS.</source>
          <target state="translated">VSX寄存器用于IEEE 128位浮点,或NO_REGS。</target>
        </trans-unit>
        <trans-unit id="5f2931cf969db5dec892ea6c97702a431f737f4f" translate="yes" xml:space="preserve">
          <source>VSX register to use for ISA 3.0 vector instructions, or NO_REGS.</source>
          <target state="translated">VSX寄存器用于ISA 3.0向量指令,或NO_REGS。</target>
        </trans-unit>
        <trans-unit id="e1e2b74202b4df2a34423d711c880f4bed5b3b14" translate="yes" xml:space="preserve">
          <source>VSX vector register to hold 128 bit integer or NO_REGS.</source>
          <target state="translated">VSX向量寄存器,用于存放128位整数或NO_REGS。</target>
        </trans-unit>
        <trans-unit id="f3dc5e0d7bbebef3893829b42a25b08c256dd4d8" translate="yes" xml:space="preserve">
          <source>VSX vector register to hold scalar double values or NO_REGS.</source>
          <target state="translated">VSX向量寄存器,用于存放标量双值或NO_REGS。</target>
        </trans-unit>
        <trans-unit id="dc350e1093c1db7d408d43c001ed04b73c029f23" translate="yes" xml:space="preserve">
          <source>VSX vector register to hold vector double data or NO_REGS.</source>
          <target state="translated">VSX向量寄存器用来存放向量双数据或NO_REGS。</target>
        </trans-unit>
        <trans-unit id="167ef2a892b4ddc57b82f58074b39f524e5008e6" translate="yes" xml:space="preserve">
          <source>VSX vector register to hold vector float data or NO_REGS.</source>
          <target state="translated">VSX向量寄存器,用于存放向量浮动数据或NO_REGS。</target>
        </trans-unit>
        <trans-unit id="81969f619b07a96e38c916b9993cc433143a784f" translate="yes" xml:space="preserve">
          <source>VTables</source>
          <target state="translated">VTables</target>
        </trans-unit>
        <trans-unit id="f5f8e1247b6f26b263b34207afe669cb4ac9de15" translate="yes" xml:space="preserve">
          <source>Valid ISO C and ISO C++ programs should compile properly with or without this option (though a rare few require</source>
          <target state="translated">不管有没有这个选项,有效的ISO C和ISO C++程序都应该能正常编译(尽管有极少数的程序需要使用</target>
        </trans-unit>
        <trans-unit id="6c1f687862693a87865ad97fba05738669eac5ce" translate="yes" xml:space="preserve">
          <source>Valid alignment values other than those returned by an _Alignof expression for fundamental types, if any (C11 6.2.8).</source>
          <target state="translated">除了基本类型的_Alignof表达式返回的值以外的有效对齐值(如果有的话)(C11 6.2.8)。</target>
        </trans-unit>
        <trans-unit id="b8f1ffda93c672ca444e36a4f56d16e63e5832c4" translate="yes" xml:space="preserve">
          <source>Valid alignments are powers of 2 up to and including &lt;em&gt;2^{28}&lt;/em&gt;.</source>
          <target state="translated">有效对齐方式是2的幂，最高为&lt;em&gt;2 ^ {28}&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="e0567df87b1ea75cda27929ada4a4306a0c755cd" translate="yes" xml:space="preserve">
          <source>Valid options for &lt;var&gt;time&lt;/var&gt; are</source>
          <target state="translated">&lt;var&gt;time&lt;/var&gt; 有效选项是</target>
        </trans-unit>
        <trans-unit id="bd15e3ace5dbddf7a0573a3f99038d776bddea91" translate="yes" xml:space="preserve">
          <source>Value appropriate as displacement.</source>
          <target state="translated">适当的值作为位移。</target>
        </trans-unit>
        <trans-unit id="bb6561e8ab01989a094611590f0602e85a6c5513" translate="yes" xml:space="preserve">
          <source>Values &amp;lsquo;</source>
          <target state="translated">价值观</target>
        </trans-unit>
        <trans-unit id="d206078a63cff7bace258bb1f4bb9507b5cf8d12" translate="yes" xml:space="preserve">
          <source>Variable, function, and type attributes for C++ only.</source>
          <target state="translated">仅适用于C++的变量、函数和类型属性。</target>
        </trans-unit>
        <trans-unit id="02b16fb34038c0c62719510ede0c2e29dc2b90fc" translate="yes" xml:space="preserve">
          <source>Variable-length automatic arrays are allowed in ISO C99, and as an extension GCC accepts them in C90 mode and in C++. These arrays are declared like any other automatic arrays, but with a length that is not a constant expression. The storage is allocated at the point of declaration and deallocated when the block scope containing the declaration exits. For example:</source>
          <target state="translated">在ISO C99中允许使用可变长度的自动数组,作为扩展,GCC在C90模式和C++中接受它们。这些数组和其他自动数组一样被声明,但其长度不是一个常量表达式。存储器在声明时分配,并在包含声明的块作用域退出时deocallated。例如</target>
        </trans-unit>
        <trans-unit id="c1cafb0eff03f52681f175e65218139665f9ce2c" translate="yes" xml:space="preserve">
          <source>Variables declared at global scope.</source>
          <target state="translated">在全局范围内声明的变量。</target>
        </trans-unit>
        <trans-unit id="5c01cb4a8cb1760f9b45c63f7213bd015da5c74c" translate="yes" xml:space="preserve">
          <source>Variables declared within a function.</source>
          <target state="translated">在函数中声明的变量。</target>
        </trans-unit>
        <trans-unit id="b8da0198222d30500868466badddd4041e14cce0" translate="yes" xml:space="preserve">
          <source>Variables of size &lt;var&gt;n&lt;/var&gt; bytes or smaller are placed in the &lt;code&gt;.based&lt;/code&gt; section by default. Based variables use the &lt;code&gt;$tp&lt;/code&gt; register as a base register, and there is a 128-byte limit to the &lt;code&gt;.based&lt;/code&gt; section.</source>
          <target state="translated">默认情况下，大小为 &lt;var&gt;n&lt;/var&gt; 字节或更小的变量位于 &lt;code&gt;.based&lt;/code&gt; 节中。基本变量将 &lt;code&gt;$tp&lt;/code&gt; 寄存器用作基本寄存器，并且 &lt;code&gt;.based&lt;/code&gt; 节有128个字节的限制。</target>
        </trans-unit>
        <trans-unit id="10abea2eed8c32edbb792ccf39c883573091a3b2" translate="yes" xml:space="preserve">
          <source>Variables that are &lt;var&gt;n&lt;/var&gt; bytes or smaller are allocated to the &lt;code&gt;.tiny&lt;/code&gt; section. These variables use the &lt;code&gt;$gp&lt;/code&gt; base register. The default for this option is 4, but note that there&amp;rsquo;s a 65536-byte limit to the &lt;code&gt;.tiny&lt;/code&gt; section.</source>
          <target state="translated">&lt;var&gt;n&lt;/var&gt; 字节或更小的变量分配给 &lt;code&gt;.tiny&lt;/code&gt; 节。这些变量使用 &lt;code&gt;$gp&lt;/code&gt; 基址寄存器。此选项的默认值为4，但请注意 &lt;code&gt;.tiny&lt;/code&gt; 节的限制为65536字节。</target>
        </trans-unit>
        <trans-unit id="fd3f9d35c079daab2745eafe9db9775e6794913e" translate="yes" xml:space="preserve">
          <source>Variables with the &lt;code&gt;cb&lt;/code&gt; attribute are used to access the control bus, using special instructions. &lt;code&gt;addr&lt;/code&gt; indicates the control bus address. Example:</source>
          <target state="translated">具有 &lt;code&gt;cb&lt;/code&gt; 属性的变量用于通过特殊指令访问控制总线。 &lt;code&gt;addr&lt;/code&gt; 指示控制总线地址。例：</target>
        </trans-unit>
        <trans-unit id="de934aeb77c58838cc9846aadb82fbd1b8f30e96" translate="yes" xml:space="preserve">
          <source>Variables with the &lt;code&gt;far&lt;/code&gt; attribute are addressed using a full 32-bit address. Since this covers the entire memory space, this allows modules to make no assumptions about where variables might be stored.</source>
          <target state="translated">具有 &lt;code&gt;far&lt;/code&gt; 属性的变量使用完整的32位地址进行寻址。由于这覆盖了整个内存空间，因此模块无需对变量的存储位置进行任何假设。</target>
        </trans-unit>
        <trans-unit id="36905cf24c84385c4961b4619b30de52faf8e512" translate="yes" xml:space="preserve">
          <source>Variables with the &lt;code&gt;io&lt;/code&gt; attribute are used to address memory-mapped peripherals. If an address is specified, the variable is assigned that address, else it is not assigned an address (it is assumed some other module assigns an address). Example:</source>
          <target state="translated">具有 &lt;code&gt;io&lt;/code&gt; 属性的变量用于寻址内存映射的外围设备。如果指定了地址，则为变量分配该地址，否则不为其分配地址（假定其他模块分配了地址）。例：</target>
        </trans-unit>
        <trans-unit id="8908399e90d6597694e9414404cf146058083fc2" translate="yes" xml:space="preserve">
          <source>Variables with the &lt;code&gt;near&lt;/code&gt; attribute are assumed to have addresses that fit in a 24-bit addressing mode. This is the default for large variables (&lt;code&gt;-mtiny=4&lt;/code&gt; is the default) but this attribute can override &lt;code&gt;-mtiny=&lt;/code&gt; for small variables, or override &lt;code&gt;-ml&lt;/code&gt;.</source>
          <target state="translated">假定具有 &lt;code&gt;near&lt;/code&gt; 属性的变量具有适合24位寻址模式的地址。这是大变量的默认值（默认 &lt;code&gt;-mtiny=4&lt;/code&gt; ），但是对于小变量，此属性可以覆盖 &lt;code&gt;-mtiny=&lt;/code&gt; ，或者覆盖 &lt;code&gt;-ml&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5f34701193da16d128be7840c2b5e27cdc6209c0" translate="yes" xml:space="preserve">
          <source>Variadic functions always use the &lt;code&gt;&quot;aapcs&quot;&lt;/code&gt; calling convention and the compiler rejects attempts to specify an alternative.</source>
          <target state="translated">可变参数函数始终使用 &lt;code&gt;&quot;aapcs&quot;&lt;/code&gt; 调用约定，并且编译器拒绝尝试指定替代项的尝试。</target>
        </trans-unit>
        <trans-unit id="c34add3442e320001d71a4acf459f90b84551e3c" translate="yes" xml:space="preserve">
          <source>Variations on C++.</source>
          <target state="translated">C++的变种。</target>
        </trans-unit>
        <trans-unit id="0125a3430008ecbd7c8a33ef91916cf2ea436c9e" translate="yes" xml:space="preserve">
          <source>Variations on Objective-C and Objective-C++.</source>
          <target state="translated">Objective-C和Objective-C++的变体。</target>
        </trans-unit>
        <trans-unit id="eb5d846c7919ee0bdc2338a4cc38cee42f3c00b6" translate="yes" xml:space="preserve">
          <source>Vector comparison is supported with standard comparison operators: &lt;code&gt;==, !=, &amp;lt;, &amp;lt;=, &amp;gt;, &amp;gt;=&lt;/code&gt;. Comparison operands can be vector expressions of integer-type or real-type. Comparison between integer-type vectors and real-type vectors are not supported. The result of the comparison is a vector of the same width and number of elements as the comparison operands with a signed integral element type.</source>
          <target state="translated">标准比较运算符支持向量比较： &lt;code&gt;==, !=, &amp;lt;, &amp;lt;=, &amp;gt;, &amp;gt;=&lt;/code&gt; 。比较操作数可以是整数类型或实数类型的向量表达式。不支持在整数型向量和实型向量之间进行比较。比较的结果是一个向量，该向量具有与带符号整数元素类型的比较操作数相同的元素宽度和数量。</target>
        </trans-unit>
        <trans-unit id="5abc95e73e06fb4a5dc5582edf5afa312b0850ca" translate="yes" xml:space="preserve">
          <source>Vector condition register: VCC, VCC_LO, VCC_HI</source>
          <target state="translated">矢量条件寄存器,VCC、VCC_LO、VCC_HI VCC,VCC_LO,VCC_HI。</target>
        </trans-unit>
        <trans-unit id="53804d00035aa75837541b3ccf479dca992da7d5" translate="yes" xml:space="preserve">
          <source>Vector constant that can be loaded with XXSPLTIB &amp;amp; sign extension.</source>
          <target state="translated">可以用XXSPLTIB和符号扩展名加载的向量常量。</target>
        </trans-unit>
        <trans-unit id="82f741b1697518a50ba54947e1a23cae2eaec1c0" translate="yes" xml:space="preserve">
          <source>Vector constant that can be loaded with the XXSPLTIB instruction.</source>
          <target state="translated">可以用XXSPLTIB指令加载的向量常数。</target>
        </trans-unit>
        <trans-unit id="46e517c61990308718dcf40277ed1d92f620280a" translate="yes" xml:space="preserve">
          <source>Vector constant that does not require memory</source>
          <target state="translated">不需要内存的向量常数</target>
        </trans-unit>
        <trans-unit id="b42c5127757a32ed5d06d2b5cf09ce9893f82ec9" translate="yes" xml:space="preserve">
          <source>Vector constant that is all zeros.</source>
          <target state="translated">全为零的向量常数。</target>
        </trans-unit>
        <trans-unit id="9c36bdfc3b8d0b06a49e5ef972497ba956ef9bbc" translate="yes" xml:space="preserve">
          <source>Vector conversion is available using the &lt;code&gt;__builtin_convertvector (vec, vectype)&lt;/code&gt; function. &lt;var&gt;vec&lt;/var&gt; must be an expression with integral or floating vector type and &lt;var&gt;vectype&lt;/var&gt; an integral or floating vector type with the same number of elements. The result has &lt;var&gt;vectype&lt;/var&gt; type and value of a C cast of every element of &lt;var&gt;vec&lt;/var&gt; to the element type of &lt;var&gt;vectype&lt;/var&gt;.</source>
          <target state="translated">使用 &lt;code&gt;__builtin_convertvector (vec, vectype)&lt;/code&gt; 函数可以进行向量转换。 &lt;var&gt;vec&lt;/var&gt; 必须是具有整数或浮点向量类型的表达式，而 &lt;var&gt;vectype&lt;/var&gt; 必须是具有相同数量元素的整数或浮点向量类型。结果具有 &lt;var&gt;vectype&lt;/var&gt; 类型和 &lt;var&gt;vec&lt;/var&gt; 的每个元素到 &lt;var&gt;vectype&lt;/var&gt; 的元素类型的C转换的值。</target>
        </trans-unit>
        <trans-unit id="d3bad6bdbaf23ec0df51bc6d85940b036ecbab94" translate="yes" xml:space="preserve">
          <source>Vector registers.</source>
          <target state="translated">向量寄存器。</target>
        </trans-unit>
        <trans-unit id="8e0df7cd51c0d162c1fce7156e6eae770327c8c2" translate="yes" xml:space="preserve">
          <source>Vector shuffling is available using functions &lt;code&gt;__builtin_shuffle (vec, mask)&lt;/code&gt; and &lt;code&gt;__builtin_shuffle (vec0, vec1, mask)&lt;/code&gt;. Both functions construct a permutation of elements from one or two vectors and return a vector of the same type as the input vector(s). The &lt;var&gt;mask&lt;/var&gt; is an integral vector with the same width (&lt;var&gt;W&lt;/var&gt;) and element count (&lt;var&gt;N&lt;/var&gt;) as the output vector.</source>
          <target state="translated">使用功能 &lt;code&gt;__builtin_shuffle (vec, mask)&lt;/code&gt; 和 &lt;code&gt;__builtin_shuffle (vec0, vec1, mask)&lt;/code&gt; 可以进行向量改组。这两个函数从一个或两个向量构造元素的置换，并返回与输入向量相同类型的向量。所述 &lt;var&gt;mask&lt;/var&gt; 是具有相同的宽度（一个组成向量 &lt;var&gt;W&lt;/var&gt; ）和元素计数（ &lt;var&gt;N&lt;/var&gt; ）作为输出矢量。</target>
        </trans-unit>
        <trans-unit id="58128c4d1de4d0a51bf04fac4cddbc549bd01efb" translate="yes" xml:space="preserve">
          <source>Vector zero</source>
          <target state="translated">向量零</target>
        </trans-unit>
        <trans-unit id="73c5f8f62b1af06d2d8df3f66347a1a059d5cf24" translate="yes" xml:space="preserve">
          <source>Vectors are compared element-wise producing 0 when comparison is false and -1 (constant of the appropriate type where all bits are set) otherwise. Consider the following example.</source>
          <target state="translated">当比较为假时,会按元素进行比较,当比较为假时,会产生0,否则会产生-1(适当类型的常量,所有位都被设置)。请看下面的例子。</target>
        </trans-unit>
        <trans-unit id="fcd23bd0a88ba1a503b10ed5edf55ece81978ffc" translate="yes" xml:space="preserve">
          <source>Vectors can be subscripted as if the vector were an array with the same number of elements and base type. Out of bound accesses invoke undefined behavior at run time. Warnings for out of bound accesses for vector subscription can be enabled with</source>
          <target state="translated">向量可以被下标,就像向量是一个具有相同元素数量和基类型的数组一样。在运行时,越界访问会引起未定义的行为。对于向量订阅的越界访问的警告可以通过使用</target>
        </trans-unit>
        <trans-unit id="e368f0bdb096cdc80b942de26edde7361d633b14" translate="yes" xml:space="preserve">
          <source>Version 0 refers to the version conforming most closely to the C++ ABI specification. Therefore, the ABI obtained using version 0 will change in different versions of G++ as ABI bugs are fixed.</source>
          <target state="translated">版本0指的是最符合C++ABI规范的版本,因此,使用版本0得到的ABI在不同的G++版本中会随着ABI bug的修复而改变。因此,在不同版本的G++中,随着ABI错误的修复,使用0版本得到的ABI会发生变化。</target>
        </trans-unit>
        <trans-unit id="4d24a59e560f384b23499b32746ec055716a43ab" translate="yes" xml:space="preserve">
          <source>Version 1 is the version of the C++ ABI that first appeared in G++ 3.2.</source>
          <target state="translated">第1版是首次出现在G++3.2中的C++ABI的版本。</target>
        </trans-unit>
        <trans-unit id="3c0b003b505c0ed05512e30de5602e0fe9cf92cd" translate="yes" xml:space="preserve">
          <source>Version 10, which first appeared in G++ 6.1, adds mangling of attributes that affect type identity, such as ia32 calling convention attributes (e.g. &amp;lsquo;</source>
          <target state="translated">第10版（最早出现在G ++ 6.1中）增加了影响类型标识的属性的修饰，例如ia32调用约定属性（例如'</target>
        </trans-unit>
        <trans-unit id="663092bb020840a15939c0d6a393bb5154dcf611" translate="yes" xml:space="preserve">
          <source>Version 11, which first appeared in G++ 7, corrects the mangling of sizeof... expressions and operator names. For multiple entities with the same name within a function, that are declared in different scopes, the mangling now changes starting with the twelfth occurrence. It also implies</source>
          <target state="translated">首次出现在 G++7 中的第 11 版纠正了 sizeof...表达式和运算符名称的混乱。对于在不同作用域中声明的、在一个函数中具有相同名称的多个实体,现在从第12次出现时开始改变混淆。这也意味着</target>
        </trans-unit>
        <trans-unit id="0ca6a1ee7b0905689803a926babe92130837b997" translate="yes" xml:space="preserve">
          <source>Version 12, which first appeared in G++ 8, corrects the calling conventions for empty classes on the x86_64 target and for classes with only deleted copy/move constructors. It accidentally changes the calling convention for classes with a deleted copy constructor and a trivial move constructor.</source>
          <target state="translated">第12版首次出现在G++8中,它纠正了x86_64目标上的空类和只有删除的复制/移动构造函数的类的调用约定。它意外地改变了具有删除的复制构造函数和琐碎的移动构造函数的类的调用惯例。</target>
        </trans-unit>
        <trans-unit id="50a009d60ade6b341d095db62ce8f2e0c4f1391a" translate="yes" xml:space="preserve">
          <source>Version 13, which first appeared in G++ 8.2, fixes the accidental change in version 12.</source>
          <target state="translated">第13版最早出现在G++8.2中,修复了12版中的意外改动。</target>
        </trans-unit>
        <trans-unit id="3b38c5970d57d0e95ac144e09f14ebe98042886d" translate="yes" xml:space="preserve">
          <source>Version 2 is the version of the C++ ABI that first appeared in G++ 3.4, and was the default through G++ 4.9.</source>
          <target state="translated">版本2是C++ABI的版本,它最早出现在G++3.4中,并在G++4.9之前一直是默认的。</target>
        </trans-unit>
        <trans-unit id="b724fbb5aa7b15b70d72eb03063512067a94eeca" translate="yes" xml:space="preserve">
          <source>Version 3 corrects an error in mangling a constant address as a template argument.</source>
          <target state="translated">第3版纠正了一个将常量地址作为模板参数的错误。</target>
        </trans-unit>
        <trans-unit id="01a6ae459293959ae77cf0ff9e1fc859781779ed" translate="yes" xml:space="preserve">
          <source>Version 4 may require GDB 7.0 and</source>
          <target state="translated">第4版可能需要GDB 7.0 和</target>
        </trans-unit>
        <trans-unit id="dd83630f9225432d363943045fc9c9e3da8fa1fd" translate="yes" xml:space="preserve">
          <source>Version 4, which first appeared in G++ 4.5, implements a standard mangling for vector types.</source>
          <target state="translated">第4版最早出现在G++4.5中,它实现了向量类型的标准混搭。</target>
        </trans-unit>
        <trans-unit id="bcd8e454766585098e98a3f378e25d4a3a094eb0" translate="yes" xml:space="preserve">
          <source>Version 5, which first appeared in G++ 4.6, corrects the mangling of attribute const/volatile on function pointer types, decltype of a plain decl, and use of a function parameter in the declaration of another parameter.</source>
          <target state="translated">第5版首次出现在G++4.6中,它纠正了函数指针类型上属性const/volatile的混杂,一个普通decl的decltype,以及在另一个参数的声明中使用一个函数参数。</target>
        </trans-unit>
        <trans-unit id="b60149f703c30d6cd13e3a5cac7ff5559e1b4439" translate="yes" xml:space="preserve">
          <source>Version 6, which first appeared in G++ 4.7, corrects the promotion behavior of C++11 scoped enums and the mangling of template argument packs, const/static_cast, prefix ++ and &amp;ndash;, and a class scope function used as a template argument.</source>
          <target state="translated">第6版首次出现在G ++ 4.7中，它纠正了C ++ 11范围内的枚举的提升行为以及模板参数包，const / static_cast，前缀++和&amp;ndash;和用作模板参数的类范围函数的混乱。</target>
        </trans-unit>
        <trans-unit id="4782295af04ef7af5fe54b3ee6d18f5a34a794e5" translate="yes" xml:space="preserve">
          <source>Version 7, which first appeared in G++ 4.8, that treats nullptr_t as a builtin type and corrects the mangling of lambdas in default argument scope.</source>
          <target state="translated">第7版,首次出现在G++4.8中,它将nullptr_t视为内建类型,并纠正了默认参数作用域中lambdas的混杂。</target>
        </trans-unit>
        <trans-unit id="d1c84e5d1ca1394d2ffa2a327b111624fb731bc7" translate="yes" xml:space="preserve">
          <source>Version 8, which first appeared in G++ 4.9, corrects the substitution behavior of function types with function-cv-qualifiers.</source>
          <target state="translated">第8版首次出现在G++4.9中,修正了带有函数-cv-限定符的函数类型的替换行为。</target>
        </trans-unit>
        <trans-unit id="4ac00f95e84165203755f6a82a57d89ac3c1bab9" translate="yes" xml:space="preserve">
          <source>Version 9, which first appeared in G++ 5.2, corrects the alignment of &lt;code&gt;nullptr_t&lt;/code&gt;.</source>
          <target state="translated">版本9（最早出现在G ++ 5.2中）更正了 &lt;code&gt;nullptr_t&lt;/code&gt; 的对齐方式。</target>
        </trans-unit>
        <trans-unit id="1cbaf9a36f9cc94b3082b235b02920043f217806" translate="yes" xml:space="preserve">
          <source>Visium&amp;mdash;</source>
          <target state="translated">Visium&amp;mdash;</target>
        </trans-unit>
        <trans-unit id="ea87a96f76fbda4a0ceea67f5b82b7da4f4e2ed4" translate="yes" xml:space="preserve">
          <source>Volatile memory access bypass the cache using the I/O variants of the load and store instructions. The default is not to bypass the cache.</source>
          <target state="translated">挥发性内存访问使用加载和存储指令的I/O变体绕过缓存。默认情况是不绕过高速缓存。</target>
        </trans-unit>
        <trans-unit id="e2415cb7f63df0c9de23362326ad3c37a9adfc96" translate="yes" xml:space="preserve">
          <source>W</source>
          <target state="translated">W</target>
        </trans-unit>
        <trans-unit id="1b1d16cb93f0aa2689c3eb4f6494e062863aa127" translate="yes" xml:space="preserve">
          <source>Warn about C++ constructs whose meaning differs between ISO C++ 1998 and ISO C++ 2011, e.g., identifiers in ISO C++ 1998 that are keywords in ISO C++ 2011. This warning turns on</source>
          <target state="translated">对ISO C++1998和ISO C++2011意义不同的C++结构提出警告,例如,ISO C++1998中的标识符在ISO C++2011中是关键字。这个警告会开启</target>
        </trans-unit>
        <trans-unit id="a16be8e81dda2e7fc6c8f9439ff0fc768831de14" translate="yes" xml:space="preserve">
          <source>Warn about C++ constructs whose meaning differs between ISO C++ 2011 and ISO C++ 2014. This warning is enabled by</source>
          <target state="translated">对ISO C++2011和ISO C++2014之间含义不同的C++结构提出警告。启用该警告的方法是</target>
        </trans-unit>
        <trans-unit id="7632b789c4deefeb017ad2d53cdd4160afd5fe89" translate="yes" xml:space="preserve">
          <source>Warn about C++ constructs whose meaning differs between ISO C++ 2014 and ISO C++ 2017. This warning is enabled by</source>
          <target state="translated">警告C++结构,其含义在ISO C++2014和ISO C++2017之间有所不同。该警告通过以下方式启用</target>
        </trans-unit>
        <trans-unit id="53b51f298dc17e10801636bad5bebb8011117716" translate="yes" xml:space="preserve">
          <source>Warn about ISO C constructs that are outside of the common subset of ISO C and ISO C++, e.g. request for implicit conversion from &lt;code&gt;void *&lt;/code&gt; to a pointer to non-&lt;code&gt;void&lt;/code&gt; type.</source>
          <target state="translated">警告在ISO C和ISO C ++的公共子集之外的ISO C构造，例如，请求从 &lt;code&gt;void *&lt;/code&gt; 隐式转换为指向非 &lt;code&gt;void&lt;/code&gt; 类型的指针。</target>
        </trans-unit>
        <trans-unit id="4f7de69bb81f9d506bfb6d47f928c946ab6b330c" translate="yes" xml:space="preserve">
          <source>Warn about One Definition Rule violations during link-time optimization. Requires</source>
          <target state="translated">在链接时间优化过程中,警告违反一定义规则。需要</target>
        </trans-unit>
        <trans-unit id="f7cf98ad983fadf59ea9d8e55fff149a4d55f39b" translate="yes" xml:space="preserve">
          <source>Warn about a comparison between values of different enumerated types. In C++ enumerated type mismatches in conditional expressions are also diagnosed and the warning is enabled by default. In C this warning is enabled by</source>
          <target state="translated">对不同枚举类型的值之间的比较发出警告。在C++中,条件表达式中的枚举类型不匹配也会被诊断出来,默认情况下该警告是启用的。在C语言中,这个警告是由</target>
        </trans-unit>
        <trans-unit id="5887fb5f81adf7425e8f523309718b847865d42f" translate="yes" xml:space="preserve">
          <source>Warn about a definition of an unsized deallocation function</source>
          <target state="translated">警告一个无大小的去分配函数的定义</target>
        </trans-unit>
        <trans-unit id="a4b22fdd430cf26b4eb0550ba2a6437e719969f1" translate="yes" xml:space="preserve">
          <source>Warn about a new-expression of a type that requires greater alignment than the &lt;code&gt;alignof(std::max_align_t)&lt;/code&gt; but uses an allocation function without an explicit alignment parameter. This option is enabled by</source>
          <target state="translated">警告有关比 &lt;code&gt;alignof(std::max_align_t)&lt;/code&gt; 需要更大的对齐方式但使用没有显式对齐参数的分配函数的类型的new表达式。此选项通过以下方式启用</target>
        </trans-unit>
        <trans-unit id="57392da628b0c1cb78f8e90a0ce56848a537dcc1" translate="yes" xml:space="preserve">
          <source>Warn about anything that depends on the &amp;ldquo;size of&amp;rdquo; a function type or of &lt;code&gt;void&lt;/code&gt;. GNU C assigns these types a size of 1, for convenience in calculations with &lt;code&gt;void *&lt;/code&gt; pointers and pointers to functions. In C++, warn also when an arithmetic operation involves &lt;code&gt;NULL&lt;/code&gt;. This warning is also enabled by</source>
          <target state="translated">警告任何取决于函数类型或 &lt;code&gt;void&lt;/code&gt; 的&amp;ldquo;大小&amp;rdquo;的内容。为了方便使用 &lt;code&gt;void *&lt;/code&gt; 指针和函数指针，GNU C将这些类型的大小分配为1 。在C ++中，当算术运算涉及 &lt;code&gt;NULL&lt;/code&gt; 时也要发出警告。此警告也通过以下方式启用</target>
        </trans-unit>
        <trans-unit id="a808a76d216f717246383427b89eff52c9b874ec" translate="yes" xml:space="preserve">
          <source>Warn about boolean expression compared with an integer value different from &lt;code&gt;true&lt;/code&gt;/&lt;code&gt;false&lt;/code&gt;. For instance, the following comparison is always false:</source>
          <target state="translated">警告布尔表达式与不同于 &lt;code&gt;true&lt;/code&gt; / &lt;code&gt;false&lt;/code&gt; 的整数值。例如，以下比较始终为假：</target>
        </trans-unit>
        <trans-unit id="a9d532ae5e4af7c1749f0187b9a6c681cd5f881a" translate="yes" xml:space="preserve">
          <source>Warn about calls to allocation functions decorated with attribute &lt;code&gt;alloc_size&lt;/code&gt; that specify zero bytes, including those to the built-in forms of the functions &lt;code&gt;aligned_alloc&lt;/code&gt;, &lt;code&gt;alloca&lt;/code&gt;, &lt;code&gt;calloc&lt;/code&gt;, &lt;code&gt;malloc&lt;/code&gt;, and &lt;code&gt;realloc&lt;/code&gt;. Because the behavior of these functions when called with a zero size differs among implementations (and in the case of &lt;code&gt;realloc&lt;/code&gt; has been deprecated) relying on it may result in subtle portability bugs and should be avoided.</source>
          <target state="translated">警告调用饰属性分配功能 &lt;code&gt;alloc_size&lt;/code&gt; 指定零个字节，包括那些功能的内置形式 &lt;code&gt;aligned_alloc&lt;/code&gt; ， &lt;code&gt;alloca&lt;/code&gt; ， &lt;code&gt;calloc&lt;/code&gt; ， &lt;code&gt;malloc&lt;/code&gt; 的，和 &lt;code&gt;realloc&lt;/code&gt; 的。因为以零大小调用这些函数的行为在实现中会有所不同（并且在不赞成使用 &lt;code&gt;realloc&lt;/code&gt; 的情况下），因此依赖它们可能会导致细微的可移植性错误，应避免使用。</target>
        </trans-unit>
        <trans-unit id="3cff65779e3725cfbc2854d42263f2ace49a0bba" translate="yes" xml:space="preserve">
          <source>Warn about calls to formatted input/output functions such as &lt;code&gt;snprintf&lt;/code&gt; and &lt;code&gt;vsnprintf&lt;/code&gt; that might result in output truncation. When the exact number of bytes written by a format directive cannot be determined at compile-time it is estimated based on heuristics that depend on the &lt;var&gt;level&lt;/var&gt; argument and on optimization. While enabling optimization will in most cases improve the accuracy of the warning, it may also result in false positives. Except as noted otherwise, the option uses the same logic</source>
          <target state="translated">警告有关对格式化输入/输出函数（例如 &lt;code&gt;snprintf&lt;/code&gt; 和 &lt;code&gt;vsnprintf&lt;/code&gt; )的调用，这可能会导致输出截断。当无法在编译时确定由format指令写入的确切字节数时，将根据依赖于 &lt;var&gt;level&lt;/var&gt; 参数和优化的试探法进行估算。虽然启用优化将在大多数情况下提高警告的准确性，但也可能导致误报。除非另有说明，否则该选项使用相同的逻辑</target>
        </trans-unit>
        <trans-unit id="66472dc4cd87cc63c73cb46419c0fd90cf1906ba" translate="yes" xml:space="preserve">
          <source>Warn about calls to formatted input/output functions such as &lt;code&gt;sprintf&lt;/code&gt; and &lt;code&gt;vsprintf&lt;/code&gt; that might overflow the destination buffer. When the exact number of bytes written by a format directive cannot be determined at compile-time it is estimated based on heuristics that depend on the &lt;var&gt;level&lt;/var&gt; argument and on optimization. While enabling optimization will in most cases improve the accuracy of the warning, it may also result in false positives.</source>
          <target state="translated">警告对可能会导致目标缓冲区溢出的格式化输入/输出功能（如 &lt;code&gt;sprintf&lt;/code&gt; 和 &lt;code&gt;vsprintf&lt;/code&gt; )的调用。当无法在编译时确定由format指令写入的确切字节数时，将根据依赖于 &lt;var&gt;level&lt;/var&gt; 参数和优化的试探法进行估算。虽然启用优化将在大多数情况下提高警告的准确性，但也可能导致误报。</target>
        </trans-unit>
        <trans-unit id="8986e7105a9ec8665e2dbbf6296adf8b057bee04" translate="yes" xml:space="preserve">
          <source>Warn about calls to functions decorated with attribute &lt;code&gt;alloc_size&lt;/code&gt; that attempt to allocate objects larger than the specified number of bytes, or where the result of the size computation in an integer type with infinite precision would exceed the value of &amp;lsquo;</source>
          <target state="translated">警告有关调用用 &lt;code&gt;alloc_size&lt;/code&gt; 属性修饰的函数的尝试，这些函数试图分配大于指定字节数的对象，或者以无限精度整数类型进行大小计算的结果将超过'</target>
        </trans-unit>
        <trans-unit id="88c937d55912c756c7716e6f943b38520ff30020" translate="yes" xml:space="preserve">
          <source>Warn about cases that are both questionable and easy to avoid. For example the compiler simplifies &lt;code&gt;x + 1 &amp;gt; x&lt;/code&gt; to &lt;code&gt;1&lt;/code&gt;. This level of</source>
          <target state="translated">警告可疑且易于避免的案件。例如，编译器将 &lt;code&gt;x + 1 &amp;gt; x&lt;/code&gt; 简化为 &lt;code&gt;1&lt;/code&gt; 。这个级别的</target>
        </trans-unit>
        <trans-unit id="179fecfde091b7cc90c5093c0b77e7c3ec453920" translate="yes" xml:space="preserve">
          <source>Warn about catch handlers that do not catch via reference. With</source>
          <target state="translated">警告那些不通过引用进行捕捉的处理程序。有了</target>
        </trans-unit>
        <trans-unit id="5d56df9ae38e57af735866e84e0cdb01862c2396" translate="yes" xml:space="preserve">
          <source>Warn about certain constructs that behave differently in traditional and ISO C. Also warn about ISO C constructs that have no traditional C equivalent, and/or problematic constructs that should be avoided.</source>
          <target state="translated">警告某些在传统C语言和ISO C语言中表现不同的构造,同时警告那些没有传统C语言等价物的ISO C语言构造和/或应该避免的问题构造。</target>
        </trans-unit>
        <trans-unit id="208feed4ba7b2db7b751737e5df71463aa2d59a9" translate="yes" xml:space="preserve">
          <source>Warn about code that may have undefined semantics because of violations of sequence point rules in the C and C++ standards.</source>
          <target state="translated">警告由于违反C和C++标准中的序列点规则,代码可能有未定义的语义。</target>
        </trans-unit>
        <trans-unit id="120296c8df6378a5551d4a8157d2634bb8869dc7" translate="yes" xml:space="preserve">
          <source>Warn about constructions where there may be confusion to which &lt;code&gt;if&lt;/code&gt; statement an &lt;code&gt;else&lt;/code&gt; branch belongs. Here is an example of such a case:</source>
          <target state="translated">警告有关 &lt;code&gt;if&lt;/code&gt; 语句 &lt;code&gt;else&lt;/code&gt; 分支所属的结构可能会造成混乱的地方。这是这种情况的示例：</target>
        </trans-unit>
        <trans-unit id="5a68fb773b2ee57c56ecf208d21e354737b77e2a" translate="yes" xml:space="preserve">
          <source>Warn about conversions between address spaces in the case where the resulting address space is not contained in the incoming address space.</source>
          <target state="translated">如果所产生的地址空间不包含在输入的地址空间中,则对地址空间之间的转换提出警告。</target>
        </trans-unit>
        <trans-unit id="0761a82a1e056ee411ecf4ae535a9dfad8b30dfc" translate="yes" xml:space="preserve">
          <source>Warn about declarations using the &lt;code&gt;alias&lt;/code&gt; and similar attributes whose target is incompatible with the type of the alias. See &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;Declaring Attributes of Functions&lt;/a&gt;.</source>
          <target state="translated">警告使用 &lt;code&gt;alias&lt;/code&gt; 和目标与别名类型不兼容的相似属性的声明。请参见&lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;声明函数的属性&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f643480f69fb1c621533ba0cdd904776e7e1ef4b" translate="yes" xml:space="preserve">
          <source>Warn about duplicated conditions in an if-else-if chain. For instance, warn for the following code:</source>
          <target state="translated">对if-else-if链中的重复条件提出警告。例如,对以下代码发出警告。</target>
        </trans-unit>
        <trans-unit id="f7359f7ae633c3c242379554307ef603621fed1e" translate="yes" xml:space="preserve">
          <source>Warn about features not present in ISO C90, but present in ISO C99. For instance, warn about use of variable length arrays, &lt;code&gt;long long&lt;/code&gt; type, &lt;code&gt;bool&lt;/code&gt; type, compound literals, designated initializers, and so on. This option is independent of the standards mode. Warnings are disabled in the expression that follows &lt;code&gt;__extension__&lt;/code&gt;.</source>
          <target state="translated">警告ISO C90中没有但ISO C99中存在的功能。例如，警告使用可变长度数组， &lt;code&gt;long long&lt;/code&gt; 类型， &lt;code&gt;bool&lt;/code&gt; 类型，复合文字，指定的初始值设定项等。此选项独立于标准模式。 &lt;code&gt;__extension__&lt;/code&gt; 后面的表达式中禁用警告。</target>
        </trans-unit>
        <trans-unit id="626c854c9715d516c67e89068f1bb76234cf669a" translate="yes" xml:space="preserve">
          <source>Warn about features not present in ISO C99, but present in ISO C11. For instance, warn about use of anonymous structures and unions, &lt;code&gt;_Atomic&lt;/code&gt; type qualifier, &lt;code&gt;_Thread_local&lt;/code&gt; storage-class specifier, &lt;code&gt;_Alignas&lt;/code&gt; specifier, &lt;code&gt;Alignof&lt;/code&gt; operator, &lt;code&gt;_Generic&lt;/code&gt; keyword, and so on. This option is independent of the standards mode. Warnings are disabled in the expression that follows &lt;code&gt;__extension__&lt;/code&gt;.</source>
          <target state="translated">警告ISO C99中不存在但ISO C11中存在的功能。例如，警告使用匿名结构和联合， &lt;code&gt;_Atomic&lt;/code&gt; 类型限定符， &lt;code&gt;_Thread_local&lt;/code&gt; 存储类指定符， &lt;code&gt;_Alignas&lt;/code&gt; 指定符， &lt;code&gt;Alignof&lt;/code&gt; 运算符， &lt;code&gt;_Generic&lt;/code&gt; 关键字等。此选项独立于标准模式。 &lt;code&gt;__extension__&lt;/code&gt; 后面的表达式中禁用警告。</target>
        </trans-unit>
        <trans-unit id="643ea2b6cbf0ea1bcfec495e08e3195164382b91" translate="yes" xml:space="preserve">
          <source>Warn about function pointers that might be candidates for &lt;code&gt;format&lt;/code&gt; attributes. Note these are only possible candidates, not absolute ones. GCC guesses that function pointers with &lt;code&gt;format&lt;/code&gt; attributes that are used in assignment, initialization, parameter passing or return statements should have a corresponding &lt;code&gt;format&lt;/code&gt; attribute in the resulting type. I.e. the left-hand side of the assignment or initialization, the type of the parameter variable, or the return type of the containing function respectively should also have a &lt;code&gt;format&lt;/code&gt; attribute to avoid the warning.</source>
          <target state="translated">警告可能是 &lt;code&gt;format&lt;/code&gt; 属性候选的函数指针。请注意，这些只是可能的候选人，而不是绝对的候选人。 GCC猜测在赋值，初始化，参数传递或return语句中使用的具有 &lt;code&gt;format&lt;/code&gt; 属性的函数指针应在结果类型中具有相应的 &lt;code&gt;format&lt;/code&gt; 属性。即，赋值或初始化的左侧，参数变量的类型或包含函数的返回类型也应分别具有 &lt;code&gt;format&lt;/code&gt; 属性，以避免发出警告。</target>
        </trans-unit>
        <trans-unit id="ff3534585cbc01893459375a2f73a721f1390a46" translate="yes" xml:space="preserve">
          <source>Warn about functions that might be candidates for &lt;code&gt;cold&lt;/code&gt; attribute. This is based on static detection and generally will only warn about functions which always leads to a call to another &lt;code&gt;cold&lt;/code&gt; function such as wrappers of C++ &lt;code&gt;throw&lt;/code&gt; or fatal error reporting functions leading to &lt;code&gt;abort&lt;/code&gt;.</source>
          <target state="translated">警告可能用作 &lt;code&gt;cold&lt;/code&gt; 属性的候选函数。这是基于静态检测的，通常只会警告总是导致调用另一个 &lt;code&gt;cold&lt;/code&gt; 函数的函数，例如C ++ &lt;code&gt;throw&lt;/code&gt; 的包装程序或导致 &lt;code&gt;abort&lt;/code&gt; 致命错误报告函数。</target>
        </trans-unit>
        <trans-unit id="ad5773c66378dee79865728b1022e5f1ddb94781" translate="yes" xml:space="preserve">
          <source>Warn about functions that might be candidates for attributes &lt;code&gt;pure&lt;/code&gt;, &lt;code&gt;const&lt;/code&gt; or &lt;code&gt;noreturn&lt;/code&gt; or &lt;code&gt;malloc&lt;/code&gt;. The compiler only warns for functions visible in other compilation units or (in the case of &lt;code&gt;pure&lt;/code&gt; and &lt;code&gt;const&lt;/code&gt;) if it cannot prove that the function returns normally. A function returns normally if it doesn&amp;rsquo;t contain an infinite loop or return abnormally by throwing, calling &lt;code&gt;abort&lt;/code&gt; or trapping. This analysis requires option</source>
          <target state="translated">警告可能可能用作 &lt;code&gt;pure&lt;/code&gt; ， &lt;code&gt;const&lt;/code&gt; 或 &lt;code&gt;noreturn&lt;/code&gt; 或 &lt;code&gt;malloc&lt;/code&gt; 属性的候选函数。编译器仅警告在其他编译单元中可见的函数，或者在无法证明该函数正常返回的情况下（对于 &lt;code&gt;pure&lt;/code&gt; 和 &lt;code&gt;const&lt;/code&gt; ）发出警告。如果一个函数不包含无限循环，或者通过抛出，调用 &lt;code&gt;abort&lt;/code&gt; 或trapping 异常返回，则该函数将正常返回。此分析需要选择</target>
        </trans-unit>
        <trans-unit id="97272a64aa6772a9d1f50422c6dbb8adfe294518" translate="yes" xml:space="preserve">
          <source>Warn about left shift overflows. This warning is enabled by default in C99 and C++11 modes (and newer).</source>
          <target state="translated">警告左移位溢出。在C99和C++11模式(以及更新的模式)中,这个警告是默认启用的。</target>
        </trans-unit>
        <trans-unit id="cab17a3fd72f34df7821e30e584c4c51a37bba48" translate="yes" xml:space="preserve">
          <source>Warn about logical not used on the left hand side operand of a comparison. This option does not warn if the right operand is considered to be a boolean expression. Its purpose is to detect suspicious code like the following:</source>
          <target state="translated">在比较的左手操作数上没有使用逻辑时发出警告。如果右侧操作数被认为是布尔表达式,这个选项不会发出警告。它的目的是检测可疑的代码,比如下面的代码。</target>
        </trans-unit>
        <trans-unit id="48b82c0283a2915829a3ee6a3436cc1017b5ea05" translate="yes" xml:space="preserve">
          <source>Warn about macros defined in the main file that are unused. A macro is &lt;em&gt;used&lt;/em&gt; if it is expanded or tested for existence at least once. The preprocessor also warns if the macro has not been used at the time it is redefined or undefined.</source>
          <target state="translated">警告主文件中定义的未使用的宏。如果宏至少被扩展或测试一次存在，则&lt;em&gt;使用&lt;/em&gt;该宏。预处理器还会警告在重新定义或未定义宏时是否尚未使用该宏。</target>
        </trans-unit>
        <trans-unit id="b4b8fd61bdb1f1846bd01a97a7bd276155ea4f4c" translate="yes" xml:space="preserve">
          <source>Warn about overriding virtual functions that are not marked with the override keyword.</source>
          <target state="translated">警告覆盖没有用覆盖关键字标记的虚拟函数。</target>
        </trans-unit>
        <trans-unit id="b83b9745dc97dfb351a27bd912c00da1a8c7a2f9" translate="yes" xml:space="preserve">
          <source>Warn about passing a null pointer for arguments marked as requiring a non-null value by the &lt;code&gt;nonnull&lt;/code&gt; function attribute.</source>
          <target state="translated">警告有关为 &lt;code&gt;nonnull&lt;/code&gt; 函数属性标记为需要非null值的参数传递null指针。</target>
        </trans-unit>
        <trans-unit id="6aa9959edf6bc4922ebb912c9a250384b3090f7c" translate="yes" xml:space="preserve">
          <source>Warn about placement new expressions with undefined behavior, such as constructing an object in a buffer that is smaller than the type of the object. For example, the placement new expression below is diagnosed because it attempts to construct an array of 64 integers in a buffer only 64 bytes large.</source>
          <target state="translated">警告具有未定义行为的放置新表达式,例如在比对象类型小的缓冲区中构造对象。例如,下面的放置新表达式被诊断出来,因为它试图在一个只有64字节大的缓冲区中构造一个64个整数的数组。</target>
        </trans-unit>
        <trans-unit id="185c654029973156a2e707b7e9ffcc02226e09a9" translate="yes" xml:space="preserve">
          <source>Warn about redundant semicolon after in-class function definition.</source>
          <target state="translated">警告类内函数定义后有多余的分号。</target>
        </trans-unit>
        <trans-unit id="083bdeb1c857ab3b93f3cbf9b4f7687d0f51ffb4" translate="yes" xml:space="preserve">
          <source>Warn about string constants that are longer than the &amp;ldquo;minimum maximum&amp;rdquo; length specified in the C standard. Modern compilers generally allow string constants that are much longer than the standard&amp;rsquo;s minimum limit, but very portable programs should avoid using longer strings.</source>
          <target state="translated">警告长于C标准中指定的&amp;ldquo;最小最大&amp;rdquo;长度的字符串常量。现代的编译器通常允许比标准的最小限制长得多的字符串常量，但是非常可移植的程序应避免使用更长的字符串。</target>
        </trans-unit>
        <trans-unit id="e453618f3508cc5c8f222f7ad7869db1fe428a6f" translate="yes" xml:space="preserve">
          <source>Warn about suspicious operations on expressions of a boolean type. For instance, bitwise negation of a boolean is very likely a bug in the program. For C, this warning also warns about incrementing or decrementing a boolean, which rarely makes sense. (In C++, decrementing a boolean is always invalid. Incrementing a boolean is invalid in C++17, and deprecated otherwise.)</source>
          <target state="translated">警告对布尔类型表达式的可疑操作。例如,布尔型的位否定很可能是程序中的一个错误。对于C语言来说,这个警告也会警告递增或递减一个布尔值,这很少有意义。(在C++中,递减一个布尔值总是无效的。在C++17中,递增一个布尔值是无效的,否则就会被废弃)。)</target>
        </trans-unit>
        <trans-unit id="2336eb6d6105fde77f9d067a2cdcc81228032540" translate="yes" xml:space="preserve">
          <source>Warn about suspicious uses of logical operators in expressions. This includes using logical operators in contexts where a bit-wise operator is likely to be expected. Also warns when the operands of a logical operator are the same:</source>
          <target state="translated">警惕在表达式中可疑地使用逻辑运算符。这包括在可能会出现位智运算符的情况下使用逻辑运算符。当逻辑运算符的操作数相同时,也会发出警告。</target>
        </trans-unit>
        <trans-unit id="47cf408f4ecd083d50c4f6fada7dd8bdd9b93bb0" translate="yes" xml:space="preserve">
          <source>Warn about suspicious uses of memory addresses. These include using the address of a function in a conditional expression, such as &lt;code&gt;void func(void); if (func)&lt;/code&gt;, and comparisons against the memory address of a string literal, such as &lt;code&gt;if (x == &quot;abc&quot;)&lt;/code&gt;. Such uses typically indicate a programmer error: the address of a function always evaluates to true, so their use in a conditional usually indicate that the programmer forgot the parentheses in a function call; and comparisons against string literals result in unspecified behavior and are not portable in C, so they usually indicate that the programmer intended to use &lt;code&gt;strcmp&lt;/code&gt;. This warning is enabled by</source>
          <target state="translated">警告有关内存地址的可疑使用。这些包括在条件表达式中使用函数的地址，例如 &lt;code&gt;void func(void); if (func)&lt;/code&gt; ，并与字符串文字的内存地址进行比较，例如 &lt;code&gt;if (x == &quot;abc&quot;)&lt;/code&gt; 。这样的用法通常表示程序员错误：函数的地址总是评估为true，因此在有条件的条件下使用它们通常表明程序员忘记了函数调用中的括号。以及与字符串文字的比较会导致未指定的行为，并且不能在C语言中移植，因此，它们通常表明程序员打算使用 &lt;code&gt;strcmp&lt;/code&gt; 。此警告通过以下方式启用</target>
        </trans-unit>
        <trans-unit id="693b5ffe72b40cbff2e2c2d99e95d2c139392a00" translate="yes" xml:space="preserve">
          <source>Warn about the use of an uncasted &lt;code&gt;NULL&lt;/code&gt; as sentinel. When compiling only with GCC this is a valid sentinel, as &lt;code&gt;NULL&lt;/code&gt; is defined to &lt;code&gt;__null&lt;/code&gt;. Although it is a null pointer constant rather than a null pointer, it is guaranteed to be of the same size as a pointer. But this use is not portable across different compilers.</source>
          <target state="translated">警告使用未强制转换的 &lt;code&gt;NULL&lt;/code&gt; 作为前哨。当只使用GCC编译，这是一个有效的前哨，为 &lt;code&gt;NULL&lt;/code&gt; 被定义为 &lt;code&gt;__null&lt;/code&gt; 。尽管它是一个空指针常量而不是一个空指针，但是可以保证它的大小与指针相同。但是这种用法不能跨不同的编译器移植。</target>
        </trans-unit>
        <trans-unit id="047e09655cbc00205404926996b3c4d4165e9649" translate="yes" xml:space="preserve">
          <source>Warn about trampolines generated for pointers to nested functions. A trampoline is a small piece of data or code that is created at run time on the stack when the address of a nested function is taken, and is used to call the nested function indirectly. For some targets, it is made up of data only and thus requires no special treatment. But, for most targets, it is made up of code and thus requires the stack to be made executable in order for the program to work properly.</source>
          <target state="translated">警惕为嵌套函数的指针生成的蹦床。蹦床是运行时在堆栈上取嵌套函数的地址时产生的一小段数据或代码,用于间接调用嵌套函数。对于某些目标来说,它只由数据组成,因此不需要特殊处理。但是,对于大多数目标来说,它是由代码组成的,因此需要使堆栈可以执行,程序才能正常运行。</target>
        </trans-unit>
        <trans-unit id="038f9bc926635b6b8fb6c2afe2d9bffe1c8b0f31" translate="yes" xml:space="preserve">
          <source>Warn about types with virtual methods where code quality would be improved if the type were declared with the C++11 &lt;code&gt;final&lt;/code&gt; specifier, or, if possible, declared in an anonymous namespace. This allows GCC to more aggressively devirtualize the polymorphic calls. This warning is more effective with link time optimization, where the information about the class hierarchy graph is more complete.</source>
          <target state="translated">使用虚拟方法警告类型，如果使用C ++ 11 &lt;code&gt;final&lt;/code&gt; 说明符声明该类型，或者在可能的情况下在匿名名称空间中声明该类型，则可以提高代码质量。这使GCC可以更积极地对多态调用进行虚拟化。此警告在链接时间优化中更有效，链接时间优化中有关类层次结构图的信息更加完整。</target>
        </trans-unit>
        <trans-unit id="ebb96b1bde565bfb0748c8483dc57189a3190e4d" translate="yes" xml:space="preserve">
          <source>Warn about uninitialized variables that are initialized with themselves. Note this option can only be used with the</source>
          <target state="translated">对未初始化的变量发出警告,因为这些变量是用自己初始化的。注意这个选项只能与</target>
        </trans-unit>
        <trans-unit id="3e4a4254c8cb8b052f1898488cd3d24c1bac24c2" translate="yes" xml:space="preserve">
          <source>Warn about unsafe multiple statement macros that appear to be guarded by a clause such as &lt;code&gt;if&lt;/code&gt;, &lt;code&gt;else&lt;/code&gt;, &lt;code&gt;for&lt;/code&gt;, &lt;code&gt;switch&lt;/code&gt;, or &lt;code&gt;while&lt;/code&gt;, in which only the first statement is actually guarded after the macro is expanded.</source>
          <target state="translated">警告似乎由子句保护的不安全的多语句宏，例如 &lt;code&gt;if&lt;/code&gt; ， &lt;code&gt;else&lt;/code&gt; ， &lt;code&gt;for&lt;/code&gt; ， &lt;code&gt;switch&lt;/code&gt; 或 &lt;code&gt;while&lt;/code&gt; ，在该子句中，实际上只有第一个语句在扩展宏后才受到保护。</target>
        </trans-unit>
        <trans-unit id="c815119ab8450282a6819d07553d786431d0bc98" translate="yes" xml:space="preserve">
          <source>Warn about violations of the following style guidelines from Scott Meyers&amp;rsquo; Effective C++ series of books:</source>
          <target state="translated">警告Scott Meyers的Effective C ++系列书籍中的以下样式准则有违：</target>
        </trans-unit>
        <trans-unit id="44cda8e3e380e8f31dd971fc6b0f31b237513dcc" translate="yes" xml:space="preserve">
          <source>Warn about virtual methods where code quality would be improved if the method were declared with the C++11 &lt;code&gt;final&lt;/code&gt; specifier, or, if possible, its type were declared in an anonymous namespace or with the &lt;code&gt;final&lt;/code&gt; specifier. This warning is more effective with link-time optimization, where the information about the class hierarchy graph is more complete. It is recommended to first consider suggestions of</source>
          <target state="translated">警告虚拟方法，如果使用C ++ 11 &lt;code&gt;final&lt;/code&gt; 说明符声明该方法，或者如果可能，则在匿名命名空间或 &lt;code&gt;final&lt;/code&gt; 说明符中声明其类型，则可以提高代码质量。此警告在链接时优化中更有效，链接时优化中有关类层次结构图的信息更加完整。建议先考虑以下方面的建议</target>
        </trans-unit>
        <trans-unit id="be3e052e75298edad5e44ae2d0677574dff86d7c" translate="yes" xml:space="preserve">
          <source>Warn for calls to bounded string manipulation functions such as &lt;code&gt;strncat&lt;/code&gt;, &lt;code&gt;strncpy&lt;/code&gt;, and &lt;code&gt;stpncpy&lt;/code&gt; that may either truncate the copied string or leave the destination unchanged.</source>
          <target state="translated">警告调用有界字符串操作函数，例如 &lt;code&gt;strncat&lt;/code&gt; ， &lt;code&gt;strncpy&lt;/code&gt; 和 &lt;code&gt;stpncpy&lt;/code&gt; ，这些函数可能会截断复制的字符串或使目标保持不变。</target>
        </trans-unit>
        <trans-unit id="97f52c63875e1d71f753bc97c51fe3992eac28f3" translate="yes" xml:space="preserve">
          <source>Warn for calls to standard functions that compute the absolute value of an argument when a more appropriate standard function is available. For example, calling &lt;code&gt;abs(3.14)&lt;/code&gt; triggers the warning because the appropriate function to call to compute the absolute value of a double argument is &lt;code&gt;fabs&lt;/code&gt;. The option also triggers warnings when the argument in a call to such a function has an unsigned type. This warning can be suppressed with an explicit type cast and it is also enabled by</source>
          <target state="translated">当更合适的标准函数可用时，警告调用计算标准绝对值的标准函数。例如，调用 &lt;code&gt;abs(3.14)&lt;/code&gt; 会触发警告，因为要调用的用于计算double参数的绝对值的适当函数是 &lt;code&gt;fabs&lt;/code&gt; 。当对该函数的调用中的参数为无符号类型时，该选项还会触发警告。可以使用显式类型强制转换禁止此警告，也可以通过以下方式启用该警告：</target>
        </trans-unit>
        <trans-unit id="c5733f483a0e2d12a12ef399d58192ff21069495" translate="yes" xml:space="preserve">
          <source>Warn for calls to string manipulation functions such as &lt;code&gt;memcpy&lt;/code&gt; and &lt;code&gt;strcpy&lt;/code&gt; that are determined to overflow the destination buffer. The optional argument is one greater than the type of Object Size Checking to perform to determine the size of the destination. See &lt;a href=&quot;object-size-checking#Object-Size-Checking&quot;&gt;Object Size Checking&lt;/a&gt;. The argument is meaningful only for functions that operate on character arrays but not for raw memory functions like &lt;code&gt;memcpy&lt;/code&gt; which always make use of Object Size type-0. The option also warns for calls that specify a size in excess of the largest possible object or at most &lt;code&gt;SIZE_MAX / 2&lt;/code&gt; bytes. The option produces the best results with optimization enabled but can detect a small subset of simple buffer overflows even without optimization in calls to the GCC built-in functions like &lt;code&gt;__builtin_memcpy&lt;/code&gt; that correspond to the standard functions. In any case, the option warns about just a subset of buffer overflows detected by the corresponding overflow checking built-ins. For example, the option will issue a warning for the &lt;code&gt;strcpy&lt;/code&gt; call below because it copies at least 5 characters (the string &lt;code&gt;&quot;blue&quot;&lt;/code&gt; including the terminating NUL) into the buffer of size 4.</source>
          <target state="translated">警告对确定为溢出目标缓冲区的字符串操作函数（例如 &lt;code&gt;memcpy&lt;/code&gt; 和 &lt;code&gt;strcpy&lt;/code&gt; )的调用。可选参数比要确定目标大小的&amp;ldquo;对象大小检查&amp;rdquo;类型大一。请参阅&lt;a href=&quot;object-size-checking#Object-Size-Checking&quot;&gt;对象大小检查&lt;/a&gt;。该参数仅对在字符数组上运行的函数有意义，而对于像 &lt;code&gt;memcpy&lt;/code&gt; 这样总是使用Object Size type-0的原始内存函数没有意义。该选项还警告指定大小超出最大可能对象或最多 &lt;code&gt;SIZE_MAX / 2&lt;/code&gt; 调用个字节。该选项在启用优化的情况下产生最佳结果，但是即使不优化对与标准函数相对应的GCC内置函数（如 &lt;code&gt;__builtin_memcpy&lt;/code&gt; )的调用，也可以检测到一小部分简单的缓冲区溢出。在任何情况下，该选项仅会警告由相应的溢出检查内置程序检测到的缓冲区溢出子集。例如，该选项将对下面的 &lt;code&gt;strcpy&lt;/code&gt; 调用发出警告，因为该选项将至少5个字符（包括终止NUL 的字符串 &lt;code&gt;&quot;blue&quot;&lt;/code&gt; ）复制到大小为4的缓冲区中。</target>
        </trans-unit>
        <trans-unit id="ea89d9fe51cb214a220766e4af0abed7f830d316" translate="yes" xml:space="preserve">
          <source>Warn for cases where adding an attribute may be beneficial. The attributes currently supported are listed below.</source>
          <target state="translated">对于添加属性可能会有好处的情况,请注意。目前支持的属性如下。</target>
        </trans-unit>
        <trans-unit id="8436e41e82368d15262acc8884e5704ddb1ce7dc" translate="yes" xml:space="preserve">
          <source>Warn for conditionally-supported (C++11 [intro.defs]) constructs.</source>
          <target state="translated">对有条件支持的(C++11[intro.defs])构造提出警告。</target>
        </trans-unit>
        <trans-unit id="ddd0db7c59c0ac572b0cd3ff62ca85c741d9e547" translate="yes" xml:space="preserve">
          <source>Warn for implicit conversions that may alter a value. This includes conversions between real and integer, like &lt;code&gt;abs (x)&lt;/code&gt; when &lt;code&gt;x&lt;/code&gt; is &lt;code&gt;double&lt;/code&gt;; conversions between signed and unsigned, like &lt;code&gt;unsigned ui = -1&lt;/code&gt;; and conversions to smaller types, like &lt;code&gt;sqrtf (M_PI)&lt;/code&gt;. Do not warn for explicit casts like &lt;code&gt;abs
((int) x)&lt;/code&gt; and &lt;code&gt;ui = (unsigned) -1&lt;/code&gt;, or if the value is not changed by the conversion like in &lt;code&gt;abs (2.0)&lt;/code&gt;. Warnings about conversions between signed and unsigned integers can be disabled by using</source>
          <target state="translated">警告可能会更改值的隐式转换。这包括实数和整数之间的转换，例如 &lt;code&gt;x&lt;/code&gt; 为 &lt;code&gt;double&lt;/code&gt; 时的 &lt;code&gt;abs (x)&lt;/code&gt; ；有符号和无符号之间的转换，例如 &lt;code&gt;unsigned ui = -1&lt;/code&gt; ;并转换为较小的类型，例如 &lt;code&gt;sqrtf (M_PI)&lt;/code&gt; 。不要警告像 &lt;code&gt;abs ((int) x)&lt;/code&gt; 和 &lt;code&gt;ui = (unsigned) -1&lt;/code&gt; 这样的显式强制类型转换，或者如果该值没有像 &lt;code&gt;abs (2.0)&lt;/code&gt; 那样由转换更改，则不要发出警告。可以通过使用禁用有关有符号和无符号整数之间转换的警告</target>
        </trans-unit>
        <trans-unit id="ec1638cbd7bdbbe5cf0d16d8253b596c446311e3" translate="yes" xml:space="preserve">
          <source>Warn for implicit conversions that may change the sign of an integer value, like assigning a signed integer expression to an unsigned integer variable. An explicit cast silences the warning. In C, this option is enabled also by</source>
          <target state="translated">警告隐式转换可能会改变一个整数值的符号,比如将一个有符号的整数表达式赋值给一个无符号的整数变量。显式转换会使警告消失。在C语言中,这个选项也可以通过</target>
        </trans-unit>
        <trans-unit id="97be0057bd1773b0bcfe31a7fd58f64b07846102" translate="yes" xml:space="preserve">
          <source>Warn for implicit conversions that reduce the precision of a real value. This includes conversions from real to integer, and from higher precision real to lower precision real values. This option is also enabled by</source>
          <target state="translated">对降低实值精度的隐式转换提出警告。这包括从实数到整数的转换,以及从高精度实数到低精度实数的转换。这个选项也可以通过</target>
        </trans-unit>
        <trans-unit id="fba779234a6e85d8e28133f5b96c546a4b460be1" translate="yes" xml:space="preserve">
          <source>Warn for invocations of &lt;a href=&quot;_005f_005fatomic-builtins#g_t_005f_005fatomic-Builtins&quot;&gt;__atomic Builtins&lt;/a&gt;, &lt;a href=&quot;_005f_005fsync-builtins#g_t_005f_005fsync-Builtins&quot;&gt;__sync Builtins&lt;/a&gt;, and the C11 atomic generic functions with a memory consistency argument that is either invalid for the operation or outside the range of values of the &lt;code&gt;memory_order&lt;/code&gt; enumeration. For example, since the &lt;code&gt;__atomic_store&lt;/code&gt; and &lt;code&gt;__atomic_store_n&lt;/code&gt; built-ins are only defined for the relaxed, release, and sequentially consistent memory orders the following code is diagnosed:</source>
          <target state="translated">使用内存一致性参数警告&lt;a href=&quot;_005f_005fatomic-builtins#g_t_005f_005fatomic-Builtins&quot;&gt;__atomic Builtins&lt;/a&gt;，&lt;a href=&quot;_005f_005fsync-builtins#g_t_005f_005fsync-Builtins&quot;&gt;__sync Builtins&lt;/a&gt;和C11原子泛型函数的调用，该参数对于该操作无效或在 &lt;code&gt;memory_order&lt;/code&gt; 枚举的值范围之外。例如，由于仅针对宽松，释放和顺序一致的内存顺序定义了 &lt;code&gt;__atomic_store&lt;/code&gt; 和 &lt;code&gt;__atomic_store_n&lt;/code&gt; 内置插件，因此将诊断以下代码：</target>
        </trans-unit>
        <trans-unit id="588f265a9e502d85c1dc2042e355d13326591d0f" translate="yes" xml:space="preserve">
          <source>Warn for obsolescent usages, according to the C Standard, in a declaration. For example, warn if storage-class specifiers like &lt;code&gt;static&lt;/code&gt; are not the first things in a declaration. This warning is also enabled by</source>
          <target state="translated">根据声明，警告使用过时（根据C标准）。例如，警告诸如 &lt;code&gt;static&lt;/code&gt; 之类的存储类说明符不是声明中的首要内容。此警告也通过以下方式启用</target>
        </trans-unit>
        <trans-unit id="e259b4649f2c39d620aa79263dfa4900b1e91328" translate="yes" xml:space="preserve">
          <source>Warn for pointer argument passing or assignment with different signedness. This option is only supported for C and Objective-C. It is implied by</source>
          <target state="translated">对指针参数传递或赋值有不同签名的情况发出警告。这个选项只支持C和Objective-C。它是由</target>
        </trans-unit>
        <trans-unit id="9ff91ea12bc4958bf94b9d94062e90a35c47ff2b" translate="yes" xml:space="preserve">
          <source>Warn for suspicious calls to the &lt;code&gt;memset&lt;/code&gt; built-in function where the second argument is not zero and the third argument is zero. For example, the call &lt;code&gt;memset (buf, sizeof buf, 0)&lt;/code&gt; is diagnosed because &lt;code&gt;memset (buf, 0, sizeof buf)&lt;/code&gt; was meant instead. The diagnostic is only emitted if the third argument is a literal zero. Otherwise, if it is an expression that is folded to zero, or a cast of zero to some type, it is far less likely that the arguments have been mistakenly transposed and no warning is emitted. This warning is enabled by</source>
          <target state="translated">警告第二个参数不为零，第三个参数为零的可疑调用 &lt;code&gt;memset&lt;/code&gt; 内置函数。例如，诊断呼叫 &lt;code&gt;memset (buf, sizeof buf, 0)&lt;/code&gt; 是因为意味着要使用 &lt;code&gt;memset (buf, 0, sizeof buf)&lt;/code&gt; 。仅当第三个参数是文字零时才发出诊断。否则，如果它是折叠为零的表达式，或者是将零强制转换为某种类型的表达式，则参数被错误地转置并且不发出警告的可能性要小得多。此警告通过以下方式启用</target>
        </trans-unit>
        <trans-unit id="bc6dbae9a566682d74e9a96f0ac749b8042dc5bb" translate="yes" xml:space="preserve">
          <source>Warn for suspicious calls to the &lt;code&gt;memset&lt;/code&gt; built-in function, if the first argument references an array, and the third argument is a number equal to the number of elements, but not equal to the size of the array in memory. This indicates that the user has omitted a multiplication by the element size. This warning is enabled by</source>
          <target state="translated">如果第一个参数引用一个数组，而第三个参数是一个等于元素数量但不等于内存中数组大小的数字，则警告可疑调用 &lt;code&gt;memset&lt;/code&gt; 内置函数。这表明用户已经省略了元素大小的乘法。此警告通过以下方式启用</target>
        </trans-unit>
        <trans-unit id="d71f136265b6596c9fcf21bacafb65164bba32b6" translate="yes" xml:space="preserve">
          <source>Warn for suspicious divisions of two sizeof expressions that divide the pointer size by the element size, which is the usual way to compute the array size but won&amp;rsquo;t work out correctly with pointers. This warning warns e.g. about &lt;code&gt;sizeof (ptr) / sizeof (ptr[0])&lt;/code&gt; if &lt;code&gt;ptr&lt;/code&gt; is not an array, but a pointer. This warning is enabled by</source>
          <target state="translated">警告对两个sizeof表达式进行可疑的划分，这些表达式会将指针大小除以元素大小，这是计算数组大小的常用方法，但无法正确使用指针。如果 &lt;code&gt;ptr&lt;/code&gt; 不是数组而是指针，则此警告将警告有关例如 &lt;code&gt;sizeof (ptr) / sizeof (ptr[0])&lt;/code&gt; 。此警告通过以下方式启用</target>
        </trans-unit>
        <trans-unit id="eb46193b49397250439f9bab61fa46107f1cb89b" translate="yes" xml:space="preserve">
          <source>Warn for suspicious length parameters to certain string and memory built-in functions if the argument uses &lt;code&gt;sizeof&lt;/code&gt;. This warning triggers for example for &lt;code&gt;memset (ptr, 0, sizeof (ptr));&lt;/code&gt; if &lt;code&gt;ptr&lt;/code&gt; is not an array, but a pointer, and suggests a possible fix, or about &lt;code&gt;memcpy (&amp;amp;foo, ptr, sizeof (&amp;amp;foo));&lt;/code&gt;.</source>
          <target state="translated">如果参数使用 &lt;code&gt;sizeof&lt;/code&gt; ,则警告某些字符串和内存内置函数的可疑长度参数。例如，此警告会触发 &lt;code&gt;memset (ptr, 0, sizeof (ptr));&lt;/code&gt; 如果 &lt;code&gt;ptr&lt;/code&gt; 不是数组，而是一个指针，并提出了可能的解决方法，或者关于 &lt;code&gt;memcpy (&amp;amp;foo, ptr, sizeof (&amp;amp;foo));&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="474691b4f69f5e3fa5e5d8572e94d30c04b806ca" translate="yes" xml:space="preserve">
          <source>Warn for suspicious use of integer values where boolean values are expected, such as conditional expressions (?:) using non-boolean integer constants in boolean context, like &lt;code&gt;if (a &amp;lt;= b ? 2 : 3)&lt;/code&gt;. Or left shifting of signed integers in boolean context, like &lt;code&gt;for (a = 0; 1 &amp;lt;&amp;lt; a; a++);&lt;/code&gt;. Likewise for all kinds of multiplications regardless of the data type. This warning is enabled by</source>
          <target state="translated">警告在可能需要布尔值的地方使用可疑的整数值，例如在布尔上下文中使用非布尔整数常量的条件表达式（？:)，例如 &lt;code&gt;if (a &amp;lt;= b ? 2 : 3)&lt;/code&gt; 。或在布尔上下文中左移有符号整数，例如 &lt;code&gt;for (a = 0; 1 &amp;lt;&amp;lt; a; a++);&lt;/code&gt; 。同样，对于所有类型的乘法，无论数据类型如何。此警告通过以下方式启用</target>
        </trans-unit>
        <trans-unit id="ef3f0d67d9be730bb5bb60eec12cdf29a3590cd3" translate="yes" xml:space="preserve">
          <source>Warn for variables that might be changed by &lt;code&gt;longjmp&lt;/code&gt; or &lt;code&gt;vfork&lt;/code&gt;. This warning is also enabled by</source>
          <target state="translated">警告可能由 &lt;code&gt;longjmp&lt;/code&gt; 或 &lt;code&gt;vfork&lt;/code&gt; 更改的变量。此警告也通过以下方式启用</target>
        </trans-unit>
        <trans-unit id="dd2e7578a65337ecde9cfa288e81a35cf44426a6" translate="yes" xml:space="preserve">
          <source>Warn if &lt;code&gt;long long&lt;/code&gt; type is used. This is enabled by either</source>
          <target state="translated">如果使用 &lt;code&gt;long long&lt;/code&gt; 类型，则发出警告。可以通过以下任一方式启用</target>
        </trans-unit>
        <trans-unit id="e19f1630667f871b7fea15d47a722bf79ecb0d1d" translate="yes" xml:space="preserve">
          <source>Warn if a &lt;code&gt;@selector(&amp;hellip;)&lt;/code&gt; expression referring to an undeclared selector is found. A selector is considered undeclared if no method with that name has been declared before the &lt;code&gt;@selector(&amp;hellip;)&lt;/code&gt; expression, either explicitly in an &lt;code&gt;@interface&lt;/code&gt; or &lt;code&gt;@protocol&lt;/code&gt; declaration, or implicitly in an &lt;code&gt;@implementation&lt;/code&gt; section. This option always performs its checks as soon as a &lt;code&gt;@selector(&amp;hellip;)&lt;/code&gt; expression is found, while</source>
          <target state="translated">如果找到了一个指向未声明选择器的 &lt;code&gt;@selector(&amp;hellip;)&lt;/code&gt; 表达式，则发出警告。如果在 &lt;code&gt;@selector(&amp;hellip;)&lt;/code&gt; 表达式之前没有声明具有该名称的方法（在 &lt;code&gt;@interface&lt;/code&gt; 或 &lt;code&gt;@protocol&lt;/code&gt; 声明中显式或在 &lt;code&gt;@implementation&lt;/code&gt; 节中隐式），则认为未声明选择器。找到 &lt;code&gt;@selector(&amp;hellip;)&lt;/code&gt; 表达式后，此选项始终执行其检查，而</target>
        </trans-unit>
        <trans-unit id="004d33c975e481dfebbcb509835b3167b8da9eba" translate="yes" xml:space="preserve">
          <source>Warn if a &lt;code&gt;goto&lt;/code&gt; statement or a &lt;code&gt;switch&lt;/code&gt; statement jumps forward across the initialization of a variable, or jumps backward to a label after the variable has been initialized. This only warns about variables that are initialized when they are declared. This warning is only supported for C and Objective-C; in C++ this sort of branch is an error in any case.</source>
          <target state="translated">如果 &lt;code&gt;goto&lt;/code&gt; 语句或 &lt;code&gt;switch&lt;/code&gt; 语句在变量的初始化过程中向前跳转，或者在变量已初始化后向后跳转至标签，则发出警告。这仅警告声明变量时已初始化的变量。仅C和Objective-C支持此警告。在C ++中，这种分支在任何情况下都是错误。</target>
        </trans-unit>
        <trans-unit id="70a205e11ff52468e2abea9748f0e8471729efe0" translate="yes" xml:space="preserve">
          <source>Warn if a built-in function is declared with an incompatible signature or as a non-function, or when a built-in function declared with a type that does not include a prototype is called with arguments whose promoted types do not match those expected by the function. When</source>
          <target state="translated">如果一个内置函数被声明为不兼容的签名或非函数,或者当一个内置函数被声明为不包含原型的类型时,如果调用的参数的类型与函数所期望的类型不匹配,则发出警告。当</target>
        </trans-unit>
        <trans-unit id="7e0b0c17d1b6ef946e72a0839cb1ce3047e47301" translate="yes" xml:space="preserve">
          <source>Warn if a class type has a base or a field whose type uses the anonymous namespace or depends on a type with no linkage. If a type A depends on a type B with no or internal linkage, defining it in multiple translation units would be an ODR violation because the meaning of B is different in each translation unit. If A only appears in a single translation unit, the best way to silence the warning is to give it internal linkage by putting it in an anonymous namespace as well. The compiler doesn&amp;rsquo;t give this warning for types defined in the main .C file, as those are unlikely to have multiple definitions.</source>
          <target state="translated">如果类类型具有使用匿名名称空间的基类或字段或依赖于没有链接的类型，则发出警告。如果类型A依赖于没有或具有内部链接的类型B，则在多个翻译单元中对其进行定义将违反ODR，因为B的含义在每个翻译单元中都不同。如果A仅出现在单个翻译单元中，则使警告静音的最佳方法是通过将其也置于匿名名称空间中来使其内部链接。编译器不会针对主.C文件中定义的类型发出此警告，因为这些类型不太可能具有多个定义。</target>
        </trans-unit>
        <trans-unit id="f50d7f18228e548a744dc4a11054b6259740a50d" translate="yes" xml:space="preserve">
          <source>Warn if a comparison is always true or always false due to the limited range of the data type, but do not warn for constant expressions. For example, warn if an unsigned variable is compared against zero with &lt;code&gt;&amp;lt;&lt;/code&gt; or &lt;code&gt;&amp;gt;=&lt;/code&gt;. This warning is also enabled by</source>
          <target state="translated">由于数据类型的范围有限，警告比较是对还是错，但不要对常量表达式发出警告。例如，警告是否使用 &lt;code&gt;&amp;lt;&lt;/code&gt; 或 &lt;code&gt;&amp;gt;=&lt;/code&gt; 将无符号变量与零进行比较。此警告也通过以下方式启用</target>
        </trans-unit>
        <trans-unit id="2a11d0f858be1c6e9bc24aa3b844f38a2b441160" translate="yes" xml:space="preserve">
          <source>Warn if a declaration has duplicate &lt;code&gt;const&lt;/code&gt;, &lt;code&gt;volatile&lt;/code&gt;, &lt;code&gt;restrict&lt;/code&gt; or &lt;code&gt;_Atomic&lt;/code&gt; specifier. This warning is enabled by</source>
          <target state="translated">发出警告的声明中有重复的 &lt;code&gt;const&lt;/code&gt; ， &lt;code&gt;volatile&lt;/code&gt; ， &lt;code&gt;restrict&lt;/code&gt; 或 &lt;code&gt;_Atomic&lt;/code&gt; 符。此警告通过以下方式启用</target>
        </trans-unit>
        <trans-unit id="435844d61c42ac3708481fd4e2d3779e1e2c4fcb" translate="yes" xml:space="preserve">
          <source>Warn if a function is declared or defined without specifying the argument types. (An old-style function definition is permitted without a warning if preceded by a declaration that specifies the argument types.)</source>
          <target state="translated">如果一个函数在没有指定参数类型的情况下被声明或定义,则发出警告。(如果在声明之前指定了参数类型,那么旧式函数定义可以不发出警告。)</target>
        </trans-unit>
        <trans-unit id="a760172e23a18bb5477be698491bcdf520546606" translate="yes" xml:space="preserve">
          <source>Warn if a function that is declared as inline cannot be inlined. Even with this option, the compiler does not warn about failures to inline functions declared in system headers.</source>
          <target state="translated">如果一个被声明为内联的函数不能内联,则发出警告。即使有这个选项,编译器也不会对系统头文件中声明为内联的函数失败发出警告。</target>
        </trans-unit>
        <trans-unit id="8022445f9b194569635957ab8997ae493df541b3" translate="yes" xml:space="preserve">
          <source>Warn if a global function is defined without a previous declaration. Do so even if the definition itself provides a prototype. Use this option to detect global functions that are not declared in header files. In C, no warnings are issued for functions with previous non-prototype declarations; use</source>
          <target state="translated">如果一个全局函数在没有事先声明的情况下被定义,则发出警告。即使定义本身提供了原型,也会发出警告。使用这个选项可以检测没有在头文件中声明的全局函数。在C语言中,对于之前有非原型声明的函数不会发出警告;使用</target>
        </trans-unit>
        <trans-unit id="8accbb9b2caefa3a198b26af7aaf7ecef01e8cb3" translate="yes" xml:space="preserve">
          <source>Warn if a global function is defined without a previous prototype declaration. This warning is issued even if the definition itself provides a prototype. Use this option to detect global functions that do not have a matching prototype declaration in a header file. This option is not valid for C++ because all function declarations provide prototypes and a non-matching declaration declares an overload rather than conflict with an earlier declaration. Use</source>
          <target state="translated">如果全局函数的定义没有事先声明原型,则发出警告。即使定义本身提供了原型,也会发出警告。使用这个选项来检测头文件中没有匹配原型声明的全局函数。这个选项对C++无效,因为所有的函数声明都提供原型,不匹配的声明会声明一个重载,而不是与之前的声明冲突。使用</target>
        </trans-unit>
        <trans-unit id="158841ec1502166264ebd7700487b8265d3a7024" translate="yes" xml:space="preserve">
          <source>Warn if a pointer is compared with a zero character constant. This usually means that the pointer was meant to be dereferenced. For example:</source>
          <target state="translated">如果指针与一个零字符常量进行比较,则发出警告。这通常意味着该指针是要被取消引用的。例如,如果一个指针与一个零字符常量进行比较,则发出警告。</target>
        </trans-unit>
        <trans-unit id="cc6737ba51245ef04a02acb681eeef00c75f1a8a" translate="yes" xml:space="preserve">
          <source>Warn if a precompiled header (see &lt;a href=&quot;precompiled-headers#Precompiled-Headers&quot;&gt;Precompiled Headers&lt;/a&gt;) is found in the search path but cannot be used.</source>
          <target state="translated">警告是否在搜索路径中找到了预编译头（请参阅&lt;a href=&quot;precompiled-headers#Precompiled-Headers&quot;&gt;Precompiled Headers&lt;/a&gt;），但无法使用。</target>
        </trans-unit>
        <trans-unit id="0939e5ffcf8a00c23be50c55ee10373ce78e992e" translate="yes" xml:space="preserve">
          <source>Warn if a prototype causes a type conversion that is different from what would happen to the same argument in the absence of a prototype. This includes conversions of fixed point to floating and vice versa, and conversions changing the width or signedness of a fixed-point argument except when the same as the default promotion.</source>
          <target state="translated">如果原型引起的类型转换与没有原型时相同参数的类型转换不同,则发出警告。这包括从定点到浮点的转换,反之亦然,以及改变定点参数的宽度或符号的转换,除非与默认值相同。</target>
        </trans-unit>
        <trans-unit id="f0026b1975a3aa571d75e5560f23067faee1ed8d" translate="yes" xml:space="preserve">
          <source>Warn if a register variable is declared volatile. The volatile modifier does not inhibit all optimizations that may eliminate reads and/or writes to register variables. This warning is enabled by</source>
          <target state="translated">如果一个寄存器变量被声明为易失性,则发出警告。易失性修饰符并不能抑制所有可能消除对寄存器变量的读和/或写的优化。这个警告是由</target>
        </trans-unit>
        <trans-unit id="3798bc740d5ed1fe194f654e04bcdb3d1c47efb1" translate="yes" xml:space="preserve">
          <source>Warn if a requested optimization pass is disabled. This warning does not generally indicate that there is anything wrong with your code; it merely indicates that GCC&amp;rsquo;s optimizers are unable to handle the code effectively. Often, the problem is that your code is too big or too complex; GCC refuses to optimize programs when the optimization itself is likely to take inordinate amounts of time.</source>
          <target state="translated">如果请求的优化通过被禁用，则发出警告。此警告通常并不表示您的代码有任何问题；它仅表示GCC的优化器无法有效处理代码。通常，问题在于您的代码太大或太复杂。当优化本身可能花费过多时间时，GCC拒绝优化程序。</target>
        </trans-unit>
        <trans-unit id="13c5db18900b8a64496f744ccfd5e2648bd6cc79" translate="yes" xml:space="preserve">
          <source>Warn if a self-comparison always evaluates to true or false. This warning detects various mistakes such as:</source>
          <target state="translated">如果一个自我比较总是评估为真或假,则发出警告。该警告可检测各种错误,如:</target>
        </trans-unit>
        <trans-unit id="3ddcbce9d2796dc0f4331ea0e609fc2579e95907" translate="yes" xml:space="preserve">
          <source>Warn if a structure field with explicitly specified alignment in a packed struct or union is misaligned. For example, a warning will be issued on &lt;code&gt;struct S&lt;/code&gt;, like, &lt;code&gt;warning: alignment 1 of
'struct S' is less than 8&lt;/code&gt;, in this code:</source>
          <target state="translated">如果在打包的结构或联合中具有明确指定的对齐方式的结构字段未对齐，则发出警告。例如，将在 &lt;code&gt;struct S&lt;/code&gt; 上 &lt;code&gt;warning: alignment 1 of 'struct S' is less than 8&lt;/code&gt; ，例如警告：&amp;ldquo; struct S&amp;rdquo;的对齐方式1小于8，在此代码中：</target>
        </trans-unit>
        <trans-unit id="4090da0abd58db5d6b3c1df786fa78fbd44ccb0c" translate="yes" xml:space="preserve">
          <source>Warn if a structure is given the packed attribute, but the packed attribute has no effect on the layout or size of the structure. Such structures may be mis-aligned for little benefit. For instance, in this code, the variable &lt;code&gt;f.x&lt;/code&gt; in &lt;code&gt;struct bar&lt;/code&gt; is misaligned even though &lt;code&gt;struct bar&lt;/code&gt; does not itself have the packed attribute:</source>
          <target state="translated">警告是否为结构赋予了packed属性，但packed属性对结构的布局或大小没有影响。这样的结构可能会错位，几乎没有好处。例如，在此代码中，即使 &lt;code&gt;struct bar&lt;/code&gt; 本身不具有packed属性， &lt;code&gt;struct bar&lt;/code&gt; 的变量 &lt;code&gt;f.x&lt;/code&gt; 也未对齐：</target>
        </trans-unit>
        <trans-unit id="25445489d5b31008c73b432793637e0936c19aa4" translate="yes" xml:space="preserve">
          <source>Warn if a structure&amp;rsquo;s initializer has some fields missing. For example, the following code causes such a warning, because &lt;code&gt;x.h&lt;/code&gt; is implicitly zero:</source>
          <target state="translated">如果结构的初始化程序缺少某些字段，则发出警告。例如，以下代码会导致这样的警告，因为 &lt;code&gt;x.h&lt;/code&gt; 隐式为零：</target>
        </trans-unit>
        <trans-unit id="ff8391aca57a7124434de4ac423b8ea2b9835ac5" translate="yes" xml:space="preserve">
          <source>Warn if a user-supplied include directory does not exist.</source>
          <target state="translated">如果用户提供的include目录不存在,则发出警告。</target>
        </trans-unit>
        <trans-unit id="3fc14a4903f34179ede0f1ca4ae1ec5c8d1b70b1" translate="yes" xml:space="preserve">
          <source>Warn if a variable-length array is used in the code.</source>
          <target state="translated">如果在代码中使用了一个可变长度的数组,则发出警告。</target>
        </trans-unit>
        <trans-unit id="36f8e0d2c860d788d014b0fd6079fd78b6555ede" translate="yes" xml:space="preserve">
          <source>Warn if an &lt;code&gt;extern&lt;/code&gt; declaration is encountered within a function.</source>
          <target state="translated">如果在函数内遇到 &lt;code&gt;extern&lt;/code&gt; 声明，则发出警告。</target>
        </trans-unit>
        <trans-unit id="2a938c70ebc261d86f7b298216ca1b2a1c719c46" translate="yes" xml:space="preserve">
          <source>Warn if an aggregate or union initializer is not fully bracketed. In the following example, the initializer for &lt;code&gt;a&lt;/code&gt; is not fully bracketed, but that for &lt;code&gt;b&lt;/code&gt; is fully bracketed. This warning is enabled by</source>
          <target state="translated">如果聚合或联合初始化程序未完全括起，则发出警告。在以下示例中，用于初始化 &lt;code&gt;a&lt;/code&gt; 没有完全括号，但对于 &lt;code&gt;b&lt;/code&gt; 被完全括号。此警告通过以下方式启用</target>
        </trans-unit>
        <trans-unit id="13b8026e8132cdf11c73019d5520d0d0def0ca31" translate="yes" xml:space="preserve">
          <source>Warn if an array subscript has type &lt;code&gt;char&lt;/code&gt;. This is a common cause of error, as programmers often forget that this type is signed on some machines. This warning is enabled by</source>
          <target state="translated">如果数组下标的类型为 &lt;code&gt;char&lt;/code&gt; ,则发出警告。这是导致错误的常见原因，因为程序员经常忘记这种类型是在某些机器上签名的。此警告通过以下方式启用</target>
        </trans-unit>
        <trans-unit id="4eadd49680011e5fcccbd2afb576905c49ae4f6b" translate="yes" xml:space="preserve">
          <source>Warn if an automatic variable is used without first being initialized or if a variable may be clobbered by a &lt;code&gt;setjmp&lt;/code&gt; call. In C++, warn if a non-static reference or non-static &lt;code&gt;const&lt;/code&gt; member appears in a class without constructors.</source>
          <target state="translated">如果未使用自动变量而未对其进行初始化，或者如果 &lt;code&gt;setjmp&lt;/code&gt; 调用可能破坏了该变量，则发出警告。在C ++中，警告是否在没有构造函数的类中出现非静态引用或非静态 &lt;code&gt;const&lt;/code&gt; 成员。</target>
        </trans-unit>
        <trans-unit id="dc1ee512cf2decbbe83cea7bedf87603b46e0326" translate="yes" xml:space="preserve">
          <source>Warn if an empty body occurs in an &lt;code&gt;if&lt;/code&gt;, &lt;code&gt;else&lt;/code&gt; or &lt;code&gt;do
while&lt;/code&gt; statement. This warning is also enabled by</source>
          <target state="translated">如果 &lt;code&gt;if&lt;/code&gt; ， &lt;code&gt;else&lt;/code&gt; 或 &lt;code&gt;do while&lt;/code&gt; 语句中出现空主体，则发出警告。此警告也通过以下方式启用</target>
        </trans-unit>
        <trans-unit id="383fdc3973b7b5cc3531ea392827d8edfbd6eb85" translate="yes" xml:space="preserve">
          <source>Warn if an initialized field with side effects is overridden when using designated initializers (see &lt;a href=&quot;designated-inits#Designated-Inits&quot;&gt;Designated Initializers&lt;/a&gt;). This warning is enabled by default.</source>
          <target state="translated">警告：使用指定的初始化程序时，是否会覆盖具有副作用的初始化字段（请参阅&amp;ldquo; &lt;a href=&quot;designated-inits#Designated-Inits&quot;&gt;指定的初始化程序&amp;rdquo;&lt;/a&gt;）。默认情况下启用此警告。</target>
        </trans-unit>
        <trans-unit id="fdf68e08c13104db975e1e1b5bfffcc9f671b2dc" translate="yes" xml:space="preserve">
          <source>Warn if an initialized field without side effects is overridden when using designated initializers (see &lt;a href=&quot;designated-inits#Designated-Inits&quot;&gt;Designated Initializers&lt;/a&gt;).</source>
          <target state="translated">当使用指定的初始化程序时，警告是否覆盖了没有副作用的初始化字段（请参见&lt;a href=&quot;designated-inits#Designated-Inits&quot;&gt;Designated Initializers&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="d80a9ebeceb31bde1433b7b0306e206a1d5169eb" translate="yes" xml:space="preserve">
          <source>Warn if an old-style (C-style) cast to a non-void type is used within a C++ program. The new-style casts (&lt;code&gt;dynamic_cast&lt;/code&gt;, &lt;code&gt;static_cast&lt;/code&gt;, &lt;code&gt;reinterpret_cast&lt;/code&gt;, and &lt;code&gt;const_cast&lt;/code&gt;) are less vulnerable to unintended effects and much easier to search for.</source>
          <target state="translated">如果在C ++程序中使用了旧样式（C样式）强制转换为非无效类型，则发出警告。新样式的类型转换（ &lt;code&gt;dynamic_cast&lt;/code&gt; ， &lt;code&gt;static_cast&lt;/code&gt; ， &lt;code&gt;reinterpret_cast&lt;/code&gt; 和 &lt;code&gt;const_cast&lt;/code&gt; ）不易受到意想不到的影响，并且更易于搜索。</target>
        </trans-unit>
        <trans-unit id="c7f9169958964ae3bf708d5e9fc733f1b6f3d079" translate="yes" xml:space="preserve">
          <source>Warn if an old-style function definition is used. A warning is given even if there is a previous prototype.</source>
          <target state="translated">如果使用了旧式函数定义,则发出警告。即使有以前的原型,也会发出警告。</target>
        </trans-unit>
        <trans-unit id="da6e0c7f139a454bc8182dc0ec55a473f639305f" translate="yes" xml:space="preserve">
          <source>Warn if an undefined identifier is evaluated in an &lt;code&gt;#if&lt;/code&gt; directive. Such identifiers are replaced with zero.</source>
          <target state="translated">如果在 &lt;code&gt;#if&lt;/code&gt; 指令中评估了未定义的标识符，则发出警告。此类标识符将替换为零。</target>
        </trans-unit>
        <trans-unit id="ac1c57ed34616373c808e98ba1a7016be9451740" translate="yes" xml:space="preserve">
          <source>Warn if any functions that return structures or unions are defined or called. (In languages where you can return an array, this also elicits a warning.)</source>
          <target state="translated">如果定义或调用了任何返回结构或联合的函数,则发出警告。(在可以返回数组的语言中,这也会引起警告。)</target>
        </trans-unit>
        <trans-unit id="51dd1d087c6f2f3e06e53605399888ad9deb557f" translate="yes" xml:space="preserve">
          <source>Warn if any trigraphs are encountered that might change the meaning of the program. Trigraphs within comments are not warned about, except those that would form escaped newlines.</source>
          <target state="translated">如果遇到任何可能改变程序含义的三段式,则发出警告。除了那些会形成转义的新行外,注释中的三段式不会被警告。</target>
        </trans-unit>
        <trans-unit id="4ffcebae22b64bc0188075323e253a892fb2c53e" translate="yes" xml:space="preserve">
          <source>Warn if anything is declared more than once in the same scope, even in cases where multiple declaration is valid and changes nothing.</source>
          <target state="translated">如果任何东西在同一个作用域中被声明了不止一次,即使在多次声明有效且没有任何改变的情况下,也要发出警告。</target>
        </trans-unit>
        <trans-unit id="e116ff785f520c78cab89ec80c259fd9b971e9a1" translate="yes" xml:space="preserve">
          <source>Warn if feedback profiles are missing when using the</source>
          <target state="translated">如果在使用的时候缺少反馈信息,则发出警告。</target>
        </trans-unit>
        <trans-unit id="159621fc69892b60a8932abc53e5e7077fd3432a" translate="yes" xml:space="preserve">
          <source>Warn if feedback profiles do not match when using the</source>
          <target state="translated">如果在使用的时候反馈信息不匹配,则发出警告。</target>
        </trans-unit>
        <trans-unit id="4484a988d285daa67ba50d8d0068eac8b9c3b671" translate="yes" xml:space="preserve">
          <source>Warn if floating-point values are used in equality comparisons.</source>
          <target state="translated">如果在等价比较中使用浮点值,则发出警告。</target>
        </trans-unit>
        <trans-unit id="5905365a7243693b281255e7cd734a616d419731" translate="yes" xml:space="preserve">
          <source>Warn if in a loop with constant number of iterations the compiler detects undefined behavior in some statement during one or more of the iterations.</source>
          <target state="translated">如果在一个恒定迭代次数的循环中,编译器在一次或多次迭代中检测到某些语句的未定义行为,则发出警告。</target>
        </trans-unit>
        <trans-unit id="30ffd0486ea9b42613bc7458b80c284dea250c07" translate="yes" xml:space="preserve">
          <source>Warn if left shifting a negative value. This warning is enabled by</source>
          <target state="translated">左移为负值时发出警告。这个警告是由</target>
        </trans-unit>
        <trans-unit id="59ffb10f60449caf44bc018fb1547abe48a875a4" translate="yes" xml:space="preserve">
          <source>Warn if multiple methods of different types for the same selector are found during compilation. The check is performed on the list of methods in the final stage of compilation. Additionally, a check is performed for each selector appearing in a &lt;code&gt;@selector(&amp;hellip;)&lt;/code&gt; expression, and a corresponding method for that selector has been found during compilation. Because these checks scan the method table only at the end of compilation, these warnings are not produced if the final stage of compilation is not reached, for example because an error is found during compilation, or because the</source>
          <target state="translated">警告在编译过程中是否为同一选择器找到了不同类型的多个方法。在编译的最后阶段对方法列表执行检查。另外， &lt;code&gt;@selector(&amp;hellip;)&lt;/code&gt; 出现在@selector（&amp;hellip;）表达式中的每个选择器执行检查，并在编译期间找到该选择器的相应方法。由于这些检查仅在编译结束时才扫描方法表，因此，如果未到达编译的最后阶段，则不会生成这些警告，例如，因为在编译期间发现错误，或者因为</target>
        </trans-unit>
        <trans-unit id="cd90c2f7bb5d921c657a205bebfbd186d1fe38a6" translate="yes" xml:space="preserve">
          <source>Warn if multiple methods with differing argument and/or return types are found for a given selector when attempting to send a message using this selector to a receiver of type &lt;code&gt;id&lt;/code&gt; or &lt;code&gt;Class&lt;/code&gt;. When this flag is off (which is the default behavior), the compiler omits such warnings if any differences found are confined to types that share the same size and alignment.</source>
          <target state="translated">当尝试使用给定选择器向 &lt;code&gt;id&lt;/code&gt; 或 &lt;code&gt;Class&lt;/code&gt; 类型的接收器发送消息时，如果找到给定选择器具有不同参数和/或返回类型的多个方法，则发出警告。禁用此标志时（这是默认行为），如果发现的任何差异仅限于共享相同大小和对齐方式的类型，则编译器将忽略此类警告。</target>
        </trans-unit>
        <trans-unit id="b4a4ef5836fcd4eb9eae356fd7d365383ac64fa2" translate="yes" xml:space="preserve">
          <source>Warn if padding is included in a structure, either to align an element of the structure or to align the whole structure. Sometimes when this happens it is possible to rearrange the fields of the structure to reduce the padding and so make the structure smaller.</source>
          <target state="translated">如果结构中包含了padding,无论是为了对齐结构中的某个元素还是为了对齐整个结构,都要发出警告。在这种情况下,有时可以重新排列结构的字段,以减少填充物,从而使结构变小。</target>
        </trans-unit>
        <trans-unit id="cd9ef45fbb8d72f1831fd326b4e220df7e2faf4b" translate="yes" xml:space="preserve">
          <source>Warn if parentheses are omitted in certain contexts, such as when there is an assignment in a context where a truth value is expected, or when operators are nested whose precedence people often get confused about.</source>
          <target state="translated">如果在某些上下文中省略了括号,例如当在上下文中存在一个预期为真值的赋值时,或者当运算符被嵌套时,人们经常会对其优先级感到困惑时,就会发出警告。</target>
        </trans-unit>
        <trans-unit id="3dceb1e23a828c2f0ba0a906a334b86bd9449ace" translate="yes" xml:space="preserve">
          <source>Warn if shift count &amp;gt;= width of type. This warning is enabled by default.</source>
          <target state="translated">如果移位计数&amp;gt; =类型宽度，则发出警告。默认情况下启用此警告。</target>
        </trans-unit>
        <trans-unit id="782b64d027fe58cf65d8d3d5a2401f820f146ca7" translate="yes" xml:space="preserve">
          <source>Warn if shift count is negative. This warning is enabled by default.</source>
          <target state="translated">如果移位数为负值,则发出警告。默认情况下,该警告是启用的。</target>
        </trans-unit>
        <trans-unit id="9c75b9200e1a12aae1dc4d040bec33d9a26d867e" translate="yes" xml:space="preserve">
          <source>Warn if the C++17 feature making &lt;code&gt;noexcept&lt;/code&gt; part of a function type changes the mangled name of a symbol relative to C++14. Enabled by</source>
          <target state="translated">如果 &lt;code&gt;noexcept&lt;/code&gt; 成为函数类型的一部分的C ++ 17功能更改了相对于C ++ 14的符号的错误名称，则发出警告。由...启用</target>
        </trans-unit>
        <trans-unit id="46702f45847b2104b177e9b694f3c3f7e2226105" translate="yes" xml:space="preserve">
          <source>Warn if the ISR is misspelled, i.e. without __vector prefix. Enabled by default.</source>
          <target state="translated">如果ISR拼写错误,即没有__vector前缀,则发出警告。默认为启用。</target>
        </trans-unit>
        <trans-unit id="33d88165f92bdb2b45ff7a297ce9db7215dfa02b" translate="yes" xml:space="preserve">
          <source>Warn if the compiler detects paths that trigger erroneous or undefined behavior due to dereferencing a null pointer. This option is only active when</source>
          <target state="translated">如果编译器检测到一些路径由于解除引用null指针而引发错误或未定义行为,则发出警告。这个选项只有在</target>
        </trans-unit>
        <trans-unit id="201bd84a1d08c6c2787e78691ed2f3f92ff20d03" translate="yes" xml:space="preserve">
          <source>Warn if the loop cannot be optimized because the compiler cannot assume anything on the bounds of the loop indices. With</source>
          <target state="translated">如果循环不能被优化,因为编译器不能假设循环指数的任何界限,则发出警告。有了</target>
        </trans-unit>
        <trans-unit id="6ce9dcfeb56e93b36f3824efcafb3fac2f89db30" translate="yes" xml:space="preserve">
          <source>Warn if the return type of a function has a type qualifier such as &lt;code&gt;const&lt;/code&gt;. For ISO C such a type qualifier has no effect, since the value returned by a function is not an lvalue. For C++, the warning is only emitted for scalar types or &lt;code&gt;void&lt;/code&gt;. ISO C prohibits qualified &lt;code&gt;void&lt;/code&gt; return types on function definitions, so such return types always receive a warning even without this option.</source>
          <target state="translated">如果函数的返回类型具有类型限定符（例如 &lt;code&gt;const&lt;/code&gt; )，则发出警告。对于ISO C，这种类型限定符无效，因为函数返回的值不是左值。对于C ++，仅针对标量类型或 &lt;code&gt;void&lt;/code&gt; 发出警告。 ISO C禁止在函数定义中使用合格的 &lt;code&gt;void&lt;/code&gt; 返回类型，因此即使没有此选项，此类返回类型也始终会收到警告。</target>
        </trans-unit>
        <trans-unit id="84e834ec069e09da87cddcf3972bf0a3064670e4" translate="yes" xml:space="preserve">
          <source>Warn if the size of a function frame exceeds &lt;var&gt;byte-size&lt;/var&gt;. The computation done to determine the stack frame size is approximate and not conservative. The actual requirements may be somewhat greater than &lt;var&gt;byte-size&lt;/var&gt; even if you do not get a warning. In addition, any space allocated via &lt;code&gt;alloca&lt;/code&gt;, variable-length arrays, or related constructs is not included by the compiler when determining whether or not to issue a warning.</source>
          <target state="translated">如果功能框 &lt;var&gt;byte-size&lt;/var&gt; 超过byte-size，则发出警告。确定堆栈帧大小所做的计算是近似的，而不是保守的。即使您没有收到警告，实际的要求也可能比 &lt;var&gt;byte-size&lt;/var&gt; 要大一些。此外，在确定是否发出警告时，编译器不包括通过 &lt;code&gt;alloca&lt;/code&gt; ，可变长度数组或相关结构分配的任何空间。</target>
        </trans-unit>
        <trans-unit id="5b03e969a133a7f61dfd42668c90fbd199dc871d" translate="yes" xml:space="preserve">
          <source>Warn if the stack usage of a function might exceed &lt;var&gt;byte-size&lt;/var&gt;. The computation done to determine the stack usage is conservative. Any space allocated via &lt;code&gt;alloca&lt;/code&gt;, variable-length arrays, or related constructs is included by the compiler when determining whether or not to issue a warning.</source>
          <target state="translated">如果函数的堆栈使用量可能超过 &lt;var&gt;byte-size&lt;/var&gt; ，则发出警告。确定堆栈使用情况所做的计算是保守的。在确定是否发出警告时，编译器将包括通过 &lt;code&gt;alloca&lt;/code&gt; ，可变长度数组或相关结构分配的任何空间。</target>
        </trans-unit>
        <trans-unit id="949e7c4b1e5fd9dd73b3df3e4dd44a3a50fb46cc" translate="yes" xml:space="preserve">
          <source>Warn if the type of &lt;code&gt;main&lt;/code&gt; is suspicious. &lt;code&gt;main&lt;/code&gt; should be a function with external linkage, returning int, taking either zero arguments, two, or three arguments of appropriate types. This warning is enabled by default in C++ and is enabled by either</source>
          <target state="translated">如果 &lt;code&gt;main&lt;/code&gt; 类型可疑，请发出警告。 &lt;code&gt;main&lt;/code&gt; 应该是具有外部链接的函数，返回int，采用零参数，两个或三个适当类型的参数。默认情况下，此警告在C ++中处于启用状态，</target>
        </trans-unit>
        <trans-unit id="6da28b5dec8555c7e8c577e4ad18fb400e3b7e57" translate="yes" xml:space="preserve">
          <source>Warn if the vectorizer cost model overrides the OpenMP simd directive set by user. The</source>
          <target state="translated">如果向量器成本模型覆盖了用户设置的OpenMP simd指令,则发出警告。该</target>
        </trans-unit>
        <trans-unit id="cd147a815b47d8a61a481259e6bec92f6328c4b1" translate="yes" xml:space="preserve">
          <source>Warn if variadic macros are used in ISO C90 mode, or if the GNU alternate syntax is used in ISO C99 mode. This is enabled by either</source>
          <target state="translated">如果在ISO C90模式下使用了变量宏,或者在ISO C99模式下使用了GNU替代语法,则发出警告。这可以通过以下两种方式启用</target>
        </trans-unit>
        <trans-unit id="55d977b102dea3867bcd6836e9a2eac79a9f6018" translate="yes" xml:space="preserve">
          <source>Warn if vector operation is not implemented via SIMD capabilities of the architecture. Mainly useful for the performance tuning. Vector operation can be implemented &lt;code&gt;piecewise&lt;/code&gt;, which means that the scalar operation is performed on every vector element; &lt;code&gt;in parallel&lt;/code&gt;, which means that the vector operation is implemented using scalars of wider type, which normally is more performance efficient; and &lt;code&gt;as a single scalar&lt;/code&gt;, which means that vector fits into a scalar type.</source>
          <target state="translated">如果没有通过体系结构的SIMD功能实现矢量操作，则发出警告。主要用于性能调整。向量运算可以 &lt;code&gt;piecewise&lt;/code&gt; 实现，这意味着对每个向量元素都执行标量运算。 &lt;code&gt;in parallel&lt;/code&gt; ，这意味着向量运算是使用较宽类型的标量实现的，通常，这种标量具有更高的性能效率；并且 &lt;code&gt;as a single scalar&lt;/code&gt; ，这意味着矢量适合标量类型。</target>
        </trans-unit>
        <trans-unit id="d552f4c46cc5d3bd7e299e5496e695efcda3d372" translate="yes" xml:space="preserve">
          <source>Warn on uses of the &lt;code&gt;register&lt;/code&gt; storage class specifier, except when it is part of the GNU &lt;a href=&quot;explicit-register-variables#Explicit-Register-Variables&quot;&gt;Explicit Register Variables&lt;/a&gt; extension. The use of the &lt;code&gt;register&lt;/code&gt; keyword as storage class specifier has been deprecated in C++11 and removed in C++17. Enabled by default with</source>
          <target state="translated">警告使用 &lt;code&gt;register&lt;/code&gt; 存储类说明符，除非它是GNU &lt;a href=&quot;explicit-register-variables#Explicit-Register-Variables&quot;&gt;Explicit Register Variables&lt;/a&gt;扩展的一部分。使用的 &lt;code&gt;register&lt;/code&gt; 关键字作为存储类说明已弃用在C ++ 11和在C ++ 17移除。默认启用</target>
        </trans-unit>
        <trans-unit id="77c0caa2b84a54b5bcf764add54f563ae56b7071" translate="yes" xml:space="preserve">
          <source>Warn that the implicit declaration of a copy constructor or copy assignment operator is deprecated if the class has a user-provided copy constructor or copy assignment operator, in C++11 and up. This warning is enabled by</source>
          <target state="translated">警告:在C++11及以上版本中,如果类中有用户提供的复制构造函数或复制赋值操作符,那么隐式声明的复制构造函数或复制赋值操作符是不被认可的。这个警告是由</target>
        </trans-unit>
        <trans-unit id="4d2e76892f19022181f5882885c8f72e1722da44" translate="yes" xml:space="preserve">
          <source>Warn upon questionable usage of the macros used to handle variable arguments like &lt;code&gt;va_start&lt;/code&gt;. This is default. To inhibit the warning messages, use</source>
          <target state="translated">对用于处理可变参数（例如 &lt;code&gt;va_start&lt;/code&gt; )的宏的用法有疑问时发出警告。这是默认值。要禁止显示警告消息，请使用</target>
        </trans-unit>
        <trans-unit id="3abec5289cdc959e5a13fe23b53843308a01da72" translate="yes" xml:space="preserve">
          <source>Warn when &lt;code&gt;__sync_fetch_and_nand&lt;/code&gt; and &lt;code&gt;__sync_nand_and_fetch&lt;/code&gt; built-in functions are used. These functions changed semantics in GCC 4.4.</source>
          <target state="translated">当使用 &lt;code&gt;__sync_fetch_and_nand&lt;/code&gt; 和 &lt;code&gt;__sync_nand_and_fetch&lt;/code&gt; 内置函数时发出警告。这些功能更改了GCC 4.4中的语义。</target>
        </trans-unit>
        <trans-unit id="2aa9b92f65cbea3024eccc7e04605b70f951ef46" translate="yes" xml:space="preserve">
          <source>Warn when &lt;code&gt;delete&lt;/code&gt; is used to destroy an instance of a class that has virtual functions and non-virtual destructor. It is unsafe to delete an instance of a derived class through a pointer to a base class if the base class does not have a virtual destructor. This warning is enabled by</source>
          <target state="translated">在使用 &lt;code&gt;delete&lt;/code&gt; 销毁具有虚拟功能和非虚拟析构函数的类的实例时发出警告。如果基类没有虚拟析构函数，则通过指向基类的指针删除派生类的实例是不安全的。此警告通过以下方式启用</target>
        </trans-unit>
        <trans-unit id="f21bdb487f01146075a954516a5aced86463b3d2" translate="yes" xml:space="preserve">
          <source>Warn when G++ it generates code that is probably not compatible with the vendor-neutral C++ ABI. Since G++ now defaults to updating the ABI with each major release, normally</source>
          <target state="translated">当G++生成的代码可能与厂商中立的C++ABI不兼容时,发出警告。由于G++现在默认在每个主要版本中都会更新ABI,所以通常情况下</target>
        </trans-unit>
        <trans-unit id="35e0de5085f6b803ca5c49ba47e5ebe4c1616823" translate="yes" xml:space="preserve">
          <source>Warn when a &lt;code&gt;#pragma&lt;/code&gt; directive is encountered that is not understood by GCC. If this command-line option is used, warnings are even issued for unknown pragmas in system header files. This is not the case if the warnings are only enabled by the</source>
          <target state="translated">在遇到GCC无法理解的 &lt;code&gt;#pragma&lt;/code&gt; 指令时发出警告。如果使用此命令行选项，则甚至会针对系统头文件中的未知杂项发出警告。如果仅由警告启用警告，则不是这种情况。</target>
        </trans-unit>
        <trans-unit id="62d4dab62f762a61b2f522842ea9ed134dd06936" translate="yes" xml:space="preserve">
          <source>Warn when a class has virtual functions and an accessible non-virtual destructor itself or in an accessible polymorphic base class, in which case it is possible but unsafe to delete an instance of a derived class through a pointer to the class itself or base class. This warning is automatically enabled if</source>
          <target state="translated">当一个类本身或在一个可访问的多态基类中具有虚拟函数和可访问的非虚拟析构器时,发出警告,在这种情况下,通过指向类本身或基类的指针删除派生类的实例是可能的,但不安全。在以下情况下,这个警告会自动启用</target>
        </trans-unit>
        <trans-unit id="2cb7e95f48120a523e19a1fdc36b0b8e1ca72f8b" translate="yes" xml:space="preserve">
          <source>Warn when a class is defined with a virtual direct base class. Some coding rules disallow multiple inheritance, and this may be used to enforce that rule. The warning is inactive inside a system header file, such as the STL, so one can still use the STL. One may also define classes that indirectly use virtual inheritance.</source>
          <target state="translated">当一个类被定义为虚拟直接基类时,发出警告。有些编码规则不允许多继承,可以用这个来执行这个规则。该警告在系统头文件(如STL)里面是不活动的,所以人们仍然可以使用STL。人们也可以定义间接使用虚拟继承的类。</target>
        </trans-unit>
        <trans-unit id="856d4cae226810333db6e35bc2ec148c4f408659" translate="yes" xml:space="preserve">
          <source>Warn when a class is defined with multiple direct base classes. Some coding rules disallow multiple inheritance, and this may be used to enforce that rule. The warning is inactive inside a system header file, such as the STL, so one can still use the STL. One may also define classes that indirectly use multiple inheritance.</source>
          <target state="translated">当一个类被定义了多个直接基类时,发出警告。有些编码规则不允许多继承,可以用这个来执行这个规则。该警告在系统头文件(如STL)里面是无效的,所以人们仍然可以使用STL。人们也可以定义间接使用多重继承的类。</target>
        </trans-unit>
        <trans-unit id="62d55cbfe764766f5f6f7218d2c7a740a50c90ce" translate="yes" xml:space="preserve">
          <source>Warn when a class seems unusable because all the constructors or destructors in that class are private, and it has neither friends nor public static member functions. Also warn if there are no non-private methods, and there&amp;rsquo;s at least one private member function that isn&amp;rsquo;t a constructor or destructor.</source>
          <target state="translated">当某个类似乎不可用时发出警告，因为该类中的所有构造函数或析构函数都是私有的，并且既没有朋友也没有公共静态成员函数。还警告是否没有非私有方法，并且至少有一个不是构造函数或析构函数的私有成员函数。</target>
        </trans-unit>
        <trans-unit id="3da6bed540b8c798c01ac10e6f991d33a93d7840" translate="yes" xml:space="preserve">
          <source>Warn when a comparison between signed and unsigned values could produce an incorrect result when the signed value is converted to unsigned. In C++, this warning is also enabled by</source>
          <target state="translated">当有符号值和无符号值之间的比较在将有符号值转换为无符号值时可能产生不正确的结果时发出警告。在C++中,这个警告也可以通过</target>
        </trans-unit>
        <trans-unit id="d0d230a7b94f00a257ce101a92be2d7094f8073f" translate="yes" xml:space="preserve">
          <source>Warn when a declaration does not specify a type. This warning is enabled by</source>
          <target state="translated">当一个声明没有指定类型时发出警告。这个警告是由</target>
        </trans-unit>
        <trans-unit id="65d83d710bdf5c622a92b858d79d70755ab8010e" translate="yes" xml:space="preserve">
          <source>Warn when a declaration is found after a statement in a block. This construct, known from C++, was introduced with ISO C99 and is by default allowed in GCC. It is not supported by ISO C90. See &lt;a href=&quot;mixed-declarations#Mixed-Declarations&quot;&gt;Mixed Declarations&lt;/a&gt;.</source>
          <target state="translated">在块中的语句后找到声明时发出警告。从C ++已知的此构造是ISO C99引入的，默认情况下在GCC中允许。ISO C90不支持它。请参阅&lt;a href=&quot;mixed-declarations#Mixed-Declarations&quot;&gt;混合声明&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a51fcbd164dc3089b47299b1d3b6f2732c7c6fcc" translate="yes" xml:space="preserve">
          <source>Warn when a declaration of a function is missing one or more attributes that a related function is declared with and whose absence may adversely affect the correctness or efficiency of generated code. For example, the warning is issued for declarations of aliases that use attributes to specify less restrictive requirements than those of their targets. This typically represents a potential optimization opportunity. By contrast, the</source>
          <target state="translated">当一个函数的声明缺少一个或多个相关函数声明的属性,并且这些属性的缺失可能会对生成代码的正确性或效率产生不利影响时,发出警告。例如,当别名的声明使用属性来指定比目标更少限制性的要求时,就会发出警告。这通常代表了一个潜在的优化机会。相比之下</target>
        </trans-unit>
        <trans-unit id="4f18983de88b8950abf6205674919e5d25d36a1f" translate="yes" xml:space="preserve">
          <source>Warn when a function call is cast to a non-matching type. For example, warn if a call to a function returning an integer type is cast to a pointer type.</source>
          <target state="translated">当一个函数调用被转换为非匹配类型时发出警告。例如,当一个返回整数类型的函数调用被转为指针类型时,发出警告。</target>
        </trans-unit>
        <trans-unit id="1fee5efa47b570695ab661666c6e4fee9e9b04a8" translate="yes" xml:space="preserve">
          <source>Warn when a function declaration hides virtual functions from a base class. For example, in:</source>
          <target state="translated">当函数声明将虚拟函数从基类中隐藏出来时,发出警告。例如,在。</target>
        </trans-unit>
        <trans-unit id="e0dab17ca245164b1ca8348967e2bf698b2a4654" translate="yes" xml:space="preserve">
          <source>Warn when a function pointer is cast to an incompatible function pointer. In a cast involving function types with a variable argument list only the types of initial arguments that are provided are considered. Any parameter of pointer-type matches any other pointer-type. Any benign differences in integral types are ignored, like &lt;code&gt;int&lt;/code&gt; vs. &lt;code&gt;long&lt;/code&gt; on ILP32 targets. Likewise type qualifiers are ignored. The function type &lt;code&gt;void (*) (void)&lt;/code&gt; is special and matches everything, which can be used to suppress this warning. In a cast involving pointer to member types this warning warns whenever the type cast is changing the pointer to member type. This warning is enabled by</source>
          <target state="translated">在将函数指针强制转换为不兼容的函数指针时发出警告。在涉及具有可变参数列表的函数类型的转换中，仅考虑提供的初始参数的类型。指针类型的任何参数都与任何其他指针类型匹配。整数类型的任何良性差异都将被忽略，例如ILP32目标上的 &lt;code&gt;int&lt;/code&gt; vs. &lt;code&gt;long&lt;/code&gt; 。同样，类型限定符也将被忽略。函数类型 &lt;code&gt;void (*) (void)&lt;/code&gt; 是特殊的，并且与所有内容匹配，可用于抑制此警告。在涉及成员类型指针的转换中，只要类型转换将指针更改为成员类型，此警告都会发出警告。此警告通过以下方式启用</target>
        </trans-unit>
        <trans-unit id="1c95c86068b8b8d1d8a72bc94ef016e54d5ce483" translate="yes" xml:space="preserve">
          <source>Warn when a literal &amp;lsquo;</source>
          <target state="translated">当文字'</target>
        </trans-unit>
        <trans-unit id="fc5d5783ac1277dfc41a8a050b298452017de063" translate="yes" xml:space="preserve">
          <source>Warn when a local variable shadows another local variable or parameter whose type is compatible with that of the shadowing variable. In C++, type compatibility here means the type of the shadowing variable can be converted to that of the shadowed variable. The creation of this flag (in addition to</source>
          <target state="translated">当一个局部变量屏蔽了另一个局部变量或参数,而该变量的类型与被屏蔽变量的类型兼容时,发出警告。在C++中,这里的类型兼容性意味着影子变量的类型可以转换为被影子变量的类型。这个标志的创建(除了</target>
        </trans-unit>
        <trans-unit id="15ad15a27db9c39d53d6f814ef18cd0f426f15bd" translate="yes" xml:space="preserve">
          <source>Warn when a local variable shadows another local variable or parameter. This warning is enabled by</source>
          <target state="translated">当一个局部变量对另一个局部变量或参数产生阴影时发出警告。这个警告是由</target>
        </trans-unit>
        <trans-unit id="7332bfdf0522cbf64f5e187ed28df9e9bbf190d7" translate="yes" xml:space="preserve">
          <source>Warn when a namespace definition is opened. Some coding rules disallow namespaces, and this may be used to enforce that rule. The warning is inactive inside a system header file, such as the STL, so one can still use the STL. One may also use using directives and qualified names.</source>
          <target state="translated">当一个命名空间定义被打开时发出警告。有些编码规则不允许使用命名空间,这可以用来强制执行该规则。该警告在系统头文件(如STL)里面是不活动的,所以人们仍然可以使用STL。人们也可以使用使用指令和限定名。</target>
        </trans-unit>
        <trans-unit id="0c68af853608801bfccea4375c872dd95f8c2c74" translate="yes" xml:space="preserve">
          <source>Warn when a noexcept-expression evaluates to false because of a call to a function that does not have a non-throwing exception specification (i.e. &lt;code&gt;throw()&lt;/code&gt; or &lt;code&gt;noexcept&lt;/code&gt;) but is known by the compiler to never throw an exception.</source>
          <target state="translated">当noexcept-expression由于调用没有非抛出异常规范（即 &lt;code&gt;throw()&lt;/code&gt; 或 &lt;code&gt;noexcept&lt;/code&gt; ）但编译器知道永远不会抛出异常的函数而导致计算结果为false时发出警告。</target>
        </trans-unit>
        <trans-unit id="64beb2070ebf4a8be0aefd1a955c78bef9d98677" translate="yes" xml:space="preserve">
          <source>Warn when a primary template declaration is encountered. Some coding rules disallow templates, and this may be used to enforce that rule. The warning is inactive inside a system header file, such as the STL, so one can still use the STL. One may also instantiate or specialize templates.</source>
          <target state="translated">遇到主模板声明时发出警告。有些编码规则不允许使用模板,可以用这个来执行这个规则。警告在系统头文件(如STL)里面是不活动的,所以人们仍然可以使用STL。人们还可以实例化或特殊化模板。</target>
        </trans-unit>
        <trans-unit id="ecfd63f7bf76274a278010015f443553fb311275" translate="yes" xml:space="preserve">
          <source>Warn when a string or character literal is followed by a ud-suffix which does not begin with an underscore. As a conforming extension, GCC treats such suffixes as separate preprocessing tokens in order to maintain backwards compatibility with code that uses formatting macros from &lt;code&gt;&amp;lt;inttypes.h&amp;gt;&lt;/code&gt;. For example:</source>
          <target state="translated">当字符串或字符文字后跟不以下划线开头的ud后缀时发出警告。作为一致的扩展，GCC将这些后缀视为单独的预处理令牌，以便与使用 &lt;code&gt;&amp;lt;inttypes.h&amp;gt;&lt;/code&gt; 格式宏的代码保持向后兼容性。例如：</target>
        </trans-unit>
        <trans-unit id="af55e43f2240ead9470434a0686aeb1f0a48afd9" translate="yes" xml:space="preserve">
          <source>Warn when a switch case falls through. For example:</source>
          <target state="translated">当开关盒跌破时,发出警告。例如:</target>
        </trans-unit>
        <trans-unit id="fae5e5411e11c5c48526329b8f085ab67410eafc" translate="yes" xml:space="preserve">
          <source>Warn when a type with an ABI tag is used in a context that does not have that ABI tag. See &lt;a href=&quot;c_002b_002b-attributes#C_002b_002b-Attributes&quot;&gt;C++ Attributes&lt;/a&gt; for more information about ABI tags.</source>
          <target state="translated">在不具有ABI标签的上下文中使用带有ABI标签的类型时发出警告。有关ABI标签的更多信息，请参见&lt;a href=&quot;c_002b_002b-attributes#C_002b_002b-Attributes&quot;&gt;C ++属性&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b81088e3c7de4ba5e43b90938614126c8743c79a" translate="yes" xml:space="preserve">
          <source>Warn when a typedef locally defined in a function is not used. This warning is enabled by</source>
          <target state="translated">当函数中本地定义的typedef未被使用时发出警告。这个警告是由</target>
        </trans-unit>
        <trans-unit id="7f92b37eeb1fc74d56bfb3de4e40a33e9756c1f8" translate="yes" xml:space="preserve">
          <source>Warn when an attribute is ignored. This is different from the</source>
          <target state="translated">当一个属性被忽略时发出警告。这与</target>
        </trans-unit>
        <trans-unit id="69d8172c43b83e36a9fc251e2742504cc5f07f18" translate="yes" xml:space="preserve">
          <source>Warn when an expression is casted to its own type.</source>
          <target state="translated">当一个表达式被转换为自己的类型时,发出警告。</target>
        </trans-unit>
        <trans-unit id="68276b3f14c999ac5fd8362dd7f4c1eb0d25507e" translate="yes" xml:space="preserve">
          <source>Warn when an if-else has identical branches. This warning detects cases like</source>
          <target state="translated">当if-else有相同分支时发出警告。该警告会检测到以下情况</target>
        </trans-unit>
        <trans-unit id="4eaddac0ef918127a66832ad98be3ebdfc801bcd" translate="yes" xml:space="preserve">
          <source>Warn when an object referenced by a &lt;code&gt;restrict&lt;/code&gt;-qualified parameter (or, in C++, a &lt;code&gt;__restrict&lt;/code&gt;-qualified parameter) is aliased by another argument, or when copies between such objects overlap. For example, the call to the &lt;code&gt;strcpy&lt;/code&gt; function below attempts to truncate the string by replacing its initial characters with the last four. However, because the call writes the terminating NUL into &lt;code&gt;a[4]&lt;/code&gt;, the copies overlap and the call is diagnosed.</source>
          <target state="translated">当由 &lt;code&gt;restrict&lt;/code&gt; 限定参数（或在C ++中为 &lt;code&gt;__restrict&lt;/code&gt; 限定参数）引用的对象被另一个参数别名时，或当此类对象之间的副本重叠时发出警告。例如，下面对 &lt;code&gt;strcpy&lt;/code&gt; 函数的调用试图通过将字符串的起始字符替换为后四个字符来截断该字符串。但是，由于调用将终止NUL写入 &lt;code&gt;a[4]&lt;/code&gt; ，因此副本重叠并且诊断了调用。</target>
        </trans-unit>
        <trans-unit id="48e014515a7db6fc79ef0eeec4d6a1ef40fdd1b6" translate="yes" xml:space="preserve">
          <source>Warn when comparing an argument marked with the &lt;code&gt;nonnull&lt;/code&gt; function attribute against null inside the function.</source>
          <target state="translated">将标有 &lt;code&gt;nonnull&lt;/code&gt; 函数属性的参数与函数内部的null 比较时发出警告。</target>
        </trans-unit>
        <trans-unit id="448f3542d0488bfdc3c401daf34114424d62966e" translate="yes" xml:space="preserve">
          <source>Warn when deleting a pointer to incomplete type, which may cause undefined behavior at runtime. This warning is enabled by default.</source>
          <target state="translated">当删除指向不完整类型的指针时发出警告,这可能会在运行时引起未定义的行为。默认情况下,这个警告是启用的。</target>
        </trans-unit>
        <trans-unit id="4aead77201e88b8231585b494878f47ece446b42" translate="yes" xml:space="preserve">
          <source>Warn when macros &lt;code&gt;__TIME__&lt;/code&gt;, &lt;code&gt;__DATE__&lt;/code&gt; or &lt;code&gt;__TIMESTAMP__&lt;/code&gt; are encountered as they might prevent bit-wise-identical reproducible compilations.</source>
          <target state="translated">警告宏时 &lt;code&gt;__TIME__&lt;/code&gt; ， &lt;code&gt;__DATE__&lt;/code&gt; 或 &lt;code&gt;__TIMESTAMP__&lt;/code&gt; 遇到，因为他们可能会阻止逐位完全相同的重复性汇编。</target>
        </trans-unit>
        <trans-unit id="f416313a5d687fda4c349efcccdbcd43185983e0" translate="yes" xml:space="preserve">
          <source>Warn when overload resolution chooses a promotion from unsigned or enumerated type to a signed type, over a conversion to an unsigned type of the same size. Previous versions of G++ tried to preserve unsignedness, but the standard mandates the current behavior.</source>
          <target state="translated">当过载解析选择从无符号类型或枚举类型升级到有符号类型,而不是转换到相同大小的无符号类型时,发出警告。以前的G++版本试图保留无符号类型,但标准规定了当前的行为。</target>
        </trans-unit>
        <trans-unit id="6b26cc3f03f85ab2638c4cf2001a077d93732070" translate="yes" xml:space="preserve">
          <source>Warn when the &amp;lsquo;</source>
          <target state="translated">当&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="8090e980ff3867e87fe893e55e71d464e21173ec" translate="yes" xml:space="preserve">
          <source>Warn when the &lt;code&gt;sizeof&lt;/code&gt; operator is applied to a parameter that is declared as an array in a function definition. This warning is enabled by default for C and C++ programs.</source>
          <target state="translated">当 &lt;code&gt;sizeof&lt;/code&gt; 运算符应用于在函数定义中声明为数组的参数时发出警告。默认情况下，C和C ++程序启用此警告。</target>
        </trans-unit>
        <trans-unit id="9e36c088ae2b71459782ca704065537e9a26901f" translate="yes" xml:space="preserve">
          <source>Warn when the address of packed member of struct or union is taken, which usually results in an unaligned pointer value. This is enabled by default.</source>
          <target state="translated">当结构或联合体的打包成员的地址被取走时发出警告,这通常会导致一个未对齐的指针值。默认情况下是启用的。</target>
        </trans-unit>
        <trans-unit id="99f87649fa1908434c721b9cad02a2282152635b" translate="yes" xml:space="preserve">
          <source>Warn when the destination of a call to a raw memory function such as &lt;code&gt;memset&lt;/code&gt; or &lt;code&gt;memcpy&lt;/code&gt; is an object of class type, and when writing into such an object might bypass the class non-trivial or deleted constructor or copy assignment, violate const-correctness or encapsulation, or corrupt virtual table pointers. Modifying the representation of such objects may violate invariants maintained by member functions of the class. For example, the call to &lt;code&gt;memset&lt;/code&gt; below is undefined because it modifies a non-trivial class object and is, therefore, diagnosed. The safe way to either initialize or clear the storage of objects of such types is by using the appropriate constructor or assignment operator, if one is available.</source>
          <target state="translated">当调用原始内存函数（例如 &lt;code&gt;memset&lt;/code&gt; 或 &lt;code&gt;memcpy&lt;/code&gt; ）的目的地是类类型的对象时，发出警告，并且在写入此类对象时可能会绕过该类的非平凡或已删除的构造函数或副本分配，违反const正确性或封装或损坏的虚拟表指针。修改此类对象的表示形式可能会违反由类的成员函数维护的不变性。例如，下面的对 &lt;code&gt;memset&lt;/code&gt; 的调用是未定义的，因为它会修改非平凡的类对象并因此被诊断。初始化或清除此类对象的存储的安全方法是使用适当的构造函数或赋值运算符（如果有）。</target>
        </trans-unit>
        <trans-unit id="40608df8d0fb171d8c9fd495ba5d5a7b32bd842d" translate="yes" xml:space="preserve">
          <source>Warn when the indentation of the code does not reflect the block structure. Specifically, a warning is issued for &lt;code&gt;if&lt;/code&gt;, &lt;code&gt;else&lt;/code&gt;, &lt;code&gt;while&lt;/code&gt;, and &lt;code&gt;for&lt;/code&gt; clauses with a guarded statement that does not use braces, followed by an unguarded statement with the same indentation.</source>
          <target state="translated">当代码缩进不反映块结构时发出警告。特别是， &lt;code&gt;if&lt;/code&gt; ， &lt;code&gt;else&lt;/code&gt; ， &lt;code&gt;while&lt;/code&gt; 和 &lt;code&gt;for&lt;/code&gt; 子句的保护语句不使用大括号，则发出警告，然后是带有相同缩进的无保护语句。</target>
        </trans-unit>
        <trans-unit id="ccf62a55eeac02e2a52c16724b5155a1eb1a630e" translate="yes" xml:space="preserve">
          <source>Warn when the order of member initializers given in the code does not match the order in which they must be executed. For instance:</source>
          <target state="translated">当代码中给出的成员初始化器的顺序与必须执行的顺序不一致时,发出警告。例如:</target>
        </trans-unit>
        <trans-unit id="761311d3e33c39156d8e3725fcf020a8f1821794" translate="yes" xml:space="preserve">
          <source>Warn when the stack frame of a function exceeds &lt;var&gt;n&lt;/var&gt; bytes.</source>
          <target state="translated">当函数的堆栈帧超过 &lt;var&gt;n&lt;/var&gt; 个字节时发出警告。</target>
        </trans-unit>
        <trans-unit id="837d376bd42b01ca86e7606408854284b9f96c39" translate="yes" xml:space="preserve">
          <source>Warn whenever &amp;lsquo;</source>
          <target state="translated">当&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="0c2135b897d3d5641cf8e18388c032eb11d6e43a" translate="yes" xml:space="preserve">
          <source>Warn whenever a &lt;code&gt;switch&lt;/code&gt; statement contains statements between the controlling expression and the first case label, which will never be executed. For example:</source>
          <target state="translated">当 &lt;code&gt;switch&lt;/code&gt; 语句包含控制表达式和第一个case标签之间的语句时发出警告，该语句将永远不会执行。例如：</target>
        </trans-unit>
        <trans-unit id="3eb686177c30ed2e6e5f5f2664f95e4bb53041fa" translate="yes" xml:space="preserve">
          <source>Warn whenever a &lt;code&gt;switch&lt;/code&gt; statement does not have a &lt;code&gt;default&lt;/code&gt; case.</source>
          <target state="translated">当 &lt;code&gt;switch&lt;/code&gt; 语句没有 &lt;code&gt;default&lt;/code&gt; 大小写时发出警告。</target>
        </trans-unit>
        <trans-unit id="3ee15f4deaad963ee59e6e25cbd36a97c1a0b6f8" translate="yes" xml:space="preserve">
          <source>Warn whenever a &lt;code&gt;switch&lt;/code&gt; statement has an index of boolean type and the case values are outside the range of a boolean type. It is possible to suppress this warning by casting the controlling expression to a type other than &lt;code&gt;bool&lt;/code&gt;. For example:</source>
          <target state="translated">当 &lt;code&gt;switch&lt;/code&gt; 语句具有布尔类型的索引并且大小写值超出布尔类型的范围时发出警告。通过将控制表达式强制转换为 &lt;code&gt;bool&lt;/code&gt; 以外的其他类型，可以抑制此警告。例如：</target>
        </trans-unit>
        <trans-unit id="d226ed0209ee1c2fb6432b4c47bf17b27b050c76" translate="yes" xml:space="preserve">
          <source>Warn whenever a &lt;code&gt;switch&lt;/code&gt; statement has an index of enumerated type and lacks a &lt;code&gt;case&lt;/code&gt; for one or more of the named codes of that enumeration. (The presence of a &lt;code&gt;default&lt;/code&gt; label prevents this warning.) &lt;code&gt;case&lt;/code&gt; labels outside the enumeration range also provoke warnings when this option is used (even if there is a &lt;code&gt;default&lt;/code&gt; label). This warning is enabled by</source>
          <target state="translated">当 &lt;code&gt;switch&lt;/code&gt; 语句具有枚举类型的索引并且缺少该枚举的一个或多个命名代码的 &lt;code&gt;case&lt;/code&gt; ，就发出警告。（使用 &lt;code&gt;default&lt;/code&gt; 标签可以防止出现此警告。）使用此选项时，枚举范围以外的 &lt;code&gt;case&lt;/code&gt; 标签也会引发警告（即使有 &lt;code&gt;default&lt;/code&gt; 标签）。此警告通过以下方式启用</target>
        </trans-unit>
        <trans-unit id="de11d7b668ccdb23ca7bd8a246e58548a37f3260" translate="yes" xml:space="preserve">
          <source>Warn whenever a &lt;code&gt;switch&lt;/code&gt; statement has an index of enumerated type and lacks a &lt;code&gt;case&lt;/code&gt; for one or more of the named codes of that enumeration. &lt;code&gt;case&lt;/code&gt; labels outside the enumeration range also provoke warnings when this option is used. The only difference between</source>
          <target state="translated">当 &lt;code&gt;switch&lt;/code&gt; 语句具有枚举类型的索引并且缺少该枚举的一个或多个命名代码的 &lt;code&gt;case&lt;/code&gt; ，就发出警告。使用此选项时，枚举范围之外的 &lt;code&gt;case&lt;/code&gt; 标签也会引发警告。之间的唯一区别</target>
        </trans-unit>
        <trans-unit id="2d59fb66fde78bda0a4dd35cce84a5db357b0d28" translate="yes" xml:space="preserve">
          <source>Warn whenever a comment-start sequence &amp;lsquo;</source>
          <target state="translated">每当评论开始序列时发出警告'</target>
        </trans-unit>
        <trans-unit id="017d9dfe987bf5077b04f6ad0db50c54e128c51c" translate="yes" xml:space="preserve">
          <source>Warn whenever a constant static variable is unused aside from its declaration.</source>
          <target state="translated">每当一个常量静态变量除了声明之外未被使用时,就会发出警告。</target>
        </trans-unit>
        <trans-unit id="44c2f3d6fa32cff8b5706f1e4a38180d5b65ee57" translate="yes" xml:space="preserve">
          <source>Warn whenever a function is defined with a return type that defaults to &lt;code&gt;int&lt;/code&gt;. Also warn about any &lt;code&gt;return&lt;/code&gt; statement with no return value in a function whose return type is not &lt;code&gt;void&lt;/code&gt; (falling off the end of the function body is considered returning without a value).</source>
          <target state="translated">当函数定义的返回类型默认为 &lt;code&gt;int&lt;/code&gt; 时发出警告。还警告在返回类型不是 &lt;code&gt;void&lt;/code&gt; 的函数中任何没有返回值的 &lt;code&gt;return&lt;/code&gt; 语句（从函数体的末尾掉落被视为没有值的返回）。</target>
        </trans-unit>
        <trans-unit id="89fb51e22730b538a06b8e80540c16d1c3734cc8" translate="yes" xml:space="preserve">
          <source>Warn whenever a function parameter is assigned to, but otherwise unused (aside from its declaration).</source>
          <target state="translated">每当一个函数参数被赋值,但未被使用(除了它的声明)时,就发出警告。</target>
        </trans-unit>
        <trans-unit id="7522f02e51d59309d9911182c3c068a365219bc7" translate="yes" xml:space="preserve">
          <source>Warn whenever a function parameter is unused aside from its declaration.</source>
          <target state="translated">每当一个函数参数除了声明之外没有被使用时,就会发出警告。</target>
        </trans-unit>
        <trans-unit id="c0a7eb9ab9f17ff83adfaf6aff2a67a4af1e6664" translate="yes" xml:space="preserve">
          <source>Warn whenever a label is declared but not used. This warning is enabled by</source>
          <target state="translated">每当一个标签被声明但未被使用时发出警告。这个警告是由</target>
        </trans-unit>
        <trans-unit id="2d58d8f5ceb022d5ba0d30591a67aed1db06f84d" translate="yes" xml:space="preserve">
          <source>Warn whenever a local or static variable is unused aside from its declaration. This option implies</source>
          <target state="translated">当一个局部变量或静态变量在声明之外未被使用时,就会发出警告。这个选项意味着</target>
        </trans-unit>
        <trans-unit id="6e4150091f2d91d35b21758f7af8935b067c74b6" translate="yes" xml:space="preserve">
          <source>Warn whenever a local variable is assigned to, but otherwise unused (aside from its declaration). This warning is enabled by</source>
          <target state="translated">每当一个局部变量被分配到,但未被使用(除了它的声明)时发出警告。这个警告是由</target>
        </trans-unit>
        <trans-unit id="79ce592a35665d53c155cc3462735224db9a9571" translate="yes" xml:space="preserve">
          <source>Warn whenever a local variable or type declaration shadows another variable, parameter, type, class member (in C++), or instance variable (in Objective-C) or whenever a built-in function is shadowed. Note that in C++, the compiler warns if a local variable shadows an explicit typedef, but not if it shadows a struct/class/enum. Same as</source>
          <target state="translated">当一个局部变量或类型声明对另一个变量、参数、类型、类成员(在C++中)或实例变量(在Objective-C中)产生阴影时,或者当一个内置函数产生阴影时,都会发出警告。请注意,在C++中,如果一个局部变量对一个显式类型定义进行了阴影处理,编译器会发出警告,但如果它对一个结构/类/枚举进行了阴影处理,则不会发出警告。与</target>
        </trans-unit>
        <trans-unit id="05ffb9a97b76e12ea54aaaeb8badea77adb678ae" translate="yes" xml:space="preserve">
          <source>Warn whenever a pointer is cast so as to remove a type qualifier from the target type. For example, warn if a &lt;code&gt;const char *&lt;/code&gt; is cast to an ordinary &lt;code&gt;char *&lt;/code&gt;.</source>
          <target state="translated">在强制转换指针时发出警告，以便从目标类型中删除类型限定符。例如，警告是否将 &lt;code&gt;const char *&lt;/code&gt; 强制转换为普通 &lt;code&gt;char *&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9c63ef9e66f9b18bee95bf1723987dfd5d11a58f" translate="yes" xml:space="preserve">
          <source>Warn whenever a pointer is cast such that the required alignment of the target is increased. For example, warn if a &lt;code&gt;char *&lt;/code&gt; is cast to an &lt;code&gt;int *&lt;/code&gt; on machines where integers can only be accessed at two- or four-byte boundaries.</source>
          <target state="translated">在投射指针时发出警告，以增加目标的所需对齐方式。例如，警告在将整数只能在两字节或四字节边界访问的计算机上，如果将 &lt;code&gt;char *&lt;/code&gt; 强制转换为 &lt;code&gt;int *&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ef7fc95a5c54b16b21f690678e6321f329b8c724" translate="yes" xml:space="preserve">
          <source>Warn whenever a pointer is cast such that the required alignment of the target is increased. For example, warn if a &lt;code&gt;char *&lt;/code&gt; is cast to an &lt;code&gt;int *&lt;/code&gt; regardless of the target machine.</source>
          <target state="translated">在投射指针时发出警告，以增加目标的所需对齐方式。例如，警告是否将 &lt;code&gt;char *&lt;/code&gt; 强制转换为 &lt;code&gt;int *&lt;/code&gt; ,而与目标计算机无关。</target>
        </trans-unit>
        <trans-unit id="f17199fabf0d6edb5e8d9320d9584ee47f24d757" translate="yes" xml:space="preserve">
          <source>Warn whenever a statement computes a result that is explicitly not used. To suppress this warning cast the unused expression to &lt;code&gt;void&lt;/code&gt;. This includes an expression-statement or the left-hand side of a comma expression that contains no side effects. For example, an expression such as &lt;code&gt;x[i,j]&lt;/code&gt; causes a warning, while &lt;code&gt;x[(void)i,j]&lt;/code&gt; does not.</source>
          <target state="translated">每当语句计算显式未使用的结果时发出警告。为了消除此警告，请将未使用的表达式强制转换为 &lt;code&gt;void&lt;/code&gt; 。这包括表达式语句或不包含副作用的逗号表达式的左侧。例如，诸如 &lt;code&gt;x[i,j]&lt;/code&gt; 的表达式会引起警告，而 &lt;code&gt;x[(void)i,j]&lt;/code&gt; 则不会。</target>
        </trans-unit>
        <trans-unit id="e9ed26895683fb69327818c06ae2df9969d8a9f1" translate="yes" xml:space="preserve">
          <source>Warn whenever a static function is declared but not defined or a non-inline static function is unused. This warning is enabled by</source>
          <target state="translated">当一个静态函数被声明但未被定义或一个非内联静态函数未被使用时发出警告。这个警告是由</target>
        </trans-unit>
        <trans-unit id="682ef1b46b2728b71e94a89b2010ca06ceb12456" translate="yes" xml:space="preserve">
          <source>Warn whenever an Objective-C assignment is being intercepted by the garbage collector.</source>
          <target state="translated">每当一个Objective-C任务被垃圾收集器拦截时,就发出警告。</target>
        </trans-unit>
        <trans-unit id="5f84fae543b9699e7c995142a54b65f353ecae8d" translate="yes" xml:space="preserve">
          <source>Warn whenever an object is defined whose size exceeds &lt;var&gt;byte-size&lt;/var&gt;.</source>
          <target state="translated">在定义大小超过 &lt;var&gt;byte-size&lt;/var&gt; 的对象时发出警告。</target>
        </trans-unit>
        <trans-unit id="ea0ef30fd9bda293d78af05a20b81fc75c62d811" translate="yes" xml:space="preserve">
          <source>Warning Options</source>
          <target state="translated">警告选项</target>
        </trans-unit>
        <trans-unit id="986ddebcadb3fa23d23a5b826b014fe8f130debb" translate="yes" xml:space="preserve">
          <source>Warning about assigning a signed value to an unsigned variable.</source>
          <target state="translated">警告将一个有符号的值分配给一个无符号变量。</target>
        </trans-unit>
        <trans-unit id="e9e66e7d69e59ab3855b10526f1e61fff27e7187" translate="yes" xml:space="preserve">
          <source>Warning about using an expression whose type is signed as a shift count.</source>
          <target state="translated">警告使用类型为符号的表达式作为移位计数。</target>
        </trans-unit>
        <trans-unit id="418dee8a9f5c36e0b14dc254214604e6561b0bc6" translate="yes" xml:space="preserve">
          <source>Warning when a non-void function value is ignored.</source>
          <target state="translated">当一个非空函数值被忽略时发出警告。</target>
        </trans-unit>
        <trans-unit id="6016747760c907aec70fe12b355cb7c681c5c0db" translate="yes" xml:space="preserve">
          <source>Warnings are diagnostic messages that report constructions that are not inherently erroneous but that are risky or suggest there may have been an error.</source>
          <target state="translated">警告是诊断信息,它报告的结构本身没有错误,但有风险,或暗示可能有错误。</target>
        </trans-unit>
        <trans-unit id="0dd982bec66fde4c74400108fddfd5cb384244af" translate="yes" xml:space="preserve">
          <source>Warnings may indicate danger points where you should check to make sure that your program really does what you intend; or the use of obsolete features; or the use of nonstandard features of GNU C or C++. Many warnings are issued only if you ask for them, with one of the</source>
          <target state="translated">警告可能表示您应该检查的危险点,以确保您的程序真的能实现您的意图;或者使用了过时的功能;或者使用了GNU C或C++的非标准功能。许多警告只有在您要求的情况下才会发出,其中一个是</target>
        </trans-unit>
        <trans-unit id="774110e2ee23eade4be0249d185f9d3f531f461a" translate="yes" xml:space="preserve">
          <source>Weak pointers are supported through a new type character specifier represented by the &amp;lsquo;</source>
          <target state="translated">弱指针通过以'表示的新型字符说明符来支持</target>
        </trans-unit>
        <trans-unit id="833f5330898dc442fd023004015464621900910e" translate="yes" xml:space="preserve">
          <source>What constitutes an access to a volatile object.</source>
          <target state="translated">什么构成对易失性对象的访问。</target>
        </trans-unit>
        <trans-unit id="29d1640b5550a77154368675da8078c8ec35026f" translate="yes" xml:space="preserve">
          <source>What constitutes an access to an object that has volatile-qualified type (C90 6.5.3, C99 and C11 6.7.3).</source>
          <target state="translated">什么是对具有易失性限定类型的对象的访问(C90 6.5.3、C99和C11 6.7.3)。</target>
        </trans-unit>
        <trans-unit id="769bb19e615b7f8e2809e5882e2d05a18f57a531" translate="yes" xml:space="preserve">
          <source>When</source>
          <target state="translated">When</target>
        </trans-unit>
        <trans-unit id="73ab9ffb5b7365deaf1034842a4b9d0c5073a1f3" translate="yes" xml:space="preserve">
          <source>When G++ and another C++ compiler conform to the same C++ ABI, but the implementations of the Standard C++ Library that they normally use do not follow the same ABI for the Standard C++ Library, object files built with those compilers can be used in the same program only if they use the same C++ library. This requires specifying the location of the C++ library header files when invoking the compiler whose usual library is not being used. The location of GCC&amp;rsquo;s C++ header files depends on how the GCC build was configured, but can be seen by using the G++</source>
          <target state="translated">当G ++和另一个C ++编译器遵循相同的C ++ ABI，但它们通常使用的Standard C ++库的实现不遵循Standard C ++库的ABI时，可以在同一程序中使用由这些编译器构建的目标文件。仅当它们使用相同的C ++库时。在调用未使用其常用库的编译器时，这需要指定C ++库头文件的位置。GCC的C ++头文件的位置取决于如何配置GCC构建，但可以通过使用G ++看到</target>
        </trans-unit>
        <trans-unit id="25b318e1653c6b6dda339c34d9872ce5b96093ce" translate="yes" xml:space="preserve">
          <source>When IPA-CP determines that a cloning candidate would make the index of an array access known, it adds a bonus of</source>
          <target state="translated">当IPA-CP确定一个克隆候选者会使一个数组访问的索引为人所知时,它就会增加一个额外的</target>
        </trans-unit>
        <trans-unit id="3fbfba2a71ffaa54417e4d873e33ec3bbc19a7e4" translate="yes" xml:space="preserve">
          <source>When IPA-CP determines that a cloning candidate would make the number of iterations of a loop known, it adds a bonus of</source>
          <target state="translated">当IPA-CP确定一个克隆候选者会使一个循环的迭代次数已知时,它就会增加一个额外的</target>
        </trans-unit>
        <trans-unit id="0b074b049fd7c7f48c6da34e1272635cac52856d" translate="yes" xml:space="preserve">
          <source>When a base class is virtual, only one subobject of the base class belongs to each full object. Also, the constructors and destructors are invoked only once, and called from the most-derived class. However, such objects behave unspecified when being assigned. For example:</source>
          <target state="translated">当一个基类是虚拟的时,基类的每个完整对象只属于一个子对象。而且,构造函数和析构函数只被调用一次,并从最派生的类中调用。但是,这样的对象在被赋值时的行为是不明确的。比如说</target>
        </trans-unit>
        <trans-unit id="67be4830f6cdd00004022ad6db1aaae5471c2589" translate="yes" xml:space="preserve">
          <source>When a class has static data members, it is not enough to &lt;em&gt;declare&lt;/em&gt; the static member; you must also &lt;em&gt;define&lt;/em&gt; it. For example:</source>
          <target state="translated">当类具有静态数据成员时，仅&lt;em&gt;声明&lt;/em&gt;静态成员是不够的。您还必须&lt;em&gt;定义&lt;/em&gt;它。例如：</target>
        </trans-unit>
        <trans-unit id="d927dabaa85a2fec9fca96ddc5e395f531b27e67" translate="yes" xml:space="preserve">
          <source>When a division strategy has not been specified the default strategy is selected based on the current target. For SH2A the default strategy is to use the &lt;code&gt;divs&lt;/code&gt; and &lt;code&gt;divu&lt;/code&gt; instructions instead of library function calls.</source>
          <target state="translated">未指定划分策略时，将根据当前目标选择默认策略。对于SH2A，默认策略是使用 &lt;code&gt;divs&lt;/code&gt; 和 &lt;code&gt;divu&lt;/code&gt; 指令而不是库函数调用。</target>
        </trans-unit>
        <trans-unit id="0a75adb840378c14dc9a655e4aba002e527f73a2" translate="yes" xml:space="preserve">
          <source>When a file is compiled with</source>
          <target state="translated">当一个文件被编译成</target>
        </trans-unit>
        <trans-unit id="0cd90cdfd69b208961a20a866e993339b4b5f840" translate="yes" xml:space="preserve">
          <source>When a function is both inline and &lt;code&gt;static&lt;/code&gt;, if all calls to the function are integrated into the caller, and the function&amp;rsquo;s address is never used, then the function&amp;rsquo;s own assembler code is never referenced. In this case, GCC does not actually output assembler code for the function, unless you specify the option</source>
          <target state="translated">当函数既是内联函数又是 &lt;code&gt;static&lt;/code&gt; 函数时，如果将对函数的所有调用都集成到调用程序中，并且永远不会使用函数的地址，那么就永远不会引用函数自己的汇编代码。在这种情况下，除非指定选项，否则GCC实际上不会为该函数输出汇编代码。</target>
        </trans-unit>
        <trans-unit id="678a6d73dd419ef65f8fe5fe05b5c39fad57f23c" translate="yes" xml:space="preserve">
          <source>When a list constructor stores the &lt;code&gt;begin&lt;/code&gt; pointer from the &lt;code&gt;initializer_list&lt;/code&gt; argument, this doesn&amp;rsquo;t extend the lifetime of the array, so if a class variable is constructed from a temporary &lt;code&gt;initializer_list&lt;/code&gt;, the pointer is left dangling by the end of the variable declaration statement.</source>
          <target state="translated">当列表构造函数存储来自 &lt;code&gt;initializer_list&lt;/code&gt; 参数的 &lt;code&gt;begin&lt;/code&gt; 指针时，这不会延长数组的生存期，因此，如果从临时 &lt;code&gt;initializer_list&lt;/code&gt; 构造类变量，则该指针将在变量声明语句的末尾悬空。</target>
        </trans-unit>
        <trans-unit id="00f542136163060bf7630e6166417f9110c29edb" translate="yes" xml:space="preserve">
          <source>When a lock acquire fails, it is required for good performance to abort the transaction quickly. This can be done with a &lt;code&gt;_mm_pause&lt;/code&gt;.</source>
          <target state="translated">当锁获取失败时，需要良好的性能才能快速中止事务。这可以通过 &lt;code&gt;_mm_pause&lt;/code&gt; 完成。</target>
        </trans-unit>
        <trans-unit id="8f7415b6c4bfc3b8582a73345fc35229f98c2491" translate="yes" xml:space="preserve">
          <source>When a type involving an ABI tag is used as the type of a variable or return type of a function where that tag is not already present in the signature of the function, the tag is automatically applied to the variable or function.</source>
          <target state="translated">当涉及ABI标签的类型被用作变量的类型或函数的返回类型,而该标签还没有出现在函数的签名中时,该标签会自动应用到变量或函数中。</target>
        </trans-unit>
        <trans-unit id="6dad89b8cb0d35ea0fd46b863a5983c0e559d839" translate="yes" xml:space="preserve">
          <source>When added to an interrupt handler with the M32C port, causes the prologue and epilogue to use bank switching to preserve the registers rather than saving them on the stack.</source>
          <target state="translated">当添加到M32C端口的中断处理程序中时,会使序幕和尾声使用bank switching来保存寄存器,而不是将它们保存在堆栈中。</target>
        </trans-unit>
        <trans-unit id="f8717fcf897c9e046dd756abc024e5f7d502ccd8" translate="yes" xml:space="preserve">
          <source>When an &lt;code&gt;initializer_list&lt;/code&gt; variable is assigned from a brace-enclosed initializer list, the temporary array created for the right side of the assignment only lives until the end of the full-expression, so at the next statement the &lt;code&gt;initializer_list&lt;/code&gt; variable has a dangling pointer.</source>
          <target state="translated">当从大括号括起来的初始化程序列表中分配了 &lt;code&gt;initializer_list&lt;/code&gt; 变量时，为该赋值右侧创建的临时数组将一直保留到全表达式结束为止，因此在下一条语句中， &lt;code&gt;initializer_list&lt;/code&gt; 变量具有一个悬空指针。</target>
        </trans-unit>
        <trans-unit id="f82873b6d13dce7be3f4357951354ec118469799" translate="yes" xml:space="preserve">
          <source>When an error message refers to a specialization of a function template, the compiler normally prints the signature of the template followed by the template arguments and any typedefs or typenames in the signature (e.g. &lt;code&gt;void f(T) [with T = int]&lt;/code&gt; rather than &lt;code&gt;void f(int)&lt;/code&gt;) so that it&amp;rsquo;s clear which template is involved. When an error message refers to a specialization of a class template, the compiler omits any template arguments that match the default template arguments for that template. If either of these behaviors make it harder to understand the error message rather than easier, you can use</source>
          <target state="translated">当错误消息提到函数模板的特殊化时，编译器通常会打印模板的签名，然后打印模板参数以及签名中的任何typedef或类型名（例如 &lt;code&gt;void f(T) [with T = int]&lt;/code&gt; 而不是 &lt;code&gt;void f(int)&lt;/code&gt; ），以便清楚地涉及到哪个模板。当错误消息指向类模板的特殊化时，编译器将忽略与该模板的默认模板参数匹配的所有模板参数。如果这些行为中的任何一种都使理解错误消息变得更加困难而不是更加容易，则可以使用</target>
        </trans-unit>
        <trans-unit id="4a0782c5484322bfadd7fe79666979332dd01a38" translate="yes" xml:space="preserve">
          <source>When an executable is run in a massive parallel environment, it is recommended to save profile to different folders. That can be done with variables in &lt;var&gt;path&lt;/var&gt; that are exported during run-time:</source>
          <target state="translated">在大规模并行环境中运行可执行文件时，建议将配置文件保存到其他文件夹中。这可以通过在运行时导出的 &lt;var&gt;path&lt;/var&gt; 中的变量来完成：</target>
        </trans-unit>
        <trans-unit id="d2c4f8c7d6b26eab60b9d9e100920ff031a8aaf4" translate="yes" xml:space="preserve">
          <source>When an inline function is not &lt;code&gt;static&lt;/code&gt;, then the compiler must assume that there may be calls from other source files; since a global symbol can be defined only once in any program, the function must not be defined in the other source files, so the calls therein cannot be integrated. Therefore, a non-&lt;code&gt;static&lt;/code&gt; inline function is always compiled on its own in the usual fashion.</source>
          <target state="translated">当内联函数不是 &lt;code&gt;static&lt;/code&gt; 时，则编译器必须假定可能存在其他源文件的调用；由于全局符号只能在任何程序中定义一次，因此该函数不得在其他源文件中定义，因此无法集成其中的调用。因此，非 &lt;code&gt;static&lt;/code&gt; 内联函数总是以通常的方式自行编译。</target>
        </trans-unit>
        <trans-unit id="b338539fbe33495121e46c5661e5bc16f008a3e0" translate="yes" xml:space="preserve">
          <source>When an insn has two alternative constraint-patterns.</source>
          <target state="translated">当一个inn有两个可供选择的约束模式时。</target>
        </trans-unit>
        <trans-unit id="4cbff59218859bab09c21980b2597e3d4c6294f2" translate="yes" xml:space="preserve">
          <source>When an unrecognized warning option is requested (e.g.,</source>
          <target state="translated">当要求使用未识别的警告选项时(例如:)</target>
        </trans-unit>
        <trans-unit id="537d39cd77a447e897b80dd75224237bdc4e0719" translate="yes" xml:space="preserve">
          <source>When applicable, enable (disable) the generation of 4-operand &lt;code&gt;madd.s&lt;/code&gt;, &lt;code&gt;madd.d&lt;/code&gt; and related instructions. Enabled by default.</source>
          <target state="translated">如果适用，启用（禁用）4-operand &lt;code&gt;madd.s&lt;/code&gt; ， &lt;code&gt;madd.d&lt;/code&gt; 和相关指令的生成。默认启用。</target>
        </trans-unit>
        <trans-unit id="4c26cdde33cc06bf31aab1a7bf63c69c29f00704" translate="yes" xml:space="preserve">
          <source>When applicable, enable (disable) the generation of &lt;code&gt;lwxc1&lt;/code&gt;, &lt;code&gt;swxc1&lt;/code&gt;, &lt;code&gt;ldxc1&lt;/code&gt;, &lt;code&gt;sdxc1&lt;/code&gt; instructions. Enabled by default.</source>
          <target state="translated">如果适用，启用（禁用） &lt;code&gt;lwxc1&lt;/code&gt; ， &lt;code&gt;swxc1&lt;/code&gt; ， &lt;code&gt;ldxc1&lt;/code&gt; ， &lt;code&gt;sdxc1&lt;/code&gt; 指令的生成。默认启用。</target>
        </trans-unit>
        <trans-unit id="7184e15e5684528f54729686834cdf00887683be" translate="yes" xml:space="preserve">
          <source>When applied to C++ classes, the attribute marks defined non-inlined member functions and static data members as exports. Static consts initialized in-class are not marked unless they are also defined out-of-class.</source>
          <target state="translated">当应用于C++类时,该属性将定义的非内联成员函数和静态数据成员标记为导出。除非类内初始化的静态常量也被定义为类外,否则不会被标记。</target>
        </trans-unit>
        <trans-unit id="7d9feaafaf97b8f7fe46d8b6b598964809d89431" translate="yes" xml:space="preserve">
          <source>When applied to C++ classes, the attribute marks non-inlined member functions and static data members as imports. However, the attribute is ignored for virtual methods to allow creation of vtables using thunks.</source>
          <target state="translated">当应用于C++类时,该属性将非内联成员函数和静态数据成员标记为导入。但是,对于虚拟方法来说,该属性被忽略,以允许使用thunks创建vtables。</target>
        </trans-unit>
        <trans-unit id="bbf180b63c03eb34a3aba311a968f02d5135ed3e" translate="yes" xml:space="preserve">
          <source>When applied to a member function of a C++ class template, the attribute also means that the function is instantiated if the class itself is instantiated.</source>
          <target state="translated">当应用于一个C++类模板的成员函数时,该属性也意味着如果类本身被实例化,则该函数被实例化。</target>
        </trans-unit>
        <trans-unit id="cabddb6e825602d843a117fb734ca3aff3112d1a" translate="yes" xml:space="preserve">
          <source>When applied to a static data member of a C++ class template, the attribute also means that the member is instantiated if the class itself is instantiated.</source>
          <target state="translated">当应用于C++类模板的静态数据成员时,该属性也意味着如果类本身被实例化,则该成员被实例化。</target>
        </trans-unit>
        <trans-unit id="59f0e6f1d8d71dac3701cee27ca42c33aae99e5f" translate="yes" xml:space="preserve">
          <source>When attached to a &lt;code&gt;union&lt;/code&gt; or a &lt;code&gt;struct&lt;/code&gt;, this attribute sets the storage order, aka endianness, of the scalar fields of the type, as well as the array fields whose component is scalar. The supported endiannesses are &lt;code&gt;big-endian&lt;/code&gt; and &lt;code&gt;little-endian&lt;/code&gt;. The attribute has no effects on fields which are themselves a &lt;code&gt;union&lt;/code&gt;, a &lt;code&gt;struct&lt;/code&gt; or an array whose component is a &lt;code&gt;union&lt;/code&gt; or a &lt;code&gt;struct&lt;/code&gt;, and it is possible for these fields to have a different scalar storage order than the enclosing type.</source>
          <target state="translated">当附加到并 &lt;code&gt;union&lt;/code&gt; 或 &lt;code&gt;struct&lt;/code&gt; ，此属性设置类型的标量字段以及组成标量的数组字段的存储顺序（即字节顺序）。支持的字节序为 &lt;code&gt;big-endian&lt;/code&gt; 和 &lt;code&gt;little-endian&lt;/code&gt; 。该属性对本身是 &lt;code&gt;union&lt;/code&gt; ， &lt;code&gt;struct&lt;/code&gt; 或数组（其组成部分是 &lt;code&gt;union&lt;/code&gt; 或 &lt;code&gt;struct&lt;/code&gt; )的字段没有影响，这些字段可能具有与封闭类型不同的标量存储顺序。</target>
        </trans-unit>
        <trans-unit id="5370f9b64efe5c0ffe3fe15dfade832ac9be14df" translate="yes" xml:space="preserve">
          <source>When attached to a type (including a &lt;code&gt;union&lt;/code&gt; or a &lt;code&gt;struct&lt;/code&gt;), this attribute means that variables of that type are meant to appear possibly unused. GCC does not produce a warning for any variables of that type, even if the variable appears to do nothing. This is often the case with lock or thread classes, which are usually defined and then not referenced, but contain constructors and destructors that have nontrivial bookkeeping functions.</source>
          <target state="translated">当附加到类型（包括并 &lt;code&gt;union&lt;/code&gt; 或 &lt;code&gt;struct&lt;/code&gt; ）时，此属性意味着该类型的变量可能未使用。即使该变量似乎无作用，GCC也不会对任何类型的变量产生警告。锁或线程类通常是这种情况，它们通常被定义然后不被引用，但是包含具有非平凡簿记功能的构造函数和析构函数。</target>
        </trans-unit>
        <trans-unit id="607b6b9a753f4dcb8aa6e646687045411231d9db" translate="yes" xml:space="preserve">
          <source>When attached to an &lt;code&gt;enum&lt;/code&gt; definition, the &lt;code&gt;packed&lt;/code&gt; attribute indicates that the smallest integral type should be used. Specifying the</source>
          <target state="translated">当附加到 &lt;code&gt;enum&lt;/code&gt; 定义时， &lt;code&gt;packed&lt;/code&gt; 属性指示应使用最小的整数类型。指定</target>
        </trans-unit>
        <trans-unit id="3212c36750452527c536dd1eddfa9228aa24bc41" translate="yes" xml:space="preserve">
          <source>When branch is predicted to be taken with probability lower than this threshold (in percent), then it is considered well predictable.</source>
          <target state="translated">当预测采取分支的概率低于这个阈值(单位:%)时,则认为其可预测性良好。</target>
        </trans-unit>
        <trans-unit id="f92818ac1f6c1cf9820bd7ad2460f0b770895e75" translate="yes" xml:space="preserve">
          <source>When branch probabilities are given, include those of unconditional branches. Unconditional branches are normally not interesting.</source>
          <target state="translated">当给出分支概率时,包括无条件分支的概率。无条件分支通常不感兴趣。</target>
        </trans-unit>
        <trans-unit id="0ae42b215512052c2cadc23355c16f5c5dd443cf" translate="yes" xml:space="preserve">
          <source>When calling routines that are not aware of the reservation, be cautious if those routines call back into code which uses them. As an example, if you call the system library version of &lt;code&gt;qsort&lt;/code&gt;, it may clobber your registers during execution, but (if you have selected appropriate registers) it will restore them before returning. However it will &lt;em&gt;not&lt;/em&gt; restore them before calling &lt;code&gt;qsort&lt;/code&gt;&amp;rsquo;s comparison function. As a result, global values will not reliably be available to the comparison function unless the &lt;code&gt;qsort&lt;/code&gt; function itself is rebuilt.</source>
          <target state="translated">当调用不知道保留的例程时，请谨慎使用这些例程，如果它们被调用回使用它们的代码。例如，如果您调用系统库版本的 &lt;code&gt;qsort&lt;/code&gt; ，它可能会在执行过程中破坏您的寄存器，但是（如果您选择了适当的寄存器）它将在返回之前恢复它们。但是，在调用 &lt;code&gt;qsort&lt;/code&gt; 的比较函数之前，它&lt;em&gt;不会&lt;/em&gt;还原它们。结果，除非重新构建 &lt;code&gt;qsort&lt;/code&gt; 函数本身，否则全局值将无法可靠地用于比较函数。</target>
        </trans-unit>
        <trans-unit id="6ce64a23abaaddcfa5831e43098fffe47be4e539" translate="yes" xml:space="preserve">
          <source>When casting from pointer to integer and back again, the resulting pointer must reference the same object as the original pointer, otherwise the behavior is undefined. That is, one may not use integer arithmetic to avoid the undefined behavior of pointer arithmetic as proscribed in C99 and C11 6.5.6/8.</source>
          <target state="translated">当从指针转为整数再转回来时,产生的指针必须引用与原始指针相同的对象,否则行为是未定义的,也就是说,不能使用整数运算来避免C99和C11 6.5.6/8中规定的指针运算的未定义行为。也就是说,不能使用整数运算来避免C99和C11 6.5.6/8中规定的指针运算的未定义行为。</target>
        </trans-unit>
        <trans-unit id="4a6770a95cb182eb94130a66a137214e2a89e539" translate="yes" xml:space="preserve">
          <source>When code compiled with</source>
          <target state="translated">当代码用</target>
        </trans-unit>
        <trans-unit id="2694a5fd19642dc29f67abfd4afa306ec8d78457" translate="yes" xml:space="preserve">
          <source>When compiling C++, warn about the deprecated conversion from string literals to &lt;code&gt;char *&lt;/code&gt;. This warning is enabled by default for C++ programs.</source>
          <target state="translated">在编译C ++时，警告从字符串文字到 &lt;code&gt;char *&lt;/code&gt; 的弃用转换。默认情况下，C ++程序启用此警告。</target>
        </trans-unit>
        <trans-unit id="b58e8f8f470141f0b7d65fa2b304a55713649c15" translate="yes" xml:space="preserve">
          <source>When compiling C, give string constants the type &lt;code&gt;const
char[&lt;var&gt;length&lt;/var&gt;]&lt;/code&gt; so that copying the address of one into a non-&lt;code&gt;const&lt;/code&gt;&lt;code&gt;char *&lt;/code&gt; pointer produces a warning. These warnings help you find at compile time code that can try to write into a string constant, but only if you have been very careful about using &lt;code&gt;const&lt;/code&gt; in declarations and prototypes. Otherwise, it is just a nuisance. This is why we did not make</source>
          <target state="translated">在编译C时，给字符串常量一个 &lt;code&gt;const char[&lt;var&gt;length&lt;/var&gt;]&lt;/code&gt; 类型的值，以便将一个地址复制到一个非 &lt;code&gt;const&lt;/code&gt; &lt;code&gt;char *&lt;/code&gt; 指针中会产生警告。这些警告可以帮助您在编译时找到可以尝试写入字符串常量的代码，但前提是您非常谨慎地在声明和原型中使用 &lt;code&gt;const&lt;/code&gt; 。否则，这只是个麻烦。这就是为什么我们没有做</target>
        </trans-unit>
        <trans-unit id="cd87062968fd1ca6c15b5a9b85fba86d8a5ccfc2" translate="yes" xml:space="preserve">
          <source>When compiling code for single processor systems, it is generally safe to use &lt;code&gt;synci&lt;/code&gt;. However, on many multi-core (SMP) systems, it does not invalidate the instruction caches on all cores and may lead to undefined behavior.</source>
          <target state="translated">为单处理器系统编译代码时，通常可以安全地使用 &lt;code&gt;synci&lt;/code&gt; 。但是，在许多多核（SMP）系统上，它不会使所有内核上的指令高速缓存失效，并且可能导致不确定的行为。</target>
        </trans-unit>
        <trans-unit id="7c10c0020a810534faa4083bee532dbff326c982" translate="yes" xml:space="preserve">
          <source>When compiling files containing mixed MIPS16 and non-MIPS16 code, the preprocessor symbol &lt;code&gt;__mips16&lt;/code&gt; reflects the setting on the command line, not that within individual functions. Mixed MIPS16 and non-MIPS16 code may interact badly with some GCC extensions such as &lt;code&gt;__builtin_apply&lt;/code&gt; (see &lt;a href=&quot;constructing-calls#Constructing-Calls&quot;&gt;Constructing Calls&lt;/a&gt;).</source>
          <target state="translated">当编译包含MIPS16和非MIPS16混合代码的文件时，预处理器符号 &lt;code&gt;__mips16&lt;/code&gt; 反映了命令行上的设置，而不是单个函数中的设置。混合的MIPS16和非MIPS16代码可能与某些GCC扩展（例如 &lt;code&gt;__builtin_apply&lt;/code&gt; ）交互不良（请参阅&lt;a href=&quot;constructing-calls#Constructing-Calls&quot;&gt;构造调用&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="60deff215e04b72131ce496d836442fb3376a9ed" translate="yes" xml:space="preserve">
          <source>When compiling files containing mixed microMIPS and non-microMIPS code, the preprocessor symbol &lt;code&gt;__mips_micromips&lt;/code&gt; reflects the setting on the command line, not that within individual functions. Mixed microMIPS and non-microMIPS code may interact badly with some GCC extensions such as &lt;code&gt;__builtin_apply&lt;/code&gt; (see &lt;a href=&quot;constructing-calls#Constructing-Calls&quot;&gt;Constructing Calls&lt;/a&gt;).</source>
          <target state="translated">当编译包含混合的microMIPS和非microMIPS代码的文件时，预处理器符号 &lt;code&gt;__mips_micromips&lt;/code&gt; 反映了命令行上的设置，而不是单个函数中的设置。混合的microMIPS和非microMIPS代码可能与某些GCC扩展（例如 &lt;code&gt;__builtin_apply&lt;/code&gt; ）严重相互作用（请参阅&lt;a href=&quot;constructing-calls#Constructing-Calls&quot;&gt;构造调用&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="3b21353af5c286cba09d175d058607a98bab9646" translate="yes" xml:space="preserve">
          <source>When compiling files residing in directory</source>
          <target state="translated">编译目录下的文件时</target>
        </trans-unit>
        <trans-unit id="fb1c662fe80e2a5daa84889e9b20929141a1f39e" translate="yes" xml:space="preserve">
          <source>When compiling for Nios II, the following options are allowed:</source>
          <target state="translated">在为 Nios II 编译时,允许使用以下选项。</target>
        </trans-unit>
        <trans-unit id="47a745ce02eda6e5b8af0283813b8d27ac893e5a" translate="yes" xml:space="preserve">
          <source>When compiling for the NeXT runtime, the compiler ordinarily replaces calls to &lt;code&gt;objc_getClass(&quot;&amp;hellip;&quot;)&lt;/code&gt; (when the name of the class is known at compile time) with static class references that get initialized at load time, which improves run-time performance. Specifying the</source>
          <target state="translated">在为NeXT运行时进行编译时，编译器通常 &lt;code&gt;objc_getClass(&quot;&amp;hellip;&quot;)&lt;/code&gt; 调用（在编译时知道该类的名称）替换为在加载时初始化的静态类引用，从而提高了运行时性能。指定</target>
        </trans-unit>
        <trans-unit id="7acd9f9e9a72745fc09c352c58646de2d43a5f5e" translate="yes" xml:space="preserve">
          <source>When compiling functions that return &lt;code id=&quot;index-float-as-function-value-type&quot;&gt;float&lt;/code&gt;, PCC converts it to a double. GCC actually returns a &lt;code&gt;float&lt;/code&gt;. If you are concerned with PCC compatibility, you should declare your functions to return &lt;code&gt;double&lt;/code&gt;; you might as well say what you mean.</source>
          <target state="translated">编译返回 &lt;code id=&quot;index-float-as-function-value-type&quot;&gt;float&lt;/code&gt; 的函数时，PCC会将其转换为double。GCC实际上返回一个 &lt;code&gt;float&lt;/code&gt; 。如果您关心PCC的兼容性，则应声明函数以返回 &lt;code&gt;double&lt;/code&gt; ；您最好说出您的意思。</target>
        </trans-unit>
        <trans-unit id="d5db0043541449725fbfb6c49474d3dea04ea8f6" translate="yes" xml:space="preserve">
          <source>When compiling functions that return structures or unions, GCC output code normally uses a method different from that used on most versions of Unix. As a result, code compiled with GCC cannot call a structure-returning function compiled with PCC, and vice versa.</source>
          <target state="translated">当编译返回结构或联合的函数时,GCC输出的代码通常使用与大多数Unix版本不同的方法。因此,用GCC编译的代码不能调用用PCC编译的返回结构函数,反之亦然。</target>
        </trans-unit>
        <trans-unit id="42802196182be1a26f30e794627d93f753ad7250" translate="yes" xml:space="preserve">
          <source>When compiling using the AAPCS ABI (or a variant of it) then valid values for the argument are &lt;code&gt;&quot;aapcs&quot;&lt;/code&gt; and &lt;code&gt;&quot;aapcs-vfp&quot;&lt;/code&gt;. In order to use a variant other than &lt;code&gt;&quot;aapcs&quot;&lt;/code&gt; then the compiler must be permitted to use the appropriate co-processor registers (i.e., the VFP registers must be available in order to use &lt;code&gt;&quot;aapcs-vfp&quot;&lt;/code&gt;). For example,</source>
          <target state="translated">使用AAPCS ABI（或其变体）进行编译时，参数的有效值为 &lt;code&gt;&quot;aapcs&quot;&lt;/code&gt; 和 &lt;code&gt;&quot;aapcs-vfp&quot;&lt;/code&gt; 。为了使用 &lt;code&gt;&quot;aapcs&quot;&lt;/code&gt; 以外的其他变体，必须允许编译器使用适当的协处理器寄存器（即，VFP寄存器必须可用才能使用 &lt;code&gt;&quot;aapcs-vfp&quot;&lt;/code&gt; ）。例如，</target>
        </trans-unit>
        <trans-unit id="6f269c2c80bc0b6cd00bdccd1a4ad395d3f1e317" translate="yes" xml:space="preserve">
          <source>When compiling, this option enables</source>
          <target state="translated">编译时,该选项可启用</target>
        </trans-unit>
        <trans-unit id="315f128e4ce30c782f28bfb565507bc8d99b6552" translate="yes" xml:space="preserve">
          <source>When doing debugging dumps (see</source>
          <target state="translated">在做调试转储时(见</target>
        </trans-unit>
        <trans-unit id="dce8f6e7dddb2ada38853381a56083f98e91e173" translate="yes" xml:space="preserve">
          <source>When doing debugging dumps, suppress address output. This makes it more feasible to use diff on debugging dumps for compiler invocations with different compiler binaries and/or different text / bss / data / heap / stack / dso start locations.</source>
          <target state="translated">在做调试转储时,抑制地址输出。这使得对不同编译器二进制文件和/或不同文本/bss/数据/堆/栈/dso起始位置的编译器调用,在调试转储时使用diff更加可行。</target>
        </trans-unit>
        <trans-unit id="5cb94325a71b749cb8e5d8b4041d1d7a131d0f11" translate="yes" xml:space="preserve">
          <source>When doing debugging dumps, suppress instruction numbers and address output. This makes it more feasible to use diff on debugging dumps for compiler invocations with different options, in particular with and without</source>
          <target state="translated">在做调试转储时,抑制指令号和地址输出。这使得在调试转储上使用diff对不同选项的编译器调用更加可行,特别是在有和无</target>
        </trans-unit>
        <trans-unit id="6a3f0b550d9291ec66729667f3f7ca83fd2f4d8b" translate="yes" xml:space="preserve">
          <source>When dumping RTL, print the RTL in slim (condensed) form instead of the default LISP-like representation.</source>
          <target state="translated">当转储RTL时,以纤细(浓缩)的形式打印RTL,而不是默认的类似LISP的表示方式。</target>
        </trans-unit>
        <trans-unit id="74301d6d6862291588f10bf29b45b4967ce13d2f" translate="yes" xml:space="preserve">
          <source>When dumping front-end intermediate representations, inhibit dumping of members of a scope or body of a function merely because that scope has been reached. Only dump such items when they are directly reachable by some other path.</source>
          <target state="translated">在转储前端中间表示时,禁止仅仅因为已经到达了函数的作用域或主体的成员而转储。只有当这些项目可以通过其他路径直接到达时,才会转储。</target>
        </trans-unit>
        <trans-unit id="f945883699fc9792ba3afeb26f744a7773586ecc" translate="yes" xml:space="preserve">
          <source>When dumping pretty-printed trees, this option inhibits dumping the bodies of control structures.</source>
          <target state="translated">在倾倒漂亮的印刷树时,该选项抑制倾倒控制结构的主体。</target>
        </trans-unit>
        <trans-unit id="6fc1555729570caee324aa057f7026754c896f3e" translate="yes" xml:space="preserve">
          <source>When enabled, perform interprocedural bitwise constant propagation. This flag is enabled by default at</source>
          <target state="translated">启用时,执行程序间位常数传播。该标志默认在</target>
        </trans-unit>
        <trans-unit id="bf82f180e269afc159377aa835c2b162d457aecd" translate="yes" xml:space="preserve">
          <source>When enabled, perform interprocedural propagation of value ranges. This flag is enabled by default at</source>
          <target state="translated">启用时,执行程序间的值范围传播。该标志默认在</target>
        </trans-unit>
        <trans-unit id="5a6db9d98413978e8951a290a39c293b6dbce38a" translate="yes" xml:space="preserve">
          <source>When enabled, the compiler ensures that the generated code does not contain CSYNC or SSYNC instructions too soon after conditional branches. If this option is used, &lt;code&gt;__WORKAROUND_SPECULATIVE_SYNCS&lt;/code&gt; is defined.</source>
          <target state="translated">启用后，编译器将确保在条件分支之后过早地生成的代码不包含CSYNC或SSYNC指令。如果使用此选项， &lt;code&gt;__WORKAROUND_SPECULATIVE_SYNCS&lt;/code&gt; 将定义__WORKAROUND_SPECULATIVE_SYNCS。</target>
        </trans-unit>
        <trans-unit id="5cabeafae5f5d65fb548beb5767960c04d9a35b8" translate="yes" xml:space="preserve">
          <source>When enabled, the compiler ensures that the generated code does not contain speculative loads after jump instructions. If this option is used, &lt;code&gt;__WORKAROUND_SPECULATIVE_LOADS&lt;/code&gt; is defined.</source>
          <target state="translated">启用后，编译器将确保生成的代码在跳转指令之后不包含推测性负载。如果使用此选项，则定义 &lt;code&gt;__WORKAROUND_SPECULATIVE_LOADS&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="177174ed256fb1fc5ac1ff6e0a69365e95922527" translate="yes" xml:space="preserve">
          <source>When enabled, the compiler is free to take advantage of the knowledge that the entire program fits into the low 64k of memory.</source>
          <target state="translated">当启用时,编译器可以自由地利用整个程序适合低64k内存的知识。</target>
        </trans-unit>
        <trans-unit id="f1158beec156e6a8ecff5cd217a56a66d53e95d9" translate="yes" xml:space="preserve">
          <source>When enabled, this option states that a range reduction step is not needed when performing complex division. Also, there is no checking whether the result of a complex multiplication or division is &lt;code&gt;NaN
+ I*NaN&lt;/code&gt;, with an attempt to rescue the situation in that case. The default is</source>
          <target state="translated">启用后，此选项表明执行复杂除法时不需要范围缩小步骤。此外，也没有检查复数乘法或除法的结果是否为 &lt;code&gt;NaN + I*NaN&lt;/code&gt; ，从而试图挽救这种情况。默认是</target>
        </trans-unit>
        <trans-unit id="5c41cf550423b99323059ab9102f75c243821bb0" translate="yes" xml:space="preserve">
          <source>When estimated performance improvement of caller + callee runtime exceeds this threshold (in percent), the function can be inlined regardless of the limit on</source>
          <target state="translated">当估计的调用者+被调用者运行时间的性能提升超过这个阈值(百分比)时,函数可以内联,而不考虑对该函数的限制。</target>
        </trans-unit>
        <trans-unit id="0546498041d4ec0ccfc5ce36934cf27647842a41" translate="yes" xml:space="preserve">
          <source>When generating PIC code, do or don&amp;rsquo;t allow the use of PLTs. Ignored for non-PIC. The default is</source>
          <target state="translated">生成PIC代码时，允许或不允许使用PLT。对于非PIC忽略。默认是</target>
        </trans-unit>
        <trans-unit id="511bcbbf68adbe04ec79792863471cde6b014863" translate="yes" xml:space="preserve">
          <source>When generating a function that returns a pointer, return the pointer in both &lt;code&gt;a0&lt;/code&gt; and &lt;code&gt;d0&lt;/code&gt;. Otherwise, the pointer is returned only in &lt;code&gt;a0&lt;/code&gt;, and attempts to call such functions without a prototype result in errors. Note that this option is on by default; use</source>
          <target state="translated">生成返回指针的函数时，请同时在 &lt;code&gt;a0&lt;/code&gt; 和 &lt;code&gt;d0&lt;/code&gt; 中返回指针。否则，仅在 &lt;code&gt;a0&lt;/code&gt; 中返回指针，并且在没有原型的情况下尝试调用此类函数会导致错误。请注意，此选项默认情况下处于启用状态。用</target>
        </trans-unit>
        <trans-unit id="dd2029500976920c4504065ca16226229e4f7c22" translate="yes" xml:space="preserve">
          <source>When generating assembler output use a syntax that is compatible with Renesas&amp;rsquo;s AS100 assembler. This syntax can also be handled by the GAS assembler, but it has some restrictions so it is not generated by default.</source>
          <target state="translated">生成汇编器输出时，请使用与瑞萨AS100汇编器兼容的语法。GAS汇编程序也可以处理此语法，但是它有一些限制，因此默认情况下不会生成。</target>
        </trans-unit>
        <trans-unit id="34010eecdc80bda1996b3453a5842eca5948c6ad" translate="yes" xml:space="preserve">
          <source>When generating code for shared libraries,</source>
          <target state="translated">为共享库生成代码时。</target>
        </trans-unit>
        <trans-unit id="ee57ba558572772d8e7d0fd148c855146cc649ba" translate="yes" xml:space="preserve">
          <source>When generating code for the x86-64 architecture with SSE extensions disabled,</source>
          <target state="translated">在禁用SSE扩展的情况下生成x86-64架构的代码时。</target>
        </trans-unit>
        <trans-unit id="8c85713507dce4f24637fdca8c9dd42ecd242b3b" translate="yes" xml:space="preserve">
          <source>When generating position-independent code for ColdFire, generate code that works if the GOT has more than 8192 entries. This code is larger and slower than code generated without this option. On M680x0 processors, this option is not needed;</source>
          <target state="translated">在为ColdFire生成与位置无关的代码时,如果GOT的条目超过8192个,则生成的代码可以使用。这个代码比没有这个选项的情况下生成的代码要大、要慢。在M680x0处理器上,不需要这个选项。</target>
        </trans-unit>
        <trans-unit id="ddb821edf6cd4d8eabb391980c4305801a4dd35b" translate="yes" xml:space="preserve">
          <source>When generating position-independent code, emit function calls using the Global Offset Table instead of the Procedure Linkage Table.</source>
          <target state="translated">生成与位置无关的代码时,使用全局偏移表而不是过程连接表发出函数调用。</target>
        </trans-unit>
        <trans-unit id="58318867846389e3f00483e730d9cdc45f04b844" translate="yes" xml:space="preserve">
          <source>When implementing patterns for these built-in functions, the memory order parameter can be ignored as long as the pattern implements the most restrictive &lt;code&gt;__ATOMIC_SEQ_CST&lt;/code&gt; memory order. Any of the other memory orders execute correctly with this memory order but they may not execute as efficiently as they could with a more appropriate implementation of the relaxed requirements.</source>
          <target state="translated">在为这些内置函数实现模式时，只要该模式实现了限制性 &lt;code&gt;__ATOMIC_SEQ_CST&lt;/code&gt; 内存顺序，就可以忽略内存顺序参数。其他任何一个内存命令都可以使用此内存命令正确执行，但是它们的执行效率可能不如宽松要求的更适当实现那样有效。</target>
        </trans-unit>
        <trans-unit id="e9af953ed4f40761c964f415712e4b881671dfb2" translate="yes" xml:space="preserve">
          <source>When linking a big-endian image select between BE8 and BE32 formats. The option has no effect for little-endian images and is ignored. The default is dependent on the selected target architecture. For ARMv6 and later architectures the default is BE8, for older architectures the default is BE32. BE32 format has been deprecated by ARM.</source>
          <target state="translated">当链接大字段图像时,可在BE8和BE32格式之间选择。该选项对小迭代图像没有影响,会被忽略。默认值取决于所选的目标架构。对于ARMv6和更高版本的架构,默认为BE8,对于旧架构,默认为BE32。BE32 格式已被 ARM 废弃。</target>
        </trans-unit>
        <trans-unit id="920068058745daad77bac4500e9d9b0ac2200c05" translate="yes" xml:space="preserve">
          <source>When making copies of thread-local variables in a transaction, this parameter specifies the size in bytes after which variables are saved with the logging functions as opposed to save/restore code sequence pairs. This option only applies when using</source>
          <target state="translated">当在事务中复制线程本地变量时,该参数指定了与保存/恢复代码序列对相比,变量与日志函数保存后的字节大小。这个选项只适用于在使用</target>
        </trans-unit>
        <trans-unit id="20fd5eb54a80ab92bcf13e1600542aa28ff5d13b" translate="yes" xml:space="preserve">
          <source>When mangling a function type with function-cv-qualifiers, the un-qualified function type was incorrectly treated as a substitution candidate.</source>
          <target state="translated">当使用function-cv-限定符对函数类型进行混淆时,未限定的函数类型被错误地处理为替换候选人。</target>
        </trans-unit>
        <trans-unit id="6e16f38a870c014c4bf05a4ba66aff0d8f015c53" translate="yes" xml:space="preserve">
          <source>When not using an &lt;var&gt;asmSymbolicName&lt;/var&gt;, use the (zero-based) position of the operand in the list of operands in the assembler template. For example if there are three output operands, use &amp;lsquo;</source>
          <target state="translated">不使用 &lt;var&gt;asmSymbolicName&lt;/var&gt; 时，请在汇编器模板的操作数列表中使用操作数（从零开始）的位置。例如，如果有三个输出操作数，则使用'</target>
        </trans-unit>
        <trans-unit id="f7f108470bcf6e6b304f3263a3362bac9bf0990f" translate="yes" xml:space="preserve">
          <source>When not using an &lt;var&gt;asmSymbolicName&lt;/var&gt;, use the (zero-based) position of the operand in the list of operands in the assembler template. For example if there are two output operands and three inputs, use &amp;lsquo;</source>
          <target state="translated">不使用 &lt;var&gt;asmSymbolicName&lt;/var&gt; 时，请在汇编器模板的操作数列表中使用操作数（从零开始）的位置。例如，如果有两个输出操作数和三个输入，则使用'</target>
        </trans-unit>
        <trans-unit id="9ab94547949a5e4c3215ae42df94303adb7916f4" translate="yes" xml:space="preserve">
          <source>When optimizing for size (using</source>
          <target state="translated">当优化尺寸时(使用</target>
        </trans-unit>
        <trans-unit id="97bc78492cc0f58dc12735620055de6a1daa4843" translate="yes" xml:space="preserve">
          <source>When passed this option, GCC produces a dynamic library instead of an executable when linking, using the Darwin</source>
          <target state="translated">当通过这个选项时,GCC会在链接时产生一个动态库,而不是可执行文件,使用Darwin的</target>
        </trans-unit>
        <trans-unit id="f2411855bc2157c02295a4d406d5bb74f6ed2885" translate="yes" xml:space="preserve">
          <source>When performing a stack backtrace, code can inspect the value of &lt;code&gt;pc&lt;/code&gt; stored at &lt;code&gt;fp + 0&lt;/code&gt;. If the trace function then looks at location &lt;code&gt;pc - 12&lt;/code&gt; and the top 8 bits are set, then we know that there is a function name embedded immediately preceding this location and has length &lt;code&gt;((pc[-3]) &amp;amp; 0xff000000)&lt;/code&gt;.</source>
          <target state="translated">执行堆栈回溯时，代码可以检查存储在 &lt;code&gt;fp + 0&lt;/code&gt; 处的 &lt;code&gt;pc&lt;/code&gt; 的值。如果跟踪函数然后查看位置 &lt;code&gt;pc - 12&lt;/code&gt; 并设置了前8位，则我们知道在该位置之前嵌入了一个函数名，其长度为 &lt;code&gt;((pc[-3]) &amp;amp; 0xff000000)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f597a9e8b63ff1121b0842bcdb388264d1b3c5ff" translate="yes" xml:space="preserve">
          <source>When performing branch target register load optimization, don&amp;rsquo;t reuse branch target registers within any basic block.</source>
          <target state="translated">执行分支目标寄存器负载优化时，请勿在任何基本块内重用分支目标寄存器。</target>
        </trans-unit>
        <trans-unit id="9c01537a52102dd8946fc5982208fe491740f320" translate="yes" xml:space="preserve">
          <source>When pipelining loops during selective scheduling, also pipeline outer loops. This option has no effect unless</source>
          <target state="translated">当在选择性调度期间对循环进行流水线处理时,也会对外循环进行流水线处理。这个选项没有效果,除非</target>
        </trans-unit>
        <trans-unit id="1280e31b08d3497c525b6d236dd8d4d87c36c837" translate="yes" xml:space="preserve">
          <source>When preprocessing files residing in directory</source>
          <target state="translated">当预处理目录下的文件时。</target>
        </trans-unit>
        <trans-unit id="18019b7cb63563a2a1382c41adbfffdfc589112f" translate="yes" xml:space="preserve">
          <source>When preprocessing, do not shorten system header paths with canonicalization.</source>
          <target state="translated">预处理时,不要用规范化缩短系统头路径。</target>
        </trans-unit>
        <trans-unit id="2727468a8d8ea18794592843d12955ca0144b622" translate="yes" xml:space="preserve">
          <source>When preprocessing, handle directives, but do not expand macros.</source>
          <target state="translated">预处理时,处理指令,但不要展开宏。</target>
        </trans-unit>
        <trans-unit id="bb09a7ade548f20e19021a30661ff4362be9b030" translate="yes" xml:space="preserve">
          <source>When printing percentages, 0% and 100% are only printed when the values are &lt;em&gt;exactly&lt;/em&gt; 0% and 100% respectively. Other values which would conventionally be rounded to 0% or 100% are instead printed as the nearest non-boundary value.</source>
          <target state="translated">当打印百分比时，仅当值分别&lt;em&gt;恰好为&lt;/em&gt; 0％和100％时才打印0％和100％。取而代之的是将通常四舍五入为0％或100％的其他值打印为最接近的非边界值。</target>
        </trans-unit>
        <trans-unit id="814abd66e9c273530f2d56ad0a0cd6cc246294fd" translate="yes" xml:space="preserve">
          <source>When producing the final binary, GCC only applies link-time optimizations to those files that contain bytecode. Therefore, you can mix and match object files and libraries with GIMPLE bytecodes and final object code. GCC automatically selects which files to optimize in LTO mode and which files to link without further processing.</source>
          <target state="translated">在生成最终的二进制文件时,GCC 只对那些包含字节码的文件进行链接时间优化。因此,您可以将对象文件和库与 GIMPLE 字节码和最终的对象代码进行混合和匹配。GCC 会自动选择哪些文件要在 LTO 模式下进行优化,哪些文件无需进一步处理即可链接。</target>
        </trans-unit>
        <trans-unit id="b96765bcbef2cdc563af58e2e7b14e500edcf025" translate="yes" xml:space="preserve">
          <source>When profile feedback is available (see</source>
          <target state="translated">当配置文件反馈可用时(见</target>
        </trans-unit>
        <trans-unit id="21ec7c5b40c9ae6af5acdf4a048ad5c0d3bce4e5" translate="yes" xml:space="preserve">
          <source>When profile feedback is available, via</source>
          <target state="translated">当个人资料反馈可用时,通过</target>
        </trans-unit>
        <trans-unit id="2f272057236473f0d19fb086d6183a38dfbd5bad" translate="yes" xml:space="preserve">
          <source>When reading data from memory in sizes shorter than 64 bits, use (do not use) zero-extending load instructions by default, rather than sign-extending ones.</source>
          <target state="translated">当从内存中读取尺寸小于64位的数据时,默认使用(不要使用)零扩展加载指令,而不是符号扩展指令。</target>
        </trans-unit>
        <trans-unit id="f96511339203319c533d1e5bb317204cec489683" translate="yes" xml:space="preserve">
          <source>When scheduling after register allocation, use superblock scheduling. This allows motion across basic block boundaries, resulting in faster schedules. This option is experimental, as not all machine descriptions used by GCC model the CPU closely enough to avoid unreliable results from the algorithm.</source>
          <target state="translated">在寄存器分配后进行调度时,使用超级块调度。这样可以跨越基本块边界进行运动,从而实现更快的调度。这个选项是试验性的,因为并不是所有GCC使用的机器描述都对CPU进行了足够紧密的建模,以避免算法的结果不可靠。</target>
        </trans-unit>
        <trans-unit id="711283accf977e698dde3a25dc400a61116947e3" translate="yes" xml:space="preserve">
          <source>When selecting a register, choose one that is normally saved and restored by function calls on your machine. This ensures that code which is unaware of this reservation (such as library routines) will restore it before returning.</source>
          <target state="translated">当选择一个寄存器时,选择一个通常由机器上的函数调用保存和恢复的寄存器。这样可以确保不知道这个保留的代码(如库例程)在返回之前将其还原。</target>
        </trans-unit>
        <trans-unit id="935d1b181ddc0bd3e6f68299a5752f8a09580e76" translate="yes" xml:space="preserve">
          <source>When selecting this option, be aware that the standard library headers do not obey all of these guidelines; use &amp;lsquo;</source>
          <target state="translated">选择此选项时，请注意，标准库标头未遵守所有这些准则；请参阅《标准指南》。用 '</target>
        </trans-unit>
        <trans-unit id="30da98647c378a61b9ead522311838c64d97cf26" translate="yes" xml:space="preserve">
          <source>When supplied with a 128-bit first argument, the &lt;code&gt;scalar_insert_exp&lt;/code&gt; built-in function returns a quad-precision ieee floating point value. The sign bit of the result is copied from the most significant bit of the &lt;code&gt;significand&lt;/code&gt; argument. The significand and exponent components of the result are composed of the least significant 15 bits of the &lt;code&gt;exponent&lt;/code&gt; argument and the least significant 112 bits of the &lt;code&gt;significand&lt;/code&gt; argument respectively.</source>
          <target state="translated">当提供有128位第一个参数时， &lt;code&gt;scalar_insert_exp&lt;/code&gt; 内置函数将返回四精度ieee浮点值。从 &lt;code&gt;significand&lt;/code&gt; 参数的最高有效位复制结果的符号位。结果的有效数和指数部件由所述的至少显著15个比特的 &lt;code&gt;exponent&lt;/code&gt; 参数和所述的至少显著112位 &lt;code&gt;significand&lt;/code&gt; 分别论点。</target>
        </trans-unit>
        <trans-unit id="55f3e3f1e06a97818ce0ffb33865599309fb29ae" translate="yes" xml:space="preserve">
          <source>When the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82085de4f0e784cd78a6493470847db57c3b16cf" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;g++&lt;/code&gt; program is used to link a C++ program, it normally automatically links against</source>
          <target state="translated">使用 &lt;code&gt;g++&lt;/code&gt; 程序链接C ++程序时，通常会自动链接到</target>
        </trans-unit>
        <trans-unit id="9d1f5e646a4aa7fceb07c0207db652e826f24dbb" translate="yes" xml:space="preserve">
          <source>When the address-of operator is applied to a thread-local variable, it is evaluated at run time and returns the address of the current thread&amp;rsquo;s instance of that variable. An address so obtained may be used by any thread. When a thread terminates, any pointers to thread-local variables in that thread become invalid.</source>
          <target state="translated">将address-of运算符应用于线程局部变量时，将在运行时对其求值，并返回该变量的当前线程实例的地址。这样获得的地址可以被任何线程使用。当线程终止时，指向该线程中线程局部变量的所有指针均无效。</target>
        </trans-unit>
        <trans-unit id="0b679da0a8fd732962aaaa73513d25a32daf4775" translate="yes" xml:space="preserve">
          <source>When the compiled program exits it saves this data to a file called</source>
          <target state="translated">当编译后的程序退出时,它将这些数据保存到一个名为</target>
        </trans-unit>
        <trans-unit id="ba14367decd6810d3de98e37ab796a274e5fcb83" translate="yes" xml:space="preserve">
          <source>When the compiler creates the statically allocated constant string object, the &lt;code&gt;c_string&lt;/code&gt; field will be filled by the compiler with the string; the &lt;code&gt;length&lt;/code&gt; field will be filled by the compiler with the string length; the &lt;code&gt;isa&lt;/code&gt; pointer will be filled with &lt;code&gt;NULL&lt;/code&gt; by the compiler, and it will later be fixed up automatically at runtime by the GNU Objective-C runtime library to point to the class which was set by the</source>
          <target state="translated">当编译器创建静态分配的常量字符串对象时，编译器将使用字符串填充 &lt;code&gt;c_string&lt;/code&gt; 字段；该 &lt;code&gt;length&lt;/code&gt; 字段将通过与字符串的长度，编译器被填充; 该 &lt;code&gt;isa&lt;/code&gt; 指针将被填充有 &lt;code&gt;NULL&lt;/code&gt; 由编译器由GNU Objective-C运行库，并且稍后将被自动固定起来在运行时指向这是由设置类</target>
        </trans-unit>
        <trans-unit id="75d541d9bedf275908dc64ccacf78982bc497338" translate="yes" xml:space="preserve">
          <source>When the compiler fixes up the operands to satisfy the constraints, it needs to know which operands are read by the instruction and which are written by it. &amp;lsquo;</source>
          <target state="translated">当编译器修正操作数以满足约束条件时，它需要知道哪些操作数由指令读取，哪些操作数由指令写入。'</target>
        </trans-unit>
        <trans-unit id="fe9038c60a954d7fa872648aae2a7292450a7e26" translate="yes" xml:space="preserve">
          <source>When the compiler selects the registers to use to represent the input operands, it does not use any of the clobbered registers (see &lt;a href=&quot;#Clobbers-and-Scratch-Registers&quot;&gt;Clobbers and Scratch Registers&lt;/a&gt;).</source>
          <target state="translated">当编译器选择用于表示输入操作数的寄存器时，它不使用任何被破坏的寄存器（请参阅&lt;a href=&quot;#Clobbers-and-Scratch-Registers&quot;&gt;Clobbers和Scratch寄存器&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="fc0664d7c952e60ae422d980b70454766a66b5fe" translate="yes" xml:space="preserve">
          <source>When the compiler selects the registers to use to represent the output operands, it does not use any of the clobbered registers (see &lt;a href=&quot;#Clobbers-and-Scratch-Registers&quot;&gt;Clobbers and Scratch Registers&lt;/a&gt;).</source>
          <target state="translated">当编译器选择用于表示输出操作数的寄存器时，它不使用任何被破坏的寄存器（请参阅&lt;a href=&quot;#Clobbers-and-Scratch-Registers&quot;&gt;Clobbers和Scratch寄存器&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="9af3756142eed3c562da1e3a657ce9b62976062a" translate="yes" xml:space="preserve">
          <source>When the compiler selects which registers to use to represent input and output operands, it does not use any of the clobbered registers. As a result, clobbered registers are available for any use in the assembler code.</source>
          <target state="translated">当编译器选择使用哪个寄存器来表示输入和输出操作数时,它不会使用任何一个被抢占的寄存器。因此,clobbered寄存器可以在汇编器代码中任意使用。</target>
        </trans-unit>
        <trans-unit id="c3d75a61bee977e603b0ea8873c523597d8f39fa" translate="yes" xml:space="preserve">
          <source>When the garbage collector is used, the objects are allocated using the so-called typed memory allocation mechanism available in the Boehm-Demers-Weiser collector. This mode requires precise information on where pointers are located inside objects. This information is computed once per class, immediately after the class has been initialized.</source>
          <target state="translated">当使用垃圾收集器时,使用Boehm-Demers-Weiser收集器中可用的所谓类型化内存分配机制来分配对象。这种模式需要精确的信息,说明指针在对象内部的位置。这个信息每个类计算一次,在类被初始化后立即计算。</target>
        </trans-unit>
        <trans-unit id="ce04df43b58d0607f55d930a3e25d2b0c0d86fd3" translate="yes" xml:space="preserve">
          <source>When the instructions are enabled GCC defines the C preprocessor symbol &lt;code&gt;__RX_ALLOW_STRING_INSNS__&lt;/code&gt;, otherwise it defines the symbol &lt;code&gt;__RX_DISALLOW_STRING_INSNS__&lt;/code&gt;.</source>
          <target state="translated">启用指令后，GCC定义C预处理程序符号 &lt;code&gt;__RX_ALLOW_STRING_INSNS__&lt;/code&gt; ，否则定义符号 &lt;code&gt;__RX_DISALLOW_STRING_INSNS__&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="237034d602a7895e4b871df52b8d8208437c1b5e" translate="yes" xml:space="preserve">
          <source>When the option</source>
          <target state="translated">当该选项</target>
        </trans-unit>
        <trans-unit id="f59a2028d7f7059c14cfbb4f7cac2e937416cda2" translate="yes" xml:space="preserve">
          <source>When the value of a decimal floating type cannot be represented in the integer type to which it is being converted, the result is undefined rather than the result value specified by the draft technical report.</source>
          <target state="translated">当小数浮动类型的值不能用所转换的整数类型来表示时,结果是未定义的,而不是技术报告草案规定的结果值。</target>
        </trans-unit>
        <trans-unit id="43dfcc6f2fffee0a3a2515bfa1a37e71e51242de" translate="yes" xml:space="preserve">
          <source>When this flag is set, the macros &lt;code&gt;__pic__&lt;/code&gt; and &lt;code&gt;__PIC__&lt;/code&gt; are defined to 1.</source>
          <target state="translated">设置此标志后，宏 &lt;code&gt;__pic__&lt;/code&gt; 和 &lt;code&gt;__PIC__&lt;/code&gt; 被定义为1。</target>
        </trans-unit>
        <trans-unit id="44c57deb401735025dc176c7c63debf58618c2fc" translate="yes" xml:space="preserve">
          <source>When this flag is set, the macros &lt;code&gt;__pic__&lt;/code&gt; and &lt;code&gt;__PIC__&lt;/code&gt; are defined to 2.</source>
          <target state="translated">设置此标志后，宏 &lt;code&gt;__pic__&lt;/code&gt; 和 &lt;code&gt;__PIC__&lt;/code&gt; 被定义为2。</target>
        </trans-unit>
        <trans-unit id="4a1317c4b8d2af979d94b62164c9d7ecd9184a36" translate="yes" xml:space="preserve">
          <source>When this option is enabled, GCC inserts &lt;code&gt;MEMW&lt;/code&gt; instructions before &lt;code&gt;volatile&lt;/code&gt; memory references to guarantee sequential consistency. The default is</source>
          <target state="translated">启用此选项后，GCC会在 &lt;code&gt;volatile&lt;/code&gt; 存储器引用之前插入 &lt;code&gt;MEMW&lt;/code&gt; 指令，以确保顺序一致性。默认是</target>
        </trans-unit>
        <trans-unit id="4f8fad713a34ff4dd67014e2a8d65e863876b686" translate="yes" xml:space="preserve">
          <source>When this option is enabled, GCC instructs the assembler to automatically align instructions to reduce branch penalties at the expense of some code density. The assembler attempts to widen density instructions to align branch targets and the instructions following call instructions. If there are not enough preceding safe density instructions to align a target, no widening is performed. The default is</source>
          <target state="translated">当启用该选项时,GCC指示汇编器自动对齐指令,以牺牲一些代码密度来减少分支惩罚。汇编器尝试拓宽密度指令以对齐分支目标和调用指令之后的指令。如果前面没有足够的安全密度指令来对齐目标,则不执行加宽。默认情况是</target>
        </trans-unit>
        <trans-unit id="6aace4cd615149f89dea8fcd082fb55d9878fa43" translate="yes" xml:space="preserve">
          <source>When this option is enabled, GCC instructs the assembler to translate direct calls to indirect calls unless it can determine that the target of a direct call is in the range allowed by the call instruction. This translation typically occurs for calls to functions in other source files. Specifically, the assembler translates a direct &lt;code&gt;CALL&lt;/code&gt; instruction into an &lt;code&gt;L32R&lt;/code&gt; followed by a &lt;code&gt;CALLX&lt;/code&gt; instruction. The default is</source>
          <target state="translated">启用此选项后，GCC会指示汇编程序将直接调用转换为间接调用，除非它可以确定直接调用的目标在调用指令允许的范围内。这种转换通常发生在对其他源文件中的函数的调用上。具体而言，汇编程序将直接 &lt;code&gt;CALL&lt;/code&gt; 指令转换为 &lt;code&gt;L32R&lt;/code&gt; ,然后转换为 &lt;code&gt;CALLX&lt;/code&gt; 指令。默认是</target>
        </trans-unit>
        <trans-unit id="932f419fffb4962ea09a2d68b7d48f6dd70fbe9a" translate="yes" xml:space="preserve">
          <source>When this option is not used, GCC optimizes for the processor specified by</source>
          <target state="translated">当不使用该选项时,GCC会对由</target>
        </trans-unit>
        <trans-unit id="d8e1351858aa322f0a55264f24813443d8991eb4" translate="yes" xml:space="preserve">
          <source>When this option is passed to the compiler driver, it causes the &lt;em&gt;first&lt;/em&gt; compilation to be skipped, which makes it useful for little other than debugging the compiler proper.</source>
          <target state="translated">当将此选项传递给编译器驱动程序时，它会导致第&lt;em&gt;一个&lt;/em&gt;编译被跳过，这使其除调试适当的编译器外几乎无用。</target>
        </trans-unit>
        <trans-unit id="9e23f54eaa8f9101922e305be1e7015dd6fc78fe" translate="yes" xml:space="preserve">
          <source>When this version of the ABI is enabled the C preprocessor symbol &lt;code&gt;__V850_GCC_ABI__&lt;/code&gt; is defined.</source>
          <target state="translated">启用此版本的ABI后，将定义C预处理器符号 &lt;code&gt;__V850_GCC_ABI__&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2a3a63e7e68adaacd52d22d0fef6ef4e247546c7" translate="yes" xml:space="preserve">
          <source>When this version of the ABI is enabled the C preprocessor symbol &lt;code&gt;__V850_RH850_ABI__&lt;/code&gt; is defined.</source>
          <target state="translated">启用此版本的ABI后，将定义C预处理器符号 &lt;code&gt;__V850_RH850_ABI__&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ffcbc5063df93d534e3fd1a9be3948f3d608cc53" translate="yes" xml:space="preserve">
          <source>When trying to fill delay slots, the maximum number of instructions to consider when searching for a block with valid live register information. Increasing this arbitrarily chosen value means more aggressive optimization, increasing the compilation time. This parameter should be removed when the delay slot code is rewritten to maintain the control-flow graph.</source>
          <target state="translated">当试图填补延迟槽时,搜索具有有效实时寄存器信息的块时,要考虑的最大指令数。增加这个任意选择的值意味着更积极的优化,增加编译时间。当重写延迟槽代码以保持控制流图时,应删除该参数。</target>
        </trans-unit>
        <trans-unit id="ca1100086e04f30d15e50b0b6ef7fef7de69d02a" translate="yes" xml:space="preserve">
          <source>When used as part of the register variable extension, see &lt;a href=&quot;explicit-register-variables#Explicit-Register-Variables&quot;&gt;Explicit Register Variables&lt;/a&gt;.</source>
          <target state="translated">当用作寄存器变量扩展的一部分时，请参见&lt;a href=&quot;explicit-register-variables#Explicit-Register-Variables&quot;&gt;显式寄存器变量&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="106a6c1a466d5af73cd467f48ab954141e8dae1a" translate="yes" xml:space="preserve">
          <source>When used as the pattern of a pack expansion within a template definition, expands to a template argument pack containing integers from &lt;code&gt;0&lt;/code&gt; to &lt;code&gt;length-1&lt;/code&gt;. This is provided for efficient implementation of &lt;code&gt;std::make_integer_sequence&lt;/code&gt;.</source>
          <target state="translated">当用作模板定义中的包扩展的模式时，扩展为包含从 &lt;code&gt;0&lt;/code&gt; 到 &lt;code&gt;length-1&lt;/code&gt; 的整数的模板参数包。这是为了有效实现 &lt;code&gt;std::make_integer_sequence&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="780fee7b38bbbc14d6460730fc730c12ac99a32c" translate="yes" xml:space="preserve">
          <source>When used from GCC without</source>
          <target state="translated">当从GCC使用时,不需要</target>
        </trans-unit>
        <trans-unit id="0e9e8833e240e4ed56f0fb1a36eb014753411cc2" translate="yes" xml:space="preserve">
          <source>When used in combination with</source>
          <target state="translated">当结合使用</target>
        </trans-unit>
        <trans-unit id="4ec2dc1132b93e0ccc417d346f716fa8317dce1d" translate="yes" xml:space="preserve">
          <source>When used in combination with the</source>
          <target state="translated">当结合使用</target>
        </trans-unit>
        <trans-unit id="7e7b12188944613e3ecc2fd00ed8b819fb8ad2ca" translate="yes" xml:space="preserve">
          <source>When used in conjunction with</source>
          <target state="translated">当与</target>
        </trans-unit>
        <trans-unit id="49cb60ae0da0fc7302708101bdf54d1b69871514" translate="yes" xml:space="preserve">
          <source>When used on a struct, or struct member, the &lt;code&gt;aligned&lt;/code&gt; attribute can only increase the alignment; in order to decrease it, the &lt;code&gt;packed&lt;/code&gt; attribute must be specified as well. When used as part of a typedef, the &lt;code&gt;aligned&lt;/code&gt; attribute can both increase and decrease alignment, and specifying the &lt;code&gt;packed&lt;/code&gt; attribute generates a warning.</source>
          <target state="translated">当在结构或结构成员上使用时， &lt;code&gt;aligned&lt;/code&gt; 属性只能增加对齐方式。为了减少它，还必须指定 &lt;code&gt;packed&lt;/code&gt; 属性。当用作typedef的一部分时， &lt;code&gt;aligned&lt;/code&gt; 属性既可以增加也可以减少对齐，并且指定 &lt;code&gt;packed&lt;/code&gt; 属性将生成警告。</target>
        </trans-unit>
        <trans-unit id="9e5e1c3d3ae3ca589eb9e745a2edd3f0de6b0b04" translate="yes" xml:space="preserve">
          <source>When used together with &lt;code&gt;interrupt_handler&lt;/code&gt;, &lt;code&gt;exception_handler&lt;/code&gt; or &lt;code&gt;nmi_handler&lt;/code&gt;, code is generated to load the stack pointer from the USP register in the function prologue.</source>
          <target state="translated">当与 &lt;code&gt;interrupt_handler&lt;/code&gt; ， &lt;code&gt;exception_handler&lt;/code&gt; 或 &lt;code&gt;nmi_handler&lt;/code&gt; 一起使用时，将生成代码以从函数序言中的USP寄存器加载堆栈指针。</target>
        </trans-unit>
        <trans-unit id="0fa555d9978b74bbd46ce823e883fc5dc96ece10" translate="yes" xml:space="preserve">
          <source>When used together,</source>
          <target state="translated">一起使用时。</target>
        </trans-unit>
        <trans-unit id="dd9e3fff8e9f3de600aeb120c0ac434ae6e8fd7f" translate="yes" xml:space="preserve">
          <source>When used with</source>
          <target state="translated">搭配使用时</target>
        </trans-unit>
        <trans-unit id="92cecb0d71e3d06f0f2ee726aec0670791ccea60" translate="yes" xml:space="preserve">
          <source>When used with GNU ld version 2.8 or later on an ELF system such as GNU/Linux or Solaris 2, or on Microsoft Windows, duplicate copies of these constructs will be discarded at link time. This is known as COMDAT support.</source>
          <target state="translated">当在GNU/Linux或Solaris 2等ELF系统上使用GNU ld 2.8或更高版本时,或在微软Windows系统上使用时,这些构造的重复拷贝将在链接时被丢弃。这就是所谓的COMDAT支持。</target>
        </trans-unit>
        <trans-unit id="3e4af787046ae7ade38ea86db68f50943f9b708f" translate="yes" xml:space="preserve">
          <source>When used with the driver options</source>
          <target state="translated">当与驱动程序选项一起使用时</target>
        </trans-unit>
        <trans-unit id="c37b9bb49622ff1b2c39fa2ca14e91b87c1c3e6e" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;__vector&lt;/code&gt; instead of &lt;code&gt;vector&lt;/code&gt;; for example,</source>
          <target state="translated">当使用 &lt;code&gt;__vector&lt;/code&gt; 而不是 &lt;code&gt;vector&lt;/code&gt; 时；例如，</target>
        </trans-unit>
        <trans-unit id="6b2bcfc1c3c9cde870c3782ea70e6faf69a223bd" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;gcov&lt;/code&gt;, you must first compile your program with a special GCC option &amp;lsquo;</source>
          <target state="translated">使用 &lt;code&gt;gcov&lt;/code&gt; 时，必须首先使用特殊的GCC选项&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="813ae21e068ea720242cb9123e52a1c2bfc86b90" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;vector&lt;/code&gt; in keyword-and-predefine mode; for example,</source>
          <target state="translated">在关键字和预定义模式下使用 &lt;code&gt;vector&lt;/code&gt; 时；例如，</target>
        </trans-unit>
        <trans-unit id="5643f8856029d91e0b316af45e590b017e03b023" translate="yes" xml:space="preserve">
          <source>When using &lt;var&gt;&amp;ndash;preserve-paths&lt;/var&gt;, gcov uses the full pathname of the source files to create an output filename. This can lead to long filenames that can overflow filesystem limits. This option creates names of the form</source>
          <target state="translated">使用 &lt;var&gt;&amp;ndash;preserve-paths&lt;/var&gt; 时，gcov使用源文件的完整路径名来创建输出文件名。这会导致文件名过长，从而导致文件系统限制溢出。此选项创建表单的名称</target>
        </trans-unit>
        <trans-unit id="86e384abcdbbd0ac6dda953fb252a5fa852b9cab" translate="yes" xml:space="preserve">
          <source>When using DWARF Version 4 or higher, type DIEs can be put into their own &lt;code&gt;.debug_types&lt;/code&gt; section instead of making them part of the &lt;code&gt;.debug_info&lt;/code&gt; section. It is more efficient to put them in a separate comdat section since the linker can then remove duplicates. But not all DWARF consumers support &lt;code&gt;.debug_types&lt;/code&gt; sections yet and on some objects &lt;code&gt;.debug_types&lt;/code&gt; produces larger instead of smaller debugging information.</source>
          <target state="translated">使用DWARF版本4或更高版本时，可以将类型的 &lt;code&gt;.debug_types&lt;/code&gt; 放在其自己的.debug_types部分中，而不必将其作为 &lt;code&gt;.debug_info&lt;/code&gt; 部分的一部分。将它们放在单独的comdat部分中会更有效，因为链接器随后可以删除重复项。但是，并非所有DWARF使用者都支持 &lt;code&gt;.debug_types&lt;/code&gt; 节，并且在某些对象上 &lt;code&gt;.debug_types&lt;/code&gt; 会产生较大的调试信息，而不是较小的调试信息。</target>
        </trans-unit>
        <trans-unit id="7fb27cfc2abe0d594f6b16d8710a96a8aeba9d2c" translate="yes" xml:space="preserve">
          <source>When using a reference to volatile, G++ does not treat equivalent expressions as accesses to volatiles, but instead issues a warning that no volatile is accessed. The rationale for this is that otherwise it becomes difficult to determine where volatile access occur, and not possible to ignore the return value from functions returning volatile references. Again, if you wish to force a read, cast the reference to an rvalue.</source>
          <target state="translated">当使用对volatile的引用时,G++不会将等价表达式视为对volatile的访问,而是发出没有访问volatile的警告。这样做的理由是,否则就很难确定volatile访问发生在哪里,也不可能忽略返回volatile引用的函数的返回值。同样,如果想强制读取,可以将引用投为r值。</target>
        </trans-unit>
        <trans-unit id="ffb95a64a466d2bd4851566c5320aa64fa40418e" translate="yes" xml:space="preserve">
          <source>When using a type that occupies multiple registers, such as &lt;code&gt;long
long&lt;/code&gt; on a 32-bit system, split the registers apart and allocate them independently. This normally generates better code for those types, but may make debugging more difficult.</source>
          <target state="translated">当使用占用多个寄存器的类型时（例如在32位系统上为 &lt;code&gt;long long&lt;/code&gt; ，请将寄存器分开并独立分配。这通常会为这些类型生成更好的代码，但可能会使调试更加困难。</target>
        </trans-unit>
        <trans-unit id="f38f792e072335436a4ef70d8d149701336de24f" translate="yes" xml:space="preserve">
          <source>When using any of the register constraints (&lt;code&gt;wa&lt;/code&gt;, &lt;code&gt;wd&lt;/code&gt;, &lt;code&gt;wf&lt;/code&gt;, &lt;code&gt;wg&lt;/code&gt;, &lt;code&gt;wh&lt;/code&gt;, &lt;code&gt;wi&lt;/code&gt;, &lt;code&gt;wj&lt;/code&gt;, &lt;code&gt;wk&lt;/code&gt;, &lt;code&gt;wl&lt;/code&gt;, &lt;code&gt;wm&lt;/code&gt;, &lt;code&gt;wo&lt;/code&gt;, &lt;code&gt;wp&lt;/code&gt;, &lt;code&gt;wq&lt;/code&gt;, &lt;code&gt;ws&lt;/code&gt;, &lt;code&gt;wt&lt;/code&gt;, &lt;code&gt;wu&lt;/code&gt;, &lt;code&gt;wv&lt;/code&gt;, &lt;code&gt;ww&lt;/code&gt;, or &lt;code&gt;wy&lt;/code&gt;) that take VSX registers, you must use &lt;code&gt;%x&amp;lt;n&amp;gt;&lt;/code&gt; in the template so that the correct register is used. Otherwise the register number output in the assembly file will be incorrect if an Altivec register is an operand of a VSX instruction that expects VSX register numbering.</source>
          <target state="translated">使用使用VSX的任何寄存器约束（ &lt;code&gt;wa&lt;/code&gt; ， &lt;code&gt;wd&lt;/code&gt; ， &lt;code&gt;wf&lt;/code&gt; ， &lt;code&gt;wg&lt;/code&gt; ， &lt;code&gt;wh&lt;/code&gt; ， &lt;code&gt;wi&lt;/code&gt; ， &lt;code&gt;wj&lt;/code&gt; ， &lt;code&gt;wk&lt;/code&gt; ， &lt;code&gt;wl&lt;/code&gt; ， &lt;code&gt;wm&lt;/code&gt; ， &lt;code&gt;wo&lt;/code&gt; ， &lt;code&gt;wp&lt;/code&gt; ， &lt;code&gt;wq&lt;/code&gt; ， &lt;code&gt;ws&lt;/code&gt; ， &lt;code&gt;wt&lt;/code&gt; ， &lt;code&gt;wu&lt;/code&gt; ， &lt;code&gt;wv&lt;/code&gt; ， &lt;code&gt;ww&lt;/code&gt; 或 &lt;code&gt;wy&lt;/code&gt; ）时寄存器，必须使用 &lt;code&gt;%x&amp;lt;n&amp;gt;&lt;/code&gt; 在模板中，以便使用正确的寄存器。否则，如果Altivec寄存器是需要VSX寄存器编号的VSX指令的操作数，则汇编文件中输出的寄存器编号将不正确。</target>
        </trans-unit>
        <trans-unit id="c184ccdd41991ac034a44b8741c7f1fabbb85a41" translate="yes" xml:space="preserve">
          <source>When using precompiled headers (see &lt;a href=&quot;precompiled-headers#Precompiled-Headers&quot;&gt;Precompiled Headers&lt;/a&gt;), this flag causes the dependency-output flags to also list the files from the precompiled header&amp;rsquo;s dependencies. If not specified, only the precompiled header are listed and not the files that were used to create it, because those files are not consulted when a precompiled header is used.</source>
          <target state="translated">使用预编译头文件时（请参见&lt;a href=&quot;precompiled-headers#Precompiled-Headers&quot;&gt;Precompiled Headers&lt;/a&gt;），此标志使依赖项输出标志也列出来自预编译头文件的依赖项的文件。如果未指定，则仅列出预编译的标头，而不列出用于创建它的文件，因为在使用预编译的标头时不会查询这些文件。</target>
        </trans-unit>
        <trans-unit id="4d73200be5ca0030ca174cac8ec7eb66631895c5" translate="yes" xml:space="preserve">
          <source>When using the GNU linker, it is usually more convenient to pass arguments to linker options using the</source>
          <target state="translated">当使用GNU链接器时,通常更方便的做法是使用</target>
        </trans-unit>
        <trans-unit id="07d62f57e8744ee5ede23dc9a1e4cfca2395afa4" translate="yes" xml:space="preserve">
          <source>When you are using the &lt;code&gt;goto&lt;/code&gt; form of &lt;code&gt;asm&lt;/code&gt;, this section contains the list of all C labels to which the code in the &lt;var&gt;AssemblerTemplate&lt;/var&gt; may jump. See &lt;a href=&quot;#GotoLabels&quot;&gt;GotoLabels&lt;/a&gt;.</source>
          <target state="translated">当您使用 &lt;code&gt;asm&lt;/code&gt; 的 &lt;code&gt;goto&lt;/code&gt; 形式时，此部分包含 &lt;var&gt;AssemblerTemplate&lt;/var&gt; 中的代码可能跳转到的所有C标签的列表。请参阅&lt;a href=&quot;#GotoLabels&quot;&gt;GotoLabels&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b1da9d83d815287fc18f851fe43c98fefdf50af5" translate="yes" xml:space="preserve">
          <source>When you compile C++ programs, you may specify many of the same command-line options that you use for compiling programs in any language; or command-line options meaningful for C and related languages; or options that are meaningful only for C++ programs. See &lt;a href=&quot;c-dialect-options#C-Dialect-Options&quot;&gt;Options Controlling C Dialect&lt;/a&gt;, for explanations of options for languages related to C. See &lt;a href=&quot;c_002b_002b-dialect-options#C_002b_002b-Dialect-Options&quot;&gt;Options Controlling C++ Dialect&lt;/a&gt;, for explanations of options that are meaningful only for C++ programs.</source>
          <target state="translated">编译C ++程序时，可以指定用于以任何语言编译程序的许多相同的命令行选项。或对C和相关语言有意义的命令行选项；或仅对C ++程序有意义的选项。见&lt;a href=&quot;c-dialect-options#C-Dialect-Options&quot;&gt;选项来控制的C语言&lt;/a&gt;，对涉及C.请参阅语言的选项的说明&lt;a href=&quot;c_002b_002b-dialect-options#C_002b_002b-Dialect-Options&quot;&gt;选项控制C ++方言&lt;/a&gt;，对于选项的说明，仅针对C ++程序是有意义的。</target>
        </trans-unit>
        <trans-unit id="628daae8697f91bc17f481bc0199bf74cc7f3f93" translate="yes" xml:space="preserve">
          <source>When you invoke GCC, it normally does preprocessing, compilation, assembly and linking. The &amp;ldquo;overall options&amp;rdquo; allow you to stop this process at an intermediate stage. For example, the</source>
          <target state="translated">调用GCC时，通常会进行预处理，编译，汇编和链接。&amp;ldquo;总体选项&amp;rdquo;使您可以在中间阶段停止此过程。例如，</target>
        </trans-unit>
        <trans-unit id="dc4bcf9de739295968f25374fa0b9b82393e8d47" translate="yes" xml:space="preserve">
          <source>When you use</source>
          <target state="translated">当你使用</target>
        </trans-unit>
        <trans-unit id="8bb9a5cb938f4f893dfe56300e7991ff5d9ac371" translate="yes" xml:space="preserve">
          <source>When you use &lt;code id=&quot;index-longjmp-incompatibilities&quot;&gt;setjmp&lt;/code&gt; and &lt;code&gt;longjmp&lt;/code&gt;, the only automatic variables guaranteed to remain valid are those declared &lt;code&gt;volatile&lt;/code&gt;. This is a consequence of automatic register allocation. Consider this function:</source>
          <target state="translated">当使用 &lt;code id=&quot;index-longjmp-incompatibilities&quot;&gt;setjmp&lt;/code&gt; 和 &lt;code&gt;longjmp&lt;/code&gt; 时，保证保持有效的唯一自动变量是声明为 &lt;code&gt;volatile&lt;/code&gt; 的那些变量。这是自动寄存器分配的结果。考虑以下功能：</target>
        </trans-unit>
        <trans-unit id="4f5a87979f362a282d672c1cd391334d27dc161a" translate="yes" xml:space="preserve">
          <source>When you use the</source>
          <target state="translated">当您使用</target>
        </trans-unit>
        <trans-unit id="cef8b3831d50a66f25ff90c61c375348a6eba6bf" translate="yes" xml:space="preserve">
          <source>Whenever possible, you should use the general-purpose constraint letters in &lt;code&gt;asm&lt;/code&gt; arguments, since they will convey meaning more readily to people reading your code. Failing that, use the constraint letters that usually have very similar meanings across architectures. The most commonly used constraints are &amp;lsquo;</source>
          <target state="translated">只要有可能，就应该在 &lt;code&gt;asm&lt;/code&gt; 参数中使用通用约束字母，因为它们将更容易地将含义传达给阅读您的代码的人。失败的话，使用通常在体系结构中具有非常相似含义的约束字母。最常用的约束是</target>
        </trans-unit>
        <trans-unit id="3a4007ba3fafc819a7924ea3b2d8632c8709039c" translate="yes" xml:space="preserve">
          <source>Whenever you leave out the alignment factor in an &lt;code&gt;aligned&lt;/code&gt; attribute specification, the compiler automatically sets the alignment for the type to the largest alignment that is ever used for any data type on the target machine you are compiling for. Doing this can often make copy operations more efficient, because the compiler can use whatever instructions copy the biggest chunks of memory when performing copies to or from the variables that have types that you have aligned this way.</source>
          <target state="translated">只要在 &lt;code&gt;aligned&lt;/code&gt; 属性规范中省略对齐因子，编译器就会自动将类型的对齐方式设置为要针对其进行编译的目标计算机上的任何数据类型使用的最大对齐方式。这样做通常可以使复制操作更有效率，因为在对具有这种类型对齐方式的变量执行复制时，编译器可以使用任何指令来复制最大的内存块。</target>
        </trans-unit>
        <trans-unit id="08306a1126e7ec7f2d356c52bfc279fbbf71d360" translate="yes" xml:space="preserve">
          <source>Where &lt;var&gt;op&lt;/var&gt; is the name of the instruction. Refer to the ISA manual for the complete list of instructions.</source>
          <target state="translated">其中 &lt;var&gt;op&lt;/var&gt; 是指令的名称。有关说明的完整列表，请参阅ISA手册。</target>
        </trans-unit>
        <trans-unit id="a66402f17809117f1d29c4b80df406d4e2f11bba" translate="yes" xml:space="preserve">
          <source>Where G++ puts inlines, vtables and such.</source>
          <target state="translated">G++把inlines,vtables之类的东西放在哪里。</target>
        </trans-unit>
        <trans-unit id="f97bcbccf23129ffc3f54b71abd0f18cfe88a7d0" translate="yes" xml:space="preserve">
          <source>Where none of</source>
          <target state="translated">凡是没有</target>
        </trans-unit>
        <trans-unit id="18ba47ae48773e2f3f0699ad79e05aa7bd3185d2" translate="yes" xml:space="preserve">
          <source>Where the standard specified with</source>
          <target state="translated">在以下标准的情况下:</target>
        </trans-unit>
        <trans-unit id="7c95dc097ed9e81e390e81810c6f3d829c025cc5" translate="yes" xml:space="preserve">
          <source>Where the unused arguments lie between used arguments that are specified with &amp;lsquo;</source>
          <target state="translated">未使用的参数位于用'指定的已使用参数之间</target>
        </trans-unit>
        <trans-unit id="b3e4d8bab3e588a9e2b728940ccf589c5438a70e" translate="yes" xml:space="preserve">
          <source>Where the value in &lt;var&gt;dest&lt;/var&gt; will be the result returned from the built-in.</source>
          <target state="translated">&lt;var&gt;dest&lt;/var&gt; 中的值将是内置返回的结果。</target>
        </trans-unit>
        <trans-unit id="e57ba6952af402ae437a5e3309d0cfb54d03b1f3" translate="yes" xml:space="preserve">
          <source>Where to find header files and libraries. Where to find the compiler executable files.</source>
          <target state="translated">在哪里可以找到头文件和库。在哪里可以找到编译器的可执行文件。</target>
        </trans-unit>
        <trans-unit id="3c00f7db25c9cf9b37e3952008b0e2f58aade5fa" translate="yes" xml:space="preserve">
          <source>Whether a &amp;ldquo;plain&amp;rdquo; &lt;code&gt;int&lt;/code&gt; bit-field is treated as a &lt;code&gt;signed int&lt;/code&gt; bit-field or as an &lt;code&gt;unsigned int&lt;/code&gt; bit-field (C90 6.5.2, C90 6.5.2.1, C99 and C11 6.7.2, C99 and C11 6.7.2.1).</source>
          <target state="translated">将&amp;ldquo;纯&amp;rdquo; &lt;code&gt;int&lt;/code&gt; 位域视为带 &lt;code&gt;signed int&lt;/code&gt; 位域还是 &lt;code&gt;unsigned int&lt;/code&gt; 位域（C90 6.5.2，C90 6.5.2.1，C99和C11 6.7.2，C99和C11 6.7.2.1 ）。</target>
        </trans-unit>
        <trans-unit id="7531059d0a25c98e7ca278e75f82acc76daa9a55" translate="yes" xml:space="preserve">
          <source>Whether a bit-field can straddle a storage-unit boundary (C90 6.5.2.1, C99 and C11 6.7.2.1).</source>
          <target state="translated">比特场是否可以跨越存储单元边界(C90 6.5.2.1、C99和C11 6.7.2.1)。</target>
        </trans-unit>
        <trans-unit id="fe2aebfc599d584921175261d958d43ef0f0aec0" translate="yes" xml:space="preserve">
          <source>Whether a function in a binary built by one set of tools can call a function in a binary built by a different set of tools is a subset of interoperability.</source>
          <target state="translated">一套工具构建的二进制中的函数能否调用另一套工具构建的二进制中的函数,是互操作性的一个子集。</target>
        </trans-unit>
        <trans-unit id="c06b8898733d76cc9dce4e56a21efa3845ac1918" translate="yes" xml:space="preserve">
          <source>Whether an argument of class type with a non-trivial copy constructor or destructor can be passed to ... (C++0x 5.2.2).</source>
          <target state="translated">是否可以将一个具有非平凡拷贝构造函数或析构函数的类类型的参数传递给 ...(C++0x 5.2.2)。</target>
        </trans-unit>
        <trans-unit id="f086235b38a936fb8979e808d23b4c24d86f5d9b" translate="yes" xml:space="preserve">
          <source>Whether and how floating expressions are contracted when not disallowed by the &lt;code&gt;FP_CONTRACT&lt;/code&gt; pragma (C99 and C11 6.5).</source>
          <target state="translated">在 &lt;code&gt;FP_CONTRACT&lt;/code&gt; 编译指示（C99和C11 6.5）不允许的情况下，是否以及如何收缩浮动表达式。</target>
        </trans-unit>
        <trans-unit id="f8840ea94992b3ba6df4412ec15b47848948aba5" translate="yes" xml:space="preserve">
          <source>Whether any extended alignments are supported and the contexts in which they are supported (C11 6.2.8).</source>
          <target state="translated">是否支持任何扩展的排列,以及支持扩展排列的背景(C11 6.2.8);</target>
        </trans-unit>
        <trans-unit id="5e7ac927cf9e33f4c488cef419402e9a193f27f2" translate="yes" xml:space="preserve">
          <source>Whether atomic types are permitted for bit-fields (C11 6.7.2.1).</source>
          <target state="translated">是否允许位字段使用原子类型(C11 6.7.2.1)。</target>
        </trans-unit>
        <trans-unit id="1b73e138d1b7cf4eb52da0986b7749369200c235" translate="yes" xml:space="preserve">
          <source>Whether case distinctions are significant in an identifier with external linkage (C90 6.1.2).</source>
          <target state="translated">在有外部联系的识别符中,大小写的区别是否重要(C90 6.1.2);</target>
        </trans-unit>
        <trans-unit id="f11ebb9d3de47abc2e0ca0f87e800f9634ac636f" translate="yes" xml:space="preserve">
          <source>Whether codegen errors should be ICEs when</source>
          <target state="translated">在以下情况下,codegen错误是否应该是ICEs?</target>
        </trans-unit>
        <trans-unit id="354a46344b75f29340cafb16fbb91450a8587db2" translate="yes" xml:space="preserve">
          <source>Whether differently-prefixed wide string literal tokens can be concatenated and, if so, the treatment of the resulting multibyte character sequence (C11 6.4.5).</source>
          <target state="translated">是否可以连接不同前缀的宽字符串文字令牌,如果可以,则对产生的多字节字符序列进行处理(C11 6.4.5)。</target>
        </trans-unit>
        <trans-unit id="3b5528cb4a8a2228a3304685d15fcf34a763a7fb" translate="yes" xml:space="preserve">
          <source>Whether each nonempty sequence of white-space characters other than new-line is retained or replaced by one space character in translation phase 3 (C90, C99 and C11 5.1.1.2).</source>
          <target state="translated">在翻译阶段3中,除新行以外的每个非空字符序列是保留还是用一个空格字符代替(C90、C99和C11 5.1.1.2)。</target>
        </trans-unit>
        <trans-unit id="599547a438479475d1d2cda798d15d3f35866c27" translate="yes" xml:space="preserve">
          <source>Whether signed integer types are represented using sign and magnitude, two&amp;rsquo;s complement, or one&amp;rsquo;s complement, and whether the extraordinary value is a trap representation or an ordinary value (C99 and C11 6.2.6.2).</source>
          <target state="translated">有符号整数类型是使用符号和大小，二进制补码还是二进制补码表示的，以及非常值是陷阱表示形式还是普通值表示（C99和C11 6.2.6.2）。</target>
        </trans-unit>
        <trans-unit id="40b6d1461dda1b8f55b388b60612f0a1c5dc15ae" translate="yes" xml:space="preserve">
          <source>Whether the &amp;ldquo;inexact&amp;rdquo; floating-point exception can be raised when the rounded result actually does equal the mathematical result in an IEC 60559 conformant implementation (C99 F.9).</source>
          <target state="translated">当四舍五入的结果实际上等于符合IEC 60559的实现（C99 F.9）的数学结果时，是否可以引发&amp;ldquo; inexact&amp;rdquo;浮点异常。</target>
        </trans-unit>
        <trans-unit id="c1f63f009e459571f2431bd617b7dca64a11adca" translate="yes" xml:space="preserve">
          <source>Whether the &amp;ldquo;underflow&amp;rdquo; (and &amp;ldquo;inexact&amp;rdquo;) floating-point exception can be raised when a result is tiny but not inexact in an IEC 60559 conformant implementation (C99 F.9).</source>
          <target state="translated">当结果很小但在符合IEC 60559的实现中不完全不精确时（C99 F.9），是否可以引发&amp;ldquo;下溢&amp;rdquo;（和&amp;ldquo;不精确&amp;rdquo;）浮点异常。</target>
        </trans-unit>
        <trans-unit id="945b6d4fa9a5ecbaf6bafbdb8d0d89ae5b700edc" translate="yes" xml:space="preserve">
          <source>Whether the &amp;lsquo;</source>
          <target state="translated">是否 '</target>
        </trans-unit>
        <trans-unit id="bba97b060da98c792876d4d0754d818ca89f0204" translate="yes" xml:space="preserve">
          <source>Whether the compiler should use the &amp;ldquo;canonical&amp;rdquo; type system. Should always be 1, which uses a more efficient internal mechanism for comparing types in C++ and Objective-C++. However, if bugs in the canonical type system are causing compilation failures, set this value to 0 to disable canonical types.</source>
          <target state="translated">编译器是否应使用&amp;ldquo;规范&amp;rdquo;类型系统。应该始终为1，它使用更有效的内部机制来比较C ++和Objective-C ++中的类型。但是，如果规范类型系统中的错误导致编译失败，请将此值设置为0以禁用规范类型。</target>
        </trans-unit>
        <trans-unit id="9bf07719435931f48daf3148b7f591b08eee6622" translate="yes" xml:space="preserve">
          <source>Whether the loop array prefetch pass should issue software prefetch hints for strides that are non-constant. In some cases this may be beneficial, though the fact the stride is non-constant may make it hard to predict when there is clear benefit to issuing these hints.</source>
          <target state="translated">循环数组预取通是否应该对非恒定的跨步发出软件预取提示。在某些情况下,这样做可能是有益的,不过由于步长是非恒定的,所以很难预测何时发出这些提示有明显的好处。</target>
        </trans-unit>
        <trans-unit id="3783705a05be7fc566fd28d14a20893e46a49fb1" translate="yes" xml:space="preserve">
          <source>Whether the value of a character constant in a constant expression that controls conditional inclusion matches the value of the same character constant in the execution character set (C90 6.8.1, C99 and C11 6.10.1).</source>
          <target state="translated">控制条件包含的常量表达式中的字符常量的值是否与执行字符集中同一字符常量的值相匹配(C90 6.8.1、C99和C11 6.10.1)。</target>
        </trans-unit>
        <trans-unit id="c36d4d5da07291b1b8267749102489e31d3d638e" translate="yes" xml:space="preserve">
          <source>Whether the value of a single-character character constant in a constant expression that controls conditional inclusion may have a negative value (C90 6.8.1, C99 and C11 6.10.1).</source>
          <target state="translated">控制条件包含的常量表达式中的单字符字符常量的值是否可以为负值(C90 6.8.1、C99和C11 6.10.1)。</target>
        </trans-unit>
        <trans-unit id="9cb3bdf69d2ad24cba5875ebe4f0cafed80a2719" translate="yes" xml:space="preserve">
          <source>Which additional multibyte characters may appear in identifiers and their correspondence to universal character names (C99 and C11 6.4.2).</source>
          <target state="translated">哪些额外的多字节字符可以出现在识别符中,以及它们与通用字符名称的对应关系(C99和C11 6.4.2);</target>
        </trans-unit>
        <trans-unit id="d42124c28b1baab39d06e79c2e6fbc80bcb8c3b0" translate="yes" xml:space="preserve">
          <source>Which of &lt;code&gt;signed char&lt;/code&gt; or &lt;code&gt;unsigned char&lt;/code&gt; has the same range, representation, and behavior as &amp;ldquo;plain&amp;rdquo; &lt;code&gt;char&lt;/code&gt; (C90 6.1.2.5, C90 6.2.1.1, C99 and C11 6.2.5, C99 and C11 6.3.1.1).</source>
          <target state="translated">有 &lt;code&gt;signed char&lt;/code&gt; 或 &lt;code&gt;unsigned char&lt;/code&gt; 具有与&amp;ldquo;普通&amp;rdquo; &lt;code&gt;char&lt;/code&gt; 相同的范围，表示形式和行为（C90 6.1.2.5，C90 6.2.1.1，C99和C11 6.2.5，C99和C11 6.3.1.1）。</target>
        </trans-unit>
        <trans-unit id="a3f8e01950ee5a5eeec136d809212bfccead4676" translate="yes" xml:space="preserve">
          <source>Which problems in your code get warnings, and which get errors.</source>
          <target state="translated">你的代码中哪些问题会收到警告,哪些会出现错误。</target>
        </trans-unit>
        <trans-unit id="d86a5675cc6478e7030415aaa83cd72801292548" translate="yes" xml:space="preserve">
          <source>While</source>
          <target state="translated">While</target>
        </trans-unit>
        <trans-unit id="78cfea135064bce5a81b5bd15458f3f64f56702d" translate="yes" xml:space="preserve">
          <source>While it is possible to leave the function undefined and thus invoke a link failure (to define the function with a message in &lt;code&gt;.gnu.warning*&lt;/code&gt; section), when using these attributes the problem is diagnosed earlier and with exact location of the call even in presence of inline functions or when not emitting debugging information.</source>
          <target state="translated">尽管可以使函数保持未定义状态，从而调用链接失败（使用 &lt;code&gt;.gnu.warning*&lt;/code&gt; 部分中的消息定义函数），但使用这些属性时，可以更早地诊断问题，甚至可以在调用中准确定位出问题。内联函数的存在或不发出调试信息时。</target>
        </trans-unit>
        <trans-unit id="652d59cea2004903b4f313a4a1b258897728e71e" translate="yes" xml:space="preserve">
          <source>While the compiler is aware of changes to entries listed in the output operands, the inline &lt;code&gt;asm&lt;/code&gt; code may modify more than just the outputs. For example, calculations may require additional registers, or the processor may overwrite a register as a side effect of a particular assembler instruction. In order to inform the compiler of these changes, list them in the clobber list. Clobber list items are either register names or the special clobbers (listed below). Each clobber list item is a string constant enclosed in double quotes and separated by commas.</source>
          <target state="translated">尽管编译器知道对输出操作数中列出的条目的更改，但内联 &lt;code&gt;asm&lt;/code&gt; 代码可能不仅对输出进行了修改。例如，计算可能需要其他寄存器，或者处理器可能会由于特定汇编指令的副作用而覆盖寄存器。为了将这些更改通知编译器，请在Clobber列表中列出它们。障碍物列表项可以是寄存器名称，也可以是特殊的障碍物（在下面列出）。每个内容清单项目都是一个字符串常量，用双引号引起来并用逗号分隔。</target>
        </trans-unit>
        <trans-unit id="e21fa2c7a90a60eea68201dc97480d9a5390c69c" translate="yes" xml:space="preserve">
          <source>While the uses of &lt;code&gt;asm&lt;/code&gt; are many and varied, it may help to think of an &lt;code&gt;asm&lt;/code&gt; statement as a series of low-level instructions that convert input parameters to output parameters. So a simple (if not particularly useful) example for i386 using &lt;code&gt;asm&lt;/code&gt; might look like this:</source>
          <target state="translated">尽管 &lt;code&gt;asm&lt;/code&gt; 的用法多种多样，但将 &lt;code&gt;asm&lt;/code&gt; 语句视为将输入参数转换为输出参数的一系列低级指令可能会有所帮助。因此，一个使用 &lt;code&gt;asm&lt;/code&gt; 的 i386的简单示例（如果不是特别有用）可能看起来像这样：</target>
        </trans-unit>
        <trans-unit id="39d000e8aa5910f6d9ef12595235838dbefbbb8c" translate="yes" xml:space="preserve">
          <source>While transforming the program out of the SSA representation, attempt to reduce copying by coalescing versions of different user-defined variables, instead of just compiler temporaries. This may severely limit the ability to debug an optimized program compiled with</source>
          <target state="translated">在将程序从SSA表示法中转换出来时,尝试通过凝聚不同用户定义变量的版本来减少复制,而不仅仅是编译器的临时变量。这可能会严重限制调试一个以</target>
        </trans-unit>
        <trans-unit id="91e29563eb1f68f27cd54dba1d78ec9cc5f02f0e" translate="yes" xml:space="preserve">
          <source>Whitespace characters are ignored and can be inserted at any position except the first. This enables each alternative for different operands to be visually aligned in the machine description even if they have different number of constraints and modifiers.</source>
          <target state="translated">忽略空白字符,可以在除第一个字符以外的任何位置插入。这使得不同操作数的每一个备选方案都能在机器描述中直观地对齐,即使它们有不同数量的约束和修饰符。</target>
        </trans-unit>
        <trans-unit id="45faa4599697b06106508c630a671752d1b455fb" translate="yes" xml:space="preserve">
          <source>Wint-to-pointer-cast</source>
          <target state="translated">Wint-to-pointer-cast</target>
        </trans-unit>
        <trans-unit id="564f8c6e76fbd512be2e38dabdfdd61550d0c3cc" translate="yes" xml:space="preserve">
          <source>With</source>
          <target state="translated">With</target>
        </trans-unit>
        <trans-unit id="db41302cf4b363b4a1378448e9a36c920e1a7fca" translate="yes" xml:space="preserve">
          <source>With both</source>
          <target state="translated">有了这两个</target>
        </trans-unit>
        <trans-unit id="a29e68e9d153083133283a2db9d7b73482a032a4" translate="yes" xml:space="preserve">
          <source>With extended &lt;code&gt;asm&lt;/code&gt; you can read and write C variables from assembler and perform jumps from assembler code to C labels. Extended &lt;code&gt;asm&lt;/code&gt; syntax uses colons (&amp;lsquo;</source>
          <target state="translated">使用扩展的 &lt;code&gt;asm&lt;/code&gt; ,您可以从汇编器读取和写入C变量，并执行从汇编器代码到C标签的跳转。扩展的 &lt;code&gt;asm&lt;/code&gt; 语法使用冒号（'</target>
        </trans-unit>
        <trans-unit id="b2027ec70d531c569c806c46a0ed0d35bbfbe374" translate="yes" xml:space="preserve">
          <source>With no modifiers, this is what the output from the operands would be for the &amp;lsquo;</source>
          <target state="translated">如果没有修饰符，则操作数的输出就是&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="d8a4b9d08d97e45adb4da87468c9bc15fb87e195" translate="yes" xml:space="preserve">
          <source>With the</source>
          <target state="translated">随着</target>
        </trans-unit>
        <trans-unit id="9cd37ca8139ba8f0077df8728d69e1509b46cb93" translate="yes" xml:space="preserve">
          <source>With the GNU C++ front end, for x86 targets, you may specify multiple versions of a function, where each function is specialized for a specific target feature. At runtime, the appropriate version of the function is automatically executed depending on the characteristics of the execution platform. Here is an example.</source>
          <target state="translated">通过GNU C++前端,对于x86目标,你可以指定一个函数的多个版本,其中每个函数都是针对特定的目标特性的。在运行时,根据执行平台的特性,自动执行相应版本的函数。下面是一个例子。</target>
        </trans-unit>
        <trans-unit id="872450a8fc748ddfde2cdc81d3d1bdedfaa16509" translate="yes" xml:space="preserve">
          <source>With the GNU runtime, exceptions are always implemented as &amp;ldquo;native&amp;rdquo; exceptions and it is recommended that the</source>
          <target state="translated">对于GNU运行时，总是将异常实现为&amp;ldquo;本机&amp;rdquo;异常，建议将</target>
        </trans-unit>
        <trans-unit id="ede352de48f14dbfe64db09513e522c73f079435" translate="yes" xml:space="preserve">
          <source>With the NeXT runtime, although currently designed to be binary compatible with &lt;code&gt;NS_HANDLER&lt;/code&gt;-style idioms provided by the &lt;code&gt;NSException&lt;/code&gt; class, the new exceptions can only be used on Mac OS X 10.3 (Panther) and later systems, due to additional functionality needed in the NeXT Objective-C runtime.</source>
          <target state="translated">随着未来运行，虽然目前设计为二进制兼容 &lt;code&gt;NS_HANDLER&lt;/code&gt; 由提供的风格的成语 &lt;code&gt;NSException&lt;/code&gt; 类，新的例外只能在Mac OS X 10.3（Panther）的和更高版本的系统中，由于在未来需要额外的功能Objective-C运行时。</target>
        </trans-unit>
        <trans-unit id="dab61d2e9aaa3623f28b2c32d76967b2c680ed03" translate="yes" xml:space="preserve">
          <source>With the exception of &lt;code&gt;__thread&lt;/code&gt;, at most one &lt;var&gt;storage-class-specifier&lt;/var&gt; shall appear in a given &lt;var&gt;decl-specifier-seq&lt;/var&gt;. The &lt;code&gt;__thread&lt;/code&gt; specifier may be used alone, or immediately following the &lt;code&gt;extern&lt;/code&gt; or &lt;code&gt;static&lt;/code&gt; specifiers. [&amp;hellip;]</source>
          <target state="translated">除了 &lt;code&gt;__thread&lt;/code&gt; 之外，给定的 &lt;var&gt;decl-specifier-seq&lt;/var&gt; 中最多应出现一个 &lt;var&gt;storage-class-specifier&lt;/var&gt; 。该 &lt;code&gt;__thread&lt;/code&gt; 说明符可单独使用，或紧随 &lt;code&gt;extern&lt;/code&gt; 或 &lt;code&gt;static&lt;/code&gt; 符。[&amp;hellip;]</target>
        </trans-unit>
        <trans-unit id="292a47839ebc29dbb70ec7b25cc162b60e68673e" translate="yes" xml:space="preserve">
          <source>With the exception of &lt;code&gt;__thread&lt;/code&gt;, at most one storage-class specifier may be given [&amp;hellip;]. The &lt;code&gt;__thread&lt;/code&gt; specifier may be used alone, or immediately following &lt;code&gt;extern&lt;/code&gt; or &lt;code&gt;static&lt;/code&gt;.</source>
          <target state="translated">除了 &lt;code&gt;__thread&lt;/code&gt; 之外，最多可以给一个存储类说明符[&amp;hellip;]。该 &lt;code&gt;__thread&lt;/code&gt; 说明符可单独使用，或紧随其后 &lt;code&gt;extern&lt;/code&gt; 或 &lt;code&gt;static&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7a3f5b76de67732f25dfbe9b7ab3c5b977a603b2" translate="yes" xml:space="preserve">
          <source>With the exception of built-ins that have library equivalents such as the standard C library functions discussed below, or that expand to library calls, GCC built-in functions are always expanded inline and thus do not have corresponding entry points and their address cannot be obtained. Attempting to use them in an expression other than a function call results in a compile-time error.</source>
          <target state="translated">除了具有库等价物的内置函数(如下面讨论的标准C库函数)或扩展到库调用的内置函数外,GCC内置函数总是内联扩展的,因此没有相应的入口点,无法获得它们的地址。试图在函数调用以外的表达式中使用它们会导致编译时错误。</target>
        </trans-unit>
        <trans-unit id="e736ee71288d11d1b230f0b89bdd35b5282b45ac" translate="yes" xml:space="preserve">
          <source>With the latter choice the options</source>
          <target state="translated">对于后一种选择,选项</target>
        </trans-unit>
        <trans-unit id="a6637ce41dda1dbfc19245d823fa7fce4d91f90f" translate="yes" xml:space="preserve">
          <source>With the linker plugin enabled, the linker extracts the needed GIMPLE files from</source>
          <target state="translated">启用链接器插件后,链接器会将所需的 GIMPLE 文件从</target>
        </trans-unit>
        <trans-unit id="8b0e7753b83f2f64fc1212f98878b05c847daa5e" translate="yes" xml:space="preserve">
          <source>With the specification of an output file, the output is appended to the named file, and it looks like this:</source>
          <target state="translated">有了指定的输出文件,输出就会附加到命名的文件中,它的样子是这样的。</target>
        </trans-unit>
        <trans-unit id="51ee435d4a40a1b09c0e1be2e1a80aec4607b86e" translate="yes" xml:space="preserve">
          <source>With this interface, &lt;code&gt;wait&lt;/code&gt;&amp;rsquo;s implementation might look like this:</source>
          <target state="translated">使用此界面， &lt;code&gt;wait&lt;/code&gt; 的实现可能如下所示：</target>
        </trans-unit>
        <trans-unit id="901e3b5288c53d25410e3fbe70a050954297b494" translate="yes" xml:space="preserve">
          <source>With this option, the compiler creates multiple copies of some local variables when unrolling a loop, which can result in superior code.</source>
          <target state="translated">有了这个选项,编译器在展开循环时,会创建一些局部变量的多份拷贝,这可以使代码更加优秀。</target>
        </trans-unit>
        <trans-unit id="ce8a418995461de4210630163f948f5da9423e89" translate="yes" xml:space="preserve">
          <source>With this option, the compiler turns the &lt;code&gt;__builtin_unreachable&lt;/code&gt; call into a diagnostics message call instead. When reaching the &lt;code&gt;__builtin_unreachable&lt;/code&gt; call, the behavior is undefined.</source>
          <target state="translated">使用此选项，编译器会将 &lt;code&gt;__builtin_unreachable&lt;/code&gt; 调用转换为诊断消息调用。到达 &lt;code&gt;__builtin_unreachable&lt;/code&gt; 调用时，该行为是不确定的。</target>
        </trans-unit>
        <trans-unit id="756db1c4a886455bb3e77429e2aacb2477c5e4e1" translate="yes" xml:space="preserve">
          <source>With this pragma, the programmer asserts that there are no loop-carried dependencies which would prevent consecutive iterations of the following loop from executing concurrently with SIMD (single instruction multiple data) instructions.</source>
          <target state="translated">有了这个pragma,程序员就可以断定不存在循环携带的依赖关系,不会阻止下面循环的连续迭代与SIMD(单指令多数据)指令并发执行。</target>
        </trans-unit>
        <trans-unit id="a8d9a31f26b7d1b3f16e1e66c83efb3ffbd755c5" translate="yes" xml:space="preserve">
          <source>Within either execution environment, a &lt;em&gt;thread&lt;/em&gt; is a flow of control within a program. It is implementation defined whether or not there may be more than one thread associated with a program. It is implementation defined how threads beyond the first are created, the name and type of the function called at thread startup, and how threads may be terminated. However, objects with thread storage duration shall be initialized before thread startup.</source>
          <target state="translated">在任一执行环境中，&lt;em&gt;线程&lt;/em&gt;都是程序内的控制流。由实现定义是否与一个程序相关联的线程可能不止一个。实现定义了如何创建第一个线程以外的线程，在线程启动时调用的函数的名称和类型以及如何终止线程。但是，具有线程存储持续时间的对象应在线程启动之前初始化。</target>
        </trans-unit>
        <trans-unit id="0e894809a49c1ed8c2eb1cfd50b560eb03dca15f" translate="yes" xml:space="preserve">
          <source>Within the body of &lt;code&gt;T::fn&lt;/code&gt;, &lt;var&gt;this&lt;/var&gt; has the effective definition &lt;code&gt;T *__restrict__ const this&lt;/code&gt;. Notice that the interpretation of a &lt;code&gt;__restrict__&lt;/code&gt; member function qualifier is different to that of &lt;code&gt;const&lt;/code&gt; or &lt;code&gt;volatile&lt;/code&gt; qualifier, in that it is applied to the pointer rather than the object. This is consistent with other compilers that implement restricted pointers.</source>
          <target state="translated">在体内 &lt;code&gt;T::fn&lt;/code&gt; ， &lt;var&gt;this&lt;/var&gt; 具有有效的定义 &lt;code&gt;T *__restrict__ const this&lt;/code&gt; 。注意， &lt;code&gt;__restrict__&lt;/code&gt; 成员函数限定符的解释与 &lt;code&gt;const&lt;/code&gt; 或 &lt;code&gt;volatile&lt;/code&gt; 限定符的解释不同，因为它适用于指针而不是对象。这与实现受限指针的其他编译器一致。</target>
        </trans-unit>
        <trans-unit id="06d91320f48b09da02ef917261dcfd59521156ff" translate="yes" xml:space="preserve">
          <source>Without a value specified, pack all structure members together without holes. When a value is specified (which must be a small power of two), pack structure members according to this value, representing the maximum alignment (that is, objects with default alignment requirements larger than this are output potentially unaligned at the next fitting location.</source>
          <target state="translated">在没有指定数值的情况下,将所有结构成员打包在一起,不打孔。当指定一个值时(必须是二的小倍数),按照这个值打包结构成员,代表最大对齐度(即默认对齐度要求大于这个值的对象在下一个拟合位置输出可能不对齐。</target>
        </trans-unit>
        <trans-unit id="4610e8cd3674760f9e34246c3335f6375dea470e" translate="yes" xml:space="preserve">
          <source>Without any optimization option, the compiler&amp;rsquo;s goal is to reduce the cost of compilation and to make debugging produce the expected results. Statements are independent: if you stop the program with a breakpoint between statements, you can then assign a new value to any variable or change the program counter to any other statement in the function and get exactly the results you expect from the source code.</source>
          <target state="translated">没有任何优化选项，编译器的目标是降低编译成本并使调试产生预期的结果。语句是独立的：如果您在语句之间使用断点来停止程序，则可以将新值分配给任何变量，或者将程序计数器更改为函数中的任何其他语句，并从源代码中准确获取期望的结果。</target>
        </trans-unit>
        <trans-unit id="d8d4a33aae2a07ecc8c812bfec17c5e5d451e08a" translate="yes" xml:space="preserve">
          <source>Without the specification of an output file, the output looks like this:</source>
          <target state="translated">如果不指定输出文件,输出结果是这样的。</target>
        </trans-unit>
        <trans-unit id="5f36069c670576f1745c3bcd64036649a26fba3f" translate="yes" xml:space="preserve">
          <source>Without this option, &amp;lsquo;</source>
          <target state="translated">如果没有此选项，&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="810b49b99b225fdb366e04ce850176fc78b9dace" translate="yes" xml:space="preserve">
          <source>Without this option, the &lt;code&gt;X&lt;/code&gt; register may be used in the same way as &lt;code&gt;Y&lt;/code&gt; or &lt;code&gt;Z&lt;/code&gt; which then is emulated by additional instructions. For example, loading a value with &lt;code&gt;X+const&lt;/code&gt; addressing with a small non-negative &lt;code&gt;const &amp;lt; 64&lt;/code&gt; to a register &lt;var&gt;Rn&lt;/var&gt; is performed as</source>
          <target state="translated">如果没有此选项，则 &lt;code&gt;X&lt;/code&gt; 寄存器的使用方式可以与 &lt;code&gt;Y&lt;/code&gt; 或 &lt;code&gt;Z&lt;/code&gt; 相同，然后通过附加指令对其进行仿真。例如，将具有较小的非负 &lt;code&gt;const &amp;lt; 64&lt;/code&gt; &lt;code&gt;X+const&lt;/code&gt; 地址的值加载到寄存器 &lt;var&gt;Rn&lt;/var&gt; 的过程如下：</target>
        </trans-unit>
        <trans-unit id="4c7069fd8666957ba9eac9efad054fa1d2f74644" translate="yes" xml:space="preserve">
          <source>Work around a bug in the &lt;code&gt;muls&lt;/code&gt; and &lt;code&gt;mulu&lt;/code&gt; instructions for CPU models where it applies. This option is active by default.</source>
          <target state="translated">围绕在一个bug工作 &lt;code&gt;muls&lt;/code&gt; 和 &lt;code&gt;mulu&lt;/code&gt; 为它适用的CPU型号说明。默认情况下，此选项是活动的。</target>
        </trans-unit>
        <trans-unit id="9517982144bf04b0b47a4d85a09581d177ba1cbb" translate="yes" xml:space="preserve">
          <source>Work around a hardware bug that causes the SPU to stall indefinitely. By default, GCC inserts the &lt;code&gt;hbrp&lt;/code&gt; instruction to make sure this stall won&amp;rsquo;t happen.</source>
          <target state="translated">解决导致SPU无限期停止的硬件错误。默认情况下，GCC插入 &lt;code&gt;hbrp&lt;/code&gt; 指令以确保不会发生这种停顿。</target>
        </trans-unit>
        <trans-unit id="8c4b8e3f13ae11240c809eb84fd3edb5d1bba62a" translate="yes" xml:space="preserve">
          <source>Work around certain R10000 errata:</source>
          <target state="translated">绕过某些R10000勘误表。</target>
        </trans-unit>
        <trans-unit id="9074be04c7616416ed213f212eeb7c6c7c183d4c" translate="yes" xml:space="preserve">
          <source>Work around certain R4000 CPU errata:</source>
          <target state="translated">绕过某些R4000 CPU勘误表。</target>
        </trans-unit>
        <trans-unit id="fd709a4ced203846b02db64672dd131b123d5504" translate="yes" xml:space="preserve">
          <source>Work around certain R4400 CPU errata:</source>
          <target state="translated">绕过某些R4400 CPU勘误表。</target>
        </trans-unit>
        <trans-unit id="9c76802dfaf86b35388bb6eac2a9a428f20a7a39" translate="yes" xml:space="preserve">
          <source>Work around certain SB-1 CPU core errata. (This flag currently works around the SB-1 revision 2 &amp;ldquo;F1&amp;rdquo; and &amp;ldquo;F2&amp;rdquo; floating-point errata.)</source>
          <target state="translated">解决某些SB-1 CPU内核勘误。（此标志当前适用于SB-1版本2&amp;ldquo; F1&amp;rdquo;和&amp;ldquo; F2&amp;rdquo;浮点勘误。）</target>
        </trans-unit>
        <trans-unit id="f1322c2c26c7f8a2ae0c4abcf920ab6e36d8883e" translate="yes" xml:space="preserve">
          <source>Work around certain VR4120 errata:</source>
          <target state="translated">绕过某些VR4120的勘误。</target>
        </trans-unit>
        <trans-unit id="70f65ee28d3f60e1570e5c0565d3bacdc0372408" translate="yes" xml:space="preserve">
          <source>Work around the 24K E48 (lost data on stores during refill) errata. The workarounds are implemented by the assembler rather than by GCC.</source>
          <target state="translated">绕过24K E48(在重新填充期间丢失存储数据)的勘误表。这些解决方法是由汇编器而不是由GCC实现的。</target>
        </trans-unit>
        <trans-unit id="eecdf3e0ad9c1e4373885008c446ef1d15e0de5a" translate="yes" xml:space="preserve">
          <source>Work around the RM7000 &lt;code&gt;dmult&lt;/code&gt;/&lt;code&gt;dmultu&lt;/code&gt; errata. The workarounds are implemented by the assembler rather than by GCC.</source>
          <target state="translated">解决RM7000 &lt;code&gt;dmult&lt;/code&gt; / &lt;code&gt;dmultu&lt;/code&gt; 勘误表。解决方法是由汇编程序而非GCC实施。</target>
        </trans-unit>
        <trans-unit id="f514e8f6d3c8232406871016402b0b519b9f1bff" translate="yes" xml:space="preserve">
          <source>Work around the VR4130 &lt;code&gt;mflo&lt;/code&gt;/&lt;code&gt;mfhi&lt;/code&gt; errata. The workarounds are implemented by the assembler rather than by GCC, although GCC avoids using &lt;code&gt;mflo&lt;/code&gt; and &lt;code&gt;mfhi&lt;/code&gt; if the VR4130 &lt;code&gt;macc&lt;/code&gt;, &lt;code&gt;macchi&lt;/code&gt;, &lt;code&gt;dmacc&lt;/code&gt; and &lt;code&gt;dmacchi&lt;/code&gt; instructions are available instead.</source>
          <target state="translated">解决VR4130 &lt;code&gt;mflo&lt;/code&gt; / &lt;code&gt;mfhi&lt;/code&gt; 勘误表。变通办法是由汇编器，而不是由GCC来实现，虽然GCC避免使用 &lt;code&gt;mflo&lt;/code&gt; 和 &lt;code&gt;mfhi&lt;/code&gt; 如果VR4130 &lt;code&gt;macc&lt;/code&gt; ， &lt;code&gt;macchi&lt;/code&gt; ， &lt;code&gt;dmacc&lt;/code&gt; 和 &lt;code&gt;dmacchi&lt;/code&gt; 指令可用来代替。</target>
        </trans-unit>
        <trans-unit id="0a937c64e2a5b7eba62b666d7ca837eb48731984" translate="yes" xml:space="preserve">
          <source>Write &lt;var&gt;src1&lt;/var&gt; into Y.</source>
          <target state="translated">将 &lt;var&gt;src1&lt;/var&gt; 写入Y。</target>
        </trans-unit>
        <trans-unit id="b99c5ddd130a32b9357572f70d99408237dc24f1" translate="yes" xml:space="preserve">
          <source>Write &lt;var&gt;src1&lt;/var&gt; into the least significant half of X and &lt;var&gt;src2&lt;/var&gt; into the most significant half of X.</source>
          <target state="translated">将 &lt;var&gt;src1&lt;/var&gt; 写入X的最低有效部分，并将 &lt;var&gt;src2&lt;/var&gt; 写入X 的最高有效部分。</target>
        </trans-unit>
        <trans-unit id="282a09ed773c8ef9852a2c6377ed12597d3a9c69" translate="yes" xml:space="preserve">
          <source>Write a SRCFILE.opt-record.json.gz file detailing what optimizations were performed, for those optimizations that support</source>
          <target state="translated">写一个SRCFILE.opt-record.json.gz文件,详细说明进行了哪些优化,对于那些支持</target>
        </trans-unit>
        <trans-unit id="40d1ca8852e0dec6c7d4fad7e6bc0514fe5d1c54" translate="yes" xml:space="preserve">
          <source>Write branch frequencies as the number of branches taken, rather than the percentage of branches taken.</source>
          <target state="translated">将分支频率写成所取的分支数,而不是所取分支的百分比。</target>
        </trans-unit>
        <trans-unit id="1423ee2af8243360b137ebe26d7ad382ca0b3b1e" translate="yes" xml:space="preserve">
          <source>Write branch frequencies to the output file, and write branch summary info to the standard output. This option allows you to see how often each branch in your program was taken. Unconditional branches will not be shown, unless the</source>
          <target state="translated">将分支频率写入输出文件,并将分支摘要信息写入标准输出。这个选项可以让你看到程序中每个分支的频率。无条件的分支将不会被显示,除非是在</target>
        </trans-unit>
        <trans-unit id="1fecc6871d15f561a1a398ebd76fa3a7a1663e9e" translate="yes" xml:space="preserve">
          <source>Write counts in human readable format (like 24.6k).</source>
          <target state="translated">以人类可读的格式(如24.6k)写入计数。</target>
        </trans-unit>
        <trans-unit id="e00e26a5662df1b01236462f99618d8089824cf9" translate="yes" xml:space="preserve">
          <source>Write individual execution counts for every basic block. Normally gcov outputs execution counts only for the main blocks of a line. With this option you can determine if blocks within a single line are not being executed.</source>
          <target state="translated">为每个基本块写入单独的执行次数。通常gcov只输出一行中主要块的执行次数。有了这个选项,你可以确定一行中的块是否没有被执行。</target>
        </trans-unit>
        <trans-unit id="27b79e5dd909fed4a63697002ecabe6d4fcefd2b" translate="yes" xml:space="preserve">
          <source>Write the name of each function into the text section, directly preceding the function prologue. The generated code is similar to this:</source>
          <target state="translated">将每个函数的名称写进文本部分,直接写在函数序言之前。生成的代码类似于这样。</target>
        </trans-unit>
        <trans-unit id="c032adc1ff629c9b66f22749ad667e6beadf144b" translate="yes" xml:space="preserve">
          <source>X</source>
          <target state="translated">X</target>
        </trans-unit>
        <trans-unit id="2c144edd2dd673b9ae13db81c4f7c41356844426" translate="yes" xml:space="preserve">
          <source>XER[CA]</source>
          <target state="translated">XER[CA]</target>
        </trans-unit>
        <trans-unit id="edd05eca97855bc49145e43cb3ab5438e61cd98b" translate="yes" xml:space="preserve">
          <source>XOP instructions.</source>
          <target state="translated">XOP指令。</target>
        </trans-unit>
        <trans-unit id="e69dd5b634eb9535ab5de7682e5d1e10df284ccf" translate="yes" xml:space="preserve">
          <source>Xstormy16&amp;mdash;</source>
          <target state="translated">Xstormy16&amp;mdash;</target>
        </trans-unit>
        <trans-unit id="8341de0a85a327eb2d7c97b77086eb0bff937ecb" translate="yes" xml:space="preserve">
          <source>Xtensa&amp;mdash;</source>
          <target state="translated">Xtensa&amp;mdash;</target>
        </trans-unit>
        <trans-unit id="5397e0583f14f6c88de06b1ef28f460a1fb5b0ae" translate="yes" xml:space="preserve">
          <source>Yes</source>
          <target state="translated">Yes</target>
        </trans-unit>
        <trans-unit id="cbfadbe232364f5b4cd1f9250a9cda7fadbb0042" translate="yes" xml:space="preserve">
          <source>You can additionally specify a string parameter: &amp;lsquo;</source>
          <target state="translated">您还可以指定一个字符串参数：'</target>
        </trans-unit>
        <trans-unit id="37f047474bb2991bbc870836a4b1dc7ea6a7e179" translate="yes" xml:space="preserve">
          <source>You can also construct an array, though this is dangerous in C++, as explained below. If all the elements of the compound literal are (made up of) simple constant expressions suitable for use in initializers of objects of static storage duration, then the compound literal can be coerced to a pointer to its first element and used in such an initializer, as shown here:</source>
          <target state="translated">你也可以构造一个数组,不过在C++中这是很危险的,下面会解释。如果复字形的所有元素都是(由)简单的常量表达式组成,适合用于静态存储持续时间的对象的初始化器中,那么复字形可以被胁迫为指向其第一个元素的指针,并用于这样的初始化器中,如这里所示。</target>
        </trans-unit>
        <trans-unit id="7e3923b44bbc7d66662628b3637d89fe21e428bc" translate="yes" xml:space="preserve">
          <source>You can also include type attributes in a &lt;code&gt;typedef&lt;/code&gt; declaration. See &lt;a href=&quot;attribute-syntax#Attribute-Syntax&quot;&gt;Attribute Syntax&lt;/a&gt;, for details of the exact syntax for using attributes.</source>
          <target state="translated">您还可以在 &lt;code&gt;typedef&lt;/code&gt; 声明中包括类型属性。有关使用属性的确切语法的详细信息，请参见&amp;ldquo; &lt;a href=&quot;attribute-syntax#Attribute-Syntax&quot;&gt;属性语法&amp;rdquo;&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c36aaae0a5a83266e8e76c432773d2ebb3588799" translate="yes" xml:space="preserve">
          <source>You can also override the ARM and Thumb mode for each function by using the &lt;code&gt;target(&quot;thumb&quot;)&lt;/code&gt; and &lt;code&gt;target(&quot;arm&quot;)&lt;/code&gt; function attributes (see &lt;a href=&quot;arm-function-attributes#ARM-Function-Attributes&quot;&gt;ARM Function Attributes&lt;/a&gt;) or pragmas (see &lt;a href=&quot;function-specific-option-pragmas#Function-Specific-Option-Pragmas&quot;&gt;Function Specific Option Pragmas&lt;/a&gt;).</source>
          <target state="translated">您还可以通过使用 &lt;code&gt;target(&quot;thumb&quot;)&lt;/code&gt; 和 &lt;code&gt;target(&quot;arm&quot;)&lt;/code&gt; 函数属性（请参见&lt;a href=&quot;arm-function-attributes#ARM-Function-Attributes&quot;&gt;ARM Function Attributes&lt;/a&gt;）或编译指示（请参见&lt;a href=&quot;function-specific-option-pragmas#Function-Specific-Option-Pragmas&quot;&gt;Function Specific Option Pragmas&lt;/a&gt;）来覆盖每个功能的ARM和Thumb模式。</target>
        </trans-unit>
        <trans-unit id="70f9f23d58cf9ce6f889493d1bc7a0c90625f3a7" translate="yes" xml:space="preserve">
          <source>You can also record the return value of that function call, and later return that value, without knowing what data type the function tried to return (as long as your caller expects that data type).</source>
          <target state="translated">你也可以记录该函数调用的返回值,之后再返回该值,而不知道该函数试图返回的数据类型(只要你的调用者期望该数据类型)。</target>
        </trans-unit>
        <trans-unit id="1165641e4d4b9af84b909635ee9d9e9c442957c3" translate="yes" xml:space="preserve">
          <source>You can also set the fpu name at function level by using the &lt;code&gt;target(&quot;fpu=&quot;)&lt;/code&gt; function attributes (see &lt;a href=&quot;arm-function-attributes#ARM-Function-Attributes&quot;&gt;ARM Function Attributes&lt;/a&gt;) or pragmas (see &lt;a href=&quot;function-specific-option-pragmas#Function-Specific-Option-Pragmas&quot;&gt;Function Specific Option Pragmas&lt;/a&gt;).</source>
          <target state="translated">您还可以通过使用 &lt;code&gt;target(&quot;fpu=&quot;)&lt;/code&gt; 函数属性（请参见&lt;a href=&quot;arm-function-attributes#ARM-Function-Attributes&quot;&gt;ARM Function Attributes&lt;/a&gt;）或编译指示（请参见&lt;a href=&quot;function-specific-option-pragmas#Function-Specific-Option-Pragmas&quot;&gt;Function Specific Option Pragmas&lt;/a&gt;）在函数级别设置fpu名称。</target>
        </trans-unit>
        <trans-unit id="7268dd0eaeb17935e5094a8029ba22d93c31a1ac" translate="yes" xml:space="preserve">
          <source>You can also specify</source>
          <target state="translated">您也可以指定</target>
        </trans-unit>
        <trans-unit id="08bf03c9c6ff7624c857011e74954c5c6f9f4300" translate="yes" xml:space="preserve">
          <source>You can also specify the alignment of structure fields. For example, to create a double-word aligned &lt;code&gt;int&lt;/code&gt; pair, you could write:</source>
          <target state="translated">您还可以指定结构字段的对齐方式。例如，要创建一个双字对齐的 &lt;code&gt;int&lt;/code&gt; 对，可以编写：</target>
        </trans-unit>
        <trans-unit id="22d0b06ab6697336780029eb518e6cdd2c05382e" translate="yes" xml:space="preserve">
          <source>You can also use</source>
          <target state="translated">您也可以使用</target>
        </trans-unit>
        <trans-unit id="282b6d022cb9c27fb3bb9103220d6eb51129f71a" translate="yes" xml:space="preserve">
          <source>You can also use attributes to control memory placement, code generation options or call/return conventions within the function being annotated. Many of these attributes are target-specific. For example, many targets support attributes for defining interrupt handler functions, which typically must follow special register usage and return conventions. Such attributes are described in the subsection for each target. However, a considerable number of attributes are supported by most, if not all targets. Those are described in the &lt;a href=&quot;common-function-attributes#Common-Function-Attributes&quot;&gt;Common Function Attributes&lt;/a&gt; section.</source>
          <target state="translated">您还可以使用属性来控制要注释的函数中的内存位置，代码生成选项或调用/返回约定。其中许多属性都是特定于目标的。例如，许多目标都支持用于定义中断处理程序功能的属性，这些属性通常必须遵循特殊的寄存器用法和返回约定。这些属性在小节中针对每个目标进行了描述。但是，大多数（如果不是全部）目标都支持大量属性。&lt;a href=&quot;common-function-attributes#Common-Function-Attributes&quot;&gt;通用功能属性&lt;/a&gt;部分对此进行了描述。</target>
        </trans-unit>
        <trans-unit id="972bfbc14b560aee91d8b7d5cfbc635d959441aa" translate="yes" xml:space="preserve">
          <source>You can also use the &lt;code&gt;asm&lt;/code&gt; keyword to override the assembler name for a C symbol, or to place a C variable in a specific register.</source>
          <target state="translated">您还可以使用 &lt;code&gt;asm&lt;/code&gt; 关键字覆盖C符号的汇编器名称，或将C变量放置在特定的寄存器中。</target>
        </trans-unit>
        <trans-unit id="354710c3fd8ed8d70c6d2f210156da0243dc4ade" translate="yes" xml:space="preserve">
          <source>You can also use the &lt;code&gt;nocf_check&lt;/code&gt; attribute to identify which functions and calls should be skipped from instrumentation (see &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;Function Attributes&lt;/a&gt;).</source>
          <target state="translated">您还可以使用 &lt;code&gt;nocf_check&lt;/code&gt; 属性来确定应从检测中跳过哪些函数和调用（请参见&lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;函数属性&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="d1c6ca2bbbe80bcabecefea25be4aa8fafd6e4d0" translate="yes" xml:space="preserve">
          <source>You can also use the union cast as a function argument:</source>
          <target state="translated">你也可以使用联合铸型作为函数参数。</target>
        </trans-unit>
        <trans-unit id="66b750e5491b307807c28732748047266dbd8e2a" translate="yes" xml:space="preserve">
          <source>You can also use variable-length arrays as arguments to functions:</source>
          <target state="translated">你也可以使用可变长度的数组作为函数的参数。</target>
        </trans-unit>
        <trans-unit id="3ed04a1e1ec2d18dcef36c3f37e8523ec33398b1" translate="yes" xml:space="preserve">
          <source>You can also write a series of &amp;lsquo;</source>
          <target state="translated">您还可以编写一系列&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="9a5d42d9b4feab1feb11ac3d7558132f70441d15" translate="yes" xml:space="preserve">
          <source>You can combine this technique of naming elements with ordinary C initialization of successive elements. Each initializer element that does not have a designator applies to the next consecutive element of the array or structure. For example,</source>
          <target state="translated">你可以将这种命名元素的技术与普通C语言的连续元素初始化结合起来。每一个没有命名符的初始化元素都适用于数组或结构的下一个连续元素。例如</target>
        </trans-unit>
        <trans-unit id="dafe9f6d4d43d75c6afd7b0ee12396460454db2d" translate="yes" xml:space="preserve">
          <source>You can compile C or C++ programs.</source>
          <target state="translated">你可以编译C或C++程序。</target>
        </trans-unit>
        <trans-unit id="54a148541552bb61abf1cc1bf716d6d5d34812ff" translate="yes" xml:space="preserve">
          <source>You can declare variables and use them in function calls and returns, as well as in assignments and some casts. You can specify a vector type as a return type for a function. Vector types can also be used as function arguments. It is possible to cast from one vector type to another, provided they are of the same size (in fact, you can also cast vectors to and from other datatypes of the same size).</source>
          <target state="translated">您可以声明变量,并在函数调用和返回、赋值和一些投掷中使用它们。您可以指定一个向量类型作为函数的返回类型。矢量类型也可以作为函数的参数使用。只要它们大小相同,就可以从一个向量类型投向另一个向量类型(事实上,您也可以将向量投向或投出相同大小的其他数据类型)。</target>
        </trans-unit>
        <trans-unit id="1ab5d021681ed2c7cdd4c44a866c9249ac2dea29" translate="yes" xml:space="preserve">
          <source>You can define a global register variable and associate it with a specified register like this:</source>
          <target state="translated">你可以定义一个全局寄存器变量,并将其与指定的寄存器关联起来,就像这样。</target>
        </trans-unit>
        <trans-unit id="77ca46933320ecebc543d5687d368957991075a9" translate="yes" xml:space="preserve">
          <source>You can define a local register variable and associate it with a specified register like this:</source>
          <target state="translated">你可以定义一个局部的寄存器变量,并将其与指定的寄存器关联起来,像这样。</target>
        </trans-unit>
        <trans-unit id="ca45e2aac1a5f53872ccff8b57eb4700a2d304e0" translate="yes" xml:space="preserve">
          <source>You can define an &lt;code&gt;enum&lt;/code&gt; tag without specifying its possible values. This results in an incomplete type, much like what you get if you write &lt;code&gt;struct foo&lt;/code&gt; without describing the elements. A later declaration that does specify the possible values completes the type.</source>
          <target state="translated">您可以定义 &lt;code&gt;enum&lt;/code&gt; 标签而无需指定其可能的值。这将导致不完整的类型，就像您在不描述元素的情况下编写 &lt;code&gt;struct foo&lt;/code&gt; 时所得到的那样。稍后的声明确实指定了可能的值，从而完成了该类型。</target>
        </trans-unit>
        <trans-unit id="fb2a1d08a5c520db79d7874dd1dd146adad124cb" translate="yes" xml:space="preserve">
          <source>You can easily find more examples by running the &amp;ldquo;strings&amp;rdquo; program on an Objective-C object file compiled by GCC. You&amp;rsquo;ll see a lot of strings that look very much like &lt;code&gt;i8@0:4&lt;/code&gt;. They are signatures of Objective-C methods.</source>
          <target state="translated">通过在GCC编译的Objective-C目标文件上运行&amp;ldquo;字符串&amp;rdquo;程序，可以轻松找到更多示例。您会看到很多看起来很像 &lt;code&gt;i8@0:4&lt;/code&gt; 的字符串。它们是Objective-C方法的签名。</target>
        </trans-unit>
        <trans-unit id="c91ff1d5bc0072fabb3f73c5cf99e1426b54e8b7" translate="yes" xml:space="preserve">
          <source>You can extract a function pointer to the method denoted by a &amp;lsquo;</source>
          <target state="translated">您可以提取函数指针，以&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="8a467dff38136e5694516c0b9fa42d9b5384c2d1" translate="yes" xml:space="preserve">
          <source>You can get the address of a label defined in the current function (or a containing function) with the unary operator &amp;lsquo;</source>
          <target state="translated">您可以使用一元运算符'获得当前函数（或包含函数）中定义的标签的地址。</target>
        </trans-unit>
        <trans-unit id="66a39a597ab8644152ae7afe5488f241a221884a" translate="yes" xml:space="preserve">
          <source>You can locally override stack limit checking by using the &lt;code&gt;no_stack_limit&lt;/code&gt; function attribute (see &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;Function Attributes&lt;/a&gt;).</source>
          <target state="translated">您可以使用 &lt;code&gt;no_stack_limit&lt;/code&gt; 函数属性在本地覆盖堆栈限制检查（请参见&lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;函数属性&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="017844d9ef74d08a2197a10acca046c6aa9a28bc" translate="yes" xml:space="preserve">
          <source>You can make</source>
          <target state="translated">你可以做</target>
        </trans-unit>
        <trans-unit id="f287c383d16164fdc862549b5e329c619384b24c" translate="yes" xml:space="preserve">
          <source>You can mix options and other arguments. For the most part, the order you use doesn&amp;rsquo;t matter. Order does matter when you use several options of the same kind; for example, if you specify</source>
          <target state="translated">您可以混合使用选项和其他参数。在大多数情况下，您使用的顺序无关紧要。当您使用相同种类的多个选项时，顺序确实很重要。例如，如果您指定</target>
        </trans-unit>
        <trans-unit id="a60d360fa80936234f5b0e4eae813689b9ce29d9" translate="yes" xml:space="preserve">
          <source>You can partially avoid this problem by using the</source>
          <target state="translated">您可以通过使用</target>
        </trans-unit>
        <trans-unit id="dd9e0967154278910b1a4d13c152f96dcaf35354" translate="yes" xml:space="preserve">
          <source>You can pass options to the assembler.</source>
          <target state="translated">你可以将选项传递给汇编器。</target>
        </trans-unit>
        <trans-unit id="394017d54ef624457656b3872471fba70d98d59b" translate="yes" xml:space="preserve">
          <source>You can provide an argument to the interrupt attribute which specifies a name or number. If the argument is a number it indicates the slot in the interrupt vector table (0 - 31) to which this handler should be assigned. If the argument is a name it is treated as a symbolic name for the vector slot. These names should match up with appropriate entries in the linker script. By default the names &lt;code&gt;watchdog&lt;/code&gt; for vector 26, &lt;code&gt;nmi&lt;/code&gt; for vector 30 and &lt;code&gt;reset&lt;/code&gt; for vector 31 are recognized.</source>
          <target state="translated">您可以向中断属性提供一个参数，该参数指定名称或数字。如果参数为数字，则表示应将此处理程序分配给的中断向量表（0-31）中的插槽。如果参数是名称，则将其视为向量槽的符号名称。这些名称应与链接描述文件中的适当条目匹配。默认情况下，将识别向量26的 &lt;code&gt;watchdog&lt;/code&gt; ，向量30的 &lt;code&gt;nmi&lt;/code&gt; 和向量31的 &lt;code&gt;reset&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="21a34f7c6e1539af9716888a85e0e6ebdfedbecf" translate="yes" xml:space="preserve">
          <source>You can request many specific warnings with options beginning with &amp;lsquo;</source>
          <target state="translated">您可以使用&amp;ldquo;'</target>
        </trans-unit>
        <trans-unit id="7fbbe3966a5814f26c4830b1276b72ab5f2dc01c" translate="yes" xml:space="preserve">
          <source>You can specify a range of consecutive values in a single &lt;code&gt;case&lt;/code&gt; label, like this:</source>
          <target state="translated">您可以在单个 &lt;code&gt;case&lt;/code&gt; 标签中指定一系列连续值，如下所示：</target>
        </trans-unit>
        <trans-unit id="97b79ea591cef9266e325e711531c14dffd1c998" translate="yes" xml:space="preserve">
          <source>You can specify any number or combination of these options on the command line to search for header files in several directories. The lookup order is as follows:</source>
          <target state="translated">您可以在命令行中指定这些选项的任意数量或组合,以搜索多个目录中的头文件。查找顺序如下。</target>
        </trans-unit>
        <trans-unit id="0856d34db6c364c78838eb5dc1f8a6703a890626" translate="yes" xml:space="preserve">
          <source>You can specify that an individual function is called with this calling sequence with the function attribute &lt;code&gt;stdcall&lt;/code&gt;. You can also override the</source>
          <target state="translated">您可以使用函数属性 &lt;code&gt;stdcall&lt;/code&gt; 指定以此调用序列调用单个函数。您也可以覆盖</target>
        </trans-unit>
        <trans-unit id="e32757ea6fc6362ed46b9b724d574c0143bee986" translate="yes" xml:space="preserve">
          <source>You can specify the input language explicitly with the</source>
          <target state="translated">您可以通过使用</target>
        </trans-unit>
        <trans-unit id="5a6c68a45d3cab174002900881189fc68df355b1" translate="yes" xml:space="preserve">
          <source>You can specify the kind of interrupt to be handled by adding an optional parameter to the interrupt attribute like this:</source>
          <target state="translated">您可以通过向中断属性添加一个可选的参数来指定要处理的中断类型,比如这样。</target>
        </trans-unit>
        <trans-unit id="eee1f7bf9410ab86d8dd30e2bec2be1b2b043010" translate="yes" xml:space="preserve">
          <source>You can specify the name to be used in the assembler code for a C function or variable by writing the &lt;code&gt;asm&lt;/code&gt; (or &lt;code&gt;__asm__&lt;/code&gt;) keyword after the declarator. It is up to you to make sure that the assembler names you choose do not conflict with any other assembler symbols, or reference registers.</source>
          <target state="translated">您可以通过在声明器之后编写 &lt;code&gt;asm&lt;/code&gt; （或 &lt;code&gt;__asm__&lt;/code&gt; ）关键字来为C函数或变量的汇编代码指定要使用的名称。您可以确保选择的汇编程序名称与任何其他汇编程序符号或引用寄存器不冲突。</target>
        </trans-unit>
        <trans-unit id="30703f7905f24c8604a78167a64a5e3a31da9d67" translate="yes" xml:space="preserve">
          <source>You can switch the warning off for all characters by writing</source>
          <target state="translated">你可以通过写下以下内容来关闭所有字符的警告。</target>
        </trans-unit>
        <trans-unit id="95dff15ddf46fdf8429aae6e46c8c16ce4977196" translate="yes" xml:space="preserve">
          <source>You can tell GCC to use a compatible convention for all structure and union returning with the option</source>
          <target state="translated">您可以用选项告诉GCC对所有结构体和联合体的返回使用兼容的约定。</target>
        </trans-unit>
        <trans-unit id="3c94090f45521fa505560d818d146d87684fe4b4" translate="yes" xml:space="preserve">
          <source>You can use</source>
          <target state="translated">您可以使用</target>
        </trans-unit>
        <trans-unit id="4f81d4b126c2797fc5e8e7dc1694c11a9c296047" translate="yes" xml:space="preserve">
          <source>You can use &lt;code&gt;__declspec(dllexport)&lt;/code&gt; as a synonym for &lt;code&gt;__attribute__ ((dllexport))&lt;/code&gt; for compatibility with other compilers.</source>
          <target state="translated">您可以使用 &lt;code&gt;__declspec(dllexport)&lt;/code&gt; 作为 &lt;code&gt;__attribute__ ((dllexport))&lt;/code&gt; 的同义词，以与其他编译器兼容。</target>
        </trans-unit>
        <trans-unit id="50005d4562495b37fc24571844dc1743ca746f4c" translate="yes" xml:space="preserve">
          <source>You can use &lt;code&gt;__declspec(dllimport)&lt;/code&gt; as a synonym for &lt;code&gt;__attribute__ ((dllimport))&lt;/code&gt; for compatibility with other compilers.</source>
          <target state="translated">您可以使用 &lt;code&gt;__declspec(dllimport)&lt;/code&gt; 作为 &lt;code&gt;__attribute__ ((dllimport))&lt;/code&gt; 的同义词，以与其他编译器兼容。</target>
        </trans-unit>
        <trans-unit id="86cd667b81efa67cbffa6feec930a1fbdb8eae9f" translate="yes" xml:space="preserve">
          <source>You can use a single C++ header file for both declarations and definitions.</source>
          <target state="translated">你可以使用一个C++头文件来处理声明和定义。</target>
        </trans-unit>
        <trans-unit id="9d208552bb3a27bb1eed945c45c53009e9054861" translate="yes" xml:space="preserve">
          <source>You can use any combination of these attributes, as shown below:</source>
          <target state="translated">您可以使用这些属性的任意组合,如下所示。</target>
        </trans-unit>
        <trans-unit id="db76755964be4e6b6be71f9e85d1a8d93663640f" translate="yes" xml:space="preserve">
          <source>You can use the &lt;code&gt;copy&lt;/code&gt; attribute to apply the same set of attributes to a declaration as that on another declaration without explicitly enumerating the attributes. This attribute can be applied to declarations of functions (see &lt;a href=&quot;common-function-attributes#Common-Function-Attributes&quot;&gt;Common Function Attributes&lt;/a&gt;), variables (see &lt;a href=&quot;common-variable-attributes#Common-Variable-Attributes&quot;&gt;Common Variable Attributes&lt;/a&gt;), or types (see &lt;a href=&quot;common-type-attributes#Common-Type-Attributes&quot;&gt;Common Type Attributes&lt;/a&gt;).</source>
          <target state="translated">您可以使用 &lt;code&gt;copy&lt;/code&gt; 属性将与其他声明相同的属性集应用于声明，而无需显式枚举属性。此属性可以应用于函数的声明（请参见&amp;ldquo; &lt;a href=&quot;common-function-attributes#Common-Function-Attributes&quot;&gt;通用函数属性&amp;rdquo;&lt;/a&gt;），变量（请参见&amp;ldquo; &lt;a href=&quot;common-variable-attributes#Common-Variable-Attributes&quot;&gt;Common Variable Attributes&amp;rdquo;&lt;/a&gt;）或类型（请参见&amp;ldquo; &lt;a href=&quot;common-type-attributes#Common-Type-Attributes&quot;&gt;Common Type Attributes&amp;rdquo;&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="89b5b15d997a3489b69c6b152372fee0f86bbdac" translate="yes" xml:space="preserve">
          <source>You can use the built-in function &lt;code&gt;__builtin_choose_expr&lt;/code&gt; to evaluate code depending on the value of a constant expression. This built-in function returns &lt;var&gt;exp1&lt;/var&gt; if &lt;var&gt;const_exp&lt;/var&gt;, which is an integer constant expression, is nonzero. Otherwise it returns &lt;var&gt;exp2&lt;/var&gt;.</source>
          <target state="translated">您可以使用内置函数 &lt;code&gt;__builtin_choose_expr&lt;/code&gt; 来根据常数表达式的值评估代码。如果作为整数常量表达式的 &lt;var&gt;const_exp&lt;/var&gt; 非零，则此内置函数返回 &lt;var&gt;exp1&lt;/var&gt; 。否则返回 &lt;var&gt;exp2&lt;/var&gt; 。</target>
        </trans-unit>
        <trans-unit id="5fd9fec295629e67098066cf6cb3c9ec92e5bb68" translate="yes" xml:space="preserve">
          <source>You can use the built-in function &lt;code&gt;__builtin_constant_p&lt;/code&gt; to determine if a value is known to be constant at compile time and hence that GCC can perform constant-folding on expressions involving that value. The argument of the function is the value to test. The function returns the integer 1 if the argument is known to be a compile-time constant and 0 if it is not known to be a compile-time constant. A return of 0 does not indicate that the value is &lt;em&gt;not&lt;/em&gt; a constant, but merely that GCC cannot prove it is a constant with the specified value of the</source>
          <target state="translated">您可以使用内置函数 &lt;code&gt;__builtin_constant_p&lt;/code&gt; 来确定某个值在编译时是否已知为常量，因此GCC可以对涉及该值的表达式执行常量折叠。函数的参数是要测试的值。如果该参数已知为编译时常量，则该函数返回整数1；如果未知该参数为编译时常量，则返回0。返回0并不表示该值&lt;em&gt;不是&lt;/em&gt;常数，而只是GCC无法证明其为指定值的常数。</target>
        </trans-unit>
        <trans-unit id="9782a2381707d838ed59767d72501592b95036b5" translate="yes" xml:space="preserve">
          <source>You can use the built-in function &lt;code&gt;__builtin_types_compatible_p&lt;/code&gt; to determine whether two types are the same.</source>
          <target state="translated">您可以使用内置函数 &lt;code&gt;__builtin_types_compatible_p&lt;/code&gt; 来确定两种类型是否相同。</target>
        </trans-unit>
        <trans-unit id="43fa60b9360490e7ba0b03452edb689c2650070f" translate="yes" xml:space="preserve">
          <source>You can use the following attributes to modify the behavior of an interrupt handler:</source>
          <target state="translated">您可以使用以下属性来修改中断处理程序的行为。</target>
        </trans-unit>
        <trans-unit id="02c72ec7b7bacac9ecd4a1fee983fedeb76ad118" translate="yes" xml:space="preserve">
          <source>You can use the function &lt;code&gt;alloca&lt;/code&gt; to get an effect much like variable-length arrays. The function &lt;code&gt;alloca&lt;/code&gt; is available in many other C implementations (but not in all). On the other hand, variable-length arrays are more elegant.</source>
          <target state="translated">您可以使用 &lt;code&gt;alloca&lt;/code&gt; 函数来获得类似于可变长度数组的效果。 &lt;code&gt;alloca&lt;/code&gt; 函数在许多其他C实现中可用（但不是全部）。另一方面，可变长度数组更优雅。</target>
        </trans-unit>
        <trans-unit id="50e67953531648188b117541d8b8b4fa30e96296" translate="yes" xml:space="preserve">
          <source>You can use the function attribute &lt;code&gt;no_instrument_function&lt;/code&gt; to suppress profiling of individual functions when compiling with these options. See &lt;a href=&quot;common-function-attributes#Common-Function-Attributes&quot;&gt;Common Function Attributes&lt;/a&gt;.</source>
          <target state="translated">使用这些选项进行编译时，可以使用函数属性 &lt;code&gt;no_instrument_function&lt;/code&gt; 禁止对单个函数进行性能分析。请参阅&lt;a href=&quot;common-function-attributes#Common-Function-Attributes&quot;&gt;通用功能属性&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e0525436fc5cc0248b7f78e573bd26eb006c5427" translate="yes" xml:space="preserve">
          <source>You can use the sequence &amp;lsquo;</source>
          <target state="translated">您可以使用序列&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="25c48302e37cab0b76739d2efc98f5300353b6c4" translate="yes" xml:space="preserve">
          <source>You can use these attributes on Microsoft Windows targets. &lt;a href=&quot;variable-attributes#x86-Variable-Attributes&quot;&gt;x86 Variable Attributes&lt;/a&gt; for additional Windows compatibility attributes available on all x86 targets.</source>
          <target state="translated">您可以在Microsoft Windows目标上使用这些属性。&lt;a href=&quot;variable-attributes#x86-Variable-Attributes&quot;&gt;x86变量属性，&lt;/a&gt;用于在所有x86目标上可用的其他Windows兼容性属性。</target>
        </trans-unit>
        <trans-unit id="349076840f0960c3892315d6f39c00e2e8d77252" translate="yes" xml:space="preserve">
          <source>You can use these types in arithmetic like any other integer types. Addition, subtraction, and bitwise boolean operations on these types are open-coded on all types of machines. Multiplication is open-coded if the machine supports a fullword-to-doubleword widening multiply instruction. Division and shifts are open-coded only on machines that provide special support. The operations that are not open-coded use special library routines that come with GCC.</source>
          <target state="translated">你可以像其他整数类型一样在算术中使用这些类型。这些类型上的加法、减法和位型布尔运算在所有类型的机器上都是开放编码的。如果机器支持全字到双字的加宽乘法指令,乘法是开放编码的。除法和移位只有在提供特殊支持的机器上才是开放编码的。不开码的运算使用GCC自带的特殊库例程。</target>
        </trans-unit>
        <trans-unit id="5aa1044e05ab82d1a453a9feb88c6b31c8d70c35" translate="yes" xml:space="preserve">
          <source>You can use this pragma to control how many times a loop should be unrolled. It must be placed immediately before a &lt;code&gt;for&lt;/code&gt;, &lt;code&gt;while&lt;/code&gt; or &lt;code&gt;do&lt;/code&gt; loop or a &lt;code&gt;#pragma GCC ivdep&lt;/code&gt;, and applies only to the loop that follows. &lt;var&gt;n&lt;/var&gt; is an integer constant expression specifying the unrolling factor. The values of &lt;em&gt;0&lt;/em&gt; and &lt;em&gt;1&lt;/em&gt; block any unrolling of the loop.</source>
          <target state="translated">您可以使用此编译指示来控制应将循环展开多少次。它必须放在 &lt;code&gt;for&lt;/code&gt; ， &lt;code&gt;while&lt;/code&gt; 或 &lt;code&gt;do&lt;/code&gt; 循环或 &lt;code&gt;#pragma GCC ivdep&lt;/code&gt; 之前，并且仅适用于随后的循环。 &lt;var&gt;n&lt;/var&gt; 是一个整数常数表达式，指定展开因子。&lt;em&gt;0&lt;/em&gt;和&lt;em&gt;1&lt;/em&gt;的值将阻止循环的展开。</target>
        </trans-unit>
        <trans-unit id="d29715d375c9f43b63580c5f152e79229b459a6b" translate="yes" xml:space="preserve">
          <source>You can write any number of such parameter forward declarations in the parameter list. They can be separated by commas or semicolons, but the last one must end with a semicolon, which is followed by the &amp;ldquo;real&amp;rdquo; parameter declarations. Each forward declaration must match a &amp;ldquo;real&amp;rdquo; declaration in parameter name and data type. ISO C99 does not support parameter forward declarations.</source>
          <target state="translated">您可以在参数列表中写入任意数量的此类参数转发声明。它们可以用逗号或分号分隔，但最后一个必须以分号结尾，其后是&amp;ldquo;真实&amp;rdquo;参数声明。每个前向声明必须与参数名称和数据类型中的&amp;ldquo;真实&amp;rdquo;声明匹配。ISO C99不支持参数转发声明。</target>
        </trans-unit>
        <trans-unit id="4d285fcb57d29c445f5c75a81399654db437434b" translate="yes" xml:space="preserve">
          <source>You cannot allocate variables or storage using the type while it is incomplete. However, you can work with pointers to that type.</source>
          <target state="translated">当类型不完整时,您不能使用该类型分配变量或存储。但是,你可以使用指向该类型的指针。</target>
        </trans-unit>
        <trans-unit id="53335da409471fbe7935a617fd9f6ebf473abc26" translate="yes" xml:space="preserve">
          <source>You cannot operate between vectors of different lengths or different signedness without a cast.</source>
          <target state="translated">你不能在不同长度的向量或不同符号的向量之间进行操作。</target>
        </trans-unit>
        <trans-unit id="13abf1800307e25590d2602f0489f433955f9bc6" translate="yes" xml:space="preserve">
          <source>You have freedom to copy and modify this GNU Manual, like GNU software. Copies published by the Free Software Foundation raise funds for GNU development.</source>
          <target state="translated">您可以像使用 GNU 软件一样,自由复制和修改本 GNU 手册。由自由软件基金会出版的副本可以为GNU的开发筹集资金。</target>
        </trans-unit>
        <trans-unit id="35918096a4cd3290ec21ef1581f71b03f35bc6de" translate="yes" xml:space="preserve">
          <source>You have the following options for dealing with template instantiations:</source>
          <target state="translated">您有以下选项来处理模板实例。</target>
        </trans-unit>
        <trans-unit id="83ae29ebda55f943f2de3641f83fdea66157c750" translate="yes" xml:space="preserve">
          <source>You have to expect a certain amount of disagreement between the executable and your source code, when you use optimization.</source>
          <target state="translated">当你使用优化时,你必须期待可执行文件和你的源代码之间存在一定的分歧。</target>
        </trans-unit>
        <trans-unit id="c18143538d54c0195224945ef42bc5ea23853737" translate="yes" xml:space="preserve">
          <source>You may also specify whether a member function&amp;rsquo;s &lt;var&gt;this&lt;/var&gt; pointer is unaliased by using &lt;code&gt;__restrict__&lt;/code&gt; as a member function qualifier.</source>
          <target state="translated">您还可以通过使用 &lt;code&gt;__restrict__&lt;/code&gt; 作为成员函数限定符来指定是否对成员函数的 &lt;var&gt;this&lt;/var&gt; 指针进行别名处理。</target>
        </trans-unit>
        <trans-unit id="3c9c1785a9b73c6c0c84000e89963aae3de9c571" translate="yes" xml:space="preserve">
          <source>You may also use &lt;code&gt;__builtin_constant_p&lt;/code&gt; in initializers for static data. For instance, you can write</source>
          <target state="translated">您还可以在初始化程序中使用 &lt;code&gt;__builtin_constant_p&lt;/code&gt; 来获取静态数据。例如，您可以编写</target>
        </trans-unit>
        <trans-unit id="77816405062bcfbd54b0c2d088c0cfe9f5a2c604" translate="yes" xml:space="preserve">
          <source>You may mark a method as having a visibility explicitly to negate the effect of the switch for that method. For example, if you do want to compare pointers to a particular inline method, you might mark it as having default visibility. Marking the enclosing class with explicit visibility has no effect.</source>
          <target state="translated">您可以明确地将一个方法标记为具有可见性,以否定该方法的切换效果。例如,如果您确实想比较指向某个内联方法的指针,您可以将其标记为具有默认可见性。将包围类标记为显式可见性则没有任何效果。</target>
        </trans-unit>
        <trans-unit id="e445da5feb655d87cca8dbc770cb3f7e24dc970f" translate="yes" xml:space="preserve">
          <source>You may need to experiment to determine the best settings for your application.</source>
          <target state="translated">您可能需要进行试验,以确定您的应用程序的最佳设置。</target>
        </trans-unit>
        <trans-unit id="bad95174418ab8218d171a6375d9166859a034cf" translate="yes" xml:space="preserve">
          <source>You may need to specify</source>
          <target state="translated">您可能需要指定</target>
        </trans-unit>
        <trans-unit id="48a08602699410d27da97f57d05daf9841a17a43" translate="yes" xml:space="preserve">
          <source>You may not use this mechanism to jump to code in a different function. If you do that, totally unpredictable things happen. The best way to avoid this is to store the label address only in automatic variables and never pass it as an argument.</source>
          <target state="translated">你不能使用这个机制来跳转到不同函数中的代码。如果你这样做,完全无法预料的事情就会发生。避免这种情况的最好方法是只将标签地址存储在自动变量中,而绝不将其作为参数传递。</target>
        </trans-unit>
        <trans-unit id="bff5113fa76e9e5005f3a00a7843919b5149c765" translate="yes" xml:space="preserve">
          <source>You may only specify the &lt;code&gt;packed&lt;/code&gt; attribute on the definition of an &lt;code&gt;enum&lt;/code&gt;, &lt;code&gt;struct&lt;/code&gt;, &lt;code&gt;union&lt;/code&gt;, or &lt;code&gt;class&lt;/code&gt;, not on a &lt;code&gt;typedef&lt;/code&gt; that does not also define the enumerated type, structure, union, or class.</source>
          <target state="translated">您只能在 &lt;code&gt;enum&lt;/code&gt; ， &lt;code&gt;struct&lt;/code&gt; ， &lt;code&gt;union&lt;/code&gt; 或 &lt;code&gt;class&lt;/code&gt; 的定义上指定 &lt;code&gt;packed&lt;/code&gt; 属性，而不能在没有定义枚举类型，结构，联合或类的 &lt;code&gt;typedef&lt;/code&gt; 上指定。</target>
        </trans-unit>
        <trans-unit id="54442d3018c5bf124a5cec286579f5b0f4a37809" translate="yes" xml:space="preserve">
          <source>You may only use the &lt;code&gt;shared&lt;/code&gt; attribute along with &lt;code&gt;section&lt;/code&gt; attribute with a fully-initialized global definition because of the way linkers work. See &lt;code&gt;section&lt;/code&gt; attribute for more information.</source>
          <target state="translated">由于链接器的工作方式，您只能将 &lt;code&gt;shared&lt;/code&gt; 属性和 &lt;code&gt;section&lt;/code&gt; 属性与完全初始化的全局定义一起使用。有关更多信息，请参见 &lt;code&gt;section&lt;/code&gt; 属性。</target>
        </trans-unit>
        <trans-unit id="9c7b80e390300159d4993b9cd813e610830fb794" translate="yes" xml:space="preserve">
          <source>You may optionally specify attribute names with &amp;lsquo;</source>
          <target state="translated">您可以选择使用'</target>
        </trans-unit>
        <trans-unit id="b744bc45d5f9c7b517250c91d7d9ce559fd58615" translate="yes" xml:space="preserve">
          <source>You may place multiple assembler instructions together in a single &lt;code&gt;asm&lt;/code&gt; string, separated by the characters normally used in assembly code for the system. A combination that works in most places is a newline to break the line, plus a tab character (written as &amp;lsquo;</source>
          <target state="translated">您可以将多个汇编程序指令放在一个 &lt;code&gt;asm&lt;/code&gt; 字符串中，并用系统的汇编代码中通常使用的字符分隔。在大多数地方都可以使用的组合是换行符，以换行符，再加上制表符（写为&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="c17cdd78fed8e2f19f13ed7c6a72d4082d16e577" translate="yes" xml:space="preserve">
          <source>You may place multiple assembler instructions together in a single &lt;code&gt;asm&lt;/code&gt; string, separated by the characters normally used in assembly code for the system. A combination that works in most places is a newline to break the line, plus a tab character to move to the instruction field (written as &amp;lsquo;</source>
          <target state="translated">您可以将多个汇编程序指令放在一个 &lt;code&gt;asm&lt;/code&gt; 字符串中，并用系统的汇编代码中通常使用的字符分隔。在大多数情况下都可以使用的组合是：换行符以换行，再加上制表符以移至指令字段（写为&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="f0570114f2ecbb2dbeed78e2cafecfaebd377566" translate="yes" xml:space="preserve">
          <source>You may specify type attributes in an enum, struct or union type declaration or definition by placing them immediately after the &lt;code&gt;struct&lt;/code&gt;, &lt;code&gt;union&lt;/code&gt; or &lt;code&gt;enum&lt;/code&gt; keyword. You can also place them just past the closing curly brace of the definition, but this is less preferred because logically the type should be fully defined at the closing brace.</source>
          <target state="translated">您可以通过将它们放置在 &lt;code&gt;struct&lt;/code&gt; ， &lt;code&gt;union&lt;/code&gt; 或 &lt;code&gt;enum&lt;/code&gt; 关键字之后，来在枚举，结构或联合类型声明或定义中指定类型属性。您也可以将它们放置在定义的右花括号之后，但这不是首选，因为从逻辑上说，应在右花括号处完全定义类型。</target>
        </trans-unit>
        <trans-unit id="1fcc73998e38d45743d93a8c5804d34b2fb5bae5" translate="yes" xml:space="preserve">
          <source>You may use &lt;code&gt;__builtin_expect&lt;/code&gt; to provide the compiler with branch prediction information. In general, you should prefer to use actual profile feedback for this (</source>
          <target state="translated">您可以使用 &lt;code&gt;__builtin_expect&lt;/code&gt; 为编译器提供分支预测信息。通常，您应该对此使用实际的个人资料反馈（</target>
        </trans-unit>
        <trans-unit id="dd9213edd154d9e31cb91aff441ba460289ac018" translate="yes" xml:space="preserve">
          <source>You may use the &lt;code&gt;section&lt;/code&gt; attribute with initialized or uninitialized global variables but the linker requires each object be defined once, with the exception that uninitialized variables tentatively go in the &lt;code&gt;common&lt;/code&gt; (or &lt;code&gt;bss&lt;/code&gt;) section and can be multiply &amp;ldquo;defined&amp;rdquo;. Using the &lt;code&gt;section&lt;/code&gt; attribute changes what section the variable goes into and may cause the linker to issue an error if an uninitialized variable has multiple definitions. You can force a variable to be initialized with the</source>
          <target state="translated">您可以将 &lt;code&gt;section&lt;/code&gt; 属性与已初始化或未初始化的全局变量一起使用，但是链接器要求每个对象定义一次，但未初始化的变量暂定位于 &lt;code&gt;common&lt;/code&gt; （或 &lt;code&gt;bss&lt;/code&gt; ）部分中，并且可以与&amp;ldquo; defined&amp;rdquo;相乘。如果未初始化的变量具有多个定义，则使用 &lt;code&gt;section&lt;/code&gt; 属性会更改变量进入的节，并可能导致链接程序发出错误。您可以强制变量使用</target>
        </trans-unit>
        <trans-unit id="0897ffec25d2d3e9ff5e4c9a12cc715a05821b36" translate="yes" xml:space="preserve">
          <source>You may use this built-in function in either a macro or an inline function. However, if you use it in an inlined function and pass an argument of the function as the argument to the built-in, GCC never returns 1 when you call the inline function with a string constant or compound literal (see &lt;a href=&quot;compound-literals#Compound-Literals&quot;&gt;Compound Literals&lt;/a&gt;) and does not return 1 when you pass a constant numeric value to the inline function unless you specify the</source>
          <target state="translated">您可以在宏或内联函数中使用此内置函数。但是，如果在内联函数中使用它并将该函数的参数作为内置参数传递，则当您使用字符串常量或复合文字（请参见&lt;a href=&quot;compound-literals#Compound-Literals&quot;&gt;Compound Literals&lt;/a&gt;）调用内联函数时，GCC永远不会返回1 除非将常量数值传递给内联函数，否则不返回1</target>
        </trans-unit>
        <trans-unit id="179c17b93d49191ff63b1b0b1b00b166383a79b3" translate="yes" xml:space="preserve">
          <source>You must move the data files to the expected directory tree in order to use them for profile directed optimizations (</source>
          <target state="translated">您必须将数据文件移动到预期的目录树中,以便将它们用于配置文件定向优化(</target>
        </trans-unit>
        <trans-unit id="65535d14a26d4547fe9b855313a51330599397c9" translate="yes" xml:space="preserve">
          <source>You must never create such structures that cause ambiguous field definitions. For example, in this structure:</source>
          <target state="translated">你千万不要创建这样的结构,导致字段定义含糊不清。例如,在这个结构中。</target>
        </trans-unit>
        <trans-unit id="364d53586a93cb7dd4166336e04c54defad73c15" translate="yes" xml:space="preserve">
          <source>You must specify</source>
          <target state="translated">您必须指定</target>
        </trans-unit>
        <trans-unit id="a0fd70e362d1f4b760a9cd038d96c07ea7f21b49" translate="yes" xml:space="preserve">
          <source>You must use GAS and GLD from GNU binutils version 2.7 or later for this attribute to work correctly.</source>
          <target state="translated">你必须使用GNU binutils 2.7或更高版本的GAS和GLD,这个属性才能正常工作。</target>
        </trans-unit>
        <trans-unit id="6993ebfa9e3b6b6d6560ac8997eeb7ede6d0e9b1" translate="yes" xml:space="preserve">
          <source>You need this special case of the</source>
          <target state="translated">你需要这种特殊情况下的</target>
        </trans-unit>
        <trans-unit id="5a83a0c884ced5b1afbf8e0b73de9c85e4e8c7bb" translate="yes" xml:space="preserve">
          <source>You should be prepared for side effects when using</source>
          <target state="translated">您应该准备好在使用</target>
        </trans-unit>
        <trans-unit id="fc2603d33fd81fe37c5c600db9786f0599bb7f89" translate="yes" xml:space="preserve">
          <source>You should compile your code without optimization if you plan to use &lt;code&gt;gcov&lt;/code&gt; because the optimization, by combining some lines of code into one function, may not give you as much information as you need to look for &amp;lsquo;hot spots&amp;rsquo; where the code is using a great deal of computer time. Likewise, because &lt;code&gt;gcov&lt;/code&gt; accumulates statistics by line (at the lowest resolution), it works best with a programming style that places only one statement on each line. If you use complicated macros that expand to loops or to other control structures, the statistics are less helpful&amp;mdash;they only report on the line where the macro call appears. If your complex macros behave like functions, you can replace them with inline functions to solve this problem.</source>
          <target state="translated">如果您打算使用 &lt;code&gt;gcov&lt;/code&gt; ,则应在不进行优化的情况下编译代码，因为通过将一些代码行合并到一个函数中，优化可能无法为您提供所需的信息，而您需要查找使用代码的&amp;ldquo;热点&amp;rdquo;大量的计算机时间。同样，由于 &lt;code&gt;gcov&lt;/code&gt; 会按行（以最低的分辨率）累积统计信息，因此它最适合于在每行仅放置一条语句的编程风格。如果您使用扩展到循环或其他控制结构的复杂宏，则统计信息的用处较小-它们仅在出现宏调用的行上报告。如果复杂宏的行为类似于函数，则可以用内联函数替换它们以解决此问题。</target>
        </trans-unit>
        <trans-unit id="fe80fe3d98f647e191798f4bf1cd85c0708a7905" translate="yes" xml:space="preserve">
          <source>You should declare the jump buffer argument &lt;var&gt;buf&lt;/var&gt; to the built-in functions as:</source>
          <target state="translated">您应将内置函数的跳转缓冲区参数 &lt;var&gt;buf&lt;/var&gt; 声明为：</target>
        </trans-unit>
        <trans-unit id="7d1fbba229a2654e9c51633205d301f0603b772d" translate="yes" xml:space="preserve">
          <source>You should make no assumptions about receiving &lt;code&gt;+load&lt;/code&gt; in sibling classes when you write &lt;code&gt;+load&lt;/code&gt; of a class. The order in which sibling classes receive &lt;code&gt;+load&lt;/code&gt; is not guaranteed.</source>
          <target state="translated">你应该让有关接收任何假设 &lt;code&gt;+load&lt;/code&gt; 中，当你写兄弟班 &lt;code&gt;+load&lt;/code&gt; 的一类。不能保证同级类接收 &lt;code&gt;+load&lt;/code&gt; 的顺序。</target>
        </trans-unit>
        <trans-unit id="3a466242a3e9760eaada5a308649a4f792fde67b" translate="yes" xml:space="preserve">
          <source>You should not write this &lt;code&gt;#pragma&lt;/code&gt; in your own code, but it is safe to edit the filename if the PCH file is available in a different location. The filename may be absolute or it may be relative to GCC&amp;rsquo;s current directory.</source>
          <target state="translated">您不应在自己的代码中编写此 &lt;code&gt;#pragma&lt;/code&gt; ，但如果PCH文件在其他位置可用，则可以安全地编辑文件名。文件名可以是绝对文件名，也可以是相对于GCC当前目录的文件名。</target>
        </trans-unit>
        <trans-unit id="b5b58bacb34de248a5caa9e1d70684a5e3e9e81a" translate="yes" xml:space="preserve">
          <source>You should rewrite your code to avoid these warnings if you are concerned about the fact that code generated by G++ may not be binary compatible with code generated by other compilers.</source>
          <target state="translated">如果你担心G++生成的代码可能与其他编译器生成的代码在二进制上不兼容,你应该重写你的代码以避免这些警告。</target>
        </trans-unit>
        <trans-unit id="3200321f5c777dbbacc4f9ef21ac598c37fa6c47" translate="yes" xml:space="preserve">
          <source>You typically use this function in an embedded application where memory is a critical resource. If you have some complex calculation, you may want it to be folded if it involves constants, but need to call a function if it does not. For example:</source>
          <target state="translated">你通常在内存是关键资源的嵌入式应用中使用这个函数。如果你有一些复杂的计算,如果涉及到常量,你可能希望它被折叠,但如果不涉及到常量,则需要调用一个函数。例如</target>
        </trans-unit>
        <trans-unit id="b1963db30d39d58a295ec397d230925d0854ee73" translate="yes" xml:space="preserve">
          <source>You typically use this function in code whose execution varies depending on the arguments&amp;rsquo; types. For example:</source>
          <target state="translated">您通常在代码中使用此函数，其执行会根据参数的类型而有所不同。例如：</target>
        </trans-unit>
        <trans-unit id="a382ebf878d522cc46ae079d7811d40f2d546d5e" translate="yes" xml:space="preserve">
          <source>You typically use this option to build a shared library dynamic loader. Itself a shared library, it must relocate itself in memory before it can find the variables and constants in its own data segment.</source>
          <target state="translated">你通常使用这个选项来构建一个共享库动态加载器。本身是一个共享库,它必须在内存中重新定位自己,才能找到自己数据段中的变量和常量。</target>
        </trans-unit>
        <trans-unit id="ff2858040c7368b4f7687d2e4605dbe04fb48ce1" translate="yes" xml:space="preserve">
          <source>You use these options to specify which instructions are available on the processor you are using. The default value of these options is determined when configuring GCC. Specifying the</source>
          <target state="translated">您可以使用这些选项来指定在您使用的处理器上哪些指令是可用的。这些选项的默认值是在配置GCC时确定的。指定</target>
        </trans-unit>
        <trans-unit id="afc6c45769ec18ef9f8f79510ff88d4f56540059" translate="yes" xml:space="preserve">
          <source>Zero</source>
          <target state="translated">Zero</target>
        </trans-unit>
        <trans-unit id="553f12b0c01c796a9c01fbfbed6d38920ed5b259" translate="yes" xml:space="preserve">
          <source>Zero-length arrays.</source>
          <target state="translated">零长度阵列。</target>
        </trans-unit>
        <trans-unit id="258478ec83495aa79136f18ffc9233ee1f0db5ed" translate="yes" xml:space="preserve">
          <source>Zero-length bit-fields following non-bit-field members are ignored:</source>
          <target state="translated">非位字段成员后面的零长度位字段会被忽略。</target>
        </trans-unit>
        <trans-unit id="0c2ceddaf3c2e5b315ce6df93a6d703e090097e2" translate="yes" xml:space="preserve">
          <source>[.A-Za-z]*</source>
          <target state="translated">[.A-Za-z]*</target>
        </trans-unit>
        <trans-unit id="abf3f56fd4893df51cec0f301e1d141ec4cf5a54" translate="yes" xml:space="preserve">
          <source>[&lt;var&gt;first&lt;/var&gt; ... &lt;var&gt;last&lt;/var&gt;] = &lt;var&gt;value&lt;/var&gt;</source>
          <target state="translated">[ &lt;var&gt;first&lt;/var&gt; ... &lt;var&gt;last&lt;/var&gt; ] = &lt;var&gt;value&lt;/var&gt;</target>
        </trans-unit>
        <trans-unit id="893b2523426b47e65f5145303772e8166d192d46" translate="yes" xml:space="preserve">
          <source>[&lt;var&gt;index&lt;/var&gt;]</source>
          <target state="translated">[&lt;var&gt;index&lt;/var&gt;]</target>
        </trans-unit>
        <trans-unit id="96a90e0b102b000a44c98efbcdab9b6dee99bbd8" translate="yes" xml:space="preserve">
          <source>[&lt;var&gt;index&lt;/var&gt;] =</source>
          <target state="translated">[ &lt;var&gt;index&lt;/var&gt; ] =</target>
        </trans-unit>
        <trans-unit id="aaf8c573d70607ca295cc0cde78f8a6154aa6363" translate="yes" xml:space="preserve">
          <source>[&lt;var&gt;suffix&lt;/var&gt;] spec</source>
          <target state="translated">[ &lt;var&gt;suffix&lt;/var&gt; ]规格</target>
        </trans-unit>
        <trans-unit id="323d9668ca564c93e740198e5fd45fcacecbe669" translate="yes" xml:space="preserve">
          <source>[dir/]include</source>
          <target state="translated">[dir/]include</target>
        </trans-unit>
        <trans-unit id="14aee59b80f3ae18852c214fd35ef6a55a3b42a6" translate="yes" xml:space="preserve">
          <source>[dir/]stage&lt;var&gt;N&lt;/var&gt;/</source>
          <target state="translated">[dir/]stage&lt;var&gt;N&lt;/var&gt;/</target>
        </trans-unit>
        <trans-unit id="08534f33c201a45017b502e90a800f1b708ebcb3" translate="yes" xml:space="preserve">
          <source>\</source>
          <target state="translated">\</target>
        </trans-unit>
        <trans-unit id="ec24514fcd2c759e6e733c1219e798f6a27080dd" translate="yes" xml:space="preserve">
          <source>\,</source>
          <target state="translated">\,</target>
        </trans-unit>
        <trans-unit id="80bcc8b02cd875c9c7b9dc9e6159a6cd886a4b36" translate="yes" xml:space="preserve">
          <source>\e</source>
          <target state="translated">\e</target>
        </trans-unit>
        <trans-unit id="ef7e6794ca9c6a06b54b66f279237fb8daaaeea8" translate="yes" xml:space="preserve">
          <source>\n</source>
          <target state="translated">\n</target>
        </trans-unit>
        <trans-unit id="5260fdfe19fbab22b26fb10a5b1cdaa4e4d5fa1f" translate="yes" xml:space="preserve">
          <source>\n\t</source>
          <target state="translated">\n\t</target>
        </trans-unit>
        <trans-unit id="dd56ac3bfe32e89d0b9eada9071564fe17a96c3a" translate="yes" xml:space="preserve">
          <source>_&lt;var&gt;L&lt;/var&gt;</source>
          <target state="translated">_&lt;var&gt;L&lt;/var&gt;</target>
        </trans-unit>
        <trans-unit id="f2b8017c21a3fa06728ebdd896c9f0840460e437" translate="yes" xml:space="preserve">
          <source>_&lt;var&gt;n&lt;/var&gt;</source>
          <target state="translated">_&lt;var&gt;n&lt;/var&gt;</target>
        </trans-unit>
        <trans-unit id="bef0f1b1eda1a69cc6d7593689c6ad7764f8486b" translate="yes" xml:space="preserve">
          <source>_Complex double x;</source>
          <target state="translated">_Complex double x;</target>
        </trans-unit>
        <trans-unit id="be1a596019bc728455ca6e661ae186a03fbaf2a6" translate="yes" xml:space="preserve">
          <source>_Complex short int y;</source>
          <target state="translated">_Complex short int y;</target>
        </trans-unit>
        <trans-unit id="4efeab93d874226b7c2975a5130348c4a300a2cf" translate="yes" xml:space="preserve">
          <source>_MAX</source>
          <target state="translated">_MAX</target>
        </trans-unit>
        <trans-unit id="dde95929ec72357d1a78e9ef9086ad031a0699b2" translate="yes" xml:space="preserve">
          <source>_MIN</source>
          <target state="translated">_MIN</target>
        </trans-unit>
        <trans-unit id="9624af4051d439e5359b9152ec698ceaa0261659" translate="yes" xml:space="preserve">
          <source>__atomic</source>
          <target state="translated">__atomic</target>
        </trans-unit>
        <trans-unit id="011657d58155e0e3541069c651cbe40aace6f116" translate="yes" xml:space="preserve">
          <source>__atomic_thread_fence</source>
          <target state="translated">__atomic_thread_fence</target>
        </trans-unit>
        <trans-unit id="b5190ca2a20962ff5fe42fd3d915ec20ed74f142" translate="yes" xml:space="preserve">
          <source>__attribute__ ((aligned (16), packed))</source>
          <target state="translated">__attribute__（（对齐（16），包装好的））</target>
        </trans-unit>
        <trans-unit id="9763de6eac5cd7741fca26ac575ae576079de73c" translate="yes" xml:space="preserve">
          <source>__builtin_</source>
          <target state="translated">__builtin_</target>
        </trans-unit>
        <trans-unit id="9ffdd3b639dbcc260c36604d951401b356ebdfa9" translate="yes" xml:space="preserve">
          <source>__builtin_frame_address</source>
          <target state="translated">__builtin_frame_address</target>
        </trans-unit>
        <trans-unit id="77d71c429ddc63ee19bd5fc63e5f0770c3745449" translate="yes" xml:space="preserve">
          <source>__builtin_return_address</source>
          <target state="translated">__builtin_return_address</target>
        </trans-unit>
        <trans-unit id="090f89da9d6d5b98fdd005c2ae6006ce69c1facf" translate="yes" xml:space="preserve">
          <source>__f</source>
          <target state="translated">__f</target>
        </trans-unit>
        <trans-unit id="3535355516b8a7449fdf619b53778778636b0eea" translate="yes" xml:space="preserve">
          <source>__int128</source>
          <target state="translated">__int128</target>
        </trans-unit>
        <trans-unit id="39a41d9f01352f9be126d019a0f55223b6f117ec" translate="yes" xml:space="preserve">
          <source>__sync</source>
          <target state="translated">__sync</target>
        </trans-unit>
        <trans-unit id="36fb58f934823421b6f9498810790aeee97de129" translate="yes" xml:space="preserve">
          <source>__v850*__</source>
          <target state="translated">__v850*__</target>
        </trans-unit>
        <trans-unit id="e748065bbc4c0e6c0efc4285894458b89aaf5dff" translate="yes" xml:space="preserve">
          <source>_flush_cache</source>
          <target state="translated">_flush_cache</target>
        </trans-unit>
        <trans-unit id="43bf149a9ed61bc94557723db25e4af7f39d8d75" translate="yes" xml:space="preserve">
          <source>_foo</source>
          <target state="translated">_foo</target>
        </trans-unit>
        <trans-unit id="86f7e437faa5a7fce15d1ddcb9eaeaea377667b8" translate="yes" xml:space="preserve">
          <source>a</source>
          <target state="translated">a</target>
        </trans-unit>
        <trans-unit id="20276f54b2fb0d6340042fdc1e284afc48a41106" translate="yes" xml:space="preserve">
          <source>a hard limit, disallowing more than that number in an instruction group. Otherwise, the limit is &amp;ldquo;soft&amp;rdquo;, meaning that non-memory operations are preferred when the limit is reached, but memory operations may still be scheduled.</source>
          <target state="translated">硬性限制，在指令组中不允许超过该数字。否则，该限制是&amp;ldquo;软&amp;rdquo;的，这意味着达到限制时将首选非内存操作，但仍可以安排内存操作。</target>
        </trans-unit>
        <trans-unit id="4d45fbf9e18e03187144f653f6c867ab6a4cb2ce" translate="yes" xml:space="preserve">
          <source>a signed doubleword</source>
          <target state="translated">双关语</target>
        </trans-unit>
        <trans-unit id="9efaa9ee2486d205847ff7f6eb2734e13064b3d6" translate="yes" xml:space="preserve">
          <source>a signed word</source>
          <target state="translated">签语</target>
        </trans-unit>
        <trans-unit id="2e5e828ebf29441ab1d17abe9b59440764703bd5" translate="yes" xml:space="preserve">
          <source>a.c</source>
          <target state="translated">a.c</target>
        </trans-unit>
        <trans-unit id="2ef04052181a3bcb9eb40398327d275b7122b76b" translate="yes" xml:space="preserve">
          <source>a.c##x.h.gcov</source>
          <target state="translated">a.c##x.h.gcov</target>
        </trans-unit>
        <trans-unit id="937373b898e354572539c11778b8369b6021d02b" translate="yes" xml:space="preserve">
          <source>a.out</source>
          <target state="translated">a.out</target>
        </trans-unit>
        <trans-unit id="b9f85daa6f83cf02ce5c31913d1f64d3f5c8fade" translate="yes" xml:space="preserve">
          <source>a2</source>
          <target state="translated">a2</target>
        </trans-unit>
        <trans-unit id="62352d3d034a492b743d85067daad3ede5b2104b" translate="yes" xml:space="preserve">
          <source>aapcs</source>
          <target state="translated">aapcs</target>
        </trans-unit>
        <trans-unit id="cb76f70bd27803c92785136c45fbc376f9dd2652" translate="yes" xml:space="preserve">
          <source>aapcs-linux</source>
          <target state="translated">aapcs-linux</target>
        </trans-unit>
        <trans-unit id="973eb567623a16af6cc4b072efcf2388a12b9404" translate="yes" xml:space="preserve">
          <source>aarch64-*-*</source>
          <target state="translated">aarch64-*-*</target>
        </trans-unit>
        <trans-unit id="c10ebf10559ad9cfd389b344d22aa0551d5fd166" translate="yes" xml:space="preserve">
          <source>aarch64_be-*-*</source>
          <target state="translated">aarch64_be-*-*</target>
        </trans-unit>
        <trans-unit id="715a5d4d840064196cfa2f6763ef29067adb4d87" translate="yes" xml:space="preserve">
          <source>abi</source>
          <target state="translated">abi</target>
        </trans-unit>
        <trans-unit id="dcd67d1087e07b87a59bb90a9324a369479ccb75" translate="yes" xml:space="preserve">
          <source>abm</source>
          <target state="translated">abm</target>
        </trans-unit>
        <trans-unit id="f3bf4a18bc12d3fd665f34273aa77398ca033388" translate="yes" xml:space="preserve">
          <source>about invoking</source>
          <target state="translated">关于调用</target>
        </trans-unit>
        <trans-unit id="de671ae4cf4c6f58efe6bf4db141ff43ea23375f" translate="yes" xml:space="preserve">
          <source>above). Currently, the following sets are defined:</source>
          <target state="translated">以上)。)目前,定义了以下几组:</target>
        </trans-unit>
        <trans-unit id="614cd09c5357289d30936d7b18d4378a9149026f" translate="yes" xml:space="preserve">
          <source>above, generate Ada specs as child units of parent &lt;var&gt;unit&lt;/var&gt;.</source>
          <target state="translated">以上，生成Ada规范作为父 &lt;var&gt;unit&lt;/var&gt; 的子单元。</target>
        </trans-unit>
        <trans-unit id="76726f07acaef7a675fe282314fc6d7f44669323" translate="yes" xml:space="preserve">
          <source>accidentally contains floating-point operations, it is likely to suffer a link-time or run-time failure.</source>
          <target state="translated">不小心包含了浮点运算,它很可能在链接时或运行时出现故障。</target>
        </trans-unit>
        <trans-unit id="466afffe5fc6585663064937defed67d00d3e3b4" translate="yes" xml:space="preserve">
          <source>acml</source>
          <target state="translated">acml</target>
        </trans-unit>
        <trans-unit id="c662180230cad14787d4ab7e77aa08681ce783fa" translate="yes" xml:space="preserve">
          <source>address</source>
          <target state="translated">address</target>
        </trans-unit>
        <trans-unit id="798db27fb8836547e7eae5cbf51a015317e5a479" translate="yes" xml:space="preserve">
          <source>adds keywords &lt;code&gt;__vector&lt;/code&gt;, &lt;code&gt;vector&lt;/code&gt;, &lt;code&gt;__pixel&lt;/code&gt;, &lt;code&gt;pixel&lt;/code&gt;, &lt;code&gt;__bool&lt;/code&gt; and &lt;code&gt;bool&lt;/code&gt;. When compiling ISO C, the context-sensitive substitution of the keywords &lt;code&gt;vector&lt;/code&gt;, &lt;code&gt;pixel&lt;/code&gt; and &lt;code&gt;bool&lt;/code&gt; is disabled. To use them, you must include &lt;code&gt;&amp;lt;altivec.h&amp;gt;&lt;/code&gt; instead.</source>
          <target state="translated">添加关键字 &lt;code&gt;__vector&lt;/code&gt; ， &lt;code&gt;vector&lt;/code&gt; ， &lt;code&gt;__pixel&lt;/code&gt; ， &lt;code&gt;pixel&lt;/code&gt; ， &lt;code&gt;__bool&lt;/code&gt; &lt;code&gt;bool&lt;/code&gt; 和bool。编译ISO C时，禁用了关键字 &lt;code&gt;vector&lt;/code&gt; ， &lt;code&gt;pixel&lt;/code&gt; 和 &lt;code&gt;bool&lt;/code&gt; 的上下文相关替换。要使用它们，必须包含 &lt;code&gt;&amp;lt;altivec.h&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6a4611cf85989cfb032315de1816f14ac9f3517b" translate="yes" xml:space="preserve">
          <source>adiw</source>
          <target state="translated">adiw</target>
        </trans-unit>
        <trans-unit id="70115ea66975f8392735da74af10a532c95caaf7" translate="yes" xml:space="preserve">
          <source>adx</source>
          <target state="translated">adx</target>
        </trans-unit>
        <trans-unit id="9b214a0fbc91794f9b2f7c03b2ffdadc705bb106" translate="yes" xml:space="preserve">
          <source>aes</source>
          <target state="translated">aes</target>
        </trans-unit>
        <trans-unit id="1ba7d6d2d5d6b99ecac4784439f26289cba856d4" translate="yes" xml:space="preserve">
          <source>align-stringops</source>
          <target state="translated">align-stringops</target>
        </trans-unit>
        <trans-unit id="3bea4606b8381d936b8f862d721bc4422652b565" translate="yes" xml:space="preserve">
          <source>aligned</source>
          <target state="translated">aligned</target>
        </trans-unit>
        <trans-unit id="a8d2e4967b2627fcbbcd7bab5490853d70874e12" translate="yes" xml:space="preserve">
          <source>aligns &lt;code&gt;long double&lt;/code&gt; to a 16-byte boundary by padding the &lt;code&gt;long double&lt;/code&gt; with an additional 32-bit zero.</source>
          <target state="translated">对准 &lt;code&gt;long double&lt;/code&gt; 到16字节边界通过填充的 &lt;code&gt;long double&lt;/code&gt; 用另外的32位零。</target>
        </trans-unit>
        <trans-unit id="3efdc33c698275c6bba0bfe0a5cc4bb1ae2af995" translate="yes" xml:space="preserve">
          <source>aligns functions to the next 32-byte boundary,</source>
          <target state="translated">将函数对齐到下一个32字节边界。</target>
        </trans-unit>
        <trans-unit id="244280ce7bd1f8e5d39e22b8ef0ce1ca3d784e6f" translate="yes" xml:space="preserve">
          <source>aligns to the next 32-byte boundary only if this can be done by skipping 23 bytes or less,</source>
          <target state="translated">只有在跳过23个字节或更少的情况下,才会与下一个32字节的边界对齐。</target>
        </trans-unit>
        <trans-unit id="cfa7e3dfee8e7262fa433d58f986a5d3347143cb" translate="yes" xml:space="preserve">
          <source>aligns to the next 32-byte boundary only if this can be done by skipping 6 bytes or less.</source>
          <target state="translated">只有在跳过6个字节或更少的情况下,才会与下一个32字节的边界对齐。</target>
        </trans-unit>
        <trans-unit id="79635748432e8322454f167c344ee1a5dee023d5" translate="yes" xml:space="preserve">
          <source>aligns to the next 64-byte boundary if this can be done by skipping 6 bytes or less, otherwise aligns to the next 32-byte boundary if this can be done by skipping 2 bytes or less. If &lt;var&gt;m2&lt;/var&gt; is not specified, it defaults to &lt;var&gt;n2&lt;/var&gt;.</source>
          <target state="translated">如果可以跳过6个字节或更少的字节，则与下一个64字节边界对齐；如果可以跳过2个字节或更少的字节，则与下一个32字节边界对齐。如果未指定 &lt;var&gt;m2&lt;/var&gt; ，则默认为 &lt;var&gt;n2&lt;/var&gt; 。</target>
        </trans-unit>
        <trans-unit id="d87c448044defb778f33158d8ccf94a20531d600" translate="yes" xml:space="preserve">
          <source>all</source>
          <target state="translated">all</target>
        </trans-unit>
        <trans-unit id="a8901683ad5f4f61f902c68d29d69c8b1ad5d90d" translate="yes" xml:space="preserve">
          <source>all external symbols are resolved at load time.</source>
          <target state="translated">所有的外部符号都在加载时被解析。</target>
        </trans-unit>
        <trans-unit id="bbe28b8276e31a373247e1c8a94a3beb37c5b6fa" translate="yes" xml:space="preserve">
          <source>all.h</source>
          <target state="translated">all.h</target>
        </trans-unit>
        <trans-unit id="3b0a792c2b1703577a069f12d469a0473536a471" translate="yes" xml:space="preserve">
          <source>all.h.gch</source>
          <target state="translated">all.h.gch</target>
        </trans-unit>
        <trans-unit id="b9bf38b9b4d225abc840bc0ee7480fcc2434e2b3" translate="yes" xml:space="preserve">
          <source>allclass.cc</source>
          <target state="translated">allclass.cc</target>
        </trans-unit>
        <trans-unit id="ca4599448f2501f9fa384de7b7038a3e242e0dfb" translate="yes" xml:space="preserve">
          <source>allocation of or sending messages to arbitrary objects;</source>
          <target state="translated">分配或向任意对象发送消息。</target>
        </trans-unit>
        <trans-unit id="32b74672543fdbbdcfc868ba07acb1ff2110d200" translate="yes" xml:space="preserve">
          <source>allocation of or sending messages to objects whose classes have a category implemented in the same file;</source>
          <target state="translated">分配或发送消息给其类的类别在同一文件中实现的对象。</target>
        </trans-unit>
        <trans-unit id="453b7342a6d3f523c8d652e090720e4f47db0bd8" translate="yes" xml:space="preserve">
          <source>allow you to switch between producing output that works with the GNU Objective-C runtime library and output that works with the Apple/NeXT Objective-C runtime library.</source>
          <target state="translated">允许你在使用GNU Objective-C运行库和使用Apple/NeXT Objective-C运行库的输出之间进行切换。</target>
        </trans-unit>
        <trans-unit id="dd4aebec0f6653650ee91987b02de80dc8963201" translate="yes" xml:space="preserve">
          <source>allowing the user to call &lt;code&gt;memcpy&lt;/code&gt; as a regular function, unaware of the actual implementation. Finally, the indirect function needs to be defined in the same translation unit as the resolver function:</source>
          <target state="translated">允许用户将 &lt;code&gt;memcpy&lt;/code&gt; 作为常规函数调用，而没有意识到实际的实现。最后，需要在与解析器函数相同的转换单元中定义间接函数：</target>
        </trans-unit>
        <trans-unit id="66438aaa4bea9ecc573f56890befc19245624f30" translate="yes" xml:space="preserve">
          <source>allows GCC to generate code that may not run at all on processors other than the one indicated. Specifying</source>
          <target state="translated">允许 GCC 生成的代码在指定处理器以外的处理器上可能根本无法运行。指定</target>
        </trans-unit>
        <trans-unit id="cf49e111caf7da05b98404623112872b82a367f9" translate="yes" xml:space="preserve">
          <source>allows GCC to use the optional PowerPC architecture instructions in the General Purpose group, including floating-point square root. Specifying</source>
          <target state="translated">允许GCC使用通用组中可选的PowerPC架构指令,包括浮点平方根。指定</target>
        </trans-unit>
        <trans-unit id="f5666aaba4ff4d9843997efb2fce32365976d352" translate="yes" xml:space="preserve">
          <source>allows GCC to use the optional PowerPC architecture instructions in the Graphics group, including floating-point select.</source>
          <target state="translated">允许GCC使用图形组中可选的PowerPC架构指令,包括浮点选择。</target>
        </trans-unit>
        <trans-unit id="2abc9f7d66d3a1198b14bbaa01458338cdf813bd" translate="yes" xml:space="preserve">
          <source>allows some nonconforming code to compile.</source>
          <target state="translated">允许一些不符合要求的代码进行编译。</target>
        </trans-unit>
        <trans-unit id="bedf43ad0a95e8d3ef4a98d57277220a9905abdc" translate="yes" xml:space="preserve">
          <source>along with</source>
          <target state="translated">与...一起</target>
        </trans-unit>
        <trans-unit id="eec221c0b71d49bdac9cb852917ed960c85ad0a8" translate="yes" xml:space="preserve">
          <source>also being enabled.</source>
          <target state="translated">也正在启用。</target>
        </trans-unit>
        <trans-unit id="5fad31864ed398f45dae03d45460e898d7d29f7e" translate="yes" xml:space="preserve">
          <source>also being specified, the code is tuned to perform well across a range of target processors implementing the target architecture.</source>
          <target state="translated">也被指定,代码被调整为在实现目标架构的一系列目标处理器上表现良好。</target>
        </trans-unit>
        <trans-unit id="8d6a07b9735308ca8e95431227809c536d7831ad" translate="yes" xml:space="preserve">
          <source>also by</source>
          <target state="translated">亦由</target>
        </trans-unit>
        <trans-unit id="187a158ae4568f3cc3e2b692351e6276268ce95b" translate="yes" xml:space="preserve">
          <source>also checks for null format arguments for several functions,</source>
          <target state="translated">还会检查几个函数的空格式参数。</target>
        </trans-unit>
        <trans-unit id="f587f4ff38f8c2cccf85ae4104732656fd8bb96d" translate="yes" xml:space="preserve">
          <source>also diagnoses cases where the attributes of the alias declaration are more restrictive than the attributes applied to its target. These mismatches can potentially result in incorrect code generation. In other cases they may be benign and could be resolved simply by adding the missing attribute to the target. For comparison, see the</source>
          <target state="translated">还可以诊断别名声明的属性比应用于目标的属性更具限制性的情况。这些不匹配可能会导致不正确的代码生成。在其他情况下,它们可能是良性的,只需将缺失的属性添加到目标中即可解决。为了比较,请看</target>
        </trans-unit>
        <trans-unit id="cb860f8821c8635791611ff058e7157ab855da31" translate="yes" xml:space="preserve">
          <source>also implies</source>
          <target state="translated">也意味着</target>
        </trans-unit>
        <trans-unit id="6f42e4ce494f5b76f2544a0f03b983119cfbce78" translate="yes" xml:space="preserve">
          <source>also includes dependence info.</source>
          <target state="translated">还包括依赖性信息。</target>
        </trans-unit>
        <trans-unit id="be3f59c6748c3a9b4a7ae21f5715d657a72eeb15" translate="yes" xml:space="preserve">
          <source>also prints warning messages for the following cases:</source>
          <target state="translated">还会打印以下情况的警告信息:</target>
        </trans-unit>
        <trans-unit id="2e5682119037273f933c083ad00d7701aba2cf5c" translate="yes" xml:space="preserve">
          <source>also provides equivalent macros called &lt;code&gt;_&lt;var&gt;someinsn&lt;/var&gt;&lt;/code&gt; that can be used for programming ease and improved readability. The following macros for DMA control are also provided:</source>
          <target state="translated">还提供了称为 &lt;code&gt;_&lt;var&gt;someinsn&lt;/var&gt;&lt;/code&gt; 的等效宏，可用于简化编程和提高可读性。还提供了以下用于DMA控制的宏：</target>
        </trans-unit>
        <trans-unit id="f34eaf4f6ae89eb9588e134559245afad4e138e4" translate="yes" xml:space="preserve">
          <source>also sets</source>
          <target state="translated">还设置</target>
        </trans-unit>
        <trans-unit id="e117a2e5dfc7efe817347989346d6cd665ab904c" translate="yes" xml:space="preserve">
          <source>also suppresses preprocessed output, as a missing header file renders this useless.</source>
          <target state="translated">也抑制了预处理的输出,因为缺少头文件会使其失去作用。</target>
        </trans-unit>
        <trans-unit id="63a0640542d5918d3932396f482586803338d771" translate="yes" xml:space="preserve">
          <source>also takes into account control flow statements, such as ifs, and only warns when appropriate. E.g.</source>
          <target state="translated">还考虑到控制流报表,如ifs,只在适当的时候发出警告。例如:</target>
        </trans-unit>
        <trans-unit id="30f35ed6e318ea969ed59edf47b9b26381d2be26" translate="yes" xml:space="preserve">
          <source>also warns about calls to bounded string copy functions like &lt;code&gt;strncat&lt;/code&gt; or &lt;code&gt;strncpy&lt;/code&gt; that specify as the bound a &lt;code&gt;sizeof&lt;/code&gt; expression of the source array. For example, in the following function the call to &lt;code&gt;strncat&lt;/code&gt; specifies the size of the source string as the bound. That is almost certainly a mistake and so the call is diagnosed.</source>
          <target state="translated">还警告有关对绑定字符串复制函数（如 &lt;code&gt;strncat&lt;/code&gt; 或 &lt;code&gt;strncpy&lt;/code&gt; )的调用，这些函数将源数组的 &lt;code&gt;sizeof&lt;/code&gt; 表达式指定为绑定对象。例如，在以下函数中，对 &lt;code&gt;strncat&lt;/code&gt; 的调用将源字符串的大小指定为绑定的大小。几乎可以肯定这是一个错误，因此可以诊断出该呼叫。</target>
        </trans-unit>
        <trans-unit id="4f244ab7b0dd86244a85d676a4e7e6a378a2f85e" translate="yes" xml:space="preserve">
          <source>also warns about class member allocation functions.</source>
          <target state="translated">还对类成员分配函数提出警告。</target>
        </trans-unit>
        <trans-unit id="b62db011fc5c4e0ddffda8c03fb7a1020abe09e6" translate="yes" xml:space="preserve">
          <source>also warns about this situation; this warning can be avoided by explicitly tagging the variable or function or moving it into a tagged inline namespace.</source>
          <target state="translated">也会对这种情况发出警告;这个警告可以通过显式标记变量或函数或将其移动到一个标记的内联命名空间来避免。</target>
        </trans-unit>
        <trans-unit id="816d63e63c53fbbcdc73b605731fb850111597ab" translate="yes" xml:space="preserve">
          <source>alternative</source>
          <target state="translated">alternative</target>
        </trans-unit>
        <trans-unit id="cbcd5fa05a97da31161499a40e885c28da334f58" translate="yes" xml:space="preserve">
          <source>altivec</source>
          <target state="translated">altivec</target>
        </trans-unit>
        <trans-unit id="6656018ac96d0295d887ff2893ba9af66ae16af2" translate="yes" xml:space="preserve">
          <source>always</source>
          <target state="translated">always</target>
        </trans-unit>
        <trans-unit id="a17ce9b6918e1f1ff5f858aa6106831fa7297c8c" translate="yes" xml:space="preserve">
          <source>always has a large stack. Support for this is implemented in the gold linker in GNU binutils release 2.21 and later.</source>
          <target state="translated">总是有一个大的栈。在GNU binutils 2.21及以后的版本中的gold linker中实现了这一支持。</target>
        </trans-unit>
        <trans-unit id="80e7ce3e370a6dda4a9fb0810b8685ac34fc5708" translate="yes" xml:space="preserve">
          <source>always_inline</source>
          <target state="translated">always_inline</target>
        </trans-unit>
        <trans-unit id="8dbe12ece6858c4818dac43b3d526c9a1f59fee3" translate="yes" xml:space="preserve">
          <source>am33</source>
          <target state="translated">am33</target>
        </trans-unit>
        <trans-unit id="11b883c428dac39d27e1d63b6df041f0638d659b" translate="yes" xml:space="preserve">
          <source>am33-2</source>
          <target state="translated">am33-2</target>
        </trans-unit>
        <trans-unit id="534aa547f58efe57e7088bffcb38a66eaac8a75f" translate="yes" xml:space="preserve">
          <source>am34</source>
          <target state="translated">am34</target>
        </trans-unit>
        <trans-unit id="1ea0b794e1acd33fc0e733b79c72bf9252569c11" translate="yes" xml:space="preserve">
          <source>amd</source>
          <target state="translated">amd</target>
        </trans-unit>
        <trans-unit id="2395059e740ec74ddaadf44ba1fd6be5abeb4f3f" translate="yes" xml:space="preserve">
          <source>amd64</source>
          <target state="translated">amd64</target>
        </trans-unit>
        <trans-unit id="b35a515e5c6e1bbc58411f2be892a9ab16847ea8" translate="yes" xml:space="preserve">
          <source>amdfam10</source>
          <target state="translated">amdfam10</target>
        </trans-unit>
        <trans-unit id="3a6d03b94ef74592e176a5d5190e78a646119762" translate="yes" xml:space="preserve">
          <source>amdfam10h</source>
          <target state="translated">amdfam10h</target>
        </trans-unit>
        <trans-unit id="261cb5d6b8474d348d7cc4b9daa4299477e3581e" translate="yes" xml:space="preserve">
          <source>amdfam15h</source>
          <target state="translated">amdfam15h</target>
        </trans-unit>
        <trans-unit id="77c479bd3bd5a6e9817c756457f45b3383bfda8b" translate="yes" xml:space="preserve">
          <source>amdfam17h</source>
          <target state="translated">amdfam17h</target>
        </trans-unit>
        <trans-unit id="fd4a625a31a18d16fe04662ffe5a54c9d06947f3" translate="yes" xml:space="preserve">
          <source>an &lt;code&gt;enum&lt;/code&gt; is encoded exactly as the integer type that the compiler uses for it, which depends on the enumeration values. Often the compiler users &lt;code&gt;unsigned int&lt;/code&gt;, which is then encoded as &lt;code&gt;I&lt;/code&gt;.</source>
          <target state="translated">一个 &lt;code&gt;enum&lt;/code&gt; 精确地编码为整数类型，编译器用途它，这取决于该枚举值。通常情况下，编译器用户 &lt;code&gt;unsigned int&lt;/code&gt; 类型，然后编码为 &lt;code&gt;I&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4a2ad1f0fd30a224aa1740e4739fe7eb9ee94f86" translate="yes" xml:space="preserve">
          <source>an ACC register number</source>
          <target state="translated">册号</target>
        </trans-unit>
        <trans-unit id="45bc278ac53a1060e69cab091ecac756552d2721" translate="yes" xml:space="preserve">
          <source>an IACC register number</source>
          <target state="translated">IACC注册号</target>
        </trans-unit>
        <trans-unit id="0666bd4cf85f6a8a3d638122033f89aff472392a" translate="yes" xml:space="preserve">
          <source>an integer constant</source>
          <target state="translated">整数常数</target>
        </trans-unit>
        <trans-unit id="6d3c084323cc6197a38855b1039213d1fa5e3a22" translate="yes" xml:space="preserve">
          <source>an unsigned doubleword</source>
          <target state="translated">无符号双字</target>
        </trans-unit>
        <trans-unit id="3657f24217b612273b00133ebb412d287de01a77" translate="yes" xml:space="preserve">
          <source>an unsigned halfword</source>
          <target state="translated">无符号半字</target>
        </trans-unit>
        <trans-unit id="1773204396a38972d97d6f1c14d98973abbaa970" translate="yes" xml:space="preserve">
          <source>an unsigned word</source>
          <target state="translated">无符号字</target>
        </trans-unit>
        <trans-unit id="cffa50a32cb13a240d705317bcec65dd1f31b6ad" translate="yes" xml:space="preserve">
          <source>and</source>
          <target state="translated">and</target>
        </trans-unit>
        <trans-unit id="70913d37024f402445c0df52a7fadf651367bc49" translate="yes" xml:space="preserve">
          <source>and &amp;ldquo;on&amp;rdquo; for</source>
          <target state="translated">和&amp;ldquo;在&amp;rdquo;上</target>
        </trans-unit>
        <trans-unit id="16ef79c113045b4dd6e920ca55a6a62dad230d8e" translate="yes" xml:space="preserve">
          <source>and 2 for</source>
          <target state="translated">和2个</target>
        </trans-unit>
        <trans-unit id="6e8bd910160e77b35630d8e9ecd21b71ad3f3f1e" translate="yes" xml:space="preserve">
          <source>and &lt;code&gt;__attribute__ ((visibility(&quot;default&quot;)))&lt;/code&gt; instead of &lt;code&gt;__declspec(dllexport)&lt;/code&gt; you get almost identical semantics with identical syntax. This is a great boon to those working with cross-platform projects.</source>
          <target state="translated">和 &lt;code&gt;__attribute__ ((visibility(&quot;default&quot;)))&lt;/code&gt; 而不是 &lt;code&gt;__declspec(dllexport)&lt;/code&gt; ,您将获得具有相同语法的几乎相同的语义。对于那些从事跨平台项目的人来说，这是一个很大的福音。</target>
        </trans-unit>
        <trans-unit id="ecd7bafc40d24575da004f86f8a90c2aaf8b6d10" translate="yes" xml:space="preserve">
          <source>and &lt;code&gt;gold&lt;/code&gt; is used as the linker plugin, &lt;code&gt;externally_visible&lt;/code&gt; attributes are automatically added to functions (not variable yet due to a current &lt;code&gt;gold&lt;/code&gt; issue) that are accessed outside of LTO objects according to resolution file produced by &lt;code&gt;gold&lt;/code&gt;. For other linkers that cannot generate resolution file, explicit &lt;code&gt;externally_visible&lt;/code&gt; attributes are still necessary.</source>
          <target state="translated">并将 &lt;code&gt;gold&lt;/code&gt; 用作链接器插件， &lt;code&gt;externally_visible&lt;/code&gt; 属性自动添加到根据 &lt;code&gt;gold&lt;/code&gt; 生成的解析文件在LTO对象外部访问的函数（由于当前的 &lt;code&gt;gold&lt;/code&gt; 问题，该变量尚未更改）。对于其他无法生成解析文件的链接器，仍然需要显式的 &lt;code&gt;externally_visible&lt;/code&gt; 属性。</target>
        </trans-unit>
        <trans-unit id="bc057aa007baa6ea326398d0908a19dee419f14d" translate="yes" xml:space="preserve">
          <source>and CSE is often sufficient to obtain the same effect. However, that is not reliable in cases where the loop body is more complicated than a single basic block. It also does not work at all on some architectures due to restrictions in the CSE pass.</source>
          <target state="translated">和CSE往往足以获得同样的效果。但是,在循环体比单个基本块更复杂的情况下,这并不可靠。由于CSE通证的限制,在某些架构上也完全不起作用。</target>
        </trans-unit>
        <trans-unit id="2d730a90936bf795bf3e3ee8f9ba908c353e4fdf" translate="yes" xml:space="preserve">
          <source>and PowerPC64 ELFv1 (big-endian) do not support inline PLT calls.</source>
          <target state="translated">和PowerPC64 ELFv1(big-endian)不支持内联PLT调用。</target>
        </trans-unit>
        <trans-unit id="b187d89af0f244b0d50df4ccd6e399a3d2177284" translate="yes" xml:space="preserve">
          <source>and above).</source>
          <target state="translated">及以上)。)</target>
        </trans-unit>
        <trans-unit id="540943c2bc2692326429df85dfa3348df4f1b753" translate="yes" xml:space="preserve">
          <source>and above). It warns about subscripts to arrays that are always out of bounds. This warning is enabled by</source>
          <target state="translated">及以上)。)它对总是超出边界的数组的下标发出警告。这个警告是由</target>
        </trans-unit>
        <trans-unit id="3763092639f876f5583517a9d0eb30243e45a887" translate="yes" xml:space="preserve">
          <source>and above.</source>
          <target state="translated">及以上。</target>
        </trans-unit>
        <trans-unit id="e116e2dfbcfa1008e272a76654ceabd0ae9dcd52" translate="yes" xml:space="preserve">
          <source>and above. For some sorts of source code the enhanced partial redundancy elimination optimization can run away, consuming all of the memory available on the host machine. This parameter sets a limit on the length of the sets that are computed, which prevents the runaway behavior. Setting a value of 0 for this parameter allows an unlimited set length.</source>
          <target state="translated">及以上。对于某些类型的源代码,增强型部分冗余消除优化可能会跑掉,消耗主机上所有的可用内存。这个参数设置了计算集的长度限制,可以防止失控行为。将该参数的值设置为0,可以实现无限制的集合长度。</target>
        </trans-unit>
        <trans-unit id="d4c36d2256d758a63a43d0d687d1ad18856d0f48" translate="yes" xml:space="preserve">
          <source>and above. It is included in</source>
          <target state="translated">及以上。它包括在</target>
        </trans-unit>
        <trans-unit id="8ca6f8b65a307f3565d2bdeac5195f1e6675246e" translate="yes" xml:space="preserve">
          <source>and above. It works in tandem with the</source>
          <target state="translated">及以上。它与</target>
        </trans-unit>
        <trans-unit id="196478f2d301e69e64852ded07da61f6a1994c32" translate="yes" xml:space="preserve">
          <source>and above. The flag</source>
          <target state="translated">及以上。旗帜</target>
        </trans-unit>
        <trans-unit id="16cca3a59f077ac790f119f67104a42b8a0ffc3d" translate="yes" xml:space="preserve">
          <source>and accordingly for the postamble of the epilogue &amp;mdash; no matter whether the mentioned registers are actually used in the ISR or not. Situations where you might want to use this attribute include:</source>
          <target state="translated">因此，无论是在ISR中实际上是否使用了所提到的寄存器，都适用于结尾的序言。您可能要使用此属性的情况包括：</target>
        </trans-unit>
        <trans-unit id="0cba2aa225bdda89770493d09134f7ac4e9d6a51" translate="yes" xml:space="preserve">
          <source>and all C files starting with &amp;rsquo;module&amp;rsquo;.</source>
          <target state="translated">以及所有以&amp;ldquo;模块&amp;rdquo;开头的C文件。</target>
        </trans-unit>
        <trans-unit id="bab3e293e424c711fb965241b4ac9719742de334" translate="yes" xml:space="preserve">
          <source>and all the</source>
          <target state="translated">以及所有</target>
        </trans-unit>
        <trans-unit id="c05c88d23f63de9b36f3b812e4c3b3636aa4477a" translate="yes" xml:space="preserve">
          <source>and also turns on the following optimization flags:</source>
          <target state="translated">并同时开启以下优化标志。</target>
        </trans-unit>
        <trans-unit id="2ebde484284695bea6e3641a94d76fb9524875f9" translate="yes" xml:space="preserve">
          <source>and another with</source>
          <target state="translated">和另一个有</target>
        </trans-unit>
        <trans-unit id="a66594753907e18391761122d0c6251f7905b621" translate="yes" xml:space="preserve">
          <source>and another with the default options. GCC must be configured to use GLIBC 2.23 or newer in order to use the &lt;code&gt;target_clones&lt;/code&gt; attribute.</source>
          <target state="translated">另一个带有默认选项。必须将GCC配置为使用GLIBC 2.23或更高版本，才能使用 &lt;code&gt;target_clones&lt;/code&gt; 属性。</target>
        </trans-unit>
        <trans-unit id="be06f33f42d5fdd847c8ef1a054178ef64e8d724" translate="yes" xml:space="preserve">
          <source>and by</source>
          <target state="translated">并以</target>
        </trans-unit>
        <trans-unit id="bd91aa685e568528bf96de5c3a56f0d28ba7fac2" translate="yes" xml:space="preserve">
          <source>and by default a cost model defined with</source>
          <target state="translated">而默认情况下,成本模型定义为</target>
        </trans-unit>
        <trans-unit id="b58b6b69e9a6e2dffafda6e336f4d4562a450054" translate="yes" xml:space="preserve">
          <source>and code compiled with</source>
          <target state="translated">和用</target>
        </trans-unit>
        <trans-unit id="5f781abb49c37ac3e1988d7f276013bdf87a40b0" translate="yes" xml:space="preserve">
          <source>and either</source>
          <target state="translated">并且要么</target>
        </trans-unit>
        <trans-unit id="db999ebc24b4a98f48dfa65e6948013de37b01d1" translate="yes" xml:space="preserve">
          <source>and emitting the result direct to stdout via</source>
          <target state="translated">并将结果直接发送到stdout,通过</target>
        </trans-unit>
        <trans-unit id="1769c9699ef4ab291d81bfc70d0f12e25b85fd42" translate="yes" xml:space="preserve">
          <source>and export those classes that are intended to be externally visible. Unfortunately it is possible for code to rely, perhaps accidentally, on the Visual Studio behavior.</source>
          <target state="translated">并导出那些打算在外部可见的类。不幸的是,代码有可能依赖Visual Studio的行为,也许是意外的。</target>
        </trans-unit>
        <trans-unit id="36b302c13ab3c153e6cac498496443414d3fce07" translate="yes" xml:space="preserve">
          <source>and finally</source>
          <target state="translated">最后</target>
        </trans-unit>
        <trans-unit id="8b3b299fce213f2a1e237365ea4fcb9e5607c1e3" translate="yes" xml:space="preserve">
          <source>and higher and depends on</source>
          <target state="translated">和更高,取决于</target>
        </trans-unit>
        <trans-unit id="d3ee9cb1836394c3283e4bf670015859583e15fc" translate="yes" xml:space="preserve">
          <source>and higher as well as</source>
          <target state="translated">和更高以及</target>
        </trans-unit>
        <trans-unit id="5a9bec14cd65cb6407309dcf8b220e22883b3c85" translate="yes" xml:space="preserve">
          <source>and higher if</source>
          <target state="translated">和更高,如果</target>
        </trans-unit>
        <trans-unit id="bcbf9cf724baaa2c05cb8d8ef447ba9db9b1d32e" translate="yes" xml:space="preserve">
          <source>and higher on architectures that support this.</source>
          <target state="translated">和更高的架构上支持。</target>
        </trans-unit>
        <trans-unit id="5652f51541248dfcd407bf27224a828b6323954d" translate="yes" xml:space="preserve">
          <source>and higher,</source>
          <target state="translated">及以上。</target>
        </trans-unit>
        <trans-unit id="20df9f0858c9d558bdf3ec73ab7b30c8be3693c7" translate="yes" xml:space="preserve">
          <source>and higher, and also at</source>
          <target state="translated">及以上,以及在</target>
        </trans-unit>
        <trans-unit id="d997e6f0b5d9397ce43f624b10d7171a88e8eab8" translate="yes" xml:space="preserve">
          <source>and higher, except for</source>
          <target state="translated">及以上,除</target>
        </trans-unit>
        <trans-unit id="de9609e65fe8304aa2b84c02990d0ddd0b347ca8" translate="yes" xml:space="preserve">
          <source>and higher.</source>
          <target state="translated">及以上。</target>
        </trans-unit>
        <trans-unit id="4822df6fd07924d846e61249bdf13788d9ead31a" translate="yes" xml:space="preserve">
          <source>and higher. Higher optimization levels improve the accuracy of the analysis.</source>
          <target state="translated">和更高。较高的优化水平可以提高分析的准确性。</target>
        </trans-unit>
        <trans-unit id="afc0a14fb13d8311f68301c0ecd98042f1e9800d" translate="yes" xml:space="preserve">
          <source>and higher. It is not enabled for</source>
          <target state="translated">及以上。它不能用于</target>
        </trans-unit>
        <trans-unit id="a76fab721d9a45aaff56d37fa7059d4d07c6bf05" translate="yes" xml:space="preserve">
          <source>and higher. Null pointer check elimination is only done if</source>
          <target state="translated">及以上。只有在以下情况下才会进行空指针检查消除</target>
        </trans-unit>
        <trans-unit id="17f12a1567309243f3153a113c5c9b0dc8b04f9a" translate="yes" xml:space="preserve">
          <source>and higher. The compilation time in this pass can be limited using</source>
          <target state="translated">及以上。在这个通道中的编译时间可以通过使用</target>
        </trans-unit>
        <trans-unit id="1352c6defb413a9629f8a883262aafbdf1d73c3e" translate="yes" xml:space="preserve">
          <source>and if the variable arguments are omitted or empty, the &amp;lsquo;</source>
          <target state="translated">如果变量参数省略或为空，则'</target>
        </trans-unit>
        <trans-unit id="97253136342a86d551cb8f938043a04fa09b8e17" translate="yes" xml:space="preserve">
          <source>and in the</source>
          <target state="translated">并在</target>
        </trans-unit>
        <trans-unit id="71e7f852efd77608e67d67f4769c27771f643624" translate="yes" xml:space="preserve">
          <source>and in the cases of</source>
          <target state="translated">以及在下列情况下</target>
        </trans-unit>
        <trans-unit id="8e1a25c4625f2b80697437af8a97194c0476ac2c" translate="yes" xml:space="preserve">
          <source>and introduces new signatures for user-defined literals:</source>
          <target state="translated">并为用户定义的文字引入了新的签名。</target>
        </trans-unit>
        <trans-unit id="4a1b1d4b275aa98ab0a4a65283ca64d508b23283" translate="yes" xml:space="preserve">
          <source>and is defined for compatibility with Diab.</source>
          <target state="translated">并定义为与Diab兼容。</target>
        </trans-unit>
        <trans-unit id="b6b1e55ec15f2cb25e78716d325961ca33806bb5" translate="yes" xml:space="preserve">
          <source>and is deprecated.</source>
          <target state="translated">并被废弃。</target>
        </trans-unit>
        <trans-unit id="9c32e4dd09aae4d64ecbad3933f8c85c732ca5ff" translate="yes" xml:space="preserve">
          <source>and is enabled by</source>
          <target state="translated">并通过以下方式启用</target>
        </trans-unit>
        <trans-unit id="60f868f3a7c169f71793f02a83a16555d3150a50" translate="yes" xml:space="preserve">
          <source>and is enabled by default in C99 and C++11 modes (and newer). This warning level does not warn about left-shifting 1 into the sign bit. (However, in C, such an overflow is still rejected in contexts where an integer constant expression is required.) No warning is emitted in C++2A mode (and newer), as signed left shifts always wrap.</source>
          <target state="translated">并在C99和C++11模式(以及更新的模式)中默认启用。这个警告级别不会警告将1左移到符号位中。(然而,在C语言中,在需要整数常量表达式的情况下,这种溢出仍然会被拒绝。)在C++2A模式(和更新版本)中不会发出警告,因为有符号的左移总是会被包起来。</target>
        </trans-unit>
        <trans-unit id="18a6194526a99bc8a75aa2625ef50b249a3cc54a" translate="yes" xml:space="preserve">
          <source>and is ignored at link time.</source>
          <target state="translated">并在链接时被忽略。</target>
        </trans-unit>
        <trans-unit id="8cdd0a931822d69709608b564b7f6b552ac906b1" translate="yes" xml:space="preserve">
          <source>and its related options. Both absolute and relative paths can be used. By default, GCC uses the current directory as &lt;var&gt;path&lt;/var&gt;, thus the profile data file appears in the same directory as the object file. In order to prevent the file name clashing, if the object file name is not an absolute path, we mangle the absolute path of the</source>
          <target state="translated">及其相关选项。绝对路径和相对路径均可使用。默认情况下，GCC使用当前目录作为 &lt;var&gt;path&lt;/var&gt; ，因此概要文件数据文件与目标文件出现在同一目录中。为了防止文件名冲突，如果目标文件名不是绝对路径，我们会修改目标文件的绝对路径。</target>
        </trans-unit>
        <trans-unit id="8aaeb495a9e5b482acebee2f5a8a0a37a7e8745c" translate="yes" xml:space="preserve">
          <source>and joined by spaces. This list is intended to be passed to the LTO linker plugin.</source>
          <target state="translated">并以空格连接。这个列表是为了传递给LTO链接器插件。</target>
        </trans-unit>
        <trans-unit id="c7acf5a5b05ac0929c1671052424680580734fbc" translate="yes" xml:space="preserve">
          <source>and let the driver handle the options instead.</source>
          <target state="translated">并让驱动程序来处理这些选项。</target>
        </trans-unit>
        <trans-unit id="bfccb2c5c250efe79e7d9930697e9b24c391e2ac" translate="yes" xml:space="preserve">
          <source>and libraries in</source>
          <target state="translated">馆和图书馆</target>
        </trans-unit>
        <trans-unit id="f0e01a5c55ee31dbcc71234d1f7dd13b04392356" translate="yes" xml:space="preserve">
          <source>and must be explicitly requested since in C++ this isn&amp;rsquo;t an error and in C it might be harder to clean up all headers included.</source>
          <target state="translated">并且必须明确请求，因为在C ++中这不是错误，在C语言中清理包含的所有标头可能更困难。</target>
        </trans-unit>
        <trans-unit id="c8b774402ab6984eabd550c359a10ea00ca9ffbe" translate="yes" xml:space="preserve">
          <source>and optimization options should be specified at compile time and during the final link. It is recommended that you compile all the files participating in the same link with the same options and also specify those options at link time. For example:</source>
          <target state="translated">和优化选项应该在编译时和最终链接时指定。建议你用相同的选项编译所有参与同一链接的文件,并在链接时也指定这些选项。例如</target>
        </trans-unit>
        <trans-unit id="c7904d214a56c9420eebba683732a4bd59f75475" translate="yes" xml:space="preserve">
          <source>and other options cause warnings for many GNU C extensions. You can prevent such warnings within one expression by writing &lt;code&gt;__extension__&lt;/code&gt; before the expression. &lt;code&gt;__extension__&lt;/code&gt; has no effect aside from this.</source>
          <target state="translated">和其他选项会引起许多GNU C扩展的警告。您可以通过在表达式之前写上 &lt;code&gt;__extension__&lt;/code&gt; 来防止此类警告。 &lt;code&gt;__extension__&lt;/code&gt; 除此之外没有任何作用。</target>
        </trans-unit>
        <trans-unit id="737b71e6d8426b3fda4249cd8c1165da4988f20d" translate="yes" xml:space="preserve">
          <source>and outputs the command-line option</source>
          <target state="translated">并输出命令行选项</target>
        </trans-unit>
        <trans-unit id="4a51075a2d63bdd9c031332e64282ebb86738b8f" translate="yes" xml:space="preserve">
          <source>and passes them on to the running GCC to make them part of the aggregated GIMPLE image to be optimized.</source>
          <target state="translated">并将它们传递给正在运行的 GCC,使它们成为要优化的聚合 GIMPLE 映像的一部分。</target>
        </trans-unit>
        <trans-unit id="b7483c73e6a38e6274495270d12341498eeacbbb" translate="yes" xml:space="preserve">
          <source>and prevents linking with the shared libraries. On other systems, this option has no effect.</source>
          <target state="translated">并防止与共享库链接。在其他系统中,这个选项没有任何效果。</target>
        </trans-unit>
        <trans-unit id="123217ee99d19efe020f3f3466fda26930ff804c" translate="yes" xml:space="preserve">
          <source>and remove the</source>
          <target state="translated">并去除</target>
        </trans-unit>
        <trans-unit id="d0ba1984262756dc3e97eba7054a343cd95b906e" translate="yes" xml:space="preserve">
          <source>and sets the start address of the program to 0x800.</source>
          <target state="translated">并将程序的起始地址设置为0x800。</target>
        </trans-unit>
        <trans-unit id="ca533d5e239b86c5bce8e5223c75d9799ce24658" translate="yes" xml:space="preserve">
          <source>and so on. Most of these have both positive and negative forms; the negative form of</source>
          <target state="translated">诸如此类。其中大部分有正反两面的形式,负的形式有</target>
        </trans-unit>
        <trans-unit id="8448c2525daee3e2e6799cb7b66fc64c9ee09e88" translate="yes" xml:space="preserve">
          <source>and that the standard C libraries are</source>
          <target state="translated">而标准的C语言库是</target>
        </trans-unit>
        <trans-unit id="673968187c298fea9b969fc56a05d8e49cf79c7d" translate="yes" xml:space="preserve">
          <source>and the Fortran-specific</source>
          <target state="translated">和Fortran专用的</target>
        </trans-unit>
        <trans-unit id="584bb0d053da62487d41fcb63d90a5569011ef09" translate="yes" xml:space="preserve">
          <source>and the application be linked with</source>
          <target state="translated">并将该申请与</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
