<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="gcc">
    <body>
      <group id="gcc">
        <trans-unit id="64755c0a10d7b896808172cc7335112d4911d239" translate="yes" xml:space="preserve">
          <source>The maximum number of insns in a region to be considered for pipelining in the selective scheduler.</source>
          <target state="translated">在选择性调度器中,一个区域内考虑流水线的最大insn数量。</target>
        </trans-unit>
        <trans-unit id="7549b9d59e547801a424f6394451c0c5eb284456" translate="yes" xml:space="preserve">
          <source>The maximum number of insns in loop header duplicated by the copy loop headers pass.</source>
          <target state="translated">复制循环头传递的循环头中重复的最大insn数量。</target>
        </trans-unit>
        <trans-unit id="557a1591041c896c87813c7c44591df470e1d549" translate="yes" xml:space="preserve">
          <source>The maximum number of insns of a completely peeled loop.</source>
          <target state="translated">一个完全剥离的循环的最大ins数。</target>
        </trans-unit>
        <trans-unit id="6e77354bbeeb82418d9ce51f0cd208bdb1bdb528" translate="yes" xml:space="preserve">
          <source>The maximum number of insns of a peeled loop that rolls only once.</source>
          <target state="translated">一个剥皮圈的最大ins数,只滚动一次。</target>
        </trans-unit>
        <trans-unit id="e1366f0a190b8fba2e81ce94bc72ef8becba23f7" translate="yes" xml:space="preserve">
          <source>The maximum number of insns of an unswitched loop.</source>
          <target state="translated">一个无开关环路的最大insn数。</target>
        </trans-unit>
        <trans-unit id="cf7612b99e9ada1082074daa96e9458c5473af04" translate="yes" xml:space="preserve">
          <source>The maximum number of instruction reload should look backward for equivalent register. Increasing values mean more aggressive optimization, making the compilation time increase with probably slightly better performance.</source>
          <target state="translated">指令重载的最大次数应该向后看等效寄存器。增加数值意味着更积极的优化,使得编译时间增加,性能可能稍好。</target>
        </trans-unit>
        <trans-unit id="9005923e6a32b4692818d139c898763d96182dda" translate="yes" xml:space="preserve">
          <source>The maximum number of instructions CSE processes before flushing.</source>
          <target state="translated">冲洗前CSE处理的最大指令数。</target>
        </trans-unit>
        <trans-unit id="c9f4ccd7bf5ad2020d3e593506c55f6c162a5002" translate="yes" xml:space="preserve">
          <source>The maximum number of instructions biased by probabilities of their execution that a loop may have to be unrolled. If a loop is unrolled, this parameter also determines how many times the loop code is unrolled.</source>
          <target state="translated">循环可能要被取消滚动的最大指令数,偏重于其执行的概率。如果一个循环被展开,这个参数也决定了循环代码被展开的次数。</target>
        </trans-unit>
        <trans-unit id="6459fa6f8aa47f72deca9d3c9064156b11b3b7ad" translate="yes" xml:space="preserve">
          <source>The maximum number of instructions non-inline function can grow to via recursive inlining.</source>
          <target state="translated">通过递归内联,非内联函数可以增长到的最大指令数。</target>
        </trans-unit>
        <trans-unit id="f088738722ed99797643c1cd7fd24995b8cb099a" translate="yes" xml:space="preserve">
          <source>The maximum number of instructions ready to be issued the scheduler should consider at any given time during the first scheduling pass. Increasing values mean more thorough searches, making the compilation time increase with probably little benefit.</source>
          <target state="translated">调度器在第一次调度时,在任何给定的时间都应该考虑的准备发出的指令的最大数量。增加数值意味着更彻底的搜索,使得编译时间增加,但可能没有什么好处。</target>
        </trans-unit>
        <trans-unit id="751361661372b9f65beccbd7de6c9e13c4fb111d" translate="yes" xml:space="preserve">
          <source>The maximum number of instructions that a loop may have to be peeled. If a loop is peeled, this parameter also determines how many times the loop code is peeled.</source>
          <target state="translated">一个循环可能需要剥离的最大指令数。如果一个循环被剥离,这个参数也决定了循环代码被剥离的次数。</target>
        </trans-unit>
        <trans-unit id="7edf4c141bc3a24bbf2d50e04de689b5700fa130" translate="yes" xml:space="preserve">
          <source>The maximum number of instructions that a loop may have to be unrolled. If a loop is unrolled, this parameter also determines how many times the loop code is unrolled.</source>
          <target state="translated">一个循环可能要被展开的最大指令数。如果一个循环被展开,这个参数也决定了循环代码被展开的次数。</target>
        </trans-unit>
        <trans-unit id="b5c3a913df725fc3842845c874668062bf683170" translate="yes" xml:space="preserve">
          <source>The maximum number of instructions that an inner loop can have before the loop versioning pass considers it too big to copy.</source>
          <target state="translated">一个内部循环在循环版本传递认为它太大而无法复制之前可以拥有的最大指令数。</target>
        </trans-unit>
        <trans-unit id="0347a5207a00a0a94142de3b1cb1207696bb8750" translate="yes" xml:space="preserve">
          <source>The maximum number of instructions that an outer loop can have before the loop versioning pass considers it too big to copy, discounting any instructions in inner loops that directly benefit from versioning.</source>
          <target state="translated">一个外循环在循环版本化通证认为它太大而无法复制之前可以拥有的最大指令数,不考虑内部循环中任何直接受益于版本化的指令。</target>
        </trans-unit>
        <trans-unit id="cd3296c189a6eb29be66f9d755ea47f2387ef49d" translate="yes" xml:space="preserve">
          <source>The maximum number of instructions the RTL combiner tries to combine.</source>
          <target state="translated">RTL组合器尝试组合的最大指令数。</target>
        </trans-unit>
        <trans-unit id="cf3b05a5fc34087d71a21bfbdc9daebc782fc835" translate="yes" xml:space="preserve">
          <source>The maximum number of instructions to consider when looking for an instruction to fill a delay slot. If more than this arbitrary number of instructions are searched, the time savings from filling the delay slot are minimal, so stop searching. Increasing values mean more aggressive optimization, making the compilation time increase with probably small improvement in execution time.</source>
          <target state="translated">寻找填补延迟槽的指令时,要考虑的最大指令数。如果搜索的指令数量超过这个任意数量,那么填补延迟槽所节省的时间就微乎其微,所以停止搜索。数值越大,意味着更积极的优化,使得编译时间增加,而执行时间可能改善不大。</target>
        </trans-unit>
        <trans-unit id="f5be3b82586aa080f1846e1d109f72232bc815fe" translate="yes" xml:space="preserve">
          <source>The maximum number of instructions to duplicate to a block that jumps to a computed goto. To avoid &lt;em&gt;O(N^2)&lt;/em&gt; behavior in a number of passes, GCC factors computed gotos early in the compilation process, and unfactors them as late as possible. Only computed jumps at the end of a basic blocks with no more than max-goto-duplication-insns are unfactored.</source>
          <target state="translated">复制到跳转到计算的goto的块的最大指令数。为了避免多次通过&lt;em&gt;O（N ^ 2）&lt;/em&gt;行为，GCC因子会在编译过程的早期就计算出goto，并尽可能晚地取消分解。仅在基本块末尾的计算跳转（不超过max-goto-duplication-insns）是未分解的。</target>
        </trans-unit>
        <trans-unit id="f826bd5a9f2e555af6e39cc55fa38f4c63598849" translate="yes" xml:space="preserve">
          <source>The maximum number of iterations of a loop the brute-force algorithm for analysis of the number of iterations of the loop tries to evaluate.</source>
          <target state="translated">循环的最大迭代次数的蛮力算法分析循环的迭代次数尝试评估。</target>
        </trans-unit>
        <trans-unit id="827bc9985068a19acb40103212322373c4817b20" translate="yes" xml:space="preserve">
          <source>The maximum number of iterations of a loop to be suitable for complete peeling.</source>
          <target state="translated">循环的最大迭代次数,以适合完全剥离。</target>
        </trans-unit>
        <trans-unit id="6ed380824467ca338cf023f1dcb3f2de07822555" translate="yes" xml:space="preserve">
          <source>The maximum number of iterations through CFG to extend regions. A value of 0 disables region extensions.</source>
          <target state="translated">通过CFG扩展区域的最大迭代次数。值为0时,禁止扩展区域。</target>
        </trans-unit>
        <trans-unit id="3a4fe5f590fb9f1538c537c1032bfe7e933f8b30" translate="yes" xml:space="preserve">
          <source>The maximum number of loop iterations we predict statically. This is useful in cases where a function contains a single loop with known bound and another loop with unknown bound. The known number of iterations is predicted correctly, while the unknown number of iterations average to roughly 10. This means that the loop without bounds appears artificially cold relative to the other one.</source>
          <target state="translated">我们静态预测的最大循环迭代次数。这在一个函数包含一个已知边界的单循环和另一个未知边界的循环的情况下很有用。已知的迭代次数被正确预测,而未知的迭代次数平均约为10。这意味着,相对于另一个循环,没有边界的循环显得人为地冷清。</target>
        </trans-unit>
        <trans-unit id="6c4f0955c671eedabc4872cd4110ae5643c1e035" translate="yes" xml:space="preserve">
          <source>The maximum number of loop peels to enhance access alignment for vectorizer. Value -1 means no limit.</source>
          <target state="translated">循环剥离的最大次数,用于增强向量器的访问对齐。值-1表示没有限制。</target>
        </trans-unit>
        <trans-unit id="15a4d50649a3963909b22c32025925dae63b4133" translate="yes" xml:space="preserve">
          <source>The maximum number of may-defs we analyze when looking for a must-def specifying the dynamic type of an object that invokes a virtual call we may be able to devirtualize speculatively.</source>
          <target state="translated">我们分析的最大数量的may-def,当寻找一个must-def指定一个对象的动态类型,调用虚拟调用时,我们可能会猜测性地devirtualize。</target>
        </trans-unit>
        <trans-unit id="6a35d2bdd1c57297696d12360403e48281b63730" translate="yes" xml:space="preserve">
          <source>The maximum number of memory locations cselib should take into account. Increasing values mean more aggressive optimization, making the compilation time increase with probably slightly better performance.</source>
          <target state="translated">cselib应该考虑的最大内存位置数。增加这个值意味着更积极的优化,使得编译时间增加,但性能可能略微提高。</target>
        </trans-unit>
        <trans-unit id="d6a0df289b9860c6b27b724bd89cb2e25afbef7b" translate="yes" xml:space="preserve">
          <source>The maximum number of namespaces to consult for suggestions when C++ name lookup fails for an identifier.</source>
          <target state="translated">当一个标识符的C++名称查找失败时,可参考建议的名称空间的最大数量。</target>
        </trans-unit>
        <trans-unit id="511118b67bad71c8756d22dc67344a5b3d5a2116" translate="yes" xml:space="preserve">
          <source>The maximum number of peelings of a single loop.</source>
          <target state="translated">单个环路的最大剥皮次数。</target>
        </trans-unit>
        <trans-unit id="e8f1f05653238e3a565a30b9f73246f26306aaea" translate="yes" xml:space="preserve">
          <source>The maximum number of pending dependencies scheduling allows before flushing the current state and starting over. Large functions with few branches or calls can create excessively large lists which needlessly consume memory and resources.</source>
          <target state="translated">在刷新当前状态并重新开始之前,调度允许的最大挂起依赖数量。分支或调用较少的大型函数可能会创建过大的列表,从而无谓地消耗内存和资源。</target>
        </trans-unit>
        <trans-unit id="f0e89b0526dda27a2d7f3e6b7314e208af696219" translate="yes" xml:space="preserve">
          <source>The maximum number of run-time checks that can be performed when doing loop versioning for alias in the vectorizer.</source>
          <target state="translated">在向量器中对别名进行循环版本化时,可以执行的最大运行时检查次数。</target>
        </trans-unit>
        <trans-unit id="db0f184d4982d10802b0494be89c63889d9e1ea5" translate="yes" xml:space="preserve">
          <source>The maximum number of run-time checks that can be performed when doing loop versioning for alignment in the vectorizer.</source>
          <target state="translated">在向量器中进行循环版本对齐时,可以执行的最大运行时检查次数。</target>
        </trans-unit>
        <trans-unit id="50ff624d5ca7c27e89395fa51bbbe5ce28d3f9f1" translate="yes" xml:space="preserve">
          <source>The maximum number of stmts in a loop to be interchanged.</source>
          <target state="translated">循环中最大可交换的stmts数量。</target>
        </trans-unit>
        <trans-unit id="2862b2a5dc2c56cf5f469134e2bd6bad6e5964e7" translate="yes" xml:space="preserve">
          <source>The maximum number of stores to attempt to merge into wider stores in the store merging pass.</source>
          <target state="translated">门店合并通行证中尝试合并成更广泛的门店的最大数量。</target>
        </trans-unit>
        <trans-unit id="ae1a00d3b58c9f16d33b3348661fd11eee89c1d8" translate="yes" xml:space="preserve">
          <source>The maximum number of times a callsite can appear in a call stack within the analyzer, before terminating analysis of a call that would recurse deeper.</source>
          <target state="translated">在分析器内的调用堆栈中,一个调用点在终止分析一个会再深层递归的调用之前,可以出现的最大次数。</target>
        </trans-unit>
        <trans-unit id="6caef17bd294964937582b8b58bab7601c99e27b" translate="yes" xml:space="preserve">
          <source>The maximum number of times that an instruction is scheduled during selective scheduling. This is the limit on the number of iterations through which the instruction may be pipelined.</source>
          <target state="translated">在选择性调度期间,指令的最大调度次数。这是对指令可以通过流水线的迭代次数的限制。</target>
        </trans-unit>
        <trans-unit id="ddefe1cfc3442fba935b71446bc04ed2a446b364" translate="yes" xml:space="preserve">
          <source>The maximum number of times the outer loop should be unrolled by the unroll-and-jam transformation.</source>
          <target state="translated">通过展开-卡姆变换,外循环应展开的最大次数。</target>
        </trans-unit>
        <trans-unit id="1df2840a57590d0c992c35b1f7cd4db504ccf715" translate="yes" xml:space="preserve">
          <source>The maximum number of unrollings of a single loop.</source>
          <target state="translated">单个循环的最大开卷次数。</target>
        </trans-unit>
        <trans-unit id="06e4b31a55ed6d6ed41d2b2d48b6006b46bfa532" translate="yes" xml:space="preserve">
          <source>The maximum relative execution frequency (in percents) of the target block relative to a statement&amp;rsquo;s original block to allow statement sinking of a statement. Larger numbers result in more aggressive statement sinking. A small positive adjustment is applied for statements with memory operands as those are even more profitable so sink.</source>
          <target state="translated">目标块相对于语句的原始块的最大相对执行频率（以百分比为单位），以允许语句下沉一条语句。较大的数字会导致更激进的语句下沉。对于具有内存操作数的语句，将进行少量的正调整，因为这些语句甚至更有利可图，因此容易下沉。</target>
        </trans-unit>
        <trans-unit id="c4e2688875615cab366f32942394edf8b4b91705" translate="yes" xml:space="preserve">
          <source>The maximum size measured as number of RTLs that can be recorded in an expression in combiner for a pseudo register as last known value of that register.</source>
          <target state="translated">伪寄存器的最后一个已知值,在组合器的表达式中,以可以记录的RTL数量衡量的最大尺寸。</target>
        </trans-unit>
        <trans-unit id="159ffd5e6070239f87afd549cbfcfd8ded2b299d" translate="yes" xml:space="preserve">
          <source>The maximum size of the lookahead window of selective scheduling. It is a depth of search for available instructions.</source>
          <target state="translated">选择性调度的看前窗口的最大尺寸。它是对可用指令的搜索深度。</target>
        </trans-unit>
        <trans-unit id="f3da3af33190929d9965056fd52af9e74099ff3d" translate="yes" xml:space="preserve">
          <source>The memory order parameter is a signed int, but only the lower 16 bits are reserved for the memory order. The remainder of the signed int is reserved for target use and should be 0. Use of the predefined atomic values ensures proper usage.</source>
          <target state="translated">内存顺序参数是一个带符号的int,但只有低16位是为内存顺序保留的,带符号的int的剩余部分是为目标使用保留的,应该为0。使用预定义的原子值确保正确使用。</target>
        </trans-unit>
        <trans-unit id="9c9000c0e6476a4bcab6775fb476be520bb235b5" translate="yes" xml:space="preserve">
          <source>The memory-based pseudo-registers $mem0 through $mem15.</source>
          <target state="translated">基于内存的伪寄存器$mem0至$mem15。</target>
        </trans-unit>
        <trans-unit id="5f9aeac04a443a9f208cd4c4e6f4207cbf2bb24b" translate="yes" xml:space="preserve">
          <source>The message attached to the attribute is affected by the setting of the</source>
          <target state="translated">附加在属性上的信息受属性的设置影响。</target>
        </trans-unit>
        <trans-unit id="535f4a6df8d49970089b47a9552616a59f08c505" translate="yes" xml:space="preserve">
          <source>The message is in keeping with the output of</source>
          <target state="translated">该信息与</target>
        </trans-unit>
        <trans-unit id="22d9ad2ced8af2273cacd0833b5a4654b153618b" translate="yes" xml:space="preserve">
          <source>The method by which preprocessing tokens (possibly resulting from macro expansion) in a &lt;code&gt;#include&lt;/code&gt; directive are combined into a header name (C90 6.8.2, C99 and C11 6.10.2).</source>
          <target state="translated">将 &lt;code&gt;#include&lt;/code&gt; 指令中的预处理令牌（可能是宏扩展产生的）组合到标头名称中的方法（C90 6.8.2，C99和C11 6.10.2）。</target>
        </trans-unit>
        <trans-unit id="64dacbdf1cd80117047022b9711381d6ea5221d3" translate="yes" xml:space="preserve">
          <source>The method is called repeatedly during a fast enumeration to retrieve batches of objects. Each invocation of the method should retrieve the next batch of objects.</source>
          <target state="translated">该方法在快速枚举过程中被反复调用,以检索一批对象。每次调用该方法,都应该检索下一批对象。</target>
        </trans-unit>
        <trans-unit id="c7fa0fb8f65f5da5a26a900516ca2af75a19d924" translate="yes" xml:space="preserve">
          <source>The method used by GCC is as follows: a structure or union which is 1, 2, 4 or 8 bytes long is returned like a scalar. A structure or union with any other size is stored into an address supplied by the caller (usually in a special, fixed register, but on some machines it is passed on the stack). The target hook &lt;code&gt;TARGET_STRUCT_VALUE_RTX&lt;/code&gt; tells GCC where to pass this address.</source>
          <target state="translated">GCC使用的方法如下：返回1、2、4或8个字节长的结构或联合，就像标量一样。具有任何其他大小的结构或联合存储在调用方提供的地址中（通常存储在特殊的固定寄存器中，但在某些计算机上，它在堆栈上传递）。目标挂钩 &lt;code&gt;TARGET_STRUCT_VALUE_RTX&lt;/code&gt; 告诉GCC将该地址传递到哪里。</target>
        </trans-unit>
        <trans-unit id="cea71b7dec6652fd1c586605bdaf1afaabd9e0d7" translate="yes" xml:space="preserve">
          <source>The middle operand in a conditional expression may be omitted. Then if the first operand is nonzero, its value is the value of the conditional expression.</source>
          <target state="translated">条件表达式中的中间操作数可以省略。那么如果第一个操作数是非零,其值就是条件表达式的值。</target>
        </trans-unit>
        <trans-unit id="6b9ca9444f11bb1174b6690d0f150eb398c757b0" translate="yes" xml:space="preserve">
          <source>The mini registers r0 - r7.</source>
          <target state="translated">微型寄存器r0-r7。</target>
        </trans-unit>
        <trans-unit id="e080de9f963115473e6c7f8a5387551ad83e48b0" translate="yes" xml:space="preserve">
          <source>The minimal probability of speculation success (in percents), so that speculative insns are scheduled.</source>
          <target state="translated">投机成功的最小概率(百分数),这样投机ins就被安排了。</target>
        </trans-unit>
        <trans-unit id="aaffaaa968786a2da6ad4d8b8e0d5b378cb65a74" translate="yes" xml:space="preserve">
          <source>The minimum cost of an expensive expression in the loop invariant motion.</source>
          <target state="translated">循环不变运动中昂贵的表达方式的最小成本。</target>
        </trans-unit>
        <trans-unit id="efe3bb81fc851386e4b7cee22649ff792c38641a" translate="yes" xml:space="preserve">
          <source>The minimum fraction of profile runs a given basic block execution count must be not to be considered unlikely.</source>
          <target state="translated">给定的基本块执行数的最小部分的配置文件运行必须不被认为是不可能的。</target>
        </trans-unit>
        <trans-unit id="92f1b567f7a83d5184bace5014aac03377eeb221" translate="yes" xml:space="preserve">
          <source>The minimum number of instructions that must be matched at the end of two blocks before cross-jumping is performed on them. This value is ignored in the case where all instructions in the block being cross-jumped from are matched.</source>
          <target state="translated">在对两个块进行交叉跳转之前,必须在两个块的末尾匹配的指令的最少数量。在交叉跳转的块中所有指令都被匹配的情况下,该值被忽略。</target>
        </trans-unit>
        <trans-unit id="02c154dc267dae6541e650ecc75738b7fc1946c1" translate="yes" xml:space="preserve">
          <source>The minimum number of iterations per thread of an innermost parallelized loop for which the parallelized variant is preferred over the single threaded one. Note that for a parallelized loop nest the minimum number of iterations of the outermost loop per thread is two.</source>
          <target state="translated">最内侧的并行化循环每线程的最小迭代次数,对于这些循环,并行化变体比单线程更受欢迎。请注意,对于一个并行化循环嵌套,最外侧循环每线程的最小迭代次数是两次。</target>
        </trans-unit>
        <trans-unit id="2647f0a952db726e7e97cf159b9a0ce4dc6514c9" translate="yes" xml:space="preserve">
          <source>The minimum number of iterations under which loops are not vectorized when</source>
          <target state="translated">循环不被矢量化的最小迭代次数,当</target>
        </trans-unit>
        <trans-unit id="a016de6d4b3751317d101162f7adccf0bba87a22" translate="yes" xml:space="preserve">
          <source>The minimum number of supernodes within a function for the analyzer to consider summarizing its effects at call sites.</source>
          <target state="translated">一个函数内的超节点的最少数量,以便分析器考虑总结其在调用站点的效果。</target>
        </trans-unit>
        <trans-unit id="44ff09fc2cb3e08a9eb4ff0c94daf816032e979a" translate="yes" xml:space="preserve">
          <source>The minimum percentage of memory references that must be optimized away for the unroll-and-jam transformation to be considered profitable.</source>
          <target state="translated">必须优化掉的内存引用的最小百分比,以使 &quot;滚动-卡姆 &quot;转换被视为有利可图。</target>
        </trans-unit>
        <trans-unit id="129a020d6e4e2d22eefb43a7999c4dc2402a1a50" translate="yes" xml:space="preserve">
          <source>The minimum probability (in percents) of reaching a source block for interblock speculative scheduling.</source>
          <target state="translated">块间投机调度达到源块的最小概率(百分比)。</target>
        </trans-unit>
        <trans-unit id="dc4b50e8ed53d44237971958e2e83e18524eb941" translate="yes" xml:space="preserve">
          <source>The minimum probability an edge must have for the scheduler to save its state across it.</source>
          <target state="translated">一个边缘保存其状态的最小概率。</target>
        </trans-unit>
        <trans-unit id="61926ef9181910c24fa1d9136e2e7aa3bdc9bb32" translate="yes" xml:space="preserve">
          <source>The minimum ratio between stride of two loops for interchange to be profitable.</source>
          <target state="translated">两环之间的最小步距比,换乘才会有利可图。</target>
        </trans-unit>
        <trans-unit id="8e01e027a6a504c434a5c40600808d2984b71737" translate="yes" xml:space="preserve">
          <source>The minimum ratio between the number of instructions and the number of memory references to enable prefetching in a loop.</source>
          <target state="translated">指令数和内存引用数之间的最小比率,以实现循环中的预取。</target>
        </trans-unit>
        <trans-unit id="0c8448923459ab38ab3cc0b8bb13a936b3627b06" translate="yes" xml:space="preserve">
          <source>The minimum ratio between the number of instructions and the number of prefetches to enable prefetching in a loop.</source>
          <target state="translated">指令数与预取数之间的最小比率,以实现循环中的预取。</target>
        </trans-unit>
        <trans-unit id="8220c9492a5b7435fa642b1e05152b364a262db5" translate="yes" xml:space="preserve">
          <source>The minimum size of buffers (i.e. arrays) that receive stack smashing protection when</source>
          <target state="translated">砸堆保护时,缓冲区(即数组)的最小尺寸。</target>
        </trans-unit>
        <trans-unit id="13054edb9e1ab6c7cefbb0f40ba19b0915f9beae" translate="yes" xml:space="preserve">
          <source>The minimum size of variables taking part in stack slot sharing when not optimizing.</source>
          <target state="translated">不优化时参加栈槽共享的变量的最小尺寸。</target>
        </trans-unit>
        <trans-unit id="2c2de50582a702ec4d7ad2fc7c8e60438b0f0aa8" translate="yes" xml:space="preserve">
          <source>The minimum value of stage count that swing modulo scheduler generates.</source>
          <target state="translated">摆动模数调度器产生的阶段数的最小值。</target>
        </trans-unit>
        <trans-unit id="e61665509912f06aa6c9cfa2083ef8e16d79724c" translate="yes" xml:space="preserve">
          <source>The most straightforward way to link a program to use a particular C++ library is to use a C++ driver that specifies that C++ library by default. The &lt;code&gt;g++&lt;/code&gt; driver, for example, tells the linker where to find GCC&amp;rsquo;s C++ library (</source>
          <target state="translated">链接程序以使用特定C ++库的最直接方法是使用默认情况下指定该C ++库的C ++驱动程序。在 &lt;code&gt;g++&lt;/code&gt; 驱动程序，例如，告知链接在哪里可以找到GCC的C ++库（</target>
        </trans-unit>
        <trans-unit id="df6349c8ef5b50987899abffe38003acbe800a64" translate="yes" xml:space="preserve">
          <source>The multiprocessing extension.</source>
          <target state="translated">多处理扩展。</target>
        </trans-unit>
        <trans-unit id="8d24347b639fc5c1199b8f3590bff6a146e13c82" translate="yes" xml:space="preserve">
          <source>The name of the function.</source>
          <target state="translated">功能的名称。</target>
        </trans-unit>
        <trans-unit id="62e8e383964ec0763f310d8e73ac1d3feb12f8de" translate="yes" xml:space="preserve">
          <source>The names of specific parameters, and the meaning of the values, are tied to the internals of the compiler, and are subject to change without notice in future releases.</source>
          <target state="translated">特定参数的名称和值的含义与编译器的内部结构有关,在未来的版本中可能会发生变化,恕不另行通知。</target>
        </trans-unit>
        <trans-unit id="329fe73400bc50b68cb243f0ab550043e7c95935" translate="yes" xml:space="preserve">
          <source>The native Linux/GNU toolchain also supports the value &amp;lsquo;</source>
          <target state="translated">本机Linux / GNU工具链还支持值'</target>
        </trans-unit>
        <trans-unit id="04c44aa6fff9d063f62cf98bb0599d7c6a3d3bb6" translate="yes" xml:space="preserve">
          <source>The nested function can access all the variables of the containing function that are visible at the point of its definition. This is called &lt;em&gt;lexical scoping&lt;/em&gt;. For example, here we show a nested function which uses an inherited variable named &lt;code&gt;offset&lt;/code&gt;:</source>
          <target state="translated">嵌套函数可以访问包含函数的所有变量，这些变量在其定义点可见。这称为&lt;em&gt;词汇作用域&lt;/em&gt;。例如，这里显示一个嵌套函数，该函数使用一个名为 &lt;code&gt;offset&lt;/code&gt; 的继承变量：</target>
        </trans-unit>
        <trans-unit id="d50cb616ffb2082a3e3b7e7c2d21914b6c5a5b8a" translate="yes" xml:space="preserve">
          <source>The nested function&amp;rsquo;s name is local to the block where it is defined. For example, here we define a nested function named &lt;code&gt;square&lt;/code&gt;, and call it twice:</source>
          <target state="translated">嵌套函数的名称在定义它的块的本地。例如，在这里我们定义一个名为 &lt;code&gt;square&lt;/code&gt; 的嵌套函数，并调用两次：</target>
        </trans-unit>
        <trans-unit id="2a845c4dca5c001e6d102157bfd313918d6f8a24" translate="yes" xml:space="preserve">
          <source>The nesting limit for &lt;code&gt;#include&lt;/code&gt; processing (C90 6.8.2, C99 and C11 6.10.2).</source>
          <target state="translated">&lt;code&gt;#include&lt;/code&gt; 处理的嵌套限制（C90 6.8.2，C99和C11 6.10.2）。</target>
        </trans-unit>
        <trans-unit id="1446b5bc47ae4093c3d59b0d15fb2e41a888d931" translate="yes" xml:space="preserve">
          <source>The next example shows a case where the optimizers can recognize that the input (&lt;code&gt;dwSomeValue&lt;/code&gt;) never changes during the execution of the function and can therefore move the &lt;code&gt;asm&lt;/code&gt; outside the loop to produce more efficient code. Again, using the &lt;code&gt;volatile&lt;/code&gt; qualifier disables this type of optimization.</source>
          <target state="translated">下一个示例显示了一种情况，优化器可以识别出输入（ &lt;code&gt;dwSomeValue&lt;/code&gt; ）在函数执行期间永不改变，因此可以将 &lt;code&gt;asm&lt;/code&gt; 移出循环以产生更有效的代码。同样，使用 &lt;code&gt;volatile&lt;/code&gt; 限定词会禁用这种类型的优化。</target>
        </trans-unit>
        <trans-unit id="90026784c98f629fb36fb07ae9132c36ffa32047" translate="yes" xml:space="preserve">
          <source>The next revision of the ISO C++ standard, planned for 2020. Support is highly experimental, and will almost certainly change in incompatible ways in future releases.</source>
          <target state="translated">ISO C++标准的下一个修订版,计划于2020年发布。支持是高度实验性的,在未来的版本中几乎肯定会以不兼容的方式改变。</target>
        </trans-unit>
        <trans-unit id="1737091e750836f7db5ac991c2404cb583f13f75" translate="yes" xml:space="preserve">
          <source>The next revision of the ISO C++ standard, tentatively planned for 2020. Support is highly experimental, and will almost certainly change in incompatible ways in future releases.</source>
          <target state="translated">ISO C++标准的下一个修订版,暂定于2020年。支持是高度实验性的,在未来的版本中几乎肯定会以不兼容的方式改变。</target>
        </trans-unit>
        <trans-unit id="07fa07f1abd567516650f6c81218681c600c92af" translate="yes" xml:space="preserve">
          <source>The next version of the ISO C standard, still under development, plus GNU extensions. The support for this version is experimental and incomplete.</source>
          <target state="translated">ISO C标准的下一个版本,仍在开发中,加上GNU的扩展。这个版本的支持是试验性的,不完整的。</target>
        </trans-unit>
        <trans-unit id="2b02aa6b6d3d78493fbc1dc480d37a214f73df64" translate="yes" xml:space="preserve">
          <source>The next version of the ISO C standard, still under development. The support for this version is experimental and incomplete.</source>
          <target state="translated">ISO C标准的下一个版本,仍在开发中。该版本的支持是试验性的,不完整的。</target>
        </trans-unit>
        <trans-unit id="2f0fbf82a063b2707d9377f7fa702f1fc2dca6a1" translate="yes" xml:space="preserve">
          <source>The nine trigraphs and their replacements are</source>
          <target state="translated">九宫格及其替代物为</target>
        </trans-unit>
        <trans-unit id="d3e272d2493136e9ddd803eb8bb6b214c461ac69" translate="yes" xml:space="preserve">
          <source>The nineteen 32-bit registers comprising general register R0 to R14, control register GBR, and system registers MACH, MACL, and PR and the vector table address offset are saved into a register bank. Register banks are stacked in first-in last-out (FILO) sequence. Restoration from the bank is executed by issuing a RESBANK instruction.</source>
          <target state="translated">由通用寄存器R0~R14、控制寄存器GBR和系统寄存器MACH、MACL、PR组成的19个32位寄存器以及矢量表地址偏移量被保存到一个寄存器库中。寄存器库按先入后出(FILO)顺序堆叠。通过发出RESBANK指令来执行从寄存器库中恢复。</target>
        </trans-unit>
        <trans-unit id="3ee0e8fe4a16194f52480c8cf2068fc9bdcd0c7f" translate="yes" xml:space="preserve">
          <source>The non-atomic types are encoded as follows:</source>
          <target state="translated">非原子类型的编码如下:</target>
        </trans-unit>
        <trans-unit id="7bfaebfb4258608ad40629ce440aac9193290911" translate="yes" xml:space="preserve">
          <source>The normal vector extract, and set operations work on &lt;var&gt;vector __int128&lt;/var&gt; and &lt;var&gt;vector __uint128&lt;/var&gt; types, but the index value must be 0.</source>
          <target state="translated">正常的向量提取和设置操作适用于 &lt;var&gt;vector __int128&lt;/var&gt; 和 &lt;var&gt;vector __uint128&lt;/var&gt; 类型，但索引值必须为0。</target>
        </trans-unit>
        <trans-unit id="ec51f6eb264a163ff7656783d752463b0cf474e2" translate="yes" xml:space="preserve">
          <source>The null pointer constant to which the macro &lt;code&gt;NULL&lt;/code&gt; expands (C90 7.1.6, C99 7.17, C11 7.19).</source>
          <target state="translated">宏 &lt;code&gt;NULL&lt;/code&gt; 扩展到的空指针常量（C90 7.1.6，C99 7.17，C11 7.19）。</target>
        </trans-unit>
        <trans-unit id="28be55da2d33dfd035a16c7e12609f9fde68fbf1" translate="yes" xml:space="preserve">
          <source>The number of Newton iterations for calculating the reciprocal for double type. The precision of division is propotional to this param when division approximation is enabled. The default value is 2.</source>
          <target state="translated">用于计算双倍型倒数的牛顿迭代次数。启用除法近似时,除法的精度与此参数相关。默认值为2。</target>
        </trans-unit>
        <trans-unit id="6669979f69801134fe5425b263914957ab4a88a7" translate="yes" xml:space="preserve">
          <source>The number of Newton iterations for calculating the reciprocal for float type. The precision of division is proportional to this param when division approximation is enabled. The default value is 1.</source>
          <target state="translated">用于计算浮点类型的倒数的牛顿迭代次数。启用除法近似时,除法的精度与此参数成正比。默认值为1。</target>
        </trans-unit>
        <trans-unit id="38d03781cbc2651157f17e0c5fbab40ff5879c62" translate="yes" xml:space="preserve">
          <source>The number of bits in a byte (C90 3.4, C99 and C11 3.6).</source>
          <target state="translated">一个字节中的位数(C90 3.4、C99和C11 3.6)。</target>
        </trans-unit>
        <trans-unit id="5116832175ad50d3f8b15e3495e553905314a198" translate="yes" xml:space="preserve">
          <source>The number of cycles the swing modulo scheduler considers when checking conflicts using DFA.</source>
          <target state="translated">使用DFA检查冲突时,摆动模数调度器考虑的周期数。</target>
        </trans-unit>
        <trans-unit id="4fb7b94d708168700c159e251d0f9d5fce1fc8c3" translate="yes" xml:space="preserve">
          <source>The number of elements for which hash table verification is done for each searched element.</source>
          <target state="translated">对每个搜索到的元素进行哈希表验证的元素数量。</target>
        </trans-unit>
        <trans-unit id="0a72ad254c79a1eea72a19a4968bbd0e5a7dddcb" translate="yes" xml:space="preserve">
          <source>The number of executions of a basic block which is considered hot. The parameter is used only in GIMPLE FE.</source>
          <target state="translated">被认为是热块的基本块的执行次数。该参数仅在GIMPLE FE中使用。</target>
        </trans-unit>
        <trans-unit id="ce1f697b40b6aa8756d941d13116c5069d63cf0d" translate="yes" xml:space="preserve">
          <source>The number of most executed permilles, ranging from 0 to 1000, of the profiled execution of the entire program to which the execution count of a basic block must be part of in order to be considered hot. The default is 990, which means that a basic block is considered hot if its execution count contributes to the upper 990 permilles, or 99.0%, of the profiled execution of the entire program. 0 means that it is never considered hot. Used in LTO mode.</source>
          <target state="translated">基本块的执行次数必须是整个程序的最多执行次数的permilles的一部分,范围从0到1000不等,才能被认为是热块。默认值是990,这意味着如果一个基本块的执行次数占整个程序的上990个permilles,或者说占整个程序的99.0%,那么它就被认为是热块。0意味着它永远不会被认为是热块。在LTO模式下使用。</target>
        </trans-unit>
        <trans-unit id="1520c1ee154295eb07c627660dca8d1a6b6092fb" translate="yes" xml:space="preserve">
          <source>The number of significant initial characters in an identifier (C90 6.1.2, C90, C99 and C11 5.2.4.1, C99 and C11 6.4.2).</source>
          <target state="translated">识别符中重要的首字符数(C90 6.1.2、C90、C99和C11 5.2.4.1、C99和C11 6.4.2);</target>
        </trans-unit>
        <trans-unit id="070362ab17f17b33a3ae34d59055a18a1e302bf9" translate="yes" xml:space="preserve">
          <source>The number, order, and encoding of bytes in any object (when not explicitly specified in this International Standard) (C99 and C11 6.2.6.1).</source>
          <target state="translated">任何对象中字节的数量、顺序和编码(当本国际标准没有明确规定时)(C99和C11 6.2.6.1)。</target>
        </trans-unit>
        <trans-unit id="b604e74e2e851789383571b70ad652997e4e66f6" translate="yes" xml:space="preserve">
          <source>The object is accessed with the respective segment override prefix.</source>
          <target state="translated">该对象用各自的段覆盖前缀访问。</target>
        </trans-unit>
        <trans-unit id="3a5091aabdc201178dc68e9213e404a14e73a3fa" translate="yes" xml:space="preserve">
          <source>The object pointed to by the first argument must be of integer or pointer type. It must not be a boolean type.</source>
          <target state="translated">第一个参数所指向的对象必须是整数或指针类型。不得是布尔类型。</target>
        </trans-unit>
        <trans-unit id="a4db2564696e493fee1ef7423f76307823d51b1d" translate="yes" xml:space="preserve">
          <source>The object pointed to by the first argument must be of integer or pointer type. It must not be a boolean type. All memory orders are valid.</source>
          <target state="translated">第一个参数所指向的对象必须是整数或指针类型。不能是布尔类型。所有的内存顺序都是有效的。</target>
        </trans-unit>
        <trans-unit id="13e4eecfa7c007179ae8943f279500072d8d783d" translate="yes" xml:space="preserve">
          <source>The only difference between &amp;lsquo;</source>
          <target state="translated">'之间的唯一区别</target>
        </trans-unit>
        <trans-unit id="e3de508e233b8d2680fdf435e3d6c8313768a8db" translate="yes" xml:space="preserve">
          <source>The only supported use for this feature is to specify registers for input and output operands when calling Extended &lt;code&gt;asm&lt;/code&gt; (see &lt;a href=&quot;extended-asm#Extended-Asm&quot;&gt;Extended Asm&lt;/a&gt;). This may be necessary if the constraints for a particular machine don&amp;rsquo;t provide sufficient control to select the desired register. To force an operand into a register, create a local variable and specify the register name after the variable&amp;rsquo;s declaration. Then use the local variable for the &lt;code&gt;asm&lt;/code&gt; operand and specify any constraint letter that matches the register:</source>
          <target state="translated">此功能唯一受支持的用途是在调用Extended &lt;code&gt;asm&lt;/code&gt; 时为输入和输出操作数指定寄存器（请参见&lt;a href=&quot;extended-asm#Extended-Asm&quot;&gt;Extended Asm&lt;/a&gt;）。如果特定机器的约束条件不能提供足够的控制来选择所需的寄存器，则这可能是必要的。若要将操作数强制进入寄存器，请创建一个局部变量，并在变量的声明后指定寄存器名称。然后将局部变量用于 &lt;code&gt;asm&lt;/code&gt; 操作数，并指定与寄存器匹配的任何约束字母：</target>
        </trans-unit>
        <trans-unit id="80fd38457618adab2fab3528f71d1285f53dd5df" translate="yes" xml:space="preserve">
          <source>The operand is the number of a register to be read. Generates:</source>
          <target state="translated">操作数是要读取的寄存器的编号。生成。</target>
        </trans-unit>
        <trans-unit id="164925c793e36006eed2abf2f19f4ef48755a0ed" translate="yes" xml:space="preserve">
          <source>The operand of &lt;code&gt;typeof&lt;/code&gt; is evaluated for its side effects if and only if it is an expression of variably modified type or the name of such a type.</source>
          <target state="translated">当且仅当它是可变修饰类型的表达式或这种类型的名称时， &lt;code&gt;typeof&lt;/code&gt; 操作数的副作用进行评估。</target>
        </trans-unit>
        <trans-unit id="6d2a4c2f3546ef01bb01773e4920ca0359e67ac5" translate="yes" xml:space="preserve">
          <source>The operand, &lt;var&gt;auxv&lt;/var&gt;, is the address of an auxiliary register and must be a compile time constant. Generates:</source>
          <target state="translated">操作数 &lt;var&gt;auxv&lt;/var&gt; 是辅助寄存器的地址，并且必须是编译时间常数。产生：</target>
        </trans-unit>
        <trans-unit id="3479099f68d087cc74ace860bc00a95f5b731c1f" translate="yes" xml:space="preserve">
          <source>The operations behave like C++ &lt;code&gt;valarrays&lt;/code&gt;. Addition is defined as the addition of the corresponding elements of the operands. For example, in the code below, each of the 4 elements in &lt;var&gt;a&lt;/var&gt; is added to the corresponding 4 elements in &lt;var&gt;b&lt;/var&gt; and the resulting vector is stored in &lt;var&gt;c&lt;/var&gt;.</source>
          <target state="translated">操作的行为类似于C ++ &lt;code&gt;valarrays&lt;/code&gt; 。加法定义为操作数对应元素的加法。例如，在下面的代码中，将 &lt;var&gt;a&lt;/var&gt; 中的4个元素中的每个元素添加到 &lt;var&gt;b&lt;/var&gt; 中相应的4个元素中，并将结果向量存储在 &lt;var&gt;c&lt;/var&gt; 中。</target>
        </trans-unit>
        <trans-unit id="fde6238c26830fa82a53914b9244e589ab1e426d" translate="yes" xml:space="preserve">
          <source>The operator &amp;lsquo;</source>
          <target state="translated">运营商 '</target>
        </trans-unit>
        <trans-unit id="e6c35a6661bd8051bda6c84d11bcf3693039836f" translate="yes" xml:space="preserve">
          <source>The opposite</source>
          <target state="translated">恰恰相反</target>
        </trans-unit>
        <trans-unit id="8d9594a87362ce1971b7a9efe4bfc116ba95e426" translate="yes" xml:space="preserve">
          <source>The option</source>
          <target state="translated">该选项</target>
        </trans-unit>
        <trans-unit id="ae1ce068a17e5dbe0ea035d1beb9f2b11368df02" translate="yes" xml:space="preserve">
          <source>The option also sets the ISA to use. If the MCU name is one that is known to only support the 430 ISA then that is selected, otherwise the 430X ISA is selected. A generic MCU name of &amp;lsquo;</source>
          <target state="translated">该选项还设置要使用的ISA。如果MCU名称是已知仅支持430 ISA的名称，则选择该名称，否则选择430X ISA。通用MCU名称为&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="bace175215f4c9a9a5086a4520e874099d58bc7b" translate="yes" xml:space="preserve">
          <source>The option cannot be combined with</source>
          <target state="translated">该选项不能与</target>
        </trans-unit>
        <trans-unit id="c9e6b8f7b2e1e4a87728188dd3bdb8e34222fb03" translate="yes" xml:space="preserve">
          <source>The option has three forms:</source>
          <target state="translated">该方案有三种形式。</target>
        </trans-unit>
        <trans-unit id="f57372a8b45a9a651870f464f28239ea0a9400c1" translate="yes" xml:space="preserve">
          <source>The option is equivalent to</source>
          <target state="translated">该方案相当于</target>
        </trans-unit>
        <trans-unit id="25431ae1de44b7a0042861eaf001a15d12b77c5c" translate="yes" xml:space="preserve">
          <source>The option is similar to</source>
          <target state="translated">该选项类似于</target>
        </trans-unit>
        <trans-unit id="3f0b2b21730ed2a5e07ab579f0c874433e03d81f" translate="yes" xml:space="preserve">
          <source>The option&amp;rsquo;s behavior depends on the</source>
          <target state="translated">该选项的行为取决于</target>
        </trans-unit>
        <trans-unit id="7003d8dcf16f832eac06c03046c9a171fa807708" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;volatile&lt;/code&gt; qualifier has no effect. All basic &lt;code&gt;asm&lt;/code&gt; blocks are implicitly volatile.</source>
          <target state="translated">可选的 &lt;code&gt;volatile&lt;/code&gt; 限定符无效。所有基本的 &lt;code&gt;asm&lt;/code&gt; 块都是隐式易失的。</target>
        </trans-unit>
        <trans-unit id="74a01a1e7aeded7ac16f376b31f6e97656f61592" translate="yes" xml:space="preserve">
          <source>The optional &lt;var&gt;sirevision&lt;/var&gt; specifies the silicon revision of the target Blackfin processor. Any workarounds available for the targeted silicon revision are enabled. If &lt;var&gt;sirevision&lt;/var&gt; is &amp;lsquo;</source>
          <target state="translated">可选的 &lt;var&gt;sirevision&lt;/var&gt; 指定目标Blackfin处理器的芯片版本。启用了适用于目标芯片版本的所有解决方法。如果 &lt;var&gt;sirevision&lt;/var&gt; 为'</target>
        </trans-unit>
        <trans-unit id="875be52030ba25094435899fd42d910088a7a954" translate="yes" xml:space="preserve">
          <source>The optional &lt;var&gt;size-index&lt;/var&gt; positional argument denotes a function argument of integer type that specifies the maximum size of the access. The size is the number of elements of the type referenced by &lt;var&gt;ref-index&lt;/var&gt;, or the number of bytes when the pointer type is &lt;code&gt;void*&lt;/code&gt;. When no &lt;var&gt;size-index&lt;/var&gt; argument is specified, the pointer argument must be either null or point to a space that is suitably aligned and large for at least one object of the referenced type (this implies that a past-the-end pointer is not a valid argument). The actual size of the access may be less but it must not be more.</source>
          <target state="translated">可选的 &lt;var&gt;size-index&lt;/var&gt; 位置参数表示整数类型的函数参数，该函数参数指定访问的最大大小。 size是 &lt;var&gt;ref-index&lt;/var&gt; 引用的类型的元素数，或者是指针类型为 &lt;code&gt;void*&lt;/code&gt; 时的字节数。如果未指定 &lt;var&gt;size-index&lt;/var&gt; 参数，则指针参数必须为null或指向一个适当对齐的空间，该空间对于至少一个引用类型的对象是适当的（这意味着过去指针不是有效参数）。访问的实际大小可以更小，但不能更大。</target>
        </trans-unit>
        <trans-unit id="f72849bef73954b968c2b10753acfe7d2de97d61" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;var&gt;mask&lt;/var&gt; may have the value &lt;code&gt;notinbranch&lt;/code&gt; or &lt;code&gt;inbranch&lt;/code&gt;, and instructs the compiler to generate non-masked or masked clones correspondingly. By default, all clones are generated.</source>
          <target state="translated">可选参数 &lt;var&gt;mask&lt;/var&gt; 的值可以为 &lt;code&gt;notinbranch&lt;/code&gt; 或 &lt;code&gt;inbranch&lt;/code&gt; ，并指示编译器相应地生成非掩码或掩码的克隆。默认情况下，将生成所有克隆。</target>
        </trans-unit>
        <trans-unit id="bf601c68a359b3325301de84f8214ec6cb3bee0d" translate="yes" xml:space="preserve">
          <source>The optional extension of specifying vector constants in parentheses is not supported.</source>
          <target state="translated">不支持在括号中指定向量常数的可选扩展。</target>
        </trans-unit>
        <trans-unit id="8e1def618310843db3ebed1e3d40c1b748262844" translate="yes" xml:space="preserve">
          <source>The optional first word limits the specification to structs that are used directly (&amp;lsquo;</source>
          <target state="translated">可选的第一个字将规范限制为直接使用的结构（&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="a9fe5708942d28978cc841b9258dd8862934e265" translate="yes" xml:space="preserve">
          <source>The optional second word limits the specification to ordinary structs (&amp;lsquo;</source>
          <target state="translated">可选的第二个字将规范限制为普通结构（'</target>
        </trans-unit>
        <trans-unit id="01a150b476753c90be937c4eb85655e5b29ceeef" translate="yes" xml:space="preserve">
          <source>The options</source>
          <target state="translated">选项</target>
        </trans-unit>
        <trans-unit id="ac4a8e159eb45db26e41d6b181749d12e91d13f3" translate="yes" xml:space="preserve">
          <source>The options from each group can be freely mixed as they are non-overlapping. However, in case of any conflicts, the later options override the earlier options on the command line.</source>
          <target state="translated">每个组的选项可以自由混合,因为它们是不重叠的。但是,如果有任何冲突,后面的选项将优先于命令行上的早期选项。</target>
        </trans-unit>
        <trans-unit id="03370c70b8d685b972b4178e392c07f67da021e0" translate="yes" xml:space="preserve">
          <source>The options in this section are defined for all VxWorks targets. Options specific to the target hardware are listed with the other options for that target.</source>
          <target state="translated">本节中的选项是为所有 VxWorks 目标定义的。特定于目标硬件的选项与该目标的其他选项一起列出。</target>
        </trans-unit>
        <trans-unit id="ee4645ad9aafdb886f64431f817492a531da45bb" translate="yes" xml:space="preserve">
          <source>The options supported are specific to each target; refer to &lt;a href=&quot;x86-function-attributes#x86-Function-Attributes&quot;&gt;x86 Function Attributes&lt;/a&gt;, &lt;a href=&quot;powerpc-function-attributes#PowerPC-Function-Attributes&quot;&gt;PowerPC Function Attributes&lt;/a&gt;, &lt;a href=&quot;arm-function-attributes#ARM-Function-Attributes&quot;&gt;ARM Function Attributes&lt;/a&gt;, &lt;a href=&quot;aarch64-function-attributes#AArch64-Function-Attributes&quot;&gt;AArch64 Function Attributes&lt;/a&gt;, &lt;a href=&quot;nios-ii-function-attributes#Nios-II-Function-Attributes&quot;&gt;Nios II Function Attributes&lt;/a&gt;, and &lt;a href=&quot;s_002f390-function-attributes#S_002f390-Function-Attributes&quot;&gt;S/390 Function Attributes&lt;/a&gt; for details.</source>
          <target state="translated">支持的选项特定于每个目标。有关详细信息，请参见&lt;a href=&quot;x86-function-attributes#x86-Function-Attributes&quot;&gt;x86功能属性&lt;/a&gt;，&lt;a href=&quot;powerpc-function-attributes#PowerPC-Function-Attributes&quot;&gt;PowerPC功能属性&lt;/a&gt;，&lt;a href=&quot;arm-function-attributes#ARM-Function-Attributes&quot;&gt;ARM功能属性&lt;/a&gt;，&lt;a href=&quot;aarch64-function-attributes#AArch64-Function-Attributes&quot;&gt;AArch64功能属性&lt;/a&gt;，&lt;a href=&quot;nios-ii-function-attributes#Nios-II-Function-Attributes&quot;&gt;Nios II功能属性&lt;/a&gt;和&lt;a href=&quot;s_002f390-function-attributes#S_002f390-Function-Attributes&quot;&gt;S / 390功能属性&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="91a395788ed90836d2997bb1c84003ea7ffde770" translate="yes" xml:space="preserve">
          <source>The options work exactly like the S/390 specific command line options (without the prefix</source>
          <target state="translated">这些选项的工作原理与S/390特定的命令行选项完全相同(没有前缀的</target>
        </trans-unit>
        <trans-unit id="e9e8fa6c8ae05f8e2a34557e6036eae0a9b76ff8" translate="yes" xml:space="preserve">
          <source>The order in which &lt;code&gt;+load&lt;/code&gt; and &lt;code&gt;+initialize&lt;/code&gt; are called could be problematic if this matters. If you don&amp;rsquo;t allocate objects inside &lt;code&gt;+load&lt;/code&gt;, it is guaranteed that &lt;code&gt;+load&lt;/code&gt; is called before &lt;code&gt;+initialize&lt;/code&gt;. If you create an object inside &lt;code&gt;+load&lt;/code&gt; the &lt;code&gt;+initialize&lt;/code&gt; method of object&amp;rsquo;s class is invoked even if &lt;code&gt;+load&lt;/code&gt; was not invoked. Note if you explicitly call &lt;code&gt;+load&lt;/code&gt; on a class, &lt;code&gt;+initialize&lt;/code&gt; will be called first. To avoid possible problems try to implement only one of these methods.</source>
          <target state="translated">如果这很重要，则调用 &lt;code&gt;+load&lt;/code&gt; 和 &lt;code&gt;+initialize&lt;/code&gt; 的顺序可能会出现问题。如果您没有在 &lt;code&gt;+load&lt;/code&gt; 内部分配对象，则可以确保 &lt;code&gt;+load&lt;/code&gt; 在 &lt;code&gt;+initialize&lt;/code&gt; 之前被调用。如果在 &lt;code&gt;+load&lt;/code&gt; 内创建对象，则即使未调用 &lt;code&gt;+load&lt;/code&gt; ，也会调用对象类的 &lt;code&gt;+initialize&lt;/code&gt; 方法。请注意，如果您在类上显式调用 &lt;code&gt;+load&lt;/code&gt; ，则将首先调用 &lt;code&gt;+initialize&lt;/code&gt; 。为避免可能的问题，请尝试仅实现这些方法之一。</target>
        </trans-unit>
        <trans-unit id="d72c8cfa2bf4559a476794fbcac9230458dd1acf" translate="yes" xml:space="preserve">
          <source>The order of allocation of bit-fields within a unit (C90 6.5.2.1, C99 and C11 6.7.2.1).</source>
          <target state="translated">单位内位场的分配顺序(C90 6.5.2.1、C99和C11 6.7.2.1);</target>
        </trans-unit>
        <trans-unit id="13bf99243d90e9f90c583730aacfa820007d4c7a" translate="yes" xml:space="preserve">
          <source>The ordering and number of these preamble lines will be augmented as &lt;code&gt;gcov&lt;/code&gt; development progresses &amp;mdash; do not rely on them remaining unchanged. Use &lt;var&gt;tag&lt;/var&gt; to locate a particular preamble line.</source>
          <target state="translated">随着 &lt;code&gt;gcov&lt;/code&gt; 开发的进展，这些序言行的顺序和数量将会增加-不要依赖于它们保持不变。使用 &lt;var&gt;tag&lt;/var&gt; 找到特定的前导行。</target>
        </trans-unit>
        <trans-unit id="f78a9eb6841c341650bf4b7b23dd41a17afa341e" translate="yes" xml:space="preserve">
          <source>The original ANSI C standard (X3.159-1989) was ratified in 1989 and published in 1990. This standard was ratified as an ISO standard (ISO/IEC 9899:1990) later in 1990. There were no technical differences between these publications, although the sections of the ANSI standard were renumbered and became clauses in the ISO standard. The ANSI standard, but not the ISO standard, also came with a Rationale document. This standard, in both its forms, is commonly known as &lt;em&gt;C89&lt;/em&gt;, or occasionally as &lt;em&gt;C90&lt;/em&gt;, from the dates of ratification. To select this standard in GCC, use one of the options</source>
          <target state="translated">最初的ANSI C标准（X3.159-1989）于1989年批准并于1990年发布。该标准于1990年晚些时候被批准为ISO标准（ISO / IEC 9899：1990）。这些出版物之间没有技术差异，尽管ANSI标准的各个部分已重新编号，并成为ISO标准中的子句。 ANSI标准（而非ISO标准）也随附了Rationale文档。从批准之日起，这两种标准的形式通常被称为&lt;em&gt;C89&lt;/em&gt;或偶尔被称为&lt;em&gt;C90&lt;/em&gt;。要在GCC中选择此标准，请使用以下选项之一</target>
        </trans-unit>
        <trans-unit id="21c496279e266f5ecd75f883afecb2192cd2a917" translate="yes" xml:space="preserve">
          <source>The original ISO C++ standard was published as the ISO standard (ISO/IEC 14882:1998) and amended by a Technical Corrigenda published in 2003 (ISO/IEC 14882:2003). These standards are referred to as C++98 and C++03, respectively. GCC implements the majority of C++98 (&lt;code&gt;export&lt;/code&gt; is a notable exception) and most of the changes in C++03. To select this standard in GCC, use one of the options</source>
          <target state="translated">最初的ISO C ++标准已发布为ISO标准（ISO / IEC 14882：1998），并于2003年发布了技术勘误（ISO / IEC 14882：2003）进行了修订。这些标准分别称为C ++ 98和C ++ 03。 GCC实现了大多数C ++ 98（ &lt;code&gt;export&lt;/code&gt; 是一个明显的例外）以及C ++ 03中的大部分更改。要在GCC中选择此标准，请使用以下选项之一</target>
        </trans-unit>
        <trans-unit id="d55c2d645aa0f80881178d7412aa07a062ca969b" translate="yes" xml:space="preserve">
          <source>The other options specify a specific processor. Code generated under those options runs best on that processor, and may not run at all on others.</source>
          <target state="translated">其他选项指定了一个特定的处理器。在这些选项下生成的代码在该处理器上运行效果最好,而在其他处理器上可能根本无法运行。</target>
        </trans-unit>
        <trans-unit id="7b5fefa619d556bce9b8629c20698a9fbaa045b6" translate="yes" xml:space="preserve">
          <source>The output is sensitive to the effects of previous command-line options, so for example it is possible to find out which optimizations are enabled at</source>
          <target state="translated">输出对之前的命令行选项的影响很敏感,因此,例如,它可以找出哪些优化在</target>
        </trans-unit>
        <trans-unit id="ee1f8d32c864542b44f4a83fd30d75feed01b2e0" translate="yes" xml:space="preserve">
          <source>The output shows that this block of code, combined by optimization, executed 100 times. In one sense this result is correct, because there was only one instruction representing all four of these lines. However, the output does not indicate how many times the result was 0 and how many times the result was 1.</source>
          <target state="translated">输出显示,这段代码通过优化组合,执行了100次。从某种意义上说,这个结果是正确的,因为只有一条指令代表这四行代码。但是,输出并没有说明结果是0的次数和结果是1的次数。</target>
        </trans-unit>
        <trans-unit id="25cd388eab46b62953cbdcb13acb11f5a206e81f" translate="yes" xml:space="preserve">
          <source>The parameter &lt;var&gt;archetype&lt;/var&gt; determines how the format string is interpreted, and should be &lt;code&gt;printf&lt;/code&gt;, &lt;code&gt;scanf&lt;/code&gt;, &lt;code&gt;strftime&lt;/code&gt;, &lt;code&gt;gnu_printf&lt;/code&gt;, &lt;code&gt;gnu_scanf&lt;/code&gt;, &lt;code&gt;gnu_strftime&lt;/code&gt; or &lt;code&gt;strfmon&lt;/code&gt;. (You can also use &lt;code&gt;__printf__&lt;/code&gt;, &lt;code&gt;__scanf__&lt;/code&gt;, &lt;code&gt;__strftime__&lt;/code&gt; or &lt;code&gt;__strfmon__&lt;/code&gt;.) On MinGW targets, &lt;code&gt;ms_printf&lt;/code&gt;, &lt;code&gt;ms_scanf&lt;/code&gt;, and &lt;code&gt;ms_strftime&lt;/code&gt; are also present. &lt;var&gt;archetype&lt;/var&gt; values such as &lt;code&gt;printf&lt;/code&gt; refer to the formats accepted by the system&amp;rsquo;s C runtime library, while values prefixed with &amp;lsquo;</source>
          <target state="translated">参数 &lt;var&gt;archetype&lt;/var&gt; 决定如何解释格式字符串，并且应为 &lt;code&gt;printf&lt;/code&gt; ， &lt;code&gt;scanf&lt;/code&gt; ， &lt;code&gt;strftime&lt;/code&gt; ， &lt;code&gt;gnu_printf&lt;/code&gt; ， &lt;code&gt;gnu_scanf&lt;/code&gt; ， &lt;code&gt;gnu_strftime&lt;/code&gt; 或 &lt;code&gt;strfmon&lt;/code&gt; 。（您也可以使用 &lt;code&gt;__printf__&lt;/code&gt; ， &lt;code&gt;__scanf__&lt;/code&gt; ， &lt;code&gt;__strftime__&lt;/code&gt; 或 &lt;code&gt;__strfmon__&lt;/code&gt; 。）在MinGW目标上，还存在 &lt;code&gt;ms_printf&lt;/code&gt; ， &lt;code&gt;ms_scanf&lt;/code&gt; 和 &lt;code&gt;ms_strftime&lt;/code&gt; 。 &lt;var&gt;archetype&lt;/var&gt; 值，例如 &lt;code&gt;printf&lt;/code&gt; 指系统的C运行时库接受的格式，而以'</target>
        </trans-unit>
        <trans-unit id="a3f3b990be6aa69326bd74ae4681ebc09216102d" translate="yes" xml:space="preserve">
          <source>The parameter &lt;var&gt;string-index&lt;/var&gt; specifies which argument is the format string argument (starting from one). Since non-static C++ methods have an implicit &lt;code&gt;this&lt;/code&gt; argument, the arguments of such methods should be counted from two.</source>
          <target state="translated">参数 &lt;var&gt;string-index&lt;/var&gt; 指定哪个参数是格式字符串参数（从1开始）。由于非静态C ++方法具有隐式 &lt;code&gt;this&lt;/code&gt; 参数，因此此类方法的参数应从2开始计算。</target>
        </trans-unit>
        <trans-unit id="0bb73878f5340c14052a29fb8e00d23ff62b384d" translate="yes" xml:space="preserve">
          <source>The part of a compiler that is specific to a particular language is called the &amp;ldquo;front end&amp;rdquo;. In addition to the front ends that are integrated components of GCC, there are several other front ends that are maintained separately. These support languages such as Mercury, and COBOL. To use these, they must be built together with GCC proper.</source>
          <target state="translated">特定于特定语言的编译器部分称为&amp;ldquo;前端&amp;rdquo;。除了作为GCC集成组件的前端外，还有一些其他前端需要单独维护。这些支持语言，例如Mercury和COBOL。要使用它们，必须将它们与GCC适当地一起构建。</target>
        </trans-unit>
        <trans-unit id="27b45d0ebc931e1e733ecb9fb1c3f4c5240b8194" translate="yes" xml:space="preserve">
          <source>The particular options set for any particular CPU varies between compiler versions, depending on what setting seems to produce optimal code for that CPU; it doesn&amp;rsquo;t necessarily reflect the actual hardware&amp;rsquo;s capabilities. If you wish to set an individual option to a particular value, you may specify it after the</source>
          <target state="translated">为任何特定CPU设置的特定选项在编译器版本之间有所不同，具体取决于哪种设置可以为该CPU生成最佳代码。它并不一定反映实际硬件的功能。如果您希望将单个选项设置为特定值，则可以在</target>
        </trans-unit>
        <trans-unit id="452dc4aa50f4dd1fa4974069451a474c59e40f9c" translate="yes" xml:space="preserve">
          <source>The parts that differ are highlighted with color (&amp;ldquo;double&amp;rdquo; and &amp;ldquo;float&amp;rdquo; in this case).</source>
          <target state="translated">不同的部分以颜色突出显示（在这种情况下为&amp;ldquo; double&amp;rdquo;和&amp;ldquo; float&amp;rdquo;）。</target>
        </trans-unit>
        <trans-unit id="9af1a3f7e74758af6362de95fe293ce9aa19535b" translate="yes" xml:space="preserve">
          <source>The percentage of function, weighted by execution frequency, that must be covered by trace formation. Used when profile feedback is available.</source>
          <target state="translated">按执行频率加权的函数百分比,必须由跟踪形成覆盖。当有轮廓反馈时使用。</target>
        </trans-unit>
        <trans-unit id="2679379ebc643273c71ff53ef41c24d477972525" translate="yes" xml:space="preserve">
          <source>The permissible values for &lt;var&gt;arch&lt;/var&gt; are &amp;lsquo;</source>
          <target state="translated">&lt;var&gt;arch&lt;/var&gt; 的允许值为&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="f2d47f57e4f2874c39d4b9abd17b4e23013a44ad" translate="yes" xml:space="preserve">
          <source>The permissible values for &lt;var&gt;feature&lt;/var&gt; are listed in the sub-section on &lt;a href=&quot;#aarch64_002dfeature_002dmodifiers&quot;&gt;&lt;samp&gt;-march&lt;/samp&gt; and &lt;samp&gt;-mcpu&lt;/samp&gt; Feature Modifiers&lt;/a&gt;. Where conflicting feature modifiers are specified, the right-most feature is used.</source>
          <target state="translated">对于允许值 &lt;var&gt;feature&lt;/var&gt; 是在副部分上列出&lt;a href=&quot;#aarch64_002dfeature_002dmodifiers&quot;&gt;&lt;samp&gt;-游行&lt;/samp&gt; 和 &lt;samp&gt;-mcpu&lt;/samp&gt;特征修饰符&lt;/a&gt;。如果指定了冲突的特征修饰符，则使用最右边的特征。</target>
        </trans-unit>
        <trans-unit id="c7e86233015dde5cd1c78847180c34b2f1e2bf2b" translate="yes" xml:space="preserve">
          <source>The places that are searched for an included &amp;lsquo;</source>
          <target state="translated">搜索包含的&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="dd8b187fae5590414120f103d445af72242d5c3b" translate="yes" xml:space="preserve">
          <source>The position in the bit-field is the position, counting in bits, of the bit closest to the beginning of the structure.</source>
          <target state="translated">位域中的位置是指最接近结构开头的位的位置,以位为单位。</target>
        </trans-unit>
        <trans-unit id="c4b546e403df1ecde52f18e1df9da4aeb8d7bc41" translate="yes" xml:space="preserve">
          <source>The possible values of &lt;var&gt;visibility_type&lt;/var&gt; correspond to the visibility settings in the ELF gABI.</source>
          <target state="translated">的可能值 &lt;var&gt;visibility_type&lt;/var&gt; 对应于ELF加比的可见性设置。</target>
        </trans-unit>
        <trans-unit id="f6264d8e91343ef3a61a9b344f8646bf4aba8cc7" translate="yes" xml:space="preserve">
          <source>The practice of reading from a different union member than the one most recently written to (called &amp;ldquo;type-punning&amp;rdquo;) is common. Even with</source>
          <target state="translated">从与最近写过的工会成员不同的工会成员那里进行阅读的做法很常见（称为&amp;ldquo;类型操纵&amp;rdquo;）。即使</target>
        </trans-unit>
        <trans-unit id="3fcfc9f88180eb2f1134228de5ee485783fb7bf2" translate="yes" xml:space="preserve">
          <source>The pragmas defined by the AArch64 target correspond to the AArch64 target function attributes. They can be specified as below:</source>
          <target state="translated">AArch64目标定义的实用名词与AArch64目标函数属性相对应。它们可以被指定如下。</target>
        </trans-unit>
        <trans-unit id="645dbf1ac450b591d9e4ddc2872516c2fa74709d" translate="yes" xml:space="preserve">
          <source>The pragmas defined by the S/390 target correspond to the S/390 target function attributes and some the additional options:</source>
          <target state="translated">S/390目标定义的实用程序对应于S/390目标功能属性和一些附加选项。</target>
        </trans-unit>
        <trans-unit id="2c0f7aae6dce4abe2e06c56745ef40bd52aa8844" translate="yes" xml:space="preserve">
          <source>The precise convention for returning structures in memory depends on the target configuration macros.</source>
          <target state="translated">返回内存中结构的精确约定取决于目标配置宏。</target>
        </trans-unit>
        <trans-unit id="91248f1a5a5155ccc98999905b33b441a4c0b382" translate="yes" xml:space="preserve">
          <source>The precompiled header file must be produced for the same language as the current compilation. You cannot use a C precompiled header for a C++ compilation.</source>
          <target state="translated">预编译的头文件必须与当前编译的语言相同。你不能将C语言的预编译头文件用于C++编译。</target>
        </trans-unit>
        <trans-unit id="a7364d3dac14debc46aa1590555ff15d8a2c5504" translate="yes" xml:space="preserve">
          <source>The precompiled header file must have been produced by the same compiler binary as the current compilation is using.</source>
          <target state="translated">预编译的头文件必须与当前编译使用的编译器二进制文件相同。</target>
        </trans-unit>
        <trans-unit id="fa601548ca48cf3a1634bdb3b2571be6608e559a" translate="yes" xml:space="preserve">
          <source>The preferred mechanism to declare variable-length types like &lt;code&gt;struct line&lt;/code&gt; above is the ISO C99 &lt;em&gt;flexible array member&lt;/em&gt;, with slightly different syntax and semantics:</source>
          <target state="translated">像上面的 &lt;code&gt;struct line&lt;/code&gt; 这样的声明可变长度类型的首选机制是ISO C99 &lt;em&gt;flexible数组成员&lt;/em&gt;，其语法和语义略有不同：</target>
        </trans-unit>
        <trans-unit id="781223d90b25e173d9a1c191f04f39b92b12674b" translate="yes" xml:space="preserve">
          <source>The preprocessor constants &lt;code&gt;__v850&lt;/code&gt; and &lt;code&gt;__v851__&lt;/code&gt; are always defined, regardless of which processor variant is the target.</source>
          <target state="translated">始终定义预处理器常量 &lt;code&gt;__v850&lt;/code&gt; 和 &lt;code&gt;__v851__&lt;/code&gt; ，而不管目标是哪个处理器变体。</target>
        </trans-unit>
        <trans-unit id="516a25c40cc84aaf870728160964e02be2e34941" translate="yes" xml:space="preserve">
          <source>The preprocessor macro &lt;code&gt;__nios2_arch__&lt;/code&gt; is available to programs, with value 1 or 2, indicating the targeted ISA level.</source>
          <target state="translated">预处理程序宏 &lt;code&gt;__nios2_arch__&lt;/code&gt; 可用于程序，其值为1或2，指示目标ISA级别。</target>
        </trans-unit>
        <trans-unit id="e7e3cb02afe1efb7ea595142066c8a4b5aee7508" translate="yes" xml:space="preserve">
          <source>The preprocessor macros &lt;code&gt;__GNUC_GNU_INLINE__&lt;/code&gt; and &lt;code&gt;__GNUC_STDC_INLINE__&lt;/code&gt; may be used to check which semantics are in effect for &lt;code&gt;inline&lt;/code&gt; functions. See &lt;a href=&quot;http://gcc.gnu.org/onlinedocs/cpp/Common-Predefined-Macros.html#Common-Predefined-Macros&quot;&gt;Common Predefined Macros&lt;/a&gt; in The C Preprocessor.</source>
          <target state="translated">预处理宏 &lt;code&gt;__GNUC_GNU_INLINE__&lt;/code&gt; 和 &lt;code&gt;__GNUC_STDC_INLINE__&lt;/code&gt; 可用于检查哪些语义 &lt;code&gt;inline&lt;/code&gt; 函数有效。请参见C预处理器中的&lt;a href=&quot;http://gcc.gnu.org/onlinedocs/cpp/Common-Predefined-Macros.html#Common-Predefined-Macros&quot;&gt;通用预定义宏&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e144b8574fca5ee84d650870787998db8cc0a6cc" translate="yes" xml:space="preserve">
          <source>The preprocessor symbols &lt;code&gt;__SEG_FS&lt;/code&gt; and &lt;code&gt;__SEG_GS&lt;/code&gt; are defined when these address spaces are supported.</source>
          <target state="translated">当支持这些地址空间时，将定义预处理器符号 &lt;code&gt;__SEG_FS&lt;/code&gt; 和 &lt;code&gt;__SEG_GS&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="59cc56242765d93d1139cc69346a113ae66f0437" translate="yes" xml:space="preserve">
          <source>The preprocessor treatment of escaped newlines is more relaxed than that specified by the C90 standard, which requires the newline to immediately follow a backslash. GCC&amp;rsquo;s implementation allows whitespace in the form of spaces, horizontal and vertical tabs, and form feeds between the backslash and the subsequent newline. The preprocessor issues a warning, but treats it as a valid escaped newline and combines the two lines to form a single logical line. This works within comments and tokens, as well as between tokens. Comments are &lt;em&gt;not&lt;/em&gt; treated as whitespace for the purposes of this relaxation, since they have not yet been replaced with spaces.</source>
          <target state="translated">转义的换行符的预处理程序比C90标准所指定的更宽松，C90标准要求换行符立即跟随反斜杠。 GCC的实现允许以空格，水平和垂直制表符的形式出现空格，并在反斜杠和后续换行符之间形成换页。预处理器发出警告，但将其视为有效的转义换行符，并将这两行合并以形成一条逻辑行。这适用于注释和标记以及标记之间。出于放松目的，注释&lt;em&gt;不&lt;/em&gt;被视为空格，因为它们尚未被空格替换。</target>
        </trans-unit>
        <trans-unit id="a2282938cc4db5b60fc722ea3f4e0b1558cfa2dc" translate="yes" xml:space="preserve">
          <source>The program counter (PC) is 2 bytes wide. This is the case for devices with up to 128 KiB of program memory.</source>
          <target state="translated">程序计数器(PC)的宽度为2个字节。对于程序存储器最大为128KiB的设备来说,就是这样。</target>
        </trans-unit>
        <trans-unit id="bdec771ba3fce1f14ccbe2f783eeba3b5eb697cc" translate="yes" xml:space="preserve">
          <source>The programs that fix the header files do not understand this special way of using symbolic links; therefore, the directory of fixed header files is good only for the machine model used to build it.</source>
          <target state="translated">固定头文件的程序不理解这种特殊的使用符号链接的方式,因此,固定头文件的目录只对用于构建它的机器型号好。</target>
        </trans-unit>
        <trans-unit id="09f7403716543aa22328bdac3e1ded4dc52aedb3" translate="yes" xml:space="preserve">
          <source>The qualifier &lt;code&gt;dynamic&lt;/code&gt; means that the function manipulates the stack dynamically: in addition to the static allocation described above, stack adjustments are made in the body of the function, for example to push/pop arguments around function calls. If the qualifier &lt;code&gt;bounded&lt;/code&gt; is also present, the amount of these adjustments is bounded at compile time and the second field is an upper bound of the total amount of stack used by the function. If it is not present, the amount of these adjustments is not bounded at compile time and the second field only represents the bounded part.</source>
          <target state="translated">限定符是 &lt;code&gt;dynamic&lt;/code&gt; 意味着函数动态地操纵堆栈：除了上述静态分配之外，还在函数主体中进行了堆栈调整，例如，在函数调用周围推送/弹出参数。如果还存在限定符 &lt;code&gt;bounded&lt;/code&gt; ，则这些调整的量在编译时限定，并且第二个字段是该函数使用的堆栈总数的上限。如果不存在，则这些调整的数量在编译时不受限制，并且第二个字段仅表示受限制的部分。</target>
        </trans-unit>
        <trans-unit id="16b6ee8f6057a92bf82347dbc31b9360f115d43a" translate="yes" xml:space="preserve">
          <source>The qualifier &lt;code&gt;static&lt;/code&gt; means that the function manipulates the stack statically: a fixed number of bytes are allocated for the frame on function entry and released on function exit; no stack adjustments are otherwise made in the function. The second field is this fixed number of bytes.</source>
          <target state="translated">限定符 &lt;code&gt;static&lt;/code&gt; 表示该函数静态地操作堆栈：在函数入口为帧分配固定数量的字节，在函数出口将其释放；否则不会在函数中进行堆栈调整。第二个字段是此固定字节数。</target>
        </trans-unit>
        <trans-unit id="d99c785e19e25b0fcfa2c0d8dc79cf7ec34db9e9" translate="yes" xml:space="preserve">
          <source>The rank of any extended integer type relative to another extended integer type with the same precision (C99 and C11 6.3.1.1).</source>
          <target state="translated">任何扩展整数类型相对于另一个精度相同的扩展整数类型的等级(C99和C11 6.3.1.1)。</target>
        </trans-unit>
        <trans-unit id="cf6573d176933b5e09eb83df2d5615b45a3bb76e" translate="yes" xml:space="preserve">
          <source>The reason for using names that start with underscores for the local variables is to avoid conflicts with variable names that occur within the expressions that are substituted for &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;. Eventually we hope to design a new form of declaration syntax that allows you to declare variables whose scopes start only after their initializers; this will be a more reliable way to prevent such conflicts.</source>
          <target state="translated">对局部变量使用以下划线开头的名称的原因是为了避免与替换 &lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;b&lt;/code&gt; 的表达式中出现的变量名称发生冲突。最终，我们希望设计一种新的声明语法形式，使您可以声明作用域仅在其初始值设定项之后才开始的变量。这将是防止此类冲突的更可靠方法。</target>
        </trans-unit>
        <trans-unit id="17b5e6eec29945ad1cdc98a53fb0e13f400b8a4b" translate="yes" xml:space="preserve">
          <source>The register assignments for arguments and return values remain the same, but each scalar value is passed in a single 64-bit register rather than a pair of 32-bit registers. For example, scalar floating-point values are returned in &amp;lsquo;</source>
          <target state="translated">参数和返回值的寄存器分配保持不变，但是每个标量值在单个64位寄存器而不是在一对32位寄存器中传递。例如，标量浮点值在&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="df089519561a6aaf6b0d5462a2d12a16f51ac16a" translate="yes" xml:space="preserve">
          <source>The register class usable in short insns. This is a register class constraint, and can thus drive register allocation. This constraint won&amp;rsquo;t match unless</source>
          <target state="translated">可以在短insns中使用的寄存器类。这是寄存器类别的约束，因此可以驱动寄存器分配。除非，否则此约束将不匹配</target>
        </trans-unit>
        <trans-unit id="ce5827517313f66ee35c67440ea785808e96b2d8" translate="yes" xml:space="preserve">
          <source>The register group usable in short insns. This constraint does not use a register class, so that it only passively matches suitable registers, and doesn&amp;rsquo;t drive register allocation.</source>
          <target state="translated">可以在短insns中使用的寄存器组。此约束不使用寄存器类，因此它仅被动匹配合适的寄存器，并且不驱动寄存器分配。</target>
        </trans-unit>
        <trans-unit id="72d3acac63bf69f2e9cbe4802b6dfb23c1a3dc0a" translate="yes" xml:space="preserve">
          <source>The register indicated by Rx (not implemented yet).</source>
          <target state="translated">Rx表示的寄存器(尚未实现)。</target>
        </trans-unit>
        <trans-unit id="b14ae46b310b2d10e38a2d9126edc47d0a1b7438" translate="yes" xml:space="preserve">
          <source>The registers reserved for interrupts (&lt;code&gt;R24&lt;/code&gt; to &lt;code&gt;R31&lt;/code&gt;).</source>
          <target state="translated">保留用于中断的寄存器（ &lt;code&gt;R24&lt;/code&gt; 至 &lt;code&gt;R31&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="5b9c9dc3621d339e8f64077eedb5da8839ab6a60" translate="yes" xml:space="preserve">
          <source>The relevant bytes of the representation of the object are treated as an object of the type used for the access. See &lt;a href=&quot;optimize-options#Type_002dpunning&quot;&gt;Type-punning&lt;/a&gt;. This may be a trap representation.</source>
          <target state="translated">对象表示形式的相关字节被视为用于访问的类型的对象。请参阅&lt;a href=&quot;optimize-options#Type_002dpunning&quot;&gt;Type-punning&lt;/a&gt;。这可能是陷阱表示。</target>
        </trans-unit>
        <trans-unit id="f41e3aebc6e71662ecec887032e93bdb3882f388" translate="yes" xml:space="preserve">
          <source>The remainder of this section is specific to GNU C90 inlining.</source>
          <target state="translated">本节剩下的部分是针对GNU C90的内联。</target>
        </trans-unit>
        <trans-unit id="558c61b7cf4311ca70d848b51262ab1898c102b3" translate="yes" xml:space="preserve">
          <source>The remaining environment variables apply only when preprocessing the particular language indicated. Each specifies a list of directories to be searched as if specified with</source>
          <target state="translated">其余的环境变量仅在预处理指定的特定语言时适用。每个环境变量都指定了一个要搜索的目录列表,就像用</target>
        </trans-unit>
        <trans-unit id="c96b85add00a5f322d58fcbd72ee7befb1dea21f" translate="yes" xml:space="preserve">
          <source>The remaining functions are provided for optimization purposes.</source>
          <target state="translated">其余功能是为了优化而提供的。</target>
        </trans-unit>
        <trans-unit id="1f81fad037120bbd5cb1f32f0f1474309573caa7" translate="yes" xml:space="preserve">
          <source>The required &lt;var&gt;ref-index&lt;/var&gt; positional argument denotes a function argument of pointer (or in C++, reference) type that is subject to the access. The same pointer argument can be referenced by at most one distinct &lt;code&gt;access&lt;/code&gt; attribute.</source>
          <target state="translated">必需的 &lt;var&gt;ref-index&lt;/var&gt; 位置参数表示要访问的指针（或在C ++中为reference）类型的函数参数。同一指针参数最多可以由一个不同的 &lt;code&gt;access&lt;/code&gt; 属性引用。</target>
        </trans-unit>
        <trans-unit id="4420491dd7bf1c05e945f7d72f0a1731089f6301" translate="yes" xml:space="preserve">
          <source>The respective segment base must be set via some method specific to the operating system. Rather than require an expensive system call to retrieve the segment base, these address spaces are not considered to be subspaces of the generic (flat) address space. This means that explicit casts are required to convert pointers between these address spaces and the generic address space. In practice the application should cast to &lt;code&gt;uintptr_t&lt;/code&gt; and apply the segment base offset that it installed previously.</source>
          <target state="translated">必须通过特定于操作系统的某种方法来设置相应的段基础。这些地址空间不被认为是通用（平面）地址空间的子空间，而不是需要昂贵的系统调用来检索段基础。这意味着需要显式强制转换才能在这些地址空间和通用地址空间之间转换指针。在实践中，应用程序应 &lt;code&gt;uintptr_t&lt;/code&gt; 为uintptr_t并应用其先前安装的段基础偏移量。</target>
        </trans-unit>
        <trans-unit id="9b4574d542eb42ca2e1f7130ac8122d2979c3b76" translate="yes" xml:space="preserve">
          <source>The rest of this discussion uses the following code for illustrative purposes.</source>
          <target state="translated">本讨论的其余部分使用以下代码进行说明。</target>
        </trans-unit>
        <trans-unit id="6771696cde55a31392f32b7d1552e2429667db0a" translate="yes" xml:space="preserve">
          <source>The restrictions on &lt;code&gt;offsetof&lt;/code&gt; may be relaxed in a future version of the C++ standard.</source>
          <target state="translated">在C ++标准的未来版本中，可能会放宽对 &lt;code&gt;offsetof&lt;/code&gt; 的限制。</target>
        </trans-unit>
        <trans-unit id="dd1a1a42d6420a3422e966b9e8baa0847229727c" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;vec_rlmi&lt;/code&gt; is obtained by rotating each element of the first argument vector left and inserting it under mask into the second argument vector. The third argument vector contains the mask beginning in bits 11:15, the mask end in bits 19:23, and the shift count in bits 27:31, of each element.</source>
          <target state="translated">通过将第一个自变量向量的每个元素向左旋转并将其在mask下插入第二个自变量向量中， &lt;code&gt;vec_rlmi&lt;/code&gt; 的结果。第三个自变量向量包含每个元素的以位11:15开始的掩码，以位19:23结尾的掩码和位27:31的移位计数。</target>
        </trans-unit>
        <trans-unit id="b9a3f0d57a834ed4eba9054b925159bf84ea4a8e" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;vec_rlnm&lt;/code&gt; is obtained by rotating each element of the first argument vector left and ANDing it with a mask specified by the second and third argument vectors. The second argument vector contains the shift count for each element in the low-order byte. The third argument vector contains the mask end for each element in the low-order byte, with the mask begin in the next higher byte.</source>
          <target state="translated">通过将第一个自变量向量的每个元素向左旋转并将其与第二个和第三个自变量向量指定的掩码进行&amp;ldquo;与&amp;rdquo;运算， &lt;code&gt;vec_rlnm&lt;/code&gt; 获得vec_rlnm的结果。第二个自变量向量包含低位字节中每个元素的移位计数。第三个参数向量在低位字节中包含每个元素的掩码结尾，而掩码在下一个较高字节中开始。</target>
        </trans-unit>
        <trans-unit id="8ac79b53c282a3e1bdc553acd00140fe5cdb87cf" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;vec_vrlnm&lt;/code&gt; is obtained by rotating each element of the first argument vector left and ANDing it with a mask. The second argument vector contains the mask beginning in bits 11:15, the mask end in bits 19:23, and the shift count in bits 27:31, of each element.</source>
          <target state="translated">&lt;code&gt;vec_vrlnm&lt;/code&gt; 的结果是通过将第一个自变量向量的每个元素向左旋转并将其与掩码进行&amp;ldquo;与&amp;rdquo;运算而获得的。第二个自变量向量包含每个元素的以11:15开始的掩码，以19:23结束的掩码以及以27:31的移位计数。</target>
        </trans-unit>
        <trans-unit id="9316b131e727e77ff29281dc2e9a7402d2bc6522" translate="yes" xml:space="preserve">
          <source>The result of attempting to indirectly access an object with automatic or thread storage duration from a thread other than the one with which it is associated (C11 6.2.4).</source>
          <target state="translated">试图从与之相关联的线程以外的线程间接访问具有自动或线程存储期限的对象的结果(C11 6.2.4)。</target>
        </trans-unit>
        <trans-unit id="293312cb8a66343c5e00cc15dc2d11a748b78cdb" translate="yes" xml:space="preserve">
          <source>The result of converting a pointer to an integer or vice versa (C90 6.3.4, C99 and C11 6.3.2.3).</source>
          <target state="translated">将指针转换为整数的结果,或者将整数转换为指针的结果(C90 6.3.4,C99和C11 6.3.2.3)。</target>
        </trans-unit>
        <trans-unit id="d8adce6949d651dd3877dd8fc89775a368e6c5a5" translate="yes" xml:space="preserve">
          <source>The result of, or the signal raised by, converting an integer to a signed integer type when the value cannot be represented in an object of that type (C90 6.2.1.2, C99 and C11 6.3.1.3).</source>
          <target state="translated">当值不能用有符号的整数类型对象表示时,将整数转换为有符号的整数类型的结果或信号(C90 6.2.1.2,C99和C11 6.3.1.3)。</target>
        </trans-unit>
        <trans-unit id="6372dea778f1e54932d501af42dec0c2c6cb7a32" translate="yes" xml:space="preserve">
          <source>The resulting code should be considerably faster in the majority of cases and avoid the numerical instability problems of 387 code, but may break some existing code that expects temporaries to be 80 bits.</source>
          <target state="translated">由此产生的代码在大多数情况下应该是相当快的,并且避免了387代码的数值不稳定问题,但可能会打破一些现有的代码,这些代码期望时序为80位。</target>
        </trans-unit>
        <trans-unit id="602584d89b66e12499de96c6abd45f1820a6ab70" translate="yes" xml:space="preserve">
          <source>The results of some bitwise operations on signed integers (C90 6.3, C99 and C11 6.5).</source>
          <target state="translated">对有符号整数进行一些位运算的结果(C90 6.3,C99和C11 6.5)。</target>
        </trans-unit>
        <trans-unit id="08e0446d619f737b8b3d1bfcead4987221134fe0" translate="yes" xml:space="preserve">
          <source>The return type, including type qualifiers. For example, a method returning &lt;code&gt;int&lt;/code&gt; would have &lt;code&gt;i&lt;/code&gt; here.</source>
          <target state="translated">返回类型，包括类型限定符。例如，一个返回 &lt;code&gt;int&lt;/code&gt; 的方法在这里有 &lt;code&gt;i&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d722a3f7a5a03ca6f3a20b50840f8dad2ad4a0a2" translate="yes" xml:space="preserve">
          <source>The return value is the value of &lt;var&gt;exp&lt;/var&gt;, which should be an integral expression. The semantics of the built-in are that it is expected that &lt;var&gt;exp&lt;/var&gt; == &lt;var&gt;c&lt;/var&gt;. For example:</source>
          <target state="translated">返回值是 &lt;var&gt;exp&lt;/var&gt; 的值，它应该是整数表达式。内置的语义是期望 &lt;var&gt;exp&lt;/var&gt; == &lt;var&gt;c&lt;/var&gt; 。例如：</target>
        </trans-unit>
        <trans-unit id="66b2899a0dec22c6c49cc318d7875f38a40fbcdb" translate="yes" xml:space="preserve">
          <source>The return value of the method is the number of objects in the current batch; this should not exceed &lt;code&gt;len&lt;/code&gt;, which is the maximum size of a batch as requested by the caller. The batch itself is returned in the &lt;code&gt;itemsPtr&lt;/code&gt; field of the &lt;code&gt;NSFastEnumerationState&lt;/code&gt; struct.</source>
          <target state="translated">该方法的返回值是当前批次中的对象数。此值不应超过 &lt;code&gt;len&lt;/code&gt; ，len是调用方要求的最大批处理大小。批处理本身将在 &lt;code&gt;NSFastEnumerationState&lt;/code&gt; 结构的 &lt;code&gt;itemsPtr&lt;/code&gt; 字段中返回。</target>
        </trans-unit>
        <trans-unit id="bd39f3563e6cdbea884ac0f3b2596eb7ac3835c0" translate="yes" xml:space="preserve">
          <source>The rounding behaviors characterized by non-standard values of &lt;code&gt;FLT_ROUNDS&lt;/code&gt; (C90, C99 and C11 5.2.4.2.2).</source>
          <target state="translated">舍入行为以 &lt;code&gt;FLT_ROUNDS&lt;/code&gt; （C90，C99和C11 5.2.4.2.2）的非标准值为特征。</target>
        </trans-unit>
        <trans-unit id="ca0bfeda9cecd5551824a4a4e37d54810853db32" translate="yes" xml:space="preserve">
          <source>The runtime support file</source>
          <target state="translated">运行时支持文件</target>
        </trans-unit>
        <trans-unit id="b4c4c0226af27718cbd914b43f7be4de41a152cd" translate="yes" xml:space="preserve">
          <source>The safe way to write such code is to give the temporary a name, which forces it to remain until the end of the scope of the name. For example:</source>
          <target state="translated">编写这类代码的安全方法是给临时的名字,这就迫使它保持到名字的范围结束。比如说</target>
        </trans-unit>
        <trans-unit id="ba4b69f3a9e8d7ca80206177b8876cf920e6f11b" translate="yes" xml:space="preserve">
          <source>The same</source>
          <target state="translated">同样的</target>
        </trans-unit>
        <trans-unit id="e53e3a35319895514d679977563fa8e554b518de" translate="yes" xml:space="preserve">
          <source>The same constraints on arguments apply as for the corresponding &lt;code&gt;__atomic_op_fetch&lt;/code&gt; built-in functions. All memory orders are valid.</source>
          <target state="translated">对参数的约束与对相应的 &lt;code&gt;__atomic_op_fetch&lt;/code&gt; 内置函数的约束相同。所有内存顺序均有效。</target>
        </trans-unit>
        <trans-unit id="1d3bb42125b4caec8cf7a192592fcd99a8477b57" translate="yes" xml:space="preserve">
          <source>The same constraints on arguments apply as for the corresponding &lt;code&gt;__sync_op_and_fetch&lt;/code&gt; built-in functions.</source>
          <target state="translated">对参数的约束与对相应的 &lt;code&gt;__sync_op_and_fetch&lt;/code&gt; 内置函数的约束相同。</target>
        </trans-unit>
        <trans-unit id="e9ffb18b7d09b9daf66ff3c77ffe4ceee695ef40" translate="yes" xml:space="preserve">
          <source>The same problem can occur if one output parameter (&lt;var&gt;a&lt;/var&gt;) allows a register constraint and another output parameter (&lt;var&gt;b&lt;/var&gt;) allows a memory constraint. The code generated by GCC to access the memory address in &lt;var&gt;b&lt;/var&gt; can contain registers which &lt;em&gt;might&lt;/em&gt; be shared by &lt;var&gt;a&lt;/var&gt;, and GCC considers those registers to be inputs to the asm. As above, GCC assumes that such input registers are consumed before any outputs are written. This assumption may result in incorrect behavior if the &lt;code&gt;asm&lt;/code&gt; statement writes to &lt;var&gt;a&lt;/var&gt; before using &lt;var&gt;b&lt;/var&gt;. Combining the &amp;lsquo;</source>
          <target state="translated">如果一个输出参数（ &lt;var&gt;a&lt;/var&gt; ）允许寄存器约束，而另一个输出参数（ &lt;var&gt;b&lt;/var&gt; ）允许存储器约束，则可能发生相同的问题。由GCC生成的用于访问 &lt;var&gt;b&lt;/var&gt; 中的内存地址的代码可以包含&lt;em&gt;可能&lt;/em&gt;由 &lt;var&gt;a&lt;/var&gt; 共享的寄存器，并且GCC认为这些寄存器是asm的输入。如上所述，GCC假定在写入任何输出之前消耗了这些输入寄存器。如果 &lt;code&gt;asm&lt;/code&gt; 语句在使用 &lt;var&gt;b&lt;/var&gt; 之前写入 &lt;var&gt;a&lt;/var&gt; ，则此假设可能导致错误的行为。结合&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="84eb297a7c7adafda6643fbbc1a64827529d36ab" translate="yes" xml:space="preserve">
          <source>The same values for</source>
          <target state="translated">相同的数值</target>
        </trans-unit>
        <trans-unit id="10b4b93db032b4ab2baad7ea49ce309b241f5e8b" translate="yes" xml:space="preserve">
          <source>The scale (in percents) applied to</source>
          <target state="translated">适用于以下方面的比额表(百分比)</target>
        </trans-unit>
        <trans-unit id="5ee0deba9d1e7e31914904f7de96ff06cf02541a" translate="yes" xml:space="preserve">
          <source>The second and third &lt;code&gt;FOO&lt;/code&gt; should be in comments. This warning is on by default.</source>
          <target state="translated">第二和第三 &lt;code&gt;FOO&lt;/code&gt; 应该在注释中。默认情况下，此警告处于启用状态。</target>
        </trans-unit>
        <trans-unit id="498b43ab0ba23ca5cccab7efec7dc706e6795ec7" translate="yes" xml:space="preserve">
          <source>The second argument to &lt;var&gt;__builtin_crypto_vshasigmad&lt;/var&gt; and &lt;var&gt;__builtin_crypto_vshasigmaw&lt;/var&gt; must be a constant integer that is 0 or 1. The third argument to these built-in functions must be a constant integer in the range of 0 to 15.</source>
          <target state="translated">&lt;var&gt;__builtin_crypto_vshasigmad&lt;/var&gt; 和 &lt;var&gt;__builtin_crypto_vshasigmaw&lt;/var&gt; 的第二个参数必须是0或1的常量整数。这些内置函数的第三个参数必须是0到15范围内的常量整数。</target>
        </trans-unit>
        <trans-unit id="a7455b53d8f1101ab3b5613a9bfe23cea1588051" translate="yes" xml:space="preserve">
          <source>The second argument, &lt;var&gt;failval&lt;/var&gt;, is optional and defaults to zero if omitted.</source>
          <target state="translated">第二个参数 &lt;var&gt;failval&lt;/var&gt; 是可选的，如果省略则默认为零。</target>
        </trans-unit>
        <trans-unit id="e5696540b2cb16b0a24c5184cde684653dcb48a5" translate="yes" xml:space="preserve">
          <source>The second form of this directive is useful for the case where you have multiple headers with the same name in different directories. If you use this form, you must specify the same string to &amp;lsquo;</source>
          <target state="translated">对于在不同目录中具有相同名称的多个头的情况，此指令的第二种形式很有用。如果您使用这种形式，则必须为&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="f7af4ae65c75a113a136191463890951e0da2e45" translate="yes" xml:space="preserve">
          <source>The second pair of &lt;var&gt;n2&lt;/var&gt;:&lt;var&gt;m2&lt;/var&gt; values allows you to specify a secondary alignment:</source>
          <target state="translated">第二对 &lt;var&gt;n2&lt;/var&gt; ： &lt;var&gt;m2&lt;/var&gt; 值使您可以指定辅助对齐方式：</target>
        </trans-unit>
        <trans-unit id="3ab6989d4c1c4f47e25307deb785d43e56803a5f" translate="yes" xml:space="preserve">
          <source>The security extension.</source>
          <target state="translated">安全扩展。</target>
        </trans-unit>
        <trans-unit id="227e1ad96cf49ba3c90eaa74176faf5e4ae6abc9" translate="yes" xml:space="preserve">
          <source>The sense of a qualifier can be inverted by prefixing it with the &amp;lsquo;</source>
          <target state="translated">限定词的含义可以通过在其前面加上'</target>
        </trans-unit>
        <trans-unit id="555ceee2bb9cf5f8f3e29c4052854238c7fb191f" translate="yes" xml:space="preserve">
          <source>The set of runtime conventions followed by all of the tools that deal with binary representations of a program, including compilers, assemblers, linkers, and language runtime support. Some ABIs are formal with a written specification, possibly designed by multiple interested parties. Others are simply the way things are actually done by a particular set of tools.</source>
          <target state="translated">所有处理程序二进制表示的工具所遵循的一套运行时惯例,包括编译器、汇编器、链接器和语言运行时支持。有些ABI是正式的,有一个书面的规范,可能由多个相关方设计。其他的则只是由一组特定的工具实际完成的方式。</target>
        </trans-unit>
        <trans-unit id="3a0b9082dbf784ec48751abb46feb9a84f16889b" translate="yes" xml:space="preserve">
          <source>The setting &amp;lsquo;</source>
          <target state="translated">那个设定 '</target>
        </trans-unit>
        <trans-unit id="be945ed951ef5a61f5eae361b911de27ce4736fe" translate="yes" xml:space="preserve">
          <source>The shadow stack unwind code looks like:</source>
          <target state="translated">影子堆栈的解压代码是这样的。</target>
        </trans-unit>
        <trans-unit id="5e51279e9e910972feb51c0c337d5562d0a6bae6" translate="yes" xml:space="preserve">
          <source>The sign of the remainder on integer division (C90 6.3.5).</source>
          <target state="translated">整数除法上余数的符号(C90 6.3.5)。</target>
        </trans-unit>
        <trans-unit id="3873ede6c61e304d381b113f1c8a01eb501fad5a" translate="yes" xml:space="preserve">
          <source>The simplest kind of constraint is a string full of letters, each of which describes one kind of operand that is permitted. Here are the letters that are allowed:</source>
          <target state="translated">最简单的约束是一串字母,每一个字母描述了一种允许的操作数。下面是允许使用的字母。</target>
        </trans-unit>
        <trans-unit id="f57db1d7a87e06c8af2c5a7b6a9b449af372d773" translate="yes" xml:space="preserve">
          <source>The single- and double-precision FPv5 floating-point instructions.</source>
          <target state="translated">单精度和双精度的FPv5浮点指令。</target>
        </trans-unit>
        <trans-unit id="8bf5f529e48bebb5ac22844826b001e3be0c3afe" translate="yes" xml:space="preserve">
          <source>The single- and double-precision floating-point instructions.</source>
          <target state="translated">单精度和双精度浮点指令。</target>
        </trans-unit>
        <trans-unit id="8ac5488ac14854117c1393d98f83c5a93f21526b" translate="yes" xml:space="preserve">
          <source>The single-precision FPv5 floating-point instructions.</source>
          <target state="translated">单精度FPv5浮点指令。</target>
        </trans-unit>
        <trans-unit id="1ebaf382d5bdec22e2b7379aab4b7c48ea9e912b" translate="yes" xml:space="preserve">
          <source>The single-precision VFPv3 floating-point instructions with 16 double-precision registers and the half-precision floating-point conversion operations.</source>
          <target state="translated">具有16个双精度寄存器的单精度VFPv3浮点指令和半精度浮点转换操作。</target>
        </trans-unit>
        <trans-unit id="e7ad435877ea887d34b1b37f15d7368e56cc4675" translate="yes" xml:space="preserve">
          <source>The single-precision VFPv3 floating-point instructions. The extension &amp;lsquo;</source>
          <target state="translated">单精度VFPv3浮点指令。扩展名'</target>
        </trans-unit>
        <trans-unit id="3e79bc7e04e01647f6facb0d53f8d2ca1a7bc417" translate="yes" xml:space="preserve">
          <source>The single-precision VFPv4 floating-point instructions.</source>
          <target state="translated">单精度VFPv4浮点指令。</target>
        </trans-unit>
        <trans-unit id="d793936d7de82c8ba0aab481f238e4822e465c4a" translate="yes" xml:space="preserve">
          <source>The single-precision floating-point instructions.</source>
          <target state="translated">单精度浮点指令。</target>
        </trans-unit>
        <trans-unit id="2d2a7508c4cb1900d0918961e8e0427152b72902" translate="yes" xml:space="preserve">
          <source>The size in bits of &lt;code&gt;double&lt;/code&gt; if</source>
          <target state="translated">在位大小 &lt;code&gt;double&lt;/code&gt; ，如果</target>
        </trans-unit>
        <trans-unit id="7ecbdd892eade8e6d4362e90240ff9047e6b2c01" translate="yes" xml:space="preserve">
          <source>The size of &lt;code&gt;t1&lt;/code&gt; is 8 bytes with the zero-length bit-field. If the zero-length bit-field were removed, &lt;code&gt;t1&lt;/code&gt;&amp;rsquo;s size would be 4 bytes.</source>
          <target state="translated">&lt;code&gt;t1&lt;/code&gt; 的大小为8个字节，长度为零。如果删除了零长度位域，则 &lt;code&gt;t1&lt;/code&gt; 的大小将为4个字节。</target>
        </trans-unit>
        <trans-unit id="d897dab500e785baf0afcdb6330501b34e2fb781" translate="yes" xml:space="preserve">
          <source>The size of L1 data cache, in kilobytes.</source>
          <target state="translated">L1数据缓存的大小,以千字节为单位。</target>
        </trans-unit>
        <trans-unit id="ff6dd15bf08b6f82cff4329c9e979dcd9c6cbe07" translate="yes" xml:space="preserve">
          <source>The size of L2 data cache, in kilobytes.</source>
          <target state="translated">L2数据缓存的大小,以千字节为单位。</target>
        </trans-unit>
        <trans-unit id="71e800ceb09e88f57e9df529fb883fbfe1a95ef2" translate="yes" xml:space="preserve">
          <source>The size of cache line in L1 data cache, in bytes.</source>
          <target state="translated">L1数据缓存中缓存行的大小,单位:字节。</target>
        </trans-unit>
        <trans-unit id="3f610b8af116509d824f7fee0527a19292abfbc2" translate="yes" xml:space="preserve">
          <source>The size of the result of subtracting two pointers to elements of the same array (C90 6.3.6, C99 and C11 6.5.6).</source>
          <target state="translated">同一数组元素的两个指针相减的结果大小(C90 6.3.6,C99和C11 6.5.6)。</target>
        </trans-unit>
        <trans-unit id="bcebc70f5d364873d98786d882fbb6e891304f9b" translate="yes" xml:space="preserve">
          <source>The sizes of all structures and unions are rounded up to a multiple of the number of bits set by this option. Permissible values are 8, 32 and 64. The default value varies for different toolchains. For the COFF targeted toolchain the default value is 8. A value of 64 is only allowed if the underlying ABI supports it.</source>
          <target state="translated">所有结构体和联合体的大小都被四舍五入到这个选项设置的位数的倍数。允许的值是8、32和64。对于不同的工具链,默认值有所不同。对于以COFF为目标的工具链,默认值为8。只有在底层ABI支持的情况下,才允许使用64的值。</target>
        </trans-unit>
        <trans-unit id="90ff87dc2c61fa6c28fc00209d8623b3de0f7131" translate="yes" xml:space="preserve">
          <source>The small data area consists of sections &lt;code&gt;.sdata&lt;/code&gt; and &lt;code&gt;.sbss&lt;/code&gt;. Objects may be explicitly put in the small data area with the &lt;code&gt;section&lt;/code&gt; attribute using one of these sections.</source>
          <target state="translated">小数据区域由 &lt;code&gt;.sdata&lt;/code&gt; 和 &lt;code&gt;.sbss&lt;/code&gt; 部分组成。可以使用这些节之一将对象明确地置于带有 &lt;code&gt;section&lt;/code&gt; 属性的小数据区域中。</target>
        </trans-unit>
        <trans-unit id="1c7aae5531671a570fbd2d9e15330b629b257be9" translate="yes" xml:space="preserve">
          <source>The smallest number of different values for which it is best to use a jump-table instead of a tree of conditional branches. If the value is 0, use the default for the machine.</source>
          <target state="translated">最好使用跳转表而不是条件分支树的不同值的最小数量。如果数值为0,则使用机器的默认值。</target>
        </trans-unit>
        <trans-unit id="792c114efc46a607cc045f1ab679489dd4452c8d" translate="yes" xml:space="preserve">
          <source>The solution is to change your program to use appropriate system headers (&lt;code&gt;&amp;lt;time.h&amp;gt;&lt;/code&gt; on systems with ISO C headers) and not to declare &lt;code&gt;time&lt;/code&gt; if the system header files declare it, or failing that to use &lt;code&gt;time_t&lt;/code&gt; as the return type of &lt;code&gt;time&lt;/code&gt;.</source>
          <target state="translated">解决方案是将程序更改为使用适当的系统头（在具有ISO C头的系统上为 &lt;code&gt;&amp;lt;time.h&amp;gt;&lt;/code&gt; ），而不是在系统头文件声明了 &lt;code&gt;time&lt;/code&gt; 情况下声明时间，或者不使用 &lt;code&gt;time_t&lt;/code&gt; 作为 &lt;code&gt;time&lt;/code&gt; 的返回类型。</target>
        </trans-unit>
        <trans-unit id="7081cb8d8850184ab64a42d1afab009a2529d69a" translate="yes" xml:space="preserve">
          <source>The solution is to not use the</source>
          <target state="translated">解决办法是不使用</target>
        </trans-unit>
        <trans-unit id="3f3e873518a99bceb250e9bd12263d250fd2ddde" translate="yes" xml:space="preserve">
          <source>The solution to these problems is to change the program to use &lt;code&gt;char&lt;/code&gt;-array variables with initialization strings for these purposes instead of string constants.</source>
          <target state="translated">解决这些问题的方法是，将程序更改为使用带初始化字符串的 &lt;code&gt;char&lt;/code&gt; -array变量而不是字符串常量，以达到这些目的。</target>
        </trans-unit>
        <trans-unit id="65b067ba968d3fec2486b7d081b6185964ff8af7" translate="yes" xml:space="preserve">
          <source>The stack is not unwound before std::terminate is called.</source>
          <target state="translated">在调用std::terminate之前,堆栈不会被解开。</target>
        </trans-unit>
        <trans-unit id="2ac8658551fc80e0b476a0a64406cc85ed6f059b" translate="yes" xml:space="preserve">
          <source>The stack pointer (SP) register is treated as 8-bit respectively 16-bit register by the compiler. The definition of these macros is affected by</source>
          <target state="translated">堆栈指针(SP)寄存器被编译器视为8位和16位寄存器。这些宏的定义受</target>
        </trans-unit>
        <trans-unit id="ba04d525c72586baf4467ca71d2abc7ef4aa1e82" translate="yes" xml:space="preserve">
          <source>The stack pointer register (&lt;code&gt;SP&lt;/code&gt;)</source>
          <target state="translated">堆栈指针寄存器（ &lt;code&gt;SP&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="0015c9e48f6bee73194b21376b4a1e1666cb6b7a" translate="yes" xml:space="preserve">
          <source>The stack pointer register.</source>
          <target state="translated">栈指针寄存器。</target>
        </trans-unit>
        <trans-unit id="7d93215dea1d74a35177f108c830b25b0a828601" translate="yes" xml:space="preserve">
          <source>The standard also defines two environments for programs, a &lt;em&gt;freestanding environment&lt;/em&gt;, required of all implementations and which may not have library facilities beyond those required of freestanding implementations, where the handling of program startup and termination are implementation-defined; and a &lt;em&gt;hosted environment&lt;/em&gt;, which is not required, in which all the library facilities are provided and startup is through a function &lt;code&gt;int
main (void)&lt;/code&gt; or &lt;code&gt;int main (int, char *[])&lt;/code&gt;. An OS kernel is an example of a program running in a freestanding environment; a program using the facilities of an operating system is an example of a program running in a hosted environment.</source>
          <target state="translated">该标准还为程序定义了两个环境，一个&lt;em&gt;独立的环境&lt;/em&gt;，是所有实现所必需的，并且可能不具有独立实现所要求的库功能，在这些环境中，程序启动和终止的处理是实现定义的；以及一个不需要的&lt;em&gt;托管环境&lt;/em&gt;，在该&lt;em&gt;环境&lt;/em&gt;中提供了所有库工具，并且可以通过函数 &lt;code&gt;int main (void)&lt;/code&gt; 或 &lt;code&gt;int main (int, char *[])&lt;/code&gt; 。 OS内核是在独立环境中运行的程序的示例。使用操作系统的功能的程序是在托管环境中运行的程序的示例。</target>
        </trans-unit>
        <trans-unit id="aa6db7352466c6267511c0ba5dc350845fe3cad9" translate="yes" xml:space="preserve">
          <source>The standard is worded confusingly, therefore there is some debate over the precise meaning of the sequence point rules in subtle cases. Links to discussions of the problem, including proposed formal definitions, may be found on the GCC readings page, at &lt;a href=&quot;http://gcc.gnu.org/readings.html&quot;&gt;http://gcc.gnu.org/readings.html&lt;/a&gt;.</source>
          <target state="translated">该标准的措词令人迷惑，因此在细微情况下对序列点规则的确切含义存在一些争议。有关该问题的讨论的链接，包括提议的正式定义，可以在GCC阅读页面上找到，&lt;a href=&quot;http://gcc.gnu.org/readings.html&quot;&gt;网址&lt;/a&gt;为http://gcc.gnu.org/readings.html。</target>
        </trans-unit>
        <trans-unit id="69cda6ddbf344279c641ca143790b176ad293ac4" translate="yes" xml:space="preserve">
          <source>The standard rules for &lt;code&gt;&amp;lt;tgmath.h&amp;gt;&lt;/code&gt; macros are used to find a common type &lt;var&gt;u&lt;/var&gt; from the types of the arguments for parameters whose types vary between the functions; complex integer types (a GNU extension) are treated like &lt;code&gt;_Complex double&lt;/code&gt; for this purpose (or &lt;code&gt;_Complex _Float64&lt;/code&gt; if all the function return types are the same &lt;code&gt;_Float&lt;var&gt;n&lt;/var&gt;&lt;/code&gt; or &lt;code&gt;_Float&lt;var&gt;n&lt;/var&gt;x&lt;/code&gt; type). If the function return types vary, or are all the same integer type, the function called is the one for which &lt;var&gt;t&lt;/var&gt; is &lt;var&gt;u&lt;/var&gt;, and it is an error if there is no such function. If the function return types are all the same floating-point type, the type-generic macro is taken to be one of those from TS 18661 that rounds the result to a narrower type; if there is a function for which &lt;var&gt;t&lt;/var&gt; is &lt;var&gt;u&lt;/var&gt;, it is called, and otherwise the first function, if any, for which &lt;var&gt;t&lt;/var&gt; has at least the range and precision of &lt;var&gt;u&lt;/var&gt; is called, and it is an error if there is no such function.</source>
          <target state="translated">&lt;code&gt;&amp;lt;tgmath.h&amp;gt;&lt;/code&gt; 宏的标准规则用于从参数的参数类型中查找公共类型 &lt;var&gt;u&lt;/var&gt; ，参数的类型在函数之间有所不同。为此，将复杂的整数类型（GNU扩展）视为 &lt;code&gt;_Complex double&lt;/code&gt; （或 &lt;code&gt;_Complex _Float64&lt;/code&gt; ,如果所有函数返回类型均为相同的 &lt;code&gt;_Float&lt;var&gt;n&lt;/var&gt;&lt;/code&gt; 或 &lt;code&gt;_Float&lt;var&gt;n&lt;/var&gt;x&lt;/code&gt; 类型）。如果函数的返回类型不同，或者都是相同的整数类型，则调用的函数是 &lt;var&gt;t&lt;/var&gt; 为 &lt;var&gt;u&lt;/var&gt; 的函数。，如果没有这样的功能，那就是错误。如果函数返回类型都是相同的浮点类型，则将类型通用宏视为TS 18661中将结果四舍五入为较窄类型的宏之一；如果存在一个 &lt;var&gt;t&lt;/var&gt; 为 &lt;var&gt;u&lt;/var&gt; 的函数，则调用它，否则调用第一个函数（如果有的话），其 &lt;var&gt;t&lt;/var&gt; 至少具有 &lt;var&gt;u&lt;/var&gt; 的范围和精度，并且如果没有这样的函数，则为错误。</target>
        </trans-unit>
        <trans-unit id="806ce7f42e8deb00dbd822deaceb91e1417e5da0" translate="yes" xml:space="preserve">
          <source>The startup code from libgcc never sets &lt;code&gt;EIND&lt;/code&gt;. Notice that startup code is a blend of code from libgcc and AVR-LibC. For the impact of AVR-LibC on &lt;code&gt;EIND&lt;/code&gt;, see the &lt;a href=&quot;http://nongnu.org/avr-libc/user-manual/&quot;&gt;AVR-LibC user manual&lt;/a&gt;.</source>
          <target state="translated">libgcc的启动代码从不设置 &lt;code&gt;EIND&lt;/code&gt; 。请注意，启动代码是来自libgcc和AVR-LibC的代码的混合。有关AVR-LibC对 &lt;code&gt;EIND&lt;/code&gt; 的影响，请参阅&lt;a href=&quot;http://nongnu.org/avr-libc/user-manual/&quot;&gt;AVR-LibC用户手册&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f98c1752aa45287d5195f68be596da96d8fbbbe6" translate="yes" xml:space="preserve">
          <source>The startup code initializes the &lt;code&gt;RAMP&lt;/code&gt; special function registers with zero.</source>
          <target state="translated">启动代码将 &lt;code&gt;RAMP&lt;/code&gt; 特殊功能寄存器初始化为零。</target>
        </trans-unit>
        <trans-unit id="e0593142bdd3bdb84b9aebea225043f72be034cf" translate="yes" xml:space="preserve">
          <source>The storage for an object of thread storage duration shall be statically initialized before the first statement of the thread startup function. An object of thread storage duration shall not require dynamic initialization.</source>
          <target state="translated">线程存储持续时间的对象的存储应在线程启动函数的第一条语句之前进行静态初始化。线程存储持续时间的对象不应要求动态初始化。</target>
        </trans-unit>
        <trans-unit id="641e9d242dbf689a8dfa4b2d4275700a77a5107c" translate="yes" xml:space="preserve">
          <source>The stored representation of the return address in memory may be different from the address returned by &lt;code&gt;__builtin_return_address&lt;/code&gt;. For example, on AArch64 the stored address may be mangled with return address signing whereas the address returned by &lt;code&gt;__builtin_return_address&lt;/code&gt; is not.</source>
          <target state="translated">返回地址在内存中存储的表示形式可能与 &lt;code&gt;__builtin_return_address&lt;/code&gt; 返回的地址不同。例如，在AArch64上，存储的地址可能会用返回地址签名进行修饰，而 &lt;code&gt;__builtin_return_address&lt;/code&gt; 返回的地址则不会。</target>
        </trans-unit>
        <trans-unit id="2f4b780083ada416a6c378ae8867cc1c7fb0b433" translate="yes" xml:space="preserve">
          <source>The structure has size zero. In C++, empty structures are part of the language. G++ treats empty structures as if they had a single member of type &lt;code&gt;char&lt;/code&gt;.</source>
          <target state="translated">该结构的大小为零。在C ++中，空结构是该语言的一部分。G ++将空结构视为具有 &lt;code&gt;char&lt;/code&gt; 类型的单个成员。</target>
        </trans-unit>
        <trans-unit id="3c2ecce652896fa952e1019513fab67001397b36" translate="yes" xml:space="preserve">
          <source>The subtype of the file created (like &amp;lsquo;</source>
          <target state="translated">创建的文件的子类型（如&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="ca6a165fe3653c2eaa19af3a9cacad8cee1b0aa0" translate="yes" xml:space="preserve">
          <source>The switch matching text &lt;code&gt;S&lt;/code&gt; in a &amp;lsquo;</source>
          <target state="translated">开关匹配'中的文本 &lt;code&gt;S&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2591c1475ef50f2d7871f5727f318ca9819d88ef" translate="yes" xml:space="preserve">
          <source>The syntax for this extension is</source>
          <target state="translated">该扩展的语法是</target>
        </trans-unit>
        <trans-unit id="c37c4e36af6f9d7c15727a683845a9a4d1ae812e" translate="yes" xml:space="preserve">
          <source>The synthetic compare types&amp;ndash;gt, lt, ge, and le.</source>
          <target state="translated">综合比较类型-gt，lt，ge和le。</target>
        </trans-unit>
        <trans-unit id="de0ec84c43a433725bea4939d7d6aa41982b5bb6" translate="yes" xml:space="preserve">
          <source>The system will help save all registers into stack before entering interrupt handler.</source>
          <target state="translated">在进入中断处理程序之前,系统会帮助将所有寄存器保存到栈中。</target>
        </trans-unit>
        <trans-unit id="0b39e2e7f8f008a32869aef147d2dc6314988d7d" translate="yes" xml:space="preserve">
          <source>The system will help save caller registers into stack before entering interrupt handler.</source>
          <target state="translated">在进入中断处理程序之前,系统会帮助将调用者寄存器保存到栈中。</target>
        </trans-unit>
        <trans-unit id="ebaa5c15171a87ae7a332bb49a3f32f19a3aad26" translate="yes" xml:space="preserve">
          <source>The table below lists the &lt;code&gt;v2i16&lt;/code&gt; operation for which hardware support exists for the DSP ASE REV 2. &lt;code&gt;e&lt;/code&gt; and &lt;code&gt;f&lt;/code&gt; are &lt;code&gt;v2i16&lt;/code&gt; values.</source>
          <target state="translated">下表列出了 &lt;code&gt;v2i16&lt;/code&gt; 操作，DSP ASE REV 2支持硬件 &lt;code&gt;e&lt;/code&gt; 和 &lt;code&gt;f&lt;/code&gt; 是 &lt;code&gt;v2i16&lt;/code&gt; 值。</target>
        </trans-unit>
        <trans-unit id="896165ef2a0dc9f91cdad7ea07b67fa41d120e44" translate="yes" xml:space="preserve">
          <source>The table below lists the &lt;code&gt;v2sf&lt;/code&gt; operations for which hardware support exists. &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt; and &lt;code&gt;c&lt;/code&gt; are &lt;code&gt;v2sf&lt;/code&gt; values and &lt;code&gt;x&lt;/code&gt; is an integral value.</source>
          <target state="translated">下表列出了存在硬件支持的 &lt;code&gt;v2sf&lt;/code&gt; 操作。 &lt;code&gt;a&lt;/code&gt; ， &lt;code&gt;b&lt;/code&gt; 和 &lt;code&gt;c&lt;/code&gt; 是 &lt;code&gt;v2sf&lt;/code&gt; 值， &lt;code&gt;x&lt;/code&gt; 是整数值。</target>
        </trans-unit>
        <trans-unit id="9b038d441c31fe7fb35f36ddaf2d9c7ea6b680b8" translate="yes" xml:space="preserve">
          <source>The table below lists the &lt;code&gt;v4i8&lt;/code&gt; and &lt;code&gt;v2q15&lt;/code&gt; operations for which hardware support exists. &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; are &lt;code&gt;v4i8&lt;/code&gt; values, and &lt;code&gt;c&lt;/code&gt; and &lt;code&gt;d&lt;/code&gt; are &lt;code&gt;v2q15&lt;/code&gt; values.</source>
          <target state="translated">下表列出了存在硬件支持的 &lt;code&gt;v4i8&lt;/code&gt; 和 &lt;code&gt;v2q15&lt;/code&gt; 操作。 &lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;b&lt;/code&gt; 是 &lt;code&gt;v4i8&lt;/code&gt; 值， &lt;code&gt;c&lt;/code&gt; 和 &lt;code&gt;d&lt;/code&gt; 是 &lt;code&gt;v2q15&lt;/code&gt; 值。</target>
        </trans-unit>
        <trans-unit id="3f249ccb08815c6079cbd323b97a2c4ac2204382" translate="yes" xml:space="preserve">
          <source>The table below lists the supported extensions for each architecture. Architectures not mentioned do not support any extensions.</source>
          <target state="translated">下表列出了每个架构所支持的扩展。未提及的架构不支持任何扩展。</target>
        </trans-unit>
        <trans-unit id="e73d22c03412d342b6a999932c3fa6fbeb3a35b8" translate="yes" xml:space="preserve">
          <source>The table below shows the list of supported modifiers and their effects.</source>
          <target state="translated">下表列出了支持的修改器及其效果。</target>
        </trans-unit>
        <trans-unit id="52323f293e0d860891a87bc29f48cbde573c5856" translate="yes" xml:space="preserve">
          <source>The table below summarizes the permissible values for &lt;var&gt;arch&lt;/var&gt; and the features that they enable by default:</source>
          <target state="translated">下表总结了 &lt;var&gt;arch&lt;/var&gt; 的允许值及其默认情况下启用的功能：</target>
        </trans-unit>
        <trans-unit id="15aee3d23ffff41850eb55f63ba2913dcc2593de" translate="yes" xml:space="preserve">
          <source>The target may also allow additional types in &lt;code&gt;format-arg&lt;/code&gt; attributes. See &lt;a href=&quot;target-format-checks#Target-Format-Checks&quot;&gt;Format Checks Specific to Particular Target Machines&lt;/a&gt;.</source>
          <target state="translated">该目标还可以允许 &lt;code&gt;format-arg&lt;/code&gt; 属性中包含其他类型。请参阅&lt;a href=&quot;target-format-checks#Target-Format-Checks&quot;&gt;特定于特定目标计算机的格式检查&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2e1eb5143cb3645d3e56fe87871163fa73c09f83" translate="yes" xml:space="preserve">
          <source>The target may also provide additional types of format checks. See &lt;a href=&quot;target-format-checks#Target-Format-Checks&quot;&gt;Format Checks Specific to Particular Target Machines&lt;/a&gt;.</source>
          <target state="translated">目标也可以提供其他类型的格式检查。请参阅&lt;a href=&quot;target-format-checks#Target-Format-Checks&quot;&gt;特定于特定目标计算机的格式检查&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0b814fff953e9628f2b901dd62490d599d61582c" translate="yes" xml:space="preserve">
          <source>The the register class of registers that can be used to hold a sibcall call address. I.e., a caller-saved register.</source>
          <target state="translated">寄存器类的寄存器,可以用来保存sibcall调用地址。即调用者保存的寄存器。</target>
        </trans-unit>
        <trans-unit id="e9067dbfe61d5583898a4c222466eaecdc743a7f" translate="yes" xml:space="preserve">
          <source>The third word specifies the source files for those structs for which the compiler should emit debug information. The values &amp;lsquo;</source>
          <target state="translated">第三个单词指定编译器应为其发出调试信息的那些结构的源文件。价值 '</target>
        </trans-unit>
        <trans-unit id="3c2caf56b0822fe7bc0594ac85f716ffb2f0188f" translate="yes" xml:space="preserve">
          <source>The thread that begins execution at the &lt;code&gt;main&lt;/code&gt; function is called the &lt;em&gt;main thread&lt;/em&gt;. It is implementation defined how functions beginning threads other than the main thread are designated or typed. A function so designated, as well as the &lt;code&gt;main&lt;/code&gt; function, is called a &lt;em&gt;thread startup function&lt;/em&gt;. It is implementation defined what happens if a thread startup function returns. It is implementation defined what happens to other threads when any thread calls &lt;code&gt;exit&lt;/code&gt;.</source>
          <target state="translated">在 &lt;code&gt;main&lt;/code&gt; 函数处开始执行的线程称为&lt;em&gt;主线程&lt;/em&gt;。实现定义了如何指定或键入除主线程以外的其他开始线程的功能。这样指定的功能以及 &lt;code&gt;main&lt;/code&gt; 功能称为&lt;em&gt;线程启动功能&lt;/em&gt;。由实现定义，如果线程启动函数返回，将发生什么。由实现定义，当任何线程调用 &lt;code&gt;exit&lt;/code&gt; 时，其他线程会发生什么情况。</target>
        </trans-unit>
        <trans-unit id="b44a5b130a3ceb5fe8f03b1aaa3178d1eeebc449" translate="yes" xml:space="preserve">
          <source>The three types of inlining behave similarly in two important cases: when the &lt;code&gt;inline&lt;/code&gt; keyword is used on a &lt;code&gt;static&lt;/code&gt; function, like the example above, and when a function is first declared without using the &lt;code&gt;inline&lt;/code&gt; keyword and then is defined with &lt;code&gt;inline&lt;/code&gt;, like this:</source>
          <target state="translated">三种类型的内联的行为类似地在两个重要的情况：当 &lt;code&gt;inline&lt;/code&gt; 关键字用于在 &lt;code&gt;static&lt;/code&gt; 功能，如上面的例子，当一个函数被首先声明不使用 &lt;code&gt;inline&lt;/code&gt; 的关键字，然后用所定义 &lt;code&gt;inline&lt;/code&gt; ，如下所示：</target>
        </trans-unit>
        <trans-unit id="603ab7e85053589e42da345836681d51d569791a" translate="yes" xml:space="preserve">
          <source>The threshold ratio for performing partial redundancy elimination after reload.</source>
          <target state="translated">重载后执行部分冗余消除的阈值比。</target>
        </trans-unit>
        <trans-unit id="423954d242ed49c029dc872280561e1e359efe72" translate="yes" xml:space="preserve">
          <source>The threshold ratio of critical edges execution count that permit performing redundancy elimination after reload.</source>
          <target state="translated">允许在重载后执行冗余消除的关键边缘执行数的阈值比。</target>
        </trans-unit>
        <trans-unit id="a881665cedd4653a3bb7d98fcef7595547272bb0" translate="yes" xml:space="preserve">
          <source>The total number of input + output + goto operands is limited to 30.</source>
          <target state="translated">输入+输出+goto操作数的总数限制在30个。</target>
        </trans-unit>
        <trans-unit id="b51a43aea88607f1a48139a383f2efbea483ea5b" translate="yes" xml:space="preserve">
          <source>The total size (in bytes) required to pass all the parameters. This includes the two hidden parameters (the object &lt;code&gt;self&lt;/code&gt; and the method selector &lt;code&gt;_cmd&lt;/code&gt;).</source>
          <target state="translated">传递所有参数所需的总大小（以字节为单位）。这包括两个隐藏参数（对象 &lt;code&gt;self&lt;/code&gt; 和方法选择器 &lt;code&gt;_cmd&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="d0dea0413ee420eebb0c3352fcc9737b26d047ac" translate="yes" xml:space="preserve">
          <source>The transaction aborted due to a persistent failure. Re-execution under same circumstances will not be productive.</source>
          <target state="translated">交易因持续失败而中止。在同样情况下重新执行不会有结果。</target>
        </trans-unit>
        <trans-unit id="7970397dce5e9b8e0cc50cc8d7046872a5452379" translate="yes" xml:space="preserve">
          <source>The transaction aborted due to a transient failure. The transaction should be re-executed in that case.</source>
          <target state="translated">交易因短暂的故障而中止。在这种情况下,应重新执行该交易。</target>
        </trans-unit>
        <trans-unit id="885e4cc2a7b2481bfb38880d5bc544bde78ed78c" translate="yes" xml:space="preserve">
          <source>The transaction was aborted due to an indeterminate condition which might be persistent.</source>
          <target state="translated">交易因可能持续存在的不确定条件而中止。</target>
        </trans-unit>
        <trans-unit id="eed635303d722768beed9ca9a2d786f5922ad4e3" translate="yes" xml:space="preserve">
          <source>The two Scalar Reduction of Aggregates passes (SRA and IPA-SRA) aim to replace scalar parts of aggregates with uses of independent scalar variables. These parameters control the maximum size, in storage units, of aggregate which is considered for replacement when compiling for speed (</source>
          <target state="translated">聚合体的两个标量缩减通道(SRA和IPA-SRA)旨在用独立标量变量的使用来替换聚合体的标量部分。这些参数控制了编译速度时考虑替换的聚合的最大尺寸,以存储单位为单位 (</target>
        </trans-unit>
        <trans-unit id="d922516e422c7b0576d05743cb3430b4c8056971" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;char&lt;/code&gt; is always a distinct type from each of &lt;code&gt;signed char&lt;/code&gt; or &lt;code&gt;unsigned char&lt;/code&gt;, even though its behavior is always just like one of those two.</source>
          <target state="translated">&lt;code&gt;char&lt;/code&gt; 类型始终是与每个有 &lt;code&gt;signed char&lt;/code&gt; 或 &lt;code&gt;unsigned char&lt;/code&gt; 截然不同的类型，即使它的行为总是与这两个字符之一相同。</target>
        </trans-unit>
        <trans-unit id="7f1531d2ff0ef2100fb6dbf78b0a6f5c969ddbe3" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;int[]&lt;/code&gt; and &lt;code&gt;int[5]&lt;/code&gt; are compatible. On the other hand, &lt;code&gt;int&lt;/code&gt; and &lt;code&gt;char *&lt;/code&gt; are not compatible, even if the size of their types, on the particular architecture are the same. Also, the amount of pointer indirection is taken into account when determining similarity. Consequently, &lt;code&gt;short *&lt;/code&gt; is not similar to &lt;code&gt;short **&lt;/code&gt;. Furthermore, two types that are typedefed are considered compatible if their underlying types are compatible.</source>
          <target state="translated">类型 &lt;code&gt;int[]&lt;/code&gt; 和 &lt;code&gt;int[5]&lt;/code&gt; 是兼容的。另一方面， &lt;code&gt;int&lt;/code&gt; 和 &lt;code&gt;char *&lt;/code&gt; 不兼容，即使它们的类型大小在特定体系结构上相同。同样，在确定相似性时要考虑指针间接的数量。因此， &lt;code&gt;short *&lt;/code&gt; 与 &lt;code&gt;short **&lt;/code&gt; 不相似。此外，如果两个类型定义的类型的基础类型兼容，则认为它们是兼容的。</target>
        </trans-unit>
        <trans-unit id="8f524b48e32ad47b9a83509e089c5a5e1558b871" translate="yes" xml:space="preserve">
          <source>The type of an object with thread storage duration shall not have a non-trivial destructor, nor shall it be an array type whose elements (directly or indirectly) have non-trivial destructors.</source>
          <target state="translated">具有线程存储持续时间的对象类型不得有非平凡的析出器,也不得是元素(直接或间接)具有非平凡析出器的数组类型。</target>
        </trans-unit>
        <trans-unit id="c90fc1cb110409689f90a0be940bc7d5911aa3a0" translate="yes" xml:space="preserve">
          <source>The type of these constants follows the same rules as for octal or hexadecimal integer constants, so suffixes like &amp;lsquo;</source>
          <target state="translated">这些常量的类型遵循与八进制或十六进制整数常量相同的规则，因此后缀如'</target>
        </trans-unit>
        <trans-unit id="3e1c0747061b6e04e40c5232315c9ae3b95fbcea" translate="yes" xml:space="preserve">
          <source>The type specifiers are encoded just before the type. Unlike types however, the type specifiers are only encoded when they appear in method argument types.</source>
          <target state="translated">类型指定符是在类型之前进行编码的。但与类型不同的是,类型指定符只有在方法参数类型中出现时才会被编码。</target>
        </trans-unit>
        <trans-unit id="235cfb0079f1cae5d7bcfb5a4109668420b1ba20" translate="yes" xml:space="preserve">
          <source>The types are encoded in the following way:</source>
          <target state="translated">这些类型的编码方式如下:</target>
        </trans-unit>
        <trans-unit id="a29416c27e6f97b9abc061da191be4a6083d70bc" translate="yes" xml:space="preserve">
          <source>The types defined in this manner can be used with a subset of normal C operations. Currently, GCC allows using the following operators on these types: &lt;code&gt;+, -, *, /, unary minus, ^, |, &amp;amp;, ~, %&lt;/code&gt;.</source>
          <target state="translated">以这种方式定义的类型可以与正常C操作的子集一起使用。当前，GCC允许对这些类型使用以下运算符： &lt;code&gt;+, -, *, /, unary minus, ^, |, &amp;amp;, ~, %&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e3fa8117933503d7edf67d6eb175e6d2d580176b" translate="yes" xml:space="preserve">
          <source>The types of long calls used depends on the capabilities of the assembler and linker, and the type of code being generated. The impact on systems that support long absolute calls, and long pic symbol-difference or pc-relative calls should be relatively small. However, an indirect call is used on 32-bit ELF systems in pic code and it is quite long.</source>
          <target state="translated">使用的长调用类型取决于汇编器和链接器的能力,以及正在生成的代码类型。对支持长绝对调用的系统,以及长pic符号差或pc相关调用的影响应该比较小。但是,在32位ELF系统的pic代码中使用了间接调用,而且时间相当长。</target>
        </trans-unit>
        <trans-unit id="ec5bc88005ecf61d67656c8a050fcb6e58f804f9" translate="yes" xml:space="preserve">
          <source>The types of the specified functions must all be different, but related to each other in the same way as a set of functions that may be selected between by a macro in &lt;code&gt;&amp;lt;tgmath.h&amp;gt;&lt;/code&gt;. This means that the functions are parameterized by a floating-point type &lt;var&gt;t&lt;/var&gt;, different for each such function. The function return types may all be the same type, or they may be &lt;var&gt;t&lt;/var&gt; for each function, or they may be the real type corresponding to &lt;var&gt;t&lt;/var&gt; for each function (if some of the types &lt;var&gt;t&lt;/var&gt; are complex). Likewise, for each parameter position, the type of the parameter in that position may always be the same type, or may be &lt;var&gt;t&lt;/var&gt; for each function (this case must apply for at least one parameter position), or may be the real type corresponding to &lt;var&gt;t&lt;/var&gt; for each function.</source>
          <target state="translated">指定函数的类型必须全部不同，但彼此之间的关联方式与可能由 &lt;code&gt;&amp;lt;tgmath.h&amp;gt;&lt;/code&gt; 中的宏在其中选择的一组函数相同。这意味着这些函数由浮点类型 &lt;var&gt;t&lt;/var&gt; 进行参数化，每个浮点类型t都不同。函数返回类型可以全部是同一类型，或者对于每个函数它们可以是 &lt;var&gt;t&lt;/var&gt; ，或者对于每个函数它们可以是与 &lt;var&gt;t&lt;/var&gt; 对应的实数类型（如果某些类型 &lt;var&gt;t&lt;/var&gt; 是复杂的）。同样，对于每个参数位置，该位置中参数的类型可能始终是相同类型，或者可能是 &lt;var&gt;t&lt;/var&gt; 对于每个函数（这种情况必须至少适用于一个参数位置），或者可以是与每个函数的 &lt;var&gt;t&lt;/var&gt; 对应的实数类型。</target>
        </trans-unit>
        <trans-unit id="562884deec4ebf19cace230c1d8314c9d6fd11a3" translate="yes" xml:space="preserve">
          <source>The typical use of extended &lt;code&gt;asm&lt;/code&gt; statements is to manipulate input values to produce output values. However, your &lt;code&gt;asm&lt;/code&gt; statements may also produce side effects. If so, you may need to use the &lt;code&gt;volatile&lt;/code&gt; qualifier to disable certain optimizations. See &lt;a href=&quot;#Volatile&quot;&gt;Volatile&lt;/a&gt;.</source>
          <target state="translated">扩展 &lt;code&gt;asm&lt;/code&gt; 语句的典型用法是操纵输入值以产生输出值。但是，您的 &lt;code&gt;asm&lt;/code&gt; 语句也可能会产生副作用。如果是这样，您可能需要使用 &lt;code&gt;volatile&lt;/code&gt; 限定符来禁用某些优化。参见&lt;a href=&quot;#Volatile&quot;&gt;挥发性&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="45e652bb27a2083165bac75933fd850a0641a946" translate="yes" xml:space="preserve">
          <source>The unary plus operator.</source>
          <target state="translated">单音加运算符。</target>
        </trans-unit>
        <trans-unit id="5b7b641512751385c6d2814d121dfa7956a428c3" translate="yes" xml:space="preserve">
          <source>The underlying type of &lt;code&gt;type&lt;/code&gt;. Requires: &lt;code&gt;type&lt;/code&gt; shall be an enumeration type ([dcl.enum]).</source>
          <target state="translated">类型的基础 &lt;code&gt;type&lt;/code&gt; 。要求： &lt;code&gt;type&lt;/code&gt; 必须是枚举类型（[dcl.enum]）。</target>
        </trans-unit>
        <trans-unit id="4c9e93062c090121b29c563680d663f3d3e33b8a" translate="yes" xml:space="preserve">
          <source>The unique value of the member of the execution character set produced for each of the standard alphabetic escape sequences (C90, C99 and C11 5.2.2).</source>
          <target state="translated">为每个标准字母转义序列(C90、C99和C11 5.2.2)产生的执行字符集成员的唯一值。</target>
        </trans-unit>
        <trans-unit id="6e9148f286cc806482521d7ebb582ea948e1076d" translate="yes" xml:space="preserve">
          <source>The use of default arguments in function pointers, function typedefs and other places where they are not permitted by the standard is deprecated and will be removed from a future version of G++.</source>
          <target state="translated">在函数指针、函数类型定义和其他标准不允许的地方使用默认参数是被废弃的,并将在G++的未来版本中删除。</target>
        </trans-unit>
        <trans-unit id="cb0aac07569b8c035da4f2196d548847237b0a9f" translate="yes" xml:space="preserve">
          <source>The usual calling convention has functions return values of types &lt;code&gt;float&lt;/code&gt; and &lt;code&gt;double&lt;/code&gt; in an FPU register, even if there is no FPU. The idea is that the operating system should emulate an FPU.</source>
          <target state="translated">通常的调用约定在FPU寄存器中具有返回 &lt;code&gt;float&lt;/code&gt; 和 &lt;code&gt;double&lt;/code&gt; 类型的值的函数，即使没有FPU也是如此。这个想法是操作系统应该模拟FPU。</target>
        </trans-unit>
        <trans-unit id="ad7784f3ecb2fcf462bcebb606253d24e3e9713b" translate="yes" xml:space="preserve">
          <source>The usual way to run GCC is to run the executable called &lt;code&gt;gcc&lt;/code&gt;, or &lt;code&gt;&lt;var&gt;machine&lt;/var&gt;-gcc&lt;/code&gt; when cross-compiling, or &lt;code&gt;&lt;var&gt;machine&lt;/var&gt;-gcc-&lt;var&gt;version&lt;/var&gt;&lt;/code&gt; to run a specific version of GCC. When you compile C++ programs, you should invoke GCC as &lt;code&gt;g++&lt;/code&gt; instead. See &lt;a href=&quot;invoking-g_002b_002b#Invoking-G_002b_002b&quot;&gt;Compiling C++ Programs&lt;/a&gt;, for information about the differences in behavior between &lt;code&gt;gcc&lt;/code&gt; and &lt;code&gt;g++&lt;/code&gt; when compiling C++ programs.</source>
          <target state="translated">运行GCC的常用方法是运行可执行文件，称为 &lt;code&gt;gcc&lt;/code&gt; ，或 &lt;code&gt;&lt;var&gt;machine&lt;/var&gt;-gcc&lt;/code&gt; 时，交叉编译，或者 &lt;code&gt;&lt;var&gt;machine&lt;/var&gt;-gcc-&lt;var&gt;version&lt;/var&gt;&lt;/code&gt; 运行GCC的特定版本。编译C ++程序时，应改为将GCC作为 &lt;code&gt;g++&lt;/code&gt; 调用。有关在&lt;a href=&quot;invoking-g_002b_002b#Invoking-G_002b_002b&quot;&gt;编译C ++程序&lt;/a&gt;时 &lt;code&gt;gcc&lt;/code&gt; 和 &lt;code&gt;g++&lt;/code&gt; 在行为上的差异的信息，请参见编译C ++程序。</target>
        </trans-unit>
        <trans-unit id="b063501b645eb4fe8a716599b0b7b68ac7473998" translate="yes" xml:space="preserve">
          <source>The valid memory order variants are &lt;code&gt;__ATOMIC_RELAXED&lt;/code&gt;, &lt;code&gt;__ATOMIC_SEQ_CST&lt;/code&gt;, &lt;code&gt;__ATOMIC_ACQUIRE&lt;/code&gt;, &lt;code&gt;__ATOMIC_RELEASE&lt;/code&gt;, and &lt;code&gt;__ATOMIC_ACQ_REL&lt;/code&gt;.</source>
          <target state="translated">有效的内存顺序变量是 &lt;code&gt;__ATOMIC_RELAXED&lt;/code&gt; ， &lt;code&gt;__ATOMIC_SEQ_CST&lt;/code&gt; ， &lt;code&gt;__ATOMIC_ACQUIRE&lt;/code&gt; ， &lt;code&gt;__ATOMIC_RELEASE&lt;/code&gt; 和 &lt;code&gt;__ATOMIC_ACQ_REL&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6cc836f5cd3d793de6c86ebfa23594977254dab4" translate="yes" xml:space="preserve">
          <source>The valid memory order variants are &lt;code&gt;__ATOMIC_RELAXED&lt;/code&gt;, &lt;code&gt;__ATOMIC_SEQ_CST&lt;/code&gt;, &lt;code&gt;__ATOMIC_ACQUIRE&lt;/code&gt;, and &lt;code&gt;__ATOMIC_CONSUME&lt;/code&gt;.</source>
          <target state="translated">有效的内存顺序变量是 &lt;code&gt;__ATOMIC_RELAXED&lt;/code&gt; ， &lt;code&gt;__ATOMIC_SEQ_CST&lt;/code&gt; ， &lt;code&gt;__ATOMIC_ACQUIRE&lt;/code&gt; 和 &lt;code&gt;__ATOMIC_CONSUME&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1b387c15b8d7905431f6ee70a72792d2b995cec6" translate="yes" xml:space="preserve">
          <source>The valid memory order variants are &lt;code&gt;__ATOMIC_RELAXED&lt;/code&gt;, &lt;code&gt;__ATOMIC_SEQ_CST&lt;/code&gt;, and &lt;code&gt;__ATOMIC_RELEASE&lt;/code&gt;.</source>
          <target state="translated">有效的内存顺序变量是 &lt;code&gt;__ATOMIC_RELAXED&lt;/code&gt; ， &lt;code&gt;__ATOMIC_SEQ_CST&lt;/code&gt; 和 &lt;code&gt;__ATOMIC_RELEASE&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b6608eaa83f451be81718292f24c656e5976df89" translate="yes" xml:space="preserve">
          <source>The value &amp;lsquo;</source>
          <target state="translated">价值 '</target>
        </trans-unit>
        <trans-unit id="9b81b1fa621fe4401621371ef2fb0416c4e7ec83" translate="yes" xml:space="preserve">
          <source>The value &lt;code&gt;branch&lt;/code&gt; tells the compiler to implement checking of validity of control-flow transfer at the point of indirect branch instructions, i.e. call/jmp instructions. The value &lt;code&gt;return&lt;/code&gt; implements checking of validity at the point of returning from a function. The value &lt;code&gt;full&lt;/code&gt; is an alias for specifying both &lt;code&gt;branch&lt;/code&gt; and &lt;code&gt;return&lt;/code&gt;. The value &lt;code&gt;none&lt;/code&gt; turns off instrumentation.</source>
          <target state="translated">值 &lt;code&gt;branch&lt;/code&gt; 告诉编译器在间接分支指令（即调用/ jmp指令）处执行控制流传输的有效性检查。值 &lt;code&gt;return&lt;/code&gt; 在从函数返回时实现有效性检查。 &lt;code&gt;full&lt;/code&gt; 值是用于指定 &lt;code&gt;branch&lt;/code&gt; 和 &lt;code&gt;return&lt;/code&gt; 的别名。该值 &lt;code&gt;none&lt;/code&gt; 关闭仪器。</target>
        </trans-unit>
        <trans-unit id="cec00d8fc6d0d865baf91db330b98c794be36fbd" translate="yes" xml:space="preserve">
          <source>The value &lt;var&gt;N&lt;/var&gt; can be between 0 and 4. A value of 0 (the default) or 4 means that constants of any size are allowed.</source>
          <target state="translated">值 &lt;var&gt;N&lt;/var&gt; 可以在0到4之间。值0（默认值）或4表示允许任何大小的常数。</target>
        </trans-unit>
        <trans-unit id="bb7289e160f23adf91cfa58505c60106049d9e55" translate="yes" xml:space="preserve">
          <source>The value is as specified in the standard and the type is determined by the ABI.</source>
          <target state="translated">该值与标准中规定的一样,类型由ABI确定。</target>
        </trans-unit>
        <trans-unit id="da848852806dcfc33f52696b5619522d23c88e8e" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;COMPILER_PATH&lt;/code&gt; is a colon-separated list of directories, much like &lt;code&gt;PATH&lt;/code&gt;. GCC tries the directories thus specified when searching for subprograms, if it cannot find the subprograms using &lt;code&gt;GCC_EXEC_PREFIX&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;COMPILER_PATH&lt;/code&gt; 的值是用冒号分隔的目录列表，非常类似于 &lt;code&gt;PATH&lt;/code&gt; 。如果无法使用 &lt;code&gt;GCC_EXEC_PREFIX&lt;/code&gt; 找到子程序，则GCC会在搜索子程序时尝试指定的目录。</target>
        </trans-unit>
        <trans-unit id="d72005aff0d80d4d1734d968cb3fab8a6e254f4d" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;DEPENDENCIES_OUTPUT&lt;/code&gt; can be just a file name, in which case the Make rules are written to that file, guessing the target name from the source file name. Or the value can have the form &amp;lsquo;</source>
          <target state="translated">&lt;code&gt;DEPENDENCIES_OUTPUT&lt;/code&gt; 的值可以只是一个文件名，在这种情况下，将Make规则写入该文件，并从源文件名中猜测目标名称。或值可以采用以下形式：</target>
        </trans-unit>
        <trans-unit id="edab9250e0babd1761a6140212faa3d4e9be6f54" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;LIBRARY_PATH&lt;/code&gt; is a colon-separated list of directories, much like &lt;code&gt;PATH&lt;/code&gt;. When configured as a native compiler, GCC tries the directories thus specified when searching for special linker files, if it cannot find them using &lt;code&gt;GCC_EXEC_PREFIX&lt;/code&gt;. Linking using GCC also uses these directories when searching for ordinary libraries for the</source>
          <target state="translated">&lt;code&gt;LIBRARY_PATH&lt;/code&gt; 的值是用冒号分隔的目录列表，非常类似于 &lt;code&gt;PATH&lt;/code&gt; 。当配置为本地编译器时，如果无法使用 &lt;code&gt;GCC_EXEC_PREFIX&lt;/code&gt; 找到特殊的链接器文件，则GCC会尝试搜索指定的目录。在搜索普通库时，使用GCC链接也会使用这些目录。</target>
        </trans-unit>
        <trans-unit id="43d97475c2600c7120869f306bf4b7bed4d2e9bd" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;SOURCE_DATE_EPOCH&lt;/code&gt; must be a UNIX timestamp, defined as the number of seconds (excluding leap seconds) since 01 Jan 1970 00:00:00 represented in ASCII; identical to the output of &amp;lsquo;</source>
          <target state="translated">&lt;code&gt;SOURCE_DATE_EPOCH&lt;/code&gt; 的值必须是UNIX时间戳，定义为自1970年1月1日00:00:00以ASCII表示的秒数（不包括leap秒）。与'的输出相同</target>
        </trans-unit>
        <trans-unit id="66e4ba46bd46984b6c4ee052416293525cc2110b" translate="yes" xml:space="preserve">
          <source>The value of &lt;var&gt;addr&lt;/var&gt; is the address of the memory to prefetch. There are two optional arguments, &lt;var&gt;rw&lt;/var&gt; and &lt;var&gt;locality&lt;/var&gt;. The value of &lt;var&gt;rw&lt;/var&gt; is a compile-time constant one or zero; one means that the prefetch is preparing for a write to the memory address and zero, the default, means that the prefetch is preparing for a read. The value &lt;var&gt;locality&lt;/var&gt; must be a compile-time constant integer between zero and three. A value of zero means that the data has no temporal locality, so it need not be left in the cache after the access. A value of three means that the data has a high degree of temporal locality and should be left in all levels of cache possible. Values of one and two mean, respectively, a low or moderate degree of temporal locality. The default is three.</source>
          <target state="translated">&lt;var&gt;addr&lt;/var&gt; 的值是要预取的内存地址。有两个可选参数 &lt;var&gt;rw&lt;/var&gt; 和 &lt;var&gt;locality&lt;/var&gt; 。 &lt;var&gt;rw&lt;/var&gt; 的值是编译时常数1或0。一个表示预取正在准备对存储器地址进行写操作，默认为零表示该预取正准备进行读操作。价值 &lt;var&gt;locality&lt;/var&gt; 必须是介于0到3之间的编译时常量整数。零值表示数据没有时间局部性，因此在访问后不必将其保留在缓存中。值为3意味着数据具有高度的时间局部性，应保留在所有可能的缓存级别中。值1和2分别表示低或中等程度的时间局部性。默认值为三。</target>
        </trans-unit>
        <trans-unit id="70e11268aef227bb1a15172e67ca65858facec52" translate="yes" xml:space="preserve">
          <source>The value of &lt;var&gt;arguments&lt;/var&gt; should be the value returned by &lt;code&gt;__builtin_apply_args&lt;/code&gt;. The argument &lt;var&gt;size&lt;/var&gt; specifies the size of the stack argument data, in bytes.</source>
          <target state="translated">值 &lt;var&gt;arguments&lt;/var&gt; 应该是返回的值 &lt;code&gt;__builtin_apply_args&lt;/code&gt; 。参数 &lt;var&gt;size&lt;/var&gt; 指定堆栈参数数据的大小（以字节为单位）。</target>
        </trans-unit>
        <trans-unit id="e97b2ef46aa7ac364dbf54d200c4936fb0a11aa0" translate="yes" xml:space="preserve">
          <source>The value of a &lt;code&gt;char&lt;/code&gt; object into which has been stored any character other than a member of the basic execution character set (C90 6.1.2.5, C99 and C11 6.2.5).</source>
          <target state="translated">一个 &lt;code&gt;char&lt;/code&gt; 对象的值，除了基本执行字符集的成员（C90 6.1.2.5，C99和C11 6.2.5）之外，已经存储了任何字符。</target>
        </trans-unit>
        <trans-unit id="c90677fad3803708fba68301854948c65ad2e0dc" translate="yes" xml:space="preserve">
          <source>The value of a string literal containing a multibyte character or escape sequence not represented in the execution character set (C90 6.1.4, C99 and C11 6.4.5).</source>
          <target state="translated">字符串的值,包含一个多字节字符或转义序列,但未在执行字符集中表示(C90 6.1.4、C99和C11 6.4.5)。</target>
        </trans-unit>
        <trans-unit id="0799bf13992e78d42dd3b2499d660140de9cd663" translate="yes" xml:space="preserve">
          <source>The value of a wide character constant containing more than one multibyte character or a single multibyte character that maps to multiple members of the extended execution character set, or containing a multibyte character or escape sequence not represented in the extended execution character set (C90 6.1.3.4, C99 and C11 6.4.4.4).</source>
          <target state="translated">宽字符常量的值,包含一个以上的多字节字符,或一个单一的多字节字符,映射到扩展执行字符集的多个成员,或包含扩展执行字符集中未表示的多字节字符或转义序列(C90 6.1.3.4,C99和C11 6.4.4.4)。</target>
        </trans-unit>
        <trans-unit id="2de23bcdd7f53de07c13a72f7ab5e75f0f064b9a" translate="yes" xml:space="preserve">
          <source>The value of an integer character constant containing more than one character or containing a character or escape sequence that does not map to a single-byte execution character (C90 6.1.3.4, C99 and C11 6.4.4.4).</source>
          <target state="translated">整数字符常量的值,包含一个以上的字符或包含一个不映射到单字节执行字符的字符或转义序列(C90 6.1.3.4、C99和C11 6.4.4.4)。</target>
        </trans-unit>
        <trans-unit id="bddf51b03e8582ac60e5e332485e2f5dfdaadff5" translate="yes" xml:space="preserve">
          <source>The value of the result of the &lt;code&gt;sizeof&lt;/code&gt; and &lt;code&gt;_Alignof&lt;/code&gt; operators (C90 6.3.3.4, C99 and C11 6.5.3.4).</source>
          <target state="translated">&lt;code&gt;sizeof&lt;/code&gt; 和 &lt;code&gt;_Alignof&lt;/code&gt; 运算符的结果值（C90 6.3.3.4，C99和C11 6.5.3.4）。</target>
        </trans-unit>
        <trans-unit id="c0b2873e2d72ded9fcc9fee52452da75fb562815" translate="yes" xml:space="preserve">
          <source>The value should be a known timestamp such as the last modification time of the source or package and it should be set by the build process.</source>
          <target state="translated">这个值应该是一个已知的时间戳,比如源代码或软件包的最后修改时间,它应该由构建过程设置。</target>
        </trans-unit>
        <trans-unit id="e30741bdd1a5b46b18e6720866027b16cbef67a9" translate="yes" xml:space="preserve">
          <source>The values &amp;lsquo;</source>
          <target state="translated">价值 '</target>
        </trans-unit>
        <trans-unit id="0725ef659b65323c744f64d2a18ca8ec4185c000" translate="yes" xml:space="preserve">
          <source>The values of the members of the execution character set (C90, C99 and C11 5.2.1).</source>
          <target state="translated">执行字符集(C90、C99和C11 5.2.1)成员的值;</target>
        </trans-unit>
        <trans-unit id="c50dd57103792a97d47d46235c3239eae04dabde" translate="yes" xml:space="preserve">
          <source>The values or expressions assigned to the macros specified in the headers &lt;code&gt;&amp;lt;float.h&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;limits.h&amp;gt;&lt;/code&gt;, and &lt;code&gt;&amp;lt;stdint.h&amp;gt;&lt;/code&gt; (C90, C99 and C11 5.2.4.2, C99 7.18.2, C99 7.18.3, C11 7.20.2, C11 7.20.3).</source>
          <target state="translated">分配给标头 &lt;code&gt;&amp;lt;float.h&amp;gt;&lt;/code&gt; ， &lt;code&gt;&amp;lt;limits.h&amp;gt;&lt;/code&gt; 和 &lt;code&gt;&amp;lt;stdint.h&amp;gt;&lt;/code&gt; 中指定的宏的值或表达式（C90，C99和C11 5.2.4.2，C99 7.18.2，C99 7.18.3， C11 7.20.2，C11 7.20.3）。</target>
        </trans-unit>
        <trans-unit id="c24e1e6a031d69e73f1ce7f443d81ca980894830" translate="yes" xml:space="preserve">
          <source>The vector type associated with paired-single values is usually called &lt;code&gt;v2sf&lt;/code&gt;. It can be defined in C as follows:</source>
          <target state="translated">与成对的单值关联的向量类型通常称为 &lt;code&gt;v2sf&lt;/code&gt; 。可以在C中定义如下：</target>
        </trans-unit>
        <trans-unit id="37fd6ea52bde5e4eca142e1cb75092f72771ffd7" translate="yes" xml:space="preserve">
          <source>The virtual registers.</source>
          <target state="translated">虚拟寄存器。</target>
        </trans-unit>
        <trans-unit id="72d4e21a353ad4b2c91fcbc017d8cd072d1cc8a4" translate="yes" xml:space="preserve">
          <source>The visibility attribute should be applied only to declarations that would otherwise have external linkage. The attribute should be applied consistently, so that the same entity should not be declared with different settings of the attribute.</source>
          <target state="translated">可见性属性应仅适用于否则会有外部链接的声明。该属性应始终如一地应用,以便不以不同的属性设置来宣布同一实体。</target>
        </trans-unit>
        <trans-unit id="dcdff986b782b656015cb9e4191209d1fd6e3439" translate="yes" xml:space="preserve">
          <source>The warning is not issued after a &lt;code&gt;#line&lt;/code&gt; directive, since this typically indicates autogenerated code, and no assumptions can be made about the layout of the file that the directive references.</source>
          <target state="translated">在 &lt;code&gt;#line&lt;/code&gt; 指令之后不会发出警告，因为该指令通常表示自动生成的代码，因此无法对该指令引用的文件的布局进行任何假设。</target>
        </trans-unit>
        <trans-unit id="c1d163df4c56e51212f1f69dc140213a05352c42" translate="yes" xml:space="preserve">
          <source>The warning is not issued for code involving multiline preprocessor logic such as the following example.</source>
          <target state="translated">对于涉及多行预处理程序逻辑的代码,如下面的例子,不会发出该警告。</target>
        </trans-unit>
        <trans-unit id="dcb7b8cd90065f04f3725df949fc5d9c95db8632" translate="yes" xml:space="preserve">
          <source>The warning message for each controllable warning includes the option that controls the warning. That option can then be used with</source>
          <target state="translated">每个可控警告的警告信息包括控制该警告的选项。该选项可以与</target>
        </trans-unit>
        <trans-unit id="f1f31ebd493031aa0be9fb191d41eda3a3e18dd4" translate="yes" xml:space="preserve">
          <source>The warnings for missing or incorrect sentinels are enabled with</source>
          <target state="translated">启用缺失或错误哨兵的警告,可使用</target>
        </trans-unit>
        <trans-unit id="6fb1f41a4e1e0161c8bf4c849af0ffb5ebafd481" translate="yes" xml:space="preserve">
          <source>The way to solve these problems is to put &amp;lsquo;</source>
          <target state="translated">解决这些问题的方法是将&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="206a81db22964ace6231b75566fe4c7da1707abe" translate="yes" xml:space="preserve">
          <source>The workarounds for the division errata rely on special functions in</source>
          <target state="translated">除法勘误的变通方法依靠的是在 &quot;除法 &quot;中的特殊函数。</target>
        </trans-unit>
        <trans-unit id="3ecc69e9abd77cc6ec0f76d76bb1dccaddb7e950" translate="yes" xml:space="preserve">
          <source>The x86 architecture supports additional memory ordering flags to mark critical sections for hardware lock elision. These must be specified in addition to an existing memory order to atomic intrinsics.</source>
          <target state="translated">x86 架构支持额外的内存排序标志,以标记硬件锁消除的关键部分。除了现有的内存顺序外,还必须指定原子内在的内存顺序。</target>
        </trans-unit>
        <trans-unit id="f94474d9a2fee2945e274919425bc2dedd2ef21c" translate="yes" xml:space="preserve">
          <source>The x86-32 and x86-64 family of processors use additional built-in functions for efficient use of &lt;code&gt;TF&lt;/code&gt; (&lt;code&gt;__float128&lt;/code&gt;) 128-bit floating point and &lt;code&gt;TC&lt;/code&gt; 128-bit complex floating-point values.</source>
          <target state="translated">x86-32和x86-64系列处理器使用其他内置函数来有效利用 &lt;code&gt;TF&lt;/code&gt; （ &lt;code&gt;__float128&lt;/code&gt; ）128位浮点和 &lt;code&gt;TC&lt;/code&gt; 128位复数浮点值。</target>
        </trans-unit>
        <trans-unit id="d02b4be795b4b009422772986429301880a6ca1d" translate="yes" xml:space="preserve">
          <source>Then use the &lt;code&gt;create_gcov&lt;/code&gt; tool to convert the raw profile data to a format that can be used by GCC. You must also supply the unstripped binary for your program to this tool. See &lt;a href=&quot;https://github.com/google/autofdo&quot;&gt;https://github.com/google/autofdo&lt;/a&gt;.</source>
          <target state="translated">然后使用 &lt;code&gt;create_gcov&lt;/code&gt; 工具将原始配置文件数据转换为GCC可以使用的格式。您还必须将程序的未剥离二进制文件提供给此工具。参见&lt;a href=&quot;https://github.com/google/autofdo&quot;&gt;https://github.com/google/autofdo&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="926b284ef06d8680215f804da3458309f6cd9668" translate="yes" xml:space="preserve">
          <source>Then you can select a label with indexing, like this:</source>
          <target state="translated">然后你可以选择一个带有索引的标签,像这样。</target>
        </trans-unit>
        <trans-unit id="cea728bf3b20beeae36b33c3b1a8dc7982befc50" translate="yes" xml:space="preserve">
          <source>There are 6 different memory orders that can be specified. These map to the C++11 memory orders with the same names, see the C++11 standard or the &lt;a href=&quot;http://gcc.gnu.org/wiki/Atomic/GCCMM/AtomicSync&quot;&gt;GCC wiki on atomic synchronization&lt;/a&gt; for detailed definitions. Individual targets may also support additional memory orders for use on specific architectures. Refer to the target documentation for details of these.</source>
          <target state="translated">可以指定6种不同的存储顺序。这些映射到具有相同名称的C ++ 11内存顺序，有关详细定义，请参见C ++ 11标准或&lt;a href=&quot;http://gcc.gnu.org/wiki/Atomic/GCCMM/AtomicSync&quot;&gt;原子同步上&lt;/a&gt;的GCC Wiki。各个目标也可能支持在特定体系结构上使用的其他内存顺序。有关这些的详细信息，请参阅目标文档。</target>
        </trans-unit>
        <trans-unit id="02f6ba3037fb7689eee8ed8968fd8f0d8ac13840" translate="yes" xml:space="preserve">
          <source>There are also GNU extension functions &lt;code&gt;clog10&lt;/code&gt;, &lt;code&gt;clog10f&lt;/code&gt; and &lt;code&gt;clog10l&lt;/code&gt; which names are reserved by ISO C99 for future use. All these functions have versions prefixed with &lt;code&gt;__builtin_&lt;/code&gt;.</source>
          <target state="translated">还有GNU扩展功能 &lt;code&gt;clog10&lt;/code&gt; ， &lt;code&gt;clog10f&lt;/code&gt; 和 &lt;code&gt;clog10l&lt;/code&gt; ，这些名称由ISO C99保留供将来使用。所有这些函数的版本都带有 &lt;code&gt;__builtin_&lt;/code&gt; 前缀。</target>
        </trans-unit>
        <trans-unit id="875ce1195c45f2b46d9a99c39e44fd3ec9b5e9cf" translate="yes" xml:space="preserve">
          <source>There are also built-in functions &lt;code&gt;__builtin_fabsf&lt;var&gt;n&lt;/var&gt;&lt;/code&gt;, &lt;code&gt;__builtin_fabsf&lt;var&gt;n&lt;/var&gt;x&lt;/code&gt;, &lt;code&gt;__builtin_copysignf&lt;var&gt;n&lt;/var&gt;&lt;/code&gt; and &lt;code&gt;__builtin_copysignf&lt;var&gt;n&lt;/var&gt;x&lt;/code&gt;, corresponding to the TS 18661-3 functions &lt;code&gt;fabsf&lt;var&gt;n&lt;/var&gt;&lt;/code&gt;, &lt;code&gt;fabsf&lt;var&gt;n&lt;/var&gt;x&lt;/code&gt;, &lt;code&gt;copysignf&lt;var&gt;n&lt;/var&gt;&lt;/code&gt; and &lt;code&gt;copysignf&lt;var&gt;n&lt;/var&gt;x&lt;/code&gt;, for supported types &lt;code&gt;_Float&lt;var&gt;n&lt;/var&gt;&lt;/code&gt; and &lt;code&gt;_Float&lt;var&gt;n&lt;/var&gt;x&lt;/code&gt;.</source>
          <target state="translated">也有内置函数 &lt;code&gt;__builtin_fabsf&lt;var&gt;n&lt;/var&gt;&lt;/code&gt; ， &lt;code&gt;__builtin_fabsf&lt;var&gt;n&lt;/var&gt;x&lt;/code&gt; ， &lt;code&gt;__builtin_copysignf&lt;var&gt;n&lt;/var&gt;&lt;/code&gt; 和 &lt;code&gt;__builtin_copysignf&lt;var&gt;n&lt;/var&gt;x&lt;/code&gt; ，对应于TS 18661-3功能 &lt;code&gt;fabsf&lt;var&gt;n&lt;/var&gt;&lt;/code&gt; ， &lt;code&gt;fabsf&lt;var&gt;n&lt;/var&gt;x&lt;/code&gt; ， &lt;code&gt;copysignf&lt;var&gt;n&lt;/var&gt;&lt;/code&gt; 和 &lt;code&gt;copysignf&lt;var&gt;n&lt;/var&gt;x&lt;/code&gt; ，支持的类型 &lt;code&gt;_Float&lt;var&gt;n&lt;/var&gt;&lt;/code&gt; 和 &lt;code&gt;_Float&lt;var&gt;n&lt;/var&gt;x&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="10087f06f9970243ffcf86e55d1829b3627290b7" translate="yes" xml:space="preserve">
          <source>There are also built-in versions of the ISO C99 functions &lt;code&gt;acosf&lt;/code&gt;, &lt;code&gt;acosl&lt;/code&gt;, &lt;code&gt;asinf&lt;/code&gt;, &lt;code&gt;asinl&lt;/code&gt;, &lt;code&gt;atan2f&lt;/code&gt;, &lt;code&gt;atan2l&lt;/code&gt;, &lt;code&gt;atanf&lt;/code&gt;, &lt;code&gt;atanl&lt;/code&gt;, &lt;code&gt;ceilf&lt;/code&gt;, &lt;code&gt;ceill&lt;/code&gt;, &lt;code&gt;cosf&lt;/code&gt;, &lt;code&gt;coshf&lt;/code&gt;, &lt;code&gt;coshl&lt;/code&gt;, &lt;code&gt;cosl&lt;/code&gt;, &lt;code&gt;expf&lt;/code&gt;, &lt;code&gt;expl&lt;/code&gt;, &lt;code&gt;fabsf&lt;/code&gt;, &lt;code&gt;fabsl&lt;/code&gt;, &lt;code&gt;floorf&lt;/code&gt;, &lt;code&gt;floorl&lt;/code&gt;, &lt;code&gt;fmodf&lt;/code&gt;, &lt;code&gt;fmodl&lt;/code&gt;, &lt;code&gt;frexpf&lt;/code&gt;, &lt;code&gt;frexpl&lt;/code&gt;, &lt;code&gt;ldexpf&lt;/code&gt;, &lt;code&gt;ldexpl&lt;/code&gt;, &lt;code&gt;log10f&lt;/code&gt;, &lt;code&gt;log10l&lt;/code&gt;, &lt;code&gt;logf&lt;/code&gt;, &lt;code&gt;logl&lt;/code&gt;, &lt;code&gt;modfl&lt;/code&gt;, &lt;code&gt;modf&lt;/code&gt;, &lt;code&gt;powf&lt;/code&gt;, &lt;code&gt;powl&lt;/code&gt;, &lt;code&gt;sinf&lt;/code&gt;, &lt;code&gt;sinhf&lt;/code&gt;, &lt;code&gt;sinhl&lt;/code&gt;, &lt;code&gt;sinl&lt;/code&gt;, &lt;code&gt;sqrtf&lt;/code&gt;, &lt;code&gt;sqrtl&lt;/code&gt;, &lt;code&gt;tanf&lt;/code&gt;, &lt;code&gt;tanhf&lt;/code&gt;, &lt;code&gt;tanhl&lt;/code&gt; and &lt;code&gt;tanl&lt;/code&gt; that are recognized in any mode since ISO C90 reserves these names for the purpose to which ISO C99 puts them. All these functions have corresponding versions prefixed with &lt;code&gt;__builtin_&lt;/code&gt;.</source>
          <target state="translated">也有内置的ISO C99功能的版本 &lt;code&gt;acosf&lt;/code&gt; ， &lt;code&gt;acosl&lt;/code&gt; ， &lt;code&gt;asinf&lt;/code&gt; ， &lt;code&gt;asinl&lt;/code&gt; ， &lt;code&gt;atan2f&lt;/code&gt; ， &lt;code&gt;atan2l&lt;/code&gt; ， &lt;code&gt;atanf&lt;/code&gt; ， &lt;code&gt;atanl&lt;/code&gt; ， &lt;code&gt;ceilf&lt;/code&gt; ， &lt;code&gt;ceill&lt;/code&gt; ， &lt;code&gt;cosf&lt;/code&gt; ， &lt;code&gt;coshf&lt;/code&gt; ， &lt;code&gt;coshl&lt;/code&gt; ， &lt;code&gt;cosl&lt;/code&gt; ， &lt;code&gt;expf&lt;/code&gt; ， &lt;code&gt;expl&lt;/code&gt; ， &lt;code&gt;fabsf&lt;/code&gt; ， &lt;code&gt;fabsl&lt;/code&gt; ， &lt;code&gt;floorf&lt;/code&gt; ， &lt;code&gt;floorl&lt;/code&gt; ， &lt;code&gt;fmodf&lt;/code&gt; ， &lt;code&gt;fmodl&lt;/code&gt; ， &lt;code&gt;frexpf&lt;/code&gt; ， &lt;code&gt;frexpl&lt;/code&gt; ， &lt;code&gt;ldexpf&lt;/code&gt; ， &lt;code&gt;ldexpl&lt;/code&gt; ， &lt;code&gt;log10f&lt;/code&gt; ， &lt;code&gt;log10l&lt;/code&gt; ， &lt;code&gt;logf&lt;/code&gt; ， &lt;code&gt;logl&lt;/code&gt; ， &lt;code&gt;modfl&lt;/code&gt; ， &lt;code&gt;modf&lt;/code&gt; ， &lt;code&gt;powf&lt;/code&gt; ， &lt;code&gt;powl&lt;/code&gt; ， &lt;code&gt;sinf&lt;/code&gt; ， &lt;code&gt;sinhf&lt;/code&gt; ， &lt;code&gt;sinhl&lt;/code&gt; ， &lt;code&gt;sinl&lt;/code&gt; ， &lt;code&gt;sqrtf&lt;/code&gt; ， &lt;code&gt;sqrtl&lt;/code&gt; ， &lt;code&gt;tanf&lt;/code&gt; ， &lt;code&gt;tanhf&lt;/code&gt; ， &lt;code&gt;tanhl&lt;/code&gt; 和 &lt;code&gt;tanl&lt;/code&gt; 在任何模式下都可以识别，因为ISO C90保留这些名称是ISO C99放置它们的目的。所有这些功能都有对应的版本，并带有前缀 &lt;code&gt;__builtin_&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e32bac703972f0098c171900bd4cc85df014dde5" translate="yes" xml:space="preserve">
          <source>There are also checking built-in functions for formatted output functions.</source>
          <target state="translated">还有检查内置函数的格式化输出函数。</target>
        </trans-unit>
        <trans-unit id="4f8ad06fe6014524cc57bfacf331d94eea076d2f" translate="yes" xml:space="preserve">
          <source>There are built-in functions added for many common string operation functions, e.g., for &lt;code&gt;memcpy&lt;/code&gt;&lt;code&gt;__builtin___memcpy_chk&lt;/code&gt; built-in is provided. This built-in has an additional last argument, which is the number of bytes remaining in the object the &lt;var&gt;dest&lt;/var&gt; argument points to or &lt;code&gt;(size_t) -1&lt;/code&gt; if the size is not known.</source>
          <target state="translated">为许多常见的字符串操作函数添加了内置函数，例如，为 &lt;code&gt;memcpy&lt;/code&gt; 提供了 &lt;code&gt;__builtin___memcpy_chk&lt;/code&gt; 内置函数。此内置函数有一个附加的last参数，该参数是 &lt;var&gt;dest&lt;/var&gt; 参数指向的对象中剩余的字节数，如果不知道大小，则为 &lt;code&gt;(size_t) -1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e8ecb3f393a336df7fd790409c78fca65366bb71" translate="yes" xml:space="preserve">
          <source>There are four levels of warning supported by GCC. The default is</source>
          <target state="translated">GCC支持的警告有四个级别。默认值是</target>
        </trans-unit>
        <trans-unit id="c5c6335a792caea07ef43ebcfd0dbedc3bba84b4" translate="yes" xml:space="preserve">
          <source>There are four supported &lt;var&gt;visibility_type&lt;/var&gt; values: default, hidden, protected or internal visibility.</source>
          <target state="translated">支持四个 &lt;var&gt;visibility_type&lt;/var&gt; 值：默认，隐藏，受保护或内部可见性。</target>
        </trans-unit>
        <trans-unit id="ce8ba713c06a7d9c57fd70b516918aacdd01bbce" translate="yes" xml:space="preserve">
          <source>There are many more AVR-specific built-in functions that are used to implement the ISO/IEC TR 18037 &amp;ldquo;Embedded C&amp;rdquo; fixed-point functions of section 7.18a.6. You don&amp;rsquo;t need to use these built-ins directly. Instead, use the declarations as supplied by the &lt;code&gt;stdfix.h&lt;/code&gt; header with GNU-C99:</source>
          <target state="translated">还有许多其他特定于AVR的内置函数，这些函数用于实现第7.18a.6节的ISO / IEC TR 18037&amp;ldquo;嵌入式C&amp;rdquo;定点函数。您不需要直接使用这些内置函数。而是将 &lt;code&gt;stdfix.h&lt;/code&gt; 标头提供的声明与GNU-C99一起使用：</target>
        </trans-unit>
        <trans-unit id="82e7d52ba0a431ff758889d5327a13ddffa9df26" translate="yes" xml:space="preserve">
          <source>There are many other possibilities, limited only by your imagination, good sense, and the constraints of your build system.</source>
          <target state="translated">还有很多其他的可能性,只受限于你的想象力、良好的感觉和你的构建系统的限制。</target>
        </trans-unit>
        <trans-unit id="15ef48c0fb35d807a55378bf489805cb806add15" translate="yes" xml:space="preserve">
          <source>There are other differences between these two methods. Space allocated with &lt;code&gt;alloca&lt;/code&gt; exists until the containing &lt;em&gt;function&lt;/em&gt; returns. The space for a variable-length array is deallocated as soon as the array name&amp;rsquo;s scope ends, unless you also use &lt;code&gt;alloca&lt;/code&gt; in this scope.</source>
          <target state="translated">这两种方法之间还有其他差异。用 &lt;code&gt;alloca&lt;/code&gt; 分配的空间一直存在，直到包含&lt;em&gt;函数&lt;/em&gt;返回。数组名称的作用域结束时，将立即释放可变长度数组的空间，除非您也在该作用域中使用 &lt;code&gt;alloca&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ec4c204c6335b8fb2d87ba86456a428609cad26b" translate="yes" xml:space="preserve">
          <source>There are several caveats to using the new exception mechanism:</source>
          <target state="translated">使用新的异常机制有几个注意事项。</target>
        </trans-unit>
        <trans-unit id="c35ba4e6fe38d832f24909aadf0cb677e0066a30" translate="yes" xml:space="preserve">
          <source>There are several constructs in C++ that require space in the object file but are not clearly tied to a single translation unit. We say that these constructs have &amp;ldquo;vague linkage&amp;rdquo;. Typically such constructs are emitted wherever they are needed, though sometimes we can be more clever.</source>
          <target state="translated">C ++中有几种构造需要在目标文件中留有空间，但并没有明确地绑定到单个翻译单元。我们说这些构造具有&amp;ldquo;模糊的联系&amp;rdquo;。通常，此类构造会在需要的任何地方发出，尽管有时我们会更聪明。</target>
        </trans-unit>
        <trans-unit id="973e35674df499ab71700555edbe1a93e1641ce5" translate="yes" xml:space="preserve">
          <source>There are several noteworthy incompatibilities between GNU C and K&amp;amp;R (non-ISO) versions of C.</source>
          <target state="translated">GNU C和K＆R（非ISO）版本的C之间存在一些值得注意的不兼容性。</target>
        </trans-unit>
        <trans-unit id="0f04da83ffcbe77658a4a2fadeea31bbf52a4d35" translate="yes" xml:space="preserve">
          <source>There are several situations in which an application should use the shared</source>
          <target state="translated">有几种情况下,应用程序应该使用共享的</target>
        </trans-unit>
        <trans-unit id="7959f13cb983e884f2106a8d8e6aa988bd66a9f9" translate="yes" xml:space="preserve">
          <source>There are some arguments for making bit-fields unsigned by default on all machines. If, for example, this becomes a universal de facto standard, it would make sense for GCC to go along with it. This is something to be considered in the future.</source>
          <target state="translated">在所有机器上默认将位字段设为无符号是有一定道理的。例如,如果这成为一个普遍的事实上的标准,那么GCC就有理由遵循它。这是未来要考虑的问题。</target>
        </trans-unit>
        <trans-unit id="451c9c37af0f9094bf98f147452ec7b2c1e8a8be" translate="yes" xml:space="preserve">
          <source>There are some code generation flags preserved by GCC when generating bytecodes, as they need to be used during the final link. Currently, the following options and their settings are taken from the first object file that explicitly specifies them:</source>
          <target state="translated">在生成字节码时,GCC保留了一些代码生成标志,因为在最后的链接过程中需要用到这些标志。目前,以下选项及其设置是从第一个明确指定它们的对象文件中提取的。</target>
        </trans-unit>
        <trans-unit id="d537bfaa9f6c3001fc1a88f5b799ca08bd61a582" translate="yes" xml:space="preserve">
          <source>There are some constraints on how this can be used&amp;mdash;</source>
          <target state="translated">在如何使用它方面存在一些限制-</target>
        </trans-unit>
        <trans-unit id="136389e963628b14cbedd792ceed996572d52240" translate="yes" xml:space="preserve">
          <source>There are some problems with the semantics of attributes in C++. For example, there are no manglings for attributes, although they may affect code generation, so problems may arise when attributed types are used in conjunction with templates or overloading. Similarly, &lt;code&gt;typeid&lt;/code&gt; does not distinguish between types with different attributes. Support for attributes in C++ may be restricted in future to attributes on declarations only, but not on nested declarators.</source>
          <target state="translated">C ++中的属性语义存在一些问题。例如，尽管属性可能会影响代码生成，但没有进行任何操作，因此当将属性类型与模板或重载一起使用时，可能会出现问题。同样， &lt;code&gt;typeid&lt;/code&gt; 不能区分具有不同属性的类型。C ++中对属性的支持将来可能会仅限于声明中的属性，而不是嵌套声明符中的属性。</target>
        </trans-unit>
        <trans-unit id="f0a43a1a2abc532264a4772bfd3acfd532a1ab60" translate="yes" xml:space="preserve">
          <source>There are two ways of writing the argument to &lt;code&gt;typeof&lt;/code&gt;: with an expression or with a type. Here is an example with an expression:</source>
          <target state="translated">有两种方法可以将参数写入 &lt;code&gt;typeof&lt;/code&gt; ：使用表达式或类型。这是带有表达式的示例：</target>
        </trans-unit>
        <trans-unit id="bc25dda9b9f38426b4a5c6b4195fea59e37ab096" translate="yes" xml:space="preserve">
          <source>There is a new runtime function &lt;code&gt;class_ivar_set_gcinvisible()&lt;/code&gt; which can be used to declare a so-called &lt;em&gt;weak pointer&lt;/em&gt; reference. Such a pointer is basically hidden for the garbage collector; this can be useful in certain situations, especially when you want to keep track of the allocated objects, yet allow them to be collected. This kind of pointers can only be members of objects, you cannot declare a global pointer as a weak reference. Every type which is a pointer type can be declared a weak pointer, including &lt;code&gt;id&lt;/code&gt;, &lt;code&gt;Class&lt;/code&gt; and &lt;code&gt;SEL&lt;/code&gt;.</source>
          <target state="translated">有一个新的运行时函数 &lt;code&gt;class_ivar_set_gcinvisible()&lt;/code&gt; ，可用于声明所谓的&lt;em&gt;弱指针&lt;/em&gt;引用。对于垃圾收集器来说，这样的指针基本上是隐藏的。这在某些情况下很有用，尤其是当您要跟踪分配的对象但仍允许收集它们时。这种指针只能是对象的成员，不能将全局指针声明为弱引用。每个属于指针类型的类型都可以声明为弱指针，包括 &lt;code&gt;id&lt;/code&gt; ， &lt;code&gt;Class&lt;/code&gt; 和 &lt;code&gt;SEL&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6782eab9d50f7c071e99f8fc866abd4eb5cd6fa7" translate="yes" xml:space="preserve">
          <source>There is a proposed representation for view numbers that is not backward compatible with the location list format introduced in DWARF 5, that can be enabled with</source>
          <target state="translated">对于视图编号,有一个建议的表示方法,它与DWARF 5中引入的位置列表格式不向后兼容,可以通过以下方式启用</target>
        </trans-unit>
        <trans-unit id="923e1f4510dc236d985b28a823797fd535b1836b" translate="yes" xml:space="preserve">
          <source>There is no</source>
          <target state="translated">没有</target>
        </trans-unit>
        <trans-unit id="29b7356a3e71c6ac7b87a32d1d5d861dca74d15e" translate="yes" xml:space="preserve">
          <source>There is no formal written standard for Objective-C or Objective-C++. The authoritative manual on traditional Objective-C (1.0) is &amp;ldquo;Object-Oriented Programming and the Objective-C Language&amp;rdquo;: &lt;a href=&quot;http://www.gnustep.org/resources/documentation/ObjectivCBook.pdf&quot;&gt;http://www.gnustep.org/resources/documentation/ObjectivCBook.pdf&lt;/a&gt; is the original NeXTstep document.</source>
          <target state="translated">没有针对Objective-C或Objective-C ++的正式书面标准。传统的Objective-C（1.0）的权威手册是&amp;ldquo;面向对象的编程和Objective-C语言&amp;rdquo;：&lt;a href=&quot;http://www.gnustep.org/resources/documentation/ObjectivCBook.pdf&quot;&gt;http&lt;/a&gt; : //www.gnustep.org/resources/documentation/ObjectivCBook.pdf是原始的NeXTstep文档。</target>
        </trans-unit>
        <trans-unit id="533538e5f5aef48cf028f3ce488b08d6002276fb" translate="yes" xml:space="preserve">
          <source>There is no guarantee (in either the C or the C++ standard language definitions) that the increments will be evaluated in any particular order. Either increment might happen first. &lt;code&gt;func&lt;/code&gt; might get the arguments &amp;lsquo;</source>
          <target state="translated">（不保证使用C或C ++标准语言定义）增量将以任何特定顺序求值。两种增量都可能首先发生。 &lt;code&gt;func&lt;/code&gt; 可能会获取参数'</target>
        </trans-unit>
        <trans-unit id="734d8f3426c5c4d551e49ff2012c542f74ef1c08" translate="yes" xml:space="preserve">
          <source>There is no guarantee any transaction ever succeeds, so there always needs to be a valid fallback path.</source>
          <target state="translated">没有任何交易成功的保证,所以总是需要一个有效的后备路径。</target>
        </trans-unit>
        <trans-unit id="df09188c09c71974483614543b07ff3dea71c626" translate="yes" xml:space="preserve">
          <source>There is no support for nesting dialect alternatives.</source>
          <target state="translated">不支持嵌套方言替代方案。</target>
        </trans-unit>
        <trans-unit id="7415b415266f5ddf918da08e3399f543c97fb7d5" translate="yes" xml:space="preserve">
          <source>There is no way to split up the contents of a single header file into multiple implementation files.</source>
          <target state="translated">没有办法将一个头文件的内容分割成多个执行文件。</target>
        </trans-unit>
        <trans-unit id="b35fa3005d504f47c5b76912e05a2d94970ddd97" translate="yes" xml:space="preserve">
          <source>There is no way within the template to determine which alternative was chosen. However you may be able to wrap your &lt;code&gt;asm&lt;/code&gt; statements with builtins such as &lt;code&gt;__builtin_constant_p&lt;/code&gt; to achieve the desired results.</source>
          <target state="translated">模板内无法确定选择了哪个替代方案。但是，您也许可以使用诸如 &lt;code&gt;__builtin_constant_p&lt;/code&gt; 之类的内置函数包装 &lt;code&gt;asm&lt;/code&gt; 语句，以获得所需的结果。</target>
        </trans-unit>
        <trans-unit id="ae8b54db3c2d81811451aec9ad4c249cf9c17c8b" translate="yes" xml:space="preserve">
          <source>There is some overlap between the purposes of attributes and pragmas (see &lt;a href=&quot;pragmas#Pragmas&quot;&gt;Pragmas Accepted by GCC&lt;/a&gt;). It has been found convenient to use &lt;code&gt;__attribute__&lt;/code&gt; to achieve a natural attachment of attributes to their corresponding declarations, whereas &lt;code&gt;#pragma&lt;/code&gt; is of use for compatibility with other compilers or constructs that do not naturally form part of the grammar.</source>
          <target state="translated">属性和杂&lt;a href=&quot;pragmas#Pragmas&quot;&gt;用语&lt;/a&gt;的用途之间存在一些重叠（请参阅GCC接受的杂语）。已经发现使用 &lt;code&gt;__attribute__&lt;/code&gt; 可以方便地将属性自然地附加到其相应的声明中，而 &lt;code&gt;#pragma&lt;/code&gt; 用于与其他自然不构成语法一部分的编译器或构造兼容。</target>
        </trans-unit>
        <trans-unit id="07be20761a89905e90146c4650de03345401fe54" translate="yes" xml:space="preserve">
          <source>There may be pitfalls when you use &lt;code&gt;long long&lt;/code&gt; types for function arguments without function prototypes. If a function expects type &lt;code&gt;int&lt;/code&gt; for its argument, and you pass a value of type &lt;code&gt;long long int&lt;/code&gt;, confusion results because the caller and the subroutine disagree about the number of bytes for the argument. Likewise, if the function expects &lt;code&gt;long long int&lt;/code&gt; and you pass &lt;code&gt;int&lt;/code&gt;. The best way to avoid such problems is to use prototypes.</source>
          <target state="translated">当对函数参数使用 &lt;code&gt;long long&lt;/code&gt; 类型而没有函数原型时，可能会有陷阱。如果函数的参数期望类型为 &lt;code&gt;int&lt;/code&gt; ，并且您传递的类型为 &lt;code&gt;long long int&lt;/code&gt; ，则由于调用者和子例程对参数的字节数不同而导致混淆。同样，如果函数期望 &lt;code&gt;long long int&lt;/code&gt; 并且您传递 &lt;code&gt;int&lt;/code&gt; 。避免此类问题的最佳方法是使用原型。</target>
        </trans-unit>
        <trans-unit id="4d9628a707838f509cf0a37ebb92916da132e1d6" translate="yes" xml:space="preserve">
          <source>Therefore, the G++ driver automatically adds</source>
          <target state="translated">因此,G++驱动会自动添加</target>
        </trans-unit>
        <trans-unit id="47997e2980ed03d4553af1541dc131cfa6cb91bc" translate="yes" xml:space="preserve">
          <source>Therefore, the expression</source>
          <target state="translated">因此,该表达式</target>
        </trans-unit>
        <trans-unit id="6ea5dc6096c9bd173073ecde828a55eabd5d76e4" translate="yes" xml:space="preserve">
          <source>These</source>
          <target state="translated">These</target>
        </trans-unit>
        <trans-unit id="322fe3b4715f9524d383adeb084e8533651edeb7" translate="yes" xml:space="preserve">
          <source>These &amp;lsquo;</source>
          <target state="translated">这些&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="cdc6fb4722bc714d5fae1673f7398b196f782701" translate="yes" xml:space="preserve">
          <source>These additional &amp;lsquo;</source>
          <target state="translated">这些额外的&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="2dea8e42e0ac78d81c1030a34ffa5859fb43e5e8" translate="yes" xml:space="preserve">
          <source>These additional options are available for Microsoft Windows targets:</source>
          <target state="translated">这些附加选项可用于Microsoft Windows目标。</target>
        </trans-unit>
        <trans-unit id="429200a04514f92caf3b4499a491ca222d5caed0" translate="yes" xml:space="preserve">
          <source>These additional options are available on System V Release 4 for compatibility with other compilers on those systems:</source>
          <target state="translated">这些额外的选项在System V Release 4上可用,以便与这些系统上的其他编译器兼容。</target>
        </trans-unit>
        <trans-unit id="aee4beda520b02d216d51ad833fd44f1904ba2f8" translate="yes" xml:space="preserve">
          <source>These are 16-bit address spaces locating data in section &lt;code&gt;.progmem&lt;var&gt;N&lt;/var&gt;.data&lt;/code&gt; where &lt;var&gt;N&lt;/var&gt; refers to address space &lt;code&gt;__flash&lt;var&gt;N&lt;/var&gt;&lt;/code&gt;. The compiler sets the &lt;code&gt;RAMPZ&lt;/code&gt; segment register appropriately before reading data by means of the &lt;code&gt;ELPM&lt;/code&gt; instruction.</source>
          <target state="translated">这些是16位的地址空间在部分定位数据 &lt;code&gt;.progmem&lt;var&gt;N&lt;/var&gt;.data&lt;/code&gt; 其中 &lt;var&gt;N&lt;/var&gt; 指地址空间 &lt;code&gt;__flash&lt;var&gt;N&lt;/var&gt;&lt;/code&gt; 。在通过 &lt;code&gt;ELPM&lt;/code&gt; 指令读取数据之前，编译器会适当地设置 &lt;code&gt;RAMPZ&lt;/code&gt; 段寄存器。</target>
        </trans-unit>
        <trans-unit id="9bc1925e612ca94ca27a8264a7444be5df20595d" translate="yes" xml:space="preserve">
          <source>These are aliases for the corresponding</source>
          <target state="translated">这些都是相应产品的别称。</target>
        </trans-unit>
        <trans-unit id="779c6f17661e07ac4152f7dc676778ae7628f8f4" translate="yes" xml:space="preserve">
          <source>These are listed under See &lt;a href=&quot;rs_002f6000-and-powerpc-options#RS_002f6000-and-PowerPC-Options&quot;&gt;RS/6000 and PowerPC Options&lt;/a&gt;.</source>
          <target state="translated">这些列在&amp;ldquo;请参阅&lt;a href=&quot;rs_002f6000-and-powerpc-options#RS_002f6000-and-PowerPC-Options&quot;&gt;RS / 6000和PowerPC选项&amp;rdquo;下&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ae931926b0b87957b809699bfe98630faaab5aad" translate="yes" xml:space="preserve">
          <source>These are listed under See &lt;a href=&quot;s_002f390-and-zseries-options#S_002f390-and-zSeries-Options&quot;&gt;S/390 and zSeries Options&lt;/a&gt;.</source>
          <target state="translated">这些列在&amp;ldquo;请参阅&lt;a href=&quot;s_002f390-and-zseries-options#S_002f390-and-zSeries-Options&quot;&gt;S / 390和zSeries选项&amp;rdquo;下&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="40acc5623309fbea5623f2aba009e341f97fe7cb" translate="yes" xml:space="preserve">
          <source>These are the &amp;lsquo;</source>
          <target state="translated">这些是 '</target>
        </trans-unit>
        <trans-unit id="25a9625ab38cfd983e37ec2df20ad8c1cd341393" translate="yes" xml:space="preserve">
          <source>These are the options defined for the Altera Nios II processor.</source>
          <target state="translated">这些是为Altera Nios II处理器定义的选项。</target>
        </trans-unit>
        <trans-unit id="ddfdc15ea502fdc771fd53ee7ee413d91e5a491a" translate="yes" xml:space="preserve">
          <source>These are the supported qualifiers:</source>
          <target state="translated">这些是支持的限定词。</target>
        </trans-unit>
        <trans-unit id="3f0f74a8692c7935b66e165ba67cb1a501ff0206" translate="yes" xml:space="preserve">
          <source>These attributes are the same as the MSP430 function attributes of the same name (see &lt;a href=&quot;msp430-function-attributes#MSP430-Function-Attributes&quot;&gt;MSP430 Function Attributes&lt;/a&gt;).</source>
          <target state="translated">这些属性与具有相同名称的MSP430功能属性相同（请参阅&lt;a href=&quot;msp430-function-attributes#MSP430-Function-Attributes&quot;&gt;MSP430功能属性&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="ea04fd9aefe63e6f009323195856f23e96723b58" translate="yes" xml:space="preserve">
          <source>These attributes are the same as the MSP430 function attributes of the same name (see &lt;a href=&quot;msp430-function-attributes#MSP430-Function-Attributes&quot;&gt;MSP430 Function Attributes&lt;/a&gt;). These attributes can be applied to both functions and variables.</source>
          <target state="translated">这些属性与同名的MSP430功能属性相同（请参见&lt;a href=&quot;msp430-function-attributes#MSP430-Function-Attributes&quot;&gt;MSP430功能属性&lt;/a&gt;）。这些属性可以同时应用于函数和变量。</target>
        </trans-unit>
        <trans-unit id="bc9f0c12140351e3fedd51dae4c1164e0be835e5" translate="yes" xml:space="preserve">
          <source>These attributes indicate that the specified function is an interrupt handler. The compiler generates function entry and exit sequences suitable for use in an interrupt handler when this attribute is present.</source>
          <target state="translated">这些属性表明指定的函数是一个中断处理程序。当该属性存在时,编译器会生成适合在中断处理程序中使用的函数进入和退出序列。</target>
        </trans-unit>
        <trans-unit id="90cae17a8377f793b8674b8db0decc44a0b2b0db" translate="yes" xml:space="preserve">
          <source>These attributes indicate that the specified function is an interrupt handler. Use the &lt;code&gt;fast_interrupt&lt;/code&gt; attribute to indicate handlers used in low-latency interrupt mode, and &lt;code&gt;interrupt_handler&lt;/code&gt; for interrupts that do not use low-latency handlers. In both cases, GCC emits appropriate prologue code and generates a return from the handler using &lt;code&gt;rtid&lt;/code&gt; instead of &lt;code&gt;rtsd&lt;/code&gt;.</source>
          <target state="translated">这些属性指示指定的函数是中断处理程序。使用 &lt;code&gt;fast_interrupt&lt;/code&gt; 属性来指示低延迟中断模式，以及用于处理 &lt;code&gt;interrupt_handler&lt;/code&gt; 对于不使用低延迟处理程序中断。在这两种情况下，GCC都会发出适当的序言代码，并使用 &lt;code&gt;rtid&lt;/code&gt; 而不是 &lt;code&gt;rtsd&lt;/code&gt; 从处理程序生成返回。</target>
        </trans-unit>
        <trans-unit id="0f83b1fb8a50c976a446dd169ccf0caf9284a311" translate="yes" xml:space="preserve">
          <source>These attributes override the default chosen by the</source>
          <target state="translated">这些属性覆盖了由</target>
        </trans-unit>
        <trans-unit id="af47925da5d7dad5e220bfdf28a73cd1e09ade04" translate="yes" xml:space="preserve">
          <source>These attributes specify how a particular function is called on MIPS. The attributes override the</source>
          <target state="translated">这些属性指定了如何在MIPS上调用特定的函数。这些属性覆盖了</target>
        </trans-unit>
        <trans-unit id="c245dc24a2c3a655d76f63a05d461d62dfaa1098" translate="yes" xml:space="preserve">
          <source>These attributes specify how a particular function is called. These attributes override the</source>
          <target state="translated">这些属性指定了特定函数的调用方式。这些属性覆盖了</target>
        </trans-unit>
        <trans-unit id="3aa2c83f10183032d2c290e0fbfc5503038ef4f2" translate="yes" xml:space="preserve">
          <source>These built-in functions are available for calling kernel helpers, and they are available depending on the kernel version selected as the CPU.</source>
          <target state="translated">这些内置函数可以用于调用内核助手,它们的可用性取决于所选择的CPU的内核版本。</target>
        </trans-unit>
        <trans-unit id="1d2db2e0a6cd3c160ce892077b566038f69a5d12" translate="yes" xml:space="preserve">
          <source>These built-in functions are available for the AArch64 family of processors.</source>
          <target state="translated">这些内置功能适用于AArch64系列处理器。</target>
        </trans-unit>
        <trans-unit id="99ee134b7e3302b89897afcdd306492cac3af896" translate="yes" xml:space="preserve">
          <source>These built-in functions are available for the ARM family of processors when the</source>
          <target state="translated">这些内置功能在以下情况下可供ARM系列处理器使用</target>
        </trans-unit>
        <trans-unit id="a2c021905865fa6d163412cd97d22f339e716b63" translate="yes" xml:space="preserve">
          <source>These built-in functions are available for the ARM family of processors with floating-point unit.</source>
          <target state="translated">这些内置功能适用于具有浮点单元的ARM系列处理器。</target>
        </trans-unit>
        <trans-unit id="48306035fd811f8d35a44f11213546ba486a0570" translate="yes" xml:space="preserve">
          <source>These built-in functions are available for the Alpha family of processors, depending on the command-line switches used.</source>
          <target state="translated">根据所使用的命令行开关,这些内置功能在Alpha系列处理器中是可用的。</target>
        </trans-unit>
        <trans-unit id="7b3ba21ab5439a452d301344eaf50af645d462ac" translate="yes" xml:space="preserve">
          <source>These built-in functions are available for the Altera Nios II family of processors.</source>
          <target state="translated">这些内置功能适用于Altera Nios II系列处理器。</target>
        </trans-unit>
        <trans-unit id="89f6765d03c89956e564760cefe25b8258f2acc4" translate="yes" xml:space="preserve">
          <source>These built-in functions are available for the NDS32 target:</source>
          <target state="translated">这些内置功能可用于NDS32目标。</target>
        </trans-unit>
        <trans-unit id="2fccae182b2f224cc802c582d293665235932f6e" translate="yes" xml:space="preserve">
          <source>These built-in functions are available for the x86-32 and x86-64 family of computers, depending on the command-line switches used.</source>
          <target state="translated">这些内置功能可用于x86-32和x86-64系列的计算机,取决于所使用的命令行开关。</target>
        </trans-unit>
        <trans-unit id="74fa1603a77cd22b8b03844382316cb7fce3f487" translate="yes" xml:space="preserve">
          <source>These built-in functions are similar to &lt;code&gt;__builtin_add_overflow&lt;/code&gt;, &lt;code&gt;__builtin_sub_overflow&lt;/code&gt;, or &lt;code&gt;__builtin_mul_overflow&lt;/code&gt;, except that they don&amp;rsquo;t store the result of the arithmetic operation anywhere and the last argument is not a pointer, but some expression with integral type other than enumerated or boolean type.</source>
          <target state="translated">这些内置函数类似于 &lt;code&gt;__builtin_add_overflow&lt;/code&gt; ， &lt;code&gt;__builtin_sub_overflow&lt;/code&gt; 或 &lt;code&gt;__builtin_mul_overflow&lt;/code&gt; ，不同之处在于它们不将算术运算的结果存储在任何地方，并且最后一个参数不是指针，而是某些具有枚举或布尔类型以外的整数类型的表达式。</target>
        </trans-unit>
        <trans-unit id="49cc0a5435c96c360dc8a007e08ab18d83b226a2" translate="yes" xml:space="preserve">
          <source>These built-in functions are similar to the add overflow checking built-in functions above, except they perform multiplication, instead of addition.</source>
          <target state="translated">这些内置函数与上面的加法溢出检查内置函数类似,只是它们执行的是乘法,而不是加法。</target>
        </trans-unit>
        <trans-unit id="60566210b0678cb1c3591a4a16d4062b4b5565ab" translate="yes" xml:space="preserve">
          <source>These built-in functions are similar to the add overflow checking built-in functions above, except they perform subtraction, subtract the second argument from the first one, instead of addition.</source>
          <target state="translated">这些内置函数与上面的加法溢出检查内置函数类似,只是它们执行的是减法,从第一个参数中减去第二个参数,而不是加法。</target>
        </trans-unit>
        <trans-unit id="f2854f4ac5cfaad00730f8aa21e163c5b047dff2" translate="yes" xml:space="preserve">
          <source>These built-in functions map to the respective machine instruction, i.e. &lt;code&gt;nop&lt;/code&gt;, &lt;code&gt;sei&lt;/code&gt;, &lt;code&gt;cli&lt;/code&gt;, &lt;code&gt;sleep&lt;/code&gt;, &lt;code&gt;wdr&lt;/code&gt;, &lt;code&gt;swap&lt;/code&gt;, &lt;code&gt;fmul&lt;/code&gt;, &lt;code&gt;fmuls&lt;/code&gt; resp. &lt;code&gt;fmulsu&lt;/code&gt;. The three &lt;code&gt;fmul*&lt;/code&gt; built-ins are implemented as library call if no hardware multiplier is available.</source>
          <target state="translated">这些内置函数映射到相应的机器指令，即 &lt;code&gt;nop&lt;/code&gt; ， &lt;code&gt;sei&lt;/code&gt; ， &lt;code&gt;cli&lt;/code&gt; ， &lt;code&gt;sleep&lt;/code&gt; ， &lt;code&gt;wdr&lt;/code&gt; ， &lt;code&gt;swap&lt;/code&gt; ， &lt;code&gt;fmul&lt;/code&gt; 和 &lt;code&gt;fmuls&lt;/code&gt; resp。 &lt;code&gt;fmulsu&lt;/code&gt; 。如果没有可用的硬件乘法器，则将三个 &lt;code&gt;fmul*&lt;/code&gt; 内置插件实现为库调用。</target>
        </trans-unit>
        <trans-unit id="b498367f60152015d5067b4b4501b71daee8b167" translate="yes" xml:space="preserve">
          <source>These built-in functions perform an atomic compare and swap. That is, if the current value of &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt; is &lt;var&gt;oldval&lt;/var&gt;, then write &lt;var&gt;newval&lt;/var&gt; into &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt;.</source>
          <target state="translated">这些内置函数执行原子比较和交换。也就是说，如果当前值 &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt; 是 &lt;var&gt;oldval&lt;/var&gt; ，然后写 &lt;var&gt;newval&lt;/var&gt; 成 &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="457d48795ac8a304362adc0940095ddd5561f409" translate="yes" xml:space="preserve">
          <source>These built-in functions perform the operation suggested by the name, and return the new value. That is, operations on integer operands have the following semantics. Operations on pointer operands are performed as if the operand&amp;rsquo;s type were &lt;code&gt;uintptr_t&lt;/code&gt;.</source>
          <target state="translated">这些内置函数执行名称建议的操作，并返回新值。即，对整数操作数的操作具有以下语义。对指针操作数的操作就像操作数的类型是 &lt;code&gt;uintptr_t&lt;/code&gt; 一样执行。</target>
        </trans-unit>
        <trans-unit id="c4af2a3302ed8abb6fe6e394796ceea4bd21df1d" translate="yes" xml:space="preserve">
          <source>These built-in functions perform the operation suggested by the name, and return the result of the operation. Operations on pointer arguments are performed as if the operands were of the &lt;code&gt;uintptr_t&lt;/code&gt; type. That is, they are not scaled by the size of the type to which the pointer points.</source>
          <target state="translated">这些内置函数执行名称建议的操作，并返回操作结果。对指针参数的操作就像操作数是 &lt;code&gt;uintptr_t&lt;/code&gt; 类型一样执行。也就是说，它们不会按指针指向的类型的大小进行缩放。</target>
        </trans-unit>
        <trans-unit id="79ddce6ba857523eabbfd2cdfa6462c8733df6a0" translate="yes" xml:space="preserve">
          <source>These built-in functions perform the operation suggested by the name, and return the value that had previously been in &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt;. Operations on pointer arguments are performed as if the operands were of the &lt;code&gt;uintptr_t&lt;/code&gt; type. That is, they are not scaled by the size of the type to which the pointer points.</source>
          <target state="translated">这些内置函数执行名称建议的操作，并返回以前在 &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt; 中的值。对指针参数的操作就像操作数是 &lt;code&gt;uintptr_t&lt;/code&gt; 类型一样执行。也就是说，它们不会按指针指向的类型的大小进行缩放。</target>
        </trans-unit>
        <trans-unit id="9d9da03d00f1fd8e4ece7f58ac8080d895ff5310" translate="yes" xml:space="preserve">
          <source>These built-in functions perform the operation suggested by the name, and returns the value that had previously been in memory. That is, operations on integer operands have the following semantics. Operations on pointer arguments are performed as if the operands were of the &lt;code&gt;uintptr_t&lt;/code&gt; type. That is, they are not scaled by the size of the type to which the pointer points.</source>
          <target state="translated">这些内置函数执行名称建议的操作，并返回以前在内存中的值。即，对整数操作数的操作具有以下语义。对指针参数的操作就像操作数是 &lt;code&gt;uintptr_t&lt;/code&gt; 类型一样执行。也就是说，它们不会按指针指向的类型的大小进行缩放。</target>
        </trans-unit>
        <trans-unit id="55de8240dbd3fc7547da89964b220023f7b63ac6" translate="yes" xml:space="preserve">
          <source>These built-in functions promote the first two operands into infinite precision signed type and perform addition on those promoted operands. The result is then cast to the type the third pointer argument points to and stored there. If the stored result is equal to the infinite precision result, the built-in functions return &lt;code&gt;false&lt;/code&gt;, otherwise they return &lt;code&gt;true&lt;/code&gt;. As the addition is performed in infinite signed precision, these built-in functions have fully defined behavior for all argument values.</source>
          <target state="translated">这些内置函数将前两个操作数提升为无限精度带符号类型，并对这些提升的操作数执行加法运算。然后将结果强制转换为第三个指针参数指向的类型并存储在那里。如果存储的结果等于无限精度的结果，则内置函数返回 &lt;code&gt;false&lt;/code&gt; ，否则返回 &lt;code&gt;true&lt;/code&gt; 。由于加法运算以无穷大的符号精度执行，因此这些内置函数对所有参数值具有完全定义的行为。</target>
        </trans-unit>
        <trans-unit id="889254cac4522dec29d7418673ff86e35bc69fa4" translate="yes" xml:space="preserve">
          <source>These command-line options are defined for PRU target:</source>
          <target state="translated">这些命令行选项是为PRU目标定义的。</target>
        </trans-unit>
        <trans-unit id="272a12ae7cc5710c521265d94a65c2d1952b524a" translate="yes" xml:space="preserve">
          <source>These command-line options are defined for RISC-V targets:</source>
          <target state="translated">这些命令行选项是为RISC-V目标定义的。</target>
        </trans-unit>
        <trans-unit id="cde559b30a769153d7e8ca70dcc17ecf58e436b4" translate="yes" xml:space="preserve">
          <source>These command-line options are defined for RX targets:</source>
          <target state="translated">这些命令行选项是为RX目标定义的。</target>
        </trans-unit>
        <trans-unit id="51a802ea6adfbbd5a44e165efe9f9442f0fe2c45" translate="yes" xml:space="preserve">
          <source>These considerations mean that it is probably a bad idea to use statement expressions of this form in header files that are designed to work with C++. (Note that some versions of the GNU C Library contained header files using statement expressions that lead to precisely this bug.)</source>
          <target state="translated">这些考虑意味着,在设计为与C++一起工作的头文件中使用这种形式的语句表达式可能是个坏主意。(请注意,GNU C库的某些版本包含了使用语句表达式的头文件,这恰恰导致了这个错误。)</target>
        </trans-unit>
        <trans-unit id="8bb762532560d78d44fe7f3daaea45c8583b0854" translate="yes" xml:space="preserve">
          <source>These constraints are represented as multiple alternatives. An alternative can be described by a series of letters for each operand. The overall constraint for an operand is made from the letters for this operand from the first alternative, a comma, the letters for this operand from the second alternative, a comma, and so on until the last alternative. All operands for a single instruction must have the same number of alternatives.</source>
          <target state="translated">这些约束条件被表示为多个备选方案。一个备选方案可以用一系列字母来描述每个操作数。一个操作数的总体约束是由第一个备选方案中的这个操作数的字母、一个逗号、第二个备选方案中的这个操作数的字母、一个逗号组成的,以此类推,直到最后一个备选方案。一条指令的所有操作数必须有相同的备选数。</target>
        </trans-unit>
        <trans-unit id="38cef76099a34e5010638d4a8b6cdd6e8c967f30" translate="yes" xml:space="preserve">
          <source>These dumps are defined but always produce empty files.</source>
          <target state="translated">这些转储是被定义的,但总是产生空文件。</target>
        </trans-unit>
        <trans-unit id="dee9b2ccc9b3a342087894f7b0b9e01286328c92" translate="yes" xml:space="preserve">
          <source>These environment variables control the way that GCC uses localization information which allows GCC to work with different national conventions. GCC inspects the locale categories &lt;code&gt;LC_CTYPE&lt;/code&gt; and &lt;code&gt;LC_MESSAGES&lt;/code&gt; if it has been configured to do so. These locale categories can be set to any value supported by your installation. A typical value is &amp;lsquo;</source>
          <target state="translated">这些环境变量控制GCC使用本地化信息的方式，该信息使GCC可以与不同的国家公约一起工作。如果已配置，GCC会检查语言环境类别 &lt;code&gt;LC_CTYPE&lt;/code&gt; 和 &lt;code&gt;LC_MESSAGES&lt;/code&gt; 。这些语言环境类别可以设置为安装支持的任何值。典型值为</target>
        </trans-unit>
        <trans-unit id="a489f50971ce1280d886918f48a3bb50c7a159d8" translate="yes" xml:space="preserve">
          <source>These extensions are also available as built-in functions: see &lt;a href=&quot;x86-built_002din-functions#x86-Built_002din-Functions&quot;&gt;x86 Built-in Functions&lt;/a&gt;, for details of the functions enabled and disabled by these switches.</source>
          <target state="translated">这些扩展也可以作为内置功能使用：有关这些开关启用和禁用的功能的详细信息，请参见&lt;a href=&quot;x86-built_002din-functions#x86-Built_002din-Functions&quot;&gt;x86内置功能&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8d27c12c180a98e05723ed39f8b22c27ed9edb1c" translate="yes" xml:space="preserve">
          <source>These extensions are available in C and Objective-C. Most of them are also available in C++. See &lt;a href=&quot;c_002b_002b-extensions#C_002b_002b-Extensions&quot;&gt;Extensions to the C++ Language&lt;/a&gt;, for extensions that apply &lt;em&gt;only&lt;/em&gt; to C++.</source>
          <target state="translated">这些扩展在C和Objective-C中可用。它们中的大多数也可以在C ++中获得。请参阅&lt;a href=&quot;c_002b_002b-extensions#C_002b_002b-Extensions&quot;&gt;C ++语言&lt;/a&gt;扩展，以获取&lt;em&gt;仅&lt;/em&gt;适用于C ++的扩展。</target>
        </trans-unit>
        <trans-unit id="543b06dcdf13923e1595eba210fefb04ac8d69e6" translate="yes" xml:space="preserve">
          <source>These function attributes are available for H8/300 targets:</source>
          <target state="translated">这些功能属性可用于H8/300目标。</target>
        </trans-unit>
        <trans-unit id="bfd06787a8c3016d0f2f433589a9910af31152c9" translate="yes" xml:space="preserve">
          <source>These function attributes are supported by the AMD GCN back end:</source>
          <target state="translated">这些功能属性由AMD GCN后端支持。</target>
        </trans-unit>
        <trans-unit id="31d4d22755862f6885158e789fb6bd235507e320" translate="yes" xml:space="preserve">
          <source>These function attributes are supported by the ARC back end:</source>
          <target state="translated">这些功能属性由ARC后端支持。</target>
        </trans-unit>
        <trans-unit id="55c618a070b2ba6452534765be65dfbcbd06c924" translate="yes" xml:space="preserve">
          <source>These function attributes are supported by the AVR back end:</source>
          <target state="translated">这些功能属性由AVR后端支持。</target>
        </trans-unit>
        <trans-unit id="4000ac271516da07336a51da8c25e0b8f6d448c0" translate="yes" xml:space="preserve">
          <source>These function attributes are supported by the Blackfin back end:</source>
          <target state="translated">这些功能属性由Blackfin后端支持。</target>
        </trans-unit>
        <trans-unit id="4afa11f7ee30e42598bbee2d62763ae6434a6f20" translate="yes" xml:space="preserve">
          <source>These function attributes are supported by the C-SKY back end:</source>
          <target state="translated">C-SKY后端支持这些功能属性。</target>
        </trans-unit>
        <trans-unit id="0b39cd5a4dc8327b896c51c9d022f5933b3f9958" translate="yes" xml:space="preserve">
          <source>These function attributes are supported by the CR16 back end:</source>
          <target state="translated">这些功能属性由CR16后端支持。</target>
        </trans-unit>
        <trans-unit id="eec1909818ce8c44d18b66d9f611b39270c8c989" translate="yes" xml:space="preserve">
          <source>These function attributes are supported by the Epiphany back end:</source>
          <target state="translated">这些功能属性由Epiphany后端支持。</target>
        </trans-unit>
        <trans-unit id="ff8d3405ae11a67438cd3ed6cb92d4bcf36611d0" translate="yes" xml:space="preserve">
          <source>These function attributes are supported by the M32C back end:</source>
          <target state="translated">这些功能属性由M32C后端支持。</target>
        </trans-unit>
        <trans-unit id="d47de44c955eeba7615b17fd0bd7f27454a04ff3" translate="yes" xml:space="preserve">
          <source>These function attributes are supported by the M32R/D back end:</source>
          <target state="translated">这些功能属性由M32R/D后端支持。</target>
        </trans-unit>
        <trans-unit id="ed7b01cf6c9218a3fa99b80d586881bd94ea12ed" translate="yes" xml:space="preserve">
          <source>These function attributes are supported by the MCORE back end:</source>
          <target state="translated">这些功能属性由MCORE后端支持。</target>
        </trans-unit>
        <trans-unit id="226e80259699476cba4da72f29c0d2be0439d85d" translate="yes" xml:space="preserve">
          <source>These function attributes are supported by the MIPS back end:</source>
          <target state="translated">这些功能属性由MIPS后端支持。</target>
        </trans-unit>
        <trans-unit id="7edfb198d558bea136b268d07a4ee17096f4b111" translate="yes" xml:space="preserve">
          <source>These function attributes are supported by the MSP430 back end:</source>
          <target state="translated">MSP430后端支持这些功能属性。</target>
        </trans-unit>
        <trans-unit id="7afb37f2786a0500cde5b0e77a1405ec0aa689e9" translate="yes" xml:space="preserve">
          <source>These function attributes are supported by the MeP back end:</source>
          <target state="translated">MeP后端支持这些功能属性。</target>
        </trans-unit>
        <trans-unit id="823340689a226c514215ae7cf6199d5c7033ae04" translate="yes" xml:space="preserve">
          <source>These function attributes are supported by the NDS32 back end:</source>
          <target state="translated">NDS32后端支持这些函数属性。</target>
        </trans-unit>
        <trans-unit id="7264e105fd00f62eb30200660903a8276158683f" translate="yes" xml:space="preserve">
          <source>These function attributes are supported by the Nios II back end:</source>
          <target state="translated">这些功能属性由Nios II后端支持。</target>
        </trans-unit>
        <trans-unit id="d367738aef5894acaadafa553c801d1b43d3e9d3" translate="yes" xml:space="preserve">
          <source>These function attributes are supported by the Nvidia PTX back end:</source>
          <target state="translated">这些功能属性由Nvidia PTX后端支持。</target>
        </trans-unit>
        <trans-unit id="8128fd2ec01bae5154b0679102e4367fb3f53fc5" translate="yes" xml:space="preserve">
          <source>These function attributes are supported by the PowerPC back end:</source>
          <target state="translated">这些功能属性由PowerPC后端支持。</target>
        </trans-unit>
        <trans-unit id="923f5bd26a54897b08d5acdad9b09a52e975ce30" translate="yes" xml:space="preserve">
          <source>These function attributes are supported by the RISC-V back end:</source>
          <target state="translated">这些功能属性由RISC-V后端支持。</target>
        </trans-unit>
        <trans-unit id="47e5203aed5d0b18481b945b5507d949e4d7c31f" translate="yes" xml:space="preserve">
          <source>These function attributes are supported by the RL78 back end:</source>
          <target state="translated">RL78后端支持这些功能属性。</target>
        </trans-unit>
        <trans-unit id="8f4c53e48bbca37bc1541d4a60d57426dc8a00e7" translate="yes" xml:space="preserve">
          <source>These function attributes are supported by the RX back end:</source>
          <target state="translated">这些功能属性由RX后端支持。</target>
        </trans-unit>
        <trans-unit id="d7ce9850ed4dcd80e265a07962ae081b178c8abb" translate="yes" xml:space="preserve">
          <source>These function attributes are supported by the SPU back end:</source>
          <target state="translated">这些功能属性由SPU后端支持。</target>
        </trans-unit>
        <trans-unit id="c4ade06aab9acf44e5ce57399ee7881faa6de0a6" translate="yes" xml:space="preserve">
          <source>These function attributes are supported by the Visium back end:</source>
          <target state="translated">Visium后端支持这些功能属性。</target>
        </trans-unit>
        <trans-unit id="ae2ef0b2bdfca9b1c67e94cbe7badc64e01b063f" translate="yes" xml:space="preserve">
          <source>These function attributes are supported by the Xstormy16 back end:</source>
          <target state="translated">这些函数属性由Xstormy16后端支持。</target>
        </trans-unit>
        <trans-unit id="e7b7833e42af4f0fe80d613be09a87490ccd7b43" translate="yes" xml:space="preserve">
          <source>These function attributes are supported by the m68k back end:</source>
          <target state="translated">这些功能属性是m68k后端支持的。</target>
        </trans-unit>
        <trans-unit id="fe7ac1f444547a0c0a07d6dfab0c75fe5199553c" translate="yes" xml:space="preserve">
          <source>These function attributes are supported by the x86 back end:</source>
          <target state="translated">这些函数属性由x86后端支持。</target>
        </trans-unit>
        <trans-unit id="5189be0ccd445175d7b77e932fb4808ff6d615fa" translate="yes" xml:space="preserve">
          <source>These function attributes are supported for ARM targets:</source>
          <target state="translated">ARM目标支持这些功能属性。</target>
        </trans-unit>
        <trans-unit id="bbd6ef1a2308a92983d4f92536fdde005890291f" translate="yes" xml:space="preserve">
          <source>These function attributes are supported on IA-64 targets:</source>
          <target state="translated">IA-64目标上支持这些功能属性。</target>
        </trans-unit>
        <trans-unit id="f64b227810fa6c9b50983f03140d568f7d9fed74" translate="yes" xml:space="preserve">
          <source>These function attributes are supported on MicroBlaze targets:</source>
          <target state="translated">MicroBlaze目标上支持这些功能属性。</target>
        </trans-unit>
        <trans-unit id="9585f4effc5a2f8970b020be9771782ca105dbb1" translate="yes" xml:space="preserve">
          <source>These function attributes are supported on the S/390:</source>
          <target state="translated">S/390上支持这些功能属性。</target>
        </trans-unit>
        <trans-unit id="18888f95dfd62b9fe90e4d6af61fe2ecdcb6ad4f" translate="yes" xml:space="preserve">
          <source>These function attributes are supported on the SH family of processors:</source>
          <target state="translated">SH系列处理器上支持这些函数属性。</target>
        </trans-unit>
        <trans-unit id="98428d8e4eba9c792163f590881b9a318e73170e" translate="yes" xml:space="preserve">
          <source>These functions are implemented in terms of the &amp;lsquo;</source>
          <target state="translated">这些功能是根据&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="8d57779f821090bd738e90d984c08a5bc5b3499b" translate="yes" xml:space="preserve">
          <source>These functions are intended to replace the legacy &amp;lsquo;</source>
          <target state="translated">这些功能旨在取代旧版&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="ad90f9504c295e2f97ffc9946ebca4f6b5d5ccf1" translate="yes" xml:space="preserve">
          <source>These functions compare &lt;var&gt;a&lt;/var&gt; and &lt;var&gt;b&lt;/var&gt; using &lt;code&gt;c.&lt;var&gt;cond&lt;/var&gt;.ps&lt;/code&gt; and return either the upper or lower half of the result. For example:</source>
          <target state="translated">这些函数使用 &lt;code&gt;c.&lt;var&gt;cond&lt;/var&gt;.ps&lt;/code&gt; 比较 &lt;var&gt;a&lt;/var&gt; 和 &lt;var&gt;b&lt;/var&gt; 。 &lt;var&gt;cond&lt;/var&gt; .ps并返回结果的上半部或下半部。例如：</target>
        </trans-unit>
        <trans-unit id="03c7a748fe1ee1ae1b17cfc9b1186d6994642291" translate="yes" xml:space="preserve">
          <source>These functions compare &lt;var&gt;a&lt;/var&gt; and &lt;var&gt;b&lt;/var&gt; using &lt;code&gt;c.&lt;var&gt;cond&lt;/var&gt;.ps&lt;/code&gt; or &lt;code&gt;cabs.&lt;var&gt;cond&lt;/var&gt;.ps&lt;/code&gt;. The &lt;code&gt;any&lt;/code&gt; forms return &lt;code&gt;true&lt;/code&gt; if either result is &lt;code&gt;true&lt;/code&gt; and the &lt;code&gt;all&lt;/code&gt; forms return &lt;code&gt;true&lt;/code&gt; if both results are &lt;code&gt;true&lt;/code&gt;. For example:</source>
          <target state="translated">这些函数使用 &lt;code&gt;c.&lt;var&gt;cond&lt;/var&gt;.ps&lt;/code&gt; 比较 &lt;var&gt;a&lt;/var&gt; 和 &lt;var&gt;b&lt;/var&gt; 。 &lt;var&gt;cond&lt;/var&gt; .ps或 &lt;code&gt;cabs.&lt;var&gt;cond&lt;/var&gt;.ps&lt;/code&gt; 。在 &lt;code&gt;any&lt;/code&gt; 形式返回 &lt;code&gt;true&lt;/code&gt; 如果任一结果是 &lt;code&gt;true&lt;/code&gt; 和 &lt;code&gt;all&lt;/code&gt; 形式返回 &lt;code&gt;true&lt;/code&gt; 如果两个结果是 &lt;code&gt;true&lt;/code&gt; 。例如：</target>
        </trans-unit>
        <trans-unit id="c195ff99103a21f524d4637aac5069ea8a395ea9" translate="yes" xml:space="preserve">
          <source>These functions compare &lt;var&gt;a&lt;/var&gt; and &lt;var&gt;b&lt;/var&gt; using &lt;code&gt;cabs.&lt;var&gt;cond&lt;/var&gt;.ps&lt;/code&gt; and return either the upper or lower half of the result. For example:</source>
          <target state="translated">这些功能使用 &lt;code&gt;cabs.&lt;var&gt;cond&lt;/var&gt;.ps&lt;/code&gt; 比较 &lt;var&gt;a&lt;/var&gt; 和 &lt;var&gt;b&lt;/var&gt; 。 &lt;var&gt;cond&lt;/var&gt; .ps并返回结果的上半部或下半部。例如：</target>
        </trans-unit>
        <trans-unit id="46c037085992dbec65501906e5e93cf40d6de82a" translate="yes" xml:space="preserve">
          <source>These functions compare &lt;var&gt;a&lt;/var&gt; and &lt;var&gt;b&lt;/var&gt; using &lt;code&gt;cabs.&lt;var&gt;cond&lt;/var&gt;.s&lt;/code&gt; or &lt;code&gt;cabs.&lt;var&gt;cond&lt;/var&gt;.d&lt;/code&gt; and return the result as a boolean value. For example:</source>
          <target state="translated">这些功能使用 &lt;code&gt;cabs.&lt;var&gt;cond&lt;/var&gt;.s&lt;/code&gt; 比较 &lt;var&gt;a&lt;/var&gt; 和 &lt;var&gt;b&lt;/var&gt; 。 &lt;var&gt;cond&lt;/var&gt; .S或 &lt;code&gt;cabs.&lt;var&gt;cond&lt;/var&gt;.d&lt;/code&gt; 并将结果作为布尔值返回。例如：</target>
        </trans-unit>
        <trans-unit id="e664732594a1533360445b60577eaf62e517fa5e" translate="yes" xml:space="preserve">
          <source>These functions may be used to get information about the callers of a function.</source>
          <target state="translated">这些函数可以用来获取函数调用者的信息。</target>
        </trans-unit>
        <trans-unit id="1dfc3d7d206adff68ce67f88a57319430a6ab850" translate="yes" xml:space="preserve">
          <source>These functions use &lt;code&gt;c.&lt;var&gt;cond&lt;/var&gt;.ps&lt;/code&gt; or &lt;code&gt;cabs.&lt;var&gt;cond&lt;/var&gt;.ps&lt;/code&gt; to compare &lt;var&gt;a&lt;/var&gt; with &lt;var&gt;b&lt;/var&gt; and to compare &lt;var&gt;c&lt;/var&gt; with &lt;var&gt;d&lt;/var&gt;. The &lt;code&gt;any&lt;/code&gt; forms return &lt;code&gt;true&lt;/code&gt; if any of the four results are &lt;code&gt;true&lt;/code&gt; and the &lt;code&gt;all&lt;/code&gt; forms return &lt;code&gt;true&lt;/code&gt; if all four results are &lt;code&gt;true&lt;/code&gt;. For example:</source>
          <target state="translated">这些功能使用 &lt;code&gt;c.&lt;var&gt;cond&lt;/var&gt;.ps&lt;/code&gt; 或 &lt;code&gt;cabs.&lt;var&gt;cond&lt;/var&gt;.ps&lt;/code&gt; 将 &lt;var&gt;a&lt;/var&gt; 与 &lt;var&gt;b&lt;/var&gt; 进行比较，并将 &lt;var&gt;c&lt;/var&gt; 与 &lt;var&gt;d&lt;/var&gt; 进行比较。在 &lt;code&gt;any&lt;/code&gt; 形式返回 &lt;code&gt;true&lt;/code&gt; 如果有四个结果是 &lt;code&gt;true&lt;/code&gt; 和 &lt;code&gt;all&lt;/code&gt; 形式返回 &lt;code&gt;true&lt;/code&gt; 如果四个结果是 &lt;code&gt;true&lt;/code&gt; 。例如：</target>
        </trans-unit>
        <trans-unit id="93f3cb76d903b1b5ffde931b05d3fa75fc2f5327" translate="yes" xml:space="preserve">
          <source>These hardware transactional memory intrinsics for x86 allow you to use memory transactions with RTM (Restricted Transactional Memory). This support is enabled with the</source>
          <target state="translated">这些针对x86的硬件事务性内存固有功能允许你使用RTM(受限事务性内存)的内存事务。这种支持是通过</target>
        </trans-unit>
        <trans-unit id="3b8547b042f5482e49423b8a94ba89797760897f" translate="yes" xml:space="preserve">
          <source>These identifiers are variables, not preprocessor macros, and may not be used to initialize &lt;code&gt;char&lt;/code&gt; arrays or be concatenated with string literals.</source>
          <target state="translated">这些标识符是变量，而不是预处理器宏，并且不能用于初始化 &lt;code&gt;char&lt;/code&gt; 数组或与字符串文字串联。</target>
        </trans-unit>
        <trans-unit id="d7ada7b6e3845c0a5e68e19752115e91ad7e714e" translate="yes" xml:space="preserve">
          <source>These issues were corrected in</source>
          <target state="translated">这些问题已在</target>
        </trans-unit>
        <trans-unit id="9b9701e15c9d94aa04294acbc1a1a03ddc6872e2" translate="yes" xml:space="preserve">
          <source>These machine-independent options control the interface conventions used in code generation.</source>
          <target state="translated">这些与机器无关的选项控制了代码生成中使用的接口约定。</target>
        </trans-unit>
        <trans-unit id="1408af6170149b7254d4dd6bcdcfd495ec7436ce" translate="yes" xml:space="preserve">
          <source>These mangling issues were fixed in</source>
          <target state="translated">这些乱码问题已在</target>
        </trans-unit>
        <trans-unit id="07b49ceeb21cede5a3a2711e37a7de019bfde35f" translate="yes" xml:space="preserve">
          <source>These memory models are formally defined in Appendix D of the SPARC-V9 architecture manual, as set in the processor&amp;rsquo;s &lt;code&gt;PSTATE.MM&lt;/code&gt; field.</source>
          <target state="translated">这些存储器模型在SPARC-V9体系结构手册的附录D中正式定义，如处理器的 &lt;code&gt;PSTATE.MM&lt;/code&gt; 字段中所设置。</target>
        </trans-unit>
        <trans-unit id="b1c28027a49e0f9f937405f5f5d9848e5c4e1880" translate="yes" xml:space="preserve">
          <source>These modifiers generate this assembler code:</source>
          <target state="translated">这些修饰符会产生这个汇编器代码。</target>
        </trans-unit>
        <trans-unit id="743e02542ccafa4975400ec872a7ad2395932b78" translate="yes" xml:space="preserve">
          <source>These options (&amp;lsquo;</source>
          <target state="translated">这些选项（'</target>
        </trans-unit>
        <trans-unit id="4958c6c5d677addc8f58eab0c0d2cf3562ddc1ad" translate="yes" xml:space="preserve">
          <source>These options are defined for AArch64 implementations:</source>
          <target state="translated">这些选项是为 AArch64 的实现而定义的。</target>
        </trans-unit>
        <trans-unit id="48d92fc742af2bfa615c74329a584a34db9bd186" translate="yes" xml:space="preserve">
          <source>These options are defined for AVR implementations:</source>
          <target state="translated">这些选项是为AVR实现而定义的。</target>
        </trans-unit>
        <trans-unit id="b2e06ccfcce04ef8518c59faf9fdd99422ee95ce" translate="yes" xml:space="preserve">
          <source>These options are defined for NDS32 implementations:</source>
          <target state="translated">这些选项是为NDS32实现而定义的。</target>
        </trans-unit>
        <trans-unit id="5d910c773d7a92c5968f91520cb1c96e846ae694" translate="yes" xml:space="preserve">
          <source>These options are defined for Nvidia PTX:</source>
          <target state="translated">这些选项是为Nvidia PTX定义的。</target>
        </trans-unit>
        <trans-unit id="70a11512edb73659010487af7574c61b869ed8dd" translate="yes" xml:space="preserve">
          <source>These options are defined for OpenRISC:</source>
          <target state="translated">这些选项是为OpenRISC定义的。</target>
        </trans-unit>
        <trans-unit id="c280d854c3b143f60be7e0eaa4e7170900086fe5" translate="yes" xml:space="preserve">
          <source>These options are defined for Score implementations:</source>
          <target state="translated">这些选项是为 Score 实现定义的。</target>
        </trans-unit>
        <trans-unit id="3fb4c45c0c5f292728f019e5710497a0ec8817f3" translate="yes" xml:space="preserve">
          <source>These options are defined for Xstormy16:</source>
          <target state="translated">这些选项是为Xstormy16定义的。</target>
        </trans-unit>
        <trans-unit id="8b09b81649730921d2e9ab3de0a2c88ec62a4975" translate="yes" xml:space="preserve">
          <source>These options are defined for all architectures running the Darwin operating system.</source>
          <target state="translated">这些选项是为运行达尔文操作系统的所有架构定义的。</target>
        </trans-unit>
        <trans-unit id="7cb3b867f983940ea2e4ebd67efa329a40f483ce" translate="yes" xml:space="preserve">
          <source>These options are defined for the MMIX:</source>
          <target state="translated">这些选项是为MMIX定义的。</target>
        </trans-unit>
        <trans-unit id="385fe3117f02cef23e8d723690c0cfc308b93e2c" translate="yes" xml:space="preserve">
          <source>These options are defined for the MSP430:</source>
          <target state="translated">这些选项是为MSP430定义的。</target>
        </trans-unit>
        <trans-unit id="adcca40803ff77f8885d53e3bb9902253e5f5f3e" translate="yes" xml:space="preserve">
          <source>These options are defined for the PDP-11:</source>
          <target state="translated">这些选项是为PDP-11定义的。</target>
        </trans-unit>
        <trans-unit id="9bfa23d8fe1cfc039288a92db83209397de4a2aa" translate="yes" xml:space="preserve">
          <source>These options are defined specifically for the AMD GCN port.</source>
          <target state="translated">这些选项是专门为AMD GCN端口定义的。</target>
        </trans-unit>
        <trans-unit id="08c86a5f185d6c276d710a46803063b57baac6b5" translate="yes" xml:space="preserve">
          <source>These options are defined specifically for the CR16 ports.</source>
          <target state="translated">这些选项是专门为CR16端口定义的。</target>
        </trans-unit>
        <trans-unit id="bbab2a1744111610f4ef1fc49ca09af76e7d1a32" translate="yes" xml:space="preserve">
          <source>These options are defined specifically for the CRIS ports.</source>
          <target state="translated">这些选项是专门为CRIS端口定义的。</target>
        </trans-unit>
        <trans-unit id="9926932fa2a7f92eb437e1b2ac02cd6adfeca6d5" translate="yes" xml:space="preserve">
          <source>These options are defined specifically for the FR30 port.</source>
          <target state="translated">这些选项是专门为FR30端口定义的。</target>
        </trans-unit>
        <trans-unit id="3dab4ff68a4f656f1c031b134a3ea5a7f3fcf21b" translate="yes" xml:space="preserve">
          <source>These options are defined specifically for the FT32 port.</source>
          <target state="translated">这些选项是专门为FT32端口定义的。</target>
        </trans-unit>
        <trans-unit id="75c959329e4528f6f7066c03da92ac9a3ae209b8" translate="yes" xml:space="preserve">
          <source>These options are passed down to the linker. They are defined for compatibility with Diab.</source>
          <target state="translated">这些选项被传递给链接器。它们是为了与Diab兼容而定义的。</target>
        </trans-unit>
        <trans-unit id="514cb6ef588bccc0cfd12c2a6ee53c62e3980343" translate="yes" xml:space="preserve">
          <source>These options are passed to the Darwin linker. The Darwin linker man page describes them in detail.</source>
          <target state="translated">这些选项被传递给Darwin linker。达尔文链接器手册详细描述了这些选项。</target>
        </trans-unit>
        <trans-unit id="921e998e0a7514666b6cd58d10b556dced0e17ae" translate="yes" xml:space="preserve">
          <source>These options are similar to</source>
          <target state="translated">这些选项类似于</target>
        </trans-unit>
        <trans-unit id="c15cb110a025cb053a49b0cc23a8ae49630d084e" translate="yes" xml:space="preserve">
          <source>These options are supported for Xtensa targets:</source>
          <target state="translated">Xtensa目标支持这些选项。</target>
        </trans-unit>
        <trans-unit id="024672ba12f6533c6267ee5ffbe7b18b0036fae5" translate="yes" xml:space="preserve">
          <source>These options come into play when the compiler links object files into an executable output file. They are meaningless if the compiler is not doing a link step.</source>
          <target state="translated">当编译器将对象文件链接到可执行输出文件时,这些选项就会发挥作用。如果编译器不进行链接步骤,这些选项就没有意义。</target>
        </trans-unit>
        <trans-unit id="4133c0873f5f47fa3d2f753863bb9a83e1789d05" translate="yes" xml:space="preserve">
          <source>These options control the C preprocessor, which is run on each C source file before actual compilation.</source>
          <target state="translated">这些选项控制了C预处理器,它在实际编译之前在每个C源文件上运行。</target>
        </trans-unit>
        <trans-unit id="5ef76ab842e5d74de09c81a688676470bc03ede7" translate="yes" xml:space="preserve">
          <source>These options control the encoding of the special not-a-number (NaN) IEEE 754 floating-point data.</source>
          <target state="translated">这些选项控制特殊的非数字(NaN)IEEE 754浮点数据的编码。</target>
        </trans-unit>
        <trans-unit id="b6d05ca58952f18a481361248697cafe54bd4e24" translate="yes" xml:space="preserve">
          <source>These options control the treatment of literal pools. The default is</source>
          <target state="translated">这些选项控制对文字池的处理。默认值是</target>
        </trans-unit>
        <trans-unit id="63f8686ec125e23f83695f3f62c70b1f7e4905ad" translate="yes" xml:space="preserve">
          <source>These options control the treatment of the special not-a-number (NaN) IEEE 754 floating-point data with the &lt;code&gt;abs.&lt;i&gt;fmt&lt;/i&gt;&lt;/code&gt; and &lt;code&gt;neg.&lt;i&gt;fmt&lt;/i&gt;&lt;/code&gt; machine instructions.</source>
          <target state="translated">这些选项控制使用ab处理特殊的非数字（NaN）IEEE 754浮点数据 &lt;code&gt;abs.&lt;i&gt;fmt&lt;/i&gt;&lt;/code&gt; 和 &lt;code&gt;neg.&lt;i&gt;fmt&lt;/i&gt;&lt;/code&gt; 机器说明。</target>
        </trans-unit>
        <trans-unit id="fe30970c8506c0b34e204983d37e0e48b0b22605" translate="yes" xml:space="preserve">
          <source>These options control various sorts of optimizations.</source>
          <target state="translated">这些选项控制各种优化。</target>
        </trans-unit>
        <trans-unit id="ca73d9226e349bbe9ceb8794e7b1f792d3ed7055" translate="yes" xml:space="preserve">
          <source>These options control warnings about left shift overflows.</source>
          <target state="translated">这些选项控制了左移溢出的警告。</target>
        </trans-unit>
        <trans-unit id="8077ddc9c44325d74d2e32e67e952882010bc964" translate="yes" xml:space="preserve">
          <source>These options control whether a bit-field is signed or unsigned, when the declaration does not use either &lt;code&gt;signed&lt;/code&gt; or &lt;code&gt;unsigned&lt;/code&gt;. By default, such a bit-field is signed, because this is consistent: the basic integer types such as &lt;code&gt;int&lt;/code&gt; are signed types.</source>
          <target state="translated">当声明不使用 &lt;code&gt;signed&lt;/code&gt; 或 &lt;code&gt;unsigned&lt;/code&gt; 时，这些选项控制位字段是带符号的还是无符号的。默认情况下，这样的位字段是带符号的，因为这是一致的：诸如 &lt;code&gt;int&lt;/code&gt; 之类的基本整数类型是带符号的类型。</target>
        </trans-unit>
        <trans-unit id="04984b17ce3993112173c90b978bdade9a561d21" translate="yes" xml:space="preserve">
          <source>These options control which form of branches will be generated. The default is</source>
          <target state="translated">这些选项控制将生成哪种形式的分支。默认为</target>
        </trans-unit>
        <trans-unit id="75acf55e945580c3df0ebbfbfe506d046bc6e85c" translate="yes" xml:space="preserve">
          <source>These options enable GCC to use these extended instructions in generated code, even without</source>
          <target state="translated">这些选项使GCC能够在生成的代码中使用这些扩展指令,即使没有</target>
        </trans-unit>
        <trans-unit id="e7fd9ac7bed816cccc6942a8d8998c84e682fcba" translate="yes" xml:space="preserve">
          <source>These options enable dumping after five rounds of instruction splitting.</source>
          <target state="translated">这些选项可以在五轮指令拆分后进行转储。</target>
        </trans-unit>
        <trans-unit id="b5b2a58223d63058f35e9cfc3fe268fbe52e4e8c" translate="yes" xml:space="preserve">
          <source>These options have no effect unless GCC is generating position independent code.</source>
          <target state="translated">除非GCC生成与位置无关的代码,否则这些选项没有效果。</target>
        </trans-unit>
        <trans-unit id="0d11fb15204ab5a9c7be14b9ed2aaeffe527ddd6" translate="yes" xml:space="preserve">
          <source>These options have no effect unless GCC is generating position-independent code.</source>
          <target state="translated">除非GCC生成与位置无关的代码,否则这些选项没有效果。</target>
        </trans-unit>
        <trans-unit id="32e82c10f4ef0470986d8f101c75c3deb8c3bb8b" translate="yes" xml:space="preserve">
          <source>These options specify directories to search for header files, for libraries and for parts of the compiler:</source>
          <target state="translated">这些选项指定了要搜索头文件、库和编译器部分的目录。</target>
        </trans-unit>
        <trans-unit id="e76a02704dc0e3839f8323b052aabfba6ae282f0" translate="yes" xml:space="preserve">
          <source>These options tell the compiler where to place functions and data that do not have one of the &lt;code&gt;lower&lt;/code&gt;, &lt;code&gt;upper&lt;/code&gt;, &lt;code&gt;either&lt;/code&gt; or &lt;code&gt;section&lt;/code&gt; attributes. Possible values are &lt;code&gt;lower&lt;/code&gt;, &lt;code&gt;upper&lt;/code&gt;, &lt;code&gt;either&lt;/code&gt; or &lt;code&gt;any&lt;/code&gt;. The first three behave like the corresponding attribute. The fourth possible value - &lt;code&gt;any&lt;/code&gt; - is the default. It leaves placement entirely up to the linker script and how it assigns the standard sections (&lt;code&gt;.text&lt;/code&gt;, &lt;code&gt;.data&lt;/code&gt;, etc) to the memory regions.</source>
          <target state="translated">这些选项告诉编译器将函数和数据不具有的一个 &lt;code&gt;lower&lt;/code&gt; ， &lt;code&gt;upper&lt;/code&gt; ， &lt;code&gt;either&lt;/code&gt; 或 &lt;code&gt;section&lt;/code&gt; 属性。可能的值是 &lt;code&gt;lower&lt;/code&gt; ， &lt;code&gt;upper&lt;/code&gt; ， &lt;code&gt;either&lt;/code&gt; 或 &lt;code&gt;any&lt;/code&gt; 。前三个行为类似于相应的属性。第四个可能的值 &lt;code&gt;any&lt;/code&gt; 是默认值。它将位置完全留给链接描述文件，以及如何将标准段（ &lt;code&gt;.text&lt;/code&gt; ， &lt;code&gt;.data&lt;/code&gt; 等）分配给内存区域。</target>
        </trans-unit>
        <trans-unit id="e0b73ff2eada76f8ac9ebd9981af9354d96c99aa" translate="yes" xml:space="preserve">
          <source>These pragmas maintain a stack of the current target and optimization options. It is intended for include files where you temporarily want to switch to using a different &amp;lsquo;</source>
          <target state="translated">这些实用程序保留了当前目标和优化选项的堆栈。它用于包含您临时要切换为使用其他&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="603f3636cf78ad4d753498b11957f65672ebe2cb" translate="yes" xml:space="preserve">
          <source>These problems are perhaps regrettable, but we don&amp;rsquo;t know any practical way around them.</source>
          <target state="translated">这些问题也许令人遗憾，但是我们不知道如何解决这些问题。</target>
        </trans-unit>
        <trans-unit id="65b9fcf5c8f8750409b0be6384fa9bc28cb10f52" translate="yes" xml:space="preserve">
          <source>These programs work properly with GNU C++ if &lt;code&gt;__STDC__&lt;/code&gt; is defined. They would not work otherwise.</source>
          <target state="translated">如果定义了 &lt;code&gt;__STDC__&lt;/code&gt; ,则这些程序可与GNU C ++一起正常使用。他们否则将无法工作。</target>
        </trans-unit>
        <trans-unit id="8668b2099e0b980048c9ff0d8e19c4e25e485197" translate="yes" xml:space="preserve">
          <source>These pseudo types are not defined by GCC, they are simply a notational convenience used in this manual.</source>
          <target state="translated">这些伪类型不是由GCC定义的,它们只是本手册中使用的一种符号上的便利。</target>
        </trans-unit>
        <trans-unit id="f405633d47d5e6bb41585f2bd9ddbfca800a1d10" translate="yes" xml:space="preserve">
          <source>These restrictions exist because the storage order attribute is lost when the address of a scalar or the address of an array with scalar component is taken, so storing indirectly through this address generally does not work. The second case is nevertheless allowed to be able to perform a block copy from or to the array.</source>
          <target state="translated">之所以存在这些限制,是因为当取标量的地址或者取带有标量成分的数组的地址时,存储顺序属性就会丢失,所以通过这个地址间接存储一般是不行的。不过第二种情况是允许的,能够从数组中或向数组进行块复制。</target>
        </trans-unit>
        <trans-unit id="617ec4855cb2c9a651bfd784a1ec34d6b14a3c49" translate="yes" xml:space="preserve">
          <source>These switches are supported in addition to the above on Solaris 2:</source>
          <target state="translated">在Solaris 2上除了支持上述交换机外,还支持这些交换机。</target>
        </trans-unit>
        <trans-unit id="bc8a75785b95174e69ab84ca725881f92373e1de" translate="yes" xml:space="preserve">
          <source>These switches control the size of &lt;code&gt;long double&lt;/code&gt; type. A size of 64 bits makes the &lt;code&gt;long double&lt;/code&gt; type equivalent to the &lt;code&gt;double&lt;/code&gt; type. This is the default for 32-bit Bionic C library. A size of 128 bits makes the &lt;code&gt;long double&lt;/code&gt; type equivalent to the &lt;code&gt;__float128&lt;/code&gt; type. This is the default for 64-bit Bionic C library.</source>
          <target state="translated">这些开关控制 &lt;code&gt;long double&lt;/code&gt; 类型的大小。64位的大小使 &lt;code&gt;long double&lt;/code&gt; 类型等效于 &lt;code&gt;double&lt;/code&gt; 类型。这是32位Bionic C库的默认设置。128位的大小使 &lt;code&gt;long double&lt;/code&gt; 类型等效于 &lt;code&gt;__float128&lt;/code&gt; 类型。这是64位Bionic C库的默认设置。</target>
        </trans-unit>
        <trans-unit id="ee4c72bd4a51cef29e53fde4cebb62a0cdc42ecb" translate="yes" xml:space="preserve">
          <source>These switches control the size of &lt;code&gt;long double&lt;/code&gt; type. A size of 64 bits makes the &lt;code&gt;long double&lt;/code&gt; type equivalent to the &lt;code&gt;double&lt;/code&gt; type. This is the default.</source>
          <target state="translated">这些开关控制 &lt;code&gt;long double&lt;/code&gt; 类型的大小。64位的大小使 &lt;code&gt;long double&lt;/code&gt; 类型等效于 &lt;code&gt;double&lt;/code&gt; 类型。这是默认值。</target>
        </trans-unit>
        <trans-unit id="cfe1fb390a0357110cca04fd8837b1f7aac6050f" translate="yes" xml:space="preserve">
          <source>These switches control the size of &lt;code&gt;long double&lt;/code&gt; type. The x86-32 application binary interface specifies the size to be 96 bits, so</source>
          <target state="translated">这些开关控制 &lt;code&gt;long double&lt;/code&gt; 类型的大小。x86-32应用程序二进制接口将大小指定为96位，因此</target>
        </trans-unit>
        <trans-unit id="10e0a73d40a50d884864ada5af6042c707554338" translate="yes" xml:space="preserve">
          <source>These switches enable the use of instructions in the MMX, SSE, SSE2, SSE3, SSSE3, SSE4, SSE4A, SSE4.1, SSE4.2, AVX, AVX2, AVX512F, AVX512PF, AVX512ER, AVX512CD, AVX512VL, AVX512BW, AVX512DQ, AVX512IFMA, AVX512VBMI, SHA, AES, PCLMUL, CLFLUSHOPT, CLWB, FSGSBASE, PTWRITE, RDRND, F16C, FMA, PCONFIG, WBNOINVD, FMA4, PREFETCHW, RDPID, PREFETCHWT1, RDSEED, SGX, XOP, LWP, 3DNow!, enhanced 3DNow!, POPCNT, ABM, ADX, BMI, BMI2, LZCNT, FXSR, XSAVE, XSAVEOPT, XSAVEC, XSAVES, RTM, HLE, TBM, MWAITX, CLZERO, PKU, AVX512VBMI2, GFNI, VAES, WAITPKG, VPCLMULQDQ, AVX512BITALG, MOVDIRI, MOVDIR64B, AVX512BF16, ENQCMD, AVX512VPOPCNTDQ, AVX5124FMAPS, AVX512VNNI, AVX5124VNNIW, or CLDEMOTE extended instruction sets. Each has a corresponding</source>
          <target state="translated">通过这些开关,可以使用MMX、SSE、SSE2、SSE3、SSE3、SSE4、SSE4A、SSE4.1、SSE4中的指令。 2、AVX、AVX2、AVX512F、AVX512PF、AVX512ER、AVX512CD、AVX512VL、AVX512BW、AVX512DQ、AVX512IFMA、AVX512VBMI、SHA、AES、PCLMUL、CLFLUSHOPT。CLWB,FSGSBASE,PTWRITE,RDRND,F16C,FMA,PCONFIG,WBNOINVD,FMA4,PREFETCHW,RDPID,PREFETCHWT1,RDSEED,SGX,XOP,LWP,3DNow!,增强型3DNow! POPCNT、ABM、ADX、BMI、BMI2、LZCNT、FXSR、XSAVE、XSAVEOPT、XSAVEC、XSAVES、RTM、HLE、TBM、MWAITX、CLZERO、PKU、AVX512VBMI2、GFNI、VAES、WAITPKG、VPCLMULQDQ。AVX512BITALG、MOVDIRI、MOVDIR64B、AVX512BF16、ENQCMD、AVX512VPOPCNTDQ、AVX5124FMAPS、AVX512VNNI、AVX5124VNNIW或CLDEMOTE扩展指令集。每个指令集都有一个相应的</target>
        </trans-unit>
        <trans-unit id="c7348ef4aa27c2888870c0a37711f33df4fe6ef4" translate="yes" xml:space="preserve">
          <source>These switches enable the use of instructions in the MMX, SSE, SSE2, SSE3, SSSE3, SSE4, SSE4A, SSE4.1, SSE4.2, AVX, AVX2, AVX512F, AVX512PF, AVX512ER, AVX512CD, AVX512VL, AVX512BW, AVX512DQ, AVX512IFMA, AVX512VBMI, SHA, AES, PCLMUL, CLFLUSHOPT, CLWB, FSGSBASE, PTWRITE, RDRND, F16C, FMA, PCONFIG, WBNOINVD, FMA4, PREFETCHW, RDPID, PREFETCHWT1, RDSEED, SGX, XOP, LWP, 3DNow!, enhanced 3DNow!, POPCNT, ABM, ADX, BMI, BMI2, LZCNT, FXSR, XSAVE, XSAVEOPT, XSAVEC, XSAVES, RTM, HLE, TBM, MWAITX, CLZERO, PKU, AVX512VBMI2, GFNI, VAES, WAITPKG, VPCLMULQDQ, AVX512BITALG, MOVDIRI, MOVDIR64B, AVX512VPOPCNTDQ, AVX5124FMAPS, AVX512VNNI, AVX5124VNNIW, or CLDEMOTE extended instruction sets. Each has a corresponding</source>
          <target state="translated">通过这些开关,可以使用MMX、SSE、SSE2、SSE3、SSE3、SSE4、SSE4A、SSE4.1、SSE4中的指令。 2、AVX、AVX2、AVX512F、AVX512PF、AVX512ER、AVX512CD、AVX512VL、AVX512BW、AVX512DQ、AVX512IFMA、AVX512VBMI、SHA、AES、PCLMUL、CLFLUSHOPT。CLWB,FSGSBASE,PTWRITE,RDRND,F16C,FMA,PCONFIG,WBNOINVD,FMA4,PREFETCHW,RDPID,PREFETCHWT1,RDSEED,SGX,XOP,LWP,3DNow!,增强型3DNow! POPCNT、ABM、ADX、BMI、BMI2、LZCNT、FXSR、XSAVE、XSAVEOPT、XSAVEC、XSAVES、RTM、HLE、TBM、MWAITX、CLZERO、PKU、AVX512VBMI2、GFNI、VAES、WAITPKG。VPCLMULQDQ、AVX512BITALG、MOVDIRI、MOVDIR64B、AVX512VPOPCNTDQ、AVX5124FMAPS、AVX512VNNI、AVX5124VNNIW或CLDEMOTE扩展指令集。每个指令集都有一个相应的</target>
        </trans-unit>
        <trans-unit id="cf9495d6f00684499ee4c826615f4071694dd898" translate="yes" xml:space="preserve">
          <source>These types can be used to define 128-bit variables. The built-in functions listed in the following section can be used on these variables to generate the vector operations.</source>
          <target state="translated">这些类型可以用来定义128位的变量。下一节中列出的内置函数可以用于这些变量上生成向量运算。</target>
        </trans-unit>
        <trans-unit id="e668693b38e6c57f5102ee95a3e05249f7244a77" translate="yes" xml:space="preserve">
          <source>These usages are only permitted when they are not ambiguous.</source>
          <target state="translated">这些用法只有在不含糊的情况下才允许使用。</target>
        </trans-unit>
        <trans-unit id="5f38a05c071c60c51e986980de83378738afc905" translate="yes" xml:space="preserve">
          <source>These variable attributes are available for H8/300 targets:</source>
          <target state="translated">这些可变属性可用于H8/300目标。</target>
        </trans-unit>
        <trans-unit id="241d1accd4905e80f5a34fe3dc64f1b3deee21e2" translate="yes" xml:space="preserve">
          <source>These variable attributes are supported by the Nvidia PTX back end:</source>
          <target state="translated">这些变量属性由Nvidia PTX后端支持。</target>
        </trans-unit>
        <trans-unit id="f806a524d1696f92091d57f9cf53c9146e9a15bf" translate="yes" xml:space="preserve">
          <source>These variable attributes are supported by the V850 back end:</source>
          <target state="translated">这些变量属性由V850后端支持。</target>
        </trans-unit>
        <trans-unit id="e1ed20f7dd8c240bdd89fa6c4be557443a983d56" translate="yes" xml:space="preserve">
          <source>These warnings are enabled by default.</source>
          <target state="translated">这些警告默认为启用。</target>
        </trans-unit>
        <trans-unit id="b949d9fe4918e4b913002b1484d0c6602fa25eb3" translate="yes" xml:space="preserve">
          <source>These warnings are harmless and can be safely ignored.</source>
          <target state="translated">这些警告是无害的,可以放心地忽略。</target>
        </trans-unit>
        <trans-unit id="e451fc6c4b4d61a1351149a72dc14d1a6505cb95" translate="yes" xml:space="preserve">
          <source>These warnings are made optional because GCC may not be able to determine when the code is correct in spite of appearing to have an error. Here is one example of how this can happen:</source>
          <target state="translated">这些警告是可选的,因为GCC可能无法确定代码是否正确,尽管看起来有错误。这里有一个例子可以说明这种情况是如何发生的。</target>
        </trans-unit>
        <trans-unit id="94e18fe51f3f4e2e5c1a093907e436f1a7eab080" translate="yes" xml:space="preserve">
          <source>These warnings are only possible in optimizing compilation, because otherwise GCC does not keep track of the state of variables.</source>
          <target state="translated">这些警告只有在优化编译时才有可能,因为否则GCC不会跟踪变量的状态。</target>
        </trans-unit>
        <trans-unit id="e68200a8afffeb4dc68ba2a9ef927363c09a49e9" translate="yes" xml:space="preserve">
          <source>These warnings occur for individual uninitialized elements of structure, union or array variables as well as for variables that are uninitialized as a whole. They do not occur for variables or elements declared &lt;code&gt;volatile&lt;/code&gt;. Because these warnings depend on optimization, the exact variables or elements for which there are warnings depend on the precise optimization options and version of GCC used.</source>
          <target state="translated">对于结构，联合或数组变量的各个未初始化元素以及整体上未初始化的变量，会发生这些警告。对于声明为 &lt;code&gt;volatile&lt;/code&gt; 的变量或元素，它们不会发生。因为这些警告取决于优化，所以存在警告的确切变量或元素取决于精确的优化选项和所使用的GCC版本。</target>
        </trans-unit>
        <trans-unit id="e773c8b72ecdbdff1f92adf539e992bd54211f66" translate="yes" xml:space="preserve">
          <source>These warnings occur for individual uninitialized or clobbered elements of structure, union or array variables as well as for variables that are uninitialized or clobbered as a whole. They do not occur for variables or elements declared &lt;code&gt;volatile&lt;/code&gt;. Because these warnings depend on optimization, the exact variables or elements for which there are warnings depends on the precise optimization options and version of GCC used.</source>
          <target state="translated">对于结构，联合变量或数组变量的各个未初始化或破坏的元素以及整体上未初始化或破坏的变量，会发生这些警告。对于声明为 &lt;code&gt;volatile&lt;/code&gt; 的变量或元素，它们不会发生。由于这些警告取决于优化，因此存在警告的确切变量或元素取决于精确的优化选项和所使用的GCC版本。</target>
        </trans-unit>
        <trans-unit id="54f2498a22474b067e488cbcf73df92835b4dcbc" translate="yes" xml:space="preserve">
          <source>Things we think are right, but some others disagree.</source>
          <target state="translated">我们认为正确的事情,但有些人不同意。</target>
        </trans-unit>
        <trans-unit id="1997b0ca2cbaa31341990ddcffc48330394de3bf" translate="yes" xml:space="preserve">
          <source>Things will disappear from G++.</source>
          <target state="translated">事情将从G++中消失。</target>
        </trans-unit>
        <trans-unit id="c779d1bd661026f38150c16245e1a66cae977330" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;asm&lt;/code&gt; takes one input, which is internally popped, and produces two outputs.</source>
          <target state="translated">该 &lt;code&gt;asm&lt;/code&gt; 接受一个内部弹出的输入，并产生两个输出。</target>
        </trans-unit>
        <trans-unit id="7ea744591db59b72a57a82ebc78f06c0a9beaefd" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;asm&lt;/code&gt; takes two inputs, which are popped by the &lt;code&gt;fyl2xp1&lt;/code&gt; opcode, and replaces them with one output. The &lt;code&gt;st(1)&lt;/code&gt; clobber is necessary for the compiler to know that &lt;code&gt;fyl2xp1&lt;/code&gt; pops both inputs.</source>
          <target state="translated">该 &lt;code&gt;asm&lt;/code&gt; 接受两个输入，这些输入由 &lt;code&gt;fyl2xp1&lt;/code&gt; 操作码弹出，并将它们替换为一个输出。 &lt;code&gt;fyl2xp1&lt;/code&gt; 编译器知道fyl2xp1会同时弹出两个输入， &lt;code&gt;st(1)&lt;/code&gt; 缓冲区是必需的。</target>
        </trans-unit>
        <trans-unit id="49059cf2744a33f2c89b82b703d94b0c5663c6e8" translate="yes" xml:space="preserve">
          <source>This IA-64 HP-UX attribute, attached to a global variable or function, renames a symbol to contain a version string, thus allowing for function level versioning. HP-UX system header files may use function level versioning for some system calls.</source>
          <target state="translated">这个IA-64 HP-UX属性,附加在一个全局变量或函数上,重命名一个符号,使其包含一个版本字符串,从而允许函数级版本。HP-UX系统头文件可能会对某些系统调用使用函数级版本。</target>
        </trans-unit>
        <trans-unit id="241afcfcf7826d27f6d46a14ffc5e97907ebd792" translate="yes" xml:space="preserve">
          <source>This ISA is implemented by the minimal AVR core and supported for assembler only. &lt;var&gt;mcu&lt;/var&gt; = &lt;code&gt;attiny11&lt;/code&gt;, &lt;code&gt;attiny12&lt;/code&gt;, &lt;code&gt;attiny15&lt;/code&gt;, &lt;code&gt;attiny28&lt;/code&gt;, &lt;code&gt;at90s1200&lt;/code&gt;.</source>
          <target state="translated">该ISA由最小的AVR内核实现，仅支持汇编程序。 &lt;var&gt;mcu&lt;/var&gt; = &lt;code&gt;attiny11&lt;/code&gt; ， &lt;code&gt;attiny12&lt;/code&gt; ， &lt;code&gt;attiny15&lt;/code&gt; ， &lt;code&gt;attiny28&lt;/code&gt; ， &lt;code&gt;at90s1200&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7707ff43d31f77dd6414b616a64487e73ac2f610" translate="yes" xml:space="preserve">
          <source>This RX attribute is similar to the &lt;code&gt;interrupt&lt;/code&gt; attribute, including its parameters, but does not make the function an interrupt-handler type function (i.e. it retains the normal C function calling ABI). See the &lt;code&gt;interrupt&lt;/code&gt; attribute for a description of its arguments.</source>
          <target state="translated">此RX属性类似于 &lt;code&gt;interrupt&lt;/code&gt; 属性，包括其参数，但不会使该函数成为中断处理程序类型的函数（即，它保留调用ABI的常规C函数）。有关其参数的描述，请参见 &lt;code&gt;interrupt&lt;/code&gt; 属性。</target>
        </trans-unit>
        <trans-unit id="5e3ace91b836f39e130a69b032cbc00b174ef7e1" translate="yes" xml:space="preserve">
          <source>This allows classes to dynamically register methods (by adding them to the class using &lt;code&gt;class_addMethod&lt;/code&gt;) when they are first called. To do so, a class should implement &lt;code&gt;+resolveInstanceMethod:&lt;/code&gt; (or, depending on the case, &lt;code&gt;+resolveClassMethod:&lt;/code&gt;) and have it recognize the selectors of methods that can be registered dynamically at runtime, register them, and return &lt;code&gt;YES&lt;/code&gt;. It should return &lt;code&gt;NO&lt;/code&gt; for methods that it does not dynamically registered at runtime.</source>
          <target state="translated">这允许类在首次调用时动态注册方法（通过使用 &lt;code&gt;class_addMethod&lt;/code&gt; 将它们添加到类中）。为此，一个类应实现 &lt;code&gt;+resolveInstanceMethod:&lt;/code&gt; (或，视情况而定 &lt;code&gt;+resolveClassMethod:&lt;/code&gt; ：），并让其识别可以在运行时动态注册的方法的选择器，将其注册，然后返回 &lt;code&gt;YES&lt;/code&gt; 。对于在运行时未动态注册的方法，它应该返回 &lt;code&gt;NO&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="08bbed031d0bdc80dfc8c12fb03bbad77feeb085" translate="yes" xml:space="preserve">
          <source>This also works with</source>
          <target state="translated">这也适用于</target>
        </trans-unit>
        <trans-unit id="ebf24102acffe4ee7e0e4cb4b714de13fd9ab15c" translate="yes" xml:space="preserve">
          <source>This analysis is much more expensive than other GCC warnings.</source>
          <target state="translated">这种分析比其他GCC警告贵得多。</target>
        </trans-unit>
        <trans-unit id="70958ab1135f4d3b760976f6ea18b5ad5e6cd4ca" translate="yes" xml:space="preserve">
          <source>This assumes that &lt;code&gt;x&lt;/code&gt; is an array of pointers to functions; the type described is that of the values of the functions.</source>
          <target state="translated">假设 &lt;code&gt;x&lt;/code&gt; 是一个指向函数的指针数组；描述的类型是函数值的类型。</target>
        </trans-unit>
        <trans-unit id="0e587899e8439ab096a171178bf777e82d34203e" translate="yes" xml:space="preserve">
          <source>This attribute adds stack protection code to the function if flags</source>
          <target state="translated">这个属性为函数添加了堆栈保护代码,如果flags</target>
        </trans-unit>
        <trans-unit id="ffa1a8a02f8237f39f16f9e3141f209d4e6ecc0a" translate="yes" xml:space="preserve">
          <source>This attribute affects the linkage of the declaration to which it is attached. It can be applied to variables (see &lt;a href=&quot;common-variable-attributes#Common-Variable-Attributes&quot;&gt;Common Variable Attributes&lt;/a&gt;) and types (see &lt;a href=&quot;common-type-attributes#Common-Type-Attributes&quot;&gt;Common Type Attributes&lt;/a&gt;) as well as functions.</source>
          <target state="translated">此属性影响其所附声明的链接。它可以应用于变量（请参阅&amp;ldquo; &lt;a href=&quot;common-variable-attributes#Common-Variable-Attributes&quot;&gt;通用变量属性&amp;rdquo;&lt;/a&gt;）和类型（请参见&amp;ldquo; &lt;a href=&quot;common-type-attributes#Common-Type-Attributes&quot;&gt;通用类型属性&amp;rdquo;&lt;/a&gt;）以及函数。</target>
        </trans-unit>
        <trans-unit id="b70510133f65523747a3309a22314ce44be57270" translate="yes" xml:space="preserve">
          <source>This attribute affects the linkage of the declaration to which it is attached. The &lt;code&gt;visibility&lt;/code&gt; attribute is described in &lt;a href=&quot;common-function-attributes#Common-Function-Attributes&quot;&gt;Common Function Attributes&lt;/a&gt;.</source>
          <target state="translated">此属性影响其所附声明的链接。该 &lt;code&gt;visibility&lt;/code&gt; 属性描述&lt;a href=&quot;common-function-attributes#Common-Function-Attributes&quot;&gt;常用功能属性&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2662beeb7225f89f9b3b830e684251c6d287e4ea" translate="yes" xml:space="preserve">
          <source>This attribute allows one to mark secure-code functions that are callable from normal mode. The location of the secure call function into the &lt;code&gt;sjli&lt;/code&gt; table needs to be passed as argument.</source>
          <target state="translated">此属性允许标记可以从正常模式调用的安全代码功能。安全调用函数在 &lt;code&gt;sjli&lt;/code&gt; 表中的位置需要作为参数传递。</target>
        </trans-unit>
        <trans-unit id="f72283dc6a14cbd57d6d6c7ceadcc8425ca927f4" translate="yes" xml:space="preserve">
          <source>This attribute allows the compiler to construct the requisite function declaration, while allowing the body of the function to be assembly code. The specified function will not have prologue/epilogue sequences generated by the compiler. Only basic &lt;code&gt;asm&lt;/code&gt; statements can safely be included in naked functions (see &lt;a href=&quot;basic-asm#Basic-Asm&quot;&gt;Basic Asm&lt;/a&gt;). While using extended &lt;code&gt;asm&lt;/code&gt; or a mixture of basic &lt;code&gt;asm&lt;/code&gt; and C code may appear to work, they cannot be depended upon to work reliably and are not supported.</source>
          <target state="translated">该属性允许编译器构造必要的函数声明，同时允许函数主体为汇编代码。指定的函数将没有编译器生成的序言/结尾序列。裸函数中只能安全地包含基本的 &lt;code&gt;asm&lt;/code&gt; 语句（请参见&lt;a href=&quot;basic-asm#Basic-Asm&quot;&gt;Basic Asm&lt;/a&gt;）。虽然使用扩展 &lt;code&gt;asm&lt;/code&gt; 或基本 &lt;code&gt;asm&lt;/code&gt; 与C代码的混合似乎可以工作，但是不能依靠它们可靠地工作并且不受支持。</target>
        </trans-unit>
        <trans-unit id="2da8d71f1e17b2c08ea57936e512e0f37aa70a9f" translate="yes" xml:space="preserve">
          <source>This attribute applies only to the particular namespace body, not to other definitions of the same namespace; it is equivalent to using &amp;lsquo;</source>
          <target state="translated">此属性仅适用于特定的名称空间主体，不适用于同一名称空间的其他定义；等同于使用'</target>
        </trans-unit>
        <trans-unit id="1a6b9ade066129340d2b93cc21dd28696f004a1b" translate="yes" xml:space="preserve">
          <source>This attribute causes the compiler to assume the called function is close enough to use the normal calling convention, overriding the</source>
          <target state="translated">这个属性使编译器认为被调用的函数足够接近,可以使用正常的调用惯例,覆盖了</target>
        </trans-unit>
        <trans-unit id="02e0a7b8749b1724d33369b4ea037bd0b071529e" translate="yes" xml:space="preserve">
          <source>This attribute causes the compiler to emit instructions to disable interrupts for the duration of the given function.</source>
          <target state="translated">该属性使编译器发出指令,在给定函数的持续时间内禁用中断。</target>
        </trans-unit>
        <trans-unit id="b8e219dd9b57732e157d707be34c1c904f638a7d" translate="yes" xml:space="preserve">
          <source>This attribute corresponds to the</source>
          <target state="translated">该属性对应于</target>
        </trans-unit>
        <trans-unit id="0da402fe02e024fb03bb5a3ac4167c5cbafc19db" translate="yes" xml:space="preserve">
          <source>This attribute enables creation of one or more function versions that can process multiple arguments using SIMD instructions from a single invocation. Specifying this attribute allows compiler to assume that such versions are available at link time (provided in the same or another translation unit). Generated versions are target-dependent and described in the corresponding Vector ABI document. For x86_64 target this document can be found &lt;a href=&quot;https://sourceware.org/glibc/wiki/libmvec?action=AttachFile&amp;amp;do=view&amp;amp;target=VectorABI.txt&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">通过此属性，可以创建一个或多个函数版本，这些函数版本可以通过一次调用使用SIMD指令来处理多个参数。指定此属性可使编译器假定链接版本（在相同或另一个翻译单元中提供）可以使用这些版本。生成的版本取决于目标，并在相应的Vector ABI文档中进行了描述。对于x86_64目标，可以在&lt;a href=&quot;https://sourceware.org/glibc/wiki/libmvec?action=AttachFile&amp;amp;do=view&amp;amp;target=VectorABI.txt&quot;&gt;此处&lt;/a&gt;找到此文档。</target>
        </trans-unit>
        <trans-unit id="660859d290d769bde079f1e74652268ebbc1b062" translate="yes" xml:space="preserve">
          <source>This attribute indicates that the corresponding function should be compiled as a kernel function, that is an entry point that can be invoked from the host via the HSA runtime library. By default functions are only callable only from other GCN functions.</source>
          <target state="translated">这个属性表示对应的函数应该被编译成内核函数,也就是一个可以通过HSA运行库从主机上调用的入口点。默认情况下,函数只能从其他GCN函数中调用。</target>
        </trans-unit>
        <trans-unit id="f2fad3c190739d8e505c7ea63fef5f7267f258de" translate="yes" xml:space="preserve">
          <source>This attribute indicates that the corresponding function should be compiled as a kernel function, which can be invoked from the host via the CUDA RT library. By default functions are only callable only from other PTX functions.</source>
          <target state="translated">这个属性表示对应的函数应该被编译成内核函数,可以通过CUDA RT库从主机上调用。默认情况下,函数只能从其他PTX函数中调用。</target>
        </trans-unit>
        <trans-unit id="57e17cc8aacf2250a0265d50a2b47adfbfe456c6" translate="yes" xml:space="preserve">
          <source>This attribute is also accepted in C, but it is unnecessary because C does not have constructors or destructors.</source>
          <target state="translated">这个属性在C语言中也是被接受的,但它是不必要的,因为C语言没有构造函数或析构函数。</target>
        </trans-unit>
        <trans-unit id="503a85109e1de0e8ce0564d361fa1038358344dc" translate="yes" xml:space="preserve">
          <source>This attribute is appropriate for types which just represent a value, such as &lt;code&gt;std::string&lt;/code&gt;; it is not appropriate for types which control a resource, such as &lt;code&gt;std::lock_guard&lt;/code&gt;.</source>
          <target state="translated">此属性适用于仅表示值的类型，例如 &lt;code&gt;std::string&lt;/code&gt; ；它不适用于控制资源的类型，例如 &lt;code&gt;std::lock_guard&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ba2d583dcd0ca68ace008c0dc9fbd8ec6f90be8f" translate="yes" xml:space="preserve">
          <source>This attribute is ignored for R8C target.</source>
          <target state="translated">对于R8C目标,此属性被忽略。</target>
        </trans-unit>
        <trans-unit id="34e03794349850af7bdeb66f9a9d6ef490386eec" translate="yes" xml:space="preserve">
          <source>This attribute is implicitly applied to any function named &lt;code&gt;main&lt;/code&gt;, using default parameters.</source>
          <target state="translated">使用默认参数，此属性隐式应用于名为 &lt;code&gt;main&lt;/code&gt; 的任何函数。</target>
        </trans-unit>
        <trans-unit id="d9346f70ea23c21af36c756ae2b79002b57ffa81" translate="yes" xml:space="preserve">
          <source>This attribute is only applicable to integral and floating scalar types. In function declarations the attribute applies to the function return type.</source>
          <target state="translated">这个属性只适用于积分和浮动标量类型。在函数声明中,该属性适用于函数的返回类型。</target>
        </trans-unit>
        <trans-unit id="4d7f394253f35fa8db5ca6f449a44ff4b56ba334" translate="yes" xml:space="preserve">
          <source>This attribute is only applicable to integral and floating scalars, although arrays, pointers, and function return values are allowed in conjunction with this construct.</source>
          <target state="translated">这个属性只适用于积分和浮动标量,尽管数组、指针和函数返回值都允许与这个构造结合使用。</target>
        </trans-unit>
        <trans-unit id="7e555249b47de74e90649b8eebd9bb76b767b366" translate="yes" xml:space="preserve">
          <source>This attribute is supported only for targets that use a uniform default scalar storage order (fortunately, most of them), i.e. targets that store the scalars either all in big-endian or all in little-endian.</source>
          <target state="translated">这个属性只支持那些使用统一的默认标量存储顺序的目标(幸运的是,大多数目标),即那些将标量全部存储在big-endian或全部存储在little-endian的目标。</target>
        </trans-unit>
        <trans-unit id="0c3dbf2eda48cb59aebda306917b7f78672e9f61" translate="yes" xml:space="preserve">
          <source>This attribute is used to modify the IA-64 calling convention by marking all input registers as live at all function exits. This makes it possible to restart a system call after an interrupt without having to save/restore the input registers. This also prevents kernel data from leaking into application code.</source>
          <target state="translated">此属性用于修改IA-64的调用惯例,在所有函数退出时将所有输入寄存器标记为有效。这样就可以在中断后重新启动系统调用,而不必保存/恢复输入寄存器。这也防止了内核数据泄露到应用程序代码中。</target>
        </trans-unit>
        <trans-unit id="b29e16cc249effe80d848bb9db8d32ddaa499113" translate="yes" xml:space="preserve">
          <source>This attribute is useful for small inline wrappers that if possible should appear during debugging as a unit. Depending on the debug info format it either means marking the function as artificial or using the caller location for all instructions within the inlined body.</source>
          <target state="translated">这个属性对于小的内联包装很有用,如果可能的话,这些内联包装应该在调试时作为一个单元出现。根据调试信息的格式,它要么意味着将函数标记为人为的,要么对内联体中的所有指令使用调用者位置。</target>
        </trans-unit>
        <trans-unit id="eebce69b5ee57e7d9f9e53b8f77d9b2143a8f71f" translate="yes" xml:space="preserve">
          <source>This attribute locally overrides the</source>
          <target state="translated">该属性在本地覆盖了</target>
        </trans-unit>
        <trans-unit id="b079e0e5e6910cff82e9ecf2f5a99d46287bccb2" translate="yes" xml:space="preserve">
          <source>This attribute may only be applied to structure types. It indicates that any initialization of an object of this type must use designated initializers rather than positional initializers. The intent of this attribute is to allow the programmer to indicate that a structure&amp;rsquo;s layout may change, and that therefore relying on positional initialization will result in future breakage.</source>
          <target state="translated">此属性只能应用于结构类型。它指示此对象的任何初始化都必须使用指定的初始化程序，而不是位置初始化程序。此属性的目的是允许程序员指示结构的布局可能会更改，因此依赖于位置初始化将导致将来的损坏。</target>
        </trans-unit>
        <trans-unit id="c5c62ef86997f4e170b106b5387843679fbba8d0" translate="yes" xml:space="preserve">
          <source>This attribute modifies the behavior of an interrupt handler. The interrupt handler may be in external memory which cannot be reached by a branch instruction, so generate a local memory trampoline to transfer control. The single parameter identifies the section where the trampoline is placed.</source>
          <target state="translated">该属性修改中断处理程序的行为。中断处理程序可能在外部内存中,分支指令无法到达,所以要生成一个本地内存蹦床来传输控制。单一参数标识了放置蹦床的部分。</target>
        </trans-unit>
        <trans-unit id="effaae1a1a3c582ea4cc6ec90afe0b02dd3b515f" translate="yes" xml:space="preserve">
          <source>This attribute only applies to interrupt functions. It is silently ignored if applied to a non-interrupt function. A wakeup interrupt function will rouse the processor from any low-power state that it might be in when the function exits.</source>
          <target state="translated">这个属性只适用于中断函数。如果应用于非中断函数,则会被默默忽略。当函数退出时,唤醒中断函数将把处理器从任何可能处于的低功耗状态中唤醒。</target>
        </trans-unit>
        <trans-unit id="b26152314a60738ffd8a5e7f3727dd841bf2cfd9" translate="yes" xml:space="preserve">
          <source>This attribute requires assembler and object file support, and may not be available on all targets.</source>
          <target state="translated">这个属性需要汇编器和对象文件的支持,并不是所有目标都能使用。</target>
        </trans-unit>
        <trans-unit id="91b2af80c8a3a275efbd609425500eed5fe647aa" translate="yes" xml:space="preserve">
          <source>This attribute should be used with a function that is also declared with the &lt;code&gt;inline&lt;/code&gt; keyword. It directs GCC to treat the function as if it were defined in gnu90 mode even when compiling in C99 or gnu99 mode.</source>
          <target state="translated">此属性应与也使用 &lt;code&gt;inline&lt;/code&gt; 关键字声明的函数一起使用。即使在C99或gnu99模式下进行编译，它也会指示GCC将功能视为在gnu90模式下定义的功能。</target>
        </trans-unit>
        <trans-unit id="673dc92ba9f751f0e2d252934e26bb46b7e48dac" translate="yes" xml:space="preserve">
          <source>This attribute specifies a function to be placed into L1 Instruction SRAM. The function is put into a specific section named &lt;code&gt;.l1.text&lt;/code&gt;. With</source>
          <target state="translated">该属性指定要放入L1指令SRAM中的功能。该函数放入名为 &lt;code&gt;.l1.text&lt;/code&gt; 的特定节中。用</target>
        </trans-unit>
        <trans-unit id="87042e05584213c1ab77c9f22219578def878d66" translate="yes" xml:space="preserve">
          <source>This attribute specifies a function to be placed into L2 SRAM. The function is put into a specific section named &lt;code&gt;.l2.text&lt;/code&gt;. With</source>
          <target state="translated">此属性指定要放置到L2 SRAM中的功能。该函数放入名为 &lt;code&gt;.l2.text&lt;/code&gt; 的特定节中。用</target>
        </trans-unit>
        <trans-unit id="79629b6015ecde4f64aa5edeebdeed4ca22350b1" translate="yes" xml:space="preserve">
          <source>This attribute specifies a threshold for the structure field, measured in bytes. If the structure field is aligned below the threshold, a warning will be issued. For example, the declaration:</source>
          <target state="translated">这个属性指定了结构域的阈值,以字节为单位。如果结构字段的对齐程度低于阈值,将发出警告。例如,声明:</target>
        </trans-unit>
        <trans-unit id="304795dd4f7d1f35b54a689f0ca428f75b402b8c" translate="yes" xml:space="preserve">
          <source>This attribute specifies the data type for the declaration&amp;mdash;whichever type corresponds to the mode &lt;var&gt;mode&lt;/var&gt;. This in effect lets you request an integer or floating-point type according to its width.</source>
          <target state="translated">此属性指定声明的数据类型-每种类型都对应于mode &lt;var&gt;mode&lt;/var&gt; 。实际上，这使您可以根据其宽度请求整数或浮点类型。</target>
        </trans-unit>
        <trans-unit id="9c9083d141dfccd0e26e0504dbf2c594ddf0afc0" translate="yes" xml:space="preserve">
          <source>This attribute specifies the vector size for the type of the declared variable, measured in bytes. The type to which it applies is known as the &lt;em&gt;base type&lt;/em&gt;. The &lt;var&gt;bytes&lt;/var&gt; argument must be a positive power-of-two multiple of the base type size. For example, the declaration:</source>
          <target state="translated">此属性指定已声明变量类型的向量大小，以字节为单位。它适用于的类型称为&lt;em&gt;基本类型&lt;/em&gt;。的 &lt;var&gt;bytes&lt;/var&gt; 参数必须是一个正电源的两多个基类型的大小。例如，声明：</target>
        </trans-unit>
        <trans-unit id="4812a74afb4965dd971b67251a8e1a47c47bf670" translate="yes" xml:space="preserve">
          <source>This attribute specifies the vector size for the type, measured in bytes. The type to which it applies is known as the &lt;em&gt;base type&lt;/em&gt;. The &lt;var&gt;bytes&lt;/var&gt; argument must be a positive power-of-two multiple of the base type size. For example, the following declarations:</source>
          <target state="translated">此属性指定类型的向量大小，以字节为单位。它适用于的类型称为&lt;em&gt;基本类型&lt;/em&gt;。的 &lt;var&gt;bytes&lt;/var&gt; 参数必须是一个正电源的两多个基类型的大小。例如，以下声明：</target>
        </trans-unit>
        <trans-unit id="721933cb3a33d0b7e6bbaf2079ece1bfb6d52c2e" translate="yes" xml:space="preserve">
          <source>This attribute, attached to a &lt;code&gt;struct&lt;/code&gt;, &lt;code&gt;union&lt;/code&gt;, or C++ &lt;code&gt;class&lt;/code&gt; type definition, specifies that each of its members (other than zero-width bit-fields) is placed to minimize the memory required. This is equivalent to specifying the &lt;code&gt;packed&lt;/code&gt; attribute on each of the members.</source>
          <target state="translated">附加到 &lt;code&gt;struct&lt;/code&gt; ， &lt;code&gt;union&lt;/code&gt; 或C ++ &lt;code&gt;class&lt;/code&gt; 类型定义的此属性指定放置其每个成员（零宽度位域除外）以最小化所需的内存。这等效于在每个成员上指定 &lt;code&gt;packed&lt;/code&gt; 属性。</target>
        </trans-unit>
        <trans-unit id="f26328ece7307f514a47cc876ff83560893a099c" translate="yes" xml:space="preserve">
          <source>This attribute, attached to a &lt;code&gt;union&lt;/code&gt; type definition, indicates that any function parameter having that union type causes calls to that function to be treated in a special way.</source>
          <target state="translated">附加到并 &lt;code&gt;union&lt;/code&gt; 类型定义的此属性表示，具有该并集类型的任何函数参数都将导致以特殊方式处理对该函数的调用。</target>
        </trans-unit>
        <trans-unit id="dea2c8428220fbb29ff9bb397fcc0cd8bc82fcc8" translate="yes" xml:space="preserve">
          <source>This attribute, attached to a function, means that code must be emitted for the function even if it appears that the function is not referenced. This is useful, for example, when the function is referenced only in inline assembly.</source>
          <target state="translated">这个属性,附加在一个函数上,意味着即使函数没有被引用,也必须为该函数发射代码。例如,当函数只在内联汇编中被引用时,这个属性就很有用。</target>
        </trans-unit>
        <trans-unit id="f26a8e83a7c29f151aef9f7d69a0073e42ed7b63" translate="yes" xml:space="preserve">
          <source>This attribute, attached to a function, means that the function is meant to be possibly unused. GCC does not produce a warning for this function.</source>
          <target state="translated">这个属性附加在一个函数上,意味着这个函数可能是未被使用的。GCC不会对该函数产生警告。</target>
        </trans-unit>
        <trans-unit id="0cda8d2a406df80f5c3c1e70abd61657e961b09d" translate="yes" xml:space="preserve">
          <source>This attribute, attached to a global variable or function, nullifies the effect of the</source>
          <target state="translated">这个属性,附加在全局变量或函数上,使全局变量或函数的效果无效。</target>
        </trans-unit>
        <trans-unit id="b693f4e1b31df32d21cd97a87984062ca5cf0e7b" translate="yes" xml:space="preserve">
          <source>This attribute, attached to a variable with static storage, means that the variable must be emitted even if it appears that the variable is not referenced.</source>
          <target state="translated">这个属性,附加在一个具有静态存储的变量上,意味着即使看起来变量没有被引用,也必须发出变量。</target>
        </trans-unit>
        <trans-unit id="09cf2bdd650a42affb72357abc94b2d76134170c" translate="yes" xml:space="preserve">
          <source>This attribute, attached to a variable, means that the variable is meant to be possibly unused. GCC does not produce a warning for this variable.</source>
          <target state="translated">这个属性,附加在一个变量上,意味着这个变量可能是未使用的。GCC不会对这个变量产生警告。</target>
        </trans-unit>
        <trans-unit id="f6a9f3d41b5e82d7b9c83b17f60c49a3dab84962" translate="yes" xml:space="preserve">
          <source>This behavior may seem silly, but it&amp;rsquo;s what the ISO standard specifies. It is easy enough for you to make your code work by moving the definition of &lt;code&gt;struct mumble&lt;/code&gt; above the prototype. It&amp;rsquo;s not worth being incompatible with ISO C just to avoid an error for the example shown above.</source>
          <target state="translated">这种行为似乎很愚蠢，但这是ISO标准指定的。通过将 &lt;code&gt;struct mumble&lt;/code&gt; 的定义移到原型之上，使您的代码正常工作很容易。为了避免上面显示的示例出现错误，与ISO C不兼容是不值得的。</target>
        </trans-unit>
        <trans-unit id="8818c6d89ffa44c89646c897a4e574f7b71484ee" translate="yes" xml:space="preserve">
          <source>This built-in can be used to determine the current transaction state using the following code example:</source>
          <target state="translated">这个内置可以使用下面的代码示例来确定当前的事务状态。</target>
        </trans-unit>
        <trans-unit id="92883b24f84fe55e50f3d20ded0b1b0331344202" translate="yes" xml:space="preserve">
          <source>This built-in function acts as a synchronization fence between a thread and signal handlers based in the same thread.</source>
          <target state="translated">这个内置函数在线程和基于同一线程的信号处理程序之间起到了同步围栏的作用。</target>
        </trans-unit>
        <trans-unit id="5a20473e8d5898eb62d474e73fb635a7caf013c9" translate="yes" xml:space="preserve">
          <source>This built-in function acts as a synchronization fence between threads based on the specified memory order.</source>
          <target state="translated">该内置功能根据指定的内存顺序在线程之间起到同步围栏的作用。</target>
        </trans-unit>
        <trans-unit id="8c179d50784fac3eee427384f1e34f1d0ea28d01" translate="yes" xml:space="preserve">
          <source>This built-in function can be used to help mitigate against unsafe speculative execution. &lt;var&gt;type&lt;/var&gt; may be any integral type or any pointer type.</source>
          <target state="translated">此内置功能可用于帮助缓解不安全的投机执行。 &lt;var&gt;type&lt;/var&gt; 可以是任何整数类型或任何指针类型。</target>
        </trans-unit>
        <trans-unit id="cdfcca8b913445e45652ce81bc13dc531eb31f5a" translate="yes" xml:space="preserve">
          <source>This built-in function can return an lvalue if the chosen argument is an lvalue.</source>
          <target state="translated">如果选择的参数是一个lvalue,这个内置函数可以返回一个lvalue。</target>
        </trans-unit>
        <trans-unit id="42b10a642d35506bdb301b36c3b2dbb7b1a29af0" translate="yes" xml:space="preserve">
          <source>This built-in function ignores top level qualifiers (e.g., &lt;code&gt;const&lt;/code&gt;, &lt;code&gt;volatile&lt;/code&gt;). For example, &lt;code&gt;int&lt;/code&gt; is equivalent to &lt;code&gt;const
int&lt;/code&gt;.</source>
          <target state="translated">此内置函数忽略顶级限定符（例如 &lt;code&gt;const&lt;/code&gt; ， &lt;code&gt;volatile&lt;/code&gt; ）。例如， &lt;code&gt;int&lt;/code&gt; 等同于 &lt;code&gt;const int&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="de3196f175db1b7bf9e191bc879315daa8c8ea4f" translate="yes" xml:space="preserve">
          <source>This built-in function implements an atomic compare and exchange operation. This compares the contents of &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt; with the contents of &lt;code&gt;*&lt;var&gt;expected&lt;/var&gt;&lt;/code&gt;. If equal, the operation is a &lt;em&gt;read-modify-write&lt;/em&gt; operation that writes &lt;var&gt;desired&lt;/var&gt; into &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt;. If they are not equal, the operation is a &lt;em&gt;read&lt;/em&gt; and the current contents of &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt; are written into &lt;code&gt;*&lt;var&gt;expected&lt;/var&gt;&lt;/code&gt;. &lt;var&gt;weak&lt;/var&gt; is &lt;code&gt;true&lt;/code&gt; for weak compare_exchange, which may fail spuriously, and &lt;code&gt;false&lt;/code&gt; for the strong variation, which never fails spuriously. Many targets only offer the strong variation and ignore the parameter. When in doubt, use the strong variation.</source>
          <target state="translated">此内置函数实现了原子比较和交换操作。这会将 &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt; 的内容与 &lt;code&gt;*&lt;var&gt;expected&lt;/var&gt;&lt;/code&gt; 的内容进行比较。如果相等，则该操作是将 &lt;var&gt;desired&lt;/var&gt; 写入 &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt; &lt;var&gt;ptr&lt;/var&gt; 的&lt;em&gt;读-修改-写&lt;/em&gt;操作。如果它们不相等，操作是&lt;em&gt;读取&lt;/em&gt;和当前内容 &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt; &lt;var&gt;ptr&lt;/var&gt; 写入 &lt;code&gt;*&lt;var&gt;expected&lt;/var&gt;&lt;/code&gt; &lt;var&gt;expected&lt;/var&gt; 。 &lt;var&gt;weak&lt;/var&gt; 对弱compare_exchange 是 &lt;code&gt;true&lt;/code&gt; 的，它可能会虚假地失败，而为 &lt;code&gt;false&lt;/code&gt; &lt;em&gt;&lt;/em&gt;对于强大的变化，它永远不会虚假地失败。许多目标仅提供强大的变化，而忽略该参数。如有疑问，请使用较大的变化。</target>
        </trans-unit>
        <trans-unit id="56f42bd96c55f1e604c896fe2e73d0e93c4e17e7" translate="yes" xml:space="preserve">
          <source>This built-in function implements an atomic exchange operation. It writes &lt;var&gt;val&lt;/var&gt; into &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt;, and returns the previous contents of &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt;.</source>
          <target state="translated">此内置函数实现了原子交换操作。它写道： &lt;var&gt;val&lt;/var&gt; 成 &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt; ，并返回以前的内容 &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e39a26f774d21850134f1ad4ec8601fd024a4508" translate="yes" xml:space="preserve">
          <source>This built-in function implements an atomic load operation. It returns the contents of &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt;.</source>
          <target state="translated">此内置函数实现了原子加载操作。它返回 &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt; 的内容。</target>
        </trans-unit>
        <trans-unit id="6b2685600611aa3929789e72b13593b02a524004" translate="yes" xml:space="preserve">
          <source>This built-in function implements an atomic store operation. It writes &lt;code&gt;&lt;var&gt;val&lt;/var&gt;&lt;/code&gt; into &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt;.</source>
          <target state="translated">此内置函数实现了原子存储操作。它将 &lt;code&gt;&lt;var&gt;val&lt;/var&gt;&lt;/code&gt; 写入 &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ea16c3e951ac6e4e93bda6af660c19a372791953" translate="yes" xml:space="preserve">
          <source>This built-in function implements the generic version of &lt;code&gt;__atomic_compare_exchange&lt;/code&gt;. The function is virtually identical to &lt;code&gt;__atomic_compare_exchange_n&lt;/code&gt;, except the desired value is also a pointer.</source>
          <target state="translated">此内置函数实现了 &lt;code&gt;__atomic_compare_exchange&lt;/code&gt; 的通用版本。该函数实际上与 &lt;code&gt;__atomic_compare_exchange_n&lt;/code&gt; 相同，除了所需的值也是指针。</target>
        </trans-unit>
        <trans-unit id="8296c6507414677ec38273521ab8df96daa500be" translate="yes" xml:space="preserve">
          <source>This built-in function invokes &lt;var&gt;function&lt;/var&gt; with a copy of the parameters described by &lt;var&gt;arguments&lt;/var&gt; and &lt;var&gt;size&lt;/var&gt;.</source>
          <target state="translated">此内置 &lt;var&gt;function&lt;/var&gt; 使用由 &lt;var&gt;arguments&lt;/var&gt; 和 &lt;var&gt;size&lt;/var&gt; 描述的参数副本来调用函数。</target>
        </trans-unit>
        <trans-unit id="8f5c4780f25bedcea7655683b3a1f0ac5e0f5ed0" translate="yes" xml:space="preserve">
          <source>This built-in function is analogous to the &amp;lsquo;</source>
          <target state="translated">此内置功能类似于&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="6e1bff7892551ba3b77dbb599f93fb2a84f960cc" translate="yes" xml:space="preserve">
          <source>This built-in function is not a full barrier, but rather a &lt;em&gt;release barrier&lt;/em&gt;. This means that all previous memory stores are globally visible, and all previous memory loads have been satisfied, but following memory reads are not prevented from being speculated to before the barrier.</source>
          <target state="translated">此内置功能不是完全障碍，而是&lt;em&gt;释放障碍&lt;/em&gt;。这意味着所有先前的存储器存储都是全局可见的，并且已满足所有先前的存储器负载，但是并不能防止随后的存储器读取被推测为在屏障之前。</target>
        </trans-unit>
        <trans-unit id="d70719484366a8b3c252ddc3ff84790bc06cc3ad" translate="yes" xml:space="preserve">
          <source>This built-in function is not a full barrier, but rather an &lt;em&gt;acquire barrier&lt;/em&gt;. This means that references after the operation cannot move to (or be speculated to) before the operation, but previous memory stores may not be globally visible yet, and previous memory loads may not yet be satisfied.</source>
          <target state="translated">此内置功能不是完全障碍，而是&lt;em&gt;获取障碍&lt;/em&gt;。这意味着在操作之后的引用不能移动到（或推测为）在操作之前，但是先前的存储器存储可能尚未全局可见，并且先前的存储器负载可能尚未得到满足。</target>
        </trans-unit>
        <trans-unit id="073757ac658ed7f6a9f1d03295b93f00125aefcc" translate="yes" xml:space="preserve">
          <source>This built-in function issues a full memory barrier.</source>
          <target state="translated">这个内置功能会发出一个完整的内存屏障。</target>
        </trans-unit>
        <trans-unit id="7e033b3b4f9c857696bc2244ed32f0a7d140cd57" translate="yes" xml:space="preserve">
          <source>This built-in function performs an atomic clear operation on &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt;. After the operation, &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt; contains 0. It should be only used for operands of type &lt;code&gt;bool&lt;/code&gt; or &lt;code&gt;char&lt;/code&gt; and in conjunction with &lt;code&gt;__atomic_test_and_set&lt;/code&gt;. For other types it may only clear partially. If the type is not &lt;code&gt;bool&lt;/code&gt; prefer using &lt;code&gt;__atomic_store&lt;/code&gt;.</source>
          <target state="translated">此内置函数对 &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt; 执行原子清除操作。运算后， &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt; 包含0。它仅应用于 &lt;code&gt;bool&lt;/code&gt; 或 &lt;code&gt;char&lt;/code&gt; 类型的操作数，并应与 &lt;code&gt;__atomic_test_and_set&lt;/code&gt; 结合使用。对于其他类型，可能仅部分清除。如果类型不是 &lt;code&gt;bool&lt;/code&gt; 类型，则首选使用 &lt;code&gt;__atomic_store&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b9c97edabae382ebead73a4652d8d69259efed11" translate="yes" xml:space="preserve">
          <source>This built-in function performs an atomic test-and-set operation on the byte at &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt;. The byte is set to some implementation defined nonzero &amp;ldquo;set&amp;rdquo; value and the return value is &lt;code&gt;true&lt;/code&gt; if and only if the previous contents were &amp;ldquo;set&amp;rdquo;. It should be only used for operands of type &lt;code&gt;bool&lt;/code&gt; or &lt;code&gt;char&lt;/code&gt;. For other types only part of the value may be set.</source>
          <target state="translated">此内置函数对 &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt; 处的字节执行原子测试和设置操作。该字节被设置为某些实现定义的非零&amp;ldquo;设置&amp;rdquo;值，并且仅当先前的内容被&amp;ldquo;设置&amp;rdquo;时，返回值才为 &lt;code&gt;true&lt;/code&gt; 。它仅应用于 &lt;code&gt;bool&lt;/code&gt; 或 &lt;code&gt;char&lt;/code&gt; 类型的操作数。对于其他类型，只能设置部分值。</target>
        </trans-unit>
        <trans-unit id="b288561de8012f0a5e9cadf66cc0631f6c354855" translate="yes" xml:space="preserve">
          <source>This built-in function releases the lock acquired by &lt;code&gt;__sync_lock_test_and_set&lt;/code&gt;. Normally this means writing the constant 0 to &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt;.</source>
          <target state="translated">此内置函数释放 &lt;code&gt;__sync_lock_test_and_set&lt;/code&gt; 获取的锁。通常，这意味着将常数0写入 &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6fbd055aee266ab03001d14151e03de46793e79e" translate="yes" xml:space="preserve">
          <source>This built-in function represents all anonymous arguments of an inline function. It can be used only in inline functions that are always inlined, never compiled as a separate function, such as those using &lt;code&gt;__attribute__ ((__always_inline__))&lt;/code&gt; or &lt;code&gt;__attribute__ ((__gnu_inline__))&lt;/code&gt; extern inline functions. It must be only passed as last argument to some other function with variable arguments. This is useful for writing small wrapper inlines for variable argument functions, when using preprocessor macros is undesirable. For example:</source>
          <target state="translated">此内置函数表示内联函数的所有匿名参数。它只能在始终内联的内联函数中使用，绝不能编译为单独的函数，例如使用 &lt;code&gt;__attribute__ ((__always_inline__))&lt;/code&gt; 或 &lt;code&gt;__attribute__ ((__gnu_inline__))&lt;/code&gt; 外部内联函数的函数。它只能作为最后一个参数传递给带有可变参数的其他函数。当不希望使用预处理器宏时，这对于为变量参数函数编写小型包装器内联很有用。例如：</target>
        </trans-unit>
        <trans-unit id="a645e8bd97d4c4a4974b86fe42f50e43f5945898" translate="yes" xml:space="preserve">
          <source>This built-in function returns 1 if the unqualified versions of the types &lt;var&gt;type1&lt;/var&gt; and &lt;var&gt;type2&lt;/var&gt; (which are types, not expressions) are compatible, 0 otherwise. The result of this built-in function can be used in integer constant expressions.</source>
          <target state="translated">如果类型 &lt;var&gt;type1&lt;/var&gt; 和 &lt;var&gt;type2&lt;/var&gt; 的非限定版本（它们是类型，不是表达式）兼容，则此内置函数返回1，否则返回0。此内置函数的结果可用于整数常量表达式。</target>
        </trans-unit>
        <trans-unit id="adfe1d809ee98496092f61c8ed5ff01343455bef" translate="yes" xml:space="preserve">
          <source>This built-in function returns &lt;code&gt;true&lt;/code&gt; if objects of &lt;var&gt;size&lt;/var&gt; bytes always generate lock-free atomic instructions for the target architecture. &lt;var&gt;size&lt;/var&gt; must resolve to a compile-time constant and the result also resolves to a compile-time constant.</source>
          <target state="translated">如果 &lt;var&gt;size&lt;/var&gt; 字节的对象始终为目标体系结构生成无锁原子指令，则此内置函数将返回 &lt;code&gt;true&lt;/code&gt; 。 &lt;var&gt;size&lt;/var&gt; 必须解析为编译时常量，并且结果也解析为编译时常量。</target>
        </trans-unit>
        <trans-unit id="81bd1267444e0c22cd6d3d40974c7c8c9aa88d05" translate="yes" xml:space="preserve">
          <source>This built-in function returns &lt;code&gt;true&lt;/code&gt; if objects of &lt;var&gt;size&lt;/var&gt; bytes always generate lock-free atomic instructions for the target architecture. If the built-in function is not known to be lock-free, a call is made to a runtime routine named &lt;code&gt;__atomic_is_lock_free&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;var&gt;size&lt;/var&gt; 字节的对象始终为目标体系结构生成无锁原子指令，则此内置函数将返回 &lt;code&gt;true&lt;/code&gt; 。如果不知道内置函数是无锁的，则调用名为 &lt;code&gt;__atomic_is_lock_free&lt;/code&gt; 的运行时例程。</target>
        </trans-unit>
        <trans-unit id="7c6d5e134400518a60b0f022ce70bc3a88ebfc9d" translate="yes" xml:space="preserve">
          <source>This built-in function returns a pointer to data describing how to perform a call with the same arguments as are passed to the current function.</source>
          <target state="translated">这个内置函数返回一个指针,指向描述如何执行与传递给当前函数的参数相同的调用的数据。</target>
        </trans-unit>
        <trans-unit id="a965c005ba35ec687e9a6eef5b255a00ddffc5d3" translate="yes" xml:space="preserve">
          <source>This built-in function returns the number of anonymous arguments of an inline function. It can be used only in inline functions that are always inlined, never compiled as a separate function, such as those using &lt;code&gt;__attribute__ ((__always_inline__))&lt;/code&gt; or &lt;code&gt;__attribute__ ((__gnu_inline__))&lt;/code&gt; extern inline functions. For example following does link- or run-time checking of open arguments for optimized code:</source>
          <target state="translated">此内置函数返回内联函数的匿名参数的数量。它只能在始终内联的内联函数中使用，绝不能编译为单独的函数，例如使用 &lt;code&gt;__attribute__ ((__always_inline__))&lt;/code&gt; 或 &lt;code&gt;__attribute__ ((__gnu_inline__))&lt;/code&gt; 外部内联函数的函数。例如，以下对优化代码的打开参数进行链接或运行时检查：</target>
        </trans-unit>
        <trans-unit id="23a152f3eb0d609efeaccc0dfd600b3f1ca33a36" translate="yes" xml:space="preserve">
          <source>This built-in function returns the value described by &lt;var&gt;result&lt;/var&gt; from the containing function. You should specify, for &lt;var&gt;result&lt;/var&gt;, a value returned by &lt;code&gt;__builtin_apply&lt;/code&gt;.</source>
          <target state="translated">该内置函数返回包含函数的 &lt;var&gt;result&lt;/var&gt; 描述的值。对于 &lt;var&gt;result&lt;/var&gt; ，您应该指定 &lt;code&gt;__builtin_apply&lt;/code&gt; 返回的值。</target>
        </trans-unit>
        <trans-unit id="93f8e4f9c5ee35c6668a2b80b5a01f58cf7b3cac" translate="yes" xml:space="preserve">
          <source>This built-in function, as described by Intel, is not a traditional test-and-set operation, but rather an atomic exchange operation. It writes &lt;var&gt;value&lt;/var&gt; into &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt;, and returns the previous contents of &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt;.</source>
          <target state="translated">如Intel所述，此内置功能不是传统的测试设置操作，而是原子交换操作。它写入 &lt;var&gt;value&lt;/var&gt; 到 &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt; ，并返回以前的内容 &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="568a9d62c8cf52e8d6dd28fe3fede9225dfafd5c" translate="yes" xml:space="preserve">
          <source>This built-in implements the C99 fpclassify functionality. The first five int arguments should be the target library&amp;rsquo;s notion of the possible FP classes and are used for return values. They must be constant values and they must appear in this order: &lt;code&gt;FP_NAN&lt;/code&gt;, &lt;code&gt;FP_INFINITE&lt;/code&gt;, &lt;code&gt;FP_NORMAL&lt;/code&gt;, &lt;code&gt;FP_SUBNORMAL&lt;/code&gt; and &lt;code&gt;FP_ZERO&lt;/code&gt;. The ellipsis is for exactly one floating-point value to classify. GCC treats the last argument as type-generic, which means it does not do default promotion from float to double.</source>
          <target state="translated">此内置实现C99 fpclassify功能。前五个int参数应该是目标库对可能的FP类的概念，并用于返回值。它们必须是常数，并且必须按以下顺序显示： &lt;code&gt;FP_NAN&lt;/code&gt; ， &lt;code&gt;FP_INFINITE&lt;/code&gt; ， &lt;code&gt;FP_NORMAL&lt;/code&gt; ， &lt;code&gt;FP_SUBNORMAL&lt;/code&gt; 和 &lt;code&gt;FP_ZERO&lt;/code&gt; 。省略号仅用于分类一个浮点值。 GCC将最后一个参数视为泛型，这意味着它不会将默认值从float提升为double。</target>
        </trans-unit>
        <trans-unit id="de56bb64bcd269982e143b48fca7664ac4ccd934" translate="yes" xml:space="preserve">
          <source>This built-in takes a byte address to the 24-bit &lt;a href=&quot;named-address-spaces#AVR-Named-Address-Spaces&quot;&gt;address space&lt;/a&gt;&lt;code&gt;__memx&lt;/code&gt; and returns the number of the flash segment (the 64 KiB chunk) where the address points to. Counting starts at &lt;code&gt;0&lt;/code&gt;. If the address does not point to flash memory, return &lt;code&gt;-1&lt;/code&gt;.</source>
          <target state="translated">这个内置 &lt;code&gt;__memx&lt;/code&gt; 将一个字节地址带到24位&lt;a href=&quot;named-address-spaces#AVR-Named-Address-Spaces&quot;&gt;地址空间&lt;/a&gt;__memx中，并返回该地址指向的Flash段的编号（64 KiB块）。计数从 &lt;code&gt;0&lt;/code&gt; 开始。如果该地址未指向闪存，则返回 &lt;code&gt;-1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="12afcfe5b0cb2421e366cb4bf6d262a7225b43e1" translate="yes" xml:space="preserve">
          <source>This calling convention is incompatible with the one normally used on Unix, so you cannot use it if you need to call libraries compiled with the Unix compiler.</source>
          <target state="translated">这个调用约定与Unix上通常使用的约定不兼容,所以如果你需要调用用Unix编译器编译的库,就不能使用它。</target>
        </trans-unit>
        <trans-unit id="c59930047a3dbe1a0da0d3c55b5832603831020b" translate="yes" xml:space="preserve">
          <source>This can be a suitable option for application code written for the Borland model, as it usually just works. Code written for the Cfront model needs to be modified so that the template definitions are available at one or more points of instantiation; usually this is as simple as adding &lt;code&gt;#include &amp;lt;tmethods.cc&amp;gt;&lt;/code&gt; to the end of each template header.</source>
          <target state="translated">对于通常为Borland模型编写的应用程序代码，这可能是一个合适的选择。需要修改为Cfront模型编写的代码，以便可以在一个或多个实例化点使用模板定义。通常，这就像在每个模板头的末尾添加 &lt;code&gt;#include &amp;lt;tmethods.cc&amp;gt;&lt;/code&gt; 一样简单。</target>
        </trans-unit>
        <trans-unit id="8138fe5070f142675bd6f047c11ca6604b5e4b89" translate="yes" xml:space="preserve">
          <source>This causes GCC&amp;rsquo;s output file to have the &amp;lsquo;</source>
          <target state="translated">这会导致GCC的输出文件具有&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="0b096441ddb3f545a4e7491763e07ff42aa42c7a" translate="yes" xml:space="preserve">
          <source>This causes an error messages saying:</source>
          <target state="translated">这就会导致错误信息说。</target>
        </trans-unit>
        <trans-unit id="37b13c019e57e81567c1e4f0f77d055f628a1482" translate="yes" xml:space="preserve">
          <source>This clears the indicated bits in the saved copy of the status register currently residing on the stack. This only works inside interrupt handlers and the changes to the status register will only take affect once the handler returns.</source>
          <target state="translated">这将清除当前保存在堆栈上的状态寄存器副本中的指定位。这只在中断处理程序中起作用,对状态寄存器的改变只有在处理程序返回后才会生效。</target>
        </trans-unit>
        <trans-unit id="52348806f9132146a3d5c83435b59d49467218d2" translate="yes" xml:space="preserve">
          <source>This code copies &lt;code&gt;src&lt;/code&gt; to &lt;code&gt;dst&lt;/code&gt; and add 1 to &lt;code&gt;dst&lt;/code&gt;.</source>
          <target state="translated">此代码将 &lt;code&gt;src&lt;/code&gt; 复制到 &lt;code&gt;dst&lt;/code&gt; ，并将1加到 &lt;code&gt;dst&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5a1cd197f5f5bea21b21e4898acbd5a40235dc12" translate="yes" xml:space="preserve">
          <source>This code makes no use of the optional &lt;var&gt;asmSymbolicName&lt;/var&gt;. Therefore it references the first output operand as &lt;code&gt;%0&lt;/code&gt; (were there a second, it would be &lt;code&gt;%1&lt;/code&gt;, etc). The number of the first input operand is one greater than that of the last output operand. In this i386 example, that makes &lt;code&gt;Mask&lt;/code&gt; referenced as &lt;code&gt;%1&lt;/code&gt;:</source>
          <target state="translated">此代码不使用可选的 &lt;var&gt;asmSymbolicName&lt;/var&gt; 。因此，它将第一个输出操作数引用为 &lt;code&gt;%0&lt;/code&gt; （如果有第二个，则为 &lt;code&gt;%1&lt;/code&gt; 等）。第一个输入操作数的数量比最后一个输出操作数的数量大一个。在此i386示例中，将 &lt;code&gt;Mask&lt;/code&gt; 引用为 &lt;code&gt;%1&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="f9f2247acfc64bac06fade1fb9f20f85e4652f3a" translate="yes" xml:space="preserve">
          <source>This code really is erroneous, because the scope of &lt;code&gt;struct
mumble&lt;/code&gt; in the prototype is limited to the argument list containing it. It does not refer to the &lt;code&gt;struct mumble&lt;/code&gt; defined with file scope immediately below&amp;mdash;they are two unrelated types with similar names in different scopes.</source>
          <target state="translated">这段代码确实是错误的，因为原型中的 &lt;code&gt;struct mumble&lt;/code&gt; 范围仅限于包含它的参数列表。它没有引用紧接在下面的文件作用域定义的 &lt;code&gt;struct mumble&lt;/code&gt; ，它们是两个不相关的类型，在不同的作用域中具有相似的名称。</target>
        </trans-unit>
        <trans-unit id="337163816650f5c7db30e6d4ef7d7194c7c7dcdf" translate="yes" xml:space="preserve">
          <source>This code runs unconditionally on all 64-bit processors. For 32-bit processors the code runs on those that support multi-byte NOP instructions.</source>
          <target state="translated">这段代码无条件地运行在所有64位处理器上。对于32位处理器,该代码在支持多字节NOP指令的处理器上运行。</target>
        </trans-unit>
        <trans-unit id="5f60ecfa36c1d209e897848d1465d421ffe66fd4" translate="yes" xml:space="preserve">
          <source>This code says that input &lt;code&gt;b&lt;/code&gt; is not popped by the &lt;code&gt;asm&lt;/code&gt;, and that the &lt;code&gt;asm&lt;/code&gt; pushes a result onto the reg-stack, i.e., the stack is one deeper after the &lt;code&gt;asm&lt;/code&gt; than it was before. But, it is possible that reload may think that it can use the same register for both the input and the output.</source>
          <target state="translated">该代码表明，输入 &lt;code&gt;b&lt;/code&gt; 不会被 &lt;code&gt;asm&lt;/code&gt; 弹出，并且 &lt;code&gt;asm&lt;/code&gt; 将结果压入reg堆栈，即，在 &lt;code&gt;asm&lt;/code&gt; 之后的堆栈比以前的堆栈深一个。但是，重载可能会认为它可以将相同的寄存器用于输入和输出。</target>
        </trans-unit>
        <trans-unit id="5158b0e232baa68e812ae0b3c5ff1e7b6dd2495a" translate="yes" xml:space="preserve">
          <source>This combination of &lt;code&gt;inline&lt;/code&gt; and &lt;code&gt;extern&lt;/code&gt; has almost the effect of a macro. The way to use it is to put a function definition in a header file with these keywords, and put another copy of the definition (lacking &lt;code&gt;inline&lt;/code&gt; and &lt;code&gt;extern&lt;/code&gt;) in a library file. The definition in the header file causes most calls to the function to be inlined. If any uses of the function remain, they refer to the single copy in the library.</source>
          <target state="translated">&lt;code&gt;inline&lt;/code&gt; 和 &lt;code&gt;extern&lt;/code&gt; 这种组合几乎具有宏的作用。使用它的方法是使用这些关键字将函数定义放入头文件中，并将定义的另一个副本（缺少 &lt;code&gt;inline&lt;/code&gt; 和 &lt;code&gt;extern&lt;/code&gt; ）放入库文件中。头文件中的定义导致对函数的大多数调用被内联。如果仍然使用该功能，则它们引用库中的单个副本。</target>
        </trans-unit>
        <trans-unit id="b81343c69409df406d64f943e849b1b69e1c3338" translate="yes" xml:space="preserve">
          <source>This construct outputs &lt;code&gt;dialect0&lt;/code&gt; when using dialect #0 to compile the code, &lt;code&gt;dialect1&lt;/code&gt; for dialect #1, etc. If there are fewer alternatives within the braces than the number of dialects the compiler supports, the construct outputs nothing.</source>
          <target state="translated">该构建输出 &lt;code&gt;dialect0&lt;/code&gt; 使用方言＃0到编译代码，当 &lt;code&gt;dialect1&lt;/code&gt; 如果在括号比方言编译器支持，所述构建体输出无关的数量之内较少的替代品方言＃1，等等。</target>
        </trans-unit>
        <trans-unit id="4418d19029db54262a2982d0fc11517ca360b079" translate="yes" xml:space="preserve">
          <source>This could also be written using a statement expression:</source>
          <target state="translated">这也可以用语句表达式来写。</target>
        </trans-unit>
        <trans-unit id="d3561933d5b27303ad0b1eed1db35f7bce90fa0b" translate="yes" xml:space="preserve">
          <source>This declaration only establishes that the class &lt;code&gt;Foo&lt;/code&gt; has an &lt;code&gt;int&lt;/code&gt; named &lt;code&gt;Foo::bar&lt;/code&gt;, and a member function named &lt;code&gt;Foo::method&lt;/code&gt;. But you still need to define &lt;em&gt;both&lt;/em&gt;&lt;code&gt;method&lt;/code&gt; and &lt;code&gt;bar&lt;/code&gt; elsewhere. According to the ISO standard, you must supply an initializer in one (and only one) source file, such as:</source>
          <target state="translated">该声明仅确定类 &lt;code&gt;Foo&lt;/code&gt; 具有一个名为 &lt;code&gt;Foo::bar&lt;/code&gt; 的 &lt;code&gt;int&lt;/code&gt; 以及一个名为 &lt;code&gt;Foo::method&lt;/code&gt; 的成员函数。但你仍然需要定义&lt;em&gt;两种&lt;/em&gt; &lt;code&gt;method&lt;/code&gt; ，并 &lt;code&gt;bar&lt;/code&gt; 其他地方。根据ISO标准，您必须在一个（只有一个）源文件中提供一个初始化程序，例如：&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="aa5d48aae2a8d70a04aa98c11ed292ce987fe6e4" translate="yes" xml:space="preserve">
          <source>This declares &lt;code&gt;y&lt;/code&gt; as an array of pointers to characters:</source>
          <target state="translated">这将 &lt;code&gt;y&lt;/code&gt; 声明为指向字符的指针数组：</target>
        </trans-unit>
        <trans-unit id="d5984e00c4ab800b89abb234fbcf6672036013a3" translate="yes" xml:space="preserve">
          <source>This declares &lt;code&gt;y&lt;/code&gt; as an array of such values.</source>
          <target state="translated">这将 &lt;code&gt;y&lt;/code&gt; 声明为此类值的数组。</target>
        </trans-unit>
        <trans-unit id="1cddb3ab7751ac13216d638e5a732f674e3c8eeb" translate="yes" xml:space="preserve">
          <source>This declares &lt;code&gt;y&lt;/code&gt; with the type of what &lt;code&gt;x&lt;/code&gt; points to.</source>
          <target state="translated">这用 &lt;code&gt;x&lt;/code&gt; 指向的类型声明 &lt;code&gt;y&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="faab4d37a48d574a707b33549eb07bcf03d70747" translate="yes" xml:space="preserve">
          <source>This deduction was implemented as a possible extension to the originally proposed semantics for the C++11 standard, but was not part of the final standard, so it is disabled by default. This option is deprecated, and may be removed in a future version of G++.</source>
          <target state="translated">这个推论是作为最初提出的C++11标准的语义的可能扩展而实现的,但并不是最终标准的一部分,所以默认情况下是禁用的。这个选项已被废弃,可能会在未来的G++版本中被删除。</target>
        </trans-unit>
        <trans-unit id="c879d3e8cb77a4fc10b608d3eb2285203202e61b" translate="yes" xml:space="preserve">
          <source>This defaults to &amp;lsquo;</source>
          <target state="translated">默认为&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="951c7938f85853a27d5c7d2c75acbe672c4155a1" translate="yes" xml:space="preserve">
          <source>This diagnostic warns for paths through the code in which &lt;code&gt;free&lt;/code&gt; is called on a non-heap pointer (e.g. an on-stack buffer, or a global).</source>
          <target state="translated">该诊断警告通过非堆指针（例如，堆栈缓冲区或全局缓冲区）上调用 &lt;code&gt;free&lt;/code&gt; 的代码的路径。</target>
        </trans-unit>
        <trans-unit id="6a1c5da5f3c1afd18968f173e07657e7302351a3" translate="yes" xml:space="preserve">
          <source>This diagnostic warns for paths through the code in which &lt;code&gt;longjmp&lt;/code&gt; is called to rewind to a &lt;code&gt;jmp_buf&lt;/code&gt; relating to a &lt;code&gt;setjmp&lt;/code&gt; call in a function that has returned.</source>
          <target state="translated">此诊断警告通过调用 &lt;code&gt;longjmp&lt;/code&gt; 的代码中的路径回 &lt;code&gt;jmp_buf&lt;/code&gt; 与返回的函数中的 &lt;code&gt;setjmp&lt;/code&gt; 调用有关的jmp_buf。</target>
        </trans-unit>
        <trans-unit id="ac21f5dcf2d09b0cae014f784d56a15b158edf70" translate="yes" xml:space="preserve">
          <source>This diagnostic warns for paths through the code in which a &lt;code&gt;&amp;lt;stdio.h&amp;gt;&lt;/code&gt;&lt;code&gt;FILE *&lt;/code&gt; stream object is leaked.</source>
          <target state="translated">此诊断警告通过 &lt;code&gt;&amp;lt;stdio.h&amp;gt;&lt;/code&gt; &lt;code&gt;FILE *&lt;/code&gt; 流对象泄漏的代码的路径。</target>
        </trans-unit>
        <trans-unit id="0839228138ef335cef6fd42894f9d1b11c2d55f0" translate="yes" xml:space="preserve">
          <source>This diagnostic warns for paths through the code in which a &lt;code&gt;FILE *&lt;/code&gt; can have &lt;code&gt;fclose&lt;/code&gt; called on it more than once.</source>
          <target state="translated">此诊断警告通过 &lt;code&gt;FILE *&lt;/code&gt; 可以多次调用 &lt;code&gt;fclose&lt;/code&gt; 的代码的路径。</target>
        </trans-unit>
        <trans-unit id="69065a1147c573eab2950f6087ec4e566a67c9a6" translate="yes" xml:space="preserve">
          <source>This diagnostic warns for paths through the code in which a function known to be async-signal-unsafe (such as &lt;code&gt;fprintf&lt;/code&gt;) is called from a signal handler.</source>
          <target state="translated">该诊断警告通过代码的路径，其中从信号处理程序中调用了已知为异步信号不安全的函数（例如 &lt;code&gt;fprintf&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="21154539e36b0472f9191b1b593654ca89275a98" translate="yes" xml:space="preserve">
          <source>This diagnostic warns for paths through the code in which a pointer allocated via &lt;code&gt;malloc&lt;/code&gt; is leaked.</source>
          <target state="translated">该诊断警告通过代码的路径，其中通过 &lt;code&gt;malloc&lt;/code&gt; 分配的指针泄漏了。</target>
        </trans-unit>
        <trans-unit id="11378cc6703dc8c65838b338e0ff6edde259a680" translate="yes" xml:space="preserve">
          <source>This diagnostic warns for paths through the code in which a pointer can have &lt;code&gt;free&lt;/code&gt; called on it more than once.</source>
          <target state="translated">该诊断警告通过代码的路径，在该路径中指针可以多次调用 &lt;code&gt;free&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8f9dc818bd4f109cde1dcf9e6dc005ab06fd45c6" translate="yes" xml:space="preserve">
          <source>This diagnostic warns for paths through the code in which a pointer is dereferenced that points to a variable in a stale stack frame.</source>
          <target state="translated">该诊断警告代码中的指针被取消引用的路径,该路径指向堆栈框架中的一个变量。</target>
        </trans-unit>
        <trans-unit id="4ec5073148ee9d8b883f3325ddcb7fb0c4d813dc" translate="yes" xml:space="preserve">
          <source>This diagnostic warns for paths through the code in which a pointer is used after &lt;code&gt;free&lt;/code&gt; is called on it.</source>
          <target state="translated">此诊断警告在代码上的路径，其中调用了 &lt;code&gt;free&lt;/code&gt; 之后将在其中使用指针。</target>
        </trans-unit>
        <trans-unit id="fad14ca24b0d656f13db98b7bf5a30df3b6adb8e" translate="yes" xml:space="preserve">
          <source>This diagnostic warns for paths through the code in which a possibly-NULL value is dereferenced.</source>
          <target state="translated">该诊断对代码中可能存在NULL值的路径发出警告。</target>
        </trans-unit>
        <trans-unit id="f2a9ffda1fede774b63029feba567cccbb607842" translate="yes" xml:space="preserve">
          <source>This diagnostic warns for paths through the code in which a possibly-NULL value is passed to a function argument marked with &lt;code&gt;__attribute__((nonnull))&lt;/code&gt; as requiring a non-NULL value.</source>
          <target state="translated">该诊断警告通过代码的路径，其中将可能为NULL的值传递给标有 &lt;code&gt;__attribute__((nonnull))&lt;/code&gt; 的函数自变量，要求使用非NULL值。</target>
        </trans-unit>
        <trans-unit id="e828b08ddbeb8b76319f7c2f75bb782a082fba40" translate="yes" xml:space="preserve">
          <source>This diagnostic warns for paths through the code in which a security-sensitive value is written to an output file (such as writing a password to a log file).</source>
          <target state="translated">该诊断对代码中写入安全敏感值到输出文件的路径发出警告(例如向日志文件写入密码)。</target>
        </trans-unit>
        <trans-unit id="3e36f8c84c0a1d9f61a3991f2dd1bc00f7fd261b" translate="yes" xml:space="preserve">
          <source>This diagnostic warns for paths through the code in which a value known to be NULL is dereferenced.</source>
          <target state="translated">该诊断对代码中一个已知为NULL的值被取消引用的路径发出警告。</target>
        </trans-unit>
        <trans-unit id="409bd5dd675e6fd0250a68f96b1c476f5f6aaaac" translate="yes" xml:space="preserve">
          <source>This diagnostic warns for paths through the code in which a value known to be NULL is passed to a function argument marked with &lt;code&gt;__attribute__((nonnull))&lt;/code&gt; as requiring a non-NULL value.</source>
          <target state="translated">此诊断警告通过代码的路径，其中将已知为NULL的值传递给标有 &lt;code&gt;__attribute__((nonnull))&lt;/code&gt; 的函数自变量，要求使用非NULL值。</target>
        </trans-unit>
        <trans-unit id="3abf773f1e1f311cc5692173d305b2448d2aae95" translate="yes" xml:space="preserve">
          <source>This diagnostic warns for paths through the code in which a value that could be under an attacker&amp;rsquo;s control is used as the index of an array access without being sanitized.</source>
          <target state="translated">该诊断警告通过代码的路径，其中可能受到攻击者控制的值被用作数组访问的索引，而没有被清除。</target>
        </trans-unit>
        <trans-unit id="f436df92076512b77fe92317bd65f3d39a6a1f34" translate="yes" xml:space="preserve">
          <source>This distinction between lookup of dependent and non-dependent names is called two-stage (or dependent) name lookup. G++ implements it since version 3.4.</source>
          <target state="translated">这种对从属名和非从属名的查找的区分称为两阶段(或从属)名查找。G++从3.4版本开始就实现了这一点。</target>
        </trans-unit>
        <trans-unit id="995cd6d9a17d418485ea5c0854d97ede3bab24ec" translate="yes" xml:space="preserve">
          <source>This document is meant to describe some of the GNU Objective-C features. It is not intended to teach you Objective-C. There are several resources on the Internet that present the language.</source>
          <target state="translated">本文档旨在描述GNU Objective-C的一些特性。它并不是要教你如何使用Objective-C。在互联网上有一些资源可以介绍这门语言。</target>
        </trans-unit>
        <trans-unit id="bdd119f74d4b60b69c880f2448f8e713a89672c3" translate="yes" xml:space="preserve">
          <source>This enables</source>
          <target state="translated">这使得</target>
        </trans-unit>
        <trans-unit id="0e09a1e0e5fd69eecab75ac51a34aa77d0b56b77" translate="yes" xml:space="preserve">
          <source>This enables all the warnings about constructions that some users consider questionable, and that are easy to avoid (or modify to prevent the warning), even in conjunction with macros. This also enables some language-specific warnings described in &lt;a href=&quot;c_002b_002b-dialect-options#C_002b_002b-Dialect-Options&quot;&gt;C++ Dialect Options&lt;/a&gt; and &lt;a href=&quot;objective_002dc-and-objective_002dc_002b_002b-dialect-options#Objective_002dC-and-Objective_002dC_002b_002b-Dialect-Options&quot;&gt;Objective-C and Objective-C++ Dialect Options&lt;/a&gt;.</source>
          <target state="translated">这样就可以启用所有有关某些用户认为可疑的构造的警告，即使与宏结合使用，也很容易避免（或进行修改以防止出现警告）。这还启用了某些特定于语言的警告，这些警告在&lt;a href=&quot;c_002b_002b-dialect-options#C_002b_002b-Dialect-Options&quot;&gt;C ++语言选项&lt;/a&gt;和&lt;a href=&quot;objective_002dc-and-objective_002dc_002b_002b-dialect-options#Objective_002dC-and-Objective_002dC_002b_002b-Dialect-Options&quot;&gt;Objective-C和Objective-C ++语言选项中进行了描述&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="10c0c908290715ca8a4902d77d9d099c7818ae8f" translate="yes" xml:space="preserve">
          <source>This enables some extra warning flags that are not enabled by</source>
          <target state="translated">这将启用一些额外的警告标志,而这些标志不是由</target>
        </trans-unit>
        <trans-unit id="b7f682e7e0e71202769284a5f29ad044bc452f34" translate="yes" xml:space="preserve">
          <source>This enables use of the locked load/store conditional extension to implement atomic memory built-in functions. Not available for ARC 6xx or ARC EM cores.</source>
          <target state="translated">这使得可以使用锁定的加载/存储条件扩展来实现原子内存内置功能。不适用于ARC 6xx或ARC EM内核。</target>
        </trans-unit>
        <trans-unit id="c5419693b2d5b267f6af681a001ebef359580125" translate="yes" xml:space="preserve">
          <source>This example assigns a function to two slots in the default table (using preprocessor macros defined elsewhere) and makes it the default for the &lt;code&gt;dct&lt;/code&gt; table:</source>
          <target state="translated">此示例将一个函数分配给默认表中的两个插槽（使用在其他地方定义的预处理器宏），并将其设为 &lt;code&gt;dct&lt;/code&gt; 表的默认值：</target>
        </trans-unit>
        <trans-unit id="1f3b599da5422ada6f5dd38b7f237af6695d9dff" translate="yes" xml:space="preserve">
          <source>This example creates an alias of &lt;code&gt;foo_v1&lt;/code&gt; with symbol name &lt;code&gt;symver_foo_v1&lt;/code&gt; which will be version &lt;code&gt;VERS_2&lt;/code&gt; of &lt;code&gt;foo&lt;/code&gt;.</source>
          <target state="translated">这个例子创建的别名 &lt;code&gt;foo_v1&lt;/code&gt; 与符号名 &lt;code&gt;symver_foo_v1&lt;/code&gt; 这将是版本 &lt;code&gt;VERS_2&lt;/code&gt; 的 &lt;code&gt;foo&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c93813cffc93eab710482b42f488b7bb9eff10b0" translate="yes" xml:space="preserve">
          <source>This example is perfectly equivalent to</source>
          <target state="translated">这个例子完全等同于</target>
        </trans-unit>
        <trans-unit id="d3e949e9ca160ba7c9c4c48936e0ebb9e6567bec" translate="yes" xml:space="preserve">
          <source>This example renames the spec called &amp;lsquo;</source>
          <target state="translated">本示例将规范重命名为&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="17efc27880dcdd0f4c6216f48227b6a6d20fb6a4" translate="yes" xml:space="preserve">
          <source>This example shows a simple assignment of a function to one vector in the default table (note that preprocessor macros may be used for chip-specific symbolic vector names):</source>
          <target state="translated">这个例子显示了一个函数对默认表中的一个向量的简单赋值(注意,预处理器宏可以用于芯片特定的符号向量名称)。</target>
        </trans-unit>
        <trans-unit id="f26530d0d01a4039c695b96fdd00747a2bd4aaea" translate="yes" xml:space="preserve">
          <source>This example uses the &lt;code&gt;cold&lt;/code&gt; label attribute to indicate the &lt;code&gt;ErrorHandling&lt;/code&gt; branch is unlikely to be taken and that the &lt;code&gt;ErrorHandling&lt;/code&gt; label is unused:</source>
          <target state="translated">本示例使用 &lt;code&gt;cold&lt;/code&gt; Label属性指示不太可能采用 &lt;code&gt;ErrorHandling&lt;/code&gt; 分支，并且 &lt;code&gt;ErrorHandling&lt;/code&gt; 标签未使用：</target>
        </trans-unit>
        <trans-unit id="0d3998b5540160156094948f334d5843b7f7f046" translate="yes" xml:space="preserve">
          <source>This example uses the &lt;code&gt;deprecated&lt;/code&gt; enumerator attribute to indicate the &lt;code&gt;oldval&lt;/code&gt; enumerator is deprecated:</source>
          <target state="translated">本示例使用 &lt;code&gt;deprecated&lt;/code&gt; 枚举数属性来指示不推荐使用 &lt;code&gt;oldval&lt;/code&gt; 枚举数：</target>
        </trans-unit>
        <trans-unit id="215cf5b89400516fe24140191ed923d2f09bd20b" translate="yes" xml:space="preserve">
          <source>This example uses the &lt;code&gt;fallthrough&lt;/code&gt; statement attribute to indicate that the</source>
          <target state="translated">本示例使用 &lt;code&gt;fallthrough&lt;/code&gt; 语句属性来指示</target>
        </trans-unit>
        <trans-unit id="7f112db8072d753fab06651e1a77010d4e9ebe45" translate="yes" xml:space="preserve">
          <source>This example:</source>
          <target state="translated">这个例子。</target>
        </trans-unit>
        <trans-unit id="101c080fa9daf91a22a5c3746a65d406ce7eb831" translate="yes" xml:space="preserve">
          <source>This extension is not supported by GNU C++.</source>
          <target state="translated">GNU C++不支持这个扩展。</target>
        </trans-unit>
        <trans-unit id="f68ab67a136425be8901f00690401dbac036957d" translate="yes" xml:space="preserve">
          <source>This extension is sufficient such that</source>
          <target state="translated">这种扩展是充分的,因此</target>
        </trans-unit>
        <trans-unit id="73b411a471e59249b2c99728d68299ae469991d2" translate="yes" xml:space="preserve">
          <source>This extension may not be very useful, but it makes the handling of &lt;code&gt;enum&lt;/code&gt; more consistent with the way &lt;code&gt;struct&lt;/code&gt; and &lt;code&gt;union&lt;/code&gt; are handled.</source>
          <target state="translated">这个扩展可能不是很有用，但是它使 &lt;code&gt;enum&lt;/code&gt; 的处理与 &lt;code&gt;struct&lt;/code&gt; 和 &lt;code&gt;union&lt;/code&gt; 的处理方式更加一致。</target>
        </trans-unit>
        <trans-unit id="5605d8fdd1bc286fd5dac21c8bc67cef9a0ffdd5" translate="yes" xml:space="preserve">
          <source>This extra alignment does consume extra stack space, and generally increases code size. Code that is sensitive to stack space usage, such as embedded systems and operating system kernels, may want to reduce the preferred alignment to</source>
          <target state="translated">这种额外的对齐方式确实会消耗额外的堆栈空间,并且通常会增加代码大小。对堆栈空间使用敏感的代码,如嵌入式系统和操作系统内核,可能希望将首选对齐方式减少为</target>
        </trans-unit>
        <trans-unit id="e786b1c4f43cf240524b9e361ead5cdf6cfb070b" translate="yes" xml:space="preserve">
          <source>This facility is very useful if you want to initialize global variables which can be accessed by the program directly, without sending a message to the class first. The usual way to initialize global variables, in the &lt;code&gt;+initialize&lt;/code&gt; method, might not be useful because &lt;code&gt;+initialize&lt;/code&gt; is only called when the first message is sent to a class object, which in some cases could be too late.</source>
          <target state="translated">如果要初始化可以直接由程序访问的全局变量，而无需先向类发送消息，则此功能非常有用。用 &lt;code&gt;+initialize&lt;/code&gt; 方法初始化全局变量的常用方法可能没有用，因为 &lt;code&gt;+initialize&lt;/code&gt; 仅在将第一条消息发送到类对象时才调用，在某些情况下可能为时已晚。</target>
        </trans-unit>
        <trans-unit id="5301c866b6ac40f65d4bd67792ec94bc126ba1c2" translate="yes" xml:space="preserve">
          <source>This feature is especially useful for ranges of ASCII character codes:</source>
          <target state="translated">这个功能对于ASCII字符代码的范围特别有用。</target>
        </trans-unit>
        <trans-unit id="4b7eade7c951c9b37c2e852a014cd189c7b49192" translate="yes" xml:space="preserve">
          <source>This feature is especially useful in making macro definitions &amp;ldquo;safe&amp;rdquo; (so that they evaluate each operand exactly once). For example, the &amp;ldquo;maximum&amp;rdquo; function is commonly defined as a macro in standard C as follows:</source>
          <target state="translated">在使宏定义&amp;ldquo;安全&amp;rdquo;（以便它们对每个操作数进行一次精确评估）时，此功能特别有用。例如，&amp;ldquo;最大&amp;rdquo;函数通常在标准C中定义为宏，如下所示：</target>
        </trans-unit>
        <trans-unit id="cf86da6582486ace0550eafa0f42f9a96d5c2a2b" translate="yes" xml:space="preserve">
          <source>This feature is intended for program-generated code that may contain unused labels, but which is compiled with</source>
          <target state="translated">此功能适用于程序生成的代码,这些代码可能包含未使用的标签,但在编译时使用了</target>
        </trans-unit>
        <trans-unit id="0c1076e2c167a24356587893b7b6c8a8375aa3a4" translate="yes" xml:space="preserve">
          <source>This feature is not enabled by default. Specifying</source>
          <target state="translated">默认情况下,此功能未启用。指定</target>
        </trans-unit>
        <trans-unit id="9420f79a451b4efac8e962af58f495ad7ac181c7" translate="yes" xml:space="preserve">
          <source>This feature is used in automatic updating of makefiles.</source>
          <target state="translated">这个功能用于自动更新makefile。</target>
        </trans-unit>
        <trans-unit id="a8f11fa97afc8a9f70ed0e1fb16cbd9bede804da" translate="yes" xml:space="preserve">
          <source>This file documents the use of the GNU compilers.</source>
          <target state="translated">这个文件记录了GNU编译器的使用情况。</target>
        </trans-unit>
        <trans-unit id="6c21848b1d55804d72743a6693d101b63cd47544" translate="yes" xml:space="preserve">
          <source>This flag attempts to use visibility settings to make GCC&amp;rsquo;s C++ linkage model compatible with that of Microsoft Visual Studio.</source>
          <target state="translated">此标志尝试使用可见性设置来使GCC的C ++链接模型与Microsoft Visual Studio兼容。</target>
        </trans-unit>
        <trans-unit id="2db7dd43d8e02c47fc0a85c5c3e38b591f0a3877" translate="yes" xml:space="preserve">
          <source>This flag does not have a negative form, because it specifies a three-way choice.</source>
          <target state="translated">这个标志没有负形式,因为它指定了一个三方选择。</target>
        </trans-unit>
        <trans-unit id="c1b1af85f2a6f09c7615fb9953621e2594fc2498" translate="yes" xml:space="preserve">
          <source>This flag is disabled by default.</source>
          <target state="translated">该标志默认为禁用。</target>
        </trans-unit>
        <trans-unit id="ef23e3f8b62106f744c396a536baec3f85486f03" translate="yes" xml:space="preserve">
          <source>This flag is enabled by default at</source>
          <target state="translated">该标志默认在</target>
        </trans-unit>
        <trans-unit id="7fb1ed0a0aaf28dac933fdc7dd7aadf9b8292636" translate="yes" xml:space="preserve">
          <source>This flag is enabled by default for</source>
          <target state="translated">该标志默认为</target>
        </trans-unit>
        <trans-unit id="c025ee0fe2aca271d6bc8b1c3c04c156ee4d07a6" translate="yes" xml:space="preserve">
          <source>This flag is included in</source>
          <target state="translated">这面旗帜包括在</target>
        </trans-unit>
        <trans-unit id="03d3b3aedc1d8ba8a1241588ebdb03f76fc4bd8e" translate="yes" xml:space="preserve">
          <source>This function attribute indicates that an argument in a call to the function is expected to be an explicit &lt;code&gt;NULL&lt;/code&gt;. The attribute is only valid on variadic functions. By default, the sentinel is expected to be the last argument of the function call. If the optional &lt;var&gt;position&lt;/var&gt; argument is specified to the attribute, the sentinel must be located at &lt;var&gt;position&lt;/var&gt; counting backwards from the end of the argument list.</source>
          <target state="translated">该函数属性指示函数调用中的参数应为显式 &lt;code&gt;NULL&lt;/code&gt; 。该属性仅在可变参数函数上有效。默认情况下，前哨应该是函数调用的最后一个参数。如果为属性指定了可选的 &lt;var&gt;position&lt;/var&gt; 参数，则前哨必须位于从参数列表的末尾开始倒数的 &lt;var&gt;position&lt;/var&gt; 。</target>
        </trans-unit>
        <trans-unit id="3eace8a8897f53986baecdd557c9bed95be5eb95" translate="yes" xml:space="preserve">
          <source>This function attribute prevents a function from being considered for cloning&amp;mdash;a mechanism that produces specialized copies of functions and which is (currently) performed by interprocedural constant propagation.</source>
          <target state="translated">此函数属性可防止考虑将函数克隆&amp;mdash;一种机制，该机制可生成函数的专门副本，并且（当前）由过程间常数传播来执行。</target>
        </trans-unit>
        <trans-unit id="0185a8637e8440da0db0d53dd62eb7167b8eb84c" translate="yes" xml:space="preserve">
          <source>This function attribute prevents a function from being considered for inlining. If the function does not have side effects, there are optimizations other than inlining that cause function calls to be optimized away, although the function call is live. To keep such calls from being optimized away, put</source>
          <target state="translated">这个函数属性可以防止函数被考虑内联。如果函数没有副作用,那么除了内联之外,还有一些优化会导致函数调用被优化掉,虽然函数调用是活的。为了防止这类调用被优化掉,可以将</target>
        </trans-unit>
        <trans-unit id="c2eae0ac690e115a386b22c2c033e3d207f73749" translate="yes" xml:space="preserve">
          <source>This function attribute prevents a functions from being merged with another semantically equivalent function.</source>
          <target state="translated">这个函数属性防止一个函数与另一个语义等同的函数合并。</target>
        </trans-unit>
        <trans-unit id="cfa0a9aeda6626f962564eda6d7bc9ae77a9f9e7" translate="yes" xml:space="preserve">
          <source>This function causes the program to exit abnormally. GCC implements this function by using a target-dependent mechanism (such as intentionally executing an illegal instruction) or by calling &lt;code&gt;abort&lt;/code&gt;. The mechanism used may vary from release to release so you should not rely on any particular implementation.</source>
          <target state="translated">此功能导致程序异常退出。GCC通过使用依赖于目标的机制（例如有意执行非法指令）或调用 &lt;code&gt;abort&lt;/code&gt; 来实现此功能。每个发行版使用的机制可能有所不同，因此您不应依赖任何特定的实现。</target>
        </trans-unit>
        <trans-unit id="e524eeb8ecfc131aac67b7d8a458ea88f19f0eed" translate="yes" xml:space="preserve">
          <source>This function does the reverse of &lt;code&gt;__builtin_extract_return_addr&lt;/code&gt;.</source>
          <target state="translated">该函数的作用与 &lt;code&gt;__builtin_extract_return_addr&lt;/code&gt; 相反。</target>
        </trans-unit>
        <trans-unit id="95420bd588ca997857f34739b8ed2c2d2dc9b407" translate="yes" xml:space="preserve">
          <source>This function has the same semantics as &lt;code&gt;__builtin_expect&lt;/code&gt;, but the caller provides the expected probability that &lt;var&gt;exp&lt;/var&gt; == &lt;var&gt;c&lt;/var&gt;. The last argument, &lt;var&gt;probability&lt;/var&gt;, is a floating-point value in the range 0.0 to 1.0, inclusive. The &lt;var&gt;probability&lt;/var&gt; argument must be constant floating-point expression.</source>
          <target state="translated">此函数的语义与 &lt;code&gt;__builtin_expect&lt;/code&gt; 相同，但是调用方提供 &lt;var&gt;exp&lt;/var&gt; == &lt;var&gt;c&lt;/var&gt; 的预期概率。最后一个参数 &lt;var&gt;probability&lt;/var&gt; ，是介于0.0到1.0之间（包括0.0和1.0）的浮点值。所述 &lt;var&gt;probability&lt;/var&gt; 参数必须是恒定浮点表达式。</target>
        </trans-unit>
        <trans-unit id="dad1828780de0ec7cb4d2651f782e659f7669888" translate="yes" xml:space="preserve">
          <source>This function is a &lt;code&gt;nop&lt;/code&gt; on the PowerPC platform and is included solely to maintain API compatibility with the x86 builtins.</source>
          <target state="translated">此功能在PowerPC平台上是 &lt;code&gt;nop&lt;/code&gt; ，仅包括在内是为了与x86内置插件保持API兼容性。</target>
        </trans-unit>
        <trans-unit id="cc1de5cdd4f293c4a48810df067ace8dfe7d6d91" translate="yes" xml:space="preserve">
          <source>This function is similar to &lt;code&gt;__builtin_return_address&lt;/code&gt;, but it returns the address of the function frame rather than the return address of the function. Calling &lt;code&gt;__builtin_frame_address&lt;/code&gt; with a value of &lt;code&gt;0&lt;/code&gt; yields the frame address of the current function, a value of &lt;code&gt;1&lt;/code&gt; yields the frame address of the caller of the current function, and so forth.</source>
          <target state="translated">此函数类似于 &lt;code&gt;__builtin_return_address&lt;/code&gt; ，但是它返回函数框架的地址，而不是函数的返回地址。值为 &lt;code&gt;0&lt;/code&gt; 调用 &lt;code&gt;__builtin_frame_address&lt;/code&gt; 会产生当前函数的帧地址，值为 &lt;code&gt;1&lt;/code&gt; 会产生当前函数的调用者的帧地址，依此类推。</target>
        </trans-unit>
        <trans-unit id="a0b7342f9f274d12e577265101ded1a69579dafe" translate="yes" xml:space="preserve">
          <source>This function is the equivalent of the &lt;code&gt;__FUNCTION__&lt;/code&gt; symbol and returns an address constant pointing to the name of the function from which the built-in was invoked, or the empty string if the invocation is not at function scope. When used as a C++ default argument for a function &lt;var&gt;F&lt;/var&gt;, it returns the name of &lt;var&gt;F&lt;/var&gt;&amp;rsquo;s caller or the empty string if the call was not made at function scope.</source>
          <target state="translated">此函数等效于 &lt;code&gt;__FUNCTION__&lt;/code&gt; 符号，并返回一个地址常量，该常量指向从中调用内置函数的函数的名称；如果调用不在函数范围内，则返回空字符串。当用作函数 &lt;var&gt;F&lt;/var&gt; 的C ++默认参数时，它将返回 &lt;var&gt;F&lt;/var&gt; 的调用者的名称，或者如果未在函数作用域进行调用，则返回空字符串。</target>
        </trans-unit>
        <trans-unit id="86e1f1b709cdf3bbdf962d668f4ccf9699d7ee2e" translate="yes" xml:space="preserve">
          <source>This function is the equivalent of the preprocessor &lt;code&gt;__FILE__&lt;/code&gt; macro and returns an address constant pointing to the file name containing the invocation of the built-in, or the empty string if the invocation is not at function scope. When used as a C++ default argument for a function &lt;var&gt;F&lt;/var&gt;, it returns the file name of the call to &lt;var&gt;F&lt;/var&gt; or the empty string if the call was not made at function scope.</source>
          <target state="translated">此函数等效于预处理器 &lt;code&gt;__FILE__&lt;/code&gt; 宏，并返回一个指向包含内建调用的文件名的地址常量，如果该调用不在函数范围内，则返回一个空字符串。当用作函数 &lt;var&gt;F&lt;/var&gt; 的C ++默认参数时，它将调用的文件名返回给 &lt;var&gt;F&lt;/var&gt; ,或者如果未在函数作用域进行调用，则返回空字符串。</target>
        </trans-unit>
        <trans-unit id="bc294999db99ded1854e8f5e1e4b8ef679553e0d" translate="yes" xml:space="preserve">
          <source>This function is the equivalent of the preprocessor &lt;code&gt;__LINE__&lt;/code&gt; macro and returns a constant integer expression that evaluates to the line number of the invocation of the built-in. When used as a C++ default argument for a function &lt;var&gt;F&lt;/var&gt;, it returns the line number of the call to &lt;var&gt;F&lt;/var&gt;.</source>
          <target state="translated">此函数等效于预处理器 &lt;code&gt;__LINE__&lt;/code&gt; 宏，并返回一个常量整数表达式，该表达式的值等于内置调用的行号。当作为C ++默认参数为函数使用 &lt;var&gt;F&lt;/var&gt; ，则返回调用的行号 &lt;var&gt;F&lt;/var&gt; 。</target>
        </trans-unit>
        <trans-unit id="b4965b81131ff05edb23e4ac2cd86ee54e42a982" translate="yes" xml:space="preserve">
          <source>This function is used to flush the processor&amp;rsquo;s instruction cache for the region of memory between &lt;var&gt;begin&lt;/var&gt; inclusive and &lt;var&gt;end&lt;/var&gt; exclusive. Some targets require that the instruction cache be flushed, after modifying memory containing code, in order to obtain deterministic behavior.</source>
          <target state="translated">此函数用于刷新处理器的指令高速缓存，以存储介于 &lt;var&gt;begin&lt;/var&gt; 包含和 &lt;var&gt;end&lt;/var&gt; 保留之间的内存区域。一些目标要求在修改包含代码的内存之后，刷新指令缓存，以获得确定性行为。</target>
        </trans-unit>
        <trans-unit id="a3fe2b1a97278967d04d0a166eb411721a963d62" translate="yes" xml:space="preserve">
          <source>This function is used to minimize cache-miss latency by moving data into a cache before it is accessed. You can insert calls to &lt;code&gt;__builtin_prefetch&lt;/code&gt; into code for which you know addresses of data in memory that is likely to be accessed soon. If the target supports them, data prefetch instructions are generated. If the prefetch is done early enough before the access then the data will be in the cache by the time it is accessed.</source>
          <target state="translated">此功能用于通过在访问数据之前将数据移入缓存来最大程度地减少缓存丢失的延迟。您可以 &lt;code&gt;__builtin_prefetch&lt;/code&gt; 调用插入到代码中，这些代码您知道内存中可能很快将被访问的数据地址。如果目标支持它们，则将生成数据预取指令。如果预取在访问之前足够早地完成，则数据将在访问时存储在缓存中。</target>
        </trans-unit>
        <trans-unit id="8919a966ee8dd6af4dbf0f92a03208a705be1969" translate="yes" xml:space="preserve">
          <source>This function restores the stack context in &lt;var&gt;buf&lt;/var&gt;, saved by a previous call to &lt;code&gt;__builtin_setjmp&lt;/code&gt;. After &lt;code&gt;__builtin_longjmp&lt;/code&gt; is finished, the program resumes execution as if the matching &lt;code&gt;__builtin_setjmp&lt;/code&gt; returns the value &lt;var&gt;val&lt;/var&gt;, which must be 1.</source>
          <target state="translated">此函数将 &lt;var&gt;buf&lt;/var&gt; 恢复堆栈上下文，该上下文由先前对 &lt;code&gt;__builtin_setjmp&lt;/code&gt; 的调用保存。后 &lt;code&gt;__builtin_longjmp&lt;/code&gt; 完成后，程序就好像匹配恢复执行 &lt;code&gt;__builtin_setjmp&lt;/code&gt; 返回值 &lt;var&gt;val&lt;/var&gt; ，它必须是1。</target>
        </trans-unit>
        <trans-unit id="d321f2ee318af6c2dd764431e17a984bfaa18ec1" translate="yes" xml:space="preserve">
          <source>This function returns a pointer to data describing how to return whatever value is returned by &lt;var&gt;function&lt;/var&gt;. The data is saved in a block of memory allocated on the stack.</source>
          <target state="translated">该函数返回一个指向数据的指针，该数据描述了如何返回 &lt;var&gt;function&lt;/var&gt; 返回的任何值。数据保存在堆栈上分配的一块内存中。</target>
        </trans-unit>
        <trans-unit id="b71039af8a1d11c8d83124bcb2f420630a5a1ce8" translate="yes" xml:space="preserve">
          <source>This function returns a positive integer if the run-time CPU is of type &lt;var&gt;cpuname&lt;/var&gt; and returns &lt;code&gt;0&lt;/code&gt; otherwise. The following CPU names can be detected:</source>
          <target state="translated">如果运行时CPU的类型为 &lt;var&gt;cpuname&lt;/var&gt; ，则此函数返回正整数，否则返回 &lt;code&gt;0&lt;/code&gt; 。可以检测到以下CPU名称：</target>
        </trans-unit>
        <trans-unit id="dfdc7462f357d955c59d1a21b41e74d15ee8d83b" translate="yes" xml:space="preserve">
          <source>This function returns a positive integer if the run-time CPU supports &lt;var&gt;feature&lt;/var&gt; and returns &lt;code&gt;0&lt;/code&gt; otherwise. The following features can be detected:</source>
          <target state="translated">该函数返回一个正整数，如果在运行时CPU支持 &lt;var&gt;feature&lt;/var&gt; ，并返回 &lt;code&gt;0&lt;/code&gt; ，否则。可以检测到以下功能：</target>
        </trans-unit>
        <trans-unit id="5bf6bbb0ff1bf6eb1b3c656f4cca7e925e10e2a5" translate="yes" xml:space="preserve">
          <source>This function returns a value of &lt;code&gt;1&lt;/code&gt; if the run-time CPU is of type &lt;var&gt;cpuname&lt;/var&gt; and returns &lt;code&gt;0&lt;/code&gt; otherwise</source>
          <target state="translated">如果运行时CPU的类型为 &lt;var&gt;cpuname&lt;/var&gt; ，则此函数返回值 &lt;code&gt;1&lt;/code&gt; ，否则返回 &lt;code&gt;0&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="27852be90385733f670b1f53118c6fb5c9f99598" translate="yes" xml:space="preserve">
          <source>This function returns a value of &lt;code&gt;1&lt;/code&gt; if the run-time CPU supports the HWCAP feature &lt;var&gt;feature&lt;/var&gt; and returns &lt;code&gt;0&lt;/code&gt; otherwise.</source>
          <target state="translated">此函数返回的值 &lt;code&gt;1&lt;/code&gt; ，如果在运行时CPU支持HWCAP特征 &lt;var&gt;feature&lt;/var&gt; 并返回 &lt;code&gt;0&lt;/code&gt; ，否则。</target>
        </trans-unit>
        <trans-unit id="213b2aa2268e34e2f3e902cc0c4fc9d3fae623d8" translate="yes" xml:space="preserve">
          <source>This function returns its first argument, and allows the compiler to assume that the returned pointer is at least &lt;var&gt;align&lt;/var&gt; bytes aligned. This built-in can have either two or three arguments, if it has three, the third argument should have integer type, and if it is nonzero means misalignment offset. For example:</source>
          <target state="translated">该函数返回其第一个参数，并允许编译器假定返回的指针至少是 &lt;var&gt;align&lt;/var&gt; 字节。此内置参数可以有两个或三个参数，如果有三个，则第三个参数应为整数类型，如果非零则表示偏移量偏移。例如：</target>
        </trans-unit>
        <trans-unit id="0dc83a066fc8a8ed7ae8cb097e4deaf1084d4a2b" translate="yes" xml:space="preserve">
          <source>This function returns the return address of the current function, or of one of its callers. The &lt;var&gt;level&lt;/var&gt; argument is number of frames to scan up the call stack. A value of &lt;code&gt;0&lt;/code&gt; yields the return address of the current function, a value of &lt;code&gt;1&lt;/code&gt; yields the return address of the caller of the current function, and so forth. When inlining the expected behavior is that the function returns the address of the function that is returned to. To work around this behavior use the &lt;code&gt;noinline&lt;/code&gt; function attribute.</source>
          <target state="translated">此函数返回当前函数或其调用者之一的返回地址。该 &lt;var&gt;level&lt;/var&gt; 的说法是帧扫描调用栈的数量。值为 &lt;code&gt;0&lt;/code&gt; 产生当前函数的返回地址，值为 &lt;code&gt;1&lt;/code&gt; 产生当前函数的调用者的返回地址，依此类推。内联预期的行为是该函数返回所返回函数的地址。要变通解决此问题，请使用 &lt;code&gt;noinline&lt;/code&gt; 函数属性。</target>
        </trans-unit>
        <trans-unit id="a8c68121ab03a5059f1b4257b6c2b3c7234cacf3" translate="yes" xml:space="preserve">
          <source>This function runs the CPU detection code to check the type of CPU and the features supported. This built-in function needs to be invoked along with the built-in functions to check CPU type and features, &lt;code&gt;__builtin_cpu_is&lt;/code&gt; and &lt;code&gt;__builtin_cpu_supports&lt;/code&gt;, only when used in a function that is executed before any constructors are called. The CPU detection code is automatically executed in a very high priority constructor.</source>
          <target state="translated">此功能运行CPU检测代码以检查CPU的类型和支持的功能。仅当在调用任何构造函数之前执行的函数中使用 &lt;code&gt;__builtin_cpu_is&lt;/code&gt; 和 &lt;code&gt;__builtin_cpu_supports&lt;/code&gt; 时，才需要将此内置函数与内置函数一起调用以检查CPU类型和功能。CPU检测代码在优先级很高的构造函数中自动执行。</target>
        </trans-unit>
        <trans-unit id="0f58a4af763a22a01173db535b0e84cbf679fc29" translate="yes" xml:space="preserve">
          <source>This function saves the current stack context in &lt;var&gt;buf&lt;/var&gt;. &lt;code&gt;__builtin_setjmp&lt;/code&gt; returns 0 when returning directly, and 1 when returning from &lt;code&gt;__builtin_longjmp&lt;/code&gt; using the same &lt;var&gt;buf&lt;/var&gt;.</source>
          <target state="translated">此函数将当前堆栈上下文保存在 &lt;var&gt;buf&lt;/var&gt; 中。 &lt;code&gt;__builtin_setjmp&lt;/code&gt; 返回0直接返回时，并且从返回时1 &lt;code&gt;__builtin_longjmp&lt;/code&gt; 使用相同的 &lt;var&gt;buf&lt;/var&gt; 。</target>
        </trans-unit>
        <trans-unit id="69e7849ff4cbe4d496d1ff31f3b20212a375c758" translate="yes" xml:space="preserve">
          <source>This function, if given a string literal all of which would have been consumed by &lt;code&gt;strtol&lt;/code&gt;, is evaluated early enough that it is considered a compile-time constant.</source>
          <target state="translated">如果给定一个字符串文字，则此函数将被 &lt;code&gt;strtol&lt;/code&gt; 消耗掉，因此应尽早评估该值，以将其视为编译时常量。</target>
        </trans-unit>
        <trans-unit id="1b248fa09ed8681d529d9f22aaa2c70eb149364a" translate="yes" xml:space="preserve">
          <source>This has symmetry with normal static arrays, in that an array of unknown size is also written with &lt;code&gt;[]&lt;/code&gt;.</source>
          <target state="translated">这与常规静态数组具有对称性，因为未知大小的数组也用 &lt;code&gt;[]&lt;/code&gt; 编写。</target>
        </trans-unit>
        <trans-unit id="8646e863ba587311636afd56af70cd4124b64132" translate="yes" xml:space="preserve">
          <source>This has the same effect as the proper number of individual &lt;code&gt;case&lt;/code&gt; labels, one for each integer value from &lt;var&gt;low&lt;/var&gt; to &lt;var&gt;high&lt;/var&gt;, inclusive.</source>
          <target state="translated">这与适当数量的个别 &lt;code&gt;case&lt;/code&gt; 标签具有相同的效果，从 &lt;var&gt;low&lt;/var&gt; 到 &lt;var&gt;high&lt;/var&gt; （包括两端）的每个整数值一个。</target>
        </trans-unit>
        <trans-unit id="83169887a69a2b08bab1ebc54a9588ce551d545e" translate="yes" xml:space="preserve">
          <source>This hook is generally reserved for &amp;ldquo;Foundation&amp;rdquo; libraries such as GNUstep Base, which use it to implement their high-level method forwarding API, typically based around the &lt;code&gt;forwardInvocation:&lt;/code&gt; method. So, unless you are implementing your own &amp;ldquo;Foundation&amp;rdquo; library, you should not set this hook.</source>
          <target state="translated">通常，该挂钩是为&amp;ldquo;基础&amp;rdquo;库（例如GNUstep Base）保留的，该库使用它来实现其高级方法转发API（通常基于 &lt;code&gt;forwardInvocation:&lt;/code&gt; 方法）。因此，除非您实现自己的&amp;ldquo; Foundation&amp;rdquo;库，否则不应设置此挂钩。</target>
        </trans-unit>
        <trans-unit id="968e5049fab7f4bdf3b3205d394535ad648ef39e" translate="yes" xml:space="preserve">
          <source>This i386 code demonstrates a case that does not use (or require) the &lt;code&gt;volatile&lt;/code&gt; qualifier. If it is performing assertion checking, this code uses &lt;code&gt;asm&lt;/code&gt; to perform the validation. Otherwise, &lt;code&gt;dwRes&lt;/code&gt; is unreferenced by any code. As a result, the optimizers can discard the &lt;code&gt;asm&lt;/code&gt; statement, which in turn removes the need for the entire &lt;code&gt;DoCheck&lt;/code&gt; routine. By omitting the &lt;code&gt;volatile&lt;/code&gt; qualifier when it isn&amp;rsquo;t needed you allow the optimizers to produce the most efficient code possible.</source>
          <target state="translated">此i386代码演示了不使用（或不需要） &lt;code&gt;volatile&lt;/code&gt; 限定符的情况。如果正在执行断言检查，则此代码使用 &lt;code&gt;asm&lt;/code&gt; 进行验证。否则，任何代码 &lt;code&gt;dwRes&lt;/code&gt; 不会引用dwRes。结果，优化器可以放弃 &lt;code&gt;asm&lt;/code&gt; 语句，从而消除了对整个 &lt;code&gt;DoCheck&lt;/code&gt; 例程的需要。通过在不需要时省略 &lt;code&gt;volatile&lt;/code&gt; 限定符，可以使优化器产生最有效的代码。</target>
        </trans-unit>
        <trans-unit id="808f6f4a24d0e37061696da154166d6ac70ac880" translate="yes" xml:space="preserve">
          <source>This implies that the choice of angle brackets or double quotes in an &amp;lsquo;</source>
          <target state="translated">这表示在'中选择尖括号或双引号</target>
        </trans-unit>
        <trans-unit id="e1db8a962787e8ba6275999130017fe253b89359" translate="yes" xml:space="preserve">
          <source>This inserts an instruction sequence that takes exactly &lt;var&gt;cycles&lt;/var&gt; cycles (between 0 and about 17E9) to complete. The inserted sequence may use jumps, loops, or no-ops, and does not interfere with any other instructions. Note that &lt;var&gt;cycles&lt;/var&gt; must be a compile-time constant integer - that is, you must pass a number, not a variable that may be optimized to a constant later. The number of cycles delayed by this builtin is exact.</source>
          <target state="translated">这将插入一个指令序列，该指令序列需要精确的 &lt;var&gt;cycles&lt;/var&gt; 周期（介于0和17E9之间）来完成。插入的序列可以使用跳转，循环或无操作，并且不干扰任何其他指令。请注意， &lt;var&gt;cycles&lt;/var&gt; 必须是编译时常量整数-也就是说，您必须传递一个数字，而不是一个可以在以后优化为常量的变量。此内置延迟的周期数是准确的。</target>
        </trans-unit>
        <trans-unit id="8e5d39ccb505b20a7de4368cf8c74cd0bd9b0602" translate="yes" xml:space="preserve">
          <source>This instrumentation is also done for functions expanded inline in other functions. The profiling calls indicate where, conceptually, the inline function is entered and exited. This means that addressable versions of such functions must be available. If all your uses of a function are expanded inline, this may mean an additional expansion of code size. If you use &lt;code&gt;extern inline&lt;/code&gt; in your C code, an addressable version of such functions must be provided. (This is normally the case anyway, but if you get lucky and the optimizer always expands the functions inline, you might have gotten away without providing static copies.)</source>
          <target state="translated">对于在其他功能中内联扩展的功能，也可以使用此工具。分析调用指示概念上内联函数的输入和退出位置。这意味着此类功能的可寻址版本必须可用。如果您对函数的所有使用都被内联扩展，则可能意味着代码大小的其他扩展。如果在C代码中使用 &lt;code&gt;extern inline&lt;/code&gt; ，则必须提供此类函数的可寻址版本。 （无论如何通常都是这种情况，但是如果您很幸运，并且优化器总是内联扩展功能，则可能不提供静态副本就已经放弃了。）</target>
        </trans-unit>
        <trans-unit id="c5f757d83923a2f4750aa24fef819d39fd7c764d" translate="yes" xml:space="preserve">
          <source>This interface allows either &lt;code&gt;int *&lt;/code&gt; or &lt;code&gt;union wait *&lt;/code&gt; arguments to be passed, using the &lt;code&gt;int *&lt;/code&gt; calling convention. The program can call &lt;code&gt;wait&lt;/code&gt; with arguments of either type:</source>
          <target state="translated">该接口允许使用 &lt;code&gt;int *&lt;/code&gt; 调用约定传递 &lt;code&gt;int *&lt;/code&gt; 或 &lt;code&gt;union wait *&lt;/code&gt; 参数。程序可以使用以下两种类型的参数调用 &lt;code&gt;wait&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="7fa6e20d0ad9607fec20c7fa93797725b39e7225" translate="yes" xml:space="preserve">
          <source>This interrupt service routine is interruptible after &lt;code&gt;PSW.GIE&lt;/code&gt; (global interrupt enable) is set. This allows interrupt service routine to finish some short critical code before enabling interrupts.</source>
          <target state="translated">设置 &lt;code&gt;PSW.GIE&lt;/code&gt; （全局中断使能）后，该中断服务程序可被中断。这允许中断服务程序在允许中断之前完成一些简短的关键代码。</target>
        </trans-unit>
        <trans-unit id="f39211b611ed78b8a4cda99c2d1b9f90b52f7b8c" translate="yes" xml:space="preserve">
          <source>This interrupt service routine is interruptible.</source>
          <target state="translated">该中断服务例程是可中断的。</target>
        </trans-unit>
        <trans-unit id="8cc90603ecbdd7ae47dd33c675b43de2d13b14cf" translate="yes" xml:space="preserve">
          <source>This interrupt service routine is not interruptible.</source>
          <target state="translated">这个中断服务例程是不可中断的。</target>
        </trans-unit>
        <trans-unit id="98ed58186125da377f3558ec8512de6f6dbbf8ae" translate="yes" xml:space="preserve">
          <source>This invokes all subprograms of &lt;code&gt;gcc&lt;/code&gt; under &amp;lsquo;</source>
          <target state="translated">这会在'下调用 &lt;code&gt;gcc&lt;/code&gt; 的所有子程序</target>
        </trans-unit>
        <trans-unit id="36c68f63258bf418514a8d6d7b59387b054a571e" translate="yes" xml:space="preserve">
          <source>This is a 24-bit address space that linearizes flash and RAM: If the high bit of the address is set, data is read from RAM using the lower two bytes as RAM address. If the high bit of the address is clear, data is read from flash with &lt;code&gt;RAMPZ&lt;/code&gt; set according to the high byte of the address. See &lt;a href=&quot;avr-built_002din-functions#AVR-Built_002din-Functions&quot;&gt;&lt;code&gt;__builtin_avr_flash_segment&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">这是一个使闪存和RAM线性化的24位地址空间：如果设置了地址的高位，则使用低两个字节作为RAM地址从RAM中读取数据。如果地址的高位清零，则根据地址的高字节从 &lt;code&gt;RAMPZ&lt;/code&gt; 置1的闪存中读取数据。参见&lt;a href=&quot;avr-built_002din-functions#AVR-Built_002din-Functions&quot;&gt; &lt;code&gt;__builtin_avr_flash_segment&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c3eadc5a720e67193fff3510f3b6d516e5846adb" translate="yes" xml:space="preserve">
          <source>This is a debugging flag. When used in conjunction with</source>
          <target state="translated">这是一个调试标志。当与</target>
        </trans-unit>
        <trans-unit id="c173adebd0002ff9b3abf598cd2d9f90729d1e99" translate="yes" xml:space="preserve">
          <source>This is a literal string that is the template for the assembler code. It is a combination of fixed text and tokens that refer to the input, output, and goto parameters. See &lt;a href=&quot;#AssemblerTemplate&quot;&gt;AssemblerTemplate&lt;/a&gt;.</source>
          <target state="translated">这是一个文字字符串，它是汇编代码的模板。它是固定文本和令牌的组合，它们引用输入，输出和goto参数。请参见&lt;a href=&quot;#AssemblerTemplate&quot;&gt;AssemblerTemplate&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0266778a01da6e94c7dbdd70401e030bc44b9214" translate="yes" xml:space="preserve">
          <source>This is a literal string that specifies the assembler code. The string can contain any instructions recognized by the assembler, including directives. GCC does not parse the assembler instructions themselves and does not know what they mean or even whether they are valid assembler input.</source>
          <target state="translated">这是一个指定汇编器代码的字面字符串,它可以包含汇编器识别的任何指令,包括指令。该字符串可以包含任何被汇编器识别的指令,包括指令。GCC不解析汇编器指令本身,也不知道它们的含义,甚至不知道它们是否是有效的汇编器输入。</target>
        </trans-unit>
        <trans-unit id="b220cd2425897f657363d80f6f8c621c9e9dc4d4" translate="yes" xml:space="preserve">
          <source>This is a more fine-grained version of</source>
          <target state="translated">这是一个更精细的版本。</target>
        </trans-unit>
        <trans-unit id="210265ec50f329c0444d753e710536de44906855" translate="yes" xml:space="preserve">
          <source>This is a property of the linker. C99 and C11 require that case distinctions are always significant in identifiers with external linkage and systems without this property are not supported by GCC.</source>
          <target state="translated">这是链接器的一个属性。C99和C11要求在有外部链接的标识符中,大小写的区分总是很重要的,没有这个属性的系统是不被GCC支持的。</target>
        </trans-unit>
        <trans-unit id="efc75a30c66eb95f41ba11f1badfcb67f0cc09c0" translate="yes" xml:space="preserve">
          <source>This is a set of options that are used to explicitly disable/enable optimization passes. These options are intended for use for debugging GCC. Compiler users should use regular options for enabling/disabling passes instead.</source>
          <target state="translated">这是一组用于明确禁用/启用优化通道的选项。这些选项用于调试GCC。编译器用户应该使用常规选项来启用/禁用通证。</target>
        </trans-unit>
        <trans-unit id="c7a5bbf22b220bbd15b9398c9ef72c66a3e9df59" translate="yes" xml:space="preserve">
          <source>This is a synonym for</source>
          <target state="translated">这是一个同义词</target>
        </trans-unit>
        <trans-unit id="fe3ee5c4bc9712f6bcac0ed8f03115711a2bebe4" translate="yes" xml:space="preserve">
          <source>This is an acceptable initializer even if &lt;var&gt;EXPRESSION&lt;/var&gt; is not a constant expression, including the case where &lt;code&gt;__builtin_constant_p&lt;/code&gt; returns 1 because &lt;var&gt;EXPRESSION&lt;/var&gt; can be folded to a constant but &lt;var&gt;EXPRESSION&lt;/var&gt; contains operands that are not otherwise permitted in a static initializer (for example, &lt;code&gt;0 &amp;amp;&amp;amp; foo ()&lt;/code&gt;). GCC must be more conservative about evaluating the built-in in this case, because it has no opportunity to perform optimization.</source>
          <target state="translated">即使 &lt;var&gt;EXPRESSION&lt;/var&gt; 不是常量表达式，这也是可接受的初始值设定项，包括 &lt;code&gt;__builtin_constant_p&lt;/code&gt; 返回1 的情况，因为 &lt;var&gt;EXPRESSION&lt;/var&gt; 可以折叠为常数，但 &lt;var&gt;EXPRESSION&lt;/var&gt; 包含静态初始值设定项中不允许的操作数（例如 &lt;code&gt;0 &amp;amp;&amp;amp; foo ()&lt;/code&gt; ）。在这种情况下，GCC在评估内置组件时必须更加保守，因为它没有机会执行优化。</target>
        </trans-unit>
        <trans-unit id="e0aaa7cf6754c8cbdc72fa557e1be8935391e808" translate="yes" xml:space="preserve">
          <source>This is an advanced section. Type encodings are used extensively by the compiler and by the runtime, but you generally do not need to know about them to use Objective-C.</source>
          <target state="translated">这是一个高级章节。类型编码被编译器和运行时广泛使用,但你一般不需要了解它们就能使用Objective-C。</target>
        </trans-unit>
        <trans-unit id="7f363131e14be21e154381e2dda1e3e5a071a820" translate="yes" xml:space="preserve">
          <source>This is an alternative to creating a union with a &lt;code&gt;double&lt;/code&gt; member, which forces the union to be double-word aligned.</source>
          <target state="translated">这是创建带有 &lt;code&gt;double&lt;/code&gt; 成员的并集的替代方法，后者强制使该联合是双字对齐的。</target>
        </trans-unit>
        <trans-unit id="07d312a53d8e7c9544d42f284a8fb92ee207ce56" translate="yes" xml:space="preserve">
          <source>This is an implementation of the ISO C99 function &lt;code&gt;nan&lt;/code&gt;.</source>
          <target state="translated">这是ISO C99函数 &lt;code&gt;nan&lt;/code&gt; 的实现。</target>
        </trans-unit>
        <trans-unit id="6bb58cdaec11ea8785a298afd036692620cb8a71" translate="yes" xml:space="preserve">
          <source>This is because 2147483648 cannot fit in the type &lt;code&gt;int&lt;/code&gt;, so (following the ISO C rules) its data type is &lt;code&gt;unsigned long int&lt;/code&gt;. Negating this value yields 2147483648 again.</source>
          <target state="translated">这是因为2147483648不适合 &lt;code&gt;int&lt;/code&gt; 类型，因此（遵循ISO C规则）其数据类型为 &lt;code&gt;unsigned long int&lt;/code&gt; 。取反该值将再次产生2147483648。</target>
        </trans-unit>
        <trans-unit id="cbcf60838e5c265166bf0d438d003168c4b74356" translate="yes" xml:space="preserve">
          <source>This is bound applied to calls which are considered relevant with</source>
          <target state="translated">这个约束适用于被认为是相关的调用与</target>
        </trans-unit>
        <trans-unit id="5195f538541a2304ddd489646469dec48a8ccb37" translate="yes" xml:space="preserve">
          <source>This is bound applied to calls which are optimized for size. Small growth may be desirable to anticipate optimization oppurtunities exposed by inlining.</source>
          <target state="translated">这适用于对大小进行优化的调用。小规模的增长可能是可取的,以预测内联所带来的优化机会。</target>
        </trans-unit>
        <trans-unit id="6762670483f9855e0a3aefbae371bb5703501c2b" translate="yes" xml:space="preserve">
          <source>This is called a &lt;em&gt;matching constraint&lt;/em&gt; and what it really means is that the assembler has only a single operand that fills two roles which &lt;code&gt;asm&lt;/code&gt; distinguishes. For example, an add instruction uses two input operands and an output operand, but on most CISC machines an add instruction really has only two operands, one of them an input-output operand:</source>
          <target state="translated">这称为&lt;em&gt;匹配约束&lt;/em&gt;，其真正含义是汇编器只有一个操作数，它可以填补 &lt;code&gt;asm&lt;/code&gt; 所区分的两个角色。例如，一条add指令使用两个输入操作数和一个输出操作数，但是在大多数CISC机器上，一条add指令实际上只有两个操作数，其中一个是输入-输出操作数：</target>
        </trans-unit>
        <trans-unit id="c074cd27c3a79447115b4b73b7a639c3b4fa2a8e" translate="yes" xml:space="preserve">
          <source>This is currently implemented using the stronger &lt;code&gt;__ATOMIC_ACQUIRE&lt;/code&gt; memory order because of a deficiency in C++11&amp;rsquo;s semantics for &lt;code&gt;memory_order_consume&lt;/code&gt;.</source>
          <target state="translated">由于C ++ 11的 &lt;code&gt;memory_order_consume&lt;/code&gt; 语义不足，当前使用更强的 &lt;code&gt;__ATOMIC_ACQUIRE&lt;/code&gt; 内存顺序来实现此功能。</target>
        </trans-unit>
        <trans-unit id="2b3d9a8a2627972c9a778aee53c0d0ec3f855978" translate="yes" xml:space="preserve">
          <source>This is dependent on the implementation of the C library, and is not defined by GCC itself.</source>
          <target state="translated">这取决于C库的实现,GCC本身没有定义。</target>
        </trans-unit>
        <trans-unit id="9b7b67a920492c1fed38bbae2d29e3b5c143fedc" translate="yes" xml:space="preserve">
          <source>This is enabled by default when outputting DWARF 2 debug information at the normal level, as long as there is assembler support,</source>
          <target state="translated">在正常输出DWARF 2调试信息时,只要有汇编器支持,该功能默认为启用。</target>
        </trans-unit>
        <trans-unit id="99ef91485a4d9927171b8579ed4d91ac7ed3d923" translate="yes" xml:space="preserve">
          <source>This is equivalent to writing the following:</source>
          <target state="translated">这相当于写了以下内容。</target>
        </trans-unit>
        <trans-unit id="aebe9f9ed1ec955a9599f55edc4af825e40a4ee7" translate="yes" xml:space="preserve">
          <source>This is generally desirable, because assembler-generated line-number tables are a lot more compact than those the compiler can generate itself.</source>
          <target state="translated">这通常是可取的,因为汇编器生成的行号表比编译器自己生成的行号表要紧凑得多。</target>
        </trans-unit>
        <trans-unit id="bfbcbb929b36a00d46e328a1a9742a8d812ee911" translate="yes" xml:space="preserve">
          <source>This is how GCC traditionally handled functions declared &lt;code&gt;inline&lt;/code&gt;. Since ISO C99 specifies a different semantics for &lt;code&gt;inline&lt;/code&gt;, this function attribute is provided as a transition measure and as a useful feature in its own right. This attribute is available in GCC 4.1.3 and later. It is available if either of the preprocessor macros &lt;code&gt;__GNUC_GNU_INLINE__&lt;/code&gt; or &lt;code&gt;__GNUC_STDC_INLINE__&lt;/code&gt; are defined. See &lt;a href=&quot;inline#Inline&quot;&gt;An Inline Function is As Fast As a Macro&lt;/a&gt;.</source>
          <target state="translated">这就是GCC传统上处理 &lt;code&gt;inline&lt;/code&gt; 声明的函数的方式。由于ISO C99为 &lt;code&gt;inline&lt;/code&gt; 指定了不同的语义，因此，此功能属性本身就是一种过渡措施和有用的功能。此属性在GCC 4.1.3和更高版本中可用。如果定义了预处理器宏 &lt;code&gt;__GNUC_GNU_INLINE__&lt;/code&gt; 或 &lt;code&gt;__GNUC_STDC_INLINE__&lt;/code&gt; ，则可用。请参见&lt;a href=&quot;inline#Inline&quot;&gt;内联函数与宏一样快&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3659f6c91bb02b5cd8a55719f9462825417fbf7f" translate="yes" xml:space="preserve">
          <source>This is in all ways equivalent to the ISO C example above, but arguably more readable and descriptive.</source>
          <target state="translated">这在各方面都等同于上述ISO C的例子,但可以说更易读,更有描述性。</target>
        </trans-unit>
        <trans-unit id="1eaa9666a3a5435e04f459b069a65e1a2259a5c1" translate="yes" xml:space="preserve">
          <source>This is intended for use by GCC developers and plugin developers when debugging diagnostics that report interprocedural control flow.</source>
          <target state="translated">这是为了让GCC开发人员和插件开发人员在调试诊断报告程序间控制流时使用。</target>
        </trans-unit>
        <trans-unit id="e833378dc7330796a80aef851e1b40fc5a1e0901" translate="yes" xml:space="preserve">
          <source>This is just like &amp;lsquo;</source>
          <target state="translated">这就像</target>
        </trans-unit>
        <trans-unit id="87943af8f7660938d198a190217b23c8ea1f6e48" translate="yes" xml:space="preserve">
          <source>This is like</source>
          <target state="translated">这就像</target>
        </trans-unit>
        <trans-unit id="37d0e0a31c79678362e2daef4bb85a617b64f850" translate="yes" xml:space="preserve">
          <source>This is more friendly to code living in shared libraries, as it reduces the number of dynamic relocations that are needed, and by consequence, allows the data to be read-only. This alternative with label differences is not supported for the AVR target, please use the first approach for AVR programs.</source>
          <target state="translated">这对生活在共享库中的代码更友好,因为它减少了需要的动态重定位的数量,因此,允许数据是只读的。这种带有标签差异的替代方法不支持AVR目标,请对AVR程序使用第一种方法。</target>
        </trans-unit>
        <trans-unit id="52f8a99adebca7a079e1f334d570e3be716912f1" translate="yes" xml:space="preserve">
          <source>This is not correct on x86-64 as it would allocate tick in either &lt;code&gt;ax&lt;/code&gt; or &lt;code&gt;dx&lt;/code&gt;. You have to use the following variant instead:</source>
          <target state="translated">这在x86-64上是不正确的，因为它将在 &lt;code&gt;ax&lt;/code&gt; 或 &lt;code&gt;dx&lt;/code&gt; 中分配tick 。您必须改用以下变体：</target>
        </trans-unit>
        <trans-unit id="73c90434e16b0f55c0b872ec23da22fc830bc9a4" translate="yes" xml:space="preserve">
          <source>This is particularly useful for assumed-shape arrays in Fortran where (for example) it allows better vectorization assuming contiguous accesses. This flag is enabled by default at</source>
          <target state="translated">这对于Fortran中的假定形状数组特别有用,例如,它允许更好的向量化,假定访问是连续的。默认情况下,这个标志在</target>
        </trans-unit>
        <trans-unit id="031672016e4d502c018309428e47661800aac1a9" translate="yes" xml:space="preserve">
          <source>This is similar to</source>
          <target state="translated">这类似于</target>
        </trans-unit>
        <trans-unit id="b5bdec22d274cc0ce57cbe3e424189dc32fd8d9a" translate="yes" xml:space="preserve">
          <source>This is the C variable or expression being passed to the &lt;code&gt;asm&lt;/code&gt; statement as input. The enclosing parentheses are a required part of the syntax.</source>
          <target state="translated">这是C变量或表达式，将其作为输入传递给 &lt;code&gt;asm&lt;/code&gt; 语句。括号是语法的必需部分。</target>
        </trans-unit>
        <trans-unit id="08fb1a095794b3c3899440175335ee88759da275" translate="yes" xml:space="preserve">
          <source>This is the default (normal) setting. The only traps that are enabled are the ones that cannot be disabled in software (e.g., division by zero trap).</source>
          <target state="translated">这是默认(正常)设置。只有那些不能在软件中禁用的陷阱才会被启用(例如,除零陷阱)。</target>
        </trans-unit>
        <trans-unit id="1a4c45120ca7a63ffc2a2ee3465224f90ffe09ce" translate="yes" xml:space="preserve">
          <source>This is the default choice for non-Darwin x86-32 targets.</source>
          <target state="translated">这是非Darwin x86-32目标的默认选择。</target>
        </trans-unit>
        <trans-unit id="59c124a9358a8d1126f10890f1eb504cdd7df946" translate="yes" xml:space="preserve">
          <source>This is the default choice for the x86-64 compiler, Darwin x86-32 targets, and the default choice for x86-32 targets with the SSE2 instruction set when</source>
          <target state="translated">这是x86-64编译器、Darwin x86-32目标的默认选择,也是x86-32目标使用SSE2指令集时的默认选择。</target>
        </trans-unit>
        <trans-unit id="b74e8d3240c6f67db12f1d7fa81a7aa2edb28fb1" translate="yes" xml:space="preserve">
          <source>This is the default on some targets.</source>
          <target state="translated">这是某些目标的默认值。</target>
        </trans-unit>
        <trans-unit id="a72e96be7931cf0f817380bd16aa70bcfafbbfe8" translate="yes" xml:space="preserve">
          <source>This is the default warning level of</source>
          <target state="translated">这是默认的警告级别,即</target>
        </trans-unit>
        <trans-unit id="2cf92c2da398ed082aa03bcf05470475390ec8ef" translate="yes" xml:space="preserve">
          <source>This is the generic version of an atomic exchange. It stores the contents of &lt;code&gt;*&lt;var&gt;val&lt;/var&gt;&lt;/code&gt; into &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt;. The original value of &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt; is copied into &lt;code&gt;*&lt;var&gt;ret&lt;/var&gt;&lt;/code&gt;.</source>
          <target state="translated">这是原子交换的通用版本。它将 &lt;code&gt;*&lt;var&gt;val&lt;/var&gt;&lt;/code&gt; 的内容存储到 &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt; 中。 &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt; 的原始值被复制到 &lt;code&gt;*&lt;var&gt;ret&lt;/var&gt;&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="544eb750f0727dd454c0757327b302d011f9d8e4" translate="yes" xml:space="preserve">
          <source>This is the generic version of an atomic load. It returns the contents of &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt; in &lt;code&gt;*&lt;var&gt;ret&lt;/var&gt;&lt;/code&gt;.</source>
          <target state="translated">这是原子负载的通用版本。它返回的内容 &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt; 在 &lt;code&gt;*&lt;var&gt;ret&lt;/var&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="21175b474269d19f2c711f8904d430397eb7f000" translate="yes" xml:space="preserve">
          <source>This is the generic version of an atomic store. It stores the value of &lt;code&gt;*&lt;var&gt;val&lt;/var&gt;&lt;/code&gt; into &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt;.</source>
          <target state="translated">这是原子存储的通用版本。它将 &lt;code&gt;*&lt;var&gt;val&lt;/var&gt;&lt;/code&gt; 的值存储到 &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="38581f9b32f6622e3fe0d5bb58e5ec8a4bb25cbf" translate="yes" xml:space="preserve">
          <source>This is the mode used for floating-point calculations with round-to-nearest-or-even rounding mode.</source>
          <target state="translated">这是用四舍五入或四舍五入模式进行浮点计算的模式。</target>
        </trans-unit>
        <trans-unit id="2425d7e7a37939aa94f7a4685eaf2c7dc785155a" translate="yes" xml:space="preserve">
          <source>This is the mode used for floating-point calculations with truncating (i.e. round towards zero) rounding mode. That includes conversion from floating point to integer.</source>
          <target state="translated">这是用于浮点计算的模式,采用截断(即向零取整)的四舍五入模式。这包括从浮点到整数的转换。</target>
        </trans-unit>
        <trans-unit id="35b95ca7a0555a082526c5eeface6f56baa751e7" translate="yes" xml:space="preserve">
          <source>This is the mode used to perform integer calculations in the FPU, e.g. integer multiply, or integer multiply-and-accumulate.</source>
          <target state="translated">这是用于在FPU中执行整数计算的模式,例如整数乘法,或整数乘法和累加。</target>
        </trans-unit>
        <trans-unit id="4098e33c6565f575396e0bc34dbbf7c96adebca6" translate="yes" xml:space="preserve">
          <source>This is the same as &amp;lsquo;</source>
          <target state="translated">这与&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="63f530e06bab16bd703cfd6e987a5d2afe910c22" translate="yes" xml:space="preserve">
          <source>This is the simplest option, but also offers flexibility and fine-grained control when necessary. It is also the most portable alternative and programs using this approach will work with most modern compilers.</source>
          <target state="translated">这是最简单的选择,但也提供了灵活性和必要时的精细控制。它也是最可移植的选择,使用这种方法的程序可以在大多数现代编译器中工作。</target>
        </trans-unit>
        <trans-unit id="92ad0261cb0958c1d426eccb32a1c93544a5dc43" translate="yes" xml:space="preserve">
          <source>This is the warning level of</source>
          <target state="translated">这是警告级别的</target>
        </trans-unit>
        <trans-unit id="77e89dce84a517cc123ca42eb8de81a6643ce569" translate="yes" xml:space="preserve">
          <source>This is the warning level that is enabled by</source>
          <target state="translated">这是由</target>
        </trans-unit>
        <trans-unit id="760cf4bac038578756206c93dae00fb9cba073c6" translate="yes" xml:space="preserve">
          <source>This is typical output:</source>
          <target state="translated">这是典型的输出。</target>
        </trans-unit>
        <trans-unit id="da7f2d31c6f9672e3ba4ae5efbb305bb596a464e" translate="yes" xml:space="preserve">
          <source>This is useful when &lt;code&gt;gcc&lt;/code&gt; prints the error message &amp;lsquo;</source>
          <target state="translated">当 &lt;code&gt;gcc&lt;/code&gt; 打印错误消息&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="61900c28d4f89d472663c0fb34d75c4a85cd7c53" translate="yes" xml:space="preserve">
          <source>This is useful when you use</source>
          <target state="translated">当你使用</target>
        </trans-unit>
        <trans-unit id="f021b4a2b4ebd3ad97c6de7e5e1dd3f9efc1450f" translate="yes" xml:space="preserve">
          <source>This is why GCC does and will treat plain bit-fields in the same fashion on all types of machines (by default).</source>
          <target state="translated">这就是为什么GCC会在所有类型的机器上以同样的方式处理纯位字段(默认情况下)。</target>
        </trans-unit>
        <trans-unit id="4b959d24ea2462316c67c3712ca90973257d6c02" translate="yes" xml:space="preserve">
          <source>This level is intended for analyzer developers; it adds various other events intended for debugging the analyzer.</source>
          <target state="translated">这个级别是为分析器开发人员准备的;它增加了各种其他事件,用于调试分析器。</target>
        </trans-unit>
        <trans-unit id="7c1b93195f2512278e6a6fff2538323d8e57d38c" translate="yes" xml:space="preserve">
          <source>This level is the default.</source>
          <target state="translated">这个级别是默认的。</target>
        </trans-unit>
        <trans-unit id="700e39a7f2669dafee2d84e8e1e01bff08feb798" translate="yes" xml:space="preserve">
          <source>This macro reflects the</source>
          <target state="translated">这个宏观反映了</target>
        </trans-unit>
        <trans-unit id="7d487e0152f8e873aae65c9ae3d1ffd07da68324" translate="yes" xml:space="preserve">
          <source>This manual documents how to use the GNU compilers, as well as their features and incompatibilities, and how to report bugs. It corresponds to the compilers (GCC) version 10.2.0. The internals of the GNU compilers, including how to port them to new targets and some information about how to write front ends for new languages, are documented in a separate manual. See &lt;a href=&quot;http://gcc.gnu.org/onlinedocs/gccint/index.html#Top&quot;&gt;Introduction&lt;/a&gt; in GNU Compiler Collection (GCC) Internals.</source>
          <target state="translated">该手册记录了如何使用GNU编译器，它们的功能和不兼容性以及如何报告错误。它对应于编译器（GCC）版本10.2.0。GNU编译器的内部知识，包括如何将它们移植到新目标以及有关如何为新语言编写前端的一些信息，均在单独的手册中进行了介绍。见&lt;a href=&quot;http://gcc.gnu.org/onlinedocs/gccint/index.html#Top&quot;&gt;介绍&lt;/a&gt;在GNU编译器集合（GCC）内幕。</target>
        </trans-unit>
        <trans-unit id="1653245bf51b1f0c3c2fa674b4064d9aab7d9670" translate="yes" xml:space="preserve">
          <source>This manual documents how to use the GNU compilers, as well as their features and incompatibilities, and how to report bugs. It corresponds to the compilers (GCC) version 9.2.0. The internals of the GNU compilers, including how to port them to new targets and some information about how to write front ends for new languages, are documented in a separate manual. See &lt;a href=&quot;http://gcc.gnu.org/onlinedocs/gccint/index.html#Top&quot;&gt;Introduction&lt;/a&gt; in GNU Compiler Collection (GCC) Internals.</source>
          <target state="translated">该手册记录了如何使用GNU编译器，它们的功能和不兼容性以及如何报告错误。它对应于编译器（GCC）版本9.2.0。GNU编译器的内部知识，包括如何将它们移植到新目标以及有关如何为新语言编写前端的一些信息，均在单独的手册中进行了介绍。见&lt;a href=&quot;http://gcc.gnu.org/onlinedocs/gccint/index.html#Top&quot;&gt;介绍&lt;/a&gt;在GNU编译器集合（GCC）内幕。</target>
        </trans-unit>
        <trans-unit id="d1e0ea996271f7db110a1aacecb995078842dd10" translate="yes" xml:space="preserve">
          <source>This mechanism is not intended to be a replacement for &lt;code&gt;+initialize&lt;/code&gt;. You should be aware of its limitations when you decide to use it instead of &lt;code&gt;+initialize&lt;/code&gt;.</source>
          <target state="translated">该机制并不打算替代 &lt;code&gt;+initialize&lt;/code&gt; 。当您决定使用它而不是 &lt;code&gt;+initialize&lt;/code&gt; 时，应该意识到它的局限性。</target>
        </trans-unit>
        <trans-unit id="0b86e98dae575f25e7dd277f55069259f5a76e0f" translate="yes" xml:space="preserve">
          <source>This might appear strange; if an insn allows a constant operand with a value not known at compile time, it certainly must allow any known value. So why use &amp;lsquo;</source>
          <target state="translated">这可能看起来很奇怪。如果一个insn允许一个常量操作数具有一个在编译时未知的值，则它肯定必须允许任何已知的值。那为什么要使用'</target>
        </trans-unit>
        <trans-unit id="93b2398d0b07a68172b830b044a2e5af1fdcea09" translate="yes" xml:space="preserve">
          <source>This number is allowed to be more than a single digit. If multiple digits are encountered consecutively, they are interpreted as a single decimal integer. There is scant chance for ambiguity, since to-date it has never been desirable that &amp;lsquo;</source>
          <target state="translated">该数字允许超过一个数字。如果连续遇到多个数字，则将它们解释为单个十进制整数。模棱两可的机会很少，因为迄今为止，从未希望&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="22e75e50204b22e1eb4e9e0ef88e476b337f8735" translate="yes" xml:space="preserve">
          <source>This occurs because sometimes GCC optimizes the variable out of existence. There is no way to tell the debugger how to compute the value such a variable &amp;ldquo;would have had&amp;rdquo;, and it is not clear that would be desirable anyway. So GCC simply does not mention the eliminated variable when it writes debugging information.</source>
          <target state="translated">发生这种情况的原因是，有时GCC会优化变量而不存在。没有办法告诉调试器如何计算这样的变量&amp;ldquo;本来应该有&amp;rdquo;的值，而且尚不清楚这是否是理想的。因此，GCC在编写调试信息时根本没有提到消除的变量。</target>
        </trans-unit>
        <trans-unit id="5ce0fa0b0cabdd9e15b52efa7f6d71eba5c1f802" translate="yes" xml:space="preserve">
          <source>This only makes sense when scheduling after register allocation, i.e. with</source>
          <target state="translated">这只有在寄存器分配后进行调度时才有意义,即用</target>
        </trans-unit>
        <trans-unit id="db13c5371ec3d6856069cde7f84c42a79ba4d667" translate="yes" xml:space="preserve">
          <source>This optimization is automatically turned off in the presence of exception handling or unwind tables (on targets using setjump/longjump or target specific scheme), for linkonce sections, for functions with a user-defined section attribute and on any architecture that does not support named sections. When</source>
          <target state="translated">在存在异常处理或unwind表的情况下,该优化会自动关闭(在使用setjump/longjump或目标特定方案的目标上),对于linkonce部分,对于具有用户定义部分属性的函数,以及在任何不支持命名部分的架构上。当</target>
        </trans-unit>
        <trans-unit id="96a50b9ceb3aa5aae8cfa612292d0e06f418fdee" translate="yes" xml:space="preserve">
          <source>This optimization is enabled by default for PowerPC targets, but disabled by default otherwise.</source>
          <target state="translated">对于PowerPC目标,该优化默认为启用,否则默认为禁用。</target>
        </trans-unit>
        <trans-unit id="03a904b6f6255ac7a46cba1abdfa2fc80dcd97c1" translate="yes" xml:space="preserve">
          <source>This optimization is enabled by default.</source>
          <target state="translated">该优化在默认情况下是启用的。</target>
        </trans-unit>
        <trans-unit id="cd622740636a8f6bc187abc5bbcb4be9fb8826dc" translate="yes" xml:space="preserve">
          <source>This optimization is off by default at all optimization levels.</source>
          <target state="translated">在所有优化级别中,该优化默认为关闭。</target>
        </trans-unit>
        <trans-unit id="96c9c932cfd47ab32407f6161d42f932d1499bb6" translate="yes" xml:space="preserve">
          <source>This option allows further control over excess precision on machines where floating-point operations occur in a format with more precision or range than the IEEE standard and interchange floating-point types. By default,</source>
          <target state="translated">当浮点运算的格式比IEEE标准的精度或范围更大时,该选项可以进一步控制过高的精度,并且可以互换浮点类型。默认情况下。</target>
        </trans-unit>
        <trans-unit id="0cd275b48533fab7a99c41cb026721abbe83dfbd" translate="yes" xml:space="preserve">
          <source>This option allows use of a precompiled header (see &lt;a href=&quot;precompiled-headers#Precompiled-Headers&quot;&gt;Precompiled Headers&lt;/a&gt;) together with</source>
          <target state="translated">此选项允许将预编译头（请参阅&lt;a href=&quot;precompiled-headers#Precompiled-Headers&quot;&gt;预编译头&lt;/a&gt;）与</target>
        </trans-unit>
        <trans-unit id="bc138a12e44acf9ec0d9c17239119bb46de565b8" translate="yes" xml:space="preserve">
          <source>This option also controls warnings when a user-defined literal operator is declared with a literal suffix identifier that doesn&amp;rsquo;t begin with an underscore. Literal suffix identifiers that don&amp;rsquo;t begin with an underscore are reserved for future standardization.</source>
          <target state="translated">当声明用户定义的文字运算符带有不以下划线开头的文字后缀标识符时，此选项还可以控制警告。不以下划线开头的文字后缀标识符将保留，以供将来标准化。</target>
        </trans-unit>
        <trans-unit id="176e6d10a5020dcedfe440b551f5e25423a91471" translate="yes" xml:space="preserve">
          <source>This option also enables</source>
          <target state="translated">该选项还可以使</target>
        </trans-unit>
        <trans-unit id="f64cb852c815528bec1c35d19339c840b9bc9852" translate="yes" xml:space="preserve">
          <source>This option also enables warnings about psABI-related changes. The known psABI changes at this point include:</source>
          <target state="translated">该选项还可以对psABI相关的变化发出警告。此时已知的 psABI 变更包括。</target>
        </trans-unit>
        <trans-unit id="44de7a78056937b7baedfa3be44429b20f8420b9" translate="yes" xml:space="preserve">
          <source>This option also warns when &lt;code&gt;alloca&lt;/code&gt; is used in a loop.</source>
          <target state="translated">当在循环中使用 &lt;code&gt;alloca&lt;/code&gt; 时，此选项也会警告。</target>
        </trans-unit>
        <trans-unit id="8dcb0d8b589589b99a6d5de3a4fa4b5fc06db20b" translate="yes" xml:space="preserve">
          <source>This option also warns when a non-volatile automatic variable might be changed by a call to &lt;code&gt;longjmp&lt;/code&gt;. The compiler sees only the calls to &lt;code&gt;setjmp&lt;/code&gt;. It cannot know where &lt;code&gt;longjmp&lt;/code&gt; will be called; in fact, a signal handler could call it at any point in the code. As a result, you may get a warning even when there is in fact no problem because &lt;code&gt;longjmp&lt;/code&gt; cannot in fact be called at the place that would cause a problem.</source>
          <target state="translated">当通过调用 &lt;code&gt;longjmp&lt;/code&gt; 更改非易失性自动变量时，此选项也会警告。编译器仅看到对 &lt;code&gt;setjmp&lt;/code&gt; 的调用。它不知道 &lt;code&gt;longjmp&lt;/code&gt; 将在哪里被调用。实际上，信号处理程序可以在代码中的任何位置调用它。结果，即使实际上没有问题，您也可能会收到警告，因为 &lt;code&gt;longjmp&lt;/code&gt; 实际上无法在会引起问题的位置调用。</target>
        </trans-unit>
        <trans-unit id="647a82f2f84be9cba875128f0dca433a10d57f59" translate="yes" xml:space="preserve">
          <source>This option and its counterpart,</source>
          <target state="translated">这个选项及其对应的。</target>
        </trans-unit>
        <trans-unit id="5138f290e3826f8790e3e713269029e9ccdb5e45" translate="yes" xml:space="preserve">
          <source>This option behaves mostly the same as the MSP430 function attribute of the same name (see &lt;a href=&quot;msp430-function-attributes#MSP430-Function-Attributes&quot;&gt;MSP430 Function Attributes&lt;/a&gt;), but it has some additional functionality.</source>
          <target state="translated">该选项的行为与具有相同名称的MSP430功能属性的行为大致相同（请参阅&lt;a href=&quot;msp430-function-attributes#MSP430-Function-Attributes&quot;&gt;MSP430功能属性&lt;/a&gt;），但是它具有一些其他功能。</target>
        </trans-unit>
        <trans-unit id="d7bf60baf10d559ca0b1b6d693e3ba93b5e1f2d3" translate="yes" xml:space="preserve">
          <source>This option can also serve as a replacement for the older way of specifying custom device-specs files that needed</source>
          <target state="translated">这个选项也可以替代旧有的指定自定义设备规格文件的方式,因为这些文件需要</target>
        </trans-unit>
        <trans-unit id="51f89764d458f9e6ce2a9e5debf60911dcf32abd" translate="yes" xml:space="preserve">
          <source>This option can be overridden for individual functions with the &lt;code&gt;hotpatch&lt;/code&gt; attribute.</source>
          <target state="translated">可以使用 &lt;code&gt;hotpatch&lt;/code&gt; 属性为单个功能覆盖此选项。</target>
        </trans-unit>
        <trans-unit id="b9d6d68f8663846b608b68015e96e5892b5536f8" translate="yes" xml:space="preserve">
          <source>This option can be used in combination with</source>
          <target state="translated">此选项可与</target>
        </trans-unit>
        <trans-unit id="6031ab076087301a6d0abbb423cf52dcdfaad6ad" translate="yes" xml:space="preserve">
          <source>This option can be used with</source>
          <target state="translated">此选项可与</target>
        </trans-unit>
        <trans-unit id="ffe3df6bb53541974a1831b4cc4d1b56a60baa8e" translate="yes" xml:space="preserve">
          <source>This option can lead to reduced code size for functions that perform several calls to functions that get their arguments on the stack like calls to printf-like functions.</source>
          <target state="translated">这个选项可以使执行多次调用的函数减少代码量,这些函数在堆栈上获取参数,比如调用类似printf的函数。</target>
        </trans-unit>
        <trans-unit id="659720e1c331361819e1f19306618a073823d1ae" translate="yes" xml:space="preserve">
          <source>This option can only be used if the target architecture supports branch-likely instructions.</source>
          <target state="translated">这个选项只有在目标架构支持分支可能指令的情况下才能使用。</target>
        </trans-unit>
        <trans-unit id="fc3a9caac6f7198e302fb437322053279f7c71d0" translate="yes" xml:space="preserve">
          <source>This option cannot be suffixed by feature modifiers.</source>
          <target state="translated">此选项不能用特征修饰符作为后缀。</target>
        </trans-unit>
        <trans-unit id="c576211fac72dc023de0044164971c10d96f526d" translate="yes" xml:space="preserve">
          <source>This option causes GCC to create markers in the internal representation at the beginning of statements, and to keep them roughly in place throughout compilation, using them to guide the output of &lt;code&gt;is_stmt&lt;/code&gt; markers in the line number table. This is enabled by default when compiling with optimization (</source>
          <target state="translated">此选项使GCC在语句的开头在内部表示中创建标记，并在整个编译过程中将它们大致保持在适当的位置，并使用它们来指导 &lt;code&gt;is_stmt&lt;/code&gt; 标记在行号表中的输出。使用优化进行编译时，默认情况下启用此功能（</target>
        </trans-unit>
        <trans-unit id="95c8757dd3d3337f46ca394f8f8769868a644ecd" translate="yes" xml:space="preserve">
          <source>This option causes r2 and r5 to be treated as fixed registers.</source>
          <target state="translated">该选项使r2和r5被视为固定寄存器。</target>
        </trans-unit>
        <trans-unit id="b5e090b60ad88e1f4ec2772be778990575505b68" translate="yes" xml:space="preserve">
          <source>This option causes r2 and r5 to be used in the code generated by the compiler. This setting is the default.</source>
          <target state="translated">这个选项会使编译器生成的代码中使用r2和r5。这个设置是默认的。</target>
        </trans-unit>
        <trans-unit id="d3d04b742fdf172a830cc81fd460a113af18fcfc" translate="yes" xml:space="preserve">
          <source>This option causes run-time data structures to be built at program startup, which are used for verifying the vtable pointers. The options &amp;lsquo;</source>
          <target state="translated">此选项导致在程序启动时构建运行时数据结构，该结构用于验证vtable指针。选项&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="a26b4242bc022197a5b469c4333379231dcfd91c" translate="yes" xml:space="preserve">
          <source>This option causes the compiler to abort compilation on the first error occurred rather than trying to keep going and printing further error messages.</source>
          <target state="translated">这个选项会使编译器在第一次发生错误时中止编译,而不是试图继续编译并打印更多的错误信息。</target>
        </trans-unit>
        <trans-unit id="5e90ed4f8d16ef658451b5bbc4a698c1ccbdaac4" translate="yes" xml:space="preserve">
          <source>This option causes the preprocessor macro &lt;code&gt;__FAST_MATH__&lt;/code&gt; to be defined.</source>
          <target state="translated">此选项将导致定义预处理程序宏 &lt;code&gt;__FAST_MATH__&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="59f74610163bdce44c421694716dba7eea2f36f3" translate="yes" xml:space="preserve">
          <source>This option causes the preprocessor macro &lt;code&gt;__SUPPORT_SNAN__&lt;/code&gt; to be defined.</source>
          <target state="translated">此选项将导致定义预处理程序宏 &lt;code&gt;__SUPPORT_SNAN__&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c130859b377ff82df01657d63e921773dd0c4fe8" translate="yes" xml:space="preserve">
          <source>This option controls code generation of the link-time optimizer. By default the linker output is automatically determined by the linker plugin. For debugging the compiler and if incremental linking with a non-LTO object file is desired, it may be useful to control the type manually.</source>
          <target state="translated">这个选项控制链接时间优化器的代码生成。默认情况下,链接器的输出是由链接器插件自动决定的。对于编译器的调试,以及如果需要用非LTO对象文件进行增量链接,可能需要手动控制类型。</target>
        </trans-unit>
        <trans-unit id="dc144b835e4ef20a9b868419ab10431eef1dc3bb" translate="yes" xml:space="preserve">
          <source>This option controls stack space reuse for user declared local/auto variables and compiler generated temporaries. &lt;var&gt;reuse_level&lt;/var&gt; can be &amp;lsquo;</source>
          <target state="translated">此选项控制用户声明的局部/自动变量和编译器生成的临时变量的堆栈空间重用。 &lt;var&gt;reuse_level&lt;/var&gt; 可以是&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="68a88d1554ed1aa2b217aa4277399c9f56f7ad9c" translate="yes" xml:space="preserve">
          <source>This option controls the code generation of the link time optimizer. By default the linker output is determined by the linker plugin automatically. For debugging the compiler and in the case of incremental linking to non-lto object file is desired, it may be useful to control the type manually.</source>
          <target state="translated">这个选项控制链接时间优化器的代码生成。默认情况下,链接器的输出是由链接器插件自动决定的。对于编译器的调试,以及在需要增量链接到非lto对象文件的情况下,手动控制类型可能是有用的。</target>
        </trans-unit>
        <trans-unit id="9a86853e0ed7deb868803dd87757662761aedfd9" translate="yes" xml:space="preserve">
          <source>This option controls the complexity of the control flow paths that are emitted for analyzer diagnostics.</source>
          <target state="translated">该选项控制分析仪诊断时发出的控制流路径的复杂性。</target>
        </trans-unit>
        <trans-unit id="5d9b7ff3f71ba23e9705b0d93e8591071e6bba1a" translate="yes" xml:space="preserve">
          <source>This option controls the default setting of the ISO C99 &lt;code&gt;CX_LIMITED_RANGE&lt;/code&gt; pragma. Nevertheless, the option applies to all languages.</source>
          <target state="translated">此选项控制ISO C99 &lt;code&gt;CX_LIMITED_RANGE&lt;/code&gt; 编译指示的默认设置。但是，该选项适用于所有语言。</target>
        </trans-unit>
        <trans-unit id="149f5a9a7f4ee5991089ef9512f0da137f76588e" translate="yes" xml:space="preserve">
          <source>This option controls the minimum width of the left margin printed by</source>
          <target state="translated">这个选项可以控制由以下方式打印的左页边距的最小宽度</target>
        </trans-unit>
        <trans-unit id="37de330d3f523306c4e20d85e9fac76a8d0f7abf" translate="yes" xml:space="preserve">
          <source>This option controls the priority that is assigned to dispatch-slot restricted instructions during the second scheduling pass. The argument &lt;var&gt;priority&lt;/var&gt; takes the value &amp;lsquo;</source>
          <target state="translated">此选项控制在第二次调度传递期间分配给调度槽受限指令的优先级。参数 &lt;var&gt;priority&lt;/var&gt; 取值为'</target>
        </trans-unit>
        <trans-unit id="00ce7609ded1a0ff2fbbb9740f9f2209c0f8ef1e" translate="yes" xml:space="preserve">
          <source>This option controls the version of libgcc that the compiler links to an executable and selects a software-managed cache for accessing variables in the &lt;code&gt;__ea&lt;/code&gt; address space with a particular cache size. Possible options for &lt;var&gt;cache-size&lt;/var&gt; are &amp;lsquo;</source>
          <target state="translated">此选项控制编译器链接到可执行文件的libgcc的版本，并选择软件管理的缓存来访问具有特定缓存大小的 &lt;code&gt;__ea&lt;/code&gt; 地址空间中的变量。 &lt;var&gt;cache-size&lt;/var&gt; 可能选项是'</target>
        </trans-unit>
        <trans-unit id="9caa6f342fbdbf76f119015b6337636546395e60" translate="yes" xml:space="preserve">
          <source>This option controls the version of libgcc that the compiler links to an executable and selects whether atomic updates to the software-managed cache of PPU-side variables are used. If you use atomic updates, changes to a PPU variable from SPU code using the &lt;code&gt;__ea&lt;/code&gt; named address space qualifier do not interfere with changes to other PPU variables residing in the same cache line from PPU code. If you do not use atomic updates, such interference may occur; however, writing back cache lines is more efficient. The default behavior is to use atomic updates.</source>
          <target state="translated">此选项控制编译器链接到可执行文件的libgcc的版本，并选择是否使用对PPU端变量的软件管理的高速缓存进行原子更新。如果使用原子更新，则使用 &lt;code&gt;__ea&lt;/code&gt; 命名地址空间限定符从SPU代码更改PPU变量不会干扰对PPU代码中驻留在同一高速缓存行中的其他PPU变量的更改。如果您不使用原子更新，则可能会发生这种干扰。但是，回写高速缓存行效率更高。默认行为是使用原子更新。</target>
        </trans-unit>
        <trans-unit id="f61295df1d57ff262d461369dde8c3f32294d711" translate="yes" xml:space="preserve">
          <source>This option controls warnings for invocations of &lt;a href=&quot;_005f_005fatomic-builtins#g_t_005f_005fatomic-Builtins&quot;&gt;__atomic Builtins&lt;/a&gt;, &lt;a href=&quot;_005f_005fsync-builtins#g_t_005f_005fsync-Builtins&quot;&gt;__sync Builtins&lt;/a&gt;, and the C11 atomic generic functions with a memory consistency argument that is either invalid for the operation or outside the range of values of the &lt;code&gt;memory_order&lt;/code&gt; enumeration. For example, since the &lt;code&gt;__atomic_store&lt;/code&gt; and &lt;code&gt;__atomic_store_n&lt;/code&gt; built-ins are only defined for the relaxed, release, and sequentially consistent memory orders the following code is diagnosed:</source>
          <target state="translated">此选项控制带有内存一致性参数的&lt;a href=&quot;_005f_005fatomic-builtins#g_t_005f_005fatomic-Builtins&quot;&gt;__atomic Builtins&lt;/a&gt;，&lt;a href=&quot;_005f_005fsync-builtins#g_t_005f_005fsync-Builtins&quot;&gt;__sync Builtins&lt;/a&gt;和C11原子泛型函数的调用警告，该参数对于该操作无效或在 &lt;code&gt;memory_order&lt;/code&gt; 枚举的值范围之外。例如，由于仅针对轻松，释放和顺序一致的内存顺序定义了 &lt;code&gt;__atomic_store&lt;/code&gt; 和 &lt;code&gt;__atomic_store_n&lt;/code&gt; 内置插件，因此将诊断以下代码：</target>
        </trans-unit>
        <trans-unit id="d64a7975973f5229e105c9130aabc92aaaa20581" translate="yes" xml:space="preserve">
          <source>This option controls warnings if feedback profiles are missing when using the</source>
          <target state="translated">此选项可控制在使用</target>
        </trans-unit>
        <trans-unit id="db5b3a6e625e42c517fab36eef17aa077a6434f1" translate="yes" xml:space="preserve">
          <source>This option controls warnings when a &lt;code&gt;switch&lt;/code&gt; case has a value that is outside of its respective type range. This warning is enabled by default for C and C++ programs.</source>
          <target state="translated">当 &lt;code&gt;switch&lt;/code&gt; 盒的值超出其各自的类型范围时，此选项控制警告。默认情况下，C和C ++程序启用此警告。</target>
        </trans-unit>
        <trans-unit id="d647e87ba0a1edc0a3d0d54b53d61b0d1016c986" translate="yes" xml:space="preserve">
          <source>This option controls warnings when a base class is inaccessible in a class derived from it due to ambiguity. The warning is enabled by default. Note that the warning for ambiguous virtual bases is enabled by the</source>
          <target state="translated">这个选项控制了当基类由于含糊不清而无法访问其派生类时的警告。默认情况下,这个警告是启用的。需要注意的是,对于模棱两可的虚拟基的警告是由</target>
        </trans-unit>
        <trans-unit id="6199fdb67a75703bc6938c6426b3cd53c0cf499e" translate="yes" xml:space="preserve">
          <source>This option controls warnings when a declaration does not specify a type. This warning is enabled by default in C99 and later dialects of C, and also by</source>
          <target state="translated">这个选项控制当声明没有指定类型时的警告。在C99及以后的C语言中,这个警告是默认启用的,也可以通过以下方式启用</target>
        </trans-unit>
        <trans-unit id="925a6115338780b00aeb738e9eb85ce67e1d1212" translate="yes" xml:space="preserve">
          <source>This option controls warnings when a function is used before being declared. This warning is enabled by default in C99 and later dialects of C, and also by</source>
          <target state="translated">这个选项控制当一个函数在被声明之前被使用时的警告。在C99及以后的C语言中,这个警告是默认启用的,也可以通过以下方式启用</target>
        </trans-unit>
        <trans-unit id="e630e657c926dcb14e35c4ecbe7b78750ea05b99" translate="yes" xml:space="preserve">
          <source>This option controls warnings when an attribute is ignored. This is different from the</source>
          <target state="translated">这个选项控制属性被忽略时的警告。这与</target>
        </trans-unit>
        <trans-unit id="23e0eea7f94b4ed1e828e2932547c5127c9ba599" translate="yes" xml:space="preserve">
          <source>This option controls what floating-point related traps are enabled. Other Alpha compilers call this option</source>
          <target state="translated">这个选项可以控制哪些浮点相关的陷阱被启用。其他的Alpha编译器把这个选项称为</target>
        </trans-unit>
        <trans-unit id="f1154974a88b020f8daf5bb4dc20170e8131c728" translate="yes" xml:space="preserve">
          <source>This option controls whether any out-of-line instance of the &lt;code&gt;__sync&lt;/code&gt; family of functions may be used to implement the C++11 &lt;code&gt;__atomic&lt;/code&gt; family of functions.</source>
          <target state="translated">此选项控制 &lt;code&gt;__sync&lt;/code&gt; 函数系列的任何脱机实例是否可用于实现C ++ 11 &lt;code&gt;__atomic&lt;/code&gt; 函数系列。</target>
        </trans-unit>
        <trans-unit id="a4a02927707c45d100e334cb80281cfb05688e67" translate="yes" xml:space="preserve">
          <source>This option controls which NOP insertion scheme is used during the second scheduling pass. The argument &lt;var&gt;scheme&lt;/var&gt; takes one of the following values:</source>
          <target state="translated">此选项控制在第二次调度过程中使用哪种NOP插入方案。参数 &lt;var&gt;scheme&lt;/var&gt; 采用以下值之一：</target>
        </trans-unit>
        <trans-unit id="c08ef18f138d574270868ecf3d1af53b2152507f" translate="yes" xml:space="preserve">
          <source>This option controls which dependences are considered costly by the target during instruction scheduling. The argument &lt;var&gt;dependence_type&lt;/var&gt; takes one of the following values:</source>
          <target state="translated">此选项控制目标在指令调度期间认为哪些依赖项代价高昂。自变量 &lt;var&gt;dependence_type&lt;/var&gt; 采用以下值之一：</target>
        </trans-unit>
        <trans-unit id="eabb06a775f104526b72d8801ca8d34d938d08ee" translate="yes" xml:space="preserve">
          <source>This option controls which reciprocal estimate instructions may be used. &lt;var&gt;opt&lt;/var&gt; is a comma-separated list of options, which may be preceded by a &amp;lsquo;</source>
          <target state="translated">此选项控制可以使用哪些相互估计指令。 &lt;var&gt;opt&lt;/var&gt; 是以逗号分隔的选项列表，其后可能带有'</target>
        </trans-unit>
        <trans-unit id="c61955646b487d462957b5ea4ab670cca58e8127" translate="yes" xml:space="preserve">
          <source>This option controls which reciprocal estimate instructions may be used. &lt;var&gt;opt&lt;/var&gt; is a comma-separated list of options, which may be preceded by a &lt;code&gt;!&lt;/code&gt; to invert the option:</source>
          <target state="translated">此选项控制可以使用哪些相互估计指令。 &lt;var&gt;opt&lt;/var&gt; 是逗号分隔的选项列表，其前面可能带有 &lt;code&gt;!&lt;/code&gt; 反转选项：</target>
        </trans-unit>
        <trans-unit id="a2ecce718b608dfca621af1742e2244436537a5c" translate="yes" xml:space="preserve">
          <source>This option currently only works for RTL dumps, and the RTL is always dumped in slim form.</source>
          <target state="translated">这个选项目前只对RTL转储有效,而且RTL总是以纤细的形式转储。</target>
        </trans-unit>
        <trans-unit id="a0efcaa928c1eb50d04d69e5ea5969a7461e4235" translate="yes" xml:space="preserve">
          <source>This option defaults to</source>
          <target state="translated">这个选项的默认值是</target>
        </trans-unit>
        <trans-unit id="9fc2236cfdc032c6f548639c70136cdca6a33540" translate="yes" xml:space="preserve">
          <source>This option disables a target-specific pass in</source>
          <target state="translated">这个选项在</target>
        </trans-unit>
        <trans-unit id="c70b4cbddab92e21116da323b06dd29142551856" translate="yes" xml:space="preserve">
          <source>This option disables all previously enabled sanitizers.</source>
          <target state="translated">此选项可禁用所有之前启用的消毒器。</target>
        </trans-unit>
        <trans-unit id="331b4b3e9a10408d9fe49b419ac451d5b43afbf6" translate="yes" xml:space="preserve">
          <source>This option does not affect the behavior of the</source>
          <target state="translated">这个选项不影响</target>
        </trans-unit>
        <trans-unit id="654b3209c6de0a321e02002e434d9a9983c5a1bb" translate="yes" xml:space="preserve">
          <source>This option does not suppress the preprocessor&amp;rsquo;s debug output, such as</source>
          <target state="translated">此选项不会取消预处理器的调试输出，例如</target>
        </trans-unit>
        <trans-unit id="90399aa992409c6c8444d2b7bc23fef6bd0b23f1" translate="yes" xml:space="preserve">
          <source>This option does not warn about designated initializers, so the following modification does not trigger a warning:</source>
          <target state="translated">这个选项不会对指定的初始化器发出警告,所以以下修改不会触发警告。</target>
        </trans-unit>
        <trans-unit id="637d485d36be088d5dc6290430edcc3559942fb2" translate="yes" xml:space="preserve">
          <source>This option does not work in the presence of shared libraries or nested functions.</source>
          <target state="translated">这个选项在有共享库或嵌套函数的情况下不起作用。</target>
        </trans-unit>
        <trans-unit id="b6cfd2996b7bd042cf9971ccd157a3b5ed5d4172" translate="yes" xml:space="preserve">
          <source>This option enable the compiler to emit &lt;code&gt;enter&lt;/code&gt; and &lt;code&gt;leave&lt;/code&gt; instructions. These instructions are only valid for CPUs with code-density feature.</source>
          <target state="translated">此选项使编译器可以发出 &lt;code&gt;enter&lt;/code&gt; 和 &lt;code&gt;leave&lt;/code&gt; 指令。这些指令仅对具有代码密度功能的CPU有效。</target>
        </trans-unit>
        <trans-unit id="f36e3ffcf2c8e8b04ebd85e66df66aa0c1508360" translate="yes" xml:space="preserve">
          <source>This option enables GCC to generate &lt;code&gt;CMPXCHG16B&lt;/code&gt; instructions in 64-bit code to implement compare-and-exchange operations on 16-byte aligned 128-bit objects. This is useful for atomic updates of data structures exceeding one machine word in size. The compiler uses this instruction to implement &lt;a href=&quot;_005f_005fsync-builtins#g_t_005f_005fsync-Builtins&quot;&gt;__sync Builtins&lt;/a&gt;. However, for &lt;a href=&quot;_005f_005fatomic-builtins#g_t_005f_005fatomic-Builtins&quot;&gt;__atomic Builtins&lt;/a&gt; operating on 128-bit integers, a library call is always used.</source>
          <target state="translated">此选项使GCC能够以64位代码生成 &lt;code&gt;CMPXCHG16B&lt;/code&gt; 指令，以对16字节对齐的128位对象实施比较和交换操作。这对于超过一个机器字的数据结构的原子更新很有用。编译器使用此指令来实现&lt;a href=&quot;_005f_005fsync-builtins#g_t_005f_005fsync-Builtins&quot;&gt;__sync Builtins&lt;/a&gt;。但是，对于在128位整数上运行的&lt;a href=&quot;_005f_005fatomic-builtins#g_t_005f_005fatomic-Builtins&quot;&gt;__atomic Builtins&lt;/a&gt;，始终使用库调用。</target>
        </trans-unit>
        <trans-unit id="111a14f183c415ed55eeae4c39a6e2dbf86ced81" translate="yes" xml:space="preserve">
          <source>This option enables a predefined, named set of custom instruction encodings (see</source>
          <target state="translated">这个选项可以启用预定义的、命名的自定义指令编码集(见下图)。</target>
        </trans-unit>
        <trans-unit id="ba4e36ba668d3f1644121ffdad98a65c14adabae" translate="yes" xml:space="preserve">
          <source>This option enables an static analysis of program flow which looks for &amp;ldquo;interesting&amp;rdquo; interprocedural paths through the code, and issues warnings for problems found on them.</source>
          <target state="translated">此选项可对程序流进行静态分析，以通过代码寻找&amp;ldquo;有趣的&amp;rdquo;过程间路径，并对在其上发现的问题发出警告。</target>
        </trans-unit>
        <trans-unit id="d1bfbfd499b3c5f5bc13445a47161400b4906077" translate="yes" xml:space="preserve">
          <source>This option enables built-in functions &lt;code&gt;__builtin_ia32_crc32qi&lt;/code&gt;, &lt;code&gt;__builtin_ia32_crc32hi&lt;/code&gt;, &lt;code&gt;__builtin_ia32_crc32si&lt;/code&gt; and &lt;code&gt;__builtin_ia32_crc32di&lt;/code&gt; to generate the &lt;code&gt;crc32&lt;/code&gt; machine instruction.</source>
          <target state="translated">此选项启用内置函数 &lt;code&gt;__builtin_ia32_crc32qi&lt;/code&gt; ， &lt;code&gt;__builtin_ia32_crc32hi&lt;/code&gt; ， &lt;code&gt;__builtin_ia32_crc32si&lt;/code&gt; 和 &lt;code&gt;__builtin_ia32_crc32di&lt;/code&gt; 来生成 &lt;code&gt;crc32&lt;/code&gt; 机器指令。</target>
        </trans-unit>
        <trans-unit id="2cd918ec8f0e039c766cf7fe1d48f22e6df60ce4" translate="yes" xml:space="preserve">
          <source>This option enables checking of alignment of pointers when they are dereferenced, or when a reference is bound to insufficiently aligned target, or when a method or constructor is invoked on insufficiently aligned object.</source>
          <target state="translated">这个选项可以检查指针的对齐情况,当指针被解除引用时,或者当引用被绑定到未充分对齐的目标时,或者当方法或构造函数被调用到未充分对齐的对象上时。</target>
        </trans-unit>
        <trans-unit id="50199f80fe90cda9539f52ff8308973833026d26" translate="yes" xml:space="preserve">
          <source>This option enables checking that the result of a shift operation is not undefined. Note that what exactly is considered undefined differs slightly between C and C++, as well as between ISO C90 and C99, etc. This option has two suboptions,</source>
          <target state="translated">通过这个选项可以检查移位操作的结果是不是未定义的。请注意,到底什么是未定义,在C和C++之间,以及在ISO C90和C99等之间都略有不同。这个选项有两个子选项。</target>
        </trans-unit>
        <trans-unit id="85b4168b985dbcf1d69994ce5cb2c45b6d1daccb" translate="yes" xml:space="preserve">
          <source>This option enables checking that the second argument of a shift operation is not negative and is smaller than the precision of the promoted first argument.</source>
          <target state="translated">通过这个选项,可以检查移位操作的第二个参数是否为负值,是否小于被推广的第一个参数的精度。</target>
        </trans-unit>
        <trans-unit id="938ba4d02fa2f3fd34289d2d8d2d36eb752b42e2" translate="yes" xml:space="preserve">
          <source>This option enables floating-point type to integer conversion checking. We check that the result of the conversion does not overflow. Unlike other similar options,</source>
          <target state="translated">这个选项可以进行浮点型到整数型的转换检查。我们检查转换结果是否溢出。与其他类似选项不同。</target>
        </trans-unit>
        <trans-unit id="2be71ee2359ef67de5a090bb541bf4acc1394953" translate="yes" xml:space="preserve">
          <source>This option enables functions to be overloaded for ordinary and UTF-8 strings:</source>
          <target state="translated">这个选项可以让函数对普通和UTF-8字符串进行重载。</target>
        </trans-unit>
        <trans-unit id="f2c29fc89d033f54fcdc9384885989225fe300ca" translate="yes" xml:space="preserve">
          <source>This option enables generation of &lt;code&gt;SAHF&lt;/code&gt; instructions in 64-bit code. Early Intel Pentium 4 CPUs with Intel 64 support, prior to the introduction of Pentium 4 G1 step in December 2005, lacked the &lt;code&gt;LAHF&lt;/code&gt; and &lt;code&gt;SAHF&lt;/code&gt; instructions which are supported by AMD64. These are load and store instructions, respectively, for certain status flags. In 64-bit mode, the &lt;code&gt;SAHF&lt;/code&gt; instruction is used to optimize &lt;code&gt;fmod&lt;/code&gt;, &lt;code&gt;drem&lt;/code&gt;, and &lt;code&gt;remainder&lt;/code&gt; built-in functions; see &lt;a href=&quot;other-builtins#Other-Builtins&quot;&gt;Other Builtins&lt;/a&gt; for details.</source>
          <target state="translated">该选项允许以64位代码生成 &lt;code&gt;SAHF&lt;/code&gt; 指令。在2005年12月推出Pentium 4 G1步骤之前，支持Intel 64的早期Intel Pentium 4 CPU缺少AMD64支持的 &lt;code&gt;LAHF&lt;/code&gt; 和 &lt;code&gt;SAHF&lt;/code&gt; 指令。这些分别是某些状态标志的加载和存储指令。在64位模式下， &lt;code&gt;SAHF&lt;/code&gt; 指令用于优化 &lt;code&gt;fmod&lt;/code&gt; ， &lt;code&gt;drem&lt;/code&gt; 和 &lt;code&gt;remainder&lt;/code&gt; 内置函数。有关详细信息，请参见&lt;a href=&quot;other-builtins#Other-Builtins&quot;&gt;其他内置&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="bf9eedf73e4d0015fa244bb4f5c3569d74469415" translate="yes" xml:space="preserve">
          <source>This option enables instrumentation of C++ member function calls, member accesses and some conversions between pointers to base and derived classes, to verify the referenced object has the correct dynamic type.</source>
          <target state="translated">这个选项可以对C++成员函数调用、成员访问以及基类和派生类的指针之间的一些转换进行仪器检测,以验证被引用对象的动态类型是否正确。</target>
        </trans-unit>
        <trans-unit id="7dd18b0f972bb3a966564c3387d23513ed8f1114" translate="yes" xml:space="preserve">
          <source>This option enables instrumentation of arguments to selected builtin functions. If an invalid value is passed to such arguments, a run-time error is issued. E.g. passing 0 as the argument to &lt;code&gt;__builtin_ctz&lt;/code&gt; or &lt;code&gt;__builtin_clz&lt;/code&gt; invokes undefined behavior and is diagnosed by this option.</source>
          <target state="translated">此选项启用对选定内置函数的参数的检测。如果将无效值传递给此类参数，则会发出运行时错误。例如，将0用作 &lt;code&gt;__builtin_ctz&lt;/code&gt; 或 &lt;code&gt;__builtin_clz&lt;/code&gt; 的参数，则会调用未定义的行为，并通过此选项进行诊断。</target>
        </trans-unit>
        <trans-unit id="4707da904f3b017d856d15dd2d0965e19870e1d8" translate="yes" xml:space="preserve">
          <source>This option enables instrumentation of array bounds. Various out of bounds accesses are detected. Flexible array members, flexible array member-like arrays, and initializers of variables with static storage are not instrumented.</source>
          <target state="translated">这个选项可以实现对阵列边界的检测。检测各种越界访问。灵活的数组成员,灵活的类似数组成员的数组,以及具有静态存储的变量的初始化器都不会被检测到。</target>
        </trans-unit>
        <trans-unit id="2e349da95c57c4503e630d88b725ecb09ef50689" translate="yes" xml:space="preserve">
          <source>This option enables instrumentation of calls, checking whether null values are not passed to arguments marked as requiring a non-null value by the &lt;code&gt;nonnull&lt;/code&gt; function attribute.</source>
          <target state="translated">此选项启用调用检测，检查是否将null值不传递给 &lt;code&gt;nonnull&lt;/code&gt; 函数属性标记为需要非null值的参数。</target>
        </trans-unit>
        <trans-unit id="8d56bee13b4f38d072afa312adba62366dd96324" translate="yes" xml:space="preserve">
          <source>This option enables instrumentation of loads from an enum type. If a value outside the range of values for the enum type is loaded, a run-time error is issued.</source>
          <target state="translated">这个选项可以对来自枚举类型的负载进行仪表化。如果加载的数值超出了枚举类型的数值范围,则会发出运行时错误。</target>
        </trans-unit>
        <trans-unit id="8bae34f78ab33cc208a29bdcebb31b30f37fdfdb" translate="yes" xml:space="preserve">
          <source>This option enables instrumentation of loads from bool. If a value other than 0/1 is loaded, a run-time error is issued.</source>
          <target state="translated">这个选项可以从bool中对负载进行仪表化。如果加载的值不是0/1,则会发出运行时错误。</target>
        </trans-unit>
        <trans-unit id="46c1b7dde6bdde5a1a374986dc5119119957fbe3" translate="yes" xml:space="preserve">
          <source>This option enables instrumentation of memory references using the &lt;code&gt;__builtin_object_size&lt;/code&gt; function. Various out of bounds pointer accesses are detected.</source>
          <target state="translated">此选项使用 &lt;code&gt;__builtin_object_size&lt;/code&gt; 函数启用对内存引用的检测。检测到各种超出范围的指针访问。</target>
        </trans-unit>
        <trans-unit id="0292138149978c95eacc8642af7ff43cfe7b2264" translate="yes" xml:space="preserve">
          <source>This option enables instrumentation of pointer arithmetics. If the pointer arithmetics overflows, a run-time error is issued.</source>
          <target state="translated">这个选项可以实现指针算术的仪器化。如果指针算术溢出,就会发出一个运行时错误。</target>
        </trans-unit>
        <trans-unit id="430110abdd161cbe658a0d2f529325e1208cd453" translate="yes" xml:space="preserve">
          <source>This option enables instrumentation of return statements in functions marked with &lt;code&gt;returns_nonnull&lt;/code&gt; function attribute, to detect returning of null values from such functions.</source>
          <target state="translated">通过此选项，可以在标记有 &lt;code&gt;returns_nonnull&lt;/code&gt; 函数属性的函数中检测return语句，以检测从此类函数返回空值。</target>
        </trans-unit>
        <trans-unit id="cb16ef94b917da96c006db5cf05527388bed65b9" translate="yes" xml:space="preserve">
          <source>This option enables or disables warnings about conflicts between the MCU name specified by the</source>
          <target state="translated">这个选项可以启用或停用关于MCU名称冲突的警告。</target>
        </trans-unit>
        <trans-unit id="f864b078493b6651bb86e363b143af67066fe079" translate="yes" xml:space="preserve">
          <source>This option enables pointer checking. Particularly, the application built with this option turned on will issue an error message when it tries to dereference a NULL pointer, or if a reference (possibly an rvalue reference) is bound to a NULL pointer, or if a method is invoked on an object pointed by a NULL pointer.</source>
          <target state="translated">这个选项可以启用指针检查。特别是,当应用程序试图取消引用一个NULL指针时,或者当一个引用(可能是一个rvalue引用)被绑定到一个NULL指针上时,或者当一个方法被调用到一个NULL指针指向的对象上时,使用该选项构建的应用程序将发出错误信息。</target>
        </trans-unit>
        <trans-unit id="9390f84ab3c6840aa43bf14f385886239ff26f9c" translate="yes" xml:space="preserve">
          <source>This option enables return statement checking. Programs built with this option turned on will issue an error message when the end of a non-void function is reached without actually returning a value. This option works in C++ only.</source>
          <target state="translated">这个选项可以启用返回语句检查。启用该选项后,当程序在没有实际返回值的情况下到达一个非void函数的终点时,会发出错误信息。这个选项只在C++中有效。</target>
        </trans-unit>
        <trans-unit id="c5e06b2ed5aaf18ef55b254444b859dc73b64e5e" translate="yes" xml:space="preserve">
          <source>This option enables signed integer overflow checking. We check that the result of &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, and both unary and binary &lt;code&gt;-&lt;/code&gt; does not overflow in the signed arithmetics. Note, integer promotion rules must be taken into account. That is, the following is not an overflow:</source>
          <target state="translated">此选项启用有符号整数溢出检查。我们检查 &lt;code&gt;+&lt;/code&gt; ， &lt;code&gt;*&lt;/code&gt; 以及一元和二进制的结果 &lt;code&gt;-&lt;/code&gt; 不会在有符号算术中溢出。注意，必须考虑整数促销规则。也就是说，以下不是溢出：</target>
        </trans-unit>
        <trans-unit id="5aa6ebd08f1df0b8312082dee55c79f646e3aa80" translate="yes" xml:space="preserve">
          <source>This option enables strict instrumentation of array bounds. Most out of bounds accesses are detected, including flexible array members and flexible array member-like arrays. Initializers of variables with static storage are not instrumented.</source>
          <target state="translated">这个选项可以对数组边界进行严格的检测。大多数越界访问都会被检测到,包括灵活的数组成员和灵活的数组成员类数组。静态存储变量的初始化器不会被检测到。</target>
        </trans-unit>
        <trans-unit id="35547d9fdeedd115e10a5da6add0bd1af02febf6" translate="yes" xml:space="preserve">
          <source>This option enables the extraction of object files with GIMPLE bytecode out of library archives. This improves the quality of optimization by exposing more code to the link-time optimizer. This information specifies what symbols can be accessed externally (by non-LTO object or during dynamic linking). Resulting code quality improvements on binaries (and shared libraries that use hidden visibility) are similar to</source>
          <target state="translated">此选项可以从库存档中提取带有 GIMPLE 字节码的对象文件。这可以通过将更多代码暴露给链接时间优化器来提高优化质量。这些信息指定了哪些符号可以从外部访问(通过非LTO对象或在动态链接期间)。结果在二进制文件(和使用隐藏可见性的共享库)上的代码质量改进类似于</target>
        </trans-unit>
        <trans-unit id="aff42a7c223b12e8af263b78f8decfd79d138482" translate="yes" xml:space="preserve">
          <source>This option enables transitivity of constraints within the analyzer.</source>
          <target state="translated">这个选项可以使分析器内的约束条件具有转折性。</target>
        </trans-unit>
        <trans-unit id="e139de52e12e355ab2f4aceaceda024599afb6f0" translate="yes" xml:space="preserve">
          <source>This option enables use of &lt;code&gt;RCPSS&lt;/code&gt; and &lt;code&gt;RSQRTSS&lt;/code&gt; instructions (and their vectorized variants &lt;code&gt;RCPPS&lt;/code&gt; and &lt;code&gt;RSQRTPS&lt;/code&gt;) with an additional Newton-Raphson step to increase precision instead of &lt;code&gt;DIVSS&lt;/code&gt; and &lt;code&gt;SQRTSS&lt;/code&gt; (and their vectorized variants) for single-precision floating-point arguments. These instructions are generated only when</source>
          <target state="translated">此选项允许使用的 &lt;code&gt;RCPSS&lt;/code&gt; 和 &lt;code&gt;RSQRTSS&lt;/code&gt; 指令（以及它们的变体矢量 &lt;code&gt;RCPPS&lt;/code&gt; 和 &lt;code&gt;RSQRTPS&lt;/code&gt; ）与另外的牛顿-拉夫逊步骤增加精度而不是 &lt;code&gt;DIVSS&lt;/code&gt; 和 &lt;code&gt;SQRTSS&lt;/code&gt; （以及它们的变体矢量）用于单精度浮点参数。这些指令仅在以下情况下生成</target>
        </trans-unit>
        <trans-unit id="060df32e86c55ba7cad1df047f45c9f196518594" translate="yes" xml:space="preserve">
          <source>This option enables use of the &lt;code&gt;movbe&lt;/code&gt; instruction to implement &lt;code&gt;__builtin_bswap32&lt;/code&gt; and &lt;code&gt;__builtin_bswap64&lt;/code&gt;.</source>
          <target state="translated">通过此选项，可以使用 &lt;code&gt;movbe&lt;/code&gt; 指令来实现 &lt;code&gt;__builtin_bswap32&lt;/code&gt; 和 &lt;code&gt;__builtin_bswap64&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3be41468437cbd33ddbb5938cf95baa409134252" translate="yes" xml:space="preserve">
          <source>This option enables use of the reciprocal estimate and reciprocal square root estimate instructions with additional Newton-Raphson steps to increase precision instead of doing a divide or square root and divide for floating-point arguments. You should use the</source>
          <target state="translated">通过该选项,可以使用往复估计和往复平方根估计指令以及额外的牛顿-拉弗森步骤来提高精度,而不是对浮点参数进行除法或平方根和除法。您应该使用</target>
        </trans-unit>
        <trans-unit id="b8b0cc8f7ad08d6547ab80b77c947a16db351cd7" translate="yes" xml:space="preserve">
          <source>This option forces GCC to use custom shadow offset in AddressSanitizer checks. It is useful for experimenting with different shadow memory layouts in Kernel AddressSanitizer.</source>
          <target state="translated">这个选项强制GCC在AddressSanitizer检查中使用自定义影子偏移。这对于在Kernel AddressSanitizer中试验不同的影子内存布局很有用。</target>
        </trans-unit>
        <trans-unit id="3233daa383d4066b02b1657216dd534dd8974913" translate="yes" xml:space="preserve">
          <source>This option generates traps for signed overflow on addition, subtraction, multiplication operations. The options</source>
          <target state="translated">这个选项会在加减乘除操作时产生有符号溢出的陷阱。选项</target>
        </trans-unit>
        <trans-unit id="bc361006809087722b4665eda3af889c660cf7bb" translate="yes" xml:space="preserve">
          <source>This option has no effect on abicalls code. The default is</source>
          <target state="translated">这个选项对abicalls代码没有影响。默认值是</target>
        </trans-unit>
        <trans-unit id="ce202009f104c41c762f668a2d6d18c3bbd55f2a" translate="yes" xml:space="preserve">
          <source>This option ignored; it is provided for compatibility purposes only. Software floating-point code is emitted by default, and this default can overridden by FPX options;</source>
          <target state="translated">这个选项被忽略;它只是为了兼容性而提供的。默认情况下,软件浮点代码会发出,这个默认值可以被FPX选项覆盖。</target>
        </trans-unit>
        <trans-unit id="d295e879be9d8d469fabe64723a6a09c1d8dadcc" translate="yes" xml:space="preserve">
          <source>This option implies</source>
          <target state="translated">该选项意味着</target>
        </trans-unit>
        <trans-unit id="8ef84b2b0112928af774bc0bf4f11244d39995fa" translate="yes" xml:space="preserve">
          <source>This option inhibits the use of 68020 and 68881/68882 instructions that have to be emulated by software on the 68060. Use this option if your 68060 does not have code to emulate those instructions.</source>
          <target state="translated">此选项禁止使用68020和68881/68882指令,这些指令必须由68060上的软件来模拟。如果你的68060没有模拟这些指令的代码,请使用该选项。</target>
        </trans-unit>
        <trans-unit id="efb405ef4149f232764b47255e26eb73c1775fc9" translate="yes" xml:space="preserve">
          <source>This option inhibits the use of 68881/68882 instructions that have to be emulated by software on the 68040. Use this option if your 68040 does not have code to emulate those instructions.</source>
          <target state="translated">此选项禁止使用必须由68040上的软件模拟的68881/68882指令。如果你的68040没有模拟这些指令的代码,请使用该选项。</target>
        </trans-unit>
        <trans-unit id="e0c66bcd77c8bed54eff907c145c1ea37c3f6555" translate="yes" xml:space="preserve">
          <source>This option instructs CPP to add a phony target for each dependency other than the main file, causing each to depend on nothing. These dummy rules work around errors &lt;code&gt;make&lt;/code&gt; gives if you remove header files without updating the</source>
          <target state="translated">此选项指示CPP为除主文件以外的每个依赖项添加一个假目标，从而使每个依赖项均不依赖任何内容。这些假规则将避开错误 &lt;code&gt;make&lt;/code&gt; 给人如果删除头文件时不更新</target>
        </trans-unit>
        <trans-unit id="3c687d2d1d2116a0ccc32795fd0f0f68e88ed641" translate="yes" xml:space="preserve">
          <source>This option instructs GCC to dump the names of the x86 performance tuning features and default settings. The names can be used in</source>
          <target state="translated">这个选项指示GCC转储x86性能调整特性和默认设置的名称。这些名称可以用在</target>
        </trans-unit>
        <trans-unit id="38a021cb20751050e831beceef3d4668ce4cf298" translate="yes" xml:space="preserve">
          <source>This option instructs GCC to emit a &lt;code&gt;cld&lt;/code&gt; instruction in the prologue of functions that use string instructions. String instructions depend on the DF flag to select between autoincrement or autodecrement mode. While the ABI specifies the DF flag to be cleared on function entry, some operating systems violate this specification by not clearing the DF flag in their exception dispatchers. The exception handler can be invoked with the DF flag set, which leads to wrong direction mode when string instructions are used. This option can be enabled by default on 32-bit x86 targets by configuring GCC with the</source>
          <target state="translated">该选项指示GCC 在使用字符串指令的函数的序言中发出 &lt;code&gt;cld&lt;/code&gt; 指令。字符串指令取决于DF标志，以在自动递增或自动递减模式之间进行选择。尽管ABI指定要在函数输入时清除DF标志，但某些操作系统通过不清除其异常分派器中的DF标志来违反此规范。可以使用DF标志集来调用异常处理程序，当使用字符串指令时，这会导致错误的方向模式。默认情况下，可以通过使用以下命令配置GCC在32位x86目标上启用此选项：</target>
        </trans-unit>
        <trans-unit id="657b508727e487887f711193a95e39499f48960e" translate="yes" xml:space="preserve">
          <source>This option instructs GCC to emit a &lt;code&gt;vzeroupper&lt;/code&gt; instruction before a transfer of control flow out of the function to minimize the AVX to SSE transition penalty as well as remove unnecessary &lt;code&gt;zeroupper&lt;/code&gt; intrinsics.</source>
          <target state="translated">此选项指示GCC 在控制流从该函数移出之前发出 &lt;code&gt;vzeroupper&lt;/code&gt; 指令，以最小化AVX到SSE的转换损失并删除不必要的 &lt;code&gt;zeroupper&lt;/code&gt; 内部函数。</target>
        </trans-unit>
        <trans-unit id="3c78872fcf66a452b582423621f5fae766269c85" translate="yes" xml:space="preserve">
          <source>This option instructs GCC to turn off all tunable features. See also</source>
          <target state="translated">这个选项指示GCC关闭所有的可调整功能。参见</target>
        </trans-unit>
        <trans-unit id="3d9dd501c30e561cb69d40cbc9373ad471302725" translate="yes" xml:space="preserve">
          <source>This option instructs GCC to use 128-bit AVX instructions instead of 256-bit AVX instructions in the auto-vectorizer.</source>
          <target state="translated">这个选项指示GCC在自动矢量化器中使用128位AVX指令而不是256位AVX指令。</target>
        </trans-unit>
        <trans-unit id="e6945bdd3deb13214c6bf659bc52045e04a70f0e" translate="yes" xml:space="preserve">
          <source>This option instructs GCC to use &lt;var&gt;opt&lt;/var&gt;-bit vector width in instructions instead of default on the selected platform.</source>
          <target state="translated">该选项指示GCC 在指令中使用 &lt;var&gt;opt&lt;/var&gt; -bit向量宽度，而不是所选平台上的默认值。</target>
        </trans-unit>
        <trans-unit id="dbda0a70a5f352dad89f90d04caa28e3bd6d0703" translate="yes" xml:space="preserve">
          <source>This option instructs the compiler to assume that pointer arithmetic overflow on addition and subtraction wraps around using twos-complement representation. This flag disables some optimizations which assume pointer overflow is invalid.</source>
          <target state="translated">这个选项指示编译器假设加减法的指针算术溢出使用双补码表示。这个标志可以禁用一些假设指针溢出无效的优化。</target>
        </trans-unit>
        <trans-unit id="f816312ce41ee12df0f414176d9a5763b90df530" translate="yes" xml:space="preserve">
          <source>This option instructs the compiler to assume that signed arithmetic overflow of addition, subtraction and multiplication wraps around using twos-complement representation. This flag enables some optimizations and disables others. The options</source>
          <target state="translated">这个选项指示编译器假设加、减、乘法的有符号算术溢出使用双补码表示。这个标志可以启用一些优化,禁用其他优化。选项</target>
        </trans-unit>
        <trans-unit id="c431c0c08a8246794b17639d38f5f9732adef200" translate="yes" xml:space="preserve">
          <source>This option instructs the compiler to check that the size of a variable length array is positive.</source>
          <target state="translated">这个选项指示编译器检查可变长度数组的大小是否为正值。</target>
        </trans-unit>
        <trans-unit id="0d3ab8d594e88fea27629172c62534cedd7e9ccd" translate="yes" xml:space="preserve">
          <source>This option instructs the compiler to generate code for a 16-entry register file. This option defines the &lt;code&gt;__ARC_RF16__&lt;/code&gt; preprocessor macro.</source>
          <target state="translated">该选项指示编译器为16项寄存器文件生成代码。此选项定义 &lt;code&gt;__ARC_RF16__&lt;/code&gt; 预处理程序宏。</target>
        </trans-unit>
        <trans-unit id="b138f51e639bc0b32ca1dc63d0195b9a7cfb2e6c" translate="yes" xml:space="preserve">
          <source>This option is a detailed version of</source>
          <target state="translated">这个选项是详细版的</target>
        </trans-unit>
        <trans-unit id="0777795174f336ed7d700a302e0b548f3225ecd3" translate="yes" xml:space="preserve">
          <source>This option is also passed on to the assembler.</source>
          <target state="translated">这个选项也会传递给汇编者。</target>
        </trans-unit>
        <trans-unit id="0a8a587d88750f4b64f0573d837060922995e692" translate="yes" xml:space="preserve">
          <source>This option is always enabled by default on certain machines, usually those which have no call-preserved registers to use instead.</source>
          <target state="translated">这个选项在某些机器上总是默认启用,通常是那些没有调用保留寄存器的机器。</target>
        </trans-unit>
        <trans-unit id="87c9194e0e60c9d507f16257e56fa4da6140cc2a" translate="yes" xml:space="preserve">
          <source>This option is available for Cygwin and MinGW targets. It specifies that a DLL&amp;mdash;a dynamic link library&amp;mdash;is to be generated, enabling the selection of the required runtime startup object and entry point.</source>
          <target state="translated">此选项可用于Cygwin和MinGW目标。它指定将生成DLL（动态链接库），从而可以选择所需的运行时启动对象和入口点。</target>
        </trans-unit>
        <trans-unit id="34974b8a3ddccb37978e6f7f3ab9b870fb775b53" translate="yes" xml:space="preserve">
          <source>This option is available for Cygwin and MinGW targets. It specifies that a GUI application is to be generated by instructing the linker to set the PE header subsystem type appropriately.</source>
          <target state="translated">这个选项适用于Cygwin和MinGW目标。它指定通过指示链接器适当地设置PE头子系统类型来生成GUI应用程序。</target>
        </trans-unit>
        <trans-unit id="f9c956bb65a4ef29b2924781000ede172dfe35c9" translate="yes" xml:space="preserve">
          <source>This option is available for Cygwin and MinGW targets. It specifies that the &lt;code&gt;dllimport&lt;/code&gt; attribute should be ignored.</source>
          <target state="translated">此选项可用于Cygwin和MinGW目标。它指定应忽略 &lt;code&gt;dllimport&lt;/code&gt; 属性。</target>
        </trans-unit>
        <trans-unit id="7e0dc3ae21d5985659301b368b4c95c1db9366f7" translate="yes" xml:space="preserve">
          <source>This option is available for Cygwin and MinGW targets. It specifies that the GNU extension to the PE file format that permits the correct alignment of COMMON variables should be used when generating code. It is enabled by default if GCC detects that the target assembler found during configuration supports the feature.</source>
          <target state="translated">这个选项适用于Cygwin和MinGW目标。它指定在生成代码时,应该使用允许COMMON变量正确对齐的PE文件格式的GNU扩展。如果GCC检测到在配置过程中找到的目标汇编器支持该功能,则默认启用该选项。</target>
        </trans-unit>
        <trans-unit id="9161324109587b09b1694f29c23c72102885dbb9" translate="yes" xml:space="preserve">
          <source>This option is available for Cygwin and MinGW targets. It specifies that the typical Microsoft Windows predefined macros are to be set in the pre-processor, but does not influence the choice of runtime library/startup code.</source>
          <target state="translated">该选项适用于Cygwin和MinGW目标。它指定在预处理器中设置典型的Microsoft Windows预定义宏,但不影响运行时库/启动代码的选择。</target>
        </trans-unit>
        <trans-unit id="9e0a3afbd291f88cb3c95726f31687bd36f164b7" translate="yes" xml:space="preserve">
          <source>This option is available for MinGW and Cygwin targets. It specifies that relocated-data in read-only section is put into the &lt;code&gt;.data&lt;/code&gt; section. This is a necessary for older runtimes not supporting modification of &lt;code&gt;.rdata&lt;/code&gt; sections for pseudo-relocation.</source>
          <target state="translated">此选项可用于MinGW和Cygwin目标。它指定将只读节中的重定位数据放入 &lt;code&gt;.data&lt;/code&gt; 节中。对于较早的运行时，这是必需的，因为不支持修改 &lt;code&gt;.rdata&lt;/code&gt; 节以进行伪重定位。</target>
        </trans-unit>
        <trans-unit id="acdd2b492fbf0ebaa317f2c48f132b3b62ecde92" translate="yes" xml:space="preserve">
          <source>This option is available for MinGW targets. It specifies that MinGW-specific thread support is to be used.</source>
          <target state="translated">该选项适用于MinGW目标。它指定要使用MinGW特定的线程支持。</target>
        </trans-unit>
        <trans-unit id="faee952b0f4c06ee910b880bfbdf149d4685f355" translate="yes" xml:space="preserve">
          <source>This option is available for MinGW targets. It specifies that the executable flag for the stack used by nested functions isn&amp;rsquo;t set. This is necessary for binaries running in kernel mode of Microsoft Windows, as there the User32 API, which is used to set executable privileges, isn&amp;rsquo;t available.</source>
          <target state="translated">此选项可用于MinGW目标。它指定未设置嵌套函数使用的堆栈的可执行标志。这对于以Microsoft Windows内核模式运行的二进制文件是必需的，因为那里没有用于设置可执行特权的User32 API。</target>
        </trans-unit>
        <trans-unit id="e934759656573ab06e7b01542f8d07b3197cbe74" translate="yes" xml:space="preserve">
          <source>This option is available for MinGW-w64 targets. It causes the &lt;code&gt;UNICODE&lt;/code&gt; preprocessor macro to be predefined, and chooses Unicode-capable runtime startup code.</source>
          <target state="translated">此选项可用于MinGW-w64目标。它使 &lt;code&gt;UNICODE&lt;/code&gt; 预处理器宏被预定义，并选择支持Unicode的运行时启动代码。</target>
        </trans-unit>
        <trans-unit id="d398f6bbd65088d4b5a66179b5d137a011940d08" translate="yes" xml:space="preserve">
          <source>This option is deprecated and has no effect.</source>
          <target state="translated">这个选项已经废弃,没有任何效果。</target>
        </trans-unit>
        <trans-unit id="2059e693abf7ce7ec777bf5e7cc1b18ffae32137" translate="yes" xml:space="preserve">
          <source>This option is deprecated.</source>
          <target state="translated">此选项已被废弃。</target>
        </trans-unit>
        <trans-unit id="aabeb9acbf850798bff5dd7ad77029ce8ab9ac73" translate="yes" xml:space="preserve">
          <source>This option is deprecated. It pads structures to multiple of 4 bytes, which is incompatible with the SH ABI.</source>
          <target state="translated">这个选项已被废弃。它将结构填充到4字节的倍数,这与SH ABI不兼容。</target>
        </trans-unit>
        <trans-unit id="9d29c4b41311afb57bb108b16e155cb489ec134b" translate="yes" xml:space="preserve">
          <source>This option is deprecated. Use</source>
          <target state="translated">此选项已被废弃。使用</target>
        </trans-unit>
        <trans-unit id="4053a3fd19d3968881e6f8e01595ecadbdd30069" translate="yes" xml:space="preserve">
          <source>This option is enabled at level</source>
          <target state="translated">该选项在以下级别启用</target>
        </trans-unit>
        <trans-unit id="bf488b640ab82c12aa83d2d5d585a8acb0774751" translate="yes" xml:space="preserve">
          <source>This option is enabled by</source>
          <target state="translated">启用该选项的方法是</target>
        </trans-unit>
        <trans-unit id="1157d5cea597fdcb95a42f4efe9767ae5da67d67" translate="yes" xml:space="preserve">
          <source>This option is enabled by default at</source>
          <target state="translated">该选项默认在</target>
        </trans-unit>
        <trans-unit id="1a1ed53d314baadd464fa2b14f3800bf95fa8ca0" translate="yes" xml:space="preserve">
          <source>This option is enabled by default at optimization levels</source>
          <target state="translated">该选项默认在优化级别启用</target>
        </trans-unit>
        <trans-unit id="d247bcb1695bed692a8726f3533be3d2fb1fee0b" translate="yes" xml:space="preserve">
          <source>This option is enabled by default for Microsoft Windows targets. This behavior can also be controlled locally by use of variable or type attributes. For more information, see &lt;a href=&quot;variable-attributes#x86-Variable-Attributes&quot;&gt;x86 Variable Attributes&lt;/a&gt; and &lt;a href=&quot;type-attributes#x86-Type-Attributes&quot;&gt;x86 Type Attributes&lt;/a&gt;.</source>
          <target state="translated">默认情况下，对于Microsoft Windows目标启用此选项。也可以通过使用变量或类型属性在本地控制此行为。有关更多信息，请参见&lt;a href=&quot;variable-attributes#x86-Variable-Attributes&quot;&gt;x86变量属性&lt;/a&gt;和&lt;a href=&quot;type-attributes#x86-Type-Attributes&quot;&gt;x86类型属性&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2652d68534c6f88541191086fa1485e27def7fc6" translate="yes" xml:space="preserve">
          <source>This option is enabled by default on most targets. On Nios II ELF, it defaults to off. On AVR, CR16, and MSP430, this option is completely disabled.</source>
          <target state="translated">在大多数目标上,该选项默认为启用。在Nios II ELF上,它默认为关闭。在AVR、CR16和MSP430上,该选项完全被禁用。</target>
        </trans-unit>
        <trans-unit id="3d8c17f97f0a71b6e6913867ec6d9569fa353e80" translate="yes" xml:space="preserve">
          <source>This option is enabled by default when LTO support in GCC is enabled and GCC was configured for use with a linker supporting plugins (GNU ld 2.21 or newer or gold).</source>
          <target state="translated">当GCC中的LTO支持被启用,并且GCC被配置为与支持插件的链接器(GNU ld 2.21或更新版或gold)一起使用时,该选项默认被启用。</target>
        </trans-unit>
        <trans-unit id="7d53846e4ad58929426e4a8a561e1ca04e4dae26" translate="yes" xml:space="preserve">
          <source>This option is enabled by default when the RH850 ABI is in use (see</source>
          <target state="translated">当使用 RH850 ABI 时,该选项默认启用(请参见第 2 页)。</target>
        </trans-unit>
        <trans-unit id="e8f3025aa92d2d4f667e2309b49f93dcbd8a2cc1" translate="yes" xml:space="preserve">
          <source>This option is experimental and does not currently guarantee to disable all GCC optimizations that affect signaling NaN behavior.</source>
          <target state="translated">这个选项是实验性的,目前并不能保证禁用所有影响信令NaN行为的GCC优化。</target>
        </trans-unit>
        <trans-unit id="6bf7bb3d6ca95f65181405f388dc4f38acb33184" translate="yes" xml:space="preserve">
          <source>This option is experimental and does not currently guarantee to disable all GCC optimizations that are affected by rounding mode. Future versions of GCC may provide finer control of this setting using C99&amp;rsquo;s &lt;code&gt;FENV_ACCESS&lt;/code&gt; pragma. This command-line option will be used to specify the default state for &lt;code&gt;FENV_ACCESS&lt;/code&gt;.</source>
          <target state="translated">此选项是实验性的，当前不保证禁用所有受舍入模式影响的GCC优化。将来的GCC版本可以使用C99的 &lt;code&gt;FENV_ACCESS&lt;/code&gt; 编译指示更好地控制此设置。此命令行选项将用于指定 &lt;code&gt;FENV_ACCESS&lt;/code&gt; 的默认状态。</target>
        </trans-unit>
        <trans-unit id="41c5b1ff9a4b2c16f0283cc8b3e6a1c1ee4e99a0" translate="yes" xml:space="preserve">
          <source>This option is experimental and the format of the data within the compressed JSON file is subject to change.</source>
          <target state="translated">这个选项是试验性的,压缩后的JSON文件中的数据格式可能会改变。</target>
        </trans-unit>
        <trans-unit id="77c067b7272c8dfb1940d673f7549a9c970673d8" translate="yes" xml:space="preserve">
          <source>This option is ignored and provided for compatibility purposes only.</source>
          <target state="translated">此选项被忽略,仅为兼容性目的而提供。</target>
        </trans-unit>
        <trans-unit id="988bc726815f60352325aa80e3adb73dc59e56eb" translate="yes" xml:space="preserve">
          <source>This option is ignored; it is for compatibility purposes only. This used to select linker and preprocessor options for use with newlib.</source>
          <target state="translated">此选项被忽略;它仅用于兼容性目的。该选项用于选择与newlib一起使用的链接器和预处理器选项。</target>
        </trans-unit>
        <trans-unit id="39bc415cf1072ef041b852cccab7caeb03cebbe9" translate="yes" xml:space="preserve">
          <source>This option is implicitly passed to the compiler for the second compilation requested by</source>
          <target state="translated">这个选项会被隐式地传递给编译器,以便在第二次编译时由</target>
        </trans-unit>
        <trans-unit id="223090f1188ac1bc38c64fe292f4f4b2503fac75" translate="yes" xml:space="preserve">
          <source>This option is implied by</source>
          <target state="translated">这个选项是由</target>
        </trans-unit>
        <trans-unit id="d3193c2234bb7da293261732a9d8d77268c8fc1c" translate="yes" xml:space="preserve">
          <source>This option is intended for analyzer developers.</source>
          <target state="translated">这个选项是为分析器开发人员准备的。</target>
        </trans-unit>
        <trans-unit id="a6f2c53d2e68d97cb3dfd3ec9c7aa21718a8745f" translate="yes" xml:space="preserve">
          <source>This option is intended for analyzer developers. It enables more verbose, lower-level detail in the descriptions of control flow within diagnostic paths.</source>
          <target state="translated">这个选项是为分析器开发人员准备的。它使诊断路径中的控制流的描述更加详细、低级。</target>
        </trans-unit>
        <trans-unit id="d656b9a9c9fb5f6bcdc2b59dc196d049700bd1b2" translate="yes" xml:space="preserve">
          <source>This option is intended for analyzer developers. It enables more verbose, lower-level detail in the descriptions of events relating to state machines within diagnostic paths.</source>
          <target state="translated">这个选项是为分析器开发人员准备的。它使诊断路径中与状态机有关的事件描述更加详细、低层次。</target>
        </trans-unit>
        <trans-unit id="4f67300ba0c3c74acfb2d8150e18a2987b0d6f05" translate="yes" xml:space="preserve">
          <source>This option is intended for analyzer developers: if multiple diagnostics have been detected as being duplicates of each other, it emits a note when reporting the best diagnostic, giving the number of additional diagnostics that were suppressed by the deduplication logic.</source>
          <target state="translated">这个选项是为分析器开发人员准备的:如果检测到多个诊断程序相互重复,它在报告最佳诊断程序时就会发出一个说明,给出被重复数据删除逻辑抑制的额外诊断程序的数量。</target>
        </trans-unit>
        <trans-unit id="9711864ac531d244797123498f9a9fe143b47ace" translate="yes" xml:space="preserve">
          <source>This option is left for compatibility reasons.</source>
          <target state="translated">由于兼容性的原因,此选项被保留。</target>
        </trans-unit>
        <trans-unit id="705dd214fcbbda555d2c25430996631d43106884" translate="yes" xml:space="preserve">
          <source>This option is like the</source>
          <target state="translated">这个选项就像</target>
        </trans-unit>
        <trans-unit id="7ea37451ed423d9b4f565d2cd48781668a2b5f65" translate="yes" xml:space="preserve">
          <source>This option is not turned on by any</source>
          <target state="translated">该选项没有被任何</target>
        </trans-unit>
        <trans-unit id="9abb00a56e1a1d91dc73fdc3ecd2a22dd97e1ddc" translate="yes" xml:space="preserve">
          <source>This option is off by default, because the resulting preprocessed output is only really suitable as input to GCC. It is switched on by</source>
          <target state="translated">这个选项默认是关闭的,因为最终的预处理输出只适合作为GCC的输入。这个选项可以通过</target>
        </trans-unit>
        <trans-unit id="4f3ef2c8071d14f453caa189ada503a69384e247" translate="yes" xml:space="preserve">
          <source>This option is only active when</source>
          <target state="translated">该选项仅在以下情况下有效</target>
        </trans-unit>
        <trans-unit id="a6188b363cf7403f6936d8ff4d2c56a28d236e61" translate="yes" xml:space="preserve">
          <source>This option is only active when signed overflow is undefined. It warns about cases where the compiler optimizes based on the assumption that signed overflow does not occur. Note that it does not warn about all cases where the code might overflow: it only warns about cases where the compiler implements some optimization. Thus this warning depends on the optimization level.</source>
          <target state="translated">这个选项只有在未定义signed overflow时才有效。它对编译器基于不发生签名溢出的假设进行优化的情况发出警告。请注意,它并不是对所有代码可能溢出的情况发出警告:它只对编译器实现某些优化的情况发出警告。因此这个警告取决于优化级别。</target>
        </trans-unit>
        <trans-unit id="84e9b00e2175bed56ae8768cc7c1a2405f67103d" translate="yes" xml:space="preserve">
          <source>This option is only applicable when compiling for the base ARMv8.0 instruction set. If using a later revision, e.g.</source>
          <target state="translated">此选项仅适用于为基本 ARMv8.0 指令集编译时。如果使用较晚的版本,如</target>
        </trans-unit>
        <trans-unit id="9d25fc758589cd4be71db515ac5f7ca7241f83be" translate="yes" xml:space="preserve">
          <source>This option is only available for ARCv2 cores.</source>
          <target state="translated">该选项仅适用于ARCv2内核。</target>
        </trans-unit>
        <trans-unit id="bb2b96b2a317107a5bbb2f1d27d819613a30b1f8" translate="yes" xml:space="preserve">
          <source>This option is only available if GCC was configured with analyzer support enabled.</source>
          <target state="translated">只有在配置GCC时启用了分析器支持时,这个选项才可用。</target>
        </trans-unit>
        <trans-unit id="47efc2541291ec81a8db6b59aeed231c895bc9c4" translate="yes" xml:space="preserve">
          <source>This option is only available when compiling C++ code. It turns on (or off, if using</source>
          <target state="translated">这个选项只在编译C++代码时可用。它可以打开(或关闭,如果使用</target>
        </trans-unit>
        <trans-unit id="f33ea172ac2795eac5ebb478ce17a5afc41091f3" translate="yes" xml:space="preserve">
          <source>This option is only intended to be useful when developing GCC.</source>
          <target state="translated">这个选项只在开发GCC时有用。</target>
        </trans-unit>
        <trans-unit id="034517546050c1e22d79385d031d17520c531cb2" translate="yes" xml:space="preserve">
          <source>This option is only useful for debugging GCC. When used from CPP or with</source>
          <target state="translated">这个选项只对调试GCC有用。当从CPP或与</target>
        </trans-unit>
        <trans-unit id="05b6c3c24d858a91f50ac46c4cd92ae8eecb3f01" translate="yes" xml:space="preserve">
          <source>This option is passed to the assembler and linker, and allows the linker to perform certain optimizations that cannot be done until the final link.</source>
          <target state="translated">这个选项被传递给汇编器和链接器,并允许链接器执行某些优化,而这些优化在最终链接之前无法完成。</target>
        </trans-unit>
        <trans-unit id="b562e6b75c17a9e319c7220a396dd42baef9b10e" translate="yes" xml:space="preserve">
          <source>This option is supported from MIPS Release 6 onwards.</source>
          <target state="translated">从MIPS第6版开始支持这个选项。</target>
        </trans-unit>
        <trans-unit id="69521eee9b087ee047a6dc4f213a5e965016b754" translate="yes" xml:space="preserve">
          <source>This option is the default for optimized compilation if the assembler and linker support it. Use</source>
          <target state="translated">如果汇编器和链接器支持,这个选项是优化编译的默认选项。使用</target>
        </trans-unit>
        <trans-unit id="a6be6b9afb7bd451d149acef44e3204c0799fa3d" translate="yes" xml:space="preserve">
          <source>This option is used internally by the compiler to select and build multilibs for architectures &lt;code&gt;avr2&lt;/code&gt; and &lt;code&gt;avr25&lt;/code&gt;. These architectures mix devices with and without &lt;code&gt;SPH&lt;/code&gt;. For any setting other than</source>
          <target state="translated">编译器在内部使用此选项来选择和构建体系结构 &lt;code&gt;avr2&lt;/code&gt; 和 &lt;code&gt;avr25&lt;/code&gt; 的多重库。这些体系结构混合了有无 &lt;code&gt;SPH&lt;/code&gt; 的设备。适用于除</target>
        </trans-unit>
        <trans-unit id="929f4574a14bae8a52d6ca406bb8cbc25e260697" translate="yes" xml:space="preserve">
          <source>This option is used internally for multilib selection. It is not an optimization option, and you don&amp;rsquo;t need to set it by hand.</source>
          <target state="translated">此选项在内部用于multilib选择。它不是优化选项，您无需手动设置。</target>
        </trans-unit>
        <trans-unit id="7cc2eb8f428f100756f402b24615715e373e0e44" translate="yes" xml:space="preserve">
          <source>This option is used to compile and link code instrumented for coverage analysis. The option is a synonym for</source>
          <target state="translated">这个选项用于编译和链接被检测到的代码以进行覆盖率分析。该选项是以下选项的同义词</target>
        </trans-unit>
        <trans-unit id="48d0c19a39e93a3e805a541c3dbbe3e7dee413d8" translate="yes" xml:space="preserve">
          <source>This option is used to do fine grain control of x86 code generation features. &lt;var&gt;feature-list&lt;/var&gt; is a comma separated list of &lt;var&gt;feature&lt;/var&gt; names. See also</source>
          <target state="translated">此选项用于对x86代码生成功能进行精细控制。 &lt;var&gt;feature-list&lt;/var&gt; 是逗号分隔的 &lt;var&gt;feature&lt;/var&gt; 名称列表。也可以看看</target>
        </trans-unit>
        <trans-unit id="d9b5652a39108319ff242af91d4906cb16765dd8" translate="yes" xml:space="preserve">
          <source>This option isn&amp;rsquo;t effective unless you either provide profile feedback (see</source>
          <target state="translated">除非您提供个人资料反馈，否则此选项无效（请参阅</target>
        </trans-unit>
        <trans-unit id="fad34c4a13c209b4406d2d95140526d0990b695b" translate="yes" xml:space="preserve">
          <source>This option makes symbolic debugging impossible.</source>
          <target state="translated">这个选项使得符号调试无法进行。</target>
        </trans-unit>
        <trans-unit id="f70581e1a11d2a9335f77e119a8e847340333cc1" translate="yes" xml:space="preserve">
          <source>This option marks the generated code as IEEE conformant. You must not use this option unless you also specify</source>
          <target state="translated">这个选项将生成的代码标记为符合IEEE标准。除非你同时指定了</target>
        </trans-unit>
        <trans-unit id="15ded195f72714a7729c2ba3f65b232ddd1df723" translate="yes" xml:space="preserve">
          <source>This option may generate better or worse code; results are highly dependent on the structure of loops within the source code.</source>
          <target state="translated">这个选项可能会产生更好或更差的代码;结果高度依赖于源代码中循环的结构。</target>
        </trans-unit>
        <trans-unit id="aaf0c177eee46432379774f3339106e6fdf38879" translate="yes" xml:space="preserve">
          <source>This option only has an effect when optimizing for the VR4130. It normally makes code faster, but at the expense of making it bigger. It is enabled by default at optimization level</source>
          <target state="translated">这个选项只有在为VR4130优化时才有效果。它通常会使代码更快,但代价是使代码更大。在优化级别时,默认启用该选项</target>
        </trans-unit>
        <trans-unit id="ab6cda42cf644e48c433b85f306f3dac6f8ee9b8" translate="yes" xml:space="preserve">
          <source>This option passes on a request to assembler to enable the fixes for the named silicon errata.</source>
          <target state="translated">这个选项传递了对汇编器的请求,以启用指定硅勘误的修复。</target>
        </trans-unit>
        <trans-unit id="845f7cfd869d00c4405522a461f9c235cb5eee1d" translate="yes" xml:space="preserve">
          <source>This option passes on a request to the assembler to enable warning messages when a silicon errata might need to be applied.</source>
          <target state="translated">这个选项传递给汇编器一个请求,以便在可能需要应用硅勘误时启用警告信息。</target>
        </trans-unit>
        <trans-unit id="c17f45a4bb601880d3a1ed4ec74cc989340e16f4" translate="yes" xml:space="preserve">
          <source>This option prevents undesirable excess precision on machines such as the 68000 where the floating registers (of the 68881) keep more precision than a &lt;code&gt;double&lt;/code&gt; is supposed to have. Similarly for the x86 architecture. For most programs, the excess precision does only good, but a few programs rely on the precise definition of IEEE floating point. Use</source>
          <target state="translated">此选项可防止在诸如68000之类的机器上产生不必要的过高精度，例如6881，其浮动寄存器（68881）保持的精度比原本应该 &lt;code&gt;double&lt;/code&gt; 精度高。对于x86体系结构也是如此。对于大多数程序而言，多余的精度只会发挥作用，但是有些程序依赖于IEEE浮点数的精确定义。用</target>
        </trans-unit>
        <trans-unit id="85c0b69978ecc16b1bd0d2e9088bf661716f775e" translate="yes" xml:space="preserve">
          <source>This option provides a seed that GCC uses in place of random numbers in generating certain symbol names that have to be different in every compiled file. It is also used to place unique stamps in coverage data files and the object files that produce them. You can use the</source>
          <target state="translated">这个选项提供了一个种子,GCC用它来代替随机数,生成某些在每个编译文件中必须不同的符号名。它还用于在覆盖率数据文件和生成它们的对象文件中放置唯一的标记。您可以使用</target>
        </trans-unit>
        <trans-unit id="5d13842ae6ab4ca478a1a5e72b6a9207042790a6" translate="yes" xml:space="preserve">
          <source>This option provides additional information when printing control-flow paths associated with a diagnostic.</source>
          <target state="translated">当打印与诊断相关的控制流路径时,该选项提供了额外的信息。</target>
        </trans-unit>
        <trans-unit id="4fc311cf74252b7ed7aa80360e3b9606e9388cce" translate="yes" xml:space="preserve">
          <source>This option requires Newlib Nano IO, so GCC must be configured with &amp;lsquo;</source>
          <target state="translated">此选项需要Newlib Nano IO，因此必须为GCC配置&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="c9dc1b607f48375a6d4f6012661eaa5b1b5ed1be" translate="yes" xml:space="preserve">
          <source>This option results in less efficient code, but some strange hacks that alter the assembler output may be confused by the optimizations performed when this option is not used.</source>
          <target state="translated">这个选项会导致代码效率降低,但一些改变汇编器输出的奇怪黑客可能会被不使用这个选项时执行的优化所迷惑。</target>
        </trans-unit>
        <trans-unit id="c631110b4d2abceaccb1bae4ccf22e852178fc73" translate="yes" xml:space="preserve">
          <source>This option runs the standard link-time optimizer. When invoked with source code, it generates GIMPLE (one of GCC&amp;rsquo;s internal representations) and writes it to special ELF sections in the object file. When the object files are linked together, all the function bodies are read from these ELF sections and instantiated as if they had been part of the same translation unit.</source>
          <target state="translated">此选项运行标准的链接时间优化器。用源代码调用时，它会生成GIMPLE（GCC的内部表示形式之一）并将其写入目标文件中的特殊ELF节。将目标文件链接在一起时，将从这些ELF节中读取所有功能体，并将其实例化，就好像它们已属于同一翻译单元一样。</target>
        </trans-unit>
        <trans-unit id="42349550220727ae2e299d4a2015499909d245e5" translate="yes" xml:space="preserve">
          <source>This option should be used if accesses to volatile bit-fields (or other structure fields, although the compiler usually honors those types anyway) should use a single access of the width of the field&amp;rsquo;s type, aligned to a natural alignment if possible. For example, targets with memory-mapped peripheral registers might require all such accesses to be 16 bits wide; with this flag you can declare all peripheral bit-fields as &lt;code&gt;unsigned short&lt;/code&gt; (assuming short is 16 bits on these targets) to force GCC to use 16-bit accesses instead of, perhaps, a more efficient 32-bit access.</source>
          <target state="translated">如果访问易失性位字段（或其他结构字段，尽管编译器通常会使用这些类型的字段）应使用该字段类型宽度的单个访问，并在可能的情况下对齐自然对齐，则应使用此选项。例如，具有存储器映射外设寄存器的目标可能要求所有此类访问的宽度均为16位。使用此标志，您可以将所有外设位字段声明为 &lt;code&gt;unsigned short&lt;/code&gt; （假定这些目标上的short为16位），以强制GCC使用16位访问权限，而不是更有效的32位访问权限。</target>
        </trans-unit>
        <trans-unit id="7a6ef28258c0d1484a7407799fe40321a370f499" translate="yes" xml:space="preserve">
          <source>This option should never be turned on by any</source>
          <target state="translated">任何情况下都不应该开启该选项。</target>
        </trans-unit>
        <trans-unit id="701b657607612b9b9057df52c63d10c751e2ef8a" translate="yes" xml:space="preserve">
          <source>This option should not be used in combination with</source>
          <target state="translated">此选项不应与</target>
        </trans-unit>
        <trans-unit id="c0219c53e7274021b5f6207f588b3446cadfa388" translate="yes" xml:space="preserve">
          <source>This option significantly reduces the size of debugging information, with some potential loss in type information to the debugger. See</source>
          <target state="translated">这个选项大大减小了调试信息的大小,在类型信息上可能会给调试器带来一些损失。参见</target>
        </trans-unit>
        <trans-unit id="3ed6d18a71b1db6dc14656f8dda97ef522ec526e" translate="yes" xml:space="preserve">
          <source>This option specifies additional section names that can be accessed via GP-relative addressing. It is most useful in conjunction with &lt;code&gt;section&lt;/code&gt; attributes on variable declarations (see &lt;a href=&quot;common-variable-attributes#Common-Variable-Attributes&quot;&gt;Common Variable Attributes&lt;/a&gt;) and a custom linker script. The &lt;var&gt;regexp&lt;/var&gt; is a POSIX Extended Regular Expression.</source>
          <target state="translated">此选项指定可以通过GP相对寻址访问的其他节名称。与变量声明中的 &lt;code&gt;section&lt;/code&gt; 属性（请参阅&lt;a href=&quot;common-variable-attributes#Common-Variable-Attributes&quot;&gt;Common Variable Attributes&lt;/a&gt;）和自定义链接描述文件一起使用时，它最为有用。在 &lt;var&gt;regexp&lt;/var&gt; 是一个POSIX扩展正则表达式。</target>
        </trans-unit>
        <trans-unit id="66f5529b3cbbe7b599cd5d6be9976188f77dac0f" translate="yes" xml:space="preserve">
          <source>This option specifies names of sections that can be accessed via a 16-bit offset from &lt;code&gt;r0&lt;/code&gt;; that is, in the low 32K or high 32K of the 32-bit address space. It is most useful in conjunction with &lt;code&gt;section&lt;/code&gt; attributes on variable declarations (see &lt;a href=&quot;common-variable-attributes#Common-Variable-Attributes&quot;&gt;Common Variable Attributes&lt;/a&gt;) and a custom linker script. The &lt;var&gt;regexp&lt;/var&gt; is a POSIX Extended Regular Expression.</source>
          <target state="translated">此选项指定可以通过 &lt;code&gt;r0&lt;/code&gt; 的16位偏移量访问的节的名称；也就是说，在32位地址空间的低32K或高32K中。与变量声明中的 &lt;code&gt;section&lt;/code&gt; 属性（请参阅&lt;a href=&quot;common-variable-attributes#Common-Variable-Attributes&quot;&gt;Common Variable Attributes&lt;/a&gt;）和自定义链接描述文件一起使用时，它最为有用。在 &lt;var&gt;regexp&lt;/var&gt; 是一个POSIX扩展正则表达式。</target>
        </trans-unit>
        <trans-unit id="4f2c2ce6a978cb353a59c6932941834cbab3c970" translate="yes" xml:space="preserve">
          <source>This option specifies that a console application is to be generated, by instructing the linker to set the PE header subsystem type required for console applications. This option is available for Cygwin and MinGW targets and is enabled by default on those targets.</source>
          <target state="translated">这个选项通过指示链接器设置控制台应用程序所需的PE头子系统类型来指定要生成控制台应用程序。这个选项适用于Cygwin和MinGW目标,并在这些目标上默认启用。</target>
        </trans-unit>
        <trans-unit id="21795b6b968aeddf2d8b82bab0643ab8d796f517" translate="yes" xml:space="preserve">
          <source>This option specifies the &lt;var&gt;executable&lt;/var&gt; that will load the build output file being linked. See man ld(1) for more information.</source>
          <target state="translated">此选项指定将加载要链接的构建输出文件的 &lt;var&gt;executable&lt;/var&gt; 文件。有关更多信息，请参见man ld（1）。</target>
        </trans-unit>
        <trans-unit id="699a780e6b546e7cd31621b332df13065645e8b9" translate="yes" xml:space="preserve">
          <source>This option specifies the level of compression used for intermediate language written to LTO object files, and is only meaningful in conjunction with LTO mode (</source>
          <target state="translated">这个选项指定了写到LTO对象文件中的中间语言所使用的压缩程度,并且只在与LTO模式(</target>
        </trans-unit>
        <trans-unit id="a52135fd3bb8dd77ca2f36e74d648a4fe294ca69" translate="yes" xml:space="preserve">
          <source>This option specifies the name of the target ARM processor for which GCC should tune the performance of the code. For some ARM implementations better performance can be obtained by using this option. Permissible names are: &amp;lsquo;</source>
          <target state="translated">此选项指定GCC为其调整代码性能的目标ARM处理器的名称。对于某些ARM实现，可以使用此选项获得更好的性能。允许的名称为：'</target>
        </trans-unit>
        <trans-unit id="0092bbb4f5a1fce13bf85587ba520d02478db7fa" translate="yes" xml:space="preserve">
          <source>This option specifies where to find the executables, libraries, include files, and data files of the compiler itself.</source>
          <target state="translated">这个选项指定在哪里可以找到编译器本身的可执行文件、库、包含文件和数据文件。</target>
        </trans-unit>
        <trans-unit id="34fcd55b8224119aadeadea926ce6d80328cc8e5" translate="yes" xml:space="preserve">
          <source>This option substantially reduces the size of debugging information, but at significant potential loss in type information to the debugger. See</source>
          <target state="translated">这个选项大大减少了调试信息的大小,但对调试器来说,可能会损失大量的类型信息。参见</target>
        </trans-unit>
        <trans-unit id="12955e4ea22dbc03ccc95585111e9bd2b3cf0146" translate="yes" xml:space="preserve">
          <source>This option suppresses generation of the &lt;code&gt;CALLT&lt;/code&gt; instruction for the v850e, v850e1, v850e2, v850e2v3 and v850e3v5 flavors of the v850 architecture.</source>
          <target state="translated">此选项禁止为v850体系结构的v850e，v850e1，v850e2，v850e2v3和v850e3v5版本生成 &lt;code&gt;CALLT&lt;/code&gt; 指令。</target>
        </trans-unit>
        <trans-unit id="f8fc982c11de8dc3374f1f50078380019a3e1f62" translate="yes" xml:space="preserve">
          <source>This option suppresses the printing of these labels (in the example above, the vertical bars and the &amp;ldquo;char *&amp;rdquo; and &amp;ldquo;long int&amp;rdquo; text).</source>
          <target state="translated">此选项禁止打印这些标签（在上面的示例中，竖线以及&amp;ldquo; char *&amp;rdquo;和&amp;ldquo; long int&amp;rdquo;文本）。</target>
        </trans-unit>
        <trans-unit id="06538fd1399a51a29e2046a8c18ed4e9d2f3a0ec" translate="yes" xml:space="preserve">
          <source>This option tells the compiler that variables declared in common blocks (e.g. Fortran) may later be overridden with longer trailing arrays. This prevents certain optimizations that depend on knowing the array bounds.</source>
          <target state="translated">这个选项告诉编译器,在普通块中声明的变量(例如Fortran)以后可以用较长的尾部数组覆盖。这就防止了某些依赖于知道数组边界的优化。</target>
        </trans-unit>
        <trans-unit id="2d836f8c7fd152c1f4c1e229195acd7d1d9aa958" translate="yes" xml:space="preserve">
          <source>This option tells the loop optimizer to use language constraints to derive bounds for the number of iterations of a loop. This assumes that loop code does not invoke undefined behavior by for example causing signed integer overflows or out-of-bound array accesses. The bounds for the number of iterations of a loop are used to guide loop unrolling and peeling and loop exit test optimizations. This option is enabled by default.</source>
          <target state="translated">这个选项告诉循环优化器使用语言约束来计算循环的迭代次数。这假定循环代码不会引起未定义的行为,例如导致有符号的整数溢出或超出边界的数组访问。循环的迭代次数的界限用于指导循环的展开和剥离以及循环退出测试的优化。这个选项默认是启用的。</target>
        </trans-unit>
        <trans-unit id="4eb8a2fe595c9e8241e6ef6590e0c3c77e876a48" translate="yes" xml:space="preserve">
          <source>This option turns off this behavior because some programs explicitly rely on variables going to the data section&amp;mdash;e.g., so that the resulting executable can find the beginning of that section and/or make assumptions based on that.</source>
          <target state="translated">此选项关闭了此行为，因为某些程序明确依赖于进入数据部分的变量，例如，以便所生成的可执行文件可以找到该部分的开头和/或基于此进行假设。</target>
        </trans-unit>
        <trans-unit id="a03fa036158e8a2d0e9cc5e169d9035da63e693f" translate="yes" xml:space="preserve">
          <source>This option warns on all uses of &lt;code&gt;alloca&lt;/code&gt; in the source.</source>
          <target state="translated">此选项警告源中对 &lt;code&gt;alloca&lt;/code&gt; 的所有使用。</target>
        </trans-unit>
        <trans-unit id="620c263a82fa884ae16095490ed1aafd4abf9e58" translate="yes" xml:space="preserve">
          <source>This option warns on calls to &lt;code&gt;alloca&lt;/code&gt; with an integer argument whose value is either zero, or that is not bounded by a controlling predicate that limits its value to at most &lt;var&gt;byte-size&lt;/var&gt;. It also warns for calls to &lt;code&gt;alloca&lt;/code&gt; where the bound value is unknown. Arguments of non-integer types are considered unbounded even if they appear to be constrained to the expected range.</source>
          <target state="translated">此选项会警告使用整数参数（其值为零或不受控制谓词限制的整数参数）调用 &lt;code&gt;alloca&lt;/code&gt; ，该控制谓词将其值限制为最大 &lt;var&gt;byte-size&lt;/var&gt; 。它还会警告调用绑定值未知的 &lt;code&gt;alloca&lt;/code&gt; 。非整数类型的参数即使被限制在预期范围内也被认为是无界的。</target>
        </trans-unit>
        <trans-unit id="61e70b725867d5de470ac626de798dde99007b65" translate="yes" xml:space="preserve">
          <source>This option will be enabled by default if, at GCC configure time, the assembler was found to support such directives.</source>
          <target state="translated">如果在GCC配置时发现汇编器支持这种指令,那么这个选项将被默认启用。</target>
        </trans-unit>
        <trans-unit id="a7e38bb2c3d97b5a7df94e2d4b17a0b93c48b4a5" translate="yes" xml:space="preserve">
          <source>This option will be enabled by default if, at GCC configure time, the assembler was found to support them.</source>
          <target state="translated">如果在GCC配置时发现汇编器支持它们,这个选项将被默认启用。</target>
        </trans-unit>
        <trans-unit id="1c545350367038810cd2987773d5c2915271f3c6" translate="yes" xml:space="preserve">
          <source>This option works only with DWARF debug output.</source>
          <target state="translated">该选项仅对DWARF调试输出有效。</target>
        </trans-unit>
        <trans-unit id="bbaec7f2023839aa97132788cd132448147454c0" translate="yes" xml:space="preserve">
          <source>This option, recognized for the cris-axis-elf, arranges to link with input-output functions from a simulator library. Code, initialized data and zero-initialized data are allocated consecutively.</source>
          <target state="translated">该选项为cris-axis-elf所认可,安排与仿真器库中的输入输出函数进行链接。代码、初始化数据和零初始化数据被连续分配。</target>
        </trans-unit>
        <trans-unit id="f3e5914b613a32a5cb2f8fca3e63e01d9cf519e2" translate="yes" xml:space="preserve">
          <source>This parameter prevents mixed usage of multiple atomic models, even if they are compatible, and makes the compiler generate atomic sequences of the specified model only.</source>
          <target state="translated">这个参数可以防止混合使用多个原子模型,即使它们是兼容的,并使编译器只生成指定模型的原子序列。</target>
        </trans-unit>
        <trans-unit id="a5d669f5cfd64a65baaa023d25d50f1d31d908f7" translate="yes" xml:space="preserve">
          <source>This parameter specifies the offset in bytes of the variable in the thread control block structure that should be used by the generated atomic sequences when the &amp;lsquo;</source>
          <target state="translated">此参数指定线程控制块结构中变量的偏移量（以字节为单位），当'</target>
        </trans-unit>
        <trans-unit id="a089b6884ff458754998285328ae2911c61445c4" translate="yes" xml:space="preserve">
          <source>This pass distributes the initialization loops and generates a call to memset zero. For example, the loop</source>
          <target state="translated">这个通证分配初始化循环,并产生对memset zero的调用。例如,循环</target>
        </trans-unit>
        <trans-unit id="f9c1c873e049f9ba7fb7727e6d4eeb92324da6de" translate="yes" xml:space="preserve">
          <source>This pass only applies to certain targets that cannot explicitly represent the comparison operation before register allocation is complete.</source>
          <target state="translated">这个通道只适用于某些目标,在寄存器分配完成之前,不能明确表示比较操作。</target>
        </trans-unit>
        <trans-unit id="461faf3624a4165b061a68a094b7ad69f3e94c46" translate="yes" xml:space="preserve">
          <source>This pragma allows the user to set the visibility for multiple declarations without having to give each a visibility attribute (see &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;Function Attributes&lt;/a&gt;).</source>
          <target state="translated">此实用程序使用户可以设置多个声明的可见性，而不必给每个声明可见性属性（请参见&lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;Function Attributes&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="e202730c1bfc48c0778f7ea2bd0c6eb45186cc47" translate="yes" xml:space="preserve">
          <source>This pragma allows you to set global optimization options for functions defined later in the source file. One or more strings can be specified. Each function that is defined after this point is treated as if it had been declared with one &lt;code&gt;optimize(&lt;/code&gt;&lt;var&gt;string&lt;/var&gt;&lt;code&gt;)&lt;/code&gt; attribute for each &lt;var&gt;string&lt;/var&gt; argument. The parentheses around the strings in the pragma are optional. See &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;Function Attributes&lt;/a&gt;, for more information about the &lt;code&gt;optimize&lt;/code&gt; attribute and the attribute syntax.</source>
          <target state="translated">此实用程序允许您为源文件中稍后定义的功能设置全局优化选项。可以指定一个或多个字符串。在此之后定义的每个函数都将被视为已使用每个 &lt;var&gt;string&lt;/var&gt; 参数的一个 &lt;code&gt;optimize(&lt;/code&gt; &lt;var&gt;string&lt;/var&gt; &lt;code&gt;)&lt;/code&gt; 属性进行了声明。杂注中字符串的括号是可选的。有关 &lt;code&gt;optimize&lt;/code&gt; 属性和属性语法的更多信息，请参见&lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;函数属性&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1c9f09620296c49e0c152a1252d539d7a1599030" translate="yes" xml:space="preserve">
          <source>This pragma allows you to set target-specific options for functions defined later in the source file. One or more strings can be specified. Each function that is defined after this point is treated as if it had been declared with one &lt;code&gt;target(&lt;/code&gt;&lt;var&gt;string&lt;/var&gt;&lt;code&gt;)&lt;/code&gt; attribute for each &lt;var&gt;string&lt;/var&gt; argument. The parentheses around the strings in the pragma are optional. See &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;Function Attributes&lt;/a&gt;, for more information about the &lt;code&gt;target&lt;/code&gt; attribute and the attribute syntax.</source>
          <target state="translated">此实用程序使您可以为源文件中稍后定义的功能设置特定于目标的选项。可以指定一个或多个字符串。在此之后定义的每个函数都将被视为已使用每个 &lt;var&gt;string&lt;/var&gt; 参数的一个 &lt;code&gt;target(&lt;/code&gt; &lt;var&gt;string&lt;/var&gt; &lt;code&gt;)&lt;/code&gt; 属性进行了声明。杂注中的字符串周围的括号是可选的。有关 &lt;code&gt;target&lt;/code&gt; 属性和属性语法的更多信息，请参见&lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;函数属性&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e5bdf333d1a9b5e255036222cc92af1884c97c92" translate="yes" xml:space="preserve">
          <source>This pragma and the &lt;code&gt;asm&lt;/code&gt; labels extension interact in a complicated manner. Here are some corner cases you may want to be aware of:</source>
          <target state="translated">该编译指示和 &lt;code&gt;asm&lt;/code&gt; 标签扩展以复杂的方式交互。您可能需要注意以下一些特殊情况：</target>
        </trans-unit>
        <trans-unit id="df6ea502dad4ed3727dbc5aab1f84068b260e566" translate="yes" xml:space="preserve">
          <source>This pragma causes each listed &lt;var&gt;function&lt;/var&gt; to be called after main, or during shared module unloading, by adding a call to the &lt;code&gt;.fini&lt;/code&gt; section.</source>
          <target state="translated">该 &lt;var&gt;function&lt;/var&gt; 通过在 &lt;code&gt;.fini&lt;/code&gt; 节中添加调用，导致在main之后或卸载共享模块时调用每个列出的函数。</target>
        </trans-unit>
        <trans-unit id="7ef98ac7a5a65ac560b0183a0711ed56313ca3a4" translate="yes" xml:space="preserve">
          <source>This pragma causes each listed &lt;var&gt;function&lt;/var&gt; to be called during initialization (before &lt;code&gt;main&lt;/code&gt;) or during shared module loading, by adding a call to the &lt;code&gt;.init&lt;/code&gt; section.</source>
          <target state="translated">该编译指示通过在 &lt;code&gt;.init&lt;/code&gt; 节中添加调用，从而在初始化期间（在 &lt;code&gt;main&lt;/code&gt; 之前）或在共享模块加载期间调用每个列出的 &lt;var&gt;function&lt;/var&gt; 。</target>
        </trans-unit>
        <trans-unit id="4305b5e7eee9369ab0724af50f66a74eaee06881" translate="yes" xml:space="preserve">
          <source>This pragma clears the current &lt;code&gt;#pragma GCC target&lt;/code&gt; and &lt;code&gt;#pragma GCC optimize&lt;/code&gt; to use the default switches as specified on the command line.</source>
          <target state="translated">该编译指示清除当前的 &lt;code&gt;#pragma GCC target&lt;/code&gt; 并且 &lt;code&gt;#pragma GCC optimize&lt;/code&gt; 以使用命令行上指定的默认开关。</target>
        </trans-unit>
        <trans-unit id="c86f808ebf265d2793b4414b964c355b2c508a5f" translate="yes" xml:space="preserve">
          <source>This pragma declares &lt;var&gt;symbol1&lt;/var&gt; to be a weak alias of &lt;var&gt;symbol2&lt;/var&gt;. It is an error if &lt;var&gt;symbol2&lt;/var&gt; is not defined in the current translation unit.</source>
          <target state="translated">该编译指示将 &lt;var&gt;symbol1&lt;/var&gt; 声明为 &lt;var&gt;symbol2&lt;/var&gt; 的弱别名。如果在当前转换单元中未定义 &lt;var&gt;symbol2&lt;/var&gt; ,则错误。</target>
        </trans-unit>
        <trans-unit id="2e41ab6e510f688ee4c0ac9d61fab50b654b5c94" translate="yes" xml:space="preserve">
          <source>This pragma declares &lt;var&gt;symbol&lt;/var&gt; to be weak, as if the declaration had the attribute of the same name. The pragma may appear before or after the declaration of &lt;var&gt;symbol&lt;/var&gt;. It is not an error for &lt;var&gt;symbol&lt;/var&gt; to never be defined at all.</source>
          <target state="translated">该杂注声明 &lt;var&gt;symbol&lt;/var&gt; 弱，就像声明具有相同名称的属性一样。杂语可能出现在 &lt;var&gt;symbol&lt;/var&gt; 声明之前或之后。绝对不要定义 &lt;var&gt;symbol&lt;/var&gt; ，这不是错误。</target>
        </trans-unit>
        <trans-unit id="6d680236fdbf196915aaf992aecdb77c6a8b587b" translate="yes" xml:space="preserve">
          <source>This pragma declares variables to be possibly unused. GCC does not produce warnings for the listed variables. The effect is similar to that of the &lt;code&gt;unused&lt;/code&gt; attribute, except that this pragma may appear anywhere within the variables&amp;rsquo; scopes.</source>
          <target state="translated">此实用程序声明变量可能未使用。GCC不会为列出的变量生成警告。效果与 &lt;code&gt;unused&lt;/code&gt; 属性类似，不同之处在于该杂注可能出现在变量范围内的任何位置。</target>
        </trans-unit>
        <trans-unit id="297d6f917f11b7d696df277d2ac80b8a527dc0e9" translate="yes" xml:space="preserve">
          <source>This pragma gives the C function &lt;var&gt;oldname&lt;/var&gt; the assembly symbol &lt;var&gt;newname&lt;/var&gt;. The preprocessor macro &lt;code&gt;__PRAGMA_REDEFINE_EXTNAME&lt;/code&gt; is defined if this pragma is available (currently on all platforms).</source>
          <target state="translated">该 &lt;var&gt;oldname&lt;/var&gt; 注将C函数oldname赋予汇编符号 &lt;var&gt;newname&lt;/var&gt; 。如果此编译指示可用（当前在所有平台上），则定义预处理器宏 &lt;code&gt;__PRAGMA_REDEFINE_EXTNAME&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1d47f09719c8273483bc0daaf5859bab9562dec9" translate="yes" xml:space="preserve">
          <source>This pragma is accepted, but has no effect.</source>
          <target state="translated">这个pragma被接受了,但没有效果。</target>
        </trans-unit>
        <trans-unit id="d1d3fa1a452de5b39a96a52139032ce525a57ad0" translate="yes" xml:space="preserve">
          <source>This pragma is not implemented, but the default is to &amp;ldquo;off&amp;rdquo; unless</source>
          <target state="translated">该编译指示未实现，但默认为&amp;ldquo;关闭&amp;rdquo;，除非</target>
        </trans-unit>
        <trans-unit id="df0d00bf5dd61e1e80f9e58129099c35fef14b94" translate="yes" xml:space="preserve">
          <source>This pragma is not implemented. Expressions are currently only contracted if</source>
          <target state="translated">这个参数没有实现。目前只有在以下情况下才会收缩表达式</target>
        </trans-unit>
        <trans-unit id="42570b540208a522195f34bdcb31e38a4d6b0221" translate="yes" xml:space="preserve">
          <source>This pragma saves the value of the macro named as &lt;var&gt;macro_name&lt;/var&gt; to the top of the stack for this macro.</source>
          <target state="translated">此编译指示将名为 &lt;var&gt;macro_name&lt;/var&gt; 的宏的值保存到该宏的堆栈顶部。</target>
        </trans-unit>
        <trans-unit id="0d99cb35c6101970038eaf301a0c3beb6107bf5a" translate="yes" xml:space="preserve">
          <source>This pragma sets the alignment of fields in structures. The values of &lt;var&gt;alignment&lt;/var&gt; may be &lt;code&gt;mac68k&lt;/code&gt;, to emulate m68k alignment, or &lt;code&gt;power&lt;/code&gt;, to emulate PowerPC alignment. Uses of this pragma nest properly; to restore the previous setting, use &lt;code&gt;reset&lt;/code&gt; for the &lt;var&gt;alignment&lt;/var&gt;.</source>
          <target state="translated">此实用程序设置结构中字段的对齐方式。 &lt;var&gt;alignment&lt;/var&gt; 的值可以是 &lt;code&gt;mac68k&lt;/code&gt; （模拟m68k对齐），或者是 &lt;code&gt;power&lt;/code&gt; （模拟PowerPC对齐）。正确使用此编译指示；要恢复先前的设置，请使用 &lt;code&gt;reset&lt;/code&gt; 进行 &lt;var&gt;alignment&lt;/var&gt; 。</target>
        </trans-unit>
        <trans-unit id="6e23a1d175eeaabf52f59f12be4c55b597b0251f" translate="yes" xml:space="preserve">
          <source>This pragma sets the value of the macro named as &lt;var&gt;macro_name&lt;/var&gt; to the value on top of the stack for this macro. If the stack for &lt;var&gt;macro_name&lt;/var&gt; is empty, the value of the macro remains unchanged.</source>
          <target state="translated">此编译指示将名为 &lt;var&gt;macro_name&lt;/var&gt; 的宏的值设置为该宏在堆栈顶部的值。如果 &lt;var&gt;macro_name&lt;/var&gt; 的堆栈为空，则宏的值保持不变。</target>
        </trans-unit>
        <trans-unit id="03b17cd16d3c44521375b42df7bda966fe331c0e" translate="yes" xml:space="preserve">
          <source>This pragma silently applies only to declarations with external linkage. The &lt;code&gt;asm&lt;/code&gt; label feature does not have this restriction.</source>
          <target state="translated">此实用程序仅适用于具有外部链接的声明。该 &lt;code&gt;asm&lt;/code&gt; 标签功能没有此限制。</target>
        </trans-unit>
        <trans-unit id="263438c853ee982ccc7a3904487e0cd3d115c742" translate="yes" xml:space="preserve">
          <source>This prefix is also used for finding files such as</source>
          <target state="translated">这个前缀也用于查找文件,如</target>
        </trans-unit>
        <trans-unit id="853d289c160cc93497a02e37abb2f9f0217d9d34" translate="yes" xml:space="preserve">
          <source>This problem may for instance occur when we use this pattern recursively, like so:</source>
          <target state="translated">例如,当我们递归地使用这个模式时,可能会出现这个问题,比如这样。</target>
        </trans-unit>
        <trans-unit id="92bb145abdc75a03d83add48a654c73cbe5bd131" translate="yes" xml:space="preserve">
          <source>This problem only affects kernel stores and, depending on the system, kernel loads. As an example, a speculatively-executed store may load the target memory into cache and mark the cache line as dirty, even if the store itself is later aborted. If a DMA operation writes to the same area of memory before the &amp;ldquo;dirty&amp;rdquo; line is flushed, the cached data overwrites the DMA-ed data. See the R10K processor manual for a full description, including other potential problems.</source>
          <target state="translated">此问题仅影响内核存储，并且会影响内核加载，具体取决于系统。例如，一个推测执行的存储可以将目标内存加载到高速缓存中，并将高速缓存行标记为脏，即使存储本身后来被中止。如果在清除&amp;ldquo;脏&amp;rdquo;行之前DMA操作写入了相同的内存区域，则缓存的数据将覆盖DMA版本的数据。有关完整说明，请参阅R10K处理器手册，其中包括其他潜在问题。</target>
        </trans-unit>
        <trans-unit id="6bba2aa8d001273821fc7a22f52c80ae052e1b79" translate="yes" xml:space="preserve">
          <source>This qualifier informs the compiler that the &lt;code&gt;asm&lt;/code&gt; statement may perform a jump to one of the labels listed in the &lt;var&gt;GotoLabels&lt;/var&gt;. See &lt;a href=&quot;#GotoLabels&quot;&gt;GotoLabels&lt;/a&gt;.</source>
          <target state="translated">该限定符通知编译器 &lt;code&gt;asm&lt;/code&gt; 语句可以跳转到 &lt;var&gt;GotoLabels&lt;/var&gt; 中列出的标签之一。请参阅&lt;a href=&quot;#GotoLabels&quot;&gt;GotoLabels&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4093c1766b06cd06224229c5ab31374f32640737" translate="yes" xml:space="preserve">
          <source>This restriction of ISO C makes it hard to write code that is portable to traditional C compilers, because the programmer does not know whether the &lt;code&gt;uid_t&lt;/code&gt; type is &lt;code&gt;short&lt;/code&gt;, &lt;code&gt;int&lt;/code&gt;, or &lt;code&gt;long&lt;/code&gt;. Therefore, in cases like these GNU C allows a prototype to override a later old-style definition. More precisely, in GNU C, a function prototype argument type overrides the argument type specified by a later old-style definition if the former type is the same as the latter type before promotion. Thus in GNU C the above example is equivalent to the following:</source>
          <target state="translated">由于ISO C的这种限制使得难以编写可移植到传统C编译器中的代码，因为程序员不知道 &lt;code&gt;uid_t&lt;/code&gt; 类型是 &lt;code&gt;short&lt;/code&gt; ， &lt;code&gt;int&lt;/code&gt; 还是 &lt;code&gt;long&lt;/code&gt; 。因此，在这种情况下，GNU C允许原型重写以后的旧式定义。更精确地讲，在GNU C中，如果函数原型参数类型与升级之前的后者类型相同，则函数原型参数类型将覆盖由较新的旧式定义所指定的参数类型。因此，在GNU C中，以上示例等效于以下示例：</target>
        </trans-unit>
        <trans-unit id="b4ab6e646b44f4632464748755730b2c272ad5f1" translate="yes" xml:space="preserve">
          <source>This sample shows how to specify the assembler name for data:</source>
          <target state="translated">这个示例展示了如何为数据指定汇编器名称。</target>
        </trans-unit>
        <trans-unit id="e5b05b60d6f2ee21a98f997beb1f9023f6a4e7bc" translate="yes" xml:space="preserve">
          <source>This says that any input file whose name ends in &amp;lsquo;</source>
          <target state="translated">这表示名称以&amp;ldquo;。&amp;rdquo;结尾的任何输入文件</target>
        </trans-unit>
        <trans-unit id="8bc7756ea229cad62f19381d0aec545c10cece4c" translate="yes" xml:space="preserve">
          <source>This says that the suffix is an alias for a known &lt;var&gt;language&lt;/var&gt;. This is similar to using the</source>
          <target state="translated">这表示后缀是已知 &lt;var&gt;language&lt;/var&gt; 的别名。这类似于使用</target>
        </trans-unit>
        <trans-unit id="77e07f2febdffcd9c896323de91d75db17316bb7" translate="yes" xml:space="preserve">
          <source>This section describes PowerPC built-in functions that do not require the inclusion of any special header files to declare prototypes or provide macro definitions. The sections that follow describe additional PowerPC built-in functions.</source>
          <target state="translated">本节介绍了不需要包含任何特殊头文件来声明原型或提供宏定义的PowerPC内置函数。后面的章节将介绍更多的PowerPC内置函数。</target>
        </trans-unit>
        <trans-unit id="4b61f221f0794b55701031d13518070c0255286e" translate="yes" xml:space="preserve">
          <source>This section describes built-in functions that are not named after a specific FR-V instruction.</source>
          <target state="translated">本节介绍不以特定FR-V指令命名的内置函数。</target>
        </trans-unit>
        <trans-unit id="d7abf825d737ed6aeedbed114bb5b1fa96d1d588" translate="yes" xml:space="preserve">
          <source>This section describes command-line options that are primarily of interest to GCC developers, including options to support compiler testing and investigation of compiler bugs and compile-time performance problems. This includes options that produce debug dumps at various points in the compilation; that print statistics such as memory use and execution time; and that print information about GCC&amp;rsquo;s configuration, such as where it searches for libraries. You should rarely need to use any of these options for ordinary compilation and linking tasks.</source>
          <target state="translated">本节介绍了GCC开发人员主要感兴趣的命令行选项，包括支持编译器测试以及调查编译器错误和编译时性能问题的选项。这包括在编译的各个点产生调试转储的选项。打印统计信息，例如内存使用和执行时间；并打印有关GCC配置的信息，例如在何处搜索库。对于普通的编译和链接任务，您几乎不需要使用任何这些选项。</target>
        </trans-unit>
        <trans-unit id="2bedaec624c9942033ae97b423071f6ba2ad1456" translate="yes" xml:space="preserve">
          <source>This section describes known problems that affect users of GCC. Most of these are not GCC bugs per se&amp;mdash;if they were, we would fix them. But the result for a user may be like the result of a bug.</source>
          <target state="translated">本节介绍了影响GCC用户的已知问题。其中大多数本身不是GCC错误-如果是，我们将对其进行修复。但是，对于用户而言，结果可能像是错误的结果。</target>
        </trans-unit>
        <trans-unit id="5b43873b1eac185b9fa8755ff87aff197f92a2f8" translate="yes" xml:space="preserve">
          <source>This section describes several environment variables that affect how GCC operates. Some of them work by specifying directories or prefixes to use when searching for various kinds of files. Some are used to specify other aspects of the compilation environment.</source>
          <target state="translated">本节介绍了影响GCC运行方式的几个环境变量。其中一些环境变量通过指定搜索各种文件时要使用的目录或前缀来工作。有些环境变量用于指定编译环境的其他方面。</target>
        </trans-unit>
        <trans-unit id="9055e1a522ff74558948ff04f5b4f164a424da3a" translate="yes" xml:space="preserve">
          <source>This section describes the command-line options that are only meaningful for C++ programs. You can also use most of the GNU compiler options regardless of what language your program is in. For example, you might compile a file</source>
          <target state="translated">本节介绍了只对C++程序有意义的命令行选项。您也可以使用GNU编译器的大部分选项,而不管您的程序使用的是什么语言。例如,你可以编译一个文件</target>
        </trans-unit>
        <trans-unit id="378b3683f59604e4695371da6c2fddfaacd92ba1" translate="yes" xml:space="preserve">
          <source>This section describes the command-line options that are only meaningful for Objective-C and Objective-C++ programs. You can also use most of the language-independent GNU compiler options. For example, you might compile a file</source>
          <target state="translated">本节介绍了只对Objective-C和Objective-C++程序有意义的命令行选项。您也可以使用大多数与语言无关的GNU编译器选项。例如,您可以编译一个文件</target>
        </trans-unit>
        <trans-unit id="382e6f59f6c971fab95547a05668a5918cd72126" translate="yes" xml:space="preserve">
          <source>This section describes the syntax with which &lt;code&gt;__attribute__&lt;/code&gt; may be used, and the constructs to which attribute specifiers bind, for the C language. Some details may vary for C++ and Objective-C. Because of infelicities in the grammar for attributes, some forms described here may not be successfully parsed in all cases.</source>
          <target state="translated">本节描述了C语言可以使用 &lt;code&gt;__attribute__&lt;/code&gt; 的语法以及属性说明符所绑定的构造。对于C ++和Objective-C，某些细节可能有所不同。由于语法上的属性不够准确，因此此处描述的某些形式可能无法在所有情况下都成功解析。</target>
        </trans-unit>
        <trans-unit id="bd8e6c5371362aa092aae0b0592e55198f1c8b9c" translate="yes" xml:space="preserve">
          <source>This section documents the encoding of method types, which is rarely needed to use Objective-C. You should skip it at a first reading; the runtime provides functions that will work on methods and can walk through the list of parameters and interpret them for you. These functions are part of the public &amp;ldquo;API&amp;rdquo; and are the preferred way to interact with method signatures from user code.</source>
          <target state="translated">本节介绍了方法类型的编码，这对于使用Objective-C几乎是不需要的。您应该在初读时略过它；运行时提供的功能将对方法起作用，并且可以遍历参数列表并为您解释它们。这些功能是公共&amp;ldquo; API&amp;rdquo;的一部分，是与用户代码中的方法签名进行交互的首选方法。</target>
        </trans-unit>
        <trans-unit id="92bc19fae671586234add4d5e1d253df22100b8a" translate="yes" xml:space="preserve">
          <source>This section intentionally empty.</source>
          <target state="translated">本节故意空。</target>
        </trans-unit>
        <trans-unit id="9dcc691a02a9391b7e0c30aab063927ea00a125c" translate="yes" xml:space="preserve">
          <source>This section is specific for the GNU Objective-C runtime. If you are using a different runtime, you can skip it.</source>
          <target state="translated">本节是针对GNU Objective-C运行时的。如果你使用的是不同的运行时,你可以跳过它。</target>
        </trans-unit>
        <trans-unit id="4d2663a3da2126761e59e5b901038db322ae02e2" translate="yes" xml:space="preserve">
          <source>This section lists changes that people frequently request, but which we do not make because we think GCC is better without them.</source>
          <target state="translated">本节列出了人们经常要求的改动,但我们没有做,因为我们认为没有这些改动GCC会更好。</target>
        </trans-unit>
        <trans-unit id="6be9fd8a27bd882ee2957a5506f02578eed902d6" translate="yes" xml:space="preserve">
          <source>This section lists various difficulties encountered in using GCC together with other compilers or with the assemblers, linkers, libraries and debuggers on certain systems.</source>
          <target state="translated">本节列出了在某些系统上与其他编译器或汇编器、链接器、库和调试器一起使用GCC时遇到的各种困难。</target>
        </trans-unit>
        <trans-unit id="fc5c464b4c99442f66523b49fbd84dd32d4a9f33" translate="yes" xml:space="preserve">
          <source>This sections describes built-in functions related to read and write instructions to access memory. These functions generate &lt;code&gt;membar&lt;/code&gt; instructions to flush the I/O load and stores where appropriate, as described in Fujitsu&amp;rsquo;s manual described above.</source>
          <target state="translated">本节介绍与访问存储器的读写指令相关的内置功能。这些功能会生成 &lt;code&gt;membar&lt;/code&gt; 指令，以刷新I / O负载并在适当的位置存储，如上述Fujitsu的手册中所述。</target>
        </trans-unit>
        <trans-unit id="657a9d90f9f4dd0b4af1725dd023d864364a9a6d" translate="yes" xml:space="preserve">
          <source>This selects the CPU to generate code for at compilation time by determining the processor type of the compiling machine. Using</source>
          <target state="translated">在编译时,通过确定编译机的处理器类型来选择生成代码的CPU。使用</target>
        </trans-unit>
        <trans-unit id="52fbcd0192529b61aa6e52c7943fcf31e0d69f81" translate="yes" xml:space="preserve">
          <source>This sets the indicated bits in the saved copy of the status register currently residing on the stack. This only works inside interrupt handlers and the changes to the status register will only take affect once the handler returns.</source>
          <target state="translated">这将设置当前保存在堆栈上的状态寄存器副本中的指定位。这只在中断处理程序中起作用,对状态寄存器的改变只有在处理程序返回后才会生效。</target>
        </trans-unit>
        <trans-unit id="c8206cbbb17dc4eed11021be8e812bfcaf18d27d" translate="yes" xml:space="preserve">
          <source>This setting is only useful for strides that are known and constant.</source>
          <target state="translated">这个设置只对已知和恒定的步幅有用。</target>
        </trans-unit>
        <trans-unit id="efe46d223c613fd1d939a40a5c5d5b8742ce8085" translate="yes" xml:space="preserve">
          <source>This setting is useful for processors that have hardware prefetchers, in which case there may be conflicts between the hardware prefetchers and the software prefetchers. If the hardware prefetchers have a maximum stride they can handle, it should be used here to improve the use of software prefetchers.</source>
          <target state="translated">这个设置对于有硬件预取器的处理器很有用,在这种情况下,硬件预取器和软件预取器之间可能会有冲突。如果硬件预取器有其能处理的最大步长,则应在此使用,以提高软件预取器的使用率。</target>
        </trans-unit>
        <trans-unit id="23f9a68d34fdcbac9802d87e4691f1d481ccdb61" translate="yes" xml:space="preserve">
          <source>This size is also used for inlining decisions. If you use &lt;code&gt;asm inline&lt;/code&gt; instead of just &lt;code&gt;asm&lt;/code&gt;, then for inlining purposes the size of the asm is taken as the minimum size, ignoring how many instructions GCC thinks it is.</source>
          <target state="translated">此大小也用于内联决策。如果您使用 &lt;code&gt;asm inline&lt;/code&gt; 而不是 &lt;code&gt;asm&lt;/code&gt; ，则出于内联目的，将asm的大小作为最小大小，而忽略了GCC认为有多少条指令。</target>
        </trans-unit>
        <trans-unit id="6436ee6603a6a283bb34edc1a40e3b3faa54b98d" translate="yes" xml:space="preserve">
          <source>This specifies that the name to be used for the function &lt;code&gt;func&lt;/code&gt; in the assembler code should be &lt;code&gt;MYFUNC&lt;/code&gt;.</source>
          <target state="translated">这指定在汇编代码中用于函数 &lt;code&gt;func&lt;/code&gt; 的名称应为 &lt;code&gt;MYFUNC&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="232e23ab36d2ae531cc928cda4ab49d45def08c5" translate="yes" xml:space="preserve">
          <source>This specifies that the name to be used for the variable &lt;code&gt;foo&lt;/code&gt; in the assembler code should be &amp;lsquo;</source>
          <target state="translated">这指定在汇编代码中用于变量 &lt;code&gt;foo&lt;/code&gt; 的名称应为'</target>
        </trans-unit>
        <trans-unit id="a3c554fdfb8d610626cac613dfe8c644012d6c11" translate="yes" xml:space="preserve">
          <source>This specifies the hard limit for frame sizes, in bytes. Currently, the value that can be specified should be less than or equal to &amp;lsquo;</source>
          <target state="translated">这指定了帧大小的硬限制，以字节为单位。当前，可以指定的值应小于或等于'</target>
        </trans-unit>
        <trans-unit id="157c3a5d700741dba8b972ce366b3872db0f98d9" translate="yes" xml:space="preserve">
          <source>This specifies the minimum version of the kernel that will run the compiled program. GCC uses this version to determine which instructions to use, what kernel helpers to allow, etc. Currently, &lt;var&gt;version&lt;/var&gt; can be one of &amp;lsquo;</source>
          <target state="translated">这指定将运行已编译程序的内核的最低版本。GCC使用此版本来确定要使用的指令，允许的内核助手等。当前，该 &lt;var&gt;version&lt;/var&gt; 可以是&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="d2e7d4d12b96a2f9b08b67a67b6c05ae9677d81f" translate="yes" xml:space="preserve">
          <source>This specifies the name of the target ARM architecture. GCC uses this name to determine what kind of instructions it can emit when generating assembly code. This option can be used in conjunction with or instead of the</source>
          <target state="translated">这指定了目标ARM架构的名称。GCC 使用此名称来确定它在生成汇编代码时可以发出何种指令。这个选项可以与</target>
        </trans-unit>
        <trans-unit id="5f5ffdf441cdde0f8b6e9e4c7fe02c1f21c8c411" translate="yes" xml:space="preserve">
          <source>This specifies the name of the target ARM processor. GCC uses this name to derive the name of the target ARM architecture (as if specified by</source>
          <target state="translated">这指定了目标ARM处理器的名称。GCC 使用此名称来推导出目标 ARM 架构的名称(就像由</target>
        </trans-unit>
        <trans-unit id="8e151a0bdb560628cb5ddbb4913dc14cfb482f53" translate="yes" xml:space="preserve">
          <source>This specifies the name of the target Nios II architecture. GCC uses this name to determine what kind of instructions it can emit when generating assembly code. Permissible names are: &amp;lsquo;</source>
          <target state="translated">这指定了目标Nios II体系结构的名称。GCC使用此名称来确定生成汇编代码时可以发出的指令类型。允许的名称为：'</target>
        </trans-unit>
        <trans-unit id="085bdfa0f8d1afe6178b912d6185b5a3f9cb191a" translate="yes" xml:space="preserve">
          <source>This specifies the name of the target architecture. GCC uses this name to determine what kind of instructions it can emit when generating assembly code. Permissible names are: &amp;lsquo;</source>
          <target state="translated">这指定了目标体系结构的名称。GCC使用此名称来确定生成汇编代码时可以发出的指令类型。允许的名称为：'</target>
        </trans-unit>
        <trans-unit id="64aaf23d10b975a481227888a0c489eb1e3c16c0" translate="yes" xml:space="preserve">
          <source>This specifies what floating-point hardware (or hardware emulation) is available on the target. Permissible names are: &amp;lsquo;</source>
          <target state="translated">这指定了目标上可用的浮点硬件（或硬件仿真）。允许的名称为：'</target>
        </trans-unit>
        <trans-unit id="345d1833d12c5392425b9eb5b3c8d3be49244d38" translate="yes" xml:space="preserve">
          <source>This switch causes the command line used to invoke the compiler to be recorded into the object file that is being created. This switch is only implemented on some targets and the exact format of the recording is target and binary file format dependent, but it usually takes the form of a section containing ASCII text. This switch is related to the</source>
          <target state="translated">这个开关导致用于调用编译器的命令行被记录到正在创建的对象文件中。这个开关只在某些目标上实现,记录的确切格式取决于目标和二进制文件格式,但它通常采取包含ASCII文本的部分形式。这个开关与</target>
        </trans-unit>
        <trans-unit id="fcef4a45435978f94ac21ce5b4ddc80a97324665" translate="yes" xml:space="preserve">
          <source>This switch causes the command-line options used to invoke the compiler that may affect code generation to be appended to the DW_AT_producer attribute in DWARF debugging information. The options are concatenated with spaces separating them from each other and from the compiler version. It is enabled by default. See also</source>
          <target state="translated">这个开关使得用于调用编译器的可能影响代码生成的命令行选项被附加到DWARF调试信息中的DW_AT_producer属性中。这些选项是连在一起的,它们之间和编译器版本之间用空格隔开。默认情况下是启用的。另请参阅</target>
        </trans-unit>
        <trans-unit id="a3ef7cfaa3693eda0200855e73487a3931ad86b9" translate="yes" xml:space="preserve">
          <source>This switch declares that the user does not attempt to compare pointers to inline functions or methods where the addresses of the two functions are taken in different shared objects.</source>
          <target state="translated">这个开关声明,当两个函数的地址取自不同的共享对象时,用户不尝试比较内联函数或方法的指针。</target>
        </trans-unit>
        <trans-unit id="9d12a205f2d4388bb6e6b2aa9be08da33c955f0c" translate="yes" xml:space="preserve">
          <source>This switch disables the automatic removal of redundant &lt;code&gt;membar&lt;/code&gt; instructions from the generated code.</source>
          <target state="translated">此开关禁止从生成的代码中自动删除多余的 &lt;code&gt;membar&lt;/code&gt; 指令。</target>
        </trans-unit>
        <trans-unit id="fb214efcf15f2eebcb5c8359308da41aee1bb7a5" translate="yes" xml:space="preserve">
          <source>This switch enables or disables the generation of ISEL instructions.</source>
          <target state="translated">该开关启用或禁用ISEL指令的生成。</target>
        </trans-unit>
        <trans-unit id="121380ba5bbee8a3b6396891291392c7f45ab990" translate="yes" xml:space="preserve">
          <source>This switch is mainly for debugging the compiler and will likely be removed in a future version.</source>
          <target state="translated">这个开关主要是为了调试编译器,在未来的版本中可能会被删除。</target>
        </trans-unit>
        <trans-unit id="83b61792d6d517f0567ee609808598af69f30e65" translate="yes" xml:space="preserve">
          <source>This switch removes redundant &lt;code&gt;membar&lt;/code&gt; instructions from the compiler-generated code. It is enabled by default.</source>
          <target state="translated">此开关从编译器生成的代码中删除多余的 &lt;code&gt;membar&lt;/code&gt; 指令。默认情况下启用。</target>
        </trans-unit>
        <trans-unit id="2700c0c5f6842561acacd13d2b72a8353682aa23" translate="yes" xml:space="preserve">
          <source>This syntax is defined in the C++ 2011 standard, but has been supported by G++ and other compilers since well before 2011.</source>
          <target state="translated">这个语法是在C++2011标准中定义的,但早在2011年之前就已经被G++和其他编译器所支持。</target>
        </trans-unit>
        <trans-unit id="82fcb60fefcb3dd52763982ecf7c2e7bdfe84505" translate="yes" xml:space="preserve">
          <source>This tells the compiler that a function is &lt;code&gt;malloc&lt;/code&gt;-like, i.e., that the pointer &lt;var&gt;P&lt;/var&gt; returned by the function cannot alias any other pointer valid when the function returns, and moreover no pointers to valid objects occur in any storage addressed by &lt;var&gt;P&lt;/var&gt;.</source>
          <target state="translated">这告诉编译器函数 &lt;code&gt;malloc&lt;/code&gt; ，即，函数返回时，函数返回的指针 &lt;var&gt;P&lt;/var&gt; 不能别名任何其他有效的指针，而且在 &lt;var&gt;P&lt;/var&gt; 寻址的任何存储中都没有指向有效对象的指针。</target>
        </trans-unit>
        <trans-unit id="57ca8b09b0bd70a0af88532cce8b6c0a57af5ea7" translate="yes" xml:space="preserve">
          <source>This tells the compiler to create, override or delete the named spec string. All lines after this directive up to the next directive or blank line are considered to be the text for the spec string. If this results in an empty string then the spec is deleted. (Or, if the spec did not exist, then nothing happens.) Otherwise, if the spec does not currently exist a new spec is created. If the spec does exist then its contents are overridden by the text of this directive, unless the first character of that text is the &amp;lsquo;</source>
          <target state="translated">这告诉编译器创建，覆盖或删除命名的规范字符串。该指令之后直到下一个指令的所有行或空白行均被视为规范字符串的文本。如果结果为空字符串，则删除规范。 （或者，如果该规范不存在，那么什么也不会发生。）否则，如果该规范当前不存在，则会创建一个新的规范。如果规范确实存在，则该指令的文本将覆盖其内容，除非该文本的第一个字符为'</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
