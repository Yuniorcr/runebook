<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="kotlin">
    <body>
      <group id="kotlin">
        <trans-unit id="ac3430431502d340786bc5ac5f5a79619bd1b1b8" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;mapping&lt;/em&gt; transformation creates a collection from the results of a function on the elements of another collection. The basic mapping function is &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/map&quot;&gt;&lt;code&gt;map()&lt;/code&gt;&lt;/a&gt;. It applies the given lambda function to each subsequent element and returns the list of the lambda results. The order of results is the same as the original order of elements. To apply a transformation that additionally uses the element index as an argument, use &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/map-indexed&quot;&gt;&lt;code&gt;mapIndexed()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">的&lt;em&gt;映射&lt;/em&gt;转换创建从在另一集合中的元素的函数的结果的集合。基本的映射函数是&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/map&quot;&gt; &lt;code&gt;map()&lt;/code&gt; &lt;/a&gt;。它将给定的lambda函数应用于每个后续元素，并返回lambda结果的列表。结果的顺序与元素的原始顺序相同。要应用额外使用元素索引作为参数的转换，请使用&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/map-indexed&quot;&gt; &lt;code&gt;mapIndexed()&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7f10d769163cad6919d11542a05d27b21373fb57" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;no-arg&lt;/em&gt; compiler plugin generates an additional zero-argument constructor for classes with a specific annotation.</source>
          <target state="translated">在&lt;em&gt;无参数&lt;/em&gt;编译器插件生成用于与特定注解类的附加无参数构造。</target>
        </trans-unit>
        <trans-unit id="5691855d07c59433c1b89721a503fe2ada65d67c" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;override&lt;/em&gt; modifier is required for &lt;code&gt;Circle.draw()&lt;/code&gt;. If it were missing, the compiler would complain. If there is no &lt;em&gt;open&lt;/em&gt; modifier on a function, like &lt;code&gt;Shape.fill()&lt;/code&gt;, declaring a method with the same signature in a subclass is illegal, either with &lt;em&gt;override&lt;/em&gt; or without it. The &lt;em&gt;open&lt;/em&gt; modifier has no effect when added on members of a final class (i.e.. a class with no &lt;em&gt;open&lt;/em&gt; modifier).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c23eadbd5827ce2bda3043305cafb8fee54b97d1" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;override&lt;/em&gt; modifier is required for &lt;code&gt;Derived.v()&lt;/code&gt;. If it were missing, the compiler would complain. If there is no &lt;em&gt;open&lt;/em&gt; modifier on a function, like &lt;code&gt;Base.nv()&lt;/code&gt;, declaring a method with the same signature in a subclass is illegal, either with &lt;em&gt;override&lt;/em&gt; or without it. The &lt;em&gt;open&lt;/em&gt; modifier has no effect when added on members of a final class (i.e.. a class with no &lt;em&gt;open&lt;/em&gt; modifier).</source>
          <target state="translated">对于 &lt;code&gt;Derived.v()&lt;/code&gt; ,必须使用&lt;em&gt;override&lt;/em&gt;修饰符。如果丢失，编译器会抱怨。如果在诸如 &lt;code&gt;Base.nv()&lt;/code&gt; 之类的函数上没有&lt;em&gt;open&lt;/em&gt;修饰符，则在子类中声明具有相同签名的方法是非法的，无论是否&lt;em&gt;重写&lt;/em&gt;。当将&lt;em&gt;open&lt;/em&gt;修饰符添加到最终类的成员（即，没有&lt;em&gt;open&lt;/em&gt;修饰符的类）的成员上时，则无效。&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="7a6efa4e40ec720cdbba584f5f17332e3c02e6f0" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;primitive data types&lt;/em&gt; are the most fundamental types in Kotlin; all other types are built up of these types and arrays thereof. Their representation is very efficient (both in terms of memory and CPU time), as they map to small byte groups that are directly manipulatable by the CPU.</source>
          <target state="translated">在&lt;em&gt;基本数据类型&lt;/em&gt;都在科特林最根本的类型; 所有其他类型均由这些类型及其数组组成。它们的表示非常有效（在内存和CPU时间方面），因为它们映射到可由CPU直接操作的小字节组。</target>
        </trans-unit>
        <trans-unit id="487cd135e968638b95e9f2832e5094575fc75a4e" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;return&lt;/em&gt;-expression returns from the nearest enclosing function, i.e. &lt;code&gt;foo&lt;/code&gt;. (Note that such non-local returns are supported only for lambda expressions passed to &lt;a href=&quot;inline-functions&quot;&gt;inline functions&lt;/a&gt;.) If we need to return from a lambda expression, we have to label it and qualify the &lt;em&gt;return&lt;/em&gt;:</source>
          <target state="translated">在&lt;em&gt;返回&lt;/em&gt;从最近的封闭功能-expression的回报，即 &lt;code&gt;foo&lt;/code&gt; 。（请注意，只有传递给&lt;a href=&quot;inline-functions&quot;&gt;内联函数的&lt;/a&gt; lambda表达式才支持此类非本地返回。）如果需要从lambda表达式返回，则必须对其进行标记并限定&lt;em&gt;返回值&lt;/em&gt;：</target>
        </trans-unit>
        <trans-unit id="cafe8afb40f89fdcda59dc51de02a6061deac76b" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;sam-with-receiver&lt;/em&gt; compiler plugin makes the first parameter of the annotated Java &quot;single abstract method&quot; (SAM) interface method a receiver in Kotlin. This conversion only works when the SAM interface is passed as a Kotlin lambda, both for SAM adapters and SAM constructors (see the &lt;a href=&quot;java-interop#sam-conversions&quot;&gt;documentation&lt;/a&gt; for more details).</source>
          <target state="translated">所述&lt;em&gt;SAM-与接收器&lt;/em&gt;编译器插件使得注释的Java&amp;ldquo;一个抽象方法&amp;rdquo;（SAM）接口方法的第一个参数在科特林的接收器。仅当SAM适配器和SAM构造函数将SAM接口作为Kotlin lambda传递时，此转换才有效（请参阅&lt;a href=&quot;java-interop#sam-conversions&quot;&gt;文档&lt;/a&gt;以获取更多详细信息）。</target>
        </trans-unit>
        <trans-unit id="2b5aab8f26eb6a59834e5185db5f935d540467ca" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;this&lt;/em&gt; keyword inside an extension function corresponds to the receiver object (the one that is passed before the dot). Now, we can call such a function on any &lt;code&gt;MutableList&amp;lt;Int&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">扩展函数中的&lt;em&gt;this&lt;/em&gt;关键字对应于接收器对象（在点之前传递的对象）。现在，我们可以在任何 &lt;code&gt;MutableList&amp;lt;Int&amp;gt;&lt;/code&gt; 上调用这样的函数：</target>
        </trans-unit>
        <trans-unit id="610610ce4b9c2a06c0d2c740b86b1595d612ed87" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;when&lt;/em&gt; expression replaces the switch statement in C-like languages. In the simplest form it looks like this</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4474dcb438fb0b1d5730dee1b01c00e81230dea0" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;Debug&lt;/strong&gt; tool window contains the &lt;strong&gt;Coroutines&lt;/strong&gt; tab. In this tab, you can find information about both currently running and suspended coroutines. The coroutines are grouped by the dispatcher they are running on.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64ff96f8d5986618b0177325f56f06db0b6ef27e" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;cinterop&lt;/strong&gt; tool produces &lt;code&gt;.klib&lt;/code&gt; wrappers for native libraries as its main output. For example, using the simple &lt;code&gt;libgit2.def&lt;/code&gt; native library definition file provided in your Kotlin/Native distribution</source>
          <target state="translated">该&lt;strong&gt;cinterop&lt;/strong&gt;工具产生 &lt;code&gt;.klib&lt;/code&gt; 的本地库作为其主输出包装。例如，使用Kotlin / Native发行版中提供的简单 &lt;code&gt;libgit2.def&lt;/code&gt; 本机库定义文件</target>
        </trans-unit>
        <trans-unit id="3afe66cbf747b6ceb2175d27e523f7de3f8680c5" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;klib&lt;/strong&gt; library management utility allows you to inspect and install the libraries.</source>
          <target state="translated">该&lt;strong&gt;klib&lt;/strong&gt;库管理工具允许你检查和安装库。</target>
        </trans-unit>
        <trans-unit id="4754f312fedbc815f86ed89afbc9edf502f5ba2a" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;out&lt;/strong&gt; modifier is called a &lt;strong&gt;variance annotation&lt;/strong&gt;, and since it is provided at the type parameter declaration site, we talk about &lt;strong&gt;declaration-site variance&lt;/strong&gt;. This is in contrast with Java's &lt;strong&gt;use-site variance&lt;/strong&gt; where wildcards in the type usages make the types covariant.</source>
          <target state="translated">该&lt;strong&gt;出&lt;/strong&gt;修饰符被称为&lt;strong&gt;方差注释&lt;/strong&gt;，并且由于它是在类型参数声明的网站提供的，我们谈论&lt;strong&gt;的声明站点变化&lt;/strong&gt;。这与Java的&lt;strong&gt;使用站点差异&lt;/strong&gt;相反，在Java中，&lt;strong&gt;使用&lt;/strong&gt;类型中的通配符使类型成为协变。</target>
        </trans-unit>
        <trans-unit id="e4cdeee14d0ede31e2c00aaa982268d6ad103b09" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;wildcard type argument&lt;/strong&gt;&lt;code&gt;? extends E&lt;/code&gt; indicates that this method accepts a collection of objects of &lt;code&gt;E&lt;/code&gt;&lt;em&gt;or some subtype of&lt;/em&gt;&lt;code&gt;E&lt;/code&gt;, not just &lt;code&gt;E&lt;/code&gt; itself. This means that we can safely &lt;strong&gt;read&lt;/strong&gt;&lt;code&gt;E&lt;/code&gt;'s from items (elements of this collection are instances of a subclass of E), but &lt;strong&gt;cannot write&lt;/strong&gt; to it since we do not know what objects comply to that unknown subtype of &lt;code&gt;E&lt;/code&gt;. In return for this limitation, we have the desired behaviour: &lt;code&gt;Collection&amp;lt;String&amp;gt;&lt;/code&gt;&lt;em&gt;is&lt;/em&gt; a subtype of &lt;code&gt;Collection&amp;lt;? extends Object&amp;gt;&lt;/code&gt;. In &quot;clever words&quot;, the wildcard with an &lt;strong&gt;extends&lt;/strong&gt;-bound (&lt;strong&gt;upper&lt;/strong&gt; bound) makes the type &lt;strong&gt;covariant&lt;/strong&gt;.</source>
          <target state="translated">该&lt;strong&gt;通配符类型参数&lt;/strong&gt; &lt;code&gt;? extends E&lt;/code&gt; 表明，该方法接受对象的集合 &lt;code&gt;E&lt;/code&gt; &lt;em&gt;或某些亚型&lt;/em&gt; &lt;code&gt;E&lt;/code&gt; ，不只是 &lt;code&gt;E&lt;/code&gt; 本身。这意味着我们可以从项目中安全地&lt;strong&gt;读取&lt;/strong&gt; &lt;code&gt;E&lt;/code&gt; （此集合的元素是E的子类的实例），但是由于我们不知道哪些对象符合该 &lt;code&gt;E&lt;/code&gt; 的未知子类型，&lt;strong&gt;因此无法对其进行写入&lt;/strong&gt;。作为此限制的回报，我们具有所需的行为： &lt;code&gt;Collection&amp;lt;String&amp;gt;&lt;/code&gt; &lt;em&gt;是&lt;/em&gt; &lt;code&gt;Collection&amp;lt;? extends Object&amp;gt;&lt;/code&gt; 的子类型。扩展Object&amp;gt;。在&amp;ldquo;聪明话&amp;rdquo;，用一个通配符&lt;strong&gt;延伸&lt;/strong&gt;结合的（&lt;strong&gt;上&lt;/strong&gt;&lt;em&gt;&lt;/em&gt;&lt;strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;/strong&gt;bound）使类型为&lt;strong&gt;covariant&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="1a90eeb87b3e982cfd1ef4a4b65cfd6c27586462" translate="yes" xml:space="preserve">
          <source>The Android world has many popular frameworks simplifying development. You can use the same frameworks if you develop in Kotlin, often as easily as you'd do that in Java. This tutorial provides examples and highlights the differences in settings.</source>
          <target state="translated">Android世界有许多流行的框架简化了开发。如果你用Kotlin开发,可以使用同样的框架,往往就像在Java中开发一样简单。本教程提供了一些例子,并强调了设置的差异。</target>
        </trans-unit>
        <trans-unit id="d41ba3261445c389f8874772f5879ab48af811af" translate="yes" xml:space="preserve">
          <source>The C data variable containing the pointer to &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">包含指向 &lt;code&gt;T&lt;/code&gt; 的指针的C数据变量。</target>
        </trans-unit>
        <trans-unit id="05360f394dd3e60e07e614be2588088eb89e3b72" translate="yes" xml:space="preserve">
          <source>The C data variable located in memory.</source>
          <target state="translated">位于内存中的C数据变量。</target>
        </trans-unit>
        <trans-unit id="cf919179eecf4647d490ce563cdd6bff132af96d" translate="yes" xml:space="preserve">
          <source>The C function.</source>
          <target state="translated">C功能。</target>
        </trans-unit>
        <trans-unit id="d36502dcbc1bebedd6773776218e3117a26820bc" translate="yes" xml:space="preserve">
          <source>The C primitive-typed variable located in memory.</source>
          <target state="translated">位于内存中的C基元类型的变量。</target>
        </trans-unit>
        <trans-unit id="639b72b8a51545cc688d8100df8871c5e14d7a1a" translate="yes" xml:space="preserve">
          <source>The C struct-typed variable located in memory.</source>
          <target state="translated">位于内存中的C结构类型的变量。</target>
        </trans-unit>
        <trans-unit id="c4b0fbfe88d7c41e706fcbcc447e39c33c492192" translate="yes" xml:space="preserve">
          <source>The CocoaPods plugin also allows using CocoaPods libraries without manual configuring cinterop parameters (see the &lt;a href=&quot;../building-mpp-with-gradle#cinterop-support&quot;&gt;corresponding section&lt;/a&gt; of the multiplatform plugin documentation). The &lt;code&gt;cocoapods { ... }&lt;/code&gt; code block allows you to add dependencies on CocoaPods libraries.</source>
          <target state="translated">CocoaPods插件还允许使用CocoaPods库，而无需手动配置cinterop参数（请参阅多平台插件文档的&lt;a href=&quot;../building-mpp-with-gradle#cinterop-support&quot;&gt;相应部分&lt;/a&gt;）。该 &lt;code&gt;cocoapods { ... }&lt;/code&gt; 代码块可以让你在的CocoaPods库添加依赖。</target>
        </trans-unit>
        <trans-unit id="8779fd3a2cac48558378b86549bbda66333c4276" translate="yes" xml:space="preserve">
          <source>The CocoaPods support is implemented in a separate Gradle plugin: &lt;code&gt;org.jetbrains.kotlin.native.cocoapods&lt;/code&gt;.</source>
          <target state="translated">CocoaPods支持在单独的Gradle插件中实现： &lt;code&gt;org.jetbrains.kotlin.native.cocoapods&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bd3aa1e3e57f3eb3ef63cd39980df09053647402" translate="yes" xml:space="preserve">
          <source>The Coroutine Debugger of the Kotlin plugin simplifies debugging coroutines in IntelliJ IDEA.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24a56079ca4afabfa7a909e10193add3dd7a492a" translate="yes" xml:space="preserve">
          <source>The DOM also provides us a way to retrieve a specific element by ID, name, class name, tag name and so on. All returned elements are of type &lt;code&gt;NodeList&lt;/code&gt;, and to access members we need to cast them to the specific type of element. The code below shows how we could access an input element on the page:</source>
          <target state="translated">DOM还为我们提供了一种通过ID，名称，类名称，标签名称等检索特定元素的方法。返回的所有元素均为 &lt;code&gt;NodeList&lt;/code&gt; 类型，要访问成员，我们需要将其强制转换为特定类型的元素。下面的代码显示了如何访问页面上的输入元素：</target>
        </trans-unit>
        <trans-unit id="325910eae4ee7077ed16505d94cb7161a53ff4ff" translate="yes" xml:space="preserve">
          <source>The Entry Point</source>
          <target state="translated">进入点</target>
        </trans-unit>
        <trans-unit id="c1f2de3caa83760aa037581086bf37c054caebbb" translate="yes" xml:space="preserve">
          <source>The Gradle file is pretty much standard for Spring Boot. The only differences are the structure layout for source folders for Kotlin, the required Kotlin dependencies and the &lt;a href=&quot;../reference/compiler-plugins#kotlin-spring-compiler-plugi&quot;&gt;&lt;em&gt;kotlin-spring&lt;/em&gt;&lt;/a&gt; Gradle plugin (CGLIB proxies used for example for &lt;code&gt;@Configuration&lt;/code&gt; and &lt;code&gt;@Bean&lt;/code&gt; processing require &lt;code&gt;open&lt;/code&gt; classes).</source>
          <target state="translated">对于Spring Boot，Gradle文件几乎是标准的。唯一的区别是Kotlin的源文件夹的结构布局，所需的Kotlin依赖关系和&lt;a href=&quot;../reference/compiler-plugins#kotlin-spring-compiler-plugi&quot;&gt;&lt;em&gt;kotlin-spring&lt;/em&gt;&lt;/a&gt; Gradle插件（用于 &lt;code&gt;@Configuration&lt;/code&gt; 和 &lt;code&gt;@Bean&lt;/code&gt; 处理的CGLIB代理需要 &lt;code&gt;open&lt;/code&gt; 类）。</target>
        </trans-unit>
        <trans-unit id="af4ea41e06d67df72de18198c84923c5e721e071" translate="yes" xml:space="preserve">
          <source>The Gradle plugin provides a separate task that creates a universal framework for iOS targets from several regular ones. The example below shows how to use this task. Note that the fat framework must have the same base name as the initial frameworks.</source>
          <target state="translated">Gradle插件提供了一个单独的任务,它可以从几个常规的目标创建一个iOS目标的通用框架。下面的例子展示了如何使用这个任务。需要注意的是,胖子框架必须与初始框架的基名相同。</target>
        </trans-unit>
        <trans-unit id="c9686505fe7f54579b832493ec5b1983b12000c6" translate="yes" xml:space="preserve">
          <source>The JS typed arrays support that translates Kotlin primitive arrays, such as &lt;code&gt;IntArray&lt;/code&gt;, &lt;code&gt;DoubleArray&lt;/code&gt;, into &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Typed_arrays&quot;&gt;JavaScript typed arrays&lt;/a&gt;, that was previously an opt-in feature, has been enabled by default.</source>
          <target state="translated">JS类型的数组支持可将Kotlin基本数组（例如 &lt;code&gt;IntArray&lt;/code&gt; ， &lt;code&gt;DoubleArray&lt;/code&gt; ）转换为&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Typed_arrays&quot;&gt;JavaScript类型的数组&lt;/a&gt;（以前是选择加入功能），默认情况下已启用。</target>
        </trans-unit>
        <trans-unit id="37ed5aeb9956cf68199e058567f26ab71cd7268f" translate="yes" xml:space="preserve">
          <source>The JSR-305 checks can be configured by adding the &lt;code&gt;-Xjsr305&lt;/code&gt; compiler flag with the following options (and their combination):</source>
          <target state="translated">可以通过添加 &lt;code&gt;-Xjsr305&lt;/code&gt; 编译器标志以及以下选项（及其组合）来配置JSR-305检查：</target>
        </trans-unit>
        <trans-unit id="8614662835decc941fb88cef784012c8f902a438" translate="yes" xml:space="preserve">
          <source>The Kotlin Android Extensions plugin allows us to obtain the same experience we have with some of these libraries, without having to add any extra code.</source>
          <target state="translated">Kotlin Android Extensions插件可以让我们获得与其中一些库相同的体验,而无需添加任何额外的代码。</target>
        </trans-unit>
        <trans-unit id="3fa035c9f4f03b0b989b6313990e3a366a7fc07b" translate="yes" xml:space="preserve">
          <source>The Kotlin Gradle plugin 1.4.10 works with Gradle 5.4 and later. The &lt;code&gt;kotlin-multiplatform&lt;/code&gt; plugin requires Gradle 6.0 or later.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b801cd7f041e6d90c21e7238c859980046339a8a" translate="yes" xml:space="preserve">
          <source>The Kotlin Gradle plugin supports incremental compilation. Incremental compilation tracks changes of source files between builds so only files affected by these changes would be compiled.</source>
          <target state="translated">Kotlin Gradle插件支持增量编译。增量编译可以跟踪两次构建之间源文件的变化,因此只有受这些变化影响的文件才会被编译。</target>
        </trans-unit>
        <trans-unit id="11818c172874b525f41c4774ffd3a8d06183ee2a" translate="yes" xml:space="preserve">
          <source>The Kotlin Maven Plugin needs to be referenced to compile the sources:</source>
          <target state="translated">需要引用Kotlin Maven插件来编译源代码。</target>
        </trans-unit>
        <trans-unit id="e701f1b663fc8e1d541e7d7bed4b022ef1cd48e3" translate="yes" xml:space="preserve">
          <source>The Kotlin Standard Library provides a comprehensive set of tools for managing &lt;em&gt;collections&lt;/em&gt; &amp;ndash; groups of a variable number of items (possibly zero) that share significance to the problem being solved and are operated upon commonly.</source>
          <target state="translated">Kotlin标准库提供了一套全面的工具来管理&lt;em&gt;馆藏&lt;/em&gt; -数量可变的项目组（可能为零），这些项目对已解决的问题具有重要意义并可以共同操作。</target>
        </trans-unit>
        <trans-unit id="8a031299bd7c193b637e92a822d8538f69af9b3a" translate="yes" xml:space="preserve">
          <source>The Kotlin Standard Library provides implementations for basic collection types: sets, lists, and maps. A pair of interfaces represent each collection type:</source>
          <target state="translated">Kotlin标准库提供了基本集合类型的实现:集合、列表和地图。一对接口代表了每种集合类型。</target>
        </trans-unit>
        <trans-unit id="3f614163c9f0e1a9b558eccd140b5d89bbaff4cb" translate="yes" xml:space="preserve">
          <source>The Kotlin Standard Library provides living essentials for everyday work with Kotlin. These include:</source>
          <target state="translated">Kotlin标准库提供了使用Kotlin进行日常工作的生活必需品。其中包括:</target>
        </trans-unit>
        <trans-unit id="33a29a3734d935aaab60c852c81fd82eccf705fa" translate="yes" xml:space="preserve">
          <source>The Kotlin code is turned into very similar looking code in Swift. There are some small differences, though. In Kotlin any &lt;code&gt;object&lt;/code&gt; has only one instance. Kotlin &lt;code&gt;object Object&lt;/code&gt; now has a constructor in Swift, and we use the &lt;code&gt;Object()&lt;/code&gt; syntax to access the only instance of it. The instance is always the same in Swift, so that &lt;code&gt;Object() === Object()&lt;/code&gt; is true. Methods and property names are translated as-is. Kotlin &lt;code&gt;String&lt;/code&gt; is turned into Swift &lt;code&gt;String&lt;/code&gt; too. Swift hides &lt;code&gt;NSNumber*&lt;/code&gt; boxing from us too. We pass Swift closure to Kotlin and call a Kotlin lambda function from Swift too.</source>
          <target state="translated">在Swift中，Kotlin代码变成了非常相似的代码。不过，还是有一些细微的差别。在Kotlin中，任何 &lt;code&gt;object&lt;/code&gt; 只有一个实例。 Kotlin &lt;code&gt;object Object&lt;/code&gt; 现在在Swift中具有一个构造函数，我们使用 &lt;code&gt;Object()&lt;/code&gt; 语法访问它的唯一实例。实例在Swift中始终是相同的，因此 &lt;code&gt;Object() === Object()&lt;/code&gt; 为true。方法和属性名称按原样翻译。 Kotlin &lt;code&gt;String&lt;/code&gt; 也变成了Swift &lt;code&gt;String&lt;/code&gt; 。 Swift 也向我们隐藏了 &lt;code&gt;NSNumber*&lt;/code&gt; 拳击。我们将Swift闭包传递给Kotlin，也从Swift调用Kotlin lambda函数。</target>
        </trans-unit>
        <trans-unit id="a82d7ab28c8dc762af0699f165239106b9d7ca89" translate="yes" xml:space="preserve">
          <source>The Kotlin collections package contains extension functions for popular operations on sets: finding intersections, merging, or subtracting collections from each other.</source>
          <target state="translated">Kotlin集合包包含了对集合的常用操作的扩展函数:寻找交集、合并或相互减去集合。</target>
        </trans-unit>
        <trans-unit id="5352e834912895fb7e864dc749c6a67a63a5c1bd" translate="yes" xml:space="preserve">
          <source>The Kotlin collections package provides functions for sorting collections in natural, custom, and even random orders. On this page, we'll describe sorting functions that apply to &lt;a href=&quot;collections-overview#collection-types&quot;&gt;read-only&lt;/a&gt; collections. These functions return their result as a new collection containing the elements of the original collection in the requested order. To learn about functions for sorting &lt;a href=&quot;collections-overview#collection-types&quot;&gt;mutable&lt;/a&gt; collections in place, see the &lt;a href=&quot;list-operations#sorting&quot;&gt;List Specific Operations&lt;/a&gt;.</source>
          <target state="translated">Kotlin集合包提供了用于以自然，自定义甚至随机顺序对集合进行排序的功能。在此页面上，我们将描述适用于&lt;a href=&quot;collections-overview#collection-types&quot;&gt;只读&lt;/a&gt;集合的排序功能。这些函数将其结果作为一个新集合返回，该新集合按请求的顺序包含原始集合的元素。要了解就地对&lt;a href=&quot;collections-overview#collection-types&quot;&gt;可变&lt;/a&gt;集合进行排序的功能，请参阅&amp;ldquo; &lt;a href=&quot;list-operations#sorting&quot;&gt;特定&lt;/a&gt;于列表的操作&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="606ec4093466ccf8ac7dfb28ac45fda128eb6073" translate="yes" xml:space="preserve">
          <source>The Kotlin compiler can now use information from type casts in type inference. If you&amp;rsquo;re calling a generic method that returns a type parameter &lt;code&gt;T&lt;/code&gt; and casting the return value to a specific type &lt;code&gt;Foo&lt;/code&gt;, the compiler now understands that &lt;code&gt;T&lt;/code&gt; for this call needs to be bound to the type &lt;code&gt;Foo&lt;/code&gt;.</source>
          <target state="translated">Kotlin编译器现在可以在类型推断中使用来自类型转换的信息。如果您正在调用一个返回类型参数 &lt;code&gt;T&lt;/code&gt; 的泛型方法，并将返回值转换为特定的 &lt;code&gt;Foo&lt;/code&gt; 类型，则编译器现在可以理解，此调用的 &lt;code&gt;T&lt;/code&gt; 必须绑定到 &lt;code&gt;Foo&lt;/code&gt; 类型。</target>
        </trans-unit>
        <trans-unit id="3ccc8c3cdb40fba2c36169a3fed32ce41fa13cee" translate="yes" xml:space="preserve">
          <source>The Kotlin compiler does extensive static analysis to provide warnings and reduce boilerplate. One of the most notable features is smartcasts &amp;mdash; with the ability to perform a cast automatically based on the performed type checks:</source>
          <target state="translated">Kotlin编译器会进行大量的静态分析，以提供警告并减少样板。最著名的功能之一是智能广播-具有根据执行的类型检查自动执行强制转换的功能：</target>
        </trans-unit>
        <trans-unit id="9b9028d4b3725e4248715dfa8cff6060191e14fa" translate="yes" xml:space="preserve">
          <source>The Kotlin compiler provides all the necessary information about &lt;code&gt;prop&lt;/code&gt; in the arguments: the first argument &lt;code&gt;this&lt;/code&gt; refers to an instance of the outer class &lt;code&gt;C&lt;/code&gt; and &lt;code&gt;this::prop&lt;/code&gt; is a reflection object of the &lt;code&gt;KProperty&lt;/code&gt; type describing &lt;code&gt;prop&lt;/code&gt; itself.</source>
          <target state="translated">所述编译器科特林提供了有关所有必要的信息 &lt;code&gt;prop&lt;/code&gt; 中的参数：第一个参数 &lt;code&gt;this&lt;/code&gt; 指外类的一个实例 &lt;code&gt;C&lt;/code&gt; 和 &lt;code&gt;this::prop&lt;/code&gt; 是的反射对象 &lt;code&gt;KProperty&lt;/code&gt; 类型描述 &lt;code&gt;prop&lt;/code&gt; 本身。</target>
        </trans-unit>
        <trans-unit id="d8f9b6bf737be7b0aa49748489bb11aedc0ed8e0" translate="yes" xml:space="preserve">
          <source>The Kotlin compiler tries to comply with the following goals:</source>
          <target state="translated">Kotlin编译器试图遵守以下目标。</target>
        </trans-unit>
        <trans-unit id="84694c64245d13b803ebc2f9a85d6bc26cef8561" translate="yes" xml:space="preserve">
          <source>The Kotlin compiler will prefer using underlying types instead of wrappers to produce the most performant and optimized code. However, sometimes it is necessary to keep wrappers around. As a rule of thumb, inline classes are boxed whenever they are used as another type.</source>
          <target state="translated">Kotlin编译器会更倾向于使用底层类型而不是包装器,以产生性能最强、最优化的代码。然而,有时有必要保留包装器。作为一个经验法则,只要内联类被用作另一种类型,就会被装箱。</target>
        </trans-unit>
        <trans-unit id="b1defae0fa9dbdfd545ce26ab8cc2b793d3d11fe" translate="yes" xml:space="preserve">
          <source>The Kotlin compiler will use this restriction to aggressively optimize runtime representation of inline classes and substitute their instances with the value of the underlying property where possible removing constructor calls, GC pressure, and enabling other optimizations:</source>
          <target state="translated">Kotlin编译器将利用这一限制来积极优化内联类的运行时表示,并在可能的情况下用底层属性的值来替代它们的实例,消除构造函数调用、GC压力,并实现其他优化。</target>
        </trans-unit>
        <trans-unit id="d850079f06081665ec514cb65c4f969e8d679814" translate="yes" xml:space="preserve">
          <source>The Kotlin language and toolset are divided into many components such as the compilers for the JVM, JS and Native targets, the Standard Library, various accompanying tools and so on. Many of these components were officially released as &lt;strong&gt;Stable&lt;/strong&gt; which means that they are evolved in the backward-compatible way following the &lt;a href=&quot;kotlin-evolution&quot;&gt;principles&lt;/a&gt; of &lt;em&gt;Comfortable Updates&lt;/em&gt; and &lt;em&gt;Keeping the Language Modern&lt;/em&gt;. Among such stable components are, for example, the Kotlin compiler for the JVM, the Standard Library, and Coroutines.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="421148b46361ca016988f110ea6a768864eebc2b" translate="yes" xml:space="preserve">
          <source>The Kotlin plugin also bundles a Java to Kotlin converter (&lt;em&gt;J2K&lt;/em&gt;) that automatically converts Java files to Kotlin. To use J2K on a file, click &lt;strong&gt;Convert Java File to Kotlin File&lt;/strong&gt; in its context menu or in the &lt;strong&gt;Code&lt;/strong&gt; menu of IntelliJ IDEA.</source>
          <target state="translated">Kotlin插件还捆绑了Java到Kotlin转换器（&lt;em&gt;J2K&lt;/em&gt;），该转换器可自动将Java文件转换为Kotlin。要在文件上使用J2K，请在其上下文菜单或IntelliJ IDEA 的&lt;strong&gt;&amp;ldquo;代码&amp;rdquo;&lt;/strong&gt;菜单中单击&amp;ldquo; &lt;strong&gt;将Java文件转换为Kotlin文件&lt;/strong&gt;&lt;strong&gt;&amp;rdquo;&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="f2e3c8e9ac9f87a3c6a3c66f4442bdb2dd4de716" translate="yes" xml:space="preserve">
          <source>The Kotlin plugin for IntelliJ IDEA supports &lt;a href=&quot;https://www.jetbrains.com/help/idea/scratches.html&quot;&gt;&lt;em&gt;scratches&lt;/em&gt;&lt;/a&gt; and &lt;em&gt;worksheets.&lt;/em&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d656f515ef009525fec5de5fd6f927dce6dbed0" translate="yes" xml:space="preserve">
          <source>The Kotlin plugin supports &lt;a href=&quot;https://guides.gradle.org/using-build-cache/&quot;&gt;Gradle Build Cache&lt;/a&gt; (Gradle version 4.3 and above is required; caching is disabled with lower versions).</source>
          <target state="translated">Kotlin插件支持&lt;a href=&quot;https://guides.gradle.org/using-build-cache/&quot;&gt;Gradle Build Cache&lt;/a&gt;（需要版本4.3及更高版本；缓存在较低版本中被禁用）。</target>
        </trans-unit>
        <trans-unit id="bb12e098841b4fa9ff61972654d2907071becf6c" translate="yes" xml:space="preserve">
          <source>The Kotlin plugin supports &lt;a href=&quot;https://guides.gradle.org/using-build-cache/&quot;&gt;Gradle Build Cache&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e886321a88f27f1211fc7e6327218f1b649f0a9" translate="yes" xml:space="preserve">
          <source>The Kotlin sources are arranged into &lt;a href=&quot;#configuring-source-sets&quot;&gt;source sets&lt;/a&gt;. In addition to Kotlin source files and resources, each source set may have its own dependencies. Source sets form a hierarchy that is built with the &lt;em&gt;&quot;depends on&quot;&lt;/em&gt; relation. A source set by itself is platform agnostic, but it may contain platform-specific code and dependencies if it's only compiled for a single platform.</source>
          <target state="translated">Kotlin源被整理成&lt;a href=&quot;#configuring-source-sets&quot;&gt;源集&lt;/a&gt;。除了Kotlin源文件和资源外，每个源集可能都有其自己的依赖性。源集形成使用&lt;em&gt;&amp;ldquo;依赖&amp;rdquo;&lt;/em&gt;关系构建的层次结构。源集本身与平台无关，但如果仅针对单个平台进行编译，则它可能包含特定于平台的代码和依赖项。</target>
        </trans-unit>
        <trans-unit id="16279f302f8a88f25bf841c70c273ae22857462c" translate="yes" xml:space="preserve">
          <source>The Kotlin standard library &lt;code&gt;kotlin-stdlib&lt;/code&gt; targets Java 6 and above. There are extended versions of the standard library that add support for some of the features of JDK 7 and JDK 8. To use these versions, add one of the following dependencies instead of &lt;code&gt;kotlin-stdlib&lt;/code&gt;:</source>
          <target state="translated">Kotlin标准库 &lt;code&gt;kotlin-stdlib&lt;/code&gt; 针对Java 6及更高版本。标准库的扩展版本增加了对JDK 7和JDK 8某些功能的支持。要使用这些版本，请添加以下依赖项之一而不是 &lt;code&gt;kotlin-stdlib&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="e19faba3d18413b5a548d796d002602d1f6b7b0d" translate="yes" xml:space="preserve">
          <source>The Kotlin standard library contains extension functions for retrieving parts of a collection. These functions provide a variety of ways to select elements for the result collection: listing their positions explicitly, specifying the result size, and others.</source>
          <target state="translated">Kotlin标准库中包含了用于检索集合的部分内容的扩展函数,这些函数提供了为结果集合选择元素的各种方法:明确列出位置,指定结果大小等。这些函数提供了为结果集合选择元素的多种方法:显式列出它们的位置、指定结果大小等。</target>
        </trans-unit>
        <trans-unit id="aee8a9e1bcfd6364e58b2c53a697014bcd222ec2" translate="yes" xml:space="preserve">
          <source>The Kotlin standard library contains several functions whose sole purpose is to execute a block of code within the context of an object. When you call such a function on an object with a &lt;a href=&quot;lambdas&quot;&gt;lambda expression&lt;/a&gt; provided, it forms a temporary scope. In this scope, you can access the object without its name. Such functions are called &lt;em&gt;scope functions&lt;/em&gt;. There are five of them: &lt;code&gt;let&lt;/code&gt;, &lt;code&gt;run&lt;/code&gt;, &lt;code&gt;with&lt;/code&gt;, &lt;code&gt;apply&lt;/code&gt;, and &lt;code&gt;also&lt;/code&gt;.</source>
          <target state="translated">Kotlin标准库包含几个函数，其唯一目的是在对象的上下文中执行代码块。当您在提供了&lt;a href=&quot;lambdas&quot;&gt;lambda表达式&lt;/a&gt;的对象上调用此类函数时，它将形成一个临时作用域。在此作用域中，您可以访问没有其名称的对象。这种功能称为&lt;em&gt;范围功能&lt;/em&gt;。其中有五个： &lt;code&gt;let&lt;/code&gt; ， &lt;code&gt;run&lt;/code&gt; ， &lt;code&gt;with&lt;/code&gt; ， &lt;code&gt;apply&lt;/code&gt; 和 &lt;code&gt;also&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="41ab82952f2d2fb6d715a1d54dee47f369b23a5d" translate="yes" xml:space="preserve">
          <source>The Kotlin standard library is available on &lt;a href=&quot;https://www.npmjs.com/&quot;&gt;npm&lt;/a&gt; and we can simply include it in our &lt;code&gt;package.json&lt;/code&gt; as a dependency.</source>
          <target state="translated">Kotlin标准库在&lt;a href=&quot;https://www.npmjs.com/&quot;&gt;npm&lt;/a&gt;上可用，我们可以简单地将其作为依赖项包含在 &lt;code&gt;package.json&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="aa008c18e28c0e852d10e5f6a39e59c2d9ab879a" translate="yes" xml:space="preserve">
          <source>The Kotlin standard library is now fully compatible with the Java 9 module system, which forbids split packages (multiple jar files declaring classes in the same package). In order to support that, new artifacts &lt;code&gt;kotlin-stdlib-jdk7&lt;/code&gt; and &lt;code&gt;kotlin-stdlib-jdk8&lt;/code&gt; are introduced, which replace the old &lt;code&gt;kotlin-stdlib-jre7&lt;/code&gt; and &lt;code&gt;kotlin-stdlib-jre8&lt;/code&gt;.</source>
          <target state="translated">Kotlin标准库现在与Java 9模块系统完全兼容，该系统禁止拆分软件包（多个jar文件在同一软件包中声明类）。为了支持这一点， &lt;code&gt;kotlin-stdlib-jdk7&lt;/code&gt; 新的工件kotlin-stdlib-jdk7和 &lt;code&gt;kotlin-stdlib-jdk8&lt;/code&gt; ，它们替代了旧的 &lt;code&gt;kotlin-stdlib-jre7&lt;/code&gt; 和 &lt;code&gt;kotlin-stdlib-jre8&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="870dd777a08235fb630e1002ab11ba8d4d93e900" translate="yes" xml:space="preserve">
          <source>The Kotlin standard library offers a broad variety of functions for performing operations on collections. This includes simple operations, such as getting or adding elements, as well as more complex ones including search, sorting, filtering, transformations, and so on.</source>
          <target state="translated">Kotlin标准库提供了各种各样的函数,用于对集合进行操作。这包括简单的操作,如获取或添加元素,以及更复杂的操作,包括搜索、排序、过滤、转换等。</target>
        </trans-unit>
        <trans-unit id="7504a2da20208970eadd23d20d879fda0292513a" translate="yes" xml:space="preserve">
          <source>The Kotlin standard library provides a series of wrappers around the JavaScript API for interacting with documents. The main component we'd usually access is the variable &lt;code&gt;document&lt;/code&gt;. Given we have access to this, we can simply read and write to the corresponding properties. For instance, to set the background of the page we can do</source>
          <target state="translated">Kotlin标准库围绕JavaScript API提供了一系列包装器，用于与文档进行交互。我们通常访问的主要组件是变量 &lt;code&gt;document&lt;/code&gt; 。有了我们可以访问的权限，我们可以简单地读取和写入相应的属性。例如，要设置页面背景，我们可以</target>
        </trans-unit>
        <trans-unit id="d4672fe3591cd8e490f322d7264f5d7b48dbb930" translate="yes" xml:space="preserve">
          <source>The Kotlin standard library provides a set of extension functions for collection &lt;em&gt;transformations&lt;/em&gt;. These functions build new collections from existing ones based on the transformation rules provided. In this page, we'll give an overview of the available collection transformation functions.</source>
          <target state="translated">Kotlin标准库提供了一组用于集合&lt;em&gt;转换&lt;/em&gt;的扩展功能。这些函数根据提供的转换规则从现有集合中构建新集合。在此页面中，我们将概述可用的集合转换功能。</target>
        </trans-unit>
        <trans-unit id="0d403b1b6b6cec3fc85d2c8444ad4595fd15211b" translate="yes" xml:space="preserve">
          <source>The Kotlin standard library provides developers with a mechanism for creating and using &lt;em&gt;experimental&lt;/em&gt; APIs. This mechanism lets library authors inform users that certain components of their API, such as classes or functions, are unstable and are likely to change in the future. Such changes may require rewriting and recompiling the client code. To prevent potential compatibility issues, the compiler warns users of the experimental status of such APIs and may require them to give their explicit consent to use the API.</source>
          <target state="translated">Kotlin标准库为开发人员提供了创建和使用&lt;em&gt;实验性&lt;/em&gt; API 的机制。通过这种机制，库作者可以通知用户其API的某些组件（例如类或函数）是不稳定的，并且将来可能会更改。此类更改可能需要重写并重新编译客户端代码。为避免潜在的兼容性问题，编译器会警告用户此类API的实验状态，并可能要求他们明确表示同意使用该API。</target>
        </trans-unit>
        <trans-unit id="25b12f54730219e6bd01543d34c7f6d86941696e" translate="yes" xml:space="preserve">
          <source>The Kotlin standard library provides extension functions for grouping collection elements. The basic function &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/group-by&quot;&gt;&lt;code&gt;groupBy()&lt;/code&gt;&lt;/a&gt; takes a lambda function and returns a &lt;code&gt;Map&lt;/code&gt;. In this map, each key is the lambda result and the corresponding value is the &lt;code&gt;List&lt;/code&gt; of elements on which this result is returned. This function can be used, for example, to group a list of &lt;code&gt;String&lt;/code&gt;s by their first letter.</source>
          <target state="translated">Kotlin标准库提供了用于对集合元素进行分组的扩展功能。基本函数&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/group-by&quot;&gt; &lt;code&gt;groupBy()&lt;/code&gt; &lt;/a&gt;使用lambda函数并返回 &lt;code&gt;Map&lt;/code&gt; 。在此映射中，每个键都是lambda结果，而对应的值是返回此结果的元素 &lt;code&gt;List&lt;/code&gt; 。例如，可以使用此函数将 &lt;code&gt;String&lt;/code&gt; 列表按首字母分组。</target>
        </trans-unit>
        <trans-unit id="d49763e3623bb841ba6b661af00bff69df48a815" translate="yes" xml:space="preserve">
          <source>The Kotlin standard library provides factory methods for several useful kinds of delegates.</source>
          <target state="translated">Kotlin标准库为几种有用的代表提供了工厂方法。</target>
        </trans-unit>
        <trans-unit id="d4752902cbbab973b31545d271408bf4e6b55c29" translate="yes" xml:space="preserve">
          <source>The Kotlin team offers a set of tools for Android development that goes beyond the standard language features:</source>
          <target state="translated">Kotlin团队为Android开发提供了一套超越标准语言功能的工具。</target>
        </trans-unit>
        <trans-unit id="3835dcf5cfa983896474e2202e8aad1e87118beb" translate="yes" xml:space="preserve">
          <source>The Kotlin visibilities are mapped to Java in the following way:</source>
          <target state="translated">Kotlin的可视性以如下方式映射到Java。</target>
        </trans-unit>
        <trans-unit id="ed293f7536e6525a4d07d9691dc5108b394e4a3c" translate="yes" xml:space="preserve">
          <source>The Kotlin visibility modifiers map to Java in the following way:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f818f7eac72c440d892f7b7bd134c99b2cf031b4" translate="yes" xml:space="preserve">
          <source>The Kotlin/JS Gradle plugin handles DCE automatically when you build a &lt;strong&gt;production bundle&lt;/strong&gt;, for example by using the &lt;code&gt;browserProductionWebpack&lt;/code&gt; task. &lt;strong&gt;Development bundling&lt;/strong&gt; tasks (like &lt;code&gt;browserDevelopmentWebpack&lt;/code&gt;) don't include DCE.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e48978274145dccf82bae99c2dc2a30b0c91f68" translate="yes" xml:space="preserve">
          <source>The Kotlin/JS Gradle plugin includes a &lt;a href=&quot;https://wikipedia.org/wiki/Dead_code_elimination&quot;&gt;&lt;em&gt;dead code elimination&lt;/em&gt;&lt;/a&gt; (&lt;em&gt;DCE&lt;/em&gt;) tool. Dead code elimination is often also called &lt;em&gt;tree shaking&lt;/em&gt;. It reduces the size or the resulting JavaScript code by removing unused properties, functions, and classes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d899757cb2398280c10acb19695bbcab979ce63" translate="yes" xml:space="preserve">
          <source>The Kotlin/Native compiler is available for macOS, Linux, and Windows. It supports different targets including iOS (arm32, arm64, simulator x86_64), Windows (mingw32 and x86_64), Linux (x86_64, arm64, MIPS), macOS (x86_64), Raspberry PI, SMT32, WASM. For the full list of targets we can refer to the &lt;a href=&quot;../../reference/native-overview&quot;&gt;Kotlin/Native overview&lt;/a&gt;. While cross-platform compilation is possible (i.e., using one platform to compile for another), in this first tutorial we are only compiling for the operating system we're running on.</source>
          <target state="translated">Kotlin / Native编译器可用于macOS，Linux和Windows。它支持不同的目标，包括iOS（arm32，arm64，模拟器x86_64），Windows（mingw32和x86_64），Linux（x86_64，arm64，MIPS），macOS（x86_64），Raspberry PI，SMT32，WASM。有关目标的完整列表，请参阅&lt;a href=&quot;../../reference/native-overview&quot;&gt;Kotlin / Native概述&lt;/a&gt;。尽管可以进行跨平台编译（即，使用一个平台编译另一个平台），但在本教程的第一个教程中，我们仅针对正在运行的操作系统进行编译。</target>
        </trans-unit>
        <trans-unit id="81130cfc1e83adbcab9e6da86955c53516b100d6" translate="yes" xml:space="preserve">
          <source>The Language Committee makes final decisions on what incompatible changes will be made and what exact measures should be taken to make user updates comfortable. In doing so, it relies on a set of guidelines available &lt;a href=&quot;https://kotlinlang.org/foundation/language-committee-guidelines.html&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">语言委员会对将进行哪些不兼容的更改以及应采取什么确切的措施使用户感到满意做出最终决定。为此，它依赖于&lt;a href=&quot;https://kotlinlang.org/foundation/language-committee-guidelines.html&quot;&gt;此处&lt;/a&gt;提供的一组准则。</target>
        </trans-unit>
        <trans-unit id="ef80e6d685a55893a99e950f4ed7fce2a86a1387" translate="yes" xml:space="preserve">
          <source>The Maven coordinates can be altered and additional artifact files may be added to the publications within the &lt;code&gt;targets { ... }&lt;/code&gt; block or the &lt;code&gt;publishing { ... }&lt;/code&gt; DSL:</source>
          <target state="translated">可以更改Maven坐标，并且可以将其他工件文件添加到 &lt;code&gt;targets { ... }&lt;/code&gt; 块或 &lt;code&gt;publishing { ... }&lt;/code&gt; DSL内的发布中：</target>
        </trans-unit>
        <trans-unit id="88e2042b128835939040b35b47b76d2e41113fdc" translate="yes" xml:space="preserve">
          <source>The Node.js target provided by Kotlin/JS enables you to create applications that &lt;strong&gt;run on a server&lt;/strong&gt; or get &lt;strong&gt;executed on serverless infrastructure&lt;/strong&gt;. You benefit from the same advantages as other applications executing in a JavaScript runtime, such as &lt;strong&gt;faster startup speed&lt;/strong&gt; and a &lt;strong&gt;reduced memory footprint&lt;/strong&gt;. With &lt;a href=&quot;https://github.com/Kotlin/kotlinx-nodejs&quot;&gt;&lt;code&gt;kotlinx-nodejs&lt;/code&gt;&lt;/a&gt;, you have typesafe access to the &lt;a href=&quot;https://nodejs.org/docs/latest/api/&quot;&gt;Node.js API&lt;/a&gt; directly from your Kotlin code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc27fb0be25fb775df8eea4ef2ba6465502161d0" translate="yes" xml:space="preserve">
          <source>The Nothing type</source>
          <target state="translated">虚无型</target>
        </trans-unit>
        <trans-unit id="8cc0334fa925283a3687c8c8309944d9801a3bf7" translate="yes" xml:space="preserve">
          <source>The REPL command line interface opens. You can enter any valid Kotlin code and see the result. Results are printed as variables with auto-generated names like &lt;code&gt;res*&lt;/code&gt;. You can later use such variables in the code you run in REPL.</source>
          <target state="translated">REPL命令行界面打开。您可以输入任何有效的Kotlin代码并查看结果。结果将打印为具有自动生成的名称（如 &lt;code&gt;res*&lt;/code&gt; 变量。您以后可以在REPL中运行的代码中使用此类变量。</target>
        </trans-unit>
        <trans-unit id="8fd3a2d7df046fd886264d64f792856593ec9b52" translate="yes" xml:space="preserve">
          <source>The REPL command line interface will open. You can enter any valid Kotlin code and see the result. The results are printed as variables with auto-generated names like &lt;code&gt;res*&lt;/code&gt;. You can later use such variables in the code you run in REPL.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b7ee6e00ac4369b5da7230befe3c113bdc4222a" translate="yes" xml:space="preserve">
          <source>The above code compiles. However, it will produce a runtime error if the object is not properly initialised before use or if &lt;code&gt;callAnything()&lt;/code&gt; is not defined at runtime.</source>
          <target state="translated">上面的代码进行编译。但是，如果在使用前未正确初始化对象或在运行时未定义 &lt;code&gt;callAnything()&lt;/code&gt; ，它将产生运行时错误。</target>
        </trans-unit>
        <trans-unit id="f67cd69d25bde43de96336b3847aa293b8518b9e" translate="yes" xml:space="preserve">
          <source>The above code indicates that the function is defined externally. The &lt;code&gt;@JsName(&quot;$&quot;)&lt;/code&gt; annotation allows us to map the name at runtime to &lt;code&gt;$&lt;/code&gt;. For more details on external declarations, please refer to the &lt;a href=&quot;../../reference/js-interop#external-modifier&quot;&gt;JavaScript interop documentation&lt;/a&gt;.</source>
          <target state="translated">上面的代码表明该函数是在外部定义的。该 &lt;code&gt;@JsName(&quot;$&quot;)&lt;/code&gt; 注释可以让我们的名字在运行时映射 &lt;code&gt;$&lt;/code&gt; 。有关外部声明的更多详细信息，请参考&lt;a href=&quot;../../reference/js-interop#external-modifier&quot;&gt;JavaScript interop文档&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5749a0f0fe8aac855f406af86fe841d365cd7cde" translate="yes" xml:space="preserve">
          <source>The above could also be a oneliner - and note that the compiler knows that because the &lt;code&gt;throw&lt;/code&gt; will prevent &lt;code&gt;y&lt;/code&gt; from coming into existence if &lt;code&gt;x&lt;/code&gt; is null, &lt;code&gt;y&lt;/code&gt; must be non-null if we reach the line below. Contrast this with &lt;code&gt;x?.importantFunction()&lt;/code&gt;, which is a no-op if &lt;code&gt;x&lt;/code&gt; is null.</source>
          <target state="translated">上面的内容也可能是一个单行代码-并且请注意，编译器知道，因为如果 &lt;code&gt;x&lt;/code&gt; 为null，则 &lt;code&gt;throw&lt;/code&gt; 将阻止 &lt;code&gt;y&lt;/code&gt; 的存在，因此，如果我们到达下面的行，则 &lt;code&gt;y&lt;/code&gt; 必须为非null。将此与 &lt;code&gt;x?.importantFunction()&lt;/code&gt; 进行对比，如果 &lt;code&gt;x&lt;/code&gt; 为null，则为空。</target>
        </trans-unit>
        <trans-unit id="a87217033eafba44229106ab25d3816102c24f78" translate="yes" xml:space="preserve">
          <source>The above is preferable to:</source>
          <target state="translated">以上是优于。</target>
        </trans-unit>
        <trans-unit id="83d32caa4c432fbb23e6f884577d8ac97faf56a2" translate="yes" xml:space="preserve">
          <source>The affected type parameter or type is &lt;em&gt;contravariant&lt;/em&gt;. Denoted by the &lt;code&gt;in&lt;/code&gt; modifier in the source code.</source>
          <target state="translated">受影响的类型参数或类型是&lt;em&gt;反变的&lt;/em&gt;。由源代码中的 &lt;code&gt;in&lt;/code&gt; 修饰符表示。</target>
        </trans-unit>
        <trans-unit id="c340d256f4b2e039e4cb98547a639c6b4f11b7ba" translate="yes" xml:space="preserve">
          <source>The affected type parameter or type is &lt;em&gt;covariant&lt;/em&gt;. Denoted by the &lt;code&gt;out&lt;/code&gt; modifier in the source code.</source>
          <target state="translated">受影响的类型参数或类型为&lt;em&gt;covariant&lt;/em&gt;。在源代码中由 &lt;code&gt;out&lt;/code&gt; 修饰符表示。</target>
        </trans-unit>
        <trans-unit id="dff58c2fdf74d3cdbb35c54ab0e0155e83797493" translate="yes" xml:space="preserve">
          <source>The affected type parameter or type is &lt;em&gt;invariant&lt;/em&gt;, which means it has no variance applied to it.</source>
          <target state="translated">受影响的类型参数或类型是&lt;em&gt;invariant&lt;/em&gt;，这意味着它没有应用任何变化。</target>
        </trans-unit>
        <trans-unit id="e638916d7acda84432e87e4a36d2e48c0c286bc5" translate="yes" xml:space="preserve">
          <source>The annotation also works for constructors, static methods, and so on. It can't be used on abstract methods, including methods defined in interfaces.</source>
          <target state="translated">该注解也适用于构造函数、静态方法等。它不能用于抽象方法,包括定义在接口中的方法。</target>
        </trans-unit>
        <trans-unit id="718f26b180ad67d2a1e20d6b7d4406049d2961a3" translate="yes" xml:space="preserve">
          <source>The annotation can be used on top-level external declarations (classes, properties, functions) and files. In case of file (which can't be &lt;code&gt;external&lt;/code&gt;) the following rule applies: all the declarations in the file must be &lt;code&gt;external&lt;/code&gt;. By applying &lt;code&gt;@JsModule(...)&lt;/code&gt; on a file you tell the compiler to import a JavaScript object that contain all the declarations from the file.</source>
          <target state="translated">注释可以用于顶级外部声明（类，属性，函数）和文件。如果是file（不能是 &lt;code&gt;external&lt;/code&gt; ），则遵循以下规则：文件中的所有声明都必须是 &lt;code&gt;external&lt;/code&gt; 。通过在文件上应用 &lt;code&gt;@JsModule(...)&lt;/code&gt; ，您可以告诉编译器导入一个JavaScript对象，该对象包含文件中的所有声明。</target>
        </trans-unit>
        <trans-unit id="ac7d8e089591134bac44995dadba571525f38003" translate="yes" xml:space="preserve">
          <source>The annotation has effect only in Kotlin/Native platform.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="993a0bc9861bdf8ea351a5eb1dd7c588f24a97de" translate="yes" xml:space="preserve">
          <source>The annotations for marking and using experimental APIs (&lt;code&gt;@Experimental&lt;/code&gt; and &lt;code&gt;@UseExperimental&lt;/code&gt;) are &lt;em&gt;experimental&lt;/em&gt; in Kotlin 1.3. See details &lt;a href=&quot;#experimental-status-of-experimental-api-markers&quot;&gt;below&lt;/a&gt;.</source>
          <target state="translated">标记和使用实验性API的注释（ &lt;code&gt;@Experimental&lt;/code&gt; 和 &lt;code&gt;@UseExperimental&lt;/code&gt; ）在Kotlin 1.3中是&lt;em&gt;实验性的&lt;/em&gt;。请参阅&lt;a href=&quot;#experimental-status-of-experimental-api-markers&quot;&gt;下面的&lt;/a&gt;详细信息。</target>
        </trans-unit>
        <trans-unit id="ecb7079c4ed4f36ab04fb8b963913758bd291799" translate="yes" xml:space="preserve">
          <source>The anonymous function syntax allows you to specify the receiver type of a function literal directly. This can be useful if you need to declare a variable of a function type with receiver, and to use it later.</source>
          <target state="translated">匿名函数语法允许你直接指定一个函数文字的接收器类型。如果你需要声明一个带有接收器的函数类型的变量,并在以后使用它,这可能会很有用。</target>
        </trans-unit>
        <trans-unit id="e99a96b83211ab5edf0514b0e8d206e232457fc5" translate="yes" xml:space="preserve">
          <source>The application we're going to create will simply show &lt;code&gt;Kotlin Rocks on Android&lt;/code&gt; on Android and &lt;code&gt;Kotlin Rocks on iOS &amp;lt;version&amp;gt;&lt;/code&gt; on iOS. The idea is to share the code that generates this message.</source>
          <target state="translated">我们将要创建的应用程序将仅 &lt;code&gt;Kotlin Rocks on Android&lt;/code&gt; 上的Android 上显示Kotlin Rocks， &lt;code&gt;Kotlin Rocks on iOS &amp;lt;version&amp;gt;&lt;/code&gt; 上仅显示Kotlin Rocks。想法是共享生成此消息的代码。</target>
        </trans-unit>
        <trans-unit id="c116b8d3b85f1f036748497d93f617762a69f1eb" translate="yes" xml:space="preserve">
          <source>The array literal syntax is constrained to annotation arguments.</source>
          <target state="translated">数组文字语法受制于注释参数。</target>
        </trans-unit>
        <trans-unit id="e6585b22e37432101f079b3e68122b140a6c8d0b" translate="yes" xml:space="preserve">
          <source>The arrow notation is right-associative, &lt;code&gt;(Int) -&amp;gt; (Int) -&amp;gt; Unit&lt;/code&gt; is equivalent to the previous example, but not to &lt;code&gt;((Int) -&amp;gt; (Int)) -&amp;gt; Unit&lt;/code&gt;.</source>
          <target state="translated">箭头表示法是右关联的， &lt;code&gt;(Int) -&amp;gt; (Int) -&amp;gt; Unit&lt;/code&gt; 等效于前面的示例，但不等于 &lt;code&gt;((Int) -&amp;gt; (Int)) -&amp;gt; Unit&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="eff75fbb6c3dbfe907753b9474216f02d469cd66" translate="yes" xml:space="preserve">
          <source>The author strongly recommends that you use an IDE with Kotlin support, as the static typing allows an IDE to do reliable navigation and code completion. I recommend &lt;a href=&quot;https://www.jetbrains.com/idea/&quot;&gt;IntelliJ IDEA&lt;/a&gt;, which is built by the same company that created Kotlin. The Community Edition is free; see &lt;a href=&quot;../getting-started&quot;&gt;instructions for getting started&lt;/a&gt; (it comes bundled with Kotlin, and you can run your program from the IDE).</source>
          <target state="translated">作者强烈建议您使用具有Kotlin支持的IDE，因为静态类型可以使IDE进行可靠的导航和代码完成。我推荐&lt;a href=&quot;https://www.jetbrains.com/idea/&quot;&gt;IntelliJ IDEA&lt;/a&gt;，它是由创建Kotlin的同一家公司构建的。社区版是免费的；请参阅&lt;a href=&quot;../getting-started&quot;&gt;入门说明&lt;/a&gt;（它与Kotlin捆绑在一起，您可以从IDE中运行程序）。</target>
        </trans-unit>
        <trans-unit id="031b37e00f6cc7d0005e366d6305ce9ae5158eb7" translate="yes" xml:space="preserve">
          <source>The available options for persistence include direct JDBC access, JPA, as well as using NoSQL databases through their Java drivers. For JPA, the &lt;a href=&quot;compiler-plugins#jpa-support&quot;&gt;kotlin-jpa compiler plugin&lt;/a&gt; adapts Kotlin-compiled classes to the requirements of the framework.</source>
          <target state="translated">持久性的可用选项包括直接JDBC访问，JPA以及通过其Java驱动程序使用NoSQL数据库。对于JPA，&lt;a href=&quot;compiler-plugins#jpa-support&quot;&gt;kotlin-jpa编译器插件使&lt;/a&gt; Kotlin编译的类适应框架的要求。</target>
        </trans-unit>
        <trans-unit id="f64d03b5ac4e40dff196fed46f6ad483b559e0ca" translate="yes" xml:space="preserve">
          <source>The base class for all errors and exceptions. Only instances of this class can be thrown or caught.</source>
          <target state="translated">所有错误和异常的基类。只有该类的实例可以被抛出或捕获。</target>
        </trans-unit>
        <trans-unit id="9567e5bd74f98cde043ce2604d36c00a7448fbca" translate="yes" xml:space="preserve">
          <source>The base exception class is &lt;code&gt;Throwable&lt;/code&gt; (but it is more common to extend its subclass &lt;code&gt;Exception&lt;/code&gt;), and there are a ton of built-in exception classes. If you don't find one that match your needs, you can create your own by inheriting from an existing exception class.</source>
          <target state="translated">基本异常类是 &lt;code&gt;Throwable&lt;/code&gt; （但更常见的是扩展其子类 &lt;code&gt;Exception&lt;/code&gt; ），并且有大量的内置异常类。如果找不到满足您需求的类，则可以通过从现有异常类继承来创建自己的类。</target>
        </trans-unit>
        <trans-unit id="d9ecc0f2cf4982d26aff3dd399995b9e266ca38f" translate="yes" xml:space="preserve">
          <source>The basic association function &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/associate-with&quot;&gt;&lt;code&gt;associateWith()&lt;/code&gt;&lt;/a&gt; creates a &lt;code&gt;Map&lt;/code&gt; in which the elements of the original collection are keys, and values are produced from them by the given transformation function. If two elements are equal, only the last one remains in the map.</source>
          <target state="translated">基本的关联函数&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/associate-with&quot;&gt; &lt;code&gt;associateWith()&lt;/code&gt; &lt;/a&gt;创建一个 &lt;code&gt;Map&lt;/code&gt; ，其中原始集合的元素是键，并通过给定的转换函数从中产生值。如果两个元素相等，则仅最后一个保留在地图中。</target>
        </trans-unit>
        <trans-unit id="8747487378c0fd48a48984cf8a26dd2308ffac09" translate="yes" xml:space="preserve">
          <source>The basic filtering function is &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/filter&quot;&gt;&lt;code&gt;filter()&lt;/code&gt;&lt;/a&gt;. When called with a predicate, &lt;code&gt;filter()&lt;/code&gt; returns the collection elements that match it. For both &lt;code&gt;List&lt;/code&gt; and &lt;code&gt;Set&lt;/code&gt;, the resulting collection is a &lt;code&gt;List&lt;/code&gt;, for &lt;code&gt;Map&lt;/code&gt; it's a &lt;code&gt;Map&lt;/code&gt; as well.</source>
          <target state="translated">基本的过滤功能是&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/filter&quot;&gt; &lt;code&gt;filter()&lt;/code&gt; &lt;/a&gt;。使用谓词调用时， &lt;code&gt;filter()&lt;/code&gt; 返回与其匹配的集合元素。对于 &lt;code&gt;List&lt;/code&gt; 和 &lt;code&gt;Set&lt;/code&gt; ，结果集合都是 &lt;code&gt;List&lt;/code&gt; ，对于 &lt;code&gt;Map&lt;/code&gt; 来说，它也是 &lt;code&gt;Map&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="699437afba4c1eb6f2aa1a305318c9d9571a4fe8" translate="yes" xml:space="preserve">
          <source>The basic functions &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/sorted&quot;&gt;&lt;code&gt;sorted()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/sorted-descending&quot;&gt;&lt;code&gt;sortedDescending()&lt;/code&gt;&lt;/a&gt; return elements of a collection sorted into ascending and descending sequence according to their natural order. These functions apply to collections of &lt;code&gt;Comparable&lt;/code&gt; elements.</source>
          <target state="translated">基本函数&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/sorted&quot;&gt; &lt;code&gt;sorted()&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/sorted-descending&quot;&gt; &lt;code&gt;sortedDescending()&lt;/code&gt; &lt;/a&gt;返回集合的元素，这些元素根据其自然顺序按升序和降序排序。这些功能适用于可 &lt;code&gt;Comparable&lt;/code&gt; 元素的集合。</target>
        </trans-unit>
        <trans-unit id="176655605bee6eae4892bd4ec703e94408b0c3f3" translate="yes" xml:space="preserve">
          <source>The best place to start is &lt;a href=&quot;https://kotlinlang.org&quot;&gt;this website&lt;/a&gt;. From there you can download the compiler, &lt;a href=&quot;https://play.kotlinlang.org&quot;&gt;try it online&lt;/a&gt; as well as get access to resources, &lt;a href=&quot;index&quot;&gt;reference documentation&lt;/a&gt; and &lt;a href=&quot;../tutorials/index&quot;&gt;tutorials&lt;/a&gt;.</source>
          <target state="translated">最好的起点是&lt;a href=&quot;https://kotlinlang.org&quot;&gt;这个网站&lt;/a&gt;。您可以从那里下载编译器，&lt;a href=&quot;https://play.kotlinlang.org&quot;&gt;在线试用它&lt;/a&gt;，还可以访问资源，&lt;a href=&quot;index&quot;&gt;参考文档&lt;/a&gt;和&lt;a href=&quot;../tutorials/index&quot;&gt;教程&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a00b10508469a6652d6e476b8749625b68deb8ad" translate="yes" xml:space="preserve">
          <source>The best way to see what C data types are visible in Kotlin is to try it</source>
          <target state="translated">查看Kotlin中可见的C数据类型的最好方法是尝试一下</target>
        </trans-unit>
        <trans-unit id="8cccc62dffea928c706df5dfd73f9995b0b8212a" translate="yes" xml:space="preserve">
          <source>The best way to understand the mapping between C and Kotlin languages is to try it out on a small example. We will create a small library headers for that. First, we need to create a &lt;code&gt;lib.h&lt;/code&gt; file with the following declaration of functions that deal with the C strings:</source>
          <target state="translated">理解C语言和Kotlin语言之间映射的最好方法是在一个小例子中尝试一下。我们将为此创建一个小的库头。首先，我们需要创建一个 &lt;code&gt;lib.h&lt;/code&gt; 文件，其中包含以下处理C字符串的函数声明：</target>
        </trans-unit>
        <trans-unit id="ffd6c6681f86404c6d10fd90b4e30255a8c338ed" translate="yes" xml:space="preserve">
          <source>The best way to understand the mapping between Kotlin and C is to try a tiny example. We declare a function that accepts a function pointer as a parameter and another function that returns a function pointer.</source>
          <target state="translated">理解Kotlin和C语言之间的映射的最好方法是尝试一个小小的例子。我们声明一个接受函数指针作为参数的函数和另一个返回函数指针的函数。</target>
        </trans-unit>
        <trans-unit id="6537550691113ba29bcd420ea4633f14458a70b1" translate="yes" xml:space="preserve">
          <source>The best way to understand the mapping between Kotlin and C is to try a tiny example. We will declare a struct and a union in the C language, to see how they are mapped into Kotlin.</source>
          <target state="translated">理解Kotlin和C语言之间映射的最好方法是尝试一个小小的例子。我们将在C语言中声明一个结构和一个联合体,看看它们是如何映射到Kotlin中的。</target>
        </trans-unit>
        <trans-unit id="4232ac266b4561b99b9bc10fa2be9171a24a3226" translate="yes" xml:space="preserve">
          <source>The best way to understand these techniques is to try them out. Let's create a first tiny Kotlin library and use it from a C program.</source>
          <target state="translated">理解这些技术的最好方法就是尝试一下。让我们创建第一个小小的Kotlin库,并从C程序中使用它。</target>
        </trans-unit>
        <trans-unit id="eaa47ef7640a883ac2445b67958ca2668d316a2e" translate="yes" xml:space="preserve">
          <source>The best way to use the Kotlin/Native compiler is with a build system. It helps by downloading and caching the Kotlin/Native compiler binaries and libraries with transitive dependencies, and running the compiler and tests. It caches the compilation results too. A build system can also be used by an IDE to understand the project layout.</source>
          <target state="translated">使用Kotlin/Native编译器的最佳方式是使用构建系统。它通过下载和缓存 Kotlin/Native 编译器的二进制文件和具有过渡性依赖关系的库,并运行编译器和测试来提供帮助。它也会缓存编译结果。集成开发环境也可以使用构建系统来了解项目布局。</target>
        </trans-unit>
        <trans-unit id="9af9e08ad353ac6ed57e0041c23dca829fbff7c4" translate="yes" xml:space="preserve">
          <source>The binaries DSL allows not only creating binaries but also accessing already created ones to configure them or get their properties (e.g. path to an output file). The &lt;code&gt;binaries&lt;/code&gt; collection implements the &lt;a href=&quot;https://docs.gradle.org/current/javadoc/org/gradle/api/DomainObjectSet.html&quot;&gt;&lt;code&gt;DomainObjectSet&lt;/code&gt;&lt;/a&gt; interface and provides methods like &lt;code&gt;all&lt;/code&gt; or &lt;code&gt;matching&lt;/code&gt; allowing configuring groups of elements.</source>
          <target state="translated">二进制DSL不仅允许创建二进制文件，还可以访问已创建的二进制文件以配置它们或获取其属性（例如，输出文件的路径）。所述 &lt;code&gt;binaries&lt;/code&gt; 集合实现的&lt;a href=&quot;https://docs.gradle.org/current/javadoc/org/gradle/api/DomainObjectSet.html&quot;&gt; &lt;code&gt;DomainObjectSet&lt;/code&gt; &lt;/a&gt;接口，并提供类似的方法 &lt;code&gt;all&lt;/code&gt; 或 &lt;code&gt;matching&lt;/code&gt; 允许配置一组元素。</target>
        </trans-unit>
        <trans-unit id="bc8bcc38381183bfcc94707aa9b37df0e52f23b1" translate="yes" xml:space="preserve">
          <source>The binary files are created in the &lt;code&gt;build/bin/native/debugExecutable&lt;/code&gt; or &lt;code&gt;build/bin/native/releaseExecutable&lt;/code&gt; folders respectively. The file has a &lt;code&gt;.kexe&lt;/code&gt; extension on Linux and macOS and an &lt;code&gt;.exe&lt;/code&gt; extension on Windows. Use the following command to instruct the build to produce binaries:</source>
          <target state="translated">二进制文件分别在 &lt;code&gt;build/bin/native/debugExecutable&lt;/code&gt; 或 &lt;code&gt;build/bin/native/releaseExecutable&lt;/code&gt; 文件夹中创建。该文件在Linux和macOS上具有 &lt;code&gt;.kexe&lt;/code&gt; 扩展名，在Windows上具有 &lt;code&gt;.exe&lt;/code&gt; 扩展名。使用以下命令来指导生成二进制文件：</target>
        </trans-unit>
        <trans-unit id="54650137fcf92a797ec9822a89e0e51a3d74473c" translate="yes" xml:space="preserve">
          <source>The block after &lt;code&gt;tree(&quot;root&quot;)&lt;/code&gt; is the first function literal with receiver, which will be passed to &lt;code&gt;tree()&lt;/code&gt; as the &lt;code&gt;initialize&lt;/code&gt; parameter. According to the parameter list of &lt;code&gt;tree()&lt;/code&gt;, the receiver is of type &lt;code&gt;TreeNode&lt;/code&gt;, and therefore, &lt;code&gt;tree()&lt;/code&gt; can call &lt;code&gt;initialize()&lt;/code&gt; on &lt;code&gt;root&lt;/code&gt;. &lt;code&gt;root&lt;/code&gt; then becomes &lt;code&gt;this&lt;/code&gt; inside the scope of that lambda expression, so when we call &lt;code&gt;node(&quot;math&quot;)&lt;/code&gt;, it implicitly says &lt;code&gt;this.node(&quot;math&quot;)&lt;/code&gt;, where &lt;code&gt;this&lt;/code&gt; refers to the same &lt;code&gt;TreeNode&lt;/code&gt; as &lt;code&gt;root&lt;/code&gt;. The next block is passed to &lt;code&gt;TreeNode.node()&lt;/code&gt;, and is invoked on the first child of the &lt;code&gt;root&lt;/code&gt; node, namely &lt;code&gt;math&lt;/code&gt;, and inside it, &lt;code&gt;this&lt;/code&gt; will refer to &lt;code&gt;math&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;tree(&quot;root&quot;)&lt;/code&gt; 之后的块是具有接收器的第一个函数文字，它将作为 &lt;code&gt;initialize&lt;/code&gt; 参数传递给 &lt;code&gt;tree()&lt;/code&gt; 。根据 &lt;code&gt;tree()&lt;/code&gt; 的参数列表，接收方的类型为 &lt;code&gt;TreeNode&lt;/code&gt; ，因此 &lt;code&gt;tree()&lt;/code&gt; 可以在 &lt;code&gt;root&lt;/code&gt; 上调用 &lt;code&gt;initialize()&lt;/code&gt; 。 &lt;code&gt;root&lt;/code&gt; 然后变成 &lt;code&gt;this&lt;/code&gt; 该lambda表达式的范围内，因此，当我们称之为 &lt;code&gt;node(&quot;math&quot;)&lt;/code&gt; ，它隐含说 &lt;code&gt;this.node(&quot;math&quot;)&lt;/code&gt; ，其中， &lt;code&gt;this&lt;/code&gt; 指的是相同的 &lt;code&gt;TreeNode&lt;/code&gt; 为 &lt;code&gt;root&lt;/code&gt; 。下一个块传递给 &lt;code&gt;TreeNode.node()&lt;/code&gt; ，并在 &lt;code&gt;root&lt;/code&gt; 的第一个子节点 &lt;code&gt;math&lt;/code&gt; 上调用，在其内部， &lt;code&gt;this&lt;/code&gt; 将引用 &lt;code&gt;math&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="299004dba6c7ef441e08541633a7bed7d65922cd" translate="yes" xml:space="preserve">
          <source>The body can be a block.</source>
          <target state="translated">身体可以是块。</target>
        </trans-unit>
        <trans-unit id="d17dad4981064bd9e13820de989411c6afec8c62" translate="yes" xml:space="preserve">
          <source>The body of an object expression may access, and possibly modify, the local variables of the containing scope.</source>
          <target state="translated">对象表达式的主体可以访问并可能修改包含作用域的局部变量。</target>
        </trans-unit>
        <trans-unit id="6eb082a62156761cbe45120602d0be4ff5a5d1b2" translate="yes" xml:space="preserve">
          <source>The box classes used for capturing mutable closure variables in lambdas no longer have volatile fields. This change improves performance, but can lead to new race conditions in some rare usage scenarios. If you're affected by this, you need to provide your own synchronization for accessing the variables.</source>
          <target state="translated">用于捕获lambdas中的可突变闭合变量的盒子类不再具有易失性字段。这一变化提高了性能,但在一些罕见的使用场景中会导致新的竞赛条件。如果你受此影响,你需要提供自己的同步来访问变量。</target>
        </trans-unit>
        <trans-unit id="0bb1979f4fa500a54eb079957dc97f38da2dd0fd" translate="yes" xml:space="preserve">
          <source>The build generates the following files under the &lt;code&gt;build/bin/native/debugShared&lt;/code&gt; folder, depending on the host OS:</source>
          <target state="translated">根据主机操作系统，内部 &lt;code&gt;build/bin/native/debugShared&lt;/code&gt; 在build / bin / native / debugShared文件夹下生成以下文件：</target>
        </trans-unit>
        <trans-unit id="8d7f1cfca83f4be43b98d7bc6f3dc13e77358eda" translate="yes" xml:space="preserve">
          <source>The call to &lt;code&gt;C().foo(1)&lt;/code&gt; will print &quot;extension&quot;.</source>
          <target state="translated">对 &lt;code&gt;C().foo(1)&lt;/code&gt; 的调用将显示&amp;ldquo;扩展名&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="5986952e4227de9affa4abe69a35c446c0bfc14d" translate="yes" xml:space="preserve">
          <source>The call to &lt;code&gt;execute&lt;/code&gt; uses a function passed as its second parameter to produce an object subgraph (i.e. set of mutually referring objects) which is then passed as a whole to that worker, it is then no longer available to the thread that initiated the request. This property is checked if the first parameter is &lt;code&gt;TransferMode.SAFE&lt;/code&gt; by graph traversal and is just assumed to be true, if it is &lt;code&gt;TransferMode.UNSAFE&lt;/code&gt;. The last parameter to &lt;code&gt;execute&lt;/code&gt; is a special Kotlin lambda, which is not allowed to capture any state, and is actually invoked in the target worker's context. Once processed, the result is transferred to whatever consumes it in the future, and it is attached to the object graph of that worker/thread.</source>
          <target state="translated">&lt;code&gt;execute&lt;/code&gt; 调用使用作为其第二个参数传递的函数来生成对象子图（即相互引用的对象集），然后将该对象子图作为一个整体传递给该工作程序，然后该线程不再可用于发起请求的线程。如果通过图形遍历检查第一个参数是否为 &lt;code&gt;TransferMode.SAFE&lt;/code&gt; ，并且如果它为 &lt;code&gt;TransferMode.UNSAFE&lt;/code&gt; ，则假定该属性为true 。要 &lt;code&gt;execute&lt;/code&gt; 的最后一个参数是特殊的Kotlin lambda，它不允许捕获任何状态，并且实际上是在目标工作程序的上下文中调用的。处理后，结果将转移到将来消耗它的任何对象，并将其附加到该工作程序/线程的对象图。</target>
        </trans-unit>
        <trans-unit id="cf4d64ccc981a36348dc5e3486734b7a527c1cd6" translate="yes" xml:space="preserve">
          <source>The callback which is called after the change of the property is made. The value of the property has already been changed when this callback is invoked.</source>
          <target state="translated">属性改变后调用的回调。当这个回调被调用时,属性的值已经被改变。</target>
        </trans-unit>
        <trans-unit id="f46a88a879fdbb85f0bd5182483f8be3f20e50d2" translate="yes" xml:space="preserve">
          <source>The callback which is called before a change to the property value is attempted. The value of the property hasn't been changed yet, when this callback is invoked. If the callback returns &lt;code&gt;true&lt;/code&gt; the value of the property is being set to the new value, and if the callback returns &lt;code&gt;false&lt;/code&gt; the new value is discarded and the property remains its old value.</source>
          <target state="translated">尝试更改属性值之前调用的回调。调用此回调时，属性的值尚未更改。如果回调返回 &lt;code&gt;true&lt;/code&gt; ，则将属性的值设置为新值，如果回调返回 &lt;code&gt;false&lt;/code&gt; ，则丢弃新值，并且该属性保留其旧值。</target>
        </trans-unit>
        <trans-unit id="e3032cd7941afef1fb6a2120a573d1232d288d72" translate="yes" xml:space="preserve">
          <source>The calls that affect inference are either members of the receiver type of an annotated function parameter or extensions for that type. The extensions must be themselves annotated with &lt;code&gt;@BuilderInference&lt;/code&gt;.</source>
          <target state="translated">影响推理的调用是带注释的函数参数的接收器类型的成员或该类型的扩展。扩展本身必须使用 &lt;code&gt;@BuilderInference&lt;/code&gt; 进行注释。</target>
        </trans-unit>
        <trans-unit id="5833c1f716afd68e76f6ee63506f61a1ac4d8150" translate="yes" xml:space="preserve">
          <source>The changes in dependencies are &lt;a href=&quot;https://en.wikipedia.org/wiki/Application_binary_interface&quot;&gt;ABI&lt;/a&gt; compatible. For example, the only changes are in method bodies.</source>
          <target state="translated">依赖项的更改与&lt;a href=&quot;https://en.wikipedia.org/wiki/Application_binary_interface&quot;&gt;ABI&lt;/a&gt;兼容。例如，唯一的变化是方法主体。</target>
        </trans-unit>
        <trans-unit id="ca6d3d47c03bc25dbb852207c0d849513ed5fbaf" translate="yes" xml:space="preserve">
          <source>The channels shown so far had no buffer. Unbuffered channels transfer elements when sender and receiver meet each other (aka rendezvous). If send is invoked first, then it is suspended until receive is invoked, if receive is invoked first, it is suspended until send is invoked.</source>
          <target state="translated">目前显示的信道没有缓冲区。无缓冲的通道在发送方和接收方相遇(也就是会合)时传输元素。如果先调用send,则暂停直至调用receive,如果先调用receive,则暂停直至调用send。</target>
        </trans-unit>
        <trans-unit id="fa768c5c4432c77d50de790cda1c8c687dccf1cc" translate="yes" xml:space="preserve">
          <source>The character &quot; &amp;ndash; quotation mark</source>
          <target state="translated">字符&amp;ldquo; &amp;ndash;引号</target>
        </trans-unit>
        <trans-unit id="10c860623b3bfd4256ce034a4fa10ecca2e8d17c" translate="yes" xml:space="preserve">
          <source>The character $ &amp;ndash; dollar sign</source>
          <target state="translated">字符$ &amp;ndash;美元符号</target>
        </trans-unit>
        <trans-unit id="bb0b9f77aa3a2b1b235948227a9bb6e95724f73c" translate="yes" xml:space="preserve">
          <source>The character &amp;Dagger;</source>
          <target state="translated">人物 &amp;Dagger;</target>
        </trans-unit>
        <trans-unit id="97d065e0957f914068e24066c8bc53313cb9196a" translate="yes" xml:space="preserve">
          <source>The character &amp;Prime;</source>
          <target state="translated">人物 &amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="697b0963155a10d5f080f157c0e1d9c9aacc9b21" translate="yes" xml:space="preserve">
          <source>The character &amp;amp; &amp;ndash; ampersand</source>
          <target state="translated">字符＆&amp;ndash;和号</target>
        </trans-unit>
        <trans-unit id="094872d2798a25e27adaff380803676c236be373" translate="yes" xml:space="preserve">
          <source>The character &amp;asymp;</source>
          <target state="translated">字符&amp;asymp;</target>
        </trans-unit>
        <trans-unit id="41d60c0526caa8463741bd966759bf19026cb739" translate="yes" xml:space="preserve">
          <source>The character &amp;bdquo;</source>
          <target state="translated">人物 &amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="fff1f1e9d607e97e90b4bc028bb0cc7f10c48e01" translate="yes" xml:space="preserve">
          <source>The character &amp;bull;</source>
          <target state="translated">人物 &amp;bull;</target>
        </trans-unit>
        <trans-unit id="143c3fcec665ebddc83c2753db67d88e2fbaf38a" translate="yes" xml:space="preserve">
          <source>The character &amp;cent;</source>
          <target state="translated">字符&amp;cent;</target>
        </trans-unit>
        <trans-unit id="ee171eaf967121aa215c85e62d2ec509ebb04257" translate="yes" xml:space="preserve">
          <source>The character &amp;copy;</source>
          <target state="translated">字符&amp;copy;</target>
        </trans-unit>
        <trans-unit id="314c38bf0716b200771c1a885fab69a9b65b99c6" translate="yes" xml:space="preserve">
          <source>The character &amp;dagger;</source>
          <target state="translated">人物 &amp;dagger;</target>
        </trans-unit>
        <trans-unit id="6f9bd3084db43833f63880cca5d946309a97ca39" translate="yes" xml:space="preserve">
          <source>The character &amp;deg;</source>
          <target state="translated">字符&amp;deg;</target>
        </trans-unit>
        <trans-unit id="0e423b28ce34d3cf18fda3a07cf0dfa515d8890e" translate="yes" xml:space="preserve">
          <source>The character &amp;euro;</source>
          <target state="translated">角色&amp;euro;</target>
        </trans-unit>
        <trans-unit id="b1449855c21d4fd06c0d5e74b5a2a7a14edf968a" translate="yes" xml:space="preserve">
          <source>The character &amp;frac12;</source>
          <target state="translated">字符&amp;frac12;</target>
        </trans-unit>
        <trans-unit id="1fa4a09afc8d4c4f53c306db471f300c4497957c" translate="yes" xml:space="preserve">
          <source>The character &amp;ge;</source>
          <target state="translated">字符&amp;ge;</target>
        </trans-unit>
        <trans-unit id="3dfbeeaef1c98d8a22709ebef333428072939a42" translate="yes" xml:space="preserve">
          <source>The character &amp;gt; &amp;ndash; greater-than sign</source>
          <target state="translated">字符&amp;gt; &amp;ndash;大于号</target>
        </trans-unit>
        <trans-unit id="6eb5e1e14a002081da7d716b380be22cde00b939" translate="yes" xml:space="preserve">
          <source>The character &amp;hellip;</source>
          <target state="translated">人物 &amp;hellip;</target>
        </trans-unit>
        <trans-unit id="a01873a887462b6593c2f5f42a550b38052e578a" translate="yes" xml:space="preserve">
          <source>The character &amp;laquo;</source>
          <target state="translated">人物 &amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="e667dca130564a78a41110f6cbd1264a713d8dd2" translate="yes" xml:space="preserve">
          <source>The character &amp;ldquo;</source>
          <target state="translated">人物 &amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="950de0de2afce4fa96ad4f62ca4dab286d3d82a8" translate="yes" xml:space="preserve">
          <source>The character &amp;le;</source>
          <target state="translated">字符&amp;le;</target>
        </trans-unit>
        <trans-unit id="9023ce61724bbabe84554211f1682a5b7d26a59b" translate="yes" xml:space="preserve">
          <source>The character &amp;lsquo;</source>
          <target state="translated">人物 '</target>
        </trans-unit>
        <trans-unit id="e9f2776cd83195ab61d81c705eb53d1d3649fd0e" translate="yes" xml:space="preserve">
          <source>The character &amp;lt; &amp;ndash; less-than sign</source>
          <target state="translated">字符&amp;lt;&amp;ndash;小于号</target>
        </trans-unit>
        <trans-unit id="7e613a75a280526a06a5c3a8cccd7722979dfc79" translate="yes" xml:space="preserve">
          <source>The character &amp;mdash;</source>
          <target state="translated">人物 -</target>
        </trans-unit>
        <trans-unit id="257dd2718c3d554488c288a2e9f88456100a73ef" translate="yes" xml:space="preserve">
          <source>The character &amp;middot;</source>
          <target state="translated">人物 &amp;middot;</target>
        </trans-unit>
        <trans-unit id="b00154ce5f2758f6abb5e4356e419ba3e2aed105" translate="yes" xml:space="preserve">
          <source>The character &amp;ndash;</source>
          <target state="translated">人物 -</target>
        </trans-unit>
        <trans-unit id="aad571a2b53620d99840a4d55bce3f5907371d75" translate="yes" xml:space="preserve">
          <source>The character &amp;ne;</source>
          <target state="translated">字符&amp;ne;</target>
        </trans-unit>
        <trans-unit id="a360453c2e244288bd242eeb7641ad601e593f75" translate="yes" xml:space="preserve">
          <source>The character &amp;para;</source>
          <target state="translated">人物 &amp;para;</target>
        </trans-unit>
        <trans-unit id="1c97c4311adda721fa170a84ab8496cb5535afa3" translate="yes" xml:space="preserve">
          <source>The character &amp;plusmn;</source>
          <target state="translated">字符&amp;plusmn;</target>
        </trans-unit>
        <trans-unit id="55144636deb97ada56b2d29a7bb655a9f22ea932" translate="yes" xml:space="preserve">
          <source>The character &amp;pound;</source>
          <target state="translated">角色&amp;pound;</target>
        </trans-unit>
        <trans-unit id="09c581b6f45120a7ecac89f6de96696cea52b01c" translate="yes" xml:space="preserve">
          <source>The character &amp;prime;</source>
          <target state="translated">人物 '</target>
        </trans-unit>
        <trans-unit id="c49eacef46814486b9678b461b5fad7053d65453" translate="yes" xml:space="preserve">
          <source>The character &amp;raquo;</source>
          <target state="translated">人物 &amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="b94a5614ad8379d659840f63e74a095d51d6a7c0" translate="yes" xml:space="preserve">
          <source>The character &amp;rdquo;</source>
          <target state="translated">人物 &amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="be87e8e3080722678155d4e087ea1bf466788605" translate="yes" xml:space="preserve">
          <source>The character &amp;reg;</source>
          <target state="translated">人物&amp;reg;</target>
        </trans-unit>
        <trans-unit id="e6daa833ce04c765a61d1650a1e4e3d75924ca44" translate="yes" xml:space="preserve">
          <source>The character &amp;rsquo;</source>
          <target state="translated">人物 '</target>
        </trans-unit>
        <trans-unit id="43ad6d82b90d71d375e73e1b9402ca5934e45166" translate="yes" xml:space="preserve">
          <source>The character &amp;sbquo;</source>
          <target state="translated">人物 ，</target>
        </trans-unit>
        <trans-unit id="4139cb770ca9a15c26a42368989f1dc39e1910da" translate="yes" xml:space="preserve">
          <source>The character &amp;sect;</source>
          <target state="translated">人物 &amp;sect;</target>
        </trans-unit>
        <trans-unit id="98e7fc24f032b2c1437d0f55811d67ee1de7b88e" translate="yes" xml:space="preserve">
          <source>The character &amp;times;</source>
          <target state="translated">角色&amp;times;</target>
        </trans-unit>
        <trans-unit id="f6467d07a9719c1073ddb29614f3d2a5ac72dfb3" translate="yes" xml:space="preserve">
          <source>The character &amp;trade;</source>
          <target state="translated">人物&amp;trade;</target>
        </trans-unit>
        <trans-unit id="1789ee1227acc918fbc63737b2058bf75be81287" translate="yes" xml:space="preserve">
          <source>The class can also declare &lt;strong&gt;secondary constructors&lt;/strong&gt;, which are prefixed with &lt;em&gt;constructor&lt;/em&gt;:</source>
          <target state="translated">该类还可以声明&lt;strong&gt;辅助构造函数&lt;/strong&gt;，它们以&lt;em&gt;构造函数&lt;/em&gt;为前缀：</target>
        </trans-unit>
        <trans-unit id="bc78b13ff48b9fc50475495610ff41f558bf6256" translate="yes" xml:space="preserve">
          <source>The class declaration consists of the class name, the class header (specifying its type parameters, the primary constructor etc.) and the class body, surrounded by curly braces. Both the header and the body are optional; if the class has no body, curly braces can be omitted.</source>
          <target state="translated">类声明由类名、类头(指定类型参数、主要构造函数等)和类主体组成,用大括号包围。头和主体都是可选的;如果类没有主体,大括号可以省略。</target>
        </trans-unit>
        <trans-unit id="20fb66c6dd38ed7ad8f3ab7df8f07a3ccc7c3a1d" translate="yes" xml:space="preserve">
          <source>The class file with a kind not listed here is treated as a non-Kotlin file.</source>
          <target state="translated">这里没有列出的类文件将作为非Kotlin文件处理。</target>
        </trans-unit>
        <trans-unit id="8d923d6e9fe47217a8cbe28cd4bc0054618db9f2" translate="yes" xml:space="preserve">
          <source>The code above uses a &lt;a href=&quot;reflection#bound-class-references-since-11&quot;&gt;bound class reference&lt;/a&gt;, which is supported since Kotlin 1.1. You can also use the &lt;code&gt;javaClass&lt;/code&gt; extension property:</source>
          <target state="translated">上面的代码使用了&lt;a href=&quot;reflection#bound-class-references-since-11&quot;&gt;绑定类引用&lt;/a&gt;，从Kotlin 1.1开始就支持该引用。您还可以使用 &lt;code&gt;javaClass&lt;/code&gt; 扩展属性：</target>
        </trans-unit>
        <trans-unit id="732a1f0dd7bc7add2cc125d4681e9dd3eef05206" translate="yes" xml:space="preserve">
          <source>The code in object expressions can access variables from the enclosing scope.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a037143482eba48d7a06126430f1e3e039ee172" translate="yes" xml:space="preserve">
          <source>The code in question is from the &lt;a href=&quot;https://curl.haxx.se/libcurl/c/simple.html&quot;&gt;simple&lt;/a&gt; example (comments removed for brevity)</source>
          <target state="translated">有问题的代码来自&lt;a href=&quot;https://curl.haxx.se/libcurl/c/simple.html&quot;&gt;简单的&lt;/a&gt;示例（为简洁起见删除了注释）</target>
        </trans-unit>
        <trans-unit id="02b7f3091db5cc1f6df8785c890e5a0df1e43276" translate="yes" xml:space="preserve">
          <source>The code in the &lt;code&gt;hello.kt&lt;/code&gt; file may look like this:</source>
          <target state="translated">&lt;code&gt;hello.kt&lt;/code&gt; 文件中的代码可能如下所示：</target>
        </trans-unit>
        <trans-unit id="8051836ca1f9bfcf8f55044dce46370d2274f4e3" translate="yes" xml:space="preserve">
          <source>The code in the final &lt;code&gt;hello.kt&lt;/code&gt; file may look like this:</source>
          <target state="translated">最终的 &lt;code&gt;hello.kt&lt;/code&gt; 文件中的代码可能如下所示：</target>
        </trans-unit>
        <trans-unit id="53a9cf6b4f40ef47e2031c236bc499f1385bb27e" translate="yes" xml:space="preserve">
          <source>The code is full of Objective-C attributes, which are intended to help the use of the framework from both Objective-C and Swift languages. &lt;code&gt;DemoClazz&lt;/code&gt;, &lt;code&gt;DemoInterface&lt;/code&gt;, and &lt;code&gt;DemoObject&lt;/code&gt; are created for &lt;code&gt;Clazz&lt;/code&gt;, &lt;code&gt;Interface&lt;/code&gt;, and &lt;code&gt;Object&lt;/code&gt; respectively. The &lt;code&gt;Interface&lt;/code&gt; is turned into &lt;code&gt;@protocol&lt;/code&gt;, both a &lt;code&gt;class&lt;/code&gt; and an &lt;code&gt;object&lt;/code&gt; are represented as &lt;code&gt;@interface&lt;/code&gt;. The &lt;code&gt;Demo&lt;/code&gt; prefix comes from the &lt;code&gt;-output&lt;/code&gt; parameter of the &lt;code&gt;kotlinc-native&lt;/code&gt; compiler and the framework name. We see here that the nullable return type &lt;code&gt;ULong?&lt;/code&gt; is turned into &lt;code&gt;DemoLong*&lt;/code&gt; in Objective-C.</source>
          <target state="translated">该代码充满了Objective-C属性，旨在帮助使用Objective-C和Swift语言的框架。 &lt;code&gt;DemoClazz&lt;/code&gt; ， &lt;code&gt;DemoInterface&lt;/code&gt; 和 &lt;code&gt;DemoObject&lt;/code&gt; 的是为创建 &lt;code&gt;Clazz&lt;/code&gt; ， &lt;code&gt;Interface&lt;/code&gt; ，和 &lt;code&gt;Object&lt;/code&gt; 分别。的 &lt;code&gt;Interface&lt;/code&gt; 变成 &lt;code&gt;@protocol&lt;/code&gt; ，既是一个 &lt;code&gt;class&lt;/code&gt; 和 &lt;code&gt;object&lt;/code&gt; 被表示为 &lt;code&gt;@interface&lt;/code&gt; 。该 &lt;code&gt;Demo&lt;/code&gt; 前缀来自 &lt;code&gt;-output&lt;/code&gt; 的参数 &lt;code&gt;kotlinc-native&lt;/code&gt; 编译器和框架的名字。我们在这里看到可以为null的返回类型 &lt;code&gt;ULong?&lt;/code&gt; 在Objective-C中变成了 &lt;code&gt;DemoLong*&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bb3f232ccbe55c8a64749007e2a52df82753b753" translate="yes" xml:space="preserve">
          <source>The code is still written as if we were writing synchronous code, top-down, without the need of any special syntax, beyond the use of a function called &lt;code&gt;launch&lt;/code&gt; which essentially kicks-off the coroutine (covered in other tutorials).</source>
          <target state="translated">仍然使用自上而下的方式编写代码，而不需要任何特殊的语法，除了使用称为 &lt;code&gt;launch&lt;/code&gt; 的函数之外，该函数实质上启动了协程（在其他教程中已发现）。</target>
        </trans-unit>
        <trans-unit id="a467b8b9b7ee4d493e257af4cbf437bbbbde6f1c" translate="yes" xml:space="preserve">
          <source>The code or data pointed by the value of this variable.</source>
          <target state="translated">该变量的值所指向的代码或数据。</target>
        </trans-unit>
        <trans-unit id="02020b547b7971154705decbe3b4487f3a320a20" translate="yes" xml:space="preserve">
          <source>The code reads as follows. We have the &lt;code&gt;libnative_ExportedSymbols&lt;/code&gt; structure, which defines all the functions that Kotlin/Native and our library provides us. It uses nested anonymous structures heavily to mimic packages. The &lt;code&gt;libnative_&lt;/code&gt; prefix comes from the library name.</source>
          <target state="translated">代码如下。我们具有 &lt;code&gt;libnative_ExportedSymbols&lt;/code&gt; 结构，该结构定义Kotlin / Native和我们的库为我们提供的所有功能。它大量使用嵌套的匿名结构来模仿程序包。该 &lt;code&gt;libnative_&lt;/code&gt; 前缀来自库名。</target>
        </trans-unit>
        <trans-unit id="38d106af82f35f678ad2690b0baa41429ea7b73f" translate="yes" xml:space="preserve">
          <source>The code uses anonymous structure declarations. The code &lt;code&gt;struct { .. } foo&lt;/code&gt; declares a field in the outer struct of that anonymous structure type, the type with no name.</source>
          <target state="translated">该代码使用匿名结构声明。代码 &lt;code&gt;struct { .. } foo&lt;/code&gt; 在该匿名结构类型（没有名称的类型）的外部结构中声明了一个字段。</target>
        </trans-unit>
        <trans-unit id="5a75d5c9d164b0af6fa981261ed056bb33166b99" translate="yes" xml:space="preserve">
          <source>The collection interfaces and related functions are located in the kotlin.collections package. Let's get an overview of its contents.</source>
          <target state="translated">集合接口和相关函数位于kotlin.collection包中。我们先来了解一下它的内容。</target>
        </trans-unit>
        <trans-unit id="8eb00e1a99072f02da7c9734f0160d0f6d88090d" translate="yes" xml:space="preserve">
          <source>The command produces the &lt;code&gt;main.exe&lt;/code&gt; file, which we can run.</source>
          <target state="translated">该命令将生成 &lt;code&gt;main.exe&lt;/code&gt; 文件，我们可以运行该文件。</target>
        </trans-unit>
        <trans-unit id="c3c76c63d39731dfbcdc20b108a998ffa2cab356" translate="yes" xml:space="preserve">
          <source>The common base class of all enum classes. See the &lt;a href=&quot;../../../../../../docs/reference/enum-classes&quot;&gt;Kotlin language documentation&lt;/a&gt; for more information on enum classes.</source>
          <target state="translated">所有枚举类的公共基类。有关枚举类的更多信息，请参见&lt;a href=&quot;../../../../../../docs/reference/enum-classes&quot;&gt;Kotlin语言文档&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b0aedfb3fef921fc9d29c01593b4d03896cda204" translate="yes" xml:space="preserve">
          <source>The common base class of all enum classes. See the &lt;a href=&quot;../../../../../docs/reference/enum-classes&quot;&gt;Kotlin language documentation&lt;/a&gt; for more information on enum classes.</source>
          <target state="translated">所有枚举类的公共基类。有关枚举类的更多信息，请参见&lt;a href=&quot;../../../../../docs/reference/enum-classes&quot;&gt;Kotlin语言文档&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="81167d80c8bd1494ae8b5c6e43cfe5f3d98e0f63" translate="yes" xml:space="preserve">
          <source>The common code is &lt;code&gt;&quot;Kotlin Rocks on ${platformName()}&quot;&lt;/code&gt;, where &lt;code&gt;platformName()&lt;/code&gt; is a function that is declared using the &lt;code&gt;expect&lt;/code&gt; keyword. The &lt;code&gt;actual&lt;/code&gt; implementation will be specific to the platform.</source>
          <target state="translated">通用代码是 &lt;code&gt;&quot;Kotlin Rocks on ${platformName()}&quot;&lt;/code&gt; ，其中 &lt;code&gt;platformName()&lt;/code&gt; 是使用 &lt;code&gt;expect&lt;/code&gt; 关键字声明的函数。在 &lt;code&gt;actual&lt;/code&gt; 实施将是特定于平台。</target>
        </trans-unit>
        <trans-unit id="26e2504fa6bfc493ea02066bb2b03d45d4bc4811" translate="yes" xml:space="preserve">
          <source>The common source sets cannot include Java sources.</source>
          <target state="translated">通用源集不能包含Java源。</target>
        </trans-unit>
        <trans-unit id="95ec79a350a2b7276da32a4ea5b29db260f72d85" translate="yes" xml:space="preserve">
          <source>The common supertype for all callable references is &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.reflect/-k-callable/index&quot;&gt;&lt;code&gt;KCallable&amp;lt;out R&amp;gt;&lt;/code&gt;&lt;/a&gt;, where &lt;code&gt;R&lt;/code&gt; is the return value type, which is the property type for properties, and the constructed type for constructors.</source>
          <target state="translated">所有可调用引用的通用超类型是&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.reflect/-k-callable/index&quot;&gt; &lt;code&gt;KCallable&amp;lt;out R&amp;gt;&lt;/code&gt; &lt;/a&gt;，其中 &lt;code&gt;R&lt;/code&gt; 是返回值类型，它是属性的属性类型，而构造函数是构造类型。</target>
        </trans-unit>
        <trans-unit id="b490df5b9d3260a0f0b5037a5c6848fe5e1088c0" translate="yes" xml:space="preserve">
          <source>The companion object &lt;a href=&quot;-default/index&quot;&gt;Random.Default&lt;/a&gt; is the default instance of &lt;a href=&quot;index&quot;&gt;Random&lt;/a&gt;.</source>
          <target state="translated">伴随对象&lt;a href=&quot;-default/index&quot;&gt;Random.Default&lt;/a&gt;是&lt;a href=&quot;index&quot;&gt;Random&lt;/a&gt;的默认实例。</target>
        </trans-unit>
        <trans-unit id="d53a914136005ae6f435321f1dcd61b723a192c1" translate="yes" xml:space="preserve">
          <source>The companion object is a singleton, and its members can be accessed directly via the name of the containing class (although you can also insert the name of the companion object if you want to be explicit about accessing the companion object):</source>
          <target state="translated">同伴对象是一个单子,它的成员可以直接通过包含类的名称来访问(不过如果你想明确访问同伴对象,也可以插入同伴对象的名称)。</target>
        </trans-unit>
        <trans-unit id="1e2216eb9ae725f1d6c56e917607f0c9488b74a1" translate="yes" xml:space="preserve">
          <source>The compiler automatically derives the following members from all properties declared in the primary constructor:</source>
          <target state="translated">编译器会自动从主构造函数中声明的所有属性中导出以下成员。</target>
        </trans-unit>
        <trans-unit id="6577ea37c1117c7a1d89eaf0755007d75c98ca87" translate="yes" xml:space="preserve">
          <source>The compiler can infer the function types for variables if there is enough information:</source>
          <target state="translated">如果有足够的信息,编译器可以推断出变量的函数类型。</target>
        </trans-unit>
        <trans-unit id="6c9d4888e9777e469bf8f8415875e00d70265bbb" translate="yes" xml:space="preserve">
          <source>The compiler ensures that every expected declaration has actual declarations in all platform modules that implement the corresponding common module, and reports an error if any actual declarations are missing. The IDE provides tools that help you create the missing actual declarations.</source>
          <target state="translated">编译器确保每个预期的声明在所有实现相应通用模块的平台模块中都有实际的声明,如果缺少任何实际声明,编译器会报错。集成开发环境提供的工具可以帮助你创建缺失的实际声明。</target>
        </trans-unit>
        <trans-unit id="1bc9fa0ea96f6adbeae3b32244221538e36f7db6" translate="yes" xml:space="preserve">
          <source>The compiler generates an executable called &lt;code&gt;a.out&lt;/code&gt;. We need to run it to see in action the Kotlin code being executed from C library. On Linux, we'll need to include &lt;code&gt;.&lt;/code&gt; into the &lt;code&gt;LD_LIBRARY_PATH&lt;/code&gt; to let the application know to load the &lt;code&gt;libnative.so&lt;/code&gt; library from the current folder.</source>
          <target state="translated">编译器生成一个称为 &lt;code&gt;a.out&lt;/code&gt; 的可执行文件。我们需要运行它以查看从C库执行的Kotlin代码的作用。在Linux上，我们需要包含 &lt;code&gt;.&lt;/code&gt; 进入 &lt;code&gt;LD_LIBRARY_PATH&lt;/code&gt; ，让应用程序知道从当前文件夹中加载 &lt;code&gt;libnative.so&lt;/code&gt; 库。</target>
        </trans-unit>
        <trans-unit id="9c32f1ebf038bdf8cbaba8702b89e98ca18e811a" translate="yes" xml:space="preserve">
          <source>The compiler is smart enough to know a cast to be safe if a negative check leads to a return:</source>
          <target state="translated">编译器很聪明,它知道如果负检查导致返回,那么投掷是安全的。</target>
        </trans-unit>
        <trans-unit id="6c760f17f753a0cd7195aa08e67eb2dc50e9752a" translate="yes" xml:space="preserve">
          <source>The compiler now inlines values of &lt;code&gt;const val&lt;/code&gt; properties into the locations where they are used.</source>
          <target state="translated">现在，编译器将 &lt;code&gt;const val&lt;/code&gt; 属性的值内联到使用它们的位置。</target>
        </trans-unit>
        <trans-unit id="4ba2b709c858d08263f181dafb3aabf655fd192d" translate="yes" xml:space="preserve">
          <source>The compiler now provides an option to treat all warnings as errors. Use &lt;code&gt;-Werror&lt;/code&gt; on the command line, or the following Gradle snippet:</source>
          <target state="translated">编译器现在提供了将所有警告视为错误的选项。在命令行上或以下Gradle片段中使用 &lt;code&gt;-Werror&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="71411ab1eb04e1e2a8b1556ddf262cc1922d7424" translate="yes" xml:space="preserve">
          <source>The compiler performs the following steps for resolution of an operator in the &lt;em&gt;postfix&lt;/em&gt; form, e.g. &lt;code&gt;a++&lt;/code&gt;:</source>
          <target state="translated">编译器执行以下步骤来解析&lt;em&gt;后缀&lt;/em&gt;形式的运算符，例如 &lt;code&gt;a++&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="ade270e63280116ba329a9222cd68e987a0137a2" translate="yes" xml:space="preserve">
          <source>The compiler produces a warning for the cast in the last line. The cast cannot be fully checked at runtime and provides no guarantee that the values in the map are &lt;code&gt;Int&lt;/code&gt;.</source>
          <target state="translated">编译器在最后一行为转换产生警告。在运行时无法完全检查强制类型转换，也不保证映射中的值为 &lt;code&gt;Int&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c187f47b8c07f5d91c0556c45f360de519c42c3f" translate="yes" xml:space="preserve">
          <source>The compiler produces the code relevant for the target module system, for example, in case of CommonJS, it will import the declaration via the &lt;code&gt;require(...)&lt;/code&gt; function.</source>
          <target state="translated">编译器生成与目标模块系统相关的代码，例如，对于CommonJS，它将通过 &lt;code&gt;require(...)&lt;/code&gt; 函数导入声明。</target>
        </trans-unit>
        <trans-unit id="8552578d258f1326cbba27a9248961d718afcda8" translate="yes" xml:space="preserve">
          <source>The compiler tracks the information about the check you performed, and allows the call to &lt;code&gt;length&lt;/code&gt; inside the &lt;em&gt;if&lt;/em&gt;. More complex conditions are supported as well:</source>
          <target state="translated">编译器跟踪有关您执行的检查的信息，并允许在&lt;em&gt;if&lt;/em&gt;内调用 &lt;code&gt;length&lt;/code&gt; 。还支持更复杂的条件：&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9778744271ecf22c5df54071242110d274ebb382" translate="yes" xml:space="preserve">
          <source>The compiler will allow this function to be called as e.g. &lt;code&gt;test(&quot;a&quot;, &quot;b&quot;)&lt;/code&gt; or &lt;code&gt;test(&quot;a&quot;, null)&lt;/code&gt;, but not as &lt;code&gt;test(null, &quot;b&quot;)&lt;/code&gt; or &lt;code&gt;test(null, null)&lt;/code&gt;. Calling &lt;code&gt;test(a, b)&lt;/code&gt; is only allowed if the compiler can prove that &lt;code&gt;a&lt;/code&gt; cannot possibly be null. Inside of &lt;code&gt;test&lt;/code&gt;, the compiler will not allow you to do anything with &lt;code&gt;b&lt;/code&gt; that would result in an exception if &lt;code&gt;b&lt;/code&gt; should happen to be null - so you can do &lt;code&gt;a.length&lt;/code&gt;, but not &lt;code&gt;b.length&lt;/code&gt;. However, once you're inside a conditional where you have checked that &lt;code&gt;b&lt;/code&gt; is not null, you can do it:</source>
          <target state="translated">编译器将允许将此函数调用为例如 &lt;code&gt;test(&quot;a&quot;, &quot;b&quot;)&lt;/code&gt; 或 &lt;code&gt;test(&quot;a&quot;, null)&lt;/code&gt; ，而不是称为 &lt;code&gt;test(null, &quot;b&quot;)&lt;/code&gt; 或 &lt;code&gt;test(null, null)&lt;/code&gt; 。仅当编译器可以证明 &lt;code&gt;a&lt;/code&gt; 不可能为null时，才允许调用 &lt;code&gt;test(a, b)&lt;/code&gt; 。在 &lt;code&gt;test&lt;/code&gt; ，如果 &lt;code&gt;b&lt;/code&gt; 恰好为null ，则编译器将不允许您对 &lt;code&gt;b&lt;/code&gt; 进行任何操作，否则会导致异常-因此您可以执行 &lt;code&gt;a.length&lt;/code&gt; ，但不能执行 &lt;code&gt;b.length&lt;/code&gt; 。但是，一旦您处于检查 &lt;code&gt;b&lt;/code&gt; 不为null的条件内，就可以执行以下操作：</target>
        </trans-unit>
        <trans-unit id="d2b29d9a02116dffd597657f45323e8d260b605c" translate="yes" xml:space="preserve">
          <source>The compiler will generate something like this (except that &lt;code&gt;start&lt;/code&gt; won't collide with any other identifiers with the same name):</source>
          <target state="translated">编译器将生成类似以下内容的代码（除了 &lt;code&gt;start&lt;/code&gt; 不会与任何其他同名标识符冲突）：</target>
        </trans-unit>
        <trans-unit id="93c0badc9698bd83e21fa61741e490ba8801596d" translate="yes" xml:space="preserve">
          <source>The compiler will not let you perform checks that can't possibly succeed because the declared type of the variable is a class that is on an unrelated branch of the class hierarchy from the class you're checking against - if the declared type of &lt;code&gt;x&lt;/code&gt; is &lt;code&gt;MotorVehicle&lt;/code&gt;, you can't check if &lt;code&gt;x&lt;/code&gt; is a &lt;code&gt;Person&lt;/code&gt;. If the right-hand side of &lt;code&gt;is&lt;/code&gt; is an interface, Kotlin will allow the type of the left-hand side to be any interface or open class, because it could be that some subclass thereof implements the interface.</source>
          <target state="translated">编译器不会让您执行无法成功执行的检查，因为变量的声明类型是要检查的类的类层次结构的不相关分支上的类-如果 &lt;code&gt;x&lt;/code&gt; 的声明类型为 &lt;code&gt;MotorVehicle&lt;/code&gt; ，您不能检查 &lt;code&gt;x&lt;/code&gt; 是否是 &lt;code&gt;Person&lt;/code&gt; 。如果的右边 &lt;code&gt;is&lt;/code&gt; 是一个接口，科特林将使左侧的类型是任何接口或公开课，因为它可能是一些子类及其实现的接口。</target>
        </trans-unit>
        <trans-unit id="945c10a176528faf419fb001b8765fc6d7f48809" translate="yes" xml:space="preserve">
          <source>The complete list of options for the Gradle tasks is the following:</source>
          <target state="translated">Gradle任务的完整选项列表如下。</target>
        </trans-unit>
        <trans-unit id="cbc4e4912fffd8b8c15a7f1685ee311f7de94af5" translate="yes" xml:space="preserve">
          <source>The consumer may only need to add the attribute to a single target where the ambiguity arises.</source>
          <target state="translated">消费者可能只需要将属性添加到一个出现歧义的目标上。</target>
        </trans-unit>
        <trans-unit id="2fa143f534ac2f4a54ee1e8593acf92219a64686" translate="yes" xml:space="preserve">
          <source>The contents of our &lt;code&gt;main.js&lt;/code&gt; would be:</source>
          <target state="translated">我们的 &lt;code&gt;main.js&lt;/code&gt; 的内容为：</target>
        </trans-unit>
        <trans-unit id="ccc1b0f9d51d769d3aac8a2e95f9b22ce641f370" translate="yes" xml:space="preserve">
          <source>The context of the coroutine that corresponds to this continuation.</source>
          <target state="translated">与该延续对应的coroutine的上下文。</target>
        </trans-unit>
        <trans-unit id="347bd2f03e4af765cba7e04d72d0cecc9c6bb8cc" translate="yes" xml:space="preserve">
          <source>The contract description must be at the beginning of a function and have at least one effect.</source>
          <target state="translated">合同说明必须在一个功能的开头,并且至少有一个效果。</target>
        </trans-unit>
        <trans-unit id="4954ad3fce80d9310d9ce43541aaf17e0123a4ea" translate="yes" xml:space="preserve">
          <source>The contravariant type parameter of a parameter of a function-typed return type (the user will call the returned function with something that can consume any &lt;code&gt;Fruit&lt;/code&gt;, so it's okay to return a function that expects to receive something that can handle &lt;code&gt;Apple&lt;/code&gt;)</source>
          <target state="translated">函数类型返回类型的参数的变量类型参数（用户将使用可能消耗任何 &lt;code&gt;Fruit&lt;/code&gt; 的东西来调用返回的函数，因此可以返回希望接收到可以处理 &lt;code&gt;Apple&lt;/code&gt; 的函数的函数是可以的）</target>
        </trans-unit>
        <trans-unit id="fc9281a07f7c7bacfae7f8c712a66286fa4aa11c" translate="yes" xml:space="preserve">
          <source>The contravariant type parameter of a parameter type (the user is passing a consumer that can handle any &lt;code&gt;Fruit&lt;/code&gt;, and it will be given an &lt;code&gt;Apple&lt;/code&gt;)</source>
          <target state="translated">参数类型的反类型参数（用户正在传递可以处理任何 &lt;code&gt;Fruit&lt;/code&gt; 的使用者，并且它将获得 &lt;code&gt;Apple&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="3b2df0437d1139299375d04a6b3d749596fe34b3" translate="yes" xml:space="preserve">
          <source>The contravariant type parameter of the return type of a function-typed parameter (the user is passing a function that will return a consumer of any &lt;code&gt;Fruit&lt;/code&gt;, and the returned consumer will be given &lt;code&gt;Apple&lt;/code&gt; instances)</source>
          <target state="translated">函数类型参数的返回类型的反类型参数（用户传递的函数将返回任何 &lt;code&gt;Fruit&lt;/code&gt; 的使用者，并且将为返回的使用者提供 &lt;code&gt;Apple&lt;/code&gt; 实例）</target>
        </trans-unit>
        <trans-unit id="3ed87fa7f81c4d406e21bd5206fb7068af42bc61" translate="yes" xml:space="preserve">
          <source>The convention that is followed is that each library gets its own definition file, usually named the same as the library. For more information on all the options available to &lt;code&gt;cinterop&lt;/code&gt;, see &lt;a href=&quot;../../reference/native/c_interop&quot;&gt;the Interop documentation&lt;/a&gt;</source>
          <target state="translated">遵循的约定是，每个库都有其自己的定义文件，通常与该库命名相同。有关 &lt;code&gt;cinterop&lt;/code&gt; 所有可用选项的更多信息，请参见&lt;a href=&quot;../../reference/native/c_interop&quot;&gt;Interop文档。&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c72d89d38289079cb805c34b2308d4dfa8c2fd72" translate="yes" xml:space="preserve">
          <source>The coroutine context includes a &lt;em&gt;coroutine dispatcher&lt;/em&gt; (see &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-dispatcher/index.html&quot;&gt;CoroutineDispatcher&lt;/a&gt;) that determines what thread or threads the corresponding coroutine uses for its execution. The coroutine dispatcher can confine coroutine execution to a specific thread, dispatch it to a thread pool, or let it run unconfined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4ce8b1f45a5d6806ad09e59cc85adf7dc80106f" translate="yes" xml:space="preserve">
          <source>The coroutine context is a set of various elements. The main elements are the &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/index.html&quot;&gt;Job&lt;/a&gt; of the coroutine, which we've seen before, and its dispatcher, which is covered in this section.</source>
          <target state="translated">协程上下文是一组各种元素。主要元素是协同程序的&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/index.html&quot;&gt;工作&lt;/a&gt;（我们之前已经看到过）及其派遣程序，本节将对此进行介绍。</target>
        </trans-unit>
        <trans-unit id="09d67675b7aec2c1bf9665203e1b50714b4ffefe" translate="yes" xml:space="preserve">
          <source>The coroutine is started directly in the invoker's thread without going through the &lt;a href=&quot;../kotlin.coroutines/-continuation-interceptor/index&quot;&gt;ContinuationInterceptor&lt;/a&gt; that might be present in the completion's &lt;a href=&quot;../kotlin.coroutines/-coroutine-context/index&quot;&gt;CoroutineContext&lt;/a&gt;. It is the invoker's responsibility to ensure that a proper invocation context is established.</source>
          <target state="translated">协程直接在调用者的线程中启动，而无需经过&lt;a href=&quot;../kotlin.coroutines/-continuation-interceptor/index&quot;&gt;ContinuationInterceptor&lt;/a&gt;，而ContinuationInterceptor可能存在于完成的&lt;a href=&quot;../kotlin.coroutines/-coroutine-context/index&quot;&gt;CoroutineContext中&lt;/a&gt;。调用者有责任确保建立正确的调用上下文。</target>
        </trans-unit>
        <trans-unit id="5075509aaa121a034050446e85498c3f79064890" translate="yes" xml:space="preserve">
          <source>The coroutine's &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/index.html&quot;&gt;Job&lt;/a&gt; is part of its context, and can be retrieved from it using the &lt;code&gt;coroutineContext[Job]&lt;/code&gt; expression:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3db3fa62931fade33326b38aff7867fe578bfdd9" translate="yes" xml:space="preserve">
          <source>The coroutine's &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/index.html&quot;&gt;Job&lt;/a&gt; is part of its context. The coroutine can retrieve it from its own context using &lt;code&gt;coroutineContext[Job]&lt;/code&gt; expression:</source>
          <target state="translated">协程的&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/index.html&quot;&gt;工作&lt;/a&gt;是其背景的一部分。协程可以使用 &lt;code&gt;coroutineContext[Job]&lt;/code&gt; 表达式从自己的上下文中检索它：</target>
        </trans-unit>
        <trans-unit id="5769f42ad3e1d523865b402b5e67bd28e7b20bad" translate="yes" xml:space="preserve">
          <source>The corresponding &lt;code&gt;sourceSets&lt;/code&gt; property should be updated if not using the default convention:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1d461218111d234968b7db694b9b764401c60b6" translate="yes" xml:space="preserve">
          <source>The corresponding &lt;em&gt;sourceSets&lt;/em&gt; property should be updated if not using the default convention:</source>
          <target state="translated">如果不使用默认约定，则应更新相应的&lt;em&gt;sourceSets&lt;/em&gt;属性：</target>
        </trans-unit>
        <trans-unit id="16c7a1a50f1d32fc204564f81e6d0304f7356ed7" translate="yes" xml:space="preserve">
          <source>The covariant type parameter of a read-only property type (the user is expecting a producer of &lt;code&gt;Fruit&lt;/code&gt;, and gets a producer of &lt;code&gt;Apple&lt;/code&gt;)</source>
          <target state="translated">只读属性类型的协变量类型参数（用户期望得到 &lt;code&gt;Fruit&lt;/code&gt; 的生产者，而得到 &lt;code&gt;Apple&lt;/code&gt; 的生产者）</target>
        </trans-unit>
        <trans-unit id="7d1a94c8808bc3894d49e0ec4259312cbb359362" translate="yes" xml:space="preserve">
          <source>The covariant type parameter of a return type (the user is expecting that the returned value will produce a &lt;code&gt;Fruit&lt;/code&gt;, so it's okay if it really produces an &lt;code&gt;Apple&lt;/code&gt;)</source>
          <target state="translated">返回类型的协变量类型参数（用户期望返回的值将产生 &lt;code&gt;Fruit&lt;/code&gt; ，因此，如果它确实产生 &lt;code&gt;Apple&lt;/code&gt; 没关系）</target>
        </trans-unit>
        <trans-unit id="ec6f1c24b0cd8b11d61e4f25576ab198b6bece55" translate="yes" xml:space="preserve">
          <source>The covariant type parameter of the parameter type of a function-typed parameter (the user is passing a function that can handle any &lt;code&gt;Fruit&lt;/code&gt; producer, and it will be given an &lt;code&gt;Apple&lt;/code&gt; producer)</source>
          <target state="translated">函数类型参数的参数类型的协变类型参数（用户正在传递可以处理任何 &lt;code&gt;Fruit&lt;/code&gt; 生产者的函数，并且它将获得 &lt;code&gt;Apple&lt;/code&gt; 生产者）</target>
        </trans-unit>
        <trans-unit id="bc2c5c3395341afe0bbd48554537d9a1ac25a9db" translate="yes" xml:space="preserve">
          <source>The covariant type parameter of the return type of a function-typed return type (the user expects the returned function to return something that produces &lt;code&gt;Fruit&lt;/code&gt;, so it's okay if it really produces &lt;code&gt;Apple&lt;/code&gt;)</source>
          <target state="translated">函数类型的返回类型的返回类型的协变量类型参数（用户希望返回的函数返回产生 &lt;code&gt;Fruit&lt;/code&gt; 的东西，因此，如果它确实产生 &lt;code&gt;Apple&lt;/code&gt; 是可以的）</target>
        </trans-unit>
        <trans-unit id="a39f5e4ad2c9626d5a5f458b4068b5771d3c11f9" translate="yes" xml:space="preserve">
          <source>The created &lt;code&gt;StableRef&lt;/code&gt; should eventually be manually disposed using the &lt;code&gt;.dispose()&lt;/code&gt; method to prevent memory leaks:</source>
          <target state="translated">最终应使用 &lt;code&gt;.dispose()&lt;/code&gt; 方法手动处理创建的 &lt;code&gt;StableRef&lt;/code&gt; ,以防止内存泄漏：</target>
        </trans-unit>
        <trans-unit id="7dc376ddde1c64329f76a2fdf0f77fd2f42853b6" translate="yes" xml:space="preserve">
          <source>The created iOS application is ready to run on the iOS emulator or on the iOS device. The device run may require an Apple developer account and to issue a developer certificate. Xcode does its best to guide us through the process.</source>
          <target state="translated">创建的iOS应用已经准备好在iOS模拟器或iOS设备上运行。设备运行可能需要一个Apple开发者账号,并且要颁发开发者证书。Xcode会尽力引导我们完成这个过程。</target>
        </trans-unit>
        <trans-unit id="e20d095cd0f1efef77b1627ffafe7b1dfa3d28bf" translate="yes" xml:space="preserve">
          <source>The curly braces around a body can be omitted if the body is a oneliner. This is discouraged unless the body goes on the same line as the condition, because it makes it easy to make this mistake, especially when one is used to Python:</source>
          <target state="translated">如果 body 是 oneliner,可以省略 body 周围的大括号。除非主体与条件在同一条线上,否则不鼓励这样做,因为这很容易犯这个错误,特别是当人们习惯于使用 Python 时。</target>
        </trans-unit>
        <trans-unit id="dcfce21884a60ba71ce3d59d9e2af53e74e2e10c" translate="yes" xml:space="preserve">
          <source>The currently released version is 1.3.41, published on July 4, 2019.</source>
          <target state="translated">目前发布的版本为1.3.41,发布时间为2019年7月4日。</target>
        </trans-unit>
        <trans-unit id="b5744a90420458acc57f96347ae2c3cc6f2d50b3" translate="yes" xml:space="preserve">
          <source>The currently released version is 1.4.10, published on September 10, 2020.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99a5ae4aba1310a5ec2c1c1ea8e6bbd89807b2b1" translate="yes" xml:space="preserve">
          <source>The declaration of the classifier used in this type. For example, in the type &lt;code&gt;List&amp;lt;String&amp;gt;&lt;/code&gt; the classifier would be the &lt;a href=&quot;../-k-class/index#kotlin.reflect.KClass&quot;&gt;KClass&lt;/a&gt; instance for &lt;a href=&quot;../../kotlin.collections/-list/index#kotlin.collections.List&quot;&gt;List&lt;/a&gt;.</source>
          <target state="translated">此类型中使用的分类器的声明。例如，在类型 &lt;code&gt;List&amp;lt;String&amp;gt;&lt;/code&gt; ，分类器将是&lt;a href=&quot;../../kotlin.collections/-list/index#kotlin.collections.List&quot;&gt;List&lt;/a&gt;的&lt;a href=&quot;../-k-class/index#kotlin.reflect.KClass&quot;&gt;KClass&lt;/a&gt;实例。</target>
        </trans-unit>
        <trans-unit id="e4cb77989b70ae7af02cc584cc3eb602ad306980" translate="yes" xml:space="preserve">
          <source>The declarations in the new artifacts are visible under the same package names from the Kotlin point of view, but have different package names for Java. Therefore, switching to the new artifacts will not require any changes to your source code.</source>
          <target state="translated">从Kotlin的角度来看,新工件中的声明在相同的包名下是可见的,但对于Java来说,包名不同。因此,切换到新的工件将不需要对您的源代码进行任何更改。</target>
        </trans-unit>
        <trans-unit id="38a82a6bd4d8bda70773fac15ae91a2110030d1c" translate="yes" xml:space="preserve">
          <source>The default &lt;a href=&quot;https://www.joelonsoftware.com/2003/10/08/the-absolute-minimum-every-software-developer-absolutely-positively-must-know-about-unicode-and-character-sets-no-excuses/&quot;&gt;encoding&lt;/a&gt; is UTF-8, but you can specify it if you need something else:</source>
          <target state="translated">默认&lt;a href=&quot;https://www.joelonsoftware.com/2003/10/08/the-absolute-minimum-every-software-developer-absolutely-positively-must-know-about-unicode-and-character-sets-no-excuses/&quot;&gt;编码&lt;/a&gt;为UTF-8，但如果需要其他内容，则可以指定它：</target>
        </trans-unit>
        <trans-unit id="7643db7f540eca7261e951018ad1bc000680e9fc" translate="yes" xml:space="preserve">
          <source>The default artifact IDs follow the pattern &lt;code&gt;&amp;lt;projectName&amp;gt;-&amp;lt;targetNameToLowerCase&amp;gt;&lt;/code&gt;, for example &lt;code&gt;sample-lib-nodejs&lt;/code&gt; for a target named &lt;code&gt;nodeJs&lt;/code&gt; in a project &lt;code&gt;sample-lib&lt;/code&gt;.</source>
          <target state="translated">默认工件ID遵循 &lt;code&gt;&amp;lt;projectName&amp;gt;-&amp;lt;targetNameToLowerCase&amp;gt;&lt;/code&gt; 模式，例如，对于project &lt;code&gt;sample-lib&lt;/code&gt; 中名为 &lt;code&gt;nodeJs&lt;/code&gt; 的目标，使用 &lt;code&gt;sample-lib-nodejs&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="960beb3d459f57914f0b08a89c8e7a0ae2d213a2" translate="yes" xml:space="preserve">
          <source>The default dispatcher that is used when coroutines are launched in &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-global-scope/index.html&quot;&gt;GlobalScope&lt;/a&gt; is represented by &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-dispatchers/-default.html&quot;&gt;Dispatchers.Default&lt;/a&gt; and uses a shared background pool of threads, so &lt;code&gt;launch(Dispatchers.Default) { ... }&lt;/code&gt; uses the same dispatcher as &lt;code&gt;GlobalScope.launch { ... }&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b76c41789282ed3ab00f219e4dbda9192589571a" translate="yes" xml:space="preserve">
          <source>The default dispatcher, that is used when coroutines are launched in &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-global-scope/index.html&quot;&gt;GlobalScope&lt;/a&gt;, is represented by &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-dispatchers/-default.html&quot;&gt;Dispatchers.Default&lt;/a&gt; and uses shared background pool of threads, so &lt;code&gt;launch(Dispatchers.Default) { ... }&lt;/code&gt; uses the same dispatcher as &lt;code&gt;GlobalScope.launch { ... }&lt;/code&gt;.</source>
          <target state="translated">默认调度程序是在&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-dispatchers/-default.html&quot;&gt;Dispatchers.Default中&lt;/a&gt;表示的，它是在&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-global-scope/index.html&quot;&gt;GlobalScope&lt;/a&gt;中启动协程时使用的，并使用共享的后台线程池，因此 &lt;code&gt;launch(Dispatchers.Default) { ... }&lt;/code&gt; 与 &lt;code&gt;GlobalScope.launch { ... }&lt;/code&gt; 使用相同的调度程序。 ..}。</target>
        </trans-unit>
        <trans-unit id="034812e12bafb58c2506d45936895dac0de7b559" translate="yes" xml:space="preserve">
          <source>The default implementation is available for Java classes implementing the interface.</source>
          <target state="translated">实现该接口的Java类可以使用默认实现。</target>
        </trans-unit>
        <trans-unit id="eae7fdc4a8ba33e2f9213a2722bb2903c080bbc0" translate="yes" xml:space="preserve">
          <source>The default implementation of &lt;code&gt;Map&lt;/code&gt; &amp;ndash; &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-linked-hash-map/index&quot;&gt;&lt;code&gt;LinkedHashMap&lt;/code&gt;&lt;/a&gt; &amp;ndash; preserves the order of elements insertion when iterating the map. In turn, an alternative implementation &amp;ndash; &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-hash-map/index&quot;&gt;&lt;code&gt;HashMap&lt;/code&gt;&lt;/a&gt; &amp;ndash; says nothing about the elements order.</source>
          <target state="translated">默认的实现 &lt;code&gt;Map&lt;/code&gt; - &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-linked-hash-map/index&quot;&gt; &lt;code&gt;LinkedHashMap&lt;/code&gt; 的&lt;/a&gt; -保留元素插入时迭代地图的顺序。反过来，另一个实现&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-hash-map/index&quot;&gt; &lt;code&gt;HashMap&lt;/code&gt; &lt;/a&gt;则没有说明元素顺序。</target>
        </trans-unit>
        <trans-unit id="1d4f4ecafdd233f07d5e3f6afd06222be0312077" translate="yes" xml:space="preserve">
          <source>The default implementation of &lt;code&gt;Set&lt;/code&gt; &amp;ndash; &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-linked-hash-set/index&quot;&gt;&lt;code&gt;LinkedHashSet&lt;/code&gt;&lt;/a&gt; &amp;ndash; preserves the order of elements insertion. Hence, the functions that rely on the order, such as &lt;code&gt;first()&lt;/code&gt; or &lt;code&gt;last()&lt;/code&gt;, return predictable results on such sets.</source>
          <target state="translated">&lt;code&gt;Set&lt;/code&gt; 的默认实现&amp;ndash; &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-linked-hash-set/index&quot;&gt; &lt;code&gt;LinkedHashSet&lt;/code&gt; &lt;/a&gt; &amp;ndash;保留元素插入的顺序。因此，依赖顺序的函数 &lt;code&gt;first()&lt;/code&gt; 例如first（）或 &lt;code&gt;last()&lt;/code&gt; )在此类集合上返回可预测的结果。</target>
        </trans-unit>
        <trans-unit id="bed0e18ec00404266f1579a08902984894034905" translate="yes" xml:space="preserve">
          <source>The default nullability is used when a type itself is not annotated by a nullability annotation, and the default is determined by the innermost enclosing element annotated with a type qualifier default annotation with the &lt;code&gt;ElementType&lt;/code&gt; matching the type usage.</source>
          <target state="translated">当类型本身未由可空性注释注释时，将使用默认可空性，并且默认值是由最里面的封闭元素确定的，该元素由类型限定符默认注释进行注释，且 &lt;code&gt;ElementType&lt;/code&gt; 与类型用法匹配。</target>
        </trans-unit>
        <trans-unit id="9d69906046e2ddf59f421f52ac090513e9b9f2a3" translate="yes" xml:space="preserve">
          <source>The default random number generator.</source>
          <target state="translated">默认的随机数发生器。</target>
        </trans-unit>
        <trans-unit id="f9ef35e4ea1c850fbe5f46bb280445cc0cd754fc" translate="yes" xml:space="preserve">
          <source>The default source set &lt;code&gt;commonMain&lt;/code&gt; is added to each production (application or library) variant's compilation. The &lt;code&gt;commonTest&lt;/code&gt; source set is, similarly, added to the compilations of unit test and instrumented test variants.</source>
          <target state="translated">默认的源集 &lt;code&gt;commonMain&lt;/code&gt; 被添加到每个生产（应用程序或库）变体的编译中。同样，将 &lt;code&gt;commonTest&lt;/code&gt; 源集添加到单元测试和检测测试变量的编译中。</target>
        </trans-unit>
        <trans-unit id="c561b55e89597682ebf08bcc014c20773fedb83e" translate="yes" xml:space="preserve">
          <source>The default upper bound (if none specified) is &lt;code&gt;Any?&lt;/code&gt;. Only one upper bound can be specified inside the angle brackets. If the same type parameter needs more than one upper bound, we need a separate &lt;strong&gt;where&lt;/strong&gt;-clause:</source>
          <target state="translated">默认上限（如果未指定）是 &lt;code&gt;Any?&lt;/code&gt; 。尖括号内只能指定一个上限。如果相同类型的参数需要一个以上的上限，则需要在&lt;strong&gt;其中使用&lt;/strong&gt; -clause：</target>
        </trans-unit>
        <trans-unit id="7b5f3fac0dd293e61c74032e957e6e608fec3b05" translate="yes" xml:space="preserve">
          <source>The default value is provided at the declaration of this parameter.</source>
          <target state="translated">默认值在该参数声明时提供。</target>
        </trans-unit>
        <trans-unit id="44653ab72c57ae2dec40031a1386b4afc98b3166" translate="yes" xml:space="preserve">
          <source>The definitions part shows how Kotlin primitive types map into C primitive types. We discussed reverse mapping in the &lt;a href=&quot;mapping-primitive-data-types-from-c&quot;&gt;Mapping Primitive Data Types from C&lt;/a&gt; tutorial.</source>
          <target state="translated">定义部分显示Kotlin基本类型如何映射为C基本类型。我们在&lt;a href=&quot;mapping-primitive-data-types-from-c&quot;&gt;C语言&lt;/a&gt;教程的&amp;ldquo; 映射原始数据类型&amp;rdquo;中讨论了反向映射。</target>
        </trans-unit>
        <trans-unit id="7879370b21d5da1f44f128551f264e026a0fb9ed" translate="yes" xml:space="preserve">
          <source>The delegate class may implement one of the interfaces &lt;code&gt;ReadOnlyProperty&lt;/code&gt; and &lt;code&gt;ReadWriteProperty&lt;/code&gt; containing the required &lt;code&gt;operator&lt;/code&gt; methods. These interfaces are declared in the Kotlin standard library:</source>
          <target state="translated">委托类可以实现包含所需 &lt;code&gt;operator&lt;/code&gt; 方法的接口 &lt;code&gt;ReadOnlyProperty&lt;/code&gt; 和 &lt;code&gt;ReadWriteProperty&lt;/code&gt; 之一。这些接口在Kotlin标准库中声明：</target>
        </trans-unit>
        <trans-unit id="42bebb3adac2ab3e00fbad0af368d0931c57bd77" translate="yes" xml:space="preserve">
          <source>The delegated property can be used like this to declare a property in &lt;code&gt;Person&lt;/code&gt; - note the use of &lt;code&gt;by&lt;/code&gt; instead of &lt;code&gt;=&lt;/code&gt;:</source>
          <target state="translated">可以像这样使用委派的属性在 &lt;code&gt;Person&lt;/code&gt; 中声明一个属性-注意使用 &lt;code&gt;by&lt;/code&gt; 代替 &lt;code&gt;=&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="898cc738a761dcd3be73120e07ea5697ac2725df" translate="yes" xml:space="preserve">
          <source>The dependencies configuration has been changed; dependencies are now specified separately for each source root.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="973f16e5337bff9eb9481252b3daeac2f25a5f4f" translate="yes" xml:space="preserve">
          <source>The dependencies declared in this way are added in the podspec file and downloaded during the execution of &lt;code&gt;pod install&lt;/code&gt;.</source>
          <target state="translated">以这种方式声明的依赖项将添加到podspec文件中，并在执行 &lt;code&gt;pod install&lt;/code&gt; 期间下载。</target>
        </trans-unit>
        <trans-unit id="8e289438644482986fe5eb08aaf9b0616f49cac1" translate="yes" xml:space="preserve">
          <source>The described mechanism for marking and using experimental APIs is itself experimental in Kotlin 1.3. This means that in future releases it may be changed in ways that make it incompatible. To make the users of annotations &lt;code&gt;@Experimental&lt;/code&gt; and &lt;code&gt;UseExperimental&lt;/code&gt; aware of their experimental status, the compiler raises warnings when compiling the code with these annotations:</source>
          <target state="translated">标记和使用实验性API的机制本身在Kotlin 1.3中是实验性的。这意味着在将来的版本中，可能会以使其不兼容的方式进行更改。为了使注释 &lt;code&gt;@Experimental&lt;/code&gt; 和 &lt;code&gt;UseExperimental&lt;/code&gt; 的用户了解他们的实验状态，编译器在使用这些注释编译代码时会发出警告：</target>
        </trans-unit>
        <trans-unit id="cf37d613f63880e424569836a2ab82c0f6bbbfbf" translate="yes" xml:space="preserve">
          <source>The design of inline classes is experimental, meaning that this feature is &lt;em&gt;moving fast&lt;/em&gt; and no compatibility guarantees are given. When using inline classes in Kotlin 1.3+, a warning will be reported, indicating that this feature is experimental.</source>
          <target state="translated">内联类的设计是实验性的，这意味着此功能&lt;em&gt;正在快速发展，&lt;/em&gt;并且不提供兼容性保证。在Kotlin 1.3+中使用内联类时，将报告警告，表明此功能是实验性的。</target>
        </trans-unit>
        <trans-unit id="530e7472ee58bdd7a4958120705547c1d20c1ddf" translate="yes" xml:space="preserve">
          <source>The design of inline classes is in &lt;a href=&quot;evolution/components-stability&quot;&gt;Alpha&lt;/a&gt;, meaning that no compatibility guarantees are given for future versions. When using inline classes in Kotlin 1.3+, a warning will be reported, indicating that this feature has not been released as stable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b65859994bf9d4a7fb5d934baaf88e39c3f04558" translate="yes" xml:space="preserve">
          <source>The design of unsigned types is experimental, meaning that this feature is moving fast and no compatibility guarantees are given. When using unsigned arithmetics in Kotlin 1.3+, warning will be reported, indicating that this feature is experimental. To remove warning, you have to opt-in for experimental usage of unsigned types.</source>
          <target state="translated">无符号类型的设计是实验性的,这意味着这个功能正在快速发展,而且不保证兼容性。当在Kotlin 1.3+中使用无符号算术时,会报告警告,表明这个功能是实验性的。要删除警告,你必须选择加入无符号类型的实验性使用。</target>
        </trans-unit>
        <trans-unit id="a2b28866ac37f05ef8569c7d67a02f97e240cc06" translate="yes" xml:space="preserve">
          <source>The design of unsigned types is in &lt;a href=&quot;evolution/components-stability&quot;&gt;Beta&lt;/a&gt;, meaning that its compatibility is best-effort only and not guaranteed. When using unsigned arithmetics in Kotlin 1.3+, a warning will be reported, indicating that this feature has not been released as stable. To remove the warning, you have to opt in for usage of unsigned types.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0d2b5a6b59247ce3c2ac4eba75f43c56acf4c3d" translate="yes" xml:space="preserve">
          <source>The difference between the two functions is that &lt;code&gt;fold()&lt;/code&gt; takes an initial value and uses it as the accumulated value on the first step, whereas the first step of &lt;code&gt;reduce()&lt;/code&gt; uses the first and the second elements as operation arguments on the first step.</source>
          <target state="translated">这两个函数的区别在于， &lt;code&gt;fold()&lt;/code&gt; 取一个初始值并将其用作第一步的累加值，而 &lt;code&gt;reduce()&lt;/code&gt; 的第一步则将第一和第二个元素用作第一步的操作参数。</target>
        </trans-unit>
        <trans-unit id="16d1b90dc650643e776a4004ab589d677449c331" translate="yes" xml:space="preserve">
          <source>The directories containing the source files to compile</source>
          <target state="translated">包含要编译的源文件的目录。</target>
        </trans-unit>
        <trans-unit id="f28bb53a04db0fb8fa17ba4aa3c143de9bce62e3" translate="yes" xml:space="preserve">
          <source>The dynamic type is not supported in code targeting the JVM</source>
          <target state="translated">在以JVM为目标的代码中不支持动态类型。</target>
        </trans-unit>
        <trans-unit id="52d4bb2170c55ab0a1a89bfce15477357b84c2db" translate="yes" xml:space="preserve">
          <source>The dynamic type is not supported in code targeting the JVM.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1e94b86df57391ab40db234f4362544f610c993" translate="yes" xml:space="preserve">
          <source>The easiest way to create a new application targeting JavaScript with Maven is to allow IntelliJ IDEA to configure the Maven project for us. Simply create a new Maven project in IntelliJ IDEA and once the project is created, add a new folder to host the Kotlin source code, removing the default Java one. The project should end up with the following structure</source>
          <target state="translated">用Maven创建一个针对JavaScript的新应用,最简单的方法就是让IntelliJ IDEA为我们配置Maven项目。只需在IntelliJ IDEA中创建一个新的Maven项目,项目创建完成后,添加一个新的文件夹来存放Kotlin源代码,删除默认的Java文件夹。项目最终应该是如下结构</target>
        </trans-unit>
        <trans-unit id="171e3cf4fb89f709d12d970ce788f0d3a1e1b68e" translate="yes" xml:space="preserve">
          <source>The effect of computing the expression is:</source>
          <target state="translated">计算表达的效果是:。</target>
        </trans-unit>
        <trans-unit id="ff0a9ac30d7664a4e4282016eea87cab13969066" translate="yes" xml:space="preserve">
          <source>The element is initialized with the specified &lt;a href=&quot;append-element#kotlin.dom%24appendElement(org.w3c.dom.Element,%20kotlin.String,%20kotlin.Function1((org.w3c.dom.Element,%20kotlin.Unit)))/init&quot;&gt;init&lt;/a&gt; function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9a189a8bbd800a60d20579c11365537800d1c5b" translate="yes" xml:space="preserve">
          <source>The element is initialized with the specified &lt;a href=&quot;create-element#kotlin.dom%24createElement(org.w3c.dom.Document,%20kotlin.String,%20kotlin.Function1((org.w3c.dom.Element,%20kotlin.Unit)))/init&quot;&gt;init&lt;/a&gt; function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a6537bfaccb8cddd8c481ef1fab76499f34a316" translate="yes" xml:space="preserve">
          <source>The element is initialized with the speicifed &lt;a href=&quot;append-element#kotlin.dom%24appendElement%28org.w3c.dom.Element%2C+kotlin.String%2C+kotlin.Function1%28%28org.w3c.dom.Element%2C+kotlin.Unit%29%29%29%2Finit&quot;&gt;init&lt;/a&gt; function.</source>
          <target state="translated">元素使用指定的&lt;a href=&quot;append-element#kotlin.dom%24appendElement%28org.w3c.dom.Element%2C+kotlin.String%2C+kotlin.Function1%28%28org.w3c.dom.Element%2C+kotlin.Unit%29%29%29%2Finit&quot;&gt;init&lt;/a&gt;函数初始化。</target>
        </trans-unit>
        <trans-unit id="3c970d5af5c7c3d91e3eb72687259d2ce93c168c" translate="yes" xml:space="preserve">
          <source>The element is initialized with the speicifed &lt;a href=&quot;create-element#kotlin.dom%24createElement%28org.w3c.dom.Document%2C+kotlin.String%2C+kotlin.Function1%28%28org.w3c.dom.Element%2C+kotlin.Unit%29%29%29%2Finit&quot;&gt;init&lt;/a&gt; function.</source>
          <target state="translated">元素使用指定的&lt;a href=&quot;create-element#kotlin.dom%24createElement%28org.w3c.dom.Document%2C+kotlin.String%2C+kotlin.Function1%28%28org.w3c.dom.Element%2C+kotlin.Unit%29%29%29%2Finit&quot;&gt;init&lt;/a&gt;函数初始化。</target>
        </trans-unit>
        <trans-unit id="4479436b9b0ce8aa0beac7c43130aa60627f658c" translate="yes" xml:space="preserve">
          <source>The elements are appended in the order they appear in the &lt;a href=&quot;../-mutable-list/add-all#kotlin.collections.MutableList%24addAll%28kotlin.collections.Collection%28%28kotlin.collections.MutableList.E%29%29%29%2Felements&quot;&gt;elements&lt;/a&gt; collection.</source>
          <target state="translated">元素以它们在&lt;a href=&quot;../-mutable-list/add-all#kotlin.collections.MutableList%24addAll%28kotlin.collections.Collection%28%28kotlin.collections.MutableList.E%29%29%29%2Felements&quot;&gt;元素&lt;/a&gt;集合中出现的顺序追加。</target>
        </trans-unit>
        <trans-unit id="544e4fbca97528fef2325c3afe55cace763538a4" translate="yes" xml:space="preserve">
          <source>The elements are appended in the order they appear in the &lt;a href=&quot;../-mutable-list/add-all#kotlin.collections.MutableList%24addAll(kotlin.collections.Collection((kotlin.collections.MutableList.E)))/elements&quot;&gt;elements&lt;/a&gt; collection.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23022bf4214f0845c5b1a370815de8e19dc6515a" translate="yes" xml:space="preserve">
          <source>The elements are appended in the order they appear in the &lt;a href=&quot;add-all#kotlin.collections.MutableList%24addAll%28kotlin.collections.Collection%28%28kotlin.collections.MutableList.E%29%29%29%2Felements&quot;&gt;elements&lt;/a&gt; collection.</source>
          <target state="translated">元素以它们在&lt;a href=&quot;add-all#kotlin.collections.MutableList%24addAll%28kotlin.collections.Collection%28%28kotlin.collections.MutableList.E%29%29%29%2Felements&quot;&gt;元素&lt;/a&gt;集合中出现的顺序追加。</target>
        </trans-unit>
        <trans-unit id="82095a92897d87f6ce531db50ce0bc12db68723f" translate="yes" xml:space="preserve">
          <source>The elements are appended in the order they appear in the &lt;a href=&quot;add-all#kotlin.collections.MutableList%24addAll(kotlin.collections.Collection((kotlin.collections.MutableList.E)))/elements&quot;&gt;elements&lt;/a&gt; collection.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="daa9aa5d9ebd8b42b1bcdf3100554fd92ca03d09" translate="yes" xml:space="preserve">
          <source>The elements are compared for equality with the &lt;a href=&quot;../kotlin/-any/equals#kotlin.Any%24equals%28kotlin.Any%29&quot;&gt;equals&lt;/a&gt; function. For floating point numbers it means that &lt;code&gt;NaN&lt;/code&gt; is equal to itself and &lt;code&gt;-0.0&lt;/code&gt; is not equal to &lt;code&gt;0.0&lt;/code&gt;.</source>
          <target state="translated">将元素与&lt;a href=&quot;../kotlin/-any/equals#kotlin.Any%24equals%28kotlin.Any%29&quot;&gt;equals&lt;/a&gt;函数进行相等性比较。对于浮点数，这意味着 &lt;code&gt;NaN&lt;/code&gt; 等于其自身，并且 &lt;code&gt;-0.0&lt;/code&gt; 不等于 &lt;code&gt;0.0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="aad20466e5a76028e3397e50e8845f24663b34cf" translate="yes" xml:space="preserve">
          <source>The elements are compared for equality with the &lt;a href=&quot;../kotlin/-any/equals#kotlin.Any%24equals(kotlin.Any?)&quot;&gt;equals&lt;/a&gt; function. For floating point numbers it means that &lt;code&gt;NaN&lt;/code&gt; is equal to itself and &lt;code&gt;-0.0&lt;/code&gt; is not equal to &lt;code&gt;0.0&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7d4f10d9d6ff53cf3cb02a56dcf3900dc9233c7" translate="yes" xml:space="preserve">
          <source>The elements in the resulting list are in the same order as they were in the source array.</source>
          <target state="translated">结果列表中的元素与源数组中的元素顺序相同。</target>
        </trans-unit>
        <trans-unit id="4758b35da216c6ed38b8e3b01e9232e835ffdf62" translate="yes" xml:space="preserve">
          <source>The elements in the resulting list are in the same order as they were in the source collection.</source>
          <target state="translated">结果列表中的元素与源集合中的顺序相同。</target>
        </trans-unit>
        <trans-unit id="925245d7080579f68b367dc0eefbb0c6350a2c59" translate="yes" xml:space="preserve">
          <source>The elements in the resulting sequence are in the same order as they were in the source sequence.</source>
          <target state="translated">结果序列中的元素与源序列中的元素顺序相同。</target>
        </trans-unit>
        <trans-unit id="62f13d9c86bbfcad668fdecca43def6919a28064" translate="yes" xml:space="preserve">
          <source>The elements of other types are compared for equality with the &lt;a href=&quot;../kotlin/-any/equals#kotlin.Any%24equals%28kotlin.Any%29&quot;&gt;equals&lt;/a&gt; function. For floating point numbers it means that &lt;code&gt;NaN&lt;/code&gt; is equal to itself and &lt;code&gt;-0.0&lt;/code&gt; is not equal to &lt;code&gt;0.0&lt;/code&gt;.</source>
          <target state="translated">将其他类型的元素与&lt;a href=&quot;../kotlin/-any/equals#kotlin.Any%24equals%28kotlin.Any%29&quot;&gt;equals&lt;/a&gt;函数进行相等性比较。对于浮点数，这意味着 &lt;code&gt;NaN&lt;/code&gt; 等于其自身，并且 &lt;code&gt;-0.0&lt;/code&gt; 不等于 &lt;code&gt;0.0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="410a7c8a1416b4dffdf86f7b2fb29d1be03e7884" translate="yes" xml:space="preserve">
          <source>The elements of other types are compared for equality with the &lt;a href=&quot;../kotlin/-any/equals#kotlin.Any%24equals(kotlin.Any?)&quot;&gt;equals&lt;/a&gt; function. For floating point numbers it means that &lt;code&gt;NaN&lt;/code&gt; is equal to itself and &lt;code&gt;-0.0&lt;/code&gt; is not equal to &lt;code&gt;0.0&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb685b2c6e5acf402eac7fe67da99cd138309729" translate="yes" xml:space="preserve">
          <source>The end index of the &lt;a href=&quot;remove-range#kotlin.text%24removeRange%28kotlin.CharSequence%2C+kotlin.ranges.IntRange%29%2Frange&quot;&gt;range&lt;/a&gt; is included in the removed part.</source>
          <target state="translated">该&lt;a href=&quot;remove-range#kotlin.text%24removeRange%28kotlin.CharSequence%2C+kotlin.ranges.IntRange%29%2Frange&quot;&gt;范围&lt;/a&gt;的结束索引包含在已删除的部分中。</target>
        </trans-unit>
        <trans-unit id="11df9d3925f0418a6e38aed874d509daf4025048" translate="yes" xml:space="preserve">
          <source>The end index of the &lt;a href=&quot;remove-range#kotlin.text%24removeRange%28kotlin.String%2C+kotlin.ranges.IntRange%29%2Frange&quot;&gt;range&lt;/a&gt; is included in the removed part.</source>
          <target state="translated">该&lt;a href=&quot;remove-range#kotlin.text%24removeRange%28kotlin.String%2C+kotlin.ranges.IntRange%29%2Frange&quot;&gt;范围&lt;/a&gt;的结束索引包含在已删除的部分中。</target>
        </trans-unit>
        <trans-unit id="67fcbb6ac3e2a5c62cd2e430c9777a067763d923" translate="yes" xml:space="preserve">
          <source>The end index of the &lt;a href=&quot;remove-range#kotlin.text%24removeRange(kotlin.CharSequence,%20kotlin.ranges.IntRange)/range&quot;&gt;range&lt;/a&gt; is included in the removed part.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7aa81f1705dd0f516aa78c926061ad0c0bdec167" translate="yes" xml:space="preserve">
          <source>The end index of the &lt;a href=&quot;remove-range#kotlin.text%24removeRange(kotlin.String,%20kotlin.ranges.IntRange)/range&quot;&gt;range&lt;/a&gt; is included in the removed part.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88ef0ef1c8adfc13f79b17d279153b4deca66c2a" translate="yes" xml:space="preserve">
          <source>The end index of the &lt;a href=&quot;replace-range#kotlin.text%24replaceRange%28kotlin.CharSequence%2C+kotlin.ranges.IntRange%2C+kotlin.CharSequence%29%2Frange&quot;&gt;range&lt;/a&gt; is included in the part to be replaced.</source>
          <target state="translated">&lt;a href=&quot;replace-range#kotlin.text%24replaceRange%28kotlin.CharSequence%2C+kotlin.ranges.IntRange%2C+kotlin.CharSequence%29%2Frange&quot;&gt;范围&lt;/a&gt;的结束索引包含在要替换的零件中。</target>
        </trans-unit>
        <trans-unit id="110043ac6542bd5ea84cfa58a2ba979b14417af8" translate="yes" xml:space="preserve">
          <source>The end index of the &lt;a href=&quot;replace-range#kotlin.text%24replaceRange%28kotlin.String%2C+kotlin.ranges.IntRange%2C+kotlin.CharSequence%29%2Frange&quot;&gt;range&lt;/a&gt; is included in the part to be replaced.</source>
          <target state="translated">&lt;a href=&quot;replace-range#kotlin.text%24replaceRange%28kotlin.String%2C+kotlin.ranges.IntRange%2C+kotlin.CharSequence%29%2Frange&quot;&gt;范围&lt;/a&gt;的结束索引包含在要替换的零件中。</target>
        </trans-unit>
        <trans-unit id="265808d7f064c65b3e4484a504c21278573abe5f" translate="yes" xml:space="preserve">
          <source>The end index of the &lt;a href=&quot;replace-range#kotlin.text%24replaceRange(kotlin.CharSequence,%20kotlin.ranges.IntRange,%20kotlin.CharSequence)/range&quot;&gt;range&lt;/a&gt; is included in the part to be replaced.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2757b02f416ac5f1c57fe37f28ebb5f19a2beb88" translate="yes" xml:space="preserve">
          <source>The end index of the &lt;a href=&quot;replace-range#kotlin.text%24replaceRange(kotlin.String,%20kotlin.ranges.IntRange,%20kotlin.CharSequence)/range&quot;&gt;range&lt;/a&gt; is included in the part to be replaced.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2bb3fe28b22f0be53eb5ccfae4478026ce71334" translate="yes" xml:space="preserve">
          <source>The entity which has an associated native pointer. Subtypes are supposed to represent interpretations of the pointed data or code.</source>
          <target state="translated">有关联的本机指针的实体。子类型应该代表对指向的数据或代码的解释。</target>
        </trans-unit>
        <trans-unit id="2c6bd81b6f529ef522b5222f238d9ced96f1bfdb" translate="yes" xml:space="preserve">
          <source>The enum constants also implement the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin/-comparable/index&quot;&gt;Comparable&lt;/a&gt; interface, with the natural order being the order in which they are defined in the enum class.</source>
          <target state="translated">枚举常量还实现&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin/-comparable/index&quot;&gt;Comparable&lt;/a&gt;接口，自然顺序是在enum类中定义它们的顺序。</target>
        </trans-unit>
        <trans-unit id="1f86188b4a8b45564220a022aed934fe72f40d6e" translate="yes" xml:space="preserve">
          <source>The example above shows the difference: &lt;code&gt;fold()&lt;/code&gt; is used for calculating the sum of doubled elements. If you pass the same function to &lt;code&gt;reduce()&lt;/code&gt;, it will return another result because it uses the list's first and second elements as arguments on the first step, so the first element won't be doubled.</source>
          <target state="translated">上面的示例显示了区别： &lt;code&gt;fold()&lt;/code&gt; 用于计算加倍元素的总和。如果将相同的函数传递给 &lt;code&gt;reduce()&lt;/code&gt; ，它将返回另一个结果，因为在第一步中它将列表的第一个和第二个元素用作参数，因此第一个元素不会被加倍。</target>
        </trans-unit>
        <trans-unit id="b596f3f6b2203ee7818d443ce1a3eb3a2049daee" translate="yes" xml:space="preserve">
          <source>The example above will work for Android libraries with no product flavors. For a library with product flavors, the variant names also contain the flavors, like &lt;code&gt;fooBarDebug&lt;/code&gt; or &lt;code&gt;fooBazRelease&lt;/code&gt;.</source>
          <target state="translated">上面的示例适用于没有产品口味的Android库。对于具有产品 &lt;code&gt;fooBarDebug&lt;/code&gt; 的库，变量名称也包含样式，例如fooBarDebug或 &lt;code&gt;fooBazRelease&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2034baca1648e38acba659c7ed9ab52779def3a9" translate="yes" xml:space="preserve">
          <source>The example of using &lt;code&gt;convert&lt;/code&gt;:</source>
          <target state="translated">使用 &lt;code&gt;convert&lt;/code&gt; 的示例：</target>
        </trans-unit>
        <trans-unit id="18829b154c907ba2a13646994ee9e04f0d08452d" translate="yes" xml:space="preserve">
          <source>The exception thrown when a character encoding or decoding error occurs.</source>
          <target state="translated">发生字符编码或解码错误时产生的异常。</target>
        </trans-unit>
        <trans-unit id="15573b104c4da364167fd1f5ed5ef94aba8df42c" translate="yes" xml:space="preserve">
          <source>The experimental marker for associated objects API.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d95121d07b3626cf990aefa17a36910bfcf4f29" translate="yes" xml:space="preserve">
          <source>The experimental marker for type inference augmenting annotations.</source>
          <target state="translated">类型推理增强注释的实验标记。</target>
        </trans-unit>
        <trans-unit id="deb8aac7cf53fe1202db4a3293685d56f19ee1b3" translate="yes" xml:space="preserve">
          <source>The experimental multiplatform support API marker.</source>
          <target state="translated">实验性的多平台支持API标记。</target>
        </trans-unit>
        <trans-unit id="0428313ba384ac9c0b8833c120ad8f95ce4ede3d" translate="yes" xml:space="preserve">
          <source>The expression &lt;code&gt;::x&lt;/code&gt; evaluates to a property object of type &lt;code&gt;KProperty&amp;lt;Int&amp;gt;&lt;/code&gt;, which allows us to read its value using &lt;code&gt;get()&lt;/code&gt; or retrieve the property name using the &lt;code&gt;name&lt;/code&gt; property. For more information, please refer to the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.reflect/-k-property/index&quot;&gt;docs on the &lt;code&gt;KProperty&lt;/code&gt; class&lt;/a&gt;.</source>
          <target state="translated">表达式 &lt;code&gt;::x&lt;/code&gt; 的计算结果为 &lt;code&gt;KProperty&amp;lt;Int&amp;gt;&lt;/code&gt; 类型的属性对象，该属性对象使我们可以使用 &lt;code&gt;get()&lt;/code&gt; 读取其值或使用 &lt;code&gt;name&lt;/code&gt; 属性检索属性名称。有关更多信息，请参考&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.reflect/-k-property/index&quot;&gt; &lt;code&gt;KProperty&lt;/code&gt; &lt;/a&gt;类上的文档。</target>
        </trans-unit>
        <trans-unit id="788ff064b8ecef1f248204a84772fdfe4508eee7" translate="yes" xml:space="preserve">
          <source>The file is missing the &lt;code&gt;extern &quot;C&quot;&lt;/code&gt; block, which is not needed for our example, but may be necessary if we use C++ and overloaded functions. The &lt;a href=&quot;https://stackoverflow.com/questions/1041866/what-is-the-effect-of-extern-c-in-c&quot;&gt;C++ compatibility&lt;/a&gt; thread contains more details on this.</source>
          <target state="translated">该文件缺少 &lt;code&gt;extern &quot;C&quot;&lt;/code&gt; 块，这对于我们的示例不是必需的，但是如果我们使用C ++和重载函数，则可能是必需的。在&lt;a href=&quot;https://stackoverflow.com/questions/1041866/what-is-the-effect-of-extern-c-in-c&quot;&gt;C ++的兼容性&lt;/a&gt;线包含更多细节。</target>
        </trans-unit>
        <trans-unit id="2828031dfb85b70cc7191c0b9ade03e3586cc60a" translate="yes" xml:space="preserve">
          <source>The file system locations for the Java sources are different from the &lt;code&gt;java&lt;/code&gt; plugin's defaults. The Java source files need to be placed in the sibling directories of the Kotlin source roots. For example, if the JVM target has the default name &lt;code&gt;jvm&lt;/code&gt;, the paths are:</source>
          <target state="translated">对于Java源文件系统中的位置是从不同 &lt;code&gt;java&lt;/code&gt; 插件的默认设置。Java源文件需要放置在Kotlin源根目录的同级目录中。例如，如果JVM目标具有默认名称 &lt;code&gt;jvm&lt;/code&gt; ，则路径为：</target>
        </trans-unit>
        <trans-unit id="a63cb5acdae60d6976d603a52addbcfa0b41167c" translate="yes" xml:space="preserve">
          <source>The file we're mostly interested in is &lt;code&gt;ConsoleOutput.js&lt;/code&gt;</source>
          <target state="translated">我们最感兴趣的文件是 &lt;code&gt;ConsoleOutput.js&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b2c228ca59fbecd7257e251a141cb2c1718c2ba0" translate="yes" xml:space="preserve">
          <source>The final code in the &lt;code&gt;hello.kt&lt;/code&gt; file may look like that:</source>
          <target state="translated">&lt;code&gt;hello.kt&lt;/code&gt; 文件中的最终代码如下所示：</target>
        </trans-unit>
        <trans-unit id="994c32d45d717275b8093d1a6c05a756a3faeb93" translate="yes" xml:space="preserve">
          <source>The final code in the &lt;code&gt;hello.kt&lt;/code&gt; file may look like this:</source>
          <target state="translated">&lt;code&gt;hello.kt&lt;/code&gt; 文件中的最终代码如下所示：</target>
        </trans-unit>
        <trans-unit id="845eeef01520a4662cdfbe660097ba30ecf3f4fb" translate="yes" xml:space="preserve">
          <source>The final step is to define the actual compilation of the project, which uses the standard IntelliJ IDEA Runner Type</source>
          <target state="translated">最后一步是定义项目的实际编译,它使用标准的IntelliJ IDEA Runner Type</target>
        </trans-unit>
        <trans-unit id="64ebebb6a3a3dfec1d013df86e5fccb457a8633c" translate="yes" xml:space="preserve">
          <source>The final step is to make Xcode call our Gradle build to prepare the &lt;code&gt;SharedCode&lt;/code&gt; framework before each run. We open the &lt;em&gt;Build Phases&lt;/em&gt; tab and click &lt;code&gt;+&lt;/code&gt; to add the &lt;em&gt;New Run Script Phase&lt;/em&gt; and add the following code into it:</source>
          <target state="translated">最后一步是使Xcode调用我们的Gradle构建，以在每次运行之前准备 &lt;code&gt;SharedCode&lt;/code&gt; 框架。我们打开&lt;em&gt;Build Phases&lt;/em&gt;选项卡，然后单击 &lt;code&gt;+&lt;/code&gt; 添加&lt;em&gt;New Run Script Phase&lt;/em&gt;并将以下代码添加到其中：</target>
        </trans-unit>
        <trans-unit id="18cac2860812daece2680c18729b8285d0c95c2d" translate="yes" xml:space="preserve">
          <source>The first &lt;code&gt;this&lt;/code&gt; refers to &lt;code&gt;maybeNull&lt;/code&gt;, the second one refers to the result of &lt;code&gt;firstFunction()&lt;/code&gt;, and &lt;code&gt;result&lt;/code&gt; will be the result of &lt;code&gt;secondFunction()&lt;/code&gt; (or null if &lt;code&gt;maybeNull&lt;/code&gt; or any of the intermediate results were null).</source>
          <target state="translated">第一 &lt;code&gt;this&lt;/code&gt; 是指 &lt;code&gt;maybeNull&lt;/code&gt; ，第二个指的结果 &lt;code&gt;firstFunction()&lt;/code&gt; ，并且 &lt;code&gt;result&lt;/code&gt; 将是的结果 &lt;code&gt;secondFunction()&lt;/code&gt; (或空如果 &lt;code&gt;maybeNull&lt;/code&gt; 或任何中间结果均为零）。</target>
        </trans-unit>
        <trans-unit id="4fdd8b62987d88f8c4db3a2a41e10fc4d1887b5c" translate="yes" xml:space="preserve">
          <source>The first argument in this example allows one to set a name prefix for the created binaries which is used to access them in the buildscript (see the &lt;a href=&quot;#accessing-binaries&quot;&gt;&quot;Accessing binaries&quot;&lt;/a&gt; section). Also this prefix is used as a default name for the binary file. For example on Windows the sample above produces files &lt;code&gt;foo.exe&lt;/code&gt; and &lt;code&gt;bar.exe&lt;/code&gt;.</source>
          <target state="translated">在此示例中，第一个参数允许为已创建的二进制文件设置名称前缀，该名称前缀用于在构建脚本中访问它们（请参见&lt;a href=&quot;#accessing-binaries&quot;&gt;&amp;ldquo;访问二进制文件&amp;rdquo;&lt;/a&gt;部分）。此前缀也用作二进制文件的默认名称。例如，在Windows上，以上示例生成文件 &lt;code&gt;foo.exe&lt;/code&gt; 和 &lt;code&gt;bar.exe&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2fc302c51d198c918ae55a3c30c065988889b3c8" translate="yes" xml:space="preserve">
          <source>The first call in the chain usually should have a line break before it, but it's OK to omit it if the code makes more sense that way.</source>
          <target state="translated">链中的第一个调用通常应该在它之前有一个换行符,但如果这样代码更合理,省略它也是可以的。</target>
        </trans-unit>
        <trans-unit id="b4e33fae8e821602ad4182a2f8cd98570f5752fb" translate="yes" xml:space="preserve">
          <source>The first element in the progression.</source>
          <target state="translated">进阶的第一个要素。</target>
        </trans-unit>
        <trans-unit id="f74c962485a9f3f35870c553a197b5ef319d5a35" translate="yes" xml:space="preserve">
          <source>The first example mixes &lt;em&gt;non-blocking&lt;/em&gt;&lt;code&gt;delay(...)&lt;/code&gt; and &lt;em&gt;blocking&lt;/em&gt;&lt;code&gt;Thread.sleep(...)&lt;/code&gt; in the same code. It is easy to lose track of which one is blocking and which one is not. Let's be explicit about blocking using &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/run-blocking.html&quot;&gt;runBlocking&lt;/a&gt; coroutine builder:</source>
          <target state="translated">第一个示例在同一代码中混合了&lt;em&gt;非阻塞&lt;/em&gt; &lt;code&gt;delay(...)&lt;/code&gt; 和&lt;em&gt;阻塞&lt;/em&gt; &lt;code&gt;Thread.sleep(...)&lt;/code&gt; 。很容易忘记哪个阻塞了，哪个没有阻塞。让我们明确地使用&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/run-blocking.html&quot;&gt;runBlocking&lt;/a&gt;协程生成器进行阻止：</target>
        </trans-unit>
        <trans-unit id="1aa4bbc7c819801ad00e125d4e56e82f4c2f67c5" translate="yes" xml:space="preserve">
          <source>The first example mixes &lt;em&gt;non-blocking&lt;/em&gt;&lt;code&gt;delay(...)&lt;/code&gt; and &lt;em&gt;blocking&lt;/em&gt;&lt;code&gt;Thread.sleep(...)&lt;/code&gt; in the same code. It is easy to lose track of which one is blocking and which one is not. Let's be explicit about blocking using the &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/run-blocking.html&quot;&gt;runBlocking&lt;/a&gt; coroutine builder:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2d66cf460f6f78061ad6d5f7262d3436e850f41" translate="yes" xml:space="preserve">
          <source>The first extension takes a &lt;code&gt;char *&lt;/code&gt; as a UTF-8 string and turns it into a String. The second function does the same but for wide UTF-16 strings.</source>
          <target state="translated">The first extension takes a &lt;code&gt;char *&lt;/code&gt; as a UTF-8 string and turns it into a String. The second function does the same but for wide UTF-16 strings.</target>
        </trans-unit>
        <trans-unit id="60455f009d759b3a711a0c86694ca0f8e3417539" translate="yes" xml:space="preserve">
          <source>The first four elements are added to the buffer and the sender suspends when trying to send the fifth one.</source>
          <target state="translated">前四个元素被添加到缓冲区,当试图发送第五个元素时,发送方暂停。</target>
        </trans-unit>
        <trans-unit id="ab32e32b6495f8ef1ecac2deb728551ecd768355" translate="yes" xml:space="preserve">
          <source>The first function is &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/flatten&quot;&gt;&lt;code&gt;flatten()&lt;/code&gt;&lt;/a&gt;. You can call it on a collection of collections, for example, a &lt;code&gt;List&lt;/code&gt; of &lt;code&gt;Set&lt;/code&gt;s. The function returns a single &lt;code&gt;List&lt;/code&gt; of all the elements of the nested collections.</source>
          <target state="translated">第一个函数是&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/flatten&quot;&gt; &lt;code&gt;flatten()&lt;/code&gt; &lt;/a&gt;。你可以把它在集合的集合，例如，一个 &lt;code&gt;List&lt;/code&gt; 的 &lt;code&gt;Set&lt;/code&gt; 秒。该函数返回嵌套集合的所有元素的单个 &lt;code&gt;List&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bb9b81609c647210d6aacd108c4c1230b4870b5f" translate="yes" xml:space="preserve">
          <source>The first line of the input contains two integers &lt;code&gt;n&lt;/code&gt; and &lt;code&gt;k&lt;/code&gt;</source>
          <target state="translated">输入的第一行包含两个整数 &lt;code&gt;n&lt;/code&gt; 和 &lt;code&gt;k&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a973365d252e2f2156e9bff5ffce49da12fd36a5" translate="yes" xml:space="preserve">
          <source>The first list contains the first elements of each &lt;code&gt;Pair&lt;/code&gt; in the original list.</source>
          <target state="translated">第一个列表包含原始列表中每个 &lt;code&gt;Pair&lt;/code&gt; 的第一个元素。</target>
        </trans-unit>
        <trans-unit id="79bda60284dc4aa80a7917505f3968fd9009f668" translate="yes" xml:space="preserve">
          <source>The first step of using an actor is to define a class of messages that an actor is going to process. Kotlin's &lt;a href=&quot;../sealed-classes&quot;&gt;sealed classes&lt;/a&gt; are well suited for that purpose. We define &lt;code&gt;CounterMsg&lt;/code&gt; sealed class with &lt;code&gt;IncCounter&lt;/code&gt; message to increment a counter and &lt;code&gt;GetCounter&lt;/code&gt; message to get its value. The later needs to send a response. A &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-completable-deferred/index.html&quot;&gt;CompletableDeferred&lt;/a&gt; communication primitive, that represents a single value that will be known (communicated) in the future, is used here for that purpose.</source>
          <target state="translated">使用actor的第一步是定义actor将要处理的一类消息。Kotlin的&lt;a href=&quot;../sealed-classes&quot;&gt;密封课程&lt;/a&gt;非常适合该目的。我们定义 &lt;code&gt;CounterMsg&lt;/code&gt; 密封类 &lt;code&gt;IncCounter&lt;/code&gt; 消息，计数器加 &lt;code&gt;GetCounter&lt;/code&gt; 消息得到其价值。稍后需要发送响应。甲&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-completable-deferred/index.html&quot;&gt;CompletableDeferred&lt;/a&gt;通信原码，即表示将在将来已知的（传送）一个单一的值，在这里用于该目的。</target>
        </trans-unit>
        <trans-unit id="38481ec6d5c41bf35d07d09bc7535247f80dee43" translate="yes" xml:space="preserve">
          <source>The first thing we'll need is a Kotlin file called &lt;code&gt;src/nativeMain/kotlin/hello.kt&lt;/code&gt; with the &lt;code&gt;main&lt;/code&gt; function defined in it and then proceed to translate each line</source>
          <target state="translated">我们需要的第一件事是一个名为 &lt;code&gt;src/nativeMain/kotlin/hello.kt&lt;/code&gt; 的Kotlin文件，其中定义了 &lt;code&gt;main&lt;/code&gt; 函数，然后继续翻译每一行</target>
        </trans-unit>
        <trans-unit id="6f6aa8f820f0284bd28697b0207de3b2578af79f" translate="yes" xml:space="preserve">
          <source>The following attributes are supported:</source>
          <target state="translated">支持以下属性:</target>
        </trans-unit>
        <trans-unit id="d555f20ea9bbf2028964527e2711757cec45ebd4" translate="yes" xml:space="preserve">
          <source>The following code launches a long-running coroutine in &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-global-scope/index.html&quot;&gt;GlobalScope&lt;/a&gt; that prints &quot;I'm sleeping&quot; twice a second and then returns from the main function after some delay:</source>
          <target state="translated">下面的代码在&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-global-scope/index.html&quot;&gt;GlobalScope&lt;/a&gt;中启动一个长时间运行的协程，该协程每秒显示两次&amp;ldquo;我在睡觉&amp;rdquo;，然后在延迟一段时间后从主函数返回：</target>
        </trans-unit>
        <trans-unit id="ead88ea1dd6b3e545d54d2d74bc4d103e0cfff51" translate="yes" xml:space="preserve">
          <source>The following commands are available.</source>
          <target state="translated">可使用以下命令:</target>
        </trans-unit>
        <trans-unit id="55be4cb42f91b956f18957a0a075265fb24672f6" translate="yes" xml:space="preserve">
          <source>The following example demonstrates this concept:</source>
          <target state="translated">下面的例子说明了这个概念。</target>
        </trans-unit>
        <trans-unit id="40d8cb89ac87b573a486f4f8fe49663dde1297b2" translate="yes" xml:space="preserve">
          <source>The following example prints the first ten prime numbers, running the whole pipeline in the context of the main thread. Since all the coroutines are launched in the scope of the main &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/run-blocking.html&quot;&gt;runBlocking&lt;/a&gt; coroutine we don't have to keep an explicit list of all the coroutines we have started. We use &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/kotlin.coroutines.-coroutine-context/cancel-children.html&quot;&gt;cancelChildren&lt;/a&gt; extension function to cancel all the children coroutines after we have printed the first ten prime numbers.</source>
          <target state="translated">下面的示例显示前十个质数，并在主线程的上下文中运行整个管道。由于所有协程都是在主&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/run-blocking.html&quot;&gt;runBlocking&lt;/a&gt;协程的范围内启动的，因此我们不必保留已启动的所有协程的明确列表。在打印前十个质数后，我们使用&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/kotlin.coroutines.-coroutine-context/cancel-children.html&quot;&gt;cancelChildren&lt;/a&gt;扩展功能来取消所有子协程。</target>
        </trans-unit>
        <trans-unit id="9f818012b8152abe166a094d93ab2ca0ec79eab1" translate="yes" xml:space="preserve">
          <source>The following example shows how to use these settings.</source>
          <target state="translated">下面的例子显示了如何使用这些设置。</target>
        </trans-unit>
        <trans-unit id="29c80399d536894a6ec94c527a731166260c49c2" translate="yes" xml:space="preserve">
          <source>The following example shows their use outside of coroutine:</source>
          <target state="translated">下面的例子显示了它们在coroutine之外的使用。</target>
        </trans-unit>
        <trans-unit id="b39c4c0b095563ff59ef483ec27836f8b662f2fa" translate="yes" xml:space="preserve">
          <source>The following examples show different possibilities of configuring the Gradle plugin:</source>
          <target state="translated">下面的例子展示了配置Gradle插件的不同可能性。</target>
        </trans-unit>
        <trans-unit id="e712d7790d39e907b7ee7e8cb60e61e0c86b31e2" translate="yes" xml:space="preserve">
          <source>The following identifiers are defined by the compiler in specific contexts and can be used as regular identifiers in other contexts:</source>
          <target state="translated">以下标识符由编译器在特定上下文中定义,并可在其他上下文中作为常规标识符使用。</target>
        </trans-unit>
        <trans-unit id="bf95dedf99c3841e1d5196a0ba2d969912347f7d" translate="yes" xml:space="preserve">
          <source>The following is an example interface of the JDK implemented by &lt;code&gt;StringBuilder&lt;/code&gt; class:</source>
          <target state="translated">以下是 &lt;code&gt;StringBuilder&lt;/code&gt; 类实现的JDK的示例接口：</target>
        </trans-unit>
        <trans-unit id="8e29598dc88ea6b0ec70ab50aa2a4cfa741c6e7f" translate="yes" xml:space="preserve">
          <source>The following pipeline stage filters an incoming stream of numbers, removing all the numbers that are divisible by the given prime number:</source>
          <target state="translated">下面的流水线阶段过滤输入的数字流,去除所有被给定质数除以的数字。</target>
        </trans-unit>
        <trans-unit id="29b7ef083a5e449cb9ecea68dfa0ae64024fefca" translate="yes" xml:space="preserve">
          <source>The following podspec fields are required by CocoaPods:</source>
          <target state="translated">CocoaPods需要以下podspec字段。</target>
        </trans-unit>
        <trans-unit id="21b0584d86535ffda98821a37bb76687f7207959" translate="yes" xml:space="preserve">
          <source>The following sections explain in more detail the concepts mentioned so far.</source>
          <target state="translated">以下各节将更详细地解释迄今为止所提到的概念。</target>
        </trans-unit>
        <trans-unit id="5472a88e6462dc9e30567cf6b7a816998c79c200" translate="yes" xml:space="preserve">
          <source>The following tokens act as keywords in modifier lists of declarations and can be used as identifiers in other contexts:</source>
          <target state="translated">以下标记在声明的修饰列表中充当关键字,并可在其他情况下作为标识符使用。</target>
        </trans-unit>
        <trans-unit id="c62886b027ba800287b4be18a333a156fdeb309b" translate="yes" xml:space="preserve">
          <source>The following tokens act as keywords in the context when they are applicable and can be used as identifiers in other contexts:</source>
          <target state="translated">以下标记在适用时作为上下文中的关键词,在其他上下文中可作为标识符使用。</target>
        </trans-unit>
        <trans-unit id="71c4c5ec356525034ad2f877a92ba2dfdfffc609" translate="yes" xml:space="preserve">
          <source>The following tokens are always interpreted as keywords and cannot be used as identifiers:</source>
          <target state="translated">以下标记总是被解释为关键字,不能作为标识符使用。</target>
        </trans-unit>
        <trans-unit id="0493d41eaaff9f9930d4990e582a0014dff8b09e" translate="yes" xml:space="preserve">
          <source>The following workflow is expected when interacting with the native library.</source>
          <target state="translated">在与本地库交互时,预计会有以下工作流程。</target>
        </trans-unit>
        <trans-unit id="41bde8cb095fdaa39e87c44d34bec8992402e368" translate="yes" xml:space="preserve">
          <source>The fractional part, if any, is rounded down towards zero. Returns zero if this &lt;code&gt;Double&lt;/code&gt; value is &lt;code&gt;NaN&lt;/code&gt;, &lt;a href=&quot;../-int/-m-i-n_-v-a-l-u-e#kotlin.Int.Companion%24MIN_VALUE&quot;&gt;Int.MIN_VALUE&lt;/a&gt; if it's less than &lt;code&gt;Int.MIN_VALUE&lt;/code&gt;, &lt;a href=&quot;../-int/-m-a-x_-v-a-l-u-e#kotlin.Int.Companion%24MAX_VALUE&quot;&gt;Int.MAX_VALUE&lt;/a&gt; if it's bigger than &lt;code&gt;Int.MAX_VALUE&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7dbd577dd676bd08f82b2f5d51d9ac8e4bfc959" translate="yes" xml:space="preserve">
          <source>The fractional part, if any, is rounded down towards zero. Returns zero if this &lt;code&gt;Double&lt;/code&gt; value is &lt;code&gt;NaN&lt;/code&gt;, &lt;a href=&quot;../-long/-m-i-n_-v-a-l-u-e#kotlin.Long.Companion%24MIN_VALUE&quot;&gt;Long.MIN_VALUE&lt;/a&gt; if it's less than &lt;code&gt;Long.MIN_VALUE&lt;/code&gt;, &lt;a href=&quot;../-long/-m-a-x_-v-a-l-u-e#kotlin.Long.Companion%24MAX_VALUE&quot;&gt;Long.MAX_VALUE&lt;/a&gt; if it's bigger than &lt;code&gt;Long.MAX_VALUE&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c24376936f310cfc6a2b02ee789c1ab9c4a079c" translate="yes" xml:space="preserve">
          <source>The fractional part, if any, is rounded down towards zero. Returns zero if this &lt;code&gt;Double&lt;/code&gt; value is negative or &lt;code&gt;NaN&lt;/code&gt;, &lt;a href=&quot;-u-int/-m-a-x_-v-a-l-u-e&quot;&gt;UInt.MAX_VALUE&lt;/a&gt; if it's bigger than &lt;code&gt;UInt.MAX_VALUE&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19ac86b4bcb26b195d587cd10aa019f5e68922bb" translate="yes" xml:space="preserve">
          <source>The fractional part, if any, is rounded down towards zero. Returns zero if this &lt;code&gt;Double&lt;/code&gt; value is negative or &lt;code&gt;NaN&lt;/code&gt;, &lt;a href=&quot;-u-long/-m-a-x_-v-a-l-u-e&quot;&gt;ULong.MAX_VALUE&lt;/a&gt; if it's bigger than &lt;code&gt;ULong.MAX_VALUE&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a03b953ac3fd08a46517db9b02880729ef0942e5" translate="yes" xml:space="preserve">
          <source>The fractional part, if any, is rounded down towards zero. Returns zero if this &lt;code&gt;Float&lt;/code&gt; value is &lt;code&gt;NaN&lt;/code&gt;, &lt;a href=&quot;../-int/-m-i-n_-v-a-l-u-e#kotlin.Int.Companion%24MIN_VALUE&quot;&gt;Int.MIN_VALUE&lt;/a&gt; if it's less than &lt;code&gt;Int.MIN_VALUE&lt;/code&gt;, &lt;a href=&quot;../-int/-m-a-x_-v-a-l-u-e#kotlin.Int.Companion%24MAX_VALUE&quot;&gt;Int.MAX_VALUE&lt;/a&gt; if it's bigger than &lt;code&gt;Int.MAX_VALUE&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8f1f7669eb111859c7b969d69798041d2a9b37e" translate="yes" xml:space="preserve">
          <source>The fractional part, if any, is rounded down towards zero. Returns zero if this &lt;code&gt;Float&lt;/code&gt; value is &lt;code&gt;NaN&lt;/code&gt;, &lt;a href=&quot;../-long/-m-i-n_-v-a-l-u-e#kotlin.Long.Companion%24MIN_VALUE&quot;&gt;Long.MIN_VALUE&lt;/a&gt; if it's less than &lt;code&gt;Long.MIN_VALUE&lt;/code&gt;, &lt;a href=&quot;../-long/-m-a-x_-v-a-l-u-e#kotlin.Long.Companion%24MAX_VALUE&quot;&gt;Long.MAX_VALUE&lt;/a&gt; if it's bigger than &lt;code&gt;Long.MAX_VALUE&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43741e55696c4613d380e3f315ef0bfbfc2d96be" translate="yes" xml:space="preserve">
          <source>The fractional part, if any, is rounded down towards zero. Returns zero if this &lt;code&gt;Float&lt;/code&gt; value is negative or &lt;code&gt;NaN&lt;/code&gt;, &lt;a href=&quot;-u-int/-m-a-x_-v-a-l-u-e&quot;&gt;UInt.MAX_VALUE&lt;/a&gt; if it's bigger than &lt;code&gt;UInt.MAX_VALUE&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3fd2c9a0fe0f333063fc214dadef0239e9bff9de" translate="yes" xml:space="preserve">
          <source>The fractional part, if any, is rounded down towards zero. Returns zero if this &lt;code&gt;Float&lt;/code&gt; value is negative or &lt;code&gt;NaN&lt;/code&gt;, &lt;a href=&quot;-u-long/-m-a-x_-v-a-l-u-e&quot;&gt;ULong.MAX_VALUE&lt;/a&gt; if it's bigger than &lt;code&gt;ULong.MAX_VALUE&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46d230bab2ec3e41d052e1e397afc7cc1e96642c" translate="yes" xml:space="preserve">
          <source>The fractional part, if any, is rounded down. Returns zero if this &lt;code&gt;Double&lt;/code&gt; value is &lt;code&gt;NaN&lt;/code&gt;, &lt;a href=&quot;../-int/-m-i-n_-v-a-l-u-e#kotlin.Int.Companion%24MIN_VALUE&quot;&gt;Int.MIN_VALUE&lt;/a&gt; if it's less than &lt;code&gt;Int.MIN_VALUE&lt;/code&gt;, &lt;a href=&quot;../-int/-m-a-x_-v-a-l-u-e#kotlin.Int.Companion%24MAX_VALUE&quot;&gt;Int.MAX_VALUE&lt;/a&gt; if it's bigger than &lt;code&gt;Int.MAX_VALUE&lt;/code&gt;.</source>
          <target state="translated">小数部分（如果有）四舍五入。返回零，如果这 &lt;code&gt;Double&lt;/code&gt; 价值 &lt;code&gt;NaN&lt;/code&gt; ，&lt;a href=&quot;../-int/-m-i-n_-v-a-l-u-e#kotlin.Int.Companion%24MIN_VALUE&quot;&gt;Int.MIN_VALUE&lt;/a&gt;如果是小于 &lt;code&gt;Int.MIN_VALUE&lt;/code&gt; ，&lt;a href=&quot;../-int/-m-a-x_-v-a-l-u-e#kotlin.Int.Companion%24MAX_VALUE&quot;&gt;int.MAX_VALUE的&lt;/a&gt;，如果它比大 &lt;code&gt;Int.MAX_VALUE&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c7c04cb487d62c119eaf78735ad59d58fbbea7f7" translate="yes" xml:space="preserve">
          <source>The fractional part, if any, is rounded down. Returns zero if this &lt;code&gt;Double&lt;/code&gt; value is &lt;code&gt;NaN&lt;/code&gt;, &lt;a href=&quot;../-long/-m-i-n_-v-a-l-u-e#kotlin.Long.Companion%24MIN_VALUE&quot;&gt;Long.MIN_VALUE&lt;/a&gt; if it's less than &lt;code&gt;Long.MIN_VALUE&lt;/code&gt;, &lt;a href=&quot;../-long/-m-a-x_-v-a-l-u-e#kotlin.Long.Companion%24MAX_VALUE&quot;&gt;Long.MAX_VALUE&lt;/a&gt; if it's bigger than &lt;code&gt;Long.MAX_VALUE&lt;/code&gt;.</source>
          <target state="translated">小数部分（如果有）四舍五入。返回零，如果这 &lt;code&gt;Double&lt;/code&gt; 价值 &lt;code&gt;NaN&lt;/code&gt; ，&lt;a href=&quot;../-long/-m-i-n_-v-a-l-u-e#kotlin.Long.Companion%24MIN_VALUE&quot;&gt;Long.MIN_VALUE&lt;/a&gt;，如果是小于 &lt;code&gt;Long.MIN_VALUE&lt;/code&gt; ，&lt;a href=&quot;../-long/-m-a-x_-v-a-l-u-e#kotlin.Long.Companion%24MAX_VALUE&quot;&gt;Long.MAX_VALUE&lt;/a&gt;如果它比大 &lt;code&gt;Long.MAX_VALUE&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="986d603361e48796a38eb31b882249f0e0fb1907" translate="yes" xml:space="preserve">
          <source>The fractional part, if any, is rounded down. Returns zero if this &lt;code&gt;Double&lt;/code&gt; value is negative or &lt;code&gt;NaN&lt;/code&gt;, &lt;a href=&quot;-u-int/-m-a-x_-v-a-l-u-e&quot;&gt;UInt.MAX_VALUE&lt;/a&gt; if it's bigger than &lt;code&gt;UInt.MAX_VALUE&lt;/code&gt;.</source>
          <target state="translated">小数部分（如果有）四舍五入。如果此 &lt;code&gt;Double&lt;/code&gt; 值是负数或 &lt;code&gt;NaN&lt;/code&gt; ，则返回零；如果&lt;a href=&quot;-u-int/-m-a-x_-v-a-l-u-e&quot;&gt;UInt.MAX_VALUE&lt;/a&gt;大于 &lt;code&gt;UInt.MAX_VALUE&lt;/code&gt; ，则返回零。</target>
        </trans-unit>
        <trans-unit id="db89446a546caa08c045751959e85b9b42af6661" translate="yes" xml:space="preserve">
          <source>The fractional part, if any, is rounded down. Returns zero if this &lt;code&gt;Double&lt;/code&gt; value is negative or &lt;code&gt;NaN&lt;/code&gt;, &lt;a href=&quot;-u-long/-m-a-x_-v-a-l-u-e&quot;&gt;ULong.MAX_VALUE&lt;/a&gt; if it's bigger than &lt;code&gt;ULong.MAX_VALUE&lt;/code&gt;.</source>
          <target state="translated">小数部分（如果有）四舍五入。如果此 &lt;code&gt;Double&lt;/code&gt; 值是负数或 &lt;code&gt;NaN&lt;/code&gt; ，则返回零&lt;a href=&quot;-u-long/-m-a-x_-v-a-l-u-e&quot;&gt;；&lt;/a&gt;如果它大于 &lt;code&gt;ULong.MAX_VALUE&lt;/code&gt; ，则返回ULong.MAX_VALUE。</target>
        </trans-unit>
        <trans-unit id="6c0d7df43097a38a432b999c674eaa178ec96a50" translate="yes" xml:space="preserve">
          <source>The fractional part, if any, is rounded down. Returns zero if this &lt;code&gt;Float&lt;/code&gt; value is &lt;code&gt;NaN&lt;/code&gt;, &lt;a href=&quot;../-int/-m-i-n_-v-a-l-u-e#kotlin.Int.Companion%24MIN_VALUE&quot;&gt;Int.MIN_VALUE&lt;/a&gt; if it's less than &lt;code&gt;Int.MIN_VALUE&lt;/code&gt;, &lt;a href=&quot;../-int/-m-a-x_-v-a-l-u-e#kotlin.Int.Companion%24MAX_VALUE&quot;&gt;Int.MAX_VALUE&lt;/a&gt; if it's bigger than &lt;code&gt;Int.MAX_VALUE&lt;/code&gt;.</source>
          <target state="translated">小数部分（如果有）四舍五入。返回零，如果这个 &lt;code&gt;Float&lt;/code&gt; 值为 &lt;code&gt;NaN&lt;/code&gt; 的，&lt;a href=&quot;../-int/-m-i-n_-v-a-l-u-e#kotlin.Int.Companion%24MIN_VALUE&quot;&gt;Int.MIN_VALUE&lt;/a&gt;如果是小于 &lt;code&gt;Int.MIN_VALUE&lt;/code&gt; ，&lt;a href=&quot;../-int/-m-a-x_-v-a-l-u-e#kotlin.Int.Companion%24MAX_VALUE&quot;&gt;int.MAX_VALUE的&lt;/a&gt;，如果它比大 &lt;code&gt;Int.MAX_VALUE&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="234cddb40ea7edc20ba16f302fd45e435a6a6dbf" translate="yes" xml:space="preserve">
          <source>The fractional part, if any, is rounded down. Returns zero if this &lt;code&gt;Float&lt;/code&gt; value is &lt;code&gt;NaN&lt;/code&gt;, &lt;a href=&quot;../-long/-m-i-n_-v-a-l-u-e#kotlin.Long.Companion%24MIN_VALUE&quot;&gt;Long.MIN_VALUE&lt;/a&gt; if it's less than &lt;code&gt;Long.MIN_VALUE&lt;/code&gt;, &lt;a href=&quot;../-long/-m-a-x_-v-a-l-u-e#kotlin.Long.Companion%24MAX_VALUE&quot;&gt;Long.MAX_VALUE&lt;/a&gt; if it's bigger than &lt;code&gt;Long.MAX_VALUE&lt;/code&gt;.</source>
          <target state="translated">小数部分（如果有）四舍五入。返回零，如果这个 &lt;code&gt;Float&lt;/code&gt; 值为 &lt;code&gt;NaN&lt;/code&gt; 的，&lt;a href=&quot;../-long/-m-i-n_-v-a-l-u-e#kotlin.Long.Companion%24MIN_VALUE&quot;&gt;Long.MIN_VALUE&lt;/a&gt;，如果是小于 &lt;code&gt;Long.MIN_VALUE&lt;/code&gt; ，&lt;a href=&quot;../-long/-m-a-x_-v-a-l-u-e#kotlin.Long.Companion%24MAX_VALUE&quot;&gt;Long.MAX_VALUE&lt;/a&gt;如果它比大 &lt;code&gt;Long.MAX_VALUE&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0a1bb43be34e6fb6de623932b67b670ae0006852" translate="yes" xml:space="preserve">
          <source>The fractional part, if any, is rounded down. Returns zero if this &lt;code&gt;Float&lt;/code&gt; value is negative or &lt;code&gt;NaN&lt;/code&gt;, &lt;a href=&quot;-u-int/-m-a-x_-v-a-l-u-e&quot;&gt;UInt.MAX_VALUE&lt;/a&gt; if it's bigger than &lt;code&gt;UInt.MAX_VALUE&lt;/code&gt;.</source>
          <target state="translated">小数部分（如果有）四舍五入。如果此 &lt;code&gt;Float&lt;/code&gt; 值为负或 &lt;code&gt;NaN&lt;/code&gt; ，则返回零&lt;a href=&quot;-u-int/-m-a-x_-v-a-l-u-e&quot;&gt;；&lt;/a&gt;如果它大于 &lt;code&gt;UInt.MAX_VALUE&lt;/code&gt; ，则返回UInt.MAX_VALUE。</target>
        </trans-unit>
        <trans-unit id="1fdd0d739f0100ce802b95ab4a4c9b2532feeff0" translate="yes" xml:space="preserve">
          <source>The fractional part, if any, is rounded down. Returns zero if this &lt;code&gt;Float&lt;/code&gt; value is negative or &lt;code&gt;NaN&lt;/code&gt;, &lt;a href=&quot;-u-long/-m-a-x_-v-a-l-u-e&quot;&gt;ULong.MAX_VALUE&lt;/a&gt; if it's bigger than &lt;code&gt;ULong.MAX_VALUE&lt;/code&gt;.</source>
          <target state="translated">小数部分（如果有）四舍五入。如果此 &lt;code&gt;Float&lt;/code&gt; 值为负或 &lt;code&gt;NaN&lt;/code&gt; ，则返回零&lt;a href=&quot;-u-long/-m-a-x_-v-a-l-u-e&quot;&gt;；&lt;/a&gt;如果其大于 &lt;code&gt;ULong.MAX_VALUE&lt;/code&gt; ，则返回ULong.MAX_VALUE。</target>
        </trans-unit>
        <trans-unit id="ea6eb6722ce134e1e96c66df47559354876af311" translate="yes" xml:space="preserve">
          <source>The framework that we compiled with Kotlin/Native has helper attributes to make it easier to use with Swift. Let's convert the previous Objective-C example into Swift. As a result, we'll have the following code in &lt;code&gt;main.swift&lt;/code&gt;:</source>
          <target state="translated">我们使用Kotlin / Native编译的框架具有helper属性，可以更轻松地与Swift一起使用。让我们将之前的Objective-C示例转换为Swift。结果，我们将在 &lt;code&gt;main.swift&lt;/code&gt; 中包含以下代码：</target>
        </trans-unit>
        <trans-unit id="229775820ba0ca0053d7b140e68dd9b3ed428ae4" translate="yes" xml:space="preserve">
          <source>The full build script for the sample project can be found &lt;a href=&quot;https://github.com/JetBrains/kotlin-examples/tree/master/gradle/kotlin-dagger/build.gradle&quot;&gt;here&lt;/a&gt;. You can also look at the converted code for &lt;a href=&quot;https://github.com/JetBrains/kotlin-examples/tree/master/gradle/android-dagger&quot;&gt;the Android sample&lt;/a&gt;.</source>
          <target state="translated">示例项目的完整构建脚本可以在&lt;a href=&quot;https://github.com/JetBrains/kotlin-examples/tree/master/gradle/kotlin-dagger/build.gradle&quot;&gt;此处&lt;/a&gt;找到。您还可以查看&lt;a href=&quot;https://github.com/JetBrains/kotlin-examples/tree/master/gradle/android-dagger&quot;&gt;Android示例&lt;/a&gt;的转换后代码。</target>
        </trans-unit>
        <trans-unit id="e62bc4cb51ca1d1cddfe4e1d3d510caa93dee388" translate="yes" xml:space="preserve">
          <source>The full list of arguments that can be used is shown when you run &lt;code&gt;kotlinc -help&lt;/code&gt;.</source>
          <target state="translated">运行 &lt;code&gt;kotlinc -help&lt;/code&gt; 时会显示可以使用的参数的完整列表。</target>
        </trans-unit>
        <trans-unit id="02b69f589be9184eaa6e08d9fb77b12e7b2d6da2" translate="yes" xml:space="preserve">
          <source>The full list of supported use-site targets is:</source>
          <target state="translated">支持的使用网站目标的完整清单是:</target>
        </trans-unit>
        <trans-unit id="58018a7c2f7cccce2f2841705c78d55576a7e56f" translate="yes" xml:space="preserve">
          <source>The full syntactic form of lambda expressions is as follows:</source>
          <target state="translated">lambda表达式的完整语法形式如下。</target>
        </trans-unit>
        <trans-unit id="1347221f9ac10fa3f9465e07c5ca87cc27e8a8e6" translate="yes" xml:space="preserve">
          <source>The full syntax for declaring a property is</source>
          <target state="translated">声明一个属性的完整语法是</target>
        </trans-unit>
        <trans-unit id="905c760b34a0beb7b5d4d319c2f007dd8ebd0fd3" translate="yes" xml:space="preserve">
          <source>The full syntax of a read-only property declaration differs from a mutable one in two ways: it starts with &lt;code&gt;val&lt;/code&gt; instead of &lt;code&gt;var&lt;/code&gt; and does not allow a setter:</source>
          <target state="translated">只读属性声明的完整语法在两个方面不同于可变的声明：它以 &lt;code&gt;val&lt;/code&gt; 而不是 &lt;code&gt;var&lt;/code&gt; 开头，并且不允许使用setter：</target>
        </trans-unit>
        <trans-unit id="776f7d695f882be224aebfaccabd52b1c0591bc5" translate="yes" xml:space="preserve">
          <source>The fully qualified dot-separated name of the class, or &lt;code&gt;null&lt;/code&gt; if the class is local or a class of an anonymous object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ee52f844a0963f3db9f0478ccd20b13916c48b9" translate="yes" xml:space="preserve">
          <source>The fully qualified dot-separated name of the class, or &lt;code&gt;null&lt;/code&gt; if the class is local or it is an anonymous object literal.</source>
          <target state="translated">类的完全限定的点名分隔 &lt;code&gt;null&lt;/code&gt; 如果类是本地类，或者它是一个匿名对象文字，则为null。</target>
        </trans-unit>
        <trans-unit id="f6c5b38e497b6843a07b1a8945d528e3c7606264" translate="yes" xml:space="preserve">
          <source>The function &lt;a href=&quot;-list#kotlin.collections%24List(kotlin.Int,%20kotlin.Function1((kotlin.Int,%20kotlin.collections.List.T)))/init&quot;&gt;init&lt;/a&gt; is called for each list element sequentially starting from the first one. It should return the value for a list element given its index.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7696926a08823163fe79a297a106aabaf3f3d399" translate="yes" xml:space="preserve">
          <source>The function &lt;a href=&quot;-mutable-list#kotlin.collections%24MutableList(kotlin.Int,%20kotlin.Function1((kotlin.Int,%20kotlin.collections.MutableList.T)))/init&quot;&gt;init&lt;/a&gt; is called for each list element sequentially starting from the first one. It should return the value for a list element given its index.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed3c35965fc33462a41df8d6c5d69d9f13434071" translate="yes" xml:space="preserve">
          <source>The function &lt;a href=&quot;-u-byte-array#kotlin%24UByteArray(kotlin.Int,%20kotlin.Function1((kotlin.Int,%20kotlin.UByte)))/init&quot;&gt;init&lt;/a&gt; is called for each array element sequentially starting from the first one. It should return the value for an array element given its index.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="acfbb507b912e298abe7a785c884c806da178f93" translate="yes" xml:space="preserve">
          <source>The function &lt;a href=&quot;-u-int-array#kotlin%24UIntArray(kotlin.Int,%20kotlin.Function1((kotlin.Int,%20kotlin.UInt)))/init&quot;&gt;init&lt;/a&gt; is called for each array element sequentially starting from the first one. It should return the value for an array element given its index.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="804f600305f25777086b4066f40ae2670855676b" translate="yes" xml:space="preserve">
          <source>The function &lt;a href=&quot;-u-long-array#kotlin%24ULongArray(kotlin.Int,%20kotlin.Function1((kotlin.Int,%20kotlin.ULong)))/init&quot;&gt;init&lt;/a&gt; is called for each array element sequentially starting from the first one. It should return the value for an array element given its index.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98c90b068891a2e0a90f241b535756a6f3e22982" translate="yes" xml:space="preserve">
          <source>The function &lt;a href=&quot;-u-short-array#kotlin%24UShortArray(kotlin.Int,%20kotlin.Function1((kotlin.Int,%20kotlin.UShort)))/init&quot;&gt;init&lt;/a&gt; is called for each array element sequentially starting from the first one. It should return the value for an array element given its index.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39a40c87789f813fc496dc5468cc91805583814e" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;libnative_symbols&lt;/code&gt; allows us to open the way from the native code to the Kotlin/Native library. This is the entry point we use. The library name is used as a prefix for the function name.</source>
          <target state="translated">函数 &lt;code&gt;libnative_symbols&lt;/code&gt; 允许我们打开从本机代码到Kotlin / Native库的方式。这是我们使用的切入点。库名称用作函数名称的前缀。</target>
        </trans-unit>
        <trans-unit id="ecf68a80d3d421d1a3dac0bf6a7b99795040c5e0" translate="yes" xml:space="preserve">
          <source>The function body is delimited by curly braces - indentation is generally not significant in Kotlin, but you should of course indent your code properly for the benefit of human readers.</source>
          <target state="translated">函数体以大括号为界--在Kotlin中,缩进一般并不重要,但为了人类读者的利益,你当然应该适当缩进你的代码。</target>
        </trans-unit>
        <trans-unit id="892b57cbc7486be03e2291de2837204f537e592b" translate="yes" xml:space="preserve">
          <source>The function does upgrade from read to write lock if needed, but this upgrade is not atomic as such upgrade is not supported by &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/util/concurrent/locks/ReentrantReadWriteLock.html&quot;&gt;ReentrantReadWriteLock&lt;/a&gt;. In order to do such upgrade this function first releases all read locks held by this thread, then acquires write lock, and after releasing it acquires read locks back again.</source>
          <target state="translated">如果需要，该函数会从读取锁定升级到写入锁定，但是此升级不是原子升级，因为&lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/util/concurrent/locks/ReentrantReadWriteLock.html&quot;&gt;ReentrantReadWriteLock&lt;/a&gt;不支持这种升级。为了进行此类升级，此功能首先释放该线程持有的所有读取锁定，然后获取写入锁定，释放后再返回获取读取锁定。</target>
        </trans-unit>
        <trans-unit id="41eab38f14ba2d1160f8a85b6cc897eb549e21ad" translate="yes" xml:space="preserve">
          <source>The function does upgrade from read to write lock if needed, but this upgrade is not atomic as such upgrade is not supported by &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/locks/ReentrantReadWriteLock.html&quot;&gt;ReentrantReadWriteLock&lt;/a&gt;. In order to do such upgrade this function first releases all read locks held by this thread, then acquires write lock, and after releasing it acquires read locks back again.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11c5bbd79a2512e469db0fde4da38bfd3abb594c" translate="yes" xml:space="preserve">
          <source>The function init is called for each array element sequentially starting from the first one. It should return the value for an array element given its index.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47e9d14611b3a1f9114880a2ff853190d9e97c10" translate="yes" xml:space="preserve">
          <source>The function signature remains exactly the same. The only difference is &lt;code&gt;suspend&lt;/code&gt; being added to it. The return type however is the type we want to be returned.</source>
          <target state="translated">功能签名保持完全相同。唯一的区别是将 &lt;code&gt;suspend&lt;/code&gt; 添加到其中。但是，返回类型是我们要返回的类型。</target>
        </trans-unit>
        <trans-unit id="f6772ad37911fb29515e5ecad2f466bed6bdb7cd" translate="yes" xml:space="preserve">
          <source>The function type notation can optionally include names for the function parameters: &lt;code&gt;(x: Int, y: Int) -&amp;gt; Point&lt;/code&gt;. These names can be used for documenting the meaning of the parameters.</source>
          <target state="translated">函数类型表示法可以选择包含函数参数的名称： &lt;code&gt;(x: Int, y: Int) -&amp;gt; Point&lt;/code&gt; 。这些名称可用于记录参数的含义。</target>
        </trans-unit>
        <trans-unit id="5f62a960bb01edb991f086fcecfa3233b3994fce" translate="yes" xml:space="preserve">
          <source>The functions include trigonometric, hyperbolic, exponentiation and power, logarithmic, rounding, sign and absolute value.</source>
          <target state="translated">函数包括三角函数、双曲函数、指数和幂函数、对数函数、四舍五入函数、符号函数和绝对值函数。</target>
        </trans-unit>
        <trans-unit id="332c4fb906dbcda140f018d0de201e8c1ce3d30d" translate="yes" xml:space="preserve">
          <source>The general rule is: when a type parameter &lt;code&gt;T&lt;/code&gt; of a class &lt;code&gt;C&lt;/code&gt; is declared &lt;strong&gt;out&lt;/strong&gt;, it may occur only in &lt;strong&gt;out&lt;/strong&gt;-position in the members of &lt;code&gt;C&lt;/code&gt;, but in return &lt;code&gt;C&amp;lt;Base&amp;gt;&lt;/code&gt; can safely be a supertype of &lt;code&gt;C&amp;lt;Derived&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">一般规则是：当声明类 &lt;code&gt;C&lt;/code&gt; 的类型参数 &lt;code&gt;T&lt;/code&gt; &lt;strong&gt;时&lt;/strong&gt;，它只能出现在 &lt;code&gt;C&lt;/code&gt; 成员的&lt;strong&gt;外部&lt;/strong&gt;位置，但作为回报， &lt;code&gt;C&amp;lt;Base&amp;gt;&lt;/code&gt; 可以安全地成为 &lt;code&gt;C&amp;lt;Derived&amp;gt;&lt;/code&gt; 的超类型。&lt;strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="47a803852f9a44b2a9ede00ebab7d2f5f19ab5c5" translate="yes" xml:space="preserve">
          <source>The general rule:</source>
          <target state="translated">一般规则:</target>
        </trans-unit>
        <trans-unit id="39d2229c00faf1c133ef862b873c7364c63bd099" translate="yes" xml:space="preserve">
          <source>The general solution that works both for threads and for coroutines is to use a thread-safe (aka synchronized, linearizable, or atomic) data structure that provides all the necessarily synchronization for the corresponding operations that needs to be performed on a shared state. In the case of a simple counter we can use &lt;code&gt;AtomicInteger&lt;/code&gt; class which has atomic &lt;code&gt;incrementAndGet&lt;/code&gt; operations:</source>
          <target state="translated">适用于线程和协程的通用解决方案是使用线程安全（又名同步，线性化或原子）数据结构，该结构为需要在共享状态下执行的相应操作提供所有必需的同步。在简单计数器的情况下，我们可以使用 &lt;code&gt;AtomicInteger&lt;/code&gt; 类，该类具有原子的 &lt;code&gt;incrementAndGet&lt;/code&gt; 操作：</target>
        </trans-unit>
        <trans-unit id="4e700b89372f9cc694759aa68e2252618aa967c7" translate="yes" xml:space="preserve">
          <source>The general solution that works both for threads and for coroutines is to use a thread-safe (aka synchronized, linearizable, or atomic) data structure that provides all the necessary synchronization for the corresponding operations that needs to be performed on a shared state. In the case of a simple counter we can use &lt;code&gt;AtomicInteger&lt;/code&gt; class which has atomic &lt;code&gt;incrementAndGet&lt;/code&gt; operations:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe194a34c4e181902ef2477861ca1a56a0c14e72" translate="yes" xml:space="preserve">
          <source>The generated constructor is synthetic so it can&amp;rsquo;t be directly called from Java or Kotlin, but it can be called using reflection.</source>
          <target state="translated">生成的构造函数是合成的，因此无法直接从Java或Kotlin调用，但可以使用反射调用。</target>
        </trans-unit>
        <trans-unit id="c09ea74ea1b03fd685bbe5f94354a8374db022b3" translate="yes" xml:space="preserve">
          <source>The getter of this property, used to obtain the value of the property.</source>
          <target state="translated">该属性的获取者,用于获取该属性的价值。</target>
        </trans-unit>
        <trans-unit id="5599725590a9016e21ca4310f17eb7b2b01a0483" translate="yes" xml:space="preserve">
          <source>The globs are applied to the header paths relative to the appropriate include path elements, e.g. &lt;code&gt;time.h&lt;/code&gt; or &lt;code&gt;curl/curl.h&lt;/code&gt;. So if the library is usually included with &lt;code&gt;#include &amp;lt;SomeLbrary/Header.h&amp;gt;&lt;/code&gt;, then it would probably be correct to filter headers with</source>
          <target state="translated">相对于适当的包含路径元素（例如 &lt;code&gt;time.h&lt;/code&gt; 或 &lt;code&gt;curl/curl.h&lt;/code&gt; )，将这些小球应用于标头路径。因此，如果该库通常包含在 &lt;code&gt;#include &amp;lt;SomeLbrary/Header.h&amp;gt;&lt;/code&gt; 中，则使用以下方法过滤标头可能是正确的</target>
        </trans-unit>
        <trans-unit id="a57ffec5971f7b3f89d004ca095f66feb86eb296" translate="yes" xml:space="preserve">
          <source>The goal of the tutorial is to demonstrate Kotlin code re-use between Android and iOS. Let's start by manually creating the &lt;code&gt;SharedCode&lt;/code&gt; sub-project in our Gradle project. The source code from the &lt;code&gt;SharedCode&lt;/code&gt; project will be shared between platforms. We will create several new files in our project to implement that.</source>
          <target state="translated">本教程的目的是演示Android和iOS之间Kotlin代码的重用。让我们从在Gradle项目中手动创建 &lt;code&gt;SharedCode&lt;/code&gt; 子项目开始。 &lt;code&gt;SharedCode&lt;/code&gt; 项目的源代码将在平台之间共享。我们将在项目中创建几个新文件来实现该目的。</target>
        </trans-unit>
        <trans-unit id="068a964193217c327091688b8b7de38e4eb4f3e1" translate="yes" xml:space="preserve">
          <source>The header files merely contain function declarations for functionality that is defined at runtime. For instance, we could define a &lt;code&gt;jQuery&lt;/code&gt; function like so</source>
          <target state="translated">头文件仅包含在运行时定义的功能的功能声明。例如，我们可以像这样定义一个 &lt;code&gt;jQuery&lt;/code&gt; 函数</target>
        </trans-unit>
        <trans-unit id="6ce2e166fe215303244aa3044be29e2844cbf2bc" translate="yes" xml:space="preserve">
          <source>The iOS simulator requires a framework compiled for the &lt;code&gt;ios_x64&lt;/code&gt; target, the &lt;code&gt;iOS_sim&lt;/code&gt; folder in our case.</source>
          <target state="translated">iOS模拟器需要为 &lt;code&gt;ios_x64&lt;/code&gt; 目标（在本例中为 &lt;code&gt;iOS_sim&lt;/code&gt; 文件夹）编译的框架。</target>
        </trans-unit>
        <trans-unit id="31859b6cbcfb9892316b62d967e1f5ae2235d5ef" translate="yes" xml:space="preserve">
          <source>The idea behind Rx is to move towards what's called &lt;code&gt;observable streams&lt;/code&gt; where by we now think of data as streams (infinite amounts of data) and these streams can be observed. In practical terms, Rx is simply the &lt;a href=&quot;https://en.wikipedia.org/wiki/Observer_pattern&quot;&gt;Observer Pattern&lt;/a&gt; with a series of extensions which allow us to operate on the data.</source>
          <target state="translated">Rx背后的想法是朝着所谓的 &lt;code&gt;observable streams&lt;/code&gt; 移动，在这里我们现在将数据视为流（无限量的数据），并且可以观察到这些流。实际上，Rx只是&lt;a href=&quot;https://en.wikipedia.org/wiki/Observer_pattern&quot;&gt;观察者模式&lt;/a&gt;，具有一系列扩展，可让我们对数据进行操作。</target>
        </trans-unit>
        <trans-unit id="a752acd40500d4af1aa6897c4527c1276e603455" translate="yes" xml:space="preserve">
          <source>The idea behind futures or promises (there are also other terms these can be referred to depending on language/platform), is that when we make a call, we're promised that at some point it will return with an object called a Promise, which can then be operated on.</source>
          <target state="translated">期货或承诺(根据语言/平台的不同,也有其他的术语)背后的想法是,当我们进行调用时,我们被承诺在某一时刻它将返回一个称为承诺的对象,然后可以对其进行操作。</target>
        </trans-unit>
        <trans-unit id="0ec5a5ec78c5bbba1d9a9593b45aa36ac04ad75c" translate="yes" xml:space="preserve">
          <source>The idea is to make every platform show similar text: &lt;code&gt;Kotlin Rocks on Android&lt;/code&gt; and &lt;code&gt;Kotlin Rocks on iOS&lt;/code&gt;, depending on the platform. We will reuse the way we generate the message. Let's create the file (and missing directories) &lt;code&gt;SharedCode/src/commonMain/kotlin/common.kt&lt;/code&gt; with the following contents under the project root directory</source>
          <target state="translated">我们的想法是让每一个平台显示出类似的文字： &lt;code&gt;Kotlin Rocks on Android&lt;/code&gt; 和 &lt;code&gt;Kotlin Rocks on iOS&lt;/code&gt; ，根据不同的平台上。我们将重用我们生成消息的方式。让我们在项目根目录下 &lt;code&gt;SharedCode/src/commonMain/kotlin/common.kt&lt;/code&gt; 具有以下内容的文件（和缺少目录）SharedCode / src / commonMain / kotlin / common.kt</target>
        </trans-unit>
        <trans-unit id="82fd6cd237e491604315526b684dbfedf391a053" translate="yes" xml:space="preserve">
          <source>The implementation of the &lt;a href=&quot;-mutable-set/index#kotlin.collections.MutableSet&quot;&gt;MutableSet&lt;/a&gt; interface, backed by a &lt;a href=&quot;-hash-map/index#kotlin.collections.HashMap&quot;&gt;HashMap&lt;/a&gt; instance.</source>
          <target state="translated">由&lt;a href=&quot;-hash-map/index#kotlin.collections.HashMap&quot;&gt;HashMap&lt;/a&gt;实例支持的&lt;a href=&quot;-mutable-set/index#kotlin.collections.MutableSet&quot;&gt;MutableSet&lt;/a&gt;接口的实现。</target>
        </trans-unit>
        <trans-unit id="6ba732549bab36d600a33b057cb1445e14d3cdfc" translate="yes" xml:space="preserve">
          <source>The implementation of the &lt;a href=&quot;-mutable-set/index#kotlin.collections.MutableSet&quot;&gt;MutableSet&lt;/a&gt; interface, backed by a &lt;a href=&quot;-linked-hash-map/index#kotlin.collections.LinkedHashMap&quot;&gt;LinkedHashMap&lt;/a&gt; instance.</source>
          <target state="translated">由&lt;a href=&quot;-linked-hash-map/index#kotlin.collections.LinkedHashMap&quot;&gt;LinkedHashMap&lt;/a&gt;实例支持的&lt;a href=&quot;-mutable-set/index#kotlin.collections.MutableSet&quot;&gt;MutableSet&lt;/a&gt;接口的实现。</target>
        </trans-unit>
        <trans-unit id="e80ec37934bbec50821c43bd38cce1238a634038" translate="yes" xml:space="preserve">
          <source>The implementation of the &lt;a href=&quot;../-mutable-set/index#kotlin.collections.MutableSet&quot;&gt;MutableSet&lt;/a&gt; interface, backed by a &lt;a href=&quot;../-hash-map/index#kotlin.collections.HashMap&quot;&gt;HashMap&lt;/a&gt; instance.</source>
          <target state="translated">由&lt;a href=&quot;../-hash-map/index#kotlin.collections.HashMap&quot;&gt;HashMap&lt;/a&gt;实例支持的&lt;a href=&quot;../-mutable-set/index#kotlin.collections.MutableSet&quot;&gt;MutableSet&lt;/a&gt;接口的实现。</target>
        </trans-unit>
        <trans-unit id="9ab2ec2a4f2966a3555f9fce9c9ee7c196c5adc8" translate="yes" xml:space="preserve">
          <source>The implementation of the &lt;a href=&quot;../-mutable-set/index#kotlin.collections.MutableSet&quot;&gt;MutableSet&lt;/a&gt; interface, backed by a &lt;a href=&quot;../-linked-hash-map/index#kotlin.collections.LinkedHashMap&quot;&gt;LinkedHashMap&lt;/a&gt; instance.</source>
          <target state="translated">由&lt;a href=&quot;../-linked-hash-map/index#kotlin.collections.LinkedHashMap&quot;&gt;LinkedHashMap&lt;/a&gt;实例支持的&lt;a href=&quot;../-mutable-set/index#kotlin.collections.MutableSet&quot;&gt;MutableSet&lt;/a&gt;接口的实现。</target>
        </trans-unit>
        <trans-unit id="41ae2cd6b24e4bafa0efb17c582aa2f3dbd61174" translate="yes" xml:space="preserve">
          <source>The implementation of the &lt;a href=&quot;../../kotlin.collections/-mutable-set/index#kotlin.collections.MutableSet&quot;&gt;MutableSet&lt;/a&gt; interface, backed by a &lt;a href=&quot;../../kotlin.collections/-hash-map/index#kotlin.collections.HashMap&quot;&gt;HashMap&lt;/a&gt; instance.</source>
          <target state="translated">由&lt;a href=&quot;../../kotlin.collections/-hash-map/index#kotlin.collections.HashMap&quot;&gt;HashMap&lt;/a&gt;实例支持的&lt;a href=&quot;../../kotlin.collections/-mutable-set/index#kotlin.collections.MutableSet&quot;&gt;MutableSet&lt;/a&gt;接口的实现。</target>
        </trans-unit>
        <trans-unit id="b29deea1bb921913df3a5fadba5cd74a8f4acd5e" translate="yes" xml:space="preserve">
          <source>The implementation of the &lt;a href=&quot;../../kotlin.collections/-mutable-set/index#kotlin.collections.MutableSet&quot;&gt;MutableSet&lt;/a&gt; interface, backed by a &lt;a href=&quot;../../kotlin.collections/-linked-hash-map/index#kotlin.collections.LinkedHashMap&quot;&gt;LinkedHashMap&lt;/a&gt; instance.</source>
          <target state="translated">由&lt;a href=&quot;../../kotlin.collections/-linked-hash-map/index#kotlin.collections.LinkedHashMap&quot;&gt;LinkedHashMap&lt;/a&gt;实例支持的&lt;a href=&quot;../../kotlin.collections/-mutable-set/index#kotlin.collections.MutableSet&quot;&gt;MutableSet&lt;/a&gt;接口的实现。</target>
        </trans-unit>
        <trans-unit id="a6579034caa6bf530c44ba48e1557ccf3e4b94a3" translate="yes" xml:space="preserve">
          <source>The implementation of the &lt;a href=&quot;index#kotlin.collections.MutableSet&quot;&gt;MutableSet&lt;/a&gt; interface, backed by a &lt;a href=&quot;../-hash-map/index#kotlin.collections.HashMap&quot;&gt;HashMap&lt;/a&gt; instance.</source>
          <target state="translated">由&lt;a href=&quot;../-hash-map/index#kotlin.collections.HashMap&quot;&gt;HashMap&lt;/a&gt;实例支持的&lt;a href=&quot;index#kotlin.collections.MutableSet&quot;&gt;MutableSet&lt;/a&gt;接口的实现。</target>
        </trans-unit>
        <trans-unit id="a009a3a444f03e70f059b3c04a3a49cc825d720d" translate="yes" xml:space="preserve">
          <source>The implementation of the &lt;a href=&quot;index#kotlin.collections.MutableSet&quot;&gt;MutableSet&lt;/a&gt; interface, backed by a &lt;a href=&quot;../-linked-hash-map/index#kotlin.collections.LinkedHashMap&quot;&gt;LinkedHashMap&lt;/a&gt; instance.</source>
          <target state="translated">由&lt;a href=&quot;../-linked-hash-map/index#kotlin.collections.LinkedHashMap&quot;&gt;LinkedHashMap&lt;/a&gt;实例支持的&lt;a href=&quot;index#kotlin.collections.MutableSet&quot;&gt;MutableSet&lt;/a&gt;接口的实现。</target>
        </trans-unit>
        <trans-unit id="fa50aaadf0215e23e542746cdfa2658460833341" translate="yes" xml:space="preserve">
          <source>The implementor is required to implement &lt;a href=&quot;../-map/entries#kotlin.collections.Map%24entries&quot;&gt;entries&lt;/a&gt; property, which should return read-only set of map entries.</source>
          <target state="translated">实现者需要实现&lt;a href=&quot;../-map/entries#kotlin.collections.Map%24entries&quot;&gt;entrys&lt;/a&gt;属性，该属性应返回映射条目的只读集。</target>
        </trans-unit>
        <trans-unit id="0d9844010488cdb05175b5fbda28866913c16552" translate="yes" xml:space="preserve">
          <source>The implementor is required to implement &lt;a href=&quot;../-mutable-map/entries#kotlin.collections.MutableMap%24entries&quot;&gt;entries&lt;/a&gt; property, which should return mutable set of map entries, and &lt;a href=&quot;put#kotlin.collections.AbstractMutableMap%24put%28kotlin.collections.AbstractMutableMap.K%2C+kotlin.collections.AbstractMutableMap.V%29&quot;&gt;put&lt;/a&gt; function.</source>
          <target state="translated">需要实现者实现&lt;a href=&quot;../-mutable-map/entries#kotlin.collections.MutableMap%24entries&quot;&gt;entrys&lt;/a&gt;属性，该属性应返回可变的映射条目集，并&lt;a href=&quot;put#kotlin.collections.AbstractMutableMap%24put%28kotlin.collections.AbstractMutableMap.K%2C+kotlin.collections.AbstractMutableMap.V%29&quot;&gt;放置put&lt;/a&gt;函数。</target>
        </trans-unit>
        <trans-unit id="4c2bcd3066d4911e1651a3eb4e73833cb38dc376" translate="yes" xml:space="preserve">
          <source>The implementor is required to implement &lt;a href=&quot;../-mutable-map/entries#kotlin.collections.MutableMap%24entries&quot;&gt;entries&lt;/a&gt; property, which should return mutable set of map entries, and &lt;a href=&quot;put#kotlin.collections.AbstractMutableMap%24put(kotlin.collections.AbstractMutableMap.K,%20kotlin.collections.AbstractMutableMap.V)&quot;&gt;put&lt;/a&gt; function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b072b8461d749216f126589f253d2136dcee5a49" translate="yes" xml:space="preserve">
          <source>The implementor is required to implement &lt;a href=&quot;entries&quot;&gt;entries&lt;/a&gt; property, which should return mutable set of map entries, and &lt;a href=&quot;put#kotlin.collections.AbstractMutableMap%24put%28kotlin.collections.AbstractMutableMap.K%2C+kotlin.collections.AbstractMutableMap.V%29&quot;&gt;put&lt;/a&gt; function.</source>
          <target state="translated">需要实现者实现&lt;a href=&quot;entries&quot;&gt;entrys&lt;/a&gt;属性，该属性应返回可变的映射条目集，并&lt;a href=&quot;put#kotlin.collections.AbstractMutableMap%24put%28kotlin.collections.AbstractMutableMap.K%2C+kotlin.collections.AbstractMutableMap.V%29&quot;&gt;放置put&lt;/a&gt;函数。</target>
        </trans-unit>
        <trans-unit id="de6f180abcaad3c2e2c4cd19c5f847e641f85c21" translate="yes" xml:space="preserve">
          <source>The implementor is required to implement &lt;a href=&quot;entries&quot;&gt;entries&lt;/a&gt; property, which should return mutable set of map entries, and &lt;a href=&quot;put#kotlin.collections.AbstractMutableMap%24put(kotlin.collections.AbstractMutableMap.K,%20kotlin.collections.AbstractMutableMap.V)&quot;&gt;put&lt;/a&gt; function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4d84ada0a069eb9728359000c31d5443cb7fe8c" translate="yes" xml:space="preserve">
          <source>The in-place sorting functions have similar names to the functions that apply to read-only lists, but without the &lt;code&gt;ed/d&lt;/code&gt; suffix:</source>
          <target state="translated">就地排序功能与应用于只读列表的功能具有相似的名称，但没有 &lt;code&gt;ed/d&lt;/code&gt; 后缀：</target>
        </trans-unit>
        <trans-unit id="ad88781015ab91e944a6d24ed6740d21e1a613c0" translate="yes" xml:space="preserve">
          <source>The indentation in front of the accessors is due to convention; like elsewhere in Kotlin, it has no syntactic significance. The compiler can tell which accessors belong to which properties because the only legal place for an accessor is immediately after the property declaration (and there can be at most one getter and one setter) - so you can't split the property declaration and the accessor declarations. However, the order of the accessors doesn't matter.</source>
          <target state="translated">访问器前面的缩进是由于惯例,就像 Kotlin 的其他地方一样,它没有语法意义。编译器可以知道哪些访问器属于哪些属性,因为访问器的唯一合法位置是紧接在属性声明之后(最多只能有一个getter和一个setter)--所以你不能把属性声明和访问器声明分开。然而,访问器的顺序并不重要。</target>
        </trans-unit>
        <trans-unit id="a438c4c204700f052b62784ad094f3d42692c3e5" translate="yes" xml:space="preserve">
          <source>The inheritors are used in &lt;a href=&quot;-contract-builder/index&quot;&gt;ContractBuilder&lt;/a&gt; to describe the contract of a function.</source>
          <target state="translated">在&lt;a href=&quot;-contract-builder/index&quot;&gt;ContractBuilder中&lt;/a&gt;，继承程序用于描述函数的约定。</target>
        </trans-unit>
        <trans-unit id="927c0a69730a98787dc84c53359365aef174d24b" translate="yes" xml:space="preserve">
          <source>The initializer, getter and setter are optional. Property type is optional if it can be inferred from the initializer (or from the getter return type, as shown below).</source>
          <target state="translated">初始化器、getter和setter是可选的。如果可以从初始化器中推断出属性类型(或从getter返回类型中推断出属性类型,如下图所示),则属性类型是可选的。</target>
        </trans-unit>
        <trans-unit id="df4b9318a341c1f296940189b67832418073c297" translate="yes" xml:space="preserve">
          <source>The inserted characters go in same order as in the &lt;a href=&quot;insert#kotlin.text.StringBuilder%24insert(kotlin.Int,%20kotlin.CharArray)/value&quot;&gt;value&lt;/a&gt; character array, starting at &lt;a href=&quot;insert#kotlin.text.StringBuilder%24insert(kotlin.Int,%20kotlin.CharArray)/index&quot;&gt;index&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d6b868449af039ece3f79e19a7f1bdef4bb1a01" translate="yes" xml:space="preserve">
          <source>The inserted characters go in the same order as in the &lt;a href=&quot;insert#kotlin.text.StringBuilder%24insert(kotlin.Int,%20kotlin.CharSequence?)/value&quot;&gt;value&lt;/a&gt; character sequence, starting at &lt;a href=&quot;insert#kotlin.text.StringBuilder%24insert(kotlin.Int,%20kotlin.CharSequence?)/index&quot;&gt;index&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73ab217fa7b8d452fbb508f24860b5983aed819b" translate="yes" xml:space="preserve">
          <source>The insertion order is preserved by maintaining a doubly-linked list of all of its entries.</source>
          <target state="translated">通过对其所有条目保持一个双链接的列表来保留插入顺序。</target>
        </trans-unit>
        <trans-unit id="d2ac540734122ad9d9f148278a049a69e4049649" translate="yes" xml:space="preserve">
          <source>The instance of the object declaration, or &lt;code&gt;null&lt;/code&gt; if this class is not an object declaration.</source>
          <target state="translated">对象声明的实例；如果此类不是对象声明，则为 &lt;code&gt;null&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4e1a88c47519272f4d061661530035978afeff04" translate="yes" xml:space="preserve">
          <source>The interoperability tool analyses C headers and produces a &quot;natural&quot; mapping of the types, functions, and constants into the Kotlin world. The generated stubs can be imported into an IDE for the purpose of code completion and navigation.</source>
          <target state="translated">互操作性工具分析C头文件,并生成类型、函数和常量到Kotlin世界的 &quot;自然 &quot;映射。生成的存根可以导入到IDE中,用于完成代码和导航。</target>
        </trans-unit>
        <trans-unit id="78163206f8e53ce50e1eec86f00b2814cc4b80d9" translate="yes" xml:space="preserve">
          <source>The kapt annotation processing tasks are &lt;a href=&quot;https://guides.gradle.org/using-build-cache/&quot;&gt;cached in Gradle&lt;/a&gt; by default. However, annotation processors run arbitrary code that may not necessarily transform the task inputs into the outputs, might access and modify the files that are not tracked by Gradle etc. If the annotation processors used in the build cannot be properly cached, it is possible to disable caching for kapt entirely by adding the following lines to the build script, in order to avoid false-positive cache hits for the kapt tasks:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c34ac28f0b47dc2a95569e5a72bbe09867d14d5" translate="yes" xml:space="preserve">
          <source>The kapt annotation processing tasks are not &lt;a href=&quot;https://guides.gradle.org/using-build-cache/&quot;&gt;cached in Gradle&lt;/a&gt; by default. Annotation processors run arbitrary code that may not necessarily transform the task inputs into the outputs, might access and modify the files that are not tracked by Gradle etc. To enable caching for kapt anyway, add the following lines to the build script:</source>
          <target state="translated">默认情况下，kapt注释处理任务不会&lt;a href=&quot;https://guides.gradle.org/using-build-cache/&quot;&gt;缓存在Gradle中&lt;/a&gt;。注释处理器运行任意代码，这些代码不一定会将任务输入转换为输出，可能会访问和修改Gradle等未跟踪的文件。无论如何要为kapt启用缓存，请在构建脚本中添加以下几行：</target>
        </trans-unit>
        <trans-unit id="0d265db62daefe24281a53daa642fa0260c64977" translate="yes" xml:space="preserve">
          <source>The key benefit of using sealed classes comes into play when you use them in a &lt;a href=&quot;control-flow#when-expression&quot;&gt;&lt;code&gt;when&lt;/code&gt; expression&lt;/a&gt;. If it's possible to verify that the statement covers all cases, you don't need to add an &lt;code&gt;else&lt;/code&gt; clause to the statement. However, this works only if you use &lt;code&gt;when&lt;/code&gt; as an expression (using the result) and not as a statement.</source>
          <target state="translated">当在&lt;a href=&quot;control-flow#when-expression&quot;&gt; &lt;code&gt;when&lt;/code&gt; 表达式&lt;/a&gt;中使用密封类时，使用密封类的主要好处就发挥了作用。如果可以验证该语句是否涵盖所有情况，则无需在该语句中添加 &lt;code&gt;else&lt;/code&gt; 子句。但是，仅当您将 &lt;code&gt;when&lt;/code&gt; 用作表达式（使用结果）而不用作语句时，此方法才有效。</target>
        </trans-unit>
        <trans-unit id="60878e19d1626a7113513294279d9306ebdfd3af" translate="yes" xml:space="preserve">
          <source>The key differences to the old model are:</source>
          <target state="translated">与老款的主要区别是:</target>
        </trans-unit>
        <trans-unit id="ba83743a7b4886ce5d922ef71ed4bc654a53eba4" translate="yes" xml:space="preserve">
          <source>The key for each element is provided by the &lt;a href=&quot;-grouping/key-of&quot;&gt;Grouping.keyOf&lt;/a&gt; function.</source>
          <target state="translated">每个元素的键由&lt;a href=&quot;-grouping/key-of&quot;&gt;Grouping.keyOf&lt;/a&gt;函数提供。</target>
        </trans-unit>
        <trans-unit id="c7780b4923a988af8ea0601856ae08a944187203" translate="yes" xml:space="preserve">
          <source>The key new feature in Kotlin 1.1 is &lt;em&gt;coroutines&lt;/em&gt;, bringing the support of &lt;code&gt;async&lt;/code&gt;/&lt;code&gt;await&lt;/code&gt;, &lt;code&gt;yield&lt;/code&gt; and similar programming patterns. The key feature of Kotlin's design is that the implementation of coroutine execution is part of the libraries, not the language, so you aren't bound to any specific programming paradigm or concurrency library.</source>
          <target state="translated">Kotlin 1.1中的关键新功能是&lt;em&gt;协程&lt;/em&gt;，带来了对 &lt;code&gt;async&lt;/code&gt; / &lt;code&gt;await&lt;/code&gt; ， &lt;code&gt;yield&lt;/code&gt; 和类似编程模式的支持。Kotlin设计的关键特征是协程执行的实现是库的一部分，而不是语言的一部分，因此您不必受限于任何特定的编程范例或并发库。</target>
        </trans-unit>
        <trans-unit id="255ddce16ff2d3386fde18744e92b0919a0c3dcd" translate="yes" xml:space="preserve">
          <source>The key that defines &lt;em&gt;the&lt;/em&gt; context interceptor.</source>
          <target state="translated">定义键&lt;em&gt;的&lt;/em&gt;情况下拦截。</target>
        </trans-unit>
        <trans-unit id="f78236335bddfda90f254cf18135e3e283c652aa" translate="yes" xml:space="preserve">
          <source>The key to understanding why this trick works is rather simple: if you can only &lt;strong&gt;take&lt;/strong&gt; items from a collection, then using a collection of &lt;code&gt;String&lt;/code&gt;s and reading &lt;code&gt;Object&lt;/code&gt;s from it is fine. Conversely, if you can only &lt;em&gt;put&lt;/em&gt; items into the collection, it's OK to take a collection of &lt;code&gt;Object&lt;/code&gt;s and put &lt;code&gt;String&lt;/code&gt;s into it: in Java we have &lt;code&gt;List&amp;lt;? super String&amp;gt;&lt;/code&gt; a &lt;strong&gt;supertype&lt;/strong&gt; of &lt;code&gt;List&amp;lt;Object&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">理解此技巧为何有效的关键非常简单：如果您只能从一个集合中&lt;strong&gt;获取&lt;/strong&gt;项目，则可以使用 &lt;code&gt;String&lt;/code&gt; 的集合并从中读取 &lt;code&gt;Object&lt;/code&gt; 。相反，如果您只能&lt;em&gt;将&lt;/em&gt;项目放入集合，则可以将 &lt;code&gt;Object&lt;/code&gt; 的集合放入 &lt;code&gt;String&lt;/code&gt; ：在Java中，我们具有 &lt;code&gt;List&amp;lt;? super String&amp;gt;&lt;/code&gt; 一个&lt;strong&gt;超类型&lt;/strong&gt;的 &lt;code&gt;List&amp;lt;Object&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e72d25f147746520f953f90cd2e72b99d7c03c99" translate="yes" xml:space="preserve">
          <source>The kind of JS module generated by the compiler</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d05fefa144a9bfaff0069cb495aef5fbbe9dc415" translate="yes" xml:space="preserve">
          <source>The language settings are checked for consistency between source sets depending on each other. Namely, if &lt;code&gt;foo&lt;/code&gt; depends on &lt;code&gt;bar&lt;/code&gt;:</source>
          <target state="translated">检查语言设置是否相互依赖，以确保源集之间的一致性。即，如果 &lt;code&gt;foo&lt;/code&gt; 取决于 &lt;code&gt;bar&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="7ae80735e57bee13b52032eac31a1a1787272a8f" translate="yes" xml:space="preserve">
          <source>The language settings for a source set can be specified as follows:</source>
          <target state="translated">源集的语言设置可指定如下。</target>
        </trans-unit>
        <trans-unit id="fbaea25f697b924abdcdee8361823761cf7fe6eb" translate="yes" xml:space="preserve">
          <source>The language used to document Kotlin code (the equivalent of Java's JavaDoc) is called &lt;strong&gt;KDoc&lt;/strong&gt;. In its essence, KDoc combines JavaDoc's syntax for block tags (extended to support Kotlin's specific constructs) and Markdown for inline markup.</source>
          <target state="translated">用于记录Kotlin代码的语言（与Java的JavaDoc等效）称为&lt;strong&gt;KDoc&lt;/strong&gt;。本质上，KDoc结合了JavaDoc的块标记语法（扩展以支持Kotlin的特定构造）和Markdown的内联标记。</target>
        </trans-unit>
        <trans-unit id="6bd524ff724eae23548f42d94d576b7a82d79f24" translate="yes" xml:space="preserve">
          <source>The last element in the progression.</source>
          <target state="translated">进展中的最后一个元素。</target>
        </trans-unit>
        <trans-unit id="5ac343906b9635efc6bc3ea707e0886b7e34f40a" translate="yes" xml:space="preserve">
          <source>The last element of the progression is calculated to find the maximum value not greater than the end value for a positive step or the minimum value not less than the end value for a negative step such that &lt;code&gt;(last - first) % step == 0&lt;/code&gt;.</source>
          <target state="translated">计算该级数的最后一个元素，以找到正步长的最大值不大于最终值或负步长的最小值不小于最终值，以使 &lt;code&gt;(last - first) % step == 0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="01b3b5a6efe68e4716a891433d6bbbed0351ca8d" translate="yes" xml:space="preserve">
          <source>The last line is invoking the function itself and passing as argument &lt;code&gt;kotlin&lt;/code&gt;, which refers to the standard library. This can be obtained in one of two ways:</source>
          <target state="translated">最后一行是调用函数本身并作为参数 &lt;code&gt;kotlin&lt;/code&gt; 传递，该参数引用标准库。可以通过以下两种方式之一来获得：</target>
        </trans-unit>
        <trans-unit id="538d53f2bc70104b650857f7bb5ca32765c9300b" translate="yes" xml:space="preserve">
          <source>The last list in the resulting list may have less elements than the given &lt;a href=&quot;chunked#kotlin.collections%24chunked%28kotlin.collections.Iterable%28%28kotlin.collections.chunked.T%29%29%2C+kotlin.Int%29%2Fsize&quot;&gt;size&lt;/a&gt;.</source>
          <target state="translated">结果列表中的最后一个列表的元素数可能少于给定的&lt;a href=&quot;chunked#kotlin.collections%24chunked%28kotlin.collections.Iterable%28%28kotlin.collections.chunked.T%29%29%2C+kotlin.Int%29%2Fsize&quot;&gt;大小&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ff4c16017113383cfa2553bc4b666ff8af31f35a" translate="yes" xml:space="preserve">
          <source>The last list in the resulting list may have less elements than the given &lt;a href=&quot;chunked#kotlin.collections%24chunked(kotlin.collections.Iterable((kotlin.collections.chunked.T)),%20kotlin.Int)/size&quot;&gt;size&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df81eba7c4b794145b48baa6539e2f2979a8d58f" translate="yes" xml:space="preserve">
          <source>The last list in the resulting sequence may have less elements than the given &lt;a href=&quot;chunked#kotlin.sequences%24chunked%28kotlin.sequences.Sequence%28%28kotlin.sequences.chunked.T%29%29%2C+kotlin.Int%29%2Fsize&quot;&gt;size&lt;/a&gt;.</source>
          <target state="translated">结果序列中的最后一个列表可能包含的元素少于给定&lt;a href=&quot;chunked#kotlin.sequences%24chunked%28kotlin.sequences.Sequence%28%28kotlin.sequences.chunked.T%29%29%2C+kotlin.Int%29%2Fsize&quot;&gt;大小的&lt;/a&gt;元素。</target>
        </trans-unit>
        <trans-unit id="e4ef2ba5891ebf7ffa1b88944ac0282efb5fecf2" translate="yes" xml:space="preserve">
          <source>The last list in the resulting sequence may have less elements than the given &lt;a href=&quot;chunked#kotlin.sequences%24chunked(kotlin.sequences.Sequence((kotlin.sequences.chunked.T)),%20kotlin.Int)/size&quot;&gt;size&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19dcc0ec6fdfe1941cf804b7c1eaf5c5297a4c82" translate="yes" xml:space="preserve">
          <source>The last string in the resulting list may have less characters than the given &lt;a href=&quot;chunked#kotlin.text%24chunked%28kotlin.CharSequence%2C+kotlin.Int%29%2Fsize&quot;&gt;size&lt;/a&gt;.</source>
          <target state="translated">结果列表中的最后一个字符串的字符数可能少于给定的&lt;a href=&quot;chunked#kotlin.text%24chunked%28kotlin.CharSequence%2C+kotlin.Int%29%2Fsize&quot;&gt;大小&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="01c80e09f206886b89d00be2fa9ab43305c32874" translate="yes" xml:space="preserve">
          <source>The last string in the resulting list may have less characters than the given &lt;a href=&quot;chunked#kotlin.text%24chunked(kotlin.CharSequence,%20kotlin.Int)/size&quot;&gt;size&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5264566740d059c5fcc7247f9b4782bf04dc775d" translate="yes" xml:space="preserve">
          <source>The last string in the resulting sequence may have less characters than the given &lt;a href=&quot;chunked-sequence#kotlin.text%24chunkedSequence%28kotlin.CharSequence%2C+kotlin.Int%29%2Fsize&quot;&gt;size&lt;/a&gt;.</source>
          <target state="translated">结果序列中的最后一个字符串的字符数可能少于给定的&lt;a href=&quot;chunked-sequence#kotlin.text%24chunkedSequence%28kotlin.CharSequence%2C+kotlin.Int%29%2Fsize&quot;&gt;大小&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7ebb5e898a1a9ea0d92ef57e7df9d364782eae89" translate="yes" xml:space="preserve">
          <source>The last string in the resulting sequence may have less characters than the given &lt;a href=&quot;chunked-sequence#kotlin.text%24chunkedSequence(kotlin.CharSequence,%20kotlin.Int)/size&quot;&gt;size&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34c76d76568703e916e3116e8326427af7debc51" translate="yes" xml:space="preserve">
          <source>The lastIndex is a read/write integer property of regular expressions that specifies the index at which to start the next match.</source>
          <target state="translated">lastIndex是正则表达式的一个读/写整数属性,指定了开始下一次匹配的索引。</target>
        </trans-unit>
        <trans-unit id="9d0eba273c11a973f53f6330c745e78d9f5b9345" translate="yes" xml:space="preserve">
          <source>The latter is called &lt;strong&gt;contravariance&lt;/strong&gt;, and you can only call methods that take String as an argument on &lt;code&gt;List&amp;lt;? super String&amp;gt;&lt;/code&gt; (e.g., you can call &lt;code&gt;add(String)&lt;/code&gt; or &lt;code&gt;set(int, String)&lt;/code&gt;), while if you call something that returns &lt;code&gt;T&lt;/code&gt; in &lt;code&gt;List&amp;lt;T&amp;gt;&lt;/code&gt;, you don't get a &lt;code&gt;String&lt;/code&gt;, but an &lt;code&gt;Object&lt;/code&gt;.</source>
          <target state="translated">后者称为&lt;strong&gt;convarivariance&lt;/strong&gt;，您只能调用将String作为 &lt;code&gt;List&amp;lt;? super String&amp;gt;&lt;/code&gt; 上的参数的方法。超级String&amp;gt;（例如，您可以调用 &lt;code&gt;add(String)&lt;/code&gt; 或 &lt;code&gt;set(int, String)&lt;/code&gt; ），而如果您调用在 &lt;code&gt;List&amp;lt;T&amp;gt;&lt;/code&gt; 中返回 &lt;code&gt;T&lt;/code&gt; 的 &lt;code&gt;Object&lt;/code&gt; ，则不会得到 &lt;code&gt;String&lt;/code&gt; ，而是Object。</target>
        </trans-unit>
        <trans-unit id="86eeb4f1664e3df8b781582839802549edf89327" translate="yes" xml:space="preserve">
          <source>The layout of a Kotlin multiplatform project is constructed out of the following building blocks:</source>
          <target state="translated">Kotlin多平台项目的布局是由以下构件构成的。</target>
        </trans-unit>
        <trans-unit id="dc4b69a6e38939f4509626db77c33dd8c679086f" translate="yes" xml:space="preserve">
          <source>The least significant 16 bits of the resulting &lt;code&gt;Int&lt;/code&gt; value are the same as the bits of this &lt;code&gt;Short&lt;/code&gt; value, whereas the most significant 16 bits are filled with the sign bit of this value.</source>
          <target state="translated">结果 &lt;code&gt;Int&lt;/code&gt; 值的最低16位与该 &lt;code&gt;Short&lt;/code&gt; 值的位相同，而最高16位用该值的符号位填充。</target>
        </trans-unit>
        <trans-unit id="4f0f34d38c4a4771a59f6d35fcaf5f32f9d5a113" translate="yes" xml:space="preserve">
          <source>The least significant 16 bits of the resulting &lt;code&gt;Int&lt;/code&gt; value are the same as the bits of this &lt;code&gt;UShort&lt;/code&gt; value, whereas the most significant 16 bits are filled with zeros.</source>
          <target state="translated">结果 &lt;code&gt;Int&lt;/code&gt; 值的最低16位与此 &lt;code&gt;UShort&lt;/code&gt; 值的位相同，而最高16位用零填充。</target>
        </trans-unit>
        <trans-unit id="db7d64a40964cbcc91041fe9c6abd3a6f883ba7c" translate="yes" xml:space="preserve">
          <source>The least significant 16 bits of the resulting &lt;code&gt;Long&lt;/code&gt; value are the same as the bits of this &lt;code&gt;Short&lt;/code&gt; value, whereas the most significant 48 bits are filled with the sign bit of this value.</source>
          <target state="translated">结果 &lt;code&gt;Long&lt;/code&gt; 值的最低有效16位与此 &lt;code&gt;Short&lt;/code&gt; 值的相同，而最高48位则用此值的符号位填充。</target>
        </trans-unit>
        <trans-unit id="96755580626f22c0780c08fafc24e52c9efd9ea9" translate="yes" xml:space="preserve">
          <source>The least significant 16 bits of the resulting &lt;code&gt;Long&lt;/code&gt; value are the same as the bits of this &lt;code&gt;UShort&lt;/code&gt; value, whereas the most significant 48 bits are filled with zeros.</source>
          <target state="translated">结果 &lt;code&gt;Long&lt;/code&gt; 值的最低有效16位与此 &lt;code&gt;UShort&lt;/code&gt; 值的位相同，而最高有效48位用零填充。</target>
        </trans-unit>
        <trans-unit id="805e1d578ae5895787cd7c80c9a6f84d9875cbdf" translate="yes" xml:space="preserve">
          <source>The least significant 16 bits of the resulting &lt;code&gt;UInt&lt;/code&gt; value are the same as the bits of this &lt;code&gt;Short&lt;/code&gt; value, whereas the most significant 16 bits are filled with the sign bit of this value.</source>
          <target state="translated">所得的 &lt;code&gt;UInt&lt;/code&gt; 值的最低有效16位与该 &lt;code&gt;Short&lt;/code&gt; 值的位相同，而最高有效的16位用该值的符号位填充。</target>
        </trans-unit>
        <trans-unit id="e2d7f90749fa8a275417e31e2a951b621f7bdd7e" translate="yes" xml:space="preserve">
          <source>The least significant 16 bits of the resulting &lt;code&gt;UInt&lt;/code&gt; value are the same as the bits of this &lt;code&gt;UShort&lt;/code&gt; value, whereas the most significant 16 bits are filled with zeros.</source>
          <target state="translated">所得 &lt;code&gt;UInt&lt;/code&gt; 值的最低有效16位与此 &lt;code&gt;UShort&lt;/code&gt; 值的位相同，而最高有效16位用零填充。</target>
        </trans-unit>
        <trans-unit id="382a5532019e821cafc1c9ca21454b43f1f91a60" translate="yes" xml:space="preserve">
          <source>The least significant 16 bits of the resulting &lt;code&gt;ULong&lt;/code&gt; value are the same as the bits of this &lt;code&gt;Short&lt;/code&gt; value, whereas the most significant 48 bits are filled with the sign bit of this value.</source>
          <target state="translated">得到的 &lt;code&gt;ULong&lt;/code&gt; 值的最低有效16位与该 &lt;code&gt;Short&lt;/code&gt; 值的位相同，而最高有效48位用该值的符号位填充。</target>
        </trans-unit>
        <trans-unit id="98d7b8a419dc2e1a1e55aeb89fee5123de4a6b5e" translate="yes" xml:space="preserve">
          <source>The least significant 16 bits of the resulting &lt;code&gt;ULong&lt;/code&gt; value are the same as the bits of this &lt;code&gt;UShort&lt;/code&gt; value, whereas the most significant 48 bits are filled with zeros.</source>
          <target state="translated">得到的 &lt;code&gt;ULong&lt;/code&gt; 值的最低有效16位与此 &lt;code&gt;UShort&lt;/code&gt; 值的位相同，而最高有效的48位用零填充。</target>
        </trans-unit>
        <trans-unit id="b511f5bcb1b166f6a21672ecd3a364142d43ef6e" translate="yes" xml:space="preserve">
          <source>The least significant 32 bits of the resulting &lt;code&gt;Long&lt;/code&gt; value are the same as the bits of this &lt;code&gt;Int&lt;/code&gt; value, whereas the most significant 32 bits are filled with the sign bit of this value.</source>
          <target state="translated">结果 &lt;code&gt;Long&lt;/code&gt; 值的最低有效32位与此 &lt;code&gt;Int&lt;/code&gt; 值的位相同，而最高有效32位则用此值的符号位填充。</target>
        </trans-unit>
        <trans-unit id="8552752324805690a09e930c3347d0b3b76fb45a" translate="yes" xml:space="preserve">
          <source>The least significant 32 bits of the resulting &lt;code&gt;Long&lt;/code&gt; value are the same as the bits of this &lt;code&gt;UInt&lt;/code&gt; value, whereas the most significant 32 bits are filled with zeros.</source>
          <target state="translated">得到的 &lt;code&gt;Long&lt;/code&gt; 值的最低有效32位与此 &lt;code&gt;UInt&lt;/code&gt; 值的位相同，而最高有效32位用零填充。</target>
        </trans-unit>
        <trans-unit id="13513c5d8d4b778bf7d2d02871ec67b342f92eb3" translate="yes" xml:space="preserve">
          <source>The least significant 32 bits of the resulting &lt;code&gt;ULong&lt;/code&gt; value are the same as the bits of this &lt;code&gt;Int&lt;/code&gt; value, whereas the most significant 32 bits are filled with the sign bit of this value.</source>
          <target state="translated">得到的 &lt;code&gt;ULong&lt;/code&gt; 值的最低有效32位与此 &lt;code&gt;Int&lt;/code&gt; 值的位相同，而最高有效32位则用该值的符号位填充。</target>
        </trans-unit>
        <trans-unit id="098196788f072e1b90241673f7cd1c8d4ddc487e" translate="yes" xml:space="preserve">
          <source>The least significant 32 bits of the resulting &lt;code&gt;ULong&lt;/code&gt; value are the same as the bits of this &lt;code&gt;UInt&lt;/code&gt; value, whereas the most significant 32 bits are filled with zeros.</source>
          <target state="translated">得到的 &lt;code&gt;ULong&lt;/code&gt; 值的最低有效32位与此 &lt;code&gt;UInt&lt;/code&gt; 值的位相同，而最高有效32位用零填充。</target>
        </trans-unit>
        <trans-unit id="1e95934eab4e475329950f2eb8e7a3a03516b89c" translate="yes" xml:space="preserve">
          <source>The least significant 8 bits of the resulting &lt;code&gt;Char&lt;/code&gt; code are the same as the bits of this &lt;code&gt;Byte&lt;/code&gt; value, whereas the most significant 8 bits are filled with the sign bit of this value.</source>
          <target state="translated">所得 &lt;code&gt;Char&lt;/code&gt; 代码的最低有效8位与此 &lt;code&gt;Byte&lt;/code&gt; 值的位相同，而最高有效8位用此值的符号位填充。</target>
        </trans-unit>
        <trans-unit id="1ccfa3d5b3f0d4c2cadb8ddee394a5e74b7f3fb0" translate="yes" xml:space="preserve">
          <source>The least significant 8 bits of the resulting &lt;code&gt;Int&lt;/code&gt; value are the same as the bits of this &lt;code&gt;Byte&lt;/code&gt; value, whereas the most significant 24 bits are filled with the sign bit of this value.</source>
          <target state="translated">结果 &lt;code&gt;Int&lt;/code&gt; 值的最低有效8位与此 &lt;code&gt;Byte&lt;/code&gt; 值的位相同，而最高有效的24位则用此值的符号位填充。</target>
        </trans-unit>
        <trans-unit id="682e9bb2df532a75f2a73fb4a8682c3fe53c3f6f" translate="yes" xml:space="preserve">
          <source>The least significant 8 bits of the resulting &lt;code&gt;Int&lt;/code&gt; value are the same as the bits of this &lt;code&gt;UByte&lt;/code&gt; value, whereas the most significant 24 bits are filled with zeros.</source>
          <target state="translated">结果 &lt;code&gt;Int&lt;/code&gt; 值的最低有效8位与此 &lt;code&gt;UByte&lt;/code&gt; 值的位相同，而最高有效的24位用零填充。</target>
        </trans-unit>
        <trans-unit id="740b8988c3d828c3ba10680439510f32d7f08bd4" translate="yes" xml:space="preserve">
          <source>The least significant 8 bits of the resulting &lt;code&gt;Long&lt;/code&gt; value are the same as the bits of this &lt;code&gt;Byte&lt;/code&gt; value, whereas the most significant 56 bits are filled with the sign bit of this value.</source>
          <target state="translated">结果 &lt;code&gt;Long&lt;/code&gt; 值的最低有效8位与此 &lt;code&gt;Byte&lt;/code&gt; 值的位相同，而最高有效56位用此值的符号位填充。</target>
        </trans-unit>
        <trans-unit id="f2986e4bdb9623eb7b0be806904f6c45008e66a1" translate="yes" xml:space="preserve">
          <source>The least significant 8 bits of the resulting &lt;code&gt;Long&lt;/code&gt; value are the same as the bits of this &lt;code&gt;UByte&lt;/code&gt; value, whereas the most significant 56 bits are filled with zeros.</source>
          <target state="translated">结果 &lt;code&gt;Long&lt;/code&gt; 值的最低有效8位与此 &lt;code&gt;UByte&lt;/code&gt; 值的位相同，而最高有效56位用零填充。</target>
        </trans-unit>
        <trans-unit id="da411f42fa8b3bbe7fd6d9ed1a7edbedcead90c8" translate="yes" xml:space="preserve">
          <source>The least significant 8 bits of the resulting &lt;code&gt;Short&lt;/code&gt; value are the same as the bits of this &lt;code&gt;Byte&lt;/code&gt; value, whereas the most significant 8 bits are filled with the sign bit of this value.</source>
          <target state="translated">结果的 &lt;code&gt;Short&lt;/code&gt; 值的最低有效8位与此 &lt;code&gt;Byte&lt;/code&gt; 值的位相同，而最高有效8位则用此值的符号位填充。</target>
        </trans-unit>
        <trans-unit id="dbca88370b969aea0b645fa67d458151bf144ef3" translate="yes" xml:space="preserve">
          <source>The least significant 8 bits of the resulting &lt;code&gt;Short&lt;/code&gt; value are the same as the bits of this &lt;code&gt;UByte&lt;/code&gt; value, whereas the most significant 8 bits are filled with zeros.</source>
          <target state="translated">结果的 &lt;code&gt;Short&lt;/code&gt; 值的最低有效8位与此 &lt;code&gt;UByte&lt;/code&gt; 值的位相同，而最高有效8位用零填充。</target>
        </trans-unit>
        <trans-unit id="0705f7403c9d4340ca48e777c703d467c71d6c8f" translate="yes" xml:space="preserve">
          <source>The least significant 8 bits of the resulting &lt;code&gt;UInt&lt;/code&gt; value are the same as the bits of this &lt;code&gt;Byte&lt;/code&gt; value, whereas the most significant 24 bits are filled with the sign bit of this value.</source>
          <target state="translated">结果 &lt;code&gt;UInt&lt;/code&gt; 值的最低有效8位与该 &lt;code&gt;Byte&lt;/code&gt; 值的位相同，而最高有效的24位用该值的符号位填充。</target>
        </trans-unit>
        <trans-unit id="e35a3b71a791931b3596ab2bd1edb46d9365dda1" translate="yes" xml:space="preserve">
          <source>The least significant 8 bits of the resulting &lt;code&gt;UInt&lt;/code&gt; value are the same as the bits of this &lt;code&gt;UByte&lt;/code&gt; value, whereas the most significant 24 bits are filled with zeros.</source>
          <target state="translated">结果 &lt;code&gt;UInt&lt;/code&gt; 值的最低有效8位与此 &lt;code&gt;UByte&lt;/code&gt; 值的位相同，而最高有效的24位用零填充。</target>
        </trans-unit>
        <trans-unit id="fbe359060636f5088c741be0b327d7d46254bbcd" translate="yes" xml:space="preserve">
          <source>The least significant 8 bits of the resulting &lt;code&gt;ULong&lt;/code&gt; value are the same as the bits of this &lt;code&gt;Byte&lt;/code&gt; value, whereas the most significant 56 bits are filled with the sign bit of this value.</source>
          <target state="translated">得到的 &lt;code&gt;ULong&lt;/code&gt; 值的最低有效8位与该 &lt;code&gt;Byte&lt;/code&gt; 值的位相同，而最高有效56位用该值的符号位填充。</target>
        </trans-unit>
        <trans-unit id="9d9c37d2ab226e9ed58e44937eac9a5c2afe8841" translate="yes" xml:space="preserve">
          <source>The least significant 8 bits of the resulting &lt;code&gt;ULong&lt;/code&gt; value are the same as the bits of this &lt;code&gt;UByte&lt;/code&gt; value, whereas the most significant 56 bits are filled with zeros.</source>
          <target state="translated">得到的 &lt;code&gt;ULong&lt;/code&gt; 值的最低有效8位与此 &lt;code&gt;UByte&lt;/code&gt; 值的位相同，而最高有效56位用零填充。</target>
        </trans-unit>
        <trans-unit id="573a497b93bab09d8947aa89f58fd5f36237628f" translate="yes" xml:space="preserve">
          <source>The least significant 8 bits of the resulting &lt;code&gt;UShort&lt;/code&gt; value are the same as the bits of this &lt;code&gt;Byte&lt;/code&gt; value, whereas the most significant 8 bits are filled with the sign bit of this value.</source>
          <target state="translated">结果 &lt;code&gt;UShort&lt;/code&gt; 值的最低有效8位与此 &lt;code&gt;Byte&lt;/code&gt; 值的位相同，而最高有效的8位则用该值的符号位填充。</target>
        </trans-unit>
        <trans-unit id="d49f6edce25857427bee05e2a6463c8f203f6aab" translate="yes" xml:space="preserve">
          <source>The least significant 8 bits of the resulting &lt;code&gt;UShort&lt;/code&gt; value are the same as the bits of this &lt;code&gt;UByte&lt;/code&gt; value, whereas the most significant 8 bits are filled with zeros.</source>
          <target state="translated">所得的 &lt;code&gt;UShort&lt;/code&gt; 值的最低有效8位与此 &lt;code&gt;UByte&lt;/code&gt; 值的位相同，而最高有效8位用零填充。</target>
        </trans-unit>
        <trans-unit id="1511f8695777128c7450dc6f9cc52fbdbfc512c7" translate="yes" xml:space="preserve">
          <source>The less obvious cases that belong to the &quot;grey area&quot; include handling corner cases differently, throwing an exception of a different type than before, changing behavior observable only through reflection, changes in undocumented/undefined behavior, renaming binary artifacts, etc. Sometimes such changes are very important and affect migration experience dramatically, sometimes they are insignificant.</source>
          <target state="translated">属于 &quot;灰色地带 &quot;的不太明显的情况包括:以不同的方式处理转角情况、抛出与之前不同类型的异常、改变只有通过反射才能观察到的行为、改变未记录/未定义的行为、重命名二进制工件等。有时这样的改变非常重要,会极大地影响迁移体验,有时则微不足道。</target>
        </trans-unit>
        <trans-unit id="dd894256ff253457e13d98fae75ab576481e876c" translate="yes" xml:space="preserve">
          <source>The library format</source>
          <target state="translated">图书馆格式</target>
        </trans-unit>
        <trans-unit id="c48fdef888f67d5a66f513cae58be8d045c058e0" translate="yes" xml:space="preserve">
          <source>The library has been created in the current directory:</source>
          <target state="translated">库已经在当前目录下创建。</target>
        </trans-unit>
        <trans-unit id="cff219119dad603b83453d082db1d0aa5cce3800" translate="yes" xml:space="preserve">
          <source>The lines returned do not include terminating line separators.</source>
          <target state="translated">返回的行数不包括终止行的分隔符。</target>
        </trans-unit>
        <trans-unit id="0ec3834f8762f850d976d74a3444d0d24d17d417" translate="yes" xml:space="preserve">
          <source>The list is expected to be sorted so that the signs of the &lt;a href=&quot;binary-search#kotlin.collections%24binarySearch(kotlin.collections.List((kotlin.collections.binarySearch.T)),%20kotlin.Int,%20kotlin.Int,%20kotlin.Function1((kotlin.collections.binarySearch.T,%20kotlin.Int)))/comparison&quot;&gt;comparison&lt;/a&gt; function's return values ascend on the list elements, i.e. negative values come before zero and zeroes come before positive values. Otherwise, the result is undefined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ecc031fda17a51efc3a0c6e7f3483a236bf69e52" translate="yes" xml:space="preserve">
          <source>The list of immediate supertypes of this class, in the order they are listed in the source code.</source>
          <target state="translated">该类的直属超类型列表,按照源代码中的顺序排列。</target>
        </trans-unit>
        <trans-unit id="37daaa29c5ab04c74e60f96a3c80a72671943c78" translate="yes" xml:space="preserve">
          <source>The list of possible time measurement units, in which a duration can be expressed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7cfcc4e5ebb2fa63d0c44bdcf02351c03c9e8d4" translate="yes" xml:space="preserve">
          <source>The list of the immediate subclasses if this class is a sealed class, or an empty list otherwise.</source>
          <target state="translated">如果这个类是一个密封的类,则直接子类的列表,否则为空列表。</target>
        </trans-unit>
        <trans-unit id="af028a3423820dfb61266857373312e6321072a9" translate="yes" xml:space="preserve">
          <source>The list of type parameters of this callable.</source>
          <target state="translated">该callable的类型参数列表。</target>
        </trans-unit>
        <trans-unit id="3983145b3c17efebd4ca1c3dd6839e784929aaa8" translate="yes" xml:space="preserve">
          <source>The list of type parameters of this class. This list does &lt;em&gt;not&lt;/em&gt; include type parameters of outer classes.</source>
          <target state="translated">此类的类型参数的列表。这份名单并&lt;em&gt;没有&lt;/em&gt;包括外部类的类型参数。</target>
        </trans-unit>
        <trans-unit id="7dd6f3d5d8e8c83c9d11a7ed45e7362cc872b1a5" translate="yes" xml:space="preserve">
          <source>The locking in this example is fine-grained, so it pays the price. However, it is a good choice for some situations where you absolutely must modify some shared state periodically, but there is no natural thread that this state is confined to.</source>
          <target state="translated">这个例子中的锁是细粒度的,所以它要付出代价。然而,对于某些情况来说,它是一个很好的选择,在这些情况下,你绝对必须周期性地修改一些共享状态,但没有一个自然线程可以限制这个状态。</target>
        </trans-unit>
        <trans-unit id="993a245cc6dcc5a6d2356a7f7d1259d26b6ea137" translate="yes" xml:space="preserve">
          <source>The loop variable(s), if any, must be declared outside of the &lt;code&gt;while&lt;/code&gt; loop, and are therefore available for inspection afterwards, at which point they will contain the value(s) that made the loop condition false.</source>
          <target state="translated">循环变量（如果有）必须在 &lt;code&gt;while&lt;/code&gt; 循环外声明，因此可以在以后检查，此时它们将包含使循环条件为假的值。</target>
        </trans-unit>
        <trans-unit id="f10abe77e5b16e3b7aa73cabd19e9ac919e5868d" translate="yes" xml:space="preserve">
          <source>The main code is straightforward:</source>
          <target state="translated">主代码简单明了。</target>
        </trans-unit>
        <trans-unit id="21b17843ae6bab256e1f2d7c26e40966048480db" translate="yes" xml:space="preserve">
          <source>The main code starts and connects the whole pipeline:</source>
          <target state="translated">主代码启动并连接整个管道。</target>
        </trans-unit>
        <trans-unit id="1415e580114f63d99c0e8622a1104c3c733c68ba" translate="yes" xml:space="preserve">
          <source>The main disadvantage of changing the code style in an existing project is that the blame/annotate VCS feature will point to irrelevant commits more often. While each VCS has some kind of way to deal with this problem (&lt;a href=&quot;https://www.jetbrains.com/help/idea/investigate-changes.html&quot;&gt;&quot;Annotate Previous Revision&quot;&lt;/a&gt; can be used in IntelliJ IDEA), it's important to decide if a new style is worth all the effort. The practice of separating reformatting commits from meaningful changes can help a lot with later investigations.</source>
          <target state="translated">更改现有项目中的代码样式的主要缺点是，怪怪/注释VCS功能将更频繁地指向无关的提交。尽管每个VCS都有某种方法可以解决此问题（IntelliJ IDEA中可以使用&lt;a href=&quot;https://www.jetbrains.com/help/idea/investigate-changes.html&quot;&gt;&amp;ldquo;注释以前的​​修订版&amp;rdquo;&lt;/a&gt;），但重要的是确定新样式是否值得所有努力。将重新格式化提交与有意义的更改分开的做法可为以后的调查提供很大帮助。</target>
        </trans-unit>
        <trans-unit id="f0255c27371bb337a0275ae99c66e66aefbb2cf2" translate="yes" xml:space="preserve">
          <source>The main function just launches a coroutine to print results of &lt;code&gt;switchMapDeferreds&lt;/code&gt; and sends some test data to it:</source>
          <target state="translated">主要功能只是启动协程以打印 &lt;code&gt;switchMapDeferreds&lt;/code&gt; 的结果并将一些测试数据发送给它：</target>
        </trans-unit>
        <trans-unit id="c0a11bc5688f898de97456dfcb543cf05d79b8a1" translate="yes" xml:space="preserve">
          <source>The main thread (that runs the &lt;code&gt;main()&lt;/code&gt; function) must wait until our coroutine completes, otherwise the program ends before &lt;code&gt;Hello&lt;/code&gt; is printed.</source>
          <target state="translated">主线程（运行 &lt;code&gt;main()&lt;/code&gt; 函数）必须等待我们的协程完成，否则程序将在打印 &lt;code&gt;Hello&lt;/code&gt; 之前结束。</target>
        </trans-unit>
        <trans-unit id="2c831066dd6087f2516b15d01bfb68e39b9bcf05" translate="yes" xml:space="preserve">
          <source>The maximum number of substrings to return. Zero by default means no limit is set.</source>
          <target state="translated">要返回的子串的最大数量。默认为零,表示没有设置限制。</target>
        </trans-unit>
        <trans-unit id="4e76f165176d7e28c6b59c285a7ee8af5a71fc72" translate="yes" xml:space="preserve">
          <source>The maximum radix available for conversion to and from strings.</source>
          <target state="translated">字符串转换的最大半径。</target>
        </trans-unit>
        <trans-unit id="38f9246447f2685e9dd36b4c8d7e0bf7ff2fb023" translate="yes" xml:space="preserve">
          <source>The maximum value in the range (inclusive).</source>
          <target state="translated">范围内的最大值(含)。</target>
        </trans-unit>
        <trans-unit id="cc9397547e8b9fc8e2131246f8cce9b80a975147" translate="yes" xml:space="preserve">
          <source>The maximum value of a Unicode code point. Kotlin/Native specific.</source>
          <target state="translated">Unicode码点的最大值。Kotlin/Native特有的。</target>
        </trans-unit>
        <trans-unit id="af496c450bf387c2b7d7ee0dc32c766b9f1b66c1" translate="yes" xml:space="preserve">
          <source>The maximum value of a Unicode high-surrogate code unit.</source>
          <target state="translated">Unicode高代码单位的最大值。</target>
        </trans-unit>
        <trans-unit id="68f9d655dde4db0c3b71fc09c97d0f87e103d52b" translate="yes" xml:space="preserve">
          <source>The maximum value of a Unicode low-surrogate code unit.</source>
          <target state="translated">Unicode低代码单位的最大值。</target>
        </trans-unit>
        <trans-unit id="0cb5887284a08dd04202e0863d133d8ed431392d" translate="yes" xml:space="preserve">
          <source>The maximum value of a Unicode surrogate code unit.</source>
          <target state="translated">Unicode代用码单位的最大值。</target>
        </trans-unit>
        <trans-unit id="ea009c16dc0030623058aff99eec7f7c7973366c" translate="yes" xml:space="preserve">
          <source>The maximum value of a character code unit.</source>
          <target state="translated">一个字符代码单位的最大值。</target>
        </trans-unit>
        <trans-unit id="dce9edb79f3aca5450e6dfb555e231182e2c5340" translate="yes" xml:space="preserve">
          <source>The meaning of a visibility modifier depends on whether it's applied to a top-level declaration or to a declaration inside a class. For top-level declarations:</source>
          <target state="translated">可见性修饰符的含义取决于它是应用于顶层声明还是应用于类中的声明。对于顶层声明。</target>
        </trans-unit>
        <trans-unit id="2f5715d8d7aab68289e0b8a47e46f1764f30f76e" translate="yes" xml:space="preserve">
          <source>The message explaining the deprecation and recommending an alternative API to use.</source>
          <target state="translated">解释弃用的信息,并推荐使用其他API。</target>
        </trans-unit>
        <trans-unit id="1d7af1b2ed876762350f57904a38e801662ebbf4" translate="yes" xml:space="preserve">
          <source>The meta-runner for Kotlin is available on &lt;a href=&quot;https://github.com/jonnyzzz/Kotlin.TeamCity&quot;&gt;GitHub&lt;/a&gt;. If using TeamCity 9 or above, we can now simply import that meta-runner from the TeamCity user interface</source>
          <target state="translated">&lt;a href=&quot;https://github.com/jonnyzzz/Kotlin.TeamCity&quot;&gt;GitHub上&lt;/a&gt;提供了Kotlin的元运行器。如果使用TeamCity 9或更高版本，我们现在可以简单地从TeamCity用户界面导入该元运行器</target>
        </trans-unit>
        <trans-unit id="cbb5d37dc4d790a9dba2a103cd7fc2ea1af9db2f" translate="yes" xml:space="preserve">
          <source>The minimum radix available for conversion to and from strings.</source>
          <target state="translated">可用于转换为字符串和从字符串转换的最小半径。</target>
        </trans-unit>
        <trans-unit id="3eb6b21e0f2a2eb117e5ca90292e6def24614862" translate="yes" xml:space="preserve">
          <source>The minimum value in the range.</source>
          <target state="translated">范围内的最小值。</target>
        </trans-unit>
        <trans-unit id="480df25e783a3ddb0c5eabcc07d40b9a21fd328e" translate="yes" xml:space="preserve">
          <source>The minimum value of a Unicode code point. Kotlin/Native specific.</source>
          <target state="translated">Unicode码点的最小值。Kotlin/Native特有的。</target>
        </trans-unit>
        <trans-unit id="c11b4b4a4cfd50662da801109ced72e7ef8083ad" translate="yes" xml:space="preserve">
          <source>The minimum value of a Unicode high-surrogate code unit.</source>
          <target state="translated">Unicode高代码单位的最小值。</target>
        </trans-unit>
        <trans-unit id="7a57e546e08f3cd66a3ed8cebd57f37a4137a78d" translate="yes" xml:space="preserve">
          <source>The minimum value of a Unicode low-surrogate code unit.</source>
          <target state="translated">Unicode低代码单位的最小值。</target>
        </trans-unit>
        <trans-unit id="47b523f1a39e9c9f7bda17fc85b300ab3e0da311" translate="yes" xml:space="preserve">
          <source>The minimum value of a Unicode surrogate code unit.</source>
          <target state="translated">Unicode代用码单位的最小值。</target>
        </trans-unit>
        <trans-unit id="e3fc4d1ab4988e695801daf57bd33d3f470c3668" translate="yes" xml:space="preserve">
          <source>The minimum value of a character code unit.</source>
          <target state="translated">一个字符代码单位的最小值。</target>
        </trans-unit>
        <trans-unit id="d80a9d6c0ddeb1216ece2df4cc2d7d63382408e4" translate="yes" xml:space="preserve">
          <source>The minimum value of a supplementary code point, &lt;code&gt;\u0x10000&lt;/code&gt;. Kotlin/Native specific.</source>
          <target state="translated">补充代码点的最小值 &lt;code&gt;\u0x10000&lt;/code&gt; 。Kotlin /本机特定。</target>
        </trans-unit>
        <trans-unit id="39042f06ab046e1bfc15de4ecf52d5a28eec3294" translate="yes" xml:space="preserve">
          <source>The modifier can be used on &lt;code&gt;var&lt;/code&gt; properties declared inside the body of a class (not in the primary constructor, and only when the property does not have a custom getter or setter) and, since Kotlin 1.2, for top-level properties and local variables. The type of the property or variable must be non-null, and it must not be a primitive type.</source>
          <target state="translated">修饰符可用于在类主体内声明的 &lt;code&gt;var&lt;/code&gt; 属性（不适用于主构造函数，并且仅在该属性没有自定义getter或setter时），并且自Kotlin 1.2起，用于顶级属性和局部变量。属性或变量的类型必须为非null，并且不能为原始类型。</target>
        </trans-unit>
        <trans-unit id="bb919d11f95900a1425b0a32e4257389d1fc669f" translate="yes" xml:space="preserve">
          <source>The most &quot;natural&quot; placement is in the object &lt;code&gt;nativeHeap&lt;/code&gt;. It corresponds to allocating native memory with &lt;code&gt;malloc&lt;/code&gt; and provides an additional &lt;code&gt;.free()&lt;/code&gt; operation to free allocated memory:</source>
          <target state="translated">最&amp;ldquo;自然&amp;rdquo;的放置在对象 &lt;code&gt;nativeHeap&lt;/code&gt; 中。它对应于使用 &lt;code&gt;malloc&lt;/code&gt; 分配本机内存，并提供了附加的 &lt;code&gt;.free()&lt;/code&gt; 操作来释放已分配的内存：</target>
        </trans-unit>
        <trans-unit id="0d14eba091c54d0c22e0562741651e98077e032c" translate="yes" xml:space="preserve">
          <source>The most basic reflection feature is getting the runtime reference to a Kotlin class. To obtain the reference to a statically known Kotlin class, you can use the &lt;em&gt;class literal&lt;/em&gt; syntax:</source>
          <target state="translated">最基本的反射功能是获取对Kotlin类的运行时引用。要获取对静态已知的Kotlin类的引用，可以使用&lt;em&gt;类文字&lt;/em&gt;语法：</target>
        </trans-unit>
        <trans-unit id="ae0dbb4ff6b4fc6cc9b694111494978916ff6daf" translate="yes" xml:space="preserve">
          <source>The most basic usage of enum classes is implementing type-safe enums:</source>
          <target state="translated">枚举类最基本的用法是实现类型安全的枚举。</target>
        </trans-unit>
        <trans-unit id="564a165b2993e039b868e117559d08b7cdc98e88" translate="yes" xml:space="preserve">
          <source>The most common kind of properties simply reads from (and maybe writes to) a backing field. On the other hand, with custom getters and setters one can implement any behaviour of a property. Somewhere in between, there are certain common patterns of how a property may work. A few examples: lazy values, reading from a map by a given key, accessing a database, notifying listener on access, etc.</source>
          <target state="translated">最常见的属性只是简单地从一个后备字段读取(也许还可以写入)。另一方面,通过自定义的getter和setter,可以实现属性的任何行为。在这两者之间,有一些常见的属性工作模式。几个例子:懒惰值、通过给定的键从地图中读取、访问数据库、在访问时通知监听器等等。</target>
        </trans-unit>
        <trans-unit id="d5cbdfb8e81de653dd867a75b87523ff1d242141" translate="yes" xml:space="preserve">
          <source>The most common type of constraint is an &lt;strong&gt;upper bound&lt;/strong&gt; that corresponds to Java's &lt;em&gt;extends&lt;/em&gt; keyword:</source>
          <target state="translated">最常见的约束类型是与Java的&lt;em&gt;extends&lt;/em&gt;关键字相对应的&lt;strong&gt;上限&lt;/strong&gt;：&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="368d747cfcb5fb4e353c85a7469dfacbb5453495" translate="yes" xml:space="preserve">
          <source>The most common way to create a collection is with the standard library functions &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/list-of&quot;&gt;&lt;code&gt;listOf&amp;lt;T&amp;gt;()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/set-of&quot;&gt;&lt;code&gt;setOf&amp;lt;T&amp;gt;()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/mutable-list-of&quot;&gt;&lt;code&gt;mutableListOf&amp;lt;T&amp;gt;()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/mutable-set-of&quot;&gt;&lt;code&gt;mutableSetOf&amp;lt;T&amp;gt;()&lt;/code&gt;&lt;/a&gt;. If you provide a comma-separated list of collection elements as arguments, the compiler detects the element type automatically. When creating empty collections, specify the type explicitly.</source>
          <target state="translated">创建集合的最常见方法是使用标准库函数&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/list-of&quot;&gt; &lt;code&gt;listOf&amp;lt;T&amp;gt;()&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/set-of&quot;&gt; &lt;code&gt;setOf&amp;lt;T&amp;gt;()&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/mutable-list-of&quot;&gt; &lt;code&gt;mutableListOf&amp;lt;T&amp;gt;()&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/mutable-set-of&quot;&gt; &lt;code&gt;mutableSetOf&amp;lt;T&amp;gt;()&lt;/code&gt; &lt;/a&gt;。如果提供逗号分隔的集合元素列表作为参数，则编译器将自动检测元素类型。创建空集合时，请明确指定类型。</target>
        </trans-unit>
        <trans-unit id="b853cf446ccffab0ecfd031a6ec9cd9f7555703c" translate="yes" xml:space="preserve">
          <source>The most notable change is in the continuation indentation policy. There's a nice idea to use the double indent for showing that a multi-line expression hasn't ended on the previous line. This is a very simple and general rule, but several Kotlin constructions look a bit awkward when they are formatted this way. In Kotlin Coding Conventions it's recommended to use a single indent in cases where the long continuation indent has been forced before</source>
          <target state="translated">最显著的变化是延续缩进政策。有一个很好的想法,就是使用双缩进来显示多行表达式没有在前一行结束。这是一个非常简单和通用的规则,但有几个Kotlin结构在采用这种格式时看起来有点尴尬。在 Kotlin 编码规范中,建议在长的延续缩进之前被强制缩进的情况下,使用单缩进。</target>
        </trans-unit>
        <trans-unit id="e8c58687aab400a3400843ec6513c56c72bdb694" translate="yes" xml:space="preserve">
          <source>The most obvious practical reason to cancel execution of a coroutine is because its execution time has exceeded some timeout. While you can manually track the reference to the corresponding &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/index.html&quot;&gt;Job&lt;/a&gt; and launch a separate coroutine to cancel the tracked one after delay, there is a ready to use &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/with-timeout.html&quot;&gt;withTimeout&lt;/a&gt; function that does it. Look at the following example:</source>
          <target state="translated">取消协程执行的最明显的实际原因是因为协程的执行时间已超过某个超时。虽然您可以手动跟踪对相应&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/index.html&quot;&gt;Job&lt;/a&gt;的引用并启动一个单独的协程以在延迟后取消所跟踪的协程，但是可以使用&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/with-timeout.html&quot;&gt;withTimeout&lt;/a&gt;函数来执行此操作。看下面的例子：</target>
        </trans-unit>
        <trans-unit id="d08f23af81c5dad7c4dca8d8027b602b0ab864b4" translate="yes" xml:space="preserve">
          <source>The most peculiar feature of &lt;code&gt;dynamic&lt;/code&gt; is that we are allowed to call &lt;strong&gt;any&lt;/strong&gt; property or function with any parameters on a &lt;code&gt;dynamic&lt;/code&gt; variable:</source>
          <target state="translated">&lt;code&gt;dynamic&lt;/code&gt; 的最独特的功能是允许我们使用 &lt;code&gt;dynamic&lt;/code&gt; 变量上的任何参数调用&lt;strong&gt;任何&lt;/strong&gt;属性或函数：</target>
        </trans-unit>
        <trans-unit id="3c05df95cb8e9db1a4f2601246ac944d5c8bd276" translate="yes" xml:space="preserve">
          <source>The multiplatform projects and multiplatform libraries are discussed in the &lt;a href=&quot;../../reference/multiplatform&quot;&gt;documentation&lt;/a&gt; too.</source>
          <target state="translated">&lt;a href=&quot;../../reference/multiplatform&quot;&gt;文档中&lt;/a&gt;还讨论了多平台项目和多平台库。</target>
        </trans-unit>
        <trans-unit id="6595e5fe1547363b463835d421622aad398ae9cc" translate="yes" xml:space="preserve">
          <source>The name contains the following parts (some of them may be empty):</source>
          <target state="translated">该名称包含以下部分(其中一些可能是空的):</target>
        </trans-unit>
        <trans-unit id="705b141c8de1d697224950845ea5a1b7afb58d54" translate="yes" xml:space="preserve">
          <source>The name of a class is usually a noun or a noun phrase explaining what the class &lt;em&gt;is&lt;/em&gt;: &lt;code&gt;List&lt;/code&gt;, &lt;code&gt;PersonReader&lt;/code&gt;.</source>
          <target state="translated">一个类的名称通常是一个名词或名词短语，用以解释该类&lt;em&gt;是&lt;/em&gt;什么： &lt;code&gt;List&lt;/code&gt; ， &lt;code&gt;PersonReader&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2218455df585d83e3681475aae4631f54b57ae59" translate="yes" xml:space="preserve">
          <source>The name of a class used by itself (not as a qualifier to another name) acts as a reference to the companion object of the class (whether named or not):</source>
          <target state="translated">一个类的名字本身使用(不是作为另一个名字的限定词),作为对该类的同伴对象(无论是否命名)的引用。</target>
        </trans-unit>
        <trans-unit id="07fe46086dbe239fd375c49037bb37bff00ee0c4" translate="yes" xml:space="preserve">
          <source>The name of a method is usually a verb or a verb phrase saying what the method &lt;em&gt;does&lt;/em&gt;: &lt;code&gt;close&lt;/code&gt;, &lt;code&gt;readPersons&lt;/code&gt;. The name should also suggest if the method is mutating the object or returning a new one. For instance &lt;code&gt;sort&lt;/code&gt; is sorting a collection in place, while &lt;code&gt;sorted&lt;/code&gt; is returning a sorted copy of the collection.</source>
          <target state="translated">方法的名称通常是动词或动词短语，表示方法的&lt;em&gt;作用&lt;/em&gt;： &lt;code&gt;close&lt;/code&gt; ， &lt;code&gt;readPersons&lt;/code&gt; 。该名称还应该建议该方法是在改变对象还是返回一个新对象。例如 &lt;code&gt;sort&lt;/code&gt; 是对集合进行 &lt;code&gt;sorted&lt;/code&gt; ，而sorted返回集合的排序副本。</target>
        </trans-unit>
        <trans-unit id="07c434a5d635392f2cc52f562338d62b0cd9ae9a" translate="yes" xml:space="preserve">
          <source>The name of the companion object can be omitted, in which case the name &lt;code&gt;Companion&lt;/code&gt; will be used:</source>
          <target state="translated">可以省略伴随对象的名称，在这种情况下，将使用名称 &lt;code&gt;Companion&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="ba35193d0490ae1490a81583acf93693abaa382e" translate="yes" xml:space="preserve">
          <source>The name of the file should describe what the code in the file does. Therefore, you should avoid using meaningless words such as &quot;Util&quot; in file names.</source>
          <target state="translated">文件的名称应该描述文件中的代码的作用。因此,你应该避免在文件名中使用 &quot;Util &quot;等无意义的词语。</target>
        </trans-unit>
        <trans-unit id="3aecf5d5ce4130f99667312567cec868e0f727ee" translate="yes" xml:space="preserve">
          <source>The name of the generated Java class can be changed using the &lt;code&gt;@JvmName&lt;/code&gt; annotation:</source>
          <target state="translated">可以使用 &lt;code&gt;@JvmName&lt;/code&gt; 批注来更改生成的Java类的名称：</target>
        </trans-unit>
        <trans-unit id="c5f1bfd2676f7023c48bd8f681608f158236c940" translate="yes" xml:space="preserve">
          <source>The name of the target (if specified) or the project</source>
          <target state="translated">目标名称(如果指定)或项目名称</target>
        </trans-unit>
        <trans-unit id="cbba3c187c456ab45b79f8154b1183097b8b2546" translate="yes" xml:space="preserve">
          <source>The name of this callable as it was declared in the source code. If the callable has no name, a special invented name is created. Nameless callables include:</source>
          <target state="translated">这个可调用的名称,因为它是在源代码中声明的。如果该可调用项没有名称,则会创建一个特殊的发明名称。无名可调用包括:</target>
        </trans-unit>
        <trans-unit id="688bb052b4a717479ab8663cafb721fc37d4378a" translate="yes" xml:space="preserve">
          <source>The name of this type parameter as it was declared in the source code.</source>
          <target state="translated">源代码中声明的该类型参数的名称。</target>
        </trans-unit>
        <trans-unit id="25f073ea1bd96da303a6eb4e8f3418d2fb774887" translate="yes" xml:space="preserve">
          <source>The names of Kotlin classes and interfaces are prefixed when imported to Objective-C. The prefix is derived from the framework name.</source>
          <target state="translated">Kotlin类和接口的名称在导入到Objective-C时是有前缀的。这个前缀是由框架名称衍生出来的。</target>
        </trans-unit>
        <trans-unit id="69675486a4053839ac9b38d8b7b0c3ec7c01c08b" translate="yes" xml:space="preserve">
          <source>The names of the tasks in Android Projects contain the &lt;a href=&quot;https://developer.android.com/studio/build/build-variants.html&quot;&gt;build variant&lt;/a&gt; names and follow the pattern &lt;code&gt;compile&amp;lt;BuildVariant&amp;gt;Kotlin&lt;/code&gt;, for example, &lt;code&gt;compileDebugKotlin&lt;/code&gt;, &lt;code&gt;compileReleaseUnitTestKotlin&lt;/code&gt;.</source>
          <target state="translated">Android项目中的任务名称包含&lt;a href=&quot;https://developer.android.com/studio/build/build-variants.html&quot;&gt;构建变体&lt;/a&gt;名称，并遵循模式 &lt;code&gt;compile&amp;lt;BuildVariant&amp;gt;Kotlin&lt;/code&gt; ，例如 &lt;code&gt;compileDebugKotlin&lt;/code&gt; ， &lt;code&gt;compileReleaseUnitTestKotlin&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b01e22b1729a53f5c38e9b03b567bbe208d510c5" translate="yes" xml:space="preserve">
          <source>The names of these tasks were created from the formula: &lt;code&gt;run[Debug|Release]Executable&amp;lt;target name&amp;gt;&lt;/code&gt;, where &lt;code&gt;target name&lt;/code&gt; is the capitalized target name that we specified in the &lt;code&gt;build.gradle.kts&lt;/code&gt;&lt;code&gt;build.gradle&lt;/code&gt; file out of our build, &lt;code&gt;&quot;native&quot;&lt;/code&gt; in our case. Let's run the task in the IDE. For that, let's open the Gradle Tool Window and find the task in the list:</source>
          <target state="translated">这些任务的名称是根据以下公式创建的： &lt;code&gt;run[Debug|Release]Executable&amp;lt;target name&amp;gt;&lt;/code&gt; ，其中 &lt;code&gt;target name&lt;/code&gt; 是我们在 &lt;code&gt;build.gradle.kts&lt;/code&gt; &lt;code&gt;build.gradle&lt;/code&gt; 文件中从构建中指定的大写目标名称，在我们的案例中为 &lt;code&gt;&quot;native&quot;&lt;/code&gt; 。让我们在IDE中运行任务。为此，让我们打开Gradle Tool窗口并在列表中找到任务：</target>
        </trans-unit>
        <trans-unit id="f0aa5ea5557fedda4c5d2598dc5dd22d0363ac01" translate="yes" xml:space="preserve">
          <source>The names should make it clear what the purpose of the entity is, so it's best to avoid using meaningless words (&lt;code&gt;Manager&lt;/code&gt;, &lt;code&gt;Wrapper&lt;/code&gt; etc.) in names.</source>
          <target state="translated">名称应清楚说明实体的用途，因此最好避免在名称中使用无意义的词（ &lt;code&gt;Manager&lt;/code&gt; ， &lt;code&gt;Wrapper&lt;/code&gt; 等）。</target>
        </trans-unit>
        <trans-unit id="73a31785499746e1755c5fd02e03d5e8b58c34d0" translate="yes" xml:space="preserve">
          <source>The native memory can be allocated using the &lt;code&gt;NativePlacement&lt;/code&gt; interface, e.g.</source>
          <target state="translated">可以使用 &lt;code&gt;NativePlacement&lt;/code&gt; 接口来分配本机内存，例如</target>
        </trans-unit>
        <trans-unit id="183994f4ebd6d698ee09d0ba15ca6b6ca68c9e19" translate="yes" xml:space="preserve">
          <source>The next lines are about providing linker and compiler options, which can vary depending on different target platforms. In our case, we are defining it for macOS (the &lt;code&gt;.osx&lt;/code&gt; suffix) and Linux (the &lt;code&gt;.linux&lt;/code&gt; suffix). Parameters without a suffix is also possible (e.g. &lt;code&gt;linkerOpts=&lt;/code&gt;) and will be applied to all platforms.</source>
          <target state="translated">接下来的几行是关于提供链接器和编译器选项的，这些选项可能会因不同的目标平台而异。在我们的例子中，我们定义它为MacOS（在 &lt;code&gt;.osx&lt;/code&gt; 后缀）和Linux（在 &lt;code&gt;.linux&lt;/code&gt; 后缀）。也可以不带后缀的参数（例如， &lt;code&gt;linkerOpts=&lt;/code&gt; ），并将这些参数应用于所有平台。</target>
        </trans-unit>
        <trans-unit id="5a6c6de321d2f0ef15a3d35472d5a5225a93083f" translate="yes" xml:space="preserve">
          <source>The next part of the &lt;code&gt;&amp;lt;Framework&amp;gt;/Headers/Demo.h&lt;/code&gt; contains number type mappings between Kotlin/Native and &lt;code&gt;NSNumber&lt;/code&gt;. We have the base class called &lt;code&gt;DemoNumber&lt;/code&gt; in Objective-C and &lt;code&gt;KotlinNumber&lt;/code&gt; in Swift. It extends &lt;code&gt;NSNumber&lt;/code&gt;. There are also child classes per Kotlin number type:</source>
          <target state="translated">&lt;code&gt;&amp;lt;Framework&amp;gt;/Headers/Demo.h&lt;/code&gt; 的下一部分包含Kotlin / Native和 &lt;code&gt;NSNumber&lt;/code&gt; 之间的数字类型映射。我们有一个叫做基类 &lt;code&gt;DemoNumber&lt;/code&gt; 在Objective-C和 &lt;code&gt;KotlinNumber&lt;/code&gt; 斯威夫特。它扩展了 &lt;code&gt;NSNumber&lt;/code&gt; 。每个Kotlin数字类型也有子类：</target>
        </trans-unit>
        <trans-unit id="cfe4a47831305057cc6388a57b9e77a3a7e3a7a8" translate="yes" xml:space="preserve">
          <source>The next part of the &lt;code&gt;libnative_api.h&lt;/code&gt; file contains definitions of the types that are used in the library:</source>
          <target state="translated">&lt;code&gt;libnative_api.h&lt;/code&gt; 文件的下一部分包含该库中使用的类型的定义：</target>
        </trans-unit>
        <trans-unit id="dc72aec2231c401cec520bbf86ad2595019584f0" translate="yes" xml:space="preserve">
          <source>The next step is going to prompt us on the Kotlin runtime library. By default the plugin selects the one that is associated to the currently installed version. Unless we want to create a different one, we can click Finish at this point after entering the project name and location.</source>
          <target state="translated">下一步会提示我们选择Kotlin运行时库。默认情况下,插件会选择与当前安装的版本相关联的那个库。除非我们想创建一个不同的,否则我们可以在此时输入项目名称和位置后点击完成。</target>
        </trans-unit>
        <trans-unit id="93716c2cabdff509bf9835ed635452819990ca4f" translate="yes" xml:space="preserve">
          <source>The next step is to call a C function pointer from a C pointer that we have from the &lt;code&gt;supply_fun()&lt;/code&gt; call:</source>
          <target state="translated">下一步是从 &lt;code&gt;supply_fun()&lt;/code&gt; 调用中的C指针中调用C函数指针：</target>
        </trans-unit>
        <trans-unit id="4c075c67c98b72698b50bde83417679cfcaad540" translate="yes" xml:space="preserve">
          <source>The next step is to compile our application. We already covered the basics of compiling a Kotlin/Native application from the command line in the &lt;a href=&quot;basic-kotlin-native-app&quot;&gt;A Basic Kotlin/Native application&lt;/a&gt; tutorial. The only difference in this case is that the &lt;code&gt;cinterop&lt;/code&gt; generated part is implicitly included into the build: Let's call the following command:</source>
          <target state="translated">下一步是编译我们的应用程序。我们已经在&lt;a href=&quot;basic-kotlin-native-app&quot;&gt;A Basic Kotlin / Native应用程序&lt;/a&gt;教程的命令行中介绍了编译Kotlin / Native应用程序的基础知识。在这种情况下，唯一的区别是 &lt;code&gt;cinterop&lt;/code&gt; 生成的部分隐式包含在构建中：让我们调用以下命令：</target>
        </trans-unit>
        <trans-unit id="29eb1a88978e11cb19e6153185329a8fdd184b9c" translate="yes" xml:space="preserve">
          <source>The next step is to create Greeting Data class that has two properties: &lt;em&gt;id&lt;/em&gt; and a &lt;em&gt;content&lt;/em&gt;</source>
          <target state="translated">下一步是创建具有两个属性的Greeting Data类：&lt;em&gt;id&lt;/em&gt;和&lt;em&gt;content&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f2ba2b214cfaccb2ec50010bfe1a0d121ee2cd4b" translate="yes" xml:space="preserve">
          <source>The next step is to create a Run Configuration in IntelliJ IDEA under Tomcat / Local which deploys the WAR and starts up Tomcat.</source>
          <target state="translated">下一步是在Tomcat/Local下的IntelliJ IDEA中创建一个运行配置,部署WAR并启动Tomcat。</target>
        </trans-unit>
        <trans-unit id="27ce517e143c3dea9eb55849f860e4c5596ec3f9" translate="yes" xml:space="preserve">
          <source>The next step is to decide which modules to configure (if the project has more than one module) and whether you want to add the runtime library to the project or use those provided by the current Kotlin plugin.</source>
          <target state="translated">下一步是决定要配置哪些模块(如果项目有多个模块的话),以及是将运行时库添加到项目中,还是使用当前Kotlin插件提供的模块。</target>
        </trans-unit>
        <trans-unit id="22779d3ccc120e4892af96a829245aa095780550" translate="yes" xml:space="preserve">
          <source>The non-abstract subclasses should represent the (complete) C data type and thus specify size and alignment. Each such subclass must have a companion object which is a &lt;a href=&quot;-type/index&quot;&gt;Type&lt;/a&gt;.</source>
          <target state="translated">非抽象子类应表示（完整的）C数据类型，从而指定大小和对齐方式。每个此类子类都必须具有一个&lt;a href=&quot;-type/index&quot;&gt;Type&lt;/a&gt;伴随对象。</target>
        </trans-unit>
        <trans-unit id="fc28129df689ae65c9fd83a31b9aa03dac9e8ced" translate="yes" xml:space="preserve">
          <source>The non-breaking space character</source>
          <target state="translated">不断裂的空间特征</target>
        </trans-unit>
        <trans-unit id="e8f00eeeaaa301ab094d387f05d45fa33541dead" translate="yes" xml:space="preserve">
          <source>The nullable version &lt;code&gt;Nothing?&lt;/code&gt; will be used by the compiler when something is initialized with null and there is no other type information. In &lt;code&gt;val x = null&lt;/code&gt;, the type of &lt;code&gt;x&lt;/code&gt; will be &lt;code&gt;Nothing?&lt;/code&gt;. This type does not have the &quot;never returns normally&quot; semantics; instead, the compiler knows that the value will always be null.</source>
          <target state="translated">可空版本 &lt;code&gt;Nothing?&lt;/code&gt; 当使用null初始化某些东西并且没有其他类型信息时，编译器将使用。在 &lt;code&gt;val x = null&lt;/code&gt; ，类型 &lt;code&gt;x&lt;/code&gt; 将是 &lt;code&gt;Nothing?&lt;/code&gt; 。此类型不具有&amp;ldquo;从不返回正常&amp;rdquo;语义；相反，编译器知道该值将始终为null。</target>
        </trans-unit>
        <trans-unit id="77363aca1573dd5dba20e28ad666c9c7fd83436a" translate="yes" xml:space="preserve">
          <source>The number is converted to a string and then the string is converted to a &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/math/BigDecimal.html&quot;&gt;BigDecimal&lt;/a&gt;.</source>
          <target state="translated">将数字转换为字符串，然后将字符串转换为&lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/math/BigDecimal.html&quot;&gt;BigDecimal&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="bbb7b619e5deab250c82714dad5c6223da422d99" translate="yes" xml:space="preserve">
          <source>The number is converted to a string and then the string is converted to a &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/math/BigDecimal.html&quot;&gt;BigDecimal&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc9979a04405cfcd09395aa075f56f352dfb5b1c" translate="yes" xml:space="preserve">
          <source>The number of bits used to represent a Char in a binary form.</source>
          <target state="translated">用来表示二进制形式的Char的位数。</target>
        </trans-unit>
        <trans-unit id="a5aabbd23fb87b74097e1ccd4055f0b183ecbf87" translate="yes" xml:space="preserve">
          <source>The number of bits used to represent an instance of Byte in a binary form.</source>
          <target state="translated">用来表示二进制形式的Byte实例的位数。</target>
        </trans-unit>
        <trans-unit id="fc5f8fcea457f48ba61aea0a6c6364e750d35bba" translate="yes" xml:space="preserve">
          <source>The number of bits used to represent an instance of Double in a binary form.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ac96a9235bc1077029c5934186d743a5b00c197" translate="yes" xml:space="preserve">
          <source>The number of bits used to represent an instance of Float in a binary form.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f9c3201d4f3bb80740106fd705fe9901bfc9490" translate="yes" xml:space="preserve">
          <source>The number of bits used to represent an instance of Int in a binary form.</source>
          <target state="translated">用来表示二进制形式的Int实例的位数。</target>
        </trans-unit>
        <trans-unit id="881c588a79332a9f90d40c26e737596c51909376" translate="yes" xml:space="preserve">
          <source>The number of bits used to represent an instance of Long in a binary form.</source>
          <target state="translated">用二进制形式表示Long实例的位数。</target>
        </trans-unit>
        <trans-unit id="3a2fa986a400a5de2289aa09e08c447c811e1ab0" translate="yes" xml:space="preserve">
          <source>The number of bits used to represent an instance of Short in a binary form.</source>
          <target state="translated">用来表示二进制形式的Short实例的位数。</target>
        </trans-unit>
        <trans-unit id="b557b6ad22e0d4a32e6ecf5e7c42a83086397f62" translate="yes" xml:space="preserve">
          <source>The number of bits used to represent an instance of UByte in a binary form.</source>
          <target state="translated">用来表示一个二进制形式的UByte实例的位数。</target>
        </trans-unit>
        <trans-unit id="04a46c8fcf471f6f7a2489fd5541b67d79b2dbba" translate="yes" xml:space="preserve">
          <source>The number of bits used to represent an instance of UInt in a binary form.</source>
          <target state="translated">用来表示二进制形式的UInt实例的位数。</target>
        </trans-unit>
        <trans-unit id="970f51f6cf41ca82dcda9c5384dd1584581a3241" translate="yes" xml:space="preserve">
          <source>The number of bits used to represent an instance of ULong in a binary form.</source>
          <target state="translated">用来表示一个二进制形式的ULong实例的位数。</target>
        </trans-unit>
        <trans-unit id="f405dad940dd8a9ba9986616021e6669d81ef332" translate="yes" xml:space="preserve">
          <source>The number of bits used to represent an instance of UShort in a binary form.</source>
          <target state="translated">用来表示二进制形式的UShort实例的位数。</target>
        </trans-unit>
        <trans-unit id="7fca3ee96d6d11e61b4e40ce8aef39bbd3166f00" translate="yes" xml:space="preserve">
          <source>The number of bytes used to represent a Char in a binary form.</source>
          <target state="translated">用来表示二进制形式的Char的字节数。</target>
        </trans-unit>
        <trans-unit id="d455af0205d71a29c80b7797e96f36f72c818b20" translate="yes" xml:space="preserve">
          <source>The number of bytes used to represent an instance of Byte in a binary form.</source>
          <target state="translated">用来表示二进制形式的Byte实例的字节数。</target>
        </trans-unit>
        <trans-unit id="cfb84d55b9d6ee08abf33db55d2a61462dded701" translate="yes" xml:space="preserve">
          <source>The number of bytes used to represent an instance of Double in a binary form.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="080e5eee27bb967010b8c2b300a0c20e8300d7a1" translate="yes" xml:space="preserve">
          <source>The number of bytes used to represent an instance of Float in a binary form.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="012737f61c97912b11277e0542ab793fcecbd8f6" translate="yes" xml:space="preserve">
          <source>The number of bytes used to represent an instance of Int in a binary form.</source>
          <target state="translated">用来表示二进制形式的Int实例的字节数。</target>
        </trans-unit>
        <trans-unit id="ac50dee558bf2179b63147e5d4abcf881946deb1" translate="yes" xml:space="preserve">
          <source>The number of bytes used to represent an instance of Long in a binary form.</source>
          <target state="translated">用二进制形式表示Long实例的字节数。</target>
        </trans-unit>
        <trans-unit id="d47711ab000d6ab309cdde940a4d6cc83958bbb7" translate="yes" xml:space="preserve">
          <source>The number of bytes used to represent an instance of Short in a binary form.</source>
          <target state="translated">用来表示二进制形式的Short实例的字节数。</target>
        </trans-unit>
        <trans-unit id="5da103d9bfe814cb16e570a63e8fffdec6abede9" translate="yes" xml:space="preserve">
          <source>The number of bytes used to represent an instance of UByte in a binary form.</source>
          <target state="translated">用来表示二进制形式的UByte实例的字节数。</target>
        </trans-unit>
        <trans-unit id="7aa018571731f4dfc20dc2f2b40bc661649fe4df" translate="yes" xml:space="preserve">
          <source>The number of bytes used to represent an instance of UInt in a binary form.</source>
          <target state="translated">用来表示二进制形式的UInt实例的字节数。</target>
        </trans-unit>
        <trans-unit id="c4d88684784d0b5692fee9bc8fbbdcbfde1bb159" translate="yes" xml:space="preserve">
          <source>The number of bytes used to represent an instance of ULong in a binary form.</source>
          <target state="translated">用来表示一个二进制形式的ULong实例的字节数。</target>
        </trans-unit>
        <trans-unit id="de97fd8a16a598b6d753acf6fc495d892600d39e" translate="yes" xml:space="preserve">
          <source>The number of bytes used to represent an instance of UShort in a binary form.</source>
          <target state="translated">用来表示二进制形式的UShort实例的字节数。</target>
        </trans-unit>
        <trans-unit id="802421b7bac6f95ce971296bce66f238a1ca7ee6" translate="yes" xml:space="preserve">
          <source>The official docs also have a very cool example with a &lt;a href=&quot;../../reference/type-safe-builders&quot;&gt; DSL for constructing HTML documents&lt;/a&gt;.</source>
          <target state="translated">官方文档中还有一个非常酷的示例，其中包含&lt;a href=&quot;../../reference/type-safe-builders&quot;&gt;用于构造HTML文档&lt;/a&gt;的DSL。</target>
        </trans-unit>
        <trans-unit id="9824ffa4fbac1aa2ba4df2857cc7d27ae42fbdf3" translate="yes" xml:space="preserve">
          <source>The only target for which it is not available is &lt;a href=&quot;https://en.wikipedia.org/wiki/WebAssembly&quot;&gt;WebAssembly&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://en.wikipedia.org/wiki/WebAssembly&quot;&gt;WebAssembly&lt;/a&gt;是唯一无法使用的目标。</target>
        </trans-unit>
        <trans-unit id="20601b96604d0e7211b7510d021f94ac0577f4a7" translate="yes" xml:space="preserve">
          <source>The only thing left to do is compile our application (Build|Build Project), and once the JavaScript files have been generated, we can open the &lt;code&gt;index.html&lt;/code&gt; file in the browser and see the result in the console debug window.</source>
          <target state="translated">剩下要做的就是编译我们的应用程序（Build | Build Project），并且一旦生成了JavaScript文件，我们就可以在浏览器中打开 &lt;code&gt;index.html&lt;/code&gt; 文件，并在控制台调试窗口中查看结果。</target>
        </trans-unit>
        <trans-unit id="940b1bdb9d47159d1535cf808141916fc2b5f10e" translate="yes" xml:space="preserve">
          <source>The operation doesn't preserve copied file attributes such as creation/modification date, permissions, etc.</source>
          <target state="translated">该操作不保留复制的文件属性,如创建/修改日期、权限等。</target>
        </trans-unit>
        <trans-unit id="b9a452f893e9486c5fbe89e3c1a52b0da8c35684" translate="yes" xml:space="preserve">
          <source>The operation is &lt;em&gt;intermediate&lt;/em&gt; and &lt;em&gt;stateful&lt;/em&gt;.</source>
          <target state="translated">操作&lt;em&gt;中间&lt;/em&gt;和&lt;em&gt;有状态&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="64f2d6f436a63697c12d9826dd0b449a2c8ece4d" translate="yes" xml:space="preserve">
          <source>The operation is &lt;em&gt;intermediate&lt;/em&gt; and &lt;em&gt;stateless&lt;/em&gt;.</source>
          <target state="translated">该操作是&lt;em&gt;中间&lt;/em&gt;且&lt;em&gt;无状态的&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="2f74c9f051d5d0a5178895ef9787aac4f50f4820" translate="yes" xml:space="preserve">
          <source>The operation is &lt;em&gt;intermediate&lt;/em&gt; for this sequence and &lt;em&gt;terminal&lt;/em&gt; and &lt;em&gt;stateful&lt;/em&gt; for the &lt;a href=&quot;minus#kotlin.sequences%24minus%28kotlin.sequences.Sequence%28%28kotlin.sequences.minus.T%29%29%2C+kotlin.sequences.Sequence%28%28kotlin.sequences.minus.T%29%29%29%2Felements&quot;&gt;elements&lt;/a&gt; sequence.</source>
          <target state="translated">操作是&lt;em&gt;中间&lt;/em&gt;此序列和&lt;em&gt;终端&lt;/em&gt;和&lt;em&gt;有状态&lt;/em&gt;的&lt;a href=&quot;minus#kotlin.sequences%24minus%28kotlin.sequences.Sequence%28%28kotlin.sequences.minus.T%29%29%2C+kotlin.sequences.Sequence%28%28kotlin.sequences.minus.T%29%29%29%2Felements&quot;&gt;元素&lt;/a&gt;序列。</target>
        </trans-unit>
        <trans-unit id="790886232e90f42fd32ca4859b4baabd53b9cbd8" translate="yes" xml:space="preserve">
          <source>The operation is &lt;em&gt;intermediate&lt;/em&gt; for this sequence and &lt;em&gt;terminal&lt;/em&gt; and &lt;em&gt;stateful&lt;/em&gt; for the &lt;a href=&quot;minus#kotlin.sequences%24minus(kotlin.sequences.Sequence((kotlin.sequences.minus.T)),%20kotlin.sequences.Sequence((kotlin.sequences.minus.T)))/elements&quot;&gt;elements&lt;/a&gt; sequence.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f90173c5f7dc2e732f31878b5387f1009c2ad309" translate="yes" xml:space="preserve">
          <source>The operation is &lt;em&gt;terminal&lt;/em&gt;.</source>
          <target state="translated">操作是&lt;em&gt;终端&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="24cec715dc71cea63c8c77aa342afd935860c2d6" translate="yes" xml:space="preserve">
          <source>The operations on floating point numbers discussed in this section are:</source>
          <target state="translated">本节讨论的浮点数的操作有:。</target>
        </trans-unit>
        <trans-unit id="c81054e9fa59c990a7f0009d1471af7d0d80d085" translate="yes" xml:space="preserve">
          <source>The operator &lt;code&gt;plus&lt;/code&gt; provides a way to add key-value pair(s) to a read-only map producing a new map, however there was not a simple way to do the opposite: to remove a key from the map you have to resort to less straightforward ways to like &lt;code&gt;Map.filter()&lt;/code&gt; or &lt;code&gt;Map.filterKeys()&lt;/code&gt;. Now the operator &lt;code&gt;minus&lt;/code&gt; fills this gap. There are 4 overloads available: for removing a single key, a collection of keys, a sequence of keys and an array of keys.</source>
          <target state="translated">运算符 &lt;code&gt;plus&lt;/code&gt; 提供了一种将键值对添加到生成新图的只读图的方法，但是，没有相反的简单方法：从图上删除键不太喜欢 &lt;code&gt;Map.filter()&lt;/code&gt; 或 &lt;code&gt;Map.filterKeys()&lt;/code&gt; 的简单方法。现在，操作员 &lt;code&gt;minus&lt;/code&gt; 填补了这个空白。有4种重载可用：用于删除单个键，键集合，键序列和键数组。</target>
        </trans-unit>
        <trans-unit id="a3dfe13bda3af06c0e25457985a11e6db0a3ea90" translate="yes" xml:space="preserve">
          <source>The order of elements is an important aspect of certain collection types. For example, two lists of the same elements are not equal if their elements are ordered differently.</source>
          <target state="translated">元素的顺序是某些集合类型的一个重要方面。例如,由相同元素组成的两个列表,如果其元素的顺序不同,则不相等。</target>
        </trans-unit>
        <trans-unit id="97cb339b9434116a61ea466562966c5cfa7e6e7a" translate="yes" xml:space="preserve">
          <source>The order of operations execution is different as well: &lt;code&gt;Sequence&lt;/code&gt; performs all the processing steps one-by-one for every single element. In turn, &lt;code&gt;Iterable&lt;/code&gt; completes each step for the whole collection and then proceeds to the next step.</source>
          <target state="translated">操作执行的顺序也不同： &lt;code&gt;Sequence&lt;/code&gt; 对每个元素逐一执行所有处理步骤。反过来， &lt;code&gt;Iterable&lt;/code&gt; 完成整个集合的每个步骤，然后进行下一步。</target>
        </trans-unit>
        <trans-unit id="812e3a1f04f0d82a55115416fefd4d8f871219e6" translate="yes" xml:space="preserve">
          <source>The original exception is handled by the parent only when all its children terminate, which is demonstrated by the following example.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b74ff8ee45b0b8f3cea227a5cb8b0ca2512e0fa1" translate="yes" xml:space="preserve">
          <source>The output is:</source>
          <target state="translated">产出是:</target>
        </trans-unit>
        <trans-unit id="21b2e4b0974b9e68e9c52fc5e687c75f3f109501" translate="yes" xml:space="preserve">
          <source>The output it produces with &lt;code&gt;-Dkotlinx.coroutines.debug&lt;/code&gt; JVM option is similar to:</source>
          <target state="translated">它使用 &lt;code&gt;-Dkotlinx.coroutines.debug&lt;/code&gt; JVM选项生成的输出类似于：</target>
        </trans-unit>
        <trans-unit id="335f16bba6cd2578184d6190d9013ac4ec39e185" translate="yes" xml:space="preserve">
          <source>The output of a config script with &lt;code&gt;--libs&lt;/code&gt; will be passed as a &lt;code&gt;-linkedArgs&lt;/code&gt;&lt;code&gt;kotlinc&lt;/code&gt; flag value (quoted) when compiling.</source>
          <target state="translated">带有 &lt;code&gt;--libs&lt;/code&gt; 的配置脚本的输出将在编译时作为 &lt;code&gt;-linkedArgs&lt;/code&gt; &lt;code&gt;kotlinc&lt;/code&gt; 标志值（引用）传递。</target>
        </trans-unit>
        <trans-unit id="a335f7db5ad6c9bad17c284454dcaeefbd6be278" translate="yes" xml:space="preserve">
          <source>The output of this code is (with &lt;a href=&quot;https://github.com/Kotlin/kotlinx.coroutines/blob/master/docs/coroutine-context-and-dispatchers.md#debugging-coroutines-and-threads&quot;&gt;debug&lt;/a&gt;):</source>
          <target state="translated">此代码的输出是（带&lt;a href=&quot;https://github.com/Kotlin/kotlinx.coroutines/blob/master/docs/coroutine-context-and-dispatchers.md#debugging-coroutines-and-threads&quot;&gt;debug&lt;/a&gt;）：</target>
        </trans-unit>
        <trans-unit id="d91d0dd8fa3a619861392f5c074fea2d8db4eaf2" translate="yes" xml:space="preserve">
          <source>The output of this code is:</source>
          <target state="translated">该代码的输出是:</target>
        </trans-unit>
        <trans-unit id="647a971dfd3700d13cfdc057be9aa0bc71494501" translate="yes" xml:space="preserve">
          <source>The output of this code shows that the &lt;code&gt;filter()&lt;/code&gt; and &lt;code&gt;map()&lt;/code&gt; functions are called only when building the result list. So, you first see the line of text &lt;code&gt;&amp;ldquo;Lengths of..&amp;rdquo;&lt;/code&gt; and then the sequence processing starts. Note that for elements left after filtering, the map executes before filtering the next element. When the result size reaches 4, the processing stops because it's the largest possible size that &lt;code&gt;take(4)&lt;/code&gt; can return.</source>
          <target state="translated">此代码的输出显示仅在构建结果列表时才调用 &lt;code&gt;filter()&lt;/code&gt; 和 &lt;code&gt;map()&lt;/code&gt; 函数。因此，您首先看到文本行 &lt;code&gt;&amp;ldquo;Lengths of..&amp;rdquo;&lt;/code&gt; ，然后开始进行序列处理。请注意，对于过滤后剩余的元素，映射将在过滤下一个元素之前执行。当结果大小达到4时，处理将停止，因为它是 &lt;code&gt;take(4)&lt;/code&gt; 可以返回的最大大小。</target>
        </trans-unit>
        <trans-unit id="4914ca42a65eab132541007ef394cf246de086f7" translate="yes" xml:space="preserve">
          <source>The output of this code with &lt;code&gt;-Dkotlinx.coroutines.debug&lt;/code&gt; JVM option is:</source>
          <target state="translated">使用 &lt;code&gt;-Dkotlinx.coroutines.debug&lt;/code&gt; JVM选项的此代码的输出为：</target>
        </trans-unit>
        <trans-unit id="ef205ce911c3cb52ce12493307210d6d78d5dcb8" translate="yes" xml:space="preserve">
          <source>The output of this code with the &lt;code&gt;-Dkotlinx.coroutines.debug&lt;/code&gt; JVM option is:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fdcf4102afb246d995583e41d5abf443dc9b24d6" translate="yes" xml:space="preserve">
          <source>The output of this example is:</source>
          <target state="translated">这个例子的输出是:</target>
        </trans-unit>
        <trans-unit id="d7f56deac4aeaab1be47a9075fd39d0cd515a13f" translate="yes" xml:space="preserve">
          <source>The output of this is a blank page that prints &lt;code&gt;Hello JavaScript!&lt;/code&gt; to the console.</source>
          <target state="translated">输出为空白页，其中打印 &lt;code&gt;Hello JavaScript!&lt;/code&gt; 到控制台。</target>
        </trans-unit>
        <trans-unit id="c7adcbeb9a00e6f9f8d55d348527ceb949cebeb0" translate="yes" xml:space="preserve">
          <source>The output should be:</source>
          <target state="translated">输出应该是:</target>
        </trans-unit>
        <trans-unit id="0b8e02788f842ec131e59334f158260f8f72ffc7" translate="yes" xml:space="preserve">
          <source>The output will be similar to the the following one, albeit the processor ids that receive each specific integer may be different:</source>
          <target state="translated">尽管接收每个特定整数的处理器ID可能不同,但输出将与下面的类似。</target>
        </trans-unit>
        <trans-unit id="dacb06aada01cf9353bf2a419b476781dd3c13a9" translate="yes" xml:space="preserve">
          <source>The overall effect is exactly as if the &lt;a href=&quot;append#kotlin.text.StringBuilder%24append(kotlin.Any?)/value&quot;&gt;value&lt;/a&gt; were converted to a string by the &lt;code&gt;value.toString()&lt;/code&gt; method, and then that string was appended to this string builder.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2fa46c20aa677e08c4fbabd2c01f13037e7e1a67" translate="yes" xml:space="preserve">
          <source>The overall effect is exactly as if the &lt;a href=&quot;append#kotlin.text.StringBuilder%24append(kotlin.Boolean)/value&quot;&gt;value&lt;/a&gt; were converted to a string by the &lt;code&gt;value.toString()&lt;/code&gt; method, and then that string was appended to this string builder.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d95d1d469be2176ebbc72a21468acef591255ad" translate="yes" xml:space="preserve">
          <source>The overall effect is exactly as if the &lt;a href=&quot;insert#kotlin.text.StringBuilder%24insert(kotlin.Int,%20kotlin.Any?)/value&quot;&gt;value&lt;/a&gt; were converted to a string by the &lt;code&gt;value.toString()&lt;/code&gt; method, and then that string was inserted into this string builder at the specified &lt;a href=&quot;insert#kotlin.text.StringBuilder%24insert(kotlin.Int,%20kotlin.Any?)/index&quot;&gt;index&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76acc76cfe7700de42074cf269fd6d05489f7e96" translate="yes" xml:space="preserve">
          <source>The overall effect is exactly as if the &lt;a href=&quot;insert#kotlin.text.StringBuilder%24insert(kotlin.Int,%20kotlin.Boolean)/value&quot;&gt;value&lt;/a&gt; were converted to a string by the &lt;code&gt;value.toString()&lt;/code&gt; method, and then that string was inserted into this string builder at the specified &lt;a href=&quot;insert#kotlin.text.StringBuilder%24insert(kotlin.Int,%20kotlin.Boolean)/index&quot;&gt;index&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b56500d82b30990e46ae5220b62e1c3f4e225003" translate="yes" xml:space="preserve">
          <source>The overriding constructor must have the same parameter names and types as the overridden one.</source>
          <target state="translated">覆盖的构造函数必须与被覆盖的构造函数具有相同的参数名称和类型。</target>
        </trans-unit>
        <trans-unit id="d0fd3de86e4826ba8c7cde26e87523bae54839bc" translate="yes" xml:space="preserve">
          <source>The packages from platform libraries are available by default. No special link flags need to be specified to use them. &lt;code&gt;Kotlin/Native&lt;/code&gt; compiler automatically detects which of the platform libraries have been accessed and automatically links the needed libraries.</source>
          <target state="translated">默认情况下，平台库中的软件包可用。无需指定特殊的链接标志即可使用它们。 &lt;code&gt;Kotlin/Native&lt;/code&gt; 编译器会自动检测已访问了哪些平台库，并自动链接所需的库。</target>
        </trans-unit>
        <trans-unit id="f9eac82235030e7e86a0bff236552f847d9867dd" translate="yes" xml:space="preserve">
          <source>The parameter is declared in a member function and one of the corresponding parameters in the super functions is optional.</source>
          <target state="translated">该参数在成员函数中声明,在超级函数中对应的参数之一是可选的。</target>
        </trans-unit>
        <trans-unit id="1a311c087dc5f415abb270981ad04ec98ba47164" translate="yes" xml:space="preserve">
          <source>The parameter must not &lt;a href=&quot;#variable-number-of-arguments-varargs&quot;&gt;accept variable number of arguments&lt;/a&gt; and must have no &lt;a href=&quot;#default-arguments&quot;&gt;default value&lt;/a&gt;.</source>
          <target state="translated">该参数不能&lt;a href=&quot;#variable-number-of-arguments-varargs&quot;&gt;接受可变数量的参数，&lt;/a&gt;并且必须没有&lt;a href=&quot;#default-arguments&quot;&gt;默认值&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="85604054f8838d2bde0848abdc31a44140b69283" translate="yes" xml:space="preserve">
          <source>The parameter of &lt;code&gt;@JsName&lt;/code&gt; is required to be a constant string literal which is a valid identifier. The compiler will report an error on any attempt to pass non-identifier string to &lt;code&gt;@JsName&lt;/code&gt;. The following example produces a compile-time error:</source>
          <target state="translated">&lt;code&gt;@JsName&lt;/code&gt; 的参数必须是常量字符串文字，它是有效的标识符。尝试将非标识符字符串传递给 &lt;code&gt;@JsName&lt;/code&gt; 时，编译器将报告错误。下面的示例产生一个编译时错误：</target>
        </trans-unit>
        <trans-unit id="d09d94c8171c7316821713755fce66dc3c85e74a" translate="yes" xml:space="preserve">
          <source>The parameter of &lt;code&gt;js&lt;/code&gt; is required to be a string constant. So, the following code is incorrect:</source>
          <target state="translated">&lt;code&gt;js&lt;/code&gt; 的参数必须为字符串常量。因此，以下代码不正确：</target>
        </trans-unit>
        <trans-unit id="64419b25b7715086a3a5cdbe138547b81a0a98a1" translate="yes" xml:space="preserve">
          <source>The parameter type of a function-typed parameter (the user is passing a function that can handle any &lt;code&gt;Fruit&lt;/code&gt;, and it will be given an &lt;code&gt;Apple&lt;/code&gt;)</source>
          <target state="translated">函数类型参数的参数类型（用户正在传递可以处理任何 &lt;code&gt;Fruit&lt;/code&gt; 的函数，并且它将获得 &lt;code&gt;Apple&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="6ef05f581070101fa2afecc255e98671537cdea0" translate="yes" xml:space="preserve">
          <source>The parameters and the return type are specified in the same way as for regular functions, except that the parameter types can be omitted if they can be inferred from context:</source>
          <target state="translated">参数和返回类型的指定方式与普通函数相同,只是如果可以从上下文中推断出参数类型,则可以省略。</target>
        </trans-unit>
        <trans-unit id="d2818a5f4b17e0f3d50df0846a19518863e09067" translate="yes" xml:space="preserve">
          <source>The parameters of &lt;code&gt;provideDelegate&lt;/code&gt; are the same as for &lt;code&gt;getValue&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;provideDelegate&lt;/code&gt; 的参数与 &lt;code&gt;getValue&lt;/code&gt; 相同：</target>
        </trans-unit>
        <trans-unit id="87e2c98795ae2a97eb179a3bb9ccc1f2e2c982d8" translate="yes" xml:space="preserve">
          <source>The passed type must satisfy all conditions of the &lt;code&gt;where&lt;/code&gt; clause simultaneously. In the above example, the &lt;code&gt;T&lt;/code&gt; type must implement &lt;em&gt;both&lt;/em&gt;&lt;code&gt;CharSequence&lt;/code&gt; and &lt;code&gt;Comparable&lt;/code&gt;.</source>
          <target state="translated">传递的类型必须同时满足 &lt;code&gt;where&lt;/code&gt; 子句的所有条件。在上面的例子中， &lt;code&gt;T&lt;/code&gt; 类型必须实现&lt;em&gt;两者&lt;/em&gt; &lt;code&gt;CharSequence&lt;/code&gt; 和 &lt;code&gt;Comparable&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0f70942d020a14104380fd6e7920e316921b42c6" translate="yes" xml:space="preserve">
          <source>The path refers to the default output location that IntelliJ IDEA uses when we compile the application. Below we'll see how to change this.</source>
          <target state="translated">这个路径指的是IntelliJ IDEA在我们编译应用程序时使用的默认输出位置。下面我们就来看看如何改变这个位置。</target>
        </trans-unit>
        <trans-unit id="38dc6771af81ffcbac99f06b8c7fb1ebccf80f9d" translate="yes" xml:space="preserve">
          <source>The pattern string of this regular expression.</source>
          <target state="translated">该正则表达式的模式字符串。</target>
        </trans-unit>
        <trans-unit id="1144f4eed1bc15fed420102b18cb1c4e49c25335" translate="yes" xml:space="preserve">
          <source>The pattern where a coroutine is producing a sequence of elements is quite common. This is a part of &lt;em&gt;producer-consumer&lt;/em&gt; pattern that is often found in concurrent code. You could abstract such a producer into a function that takes channel as its parameter, but this goes contrary to common sense that results must be returned from functions.</source>
          <target state="translated">协程产生一系列元素的模式非常普遍。这是通常在并发代码中发现的&lt;em&gt;生产者-消费者&lt;/em&gt;模式的一部分。您可以将这样的生产者抽象为以channel为参数的函数，但这与必须从函数返回结果的常识相反。</target>
        </trans-unit>
        <trans-unit id="0452bcbdd609690466ea082ea5af90749aa8dcc5" translate="yes" xml:space="preserve">
          <source>The placeholder &lt;code&gt;&amp;lt;...&amp;gt;&lt;/code&gt; should be replaced with one of the plugin names that can be found in further sections.</source>
          <target state="translated">占位符 &lt;code&gt;&amp;lt;...&amp;gt;&lt;/code&gt; 应该替换为可以在后续章节中找到的插件名称之一。</target>
        </trans-unit>
        <trans-unit id="02d885dcfef73f7197c98c6f94fc980ae42855f5" translate="yes" xml:space="preserve">
          <source>The plugin allows you to customize the pom generated for the publication with the &lt;code&gt;pom&lt;/code&gt; code block available for every component:</source>
          <target state="translated">该插件允许您使用每个组件可用的 &lt;code&gt;pom&lt;/code&gt; 代码块来自定义为发布生成的pom：</target>
        </trans-unit>
        <trans-unit id="73896d94724b0c15c533e7832f50fc2c5d439771" translate="yes" xml:space="preserve">
          <source>The plugin allows you to declare dependencies on files and other projects using traditional Gradle's mechanism of configurations. The plugin supports Kotlin multiplatform projects allowing you to declare the &lt;code&gt;expectedBy&lt;/code&gt; dependencies</source>
          <target state="translated">该插件使您可以使用传统的Gradle配置机制声明对文件和其他项目的依赖性。该插件支持科特林多项目让你申报 &lt;code&gt;expectedBy&lt;/code&gt; 依赖</target>
        </trans-unit>
        <trans-unit id="e2b8c11954d8c4f9f34c307b3e3ea0e12583e5af" translate="yes" xml:space="preserve">
          <source>The plugin builds a test executable for all the targets specified for the &lt;code&gt;test&lt;/code&gt; component. If the current host platform is included in this list the test running tasks are also created. To run tests, execute the standard lifecycle &lt;code&gt;check&lt;/code&gt; task:</source>
          <target state="translated">该插件为为 &lt;code&gt;test&lt;/code&gt; 组件指定的所有目标构建测试可执行文件。如果此列表中包含当前主机平台，则还将创建测试运行任务。要运行测试，请执行标准的生命周期 &lt;code&gt;check&lt;/code&gt; 任务：</target>
        </trans-unit>
        <trans-unit id="cbd612ac393a456f8773735c05ddbd5f91419396" translate="yes" xml:space="preserve">
          <source>The plugin creates a compilation task for each combination of the target, output kind, and build type. The tasks have the following naming convention:</source>
          <target state="translated">该插件为目标、输出类型和构建类型的每个组合创建一个编译任务。任务的命名约定如下。</target>
        </trans-unit>
        <trans-unit id="b7797d4ea1281347f08b98f3d1593b5740b623cc" translate="yes" xml:space="preserve">
          <source>The plugin is shipped with a customized version of the &lt;code&gt;kotlinx.serialization&lt;/code&gt; plugin. To use it you don't have to add new buildscript dependencies, just apply the plugins and add a dependency on the serialization library:</source>
          <target state="translated">该插件随附了 &lt;code&gt;kotlinx.serialization&lt;/code&gt; 插件的自定义版本。要使用它，您不必添加新的buildscript依赖项，只需应用插件并在序列化库上添加依赖项即可：</target>
        </trans-unit>
        <trans-unit id="a5b5cad9084adc7ffa681b4e8b7b6b009920bbab" translate="yes" xml:space="preserve">
          <source>The plugin option format is: &lt;code&gt;-P plugin:&amp;lt;plugin id&amp;gt;:&amp;lt;key&amp;gt;=&amp;lt;value&amp;gt;&lt;/code&gt;. Options can be repeated.</source>
          <target state="translated">插件选项格式为 &lt;code&gt;-P plugin:&amp;lt;plugin id&amp;gt;:&amp;lt;key&amp;gt;=&amp;lt;value&amp;gt;&lt;/code&gt; 。选项可以重复。</target>
        </trans-unit>
        <trans-unit id="4b96dd9cca135b083ee411ceef82d46edf74c104" translate="yes" xml:space="preserve">
          <source>The plugin specifies the following annotations: &lt;a href=&quot;http://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/stereotype/Component.html&quot;&gt;&lt;code&gt;@Component&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;http://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/scheduling/annotation/Async.html&quot;&gt;&lt;code&gt;@Async&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;http://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/transaction/annotation/Transactional.html&quot;&gt;&lt;code&gt;@Transactional&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;http://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/cache/annotation/Cacheable.html&quot;&gt;&lt;code&gt;@Cacheable&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://docs.spring.io/spring-boot/docs/current/api/org/springframework/boot/test/context/SpringBootTest.html&quot;&gt;&lt;code&gt;@SpringBootTest&lt;/code&gt;&lt;/a&gt;. Thanks to meta-annotations support classes annotated with &lt;a href=&quot;https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/context/annotation/Configuration.html&quot;&gt;&lt;code&gt;@Configuration&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/stereotype/Controller.html&quot;&gt;&lt;code&gt;@Controller&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/web/bind/annotation/RestController.html&quot;&gt;&lt;code&gt;@RestController&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/stereotype/Service.html&quot;&gt;&lt;code&gt;@Service&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/stereotype/Repository.html&quot;&gt;&lt;code&gt;@Repository&lt;/code&gt;&lt;/a&gt; are automatically opened since these annotations are meta-annotated with &lt;a href=&quot;http://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/stereotype/Component.html&quot;&gt;&lt;code&gt;@Component&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">该插件指定了以下注释：&lt;a href=&quot;http://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/stereotype/Component.html&quot;&gt; &lt;code&gt;@Component&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;http://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/scheduling/annotation/Async.html&quot;&gt; &lt;code&gt;@Async&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;http://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/transaction/annotation/Transactional.html&quot;&gt; &lt;code&gt;@Transactional&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;http://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/cache/annotation/Cacheable.html&quot;&gt; &lt;code&gt;@Cacheable&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;https://docs.spring.io/spring-boot/docs/current/api/org/springframework/boot/test/context/SpringBootTest.html&quot;&gt; &lt;code&gt;@SpringBootTest&lt;/code&gt; &lt;/a&gt;。由于元注释支持与注解的类&lt;a href=&quot;https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/context/annotation/Configuration.html&quot;&gt; &lt;code&gt;@Configuration&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/stereotype/Controller.html&quot;&gt; &lt;code&gt;@Controller&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/web/bind/annotation/RestController.html&quot;&gt; &lt;code&gt;@RestController&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/stereotype/Service.html&quot;&gt; &lt;code&gt;@Service&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/stereotype/Repository.html&quot;&gt; &lt;code&gt;@Repository&lt;/code&gt; &lt;/a&gt;会自动打开，因为这些注释是元注解为&lt;a href=&quot;http://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/stereotype/Component.html&quot;&gt; &lt;code&gt;@Component&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="422a0ed13a769b30fb09b25e92467921db8dd51b" translate="yes" xml:space="preserve">
          <source>The plugin uses the same notation as the compiler. By default, test component uses the same targets as specified for the main one.</source>
          <target state="translated">插件使用与编译器相同的符号。默认情况下,测试组件使用与主测试组件相同的目标。</target>
        </trans-unit>
        <trans-unit id="1f3c2f2fca540697d8f63e00a5a21435f0484957" translate="yes" xml:space="preserve">
          <source>The podspec generated includes a path to an output framework and script phases which automate building this framework during a build process of an Xcode project. Some fields of the podspec file can be configured using the &lt;code&gt;kotlin.cocoapods { ... }&lt;/code&gt; code block.</source>
          <target state="translated">生成的podspec包括输出框架的路径和脚本阶段，这些阶段在Xcode项目的构建过程中自动构建该框架。可以使用 &lt;code&gt;kotlin.cocoapods { ... }&lt;/code&gt; 代码块来配置podspec文件的某些字段。</target>
        </trans-unit>
        <trans-unit id="4f2f6c39a4cfc0d578583a59ccc054d34affa473" translate="yes" xml:space="preserve">
          <source>The pointer with an opaque type.</source>
          <target state="translated">具有不透明类型的指针。</target>
        </trans-unit>
        <trans-unit id="cac38148225622f1c3ccca3dceed3d6a499e0217" translate="yes" xml:space="preserve">
          <source>The possible values of &lt;a href=&quot;returns#kotlin.contracts.ContractBuilder%24returns%28kotlin.Any%29%2Fvalue&quot;&gt;value&lt;/a&gt; are limited to &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;false&lt;/code&gt; or &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;returns#kotlin.contracts.ContractBuilder%24returns%28kotlin.Any%29%2Fvalue&quot;&gt;value&lt;/a&gt;的可能值限制为 &lt;code&gt;true&lt;/code&gt; ， &lt;code&gt;false&lt;/code&gt; 或 &lt;code&gt;null&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ff2c8804ee232db23ae3d579f25ad98024549ce9" translate="yes" xml:space="preserve">
          <source>The possible values of &lt;a href=&quot;returns#kotlin.contracts.ContractBuilder%24returns(kotlin.Any?)/value&quot;&gt;value&lt;/a&gt; are limited to &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;false&lt;/code&gt; or &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db453765e0a754bcf108983d99d14a9cceb4e257" translate="yes" xml:space="preserve">
          <source>The predicates in &lt;code&gt;filter()&lt;/code&gt; can only check the values of the elements. If you want to use element positions in the filter, use &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/filter-indexed&quot;&gt;&lt;code&gt;filterIndexed()&lt;/code&gt;&lt;/a&gt;. It takes a predicate with two arguments: the index and the value of an element.</source>
          <target state="translated">&lt;code&gt;filter()&lt;/code&gt; 中的谓词只能检查元素的值。如果要在过滤器中使用元素位置，请使用&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/filter-indexed&quot;&gt; &lt;code&gt;filterIndexed()&lt;/code&gt; &lt;/a&gt;。它带有两个参数的谓词：索引和元素的值。</target>
        </trans-unit>
        <trans-unit id="273bc9daf88463decafd479d30c651cc98374847" translate="yes" xml:space="preserve">
          <source>The prepared project sources can be directly downloaded from &lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-app-groovy-macos.zip&quot;&gt;GitHub&lt;/a&gt;. &lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-app-groovy-linux.zip&quot;&gt;GitHub&lt;/a&gt;. &lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-app-groovy-windows.zip&quot;&gt;GitHub&lt;/a&gt;. &lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-app-kotlin-macos.zip&quot;&gt;GitHub&lt;/a&gt;. &lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-app-kotlin-linux.zip&quot;&gt;GitHub&lt;/a&gt;. &lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-app-kotlin-windows.zip&quot;&gt;GitHub&lt;/a&gt;.</source>
          <target state="translated">准备好的项目源代码可以直接从&lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-app-groovy-macos.zip&quot;&gt;GitHub&lt;/a&gt;下载。&lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-app-groovy-linux.zip&quot;&gt;GitHub上&lt;/a&gt;。&lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-app-groovy-windows.zip&quot;&gt;GitHub上&lt;/a&gt;。&lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-app-kotlin-macos.zip&quot;&gt;GitHub上&lt;/a&gt;。&lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-app-kotlin-linux.zip&quot;&gt;GitHub上&lt;/a&gt;。&lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-app-kotlin-windows.zip&quot;&gt;GitHub上&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1cda211d823296d73d5059839d0f82ff49bb5da0" translate="yes" xml:space="preserve">
          <source>The prepared project sources can be directly downloaded from &lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-framework-groovy-macos-mac.zip&quot;&gt;GitHub&lt;/a&gt;. &lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-framework-kotlin-macos-mac.zip&quot;&gt;GitHub&lt;/a&gt;.</source>
          <target state="translated">准备好的项目源代码可以直接从&lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-framework-groovy-macos-mac.zip&quot;&gt;GitHub&lt;/a&gt;下载。&lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-framework-kotlin-macos-mac.zip&quot;&gt;GitHub上&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="83fad008770a134699f224ecf517dfb249b17b87" translate="yes" xml:space="preserve">
          <source>The prepared project sources can be directly downloaded from &lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-shared-lib-groovy-linux.zip&quot;&gt;GitHub&lt;/a&gt;. &lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-shared-lib-groovy-macos.zip&quot;&gt;GitHub&lt;/a&gt;. &lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-shared-lib-groovy-windows.zip&quot;&gt;GitHub&lt;/a&gt;. &lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-shared-lib-kotlin-linux.zip&quot;&gt;GitHub&lt;/a&gt;. &lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-shared-lib-kotlin-macos.zip&quot;&gt;GitHub&lt;/a&gt;. &lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-shared-lib-kotlin-windows.zip&quot;&gt;GitHub&lt;/a&gt;.</source>
          <target state="translated">准备好的项目源代码可以直接从&lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-shared-lib-groovy-linux.zip&quot;&gt;GitHub&lt;/a&gt;下载。&lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-shared-lib-groovy-macos.zip&quot;&gt;GitHub上&lt;/a&gt;。&lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-shared-lib-groovy-windows.zip&quot;&gt;GitHub上&lt;/a&gt;。&lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-shared-lib-kotlin-linux.zip&quot;&gt;GitHub上&lt;/a&gt;。&lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-shared-lib-kotlin-macos.zip&quot;&gt;GitHub上&lt;/a&gt;。&lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-shared-lib-kotlin-windows.zip&quot;&gt;GitHub上&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="47fbf2be0cf9555e26f724c9cc904699b4e6d2c6" translate="yes" xml:space="preserve">
          <source>The prepared project sources can be downloaded directly from &lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-app-groovy-macos-c.zip&quot;&gt;GitHub&lt;/a&gt;. &lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-app-groovy-linux-c.zip&quot;&gt;GitHub&lt;/a&gt;. &lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-app-groovy-windows-c.zip&quot;&gt;GitHub&lt;/a&gt;. &lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-app-kotlin-macos-c.zip&quot;&gt;GitHub&lt;/a&gt;. &lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-app-kotlin-linux-c.zip&quot;&gt;GitHub&lt;/a&gt;. &lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-app-kotlin-windows-c.zip&quot;&gt;GitHub&lt;/a&gt;.</source>
          <target state="translated">准备好的项目源可以直接从&lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-app-groovy-macos-c.zip&quot;&gt;GitHub&lt;/a&gt;下载。&lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-app-groovy-linux-c.zip&quot;&gt;GitHub上&lt;/a&gt;。&lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-app-groovy-windows-c.zip&quot;&gt;GitHub上&lt;/a&gt;。&lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-app-kotlin-macos-c.zip&quot;&gt;GitHub上&lt;/a&gt;。&lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-app-kotlin-linux-c.zip&quot;&gt;GitHub上&lt;/a&gt;。&lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-app-kotlin-windows-c.zip&quot;&gt;GitHub上&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0b884226386a575e859d8ba59646588a18cff524" translate="yes" xml:space="preserve">
          <source>The preset functions return an existing target if there is one. This can be used to configure an existing target:</source>
          <target state="translated">预设功能返回一个现有的目标(如果有)。这可以用来配置一个现有的目标。</target>
        </trans-unit>
        <trans-unit id="94b4a93f08efae43f49ccc9068c6ccc45a749339" translate="yes" xml:space="preserve">
          <source>The primary constructor cannot contain any code. Initialization code can be placed in &lt;strong&gt;initializer blocks&lt;/strong&gt;, which are prefixed with the &lt;em&gt;init&lt;/em&gt; keyword.</source>
          <target state="translated">主构造函数不能包含任何代码。可以将初始化代码放在&lt;strong&gt;初始化器块中&lt;/strong&gt;，这些&lt;strong&gt;块&lt;/strong&gt;以&lt;em&gt;init&lt;/em&gt;关键字为前缀。</target>
        </trans-unit>
        <trans-unit id="9fdf36149a4f79a1bb95fdb86a615c52def92e79" translate="yes" xml:space="preserve">
          <source>The primary constructor needs to have at least one parameter;</source>
          <target state="translated">主构造函数需要有至少一个参数。</target>
        </trans-unit>
        <trans-unit id="da3ee8bb58d5e5b4db4f578cf06329f7adf39108" translate="yes" xml:space="preserve">
          <source>The principles of Keeping the Language Modern and Comfortable Updates suggest that incompatible changes are sometimes necessary, but they should be introduced carefully. Our goal is to make the users aware of upcoming changes well in advance to let them migrate their code comfortably.</source>
          <target state="translated">保持语言的现代性和舒适更新的原则表明,不兼容的变化有时是必要的,但应该谨慎引入。我们的目标是让用户提前意识到即将到来的变化,让他们舒适地迁移他们的代码。</target>
        </trans-unit>
        <trans-unit id="8a9400005c3bca2486ac5d4f71c851ac612c4135" translate="yes" xml:space="preserve">
          <source>The problem</source>
          <target state="translated">问题</target>
        </trans-unit>
        <trans-unit id="9c66b2fe04efcfddbeb39708f916ac0b213e981b" translate="yes" xml:space="preserve">
          <source>The problem is that in Kotlin we can say &lt;code&gt;unboxBase(boxDerived(&quot;s&quot;))&lt;/code&gt;, but in Java that would be impossible, because in Java the class &lt;code&gt;Box&lt;/code&gt; is &lt;em&gt;invariant&lt;/em&gt; in its parameter &lt;code&gt;T&lt;/code&gt;, and thus &lt;code&gt;Box&amp;lt;Derived&amp;gt;&lt;/code&gt; is not a subtype of &lt;code&gt;Box&amp;lt;Base&amp;gt;&lt;/code&gt;. To make it work in Java we'd have to define &lt;code&gt;unboxBase&lt;/code&gt; as follows:</source>
          <target state="translated">问题是在Kotlin中我们可以说 &lt;code&gt;unboxBase(boxDerived(&quot;s&quot;))&lt;/code&gt; ，但是在Java中这是不可能的，因为在Java中，类 &lt;code&gt;Box&lt;/code&gt; 的参数 &lt;code&gt;T&lt;/code&gt; 是&lt;em&gt;不变的&lt;/em&gt;，因此 &lt;code&gt;Box&amp;lt;Derived&amp;gt;&lt;/code&gt; 不是子类型。的 &lt;code&gt;Box&amp;lt;Base&amp;gt;&lt;/code&gt; 。为了使其在Java中工作，我们必须定义 &lt;code&gt;unboxBase&lt;/code&gt; ，如下所示：</target>
        </trans-unit>
        <trans-unit id="d0d37636a32f4cdf2f104260760bfa7761da1ecf" translate="yes" xml:space="preserve">
          <source>The process of building and running the Kotlin application in Android Studio is exactly the same as with Java.</source>
          <target state="translated">在Android Studio中构建和运行Kotlin应用程序的过程与使用Java完全相同。</target>
        </trans-unit>
        <trans-unit id="5333ca5a84bee1fa54c6c2c65a4ed24b1d5a7d39" translate="yes" xml:space="preserve">
          <source>The programming model and APIs remain the same. We can continue to use loops, exception handling, etc. and there's no need to learn a complete set of new APIs</source>
          <target state="translated">编程模型和API保持不变。我们可以继续使用循环、异常处理等,不需要学习一套完整的新的API</target>
        </trans-unit>
        <trans-unit id="cbc23b45ec695a38d5e9af2e658da812853cfa4f" translate="yes" xml:space="preserve">
          <source>The progression starts with the &lt;a href=&quot;from-closed-range#kotlin.ranges.CharProgression.Companion%24fromClosedRange%28kotlin.Char%2C+kotlin.Char%2C+kotlin.Int%29%2FrangeStart&quot;&gt;rangeStart&lt;/a&gt; value and goes toward the &lt;a href=&quot;from-closed-range#kotlin.ranges.CharProgression.Companion%24fromClosedRange%28kotlin.Char%2C+kotlin.Char%2C+kotlin.Int%29%2FrangeEnd&quot;&gt;rangeEnd&lt;/a&gt; value not excluding it, with the specified &lt;a href=&quot;from-closed-range#kotlin.ranges.CharProgression.Companion%24fromClosedRange%28kotlin.Char%2C+kotlin.Char%2C+kotlin.Int%29%2Fstep&quot;&gt;step&lt;/a&gt;. In order to go backwards the &lt;a href=&quot;from-closed-range#kotlin.ranges.CharProgression.Companion%24fromClosedRange%28kotlin.Char%2C+kotlin.Char%2C+kotlin.Int%29%2Fstep&quot;&gt;step&lt;/a&gt; must be negative.</source>
          <target state="translated">进度以&lt;a href=&quot;from-closed-range#kotlin.ranges.CharProgression.Companion%24fromClosedRange%28kotlin.Char%2C+kotlin.Char%2C+kotlin.Int%29%2FrangeStart&quot;&gt;rangeStart&lt;/a&gt;值开始，并以指定的&lt;a href=&quot;from-closed-range#kotlin.ranges.CharProgression.Companion%24fromClosedRange%28kotlin.Char%2C+kotlin.Char%2C+kotlin.Int%29%2Fstep&quot;&gt;step&lt;/a&gt;朝向不排除它的&lt;a href=&quot;from-closed-range#kotlin.ranges.CharProgression.Companion%24fromClosedRange%28kotlin.Char%2C+kotlin.Char%2C+kotlin.Int%29%2FrangeEnd&quot;&gt;rangeEnd&lt;/a&gt;值。为了后退，&lt;a href=&quot;from-closed-range#kotlin.ranges.CharProgression.Companion%24fromClosedRange%28kotlin.Char%2C+kotlin.Char%2C+kotlin.Int%29%2Fstep&quot;&gt;步数&lt;/a&gt;必须为负。</target>
        </trans-unit>
        <trans-unit id="3cfecf27df2864c65a3a1ce3c515f4f228c95a52" translate="yes" xml:space="preserve">
          <source>The progression starts with the &lt;a href=&quot;from-closed-range#kotlin.ranges.CharProgression.Companion%24fromClosedRange(kotlin.Char,%20kotlin.Char,%20kotlin.Int)/rangeStart&quot;&gt;rangeStart&lt;/a&gt; value and goes toward the &lt;a href=&quot;from-closed-range#kotlin.ranges.CharProgression.Companion%24fromClosedRange(kotlin.Char,%20kotlin.Char,%20kotlin.Int)/rangeEnd&quot;&gt;rangeEnd&lt;/a&gt; value not excluding it, with the specified &lt;a href=&quot;from-closed-range#kotlin.ranges.CharProgression.Companion%24fromClosedRange(kotlin.Char,%20kotlin.Char,%20kotlin.Int)/step&quot;&gt;step&lt;/a&gt;. In order to go backwards the &lt;a href=&quot;from-closed-range#kotlin.ranges.CharProgression.Companion%24fromClosedRange(kotlin.Char,%20kotlin.Char,%20kotlin.Int)/step&quot;&gt;step&lt;/a&gt; must be negative.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d272fe15b8cfff505d8d535e47fe9213e3e4bb4" translate="yes" xml:space="preserve">
          <source>The progression starts with the &lt;a href=&quot;from-closed-range#kotlin.ranges.IntProgression.Companion%24fromClosedRange%28kotlin.Int%2C+kotlin.Int%2C+kotlin.Int%29%2FrangeStart&quot;&gt;rangeStart&lt;/a&gt; value and goes toward the &lt;a href=&quot;from-closed-range#kotlin.ranges.IntProgression.Companion%24fromClosedRange%28kotlin.Int%2C+kotlin.Int%2C+kotlin.Int%29%2FrangeEnd&quot;&gt;rangeEnd&lt;/a&gt; value not excluding it, with the specified &lt;a href=&quot;from-closed-range#kotlin.ranges.IntProgression.Companion%24fromClosedRange%28kotlin.Int%2C+kotlin.Int%2C+kotlin.Int%29%2Fstep&quot;&gt;step&lt;/a&gt;. In order to go backwards the &lt;a href=&quot;from-closed-range#kotlin.ranges.IntProgression.Companion%24fromClosedRange%28kotlin.Int%2C+kotlin.Int%2C+kotlin.Int%29%2Fstep&quot;&gt;step&lt;/a&gt; must be negative.</source>
          <target state="translated">进度以&lt;a href=&quot;from-closed-range#kotlin.ranges.IntProgression.Companion%24fromClosedRange%28kotlin.Int%2C+kotlin.Int%2C+kotlin.Int%29%2FrangeStart&quot;&gt;rangeStart&lt;/a&gt;值开始，并以指定的&lt;a href=&quot;from-closed-range#kotlin.ranges.IntProgression.Companion%24fromClosedRange%28kotlin.Int%2C+kotlin.Int%2C+kotlin.Int%29%2Fstep&quot;&gt;step&lt;/a&gt;朝向不排除它的&lt;a href=&quot;from-closed-range#kotlin.ranges.IntProgression.Companion%24fromClosedRange%28kotlin.Int%2C+kotlin.Int%2C+kotlin.Int%29%2FrangeEnd&quot;&gt;rangeEnd&lt;/a&gt;值。为了后退，&lt;a href=&quot;from-closed-range#kotlin.ranges.IntProgression.Companion%24fromClosedRange%28kotlin.Int%2C+kotlin.Int%2C+kotlin.Int%29%2Fstep&quot;&gt;步数&lt;/a&gt;必须为负。</target>
        </trans-unit>
        <trans-unit id="2c4a6206c951ddbe8fde808b1243da3bfe938dbc" translate="yes" xml:space="preserve">
          <source>The progression starts with the &lt;a href=&quot;from-closed-range#kotlin.ranges.IntProgression.Companion%24fromClosedRange(kotlin.Int,%20kotlin.Int,%20kotlin.Int)/rangeStart&quot;&gt;rangeStart&lt;/a&gt; value and goes toward the &lt;a href=&quot;from-closed-range#kotlin.ranges.IntProgression.Companion%24fromClosedRange(kotlin.Int,%20kotlin.Int,%20kotlin.Int)/rangeEnd&quot;&gt;rangeEnd&lt;/a&gt; value not excluding it, with the specified &lt;a href=&quot;from-closed-range#kotlin.ranges.IntProgression.Companion%24fromClosedRange(kotlin.Int,%20kotlin.Int,%20kotlin.Int)/step&quot;&gt;step&lt;/a&gt;. In order to go backwards the &lt;a href=&quot;from-closed-range#kotlin.ranges.IntProgression.Companion%24fromClosedRange(kotlin.Int,%20kotlin.Int,%20kotlin.Int)/step&quot;&gt;step&lt;/a&gt; must be negative.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84ee7e5946067792bd4d0c03b228099a9bd9d9cd" translate="yes" xml:space="preserve">
          <source>The progression starts with the &lt;a href=&quot;from-closed-range#kotlin.ranges.LongProgression.Companion%24fromClosedRange%28kotlin.Long%2C+kotlin.Long%2C+kotlin.Long%29%2FrangeStart&quot;&gt;rangeStart&lt;/a&gt; value and goes toward the &lt;a href=&quot;from-closed-range#kotlin.ranges.LongProgression.Companion%24fromClosedRange%28kotlin.Long%2C+kotlin.Long%2C+kotlin.Long%29%2FrangeEnd&quot;&gt;rangeEnd&lt;/a&gt; value not excluding it, with the specified &lt;a href=&quot;from-closed-range#kotlin.ranges.LongProgression.Companion%24fromClosedRange%28kotlin.Long%2C+kotlin.Long%2C+kotlin.Long%29%2Fstep&quot;&gt;step&lt;/a&gt;. In order to go backwards the &lt;a href=&quot;from-closed-range#kotlin.ranges.LongProgression.Companion%24fromClosedRange%28kotlin.Long%2C+kotlin.Long%2C+kotlin.Long%29%2Fstep&quot;&gt;step&lt;/a&gt; must be negative.</source>
          <target state="translated">进度以&lt;a href=&quot;from-closed-range#kotlin.ranges.LongProgression.Companion%24fromClosedRange%28kotlin.Long%2C+kotlin.Long%2C+kotlin.Long%29%2FrangeStart&quot;&gt;rangeStart&lt;/a&gt;值开始，并以指定的&lt;a href=&quot;from-closed-range#kotlin.ranges.LongProgression.Companion%24fromClosedRange%28kotlin.Long%2C+kotlin.Long%2C+kotlin.Long%29%2Fstep&quot;&gt;step&lt;/a&gt;朝向不排除它的&lt;a href=&quot;from-closed-range#kotlin.ranges.LongProgression.Companion%24fromClosedRange%28kotlin.Long%2C+kotlin.Long%2C+kotlin.Long%29%2FrangeEnd&quot;&gt;rangeEnd&lt;/a&gt;值。为了后退，&lt;a href=&quot;from-closed-range#kotlin.ranges.LongProgression.Companion%24fromClosedRange%28kotlin.Long%2C+kotlin.Long%2C+kotlin.Long%29%2Fstep&quot;&gt;步数&lt;/a&gt;必须为负。</target>
        </trans-unit>
        <trans-unit id="d9d863d5adbc27747b9056e74161d14934d72f8c" translate="yes" xml:space="preserve">
          <source>The progression starts with the &lt;a href=&quot;from-closed-range#kotlin.ranges.LongProgression.Companion%24fromClosedRange(kotlin.Long,%20kotlin.Long,%20kotlin.Long)/rangeStart&quot;&gt;rangeStart&lt;/a&gt; value and goes toward the &lt;a href=&quot;from-closed-range#kotlin.ranges.LongProgression.Companion%24fromClosedRange(kotlin.Long,%20kotlin.Long,%20kotlin.Long)/rangeEnd&quot;&gt;rangeEnd&lt;/a&gt; value not excluding it, with the specified &lt;a href=&quot;from-closed-range#kotlin.ranges.LongProgression.Companion%24fromClosedRange(kotlin.Long,%20kotlin.Long,%20kotlin.Long)/step&quot;&gt;step&lt;/a&gt;. In order to go backwards the &lt;a href=&quot;from-closed-range#kotlin.ranges.LongProgression.Companion%24fromClosedRange(kotlin.Long,%20kotlin.Long,%20kotlin.Long)/step&quot;&gt;step&lt;/a&gt; must be negative.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d8b7627f24846e9a31abff3ae25964002a498bf" translate="yes" xml:space="preserve">
          <source>The progression starts with the &lt;a href=&quot;from-closed-range#kotlin.ranges.UIntProgression.Companion%24fromClosedRange%28kotlin.UInt%2C+kotlin.UInt%2C+kotlin.Int%29%2FrangeStart&quot;&gt;rangeStart&lt;/a&gt; value and goes toward the &lt;a href=&quot;from-closed-range#kotlin.ranges.UIntProgression.Companion%24fromClosedRange%28kotlin.UInt%2C+kotlin.UInt%2C+kotlin.Int%29%2FrangeEnd&quot;&gt;rangeEnd&lt;/a&gt; value not excluding it, with the specified &lt;a href=&quot;from-closed-range#kotlin.ranges.UIntProgression.Companion%24fromClosedRange%28kotlin.UInt%2C+kotlin.UInt%2C+kotlin.Int%29%2Fstep&quot;&gt;step&lt;/a&gt;. In order to go backwards the &lt;a href=&quot;from-closed-range#kotlin.ranges.UIntProgression.Companion%24fromClosedRange%28kotlin.UInt%2C+kotlin.UInt%2C+kotlin.Int%29%2Fstep&quot;&gt;step&lt;/a&gt; must be negative.</source>
          <target state="translated">进度以&lt;a href=&quot;from-closed-range#kotlin.ranges.UIntProgression.Companion%24fromClosedRange%28kotlin.UInt%2C+kotlin.UInt%2C+kotlin.Int%29%2FrangeStart&quot;&gt;rangeStart&lt;/a&gt;值开始，并以指定的&lt;a href=&quot;from-closed-range#kotlin.ranges.UIntProgression.Companion%24fromClosedRange%28kotlin.UInt%2C+kotlin.UInt%2C+kotlin.Int%29%2Fstep&quot;&gt;step&lt;/a&gt;朝向不排除它的&lt;a href=&quot;from-closed-range#kotlin.ranges.UIntProgression.Companion%24fromClosedRange%28kotlin.UInt%2C+kotlin.UInt%2C+kotlin.Int%29%2FrangeEnd&quot;&gt;rangeEnd&lt;/a&gt;值。为了后退，&lt;a href=&quot;from-closed-range#kotlin.ranges.UIntProgression.Companion%24fromClosedRange%28kotlin.UInt%2C+kotlin.UInt%2C+kotlin.Int%29%2Fstep&quot;&gt;步数&lt;/a&gt;必须为负。</target>
        </trans-unit>
        <trans-unit id="890067d4bb4a41e1198a024fd7c7c538b8728df3" translate="yes" xml:space="preserve">
          <source>The progression starts with the &lt;a href=&quot;from-closed-range#kotlin.ranges.UIntProgression.Companion%24fromClosedRange(kotlin.UInt,%20kotlin.UInt,%20kotlin.Int)/rangeStart&quot;&gt;rangeStart&lt;/a&gt; value and goes toward the &lt;a href=&quot;from-closed-range#kotlin.ranges.UIntProgression.Companion%24fromClosedRange(kotlin.UInt,%20kotlin.UInt,%20kotlin.Int)/rangeEnd&quot;&gt;rangeEnd&lt;/a&gt; value not excluding it, with the specified &lt;a href=&quot;from-closed-range#kotlin.ranges.UIntProgression.Companion%24fromClosedRange(kotlin.UInt,%20kotlin.UInt,%20kotlin.Int)/step&quot;&gt;step&lt;/a&gt;. In order to go backwards the &lt;a href=&quot;from-closed-range#kotlin.ranges.UIntProgression.Companion%24fromClosedRange(kotlin.UInt,%20kotlin.UInt,%20kotlin.Int)/step&quot;&gt;step&lt;/a&gt; must be negative.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc7d38b12995812c4efea617bb206ec4460e9ccc" translate="yes" xml:space="preserve">
          <source>The progression starts with the &lt;a href=&quot;from-closed-range#kotlin.ranges.ULongProgression.Companion%24fromClosedRange%28kotlin.ULong%2C+kotlin.ULong%2C+kotlin.Long%29%2FrangeStart&quot;&gt;rangeStart&lt;/a&gt; value and goes toward the &lt;a href=&quot;from-closed-range#kotlin.ranges.ULongProgression.Companion%24fromClosedRange%28kotlin.ULong%2C+kotlin.ULong%2C+kotlin.Long%29%2FrangeEnd&quot;&gt;rangeEnd&lt;/a&gt; value not excluding it, with the specified &lt;a href=&quot;from-closed-range#kotlin.ranges.ULongProgression.Companion%24fromClosedRange%28kotlin.ULong%2C+kotlin.ULong%2C+kotlin.Long%29%2Fstep&quot;&gt;step&lt;/a&gt;. In order to go backwards the &lt;a href=&quot;from-closed-range#kotlin.ranges.ULongProgression.Companion%24fromClosedRange%28kotlin.ULong%2C+kotlin.ULong%2C+kotlin.Long%29%2Fstep&quot;&gt;step&lt;/a&gt; must be negative.</source>
          <target state="translated">进度以&lt;a href=&quot;from-closed-range#kotlin.ranges.ULongProgression.Companion%24fromClosedRange%28kotlin.ULong%2C+kotlin.ULong%2C+kotlin.Long%29%2FrangeStart&quot;&gt;rangeStart&lt;/a&gt;值开始，并以指定的&lt;a href=&quot;from-closed-range#kotlin.ranges.ULongProgression.Companion%24fromClosedRange%28kotlin.ULong%2C+kotlin.ULong%2C+kotlin.Long%29%2Fstep&quot;&gt;step&lt;/a&gt;朝向不排除它的&lt;a href=&quot;from-closed-range#kotlin.ranges.ULongProgression.Companion%24fromClosedRange%28kotlin.ULong%2C+kotlin.ULong%2C+kotlin.Long%29%2FrangeEnd&quot;&gt;rangeEnd&lt;/a&gt;值。为了后退，&lt;a href=&quot;from-closed-range#kotlin.ranges.ULongProgression.Companion%24fromClosedRange%28kotlin.ULong%2C+kotlin.ULong%2C+kotlin.Long%29%2Fstep&quot;&gt;步数&lt;/a&gt;必须为负。</target>
        </trans-unit>
        <trans-unit id="cfd566a721eacfbba5c78dd8988340e1f6d111e0" translate="yes" xml:space="preserve">
          <source>The progression starts with the &lt;a href=&quot;from-closed-range#kotlin.ranges.ULongProgression.Companion%24fromClosedRange(kotlin.ULong,%20kotlin.ULong,%20kotlin.Long)/rangeStart&quot;&gt;rangeStart&lt;/a&gt; value and goes toward the &lt;a href=&quot;from-closed-range#kotlin.ranges.ULongProgression.Companion%24fromClosedRange(kotlin.ULong,%20kotlin.ULong,%20kotlin.Long)/rangeEnd&quot;&gt;rangeEnd&lt;/a&gt; value not excluding it, with the specified &lt;a href=&quot;from-closed-range#kotlin.ranges.ULongProgression.Companion%24fromClosedRange(kotlin.ULong,%20kotlin.ULong,%20kotlin.Long)/step&quot;&gt;step&lt;/a&gt;. In order to go backwards the &lt;a href=&quot;from-closed-range#kotlin.ranges.ULongProgression.Companion%24fromClosedRange(kotlin.ULong,%20kotlin.ULong,%20kotlin.Long)/step&quot;&gt;step&lt;/a&gt; must be negative.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f35887cf67bb91d63b75657011139a4b8f31176b" translate="yes" xml:space="preserve">
          <source>The project file configures the C interop as an additional step of the build. Let's move the &lt;code&gt;interop.def&lt;/code&gt; file to the &lt;code&gt;src/nativeInterop/cinterop&lt;/code&gt; directory. Gradle recommends using conventions instead of configurations, for example, the source files are expected to be in the &lt;code&gt;src/nativeMain/kotlin&lt;/code&gt; folder. By default, all the symbols from C are imported to the &lt;code&gt;interop&lt;/code&gt; package, we may want to import the whole package in our &lt;code&gt;.kt&lt;/code&gt; files. Check out the &lt;a href=&quot;../../reference/building-mpp-with-gradle&quot;&gt;kotlin-multiplatform&lt;/a&gt; plugin documentation to learn about all the different ways you could configure it.</source>
          <target state="translated">项目文件将C互操作配置为构建的附加步骤。让我们将 &lt;code&gt;interop.def&lt;/code&gt; 文件移动到 &lt;code&gt;src/nativeInterop/cinterop&lt;/code&gt; 目录。 Gradle建议使用约定而不是配置，例如，源文件应位于 &lt;code&gt;src/nativeMain/kotlin&lt;/code&gt; 文件夹中。默认情况下，所有来自C的符号都导入到 &lt;code&gt;interop&lt;/code&gt; 包中，我们可能希望将整个包导入到我们的 &lt;code&gt;.kt&lt;/code&gt; 文件中。查看&lt;a href=&quot;../../reference/building-mpp-with-gradle&quot;&gt;kotlin-multiplatform&lt;/a&gt;插件文档，以了解配置它的所有不同方式。</target>
        </trans-unit>
        <trans-unit id="c7f7aa55f08a335c3d3db3f646f14c719c538320" translate="yes" xml:space="preserve">
          <source>The project file configures the C interop as an additional step of the build. Let's move the &lt;code&gt;interop.def&lt;/code&gt; file to the &lt;code&gt;src/nativeInterop/cinterop&lt;/code&gt; directory. Gradle recommends using conventions instead of configurations, for example, the source files are expected to be in the &lt;code&gt;src/nativeMain/kotlin&lt;/code&gt; folder. By default, all the symbols from C are imported to the &lt;code&gt;interop&lt;/code&gt; package, we may want to import the whole package in our &lt;code&gt;.kt&lt;/code&gt; files. Check out the &lt;a href=&quot;../../reference/mpp-discover-project#multiplatform-plugin&quot;&gt;kotlin-multiplatform&lt;/a&gt; plugin documentation to learn about all the different ways you could configure it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04a29f21fc01df00a35820fecf66f137da298242" translate="yes" xml:space="preserve">
          <source>The project is ready. The next step is to open it in IntelliJ IDEA. For advanced build scenarios, it is recommended to refer to the &lt;a href=&quot;../../reference/building-mpp-with-gradle#setting-up-a-multiplatform-project&quot;&gt;more detailed&lt;/a&gt; documentation.</source>
          <target state="translated">项目准备就绪。下一步是在IntelliJ IDEA中打开它。对于高级构建方案，建议参考&lt;a href=&quot;../../reference/building-mpp-with-gradle#setting-up-a-multiplatform-project&quot;&gt;更详细的&lt;/a&gt;文档。</target>
        </trans-unit>
        <trans-unit id="b358195ade68af7da060ed2c5bd98eb5f625c0a9" translate="yes" xml:space="preserve">
          <source>The project source roots</source>
          <target state="translated">项目源根</target>
        </trans-unit>
        <trans-unit id="6b692a2a5504099d52b9ee1d8cd9e82682b0438b" translate="yes" xml:space="preserve">
          <source>The project structure looks like this:</source>
          <target state="translated">项目结构是这样的。</target>
        </trans-unit>
        <trans-unit id="85001da371d8ff3d4160eee8edd3719f9a8a82c8" translate="yes" xml:space="preserve">
          <source>The project's source files are unchanged.</source>
          <target state="translated">项目的源文件没有变化。</target>
        </trans-unit>
        <trans-unit id="fe6d1020447b5badd7227ed9268d67a33471daca" translate="yes" xml:space="preserve">
          <source>The property that can be used as a placeholder for statements and values that are defined in JavaScript.</source>
          <target state="translated">可用作JavaScript中定义的语句和值的占位符的属性。</target>
        </trans-unit>
        <trans-unit id="fe5ea5ce74d05b50ab08ac3eaf5980cd10f01114" translate="yes" xml:space="preserve">
          <source>The property which this accessor is originated from.</source>
          <target state="translated">这个配件的来源的属性。</target>
        </trans-unit>
        <trans-unit id="f478ed7d5b12b6f5e34c37814b287211378258c6" translate="yes" xml:space="preserve">
          <source>The provisions of the &lt;a href=&quot;kotlin-evolution&quot;&gt;Kotlin evolution policy&lt;/a&gt; fully apply only to components that have reached Full Stability (FS). From that point on incompatible changes have to be approved by the Language Committee.</source>
          <target state="translated">&lt;a href=&quot;kotlin-evolution&quot;&gt;Kotlin进化政策&lt;/a&gt;的规定完全仅适用于已达到完全稳定性（FS）的组件。从那时起，不兼容的更改必须由语言委员会批准。</target>
        </trans-unit>
        <trans-unit id="4e0268d689de7d5f78e70c6cb1e82a66dc683856" translate="yes" xml:space="preserve">
          <source>The publication of this target is handled by the Kotlin plugin and doesn't require the steps that are specific to the Java plugin, such as manually creating a publication and configuring it as &lt;code&gt;from(components.java)&lt;/code&gt;.</source>
          <target state="translated">该目标的发布由Kotlin插件处理，不需要特定于Java插件的步骤，例如手动创建发布并将其配置为 &lt;code&gt;from(components.java)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="38341133c8abc06ea8b313769f8407419006fee4" translate="yes" xml:space="preserve">
          <source>The purpose of this code is to write out some text in the console. In order to use this from the browser, load it, preferably from inside an HTML page:</source>
          <target state="translated">这段代码的目的是在控制台中写出一些文本。为了在浏览器中使用,最好从HTML页面中加载它。</target>
        </trans-unit>
        <trans-unit id="dc84bc4a3671f7fd39fcbdb5d811a4f7dfb04fdc" translate="yes" xml:space="preserve">
          <source>The quickest way to try out C API mapping is to have all C declarations in the &lt;code&gt;interop.def&lt;/code&gt; file, without creating any &lt;code&gt;.h&lt;/code&gt; of &lt;code&gt;.c&lt;/code&gt; files at all. Then place the C declarations in a &lt;code&gt;.def&lt;/code&gt; file after the special &lt;code&gt;---&lt;/code&gt; separator line:</source>
          <target state="translated">尝试C API映射的最快的方法是在所有的C声明 &lt;code&gt;interop.def&lt;/code&gt; 文件，而不会产生任何 &lt;code&gt;.h&lt;/code&gt; 的 &lt;code&gt;.c&lt;/code&gt; 的所有文件。然后将C声明放在特殊的 &lt;code&gt;---&lt;/code&gt; 分隔符行之后的 &lt;code&gt;.def&lt;/code&gt; 文件中：</target>
        </trans-unit>
        <trans-unit id="086ba4582c0f9ff5d704a53067f7ea26f2bef36a" translate="yes" xml:space="preserve">
          <source>The range of indices in the input string where group was captured.</source>
          <target state="translated">输入字符串中捕获组的索引范围。</target>
        </trans-unit>
        <trans-unit id="d16563c64c4aedfc780b010fa9c5624f673175d2" translate="yes" xml:space="preserve">
          <source>The range of indices in the original string where match was captured.</source>
          <target state="translated">匹配的原始字符串中的索引范围。</target>
        </trans-unit>
        <trans-unit id="199d1e88f27ba9b05b8adc73d8d822df0cadd36a" translate="yes" xml:space="preserve">
          <source>The read-only collection types are &lt;a href=&quot;generics#variance&quot;&gt;covariant&lt;/a&gt;. This means that, if a &lt;code&gt;Rectangle&lt;/code&gt; class inherits from &lt;code&gt;Shape&lt;/code&gt;, you can use a &lt;code&gt;List&amp;lt;Rectangle&amp;gt;&lt;/code&gt; anywhere the &lt;code&gt;List&amp;lt;Shape&amp;gt;&lt;/code&gt; is required. In other words, the collection types have the same subtyping relationship as the element types. Maps are covariant on the value type, but not on the key type.</source>
          <target state="translated">只读的集合类型是&lt;a href=&quot;generics#variance&quot;&gt;covariant&lt;/a&gt;。这意味着，如果一个 &lt;code&gt;Rectangle&lt;/code&gt; 从类继承 &lt;code&gt;Shape&lt;/code&gt; ，你可以使用一个 &lt;code&gt;List&amp;lt;Rectangle&amp;gt;&lt;/code&gt; 的任何位置 &lt;code&gt;List&amp;lt;Shape&amp;gt;&lt;/code&gt; 是必需的。换句话说，集合类型与元素类型具有相同的子类型关系。映射在值类型上是协变的，但在键类型上不是。</target>
        </trans-unit>
        <trans-unit id="2ddb83b3e5eaf3228b8ed04e27d5be844d1ede7b" translate="yes" xml:space="preserve">
          <source>The reason we're seeing the actual output is because the call &lt;code&gt;curl_easy_perform&lt;/code&gt; prints the result to the standard output. We could hide this using &lt;code&gt;curl_easy_setopt&lt;/code&gt;.</source>
          <target state="translated">我们看到实际输出的原因是因为调用 &lt;code&gt;curl_easy_perform&lt;/code&gt; 将结果打印到标准输出。我们可以使用 &lt;code&gt;curl_easy_setopt&lt;/code&gt; 隐藏它。</target>
        </trans-unit>
        <trans-unit id="4670c1839cea0120059e336f30de1dda186179ab" translate="yes" xml:space="preserve">
          <source>The recommended way to use Kotlin/JS is via the &lt;code&gt;kotlin.js&lt;/code&gt; and &lt;code&gt;kotlin.multiplatform&lt;/code&gt; Gradle plugins. They provide a central and convenient way to set up and control Kotlin projects targeting JavaScript. This includes essential functionality such as controlling the bundling of your application, adding JavaScript dependencies directly from npm, and more. To get an overview of the available options, check out the &lt;a href=&quot;js-project-setup&quot;&gt;Kotlin/JS project setup&lt;/a&gt; documentation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58ca5ea2bf2b7e6112a4ed6c521b74a4fb8e1b96" translate="yes" xml:space="preserve">
          <source>The reference is a value of type &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.reflect/-k-class/index&quot;&gt;KClass&lt;/a&gt;.</source>
          <target state="translated">引用是类型&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.reflect/-k-class/index&quot;&gt;KClass&lt;/a&gt;的值。</target>
        </trans-unit>
        <trans-unit id="225d32a1d2d879830740b8e0770ecbbb02de2cc7" translate="yes" xml:space="preserve">
          <source>The referenced value. Gets the value or sets the new value. If new value is not null, and &lt;code&gt;this&lt;/code&gt; is frozen - it must be frozen or permanent object.</source>
          <target state="translated">参考值。获取值或设置新值。如果新的值不为空，而 &lt;code&gt;this&lt;/code&gt; 是冷冻-它必须是冷冻或永久的对象。</target>
        </trans-unit>
        <trans-unit id="9e1c9e946585f6c5b784f91adc26c58c91e5a3c2" translate="yes" xml:space="preserve">
          <source>The referenced value. Gets the value or sets the new value. If new value is not null, it must be frozen or permanent object.</source>
          <target state="translated">引用的值。获取值或设置新值。如果新值不是null,则必须是冻结或永久对象。</target>
        </trans-unit>
        <trans-unit id="04f24df5fbabe6af37ab1161e95151a96c9196e9" translate="yes" xml:space="preserve">
          <source>The repositories where the library will be published are added via the &lt;code&gt;repositories&lt;/code&gt; block in the &lt;code&gt;publishing { ... }&lt;/code&gt; DSL, as explained in &lt;a href=&quot;https://docs.gradle.org/current/userguide/publishing_maven.html#publishing_maven:repositories&quot;&gt;Maven Publish Plugin. Repositories&lt;/a&gt;.</source>
          <target state="translated">如&lt;a href=&quot;https://docs.gradle.org/current/userguide/publishing_maven.html#publishing_maven:repositories&quot;&gt;Maven Publish Plugin&lt;/a&gt;中所述，将通过 &lt;code&gt;publishing { ... }&lt;/code&gt; DSL中的 &lt;code&gt;repositories&lt;/code&gt; 块添加将要发布库的存储库。仓库。</target>
        </trans-unit>
        <trans-unit id="7ffbb195d8e128e52d788e2edb39be54dd761c55" translate="yes" xml:space="preserve">
          <source>The rest of the procedure works in exactly the same way as in Java.</source>
          <target state="translated">存储过程的其余部分与Java中的工作方式完全相同。</target>
        </trans-unit>
        <trans-unit id="81a9c69ffb22a2342532cf8251cc7d0415b9dbb2" translate="yes" xml:space="preserve">
          <source>The result is an object which represents a reference to the property (the &quot;Platonic ideal&quot; property, not a property on a particular instance). There's a type hierarchy for property objects: the base interface is &lt;code&gt;KProperty&lt;/code&gt;, which lets you get metadata about the property, such as its name and type. If you want to use the property object to read or modify the property's value in an object, you need to use a subinterface that specifies what kind of property it is. Immutable properties typically are &lt;code&gt;KProperty1&amp;lt;R, V&amp;gt;&lt;/code&gt;, and mutable properties typically are &lt;code&gt;KMutableProperty1&amp;lt;R, V&amp;gt;&lt;/code&gt;. Both of these are generic interfaces, with &lt;code&gt;R&lt;/code&gt; being the receiver type (the type on which the property is declared, in this case &lt;code&gt;Person&lt;/code&gt;) and &lt;code&gt;V&lt;/code&gt; being the type of the property's value.</source>
          <target state="translated">结果是一个对象，该对象表示对该属性的引用（&amp;ldquo;柏拉图理想&amp;rdquo;属性，而不是特定实例上的属性）。属性对象有一个类型层次结构：基本接口是 &lt;code&gt;KProperty&lt;/code&gt; ，它使您可以获取有关属性的元数据，例如名称和类型。如果要使用属性对象读取或修改对象中属性的值，则需要使用一个子接口来指定它是什么类型的属性。不变属性通常是 &lt;code&gt;KProperty1&amp;lt;R, V&amp;gt;&lt;/code&gt; ，可变属性通常是 &lt;code&gt;KMutableProperty1&amp;lt;R, V&amp;gt;&lt;/code&gt; 。这两个都是通用接口，其中 &lt;code&gt;R&lt;/code&gt; 是接收方类型（在该属性上声明属性的类型，在这种情况下为 &lt;code&gt;Person&lt;/code&gt; ），而 &lt;code&gt;V&lt;/code&gt; 是属性值的类型。</target>
        </trans-unit>
        <trans-unit id="1a8aae926c8fa4cd902ab72788ba84f110e52d36" translate="yes" xml:space="preserve">
          <source>The result is computed as &lt;code&gt;r = this - (q * divisor)&lt;/code&gt; where &lt;code&gt;q&lt;/code&gt; is the quotient of division rounded to the nearest integer, &lt;code&gt;q = round(this / other)&lt;/code&gt;.</source>
          <target state="translated">计算结果为 &lt;code&gt;r = this - (q * divisor)&lt;/code&gt; ，其中 &lt;code&gt;q&lt;/code&gt; 是四舍五入到最接近整数的除法商， &lt;code&gt;q = round(this / other)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8346187656aa601c46c1b882160101b5d70d1783" translate="yes" xml:space="preserve">
          <source>The result is going to be:</source>
          <target state="translated">结果是要。</target>
        </trans-unit>
        <trans-unit id="f757614cb2200a5a31db5b9a50190e9f1a783287" translate="yes" xml:space="preserve">
          <source>The result is the same, but this code uses only non-blocking &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/delay.html&quot;&gt;delay&lt;/a&gt;. The main thread invoking &lt;code&gt;runBlocking&lt;/code&gt;&lt;em&gt;blocks&lt;/em&gt; until the coroutine inside &lt;code&gt;runBlocking&lt;/code&gt; completes.</source>
          <target state="translated">结果是相同的，但是此代码仅使用非阻塞&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/delay.html&quot;&gt;延迟&lt;/a&gt;。主线程调用 &lt;code&gt;runBlocking&lt;/code&gt; &lt;em&gt;块&lt;/em&gt;，直到内部的协同程序 &lt;code&gt;runBlocking&lt;/code&gt; 完成。</target>
        </trans-unit>
        <trans-unit id="80513416e38e21b1cd6b19983bdbc1cd0f8dbc1d" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;minus&lt;/code&gt; contains the elements of the original collection &lt;em&gt;except&lt;/em&gt; the elements from the second operand. If it's an element, &lt;code&gt;minus&lt;/code&gt; removes its &lt;em&gt;first&lt;/em&gt; occurrence; if it's a collection, &lt;em&gt;all&lt;/em&gt; occurrences of its elements are removed.</source>
          <target state="translated">&lt;code&gt;minus&lt;/code&gt; 的结果包含原始集合的元素，但第二个操作数中的元素&lt;em&gt;除外&lt;/em&gt;。如果它是一个元素， &lt;code&gt;minus&lt;/code&gt; 会删除它的&lt;em&gt;第一个&lt;/em&gt;匹配项。如果是集合，则删除&lt;em&gt;所有&lt;/em&gt;出现的元素。</target>
        </trans-unit>
        <trans-unit id="9f4386a5cc0897ae566404e34449e10c9271784f" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;plus&lt;/code&gt; contains the elements from the original collection &lt;em&gt;and&lt;/em&gt; from the second operand.</source>
          <target state="translated">&lt;code&gt;plus&lt;/code&gt; 的结果包含原始集合&lt;em&gt;和&lt;/em&gt;第二个操作数中的元素。</target>
        </trans-unit>
        <trans-unit id="ff8add7f5e14fd024c26ef191ab483a18b621fed" translate="yes" xml:space="preserve">
          <source>The result of the future computation. Blocks execution until the future is ready. Second attempt to get will result in an error.</source>
          <target state="translated">未来计算的结果。阻止执行,直到未来的计算准备好。第二次尝试获取将导致错误。</target>
        </trans-unit>
        <trans-unit id="b0a33939298c1573b79334a09954b9afb450d438" translate="yes" xml:space="preserve">
          <source>The result of this code is quite interesting, so we'll analyze it in mode detail:</source>
          <target state="translated">这段代码的结果是相当有趣的,所以我们将详细分析它的模式。</target>
        </trans-unit>
        <trans-unit id="4a889b01b76fad01cdae52fa6c7d371792173b90" translate="yes" xml:space="preserve">
          <source>The result of this code is quite interesting, so we'll analyze it in more detail:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a92982b6e3242403fa82d0db42fdb4534028b312" translate="yes" xml:space="preserve">
          <source>The result of this code is:</source>
          <target state="translated">该代码的结果是:</target>
        </trans-unit>
        <trans-unit id="ee6868c39ff4d2539255b06db5a2381813300a75" translate="yes" xml:space="preserve">
          <source>The result of this code:</source>
          <target state="translated">这个代码的结果。</target>
        </trans-unit>
        <trans-unit id="4844d20ae5c2024023a55c2b6b3214cb6ce72593" translate="yes" xml:space="preserve">
          <source>The resulting &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/util/SortedMap.html&quot;&gt;SortedMap&lt;/a&gt; determines the equality and order of keys according to their natural sorting order.</source>
          <target state="translated">生成的&lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/util/SortedMap.html&quot;&gt;SortedMap&lt;/a&gt;根据键的自然排序顺序确定键的相等性和顺序。</target>
        </trans-unit>
        <trans-unit id="e25355ad3b686053cc1bc487b49186167f01eccb" translate="yes" xml:space="preserve">
          <source>The resulting &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/SortedMap.html&quot;&gt;SortedMap&lt;/a&gt; determines the equality and order of keys according to the sorting order provided by the given &lt;a href=&quot;sorted-map-of#kotlin.collections%24sortedMapOf(java.util.Comparator((kotlin.collections.sortedMapOf.K)),%20kotlin.Array((kotlin.Pair((kotlin.collections.sortedMapOf.K,%20kotlin.collections.sortedMapOf.V)))))/comparator&quot;&gt;comparator&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="634514a1676e5366bef12944cb3543ffee02d086" translate="yes" xml:space="preserve">
          <source>The resulting &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/SortedMap.html&quot;&gt;SortedMap&lt;/a&gt; determines the equality and order of keys according to their natural sorting order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f890bef6e41ea49023cd4e145c9ac8e02777347" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Byte&lt;/code&gt; value has the same binary representation as this &lt;code&gt;UByte&lt;/code&gt; value.</source>
          <target state="translated">所得的 &lt;code&gt;Byte&lt;/code&gt; 值与此 &lt;code&gt;UByte&lt;/code&gt; 值具有相同的二进制表示形式。</target>
        </trans-unit>
        <trans-unit id="bcc21fce83c8a76fb70c4188dec066655dc99e5f" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Byte&lt;/code&gt; value is equal to &lt;code&gt;this.toInt().toByte()&lt;/code&gt;.</source>
          <target state="translated">生成的 &lt;code&gt;Byte&lt;/code&gt; 值等于 &lt;code&gt;this.toInt().toByte()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="500fd389152dfac3d3a3bdf516db69049b6112d1" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Byte&lt;/code&gt; value is represented by the least significant 8 bits of this &lt;code&gt;Int&lt;/code&gt; value.</source>
          <target state="translated">结果 &lt;code&gt;Byte&lt;/code&gt; 值由该 &lt;code&gt;Int&lt;/code&gt; 值的最低有效8位表示。</target>
        </trans-unit>
        <trans-unit id="f5d708d0dd756dc92bd87189470b9a3b0f187bad" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Byte&lt;/code&gt; value is represented by the least significant 8 bits of this &lt;code&gt;Long&lt;/code&gt; value.</source>
          <target state="translated">结果 &lt;code&gt;Byte&lt;/code&gt; 值由此 &lt;code&gt;Long&lt;/code&gt; 值的最低有效8位表示。</target>
        </trans-unit>
        <trans-unit id="f1c617d1ad1ce5e0250376516d3fc7acee8c76a7" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Byte&lt;/code&gt; value is represented by the least significant 8 bits of this &lt;code&gt;Short&lt;/code&gt; value.</source>
          <target state="translated">结果 &lt;code&gt;Byte&lt;/code&gt; 值由该 &lt;code&gt;Short&lt;/code&gt; 值的最低8位表示。</target>
        </trans-unit>
        <trans-unit id="3c0aa6565c5cc7948d96b6aa45e671f5d970085c" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Byte&lt;/code&gt; value is represented by the least significant 8 bits of this &lt;code&gt;UInt&lt;/code&gt; value. Note that the resulting &lt;code&gt;Byte&lt;/code&gt; value may be negative.</source>
          <target state="translated">结果 &lt;code&gt;Byte&lt;/code&gt; 值由该 &lt;code&gt;UInt&lt;/code&gt; 值的最低有效8位表示。请注意，结果 &lt;code&gt;Byte&lt;/code&gt; 值可能为负。</target>
        </trans-unit>
        <trans-unit id="dd46bb58530a520cf29001659a58a32130329b50" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Byte&lt;/code&gt; value is represented by the least significant 8 bits of this &lt;code&gt;ULong&lt;/code&gt; value. Note that the resulting &lt;code&gt;Byte&lt;/code&gt; value may be negative.</source>
          <target state="translated">结果 &lt;code&gt;Byte&lt;/code&gt; 值由该 &lt;code&gt;ULong&lt;/code&gt; 值的最低有效8位表示。请注意，结果 &lt;code&gt;Byte&lt;/code&gt; 值可能为负。</target>
        </trans-unit>
        <trans-unit id="f0796ad9fb92ce12d111b3b2e535fa3a4138ff67" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Byte&lt;/code&gt; value is represented by the least significant 8 bits of this &lt;code&gt;UShort&lt;/code&gt; value. Note that the resulting &lt;code&gt;Byte&lt;/code&gt; value may be negative.</source>
          <target state="translated">结果 &lt;code&gt;Byte&lt;/code&gt; 值由该 &lt;code&gt;UShort&lt;/code&gt; 值的最低有效8位表示。请注意，结果 &lt;code&gt;Byte&lt;/code&gt; 值可能为负。</target>
        </trans-unit>
        <trans-unit id="1dcececb10dcdcffc92e35f3fc84338088990b5d" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Char&lt;/code&gt; code is equal to this value reinterpreted as an unsigned number, i.e. it has the same binary representation as this &lt;code&gt;Short&lt;/code&gt;.</source>
          <target state="translated">所得的 &lt;code&gt;Char&lt;/code&gt; 代码等于将此值重新解释为无符号数字，即，它具有与此 &lt;code&gt;Short&lt;/code&gt; 相同的二进制表示形式。</target>
        </trans-unit>
        <trans-unit id="7d3990133293f18f718906ea26c50d316e7978f0" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Char&lt;/code&gt; code is represented by the least significant 16 bits of this &lt;code&gt;Int&lt;/code&gt; value.</source>
          <target state="translated">所得的 &lt;code&gt;Char&lt;/code&gt; 码由该 &lt;code&gt;Int&lt;/code&gt; 值的最低16位表示。</target>
        </trans-unit>
        <trans-unit id="8e5f25cf2555e851681e56711455629d8b96cc85" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Char&lt;/code&gt; code is represented by the least significant 16 bits of this &lt;code&gt;Long&lt;/code&gt; value.</source>
          <target state="translated">所得的 &lt;code&gt;Char&lt;/code&gt; 码由此 &lt;code&gt;Long&lt;/code&gt; 值的最低有效16位表示。</target>
        </trans-unit>
        <trans-unit id="7c93c7f205f664c42eb53e198c38febdd8681e8c" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Char&lt;/code&gt; value is equal to &lt;code&gt;this.toInt().toChar()&lt;/code&gt;.</source>
          <target state="translated">得到的 &lt;code&gt;Char&lt;/code&gt; 值等于 &lt;code&gt;this.toInt().toChar()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fb0bee6e823fc7a039aaeeb4e2cf6ccadd56cad2" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Double&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;Byte&lt;/code&gt;.</source>
          <target state="translated">得到的 &lt;code&gt;Double&lt;/code&gt; 值表示与此 &lt;code&gt;Byte&lt;/code&gt; 相同的数值。</target>
        </trans-unit>
        <trans-unit id="ec044076f69f3a9e4c8c326707b213be48dbdf4c" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Double&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;Float&lt;/code&gt;.</source>
          <target state="translated">得到的 &lt;code&gt;Double&lt;/code&gt; 值表示与此 &lt;code&gt;Float&lt;/code&gt; 相同的数值。</target>
        </trans-unit>
        <trans-unit id="413cc395d49c3c9b688aa7288d432c1583480097" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Double&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;Int&lt;/code&gt;.</source>
          <target state="translated">得到的 &lt;code&gt;Double&lt;/code&gt; 值表示与此 &lt;code&gt;Int&lt;/code&gt; 相同的数值。</target>
        </trans-unit>
        <trans-unit id="e04c116c448cef44fd49f1d1da49c8be72cf833e" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Double&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;Short&lt;/code&gt;.</source>
          <target state="translated">得到的 &lt;code&gt;Double&lt;/code&gt; 值表示与此 &lt;code&gt;Short&lt;/code&gt; 相同的数值。</target>
        </trans-unit>
        <trans-unit id="624ad9cad2fadf7c5df7034160380cba9b36827a" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Double&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;UByte&lt;/code&gt;.</source>
          <target state="translated">得到的 &lt;code&gt;Double&lt;/code&gt; 值表示与此 &lt;code&gt;UByte&lt;/code&gt; 相同的数值。</target>
        </trans-unit>
        <trans-unit id="e233d00009204b3d8e16f6c4faaeb29b610dd152" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Double&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;UInt&lt;/code&gt;.</source>
          <target state="translated">所得的 &lt;code&gt;Double&lt;/code&gt; 值表示与此 &lt;code&gt;UInt&lt;/code&gt; 相同的数值。</target>
        </trans-unit>
        <trans-unit id="be9fd1536c9016ec165d93e9e044c6403df23d59" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Double&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;UShort&lt;/code&gt;.</source>
          <target state="translated">得到的 &lt;code&gt;Double&lt;/code&gt; 值表示与此 &lt;code&gt;UShort&lt;/code&gt; 相同的数值。</target>
        </trans-unit>
        <trans-unit id="ae244f9a05312104462c229a2e3a4a4de64be4e1" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Float&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;Byte&lt;/code&gt;.</source>
          <target state="translated">最终的 &lt;code&gt;Float&lt;/code&gt; 值表示与此 &lt;code&gt;Byte&lt;/code&gt; 相同的数值。</target>
        </trans-unit>
        <trans-unit id="f8088fd36ea4c2c1efeb80cfa5d2e317eb476320" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Float&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;Short&lt;/code&gt;.</source>
          <target state="translated">产生的 &lt;code&gt;Float&lt;/code&gt; 值表示与此 &lt;code&gt;Short&lt;/code&gt; 相同的数值。</target>
        </trans-unit>
        <trans-unit id="f353ad75e4345f7f3c16a80f19361bddd53a4f67" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Float&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;UByte&lt;/code&gt;.</source>
          <target state="translated">最终的 &lt;code&gt;Float&lt;/code&gt; 值表示与此 &lt;code&gt;UByte&lt;/code&gt; 相同的数值。</target>
        </trans-unit>
        <trans-unit id="abac5ba157cb93c8f101ff3e6ab497cfac17749a" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Float&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;UShort&lt;/code&gt;.</source>
          <target state="translated">最终的 &lt;code&gt;Float&lt;/code&gt; 值表示与此 &lt;code&gt;UShort&lt;/code&gt; 相同的数值。</target>
        </trans-unit>
        <trans-unit id="9d03c1143daecc3b8a141860933f0a92adb18b37" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Int&lt;/code&gt; value has the same binary representation as this &lt;code&gt;UInt&lt;/code&gt; value.</source>
          <target state="translated">生成的 &lt;code&gt;Int&lt;/code&gt; 值与此 &lt;code&gt;UInt&lt;/code&gt; 值具有相同的二进制表示形式。</target>
        </trans-unit>
        <trans-unit id="6ff94aee825d38ae08d93f2ca58819f2a03d9747" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Int&lt;/code&gt; value is represented by the least significant 32 bits of this &lt;code&gt;Long&lt;/code&gt; value.</source>
          <target state="translated">结果 &lt;code&gt;Int&lt;/code&gt; 值由此 &lt;code&gt;Long&lt;/code&gt; 值的最低有效32位表示。</target>
        </trans-unit>
        <trans-unit id="7a5d4e0dea3c1513f10c80d1128e159e3a009787" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Int&lt;/code&gt; value is represented by the least significant 32 bits of this &lt;code&gt;ULong&lt;/code&gt; value. Note that the resulting &lt;code&gt;Int&lt;/code&gt; value may be negative.</source>
          <target state="translated">结果的 &lt;code&gt;Int&lt;/code&gt; 值由该 &lt;code&gt;ULong&lt;/code&gt; 值的最低有效32位表示。请注意，所得的 &lt;code&gt;Int&lt;/code&gt; 值可能为负。</target>
        </trans-unit>
        <trans-unit id="134cc45d29d5c0611e6038571857feed8853b0ee" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Int&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;Byte&lt;/code&gt;.</source>
          <target state="translated">得到的 &lt;code&gt;Int&lt;/code&gt; 值表示与此 &lt;code&gt;Byte&lt;/code&gt; 相同的数值。</target>
        </trans-unit>
        <trans-unit id="a8d60bc3ef88b39460060b7f8165763da80802bc" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Int&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;Short&lt;/code&gt;.</source>
          <target state="translated">得到的 &lt;code&gt;Int&lt;/code&gt; 值表示与此 &lt;code&gt;Short&lt;/code&gt; 相同的数值。</target>
        </trans-unit>
        <trans-unit id="12aaa5ec83610d73b4b2fc195902417a297ddd61" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Int&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;UByte&lt;/code&gt;.</source>
          <target state="translated">结果 &lt;code&gt;Int&lt;/code&gt; 值表示与此 &lt;code&gt;UByte&lt;/code&gt; 相同的数值。</target>
        </trans-unit>
        <trans-unit id="b30712342fda907bc49df4d10c136bbeeaaf708b" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Int&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;UShort&lt;/code&gt;.</source>
          <target state="translated">最终的 &lt;code&gt;Int&lt;/code&gt; 值表示与此 &lt;code&gt;UShort&lt;/code&gt; 相同的数值。</target>
        </trans-unit>
        <trans-unit id="25bcbeae5576ececd431ec0f451a2c7cf6bf73b4" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Long&lt;/code&gt; value has the same binary representation as this &lt;code&gt;ULong&lt;/code&gt; value.</source>
          <target state="translated">所得的 &lt;code&gt;Long&lt;/code&gt; 值与此 &lt;code&gt;ULong&lt;/code&gt; 值具有相同的二进制表示形式。</target>
        </trans-unit>
        <trans-unit id="e6a0efc4ac5c4b05735980342faa240209bf9353" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Long&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;Byte&lt;/code&gt;.</source>
          <target state="translated">得到的 &lt;code&gt;Long&lt;/code&gt; 值表示与此 &lt;code&gt;Byte&lt;/code&gt; 相同的数值。</target>
        </trans-unit>
        <trans-unit id="a30381cf3452bf71d4466b6a6a9c5a35e959654a" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Long&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;Int&lt;/code&gt;.</source>
          <target state="translated">得到的 &lt;code&gt;Long&lt;/code&gt; 值表示与此 &lt;code&gt;Int&lt;/code&gt; 相同的数值。</target>
        </trans-unit>
        <trans-unit id="7692c28294ebe4518a8808f192338ab899b5aeec" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Long&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;Short&lt;/code&gt;.</source>
          <target state="translated">得到的 &lt;code&gt;Long&lt;/code&gt; 值表示与此 &lt;code&gt;Short&lt;/code&gt; 相同的数值。</target>
        </trans-unit>
        <trans-unit id="60b7e7e3ba10c2b92827e84db685cc040e179ed1" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Long&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;UByte&lt;/code&gt;.</source>
          <target state="translated">得到的 &lt;code&gt;Long&lt;/code&gt; 值表示与此 &lt;code&gt;UByte&lt;/code&gt; 相同的数值。</target>
        </trans-unit>
        <trans-unit id="a95d7e6a557f4530d701aed1a8410d9b6e793205" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Long&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;UInt&lt;/code&gt;.</source>
          <target state="translated">得到的 &lt;code&gt;Long&lt;/code&gt; 值表示与此 &lt;code&gt;UInt&lt;/code&gt; 相同的数值。</target>
        </trans-unit>
        <trans-unit id="e900373f53d6267fd01ecf92bb2c5cb1fed9a7b7" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Long&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;UShort&lt;/code&gt;.</source>
          <target state="translated">得到的 &lt;code&gt;Long&lt;/code&gt; 值表示与此 &lt;code&gt;UShort&lt;/code&gt; 相同的数值。</target>
        </trans-unit>
        <trans-unit id="3866529acc183dc8b682af92a84909ec65bd5749" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Short&lt;/code&gt; value has the same binary representation as this &lt;code&gt;UShort&lt;/code&gt; value.</source>
          <target state="translated">所得的 &lt;code&gt;Short&lt;/code&gt; 值与此 &lt;code&gt;UShort&lt;/code&gt; 值具有相同的二进制表示形式。</target>
        </trans-unit>
        <trans-unit id="5ccfa5aff935ee9326f2b407c585467d126768e7" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Short&lt;/code&gt; value is equal to &lt;code&gt;this.toInt().toShort()&lt;/code&gt;.</source>
          <target state="translated">产生的 &lt;code&gt;Short&lt;/code&gt; 值等于 &lt;code&gt;this.toInt().toShort()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fb338e05b22f496cc978d6bf212ddabde5dd17a4" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Short&lt;/code&gt; value is represented by the least significant 16 bits of this &lt;code&gt;Int&lt;/code&gt; value.</source>
          <target state="translated">结果的 &lt;code&gt;Short&lt;/code&gt; 值由该 &lt;code&gt;Int&lt;/code&gt; 值的最低有效16位表示。</target>
        </trans-unit>
        <trans-unit id="27367d77acd56c6a1050bc0a49a57fcf2061de96" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Short&lt;/code&gt; value is represented by the least significant 16 bits of this &lt;code&gt;Long&lt;/code&gt; value.</source>
          <target state="translated">结果的 &lt;code&gt;Short&lt;/code&gt; 值由该 &lt;code&gt;Long&lt;/code&gt; 值的最低有效16位表示。</target>
        </trans-unit>
        <trans-unit id="0bc0fbdc70644d6d748c478656fa78e912cc16e6" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Short&lt;/code&gt; value is represented by the least significant 16 bits of this &lt;code&gt;UInt&lt;/code&gt; value. Note that the resulting &lt;code&gt;Short&lt;/code&gt; value may be negative.</source>
          <target state="translated">结果的 &lt;code&gt;Short&lt;/code&gt; 值由该 &lt;code&gt;UInt&lt;/code&gt; 值的最低有效16位表示。请注意，所得的 &lt;code&gt;Short&lt;/code&gt; 值可能为负。</target>
        </trans-unit>
        <trans-unit id="bb9494a50b8985a2d74ddd24ec83038bdcd4606a" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Short&lt;/code&gt; value is represented by the least significant 16 bits of this &lt;code&gt;ULong&lt;/code&gt; value. Note that the resulting &lt;code&gt;Short&lt;/code&gt; value may be negative.</source>
          <target state="translated">结果的 &lt;code&gt;Short&lt;/code&gt; 值由该 &lt;code&gt;ULong&lt;/code&gt; 值的最低有效16位表示。请注意，所得的 &lt;code&gt;Short&lt;/code&gt; 值可能为负。</target>
        </trans-unit>
        <trans-unit id="1fbe35f845af4aa0feff1d9060ab35a7c6fe3476" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Short&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;Byte&lt;/code&gt;.</source>
          <target state="translated">得到的 &lt;code&gt;Short&lt;/code&gt; 值表示与此 &lt;code&gt;Byte&lt;/code&gt; 相同的数值。</target>
        </trans-unit>
        <trans-unit id="62163dcead131c0bf0933b1342f420db3bc4bb8d" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Short&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;UByte&lt;/code&gt;.</source>
          <target state="translated">所得的 &lt;code&gt;Short&lt;/code&gt; 值表示与此 &lt;code&gt;UByte&lt;/code&gt; 相同的数值。</target>
        </trans-unit>
        <trans-unit id="26c6a5634d9e1d8b962bb6788ae67bc866b78e45" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;UByte&lt;/code&gt; value has the same binary representation as this &lt;code&gt;Byte&lt;/code&gt; value.</source>
          <target state="translated">所得的 &lt;code&gt;UByte&lt;/code&gt; 值与此 &lt;code&gt;Byte&lt;/code&gt; 值具有相同的二进制表示形式。</target>
        </trans-unit>
        <trans-unit id="11d5b691a4a978c7af952b604f7d065d5eac1305" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;UByte&lt;/code&gt; value is represented by the least significant 8 bits of this &lt;code&gt;Int&lt;/code&gt; value.</source>
          <target state="translated">所得的 &lt;code&gt;UByte&lt;/code&gt; 值由该 &lt;code&gt;Int&lt;/code&gt; 值的最低有效8位表示。</target>
        </trans-unit>
        <trans-unit id="5226c83d79204652c28eff49e7528cb1e99fe2d6" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;UByte&lt;/code&gt; value is represented by the least significant 8 bits of this &lt;code&gt;Long&lt;/code&gt; value.</source>
          <target state="translated">将所得 &lt;code&gt;UByte&lt;/code&gt; 值由这种的至少显著8位表示 &lt;code&gt;Long&lt;/code&gt; 值。</target>
        </trans-unit>
        <trans-unit id="726d8e3bdd3b093a08a44094c2cae4da994770da" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;UByte&lt;/code&gt; value is represented by the least significant 8 bits of this &lt;code&gt;Short&lt;/code&gt; value.</source>
          <target state="translated">将所得 &lt;code&gt;UByte&lt;/code&gt; 值由这种的至少显著8位表示 &lt;code&gt;Short&lt;/code&gt; 值。</target>
        </trans-unit>
        <trans-unit id="1dfb49e88d21be6bcb0f49bf822a5aaa6937a983" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;UByte&lt;/code&gt; value is represented by the least significant 8 bits of this &lt;code&gt;UInt&lt;/code&gt; value.</source>
          <target state="translated">所得的 &lt;code&gt;UByte&lt;/code&gt; 值由该 &lt;code&gt;UInt&lt;/code&gt; 值的最低有效8位表示。</target>
        </trans-unit>
        <trans-unit id="2686cc59be2588fb1dc986c8db1acdab514c552c" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;UByte&lt;/code&gt; value is represented by the least significant 8 bits of this &lt;code&gt;ULong&lt;/code&gt; value.</source>
          <target state="translated">所得的 &lt;code&gt;UByte&lt;/code&gt; 值由该 &lt;code&gt;ULong&lt;/code&gt; 值的最低有效8位表示。</target>
        </trans-unit>
        <trans-unit id="a5d21503bfa5cb9b99c854c368f0b66239678aba" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;UByte&lt;/code&gt; value is represented by the least significant 8 bits of this &lt;code&gt;UShort&lt;/code&gt; value.</source>
          <target state="translated">所得的 &lt;code&gt;UByte&lt;/code&gt; 值由该 &lt;code&gt;UShort&lt;/code&gt; 值的最低有效8位表示。</target>
        </trans-unit>
        <trans-unit id="4f3fe5211f1aea05bea1a841d6d73788aeeb2998" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;UInt&lt;/code&gt; value has the same binary representation as this &lt;code&gt;Int&lt;/code&gt; value.</source>
          <target state="translated">所得的 &lt;code&gt;UInt&lt;/code&gt; 值与此 &lt;code&gt;Int&lt;/code&gt; 值具有相同的二进制表示形式。</target>
        </trans-unit>
        <trans-unit id="66a1e76fd131680ad5406468e22ad3973f35ff4e" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;UInt&lt;/code&gt; value is represented by the least significant 32 bits of this &lt;code&gt;Long&lt;/code&gt; value.</source>
          <target state="translated">最终的 &lt;code&gt;UInt&lt;/code&gt; 值由此 &lt;code&gt;Long&lt;/code&gt; 值的最低有效32位表示。</target>
        </trans-unit>
        <trans-unit id="bc935cba2a00e8cc63899ff18d12438a89739380" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;UInt&lt;/code&gt; value is represented by the least significant 32 bits of this &lt;code&gt;ULong&lt;/code&gt; value.</source>
          <target state="translated">最终的 &lt;code&gt;UInt&lt;/code&gt; 值由该 &lt;code&gt;ULong&lt;/code&gt; 值的最低有效32位表示。</target>
        </trans-unit>
        <trans-unit id="9d9ba2608012da37a52b5b9b7da96f6d67796334" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;UInt&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;UByte&lt;/code&gt;.</source>
          <target state="translated">所得的 &lt;code&gt;UInt&lt;/code&gt; 值表示与此 &lt;code&gt;UByte&lt;/code&gt; 相同的数值。</target>
        </trans-unit>
        <trans-unit id="9ab12c98c1ea5502db93ef496727f7d48f4edc12" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;UInt&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;UShort&lt;/code&gt;.</source>
          <target state="translated">最终的 &lt;code&gt;UInt&lt;/code&gt; 值表示与此 &lt;code&gt;UShort&lt;/code&gt; 相同的数值。</target>
        </trans-unit>
        <trans-unit id="e00a9f9829597db51c5f5f105c5c613e61839318" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;ULong&lt;/code&gt; value has the same binary representation as this &lt;code&gt;Long&lt;/code&gt; value.</source>
          <target state="translated">所得的 &lt;code&gt;ULong&lt;/code&gt; 值与此 &lt;code&gt;Long&lt;/code&gt; 值具有相同的二进制表示形式。</target>
        </trans-unit>
        <trans-unit id="a5fe358a0a132b3d4ac886ee0067825836c972c3" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;ULong&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;UByte&lt;/code&gt;.</source>
          <target state="translated">得到的 &lt;code&gt;ULong&lt;/code&gt; 值表示与此 &lt;code&gt;UByte&lt;/code&gt; 相同的数值。</target>
        </trans-unit>
        <trans-unit id="1e225f6484184e1fd9b9a789c6be2168c16944f8" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;ULong&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;UInt&lt;/code&gt;.</source>
          <target state="translated">得到的 &lt;code&gt;ULong&lt;/code&gt; 值表示与此 &lt;code&gt;UInt&lt;/code&gt; 相同的数值。</target>
        </trans-unit>
        <trans-unit id="951d01157187c8755e4bb93be0ec662d70035ced" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;ULong&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;UShort&lt;/code&gt;.</source>
          <target state="translated">得到的 &lt;code&gt;ULong&lt;/code&gt; 值表示与此 &lt;code&gt;UShort&lt;/code&gt; 相同的数值。</target>
        </trans-unit>
        <trans-unit id="76c0754fefaa89b43d0e48e2d3b2efa1a3c37cac" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;UShort&lt;/code&gt; value has the same binary representation as this &lt;code&gt;Short&lt;/code&gt; value.</source>
          <target state="translated">所得的 &lt;code&gt;UShort&lt;/code&gt; 值与此 &lt;code&gt;Short&lt;/code&gt; 值具有相同的二进制表示形式。</target>
        </trans-unit>
        <trans-unit id="ed25489ad27c7ad2fa4a9e9ed8a17e177ed921a7" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;UShort&lt;/code&gt; value is represented by the least significant 16 bits of this &lt;code&gt;Int&lt;/code&gt; value.</source>
          <target state="translated">所得的 &lt;code&gt;UShort&lt;/code&gt; 值由该 &lt;code&gt;Int&lt;/code&gt; 值的最低有效16位表示。</target>
        </trans-unit>
        <trans-unit id="f42954d6785f3d5db6ef1809c504748ad3c8598b" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;UShort&lt;/code&gt; value is represented by the least significant 16 bits of this &lt;code&gt;Long&lt;/code&gt; value.</source>
          <target state="translated">结果 &lt;code&gt;UShort&lt;/code&gt; 值由该 &lt;code&gt;Long&lt;/code&gt; 值的最低有效16位表示。</target>
        </trans-unit>
        <trans-unit id="1457c7b3fcc5ff173b3ad803474b4e660273fb3a" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;UShort&lt;/code&gt; value is represented by the least significant 16 bits of this &lt;code&gt;UInt&lt;/code&gt; value.</source>
          <target state="translated">所得的 &lt;code&gt;UShort&lt;/code&gt; 值由该 &lt;code&gt;UInt&lt;/code&gt; 值的最低有效16位表示。</target>
        </trans-unit>
        <trans-unit id="f4cfae00353cb363d45d034bd2773a412889ab06" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;UShort&lt;/code&gt; value is represented by the least significant 16 bits of this &lt;code&gt;ULong&lt;/code&gt; value.</source>
          <target state="translated">所得的 &lt;code&gt;UShort&lt;/code&gt; 值由该 &lt;code&gt;ULong&lt;/code&gt; 值的最低有效16位表示。</target>
        </trans-unit>
        <trans-unit id="fd44eb3bc0245bda18586fe624c6aa7f2130c655" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;UShort&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;UByte&lt;/code&gt;.</source>
          <target state="translated">所得的 &lt;code&gt;UShort&lt;/code&gt; 值表示与此 &lt;code&gt;UByte&lt;/code&gt; 相同的数值。</target>
        </trans-unit>
        <trans-unit id="26ad7d1c46a7946f361222464d3fd9f54190f2e7" translate="yes" xml:space="preserve">
          <source>The resulting value is the closest &lt;code&gt;Double&lt;/code&gt; to this &lt;code&gt;Long&lt;/code&gt; value. In case when this &lt;code&gt;Long&lt;/code&gt; value is exactly between two &lt;code&gt;Double&lt;/code&gt;s, the one with zero at least significant bit of mantissa is selected.</source>
          <target state="translated">结果值是与此 &lt;code&gt;Long&lt;/code&gt; 值最接近的 &lt;code&gt;Double&lt;/code&gt; 。如果此 &lt;code&gt;Long&lt;/code&gt; 值恰好在两个 &lt;code&gt;Double&lt;/code&gt; 之间，则选择尾数至少为0的那个。</target>
        </trans-unit>
        <trans-unit id="492c13f0924f52f27eadd038e36be9a70c7d0f23" translate="yes" xml:space="preserve">
          <source>The resulting value is the closest &lt;code&gt;Double&lt;/code&gt; to this &lt;code&gt;ULong&lt;/code&gt; value. In case when this &lt;code&gt;ULong&lt;/code&gt; value is exactly between two &lt;code&gt;Double&lt;/code&gt;s, the one with zero at least significant bit of mantissa is selected.</source>
          <target state="translated">结果值是与此 &lt;code&gt;ULong&lt;/code&gt; 值最接近的 &lt;code&gt;Double&lt;/code&gt; 。如果此 &lt;code&gt;ULong&lt;/code&gt; 值恰好在两个 &lt;code&gt;Double&lt;/code&gt; 之间，则选择尾数至少为0的那个。</target>
        </trans-unit>
        <trans-unit id="fc0e588cba1b5e32b36bbd725d91a005e8eca137" translate="yes" xml:space="preserve">
          <source>The resulting value is the closest &lt;code&gt;Float&lt;/code&gt; to this &lt;code&gt;Double&lt;/code&gt; value. In case when this &lt;code&gt;Double&lt;/code&gt; value is exactly between two &lt;code&gt;Float&lt;/code&gt;s, the one with zero at least significant bit of mantissa is selected.</source>
          <target state="translated">结果值是最接近此 &lt;code&gt;Double&lt;/code&gt; 值的 &lt;code&gt;Float&lt;/code&gt; 。如果此 &lt;code&gt;Double&lt;/code&gt; 值恰好在两个 &lt;code&gt;Float&lt;/code&gt; 之间，则选择尾数至少为0的那个。</target>
        </trans-unit>
        <trans-unit id="1a94a9e0d2914f4ed72b19cd967f6325996af0de" translate="yes" xml:space="preserve">
          <source>The resulting value is the closest &lt;code&gt;Float&lt;/code&gt; to this &lt;code&gt;Int&lt;/code&gt; value. In case when this &lt;code&gt;Int&lt;/code&gt; value is exactly between two &lt;code&gt;Float&lt;/code&gt;s, the one with zero at least significant bit of mantissa is selected.</source>
          <target state="translated">结果值是最接近此 &lt;code&gt;Int&lt;/code&gt; 值的 &lt;code&gt;Float&lt;/code&gt; 。如果此 &lt;code&gt;Int&lt;/code&gt; 值恰好在两个 &lt;code&gt;Float&lt;/code&gt; 之间，则选择尾数至少为0的那个。</target>
        </trans-unit>
        <trans-unit id="4c34f885e332b614efeb077bdc9dc7f566d719ac" translate="yes" xml:space="preserve">
          <source>The resulting value is the closest &lt;code&gt;Float&lt;/code&gt; to this &lt;code&gt;Long&lt;/code&gt; value. In case when this &lt;code&gt;Long&lt;/code&gt; value is exactly between two &lt;code&gt;Float&lt;/code&gt;s, the one with zero at least significant bit of mantissa is selected.</source>
          <target state="translated">结果值是最接近此 &lt;code&gt;Long&lt;/code&gt; 值的 &lt;code&gt;Float&lt;/code&gt; 。如果此 &lt;code&gt;Long&lt;/code&gt; 值恰好在两个 &lt;code&gt;Float&lt;/code&gt; 之间，则选择尾数至少为0的那个。</target>
        </trans-unit>
        <trans-unit id="56778d0fa4ef4bd39c3c6c8e27df252ff267b86a" translate="yes" xml:space="preserve">
          <source>The resulting value is the closest &lt;code&gt;Float&lt;/code&gt; to this &lt;code&gt;UInt&lt;/code&gt; value. In case when this &lt;code&gt;UInt&lt;/code&gt; value is exactly between two &lt;code&gt;Float&lt;/code&gt;s, the one with zero at least significant bit of mantissa is selected.</source>
          <target state="translated">结果值是最接近此 &lt;code&gt;UInt&lt;/code&gt; 值的 &lt;code&gt;Float&lt;/code&gt; 。如果此 &lt;code&gt;UInt&lt;/code&gt; 值恰好在两个 &lt;code&gt;Float&lt;/code&gt; 之间，则选择至少零个有效尾数的那个。</target>
        </trans-unit>
        <trans-unit id="498957909e2b3c5b2a70150c6779dc9db0eb20c7" translate="yes" xml:space="preserve">
          <source>The resulting value is the closest &lt;code&gt;Float&lt;/code&gt; to this &lt;code&gt;ULong&lt;/code&gt; value. In case when this &lt;code&gt;ULong&lt;/code&gt; value is exactly between two &lt;code&gt;Float&lt;/code&gt;s, the one with zero at least significant bit of mantissa is selected.</source>
          <target state="translated">结果值是最接近此 &lt;code&gt;ULong&lt;/code&gt; 值的 &lt;code&gt;Float&lt;/code&gt; 。如果此 &lt;code&gt;ULong&lt;/code&gt; 值恰好在两个 &lt;code&gt;Float&lt;/code&gt; 之间，则选择至少零个有效尾数的零。</target>
        </trans-unit>
        <trans-unit id="65d14c2cdb6c9b143338a902f9c4de4c9b45f92f" translate="yes" xml:space="preserve">
          <source>The return type inference for anonymous functions works just like for normal functions: the return type is inferred automatically for anonymous functions with an expression body and has to be specified explicitly (or is assumed to be &lt;code&gt;Unit&lt;/code&gt;) for anonymous functions with a block body.</source>
          <target state="translated">匿名函数的返回类型推断的工作原理与普通函数一样：对于具有表达式主体的匿名函数，将自动推断返回类型，对于具有块主体的匿名函数，必须明确指定返回类型（或假定为 &lt;code&gt;Unit&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="dbab78ef44eaefb4e469bd1e51f4e8661d634cea" translate="yes" xml:space="preserve">
          <source>The return type of a function-typed return type (the user expects the returned function to return &lt;code&gt;Fruit&lt;/code&gt;, so it's okay if it really returns &lt;code&gt;Apple&lt;/code&gt;)</source>
          <target state="translated">函数类型的返回类型的返回类型（用户希望返回的函数返回 &lt;code&gt;Fruit&lt;/code&gt; ，因此，如果它确实返回 &lt;code&gt;Apple&lt;/code&gt; ,也可以）</target>
        </trans-unit>
        <trans-unit id="d8362d946ac99a87abd0521089565682c0510f07" translate="yes" xml:space="preserve">
          <source>The return type of a lambda expression is inferred from the type of the last expression inside it (or from the function type of the variable/parameter that the lambda expression is assigned to). If a lambda expression is passed as a function parameter (which is the ordinary use) or assigned to a variable with a declared type, Kotlin can infer the parameter types too, and you only need to specify their names:</source>
          <target state="translated">一个lambda表达式的返回类型是根据它里面最后一个表达式的类型来推断的(或者是根据lambda表达式分配给的变量/参数的函数类型)。如果一个lambda表达式作为函数参数传递(这是普通的用法),或者分配给一个有声明类型的变量,Kotlin也可以推断出参数类型,你只需要指定它们的名字。</target>
        </trans-unit>
        <trans-unit id="d7c260eb93497371636dc4de8fdb8ef84ac32045" translate="yes" xml:space="preserve">
          <source>The return value of &lt;code&gt;apply&lt;/code&gt; and &lt;code&gt;also&lt;/code&gt; is the context object itself. Hence, they can be included into call chains as &lt;em&gt;side steps&lt;/em&gt;: you can continue chaining function calls on the same object after them.</source>
          <target state="translated">&lt;code&gt;apply&lt;/code&gt; 和的返回值 &lt;code&gt;also&lt;/code&gt; 上下文对象本身。因此，它们可以作为&lt;em&gt;副步骤&lt;/em&gt;包含在调用链中：您可以在它们之后继续在同一对象上链接函数调用。</target>
        </trans-unit>
        <trans-unit id="6d324367f598aa028770dca0838f66177648fed1" translate="yes" xml:space="preserve">
          <source>The return value.</source>
          <target state="translated">返回值。</target>
        </trans-unit>
        <trans-unit id="046b6584c1bbd3a7a64857edece72cc830dec917" translate="yes" xml:space="preserve">
          <source>The returned instance uses the specified &lt;a href=&quot;lazy#kotlin%24lazy%28kotlin.Any%2C+kotlin.Function0%28%28kotlin.lazy.T%29%29%29%2Flock&quot;&gt;lock&lt;/a&gt; object to synchronize on. When the &lt;a href=&quot;lazy#kotlin%24lazy%28kotlin.Any%2C+kotlin.Function0%28%28kotlin.lazy.T%29%29%29%2Flock&quot;&gt;lock&lt;/a&gt; is not specified the instance uses itself to synchronize on, in this case do not synchronize from external code on the returned instance as it may cause accidental deadlock. Also this behavior can be changed in the future.</source>
          <target state="translated">返回的实例使用指定的&lt;a href=&quot;lazy#kotlin%24lazy%28kotlin.Any%2C+kotlin.Function0%28%28kotlin.lazy.T%29%29%29%2Flock&quot;&gt;锁定&lt;/a&gt;对象进行同步。如果未指定&lt;a href=&quot;lazy#kotlin%24lazy%28kotlin.Any%2C+kotlin.Function0%28%28kotlin.lazy.T%29%29%29%2Flock&quot;&gt;锁，&lt;/a&gt;则实例将使用自身进行同步，在这种情况下，请勿与返回的实例上的外部代码进行同步，因为这可能会导致意外的死锁。同样，将来可以更改此行为。</target>
        </trans-unit>
        <trans-unit id="9b93655dba3d2a18324e24a42bc0aa37bcaff559" translate="yes" xml:space="preserve">
          <source>The returned instance uses the specified &lt;a href=&quot;lazy#kotlin%24lazy(kotlin.Any?,%20kotlin.Function0((kotlin.lazy.T)))/lock&quot;&gt;lock&lt;/a&gt; object to synchronize on. When the &lt;a href=&quot;lazy#kotlin%24lazy(kotlin.Any?,%20kotlin.Function0((kotlin.lazy.T)))/lock&quot;&gt;lock&lt;/a&gt; is not specified the instance uses itself to synchronize on, in this case do not synchronize from external code on the returned instance as it may cause accidental deadlock. Also this behavior can be changed in the future.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97bfc2ca377533226a66b10393317b0a2f994fba" translate="yes" xml:space="preserve">
          <source>The returned list is empty if this char sequence contains less than two characters.</source>
          <target state="translated">如果这个字符序列包含的字符数少于两个,则返回的列表为空。</target>
        </trans-unit>
        <trans-unit id="d158c2273db93047119908af61efbbba35bd76f3" translate="yes" xml:space="preserve">
          <source>The returned list is empty if this collection contains less than two elements.</source>
          <target state="translated">如果这个集合包含的元素少于两个,则返回的列表为空。</target>
        </trans-unit>
        <trans-unit id="29bbad5c305945f97c70cd75ffccab450111f2ea" translate="yes" xml:space="preserve">
          <source>The returned map is serializable (JVM).</source>
          <target state="translated">返回的地图是可序列化的(JVM)。</target>
        </trans-unit>
        <trans-unit id="ec4d25dd41a10ce08bae955efed7031764938b43" translate="yes" xml:space="preserve">
          <source>The returned map is serializable.</source>
          <target state="translated">返回的地图是可序列化的。</target>
        </trans-unit>
        <trans-unit id="6f1137c5bd275e0d050f73fe1ffb45e6bc0fef52" translate="yes" xml:space="preserve">
          <source>The returned map preserves the entry iteration order of the keys produced from the original array.</source>
          <target state="translated">返回的映射保留了从原始数组产生的键的入口迭代顺序。</target>
        </trans-unit>
        <trans-unit id="aab8c4af63582433af11da060d436e3782362d9a" translate="yes" xml:space="preserve">
          <source>The returned map preserves the entry iteration order of the keys produced from the original char sequence.</source>
          <target state="translated">返回的映射保留了从原始char序列产生的键的入口迭代顺序。</target>
        </trans-unit>
        <trans-unit id="16f1a5aa5ffd50a8f9547783402bf7757df5025f" translate="yes" xml:space="preserve">
          <source>The returned map preserves the entry iteration order of the keys produced from the original collection.</source>
          <target state="translated">返回的映射保留了从原始集合产生的键的入口迭代顺序。</target>
        </trans-unit>
        <trans-unit id="19c068ac54b988c0d6076dddd8c2dbf4092708f6" translate="yes" xml:space="preserve">
          <source>The returned map preserves the entry iteration order of the keys produced from the original sequence.</source>
          <target state="translated">返回的映射保留了从原始序列产生的键的入口迭代顺序。</target>
        </trans-unit>
        <trans-unit id="f54f229a0ee8d8720d828fe3e27b2d2a6ca940bc" translate="yes" xml:space="preserve">
          <source>The returned map preserves the entry iteration order of the original array.</source>
          <target state="translated">返回的映射保留了原始数组的条目迭代顺序。</target>
        </trans-unit>
        <trans-unit id="918c726186d31885a03be5dd5847d194f356551f" translate="yes" xml:space="preserve">
          <source>The returned map preserves the entry iteration order of the original array. If any of two pairs would have the same key the last one gets added to the map.</source>
          <target state="translated">返回的映射保留了原始数组的条目迭代顺序。如果两个数组中的任何一个数组有相同的键,则最后一个数组会被添加到映射中。</target>
        </trans-unit>
        <trans-unit id="1331dc1f7dcbe48a5148654c3f9a9dd17b60c885" translate="yes" xml:space="preserve">
          <source>The returned map preserves the entry iteration order of the original char sequence.</source>
          <target state="translated">返回的映射保留了原始char序列的入口迭代顺序。</target>
        </trans-unit>
        <trans-unit id="566ed3a9dcb7ca74d4f2c70c6fdf84ac896debb5" translate="yes" xml:space="preserve">
          <source>The returned map preserves the entry iteration order of the original collection.</source>
          <target state="translated">返回的地图保留了原始集合的条目迭代顺序。</target>
        </trans-unit>
        <trans-unit id="2e469a2caf818c0835cee9e0a1babf1e2e3c07a5" translate="yes" xml:space="preserve">
          <source>The returned map preserves the entry iteration order of the original collection. If any of two pairs would have the same key the last one gets added to the map.</source>
          <target state="translated">返回的映射保留了原始集合的条目迭代顺序。如果任何两个对有相同的键,最后一个会被添加到映射中。</target>
        </trans-unit>
        <trans-unit id="4c19d30d5fb69c54a255c5b1e548f2fa56d3aefb" translate="yes" xml:space="preserve">
          <source>The returned map preserves the entry iteration order of the original map.</source>
          <target state="translated">返回的地图保留了原始地图的条目迭代顺序。</target>
        </trans-unit>
        <trans-unit id="f87204408405ad88a40594eff8f4867029a89b59" translate="yes" xml:space="preserve">
          <source>The returned map preserves the entry iteration order of the original map. The &lt;a href=&quot;plus#kotlin.collections%24plus%28kotlin.collections.Map%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%2C+kotlin.Pair%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%29%2Fpair&quot;&gt;pair&lt;/a&gt; is iterated in the end if it has a unique key.</source>
          <target state="translated">返回的地图保留了原始地图的输入迭代顺序。如果该&lt;a href=&quot;plus#kotlin.collections%24plus%28kotlin.collections.Map%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%2C+kotlin.Pair%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%29%2Fpair&quot;&gt;对&lt;/a&gt;具有唯一密钥，则最后对其进行迭代。</target>
        </trans-unit>
        <trans-unit id="2699ea2c18d183922dd8db09dd9a3f0e18a1eb1d" translate="yes" xml:space="preserve">
          <source>The returned map preserves the entry iteration order of the original map. The &lt;a href=&quot;plus#kotlin.collections%24plus(kotlin.collections.Map((kotlin.collections.plus.K,%20kotlin.collections.plus.V)),%20kotlin.Pair((kotlin.collections.plus.K,%20kotlin.collections.plus.V)))/pair&quot;&gt;pair&lt;/a&gt; is iterated in the end if it has a unique key.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ff3f66b8173f81182161d671f67a90a7b9f8d74" translate="yes" xml:space="preserve">
          <source>The returned map preserves the entry iteration order of the original map. Those &lt;a href=&quot;plus#kotlin.collections%24plus%28kotlin.collections.Map%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%2C+kotlin.Array%28%28kotlin.Pair%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%29%29%29%2Fpairs&quot;&gt;pairs&lt;/a&gt; with unique keys are iterated in the end in the order of &lt;a href=&quot;plus#kotlin.collections%24plus%28kotlin.collections.Map%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%2C+kotlin.Array%28%28kotlin.Pair%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%29%29%29%2Fpairs&quot;&gt;pairs&lt;/a&gt; array.</source>
          <target state="translated">返回的地图保留了原始地图的输入迭代顺序。那些&lt;a href=&quot;plus#kotlin.collections%24plus%28kotlin.collections.Map%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%2C+kotlin.Array%28%28kotlin.Pair%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%29%29%29%2Fpairs&quot;&gt;对&lt;/a&gt;具有独特的键被迭代中的顺序结束&lt;a href=&quot;plus#kotlin.collections%24plus%28kotlin.collections.Map%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%2C+kotlin.Array%28%28kotlin.Pair%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%29%29%29%2Fpairs&quot;&gt;对&lt;/a&gt;数组。</target>
        </trans-unit>
        <trans-unit id="4c15bc5f538aa94ff9d36f2c463553e37bffffa8" translate="yes" xml:space="preserve">
          <source>The returned map preserves the entry iteration order of the original map. Those &lt;a href=&quot;plus#kotlin.collections%24plus%28kotlin.collections.Map%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%2C+kotlin.collections.Iterable%28%28kotlin.Pair%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%29%29%29%2Fpairs&quot;&gt;pairs&lt;/a&gt; with unique keys are iterated in the end in the order of &lt;a href=&quot;plus#kotlin.collections%24plus%28kotlin.collections.Map%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%2C+kotlin.collections.Iterable%28%28kotlin.Pair%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%29%29%29%2Fpairs&quot;&gt;pairs&lt;/a&gt; collection.</source>
          <target state="translated">返回的地图保留了原始地图的输入迭代顺序。最后，按照&lt;a href=&quot;plus#kotlin.collections%24plus%28kotlin.collections.Map%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%2C+kotlin.collections.Iterable%28%28kotlin.Pair%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%29%29%29%2Fpairs&quot;&gt;对&lt;/a&gt;集合的顺序对那些具有唯一密钥的&lt;a href=&quot;plus#kotlin.collections%24plus%28kotlin.collections.Map%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%2C+kotlin.collections.Iterable%28%28kotlin.Pair%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%29%29%29%2Fpairs&quot;&gt;对&lt;/a&gt;进行迭代。</target>
        </trans-unit>
        <trans-unit id="41524b28b32f1890886788ed586175d793500478" translate="yes" xml:space="preserve">
          <source>The returned map preserves the entry iteration order of the original map. Those &lt;a href=&quot;plus#kotlin.collections%24plus%28kotlin.collections.Map%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%2C+kotlin.sequences.Sequence%28%28kotlin.Pair%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%29%29%29%2Fpairs&quot;&gt;pairs&lt;/a&gt; with unique keys are iterated in the end in the order of &lt;a href=&quot;plus#kotlin.collections%24plus%28kotlin.collections.Map%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%2C+kotlin.sequences.Sequence%28%28kotlin.Pair%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%29%29%29%2Fpairs&quot;&gt;pairs&lt;/a&gt; sequence.</source>
          <target state="translated">返回的地图保留了原始地图的输入迭代顺序。最后，按照&lt;a href=&quot;plus#kotlin.collections%24plus%28kotlin.collections.Map%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%2C+kotlin.sequences.Sequence%28%28kotlin.Pair%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%29%29%29%2Fpairs&quot;&gt;对&lt;/a&gt;顺序的顺序对那些具有唯一密钥的&lt;a href=&quot;plus#kotlin.collections%24plus%28kotlin.collections.Map%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%2C+kotlin.sequences.Sequence%28%28kotlin.Pair%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%29%29%29%2Fpairs&quot;&gt;对&lt;/a&gt;进行迭代。</target>
        </trans-unit>
        <trans-unit id="f1a276280301194297ba4dd69f82e32624b066f0" translate="yes" xml:space="preserve">
          <source>The returned map preserves the entry iteration order of the original map. Those &lt;a href=&quot;plus#kotlin.collections%24plus(kotlin.collections.Map((kotlin.collections.plus.K,%20kotlin.collections.plus.V)),%20kotlin.Array((kotlin.Pair((kotlin.collections.plus.K,%20kotlin.collections.plus.V)))))/pairs&quot;&gt;pairs&lt;/a&gt; with unique keys are iterated in the end in the order of &lt;a href=&quot;plus#kotlin.collections%24plus(kotlin.collections.Map((kotlin.collections.plus.K,%20kotlin.collections.plus.V)),%20kotlin.Array((kotlin.Pair((kotlin.collections.plus.K,%20kotlin.collections.plus.V)))))/pairs&quot;&gt;pairs&lt;/a&gt; array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60a4b6ca8bf806aec99d136cb53e3d0881c0b238" translate="yes" xml:space="preserve">
          <source>The returned map preserves the entry iteration order of the original map. Those &lt;a href=&quot;plus#kotlin.collections%24plus(kotlin.collections.Map((kotlin.collections.plus.K,%20kotlin.collections.plus.V)),%20kotlin.collections.Iterable((kotlin.Pair((kotlin.collections.plus.K,%20kotlin.collections.plus.V)))))/pairs&quot;&gt;pairs&lt;/a&gt; with unique keys are iterated in the end in the order of &lt;a href=&quot;plus#kotlin.collections%24plus(kotlin.collections.Map((kotlin.collections.plus.K,%20kotlin.collections.plus.V)),%20kotlin.collections.Iterable((kotlin.Pair((kotlin.collections.plus.K,%20kotlin.collections.plus.V)))))/pairs&quot;&gt;pairs&lt;/a&gt; collection.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1d13bbc3f9bab24f8a9c962714d64145931ced0" translate="yes" xml:space="preserve">
          <source>The returned map preserves the entry iteration order of the original map. Those &lt;a href=&quot;plus#kotlin.collections%24plus(kotlin.collections.Map((kotlin.collections.plus.K,%20kotlin.collections.plus.V)),%20kotlin.sequences.Sequence((kotlin.Pair((kotlin.collections.plus.K,%20kotlin.collections.plus.V)))))/pairs&quot;&gt;pairs&lt;/a&gt; with unique keys are iterated in the end in the order of &lt;a href=&quot;plus#kotlin.collections%24plus(kotlin.collections.Map((kotlin.collections.plus.K,%20kotlin.collections.plus.V)),%20kotlin.sequences.Sequence((kotlin.Pair((kotlin.collections.plus.K,%20kotlin.collections.plus.V)))))/pairs&quot;&gt;pairs&lt;/a&gt; sequence.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af1ab049b7a80d37b426b5189d29b3d33630f886" translate="yes" xml:space="preserve">
          <source>The returned map preserves the entry iteration order of the original map. Those entries of another &lt;a href=&quot;plus#kotlin.collections%24plus%28kotlin.collections.Map%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%2C+kotlin.collections.Map%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%29%2Fmap&quot;&gt;map&lt;/a&gt; that are missing in this map are iterated in the end in the order of that &lt;a href=&quot;plus#kotlin.collections%24plus%28kotlin.collections.Map%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%2C+kotlin.collections.Map%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%29%2Fmap&quot;&gt;map&lt;/a&gt;.</source>
          <target state="translated">返回的地图保留了原始地图的输入迭代顺序。最后，按照该&lt;a href=&quot;plus#kotlin.collections%24plus%28kotlin.collections.Map%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%2C+kotlin.collections.Map%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%29%2Fmap&quot;&gt;映射&lt;/a&gt;的顺序对另一个&lt;a href=&quot;plus#kotlin.collections%24plus%28kotlin.collections.Map%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%2C+kotlin.collections.Map%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%29%2Fmap&quot;&gt;映射&lt;/a&gt;中缺少的条目进行迭代。</target>
        </trans-unit>
        <trans-unit id="9b1dd6b497b334d1c744c85f81ba4c2ff9742b26" translate="yes" xml:space="preserve">
          <source>The returned map preserves the entry iteration order of the original map. Those entries of another &lt;a href=&quot;plus#kotlin.collections%24plus(kotlin.collections.Map((kotlin.collections.plus.K,%20kotlin.collections.plus.V)),%20kotlin.collections.Map((kotlin.collections.plus.K,%20kotlin.collections.plus.V)))/map&quot;&gt;map&lt;/a&gt; that are missing in this map are iterated in the end in the order of that &lt;a href=&quot;plus#kotlin.collections%24plus(kotlin.collections.Map((kotlin.collections.plus.K,%20kotlin.collections.plus.V)),%20kotlin.collections.Map((kotlin.collections.plus.K,%20kotlin.collections.plus.V)))/map&quot;&gt;map&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="048dcd341f30e50bd04dda11327a4ef88e0d2612" translate="yes" xml:space="preserve">
          <source>The returned map preserves the entry iteration order of the original sequence.</source>
          <target state="translated">返回的映射保留了原始序列的入口迭代顺序。</target>
        </trans-unit>
        <trans-unit id="bba2889b44a4cec09a40249a683767a797d71e14" translate="yes" xml:space="preserve">
          <source>The returned map preserves the entry iteration order of the original sequence. If any of two pairs would have the same key the last one gets added to the map.</source>
          <target state="translated">返回的映射保留了原始序列的条目迭代顺序。如果任何两对中有相同的键,最后一个会被添加到映射中。</target>
        </trans-unit>
        <trans-unit id="b48dc5da4ba5d84bf8f51570f1be30c9067ca36a" translate="yes" xml:space="preserve">
          <source>The returned map preserves the entry iteration order.</source>
          <target state="translated">返回的地图保留了条目迭代顺序。</target>
        </trans-unit>
        <trans-unit id="d70c61d5fb5764eefc41a239b3b607225317f588" translate="yes" xml:space="preserve">
          <source>The returned sequence is constrained to be iterated only once.</source>
          <target state="translated">返回的序列被约束为只能迭代一次。</target>
        </trans-unit>
        <trans-unit id="a79b9e6a21565ad6033f2ab5027e737873a51569" translate="yes" xml:space="preserve">
          <source>The returned sequence is empty if this sequence contains less than two elements.</source>
          <target state="translated">如果这个序列包含的元素少于两个,则返回的序列为空。</target>
        </trans-unit>
        <trans-unit id="7927ae1e5106eaeb7bb0b0dc1138826c33d1919c" translate="yes" xml:space="preserve">
          <source>The returned set preserves the element iteration order of the original array.</source>
          <target state="translated">返回的集合保留了原始数组的元素迭代顺序。</target>
        </trans-unit>
        <trans-unit id="8e820b287237249236a403161f0b70ed17d391a2" translate="yes" xml:space="preserve">
          <source>The returned set preserves the element iteration order of the original array. Those elements of the &lt;a href=&quot;union#kotlin.collections%24union%28kotlin.Array%28%28kotlin.collections.union.T%29%29%2C+kotlin.collections.Iterable%28%28kotlin.collections.union.T%29%29%29%2Fother&quot;&gt;other&lt;/a&gt; collection that are unique are iterated in the end in the order of the &lt;a href=&quot;union#kotlin.collections%24union%28kotlin.Array%28%28kotlin.collections.union.T%29%29%2C+kotlin.collections.Iterable%28%28kotlin.collections.union.T%29%29%29%2Fother&quot;&gt;other&lt;/a&gt; collection.</source>
          <target state="translated">返回的集合保留原始数组的元素迭代顺序。最后，以&lt;a href=&quot;union#kotlin.collections%24union%28kotlin.Array%28%28kotlin.collections.union.T%29%29%2C+kotlin.collections.Iterable%28%28kotlin.collections.union.T%29%29%29%2Fother&quot;&gt;另一个&lt;/a&gt;集合的顺序迭代&lt;a href=&quot;union#kotlin.collections%24union%28kotlin.Array%28%28kotlin.collections.union.T%29%29%2C+kotlin.collections.Iterable%28%28kotlin.collections.union.T%29%29%29%2Fother&quot;&gt;另一个&lt;/a&gt;集合中唯一的那些元素。</target>
        </trans-unit>
        <trans-unit id="3daac3d7a93bd39f019e22a0fe48ced02c6896f9" translate="yes" xml:space="preserve">
          <source>The returned set preserves the element iteration order of the original array. Those elements of the &lt;a href=&quot;union#kotlin.collections%24union(kotlin.Array((kotlin.collections.union.T)),%20kotlin.collections.Iterable((kotlin.collections.union.T)))/other&quot;&gt;other&lt;/a&gt; collection that are unique are iterated in the end in the order of the &lt;a href=&quot;union#kotlin.collections%24union(kotlin.Array((kotlin.collections.union.T)),%20kotlin.collections.Iterable((kotlin.collections.union.T)))/other&quot;&gt;other&lt;/a&gt; collection.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2b309c05bb0df5183017b60bb11949ef16cec12" translate="yes" xml:space="preserve">
          <source>The returned set preserves the element iteration order of the original char sequence.</source>
          <target state="translated">返回的集合保留了原始char序列的元素迭代顺序。</target>
        </trans-unit>
        <trans-unit id="77b699621c7e191100bcd082c9accf071cd60f08" translate="yes" xml:space="preserve">
          <source>The returned set preserves the element iteration order of the original collection.</source>
          <target state="translated">返回的集合保留了原始集合的元素迭代顺序。</target>
        </trans-unit>
        <trans-unit id="ed96aca660cbd3c3aee98cb1f013ac3448395f47" translate="yes" xml:space="preserve">
          <source>The returned set preserves the element iteration order of the original collection. Those elements of the &lt;a href=&quot;union#kotlin.collections%24union%28kotlin.collections.Iterable%28%28kotlin.collections.union.T%29%29%2C+kotlin.collections.Iterable%28%28kotlin.collections.union.T%29%29%29%2Fother&quot;&gt;other&lt;/a&gt; collection that are unique are iterated in the end in the order of the &lt;a href=&quot;union#kotlin.collections%24union%28kotlin.collections.Iterable%28%28kotlin.collections.union.T%29%29%2C+kotlin.collections.Iterable%28%28kotlin.collections.union.T%29%29%29%2Fother&quot;&gt;other&lt;/a&gt; collection.</source>
          <target state="translated">返回的集合保留原始集合的元素迭代顺序。最后，按照&lt;a href=&quot;union#kotlin.collections%24union%28kotlin.collections.Iterable%28%28kotlin.collections.union.T%29%29%2C+kotlin.collections.Iterable%28%28kotlin.collections.union.T%29%29%29%2Fother&quot;&gt;另一个&lt;/a&gt;集合的顺序迭代&lt;a href=&quot;union#kotlin.collections%24union%28kotlin.collections.Iterable%28%28kotlin.collections.union.T%29%29%2C+kotlin.collections.Iterable%28%28kotlin.collections.union.T%29%29%29%2Fother&quot;&gt;另一个&lt;/a&gt;集合中唯一的那些元素。</target>
        </trans-unit>
        <trans-unit id="c4910c50663c8a64b733d52ca426f65568fa0287" translate="yes" xml:space="preserve">
          <source>The returned set preserves the element iteration order of the original collection. Those elements of the &lt;a href=&quot;union#kotlin.collections%24union(kotlin.collections.Iterable((kotlin.collections.union.T)),%20kotlin.collections.Iterable((kotlin.collections.union.T)))/other&quot;&gt;other&lt;/a&gt; collection that are unique are iterated in the end in the order of the &lt;a href=&quot;union#kotlin.collections%24union(kotlin.collections.Iterable((kotlin.collections.union.T)),%20kotlin.collections.Iterable((kotlin.collections.union.T)))/other&quot;&gt;other&lt;/a&gt; collection.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b556a6977dd4e71f20e303d7d9385040d75f0ac7" translate="yes" xml:space="preserve">
          <source>The returned set preserves the element iteration order of the original sequence.</source>
          <target state="translated">返回的集合保留了原始序列的元素迭代顺序。</target>
        </trans-unit>
        <trans-unit id="eddbfc5096c56b9aafbe04f2e54352a74a62ad62" translate="yes" xml:space="preserve">
          <source>The returned set preserves the element iteration order of the original set.</source>
          <target state="translated">返回的集合保留了原集合的元素迭代顺序。</target>
        </trans-unit>
        <trans-unit id="4e9b4d20ac671bfe117e4f28b0081ad091c327b5" translate="yes" xml:space="preserve">
          <source>The returned set preserves the element iteration order.</source>
          <target state="translated">返回的集合保留了元素迭代顺序。</target>
        </trans-unit>
        <trans-unit id="7c0e13333db8789388b9d52adff49d100d5cf6ca" translate="yes" xml:space="preserve">
          <source>The returned value is &lt;code&gt;y&lt;/code&gt; such that &lt;code&gt;sinh(y) == x&lt;/code&gt;.</source>
          <target state="translated">返回值是 &lt;code&gt;y&lt;/code&gt; ，使得 &lt;code&gt;sinh(y) == x&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f0a819fc71728e449a1fa0a52b2d805fcb67dfe6" translate="yes" xml:space="preserve">
          <source>The returned value is &lt;code&gt;y&lt;/code&gt; such that &lt;code&gt;tanh(y) == x&lt;/code&gt;.</source>
          <target state="translated">返回值是 &lt;code&gt;y&lt;/code&gt; ，使得 &lt;code&gt;tanh(y) == x&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="38db1bb7310932e868d4c70216856f90e11179f2" translate="yes" xml:space="preserve">
          <source>The returned value is positive &lt;code&gt;y&lt;/code&gt; such that &lt;code&gt;cosh(y) == x&lt;/code&gt;.</source>
          <target state="translated">返回值是正 &lt;code&gt;y&lt;/code&gt; ，使得 &lt;code&gt;cosh(y) == x&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="92462ffebca930d13f4cb4aaee4b7842f4ea14de" translate="yes" xml:space="preserve">
          <source>The returned value of a &lt;em&gt;try&lt;/em&gt;-expression is either the last expression in the &lt;em&gt;try&lt;/em&gt; block or the last expression in the &lt;em&gt;catch&lt;/em&gt; block (or blocks). Contents of the &lt;em&gt;finally&lt;/em&gt; block do not affect the result of the expression.</source>
          <target state="translated">&lt;em&gt;try&lt;/em&gt; -expression 的返回值是&lt;em&gt;try&lt;/em&gt;块中的最后一个表达式或&lt;em&gt;catch&lt;/em&gt;块（或多个块）中的最后一个表达式。&lt;em&gt;finally&lt;/em&gt;块的内容不影响表达式的结果。</target>
        </trans-unit>
        <trans-unit id="261319d8fec52739ec6c832665ae3f7dbd0e5025" translate="yes" xml:space="preserve">
          <source>The root of the Kotlin class hierarchy. Every Kotlin class has &lt;a href=&quot;-any/index#kotlin.Any&quot;&gt;Any&lt;/a&gt; as a superclass.</source>
          <target state="translated">Kotlin类层次结构的根。每个Kotlin类都有&lt;a href=&quot;-any/index#kotlin.Any&quot;&gt;Any&lt;/a&gt;作为超类。</target>
        </trans-unit>
        <trans-unit id="a55ae833319a2f8e509e5aee918452e19eb747a8" translate="yes" xml:space="preserve">
          <source>The root of the Kotlin class hierarchy. Every Kotlin class has &lt;a href=&quot;index#kotlin.Any&quot;&gt;Any&lt;/a&gt; as a superclass.</source>
          <target state="translated">Kotlin类层次结构的根。每个Kotlin类都有&lt;a href=&quot;index#kotlin.Any&quot;&gt;Any&lt;/a&gt;作为超类。</target>
        </trans-unit>
        <trans-unit id="98512a74a1640b8252b93eb9be999aab21267c59" translate="yes" xml:space="preserve">
          <source>The runner will set the value for the property system.path.macro.KOTLIN.BUNDLED to the correct one based on the path settings from the IntelliJ IDEA project. However this value needs to be defined in TeamCity (and can be set to any value). Therefore we need to define it as a system variable.</source>
          <target state="translated">运行器将根据IntelliJ IDEA项目中的路径设置,将属性system.path.macro.KOTLIN.BUNDLED的值设置为正确的值。然而这个值需要在TeamCity中定义(可以设置为任何值)。因此我们需要将其定义为一个系统变量。</target>
        </trans-unit>
        <trans-unit id="578262526068b614504d1b18d76cf8dea19e1504" translate="yes" xml:space="preserve">
          <source>The same is available for maps with the functions &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/map-of&quot;&gt;&lt;code&gt;mapOf()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/mutable-map-of&quot;&gt;&lt;code&gt;mutableMapOf()&lt;/code&gt;&lt;/a&gt;. The map's keys and values are passed as &lt;code&gt;Pair&lt;/code&gt; objects (usually created with &lt;code&gt;to&lt;/code&gt; infix function).</source>
          <target state="translated">具有&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/mutable-map-of&quot;&gt; &lt;code&gt;mutableMapOf()&lt;/code&gt; &lt;/a&gt;和mutableMapOf（）函数的&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/map-of&quot;&gt; &lt;code&gt;mapOf()&lt;/code&gt; &lt;/a&gt;也可以使用此功能。映射的键和值作为 &lt;code&gt;Pair&lt;/code&gt; 对象（通常使用 &lt;code&gt;to&lt;/code&gt; infix函数创建）传递。</target>
        </trans-unit>
        <trans-unit id="25f5c97c541192ff226fb77118f20b9141f29a81" translate="yes" xml:space="preserve">
          <source>The same rules are used by the Kotlin/Native compiler to generate the &lt;code&gt;.h&lt;/code&gt; file for all platforms.</source>
          <target state="translated">Kotlin / Native编译器使用相同的规则为所有平台生成 &lt;code&gt;.h&lt;/code&gt; 文件。</target>
        </trans-unit>
        <trans-unit id="dac2ac98305c82e23b60095cae0d9b066592bfa3" translate="yes" xml:space="preserve">
          <source>The same set of functions (but without constants) is also available for &lt;code&gt;Float&lt;/code&gt; arguments.</source>
          <target state="translated">相同的函数集（但没有常量）也可用于 &lt;code&gt;Float&lt;/code&gt; 参数。</target>
        </trans-unit>
        <trans-unit id="afd6887219148439be70535c83e0ab200b27625e" translate="yes" xml:space="preserve">
          <source>The same syntax can be used to annotate the entire file. To do this, put an annotation with the target &lt;code&gt;file&lt;/code&gt; at the top level of a file, before the package directive or before all imports if the file is in the default package:</source>
          <target state="translated">可以使用相同的语法来注释整个文件。为此，请将注释与目标 &lt;code&gt;file&lt;/code&gt; 一起放在文件的最高级别，package指令之前或所有导入之前（如果该文件位于默认软件包中）：</target>
        </trans-unit>
        <trans-unit id="2ae227fcecaec9d7de3afec1996267608672f87b" translate="yes" xml:space="preserve">
          <source>The same syntax with omitted type arguments can be used for casts that do not take type arguments into account: &lt;code&gt;list as ArrayList&lt;/code&gt;.</source>
          <target state="translated">省略类型参数的语法可以用于不考虑类型参数的类型转换： &lt;code&gt;list as ArrayList&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="998fefac425fa7727b709de3b80c938ce507ca90" translate="yes" xml:space="preserve">
          <source>The same trick applies when we need to have a property &lt;code&gt;x&lt;/code&gt; alongside with a function &lt;code&gt;getX()&lt;/code&gt;:</source>
          <target state="translated">当我们需要同时具有属性 &lt;code&gt;x&lt;/code&gt; 和函数 &lt;code&gt;getX()&lt;/code&gt; 时，同样的技巧也适用：</target>
        </trans-unit>
        <trans-unit id="7028478d43f0e9046e167eadedccdd38efaac612" translate="yes" xml:space="preserve">
          <source>The same type parameter can be used in both covariant and contravariant projections (because it's the generic classes that are being projected, not the type parameter):</source>
          <target state="translated">相同的类型参数可以在共变和反变投影中使用(因为被投影的是泛类,而不是类型参数)。</target>
        </trans-unit>
        <trans-unit id="e34374077b9198e942d005d02c16935775597fa6" translate="yes" xml:space="preserve">
          <source>The scale of the result is the same as the scale of &lt;code&gt;this&lt;/code&gt; (divident), and for rounding the &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/math/RoundingMode.html#HALF_EVEN&quot;&gt;RoundingMode.HALF_EVEN&lt;/a&gt; rounding mode is used.</source>
          <target state="translated">结果的小数位数与 &lt;code&gt;this&lt;/code&gt; （小数）的小数位数相同，并且用于取&lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/math/RoundingMode.html#HALF_EVEN&quot;&gt;整RoundingMode.HALF_EVEN取&lt;/a&gt;整模式。</target>
        </trans-unit>
        <trans-unit id="862c489ca779c92aa7c1ebb24e7220c5850ae722" translate="yes" xml:space="preserve">
          <source>The scale of the result is the same as the scale of &lt;code&gt;this&lt;/code&gt; (divident), and for rounding the &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/math/RoundingMode.html#HALF_EVEN&quot;&gt;RoundingMode.HALF_EVEN&lt;/a&gt; rounding mode is used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f22bffdb314393bc05bae9820f09e84c2f28f7a7" translate="yes" xml:space="preserve">
          <source>The scope for yielding values of a &lt;a href=&quot;-sequence/index&quot;&gt;Sequence&lt;/a&gt; or an &lt;a href=&quot;../kotlin.collections/-iterator/index#kotlin.collections.Iterator&quot;&gt;Iterator&lt;/a&gt;, provides &lt;a href=&quot;-sequence-scope/yield&quot;&gt;yield&lt;/a&gt; and &lt;a href=&quot;-sequence-scope/yield-all&quot;&gt;yieldAll&lt;/a&gt; suspension functions.</source>
          <target state="translated">产生&lt;a href=&quot;-sequence/index&quot;&gt;Sequence&lt;/a&gt;或&lt;a href=&quot;../kotlin.collections/-iterator/index#kotlin.collections.Iterator&quot;&gt;Iterator的&lt;/a&gt;值的范围提供了&lt;a href=&quot;-sequence-scope/yield&quot;&gt;yield&lt;/a&gt;和&lt;a href=&quot;-sequence-scope/yield-all&quot;&gt;yieldAll&lt;/a&gt;暂停函数。</target>
        </trans-unit>
        <trans-unit id="4a3f3df589995633decc0a7530a1bb032d855ae5" translate="yes" xml:space="preserve">
          <source>The scope for yielding values of a &lt;a href=&quot;../-sequence/index&quot;&gt;Sequence&lt;/a&gt; or an &lt;a href=&quot;../../kotlin.collections/-iterator/index#kotlin.collections.Iterator&quot;&gt;Iterator&lt;/a&gt;, provides &lt;a href=&quot;yield&quot;&gt;yield&lt;/a&gt; and &lt;a href=&quot;yield-all&quot;&gt;yieldAll&lt;/a&gt; suspension functions.</source>
          <target state="translated">产生&lt;a href=&quot;../-sequence/index&quot;&gt;Sequence&lt;/a&gt;或&lt;a href=&quot;../../kotlin.collections/-iterator/index#kotlin.collections.Iterator&quot;&gt;Iterator的&lt;/a&gt;值的范围提供了&lt;a href=&quot;yield&quot;&gt;yield&lt;/a&gt;和&lt;a href=&quot;yield-all&quot;&gt;yieldAll&lt;/a&gt;暂停函数。</target>
        </trans-unit>
        <trans-unit id="a36f2feb54110b2ee9d15c70833427be6cae37ba" translate="yes" xml:space="preserve">
          <source>The scope for yielding values of a &lt;a href=&quot;../../kotlin.sequences/-sequence/index&quot;&gt;Sequence&lt;/a&gt; or an &lt;a href=&quot;../../kotlin.collections/-iterator/index#kotlin.collections.Iterator&quot;&gt;Iterator&lt;/a&gt;, provides &lt;a href=&quot;../../kotlin.sequences/-sequence-scope/yield&quot;&gt;yield&lt;/a&gt; and &lt;a href=&quot;../../kotlin.sequences/-sequence-scope/yield-all&quot;&gt;yieldAll&lt;/a&gt; suspension functions.</source>
          <target state="translated">产生&lt;a href=&quot;../../kotlin.sequences/-sequence/index&quot;&gt;Sequence&lt;/a&gt;或&lt;a href=&quot;../../kotlin.collections/-iterator/index#kotlin.collections.Iterator&quot;&gt;Iterator的&lt;/a&gt;值的范围提供了&lt;a href=&quot;../../kotlin.sequences/-sequence-scope/yield&quot;&gt;yield&lt;/a&gt;和&lt;a href=&quot;../../kotlin.sequences/-sequence-scope/yield-all&quot;&gt;yieldAll&lt;/a&gt;暂停函数。</target>
        </trans-unit>
        <trans-unit id="f47c36946d42e828300cda7cb035fe509918aa59" translate="yes" xml:space="preserve">
          <source>The scope functions differ by the result they return:</source>
          <target state="translated">范围函数因其返回的结果而不同。</target>
        </trans-unit>
        <trans-unit id="8f4977d6e6dad61eba46e51272eff7452a6f78a7" translate="yes" xml:space="preserve">
          <source>The scope functions do not introduce any new technical capabilities, but they can make your code more concise and readable.</source>
          <target state="translated">范围函数并没有引入任何新的技术能力,但它们可以使你的代码更加简洁和可读。</target>
        </trans-unit>
        <trans-unit id="5f41bf24b11179244ce6543e55a837627d8700cb" translate="yes" xml:space="preserve">
          <source>The second line is the &lt;code&gt;headerFilter&lt;/code&gt;. This is used to denote what exactly we want included. In C, when one file references another file with the &lt;code&gt;#include&lt;/code&gt; directive, all the headers are also included. Sometimes this may not be needed, and we can use this parameter, &lt;a href=&quot;https://en.wikipedia.org/wiki/Glob_(programming)&quot;&gt;using glob patterns&lt;/a&gt;, to fine tune things. Note, that &lt;code&gt;headerFilter&lt;/code&gt; is an optional argument and mostly only used when the library we're using is being installed as a system library, and we do not want to fetch external dependencies (such as system &lt;code&gt;stdint.h&lt;/code&gt; header) into our interop library. It may be important for both optimizing the library size and fixing potential conflicts between the system and the Kotlin/Native provided compilation environment.</source>
          <target state="translated">第二行是 &lt;code&gt;headerFilter&lt;/code&gt; 。这用来表示我们想要包含的内容。在C语言中，当一个文件使用 &lt;code&gt;#include&lt;/code&gt; 指令引用另一个文件时，还将包含所有标头。有时可能不需要这样做，我们可以使用&lt;a href=&quot;https://en.wikipedia.org/wiki/Glob_(programming)&quot;&gt;glob模式&lt;/a&gt;使用此参数来微调事物。请注意， &lt;code&gt;headerFilter&lt;/code&gt; 是一个可选参数，并且仅在将要使用的库作为系统库安装时才使用，并且我们不想将外部依赖项（例如系统 &lt;code&gt;stdint.h&lt;/code&gt; 标头）提取到我们的互操作库中。这对于优化库大小以及修复系统与Kotlin / Native提供的编译环境之间的潜在冲突都可能很重要。</target>
        </trans-unit>
        <trans-unit id="840619ade32a5f33b95550212b369e6072d8ca9d" translate="yes" xml:space="preserve">
          <source>The second list contains the second elements.</source>
          <target state="translated">第二个列表包含第二个元素。</target>
        </trans-unit>
        <trans-unit id="61c6cf9e9e7f1d565d89fe5986da63f4fbcd432b" translate="yes" xml:space="preserve">
          <source>The second observation, is that &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/on-receive-or-null.html&quot;&gt;onReceiveOrNull&lt;/a&gt; gets immediately selected when the channel is already closed.</source>
          <target state="translated">第二个观察结果是，当通道已经关闭时，&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/on-receive-or-null.html&quot;&gt;onReceiveOrNull&lt;/a&gt;立即被选择。</target>
        </trans-unit>
        <trans-unit id="90bb330cf5e09011380c337ab5bbdf9ebc55c7f5" translate="yes" xml:space="preserve">
          <source>The second step is to configure the framework search path of the produced binary. It is also known as &lt;code&gt;rpath&lt;/code&gt; or &lt;a href=&quot;https://en.wikipedia.org/wiki/Rpath&quot;&gt;run-time search path&lt;/a&gt;. The binary uses the path to look for the required frameworks. We do not recommend installing additional frameworks to the OS if it is not needed. We should understand the layout of our future application, for example, we may have the &lt;code&gt;Frameworks&lt;/code&gt; folder under the application bundle with all the frameworks we use. The &lt;code&gt;@rpath&lt;/code&gt; parameter can be configured in Xcode. We need to open the &lt;em&gt;project&lt;/em&gt; configuration and find the &lt;code&gt;Runpath Search Paths&lt;/code&gt; section. Here we specify the relative path to the compiled framework.</source>
          <target state="translated">第二步是配置生成的二进制文件的框架搜索路径。也称为 &lt;code&gt;rpath&lt;/code&gt; 或&lt;a href=&quot;https://en.wikipedia.org/wiki/Rpath&quot;&gt;运行时搜索路径&lt;/a&gt;。二进制文件使用该路径查找所需的框架。如果不需要，我们不建议在操作系统上安装其他框架。我们应该了解未来应用程序的布局，例如，在应用程序捆绑包中，我们可能会拥有所有使用的框架的 &lt;code&gt;Frameworks&lt;/code&gt; 文件夹。所述 &lt;code&gt;@rpath&lt;/code&gt; 参数可以在Xcode进行配置。我们需要打开&lt;em&gt;项目&lt;/em&gt;配置并找到&amp;ldquo; &lt;code&gt;Runpath Search Paths&lt;/code&gt; 部分。在这里，我们指定了已编译框架的相对路径。</target>
        </trans-unit>
        <trans-unit id="654406bf07807fb9a1c468fda5253d223f604a77" translate="yes" xml:space="preserve">
          <source>The second step is to then include the framework path into the &lt;code&gt;Framework Search Paths&lt;/code&gt; block of the &lt;code&gt;Build Settings&lt;/code&gt; section of the &lt;em&gt;target&lt;/em&gt; configuration page. It is possible to use &lt;code&gt;$(PROJECT_DIR)&lt;/code&gt; macro to simplify the setup.</source>
          <target state="translated">然后，第二步是将框架路径包括在&lt;em&gt;目标&lt;/em&gt;配置页面的&amp;ldquo; &lt;code&gt;Build Settings&lt;/code&gt; 部分的&amp;ldquo; &lt;code&gt;Framework Search Paths&lt;/code&gt; 块中。可以使用 &lt;code&gt;$(PROJECT_DIR)&lt;/code&gt; 宏来简化设置。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="18e3a3f25c81d64436deec2668dbca688024cd76" translate="yes" xml:space="preserve">
          <source>The second way is using typed getters. These getters allow one to access a binary of a certain type by its name prefix and build type.</source>
          <target state="translated">第二种方式是使用类型化的获取器。这些获取器允许人们通过其名称前缀和构建类型来访问某个类型的二进制。</target>
        </trans-unit>
        <trans-unit id="827737115fbde8c1114cdac2570a8c2c25e8999d" translate="yes" xml:space="preserve">
          <source>The sequence can be iterated multiple times, each time starting with &lt;a href=&quot;generate-sequence#kotlin.sequences%24generateSequence%28kotlin.sequences.generateSequence.T%2C+kotlin.Function1%28%28kotlin.sequences.generateSequence.T%2C+kotlin.sequences.generateSequence.T%29%29%29%2Fseed&quot;&gt;seed&lt;/a&gt;.</source>
          <target state="translated">该序列可以迭代多次，每次都以&lt;a href=&quot;generate-sequence#kotlin.sequences%24generateSequence%28kotlin.sequences.generateSequence.T%2C+kotlin.Function1%28%28kotlin.sequences.generateSequence.T%2C+kotlin.sequences.generateSequence.T%29%29%29%2Fseed&quot;&gt;seed&lt;/a&gt;开头。</target>
        </trans-unit>
        <trans-unit id="fc73d4e6f9fffbb0e65e07b8a9240c6689985bdd" translate="yes" xml:space="preserve">
          <source>The sequence can be iterated multiple times, each time starting with &lt;a href=&quot;generate-sequence#kotlin.sequences%24generateSequence(kotlin.sequences.generateSequence.T?,%20kotlin.Function1((kotlin.sequences.generateSequence.T,%20kotlin.sequences.generateSequence.T?)))/seed&quot;&gt;seed&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0eda5b13d201be08982eef0e6ce47fb43644a540" translate="yes" xml:space="preserve">
          <source>The sequence can be iterated multiple times.</source>
          <target state="translated">该序列可以多次迭代。</target>
        </trans-unit>
        <trans-unit id="0a85208253c6224f238363151292bff48ddafdf4" translate="yes" xml:space="preserve">
          <source>The sequence can be potentially infinite.</source>
          <target state="translated">序列可以是潜在的无限的。</target>
        </trans-unit>
        <trans-unit id="0e5675a51efa9f06e75cacd0d5cc4fa5944cc8f4" translate="yes" xml:space="preserve">
          <source>The sequence of values returned by the given iterator can be potentially infinite.</source>
          <target state="translated">给定迭代器返回的值序列可能是无限的。</target>
        </trans-unit>
        <trans-unit id="7d79c1f34f116fdb6c923fac302558f761c71524" translate="yes" xml:space="preserve">
          <source>The sequence operations can be classified into the following groups regarding their state requirements:</source>
          <target state="translated">序列操作按其状态要求可分为以下几组。</target>
        </trans-unit>
        <trans-unit id="30c4d2821891f6cd1d6f9f4ff92091f8670df4f6" translate="yes" xml:space="preserve">
          <source>The sequence processing goes like this:</source>
          <target state="translated">顺序处理是这样的。</target>
        </trans-unit>
        <trans-unit id="037cfea620d6aaba99a768d063c28b857dfd0b60" translate="yes" xml:space="preserve">
          <source>The sequence produces values until it encounters first &lt;code&gt;null&lt;/code&gt; value. If &lt;a href=&quot;generate-sequence#kotlin.sequences%24generateSequence%28kotlin.Function0%28%28kotlin.sequences.generateSequence.T%29%29%2C+kotlin.Function1%28%28kotlin.sequences.generateSequence.T%2C+kotlin.sequences.generateSequence.T%29%29%29%2FseedFunction&quot;&gt;seedFunction&lt;/a&gt; returns &lt;code&gt;null&lt;/code&gt;, an empty sequence is produced.</source>
          <target state="translated">该序列产生值，直到遇到第一个 &lt;code&gt;null&lt;/code&gt; 值。如果&lt;a href=&quot;generate-sequence#kotlin.sequences%24generateSequence%28kotlin.Function0%28%28kotlin.sequences.generateSequence.T%29%29%2C+kotlin.Function1%28%28kotlin.sequences.generateSequence.T%2C+kotlin.sequences.generateSequence.T%29%29%29%2FseedFunction&quot;&gt;seedFunction&lt;/a&gt;返回 &lt;code&gt;null&lt;/code&gt; ，那么将生成一个空序列。</target>
        </trans-unit>
        <trans-unit id="6f1a48a2bbbc690466820f3b0f0b43bc4de3e6e5" translate="yes" xml:space="preserve">
          <source>The sequence produces values until it encounters first &lt;code&gt;null&lt;/code&gt; value. If &lt;a href=&quot;generate-sequence#kotlin.sequences%24generateSequence%28kotlin.sequences.generateSequence.T%2C+kotlin.Function1%28%28kotlin.sequences.generateSequence.T%2C+kotlin.sequences.generateSequence.T%29%29%29%2Fseed&quot;&gt;seed&lt;/a&gt; is &lt;code&gt;null&lt;/code&gt;, an empty sequence is produced.</source>
          <target state="translated">该序列产生值，直到遇到第一个 &lt;code&gt;null&lt;/code&gt; 值。如果&lt;a href=&quot;generate-sequence#kotlin.sequences%24generateSequence%28kotlin.sequences.generateSequence.T%2C+kotlin.Function1%28%28kotlin.sequences.generateSequence.T%2C+kotlin.sequences.generateSequence.T%29%29%29%2Fseed&quot;&gt;seed&lt;/a&gt;为 &lt;code&gt;null&lt;/code&gt; ，则产生一个空序列。</target>
        </trans-unit>
        <trans-unit id="7f85b3586f825638607e86e68f4e2c3390aaa658" translate="yes" xml:space="preserve">
          <source>The sequence produces values until it encounters first &lt;code&gt;null&lt;/code&gt; value. If &lt;a href=&quot;generate-sequence#kotlin.sequences%24generateSequence(kotlin.Function0((kotlin.sequences.generateSequence.T?)),%20kotlin.Function1((kotlin.sequences.generateSequence.T,%20kotlin.sequences.generateSequence.T?)))/seedFunction&quot;&gt;seedFunction&lt;/a&gt; returns &lt;code&gt;null&lt;/code&gt;, an empty sequence is produced.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2bd1e283bb0d03da60d7adf31bcae11b19146a2e" translate="yes" xml:space="preserve">
          <source>The sequence produces values until it encounters first &lt;code&gt;null&lt;/code&gt; value. If &lt;a href=&quot;generate-sequence#kotlin.sequences%24generateSequence(kotlin.sequences.generateSequence.T?,%20kotlin.Function1((kotlin.sequences.generateSequence.T,%20kotlin.sequences.generateSequence.T?)))/seed&quot;&gt;seed&lt;/a&gt; is &lt;code&gt;null&lt;/code&gt;, an empty sequence is produced.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a3082b192dc0701c42da2f86e13f788df24a0f1" translate="yes" xml:space="preserve">
          <source>The set of all possible types that can be substituted for a given type parameter may be restricted by &lt;strong&gt;generic constraints&lt;/strong&gt;.</source>
          <target state="translated">可以用给定类型参数替代的所有可能类型的集合可能受到&lt;strong&gt;通用约束的限制&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="bf0dd762f332fcd86a0727fbb8e23b4a1bb32f29" translate="yes" xml:space="preserve">
          <source>The set of options that were used to create this regular expression.</source>
          <target state="translated">用于创建该正则表达式的一组选项。</target>
        </trans-unit>
        <trans-unit id="459759855b3639a06e88e0e2596d7493a847d411" translate="yes" xml:space="preserve">
          <source>The set of target platforms is defined by a multiplatform library author, and they should provide all of the platform-specific implementations for the library. Adding new targets for a multiplatform library at the consumer's side is not supported.</source>
          <target state="translated">目标平台的集合是由多平台库作者定义的,他们应该为库提供所有特定平台的实现。不支持在消费者端为多平台库添加新目标。</target>
        </trans-unit>
        <trans-unit id="488655893b603c994560325ea4e7b1458229763b" translate="yes" xml:space="preserve">
          <source>The setter of this mutable property, used to change the value of the property.</source>
          <target state="translated">这个可变属性的设置者,用来改变属性的值。</target>
        </trans-unit>
        <trans-unit id="67fe2f456972c4ac12399f4f27262af0c978820f" translate="yes" xml:space="preserve">
          <source>The signature of &lt;code&gt;greet()&lt;/code&gt; is &lt;code&gt;KFunction2&amp;lt;Person, String, String&amp;gt;&lt;/code&gt; because it's a function on &lt;code&gt;Person&lt;/code&gt; that takes a &lt;code&gt;String&lt;/code&gt; and returns a &lt;code&gt;String&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;greet()&lt;/code&gt; 的签名为 &lt;code&gt;KFunction2&amp;lt;Person, String, String&amp;gt;&lt;/code&gt; 因为它是 &lt;code&gt;Person&lt;/code&gt; 上的一个函数，它接受 &lt;code&gt;String&lt;/code&gt; 并返回 &lt;code&gt;String&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3e351be319f91b0a3ca4911e8fb9da8a9528097a" translate="yes" xml:space="preserve">
          <source>The signature of a member function or an &lt;a href=&quot;extension-functionsproperties&quot;&gt;extension function&lt;/a&gt; begins with a &lt;em&gt;receiver&lt;/em&gt;: the type upon which the function can be invoked. For example, the signature of &lt;code&gt;toString()&lt;/code&gt; is &lt;code&gt;Any.() -&amp;gt; String&lt;/code&gt; - it can be called on any non-null object (the receiver), it takes no parameters, and it returns a &lt;code&gt;String&lt;/code&gt;. It is possible to write a lambda function with such a signature - this is called a &lt;em&gt;function literal with receiver&lt;/em&gt;, and is extremely useful for building DSLs.</source>
          <target state="translated">成员函数或&lt;a href=&quot;extension-functionsproperties&quot;&gt;扩展函数&lt;/a&gt;的签名从&lt;em&gt;接收方&lt;/em&gt;开始：可以在其上调用函数的类型。例如， &lt;code&gt;toString()&lt;/code&gt; 的签名为 &lt;code&gt;Any.() -&amp;gt; String&lt;/code&gt; 可以在任何非null对象（接收方）上调用它，不使用任何参数，并且返回 &lt;code&gt;String&lt;/code&gt; 。可以使用这样的签名编写一个lambda函数-这被称为&lt;em&gt;带有Receiver&lt;/em&gt;的&lt;em&gt;函数文字，&lt;/em&gt;对于构建DSL非常有用。</target>
        </trans-unit>
        <trans-unit id="aadf52185468aa82855f792813cb9471782e9fa0" translate="yes" xml:space="preserve">
          <source>The signature of the overriding function must exactly match the overridden one, except that the return type in the overriding function may be a subtype of the return type of the overridden function.</source>
          <target state="translated">覆盖函数的签名必须与被覆盖函数完全一致,但覆盖函数中的返回类型可以是被覆盖函数返回类型的子类型。</target>
        </trans-unit>
        <trans-unit id="cb5cfcfa1d9e07364a5b05687e8945f6f792b6b5" translate="yes" xml:space="preserve">
          <source>The simple name of the class as it was declared in the source code, or &lt;code&gt;null&lt;/code&gt; if the class has no name (if, for example, it is a class of an anonymous object).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0290c571ea3c6c1d4ef5f1279658ebad7901a082" translate="yes" xml:space="preserve">
          <source>The simple name of the class as it was declared in the source code, or &lt;code&gt;null&lt;/code&gt; if the class has no name (if, for example, it is an anonymous object literal).</source>
          <target state="translated">在源代码中声明的类的简单名称；如果该类没有名称（例如，如果它是一个匿名对象文字），则为 &lt;code&gt;null&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4a78d65e883965ba15ad1eec8e7ccc645ad6c9f8" translate="yes" xml:space="preserve">
          <source>The simplest version doesn't require any additional parameters and creates one binary for each build type. Currently there a two build types available: &lt;code&gt;DEBUG&lt;/code&gt; (produces a not optimized binary with a debug information) and &lt;code&gt;RELEASE&lt;/code&gt; (produces an optimized binary without debug information). Consequently the following snippet creates two executable binaries: debug and release.</source>
          <target state="translated">最简单的版本不需要任何其他参数，并为每种构建类型创建一个二进制文件。当前有两种构建类型可用： &lt;code&gt;DEBUG&lt;/code&gt; （产生带有调试信息的未优化的二进制文件）和 &lt;code&gt;RELEASE&lt;/code&gt; （产生没有调试信息的已优化的二进制文件）。因此，以下代码段创建了两个可执行二进制文件：debug和release。</target>
        </trans-unit>
        <trans-unit id="0e7b9b0dd8fa90a8e9f2b4ea99f92d60e815b8b9" translate="yes" xml:space="preserve">
          <source>The single immutable C value. It is self-contained and doesn't depend on native memory.</source>
          <target state="translated">单一不可改变的C值。它是自成一体的,不依赖于本机内存。</target>
        </trans-unit>
        <trans-unit id="d8e685c40e1d41520bbfb52a9a2cf6ce5cf4d2b1" translate="yes" xml:space="preserve">
          <source>The single-parent rule often becomes too limiting, as you'll often find commonalities between classes in different branches of a class hierarchy. These commonalities can be expressed in &lt;em&gt;interfaces&lt;/em&gt;.</source>
          <target state="translated">单亲规则通常变得过于局限，因为您经常会发现类层次结构不同分支中的类之间存在共性。这些共同点可以在&lt;em&gt;接口中&lt;/em&gt;表达。</target>
        </trans-unit>
        <trans-unit id="ad2d029e0bf9000bbb670b32b9cfbfdfb5c64ee2" translate="yes" xml:space="preserve">
          <source>The solution is a &lt;em&gt;delegated property&lt;/em&gt;, which allows you to specify the behavior of getting and setting a property (somewhat similar to implementing &lt;code&gt;__getattribute__()&lt;/code&gt; and &lt;code&gt;__setattribute__()&lt;/code&gt; in Python, but for one property at a time).</source>
          <target state="translated">该解决方案是一个&lt;em&gt;委托属性&lt;/em&gt;，它允许您指定获取和设置属性的行为（有点类似于在Python中实现 &lt;code&gt;__getattribute__()&lt;/code&gt; 和 &lt;code&gt;__setattribute__()&lt;/code&gt; ，但一次只设置一个属性）。</target>
        </trans-unit>
        <trans-unit id="02ba30e8a0350e3498389f6bdcc51b4d923322f5" translate="yes" xml:space="preserve">
          <source>The solution is to mark the targets with a custom attribute, which is taken into account by Gradle during dependency resolution. This, however, must be done on both the library author and the consumer sides, and it's the library author's responsibility to communicate the attribute and its possible values to the consumers.</source>
          <target state="translated">解决办法是用一个自定义属性来标记目标,Gradle在解决依赖关系的过程中会考虑到这个属性。然而,这必须在库作者和消费者两方面进行,库作者有责任将属性及其可能的值传达给消费者。</target>
        </trans-unit>
        <trans-unit id="4ce364ecc8aca93a0b9f937690067d3d1f6fcb4e" translate="yes" xml:space="preserve">
          <source>The sort is &lt;em&gt;stable&lt;/em&gt;. It means that equal elements preserve their order relative to each other after sorting.</source>
          <target state="translated">排序是&lt;em&gt;稳定的&lt;/em&gt;。这意味着相等的元素在排序后保留相对于彼此的顺序。</target>
        </trans-unit>
        <trans-unit id="563e0866ee26fde4dae779a523cc71b4cbb6977d" translate="yes" xml:space="preserve">
          <source>The source set names are case-sensitive. When referring to a default source set by its name, make sure the name prefix matches a target's name, for example, a source set &lt;code&gt;iosX64Main&lt;/code&gt; for a target &lt;code&gt;iosX64&lt;/code&gt;.</source>
          <target state="translated">源集名称区分大小写。当提到它的名字默认源设置，确保名称前缀与对象的名称，例如，源设置 &lt;code&gt;iosX64Main&lt;/code&gt; 为目标 &lt;code&gt;iosX64&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="11b3468dd6e9b05386099434c4ca46b0c2547522" translate="yes" xml:space="preserve">
          <source>The source sets DSL can be used to define these connections between the source sets:</source>
          <target state="translated">源集DSL可以用来定义这些源集之间的连接。</target>
        </trans-unit>
        <trans-unit id="5ee1552c884a6b1c888ad99542230488f493bca7" translate="yes" xml:space="preserve">
          <source>The source sets are configured within a &lt;code&gt;sourceSets { ... }&lt;/code&gt; block of the &lt;code&gt;kotlin { ... }&lt;/code&gt; extension:</source>
          <target state="translated">源集在 &lt;code&gt;kotlin { ... }&lt;/code&gt; 扩展的 &lt;code&gt;sourceSets { ... }&lt;/code&gt; 块内配置：</target>
        </trans-unit>
        <trans-unit id="d4cf592997fcfc68c560b9248ead3349afe2d7c1" translate="yes" xml:space="preserve">
          <source>The specification of the requirements to the delegated object can be found &lt;a href=&quot;delegated-properties#property-delegate-requirements&quot;&gt;below&lt;/a&gt;.</source>
          <target state="translated">可以在&lt;a href=&quot;delegated-properties#property-delegate-requirements&quot;&gt;下面&lt;/a&gt;找到对委托对象的要求的规范。</target>
        </trans-unit>
        <trans-unit id="d73e9a80f0bf586c373c77dd33cae5cc1f592da3" translate="yes" xml:space="preserve">
          <source>The specified arrays are also considered deeply equal if both are &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63949c8dfec16ede4c20d9d3cd58cdaf9f88fafe" translate="yes" xml:space="preserve">
          <source>The standard JavaDoc generation plugin (&lt;code&gt;maven-javadoc-plugin&lt;/code&gt;) does not support Kotlin code. To generate documentation for Kotlin projects, use &lt;a href=&quot;https://github.com/Kotlin/dokka&quot;&gt;Dokka&lt;/a&gt;; please refer to the &lt;a href=&quot;https://github.com/Kotlin/dokka/blob/master/README.md#using-the-maven-plugin&quot;&gt;Dokka README&lt;/a&gt; for configuration instructions. Dokka supports mixed-language projects and can generate output in multiple formats, including standard JavaDoc.</source>
          <target state="translated">标准的JavaDoc生成插件（ &lt;code&gt;maven-javadoc-plugin&lt;/code&gt; ）不支持Kotlin代码。要生成Kotlin项目的文档，请使用&lt;a href=&quot;https://github.com/Kotlin/dokka&quot;&gt;Dokka&lt;/a&gt;；请参阅&lt;a href=&quot;https://github.com/Kotlin/dokka/blob/master/README.md#using-the-maven-plugin&quot;&gt;Dokka自述文件&lt;/a&gt;以获取配置说明。Dokka支持混合语言项目，并且可以生成多种格式的输出，包括标准JavaDoc。</target>
        </trans-unit>
        <trans-unit id="bb8d32cf58d6a52257e9ed55a0d5c90647cf240f" translate="yes" xml:space="preserve">
          <source>The standard library contains a group of extension functions that let you filter collections in a single call. These functions leave the original collection unchanged, so they are available for both &lt;a href=&quot;collections-overview#collection-types&quot;&gt;mutable and read-only&lt;/a&gt; collections. To operate the filtering result, you should assign it to a variable or chain the functions after filtering.</source>
          <target state="translated">标准库包含一组扩展功能，使您可以在单个调用中过滤集合。这些函数使原始集合保持不变，因此它们可用于&lt;a href=&quot;collections-overview#collection-types&quot;&gt;可变&lt;/a&gt;集合和只读集合。要操作过滤结果，应将其分配给变量或在过滤后链接函数。</target>
        </trans-unit>
        <trans-unit id="64cd7cca211b28854215461360962734eb107f4c" translate="yes" xml:space="preserve">
          <source>The standard library defines a function named &lt;a href=&quot;../../../api/latest/jvm/stdlib/kotlin.js/as-dynamic&quot;&gt;&lt;code&gt;asDynamic()&lt;/code&gt;&lt;/a&gt; which casts a value to the dynamic type. Given our previous example where we used jQuery to work with DOM elements, we can now combine this with &lt;code&gt;asDynamic()&lt;/code&gt; to then invoke &lt;code&gt;dataTable()&lt;/code&gt; on the result:</source>
          <target state="translated">标准库定义了一个名为&lt;a href=&quot;../../../api/latest/jvm/stdlib/kotlin.js/as-dynamic&quot;&gt; &lt;code&gt;asDynamic()&lt;/code&gt; &lt;/a&gt;的函数，该函数将值转换为动态类型。在前面的示例中，我们使用jQuery处理DOM元素，现在我们可以将其与 &lt;code&gt;asDynamic()&lt;/code&gt; 结合起来，然后在结果上调用 &lt;code&gt;dataTable()&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="2f92a5708c1e21664731222bd701621446c56d87" translate="yes" xml:space="preserve">
          <source>The standard library now provides a set of functions for element-by-element operations on arrays: comparison (&lt;code&gt;contentEquals&lt;/code&gt; and &lt;code&gt;contentDeepEquals&lt;/code&gt;), hash code calculation (&lt;code&gt;contentHashCode&lt;/code&gt; and &lt;code&gt;contentDeepHashCode&lt;/code&gt;), and conversion to a string (&lt;code&gt;contentToString&lt;/code&gt; and &lt;code&gt;contentDeepToString&lt;/code&gt;). They're supported both for the JVM (where they act as aliases for the corresponding functions in &lt;code&gt;java.util.Arrays&lt;/code&gt;) and for JS (where the implementation is provided in the Kotlin standard library).</source>
          <target state="translated">现在，标准库为数组的逐个元素操作提供了一组函数：比较（ &lt;code&gt;contentEquals&lt;/code&gt; 和 &lt;code&gt;contentDeepEquals&lt;/code&gt; ），哈希码计算（ &lt;code&gt;contentHashCode&lt;/code&gt; 和 &lt;code&gt;contentDeepHashCode&lt;/code&gt; ）以及转换为字符串（ &lt;code&gt;contentToString&lt;/code&gt; 和 &lt;code&gt;contentDeepToString&lt;/code&gt; ）。他们的JVM（他们作为别名在相应的功能均支持 &lt;code&gt;java.util.Arrays&lt;/code&gt; 中）和JS（其中在科特林标准库提供的实现）。</target>
        </trans-unit>
        <trans-unit id="4cd1337efd07a01ae50fb56677c92729c05a2ca9" translate="yes" xml:space="preserve">
          <source>The standard library provides &lt;code&gt;Pair&lt;/code&gt; and &lt;code&gt;Triple&lt;/code&gt;. In most cases, though, named data classes are a better design choice, because they make the code more readable by providing meaningful names for properties.</source>
          <target state="translated">标准库提供 &lt;code&gt;Pair&lt;/code&gt; 和 &lt;code&gt;Triple&lt;/code&gt; 。但是，在大多数情况下，命名数据类是更好的设计选择，因为命名属性为属性提供有意义的名称，使代码更易读。</target>
        </trans-unit>
        <trans-unit id="0fa7bf33e28a4e2133f3eb85b822f13a5861e747" translate="yes" xml:space="preserve">
          <source>The standard library provides us with a series of wrappers around DOM as well as functions to work with JavaScript, using static typing. What happens however when we want to use a library such as jQuery? Kotlin does not have its own &quot;header&quot; files for all the different libraries available on the JavaScript ecosystem however, TypeScript does. The &lt;a href=&quot;https://github.com/DefinitelyTyped/DefinitelyTyped/&quot;&gt;Definitely Typed repository&lt;/a&gt; provides us with a very large selection of header files.</source>
          <target state="translated">标准库为我们提供了一系列有关DOM的包装器以及使用静态类型与JavaScript配合使用的函数。但是，当我们想使用jQuery之类的库时会发生什么？对于JavaScript生态系统上可用的所有不同库，Kotlin没有自己的&amp;ldquo;标头&amp;rdquo;文件，但是TypeScript有。在&lt;a href=&quot;https://github.com/DefinitelyTyped/DefinitelyTyped/&quot;&gt;肯定类型化资料库&lt;/a&gt;为我们提供了一个非常大的选择的头文件。</target>
        </trans-unit>
        <trans-unit id="5b02aa301d08018505c67b11eafce33e20430963" translate="yes" xml:space="preserve">
          <source>The standard library uses coroutines to support &lt;em&gt;lazily generated sequences&lt;/em&gt; with &lt;code&gt;yield&lt;/code&gt; and &lt;code&gt;yieldAll&lt;/code&gt; functions. In such a sequence, the block of code that returns sequence elements is suspended after each element has been retrieved, and resumed when the next element is requested. Here's an example:</source>
          <target state="translated">标准库使用协程支持具有 &lt;code&gt;yield&lt;/code&gt; 和 &lt;code&gt;yieldAll&lt;/code&gt; 函数的&lt;em&gt;延迟生成的序列&lt;/em&gt;。在这样的序列中，返回序列元素的代码块在检索到每个元素之后将被挂起，并在请求下一个元素时恢复。这是一个例子：</target>
        </trans-unit>
        <trans-unit id="bd81d65292e2ed27e6a7bd7b3f70e04e3c6f5969" translate="yes" xml:space="preserve">
          <source>The status value in &lt;code&gt;@UnderMigration(status = ...)&lt;/code&gt; specifies how the compiler treats inappropriate usages of the annotated types in Kotlin (e.g. using a &lt;code&gt;@MyNullable&lt;/code&gt;-annotated type value as non-null):</source>
          <target state="translated">&lt;code&gt;@UnderMigration(status = ...)&lt;/code&gt; 的状态值指定编译器如何对待Kotlin中带注释类型的不当用法（例如，使用 &lt;code&gt;@MyNullable&lt;/code&gt; -带注释类型的值作为非null）：</target>
        </trans-unit>
        <trans-unit id="4dfa4a2af58e962d2e78195bb041069a8bfddba3" translate="yes" xml:space="preserve">
          <source>The step of the progression.</source>
          <target state="translated">进阶的步骤。</target>
        </trans-unit>
        <trans-unit id="e2561323722fd466eed7e84734bba0e2d9a0a20e" translate="yes" xml:space="preserve">
          <source>The step value must be positive. If you need to count downwards, use the inclusive &lt;code&gt;downTo&lt;/code&gt;:</source>
          <target state="translated">步长值必须为正。如果需要向下计数，请使用包含在内的 &lt;code&gt;downTo&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="ba5dcc36cf4e926283f2cf38c8b5b4a8a22b74ac" translate="yes" xml:space="preserve">
          <source>The subclass &lt;em&gt;inherits&lt;/em&gt; all members that exist in its superclass - both those that are directly defined in the superclass and the ones that the superclass itself has inherited. In this example, &lt;code&gt;Car&lt;/code&gt; contains the following members:</source>
          <target state="translated">子类&lt;em&gt;继承&lt;/em&gt;其超类中存在的所有成员-既直接在超类中定义的成员，也包括超类本身已继承的成员。在此示例中， &lt;code&gt;Car&lt;/code&gt; 包含以下成员：</target>
        </trans-unit>
        <trans-unit id="9587208b56b71c873bb976ba7dd19e63565c1783" translate="yes" xml:space="preserve">
          <source>The substring from the input string captured by this match.</source>
          <target state="translated">本次匹配所捕获的输入字符串的子串。</target>
        </trans-unit>
        <trans-unit id="ef9d4de4ce3f425feef1d92bfbe702742ff76fe2" translate="yes" xml:space="preserve">
          <source>The syntax is: &lt;code&gt;val/var &amp;lt;property name&amp;gt;: &amp;lt;Type&amp;gt; by &amp;lt;expression&amp;gt;&lt;/code&gt;. The expression after &lt;em&gt;by&lt;/em&gt; is the &lt;em&gt;delegate&lt;/em&gt;, because &lt;code&gt;get()&lt;/code&gt; (and &lt;code&gt;set()&lt;/code&gt;) corresponding to the property will be delegated to its &lt;code&gt;getValue()&lt;/code&gt; and &lt;code&gt;setValue()&lt;/code&gt; methods. Property delegates don&amp;rsquo;t have to implement any interface, but they have to provide a &lt;code&gt;getValue()&lt;/code&gt; function (and &lt;code&gt;setValue()&lt;/code&gt; &amp;mdash; for &lt;em&gt;var&lt;/em&gt;s). For example:</source>
          <target state="translated">语法为： &lt;code&gt;val/var &amp;lt;property name&amp;gt;: &amp;lt;Type&amp;gt; by &amp;lt;expression&amp;gt;&lt;/code&gt; 。&lt;em&gt;by&lt;/em&gt;之后的表达式是&lt;em&gt;委托&lt;/em&gt;，因为与该属性对应的 &lt;code&gt;get()&lt;/code&gt; （和 &lt;code&gt;set()&lt;/code&gt; ）将委托给其 &lt;code&gt;getValue()&lt;/code&gt; 和 &lt;code&gt;setValue()&lt;/code&gt; 方法。属性委托不必实现任何接口，但是必须提供 &lt;code&gt;getValue()&lt;/code&gt; 函数（和 &lt;code&gt;setValue()&lt;/code&gt; －用于&lt;em&gt;var&lt;/em&gt;）。例如：</target>
        </trans-unit>
        <trans-unit id="7f8b0e5f27ed7447035e9e8912fa4868135e5b36" translate="yes" xml:space="preserve">
          <source>The table below shows how Kotlin concepts are mapped to Swift/Objective-C and vice versa.</source>
          <target state="translated">下表显示了Kotlin概念如何映射到Swift/Objective-C,反之亦然。</target>
        </trans-unit>
        <trans-unit id="27aee67b81ecee081c926fb6403fc250a2669b58" translate="yes" xml:space="preserve">
          <source>The targets created from presets are added to the &lt;code&gt;kotlin.targets&lt;/code&gt; domain object collection, which can be used to access them by their names or configure all targets:</source>
          <target state="translated">从预设创建的目标将添加到 &lt;code&gt;kotlin.targets&lt;/code&gt; 域对象集合中，可用于按其名称访问它们或配置所有目标：</target>
        </trans-unit>
        <trans-unit id="ea834ff7223c20a4c037e26a9eaa3ee2e490ee75" translate="yes" xml:space="preserve">
          <source>The terminology is that &lt;code&gt;var&lt;/code&gt; declares a &lt;em&gt;mutable&lt;/em&gt; variable, and that &lt;code&gt;val&lt;/code&gt; declares a &lt;em&gt;read-only&lt;/em&gt; or &lt;em&gt;assign-once&lt;/em&gt; variable - so both kinds are called &lt;em&gt;variables&lt;/em&gt;.</source>
          <target state="translated">术语是 &lt;code&gt;var&lt;/code&gt; 声明了一个&lt;em&gt;可变&lt;/em&gt;变量，而 &lt;code&gt;val&lt;/code&gt; 声明了一个&lt;em&gt;只读&lt;/em&gt;或&lt;em&gt;一次分配&lt;/em&gt;变量-因此这两种都称为&lt;em&gt;变量&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="d2c1a93ffe9401881d7e0f5a7066475d9434f33d" translate="yes" xml:space="preserve">
          <source>The the &lt;a href=&quot;https://github.com/ilmat192/kotlin-native-serialization-sample&quot;&gt;example project&lt;/a&gt; for details.</source>
          <target state="translated">该&lt;a href=&quot;https://github.com/ilmat192/kotlin-native-serialization-sample&quot;&gt;示例项目&lt;/a&gt;中有详细信息。</target>
        </trans-unit>
        <trans-unit id="db0d4a97f9fddd6cc7f4a4e559ab92c9b243b3dc" translate="yes" xml:space="preserve">
          <source>The third option is for NPE-lovers: the not-null assertion operator (&lt;code&gt;!!&lt;/code&gt;) converts any value to a non-null type and throws an exception if the value is null. We can write &lt;code&gt;b!!&lt;/code&gt;, and this will return a non-null value of &lt;code&gt;b&lt;/code&gt; (e.g., a &lt;code&gt;String&lt;/code&gt; in our example) or throw an NPE if &lt;code&gt;b&lt;/code&gt; is null:</source>
          <target state="translated">第三个选项适用于NPE爱好者：非空断言运算符（ &lt;code&gt;!!&lt;/code&gt; ）将任何值转换为非空类型，如果该值为空，则引发异常。我们可以写 &lt;code&gt;b!!&lt;/code&gt; ，这将返回 &lt;code&gt;b&lt;/code&gt; 的非空值（例如，在我们的示例中为 &lt;code&gt;String&lt;/code&gt; ），或者如果 &lt;code&gt;b&lt;/code&gt; 为null 则抛出NPE ：</target>
        </trans-unit>
        <trans-unit id="328eee564065ef14869693e4097fdfb0bb1e1ca4" translate="yes" xml:space="preserve">
          <source>The three targets are created with the preset functions &lt;code&gt;jvm()&lt;/code&gt;, &lt;code&gt;js()&lt;/code&gt;, and &lt;code&gt;mingwX64()&lt;/code&gt; that provide some &lt;a href=&quot;#default-project-layout&quot;&gt;default configuration&lt;/a&gt;. There are presets for each of the &lt;a href=&quot;#supported-platforms&quot;&gt;supported platforms&lt;/a&gt;.</source>
          <target state="translated">这三个目标是使用提供一些&lt;a href=&quot;#default-project-layout&quot;&gt;默认配置&lt;/a&gt;的预设函数 &lt;code&gt;jvm()&lt;/code&gt; ， &lt;code&gt;js()&lt;/code&gt; 和 &lt;code&gt;mingwX64()&lt;/code&gt; 创建的。每个&lt;a href=&quot;#supported-platforms&quot;&gt;受支持的平台&lt;/a&gt;都有预设。</target>
        </trans-unit>
        <trans-unit id="865a447cbe3c80dc40999ce2ca6d480bd87143d3" translate="yes" xml:space="preserve">
          <source>The timeout event in &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/with-timeout.html&quot;&gt;withTimeout&lt;/a&gt; is asynchronous with respect to the code running in its block and may happen at any time, even right before the return from inside of the timeout block. Keep this in mind if you open or acquire some resource inside the block that needs closing or release outside of the block.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04def297d18523cf309971345c57324bf9993c18" translate="yes" xml:space="preserve">
          <source>The title case of a character is usually the same as its upper case with several exceptions. The particular list of characters with the special title case form depends on the underlying platform.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3871e9aa2f804023caa55782736ddd2a4dee3be1" translate="yes" xml:space="preserve">
          <source>The two characters are the same (as compared by the == operator)</source>
          <target state="translated">这两个字符是一样的(通过==操作符进行比较)</target>
        </trans-unit>
        <trans-unit id="43727256131e4c09e21487921129d951e5403bce" translate="yes" xml:space="preserve">
          <source>The type &lt;a href=&quot;exceptions#the-nothing-type&quot;&gt;&lt;code&gt;Nothing&lt;/code&gt;&lt;/a&gt; is special, because it has no natural counterpart in Java. Indeed, every Java reference type, including &lt;code&gt;java.lang.Void&lt;/code&gt;, accepts &lt;code&gt;null&lt;/code&gt; as a value, and &lt;code&gt;Nothing&lt;/code&gt; doesn't accept even that. So, this type cannot be accurately represented in the Java world. This is why Kotlin generates a raw type where an argument of type &lt;code&gt;Nothing&lt;/code&gt; is used:</source>
          <target state="translated">&lt;a href=&quot;exceptions#the-nothing-type&quot;&gt; &lt;code&gt;Nothing&lt;/code&gt; &lt;/a&gt;类型是特殊的，因为它在Java中没有自然的对应物。实际上，每个Java引用类型（包括 &lt;code&gt;java.lang.Void&lt;/code&gt; ）都接受 &lt;code&gt;null&lt;/code&gt; 作为值，而 &lt;code&gt;Nothing&lt;/code&gt; 甚至不接受。因此，无法在Java世界中准确地表示这种类型。这就是为什么Kotlin生成使用 &lt;code&gt;Nothing&lt;/code&gt; 类型的参数的原始类型的原因：</target>
        </trans-unit>
        <trans-unit id="5840d7b86dbf1ab10e5032023a9859ef434e1278" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;Boolean&lt;/code&gt; represents booleans, and has two values: &lt;em&gt;true&lt;/em&gt; and &lt;em&gt;false&lt;/em&gt;.</source>
          <target state="translated">&lt;code&gt;Boolean&lt;/code&gt; 类型表示布尔值，并具有两个值：&lt;em&gt;true&lt;/em&gt;和&lt;em&gt;false&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="fdef02e2cbe116b674c3a5cab83d13e4789bcc49" translate="yes" xml:space="preserve">
          <source>The type argument &lt;code&gt;T&lt;/code&gt; of &lt;code&gt;CPointer&amp;lt;T&amp;gt;&lt;/code&gt; must be one of the &quot;lvalue&quot; types described above, e.g., the C type &lt;code&gt;struct S*&lt;/code&gt; is mapped to &lt;code&gt;CPointer&amp;lt;S&amp;gt;&lt;/code&gt;, &lt;code&gt;int8_t*&lt;/code&gt; is mapped to &lt;code&gt;CPointer&amp;lt;int_8tVar&amp;gt;&lt;/code&gt;, and &lt;code&gt;char**&lt;/code&gt; is mapped to &lt;code&gt;CPointer&amp;lt;CPointerVar&amp;lt;ByteVar&amp;gt;&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">类型参数 &lt;code&gt;T&lt;/code&gt; 的 &lt;code&gt;CPointer&amp;lt;T&amp;gt;&lt;/code&gt; 必须是上述的&amp;ldquo;左值&amp;rdquo;类型中的一种，例如，将C型 &lt;code&gt;struct S*&lt;/code&gt; 被映射到 &lt;code&gt;CPointer&amp;lt;S&amp;gt;&lt;/code&gt; ， &lt;code&gt;int8_t*&lt;/code&gt; 被映射到 &lt;code&gt;CPointer&amp;lt;int_8tVar&amp;gt;&lt;/code&gt; ，和 &lt;code&gt;char**&lt;/code&gt; 映射到 &lt;code&gt;CPointer&amp;lt;CPointerVar&amp;lt;ByteVar&amp;gt;&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="304e12f8621867e9197c2891cfb5db65d05e542f" translate="yes" xml:space="preserve">
          <source>The type arguments of generic function calls are also only checked at compile time. Inside the function bodies, the type parameters cannot be used for type checks, and type casts to type parameters (&lt;code&gt;foo as T&lt;/code&gt;) are unchecked. However, &lt;a href=&quot;inline-functions#reified-type-parameters&quot;&gt;reified type parameters&lt;/a&gt; of inline functions are substituted by the actual type arguments in the inlined function body at the call sites and thus can be used for type checks and casts, with the same restrictions for instances of generic types as described above.</source>
          <target state="translated">泛型函数调用的类型参数也仅在编译时检查。在函数体内，类型参数不能用于类型检查，并且对类型参数（ &lt;code&gt;foo as T&lt;/code&gt; ）的类型强制转换是未选中的。然而，&lt;a href=&quot;inline-functions#reified-type-parameters&quot;&gt;具体化类型参数&lt;/a&gt;的内联函数是由实际类型参数中在调用点内联函数体取代并且因此可用于类型检查和石膏，与如上所述的一般的类型的实例相同的限制。</target>
        </trans-unit>
        <trans-unit id="6d035411fbfdc1232561efb8b45fef51b9b3f1fe" translate="yes" xml:space="preserve">
          <source>The type of &lt;code&gt;safeDivide&lt;/code&gt; is &lt;code&gt;(Int, Int) -&amp;gt; Double&lt;/code&gt;. Note that unlike function type declarations, the parameter list of a lambda expression must not be enclosed in parentheses.</source>
          <target state="translated">&lt;code&gt;safeDivide&lt;/code&gt; 的类型是 &lt;code&gt;(Int, Int) -&amp;gt; Double&lt;/code&gt; 。请注意，与函数类型声明不同，lambda表达式的参数列表不得包含在括号中。</target>
        </trans-unit>
        <trans-unit id="c50d2b6bc67063abeddc4b2628733da7784a58f0" translate="yes" xml:space="preserve">
          <source>The type of a property, and the types that are used for the parameters and the return type of a function, must be &quot;at least as visible&quot; as the property/function itself. For example, a public function can't take a private type as a parameter.</source>
          <target state="translated">属性的类型,以及用于参数和函数返回类型的类型,必须与属性/函数本身 &quot;至少一样可见&quot;。例如,一个公共函数不能使用私有类型作为参数。</target>
        </trans-unit>
        <trans-unit id="8de1071b6667ea170a2315b344096736147854e4" translate="yes" xml:space="preserve">
          <source>The type of the &lt;code&gt;throw&lt;/code&gt; expression is the special type &lt;code&gt;Nothing&lt;/code&gt;. The type has no values and is used to mark code locations that can never be reached. In your own code, you can use &lt;code&gt;Nothing&lt;/code&gt; to mark a function that never returns:</source>
          <target state="translated">该类型的 &lt;code&gt;throw&lt;/code&gt; 表现是特殊类型 &lt;code&gt;Nothing&lt;/code&gt; 。该类型没有值，用于标记永远无法到达的代码位置。在您自己的代码中，可以使用 &lt;code&gt;Nothing&lt;/code&gt; 标记永不返回的函数：</target>
        </trans-unit>
        <trans-unit id="23c18621bf7101376cb4104c69faad184a7d75d0" translate="yes" xml:space="preserve">
          <source>The type of these expressions is the &lt;a href=&quot;exceptions#the-nothing-type&quot;&gt;Nothing type&lt;/a&gt;.</source>
          <target state="translated">这些表达式的&lt;a href=&quot;exceptions#the-nothing-type&quot;&gt;类型&lt;/a&gt;是Nothing类型。</target>
        </trans-unit>
        <trans-unit id="28dfc8e3403b9f6de19da78b037825e3337aa674" translate="yes" xml:space="preserve">
          <source>The type of values returned by this callable.</source>
          <target state="translated">该callable返回的值的类型。</target>
        </trans-unit>
        <trans-unit id="724404b217f8e33affca4710ff6d760dfbd8b8e9" translate="yes" xml:space="preserve">
          <source>The type safety checks that Kotlin performs for generic declaration usages are only done at compile time. At runtime, the instances of generic types do not hold any information about their actual type arguments. The type information is said to be &lt;em&gt;erased&lt;/em&gt;. For example, the instances of &lt;code&gt;Foo&amp;lt;Bar&amp;gt;&lt;/code&gt; and &lt;code&gt;Foo&amp;lt;Baz?&amp;gt;&lt;/code&gt; are erased to just &lt;code&gt;Foo&amp;lt;*&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Kotlin针对泛型声明用法执行的类型安全检查仅在编译时进行。在运行时，泛型类型的实例不保存有关其实际类型参数的任何信息。据说类型信息已被&lt;em&gt;擦除&lt;/em&gt;。例如， &lt;code&gt;Foo&amp;lt;Bar&amp;gt;&lt;/code&gt; 和 &lt;code&gt;Foo&amp;lt;Baz?&amp;gt;&lt;/code&gt; 实例被擦除为 &lt;code&gt;Foo&amp;lt;*&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bd9368e467f6513ce687f28529e6a3ccfb31bd57" translate="yes" xml:space="preserve">
          <source>The type specified after a colon is the &lt;strong&gt;upper bound&lt;/strong&gt;: only a subtype of &lt;code&gt;Comparable&amp;lt;T&amp;gt;&lt;/code&gt; may be substituted for &lt;code&gt;T&lt;/code&gt;. For example:</source>
          <target state="translated">冒号之后指定的类型是&lt;strong&gt;上界&lt;/strong&gt;：只有一个亚型 &lt;code&gt;Comparable&amp;lt;T&amp;gt;&lt;/code&gt; 可以取代 &lt;code&gt;T&lt;/code&gt; 。例如：</target>
        </trans-unit>
        <trans-unit id="195a81820ffdceacb4b4779278f03f44e25e239e" translate="yes" xml:space="preserve">
          <source>The type specified in the projection, or &lt;code&gt;null&lt;/code&gt; if this is a star projection.</source>
          <target state="translated">投影中指定的类型；如果是星型投影，则为 &lt;code&gt;null&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e184ade95bbad48da746688d8668a604f12d3467" translate="yes" xml:space="preserve">
          <source>The type with only one value: the &lt;code&gt;Unit&lt;/code&gt; object.</source>
          <target state="translated">只有一个值的类型： &lt;code&gt;Unit&lt;/code&gt; 对象。</target>
        </trans-unit>
        <trans-unit id="19328e2c828d83e68c896264bdfa85a39aa786f7" translate="yes" xml:space="preserve">
          <source>The type with only one value: the &lt;code&gt;Unit&lt;/code&gt; object. This type corresponds to the &lt;code&gt;void&lt;/code&gt; type in Java.</source>
          <target state="translated">只有一个值的类型： &lt;code&gt;Unit&lt;/code&gt; 对象。此类型对应于Java中的 &lt;code&gt;void&lt;/code&gt; 类型。</target>
        </trans-unit>
        <trans-unit id="7008246671a61ed2da63a9b1d753eac75888ec6a" translate="yes" xml:space="preserve">
          <source>The types inside the angle brackets are called &lt;em&gt;generic type parameters&lt;/em&gt;, which we will cover later. In short, it's a useful technique to make a class that is tied to another class (such as a container class, which is tied to its element class) applicable to many different classes.</source>
          <target state="translated">尖括号内的类型称为&lt;em&gt;通用类型参数&lt;/em&gt;，我们将在后面介绍。简而言之，使绑定到另一个类的类（例如，容器类，绑定到其元素类的类）适用于许多不同的类是一种有用的技术。</target>
        </trans-unit>
        <trans-unit id="608adb2d4b11107c32aaf63109063a2afc4cba2c" translate="yes" xml:space="preserve">
          <source>The unconfined dispatcher is an advanced mechanism that can be helpful in certain corner cases where dispatching of a coroutine for its execution later is not needed or produces undesirable side-effects, because some operation in a coroutine must be performed right away. The unconfined dispatcher should not be used in general code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b16b6543fccfa319ed1bb173131c9217c5b8ccc" translate="yes" xml:space="preserve">
          <source>The usage from C is straightforward and uncomplicated. We create a &lt;code&gt;main.c&lt;/code&gt; file with the following code:</source>
          <target state="translated">C语言中的用法非常简单明了。我们使用以下代码创建一个 &lt;code&gt;main.c&lt;/code&gt; 文件：</target>
        </trans-unit>
        <trans-unit id="eda63df3b0cc777042c5e16e6a7e9e820a7f02bd" translate="yes" xml:space="preserve">
          <source>The usage is pretty similar to all-open.</source>
          <target state="translated">用法和全开很相似。</target>
        </trans-unit>
        <trans-unit id="d4460c6a02beaa088565d93296bf84c132fa91dd" translate="yes" xml:space="preserve">
          <source>The usage is the same to all-open and no-arg, except the fact that sam-with-receiver does not have any built-in presets, and you need to specify your own list of special-treated annotations.</source>
          <target state="translated">除了sam-with-receiver没有任何内置的预设之外,用法和all-open和no-arg是一样的,你需要自己指定特殊处理的注释列表。</target>
        </trans-unit>
        <trans-unit id="79d6496f32a4f62877c61deb0bd17640fe23059a" translate="yes" xml:space="preserve">
          <source>The use cases of different functions overlap, so that you can choose the functions based on the specific conventions used in your project or team.</source>
          <target state="translated">不同功能的用例有重叠,可以根据项目或团队的具体约定来选择功能。</target>
        </trans-unit>
        <trans-unit id="882548c8ded53fae119e86e0601fc1f2361824a2" translate="yes" xml:space="preserve">
          <source>The use-site variance specified in the projection, or &lt;code&gt;null&lt;/code&gt; if this is a star projection.</source>
          <target state="translated">投影中指定的使用地点差异；如果是星形投影，则为 &lt;code&gt;null&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f6253f8d51fcab2be72d37974c28482731bda531" translate="yes" xml:space="preserve">
          <source>The value being held by this class.</source>
          <target state="translated">该类所持有的价值。</target>
        </trans-unit>
        <trans-unit id="3c6df952c69c83c655c026cd3cab96c052641127" translate="yes" xml:space="preserve">
          <source>The value must be positive and &lt;a href=&quot;../../kotlin/-int/-m-a-x_-v-a-l-u-e#kotlin.Int.Companion%24MAX_VALUE&quot;&gt;Int.MAX_VALUE&lt;/a&gt; is used to specify an unlimited depth.</source>
          <target state="translated">该值必须为正，并且&lt;a href=&quot;../../kotlin/-int/-m-a-x_-v-a-l-u-e#kotlin.Int.Companion%24MAX_VALUE&quot;&gt;Int.MAX_VALUE&lt;/a&gt;用于指定无限深度。</target>
        </trans-unit>
        <trans-unit id="239f4ace7ed276249b435b6f6174eb7de8fef7a5" translate="yes" xml:space="preserve">
          <source>The value of captured group.</source>
          <target state="translated">捕获组的价值。</target>
        </trans-unit>
        <trans-unit id="af704602dd7474776e5b688f4b067018b5e41c89" translate="yes" xml:space="preserve">
          <source>The value of this variable.</source>
          <target state="translated">此变量的值。</target>
        </trans-unit>
        <trans-unit id="3aabcc212c1608210121013dee11f396d22f4fca" translate="yes" xml:space="preserve">
          <source>The variable containing a &lt;a href=&quot;-c-opaque-pointer&quot;&gt;COpaquePointer&lt;/a&gt;.</source>
          <target state="translated">包含&lt;a href=&quot;-c-opaque-pointer&quot;&gt;COpaquePointer&lt;/a&gt;的变量。</target>
        </trans-unit>
        <trans-unit id="e9b853cf2301d69ed0ca13dfc9180094e7f3e288" translate="yes" xml:space="preserve">
          <source>The version of the bytecode interface (naming conventions, signatures) of the class file annotated with this annotation.</source>
          <target state="translated">用该注解注释的类文件的字节码接口版本(命名惯例、签名)。</target>
        </trans-unit>
        <trans-unit id="1abfb175c8f11a4b2665f4fbd6b2ed384b7a75ef" translate="yes" xml:space="preserve">
          <source>The version of the metadata provided in the arguments of this annotation.</source>
          <target state="translated">本注解的参数中提供的元数据的版本。</target>
        </trans-unit>
        <trans-unit id="b210bbe6f64c596cb275d652b699dc315a1fc8bc" translate="yes" xml:space="preserve">
          <source>The very first part contains the standard C/C++ header and footer:</source>
          <target state="translated">第一部分包含标准的C/C++头和脚。</target>
        </trans-unit>
        <trans-unit id="13204b21b51f8144497368ed89b8d47c465b75a3" translate="yes" xml:space="preserve">
          <source>The visibility level only affects the &lt;em&gt;lexical visibility&lt;/em&gt; of the &lt;em&gt;symbol&lt;/em&gt; - i.e., where the compiler allows you to type out the symbol. It does not affect where &lt;em&gt;instances&lt;/em&gt; are used: for example, a public top-level function may well return an instance of a private class, as long as the return type doesn't mention the private class name but is instead a public base class of the private class (possibly &lt;code&gt;Any&lt;/code&gt;) or a public interface that the private class implements. When you &lt;a href=&quot;inheritance#subclassing&quot;&gt;subclass&lt;/a&gt; a class, its private members are also inherited by the subclass, but are not directly accessible there - however, if you call an inherited public function that happens to access a private member, that's fine.</source>
          <target state="translated">可见性级别仅影响&lt;em&gt;符号&lt;/em&gt;的&lt;em&gt;词法可见性&lt;/em&gt;，即，编译器允许您键入符号。它不会影响使用&lt;em&gt;实例的&lt;/em&gt;位置：例如，一个公共顶级函数很可能会返回一个私有类的实例，只要返回类型没有提及私有类的名称，而是一个私有的基类即可。私有类（可能是 &lt;code&gt;Any&lt;/code&gt; ）或私有类实现的公共接口。当您对一个类进行&lt;a href=&quot;inheritance#subclassing&quot;&gt;子&lt;/a&gt;类化时，子类也继承了它的私有成员，但是在那里不能直接访问它-但是，如果您调用碰巧访问私有成员的继承的公共函数，那很好。&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="be08405fa49b795ce8dcbbade59f22553916f972" translate="yes" xml:space="preserve">
          <source>The way in which we'd use this from JavaScript would be to call &lt;code&gt;dataTable()&lt;/code&gt; on the corresponding &lt;code&gt;&amp;lt;table&amp;gt;&lt;/code&gt; element</source>
          <target state="translated">我们将通过JavaScript使用此方法的方式是在相应的 &lt;code&gt;&amp;lt;table&amp;gt;&lt;/code&gt; 元素上调用 &lt;code&gt;dataTable()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="df6c92cd4ac7021995eb7f605c7d7406310257be" translate="yes" xml:space="preserve">
          <source>The way to refer to the context object</source>
          <target state="translated">引用上下文对象的方式</target>
        </trans-unit>
        <trans-unit id="db21ceeaa7842bb619c97af30e1e09b94faa6e61" translate="yes" xml:space="preserve">
          <source>The web site has a bunch of &lt;a href=&quot;https://kotlinlang.org/community/&quot;&gt;online resources&lt;/a&gt;, including &lt;a href=&quot;https://kotlin.link&quot;&gt;Kotlin Digests&lt;/a&gt; by community members, a &lt;a href=&quot;http://www.kotlinweekly.net&quot;&gt;newsletter&lt;/a&gt;, a &lt;a href=&quot;https://talkingkotlin.com&quot;&gt;podcast&lt;/a&gt; and more.</source>
          <target state="translated">该网站拥有大量&lt;a href=&quot;https://kotlinlang.org/community/&quot;&gt;在线资源&lt;/a&gt;，包括社区成员的&lt;a href=&quot;https://kotlin.link&quot;&gt;Kotlin Digests&lt;/a&gt;，&lt;a href=&quot;http://www.kotlinweekly.net&quot;&gt;新闻通讯&lt;/a&gt;，&lt;a href=&quot;https://talkingkotlin.com&quot;&gt;播客&lt;/a&gt;等等。</target>
        </trans-unit>
        <trans-unit id="ffaad4042bec05249e2007ea2e2a7c01e5b1b264" translate="yes" xml:space="preserve">
          <source>Then add the respective dependencies using the &lt;code&gt;kapt&lt;/code&gt; configuration in your &lt;code&gt;dependencies&lt;/code&gt; block:</source>
          <target state="translated">然后在您的 &lt;code&gt;dependencies&lt;/code&gt; 块中使用 &lt;code&gt;kapt&lt;/code&gt; 配置添加相应的依赖关系：</target>
        </trans-unit>
        <trans-unit id="3d3dd4715a6e839facb3a4bc6c2872f8802ec4b8" translate="yes" xml:space="preserve">
          <source>Then follow the wizard steps. You'll have a &lt;code&gt;build.gradle&lt;/code&gt; file created with Kotlin configured according to &lt;a href=&quot;../../reference/using-gradle&quot;&gt;this document&lt;/a&gt;. Make sure it's configured for Kotlin 1.3 or higher.</source>
          <target state="translated">然后按照向导步骤。您将拥有一个Kotlin创建的 &lt;code&gt;build.gradle&lt;/code&gt; 文件，&lt;a href=&quot;../../reference/using-gradle&quot;&gt;该文件&lt;/a&gt;根据此文档进行配置。确保将其配置为Kotlin 1.3或更高版本。</target>
        </trans-unit>
        <trans-unit id="9ed3e436c4ee364169e1bdacb724480b6ae120b2" translate="yes" xml:space="preserve">
          <source>Then follow the wizard steps. You'll have a &lt;code&gt;pom.xml&lt;/code&gt; file created with Kotlin configured according to &lt;a href=&quot;../../reference/using-maven&quot;&gt;this document&lt;/a&gt;. Make sure it's configured for Kotlin 1.3 or higher.</source>
          <target state="translated">然后按照向导步骤。您将拥有一个根据&lt;a href=&quot;../../reference/using-maven&quot;&gt;本文档&lt;/a&gt;配置Kotlin创建的 &lt;code&gt;pom.xml&lt;/code&gt; 文件。确保将其配置为Kotlin 1.3或更高版本。</target>
        </trans-unit>
        <trans-unit id="10cfe3c1803900b3459055c1fdedb21ced35e4cd" translate="yes" xml:space="preserve">
          <source>Then run the &lt;code&gt;cinterop&lt;/code&gt; tool with something like this (note that for host libraries that are not included in the sysroot search paths, headers may be needed):</source>
          <target state="translated">然后使用以下内容运行 &lt;code&gt;cinterop&lt;/code&gt; 工具（请注意，对于sysroot搜索路径中未包含的主机库，可能需要标头）：</target>
        </trans-unit>
        <trans-unit id="5581239ffa3d854f1837127435e240d49f122ba5" translate="yes" xml:space="preserve">
          <source>Then specify the list of SAM-with-receiver annotations:</source>
          <target state="translated">然后指定SAM-with-receiver注释的列表。</target>
        </trans-unit>
        <trans-unit id="9b78fa9ef8a36ffde61cb8bc4f298109afadcbee" translate="yes" xml:space="preserve">
          <source>Then specify the list of annotations that will make classes open:</source>
          <target state="translated">然后指定将使类打开的注释列表。</target>
        </trans-unit>
        <trans-unit id="fd73374c27e0a874f2f41c35f033bfc599a82d6b" translate="yes" xml:space="preserve">
          <source>Then specify the list of no-arg annotations:</source>
          <target state="translated">然后指定无参数注释的列表。</target>
        </trans-unit>
        <trans-unit id="0ef92249fe5f505a551a8b463644321da779af43" translate="yes" xml:space="preserve">
          <source>Then we can have several processor coroutines. In this example, they just print their id and received number:</source>
          <target state="translated">那么我们可以有几个处理器的coroutine。在这个例子中,它们只是打印自己的id和收到的号码。</target>
        </trans-unit>
        <trans-unit id="490b87ea6044ef60c21b2e7783571a7d77df8b12" translate="yes" xml:space="preserve">
          <source>Then we define a function that launches an actor using an &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/actor.html&quot;&gt;actor&lt;/a&gt; coroutine builder:</source>
          <target state="translated">然后，我们定义一个使用&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/actor.html&quot;&gt;actor&lt;/a&gt;协程生成器启动actor的函数：</target>
        </trans-unit>
        <trans-unit id="843feae1b1434f20428d159db5d3289af1525e9c" translate="yes" xml:space="preserve">
          <source>Then, for each &lt;a href=&quot;https://developer.android.com/studio/build/build-variants#sourcesets&quot;&gt;Android source set&lt;/a&gt; compiled by the variants, a Kotlin source set is created under that source set name prepended by the target name, like Kotlin source set &lt;code&gt;androidDebug&lt;/code&gt; for an Android source set &lt;code&gt;debug&lt;/code&gt; and the Kotlin target named &lt;code&gt;android&lt;/code&gt;. These Kotlin source sets are added to the variants compilations accordingly.</source>
          <target state="translated">然后，对于由变体编译的每个&lt;a href=&quot;https://developer.android.com/studio/build/build-variants#sourcesets&quot;&gt;Android源集&lt;/a&gt;，将在目标名称前的源集名称下创建Kotlin源集，例如Android源集 &lt;code&gt;debug&lt;/code&gt; 的 Kotlin源集 &lt;code&gt;androidDebug&lt;/code&gt; 和名为 &lt;code&gt;android&lt;/code&gt; 的Kotlin目标。这些Kotlin源集会相应地添加到变体编辑中。</target>
        </trans-unit>
        <trans-unit id="68562aa9b0f180cb0bf47fd690042cd2286c6294" translate="yes" xml:space="preserve">
          <source>Then, it would be perfectly safe to store a reference to an instance of &lt;code&gt;Source&amp;lt;String&amp;gt;&lt;/code&gt; in a variable of type &lt;code&gt;Source&amp;lt;Object&amp;gt;&lt;/code&gt; &amp;ndash; there are no consumer-methods to call. But Java does not know this, and still prohibits it:</source>
          <target state="translated">然后，将对 &lt;code&gt;Source&amp;lt;String&amp;gt;&lt;/code&gt; 实例的引用存储在类型为 &lt;code&gt;Source&amp;lt;Object&amp;gt;&lt;/code&gt; 的变量中将是绝对安全的&amp;ndash;没有要调用的使用方方法。但是Java不知道这一点，并且仍然禁止它：</target>
        </trans-unit>
        <trans-unit id="d673d7a939528ccf7977db751d0c7bd0f923bb89" translate="yes" xml:space="preserve">
          <source>Then, once a target is added, default compilations are created for it:</source>
          <target state="translated">然后,一旦添加了一个目标,就会为其创建默认的编译。</target>
        </trans-unit>
        <trans-unit id="a7b51b664e8983298e6dc346e7c7dc0b18863813" translate="yes" xml:space="preserve">
          <source>Then, some time later the deprecation level is raised to &lt;a href=&quot;../-deprecation-level/-e-r-r-o-r#kotlin.DeprecationLevel.ERROR&quot;&gt;DeprecationLevel.ERROR&lt;/a&gt;, so that no new Kotlin code can be compiled using the deprecated API.</source>
          <target state="translated">然后，过一会儿，弃用级别将提高到&lt;a href=&quot;../-deprecation-level/-e-r-r-o-r#kotlin.DeprecationLevel.ERROR&quot;&gt;DeprecationLevel.ERROR&lt;/a&gt;，以便使用弃用的API无法编译新的Kotlin代码。</target>
        </trans-unit>
        <trans-unit id="b6377e7d0f06e408f80f03d549dd08ce8d9b969c" translate="yes" xml:space="preserve">
          <source>Then, the only thing we want to ensure is that &lt;code&gt;copy()&lt;/code&gt; does not do any bad things. We want to prohibit it from &lt;strong&gt;writing&lt;/strong&gt; to &lt;code&gt;from&lt;/code&gt;, and we can:</source>
          <target state="translated">然后，我们唯一要确保的是 &lt;code&gt;copy()&lt;/code&gt; 不会做任何不好的事情。我们想从禁止其&lt;strong&gt;写入&lt;/strong&gt;到 &lt;code&gt;from&lt;/code&gt; ，我们可以：</target>
        </trans-unit>
        <trans-unit id="2e04f4cdf39ff6bfe2fd15e1cdcb551eff15e642" translate="yes" xml:space="preserve">
          <source>There are a few courses available for Kotlin, including a &lt;a href=&quot;https://www.pluralsight.com/courses/kotlin-getting-started&quot;&gt;Pluralsight Kotlin Course&lt;/a&gt; by Kevin Jones, an &lt;a href=&quot;http://shop.oreilly.com/product/0636920052982.do&quot;&gt;O&amp;rsquo;Reilly Course&lt;/a&gt; by Hadi Hariri and an &lt;a href=&quot;http://petersommerhoff.com/dev/kotlin/kotlin-beginner-tutorial/&quot;&gt;Udemy Kotlin Course&lt;/a&gt; by Peter Sommerhoff.</source>
          <target state="translated">Kotlin有一些可用的课程，包括Kevin Jones 的&lt;a href=&quot;https://www.pluralsight.com/courses/kotlin-getting-started&quot;&gt;Pluralsight Kotlin &lt;/a&gt;&lt;a href=&quot;http://shop.oreilly.com/product/0636920052982.do&quot;&gt;课程&lt;/a&gt;，Hadi Hariri 的O'Reilly课程和Peter Sommerhoff 的&lt;a href=&quot;http://petersommerhoff.com/dev/kotlin/kotlin-beginner-tutorial/&quot;&gt;Udemy Kotlin课程&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7aeb1151dcad680105c7a075482911c8fc7a00f6" translate="yes" xml:space="preserve">
          <source>There are a lot of built-in extension functions/properties in Kotlin - for example, &lt;code&gt;map()&lt;/code&gt;, &lt;code&gt;filter()&lt;/code&gt;, and the rest of the framework for processing collections in a functional manner is built using extension functions.</source>
          <target state="translated">Kotlin中有很多内置的扩展功能/属性-例如 &lt;code&gt;map()&lt;/code&gt; ， &lt;code&gt;filter()&lt;/code&gt; 和使用扩展功能构建其余用于以功能方式处理集合的框架。</target>
        </trans-unit>
        <trans-unit id="24f819fcebc7b01f0f49b06a15eca941aac602cd" translate="yes" xml:space="preserve">
          <source>There are already &lt;a href=&quot;https://kotlinlang.org/docs/books.html&quot;&gt;a number of books&lt;/a&gt; available for Kotlin, including &lt;a href=&quot;https://www.manning.com/books/kotlin-in-action&quot;&gt;Kotlin in Action&lt;/a&gt; which is by Kotlin team members Dmitry Jemerov and Svetlana Isakova, &lt;a href=&quot;https://leanpub.com/kotlin-for-android-developers&quot;&gt;Kotlin for Android Developers&lt;/a&gt; targeted at Android developers.</source>
          <target state="translated">Kotlin 已经&lt;a href=&quot;https://kotlinlang.org/docs/books.html&quot;&gt;有许多&lt;/a&gt;可用的书籍，其中包括&lt;a href=&quot;https://www.manning.com/books/kotlin-in-action&quot;&gt;Kotlin&lt;/a&gt;团队成员Dmitry Jemerov和&lt;a href=&quot;https://leanpub.com/kotlin-for-android-developers&quot;&gt;Kotlin的&lt;/a&gt; Svetlana Isakova，由Kotlin团队成员Dmitry Jemerov和Android开发人员针对Android开发人员编写。</target>
        </trans-unit>
        <trans-unit id="cafdda410a7a8fb3e86649e5eeda1f41cb52882f" translate="yes" xml:space="preserve">
          <source>There are also functions for creating collections without any elements: &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/empty-list&quot;&gt;&lt;code&gt;emptyList()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/empty-set&quot;&gt;&lt;code&gt;emptySet()&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/empty-map&quot;&gt;&lt;code&gt;emptyMap()&lt;/code&gt;&lt;/a&gt;. When creating empty collections, you should specify the type of elements that the collection will hold.</source>
          <target state="translated">还有一些用于创建不带任何元素的集合的函数：&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/empty-list&quot;&gt; &lt;code&gt;emptyList()&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/empty-set&quot;&gt; &lt;code&gt;emptySet()&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/empty-map&quot;&gt; &lt;code&gt;emptyMap()&lt;/code&gt; &lt;/a&gt;。创建空集合时，应指定集合将包含的元素类型。</target>
        </trans-unit>
        <trans-unit id="843241bb0f5eb80f440f0b1b3622ce9c95598c3b" translate="yes" xml:space="preserve">
          <source>There are also functions for retrieving the smallest and the largest elements by certain selector function or custom &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin/-comparator/index&quot;&gt;&lt;code&gt;Comparator&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">还有一些通过某些选择器功能或自定义&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin/-comparator/index&quot;&gt; &lt;code&gt;Comparator&lt;/code&gt; &lt;/a&gt;检索最小和最大元素的函数：</target>
        </trans-unit>
        <trans-unit id="4888d99de496e5f2812e2d42599de7f621ae0a73" translate="yes" xml:space="preserve">
          <source>There are also functions that narrow the element type by filtering elements of a given type:</source>
          <target state="translated">还有一些函数可以通过过滤给定类型的元素来缩小元素类型。</target>
        </trans-unit>
        <trans-unit id="22fc645d90366ef3cbd36340e10852155ba93121" translate="yes" xml:space="preserve">
          <source>There are also many recordings of &lt;a href=&quot;http://kotlinlang.org/community/talks.html&quot;&gt;Kotlin talks&lt;/a&gt; available on YouTube and Vimeo.</source>
          <target state="translated">YouTube和Vimeo上还有许多&lt;a href=&quot;http://kotlinlang.org/community/talks.html&quot;&gt;Kotlin演讲的&lt;/a&gt;录音。</target>
        </trans-unit>
        <trans-unit id="e4606566df8d7d15d5ed6bd46e8178f7ee899fb7" translate="yes" xml:space="preserve">
          <source>There are also more specific types:</source>
          <target state="translated">还有一些比较特殊的类型。</target>
        </trans-unit>
        <trans-unit id="06489c1e98a1df08c22af1c2c8a1f880cc0522a9" translate="yes" xml:space="preserve">
          <source>There are also some tools available to convert between Kotlin and C strings manually:</source>
          <target state="translated">也有一些工具可以在Kotlin和C字符串之间手动转换。</target>
        </trans-unit>
        <trans-unit id="5da1b83a877bec99a63204ac23c3a863bcc7d2fe" translate="yes" xml:space="preserve">
          <source>There are also the following type qualifiers in the C language: &lt;code&gt;const&lt;/code&gt;, &lt;code&gt;volatile&lt;/code&gt;, &lt;code&gt;restruct&lt;/code&gt;, &lt;code&gt;atomic&lt;/code&gt;.</source>
          <target state="translated">在C语言中，还有以下类型限定符： &lt;code&gt;const&lt;/code&gt; ， &lt;code&gt;volatile&lt;/code&gt; ， &lt;code&gt;restruct&lt;/code&gt; ， &lt;code&gt;atomic&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d1856539b37f6f362e28eec082e8282bf62fdd7b" translate="yes" xml:space="preserve">
          <source>There are also two specific ways for filtering maps: by keys and by values. For each way, there is a function: &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/filter-keys&quot;&gt;&lt;code&gt;filterKeys()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/filter-values&quot;&gt;&lt;code&gt;filterValues()&lt;/code&gt;&lt;/a&gt;. Both return a new map of entries which match the given predicate. The predicate for &lt;code&gt;filterKeys()&lt;/code&gt; checks only the element keys, the one for &lt;code&gt;filterValues()&lt;/code&gt; checks only values.</source>
          <target state="translated">还有两种用于过滤地图的特定方法：按键和按值。对于每种方式，都有一个函数：&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/filter-keys&quot;&gt; &lt;code&gt;filterKeys()&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/filter-values&quot;&gt; &lt;code&gt;filterValues()&lt;/code&gt; &lt;/a&gt;。两者均返回与给定谓词匹配的新条目映射。谓词 &lt;code&gt;filterKeys()&lt;/code&gt; 仅检查元件按键，一个用于 &lt;code&gt;filterValues()&lt;/code&gt; 仅检查值。</target>
        </trans-unit>
        <trans-unit id="250044abbac1d0cc39bffb2b00e37419c1aa5fa8" translate="yes" xml:space="preserve">
          <source>There are also useful aliases for retrieving the first and the last element of the collection: &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/first&quot;&gt;&lt;code&gt;first()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/last&quot;&gt;&lt;code&gt;last()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">还有一些有用的别名来检索集合的第一个和最后一个元素：&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/first&quot;&gt; &lt;code&gt;first()&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/last&quot;&gt; &lt;code&gt;last()&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f989069ff2a0fc8bbd7269050d48a2e9c89946af" translate="yes" xml:space="preserve">
          <source>There are certain common kinds of properties, that, though we can implement them manually every time we need them, would be very nice to implement once and for all, and put into a library. Examples include:</source>
          <target state="translated">有一些常见的属性,虽然我们可以在每次需要的时候手动实现,但如果能一次性实现,并放入库中,那就再好不过了。例子包括:</target>
        </trans-unit>
        <trans-unit id="e9d07a2b7a0e6a37bb57f8fc3823505798a41626" translate="yes" xml:space="preserve">
          <source>There are certain rules that define write operations on maps:</source>
          <target state="translated">有一些规则定义了对地图的写操作。</target>
        </trans-unit>
        <trans-unit id="2a3a36051a175f99aacc43b0a72a065674774e2a" translate="yes" xml:space="preserve">
          <source>There are couple of observations to make out of it.</source>
          <target state="translated">从中可以看出几个问题。</target>
        </trans-unit>
        <trans-unit id="fd050ce9dc8260feb80b7e8ad7e70f3ec42e69f1" translate="yes" xml:space="preserve">
          <source>There are exactly four instances of this class, named &lt;code&gt;ContentKind.TOPIC&lt;/code&gt;, and so on. Instances of this class can be compared to each other with &lt;code&gt;==&lt;/code&gt; and &lt;code&gt;!=&lt;/code&gt;, and you can get all the allowable values with &lt;code&gt;ContentKind.values()&lt;/code&gt;. You can also tack on more information to each instance if you need:</source>
          <target state="translated">该类有四个实例，分别称为 &lt;code&gt;ContentKind.TOPIC&lt;/code&gt; ，依此类推。可以使用 &lt;code&gt;==&lt;/code&gt; 和 &lt;code&gt;!=&lt;/code&gt; 将此类的实例相互比较，并且可以使用 &lt;code&gt;ContentKind.values()&lt;/code&gt; 获得所有允许的值。如果需要，您还可以为每个实例提供更多信息：</target>
        </trans-unit>
        <trans-unit id="f927ac2e11471dbf3b5e6b2ee718ccfcd881bb02" translate="yes" xml:space="preserve">
          <source>There are many approaches to this problem, and in Kotlin we take a very flexible one by providing &lt;a href=&quot;https://en.wikipedia.org/wiki/Coroutine&quot;&gt;Coroutine&lt;/a&gt; support at the language level and delegating most of the functionality to libraries, much in line with Kotlin's philosophy.</source>
          <target state="translated">解决此问题的方法很多，在Kotlin中，我们通过在语言级别提供&lt;a href=&quot;https://en.wikipedia.org/wiki/Coroutine&quot;&gt;Coroutine&lt;/a&gt;支持并将大部分功能委托给库来采取非常灵活的方法，这与Kotlin的哲学非常一致。</target>
        </trans-unit>
        <trans-unit id="a0366ee935c5394b522c3fe877f29b4f014a964b" translate="yes" xml:space="preserve">
          <source>There are many more platform libraries available for host and cross-compilation targets. &lt;code&gt;Kotlin/Native&lt;/code&gt; distribution provides access to &lt;code&gt;OpenGL&lt;/code&gt;, &lt;code&gt;zlib&lt;/code&gt; and other popular native libraries on applicable platforms.</source>
          <target state="translated">还有更多的平台库可用于宿主和交叉编译目标。 &lt;code&gt;Kotlin/Native&lt;/code&gt; 发行版提供对 &lt;code&gt;OpenGL&lt;/code&gt; ， &lt;code&gt;zlib&lt;/code&gt; 和适用平台上其他流行的本机库的访问。</target>
        </trans-unit>
        <trans-unit id="ef27dee02c48c1f5d014bbb6297ef36468bd6491" translate="yes" xml:space="preserve">
          <source>There are multiple ways to compile Kotlin to JavaScript. The recommended approach is to use Gradle; if desired, you can also build JavaScript projects directly from IntelliJ IDEA, use Maven, or compile the code manually from the command line. To learn more about how to compile to JavaScript please see the corresponding tutorials:</source>
          <target state="translated">有多种方法可以将Kotlin编译成JavaScript。推荐的方法是使用Gradle;如果需要,你也可以直接从IntelliJ IDEA中构建JavaScript项目,使用Maven,或者从命令行手动编译代码。要了解更多关于如何编译成JavaScript的信息,请看相应的教程。</target>
        </trans-unit>
        <trans-unit id="655afcf98b929642faf68faf52cca26e671f04f6" translate="yes" xml:space="preserve">
          <source>There are no &lt;code&gt;**kwargs&lt;/code&gt; in Kotlin, but you can define optional parameters with default values, and you may choose to name some or all of the parameters when you call the function (whether they've got default values or not). A parameter with a default value must still specify its type explicitly. Like in Python, the named arguments can be reordered at will at the call site:</source>
          <target state="translated">Kotlin 中没有 &lt;code&gt;**kwargs&lt;/code&gt; kwarg，但是您可以定义具有默认值的可选参数，并且在调用函数时可以选择命名部分或全部参数（无论它们是否具有默认值）。具有默认值的参数仍必须明确指定其类型。像在Python中一样，可以在调用站点随意重新命名命名的参数：</target>
        </trans-unit>
        <trans-unit id="577ed2c21e3c8a21c4f57421503fea8126403589" translate="yes" xml:space="preserve">
          <source>There are no automatic conversions to boolean and thus no concept of truthy and falsy: checks for zero, empty, or null must be done explicitly with &lt;code&gt;==&lt;/code&gt; or &lt;code&gt;!=&lt;/code&gt;. Most collection types have an &lt;code&gt;isEmpty()&lt;/code&gt; and an &lt;code&gt;isNotEmpty()&lt;/code&gt; function.</source>
          <target state="translated">没有自动转换为布尔值的方法，因此也没有&amp;ldquo;真假&amp;rdquo;的概念：必须使用 &lt;code&gt;==&lt;/code&gt; 或 &lt;code&gt;!=&lt;/code&gt; 明确进行零，空或null的检查。大多数集合类型具有 &lt;code&gt;isEmpty()&lt;/code&gt; 和 &lt;code&gt;isNotEmpty()&lt;/code&gt; 函数。</target>
        </trans-unit>
        <trans-unit id="0173c0164165dfc2326b31145c73366a6b9e4caf" translate="yes" xml:space="preserve">
          <source>There are now separate versions of the standard library supporting the new JDK APIs added in Java 7 and 8. If you need access to the new APIs, use &lt;code&gt;kotlin-stdlib-jre7&lt;/code&gt; and &lt;code&gt;kotlin-stdlib-jre8&lt;/code&gt; maven artifacts instead of the standard &lt;code&gt;kotlin-stdlib&lt;/code&gt;. These artifacts are tiny extensions on top of &lt;code&gt;kotlin-stdlib&lt;/code&gt; and they bring it to your project as a transitive dependency.</source>
          <target state="translated">现在，有标准库的单独版本支持在Java 7和8中添加的新JDK API。如果需要访问新API，请使用 &lt;code&gt;kotlin-stdlib-jre7&lt;/code&gt; 和 &lt;code&gt;kotlin-stdlib-jre8&lt;/code&gt; maven构件代替标准 &lt;code&gt;kotlin-stdlib&lt;/code&gt; 。这些工件是 &lt;code&gt;kotlin-stdlib&lt;/code&gt; 之上的微小扩展，它们作为传递依赖项将其带入您的项目。</target>
        </trans-unit>
        <trans-unit id="eb7a82db5fbadd7939003437756e36c07405db69" translate="yes" xml:space="preserve">
          <source>There are numerous ways that Kotlin/JS can be used. To provide you some inspiration, here's a non-exhaustive list of scenarios in which you can use Kotlin/JS.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f69b73bfcd710307d7869f79c049d0bc960833d" translate="yes" xml:space="preserve">
          <source>There are several ways to obtain an instance of a function type:</source>
          <target state="translated">有几种方法可以获得函数类型的实例。</target>
        </trans-unit>
        <trans-unit id="bfb4470f4c8ab69e441c59ca19feae2c36a172f6" translate="yes" xml:space="preserve">
          <source>There are several ways to override the default setting:</source>
          <target state="translated">有几种方法可以覆盖默认设置。</target>
        </trans-unit>
        <trans-unit id="3ea08a710ccd5abee84ca77d28377d406d442756" translate="yes" xml:space="preserve">
          <source>There are some limitations:</source>
          <target state="translated">有一些限制。</target>
        </trans-unit>
        <trans-unit id="060bb5e1464bf104cc44e53612c8d8eb0e6d472c" translate="yes" xml:space="preserve">
          <source>There are target presets that one can apply using the preset functions, as shown above, for the following target platforms:</source>
          <target state="translated">有一些目标预设,可以使用预设功能来应用,如上图所示,适用于以下目标平台。</target>
        </trans-unit>
        <trans-unit id="7df642de78432a3520c5b5afd68e2c605c1c315a" translate="yes" xml:space="preserve">
          <source>There are the following kinds of literal constants for integral values:</source>
          <target state="translated">积分值的文字常数有以下几种。</target>
        </trans-unit>
        <trans-unit id="f4373b7b309c5120a0c7bdb4b6efb5a4594f35b5" translate="yes" xml:space="preserve">
          <source>There are three coroutines. The main coroutine (#1) &amp;ndash; &lt;code&gt;runBlocking&lt;/code&gt; one, and two coroutines computing deferred values &lt;code&gt;a&lt;/code&gt; (#2) and &lt;code&gt;b&lt;/code&gt; (#3). They are all executing in the context of &lt;code&gt;runBlocking&lt;/code&gt; and are confined to the main thread. The output of this code is:</source>
          <target state="translated">有三个协程。主协程（＃1）&amp;ndash; &lt;code&gt;runBlocking&lt;/code&gt; 一个协程，两个协程计算递延值 &lt;code&gt;a&lt;/code&gt; （＃2）和 &lt;code&gt;b&lt;/code&gt; （＃3）。它们都在 &lt;code&gt;runBlocking&lt;/code&gt; 上下文中执行，并且仅限于主线程。此代码的输出是：</target>
        </trans-unit>
        <trans-unit id="b170e6fd924b27994900ac3fea0116365dd9d5a3" translate="yes" xml:space="preserve">
          <source>There are three coroutines. The main coroutine (#1) inside &lt;code&gt;runBlocking&lt;/code&gt; and two coroutines computing the deferred values &lt;code&gt;a&lt;/code&gt; (#2) and &lt;code&gt;b&lt;/code&gt; (#3). They are all executing in the context of &lt;code&gt;runBlocking&lt;/code&gt; and are confined to the main thread. The output of this code is:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f684c90b5c1cc2b45ec708952abe326e96395793" translate="yes" xml:space="preserve">
          <source>There are too many companies using Kotlin to list, but some more visible companies that have publicly declared usage of Kotlin, be this via blog posts, GitHub repositories or talks include &lt;a href=&quot;https://medium.com/square-corner-blog/square-open-source-loves-kotlin-c57c21710a17&quot;&gt;Square&lt;/a&gt;, &lt;a href=&quot;https://www.youtube.com/watch?v=mDpnc45WwlI&quot;&gt;Pinterest&lt;/a&gt;, &lt;a href=&quot;https://m.signalvnoise.com/how-we-made-basecamp-3s-android-app-100-kotlin-35e4e1c0ef12&quot;&gt;Basecamp&lt;/a&gt; or &lt;a href=&quot;https://docs.corda.net/releases/release-M9.2/further-notes-on-kotlin.html&quot;&gt;Corda&lt;/a&gt;.</source>
          <target state="translated">有太多使用Kotlin进行上市的公司，但是一些公开宣布使用Kotlin的知名公司（包括博客文章，GitHub仓库或座谈会）包括&lt;a href=&quot;https://medium.com/square-corner-blog/square-open-source-loves-kotlin-c57c21710a17&quot;&gt;Square&lt;/a&gt;，&lt;a href=&quot;https://www.youtube.com/watch?v=mDpnc45WwlI&quot;&gt;Pinterest&lt;/a&gt;，&lt;a href=&quot;https://m.signalvnoise.com/how-we-made-basecamp-3s-android-app-100-kotlin-35e4e1c0ef12&quot;&gt;Basecamp&lt;/a&gt;或&lt;a href=&quot;https://docs.corda.net/releases/release-M9.2/further-notes-on-kotlin.html&quot;&gt;Corda&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="26ea8b64f47f54b93f794f79bdbd7ea265251dad" translate="yes" xml:space="preserve">
          <source>There are two approaches to making computation code cancellable. The first one is to periodically invoke a suspending function that checks for cancellation. There is a &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/yield.html&quot;&gt;yield&lt;/a&gt; function that is a good choice for that purpose. The other one is to explicitly check the cancellation status. Let us try the latter approach.</source>
          <target state="translated">有两种方法可以使计算代码可取消。第一个是定期调用检查取消的挂起函数。为此，有一个&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/yield.html&quot;&gt;yield&lt;/a&gt;函数是一个不错的选择。另一个是显式检查取消状态。让我们尝试后一种方法。</target>
        </trans-unit>
        <trans-unit id="cdb0e62ebdac6496d2a6cecaea4c9ddd6a113e2b" translate="yes" xml:space="preserve">
          <source>There are two functions for which the compiler gives same name in JavaScript, you can mark one with &lt;code&gt;@JsName(...)&lt;/code&gt; to prevent the compiler from reporting error.</source>
          <target state="translated">编译器在JavaScript中使用两个相同的函数来命名，您可以使用 &lt;code&gt;@JsName(...)&lt;/code&gt; 标记一个，以防止编译器报告错误。</target>
        </trans-unit>
        <trans-unit id="538a207adbe54f7fe71914302d366f642c584d32" translate="yes" xml:space="preserve">
          <source>There are two possible ways to opt-in for unsigned types: with marking your API as experimental too, or without doing that.</source>
          <target state="translated">有两种可能的方式来选择加入无符号类型:将你的API也标记为实验性的,或者不这样做。</target>
        </trans-unit>
        <trans-unit id="8fb334f842c55f58127659b8b13256439fde4f09" translate="yes" xml:space="preserve">
          <source>There are two possible ways to opt-in for unsigned types: with requiring an opt-in for your API, or without doing that.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86b3923915c4ddd4dd399b02f1d436b8dc853f8d" translate="yes" xml:space="preserve">
          <source>There can be different modes of stability depending of how quickly a component is evolving:</source>
          <target state="translated">根据组件的发展速度,可以有不同的稳定模式。</target>
        </trans-unit>
        <trans-unit id="0b3f1a4d9ad65e8f5f359abf2fed82920c3beef2" translate="yes" xml:space="preserve">
          <source>There have been many approaches to solving this problem, including:</source>
          <target state="translated">解决这个问题的方法有很多,包括:</target>
        </trans-unit>
        <trans-unit id="c4dc29b34f77a8368125ef8d384ca8b6bfbe8472" translate="yes" xml:space="preserve">
          <source>There is a &lt;code&gt;kotlin.root.example.Clazz&lt;/code&gt; field that represents the &lt;code&gt;Clazz&lt;/code&gt; from Kotlin. The &lt;code&gt;Clazz#memberFunction&lt;/code&gt; is accessible with the &lt;code&gt;memberFunction&lt;/code&gt; field. The only difference is that the &lt;code&gt;memberFunction&lt;/code&gt; accepts a &lt;code&gt;this&lt;/code&gt; reference as the first parameter. The C language does not support objects, and this is the reason to pass a &lt;code&gt;this&lt;/code&gt; pointer explicitly.</source>
          <target state="translated">有一个 &lt;code&gt;kotlin.root.example.Clazz&lt;/code&gt; 表示场 &lt;code&gt;Clazz&lt;/code&gt; 从科特林。在 &lt;code&gt;Clazz#memberFunction&lt;/code&gt; 与访问 &lt;code&gt;memberFunction&lt;/code&gt; 领域。唯一的区别是 &lt;code&gt;memberFunction&lt;/code&gt; 接受 &lt;code&gt;this&lt;/code&gt; 引用作为第一个参数。C语言不支持对象，这就是显式传递 &lt;code&gt;this&lt;/code&gt; 指针的原因。</target>
        </trans-unit>
        <trans-unit id="725365acc046d2774e785fd58198ecf73c6aec56" translate="yes" xml:space="preserve">
          <source>There is a better solution. We can use structured concurrency in our code. Instead of launching coroutines in the &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-global-scope/index.html&quot;&gt;GlobalScope&lt;/a&gt;, just like we usually do with threads (threads are always global), we can launch coroutines in the specific scope of the operation we are performing.</source>
          <target state="translated">有更好的解决方案。我们可以在代码中使用结构化并发。像我们通常在线程中一样（线程始终是全局的），而不是在&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-global-scope/index.html&quot;&gt;GlobalScope&lt;/a&gt;中启动协程，我们可以在正在执行的操作的特定范围内启动协程。</target>
        </trans-unit>
        <trans-unit id="f4b1300b6ec8e15e33a7b0dfe89c4e2e11e628f0" translate="yes" xml:space="preserve">
          <source>There is a bunch of new extensions on the String class to convert it to a number without throwing an exception on invalid number: &lt;code&gt;String.toIntOrNull(): Int?&lt;/code&gt;, &lt;code&gt;String.toDoubleOrNull(): Double?&lt;/code&gt; etc.</source>
          <target state="translated">String类上有很多新扩展，可以将其转换为数字，而不会在无效数字上引发异常： &lt;code&gt;String.toIntOrNull(): Int?&lt;/code&gt; ， &lt;code&gt;String.toDoubleOrNull(): Double?&lt;/code&gt; 等等</target>
        </trans-unit>
        <trans-unit id="2d16488afd500f574acdf4a610fe81c8b613729f" translate="yes" xml:space="preserve">
          <source>There is a common misconception that making a variable &lt;code&gt;volatile&lt;/code&gt; solves concurrency problem. Let us try it:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e33e2bb2c0c45c94e894d38130281f13150c4a3" translate="yes" xml:space="preserve">
          <source>There is a constructor in the &lt;code&gt;Clazz&lt;/code&gt; field (aka &lt;code&gt;kotlin.root.example.Clazz.Clazz&lt;/code&gt;), which is the constructor function to create an instance of the &lt;code&gt;Clazz&lt;/code&gt;.</source>
          <target state="translated">有一个在构造函数 &lt;code&gt;Clazz&lt;/code&gt; 字段（又名 &lt;code&gt;kotlin.root.example.Clazz.Clazz&lt;/code&gt; ），这是构造函数来创建的实例 &lt;code&gt;Clazz&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b8e6c9d338e18c01513c4cf42dbec9a1ab61f7aa" translate="yes" xml:space="preserve">
          <source>There is a convenient coroutine builder named &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/produce.html&quot;&gt;produce&lt;/a&gt; that makes it easy to do it right on producer side, and an extension function &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/consume-each.html&quot;&gt;consumeEach&lt;/a&gt;, that replaces a &lt;code&gt;for&lt;/code&gt; loop on the consumer side:</source>
          <target state="translated">有一个名为方便协同程序生成器&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/produce.html&quot;&gt;产生&lt;/a&gt;，可以很容易把事情做对的制片方和扩展功能&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/consume-each.html&quot;&gt;consumeEach&lt;/a&gt;，替换上 &lt;code&gt;for&lt;/code&gt; 消费者一方循环：</target>
        </trans-unit>
        <trans-unit id="2dc05473a597a891dd992cdcf3cb31ec48971266" translate="yes" xml:space="preserve">
          <source>There is a laziness option to &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/async.html&quot;&gt;async&lt;/a&gt; using an optional &lt;code&gt;start&lt;/code&gt; parameter with a value of &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-start/-l-a-z-y.html&quot;&gt;CoroutineStart.LAZY&lt;/a&gt;. It starts coroutine only when its result is needed by some &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-deferred/await.html&quot;&gt;await&lt;/a&gt; or if a &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/start.html&quot;&gt;start&lt;/a&gt; function is invoked. Run the following example:</source>
          <target state="translated">有一个懒惰选项&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/async.html&quot;&gt;异步&lt;/a&gt;使用可选的 &lt;code&gt;start&lt;/code&gt; 参数与值&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-start/-l-a-z-y.html&quot;&gt;CoroutineStart.LAZY&lt;/a&gt;。仅在&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-deferred/await.html&quot;&gt;等待&lt;/a&gt;其结果或调用&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/start.html&quot;&gt;启动&lt;/a&gt;函数时，它才启动协程。运行以下示例：</target>
        </trans-unit>
        <trans-unit id="64fbf3e4d33c3845151425fcbae0bd95c1ac7ffc" translate="yes" xml:space="preserve">
          <source>There is a nice piece of syntactic sugar that lets you do this: &lt;em&gt;extension functions&lt;/em&gt; and &lt;em&gt;extension properties&lt;/em&gt;. They look like regular member functions/properties, but they are defined outside of any class - yet they reference the class name and can use &lt;code&gt;this&lt;/code&gt;. However, they can only use visible members of the class (typically just the public ones). Behind the scenes, they get compiled down to regular functions that take the target instance as a parameter.</source>
          <target state="translated">有一个不错的语法糖可以让您做到这一点：&lt;em&gt;扩展功能&lt;/em&gt;和&lt;em&gt;扩展属性&lt;/em&gt;。它们看起来像常规成员函数/属性，但是它们在任何类之外定义-但是它们引用了类名并且可以使用 &lt;code&gt;this&lt;/code&gt; 。但是，他们只能使用该类的可见成员（通常仅是公共成员）。在幕后，它们被编译为以目标实例为参数的常规函数​​。</target>
        </trans-unit>
        <trans-unit id="56a1a93e9823bbcbe462dd3f2561922740df0cc6" translate="yes" xml:space="preserve">
          <source>There is also &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.sync/with-lock.html&quot;&gt;withLock&lt;/a&gt; extension function that conveniently represents &lt;code&gt;mutex.lock(); try { ... } finally { mutex.unlock() }&lt;/code&gt; pattern:</source>
          <target state="translated">还有一个&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.sync/with-lock.html&quot;&gt;withLock&lt;/a&gt;扩展功能，可以方便地表示 &lt;code&gt;mutex.lock(); try { ... } finally { mutex.unlock() }&lt;/code&gt; 模式：</target>
        </trans-unit>
        <trans-unit id="5482d8805716b35d94ddb1402c557dc6720d3835" translate="yes" xml:space="preserve">
          <source>There is also a pair of functions that take a predicate and search for elements matching it:</source>
          <target state="translated">还有一对函数,取一个谓词并搜索与之匹配的元素。</target>
        </trans-unit>
        <trans-unit id="40c042439b9082c369e4da946808b3cddd767bd9" translate="yes" xml:space="preserve">
          <source>There is an &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/actor.html&quot;&gt;actor&lt;/a&gt; coroutine builder that conveniently combines actor's mailbox channel into its scope to receive messages from and combines the send channel into the resulting job object, so that a single reference to the actor can be carried around as its handle.</source>
          <target state="translated">有一个&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/actor.html&quot;&gt;actor&lt;/a&gt;协程生成器，可以方便地将actor的邮箱通道合并到其作用域中，以从中接收消息，并将send通道合并到结果作业对象中，以便可以随身携带对actor的单个引用作为其句柄。</target>
        </trans-unit>
        <trans-unit id="b44464d4de5fbd249cc21009c9fb2f52893bbcce" translate="yes" xml:space="preserve">
          <source>There is an optimization that removes redundant arrays creation in such cases, which prevents performance degradation. The single-argument form produces warnings in Kotlin 1.2 and is to be dropped in Kotlin 1.3.</source>
          <target state="translated">有一个优化,在这种情况下,可以去除冗余数组的创建,从而防止性能下降。单参数形式在 Kotlin 1.2 中会产生警告,在 Kotlin 1.3 中会被删除。</target>
        </trans-unit>
        <trans-unit id="6a4b4c7df274b19d3bf5dccee93fd3962d578245" translate="yes" xml:space="preserve">
          <source>There is an option to publish variants grouped by the product flavor, so that the outputs of the different build types are placed in a single module, with the build type becoming a classifier for the artifacts (the release build type is still published with no classifier). This mode is disabled by default and can be enabled as follows:</source>
          <target state="translated">有一个选项可以按产品风味分组发布变体,这样不同构建类型的输出就会被放置在一个模块中,构建类型就会成为工件的分类器(发布的构建类型仍然是没有分类器的)。该模式默认是禁用的,可以按以下方式启用。</target>
        </trans-unit>
        <trans-unit id="6a3b908fffabfbd0bb64797382bd07626137ec3f" translate="yes" xml:space="preserve">
          <source>There is common misconception that making a variable &lt;code&gt;volatile&lt;/code&gt; solves concurrency problem. Let us try it:</source>
          <target state="translated">常见的误解是，使变量 &lt;code&gt;volatile&lt;/code&gt; 可解决并发问题。让我们尝试一下：</target>
        </trans-unit>
        <trans-unit id="5eb09ee69535cf6dda53683554e0ee16259161ba" translate="yes" xml:space="preserve">
          <source>There is no dedicated type in C language for strings. A developer knows from a method signature or the documentation, whether a given &lt;code&gt;char *&lt;/code&gt; means a C string in the context. Strings in the C language are null-terminated, a trailing zero character &lt;code&gt;\0&lt;/code&gt; is added at the end of a bytes sequence to mark a string termination. Usually, &lt;a href=&quot;https://en.wikipedia.org/wiki/UTF-8&quot;&gt;UTF-8 encoded strings&lt;/a&gt; are used. The UTF-8 encoding uses variable width characters, and it is backward compatible with &lt;a href=&quot;https://en.wikipedia.org/wiki/ASCII&quot;&gt;ASCII&lt;/a&gt;. Kotlin/Native uses UTF-8 character encoding by default.</source>
          <target state="translated">C语言中没有用于字符串的专用类型。开发人员从方法签名或文档中知道，给定的 &lt;code&gt;char *&lt;/code&gt; 在上下文中是否表示C字符串。 C语言中的字符串以空字符结尾，在字节序列的末尾添加一个结尾的零字符 &lt;code&gt;\0&lt;/code&gt; ，以标记字符串的结尾。通常，使用&lt;a href=&quot;https://en.wikipedia.org/wiki/UTF-8&quot;&gt;UTF-8编码的字符串&lt;/a&gt;。 UTF-8编码使用可变宽度的字符，并且与&lt;a href=&quot;https://en.wikipedia.org/wiki/ASCII&quot;&gt;ASCII&lt;/a&gt;向后兼容。 Kotlin / Native默认使用UTF-8字符编码。</target>
        </trans-unit>
        <trans-unit id="50408f344ff56fd13407ed98b66fe0baaa2ef0c5" translate="yes" xml:space="preserve">
          <source>There is no longer an exception when running this code:</source>
          <target state="translated">运行这段代码时,不再有异常。</target>
        </trans-unit>
        <trans-unit id="edef4e6315a2b596a0ca3836f2b3be1feee84974" translate="yes" xml:space="preserve">
          <source>There is no meaning attached to values in this class, it can be used for any purpose. Pair exhibits value semantics, i.e. two pairs are equal if both components are equal.</source>
          <target state="translated">在这个类中,值没有附加的意义,它可以用于任何目的。Pair表现出值的语义,即如果两个成分都相等,那么两个对就相等。</target>
        </trans-unit>
        <trans-unit id="0049a565ebb0e6780625b95d2507e4c5901c80a7" translate="yes" xml:space="preserve">
          <source>There is no meaning attached to values in this class, it can be used for any purpose. Triple exhibits value semantics, i.e. two triples are equal if all three components are equal. An example of decomposing it into values:</source>
          <target state="translated">在这个类中,值没有附加任何意义,它可以用于任何目的。三元组表现出值的语义,即如果三个成分都相等,则两个三元组就相等。将其分解为值的一个例子。</target>
        </trans-unit>
        <trans-unit id="1dd7b0fcce3d3026dd4903ea1dcae2ace7aba63b" translate="yes" xml:space="preserve">
          <source>There is no namespaces support in C, so the Kotlin/Native compiler generates long names to avoid any possible clashes with other symbols in the existing native project.</source>
          <target state="translated">C语言中不支持命名空间,所以Kotlin/Native编译器会生成长名,以避免与现有本地项目中的其他符号发生任何可能的冲突。</target>
        </trans-unit>
        <trans-unit id="9fc7acf9c721c77f449446dbc8b3636586ef2efc" translate="yes" xml:space="preserve">
          <source>There is no need to consider compatibility for new interfaces, as no clients have used them before. You can minimize the compatibility overhead by excluding these interfaces from the compatibility mode. To do this, annotate them with the &lt;code&gt;@JvmDefaultWithoutCompatibility&lt;/code&gt; annotation. Such interfaces compile the same way as with &lt;code&gt;-Xjvm-default=all&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8859e68bee06f71aa7ff22831dc050e526d2f13b" translate="yes" xml:space="preserve">
          <source>There is no need to handle the case of misformatted input in competitive programming. In competitive programming, an input format is always precisely specified and the actual input cannot deviate from the input specification in the problem statement. That's what the null-assertion operator &lt;code&gt;!!&lt;/code&gt; essentially does &amp;mdash; it asserts that the input string is present and throws an exception otherwise. Likewise, the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.text/to-int&quot;&gt;String.toInt()&lt;/a&gt; function throws an exception if the input string is not an integer.</source>
          <target state="translated">在竞争性编程中，无需处理格式错误的输入。在竞争性编程中，始终精确指定输入格式，并且实际输入不能偏离问题说明中的输入规范。这就是null断言运算符 &lt;code&gt;!!&lt;/code&gt; 本质上是这样做的-它断言输入字符串存在，否则抛出异常。同样，如果输入字符串不是整数，则&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.text/to-int&quot;&gt;String.toInt（）&lt;/a&gt;函数将引发异常。</target>
        </trans-unit>
        <trans-unit id="c6d0ebaf0b7e6376420eb9484810949b156e1e12" translate="yes" xml:space="preserve">
          <source>There is no such syntax in Kotlin. However, in Kotlin we have &lt;a href=&quot;object-declarations#companion-objects&quot;&gt;&lt;code&gt;companion&lt;/code&gt;&lt;/a&gt; objects. Kotlin treats companion objects of &lt;code&gt;external&lt;/code&gt; classes in a special way: instead of expecting an object, it assumes members of companion objects to be members of the class itself. &lt;code&gt;MyClass&lt;/code&gt; from the example above can be described as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e914e64115449100ebfd64599edfd2968cff02a7" translate="yes" xml:space="preserve">
          <source>There is now a large number of &lt;a href=&quot;building-mpp-with-gradle#supported-platforms&quot;&gt;preset platform configurations&lt;/a&gt; for different supported platforms.</source>
          <target state="translated">现在，存在针对不同支持平台的大量&lt;a href=&quot;building-mpp-with-gradle#supported-platforms&quot;&gt;预设平台配置&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5c9261e9c8424c9800b6b0327e8368a8f20c36c1" translate="yes" xml:space="preserve">
          <source>There is now a large number of &lt;a href=&quot;mpp-supported-platforms&quot;&gt;preset platform configurations&lt;/a&gt; for different supported platforms.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b648b3a77b4b2e5fa4527e728e2d5fe0ae2a410" translate="yes" xml:space="preserve">
          <source>There is one important semantic difference between object expressions and object declarations:</source>
          <target state="translated">对象表达式和对象声明之间有一个重要的语义区别。</target>
        </trans-unit>
        <trans-unit id="8fd6b73de53838cea1717936197f551e12e9d247" translate="yes" xml:space="preserve">
          <source>There is one more way to search elements in lists &amp;ndash; &lt;a href=&quot;https://en.wikipedia.org/wiki/Binary_search_algorithm&quot;&gt;binary search&lt;/a&gt;. It works significantly faster than other built-in search functions but &lt;em&gt;requires the list to be &lt;a href=&quot;collection-ordering&quot;&gt;sorted&lt;/a&gt;&lt;/em&gt; in ascending order according to a certain ordering: natural or another one provided in the function parameter. Otherwise, the result is undefined.</source>
          <target state="translated">搜索列表中元素的另一种方法是&lt;a href=&quot;https://en.wikipedia.org/wiki/Binary_search_algorithm&quot;&gt;二进制搜索&lt;/a&gt;。它的工作速度明显快于其他内置搜索功能，但&lt;em&gt;要求列表&lt;a href=&quot;collection-ordering&quot;&gt;&lt;/a&gt;&lt;/em&gt;按照某种顺序（自然或功能参数中提供的另一个&lt;em&gt;顺序）&lt;/em&gt;以升序排序。否则，结果是不确定的。</target>
        </trans-unit>
        <trans-unit id="c4497244354ad07743aea06bad3f15a18c72b5c2" translate="yes" xml:space="preserve">
          <source>There is still something to be desired for practical usage of coroutines. When we use &lt;code&gt;GlobalScope.launch&lt;/code&gt;, we create a top-level coroutine. Even though it is light-weight, it still consumes some memory resources while it runs. If we forget to keep a reference to the newly launched coroutine it still runs. What if the code in the coroutine hangs (for example, we erroneously delay for too long), what if we launched too many coroutines and ran out of memory? Having to manually keep references to all the launched coroutines and &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/join.html&quot;&gt;join&lt;/a&gt; them is error-prone.</source>
          <target state="translated">协程的实际使用仍需要一些东西。当使用 &lt;code&gt;GlobalScope.launch&lt;/code&gt; 时，我们将创建一个顶级协程。即使它很轻巧，它在运行时仍会消耗一些内存资源。如果我们忘记保留对新发布的协程的引用，它将继续运行。如果协程中的代码挂起（例如，我们错误地延迟了太长时间），怎么办？如果启动太多协程并用完了内存怎么办？必须手动保留对所有已启动协程的引用并&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/join.html&quot;&gt;加入&lt;/a&gt;它们是容易出错的。</target>
        </trans-unit>
        <trans-unit id="c2958b4b7d6ee3fe23d0044dbf293010b99dd8e5" translate="yes" xml:space="preserve">
          <source>There is still something to be desired for practical usage of coroutines. When we use &lt;code&gt;GlobalScope.launch&lt;/code&gt;, we create a top-level coroutine. Even though it is light-weight, it still consumes some memory resources while it runs. If we forget to keep a reference to the newly launched coroutine, it still runs. What if the code in the coroutine hangs (for example, we erroneously delay for too long), what if we launched too many coroutines and ran out of memory? Having to manually keep references to all the launched coroutines and &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/join.html&quot;&gt;join&lt;/a&gt; them is error-prone.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01079d64cb67e3f5b3eb1ab0a3228010e68dcdd0" translate="yes" xml:space="preserve">
          <source>There may be times when you need to quickly write and execute code outside of a project or application. This may be useful, for example, when learning Kotlin or evaluating expressions. Let's have a look at three handy ways we can use to run Kotlin code quickly:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98631247ce5d35bfa57c2de9453651ac4adc252b" translate="yes" xml:space="preserve">
          <source>There may be zero or more &lt;em&gt;catch&lt;/em&gt; blocks. &lt;em&gt;finally&lt;/em&gt; block may be omitted. However at least one &lt;em&gt;catch&lt;/em&gt; or &lt;em&gt;finally&lt;/em&gt; block should be present.</source>
          <target state="translated">可能有零个或多个&lt;em&gt;捕获&lt;/em&gt;块。&lt;em&gt;最终&lt;/em&gt;块可以省略。但是，至少应有一个&lt;em&gt;抓钩&lt;/em&gt;或&lt;em&gt;最后&lt;/em&gt;一个挡块。</target>
        </trans-unit>
        <trans-unit id="f116d6d19440fd947335171cc03cdab27f6adc4e" translate="yes" xml:space="preserve">
          <source>There will be a property named &lt;code&gt;hello&lt;/code&gt;:</source>
          <target state="translated">将有一个名为 &lt;code&gt;hello&lt;/code&gt; 的属性：</target>
        </trans-unit>
        <trans-unit id="def4b70b1b61bdf7178a471139f991f3029fb44c" translate="yes" xml:space="preserve">
          <source>There will only ever be one instance of this class, and the instance (which is created the first time it is accessed, in a thread-safe manner) has got the same name as the class:</source>
          <target state="translated">这个类永远只有一个实例,而且这个实例(在第一次访问时以线程安全的方式创建)的名字与这个类相同。</target>
        </trans-unit>
        <trans-unit id="6f9f7587a2e090ad5e29fbff32347947646d8531" translate="yes" xml:space="preserve">
          <source>There's a little bit of runtime overhead associated with lambda functions: they are really objects, so they must be instantiated, and (like other functions) calling them takes a little bit of time too. If we use the &lt;code&gt;inline&lt;/code&gt; keyword on a function, we tell the compiler to &lt;em&gt;inline&lt;/em&gt; both the function and its lambda parameters (if any) - that is, the compiler will copy the code of the function (and its lambda parameters) into &lt;em&gt;every&lt;/em&gt; callsite, thus eliminating the overhead of both the lambda instantiation and the calling of the function and the lambdas. This will happen unconditionally, unlike in C and C++, where &lt;code&gt;inline&lt;/code&gt; is more of a hint to the compiler. This will cause the size of the compiled code to grow, but it may be worth it for certain small but frequently-called functions.</source>
          <target state="translated">Lambda函数有一些运行时开销：它们实际上是对象，因此必须实例化它们，并且（与其他函数一样）调用它们也需要一点时间。如果我们在函数上使用 &lt;code&gt;inline&lt;/code&gt; 关键字，则会告诉编译器&lt;em&gt;内联&lt;/em&gt;函数和其lambda参数（如果有）-也就是说，编译器会将函数的代码（及其lambda参数）复制到&lt;em&gt;每个&lt;/em&gt;调用站点中，这样就消除了lambda实例化以及函数和lambda调用的开销。这将无条件发生，这与C和C ++中的 &lt;code&gt;inline&lt;/code&gt; 对编译器来说更多的是提示。这将导致已编译代码的大小增加，但是对于某些较小但经常调用的函数可能值得这样做。</target>
        </trans-unit>
        <trans-unit id="1db5770d8b83e30706aed362d9428bb0d8466fab" translate="yes" xml:space="preserve">
          <source>There's a vast collection of functional programming-style operations available in the &lt;a href=&quot;../../../api/latest/jvm/stdlib/kotlin.collections/index&quot;&gt;&lt;code&gt;kotlin.collections&lt;/code&gt; package&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../../../api/latest/jvm/stdlib/kotlin.collections/index&quot;&gt; &lt;code&gt;kotlin.collections&lt;/code&gt; 包中&lt;/a&gt;提供了大量功能编程风格的操作。</target>
        </trans-unit>
        <trans-unit id="202786b020b9056a1534a505736791f80248ba7e" translate="yes" xml:space="preserve">
          <source>There's no 64 bit integer number in JavaScript, so &lt;code&gt;kotlin.Long&lt;/code&gt; is not mapped to any JavaScript object, it's emulated by a Kotlin class.</source>
          <target state="translated">JavaScript中没有64位整数，因此 &lt;code&gt;kotlin.Long&lt;/code&gt; 不会映射到任何JavaScript对象，而是由Kotlin类模拟的。</target>
        </trans-unit>
        <trans-unit id="9178e1d163a2f07f63e80e90e8b72e40666cb6be" translate="yes" xml:space="preserve">
          <source>There's no such syntax in Kotlin. However, in Kotlin we have &lt;code&gt;companion&lt;/code&gt; objects. Kotlin treats companion objects of &lt;code&gt;external&lt;/code&gt; class in a special way: instead of expecting an object, it assumes members of companion objects to be members of the class itself. To describe &lt;code&gt;MyClass&lt;/code&gt; from the example above, you can write:</source>
          <target state="translated">Kotlin中没有这样的语法。但是，在Kotlin中，我们有 &lt;code&gt;companion&lt;/code&gt; 对象。Kotlin 以一种特殊的方式对待 &lt;code&gt;external&lt;/code&gt; 类的同伴对象：与其期望一个对象，不如假设一个同伴对象的成员是该类本身的成员。为了从上面的示例描述 &lt;code&gt;MyClass&lt;/code&gt; ，您可以编写：</target>
        </trans-unit>
        <trans-unit id="918d499d192390404b8163b61ae9ad18a046a4a8" translate="yes" xml:space="preserve">
          <source>There's two forms of using &lt;code&gt;definedExternally&lt;/code&gt;:</source>
          <target state="translated">有两种使用 &lt;code&gt;definedExternally&lt;/code&gt; 的形式：</target>
        </trans-unit>
        <trans-unit id="1d27760789bc7d15f7cae3944fffbd1ed1e60b2e" translate="yes" xml:space="preserve">
          <source>Therefore if the &lt;a href=&quot;write#kotlin.concurrent%24write%28java.util.concurrent.locks.ReentrantReadWriteLock%2C+kotlin.Function0%28%28kotlin.concurrent.write.T%29%29%29%2Faction&quot;&gt;action&lt;/a&gt; inside write lock has been initiated by checking some condition, the condition must be rechecked inside the &lt;a href=&quot;write#kotlin.concurrent%24write%28java.util.concurrent.locks.ReentrantReadWriteLock%2C+kotlin.Function0%28%28kotlin.concurrent.write.T%29%29%29%2Faction&quot;&gt;action&lt;/a&gt; to avoid possible races.</source>
          <target state="translated">因此，如果&lt;a href=&quot;write#kotlin.concurrent%24write%28java.util.concurrent.locks.ReentrantReadWriteLock%2C+kotlin.Function0%28%28kotlin.concurrent.write.T%29%29%29%2Faction&quot;&gt;动作&lt;/a&gt;写锁内已通过检查一些条件启动，条件必须在内部重新检查&lt;a href=&quot;write#kotlin.concurrent%24write%28java.util.concurrent.locks.ReentrantReadWriteLock%2C+kotlin.Function0%28%28kotlin.concurrent.write.T%29%29%29%2Faction&quot;&gt;行动&lt;/a&gt;，以避免可能的比赛。</target>
        </trans-unit>
        <trans-unit id="e58964a321357f25142def10569f3d0cf1f1691d" translate="yes" xml:space="preserve">
          <source>Therefore if the &lt;a href=&quot;write#kotlin.concurrent%24write(java.util.concurrent.locks.ReentrantReadWriteLock,%20kotlin.Function0((kotlin.concurrent.write.T)))/action&quot;&gt;action&lt;/a&gt; inside write lock has been initiated by checking some condition, the condition must be rechecked inside the &lt;a href=&quot;write#kotlin.concurrent%24write(java.util.concurrent.locks.ReentrantReadWriteLock,%20kotlin.Function0((kotlin.concurrent.write.T)))/action&quot;&gt;action&lt;/a&gt; to avoid possible races.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f17bb5adc41c5c7eefa8d167c2c05552954588a" translate="yes" xml:space="preserve">
          <source>Therefore, the two following snippets are equivalent:</source>
          <target state="translated">因此,以下两个片段是等价的。</target>
        </trans-unit>
        <trans-unit id="b2fcfe97b28b6d55545bf13f39eacf58d2cbb997" translate="yes" xml:space="preserve">
          <source>Therefore, there is no general way to check whether an instance of a generic type was created with certain type arguments at runtime, and the compiler &lt;a href=&quot;typecasts#type-erasure-and-generic-type-checks&quot;&gt;prohibits such &lt;em&gt;is&lt;/em&gt;-checks&lt;/a&gt;.</source>
          <target state="translated">因此，没有通用的方法来检查在运行时是否使用某些类型参数创建了泛型类型的实例，并且编译器&lt;a href=&quot;typecasts#type-erasure-and-generic-type-checks&quot;&gt;禁止使用&lt;em&gt;is&lt;/em&gt; -checks&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ba4578c0908f499a877e6e75a3e1e8fb6ca14fec" translate="yes" xml:space="preserve">
          <source>These &lt;a href=&quot;typecasts#unchecked-casts&quot;&gt;unchecked casts&lt;/a&gt; can be used when type safety is implied by the high-level program logic but cannot be inferred directly by the compiler. The compiler issues a warning on unchecked casts, and at runtime, only the non-generic part is checked (equivalent to &lt;code&gt;foo as List&amp;lt;*&amp;gt;&lt;/code&gt;).</source>
          <target state="translated">当高级程序逻辑隐含类型安全性但编译器无法直接推断出类型安全性时，可以使用这些&lt;a href=&quot;typecasts#unchecked-casts&quot;&gt;未经检查的强制转换&lt;/a&gt;。编译器会在未检查的强制转换上发出警告，并且在运行时仅检查非通用部分（相当于 &lt;code&gt;foo as List&amp;lt;*&amp;gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="dd3d3ea77431105543bdd1015eeb929086add1c8" translate="yes" xml:space="preserve">
          <source>These abstract classes can be used as base classes when implementing Kotlin collection classes. For implementing read-only collections there are &lt;code&gt;AbstractCollection&lt;/code&gt;, &lt;code&gt;AbstractList&lt;/code&gt;, &lt;code&gt;AbstractSet&lt;/code&gt; and &lt;code&gt;AbstractMap&lt;/code&gt;, and for mutable collections there are &lt;code&gt;AbstractMutableCollection&lt;/code&gt;, &lt;code&gt;AbstractMutableList&lt;/code&gt;, &lt;code&gt;AbstractMutableSet&lt;/code&gt; and &lt;code&gt;AbstractMutableMap&lt;/code&gt;. On JVM these abstract mutable collections inherit most of their functionality from JDK's abstract collections.</source>
          <target state="translated">在实现Kotlin集合类时，可以将这些抽象类用作基类。为了实现只读集合，有 &lt;code&gt;AbstractCollection&lt;/code&gt; ， &lt;code&gt;AbstractList&lt;/code&gt; ， &lt;code&gt;AbstractSet&lt;/code&gt; 和 &lt;code&gt;AbstractMap&lt;/code&gt; ；对于可变集合，有 &lt;code&gt;AbstractMutableCollection&lt;/code&gt; ， &lt;code&gt;AbstractMutableList&lt;/code&gt; ， &lt;code&gt;AbstractMutableSet&lt;/code&gt; 和 &lt;code&gt;AbstractMutableMap&lt;/code&gt; 。在JVM上，这些抽象可变集合从JDK的抽象集合继承了大多数功能。</target>
        </trans-unit>
        <trans-unit id="aae55c4083a74f1ac27e26d5124083a7a6b3b4cb" translate="yes" xml:space="preserve">
          <source>These are the &lt;a href=&quot;#default-project-layout&quot;&gt;default source set names&lt;/a&gt; for the production and test sources for the targets configured above. The source sets &lt;code&gt;commonMain&lt;/code&gt; and &lt;code&gt;commonTest&lt;/code&gt; are included into production and test compilations, respectively, of all targets. Note that the dependencies for common source sets &lt;code&gt;commonMain&lt;/code&gt; and &lt;code&gt;commonTest&lt;/code&gt; are the common artifacts, and the platform libraries go to the source sets of the specific targets.</source>
          <target state="translated">这些是上面配置的目标的生产和测试源的&lt;a href=&quot;#default-project-layout&quot;&gt;默认源集名称&lt;/a&gt;。源集 &lt;code&gt;commonMain&lt;/code&gt; 和 &lt;code&gt;commonTest&lt;/code&gt; 分别包含在所有目标的生产和测试编译中。请注意，公共源集 &lt;code&gt;commonMain&lt;/code&gt; 和 &lt;code&gt;commonTest&lt;/code&gt; 的依赖项是公共工件，平台库转到特定目标的源集。</target>
        </trans-unit>
        <trans-unit id="6c67dd2d501b6f7860e7b47d523d2ae61bab43e4" translate="yes" xml:space="preserve">
          <source>These are three general-purpose extension functions applicable to any receiver.</source>
          <target state="translated">这是三个适用于任何接收器的通用扩展功能。</target>
        </trans-unit>
        <trans-unit id="4a99a063b2c797ffc59fde5538599b9e6760c083" translate="yes" xml:space="preserve">
          <source>These considerations lead to the following rules. A covariant type parameter &lt;code&gt;T&lt;/code&gt; (which the user of an object might think is &lt;code&gt;Fruit&lt;/code&gt;, while the object in reality is tied to &lt;code&gt;Apple&lt;/code&gt;) may be used as:</source>
          <target state="translated">这些考虑导致以下规则。协变类型参数 &lt;code&gt;T&lt;/code&gt; （对象的用户可能认为它是 &lt;code&gt;Fruit&lt;/code&gt; ，而实际上该对象与 &lt;code&gt;Apple&lt;/code&gt; 绑定）可以用作：</target>
        </trans-unit>
        <trans-unit id="e8a12f370f83960d4f7413fab1b904c1e1f23ab2" translate="yes" xml:space="preserve">
          <source>These declarations look clear. All &lt;code&gt;char *&lt;/code&gt; pointers are turned into &lt;code&gt;str: CValuesRef&amp;lt;ByteVar&amp;gt;?&lt;/code&gt; for parameters and to &lt;code&gt;CPointer&amp;lt;ByteVar&amp;gt;?&lt;/code&gt; in return types. Kotlin turns &lt;code&gt;char&lt;/code&gt; type into &lt;code&gt;kotlin.Byte&lt;/code&gt; type, as it is usually an 8-bit signed value.</source>
          <target state="translated">这些声明看起来很清楚。所有 &lt;code&gt;char *&lt;/code&gt; 指针都转换为 &lt;code&gt;str: CValuesRef&amp;lt;ByteVar&amp;gt;?&lt;/code&gt; 参数和 &lt;code&gt;CPointer&amp;lt;ByteVar&amp;gt;?&lt;/code&gt; 返回类型。Kotlin将 &lt;code&gt;char&lt;/code&gt; 类型转换为 &lt;code&gt;kotlin.Byte&lt;/code&gt; 类型，因为它通常是一个8位带符号的值。</target>
        </trans-unit>
        <trans-unit id="53e4257de1ac9420719572d5eaf311fafd22b5c2" translate="yes" xml:space="preserve">
          <source>These features are not considered production ready yet, so you need to turn on the &lt;em&gt;experimental mode&lt;/em&gt; in &lt;code&gt;build.gradle&lt;/code&gt; in order to use them:</source>
          <target state="translated">这些功能尚未被考虑用于生产环境，因此您需要在 &lt;code&gt;build.gradle&lt;/code&gt; 中打开&lt;em&gt;实验模式&lt;/em&gt;才能使用它们：</target>
        </trans-unit>
        <trans-unit id="e6b05d8f5b89932c0c2ddc8328889d3567a05266" translate="yes" xml:space="preserve">
          <source>These functions can also be used for converting collections to other types, for example, build a set from a list or vice versa.</source>
          <target state="translated">这些函数也可以用于将集合转换为其他类型,例如,从列表中建立一个集合或反之。</target>
        </trans-unit>
        <trans-unit id="d5e9c8cae28543e16ef49eb2054cfc4937ef3fcf" translate="yes" xml:space="preserve">
          <source>These functions can be used for easy copying of maps:</source>
          <target state="translated">这些功能可以用来方便复制地图。</target>
        </trans-unit>
        <trans-unit id="2a7f12885b59bbc14ccabadd6389a34cf6ff8eb2" translate="yes" xml:space="preserve">
          <source>These functions can be used to find the lowest and greatest of two or three given values, where values are primitive numbers or &lt;code&gt;Comparable&lt;/code&gt; objects. There is also an overload of each function that take an additional &lt;code&gt;Comparator&lt;/code&gt; instance, if you want to compare objects that are not comparable themselves.</source>
          <target state="translated">这些函数可用于查找两个或三个给定值中的最小和最大值，其中值是原始数或 &lt;code&gt;Comparable&lt;/code&gt; 对象。如果您要比较本身不具有可比性的对象，则每个函数还有一个额外的 &lt;code&gt;Comparator&lt;/code&gt; 实例会重载。</target>
        </trans-unit>
        <trans-unit id="8f7f5c9e85694705edbe3da3b621cafe8f2795f3" translate="yes" xml:space="preserve">
          <source>These functions deal with Kotlin/Native objects. Call the &lt;code&gt;DisposeStablePointer&lt;/code&gt; to release a Kotlin object and &lt;code&gt;DisposeString&lt;/code&gt; to release a Kotlin String, which has the &lt;code&gt;char*&lt;/code&gt; type in C. It is possible to use the &lt;code&gt;IsInstance&lt;/code&gt; function to check if a Kotlin type or a &lt;code&gt;libnative_KNativePtr&lt;/code&gt; is an instance of another type. The actual set of operations generated depends on the actual usages.</source>
          <target state="translated">这些功能处理Kotlin / Native对象。调用 &lt;code&gt;DisposeStablePointer&lt;/code&gt; 释放科特林对象和 &lt;code&gt;DisposeString&lt;/code&gt; 释放科特林字符串，其具有 &lt;code&gt;char*&lt;/code&gt; 类型C.它是能够使用 &lt;code&gt;IsInstance&lt;/code&gt; 函数来检查科特林型或 &lt;code&gt;libnative_KNativePtr&lt;/code&gt; 是另一种类型的一个实例。生成的实际操作集取决于实际用法。</target>
        </trans-unit>
        <trans-unit id="ebcfd0ed6c7e90830065d9ee1e014161378d5e50" translate="yes" xml:space="preserve">
          <source>These include &lt;a href=&quot;reflection#bound-function-and-property-references-since-11&quot;&gt;bound callable references&lt;/a&gt; that point to a member of a particular instance: &lt;code&gt;foo::toString&lt;/code&gt;.</source>
          <target state="translated">这些包括指向特定实例成员的&lt;a href=&quot;reflection#bound-function-and-property-references-since-11&quot;&gt;绑定可调用引用&lt;/a&gt;： &lt;code&gt;foo::toString&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="341a2ef673574a4668acee83662de92778d835b1" translate="yes" xml:space="preserve">
          <source>These operators only work with the function &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin/-any/equals&quot;&gt;&lt;code&gt;equals(other: Any?): Boolean&lt;/code&gt;&lt;/a&gt;, which can be overridden to provide custom equality check implementation. Any other function with the same name (like &lt;code&gt;equals(other: Foo)&lt;/code&gt;) will not be called.</source>
          <target state="translated">这些运算符仅与&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin/-any/equals&quot;&gt; &lt;code&gt;equals(other: Any?): Boolean&lt;/code&gt; &lt;/a&gt;函数一起使用，可以重写以提供自定义相等性检查实现。具有相同名称的任何其他函数（例如 &lt;code&gt;equals(other: Foo)&lt;/code&gt; ）都不会被调用。</target>
        </trans-unit>
        <trans-unit id="04c64c9fdc4ddbb026d14664db7dfcf575773eab" translate="yes" xml:space="preserve">
          <source>These options have nearly the same effect as clang's &lt;code&gt;-fembed-bitcode&lt;/code&gt;/&lt;code&gt;-fembed-bitcode-marker&lt;/code&gt; and swiftc's &lt;code&gt;-embed-bitcode&lt;/code&gt;/&lt;code&gt;-embed-bitcode-marker&lt;/code&gt;.</source>
          <target state="translated">这些选项与clang的 &lt;code&gt;-fembed-bitcode&lt;/code&gt; / &lt;code&gt;-fembed-bitcode-marker&lt;/code&gt; 和swiftc的 &lt;code&gt;-embed-bitcode&lt;/code&gt; / &lt;code&gt;-embed-bitcode-marker&lt;/code&gt; 具有几乎相同的效果。</target>
        </trans-unit>
        <trans-unit id="42a0b78cb4e25be9e1f6ef7cf3d39eb3e781050e" translate="yes" xml:space="preserve">
          <source>These tasks are defined in the &lt;em&gt;kotlin-ant.jar&lt;/em&gt; library which is located in the &lt;em&gt;lib&lt;/em&gt; folder for the &lt;a href=&quot;https://github.com/JetBrains/kotlin/releases/tag/v1.3.41&quot;&gt;Kotlin Compiler&lt;/a&gt; Ant version 1.8.2+ is required.</source>
          <target state="translated">这些任务在&lt;em&gt;kotlin-ant.jar&lt;/em&gt;库中定义，该库位于&lt;a href=&quot;https://github.com/JetBrains/kotlin/releases/tag/v1.3.41&quot;&gt;Kotlin Compiler&lt;/a&gt; Ant版本1.8.2+ 的&lt;em&gt;lib&lt;/em&gt;文件夹中。</target>
        </trans-unit>
        <trans-unit id="35fb8f738b23790388f177e5975164208ed39249" translate="yes" xml:space="preserve">
          <source>These tasks are defined in the &lt;em&gt;kotlin-ant.jar&lt;/em&gt; library which is located in the &lt;em&gt;lib&lt;/em&gt; folder for the &lt;a href=&quot;https://github.com/JetBrains/kotlin/releases/tag/v1.4.10&quot;&gt;Kotlin Compiler&lt;/a&gt; Ant version 1.8.2+ is required.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d0ae43a71338a23e33d7f8aec6b35c87860e63a" translate="yes" xml:space="preserve">
          <source>These transformations can also be applied to &lt;code&gt;Sequence&amp;lt;T&amp;gt;&lt;/code&gt;, which is similar to Python's generators and allows for lazy evaluation. If you have a huge list and you want to process it lazily, you can call &lt;code&gt;asSequence()&lt;/code&gt; on it.</source>
          <target state="translated">这些转换也可以应用于 &lt;code&gt;Sequence&amp;lt;T&amp;gt;&lt;/code&gt; ，它类似于Python的生成器，并允许进行惰性求值。如果您有一个庞大的列表，并且想要懒惰地处理它，则可以在其上调用 &lt;code&gt;asSequence()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="03f364964cb20dc479a4f5003a2a44d235abdb7a" translate="yes" xml:space="preserve">
          <source>These two functions can not be defined side-by-side, because their JVM signatures are the same: &lt;code&gt;filterValid(Ljava/util/List;)Ljava/util/List;&lt;/code&gt;. If we really want them to have the same name in Kotlin, we can annotate one (or both) of them with &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.jvm/-jvm-name/index&quot;&gt;&lt;code&gt;@JvmName&lt;/code&gt;&lt;/a&gt; and specify a different name as an argument:</source>
          <target state="translated">这两个函数不能并排定义，因为它们的JVM签名是相同的： &lt;code&gt;filterValid(Ljava/util/List;)Ljava/util/List;&lt;/code&gt; 。如果我们确实希望它们在Kotlin中具有相同的名称，则可以使用&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.jvm/-jvm-name/index&quot;&gt; &lt;code&gt;@JvmName&lt;/code&gt; &lt;/a&gt;注释其中一个（或两个），并指定其他名称作为参数：</target>
        </trans-unit>
        <trans-unit id="921fb3d0fcc9e0673ab266d259447beb1dbfed2e" translate="yes" xml:space="preserve">
          <source>These two options let you choose the proper function depending on what you do next in your code.</source>
          <target state="translated">这两个选项可以让你根据你接下来在代码中的操作选择合适的函数。</target>
        </trans-unit>
        <trans-unit id="5dbdf5173288dba5a705ae6e593e7cbdf4691ea2" translate="yes" xml:space="preserve">
          <source>These types are used to map boxed Kotlin number types into Objective-C and Swift. In Swift, we may simply call the constructor to create an instance, e.g. &lt;code&gt;KotlinLong(value: 42)&lt;/code&gt;.</source>
          <target state="translated">这些类型用于将装箱的Kotlin数字类型映射到Objective-C和Swift。在Swift中，我们可以简单地调用构造函数来创建一个实例，例如 &lt;code&gt;KotlinLong(value: 42)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c780ae4d91e6b3d59d657bd21738eface7e6d706" translate="yes" xml:space="preserve">
          <source>These types have a special notation that corresponds to the signatures of the functions, i.e. their parameters and return values:</source>
          <target state="translated">这些类型有一个特殊的符号,对应于函数的签名,即它们的参数和返回值。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
