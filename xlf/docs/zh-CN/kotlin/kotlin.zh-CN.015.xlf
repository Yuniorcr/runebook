<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="kotlin">
    <body>
      <group id="kotlin">
        <trans-unit id="23d6510bb7782c43d563dd375dee713e5d305e0b" translate="yes" xml:space="preserve">
          <source>If you need a &lt;em&gt;singleton&lt;/em&gt; - a class that only has got one instance - you can declare the class in the usual way, but use the &lt;code&gt;object&lt;/code&gt; keyword instead of &lt;code&gt;class&lt;/code&gt;:</source>
          <target state="translated">如果您需要一个&lt;em&gt;单例&lt;/em&gt;（一个只有一个实例的类），则可以按照通常的方式声明该类，但可以使用 &lt;code&gt;object&lt;/code&gt; 关键字而不是 &lt;code&gt;class&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="fc8467398b87bfa40771e50f53a8a177a25657b1" translate="yes" xml:space="preserve">
          <source>If you need a fancier way of reading or writing file data, you have access to the full Java suite of I/O classes - in particular, &lt;code&gt;Scanner&lt;/code&gt;, which can parse numbers and other data types from files or other streams, and &lt;code&gt;BufferedReader&lt;/code&gt; (which is good for efficient reading of large amounts of data), which you can obtain by calling &lt;code&gt;bufferedReader()&lt;/code&gt; on a file or stream. See any Java tutorial for how to use these.</source>
          <target state="translated">如果您需要一种更简单的读取或写入文件数据的方式，则可以访问完整的Java I / O类套件-特别是 &lt;code&gt;Scanner&lt;/code&gt; ，它可以解析文件或其他流中的数字和其他数据类型，以及 &lt;code&gt;BufferedReader&lt;/code&gt; （可以有效地读取大量数据），您可以通过在文件或流上调用 &lt;code&gt;bufferedReader()&lt;/code&gt; 获得该数据。请参阅任何Java教程以了解如何使用它们。</target>
        </trans-unit>
        <trans-unit id="54e87845252769ababaaab1c06f5bd872659abd6" translate="yes" xml:space="preserve">
          <source>If you need a function or a property to be tied to a class rather than to instances of it (similar to &lt;code&gt;@staticmethod&lt;/code&gt; in Python), you can declare it inside a &lt;em&gt;companion object&lt;/em&gt;:</source>
          <target state="translated">如果需要将函数或属性绑定到类而不是实例（类似于Python中的 &lt;code&gt;@staticmethod&lt;/code&gt; ），则可以在&lt;em&gt;同伴对象中&lt;/em&gt;声明它：</target>
        </trans-unit>
        <trans-unit id="8de1431e2a233483ba705c03102c9221f4f2f632" translate="yes" xml:space="preserve">
          <source>If you need multiple ways to initialize a class, you can create &lt;em&gt;secondary constructors&lt;/em&gt;, each of which looks like a function whose name is &lt;code&gt;constructor&lt;/code&gt;. Every secondary constructor must invoke another (primary or secondary) constructor by using the &lt;code&gt;this&lt;/code&gt; keyword as if it were a function (so that every instance construction eventually calls the primary constructor).</source>
          <target state="translated">如果您需要多种方法来初始化类，则可以创建&lt;em&gt;辅助构造函数&lt;/em&gt;，每个&lt;em&gt;构造&lt;/em&gt;函数看起来都像一个函数，名称为 &lt;code&gt;constructor&lt;/code&gt; 。每个辅助构造函数都必须使用 &lt;code&gt;this&lt;/code&gt; 关键字调用另一个（主要或辅助）构造函数，就好像它是一个函数一样（这样，每个实例构造最终都会调用该主要构造函数）。</target>
        </trans-unit>
        <trans-unit id="e23221640befe2f0b60d6c58ea9b02d7e3a97b07" translate="yes" xml:space="preserve">
          <source>If you need to access a class implemented in JavaScript from Kotlin in a typesafe way, you can write a Kotlin declaration using the &lt;code&gt;external&lt;/code&gt; modifier. (In Kotlin 1.0, the &lt;code&gt;@native&lt;/code&gt; annotation was used instead.) Unlike the JVM target, the JS one permits to use external modifier with classes and properties. For example, here's how you can declare the DOM &lt;code&gt;Node&lt;/code&gt; class:</source>
          <target state="translated">如果您需要以类型安全的方式从Kotlin访问用JavaScript实现的类，则可以使用 &lt;code&gt;external&lt;/code&gt; 修饰符编写Kotlin声明。（在Kotlin 1.0中，使用 &lt;code&gt;@native&lt;/code&gt; 注释代替。）与JVM目标不同，JS允许使用带有类和属性的外部修饰符。例如，下面是如何声明DOM &lt;code&gt;Node&lt;/code&gt; 类的方法：</target>
        </trans-unit>
        <trans-unit id="f99443af480d55217c4ce0d28159d54e4f7cf72b" translate="yes" xml:space="preserve">
          <source>If you need to access platform-specific APIs from the shared code, use the Kotlin mechanism of &lt;a href=&quot;mpp-connect-to-apis&quot;&gt;expected and actual declarations&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4e8082dbfdacd1170b034e190a7f81841b9039b" translate="yes" xml:space="preserve">
          <source>If you need to annotate the primary constructor of a class, you need to add the &lt;em&gt;constructor&lt;/em&gt; keyword to the constructor declaration, and add the annotations before it:</source>
          <target state="translated">如果需要对类的主要构造函数进行注释，则需要将&lt;em&gt;Constructor&lt;/em&gt;关键字添加到&lt;em&gt;构造&lt;/em&gt;函数声明中，并在其之前添加注释：</target>
        </trans-unit>
        <trans-unit id="e462275c07255513e75672de08e598bdce5e271f" translate="yes" xml:space="preserve">
          <source>If you need to change the visibility of an accessor or to annotate it, but don't need to change the default implementation, you can define the accessor without defining its body:</source>
          <target state="translated">如果你需要改变一个访问器的可见性或注释它,但不需要改变默认的实现,你可以定义访问器而不定义它的主体。</target>
        </trans-unit>
        <trans-unit id="4613a8244834c0ecb89ce0d825ca742a6fa51707" translate="yes" xml:space="preserve">
          <source>If you need to expose a Kotlin property as a field in Java, annotate it with the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.jvm/-jvm-field/index&quot;&gt;&lt;code&gt;@JvmField&lt;/code&gt;&lt;/a&gt; annotation. The field will have the same visibility as the underlying property. You can annotate a property with &lt;code&gt;@JvmField&lt;/code&gt; if it has a backing field, is not private, does not have &lt;code&gt;open&lt;/code&gt;, &lt;code&gt;override&lt;/code&gt; or &lt;code&gt;const&lt;/code&gt; modifiers, and is not a delegated property.</source>
          <target state="translated">如果您需要将Kotlin属性公开为Java中的字段，请使用&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.jvm/-jvm-field/index&quot;&gt; &lt;code&gt;@JvmField&lt;/code&gt; &lt;/a&gt;注释对其进行注释。该字段将具有与基础属性相同的可见性。如果属性具有后备字段，不是私有属性，没有 &lt;code&gt;open&lt;/code&gt; ， &lt;code&gt;override&lt;/code&gt; 或 &lt;code&gt;const&lt;/code&gt; 修饰符且不是委派属性，则可以使用 &lt;code&gt;@JvmField&lt;/code&gt; 对其进行注释。</target>
        </trans-unit>
        <trans-unit id="b3648463615f31d33dec14dff446661a5d42afc8" translate="yes" xml:space="preserve">
          <source>If you need to know the index of the current element when you're iterating over something, you can use &lt;code&gt;withIndex()&lt;/code&gt;, which corresponds to &lt;code&gt;enumerate()&lt;/code&gt;. It produces a sequence of objects that have got two properties (the index and the value) and two specially-named accessor functions called &lt;code&gt;component1()&lt;/code&gt; and &lt;code&gt;component2()&lt;/code&gt;; Kotlin lets you destructure such an object into a declaration:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89e90e48358e19dcdf7d70c38acd3455ecae2039" translate="yes" xml:space="preserve">
          <source>If you need to know the index of the current element when you're iterating through something, you can use &lt;code&gt;withIndex()&lt;/code&gt;, which corresponds to &lt;code&gt;enumerate()&lt;/code&gt;. It produces a sequence of objects that have got two properties (the index and the value) and two specially-named accessor functions called &lt;code&gt;component1()&lt;/code&gt; and &lt;code&gt;component2()&lt;/code&gt;; Kotlin lets you destructure such an object into a declaration:</source>
          <target state="translated">如果您需要在迭代过程中了解当前元素的索引，则可以使用 &lt;code&gt;withIndex()&lt;/code&gt; ，它对应于 &lt;code&gt;enumerate()&lt;/code&gt; 。它产生一系列具有两个属性（索引和值）以及两个特殊命名的访问器函数的对象序列，分别称为 &lt;code&gt;component1()&lt;/code&gt; 和 &lt;code&gt;component2()&lt;/code&gt; ；Kotlin让您将这样的对象分解为声明：</target>
        </trans-unit>
        <trans-unit id="4c304182ad4dffb827b2cd5041835d4a1290ba5c" translate="yes" xml:space="preserve">
          <source>If you need to look up the class dynamically as well, you can use &lt;code&gt;Class.forName()&lt;/code&gt; and supply the fully-qualified name of the class.</source>
          <target state="translated">如果还需要动态查找该类，则可以使用 &lt;code&gt;Class.forName()&lt;/code&gt; 并提供该类的完全限定名称。</target>
        </trans-unit>
        <trans-unit id="fb05e76a6c128f62bf211b270ee1f300cbc3d9aa" translate="yes" xml:space="preserve">
          <source>If you need to retrieve an arbitrary element of a collection, call the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/random&quot;&gt;&lt;code&gt;random()&lt;/code&gt;&lt;/a&gt; function. You can call it without arguments or with a &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.random/-random/index&quot;&gt;&lt;code&gt;Random&lt;/code&gt;&lt;/a&gt; object as a source of the randomness.</source>
          <target state="translated">如果需要检索集合的任意元素，请调用&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/random&quot;&gt; &lt;code&gt;random()&lt;/code&gt; &lt;/a&gt;函数。您可以不带参数或使用&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.random/-random/index&quot;&gt; &lt;code&gt;Random&lt;/code&gt; &lt;/a&gt;对象作为随机性的源来调用它。</target>
        </trans-unit>
        <trans-unit id="2c6c6ff6a76abad65e2d1d67dae2bda5a0418cb0" translate="yes" xml:space="preserve">
          <source>If you need to retrieve the collection content in a readable format, use functions that transform the collections to strings: &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/join-to-string&quot;&gt;&lt;code&gt;joinToString()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/join-to&quot;&gt;&lt;code&gt;joinTo()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果您需要以可读格式检索集合内容，请使用将集合转换为字符串的函数：&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/join-to-string&quot;&gt; &lt;code&gt;joinToString()&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/join-to&quot;&gt; &lt;code&gt;joinTo()&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="27633af274eff8d8c59fb2e4a25231c59018307c" translate="yes" xml:space="preserve">
          <source>If you need to specify a class as an argument of an annotation, use a Kotlin class (&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.reflect/-k-class/index&quot;&gt;KClass&lt;/a&gt;). The Kotlin compiler will automatically convert it to a Java class, so that the Java code can access the annotations and arguments normally.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="993106f4a5b27e1d574e1151066452d4ad416447" translate="yes" xml:space="preserve">
          <source>If you need to specify a class as an argument of an annotation, use a Kotlin class (&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.reflect/-k-class/index&quot;&gt;KClass&lt;/a&gt;). The Kotlin compiler will automatically convert it to a Java class, so that the Java code will be able to see the annotations and arguments normally.</source>
          <target state="translated">如果需要将类指定为注释的参数，请使用Kotlin类（&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.reflect/-k-class/index&quot;&gt;KClass&lt;/a&gt;）。Kotlin编译器会自动将其转换为Java类，以便Java代码将能够正常查看注释和参数。</target>
        </trans-unit>
        <trans-unit id="7448bb25e266494ddde684c5929327a96a8fb964" translate="yes" xml:space="preserve">
          <source>If you need to use a nullable &lt;code&gt;Boolean&lt;/code&gt; in a conditional statement, use &lt;code&gt;if (value == true)&lt;/code&gt; or &lt;code&gt;if (value == false)&lt;/code&gt; checks.</source>
          <target state="translated">如果需要在条件语句中使用可为空的 &lt;code&gt;Boolean&lt;/code&gt; ，请使用 &lt;code&gt;if (value == true)&lt;/code&gt; 或 &lt;code&gt;if (value == false)&lt;/code&gt; 检查。</target>
        </trans-unit>
        <trans-unit id="2c201a6c8803ec9d0564e44a48fc6ef8489585c2" translate="yes" xml:space="preserve">
          <source>If you need to write a function that can be called without having a class instance but needs access to the internals of a class (for example, a factory method), you can write it as a member of an &lt;a href=&quot;object-declarations&quot;&gt;object declaration&lt;/a&gt; inside that class.</source>
          <target state="translated">如果您需要编写一个可以在没有类实例的情况下调用但又需要访问类内部的函数（例如，工厂方法），则可以将该函数编写为该类内部&lt;a href=&quot;object-declarations&quot;&gt;对象声明&lt;/a&gt;的成员。</target>
        </trans-unit>
        <trans-unit id="5f584df433485780683ca571ae5a89e659948c6b" translate="yes" xml:space="preserve">
          <source>If you only want to call the function and don't care about the metadata, use a function type, e.g. &lt;code&gt;(A, B) -&amp;gt; V&lt;/code&gt; for an ordinary function reference or a bound member function reference, or &lt;code&gt;A.(B, C) -&amp;gt; V&lt;/code&gt; for an unbound member function reference on &lt;code&gt;A&lt;/code&gt;. Note that &lt;code&gt;KFunction&amp;lt;V&amp;gt;&lt;/code&gt; and its subinterfaces are only available for declared functions (obtained either by explicitly referencing it in the code, or through reflection, as shown later) - only function types are available for function literals (lambda expressions or anonymous functions).</source>
          <target state="translated">如果只想调用函数而不关心元数据，请使用函数类型，例如 &lt;code&gt;(A, B) -&amp;gt; V&lt;/code&gt; 作为普通函数引用或绑定成员函数引用，或者使用 &lt;code&gt;A.(B, C) -&amp;gt; V&lt;/code&gt; 表示 &lt;code&gt;A&lt;/code&gt; 上的未绑定成员函数引用。请注意， &lt;code&gt;KFunction&amp;lt;V&amp;gt;&lt;/code&gt; 及其子接口仅可用于已声明的函数（通过在代码中显式引用它或通过反射来获得，如稍后所示）-仅函数类型可用于函数文字（lambda表达式或匿名函数） 。</target>
        </trans-unit>
        <trans-unit id="8014e84399844604d4127e5bfb102e3054b9b7f6" translate="yes" xml:space="preserve">
          <source>If you operate nested collections, you may find the standard library functions that provide flat access to nested collection elements useful.</source>
          <target state="translated">如果你操作嵌套的集合,你可能会发现提供对嵌套集合元素的平面访问的标准库函数很有用。</target>
        </trans-unit>
        <trans-unit id="aa8d397c2c2050d55c50d82eec1a501b49617481" translate="yes" xml:space="preserve">
          <source>If you override a &lt;code&gt;protected&lt;/code&gt; member and do not specify the visibility explicitly, the overriding member will also have &lt;code&gt;protected&lt;/code&gt; visibility.</source>
          <target state="translated">如果您覆盖 &lt;code&gt;protected&lt;/code&gt; 成员并且未明确指定可见性，则该覆盖的成员还将具有 &lt;code&gt;protected&lt;/code&gt; 可见性。</target>
        </trans-unit>
        <trans-unit id="bd8f947a24ab8c99f576a413b868a14fd70348dc" translate="yes" xml:space="preserve">
          <source>If you previously used the &lt;a href=&quot;https://developer.android.com/studio/build/gradle-plugin-3-0-0-migration.html#annotationProcessor_config&quot;&gt;Android support&lt;/a&gt; for annotation processors, replace usages of the &lt;code&gt;annotationProcessor&lt;/code&gt; configuration with &lt;code&gt;kapt&lt;/code&gt;. If your project contains Java classes, &lt;code&gt;kapt&lt;/code&gt; will also take care of them.</source>
          <target state="translated">如果您以前使用&lt;a href=&quot;https://developer.android.com/studio/build/gradle-plugin-3-0-0-migration.html#annotationProcessor_config&quot;&gt;的Android支持&lt;/a&gt;标注处理，更换的用法 &lt;code&gt;annotationProcessor&lt;/code&gt; 与配置 &lt;code&gt;kapt&lt;/code&gt; 。如果您的项目包含Java类，则 &lt;code&gt;kapt&lt;/code&gt; 还将处理它们。</target>
        </trans-unit>
        <trans-unit id="3126f475d393c0188e7088d866ab3c517a722979" translate="yes" xml:space="preserve">
          <source>If you publish several features in the experimental state, declare a marker for each. Separate markers make the use of experimental features safer for your clients: they'll be able to use only the features that they explicitly accept. This also lets you graduate the features to stable independently.</source>
          <target state="translated">如果您在实验状态下发布了多个功能,请为每个功能声明一个标记。单独的标记可以让你的客户更安全地使用实验性功能:他们将只能使用他们明确接受的功能。这也让你可以独立地将功能升级到稳定状态。</target>
        </trans-unit>
        <trans-unit id="df8a586d7260c254feebf62ecf6abe57e497a3fe" translate="yes" xml:space="preserve">
          <source>If you really really need a mixed-type collection, you can use the element type &lt;code&gt;Any&lt;/code&gt; - but you'll need typecasting to get the elements back to their proper type again, so if what you want is a multiple-value return from a function, please use the per-element-typed &lt;code&gt;Pair&lt;/code&gt; or &lt;code&gt;Triple&lt;/code&gt; instead. If you need four or more elements, consider making a &lt;a href=&quot;classes#data-classes&quot;&gt;data class&lt;/a&gt; for the return type instead (which you should ideally do for two or three elements as well, especially if it's a public function, since it gives you proper names for the elements) - it's very easy and usually a oneliner.</source>
          <target state="translated">如果您确实确实需要混合类型集合，则可以使用元素类型 &lt;code&gt;Any&lt;/code&gt; ，但是您需要进行类型转换以使元素再次返回其正确类型，因此，如果要的是从函数返回多值，请改用按元素类型输入的 &lt;code&gt;Pair&lt;/code&gt; 或 &lt;code&gt;Triple&lt;/code&gt; 。如果您需要四个或更多元素，请考虑为返回类型创建一个&lt;a href=&quot;classes#data-classes&quot;&gt;数据类&lt;/a&gt;（理想情况下，您也应该对两个或三个元素进行此处理，尤其是在使用public函数的情况下，因为它会为元素提供正确的名称）-这很简单，通常是一个单线。</target>
        </trans-unit>
        <trans-unit id="cbc8324a9f6502600707b1d372c5b0e01758d5e6" translate="yes" xml:space="preserve">
          <source>If you really want to, you can both initialize and specify the type on the same line. This is mostly useful if you're dealing with a class hierarchy (more on that later) and you want the variable type to be a base type of the value's class:</source>
          <target state="translated">如果你真的想这样做,你可以在同一行中同时初始化和指定类型。如果你正在处理一个类的层次结构(稍后会有更多的介绍),并且你希望变量类型是值的类的基础类型,那么这就很有用。</target>
        </trans-unit>
        <trans-unit id="13648197906f478e28c0bcf3383cb817c3e322b6" translate="yes" xml:space="preserve">
          <source>If you run the above code you'll see that it does not always print zero, though it may depend on the timings of your machine you may need to tweak timeouts in this example to actually see non-zero values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd3a00df64d22ebf69e57bb704a9d62539a93298" translate="yes" xml:space="preserve">
          <source>If you start by replacing &lt;code&gt;GlobalScope.launch&lt;/code&gt; by &lt;code&gt;thread&lt;/code&gt;, the compiler produces the following error:</source>
          <target state="translated">如果您通过更换启动 &lt;code&gt;GlobalScope.launch&lt;/code&gt; 由 &lt;code&gt;thread&lt;/code&gt; ，编译器产生以下错误：</target>
        </trans-unit>
        <trans-unit id="1244c242be7001db0fa42d5a34807cd464a4c723" translate="yes" xml:space="preserve">
          <source>If you start by replacing &lt;code&gt;GlobalScope.launch&lt;/code&gt; with &lt;code&gt;thread&lt;/code&gt;, the compiler produces the following error:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="589b4c81823f6922542c45e2902c148531d2b494" translate="yes" xml:space="preserve">
          <source>If you target JavaScript, use the &lt;code&gt;stdlib-js&lt;/code&gt; dependency.</source>
          <target state="translated">如果您以JavaScript为目标，请使用 &lt;code&gt;stdlib-js&lt;/code&gt; 依赖项。</target>
        </trans-unit>
        <trans-unit id="bf587872264afbd1369b320aaae73dd1b3673d1b" translate="yes" xml:space="preserve">
          <source>If you use &lt;a href=&quot;kapt&quot;&gt;kapt&lt;/a&gt;, note that the kapt annotation processing tasks are not cached by default. However, you can &lt;a href=&quot;kapt#gradle-build-cache-support-since-1220&quot;&gt;enable caching for them manually&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39efa722c74de834ad1bd8a4e4c201bd7dac494b" translate="yes" xml:space="preserve">
          <source>If you use &lt;a href=&quot;kapt&quot;&gt;kapt&lt;/a&gt;, note that the kapt annotation processing tasks are not cached by default. However, you can enable caching for them manually. See the &lt;a href=&quot;kapt#gradle-build-cache-support-since-1220&quot;&gt;kapt page&lt;/a&gt; for details.</source>
          <target state="translated">如果使用&lt;a href=&quot;kapt&quot;&gt;kapt&lt;/a&gt;，请注意，默认情况下不会缓存kapt批注处理任务。但是，您可以为其手动启用缓存。有关详细信息，请参见&lt;a href=&quot;kapt#gradle-build-cache-support-since-1220&quot;&gt;kapt页面&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a73c7aeee6bdc5c7806d3e53e9294fc8ac4610bf" translate="yes" xml:space="preserve">
          <source>If you use Spring, you can enable the &lt;em&gt;kotlin-spring&lt;/em&gt; compiler plugin instead of specifying Spring annotations manually. The kotlin-spring is a wrapper on top of all-open, and it behaves exactly the same way.</source>
          <target state="translated">如果您使用Spring，则可以启用&lt;em&gt;kotlin-spring&lt;/em&gt;编译器插件，而不用手动指定Spring注释。Kotlin弹簧是全开式包装的包装，其行为完全相同。</target>
        </trans-unit>
        <trans-unit id="611d8f619bf7a7948c981fe9d16f096526d50981" translate="yes" xml:space="preserve">
          <source>If you use a kotlinx library and need a platform-specific dependency, you can use platform-specific variants of libraries with suffixes such as &lt;code&gt;-jvm&lt;/code&gt; or &lt;code&gt;-js&lt;/code&gt;, for example, &lt;code&gt;kotlinx-coroutines-core-jvm&lt;/code&gt;. You can also use the library base artifact name instead &amp;ndash; &lt;code&gt;kotlinx-coroutines-core&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7efa55746211a1f8112a9a60777f3c462da2efbd" translate="yes" xml:space="preserve">
          <source>If you use a multiplatform library and need to depend on the shared code, set the dependency only once in the shared source set. Use the library base artifact name, such as &lt;code&gt;kotlinx-coroutines-core&lt;/code&gt; or &lt;code&gt;ktor-client-core&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1bce77e8c93a7ca161789d86b2fef454e9ed0e0f" translate="yes" xml:space="preserve">
          <source>If you use annotation processors for your &lt;code&gt;androidTest&lt;/code&gt; or &lt;code&gt;test&lt;/code&gt; sources, the respective &lt;code&gt;kapt&lt;/code&gt; configurations are named &lt;code&gt;kaptAndroidTest&lt;/code&gt; and &lt;code&gt;kaptTest&lt;/code&gt;. Note that &lt;code&gt;kaptAndroidTest&lt;/code&gt; and &lt;code&gt;kaptTest&lt;/code&gt; extends &lt;code&gt;kapt&lt;/code&gt;, so you can just provide the &lt;code&gt;kapt&lt;/code&gt; dependency and it will be available both for production sources and tests.</source>
          <target state="translated">如果您将注释处理器用于 &lt;code&gt;androidTest&lt;/code&gt; 或 &lt;code&gt;test&lt;/code&gt; 源，则相应的 &lt;code&gt;kapt&lt;/code&gt; 配置将命名为 &lt;code&gt;kaptAndroidTest&lt;/code&gt; 和 &lt;code&gt;kaptTest&lt;/code&gt; 。请注意， &lt;code&gt;kaptAndroidTest&lt;/code&gt; 和 &lt;code&gt;kaptTest&lt;/code&gt; 扩展了 &lt;code&gt;kapt&lt;/code&gt; ，因此您只需提供 &lt;code&gt;kapt&lt;/code&gt; 依赖项，即可将其用于生产源和测试。</target>
        </trans-unit>
        <trans-unit id="8e5fa9bba802b4996dceed857e221c7dc79c3552" translate="yes" xml:space="preserve">
          <source>If you use the NV Kotlin compiler and have the OV standard library or the OV reflection library in the classpath, it can be a sign that the project is misconfigured. To prevent unexpected problems during compilation or at runtime, we suggest either updating the dependencies to NV, or specifying the API version / language version arguments explicitly. Otherwise the compiler detects that something can go wrong and reports a warning.</source>
          <target state="translated">如果你使用NV Kotlin编译器,并且在classpath中有OV标准库或OV反射库,这可能是项目配置错误的迹象。为了防止在编译过程中或运行时出现意外问题,我们建议更新依赖关系到NV,或者明确指定API版本/语言版本参数。否则编译器会检测到一些可能出错的地方并报告一个警告。</target>
        </trans-unit>
        <trans-unit id="f69388ccfa9be1025c7351e156b510d0110f1b95" translate="yes" xml:space="preserve">
          <source>If you want a literal &lt;code&gt;$&lt;/code&gt;, you need to escape it: &lt;code&gt;\$&lt;/code&gt;. Escaping generally works the same way as in Python, with a similar set of standard escape sequences.</source>
          <target state="translated">如果要使用文字 &lt;code&gt;$&lt;/code&gt; ，则需要对其进行转义： &lt;code&gt;\$&lt;/code&gt; 。转义通常与Python中的工作方式相同，但具有一组类似的标准转义序列。</target>
        </trans-unit>
        <trans-unit id="542e15c450e9d7499e5b8e3fd1eff9a8b7386f93" translate="yes" xml:space="preserve">
          <source>If you want to &lt;strong&gt;start from scratch&lt;/strong&gt;, you can &lt;a href=&quot;jvm-get-started&quot;&gt;create a basic Kotlin application&lt;/a&gt;. Once you&amp;rsquo;ve created the application, you can dive deeper into Kotlin syntax:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dcc75b83f1a6aedb14b4da0cf0332f54ec31285c" translate="yes" xml:space="preserve">
          <source>If you want to alert callers of possible exceptions when calling Kotlin code from Java, Swift, or Objective-C, you can use the &lt;code&gt;@Throws&lt;/code&gt; annotation. Read more about using this annotation &lt;a href=&quot;java-to-kotlin-interop#checked-exceptions&quot;&gt;for Java&lt;/a&gt; as well as &lt;a href=&quot;native/objc_interop#errors-and-exceptions&quot;&gt;for Swift and Objective-C&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aeb2cd1321a6da714d1670aa5db99ba2841082d1" translate="yes" xml:space="preserve">
          <source>If you want to be able to intercept an assignment and &quot;veto&quot; it, use &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.properties/-delegates/vetoable&quot;&gt;&lt;code&gt;vetoable()&lt;/code&gt;&lt;/a&gt; instead of &lt;code&gt;observable()&lt;/code&gt;. The handler passed to the &lt;code&gt;vetoable&lt;/code&gt; is called &lt;em&gt;before&lt;/em&gt; the assignment of a new property value has been performed.</source>
          <target state="translated">如果您希望能够拦截分配并&amp;ldquo;否决&amp;rdquo;分配，请使用&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.properties/-delegates/vetoable&quot;&gt; &lt;code&gt;vetoable()&lt;/code&gt; &lt;/a&gt;而不是 &lt;code&gt;observable()&lt;/code&gt; 。在执行新属性值的分配&lt;em&gt;之前，&lt;/em&gt;将调用传递给 &lt;code&gt;vetoable&lt;/code&gt; 的处理程序。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="bfcb549b385e785251e8b67f2103cc999018679b" translate="yes" xml:space="preserve">
          <source>If you want to be more explicit about the fact that you're creating a function, you can make an &lt;em&gt;anonymous function&lt;/em&gt;, which is still an expression rather than a declaration:</source>
          <target state="translated">如果您想更清楚地了解创建函数的事实，可以创建一个&lt;em&gt;匿名函数&lt;/em&gt;，该&lt;em&gt;函数&lt;/em&gt;仍然是表达式而不是声明：</target>
        </trans-unit>
        <trans-unit id="696e4536ad6464f41098a1506dbe37ed6e039609" translate="yes" xml:space="preserve">
          <source>If you want to check for &lt;em&gt;not&lt;/em&gt; being an instance of a type, use &lt;code&gt;!is&lt;/code&gt;. Note that &lt;code&gt;null&lt;/code&gt; is never an instance of any non-nullable type, but it is always an &quot;instance&quot; of any nullable type (even though it technically isn't an instance, but an absence of any instance).</source>
          <target state="translated">如果要检查&lt;em&gt;不是&lt;/em&gt;某个类型的实例，请使用 &lt;code&gt;!is&lt;/code&gt; 。请注意， &lt;code&gt;null&lt;/code&gt; 绝不是任何非空类型的实例，但它始终是任何可空类型的&amp;ldquo;实例&amp;rdquo;（即使从技术上讲它不是实例，但是没有任何实例）。</target>
        </trans-unit>
        <trans-unit id="da257f8128fc0a8ca8d706e6f33a71205b6846f0" translate="yes" xml:space="preserve">
          <source>If you want to customize your builds or run configuration, refer to the Android Studio &lt;a href=&quot;https://developer.android.com/studio/run&quot;&gt;documentation&lt;/a&gt;.</source>
          <target state="translated">如果要自定义构建或运行配置，请参阅Android Studio &lt;a href=&quot;https://developer.android.com/studio/run&quot;&gt;文档&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6811d9ac7923673de93e7c6cb86e0dcf12f4b539" translate="yes" xml:space="preserve">
          <source>If you want to declare your module's API as experimental, create an annotation class to use as its &lt;em&gt;experimental marker&lt;/em&gt;. This class must be annotated with &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin/-experimental/index&quot;&gt;@Experimental&lt;/a&gt;:</source>
          <target state="translated">如果要将模块的API声明为实验性API，请创建一个注释类以用作其&lt;em&gt;实验性标记&lt;/em&gt;。此类必须使用&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin/-experimental/index&quot;&gt;@Experimental&lt;/a&gt;进行注释：</target>
        </trans-unit>
        <trans-unit id="03930681c826a10c017d1c305e0dfdcd631eb099" translate="yes" xml:space="preserve">
          <source>If you want to do something that does not fit into this &quot;implicit backing field&quot; scheme, you can always fall back to having a &lt;em&gt;backing property&lt;/em&gt;:</source>
          <target state="translated">如果您想做一些不适合这种&amp;ldquo;隐式后备字段&amp;rdquo;方案的事情，那么您总是可以退回到拥有&lt;em&gt;后备属性的位置&lt;/em&gt;：</target>
        </trans-unit>
        <trans-unit id="469cbead1816f95552e8fb9afc4584e38910eba1" translate="yes" xml:space="preserve">
          <source>If you want to exclude the last value, use &lt;code&gt;until&lt;/code&gt;:</source>
          <target state="translated">如果要排除最后一个值，请使用 &lt;code&gt;until&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="21db5d6173e4569eae43123218189b3a3fd619bd" translate="yes" xml:space="preserve">
          <source>If you want to group elements and then apply an operation to all groups at one time, use the function &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/grouping-by&quot;&gt;&lt;code&gt;groupingBy()&lt;/code&gt;&lt;/a&gt;. It returns an instance of the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-grouping/index&quot;&gt;&lt;code&gt;Grouping&lt;/code&gt;&lt;/a&gt; type. The &lt;code&gt;Grouping&lt;/code&gt; instance lets you apply operations to all groups in a lazy manner: the groups are actually built right before the operation execution.</source>
          <target state="translated">如果要对元素进行分组，然后一次将操作应用于所有分组，请使用函数&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/grouping-by&quot;&gt; &lt;code&gt;groupingBy()&lt;/code&gt; &lt;/a&gt;。它返回一个&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-grouping/index&quot;&gt; &lt;code&gt;Grouping&lt;/code&gt; &lt;/a&gt;类型的实例。通过 &lt;code&gt;Grouping&lt;/code&gt; 实例，您可以以一种惰性的方式将操作应用于所有组：这些组实际上是在执行操作之前构建的。</target>
        </trans-unit>
        <trans-unit id="28c8357f8e591acaadaa35ef0312974da5893976" translate="yes" xml:space="preserve">
          <source>If you want to impose additional constraints, you must use a separate &lt;code&gt;where&lt;/code&gt; clause, in which case the type parameter must be a subclass of the given class (if you specify a class, and you can specify at most one) &lt;em&gt;and&lt;/em&gt; implement all the given interfaces. You may then access all the public members of all the given types whenever you've got a value of type &lt;code&gt;T&lt;/code&gt;:</source>
          <target state="translated">如果要施加其他约束，则必须使用单独的 &lt;code&gt;where&lt;/code&gt; 子句，在这种情况下，type参数必须是给定类的子类（如果指定了一个类，并且最多可以指定一个），&lt;em&gt;并&lt;/em&gt;实现所有给定的接口。然后，只要您拥有类型 &lt;code&gt;T&lt;/code&gt; 的值，就可以访问所有给定类型的所有公共成员：</target>
        </trans-unit>
        <trans-unit id="1e91febbc6ec64c3a83c00953396a7246b3b6ef2" translate="yes" xml:space="preserve">
          <source>If you want to intercept assignments and &quot;veto&quot; them, use &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.properties/-delegates/vetoable&quot;&gt;&lt;code&gt;vetoable()&lt;/code&gt;&lt;/a&gt; instead of &lt;code&gt;observable()&lt;/code&gt;. The handler passed to the &lt;code&gt;vetoable&lt;/code&gt; is called &lt;em&gt;before&lt;/em&gt; the assignment of a new property value has been performed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad4ce20803bf2d9ea3efb4e51b2111ecb76db405" translate="yes" xml:space="preserve">
          <source>If you want to iterate through an array or a list with an index, you can do it this way:</source>
          <target state="translated">如果你想在一个数组或带索引的列表中进行迭代,你可以这样做。</target>
        </trans-unit>
        <trans-unit id="125c434fa84549730a675353dd139689f7b256f9" translate="yes" xml:space="preserve">
          <source>If you want to keep a whole package or module from elimination, you can use its fully qualified name as it appears in the generated JavaScript code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6675875ca0e15a9e0e94e4e62bcc35aa2271753" translate="yes" xml:space="preserve">
          <source>If you want to keep your code compatible with the 1.0 standard library, you can pass &lt;code&gt;-api-version 1.0&lt;/code&gt;.</source>
          <target state="translated">如果要使代码与1.0标准库兼容，则可以传递 &lt;code&gt;-api-version 1.0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a90f40cf003c1ca63835c4f5252dade99a0b6302" translate="yes" xml:space="preserve">
          <source>If you want to learn different Kotlin features, try &lt;a href=&quot;koans&quot;&gt;Kotlin Koans&lt;/a&gt;.</source>
          <target state="translated">如果您想了解Kotlin的其他功能，请尝试&lt;a href=&quot;koans&quot;&gt;Kotlin Koans&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="00db4d51336388a60b35cfdb52f35a642fd46d81" translate="yes" xml:space="preserve">
          <source>If you want to look at the metadata of a function (e.g. its name), use &lt;code&gt;KFunction&amp;lt;V&amp;gt;&lt;/code&gt; or one of its subinterfaces, where &lt;code&gt;V&lt;/code&gt; is the function's return type. Here's a basic example:</source>
          <target state="translated">如果要查看函数的元数据（例如，函数名称），请使用 &lt;code&gt;KFunction&amp;lt;V&amp;gt;&lt;/code&gt; 或其子接口之一，其中 &lt;code&gt;V&lt;/code&gt; 是函数的返回类型。这是一个基本示例：</target>
        </trans-unit>
        <trans-unit id="1d1730df83789869c0eec8797d86c76b973936cd" translate="yes" xml:space="preserve">
          <source>If you want to restrict the set of subclasses of a base class, you can declare the base class to be &lt;code&gt;sealed&lt;/code&gt; (which also makes it abstract), in which case you can only declare subclasses in the same file. The compiler then knows the complete set of possible subclasses, which will let you do exhaustive &lt;code&gt;when&lt;/code&gt; expression for all the possible subtypes without the need for an &lt;code&gt;else&lt;/code&gt; clause (and if you add another subclass in the future and forget to update the &lt;code&gt;when&lt;/code&gt;, the compiler will let you know).</source>
          <target state="translated">如果要限制基类的子类集，则可以声明要 &lt;code&gt;sealed&lt;/code&gt; 的基类（这也使其抽象化），在这种情况下，只能在同一文件中声明子类。然后，编译器知道了所有可能的子类的完整集合，这将使您在无需使用 &lt;code&gt;else&lt;/code&gt; 子句的情况下对所有可能的子类型进行详尽的 &lt;code&gt;when&lt;/code&gt; 表达式（如果将来添加另一个子类而忘记更新 &lt;code&gt;when&lt;/code&gt; ，则编译器会让你知道）。</target>
        </trans-unit>
        <trans-unit id="24aa907f13ca700b9ceeaa1262123234a9393fc1" translate="yes" xml:space="preserve">
          <source>If you want to see all available options run</source>
          <target state="translated">如果你想查看所有可用的选项,运行</target>
        </trans-unit>
        <trans-unit id="2d21aa936de4e7ff46724ca50ee4a418c4b5e521" translate="yes" xml:space="preserve">
          <source>If you want to see how your task will be look to the learner, right-click the &lt;code&gt;Task.kt&lt;/code&gt; file in the &lt;strong&gt;Project&lt;/strong&gt; tool window, and choose &lt;strong&gt;Course Creator -&amp;gt; Show Preview&lt;/strong&gt;:</source>
          <target state="translated">如果要查看学习者的任务外观，请在&amp;ldquo; &lt;strong&gt;项目&amp;rdquo;&lt;/strong&gt;工具窗口中右键单击 &lt;code&gt;Task.kt&lt;/code&gt; 文件，然后选择&amp;ldquo; &lt;strong&gt;课程创建者&amp;rdquo;-&amp;gt;&amp;ldquo;显示预览&amp;rdquo;&lt;/strong&gt;：&lt;strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="81dec7b57d1ae160cc859398f6b261d2b3f48fa4" translate="yes" xml:space="preserve">
          <source>If you want to specify a custom label for the link, use the Markdown reference-style syntax:</source>
          <target state="translated">如果你想为链接指定一个自定义标签,请使用Markdown引用式语法。</target>
        </trans-unit>
        <trans-unit id="e8b98cb29aff85793ce838953d8ec8871fe09a05" translate="yes" xml:space="preserve">
          <source>If you want to start from scratch with the task, use the &lt;strong&gt;Reset&lt;/strong&gt; icon at the top of &lt;strong&gt;Task Description&lt;/strong&gt; panel:</source>
          <target state="translated">如果要从头开始执行任务，请使用&amp;ldquo; &lt;strong&gt;任务描述&amp;rdquo;&lt;/strong&gt;面板顶部的&amp;ldquo; &lt;strong&gt;重置&amp;rdquo;&lt;/strong&gt;图标：&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c377ee38e06516840389b0006f62da827c729d93" translate="yes" xml:space="preserve">
          <source>If you want to start using Kotlin for Android development, read &lt;a href=&quot;https://developer.android.com/kotlin/get-started&quot;&gt;Google&amp;rsquo;s recommendation for getting started with Kotlin on Android&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef089a53351dae0337ca675a4a633d10abb6eccf" translate="yes" xml:space="preserve">
          <source>If you want to use a value only if it satisfies a certain condition, try &lt;code&gt;takeIf()&lt;/code&gt;, which returns the value it's called on if it satisfies the given predicate, and null otherwise. There's also &lt;code&gt;takeUnless()&lt;/code&gt;, which inverts the logic. You can follow this with a &lt;code&gt;?.&lt;/code&gt; to perform an operation on the value only if it satisfies the predicate. Below, we compute the square of some expression, but only if the expression value is at least 42:</source>
          <target state="translated">如果仅在满足特定条件时才使用值，请尝试 &lt;code&gt;takeIf()&lt;/code&gt; ，如果它满足给定谓词，则返回它被调用的值，否则返回null。还有 &lt;code&gt;takeUnless()&lt;/code&gt; ，它会反转逻辑。您可以在后面加上 &lt;code&gt;?.&lt;/code&gt; 仅在满足谓词的情况下对值执行运算。下面，我们计算某些表达式的平方，但前提是表达式的值至少为42：</target>
        </trans-unit>
        <trans-unit id="39803479c2452982a2bf2e4068e689f82660ee9c" translate="yes" xml:space="preserve">
          <source>If you want to use dependencies on local pods from Kotlin code, import the corresponding packages.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be96354e6d849f99091812f51218336ab205ca9c" translate="yes" xml:space="preserve">
          <source>If you want to use the EduTools plugin for teaching, read &lt;a href=&quot;edu-tools-educator&quot;&gt;Teaching Kotlin with EduTools plugin&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67fb2febabe66895070c2641c4d6f978cdb57747" translate="yes" xml:space="preserve">
          <source>If you want to use the EduTools plugin to learn Kotlin, read &lt;a href=&quot;edu-tools-learner&quot;&gt;Learning Kotlin with EduTools plugin&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87bc643ce85513f6868cb2e9de9823d1f4369259" translate="yes" xml:space="preserve">
          <source>If you want to write strings gradually, you need to create an &lt;code&gt;OutputStreamWriter&lt;/code&gt; by calling &lt;code&gt;writer()&lt;/code&gt; on the file object. You can write binary data to a file by calling &lt;code&gt;outputStream()&lt;/code&gt; on a file object and use the resulting &lt;code&gt;OutputStream&lt;/code&gt; to write bytes.</source>
          <target state="translated">如果要逐渐编写字符串，则需要通过在文件对象上调用 &lt;code&gt;writer()&lt;/code&gt; 创建一个 &lt;code&gt;OutputStreamWriter&lt;/code&gt; 。您可以通过在文件对象上调用 &lt;code&gt;outputStream()&lt;/code&gt; 将二进制数据写入文件，然后使用生成的 &lt;code&gt;OutputStream&lt;/code&gt; 写入字节。</target>
        </trans-unit>
        <trans-unit id="a41befb145b42cbf8131f21728e484a8a91115d2" translate="yes" xml:space="preserve">
          <source>If you write the same without &lt;code&gt;let&lt;/code&gt;, you'll have to introduce a new variable and repeat its name whenever you use it.</source>
          <target state="translated">如果不使用 &lt;code&gt;let&lt;/code&gt; 编写相同的代码，则必须引入一个新变量，并在每次使用它时重复其名称。</target>
        </trans-unit>
        <trans-unit id="0a3aaf1f9dd9fea6023de83a437602a5eadebf5e" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re on Ubuntu 16.04 or later, you can install the compiler from the command line:</source>
          <target state="translated">如果您使用的是Ubuntu 16.04或更高版本，则可以从命令行安装编译器：</target>
        </trans-unit>
        <trans-unit id="4ef3b492d472d99a86a122fa8edba6106fbe3c08" translate="yes" xml:space="preserve">
          <source>If you'd rather do &lt;code&gt;x.unsigned&lt;/code&gt;, you can define an extension property:</source>
          <target state="translated">如果愿意使用 &lt;code&gt;x.unsigned&lt;/code&gt; ，则可以定义一个扩展属性：</target>
        </trans-unit>
        <trans-unit id="07dd95cbbfcdccfc3f0d530d8306040139f15ae7" translate="yes" xml:space="preserve">
          <source>If you're a &lt;a href=&quot;https://www.macports.org/&quot;&gt;MacPorts&lt;/a&gt; user, you can install the compiler with:</source>
          <target state="translated">如果您是&lt;a href=&quot;https://www.macports.org/&quot;&gt;MacPorts&lt;/a&gt;用户，则可以使用以下方法安装编译器：</target>
        </trans-unit>
        <trans-unit id="0509d81eee59f0e681a0c3f0c84d5a54a79b4f26" translate="yes" xml:space="preserve">
          <source>If you're developing a library to be used by other Kotlin applications, you can build the &lt;em&gt;.jar&lt;/em&gt; file without including the Kotlin runtime into it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="368782cf6eaff197b952127bcc0c0565b3479378" translate="yes" xml:space="preserve">
          <source>If you're developing a library to be used by other Kotlin applications, you can produce the .jar file without including the Kotlin runtime into it.</source>
          <target state="translated">如果你正在开发一个供其他Kotlin应用程序使用的库,你可以在不包含Kotlin运行时的情况下生成.jar文件。</target>
        </trans-unit>
        <trans-unit id="9da5d517a7b5384e2a44811f79965cdbfc0afba2" translate="yes" xml:space="preserve">
          <source>If you're new to Android and want to learn to create applications with Kotlin, check out &lt;a href=&quot;https://www.udacity.com/course/developing-android-apps-with-kotlin--ud9012&quot;&gt;this Udacity course&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f128e1fe8c8eb81ea54217b5ba66f82b1c59b061" translate="yes" xml:space="preserve">
          <source>If you're new to Kotlin, a good first step would be to familiarise yourself with the &lt;a href=&quot;basic-syntax&quot;&gt;Basic Syntax&lt;/a&gt; of the language.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="766f702953f8980e6bc50e185cc1d656f34dfbc1" translate="yes" xml:space="preserve">
          <source>If you're targeting JDK 7 or JDK 8, you can use extended versions of the Kotlin standard library which contain additional extension functions for APIs added in new JDK versions. Instead of &lt;code&gt;kotlin-stdlib&lt;/code&gt;, use &lt;code&gt;kotlin-stdlib-jdk7&lt;/code&gt; or &lt;code&gt;kotlin-stdlib-jdk8&lt;/code&gt;, depending on your JDK version (for Kotlin 1.1.x use &lt;code&gt;kotlin-stdlib-jre7&lt;/code&gt; and &lt;code&gt;kotlin-stdlib-jre8&lt;/code&gt; as the &lt;code&gt;jdk&lt;/code&gt; counterparts were introduced in 1.2.0).</source>
          <target state="translated">如果您以JDK 7或JDK 8为目标，则可以使用Kotlin标准库的扩展版本，其中包含针对新JDK版本中添加的API的其他扩展功能。代替 &lt;code&gt;kotlin-stdlib&lt;/code&gt; ，请使用 &lt;code&gt;kotlin-stdlib-jdk7&lt;/code&gt; 或 &lt;code&gt;kotlin-stdlib-jdk8&lt;/code&gt; ，具体取决于您的JDK版本（对于Kotlin 1.1.x，请使用 &lt;code&gt;kotlin-stdlib-jre7&lt;/code&gt; 和 &lt;code&gt;kotlin-stdlib-jre8&lt;/code&gt; ,因为在1.2中引入了 &lt;code&gt;jdk&lt;/code&gt; 对应版本.0）。</target>
        </trans-unit>
        <trans-unit id="b775395194955c271aef49dac84498fbe90d7450" translate="yes" xml:space="preserve">
          <source>If you're targeting the JVM platform, you can also use Java's reflection system directly. In this example, we grab a function reference from an object's class by specifying the function's name as a string (if the function takes parameters, you also need to specify their types), and then we call it. Note that we didn't mention &lt;code&gt;String&lt;/code&gt; anywhere - this technique works without knowing what the object's class is, but it will raise an exception if the object's class doesn't have the requested function. However, Java-style function references do not have type information, so you won't get verification of the parameter types, and you must cast the return value:</source>
          <target state="translated">如果您以JVM平台为目标，则还可以直接使用Java的反射系统。在此示例中，我们通过将函数名称指定为字符串来从对象的类中获取函数引用（如果函数带有参数，则还需要指定其类型），然后调用它。请注意，我们在任何地方都没有提到 &lt;code&gt;String&lt;/code&gt; －这种技术在不知道对象的类是什么的情况下起作用，但是如果对象的类没有所请求的功能，它将引发异常。但是，Java样式的函数引用没有类型信息，因此您将无法验证参数类型，并且必须强制转换返回值：</target>
        </trans-unit>
        <trans-unit id="3a761f12674bd3c30efe00ec7ea6eb2be1927a55" translate="yes" xml:space="preserve">
          <source>If you're targeting the browser and want to use a different module system than UMD, you can specify the desired module type in the &lt;code&gt;webpackTask&lt;/code&gt; configuration block. For example, to switch to CommonJS, use:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d2933676dc2f7e28b956599b006e00954f9395f" translate="yes" xml:space="preserve">
          <source>If you're using &lt;em&gt;if&lt;/em&gt; as an expression rather than a statement (for example, returning its value or assigning it to a variable), the expression is required to have an &lt;code&gt;else&lt;/code&gt; branch.</source>
          <target state="translated">如果您将&lt;em&gt;if&lt;/em&gt;用作表达式而不是语句（例如，将其值返回或将其分配给变量），则该表达式必须具有 &lt;code&gt;else&lt;/code&gt; 分支。</target>
        </trans-unit>
        <trans-unit id="51fc2cadbf8df70dee87fb5d749d2ee884d218b0" translate="yes" xml:space="preserve">
          <source>If you're using a generic class whose type parameters haven't been declared in a variant way (either because its authors didn't think of it, or because the type parameters can't have either variance kind because they are used both as parameter types and return types), you can still use it in a variant way thanks to &lt;em&gt;type projection&lt;/em&gt;. The term &quot;projection&quot; refers to the fact that when you do this, you might restrict yourself to using only some of its members - so you're in a sense only seeing a partial, or &quot;projected&quot; version of the class. Let's look again at our &lt;code&gt;Bowl&lt;/code&gt; class, but without the variant interfaces this time:</source>
          <target state="translated">如果您使用的泛型类的类型参数没有以变体的方式声明（要么是因为其作者没有想到它，要么是因为类型参数不能具有任何一种变异类型，因为它们都被用作参数类型和返回类型），由于&lt;em&gt;类型为projection&lt;/em&gt;，您仍然可以以其他方式使用它。术语&amp;ldquo;投影&amp;rdquo;是指这样的事实：执行此操作时，您可能会限制自己仅使用其某些成员-因此，从某种意义上讲，您只能看到类的部分或&amp;ldquo;投影&amp;rdquo;版本。让我们再次看一下 &lt;code&gt;Bowl&lt;/code&gt; 类，但是这次没有变型接口：</target>
        </trans-unit>
        <trans-unit id="f6e51da97890d2ae9ab3d189065498b378cc4fb2" translate="yes" xml:space="preserve">
          <source>If you've got one string that you want to write to a file, overwriting the existing contents if the file already exists, do this (again, UTF-8 is the default encoding):</source>
          <target state="translated">如果你有一个字符串想写入一个文件,如果文件已经存在,就覆盖现有的内容,这样做(同样,UTF-8是默认编码)。</target>
        </trans-unit>
        <trans-unit id="d91079d5275bf77f335cf6cb84c315d0b54d9ee8" translate="yes" xml:space="preserve">
          <source>If you've just upgraded to Kotlin 1.1 but can not use new language features yet (e.g. because some of your teammates may not have upgraded), you can pass &lt;code&gt;-language-version 1.0&lt;/code&gt;, which will restrict all APIs and language features to 1.0.</source>
          <target state="translated">如果您刚刚升级到Kotlin 1.1，但仍不能使用新的语言功能（例如，由于您的某些队友可能尚未升级），则可以传递 &lt;code&gt;-language-version 1.0&lt;/code&gt; ，它将所有API和语言功能限制为1.0。</target>
        </trans-unit>
        <trans-unit id="6a4d49a0aa58db91f5538f1484a110d84d269171" translate="yes" xml:space="preserve">
          <source>If your application already uses DBFlow, you can safely introduce Kotlin into your project. You can gradually convert existing code to Kotlin (ensuring that everything compiles along the way). The converted code doesn't differ much from Java. For instance, declaring a table looks similar to Java with the small difference that default values for properties must be specified explicitly:</source>
          <target state="translated">如果您的应用程序已经使用DBFlow,您可以安全地将Kotlin引入到您的项目中。你可以逐步将现有的代码转换为Kotlin(确保所有的东西都能顺着编译)。转换后的代码与Java没有太大区别。例如,声明一个表看起来与Java相似,但有一点不同,即必须明确指定属性的默认值。</target>
        </trans-unit>
        <trans-unit id="f63962aa6cf85ec6f47c280bebab4a954c284cd2" translate="yes" xml:space="preserve">
          <source>If your class requires more advanced serialization logic, write it inside a companion class:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3503de21b9cb0b7cba965dc4634f2918727f903d" translate="yes" xml:space="preserve">
          <source>If your class requires more advanced serialization logic, you can write it inside a companion class:</source>
          <target state="translated">如果你的类需要更高级的序列化逻辑,你可以把它写在一个同伴类里面。</target>
        </trans-unit>
        <trans-unit id="eacc53066a886e6486df3248d96a52d89fd95863" translate="yes" xml:space="preserve">
          <source>If your code is too clever for the compiler, and you know without the help of &lt;code&gt;is&lt;/code&gt; that &lt;code&gt;x&lt;/code&gt; is an instance of &lt;code&gt;Person&lt;/code&gt; but the compiler doesn't, you can &lt;em&gt;cast&lt;/em&gt; your value with &lt;code&gt;as&lt;/code&gt;:</source>
          <target state="translated">如果您的代码对于编译器来说太聪明了，并且您没有 &lt;code&gt;x&lt;/code&gt; 的帮助 &lt;code&gt;is&lt;/code&gt; 知道x是 &lt;code&gt;Person&lt;/code&gt; 的实例，但是编译器却不是，则可以使用 &lt;code&gt;as&lt;/code&gt; &lt;em&gt;强制转换&lt;/em&gt;值：</target>
        </trans-unit>
        <trans-unit id="2ecf8bd14ee3aa94f5fa13c2b5cd616c3b320e5a" translate="yes" xml:space="preserve">
          <source>If your project uses &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.reflect.full/index&quot;&gt;Kotlin reflection&lt;/a&gt; or testing facilities, you need to add the corresponding dependencies as well. The artifact IDs are &lt;code&gt;kotlin-reflect&lt;/code&gt; for the reflection library, and &lt;code&gt;kotlin-test&lt;/code&gt; and &lt;code&gt;kotlin-test-junit&lt;/code&gt; for the testing libraries.</source>
          <target state="translated">如果您的项目使用&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.reflect.full/index&quot;&gt;Kotlin反射&lt;/a&gt;或测试工具，则还需要添加相应的依赖项。工件ID 对于反射库是 &lt;code&gt;kotlin-reflect&lt;/code&gt; ,对于 &lt;code&gt;kotlin-test&lt;/code&gt; 库是kotlin-test和 &lt;code&gt;kotlin-test-junit&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="aaffb39c3271a99cd3c6b1dcd26285bb7f6d4133" translate="yes" xml:space="preserve">
          <source>If your project uses &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.reflect.full/index&quot;&gt;Kotlin reflection&lt;/a&gt; or testing facilities, you need to add the corresponding dependencies as well:</source>
          <target state="translated">如果您的项目使用&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.reflect.full/index&quot;&gt;Kotlin反射&lt;/a&gt;或测试工具，则还需要添加相应的依赖项：</target>
        </trans-unit>
        <trans-unit id="ff4ecabd35e3e545f9518b5b102d6fa77c32607a" translate="yes" xml:space="preserve">
          <source>If, by any chance, we need &quot;just an object&quot;, with no nontrivial supertypes, we can simply say:</source>
          <target state="translated">如果偶然,我们需要 &quot;只是一个对象&quot;,没有非同寻常的超类型,我们可以简单地说。</target>
        </trans-unit>
        <trans-unit id="f78ba0d5d02014df85f65107c7688ad5093fc4b0" translate="yes" xml:space="preserve">
          <source>If, upon updating from one version to another, some code that used to work doesn't work any more, it is an &lt;em&gt;incompatible change&lt;/em&gt; in the language (sometimes referred to as &quot;breaking change&quot;). There can be debates as to what &quot;doesn't work any more&quot; means precisely in some cases, but it definitely includes the following:</source>
          <target state="translated">如果从一个版本更新到另一个版本后，某些可以正常工作的代码不再起作用，则表示该语言存在&lt;em&gt;不兼容的更改&lt;/em&gt;（有时称为&amp;ldquo;重大更改&amp;rdquo;）。在某些情况下，关于&amp;ldquo;不再有用&amp;rdquo;的确切含义可能存在争议，但肯定包括以下内容：</target>
        </trans-unit>
        <trans-unit id="ea0b39c7ffc510626fe28212437d8a57285e5a4c" translate="yes" xml:space="preserve">
          <source>IllegalArgumentException</source>
          <target state="translated">IllegalArgumentException</target>
        </trans-unit>
        <trans-unit id="906f0c92cf03edbafe4a5d12e37d92701ba25962" translate="yes" xml:space="preserve">
          <source>IllegalCallableAccessException</source>
          <target state="translated">IllegalCallableAccessException</target>
        </trans-unit>
        <trans-unit id="6bfee05d69b5aa826fde5d373d8ebea121200b58" translate="yes" xml:space="preserve">
          <source>IllegalCharacterConversionException</source>
          <target state="translated">IllegalCharacterConversionException</target>
        </trans-unit>
        <trans-unit id="6d13e3edbafba5c6ba6e57ae6bc8267296d1bf66" translate="yes" xml:space="preserve">
          <source>IllegalPropertyDelegateAccessException</source>
          <target state="translated">IllegalPropertyDelegateAccessException</target>
        </trans-unit>
        <trans-unit id="63b3abc14a5b2c9db143083b94887cb72910c4de" translate="yes" xml:space="preserve">
          <source>IllegalStateException</source>
          <target state="translated">IllegalStateException</target>
        </trans-unit>
        <trans-unit id="0ef9de975cdef9d9d9b896b68103ad59db30e33a" translate="yes" xml:space="preserve">
          <source>ImageBitmap</source>
          <target state="translated">ImageBitmap</target>
        </trans-unit>
        <trans-unit id="33f05a29887232f2adef5f1b64b04d6cf8bd78f2" translate="yes" xml:space="preserve">
          <source>ImageBitmapOptions</source>
          <target state="translated">ImageBitmapOptions</target>
        </trans-unit>
        <trans-unit id="91a39bdc5a33f203d5c2f138f0da931369fac84f" translate="yes" xml:space="preserve">
          <source>ImageBitmapRenderingContext</source>
          <target state="translated">ImageBitmapRenderingContext</target>
        </trans-unit>
        <trans-unit id="1a722437bfbd0c07b7f837b5b4332fd5d966ead2" translate="yes" xml:space="preserve">
          <source>ImageBitmapRenderingContextSettings</source>
          <target state="translated">ImageBitmapRenderingContextSettings</target>
        </trans-unit>
        <trans-unit id="b28af413c72a2e03556905d9b27766a80ae5dd7b" translate="yes" xml:space="preserve">
          <source>ImageBitmapSource</source>
          <target state="translated">ImageBitmapSource</target>
        </trans-unit>
        <trans-unit id="682b65e19d67a5e783299b757e21bec2832c6fb5" translate="yes" xml:space="preserve">
          <source>ImageData</source>
          <target state="translated">ImageData</target>
        </trans-unit>
        <trans-unit id="2217055c382ca08984df9c834dee428b5ed7c541" translate="yes" xml:space="preserve">
          <source>ImageOrientation</source>
          <target state="translated">ImageOrientation</target>
        </trans-unit>
        <trans-unit id="3394b71415cd8bd55fc9255b5d6beaf734d6f770" translate="yes" xml:space="preserve">
          <source>ImageSmoothingQuality</source>
          <target state="translated">ImageSmoothingQuality</target>
        </trans-unit>
        <trans-unit id="f98fd49f8f974a3886c42cb3693e5ffdf40539ee" translate="yes" xml:space="preserve">
          <source>Immediate superclasses of this class, in the order they are listed in the source code. Includes superclasses and superinterfaces of the class, but does not include the class itself.</source>
          <target state="translated">该类的直属超类,按照源代码中的顺序排列。包括该类的超类和超接口,但不包括该类本身。</target>
        </trans-unit>
        <trans-unit id="70af22099196223b8485c95684bbf8824a9afa2b" translate="yes" xml:space="preserve">
          <source>Immutability</source>
          <target state="translated">Immutability</target>
        </trans-unit>
        <trans-unit id="bb86d1b762a23d9068f4510901eeff7d18242638" translate="yes" xml:space="preserve">
          <source>Immutability in Kotlin/Native</source>
          <target state="translated">Kotlin/Native中的不可更改性</target>
        </trans-unit>
        <trans-unit id="7f8782e7a667262dd5095f5ff184ddd709f4772b" translate="yes" xml:space="preserve">
          <source>Immutability is a runtime property in Kotlin/Native, and can be applied to an arbitrary object subgraph using the &lt;code&gt;kotlin.native.concurrent.freeze&lt;/code&gt; function. It makes all the objects reachable from the given one immutable, such a transition is a one-way operation (i.e., objects cannot be unfrozen later). Some naturally immutable objects such as &lt;code&gt;kotlin.String&lt;/code&gt;, &lt;code&gt;kotlin.Int&lt;/code&gt;, and other primitive types, along with &lt;code&gt;AtomicInt&lt;/code&gt; and &lt;code&gt;AtomicReference&lt;/code&gt; are frozen by default. If a mutating operation is applied to a frozen object, an &lt;code&gt;InvalidMutabilityException&lt;/code&gt; is thrown.</source>
          <target state="translated">不可变性是Kotlin / Native中的运行时属性，可以使用 &lt;code&gt;kotlin.native.concurrent.freeze&lt;/code&gt; 函数将其应用于任意对象子图。它使所有对象都可以从给定的一个对象变为不可变的对象，这样的转换是单向操作（即，以后不能解冻对象）。默认情况下会冻结一些自然不可变的对象，例如 &lt;code&gt;kotlin.String&lt;/code&gt; ， &lt;code&gt;kotlin.Int&lt;/code&gt; 和其他原始类型，以及 &lt;code&gt;AtomicInt&lt;/code&gt; 和 &lt;code&gt;AtomicReference&lt;/code&gt; 。如果对冻结对象执行了变异操作， &lt;code&gt;InvalidMutabilityException&lt;/code&gt; 抛出InvalidMutabilityException。</target>
        </trans-unit>
        <trans-unit id="ed22a68de3c3f3cb15e1268df39db4a167fd746d" translate="yes" xml:space="preserve">
          <source>ImmutableBlob</source>
          <target state="translated">ImmutableBlob</target>
        </trans-unit>
        <trans-unit id="ee7341a728a58d68c7532bf18aeb0fac4452b6b5" translate="yes" xml:space="preserve">
          <source>Implementation by Delegation</source>
          <target state="translated">授权实施</target>
        </trans-unit>
        <trans-unit id="dc1735ad8ce42355f885445d5ba551e409b9c86b" translate="yes" xml:space="preserve">
          <source>Implementations of the interface can override default methods.</source>
          <target state="translated">接口的实现可以覆盖默认方法。</target>
        </trans-unit>
        <trans-unit id="00d5f96768fee4f4899fb4ea94381d1c87db0a66" translate="yes" xml:space="preserve">
          <source>Implementing Interfaces</source>
          <target state="translated">实现接口</target>
        </trans-unit>
        <trans-unit id="d640e1d5eb2b7a283f3bc3070dd151afc512fb6c" translate="yes" xml:space="preserve">
          <source>Implementing Interfaces in Enum Classes</source>
          <target state="translated">在Enum类中实现接口</target>
        </trans-unit>
        <trans-unit id="b2153d6fa67762548da1f8fe28f3d481ede48834" translate="yes" xml:space="preserve">
          <source>Implements the core logic of a property delegate for a read/write property that calls callback functions when changed.</source>
          <target state="translated">实现了读/写属性委托的核心逻辑,当属性改变时调用回调函数。</target>
        </trans-unit>
        <trans-unit id="b1af49118602d4ab9bd26831d35fc303f95ea13f" translate="yes" xml:space="preserve">
          <source>Implicit &lt;code&gt;this&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="febd7a841f47bb67cef7b18f13ac806c637192b6" translate="yes" xml:space="preserve">
          <source>Important: files marked with &lt;code&gt;@file:JsModule&lt;/code&gt; annotation can't declare non-external members. The example below produces compile-time error:</source>
          <target state="translated">重要：标有 &lt;code&gt;@file:JsModule&lt;/code&gt; 批注的文件不能声明非外部成员。下面的示例产生编译时错误：</target>
        </trans-unit>
        <trans-unit id="e45479a7a7959d4875b5ea4acddae533ace5e782" translate="yes" xml:space="preserve">
          <source>Importing deeper package hierarchies</source>
          <target state="translated">导入更深层次的包层次结构</target>
        </trans-unit>
        <trans-unit id="a932c1ce87f097109d85ae710ba5975b2888a20e" translate="yes" xml:space="preserve">
          <source>Importing synthetic properties</source>
          <target state="translated">导入合成属性</target>
        </trans-unit>
        <trans-unit id="e42328ac01cd03a47978f064c93b392caf3861f0" translate="yes" xml:space="preserve">
          <source>Imports</source>
          <target state="translated">Imports</target>
        </trans-unit>
        <trans-unit id="513df22c9887b1f085e00ef3b729d3f007cfd9d9" translate="yes" xml:space="preserve">
          <source>Improved import handling</source>
          <target state="translated">改进的导入处理</target>
        </trans-unit>
        <trans-unit id="d8972a1f28a588591d73ee09ddd836428eaca222" translate="yes" xml:space="preserve">
          <source>Improving smartcasts analysis by declaring the relation between a function's call outcome and the passed arguments values:</source>
          <target state="translated">通过声明函数的调用结果和传递的参数值之间的关系,改进智能广播分析。</target>
        </trans-unit>
        <trans-unit id="3ea84fc4dca92bbd95cba0393e768bc0dbac665a" translate="yes" xml:space="preserve">
          <source>Improving the variable initialization analysis in the presence of high-order functions:</source>
          <target state="translated">改进高阶函数存在下的变量初始化分析。</target>
        </trans-unit>
        <trans-unit id="1a9aa64fd2cf728e6a54a37ad269e224c4406ae7" translate="yes" xml:space="preserve">
          <source>In &quot;clever words&quot; they say that the class &lt;code&gt;C&lt;/code&gt; is &lt;strong&gt;covariant&lt;/strong&gt; in the parameter &lt;code&gt;T&lt;/code&gt;, or that &lt;code&gt;T&lt;/code&gt; is a &lt;strong&gt;covariant&lt;/strong&gt; type parameter. You can think of &lt;code&gt;C&lt;/code&gt; as being a &lt;strong&gt;producer&lt;/strong&gt; of &lt;code&gt;T&lt;/code&gt;'s, and NOT a &lt;strong&gt;consumer&lt;/strong&gt; of &lt;code&gt;T&lt;/code&gt;'s.</source>
          <target state="translated">在&amp;ldquo;灵巧的词&amp;rdquo;中，他们说类别 &lt;code&gt;C&lt;/code&gt; 在参数 &lt;code&gt;T&lt;/code&gt; 中是&lt;strong&gt;协变&lt;/strong&gt;的，或者 &lt;code&gt;T&lt;/code&gt; 是&lt;strong&gt;协变&lt;/strong&gt;类型参数。你可以认为 &lt;code&gt;C&lt;/code&gt; 作为一个&lt;strong&gt;制片人&lt;/strong&gt;的 &lt;code&gt;T&lt;/code&gt; 的，而不是一个&lt;strong&gt;消费者&lt;/strong&gt;的 &lt;code&gt;T&lt;/code&gt; 的。&lt;strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6019b82a793e669523c1435271b5d51f4ccb4ffc" translate="yes" xml:space="preserve">
          <source>In 1.3 we reworked the entire multiplatform model. The &lt;a href=&quot;building-mpp-with-gradle&quot;&gt;new DSL&lt;/a&gt; we have for describing multiplatform Gradle projects is much more flexible, and we'll keep working on it to make project configuration straightforward.</source>
          <target state="translated">在1.3中，我们重新设计了整个多平台模型。我们用于描述多平台Gradle项目的&lt;a href=&quot;building-mpp-with-gradle&quot;&gt;新DSL&lt;/a&gt;更加灵活，我们将继续致力于使项目配置变得简单明了。</target>
        </trans-unit>
        <trans-unit id="08f9bdd95bef61c2c357a6e138e1e9a913682812" translate="yes" xml:space="preserve">
          <source>In 1.3, we've completely reworked the model of multiplatform projects in order to improve expressiveness and flexibility, and to make sharing common code easier. Also, Kotlin/Native is now supported as one of the targets!</source>
          <target state="translated">在1.3版本中,我们对多平台项目的模型进行了彻底的重构,以提高表现力和灵活性,并使共享通用代码变得更加容易。另外,现在Kotlin/Native也被支持为目标之一了!</target>
        </trans-unit>
        <trans-unit id="5745802255877abfa046b72cbccdadc8221d5622" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;collection-ordering&quot;&gt;Collection Ordering&lt;/a&gt;, we describe operations that retrieve collection elements in specific orders. For mutable lists, the standard library offers similar extension functions that perform the same ordering operations in place. When you apply such an operation to a list instance, it changes the order of elements in that exact instance.</source>
          <target state="translated">在&lt;a href=&quot;collection-ordering&quot;&gt;Collection Ordering中&lt;/a&gt;，我们描述了按特定顺序检索集合元素的操作。对于可变列表，标准库提供了类似的扩展功能，这些扩展功能可以执行相同的排序操作。当您将此类操作应用于列表实例时，它将更改该确切实例中元素的顺序。</target>
        </trans-unit>
        <trans-unit id="be8a31aea4fdca8e3b9bdedb1958918e98cae1d2" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;collections-overview#map&quot;&gt;maps&lt;/a&gt;, types of both keys and values are user-defined. Key-based access to map entries enables various map-specific processing capabilities from getting a value by key to separate filtering of keys and values. On this page, we provide descriptions of the map processing functions from the standard library.</source>
          <target state="translated">在&lt;a href=&quot;collections-overview#map&quot;&gt;map中&lt;/a&gt;，键和值的类型都是用户定义的。对地图条目的基于键的访问启用了各种特定于地图的处理功能，从按键获取值到对键和值进行单独过滤。在此页面上，我们提供了来自标准库的地图处理功能的描述。</target>
        </trans-unit>
        <trans-unit id="7454358e40f9eaf26ccc7cd55f4c30f555918de5" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;mapping-primitive-data-types-from-c&quot;&gt;the previous tutorial&lt;/a&gt; we created a &lt;code&gt;lib.h&lt;/code&gt; file. This time, we are going to include those declarations directly into the &lt;code&gt;interop.def&lt;/code&gt; file, after the &lt;code&gt;---&lt;/code&gt; separator line:</source>
          <target state="translated">在&lt;a href=&quot;mapping-primitive-data-types-from-c&quot;&gt;上一个教程中，&lt;/a&gt;我们创建了一个 &lt;code&gt;lib.h&lt;/code&gt; 文件。这次，我们将在 &lt;code&gt;---&lt;/code&gt; 分隔符行之后将这些声明直接包含在 &lt;code&gt;interop.def&lt;/code&gt; 文件中：</target>
        </trans-unit>
        <trans-unit id="f0454a21172602b262219293f4778fc730c2daf2" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;build.gradle.kts&lt;/code&gt; (or &lt;code&gt;build.gradle&lt;/code&gt;) of your IDEA project, apply the CocoaPods plugin as well as the Kotlin Multiplatform plugin.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f2d8d96fc34753484a87526254e4a4f003f9c05" translate="yes" xml:space="preserve">
          <source>In Android projects, additional Kotlin source sets are created for each &lt;a href=&quot;https://developer.android.com/studio/build/#sourcesets&quot;&gt;Android source set&lt;/a&gt;. If the Android target has a name &lt;code&gt;foo&lt;/code&gt;, the Android source set &lt;code&gt;bar&lt;/code&gt; gets a Kotlin source set counterpart &lt;code&gt;fooBar&lt;/code&gt;. The Kotlin compilations, however, are able to consume Kotlin sources from all of the directories &lt;code&gt;src/bar/java&lt;/code&gt;, &lt;code&gt;src/bar/kotlin&lt;/code&gt;, and &lt;code&gt;src/fooBar/kotlin&lt;/code&gt;. Java sources are only read from the first of these directories.</source>
          <target state="translated">在Android项目中，会为每个&lt;a href=&quot;https://developer.android.com/studio/build/#sourcesets&quot;&gt;Android源集&lt;/a&gt;创建其他Kotlin源集。如果Android目标的名称为 &lt;code&gt;foo&lt;/code&gt; ，则Android源代码集 &lt;code&gt;bar&lt;/code&gt; 将获取Kotlin源集合对应项 &lt;code&gt;fooBar&lt;/code&gt; 。但是，Kotlin编译能够使用所有目录 &lt;code&gt;src/bar/java&lt;/code&gt; ， &lt;code&gt;src/bar/kotlin&lt;/code&gt; 和 &lt;code&gt;src/fooBar/kotlin&lt;/code&gt; 的 Kotlin源。仅从这些目录中的第一个读取Java源。</target>
        </trans-unit>
        <trans-unit id="33342ff8fe9e060731185ad7c136d99b9461055f" translate="yes" xml:space="preserve">
          <source>In Gradle</source>
          <target state="translated">在Gradle中</target>
        </trans-unit>
        <trans-unit id="9ffad76a20436e6770075c18f7fc5a623588a28f" translate="yes" xml:space="preserve">
          <source>In Gradle 5.3 and above, the module metadata is always used during dependency resolution, but publications don't include any module metadata by default. To enable module metadata publishing, add &lt;code&gt;enableFeaturePreview(&quot;GRADLE_METADATA&quot;)&lt;/code&gt; to the root project's &lt;code&gt;settings.gradle&lt;/code&gt; file. With older Gradle versions, this is also required for module metadata consumption.</source>
          <target state="translated">在Gradle 5.3及更高版本中，模块元数据始终在依赖关系解析期间使用，但默认情况下发布不包含任何模块元数据。要启用模块元数据发布，请将 &lt;code&gt;enableFeaturePreview(&quot;GRADLE_METADATA&quot;)&lt;/code&gt; 到根项目的 &lt;code&gt;settings.gradle&lt;/code&gt; 文件中。对于较旧的Gradle版本，模块元数据消耗也需要此功能。</target>
        </trans-unit>
        <trans-unit id="db8d93f584f6cd9be9c19cceb09290c42348f8b6" translate="yes" xml:space="preserve">
          <source>In Gradle command line parameters: add the parameter &lt;code&gt;-Pkotlin.incremental&lt;/code&gt; or &lt;code&gt;-Pkotlin.incremental.js&lt;/code&gt; with the boolean value reflecting the usage of incremental compilation. Note that in this case the parameter should be added to each subsequent build, and any build with disabled incremental compilation invalidates incremental caches.</source>
          <target state="translated">在Gradle命令行参数中：添加参数 &lt;code&gt;-Pkotlin.incremental&lt;/code&gt; 或 &lt;code&gt;-Pkotlin.incremental.js&lt;/code&gt; ，其布尔值反映增量编译的用法。请注意，在这种情况下，应将参数添加到每个后续构建中，并且任何禁用了增量编译的构建都会使增量缓存无效。</target>
        </trans-unit>
        <trans-unit id="d95af6982c4662ae34dc8dfd04c6f3d77bb71544" translate="yes" xml:space="preserve">
          <source>In Gradle configuration files: add the line &lt;code&gt;kotlin.incremental=&amp;lt;value&amp;gt;&lt;/code&gt; for Kotlin/JVM or &lt;code&gt;kotlin.incremental.js=&amp;lt;value&amp;gt;&lt;/code&gt; for Kotlin/JS projects either to &lt;code&gt;gradle.properties&lt;/code&gt; or to &lt;code&gt;local.properties&lt;/code&gt; file. &lt;code&gt;&amp;lt;value&amp;gt;&lt;/code&gt; is a boolean value reflecting the usage of incremental compilation.</source>
          <target state="translated">在摇篮配置文件：添加行 &lt;code&gt;kotlin.incremental=&amp;lt;value&amp;gt;&lt;/code&gt; 为科特林/ JVM或 &lt;code&gt;kotlin.incremental.js=&amp;lt;value&amp;gt;&lt;/code&gt; 为科特林/ JS项目要么 &lt;code&gt;gradle.properties&lt;/code&gt; 或 &lt;code&gt;local.properties&lt;/code&gt; 文件。 &lt;code&gt;&amp;lt;value&amp;gt;&lt;/code&gt; 是一个布尔值，反映了增量编译的用法。</target>
        </trans-unit>
        <trans-unit id="537c1a3af537507e4b627b3261006ddbdae522fd" translate="yes" xml:space="preserve">
          <source>In Gradle:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2d1d0c783432497ec07d157b951c4e78d7cc0b8" translate="yes" xml:space="preserve">
          <source>In IntelliJ IDEA go to &lt;em&gt;File -&amp;gt; New &amp;gt; Project&amp;hellip;&lt;/em&gt; and check the &lt;em&gt;Create from archetype&lt;/em&gt; box:</source>
          <target state="translated">在IntelliJ IDEA中，转到&lt;em&gt;File-&amp;gt; New&amp;gt; Project&amp;hellip;，&lt;/em&gt;然后选中&lt;em&gt;Create from archetype&lt;/em&gt;框：</target>
        </trans-unit>
        <trans-unit id="4d485a76c7a3760895d18fab529fc51f77b28063" translate="yes" xml:space="preserve">
          <source>In IntelliJ IDEA go to &lt;em&gt;File -&amp;gt; New &amp;gt; Project&amp;hellip;&lt;/em&gt;:</source>
          <target state="translated">在IntelliJ IDEA中，转到&lt;em&gt;File-&amp;gt; New&amp;gt; Project&amp;hellip;&lt;/em&gt;：</target>
        </trans-unit>
        <trans-unit id="9cc14db5a6e801d7da035df405c7d7827fc53b41" translate="yes" xml:space="preserve">
          <source>In JVM platform code:</source>
          <target state="translated">在JVM平台代码中。</target>
        </trans-unit>
        <trans-unit id="513ad5f28a98a53d38c2cd4b1ebf3e53ba78a0e9" translate="yes" xml:space="preserve">
          <source>In Java you specify &lt;code&gt;Dagger&lt;/code&gt; as &lt;code&gt;annotationProcessor&lt;/code&gt; (or &lt;code&gt;apt&lt;/code&gt;) dependency:</source>
          <target state="translated">在Java中，您将 &lt;code&gt;Dagger&lt;/code&gt; 指定为 &lt;code&gt;annotationProcessor&lt;/code&gt; （或 &lt;code&gt;apt&lt;/code&gt; ）依赖项：</target>
        </trans-unit>
        <trans-unit id="e76e330054ec3492dbde5d95b20d3d1c9ac12e6f" translate="yes" xml:space="preserve">
          <source>In Java, we are used to classes named &quot;*Utils&quot;: &lt;code&gt;FileUtils&lt;/code&gt;, &lt;code&gt;StringUtils&lt;/code&gt; and so on. The famous &lt;code&gt;java.util.Collections&lt;/code&gt; belongs to the same breed. And the unpleasant part about these Utils-classes is that the code that uses them looks like this:</source>
          <target state="translated">在Java中，我们习惯于使用名为&amp;ldquo; * Utils&amp;rdquo;的类： &lt;code&gt;FileUtils&lt;/code&gt; ， &lt;code&gt;StringUtils&lt;/code&gt; 等。著名的 &lt;code&gt;java.util.Collections&lt;/code&gt; 属于同一品种。关于这些Utils类的不愉快的部分是使用它们的代码看起来像这样：</target>
        </trans-unit>
        <trans-unit id="8310a54b24568803ae04cc82e73e4ed7d64a2ce9" translate="yes" xml:space="preserve">
          <source>In Java:</source>
          <target state="translated">在Java中。</target>
        </trans-unit>
        <trans-unit id="abb66954294d1e4253f6894befd4961b0fc88ece" translate="yes" xml:space="preserve">
          <source>In JavaScript you can define members either on a prototype or a class itself. I.e.:</source>
          <target state="translated">在JavaScript中,你可以在原型或类本身定义成员。即..:</target>
        </trans-unit>
        <trans-unit id="592ce5c07c0fe6dc9a4e0ec16760d4af84a287b3" translate="yes" xml:space="preserve">
          <source>In JavaScript you can define members either on a prototype or a class itself:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b73e80ab874eb4a673c8b0548f2f4b1a57e2e5b0" translate="yes" xml:space="preserve">
          <source>In Kotlin 1.0, code in the lambda passed to &lt;code&gt;td&lt;/code&gt; has access to three implicit receivers: the one passed to &lt;code&gt;table&lt;/code&gt;, to &lt;code&gt;tr&lt;/code&gt; and to &lt;code&gt;td&lt;/code&gt;. This allows you to call methods that make no sense in the context - for example to call &lt;code&gt;tr&lt;/code&gt; inside &lt;code&gt;td&lt;/code&gt; and thus to put a &lt;code&gt;&amp;lt;tr&amp;gt;&lt;/code&gt; tag in a &lt;code&gt;&amp;lt;td&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">在Kotlin 1.0中，传递给 &lt;code&gt;td&lt;/code&gt; 的lambda中的代码可以访问三个隐式接收器：一个传递给 &lt;code&gt;table&lt;/code&gt; ， &lt;code&gt;tr&lt;/code&gt; 和 &lt;code&gt;td&lt;/code&gt; 。这使您可以调用在上下文中没有意义的方法，例如，在 &lt;code&gt;td&lt;/code&gt; 内部调用 &lt;code&gt;tr&lt;/code&gt; ，从而在 &lt;code&gt;&amp;lt;td&amp;gt;&lt;/code&gt; 中放置 &lt;code&gt;&amp;lt;tr&amp;gt;&lt;/code&gt; 标记。</target>
        </trans-unit>
        <trans-unit id="faca07a0c2f2dcf45e7526d00d395e3cdc377fcb" translate="yes" xml:space="preserve">
          <source>In Kotlin 1.1, you can restrict that, so that only methods defined on the implicit receiver of &lt;code&gt;td&lt;/code&gt; will be available inside the lambda passed to &lt;code&gt;td&lt;/code&gt;. You do that by defining your annotation marked with the &lt;code&gt;@DslMarker&lt;/code&gt; meta-annotation and applying it to the base class of the tag classes.</source>
          <target state="translated">在Kotlin 1.1中，您可以对此进行限制，以便在传递给 &lt;code&gt;td&lt;/code&gt; 的lambda内只有在 &lt;code&gt;td&lt;/code&gt; 的隐式接收器上定义的方法才可用。为此，您可以定义带有 &lt;code&gt;@DslMarker&lt;/code&gt; 元注释的注释，并将其应用于标签类的基类。</target>
        </trans-unit>
        <trans-unit id="24a213ee88ffeaa2bec3378db48986b075744611" translate="yes" xml:space="preserve">
          <source>In Kotlin 1.1.x, use &lt;code&gt;kotlin-stdlib-jre7&lt;/code&gt; and &lt;code&gt;kotlin-stdlib-jre8&lt;/code&gt; instead.</source>
          <target state="translated">在Kotlin 1.1.x中，请改用 &lt;code&gt;kotlin-stdlib-jre7&lt;/code&gt; 和 &lt;code&gt;kotlin-stdlib-jre8&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6ea3af6627b279c964f114bd464c51ab696c689f" translate="yes" xml:space="preserve">
          <source>In Kotlin 1.3 it is possible for annotations to have nested classes, interfaces, objects, and companions:</source>
          <target state="translated">在Kotlin 1.3中,注释可以有嵌套的类、接口、对象和同伴。</target>
        </trans-unit>
        <trans-unit id="3098d1aa730f31e91846c87eaae7ac71342cdc7e" translate="yes" xml:space="preserve">
          <source>In Kotlin 1.3, it is now possible to capture the &lt;code&gt;when&lt;/code&gt; subject into variable:</source>
          <target state="translated">在Kotlin 1.3中，现在可以将 &lt;code&gt;when&lt;/code&gt; 主题捕获为变量：</target>
        </trans-unit>
        <trans-unit id="2a99d2573a55fb319e350044cce69239e344a488" translate="yes" xml:space="preserve">
          <source>In Kotlin functions can be declared at top level in a file, meaning you do not need to create a class to hold a function, which you are required to do in languages such as Java, C# or Scala. In addition to top level functions, Kotlin functions can also be declared local, as member functions and extension functions.</source>
          <target state="translated">在Kotlin中,函数可以在文件中进行顶层声明,这意味着你不需要创建一个类来容纳一个函数,而在Java、C#或Scala等语言中则需要这样做。除了顶层函数外,Kotlin函数还可以作为成员函数和扩展函数进行本地声明。</target>
        </trans-unit>
        <trans-unit id="d5176ee2358fd7911cf590e90f48fd7d921131e2" translate="yes" xml:space="preserve">
          <source>In Kotlin there are two types of equality:</source>
          <target state="translated">在Kotlin中,有两种类型的平等。</target>
        </trans-unit>
        <trans-unit id="1307e7346626ce5c88b95620e1843731ae3969f4" translate="yes" xml:space="preserve">
          <source>In Kotlin this line can be concisely parsed with the following statement using &lt;a href=&quot;../reference/multi-declarations#destructuring-declarations&quot;&gt;destructuring declaration&lt;/a&gt; from a list of integers:</source>
          <target state="translated">在Kotlin中，可以使用以下语句使用整数列表中的&lt;a href=&quot;../reference/multi-declarations#destructuring-declarations&quot;&gt;解构声明&lt;/a&gt;来简洁地解析此行：</target>
        </trans-unit>
        <trans-unit id="d2cb95a39c5087932a02f405cc63f954a5dedc22" translate="yes" xml:space="preserve">
          <source>In Kotlin you can provide upper bounds for a generic type. Objective-C also supports this, but that support is unavailable in more complex cases, and is currently not supported in the Kotlin - Objective-C interop. The exception here being a non-null upper bound will make Objective-C methods/properties non-null.</source>
          <target state="translated">在Kotlin中,你可以为一个通用类型提供上界。Objective-C也支持这样做,但在更复杂的情况下,这种支持是不可用的,而且目前Kotlin-Objective-C互操作中也不支持。这里的例外是一个非空的上界将使Objective-C方法/属性非空。</target>
        </trans-unit>
        <trans-unit id="ef29e345af9c063df71b3f01a21f78a928c57611" translate="yes" xml:space="preserve">
          <source>In Kotlin you can't work with fields directly, you work with &lt;a href=&quot;../reference/properties&quot;&gt;properties&lt;/a&gt;. You annotate the property:</source>
          <target state="translated">在Kotlin中，您不能直接使用字段，而只能使用&lt;a href=&quot;../reference/properties&quot;&gt;properties&lt;/a&gt;。您注释属性：</target>
        </trans-unit>
        <trans-unit id="b1411aa40ea7c5b9a0de303333e37baf632f1665" translate="yes" xml:space="preserve">
          <source>In Kotlin you have to add the &lt;code&gt;kotlin-kapt&lt;/code&gt; plugin to enable &lt;code&gt;kapt&lt;/code&gt;, and then replace &lt;code&gt;annotationProcessor&lt;/code&gt; with &lt;code&gt;kapt&lt;/code&gt;:</source>
          <target state="translated">在Kotlin中，您必须添加 &lt;code&gt;kotlin-kapt&lt;/code&gt; 插件以启用 &lt;code&gt;kapt&lt;/code&gt; ，然后用 &lt;code&gt;kapt&lt;/code&gt; 替换 &lt;code&gt;annotationProcessor&lt;/code&gt; 处理程序：</target>
        </trans-unit>
        <trans-unit id="da7a2b73e175cb7362740b3fbdff60c8cc8e5724" translate="yes" xml:space="preserve">
          <source>In Kotlin you specify the dependencies in a similar to Java way using &lt;a href=&quot;../reference/kapt&quot;&gt;Kotlin Annotation processing tool&lt;/a&gt; (&lt;code&gt;kapt&lt;/code&gt;) instead of &lt;code&gt;annotationProcessor&lt;/code&gt;.</source>
          <target state="translated">在科特林您使用指定一个类似于Java的方式依赖&lt;a href=&quot;../reference/kapt&quot;&gt;科特林注释处理工具&lt;/a&gt;（ &lt;code&gt;kapt&lt;/code&gt; 代替） &lt;code&gt;annotationProcessor&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0a2601b06937bb12c0744830de8e7b372473464e" translate="yes" xml:space="preserve">
          <source>In Kotlin, &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/plus&quot;&gt;&lt;code&gt;plus&lt;/code&gt;&lt;/a&gt; (&lt;code&gt;+&lt;/code&gt;) and &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/minus&quot;&gt;&lt;code&gt;minus&lt;/code&gt;&lt;/a&gt; (&lt;code&gt;-&lt;/code&gt;) operators are defined for collections. They take a collection as the first operand; the second operand can be either an element or another collection. The return value is a new read-only collection:</source>
          <target state="translated">在Kotlin中，为集合定义了&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/plus&quot;&gt; &lt;code&gt;plus&lt;/code&gt; &lt;/a&gt;（ &lt;code&gt;+&lt;/code&gt; ）和&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/minus&quot;&gt; &lt;code&gt;minus&lt;/code&gt; &lt;/a&gt;（ &lt;code&gt;-&lt;/code&gt; ）。他们将集合作为第一个操作数。第二个操作数可以是一个元素或另一个集合。返回值是一个新的只读集合：</target>
        </trans-unit>
        <trans-unit id="78f4990d53a6e7c8067b2fe1adea30492b815286" translate="yes" xml:space="preserve">
          <source>In Kotlin, &lt;em&gt;if&lt;/em&gt; can also be used as an expression:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="630fd5574aed5de24f8dfa12e49c30f220082837" translate="yes" xml:space="preserve">
          <source>In Kotlin, &lt;em&gt;if&lt;/em&gt; is an expression, i.e. it returns a value. Therefore there is no ternary operator (condition ? then : else), because ordinary &lt;em&gt;if&lt;/em&gt; works fine in this role.</source>
          <target state="translated">在Kotlin中，&lt;em&gt;if&lt;/em&gt;是一个表达式，即它返回一个值。因此，没有三元运算符（条件？then：else），因为普通&lt;em&gt;if&lt;/em&gt;在此角色下工作良好。</target>
        </trans-unit>
        <trans-unit id="449834b1db02375da0148e9e57aea36e01ccf956" translate="yes" xml:space="preserve">
          <source>In Kotlin, all exceptions are unchecked, meaning that the compiler does not force you to catch any of them. So, when you call a Java method that declares a checked exception, Kotlin does not force you to do anything:</source>
          <target state="translated">在Kotlin中,所有的异常都是未检查的,这意味着编译器不会强迫你捕获任何异常。因此,当你调用一个声明了检查异常的Java方法时,Kotlin不会强迫你做任何事情。</target>
        </trans-unit>
        <trans-unit id="ccb7acc6feff10a66296746e0c93a95c37a6267f" translate="yes" xml:space="preserve">
          <source>In Kotlin, everything is an object in the sense that we can call member functions and properties on any variable. Some of the types can have a special internal representation - for example, numbers, characters and booleans can be represented as primitive values at runtime - but to the user they look like ordinary classes. In this section we describe the basic types used in Kotlin: numbers, characters, booleans, arrays, and strings.</source>
          <target state="translated">在Kotlin中,所有的东西都是一个对象,我们可以在任何变量上调用成员函数和属性。有些类型可以有特殊的内部表示--例如,数字、字符和booleans可以在运行时表示为基元值--但对用户来说,它们看起来就像普通的类。在本节中,我们将描述Kotlin中使用的基本类型:数字、字符、booleans、数组和字符串。</target>
        </trans-unit>
        <trans-unit id="bcc1b8c2a992c6c34b455f92da91c74149cd8719" translate="yes" xml:space="preserve">
          <source>In Kotlin, functional types are represented as generic classes taking a different number of parameters: &lt;code&gt;Function0&amp;lt;R&amp;gt;&lt;/code&gt;, &lt;code&gt;Function1&amp;lt;P0, R&amp;gt;&lt;/code&gt;, &lt;code&gt;Function2&amp;lt;P0, P1, R&amp;gt;&lt;/code&gt;, &amp;hellip; This approach has a problem in that this list is finite, and it currently ends with &lt;code&gt;Function22&lt;/code&gt;.</source>
          <target state="translated">在Kotlin中，功能类型表示为具有不同数量参数的泛型类： &lt;code&gt;Function0&amp;lt;R&amp;gt;&lt;/code&gt; ， &lt;code&gt;Function1&amp;lt;P0, R&amp;gt;&lt;/code&gt; ， &lt;code&gt;Function2&amp;lt;P0, P1, R&amp;gt;&lt;/code&gt; &amp;hellip;&amp;hellip;&amp;hellip;这种方法的问题在于此列表是有限的，当前以 &lt;code&gt;Function22&lt;/code&gt; 结尾。</target>
        </trans-unit>
        <trans-unit id="dda94f8bd95fbc2c5d984c18e048611fb7b42dbc" translate="yes" xml:space="preserve">
          <source>In Kotlin, implementation inheritance is regulated by the following rule: if a class inherits many implementations of the same member from its immediate superclasses, it must override this member and provide its own implementation (perhaps, using one of the inherited ones). To denote the supertype from which the inherited implementation is taken, we use &lt;em&gt;super&lt;/em&gt; qualified by the supertype name in angle brackets, e.g. &lt;code&gt;super&amp;lt;Base&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">在Kotlin中，实现继承受以下规则支配：如果一个类从其直接超类继承了同一成员的许多实现，则它必须重写此成员并提供自己的实现（也许使用继承的一个）。来表示从该继承执行取超型，我们使用&lt;em&gt;超级&lt;/em&gt;尖括号合格由超类型名称，例如 &lt;code&gt;super&amp;lt;Base&amp;gt;&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="7e8de20bd90cf59ff062bcee3a6b6475fd0af4bb" translate="yes" xml:space="preserve">
          <source>In Kotlin, implementation inheritance is regulated by the following rule: if a class inherits multiple implementations of the same member from its immediate superclasses, it must override this member and provide its own implementation (perhaps, using one of the inherited ones). To denote the supertype from which the inherited implementation is taken, we use &lt;em&gt;super&lt;/em&gt; qualified by the supertype name in angle brackets, e.g. &lt;code&gt;super&amp;lt;Base&amp;gt;&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7dcc76eece2b8bf2e4ff6b5b682eb767b78c7f50" translate="yes" xml:space="preserve">
          <source>In Kotlin, importing is a compile-time concept - importing something does not actually cause any code to run (unlike Python, where all top-level statements in a file are executed at import time). Therefore, circular imports are allowed, but they might suggest a design problem in your code. However, during execution, a class will be loaded the first time it (or any of its properties or functions) is referenced, and class loading causes &lt;a href=&quot;objects-and-companion-objects#companion-objects&quot;&gt;companion objects&lt;/a&gt; to be initialized - this can lead to runtime exceptions if you have circular dependencies.</source>
          <target state="translated">在Kotlin中，导入是一个编译时概念-导入内容实际上不会导致任何代码运行（与Python不同，Python中文件中的所有顶级语句都在导入时执行）。因此，允许循环导入，但是它们可能会在您的代码中提示设计问题。但是，在执行期间，将在首次引用类（或其任何属性或函数）时加载类，并且类加载会导致初始化&lt;a href=&quot;objects-and-companion-objects#companion-objects&quot;&gt;伴随对象&lt;/a&gt; -如果您具有循环依赖项，则可能导致运行时异常。</target>
        </trans-unit>
        <trans-unit id="9724d2f4d0f2fb74f7ee2235878c749f495a0bad" translate="yes" xml:space="preserve">
          <source>In Kotlin, polymorphism is achieved via the class hierarchy, in such a way that it is impossible to run into a situation where a property or function is missing. The basic rule is that a variable/property/parameter whose declared type is &lt;code&gt;A&lt;/code&gt; may refer to an instance of a class &lt;code&gt;B&lt;/code&gt; if and only if &lt;code&gt;B&lt;/code&gt; is a subtype of &lt;code&gt;A&lt;/code&gt;. This means that either, &lt;code&gt;A&lt;/code&gt; must be a class and &lt;code&gt;B&lt;/code&gt; must be a subclass of &lt;code&gt;A&lt;/code&gt;, or that &lt;code&gt;A&lt;/code&gt; must be an interface and &lt;code&gt;B&lt;/code&gt; must be a class that implements that interface or be a subclass of a class that does. With our classes and interfaces from the previous sections, we can define these functions:</source>
          <target state="translated">在Kotlin中，多态性是通过类层次结构来实现的，这样就不可能碰到缺少属性或功能的情况。基本规则是，当且仅当 &lt;code&gt;B&lt;/code&gt; 是 &lt;code&gt;A&lt;/code&gt; 的子类型时，声明类型为 &lt;code&gt;A&lt;/code&gt; 的变量/属性/参数才可以引用 &lt;code&gt;B&lt;/code&gt; 类的实例。这意味着，要么 &lt;code&gt;A&lt;/code&gt; 必须是一个类，而 &lt;code&gt;B&lt;/code&gt; 必须是 &lt;code&gt;A&lt;/code&gt; 的子类，要么 &lt;code&gt;A&lt;/code&gt; 必须是一个接口，而 &lt;code&gt;B&lt;/code&gt; 必须是实现该接口的类，或者是该类的子类。使用上一部分中的类和接口，我们可以定义以下功能：</target>
        </trans-unit>
        <trans-unit id="0ea4efcee086c70a1dc18d5edfeb999729e27f06" translate="yes" xml:space="preserve">
          <source>In Kotlin, semicolons are optional, and therefore line breaks are significant. The language design assumes Java-style braces, and you may encounter surprising behavior if you try to use a different formatting style.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ea952e978cda6b66f0b076e1bf4afae5776a252" translate="yes" xml:space="preserve">
          <source>In Kotlin, the default implementation of &lt;code&gt;List&lt;/code&gt; is &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-array-list/index&quot;&gt;&lt;code&gt;ArrayList&lt;/code&gt;&lt;/a&gt; which you can think of as a resizable array.</source>
          <target state="translated">在Kotlin中， &lt;code&gt;List&lt;/code&gt; 的默认实现是&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-array-list/index&quot;&gt; &lt;code&gt;ArrayList&lt;/code&gt; &lt;/a&gt;，您可以将其视为可调整大小的数组。</target>
        </trans-unit>
        <trans-unit id="b0f2e47b033955ac0009c7acc59029af121c0f6e" translate="yes" xml:space="preserve">
          <source>In Kotlin, the expression for a default value is evaluated every time the function is invoked. Therefore, you will avoid the above trap as long as you use an expression that produces a new list every time it is evaluated:</source>
          <target state="translated">在Kotlin中,每次调用函数时都会对默认值的表达式进行评估。因此,只要使用每次评估都会产生一个新列表的表达式,就可以避免上述陷阱。</target>
        </trans-unit>
        <trans-unit id="1f711d573309109397667a32c94fd541ceecdc60" translate="yes" xml:space="preserve">
          <source>In Kotlin, the orders of objects can be defined in several ways.</source>
          <target state="translated">在Kotlin中,对象的顺序可以用几种方式来定义。</target>
        </trans-unit>
        <trans-unit id="2339e3beff8d4c7968bd5b14328be82bd9a5b046" translate="yes" xml:space="preserve">
          <source>In Kotlin, the type system distinguishes between references that can hold &lt;em&gt;null&lt;/em&gt; (nullable references) and those that can not (non-null references). For example, a regular variable of type &lt;code&gt;String&lt;/code&gt; can not hold &lt;em&gt;null&lt;/em&gt;:</source>
          <target state="translated">在Kotlin中，类型系统区分可以保存&lt;em&gt;null的&lt;/em&gt;引用（可为空的引用）和不能保存的引用（非null引用）。例如， &lt;code&gt;String&lt;/code&gt; 类型的常规变量不能包含&lt;em&gt;null&lt;/em&gt;：</target>
        </trans-unit>
        <trans-unit id="832014b08edc07489a35f79862dd60fe09daab6f" translate="yes" xml:space="preserve">
          <source>In Kotlin, there is a convention: if the last parameter of a function is a function, then a lambda expression passed as the corresponding argument can be placed outside the parentheses:</source>
          <target state="translated">在Kotlin中,有一个惯例:如果一个函数的最后一个参数是函数,那么作为相应参数传递的lambda表达式可以放在括号外。</target>
        </trans-unit>
        <trans-unit id="c2a3923bf671e235e84ea1d045b896ec7fad1d7d" translate="yes" xml:space="preserve">
          <source>In Kotlin, there is a way to explain this sort of thing to the compiler. This is called &lt;strong&gt;declaration-site variance&lt;/strong&gt;: we can annotate the &lt;strong&gt;type parameter&lt;/strong&gt;&lt;code&gt;T&lt;/code&gt; of Source to make sure that it is only &lt;strong&gt;returned&lt;/strong&gt; (produced) from members of &lt;code&gt;Source&amp;lt;T&amp;gt;&lt;/code&gt;, and never consumed. To do this we provide the &lt;strong&gt;out&lt;/strong&gt; modifier:</source>
          <target state="translated">在Kotlin中，有一种方法可以向编译器解释这种情况。这称为&lt;strong&gt;声明位置方差&lt;/strong&gt;：我们可以对Source 的&lt;strong&gt;类型参数&lt;/strong&gt; &lt;code&gt;T&lt;/code&gt; 进行注释，以确保仅从 &lt;code&gt;Source&amp;lt;T&amp;gt;&lt;/code&gt; 成员&lt;strong&gt;返回&lt;/strong&gt;（产生）该&lt;strong&gt;参数&lt;/strong&gt;，而从不使用它。为此，我们提供&lt;strong&gt;out&lt;/strong&gt;修饰符：&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="feddf47fe54f2c3f729a6d26efa190cb7e973f88" translate="yes" xml:space="preserve">
          <source>In Kotlin, unlike Java or C#, classes do not have static methods. In most cases, it's recommended to simply use package-level functions instead.</source>
          <target state="translated">在Kotlin中,与Java或C#不同,类没有静态方法。在大多数情况下,建议使用包级函数来代替。</target>
        </trans-unit>
        <trans-unit id="d5e92ec06e3b15b62ad5ec58ebeffa93765ab71a" translate="yes" xml:space="preserve">
          <source>In Kotlin, we can only use a normal, unqualified &lt;code&gt;return&lt;/code&gt; to exit a named function or an anonymous function. This means that to exit a lambda, we have to use a &lt;a href=&quot;returns#return-at-labels&quot;&gt;label&lt;/a&gt;, and a bare &lt;code&gt;return&lt;/code&gt; is forbidden inside a lambda, because a lambda cannot make the enclosing function return:</source>
          <target state="translated">在Kotlin中，我们只能使用普通的不合格 &lt;code&gt;return&lt;/code&gt; 来退出命名函数或匿名函数。这意味着要退出lambda，我们必须使用&lt;a href=&quot;returns#return-at-labels&quot;&gt;label&lt;/a&gt;，并且lambda内禁止裸 &lt;code&gt;return&lt;/code&gt; ，因为lambda无法使封闭函数返回：</target>
        </trans-unit>
        <trans-unit id="0bc591251b1866272d3defd4ab24986b180f3e99" translate="yes" xml:space="preserve">
          <source>In Kotlin/JS implementation of StringBuilder the initial capacity has no effect on the further performance of operations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d25d5f146a0d36095ac2d2fbada4dfa30e5c1b3" translate="yes" xml:space="preserve">
          <source>In Kotlin/JS implementation of StringBuilder the size of the backing storage is always equal to the length of the string builder.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c5a4446d1a6bca7a876f80da83f707725750c3e" translate="yes" xml:space="preserve">
          <source>In Kotlin/JS implementation of StringBuilder the size of the backing storage is not extended to comply the given &lt;a href=&quot;ensure-capacity#kotlin.text.StringBuilder%24ensureCapacity(kotlin.Int)/minimumCapacity&quot;&gt;minimumCapacity&lt;/a&gt;, thus calling this method has no effect on the further performance of operations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b416b284c329b83d138fdf71a7f58ad406d7c9b" translate="yes" xml:space="preserve">
          <source>In Maven</source>
          <target state="translated">在Maven中</target>
        </trans-unit>
        <trans-unit id="9ce095374b679dfd053dccebdba1f6ce80a67e34" translate="yes" xml:space="preserve">
          <source>In Maven, enable the &lt;code&gt;jpa&lt;/code&gt; plugin:</source>
          <target state="translated">在Maven中，启用 &lt;code&gt;jpa&lt;/code&gt; 插件：</target>
        </trans-unit>
        <trans-unit id="4cf1f43e65b88c5f6958702897fafbb7af63f2e9" translate="yes" xml:space="preserve">
          <source>In Maven, enable the &lt;code&gt;spring&lt;/code&gt; plugin:</source>
          <target state="translated">在Maven中，启用 &lt;code&gt;spring&lt;/code&gt; 插件：</target>
        </trans-unit>
        <trans-unit id="14be0db4481edc4ab423c4343db7ab0c7cfdc4a9" translate="yes" xml:space="preserve">
          <source>In Maven, the &lt;code&gt;spring&lt;/code&gt; plugin is provided by the &lt;code&gt;kotlin-maven-allopen&lt;/code&gt; plugin dependency, so to enable it:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2fde5916b654de021cf5316e7c8446b2d071c3b3" translate="yes" xml:space="preserve">
          <source>In Maven:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6dc887971001bc1cd4775889e759bfb59211b14c" translate="yes" xml:space="preserve">
          <source>In Python, function names must be unique within a module or a class. In Kotlin, we can &lt;em&gt;overload&lt;/em&gt; functions: there can be multiple declarations of functions that have the same name. Overloaded functions must be distinguishable from each other through their parameter lists. (The types of the parameter list, together with the return type, is known as a function's &lt;em&gt;signature&lt;/em&gt;, but the return type cannot be used to disambiguate overloaded functions.) For example, we can have both of these functions in the same file:</source>
          <target state="translated">在Python中，函数名称在模块或类中必须唯一。在Kotlin中，我们可以&lt;em&gt;重载&lt;/em&gt;函数：可以有多个具有相同名称的函数声明。重载的函数必须通过它们的参数列表相互区分。（参数列表的类型与返回类型一起被称为函数的&lt;em&gt;签名&lt;/em&gt;，但是返回类型不能用于消除重载函数的歧义。）例如，我们可以在同一个文件中同时拥有这两个函数：</target>
        </trans-unit>
        <trans-unit id="1c0f7f91981a6ecf109d226f21e3069c8aabc15a" translate="yes" xml:space="preserve">
          <source>In Python, the expression for a default value is evaluated once, at function definition time. That leads to this classic trap, where the developer hopes to get a new, empty list every time the function is called without a value for &lt;code&gt;numbers&lt;/code&gt;, but instead, the same list is being used every time:</source>
          <target state="translated">在Python中，默认值的表达式在函数定义时被评估一次。这导致了这种经典的陷阱，开发人员希望每次调用该函数时都获得一个新的空列表，而没有 &lt;code&gt;numbers&lt;/code&gt; 的值，但是每次都使用相同的列表：</target>
        </trans-unit>
        <trans-unit id="cd3d02ed8996a5f9eaf8b21aad3a4aaadb80de18" translate="yes" xml:space="preserve">
          <source>In a &lt;code&gt;when&lt;/code&gt; statement, if a branch is more than a single line, consider separating it from adjacent case blocks with a blank line:</source>
          <target state="translated">在 &lt;code&gt;when&lt;/code&gt; 语句中，如果分支多于一行，请考虑使用空行将其与相邻的case块分开：</target>
        </trans-unit>
        <trans-unit id="3a1b36cf0bd1ee7bba19fe0760cca000ad48b849" translate="yes" xml:space="preserve">
          <source>In a long-running application you might need fine-grained control on your background coroutines. For example, a user might have closed the page that launched a coroutine and now its result is no longer needed and its operation can be cancelled. The &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/launch.html&quot;&gt;launch&lt;/a&gt; function returns a &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/index.html&quot;&gt;Job&lt;/a&gt; that can be used to cancel the running coroutine:</source>
          <target state="translated">在长时间运行的应用程序中，您可能需要对后台协程进行细粒度的控制。例如，用户可能已经关闭了启动协程的页面，现在不再需要其结果并且可以取消其操作。在&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/launch.html&quot;&gt;推出&lt;/a&gt;函数返回一个&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/index.html&quot;&gt;作业&lt;/a&gt;，可用于取消运行协程：</target>
        </trans-unit>
        <trans-unit id="e333c99581fbe52762649b5ab0c35c55ffcd093c" translate="yes" xml:space="preserve">
          <source>In a member of a &lt;a href=&quot;classes#inheritance&quot;&gt;class&lt;/a&gt;, &lt;em&gt;this&lt;/em&gt; refers to the current object of that class.</source>
          <target state="translated">在&lt;a href=&quot;classes#inheritance&quot;&gt;类&lt;/a&gt;的成员中，&lt;em&gt;这&lt;/em&gt;是指该类的当前对象。</target>
        </trans-unit>
        <trans-unit id="15a56874c4866fabbe734af8a3fb102f28e0b12f" translate="yes" xml:space="preserve">
          <source>In a nutshell, you can use libraries such as &lt;a href=&quot;https://google.github.io/dagger/&quot;&gt;Dagger&lt;/a&gt; or &lt;a href=&quot;https://developer.android.com/topic/libraries/data-binding/index.html&quot;&gt;Data Binding&lt;/a&gt; in your Kotlin projects.</source>
          <target state="translated">简而言之，您可以在Kotlin项目中使用&lt;a href=&quot;https://google.github.io/dagger/&quot;&gt;Dagger&lt;/a&gt;或&lt;a href=&quot;https://developer.android.com/topic/libraries/data-binding/index.html&quot;&gt;Data Binding之类的&lt;/a&gt;库。</target>
        </trans-unit>
        <trans-unit id="5544e7dcfdd04da3eceaae6a1614ec1e4f550da9" translate="yes" xml:space="preserve">
          <source>In addition to &lt;strong&gt;out&lt;/strong&gt;, Kotlin provides a complementary variance annotation: &lt;strong&gt;in&lt;/strong&gt;. It makes a type parameter &lt;strong&gt;contravariant&lt;/strong&gt;: it can only be consumed and never produced. A good example of a contravariant type is &lt;code&gt;Comparable&lt;/code&gt;:</source>
          <target state="translated">除了&lt;strong&gt;out之外&lt;/strong&gt;，Kotlin还提供了补充的方差注释：&lt;strong&gt;in&lt;/strong&gt;。它使类型参数&lt;strong&gt;互变&lt;/strong&gt;：它只能被使用而不能产生。可变类型的一个很好的例子是 &lt;code&gt;Comparable&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="c6329f208d955601deb101d4b33fc1acdf8accac" translate="yes" xml:space="preserve">
          <source>In addition to common operations for &lt;a href=&quot;collection-parts&quot;&gt;Retrieving Collection Parts&lt;/a&gt;, lists provide the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-list/sub-list&quot;&gt;&lt;code&gt;subList()&lt;/code&gt;&lt;/a&gt; function that returns a view of the specified elements range as a list. Thus, if an element of the original collection changes, it also changes in the previously created sublists and vice versa.</source>
          <target state="translated">除了用于&lt;a href=&quot;collection-parts&quot;&gt;检索集合零件的&lt;/a&gt;常用操作之外，列表还提供&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-list/sub-list&quot;&gt; &lt;code&gt;subList()&lt;/code&gt; &lt;/a&gt;函数，该函数将指定元素范围的视图作为列表返回。因此，如果原始集合的元素发生变化，则它在先前创建的子列表中也会发生变化，反之亦然。</target>
        </trans-unit>
        <trans-unit id="9674c96ddd7757af7200ad4daae22ce260bb2047" translate="yes" xml:space="preserve">
          <source>In addition to removing elements, the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-mutable-list-iterator/index&quot;&gt;&lt;code&gt;MutableListIterator&lt;/code&gt;&lt;/a&gt; can also insert and replace elements while iterating the list.</source>
          <target state="translated">除了删除元素，&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-mutable-list-iterator/index&quot;&gt; &lt;code&gt;MutableListIterator&lt;/code&gt; &lt;/a&gt;还可以在迭代列表时插入和替换元素。</target>
        </trans-unit>
        <trans-unit id="38a6e3c954dde3e3eb6edba41ad0b83ce52bd70c" translate="yes" xml:space="preserve">
          <source>In addition to scope functions, the standard library contains the functions &lt;code&gt;takeIf&lt;/code&gt; and &lt;code&gt;takeUnless&lt;/code&gt;. These functions let you embed checks of the object state in call chains.</source>
          <target state="translated">除范围函数外，标准库还包含函数 &lt;code&gt;takeIf&lt;/code&gt; 和 &lt;code&gt;takeUnless&lt;/code&gt; 。这些功能使您可以将对对象状态的检查嵌入到调用链中。</target>
        </trans-unit>
        <trans-unit id="acfd15e725bcfef6236f16c4782a0f3dc2126f4d" translate="yes" xml:space="preserve">
          <source>In addition to that, you can use &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.js/js&quot;&gt;KClass.js&lt;/a&gt; to access the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.js/-js-class/index&quot;&gt;JsClass&lt;/a&gt; instance corresponding to the class. The &lt;code&gt;JsClass&lt;/code&gt; instance itself is a reference to the constructor function. This can be used to interoperate with JS functions that expect a reference to a constructor.</source>
          <target state="translated">除此之外，您还可以使用&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.js/js&quot;&gt;KClass.js&lt;/a&gt;访问与&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.js/-js-class/index&quot;&gt;该类&lt;/a&gt;相对应的JsClass实例。该 &lt;code&gt;JsClass&lt;/code&gt; 实例本身的构造函数的引用。这可用于与期望引用构造函数的JS函数进行互操作。</target>
        </trans-unit>
        <trans-unit id="36b7ccec26bcb88294baf54023cc9ae72ecaa90f" translate="yes" xml:space="preserve">
          <source>In addition to the &lt;a href=&quot;typecasts#unsafe-cast-operator&quot;&gt;&quot;unsafe&quot; cast operator&lt;/a&gt;&lt;code&gt;as&lt;/code&gt;, which throws a &lt;code&gt;ClassCastException&lt;/code&gt; in case a cast is not possible, Kotlin/JS also provides &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.js/unsafe-cast&quot;&gt;&lt;code&gt;unsafeCast&amp;lt;T&amp;gt;()&lt;/code&gt;&lt;/a&gt;. When using &lt;code&gt;unsafeCast&lt;/code&gt;, &lt;em&gt;no type checking is done at all&lt;/em&gt; during runtime. For example, consider the following two methods:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5594aa712f7692fd1a48c40180fe2939a4654a66" translate="yes" xml:space="preserve">
          <source>In addition to the &lt;code&gt;kotlin-gradle-plugin&lt;/code&gt; dependency shown above, you need to add a dependency on the Kotlin standard library:</source>
          <target state="translated">除了上面显示的 &lt;code&gt;kotlin-gradle-plugin&lt;/code&gt; 依赖项之外，您还需要添加对Kotlin标准库的依赖项：</target>
        </trans-unit>
        <trans-unit id="ea7c2f23dd342e78eba03e7edea502fd9fbb6ef4" translate="yes" xml:space="preserve">
          <source>In addition to the build tasks, the Gradle build includes helpful tasks to run the application directly via &lt;code&gt;runDebugExecutableNative&lt;/code&gt; and &lt;code&gt;runReleaseExecutableNative&lt;/code&gt;.</source>
          <target state="translated">除了构建任务之外，Gradle构建还包括一些有用的任务，这些任务可通过 &lt;code&gt;runDebugExecutableNative&lt;/code&gt; 和 &lt;code&gt;runReleaseExecutableNative&lt;/code&gt; 直接运行应用程序。</target>
        </trans-unit>
        <trans-unit id="1d5b7f7ad1a1556c56ce8e8eb4580dccfbc4c337" translate="yes" xml:space="preserve">
          <source>In addition to the collection modification operations described in &lt;a href=&quot;collection-write&quot;&gt;Collection Write Operations&lt;/a&gt;, &lt;a href=&quot;collections-overview#collection-types&quot;&gt;mutable&lt;/a&gt; lists support specific write operations. Such operations use the index to access elements to broaden the list modification capabilities.</source>
          <target state="translated">除了&amp;ldquo;收集&lt;a href=&quot;collection-write&quot;&gt;写&lt;/a&gt;操作&amp;rdquo;中描述的收集修改操作之外，&lt;a href=&quot;collections-overview#collection-types&quot;&gt;可变&lt;/a&gt;列表还支持特定的写操作。这样的操作使用索引来访问元素以扩展列表修改功能。</target>
        </trans-unit>
        <trans-unit id="edff8af41569526ee6f34e250c39b84435f2d3a3" translate="yes" xml:space="preserve">
          <source>In addition to the command line compiler and IntelliJ IDEA, you can also build Kotlin projects with Ant, Maven, and Gradle.</source>
          <target state="translated">除了命令行编译器和IntelliJ IDEA,你还可以用Ant、Maven和Gradle构建Kotlin项目。</target>
        </trans-unit>
        <trans-unit id="13939289a96ed1a1e50225139ac3fbd7b0bc2be9" translate="yes" xml:space="preserve">
          <source>In addition to the coroutine scope provided by different builders, it is possible to declare your own scope using &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/coroutine-scope.html&quot;&gt;coroutineScope&lt;/a&gt; builder. It creates a coroutine scope and does not complete until all launched children complete. The main difference between &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/run-blocking.html&quot;&gt;runBlocking&lt;/a&gt; and &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/coroutine-scope.html&quot;&gt;coroutineScope&lt;/a&gt; is that the latter does not block the current thread while waiting for all children to complete.</source>
          <target state="translated">除了不同构建器提供的协程作用域之外，还可以使用&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/coroutine-scope.html&quot;&gt;coroutineScope&lt;/a&gt;构建器声明自己的作用域。它创建一个协程范围，并且直到所有启动的子级都完成后才完成。&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/run-blocking.html&quot;&gt;runBlocking&lt;/a&gt;和&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/coroutine-scope.html&quot;&gt;coroutineScope&lt;/a&gt;之间的主要区别在于，后者在等待所有子级完成时不会阻塞当前线程。</target>
        </trans-unit>
        <trans-unit id="e5077ac7f8cceff0957d255db71b0d1a0a24a0ba" translate="yes" xml:space="preserve">
          <source>In addition to the coroutine scope provided by different builders, it is possible to declare your own scope using the &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/coroutine-scope.html&quot;&gt;coroutineScope&lt;/a&gt; builder. It creates a coroutine scope and does not complete until all launched children complete.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="063fa2441ff30c74a010fc27ec5f2018d7ca4ef2" translate="yes" xml:space="preserve">
          <source>In addition to the output JavaScript file, the plugin by default creates an additional JS file with binary descriptors. This file is required if you're building a reusable library that other Kotlin modules can depend on, and should be distributed together with the result of translation. The generation is controlled by the &lt;code&gt;kotlinOptions.metaInfo&lt;/code&gt; option:</source>
          <target state="translated">除了输出的JavaScript文件之外，该插件默认情况下还会创建一个带有二进制描述符的附加JS文件。如果您要构建其他Kotlin模块可以依赖的可重用库，则此文件是必需的，并且应与转换结果一起分发。生成由 &lt;code&gt;kotlinOptions.metaInfo&lt;/code&gt; 选项控制：</target>
        </trans-unit>
        <trans-unit id="4c8c93a8699f08045725902510444a7e2a812bf3" translate="yes" xml:space="preserve">
          <source>In addition, Rx does introduce a somewhat nicer approach to error handling.</source>
          <target state="translated">此外,Rx确实引入了一种更好的错误处理方法。</target>
        </trans-unit>
        <trans-unit id="3434b058fadc1fd97196abc0cd226b5de0eff131" translate="yes" xml:space="preserve">
          <source>In addition, each of these also have a corresponding &lt;code&gt;{file}.meta.js&lt;/code&gt; meta file which will be used for reflection and other functionality.</source>
          <target state="translated">此外，每个 &lt;code&gt;{file}.meta.js&lt;/code&gt; 还具有一个对应的{file} .meta.js元文件，该文件将用于反射和其他功能。</target>
        </trans-unit>
        <trans-unit id="adf05c9d4a5ea22db47de9f6cd0f0a1f61618f95" translate="yes" xml:space="preserve">
          <source>In all cases, the C string is supposed to be encoded as UTF-8.</source>
          <target state="translated">在所有的情况下,C字符串都应该被编码为UTF-8。</target>
        </trans-unit>
        <trans-unit id="2ad8a2cde437dc29e925bd2e2608bcf1efd428d2" translate="yes" xml:space="preserve">
          <source>In all respects, this is just the same as in Java since access to private properties with default getters and setters is optimized so that no function call overhead is introduced.</source>
          <target state="translated">在所有方面,这与Java中的做法是一样的,因为通过默认的getters和setters对私有属性的访问是经过优化的,所以不会引入函数调用的开销。</target>
        </trans-unit>
        <trans-unit id="af3fb6a2c1c95a7bcc9ea3f79ae7998d4cb1b27a" translate="yes" xml:space="preserve">
          <source>In an &lt;a href=&quot;extensions&quot;&gt;extension function&lt;/a&gt; or a &lt;a href=&quot;lambdas#function-literals-with-receiver&quot;&gt;function literal with receiver&lt;/a&gt;&lt;em&gt;this&lt;/em&gt; denotes the &lt;em&gt;receiver&lt;/em&gt; parameter that is passed on the left-hand side of a dot.</source>
          <target state="translated">在&lt;a href=&quot;extensions&quot;&gt;扩展函数&lt;/a&gt;或&lt;a href=&quot;lambdas#function-literals-with-receiver&quot;&gt;带有接收器&lt;/a&gt;的函数文字中，&lt;em&gt;这&lt;/em&gt;表示在点的左侧传递的&lt;em&gt;接收器&lt;/em&gt;参数。</target>
        </trans-unit>
        <trans-unit id="751813b87d30d6501d1bf6ea23fd73a02ca28ea0" translate="yes" xml:space="preserve">
          <source>In an inline function definition, you can use &lt;code&gt;noinline&lt;/code&gt; in front of any function-typed parameter to prevent the lambda that will be passed to it from also being inlined.</source>
          <target state="translated">&lt;code&gt;noinline&lt;/code&gt; 联函数定义中，可以在任何函数类型的参数前面使用noinline，以防止内联将传递给它的lambda。</target>
        </trans-unit>
        <trans-unit id="751fca68ff5e9efd6f13ba9f691a416e15e88e6e" translate="yes" xml:space="preserve">
          <source>In any lists, you can find the position of an element using the functions &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/index-of&quot;&gt;&lt;code&gt;indexOf()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/last-index-of&quot;&gt;&lt;code&gt;lastIndexOf()&lt;/code&gt;&lt;/a&gt;. They return the first and the last position of an element equal to the given argument in the list. If there are no such elements, both functions return &lt;code&gt;-1&lt;/code&gt;.</source>
          <target state="translated">在任何列表中，您都可以使用&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/index-of&quot;&gt; &lt;code&gt;indexOf()&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/last-index-of&quot;&gt; &lt;code&gt;lastIndexOf()&lt;/code&gt; &lt;/a&gt;函数找到元素的位置。它们返回与列表中给定参数相等的元素的第一个和最后一个位置。如果没有这样的元素，则两个函数都将返回 &lt;code&gt;-1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c3c35f058a2881495687f9b24556ffc42c9b3b89" translate="yes" xml:space="preserve">
          <source>In approach it's quite similar to Futures, but one can think of a Future as returning a discrete element, whereby Rx returns a stream. However, similar to the previous, it also introduces a complete new way of thinking about our programming model, famously phrased as</source>
          <target state="translated">在方法上,它和Futures很相似,但我们可以把Future看作是返回一个离散元素,而Rx则返回一个流。然而,与前者类似,它也为我们的编程模型引入了一种全新的思维方式,著名的说法为</target>
        </trans-unit>
        <trans-unit id="afaa57d188a4de777b467f6dcde31f2f2cfb5700" translate="yes" xml:space="preserve">
          <source>In case if any two entries are mapped to the equal keys, the value of the latter one will overwrite the value associated with the former one.</source>
          <target state="translated">如果任何两个条目被映射到等键上,后一个条目的值将覆盖与前一个条目相关联的值。</target>
        </trans-unit>
        <trans-unit id="ab773dc6434fe9e51f59bd2f39f7407e2e315f54" translate="yes" xml:space="preserve">
          <source>In case if the resource is being closed due to an exception occurred in &lt;a href=&quot;use#kotlin%24use%28kotlin.use.T%2C+kotlin.Function1%28%28kotlin.use.T%2C+kotlin.use.R%29%29%29%2Fblock&quot;&gt;block&lt;/a&gt;, and the closing also fails with an exception, the latter is added to the &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/lang/Throwable.html#addSuppressed(java.lang.Throwable)&quot;&gt;suppressed&lt;/a&gt; exceptions of the former.</source>
          <target state="translated">如果由于在&lt;a href=&quot;use#kotlin%24use%28kotlin.use.T%2C+kotlin.Function1%28%28kotlin.use.T%2C+kotlin.use.R%29%29%29%2Fblock&quot;&gt;block中&lt;/a&gt;发生异常而关闭资源，并且关闭也因异常而失败，则将后者添加到前者的&lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/lang/Throwable.html#addSuppressed(java.lang.Throwable)&quot;&gt;抑制&lt;/a&gt;异常中。</target>
        </trans-unit>
        <trans-unit id="753affb3f26053a8d6fe6a50898f37935f2da6a8" translate="yes" xml:space="preserve">
          <source>In case if the resource is being closed due to an exception occurred in &lt;a href=&quot;use#kotlin%24use(kotlin.use.T,%20kotlin.Function1((kotlin.use.T,%20kotlin.use.R)))/block&quot;&gt;block&lt;/a&gt;, and the closing also fails with an exception, the latter is added to the suppressed exceptions of the former.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a99d3de27a9334d7d61ccdc4fea1d3937e232802" translate="yes" xml:space="preserve">
          <source>In case if there are non-blank lines with no leading whitespace characters (no indent at all) then the common indent is 0, and therefore this function doesn't change the indentation.</source>
          <target state="translated">如果有非空行,没有前导空格字符(完全没有缩进),那么普通缩进为0,因此这个函数不会改变缩进。</target>
        </trans-unit>
        <trans-unit id="c60b20e0301bd757b71bb24ccc047d80b78f21b1" translate="yes" xml:space="preserve">
          <source>In case of a name conflict between the members of the dispatch receiver and the extension receiver, the extension receiver takes precedence. To refer to the member of the dispatch receiver you can use the &lt;a href=&quot;this-expressions#qualified&quot;&gt;qualified &lt;code&gt;this&lt;/code&gt; syntax&lt;/a&gt;.</source>
          <target state="translated">如果在派发接收方和扩展接收方的成员之间发生名称冲突，则以扩展接收方为准。要引用调度接收器的成员，可以使用&lt;a href=&quot;this-expressions#qualified&quot;&gt;限定的 &lt;code&gt;this&lt;/code&gt; 语法&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2564f2a33e66657de3341732c5e625e51d4323de" translate="yes" xml:space="preserve">
          <source>In case of the extension property in a class, the instance of the class should be passed first and the instance of the extension receiver second.</source>
          <target state="translated">如果是类中的扩展属性,应先传递类的实例,后传递扩展接收器的实例。</target>
        </trans-unit>
        <trans-unit id="1a1fb30f33e29cde0e4a9adce651bb450975c80d" translate="yes" xml:space="preserve">
          <source>In case this type is based on an inner class, the returned list contains the type arguments provided for the innermost class first, then its outer class, and so on. For example, in the type &lt;code&gt;Outer&amp;lt;A, B&amp;gt;.Inner&amp;lt;C, D&amp;gt;&lt;/code&gt; the returned list is &lt;code&gt;[C, D, A, B]&lt;/code&gt;.</source>
          <target state="translated">如果此类型基于内部类，则返回的列表将首先包含为最内部类提供的类型参数，然后是为其外部类提供的参数，依此类推。例如，在类型 &lt;code&gt;Outer&amp;lt;A, B&amp;gt;.Inner&amp;lt;C, D&amp;gt;&lt;/code&gt; ，返回的列表为 &lt;code&gt;[C, D, A, B]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="744293bc64c3188af17bab32f33333fe2cad85c9" translate="yes" xml:space="preserve">
          <source>In case you want only some of the lambdas passed to an inline function to be inlined, you can mark some of your function parameters with the &lt;code&gt;noinline&lt;/code&gt; modifier:</source>
          <target state="translated">如果只希望传递给内联函数的某些lambda进行内联，则可以使用 &lt;code&gt;noinline&lt;/code&gt; 修饰符标记一些函数参数：</target>
        </trans-unit>
        <trans-unit id="816f79d2ddebc85fd82a80af3cc580e6eeb81694" translate="yes" xml:space="preserve">
          <source>In case you're wondering about how &lt;code&gt;use&lt;/code&gt;, which is a function, can just be followed by a block like that, see the section on &lt;a href=&quot;functional-programming#receivers&quot;&gt;DSL support&lt;/a&gt;.</source>
          <target state="translated">如果您想知道 &lt;code&gt;use&lt;/code&gt; 是一个功能，如何在其后加上类似的代码块，请参阅&lt;a href=&quot;functional-programming#receivers&quot;&gt;DSL支持&lt;/a&gt;部分。</target>
        </trans-unit>
        <trans-unit id="de1e14373afc30cdce829d5ccf1028c05a1345bf" translate="yes" xml:space="preserve">
          <source>In common code:</source>
          <target state="translated">在通用代码中:</target>
        </trans-unit>
        <trans-unit id="dbd13320c78fae25fd6f48673f77aea087d10896" translate="yes" xml:space="preserve">
          <source>In essence, this allows for the following code:</source>
          <target state="translated">从本质上讲,这允许以下代码。</target>
        </trans-unit>
        <trans-unit id="b797e297636a01e5f39faa44903e3922322a2f0c" translate="yes" xml:space="preserve">
          <source>In fact, for declaring properties and initializing them from the primary constructor, Kotlin has a concise syntax:</source>
          <target state="translated">事实上,对于从主构造函数中声明属性和初始化属性,Kotlin有一个简洁的语法。</target>
        </trans-unit>
        <trans-unit id="8575e5bc9be645637c35224eaab5422d26408ea8" translate="yes" xml:space="preserve">
          <source>In further sections, these concepts are described in more detail along with the DSL to configure them in a project.</source>
          <target state="translated">在接下来的章节中,将对这些概念以及在项目中配置它们的DSL进行更详细的描述。</target>
        </trans-unit>
        <trans-unit id="093d33db378ee271b0948a0579ab35389d4e97d5" translate="yes" xml:space="preserve">
          <source>In general, for small projects, we recommend converting all the files at once.</source>
          <target state="translated">一般来说,对于小型项目,我们建议一次性转换所有文件。</target>
        </trans-unit>
        <trans-unit id="2ad6bf46a8b188e9bc3522dea93919d7678b502b" translate="yes" xml:space="preserve">
          <source>In general, identifiers may consist of letters, digits, and underscores, and may not begin with a digit. However, if you are writing code that e.g. autogenerates JSON based on identifiers and you want the JSON key to be a string that does not conform to these rules or that collides with a keyword, you can enclose it in backticks: &lt;code&gt;`I can't believe this is not an error!`&lt;/code&gt; is a valid identifier.</source>
          <target state="translated">通常，标识符可以由字母，数字和下划线组成，并且不能以数字开头。但是，如果您编写的代码（例如，基于标识符自动生成JSON）并且希望JSON密钥是不符合这些规则或与关键字冲突的字符串，则可以将其括在反引号中： &lt;code&gt;`I can't believe this is not an error!`&lt;/code&gt; 是有效的标识符。</target>
        </trans-unit>
        <trans-unit id="def8cf1480d12ae42f29a02a77be00f6fa6a05e6" translate="yes" xml:space="preserve">
          <source>In general, if a certain syntactic construction in Kotlin is optional and highlighted by the IDE as redundant, you should omit it in your code. Do not leave unnecessary syntactic elements in code just &quot;for clarity&quot;.</source>
          <target state="translated">一般来说,如果Kotlin中的某个语法结构是可选的,并且被IDE高亮显示为多余的,你应该在代码中省略它。不要为了 &quot;清晰 &quot;而在代码中留下不必要的语法元素。</target>
        </trans-unit>
        <trans-unit id="01b3fb6a7b9e95b734c635ce49024c6d660e14c4" translate="yes" xml:space="preserve">
          <source>In general, to create an instance of such a class, we need to provide the type arguments:</source>
          <target state="translated">一般来说,要创建这样一个类的实例,我们需要提供类型参数。</target>
        </trans-unit>
        <trans-unit id="450c32ce21d7e1cf7d82473c6445b4ccee4985e3" translate="yes" xml:space="preserve">
          <source>In generated code, the Kotlin compiler keeps a &lt;em&gt;wrapper&lt;/em&gt; for each inline class. Inline class instances can be represented at runtime either as wrappers or as the underlying type. This is similar to how &lt;code&gt;Int&lt;/code&gt; can be &lt;a href=&quot;basic-types#representation&quot;&gt;represented&lt;/a&gt; either as a primitive &lt;code&gt;int&lt;/code&gt; or as the wrapper &lt;code&gt;Integer&lt;/code&gt;.</source>
          <target state="translated">在生成的代码中，Kotlin编译&lt;em&gt;器&lt;/em&gt;为每个内联类保留一个&lt;em&gt;包装器&lt;/em&gt;。内联类实例可以在运行时表示为包装器或基础类型。这类似于如何 &lt;code&gt;Int&lt;/code&gt; 可以&lt;a href=&quot;basic-types#representation&quot;&gt;表示&lt;/a&gt;或者作为原始 &lt;code&gt;int&lt;/code&gt; 或作为包装 &lt;code&gt;Integer&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fd80bee1bf4ef4cc9fdfdeda947dd40e1e56db38" translate="yes" xml:space="preserve">
          <source>In lambda expressions, spaces should be used around the curly braces, as well as around the arrow which separates the parameters from the body. If a call takes a single lambda, it should be passed outside of parentheses whenever possible.</source>
          <target state="translated">在lambda表达式中,应该在大括号周围使用空格,以及在分隔参数和正文的箭头周围使用空格。如果一个调用只使用一个lambda,则应尽可能在括号外传递。</target>
        </trans-unit>
        <trans-unit id="80c8a890c9d273e819066140d09ce2d0bc285c7d" translate="yes" xml:space="preserve">
          <source>In lambdas which are short and not nested, it's recommended to use the &lt;code&gt;it&lt;/code&gt; convention instead of declaring the parameter explicitly. In nested lambdas with parameters, parameters should be always declared explicitly.</source>
          <target state="translated">在较短且未嵌套的lambda中，建议使用 &lt;code&gt;it&lt;/code&gt; 约定而不是显式声明参数。在带有参数的嵌套lambda中，应始终明确声明参数。</target>
        </trans-unit>
        <trans-unit id="0f96591676e8e90474bcc2e9cbd0fe550a87c6d7" translate="yes" xml:space="preserve">
          <source>In long argument lists, put a line break after the opening parenthesis. Indent arguments by 4 spaces. Group multiple closely related arguments on the same line.</source>
          <target state="translated">在较长的参数列表中,在开头的括号后加一个换行符。缩进4个空格的参数。将多个密切相关的参数归为同一行。</target>
        </trans-unit>
        <trans-unit id="e70f274fab45a9ad1cf0f5234b5a4c58fefd78f6" translate="yes" xml:space="preserve">
          <source>In many cases, one does not need to use explicit cast operators in Kotlin, because the compiler tracks the &lt;code&gt;is&lt;/code&gt;-checks and &lt;a href=&quot;#unsafe-cast-operator&quot;&gt;explicit casts&lt;/a&gt; for immutable values and inserts (safe) casts automatically when needed:</source>
          <target state="translated">在许多情况下，不需要在Kotlin中使用显&lt;a href=&quot;#unsafe-cast-operator&quot;&gt;式强制转换&lt;/a&gt;运算符，因为编译器会跟踪 &lt;code&gt;is&lt;/code&gt; - checks和显式强制转换以获取不可变值，并在需要时自动插入（安全）强制转换：</target>
        </trans-unit>
        <trans-unit id="d05a001b4fb4f64cd4a87d987f4f265545ae66a8" translate="yes" xml:space="preserve">
          <source>In mixed-language projects, Kotlin source files should reside in the same source root as the Java source files, and follow the same directory structure (each file should be stored in the directory corresponding to each package statement).</source>
          <target state="translated">在混合语言项目中,Kotlin源文件应与Java源文件驻留在同一个源根中,并遵循相同的目录结构(每个文件应存放在每个包声明对应的目录中)。</target>
        </trans-unit>
        <trans-unit id="a772373d726c1ea1dd1e4b5bd74e75bb5171d98d" translate="yes" xml:space="preserve">
          <source>In modules that don't provide their own API, such as application modules, you can use experimental APIs without propagating the experimental status to your code. In this case, mark your code with the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin/-use-experimental/index&quot;&gt;@UseExperimental(Marker::class)&lt;/a&gt; annotation specifying the marker annotation of the experimental API:</source>
          <target state="translated">在不提供自己的API的模块（例如应用程序模块）中，您可以使用实验性API，而无需将实验状态传播到代码中。在这种情况下，请使用&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin/-use-experimental/index&quot;&gt;@UseExperimental（Marker :: class）&lt;/a&gt;批注标记代码，并指定实验性API的标记批注：</target>
        </trans-unit>
        <trans-unit id="cfed7f25e3bb00e2797542765d6c2ca96af68b87" translate="yes" xml:space="preserve">
          <source>In most cases, Kotlin follows the Java coding conventions.</source>
          <target state="translated">在大多数情况下,Kotlin遵循Java编码惯例。</target>
        </trans-unit>
        <trans-unit id="d126b0359662ea6c66b61b9e3af53b0d85339044" translate="yes" xml:space="preserve">
          <source>In multiline mode the expressions &lt;code&gt;^&lt;/code&gt; and &lt;code&gt;$&lt;/code&gt; match just after or just before, respectively, a line terminator or the end of the input sequence.</source>
          <target state="translated">在多行模式下，表达式 &lt;code&gt;^&lt;/code&gt; 和 &lt;code&gt;$&lt;/code&gt; 分别在行终止符或输入序列的结尾之后或之前匹配。</target>
        </trans-unit>
        <trans-unit id="6667a323602babcf47c04e12460b410e75814d22" translate="yes" xml:space="preserve">
          <source>In order to assemble an application, we also need to include the Kotlin standard library, i.e. &lt;code&gt;kotlin.js&lt;/code&gt;, which was included as a dependency, and the other libraries if any.</source>
          <target state="translated">为了组装应用程序，我们还需要包括Kotlin标准库（即作为依赖项包含的 &lt;code&gt;kotlin.js&lt;/code&gt; )和其他库（如果有）。</target>
        </trans-unit>
        <trans-unit id="034cc52464c28236e3f8c4183a0d3673ce621a3f" translate="yes" xml:space="preserve">
          <source>In order to avoid compatibility issues during an Xcode build, the plugin requires using a &lt;a href=&quot;https://docs.gradle.org/current/userguide/gradle_wrapper.html&quot;&gt;Gradle wrapper&lt;/a&gt;. To generate the wrapper automatically during execution of the &lt;code&gt;podspec&lt;/code&gt; task, run it with the parameter &lt;code&gt;-Pkotlin.native.cocoapods.generate.wrapper=true&lt;/code&gt;.</source>
          <target state="translated">为了避免在Xcode构建期间出现兼容性问题，该插件需要使用&lt;a href=&quot;https://docs.gradle.org/current/userguide/gradle_wrapper.html&quot;&gt;Gradle包装器&lt;/a&gt;。要在执行 &lt;code&gt;podspec&lt;/code&gt; 任务期间自动生成包装器，请使用参数 &lt;code&gt;-Pkotlin.native.cocoapods.generate.wrapper=true&lt;/code&gt; 对其运行。</target>
        </trans-unit>
        <trans-unit id="320ea67fc7a407c39652cf848b66d1bac7958814" translate="yes" xml:space="preserve">
          <source>In order to build a Kotlin project with Gradle, you should &lt;a href=&quot;#plugin-and-versions&quot;&gt;apply the Kotlin Gradle plugin to your project&lt;/a&gt; and &lt;a href=&quot;#configuring-dependencies&quot;&gt;configure dependencies&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a047d1f6392366b3f681991fe461367b7be253f" translate="yes" xml:space="preserve">
          <source>In order to build a Kotlin project with Gradle, you should &lt;a href=&quot;#plugin-and-versions&quot;&gt;set up the &lt;em&gt;kotlin-gradle&lt;/em&gt; plugin&lt;/a&gt;, &lt;a href=&quot;#targeting-the-jvm&quot;&gt;apply it&lt;/a&gt; to your project and &lt;a href=&quot;#configuring-dependencies&quot;&gt;add &lt;em&gt;kotlin-stdlib&lt;/em&gt; dependencies&lt;/a&gt;. Those actions may also be performed automatically in IntelliJ IDEA by invoking &lt;strong&gt;Tools | Kotlin | Configure Kotlin&lt;/strong&gt; in &lt;strong&gt;Project&lt;/strong&gt; action.</source>
          <target state="translated">为了使用Gradle构建Kotlin项目，您应该&lt;a href=&quot;#plugin-and-versions&quot;&gt;设置&lt;em&gt;kotlin-gradle&lt;/em&gt;插件&lt;/a&gt;，&lt;a href=&quot;#targeting-the-jvm&quot;&gt;将其应用&lt;/a&gt;到项目中并&lt;a href=&quot;#configuring-dependencies&quot;&gt;添加&lt;em&gt;kotlin-stdlib&lt;/em&gt;依赖项&lt;/a&gt;。通过调用&amp;ldquo; &lt;strong&gt;工具&amp;rdquo;，&lt;/strong&gt;这些动作也可以在IntelliJ IDEA中自动执行&lt;strong&gt;。&lt;/strong&gt;&lt;strong&gt;科特林| &lt;/strong&gt;在&amp;ldquo; &lt;strong&gt;项目&amp;rdquo;&lt;/strong&gt;操作中&lt;strong&gt;配置Kotlin&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="e347f51a9c40cc493b347c1bed8c2d5285726dad" translate="yes" xml:space="preserve">
          <source>In order to compile JavaScript code, you need to use the &lt;code&gt;js&lt;/code&gt; and &lt;code&gt;test-js&lt;/code&gt; goals for the &lt;code&gt;compile&lt;/code&gt; execution:</source>
          <target state="translated">为了编译JavaScript代码，您需要使用 &lt;code&gt;js&lt;/code&gt; 和 &lt;code&gt;test-js&lt;/code&gt; 目标进行 &lt;code&gt;compile&lt;/code&gt; 执行：</target>
        </trans-unit>
        <trans-unit id="7888ab5509b34a7615518c3269c358c32f2dd548" translate="yes" xml:space="preserve">
          <source>In order to debug the application using IntelliJ IDEA, we need to perform two steps:</source>
          <target state="translated">为了使用IntelliJ IDEA调试应用程序,我们需要执行两个步骤。</target>
        </trans-unit>
        <trans-unit id="0d60abc6454bf0506cb62dd1ac746f025ab62610" translate="yes" xml:space="preserve">
          <source>In order to generate these bindings, we need to create a library definition &lt;code&gt;.def&lt;/code&gt; file that contains some information about the headers we need to generate. In our case we want to use the famous &lt;code&gt;libcurl&lt;/code&gt; library to make some HTTP calls, so we'll create a file named &lt;code&gt;libcurl.def&lt;/code&gt; with the following contents</source>
          <target state="translated">为了生成这些绑定，我们需要创建一个库定义 &lt;code&gt;.def&lt;/code&gt; 文件，其中包含一些有关我们需要生成的标头的信息。在我们的例子中，我们想使用著名的 &lt;code&gt;libcurl&lt;/code&gt; 库进行一些HTTP调用，因此我们将创建一个名为 &lt;code&gt;libcurl.def&lt;/code&gt; 的文件,其中包含以下内容</target>
        </trans-unit>
        <trans-unit id="ffbf97f9cc48e7603dadd7a45b25bf4f6b7e3989" translate="yes" xml:space="preserve">
          <source>In order to run, we need the corresponding WAR(s) for deploying. We can generate these using the &lt;em&gt;war&lt;/em&gt; task in Gradle which can easily be executed via the Gradle tool window in IntelliJ IDEA.</source>
          <target state="translated">为了运行，我们需要相应的WAR进行部署。我们可以使用Gradle中的&lt;em&gt;war&lt;/em&gt;任务生成这些任务，该任务可以通过IntelliJ IDEA中的Gradle工具窗口轻松执行。</target>
        </trans-unit>
        <trans-unit id="24dcbfd34df21e70b79c4b2191a485e90cc3e450" translate="yes" xml:space="preserve">
          <source>In order to share the changes across the project developers &lt;code&gt;.idea/codeStyle&lt;/code&gt; folder, it has to be committed to VCS. Alternatively &lt;strong&gt;kotlin.code.style&lt;/strong&gt;=&lt;strong&gt;obsolete&lt;/strong&gt; can be used for projects configured with Gradle or Maven.</source>
          <target state="translated">为了在项目开发人员的 &lt;code&gt;.idea/codeStyle&lt;/code&gt; 文件夹中共享更改，必须将其提交给VCS。另外，&lt;strong&gt;kotlin.code.style&lt;/strong&gt; = &lt;strong&gt;obsolete&lt;/strong&gt;可以用于配置了Gradle或Maven的项目。</target>
        </trans-unit>
        <trans-unit id="155fb0f00f3221a063feea137fb0401c04ce9dd5" translate="yes" xml:space="preserve">
          <source>In order to share those changes for all project developers &lt;code&gt;.idea/codeStyle&lt;/code&gt; folder have to be committed to VCS.</source>
          <target state="translated">为了向所有项目开发人员共享这些更改，必须将 &lt;code&gt;.idea/codeStyle&lt;/code&gt; 文件夹提交给VCS。</target>
        </trans-unit>
        <trans-unit id="fa88cf692336fd455afd07788cc5c7d6ab06d938" translate="yes" xml:space="preserve">
          <source>In order to specify the module kind, we can add a configuration to our plugin as below</source>
          <target state="translated">为了指定模块的种类,我们可以为我们的插件添加一个配置,如下所示</target>
        </trans-unit>
        <trans-unit id="59607fe0baf1ba77b3f9ca8983f516dc1d471c45" translate="yes" xml:space="preserve">
          <source>In order to support a potentially nullable type, the Objc header needs to define &lt;code&gt;myVal&lt;/code&gt; with a nullable return value.</source>
          <target state="translated">为了支持可能为空的类型，Objc标头需要使用可为空的返回值定义 &lt;code&gt;myVal&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="de88f4d0de61705bae1956451c94335904114bb9" translate="yes" xml:space="preserve">
          <source>In order to support a potentially nullable type, the Objective-C header needs to define &lt;code&gt;myVal&lt;/code&gt; with a nullable return value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9aac89688353374371a7ae0f65a4346b1a58df3a" translate="yes" xml:space="preserve">
          <source>In order to use Gradle to target JavaScript, we need to use the &lt;code&gt;kotlin2js&lt;/code&gt; plugin as opposed to the &lt;code&gt;kotlin&lt;/code&gt; plugin.</source>
          <target state="translated">为了使用Gradle定位JavaScript，我们需要使用 &lt;code&gt;kotlin2js&lt;/code&gt; 插件，而不是 &lt;code&gt;kotlin&lt;/code&gt; 插件。</target>
        </trans-unit>
        <trans-unit id="33526a8ed38f3fde7c6b4f6af71779367c169bbc" translate="yes" xml:space="preserve">
          <source>In order to use Kotlin with node.js, we need to set the compiler option to use CommonJS. Once we do that, the output of the application should be accessible using the node module system.</source>
          <target state="translated">为了在node.js中使用Kotlin,我们需要将编译器选项设置为使用CommonJS。一旦我们这样做,应用程序的输出应该可以使用node模块系统访问。</target>
        </trans-unit>
        <trans-unit id="5bdfd7a958cb3b5e6a62acec15106d2a72aa846c" translate="yes" xml:space="preserve">
          <source>In order to use coroutines as well as follow the examples in this guide, you need to add a dependency on &lt;code&gt;kotlinx-coroutines-core&lt;/code&gt; module as explained &lt;a href=&quot;https://github.com/kotlin/kotlinx.coroutines/blob/master/README.md#using-in-your-projects&quot;&gt;in the project README&lt;/a&gt;.</source>
          <target state="translated">为了使用协程并遵循本指南中的示例，您需要添加对 &lt;code&gt;kotlinx-coroutines-core&lt;/code&gt; 模块的依赖项，如&lt;a href=&quot;https://github.com/kotlin/kotlinx.coroutines/blob/master/README.md#using-in-your-projects&quot;&gt;项目README中所述&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="cc71e5241592939229f3aa2e6f5ed18f17024e17" translate="yes" xml:space="preserve">
          <source>In order to use coroutines as well as follow the examples in this guide, you need to add a dependency on the &lt;code&gt;kotlinx-coroutines-core&lt;/code&gt; module as explained &lt;a href=&quot;https://github.com/kotlin/kotlinx.coroutines/blob/master/README.md#using-in-your-projects&quot;&gt;in the project README&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1cc60ead46c9defc457295413372bae706d2254f" translate="yes" xml:space="preserve">
          <source>In order to use something from a package, it is sufficient to use the package name to fully qualify the name of the symbol at the place where you use the symbol:</source>
          <target state="translated">为了使用包中的东西,只要在使用符号的地方使用包名来完全限定符号的名称即可。</target>
        </trans-unit>
        <trans-unit id="9abc8ef7836ac20fac6436adb16fe6c5da1f6518" translate="yes" xml:space="preserve">
          <source>In order to use this, we also need to include the Kotlin standard library in our application, i.e. &lt;code&gt;kotlin.js&lt;/code&gt;, which was included as a dependency. By default, Maven does not expand the JAR as part of the build process, so we would need to add an additional step in our build to do so.</source>
          <target state="translated">为了使用它，我们还需要在我们的应用程序中包括Kotlin标准库，即 &lt;code&gt;kotlin.js&lt;/code&gt; ，它作为依赖项包含在内。默认情况下，Maven不会在构建过程中扩展JAR，因此我们需要在构建中添加一个额外的步骤。</target>
        </trans-unit>
        <trans-unit id="a5c6ba86278357c55cc58dbde4e4e54ec8ffad3f" translate="yes" xml:space="preserve">
          <source>In other words, inline classes introduce a truly &lt;em&gt;new&lt;/em&gt; type, contrary to type aliases which only introduce an alternative name (alias) for an existing type:</source>
          <target state="translated">换句话说，内联类引入了一种真正的&lt;em&gt;新&lt;/em&gt;类型，这与类型别名相反，后者仅为现有类型引入了替代名称（别名）：</target>
        </trans-unit>
        <trans-unit id="2fcd261cf566bdf17c9a0226c120616065441d92" translate="yes" xml:space="preserve">
          <source>In our DSL all the tag classes extend the same superclass &lt;code&gt;Tag&lt;/code&gt;. It's enough to annotate only the superclass with &lt;code&gt;@HtmlTagMarker&lt;/code&gt; and after that the Kotlin compiler will treat all the inherited classes as annotated:</source>
          <target state="translated">在我们的DSL中，所有标签类都扩展相同的超类 &lt;code&gt;Tag&lt;/code&gt; 。仅用 &lt;code&gt;@HtmlTagMarker&lt;/code&gt; 注释超类就足够了，然后Kotlin编译器会将所有继承的类视为已注释：</target>
        </trans-unit>
        <trans-unit id="055ba8d22e98a479f59a07d7a075048bb0a20fe4" translate="yes" xml:space="preserve">
          <source>In our example, we have &lt;code&gt;main&lt;/code&gt; function that is turned into a coroutine using &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/run-blocking.html&quot;&gt;runBlocking&lt;/a&gt; coroutine builder. Every coroutine builder, including &lt;code&gt;runBlocking&lt;/code&gt;, adds an instance of &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/coroutine-scope.html&quot;&gt;CoroutineScope&lt;/a&gt; to the scope of its code block. We can launch coroutines in this scope without having to &lt;code&gt;join&lt;/code&gt; them explicitly, because an outer coroutine (&lt;code&gt;runBlocking&lt;/code&gt; in our example) does not complete until all the coroutines launched in its scope complete. Thus, we can make our example simpler:</source>
          <target state="translated">在我们的示例中，我们具有使用&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/run-blocking.html&quot;&gt;runBlocking&lt;/a&gt;协程构建器将其转换为协程的 &lt;code&gt;main&lt;/code&gt; 功能。每个协 &lt;code&gt;runBlocking&lt;/code&gt; 器，包括runBlocking，&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/coroutine-scope.html&quot;&gt;都会&lt;/a&gt;在其代码块范围内添加一个CoroutineScope实例。我们可以在此范围内启动协程，而不必显式地 &lt;code&gt;join&lt;/code&gt; 它们，因为外部协程（在我们的示例中为 &lt;code&gt;runBlocking&lt;/code&gt; ）直到在其范围内启动的所有协程完成后才完成。因此，我们可以使示例更简单：</target>
        </trans-unit>
        <trans-unit id="a2b76b0743b9831752920932ff5a5625568afac3" translate="yes" xml:space="preserve">
          <source>In our example, we have a &lt;code&gt;main&lt;/code&gt; function that is turned into a coroutine using the &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/run-blocking.html&quot;&gt;runBlocking&lt;/a&gt; coroutine builder. Every coroutine builder, including &lt;code&gt;runBlocking&lt;/code&gt;, adds an instance of &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope/index.html&quot;&gt;CoroutineScope&lt;/a&gt; to the scope of its code block. We can launch coroutines in this scope without having to &lt;code&gt;join&lt;/code&gt; them explicitly, because an outer coroutine (&lt;code&gt;runBlocking&lt;/code&gt; in our example) does not complete until all the coroutines launched in its scope complete. Thus, we can make our example simpler:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99c50d394fc235f8eeca8f1ea6662b1ec125d6bd" translate="yes" xml:space="preserve">
          <source>In our main function we create activity, call our test &lt;code&gt;doSomething&lt;/code&gt; function, and destroy activity after 500ms. This cancels all the coroutines that were launched which we can confirm by noting that it does not print onto the screen anymore if we wait:</source>
          <target state="translated">在我们的主要函数中，我们创建活动，调用测试 &lt;code&gt;doSomething&lt;/code&gt; 函数，并在500毫秒后销毁活动。这会取消所有已启动的协程，如果等待，我们可以通过注意到它不再打印在屏幕上来确认这一点：</target>
        </trans-unit>
        <trans-unit id="8567ecf52dbb46832894d62cc3534eccec93e924" translate="yes" xml:space="preserve">
          <source>In our main function we create the activity, call our test &lt;code&gt;doSomething&lt;/code&gt; function, and destroy the activity after 500ms. This cancels all the coroutines that were launched from &lt;code&gt;doSomething&lt;/code&gt;. We can see that because after the destruction of the activity no more messages are printed, even if we wait a little longer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e33cfe3a798666f120dafc2300d3a53a316781b" translate="yes" xml:space="preserve">
          <source>In particular, when defining extension functions for a class which are relevant for all clients of this class, put them in the same file where the class itself is defined. When defining extension functions that make sense only for a specific client, put them next to the code of that client. Do not create files just to hold &quot;all extensions of Foo&quot;.</source>
          <target state="translated">特别是,当为一个类定义对这个类的所有客户端都有意义的扩展函数时,把它们放在定义该类本身的同一个文件中。当定义那些只对特定客户端有意义的扩展函数时,把它们放在该客户端的代码旁边。不要为了存放 &quot;Foo的所有扩展函数 &quot;而创建文件。</target>
        </trans-unit>
        <trans-unit id="2683ff56288a092d85a9176c5ad7bb38fce09a9b" translate="yes" xml:space="preserve">
          <source>In practice some changes can't be accurately detected at compile time, so no warnings can be reported, but at least the users will be notified through Release notes of version A that a change is coming in version B.</source>
          <target state="translated">在实践中,有些变化无法在编译时准确地检测到,所以不能报告警告,但至少会通过A版本的Release notes通知用户,B版本将有变化。</target>
        </trans-unit>
        <trans-unit id="1e5d38479fe45d55c10d169d2b3903a772bc6139" translate="yes" xml:space="preserve">
          <source>In practice, quite a bit of code is affected, so this can be considered a major code style update.</source>
          <target state="translated">在实践中,有不少代码受到影响,所以这可以说是一次重大的代码风格更新。</target>
        </trans-unit>
        <trans-unit id="57e5b70de31acdb27d8d2c67fea04b3d16fdd8a7" translate="yes" xml:space="preserve">
          <source>In practice, thread confinement is performed in large chunks, e.g. big pieces of state-updating business logic are confined to the single thread. The following example does it like that, running each coroutine in the single-threaded context to start with.</source>
          <target state="translated">在实际工作中,线程限制是以大块的方式进行的,比如大块的状态更新业务逻辑就限制在单线程中。下面的例子就是这样做的,首先在单线程上下文中运行每个coroutine。</target>
        </trans-unit>
        <trans-unit id="40969ff7e4fed85e58f626291a67f5273e20a573" translate="yes" xml:space="preserve">
          <source>In progressive mode, some fixes in language semantics can arrive immediately. All these fixes have two important properties:</source>
          <target state="translated">在渐进模式下,语言语义的一些修正可以立即到达。所有这些修正都有两个重要的特性。</target>
        </trans-unit>
        <trans-unit id="eff40107a95c01dec77eae6fb0ec0b96a075ea6f" translate="yes" xml:space="preserve">
          <source>In pure Kotlin projects, the recommended directory structure follows the package structure with the common root package omitted. For example, if all the code in the project is in the &lt;code&gt;org.example.kotlin&lt;/code&gt; package and its subpackages, files with the &lt;code&gt;org.example.kotlin&lt;/code&gt; package should be placed directly under the source root, and files in &lt;code&gt;org.example.kotlin.network.socket&lt;/code&gt; should be in the &lt;code&gt;network/socket&lt;/code&gt; subdirectory of the source root.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d10877f2d49f4fb7859f1ddc63051feb0cebe60b" translate="yes" xml:space="preserve">
          <source>In pure Kotlin projects, the recommended directory structure is to follow the package structure with the common root package omitted (e.g. if all the code in the project is in the &quot;org.example.kotlin&quot; package and its subpackages, files with the &quot;org.example.kotlin&quot; package should be placed directly under the source root, and files in &quot;org.example.kotlin.foo.bar&quot; should be in the &quot;foo/bar&quot; subdirectory of the source root).</source>
          <target state="translated">在纯Kotlin项目中,推荐的目录结构是遵循包的结构,而省略常用的根包(例如,如果项目中所有的代码都在 &quot;org.example.kotlin &quot;包及其子包中,那么 &quot;org.example.kotlin &quot;包中的文件应该直接放在源根目录下,而 &quot;org.example.kotlin.foo.bar &quot;中的文件应该放在源根目录的 &quot;foo/bar &quot;子目录下)。</target>
        </trans-unit>
        <trans-unit id="c30c378469f41e6f1d1072007ebada7e490b3451" translate="yes" xml:space="preserve">
          <source>In scratches and worksheets, you can write any valid Kotlin code. Syntax highlighting, auto-completion, and the other IntelliJ IDEA code editing features are all supported too. Note that there's no need for declaring the &lt;code&gt;main&lt;/code&gt; function: all the code you write is executed as if it would be in the body of &lt;code&gt;main&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a5be9888b7ba5a318d3261861baf4d32fa8861a" translate="yes" xml:space="preserve">
          <source>In short: &lt;em&gt;think carefully through your declarations of integers, and be absolutely certain that the value will never ever need to be larger than the limits of the type!&lt;/em&gt; If you need an integer of unlimited size, use the non-primitive type &lt;code&gt;BigInteger&lt;/code&gt;.</source>
          <target state="translated">简而言之：&lt;em&gt;仔细考虑您的整数声明，并绝对确保该值永远不必大于该类型的限制！&lt;/em&gt;如果需要不限大小的整数，请使用非原始类型 &lt;code&gt;BigInteger&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4a3b75ce2c9b15401d05148e77e0306873596e7e" translate="yes" xml:space="preserve">
          <source>In situations like this we can use the &lt;code&gt;dynamic&lt;/code&gt; type, which allows us to work with dynamic types when targeting JavaScript. The following variable is declared as &lt;code&gt;dynamic&lt;/code&gt; meaning that whatever we invoke on it will not result in a compile-time error:</source>
          <target state="translated">在这种情况下，我们可以使用 &lt;code&gt;dynamic&lt;/code&gt; 类型，该动态类型允许我们在定位JavaScript时使用动态类型。以下变量被声明为 &lt;code&gt;dynamic&lt;/code&gt; 变量，这意味着我们对其进行的调用均不会导致编译时错误：</target>
        </trans-unit>
        <trans-unit id="55bd36b85c22e6a1c4d10234a638ea714c3940ad" translate="yes" xml:space="preserve">
          <source>In some cases (for example, to support overloads), Kotlin compiler mangles names of generated functions and attributes in JavaScript code. To control the generated names, you can use the &lt;code&gt;@JsName&lt;/code&gt; annotation:</source>
          <target state="translated">在某些情况下（例如，为了支持重载），Kotlin编译器会破坏JavaScript代码中生成的函数和属性的名称。要控制生成的名称，可以使用 &lt;code&gt;@JsName&lt;/code&gt; 批注：</target>
        </trans-unit>
        <trans-unit id="f1f62f22b0a379feb738d1ada9b061745859834e" translate="yes" xml:space="preserve">
          <source>In some cases (for example, to support overloads), the Kotlin compiler mangles the names of generated functions and attributes in JavaScript code. To control the generated names, you can use the &lt;code&gt;@JsName&lt;/code&gt; annotation:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f1f57175de66b286d8ac98729c81851940d41f3" translate="yes" xml:space="preserve">
          <source>In some cases functions with no arguments might be interchangeable with read-only properties. Although the semantics are similar, there are some stylistic conventions on when to prefer one to another.</source>
          <target state="translated">在某些情况下,没有参数的函数可以和只读属性互换。虽然语义相似,但在什么情况下,有一些风格上的约定。</target>
        </trans-unit>
        <trans-unit id="4526b2f446cfa690eb7c5baadbe7c8dea021438f" translate="yes" xml:space="preserve">
          <source>In some ways, this is easier to read because the operations are specified in the order they are applied to the values. The result will be an immutable &lt;code&gt;List&amp;lt;T&amp;gt;&lt;/code&gt;, where &lt;code&gt;T&lt;/code&gt; is whichever type is produced by the transformations you use (in this case, &lt;code&gt;String&lt;/code&gt;). If you need a mutable list, call &lt;code&gt;toMutableList()&lt;/code&gt; at the end. If you want a set, call &lt;code&gt;toSet()&lt;/code&gt; or &lt;code&gt;toMutableSet()&lt;/code&gt; at the end. If you want to transform a collection into a map, call &lt;code&gt;associateBy()&lt;/code&gt;, which takes two lambdas that specify how to extract the key and the value from each element: &lt;code&gt;people.associateBy({it.ssn}, {it.name})&lt;/code&gt; (you can omit the second lambda if you want the entire element to be the value, and you can call &lt;code&gt;toMutableMap()&lt;/code&gt; at the end if you want the result to be mutable).</source>
          <target state="translated">在某些方面，这更易于阅读，因为操作是按照它们应用于值的顺序指定的。结果将是一个不变的 &lt;code&gt;List&amp;lt;T&amp;gt;&lt;/code&gt; ，其中 &lt;code&gt;T&lt;/code&gt; 是您使用的转换产生的任何类型（在这种情况下为 &lt;code&gt;String&lt;/code&gt; ）。如果需要可变列表，请在最后调用 &lt;code&gt;toMutableList()&lt;/code&gt; 。如果需要集合，请在最后调用 &lt;code&gt;toSet()&lt;/code&gt; 或 &lt;code&gt;toMutableSet()&lt;/code&gt; 。如果要将集合转换为地图，请调用 &lt;code&gt;associateBy()&lt;/code&gt; ，它需要两个lambda来指定如何从每个元素中提取键和值： &lt;code&gt;people.associateBy({it.ssn}, {it.name})&lt;/code&gt; （如果希望整个元素作为值，则可以省略第二个lambda；如果希望结果可变，则可以在最后调用 &lt;code&gt;toMutableMap()&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="482c7a83b939d337af8bf0cb41a70749c1cb67ed" translate="yes" xml:space="preserve">
          <source>In spite of the &lt;code&gt;object&lt;/code&gt; keyword being used, a new instance of the anonymous class will be created whenever the object expression is evaluated.</source>
          <target state="translated">尽管使用了 &lt;code&gt;object&lt;/code&gt; 关键字，但是每当计算对象表达式时，都会创建一个匿名类的新实例。</target>
        </trans-unit>
        <trans-unit id="10fed13cfcbccf5e09d7648e3ceabcf9a0d8e2f5" translate="yes" xml:space="preserve">
          <source>In spite of this syntactical convenience, the companion object is a proper object on its own, and can have its own supertypes - and you can assign it to a variable and pass it around. If you're integrating with Java code and need a true &lt;code&gt;static&lt;/code&gt; member, you can &lt;a href=&quot;annotations&quot;&gt;annotate&lt;/a&gt; a member inside a companion object with &lt;code&gt;@JvmStatic&lt;/code&gt;.</source>
          <target state="translated">尽管语法上很方便，但伴随对象本身就是一个合适的对象，并且可以具有自己的超类型-您可以将其分配给变量并传递给它。如果要与Java代码集成，并且需要一个真正的 &lt;code&gt;static&lt;/code&gt; 成员，则可以使用 &lt;code&gt;@JvmStatic&lt;/code&gt; 在同伴对象内&lt;a href=&quot;annotations&quot;&gt;注释&lt;/a&gt;一个成员。</target>
        </trans-unit>
        <trans-unit id="8be34c3c318a79f1a61390cd86ad3bb03f42aee7" translate="yes" xml:space="preserve">
          <source>In subsequent tutorials we'll show how you can influence the files generated, for example, change location, prefix and suffixes, and how you can work with modules.</source>
          <target state="translated">在后续的教程中,我们将展示如何影响生成的文件,例如,改变位置、前缀和后缀,以及如何使用模块。</target>
        </trans-unit>
        <trans-unit id="bc19aea0692b9f67e799748ba127b1fc2dfa9708" translate="yes" xml:space="preserve">
          <source>In tests (and &lt;strong&gt;only&lt;/strong&gt; in tests), it's acceptable to use method names with spaces enclosed in backticks. (Note that such method names are currently not supported by the Android runtime.) Underscores in method names are also allowed in test code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de0700bb726b0915ca84006a652a9bb020053b41" translate="yes" xml:space="preserve">
          <source>In tests (and only in tests), it's acceptable to use method names with spaces enclosed in backticks. (Note that such method names are currently not supported by the Android runtime.) Underscores in method names are also allowed in test code.</source>
          <target state="translated">在测试中(也只有在测试中),使用带空格的方法名是可以接受的。(注意,Android运行时目前不支持这样的方法名。)在测试代码中也允许在方法名中使用下划线。</target>
        </trans-unit>
        <trans-unit id="e4ad3e9e93913c50444eb70a3c6d491b3cf74240" translate="yes" xml:space="preserve">
          <source>In that case you need to use the spread operator &lt;code&gt;*&lt;/code&gt; to pass the &lt;code&gt;IntArray&lt;/code&gt;:</source>
          <target state="translated">在这种情况下，您需要使用传播运算符 &lt;code&gt;*&lt;/code&gt; 来传递 &lt;code&gt;IntArray&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="a1e90ae09efa8b0693d6eb0e54489eb2ffa5613b" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;#debugging-coroutines-and-threads&quot;&gt;debug mode&lt;/a&gt;, it outputs something like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dfa4bedab09a124fc51fd33f0b20a721f3509f7a" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;#enabling-experimental-features&quot;&gt;experimental mode&lt;/a&gt;, you can specify any variant name (not only flavor), e.g. &lt;code&gt;freeDebug&lt;/code&gt; or &lt;code&gt;freeRelease&lt;/code&gt; will work as well.</source>
          <target state="translated">在&lt;a href=&quot;#enabling-experimental-features&quot;&gt;实验模式下&lt;/a&gt;，您可以指定任何变体名称（不仅是flavor），例如 &lt;code&gt;freeDebug&lt;/code&gt; 或 &lt;code&gt;freeRelease&lt;/code&gt; 也可以使用。</target>
        </trans-unit>
        <trans-unit id="34502d3bacebdc9ab51090cbc1ee8b5aa02dcb57" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;libnative_api.h&lt;/code&gt;, we'll find the following code. We will discuss the code in parts to make it easier to understand.</source>
          <target state="translated">在 &lt;code&gt;libnative_api.h&lt;/code&gt; 中，我们将找到以下代码。我们将分部分讨论代码，以使其更易于理解。</target>
        </trans-unit>
        <trans-unit id="97cbe1bbd40fde30fcff61322aab402c1acd97ce" translate="yes" xml:space="preserve">
          <source>In the Gradle dependencies you use add the &lt;code&gt;kotlin-kapt&lt;/code&gt; plugin and replace &lt;code&gt;annotationProcessor&lt;/code&gt; with &lt;code&gt;kapt&lt;/code&gt;:</source>
          <target state="translated">在Gradle依赖项中，您使用添加 &lt;code&gt;kotlin-kapt&lt;/code&gt; 插件，并用 &lt;code&gt;kapt&lt;/code&gt; 替换 &lt;code&gt;annotationProcessor&lt;/code&gt; 处理程序：</target>
        </trans-unit>
        <trans-unit id="a87144873c9b9ee0a65c1c2fda83f3948fb32756" translate="yes" xml:space="preserve">
          <source>In the JavaScript world, a completely different set of APIs is availiable, so one could instead implement logging to the console:</source>
          <target state="translated">在JavaScript的世界里,有一套完全不同的API可以使用,所以我们可以实现对控制台的日志记录。</target>
        </trans-unit>
        <trans-unit id="cc47ebd8b09857b2d92aa6e80c268cb28a620e3a" translate="yes" xml:space="preserve">
          <source>In the Kotlin Gradle DSL, there is also a shortcut for setting the CommonJS module kind:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="952c75185ceff6a4ea2264e236a32b30e1121e70" translate="yes" xml:space="preserve">
          <source>In the code above, the parameter &lt;code&gt;combine&lt;/code&gt; has a &lt;a href=&quot;#function-types&quot;&gt;function type&lt;/a&gt;&lt;code&gt;(R, T) -&amp;gt; R&lt;/code&gt;, so it accepts a function that takes two arguments of types &lt;code&gt;R&lt;/code&gt; and &lt;code&gt;T&lt;/code&gt; and returns a value of type &lt;code&gt;R&lt;/code&gt;. It is &lt;a href=&quot;#invoking-a-function-type-instance&quot;&gt;invoked&lt;/a&gt; inside the &lt;em&gt;for&lt;/em&gt;-loop, and the return value is then assigned to &lt;code&gt;accumulator&lt;/code&gt;.</source>
          <target state="translated">在上面的代码中，参数 &lt;code&gt;combine&lt;/code&gt; 具有&lt;a href=&quot;#function-types&quot;&gt;函数类型&lt;/a&gt; &lt;code&gt;(R, T) -&amp;gt; R&lt;/code&gt; ，因此它接受一个函数，该函数接受 &lt;code&gt;R&lt;/code&gt; 和 &lt;code&gt;T&lt;/code&gt; 类型的两个参数并返回 &lt;code&gt;R&lt;/code&gt; 类型的值。在&lt;em&gt;for&lt;/em&gt;循环内&lt;a href=&quot;#invoking-a-function-type-instance&quot;&gt;调用&lt;/a&gt;它，然后将返回值分配给 &lt;code&gt;accumulator&lt;/code&gt; 。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="983dc81454e62d4d8dfeb15d4d6704ae3670a9b1" translate="yes" xml:space="preserve">
          <source>In the example above, the production sources for the JVM target are compiled by its &lt;code&gt;main&lt;/code&gt; compilation and therefore include the sources and dependencies from the source sets &lt;code&gt;jvmMain&lt;/code&gt; and &lt;code&gt;commonMain&lt;/code&gt; (due to the &lt;em&gt;depends on&lt;/em&gt; relation):</source>
          <target state="translated">在上面的示例中，JVM目标的生产源通过其 &lt;code&gt;main&lt;/code&gt; 编译进行编译，因此包括来自源集 &lt;code&gt;jvmMain&lt;/code&gt; 和 &lt;code&gt;commonMain&lt;/code&gt; 的源和依赖项（由于&lt;em&gt;取决于&lt;/em&gt;关系）：</target>
        </trans-unit>
        <trans-unit id="92a4732d4ba58bb8eb4b7a1a153809f54718cd39" translate="yes" xml:space="preserve">
          <source>In the example below, we assume that there is a &lt;code&gt;DbModel&lt;/code&gt; base class, and that every subclass has got a parameterless primary constructor. In the inline function, &lt;code&gt;T&lt;/code&gt; is reified, so we can get the class metadata. We pass this to the function that does the real work of talking to the database.</source>
          <target state="translated">在下面的示例中，我们假设有一个 &lt;code&gt;DbModel&lt;/code&gt; 基类，并且每个子类都有一个无参数的主构造函数。在内联函数中，对 &lt;code&gt;T&lt;/code&gt; 进行了归一化，因此我们可以获得类元数据。我们将此传递给执行与数据库对话的实际工作的函数。</target>
        </trans-unit>
        <trans-unit id="f9725b5629cf5c05b1dabad8df3abc795d27f14a" translate="yes" xml:space="preserve">
          <source>In the example we have the most popular ways to pass or receive a string in the C language. We should take the return of &lt;code&gt;return_string&lt;/code&gt; with care. In general, it is best to make sure we use the right function to dispose the returned &lt;code&gt;char*&lt;/code&gt; with the right &lt;code&gt;free(..)&lt;/code&gt; function call.</source>
          <target state="translated">在该示例中，我们采用了最流行的方式来传递或接收C语言中的字符串。我们应该小心地返回 &lt;code&gt;return_string&lt;/code&gt; 。通常，最好确保我们使用正确的函数通过正确的 &lt;code&gt;free(..)&lt;/code&gt; 函数调用来处理返回的 &lt;code&gt;char*&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="45b64e498fcd11490ca143779a88435b7d9e0b0c" translate="yes" xml:space="preserve">
          <source>In the following example, &lt;code&gt;findViewById()&lt;/code&gt; is only invoked once:</source>
          <target state="translated">在下面的示例中， &lt;code&gt;findViewById()&lt;/code&gt; 仅被调用一次：</target>
        </trans-unit>
        <trans-unit id="8cf0c93c6e85cb80e10b5e71f71e2e6899fc70c7" translate="yes" xml:space="preserve">
          <source>In the generated Kotlin declarations, we see that &lt;code&gt;str&lt;/code&gt; is represented as &lt;code&gt;CValuesRef&amp;lt;ByteVar/&amp;gt;?&lt;/code&gt;. The type is nullable, and we can simply pass Kotlin &lt;code&gt;null&lt;/code&gt; as the parameter value.</source>
          <target state="translated">在生成的Kotlin声明中，我们看到 &lt;code&gt;str&lt;/code&gt; 表示为 &lt;code&gt;CValuesRef&amp;lt;ByteVar/&amp;gt;?&lt;/code&gt; 。该类型是可为空的，我们可以简单地将Kotlin &lt;code&gt;null&lt;/code&gt; 作为参数值传递。</target>
        </trans-unit>
        <trans-unit id="6ffd682e74db1be23092050eecf5e03af23b3260" translate="yes" xml:space="preserve">
          <source>In the generated code, the &lt;code&gt;provideDelegate&lt;/code&gt; method is called to initialize the auxiliary &lt;code&gt;prop$delegate&lt;/code&gt; property. Compare the generated code for the property declaration &lt;code&gt;val prop: Type by MyDelegate()&lt;/code&gt; with the generated code &lt;a href=&quot;delegated-properties#translation-rules&quot;&gt;above&lt;/a&gt; (when the &lt;code&gt;provideDelegate&lt;/code&gt; method is not present):</source>
          <target state="translated">在生成的代码中，调用 &lt;code&gt;provideDelegate&lt;/code&gt; 方法以初始化辅助 &lt;code&gt;prop$delegate&lt;/code&gt; 属性。比较属性声明 &lt;code&gt;val prop: Type by MyDelegate()&lt;/code&gt; 的生成代码：使用MyDelegate（）键入&lt;a href=&quot;delegated-properties#translation-rules&quot;&gt;上面&lt;/a&gt;的生成代码（当不提供 &lt;code&gt;provideDelegate&lt;/code&gt; 方法时）：</target>
        </trans-unit>
        <trans-unit id="f86f30c4d84e613891c93b386289b1fcc35ce4d5" translate="yes" xml:space="preserve">
          <source>In the last line &lt;code&gt;button&lt;/code&gt; is referenced by &lt;code&gt;id&lt;/code&gt; using the &lt;a href=&quot;android-plugin&quot;&gt;Kotlin Android Extensions&lt;/a&gt; plugin. Consider using this plugin as an alternative which allows you to keep binding logic in code and have the concise syntax at the same time.</source>
          <target state="translated">在最后一行，使用&lt;a href=&quot;android-plugin&quot;&gt;Kotlin Android扩展&lt;/a&gt;插件通过 &lt;code&gt;id&lt;/code&gt; 引用了 &lt;code&gt;button&lt;/code&gt; 。考虑使用此插件作为替代方案，它使您可以将绑定逻辑保留在代码中，并同时具有简洁的语法。</target>
        </trans-unit>
        <trans-unit id="7da80e212e3fb5a8c2cf3d597abb266f174acf51" translate="yes" xml:space="preserve">
          <source>In the last line, there's an implicit &lt;code&gt;this.&lt;/code&gt; in front of both &lt;code&gt;memberFunction()&lt;/code&gt; and &lt;code&gt;memberProperty&lt;/code&gt; (if these exist on the type of &lt;code&gt;someExpression&lt;/code&gt;). The return value is that of the last expression.</source>
          <target state="translated">在最后一行，有一个隐式的 &lt;code&gt;this.&lt;/code&gt; 在 &lt;code&gt;memberFunction()&lt;/code&gt; 和 &lt;code&gt;memberProperty&lt;/code&gt; 前面（如果它们存在于 &lt;code&gt;someExpression&lt;/code&gt; 类型上）。返回值是最后一个表达式的值。</target>
        </trans-unit>
        <trans-unit id="21de312c94f28c9a74e944cc50e80500b0df440a" translate="yes" xml:space="preserve">
          <source>In the next dialog, provide the project details:</source>
          <target state="translated">在下一个对话框中,提供项目细节。</target>
        </trans-unit>
        <trans-unit id="fb8d123847c0bf27cf6ffe6e978d7163ff9a921d" translate="yes" xml:space="preserve">
          <source>In the old model, common and platform-specific code needed to be placed in separate modules, linked by &lt;code&gt;expectedBy&lt;/code&gt; dependencies. Now, common and platform-specific code is placed in different source roots of the same module, making projects easier to configure.</source>
          <target state="translated">在旧模型中，需要将通用代码和特定于平台的代码放置在单独的模块中，并按 &lt;code&gt;expectedBy&lt;/code&gt; 依赖关系进行链接。现在，通用代码和特定于平台的代码被放置在同一模块的不同源根目录中，从而使项目更易于配置。</target>
        </trans-unit>
        <trans-unit id="ca766f4efd26534c30d9c87798187848fcb65628" translate="yes" xml:space="preserve">
          <source>In the presence of &lt;code&gt;maven-publish&lt;/code&gt; plugin the publications for all the binaries built are created. The plugin uses Gradle metadata to publish the artifacts so this feature must be enabled (see the &lt;a href=&quot;#dependencies&quot;&gt;dependencies&lt;/a&gt; section).</source>
          <target state="translated">在存在 &lt;code&gt;maven-publish&lt;/code&gt; 插件的情况下，将创建所有已构建二进制文件的发布。该插件使用Gradle元数据发布构件，因此必须启用此功能（请参阅&lt;a href=&quot;#dependencies&quot;&gt;依赖项&lt;/a&gt;部分）。</target>
        </trans-unit>
        <trans-unit id="d60dd59e4676a95bd7097287912e2ec3768e0f9a" translate="yes" xml:space="preserve">
          <source>In the previous example the JavaScript module exports a single package. However, some JavaScript libraries export multiple packages from within a module. This case is also supported by Kotlin, though you have to declare a new &lt;code&gt;.kt&lt;/code&gt; file for each package you import.</source>
          <target state="translated">在前面的示例中，JavaScript模块导出单个包。但是，某些JavaScript库从模块内部导出多个包。Kotlin也支持这种情况，尽管您必须为导入的每个包声明一个新的 &lt;code&gt;.kt&lt;/code&gt; 文件。</target>
        </trans-unit>
        <trans-unit id="42d1f7acaeec00a73953ae801ded4c35e710f59f" translate="yes" xml:space="preserve">
          <source>In the tutorial we will learn:</source>
          <target state="translated">在教程中我们将学习。</target>
        </trans-unit>
        <trans-unit id="5c983473a452d20ce90bb4b7f97f64c188d78e2f" translate="yes" xml:space="preserve">
          <source>In the tutorial we:</source>
          <target state="translated">在本教程中,我们。</target>
        </trans-unit>
        <trans-unit id="91d34ec07b8ea3ab8718a88b953168add8f0c256" translate="yes" xml:space="preserve">
          <source>In these examples &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-exception-handler/index.html&quot;&gt;CoroutineExceptionHandler&lt;/a&gt; is always installed to a coroutine that is created in &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-global-scope/index.html&quot;&gt;GlobalScope&lt;/a&gt;. It does not make sense to install an exception handler to a coroutine that is launched in the scope of the main &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/run-blocking.html&quot;&gt;runBlocking&lt;/a&gt;, since the main coroutine is going to be always cancelled when its child completes with exception despite the installed handler.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="095e7f10496f59e9c1f965ea0b808ca458b5529c" translate="yes" xml:space="preserve">
          <source>In this case the compiler will not be downloaded by the plugin.</source>
          <target state="translated">在这种情况下,编译器将不会被插件下载。</target>
        </trans-unit>
        <trans-unit id="f1f881dff617021acda0968035a0c51bb38a1c2d" translate="yes" xml:space="preserve">
          <source>In this case, JQuery will be imported as a module named &lt;code&gt;jquery&lt;/code&gt;. Alternatively, it can be used as a $-object, depending on what module system Kotlin compiler is configured to use.</source>
          <target state="translated">在这种情况下，JQuery将作为名为 &lt;code&gt;jquery&lt;/code&gt; 的模块导入。另外，它可以用作$对象，具体取决于Kotlin编译器配置使用的模块系统。</target>
        </trans-unit>
        <trans-unit id="c032e19443eb1eff2c0c1528c6eb2e5d72dfce23" translate="yes" xml:space="preserve">
          <source>In this case, we've set the output of our compilation to the &lt;code&gt;scripts&lt;/code&gt; folder. On running the application we should see the following output:</source>
          <target state="translated">在这种情况下，我们已将编译的输出设置为 &lt;code&gt;scripts&lt;/code&gt; 文件夹。在运行应用程序时，我们应该看到以下输出：</target>
        </trans-unit>
        <trans-unit id="de0ac72463e7c41b8825d92484726f740a2112b2" translate="yes" xml:space="preserve">
          <source>In this dense code, in addition to collection transformations, you can see such handy Kotlin features as local functions and the &lt;a href=&quot;../reference/null-safety#elvis-operator&quot;&gt;elvis operator&lt;/a&gt;&lt;code&gt;?:&lt;/code&gt; that allow to express &lt;a href=&quot;../reference/idioms&quot;&gt;idioms&lt;/a&gt; like &quot;take the value if it is positive or else use length&quot; with a concise and readable expressions like &lt;code&gt;.takeIf { it &amp;gt;= 0 } ?: s.length&lt;/code&gt;, yet it is perfectly fine with Kotlin to create additional mutable variables and express the same code in imperative style, too.</source>
          <target state="translated">在这个密集的代码中，除了集合转换之外，您还可以看到便利的Kotlin功能（例如局部函数和&lt;a href=&quot;../reference/null-safety#elvis-operator&quot;&gt;elvis运算符&lt;/a&gt; &lt;code&gt;?:&lt;/code&gt; 可以表达简洁明了的&lt;a href=&quot;../reference/idioms&quot;&gt;习惯用法，&lt;/a&gt;例如&amp;ldquo;取正则取值，否则使用长度&amp;rdquo;。可读的表达式，例如 &lt;code&gt;.takeIf { it &amp;gt;= 0 } ?: s.length&lt;/code&gt; ，但是对于Kotlin来说，创建其他可变变量并以命令式方式表示相同的代码也很好。</target>
        </trans-unit>
        <trans-unit id="e691bb86d414ab1eeeac0ce8d8cf107c13b24d6b" translate="yes" xml:space="preserve">
          <source>In this doc, we'll sometimes specify the type unnecessarily, in order to highlight what type is produced by an expression. (Also, a good IDE will be able to show you the resulting type.)</source>
          <target state="translated">在本文档中,我们有时会不必要地指定类型,以突出表达式产生的是什么类型。(另外,一个好的IDE将能够向你展示产生的类型。)</target>
        </trans-unit>
        <trans-unit id="7d12593ba02967f080622029b34989f6d346aaf9" translate="yes" xml:space="preserve">
          <source>In this document we introduce several kinds of compatibility:</source>
          <target state="translated">在本文档中,我们介绍了几种兼容性。</target>
        </trans-unit>
        <trans-unit id="537f8c16fc8f03cc135b33707b31eb29f9995ea0" translate="yes" xml:space="preserve">
          <source>In this example only members of the nearest implicit receiver &lt;code&gt;this@head&lt;/code&gt; must be available; &lt;code&gt;head()&lt;/code&gt; is a member of the outer receiver &lt;code&gt;this@html&lt;/code&gt;, so it must be illegal to call it.</source>
          <target state="translated">在此示例中，仅最近的隐式接收者 &lt;code&gt;this@head&lt;/code&gt; 必须可用； &lt;code&gt;head()&lt;/code&gt; 是外部接收者 &lt;code&gt;this@html&lt;/code&gt; 的成员，因此调用它必须是非法的。</target>
        </trans-unit>
        <trans-unit id="9c36d65c210f75f6cba412252945fedc98c222bc" translate="yes" xml:space="preserve">
          <source>In this example we launch a new coroutine in a background thread pool using &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-dispatchers/-default.html&quot;&gt;Dispatchers.Default&lt;/a&gt;, so it works on a different thread from the thread pool, but it still has the value of the thread local variable that we specified using &lt;code&gt;threadLocal.asContextElement(value = &quot;launch&quot;)&lt;/code&gt;, no matter which thread the coroutine is executed on. Thus, the output (with &lt;a href=&quot;#debugging-coroutines-and-threads&quot;&gt;debug&lt;/a&gt;) is:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67582c167007a9ba92244086b3d65c9a9e9700f4" translate="yes" xml:space="preserve">
          <source>In this example we launch a new coroutine in a background thread pool using &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-dispatchers/-default.html&quot;&gt;Dispatchers.Default&lt;/a&gt;, so it works on a different threads from a thread pool, but it still has the value of thread local variable, that we've specified using &lt;code&gt;threadLocal.asContextElement(value = &quot;launch&quot;)&lt;/code&gt;, no matter on what thread the coroutine is executed. Thus, output (with &lt;a href=&quot;#debugging-coroutines-and-threads&quot;&gt;debug&lt;/a&gt;) is:</source>
          <target state="translated">在此示例中，我们使用&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-dispatchers/-default.html&quot;&gt;Dispatchers.Default&lt;/a&gt;在后台线程池中启动了一个新协程，因此它可以在与线程池不同的线程上工作，但是它仍然具有我们使用 &lt;code&gt;threadLocal.asContextElement(value = &quot;launch&quot;)&lt;/code&gt; 指定的线程局部变量的值。（value =&amp;ldquo; launch&amp;rdquo;），无论协程执行在哪个线程上。因此，输出（带有&lt;a href=&quot;#debugging-coroutines-and-threads&quot;&gt;debug&lt;/a&gt;）为：</target>
        </trans-unit>
        <trans-unit id="872d3ddd1be8b8c4ec3ab8cc792f3b5cde57d822" translate="yes" xml:space="preserve">
          <source>In this example, all values passed to the C API &lt;code&gt;new_menu()&lt;/code&gt; have a lifetime of the innermost &lt;code&gt;memScope&lt;/code&gt; it belongs to. Once the control flow leaves the &lt;code&gt;memScoped&lt;/code&gt; scope the C pointers become invalid.</source>
          <target state="translated">在此示例中，所有传递给C API &lt;code&gt;new_menu()&lt;/code&gt; 的值都具有其所属的最内部 &lt;code&gt;memScope&lt;/code&gt; 的生存期。一旦控制流离开 &lt;code&gt;memScoped&lt;/code&gt; 范围，则C指针将变为无效。</target>
        </trans-unit>
        <trans-unit id="5b70f0a7dd260f72c7acee91c3f5762c472a459a" translate="yes" xml:space="preserve">
          <source>In this example, the constructor takes a map:</source>
          <target state="translated">在这个例子中,构造函数取一个地图。</target>
        </trans-unit>
        <trans-unit id="06698ce38b883fc740d14dcc830fa9e382960eb5" translate="yes" xml:space="preserve">
          <source>In this example, the sequence processing takes 18 steps instead of 23 steps for doing the same with lists.</source>
          <target state="translated">在这个例子中,序列处理需要18步,而不是对列表进行同样的处理需要23步。</target>
        </trans-unit>
        <trans-unit id="550b3c67b81cc4d4252fe83306649fc1df1e86da" translate="yes" xml:space="preserve">
          <source>In this example, using &lt;code&gt;Person&lt;/code&gt; and &lt;code&gt;callAndPrintTwoParam()&lt;/code&gt; from the previous section, we locate a member function reference by name and call it:</source>
          <target state="translated">在此示例中，使用上一节中的 &lt;code&gt;Person&lt;/code&gt; 和 &lt;code&gt;callAndPrintTwoParam()&lt;/code&gt; ，我们按名称查找成员函数引用并对其进行调用：</target>
        </trans-unit>
        <trans-unit id="25017fcbb3e37d1b9106fc29788136cb1c456365" translate="yes" xml:space="preserve">
          <source>In this function both &lt;a href=&quot;-continuation/resume&quot;&gt;Continuation.resume&lt;/a&gt; and &lt;a href=&quot;-continuation/resume-with-exception&quot;&gt;Continuation.resumeWithException&lt;/a&gt; can be used either synchronously in the same stack-frame where suspension function is run or asynchronously later in the same thread or from a different thread of execution. Repeated invocation of any resume function produces &lt;a href=&quot;../kotlin/-illegal-state-exception/index#kotlin.IllegalStateException&quot;&gt;IllegalStateException&lt;/a&gt;.</source>
          <target state="translated">在此函数中，&lt;a href=&quot;-continuation/resume&quot;&gt;Continuation.resume&lt;/a&gt;和&lt;a href=&quot;-continuation/resume-with-exception&quot;&gt;Continuation.resumeWithException&lt;/a&gt;可以在运行暂停功能的同一堆栈帧中同步使用，也可以稍后在同一线程或不同执行线程中异步使用。重复调用任何恢复函数都会产生&lt;a href=&quot;../kotlin/-illegal-state-exception/index#kotlin.IllegalStateException&quot;&gt;IllegalStateException&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a802dce08d5c39703b387f16a864974235e44de0" translate="yes" xml:space="preserve">
          <source>In this function both &lt;a href=&quot;resume&quot;&gt;Continuation.resume&lt;/a&gt; and &lt;a href=&quot;resume-with-exception&quot;&gt;Continuation.resumeWithException&lt;/a&gt; can be used either synchronously in the same stack-frame where the suspension function is run or asynchronously later in the same thread or from a different thread of execution. Subsequent invocation of any resume function will produce an &lt;a href=&quot;../kotlin/-illegal-state-exception/index#kotlin.IllegalStateException&quot;&gt;IllegalStateException&lt;/a&gt;.</source>
          <target state="translated">在此函数中，&lt;a href=&quot;resume&quot;&gt;Continuation.resume&lt;/a&gt;和&lt;a href=&quot;resume-with-exception&quot;&gt;Continuation.resumeWithException&lt;/a&gt;可以在运行暂停函数的同一堆栈帧中同步使用，也可以稍后在同一线程或不同执行线程中异步使用。随后调用任何resume函数将产生一个&lt;a href=&quot;../kotlin/-illegal-state-exception/index#kotlin.IllegalStateException&quot;&gt;IllegalStateException&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="677125a2bada551194ff25d8eec9f1b62a3c4ba4" translate="yes" xml:space="preserve">
          <source>In this section a commented DSL is shown. See also the example projects that use this plugin, e.g. &lt;a href=&quot;https://github.com/Kotlin/kotlinx.coroutines&quot;&gt;Kotlinx.coroutines&lt;/a&gt;, &lt;a href=&quot;https://github.com/e5l/http-client-common/tree/master/samples/ios-test-application&quot;&gt;MPP http client&lt;/a&gt;</source>
          <target state="translated">在本节中，显示了注释的DSL。另请参见使用此插件的示例项目，例如&lt;a href=&quot;https://github.com/Kotlin/kotlinx.coroutines&quot;&gt;Kotlinx.coroutines&lt;/a&gt;，&lt;a href=&quot;https://github.com/e5l/http-client-common/tree/master/samples/ios-test-application&quot;&gt;MPP http客户端&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="45d0e31509240af7f0d899e0847fb308f3f6c3d9" translate="yes" xml:space="preserve">
          <source>In this tutorial We will learn how to:</source>
          <target state="translated">在本教程中,我们将学习如何。</target>
        </trans-unit>
        <trans-unit id="b8d78e48aa113b25ef679f219669ead0543c6d9d" translate="yes" xml:space="preserve">
          <source>In this tutorial however, we'll see how to use some specific libraries, such as &lt;code&gt;libcurl&lt;/code&gt;. We'll learn to</source>
          <target state="translated">但是，在本教程中，我们将看到如何使用某些特定的库，例如 &lt;code&gt;libcurl&lt;/code&gt; 。我们将学习</target>
        </trans-unit>
        <trans-unit id="38ae904b992e64be7d6f1c95db212a698e90d2ef" translate="yes" xml:space="preserve">
          <source>In this tutorial we have:</source>
          <target state="translated">在本教程中,我们有。</target>
        </trans-unit>
        <trans-unit id="814c4fd32a87a880ed24663823d0826f5fba0218" translate="yes" xml:space="preserve">
          <source>In this tutorial we see how to deal with C strings in Kotlin/Native. We will learn how to:</source>
          <target state="translated">在本教程中,我们将看到如何在Kotlin/Native中处理C字符串。我们将学习如何</target>
        </trans-unit>
        <trans-unit id="f187570814c6d6abda5a2c00ead30d73ef74a12e" translate="yes" xml:space="preserve">
          <source>In this tutorial we will create an iOS and Android application, by making use of Kotlin's code sharing features. For Android we'll be using Kotlin/JVM, while for iOS it will be Kotlin/Native.</source>
          <target state="translated">在本教程中,我们将利用Kotlin的代码共享功能,创建一个iOS和Android应用程序。对于Android,我们将使用Kotlin/JVM,而对于iOS,将使用Kotlin/Native。</target>
        </trans-unit>
        <trans-unit id="e75dd7cce5c41f63288c1748bd5bfd1c78d1ff1b" translate="yes" xml:space="preserve">
          <source>In this tutorial we'll see how to</source>
          <target state="translated">在本教程中,我们将看到如何做到</target>
        </trans-unit>
        <trans-unit id="73192ff47f695a8d1b74a36ad93cdb6ae37eb2de" translate="yes" xml:space="preserve">
          <source>In this tutorial we'll walk through the steps required to use the Kotlin Android Extensions plugin, enhancing the experience of Android development.</source>
          <target state="translated">在本教程中,我们将介绍使用Kotlin Android Extensions插件所需的步骤,提升Android开发的体验。</target>
        </trans-unit>
        <trans-unit id="f0e340bf119483d38d43d3af161837206adf260c" translate="yes" xml:space="preserve">
          <source>In this tutorial we'll walk through the steps required. For a more thorough explanation of Spring Boot and Kotlin, please see &lt;a href=&quot;https://spring.io/guides/tutorials/spring-boot-kotlin/&quot;&gt;Building web applications with Spring Boot and Kotlin&lt;/a&gt;.</source>
          <target state="translated">在本教程中，我们将逐步完成所需的步骤。有关Spring Boot和Kotlin的更详尽说明，请参阅&lt;a href=&quot;https://spring.io/guides/tutorials/spring-boot-kotlin/&quot;&gt;使用Spring Boot和Kotlin构建Web应用程序&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="04ead99e3026a0a00111c1c9a4f51b0c3c739752" translate="yes" xml:space="preserve">
          <source>In this tutorial we'll:</source>
          <target state="translated">在本教程中,我们将。</target>
        </trans-unit>
        <trans-unit id="0f464678d81fef87702589d2f00f58596a930600" translate="yes" xml:space="preserve">
          <source>In this tutorial we're going to use IntelliJ IDEA. For instructions on how to compile and execute Kotlin applications using the command line compiler, see &lt;a href=&quot;command-line&quot;&gt;Working with the Command Line Compiler&lt;/a&gt;.</source>
          <target state="translated">在本教程中，我们将使用IntelliJ IDEA。有关如何使用命令行编译器编译和执行Kotlin应用程序的说明，请参阅&lt;a href=&quot;command-line&quot;&gt;使用命令行编译器&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a5d5b9a27b34d95239a0c33821d0a9b033c40bd3" translate="yes" xml:space="preserve">
          <source>In this tutorial we've seen how to create a Kotlin application that targets JavaScript, debug it as well as set compiler options. In other tutorials we'll cover more in-depth topics such as interacting with the DOM, etc.</source>
          <target state="translated">在本教程中,我们已经看到了如何创建一个以JavaScript为目标的Kotlin应用程序,调试它以及设置编译器选项。在其他教程中,我们将涉及更深入的主题,如与DOM的交互等。</target>
        </trans-unit>
        <trans-unit id="15ab8dc4bd9f08f596ae63880b3958cb4434a6d7" translate="yes" xml:space="preserve">
          <source>In this tutorial, we learn what C data types are visible in Kotlin/Native and vice versa. We will:</source>
          <target state="translated">在本教程中,我们将学习哪些C数据类型在Kotlin/Native中可见,反之亦然。我们将</target>
        </trans-unit>
        <trans-unit id="8a05d2cdb1fd77bc1ee6b2a0bfc489f7b20f51b2" translate="yes" xml:space="preserve">
          <source>In this tutorial, we look at how we can use the Kotlin/Native code from existing native applications or libraries. For this, we need to compile our Kotlin code into a dynamic library, &lt;code&gt;.so&lt;/code&gt;, &lt;code&gt;.dylib&lt;/code&gt;, and &lt;code&gt;.dll&lt;/code&gt;.</source>
          <target state="translated">在本教程中，我们将研究如何从现有的本机应用程序或库中使用Kotlin / Native代码。为此，我们需要将Kotlin代码编译为动态库 &lt;code&gt;.so&lt;/code&gt; ， &lt;code&gt;.dylib&lt;/code&gt; 和 &lt;code&gt;.dll&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="701903e9f376cd1d8503774a4d299554e97196a0" translate="yes" xml:space="preserve">
          <source>In this tutorial, we will build a small library available from the worlds of JVM, JS, and Native. You will learn step-by-step how to create a multiplatform library which can be used from any other common code (e.g., one shared with Android and iOS), and how to write tests which will be executed on all platforms and use an efficient implementation provided by the concrete platform.</source>
          <target state="translated">在本教程中,我们将建立一个可从JVM、JS和Native世界中获得的小库。你将逐步学习如何创建一个多平台库,它可以从任何其他通用代码(例如,一个与Android和iOS共享的代码),以及如何编写将在所有平台上执行的测试,并使用具体平台提供的有效实现。</target>
        </trans-unit>
        <trans-unit id="8459da0cf638e813dae1e5c0fa95e9568c3582bd" translate="yes" xml:space="preserve">
          <source>In this tutorial, we will look at how to use Kotlin/Native code from Objective-C and Swift applications on macOS and iOS. We will build a framework from Kotlin code.</source>
          <target state="translated">在本教程中,我们将探讨如何在macOS和iOS上使用Objective-C和Swift应用程序的Kotlin/Native代码。我们将从Kotlin代码构建一个框架。</target>
        </trans-unit>
        <trans-unit id="864dde628feba0ddb56fa697c290d183bee8b077" translate="yes" xml:space="preserve">
          <source>In this tutorial, we will:</source>
          <target state="translated">在本教程中,我们将。</target>
        </trans-unit>
        <trans-unit id="98c10d04454a966f67cb1dfe790300722810cd2d" translate="yes" xml:space="preserve">
          <source>In this tutorial, we'll look at how to</source>
          <target state="translated">在本教程中,我们将看一看如何进行以下操作</target>
        </trans-unit>
        <trans-unit id="0c3ebd5f96036d4c23f2a9d6d5dd9911faa69aff" translate="yes" xml:space="preserve">
          <source>In this tutorial, we're going to be using Gradle but the same can be accomplished using either IntelliJ IDEA project structure or Maven. For details on setting up Gradle to work with Kotlin, see &lt;a href=&quot;../reference/using-gradle&quot;&gt;Using Gradle&lt;/a&gt;.</source>
          <target state="translated">在本教程中，我们将使用Gradle，但是可以使用IntelliJ IDEA项目结构或Maven来实现相同的目的。有关设置Gradle与Kotlin一起&lt;a href=&quot;../reference/using-gradle&quot;&gt;使用的&lt;/a&gt;详细信息，请参阅《使用Gradle》。</target>
        </trans-unit>
        <trans-unit id="aa1a5fa948935055fc078b1993ec8baed9df514c" translate="yes" xml:space="preserve">
          <source>In this tutorial, we're going to be using Gradle but the same can be accomplished using either IntelliJ IDEA project structure or Maven. For details on setting up Gradle to work with Kotlin, see &lt;a href=&quot;../reference/using-gradle&quot;&gt;Using Gradle&lt;/a&gt;. The main dependency required for using HTTP servlets is the JavaEE API:</source>
          <target state="translated">在本教程中，我们将使用Gradle，但是可以使用IntelliJ IDEA项目结构或Maven来实现相同的目的。有关设置Gradle与Kotlin一起&lt;a href=&quot;../reference/using-gradle&quot;&gt;使用的&lt;/a&gt;详细信息，请参阅《使用Gradle》。使用HTTP servlet所需的主要依赖关系是JavaEE API：</target>
        </trans-unit>
        <trans-unit id="40ab0f9121b36c46d899b6425de4821ece3db190" translate="yes" xml:space="preserve">
          <source>In this video, Kotlin Developer Advocate Sebastian Aigner will explain the main Kotlin/JS benefits to you, share some tips and use cases, and also tell you about the plans and upcoming features for Kotlin/JS.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23e1b785f9b5814cd84a43b0c10801c0740b41ac" translate="yes" xml:space="preserve">
          <source>In turn, &lt;code&gt;let&lt;/code&gt; and &lt;code&gt;also&lt;/code&gt; have the context object as a lambda argument. If the argument name is not specified, the object is accessed by the implicit default name &lt;code&gt;it&lt;/code&gt;. &lt;code&gt;it&lt;/code&gt; is shorter than &lt;code&gt;this&lt;/code&gt; and expressions with &lt;code&gt;it&lt;/code&gt; are usually easier for reading. However, when calling the object functions or properties you don't have the object available implicitly like &lt;code&gt;this&lt;/code&gt;. Hence, having the context object as &lt;code&gt;it&lt;/code&gt; is better when the object is mostly used as an argument in function calls. &lt;code&gt;it&lt;/code&gt; is also better if you use multiple variables in the code block.</source>
          <target state="translated">反过来， &lt;code&gt;let&lt;/code&gt; 和 &lt;code&gt;also&lt;/code&gt; 将上下文对象作为lambda参数。如果未指定参数名称，则使用隐式默认名称 &lt;code&gt;it&lt;/code&gt; 来访问对象。 &lt;code&gt;it&lt;/code&gt; 比 &lt;code&gt;this&lt;/code&gt; 短，并且带有 &lt;code&gt;it&lt;/code&gt; 表达式通常更易于阅读。但是，在调用对象函数或属性时，您没有像 &lt;code&gt;this&lt;/code&gt; 隐式可用的对象。因此，具有的上下文对象作为 &lt;code&gt;it&lt;/code&gt; 是更好当对象被主要用作在函数调用的参数。 &lt;code&gt;it&lt;/code&gt; 也更好，如果你在代码块中使用多个变量。</target>
        </trans-unit>
        <trans-unit id="812b574e96ace8dd4cdbeccd6ad6e3f2e4f0aabb" translate="yes" xml:space="preserve">
          <source>In turn, mutable collections aren't covariant; otherwise, this would lead to runtime failures. If &lt;code&gt;MutableList&amp;lt;Rectangle&amp;gt;&lt;/code&gt; was a subtype of &lt;code&gt;MutableList&amp;lt;Shape&amp;gt;&lt;/code&gt;, you could insert other &lt;code&gt;Shape&lt;/code&gt; inheritors (for example, &lt;code&gt;Circle&lt;/code&gt;) into it, thus violating its &lt;code&gt;Rectangle&lt;/code&gt; type argument.</source>
          <target state="translated">反过来，可变集合不是协变的。否则，将导致运行时失败。如果 &lt;code&gt;MutableList&amp;lt;Rectangle&amp;gt;&lt;/code&gt; 是 &lt;code&gt;MutableList&amp;lt;Shape&amp;gt;&lt;/code&gt; 的子类型，则可以在其中插入其他 &lt;code&gt;Shape&lt;/code&gt; 继承者（例如 &lt;code&gt;Circle&lt;/code&gt; ），从而违反其 &lt;code&gt;Rectangle&lt;/code&gt; 类型参数。</target>
        </trans-unit>
        <trans-unit id="2a50d6665033bbbaf15909f2a8b12edea9bb1926" translate="yes" xml:space="preserve">
          <source>In turn, set is not an ordered collection by &lt;a href=&quot;collections-overview&quot;&gt;definition&lt;/a&gt;. However, the Kotlin &lt;code&gt;Set&lt;/code&gt; stores elements in certain orders. These can be the order of insertion (in &lt;code&gt;LinkedHashSet&lt;/code&gt;), natural sorting order (in &lt;code&gt;SortedSet&lt;/code&gt;), or another order. The order of a set of elements can also be unknown. In such cases, the elements are still ordered somehow, so the functions that rely on the element positions still return their results. However, such results are unpredictable to the caller unless they know the specific implementation of &lt;code&gt;Set&lt;/code&gt; used.</source>
          <target state="translated">反过来，set并不是&lt;a href=&quot;collections-overview&quot;&gt;定义&lt;/a&gt;为有序集合。但是，Kotlin &lt;code&gt;Set&lt;/code&gt; 按某些顺序存储元素。这些可以是插入顺序（在 &lt;code&gt;LinkedHashSet&lt;/code&gt; 中），自然排序顺序（在 &lt;code&gt;SortedSet&lt;/code&gt; 中）或其他顺序。一组元素的顺序也可以是未知的。在这种情况下，元素仍然会以某种方式排序，因此依赖元素位置的函数仍会返回其结果。但是，除非调用者知道所使用 &lt;code&gt;Set&lt;/code&gt; 的特定实现，否则它们对调用者是不可预测的。</target>
        </trans-unit>
        <trans-unit id="26d300702c75a3b26e8ba1f4228f68dc28aca421" translate="yes" xml:space="preserve">
          <source>In turn, worksheets are project files: they are stored in project directories and tied to the project modules. Worksheets are useful for writing code parts that don't actually make a software unit but should still be stored together in a project. For example, you can use worksheets for education or demo materials.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01b654ef30cda18991ddded390d4b967ccf9e9a4" translate="yes" xml:space="preserve">
          <source>In your scratch, you can write any valid Kotlin code, including new functions and classes. Syntax highlighting, auto-completion, and other code editing features of IntelliJ IDEA are supported in scratches.</source>
          <target state="translated">在您的scratch中,您可以编写任何有效的Kotlin代码,包括新的函数和类。在scratches中支持IntelliJ IDEA的语法高亮、自动完成和其他代码编辑功能。</target>
        </trans-unit>
        <trans-unit id="3348bba79393338a33249573a6e3c773462946f1" translate="yes" xml:space="preserve">
          <source>Include a custom JDK from the specified location into the classpath instead of the default JAVA_HOME</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2699078d9287cbd90f76ee50448a4fec028de87" translate="yes" xml:space="preserve">
          <source>Including static library in your klib</source>
          <target state="translated">在你的klib中加入静态库</target>
        </trans-unit>
        <trans-unit id="84996d5891b1f1a645c33eb5c3b22433a18e3eec" translate="yes" xml:space="preserve">
          <source>Incompatible Changes</source>
          <target state="translated">不兼容的变化</target>
        </trans-unit>
        <trans-unit id="8d41722fdaa1b8acfa42d80a00302ec1d80e560e" translate="yes" xml:space="preserve">
          <source>IncorrectDereferenceException</source>
          <target state="translated">IncorrectDereferenceException</target>
        </trans-unit>
        <trans-unit id="7c15aa041f9a78e640a95e3034dce236ee5d488b" translate="yes" xml:space="preserve">
          <source>Incremental Compilation</source>
          <target state="translated">递增式编译</target>
        </trans-unit>
        <trans-unit id="1d25e364e8dc05079a68a8ada56d8fbeda70bc16" translate="yes" xml:space="preserve">
          <source>Incremental annotation processing (since 1.3.30)</source>
          <target state="translated">增量注解处理(自1.3.30起)。</target>
        </trans-unit>
        <trans-unit id="29106d30f82b4fbf8a046db084591a963e0208cc" translate="yes" xml:space="preserve">
          <source>Incremental annotation processing is enabled by default starting from version 1.3.50. To disable incremental annotation processing, add this line to your &lt;code&gt;gradle.properties&lt;/code&gt; file:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1262b9eb921db266028505964086f28ad7e7f94" translate="yes" xml:space="preserve">
          <source>Incremental compilation</source>
          <target state="translated">递增式汇编</target>
        </trans-unit>
        <trans-unit id="3bb3cfba326a2bdc90f381639a6d53003c8fb9e7" translate="yes" xml:space="preserve">
          <source>Incremental compilation is supported for Kotlin/JVM and Kotlin/JS projects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33b5061796594b36b41f624484bcfb3853bb6d0c" translate="yes" xml:space="preserve">
          <source>Incremental compilation is supported for Kotlin/JVM and Kotlin/JS projects. It's enabled by default since Kotlin 1.1.1 for Kotlin/JVM and 1.3.20 for Kotlin/JS.</source>
          <target state="translated">Kotlin/JVM和Kotlin/JS项目支持增量编译。自Kotlin 1.1.1(Kotlin/JVM)和1.3.20(Kotlin/JS)以来,它是默认启用的。</target>
        </trans-unit>
        <trans-unit id="d6dbea2b53708e66e73d3f1a6a99defec97fa2a9" translate="yes" xml:space="preserve">
          <source>Incremental releases bring updates in the tooling (often including features), performance improvements and bug fixes. We try to keep such versions compatible with each other, so changes to the compiler are mostly optimizations and warning additions/removals. Experimental features may, of course, be added, removed or changed at any time.</source>
          <target state="translated">递增版本带来了工具的更新(通常包括功能)、性能的改进和错误的修复。我们尽量保持这些版本之间的兼容性,所以对编译器的修改主要是优化和警告的添加/删除。当然,实验性功能可能会在任何时候被添加、删除或更改。</target>
        </trans-unit>
        <trans-unit id="36431db4a12e3c14e9de849f36b5befe35ed62b5" translate="yes" xml:space="preserve">
          <source>Incremental releases bring updates in the tooling (often including features), performance improvements and bug fixes. We try to keep such versions compatible with each other, so changes to the compiler are mostly optimizations and warning additions/removals. Pre-stable features may, of course, be added, removed or changed at any time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c0b336ea67b1169e696bcad497094e1948f51aa" translate="yes" xml:space="preserve">
          <source>Increments and decrements</source>
          <target state="translated">递增和递减</target>
        </trans-unit>
        <trans-unit id="51065cc396f6ec67a2538e872f538ab2d9ab75c9" translate="yes" xml:space="preserve">
          <source>Increments the value by &lt;a href=&quot;add-and-get#kotlin.native.concurrent.AtomicInt%24addAndGet%28kotlin.Int%29%2Fdelta&quot;&gt;delta&lt;/a&gt; and returns the new value.</source>
          <target state="translated">将值增加&lt;a href=&quot;add-and-get#kotlin.native.concurrent.AtomicInt%24addAndGet%28kotlin.Int%29%2Fdelta&quot;&gt;delta&lt;/a&gt;并返回新值。</target>
        </trans-unit>
        <trans-unit id="b0f32b37b99e84f7a892589880d018ef9b908ef9" translate="yes" xml:space="preserve">
          <source>Increments the value by &lt;a href=&quot;add-and-get#kotlin.native.concurrent.AtomicInt%24addAndGet(kotlin.Int)/delta&quot;&gt;delta&lt;/a&gt; and returns the new value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44233843d94836d1fccccf70b3b2b867d9acc067" translate="yes" xml:space="preserve">
          <source>Increments the value by &lt;a href=&quot;add-and-get#kotlin.native.concurrent.AtomicLong%24addAndGet%28kotlin.Long%29%2Fdelta&quot;&gt;delta&lt;/a&gt; and returns the new value.</source>
          <target state="translated">将值增加&lt;a href=&quot;add-and-get#kotlin.native.concurrent.AtomicLong%24addAndGet%28kotlin.Long%29%2Fdelta&quot;&gt;delta&lt;/a&gt;并返回新值。</target>
        </trans-unit>
        <trans-unit id="166f962aa69e44913e0b39e6fa68583a02fd3a79" translate="yes" xml:space="preserve">
          <source>Increments the value by &lt;a href=&quot;add-and-get#kotlin.native.concurrent.AtomicLong%24addAndGet(kotlin.Long)/delta&quot;&gt;delta&lt;/a&gt; and returns the new value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28411949be3415589036a91826011ccfec40fbd4" translate="yes" xml:space="preserve">
          <source>Increments this value.</source>
          <target state="translated">增加该值。</target>
        </trans-unit>
        <trans-unit id="b8fcfd847cda35bcb6945261dd3c4eb8f88f412a" translate="yes" xml:space="preserve">
          <source>Increments value by one.</source>
          <target state="translated">将数值增加1。</target>
        </trans-unit>
        <trans-unit id="c2df9b932637fe9d32a0f16da1c11873398f873d" translate="yes" xml:space="preserve">
          <source>Index</source>
          <target state="translated">Index</target>
        </trans-unit>
        <trans-unit id="83f705f84f3e506a637956b9907406ba6fe9f41e" translate="yes" xml:space="preserve">
          <source>IndexOutOfBoundsException</source>
          <target state="translated">IndexOutOfBoundsException</target>
        </trans-unit>
        <trans-unit id="4a12f879063aea0813ebab8015ddf21b727cd7af" translate="yes" xml:space="preserve">
          <source>Indexed access operator</source>
          <target state="translated">索引访问操作者</target>
        </trans-unit>
        <trans-unit id="d4e1cf8d774b0c0bb9b5921ec7fa833544082d60" translate="yes" xml:space="preserve">
          <source>IndexedValue</source>
          <target state="translated">IndexedValue</target>
        </trans-unit>
        <trans-unit id="2606e49e237c315e21ba9ad3205e46744904acbb" translate="yes" xml:space="preserve">
          <source>Indexing suffix</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ad24986a96806bcf716cdb15281ed398b1a31f5" translate="yes" xml:space="preserve">
          <source>Indicates whether some other object is &quot;equal to&quot; this one. Implementations must fulfil the following requirements:</source>
          <target state="translated">表示是否有其他对象 &quot;等于 &quot;这个对象。执行时必须满足以下要求:</target>
        </trans-unit>
        <trans-unit id="53f09d01b93a3110068a373094e1fb376a10c3c8" translate="yes" xml:space="preserve">
          <source>Indicates whether the regular expression can find at least one match in the specified &lt;a href=&quot;contains-match-in#kotlin.text.Regex%24containsMatchIn%28kotlin.CharSequence%29%2Finput&quot;&gt;input&lt;/a&gt;.</source>
          <target state="translated">指示正则表达式是否可以在指定的&lt;a href=&quot;contains-match-in#kotlin.text.Regex%24containsMatchIn%28kotlin.CharSequence%29%2Finput&quot;&gt;输入中&lt;/a&gt;找到至少一个匹配项。</target>
        </trans-unit>
        <trans-unit id="51429e87bd819bb2f3942329861eee4721f512b8" translate="yes" xml:space="preserve">
          <source>Indicates whether the regular expression can find at least one match in the specified &lt;a href=&quot;contains-match-in#kotlin.text.Regex%24containsMatchIn(kotlin.CharSequence)/input&quot;&gt;input&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc670204f79af50c97c85084d6a41b77270ab6a4" translate="yes" xml:space="preserve">
          <source>Indicates whether the regular expression matches the entire &lt;a href=&quot;matches#kotlin.text.Regex%24matches%28kotlin.CharSequence%29%2Finput&quot;&gt;input&lt;/a&gt;.</source>
          <target state="translated">指示正则表达式是否与整个&lt;a href=&quot;matches#kotlin.text.Regex%24matches%28kotlin.CharSequence%29%2Finput&quot;&gt;输入&lt;/a&gt;匹配。</target>
        </trans-unit>
        <trans-unit id="b98c0b71834f5e2d5a0d8cf79e50cdeebb2945aa" translate="yes" xml:space="preserve">
          <source>Indicates whether the regular expression matches the entire &lt;a href=&quot;matches#kotlin.text.Regex%24matches(kotlin.CharSequence)/input&quot;&gt;input&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="767a32bb6d83112e90455e54a6dd8a16300ca86c" translate="yes" xml:space="preserve">
          <source>Infix calls for named functions</source>
          <target state="translated">命名函数的Infix调用</target>
        </trans-unit>
        <trans-unit id="1cea4b28540c3fbdd2e2436ba68910be38a3f387" translate="yes" xml:space="preserve">
          <source>Infix function calls have lower precedence than the arithmetic operators, type casts, and the &lt;code&gt;rangeTo&lt;/code&gt; operator. The following expressions are equivalent:</source>
          <target state="translated">Infix函数调用的优先级低于算术运算符，类型强制转换和 &lt;code&gt;rangeTo&lt;/code&gt; 运算符。以下表达式是等效的：</target>
        </trans-unit>
        <trans-unit id="c345bbff4a1e1fc76b2e4ede7fbe52f5de947e6b" translate="yes" xml:space="preserve">
          <source>Infix functions</source>
          <target state="translated">填充功能</target>
        </trans-unit>
        <trans-unit id="19c6abcd2f2f19793afb1f4565bae99cd5d50667" translate="yes" xml:space="preserve">
          <source>Infix notation</source>
          <target state="translated">下位法</target>
        </trans-unit>
        <trans-unit id="c5a135f955f6a2349a2d4263f326ff3a2a3304ed" translate="yes" xml:space="preserve">
          <source>Information from explicit casts is used for type inference</source>
          <target state="translated">来自显式浇铸的信息被用于类型推理。</target>
        </trans-unit>
        <trans-unit id="fdaddb9ce367c2ca746a97cc24d2e8817a51f27d" translate="yes" xml:space="preserve">
          <source>Inheritance</source>
          <target state="translated">Inheritance</target>
        </trans-unit>
        <trans-unit id="fc3ff49d31fe091e3831cd8bc1f2e6d38992276d" translate="yes" xml:space="preserve">
          <source>Inheritance from Java classes</source>
          <target state="translated">从Java类继承</target>
        </trans-unit>
        <trans-unit id="060c830dba717926ce4d26ef9693decc297e0680" translate="yes" xml:space="preserve">
          <source>Inheritance that leads to a &lt;code&gt;copy&lt;/code&gt; conflict has become deprecated with a warning in Kotlin 1.2 and will be an error in Kotlin 1.3.</source>
          <target state="translated">导致 &lt;code&gt;copy&lt;/code&gt; 冲突的继承已在Kotlin 1.2中被警告弃用，在Kotlin 1.3中将是错误。</target>
        </trans-unit>
        <trans-unit id="fe8f308745a21bdbf9c67ae8f86198813253366c" translate="yes" xml:space="preserve">
          <source>Inherited Functions</source>
          <target state="translated">继承的功能</target>
        </trans-unit>
        <trans-unit id="a97b2d009dc11ee2399b0468fc72e941eebbf165" translate="yes" xml:space="preserve">
          <source>Inherited Properties</source>
          <target state="translated">继承属性</target>
        </trans-unit>
        <trans-unit id="f54b5bc69098e64d7fae998cd4e9df2d4fa8e7af" translate="yes" xml:space="preserve">
          <source>Inherited built-in functions</source>
          <target state="translated">继承的内置功能</target>
        </trans-unit>
        <trans-unit id="af6ed82fe139bda1a895add0ffee5c78ca3dcf12" translate="yes" xml:space="preserve">
          <source>Inheritors</source>
          <target state="translated">Inheritors</target>
        </trans-unit>
        <trans-unit id="68fa16ffd48f366e4fa8d57fea78ff03fcab0191" translate="yes" xml:space="preserve">
          <source>Initialization</source>
          <target state="translated">Initialization</target>
        </trans-unit>
        <trans-unit id="100b184b34b9bc80bfe5761ad8aa4a5db3c27036" translate="yes" xml:space="preserve">
          <source>Initialized with a value of type &lt;code&gt;String&lt;/code&gt; or a primitive type</source>
          <target state="translated">用 &lt;code&gt;String&lt;/code&gt; 类型或原始类型的值初始化</target>
        </trans-unit>
        <trans-unit id="0c55ba13e2bd9dbfd35641ebe93792c6061e39cd" translate="yes" xml:space="preserve">
          <source>Initializer</source>
          <target state="translated">Initializer</target>
        </trans-unit>
        <trans-unit id="cddbd43ce85bc15d27c1f2848a884d7030458b88" translate="yes" xml:space="preserve">
          <source>Initializer function can be called several times on concurrent access to uninitialized &lt;a href=&quot;../-lazy/index&quot;&gt;Lazy&lt;/a&gt; instance value, but only the first returned value will be used as the value of &lt;a href=&quot;../-lazy/index&quot;&gt;Lazy&lt;/a&gt; instance.</source>
          <target state="translated">在并发访问未初始化的&lt;a href=&quot;../-lazy/index&quot;&gt;Lazy&lt;/a&gt;实例值时，可以多次调用Initializer函数，但是只有第一个返回的值将用作&lt;a href=&quot;../-lazy/index&quot;&gt;Lazy&lt;/a&gt;实例的值。</target>
        </trans-unit>
        <trans-unit id="8de9a4ea59b21de32db609afcfc607895faed0de" translate="yes" xml:space="preserve">
          <source>Initializer functions for lists</source>
          <target state="translated">列表的初始化函数</target>
        </trans-unit>
        <trans-unit id="db5e65d8fc7dddd98f6860c2416bcbcc90ec0fba" translate="yes" xml:space="preserve">
          <source>Initializers</source>
          <target state="translated">Initializers</target>
        </trans-unit>
        <trans-unit id="96e412fcc42808e35495dbc64ebcde5c69c261de" translate="yes" xml:space="preserve">
          <source>Initializes Kotlin runtime for the current thread, if not inited already.</source>
          <target state="translated">如果尚未初始化,则初始化当前线程的Kotlin运行时。</target>
        </trans-unit>
        <trans-unit id="4bf76bf156ef56b953245fb5da4ea73be4ae4d91" translate="yes" xml:space="preserve">
          <source>Initiates a call to this deep recursive function, forming a root of the call tree.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be787dbbf62b5076f4a13439769f15509c2967ea" translate="yes" xml:space="preserve">
          <source>Inlinable lambdas can only be called inside the inline functions or passed as inlinable arguments, but &lt;code&gt;noinline&lt;/code&gt; ones can be manipulated in any way we like: stored in fields, passed around etc.</source>
          <target state="translated">可以内联Lambda表达式只能被称为内联函数中或可以内联参数传递，但 &lt;code&gt;noinline&lt;/code&gt; 始终们可以在任何我们喜欢的方式来处理：在存储领域，围绕等通过</target>
        </trans-unit>
        <trans-unit id="b60019f47df04ae92897fa912c6748a6013313fa" translate="yes" xml:space="preserve">
          <source>Inline Functions</source>
          <target state="translated">内联功能</target>
        </trans-unit>
        <trans-unit id="77dc1cce985d17f15f3bb54896d9ab82a2428c34" translate="yes" xml:space="preserve">
          <source>Inline JavaScript</source>
          <target state="translated">内联JavaScript</target>
        </trans-unit>
        <trans-unit id="62d048ab15fe71589a192aa32dfde8cfed8f778a" translate="yes" xml:space="preserve">
          <source>Inline Markup</source>
          <target state="translated">内联标记</target>
        </trans-unit>
        <trans-unit id="5d360c4149ca0224f961067c92c26613a7104175" translate="yes" xml:space="preserve">
          <source>Inline classes</source>
          <target state="translated">内联类</target>
        </trans-unit>
        <trans-unit id="9286e6770b0362425ca42b0e3ebc568ac630fc5b" translate="yes" xml:space="preserve">
          <source>Inline classes are allowed to inherit from interfaces:</source>
          <target state="translated">内联类允许从接口继承。</target>
        </trans-unit>
        <trans-unit id="4c5881ab063c0ce817cf6f52ab599309c2d3110f" translate="yes" xml:space="preserve">
          <source>Inline classes are available only since Kotlin 1.3 and currently are &lt;em&gt;experimental&lt;/em&gt;. See details &lt;a href=&quot;#experimental-status-of-inline-classes&quot;&gt;below&lt;/a&gt;</source>
          <target state="translated">内联类仅自Kotlin 1.3起可用，目前仍处于&lt;em&gt;实验阶段&lt;/em&gt;。请参阅&lt;a href=&quot;#experimental-status-of-inline-classes&quot;&gt;下面的&lt;/a&gt;详细信息</target>
        </trans-unit>
        <trans-unit id="f253e2ca96472e7c3372c8639328c1d3867dc3b6" translate="yes" xml:space="preserve">
          <source>Inline classes are available only since Kotlin 1.3 and currently are &lt;em&gt;experimental&lt;/em&gt;. See details in the &lt;a href=&quot;inline-classes#experimental-status-of-inline-classes&quot;&gt;reference&lt;/a&gt;.</source>
          <target state="translated">内联类仅自Kotlin 1.3起可用，目前仍处于&lt;em&gt;实验阶段&lt;/em&gt;。看到细节&lt;a href=&quot;inline-classes#experimental-status-of-inline-classes&quot;&gt;的参考&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1fe109e560117398094720f2c3a634950943781d" translate="yes" xml:space="preserve">
          <source>Inline classes are available only since Kotlin 1.3 and currently are in &lt;a href=&quot;evolution/components-stability&quot;&gt;Alpha&lt;/a&gt;. See details in the &lt;a href=&quot;inline-classes#alpha-status-of-inline-classes&quot;&gt;reference&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ad02ddc63db8ea1a5da350db44423e72064462a" translate="yes" xml:space="preserve">
          <source>Inline classes are available only since Kotlin 1.3 and currently in &lt;a href=&quot;evolution/components-stability&quot;&gt;Alpha&lt;/a&gt;. See details &lt;a href=&quot;#alpha-status-of-inline-classes&quot;&gt;below&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7a2cb12c8331fe8180ea13004fae9e89ef3e1fd" translate="yes" xml:space="preserve">
          <source>Inline classes support some functionality of regular classes. In particular, they are allowed to declare properties and functions:</source>
          <target state="translated">内联类支持常规类的一些功能。特别是,它们被允许声明属性和函数。</target>
        </trans-unit>
        <trans-unit id="6c7769b31582b2d304756a0e1ee20904b47b72a0" translate="yes" xml:space="preserve">
          <source>Inline classes vs type aliases</source>
          <target state="translated">内联类与类型别名</target>
        </trans-unit>
        <trans-unit id="126b7ff7e58c488c8dbbe2c35dcf311f885d0926" translate="yes" xml:space="preserve">
          <source>Inline extension functions that were called on a null value of a platform type did not check the receiver for null and would thus allow null to escape into the other code. Kotlin 1.2 forces this check at the call sites, throwing an exception if the receiver is null.</source>
          <target state="translated">在平台类型的null值上调用的内联扩展函数没有检查接收器是否为null,因此会允许null逃逸到其他代码中。Kotlin 1.2在调用站点强制进行这种检查,如果接收器为空,则抛出异常。</target>
        </trans-unit>
        <trans-unit id="5c804513cadec43c33b180af13b2e9aec456a962" translate="yes" xml:space="preserve">
          <source>Inline functions</source>
          <target state="translated">内联功能</target>
        </trans-unit>
        <trans-unit id="9d0d1200e09d5fde96bd026c2e6ca0b2d04d5ad5" translate="yes" xml:space="preserve">
          <source>Inline functions are explained &lt;a href=&quot;inline-functions&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">内联函数在&lt;a href=&quot;inline-functions&quot;&gt;此处&lt;/a&gt;进行说明。</target>
        </trans-unit>
        <trans-unit id="aa8db13612a09f046bbacee8122bb577b38d70fa" translate="yes" xml:space="preserve">
          <source>Inline functions are now allowed to have default values for their inlined functional parameters:</source>
          <target state="translated">内联函数现在允许为其内联函数参数设置默认值。</target>
        </trans-unit>
        <trans-unit id="d6c978967701dd3225fcc54de37cf91805dd0b8d" translate="yes" xml:space="preserve">
          <source>Inline functions with &lt;a href=&quot;inline-functions#reified-type-parameters&quot;&gt;reified type parameters&lt;/a&gt; have their actual type arguments inlined at each call site, which enables &lt;code&gt;arg is T&lt;/code&gt; checks for the type parameters, but if &lt;code&gt;arg&lt;/code&gt; is an instance of a generic type itself, &lt;em&gt;its&lt;/em&gt; type arguments are still erased. Example:</source>
          <target state="translated">带有经过&lt;a href=&quot;inline-functions#reified-type-parameters&quot;&gt;修饰的类型参数的&lt;/a&gt;内联函数在每个调用站点上都会内联其实际的类型参数，这使 &lt;code&gt;arg is T&lt;/code&gt; 检查类型参数，但是如果 &lt;code&gt;arg&lt;/code&gt; 是泛型类型本身的实例，则&lt;em&gt;其&lt;/em&gt;类型参数仍会被擦除。例：</target>
        </trans-unit>
        <trans-unit id="dad40d691cb152e5ea04161c10815db00953ebbb" translate="yes" xml:space="preserve">
          <source>Inline functions with default functional parameters</source>
          <target state="translated">带有默认功能参数的内联函数</target>
        </trans-unit>
        <trans-unit id="e60dd1451a60d33b2eca72439470d0150cb5cb84" translate="yes" xml:space="preserve">
          <source>Inline properties (since 1.1)</source>
          <target state="translated">内联属性(从1.1开始</target>
        </trans-unit>
        <trans-unit id="6fec8c0d06ca4be7ff0c4bc9fa753ee420aa8bbc" translate="yes" xml:space="preserve">
          <source>Inline property accessors</source>
          <target state="translated">内联属性访问器</target>
        </trans-unit>
        <trans-unit id="01185d7fc605bc19fbe95771073571a841e3e817" translate="yes" xml:space="preserve">
          <source>Inlining may cause the generated code to grow; however, if we do it in a reasonable way (i.e. avoiding inlining large functions), it will pay off in performance, especially at &quot;megamorphic&quot; call-sites inside loops.</source>
          <target state="translated">内联可能会导致生成的代码增长;然而,如果我们以合理的方式进行内联(即避免内联大型函数),它将在性能上得到回报,特别是在循环内的 &quot;巨变形 &quot;调用点。</target>
        </trans-unit>
        <trans-unit id="aacf14c4398ec9fe537fae7e92753856f34743cb" translate="yes" xml:space="preserve">
          <source>Inner classes</source>
          <target state="translated">内部班级</target>
        </trans-unit>
        <trans-unit id="bc3fa717af37b9f1e13149ace0b8f86497367e3c" translate="yes" xml:space="preserve">
          <source>Inner classes inheriting &lt;code&gt;Throwable&lt;/code&gt; that capture generic parameters from the outer class</source>
          <target state="translated">继承 &lt;code&gt;Throwable&lt;/code&gt; 的内部类从外部类捕获通用参数</target>
        </trans-unit>
        <trans-unit id="258becf2f7c7396759bd76072890548fa224b9a4" translate="yes" xml:space="preserve">
          <source>Inner classes of generic types that inherit from &lt;code&gt;Throwable&lt;/code&gt; could violate type-safety in a throw-catch scenario and thus have been deprecated, with a warning in Kotlin 1.2 and an error in Kotlin 1.3.</source>
          <target state="translated">从 &lt;code&gt;Throwable&lt;/code&gt; 继承的泛型类型的内部类在抛出捕获场景中可能会违反类型安全性，因此已被弃用，在Kotlin 1.2中发出警告，在Kotlin 1.3中出现错误。</target>
        </trans-unit>
        <trans-unit id="b14a7c09e5913aa9efafcb8d3f6e59361da51506" translate="yes" xml:space="preserve">
          <source>InputEventInit</source>
          <target state="translated">InputEventInit</target>
        </trans-unit>
        <trans-unit id="081e0fb72f26260fc891fc2cb6cbf71cf9e0d97f" translate="yes" xml:space="preserve">
          <source>Inserts all of the elements of the specified collection &lt;a href=&quot;../-mutable-list/add-all#kotlin.collections.MutableList%24addAll%28kotlin.Int%2C+kotlin.collections.Collection%28%28kotlin.collections.MutableList.E%29%29%29%2Felements&quot;&gt;elements&lt;/a&gt; into this list at the specified &lt;a href=&quot;../-mutable-list/add-all#kotlin.collections.MutableList%24addAll%28kotlin.Int%2C+kotlin.collections.Collection%28%28kotlin.collections.MutableList.E%29%29%29%2Findex&quot;&gt;index&lt;/a&gt;.</source>
          <target state="translated">将指定集合&lt;a href=&quot;../-mutable-list/add-all#kotlin.collections.MutableList%24addAll%28kotlin.Int%2C+kotlin.collections.Collection%28%28kotlin.collections.MutableList.E%29%29%29%2Felements&quot;&gt;元素的&lt;/a&gt;所有元素插入此列表中的指定&lt;a href=&quot;../-mutable-list/add-all#kotlin.collections.MutableList%24addAll%28kotlin.Int%2C+kotlin.collections.Collection%28%28kotlin.collections.MutableList.E%29%29%29%2Findex&quot;&gt;索引处&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="005fc2603487998262e6a4431116600f620b75a0" translate="yes" xml:space="preserve">
          <source>Inserts all of the elements of the specified collection &lt;a href=&quot;../-mutable-list/add-all#kotlin.collections.MutableList%24addAll(kotlin.Int,%20kotlin.collections.Collection((kotlin.collections.MutableList.E)))/elements&quot;&gt;elements&lt;/a&gt; into this list at the specified &lt;a href=&quot;../-mutable-list/add-all#kotlin.collections.MutableList%24addAll(kotlin.Int,%20kotlin.collections.Collection((kotlin.collections.MutableList.E)))/index&quot;&gt;index&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="887d8e7112f2b5499df8e54becfa68d97d70bd00" translate="yes" xml:space="preserve">
          <source>Inserts all of the elements of the specified collection &lt;a href=&quot;add-all#kotlin.collections.MutableList%24addAll%28kotlin.Int%2C+kotlin.collections.Collection%28%28kotlin.collections.MutableList.E%29%29%29%2Felements&quot;&gt;elements&lt;/a&gt; into this list at the specified &lt;a href=&quot;add-all#kotlin.collections.MutableList%24addAll%28kotlin.Int%2C+kotlin.collections.Collection%28%28kotlin.collections.MutableList.E%29%29%29%2Findex&quot;&gt;index&lt;/a&gt;.</source>
          <target state="translated">将指定集合&lt;a href=&quot;add-all#kotlin.collections.MutableList%24addAll%28kotlin.Int%2C+kotlin.collections.Collection%28%28kotlin.collections.MutableList.E%29%29%29%2Felements&quot;&gt;元素的&lt;/a&gt;所有元素插入此列表中的指定&lt;a href=&quot;add-all#kotlin.collections.MutableList%24addAll%28kotlin.Int%2C+kotlin.collections.Collection%28%28kotlin.collections.MutableList.E%29%29%29%2Findex&quot;&gt;索引处&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="602fbcd913879c3c9b700203739e32c4a9b2050d" translate="yes" xml:space="preserve">
          <source>Inserts all of the elements of the specified collection &lt;a href=&quot;add-all#kotlin.collections.MutableList%24addAll(kotlin.Int,%20kotlin.collections.Collection((kotlin.collections.MutableList.E)))/elements&quot;&gt;elements&lt;/a&gt; into this list at the specified &lt;a href=&quot;add-all#kotlin.collections.MutableList%24addAll(kotlin.Int,%20kotlin.collections.Collection((kotlin.collections.MutableList.E)))/index&quot;&gt;index&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0c7a2de4f7654463ee73faa30f98d50a3b73e7e" translate="yes" xml:space="preserve">
          <source>Inserts an element into the list at the specified &lt;a href=&quot;../-mutable-list/add#kotlin.collections.MutableList%24add%28kotlin.Int%2C+kotlin.collections.MutableList.E%29%2Findex&quot;&gt;index&lt;/a&gt;.</source>
          <target state="translated">将元素插入列表中指定&lt;a href=&quot;../-mutable-list/add#kotlin.collections.MutableList%24add%28kotlin.Int%2C+kotlin.collections.MutableList.E%29%2Findex&quot;&gt;索引处&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="043751f897f4eb9dc49253608d3dad5a3c113e89" translate="yes" xml:space="preserve">
          <source>Inserts an element into the list at the specified &lt;a href=&quot;../-mutable-list/add#kotlin.collections.MutableList%24add(kotlin.Int,%20kotlin.collections.MutableList.E)/index&quot;&gt;index&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6b6ae35f6d9d56e894884fb222d27eda900dc09" translate="yes" xml:space="preserve">
          <source>Inserts an element into the list at the specified &lt;a href=&quot;add#kotlin.collections.AbstractMutableList%24add%28kotlin.Int%2C+kotlin.collections.AbstractMutableList.E%29%2Findex&quot;&gt;index&lt;/a&gt;.</source>
          <target state="translated">将元素插入列表中指定&lt;a href=&quot;add#kotlin.collections.AbstractMutableList%24add%28kotlin.Int%2C+kotlin.collections.AbstractMutableList.E%29%2Findex&quot;&gt;索引处&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="dc5d1b50a39baeed86e36617a548438e3f127155" translate="yes" xml:space="preserve">
          <source>Inserts an element into the list at the specified &lt;a href=&quot;add#kotlin.collections.AbstractMutableList%24add(kotlin.Int,%20kotlin.collections.AbstractMutableList.E)/index&quot;&gt;index&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c1226de8bd8dc851fb3874b9c31e306f3fa56c5" translate="yes" xml:space="preserve">
          <source>Inserts an element into the list at the specified &lt;a href=&quot;add#kotlin.collections.MutableList%24add%28kotlin.Int%2C+kotlin.collections.MutableList.E%29%2Findex&quot;&gt;index&lt;/a&gt;.</source>
          <target state="translated">将元素插入列表中指定&lt;a href=&quot;add#kotlin.collections.MutableList%24add%28kotlin.Int%2C+kotlin.collections.MutableList.E%29%2Findex&quot;&gt;索引处&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8e37de1820797a87c23300e79e4b0ed919d09e2a" translate="yes" xml:space="preserve">
          <source>Inserts an element into the list at the specified &lt;a href=&quot;add#kotlin.collections.MutableList%24add(kotlin.Int,%20kotlin.collections.MutableList.E)/index&quot;&gt;index&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27480ec1869e9733f33a48ab29f659fcb2a460a3" translate="yes" xml:space="preserve">
          <source>Inserts characters in a subarray of the specified character array &lt;a href=&quot;insert-range#kotlin.text%24insertRange(java.lang.StringBuilder,%20kotlin.Int,%20kotlin.CharArray,%20kotlin.Int,%20kotlin.Int)/value&quot;&gt;value&lt;/a&gt; into this string builder at the specified &lt;a href=&quot;insert-range#kotlin.text%24insertRange(java.lang.StringBuilder,%20kotlin.Int,%20kotlin.CharArray,%20kotlin.Int,%20kotlin.Int)/index&quot;&gt;index&lt;/a&gt; and returns this instance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0751e96b7b08da95e20ff3bc7df0567c20077897" translate="yes" xml:space="preserve">
          <source>Inserts characters in a subarray of the specified character array &lt;a href=&quot;insert-range#kotlin.text%24insertRange(kotlin.text.StringBuilder,%20kotlin.Int,%20kotlin.CharArray,%20kotlin.Int,%20kotlin.Int)/value&quot;&gt;value&lt;/a&gt; into this string builder at the specified &lt;a href=&quot;insert-range#kotlin.text%24insertRange(kotlin.text.StringBuilder,%20kotlin.Int,%20kotlin.CharArray,%20kotlin.Int,%20kotlin.Int)/index&quot;&gt;index&lt;/a&gt; and returns this instance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e04a0c39fa9e9ba6f8f7b53f66419ea35f91587" translate="yes" xml:space="preserve">
          <source>Inserts characters in a subarray of the specified character array &lt;a href=&quot;insert-range#kotlin.text.StringBuilder%24insertRange(kotlin.Int,%20kotlin.CharArray,%20kotlin.Int,%20kotlin.Int)/value&quot;&gt;value&lt;/a&gt; into this string builder at the specified &lt;a href=&quot;insert-range#kotlin.text.StringBuilder%24insertRange(kotlin.Int,%20kotlin.CharArray,%20kotlin.Int,%20kotlin.Int)/index&quot;&gt;index&lt;/a&gt; and returns this instance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="990caaef55fa9369abe10fe21e08b659ee5241e9" translate="yes" xml:space="preserve">
          <source>Inserts characters in a subsequence of the specified character sequence &lt;a href=&quot;../insert#kotlin.text%24insert(kotlin.text.StringBuilder,%20kotlin.Int,%20kotlin.CharSequence?,%20kotlin.Int,%20kotlin.Int)/csq&quot;&gt;csq&lt;/a&gt; into this string builder at the specified &lt;a href=&quot;../insert#kotlin.text%24insert(kotlin.text.StringBuilder,%20kotlin.Int,%20kotlin.CharSequence?,%20kotlin.Int,%20kotlin.Int)/index&quot;&gt;index&lt;/a&gt; and returns this instance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56381b6576df78ab7498f4c21ed74ffb38fce356" translate="yes" xml:space="preserve">
          <source>Inserts characters in a subsequence of the specified character sequence &lt;a href=&quot;insert#kotlin.text%24insert(kotlin.text.StringBuilder,%20kotlin.Int,%20kotlin.CharSequence?,%20kotlin.Int,%20kotlin.Int)/csq&quot;&gt;csq&lt;/a&gt; into this string builder at the specified &lt;a href=&quot;insert#kotlin.text%24insert(kotlin.text.StringBuilder,%20kotlin.Int,%20kotlin.CharSequence?,%20kotlin.Int,%20kotlin.Int)/index&quot;&gt;index&lt;/a&gt; and returns this instance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13ca00255e68344adaf9baf7d5fd54a64418b339" translate="yes" xml:space="preserve">
          <source>Inserts characters in a subsequence of the specified character sequence &lt;a href=&quot;insert-range#kotlin.text%24insertRange(java.lang.StringBuilder,%20kotlin.Int,%20kotlin.CharSequence,%20kotlin.Int,%20kotlin.Int)/value&quot;&gt;value&lt;/a&gt; into this string builder at the specified &lt;a href=&quot;insert-range#kotlin.text%24insertRange(java.lang.StringBuilder,%20kotlin.Int,%20kotlin.CharSequence,%20kotlin.Int,%20kotlin.Int)/index&quot;&gt;index&lt;/a&gt; and returns this instance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f16ec6bfc81f5c607f3cb9b48f5e7a410c32c025" translate="yes" xml:space="preserve">
          <source>Inserts characters in a subsequence of the specified character sequence &lt;a href=&quot;insert-range#kotlin.text%24insertRange(kotlin.text.StringBuilder,%20kotlin.Int,%20kotlin.CharSequence,%20kotlin.Int,%20kotlin.Int)/value&quot;&gt;value&lt;/a&gt; into this string builder at the specified &lt;a href=&quot;insert-range#kotlin.text%24insertRange(kotlin.text.StringBuilder,%20kotlin.Int,%20kotlin.CharSequence,%20kotlin.Int,%20kotlin.Int)/index&quot;&gt;index&lt;/a&gt; and returns this instance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b15a142e3f1c0e94cad906174d3311d39fef798f" translate="yes" xml:space="preserve">
          <source>Inserts characters in a subsequence of the specified character sequence &lt;a href=&quot;insert-range#kotlin.text.StringBuilder%24insertRange(kotlin.Int,%20kotlin.CharSequence,%20kotlin.Int,%20kotlin.Int)/value&quot;&gt;value&lt;/a&gt; into this string builder at the specified &lt;a href=&quot;insert-range#kotlin.text.StringBuilder%24insertRange(kotlin.Int,%20kotlin.CharSequence,%20kotlin.Int,%20kotlin.Int)/index&quot;&gt;index&lt;/a&gt; and returns this instance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98e8ddbbdefb8f6d9c8e1f1a1ec159981fb75050" translate="yes" xml:space="preserve">
          <source>Inserts characters in the specified character array &lt;a href=&quot;insert#kotlin.text.StringBuilder%24insert(kotlin.Int,%20kotlin.CharArray)/value&quot;&gt;value&lt;/a&gt; into this string builder at the specified &lt;a href=&quot;insert#kotlin.text.StringBuilder%24insert(kotlin.Int,%20kotlin.CharArray)/index&quot;&gt;index&lt;/a&gt; and returns this instance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8bd299382c17ed7be741a94000ce27e3cb569545" translate="yes" xml:space="preserve">
          <source>Inserts characters in the specified character sequence &lt;a href=&quot;insert#kotlin.text.StringBuilder%24insert(kotlin.Int,%20kotlin.CharSequence?)/value&quot;&gt;value&lt;/a&gt; into this string builder at the specified &lt;a href=&quot;insert#kotlin.text.StringBuilder%24insert(kotlin.Int,%20kotlin.CharSequence?)/index&quot;&gt;index&lt;/a&gt; and returns this instance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c10488d941ff5f739e50f3ed8d100fc28145f09c" translate="yes" xml:space="preserve">
          <source>Inserts the specified character &lt;a href=&quot;insert#kotlin.text.StringBuilder%24insert(kotlin.Int,%20kotlin.Char)/value&quot;&gt;value&lt;/a&gt; into this string builder at the specified &lt;a href=&quot;insert#kotlin.text.StringBuilder%24insert(kotlin.Int,%20kotlin.Char)/index&quot;&gt;index&lt;/a&gt; and returns this instance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad678e17f874b23d4231a5cb1e5b3edfa0684922" translate="yes" xml:space="preserve">
          <source>Inserts the string &lt;a href=&quot;insert#kotlin.text.StringBuilder%24insert(kotlin.Int,%20kotlin.String?)/value&quot;&gt;value&lt;/a&gt; into this string builder at the specified &lt;a href=&quot;insert#kotlin.text.StringBuilder%24insert(kotlin.Int,%20kotlin.String?)/index&quot;&gt;index&lt;/a&gt; and returns this instance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb5279ca89113fa744f9ed912c21f45c93146fab" translate="yes" xml:space="preserve">
          <source>Inserts the string representation of the specified boolean &lt;a href=&quot;insert#kotlin.text.StringBuilder%24insert(kotlin.Int,%20kotlin.Boolean)/value&quot;&gt;value&lt;/a&gt; into this string builder at the specified &lt;a href=&quot;insert#kotlin.text.StringBuilder%24insert(kotlin.Int,%20kotlin.Boolean)/index&quot;&gt;index&lt;/a&gt; and returns this instance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8ce5257d0d44bc8ee828b4f0aa168d27143f4fc" translate="yes" xml:space="preserve">
          <source>Inserts the string representation of the specified object &lt;a href=&quot;insert#kotlin.text.StringBuilder%24insert(kotlin.Int,%20kotlin.Any?)/value&quot;&gt;value&lt;/a&gt; into this string builder at the specified &lt;a href=&quot;insert#kotlin.text.StringBuilder%24insert(kotlin.Int,%20kotlin.Any?)/index&quot;&gt;index&lt;/a&gt; and returns this instance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40e63a4d54fc0992dbc62da98003576fd7d50dbb" translate="yes" xml:space="preserve">
          <source>Inside a class, you can declare extensions for another class. Inside such an extension, there are multiple &lt;em&gt;implicit receivers&lt;/em&gt; - objects members of which can be accessed without a qualifier. The instance of the class in which the extension is declared is called &lt;em&gt;dispatch receiver&lt;/em&gt;, and the instance of the receiver type of the extension method is called &lt;em&gt;extension receiver&lt;/em&gt;.</source>
          <target state="translated">在一个类中，您可以声明另一个类的扩展。在这种扩展内部，有多个&lt;em&gt;隐式接收器&lt;/em&gt; -无需限定符即可访问其对象的成员。声明扩展的类的实例称为&lt;em&gt;调度接收器&lt;/em&gt;，扩展方法的接收器类型的实例称为&lt;em&gt;扩展接收器&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="97c34b033d93e70cd2130ab46bfa71cd52ac56f6" translate="yes" xml:space="preserve">
          <source>Inside a function a &lt;code&gt;vararg&lt;/code&gt;-parameter of type &lt;code&gt;T&lt;/code&gt; is visible as an array of &lt;code&gt;T&lt;/code&gt;, i.e. the &lt;code&gt;ts&lt;/code&gt; variable in the example above has type &lt;code&gt;Array&amp;lt;out T&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">内的功能的 &lt;code&gt;vararg&lt;/code&gt; 类型的-parameter &lt;code&gt;T&lt;/code&gt; 是可见的阵列 &lt;code&gt;T&lt;/code&gt; ，即， &lt;code&gt;ts&lt;/code&gt; 在例如上述可变型具有 &lt;code&gt;Array&amp;lt;out T&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="826cc6f6147dd291bf22ea4078acd71a79ba87cf" translate="yes" xml:space="preserve">
          <source>Inside a lambda expression with receiver, you can use &lt;code&gt;this&lt;/code&gt; to refer to the receiver object (in this case, &lt;code&gt;car&lt;/code&gt;). As usual, you can omit &lt;code&gt;this&lt;/code&gt; if there are no naming conflicts, which is why we can simply say &lt;code&gt;$horsepowers&lt;/code&gt; instead of &lt;code&gt;${this.horsepowers}&lt;/code&gt;. So beware that in Kotlin, &lt;code&gt;this&lt;/code&gt; can have different meanings depending on the context: if used inside (possibly nested) lambda expressions with receivers, it refers to the receiver object of the innermost enclosing lambda expression with receiver. If you need to &quot;break out&quot; of the function literal and get the &quot;original&quot; &lt;code&gt;this&lt;/code&gt; (the instance the member function you're inside is executing on), mention the containing class name after &lt;code&gt;this@&lt;/code&gt; - so if you're inside a function literal with receiver inside a member function of Car, use &lt;code&gt;this@Car&lt;/code&gt;.</source>
          <target state="translated">在带有接收器的lambda表达式中，您可以使用 &lt;code&gt;this&lt;/code&gt; 来引用接收器对象（在本例中为 &lt;code&gt;car&lt;/code&gt; ）。像往常一样，如果没有命名冲突，则可以忽略 &lt;code&gt;this&lt;/code&gt; ，这就是为什么我们可以简单地说 &lt;code&gt;$horsepowers&lt;/code&gt; &lt;code&gt;${this.horsepowers}&lt;/code&gt; 而不是$ {this.horsepowers}的原因。请注意，在Kotlin中， &lt;code&gt;this&lt;/code&gt; 取决于上下文可能具有不同的含义：如果在带有接收器的lambda表达式内部（可能是嵌套的）中使用，它指的是带有接收器的最内层lambda表达式的接收器对象。如果您需要&amp;ldquo;突破&amp;rdquo;函数文字并获得&amp;ldquo;原始&amp;rdquo;字样， &lt;code&gt;this&lt;/code&gt; （您正在执行的内部成员函数的实例），请在 &lt;code&gt;this@&lt;/code&gt; 之后提及包含的类名-因此，如果您位于Car的成员函数内部的带有接收者的函数文字中，请使用 &lt;code&gt;this@Car&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d76861f103960eff4ae0c7430fef1ebd5d3e542c" translate="yes" xml:space="preserve">
          <source>Inside an inner class, accessing the superclass of the outer class is done with the &lt;em&gt;super&lt;/em&gt; keyword qualified with the outer class name: &lt;code&gt;super@Outer&lt;/code&gt;:</source>
          <target state="translated">在内部类内部，访问外部类的超类是通过使用外部类名称为 &lt;code&gt;super@Outer&lt;/code&gt; 限定的&lt;em&gt;super&lt;/em&gt;关键字完成的：</target>
        </trans-unit>
        <trans-unit id="8ccb5c0d6d5858f7a6cc2ca5c66201a3c3cecf82" translate="yes" xml:space="preserve">
          <source>Inside enum entries, defining a nested type that is not an &lt;code&gt;inner class&lt;/code&gt; has been deprecated due to issues in the initialization logic. This causes a warning in Kotlin 1.2 and will become an error in Kotlin 1.3.</source>
          <target state="translated">由于初始化逻辑中的问题，在枚举条目内部定义了不是 &lt;code&gt;inner class&lt;/code&gt; 的嵌套类型已被弃用。这会在Kotlin 1.2中引起警告，并在Kotlin 1.3中成为错误。</target>
        </trans-unit>
        <trans-unit id="d5019da5c150ca59c7fa4dd453ea0a06cf96e080" translate="yes" xml:space="preserve">
          <source>Inside the &lt;code&gt;apply&lt;/code&gt; block, &lt;code&gt;this&lt;/code&gt; refers to &lt;code&gt;maybeNull&lt;/code&gt;. There's an implicit &lt;code&gt;this&lt;/code&gt; in front of &lt;code&gt;memberPropertyA&lt;/code&gt;, &lt;code&gt;memberPropertyB&lt;/code&gt;, and &lt;code&gt;memberFunctionA&lt;/code&gt; (unless these don't exist on &lt;code&gt;maybeNull&lt;/code&gt;, in which case they'll be looked for in the containing scopes). Afterwards, &lt;code&gt;memberFunctionB()&lt;/code&gt; is also invoked on &lt;code&gt;maybeNull&lt;/code&gt;.</source>
          <target state="translated">里面的 &lt;code&gt;apply&lt;/code&gt; 模块， &lt;code&gt;this&lt;/code&gt; 是指 &lt;code&gt;maybeNull&lt;/code&gt; 。这里有一个隐含的 &lt;code&gt;this&lt;/code&gt; 前面 &lt;code&gt;memberPropertyA&lt;/code&gt; ， &lt;code&gt;memberPropertyB&lt;/code&gt; 和 &lt;code&gt;memberFunctionA&lt;/code&gt; （除非这些根本不存在的 &lt;code&gt;maybeNull&lt;/code&gt; ，在这种情况下，他们将会在包含范围来寻找）。之后，还会在 &lt;code&gt;maybeNull&lt;/code&gt; 上调用 &lt;code&gt;memberFunctionB()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f13d8be73f140532f836309395f0554a59c9c6f7" translate="yes" xml:space="preserve">
          <source>Inside the body of the function literal, the receiver object passed to a call becomes an &lt;em&gt;implicit&lt;/em&gt;&lt;em&gt;this&lt;/em&gt;, so that you can access the members of that receiver object without any additional qualifiers, or access the receiver object using a &lt;a href=&quot;this-expressions&quot;&gt;&lt;code&gt;this&lt;/code&gt; expression&lt;/a&gt;.</source>
          <target state="translated">在函数文字的主体内部，传递给调用的接收者对象将成为&lt;em&gt;隐式&lt;/em&gt;&lt;em&gt;this&lt;/em&gt;，因此您可以在没有任何其他限定符的情况下访问该接收者对象的成员，或者使用&lt;a href=&quot;this-expressions&quot;&gt; &lt;code&gt;this&lt;/code&gt; 表达式&lt;/a&gt;访问接收者对象。</target>
        </trans-unit>
        <trans-unit id="2558cc93d05f62b7942210cca1e0fecc8bdce932" translate="yes" xml:space="preserve">
          <source>Inside the class that declares a lateinit property, you can check if it has been initialized:</source>
          <target state="translated">在声明lateinit属性的类里面,你可以检查它是否已经被初始化。</target>
        </trans-unit>
        <trans-unit id="987506c0627eacba63113c8eade53536a31e1484" translate="yes" xml:space="preserve">
          <source>Inside the file, the documentation for the module as a whole and for individual packages is introduced by the corresponding first-level headings. The text of the heading must be &quot;Module &lt;code&gt;&amp;lt;module name&amp;gt;&lt;/code&gt;&quot; for the module, and &quot;Package &lt;code&gt;&amp;lt;package qualified name&amp;gt;&lt;/code&gt;&quot; for a package.</source>
          <target state="translated">在文件内部，相应的第一级标题介绍了整个模块和单个软件包的文档。标题文本对于模块必须是&amp;ldquo;模块 &lt;code&gt;&amp;lt;module name&amp;gt;&lt;/code&gt; &amp;rdquo;，对于包必须是&amp;ldquo; 包 &lt;code&gt;&amp;lt;package qualified name&amp;gt;&lt;/code&gt; &amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="493e88f297e12412d7ac95bb437b962fd0497829" translate="yes" xml:space="preserve">
          <source>Inside the lambda of a scope function, the context object is available by a short reference instead of its actual name. Each scope function uses one of two ways to access the context object: as a lambda &lt;a href=&quot;lambdas#function-literals-with-receiver&quot;&gt;receiver&lt;/a&gt; (&lt;code&gt;this&lt;/code&gt;) or as a lambda argument (&lt;code&gt;it&lt;/code&gt;). Both provide the same capabilities, so we'll describe the pros and cons of each for different cases and provide recommendations on their use.</source>
          <target state="translated">在作用域函数的lambda中，可以通过短引用而不是其实际名称来使用上下文对象。每个范围函数使用两种访问上下文对象的方式之一：作为lambda &lt;a href=&quot;lambdas#function-literals-with-receiver&quot;&gt;接收器&lt;/a&gt;（ &lt;code&gt;this&lt;/code&gt; ）或作为lambda参数（ &lt;code&gt;it&lt;/code&gt; ）。两者都提供相同的功能，因此我们将描述每种情况在每种情况下的利弊，并提供有关其用法的建议。</target>
        </trans-unit>
        <trans-unit id="5003ad2518c8a72a35acc2813b3f299786173c02" translate="yes" xml:space="preserve">
          <source>Inspect Generated Kotlin APIs from a C library</source>
          <target state="translated">检查从C库中生成的Kotlin API。</target>
        </trans-unit>
        <trans-unit id="40cd793a9f0552fd84c4436f73c844d1482e9756" translate="yes" xml:space="preserve">
          <source>Inspect the contents of &lt;code&gt;dist/klib/platform/$target&lt;/code&gt; of the distribution for the details.</source>
          <target state="translated">检查发行版的 &lt;code&gt;dist/klib/platform/$target&lt;/code&gt; 的详细信息。</target>
        </trans-unit>
        <trans-unit id="125c70324902d1ea37a08feb6e548d2fa859e9e8" translate="yes" xml:space="preserve">
          <source>Inspecting Generated Kotlin APIs for a C library</source>
          <target state="translated">为C库检查生成的Kotlin APIs</target>
        </trans-unit>
        <trans-unit id="bc318e2b8cd3f066b53b59698e603a8b1ca8d81c" translate="yes" xml:space="preserve">
          <source>Install custom unhandled exception hook. Returns old hook, or null if it was not specified. Hook is invoked whenever there's uncaught exception reaching boundaries of the Kotlin world, i.e. top level main(), or when Objective-C to Kotlin call not marked with @Throws throws an exception. Hook must be a frozen lambda, so that it could be called from any thread/worker. Hook is invoked once, and is cleared afterwards, so that memory leak detection works as expected even with custom exception hooks.</source>
          <target state="translated">安装自定义的未处理异常钩子。返回旧的钩子,如果没有指定钩子,则返回null。每当有未捕获的异常到达Kotlin世界的边界时,例如顶级的main(),或者当Objective-C对Kotlin的调用没有用@Throws标记时,就会调用Hook。钩子必须是一个冻结的lambda,这样它就可以从任何线程/工作站调用。钩子只被调用一次,之后会被清除,所以即使是自定义的异常钩子,内存泄漏检测也能如期进行。</target>
        </trans-unit>
        <trans-unit id="61dc4e9bf861172198001de007eee7dfc119f627" translate="yes" xml:space="preserve">
          <source>Install libgit2 and prepare stubs for the git library:</source>
          <target state="translated">安装 libgit2 并为 git 库准备存根。</target>
        </trans-unit>
        <trans-unit id="55178375f2d34a4d0b5f0a6c687d2b1b982ae90c" translate="yes" xml:space="preserve">
          <source>Install the &lt;a href=&quot;https://chrome.google.com/webstore/detail/jetbrains-ide-support/hmhgeddbohgjknpmjagkdomcpobmllji?hl=en&quot;&gt;JetBrains Chrome Extension&lt;/a&gt; which allows debugging inside IntelliJ IDEA via Chrome. This is useful for any type of web application developed with IntelliJ IDEA, not just Kotlin.</source>
          <target state="translated">安装&lt;a href=&quot;https://chrome.google.com/webstore/detail/jetbrains-ide-support/hmhgeddbohgjknpmjagkdomcpobmllji?hl=en&quot;&gt;JetBrains Chrome扩展程序&lt;/a&gt;，该扩展程序允许通过Chrome在IntelliJ IDEA内部进行调试。这对于使用IntelliJ IDEA开发的任何类型的Web应用程序都是有用的，而不仅仅是Kotlin。</target>
        </trans-unit>
        <trans-unit id="cba3ec3086c29abcbfa73fe1ec7eb10077b3664f" translate="yes" xml:space="preserve">
          <source>Install the &lt;a href=&quot;https://cocoapods.org/&quot;&gt;CocoaPods dependency manager&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7237a8f52f82477e8aca289f73e7feebfb253754" translate="yes" xml:space="preserve">
          <source>Install the &lt;a href=&quot;https://github.com/square/cocoapods-generate&quot;&gt;&lt;code&gt;cocoapods-generate&lt;/code&gt;&lt;/a&gt; plugin.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d91d23355e44b9f891a149ed27d5dd594ef16726" translate="yes" xml:space="preserve">
          <source>Install the &lt;a href=&quot;https://plugins.jetbrains.com/plugin/10081-edutools&quot;&gt;EduTools plugin&lt;/a&gt; for IDEA and complete exercises from the &lt;a href=&quot;https://www.jetbrains.com/help/education/learner-start-guide.html?section=Kotlin%20Koans&quot;&gt;Kotlin Koans course&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6c9c342f22b1bebf06cebee1a33f0bf01b82e59" translate="yes" xml:space="preserve">
          <source>Install the CocoaPods dependency manager and plugin</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fdaed5952d98f86231a297a2212142ac7c035122" translate="yes" xml:space="preserve">
          <source>Installing EduTools plugin</source>
          <target state="translated">安装EduTools插件</target>
        </trans-unit>
        <trans-unit id="2a79a656994e8f8c151cea0c7b39c2c9e4d16ed5" translate="yes" xml:space="preserve">
          <source>Instance Checks</source>
          <target state="translated">实例检查</target>
        </trans-unit>
        <trans-unit id="9e1218ddd72144e647203114e5a8e7ec310019cb" translate="yes" xml:space="preserve">
          <source>Instance fields</source>
          <target state="translated">实例领域</target>
        </trans-unit>
        <trans-unit id="808164c9992eeb307ee53ea9dae39f6fb259b6e5" translate="yes" xml:space="preserve">
          <source>Instance required to make a call to the member, or an outer class instance for an inner class constructor.</source>
          <target state="translated">对成员进行调用所需的实例,或对内类构造函数进行外类实例。</target>
        </trans-unit>
        <trans-unit id="a15783fb8d36e7147f368f4e99e9d406c5062f79" translate="yes" xml:space="preserve">
          <source>Instantiating a function type</source>
          <target state="translated">实例化一个函数类型</target>
        </trans-unit>
        <trans-unit id="323fad682a062c4a52dfeb27dd2280fe7981b362" translate="yes" xml:space="preserve">
          <source>Instead of &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/coroutine-scope.html&quot;&gt;coroutineScope&lt;/a&gt;, we can use &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/supervisor-scope.html&quot;&gt;supervisorScope&lt;/a&gt; for &lt;em&gt;scoped&lt;/em&gt; concurrency. It propagates the cancellation in one direction only and cancels all its children only if it failed itself. It also waits for all children before completion just like &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/coroutine-scope.html&quot;&gt;coroutineScope&lt;/a&gt; does.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d2cc7618aade0b4e22b2f6e46628e00aba0ed39" translate="yes" xml:space="preserve">
          <source>Instead of calling the method &lt;code&gt;matches&lt;/code&gt; directly we are storing a reference to it. Such reference is bound to its receiver. It can be called directly (like in the example above) or used whenever an expression of function type is expected:</source>
          <target state="translated">我们没有直接调用方法 &lt;code&gt;matches&lt;/code&gt; ，而是存储了对其的引用。这样的引用绑定到它的接收者。可以直接调用它（如上面的示例中一样），或者在需要函数类型的表达式时使用它：</target>
        </trans-unit>
        <trans-unit id="8213790556130c398f868064e28de372b2469df8" translate="yes" xml:space="preserve">
          <source>Instead of creating a function object for the parameter and generating a call, the compiler could emit the following code:</source>
          <target state="translated">编译器可以不为参数创建一个函数对象并生成一个调用,而是发出以下代码。</target>
        </trans-unit>
        <trans-unit id="f83cef13eec16cda3d2cf44a7d9356f601633a76" translate="yes" xml:space="preserve">
          <source>Instead of threads Kotlin/Native runtime offers the concept of workers: concurrently executed control flow streams with an associated request queue. Workers are very similar to the actors in the Actor Model. A worker can exchange Kotlin objects with another worker, so that at any moment each mutable object is owned by a single worker, but ownership can be transferred. See section &lt;a href=&quot;#transfer&quot;&gt;Object transfer and freezing&lt;/a&gt;.</source>
          <target state="translated">Kotlin / Native运行时代替线程来提供工作程序的概念：同时执行的控制流和关联的请求队列。工人与&amp;ldquo;演员模型&amp;rdquo;中的演员非常相似。一个工作人员可以与另一个工作人员交换Kotlin对象，以便任何时候每个可变对象都由一个工作人员拥有，但是所有权可以转移。请参阅&lt;a href=&quot;#transfer&quot;&gt;对象传输和冻结部分&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="72f70be3d9872cba860894ac5cf17293ed0d78f8" translate="yes" xml:space="preserve">
          <source>Instructs compiler to generate or omit wildcards for type arguments corresponding to parameters with declaration-site variance, for example such as &lt;code&gt;Collection&amp;lt;out T&amp;gt;&lt;/code&gt; has.</source>
          <target state="translated">指示编译器为带有声明位置差异的参数对应的类型实参生成或忽略通配符，例如 &lt;code&gt;Collection&amp;lt;out T&amp;gt;&lt;/code&gt; 具有。</target>
        </trans-unit>
        <trans-unit id="783a81e7c87c37045741ac6ac177384c0af024d5" translate="yes" xml:space="preserve">
          <source>Instructs compiler to generate wildcard for annotated type arguments corresponding to parameters with declaration-site variance.</source>
          <target state="translated">指示编译器为注释类型参数生成通配符,这些参数对应于具有声明点差异的参数。</target>
        </trans-unit>
        <trans-unit id="2008818ef3a5b5313d7106b4d54dde4c0275e9fe" translate="yes" xml:space="preserve">
          <source>Instructs the Kotlin compiler not to generate getters/setters for this property and expose it as a field.</source>
          <target state="translated">指示Kotlin编译器不要为这个属性生成getters/setters,而是将其作为一个字段公开。</target>
        </trans-unit>
        <trans-unit id="13386323cf0532c0c864d57e3f5e6f155f3a611f" translate="yes" xml:space="preserve">
          <source>Instructs the Kotlin compiler to generate a multifile class with top-level functions and properties declared in this file as one of its parts. Name of the corresponding multifile class is provided by the &lt;a href=&quot;-jvm-name/index#kotlin.jvm.JvmName&quot;&gt;JvmName&lt;/a&gt; annotation.</source>
          <target state="translated">指示Kotlin编译器生成一个多文件类，其中包含在此文件中声明的顶级功能和属性作为其一部分。相应的多文件类的名称由&lt;a href=&quot;-jvm-name/index#kotlin.jvm.JvmName&quot;&gt;JvmName&lt;/a&gt;批注提供。</target>
        </trans-unit>
        <trans-unit id="c90ad955a31d769d0ca4882df53d8563d188c893" translate="yes" xml:space="preserve">
          <source>Instructs the Kotlin compiler to generate a multifile class with top-level functions and properties declared in this file as one of its parts. Name of the corresponding multifile class is provided by the &lt;a href=&quot;../-jvm-name/index#kotlin.jvm.JvmName&quot;&gt;JvmName&lt;/a&gt; annotation.</source>
          <target state="translated">指示Kotlin编译器生成一个多文件类，其中包含在此文件中声明的顶级功能和属性作为其一部分。相应的多文件类的名称由&lt;a href=&quot;../-jvm-name/index#kotlin.jvm.JvmName&quot;&gt;JvmName&lt;/a&gt;批注提供。</target>
        </trans-unit>
        <trans-unit id="8b0c8be222fd671f12f20bd767b02c4381772bb8" translate="yes" xml:space="preserve">
          <source>Instructs the Kotlin compiler to generate a multifile class with top-level functions and properties declared in this file as one of its parts. Name of the corresponding multifile class is provided by the &lt;a href=&quot;../../kotlin.jvm/-jvm-name/index#kotlin.jvm.JvmName&quot;&gt;JvmName&lt;/a&gt; annotation.</source>
          <target state="translated">指示Kotlin编译器生成一个多文件类，其中包含在此文件中声明的顶级功能和属性作为其一部分。相应的多文件类的名称由&lt;a href=&quot;../../kotlin.jvm/-jvm-name/index#kotlin.jvm.JvmName&quot;&gt;JvmName&lt;/a&gt;批注提供。</target>
        </trans-unit>
        <trans-unit id="7818697c4ce6725112184b56cee9c62bbd312790" translate="yes" xml:space="preserve">
          <source>Instructs the Kotlin compiler to generate a multifile class with top-level functions and properties declared in this file as one of its parts. Name of the corresponding multifile class is provided by the &lt;a href=&quot;../kotlin.jvm/-jvm-name/index#kotlin.jvm.JvmName&quot;&gt;JvmName&lt;/a&gt; annotation.</source>
          <target state="translated">指示Kotlin编译器生成一个多文件类，其中包含在此文件中声明的顶级功能和属性作为其一部分。相应的多文件类的名称由&lt;a href=&quot;../kotlin.jvm/-jvm-name/index#kotlin.jvm.JvmName&quot;&gt;JvmName&lt;/a&gt;批注提供。</target>
        </trans-unit>
        <trans-unit id="b493b4c87b9464cb2f6602a1607cbc49417f03a7" translate="yes" xml:space="preserve">
          <source>Instructs the Kotlin compiler to generate overloads for this function that substitute default parameter values.</source>
          <target state="translated">指示Kotlin编译器为该函数生成替代默认参数值的重载。</target>
        </trans-unit>
        <trans-unit id="b7b71d6677358cf2e0528038c668cb35b0db79e9" translate="yes" xml:space="preserve">
          <source>Instructs the Kotlin compiler to treat annotated Java class as pure implementation of given Kotlin interface. &quot;Pure&quot; means here that each type parameter of class becomes non-platform type argument of that interface.</source>
          <target state="translated">指示Kotlin编译器将注释的Java类视为给定Kotlin接口的纯实现。&quot;Pure &quot;是指类的每个类型参数都成为该接口的非平台类型参数。</target>
        </trans-unit>
        <trans-unit id="5c89edcac2811a6a9e8072517cae7f3cbfd5049d" translate="yes" xml:space="preserve">
          <source>Int</source>
          <target state="translated">Int</target>
        </trans-unit>
        <trans-unit id="691e0102b6c4ff1f7d6b4b79971b501f00d71a45" translate="yes" xml:space="preserve">
          <source>Int16Array</source>
          <target state="translated">Int16Array</target>
        </trans-unit>
        <trans-unit id="5c193dd46f10dac764d5258087bf039ad767fbce" translate="yes" xml:space="preserve">
          <source>Int32Array</source>
          <target state="translated">Int32Array</target>
        </trans-unit>
        <trans-unit id="e088a2144c05ba06fd761a7dbefbb84d2fc79069" translate="yes" xml:space="preserve">
          <source>Int8Array</source>
          <target state="translated">Int8Array</target>
        </trans-unit>
        <trans-unit id="4e1eee767ff111b716b2cc9473b02ef4802f7fa3" translate="yes" xml:space="preserve">
          <source>IntArray</source>
          <target state="translated">IntArray</target>
        </trans-unit>
        <trans-unit id="80050b51df21784d163dd20b4b73efde68f88f12" translate="yes" xml:space="preserve">
          <source>IntIterator</source>
          <target state="translated">IntIterator</target>
        </trans-unit>
        <trans-unit id="5808b7bdff6fe2202d34d31f55aa02c48c8f9d57" translate="yes" xml:space="preserve">
          <source>IntProgression</source>
          <target state="translated">IntProgression</target>
        </trans-unit>
        <trans-unit id="1ecd34c101b616e04032d5f18915a529dbf2c1ba" translate="yes" xml:space="preserve">
          <source>IntRange</source>
          <target state="translated">IntRange</target>
        </trans-unit>
        <trans-unit id="122a70b702fe4ea6640b0afbf0db142a8ee86964" translate="yes" xml:space="preserve">
          <source>IntVar</source>
          <target state="translated">IntVar</target>
        </trans-unit>
        <trans-unit id="3d2bffbceb8bff9b98f810d1689ed67697bea8bf" translate="yes" xml:space="preserve">
          <source>IntVarOf</source>
          <target state="translated">IntVarOf</target>
        </trans-unit>
        <trans-unit id="876569ad85ebaf17d9149dea5706aba22e882fe8" translate="yes" xml:space="preserve">
          <source>Integer types</source>
          <target state="translated">整数类型</target>
        </trans-unit>
        <trans-unit id="dee1ac1dc651dc2435d67e71a4478aae5437b7bf" translate="yes" xml:space="preserve">
          <source>Integer types in Kotlin have a &lt;em&gt;limited size&lt;/em&gt;, as opposed to the arbitrarily large integers in Python. The limit depends on the type, which decides how many bits the number occupies in memory:</source>
          <target state="translated">与Python中任意大的整数相反，Kotlin中的整数类型的&lt;em&gt;大小有限&lt;/em&gt;。该限制取决于类型，该类型决定了该数字在内存中占据多少位：</target>
        </trans-unit>
        <trans-unit id="cda60a10cf7788b96a2f3e8c4df843ff16bf37d4" translate="yes" xml:space="preserve">
          <source>Integral type ranges (&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.ranges/-int-range/index&quot;&gt;&lt;code&gt;IntRange&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.ranges/-long-range/index&quot;&gt;&lt;code&gt;LongRange&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.ranges/-char-range/index&quot;&gt;&lt;code&gt;CharRange&lt;/code&gt;&lt;/a&gt;) have an extra feature: they can be iterated over. These ranges are also &lt;a href=&quot;https://en.wikipedia.org/wiki/Arithmetic_progression&quot;&gt;progressions&lt;/a&gt; of the corresponding integral types. Such ranges are generally used for iteration in the &lt;code&gt;for&lt;/code&gt; loops.</source>
          <target state="translated">整体式范围（&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.ranges/-int-range/index&quot;&gt; &lt;code&gt;IntRange&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.ranges/-long-range/index&quot;&gt; &lt;code&gt;LongRange&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.ranges/-char-range/index&quot;&gt; &lt;code&gt;CharRange&lt;/code&gt; &lt;/a&gt;）有一个额外的功能：它们可以遍历。这些范围也是相应整数类型的&lt;a href=&quot;https://en.wikipedia.org/wiki/Arithmetic_progression&quot;&gt;级数&lt;/a&gt;。这样的范围一般用于在迭代 &lt;code&gt;for&lt;/code&gt; 环路。</target>
        </trans-unit>
        <trans-unit id="13f8bf35d86cdecdc30977f1b4bf82da0dde4e54" translate="yes" xml:space="preserve">
          <source>IntelliJ IDEA can also automatically generate the &lt;code&gt;@Suppress&lt;/code&gt; annotation. Open the intentions menu via the light bulb icon or Alt-Enter, and click the small arrow next to the &quot;Change type arguments&quot; quick-fix. Here, you can select the suppression scope, and your IDE will add the annotation to your file accordingly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2bee37b0cdd0528c3a6b459962cdaf6bec045292" translate="yes" xml:space="preserve">
          <source>IntelliJ IDEA can also automatically generate the &lt;code&gt;@Suppress&lt;/code&gt; annotation. Open the intentions menu via the light bulb icon or Alt-Enter, and click the small arrow next to the &quot;Unchecked cast to external interface&quot; inspection. Here, you can select the suppression scope, and your IDE will add the annotation to your file accordingly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10bb7deeea7ab770c8cc611de5a7e9bd46c52593" translate="yes" xml:space="preserve">
          <source>IntelliJ IDEA can run the code from scratches and worksheets automatically. To get the execution results when you stop typing, switch on the &lt;strong&gt;Interactive mode&lt;/strong&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8489966f59e24770658292f5a494ac85bfb4f6e0" translate="yes" xml:space="preserve">
          <source>IntelliJ IDEA can run your scratches automatically. To get the execution results once you stop typing for a short time, switch on the &lt;strong&gt;Interactive mode&lt;/strong&gt;.</source>
          <target state="translated">IntelliJ IDEA可以自动刮擦。要在短时间内停止键入后获得执行结果，请打开&amp;ldquo; &lt;strong&gt;交互&amp;rdquo;模式&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="11066aac7596078ae46263d8a457c412baa42d01" translate="yes" xml:space="preserve">
          <source>IntelliJ IDEA will add the corresponding entries for us in the &lt;a href=&quot;#maven-configuration&quot;&gt;Maven configuration&lt;/a&gt;.</source>
          <target state="translated">IntelliJ IDEA将在&lt;a href=&quot;#maven-configuration&quot;&gt;Maven配置中&lt;/a&gt;为我们添加相应的条目。</target>
        </trans-unit>
        <trans-unit id="eff2bf29e6c4ca5eac858ebfb9f2e0be07577de6" translate="yes" xml:space="preserve">
          <source>IntelliJ IDEA's kotlin plugin understands the semantics of &lt;code&gt;TODO()&lt;/code&gt; and automatically adds a code pointer in the TODO toolwindow.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54d05b8bf6f20e0d324256cf774765900389821b" translate="yes" xml:space="preserve">
          <source>Interact with the DOM</source>
          <target state="translated">与DOM互动</target>
        </trans-unit>
        <trans-unit id="2c419294377dd8ca37e7cb76b4dea91ed19ea8dc" translate="yes" xml:space="preserve">
          <source>Interacting with the DOM</source>
          <target state="translated">与DOM的交互</target>
        </trans-unit>
        <trans-unit id="0d798c0b1cd4a6d135dc1e4671cde5f33dab863b" translate="yes" xml:space="preserve">
          <source>Interactive mode</source>
          <target state="translated">互动模式</target>
        </trans-unit>
        <trans-unit id="b02084f4df61f4f1999048df4a4f737cbeb8d5d5" translate="yes" xml:space="preserve">
          <source>Intercept continuation with &lt;a href=&quot;../-continuation-interceptor/index&quot;&gt;ContinuationInterceptor&lt;/a&gt;.</source>
          <target state="translated">使用&lt;a href=&quot;../-continuation-interceptor/index&quot;&gt;ContinuationInterceptor进行&lt;/a&gt;拦截截取。</target>
        </trans-unit>
        <trans-unit id="653ee20081a2ed0c0dfdeafb8d4cc56b1706495b" translate="yes" xml:space="preserve">
          <source>Intercept continuation with &lt;a href=&quot;../kotlin.coroutines.experimental/-continuation-interceptor/index&quot;&gt;ContinuationInterceptor&lt;/a&gt;.</source>
          <target state="translated">使用&lt;a href=&quot;../kotlin.coroutines.experimental/-continuation-interceptor/index&quot;&gt;ContinuationInterceptor进行&lt;/a&gt;拦截截取。</target>
        </trans-unit>
        <trans-unit id="ef76b9eb4630422886c9e0fac2f1db0f2f6f1af1" translate="yes" xml:space="preserve">
          <source>Interception of delegated property binding</source>
          <target state="translated">拦截委托属性绑定</target>
        </trans-unit>
        <trans-unit id="fc7a4e9264f9fe99aec05e3498611be00e954e41" translate="yes" xml:space="preserve">
          <source>Intercepts this continuation with &lt;a href=&quot;../kotlin.coroutines/-continuation-interceptor/index&quot;&gt;ContinuationInterceptor&lt;/a&gt;.</source>
          <target state="translated">用&lt;a href=&quot;../kotlin.coroutines/-continuation-interceptor/index&quot;&gt;ContinuationInterceptor&lt;/a&gt;拦截此继续。</target>
        </trans-unit>
        <trans-unit id="16bd3eae0558639cfe5dccb9e5a929f401a38bef" translate="yes" xml:space="preserve">
          <source>Interface implementation layout</source>
          <target state="translated">接口实现布局</target>
        </trans-unit>
        <trans-unit id="b4d21bf63ded1f81b33de5ff71ef6ec0031cdd1f" translate="yes" xml:space="preserve">
          <source>Interface representing a continuation after a suspension point that returns a value of type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">表示在悬浮点之后的延续的接口，该延续返回类型 &lt;code&gt;T&lt;/code&gt; 的值。</target>
        </trans-unit>
        <trans-unit id="3d559a197ac3fd74c061414f5d71be30830c373e" translate="yes" xml:space="preserve">
          <source>Interface representing a continuation after a suspension point that returns value of type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">接口中的悬浮液点后表示的延续这种类型的回报值 &lt;code&gt;T&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b356313f979923fc829adb909098ed26a5a01aff" translate="yes" xml:space="preserve">
          <source>Interfaces</source>
          <target state="translated">Interfaces</target>
        </trans-unit>
        <trans-unit id="3fb0788052e6b21a9e30969754a6a4b19102a8cb" translate="yes" xml:space="preserve">
          <source>Interfaces &lt;em&gt;A&lt;/em&gt; and &lt;em&gt;B&lt;/em&gt; both declare functions &lt;em&gt;foo()&lt;/em&gt; and &lt;em&gt;bar()&lt;/em&gt;. Both of them implement &lt;em&gt;foo()&lt;/em&gt;, but only &lt;em&gt;B&lt;/em&gt; implements &lt;em&gt;bar()&lt;/em&gt; (&lt;em&gt;bar()&lt;/em&gt; is not marked abstract in &lt;em&gt;A&lt;/em&gt;, because this is the default for interfaces, if the function has no body). Now, if we derive a concrete class &lt;em&gt;C&lt;/em&gt; from &lt;em&gt;A&lt;/em&gt;, we, obviously, have to override &lt;em&gt;bar()&lt;/em&gt; and provide an implementation.</source>
          <target state="translated">接口&lt;em&gt;A&lt;/em&gt;和&lt;em&gt;B&lt;/em&gt;都声明了函数&lt;em&gt;foo（）&lt;/em&gt;和&lt;em&gt;bar（）&lt;/em&gt;。它们都实现&lt;em&gt;foo（）&lt;/em&gt;，但是只有&lt;em&gt;B&lt;/em&gt;实现&lt;em&gt;bar（）&lt;/em&gt;（&lt;em&gt;A中&lt;/em&gt;没有将&lt;em&gt;bar（）&lt;/em&gt;标记为abstract ，因为如果函数没有主体，这是接口的默认值）。现在，如果我们从&lt;em&gt;A&lt;/em&gt;派生出具体的类&lt;em&gt;C&lt;/em&gt;，显然，我们必须重写&lt;em&gt;bar（）&lt;/em&gt;并提供一个实现。&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="99ffdc8085488e57490fe414d8c6f2ac4c1599ac" translate="yes" xml:space="preserve">
          <source>Interfaces Inheritance</source>
          <target state="translated">接口 继承</target>
        </trans-unit>
        <trans-unit id="8b075e134839d5d81cca3ebe6834964746dbfa9f" translate="yes" xml:space="preserve">
          <source>Interfaces in Kotlin are very similar to Java 8. They can contain declarations of abstract methods, as well as method implementations. What makes them different from abstract classes is that interfaces cannot store state. They can have properties but these need to be abstract or to provide accessor implementations.</source>
          <target state="translated">Kotlin中的接口与Java 8非常相似。它们可以包含抽象方法的声明,以及方法实现。它们与抽象类的不同之处在于,接口不能存储状态,它们可以有属性,但这些属性需要是抽象的,或者提供访问器实现。它们可以有属性,但这些属性需要是抽象的,或者提供访问器实现。</target>
        </trans-unit>
        <trans-unit id="3dc6f1c623405f44dfc6225166b717008c4b39d3" translate="yes" xml:space="preserve">
          <source>Interfaces in Kotlin can contain declarations of abstract methods, as well as method implementations. What makes them different from abstract classes is that interfaces cannot store state. They can have properties but these need to be abstract or to provide accessor implementations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3a19a0ac9dc5495efba84238a1c889b8a1af7e4" translate="yes" xml:space="preserve">
          <source>Interop with Java</source>
          <target state="translated">与Java的互操作</target>
        </trans-unit>
        <trans-unit id="c644acaf1f3c1a0ed7a1256f251846c1b5938545" translate="yes" xml:space="preserve">
          <source>InteropStubs</source>
          <target state="translated">InteropStubs</target>
        </trans-unit>
        <trans-unit id="e8ee8f70e7d8b9c0f444242c7791f8de975f2a89" translate="yes" xml:space="preserve">
          <source>Interoperability</source>
          <target state="translated">Interoperability</target>
        </trans-unit>
        <trans-unit id="68de227c33695f7eee1af76e54576c5f473dbabb" translate="yes" xml:space="preserve">
          <source>Interoperability With Java Reflection</source>
          <target state="translated">与Java反射的互操作性</target>
        </trans-unit>
        <trans-unit id="2a2e730dccd30c2b052062769d22631b368b3446" translate="yes" xml:space="preserve">
          <source>Interoperability with Java reflection</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="768631baf54d445fa8bf1b363fe5b7347532e0f6" translate="yes" xml:space="preserve">
          <source>Interoperability with Swift/Objective-C is provided too and covered in a separate document &lt;a href=&quot;objc_interop&quot;&gt;OBJC_INTEROP.md&lt;/a&gt;.</source>
          <target state="translated">还提供了与Swift / Objective-C的互操作性，并在单独的文档&lt;a href=&quot;objc_interop&quot;&gt;OBJC_INTEROP.md&lt;/a&gt;中进行了介绍。</target>
        </trans-unit>
        <trans-unit id="cf0f2c7977d4a0d28911368671a5b929d3d0eeba" translate="yes" xml:space="preserve">
          <source>Introducing an expression as a variable in local scope: &lt;code&gt;let&lt;/code&gt;</source>
          <target state="translated">将表达式引入为局部作用域中的变量： &lt;code&gt;let&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2473e96bc614a911821242119918a241a41836d6" translate="yes" xml:space="preserve">
          <source>Introduction</source>
          <target state="translated">Introduction</target>
        </trans-unit>
        <trans-unit id="32255fd1a8ee65ebb05876eff1fd292d27126703" translate="yes" xml:space="preserve">
          <source>Introduction to Kotlin (in Russian)</source>
          <target state="translated">Kotlin简介(俄语)</target>
        </trans-unit>
        <trans-unit id="8907e06f66221d3c7deda7eaa03a2cc4d7313211" translate="yes" xml:space="preserve">
          <source>Introduction to Kotlin Programming</source>
          <target state="translated">Kotlin编程介绍</target>
        </trans-unit>
        <trans-unit id="1a733ca17cc418ac2040451ede20832965697fc4" translate="yes" xml:space="preserve">
          <source>InvalidMutabilityException</source>
          <target state="translated">InvalidMutabilityException</target>
        </trans-unit>
        <trans-unit id="ed8bc42e69c9abe4619cbcab39f65339c9a9ce60" translate="yes" xml:space="preserve">
          <source>Inverts the bits in this value.</source>
          <target state="translated">将此值的位数反转。</target>
        </trans-unit>
        <trans-unit id="555df15449eba01e6d316f12f10d25ead6974375" translate="yes" xml:space="preserve">
          <source>Inverts the bits including the sign bit in this value.</source>
          <target state="translated">将该值中包括符号位在内的位进行反转。</target>
        </trans-unit>
        <trans-unit id="1808969803eb296cd6d4f6a8c06b19cec81c8416" translate="yes" xml:space="preserve">
          <source>Invocation of &lt;a href=&quot;../kotlin.coroutines/-continuation/resume-with&quot;&gt;Continuation.resumeWith&lt;/a&gt; resumes coroutine directly in the invoker's thread without going through the &lt;a href=&quot;../kotlin.coroutines/-continuation-interceptor/index&quot;&gt;ContinuationInterceptor&lt;/a&gt; that might be present in the coroutine's &lt;a href=&quot;../kotlin.coroutines/-coroutine-context/index&quot;&gt;CoroutineContext&lt;/a&gt;. It is the invoker's responsibility to ensure that a proper invocation context is established. &lt;a href=&quot;intercepted#kotlin.coroutines.intrinsics%24intercepted%28kotlin.coroutines.Continuation%28%28kotlin.coroutines.intrinsics.intercepted.T%29%29%29&quot;&gt;Continuation.intercepted&lt;/a&gt; can be used to acquire the intercepted continuation.</source>
          <target state="translated">的调用&lt;a href=&quot;../kotlin.coroutines/-continuation/resume-with&quot;&gt;Continuation.resumeWith&lt;/a&gt;直接在调用者的线程恢复协程无需经过去&lt;a href=&quot;../kotlin.coroutines/-continuation-interceptor/index&quot;&gt;ContinuationInterceptor&lt;/a&gt;可能存在的协程的&lt;a href=&quot;../kotlin.coroutines/-coroutine-context/index&quot;&gt;CoroutineContext&lt;/a&gt;。调用者有责任确保建立正确的调用上下文。&lt;a href=&quot;intercepted#kotlin.coroutines.intrinsics%24intercepted%28kotlin.coroutines.Continuation%28%28kotlin.coroutines.intrinsics.intercepted.T%29%29%29&quot;&gt;Continuation.intercepted&lt;/a&gt;可用于获取截获的连续性。</target>
        </trans-unit>
        <trans-unit id="12923fefc07e48286763b781976e0602cda671d5" translate="yes" xml:space="preserve">
          <source>Invocation of &lt;a href=&quot;../kotlin.coroutines/-continuation/resume-with&quot;&gt;Continuation.resumeWith&lt;/a&gt; resumes coroutine directly in the invoker's thread without going through the &lt;a href=&quot;../kotlin.coroutines/-continuation-interceptor/index&quot;&gt;ContinuationInterceptor&lt;/a&gt; that might be present in the coroutine's &lt;a href=&quot;../kotlin.coroutines/-coroutine-context/index&quot;&gt;CoroutineContext&lt;/a&gt;. It is the invoker's responsibility to ensure that a proper invocation context is established. &lt;a href=&quot;intercepted#kotlin.coroutines.intrinsics%24intercepted(kotlin.coroutines.Continuation((kotlin.coroutines.intrinsics.intercepted.T)))&quot;&gt;Continuation.intercepted&lt;/a&gt; can be used to acquire the intercepted continuation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a142e8aa439986e2d57c987fdc039b4c2ce8b67d" translate="yes" xml:space="preserve">
          <source>InvocationKind</source>
          <target state="translated">InvocationKind</target>
        </trans-unit>
        <trans-unit id="32a85866515d2c40342d72243d3af2e2ade61880" translate="yes" xml:space="preserve">
          <source>Invoke operator</source>
          <target state="translated">调用操作员</target>
        </trans-unit>
        <trans-unit id="90d36cdc449e51ffdeb986b93d9cc3791424dd45" translate="yes" xml:space="preserve">
          <source>Invoked for the continuation instance returned by &lt;a href=&quot;intercept-continuation&quot;&gt;interceptContinuation&lt;/a&gt; when the original continuation completes and will not be used anymore. This function is invoked only if &lt;a href=&quot;intercept-continuation&quot;&gt;interceptContinuation&lt;/a&gt; had returned a different continuation instance from the one it was invoked with.</source>
          <target state="translated">当原始延续完成且不再使用时，为&lt;a href=&quot;intercept-continuation&quot;&gt;interceptContinuation&lt;/a&gt;返回的延续实例调用。仅当&lt;a href=&quot;intercept-continuation&quot;&gt;interceptContinuation&lt;/a&gt;返回的调用实例不同于其调用实例时，才调用此函数。</target>
        </trans-unit>
        <trans-unit id="e7b262710ce446d5dceec2a721a656e3054eebf5" translate="yes" xml:space="preserve">
          <source>Invoking &lt;code&gt;call()&lt;/code&gt; on a function object will call the function. If it is a member function, the first parameter must be the &lt;em&gt;receiver&lt;/em&gt; (the object on which the function is to be invoked, in this case &lt;code&gt;person&lt;/code&gt;), and the remaining parameters must be the ordinary function parameters (in this case &lt;code&gt;&quot;Anne&quot;&lt;/code&gt;).</source>
          <target state="translated">在函数对象上调用 &lt;code&gt;call()&lt;/code&gt; 将调用该函数。如果它是成员函数，则第一个参数必须是&lt;em&gt;接收者&lt;/em&gt;（要在其上调用函数的对象，在这种情况下为 &lt;code&gt;person&lt;/code&gt; ），而其余参数必须是普通的函数参数（在这种情况下为 &lt;code&gt;&quot;Anne&quot;&lt;/code&gt; ） 。</target>
        </trans-unit>
        <trans-unit id="e517c0efd966757777074a55cf84552ef188ca9a" translate="yes" xml:space="preserve">
          <source>Invoking &lt;code&gt;findViewById()&lt;/code&gt; can be slow, especially in case of huge view hierarchies, so Android Extensions tries to minimize &lt;code&gt;findViewById()&lt;/code&gt; calls by caching views in containers.</source>
          <target state="translated">调用 &lt;code&gt;findViewById()&lt;/code&gt; 可能会很慢，尤其是在视图层次结构庞大的情况下，因此Android扩展会尝试通过在容器中缓存视图来最小化 &lt;code&gt;findViewById()&lt;/code&gt; 调用。</target>
        </trans-unit>
        <trans-unit id="55b7cc54c31bd895727aeb7e2e5dfcfeaf500f67" translate="yes" xml:space="preserve">
          <source>Invoking a function type instance</source>
          <target state="translated">调用函数类型实例</target>
        </trans-unit>
        <trans-unit id="609d1188a5fb6f3c57a44ee5ee27b2fb07938bf1" translate="yes" xml:space="preserve">
          <source>Invoking functions on other collections</source>
          <target state="translated">在其他集合上调用函数</target>
        </trans-unit>
        <trans-unit id="39f649540ce7c567f8fc21179741df12bdec413a" translate="yes" xml:space="preserve">
          <source>Is Kotlin an object-oriented language or a functional one?</source>
          <target state="translated">Kotlin是一种面向对象的语言还是一种功能型语言?</target>
        </trans-unit>
        <trans-unit id="0396150c49da7aa331143384cade7b9761b9c77b" translate="yes" xml:space="preserve">
          <source>Is Kotlin compatible with the Java programming language?</source>
          <target state="translated">Kotlin与Java编程语言兼容吗?</target>
        </trans-unit>
        <trans-unit id="d651f0b2ee6f868c27d5b6dae520cfb850abc9e7" translate="yes" xml:space="preserve">
          <source>Is Kotlin free?</source>
          <target state="translated">Kotlin是免费的吗?</target>
        </trans-unit>
        <trans-unit id="4096c8e1086b327150a7292e4d2afe3394a12f6e" translate="yes" xml:space="preserve">
          <source>Is Kotlin hard?</source>
          <target state="translated">Kotlin难吗?</target>
        </trans-unit>
        <trans-unit id="9edc452dd78ce29f04fd4cdc3ccb57260c61debd" translate="yes" xml:space="preserve">
          <source>Is Kotlin on Social Media?</source>
          <target state="translated">Kotlin在社交媒体上吗?</target>
        </trans-unit>
        <trans-unit id="4e2b800e686ee55bbeca8de0e7c4e9007eb7822f" translate="yes" xml:space="preserve">
          <source>Is Kotlin on social media?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06373ad2bc61a9e4042f42be3c932a4374d09d55" translate="yes" xml:space="preserve">
          <source>Is extension function</source>
          <target state="translated">是扩展功能</target>
        </trans-unit>
        <trans-unit id="84f7edacad77f3efea0c1f9a95023335afe8e98e" translate="yes" xml:space="preserve">
          <source>Is there a Kotlin conference?</source>
          <target state="translated">有Kotlin会议吗?</target>
        </trans-unit>
        <trans-unit id="23fb12980d63818dd24d249914c5dbde1e4eab5d" translate="yes" xml:space="preserve">
          <source>Isn't it what we wanted from the very beginning?</source>
          <target state="translated">这不是我们一开始就想要的吗?</target>
        </trans-unit>
        <trans-unit id="651e4641fbeb110db3b7fdfb2bb5a04a7dfe7d1b" translate="yes" xml:space="preserve">
          <source>Isolating declarations in a separate JavaScript object</source>
          <target state="translated">在一个单独的JavaScript对象中隔离声明。</target>
        </trans-unit>
        <trans-unit id="d439914b4bf445ecb5fcbbcfd0b7501a29e97254" translate="yes" xml:space="preserve">
          <source>Isolating declarations in a separate JavaScript object in &lt;code&gt;plain&lt;/code&gt; mode</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec40e8e2417f63763bc4005b1f45f89c4b9bd620" translate="yes" xml:space="preserve">
          <source>It also works with meta-annotations:</source>
          <target state="translated">它还可以与元注释一起使用。</target>
        </trans-unit>
        <trans-unit id="6f49ae3f8f0dbf679bfc3c5ff95bf21f8e30ee20" translate="yes" xml:space="preserve">
          <source>It can be demonstrated by a simple example that creates coroutines in the &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-global-scope/index.html&quot;&gt;GlobalScope&lt;/a&gt;:</source>
          <target state="translated">可以通过一个在&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-global-scope/index.html&quot;&gt;GlobalScope&lt;/a&gt;中创建协程的简单示例来证明这一点：</target>
        </trans-unit>
        <trans-unit id="fafe915e21eb48d949ca0df5819ea5714df59866" translate="yes" xml:space="preserve">
          <source>It can be demonstrated by a simple example that creates root coroutines using the &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-global-scope/index.html&quot;&gt;GlobalScope&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2cb6066b03e8d078e05b9934f5a0885eb7115c7" translate="yes" xml:space="preserve">
          <source>It can be demonstrated by the following example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7f79c6fa89f2be4d0900a1df15f6e4c9cd6d6d8" translate="yes" xml:space="preserve">
          <source>It can of course be done as a single expression: &lt;code&gt;val x = javaFunctionThatYouKnowReturnsNonNull()!!&lt;/code&gt;.</source>
          <target state="translated">当然，它可以作为单个表达式完成： &lt;code&gt;val x = javaFunctionThatYouKnowReturnsNonNull()!!&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b4869b700b07f0d7aa2566a42cedd6c00ff40027" translate="yes" xml:space="preserve">
          <source>It demonstrates several new techniques. One is using &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/run-blocking.html&quot;&gt;runBlocking&lt;/a&gt; with an explicitly specified context, and the other one is using &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/with-context.html&quot;&gt;withContext&lt;/a&gt; function to change a context of a coroutine while still staying in the same coroutine as you can see in the output below:</source>
          <target state="translated">它演示了几种新技术。一种是在具有明确指定的上下文的情况下使用&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/run-blocking.html&quot;&gt;runBlocking&lt;/a&gt;，另一种是使用&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/with-context.html&quot;&gt;withContext&lt;/a&gt;函数更改协程的上下文，同时仍保持在同一协程中，如下面的输出所示：</target>
        </trans-unit>
        <trans-unit id="407d919d76eb160a2f5dfd9e474e1e25b6f6932e" translate="yes" xml:space="preserve">
          <source>It demonstrates several new techniques. One is using &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/run-blocking.html&quot;&gt;runBlocking&lt;/a&gt; with an explicitly specified context, and the other one is using the &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/with-context.html&quot;&gt;withContext&lt;/a&gt; function to change the context of a coroutine while still staying in the same coroutine, as you can see in the output below:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df6b25cff4a7799af9dc4369b6ce738113d68ee2" translate="yes" xml:space="preserve">
          <source>It does not matter (for correctness) what context the actor itself is executed in. An actor is a coroutine and a coroutine is executed sequentially, so confinement of the state to the specific coroutine works as a solution to the problem of shared mutable state. Indeed, actors may modify their own private state, but can only affect each other through messages (avoiding the need for any locks).</source>
          <target state="translated">actor本身在什么上下文中执行并不重要(为了正确性)。一个actor是一个coroutine,而一个coroutine是按顺序执行的,所以将状态限制在特定的coroutine中可以作为共享可变状态问题的一个解决方案。事实上,actor可以修改自己的私有状态,但只能通过消息来影响对方(避免任何锁的需要)。</target>
        </trans-unit>
        <trans-unit id="838f4ba272421d5995e2a80726c6cbb738d51748" translate="yes" xml:space="preserve">
          <source>It expects the targets to provide platform-specific implementations for &lt;code&gt;writeLogMessage&lt;/code&gt;, and the common code can now use this declaration without any consideration of how it is implemented.</source>
          <target state="translated">它期望目标为 &lt;code&gt;writeLogMessage&lt;/code&gt; 提供特定于平台的实现，并且通用代码现在可以使用此声明，而无需考虑如何实现。</target>
        </trans-unit>
        <trans-unit id="acca4b75fdfdc287f94d60288ba8cbf8ea940d89" translate="yes" xml:space="preserve">
          <source>It is also convenient to use when you have a callable reference instead of the lambda:</source>
          <target state="translated">当你有一个可调用的引用而不是lambda时,使用它也很方便。</target>
        </trans-unit>
        <trans-unit id="db36d25fe18e1fa8b4a072e0b9e5e699d53ac00e" translate="yes" xml:space="preserve">
          <source>It is also possible to configure all Kotlin compilation tasks in the project:</source>
          <target state="translated">也可以在项目中配置所有的Kotlin编译任务。</target>
        </trans-unit>
        <trans-unit id="4e799686fc388ae642c64e9044143db835d23770" translate="yes" xml:space="preserve">
          <source>It is also possible to debug Kotlin applications using the standard Chrome debugger. Just make sure that you do generate source maps.</source>
          <target state="translated">也可以使用标准的Chrome调试器来调试Kotlin应用程序。只要确保你能生成源码图。</target>
        </trans-unit>
        <trans-unit id="2d484974349c030ade989fbea0475cbaae9e9d98" translate="yes" xml:space="preserve">
          <source>It is also possible to iterate over numbers with an arbitrary step (not necessarily 1). This is done via the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.ranges/step&quot;&gt;&lt;code&gt;step&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">也可以通过任意步长（不一定为1）迭代数字。这是通过&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.ranges/step&quot;&gt; &lt;code&gt;step&lt;/code&gt; &lt;/a&gt;功能完成的。</target>
        </trans-unit>
        <trans-unit id="dc446105af35ae94e82863937d04520fa631bab7" translate="yes" xml:space="preserve">
          <source>It is convenient to import all widget properties for a specific layout in one go:</source>
          <target state="translated">一次性导入特定布局的所有widget属性,非常方便。</target>
        </trans-unit>
        <trans-unit id="ea87fa24d13265d437721a500dc610021a2b6ae7" translate="yes" xml:space="preserve">
          <source>It is created by attaching &lt;code&gt;keySelector: (T) -&amp;gt; K&lt;/code&gt; function to a source of elements. To get an instance of &lt;a href=&quot;index&quot;&gt;Grouping&lt;/a&gt; use one of &lt;code&gt;groupingBy&lt;/code&gt; extension functions:</source>
          <target state="translated">它是通过将 &lt;code&gt;keySelector: (T) -&amp;gt; K&lt;/code&gt; 函数附加到元素源来创建的。要获得&lt;a href=&quot;index&quot;&gt;分组&lt;/a&gt;的实例，请使用 &lt;code&gt;groupingBy&lt;/code&gt; 扩展功能之一：</target>
        </trans-unit>
        <trans-unit id="9817b3326fc94d2d632dd03bcb277b7bc5e546ba" translate="yes" xml:space="preserve">
          <source>It is easy to demonstrate it in action:</source>
          <target state="translated">很容易用行动来证明。</target>
        </trans-unit>
        <trans-unit id="5057879a755e254fb21862c60fef7113f875d675" translate="yes" xml:space="preserve">
          <source>It is easy to include a compiled Kotlin code into existing projects written in C, C++, Swift, Objective-C, and other languages. It is also easy to use existing native code, static or dynamic &lt;a href=&quot;native/c_interop&quot;&gt;C libraries&lt;/a&gt;, Swift/Objective-C &lt;a href=&quot;native/objc_interop&quot;&gt;frameworks&lt;/a&gt;, graphical engines, and anything else directly from Kotlin/Native.</source>
          <target state="translated">将编译的Kotlin代码包含到以C，C ++，Swift，Objective-C和其他语言编写的现有项目中很容易。使用现有的本机代码，静态或动态&lt;a href=&quot;native/c_interop&quot;&gt;C库&lt;/a&gt;，Swift / Objective-C &lt;a href=&quot;native/objc_interop&quot;&gt;框架&lt;/a&gt;，图形引擎以及直接来自Kotlin / Native的其他任何工具也很容易。</target>
        </trans-unit>
        <trans-unit id="5f37ac7cf663ce39ab7cecdf53e288f77e8f878b" translate="yes" xml:space="preserve">
          <source>It is easy to use the generated wrapper classes for C &lt;code&gt;struct&lt;/code&gt; and &lt;code&gt;union&lt;/code&gt; types from Kotlin. Thanks to the generated properties, it feels natural to use them in Kotlin code. The only question, so far, is how do we create a new instance on those classes. As we see from the declarations of &lt;code&gt;MyStruct&lt;/code&gt; and &lt;code&gt;MyUnion&lt;/code&gt;, their constructors require a &lt;code&gt;NativePtr&lt;/code&gt;. Of course, we are not willing to deal with pointers manually. Instead, we can use Kotlin API to have those objects instantiated for us.</source>
          <target state="translated">对于Kotlin的C &lt;code&gt;struct&lt;/code&gt; 和 &lt;code&gt;union&lt;/code&gt; 类型，可以轻松使用生成的包装器类。由于生成了属性，因此在Kotlin代码中使用它们很自然。到目前为止，唯一的问题是我们如何在这些类上创建一个新实例。从 &lt;code&gt;MyStruct&lt;/code&gt; 和 &lt;code&gt;MyUnion&lt;/code&gt; 的声明中可以看到，它们的构造函数需要 &lt;code&gt;NativePtr&lt;/code&gt; 。当然，我们不愿意手动处理指针。相反，我们可以使用Kotlin API为我们实例化那些对象。</target>
        </trans-unit>
        <trans-unit id="13a7c2154690aa37b95c233923686a0683d02a9e" translate="yes" xml:space="preserve">
          <source>It is equivalent to this Java code:</source>
          <target state="translated">它相当于这段Java代码。</target>
        </trans-unit>
        <trans-unit id="fd011ac428fa7a3101febe89637cd71887a4e771" translate="yes" xml:space="preserve">
          <source>It is forbidden for inline classes to participate in a class hierarchy. This means that inline classes cannot extend other classes and must be &lt;em&gt;final&lt;/em&gt;.</source>
          <target state="translated">禁止内联类参与类层次结构。这意味着内联类不能扩展其他类，并且必须是&lt;em&gt;final&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="baf0c1eedc3c7d76ed7d17e6f83833365d1074e5" translate="yes" xml:space="preserve">
          <source>It is important to note that some of the &lt;a href=&quot;#supported-platforms&quot;&gt;Kotlin/Native targets&lt;/a&gt; may only be built with an appropriate host machine:</source>
          <target state="translated">重要的是要注意，某些&lt;a href=&quot;#supported-platforms&quot;&gt;Kotlin / Native目标&lt;/a&gt;只能使用适当的主机构建：</target>
        </trans-unit>
        <trans-unit id="417f8643742c5b4b13e710785eaf864b3ada4be9" translate="yes" xml:space="preserve">
          <source>It is important to understand that just like in the case of &lt;code&gt;callAnything()&lt;/code&gt;, the &lt;code&gt;dataTable()&lt;/code&gt; function must exist at runtime. In our case, we need to make sure that the corresponding script file for our plugin is included:</source>
          <target state="translated">重要的是要理解，就像在 &lt;code&gt;callAnything()&lt;/code&gt; 的情况下一样， &lt;code&gt;dataTable()&lt;/code&gt; 函数必须在运行时存在。在我们的情况下，我们需要确保包含插件的相应脚本文件：</target>
        </trans-unit>
        <trans-unit id="0e863e2f2b3f4c7cb9be7530e2969137eb812edc" translate="yes" xml:space="preserve">
          <source>It is not recommended to publish variants grouped by the product flavor in case they have different dependencies, as those will be merged into one dependencies list.</source>
          <target state="translated">不建议发布按产品风味分组的变体,以防它们有不同的依赖关系,因为这些变体会被合并到一个依赖关系列表中。</target>
        </trans-unit>
        <trans-unit id="41a0e8e8363c715bede252f00decd03608d5ae6b" translate="yes" xml:space="preserve">
          <source>It is not required to match directories and packages: source files can be placed arbitrarily in the file system.</source>
          <target state="translated">它不需要匹配目录和包:源文件可以任意放在文件系统中。</target>
        </trans-unit>
        <trans-unit id="ed10861129de21214d3c19646f1725bf54132b36" translate="yes" xml:space="preserve">
          <source>It is now possible to enumerate the values of an enum class in a generic way.</source>
          <target state="translated">现在可以用一种通用的方式来枚举一个枚举类的值。</target>
        </trans-unit>
        <trans-unit id="e7a4a5a763a24f82bedd348e3c81f2b59dad3138" translate="yes" xml:space="preserve">
          <source>It is platform independent. Whether we targeting JVM, JavaScript or any other platform, the code we write is the same. Under the covers the compiler takes care of adapting it to each platform.</source>
          <target state="translated">它是独立于平台的。无论我们是针对JVM、JavaScript还是其他平台,我们写的代码都是一样的。在掩护之下,编译器会负责让它适应每个平台。</target>
        </trans-unit>
        <trans-unit id="4d947185f89d323fe7c7abf6d8cbb01ea4b530eb" translate="yes" xml:space="preserve">
          <source>It is possible for a class to implement a function type as if it were an interface. It must then supply an operator function called &lt;code&gt;invoke&lt;/code&gt; with the given signature, and instances of that class may then be assigned to a variable of that function type:</source>
          <target state="translated">类有可能像执行接口一样实现函数类型。然后，它必须提供带有给定签名的称为 &lt;code&gt;invoke&lt;/code&gt; 的运算符函数，然后可以将该类的实例分配给该函数类型的变量：</target>
        </trans-unit>
        <trans-unit id="05ec15ebc6d7af617a86a57248adcf19a55ca53f" translate="yes" xml:space="preserve">
          <source>It is possible to annotate type arguments of generic types to provide nullability information for them as well. For example, consider these annotations on a Java declaration:</source>
          <target state="translated">可以对通用类型的类型参数进行注解,以便为它们提供空性信息。例如,考虑一下Java声明中的这些注释。</target>
        </trans-unit>
        <trans-unit id="a4db969f6c44a5e65473207ba72459c76a3f1c8a" translate="yes" xml:space="preserve">
          <source>It is possible to configure the language settings of all source sets at once:</source>
          <target state="translated">可以一次性配置所有源集的语言设置。</target>
        </trans-unit>
        <trans-unit id="8ee4c90445d9b9d795928bb3dfbba324ab54fe64" translate="yes" xml:space="preserve">
          <source>It is possible to create a scope-stable pointer of C representation of &lt;code&gt;CValues&amp;lt;T&amp;gt;&lt;/code&gt; instance using the &lt;code&gt;CValues&amp;lt;T&amp;gt;.ptr&lt;/code&gt; extension property, available under &lt;code&gt;memScoped { ... }&lt;/code&gt;. It allows using the APIs which require C pointers with a lifetime bound to a certain &lt;code&gt;MemScope&lt;/code&gt;. For example:</source>
          <target state="translated">可以使用 &lt;code&gt;memScoped { ... }&lt;/code&gt; 下的 &lt;code&gt;CValues&amp;lt;T&amp;gt;.ptr&lt;/code&gt; 扩展属性创建 &lt;code&gt;CValues&amp;lt;T&amp;gt;&lt;/code&gt; 实例的C表示形式的作用域稳定的指针。它允许使用需要C指针且生命周期绑定到某个 &lt;code&gt;MemScope&lt;/code&gt; 的API。例如：</target>
        </trans-unit>
        <trans-unit id="a1c523500d91947ee9765a964b978e521350e87f" translate="yes" xml:space="preserve">
          <source>It is possible to customize the default behavior of printing &lt;strong&gt;uncaught&lt;/strong&gt; exceptions to the console. &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-exception-handler/index.html&quot;&gt;CoroutineExceptionHandler&lt;/a&gt; context element on a &lt;em&gt;root&lt;/em&gt; coroutine can be used as generic &lt;code&gt;catch&lt;/code&gt; block for this root coroutine and all its children where custom exception handling may take place. It is similar to &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/lang/Thread.html#setUncaughtExceptionHandler(java.lang.Thread.UncaughtExceptionHandler)&quot;&gt;&lt;code&gt;Thread.uncaughtExceptionHandler&lt;/code&gt;&lt;/a&gt;. You cannot recover from the exception in the &lt;code&gt;CoroutineExceptionHandler&lt;/code&gt;. The coroutine had already completed with the corresponding exception when the handler is called. Normally, the handler is used to log the exception, show some kind of error message, terminate, and/or restart the application.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9091ebea40cd5ed5eeeecc5f5fcdcb74a99a77f" translate="yes" xml:space="preserve">
          <source>It is possible to declare contracts for your own functions, but this feature is &lt;strong&gt;experimental,&lt;/strong&gt; as the current syntax is in a state of early prototype and will most probably be changed. Also, please note, that currently the Kotlin compiler does not verify contracts, so it's a programmer's responsibility to write correct and sound contracts.</source>
          <target state="translated">可以为您自己的函数声明合同，但是此功能是&lt;strong&gt;实验性的，&lt;/strong&gt;因为当前语法处于早期原型状态，并且很可能会更改。另外，请注意，当前Kotlin编译器不验证合同，因此编写正确和合理的合同是程序员的责任。</target>
        </trans-unit>
        <trans-unit id="dc3778d4014e6f71dce4d7d20c0e012498a2087a" translate="yes" xml:space="preserve">
          <source>It is possible to filter headers by globs. The &lt;code&gt;headerFilter&lt;/code&gt; property value from the &lt;code&gt;.def&lt;/code&gt; file is treated as a space-separated list of globs. If the included header matches any of the globs, then the declarations from this header are included into the bindings.</source>
          <target state="translated">可以按全局过滤标题。 &lt;code&gt;.def&lt;/code&gt; 文件中的 &lt;code&gt;headerFilter&lt;/code&gt; 属性值被视为以空格分隔的glob列表。如果包含的标头与任何glob匹配，则来自此标头的声明将包含在绑定中。</target>
        </trans-unit>
        <trans-unit id="402a77d3239dcd76fb899799d8112b0ad86dfc4e" translate="yes" xml:space="preserve">
          <source>It is possible to have more than one target for a single platform in a multiplatform library. For example, these targets may provide the same API and differ in the libraries they cooperate with at runtime, like testing frameworks or logging solutions.</source>
          <target state="translated">在一个多平台库中,一个平台可以有多个目标。例如,这些目标可以提供相同的API,但在运行时与之合作的库不同,如测试框架或日志解决方案。</target>
        </trans-unit>
        <trans-unit id="2e301a8ab019737ffb1879efcfc2dbdf711dcf6a" translate="yes" xml:space="preserve">
          <source>It is possible to specify which build types will be used to create binaries and which won't. In the following example only debug executable is created.</source>
          <target state="translated">可以指定哪些构建类型将被用于创建二进制文件,哪些不会。在下面的例子中,只创建调试可执行文件。</target>
        </trans-unit>
        <trans-unit id="c4c1947233d08bc7cc11e65c450d05edf9570b44" translate="yes" xml:space="preserve">
          <source>It is quite a common situation to have a list of keys and want to build a map by associating each of these keys with some value. It was possible to do it before with the &lt;code&gt;associate { it to getValue(it) }&lt;/code&gt; function, but now we&amp;rsquo;re introducing a more efficient and easy to explore alternative: &lt;code&gt;keys.associateWith { getValue(it) }&lt;/code&gt;.</source>
          <target state="translated">拥有键列表并希望通过将这些键中的每个键与某个值相关联来构建映射是一种很常见的情况。以前可以通过 &lt;code&gt;associate { it to getValue(it) }&lt;/code&gt; 函数来做到这一点，但是现在我们引入了一种更有效，更容易探索的替代方法： &lt;code&gt;keys.associateWith { getValue(it) }&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cb237bed1931cb077bff53fe7955788594878ed8" translate="yes" xml:space="preserve">
          <source>It is safe to treat a &lt;code&gt;Consumer&amp;lt;Fruit&amp;gt;&lt;/code&gt; as a &lt;code&gt;Consumer&amp;lt;Apple&amp;gt;&lt;/code&gt; - you are then restricted to only adding &lt;code&gt;Apple&lt;/code&gt; instances to it, but that's okay, because it is capable of receiving any &lt;code&gt;Fruit&lt;/code&gt;.</source>
          <target state="translated">将 &lt;code&gt;Consumer&amp;lt;Fruit&amp;gt;&lt;/code&gt; 视为 &lt;code&gt;Consumer&amp;lt;Apple&amp;gt;&lt;/code&gt; 是安全的-然后，您只能在其中添加 &lt;code&gt;Apple&lt;/code&gt; 实例，但这没关系，因为它可以接收任何 &lt;code&gt;Fruit&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dc95825b1857af449f9e7a03e1be3bb43d0ddb3a" translate="yes" xml:space="preserve">
          <source>It is safe to treat a &lt;code&gt;Producer&amp;lt;Apple&amp;gt;&lt;/code&gt; as if it were a &lt;code&gt;Producer&amp;lt;Fruit&amp;gt;&lt;/code&gt; - the only thing it will ever produce is &lt;code&gt;Apple&lt;/code&gt; instances, but that's okay, because an &lt;code&gt;Apple&lt;/code&gt; is a &lt;code&gt;Fruit&lt;/code&gt;.</source>
          <target state="translated">将 &lt;code&gt;Producer&amp;lt;Apple&amp;gt;&lt;/code&gt; 视为 &lt;code&gt;Producer&amp;lt;Fruit&amp;gt;&lt;/code&gt; 是安全的-它只会生产 &lt;code&gt;Apple&lt;/code&gt; 实例，但这没关系，因为 &lt;code&gt;Apple&lt;/code&gt; 是 &lt;code&gt;Fruit&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1cb7a9be64c1b10976e2826c53f2565e3ab27c33" translate="yes" xml:space="preserve">
          <source>It is the same as the hashCode of &lt;a href=&quot;../-map/entries#kotlin.collections.Map%24entries&quot;&gt;entries&lt;/a&gt; set.</source>
          <target state="translated">它与&lt;a href=&quot;../-map/entries#kotlin.collections.Map%24entries&quot;&gt;条目&lt;/a&gt;集的hashCode相同。</target>
        </trans-unit>
        <trans-unit id="638b2a44297b2347a2a9b3d378c007753c4381ba" translate="yes" xml:space="preserve">
          <source>It is the time to try using C Functions from our Kotlin program. Let's call the &lt;code&gt;accept_fun&lt;/code&gt; function and pass the C function pointer to a Kotlin lambda:</source>
          <target state="translated">现在该尝试从我们的Kotlin程序中使用C函数了。让我们调用 &lt;code&gt;accept_fun&lt;/code&gt; 函数并将C函数指针传递给Kotlin lambda：</target>
        </trans-unit>
        <trans-unit id="d8fa5339a1950bfcc4e526f49360c54a4a63bc2d" translate="yes" xml:space="preserve">
          <source>It is very convenient to declare a type parameter T as &lt;em&gt;out&lt;/em&gt; and avoid trouble with subtyping on the use site, but some classes &lt;strong&gt;can't&lt;/strong&gt; actually be restricted to only return &lt;code&gt;T&lt;/code&gt;'s! A good example of this is Array:</source>
          <target state="translated">这是声明类型参数T作为非常方便的&lt;em&gt;进行&lt;/em&gt;并避免麻烦子类型上使用的网站，但有些类&lt;strong&gt;不能&lt;/strong&gt;实际上只限于返回 &lt;code&gt;T&lt;/code&gt; 的！一个很好的例子是数组：</target>
        </trans-unit>
        <trans-unit id="776fdced037b223c21ef26795ae5fc999fa0ee3e" translate="yes" xml:space="preserve">
          <source>It launches 100K coroutines and, after 5 seconds, each coroutine prints a dot.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b163cb494d8f7133d17c75969b6f58ad44cf2144" translate="yes" xml:space="preserve">
          <source>It launches 100K coroutines and, after a second, each coroutine prints a dot. Now, try that with threads. What would happen? (Most likely your code will produce some sort of out-of-memory error)</source>
          <target state="translated">它启动了100K个coroutine,一秒钟后,每个coroutine打印一个点。现在,用线程试试。会发生什么?(很可能你的代码会产生某种内存外的错误)</target>
        </trans-unit>
        <trans-unit id="efa9aff9b6f6c29df2d20508228006677fa18621" translate="yes" xml:space="preserve">
          <source>It leads to the following signature seen in Kotlin:</source>
          <target state="translated">这就导致了在Kotlin中看到的以下签名。</target>
        </trans-unit>
        <trans-unit id="31157cfdb7da2c923cc250df2cdef99f52021252" translate="yes" xml:space="preserve">
          <source>It makes it easy to add and reorder elements &amp;ndash; there is no need to add or delete the comma if you manipulate elements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17169e22fd37b9c0c61060b6531c5a37b04dbe03" translate="yes" xml:space="preserve">
          <source>It makes version-control diffs cleaner &amp;ndash; as all the focus is on the changed value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50a8da20f5180842f95e2e885ec1433b6eb6b732" translate="yes" xml:space="preserve">
          <source>It may be helpful only if declaration seems to be inconvenient to use from Java without wildcard.</source>
          <target state="translated">只有在没有通配符的情况下,在Java中声明似乎不方便使用时,它才会有帮助。</target>
        </trans-unit>
        <trans-unit id="8ead6eaf5a09cdd5203f3d7332c148b0e2afab55" translate="yes" xml:space="preserve">
          <source>It may be helpful only if declaration seems to be inconvenient to use from Java.</source>
          <target state="translated">只有在Java中声明似乎不方便使用时,它才会有帮助。</target>
        </trans-unit>
        <trans-unit id="92fc36943474eb17749f18ce6facbefadc2bd75a" translate="yes" xml:space="preserve">
          <source>It may seem a logical next step to remove this obscurity by switching the defaults in IntelliJ IDEA and make formatting consistent with the Kotlin Coding Conventions. But this would mean that all the existing Kotlin projects will have a new code style enabled the moment the Kotlin plugin is installed. Not really the expected result for plugin update, right?</source>
          <target state="translated">通过切换IntelliJ IDEA中的默认值并使格式化与Kotlin编码约定保持一致来消除这种模糊性,这似乎是一个合乎逻辑的下一步。但这将意味着所有现有的Kotlin项目在安装Kotlin插件的那一刻就会启用新的代码风格。这其实并不是插件更新的预期结果吧?</target>
        </trans-unit>
        <trans-unit id="5a4d0a01a307589d4ada06d8aac41c245c2a1232" translate="yes" xml:space="preserve">
          <source>It means that, by the time of the base class constructor execution, the properties declared or overridden in the derived class are not yet initialized. If any of those properties are used in the base class initialization logic (either directly or indirectly, through another overridden &lt;em&gt;open&lt;/em&gt; member implementation), it may lead to incorrect behavior or a runtime failure. When designing a base class, you should therefore avoid using &lt;em&gt;open&lt;/em&gt; members in the constructors, property initializers, and &lt;em&gt;init&lt;/em&gt; blocks.</source>
          <target state="translated">这意味着，在执行基类构造函数时，尚未初始化在派生类中声明或覆盖的属性。如果在基类初始化逻辑中使用了这些属性中的任何一个（直接或间接地通过另一个重写的&lt;em&gt;开放&lt;/em&gt;成员实现），则可能导致错误的行为或运行时失败。因此，在设计基类时，应避免在构造函数，属性初始化程序和&lt;em&gt;init&lt;/em&gt;块中使用&lt;em&gt;开放&lt;/em&gt;成员。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="797f38dacaae5d59a26c62d2dd822a0488289854" translate="yes" xml:space="preserve">
          <source>It might be temping to use JVM's &lt;code&gt;java.util.Scanner&lt;/code&gt; class to parse less structured input formats. Kotlin is designed to interoperate well with JVM libraries, so that their use feels quite natural in Kotlin. However, beware that &lt;code&gt;java.util.Scanner&lt;/code&gt; is extremely slow. So slow, in fact, that parsing 10&lt;sup&gt;5&lt;/sup&gt; or more integers with it might not fit into a typical 2 second time-limit, which a simple Kotlin's &lt;code&gt;split(&quot; &quot;).map { it.toInt() }&lt;/code&gt; would handle.</source>
          <target state="translated">可能会尝试使用JVM的 &lt;code&gt;java.util.Scanner&lt;/code&gt; 类来解析结构化程度较低的输入格式。Kotlin旨在与JVM库良好地互操作，因此在Kotlin中使用它们非常自然。但是，请注意 &lt;code&gt;java.util.Scanner&lt;/code&gt; 非常慢。实际上，它是如此之慢，以至于用它解析10 &lt;sup&gt;5个&lt;/sup&gt;或更多整数可能不适合典型的2秒时限，这是简单的Kotlin的 &lt;code&gt;split(&quot; &quot;).map { it.toInt() }&lt;/code&gt; 可以处理的。</target>
        </trans-unit>
        <trans-unit id="4dcefeb4f7398e3e9107786806cb210122661b33" translate="yes" xml:space="preserve">
          <source>It prints &quot;sending&quot; &lt;em&gt;five&lt;/em&gt; times using a buffered channel with capacity of &lt;em&gt;four&lt;/em&gt;:</source>
          <target state="translated">它使用容量为&lt;em&gt;4&lt;/em&gt;的缓冲通道打印&amp;ldquo;发送&amp;rdquo; &lt;em&gt;五次&lt;/em&gt;：&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="22cac1fe7a5de098526c35e5a30637b070cd91b6" translate="yes" xml:space="preserve">
          <source>It prints following lines:</source>
          <target state="translated">它打印的行数如下:</target>
        </trans-unit>
        <trans-unit id="c7f4b533e837bd7e46a9ce1a0a22fbfcd4d17d31" translate="yes" xml:space="preserve">
          <source>It produces something like that when running in &lt;a href=&quot;#debugging-coroutines-and-threads&quot;&gt;debug mode&lt;/a&gt;:</source>
          <target state="translated">在&lt;a href=&quot;#debugging-coroutines-and-threads&quot;&gt;调试模式下&lt;/a&gt;运行时，它会产生类似的结果：</target>
        </trans-unit>
        <trans-unit id="438255e8d8df7e6af7b2286b9eb0a1ff8f4ea247" translate="yes" xml:space="preserve">
          <source>It produces something like this:</source>
          <target state="translated">它产生的东西是这样的。</target>
        </trans-unit>
        <trans-unit id="fb781104064af1d8629d3a388a507c72839c91db" translate="yes" xml:space="preserve">
          <source>It produces the following output (maybe in different order):</source>
          <target state="translated">它产生以下输出(可能顺序不同)。</target>
        </trans-unit>
        <trans-unit id="c9f7c3047939db3a0d1c9e3a0026fbe61df824db" translate="yes" xml:space="preserve">
          <source>It produces the following output:</source>
          <target state="translated">它产生以下输出:</target>
        </trans-unit>
        <trans-unit id="17589c30d4bd3d4e252acd3e2fde1d3c719a5224" translate="yes" xml:space="preserve">
          <source>It returns a composition of two functions passed to it: &lt;code&gt;compose(f, g) = f(g(*))&lt;/code&gt;. Now, you can apply it to callable references:</source>
          <target state="translated">它返回传递给它的两个函数的组合： &lt;code&gt;compose(f, g) = f(g(*))&lt;/code&gt; 。现在，您可以将其应用于可调用引用：</target>
        </trans-unit>
        <trans-unit id="ed5dfacacd6fed6df8733c434a43165786f1b136" translate="yes" xml:space="preserve">
          <source>It simplifies code generation, for example, for object initializers. The last element can also have a comma.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="adaa459203490bc09b0dd6700bcf5aacd3687f3b" translate="yes" xml:space="preserve">
          <source>It takes two &lt;code&gt;Int&lt;/code&gt; parameters and returns a &lt;code&gt;Double&lt;/code&gt;, so its type is &lt;code&gt;(Int, Int) -&amp;gt; Double&lt;/code&gt;. We can reference the function itself by prefixing its name with &lt;code&gt;::&lt;/code&gt;, and we can assign it to a variable (whose type would normally be inferred, but we show the type signature for demonstration):</source>
          <target state="translated">它带有两个 &lt;code&gt;Int&lt;/code&gt; 参数并返回 &lt;code&gt;Double&lt;/code&gt; ，因此其类型为 &lt;code&gt;(Int, Int) -&amp;gt; Double&lt;/code&gt; 。我们可以通过在函数名称前加上 &lt;code&gt;::&lt;/code&gt; 来引用函数本身，并且可以将其分配给变量（通常会推断出其类型，但我们将演示类型签名）：</target>
        </trans-unit>
        <trans-unit id="c85187abd273afe2d39456db809770ff8d17b7cc" translate="yes" xml:space="preserve">
          <source>It will produce a platform-specific shared object (.so on Linux, .dylib on macOS, and .dll on Windows targets) and a C language header, allowing the use of all public APIs available in your Kotlin/Native program from C/C++ code. See &lt;code&gt;samples/python_extension&lt;/code&gt; for an example of using such a shared object to provide a bridge between Python and Kotlin/Native.</source>
          <target state="translated">它将产生特定于平台的共享对象（在Linux上为.so，在macOS上为.dylib，在Windows目标上为.dll）和C语言标头，从而允许使用C /中Kotlin / Native程序中可用的所有公共API。 C ++代码。有关使用此类共享库在Python和Kotlin / Native之间架起桥梁的示例，请参见 &lt;code&gt;samples/python_extension&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9b575c19d946e336100c7ed068ca562177833082" translate="yes" xml:space="preserve">
          <source>It will produce a platform-specific static object (.a library format) and a C language header, allowing you to use all the public APIs available in your Kotlin/Native program from C/C++ code.</source>
          <target state="translated">它将产生一个平台特定的静态对象(.a库格式)和一个C语言头,允许你从C/C++代码中使用Kotlin/Native程序中所有可用的公共API。</target>
        </trans-unit>
        <trans-unit id="c77b95136e56addaaf94d730513b3a8bef6e57a3" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s almost done, user feedback is especially important now.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="039acb422f298b9e2dda428662093ea454940860" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s done. We will be evolving it according to our strict &lt;a href=&quot;https://kotlinlang.org/foundation/language-committee-guidelines.html&quot;&gt;backward compatibility rules&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3d38eb85ce2f60386c4898b42f31b426d1bea2f" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s easy to get started with Kotlin using the Kotlin plugin integrated in &lt;a href=&quot;https://www.jetbrains.com/idea/&quot;&gt;IntelliJ IDEA&lt;/a&gt;. Benefit from code highlighting, code completion, refactoring, debugging, and other features available for Kotlin.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d20f5ce9372886e3a18510e89bf62db3fa25cfc" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s extremely easy to start using Kotlin for Android development. In this tutorial we&amp;rsquo;ll follow the warming up process with Android Studio. If you're using Intellij IDEA with Android, the process is almost the same.</source>
          <target state="translated">开始使用Kotlin进行Android开发非常容易。在本教程中，我们将遵循Android Studio的预热过程。如果您在Android上使用Intellij IDEA，则过程几乎相同。</target>
        </trans-unit>
        <trans-unit id="0d25598a290d255bee23e0efee2aa27e246b4f17" translate="yes" xml:space="preserve">
          <source>It's allowed to pass the same array in the &lt;a href=&quot;copy-into#kotlin.collections%24copyInto%28kotlin.Array%28%28kotlin.collections.copyInto.T%29%29%2C+kotlin.Array%28%28kotlin.collections.copyInto.T%29%29%2C+kotlin.Int%2C+kotlin.Int%2C+kotlin.Int%29%2Fdestination&quot;&gt;destination&lt;/a&gt; and even specify the subrange so that it overlaps with the destination range.</source>
          <target state="translated">允许在&lt;a href=&quot;copy-into#kotlin.collections%24copyInto%28kotlin.Array%28%28kotlin.collections.copyInto.T%29%29%2C+kotlin.Array%28%28kotlin.collections.copyInto.T%29%29%2C+kotlin.Int%2C+kotlin.Int%2C+kotlin.Int%29%2Fdestination&quot;&gt;目标中&lt;/a&gt;传递相同的数组，甚至可以指定子范围，使其与目标范围重叠。</target>
        </trans-unit>
        <trans-unit id="ccc637fca146e7aa9091977f4ab6a14a8ec874b0" translate="yes" xml:space="preserve">
          <source>It's allowed to pass the same array in the &lt;a href=&quot;copy-into#kotlin.collections%24copyInto%28kotlin.UIntArray%2C+kotlin.UIntArray%2C+kotlin.Int%2C+kotlin.Int%2C+kotlin.Int%29%2Fdestination&quot;&gt;destination&lt;/a&gt; and even specify the subrange so that it overlaps with the destination range.</source>
          <target state="translated">允许在&lt;a href=&quot;copy-into#kotlin.collections%24copyInto%28kotlin.UIntArray%2C+kotlin.UIntArray%2C+kotlin.Int%2C+kotlin.Int%2C+kotlin.Int%29%2Fdestination&quot;&gt;目标中&lt;/a&gt;传递相同的数组，甚至可以指定子范围，使其与目标范围重叠。</target>
        </trans-unit>
        <trans-unit id="c547761ff928eabb85ae6f68b2a8d06acf2434c8" translate="yes" xml:space="preserve">
          <source>It's allowed to pass the same array in the &lt;a href=&quot;copy-into#kotlin.collections%24copyInto(kotlin.Array((kotlin.collections.copyInto.T)),%20kotlin.Array((kotlin.collections.copyInto.T)),%20kotlin.Int,%20kotlin.Int,%20kotlin.Int)/destination&quot;&gt;destination&lt;/a&gt; and even specify the subrange so that it overlaps with the destination range.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0234d9c081afa271a5761a94d33278199b8154d0" translate="yes" xml:space="preserve">
          <source>It's allowed to pass the same array in the &lt;a href=&quot;copy-into#kotlin.collections%24copyInto(kotlin.UIntArray,%20kotlin.UIntArray,%20kotlin.Int,%20kotlin.Int,%20kotlin.Int)/destination&quot;&gt;destination&lt;/a&gt; and even specify the subrange so that it overlaps with the destination range.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="031250b72b284d8b276f90bf0d49fd6078c2857d" translate="yes" xml:space="preserve">
          <source>It's always possible to explicitly set the IntelliJ IDEA code style as the correct code style for the project. To do so please switch to the &lt;em&gt;Project&lt;/em&gt; scheme in &lt;code&gt;Settings &amp;rarr; Editor &amp;rarr; Code Style &amp;rarr; Kotlin&lt;/code&gt; and select &lt;em&gt;&quot;Kotlin obsolete IntelliJ IDEA codestyle&quot;&lt;/em&gt; in the &lt;em&gt;&quot;Use defaults from:&quot;&lt;/em&gt; on the &lt;em&gt;Load&lt;/em&gt; tab.</source>
          <target state="translated">始终可以将IntelliJ IDEA代码样式显式设置为项目的正确代码样式。为此，请在 &lt;code&gt;Settings &amp;rarr; Editor &amp;rarr; Code Style &amp;rarr; Kotlin&lt;/code&gt; &lt;em&gt;&amp;ldquo; Kotlin&amp;rdquo;&lt;/em&gt;中切换到&amp;ldquo; &lt;em&gt;项目&amp;rdquo;&lt;/em&gt;方案，&lt;em&gt;然后&lt;/em&gt;在&lt;em&gt;&amp;ldquo; &lt;/em&gt;&lt;em&gt;加载&amp;rdquo;&lt;/em&gt;选项卡上的&lt;em&gt;&amp;ldquo;使用默认来源：&amp;rdquo;中&lt;/em&gt;选择&lt;em&gt;&amp;ldquo; Kotlin过时的IntelliJ IDEA &lt;/em&gt;代码样式&lt;em&gt;&amp;rdquo;&lt;/em&gt;。&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6e80a1e74b8c8e47694ccc45eb2685d70fcb822d" translate="yes" xml:space="preserve">
          <source>It's currently not possible to pass &lt;em&gt;null&lt;/em&gt; to a method that is declared as varargs.</source>
          <target state="translated">当前无法将&lt;em&gt;null&lt;/em&gt;传递给声明为varargs的方法。</target>
        </trans-unit>
        <trans-unit id="114b9bcaf449cf9b870e05fba48add6ecc248f08" translate="yes" xml:space="preserve">
          <source>It's easy to forget to set the corresponding context element. The thread-local variable accessed from the coroutine may then have an unexpected value, if the thread running the coroutine is different. To avoid such situations, it is recommended to use the &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/java.lang.-thread-local/ensure-present.html&quot;&gt;ensurePresent&lt;/a&gt; method and fail-fast on improper usages.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="acfee84980c04ef0fe85e54f28d399f66e64abaa" translate="yes" xml:space="preserve">
          <source>It's fine to inherit from both &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt;, and we have no problems with &lt;code&gt;a()&lt;/code&gt; and &lt;code&gt;b()&lt;/code&gt; since &lt;code&gt;C&lt;/code&gt; inherits only one implementation of each of these functions. But for &lt;code&gt;f()&lt;/code&gt; we have two implementations inherited by &lt;code&gt;C&lt;/code&gt;, and thus we have to override &lt;code&gt;f()&lt;/code&gt; in &lt;code&gt;C&lt;/code&gt; and provide our own implementation that eliminates the ambiguity.</source>
          <target state="translated">从 &lt;code&gt;A&lt;/code&gt; 和 &lt;code&gt;B&lt;/code&gt; 继承都可以，并且 &lt;code&gt;a()&lt;/code&gt; 和 &lt;code&gt;b()&lt;/code&gt; 没有问题，因为 &lt;code&gt;C&lt;/code&gt; 仅继承了每个函数的一个实现。但是对于 &lt;code&gt;f()&lt;/code&gt; 我们有两个 &lt;code&gt;C&lt;/code&gt; 继承的实现，因此我们必须在 &lt;code&gt;C&lt;/code&gt; 中重写 &lt;code&gt;f()&lt;/code&gt; 并提供我们自己的实现以消除歧义。</target>
        </trans-unit>
        <trans-unit id="04f1d0f6695973692315398bd64dee5cfdd7323c" translate="yes" xml:space="preserve">
          <source>It's fine to inherit from both &lt;code&gt;Rectangle&lt;/code&gt; and &lt;code&gt;Polygon&lt;/code&gt;, but both of them have their implementations of &lt;code&gt;draw()&lt;/code&gt;, so we have to override &lt;code&gt;draw()&lt;/code&gt; in &lt;code&gt;Square&lt;/code&gt; and provide its own implementation that eliminates the ambiguity.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="442e1f9409803560cb8db1e8e932691b852b50ed" translate="yes" xml:space="preserve">
          <source>It's important to close a stream when you're done with it; otherwise, your program will leak a file handle. See the next section for how do do this nicely.</source>
          <target state="translated">当你完成一个流时,关闭它是很重要的;否则,你的程序会泄漏一个文件句柄。请参阅下一节,了解如何很好地做到这一点。</target>
        </trans-unit>
        <trans-unit id="9346c60b395e4bb0937fa0abc8c38e87d658e069" translate="yes" xml:space="preserve">
          <source>It's important to make sure that the &lt;em&gt;Include Kotlin support&lt;/em&gt; checkbox is ticked. For now we can leave the default settings in the next step of the wizard. We then proceed to select the &lt;em&gt;Empty Activity&lt;/em&gt; option and click &lt;em&gt;Next&lt;/em&gt;, finally pressing &lt;em&gt;Finish&lt;/em&gt;.</source>
          <target state="translated">确保选中&amp;ldquo; &lt;em&gt;包括Kotlin支持&amp;rdquo;&lt;/em&gt;复选框很重要。现在，我们可以在向导的下一步中保留默认设置。然后，我们继续选择&lt;em&gt;清空活动&lt;/em&gt;选项，然后单击&lt;em&gt;下一步&lt;/em&gt;，最后按&lt;em&gt;完成&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="3f80b2897a86bf69ce94fa9c91efda88ddaabb97" translate="yes" xml:space="preserve">
          <source>It's important to understand that this is now a native application, and no runtime or virtual machine is required. We can now run the compiled binary from the console:</source>
          <target state="translated">重要的是要明白,现在这是一个本地应用程序,不需要运行时或虚拟机。我们现在可以从控制台运行编译后的二进制文件。</target>
        </trans-unit>
        <trans-unit id="841256700fec240b48d1a1475f562513e2734121" translate="yes" xml:space="preserve">
          <source>It's not recommended that you apply Kotlin plugins with &lt;code&gt;apply&lt;/code&gt; in Gradle Kotlin DSL &amp;ndash; &lt;a href=&quot;#using-gradle-kotlin-dsl&quot;&gt;see why&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="451aaccdf6c2eb6d6c44303ffdea63bce2a3d7a2" translate="yes" xml:space="preserve">
          <source>It's not recommended to apply Kotlin plugins with &lt;code&gt;apply&lt;/code&gt; in Gradle Kotlin DSL. The details are provided &lt;a href=&quot;#using-gradle-kotlin-dsl&quot;&gt;below&lt;/a&gt;.</source>
          <target state="translated">它不建议与申请科特林插件 &lt;code&gt;apply&lt;/code&gt; 于摇篮科特林DSL。&lt;a href=&quot;#using-gradle-kotlin-dsl&quot;&gt;下面&lt;/a&gt;提供了详细信息。</target>
        </trans-unit>
        <trans-unit id="903ee30ab34cc6304b069dd5e5dba6a6e65093d1" translate="yes" xml:space="preserve">
          <source>It's often the case that we need to copy an object altering &lt;em&gt;some&lt;/em&gt; of its properties, but keeping the rest unchanged. This is what &lt;code&gt;copy()&lt;/code&gt; function is generated for. For the &lt;code&gt;User&lt;/code&gt; class above, its implementation would be as follows:</source>
          <target state="translated">通常，我们需要复制一个对象以更改其&lt;em&gt;某些&lt;/em&gt;属性，但保持其余部分不变。这就是生成 &lt;code&gt;copy()&lt;/code&gt; 函数的目的。对于上面的 &lt;code&gt;User&lt;/code&gt; 类，其实现如下：</target>
        </trans-unit>
        <trans-unit id="f5bc060842af3a7b6e0d01c24d0becf2bb7a201f" translate="yes" xml:space="preserve">
          <source>It's possible to declare a cinterop dependency for a component:</source>
          <target state="translated">可以为一个组件声明一个cinterop依赖关系。</target>
        </trans-unit>
        <trans-unit id="2884706f64f3c6fe7682c1d6d6493a0cd7c7c71d" translate="yes" xml:space="preserve">
          <source>It's possible to depend on a Kotlin/Native library published earlier in a maven repo. The plugin relies on Gradle's &lt;a href=&quot;https://github.com/gradle/gradle/blob/master/subprojects/docs/src/docs/design/gradle-module-metadata-specification.md&quot;&gt;metadata&lt;/a&gt; support so the corresponding feature must be enabled. Add the following line in your &lt;code&gt;settings.gradle&lt;/code&gt;:</source>
          <target state="translated">可能依赖于先前在Maven存储库中发布的Kotlin / Native库。该插件依赖Gradle的&lt;a href=&quot;https://github.com/gradle/gradle/blob/master/subprojects/docs/src/docs/design/gradle-module-metadata-specification.md&quot;&gt;元数据&lt;/a&gt;支持，因此必须启用相应的功能。在 &lt;code&gt;settings.gradle&lt;/code&gt; 中添加以下行：</target>
        </trans-unit>
        <trans-unit id="c597ff748c96d1169a0e3b1f389a9e5bf8a14509" translate="yes" xml:space="preserve">
          <source>It's recommended that you use Android Studio for creating Android applications. &lt;a href=&quot;https://developer.android.com/studio/releases/gradle-plugin&quot;&gt;Learn how to use Android Gradle plugin&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="268bb3f4ba30e1a5b60f8f81ac29d4c03ccdf710" translate="yes" xml:space="preserve">
          <source>It's recommended to propagate the experimental status to the API that depends on unsigned types by annotating it with this annotation.</source>
          <target state="translated">建议用这个注解将实验状态传播到依赖于无符号类型的API上。</target>
        </trans-unit>
        <trans-unit id="d7daa3cad985a04d515f5a0b14e8155b1a6fab3e" translate="yes" xml:space="preserve">
          <source>It's up to you to decide if your clients have to explicitly opt-in into usage of your API, but bear in mind that unsigned types are an experimental feature, so API which uses them can be suddenly broken due to changes in language.</source>
          <target state="translated">你可以决定你的客户是否必须明确地选择使用你的API,但是请记住,无符号类型是一个实验性的功能,所以使用它们的API可能会因为语言的变化而突然中断。</target>
        </trans-unit>
        <trans-unit id="da8e68f5b23a3014c6d8de49b6e15eb047b18c62" translate="yes" xml:space="preserve">
          <source>It's up to you to decide if your clients have to explicitly opt-in into usage of your API, but bear in mind that unsigned types are not a stable feature, so API which uses them can be broken by changes in the language.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9fa67b0c21d7b8170095650619f367328af7593f" translate="yes" xml:space="preserve">
          <source>It's useful to shorten long generic types. For instance, it's often tempting to shrink collection types:</source>
          <target state="translated">缩短长的通用类型是很有用的。例如,我们经常想缩短集合类型。</target>
        </trans-unit>
        <trans-unit id="d50dbfd39b435235eb76a4c86249fda694136067" translate="yes" xml:space="preserve">
          <source>It's very common that a lambda expression has only one parameter.</source>
          <target state="translated">一个lambda表达式只有一个参数是很常见的。</target>
        </trans-unit>
        <trans-unit id="497cb9444d2d1993508a971a9e38bf60f29788e9" translate="yes" xml:space="preserve">
          <source>ItemArrayLike</source>
          <target state="translated">ItemArrayLike</target>
        </trans-unit>
        <trans-unit id="08ca6a3da933ca6826a2f4d3fcc919af71d7e380" translate="yes" xml:space="preserve">
          <source>Iterable</source>
          <target state="translated">Iterable</target>
        </trans-unit>
        <trans-unit id="dc8802d44941c46da0da729594bb50e6d441ce2d" translate="yes" xml:space="preserve">
          <source>Iterable.groupingBy</source>
          <target state="translated">Iterable.groupingBy</target>
        </trans-unit>
        <trans-unit id="380a211ab0a9e218f328f8421df21a0f64a31d3e" translate="yes" xml:space="preserve">
          <source>Iterates through each line of this reader, calls &lt;a href=&quot;for-each-line#kotlin.io%24forEachLine%28java.io.Reader%2C+kotlin.Function1%28%28kotlin.String%2C+kotlin.Unit%29%29%29%2Faction&quot;&gt;action&lt;/a&gt; for each line read and closes the &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/io/Reader.html&quot;&gt;Reader&lt;/a&gt; when it's completed.</source>
          <target state="translated">遍历此读取器的每一行，为读取的每一行调用&lt;a href=&quot;for-each-line#kotlin.io%24forEachLine%28java.io.Reader%2C+kotlin.Function1%28%28kotlin.String%2C+kotlin.Unit%29%29%29%2Faction&quot;&gt;操作&lt;/a&gt;，并在&lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/io/Reader.html&quot;&gt;读取器&lt;/a&gt;完成时关闭它。</target>
        </trans-unit>
        <trans-unit id="a23c7a347a61820ec903389403c010444ab83c86" translate="yes" xml:space="preserve">
          <source>Iterates through each line of this reader, calls &lt;a href=&quot;for-each-line#kotlin.io%24forEachLine(java.io.Reader,%20kotlin.Function1((kotlin.String,%20kotlin.Unit)))/action&quot;&gt;action&lt;/a&gt; for each line read and closes the &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/io/Reader.html&quot;&gt;Reader&lt;/a&gt; when it's completed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df79ba3f92580a38aac3b295d97ec6467bf9c601" translate="yes" xml:space="preserve">
          <source>Iterating over a collection:</source>
          <target state="translated">在一个集合上迭代。</target>
        </trans-unit>
        <trans-unit id="cd542426f011094d421bd238597459f01a78a773" translate="yes" xml:space="preserve">
          <source>Iterating over a range:</source>
          <target state="translated">在一个范围内迭代。</target>
        </trans-unit>
        <trans-unit id="bae8809b2429231a50c28ba87cecc038aac88855" translate="yes" xml:space="preserve">
          <source>Iterator</source>
          <target state="translated">Iterator</target>
        </trans-unit>
        <trans-unit id="003d5d89ff75536e7c8fe75998f6c431dc6a6bfb" translate="yes" xml:space="preserve">
          <source>Iterator for characters of the given char sequence.</source>
          <target state="translated">字符序列的迭代器。</target>
        </trans-unit>
        <trans-unit id="909a5f0dfd8c3a4ef79cd1458e2b5fb136ad7fae" translate="yes" xml:space="preserve">
          <source>Iterators</source>
          <target state="translated">Iterators</target>
        </trans-unit>
        <trans-unit id="506c9ecd5cb52c951984866e4ca884bba6f6ea5f" translate="yes" xml:space="preserve">
          <source>Iterators can be obtained for inheritors of the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-iterable/index&quot;&gt;&lt;code&gt;Iterable&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; interface, including &lt;code&gt;Set&lt;/code&gt; and &lt;code&gt;List&lt;/code&gt;, by calling the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-iterable/iterator&quot;&gt;&lt;code&gt;iterator()&lt;/code&gt;&lt;/a&gt; function. Once you obtain an iterator, it points to the first element of a collection; calling the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-iterator/next&quot;&gt;&lt;code&gt;next()&lt;/code&gt;&lt;/a&gt; function returns this element and moves the iterator position to the following element if it exists. Once the iterator passes through the last element, it can no longer be used for retrieving elements; neither can it be reset to any previous position. To iterate through the collection again, create a new iterator.</source>
          <target state="translated">可以通过调用&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-iterable/iterator&quot;&gt; &lt;code&gt;iterator()&lt;/code&gt; &lt;/a&gt;函数来为&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-iterable/index&quot;&gt; &lt;code&gt;Iterable&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt;接口的继承者（包括 &lt;code&gt;Set&lt;/code&gt; 和 &lt;code&gt;List&lt;/code&gt; ）获取迭代器。获得迭代器后，它指向集合的第一个元素；调用&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-iterator/next&quot;&gt; &lt;code&gt;next()&lt;/code&gt; &lt;/a&gt;函数将返回此元素，并将迭代器位置移动到以下元素（如果存在）。一旦迭代器通过了最后一个元素，它就不能再用于检索元素。也无法将其重置到任何以前的位置。要再次遍历集合，请创建一个新的迭代器。</target>
        </trans-unit>
        <trans-unit id="bc0b40497b63bea004394bd2f67e443f08b6588f" translate="yes" xml:space="preserve">
          <source>JAR file for the Android project, from the &lt;code&gt;androidMain&lt;/code&gt; source set</source>
          <target state="translated">来自 &lt;code&gt;androidMain&lt;/code&gt; 源集的Android项目的JAR文件</target>
        </trans-unit>
        <trans-unit id="1c094e3ab7a1c494d642222b6728398ff3000b42" translate="yes" xml:space="preserve">
          <source>JPA support</source>
          <target state="translated">JPA支持</target>
        </trans-unit>
        <trans-unit id="95f92b2f0cb530542d16d90a6c2af59e20759430" translate="yes" xml:space="preserve">
          <source>JS</source>
          <target state="translated">JS</target>
        </trans-unit>
        <trans-unit id="2ef44ba04cb41365765eba178e5fb528ee006a1b" translate="yes" xml:space="preserve">
          <source>JS:</source>
          <target state="translated">JS:</target>
        </trans-unit>
        <trans-unit id="031a4e76f0b39d0df073d934da5fc48da8d737e5" translate="yes" xml:space="preserve">
          <source>JSON</source>
          <target state="translated">JSON</target>
        </trans-unit>
        <trans-unit id="8262ef9c2c68924dbec9b88761bde41ad5ef98f3" translate="yes" xml:space="preserve">
          <source>JSR-305 (&lt;code&gt;javax.annotation&lt;/code&gt;, more details below)</source>
          <target state="translated">JSR-305（ &lt;code&gt;javax.annotation&lt;/code&gt; ，更多详细信息在下面）</target>
        </trans-unit>
        <trans-unit id="5188151af5277b4d83b75fa70a7e55c37a18f211" translate="yes" xml:space="preserve">
          <source>JSR-305 Support</source>
          <target state="translated">JSR-305支持</target>
        </trans-unit>
        <trans-unit id="bb63c86538bf1c2ee7cd6190cf88dd1f44d85eff" translate="yes" xml:space="preserve">
          <source>JVM</source>
          <target state="translated">JVM</target>
        </trans-unit>
        <trans-unit id="04a7d3f3683303c17ad132f382f6d0c911d30883" translate="yes" xml:space="preserve">
          <source>JVM 6</source>
          <target state="translated">JVM 6</target>
        </trans-unit>
        <trans-unit id="3430f69443094c1010f905be31e657db1bc9cecc" translate="yes" xml:space="preserve">
          <source>JVM Backend</source>
          <target state="translated">JVM后端</target>
        </trans-unit>
        <trans-unit id="8a60d58cc6c328ec0b68627b45e8de68d5004fb4" translate="yes" xml:space="preserve">
          <source>JVM backend</source>
          <target state="translated">JVM后端</target>
        </trans-unit>
        <trans-unit id="e314b08890e867b0e66c9aacb3731e2c760fd4e5" translate="yes" xml:space="preserve">
          <source>JVM dependency</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e479037f37f3056da4dd3f4b8476891324342ba" translate="yes" xml:space="preserve">
          <source>JVM:</source>
          <target state="translated">JVM:</target>
        </trans-unit>
        <trans-unit id="4aa2729d3292a207da300462e1c7fb9e07fee8d1" translate="yes" xml:space="preserve">
          <source>Jar file</source>
          <target state="translated">Jar文件</target>
        </trans-unit>
        <trans-unit id="c32dbe67bb4cda6c969b9b214ff6e46a25b2a0f2" translate="yes" xml:space="preserve">
          <source>Java 7's try with resources</source>
          <target state="translated">Java 7对资源的尝试</target>
        </trans-unit>
        <trans-unit id="ac187b2b88eb97c8a6d1b499783f3187c6ec8c0b" translate="yes" xml:space="preserve">
          <source>Java 8 bytecode support</source>
          <target state="translated">支持Java 8字节码</target>
        </trans-unit>
        <trans-unit id="072e6f9a3196506ae761b516738d856e34828cc7" translate="yes" xml:space="preserve">
          <source>Java 8 standard library support</source>
          <target state="translated">支持Java 8标准库</target>
        </trans-unit>
        <trans-unit id="01579d0353cd60180076cc09ff0d55781e923e55" translate="yes" xml:space="preserve">
          <source>Java Annotations</source>
          <target state="translated">Java注释</target>
        </trans-unit>
        <trans-unit id="d04e5ac8f8fe9912f7302d2d4689867b318a2094" translate="yes" xml:space="preserve">
          <source>Java Arrays</source>
          <target state="translated">Java数组</target>
        </trans-unit>
        <trans-unit id="860970d26c3938762fa2e2c7b7194b61a0231169" translate="yes" xml:space="preserve">
          <source>Java EE Http servlets can be used from Kotlin much like any other Java library or framework. We'll see how to make a simple controller that returns &quot;Hello, World!&quot;.</source>
          <target state="translated">Java EE Http servlets可以从Kotlin中使用,就像其他Java库或框架一样。我们将看到如何制作一个简单的控制器,返回 &quot;Hello,World!&quot;。</target>
        </trans-unit>
        <trans-unit id="98c55e3f9693daef863846ba04beb7a87639d58b" translate="yes" xml:space="preserve">
          <source>Java Interoperability</source>
          <target state="translated">Java互操作性</target>
        </trans-unit>
        <trans-unit id="ab55871eec7aba9e50581782c94506d7b076be92" translate="yes" xml:space="preserve">
          <source>Java Reflection</source>
          <target state="translated">Java 反射</target>
        </trans-unit>
        <trans-unit id="8b7c04d9bb7da5a0513e73469be371a892a0ddec" translate="yes" xml:space="preserve">
          <source>Java Support in JVM Targets</source>
          <target state="translated">JVM目标中的Java支持</target>
        </trans-unit>
        <trans-unit id="027f8a4631110b77b693f662b6d14564e95f3ad5" translate="yes" xml:space="preserve">
          <source>Java Varargs</source>
          <target state="translated">Java Varargs</target>
        </trans-unit>
        <trans-unit id="746c982d879f15c37e1edb8014f7e0a7a57db534" translate="yes" xml:space="preserve">
          <source>Java annotations are 100% compatible with Kotlin:</source>
          <target state="translated">Java注释与Kotlin 100%兼容。</target>
        </trans-unit>
        <trans-unit id="85a2157de6f31be86d225df11c21c07e4164424b" translate="yes" xml:space="preserve">
          <source>Java classes sometimes use a method declaration for the indices with a variable number of arguments (varargs):</source>
          <target state="translated">Java类有时会使用一个方法声明来表示具有可变参数数(varargs)的索引。</target>
        </trans-unit>
        <trans-unit id="695cb4693d8f07873088e0e2ca1954a3e6b1dec0" translate="yes" xml:space="preserve">
          <source>Java compiler options</source>
          <target state="translated">Java编译器选项</target>
        </trans-unit>
        <trans-unit id="53d9a40a89e185b3910817fb0920db3433576443" translate="yes" xml:space="preserve">
          <source>Java generics in Kotlin</source>
          <target state="translated">Kotlin中的Java泛型</target>
        </trans-unit>
        <trans-unit id="8de44c9537e6dbc55b9f15952d2d0c0a403f924d" translate="yes" xml:space="preserve">
          <source>Java interoperation:</source>
          <target state="translated">Java互操作。</target>
        </trans-unit>
        <trans-unit id="e832e4cfea4d9817c729a744a89f9449a5f1d1ee" translate="yes" xml:space="preserve">
          <source>Java only got support for function types and lambda expressions a few years ago. Previously, Java worked around this by using an interface to define a function signature and allowing an inline, anonymous definition of a class that implements the interface. This is also available in Kotlin, partly for compatibility with Java libraries and partly because it can be handy for specifying event handlers (in particular if there is more than one event type that must be listened for by the same listener object). Consider an interface or a (possibly abstract) class, as well a function that takes an instance of it:</source>
          <target state="translated">Java在几年前才开始支持函数类型和lambda表达式。此前,Java通过使用一个接口来定义函数签名,并允许内联、匿名定义一个实现该接口的类来解决这个问题。这在Kotlin中也是可用的,部分原因是为了与Java库兼容,部分原因是它可以方便地指定事件处理程序(特别是当有多个事件类型必须由同一个监听器对象监听时)。考虑一个接口或一个(可能是抽象的)类,以及一个接受它的实例的函数。</target>
        </trans-unit>
        <trans-unit id="1915d97968b458264a2f2dbd19e10237488a0c18" translate="yes" xml:space="preserve">
          <source>Java reflection works on Kotlin classes and vice versa. As mentioned above, you can use &lt;code&gt;instance::class.java&lt;/code&gt;, &lt;code&gt;ClassName::class.java&lt;/code&gt; or &lt;code&gt;instance.javaClass&lt;/code&gt; to enter Java reflection through &lt;code&gt;java.lang.Class&lt;/code&gt;.</source>
          <target state="translated">Java反射适用于Kotlin类，反之亦然。如上所述，您可以使用 &lt;code&gt;instance::class.java&lt;/code&gt; ， &lt;code&gt;ClassName::class.java&lt;/code&gt; 或 &lt;code&gt;instance.javaClass&lt;/code&gt; 通过 &lt;code&gt;java.lang.Class&lt;/code&gt; 输入Java反射。</target>
        </trans-unit>
        <trans-unit id="ef56a24f4d8f2d665c8315a53a8f2125506c9068" translate="yes" xml:space="preserve">
          <source>Java reflection works on Kotlin classes and vice versa. As mentioned above, you can use &lt;code&gt;instance::class.java&lt;/code&gt;, &lt;code&gt;ClassName::class.java&lt;/code&gt; or &lt;code&gt;instance.javaClass&lt;/code&gt; to enter Java reflection through &lt;code&gt;java.lang.Class&lt;/code&gt;. You may also use &lt;code&gt;ClassName::class.javaObjectType&lt;/code&gt; for getting primitive types wrappers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="604557100ea734a8e508b4cfcd3fd0b6ae0fffe3" translate="yes" xml:space="preserve">
          <source>Java types which have nullability annotations are represented not as platform types, but as actual nullable or non-null Kotlin types. The compiler supports several flavors of nullability annotations, including:</source>
          <target state="translated">具有可空性注解的Java类型不是作为平台类型来表示,而是作为实际的可空或非空的Kotlin类型来表示。编译器支持几种类型的可空性注解,包括:</target>
        </trans-unit>
        <trans-unit id="dc024086aaa20e53d67ca09758f8c4d13c64cb3c" translate="yes" xml:space="preserve">
          <source>Java's arrays are mapped as mentioned &lt;a href=&quot;java-interop#java-arrays&quot;&gt;below&lt;/a&gt;:</source>
          <target state="translated">Java的数组映射为提到&lt;a href=&quot;java-interop#java-arrays&quot;&gt;如下&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="a52c0cfe5cac6860cf184e57dfda94c4e4aab7eb" translate="yes" xml:space="preserve">
          <source>Java's boxed primitive types are mapped to nullable Kotlin types:</source>
          <target state="translated">Java的盒式基元类型被映射为可空的Kotlin类型。</target>
        </trans-unit>
        <trans-unit id="a93aa77d99dfed9f4e64393e47b4458e7232bba4" translate="yes" xml:space="preserve">
          <source>Java's raw types are converted into star projections,</source>
          <target state="translated">Java的原始类型被转换为星形投影。</target>
        </trans-unit>
        <trans-unit id="4b08bd53dd6ccc40659e0ead9c100bf1e91b5ac6" translate="yes" xml:space="preserve">
          <source>Java's wildcards are converted into type projections,</source>
          <target state="translated">Java的通配符被转换为类型投影。</target>
        </trans-unit>
        <trans-unit id="b7e0008cfda3632a9ce80870d8378b5ff1ce2de5" translate="yes" xml:space="preserve">
          <source>Java-default method calls</source>
          <target state="translated">Java默认方法调用</target>
        </trans-unit>
        <trans-unit id="28658a9e65ac1fce8b895da9099268ad9257b5a4" translate="yes" xml:space="preserve">
          <source>Java-style reflection</source>
          <target state="translated">Java风格的反射</target>
        </trans-unit>
        <trans-unit id="d3d2902f267714c4d2888df7a9cb53494548b955" translate="yes" xml:space="preserve">
          <source>Java2Kotlin converter</source>
          <target state="translated">Java2Kotlin转换器</target>
        </trans-unit>
        <trans-unit id="ee620923ff5fc510555dc37083a135ee93b5404b" translate="yes" xml:space="preserve">
          <source>JavaScript</source>
          <target state="translated">JavaScript</target>
        </trans-unit>
        <trans-unit id="cb598ee02a2a4ba66a8b8c49bee0bba3cd995db7" translate="yes" xml:space="preserve">
          <source>JavaScript Backend</source>
          <target state="translated">JavaScript后端</target>
        </trans-unit>
        <trans-unit id="7ceba75ee976f8baf2462d625f66425dd948bcef" translate="yes" xml:space="preserve">
          <source>JavaScript DCE</source>
          <target state="translated">JavaScript DCE</target>
        </trans-unit>
        <trans-unit id="1731268deeec6a5538ea96e67d2bad77e86644c6" translate="yes" xml:space="preserve">
          <source>JavaScript Dead Code Elimination (DCE)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3f888694954b41c7c2070331437408d8501d710" translate="yes" xml:space="preserve">
          <source>JavaScript Modules</source>
          <target state="translated">JavaScript模块</target>
        </trans-unit>
        <trans-unit id="8c784f817b830f35e8d38eb1b5afb3d6e6b36d02" translate="yes" xml:space="preserve">
          <source>JavaScript Reflection</source>
          <target state="translated">JavaScript反思</target>
        </trans-unit>
        <trans-unit id="6427edfd3be2acf2cb18120ef89fe67414e7fe92" translate="yes" xml:space="preserve">
          <source>JavaScript backend</source>
          <target state="translated">JavaScript后端</target>
        </trans-unit>
        <trans-unit id="21bc6187f833ae0234195b5bb7f032fa9c9eddf3" translate="yes" xml:space="preserve">
          <source>JavaScript backend now generates more statically checkable code, which is friendlier to JS code processing tools, like minifiers, optimisers, linters, etc.</source>
          <target state="translated">现在JavaScript后台生成的代码更多的是可静态检查的,这对JS代码处理工具更友好,如minifiers、优化器、linters等。</target>
        </trans-unit>
        <trans-unit id="18040e1d6c0077c2a62cb7d49ff581501d95859d" translate="yes" xml:space="preserve">
          <source>JavaScript does not have concept of packages (namespaces). They are usually emulated by nested objects. The compiler turns references to &lt;code&gt;external&lt;/code&gt; declarations either to plain unprefixed names (in case of &lt;em&gt;plain&lt;/em&gt; modules) or to plain imports. However, if a JavaScript library provides its declarations in packages, you won't be satisfied with this. You can tell the compiler to generate additional prefix before references to &lt;code&gt;external&lt;/code&gt; declarations using the &lt;code&gt;@JsQualifier(...)&lt;/code&gt; annotation.</source>
          <target state="translated">JavaScript没有包（命名空间）的概念。它们通常由嵌套对象模拟。编译器将对 &lt;code&gt;external&lt;/code&gt; 声明的引用转换为纯无前缀名称（如果使用&lt;em&gt;纯&lt;/em&gt;模块）或纯导入。但是，如果JavaScript库在包中提供其声明，您将不会对此感到满意。您可以使用 &lt;code&gt;@JsQualifier(...)&lt;/code&gt; 批注告诉编译器在引用 &lt;code&gt;external&lt;/code&gt; 声明之前生成其他前缀。</target>
        </trans-unit>
        <trans-unit id="95802660178652b3cea0422eb5403bb445448c4c" translate="yes" xml:space="preserve">
          <source>JavaScript does not have the concept of interfaces. When a function expects its parameter to support &lt;code&gt;foo&lt;/code&gt; and &lt;code&gt;bar&lt;/code&gt; methods, you just pass objects that actually have these methods. You can use interfaces to express this for statically-typed Kotlin, for example:</source>
          <target state="translated">JavaScript没有接口的概念。当函数期望其参数支持 &lt;code&gt;foo&lt;/code&gt; 和 &lt;code&gt;bar&lt;/code&gt; 方法时，只需传递实际具有这些方法的对象即可。您可以使用接口将其表示为静态类型的Kotlin，例如：</target>
        </trans-unit>
        <trans-unit id="db533d2ccc039c3271e49d0037285a95132804d3" translate="yes" xml:space="preserve">
          <source>JavaScript does not have the concept of interfaces. When a function expects its parameter to support two methods &lt;code&gt;foo&lt;/code&gt; and &lt;code&gt;bar&lt;/code&gt;, you would just pass in an object that actually has these methods.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fffb2c94a89ef37f4ff800dd4f2f3274e7b4c9bf" translate="yes" xml:space="preserve">
          <source>JetBrains develops and maintains several tools specifically for the React community: &lt;a href=&quot;https://github.com/JetBrains/kotlin-wrappers&quot;&gt;React bindings&lt;/a&gt; as well as &lt;a href=&quot;https://github.com/JetBrains/create-react-kotlin-app&quot;&gt;Create React Kotlin App&lt;/a&gt;. The latter helps you start building React apps with Kotlin with no build configuration.</source>
          <target state="translated">JetBrains开发和维护了几个专门用于React社区的工具：&lt;a href=&quot;https://github.com/JetBrains/kotlin-wrappers&quot;&gt;React绑定&lt;/a&gt;以及&lt;a href=&quot;https://github.com/JetBrains/create-react-kotlin-app&quot;&gt;Create React Kotlin App&lt;/a&gt;。后者可以帮助您开始使用没有构建配置的Kotlin构建React应用。</target>
        </trans-unit>
        <trans-unit id="0afbb0e9a99e99277b2f49549fedbc94a32802c2" translate="yes" xml:space="preserve">
          <source>Job in the context</source>
          <target state="translated">工作的背景</target>
        </trans-unit>
        <trans-unit id="06c75c90e1e9379a2cdd628513a60c328e9a2837" translate="yes" xml:space="preserve">
          <source>Join the Kotlin/JS community</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f050b9ce8a72499f6d4325b437a4f8f851d64df" translate="yes" xml:space="preserve">
          <source>Join us to continue exploring the C language types and their representation in Kotlin/Native in the related tutorials:</source>
          <target state="translated">和我们一起在相关教程中继续探索C语言类型及其在Kotlin/Native中的表示。</target>
        </trans-unit>
        <trans-unit id="560f658735b552460323d7d08486e67939d8b69b" translate="yes" xml:space="preserve">
          <source>Joining a course</source>
          <target state="translated">参加课程</target>
        </trans-unit>
        <trans-unit id="e14bf41ef01fdef5cf6b52dd5564ec2b2886f811" translate="yes" xml:space="preserve">
          <source>Joshua Bloch calls those objects you only &lt;strong&gt;read&lt;/strong&gt; from &lt;strong&gt;Producers&lt;/strong&gt;, and those you only &lt;strong&gt;write&lt;/strong&gt; to &lt;strong&gt;Consumers&lt;/strong&gt;. He recommends: &quot;&lt;em&gt;For maximum flexibility, use wildcard types on input parameters that represent producers or consumers&lt;/em&gt;&quot;, and proposes the following mnemonic:</source>
          <target state="translated">约书亚&amp;middot;布洛克称这些对象，你只能&lt;strong&gt;读&lt;/strong&gt;从&lt;strong&gt;生产者&lt;/strong&gt;，而那些只&lt;strong&gt;写&lt;/strong&gt;到&lt;strong&gt;消费者&lt;/strong&gt;。他建议：&amp;ldquo; &lt;em&gt;为了获得最大的灵活性，请在代表生产者或消费者的输入参数上使用通配符类型&lt;/em&gt; &amp;rdquo;，并提出以下助记符：</target>
        </trans-unit>
        <trans-unit id="aaaf7cda9e752b334875dd3fb12220ae53318575" translate="yes" xml:space="preserve">
          <source>JsArray</source>
          <target state="translated">JsArray</target>
        </trans-unit>
        <trans-unit id="5cf2add42044a4a104180a92b4649ba344349b36" translate="yes" xml:space="preserve">
          <source>JsClass</source>
          <target state="translated">JsClass</target>
        </trans-unit>
        <trans-unit id="829d41f036e4b83f97d9207ff01e19270a103dc5" translate="yes" xml:space="preserve">
          <source>JsExport</source>
          <target state="translated">JsExport</target>
        </trans-unit>
        <trans-unit id="680d5016d394bd1910f8e79c1f48e1099ec8a45e" translate="yes" xml:space="preserve">
          <source>JsModule</source>
          <target state="translated">JsModule</target>
        </trans-unit>
        <trans-unit id="bb2ba9a64ec3ce618d8658d2bac2ab5b52799c41" translate="yes" xml:space="preserve">
          <source>JsName</source>
          <target state="translated">JsName</target>
        </trans-unit>
        <trans-unit id="285e217de7a6a19bb6ff3224730d97a2ffb8669c" translate="yes" xml:space="preserve">
          <source>JsNonModule</source>
          <target state="translated">JsNonModule</target>
        </trans-unit>
        <trans-unit id="4431c8a7c0e95318d4df4acc2fb68414f204013b" translate="yes" xml:space="preserve">
          <source>JsQualifier</source>
          <target state="translated">JsQualifier</target>
        </trans-unit>
        <trans-unit id="5e2ef85ac474ea70113e00f2d535adfcd131ef41" translate="yes" xml:space="preserve">
          <source>JsValue</source>
          <target state="translated">JsValue</target>
        </trans-unit>
        <trans-unit id="0e8b29f774aacb41aea9f3a3e3922bc27a5b2f86" translate="yes" xml:space="preserve">
          <source>Json</source>
          <target state="translated">Json</target>
        </trans-unit>
        <trans-unit id="ee67901393cc367dccd6b7380bc834e3173528f8" translate="yes" xml:space="preserve">
          <source>Jumping between threads</source>
          <target state="translated">线程之间的跳转</target>
        </trans-unit>
        <trans-unit id="35e8c2b0fe924d03188fa9d13f85d320bcb98681" translate="yes" xml:space="preserve">
          <source>Just add the plugin JAR file to the compiler plugin classpath and specify the list of sam-with-receiver annotations:</source>
          <target state="translated">只要将插件JAR文件添加到编译器插件classpath中,并指定sam-with-receiver注释列表即可。</target>
        </trans-unit>
        <trans-unit id="23faffb10dc95518c4b08d2ccd86868a15d724ef" translate="yes" xml:space="preserve">
          <source>Just as in Java 8, Kotlin now allows to use underscores in numeric literals to separate groups of digits:</source>
          <target state="translated">就像在Java 8中一样,Kotlin现在允许在数字文字中使用下划线来分隔数字组。</target>
        </trans-unit>
        <trans-unit id="1d8e794cae8b9d9de103c8c7346fbf29e3d8b66f" translate="yes" xml:space="preserve">
          <source>Just like Java 8, Kotlin supports SAM conversions. This means that Kotlin function literals can be automatically converted into implementations of Java interfaces with a single non-default method, as long as the parameter types of the interface method match the parameter types of the Kotlin function.</source>
          <target state="translated">就像Java 8一样,Kotlin支持SAM转换。这意味着,只要接口方法的参数类型与Kotlin函数的参数类型相匹配,Kotlin函数字面值就可以通过一个非默认方法自动转换为Java接口的实现。</target>
        </trans-unit>
        <trans-unit id="949a51b86664f4131dce0e0c1b95750468898210" translate="yes" xml:space="preserve">
          <source>Just like Java and JavaScript, Kotlin supports end-of-line and block comments.</source>
          <target state="translated">就像Java和JavaScript一样,Kotlin支持行结束和块注释。</target>
        </trans-unit>
        <trans-unit id="470dca02756a771de4224b1f3a4e099fc973e2f5" translate="yes" xml:space="preserve">
          <source>Just like Java's anonymous inner classes, code in object expressions can access variables from the enclosing scope. (Unlike Java, this is not restricted to final or effectively final variables.)</source>
          <target state="translated">就像Java的匿名内类一样,对象表达式中的代码可以从包围的作用域中访问变量。与Java不同的是,这并不限于final或有效的final变量)。</target>
        </trans-unit>
        <trans-unit id="52bd785fc290723ed0a2f51dcda0df34f29bb395" translate="yes" xml:space="preserve">
          <source>Just like in Java, a special case is the &lt;code&gt;value&lt;/code&gt; parameter; its value can be specified without an explicit name:</source>
          <target state="translated">就像Java中一样， &lt;code&gt;value&lt;/code&gt; 参数是一个特例。可以不使用显式名称来指定其值：</target>
        </trans-unit>
        <trans-unit id="56e17eda787fc8a6435c74f86b6d7baef2f4cc5c" translate="yes" xml:space="preserve">
          <source>Just like in Java, enum classes in Kotlin have synthetic methods allowing to list the defined enum constants and to get an enum constant by its name. The signatures of these methods are as follows (assuming the name of the enum class is &lt;code&gt;EnumClass&lt;/code&gt;):</source>
          <target state="translated">就像Java中一样，Kotlin中的枚举类具有综合方法，可以列出定义的枚举常量并通过其名称获取枚举常量。这些方法的签名如下（假设枚举类的名称为 &lt;code&gt;EnumClass&lt;/code&gt; ）：</target>
        </trans-unit>
        <trans-unit id="087fe94dcb6ae8bf0df1e1981129ddf1a93236a7" translate="yes" xml:space="preserve">
          <source>Just like most modern languages, Kotlin supports single-line (or &lt;em&gt;end-of-line&lt;/em&gt;) and multi-line (&lt;em&gt;block&lt;/em&gt;) comments.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9137e7255bdeb308d1bb811a9d7f200fe163b672" translate="yes" xml:space="preserve">
          <source>Just like regular members of the companion object, they can be called using only the class name as the qualifier:</source>
          <target state="translated">就像companion对象的普通成员一样,它们可以只用类名作为限定符被调用。</target>
        </trans-unit>
        <trans-unit id="0848ea7d6dc0355eb57cb3d83744477db1fa4d97" translate="yes" xml:space="preserve">
          <source>Just like with JavaDoc, KDoc comments start with &lt;code&gt;/**&lt;/code&gt; and end with &lt;code&gt;*/&lt;/code&gt;. Every line of the comment may begin with an asterisk, which is not considered part of the contents of the comment.</source>
          <target state="translated">就像JavaDoc一样，KDoc注释以 &lt;code&gt;/**&lt;/code&gt; 开头，以 &lt;code&gt;*/&lt;/code&gt; 结尾。注释的每一行都可以以星号开头，该星号不被视为注释内容的一部分。</target>
        </trans-unit>
        <trans-unit id="d4d2de8b4148383d16c153caa1ed915e8e3e98f8" translate="yes" xml:space="preserve">
          <source>JvmDefault</source>
          <target state="translated">JvmDefault</target>
        </trans-unit>
        <trans-unit id="8d8475b40c0c838717c002d3eb803f88fd28b448" translate="yes" xml:space="preserve">
          <source>JvmDefaultWithoutCompatibility</source>
          <target state="translated">JvmDefaultWithoutCompatibility</target>
        </trans-unit>
        <trans-unit id="692baf8c605cdd872f8ac1b51f0db35d878fa6ec" translate="yes" xml:space="preserve">
          <source>JvmField</source>
          <target state="translated">JvmField</target>
        </trans-unit>
        <trans-unit id="8cafb887c2be5267183d19409f4ac9f885353c0a" translate="yes" xml:space="preserve">
          <source>JvmMultifileClass</source>
          <target state="translated">JvmMultifileClass</target>
        </trans-unit>
        <trans-unit id="2033eae859b01f53e2d78af856c5c34461b71b90" translate="yes" xml:space="preserve">
          <source>JvmName</source>
          <target state="translated">JvmName</target>
        </trans-unit>
        <trans-unit id="311d71c3b3f54390c29adff749b3edbb6a494b4a" translate="yes" xml:space="preserve">
          <source>JvmOverloads</source>
          <target state="translated">JvmOverloads</target>
        </trans-unit>
        <trans-unit id="747778441d808007d459844a0415514317ff72b7" translate="yes" xml:space="preserve">
          <source>JvmStatic</source>
          <target state="translated">JvmStatic</target>
        </trans-unit>
        <trans-unit id="6bc8e12710c62fe36d0378462ee3b1c664cd3300" translate="yes" xml:space="preserve">
          <source>JvmSuppressWildcards</source>
          <target state="translated">JvmSuppressWildcards</target>
        </trans-unit>
        <trans-unit id="a351df29143ba3c04cf22dc294f311273bb9b60f" translate="yes" xml:space="preserve">
          <source>JvmSynthetic</source>
          <target state="translated">JvmSynthetic</target>
        </trans-unit>
        <trans-unit id="85e086e57dc0c9b8c2d108ccec8876b36768e9b7" translate="yes" xml:space="preserve">
          <source>JvmWildcard</source>
          <target state="translated">JvmWildcard</target>
        </trans-unit>
        <trans-unit id="269b4c8f67d4bef3fb8e55e7c16a561a21d1145a" translate="yes" xml:space="preserve">
          <source>KAnnotatedElement</source>
          <target state="translated">KAnnotatedElement</target>
        </trans-unit>
        <trans-unit id="2380c006605522b5d08a2ee817a1eaa70c3eee66" translate="yes" xml:space="preserve">
          <source>KCallable</source>
          <target state="translated">KCallable</target>
        </trans-unit>
        <trans-unit id="638ba738d7801f4caebfacfc6daada8a29efaa3c" translate="yes" xml:space="preserve">
          <source>KClass</source>
          <target state="translated">KClass</target>
        </trans-unit>
        <trans-unit id="fab281a5b19ac7d1db397f74e48d5b9b12cc8340" translate="yes" xml:space="preserve">
          <source>KClass.cast</source>
          <target state="translated">KClass.cast</target>
        </trans-unit>
        <trans-unit id="acf5de634c6435ff94d10fad8e77c31d4afdb216" translate="yes" xml:space="preserve">
          <source>KClass.isInstance</source>
          <target state="translated">KClass.isInstance</target>
        </trans-unit>
        <trans-unit id="0eb6eed766c7bf5a996d5d184bea9e1688094497" translate="yes" xml:space="preserve">
          <source>KClass.safeCast</source>
          <target state="translated">KClass.safeCast</target>
        </trans-unit>
        <trans-unit id="64fa1008f290c0ccc3cc7c6ea0be14a5730d8c96" translate="yes" xml:space="preserve">
          <source>KClassifier</source>
          <target state="translated">KClassifier</target>
        </trans-unit>
        <trans-unit id="79b222c243d152a61ff297964121af433061592b" translate="yes" xml:space="preserve">
          <source>KClassifier.createType</source>
          <target state="translated">KClassifier.createType</target>
        </trans-unit>
        <trans-unit id="20cb65ed76161cb0b2be5e7c93b9d81ef134450b" translate="yes" xml:space="preserve">
          <source>KDeclarationContainer</source>
          <target state="translated">KDeclarationContainer</target>
        </trans-unit>
        <trans-unit id="7bf1a6c1fa5dce180803fdb8c3400d5e981f7201" translate="yes" xml:space="preserve">
          <source>KDoc Syntax</source>
          <target state="translated">KDoc语法</target>
        </trans-unit>
        <trans-unit id="7d4c77574d0b857a214718597dca35a72ce59ec3" translate="yes" xml:space="preserve">
          <source>KDoc currently supports the following block tags:</source>
          <target state="translated">KDoc目前支持以下区块标签。</target>
        </trans-unit>
        <trans-unit id="fae5be3a00cdb97c4b5aa9435d19be927a5665ba" translate="yes" xml:space="preserve">
          <source>KDoc does not support the &lt;code&gt;@deprecated&lt;/code&gt; tag. Instead, please use the &lt;code&gt;@Deprecated&lt;/code&gt; annotation.</source>
          <target state="translated">KDoc不支持 &lt;code&gt;@deprecated&lt;/code&gt; 标记。相反，请使用 &lt;code&gt;@Deprecated&lt;/code&gt; 批注。</target>
        </trans-unit>
        <trans-unit id="343a3fd44d3f90b682e5b8542c76a1c8f0dc43bf" translate="yes" xml:space="preserve">
          <source>KDoc syntax</source>
          <target state="translated">KDoc语法</target>
        </trans-unit>
        <trans-unit id="cf7f75d8adb5a4855b94e1806ea4b9da20753a2a" translate="yes" xml:space="preserve">
          <source>KFunction</source>
          <target state="translated">KFunction</target>
        </trans-unit>
        <trans-unit id="ed5e1b52600600ea74e498fffdc8c815085f7d28" translate="yes" xml:space="preserve">
          <source>KLib binaries</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="351228c4e54d9346ab6c9f3124cf8905349ef3f6" translate="yes" xml:space="preserve">
          <source>KMutableProperty</source>
          <target state="translated">KMutableProperty</target>
        </trans-unit>
        <trans-unit id="b8079b1b2c0efc81f1810eda68de2b7cfe28211b" translate="yes" xml:space="preserve">
          <source>KMutableProperty0</source>
          <target state="translated">KMutableProperty0</target>
        </trans-unit>
        <trans-unit id="ee64a1ab548503607558b0ae24255a9fb8d1bf97" translate="yes" xml:space="preserve">
          <source>KMutableProperty1</source>
          <target state="translated">KMutableProperty1</target>
        </trans-unit>
        <trans-unit id="b5a2a8a013bdb0ae3b43fd0eedfa92a1c579f8b7" translate="yes" xml:space="preserve">
          <source>KMutableProperty2</source>
          <target state="translated">KMutableProperty2</target>
        </trans-unit>
        <trans-unit id="3b161212f1754e4e1f54c5dee3fdb112a6efcc79" translate="yes" xml:space="preserve">
          <source>KParameter</source>
          <target state="translated">KParameter</target>
        </trans-unit>
        <trans-unit id="47dc03443aa940939b9abccc2588997b2fd72705" translate="yes" xml:space="preserve">
          <source>KProperty</source>
          <target state="translated">KProperty</target>
        </trans-unit>
        <trans-unit id="7c65965ff00632a4a27df6d2ccf39af470a5196a" translate="yes" xml:space="preserve">
          <source>KProperty0</source>
          <target state="translated">KProperty0</target>
        </trans-unit>
        <trans-unit id="8baedb2820a644b389145928c1658d83b9918bc5" translate="yes" xml:space="preserve">
          <source>KProperty1</source>
          <target state="translated">KProperty1</target>
        </trans-unit>
        <trans-unit id="8bf91abab2e2266a64dcd908bc6e070ddbaf118e" translate="yes" xml:space="preserve">
          <source>KProperty1.getDelegate</source>
          <target state="translated">KProperty1.getDelegate</target>
        </trans-unit>
        <trans-unit id="d8609e0c5b369de4819d2e07e76fd6ed37986905" translate="yes" xml:space="preserve">
          <source>KProperty2</source>
          <target state="translated">KProperty2</target>
        </trans-unit>
        <trans-unit id="fd138efe2eefe64c683fdbac01b4ebe15e42c11f" translate="yes" xml:space="preserve">
          <source>KProperty2.getDelegate</source>
          <target state="translated">KProperty2.getDelegate</target>
        </trans-unit>
        <trans-unit id="cddedd34830292c250dc6df0c7292dd170403bdb" translate="yes" xml:space="preserve">
          <source>KType</source>
          <target state="translated">KType</target>
        </trans-unit>
        <trans-unit id="f3764cdd111b81b5f82e469014413398559a3a69" translate="yes" xml:space="preserve">
          <source>KTypeParameter</source>
          <target state="translated">KTypeParameter</target>
        </trans-unit>
        <trans-unit id="a52a8fe183ee882846ec18218986d60cbd8b9caa" translate="yes" xml:space="preserve">
          <source>KTypeParameter.variance</source>
          <target state="translated">KTypeParameter.variance</target>
        </trans-unit>
        <trans-unit id="541ac7b02574ef282f5fea0a7caa24f963767d58" translate="yes" xml:space="preserve">
          <source>KTypeProjection</source>
          <target state="translated">KTypeProjection</target>
        </trans-unit>
        <trans-unit id="453bbaf5b6df4218f396acb7d784d58647332cd3" translate="yes" xml:space="preserve">
          <source>KVariance</source>
          <target state="translated">KVariance</target>
        </trans-unit>
        <trans-unit id="540dc0ef81ec2a035fa8eb530610a94d10ceaf33" translate="yes" xml:space="preserve">
          <source>KVisibility</source>
          <target state="translated">KVisibility</target>
        </trans-unit>
        <trans-unit id="89ee95ab7caa6f00ebf6ba552593878d5c2b4d1a" translate="yes" xml:space="preserve">
          <source>Kapt can generate Kotlin sources. Just write the generated Kotlin source files to the directory specified by &lt;code&gt;processingEnv.options[&quot;kapt.kotlin.generated&quot;]&lt;/code&gt;, and these files will be compiled together with the main sources.</source>
          <target state="translated">Kapt可以生成Kotlin源。只需将生成的Kotlin源文件写入到 &lt;code&gt;processingEnv.options[&quot;kapt.kotlin.generated&quot;]&lt;/code&gt; 指定的目录中，这些文件就会与主要源文件一起编译。</target>
        </trans-unit>
        <trans-unit id="115c000133ca0eeaa296737859925189dceee8bb" translate="yes" xml:space="preserve">
          <source>Kapt compiler plugin is available in the binary distribution of the Kotlin compiler.</source>
          <target state="translated">Kapt编译器插件可以在Kotlin编译器的二进制发行版中使用。</target>
        </trans-unit>
        <trans-unit id="d2790ed7723277b25aa2209903904a8c31657160" translate="yes" xml:space="preserve">
          <source>Kapt uses Java compiler to run annotation processors.</source>
          <target state="translated">Kapt使用Java编译器来运行注释处理器。</target>
        </trans-unit>
        <trans-unit id="ec688ce3d89067940f46fd29a7ea54660b831823" translate="yes" xml:space="preserve">
          <source>Keep in mind that this is just syntactic sugar - you're not actually modifying the class or its instances. Therefore, you have to import an extension function/property wherever you want to use it (since it isn't carried along with the instances of the class). For the same reason, you can not override extension members - you can reimplement them for subtypes, but the resolution happens at compile-time based on the static type of the expression you're invoking it on. So if you declare an extension function for &lt;code&gt;Vehicle&lt;/code&gt;, and one with the same name and signature for its subclass &lt;code&gt;Car&lt;/code&gt;, and you do the following, it's the extension function on &lt;code&gt;Vehicle&lt;/code&gt; that will be called, even though &lt;code&gt;v&lt;/code&gt; is really a &lt;code&gt;Car&lt;/code&gt;:</source>
          <target state="translated">请记住，这只是语法糖-您实际上并没有在修改类或其实例。因此，您必须在要使用扩展功能/属性的任何地方导入它（因为扩展功能/属性不会随类的实例一起提供）。出于同样的原因，您不能覆盖扩展成员-您可以为子类型重新实现扩展成员，但是解决方案是在编译时根据调用它的表达式的静态类型进行的。因此，如果您为 &lt;code&gt;Vehicle&lt;/code&gt; 声明了一个扩展函数，并且为其子类 &lt;code&gt;Car&lt;/code&gt; 声明了一个具有相同名称和签名的扩展函数，然后执行以下操作，那么即使 &lt;code&gt;v&lt;/code&gt; 确实是 &lt;code&gt;Car&lt;/code&gt; ，也将调用 &lt;code&gt;Vehicle&lt;/code&gt; 的扩展函数：</target>
        </trans-unit>
        <trans-unit id="18218cc9fd8c5aa995704dae391402dc208f9851" translate="yes" xml:space="preserve">
          <source>Keep the language modern over the years.</source>
          <target state="translated">多年来,保持语言的现代化。</target>
        </trans-unit>
        <trans-unit id="07ccea1c92ddb53422b1f7f7120a95adacb8fcf2" translate="yes" xml:space="preserve">
          <source>Keeping whole packages or modules from elimination can prevent DCE from removing many unused declarations. Because of this, it is preferable to select individual declarations which should be excluded from DCE one by one.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="428b07e8e32e536ccaf4d9521cd95cadbf7fb10f" translate="yes" xml:space="preserve">
          <source>Keepsafe's App Lock app has also been &lt;a href=&quot;https://medium.com/keepsafe-engineering/lessons-from-converting-an-app-to-100-kotlin-68984a05dcb6&quot;&gt;converted to 100% Kotlin&lt;/a&gt;, leading to a 30% decrease in source line count and 10% decrease in method count.</source>
          <target state="translated">Keepsafe的App Lock应用也已&lt;a href=&quot;https://medium.com/keepsafe-engineering/lessons-from-converting-an-app-to-100-kotlin-68984a05dcb6&quot;&gt;转换为100％Kotlin&lt;/a&gt;，从而使源代码行计数减少了30％，方法计数减少了10％。</target>
        </trans-unit>
        <trans-unit id="c67dd20ee842986086a0a915ddc2a279490130ed" translate="yes" xml:space="preserve">
          <source>Key</source>
          <target state="translated">Key</target>
        </trans-unit>
        <trans-unit id="4529f1f2ec7b60606af93bf0af48f282ccf9e92f" translate="yes" xml:space="preserve">
          <source>Key for the elements of &lt;a href=&quot;index&quot;&gt;CoroutineContext&lt;/a&gt;. &lt;a href=&quot;-key#E&quot;&gt;E&lt;/a&gt; is a type of element with this key.</source>
          <target state="translated">&lt;a href=&quot;index&quot;&gt;CoroutineContext&lt;/a&gt;元素的键。&lt;a href=&quot;-key#E&quot;&gt;E&lt;/a&gt;是具有此键的元素的类型。</target>
        </trans-unit>
        <trans-unit id="14a72bb7f1422b3f859b664b3562ae101c3c66b5" translate="yes" xml:space="preserve">
          <source>Key for the elements of &lt;a href=&quot;index&quot;&gt;CoroutineContext&lt;/a&gt;. &lt;a href=&quot;-key#E&quot;&gt;E&lt;/a&gt; is a type of element with this key. Keys in the context are compared &lt;em&gt;by reference&lt;/em&gt;.</source>
          <target state="translated">&lt;a href=&quot;index&quot;&gt;CoroutineContext&lt;/a&gt;元素的键。&lt;a href=&quot;-key#E&quot;&gt;E&lt;/a&gt;是具有此键的元素的类型。&lt;em&gt;通过引用&lt;/em&gt;比较上下文中的键。</target>
        </trans-unit>
        <trans-unit id="7dea00f8bb18a0d2f420e398a89ddb4931a962cc" translate="yes" xml:space="preserve">
          <source>KeyboardEventInit</source>
          <target state="translated">KeyboardEventInit</target>
        </trans-unit>
        <trans-unit id="12698e3202bea6e77c14cc7645aefe1f40b4a95b" translate="yes" xml:space="preserve">
          <source>Keywords and Operators</source>
          <target state="translated">关键词和操作者</target>
        </trans-unit>
        <trans-unit id="e00ac23f2ac2ff73ad4f3c4b263d6c5bbfb80190" translate="yes" xml:space="preserve">
          <source>Kind</source>
          <target state="translated">Kind</target>
        </trans-unit>
        <trans-unit id="6d7060b8f0b142e9cc5d99251ae9bfc8344b5cdb" translate="yes" xml:space="preserve">
          <source>Kind of a module generated by compiler</source>
          <target state="translated">一种由编译器生成的模块</target>
        </trans-unit>
        <trans-unit id="1d34a603bd791899c80e1dbe11daaee6bb135493" translate="yes" xml:space="preserve">
          <source>Kind of this parameter.</source>
          <target state="translated">样的这个参数。</target>
        </trans-unit>
        <trans-unit id="b295237940a339c9b3b99ec9fc0619f9bc3cd8b9" translate="yes" xml:space="preserve">
          <source>Kind represents a particular position of the parameter declaration in the source code, such as an instance, an extension receiver parameter or a value parameter.</source>
          <target state="translated">Kind表示参数声明在源代码中的特定位置,如实例、扩展接收器参数或值参数。</target>
        </trans-unit>
        <trans-unit id="b05203cf89b60eb36609a1a8b7f3cafe0927486a" translate="yes" xml:space="preserve">
          <source>Known issues</source>
          <target state="translated">已知问题</target>
        </trans-unit>
        <trans-unit id="7205eb983ba710302eb6c62f19abead98485f315" translate="yes" xml:space="preserve">
          <source>Koans</source>
          <target state="translated">Koans</target>
        </trans-unit>
        <trans-unit id="cff7933a49bb6d767f24e765c4887a762a5f9c00" translate="yes" xml:space="preserve">
          <source>Konan_js_getProperty</source>
          <target state="translated">Konan_js_getProperty</target>
        </trans-unit>
        <trans-unit id="4b97a1cc4cde2d848838f0605a552d5704eea24b" translate="yes" xml:space="preserve">
          <source>Kotlin</source>
          <target state="translated">Kotlin</target>
        </trans-unit>
        <trans-unit id="ce2c3a212ddf8e8e1152459e5ba603b0e8d0abe9" translate="yes" xml:space="preserve">
          <source>Kotlin 1.1 introduced coroutines, a new way of writing asynchronous, non-blocking code (and much more). In this tutorial we will go through some basics of using Kotlin coroutines with the help of the &lt;code&gt;kotlinx.coroutines&lt;/code&gt; library, which is a collection of helpers and wrappers for existing Java libraries.</source>
          <target state="translated">Kotlin 1.1引入了协程，这是一种编写异步，非阻塞代码（以及更多）的新方法。在本教程中，我们将在 &lt;code&gt;kotlinx.coroutines&lt;/code&gt; 库的帮助下，了解使用Kotlin协程的一些基础知识，该库是现有Java库的帮助程序和包装程序的集合。</target>
        </trans-unit>
        <trans-unit id="63575fcf9f53cf161b23b5a5120b649f923aec04" translate="yes" xml:space="preserve">
          <source>Kotlin 1.1 removes some of the restrictions on sealed and data classes that were present in Kotlin 1.0. Now you can define subclasses of a top-level sealed class on the top level in the same file, and not just as nested classes of the sealed class. Data classes can now extend other classes. This can be used to define a hierarchy of expression classes nicely and cleanly:</source>
          <target state="translated">Kotlin 1.1删除了Kotlin 1.0中对密封类和数据类的一些限制。现在你可以在同一个文件中定义顶层密封类的子类,而不仅仅是作为密封类的嵌套类。数据类现在可以扩展其他类。这可以用来很好地、干净地定义表达式类的层次结构。</target>
        </trans-unit>
        <trans-unit id="4b689f1de0358fa8de1c1a96775c0c0ab1538fa5" translate="yes" xml:space="preserve">
          <source>Kotlin 1.2 introduces a set of functions for operating with &lt;code&gt;BigInteger&lt;/code&gt; and &lt;code&gt;BigDecimal&lt;/code&gt; and creating them from other numeric types. These are:</source>
          <target state="translated">Kotlin 1.2引入了一组用于 &lt;code&gt;BigInteger&lt;/code&gt; 和 &lt;code&gt;BigDecimal&lt;/code&gt; 并从其他数字类型创建它们的函数。这些是：</target>
        </trans-unit>
        <trans-unit id="f18db78c63aaf770b997189868cab88ccb0ebc9f" translate="yes" xml:space="preserve">
          <source>Kotlin 1.3 continues to evolve and improve scripting API, introducing some experimental support for scripts customization, such as adding external properties, providing static or dynamic dependencies, and so on.</source>
          <target state="translated">Kotlin 1.3继续发展和改进脚本API,引入了一些实验性的脚本定制支持,如添加外部属性、提供静态或动态依赖等。</target>
        </trans-unit>
        <trans-unit id="88e2adace5bac1e48c0adc9ef2ac271c679c842b" translate="yes" xml:space="preserve">
          <source>Kotlin 1.3 continues to improve and polish the Native target. See the &lt;a href=&quot;native-overview&quot;&gt;Kotlin/Native overview&lt;/a&gt; for details.</source>
          <target state="translated">Kotlin 1.3继续改进和完善了Native目标。有关详细信息，请参见&lt;a href=&quot;native-overview&quot;&gt;Kotlin / Native概述&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="fb394a79550e8145ec468f60617c81e553701477" translate="yes" xml:space="preserve">
          <source>Kotlin 1.3 introduced a simpler form of &lt;code&gt;main&lt;/code&gt; which takes no parameters. Now &amp;ldquo;Hello, World&amp;rdquo; in Kotlin is 19 characters shorter!</source>
          <target state="translated">Kotlin 1.3引入了一种更简单的 &lt;code&gt;main&lt;/code&gt; 形式，该形式不带参数。现在，科特林的&amp;ldquo; Hello，World&amp;rdquo;要短19个字符！</target>
        </trans-unit>
        <trans-unit id="bfa732fa62960ffc201f7ae614e12c53ef901915" translate="yes" xml:space="preserve">
          <source>Kotlin 1.3 introduces a new kind of declaration &amp;mdash; &lt;code&gt;inline class&lt;/code&gt;. Inline classes can be viewed as a restricted version of the usual classes, in particular, inline classes must have exactly one property:</source>
          <target state="translated">Kotlin 1.3引入了一种新的声明&amp;mdash; &lt;code&gt;inline class&lt;/code&gt; 。可以将内联类视为普通类的受限版本，特别是，内联类必须具有唯一的一个属性：</target>
        </trans-unit>
        <trans-unit id="32e23fcaa9e8679e7038c793f0f15c69e36b0fe8" translate="yes" xml:space="preserve">
          <source>Kotlin 1.3 introduces callable references on suspend-functions and support of Coroutines in the Reflection API.</source>
          <target state="translated">Kotlin 1.3在Reflection API中引入了悬浮函数的可调用引用和对Coroutines的支持。</target>
        </trans-unit>
        <trans-unit id="99e7bed5b89ef9affe2aabaa02c6b466182d4674" translate="yes" xml:space="preserve">
          <source>Kotlin 1.3 introduces support for runnable Kotlin &lt;em&gt;scratch files&lt;/em&gt;. &lt;em&gt;Scratch file&lt;/em&gt; is a kotlin script file with a .kts extension which you can run and get evaluation results directly in the editor.</source>
          <target state="translated">Kotlin 1.3引入了对可运行Kotlin &lt;em&gt;暂存文件的&lt;/em&gt;支持。&lt;em&gt;Scratch文件&lt;/em&gt;是带有.kts扩展名的kotlin脚本文件，您可以直接在编辑器中运行并获取评估结果。</target>
        </trans-unit>
        <trans-unit id="62694aae6035c5ad4972f2e14bf03a63310cd91a" translate="yes" xml:space="preserve">
          <source>Kotlin 1.3 introduces support for the &lt;a href=&quot;coding-conventions&quot;&gt;recommended code style&lt;/a&gt; in the IDE. Check out &lt;a href=&quot;code-style-migration-guide&quot;&gt;this page&lt;/a&gt; for the migration guidelines.</source>
          <target state="translated">Kotlin 1.3引入了对IDE中&lt;a href=&quot;coding-conventions&quot;&gt;推荐代码风格的&lt;/a&gt;支持。请查看&lt;a href=&quot;code-style-migration-guide&quot;&gt;此页面&lt;/a&gt;以获取迁移指南。</target>
        </trans-unit>
        <trans-unit id="dae614ce706dcca5f69b1c3253fcc5bc2a15bada" translate="yes" xml:space="preserve">
          <source>Kotlin 1.3 introduces unsigned integer types:</source>
          <target state="translated">Kotlin 1.3引入了无符号整数类型。</target>
        </trans-unit>
        <trans-unit id="29c35fc143ca98d825aae2e4d6224d719799d607" translate="yes" xml:space="preserve">
          <source>Kotlin 1.3 relaxes this limitation and adds support for functions with bigger arity:</source>
          <target state="translated">Kotlin 1.3 放宽了这一限制,并增加了对大数子函数的支持。</target>
        </trans-unit>
        <trans-unit id="fab6809ce8d845633ec216cd46b20c0f5a989761" translate="yes" xml:space="preserve">
          <source>Kotlin &lt;code&gt;Any&lt;/code&gt; type</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e0b4419e56e01f176b70724da2be7f1570af7d9" translate="yes" xml:space="preserve">
          <source>Kotlin &lt;code&gt;String&lt;/code&gt; type</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0c3f493c89be1b94503fdc3f47d5c69cab752c8" translate="yes" xml:space="preserve">
          <source>Kotlin &lt;code&gt;inline&lt;/code&gt; classes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6f908927df8b995d9d09ec9bb214acf154074cf" translate="yes" xml:space="preserve">
          <source>Kotlin &lt;code&gt;interface&lt;/code&gt; types</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="efe980e61f0d5167fc83d8f145a3ab77bfa2773d" translate="yes" xml:space="preserve">
          <source>Kotlin &lt;code&gt;object Object&lt;/code&gt; is accessible as &lt;code&gt;kotlin.root.example.Object&lt;/code&gt;. There is the &lt;code&gt;_instance&lt;/code&gt; function to get the only instance of the object.</source>
          <target state="translated">Kotlin &lt;code&gt;object Object&lt;/code&gt; 可以作为 &lt;code&gt;kotlin.root.example.Object&lt;/code&gt; 访问。还有就是 &lt;code&gt;_instance&lt;/code&gt; 函数来获取对象的唯一实例。</target>
        </trans-unit>
        <trans-unit id="0c1eb8d6dc73bce62ae72ba95f8c60b359816283" translate="yes" xml:space="preserve">
          <source>Kotlin Android Extensions</source>
          <target state="translated">Kotlin Android扩展</target>
        </trans-unit>
        <trans-unit id="7ffa31859972ce0a8778bfbe6687b81f154ab790" translate="yes" xml:space="preserve">
          <source>Kotlin Coding Conventions and IntelliJ IDEA formatter</source>
          <target state="translated">Kotlin 编码约定和 IntelliJ IDEA 格式器</target>
        </trans-unit>
        <trans-unit id="d072d7cbb3d097a577aaa31d4b14236492b51583" translate="yes" xml:space="preserve">
          <source>Kotlin Collections Overview</source>
          <target state="translated">Kotlin Collections概述</target>
        </trans-unit>
        <trans-unit id="e053b5d9a8bf9415ef3c2e418563c34aaf8713f7" translate="yes" xml:space="preserve">
          <source>Kotlin Define</source>
          <target state="translated">Kotlin定义</target>
        </trans-unit>
        <trans-unit id="f0cb9aff4685505b6e4d1a7786d44dbe9c5c78a7" translate="yes" xml:space="preserve">
          <source>Kotlin Educational Plugin</source>
          <target state="translated">Kotlin教育插件</target>
        </trans-unit>
        <trans-unit id="d2c2322d0e9d4d8a96800bd4df5ea6b0ed7d65ca" translate="yes" xml:space="preserve">
          <source>Kotlin Evolution</source>
          <target state="translated">Kotlin的进化</target>
        </trans-unit>
        <trans-unit id="5cd6704a0bf9c9ca5663fc3e713188fc0c5a8b1c" translate="yes" xml:space="preserve">
          <source>Kotlin Examples</source>
          <target state="translated">Kotlin示例</target>
        </trans-unit>
        <trans-unit id="37cd15476fbbf200875db0672669c456999520ce" translate="yes" xml:space="preserve">
          <source>Kotlin Gradle plugin 1.3.41 works with Android Gradle Plugin 3.0 and later.</source>
          <target state="translated">Kotlin Gradle插件1.3.41适用于Android Gradle Plugin 3.0及以上版本。</target>
        </trans-unit>
        <trans-unit id="4cd0aaf87578a00cb3abace9012077865b35012d" translate="yes" xml:space="preserve">
          <source>Kotlin JavaScript Overview</source>
          <target state="translated">Kotlin JavaScript概述</target>
        </trans-unit>
        <trans-unit id="59567d5d08261cc25efe7ed7644a3eac45c8cd4f" translate="yes" xml:space="preserve">
          <source>Kotlin JavaScript wrappers for the &lt;a href=&quot;https://fetch.spec.whatwg.org&quot;&gt;W3C fetch API&lt;/a&gt;.</source>
          <target state="translated">用于&lt;a href=&quot;https://fetch.spec.whatwg.org&quot;&gt;W3C提取API的&lt;/a&gt; Kotlin JavaScript包装器。</target>
        </trans-unit>
        <trans-unit id="89d3498431602c2625879d1556695e73607eefba" translate="yes" xml:space="preserve">
          <source>Kotlin JavaScript wrappers for the &lt;a href=&quot;https://www.w3.org/TR/FileAPI/&quot;&gt;W3C file API&lt;/a&gt;.</source>
          <target state="translated">用于&lt;a href=&quot;https://www.w3.org/TR/FileAPI/&quot;&gt;W3C文件API的&lt;/a&gt; Kotlin JavaScript包装器。</target>
        </trans-unit>
        <trans-unit id="87540457cfa4e684d01ade1be4ff2d537b4f72fb" translate="yes" xml:space="preserve">
          <source>Kotlin JavaScript wrappers for the &lt;a href=&quot;https://www.w3.org/TR/XMLHttpRequest/&quot;&gt;XMLHttpRequest API&lt;/a&gt;.</source>
          <target state="translated">用于&lt;a href=&quot;https://www.w3.org/TR/XMLHttpRequest/&quot;&gt;XMLHttpRequest API的&lt;/a&gt; Kotlin JavaScript包装器。</target>
        </trans-unit>
        <trans-unit id="e6596f2dab21e4e3036fba3783d7f4c0fbb0bb5f" translate="yes" xml:space="preserve">
          <source>Kotlin JavaScript wrappers for the &lt;a href=&quot;https://www.w3.org/TR/navigation-timing/&quot;&gt;Navigation Timing API&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://www.w3.org/TR/navigation-timing/&quot;&gt;导航Timing API的&lt;/a&gt; Kotlin JavaScript包装器。</target>
        </trans-unit>
        <trans-unit id="449720a2299361e4c4ce93870004ed0025bd08d4" translate="yes" xml:space="preserve">
          <source>Kotlin JavaScript wrappers for the &lt;a href=&quot;https://www.w3.org/TR/notifications/&quot;&gt;Web Notifications API&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://www.w3.org/TR/notifications/&quot;&gt;Web Notifications API的&lt;/a&gt; Kotlin JavaScript包装器。</target>
        </trans-unit>
        <trans-unit id="273f94ff92211232696d0bb0cccbbaefd99d6ca2" translate="yes" xml:space="preserve">
          <source>Kotlin JavaScript wrappers for the &lt;a href=&quot;https://www.w3.org/TR/workers/&quot;&gt;Web Workers API&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://www.w3.org/TR/workers/&quot;&gt;Web Workers API的&lt;/a&gt; Kotlin JavaScript包装器。</target>
        </trans-unit>
        <trans-unit id="60b8cb21a679faec431a00498befc15353dcf7ae" translate="yes" xml:space="preserve">
          <source>Kotlin JavaScript wrappers for the DOM API.</source>
          <target state="translated">用于DOM API的Kotlin JavaScript封装器。</target>
        </trans-unit>
        <trans-unit id="510e862b2092dfc113c9c6425e75519b326f41d7" translate="yes" xml:space="preserve">
          <source>Kotlin JavaScript wrappers for the DOM CSS API.</source>
          <target state="translated">用于DOM CSS API的Kotlin JavaScript封装器。</target>
        </trans-unit>
        <trans-unit id="f801c6554f4b1898140dcdff66b0ae475172001f" translate="yes" xml:space="preserve">
          <source>Kotlin JavaScript wrappers for the DOM SVG API.</source>
          <target state="translated">用于DOM SVG API的Kotlin JavaScript封装器。</target>
        </trans-unit>
        <trans-unit id="ac97493032ddcd8ea7ab49e6704871e5d4e02a32" translate="yes" xml:space="preserve">
          <source>Kotlin JavaScript wrappers for the DOM URL API.</source>
          <target state="translated">用于DOM URL API的Kotlin JavaScript封装器。</target>
        </trans-unit>
        <trans-unit id="632516fede4eb8d78a61753d5a6b557583fae63f" translate="yes" xml:space="preserve">
          <source>Kotlin JavaScript wrappers for the DOM events API.</source>
          <target state="translated">用于DOM事件API的Kotlin JavaScript封装器。</target>
        </trans-unit>
        <trans-unit id="9961d958d00f28d74f54365fb789a0a4c6ef0a4a" translate="yes" xml:space="preserve">
          <source>Kotlin JavaScript wrappers for the DOM parsing API.</source>
          <target state="translated">用于DOM解析API的Kotlin JavaScript封装器。</target>
        </trans-unit>
        <trans-unit id="1124adb3f39b71dbc17459b09b1abc27195f61e8" translate="yes" xml:space="preserve">
          <source>Kotlin JavaScript wrappers for the WebGL API.</source>
          <target state="translated">用于WebGL API的Kotlin JavaScript封装器。</target>
        </trans-unit>
        <trans-unit id="c722e55da392cbca2ad7039aefd4506956b7b45a" translate="yes" xml:space="preserve">
          <source>Kotlin Koans</source>
          <target state="translated">Kotlin Koans</target>
        </trans-unit>
        <trans-unit id="8d8f55606ab1553a327fba954030ef9e92582959" translate="yes" xml:space="preserve">
          <source>Kotlin Koans are a series of exercises to get you familiar with the Kotlin Syntax. Each exercise is created as a failing unit test and your job is to make it pass. You can work with Kotlin Koans in one of following two ways:</source>
          <target state="translated">Kotlin Koans是一系列让你熟悉Kotlin语法的练习。每个练习都被创建为一个失败的单元测试,而你的工作就是让它通过。你可以通过以下两种方式来使用Kotlin Koans。</target>
        </trans-unit>
        <trans-unit id="02527323fc74019fbf781a55d67bc6708fd5c80b" translate="yes" xml:space="preserve">
          <source>Kotlin Multiplatform Mobile documentation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79d51b4bb6a5d02df45fa0b0d8769519481f6142" translate="yes" xml:space="preserve">
          <source>Kotlin Multiplatform Mobile samples</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c868382257c277087bdd2ca5e011f6e8a06d6f5" translate="yes" xml:space="preserve">
          <source>Kotlin Multiplatform projects require Gradle version 4.7 and above, older Gradle versions are not supported.</source>
          <target state="translated">Kotlin多平台项目需要Gradle 4.7及以上版本,不支持旧版Gradle。</target>
        </trans-unit>
        <trans-unit id="5beef88265abf70b994272f6614d166413737387" translate="yes" xml:space="preserve">
          <source>Kotlin Multiplatform projects support the Android platform by providing the &lt;code&gt;android&lt;/code&gt; preset. Creating an Android target requires that one of the Android Gradle plugins, like &lt;code&gt;com.android.application&lt;/code&gt; or &lt;code&gt;com.android.library&lt;/code&gt; is manually applied to the project. Only one Android target may be created per Gradle subproject:</source>
          <target state="translated">Kotlin Multiplatform项目通过提供 &lt;code&gt;android&lt;/code&gt; 预设来支持Android平台。创建Android目标需要手动将一个Android Gradle插件（例如 &lt;code&gt;com.android.application&lt;/code&gt; 或 &lt;code&gt;com.android.library&lt;/code&gt; ）应用于项目。每个Gradle子项目只能创建一个Android目标：</target>
        </trans-unit>
        <trans-unit id="dc3e3dd997f7c2c71d9a81f4cdb39cd90d645230" translate="yes" xml:space="preserve">
          <source>Kotlin Numbers and NSNumber</source>
          <target state="translated">Kotlin数字和NSNumber</target>
        </trans-unit>
        <trans-unit id="eb93d433c30733afdb11f2126d70c53184c02256" translate="yes" xml:space="preserve">
          <source>Kotlin Programming: The Big Nerd Ranch Guide</source>
          <target state="translated">Kotlin编程。大书呆子牧场指南</target>
        </trans-unit>
        <trans-unit id="7be628ef89900aa7e06bf8cc0824f551fbf7c2e0" translate="yes" xml:space="preserve">
          <source>Kotlin Scripting APIs</source>
          <target state="translated">Kotlin脚本API</target>
        </trans-unit>
        <trans-unit id="faea4ae8da7ddba5c8fa58aae401857d2734ca04" translate="yes" xml:space="preserve">
          <source>Kotlin Scripting APIs and custom hosts</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="011d36adfc33756acd805d34ad317cbce9bd6e81" translate="yes" xml:space="preserve">
          <source>Kotlin Scripts (*.kts)</source>
          <target state="translated">Kotlin Scripts (*.kts)</target>
        </trans-unit>
        <trans-unit id="ede3b405bdfcccaf670f3a431d8f9e4a2a31a89a" translate="yes" xml:space="preserve">
          <source>Kotlin Standard Library</source>
          <target state="translated">Kotlin标准库</target>
        </trans-unit>
        <trans-unit id="f1cf27226d5b75bef32541fe78ffcb393aaf20fa" translate="yes" xml:space="preserve">
          <source>Kotlin allows us to provide implementations for a predefined set of operators on our types. These operators have fixed symbolic representation (like &lt;code&gt;+&lt;/code&gt; or &lt;code&gt;*&lt;/code&gt;) and fixed &lt;a href=&quot;https://kotlinlang.org/docs/reference/grammar.html#expressions&quot;&gt;precedence&lt;/a&gt;. To implement an operator, we provide a &lt;a href=&quot;functions#member-functions&quot;&gt;member function&lt;/a&gt; or an &lt;a href=&quot;extensions&quot;&gt;extension function&lt;/a&gt; with a fixed name, for the corresponding type, i.e. left-hand side type for binary operations and argument type for unary ones. Functions that overload operators need to be marked with the &lt;code&gt;operator&lt;/code&gt; modifier.</source>
          <target state="translated">Kotlin允许我们为类型上的一组预定义操作符提供实现。这些运算符具有固定的符号表示形式（如 &lt;code&gt;+&lt;/code&gt; 或 &lt;code&gt;*&lt;/code&gt; ）和固定的&lt;a href=&quot;https://kotlinlang.org/docs/reference/grammar.html#expressions&quot;&gt;优先级&lt;/a&gt;。为了实现运算符，我们为相应的类型提供了具有固定名称的&lt;a href=&quot;functions#member-functions&quot;&gt;成员函数&lt;/a&gt;或&lt;a href=&quot;extensions&quot;&gt;扩展函数&lt;/a&gt;，即对于二进制运算而言是左侧类型，对于一元运算符而言是参数类型。重载运算符的功能需要使用 &lt;code&gt;operator&lt;/code&gt; 修饰符进行标记。</target>
        </trans-unit>
        <trans-unit id="b851c189b290bdaf55745756936a76cc50344467" translate="yes" xml:space="preserve">
          <source>Kotlin allows you to compile your Kotlin projects to JavaScript modules for popular module systems. Here is the list of available options:</source>
          <target state="translated">Kotlin允许你将你的Kotlin项目编译成JavaScript模块,用于流行的模块系统。下面是可用选项的列表。</target>
        </trans-unit>
        <trans-unit id="9b5fdfaaf9a73290e0eaf81fbe25051b78fa8542" translate="yes" xml:space="preserve">
          <source>Kotlin allows you to enforce symbol visibility (which Python only does via underscore conventions) via &lt;em&gt;visibility modifiers&lt;/em&gt;, which can be placed on symbol declarations. If you don't supply a visibility modifier, you get the default visibility level, which is &lt;em&gt;public&lt;/em&gt;.</source>
          <target state="translated">Kotlin允许您通过&lt;em&gt;可见性修饰符&lt;/em&gt;来强制符号可见性（Python仅通过下划线约定来实现），可以将其放置在符号声明上。如果不提供可见性修改器，则会获得默认的可见性级别，即&lt;em&gt;public&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="abf47a509d1576212045a5d60665d20e7353bdcd" translate="yes" xml:space="preserve">
          <source>Kotlin also has specialized classes to represent arrays of primitive types without boxing overhead: &lt;code&gt;ByteArray&lt;/code&gt;, &lt;code&gt;ShortArray&lt;/code&gt;, &lt;code&gt;IntArray&lt;/code&gt; and so on. These classes have no inheritance relation to the &lt;code&gt;Array&lt;/code&gt; class, but they have the same set of methods and properties. Each of them also has a corresponding factory function:</source>
          <target state="translated">Kotlin还具有专门的类来表示原始类型的数组，而无需装箱： &lt;code&gt;ByteArray&lt;/code&gt; ， &lt;code&gt;ShortArray&lt;/code&gt; ， &lt;code&gt;IntArray&lt;/code&gt; 等。这些类与 &lt;code&gt;Array&lt;/code&gt; 类没有继承关系，但是它们具有相同的方法和属性集。它们每个都具有对应的工厂功能：</target>
        </trans-unit>
        <trans-unit id="7c8be75b3b89d72e9e8ecc5a19439af68c79c8b1" translate="yes" xml:space="preserve">
          <source>Kotlin also supports a conventional notation for floating-point numbers:</source>
          <target state="translated">Kotlin还支持浮点数的传统符号。</target>
        </trans-unit>
        <trans-unit id="fdbc9c499ba317d1129cfbc92871c8a9261e88e6" translate="yes" xml:space="preserve">
          <source>Kotlin and Continuous Integration with TeamCity</source>
          <target state="translated">Kotlin和TeamCity的持续集成</target>
        </trans-unit>
        <trans-unit id="a29301ac26900a11e482b9b5b30d720163c72b02" translate="yes" xml:space="preserve">
          <source>Kotlin and Java sources</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c08b7274c4d1ababf7790a5bd9928dd47f39d9b" translate="yes" xml:space="preserve">
          <source>Kotlin and OSGi</source>
          <target state="translated">Kotlin和OSGi</target>
        </trans-unit>
        <trans-unit id="b68da677f694a6554746e03538ca7213a7ff25e8" translate="yes" xml:space="preserve">
          <source>Kotlin and Swift both define nullability as part of the type specification, while Objc defines nullability on methods and properties of a type. As such, the following:</source>
          <target state="translated">Kotlin和Swift都将nullability定义为类型规范的一部分,而Objc则在类型的方法和属性上定义了nullability。因此,以下。</target>
        </trans-unit>
        <trans-unit id="de39894b7ea202f08e960c5e82b74ef66fdd95ec" translate="yes" xml:space="preserve">
          <source>Kotlin and Swift both define nullability as part of the type specification, while Objective-C defines nullability on methods and properties of a type. As such, the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fab22e5d648c157aabeded51b75888d84156c11e" translate="yes" xml:space="preserve">
          <source>Kotlin applications can be deployed into any host that supports Java Web applications, including Amazon Web Services, Google Cloud Platform and more.</source>
          <target state="translated">Kotlin应用可以部署到任何支持Java Web应用的主机中,包括Amazon Web Services、Google Cloud Platform等。</target>
        </trans-unit>
        <trans-unit id="e02f5529b0cc0cc0f331270b870a1119276c7c49" translate="yes" xml:space="preserve">
          <source>Kotlin as a statically typed programming language plays well for writing Gradle build scripts. Thanks to the static type inference, the Kotlin compiler detects errors earlier and shows important compilation error messages and warnings. Both an IDE and the compiler can use the information about types to infer the available functions and properties in a given scope.</source>
          <target state="translated">Kotlin作为一种静态类型的编程语言,在编写Gradle构建脚本时发挥了很好的作用。得益于静态类型推理,Kotlin编译器可以更早地发现错误,并显示重要的编译错误信息和警告。IDE和编译器都可以使用类型信息来推断给定作用域中的可用函数和属性。</target>
        </trans-unit>
        <trans-unit id="2c6b22009eb8eb5969f5ded032f4849774e1cf34" translate="yes" xml:space="preserve">
          <source>Kotlin by Example</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b0d896d7d9bc79daab4d58d21e623cb98946df3" translate="yes" xml:space="preserve">
          <source>Kotlin can also be used as a scripting language. A script is a Kotlin source file (.kts) with top level executable code.</source>
          <target state="translated">Kotlin也可以作为一种脚本语言使用。脚本是一个包含顶级可执行代码的Kotlin源文件(.kts)。</target>
        </trans-unit>
        <trans-unit id="89f1b06f3d13062a764afffd52c7537a00883d5c" translate="yes" xml:space="preserve">
          <source>Kotlin can also be used as a scripting language. A script is a Kotlin source file (&lt;em&gt;.kts&lt;/em&gt;) with top level executable code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3ea6432cc5a54843d5885315d7e06f428855633" translate="yes" xml:space="preserve">
          <source>Kotlin can be compiled for several different platforms. In this document, we assume that the target platform is the Java virtual machine, which grants some extra capabilities - in particular, your code will be compiled to Java bytecode and will therefore be interoperable with the large ecosystem of Java libraries.</source>
          <target state="translated">Kotlin可以被编译到几个不同的平台上。在本文档中,我们假设目标平台是Java虚拟机,这赋予了一些额外的功能--特别是,您的代码将被编译成Java字节码,因此将与Java库的大型生态系统互操作。</target>
        </trans-unit>
        <trans-unit id="fb59a20f7c43ef0e90a9a5fe239e22f7fac4ccd8" translate="yes" xml:space="preserve">
          <source>Kotlin can be used for any kind of development, be it server-side, client-side web and Android. With Kotlin/Native currently in the works, support for other platforms such as embedded systems, macOS and iOS is coming. People are using Kotlin for mobile and server-side applications, client-side with JavaScript or JavaFX, and data science, just to name a few possibilities.</source>
          <target state="translated">Kotlin可以用于任何类型的开发,无论是服务器端、客户端的Web和Android。目前,Kotlin/Native正在开发中,对其他平台的支持也即将到来,如嵌入式系统、macOS和iOS。人们正在将Kotlin用于移动和服务器端应用,客户端与JavaScript或JavaFX,以及数据科学,这只是一些可能性。</target>
        </trans-unit>
        <trans-unit id="521266653280c8e4a255fb437cafa5ed253cdca4" translate="yes" xml:space="preserve">
          <source>Kotlin can be used together with existing third-party libraries and frameworks, such as jQuery or React. To access third-party frameworks with a strongly-typed API, you can convert TypeScript definitions from the &lt;a href=&quot;http://definitelytyped.org/&quot;&gt;Definitely Typed&lt;/a&gt; type definitions repository to Kotlin using the &lt;a href=&quot;https://github.com/kotlin/ts2kt&quot;&gt;ts2kt&lt;/a&gt; tool. Alternatively, you can use the &lt;a href=&quot;dynamic-type&quot;&gt;dynamic type&lt;/a&gt; to access any framework without strong typing.</source>
          <target state="translated">Kotlin可以与现有的第三方库和框架（例如jQuery或React）一起使用。要使用强类型API访问第三方框架，您可以使用&lt;a href=&quot;https://github.com/kotlin/ts2kt&quot;&gt;ts2kt&lt;/a&gt;工具将TypeScript定义从&amp;ldquo; &lt;a href=&quot;http://definitelytyped.org/&quot;&gt;绝对类型&amp;rdquo;&lt;/a&gt;类型定义存储库转换为Kotlin 。或者，您可以使用&lt;a href=&quot;dynamic-type&quot;&gt;动态类型&lt;/a&gt;来访问任何框架，而无需强类型化。</target>
        </trans-unit>
        <trans-unit id="7c790b4c961dea3d891274def8258c901571e23a" translate="yes" xml:space="preserve">
          <source>Kotlin can get quite close to the compactness of Python's &lt;code&gt;list&lt;/code&gt;/&lt;code&gt;dict&lt;/code&gt;/&lt;code&gt;set&lt;/code&gt; comprehensions. Assuming that &lt;code&gt;people&lt;/code&gt; is a collection of &lt;code&gt;Person&lt;/code&gt; objects with a &lt;code&gt;name&lt;/code&gt; property:</source>
          <target state="translated">Kotlin可以非常接近Python的 &lt;code&gt;list&lt;/code&gt; / &lt;code&gt;dict&lt;/code&gt; / &lt;code&gt;set&lt;/code&gt; 理解的紧凑性。假设 &lt;code&gt;people&lt;/code&gt; 是具有 &lt;code&gt;name&lt;/code&gt; 属性的 &lt;code&gt;Person&lt;/code&gt; 对象的集合：</target>
        </trans-unit>
        <trans-unit id="88373e20528c6bc39fe448071ad8e0db31e3a229" translate="yes" xml:space="preserve">
          <source>Kotlin can't distinguish between numeric types at run time (except for &lt;code&gt;kotlin.Long&lt;/code&gt;), i.e. the following code works:</source>
          <target state="translated">Kotlin在运行时无法区分数字类型（ &lt;code&gt;kotlin.Long&lt;/code&gt; 除外），即以下代码有效：</target>
        </trans-unit>
        <trans-unit id="f14b3e6c2a42d2b616f9f3f45afd4a5a6fa4ccb2" translate="yes" xml:space="preserve">
          <source>Kotlin can't distinguish between numeric types at run time (except for &lt;code&gt;kotlin.Long&lt;/code&gt;), so the following code works:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6add9a81cfef0c10e828238aa1031be87d4fbdd7" translate="yes" xml:space="preserve">
          <source>Kotlin cares a lot about stability and backward compatibility of code: Kotlin compatibility policy says that &quot;breaking changes&quot; (e.g., a change which makes the code that used to compile fine, not compile anymore) can be introduced only in the major releases (1.2, 1.3, etc.).</source>
          <target state="translated">Kotlin非常在意代码的稳定性和向后兼容性。Kotlin的兼容性政策规定,只有在主要版本(1.2、1.3等)中才能引入 &quot;中断性改动&quot;(例如,使过去可以正常编译的代码不再编译的改动)。</target>
        </trans-unit>
        <trans-unit id="7c15ccd2ee8e753a90a11ef141acc11bda9b7db8" translate="yes" xml:space="preserve">
          <source>Kotlin classes and interfaces can be subclassed by Swift/Objective-C classes and protocols.</source>
          <target state="translated">Kotlin类和接口可以被Swift/Objective-C类和协议子类化。</target>
        </trans-unit>
        <trans-unit id="21d314ecbc0aafe901079bc4583e826c76990ca2" translate="yes" xml:space="preserve">
          <source>Kotlin classes have a &lt;code&gt;KotlinBase&lt;/code&gt; base class in Objective-C, the class extends the &lt;code&gt;NSObject&lt;/code&gt; class there. We also have wrappers for collections and exceptions. Most of the collection types are mapped to similar collection types from the other side:</source>
          <target state="translated">Kotlin类在Objective-C中有一个 &lt;code&gt;KotlinBase&lt;/code&gt; 基类，该类在那里扩展了 &lt;code&gt;NSObject&lt;/code&gt; 类。我们也有用于集合和异常的包装器。大部分收集类型从另一端映射到相似的收集类型：</target>
        </trans-unit>
        <trans-unit id="8a8b117cc96a073696a10569a9a03f3366586d14" translate="yes" xml:space="preserve">
          <source>Kotlin code can be easily called from Java. For example, instances of a Kotlin class can be seamlessly created and operated in Java methods. However, there are certain differences between Java and Kotlin that require attention when integrating Kotlin code into Java. On this page, we'll describe the ways to tailor the interop of your Kotlin code with its Java clients.</source>
          <target state="translated">Kotlin代码可以轻松地从Java中调用。例如,Kotlin类的实例可以在Java方法中无缝创建和操作。然而,在将Kotlin代码集成到Java中时,需要注意Java和Kotlin之间的某些差异。在本页中,我们将介绍如何调整Kotlin代码与其Java客户端的互操作。</target>
        </trans-unit>
        <trans-unit id="9fd6821c54cf8552d62d9de4efae79ccdf8ce19d" translate="yes" xml:space="preserve">
          <source>Kotlin collection types and subtypes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="315f6541c31d964f7f6872786a71a0ab54434ee9" translate="yes" xml:space="preserve">
          <source>Kotlin collections (&lt;code&gt;List&lt;/code&gt;, &lt;code&gt;Set&lt;/code&gt;, &lt;code&gt;Map&lt;/code&gt;, etc.) are not mapped to any specific JavaScript type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82a1593c6b9e1c8836da6d1fc4eb0ee62fff00f0" translate="yes" xml:space="preserve">
          <source>Kotlin collections (i.e. &lt;code&gt;List&lt;/code&gt;, &lt;code&gt;Set&lt;/code&gt;, &lt;code&gt;Map&lt;/code&gt;, etc) are not mapped to any specific JavaScript type.</source>
          <target state="translated">Kotlin集合（即 &lt;code&gt;List&lt;/code&gt; ， &lt;code&gt;Set&lt;/code&gt; ， &lt;code&gt;Map&lt;/code&gt; 等）未映射到任何特定的JavaScript类型。</target>
        </trans-unit>
        <trans-unit id="89a478aadf91b074b0da52969af13f23d22bc823" translate="yes" xml:space="preserve">
          <source>Kotlin collections are converted to Swift/Objective-C collections as described in the table above. Swift/Objective-C collections are mapped to Kotlin in the same way, except for &lt;code&gt;NSMutableSet&lt;/code&gt; and &lt;code&gt;NSMutableDictionary&lt;/code&gt;. &lt;code&gt;NSMutableSet&lt;/code&gt; isn't converted to a Kotlin &lt;code&gt;MutableSet&lt;/code&gt;. To pass an object for Kotlin &lt;code&gt;MutableSet&lt;/code&gt;, you can create this kind of Kotlin collection explicitly by either creating it in Kotlin with e.g. &lt;code&gt;mutableSetOf()&lt;/code&gt;, or using the &lt;code&gt;KotlinMutableSet&lt;/code&gt; class in Swift (or &lt;code&gt;${prefix}MutableSet&lt;/code&gt; in Objective-C, where &lt;code&gt;prefix&lt;/code&gt; is the framework names prefix). The same holds for &lt;code&gt;MutableMap&lt;/code&gt;.</source>
          <target state="translated">如上表所述，将Kotlin集合转换为Swift / Objective-C集合。 Swift / Objective-C集合以相同的方式映射到Kotlin，除了 &lt;code&gt;NSMutableSet&lt;/code&gt; 和 &lt;code&gt;NSMutableDictionary&lt;/code&gt; 。 &lt;code&gt;NSMutableSet&lt;/code&gt; 不会转换为Kotlin &lt;code&gt;MutableSet&lt;/code&gt; 。要为Kotlin &lt;code&gt;MutableSet&lt;/code&gt; 传递对象，您可以显式地创建此类Kotlin集合，方法是使用例如 &lt;code&gt;mutableSetOf()&lt;/code&gt; 在Kotlin中创建它，或者在Swift中使用 &lt;code&gt;KotlinMutableSet&lt;/code&gt; 类（或在Objective-C中使用 &lt;code&gt;${prefix}MutableSet&lt;/code&gt; ，其中有 &lt;code&gt;prefix&lt;/code&gt; 是框架名称前缀）。 &lt;code&gt;MutableMap&lt;/code&gt; 也是如此。</target>
        </trans-unit>
        <trans-unit id="b92ab48756ee9ee4eecd8b48a584a882c8254f38" translate="yes" xml:space="preserve">
          <source>Kotlin collections contain functions for commonly used &lt;em&gt;aggregate operations&lt;/em&gt; &amp;ndash; operations that return a single value based on the collection content. Most of them are well known and work the same way as they do in other languages:</source>
          <target state="translated">Kotlin集合包含用于常用&lt;em&gt;聚合操作的&lt;/em&gt;函数，这些函数基于集合内容返回单个值。其中大多数是众所周知的，并且以与其他语言相同的方式工作：</target>
        </trans-unit>
        <trans-unit id="6f6ae7c2ed581955837fb7fe33d78ac601409b90" translate="yes" xml:space="preserve">
          <source>Kotlin collections provide a set of functions for retrieving single elements from collections. Functions described on this page apply to both lists and sets.</source>
          <target state="translated">Kotlin集合提供了一组用于从集合中检索单个元素的函数。本页描述的函数既适用于列表,也适用于集合。</target>
        </trans-unit>
        <trans-unit id="ba542c391d818d9d92362b069b9bf7f9bd8bf71d" translate="yes" xml:space="preserve">
          <source>Kotlin community is open, helpful, and welcoming. Don't hesitate to join and ask on any platform you like:</source>
          <target state="translated">Kotlin社区是开放的,乐于助人的,欢迎大家加入。不要犹豫,加入并在任何你喜欢的平台上询问。</target>
        </trans-unit>
        <trans-unit id="4e7553781e500e3864ae344f47e5a7328b499d62" translate="yes" xml:space="preserve">
          <source>Kotlin compiler generates normal JavaScript classes, functions and properties you can freely use from JavaScript code. Nevertheless, there are some subtle things you should remember.</source>
          <target state="translated">Kotlin编译器可以从JavaScript代码中生成正常的JavaScript类、函数和属性,你可以自由使用。然而,有一些微妙的事情你应该记住。</target>
        </trans-unit>
        <trans-unit id="6a4e8f76fdd58bb0af9bcb56f7360e7af41cc619" translate="yes" xml:space="preserve">
          <source>Kotlin compiler produces byte-code, thus there really is no difference in terms of look and feel of Kotlin applications versus those written in Java.</source>
          <target state="translated">Kotlin编译器产生的是字节码,因此Kotlin应用程序与Java编写的应用程序在外观和感觉上确实没有区别。</target>
        </trans-unit>
        <trans-unit id="254a81c2b10749e0ebcc71c56165e699f0faa1e8" translate="yes" xml:space="preserve">
          <source>Kotlin compiler specifics</source>
          <target state="translated">Kotlin编译器细节</target>
        </trans-unit>
        <trans-unit id="9aad08d33b38b295c66376049aa54dafe55e242e" translate="yes" xml:space="preserve">
          <source>Kotlin compiler would generate the following output</source>
          <target state="translated">Kotlin编译器将产生以下输出</target>
        </trans-unit>
        <trans-unit id="4e6a12781a358b0632ea318dc28241e7061cc96f" translate="yes" xml:space="preserve">
          <source>Kotlin constructors are imported as initializers to Swift/Objective-C.</source>
          <target state="translated">Kotlin构造函数作为初始化器被导入到Swift/Objective-C中。</target>
        </trans-unit>
        <trans-unit id="fd097194728e7a8d4e414220f1c3adc66a1135aa" translate="yes" xml:space="preserve">
          <source>Kotlin documentation is a good place to start, check out these links to get your feet wet:</source>
          <target state="translated">Kotlin文档是一个很好的开始,请查看这些链接来让你的脚步湿润。</target>
        </trans-unit>
        <trans-unit id="22a04b6935ed8f621d145360c7aea12d3366842f" translate="yes" xml:space="preserve">
          <source>Kotlin does not have Python's &lt;em&gt;resource managers&lt;/em&gt; or Java's &lt;em&gt;try-with-resources&lt;/em&gt;, but thanks to extension functions, there's &lt;code&gt;use&lt;/code&gt;:</source>
          <target state="translated">Kotlin没有Python的&lt;em&gt;资源管理器&lt;/em&gt;或Java的&lt;em&gt;try-with-resources&lt;/em&gt;，但是由于具有扩展功能，因此可以 &lt;code&gt;use&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="8da11f04c1c3d7dbbef032228e63afa6f04d63f3" translate="yes" xml:space="preserve">
          <source>Kotlin does not have checked &lt;a href=&quot;exceptions&quot;&gt;exceptions&lt;/a&gt;</source>
          <target state="translated">Kotlin没有检查的&lt;a href=&quot;exceptions&quot;&gt;异常&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="58e8fc7ba9fc6ab7f17a343e98ca51e5a850e480" translate="yes" xml:space="preserve">
          <source>Kotlin does not have checked exceptions. There are many reasons for this, but we will provide a simple example.</source>
          <target state="translated">Kotlin没有检查异常。这有很多原因,但我们将提供一个简单的例子。</target>
        </trans-unit>
        <trans-unit id="7ea8df84918172c874d6ce26a2d2ac8d56eff8a7" translate="yes" xml:space="preserve">
          <source>Kotlin does not implement lazy initialization of top-level properties in JavaScript.</source>
          <target state="translated">Kotlin在JavaScript中没有实现顶层属性的懒惰初始化。</target>
        </trans-unit>
        <trans-unit id="1c19ec6ca29946106579b7774a9f16c5845ebbc2" translate="yes" xml:space="preserve">
          <source>Kotlin ensures type safety of operations involving &lt;a href=&quot;generics&quot;&gt;generics&lt;/a&gt; at compile time, while, at runtime, instances of generic types hold no information about their actual type arguments. For example, &lt;code&gt;List&amp;lt;Foo&amp;gt;&lt;/code&gt; is erased to just &lt;code&gt;List&amp;lt;*&amp;gt;&lt;/code&gt;. In general, there is no way to check whether an instance belongs to a generic type with certain type arguments at runtime.</source>
          <target state="translated">Kotlin确保在编译时涉及&lt;a href=&quot;generics&quot;&gt;泛型&lt;/a&gt;的操作的类型安全，而在运行时，泛型类型的实例不保存有关其实际类型参数的信息。例如，将 &lt;code&gt;List&amp;lt;Foo&amp;gt;&lt;/code&gt; 删除为 &lt;code&gt;List&amp;lt;*&amp;gt;&lt;/code&gt; 。通常，无法在运行时检查实例是否属于具有某些类型参数的泛型类型。</target>
        </trans-unit>
        <trans-unit id="e3093475043dd707a8b9c1069aead086bf16cf6d" translate="yes" xml:space="preserve">
          <source>Kotlin exposes its package structure to JavaScript, so unless you define your declarations in the root package, you have to use fully qualified names in JavaScript. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bbcaf4c7dfc1607eaa4b2ffde25fea37b6fff50b" translate="yes" xml:space="preserve">
          <source>Kotlin exposes its package structure to JavaScript, so unless you define your declarations in the root package, you have to use fully-qualified names in JavaScript. For example:</source>
          <target state="translated">Kotlin将其包结构暴露给JavaScript,所以除非你在根包中定义你的声明,否则你必须在JavaScript中使用完全限定的名称。比如说</target>
        </trans-unit>
        <trans-unit id="7be04058c2375c4141e803b8f5f5c3ef0ebe450b" translate="yes" xml:space="preserve">
          <source>Kotlin extensions to &quot;regular&quot; Kotlin classes are imported to Swift and Objective-C as extensions and category members respectively. Kotlin extensions to other types are treated as &lt;a href=&quot;#top-level-functions-and-properties&quot;&gt;top-level declarations&lt;/a&gt; with an additional receiver parameter. These types include:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6bd032e19c9c721a60ec9014384d50331ee1d338" translate="yes" xml:space="preserve">
          <source>Kotlin fixes a series of issues that Java suffers from:</source>
          <target state="translated">Kotlin修复了Java存在的一系列问题。</target>
        </trans-unit>
        <trans-unit id="2e70b9b4257b183b5c7e10570483451ad725fc8a" translate="yes" xml:space="preserve">
          <source>Kotlin follows the Java naming conventions. In particular:</source>
          <target state="translated">Kotlin遵循Java的命名惯例。特别是:</target>
        </trans-unit>
        <trans-unit id="0548deb8694e8bfa87792c4e732edf938085eb1e" translate="yes" xml:space="preserve">
          <source>Kotlin for Android Case Studies</source>
          <target state="translated">Kotlin for Android案例研究</target>
        </trans-unit>
        <trans-unit id="c1441b497e656bddb290de8de9224360e00ecbdf" translate="yes" xml:space="preserve">
          <source>Kotlin for Android Developers</source>
          <target state="translated">Kotlin for Android Developers</target>
        </trans-unit>
        <trans-unit id="7b2f1c8edda5c1d58bf2a573a1626581c631617c" translate="yes" xml:space="preserve">
          <source>Kotlin for Java Developers</source>
          <target state="translated">Kotlin for Java Developers</target>
        </trans-unit>
        <trans-unit id="e6f31bf50fe73009407bd97cfc46c1659646cb16" translate="yes" xml:space="preserve">
          <source>Kotlin function types and subtypes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe6b04ae909883df5d80ca51aec87a07bb290e41" translate="yes" xml:space="preserve">
          <source>Kotlin function-typed objects (e.g. lambdas) are converted to Swift functions / Objective-C blocks. However there is a difference in how types of parameters and return values are mapped when translating a function and a function type. In the latter case primitive types are mapped to their boxed representation. Kotlin &lt;code&gt;Unit&lt;/code&gt; return value is represented as a corresponding &lt;code&gt;Unit&lt;/code&gt; singleton in Swift/Objective-C. The value of this singleton can be retrieved in the same way as it is for any other Kotlin &lt;code&gt;object&lt;/code&gt; (see singletons in the table above). To sum the things up:</source>
          <target state="translated">Kotlin函数类型的对象（例如lambda）将转换为Swift函数/ Objective-C块。但是，在转换函数和函数类型时如何映射参数类型和返回值是有区别的。在后一种情况下，原始类型被映射到其盒装表示形式。 Kotlin &lt;code&gt;Unit&lt;/code&gt; 返回值在Swift / Objective-C中表示为对应的 &lt;code&gt;Unit&lt;/code&gt; 单例。可以使用与其他任何Kotlin &lt;code&gt;object&lt;/code&gt; 相同的方式来检索此单例的值（请参阅上表中的单例）。总结一下：</target>
        </trans-unit>
        <trans-unit id="6377c81eb40cd3205e240b814a78f31b9c3b2c4e" translate="yes" xml:space="preserve">
          <source>Kotlin functions are &lt;a href=&quot;https://en.wikipedia.org/wiki/First-class_function&quot;&gt;&lt;em&gt;first-class&lt;/em&gt;&lt;/a&gt;, which means that they can be stored in variables and data structures, passed as arguments to and returned from other &lt;a href=&quot;#higher-order-functions&quot;&gt;higher-order functions&lt;/a&gt;. You can operate with functions in any way that is possible for other non-function values.</source>
          <target state="translated">Kotlin函数是&lt;a href=&quot;https://en.wikipedia.org/wiki/First-class_function&quot;&gt;&lt;em&gt;一流的&lt;/em&gt;&lt;/a&gt;，这意味着它们可以存储在变量和数据结构中，作为参数传递给其他&lt;a href=&quot;#higher-order-functions&quot;&gt;高阶函数或&lt;/a&gt;从其他高阶函数返回。您可以通过其他非函数值可能使用的任何方式来使用函数。</target>
        </trans-unit>
        <trans-unit id="06212cca9855d4bc50a6216a937f6da059a9c0cc" translate="yes" xml:space="preserve">
          <source>Kotlin generate JavaScript code that is compatible with Asynchronous Module Definition (AMD), CommonJS and Universal Model Definition (UMD).</source>
          <target state="translated">Kotlin生成与异步模块定义(AMD)、CommonJS和通用模型定义(UMD)兼容的JavaScript代码。</target>
        </trans-unit>
        <trans-unit id="7e3d5465bac3e356284fe278ce3583ae2129ce4a" translate="yes" xml:space="preserve">
          <source>Kotlin handles numbers in a way close to Java, but not exactly the same. For example, there are no implicit widening conversions for numbers, and literals are slightly different in some cases.</source>
          <target state="translated">Kotlin处理数字的方式与Java接近,但不完全相同。例如,数字没有隐式的加宽转换,而且在某些情况下,字形也略有不同。</target>
        </trans-unit>
        <trans-unit id="a419931ca3da367222b771f7660e3ff6428af9ed" translate="yes" xml:space="preserve">
          <source>Kotlin has a rather small runtime file size: the library is approximately 964KB (as of 1.3.41). This means Kotlin adds just a little to .apk file size.</source>
          <target state="translated">Kotlin有一个相当小的运行时文件大小:该库约为964KB(截至1.3.41)。这意味着Kotlin只增加了一点.apk文件大小。</target>
        </trans-unit>
        <trans-unit id="1a3e60d485f88e60187d3caa5025c740961ab3aa" translate="yes" xml:space="preserve">
          <source>Kotlin has an extensive standard library that can be used in your applications. Configure the following dependency in the pom file:</source>
          <target state="translated">Kotlin有一个广泛的标准库,可以在您的应用程序中使用。在 pom 文件中配置以下依赖关系。</target>
        </trans-unit>
        <trans-unit id="ab1e60d19725004dca25a2263f17ef1cdb84890e" translate="yes" xml:space="preserve">
          <source>Kotlin has been successfully adopted by major companies, and a few of them have shared their experiences:</source>
          <target state="translated">Kotlin已经被各大公司成功采用,其中有几家公司分享了他们的经验。</target>
        </trans-unit>
        <trans-unit id="3ed9d85f3169bc5321f12531a1c541d127d00550" translate="yes" xml:space="preserve">
          <source>Kotlin has both object-oriented and functional constructs. You can use it in both OO and FP styles, or mix elements of the two. With first-class support for features such as higher-order functions, function types and lambdas, Kotlin is a great choice if you&amp;rsquo;re doing or exploring functional programming.</source>
          <target state="translated">Kotlin具有面向对象和功能构造。您可以在OO和FP样式中使用它，或将两者的元素混合使用。凭借对高阶函数，函数类型和lambda等功能的一流支持，如果您正在或正在探索函数式编程，则Kotlin是一个不错的选择。</target>
        </trans-unit>
        <trans-unit id="d0b80a6eafa346308b4f2ffbb72d503567999d28" translate="yes" xml:space="preserve">
          <source>Kotlin has classes and their members &lt;code&gt;final&lt;/code&gt; by default, which makes it inconvenient to use frameworks and libraries such as Spring AOP that require classes to be &lt;code&gt;open&lt;/code&gt;. The &lt;em&gt;all-open&lt;/em&gt; compiler plugin adapts Kotlin to the requirements of those frameworks and makes classes annotated with a specific annotation and their members open without the explicit &lt;code&gt;open&lt;/code&gt; keyword.</source>
          <target state="translated">Kotlin 默认具有类及其成员 &lt;code&gt;final&lt;/code&gt; ，这使得使用要求类是 &lt;code&gt;open&lt;/code&gt; 框架和库（例如Spring AOP）变得不便。在&lt;em&gt;所有开放式&lt;/em&gt;编译器插件适应科特林到这些框架的要求，并与特定的注解类及其成员没有明确的开 &lt;code&gt;open&lt;/code&gt; 的关键字。</target>
        </trans-unit>
        <trans-unit id="b816faaaa048d52b55167846f58533c82dcf332c" translate="yes" xml:space="preserve">
          <source>Kotlin has got its own reflection library (&lt;code&gt;kotlin-reflect.jar&lt;/code&gt; must be included in your build). When targeting the JVM, you can also use the Java reflection facilities. Note that the Kotlin reflection isn't quite feature-complete yet - in particular, you can't use it to inspect built-in classes like &lt;code&gt;String&lt;/code&gt;.</source>
          <target state="translated">Kotlin有自己的反射库（您的构建中必须包含 &lt;code&gt;kotlin-reflect.jar&lt;/code&gt; ）。以JVM为目标时，您也可以使用Java反射工具。请注意，Kotlin反射功能还不够完善-特别是，您不能使用它来检查诸如 &lt;code&gt;String&lt;/code&gt; 之类的内置类。</target>
        </trans-unit>
        <trans-unit id="89599a2b8afb959091521970edd698c7f8696cca" translate="yes" xml:space="preserve">
          <source>Kotlin has inherited Java's fidgety (but very flexible) way of doing I/O, but with some simplifying extra features. We won't get into all of it here, so for starters, this is how to iterate through all the lines of a file (you'll need &lt;code&gt;import java.io.File&lt;/code&gt;):</source>
          <target state="translated">Kotlin继承了Java的烦躁（但非常灵活）的I / O方式，但是简化了一些附加功能。我们不会在这里介绍所有内容，因此对于初学者来说，这是遍历文件的所有行的方式（您需要 &lt;code&gt;import java.io.File&lt;/code&gt; ）：</target>
        </trans-unit>
        <trans-unit id="789ece85cba2d7c5232dc414bc11dc159641da4f" translate="yes" xml:space="preserve">
          <source>Kotlin has inherited Java's fidgety array system, so primitive types have got their own array types and conversion functions, while any other type uses the generic &lt;code&gt;Array&lt;/code&gt; type, to which you can convert with &lt;code&gt;.toTypedArray()&lt;/code&gt;.</source>
          <target state="translated">Kotlin继承了Java的烦躁数组系统，因此原始类型具有自己的数组类型和转换函数，而其他任何类型都使用通用 &lt;code&gt;Array&lt;/code&gt; 类型，可以使用 &lt;code&gt;.toTypedArray()&lt;/code&gt; 转换为该类型。</target>
        </trans-unit>
        <trans-unit id="99a77fa93b5373d975ec4157225559f8cd6c6cb3" translate="yes" xml:space="preserve">
          <source>Kotlin has no concept of checked exceptions, all Kotlin exceptions are unchecked. Swift has only checked errors. So if Swift or Objective-C code calls a Kotlin method which throws an exception to be handled, then the Kotlin method should be marked with a &lt;code&gt;@Throws&lt;/code&gt; annotation specifying a list of &quot;expected&quot; exception classes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e626b593df468862004f3cb251d2e1710f0e139" translate="yes" xml:space="preserve">
          <source>Kotlin has no concept of checked exceptions, all Kotlin exceptions are unchecked. Swift has only checked errors. So if Swift or Objective-C code calls a Kotlin method which throws an exception to be handled, then the Kotlin method should be marked with a &lt;code&gt;@Throws&lt;/code&gt; annotation. In this case all Kotlin exceptions (except for instances of &lt;code&gt;Error&lt;/code&gt;, &lt;code&gt;RuntimeException&lt;/code&gt; and subclasses) are translated into a Swift error/&lt;code&gt;NSError&lt;/code&gt;.</source>
          <target state="translated">Kotlin没有检查异常的概念，所有Kotlin异常都是未检查的。 Swift仅检查了错误。因此，如果Swift或Objective-C代码调用了抛出异常进行处理的Kotlin方法，则Kotlin方法应使用 &lt;code&gt;@Throws&lt;/code&gt; 批注进行标记。在这种情况下，所有Kotlin异常（ &lt;code&gt;Error&lt;/code&gt; ， &lt;code&gt;RuntimeException&lt;/code&gt; 和子类的实例除外）都转换为Swift错误/ &lt;code&gt;NSError&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="178ebff753223a76976f1b5505609a06e7a0941e" translate="yes" xml:space="preserve">
          <source>Kotlin has now the option of generating Java 8 bytecode (&lt;code&gt;-jvm-target 1.8&lt;/code&gt; command line option or the corresponding options in Ant/Maven/Gradle). For now this doesn't change the semantics of the bytecode (in particular, default methods in interfaces and lambdas are generated exactly as in Kotlin 1.0), but we plan to make further use of this later.</source>
          <target state="translated">Kotlin现在可以选择生成Java 8字节码（ &lt;code&gt;-jvm-target 1.8&lt;/code&gt; 命令行选项或Ant / Maven / Gradle中的相应选项）。目前，这不会改变字节码的语义（特别是，接口和lambda中的默认方法的生成与Kotlin 1.0中的完全相同），但是我们计划稍后再使用它。</target>
        </trans-unit>
        <trans-unit id="1b256a14cb898b1876ca682918ab4726ae689547" translate="yes" xml:space="preserve">
          <source>Kotlin has proper &lt;a href=&quot;lambdas#function-types&quot;&gt;function types&lt;/a&gt;, as opposed to Java's SAM-conversions</source>
          <target state="translated">与Java的SAM转换相反，Kotlin具有适当的&lt;a href=&quot;lambdas#function-types&quot;&gt;函数类型&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="21d65ae753898818d1cd1395d2b3d50ce49c4d34" translate="yes" xml:space="preserve">
          <source>Kotlin has three structural jump expressions:</source>
          <target state="translated">Kotlin有三种结构跳转表达方式。</target>
        </trans-unit>
        <trans-unit id="8fab1b92010786ac4e42e500d9dbd613684af3aa" translate="yes" xml:space="preserve">
          <source>Kotlin has two types of string literals: escaped strings that may have escaped characters in them and raw strings that can contain newlines and arbitrary text. An escaped string is very much like a Java string:</source>
          <target state="translated">Kotlin有两种类型的字符串字元:可能包含转义字符的转义字符串和可以包含换行符和任意文本的原始字符串。转义字符串很像Java字符串。</target>
        </trans-unit>
        <trans-unit id="88377cf789dc237868418b003f1376d4a4fb9cfb" translate="yes" xml:space="preserve">
          <source>Kotlin has two types of string literals: escaped strings that may have escaped characters in them and raw strings that can contain newlines and arbitrary text. Here's an example of an escaped string:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c53d6c43db7159858e1b06d40910057344f857d" translate="yes" xml:space="preserve">
          <source>Kotlin in Action</source>
          <target state="translated">Kotlin在行动</target>
        </trans-unit>
        <trans-unit id="897dddb8bded8aacac7c4f7f6865ba43edeed083" translate="yes" xml:space="preserve">
          <source>Kotlin introduces following types for unsigned integers:</source>
          <target state="translated">Kotlin为无符号整数引入了以下类型。</target>
        </trans-unit>
        <trans-unit id="1162e3ef7e5343b47c0a5de3586b0dd6d01591ce" translate="yes" xml:space="preserve">
          <source>Kotlin is a compiled, statically typed language, which might provide some initial hurdles for people who are used to the interpreted, dynamically typed Python. This document aims to explain a substantial portion of Kotlin's syntax and concepts in terms of how they compare to corresponding concepts in Python.</source>
          <target state="translated">Kotlin 是一门编译过的静态类型语言,这可能会给习惯了解释型、动态类型 Python 的人带来一些初始障碍。本文档旨在解释Kotlin的语法和概念中的相当一部分与Python中相应概念的比较。</target>
        </trans-unit>
        <trans-unit id="640ddadf7e88f55374061d5998c2bee5a53626f4" translate="yes" xml:space="preserve">
          <source>Kotlin is a great fit for developing Android applications, bringing all of the advantages of a modern language to the Android platform without introducing any new restrictions:</source>
          <target state="translated">Kotlin非常适合开发Android应用,它将现代语言的所有优点带到了Android平台,而不会引入任何新的限制。</target>
        </trans-unit>
        <trans-unit id="b1f1b3f12f705373f46ad38b06f457675f0bb145" translate="yes" xml:space="preserve">
          <source>Kotlin is a great fit for developing server-side applications, allowing you to write concise and expressive code while maintaining full compatibility with existing Java-based technology stacks and a smooth learning curve:</source>
          <target state="translated">Kotlin非常适合开发服务器端应用程序,它允许你编写简洁而富有表现力的代码,同时保持与现有的基于Java的技术栈的完全兼容,并保持平滑的学习曲线。</target>
        </trans-unit>
        <trans-unit id="942fb98d86e153b0e83fe0d61de04cbccacbe8f7" translate="yes" xml:space="preserve">
          <source>Kotlin is a pragmatic and unopinionated language, supporting both imperative and function programming styles without pushing the developer towards either one. We can implement the function &lt;code&gt;f&lt;/code&gt; in functional style, using such Kotlin features as &lt;a href=&quot;../reference/functions#tail-recursive-functions&quot;&gt;tail recursion&lt;/a&gt;:</source>
          <target state="translated">Kotlin是一种实用且不受质疑的语言，支持命令式和函数式编程风格，而不会迫使开发人员选择任何一种。我们可以使用&lt;a href=&quot;../reference/functions#tail-recursive-functions&quot;&gt;尾部递归&lt;/a&gt;等Kotlin功能以函数形式实现函数 &lt;code&gt;f&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="c0d8f4fd81a58ee08fc7afcc5cfdb0b02c31ab79" translate="yes" xml:space="preserve">
          <source>Kotlin is a statically typed language, which makes it different from the dynamically typed JavaScript. In order to facilitate interoperation with JavaScript code, Kotlin/JS offers the &lt;code&gt;dynamic&lt;/code&gt; type:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f033af0ab747811276c086c79a9bfc947c92c7d6" translate="yes" xml:space="preserve">
          <source>Kotlin is an OSS statically typed programming language that targets the JVM, Android, JavaScript and Native. It&amp;rsquo;s developed by &lt;a href=&quot;http://www.jetbrains.com&quot;&gt;JetBrains&lt;/a&gt;. The project started in 2010 and was open source from very early on. The first official 1.0 release was in February 2016.</source>
          <target state="translated">Kotlin是OSS静态类型的编程语言，主要针对JVM，Android，JavaScript和Native。它由&lt;a href=&quot;http://www.jetbrains.com&quot;&gt;JetBrains开发&lt;/a&gt;。该项目于2010年开始，从一开始就是开源的。第一个官方1.0版本于2016年2月发布。</target>
        </trans-unit>
        <trans-unit id="654d332c5c16069d8e33851920e04af4ba1633e6" translate="yes" xml:space="preserve">
          <source>Kotlin is an open-source statically typed programming language that targets the JVM, Android, JavaScript and Native. It&amp;rsquo;s developed by &lt;a href=&quot;http://www.jetbrains.com&quot;&gt;JetBrains&lt;/a&gt;. The project started in 2010 and was open source from very early on. The first official 1.0 release was in February 2016.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9537d803964341dc28f1f4951da5b348b7b611e" translate="yes" xml:space="preserve">
          <source>Kotlin is compatible with CommonJS, AMD and UMD, &lt;a href=&quot;../tutorials/javascript/working-with-modules/working-with-modules&quot;&gt;making interaction with different&lt;/a&gt; module systems straightforward.</source>
          <target state="translated">Kotlin与CommonJS，AMD和UMD兼容，&lt;a href=&quot;../tutorials/javascript/working-with-modules/working-with-modules&quot;&gt;从而使与不同&lt;/a&gt;模块系统的交互变得简单。</target>
        </trans-unit>
        <trans-unit id="2c3ca5bc7aa971f25976aff86462ee8c65c9cb7e" translate="yes" xml:space="preserve">
          <source>Kotlin is designed to be a pragmatic tool for programmers. When it comes to language evolution, its pragmatic nature is captured by the following principles:</source>
          <target state="translated">Kotlin被设计为程序员的实用性工具。在语言进化方面,它的实用性由以下原则来体现。</target>
        </trans-unit>
        <trans-unit id="93c08e581c43a4ec4822d841d4ddc6b6324821eb" translate="yes" xml:space="preserve">
          <source>Kotlin is designed to be easy to learn for people who already know Java. A quick overview of differences is given on &lt;a href=&quot;../reference/comparison-to-java&quot;&gt;the official comparison page&lt;/a&gt;. A short introduction to the basic syntax of Kotlin for software developers can be found directly in the reference section of the web site starting from &lt;a href=&quot;../reference/basic-syntax&quot;&gt;basic syntax&lt;/a&gt;.</source>
          <target state="translated">Kotlin的设计使已经熟悉Java的人易于学习。&lt;a href=&quot;../reference/comparison-to-java&quot;&gt;官方比较页面&lt;/a&gt;上提供了差异的快速概述。简短的介绍科特林的面向软件开发人员的基本语法可以直接在网站上从开始的参考部分找到&lt;a href=&quot;../reference/basic-syntax&quot;&gt;基本语法&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="76527281e23251ab9b22562a01f9e2381d26e878" translate="yes" xml:space="preserve">
          <source>Kotlin is designed with Java Interoperability in mind. Existing Java code can be called from Kotlin in a natural way, and Kotlin code can be used from Java rather smoothly as well. In this section we describe some details about calling Java code from Kotlin.</source>
          <target state="translated">Kotlin在设计时就考虑到了Java的互操作性,现有的Java代码可以很自然地从Kotlin中调用,而Kotlin代码也可以很顺利地从Java中使用。现有的Java代码可以很自然地从Kotlin中调用,Kotlin代码也可以很顺利地从Java中使用。在本节中,我们将介绍一些关于从Kotlin调用Java代码的细节。</target>
        </trans-unit>
        <trans-unit id="b1117330525358e715dea7a8875981cd28a616bf" translate="yes" xml:space="preserve">
          <source>Kotlin is distributed with &lt;code&gt;kotlin.js&lt;/code&gt; standard library as a single file, which is itself compiled as an UMD module, so you can use it with any module system described above. Also it is available on NPM as &lt;a href=&quot;https://www.npmjs.com/package/kotlin&quot;&gt;&lt;code&gt;kotlin&lt;/code&gt; package&lt;/a&gt;</source>
          <target state="translated">Kotlin与 &lt;code&gt;kotlin.js&lt;/code&gt; 标准库一起作为单个文件分发，该文件本身已编译为UMD模块，因此您可以将其与上述任何模块系统一起使用。也可以在NPM上以&lt;a href=&quot;https://www.npmjs.com/package/kotlin&quot;&gt; &lt;code&gt;kotlin&lt;/code&gt; 软件包形式购买&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d0a18e9cef9fc2a234c1d159c10281aea5af17fa" translate="yes" xml:space="preserve">
          <source>Kotlin is distributed with the Kotlin/JS standard library as a single file, which is itself compiled as an UMD module, so you can use it with any module system described above. While for most use cases of Kotlin/JS, it is recommended to use a Gradle dependency on &lt;code&gt;kotlin-stdlib-js&lt;/code&gt;, it is also available on NPM as the &lt;a href=&quot;https://www.npmjs.com/package/kotlin&quot;&gt;&lt;code&gt;kotlin&lt;/code&gt;&lt;/a&gt; package.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0bb12b617173b78ae2213fea703120a48dac83b8" translate="yes" xml:space="preserve">
          <source>Kotlin is inspired by existing languages such as Java, C#, JavaScript, Scala and Groovy. We've tried to ensure that Kotlin is easy to learn, so that people can easily jump on board, reading and writing Kotlin in a matter of days. Learning idiomatic Kotlin and using some more of its advanced features can take a little longer, but overall it is not a complicated language.</source>
          <target state="translated">Kotlin的灵感来自于现有的语言,如Java、C#、JavaScript、Scala和Groovy。我们试图确保Kotlin易于学习,因此人们可以很容易地跳上船,在几天内阅读和编写Kotlin。学习习惯性的Kotlin和使用它的一些更高级的功能可能需要更长的时间,但总的来说它并不是一门复杂的语言。</target>
        </trans-unit>
        <trans-unit id="62c8094d2f49ea185993571453009f8f90b8b387" translate="yes" xml:space="preserve">
          <source>Kotlin is more concise. Rough estimates indicate approximately a 40% cut in the number of lines of code. It&amp;rsquo;s also more type-safe, e.g. support for non-nullable types makes applications less prone to NPE&amp;rsquo;s. Other features including smart casting, higher-order functions, extension functions and lambdas with receivers provide the ability to write expressive code as well as facilitating creation of DSL.</source>
          <target state="translated">Kotlin更简洁。粗略估计表明代码行数减少了约40％。它还具有更好的类型安全性，例如，对非空类型的支持使应用程序不易使用NPE。其他功能包括智能强制转换，高阶功能，扩展功能和带有接收器的Lambda，这些功能可以编写表达性代码并促进DSL的创建。</target>
        </trans-unit>
        <trans-unit id="57ebc857aaa4fe4ee76557729aedd97eb250b716" translate="yes" xml:space="preserve">
          <source>Kotlin is primarily developed by a team of engineers at JetBrains (current team size is 100+). The lead language designer is &lt;a href=&quot;https://twitter.com/abreslav&quot;&gt;Andrey Breslav&lt;/a&gt;. In addition to the core team, there are also over 250 external contributors on GitHub.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a6891160d562ed8798489fdde041cf7382a9267" translate="yes" xml:space="preserve">
          <source>Kotlin is primarily developed by a team of engineers at JetBrains (current team size is 50+). The lead language designer is &lt;a href=&quot;https://twitter.com/abreslav&quot;&gt;Andrey Breslav&lt;/a&gt;. In addition to the core team, there are also over 250 external contributors on GitHub.</source>
          <target state="translated">Kotlin主要由JetBrains的工程师团队开发（目前的团队规模为50+）。首席语言设计师是&lt;a href=&quot;https://twitter.com/abreslav&quot;&gt;Andrey Breslav&lt;/a&gt;。除了核心团队，GitHub上还有250多个外部贡献者。</target>
        </trans-unit>
        <trans-unit id="e252e4cd43e2222ef996694efabbf2a368b1568c" translate="yes" xml:space="preserve">
          <source>Kotlin is supported by all major Java IDEs including &lt;a href=&quot;../tutorials/getting-started&quot;&gt;IntelliJ IDEA&lt;/a&gt;, &lt;a href=&quot;../tutorials/kotlin-android&quot;&gt;Android Studio&lt;/a&gt;, &lt;a href=&quot;../tutorials/getting-started-eclipse&quot;&gt;Eclipse&lt;/a&gt; and &lt;a href=&quot;http://plugins.netbeans.org/plugin/68590/kotlin&quot;&gt;NetBeans&lt;/a&gt;. In addition, a &lt;a href=&quot;../tutorials/command-line&quot;&gt;command line compiler&lt;/a&gt; is available and provides straightforward support for compiling and running applications.</source>
          <target state="translated">所有主要的Java IDE（包括&lt;a href=&quot;../tutorials/getting-started&quot;&gt;IntelliJ IDEA&lt;/a&gt;，&lt;a href=&quot;../tutorials/kotlin-android&quot;&gt;Android Studio&lt;/a&gt;，&lt;a href=&quot;../tutorials/getting-started-eclipse&quot;&gt;Eclipse&lt;/a&gt;和&lt;a href=&quot;http://plugins.netbeans.org/plugin/68590/kotlin&quot;&gt;NetBeans）&lt;/a&gt;都支持Kotlin 。此外，还提供了&lt;a href=&quot;../tutorials/command-line&quot;&gt;命令行编译器&lt;/a&gt;，它为编译和运行应用程序提供了直接的支持。</target>
        </trans-unit>
        <trans-unit id="8b9c46bf1ad2fe2fbc414ecfb85cf4b65bec1ff6" translate="yes" xml:space="preserve">
          <source>Kotlin is supported by all major Java IDEs including &lt;a href=&quot;../tutorials/jvm-get-started&quot;&gt;IntelliJ IDEA&lt;/a&gt;, &lt;a href=&quot;https://developer.android.com/kotlin/get-started&quot;&gt;Android Studio&lt;/a&gt;, &lt;a href=&quot;../tutorials/getting-started-eclipse&quot;&gt;Eclipse&lt;/a&gt; and &lt;a href=&quot;http://plugins.netbeans.org/plugin/68590/kotlin&quot;&gt;NetBeans&lt;/a&gt;. In addition, a &lt;a href=&quot;../tutorials/command-line&quot;&gt;command line compiler&lt;/a&gt; is available and provides straightforward support for compiling and running applications.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38b8eb152c426ee3fe939706153705b8354595aa" translate="yes" xml:space="preserve">
          <source>Kotlin is well covered in online courses, check out recommended courses here:</source>
          <target state="translated">Kotlin在在线课程中的覆盖率很高,在这里查看推荐课程。</target>
        </trans-unit>
        <trans-unit id="f6275eeb32172070d309b650be85e7156b1c7dc9" translate="yes" xml:space="preserve">
          <source>Kotlin lets you choose the version of JVM for execution. By default, the Kotlin/JVM compiler produces Java 6 compatible bytecode. If you want to make use of optimizations available in newer versions of Java, you can explicitly specify the target Java version from 8 to 13. Note that in this case the resulting bytecode might not run on lower versions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47b75c21f1512e55023917a6b77552862460e120" translate="yes" xml:space="preserve">
          <source>Kotlin lets you easily create ranges of values using the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.ranges/range-to&quot;&gt;&lt;code&gt;rangeTo()&lt;/code&gt;&lt;/a&gt; function from the &lt;code&gt;kotlin.ranges&lt;/code&gt; package and its operator form &lt;code&gt;..&lt;/code&gt;. Usually, &lt;code&gt;rangeTo()&lt;/code&gt; is complemented by &lt;code&gt;in&lt;/code&gt; or &lt;code&gt;!in&lt;/code&gt; functions.</source>
          <target state="translated">科特林让您轻松创建使用值的范围&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.ranges/range-to&quot;&gt; &lt;code&gt;rangeTo()&lt;/code&gt; &lt;/a&gt;从功能 &lt;code&gt;kotlin.ranges&lt;/code&gt; 包及其操作的形式 &lt;code&gt;..&lt;/code&gt; 。通常， &lt;code&gt;rangeTo()&lt;/code&gt; 由 &lt;code&gt;in&lt;/code&gt; 或 &lt;code&gt;!in&lt;/code&gt; 函数补充。</target>
        </trans-unit>
        <trans-unit id="ceee386e40b3b46c69160d750c22ce62d0c3f184" translate="yes" xml:space="preserve">
          <source>Kotlin lets you manipulate collections independently of the exact type of objects stored in them. In other words, you add a &lt;code&gt;String&lt;/code&gt; to a list of &lt;code&gt;String&lt;/code&gt;s the same way as you would do with &lt;code&gt;Int&lt;/code&gt;s or a user-defined class. So, the Kotlin Standard Library offers generic interfaces, classes, and functions for creating, populating, and managing collections of any type.</source>
          <target state="translated">Kotlin使您可以独立于存储在其中的对象的确切类型来操作集合。换句话说，你添加一个 &lt;code&gt;String&lt;/code&gt; 到列表 &lt;code&gt;String&lt;/code&gt; S中的同样的方式，你会用做 &lt;code&gt;Int&lt;/code&gt; S或用户定义的类。因此，Kotlin标准库提供了用于创建，填充和管理任何类型的集合的通用接口，类和函数。</target>
        </trans-unit>
        <trans-unit id="8bb9f52709d9b5cdac5f51755d862ecbca9c415c" translate="yes" xml:space="preserve">
          <source>Kotlin metadata</source>
          <target state="translated">Kotlin元数据</target>
        </trans-unit>
        <trans-unit id="0e7ef1544d45f6a307acf242d3ddb29c611697ae" translate="yes" xml:space="preserve">
          <source>Kotlin modules can be used in Swift/Objective-C code if compiled into a framework (see &quot;Targets and output kinds&quot; section in &lt;a href=&quot;gradle_plugin#targets-and-output-kinds&quot;&gt;Gradle plugin documentation&lt;/a&gt;). See &lt;a href=&quot;https://github.com/JetBrains/kotlin-native/tree/master/samples/calculator&quot;&gt;calculator sample&lt;/a&gt; for an example.</source>
          <target state="translated">如果将Kotlin模块编译成框架，则可以在Swift / Objective-C代码中使用（请参阅&lt;a href=&quot;gradle_plugin#targets-and-output-kinds&quot;&gt;Gradle插件文档中的&lt;/a&gt; &amp;ldquo;目标和输出种类&amp;rdquo;部分）。有关&lt;a href=&quot;https://github.com/JetBrains/kotlin-native/tree/master/samples/calculator&quot;&gt;示例&lt;/a&gt;，请参见计算器示例。</target>
        </trans-unit>
        <trans-unit id="a0c9d0d836710fc155aae7ff2099c119f8b8ff3b" translate="yes" xml:space="preserve">
          <source>Kotlin now integrates with the &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/javax/script/package-summary.html&quot;&gt;javax.script API&lt;/a&gt; (JSR-223). The API allows to evaluate snippets of code at runtime:</source>
          <target state="translated">Kotlin现在与&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/javax/script/package-summary.html&quot;&gt;javax.script API&lt;/a&gt;（JSR-223）集成。该API允许在运行时评估代码段：</target>
        </trans-unit>
        <trans-unit id="5917b5d1de587466aad2c24c7e35497e2343f72e" translate="yes" xml:space="preserve">
          <source>Kotlin now supports storing parameter names in the bytecode. This can be enabled using the &lt;code&gt;-java-parameters&lt;/code&gt; command line option.</source>
          <target state="translated">Kotlin现在支持将参数名称存储在字节码中。可以使用 &lt;code&gt;-java-parameters&lt;/code&gt; 命令行选项启用它。</target>
        </trans-unit>
        <trans-unit id="900f5e70ca199686eb62d660ad48f2ce1610ab30" translate="yes" xml:space="preserve">
          <source>Kotlin numeric types, except for &lt;code&gt;kotlin.Long&lt;/code&gt; are mapped to JavaScript Number.</source>
          <target state="translated">除 &lt;code&gt;kotlin.Long&lt;/code&gt; 以外的Kotlin数字类型映射到JavaScript Number。</target>
        </trans-unit>
        <trans-unit id="fa0f528e5b1ad066646e40d867c682edc345e3d1" translate="yes" xml:space="preserve">
          <source>Kotlin objects could be pinned, i.e. their position in memory is guaranteed to be stable until unpinned, and pointers to such objects inner data could be passed to the C functions. For example</source>
          <target state="translated">Kotlin对象可以被钉住,即保证其在内存中的位置稳定,直到取消钉住,这种对象内部数据的指针可以传递给C函数。例如</target>
        </trans-unit>
        <trans-unit id="23971a8580dfc32441ac3140ce5ff12ac8ef11bf" translate="yes" xml:space="preserve">
          <source>Kotlin plugin 1.3.21 or higher should be installed in the IDE. This can be verified via &lt;em&gt;Language &amp;amp; Frameworks | Kotlin Updates&lt;/em&gt; section in the &lt;em&gt;Settings&lt;/em&gt; (or &lt;em&gt;Preferences&lt;/em&gt;) of the IDE.</source>
          <target state="translated">应该在IDE中安装Kotlin插件1.3.21或更高版本。可以通过&lt;em&gt;语言和框架&lt;/em&gt;进行验证&lt;em&gt;。&lt;/em&gt;IDE 的&lt;em&gt;&amp;ldquo;设置&amp;rdquo;&lt;/em&gt;（或&lt;em&gt;&amp;ldquo;首选项&amp;rdquo;&lt;/em&gt;）中的&lt;em&gt;&amp;ldquo; &lt;/em&gt;&lt;em&gt;Kotlin更新&amp;rdquo;&lt;/em&gt;部分。</target>
        </trans-unit>
        <trans-unit id="446a5a46278f3d1273d1c8d81bcdc944823353d2" translate="yes" xml:space="preserve">
          <source>Kotlin plugin for IntelliJ IDEA supports &lt;a href=&quot;https://www.jetbrains.com/help/idea/scratches.html&quot;&gt;scratches&lt;/a&gt;. Scratches let you create code drafts in the same IDE window with your project and run them on the fly. Scratches are not tied to projects; you can access and run all your scratches from any IntelliJ IDEA window on your OS.</source>
          <target state="translated">IntelliJ IDEA的Kotlin插件支持&lt;a href=&quot;https://www.jetbrains.com/help/idea/scratches.html&quot;&gt;抓痕&lt;/a&gt;。Scratches使您可以在与项目相同的IDE窗口中创建代码草稿，并即时运行它们。从头开始与项目无关；您可以从操作系统上的任何IntelliJ IDEA窗口访问并运行所有暂存器。</target>
        </trans-unit>
        <trans-unit id="bf764bc84647534de5f2a7804f4aa2d9d548f9f9" translate="yes" xml:space="preserve">
          <source>Kotlin preserves lazy object initialization in JavaScript.</source>
          <target state="translated">Kotlin保留了JavaScript中的懒惰对象初始化。</target>
        </trans-unit>
        <trans-unit id="69aede4d1ffe657e5907011bd8394bcc0601690e" translate="yes" xml:space="preserve">
          <source>Kotlin preserves overflow semantics for &lt;code&gt;kotlin.Int&lt;/code&gt;, &lt;code&gt;kotlin.Byte&lt;/code&gt;, &lt;code&gt;kotlin.Short&lt;/code&gt;, &lt;code&gt;kotlin.Char&lt;/code&gt; and &lt;code&gt;kotlin.Long&lt;/code&gt;.</source>
          <target state="translated">Kotlin保留了 &lt;code&gt;kotlin.Int&lt;/code&gt; ， &lt;code&gt;kotlin.Byte&lt;/code&gt; ， &lt;code&gt;kotlin.Short&lt;/code&gt; ， &lt;code&gt;kotlin.Char&lt;/code&gt; 和 &lt;code&gt;kotlin.Long&lt;/code&gt; 的溢出语义。</target>
        </trans-unit>
        <trans-unit id="2849a08507ed289fb75d76677103722db661daba" translate="yes" xml:space="preserve">
          <source>Kotlin primitive type boxes are mapped to special Swift/Objective-C classes. For example, &lt;code&gt;kotlin.Int&lt;/code&gt; box is represented as &lt;code&gt;KotlinInt&lt;/code&gt; class instance in Swift (or &lt;code&gt;${prefix}Int&lt;/code&gt; instance in Objective-C, where &lt;code&gt;prefix&lt;/code&gt; is the framework names prefix). These classes are derived from &lt;code&gt;NSNumber&lt;/code&gt;, so the instances are proper &lt;code&gt;NSNumber&lt;/code&gt;s supporting all corresponding operations.</source>
          <target state="translated">Kotlin基本类型框被映射到特殊的Swift / Objective-C类。例如， &lt;code&gt;kotlin.Int&lt;/code&gt; 框表示为Swift中的 &lt;code&gt;KotlinInt&lt;/code&gt; 类实例（或Objective-C中的 &lt;code&gt;${prefix}Int&lt;/code&gt; 实例，其中 &lt;code&gt;prefix&lt;/code&gt; 是框架名称的前缀）。这些类是从 &lt;code&gt;NSNumber&lt;/code&gt; 派生的，因此实例是支持所有相应操作的正确 &lt;code&gt;NSNumber&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a7ceca5755070f2e75db1f8f41e2c1a411bf045a" translate="yes" xml:space="preserve">
          <source>Kotlin primitive types</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56d4abf280a1b7394ae7fdfbb57bfe9eaca646d5" translate="yes" xml:space="preserve">
          <source>Kotlin properties declared in a named object or a companion object will have static backing fields either in that named object or in the class containing the companion object.</source>
          <target state="translated">在命名对象或同伴对象中声明的Kotlin属性将在该命名对象或包含同伴对象的类中具有静态支持字段。</target>
        </trans-unit>
        <trans-unit id="cf2e0c6a8a702a4b4cb47d5f81663fe43b024e43" translate="yes" xml:space="preserve">
          <source>Kotlin provides a series of compiler options that are accessible in IntelliJ IDEA also. In addition to the one we've just seen for generating source maps, we also have the ability to set</source>
          <target state="translated">Kotlin提供了一系列编译器选项,在IntelliJ IDEA中也可以使用。除了我们刚才看到的用于生成源码图的选项外,我们还可以设置</target>
        </trans-unit>
        <trans-unit id="e2142c523bbfdb03dd37f333a0ce0922e05e00a3" translate="yes" xml:space="preserve">
          <source>Kotlin provides a set of built-in types that represent numbers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a113f99eec74b4131a54c5b784be8df823aef27" translate="yes" xml:space="preserve">
          <source>Kotlin provides a variety of functions to execute a block of code in the context of a given object: &lt;code&gt;let&lt;/code&gt;, &lt;code&gt;run&lt;/code&gt;, &lt;code&gt;with&lt;/code&gt;, &lt;code&gt;apply&lt;/code&gt;, and &lt;code&gt;also&lt;/code&gt;. For the guidance on choosing the right scope function for your case, refer to &lt;a href=&quot;scope-functions&quot;&gt;Scope Functions&lt;/a&gt;.</source>
          <target state="translated">Kotlin提供了多种功能来在给定对象的上下文中执行代码块： &lt;code&gt;let&lt;/code&gt; ， &lt;code&gt;run&lt;/code&gt; ， &lt;code&gt;with&lt;/code&gt; ， &lt;code&gt;apply&lt;/code&gt; 和 &lt;code&gt;also&lt;/code&gt; 。有关为您的案例选择正确的示波器功能的指南，请参阅&amp;ldquo; &lt;a href=&quot;scope-functions&quot;&gt;示波器功能&amp;rdquo;&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9bdbfc816d9da34f310288932621f6005bd4a635" translate="yes" xml:space="preserve">
          <source>Kotlin provides so called &lt;strong&gt;star-projection&lt;/strong&gt; syntax for this:</source>
          <target state="translated">Kotlin 为此提供了所谓的&lt;strong&gt;星形投影&lt;/strong&gt;语法：</target>
        </trans-unit>
        <trans-unit id="a7357de7d14d7d6aa1f1f673c4bd660028007794" translate="yes" xml:space="preserve">
          <source>Kotlin provides the ability to extend a class with new functionality without having to inherit from the class or use design patterns such as Decorator. This is done via special declarations called &lt;em&gt;extensions&lt;/em&gt;. For example, you can write new functions for a class from a third-party library that you can't modify. Such functions are available for calling in the usual way as if they were methods of the original class. This mechanism is called &lt;em&gt;extension functions&lt;/em&gt;. There are also &lt;em&gt;extension properties&lt;/em&gt; that let you define new properties for existing classes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45eae3e9e04c057fe2a9ce2b00c2b1626952c923" translate="yes" xml:space="preserve">
          <source>Kotlin provides the ability to target JavaScript. It does so by transpiling Kotlin to JavaScript. The current implementation targets ECMAScript 5.1 but there are plans to eventually target ECMAScript 2015 as well.</source>
          <target state="translated">Kotlin提供了针对JavaScript的能力。它通过将Kotlin移植到JavaScript中来实现。目前的实现以ECMAScript 5.1为目标,但计划最终也以ECMAScript 2015为目标。</target>
        </trans-unit>
        <trans-unit id="1d361e832e7fbd8cbfa474feeaaf4e3060965e0c" translate="yes" xml:space="preserve">
          <source>Kotlin provides the following built-in types representing numbers (this is close to Java):</source>
          <target state="translated">Kotlin提供了以下代表数字的内置类型(这与Java很接近)。</target>
        </trans-unit>
        <trans-unit id="bcb1ec23fd44ea30c0c43e5be53b38271d9f8878" translate="yes" xml:space="preserve">
          <source>Kotlin provides three tasks for Ant:</source>
          <target state="translated">Kotlin为Ant提供了三个任务。</target>
        </trans-unit>
        <trans-unit id="d32683bae75ae112d7b7ae383176964359ce8293" translate="yes" xml:space="preserve">
          <source>Kotlin requires that every member property is initialized during instance construction. Sometimes, a class is intended to be used in such a way that the constructor doesn't have enough information to initialize all properties (such as when making a builder class or when using property-based dependency injection). In order to not have to make those properties nullable, you can use a &lt;em&gt;late-initialized property&lt;/em&gt;:</source>
          <target state="translated">Kotlin要求在实例构建过程中初始化每个成员属性。有时，类的使用方式应使构造函数没有足够的信息来初始化所有属性（例如，制作构建器类或使用基于属性的依赖注入时）。为了不必使这些属性可为空，可以使用&lt;em&gt;后期初始化的属性&lt;/em&gt;：</target>
        </trans-unit>
        <trans-unit id="b6c82522c1d0ee2c933047e31fffeca6f833ef7e" translate="yes" xml:space="preserve">
          <source>Kotlin scripts in &lt;code&gt;build.gradle.kts&lt;/code&gt; files</source>
          <target state="translated">&lt;code&gt;build.gradle.kts&lt;/code&gt; 文件中的Kotlin脚本</target>
        </trans-unit>
        <trans-unit id="120e9cfe3ecde2244c4b2038cf0d5e11c76827a7" translate="yes" xml:space="preserve">
          <source>Kotlin singleton (made with an &lt;code&gt;object&lt;/code&gt; declaration, including &lt;code&gt;companion object&lt;/code&gt;) is imported to Swift/Objective-C as a class with a single instance. The instance is available through the factory method, i.e. as &lt;code&gt;[MySingleton mySingleton]&lt;/code&gt; in Objective-C and &lt;code&gt;MySingleton()&lt;/code&gt; in Swift.</source>
          <target state="translated">Kotlin单例（使用 &lt;code&gt;object&lt;/code&gt; 声明（包括 &lt;code&gt;companion object&lt;/code&gt; ）制成）作为具有单个实例的类导入到Swift / Objective-C中。该实例可通过工厂方法使用，例如，Objective-C中的 &lt;code&gt;[MySingleton mySingleton]&lt;/code&gt; 和Swift中的 &lt;code&gt;MySingleton()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bea729ea75b1b1e606f056a5012e91fb52a83a74" translate="yes" xml:space="preserve">
          <source>Kotlin singletons</source>
          <target state="translated">Kotlin单子</target>
        </trans-unit>
        <trans-unit id="a2394b4a95a3420db31c70572b58364d6b98a0c6" translate="yes" xml:space="preserve">
          <source>Kotlin source file or directory to compile</source>
          <target state="translated">要编译的Kotlin源文件或目录</target>
        </trans-unit>
        <trans-unit id="e2f631b0ebe5da9da1b87daae220f0696369b117" translate="yes" xml:space="preserve">
          <source>Kotlin source sets may be connected with the &lt;em&gt;'depends on'&lt;/em&gt; relation, so that if a source set &lt;code&gt;foo&lt;/code&gt; depends on a source set &lt;code&gt;bar&lt;/code&gt; then:</source>
          <target state="translated">Kotlin源集可能与&lt;em&gt;&amp;ldquo;取决于&amp;rdquo;&lt;/em&gt;关系相关联，因此，如果源集 &lt;code&gt;foo&lt;/code&gt; 取决于源集 &lt;code&gt;bar&lt;/code&gt; 则：</target>
        </trans-unit>
        <trans-unit id="3806de1d34a4bca588a5784ceb856faa4c1b15c6" translate="yes" xml:space="preserve">
          <source>Kotlin sources can be mixed with Java sources in the same folder, or in different folders. The default convention is using different folders:</source>
          <target state="translated">Kotlin源码可以和Java源码混合在同一个文件夹中,也可以放在不同的文件夹中。默认的惯例是使用不同的文件夹。</target>
        </trans-unit>
        <trans-unit id="8dda6be52af63434ddc539d85c3f07ae2c8c8de5" translate="yes" xml:space="preserve">
          <source>Kotlin sources can be stored with Java sources in the same folder, or placed to different folders. The default convention is using different folders:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="742632ac6e0e85caf1c4f062cccebafab2dafb01" translate="yes" xml:space="preserve">
          <source>Kotlin standard library artifacts and split packages</source>
          <target state="translated">Kotlin标准库构件和拆分包。</target>
        </trans-unit>
        <trans-unit id="77cb00a3ce7a3cdab1c1c157be47f7632c70f806" translate="yes" xml:space="preserve">
          <source>Kotlin subclasses of Objective-C classes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2607bec52d42f747a5225384e349fc0ccef2ced7" translate="yes" xml:space="preserve">
          <source>Kotlin supports SAM conversions for both Java and &lt;a href=&quot;fun-interfaces&quot;&gt;Kotlin interfaces&lt;/a&gt;. This support for Java means that Kotlin function literals can be automatically converted into implementations of Java interfaces with a single non-default method, as long as the parameter types of the interface method match the parameter types of the Kotlin function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4a28ec1a46419f171d723ee46383588cd9c1cbc" translate="yes" xml:space="preserve">
          <source>Kotlin supports a style of functional programming known as &lt;a href=&quot;https://en.wikipedia.org/wiki/Tail_call&quot;&gt;tail recursion&lt;/a&gt;. This allows some algorithms that would normally be written using loops to instead be written using a recursive function, but without the risk of stack overflow. When a function is marked with the &lt;code&gt;tailrec&lt;/code&gt; modifier and meets the required form, the compiler optimises out the recursion, leaving behind a fast and efficient loop based version instead:</source>
          <target state="translated">Kotlin支持一种称为&lt;a href=&quot;https://en.wikipedia.org/wiki/Tail_call&quot;&gt;尾递归&lt;/a&gt;的函数式编程。这允许某些通常使用循环编写的算法改为使用递归函数编写，但是没有堆栈溢出的风险。当一个函数用 &lt;code&gt;tailrec&lt;/code&gt; 修饰符标记并符合所需形式时，编译器会优化递归，而留下一个快速，高效的基于循环的版本：</target>
        </trans-unit>
        <trans-unit id="a2baed6c5430ce0572e2f1a5bae6b4631f0f1c73" translate="yes" xml:space="preserve">
          <source>Kotlin supports a style of functional programming known as &lt;a href=&quot;https://en.wikipedia.org/wiki/Tail_call&quot;&gt;tail recursion&lt;/a&gt;. This allows some algorithms that would normally be written using loops to instead be written using a recursive function, but without the risk of stack overflow. When a function is marked with the &lt;code&gt;tailrec&lt;/code&gt; modifier and meets the required form, the compiler optimizes out the recursion, leaving behind a fast and efficient loop based version instead:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f764f32b8a5f60d7b0c651002320db85fd7d539f" translate="yes" xml:space="preserve">
          <source>Kotlin supports annonation processing via the &lt;em&gt;Kotlin annotation processing tool&lt;/em&gt;(&lt;code&gt;kapt&lt;/code&gt;). Usage of kapt with Gradle is described on the &lt;a href=&quot;kapt&quot;&gt;kapt page&lt;/a&gt;.</source>
          <target state="translated">Kotlin通过&lt;em&gt;Kotlin注释处理工具&lt;/em&gt;（ &lt;code&gt;kapt&lt;/code&gt; ）支持&lt;em&gt;注释处理&lt;/em&gt;。&lt;a href=&quot;kapt&quot;&gt;kapt页面&lt;/a&gt;上介绍了kapt与Gradle的用法。</target>
        </trans-unit>
        <trans-unit id="13f5d747f019181c1a771753e56710d47a2bbad6" translate="yes" xml:space="preserve">
          <source>Kotlin supports annonation processing via the Kotlin annotation processing tool &lt;a href=&quot;kapt&quot;&gt;&lt;code&gt;kapt&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92bcfac7403d3cddfb4464119a784d92d81f9f9d" translate="yes" xml:space="preserve">
          <source>Kotlin supports local functions, i.e. a function inside another function:</source>
          <target state="translated">Kotlin支持本地函数,即一个函数在另一个函数里面。</target>
        </trans-unit>
        <trans-unit id="282b26637b1a5ff71051d95d88177e34b6cefc30" translate="yes" xml:space="preserve">
          <source>Kotlin supports single-parent class inheritance - so each class (except the root class &lt;code&gt;Any&lt;/code&gt;) has got exactly one parent class, called a &lt;em&gt;superclass&lt;/em&gt;. Kotlin wants you to think through your class design to make sure that it's actually safe to &lt;em&gt;subclass&lt;/em&gt; it, so classes are &lt;em&gt;closed&lt;/em&gt; by default and can't be inherited from unless you explicitly declare the class to be &lt;em&gt;open&lt;/em&gt; or &lt;em&gt;abstract&lt;/em&gt;. You can then subclass from that class by declaring a new class which mentions its parent class after a colon:</source>
          <target state="translated">Kotlin支持单父类继承-因此，每个类（根类 &lt;code&gt;Any&lt;/code&gt; 除外）都只有一个父类，称为&lt;em&gt;超类&lt;/em&gt;。 Kotlin希望您仔细考虑类的设计，以确保对其进行&lt;em&gt;子类化&lt;/em&gt;实际上是安全的，因此，默认情况下类是&lt;em&gt;关闭&lt;/em&gt;的，除非您明确声明该类为&lt;em&gt;open&lt;/em&gt;或&lt;em&gt;abstract&lt;/em&gt;，否则不能继承。然后，您可以通过声明一个新类来从该类中子类化，该新类在冒号后提及其父类：</target>
        </trans-unit>
        <trans-unit id="c701dab67e42733a07778c8e90d14a14d6115e0e" translate="yes" xml:space="preserve">
          <source>Kotlin supports the following operators and special symbols:</source>
          <target state="translated">Kotlin支持以下运算符和特殊符号。</target>
        </trans-unit>
        <trans-unit id="b9f65c39eaf4fcfb17c2f522f10687c0e4404fdb" translate="yes" xml:space="preserve">
          <source>Kotlin supports the standard set of arithmetical operations over numbers (&lt;code&gt;+&lt;/code&gt;&lt;code&gt;-&lt;/code&gt;&lt;code&gt;*&lt;/code&gt;&lt;code&gt;/&lt;/code&gt;&lt;code&gt;%&lt;/code&gt;), which are declared as members of appropriate classes (but the compiler optimizes the calls down to the corresponding instructions). See &lt;a href=&quot;operator-overloading&quot;&gt;Operator overloading&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4887c0a9ca610838532432bde155538452979c8b" translate="yes" xml:space="preserve">
          <source>Kotlin supports the standard set of arithmetical operations over numbers, which are declared as members of appropriate classes (but the compiler optimizes the calls down to the corresponding instructions). See &lt;a href=&quot;operator-overloading&quot;&gt;Operator overloading&lt;/a&gt;.</source>
          <target state="translated">Kotlin支持数字上的标准算术运算集，这些算术运算被声明为适当类的成员（但编译器会优化对相应指令的调用）。请参阅&lt;a href=&quot;operator-overloading&quot;&gt;运算符重载&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c8bfc686b943f3ad415464d9f2987e93b995ca8c" translate="yes" xml:space="preserve">
          <source>Kotlin supports traditional &lt;em&gt;break&lt;/em&gt; and &lt;em&gt;continue&lt;/em&gt; operators in loops. See &lt;a href=&quot;returns&quot;&gt;Returns and jumps&lt;/a&gt;.</source>
          <target state="translated">Kotlin支持传统的&lt;em&gt;break&lt;/em&gt;和循环&lt;em&gt;继续&lt;/em&gt;操作符。请参阅&lt;a href=&quot;returns&quot;&gt;返回和跳转&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0d07ef64d55abdae6d6a123db33be555df8316b4" translate="yes" xml:space="preserve">
          <source>Kotlin supports trailing commas in the following cases:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d836a05da6a45d7708b37e3a93892db605af05e1" translate="yes" xml:space="preserve">
          <source>Kotlin targets a wide range of the Java versions, including Java 6 and Java 7, where default methods in the interfaces are not allowed. For your convenience, the Kotlin compiler works around that limitation, but this workaround isn't compatible with the &lt;code&gt;default&lt;/code&gt; methods, introduced in Java 8.</source>
          <target state="translated">Kotlin面向广泛的Java版本，包括Java 6和Java 7，其中不允许接口中使用默认方法。为方便起见，Kotlin编译器可解决该限制，但该解决方法与Java 8中引入的 &lt;code&gt;default&lt;/code&gt; 方法不兼容。</target>
        </trans-unit>
        <trans-unit id="7a3c3013cf9e37dd556eb25470f92f220350c10a" translate="yes" xml:space="preserve">
          <source>Kotlin to JavaScript</source>
          <target state="translated">Kotlin to JavaScript</target>
        </trans-unit>
        <trans-unit id="09a30aded79f08fdd22e3766d5057679b6cb51d6" translate="yes" xml:space="preserve">
          <source>Kotlin treats some Java types specially. Such types are not loaded from Java &quot;as is&quot;, but are &lt;em&gt;mapped&lt;/em&gt; to corresponding Kotlin types. The mapping only matters at compile time, the runtime representation remains unchanged. Java's primitive types are mapped to corresponding Kotlin types (keeping &lt;a href=&quot;#null-safety-and-platform-types&quot;&gt;platform types&lt;/a&gt; in mind):</source>
          <target state="translated">Kotlin特别对待某些Java类型。此类类型不是从Java 照原样加载的，而是&lt;em&gt;映射&lt;/em&gt;到相应的Kotlin类型。映射仅在编译时起作用，运行时表示形式保持不变。Java的原始类型映射到相应的Kotlin类型（请记住&lt;a href=&quot;#null-safety-and-platform-types&quot;&gt;平台类型&lt;/a&gt;）：</target>
        </trans-unit>
        <trans-unit id="768f1e9cdea1a9d60e4596098790dc6c5c883f4f" translate="yes" xml:space="preserve">
          <source>Kotlin turns the function pointer return type into a nullable &lt;code&gt;CPointer&amp;lt;CFunction&amp;lt;..&amp;gt;&lt;/code&gt; object. There is the need to explicitly check for &lt;code&gt;null&lt;/code&gt; first. We use &lt;a href=&quot;../../reference/null-safety&quot;&gt;elvis operator&lt;/a&gt; for that. The &lt;code&gt;cinterop&lt;/code&gt; tool helps us to turn a C function pointer into an easy to call object in Kotlin. This is what we did on the last line.</source>
          <target state="translated">Kotlin将函数指针返回类型转换为可为空的 &lt;code&gt;CPointer&amp;lt;CFunction&amp;lt;..&amp;gt;&lt;/code&gt; 对象。有必要先明确检查 &lt;code&gt;null&lt;/code&gt; 。为此，我们使用&lt;a href=&quot;../../reference/null-safety&quot;&gt;elvis运算符&lt;/a&gt;。该 &lt;code&gt;cinterop&lt;/code&gt; 工具可以帮助我们把C函数指针指向一个简单的调用对象科特林。这就是我们在最后一行所做的。</target>
        </trans-unit>
        <trans-unit id="db8f21bde482b5a130cf00596109ec23d3d336d2" translate="yes" xml:space="preserve">
          <source>Kotlin uses a family of function types like &lt;code&gt;(Int) -&amp;gt; String&lt;/code&gt; for declarations that deal with functions: &lt;code&gt;val onClick: () -&amp;gt; Unit = ...&lt;/code&gt;.</source>
          <target state="translated">科特林使用函数类型，如家族 &lt;code&gt;(Int) -&amp;gt; String&lt;/code&gt; 的声明该处理功能： &lt;code&gt;val onClick: () -&amp;gt; Unit = ...&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bb4aa710f2c72b83ee921d5d3e539487fd005073" translate="yes" xml:space="preserve">
          <source>Kotlin uses the &lt;code&gt;libnative_&lt;/code&gt; prefix for all declarations in the created &lt;code&gt;libnative_api.h&lt;/code&gt; file. Let's present the mapping of the types in a more readable way:</source>
          <target state="translated">Kotlin将 &lt;code&gt;libnative_&lt;/code&gt; 前缀用于所创建的 &lt;code&gt;libnative_api.h&lt;/code&gt; 文件中的所有声明。让我们以一种更具可读性的方式呈现类型的映射：</target>
        </trans-unit>
        <trans-unit id="b58121b32bf1a1498b7715228a497191716fd48d" translate="yes" xml:space="preserve">
          <source>Kotlin was designed for easy interoperation with Java platform. It sees Java classes as Kotlin classes, and Java sees Kotlin classes as Java classes. However, JavaScript is a dynamically-typed language, which means it does not check types in compile-time. You can freely talk to JavaScript from Kotlin via &lt;a href=&quot;dynamic-type&quot;&gt;dynamic&lt;/a&gt; types, but if you want the full power of Kotlin type system, you can create Kotlin headers for JavaScript libraries.</source>
          <target state="translated">Kotlin旨在与Java平台轻松互操作。它将Java类视为Kotlin类，而Java将Kotlin类视为Java类。但是，JavaScript是一种动态类型的语言，这意味着它不会在编译时检查类型。您可以通过&lt;a href=&quot;dynamic-type&quot;&gt;动态&lt;/a&gt;类型从Kotlin中自由地与JavaScript对话，但是如果您想要Kotlin类型系统的全部功能，则可以为JavaScript库创建Kotlin标头。</target>
        </trans-unit>
        <trans-unit id="e4c0f3a3782b90edcee0e70de97ebb0b28520a70" translate="yes" xml:space="preserve">
          <source>Kotlin was first designed for easy interoperation with the Java platform: it sees Java classes as Kotlin classes, and Java sees Kotlin classes as Java classes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="487d5ff42a3055fc2a4cb28f3d53d445d59f1865" translate="yes" xml:space="preserve">
          <source>Kotlin will allow you to declare this property without initializing it, and you can set the property value at some point after construction (either directly or via a function). It is the responsibility of the class itself as well as its users to take care not to read the property before it has been set, and Kotlin allows you to write code that reads &lt;code&gt;name&lt;/code&gt; as if it were an ordinary, non-nullable property. However, the compiler is unable to enforce correct usage, so if the property is read before it has been set, an &lt;code&gt;UninitializedPropertyAccessException&lt;/code&gt; will be thrown at runtime.</source>
          <target state="translated">Kotlin允许您声明该属性而无需初始化它，并且您可以在构造后的某个时候（直接或通过函数）设置属性值。类本身及其用户都有责任注意在设置属性之前不要读取该属性，并且Kotlin允许您编写读取 &lt;code&gt;name&lt;/code&gt; 的代码，就像它是普通的，不可为空的属性一样。但是，编译器是无法强制执行正确的使用方法，因此，如果属性是读已设置之前，一个 &lt;code&gt;UninitializedPropertyAccessException&lt;/code&gt; 将在运行时抛出。</target>
        </trans-unit>
        <trans-unit id="b3a556e28261e02ebafecde169f3b3513ca13075" translate="yes" xml:space="preserve">
          <source>Kotlin works quite smoothly with Spring Boot and many of the steps found on the &lt;a href=&quot;https://spring.io/guides&quot;&gt;Spring Guides&lt;/a&gt; for creating a RESTful service can be followed verbatim for Kotlin. There are some minor differences however when it comes to defining the Gradle configuration and the project layout structure, as well as the initialization code.</source>
          <target state="translated">Kotlin使用Spring Boot可以非常顺畅地工作，并且Kotlin可以完全遵循&lt;a href=&quot;https://spring.io/guides&quot;&gt;Spring指南&lt;/a&gt;中创建RESTful服务的许多步骤。但是，在定义Gradle配置和项目布局结构以及初始化代码方面存在一些细微差异。</target>
        </trans-unit>
        <trans-unit id="43ea688f8664ba8f8dabcebd91046161c6146f3c" translate="yes" xml:space="preserve">
          <source>Kotlin works with different &lt;a href=&quot;build-tools&quot;&gt;build tools&lt;/a&gt;, so if we're using a standard tool such as Ant, Maven or Gradle, the process for setting up a Kotlin project is no different to any other language or library that integrates with these tools. Where there are some minor requirements and differences is when using JBS, which is the internal build system that IntelliJ IDEA uses, which is also supported on TeamCity.</source>
          <target state="translated">Kotlin使用不同的&lt;a href=&quot;build-tools&quot;&gt;构建工具&lt;/a&gt;，因此，如果我们使用的是Ant，Maven或Gradle之类的标准工具，则Kotlin项目的设置过程与与这些工具集成的任何其他语言或库没有什么不同。在使用JBS时，有一些小的要求和不同之处，这是IntelliJ IDEA使用的内部构建系统，TeamCity也支持该系统。</target>
        </trans-unit>
        <trans-unit id="457e307b979be376836ec99d4487123ba8ace79f" translate="yes" xml:space="preserve">
          <source>Kotlin's approach to working with asynchronous code is using coroutines, which is the idea of suspendable computations, i.e. the idea that a function can suspend its execution at some point and resume later on.</source>
          <target state="translated">Kotlin处理异步代码的方法是使用coroutines,也就是可暂停计算的思想,即一个函数可以在某个时刻暂停执行,以后再恢复。</target>
        </trans-unit>
        <trans-unit id="b5ab858d5d3418daf57f2ff97756dc06bfcd23b9" translate="yes" xml:space="preserve">
          <source>Kotlin's documentation generation tool is called &lt;a href=&quot;https://github.com/Kotlin/dokka&quot;&gt;Dokka&lt;/a&gt;. See the &lt;a href=&quot;https://github.com/Kotlin/dokka/blob/master/README.md&quot;&gt;Dokka README&lt;/a&gt; for usage instructions.</source>
          <target state="translated">Kotlin的文档生成工具称为&lt;a href=&quot;https://github.com/Kotlin/dokka&quot;&gt;Dokka&lt;/a&gt;。有关用法说明，请参阅《&lt;a href=&quot;https://github.com/Kotlin/dokka/blob/master/README.md&quot;&gt;Dokka README&lt;/a&gt;》。</target>
        </trans-unit>
        <trans-unit id="3af1e3ba09d170fd30c3af38c47add3814785926" translate="yes" xml:space="preserve">
          <source>Kotlin's documentation syntax is called &lt;em&gt;KDoc&lt;/em&gt;. A KDoc block is placed above the construct it describes, and begins with &lt;code&gt;/**&lt;/code&gt; and ends with &lt;code&gt;*/&lt;/code&gt; (possibly on one line; if not, each intermediate lines should start with an aligned asterisk). The first block of text is the summary; then, you can use &lt;em&gt;block tags&lt;/em&gt; to provide information about specific parts of the construct. Some block tags are &lt;code&gt;@param&lt;/code&gt; for function parameters and generic type parameters, and &lt;code&gt;@return&lt;/code&gt; for the return value. You can link to identifiers inside brackets. All the text outside of links and block tag names is in Markdown format.</source>
          <target state="translated">Kotlin的文档语法称为&lt;em&gt;KDoc&lt;/em&gt;。 KDoc块放置在它描述的结构上方，并以 &lt;code&gt;/**&lt;/code&gt; 开头，并以 &lt;code&gt;*/&lt;/code&gt; 结束（可能在一行上；如果没有，则每个中间行应以对齐的星号开头）。文本的第一块是摘要。然后，您可以使用&lt;em&gt;块标记&lt;/em&gt;提供有关构造的特定部分的信息。某些块标记是 &lt;code&gt;@param&lt;/code&gt; (用于函数参数和泛型类型参数），以及 &lt;code&gt;@return&lt;/code&gt; (用于返回值）。您可以链接到方括号内的标识符。链接和块标记名称之外的所有文本均为Markdown格式。</target>
        </trans-unit>
        <trans-unit id="053760c0ead482ee5ae43f8e0bead527a31d7dd2" translate="yes" xml:space="preserve">
          <source>Kotlin's generics are a little different from Java's (see &lt;a href=&quot;generics&quot;&gt;Generics&lt;/a&gt;). When importing Java types to Kotlin we perform some conversions:</source>
          <target state="translated">Kotlin的泛型与Java的&lt;a href=&quot;generics&quot;&gt;泛型&lt;/a&gt;有些不同（请参阅Generics）。将Java类型导入Kotlin时，我们会执行一些转换：</target>
        </trans-unit>
        <trans-unit id="9ce324f37629b9d5fdf6ee64821674d4e61b9c46" translate="yes" xml:space="preserve">
          <source>Kotlin's loops are similar to Python's. &lt;code&gt;for&lt;/code&gt; iterates over anything that is &lt;em&gt;iterable&lt;/em&gt; (anything that has an &lt;code&gt;iterator()&lt;/code&gt; function that provides an &lt;code&gt;Iterator&lt;/code&gt; object), or anything that is itself an iterator:</source>
          <target state="translated">Kotlin的循环类似于Python的循环。 &lt;code&gt;for&lt;/code&gt; 迭代任何&lt;em&gt;可迭代的&lt;/em&gt;事物（任何具有提供 &lt;code&gt;Iterator&lt;/code&gt; 对象的 &lt;code&gt;iterator()&lt;/code&gt; 函数的事物）或本身就是迭代器的事物：</target>
        </trans-unit>
        <trans-unit id="ba05695800cb8016bdf03b211c131a78afee8e93" translate="yes" xml:space="preserve">
          <source>Kotlin's object model is substantially different from Python's. Most importantly, classes are &lt;em&gt;not&lt;/em&gt; dynamically modifiable at runtime! (There are some limited exceptions to this, but you generally shouldn't do it. However, it &lt;em&gt;is&lt;/em&gt; possible to dynamically &lt;em&gt;inspect&lt;/em&gt; classes and objects at runtime with a feature called &lt;em&gt;reflection&lt;/em&gt; - this can be useful, but should be judiciously used.) All properties (attributes) and functions that might ever be needed on a class must be declared either directly in the class body or as &lt;a href=&quot;extension-functionsproperties&quot;&gt;&lt;em&gt;extension functions&lt;/em&gt;&lt;/a&gt;, so you should think carefully through your class design.</source>
          <target state="translated">Kotlin的对象模型与Python的对象模型有很大的不同。最重要的是，类&lt;em&gt;不能&lt;/em&gt;在运行时动态修改！ （有一些有限的例外，但你一般不应该这样做然而，。&lt;em&gt;是&lt;/em&gt;可以动态地&lt;em&gt;检查&lt;/em&gt;类和在运行时用一个功能叫做物体&lt;em&gt;反射&lt;/em&gt; -这可能是有用的，但应谨慎使用）所有必须直接在类主体中声明或作为&lt;a href=&quot;extension-functionsproperties&quot;&gt;&lt;em&gt;扩展函数&lt;/em&gt;&lt;/a&gt;声明类中可能需要的属性（属性）和函数，因此您应该在类设计时仔细考虑。</target>
        </trans-unit>
        <trans-unit id="d2a59f6487d643d44ccac72e26090969f3853d89" translate="yes" xml:space="preserve">
          <source>Kotlin's standard library has a &lt;code&gt;TODO()&lt;/code&gt; function that will always throw a &lt;code&gt;NotImplementedError&lt;/code&gt;. Its return type is &lt;code&gt;Nothing&lt;/code&gt; so it can be used regardless of expected type. There's also an overload that accepts a reason parameter:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="970540431e074be00582837c3e83cd1ca1a5ee04" translate="yes" xml:space="preserve">
          <source>Kotlin's type system is aimed at eliminating the danger of null references from code, also known as the &lt;a href=&quot;http://en.wikipedia.org/wiki/Tony_Hoare#Apologies_and_retractions&quot;&gt;The Billion Dollar Mistake&lt;/a&gt;.</source>
          <target state="translated">Kotlin的类型系统旨在消除代码中空引用的危险，也称为&lt;a href=&quot;http://en.wikipedia.org/wiki/Tony_Hoare#Apologies_and_retractions&quot;&gt;&amp;ldquo;十亿美元的错误&amp;rdquo;&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8b3b3c2fce26ced6c3f89e4969b12ebc4e57fb47" translate="yes" xml:space="preserve">
          <source>Kotlin's type system is aimed at eliminating the danger of null references from code, also known as the &lt;a href=&quot;https://en.wikipedia.org/wiki/Tony_Hoare#Apologies_and_retractions&quot;&gt;The Billion Dollar Mistake&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ae5912eae484ffd44f09a774b363dbba8158106" translate="yes" xml:space="preserve">
          <source>Kotlin's type system is aimed to eliminate &lt;code&gt;NullPointerException&lt;/code&gt;'s from our code. The only possible causes of NPE's may be:</source>
          <target state="translated">Kotlin的类型系统旨在从我们的代码中消除 &lt;code&gt;NullPointerException&lt;/code&gt; 。NPE的唯一可能原因可能是：</target>
        </trans-unit>
        <trans-unit id="0b21dfbe494a9eaaf724f5a9592dd235fdd14650" translate="yes" xml:space="preserve">
          <source>Kotlin, as a language, provides only minimal low-level APIs in its standard library to enable various other libraries to utilize coroutines. Unlike many other languages with similar capabilities, &lt;code&gt;async&lt;/code&gt; and &lt;code&gt;await&lt;/code&gt; are not keywords in Kotlin and are not even part of its standard library. Moreover, Kotlin's concept of &lt;em&gt;suspending function&lt;/em&gt; provides a safer and less error-prone abstraction for asynchronous operations than futures and promises.</source>
          <target state="translated">Kotlin作为一种语言，在其标准库中仅提供最少的低级API，以使其他各种库都可以使用协程。与许多其他具有类似功能的语言不同， &lt;code&gt;async&lt;/code&gt; 和 &lt;code&gt;await&lt;/code&gt; 不是Kotlin中的关键字，甚至都不是其标准库的一部分。此外，与期货和承诺相比，Kotlin的&lt;em&gt;暂停功能&lt;/em&gt;概念为异步操作提供了更安全，更不易出错的抽象。</target>
        </trans-unit>
        <trans-unit id="1aefdadaf18a27e16e25f47128252ff2aeb47fe6" translate="yes" xml:space="preserve">
          <source>Kotlin, similar to C# and Gosu, provides the ability to extend a class with new functionality without having to inherit from the class or use any type of design pattern such as Decorator. This is done via special declarations called &lt;em&gt;extensions&lt;/em&gt;. Kotlin supports &lt;em&gt;extension functions&lt;/em&gt; and &lt;em&gt;extension properties&lt;/em&gt;.</source>
          <target state="translated">与C＃和Gosu相似，Kotlin提供了使用新功能扩展类的功能，而不必继承该类或使用任何类型的设计模式（例如Decorator）。这通过称为&lt;em&gt;扩展的&lt;/em&gt;特殊声明来完成。Kotlin支持&lt;em&gt;扩展功能&lt;/em&gt;和&lt;em&gt;扩展属性&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="66f1754b6d5c7a12dce00bd5e634c25ddb75bf52" translate="yes" xml:space="preserve">
          <source>Kotlin/JS</source>
          <target state="translated">Kotlin/JS</target>
        </trans-unit>
        <trans-unit id="b4529ea374c3a4cde07a41aa987a9b048c623d50" translate="yes" xml:space="preserve">
          <source>Kotlin/JS (Classic back-end)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c111df440b988d7ac0f881b0ae8eeed10bb5e43" translate="yes" xml:space="preserve">
          <source>Kotlin/JS (IR-based)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3409f54fa5231194c2d7cb0f9009c3222e1a2109" translate="yes" xml:space="preserve">
          <source>Kotlin/JS Overview</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5579b6ef038f8f8ca2fe985b676250979f056cbe" translate="yes" xml:space="preserve">
          <source>Kotlin/JS allows you to &lt;strong&gt;leverage powerful browser and web APIs&lt;/strong&gt; in a type-safe fashion. Create, modify and interact with elements in the Document Object Model (DOM), use Kotlin code to control the rendering of &lt;code&gt;canvas&lt;/code&gt; or WebGL components, and enjoy access to many more of the features supported in modern browsers.</source>
          <target state="new"/>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
