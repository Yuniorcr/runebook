<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="kotlin">
    <body>
      <group id="kotlin">
        <trans-unit id="8e5f25cf2555e851681e56711455629d8b96cc85" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Char&lt;/code&gt; code is represented by the least significant 16 bits of this &lt;code&gt;Long&lt;/code&gt; value.</source>
          <target state="translated">所得的 &lt;code&gt;Char&lt;/code&gt; 码由此 &lt;code&gt;Long&lt;/code&gt; 值的最低有效16位表示。</target>
        </trans-unit>
        <trans-unit id="7c93c7f205f664c42eb53e198c38febdd8681e8c" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Char&lt;/code&gt; value is equal to &lt;code&gt;this.toInt().toChar()&lt;/code&gt;.</source>
          <target state="translated">得到的 &lt;code&gt;Char&lt;/code&gt; 值等于 &lt;code&gt;this.toInt().toChar()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fb0bee6e823fc7a039aaeeb4e2cf6ccadd56cad2" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Double&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;Byte&lt;/code&gt;.</source>
          <target state="translated">得到的 &lt;code&gt;Double&lt;/code&gt; 值表示与此 &lt;code&gt;Byte&lt;/code&gt; 相同的数值。</target>
        </trans-unit>
        <trans-unit id="ec044076f69f3a9e4c8c326707b213be48dbdf4c" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Double&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;Float&lt;/code&gt;.</source>
          <target state="translated">得到的 &lt;code&gt;Double&lt;/code&gt; 值表示与此 &lt;code&gt;Float&lt;/code&gt; 相同的数值。</target>
        </trans-unit>
        <trans-unit id="413cc395d49c3c9b688aa7288d432c1583480097" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Double&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;Int&lt;/code&gt;.</source>
          <target state="translated">得到的 &lt;code&gt;Double&lt;/code&gt; 值表示与此 &lt;code&gt;Int&lt;/code&gt; 相同的数值。</target>
        </trans-unit>
        <trans-unit id="e04c116c448cef44fd49f1d1da49c8be72cf833e" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Double&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;Short&lt;/code&gt;.</source>
          <target state="translated">得到的 &lt;code&gt;Double&lt;/code&gt; 值表示与此 &lt;code&gt;Short&lt;/code&gt; 相同的数值。</target>
        </trans-unit>
        <trans-unit id="624ad9cad2fadf7c5df7034160380cba9b36827a" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Double&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;UByte&lt;/code&gt;.</source>
          <target state="translated">得到的 &lt;code&gt;Double&lt;/code&gt; 值表示与此 &lt;code&gt;UByte&lt;/code&gt; 相同的数值。</target>
        </trans-unit>
        <trans-unit id="e233d00009204b3d8e16f6c4faaeb29b610dd152" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Double&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;UInt&lt;/code&gt;.</source>
          <target state="translated">所得的 &lt;code&gt;Double&lt;/code&gt; 值表示与此 &lt;code&gt;UInt&lt;/code&gt; 相同的数值。</target>
        </trans-unit>
        <trans-unit id="be9fd1536c9016ec165d93e9e044c6403df23d59" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Double&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;UShort&lt;/code&gt;.</source>
          <target state="translated">得到的 &lt;code&gt;Double&lt;/code&gt; 值表示与此 &lt;code&gt;UShort&lt;/code&gt; 相同的数值。</target>
        </trans-unit>
        <trans-unit id="ae244f9a05312104462c229a2e3a4a4de64be4e1" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Float&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;Byte&lt;/code&gt;.</source>
          <target state="translated">最终的 &lt;code&gt;Float&lt;/code&gt; 值表示与此 &lt;code&gt;Byte&lt;/code&gt; 相同的数值。</target>
        </trans-unit>
        <trans-unit id="f8088fd36ea4c2c1efeb80cfa5d2e317eb476320" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Float&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;Short&lt;/code&gt;.</source>
          <target state="translated">产生的 &lt;code&gt;Float&lt;/code&gt; 值表示与此 &lt;code&gt;Short&lt;/code&gt; 相同的数值。</target>
        </trans-unit>
        <trans-unit id="f353ad75e4345f7f3c16a80f19361bddd53a4f67" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Float&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;UByte&lt;/code&gt;.</source>
          <target state="translated">最终的 &lt;code&gt;Float&lt;/code&gt; 值表示与此 &lt;code&gt;UByte&lt;/code&gt; 相同的数值。</target>
        </trans-unit>
        <trans-unit id="abac5ba157cb93c8f101ff3e6ab497cfac17749a" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Float&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;UShort&lt;/code&gt;.</source>
          <target state="translated">最终的 &lt;code&gt;Float&lt;/code&gt; 值表示与此 &lt;code&gt;UShort&lt;/code&gt; 相同的数值。</target>
        </trans-unit>
        <trans-unit id="9d03c1143daecc3b8a141860933f0a92adb18b37" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Int&lt;/code&gt; value has the same binary representation as this &lt;code&gt;UInt&lt;/code&gt; value.</source>
          <target state="translated">生成的 &lt;code&gt;Int&lt;/code&gt; 值与此 &lt;code&gt;UInt&lt;/code&gt; 值具有相同的二进制表示形式。</target>
        </trans-unit>
        <trans-unit id="6ff94aee825d38ae08d93f2ca58819f2a03d9747" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Int&lt;/code&gt; value is represented by the least significant 32 bits of this &lt;code&gt;Long&lt;/code&gt; value.</source>
          <target state="translated">结果 &lt;code&gt;Int&lt;/code&gt; 值由此 &lt;code&gt;Long&lt;/code&gt; 值的最低有效32位表示。</target>
        </trans-unit>
        <trans-unit id="7a5d4e0dea3c1513f10c80d1128e159e3a009787" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Int&lt;/code&gt; value is represented by the least significant 32 bits of this &lt;code&gt;ULong&lt;/code&gt; value. Note that the resulting &lt;code&gt;Int&lt;/code&gt; value may be negative.</source>
          <target state="translated">结果的 &lt;code&gt;Int&lt;/code&gt; 值由该 &lt;code&gt;ULong&lt;/code&gt; 值的最低有效32位表示。请注意，所得的 &lt;code&gt;Int&lt;/code&gt; 值可能为负。</target>
        </trans-unit>
        <trans-unit id="134cc45d29d5c0611e6038571857feed8853b0ee" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Int&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;Byte&lt;/code&gt;.</source>
          <target state="translated">得到的 &lt;code&gt;Int&lt;/code&gt; 值表示与此 &lt;code&gt;Byte&lt;/code&gt; 相同的数值。</target>
        </trans-unit>
        <trans-unit id="a8d60bc3ef88b39460060b7f8165763da80802bc" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Int&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;Short&lt;/code&gt;.</source>
          <target state="translated">得到的 &lt;code&gt;Int&lt;/code&gt; 值表示与此 &lt;code&gt;Short&lt;/code&gt; 相同的数值。</target>
        </trans-unit>
        <trans-unit id="12aaa5ec83610d73b4b2fc195902417a297ddd61" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Int&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;UByte&lt;/code&gt;.</source>
          <target state="translated">结果 &lt;code&gt;Int&lt;/code&gt; 值表示与此 &lt;code&gt;UByte&lt;/code&gt; 相同的数值。</target>
        </trans-unit>
        <trans-unit id="b30712342fda907bc49df4d10c136bbeeaaf708b" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Int&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;UShort&lt;/code&gt;.</source>
          <target state="translated">最终的 &lt;code&gt;Int&lt;/code&gt; 值表示与此 &lt;code&gt;UShort&lt;/code&gt; 相同的数值。</target>
        </trans-unit>
        <trans-unit id="25bcbeae5576ececd431ec0f451a2c7cf6bf73b4" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Long&lt;/code&gt; value has the same binary representation as this &lt;code&gt;ULong&lt;/code&gt; value.</source>
          <target state="translated">所得的 &lt;code&gt;Long&lt;/code&gt; 值与此 &lt;code&gt;ULong&lt;/code&gt; 值具有相同的二进制表示形式。</target>
        </trans-unit>
        <trans-unit id="e6a0efc4ac5c4b05735980342faa240209bf9353" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Long&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;Byte&lt;/code&gt;.</source>
          <target state="translated">得到的 &lt;code&gt;Long&lt;/code&gt; 值表示与此 &lt;code&gt;Byte&lt;/code&gt; 相同的数值。</target>
        </trans-unit>
        <trans-unit id="a30381cf3452bf71d4466b6a6a9c5a35e959654a" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Long&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;Int&lt;/code&gt;.</source>
          <target state="translated">得到的 &lt;code&gt;Long&lt;/code&gt; 值表示与此 &lt;code&gt;Int&lt;/code&gt; 相同的数值。</target>
        </trans-unit>
        <trans-unit id="7692c28294ebe4518a8808f192338ab899b5aeec" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Long&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;Short&lt;/code&gt;.</source>
          <target state="translated">得到的 &lt;code&gt;Long&lt;/code&gt; 值表示与此 &lt;code&gt;Short&lt;/code&gt; 相同的数值。</target>
        </trans-unit>
        <trans-unit id="60b7e7e3ba10c2b92827e84db685cc040e179ed1" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Long&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;UByte&lt;/code&gt;.</source>
          <target state="translated">得到的 &lt;code&gt;Long&lt;/code&gt; 值表示与此 &lt;code&gt;UByte&lt;/code&gt; 相同的数值。</target>
        </trans-unit>
        <trans-unit id="a95d7e6a557f4530d701aed1a8410d9b6e793205" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Long&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;UInt&lt;/code&gt;.</source>
          <target state="translated">得到的 &lt;code&gt;Long&lt;/code&gt; 值表示与此 &lt;code&gt;UInt&lt;/code&gt; 相同的数值。</target>
        </trans-unit>
        <trans-unit id="e900373f53d6267fd01ecf92bb2c5cb1fed9a7b7" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Long&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;UShort&lt;/code&gt;.</source>
          <target state="translated">得到的 &lt;code&gt;Long&lt;/code&gt; 值表示与此 &lt;code&gt;UShort&lt;/code&gt; 相同的数值。</target>
        </trans-unit>
        <trans-unit id="3866529acc183dc8b682af92a84909ec65bd5749" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Short&lt;/code&gt; value has the same binary representation as this &lt;code&gt;UShort&lt;/code&gt; value.</source>
          <target state="translated">所得的 &lt;code&gt;Short&lt;/code&gt; 值与此 &lt;code&gt;UShort&lt;/code&gt; 值具有相同的二进制表示形式。</target>
        </trans-unit>
        <trans-unit id="5ccfa5aff935ee9326f2b407c585467d126768e7" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Short&lt;/code&gt; value is equal to &lt;code&gt;this.toInt().toShort()&lt;/code&gt;.</source>
          <target state="translated">产生的 &lt;code&gt;Short&lt;/code&gt; 值等于 &lt;code&gt;this.toInt().toShort()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fb338e05b22f496cc978d6bf212ddabde5dd17a4" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Short&lt;/code&gt; value is represented by the least significant 16 bits of this &lt;code&gt;Int&lt;/code&gt; value.</source>
          <target state="translated">结果的 &lt;code&gt;Short&lt;/code&gt; 值由该 &lt;code&gt;Int&lt;/code&gt; 值的最低有效16位表示。</target>
        </trans-unit>
        <trans-unit id="27367d77acd56c6a1050bc0a49a57fcf2061de96" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Short&lt;/code&gt; value is represented by the least significant 16 bits of this &lt;code&gt;Long&lt;/code&gt; value.</source>
          <target state="translated">结果的 &lt;code&gt;Short&lt;/code&gt; 值由该 &lt;code&gt;Long&lt;/code&gt; 值的最低有效16位表示。</target>
        </trans-unit>
        <trans-unit id="0bc0fbdc70644d6d748c478656fa78e912cc16e6" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Short&lt;/code&gt; value is represented by the least significant 16 bits of this &lt;code&gt;UInt&lt;/code&gt; value. Note that the resulting &lt;code&gt;Short&lt;/code&gt; value may be negative.</source>
          <target state="translated">结果的 &lt;code&gt;Short&lt;/code&gt; 值由该 &lt;code&gt;UInt&lt;/code&gt; 值的最低有效16位表示。请注意，所得的 &lt;code&gt;Short&lt;/code&gt; 值可能为负。</target>
        </trans-unit>
        <trans-unit id="bb9494a50b8985a2d74ddd24ec83038bdcd4606a" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Short&lt;/code&gt; value is represented by the least significant 16 bits of this &lt;code&gt;ULong&lt;/code&gt; value. Note that the resulting &lt;code&gt;Short&lt;/code&gt; value may be negative.</source>
          <target state="translated">结果的 &lt;code&gt;Short&lt;/code&gt; 值由该 &lt;code&gt;ULong&lt;/code&gt; 值的最低有效16位表示。请注意，所得的 &lt;code&gt;Short&lt;/code&gt; 值可能为负。</target>
        </trans-unit>
        <trans-unit id="1fbe35f845af4aa0feff1d9060ab35a7c6fe3476" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Short&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;Byte&lt;/code&gt;.</source>
          <target state="translated">得到的 &lt;code&gt;Short&lt;/code&gt; 值表示与此 &lt;code&gt;Byte&lt;/code&gt; 相同的数值。</target>
        </trans-unit>
        <trans-unit id="62163dcead131c0bf0933b1342f420db3bc4bb8d" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Short&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;UByte&lt;/code&gt;.</source>
          <target state="translated">所得的 &lt;code&gt;Short&lt;/code&gt; 值表示与此 &lt;code&gt;UByte&lt;/code&gt; 相同的数值。</target>
        </trans-unit>
        <trans-unit id="26c6a5634d9e1d8b962bb6788ae67bc866b78e45" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;UByte&lt;/code&gt; value has the same binary representation as this &lt;code&gt;Byte&lt;/code&gt; value.</source>
          <target state="translated">所得的 &lt;code&gt;UByte&lt;/code&gt; 值与此 &lt;code&gt;Byte&lt;/code&gt; 值具有相同的二进制表示形式。</target>
        </trans-unit>
        <trans-unit id="11d5b691a4a978c7af952b604f7d065d5eac1305" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;UByte&lt;/code&gt; value is represented by the least significant 8 bits of this &lt;code&gt;Int&lt;/code&gt; value.</source>
          <target state="translated">所得的 &lt;code&gt;UByte&lt;/code&gt; 值由该 &lt;code&gt;Int&lt;/code&gt; 值的最低有效8位表示。</target>
        </trans-unit>
        <trans-unit id="5226c83d79204652c28eff49e7528cb1e99fe2d6" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;UByte&lt;/code&gt; value is represented by the least significant 8 bits of this &lt;code&gt;Long&lt;/code&gt; value.</source>
          <target state="translated">将所得 &lt;code&gt;UByte&lt;/code&gt; 值由这种的至少显著8位表示 &lt;code&gt;Long&lt;/code&gt; 值。</target>
        </trans-unit>
        <trans-unit id="726d8e3bdd3b093a08a44094c2cae4da994770da" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;UByte&lt;/code&gt; value is represented by the least significant 8 bits of this &lt;code&gt;Short&lt;/code&gt; value.</source>
          <target state="translated">将所得 &lt;code&gt;UByte&lt;/code&gt; 值由这种的至少显著8位表示 &lt;code&gt;Short&lt;/code&gt; 值。</target>
        </trans-unit>
        <trans-unit id="1dfb49e88d21be6bcb0f49bf822a5aaa6937a983" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;UByte&lt;/code&gt; value is represented by the least significant 8 bits of this &lt;code&gt;UInt&lt;/code&gt; value.</source>
          <target state="translated">所得的 &lt;code&gt;UByte&lt;/code&gt; 值由该 &lt;code&gt;UInt&lt;/code&gt; 值的最低有效8位表示。</target>
        </trans-unit>
        <trans-unit id="2686cc59be2588fb1dc986c8db1acdab514c552c" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;UByte&lt;/code&gt; value is represented by the least significant 8 bits of this &lt;code&gt;ULong&lt;/code&gt; value.</source>
          <target state="translated">所得的 &lt;code&gt;UByte&lt;/code&gt; 值由该 &lt;code&gt;ULong&lt;/code&gt; 值的最低有效8位表示。</target>
        </trans-unit>
        <trans-unit id="a5d21503bfa5cb9b99c854c368f0b66239678aba" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;UByte&lt;/code&gt; value is represented by the least significant 8 bits of this &lt;code&gt;UShort&lt;/code&gt; value.</source>
          <target state="translated">所得的 &lt;code&gt;UByte&lt;/code&gt; 值由该 &lt;code&gt;UShort&lt;/code&gt; 值的最低有效8位表示。</target>
        </trans-unit>
        <trans-unit id="4f3fe5211f1aea05bea1a841d6d73788aeeb2998" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;UInt&lt;/code&gt; value has the same binary representation as this &lt;code&gt;Int&lt;/code&gt; value.</source>
          <target state="translated">所得的 &lt;code&gt;UInt&lt;/code&gt; 值与此 &lt;code&gt;Int&lt;/code&gt; 值具有相同的二进制表示形式。</target>
        </trans-unit>
        <trans-unit id="66a1e76fd131680ad5406468e22ad3973f35ff4e" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;UInt&lt;/code&gt; value is represented by the least significant 32 bits of this &lt;code&gt;Long&lt;/code&gt; value.</source>
          <target state="translated">最终的 &lt;code&gt;UInt&lt;/code&gt; 值由此 &lt;code&gt;Long&lt;/code&gt; 值的最低有效32位表示。</target>
        </trans-unit>
        <trans-unit id="bc935cba2a00e8cc63899ff18d12438a89739380" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;UInt&lt;/code&gt; value is represented by the least significant 32 bits of this &lt;code&gt;ULong&lt;/code&gt; value.</source>
          <target state="translated">最终的 &lt;code&gt;UInt&lt;/code&gt; 值由该 &lt;code&gt;ULong&lt;/code&gt; 值的最低有效32位表示。</target>
        </trans-unit>
        <trans-unit id="9d9ba2608012da37a52b5b9b7da96f6d67796334" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;UInt&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;UByte&lt;/code&gt;.</source>
          <target state="translated">所得的 &lt;code&gt;UInt&lt;/code&gt; 值表示与此 &lt;code&gt;UByte&lt;/code&gt; 相同的数值。</target>
        </trans-unit>
        <trans-unit id="9ab12c98c1ea5502db93ef496727f7d48f4edc12" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;UInt&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;UShort&lt;/code&gt;.</source>
          <target state="translated">最终的 &lt;code&gt;UInt&lt;/code&gt; 值表示与此 &lt;code&gt;UShort&lt;/code&gt; 相同的数值。</target>
        </trans-unit>
        <trans-unit id="e00a9f9829597db51c5f5f105c5c613e61839318" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;ULong&lt;/code&gt; value has the same binary representation as this &lt;code&gt;Long&lt;/code&gt; value.</source>
          <target state="translated">所得的 &lt;code&gt;ULong&lt;/code&gt; 值与此 &lt;code&gt;Long&lt;/code&gt; 值具有相同的二进制表示形式。</target>
        </trans-unit>
        <trans-unit id="a5fe358a0a132b3d4ac886ee0067825836c972c3" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;ULong&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;UByte&lt;/code&gt;.</source>
          <target state="translated">得到的 &lt;code&gt;ULong&lt;/code&gt; 值表示与此 &lt;code&gt;UByte&lt;/code&gt; 相同的数值。</target>
        </trans-unit>
        <trans-unit id="1e225f6484184e1fd9b9a789c6be2168c16944f8" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;ULong&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;UInt&lt;/code&gt;.</source>
          <target state="translated">得到的 &lt;code&gt;ULong&lt;/code&gt; 值表示与此 &lt;code&gt;UInt&lt;/code&gt; 相同的数值。</target>
        </trans-unit>
        <trans-unit id="951d01157187c8755e4bb93be0ec662d70035ced" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;ULong&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;UShort&lt;/code&gt;.</source>
          <target state="translated">得到的 &lt;code&gt;ULong&lt;/code&gt; 值表示与此 &lt;code&gt;UShort&lt;/code&gt; 相同的数值。</target>
        </trans-unit>
        <trans-unit id="76c0754fefaa89b43d0e48e2d3b2efa1a3c37cac" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;UShort&lt;/code&gt; value has the same binary representation as this &lt;code&gt;Short&lt;/code&gt; value.</source>
          <target state="translated">所得的 &lt;code&gt;UShort&lt;/code&gt; 值与此 &lt;code&gt;Short&lt;/code&gt; 值具有相同的二进制表示形式。</target>
        </trans-unit>
        <trans-unit id="ed25489ad27c7ad2fa4a9e9ed8a17e177ed921a7" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;UShort&lt;/code&gt; value is represented by the least significant 16 bits of this &lt;code&gt;Int&lt;/code&gt; value.</source>
          <target state="translated">所得的 &lt;code&gt;UShort&lt;/code&gt; 值由该 &lt;code&gt;Int&lt;/code&gt; 值的最低有效16位表示。</target>
        </trans-unit>
        <trans-unit id="f42954d6785f3d5db6ef1809c504748ad3c8598b" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;UShort&lt;/code&gt; value is represented by the least significant 16 bits of this &lt;code&gt;Long&lt;/code&gt; value.</source>
          <target state="translated">结果 &lt;code&gt;UShort&lt;/code&gt; 值由该 &lt;code&gt;Long&lt;/code&gt; 值的最低有效16位表示。</target>
        </trans-unit>
        <trans-unit id="1457c7b3fcc5ff173b3ad803474b4e660273fb3a" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;UShort&lt;/code&gt; value is represented by the least significant 16 bits of this &lt;code&gt;UInt&lt;/code&gt; value.</source>
          <target state="translated">所得的 &lt;code&gt;UShort&lt;/code&gt; 值由该 &lt;code&gt;UInt&lt;/code&gt; 值的最低有效16位表示。</target>
        </trans-unit>
        <trans-unit id="f4cfae00353cb363d45d034bd2773a412889ab06" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;UShort&lt;/code&gt; value is represented by the least significant 16 bits of this &lt;code&gt;ULong&lt;/code&gt; value.</source>
          <target state="translated">所得的 &lt;code&gt;UShort&lt;/code&gt; 值由该 &lt;code&gt;ULong&lt;/code&gt; 值的最低有效16位表示。</target>
        </trans-unit>
        <trans-unit id="fd44eb3bc0245bda18586fe624c6aa7f2130c655" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;UShort&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;UByte&lt;/code&gt;.</source>
          <target state="translated">所得的 &lt;code&gt;UShort&lt;/code&gt; 值表示与此 &lt;code&gt;UByte&lt;/code&gt; 相同的数值。</target>
        </trans-unit>
        <trans-unit id="26ad7d1c46a7946f361222464d3fd9f54190f2e7" translate="yes" xml:space="preserve">
          <source>The resulting value is the closest &lt;code&gt;Double&lt;/code&gt; to this &lt;code&gt;Long&lt;/code&gt; value. In case when this &lt;code&gt;Long&lt;/code&gt; value is exactly between two &lt;code&gt;Double&lt;/code&gt;s, the one with zero at least significant bit of mantissa is selected.</source>
          <target state="translated">结果值是与此 &lt;code&gt;Long&lt;/code&gt; 值最接近的 &lt;code&gt;Double&lt;/code&gt; 。如果此 &lt;code&gt;Long&lt;/code&gt; 值恰好在两个 &lt;code&gt;Double&lt;/code&gt; 之间，则选择尾数至少为0的那个。</target>
        </trans-unit>
        <trans-unit id="492c13f0924f52f27eadd038e36be9a70c7d0f23" translate="yes" xml:space="preserve">
          <source>The resulting value is the closest &lt;code&gt;Double&lt;/code&gt; to this &lt;code&gt;ULong&lt;/code&gt; value. In case when this &lt;code&gt;ULong&lt;/code&gt; value is exactly between two &lt;code&gt;Double&lt;/code&gt;s, the one with zero at least significant bit of mantissa is selected.</source>
          <target state="translated">结果值是与此 &lt;code&gt;ULong&lt;/code&gt; 值最接近的 &lt;code&gt;Double&lt;/code&gt; 。如果此 &lt;code&gt;ULong&lt;/code&gt; 值恰好在两个 &lt;code&gt;Double&lt;/code&gt; 之间，则选择尾数至少为0的那个。</target>
        </trans-unit>
        <trans-unit id="fc0e588cba1b5e32b36bbd725d91a005e8eca137" translate="yes" xml:space="preserve">
          <source>The resulting value is the closest &lt;code&gt;Float&lt;/code&gt; to this &lt;code&gt;Double&lt;/code&gt; value. In case when this &lt;code&gt;Double&lt;/code&gt; value is exactly between two &lt;code&gt;Float&lt;/code&gt;s, the one with zero at least significant bit of mantissa is selected.</source>
          <target state="translated">结果值是最接近此 &lt;code&gt;Double&lt;/code&gt; 值的 &lt;code&gt;Float&lt;/code&gt; 。如果此 &lt;code&gt;Double&lt;/code&gt; 值恰好在两个 &lt;code&gt;Float&lt;/code&gt; 之间，则选择尾数至少为0的那个。</target>
        </trans-unit>
        <trans-unit id="1a94a9e0d2914f4ed72b19cd967f6325996af0de" translate="yes" xml:space="preserve">
          <source>The resulting value is the closest &lt;code&gt;Float&lt;/code&gt; to this &lt;code&gt;Int&lt;/code&gt; value. In case when this &lt;code&gt;Int&lt;/code&gt; value is exactly between two &lt;code&gt;Float&lt;/code&gt;s, the one with zero at least significant bit of mantissa is selected.</source>
          <target state="translated">结果值是最接近此 &lt;code&gt;Int&lt;/code&gt; 值的 &lt;code&gt;Float&lt;/code&gt; 。如果此 &lt;code&gt;Int&lt;/code&gt; 值恰好在两个 &lt;code&gt;Float&lt;/code&gt; 之间，则选择尾数至少为0的那个。</target>
        </trans-unit>
        <trans-unit id="4c34f885e332b614efeb077bdc9dc7f566d719ac" translate="yes" xml:space="preserve">
          <source>The resulting value is the closest &lt;code&gt;Float&lt;/code&gt; to this &lt;code&gt;Long&lt;/code&gt; value. In case when this &lt;code&gt;Long&lt;/code&gt; value is exactly between two &lt;code&gt;Float&lt;/code&gt;s, the one with zero at least significant bit of mantissa is selected.</source>
          <target state="translated">结果值是最接近此 &lt;code&gt;Long&lt;/code&gt; 值的 &lt;code&gt;Float&lt;/code&gt; 。如果此 &lt;code&gt;Long&lt;/code&gt; 值恰好在两个 &lt;code&gt;Float&lt;/code&gt; 之间，则选择尾数至少为0的那个。</target>
        </trans-unit>
        <trans-unit id="56778d0fa4ef4bd39c3c6c8e27df252ff267b86a" translate="yes" xml:space="preserve">
          <source>The resulting value is the closest &lt;code&gt;Float&lt;/code&gt; to this &lt;code&gt;UInt&lt;/code&gt; value. In case when this &lt;code&gt;UInt&lt;/code&gt; value is exactly between two &lt;code&gt;Float&lt;/code&gt;s, the one with zero at least significant bit of mantissa is selected.</source>
          <target state="translated">结果值是最接近此 &lt;code&gt;UInt&lt;/code&gt; 值的 &lt;code&gt;Float&lt;/code&gt; 。如果此 &lt;code&gt;UInt&lt;/code&gt; 值恰好在两个 &lt;code&gt;Float&lt;/code&gt; 之间，则选择至少零个有效尾数的那个。</target>
        </trans-unit>
        <trans-unit id="498957909e2b3c5b2a70150c6779dc9db0eb20c7" translate="yes" xml:space="preserve">
          <source>The resulting value is the closest &lt;code&gt;Float&lt;/code&gt; to this &lt;code&gt;ULong&lt;/code&gt; value. In case when this &lt;code&gt;ULong&lt;/code&gt; value is exactly between two &lt;code&gt;Float&lt;/code&gt;s, the one with zero at least significant bit of mantissa is selected.</source>
          <target state="translated">结果值是最接近此 &lt;code&gt;ULong&lt;/code&gt; 值的 &lt;code&gt;Float&lt;/code&gt; 。如果此 &lt;code&gt;ULong&lt;/code&gt; 值恰好在两个 &lt;code&gt;Float&lt;/code&gt; 之间，则选择至少零个有效尾数的零。</target>
        </trans-unit>
        <trans-unit id="65d14c2cdb6c9b143338a902f9c4de4c9b45f92f" translate="yes" xml:space="preserve">
          <source>The return type inference for anonymous functions works just like for normal functions: the return type is inferred automatically for anonymous functions with an expression body and has to be specified explicitly (or is assumed to be &lt;code&gt;Unit&lt;/code&gt;) for anonymous functions with a block body.</source>
          <target state="translated">匿名函数的返回类型推断的工作原理与普通函数一样：对于具有表达式主体的匿名函数，将自动推断返回类型，对于具有块主体的匿名函数，必须明确指定返回类型（或假定为 &lt;code&gt;Unit&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="dbab78ef44eaefb4e469bd1e51f4e8661d634cea" translate="yes" xml:space="preserve">
          <source>The return type of a function-typed return type (the user expects the returned function to return &lt;code&gt;Fruit&lt;/code&gt;, so it's okay if it really returns &lt;code&gt;Apple&lt;/code&gt;)</source>
          <target state="translated">函数类型的返回类型的返回类型（用户希望返回的函数返回 &lt;code&gt;Fruit&lt;/code&gt; ，因此，如果它确实返回 &lt;code&gt;Apple&lt;/code&gt; ,也可以）</target>
        </trans-unit>
        <trans-unit id="d8362d946ac99a87abd0521089565682c0510f07" translate="yes" xml:space="preserve">
          <source>The return type of a lambda expression is inferred from the type of the last expression inside it (or from the function type of the variable/parameter that the lambda expression is assigned to). If a lambda expression is passed as a function parameter (which is the ordinary use) or assigned to a variable with a declared type, Kotlin can infer the parameter types too, and you only need to specify their names:</source>
          <target state="translated">一个lambda表达式的返回类型是根据它里面最后一个表达式的类型来推断的(或者是根据lambda表达式分配给的变量/参数的函数类型)。如果一个lambda表达式作为函数参数传递(这是普通的用法),或者分配给一个有声明类型的变量,Kotlin也可以推断出参数类型,你只需要指定它们的名字。</target>
        </trans-unit>
        <trans-unit id="d7c260eb93497371636dc4de8fdb8ef84ac32045" translate="yes" xml:space="preserve">
          <source>The return value of &lt;code&gt;apply&lt;/code&gt; and &lt;code&gt;also&lt;/code&gt; is the context object itself. Hence, they can be included into call chains as &lt;em&gt;side steps&lt;/em&gt;: you can continue chaining function calls on the same object after them.</source>
          <target state="translated">&lt;code&gt;apply&lt;/code&gt; 和的返回值 &lt;code&gt;also&lt;/code&gt; 上下文对象本身。因此，它们可以作为&lt;em&gt;副步骤&lt;/em&gt;包含在调用链中：您可以在它们之后继续在同一对象上链接函数调用。</target>
        </trans-unit>
        <trans-unit id="6d324367f598aa028770dca0838f66177648fed1" translate="yes" xml:space="preserve">
          <source>The return value.</source>
          <target state="translated">返回值。</target>
        </trans-unit>
        <trans-unit id="02d73a0e151892c1ff98e7a6888b38592bdd4e2a" translate="yes" xml:space="preserve">
          <source>The returned &lt;a href=&quot;../-time-mark/index&quot;&gt;TimeMark&lt;/a&gt; instance encapsulates the captured time point and allows querying the duration of time interval &lt;a href=&quot;../-time-mark/elapsed-now&quot;&gt;elapsed&lt;/a&gt; from that point.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="046b6584c1bbd3a7a64857edece72cc830dec917" translate="yes" xml:space="preserve">
          <source>The returned instance uses the specified &lt;a href=&quot;lazy#kotlin%24lazy%28kotlin.Any%2C+kotlin.Function0%28%28kotlin.lazy.T%29%29%29%2Flock&quot;&gt;lock&lt;/a&gt; object to synchronize on. When the &lt;a href=&quot;lazy#kotlin%24lazy%28kotlin.Any%2C+kotlin.Function0%28%28kotlin.lazy.T%29%29%29%2Flock&quot;&gt;lock&lt;/a&gt; is not specified the instance uses itself to synchronize on, in this case do not synchronize from external code on the returned instance as it may cause accidental deadlock. Also this behavior can be changed in the future.</source>
          <target state="translated">返回的实例使用指定的&lt;a href=&quot;lazy#kotlin%24lazy%28kotlin.Any%2C+kotlin.Function0%28%28kotlin.lazy.T%29%29%29%2Flock&quot;&gt;锁定&lt;/a&gt;对象进行同步。如果未指定&lt;a href=&quot;lazy#kotlin%24lazy%28kotlin.Any%2C+kotlin.Function0%28%28kotlin.lazy.T%29%29%29%2Flock&quot;&gt;锁，&lt;/a&gt;则实例将使用自身进行同步，在这种情况下，请勿与返回的实例上的外部代码进行同步，因为这可能会导致意外的死锁。同样，将来可以更改此行为。</target>
        </trans-unit>
        <trans-unit id="9b93655dba3d2a18324e24a42bc0aa37bcaff559" translate="yes" xml:space="preserve">
          <source>The returned instance uses the specified &lt;a href=&quot;lazy#kotlin%24lazy(kotlin.Any?,%20kotlin.Function0((kotlin.lazy.T)))/lock&quot;&gt;lock&lt;/a&gt; object to synchronize on. When the &lt;a href=&quot;lazy#kotlin%24lazy(kotlin.Any?,%20kotlin.Function0((kotlin.lazy.T)))/lock&quot;&gt;lock&lt;/a&gt; is not specified the instance uses itself to synchronize on, in this case do not synchronize from external code on the returned instance as it may cause accidental deadlock. Also this behavior can be changed in the future.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97bfc2ca377533226a66b10393317b0a2f994fba" translate="yes" xml:space="preserve">
          <source>The returned list is empty if this char sequence contains less than two characters.</source>
          <target state="translated">如果这个字符序列包含的字符数少于两个,则返回的列表为空。</target>
        </trans-unit>
        <trans-unit id="d158c2273db93047119908af61efbbba35bd76f3" translate="yes" xml:space="preserve">
          <source>The returned list is empty if this collection contains less than two elements.</source>
          <target state="translated">如果这个集合包含的元素少于两个,则返回的列表为空。</target>
        </trans-unit>
        <trans-unit id="29bbad5c305945f97c70cd75ffccab450111f2ea" translate="yes" xml:space="preserve">
          <source>The returned map is serializable (JVM).</source>
          <target state="translated">返回的地图是可序列化的(JVM)。</target>
        </trans-unit>
        <trans-unit id="ec4d25dd41a10ce08bae955efed7031764938b43" translate="yes" xml:space="preserve">
          <source>The returned map is serializable.</source>
          <target state="translated">返回的地图是可序列化的。</target>
        </trans-unit>
        <trans-unit id="6f1137c5bd275e0d050f73fe1ffb45e6bc0fef52" translate="yes" xml:space="preserve">
          <source>The returned map preserves the entry iteration order of the keys produced from the original array.</source>
          <target state="translated">返回的映射保留了从原始数组产生的键的入口迭代顺序。</target>
        </trans-unit>
        <trans-unit id="aab8c4af63582433af11da060d436e3782362d9a" translate="yes" xml:space="preserve">
          <source>The returned map preserves the entry iteration order of the keys produced from the original char sequence.</source>
          <target state="translated">返回的映射保留了从原始char序列产生的键的入口迭代顺序。</target>
        </trans-unit>
        <trans-unit id="16f1a5aa5ffd50a8f9547783402bf7757df5025f" translate="yes" xml:space="preserve">
          <source>The returned map preserves the entry iteration order of the keys produced from the original collection.</source>
          <target state="translated">返回的映射保留了从原始集合产生的键的入口迭代顺序。</target>
        </trans-unit>
        <trans-unit id="19c068ac54b988c0d6076dddd8c2dbf4092708f6" translate="yes" xml:space="preserve">
          <source>The returned map preserves the entry iteration order of the keys produced from the original sequence.</source>
          <target state="translated">返回的映射保留了从原始序列产生的键的入口迭代顺序。</target>
        </trans-unit>
        <trans-unit id="f54f229a0ee8d8720d828fe3e27b2d2a6ca940bc" translate="yes" xml:space="preserve">
          <source>The returned map preserves the entry iteration order of the original array.</source>
          <target state="translated">返回的映射保留了原始数组的条目迭代顺序。</target>
        </trans-unit>
        <trans-unit id="918c726186d31885a03be5dd5847d194f356551f" translate="yes" xml:space="preserve">
          <source>The returned map preserves the entry iteration order of the original array. If any of two pairs would have the same key the last one gets added to the map.</source>
          <target state="translated">返回的映射保留了原始数组的条目迭代顺序。如果两个数组中的任何一个数组有相同的键,则最后一个数组会被添加到映射中。</target>
        </trans-unit>
        <trans-unit id="1331dc1f7dcbe48a5148654c3f9a9dd17b60c885" translate="yes" xml:space="preserve">
          <source>The returned map preserves the entry iteration order of the original char sequence.</source>
          <target state="translated">返回的映射保留了原始char序列的入口迭代顺序。</target>
        </trans-unit>
        <trans-unit id="566ed3a9dcb7ca74d4f2c70c6fdf84ac896debb5" translate="yes" xml:space="preserve">
          <source>The returned map preserves the entry iteration order of the original collection.</source>
          <target state="translated">返回的地图保留了原始集合的条目迭代顺序。</target>
        </trans-unit>
        <trans-unit id="2e469a2caf818c0835cee9e0a1babf1e2e3c07a5" translate="yes" xml:space="preserve">
          <source>The returned map preserves the entry iteration order of the original collection. If any of two pairs would have the same key the last one gets added to the map.</source>
          <target state="translated">返回的映射保留了原始集合的条目迭代顺序。如果任何两个对有相同的键,最后一个会被添加到映射中。</target>
        </trans-unit>
        <trans-unit id="4c19d30d5fb69c54a255c5b1e548f2fa56d3aefb" translate="yes" xml:space="preserve">
          <source>The returned map preserves the entry iteration order of the original map.</source>
          <target state="translated">返回的地图保留了原始地图的条目迭代顺序。</target>
        </trans-unit>
        <trans-unit id="f87204408405ad88a40594eff8f4867029a89b59" translate="yes" xml:space="preserve">
          <source>The returned map preserves the entry iteration order of the original map. The &lt;a href=&quot;plus#kotlin.collections%24plus%28kotlin.collections.Map%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%2C+kotlin.Pair%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%29%2Fpair&quot;&gt;pair&lt;/a&gt; is iterated in the end if it has a unique key.</source>
          <target state="translated">返回的地图保留了原始地图的输入迭代顺序。如果该&lt;a href=&quot;plus#kotlin.collections%24plus%28kotlin.collections.Map%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%2C+kotlin.Pair%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%29%2Fpair&quot;&gt;对&lt;/a&gt;具有唯一密钥，则最后对其进行迭代。</target>
        </trans-unit>
        <trans-unit id="2699ea2c18d183922dd8db09dd9a3f0e18a1eb1d" translate="yes" xml:space="preserve">
          <source>The returned map preserves the entry iteration order of the original map. The &lt;a href=&quot;plus#kotlin.collections%24plus(kotlin.collections.Map((kotlin.collections.plus.K,%20kotlin.collections.plus.V)),%20kotlin.Pair((kotlin.collections.plus.K,%20kotlin.collections.plus.V)))/pair&quot;&gt;pair&lt;/a&gt; is iterated in the end if it has a unique key.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ff3f66b8173f81182161d671f67a90a7b9f8d74" translate="yes" xml:space="preserve">
          <source>The returned map preserves the entry iteration order of the original map. Those &lt;a href=&quot;plus#kotlin.collections%24plus%28kotlin.collections.Map%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%2C+kotlin.Array%28%28kotlin.Pair%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%29%29%29%2Fpairs&quot;&gt;pairs&lt;/a&gt; with unique keys are iterated in the end in the order of &lt;a href=&quot;plus#kotlin.collections%24plus%28kotlin.collections.Map%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%2C+kotlin.Array%28%28kotlin.Pair%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%29%29%29%2Fpairs&quot;&gt;pairs&lt;/a&gt; array.</source>
          <target state="translated">返回的地图保留了原始地图的输入迭代顺序。那些&lt;a href=&quot;plus#kotlin.collections%24plus%28kotlin.collections.Map%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%2C+kotlin.Array%28%28kotlin.Pair%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%29%29%29%2Fpairs&quot;&gt;对&lt;/a&gt;具有独特的键被迭代中的顺序结束&lt;a href=&quot;plus#kotlin.collections%24plus%28kotlin.collections.Map%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%2C+kotlin.Array%28%28kotlin.Pair%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%29%29%29%2Fpairs&quot;&gt;对&lt;/a&gt;数组。</target>
        </trans-unit>
        <trans-unit id="4c15bc5f538aa94ff9d36f2c463553e37bffffa8" translate="yes" xml:space="preserve">
          <source>The returned map preserves the entry iteration order of the original map. Those &lt;a href=&quot;plus#kotlin.collections%24plus%28kotlin.collections.Map%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%2C+kotlin.collections.Iterable%28%28kotlin.Pair%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%29%29%29%2Fpairs&quot;&gt;pairs&lt;/a&gt; with unique keys are iterated in the end in the order of &lt;a href=&quot;plus#kotlin.collections%24plus%28kotlin.collections.Map%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%2C+kotlin.collections.Iterable%28%28kotlin.Pair%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%29%29%29%2Fpairs&quot;&gt;pairs&lt;/a&gt; collection.</source>
          <target state="translated">返回的地图保留了原始地图的输入迭代顺序。最后，按照&lt;a href=&quot;plus#kotlin.collections%24plus%28kotlin.collections.Map%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%2C+kotlin.collections.Iterable%28%28kotlin.Pair%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%29%29%29%2Fpairs&quot;&gt;对&lt;/a&gt;集合的顺序对那些具有唯一密钥的&lt;a href=&quot;plus#kotlin.collections%24plus%28kotlin.collections.Map%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%2C+kotlin.collections.Iterable%28%28kotlin.Pair%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%29%29%29%2Fpairs&quot;&gt;对&lt;/a&gt;进行迭代。</target>
        </trans-unit>
        <trans-unit id="41524b28b32f1890886788ed586175d793500478" translate="yes" xml:space="preserve">
          <source>The returned map preserves the entry iteration order of the original map. Those &lt;a href=&quot;plus#kotlin.collections%24plus%28kotlin.collections.Map%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%2C+kotlin.sequences.Sequence%28%28kotlin.Pair%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%29%29%29%2Fpairs&quot;&gt;pairs&lt;/a&gt; with unique keys are iterated in the end in the order of &lt;a href=&quot;plus#kotlin.collections%24plus%28kotlin.collections.Map%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%2C+kotlin.sequences.Sequence%28%28kotlin.Pair%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%29%29%29%2Fpairs&quot;&gt;pairs&lt;/a&gt; sequence.</source>
          <target state="translated">返回的地图保留了原始地图的输入迭代顺序。最后，按照&lt;a href=&quot;plus#kotlin.collections%24plus%28kotlin.collections.Map%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%2C+kotlin.sequences.Sequence%28%28kotlin.Pair%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%29%29%29%2Fpairs&quot;&gt;对&lt;/a&gt;顺序的顺序对那些具有唯一密钥的&lt;a href=&quot;plus#kotlin.collections%24plus%28kotlin.collections.Map%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%2C+kotlin.sequences.Sequence%28%28kotlin.Pair%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%29%29%29%2Fpairs&quot;&gt;对&lt;/a&gt;进行迭代。</target>
        </trans-unit>
        <trans-unit id="f1a276280301194297ba4dd69f82e32624b066f0" translate="yes" xml:space="preserve">
          <source>The returned map preserves the entry iteration order of the original map. Those &lt;a href=&quot;plus#kotlin.collections%24plus(kotlin.collections.Map((kotlin.collections.plus.K,%20kotlin.collections.plus.V)),%20kotlin.Array((kotlin.Pair((kotlin.collections.plus.K,%20kotlin.collections.plus.V)))))/pairs&quot;&gt;pairs&lt;/a&gt; with unique keys are iterated in the end in the order of &lt;a href=&quot;plus#kotlin.collections%24plus(kotlin.collections.Map((kotlin.collections.plus.K,%20kotlin.collections.plus.V)),%20kotlin.Array((kotlin.Pair((kotlin.collections.plus.K,%20kotlin.collections.plus.V)))))/pairs&quot;&gt;pairs&lt;/a&gt; array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60a4b6ca8bf806aec99d136cb53e3d0881c0b238" translate="yes" xml:space="preserve">
          <source>The returned map preserves the entry iteration order of the original map. Those &lt;a href=&quot;plus#kotlin.collections%24plus(kotlin.collections.Map((kotlin.collections.plus.K,%20kotlin.collections.plus.V)),%20kotlin.collections.Iterable((kotlin.Pair((kotlin.collections.plus.K,%20kotlin.collections.plus.V)))))/pairs&quot;&gt;pairs&lt;/a&gt; with unique keys are iterated in the end in the order of &lt;a href=&quot;plus#kotlin.collections%24plus(kotlin.collections.Map((kotlin.collections.plus.K,%20kotlin.collections.plus.V)),%20kotlin.collections.Iterable((kotlin.Pair((kotlin.collections.plus.K,%20kotlin.collections.plus.V)))))/pairs&quot;&gt;pairs&lt;/a&gt; collection.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1d13bbc3f9bab24f8a9c962714d64145931ced0" translate="yes" xml:space="preserve">
          <source>The returned map preserves the entry iteration order of the original map. Those &lt;a href=&quot;plus#kotlin.collections%24plus(kotlin.collections.Map((kotlin.collections.plus.K,%20kotlin.collections.plus.V)),%20kotlin.sequences.Sequence((kotlin.Pair((kotlin.collections.plus.K,%20kotlin.collections.plus.V)))))/pairs&quot;&gt;pairs&lt;/a&gt; with unique keys are iterated in the end in the order of &lt;a href=&quot;plus#kotlin.collections%24plus(kotlin.collections.Map((kotlin.collections.plus.K,%20kotlin.collections.plus.V)),%20kotlin.sequences.Sequence((kotlin.Pair((kotlin.collections.plus.K,%20kotlin.collections.plus.V)))))/pairs&quot;&gt;pairs&lt;/a&gt; sequence.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af1ab049b7a80d37b426b5189d29b3d33630f886" translate="yes" xml:space="preserve">
          <source>The returned map preserves the entry iteration order of the original map. Those entries of another &lt;a href=&quot;plus#kotlin.collections%24plus%28kotlin.collections.Map%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%2C+kotlin.collections.Map%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%29%2Fmap&quot;&gt;map&lt;/a&gt; that are missing in this map are iterated in the end in the order of that &lt;a href=&quot;plus#kotlin.collections%24plus%28kotlin.collections.Map%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%2C+kotlin.collections.Map%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%29%2Fmap&quot;&gt;map&lt;/a&gt;.</source>
          <target state="translated">返回的地图保留了原始地图的输入迭代顺序。最后，按照该&lt;a href=&quot;plus#kotlin.collections%24plus%28kotlin.collections.Map%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%2C+kotlin.collections.Map%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%29%2Fmap&quot;&gt;映射&lt;/a&gt;的顺序对另一个&lt;a href=&quot;plus#kotlin.collections%24plus%28kotlin.collections.Map%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%2C+kotlin.collections.Map%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%29%2Fmap&quot;&gt;映射&lt;/a&gt;中缺少的条目进行迭代。</target>
        </trans-unit>
        <trans-unit id="9b1dd6b497b334d1c744c85f81ba4c2ff9742b26" translate="yes" xml:space="preserve">
          <source>The returned map preserves the entry iteration order of the original map. Those entries of another &lt;a href=&quot;plus#kotlin.collections%24plus(kotlin.collections.Map((kotlin.collections.plus.K,%20kotlin.collections.plus.V)),%20kotlin.collections.Map((kotlin.collections.plus.K,%20kotlin.collections.plus.V)))/map&quot;&gt;map&lt;/a&gt; that are missing in this map are iterated in the end in the order of that &lt;a href=&quot;plus#kotlin.collections%24plus(kotlin.collections.Map((kotlin.collections.plus.K,%20kotlin.collections.plus.V)),%20kotlin.collections.Map((kotlin.collections.plus.K,%20kotlin.collections.plus.V)))/map&quot;&gt;map&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="048dcd341f30e50bd04dda11327a4ef88e0d2612" translate="yes" xml:space="preserve">
          <source>The returned map preserves the entry iteration order of the original sequence.</source>
          <target state="translated">返回的映射保留了原始序列的入口迭代顺序。</target>
        </trans-unit>
        <trans-unit id="bba2889b44a4cec09a40249a683767a797d71e14" translate="yes" xml:space="preserve">
          <source>The returned map preserves the entry iteration order of the original sequence. If any of two pairs would have the same key the last one gets added to the map.</source>
          <target state="translated">返回的映射保留了原始序列的条目迭代顺序。如果任何两对中有相同的键,最后一个会被添加到映射中。</target>
        </trans-unit>
        <trans-unit id="b48dc5da4ba5d84bf8f51570f1be30c9067ca36a" translate="yes" xml:space="preserve">
          <source>The returned map preserves the entry iteration order.</source>
          <target state="translated">返回的地图保留了条目迭代顺序。</target>
        </trans-unit>
        <trans-unit id="d70c61d5fb5764eefc41a239b3b607225317f588" translate="yes" xml:space="preserve">
          <source>The returned sequence is constrained to be iterated only once.</source>
          <target state="translated">返回的序列被约束为只能迭代一次。</target>
        </trans-unit>
        <trans-unit id="a79b9e6a21565ad6033f2ab5027e737873a51569" translate="yes" xml:space="preserve">
          <source>The returned sequence is empty if this sequence contains less than two elements.</source>
          <target state="translated">如果这个序列包含的元素少于两个,则返回的序列为空。</target>
        </trans-unit>
        <trans-unit id="7927ae1e5106eaeb7bb0b0dc1138826c33d1919c" translate="yes" xml:space="preserve">
          <source>The returned set preserves the element iteration order of the original array.</source>
          <target state="translated">返回的集合保留了原始数组的元素迭代顺序。</target>
        </trans-unit>
        <trans-unit id="8e820b287237249236a403161f0b70ed17d391a2" translate="yes" xml:space="preserve">
          <source>The returned set preserves the element iteration order of the original array. Those elements of the &lt;a href=&quot;union#kotlin.collections%24union%28kotlin.Array%28%28kotlin.collections.union.T%29%29%2C+kotlin.collections.Iterable%28%28kotlin.collections.union.T%29%29%29%2Fother&quot;&gt;other&lt;/a&gt; collection that are unique are iterated in the end in the order of the &lt;a href=&quot;union#kotlin.collections%24union%28kotlin.Array%28%28kotlin.collections.union.T%29%29%2C+kotlin.collections.Iterable%28%28kotlin.collections.union.T%29%29%29%2Fother&quot;&gt;other&lt;/a&gt; collection.</source>
          <target state="translated">返回的集合保留原始数组的元素迭代顺序。最后，以&lt;a href=&quot;union#kotlin.collections%24union%28kotlin.Array%28%28kotlin.collections.union.T%29%29%2C+kotlin.collections.Iterable%28%28kotlin.collections.union.T%29%29%29%2Fother&quot;&gt;另一个&lt;/a&gt;集合的顺序迭代&lt;a href=&quot;union#kotlin.collections%24union%28kotlin.Array%28%28kotlin.collections.union.T%29%29%2C+kotlin.collections.Iterable%28%28kotlin.collections.union.T%29%29%29%2Fother&quot;&gt;另一个&lt;/a&gt;集合中唯一的那些元素。</target>
        </trans-unit>
        <trans-unit id="3daac3d7a93bd39f019e22a0fe48ced02c6896f9" translate="yes" xml:space="preserve">
          <source>The returned set preserves the element iteration order of the original array. Those elements of the &lt;a href=&quot;union#kotlin.collections%24union(kotlin.Array((kotlin.collections.union.T)),%20kotlin.collections.Iterable((kotlin.collections.union.T)))/other&quot;&gt;other&lt;/a&gt; collection that are unique are iterated in the end in the order of the &lt;a href=&quot;union#kotlin.collections%24union(kotlin.Array((kotlin.collections.union.T)),%20kotlin.collections.Iterable((kotlin.collections.union.T)))/other&quot;&gt;other&lt;/a&gt; collection.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2b309c05bb0df5183017b60bb11949ef16cec12" translate="yes" xml:space="preserve">
          <source>The returned set preserves the element iteration order of the original char sequence.</source>
          <target state="translated">返回的集合保留了原始char序列的元素迭代顺序。</target>
        </trans-unit>
        <trans-unit id="77b699621c7e191100bcd082c9accf071cd60f08" translate="yes" xml:space="preserve">
          <source>The returned set preserves the element iteration order of the original collection.</source>
          <target state="translated">返回的集合保留了原始集合的元素迭代顺序。</target>
        </trans-unit>
        <trans-unit id="ed96aca660cbd3c3aee98cb1f013ac3448395f47" translate="yes" xml:space="preserve">
          <source>The returned set preserves the element iteration order of the original collection. Those elements of the &lt;a href=&quot;union#kotlin.collections%24union%28kotlin.collections.Iterable%28%28kotlin.collections.union.T%29%29%2C+kotlin.collections.Iterable%28%28kotlin.collections.union.T%29%29%29%2Fother&quot;&gt;other&lt;/a&gt; collection that are unique are iterated in the end in the order of the &lt;a href=&quot;union#kotlin.collections%24union%28kotlin.collections.Iterable%28%28kotlin.collections.union.T%29%29%2C+kotlin.collections.Iterable%28%28kotlin.collections.union.T%29%29%29%2Fother&quot;&gt;other&lt;/a&gt; collection.</source>
          <target state="translated">返回的集合保留原始集合的元素迭代顺序。最后，按照&lt;a href=&quot;union#kotlin.collections%24union%28kotlin.collections.Iterable%28%28kotlin.collections.union.T%29%29%2C+kotlin.collections.Iterable%28%28kotlin.collections.union.T%29%29%29%2Fother&quot;&gt;另一个&lt;/a&gt;集合的顺序迭代&lt;a href=&quot;union#kotlin.collections%24union%28kotlin.collections.Iterable%28%28kotlin.collections.union.T%29%29%2C+kotlin.collections.Iterable%28%28kotlin.collections.union.T%29%29%29%2Fother&quot;&gt;另一个&lt;/a&gt;集合中唯一的那些元素。</target>
        </trans-unit>
        <trans-unit id="c4910c50663c8a64b733d52ca426f65568fa0287" translate="yes" xml:space="preserve">
          <source>The returned set preserves the element iteration order of the original collection. Those elements of the &lt;a href=&quot;union#kotlin.collections%24union(kotlin.collections.Iterable((kotlin.collections.union.T)),%20kotlin.collections.Iterable((kotlin.collections.union.T)))/other&quot;&gt;other&lt;/a&gt; collection that are unique are iterated in the end in the order of the &lt;a href=&quot;union#kotlin.collections%24union(kotlin.collections.Iterable((kotlin.collections.union.T)),%20kotlin.collections.Iterable((kotlin.collections.union.T)))/other&quot;&gt;other&lt;/a&gt; collection.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b556a6977dd4e71f20e303d7d9385040d75f0ac7" translate="yes" xml:space="preserve">
          <source>The returned set preserves the element iteration order of the original sequence.</source>
          <target state="translated">返回的集合保留了原始序列的元素迭代顺序。</target>
        </trans-unit>
        <trans-unit id="eddbfc5096c56b9aafbe04f2e54352a74a62ad62" translate="yes" xml:space="preserve">
          <source>The returned set preserves the element iteration order of the original set.</source>
          <target state="translated">返回的集合保留了原集合的元素迭代顺序。</target>
        </trans-unit>
        <trans-unit id="4e9b4d20ac671bfe117e4f28b0081ad091c327b5" translate="yes" xml:space="preserve">
          <source>The returned set preserves the element iteration order.</source>
          <target state="translated">返回的集合保留了元素迭代顺序。</target>
        </trans-unit>
        <trans-unit id="3396cb9052521da9189bb354afe95f34735769fc" translate="yes" xml:space="preserve">
          <source>The returned time mark is more &lt;em&gt;early&lt;/em&gt; when the &lt;a href=&quot;minus#kotlin.time.TimeMark%24minus(kotlin.time.Duration)/duration&quot;&gt;duration&lt;/a&gt; is positive, and more &lt;em&gt;late&lt;/em&gt; when the &lt;a href=&quot;minus#kotlin.time.TimeMark%24minus(kotlin.time.Duration)/duration&quot;&gt;duration&lt;/a&gt; is negative.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b678653886184f25ddce12e87e8c3d50b1e6262c" translate="yes" xml:space="preserve">
          <source>The returned time mark is more &lt;em&gt;late&lt;/em&gt; when the &lt;a href=&quot;plus#kotlin.time.TimeMark%24plus(kotlin.time.Duration)/duration&quot;&gt;duration&lt;/a&gt; is positive, and more &lt;em&gt;early&lt;/em&gt; when the &lt;a href=&quot;plus#kotlin.time.TimeMark%24plus(kotlin.time.Duration)/duration&quot;&gt;duration&lt;/a&gt; is negative.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c0e13333db8789388b9d52adff49d100d5cf6ca" translate="yes" xml:space="preserve">
          <source>The returned value is &lt;code&gt;y&lt;/code&gt; such that &lt;code&gt;sinh(y) == x&lt;/code&gt;.</source>
          <target state="translated">返回值是 &lt;code&gt;y&lt;/code&gt; ，使得 &lt;code&gt;sinh(y) == x&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f0a819fc71728e449a1fa0a52b2d805fcb67dfe6" translate="yes" xml:space="preserve">
          <source>The returned value is &lt;code&gt;y&lt;/code&gt; such that &lt;code&gt;tanh(y) == x&lt;/code&gt;.</source>
          <target state="translated">返回值是 &lt;code&gt;y&lt;/code&gt; ，使得 &lt;code&gt;tanh(y) == x&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="38db1bb7310932e868d4c70216856f90e11179f2" translate="yes" xml:space="preserve">
          <source>The returned value is positive &lt;code&gt;y&lt;/code&gt; such that &lt;code&gt;cosh(y) == x&lt;/code&gt;.</source>
          <target state="translated">返回值是正 &lt;code&gt;y&lt;/code&gt; ，使得 &lt;code&gt;cosh(y) == x&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="09ad6f6bfed71caa855b5d5a6e4efd57371809c7" translate="yes" xml:space="preserve">
          <source>The returned value is presented in the format &lt;code&gt;PThHmMs.fS&lt;/code&gt;, where &lt;code&gt;h&lt;/code&gt;, &lt;code&gt;m&lt;/code&gt;, &lt;code&gt;s&lt;/code&gt; are the integer components of this duration (see &lt;a href=&quot;to-components&quot;&gt;toComponents&lt;/a&gt;) and &lt;code&gt;f&lt;/code&gt; is a fractional part of second. Depending on the roundness of the value the fractional part can be formatted with either 0, 3, 6, or 9 decimal digits.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92462ffebca930d13f4cb4aaee4b7842f4ea14de" translate="yes" xml:space="preserve">
          <source>The returned value of a &lt;em&gt;try&lt;/em&gt;-expression is either the last expression in the &lt;em&gt;try&lt;/em&gt; block or the last expression in the &lt;em&gt;catch&lt;/em&gt; block (or blocks). Contents of the &lt;em&gt;finally&lt;/em&gt; block do not affect the result of the expression.</source>
          <target state="translated">&lt;em&gt;try&lt;/em&gt; -expression 的返回值是&lt;em&gt;try&lt;/em&gt;块中的最后一个表达式或&lt;em&gt;catch&lt;/em&gt;块（或多个块）中的最后一个表达式。&lt;em&gt;finally&lt;/em&gt;块的内容不影响表达式的结果。</target>
        </trans-unit>
        <trans-unit id="261319d8fec52739ec6c832665ae3f7dbd0e5025" translate="yes" xml:space="preserve">
          <source>The root of the Kotlin class hierarchy. Every Kotlin class has &lt;a href=&quot;-any/index#kotlin.Any&quot;&gt;Any&lt;/a&gt; as a superclass.</source>
          <target state="translated">Kotlin类层次结构的根。每个Kotlin类都有&lt;a href=&quot;-any/index#kotlin.Any&quot;&gt;Any&lt;/a&gt;作为超类。</target>
        </trans-unit>
        <trans-unit id="a55ae833319a2f8e509e5aee918452e19eb747a8" translate="yes" xml:space="preserve">
          <source>The root of the Kotlin class hierarchy. Every Kotlin class has &lt;a href=&quot;index#kotlin.Any&quot;&gt;Any&lt;/a&gt; as a superclass.</source>
          <target state="translated">Kotlin类层次结构的根。每个Kotlin类都有&lt;a href=&quot;index#kotlin.Any&quot;&gt;Any&lt;/a&gt;作为超类。</target>
        </trans-unit>
        <trans-unit id="98512a74a1640b8252b93eb9be999aab21267c59" translate="yes" xml:space="preserve">
          <source>The runner will set the value for the property system.path.macro.KOTLIN.BUNDLED to the correct one based on the path settings from the IntelliJ IDEA project. However this value needs to be defined in TeamCity (and can be set to any value). Therefore we need to define it as a system variable.</source>
          <target state="translated">运行器将根据IntelliJ IDEA项目中的路径设置,将属性system.path.macro.KOTLIN.BUNDLED的值设置为正确的值。然而这个值需要在TeamCity中定义(可以设置为任何值)。因此我们需要将其定义为一个系统变量。</target>
        </trans-unit>
        <trans-unit id="578262526068b614504d1b18d76cf8dea19e1504" translate="yes" xml:space="preserve">
          <source>The same is available for maps with the functions &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/map-of&quot;&gt;&lt;code&gt;mapOf()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/mutable-map-of&quot;&gt;&lt;code&gt;mutableMapOf()&lt;/code&gt;&lt;/a&gt;. The map's keys and values are passed as &lt;code&gt;Pair&lt;/code&gt; objects (usually created with &lt;code&gt;to&lt;/code&gt; infix function).</source>
          <target state="translated">具有&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/mutable-map-of&quot;&gt; &lt;code&gt;mutableMapOf()&lt;/code&gt; &lt;/a&gt;和mutableMapOf（）函数的&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/map-of&quot;&gt; &lt;code&gt;mapOf()&lt;/code&gt; &lt;/a&gt;也可以使用此功能。映射的键和值作为 &lt;code&gt;Pair&lt;/code&gt; 对象（通常使用 &lt;code&gt;to&lt;/code&gt; infix函数创建）传递。</target>
        </trans-unit>
        <trans-unit id="25f5c97c541192ff226fb77118f20b9141f29a81" translate="yes" xml:space="preserve">
          <source>The same rules are used by the Kotlin/Native compiler to generate the &lt;code&gt;.h&lt;/code&gt; file for all platforms.</source>
          <target state="translated">Kotlin / Native编译器使用相同的规则为所有平台生成 &lt;code&gt;.h&lt;/code&gt; 文件。</target>
        </trans-unit>
        <trans-unit id="dac2ac98305c82e23b60095cae0d9b066592bfa3" translate="yes" xml:space="preserve">
          <source>The same set of functions (but without constants) is also available for &lt;code&gt;Float&lt;/code&gt; arguments.</source>
          <target state="translated">相同的函数集（但没有常量）也可用于 &lt;code&gt;Float&lt;/code&gt; 参数。</target>
        </trans-unit>
        <trans-unit id="afd6887219148439be70535c83e0ab200b27625e" translate="yes" xml:space="preserve">
          <source>The same syntax can be used to annotate the entire file. To do this, put an annotation with the target &lt;code&gt;file&lt;/code&gt; at the top level of a file, before the package directive or before all imports if the file is in the default package:</source>
          <target state="translated">可以使用相同的语法来注释整个文件。为此，请将注释与目标 &lt;code&gt;file&lt;/code&gt; 一起放在文件的最高级别，package指令之前或所有导入之前（如果该文件位于默认软件包中）：</target>
        </trans-unit>
        <trans-unit id="2ae227fcecaec9d7de3afec1996267608672f87b" translate="yes" xml:space="preserve">
          <source>The same syntax with omitted type arguments can be used for casts that do not take type arguments into account: &lt;code&gt;list as ArrayList&lt;/code&gt;.</source>
          <target state="translated">省略类型参数的语法可以用于不考虑类型参数的类型转换： &lt;code&gt;list as ArrayList&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="998fefac425fa7727b709de3b80c938ce507ca90" translate="yes" xml:space="preserve">
          <source>The same trick applies when we need to have a property &lt;code&gt;x&lt;/code&gt; alongside with a function &lt;code&gt;getX()&lt;/code&gt;:</source>
          <target state="translated">当我们需要同时具有属性 &lt;code&gt;x&lt;/code&gt; 和函数 &lt;code&gt;getX()&lt;/code&gt; 时，同样的技巧也适用：</target>
        </trans-unit>
        <trans-unit id="7028478d43f0e9046e167eadedccdd38efaac612" translate="yes" xml:space="preserve">
          <source>The same type parameter can be used in both covariant and contravariant projections (because it's the generic classes that are being projected, not the type parameter):</source>
          <target state="translated">相同的类型参数可以在共变和反变投影中使用(因为被投影的是泛类,而不是类型参数)。</target>
        </trans-unit>
        <trans-unit id="e34374077b9198e942d005d02c16935775597fa6" translate="yes" xml:space="preserve">
          <source>The scale of the result is the same as the scale of &lt;code&gt;this&lt;/code&gt; (divident), and for rounding the &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/math/RoundingMode.html#HALF_EVEN&quot;&gt;RoundingMode.HALF_EVEN&lt;/a&gt; rounding mode is used.</source>
          <target state="translated">结果的小数位数与 &lt;code&gt;this&lt;/code&gt; （小数）的小数位数相同，并且用于取&lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/math/RoundingMode.html#HALF_EVEN&quot;&gt;整RoundingMode.HALF_EVEN取&lt;/a&gt;整模式。</target>
        </trans-unit>
        <trans-unit id="862c489ca779c92aa7c1ebb24e7220c5850ae722" translate="yes" xml:space="preserve">
          <source>The scale of the result is the same as the scale of &lt;code&gt;this&lt;/code&gt; (divident), and for rounding the &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/math/RoundingMode.html#HALF_EVEN&quot;&gt;RoundingMode.HALF_EVEN&lt;/a&gt; rounding mode is used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f22bffdb314393bc05bae9820f09e84c2f28f7a7" translate="yes" xml:space="preserve">
          <source>The scope for yielding values of a &lt;a href=&quot;-sequence/index&quot;&gt;Sequence&lt;/a&gt; or an &lt;a href=&quot;../kotlin.collections/-iterator/index#kotlin.collections.Iterator&quot;&gt;Iterator&lt;/a&gt;, provides &lt;a href=&quot;-sequence-scope/yield&quot;&gt;yield&lt;/a&gt; and &lt;a href=&quot;-sequence-scope/yield-all&quot;&gt;yieldAll&lt;/a&gt; suspension functions.</source>
          <target state="translated">产生&lt;a href=&quot;-sequence/index&quot;&gt;Sequence&lt;/a&gt;或&lt;a href=&quot;../kotlin.collections/-iterator/index#kotlin.collections.Iterator&quot;&gt;Iterator的&lt;/a&gt;值的范围提供了&lt;a href=&quot;-sequence-scope/yield&quot;&gt;yield&lt;/a&gt;和&lt;a href=&quot;-sequence-scope/yield-all&quot;&gt;yieldAll&lt;/a&gt;暂停函数。</target>
        </trans-unit>
        <trans-unit id="4a3f3df589995633decc0a7530a1bb032d855ae5" translate="yes" xml:space="preserve">
          <source>The scope for yielding values of a &lt;a href=&quot;../-sequence/index&quot;&gt;Sequence&lt;/a&gt; or an &lt;a href=&quot;../../kotlin.collections/-iterator/index#kotlin.collections.Iterator&quot;&gt;Iterator&lt;/a&gt;, provides &lt;a href=&quot;yield&quot;&gt;yield&lt;/a&gt; and &lt;a href=&quot;yield-all&quot;&gt;yieldAll&lt;/a&gt; suspension functions.</source>
          <target state="translated">产生&lt;a href=&quot;../-sequence/index&quot;&gt;Sequence&lt;/a&gt;或&lt;a href=&quot;../../kotlin.collections/-iterator/index#kotlin.collections.Iterator&quot;&gt;Iterator的&lt;/a&gt;值的范围提供了&lt;a href=&quot;yield&quot;&gt;yield&lt;/a&gt;和&lt;a href=&quot;yield-all&quot;&gt;yieldAll&lt;/a&gt;暂停函数。</target>
        </trans-unit>
        <trans-unit id="a36f2feb54110b2ee9d15c70833427be6cae37ba" translate="yes" xml:space="preserve">
          <source>The scope for yielding values of a &lt;a href=&quot;../../kotlin.sequences/-sequence/index&quot;&gt;Sequence&lt;/a&gt; or an &lt;a href=&quot;../../kotlin.collections/-iterator/index#kotlin.collections.Iterator&quot;&gt;Iterator&lt;/a&gt;, provides &lt;a href=&quot;../../kotlin.sequences/-sequence-scope/yield&quot;&gt;yield&lt;/a&gt; and &lt;a href=&quot;../../kotlin.sequences/-sequence-scope/yield-all&quot;&gt;yieldAll&lt;/a&gt; suspension functions.</source>
          <target state="translated">产生&lt;a href=&quot;../../kotlin.sequences/-sequence/index&quot;&gt;Sequence&lt;/a&gt;或&lt;a href=&quot;../../kotlin.collections/-iterator/index#kotlin.collections.Iterator&quot;&gt;Iterator的&lt;/a&gt;值的范围提供了&lt;a href=&quot;../../kotlin.sequences/-sequence-scope/yield&quot;&gt;yield&lt;/a&gt;和&lt;a href=&quot;../../kotlin.sequences/-sequence-scope/yield-all&quot;&gt;yieldAll&lt;/a&gt;暂停函数。</target>
        </trans-unit>
        <trans-unit id="f47c36946d42e828300cda7cb035fe509918aa59" translate="yes" xml:space="preserve">
          <source>The scope functions differ by the result they return:</source>
          <target state="translated">范围函数因其返回的结果而不同。</target>
        </trans-unit>
        <trans-unit id="8f4977d6e6dad61eba46e51272eff7452a6f78a7" translate="yes" xml:space="preserve">
          <source>The scope functions do not introduce any new technical capabilities, but they can make your code more concise and readable.</source>
          <target state="translated">范围函数并没有引入任何新的技术能力,但它们可以使你的代码更加简洁和可读。</target>
        </trans-unit>
        <trans-unit id="e84a98a8ab59f4886f0e69aee2d9364d4d099205" translate="yes" xml:space="preserve">
          <source>The second coroutine has computed its value and disappeared.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76e57d4d84961d41b1ec0ed92b3d75452ff7d775" translate="yes" xml:space="preserve">
          <source>The second coroutine is calculating the &lt;code&gt;a&lt;/code&gt; value &amp;ndash; it has the &lt;strong&gt;RUNNING&lt;/strong&gt; status.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f41bf24b11179244ce6543e55a837627d8700cb" translate="yes" xml:space="preserve">
          <source>The second line is the &lt;code&gt;headerFilter&lt;/code&gt;. This is used to denote what exactly we want included. In C, when one file references another file with the &lt;code&gt;#include&lt;/code&gt; directive, all the headers are also included. Sometimes this may not be needed, and we can use this parameter, &lt;a href=&quot;https://en.wikipedia.org/wiki/Glob_(programming)&quot;&gt;using glob patterns&lt;/a&gt;, to fine tune things. Note, that &lt;code&gt;headerFilter&lt;/code&gt; is an optional argument and mostly only used when the library we're using is being installed as a system library, and we do not want to fetch external dependencies (such as system &lt;code&gt;stdint.h&lt;/code&gt; header) into our interop library. It may be important for both optimizing the library size and fixing potential conflicts between the system and the Kotlin/Native provided compilation environment.</source>
          <target state="translated">第二行是 &lt;code&gt;headerFilter&lt;/code&gt; 。这用来表示我们想要包含的内容。在C语言中，当一个文件使用 &lt;code&gt;#include&lt;/code&gt; 指令引用另一个文件时，还将包含所有标头。有时可能不需要这样做，我们可以使用&lt;a href=&quot;https://en.wikipedia.org/wiki/Glob_(programming)&quot;&gt;glob模式&lt;/a&gt;使用此参数来微调事物。请注意， &lt;code&gt;headerFilter&lt;/code&gt; 是一个可选参数，并且仅在将要使用的库作为系统库安装时才使用，并且我们不想将外部依赖项（例如系统 &lt;code&gt;stdint.h&lt;/code&gt; 标头）提取到我们的互操作库中。这对于优化库大小以及修复系统与Kotlin / Native提供的编译环境之间的潜在冲突都可能很重要。</target>
        </trans-unit>
        <trans-unit id="840619ade32a5f33b95550212b369e6072d8ca9d" translate="yes" xml:space="preserve">
          <source>The second list contains the second elements.</source>
          <target state="translated">第二个列表包含第二个元素。</target>
        </trans-unit>
        <trans-unit id="61c6cf9e9e7f1d565d89fe5986da63f4fbcd432b" translate="yes" xml:space="preserve">
          <source>The second observation, is that &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/on-receive-or-null.html&quot;&gt;onReceiveOrNull&lt;/a&gt; gets immediately selected when the channel is already closed.</source>
          <target state="translated">第二个观察结果是，当通道已经关闭时，&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/on-receive-or-null.html&quot;&gt;onReceiveOrNull&lt;/a&gt;立即被选择。</target>
        </trans-unit>
        <trans-unit id="90bb330cf5e09011380c337ab5bbdf9ebc55c7f5" translate="yes" xml:space="preserve">
          <source>The second step is to configure the framework search path of the produced binary. It is also known as &lt;code&gt;rpath&lt;/code&gt; or &lt;a href=&quot;https://en.wikipedia.org/wiki/Rpath&quot;&gt;run-time search path&lt;/a&gt;. The binary uses the path to look for the required frameworks. We do not recommend installing additional frameworks to the OS if it is not needed. We should understand the layout of our future application, for example, we may have the &lt;code&gt;Frameworks&lt;/code&gt; folder under the application bundle with all the frameworks we use. The &lt;code&gt;@rpath&lt;/code&gt; parameter can be configured in Xcode. We need to open the &lt;em&gt;project&lt;/em&gt; configuration and find the &lt;code&gt;Runpath Search Paths&lt;/code&gt; section. Here we specify the relative path to the compiled framework.</source>
          <target state="translated">第二步是配置生成的二进制文件的框架搜索路径。也称为 &lt;code&gt;rpath&lt;/code&gt; 或&lt;a href=&quot;https://en.wikipedia.org/wiki/Rpath&quot;&gt;运行时搜索路径&lt;/a&gt;。二进制文件使用该路径查找所需的框架。如果不需要，我们不建议在操作系统上安装其他框架。我们应该了解未来应用程序的布局，例如，在应用程序捆绑包中，我们可能会拥有所有使用的框架的 &lt;code&gt;Frameworks&lt;/code&gt; 文件夹。所述 &lt;code&gt;@rpath&lt;/code&gt; 参数可以在Xcode进行配置。我们需要打开&lt;em&gt;项目&lt;/em&gt;配置并找到&amp;ldquo; &lt;code&gt;Runpath Search Paths&lt;/code&gt; 部分。在这里，我们指定了已编译框架的相对路径。</target>
        </trans-unit>
        <trans-unit id="654406bf07807fb9a1c468fda5253d223f604a77" translate="yes" xml:space="preserve">
          <source>The second step is to then include the framework path into the &lt;code&gt;Framework Search Paths&lt;/code&gt; block of the &lt;code&gt;Build Settings&lt;/code&gt; section of the &lt;em&gt;target&lt;/em&gt; configuration page. It is possible to use &lt;code&gt;$(PROJECT_DIR)&lt;/code&gt; macro to simplify the setup.</source>
          <target state="translated">然后，第二步是将框架路径包括在&lt;em&gt;目标&lt;/em&gt;配置页面的&amp;ldquo; &lt;code&gt;Build Settings&lt;/code&gt; 部分的&amp;ldquo; &lt;code&gt;Framework Search Paths&lt;/code&gt; 块中。可以使用 &lt;code&gt;$(PROJECT_DIR)&lt;/code&gt; 宏来简化设置。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="18e3a3f25c81d64436deec2668dbca688024cd76" translate="yes" xml:space="preserve">
          <source>The second way is using typed getters. These getters allow one to access a binary of a certain type by its name prefix and build type.</source>
          <target state="translated">第二种方式是使用类型化的获取器。这些获取器允许人们通过其名称前缀和构建类型来访问某个类型的二进制。</target>
        </trans-unit>
        <trans-unit id="827737115fbde8c1114cdac2570a8c2c25e8999d" translate="yes" xml:space="preserve">
          <source>The sequence can be iterated multiple times, each time starting with &lt;a href=&quot;generate-sequence#kotlin.sequences%24generateSequence%28kotlin.sequences.generateSequence.T%2C+kotlin.Function1%28%28kotlin.sequences.generateSequence.T%2C+kotlin.sequences.generateSequence.T%29%29%29%2Fseed&quot;&gt;seed&lt;/a&gt;.</source>
          <target state="translated">该序列可以迭代多次，每次都以&lt;a href=&quot;generate-sequence#kotlin.sequences%24generateSequence%28kotlin.sequences.generateSequence.T%2C+kotlin.Function1%28%28kotlin.sequences.generateSequence.T%2C+kotlin.sequences.generateSequence.T%29%29%29%2Fseed&quot;&gt;seed&lt;/a&gt;开头。</target>
        </trans-unit>
        <trans-unit id="fc73d4e6f9fffbb0e65e07b8a9240c6689985bdd" translate="yes" xml:space="preserve">
          <source>The sequence can be iterated multiple times, each time starting with &lt;a href=&quot;generate-sequence#kotlin.sequences%24generateSequence(kotlin.sequences.generateSequence.T?,%20kotlin.Function1((kotlin.sequences.generateSequence.T,%20kotlin.sequences.generateSequence.T?)))/seed&quot;&gt;seed&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0eda5b13d201be08982eef0e6ce47fb43644a540" translate="yes" xml:space="preserve">
          <source>The sequence can be iterated multiple times.</source>
          <target state="translated">该序列可以多次迭代。</target>
        </trans-unit>
        <trans-unit id="0a85208253c6224f238363151292bff48ddafdf4" translate="yes" xml:space="preserve">
          <source>The sequence can be potentially infinite.</source>
          <target state="translated">序列可以是潜在的无限的。</target>
        </trans-unit>
        <trans-unit id="0e5675a51efa9f06e75cacd0d5cc4fa5944cc8f4" translate="yes" xml:space="preserve">
          <source>The sequence of values returned by the given iterator can be potentially infinite.</source>
          <target state="translated">给定迭代器返回的值序列可能是无限的。</target>
        </trans-unit>
        <trans-unit id="7d79c1f34f116fdb6c923fac302558f761c71524" translate="yes" xml:space="preserve">
          <source>The sequence operations can be classified into the following groups regarding their state requirements:</source>
          <target state="translated">序列操作按其状态要求可分为以下几组。</target>
        </trans-unit>
        <trans-unit id="30c4d2821891f6cd1d6f9f4ff92091f8670df4f6" translate="yes" xml:space="preserve">
          <source>The sequence processing goes like this:</source>
          <target state="translated">顺序处理是这样的。</target>
        </trans-unit>
        <trans-unit id="037cfea620d6aaba99a768d063c28b857dfd0b60" translate="yes" xml:space="preserve">
          <source>The sequence produces values until it encounters first &lt;code&gt;null&lt;/code&gt; value. If &lt;a href=&quot;generate-sequence#kotlin.sequences%24generateSequence%28kotlin.Function0%28%28kotlin.sequences.generateSequence.T%29%29%2C+kotlin.Function1%28%28kotlin.sequences.generateSequence.T%2C+kotlin.sequences.generateSequence.T%29%29%29%2FseedFunction&quot;&gt;seedFunction&lt;/a&gt; returns &lt;code&gt;null&lt;/code&gt;, an empty sequence is produced.</source>
          <target state="translated">该序列产生值，直到遇到第一个 &lt;code&gt;null&lt;/code&gt; 值。如果&lt;a href=&quot;generate-sequence#kotlin.sequences%24generateSequence%28kotlin.Function0%28%28kotlin.sequences.generateSequence.T%29%29%2C+kotlin.Function1%28%28kotlin.sequences.generateSequence.T%2C+kotlin.sequences.generateSequence.T%29%29%29%2FseedFunction&quot;&gt;seedFunction&lt;/a&gt;返回 &lt;code&gt;null&lt;/code&gt; ，那么将生成一个空序列。</target>
        </trans-unit>
        <trans-unit id="6f1a48a2bbbc690466820f3b0f0b43bc4de3e6e5" translate="yes" xml:space="preserve">
          <source>The sequence produces values until it encounters first &lt;code&gt;null&lt;/code&gt; value. If &lt;a href=&quot;generate-sequence#kotlin.sequences%24generateSequence%28kotlin.sequences.generateSequence.T%2C+kotlin.Function1%28%28kotlin.sequences.generateSequence.T%2C+kotlin.sequences.generateSequence.T%29%29%29%2Fseed&quot;&gt;seed&lt;/a&gt; is &lt;code&gt;null&lt;/code&gt;, an empty sequence is produced.</source>
          <target state="translated">该序列产生值，直到遇到第一个 &lt;code&gt;null&lt;/code&gt; 值。如果&lt;a href=&quot;generate-sequence#kotlin.sequences%24generateSequence%28kotlin.sequences.generateSequence.T%2C+kotlin.Function1%28%28kotlin.sequences.generateSequence.T%2C+kotlin.sequences.generateSequence.T%29%29%29%2Fseed&quot;&gt;seed&lt;/a&gt;为 &lt;code&gt;null&lt;/code&gt; ，则产生一个空序列。</target>
        </trans-unit>
        <trans-unit id="7f85b3586f825638607e86e68f4e2c3390aaa658" translate="yes" xml:space="preserve">
          <source>The sequence produces values until it encounters first &lt;code&gt;null&lt;/code&gt; value. If &lt;a href=&quot;generate-sequence#kotlin.sequences%24generateSequence(kotlin.Function0((kotlin.sequences.generateSequence.T?)),%20kotlin.Function1((kotlin.sequences.generateSequence.T,%20kotlin.sequences.generateSequence.T?)))/seedFunction&quot;&gt;seedFunction&lt;/a&gt; returns &lt;code&gt;null&lt;/code&gt;, an empty sequence is produced.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2bd1e283bb0d03da60d7adf31bcae11b19146a2e" translate="yes" xml:space="preserve">
          <source>The sequence produces values until it encounters first &lt;code&gt;null&lt;/code&gt; value. If &lt;a href=&quot;generate-sequence#kotlin.sequences%24generateSequence(kotlin.sequences.generateSequence.T?,%20kotlin.Function1((kotlin.sequences.generateSequence.T,%20kotlin.sequences.generateSequence.T?)))/seed&quot;&gt;seed&lt;/a&gt; is &lt;code&gt;null&lt;/code&gt;, an empty sequence is produced.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f129e3ce5b36d66a5d5fd7f643fe14c7cd5cdbca" translate="yes" xml:space="preserve">
          <source>The sequential nature of &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/flat-map-concat.html&quot;&gt;flatMapConcat&lt;/a&gt; is clearly seen in the output:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a3082b192dc0701c42da2f86e13f788df24a0f1" translate="yes" xml:space="preserve">
          <source>The set of all possible types that can be substituted for a given type parameter may be restricted by &lt;strong&gt;generic constraints&lt;/strong&gt;.</source>
          <target state="translated">可以用给定类型参数替代的所有可能类型的集合可能受到&lt;strong&gt;通用约束的限制&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="bf0dd762f332fcd86a0727fbb8e23b4a1bb32f29" translate="yes" xml:space="preserve">
          <source>The set of options that were used to create this regular expression.</source>
          <target state="translated">用于创建该正则表达式的一组选项。</target>
        </trans-unit>
        <trans-unit id="459759855b3639a06e88e0e2596d7493a847d411" translate="yes" xml:space="preserve">
          <source>The set of target platforms is defined by a multiplatform library author, and they should provide all of the platform-specific implementations for the library. Adding new targets for a multiplatform library at the consumer's side is not supported.</source>
          <target state="translated">目标平台的集合是由多平台库作者定义的,他们应该为库提供所有特定平台的实现。不支持在消费者端为多平台库添加新目标。</target>
        </trans-unit>
        <trans-unit id="c6c20544cd51f23d74f3a9b338c20b248ca719a1" translate="yes" xml:space="preserve">
          <source>The set passed as a receiver to the &lt;a href=&quot;build-set#kotlin.collections%24buildSet(kotlin.Function1((kotlin.collections.MutableSet((kotlin.collections.buildSet.E)),%20kotlin.Unit)))/builderAction&quot;&gt;builderAction&lt;/a&gt; is valid only inside that function. Using it outside of the function produces an unspecified behavior.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cfae932c206b2b202a3e4b7250821be416b0151c" translate="yes" xml:space="preserve">
          <source>The set passed as a receiver to the &lt;a href=&quot;build-set#kotlin.collections%24buildSet(kotlin.Int,%20kotlin.Function1((kotlin.collections.MutableSet((kotlin.collections.buildSet.E)),%20kotlin.Unit)))/builderAction&quot;&gt;builderAction&lt;/a&gt; is valid only inside that function. Using it outside of the function produces an unspecified behavior.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="488655893b603c994560325ea4e7b1458229763b" translate="yes" xml:space="preserve">
          <source>The setter of this mutable property, used to change the value of the property.</source>
          <target state="translated">这个可变属性的设置者,用来改变属性的值。</target>
        </trans-unit>
        <trans-unit id="67fe2f456972c4ac12399f4f27262af0c978820f" translate="yes" xml:space="preserve">
          <source>The signature of &lt;code&gt;greet()&lt;/code&gt; is &lt;code&gt;KFunction2&amp;lt;Person, String, String&amp;gt;&lt;/code&gt; because it's a function on &lt;code&gt;Person&lt;/code&gt; that takes a &lt;code&gt;String&lt;/code&gt; and returns a &lt;code&gt;String&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;greet()&lt;/code&gt; 的签名为 &lt;code&gt;KFunction2&amp;lt;Person, String, String&amp;gt;&lt;/code&gt; 因为它是 &lt;code&gt;Person&lt;/code&gt; 上的一个函数，它接受 &lt;code&gt;String&lt;/code&gt; 并返回 &lt;code&gt;String&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3e351be319f91b0a3ca4911e8fb9da8a9528097a" translate="yes" xml:space="preserve">
          <source>The signature of a member function or an &lt;a href=&quot;extension-functionsproperties&quot;&gt;extension function&lt;/a&gt; begins with a &lt;em&gt;receiver&lt;/em&gt;: the type upon which the function can be invoked. For example, the signature of &lt;code&gt;toString()&lt;/code&gt; is &lt;code&gt;Any.() -&amp;gt; String&lt;/code&gt; - it can be called on any non-null object (the receiver), it takes no parameters, and it returns a &lt;code&gt;String&lt;/code&gt;. It is possible to write a lambda function with such a signature - this is called a &lt;em&gt;function literal with receiver&lt;/em&gt;, and is extremely useful for building DSLs.</source>
          <target state="translated">成员函数或&lt;a href=&quot;extension-functionsproperties&quot;&gt;扩展函数&lt;/a&gt;的签名从&lt;em&gt;接收方&lt;/em&gt;开始：可以在其上调用函数的类型。例如， &lt;code&gt;toString()&lt;/code&gt; 的签名为 &lt;code&gt;Any.() -&amp;gt; String&lt;/code&gt; 可以在任何非null对象（接收方）上调用它，不使用任何参数，并且返回 &lt;code&gt;String&lt;/code&gt; 。可以使用这样的签名编写一个lambda函数-这被称为&lt;em&gt;带有Receiver&lt;/em&gt;的&lt;em&gt;函数文字，&lt;/em&gt;对于构建DSL非常有用。</target>
        </trans-unit>
        <trans-unit id="aadf52185468aa82855f792813cb9471782e9fa0" translate="yes" xml:space="preserve">
          <source>The signature of the overriding function must exactly match the overridden one, except that the return type in the overriding function may be a subtype of the return type of the overridden function.</source>
          <target state="translated">覆盖函数的签名必须与被覆盖函数完全一致,但覆盖函数中的返回类型可以是被覆盖函数返回类型的子类型。</target>
        </trans-unit>
        <trans-unit id="cb5cfcfa1d9e07364a5b05687e8945f6f792b6b5" translate="yes" xml:space="preserve">
          <source>The simple name of the class as it was declared in the source code, or &lt;code&gt;null&lt;/code&gt; if the class has no name (if, for example, it is a class of an anonymous object).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0290c571ea3c6c1d4ef5f1279658ebad7901a082" translate="yes" xml:space="preserve">
          <source>The simple name of the class as it was declared in the source code, or &lt;code&gt;null&lt;/code&gt; if the class has no name (if, for example, it is an anonymous object literal).</source>
          <target state="translated">在源代码中声明的类的简单名称；如果该类没有名称（例如，如果它是一个匿名对象文字），则为 &lt;code&gt;null&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4a78d65e883965ba15ad1eec8e7ccc645ad6c9f8" translate="yes" xml:space="preserve">
          <source>The simplest version doesn't require any additional parameters and creates one binary for each build type. Currently there a two build types available: &lt;code&gt;DEBUG&lt;/code&gt; (produces a not optimized binary with a debug information) and &lt;code&gt;RELEASE&lt;/code&gt; (produces an optimized binary without debug information). Consequently the following snippet creates two executable binaries: debug and release.</source>
          <target state="translated">最简单的版本不需要任何其他参数，并为每种构建类型创建一个二进制文件。当前有两种构建类型可用： &lt;code&gt;DEBUG&lt;/code&gt; （产生带有调试信息的未优化的二进制文件）和 &lt;code&gt;RELEASE&lt;/code&gt; （产生没有调试信息的已优化的二进制文件）。因此，以下代码段创建了两个可执行二进制文件：debug和release。</target>
        </trans-unit>
        <trans-unit id="4d355ad220db74fe2658767f0c23a71e3df3dd7a" translate="yes" xml:space="preserve">
          <source>The simplest version doesn't require any additional parameters and creates one binary for each build type. Currently there two build types available:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e7b9b0dd8fa90a8e9f2b4ea99f92d60e815b8b9" translate="yes" xml:space="preserve">
          <source>The single immutable C value. It is self-contained and doesn't depend on native memory.</source>
          <target state="translated">单一不可改变的C值。它是自成一体的,不依赖于本机内存。</target>
        </trans-unit>
        <trans-unit id="d8e685c40e1d41520bbfb52a9a2cf6ce5cf4d2b1" translate="yes" xml:space="preserve">
          <source>The single-parent rule often becomes too limiting, as you'll often find commonalities between classes in different branches of a class hierarchy. These commonalities can be expressed in &lt;em&gt;interfaces&lt;/em&gt;.</source>
          <target state="translated">单亲规则通常变得过于局限，因为您经常会发现类层次结构不同分支中的类之间存在共性。这些共同点可以在&lt;em&gt;接口中&lt;/em&gt;表达。</target>
        </trans-unit>
        <trans-unit id="27135a00f55fa78c13aaad4e34fb656e821fa145" translate="yes" xml:space="preserve">
          <source>The smallest time unit is &lt;a href=&quot;-n-a-n-o-s-e-c-o-n-d-s#kotlin.time.DurationUnit.NANOSECONDS&quot;&gt;NANOSECONDS&lt;/a&gt; and the largest is &lt;a href=&quot;-d-a-y-s#kotlin.time.DurationUnit.DAYS&quot;&gt;DAYS&lt;/a&gt;, which corresponds to exactly 24 &lt;a href=&quot;-h-o-u-r-s#kotlin.time.DurationUnit.HOURS&quot;&gt;HOURS&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad2d029e0bf9000bbb670b32b9cfbfdfb5c64ee2" translate="yes" xml:space="preserve">
          <source>The solution is a &lt;em&gt;delegated property&lt;/em&gt;, which allows you to specify the behavior of getting and setting a property (somewhat similar to implementing &lt;code&gt;__getattribute__()&lt;/code&gt; and &lt;code&gt;__setattribute__()&lt;/code&gt; in Python, but for one property at a time).</source>
          <target state="translated">该解决方案是一个&lt;em&gt;委托属性&lt;/em&gt;，它允许您指定获取和设置属性的行为（有点类似于在Python中实现 &lt;code&gt;__getattribute__()&lt;/code&gt; 和 &lt;code&gt;__setattribute__()&lt;/code&gt; ，但一次只设置一个属性）。</target>
        </trans-unit>
        <trans-unit id="02ba30e8a0350e3498389f6bdcc51b4d923322f5" translate="yes" xml:space="preserve">
          <source>The solution is to mark the targets with a custom attribute, which is taken into account by Gradle during dependency resolution. This, however, must be done on both the library author and the consumer sides, and it's the library author's responsibility to communicate the attribute and its possible values to the consumers.</source>
          <target state="translated">解决办法是用一个自定义属性来标记目标,Gradle在解决依赖关系的过程中会考虑到这个属性。然而,这必须在库作者和消费者两方面进行,库作者有责任将属性及其可能的值传达给消费者。</target>
        </trans-unit>
        <trans-unit id="4ce364ecc8aca93a0b9f937690067d3d1f6fcb4e" translate="yes" xml:space="preserve">
          <source>The sort is &lt;em&gt;stable&lt;/em&gt;. It means that equal elements preserve their order relative to each other after sorting.</source>
          <target state="translated">排序是&lt;em&gt;稳定的&lt;/em&gt;。这意味着相等的元素在排序后保留相对于彼此的顺序。</target>
        </trans-unit>
        <trans-unit id="563e0866ee26fde4dae779a523cc71b4cbb6977d" translate="yes" xml:space="preserve">
          <source>The source set names are case-sensitive. When referring to a default source set by its name, make sure the name prefix matches a target's name, for example, a source set &lt;code&gt;iosX64Main&lt;/code&gt; for a target &lt;code&gt;iosX64&lt;/code&gt;.</source>
          <target state="translated">源集名称区分大小写。当提到它的名字默认源设置，确保名称前缀与对象的名称，例如，源设置 &lt;code&gt;iosX64Main&lt;/code&gt; 为目标 &lt;code&gt;iosX64&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="11b3468dd6e9b05386099434c4ca46b0c2547522" translate="yes" xml:space="preserve">
          <source>The source sets DSL can be used to define these connections between the source sets:</source>
          <target state="translated">源集DSL可以用来定义这些源集之间的连接。</target>
        </trans-unit>
        <trans-unit id="5ee1552c884a6b1c888ad99542230488f493bca7" translate="yes" xml:space="preserve">
          <source>The source sets are configured within a &lt;code&gt;sourceSets { ... }&lt;/code&gt; block of the &lt;code&gt;kotlin { ... }&lt;/code&gt; extension:</source>
          <target state="translated">源集在 &lt;code&gt;kotlin { ... }&lt;/code&gt; 扩展的 &lt;code&gt;sourceSets { ... }&lt;/code&gt; 块内配置：</target>
        </trans-unit>
        <trans-unit id="d4cf592997fcfc68c560b9248ead3349afe2d7c1" translate="yes" xml:space="preserve">
          <source>The specification of the requirements to the delegated object can be found &lt;a href=&quot;delegated-properties#property-delegate-requirements&quot;&gt;below&lt;/a&gt;.</source>
          <target state="translated">可以在&lt;a href=&quot;delegated-properties#property-delegate-requirements&quot;&gt;下面&lt;/a&gt;找到对委托对象的要求的规范。</target>
        </trans-unit>
        <trans-unit id="d73e9a80f0bf586c373c77dd33cae5cc1f592da3" translate="yes" xml:space="preserve">
          <source>The specified arrays are also considered deeply equal if both are &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63949c8dfec16ede4c20d9d3cd58cdaf9f88fafe" translate="yes" xml:space="preserve">
          <source>The standard JavaDoc generation plugin (&lt;code&gt;maven-javadoc-plugin&lt;/code&gt;) does not support Kotlin code. To generate documentation for Kotlin projects, use &lt;a href=&quot;https://github.com/Kotlin/dokka&quot;&gt;Dokka&lt;/a&gt;; please refer to the &lt;a href=&quot;https://github.com/Kotlin/dokka/blob/master/README.md#using-the-maven-plugin&quot;&gt;Dokka README&lt;/a&gt; for configuration instructions. Dokka supports mixed-language projects and can generate output in multiple formats, including standard JavaDoc.</source>
          <target state="translated">标准的JavaDoc生成插件（ &lt;code&gt;maven-javadoc-plugin&lt;/code&gt; ）不支持Kotlin代码。要生成Kotlin项目的文档，请使用&lt;a href=&quot;https://github.com/Kotlin/dokka&quot;&gt;Dokka&lt;/a&gt;；请参阅&lt;a href=&quot;https://github.com/Kotlin/dokka/blob/master/README.md#using-the-maven-plugin&quot;&gt;Dokka自述文件&lt;/a&gt;以获取配置说明。Dokka支持混合语言项目，并且可以生成多种格式的输出，包括标准JavaDoc。</target>
        </trans-unit>
        <trans-unit id="bb8d32cf58d6a52257e9ed55a0d5c90647cf240f" translate="yes" xml:space="preserve">
          <source>The standard library contains a group of extension functions that let you filter collections in a single call. These functions leave the original collection unchanged, so they are available for both &lt;a href=&quot;collections-overview#collection-types&quot;&gt;mutable and read-only&lt;/a&gt; collections. To operate the filtering result, you should assign it to a variable or chain the functions after filtering.</source>
          <target state="translated">标准库包含一组扩展功能，使您可以在单个调用中过滤集合。这些函数使原始集合保持不变，因此它们可用于&lt;a href=&quot;collections-overview#collection-types&quot;&gt;可变&lt;/a&gt;集合和只读集合。要操作过滤结果，应将其分配给变量或在过滤后链接函数。</target>
        </trans-unit>
        <trans-unit id="64cd7cca211b28854215461360962734eb107f4c" translate="yes" xml:space="preserve">
          <source>The standard library defines a function named &lt;a href=&quot;../../../api/latest/jvm/stdlib/kotlin.js/as-dynamic&quot;&gt;&lt;code&gt;asDynamic()&lt;/code&gt;&lt;/a&gt; which casts a value to the dynamic type. Given our previous example where we used jQuery to work with DOM elements, we can now combine this with &lt;code&gt;asDynamic()&lt;/code&gt; to then invoke &lt;code&gt;dataTable()&lt;/code&gt; on the result:</source>
          <target state="translated">标准库定义了一个名为&lt;a href=&quot;../../../api/latest/jvm/stdlib/kotlin.js/as-dynamic&quot;&gt; &lt;code&gt;asDynamic()&lt;/code&gt; &lt;/a&gt;的函数，该函数将值转换为动态类型。在前面的示例中，我们使用jQuery处理DOM元素，现在我们可以将其与 &lt;code&gt;asDynamic()&lt;/code&gt; 结合起来，然后在结果上调用 &lt;code&gt;dataTable()&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="0f57c9d3cc14b958c346235550397a3ba0b18486" translate="yes" xml:space="preserve">
          <source>The standard library in 1.4.0 includes a number of improvements in the API for string manipulation:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f92a5708c1e21664731222bd701621446c56d87" translate="yes" xml:space="preserve">
          <source>The standard library now provides a set of functions for element-by-element operations on arrays: comparison (&lt;code&gt;contentEquals&lt;/code&gt; and &lt;code&gt;contentDeepEquals&lt;/code&gt;), hash code calculation (&lt;code&gt;contentHashCode&lt;/code&gt; and &lt;code&gt;contentDeepHashCode&lt;/code&gt;), and conversion to a string (&lt;code&gt;contentToString&lt;/code&gt; and &lt;code&gt;contentDeepToString&lt;/code&gt;). They're supported both for the JVM (where they act as aliases for the corresponding functions in &lt;code&gt;java.util.Arrays&lt;/code&gt;) and for JS (where the implementation is provided in the Kotlin standard library).</source>
          <target state="translated">现在，标准库为数组的逐个元素操作提供了一组函数：比较（ &lt;code&gt;contentEquals&lt;/code&gt; 和 &lt;code&gt;contentDeepEquals&lt;/code&gt; ），哈希码计算（ &lt;code&gt;contentHashCode&lt;/code&gt; 和 &lt;code&gt;contentDeepHashCode&lt;/code&gt; ）以及转换为字符串（ &lt;code&gt;contentToString&lt;/code&gt; 和 &lt;code&gt;contentDeepToString&lt;/code&gt; ）。他们的JVM（他们作为别名在相应的功能均支持 &lt;code&gt;java.util.Arrays&lt;/code&gt; 中）和JS（其中在科特林标准库提供的实现）。</target>
        </trans-unit>
        <trans-unit id="4cd1337efd07a01ae50fb56677c92729c05a2ca9" translate="yes" xml:space="preserve">
          <source>The standard library provides &lt;code&gt;Pair&lt;/code&gt; and &lt;code&gt;Triple&lt;/code&gt;. In most cases, though, named data classes are a better design choice, because they make the code more readable by providing meaningful names for properties.</source>
          <target state="translated">标准库提供 &lt;code&gt;Pair&lt;/code&gt; 和 &lt;code&gt;Triple&lt;/code&gt; 。但是，在大多数情况下，命名数据类是更好的设计选择，因为命名属性为属性提供有意义的名称，使代码更易读。</target>
        </trans-unit>
        <trans-unit id="0fa7bf33e28a4e2133f3eb85b822f13a5861e747" translate="yes" xml:space="preserve">
          <source>The standard library provides us with a series of wrappers around DOM as well as functions to work with JavaScript, using static typing. What happens however when we want to use a library such as jQuery? Kotlin does not have its own &quot;header&quot; files for all the different libraries available on the JavaScript ecosystem however, TypeScript does. The &lt;a href=&quot;https://github.com/DefinitelyTyped/DefinitelyTyped/&quot;&gt;Definitely Typed repository&lt;/a&gt; provides us with a very large selection of header files.</source>
          <target state="translated">标准库为我们提供了一系列有关DOM的包装器以及使用静态类型与JavaScript配合使用的函数。但是，当我们想使用jQuery之类的库时会发生什么？对于JavaScript生态系统上可用的所有不同库，Kotlin没有自己的&amp;ldquo;标头&amp;rdquo;文件，但是TypeScript有。在&lt;a href=&quot;https://github.com/DefinitelyTyped/DefinitelyTyped/&quot;&gt;肯定类型化资料库&lt;/a&gt;为我们提供了一个非常大的选择的头文件。</target>
        </trans-unit>
        <trans-unit id="5b02aa301d08018505c67b11eafce33e20430963" translate="yes" xml:space="preserve">
          <source>The standard library uses coroutines to support &lt;em&gt;lazily generated sequences&lt;/em&gt; with &lt;code&gt;yield&lt;/code&gt; and &lt;code&gt;yieldAll&lt;/code&gt; functions. In such a sequence, the block of code that returns sequence elements is suspended after each element has been retrieved, and resumed when the next element is requested. Here's an example:</source>
          <target state="translated">标准库使用协程支持具有 &lt;code&gt;yield&lt;/code&gt; 和 &lt;code&gt;yieldAll&lt;/code&gt; 函数的&lt;em&gt;延迟生成的序列&lt;/em&gt;。在这样的序列中，返回序列元素的代码块在检索到每个元素之后将被挂起，并在请求下一个元素时恢复。这是一个例子：</target>
        </trans-unit>
        <trans-unit id="bd81d65292e2ed27e6a7bd7b3f70e04e3c6f5969" translate="yes" xml:space="preserve">
          <source>The status value in &lt;code&gt;@UnderMigration(status = ...)&lt;/code&gt; specifies how the compiler treats inappropriate usages of the annotated types in Kotlin (e.g. using a &lt;code&gt;@MyNullable&lt;/code&gt;-annotated type value as non-null):</source>
          <target state="translated">&lt;code&gt;@UnderMigration(status = ...)&lt;/code&gt; 的状态值指定编译器如何对待Kotlin中带注释类型的不当用法（例如，使用 &lt;code&gt;@MyNullable&lt;/code&gt; -带注释类型的值作为非null）：</target>
        </trans-unit>
        <trans-unit id="4dfa4a2af58e962d2e78195bb041069a8bfddba3" translate="yes" xml:space="preserve">
          <source>The step of the progression.</source>
          <target state="translated">进阶的步骤。</target>
        </trans-unit>
        <trans-unit id="e2561323722fd466eed7e84734bba0e2d9a0a20e" translate="yes" xml:space="preserve">
          <source>The step value must be positive. If you need to count downwards, use the inclusive &lt;code&gt;downTo&lt;/code&gt;:</source>
          <target state="translated">步长值必须为正。如果需要向下计数，请使用包含在内的 &lt;code&gt;downTo&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="ba5dcc36cf4e926283f2cf38c8b5b4a8a22b74ac" translate="yes" xml:space="preserve">
          <source>The subclass &lt;em&gt;inherits&lt;/em&gt; all members that exist in its superclass - both those that are directly defined in the superclass and the ones that the superclass itself has inherited. In this example, &lt;code&gt;Car&lt;/code&gt; contains the following members:</source>
          <target state="translated">子类&lt;em&gt;继承&lt;/em&gt;其超类中存在的所有成员-既直接在超类中定义的成员，也包括超类本身已继承的成员。在此示例中， &lt;code&gt;Car&lt;/code&gt; 包含以下成员：</target>
        </trans-unit>
        <trans-unit id="9587208b56b71c873bb976ba7dd19e63565c1783" translate="yes" xml:space="preserve">
          <source>The substring from the input string captured by this match.</source>
          <target state="translated">本次匹配所捕获的输入字符串的子串。</target>
        </trans-unit>
        <trans-unit id="ef9d4de4ce3f425feef1d92bfbe702742ff76fe2" translate="yes" xml:space="preserve">
          <source>The syntax is: &lt;code&gt;val/var &amp;lt;property name&amp;gt;: &amp;lt;Type&amp;gt; by &amp;lt;expression&amp;gt;&lt;/code&gt;. The expression after &lt;em&gt;by&lt;/em&gt; is the &lt;em&gt;delegate&lt;/em&gt;, because &lt;code&gt;get()&lt;/code&gt; (and &lt;code&gt;set()&lt;/code&gt;) corresponding to the property will be delegated to its &lt;code&gt;getValue()&lt;/code&gt; and &lt;code&gt;setValue()&lt;/code&gt; methods. Property delegates don&amp;rsquo;t have to implement any interface, but they have to provide a &lt;code&gt;getValue()&lt;/code&gt; function (and &lt;code&gt;setValue()&lt;/code&gt; &amp;mdash; for &lt;em&gt;var&lt;/em&gt;s). For example:</source>
          <target state="translated">语法为： &lt;code&gt;val/var &amp;lt;property name&amp;gt;: &amp;lt;Type&amp;gt; by &amp;lt;expression&amp;gt;&lt;/code&gt; 。&lt;em&gt;by&lt;/em&gt;之后的表达式是&lt;em&gt;委托&lt;/em&gt;，因为与该属性对应的 &lt;code&gt;get()&lt;/code&gt; （和 &lt;code&gt;set()&lt;/code&gt; ）将委托给其 &lt;code&gt;getValue()&lt;/code&gt; 和 &lt;code&gt;setValue()&lt;/code&gt; 方法。属性委托不必实现任何接口，但是必须提供 &lt;code&gt;getValue()&lt;/code&gt; 函数（和 &lt;code&gt;setValue()&lt;/code&gt; －用于&lt;em&gt;var&lt;/em&gt;）。例如：</target>
        </trans-unit>
        <trans-unit id="7f8b0e5f27ed7447035e9e8912fa4868135e5b36" translate="yes" xml:space="preserve">
          <source>The table below shows how Kotlin concepts are mapped to Swift/Objective-C and vice versa.</source>
          <target state="translated">下表显示了Kotlin概念如何映射到Swift/Objective-C,反之亦然。</target>
        </trans-unit>
        <trans-unit id="3a0f8ac6bab0154ecc68aecfaae3d29f58f2856b" translate="yes" xml:space="preserve">
          <source>The target's JAR task instead of &lt;code&gt;jar&lt;/code&gt; (for example, &lt;code&gt;jvmJar&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="124f0b13dfdd24294f1739df4ba61c7845dc9b4c" translate="yes" xml:space="preserve">
          <source>The target's test task instead of &lt;code&gt;test&lt;/code&gt; (for example, &lt;code&gt;jvmTest&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27aee67b81ecee081c926fb6403fc250a2669b58" translate="yes" xml:space="preserve">
          <source>The targets created from presets are added to the &lt;code&gt;kotlin.targets&lt;/code&gt; domain object collection, which can be used to access them by their names or configure all targets:</source>
          <target state="translated">从预设创建的目标将添加到 &lt;code&gt;kotlin.targets&lt;/code&gt; 域对象集合中，可用于按其名称访问它们或配置所有目标：</target>
        </trans-unit>
        <trans-unit id="fee7dff3e4d6eadb637b39f376e9227a5981c25c" translate="yes" xml:space="preserve">
          <source>The targets of a multiplatform project are described in the corresponding blocks inside &lt;code&gt;kotlin&lt;/code&gt;, for example, &lt;code&gt;jvm&lt;/code&gt;, &lt;code&gt;android&lt;/code&gt;, &lt;code&gt;iosArm64&lt;/code&gt;. The complete list of available targets is the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea834ff7223c20a4c037e26a9eaa3ee2e490ee75" translate="yes" xml:space="preserve">
          <source>The terminology is that &lt;code&gt;var&lt;/code&gt; declares a &lt;em&gt;mutable&lt;/em&gt; variable, and that &lt;code&gt;val&lt;/code&gt; declares a &lt;em&gt;read-only&lt;/em&gt; or &lt;em&gt;assign-once&lt;/em&gt; variable - so both kinds are called &lt;em&gt;variables&lt;/em&gt;.</source>
          <target state="translated">术语是 &lt;code&gt;var&lt;/code&gt; 声明了一个&lt;em&gt;可变&lt;/em&gt;变量，而 &lt;code&gt;val&lt;/code&gt; 声明了一个&lt;em&gt;只读&lt;/em&gt;或&lt;em&gt;一次分配&lt;/em&gt;变量-因此这两种都称为&lt;em&gt;变量&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="d2c1a93ffe9401881d7e0f5a7066475d9434f33d" translate="yes" xml:space="preserve">
          <source>The the &lt;a href=&quot;https://github.com/ilmat192/kotlin-native-serialization-sample&quot;&gt;example project&lt;/a&gt; for details.</source>
          <target state="translated">该&lt;a href=&quot;https://github.com/ilmat192/kotlin-native-serialization-sample&quot;&gt;示例项目&lt;/a&gt;中有详细信息。</target>
        </trans-unit>
        <trans-unit id="b8693d679cd999a259c3aef897e70bd0e78837fd" translate="yes" xml:space="preserve">
          <source>The third coroutine has the &lt;strong&gt;CREATED&lt;/strong&gt; status and isn&amp;rsquo;t calculating the value of &lt;code&gt;b&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3144e358140798c41ce3b59dc5b4d63d3fba3f7" translate="yes" xml:space="preserve">
          <source>The third coroutine is calculating the value of &lt;code&gt;b&lt;/code&gt; &amp;ndash; it has the &lt;strong&gt;RUNNING&lt;/strong&gt; status.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db0d4a97f9fddd6cc7f4a4e559ab92c9b243b3dc" translate="yes" xml:space="preserve">
          <source>The third option is for NPE-lovers: the not-null assertion operator (&lt;code&gt;!!&lt;/code&gt;) converts any value to a non-null type and throws an exception if the value is null. We can write &lt;code&gt;b!!&lt;/code&gt;, and this will return a non-null value of &lt;code&gt;b&lt;/code&gt; (e.g., a &lt;code&gt;String&lt;/code&gt; in our example) or throw an NPE if &lt;code&gt;b&lt;/code&gt; is null:</source>
          <target state="translated">第三个选项适用于NPE爱好者：非空断言运算符（ &lt;code&gt;!!&lt;/code&gt; ）将任何值转换为非空类型，如果该值为空，则引发异常。我们可以写 &lt;code&gt;b!!&lt;/code&gt; ，这将返回 &lt;code&gt;b&lt;/code&gt; 的非空值（例如，在我们的示例中为 &lt;code&gt;String&lt;/code&gt; ），或者如果 &lt;code&gt;b&lt;/code&gt; 为null 则抛出NPE ：</target>
        </trans-unit>
        <trans-unit id="328eee564065ef14869693e4097fdfb0bb1e1ca4" translate="yes" xml:space="preserve">
          <source>The three targets are created with the preset functions &lt;code&gt;jvm()&lt;/code&gt;, &lt;code&gt;js()&lt;/code&gt;, and &lt;code&gt;mingwX64()&lt;/code&gt; that provide some &lt;a href=&quot;#default-project-layout&quot;&gt;default configuration&lt;/a&gt;. There are presets for each of the &lt;a href=&quot;#supported-platforms&quot;&gt;supported platforms&lt;/a&gt;.</source>
          <target state="translated">这三个目标是使用提供一些&lt;a href=&quot;#default-project-layout&quot;&gt;默认配置&lt;/a&gt;的预设函数 &lt;code&gt;jvm()&lt;/code&gt; ， &lt;code&gt;js()&lt;/code&gt; 和 &lt;code&gt;mingwX64()&lt;/code&gt; 创建的。每个&lt;a href=&quot;#supported-platforms&quot;&gt;受支持的平台&lt;/a&gt;都有预设。</target>
        </trans-unit>
        <trans-unit id="865a447cbe3c80dc40999ce2ca6d480bd87143d3" translate="yes" xml:space="preserve">
          <source>The timeout event in &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/with-timeout.html&quot;&gt;withTimeout&lt;/a&gt; is asynchronous with respect to the code running in its block and may happen at any time, even right before the return from inside of the timeout block. Keep this in mind if you open or acquire some resource inside the block that needs closing or release outside of the block.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04def297d18523cf309971345c57324bf9993c18" translate="yes" xml:space="preserve">
          <source>The title case of a character is usually the same as its upper case with several exceptions. The particular list of characters with the special title case form depends on the underlying platform.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95397456cc9c821cee4e5e9e86873ae3bfa64d7a" translate="yes" xml:space="preserve">
          <source>The tutorial assumes you have prior knowledge of the &lt;a href=&quot;../../reference/coroutines/coroutines-guide&quot;&gt;coroutines&lt;/a&gt; and &lt;a href=&quot;../../reference/coroutines/flow#flows&quot;&gt;Kotlin Flow&lt;/a&gt; concepts.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb864cb1ef23ff32107953e1fa4c437c5106429f" translate="yes" xml:space="preserve">
          <source>The tutorial assumes you have prior knowledge of the &lt;a href=&quot;../../reference/coroutines/coroutines-guide&quot;&gt;coroutines&lt;/a&gt; concept.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3871e9aa2f804023caa55782736ddd2a4dee3be1" translate="yes" xml:space="preserve">
          <source>The two characters are the same (as compared by the == operator)</source>
          <target state="translated">这两个字符是一样的(通过==操作符进行比较)</target>
        </trans-unit>
        <trans-unit id="43727256131e4c09e21487921129d951e5403bce" translate="yes" xml:space="preserve">
          <source>The type &lt;a href=&quot;exceptions#the-nothing-type&quot;&gt;&lt;code&gt;Nothing&lt;/code&gt;&lt;/a&gt; is special, because it has no natural counterpart in Java. Indeed, every Java reference type, including &lt;code&gt;java.lang.Void&lt;/code&gt;, accepts &lt;code&gt;null&lt;/code&gt; as a value, and &lt;code&gt;Nothing&lt;/code&gt; doesn't accept even that. So, this type cannot be accurately represented in the Java world. This is why Kotlin generates a raw type where an argument of type &lt;code&gt;Nothing&lt;/code&gt; is used:</source>
          <target state="translated">&lt;a href=&quot;exceptions#the-nothing-type&quot;&gt; &lt;code&gt;Nothing&lt;/code&gt; &lt;/a&gt;类型是特殊的，因为它在Java中没有自然的对应物。实际上，每个Java引用类型（包括 &lt;code&gt;java.lang.Void&lt;/code&gt; ）都接受 &lt;code&gt;null&lt;/code&gt; 作为值，而 &lt;code&gt;Nothing&lt;/code&gt; 甚至不接受。因此，无法在Java世界中准确地表示这种类型。这就是为什么Kotlin生成使用 &lt;code&gt;Nothing&lt;/code&gt; 类型的参数的原始类型的原因：</target>
        </trans-unit>
        <trans-unit id="5840d7b86dbf1ab10e5032023a9859ef434e1278" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;Boolean&lt;/code&gt; represents booleans, and has two values: &lt;em&gt;true&lt;/em&gt; and &lt;em&gt;false&lt;/em&gt;.</source>
          <target state="translated">&lt;code&gt;Boolean&lt;/code&gt; 类型表示布尔值，并具有两个值：&lt;em&gt;true&lt;/em&gt;和&lt;em&gt;false&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="fdef02e2cbe116b674c3a5cab83d13e4789bcc49" translate="yes" xml:space="preserve">
          <source>The type argument &lt;code&gt;T&lt;/code&gt; of &lt;code&gt;CPointer&amp;lt;T&amp;gt;&lt;/code&gt; must be one of the &quot;lvalue&quot; types described above, e.g., the C type &lt;code&gt;struct S*&lt;/code&gt; is mapped to &lt;code&gt;CPointer&amp;lt;S&amp;gt;&lt;/code&gt;, &lt;code&gt;int8_t*&lt;/code&gt; is mapped to &lt;code&gt;CPointer&amp;lt;int_8tVar&amp;gt;&lt;/code&gt;, and &lt;code&gt;char**&lt;/code&gt; is mapped to &lt;code&gt;CPointer&amp;lt;CPointerVar&amp;lt;ByteVar&amp;gt;&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">类型参数 &lt;code&gt;T&lt;/code&gt; 的 &lt;code&gt;CPointer&amp;lt;T&amp;gt;&lt;/code&gt; 必须是上述的&amp;ldquo;左值&amp;rdquo;类型中的一种，例如，将C型 &lt;code&gt;struct S*&lt;/code&gt; 被映射到 &lt;code&gt;CPointer&amp;lt;S&amp;gt;&lt;/code&gt; ， &lt;code&gt;int8_t*&lt;/code&gt; 被映射到 &lt;code&gt;CPointer&amp;lt;int_8tVar&amp;gt;&lt;/code&gt; ，和 &lt;code&gt;char**&lt;/code&gt; 映射到 &lt;code&gt;CPointer&amp;lt;CPointerVar&amp;lt;ByteVar&amp;gt;&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="304e12f8621867e9197c2891cfb5db65d05e542f" translate="yes" xml:space="preserve">
          <source>The type arguments of generic function calls are also only checked at compile time. Inside the function bodies, the type parameters cannot be used for type checks, and type casts to type parameters (&lt;code&gt;foo as T&lt;/code&gt;) are unchecked. However, &lt;a href=&quot;inline-functions#reified-type-parameters&quot;&gt;reified type parameters&lt;/a&gt; of inline functions are substituted by the actual type arguments in the inlined function body at the call sites and thus can be used for type checks and casts, with the same restrictions for instances of generic types as described above.</source>
          <target state="translated">泛型函数调用的类型参数也仅在编译时检查。在函数体内，类型参数不能用于类型检查，并且对类型参数（ &lt;code&gt;foo as T&lt;/code&gt; ）的类型强制转换是未选中的。然而，&lt;a href=&quot;inline-functions#reified-type-parameters&quot;&gt;具体化类型参数&lt;/a&gt;的内联函数是由实际类型参数中在调用点内联函数体取代并且因此可用于类型检查和石膏，与如上所述的一般的类型的实例相同的限制。</target>
        </trans-unit>
        <trans-unit id="6d035411fbfdc1232561efb8b45fef51b9b3f1fe" translate="yes" xml:space="preserve">
          <source>The type of &lt;code&gt;safeDivide&lt;/code&gt; is &lt;code&gt;(Int, Int) -&amp;gt; Double&lt;/code&gt;. Note that unlike function type declarations, the parameter list of a lambda expression must not be enclosed in parentheses.</source>
          <target state="translated">&lt;code&gt;safeDivide&lt;/code&gt; 的类型是 &lt;code&gt;(Int, Int) -&amp;gt; Double&lt;/code&gt; 。请注意，与函数类型声明不同，lambda表达式的参数列表不得包含在括号中。</target>
        </trans-unit>
        <trans-unit id="e87e3495180710587f4d34c13b7d672cd8d74623" translate="yes" xml:space="preserve">
          <source>The type of a delegated property wasn&amp;rsquo;t taken into account while analyzing the delegate expression which follows the &lt;code&gt;by&lt;/code&gt; keyword. For instance, the following code didn&amp;rsquo;t compile before, but now the compiler correctly infers the types of the &lt;code&gt;old&lt;/code&gt; and &lt;code&gt;new&lt;/code&gt; parameters as &lt;code&gt;String?&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c50d2b6bc67063abeddc4b2628733da7784a58f0" translate="yes" xml:space="preserve">
          <source>The type of a property, and the types that are used for the parameters and the return type of a function, must be &quot;at least as visible&quot; as the property/function itself. For example, a public function can't take a private type as a parameter.</source>
          <target state="translated">属性的类型,以及用于参数和函数返回类型的类型,必须与属性/函数本身 &quot;至少一样可见&quot;。例如,一个公共函数不能使用私有类型作为参数。</target>
        </trans-unit>
        <trans-unit id="8de1071b6667ea170a2315b344096736147854e4" translate="yes" xml:space="preserve">
          <source>The type of the &lt;code&gt;throw&lt;/code&gt; expression is the special type &lt;code&gt;Nothing&lt;/code&gt;. The type has no values and is used to mark code locations that can never be reached. In your own code, you can use &lt;code&gt;Nothing&lt;/code&gt; to mark a function that never returns:</source>
          <target state="translated">该类型的 &lt;code&gt;throw&lt;/code&gt; 表现是特殊类型 &lt;code&gt;Nothing&lt;/code&gt; 。该类型没有值，用于标记永远无法到达的代码位置。在您自己的代码中，可以使用 &lt;code&gt;Nothing&lt;/code&gt; 标记永不返回的函数：</target>
        </trans-unit>
        <trans-unit id="23c18621bf7101376cb4104c69faad184a7d75d0" translate="yes" xml:space="preserve">
          <source>The type of these expressions is the &lt;a href=&quot;exceptions#the-nothing-type&quot;&gt;Nothing type&lt;/a&gt;.</source>
          <target state="translated">这些表达式的&lt;a href=&quot;exceptions#the-nothing-type&quot;&gt;类型&lt;/a&gt;是Nothing类型。</target>
        </trans-unit>
        <trans-unit id="28dfc8e3403b9f6de19da78b037825e3337aa674" translate="yes" xml:space="preserve">
          <source>The type of values returned by this callable.</source>
          <target state="translated">该callable返回的值的类型。</target>
        </trans-unit>
        <trans-unit id="724404b217f8e33affca4710ff6d760dfbd8b8e9" translate="yes" xml:space="preserve">
          <source>The type safety checks that Kotlin performs for generic declaration usages are only done at compile time. At runtime, the instances of generic types do not hold any information about their actual type arguments. The type information is said to be &lt;em&gt;erased&lt;/em&gt;. For example, the instances of &lt;code&gt;Foo&amp;lt;Bar&amp;gt;&lt;/code&gt; and &lt;code&gt;Foo&amp;lt;Baz?&amp;gt;&lt;/code&gt; are erased to just &lt;code&gt;Foo&amp;lt;*&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Kotlin针对泛型声明用法执行的类型安全检查仅在编译时进行。在运行时，泛型类型的实例不保存有关其实际类型参数的任何信息。据说类型信息已被&lt;em&gt;擦除&lt;/em&gt;。例如， &lt;code&gt;Foo&amp;lt;Bar&amp;gt;&lt;/code&gt; 和 &lt;code&gt;Foo&amp;lt;Baz?&amp;gt;&lt;/code&gt; 实例被擦除为 &lt;code&gt;Foo&amp;lt;*&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bd9368e467f6513ce687f28529e6a3ccfb31bd57" translate="yes" xml:space="preserve">
          <source>The type specified after a colon is the &lt;strong&gt;upper bound&lt;/strong&gt;: only a subtype of &lt;code&gt;Comparable&amp;lt;T&amp;gt;&lt;/code&gt; may be substituted for &lt;code&gt;T&lt;/code&gt;. For example:</source>
          <target state="translated">冒号之后指定的类型是&lt;strong&gt;上界&lt;/strong&gt;：只有一个亚型 &lt;code&gt;Comparable&amp;lt;T&amp;gt;&lt;/code&gt; 可以取代 &lt;code&gt;T&lt;/code&gt; 。例如：</target>
        </trans-unit>
        <trans-unit id="195a81820ffdceacb4b4779278f03f44e25e239e" translate="yes" xml:space="preserve">
          <source>The type specified in the projection, or &lt;code&gt;null&lt;/code&gt; if this is a star projection.</source>
          <target state="translated">投影中指定的类型；如果是星型投影，则为 &lt;code&gt;null&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e184ade95bbad48da746688d8668a604f12d3467" translate="yes" xml:space="preserve">
          <source>The type with only one value: the &lt;code&gt;Unit&lt;/code&gt; object.</source>
          <target state="translated">只有一个值的类型： &lt;code&gt;Unit&lt;/code&gt; 对象。</target>
        </trans-unit>
        <trans-unit id="19328e2c828d83e68c896264bdfa85a39aa786f7" translate="yes" xml:space="preserve">
          <source>The type with only one value: the &lt;code&gt;Unit&lt;/code&gt; object. This type corresponds to the &lt;code&gt;void&lt;/code&gt; type in Java.</source>
          <target state="translated">只有一个值的类型： &lt;code&gt;Unit&lt;/code&gt; 对象。此类型对应于Java中的 &lt;code&gt;void&lt;/code&gt; 类型。</target>
        </trans-unit>
        <trans-unit id="7008246671a61ed2da63a9b1d753eac75888ec6a" translate="yes" xml:space="preserve">
          <source>The types inside the angle brackets are called &lt;em&gt;generic type parameters&lt;/em&gt;, which we will cover later. In short, it's a useful technique to make a class that is tied to another class (such as a container class, which is tied to its element class) applicable to many different classes.</source>
          <target state="translated">尖括号内的类型称为&lt;em&gt;通用类型参数&lt;/em&gt;，我们将在后面介绍。简而言之，使绑定到另一个类的类（例如，容器类，绑定到其元素类的类）适用于许多不同的类是一种有用的技术。</target>
        </trans-unit>
        <trans-unit id="608adb2d4b11107c32aaf63109063a2afc4cba2c" translate="yes" xml:space="preserve">
          <source>The unconfined dispatcher is an advanced mechanism that can be helpful in certain corner cases where dispatching of a coroutine for its execution later is not needed or produces undesirable side-effects, because some operation in a coroutine must be performed right away. The unconfined dispatcher should not be used in general code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6fa7d43068ef0a257b1107aef91aad1237cf845b" translate="yes" xml:space="preserve">
          <source>The unit in which this time source's readings are expressed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b16b6543fccfa319ed1bb173131c9217c5b8ccc" translate="yes" xml:space="preserve">
          <source>The usage from C is straightforward and uncomplicated. We create a &lt;code&gt;main.c&lt;/code&gt; file with the following code:</source>
          <target state="translated">C语言中的用法非常简单明了。我们使用以下代码创建一个 &lt;code&gt;main.c&lt;/code&gt; 文件：</target>
        </trans-unit>
        <trans-unit id="eda63df3b0cc777042c5e16e6a7e9e820a7f02bd" translate="yes" xml:space="preserve">
          <source>The usage is pretty similar to all-open.</source>
          <target state="translated">用法和全开很相似。</target>
        </trans-unit>
        <trans-unit id="d4460c6a02beaa088565d93296bf84c132fa91dd" translate="yes" xml:space="preserve">
          <source>The usage is the same to all-open and no-arg, except the fact that sam-with-receiver does not have any built-in presets, and you need to specify your own list of special-treated annotations.</source>
          <target state="translated">除了sam-with-receiver没有任何内置的预设之外,用法和all-open和no-arg是一样的,你需要自己指定特殊处理的注释列表。</target>
        </trans-unit>
        <trans-unit id="79d6496f32a4f62877c61deb0bd17640fe23059a" translate="yes" xml:space="preserve">
          <source>The use cases of different functions overlap, so that you can choose the functions based on the specific conventions used in your project or team.</source>
          <target state="translated">不同功能的用例有重叠,可以根据项目或团队的具体约定来选择功能。</target>
        </trans-unit>
        <trans-unit id="882548c8ded53fae119e86e0601fc1f2361824a2" translate="yes" xml:space="preserve">
          <source>The use-site variance specified in the projection, or &lt;code&gt;null&lt;/code&gt; if this is a star projection.</source>
          <target state="translated">投影中指定的使用地点差异；如果是星形投影，则为 &lt;code&gt;null&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f6253f8d51fcab2be72d37974c28482731bda531" translate="yes" xml:space="preserve">
          <source>The value being held by this class.</source>
          <target state="translated">该类所持有的价值。</target>
        </trans-unit>
        <trans-unit id="577bdaa0d4f29e2066a35e4f4e04798f20702fe4" translate="yes" xml:space="preserve">
          <source>The value is coerced to the range of &lt;a href=&quot;../../kotlin/-long/index#kotlin.Long&quot;&gt;Long&lt;/a&gt; type, if it doesn't fit in that range, see the conversion &lt;a href=&quot;../../kotlin/-double/to-long#kotlin.Double%24toLong()&quot;&gt;Double.toLong&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c6df952c69c83c655c026cd3cab96c052641127" translate="yes" xml:space="preserve">
          <source>The value must be positive and &lt;a href=&quot;../../kotlin/-int/-m-a-x_-v-a-l-u-e#kotlin.Int.Companion%24MAX_VALUE&quot;&gt;Int.MAX_VALUE&lt;/a&gt; is used to specify an unlimited depth.</source>
          <target state="translated">该值必须为正，并且&lt;a href=&quot;../../kotlin/-int/-m-a-x_-v-a-l-u-e#kotlin.Int.Companion%24MAX_VALUE&quot;&gt;Int.MAX_VALUE&lt;/a&gt;用于指定无限深度。</target>
        </trans-unit>
        <trans-unit id="97892b5c37923194772dbef7a77eefc1ede87692" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;-o&lt;/code&gt; option specifies the name of the output file, so this call should generate a &lt;code&gt;hello.kexe&lt;/code&gt; (Linux and macOS) or &lt;code&gt;hello.exe&lt;/code&gt; (Windows) binary file. For the full list of available compiler options, see the &lt;a href=&quot;../../reference/compiler-reference&quot;&gt;compiler options reference&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="239f4ace7ed276249b435b6f6174eb7de8fef7a5" translate="yes" xml:space="preserve">
          <source>The value of captured group.</source>
          <target state="translated">捕获组的价值。</target>
        </trans-unit>
        <trans-unit id="ce44ab0aef2ba6fca007243084494724190d0750" translate="yes" xml:space="preserve">
          <source>The value of this duration expressed as a &lt;a href=&quot;../../kotlin/-double/index#kotlin.Double&quot;&gt;Double&lt;/a&gt; number of days.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ddf648b4a0329becbc5477b60555b12220f10b40" translate="yes" xml:space="preserve">
          <source>The value of this duration expressed as a &lt;a href=&quot;../../kotlin/-double/index#kotlin.Double&quot;&gt;Double&lt;/a&gt; number of hours.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="011bd5d3e1ddd02dcec9b1f85243ece2a4ace656" translate="yes" xml:space="preserve">
          <source>The value of this duration expressed as a &lt;a href=&quot;../../kotlin/-double/index#kotlin.Double&quot;&gt;Double&lt;/a&gt; number of microseconds.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30b8a003aa5b8584408499ff82622a0e706a84fc" translate="yes" xml:space="preserve">
          <source>The value of this duration expressed as a &lt;a href=&quot;../../kotlin/-double/index#kotlin.Double&quot;&gt;Double&lt;/a&gt; number of milliseconds.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c99149817b525fbcf413d6772866b32a2c01ada" translate="yes" xml:space="preserve">
          <source>The value of this duration expressed as a &lt;a href=&quot;../../kotlin/-double/index#kotlin.Double&quot;&gt;Double&lt;/a&gt; number of minutes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e38ca805c23940cba81f9df025502e9ca46a64b0" translate="yes" xml:space="preserve">
          <source>The value of this duration expressed as a &lt;a href=&quot;../../kotlin/-double/index#kotlin.Double&quot;&gt;Double&lt;/a&gt; number of nanoseconds.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21ec4e0972a7296f1c104ec03a824f9de0f72383" translate="yes" xml:space="preserve">
          <source>The value of this duration expressed as a &lt;a href=&quot;../../kotlin/-double/index#kotlin.Double&quot;&gt;Double&lt;/a&gt; number of seconds.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af704602dd7474776e5b688f4b067018b5e41c89" translate="yes" xml:space="preserve">
          <source>The value of this variable.</source>
          <target state="translated">此变量的值。</target>
        </trans-unit>
        <trans-unit id="3aabcc212c1608210121013dee11f396d22f4fca" translate="yes" xml:space="preserve">
          <source>The variable containing a &lt;a href=&quot;-c-opaque-pointer&quot;&gt;COpaquePointer&lt;/a&gt;.</source>
          <target state="translated">包含&lt;a href=&quot;-c-opaque-pointer&quot;&gt;COpaquePointer&lt;/a&gt;的变量。</target>
        </trans-unit>
        <trans-unit id="e9b853cf2301d69ed0ca13dfc9180094e7f3e288" translate="yes" xml:space="preserve">
          <source>The version of the bytecode interface (naming conventions, signatures) of the class file annotated with this annotation.</source>
          <target state="translated">用该注解注释的类文件的字节码接口版本(命名惯例、签名)。</target>
        </trans-unit>
        <trans-unit id="1abfb175c8f11a4b2665f4fbd6b2ed384b7a75ef" translate="yes" xml:space="preserve">
          <source>The version of the metadata provided in the arguments of this annotation.</source>
          <target state="translated">本注解的参数中提供的元数据的版本。</target>
        </trans-unit>
        <trans-unit id="b210bbe6f64c596cb275d652b699dc315a1fc8bc" translate="yes" xml:space="preserve">
          <source>The very first part contains the standard C/C++ header and footer:</source>
          <target state="translated">第一部分包含标准的C/C++头和脚。</target>
        </trans-unit>
        <trans-unit id="13204b21b51f8144497368ed89b8d47c465b75a3" translate="yes" xml:space="preserve">
          <source>The visibility level only affects the &lt;em&gt;lexical visibility&lt;/em&gt; of the &lt;em&gt;symbol&lt;/em&gt; - i.e., where the compiler allows you to type out the symbol. It does not affect where &lt;em&gt;instances&lt;/em&gt; are used: for example, a public top-level function may well return an instance of a private class, as long as the return type doesn't mention the private class name but is instead a public base class of the private class (possibly &lt;code&gt;Any&lt;/code&gt;) or a public interface that the private class implements. When you &lt;a href=&quot;inheritance#subclassing&quot;&gt;subclass&lt;/a&gt; a class, its private members are also inherited by the subclass, but are not directly accessible there - however, if you call an inherited public function that happens to access a private member, that's fine.</source>
          <target state="translated">可见性级别仅影响&lt;em&gt;符号&lt;/em&gt;的&lt;em&gt;词法可见性&lt;/em&gt;，即，编译器允许您键入符号。它不会影响使用&lt;em&gt;实例的&lt;/em&gt;位置：例如，一个公共顶级函数很可能会返回一个私有类的实例，只要返回类型没有提及私有类的名称，而是一个私有的基类即可。私有类（可能是 &lt;code&gt;Any&lt;/code&gt; ）或私有类实现的公共接口。当您对一个类进行&lt;a href=&quot;inheritance#subclassing&quot;&gt;子&lt;/a&gt;类化时，子类也继承了它的私有成员，但是在那里不能直接访问它-但是，如果您调用碰巧访问私有成员的继承的公共函数，那很好。&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="be08405fa49b795ce8dcbbade59f22553916f972" translate="yes" xml:space="preserve">
          <source>The way in which we'd use this from JavaScript would be to call &lt;code&gt;dataTable()&lt;/code&gt; on the corresponding &lt;code&gt;&amp;lt;table&amp;gt;&lt;/code&gt; element</source>
          <target state="translated">我们将通过JavaScript使用此方法的方式是在相应的 &lt;code&gt;&amp;lt;table&amp;gt;&lt;/code&gt; 元素上调用 &lt;code&gt;dataTable()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="df6c92cd4ac7021995eb7f605c7d7406310257be" translate="yes" xml:space="preserve">
          <source>The way to refer to the context object</source>
          <target state="translated">引用上下文对象的方式</target>
        </trans-unit>
        <trans-unit id="db21ceeaa7842bb619c97af30e1e09b94faa6e61" translate="yes" xml:space="preserve">
          <source>The web site has a bunch of &lt;a href=&quot;https://kotlinlang.org/community/&quot;&gt;online resources&lt;/a&gt;, including &lt;a href=&quot;https://kotlin.link&quot;&gt;Kotlin Digests&lt;/a&gt; by community members, a &lt;a href=&quot;http://www.kotlinweekly.net&quot;&gt;newsletter&lt;/a&gt;, a &lt;a href=&quot;https://talkingkotlin.com&quot;&gt;podcast&lt;/a&gt; and more.</source>
          <target state="translated">该网站拥有大量&lt;a href=&quot;https://kotlinlang.org/community/&quot;&gt;在线资源&lt;/a&gt;，包括社区成员的&lt;a href=&quot;https://kotlin.link&quot;&gt;Kotlin Digests&lt;/a&gt;，&lt;a href=&quot;http://www.kotlinweekly.net&quot;&gt;新闻通讯&lt;/a&gt;，&lt;a href=&quot;https://talkingkotlin.com&quot;&gt;播客&lt;/a&gt;等等。</target>
        </trans-unit>
        <trans-unit id="ffaad4042bec05249e2007ea2e2a7c01e5b1b264" translate="yes" xml:space="preserve">
          <source>Then add the respective dependencies using the &lt;code&gt;kapt&lt;/code&gt; configuration in your &lt;code&gt;dependencies&lt;/code&gt; block:</source>
          <target state="translated">然后在您的 &lt;code&gt;dependencies&lt;/code&gt; 块中使用 &lt;code&gt;kapt&lt;/code&gt; 配置添加相应的依赖关系：</target>
        </trans-unit>
        <trans-unit id="3d3dd4715a6e839facb3a4bc6c2872f8802ec4b8" translate="yes" xml:space="preserve">
          <source>Then follow the wizard steps. You'll have a &lt;code&gt;build.gradle&lt;/code&gt; file created with Kotlin configured according to &lt;a href=&quot;../../reference/using-gradle&quot;&gt;this document&lt;/a&gt;. Make sure it's configured for Kotlin 1.3 or higher.</source>
          <target state="translated">然后按照向导步骤。您将拥有一个Kotlin创建的 &lt;code&gt;build.gradle&lt;/code&gt; 文件，&lt;a href=&quot;../../reference/using-gradle&quot;&gt;该文件&lt;/a&gt;根据此文档进行配置。确保将其配置为Kotlin 1.3或更高版本。</target>
        </trans-unit>
        <trans-unit id="9ed3e436c4ee364169e1bdacb724480b6ae120b2" translate="yes" xml:space="preserve">
          <source>Then follow the wizard steps. You'll have a &lt;code&gt;pom.xml&lt;/code&gt; file created with Kotlin configured according to &lt;a href=&quot;../../reference/using-maven&quot;&gt;this document&lt;/a&gt;. Make sure it's configured for Kotlin 1.3 or higher.</source>
          <target state="translated">然后按照向导步骤。您将拥有一个根据&lt;a href=&quot;../../reference/using-maven&quot;&gt;本文档&lt;/a&gt;配置Kotlin创建的 &lt;code&gt;pom.xml&lt;/code&gt; 文件。确保将其配置为Kotlin 1.3或更高版本。</target>
        </trans-unit>
        <trans-unit id="10cfe3c1803900b3459055c1fdedb21ced35e4cd" translate="yes" xml:space="preserve">
          <source>Then run the &lt;code&gt;cinterop&lt;/code&gt; tool with something like this (note that for host libraries that are not included in the sysroot search paths, headers may be needed):</source>
          <target state="translated">然后使用以下内容运行 &lt;code&gt;cinterop&lt;/code&gt; 工具（请注意，对于sysroot搜索路径中未包含的主机库，可能需要标头）：</target>
        </trans-unit>
        <trans-unit id="5581239ffa3d854f1837127435e240d49f122ba5" translate="yes" xml:space="preserve">
          <source>Then specify the list of SAM-with-receiver annotations:</source>
          <target state="translated">然后指定SAM-with-receiver注释的列表。</target>
        </trans-unit>
        <trans-unit id="9b78fa9ef8a36ffde61cb8bc4f298109afadcbee" translate="yes" xml:space="preserve">
          <source>Then specify the list of annotations that will make classes open:</source>
          <target state="translated">然后指定将使类打开的注释列表。</target>
        </trans-unit>
        <trans-unit id="fd73374c27e0a874f2f41c35f033bfc599a82d6b" translate="yes" xml:space="preserve">
          <source>Then specify the list of no-arg annotations:</source>
          <target state="translated">然后指定无参数注释的列表。</target>
        </trans-unit>
        <trans-unit id="0ef92249fe5f505a551a8b463644321da779af43" translate="yes" xml:space="preserve">
          <source>Then we can have several processor coroutines. In this example, they just print their id and received number:</source>
          <target state="translated">那么我们可以有几个处理器的coroutine。在这个例子中,它们只是打印自己的id和收到的号码。</target>
        </trans-unit>
        <trans-unit id="490b87ea6044ef60c21b2e7783571a7d77df8b12" translate="yes" xml:space="preserve">
          <source>Then we define a function that launches an actor using an &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/actor.html&quot;&gt;actor&lt;/a&gt; coroutine builder:</source>
          <target state="translated">然后，我们定义一个使用&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/actor.html&quot;&gt;actor&lt;/a&gt;协程生成器启动actor的函数：</target>
        </trans-unit>
        <trans-unit id="d20d8e9783f5f7554d56032158624be9ade29c33" translate="yes" xml:space="preserve">
          <source>Then we end up with a flow of flows (&lt;code&gt;Flow&amp;lt;Flow&amp;lt;String&amp;gt;&amp;gt;&lt;/code&gt;) that needs to be &lt;em&gt;flattened&lt;/em&gt; into a single flow for further processing. Collections and sequences have &lt;a href=&quot;../../../api/latest/jvm/stdlib/kotlin.sequences/flatten&quot;&gt;flatten&lt;/a&gt; and &lt;a href=&quot;../../../api/latest/jvm/stdlib/kotlin.sequences/flat-map&quot;&gt;flatMap&lt;/a&gt; operators for this. However, due to the asynchronous nature of flows they call for different &lt;em&gt;modes&lt;/em&gt; of flattening, as such, there is a family of flattening operators on flows.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ca671870f1fadd5567721f74e5bc28177111ecb" translate="yes" xml:space="preserve">
          <source>Then you can finish creating your project or, optionally, &lt;em&gt;configure the project&lt;/em&gt; on the next screen:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="843feae1b1434f20428d159db5d3289af1525e9c" translate="yes" xml:space="preserve">
          <source>Then, for each &lt;a href=&quot;https://developer.android.com/studio/build/build-variants#sourcesets&quot;&gt;Android source set&lt;/a&gt; compiled by the variants, a Kotlin source set is created under that source set name prepended by the target name, like Kotlin source set &lt;code&gt;androidDebug&lt;/code&gt; for an Android source set &lt;code&gt;debug&lt;/code&gt; and the Kotlin target named &lt;code&gt;android&lt;/code&gt;. These Kotlin source sets are added to the variants compilations accordingly.</source>
          <target state="translated">然后，对于由变体编译的每个&lt;a href=&quot;https://developer.android.com/studio/build/build-variants#sourcesets&quot;&gt;Android源集&lt;/a&gt;，将在目标名称前的源集名称下创建Kotlin源集，例如Android源集 &lt;code&gt;debug&lt;/code&gt; 的 Kotlin源集 &lt;code&gt;androidDebug&lt;/code&gt; 和名为 &lt;code&gt;android&lt;/code&gt; 的Kotlin目标。这些Kotlin源集会相应地添加到变体编辑中。</target>
        </trans-unit>
        <trans-unit id="8f493cee5294668e61abac2182624f37839c6424" translate="yes" xml:space="preserve">
          <source>Then, for each &lt;a href=&quot;https://developer.android.com/studio/build/build-variants#sourcesets&quot;&gt;Android source set&lt;/a&gt; compiled for each of the variants, a Kotlin source set is created under that source set name prepended by the target name, like the Kotlin source set &lt;code&gt;androidDebug&lt;/code&gt; for an Android source set &lt;code&gt;debug&lt;/code&gt; and the Kotlin target named &lt;code&gt;android&lt;/code&gt;. These Kotlin source sets are added to the variants&amp;rsquo; compilations accordingly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68562aa9b0f180cb0bf47fd690042cd2286c6294" translate="yes" xml:space="preserve">
          <source>Then, it would be perfectly safe to store a reference to an instance of &lt;code&gt;Source&amp;lt;String&amp;gt;&lt;/code&gt; in a variable of type &lt;code&gt;Source&amp;lt;Object&amp;gt;&lt;/code&gt; &amp;ndash; there are no consumer-methods to call. But Java does not know this, and still prohibits it:</source>
          <target state="translated">然后，将对 &lt;code&gt;Source&amp;lt;String&amp;gt;&lt;/code&gt; 实例的引用存储在类型为 &lt;code&gt;Source&amp;lt;Object&amp;gt;&lt;/code&gt; 的变量中将是绝对安全的&amp;ndash;没有要调用的使用方方法。但是Java不知道这一点，并且仍然禁止它：</target>
        </trans-unit>
        <trans-unit id="d673d7a939528ccf7977db751d0c7bd0f923bb89" translate="yes" xml:space="preserve">
          <source>Then, once a target is added, default compilations are created for it:</source>
          <target state="translated">然后,一旦添加了一个目标,就会为其创建默认的编译。</target>
        </trans-unit>
        <trans-unit id="a7b51b664e8983298e6dc346e7c7dc0b18863813" translate="yes" xml:space="preserve">
          <source>Then, some time later the deprecation level is raised to &lt;a href=&quot;../-deprecation-level/-e-r-r-o-r#kotlin.DeprecationLevel.ERROR&quot;&gt;DeprecationLevel.ERROR&lt;/a&gt;, so that no new Kotlin code can be compiled using the deprecated API.</source>
          <target state="translated">然后，过一会儿，弃用级别将提高到&lt;a href=&quot;../-deprecation-level/-e-r-r-o-r#kotlin.DeprecationLevel.ERROR&quot;&gt;DeprecationLevel.ERROR&lt;/a&gt;，以便使用弃用的API无法编译新的Kotlin代码。</target>
        </trans-unit>
        <trans-unit id="b6377e7d0f06e408f80f03d549dd08ce8d9b969c" translate="yes" xml:space="preserve">
          <source>Then, the only thing we want to ensure is that &lt;code&gt;copy()&lt;/code&gt; does not do any bad things. We want to prohibit it from &lt;strong&gt;writing&lt;/strong&gt; to &lt;code&gt;from&lt;/code&gt;, and we can:</source>
          <target state="translated">然后，我们唯一要确保的是 &lt;code&gt;copy()&lt;/code&gt; 不会做任何不好的事情。我们想从禁止其&lt;strong&gt;写入&lt;/strong&gt;到 &lt;code&gt;from&lt;/code&gt; ，我们可以：</target>
        </trans-unit>
        <trans-unit id="2e04f4cdf39ff6bfe2fd15e1cdcb551eff15e642" translate="yes" xml:space="preserve">
          <source>There are a few courses available for Kotlin, including a &lt;a href=&quot;https://www.pluralsight.com/courses/kotlin-getting-started&quot;&gt;Pluralsight Kotlin Course&lt;/a&gt; by Kevin Jones, an &lt;a href=&quot;http://shop.oreilly.com/product/0636920052982.do&quot;&gt;O&amp;rsquo;Reilly Course&lt;/a&gt; by Hadi Hariri and an &lt;a href=&quot;http://petersommerhoff.com/dev/kotlin/kotlin-beginner-tutorial/&quot;&gt;Udemy Kotlin Course&lt;/a&gt; by Peter Sommerhoff.</source>
          <target state="translated">Kotlin有一些可用的课程，包括Kevin Jones 的&lt;a href=&quot;https://www.pluralsight.com/courses/kotlin-getting-started&quot;&gt;Pluralsight Kotlin &lt;/a&gt;&lt;a href=&quot;http://shop.oreilly.com/product/0636920052982.do&quot;&gt;课程&lt;/a&gt;，Hadi Hariri 的O'Reilly课程和Peter Sommerhoff 的&lt;a href=&quot;http://petersommerhoff.com/dev/kotlin/kotlin-beginner-tutorial/&quot;&gt;Udemy Kotlin课程&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7aeb1151dcad680105c7a075482911c8fc7a00f6" translate="yes" xml:space="preserve">
          <source>There are a lot of built-in extension functions/properties in Kotlin - for example, &lt;code&gt;map()&lt;/code&gt;, &lt;code&gt;filter()&lt;/code&gt;, and the rest of the framework for processing collections in a functional manner is built using extension functions.</source>
          <target state="translated">Kotlin中有很多内置的扩展功能/属性-例如 &lt;code&gt;map()&lt;/code&gt; ， &lt;code&gt;filter()&lt;/code&gt; 和使用扩展功能构建其余用于以功能方式处理集合的框架。</target>
        </trans-unit>
        <trans-unit id="24f819fcebc7b01f0f49b06a15eca941aac602cd" translate="yes" xml:space="preserve">
          <source>There are already &lt;a href=&quot;https://kotlinlang.org/docs/books.html&quot;&gt;a number of books&lt;/a&gt; available for Kotlin, including &lt;a href=&quot;https://www.manning.com/books/kotlin-in-action&quot;&gt;Kotlin in Action&lt;/a&gt; which is by Kotlin team members Dmitry Jemerov and Svetlana Isakova, &lt;a href=&quot;https://leanpub.com/kotlin-for-android-developers&quot;&gt;Kotlin for Android Developers&lt;/a&gt; targeted at Android developers.</source>
          <target state="translated">Kotlin 已经&lt;a href=&quot;https://kotlinlang.org/docs/books.html&quot;&gt;有许多&lt;/a&gt;可用的书籍，其中包括&lt;a href=&quot;https://www.manning.com/books/kotlin-in-action&quot;&gt;Kotlin&lt;/a&gt;团队成员Dmitry Jemerov和&lt;a href=&quot;https://leanpub.com/kotlin-for-android-developers&quot;&gt;Kotlin的&lt;/a&gt; Svetlana Isakova，由Kotlin团队成员Dmitry Jemerov和Android开发人员针对Android开发人员编写。</target>
        </trans-unit>
        <trans-unit id="5fc2f752c1f987f34408faba377f5009dac3834a" translate="yes" xml:space="preserve">
          <source>There are also &lt;code&gt;minOfWith()&lt;/code&gt; and &lt;code&gt;maxOfWith()&lt;/code&gt;, which take a &lt;code&gt;Comparator&lt;/code&gt; as an argument, and &lt;code&gt;*OrNull()&lt;/code&gt; versions of all four functions that return &lt;code&gt;null&lt;/code&gt; on empty collections.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9bb89fb652d44ab10911a269bc7625b66f46b917" translate="yes" xml:space="preserve">
          <source>There are also community-maintained libraries that support more serialization formats, such as &lt;a href=&quot;https://yaml.org/&quot;&gt;YAML&lt;/a&gt; or &lt;a href=&quot;https://avro.apache.org/&quot;&gt;Apache Avro&lt;/a&gt;. For detailed information about available serialization formats, see the &lt;a href=&quot;https://github.com/Kotlin/kotlinx.serialization/blob/master/formats/README.md&quot;&gt;&lt;code&gt;kotlinx.serialization&lt;/code&gt; documentation&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cafdda410a7a8fb3e86649e5eeda1f41cb52882f" translate="yes" xml:space="preserve">
          <source>There are also functions for creating collections without any elements: &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/empty-list&quot;&gt;&lt;code&gt;emptyList()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/empty-set&quot;&gt;&lt;code&gt;emptySet()&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/empty-map&quot;&gt;&lt;code&gt;emptyMap()&lt;/code&gt;&lt;/a&gt;. When creating empty collections, you should specify the type of elements that the collection will hold.</source>
          <target state="translated">还有一些用于创建不带任何元素的集合的函数：&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/empty-list&quot;&gt; &lt;code&gt;emptyList()&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/empty-set&quot;&gt; &lt;code&gt;emptySet()&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/empty-map&quot;&gt; &lt;code&gt;emptyMap()&lt;/code&gt; &lt;/a&gt;。创建空集合时，应指定集合将包含的元素类型。</target>
        </trans-unit>
        <trans-unit id="843241bb0f5eb80f440f0b1b3622ce9c95598c3b" translate="yes" xml:space="preserve">
          <source>There are also functions for retrieving the smallest and the largest elements by certain selector function or custom &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin/-comparator/index&quot;&gt;&lt;code&gt;Comparator&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">还有一些通过某些选择器功能或自定义&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin/-comparator/index&quot;&gt; &lt;code&gt;Comparator&lt;/code&gt; &lt;/a&gt;检索最小和最大元素的函数：</target>
        </trans-unit>
        <trans-unit id="4888d99de496e5f2812e2d42599de7f621ae0a73" translate="yes" xml:space="preserve">
          <source>There are also functions that narrow the element type by filtering elements of a given type:</source>
          <target state="translated">还有一些函数可以通过过滤给定类型的元素来缩小元素类型。</target>
        </trans-unit>
        <trans-unit id="22fc645d90366ef3cbd36340e10852155ba93121" translate="yes" xml:space="preserve">
          <source>There are also many recordings of &lt;a href=&quot;http://kotlinlang.org/community/talks.html&quot;&gt;Kotlin talks&lt;/a&gt; available on YouTube and Vimeo.</source>
          <target state="translated">YouTube和Vimeo上还有许多&lt;a href=&quot;http://kotlinlang.org/community/talks.html&quot;&gt;Kotlin演讲的&lt;/a&gt;录音。</target>
        </trans-unit>
        <trans-unit id="e4606566df8d7d15d5ed6bd46e8178f7ee899fb7" translate="yes" xml:space="preserve">
          <source>There are also more specific types:</source>
          <target state="translated">还有一些比较特殊的类型。</target>
        </trans-unit>
        <trans-unit id="06489c1e98a1df08c22af1c2c8a1f880cc0522a9" translate="yes" xml:space="preserve">
          <source>There are also some tools available to convert between Kotlin and C strings manually:</source>
          <target state="translated">也有一些工具可以在Kotlin和C字符串之间手动转换。</target>
        </trans-unit>
        <trans-unit id="5da1b83a877bec99a63204ac23c3a863bcc7d2fe" translate="yes" xml:space="preserve">
          <source>There are also the following type qualifiers in the C language: &lt;code&gt;const&lt;/code&gt;, &lt;code&gt;volatile&lt;/code&gt;, &lt;code&gt;restruct&lt;/code&gt;, &lt;code&gt;atomic&lt;/code&gt;.</source>
          <target state="translated">在C语言中，还有以下类型限定符： &lt;code&gt;const&lt;/code&gt; ， &lt;code&gt;volatile&lt;/code&gt; ， &lt;code&gt;restruct&lt;/code&gt; ， &lt;code&gt;atomic&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d1856539b37f6f362e28eec082e8282bf62fdd7b" translate="yes" xml:space="preserve">
          <source>There are also two specific ways for filtering maps: by keys and by values. For each way, there is a function: &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/filter-keys&quot;&gt;&lt;code&gt;filterKeys()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/filter-values&quot;&gt;&lt;code&gt;filterValues()&lt;/code&gt;&lt;/a&gt;. Both return a new map of entries which match the given predicate. The predicate for &lt;code&gt;filterKeys()&lt;/code&gt; checks only the element keys, the one for &lt;code&gt;filterValues()&lt;/code&gt; checks only values.</source>
          <target state="translated">还有两种用于过滤地图的特定方法：按键和按值。对于每种方式，都有一个函数：&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/filter-keys&quot;&gt; &lt;code&gt;filterKeys()&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/filter-values&quot;&gt; &lt;code&gt;filterValues()&lt;/code&gt; &lt;/a&gt;。两者均返回与给定谓词匹配的新条目映射。谓词 &lt;code&gt;filterKeys()&lt;/code&gt; 仅检查元件按键，一个用于 &lt;code&gt;filterValues()&lt;/code&gt; 仅检查值。</target>
        </trans-unit>
        <trans-unit id="250044abbac1d0cc39bffb2b00e37419c1aa5fa8" translate="yes" xml:space="preserve">
          <source>There are also useful aliases for retrieving the first and the last element of the collection: &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/first&quot;&gt;&lt;code&gt;first()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/last&quot;&gt;&lt;code&gt;last()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">还有一些有用的别名来检索集合的第一个和最后一个元素：&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/first&quot;&gt; &lt;code&gt;first()&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/last&quot;&gt; &lt;code&gt;last()&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f989069ff2a0fc8bbd7269050d48a2e9c89946af" translate="yes" xml:space="preserve">
          <source>There are certain common kinds of properties, that, though we can implement them manually every time we need them, would be very nice to implement once and for all, and put into a library. Examples include:</source>
          <target state="translated">有一些常见的属性,虽然我们可以在每次需要的时候手动实现,但如果能一次性实现,并放入库中,那就再好不过了。例子包括:</target>
        </trans-unit>
        <trans-unit id="e9d07a2b7a0e6a37bb57f8fc3823505798a41626" translate="yes" xml:space="preserve">
          <source>There are certain rules that define write operations on maps:</source>
          <target state="translated">有一些规则定义了对地图的写操作。</target>
        </trans-unit>
        <trans-unit id="2a3a36051a175f99aacc43b0a72a065674774e2a" translate="yes" xml:space="preserve">
          <source>There are couple of observations to make out of it.</source>
          <target state="translated">从中可以看出几个问题。</target>
        </trans-unit>
        <trans-unit id="fd050ce9dc8260feb80b7e8ad7e70f3ec42e69f1" translate="yes" xml:space="preserve">
          <source>There are exactly four instances of this class, named &lt;code&gt;ContentKind.TOPIC&lt;/code&gt;, and so on. Instances of this class can be compared to each other with &lt;code&gt;==&lt;/code&gt; and &lt;code&gt;!=&lt;/code&gt;, and you can get all the allowable values with &lt;code&gt;ContentKind.values()&lt;/code&gt;. You can also tack on more information to each instance if you need:</source>
          <target state="translated">该类有四个实例，分别称为 &lt;code&gt;ContentKind.TOPIC&lt;/code&gt; ，依此类推。可以使用 &lt;code&gt;==&lt;/code&gt; 和 &lt;code&gt;!=&lt;/code&gt; 将此类的实例相互比较，并且可以使用 &lt;code&gt;ContentKind.values()&lt;/code&gt; 获得所有允许的值。如果需要，您还可以为每个实例提供更多信息：</target>
        </trans-unit>
        <trans-unit id="11ad196ede0a4f63cd51413d0ab908cfc6383f63" translate="yes" xml:space="preserve">
          <source>There are four types of dependencies:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99e47ebabd055fced8bd65467671cf5429616422" translate="yes" xml:space="preserve">
          <source>There are lots of ways to compose multiple flows.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f927ac2e11471dbf3b5e6b2ee718ccfcd881bb02" translate="yes" xml:space="preserve">
          <source>There are many approaches to this problem, and in Kotlin we take a very flexible one by providing &lt;a href=&quot;https://en.wikipedia.org/wiki/Coroutine&quot;&gt;Coroutine&lt;/a&gt; support at the language level and delegating most of the functionality to libraries, much in line with Kotlin's philosophy.</source>
          <target state="translated">解决此问题的方法很多，在Kotlin中，我们通过在语言级别提供&lt;a href=&quot;https://en.wikipedia.org/wiki/Coroutine&quot;&gt;Coroutine&lt;/a&gt;支持并将大部分功能委托给库来采取非常灵活的方法，这与Kotlin的哲学非常一致。</target>
        </trans-unit>
        <trans-unit id="a0366ee935c5394b522c3fe877f29b4f014a964b" translate="yes" xml:space="preserve">
          <source>There are many more platform libraries available for host and cross-compilation targets. &lt;code&gt;Kotlin/Native&lt;/code&gt; distribution provides access to &lt;code&gt;OpenGL&lt;/code&gt;, &lt;code&gt;zlib&lt;/code&gt; and other popular native libraries on applicable platforms.</source>
          <target state="translated">还有更多的平台库可用于宿主和交叉编译目标。 &lt;code&gt;Kotlin/Native&lt;/code&gt; 发行版提供对 &lt;code&gt;OpenGL&lt;/code&gt; ， &lt;code&gt;zlib&lt;/code&gt; 和适用平台上其他流行的本机库的访问。</target>
        </trans-unit>
        <trans-unit id="ef27dee02c48c1f5d014bbb6297ef36468bd6491" translate="yes" xml:space="preserve">
          <source>There are multiple ways to compile Kotlin to JavaScript. The recommended approach is to use Gradle; if desired, you can also build JavaScript projects directly from IntelliJ IDEA, use Maven, or compile the code manually from the command line. To learn more about how to compile to JavaScript please see the corresponding tutorials:</source>
          <target state="translated">有多种方法可以将Kotlin编译成JavaScript。推荐的方法是使用Gradle;如果需要,你也可以直接从IntelliJ IDEA中构建JavaScript项目,使用Maven,或者从命令行手动编译代码。要了解更多关于如何编译成JavaScript的信息,请看相应的教程。</target>
        </trans-unit>
        <trans-unit id="2dc32ef7bc8bd0e0afcc7aa9afb4f5081190370a" translate="yes" xml:space="preserve">
          <source>There are new &lt;code&gt;compile&amp;lt;SourceSet&amp;gt;KotlinMetadata&lt;/code&gt; tasks for all published intermediate source-sets</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="655afcf98b929642faf68faf52cca26e671f04f6" translate="yes" xml:space="preserve">
          <source>There are no &lt;code&gt;**kwargs&lt;/code&gt; in Kotlin, but you can define optional parameters with default values, and you may choose to name some or all of the parameters when you call the function (whether they've got default values or not). A parameter with a default value must still specify its type explicitly. Like in Python, the named arguments can be reordered at will at the call site:</source>
          <target state="translated">Kotlin 中没有 &lt;code&gt;**kwargs&lt;/code&gt; kwarg，但是您可以定义具有默认值的可选参数，并且在调用函数时可以选择命名部分或全部参数（无论它们是否具有默认值）。具有默认值的参数仍必须明确指定其类型。像在Python中一样，可以在调用站点随意重新命名命名的参数：</target>
        </trans-unit>
        <trans-unit id="577ed2c21e3c8a21c4f57421503fea8126403589" translate="yes" xml:space="preserve">
          <source>There are no automatic conversions to boolean and thus no concept of truthy and falsy: checks for zero, empty, or null must be done explicitly with &lt;code&gt;==&lt;/code&gt; or &lt;code&gt;!=&lt;/code&gt;. Most collection types have an &lt;code&gt;isEmpty()&lt;/code&gt; and an &lt;code&gt;isNotEmpty()&lt;/code&gt; function.</source>
          <target state="translated">没有自动转换为布尔值的方法，因此也没有&amp;ldquo;真假&amp;rdquo;的概念：必须使用 &lt;code&gt;==&lt;/code&gt; 或 &lt;code&gt;!=&lt;/code&gt; 明确进行零，空或null的检查。大多数集合类型具有 &lt;code&gt;isEmpty()&lt;/code&gt; 和 &lt;code&gt;isNotEmpty()&lt;/code&gt; 函数。</target>
        </trans-unit>
        <trans-unit id="0173c0164165dfc2326b31145c73366a6b9e4caf" translate="yes" xml:space="preserve">
          <source>There are now separate versions of the standard library supporting the new JDK APIs added in Java 7 and 8. If you need access to the new APIs, use &lt;code&gt;kotlin-stdlib-jre7&lt;/code&gt; and &lt;code&gt;kotlin-stdlib-jre8&lt;/code&gt; maven artifacts instead of the standard &lt;code&gt;kotlin-stdlib&lt;/code&gt;. These artifacts are tiny extensions on top of &lt;code&gt;kotlin-stdlib&lt;/code&gt; and they bring it to your project as a transitive dependency.</source>
          <target state="translated">现在，有标准库的单独版本支持在Java 7和8中添加的新JDK API。如果需要访问新API，请使用 &lt;code&gt;kotlin-stdlib-jre7&lt;/code&gt; 和 &lt;code&gt;kotlin-stdlib-jre8&lt;/code&gt; maven构件代替标准 &lt;code&gt;kotlin-stdlib&lt;/code&gt; 。这些工件是 &lt;code&gt;kotlin-stdlib&lt;/code&gt; 之上的微小扩展，它们作为传递依赖项将其带入您的项目。</target>
        </trans-unit>
        <trans-unit id="eb7a82db5fbadd7939003437756e36c07405db69" translate="yes" xml:space="preserve">
          <source>There are numerous ways that Kotlin/JS can be used. To provide you some inspiration, here's a non-exhaustive list of scenarios in which you can use Kotlin/JS.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f69b73bfcd710307d7869f79c049d0bc960833d" translate="yes" xml:space="preserve">
          <source>There are several ways to obtain an instance of a function type:</source>
          <target state="translated">有几种方法可以获得函数类型的实例。</target>
        </trans-unit>
        <trans-unit id="bfb4470f4c8ab69e441c59ca19feae2c36a172f6" translate="yes" xml:space="preserve">
          <source>There are several ways to override the default setting:</source>
          <target state="translated">有几种方法可以覆盖默认设置。</target>
        </trans-unit>
        <trans-unit id="bf800a950521aa58b97d350b92bc387bac6d9bab" translate="yes" xml:space="preserve">
          <source>There are several ways to set the compiler options and their values (&lt;em&gt;compiler arguments&lt;/em&gt;):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ea08a710ccd5abee84ca77d28377d406d442756" translate="yes" xml:space="preserve">
          <source>There are some limitations:</source>
          <target state="translated">有一些限制。</target>
        </trans-unit>
        <trans-unit id="060bb5e1464bf104cc44e53612c8d8eb0e6d472c" translate="yes" xml:space="preserve">
          <source>There are target presets that one can apply using the preset functions, as shown above, for the following target platforms:</source>
          <target state="translated">有一些目标预设,可以使用预设功能来应用,如上图所示,适用于以下目标平台。</target>
        </trans-unit>
        <trans-unit id="928b53f844ebe12f1ce8f740249971af80b86900" translate="yes" xml:space="preserve">
          <source>There are the following kinds of binaries:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7df642de78432a3520c5b5afd68e2c605c1c315a" translate="yes" xml:space="preserve">
          <source>There are the following kinds of literal constants for integral values:</source>
          <target state="translated">积分值的文字常数有以下几种。</target>
        </trans-unit>
        <trans-unit id="f4373b7b309c5120a0c7bdb4b6efb5a4594f35b5" translate="yes" xml:space="preserve">
          <source>There are three coroutines. The main coroutine (#1) &amp;ndash; &lt;code&gt;runBlocking&lt;/code&gt; one, and two coroutines computing deferred values &lt;code&gt;a&lt;/code&gt; (#2) and &lt;code&gt;b&lt;/code&gt; (#3). They are all executing in the context of &lt;code&gt;runBlocking&lt;/code&gt; and are confined to the main thread. The output of this code is:</source>
          <target state="translated">有三个协程。主协程（＃1）&amp;ndash; &lt;code&gt;runBlocking&lt;/code&gt; 一个协程，两个协程计算递延值 &lt;code&gt;a&lt;/code&gt; （＃2）和 &lt;code&gt;b&lt;/code&gt; （＃3）。它们都在 &lt;code&gt;runBlocking&lt;/code&gt; 上下文中执行，并且仅限于主线程。此代码的输出是：</target>
        </trans-unit>
        <trans-unit id="b170e6fd924b27994900ac3fea0116365dd9d5a3" translate="yes" xml:space="preserve">
          <source>There are three coroutines. The main coroutine (#1) inside &lt;code&gt;runBlocking&lt;/code&gt; and two coroutines computing the deferred values &lt;code&gt;a&lt;/code&gt; (#2) and &lt;code&gt;b&lt;/code&gt; (#3). They are all executing in the context of &lt;code&gt;runBlocking&lt;/code&gt; and are confined to the main thread. The output of this code is:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f684c90b5c1cc2b45ec708952abe326e96395793" translate="yes" xml:space="preserve">
          <source>There are too many companies using Kotlin to list, but some more visible companies that have publicly declared usage of Kotlin, be this via blog posts, GitHub repositories or talks include &lt;a href=&quot;https://medium.com/square-corner-blog/square-open-source-loves-kotlin-c57c21710a17&quot;&gt;Square&lt;/a&gt;, &lt;a href=&quot;https://www.youtube.com/watch?v=mDpnc45WwlI&quot;&gt;Pinterest&lt;/a&gt;, &lt;a href=&quot;https://m.signalvnoise.com/how-we-made-basecamp-3s-android-app-100-kotlin-35e4e1c0ef12&quot;&gt;Basecamp&lt;/a&gt; or &lt;a href=&quot;https://docs.corda.net/releases/release-M9.2/further-notes-on-kotlin.html&quot;&gt;Corda&lt;/a&gt;.</source>
          <target state="translated">有太多使用Kotlin进行上市的公司，但是一些公开宣布使用Kotlin的知名公司（包括博客文章，GitHub仓库或座谈会）包括&lt;a href=&quot;https://medium.com/square-corner-blog/square-open-source-loves-kotlin-c57c21710a17&quot;&gt;Square&lt;/a&gt;，&lt;a href=&quot;https://www.youtube.com/watch?v=mDpnc45WwlI&quot;&gt;Pinterest&lt;/a&gt;，&lt;a href=&quot;https://m.signalvnoise.com/how-we-made-basecamp-3s-android-app-100-kotlin-35e4e1c0ef12&quot;&gt;Basecamp&lt;/a&gt;或&lt;a href=&quot;https://docs.corda.net/releases/release-M9.2/further-notes-on-kotlin.html&quot;&gt;Corda&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="26ea8b64f47f54b93f794f79bdbd7ea265251dad" translate="yes" xml:space="preserve">
          <source>There are two approaches to making computation code cancellable. The first one is to periodically invoke a suspending function that checks for cancellation. There is a &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/yield.html&quot;&gt;yield&lt;/a&gt; function that is a good choice for that purpose. The other one is to explicitly check the cancellation status. Let us try the latter approach.</source>
          <target state="translated">有两种方法可以使计算代码可取消。第一个是定期调用检查取消的挂起函数。为此，有一个&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/yield.html&quot;&gt;yield&lt;/a&gt;函数是一个不错的选择。另一个是显式检查取消状态。让我们尝试后一种方法。</target>
        </trans-unit>
        <trans-unit id="cdb0e62ebdac6496d2a6cecaea4c9ddd6a113e2b" translate="yes" xml:space="preserve">
          <source>There are two functions for which the compiler gives same name in JavaScript, you can mark one with &lt;code&gt;@JsName(...)&lt;/code&gt; to prevent the compiler from reporting error.</source>
          <target state="translated">编译器在JavaScript中使用两个相同的函数来命名，您可以使用 &lt;code&gt;@JsName(...)&lt;/code&gt; 标记一个，以防止编译器报告错误。</target>
        </trans-unit>
        <trans-unit id="538a207adbe54f7fe71914302d366f642c584d32" translate="yes" xml:space="preserve">
          <source>There are two possible ways to opt-in for unsigned types: with marking your API as experimental too, or without doing that.</source>
          <target state="translated">有两种可能的方式来选择加入无符号类型:将你的API也标记为实验性的,或者不这样做。</target>
        </trans-unit>
        <trans-unit id="8fb334f842c55f58127659b8b13256439fde4f09" translate="yes" xml:space="preserve">
          <source>There are two possible ways to opt-in for unsigned types: with requiring an opt-in for your API, or without doing that.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33427a641bab71be82e1a6d8c670d7484fef5041" translate="yes" xml:space="preserve">
          <source>There are two ways you can create the hierarchical structure:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86b3923915c4ddd4dd399b02f1d436b8dc853f8d" translate="yes" xml:space="preserve">
          <source>There can be different modes of stability depending of how quickly a component is evolving:</source>
          <target state="translated">根据组件的发展速度,可以有不同的稳定模式。</target>
        </trans-unit>
        <trans-unit id="0b3f1a4d9ad65e8f5f359abf2fed82920c3beef2" translate="yes" xml:space="preserve">
          <source>There have been many approaches to solving this problem, including:</source>
          <target state="translated">解决这个问题的方法有很多,包括:</target>
        </trans-unit>
        <trans-unit id="c4dc29b34f77a8368125ef8d384ca8b6bfbe8472" translate="yes" xml:space="preserve">
          <source>There is a &lt;code&gt;kotlin.root.example.Clazz&lt;/code&gt; field that represents the &lt;code&gt;Clazz&lt;/code&gt; from Kotlin. The &lt;code&gt;Clazz#memberFunction&lt;/code&gt; is accessible with the &lt;code&gt;memberFunction&lt;/code&gt; field. The only difference is that the &lt;code&gt;memberFunction&lt;/code&gt; accepts a &lt;code&gt;this&lt;/code&gt; reference as the first parameter. The C language does not support objects, and this is the reason to pass a &lt;code&gt;this&lt;/code&gt; pointer explicitly.</source>
          <target state="translated">有一个 &lt;code&gt;kotlin.root.example.Clazz&lt;/code&gt; 表示场 &lt;code&gt;Clazz&lt;/code&gt; 从科特林。在 &lt;code&gt;Clazz#memberFunction&lt;/code&gt; 与访问 &lt;code&gt;memberFunction&lt;/code&gt; 领域。唯一的区别是 &lt;code&gt;memberFunction&lt;/code&gt; 接受 &lt;code&gt;this&lt;/code&gt; 引用作为第一个参数。C语言不支持对象，这就是显式传递 &lt;code&gt;this&lt;/code&gt; 指针的原因。</target>
        </trans-unit>
        <trans-unit id="725365acc046d2774e785fd58198ecf73c6aec56" translate="yes" xml:space="preserve">
          <source>There is a better solution. We can use structured concurrency in our code. Instead of launching coroutines in the &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-global-scope/index.html&quot;&gt;GlobalScope&lt;/a&gt;, just like we usually do with threads (threads are always global), we can launch coroutines in the specific scope of the operation we are performing.</source>
          <target state="translated">有更好的解决方案。我们可以在代码中使用结构化并发。像我们通常在线程中一样（线程始终是全局的），而不是在&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-global-scope/index.html&quot;&gt;GlobalScope&lt;/a&gt;中启动协程，我们可以在正在执行的操作的特定范围内启动协程。</target>
        </trans-unit>
        <trans-unit id="f4b1300b6ec8e15e33a7b0dfe89c4e2e11e628f0" translate="yes" xml:space="preserve">
          <source>There is a bunch of new extensions on the String class to convert it to a number without throwing an exception on invalid number: &lt;code&gt;String.toIntOrNull(): Int?&lt;/code&gt;, &lt;code&gt;String.toDoubleOrNull(): Double?&lt;/code&gt; etc.</source>
          <target state="translated">String类上有很多新扩展，可以将其转换为数字，而不会在无效数字上引发异常： &lt;code&gt;String.toIntOrNull(): Int?&lt;/code&gt; ， &lt;code&gt;String.toDoubleOrNull(): Double?&lt;/code&gt; 等等</target>
        </trans-unit>
        <trans-unit id="2d16488afd500f574acdf4a610fe81c8b613729f" translate="yes" xml:space="preserve">
          <source>There is a common misconception that making a variable &lt;code&gt;volatile&lt;/code&gt; solves concurrency problem. Let us try it:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e33e2bb2c0c45c94e894d38130281f13150c4a3" translate="yes" xml:space="preserve">
          <source>There is a constructor in the &lt;code&gt;Clazz&lt;/code&gt; field (aka &lt;code&gt;kotlin.root.example.Clazz.Clazz&lt;/code&gt;), which is the constructor function to create an instance of the &lt;code&gt;Clazz&lt;/code&gt;.</source>
          <target state="translated">有一个在构造函数 &lt;code&gt;Clazz&lt;/code&gt; 字段（又名 &lt;code&gt;kotlin.root.example.Clazz.Clazz&lt;/code&gt; ），这是构造函数来创建的实例 &lt;code&gt;Clazz&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b8e6c9d338e18c01513c4cf42dbec9a1ab61f7aa" translate="yes" xml:space="preserve">
          <source>There is a convenient coroutine builder named &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/produce.html&quot;&gt;produce&lt;/a&gt; that makes it easy to do it right on producer side, and an extension function &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/consume-each.html&quot;&gt;consumeEach&lt;/a&gt;, that replaces a &lt;code&gt;for&lt;/code&gt; loop on the consumer side:</source>
          <target state="translated">有一个名为方便协同程序生成器&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/produce.html&quot;&gt;产生&lt;/a&gt;，可以很容易把事情做对的制片方和扩展功能&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/consume-each.html&quot;&gt;consumeEach&lt;/a&gt;，替换上 &lt;code&gt;for&lt;/code&gt; 消费者一方循环：</target>
        </trans-unit>
        <trans-unit id="2dc05473a597a891dd992cdcf3cb31ec48971266" translate="yes" xml:space="preserve">
          <source>There is a laziness option to &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/async.html&quot;&gt;async&lt;/a&gt; using an optional &lt;code&gt;start&lt;/code&gt; parameter with a value of &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-start/-l-a-z-y.html&quot;&gt;CoroutineStart.LAZY&lt;/a&gt;. It starts coroutine only when its result is needed by some &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-deferred/await.html&quot;&gt;await&lt;/a&gt; or if a &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/start.html&quot;&gt;start&lt;/a&gt; function is invoked. Run the following example:</source>
          <target state="translated">有一个懒惰选项&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/async.html&quot;&gt;异步&lt;/a&gt;使用可选的 &lt;code&gt;start&lt;/code&gt; 参数与值&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-start/-l-a-z-y.html&quot;&gt;CoroutineStart.LAZY&lt;/a&gt;。仅在&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-deferred/await.html&quot;&gt;等待&lt;/a&gt;其结果或调用&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/start.html&quot;&gt;启动&lt;/a&gt;函数时，它才启动协程。运行以下示例：</target>
        </trans-unit>
        <trans-unit id="64fbf3e4d33c3845151425fcbae0bd95c1ac7ffc" translate="yes" xml:space="preserve">
          <source>There is a nice piece of syntactic sugar that lets you do this: &lt;em&gt;extension functions&lt;/em&gt; and &lt;em&gt;extension properties&lt;/em&gt;. They look like regular member functions/properties, but they are defined outside of any class - yet they reference the class name and can use &lt;code&gt;this&lt;/code&gt;. However, they can only use visible members of the class (typically just the public ones). Behind the scenes, they get compiled down to regular functions that take the target instance as a parameter.</source>
          <target state="translated">有一个不错的语法糖可以让您做到这一点：&lt;em&gt;扩展功能&lt;/em&gt;和&lt;em&gt;扩展属性&lt;/em&gt;。它们看起来像常规成员函数/属性，但是它们在任何类之外定义-但是它们引用了类名并且可以使用 &lt;code&gt;this&lt;/code&gt; 。但是，他们只能使用该类的可见成员（通常仅是公共成员）。在幕后，它们被编译为以目标实例为参数的常规函数​​。</target>
        </trans-unit>
        <trans-unit id="56a1a93e9823bbcbe462dd3f2561922740df0cc6" translate="yes" xml:space="preserve">
          <source>There is also &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.sync/with-lock.html&quot;&gt;withLock&lt;/a&gt; extension function that conveniently represents &lt;code&gt;mutex.lock(); try { ... } finally { mutex.unlock() }&lt;/code&gt; pattern:</source>
          <target state="translated">还有一个&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.sync/with-lock.html&quot;&gt;withLock&lt;/a&gt;扩展功能，可以方便地表示 &lt;code&gt;mutex.lock(); try { ... } finally { mutex.unlock() }&lt;/code&gt; 模式：</target>
        </trans-unit>
        <trans-unit id="5482d8805716b35d94ddb1402c557dc6720d3835" translate="yes" xml:space="preserve">
          <source>There is also a pair of functions that take a predicate and search for elements matching it:</source>
          <target state="translated">还有一对函数,取一个谓词并搜索与之匹配的元素。</target>
        </trans-unit>
        <trans-unit id="40c042439b9082c369e4da946808b3cddd767bd9" translate="yes" xml:space="preserve">
          <source>There is an &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/actor.html&quot;&gt;actor&lt;/a&gt; coroutine builder that conveniently combines actor's mailbox channel into its scope to receive messages from and combines the send channel into the resulting job object, so that a single reference to the actor can be carried around as its handle.</source>
          <target state="translated">有一个&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/actor.html&quot;&gt;actor&lt;/a&gt;协程生成器，可以方便地将actor的邮箱通道合并到其作用域中，以从中接收消息，并将send通道合并到结果作业对象中，以便可以随身携带对actor的单个引用作为其句柄。</target>
        </trans-unit>
        <trans-unit id="b44464d4de5fbd249cc21009c9fb2f52893bbcce" translate="yes" xml:space="preserve">
          <source>There is an optimization that removes redundant arrays creation in such cases, which prevents performance degradation. The single-argument form produces warnings in Kotlin 1.2 and is to be dropped in Kotlin 1.3.</source>
          <target state="translated">有一个优化,在这种情况下,可以去除冗余数组的创建,从而防止性能下降。单参数形式在 Kotlin 1.2 中会产生警告,在 Kotlin 1.3 中会被删除。</target>
        </trans-unit>
        <trans-unit id="6a4b4c7df274b19d3bf5dccee93fd3962d578245" translate="yes" xml:space="preserve">
          <source>There is an option to publish variants grouped by the product flavor, so that the outputs of the different build types are placed in a single module, with the build type becoming a classifier for the artifacts (the release build type is still published with no classifier). This mode is disabled by default and can be enabled as follows:</source>
          <target state="translated">有一个选项可以按产品风味分组发布变体,这样不同构建类型的输出就会被放置在一个模块中,构建类型就会成为工件的分类器(发布的构建类型仍然是没有分类器的)。该模式默认是禁用的,可以按以下方式启用。</target>
        </trans-unit>
        <trans-unit id="6a3b908fffabfbd0bb64797382bd07626137ec3f" translate="yes" xml:space="preserve">
          <source>There is common misconception that making a variable &lt;code&gt;volatile&lt;/code&gt; solves concurrency problem. Let us try it:</source>
          <target state="translated">常见的误解是，使变量 &lt;code&gt;volatile&lt;/code&gt; 可解决并发问题。让我们尝试一下：</target>
        </trans-unit>
        <trans-unit id="5eb09ee69535cf6dda53683554e0ee16259161ba" translate="yes" xml:space="preserve">
          <source>There is no dedicated type in C language for strings. A developer knows from a method signature or the documentation, whether a given &lt;code&gt;char *&lt;/code&gt; means a C string in the context. Strings in the C language are null-terminated, a trailing zero character &lt;code&gt;\0&lt;/code&gt; is added at the end of a bytes sequence to mark a string termination. Usually, &lt;a href=&quot;https://en.wikipedia.org/wiki/UTF-8&quot;&gt;UTF-8 encoded strings&lt;/a&gt; are used. The UTF-8 encoding uses variable width characters, and it is backward compatible with &lt;a href=&quot;https://en.wikipedia.org/wiki/ASCII&quot;&gt;ASCII&lt;/a&gt;. Kotlin/Native uses UTF-8 character encoding by default.</source>
          <target state="translated">C语言中没有用于字符串的专用类型。开发人员从方法签名或文档中知道，给定的 &lt;code&gt;char *&lt;/code&gt; 在上下文中是否表示C字符串。 C语言中的字符串以空字符结尾，在字节序列的末尾添加一个结尾的零字符 &lt;code&gt;\0&lt;/code&gt; ，以标记字符串的结尾。通常，使用&lt;a href=&quot;https://en.wikipedia.org/wiki/UTF-8&quot;&gt;UTF-8编码的字符串&lt;/a&gt;。 UTF-8编码使用可变宽度的字符，并且与&lt;a href=&quot;https://en.wikipedia.org/wiki/ASCII&quot;&gt;ASCII&lt;/a&gt;向后兼容。 Kotlin / Native默认使用UTF-8字符编码。</target>
        </trans-unit>
        <trans-unit id="50408f344ff56fd13407ed98b66fe0baaa2ef0c5" translate="yes" xml:space="preserve">
          <source>There is no longer an exception when running this code:</source>
          <target state="translated">运行这段代码时,不再有异常。</target>
        </trans-unit>
        <trans-unit id="edef4e6315a2b596a0ca3836f2b3be1feee84974" translate="yes" xml:space="preserve">
          <source>There is no meaning attached to values in this class, it can be used for any purpose. Pair exhibits value semantics, i.e. two pairs are equal if both components are equal.</source>
          <target state="translated">在这个类中,值没有附加的意义,它可以用于任何目的。Pair表现出值的语义,即如果两个成分都相等,那么两个对就相等。</target>
        </trans-unit>
        <trans-unit id="0049a565ebb0e6780625b95d2507e4c5901c80a7" translate="yes" xml:space="preserve">
          <source>There is no meaning attached to values in this class, it can be used for any purpose. Triple exhibits value semantics, i.e. two triples are equal if all three components are equal. An example of decomposing it into values:</source>
          <target state="translated">在这个类中,值没有附加任何意义,它可以用于任何目的。三元组表现出值的语义,即如果三个成分都相等,则两个三元组就相等。将其分解为值的一个例子。</target>
        </trans-unit>
        <trans-unit id="1dd7b0fcce3d3026dd4903ea1dcae2ace7aba63b" translate="yes" xml:space="preserve">
          <source>There is no namespaces support in C, so the Kotlin/Native compiler generates long names to avoid any possible clashes with other symbols in the existing native project.</source>
          <target state="translated">C语言中不支持命名空间,所以Kotlin/Native编译器会生成长名,以避免与现有本地项目中的其他符号发生任何可能的冲突。</target>
        </trans-unit>
        <trans-unit id="9fc7acf9c721c77f449446dbc8b3636586ef2efc" translate="yes" xml:space="preserve">
          <source>There is no need to consider compatibility for new interfaces, as no clients have used them before. You can minimize the compatibility overhead by excluding these interfaces from the compatibility mode. To do this, annotate them with the &lt;code&gt;@JvmDefaultWithoutCompatibility&lt;/code&gt; annotation. Such interfaces compile the same way as with &lt;code&gt;-Xjvm-default=all&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8859e68bee06f71aa7ff22831dc050e526d2f13b" translate="yes" xml:space="preserve">
          <source>There is no need to handle the case of misformatted input in competitive programming. In competitive programming, an input format is always precisely specified and the actual input cannot deviate from the input specification in the problem statement. That's what the null-assertion operator &lt;code&gt;!!&lt;/code&gt; essentially does &amp;mdash; it asserts that the input string is present and throws an exception otherwise. Likewise, the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.text/to-int&quot;&gt;String.toInt()&lt;/a&gt; function throws an exception if the input string is not an integer.</source>
          <target state="translated">在竞争性编程中，无需处理格式错误的输入。在竞争性编程中，始终精确指定输入格式，并且实际输入不能偏离问题说明中的输入规范。这就是null断言运算符 &lt;code&gt;!!&lt;/code&gt; 本质上是这样做的-它断言输入字符串存在，否则抛出异常。同样，如果输入字符串不是整数，则&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.text/to-int&quot;&gt;String.toInt（）&lt;/a&gt;函数将引发异常。</target>
        </trans-unit>
        <trans-unit id="c6d0ebaf0b7e6376420eb9484810949b156e1e12" translate="yes" xml:space="preserve">
          <source>There is no such syntax in Kotlin. However, in Kotlin we have &lt;a href=&quot;object-declarations#companion-objects&quot;&gt;&lt;code&gt;companion&lt;/code&gt;&lt;/a&gt; objects. Kotlin treats companion objects of &lt;code&gt;external&lt;/code&gt; classes in a special way: instead of expecting an object, it assumes members of companion objects to be members of the class itself. &lt;code&gt;MyClass&lt;/code&gt; from the example above can be described as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e914e64115449100ebfd64599edfd2968cff02a7" translate="yes" xml:space="preserve">
          <source>There is now a large number of &lt;a href=&quot;building-mpp-with-gradle#supported-platforms&quot;&gt;preset platform configurations&lt;/a&gt; for different supported platforms.</source>
          <target state="translated">现在，存在针对不同支持平台的大量&lt;a href=&quot;building-mpp-with-gradle#supported-platforms&quot;&gt;预设平台配置&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5c9261e9c8424c9800b6b0327e8368a8f20c36c1" translate="yes" xml:space="preserve">
          <source>There is now a large number of &lt;a href=&quot;mpp-supported-platforms&quot;&gt;preset platform configurations&lt;/a&gt; for different supported platforms.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b648b3a77b4b2e5fa4527e728e2d5fe0ae2a410" translate="yes" xml:space="preserve">
          <source>There is one important semantic difference between object expressions and object declarations:</source>
          <target state="translated">对象表达式和对象声明之间有一个重要的语义区别。</target>
        </trans-unit>
        <trans-unit id="8fd6b73de53838cea1717936197f551e12e9d247" translate="yes" xml:space="preserve">
          <source>There is one more way to search elements in lists &amp;ndash; &lt;a href=&quot;https://en.wikipedia.org/wiki/Binary_search_algorithm&quot;&gt;binary search&lt;/a&gt;. It works significantly faster than other built-in search functions but &lt;em&gt;requires the list to be &lt;a href=&quot;collection-ordering&quot;&gt;sorted&lt;/a&gt;&lt;/em&gt; in ascending order according to a certain ordering: natural or another one provided in the function parameter. Otherwise, the result is undefined.</source>
          <target state="translated">搜索列表中元素的另一种方法是&lt;a href=&quot;https://en.wikipedia.org/wiki/Binary_search_algorithm&quot;&gt;二进制搜索&lt;/a&gt;。它的工作速度明显快于其他内置搜索功能，但&lt;em&gt;要求列表&lt;a href=&quot;collection-ordering&quot;&gt;&lt;/a&gt;&lt;/em&gt;按照某种顺序（自然或功能参数中提供的另一个&lt;em&gt;顺序）&lt;/em&gt;以升序排序。否则，结果是不确定的。</target>
        </trans-unit>
        <trans-unit id="c4497244354ad07743aea06bad3f15a18c72b5c2" translate="yes" xml:space="preserve">
          <source>There is still something to be desired for practical usage of coroutines. When we use &lt;code&gt;GlobalScope.launch&lt;/code&gt;, we create a top-level coroutine. Even though it is light-weight, it still consumes some memory resources while it runs. If we forget to keep a reference to the newly launched coroutine it still runs. What if the code in the coroutine hangs (for example, we erroneously delay for too long), what if we launched too many coroutines and ran out of memory? Having to manually keep references to all the launched coroutines and &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/join.html&quot;&gt;join&lt;/a&gt; them is error-prone.</source>
          <target state="translated">协程的实际使用仍需要一些东西。当使用 &lt;code&gt;GlobalScope.launch&lt;/code&gt; 时，我们将创建一个顶级协程。即使它很轻巧，它在运行时仍会消耗一些内存资源。如果我们忘记保留对新发布的协程的引用，它将继续运行。如果协程中的代码挂起（例如，我们错误地延迟了太长时间），怎么办？如果启动太多协程并用完了内存怎么办？必须手动保留对所有已启动协程的引用并&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/join.html&quot;&gt;加入&lt;/a&gt;它们是容易出错的。</target>
        </trans-unit>
        <trans-unit id="c2958b4b7d6ee3fe23d0044dbf293010b99dd8e5" translate="yes" xml:space="preserve">
          <source>There is still something to be desired for practical usage of coroutines. When we use &lt;code&gt;GlobalScope.launch&lt;/code&gt;, we create a top-level coroutine. Even though it is light-weight, it still consumes some memory resources while it runs. If we forget to keep a reference to the newly launched coroutine, it still runs. What if the code in the coroutine hangs (for example, we erroneously delay for too long), what if we launched too many coroutines and ran out of memory? Having to manually keep references to all the launched coroutines and &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/join.html&quot;&gt;join&lt;/a&gt; them is error-prone.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01079d64cb67e3f5b3eb1ab0a3228010e68dcdd0" translate="yes" xml:space="preserve">
          <source>There may be times when you need to quickly write and execute code outside of a project or application. This may be useful, for example, when learning Kotlin or evaluating expressions. Let's have a look at three handy ways we can use to run Kotlin code quickly:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98631247ce5d35bfa57c2de9453651ac4adc252b" translate="yes" xml:space="preserve">
          <source>There may be zero or more &lt;em&gt;catch&lt;/em&gt; blocks. &lt;em&gt;finally&lt;/em&gt; block may be omitted. However at least one &lt;em&gt;catch&lt;/em&gt; or &lt;em&gt;finally&lt;/em&gt; block should be present.</source>
          <target state="translated">可能有零个或多个&lt;em&gt;捕获&lt;/em&gt;块。&lt;em&gt;最终&lt;/em&gt;块可以省略。但是，至少应有一个&lt;em&gt;抓钩&lt;/em&gt;或&lt;em&gt;最后&lt;/em&gt;一个挡块。</target>
        </trans-unit>
        <trans-unit id="f116d6d19440fd947335171cc03cdab27f6adc4e" translate="yes" xml:space="preserve">
          <source>There will be a property named &lt;code&gt;hello&lt;/code&gt;:</source>
          <target state="translated">将有一个名为 &lt;code&gt;hello&lt;/code&gt; 的属性：</target>
        </trans-unit>
        <trans-unit id="def4b70b1b61bdf7178a471139f991f3029fb44c" translate="yes" xml:space="preserve">
          <source>There will only ever be one instance of this class, and the instance (which is created the first time it is accessed, in a thread-safe manner) has got the same name as the class:</source>
          <target state="translated">这个类永远只有一个实例,而且这个实例(在第一次访问时以线程安全的方式创建)的名字与这个类相同。</target>
        </trans-unit>
        <trans-unit id="6f9f7587a2e090ad5e29fbff32347947646d8531" translate="yes" xml:space="preserve">
          <source>There's a little bit of runtime overhead associated with lambda functions: they are really objects, so they must be instantiated, and (like other functions) calling them takes a little bit of time too. If we use the &lt;code&gt;inline&lt;/code&gt; keyword on a function, we tell the compiler to &lt;em&gt;inline&lt;/em&gt; both the function and its lambda parameters (if any) - that is, the compiler will copy the code of the function (and its lambda parameters) into &lt;em&gt;every&lt;/em&gt; callsite, thus eliminating the overhead of both the lambda instantiation and the calling of the function and the lambdas. This will happen unconditionally, unlike in C and C++, where &lt;code&gt;inline&lt;/code&gt; is more of a hint to the compiler. This will cause the size of the compiled code to grow, but it may be worth it for certain small but frequently-called functions.</source>
          <target state="translated">Lambda函数有一些运行时开销：它们实际上是对象，因此必须实例化它们，并且（与其他函数一样）调用它们也需要一点时间。如果我们在函数上使用 &lt;code&gt;inline&lt;/code&gt; 关键字，则会告诉编译器&lt;em&gt;内联&lt;/em&gt;函数和其lambda参数（如果有）-也就是说，编译器会将函数的代码（及其lambda参数）复制到&lt;em&gt;每个&lt;/em&gt;调用站点中，这样就消除了lambda实例化以及函数和lambda调用的开销。这将无条件发生，这与C和C ++中的 &lt;code&gt;inline&lt;/code&gt; 对编译器来说更多的是提示。这将导致已编译代码的大小增加，但是对于某些较小但经常调用的函数可能值得这样做。</target>
        </trans-unit>
        <trans-unit id="1db5770d8b83e30706aed362d9428bb0d8466fab" translate="yes" xml:space="preserve">
          <source>There's a vast collection of functional programming-style operations available in the &lt;a href=&quot;../../../api/latest/jvm/stdlib/kotlin.collections/index&quot;&gt;&lt;code&gt;kotlin.collections&lt;/code&gt; package&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../../../api/latest/jvm/stdlib/kotlin.collections/index&quot;&gt; &lt;code&gt;kotlin.collections&lt;/code&gt; 包中&lt;/a&gt;提供了大量功能编程风格的操作。</target>
        </trans-unit>
        <trans-unit id="202786b020b9056a1534a505736791f80248ba7e" translate="yes" xml:space="preserve">
          <source>There's no 64 bit integer number in JavaScript, so &lt;code&gt;kotlin.Long&lt;/code&gt; is not mapped to any JavaScript object, it's emulated by a Kotlin class.</source>
          <target state="translated">JavaScript中没有64位整数，因此 &lt;code&gt;kotlin.Long&lt;/code&gt; 不会映射到任何JavaScript对象，而是由Kotlin类模拟的。</target>
        </trans-unit>
        <trans-unit id="9178e1d163a2f07f63e80e90e8b72e40666cb6be" translate="yes" xml:space="preserve">
          <source>There's no such syntax in Kotlin. However, in Kotlin we have &lt;code&gt;companion&lt;/code&gt; objects. Kotlin treats companion objects of &lt;code&gt;external&lt;/code&gt; class in a special way: instead of expecting an object, it assumes members of companion objects to be members of the class itself. To describe &lt;code&gt;MyClass&lt;/code&gt; from the example above, you can write:</source>
          <target state="translated">Kotlin中没有这样的语法。但是，在Kotlin中，我们有 &lt;code&gt;companion&lt;/code&gt; 对象。Kotlin 以一种特殊的方式对待 &lt;code&gt;external&lt;/code&gt; 类的同伴对象：与其期望一个对象，不如假设一个同伴对象的成员是该类本身的成员。为了从上面的示例描述 &lt;code&gt;MyClass&lt;/code&gt; ，您可以编写：</target>
        </trans-unit>
        <trans-unit id="918d499d192390404b8163b61ae9ad18a046a4a8" translate="yes" xml:space="preserve">
          <source>There's two forms of using &lt;code&gt;definedExternally&lt;/code&gt;:</source>
          <target state="translated">有两种使用 &lt;code&gt;definedExternally&lt;/code&gt; 的形式：</target>
        </trans-unit>
        <trans-unit id="1d27760789bc7d15f7cae3944fffbd1ed1e60b2e" translate="yes" xml:space="preserve">
          <source>Therefore if the &lt;a href=&quot;write#kotlin.concurrent%24write%28java.util.concurrent.locks.ReentrantReadWriteLock%2C+kotlin.Function0%28%28kotlin.concurrent.write.T%29%29%29%2Faction&quot;&gt;action&lt;/a&gt; inside write lock has been initiated by checking some condition, the condition must be rechecked inside the &lt;a href=&quot;write#kotlin.concurrent%24write%28java.util.concurrent.locks.ReentrantReadWriteLock%2C+kotlin.Function0%28%28kotlin.concurrent.write.T%29%29%29%2Faction&quot;&gt;action&lt;/a&gt; to avoid possible races.</source>
          <target state="translated">因此，如果&lt;a href=&quot;write#kotlin.concurrent%24write%28java.util.concurrent.locks.ReentrantReadWriteLock%2C+kotlin.Function0%28%28kotlin.concurrent.write.T%29%29%29%2Faction&quot;&gt;动作&lt;/a&gt;写锁内已通过检查一些条件启动，条件必须在内部重新检查&lt;a href=&quot;write#kotlin.concurrent%24write%28java.util.concurrent.locks.ReentrantReadWriteLock%2C+kotlin.Function0%28%28kotlin.concurrent.write.T%29%29%29%2Faction&quot;&gt;行动&lt;/a&gt;，以避免可能的比赛。</target>
        </trans-unit>
        <trans-unit id="e58964a321357f25142def10569f3d0cf1f1691d" translate="yes" xml:space="preserve">
          <source>Therefore if the &lt;a href=&quot;write#kotlin.concurrent%24write(java.util.concurrent.locks.ReentrantReadWriteLock,%20kotlin.Function0((kotlin.concurrent.write.T)))/action&quot;&gt;action&lt;/a&gt; inside write lock has been initiated by checking some condition, the condition must be rechecked inside the &lt;a href=&quot;write#kotlin.concurrent%24write(java.util.concurrent.locks.ReentrantReadWriteLock,%20kotlin.Function0((kotlin.concurrent.write.T)))/action&quot;&gt;action&lt;/a&gt; to avoid possible races.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f17bb5adc41c5c7eefa8d167c2c05552954588a" translate="yes" xml:space="preserve">
          <source>Therefore, the two following snippets are equivalent:</source>
          <target state="translated">因此,以下两个片段是等价的。</target>
        </trans-unit>
        <trans-unit id="b2fcfe97b28b6d55545bf13f39eacf58d2cbb997" translate="yes" xml:space="preserve">
          <source>Therefore, there is no general way to check whether an instance of a generic type was created with certain type arguments at runtime, and the compiler &lt;a href=&quot;typecasts#type-erasure-and-generic-type-checks&quot;&gt;prohibits such &lt;em&gt;is&lt;/em&gt;-checks&lt;/a&gt;.</source>
          <target state="translated">因此，没有通用的方法来检查在运行时是否使用某些类型参数创建了泛型类型的实例，并且编译器&lt;a href=&quot;typecasts#type-erasure-and-generic-type-checks&quot;&gt;禁止使用&lt;em&gt;is&lt;/em&gt; -checks&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ba4578c0908f499a877e6e75a3e1e8fb6ca14fec" translate="yes" xml:space="preserve">
          <source>These &lt;a href=&quot;typecasts#unchecked-casts&quot;&gt;unchecked casts&lt;/a&gt; can be used when type safety is implied by the high-level program logic but cannot be inferred directly by the compiler. The compiler issues a warning on unchecked casts, and at runtime, only the non-generic part is checked (equivalent to &lt;code&gt;foo as List&amp;lt;*&amp;gt;&lt;/code&gt;).</source>
          <target state="translated">当高级程序逻辑隐含类型安全性但编译器无法直接推断出类型安全性时，可以使用这些&lt;a href=&quot;typecasts#unchecked-casts&quot;&gt;未经检查的强制转换&lt;/a&gt;。编译器会在未检查的强制转换上发出警告，并且在运行时仅检查非通用部分（相当于 &lt;code&gt;foo as List&amp;lt;*&amp;gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="dd3d3ea77431105543bdd1015eeb929086add1c8" translate="yes" xml:space="preserve">
          <source>These abstract classes can be used as base classes when implementing Kotlin collection classes. For implementing read-only collections there are &lt;code&gt;AbstractCollection&lt;/code&gt;, &lt;code&gt;AbstractList&lt;/code&gt;, &lt;code&gt;AbstractSet&lt;/code&gt; and &lt;code&gt;AbstractMap&lt;/code&gt;, and for mutable collections there are &lt;code&gt;AbstractMutableCollection&lt;/code&gt;, &lt;code&gt;AbstractMutableList&lt;/code&gt;, &lt;code&gt;AbstractMutableSet&lt;/code&gt; and &lt;code&gt;AbstractMutableMap&lt;/code&gt;. On JVM these abstract mutable collections inherit most of their functionality from JDK's abstract collections.</source>
          <target state="translated">在实现Kotlin集合类时，可以将这些抽象类用作基类。为了实现只读集合，有 &lt;code&gt;AbstractCollection&lt;/code&gt; ， &lt;code&gt;AbstractList&lt;/code&gt; ， &lt;code&gt;AbstractSet&lt;/code&gt; 和 &lt;code&gt;AbstractMap&lt;/code&gt; ；对于可变集合，有 &lt;code&gt;AbstractMutableCollection&lt;/code&gt; ， &lt;code&gt;AbstractMutableList&lt;/code&gt; ， &lt;code&gt;AbstractMutableSet&lt;/code&gt; 和 &lt;code&gt;AbstractMutableMap&lt;/code&gt; 。在JVM上，这些抽象可变集合从JDK的抽象集合继承了大多数功能。</target>
        </trans-unit>
        <trans-unit id="aae55c4083a74f1ac27e26d5124083a7a6b3b4cb" translate="yes" xml:space="preserve">
          <source>These are the &lt;a href=&quot;#default-project-layout&quot;&gt;default source set names&lt;/a&gt; for the production and test sources for the targets configured above. The source sets &lt;code&gt;commonMain&lt;/code&gt; and &lt;code&gt;commonTest&lt;/code&gt; are included into production and test compilations, respectively, of all targets. Note that the dependencies for common source sets &lt;code&gt;commonMain&lt;/code&gt; and &lt;code&gt;commonTest&lt;/code&gt; are the common artifacts, and the platform libraries go to the source sets of the specific targets.</source>
          <target state="translated">这些是上面配置的目标的生产和测试源的&lt;a href=&quot;#default-project-layout&quot;&gt;默认源集名称&lt;/a&gt;。源集 &lt;code&gt;commonMain&lt;/code&gt; 和 &lt;code&gt;commonTest&lt;/code&gt; 分别包含在所有目标的生产和测试编译中。请注意，公共源集 &lt;code&gt;commonMain&lt;/code&gt; 和 &lt;code&gt;commonTest&lt;/code&gt; 的依赖项是公共工件，平台库转到特定目标的源集。</target>
        </trans-unit>
        <trans-unit id="6c67dd2d501b6f7860e7b47d523d2ae61bab43e4" translate="yes" xml:space="preserve">
          <source>These are three general-purpose extension functions applicable to any receiver.</source>
          <target state="translated">这是三个适用于任何接收器的通用扩展功能。</target>
        </trans-unit>
        <trans-unit id="a31b00eaf51e9ded931a5bcf77718ad763afbdf7" translate="yes" xml:space="preserve">
          <source>These changes are relevant only for projects with the hierarchical project structure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b13209452f2b9faee7dc51d424f004345829a7e" translate="yes" xml:space="preserve">
          <source>These compilers are used by the IDE when you click the &lt;strong&gt;Compile&lt;/strong&gt; or &lt;strong&gt;Run&lt;/strong&gt; button for your Kotlin project.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a99a063b2c797ffc59fde5538599b9e6760c083" translate="yes" xml:space="preserve">
          <source>These considerations lead to the following rules. A covariant type parameter &lt;code&gt;T&lt;/code&gt; (which the user of an object might think is &lt;code&gt;Fruit&lt;/code&gt;, while the object in reality is tied to &lt;code&gt;Apple&lt;/code&gt;) may be used as:</source>
          <target state="translated">这些考虑导致以下规则。协变类型参数 &lt;code&gt;T&lt;/code&gt; （对象的用户可能认为它是 &lt;code&gt;Fruit&lt;/code&gt; ，而实际上该对象与 &lt;code&gt;Apple&lt;/code&gt; 绑定）可以用作：</target>
        </trans-unit>
        <trans-unit id="e8a12f370f83960d4f7413fab1b904c1e1f23ab2" translate="yes" xml:space="preserve">
          <source>These declarations look clear. All &lt;code&gt;char *&lt;/code&gt; pointers are turned into &lt;code&gt;str: CValuesRef&amp;lt;ByteVar&amp;gt;?&lt;/code&gt; for parameters and to &lt;code&gt;CPointer&amp;lt;ByteVar&amp;gt;?&lt;/code&gt; in return types. Kotlin turns &lt;code&gt;char&lt;/code&gt; type into &lt;code&gt;kotlin.Byte&lt;/code&gt; type, as it is usually an 8-bit signed value.</source>
          <target state="translated">这些声明看起来很清楚。所有 &lt;code&gt;char *&lt;/code&gt; 指针都转换为 &lt;code&gt;str: CValuesRef&amp;lt;ByteVar&amp;gt;?&lt;/code&gt; 参数和 &lt;code&gt;CPointer&amp;lt;ByteVar&amp;gt;?&lt;/code&gt; 返回类型。Kotlin将 &lt;code&gt;char&lt;/code&gt; 类型转换为 &lt;code&gt;kotlin.Byte&lt;/code&gt; 类型，因为它通常是一个8位带符号的值。</target>
        </trans-unit>
        <trans-unit id="53e4257de1ac9420719572d5eaf311fafd22b5c2" translate="yes" xml:space="preserve">
          <source>These features are not considered production ready yet, so you need to turn on the &lt;em&gt;experimental mode&lt;/em&gt; in &lt;code&gt;build.gradle&lt;/code&gt; in order to use them:</source>
          <target state="translated">这些功能尚未被考虑用于生产环境，因此您需要在 &lt;code&gt;build.gradle&lt;/code&gt; 中打开&lt;em&gt;实验模式&lt;/em&gt;才能使用它们：</target>
        </trans-unit>
        <trans-unit id="e6b05d8f5b89932c0c2ddc8328889d3567a05266" translate="yes" xml:space="preserve">
          <source>These functions can also be used for converting collections to other types, for example, build a set from a list or vice versa.</source>
          <target state="translated">这些函数也可以用于将集合转换为其他类型,例如,从列表中建立一个集合或反之。</target>
        </trans-unit>
        <trans-unit id="d5e9c8cae28543e16ef49eb2054cfc4937ef3fcf" translate="yes" xml:space="preserve">
          <source>These functions can be used for easy copying of maps:</source>
          <target state="translated">这些功能可以用来方便复制地图。</target>
        </trans-unit>
        <trans-unit id="2a7f12885b59bbc14ccabadd6389a34cf6ff8eb2" translate="yes" xml:space="preserve">
          <source>These functions can be used to find the lowest and greatest of two or three given values, where values are primitive numbers or &lt;code&gt;Comparable&lt;/code&gt; objects. There is also an overload of each function that take an additional &lt;code&gt;Comparator&lt;/code&gt; instance, if you want to compare objects that are not comparable themselves.</source>
          <target state="translated">这些函数可用于查找两个或三个给定值中的最小和最大值，其中值是原始数或 &lt;code&gt;Comparable&lt;/code&gt; 对象。如果您要比较本身不具有可比性的对象，则每个函数还有一个额外的 &lt;code&gt;Comparator&lt;/code&gt; 实例会重载。</target>
        </trans-unit>
        <trans-unit id="8f7f5c9e85694705edbe3da3b621cafe8f2795f3" translate="yes" xml:space="preserve">
          <source>These functions deal with Kotlin/Native objects. Call the &lt;code&gt;DisposeStablePointer&lt;/code&gt; to release a Kotlin object and &lt;code&gt;DisposeString&lt;/code&gt; to release a Kotlin String, which has the &lt;code&gt;char*&lt;/code&gt; type in C. It is possible to use the &lt;code&gt;IsInstance&lt;/code&gt; function to check if a Kotlin type or a &lt;code&gt;libnative_KNativePtr&lt;/code&gt; is an instance of another type. The actual set of operations generated depends on the actual usages.</source>
          <target state="translated">这些功能处理Kotlin / Native对象。调用 &lt;code&gt;DisposeStablePointer&lt;/code&gt; 释放科特林对象和 &lt;code&gt;DisposeString&lt;/code&gt; 释放科特林字符串，其具有 &lt;code&gt;char*&lt;/code&gt; 类型C.它是能够使用 &lt;code&gt;IsInstance&lt;/code&gt; 函数来检查科特林型或 &lt;code&gt;libnative_KNativePtr&lt;/code&gt; 是另一种类型的一个实例。生成的实际操作集取决于实际用法。</target>
        </trans-unit>
        <trans-unit id="ebcfd0ed6c7e90830065d9ee1e014161378d5e50" translate="yes" xml:space="preserve">
          <source>These include &lt;a href=&quot;reflection#bound-function-and-property-references-since-11&quot;&gt;bound callable references&lt;/a&gt; that point to a member of a particular instance: &lt;code&gt;foo::toString&lt;/code&gt;.</source>
          <target state="translated">这些包括指向特定实例成员的&lt;a href=&quot;reflection#bound-function-and-property-references-since-11&quot;&gt;绑定可调用引用&lt;/a&gt;： &lt;code&gt;foo::toString&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="341a2ef673574a4668acee83662de92778d835b1" translate="yes" xml:space="preserve">
          <source>These operators only work with the function &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin/-any/equals&quot;&gt;&lt;code&gt;equals(other: Any?): Boolean&lt;/code&gt;&lt;/a&gt;, which can be overridden to provide custom equality check implementation. Any other function with the same name (like &lt;code&gt;equals(other: Foo)&lt;/code&gt;) will not be called.</source>
          <target state="translated">这些运算符仅与&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin/-any/equals&quot;&gt; &lt;code&gt;equals(other: Any?): Boolean&lt;/code&gt; &lt;/a&gt;函数一起使用，可以重写以提供自定义相等性检查实现。具有相同名称的任何其他函数（例如 &lt;code&gt;equals(other: Foo)&lt;/code&gt; ）都不会被调用。</target>
        </trans-unit>
        <trans-unit id="04c64c9fdc4ddbb026d14664db7dfcf575773eab" translate="yes" xml:space="preserve">
          <source>These options have nearly the same effect as clang's &lt;code&gt;-fembed-bitcode&lt;/code&gt;/&lt;code&gt;-fembed-bitcode-marker&lt;/code&gt; and swiftc's &lt;code&gt;-embed-bitcode&lt;/code&gt;/&lt;code&gt;-embed-bitcode-marker&lt;/code&gt;.</source>
          <target state="translated">这些选项与clang的 &lt;code&gt;-fembed-bitcode&lt;/code&gt; / &lt;code&gt;-fembed-bitcode-marker&lt;/code&gt; 和swiftc的 &lt;code&gt;-embed-bitcode&lt;/code&gt; / &lt;code&gt;-embed-bitcode-marker&lt;/code&gt; 具有几乎相同的效果。</target>
        </trans-unit>
        <trans-unit id="42a0b78cb4e25be9e1f6ef7cf3d39eb3e781050e" translate="yes" xml:space="preserve">
          <source>These tasks are defined in the &lt;em&gt;kotlin-ant.jar&lt;/em&gt; library which is located in the &lt;em&gt;lib&lt;/em&gt; folder for the &lt;a href=&quot;https://github.com/JetBrains/kotlin/releases/tag/v1.3.41&quot;&gt;Kotlin Compiler&lt;/a&gt; Ant version 1.8.2+ is required.</source>
          <target state="translated">这些任务在&lt;em&gt;kotlin-ant.jar&lt;/em&gt;库中定义，该库位于&lt;a href=&quot;https://github.com/JetBrains/kotlin/releases/tag/v1.3.41&quot;&gt;Kotlin Compiler&lt;/a&gt; Ant版本1.8.2+ 的&lt;em&gt;lib&lt;/em&gt;文件夹中。</target>
        </trans-unit>
        <trans-unit id="35fb8f738b23790388f177e5975164208ed39249" translate="yes" xml:space="preserve">
          <source>These tasks are defined in the &lt;em&gt;kotlin-ant.jar&lt;/em&gt; library which is located in the &lt;em&gt;lib&lt;/em&gt; folder for the &lt;a href=&quot;https://github.com/JetBrains/kotlin/releases/tag/v1.4.10&quot;&gt;Kotlin Compiler&lt;/a&gt; Ant version 1.8.2+ is required.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d0ae43a71338a23e33d7f8aec6b35c87860e63a" translate="yes" xml:space="preserve">
          <source>These transformations can also be applied to &lt;code&gt;Sequence&amp;lt;T&amp;gt;&lt;/code&gt;, which is similar to Python's generators and allows for lazy evaluation. If you have a huge list and you want to process it lazily, you can call &lt;code&gt;asSequence()&lt;/code&gt; on it.</source>
          <target state="translated">这些转换也可以应用于 &lt;code&gt;Sequence&amp;lt;T&amp;gt;&lt;/code&gt; ，它类似于Python的生成器，并允许进行惰性求值。如果您有一个庞大的列表，并且想要懒惰地处理它，则可以在其上调用 &lt;code&gt;asSequence()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="03f364964cb20dc479a4f5003a2a44d235abdb7a" translate="yes" xml:space="preserve">
          <source>These two functions can not be defined side-by-side, because their JVM signatures are the same: &lt;code&gt;filterValid(Ljava/util/List;)Ljava/util/List;&lt;/code&gt;. If we really want them to have the same name in Kotlin, we can annotate one (or both) of them with &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.jvm/-jvm-name/index&quot;&gt;&lt;code&gt;@JvmName&lt;/code&gt;&lt;/a&gt; and specify a different name as an argument:</source>
          <target state="translated">这两个函数不能并排定义，因为它们的JVM签名是相同的： &lt;code&gt;filterValid(Ljava/util/List;)Ljava/util/List;&lt;/code&gt; 。如果我们确实希望它们在Kotlin中具有相同的名称，则可以使用&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.jvm/-jvm-name/index&quot;&gt; &lt;code&gt;@JvmName&lt;/code&gt; &lt;/a&gt;注释其中一个（或两个），并指定其他名称作为参数：</target>
        </trans-unit>
        <trans-unit id="921fb3d0fcc9e0673ab266d259447beb1dbfed2e" translate="yes" xml:space="preserve">
          <source>These two options let you choose the proper function depending on what you do next in your code.</source>
          <target state="translated">这两个选项可以让你根据你接下来在代码中的操作选择合适的函数。</target>
        </trans-unit>
        <trans-unit id="5dbdf5173288dba5a705ae6e593e7cbdf4691ea2" translate="yes" xml:space="preserve">
          <source>These types are used to map boxed Kotlin number types into Objective-C and Swift. In Swift, we may simply call the constructor to create an instance, e.g. &lt;code&gt;KotlinLong(value: 42)&lt;/code&gt;.</source>
          <target state="translated">这些类型用于将装箱的Kotlin数字类型映射到Objective-C和Swift。在Swift中，我们可以简单地调用构造函数来创建一个实例，例如 &lt;code&gt;KotlinLong(value: 42)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c780ae4d91e6b3d59d657bd21738eface7e6d706" translate="yes" xml:space="preserve">
          <source>These types have a special notation that corresponds to the signatures of the functions, i.e. their parameters and return values:</source>
          <target state="translated">这些类型有一个特殊的符号,对应于函数的签名,即它们的参数和返回值。</target>
        </trans-unit>
        <trans-unit id="49301d7c0ca361c41d110b3bca3a6ef2c53c1486" translate="yes" xml:space="preserve">
          <source>They also can be used in return statements of functions returning the context object.</source>
          <target state="translated">它们也可以用于返回上下文对象的函数的返回语句中。</target>
        </trans-unit>
        <trans-unit id="6e6ad519d848a011249fae6e51a09e8caed4ec20" translate="yes" xml:space="preserve">
          <source>They can't be passed as reified type arguments.</source>
          <target state="translated">它们不能作为重构类型参数传递。</target>
        </trans-unit>
        <trans-unit id="9f968b20031a0c4e81acc38a3f23bdedaba5b962" translate="yes" xml:space="preserve">
          <source>They can't be used in class literal expressions (i.e. &lt;code&gt;I::class&lt;/code&gt;).</source>
          <target state="translated">它们不能用于类文字表达式（即 &lt;code&gt;I::class&lt;/code&gt; ）中。</target>
        </trans-unit>
        <trans-unit id="31bcc86b1bb409efa1776fef24979f29b2bad523" translate="yes" xml:space="preserve">
          <source>They can't be used in class literal expressions (such as &lt;code&gt;I::class&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f0701452411de1234771e67765d254ade0b6df7" translate="yes" xml:space="preserve">
          <source>They can't be used on the right hand side of &lt;code&gt;is&lt;/code&gt; checks.</source>
          <target state="translated">它们不能在 &lt;code&gt;is&lt;/code&gt; 支票的右侧使用。</target>
        </trans-unit>
        <trans-unit id="a244b209eab02673f1fb27177884b364b4d4031d" translate="yes" xml:space="preserve">
          <source>They can't be used on the right-hand side of &lt;code&gt;is&lt;/code&gt; checks.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1d1a7c20f6efa1c87f68abf4cdd98085a534c8a" translate="yes" xml:space="preserve">
          <source>They include sample projects, which can serve as jumping-off points for your own projects, and contain useful snippets and patterns.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="398723a13324bec77451c1ae01057e1ef7af3705" translate="yes" xml:space="preserve">
          <source>They must be member functions or &lt;a href=&quot;extensions&quot;&gt;extension functions&lt;/a&gt;;</source>
          <target state="translated">它们必须是成员函数或&lt;a href=&quot;extensions&quot;&gt;扩展函数&lt;/a&gt; ;</target>
        </trans-unit>
        <trans-unit id="d532a698fc6a89ca0085db59fd5aa194790955a6" translate="yes" xml:space="preserve">
          <source>They must have a single parameter;</source>
          <target state="translated">它们必须有一个单一的参数。</target>
        </trans-unit>
        <trans-unit id="91414177a4c44f1c365d06f986fa21be74b2196d" translate="yes" xml:space="preserve">
          <source>They will be compiled accordingly:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4df440c5a2dac5df94e2c6decf7738ac3f8470ab" translate="yes" xml:space="preserve">
          <source>Third value.</source>
          <target state="translated">第三值:</target>
        </trans-unit>
        <trans-unit id="568f46dc17a32c789437c86db2458bc1fe5ce90c" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;kotlinMultiplatform&lt;/code&gt; publication does not include any artifacts and only references the other publications as its variants. However, it may need the sources and documentation artifacts if that is required by the repository. In that case, add those artifacts by using &lt;a href=&quot;https://docs.gradle.org/current/javadoc/org/gradle/api/publish/maven/MavenPublication.html#artifact-java.lang.Object-&quot;&gt;&lt;code&gt;artifact(...)&lt;/code&gt;&lt;/a&gt; in the publication's scope.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65054a6c60d19f99f3ba82de08ae0a53fc9c01d3" translate="yes" xml:space="preserve">
          <source>This API can be used to group a collection by key and fold each group simultaneously. For example, it can be used to count the number of words starting with each letter:</source>
          <target state="translated">这个API可以用来按键对一个集合进行分组,并同时折叠每个组。例如,它可以用来计算以每个字母开头的单词数量。</target>
        </trans-unit>
        <trans-unit id="c5e92a8ba9a486d6b6f5f3bfcee1ee9e16e21ffe" translate="yes" xml:space="preserve">
          <source>This Expression</source>
          <target state="translated">这种表达方式</target>
        </trans-unit>
        <trans-unit id="400a9b5cc1bda6f3a7e49accaa11c2410d235898" translate="yes" xml:space="preserve">
          <source>This JavaScript function can now be used just like a regular Kotlin function. Because we provided type information in the header file (as opposed to simply defining parameter and return type to be &lt;code&gt;dynamic&lt;/code&gt;), proper compiler support and type-checking is also available.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39d8e7ef05f8d1193ddfe60ed385361228082346" translate="yes" xml:space="preserve">
          <source>This allows the Java Persistence API (JPA) to instantiate a class although it doesn't have the zero-parameter constructor from Kotlin or Java point of view (see the description of &lt;code&gt;kotlin-jpa&lt;/code&gt; plugin &lt;a href=&quot;compiler-plugins#jpa-support&quot;&gt;below&lt;/a&gt;).</source>
          <target state="translated">尽管从Kotlin或Java的角度来看，它没有零参数构造函数，但它允许Java Persistence API（JPA）实例化一个类（请参阅&lt;a href=&quot;compiler-plugins#jpa-support&quot;&gt;下面&lt;/a&gt;的 &lt;code&gt;kotlin-jpa&lt;/code&gt; 插件说明）。</target>
        </trans-unit>
        <trans-unit id="262a7c17763f126ac70f16b74664e0c2732654ca" translate="yes" xml:space="preserve">
          <source>This allows the user code to not pass an extra &lt;a href=&quot;-coroutine-context/index&quot;&gt;CoroutineContext&lt;/a&gt; parameter in basic coroutine builders like &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental/launch.html&quot;&gt;launch&lt;/a&gt; and &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental/async.html&quot;&gt;async&lt;/a&gt;, but still provide easy access to coroutine context.</source>
          <target state="translated">这允许用户代码在基本的协程构建器（如&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental/launch.html&quot;&gt;launch&lt;/a&gt;和&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental/async.html&quot;&gt;async）中&lt;/a&gt;不传递额外的&lt;a href=&quot;-coroutine-context/index&quot;&gt;CoroutineContext&lt;/a&gt;参数，但仍提供对协程上下文的轻松访问。</target>
        </trans-unit>
        <trans-unit id="eb2da247bb9f320229aba7d44d4da4813d52b5e8" translate="yes" xml:space="preserve">
          <source>This allows us to write:</source>
          <target state="translated">这样我们就可以写。</target>
        </trans-unit>
        <trans-unit id="2943eee5e149bda0a3b90788c4e427a3f77fb555" translate="yes" xml:space="preserve">
          <source>This also a reason why, in these examples, &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-exception-handler/index.html&quot;&gt;CoroutineExceptionHandler&lt;/a&gt; is always installed to a coroutine that is created in &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-global-scope/index.html&quot;&gt;GlobalScope&lt;/a&gt;. It does not make sense to install an exception handler to a coroutine that is launched in the scope of the main &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/run-blocking.html&quot;&gt;runBlocking&lt;/a&gt;, since the main coroutine is going to be always cancelled when its child completes with exception despite the installed handler.</source>
          <target state="translated">这也是为什么在这些示例中，始终将&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-exception-handler/index.html&quot;&gt;CoroutineExceptionHandler&lt;/a&gt;安装到在&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-global-scope/index.html&quot;&gt;GlobalScope中&lt;/a&gt;创建的协程的原因。将异常处理程序安装到在主&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/run-blocking.html&quot;&gt;runBlocking&lt;/a&gt;范围内启动的协程中没有意义，因为尽管已安装了处理程序，但当其子级异常完成时，主协程将始终被取消。</target>
        </trans-unit>
        <trans-unit id="369f2b1361dad7365016272a8691f3b6c2f5f7b0" translate="yes" xml:space="preserve">
          <source>This also works in &lt;a href=&quot;multi-declarations&quot;&gt;destructuring declarations&lt;/a&gt;:</source>
          <target state="translated">这也适用于&lt;a href=&quot;multi-declarations&quot;&gt;销毁声明&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="d8207f40b4373f5ed1c6abf3087010e599937228" translate="yes" xml:space="preserve">
          <source>This annotation can be applied to either files or top-level declarations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7624b3ac5961056978ec90a7581d578f33bbbb61" translate="yes" xml:space="preserve">
          <source>This annotation indicates what exceptions should be declared by a function when compiled to a JVM method.</source>
          <target state="translated">这个注解指出了在编译到JVM方法时,函数应该声明哪些异常。</target>
        </trans-unit>
        <trans-unit id="cbf5d9ab056e2f21c12f9f19d919382afdc1ec0d" translate="yes" xml:space="preserve">
          <source>This annotation indicates what exceptions should be declared by a function when compiled to a platform method in Kotlin/JVM and Kotlin/Native.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b67d7593eb58defe040aee620d9f9dc5b7b870b" translate="yes" xml:space="preserve">
          <source>This annotation indicates what exceptions should be declared by a function when compiled to a platform method.</source>
          <target state="translated">这个注解指出了在编译成平台方法时,函数应该声明哪些异常。</target>
        </trans-unit>
        <trans-unit id="938e58ea6fe6a8518c5ab92c2083223c5182968a" translate="yes" xml:space="preserve">
          <source>This annotation is also used to discriminate the annotated overloads in case if overload selection still cannot choose one of them even taking in account the result of lambda parameter analysis. In that case a warning is reported.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9cda87fc9471c788eb58ec6f2e67bdf425f08550" translate="yes" xml:space="preserve">
          <source>This annotation is experimental, meaning that restrictions mentioned above are subject to change.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53852272acd887d2ace151213b2a79c6186dd5ad" translate="yes" xml:space="preserve">
          <source>This annotation is intended for &lt;em&gt;rare cases&lt;/em&gt; when API designer needs to hide Kotlin-specific target from Java API while keeping it a part of Kotlin API so the resulting API is idiomatic for both languages.</source>
          <target state="translated">此注释适用于&lt;em&gt;极少数情况，&lt;/em&gt;当API设计人员需要从Java API中隐藏Kotlin特定的目标，同时又将其保留为Kotlin API的一部分时，这样生成的API对于两种语言都是惯用的。</target>
        </trans-unit>
        <trans-unit id="f7ff9954f76ed995dd9da4bc5f1699538f3cd9e5" translate="yes" xml:space="preserve">
          <source>This annotation is only applicable to &lt;code&gt;expect&lt;/code&gt; annotation classes in multi-platform projects and marks that class as &quot;optional&quot;. Optional expected class is allowed to have no corresponding actual class on the platform. Optional annotations can only be used to annotate something, not as types in signatures. If an optional annotation has no corresponding actual class on a platform, the annotation entries where it's used are simply erased when compiling code on that platform.</source>
          <target state="translated">该批注仅适用于多平台项目中的 &lt;code&gt;expect&lt;/code&gt; 批注类，并将该类标记为&amp;ldquo;可选&amp;rdquo;。可选的预期类别允许在平台上没有相应的实际类别。可选注释只能用于注释某些内容，而不能用作签名中的类型。如果可选注释在平台上没有对应的实际类，则在该平台上编译代码时，将仅删除使用该注释的条目。</target>
        </trans-unit>
        <trans-unit id="c1b9122ad4cc089c09a766a63290941217a27add" translate="yes" xml:space="preserve">
          <source>This annotation is present on any class file produced by the Kotlin compiler and is read by the compiler and reflection. Parameters have very short JVM names on purpose: these names appear in all generated class files, and we'd like to reduce their size.</source>
          <target state="translated">这个注解存在于Kotlin编译器生成的任何类文件上,并被编译器和反射读取。参数的JVM名称非常短是有目的的:这些名称出现在所有生成的类文件中,我们希望减少它们的大小。</target>
        </trans-unit>
        <trans-unit id="10a19875cc351d84fe5e296411c863dd2553261e" translate="yes" xml:space="preserve">
          <source>This annotation marks the experimental preview of the standard library API for measuring time and working with durations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08e24e4cbc4d173492beb5ffd4d4ddb94a113383" translate="yes" xml:space="preserve">
          <source>This annotation marks the standard library API that is considered experimental and is not subject to the &lt;a href=&quot;../../../../../../docs/reference/evolution/components-stability&quot;&gt;general compatibility guarantees&lt;/a&gt; given for the standard library: the behavior of such API may be changed or the API may be removed completely in any further release.</source>
          <target state="translated">此批注标记了被认为是实验性的标准库API，不受标准库所&lt;a href=&quot;../../../../../../docs/reference/evolution/components-stability&quot;&gt;提供&lt;/a&gt;的一般兼容性保证的约束：此类API的行为可能会更改，或者在任何后续发行版中都可能会完全删除该API。</target>
        </trans-unit>
        <trans-unit id="400bdfa2156af296817e663103c3f69c483eb8d7" translate="yes" xml:space="preserve">
          <source>This annotation marks the standard library API that is considered experimental and is not subject to the &lt;a href=&quot;../../../../../docs/reference/evolution/components-stability&quot;&gt;general compatibility guarantees&lt;/a&gt; given for the standard library: the behavior of such API may be changed or the API may be removed completely in any further release.</source>
          <target state="translated">此批注标记了被认为是实验性的标准库API，不受标准库所&lt;a href=&quot;../../../../../docs/reference/evolution/components-stability&quot;&gt;提供&lt;/a&gt;的一般兼容性保证的约束：此类API的行为可能会更改，或者在任何后续发行版中都可能会完全删除该API。</target>
        </trans-unit>
        <trans-unit id="5109889d5440b373d8a734354ff5ededaa5413bf" translate="yes" xml:space="preserve">
          <source>This applies the Gradle &lt;code&gt;java&lt;/code&gt; plugin and configures the target to cooperate with it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a3b2ae9c5594175372b79e16080724e6e8baa3b" translate="yes" xml:space="preserve">
          <source>This approach requires a series of changes in how we program, in particular</source>
          <target state="translated">这种方法需要我们改变一系列的编程方式,尤其是</target>
        </trans-unit>
        <trans-unit id="726ac695c3ca14123e929478de2ca04ef1ac0eb0" translate="yes" xml:space="preserve">
          <source>This approach works only for a native source set that is shared among platform-specific source sets. It doesn&amp;rsquo;t work for native source sets shared at higher levels of the source set hierarchy.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="caabd1756e7a5fe69a248020021b58534dfbff4d" translate="yes" xml:space="preserve">
          <source>This behavior is correct but it can be very inconvenient for some libraries. So it is possible to specify in the &lt;code&gt;.def&lt;/code&gt; file which of the included headers are to be imported. The separate declarations from other headers can also be imported in case of direct dependencies.</source>
          <target state="translated">此行为是正确的，但对于某些库来说可能非常不便。因此，可以在 &lt;code&gt;.def&lt;/code&gt; 文件中指定要导入的包括哪些标头。在直接依赖的情况下，也可以导入与其他标头分开的声明。</target>
        </trans-unit>
        <trans-unit id="c6b0989aa993ac0e544c959f288dcd6e31817be1" translate="yes" xml:space="preserve">
          <source>This behavior is similar to &lt;a href=&quot;extensions&quot;&gt;extension functions&lt;/a&gt;, which also allow you to access the members of the receiver object inside the body of the function.</source>
          <target state="translated">此行为类似于&lt;a href=&quot;extensions&quot;&gt;扩展功能&lt;/a&gt;，该扩展功能还允许您访问函数主体内的接收器对象的成员。</target>
        </trans-unit>
        <trans-unit id="e20a24097999574b06c858b7503368f6bbdeb55a" translate="yes" xml:space="preserve">
          <source>This callback method should call one of these two methods:</source>
          <target state="translated">这个回调方法应该调用这两个方法中的一个。</target>
        </trans-unit>
        <trans-unit id="216d2a3ecca96db5ee19a6d39eef11e98c9f0bf5" translate="yes" xml:space="preserve">
          <source>This can be effectively combined with other idioms, leading to shorter code. E.g. with the &lt;em&gt;when&lt;/em&gt;-expression:</source>
          <target state="translated">这可以与其他惯用法有效地结合在一起，从而缩短代码长度。例如，&lt;em&gt;当when&lt;/em&gt;表达式：</target>
        </trans-unit>
        <trans-unit id="a3b4ad6a40906907f86d5ceb0160f0fc35e4272e" translate="yes" xml:space="preserve">
          <source>This can be useful for creating &lt;a href=&quot;../kotlin.collections/-map/index#kotlin.collections.Map&quot;&gt;Map&lt;/a&gt; literals with less noise, for example:</source>
          <target state="translated">这对于创建噪声较小的&lt;a href=&quot;../kotlin.collections/-map/index#kotlin.collections.Map&quot;&gt;Map&lt;/a&gt;文字很有用，例如：</target>
        </trans-unit>
        <trans-unit id="30bbb3ee5d18507d31640cacf4f0eef06845cc34" translate="yes" xml:space="preserve">
          <source>This change increases the number of possible null check optimizations that can be performed either by the Kotlin compiler or by various kinds of bytecode processing tools, such as the Android &lt;a href=&quot;https://developer.android.com/studio/build/shrink-code&quot;&gt;R8 optimizer&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e1ff87841658b954b989c8097e33f6cc0f4c4fa" translate="yes" xml:space="preserve">
          <source>This check is only available for the properties that are lexically accessible, i.e. declared in the same type or in one of the outer types, or at top level in the same file.</source>
          <target state="translated">该检查仅对词法上可访问的属性有效,即在同一类型或外类型之一中声明,或在同一文件的顶层声明。</target>
        </trans-unit>
        <trans-unit id="b8e6d8ea08a6d2f26902035e61567b7b01f67c89" translate="yes" xml:space="preserve">
          <source>This class cannot be either co- or contravariant in &lt;code&gt;T&lt;/code&gt;. And this imposes certain inflexibilities. Consider the following function:</source>
          <target state="translated">此类不能在 &lt;code&gt;T&lt;/code&gt; 中是协变或逆变的。这会带来一定的灵活性。考虑以下功能：</target>
        </trans-unit>
        <trans-unit id="5e57ca69fb23b5a69bf1e170dc12314fcab3e46e" translate="yes" xml:space="preserve">
          <source>This class is deprecated in favor of a more general approach provided by &lt;a href=&quot;../-requires-opt-in/index&quot;&gt;RequiresOptIn&lt;/a&gt;/&lt;a href=&quot;../-opt-in/index&quot;&gt;OptIn&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cfa1db139b7b160a14b6c47d1a1495d378da6d44" translate="yes" xml:space="preserve">
          <source>This class is experimental itself and can only be used with the compiler argument &lt;code&gt;-Xuse-experimental=kotlin.Experimental&lt;/code&gt;.</source>
          <target state="translated">此类本身是实验性的，只能与编译器参数 &lt;code&gt;-Xuse-experimental=kotlin.Experimental&lt;/code&gt; 一起使用。</target>
        </trans-unit>
        <trans-unit id="f5fdf32c20c754f3849efeb2ffb6fd9fe85ddd31" translate="yes" xml:space="preserve">
          <source>This class is intended to help implementing read-only lists so it doesn't support concurrent modification tracking.</source>
          <target state="translated">这个类是为了帮助实现只读列表,所以不支持并发修改跟踪。</target>
        </trans-unit>
        <trans-unit id="3649d86d1c264225e25ee01e6d003c299727a7d0" translate="yes" xml:space="preserve">
          <source>This class is intended to help implementing read-only sets so it doesn't support concurrent modification tracking.</source>
          <target state="translated">这个类是为了帮助实现只读集,所以不支持并发修改跟踪。</target>
        </trans-unit>
        <trans-unit id="d10d84799d8bbf78fb0535ad9184c4c6ada6aa07" translate="yes" xml:space="preserve">
          <source>This class is intended to implement different file traversal methods. It allows to iterate through all files inside a given directory.</source>
          <target state="translated">该类旨在实现不同的文件遍历方法。它允许遍历给定目录内的所有文件。</target>
        </trans-unit>
        <trans-unit id="322e62ea251e48658a034c9b427e81ba230bb5e9" translate="yes" xml:space="preserve">
          <source>This class provides a way to create a stable handle to any Kotlin object. After &lt;a href=&quot;-stable-ref/as-c-pointer&quot;&gt;converting to CPointer&lt;/a&gt; it can be safely passed to native code e.g. to be received in a Kotlin callback.</source>
          <target state="translated">此类提供了一种创建任何Kotlin对象的稳定句柄的方法。后&lt;a href=&quot;-stable-ref/as-c-pointer&quot;&gt;转换成CPointer&lt;/a&gt;它可以安全地传递给本机代码，例如在科特林回调接收。</target>
        </trans-unit>
        <trans-unit id="a36e06591e999a4c0d4c4171fd2c0675fb1b16fc" translate="yes" xml:space="preserve">
          <source>This class provides a way to create a stable handle to any Kotlin object. After &lt;a href=&quot;../../kotlinx.cinterop/-stable-ref/as-c-pointer&quot;&gt;converting to CPointer&lt;/a&gt; it can be safely passed to native code e.g. to be received in a Kotlin callback.</source>
          <target state="translated">此类提供了一种创建任何Kotlin对象的稳定句柄的方法。后&lt;a href=&quot;../../kotlinx.cinterop/-stable-ref/as-c-pointer&quot;&gt;转换成CPointer&lt;/a&gt;它可以安全地传递给本机代码，例如在科特林回调接收。</target>
        </trans-unit>
        <trans-unit id="f9ba51153ea7889b4c1f1704d375fc98842fa90a" translate="yes" xml:space="preserve">
          <source>This class provides a way to create a stable handle to any Kotlin object. After &lt;a href=&quot;as-c-pointer&quot;&gt;converting to CPointer&lt;/a&gt; it can be safely passed to native code e.g. to be received in a Kotlin callback.</source>
          <target state="translated">此类提供了一种创建任何Kotlin对象的稳定句柄的方法。后&lt;a href=&quot;as-c-pointer&quot;&gt;转换成CPointer&lt;/a&gt;它可以安全地传递给本机代码，例如在科特林回调接收。</target>
        </trans-unit>
        <trans-unit id="dcb7002c65d065a83f8e4df531f7471f6f059189" translate="yes" xml:space="preserve">
          <source>This class requires opt-in itself and can only be used with the compiler argument &lt;code&gt;-Xopt-in=kotlin.RequiresOptIn&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3de458f3166219b6408ccb11d5d011e7dedd5974" translate="yes" xml:space="preserve">
          <source>This code calculates the fixpoint of cosine, which is a mathematical constant. It simply calls Math.cos repeatedly starting at 1.0 until the result doesn't change any more, yielding a result of 0.7390851332151611 for the specified &lt;code&gt;eps&lt;/code&gt; precision. The resulting code is equivalent to this more traditional style:</source>
          <target state="translated">此代码计算余弦的定点，这是一个数学常数。它只是从1.0开始重复调用Math.cos，直到结果不再改变为止，对于指定的 &lt;code&gt;eps&lt;/code&gt; 精度，结果为0.7390851332151611 。生成的代码等效于这种更传统的样式：</target>
        </trans-unit>
        <trans-unit id="0859f73fe17538052c3240dd97a19efeb37af3a3" translate="yes" xml:space="preserve">
          <source>This code outputs the same numbers, but it waits 100ms before printing each one.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="311dcc9bdc9a71974877af55a1f22b85798cc90e" translate="yes" xml:space="preserve">
          <source>This code outputs:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6ca25f95d0c9b2687336e1d3e2569e0a9d58bd7" translate="yes" xml:space="preserve">
          <source>This code prints &quot;&lt;em&gt;Class method&lt;/em&gt;&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8620e5b24bc2854857bfffdb08cfa789461eb543" translate="yes" xml:space="preserve">
          <source>This code prints the numbers after waiting for a second.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d9da40aacdb3e7a501485fd289174c0f7bd3ce2" translate="yes" xml:space="preserve">
          <source>This code prints three numbers produced by the &lt;code&gt;simple&lt;/code&gt; flow followed by a &quot;Done&quot; string:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fed0b2a7bdca562e95956df46281418063a044e3" translate="yes" xml:space="preserve">
          <source>This code produces the following exception:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c9fb24eb61454c344b8e7f5093f2e83751a14fd" translate="yes" xml:space="preserve">
          <source>This code specifies an action to be performed on the &quot;hello&quot; button click. Note that with lambdas this code looks rather concise written directly in Kotlin:</source>
          <target state="translated">这段代码指定了点击 &quot;hello &quot;按钮时要执行的操作。请注意,如果使用lambdas,这段代码看起来相当简洁,直接用Kotlin写的。</target>
        </trans-unit>
        <trans-unit id="5ce07b0d1b723a22c052939194fdf2108e0fc9dc" translate="yes" xml:space="preserve">
          <source>This code successfully catches an exception in &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/collect.html&quot;&gt;collect&lt;/a&gt; terminal operator and, as we see, no more values are emitted after that:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a399037775e6ca51f06689e0a34eb873db7e0ee6" translate="yes" xml:space="preserve">
          <source>This code waits 100ms before printing each number without blocking the main thread. This is verified by printing &quot;I'm not blocked&quot; every 100ms from a separate coroutine that is running in the main thread:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="655348672aba46b323a130d4745ad11efc796bd4" translate="yes" xml:space="preserve">
          <source>This code will be compiled &quot;as is&quot;: &lt;code&gt;dyn.whatever(1)&lt;/code&gt; in Kotlin becomes &lt;code&gt;dyn.whatever(1)&lt;/code&gt; in the generated JavaScript code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f097f6de0cc3b7d0fc741d38a1eac67ae2fca6f2" translate="yes" xml:space="preserve">
          <source>This code will launch a long-running operation without blocking the main thread. The &lt;code&gt;preparePost&lt;/code&gt; is what's called a &lt;code&gt;suspendable function&lt;/code&gt;, thus the keyword &lt;code&gt;suspend&lt;/code&gt; prefixing it. What this means as stated above, is that the function will execute, pause execution and resume at some point in time.</source>
          <target state="translated">此代码将启动长时间运行的操作，而不会阻塞主线程。该 &lt;code&gt;preparePost&lt;/code&gt; 是什么叫做 &lt;code&gt;suspendable function&lt;/code&gt; ，因此关键字 &lt;code&gt;suspend&lt;/code&gt; 前缀它。如上所述，这意味着该函数将在某个时间点执行，暂停执行并恢复。</target>
        </trans-unit>
        <trans-unit id="940a39107db356b9719bbf9342038d41ba48b8c2" translate="yes" xml:space="preserve">
          <source>This code works slower, but we still don't get &quot;Counter = 100000&quot; at the end, because volatile variables guarantee linearizable (this is a technical term for &quot;atomic&quot;) reads and writes to the corresponding variable, but do not provide atomicity of larger actions (increment in our case).</source>
          <target state="translated">这段代码的工作速度较慢,但我们在最后仍然没有得到 &quot;Counter=100000&quot;,因为volatile变量保证了对相应变量的可线性化(这是 &quot;原子 &quot;的技术术语)读写,但不提供较大动作(在我们的例子中是增量)的原子性。</target>
        </trans-unit>
        <trans-unit id="19e35196b450d82e8abc869e0b8d2aedd7f24d49" translate="yes" xml:space="preserve">
          <source>This code works very slowly, because it does &lt;em&gt;fine-grained&lt;/em&gt; thread-confinement. Each individual increment switches from multi-threaded &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-dispatchers/-default.html&quot;&gt;Dispatchers.Default&lt;/a&gt; context to the single-threaded context using &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/with-context.html&quot;&gt;withContext(counterContext)&lt;/a&gt; block.</source>
          <target state="translated">这段代码的工作速度非常慢，因为它&lt;em&gt;可以进行细粒度的&lt;/em&gt;线程约束。每个单独的增量都使用&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/with-context.html&quot;&gt;withContext（counterContext）&lt;/a&gt;块从多线程&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-dispatchers/-default.html&quot;&gt;Dispatchers.Default&lt;/a&gt;上下文切换到单线程上下文。</target>
        </trans-unit>
        <trans-unit id="d15be2d04edeeec0e153a44e5ef98d0f0d439b37" translate="yes" xml:space="preserve">
          <source>This collection has size of &lt;code&gt;groupCount + 1&lt;/code&gt; where &lt;code&gt;groupCount&lt;/code&gt; is the count of groups in the regular expression. Groups are indexed from 1 to &lt;code&gt;groupCount&lt;/code&gt; and group with the index 0 corresponds to the entire match.</source>
          <target state="translated">该集合的大小为 &lt;code&gt;groupCount + 1&lt;/code&gt; ，其中 &lt;code&gt;groupCount&lt;/code&gt; 是正则表达式中的组数。组从1到 &lt;code&gt;groupCount&lt;/code&gt; 进行索引，索引为0的组与整个匹配相对应。</target>
        </trans-unit>
        <trans-unit id="3f0910a281cb430f7b55e3a35ed5817aefc3f7c5" translate="yes" xml:space="preserve">
          <source>This command should output crash report that is additionally processed and includes inlined stack trace elements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c28fcaf55859958d617c24c43acf5fe9a19ed1ae" translate="yes" xml:space="preserve">
          <source>This command will produce a &lt;code&gt;png.klib&lt;/code&gt; compiled library and &lt;code&gt;png-build/kotlin&lt;/code&gt; directory containing Kotlin source code for the library.</source>
          <target state="translated">该命令将生成一个 &lt;code&gt;png.klib&lt;/code&gt; 编译的库以及包含该库的Kotlin源代码的 &lt;code&gt;png-build/kotlin&lt;/code&gt; 目录。</target>
        </trans-unit>
        <trans-unit id="31a6ce4f29e9c4d59e89de3b53b3a11728189b63" translate="yes" xml:space="preserve">
          <source>This contract specifies that:</source>
          <target state="translated">本合同规定:</target>
        </trans-unit>
        <trans-unit id="d6dc362cdb3af439d7414c31776e978f9f9881cd" translate="yes" xml:space="preserve">
          <source>This convention, along with &lt;a href=&quot;#passing-a-lambda-to-the-last-parameter&quot;&gt;passing a lambda expression outside parentheses&lt;/a&gt;, allows for &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/bb308959.aspx&quot;&gt;LINQ-style&lt;/a&gt; code:</source>
          <target state="translated">该约定以及&lt;a href=&quot;#passing-a-lambda-to-the-last-parameter&quot;&gt;在括号外传递lambda表达式&lt;/a&gt;，允许使用&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/bb308959.aspx&quot;&gt;LINQ样式的&lt;/a&gt;代码：</target>
        </trans-unit>
        <trans-unit id="615ee8a7977549b4df34e13628dfcadf465d6b63" translate="yes" xml:space="preserve">
          <source>This convention, along with &lt;a href=&quot;#passing-a-lambda-to-the-last-parameter&quot;&gt;passing a lambda expression outside parentheses&lt;/a&gt;, allows for &lt;a href=&quot;https://docs.microsoft.com/en-us/previous-versions/dotnet/articles/bb308959(v=msdn.10)&quot;&gt;LINQ-style&lt;/a&gt; code:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78e5afd48b07123042fcce6bdde782478e4769ee" translate="yes" xml:space="preserve">
          <source>This could be an issue for Java-interoperability, so Kotlin 1.3 introduces the &lt;code&gt;@JvmDefault&lt;/code&gt; annotation. Methods, annotated with this annotation will be generated as &lt;code&gt;default&lt;/code&gt; methods for JVM:</source>
          <target state="translated">这可能是Java互操作性的问题，因此Kotlin 1.3引入了 &lt;code&gt;@JvmDefault&lt;/code&gt; 注释。带有此注释的方法将作为JVM的 &lt;code&gt;default&lt;/code&gt; 方法生成：</target>
        </trans-unit>
        <trans-unit id="b179e178b1137230407a1019e7d8b4984a1d071b" translate="yes" xml:space="preserve">
          <source>This creates the &lt;code&gt;kotlin&lt;/code&gt; extension at the top level. You can then access it in the build script for:</source>
          <target state="translated">这将在顶层创建 &lt;code&gt;kotlin&lt;/code&gt; 扩展。然后，您可以在构建脚本中访问它：</target>
        </trans-unit>
        <trans-unit id="91b0596f729477e16cacda10e4665e91b4d05e3b" translate="yes" xml:space="preserve">
          <source>This document covers some details of Kotlin/Native interoperability with Swift/Objective-C.</source>
          <target state="translated">本文档涵盖了Kotlin/Native与Swift/Objective-C互操作的一些细节。</target>
        </trans-unit>
        <trans-unit id="50a7c9e10c5c72d9392130bc3068411c0b41a1c1" translate="yes" xml:space="preserve">
          <source>This document explains the structure of &lt;a href=&quot;multiplatform&quot;&gt;Kotlin multiplatform projects&lt;/a&gt; and describes how those are configured and built using Gradle.</source>
          <target state="translated">本文档说明了&lt;a href=&quot;multiplatform&quot;&gt;Kotlin跨平台项目&lt;/a&gt;的结构，并介绍了如何使用Gradle配置和构建这些项目。</target>
        </trans-unit>
        <trans-unit id="21394d0363d5df965c799770727e7adbc3c6c279" translate="yes" xml:space="preserve">
          <source>This effect is specified in the &lt;code&gt;contract { }&lt;/code&gt; block by attaching a boolean expression to another &lt;a href=&quot;-simple-effect/index&quot;&gt;SimpleEffect&lt;/a&gt; effect with the function &lt;a href=&quot;-simple-effect/implies&quot;&gt;SimpleEffect.implies&lt;/a&gt;.</source>
          <target state="translated">通过将布尔表达式附加到具有功能&lt;a href=&quot;-simple-effect/implies&quot;&gt;SimpleEffect.implies的&lt;/a&gt;另一个&lt;a href=&quot;-simple-effect/index&quot;&gt;SimpleEffect&lt;/a&gt;效果，可以在 &lt;code&gt;contract { }&lt;/code&gt; 块中指定此效果。</target>
        </trans-unit>
        <trans-unit id="fb5b2df09cf2fcb8077c0a923825c3e12c005d89" translate="yes" xml:space="preserve">
          <source>This example always prints zero. Resources do not leak.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e955cd6c26356181a1bb5fce56a8a7425848e09" translate="yes" xml:space="preserve">
          <source>This example can be also rewritten in a more idiomatic way, using &lt;code&gt;runBlocking&lt;/code&gt; to wrap the execution of the main function:</source>
          <target state="translated">也可以使用 &lt;code&gt;runBlocking&lt;/code&gt; 封装主要函数的执行，以更惯用的方式重写此示例：</target>
        </trans-unit>
        <trans-unit id="fea137e1d1b8bae0357ac3e28f43d2dbd0615f21" translate="yes" xml:space="preserve">
          <source>This example completes in less than a second for me, but it prints some arbitrary number, because some coroutines don't finish before &lt;code&gt;main()&lt;/code&gt; prints the result. Let's fix that.</source>
          <target state="translated">对于我来说，该示例在不到一秒钟的时间内完成了，但是它打印了一些任意数字，因为某些协程在 &lt;code&gt;main()&lt;/code&gt; 打印结果之前没有完成。让我们修复它。</target>
        </trans-unit>
        <trans-unit id="a01abea8c251a15b2fecf1b509dc49ecf9457794" translate="yes" xml:space="preserve">
          <source>This example prints &quot;&lt;em&gt;Shape&lt;/em&gt;&quot;, because the extension function being called depends only on the declared type of the parameter &lt;code&gt;s&lt;/code&gt;, which is the &lt;code&gt;Shape&lt;/code&gt; class.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e728cbcad0747512419b85edec7c03f8dbc8800" translate="yes" xml:space="preserve">
          <source>This example prints:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3176985b1c6580c82570c99ec00af4e47e3fca5d" translate="yes" xml:space="preserve">
          <source>This example uses the utility function &lt;code&gt;startActivity&lt;/code&gt; creating an intent with no data and starting a new activity, which comes from the &lt;a href=&quot;https://github.com/Kotlin/anko&quot;&gt;Anko&lt;/a&gt; library. To pass some data, you can say &lt;code&gt;startActivity&amp;lt;OtherActivity&amp;gt;(&quot;KEY&quot; to &quot;VALUE&quot;)&lt;/code&gt;.</source>
          <target state="translated">本示例使用实用程序函数 &lt;code&gt;startActivity&lt;/code&gt; 创建一个无数据的意图，并启动一个来自&lt;a href=&quot;https://github.com/Kotlin/anko&quot;&gt;Anko&lt;/a&gt;库的新活动。要传递一些数据，您可以说 &lt;code&gt;startActivity&amp;lt;OtherActivity&amp;gt;(&quot;KEY&quot; to &quot;VALUE&quot;)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6017ffad0436bb8b6025573c2ab986b658552870" translate="yes" xml:space="preserve">
          <source>This example will print &quot;c&quot;, because the extension function being called depends only on the declared type of the parameter &lt;code&gt;c&lt;/code&gt;, which is the &lt;code&gt;C&lt;/code&gt; class.</source>
          <target state="translated">这个例子将打印&amp;ldquo;C&amp;rdquo;，因为被称为扩展函数仅依赖于声明的类型的参数的 &lt;code&gt;c&lt;/code&gt; ，这是 &lt;code&gt;C&lt;/code&gt; 类。</target>
        </trans-unit>
        <trans-unit id="a5a9e0df4941c06894731d36487fbab59c324ecd" translate="yes" xml:space="preserve">
          <source>This exception is still caught and collection is stopped:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="133008c5d984069ce6a34613c275871c4f01bd7c" translate="yes" xml:space="preserve">
          <source>This extension allows to use instances of Lazy for property delegation: &lt;code&gt;val property: String by lazy { initializer }&lt;/code&gt;</source>
          <target state="translated">此扩展允许使用Lazy的实例进行属性委派： &lt;code&gt;val property: String by lazy { initializer }&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8d46e174deee6bd3f88e10604b91fb9b63428622" translate="yes" xml:space="preserve">
          <source>This extension is chosen only for invocation with old-named parameters. Replace parameter names with the same as those of &lt;a href=&quot;../kotlin/-char-sequence/sub-sequence#kotlin.CharSequence%24subSequence%28kotlin.Int%2C+kotlin.Int%29&quot;&gt;CharSequence.subSequence&lt;/a&gt;.</source>
          <target state="translated">选择此扩展名仅用于使用旧名称的参数进行调用。将参数名称替换为与&lt;a href=&quot;../kotlin/-char-sequence/sub-sequence#kotlin.CharSequence%24subSequence%28kotlin.Int%2C+kotlin.Int%29&quot;&gt;CharSequence.subSequence&lt;/a&gt;相同的名称。</target>
        </trans-unit>
        <trans-unit id="14d1030709354dc027ae0189ce6ddad41a98c081" translate="yes" xml:space="preserve">
          <source>This extension is chosen only for invocation with old-named parameters. Replace parameter names with the same as those of &lt;a href=&quot;../kotlin/-char-sequence/sub-sequence#kotlin.CharSequence%24subSequence(kotlin.Int,%20kotlin.Int)&quot;&gt;CharSequence.subSequence&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04d1f02c756f7e0904c6b3ffc69c7b6618cd5516" translate="yes" xml:space="preserve">
          <source>This extension on &lt;code&gt;Map&lt;/code&gt; returns an existing value corresponding to the given key or throws an exception, mentioning which key was not found. If the map was produced with &lt;code&gt;withDefault&lt;/code&gt;, this function will return the default value instead of throwing an exception.</source>
          <target state="translated">&lt;code&gt;Map&lt;/code&gt; 上的此扩展名返回与给定键相对应的现有值，或引发异常，并提及未找到哪个键。如果映射是使用 &lt;code&gt;withDefault&lt;/code&gt; 生成的，则此函数将返回默认值，而不是引发异常。</target>
        </trans-unit>
        <trans-unit id="179023ec810ea92c988e87fc2b985af8aad37762" translate="yes" xml:space="preserve">
          <source>This feature is available since Kotlin 1.3.40.</source>
          <target state="translated">这个功能从Kotlin 1.3.40开始就有了。</target>
        </trans-unit>
        <trans-unit id="291f1aee064b4993bae1bca7498ed1b391616e9f" translate="yes" xml:space="preserve">
          <source>This function can be implemented to produce more precise result for &lt;a href=&quot;expm1#kotlin.math%24expm1%28kotlin.Double%29%2Fx&quot;&gt;x&lt;/a&gt; near zero.</source>
          <target state="translated">可以实现该功能以针对&lt;a href=&quot;expm1#kotlin.math%24expm1%28kotlin.Double%29%2Fx&quot;&gt;x&lt;/a&gt;接近零产生更精确的结果。</target>
        </trans-unit>
        <trans-unit id="82fc3a4111cee52b0765cac3deb75eac875358c3" translate="yes" xml:space="preserve">
          <source>This function can be implemented to produce more precise result for &lt;a href=&quot;expm1#kotlin.math%24expm1(kotlin.Double)/x&quot;&gt;x&lt;/a&gt; near zero.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b2cb2dc1fab6dcfdc4a04073763dbc01b226107" translate="yes" xml:space="preserve">
          <source>This function can be implemented to produce more precise result for &lt;a href=&quot;ln1p#kotlin.math%24ln1p%28kotlin.Double%29%2Fx&quot;&gt;x&lt;/a&gt; near zero.</source>
          <target state="translated">可以实现该功能以针对&lt;a href=&quot;ln1p#kotlin.math%24ln1p%28kotlin.Double%29%2Fx&quot;&gt;x&lt;/a&gt;接近零产生更精确的结果。</target>
        </trans-unit>
        <trans-unit id="8ea77ed3f5037a0baac9478b8da01da4e51178e3" translate="yes" xml:space="preserve">
          <source>This function can be implemented to produce more precise result for &lt;a href=&quot;ln1p#kotlin.math%24ln1p%28kotlin.Float%29%2Fx&quot;&gt;x&lt;/a&gt; near zero.</source>
          <target state="translated">可以实现该功能以针对&lt;a href=&quot;ln1p#kotlin.math%24ln1p%28kotlin.Float%29%2Fx&quot;&gt;x&lt;/a&gt;接近零产生更精确的结果。</target>
        </trans-unit>
        <trans-unit id="8188da7cb3be6634067162b37cc97e8bc1ff03f4" translate="yes" xml:space="preserve">
          <source>This function can be implemented to produce more precise result for &lt;a href=&quot;ln1p#kotlin.math%24ln1p(kotlin.Double)/x&quot;&gt;x&lt;/a&gt; near zero.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="efadae38b073a74442295c102230ba4f30a5571f" translate="yes" xml:space="preserve">
          <source>This function can be implemented to produce more precise result for &lt;a href=&quot;ln1p#kotlin.math%24ln1p(kotlin.Float)/x&quot;&gt;x&lt;/a&gt; near zero.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4311a401a48c7764543d1126d79598187555315" translate="yes" xml:space="preserve">
          <source>This function can be used to extend the logic of creating the object (e.g. perform validation checks) to which the property implementation is delegated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c898be592d8e9ec3ec1e1197444847361f309383" translate="yes" xml:space="preserve">
          <source>This function catches any &lt;a href=&quot;-throwable/index#kotlin.Throwable&quot;&gt;Throwable&lt;/a&gt; exception thrown by &lt;a href=&quot;map-catching#kotlin%24mapCatching(kotlin.Result((kotlin.mapCatching.T)),%20kotlin.Function1((kotlin.mapCatching.T,%20kotlin.mapCatching.R)))/transform&quot;&gt;transform&lt;/a&gt; function and encapsulates it as a failure. See &lt;a href=&quot;../kotlin.collections/map&quot;&gt;map&lt;/a&gt; for an alternative that rethrows exceptions from &lt;code&gt;transform&lt;/code&gt; function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cef13bf6e73de23f49c16a3bab2d588fbcbf2988" translate="yes" xml:space="preserve">
          <source>This function catches any &lt;a href=&quot;-throwable/index#kotlin.Throwable&quot;&gt;Throwable&lt;/a&gt; exception thrown by &lt;a href=&quot;recover-catching#kotlin%24recoverCatching(kotlin.Result((kotlin.recoverCatching.T)),%20kotlin.Function1((kotlin.Throwable,%20kotlin.recoverCatching.R)))/transform&quot;&gt;transform&lt;/a&gt; function and encapsulates it as a failure. See &lt;a href=&quot;recover&quot;&gt;recover&lt;/a&gt; for an alternative that rethrows exceptions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c484bb37db8fbf2af8bdf87b8645f693e45336d" translate="yes" xml:space="preserve">
          <source>This function compares this string and the specified &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/lang/StringBuffer.html&quot;&gt;StringBuffer&lt;/a&gt; in a synchronized block that acquires that &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/lang/StringBuffer.html&quot;&gt;StringBuffer&lt;/a&gt;'s monitor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15d8b3c4e3fae3fdf6c4d98c18ebe217e09dc09b" translate="yes" xml:space="preserve">
          <source>This function ensures that if we see such an object during freezing attempt - freeze fails and &lt;a href=&quot;-freezing-exception/index&quot;&gt;FreezingException&lt;/a&gt; is thrown.</source>
          <target state="translated">此函数可确保如果我们在尝试冻结期间看到此类对象，则会冻结失败并引发&lt;a href=&quot;-freezing-exception/index&quot;&gt;FreezingException&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b1cc74a9da98228f1c9d06844410d709b18bb49c" translate="yes" xml:space="preserve">
          <source>This function ensures that if we see such an object during freezing attempt - freeze fails and &lt;a href=&quot;../../kotlin.native.concurrent/-freezing-exception/index&quot;&gt;FreezingException&lt;/a&gt; is thrown.</source>
          <target state="translated">此函数可确保如果我们在尝试冻结期间看到此类对象，则会冻结失败并引发&lt;a href=&quot;../../kotlin.native.concurrent/-freezing-exception/index&quot;&gt;FreezingException&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a5393499e5b4f857a3be1966cc5a5ee2263343b0" translate="yes" xml:space="preserve">
          <source>This function has two notable differences from the method Pattern.split:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8266b16f93bf335043fb8a8f2352b33ede13a56f" translate="yes" xml:space="preserve">
          <source>This function is &lt;em&gt;unchecked&lt;/em&gt;. Repeated invocation of any resume function on the resulting continuation corrupts the state machine of the coroutine and may result in arbitrary behaviour or exception.</source>
          <target state="translated">此功能&lt;em&gt;未选中&lt;/em&gt;。在结果延续上重复调用任何恢复函数会破坏协程的状态机，并可能导致任意行为或异常。</target>
        </trans-unit>
        <trans-unit id="080e9b8336d9b1bd6ef82f0d25962f50f8a0565d" translate="yes" xml:space="preserve">
          <source>This function is a shorthand for &lt;code&gt;fold(onSuccess = { null }, onFailure = { it })&lt;/code&gt; (see &lt;a href=&quot;../../kotlin.collections/fold&quot;&gt;fold&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d500cf4330e5af6f7d32531bc1c10b5b5cb22a39" translate="yes" xml:space="preserve">
          <source>This function is a shorthand for &lt;code&gt;getOrElse { defaultValue }&lt;/code&gt; (see &lt;a href=&quot;../kotlin.collections/get-or-else&quot;&gt;getOrElse&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1206d6e25fa2947fa30b44bb46d8a067f16e4bc2" translate="yes" xml:space="preserve">
          <source>This function is a shorthand for &lt;code&gt;getOrElse { null }&lt;/code&gt; (see &lt;a href=&quot;../../kotlin.collections/get-or-else&quot;&gt;getOrElse&lt;/a&gt;) or &lt;code&gt;fold(onSuccess = { it }, onFailure = { null })&lt;/code&gt; (see &lt;a href=&quot;../../kotlin.collections/fold&quot;&gt;fold&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3ceaf91c907592aafc9f5d591d5965851baf420" translate="yes" xml:space="preserve">
          <source>This function is a shorthand for &lt;code&gt;getOrElse { throw it }&lt;/code&gt; (see &lt;a href=&quot;../kotlin.collections/get-or-else&quot;&gt;getOrElse&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ff5ce4b141292d06ec70d6eb85ccd3070084028" translate="yes" xml:space="preserve">
          <source>This function is deprecated. See &lt;a href=&quot;as-c-pointer&quot;&gt;Worker.asCPointer&lt;/a&gt; for more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1082b4365fe4440feb5a4149d9805ba0ee95963d" translate="yes" xml:space="preserve">
          <source>This function is deprecated. Use &lt;code&gt;kotlinx.cinterop.StableRef.create(worker).asCPointer()&lt;/code&gt; instead. The result can be unwrapped with &lt;code&gt;pointer.asStableRef&amp;lt;Worker&amp;gt;().get()&lt;/code&gt;. &lt;a href=&quot;../../kotlinx.cinterop/-stable-ref/index&quot;&gt;StableRef&lt;/a&gt; should be eventually disposed manually with &lt;a href=&quot;../../kotlinx.cinterop/-stable-ref/dispose&quot;&gt;StableRef.dispose&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="655c266532fc9da4c9f83fafc0352f21cfdf4913" translate="yes" xml:space="preserve">
          <source>This function is designed to be used from inside of &lt;a href=&quot;suspend-coroutine-unintercepted-or-return&quot;&gt;suspendCoroutineUninterceptedOrReturn&lt;/a&gt; to resume the execution of the suspended coroutine using a reference to the suspending function.</source>
          <target state="translated">该函数被设计为从&lt;a href=&quot;suspend-coroutine-unintercepted-or-return&quot;&gt;suspendCoroutineUninterceptedOrReturn&lt;/a&gt;内部使用，以通过使用对suspend函数的引用来恢复暂停的协程的执行。</target>
        </trans-unit>
        <trans-unit id="4f965c0d50c6551000096efd613ba42b0075743e" translate="yes" xml:space="preserve">
          <source>This function is experimental because not all the features are supported yet, and behavior might change in corner cases. In particular, the following is not supported correctly or at all:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a73c80e70840d67f98f7e02bc949060c1aff0a7a" translate="yes" xml:space="preserve">
          <source>This function is shorthand for &lt;code&gt;fold(onSuccess = { null }, onFailure = { it })&lt;/code&gt; (see &lt;a href=&quot;../../kotlin.collections/fold&quot;&gt;fold&lt;/a&gt;).</source>
          <target state="translated">该函数是 &lt;code&gt;fold(onSuccess = { null }, onFailure = { it })&lt;/code&gt; 简写（请参阅&lt;a href=&quot;../../kotlin.collections/fold&quot;&gt;fold&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="6bebf395da4954e0241f8b8cedacdd2c2c071a5d" translate="yes" xml:space="preserve">
          <source>This function is shorthand for &lt;code&gt;getOrElse { defaultValue }&lt;/code&gt; (see &lt;a href=&quot;../kotlin.collections/get-or-else&quot;&gt;getOrElse&lt;/a&gt;).</source>
          <target state="translated">此函数是 &lt;code&gt;getOrElse { defaultValue }&lt;/code&gt; 简写（请参见&lt;a href=&quot;../kotlin.collections/get-or-else&quot;&gt;getOrElse&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="036653325111157e1e020b5f2e95ce39aee0befd" translate="yes" xml:space="preserve">
          <source>This function is shorthand for &lt;code&gt;getOrElse { null }&lt;/code&gt; (see &lt;a href=&quot;../../kotlin.collections/get-or-else&quot;&gt;getOrElse&lt;/a&gt;) or &lt;code&gt;fold(onSuccess = { it }, onFailure = { null })&lt;/code&gt; (see &lt;a href=&quot;../../kotlin.collections/fold&quot;&gt;fold&lt;/a&gt;).</source>
          <target state="translated">此函数是 &lt;code&gt;getOrElse { null }&lt;/code&gt; （请参见&lt;a href=&quot;../../kotlin.collections/get-or-else&quot;&gt;getOrElse&lt;/a&gt;）或 &lt;code&gt;fold(onSuccess = { it }, onFailure = { null })&lt;/code&gt; （请参见&lt;a href=&quot;../../kotlin.collections/fold&quot;&gt;fold&lt;/a&gt;）的简写形式。</target>
        </trans-unit>
        <trans-unit id="0cd6600313d79bdb9ccb1177f047f415c30785ec" translate="yes" xml:space="preserve">
          <source>This function is shorthand for &lt;code&gt;getOrElse { throw it }&lt;/code&gt; (see &lt;a href=&quot;../kotlin.collections/get-or-else&quot;&gt;getOrElse&lt;/a&gt;).</source>
          <target state="translated">此函数是 &lt;code&gt;getOrElse { throw it }&lt;/code&gt; 简写（请参阅&lt;a href=&quot;../kotlin.collections/get-or-else&quot;&gt;getOrElse&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="2764ff2fd2235b064886b62fb3ea52722744061e" translate="yes" xml:space="preserve">
          <source>This function is supposed to copy items from one array to another. Let's try to apply it in practice:</source>
          <target state="translated">这个函数应该是将一个数组中的项目复制到另一个数组中。让我们试着在实践中应用它。</target>
        </trans-unit>
        <trans-unit id="e946cda58e67ec0857646809f4c7cd966c6aa3b4" translate="yes" xml:space="preserve">
          <source>This function may simply return original &lt;a href=&quot;intercept-continuation#kotlin.coroutines.ContinuationInterceptor%24interceptContinuation%28kotlin.coroutines.Continuation%28%28kotlin.coroutines.ContinuationInterceptor.interceptContinuation.T%29%29%29%2Fcontinuation&quot;&gt;continuation&lt;/a&gt; if it does not want to intercept this particular continuation.</source>
          <target state="translated">该功能可以简单地返回原来的&lt;a href=&quot;intercept-continuation#kotlin.coroutines.ContinuationInterceptor%24interceptContinuation%28kotlin.coroutines.Continuation%28%28kotlin.coroutines.ContinuationInterceptor.interceptContinuation.T%29%29%29%2Fcontinuation&quot;&gt;延续&lt;/a&gt;，如果它不希望拦截这个特殊的延续。</target>
        </trans-unit>
        <trans-unit id="11e7f8ea6989ea16c6c6f19e0683df8d87331f23" translate="yes" xml:space="preserve">
          <source>This function may simply return original &lt;a href=&quot;intercept-continuation#kotlin.coroutines.ContinuationInterceptor%24interceptContinuation(kotlin.coroutines.Continuation((kotlin.coroutines.ContinuationInterceptor.interceptContinuation.T)))/continuation&quot;&gt;continuation&lt;/a&gt; if it does not want to intercept this particular continuation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e37e9fc156176e563d05b6de34d613400e3a03e7" translate="yes" xml:space="preserve">
          <source>This function returns unintercepted continuation. Invocation of &lt;code&gt;resume(Unit)&lt;/code&gt; starts coroutine immediately in the invoker's call stack without going through the ContinuationInterceptor that might be present in the completion's CoroutineContext. It is the invoker's responsibility to ensure that a proper invocation context is established. Note that &lt;a href=&quot;create-coroutine-unintercepted#kotlin.coroutines.intrinsics%24createCoroutineUnintercepted%28kotlin.coroutines.SuspendFunction0%28%28kotlin.coroutines.intrinsics.createCoroutineUnintercepted.T%29%29%2C+kotlin.coroutines.Continuation%28%28kotlin.coroutines.intrinsics.createCoroutineUnintercepted.T%29%29%29%2Fcompletion&quot;&gt;completion&lt;/a&gt; of this function may get invoked in an arbitrary context.</source>
          <target state="translated">此函数返回无中断的延续。调用 &lt;code&gt;resume(Unit)&lt;/code&gt; 会立即在调用者的调用堆栈中启动协程，而无需经过可能存在于完成的CoroutineContext中的ContinuationInterceptor。调用者有责任确保建立正确的调用上下文。注意，可以在任意上下文中调用此功能的&lt;a href=&quot;create-coroutine-unintercepted#kotlin.coroutines.intrinsics%24createCoroutineUnintercepted%28kotlin.coroutines.SuspendFunction0%28%28kotlin.coroutines.intrinsics.createCoroutineUnintercepted.T%29%29%2C+kotlin.coroutines.Continuation%28%28kotlin.coroutines.intrinsics.createCoroutineUnintercepted.T%29%29%29%2Fcompletion&quot;&gt;完成&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="83c7cfd05c8eea06ab4db27704a1d5249d155e3e" translate="yes" xml:space="preserve">
          <source>This function returns unintercepted continuation. Invocation of &lt;code&gt;resume(Unit)&lt;/code&gt; starts coroutine immediately in the invoker's call stack without going through the ContinuationInterceptor that might be present in the completion's CoroutineContext. It is the invoker's responsibility to ensure that a proper invocation context is established. Note that &lt;a href=&quot;create-coroutine-unintercepted#kotlin.coroutines.intrinsics%24createCoroutineUnintercepted%28kotlin.coroutines.SuspendFunction1%28%28kotlin.coroutines.intrinsics.createCoroutineUnintercepted.R%2C+kotlin.coroutines.intrinsics.createCoroutineUnintercepted.T%29%29%2C+kotlin.coroutines.intrinsics.createCoroutineUnintercepted.R%2C+kotlin.coroutines.Continuation%28%28kotlin.coroutines.intrinsics.createCoroutineUnintercepted.T%29%29%29%2Fcompletion&quot;&gt;completion&lt;/a&gt; of this function may get invoked in an arbitrary context.</source>
          <target state="translated">此函数返回无中断的延续。调用 &lt;code&gt;resume(Unit)&lt;/code&gt; 会立即在调用者的调用堆栈中启动协程，而无需经过可能存在于完成的CoroutineContext中的ContinuationInterceptor。调用者有责任确保建立正确的调用上下文。注意，可以在任意上下文中调用此功能的&lt;a href=&quot;create-coroutine-unintercepted#kotlin.coroutines.intrinsics%24createCoroutineUnintercepted%28kotlin.coroutines.SuspendFunction1%28%28kotlin.coroutines.intrinsics.createCoroutineUnintercepted.R%2C+kotlin.coroutines.intrinsics.createCoroutineUnintercepted.T%29%29%2C+kotlin.coroutines.intrinsics.createCoroutineUnintercepted.R%2C+kotlin.coroutines.Continuation%28%28kotlin.coroutines.intrinsics.createCoroutineUnintercepted.T%29%29%29%2Fcompletion&quot;&gt;完成&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e77211107874c1aa9b698abd78683ca24a554806" translate="yes" xml:space="preserve">
          <source>This function returns unintercepted continuation. Invocation of &lt;code&gt;resume(Unit)&lt;/code&gt; starts coroutine immediately in the invoker's call stack without going through the ContinuationInterceptor that might be present in the completion's CoroutineContext. It is the invoker's responsibility to ensure that a proper invocation context is established. Note that &lt;a href=&quot;create-coroutine-unintercepted#kotlin.coroutines.intrinsics%24createCoroutineUnintercepted(kotlin.coroutines.SuspendFunction0((kotlin.coroutines.intrinsics.createCoroutineUnintercepted.T)),%20kotlin.coroutines.Continuation((kotlin.coroutines.intrinsics.createCoroutineUnintercepted.T)))/completion&quot;&gt;completion&lt;/a&gt; of this function may get invoked in an arbitrary context.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23439beed8599daea974279d78d13303435cfab9" translate="yes" xml:space="preserve">
          <source>This function returns unintercepted continuation. Invocation of &lt;code&gt;resume(Unit)&lt;/code&gt; starts coroutine immediately in the invoker's call stack without going through the ContinuationInterceptor that might be present in the completion's CoroutineContext. It is the invoker's responsibility to ensure that a proper invocation context is established. Note that &lt;a href=&quot;create-coroutine-unintercepted#kotlin.coroutines.intrinsics%24createCoroutineUnintercepted(kotlin.coroutines.SuspendFunction1((kotlin.coroutines.intrinsics.createCoroutineUnintercepted.R,%20kotlin.coroutines.intrinsics.createCoroutineUnintercepted.T)),%20kotlin.coroutines.intrinsics.createCoroutineUnintercepted.R,%20kotlin.coroutines.Continuation((kotlin.coroutines.intrinsics.createCoroutineUnintercepted.T)))/completion&quot;&gt;completion&lt;/a&gt; of this function may get invoked in an arbitrary context.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c273643758adbf26e0358f1c22929439c83656d2" translate="yes" xml:space="preserve">
          <source>This function shall be used on the immediate result of &lt;a href=&quot;create-coroutine-unintercepted#kotlin.coroutines.intrinsics%24createCoroutineUnintercepted%28kotlin.coroutines.SuspendFunction0%28%28kotlin.coroutines.intrinsics.createCoroutineUnintercepted.T%29%29%2C+kotlin.coroutines.Continuation%28%28kotlin.coroutines.intrinsics.createCoroutineUnintercepted.T%29%29%29&quot;&gt;createCoroutineUnintercepted&lt;/a&gt; or &lt;a href=&quot;suspend-coroutine-unintercepted-or-return&quot;&gt;suspendCoroutineUninterceptedOrReturn&lt;/a&gt;, in which case it checks for &lt;a href=&quot;../kotlin.coroutines/-continuation-interceptor/index&quot;&gt;ContinuationInterceptor&lt;/a&gt; in the continuation's &lt;a href=&quot;../kotlin.coroutines/-continuation/context&quot;&gt;context&lt;/a&gt;, invokes &lt;a href=&quot;../kotlin.coroutines/-continuation-interceptor/intercept-continuation&quot;&gt;ContinuationInterceptor.interceptContinuation&lt;/a&gt;, caches and returns the result.</source>
          <target state="translated">此函数应在&lt;a href=&quot;create-coroutine-unintercepted#kotlin.coroutines.intrinsics%24createCoroutineUnintercepted%28kotlin.coroutines.SuspendFunction0%28%28kotlin.coroutines.intrinsics.createCoroutineUnintercepted.T%29%29%2C+kotlin.coroutines.Continuation%28%28kotlin.coroutines.intrinsics.createCoroutineUnintercepted.T%29%29%29&quot;&gt;createCoroutineUnintercepted&lt;/a&gt;或&lt;a href=&quot;suspend-coroutine-unintercepted-or-return&quot;&gt;suspendCoroutineUninterceptedOrReturn&lt;/a&gt;的立即结果上使用，在这种情况下，它将在延续的&lt;a href=&quot;../kotlin.coroutines/-continuation/context&quot;&gt;上下文中&lt;/a&gt;检查&lt;a href=&quot;../kotlin.coroutines/-continuation-interceptor/index&quot;&gt;ContinuationInterceptor&lt;/a&gt;，调用&lt;a href=&quot;../kotlin.coroutines/-continuation-interceptor/intercept-continuation&quot;&gt;ContinuationInterceptor.interceptContinuation&lt;/a&gt;，缓存并返回结果。</target>
        </trans-unit>
        <trans-unit id="e65f4539a9086004cb5d3a889baf0f098ccd5d4a" translate="yes" xml:space="preserve">
          <source>This function shall be used on the immediate result of &lt;a href=&quot;create-coroutine-unintercepted#kotlin.coroutines.intrinsics%24createCoroutineUnintercepted(kotlin.coroutines.SuspendFunction0((kotlin.coroutines.intrinsics.createCoroutineUnintercepted.T)),%20kotlin.coroutines.Continuation((kotlin.coroutines.intrinsics.createCoroutineUnintercepted.T)))&quot;&gt;createCoroutineUnintercepted&lt;/a&gt; or &lt;a href=&quot;suspend-coroutine-unintercepted-or-return&quot;&gt;suspendCoroutineUninterceptedOrReturn&lt;/a&gt;, in which case it checks for &lt;a href=&quot;../kotlin.coroutines/-continuation-interceptor/index&quot;&gt;ContinuationInterceptor&lt;/a&gt; in the continuation's &lt;a href=&quot;../kotlin.coroutines/-continuation/context&quot;&gt;context&lt;/a&gt;, invokes &lt;a href=&quot;../kotlin.coroutines/-continuation-interceptor/intercept-continuation&quot;&gt;ContinuationInterceptor.interceptContinuation&lt;/a&gt;, caches and returns the result.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b0e3ac4cd4df41a67feb4ab61ba294bec022bac" translate="yes" xml:space="preserve">
          <source>This function takes one parameter named &lt;code&gt;init&lt;/code&gt;, which is itself a function. The type of the function is &lt;code&gt;HTML.() -&amp;gt; Unit&lt;/code&gt;, which is a &lt;em&gt;function type with receiver&lt;/em&gt;. This means that we need to pass an instance of type &lt;code&gt;HTML&lt;/code&gt; (a &lt;em&gt;receiver&lt;/em&gt;) to the function, and we can call members of that instance inside the function. The receiver can be accessed through the &lt;em&gt;this&lt;/em&gt; keyword:</source>
          <target state="translated">此函数采用一个名为 &lt;code&gt;init&lt;/code&gt; 的参数，该参数本身就是一个函数。函数的类型是 &lt;code&gt;HTML.() -&amp;gt; Unit&lt;/code&gt; ，这是&lt;em&gt;带有接收器&lt;/em&gt;的&lt;em&gt;函数类型&lt;/em&gt;。这意味着我们需要将 &lt;code&gt;HTML&lt;/code&gt; 类型的实例（&lt;em&gt;接收器&lt;/em&gt;）传递给函数，并且可以在函数内部调用该实例的成员。可以通过&lt;em&gt;以下&lt;/em&gt;关键字访问接收方：</target>
        </trans-unit>
        <trans-unit id="675aeac2a918c6d6c8b4beafdddac2cf6431511b" translate="yes" xml:space="preserve">
          <source>This illustrates several important points:</source>
          <target state="translated">这说明了几个重要的问题。</target>
        </trans-unit>
        <trans-unit id="42ded97c96158badfa6b51ddc24bd9a63c6cca70" translate="yes" xml:space="preserve">
          <source>This implementation doesn't provide a way to manage capacity, as backing JS array is resizeable itself. There is no speed advantage to pre-allocating array sizes in JavaScript, so this implementation does not include any of the capacity and &quot;growth increment&quot; concepts.</source>
          <target state="translated">这个实现并没有提供管理容量的方法,因为支持JS数组本身是可以调整大小的。在JavaScript中预分配数组大小在速度上没有优势,所以这个实现不包含任何容量和 &quot;增长增量 &quot;的概念。</target>
        </trans-unit>
        <trans-unit id="691ede82b3af6046b7651a9c02f4605eaa3ba130" translate="yes" xml:space="preserve">
          <source>This implementation makes no guarantees regarding the order of enumeration of &lt;a href=&quot;../-abstract-mutable-map/keys#kotlin.collections.AbstractMutableMap%24keys&quot;&gt;keys&lt;/a&gt;, &lt;a href=&quot;../-abstract-mutable-map/values#kotlin.collections.AbstractMutableMap%24values&quot;&gt;values&lt;/a&gt; and &lt;a href=&quot;entries#kotlin.collections.HashMap%24entries&quot;&gt;entries&lt;/a&gt; collections.</source>
          <target state="translated">此实现不保证&lt;a href=&quot;../-abstract-mutable-map/keys#kotlin.collections.AbstractMutableMap%24keys&quot;&gt;键&lt;/a&gt;，&lt;a href=&quot;../-abstract-mutable-map/values#kotlin.collections.AbstractMutableMap%24values&quot;&gt;值&lt;/a&gt;和&lt;a href=&quot;entries#kotlin.collections.HashMap%24entries&quot;&gt;条目&lt;/a&gt;集合的枚举顺序。</target>
        </trans-unit>
        <trans-unit id="8ddc3e7d274cee12068e4ad892df6635b0d1615a" translate="yes" xml:space="preserve">
          <source>This implementation preserves the insertion order of elements during the iteration.</source>
          <target state="translated">本实施例在迭代过程中保留了元素的插入顺序。</target>
        </trans-unit>
        <trans-unit id="1edd274f6c90be7cfea12d2c044bc4232b280a23" translate="yes" xml:space="preserve">
          <source>This implicit default value is used when the original map doesn't contain a value for the key specified and a value is obtained with &lt;a href=&quot;get-value&quot;&gt;Map.getValue&lt;/a&gt; function, for example when properties are delegated to the map.</source>
          <target state="translated">当原始地图不包含指定键的值并且使用&lt;a href=&quot;get-value&quot;&gt;Map.getValue&lt;/a&gt;函数获取值时（例如，将属性委派给地图时），将使用此隐式默认值。</target>
        </trans-unit>
        <trans-unit id="410788a84e729541585bfe744595e36fe672b2b8" translate="yes" xml:space="preserve">
          <source>This implies a different way to approach problems and quite a significant shift from what we're using to when writing synchronous code. One benefit as opposed to Futures is that given its ported to so many platforms, generally we can find a consistent API experience no matter what we use it, be it C#, Java, JavaScript, or any other language where Rx is available.</source>
          <target state="translated">这意味着一种不同的处理问题的方式,与我们在编写同步代码时使用的方式有相当大的转变。相对于Futures的一个好处是,鉴于其被移植到了这么多的平台上,一般来说,无论我们使用什么,无论是C#、Java、JavaScript,还是其他任何可以使用Rx的语言,我们都可以找到一致的API体验。</target>
        </trans-unit>
        <trans-unit id="b300e1ecd05ef9cda9c0ccf69cc9b5755628a6bd" translate="yes" xml:space="preserve">
          <source>This imposes certain risks of binary incompatibility caused by changes in the module that declares an inline function in case the calling module is not re-compiled after the change.</source>
          <target state="translated">这就存在一定的二进制不兼容风险,因为声明内联函数的模块发生变化,万一调用模块在变化后没有重新编译,就会造成二进制不兼容。</target>
        </trans-unit>
        <trans-unit id="1c39f73f8778c781fa84c78bdda94d474dac7b9e" translate="yes" xml:space="preserve">
          <source>This in principle feels like a much more elegant solution, but once again has several issues:</source>
          <target state="translated">这在原则上感觉是一个更优雅的解决方案,但又有几个问题。</target>
        </trans-unit>
        <trans-unit id="2dca6747771b3b10d5fd08415bf950f46bdea92f" translate="yes" xml:space="preserve">
          <source>This interface is implemented by floating point ranges returned by &lt;a href=&quot;../range-to&quot;&gt;Float.rangeTo&lt;/a&gt; and &lt;a href=&quot;../range-to&quot;&gt;Double.rangeTo&lt;/a&gt; operators to achieve IEEE-754 comparison order instead of total order of floating point numbers.</source>
          <target state="translated">此接口由&lt;a href=&quot;../range-to&quot;&gt;Float.rangeTo&lt;/a&gt;和&lt;a href=&quot;../range-to&quot;&gt;Double.rangeTo&lt;/a&gt;运算符返回的浮点范围实现，以实现IEEE-754比较顺序，而不是浮点数的总顺序。</target>
        </trans-unit>
        <trans-unit id="b9b5668de562d41a3eb7fb59a1bae495ad743bbf" translate="yes" xml:space="preserve">
          <source>This interface is likely to be handled by compiler magic and shouldn't be subtyped by arbitrary classes.</source>
          <target state="translated">这个接口很可能被编译器的魔法处理,不应该被任意类子类型化。</target>
        </trans-unit>
        <trans-unit id="60e87d87b4ef52673d6b6accbe785d16a04f37c9" translate="yes" xml:space="preserve">
          <source>This is a guide on core features of &lt;code&gt;kotlinx.coroutines&lt;/code&gt; with a series of examples, divided up into different topics.</source>
          <target state="translated">这是有关 &lt;code&gt;kotlinx.coroutines&lt;/code&gt; 核心功能的指南，提供了一系列示例，分为不同主题。</target>
        </trans-unit>
        <trans-unit id="df1cdfbf36992d0e353e65acc97d1211d338f55d" translate="yes" xml:space="preserve">
          <source>This is a key reason the &lt;code&gt;simple&lt;/code&gt; function (which returns a flow) is not marked with &lt;code&gt;suspend&lt;/code&gt; modifier. By itself, &lt;code&gt;simple()&lt;/code&gt; call returns quickly and does not wait for anything. The flow starts every time it is collected, that is why we see &quot;Flow started&quot; when we call &lt;code&gt;collect&lt;/code&gt; again.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c933ba19b81dc6ad55a2c69193b755c303d2100a" translate="yes" xml:space="preserve">
          <source>This is a little better, but we have no or little help from the powerful code completion of the IDE. It would be so much better if we could say:</source>
          <target state="translated">这样做是好了一点,但是我们没有或者说没有得到IDE强大的代码完成的帮助。如果我们能说,那就好多了。</target>
        </trans-unit>
        <trans-unit id="da401b98d9be6d7ebaac9172cbd4241fbf6ba27c" translate="yes" xml:space="preserve">
          <source>This is also a way to write unit tests for suspending functions:</source>
          <target state="translated">这也是为暂停函数编写单元测试的一种方式。</target>
        </trans-unit>
        <trans-unit id="64ed768079e9d5cbdb933e9c19824b5132acfb30" translate="yes" xml:space="preserve">
          <source>This is an experimental API. Given a class for a compiled Kotlin lambda or a function expression, returns a &lt;a href=&quot;../-k-function/index#kotlin.reflect.KFunction&quot;&gt;KFunction&lt;/a&gt; instance providing introspection capabilities for that lambda or function expression and its parameters. Not all features are currently supported, in particular KCallable.call and KCallable.callBy will fail at the moment.</source>
          <target state="translated">这是一个实验性的API。给定已编译Kotlin lambda或函数表达式的类，则返回&lt;a href=&quot;../-k-function/index#kotlin.reflect.KFunction&quot;&gt;KFunction&lt;/a&gt;实例，该实例为该lambda或函数表达式及其参数提供自省功能。当前尚不支持所有功能，尤其是KCallable.call和KCallable.callBy目前将失败。</target>
        </trans-unit>
        <trans-unit id="109dcae61144497c38fcb7128f4fde954a0b0dab" translate="yes" xml:space="preserve">
          <source>This is an experimental API. Given a class for a compiled Kotlin lambda or a function expression, returns a &lt;a href=&quot;../kotlin.reflect/-k-function/index#kotlin.reflect.KFunction&quot;&gt;KFunction&lt;/a&gt; instance providing introspection capabilities for that lambda or function expression and its parameters. Not all features are currently supported, in particular KCallable.call and KCallable.callBy will fail at the moment.</source>
          <target state="translated">这是一个实验性的API。给定已编译Kotlin lambda或函数表达式的类，则返回&lt;a href=&quot;../kotlin.reflect/-k-function/index#kotlin.reflect.KFunction&quot;&gt;KFunction&lt;/a&gt;实例，该实例为该lambda或函数表达式及其参数提供自省功能。当前尚不支持所有功能，尤其是KCallable.call和KCallable.callBy目前将失败。</target>
        </trans-unit>
        <trans-unit id="1275ac7243b73ff90c0cce870f1cace4805d6b9b" translate="yes" xml:space="preserve">
          <source>This is an experimental API. Given a class for a compiled Kotlin lambda or a function expression, returns a &lt;a href=&quot;index#kotlin.reflect.KFunction&quot;&gt;KFunction&lt;/a&gt; instance providing introspection capabilities for that lambda or function expression and its parameters. Not all features are currently supported, in particular KCallable.call and KCallable.callBy will fail at the moment.</source>
          <target state="translated">这是一个实验性的API。给定已编译Kotlin lambda或函数表达式的类，则返回&lt;a href=&quot;index#kotlin.reflect.KFunction&quot;&gt;KFunction&lt;/a&gt;实例，该实例为该lambda或函数表达式及其参数提供自省功能。当前尚不支持所有功能，尤其是KCallable.call和KCallable.callBy目前将失败。</target>
        </trans-unit>
        <trans-unit id="56ff2e2058e67cead5d0e1ef36c3683a6dd863f0" translate="yes" xml:space="preserve">
          <source>This is an experimental function that behaves as a similar function from kotlin.reflect.full on JVM.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bbf054c69a799b1f208427023936248eccf48ba6" translate="yes" xml:space="preserve">
          <source>This is because we are not inside any coroutine. We can use delay if we wrap it into &lt;code&gt;runBlocking {}&lt;/code&gt; that starts a coroutine and waits until it's done:</source>
          <target state="translated">这是因为我们不在任何协程内部。如果将延迟包装到 &lt;code&gt;runBlocking {}&lt;/code&gt; 协程并等待完成的runBlocking {}中，则可以使用延迟：</target>
        </trans-unit>
        <trans-unit id="89a3c5e95e199bf51561c58886a8d92c513c9cea" translate="yes" xml:space="preserve">
          <source>This is called an &lt;em&gt;object declaration&lt;/em&gt;, and it always has a name following the &lt;em&gt;object&lt;/em&gt; keyword. Just like a variable declaration, an object declaration is not an expression, and cannot be used on the right hand side of an assignment statement.</source>
          <target state="translated">这称为&lt;em&gt;对象声明&lt;/em&gt;，它始终在&lt;em&gt;object&lt;/em&gt;关键字之后有一个名称。就像变量声明一样，对象声明也不是表达式，并且不能在赋值语句的右侧使用。</target>
        </trans-unit>
        <trans-unit id="0f25f0b9ab280fe3c292330ad8e1771dad21395c" translate="yes" xml:space="preserve">
          <source>This is completely legitimate Kotlin code. You can play with this code online (modify it and run in the browser) &lt;a href=&quot;https://play.kotlinlang.org/byExample/09_Kotlin_JS/06_HtmlBuilder&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">这是完全合法的Kotlin代码。您可以在&lt;a href=&quot;https://play.kotlinlang.org/byExample/09_Kotlin_JS/06_HtmlBuilder&quot;&gt;此处&lt;/a&gt;在线使用此代码（对其进行修改并在浏览器中运行）。</target>
        </trans-unit>
        <trans-unit id="3ddd6e3de1f5a28a90747db03b48c3a1e5c746b0" translate="yes" xml:space="preserve">
          <source>This is different from adjusting &lt;code&gt;webpackTask.output.libraryTarget&lt;/code&gt;. The library target changes the output &lt;em&gt;generated by webpack&lt;/em&gt; (after your code has already been compiled). &lt;code&gt;kotlinOptions.moduleKind&lt;/code&gt; changes the output generated &lt;em&gt;by the Kotlin compiler&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e75165bd6c0c435e57a13f622ac0560e9f8aea5" translate="yes" xml:space="preserve">
          <source>This is equivalent to</source>
          <target state="translated">这相当于</target>
        </trans-unit>
        <trans-unit id="9f70cf8ecc85c3e0ff05ae57878985a9c7914959" translate="yes" xml:space="preserve">
          <source>This is especially helpful if you use multi-line syntax for parameters or values. After adding a trailing comma, you can then easily swap lines with parameters or values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cafbcd266b45a7c72452995f54470aa36c3c74c4" translate="yes" xml:space="preserve">
          <source>This is how Kotlin Multiplatform works.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1b5d12f5c0ad6b8f02b5702175b995f5f4555de" translate="yes" xml:space="preserve">
          <source>This is how the package &lt;code&gt;com.example.html&lt;/code&gt; is defined (only the elements used in the example above). It builds an HTML tree. It makes heavy use of &lt;a href=&quot;extensions&quot;&gt;extension functions&lt;/a&gt; and &lt;a href=&quot;lambdas#function-literals-with-receiver&quot;&gt;lambdas with receiver&lt;/a&gt;.</source>
          <target state="translated">这就是 &lt;code&gt;com.example.html&lt;/code&gt; 包的定义方式（仅上述示例中使用的元素）。它构建一个HTML树。它大量使用&lt;a href=&quot;extensions&quot;&gt;扩展功能&lt;/a&gt;和&lt;a href=&quot;lambdas#function-literals-with-receiver&quot;&gt;带有接收器的lambda&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="eb4b287b1edf1ba23dd84510aa2e475b62f2bf92" translate="yes" xml:space="preserve">
          <source>This is how the same function looks without the standard library functions:</source>
          <target state="translated">这就是同样的函数在没有标准库函数的情况下的样子。</target>
        </trans-unit>
        <trans-unit id="be45b011252e2fb8cf7402a94a29a95e7994751a" translate="yes" xml:space="preserve">
          <source>This is not applicable when you compile your Kotlin module to JavaScript module (see &lt;a href=&quot;js-modules&quot;&gt;JavaScript Modules&lt;/a&gt; for more information on this). In this case there won't be a wrapper object, instead, declarations will be exposed as a JavaScript module of a corresponding kind. For example, in case of CommonJS you should write:</source>
          <target state="translated">当您将Kotlin模块编译为JavaScript模块时，此方法不适用（有关此信息，请参阅&lt;a href=&quot;js-modules&quot;&gt;JavaScript模块&lt;/a&gt;）。在这种情况下，将没有包装对象，相反，声明将作为相应类型的JavaScript模块公开。例如，对于CommonJS，您应该编写：</target>
        </trans-unit>
        <trans-unit id="9ac1b203334ec097b223fccc93d140d76e0239d4" translate="yes" xml:space="preserve">
          <source>This is not applicable when you compile your Kotlin module to JavaScript modules like UMD (which is the default setting for both &lt;code&gt;browser&lt;/code&gt; and &lt;code&gt;nodejs&lt;/code&gt; targets), CommonJS or AMD. In this case, your declarations will be exposed in the format specified by your chosen JavaScript module system. When using UMD or CommonJS, for example, your call site could look like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16ae8412e011bd154f0f6ed0d14afcc433a50b3b" translate="yes" xml:space="preserve">
          <source>This is not required when using Kotlin Gradle plugin 1.1.1 and above with the &lt;a href=&quot;https://docs.gradle.org/current/userguide/plugins.html#sec:plugins_block&quot;&gt;Gradle plugins DSL&lt;/a&gt;, and with &lt;a href=&quot;https://github.com/gradle/kotlin-dsl&quot;&gt;Gradle Kotlin DSL&lt;/a&gt;.</source>
          <target state="translated">当将Kotlin Gradle插件1.1.1及更高版本与&lt;a href=&quot;https://docs.gradle.org/current/userguide/plugins.html#sec:plugins_block&quot;&gt;Gradle插件DSL&lt;/a&gt;以及&lt;a href=&quot;https://github.com/gradle/kotlin-dsl&quot;&gt;Gradle Kotlin DSL&lt;/a&gt;结合使用时，不需要这样做。</target>
        </trans-unit>
        <trans-unit id="04267f944435e1968a98920e69ed6ee93ce59d4b" translate="yes" xml:space="preserve">
          <source>This is one expression in all three languages:</source>
          <target state="translated">这是三种语言中的一种表述。</target>
        </trans-unit>
        <trans-unit id="6b9969b7447679a0aefde827887c1e2aff85957c" translate="yes" xml:space="preserve">
          <source>This is one expression in both Kotlin (because the first line doesn't parse on its own) and JavaScript, and doesn't parse in Python:</source>
          <target state="translated">这在Kotlin(因为第一行自己不解析)和JavaScript中都是一个表达式,在Python中不解析。</target>
        </trans-unit>
        <trans-unit id="0e08018d2743eaf233d0fdb2fc751af52fc3dee8" translate="yes" xml:space="preserve">
          <source>This is only the beginning and a small example of Kotlin code sharing between iOS and Android (and other platforms) with Kotlin, Kotlin/Native and Kotlin multiplatform projects. The same approach works for real applications, independent of their size or complexity.</source>
          <target state="translated">这只是iOS和Android(以及其他平台)之间Kotlin代码共享的一个开始和小例子,有Kotlin、Kotlin/Native和Kotlin多平台项目。同样的方法也适用于真实的应用程序,无论其大小或复杂程度如何。</target>
        </trans-unit>
        <trans-unit id="556b42ba8780522a3f90da067d375baba3a8ad1d" translate="yes" xml:space="preserve">
          <source>This is particularly important for Android developers, since the compiler can now correctly analyze generic &lt;code&gt;findViewById&lt;/code&gt; calls in Android API level 26:</source>
          <target state="translated">这对于Android开发人员尤其重要，因为编译器现在可以正确分析Android API级别26中的常规 &lt;code&gt;findViewById&lt;/code&gt; 调用：</target>
        </trans-unit>
        <trans-unit id="e920053f53e4a61b09848006ad0bfc26918d5a11" translate="yes" xml:space="preserve">
          <source>This is provided only for convenience; you don't have to extend this interface as long as your delegate provider has a method with the same signature.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="995a44882385c48d93df496a6a80eaaa6c26f44a" translate="yes" xml:space="preserve">
          <source>This is provided only for convenience; you don't have to extend this interface as long as your property delegate has methods with the same signatures.</source>
          <target state="translated">这只是为了方便而提供的,只要你的属性委托人有相同签名的方法,你就不必扩展这个接口。</target>
        </trans-unit>
        <trans-unit id="64b2fb3aa48fe9872cab0264ea29aacf2838772b" translate="yes" xml:space="preserve">
          <source>This is the JS code generated for the Kotlin code above (the &lt;code&gt;main&lt;/code&gt; function). Let's have a closer look at it.</source>
          <target state="translated">这是为上面的Kotlin代码（ &lt;code&gt;main&lt;/code&gt; 功能）生成的JS代码。让我们仔细看看。</target>
        </trans-unit>
        <trans-unit id="61af108c05fdc7b4a1413c5ee9cd9367a036a611" translate="yes" xml:space="preserve">
          <source>This is the fastest solution for this particular problem. It works for plain counters, collections, queues and other standard data structures and basic operations on them. However, it does not easily scale to complex state or to complex operations that do not have ready-to-use thread-safe implementations.</source>
          <target state="translated">这是解决这个特殊问题的最快方案。它适用于普通计数器、集合、队列和其他标准数据结构以及对它们的基本操作。然而,它不容易扩展到复杂的状态或没有现成的线程安全实现的复杂操作。</target>
        </trans-unit>
        <trans-unit id="fa369ec473906917e945918ae4ca55d8b5858ee4" translate="yes" xml:space="preserve">
          <source>This is the last tutorial in the series. The first tutorial of the series is &lt;a href=&quot;mapping-primitive-data-types-from-c&quot;&gt;Mapping Primitive Data Types from C&lt;/a&gt;. There are also &lt;a href=&quot;mapping-struct-union-types-from-c&quot;&gt;Mapping Struct and Union Types from C&lt;/a&gt; and &lt;a href=&quot;mapping-function-pointers-from-c&quot;&gt;Mapping Function Pointers from C&lt;/a&gt; tutorials.</source>
          <target state="translated">这是本系列的最后一篇教程。该系列的第一个教程是&lt;a href=&quot;mapping-primitive-data-types-from-c&quot;&gt;从C映射原始数据类型&lt;/a&gt;。也有&lt;a href=&quot;mapping-function-pointers-from-c&quot;&gt;C&lt;/a&gt;教程中的&lt;a href=&quot;mapping-struct-union-types-from-c&quot;&gt;Mapping Struct和Union Type&lt;/a&gt;和C教程中的Mapping Function Pointer。</target>
        </trans-unit>
        <trans-unit id="db342e5eb9179bc09fc429165b10a1574cb68d62" translate="yes" xml:space="preserve">
          <source>This is the main feature of inline classes, which inspired the name &quot;inline&quot;: data of the class is &quot;inlined&quot; into its usages (similar to how content of &lt;a href=&quot;inline-functions&quot;&gt;inline functions&lt;/a&gt; is inlined to call sites).</source>
          <target state="translated">这是内联类的主要特征，它启发了&amp;ldquo;内联&amp;rdquo;的名称：该类的数据被&amp;ldquo;内联&amp;rdquo;到其用法中（类似于&lt;a href=&quot;inline-functions&quot;&gt;内联函数的&lt;/a&gt;内容内联到调用站点的方式）。</target>
        </trans-unit>
        <trans-unit id="e191f2b52800fbe76b7db487772b3a907bdf44b0" translate="yes" xml:space="preserve">
          <source>This is the second post in the series. The very first tutorial of the series is &lt;a href=&quot;mapping-primitive-data-types-from-c&quot;&gt;Mapping Primitive Data Types from C&lt;/a&gt;. There are also the &lt;a href=&quot;mapping-function-pointers-from-c&quot;&gt;Mapping Function Pointers from C&lt;/a&gt; and &lt;a href=&quot;mapping-strings-from-c&quot;&gt;Mapping Strings from C&lt;/a&gt; tutorials.</source>
          <target state="translated">这是该系列的第二篇文章。该系列的第一个教程是&lt;a href=&quot;mapping-primitive-data-types-from-c&quot;&gt;从C映射原始数据类型&lt;/a&gt;。还有&lt;a href=&quot;mapping-function-pointers-from-c&quot;&gt;C语言&lt;/a&gt;的Mapping Function Pointer和&lt;a href=&quot;mapping-strings-from-c&quot;&gt;C语言&lt;/a&gt;教程的Mapping Strings。</target>
        </trans-unit>
        <trans-unit id="9d714ceb3667c2a2d840d8a543c7e66ce3d058a3" translate="yes" xml:space="preserve">
          <source>This is the third post in the series. The very first tutorial is &lt;a href=&quot;mapping-primitive-data-types-from-c&quot;&gt;Mapping Primitive Data Types from C&lt;/a&gt;. There are also &lt;a href=&quot;mapping-struct-union-types-from-c&quot;&gt;Mapping Struct and Union Types from C&lt;/a&gt; and &lt;a href=&quot;mapping-strings-from-c&quot;&gt;Mapping Strings from C&lt;/a&gt; tutorials.</source>
          <target state="translated">这是该系列的第三篇文章。第一个教程是&lt;a href=&quot;mapping-primitive-data-types-from-c&quot;&gt;从C映射原始数据类型&lt;/a&gt;。也有&lt;a href=&quot;mapping-strings-from-c&quot;&gt;C&lt;/a&gt;教程中的&lt;a href=&quot;mapping-struct-union-types-from-c&quot;&gt;Mapping Struct和Union Type&lt;/a&gt;和C教程中的Mapping Strings。</target>
        </trans-unit>
        <trans-unit id="4b1e08d2ab9bc443d4e794dd876f58764cb1b59a" translate="yes" xml:space="preserve">
          <source>This is true for a division between any two integer types.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1cdf86b607345251afe79fd6fc9f04693b54a221" translate="yes" xml:space="preserve">
          <source>This is twice as fast, because the two coroutines execute concurrently. Note that concurrency with coroutines is always explicit.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2ad8f555f0fd0b81fe583ef82f57587da754391" translate="yes" xml:space="preserve">
          <source>This is twice as fast, because we have concurrent execution of two coroutines. Note that concurrency with coroutines is always explicit.</source>
          <target state="translated">这是速度的两倍,因为我们有两个coroutine的并发执行。注意,coroutine的并发总是显式的。</target>
        </trans-unit>
        <trans-unit id="71c1af27d3f71a4b285ff3d26289c1fc97691cf8" translate="yes" xml:space="preserve">
          <source>This is useful for configuring properties that aren't present in the object constructor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92b4fd5ae8a5154b1a5e18bb911000880c41554c" translate="yes" xml:space="preserve">
          <source>This lets Android Studio know that the kotlin directory is a source root, so when the project model is loaded into the IDE it will be properly recognized. Alternatively, you can put Kotlin classes in the Java source directory, typically located in &lt;code&gt;src/main/java&lt;/code&gt;.</source>
          <target state="translated">这使Android Studio知道kotlin目录是源根目录，因此当将项目模型加载到IDE中时，它将被正确识别。另外，您可以将Kotlin类放在Java源目录中，该目录通常位于 &lt;code&gt;src/main/java&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="736ca34cfc08c91c8fd20715eb24479a73c79bdf" translate="yes" xml:space="preserve">
          <source>This library is published to Bintray JCenter repository, so let us add it:</source>
          <target state="translated">该库已发布到Bintray JCenter库中,让我们来添加它。</target>
        </trans-unit>
        <trans-unit id="898c5a35f84b96626909c79797c0f501c038d6e4" translate="yes" xml:space="preserve">
          <source>This list has size of &lt;code&gt;groupCount + 1&lt;/code&gt; where &lt;code&gt;groupCount&lt;/code&gt; is the count of groups in the regular expression. Groups are indexed from 1 to &lt;code&gt;groupCount&lt;/code&gt; and group with the index 0 corresponds to the entire match.</source>
          <target state="translated">此列表的大小为 &lt;code&gt;groupCount + 1&lt;/code&gt; ，其中 &lt;code&gt;groupCount&lt;/code&gt; 是正则表达式中的组数。组从1到 &lt;code&gt;groupCount&lt;/code&gt; 进行索引，索引为0的组与整个匹配相对应。</target>
        </trans-unit>
        <trans-unit id="d9cbb7f39883f90a51ea7e495265c7bc108e6a66" translate="yes" xml:space="preserve">
          <source>This made it easy to &lt;a href=&quot;mpp-share-on-platforms#share-code-on-all-platforms&quot;&gt;share code on all platforms&lt;/a&gt;, but it was not so easy to &lt;a href=&quot;mpp-share-on-platforms#share-code-on-similar-platforms&quot;&gt;share between only some of the targets&lt;/a&gt;, especially similar ones that could potentially reuse a lot of the common logic and third-party APIs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4bdb3ec74f6932b33fd8d2d9d59b4f6dd5cdc88a" translate="yes" xml:space="preserve">
          <source>This marker distinguishes the experimental contract declaration API and is used to opt-in for that feature when declaring contracts of user functions.</source>
          <target state="translated">这个标记区分了实验性的合同声明API,用于在声明用户函数的合同时选择加入该功能。</target>
        </trans-unit>
        <trans-unit id="180f1cb299276ef1bdc5f464e18d2794e7d742af" translate="yes" xml:space="preserve">
          <source>This may be useful in the following cases:</source>
          <target state="translated">这在以下情况下可能有用:</target>
        </trans-unit>
        <trans-unit id="fe068972b66d6d75ef4966c9005153d1f9eaed4c" translate="yes" xml:space="preserve">
          <source>This may be useful, for example, when you want to rename a property in a backward-compatible way: you introduce a new property, annotate the old one with the &lt;code&gt;@Deprecated&lt;/code&gt; annotation, and delegate its implementation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13bd4b9a1ff3829dff4d0473f506ce883108b5a3" translate="yes" xml:space="preserve">
          <source>This means that there's a library in the classpath which does not depend on the Kotlin standard library as a Gradle/Maven dependency, but is distributed in the same artifact with it (i.e. has it &lt;em&gt;bundled&lt;/em&gt;). Such a library may cause issues because standard build tools do not consider it an instance of the Kotlin standard library, thus it's not subject to the dependency version resolution mechanisms, and you can end up with several versions of the same library in the classpath. Consider contacting the authors of such a library and suggesting to use the Gradle/Maven dependency instead.</source>
          <target state="translated">这意味着在类路径中有一个库，该库不依赖Kotlin标准库作为Gradle / Maven依赖项，而是与它一起分布在同一工件中（即，将其&lt;em&gt;捆绑在一起&lt;/em&gt;）。这样的库可能会引起问题，因为标准构建工具不会将其视为Kotlin标准库的实例，因此它不受依赖版本解析机制的影响，并且最终可以在类路径中获得同一库的多个版本。考虑联系此类库的作者，并建议改用Gradle / Maven依赖项。</target>
        </trans-unit>
        <trans-unit id="6cde525aeab8f8f490a4ed99ff83215b05165a70" translate="yes" xml:space="preserve">
          <source>This means that you have a dependency on libraries of different versions, for example the 1.1 standard library and the 1.0 reflection library. To prevent subtle errors at runtime, we recommend you to use the same version of all Kotlin libraries. In this case, consider adding an explicit dependency on the 1.1 reflection library.</source>
          <target state="translated">这意味着你对不同版本的库有依赖性,例如1.1标准库和1.0反射库。为了防止在运行时出现微妙的错误,我们建议你使用所有Kotlin库的相同版本。在这种情况下,可以考虑在1.1反射库上添加一个显式依赖。</target>
        </trans-unit>
        <trans-unit id="17a60d9a927ab40397189c8d1b96e5f7c53d044e" translate="yes" xml:space="preserve">
          <source>This means that you're using the Kotlin compiler 1.1 against the standard or reflection library of version 1.0. This can be handled in different ways:</source>
          <target state="translated">这意味着你使用的Kotlin编译器1.1是针对1.0版本的标准库或反射库。这可以用不同的方式来处理。</target>
        </trans-unit>
        <trans-unit id="77369f21aef42d741a8e7d6c6dac5c006f439aba" translate="yes" xml:space="preserve">
          <source>This means you can call &lt;code&gt;myFunWithOptionalArgs&lt;/code&gt; with one required argument and two optional arguments (their default values are calculated by some JavaScript code).</source>
          <target state="translated">这意味着您可以使用一个必需的参数和两个可选的参数（它们的默认值由某些JavaScript代码计算）来调用 &lt;code&gt;myFunWithOptionalArgs&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="448a85fa82c5ef71170374be3303b1bc78bb209c" translate="yes" xml:space="preserve">
          <source>This meta-annotation determines that an annotation is a part of public API and therefore should be included in the generated documentation for the element to which the annotation is applied.</source>
          <target state="translated">这个元注解决定了注解是公共API的一部分,因此应该包含在应用注解的元素的生成文档中。</target>
        </trans-unit>
        <trans-unit id="5c594f1e41ee531a1ebc1db1a8ef8742f5fcd14a" translate="yes" xml:space="preserve">
          <source>This meta-annotation determines that an annotation is applicable twice or more on a single code element</source>
          <target state="translated">该元注解确定一个注解在一个代码元素上适用两次或两次以上。</target>
        </trans-unit>
        <trans-unit id="71d0203916dcd2ae084a69342802dae5c434f881" translate="yes" xml:space="preserve">
          <source>This meta-annotation determines whether an annotation is stored in binary output and visible for reflection. By default, both are true.</source>
          <target state="translated">该元注解决定了注解是否存储在二进制输出中,以及是否对反射可见。默认情况下,两者都为真。</target>
        </trans-unit>
        <trans-unit id="a36fadd37607b67a90a001f3c5a13ec3d8698650" translate="yes" xml:space="preserve">
          <source>This meta-annotation indicates the kinds of code elements which are possible targets of an annotation.</source>
          <target state="translated">这个元注解指出了可能成为注解目标的代码元素的种类。</target>
        </trans-unit>
        <trans-unit id="5733089c709664ede5e39a2892f4d97391a8d9f0" translate="yes" xml:space="preserve">
          <source>This method accepts values of &lt;a href=&quot;../kotlin/-short/index#kotlin.Short&quot;&gt;Short&lt;/a&gt; type in range &lt;code&gt;0x00..0xff&lt;/code&gt;, other values are prohibited.</source>
          <target state="translated">此方法接受 &lt;code&gt;0x00..0xff&lt;/code&gt; 范围内的&lt;a href=&quot;../kotlin/-short/index#kotlin.Short&quot;&gt;Short&lt;/a&gt;类型的值，禁止使用其他值。</target>
        </trans-unit>
        <trans-unit id="a75948e2d8c32738a31fd96217f7586ee79f04f4" translate="yes" xml:space="preserve">
          <source>This method allows to use destructuring declarations when working with maps, for example:</source>
          <target state="translated">此方法允许在处理地图时使用解构声明,例如。</target>
        </trans-unit>
        <trans-unit id="5a64298e1d3ab705d641d81b81fea403c6aa3318" translate="yes" xml:space="preserve">
          <source>This method allows to use the &lt;code&gt;x in map&lt;/code&gt; syntax for checking whether an object is contained in the map.</source>
          <target state="translated">此方法允许使用 &lt;code&gt;x in map&lt;/code&gt; 的x语法检查地图中是否包含对象。</target>
        </trans-unit>
        <trans-unit id="96f4999c28f30d3489635a82f469652d71846c62" translate="yes" xml:space="preserve">
          <source>This method guarantees not to put the value into the map if the key is already there, but the &lt;a href=&quot;get-or-put#kotlin.collections%24getOrPut%28java.util.concurrent.ConcurrentMap%28%28kotlin.collections.getOrPut.K%2C+kotlin.collections.getOrPut.V%29%29%2C+kotlin.collections.getOrPut.K%2C+kotlin.Function0%28%28kotlin.collections.getOrPut.V%29%29%29%2FdefaultValue&quot;&gt;defaultValue&lt;/a&gt; function may be invoked even if the key is already in the map.</source>
          <target state="translated">如果键已经在映射中，则此方法保证不将值放入映射中，但是即使键已在映射中，也可以调用&lt;a href=&quot;get-or-put#kotlin.collections%24getOrPut%28java.util.concurrent.ConcurrentMap%28%28kotlin.collections.getOrPut.K%2C+kotlin.collections.getOrPut.V%29%29%2C+kotlin.collections.getOrPut.K%2C+kotlin.Function0%28%28kotlin.collections.getOrPut.V%29%29%29%2FdefaultValue&quot;&gt;defaultValue&lt;/a&gt;函数。</target>
        </trans-unit>
        <trans-unit id="047deaa17bbcb4b085ecd0f5b31fe3d84a681f3f" translate="yes" xml:space="preserve">
          <source>This method guarantees not to put the value into the map if the key is already there, but the &lt;a href=&quot;get-or-put#kotlin.collections%24getOrPut(java.util.concurrent.ConcurrentMap((kotlin.collections.getOrPut.K,%20kotlin.collections.getOrPut.V)),%20kotlin.collections.getOrPut.K,%20kotlin.Function0((kotlin.collections.getOrPut.V)))/defaultValue&quot;&gt;defaultValue&lt;/a&gt; function may be invoked even if the key is already in the map.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="083648bbf3b66e12f1c5e5fd3afa3ff2914dd084" translate="yes" xml:space="preserve">
          <source>This method is not recommended on huge files.</source>
          <target state="translated">对于巨大的文件,不建议使用这种方法。</target>
        </trans-unit>
        <trans-unit id="ecd5e6ce22de7239fac178cb06d85481149c22bf" translate="yes" xml:space="preserve">
          <source>This method is not recommended on huge files. It has an internal limitation of 2 GB byte array size.</source>
          <target state="translated">在巨大的文件上不推荐使用这种方法。它的内部限制是2GB的字节阵列大小。</target>
        </trans-unit>
        <trans-unit id="ecfd9cc7f27ed3b4efbb7dd03aebaf75912a636e" translate="yes" xml:space="preserve">
          <source>This method is not recommended on huge files. It has an internal limitation of 2 GB file size.</source>
          <target state="translated">此方法不推荐用于巨大的文件。它的内部限制是2GB的文件大小。</target>
        </trans-unit>
        <trans-unit id="43901fb40d645ef2b68c677a55d2f926ea8ed530" translate="yes" xml:space="preserve">
          <source>This method is redeclared as abstract, because it's not implemented in the base class, so it must be always overridden in the concrete mutable collection implementation.</source>
          <target state="translated">这个方法被重新声明为抽象的,因为它没有在基类中实现,所以它必须在具体的可变集合实现中始终被重写。</target>
        </trans-unit>
        <trans-unit id="f25f95428ac465fef329ee7b3944fdbec35af43f" translate="yes" xml:space="preserve">
          <source>This mode should not be used unless the &lt;a href=&quot;../-lazy/index&quot;&gt;Lazy&lt;/a&gt; instance is guaranteed never to be initialized from more than one thread.</source>
          <target state="translated">除非保证永不从多个线程初始化&lt;a href=&quot;../-lazy/index&quot;&gt;Lazy&lt;/a&gt;实例，否则不应使用此模式。</target>
        </trans-unit>
        <trans-unit id="6446cf4cb49ffcb2caf4afcf619d26541516a151" translate="yes" xml:space="preserve">
          <source>This name can be used to access the binary:</source>
          <target state="translated">这个名字可以用来访问二进制。</target>
        </trans-unit>
        <trans-unit id="acb387fd4daeff721899d12634f06c3c11719a1e" translate="yes" xml:space="preserve">
          <source>This now works much faster and produces correct result.</source>
          <target state="translated">现在工作速度更快,并产生正确的结果。</target>
        </trans-unit>
        <trans-unit id="da4dbc68402bb11c32b149d461913452ae42bef5" translate="yes" xml:space="preserve">
          <source>This operator should not be used from inside of &lt;a href=&quot;-deep-recursive-scope/index&quot;&gt;DeepRecursiveScope&lt;/a&gt; as it uses the call stack slot for initial recursive invocation. From inside of &lt;a href=&quot;-deep-recursive-scope/index&quot;&gt;DeepRecursiveScope&lt;/a&gt; use &lt;a href=&quot;-deep-recursive-scope/call-recursive&quot;&gt;callRecursive&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08d7f6ce5ec74ffd1dae5f3e2a4e554fa93562ae" translate="yes" xml:space="preserve">
          <source>This page contains the current coding style for the Kotlin language.</source>
          <target state="translated">本页包含当前Kotlin语言的编码风格。</target>
        </trans-unit>
        <trans-unit id="d592b749bb8c59614b5bce1df54bbaa180a699f7" translate="yes" xml:space="preserve">
          <source>This plugin only works for Kotlin files so it is recommended that you keep Kotlin and Java files separately (in case the project contains Java files). If you don't store them separately , specify the source folder in the &lt;code&gt;sourceSets&lt;/code&gt; block:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b0d3b6a365feefc5bf2639481a27bf15df77f32" translate="yes" xml:space="preserve">
          <source>This plugin only works for Kotlin files so it is recommended to keep Kotlin and Java files separate (in case if the same project contains Java files). As with targeting the JVM, if not using the default convention, you should specify the source folder using &lt;em&gt;sourceSets&lt;/em&gt;:</source>
          <target state="translated">该插件仅适用于Kotlin文件，因此建议将Kotlin和Java文件分开（以防同一项目包含Java文件）。与定位JVM一样，如果不使用默认约定，则应使用&lt;em&gt;sourceSets&lt;/em&gt;指定源文件夹：</target>
        </trans-unit>
        <trans-unit id="2d1dbfb5aeb4d13de4e43c69f4da833e8295308f" translate="yes" xml:space="preserve">
          <source>This podspec file can be referenced from a &lt;a href=&quot;https://guides.cocoapods.org/using/the-podfile.html&quot;&gt;Podfile&lt;/a&gt; of an Xcode project. After that the framework built from the Kotlin/Native module can be used from this Xcode project. If necessary, this framework is automatically rebuilt during Xcode build process.</source>
          <target state="translated">可以从Xcode项目的&lt;a href=&quot;https://guides.cocoapods.org/using/the-podfile.html&quot;&gt;Podfile&lt;/a&gt;中引用此podspec文件。之后，可以从此Xcode项目中使用从Kotlin / Native模块构建的框架。如有必要，可以在Xcode构建过程中自动重建此框架。</target>
        </trans-unit>
        <trans-unit id="30a2879d5d48273acab2ab3a9f22c1edf08032e3" translate="yes" xml:space="preserve">
          <source>This prints</source>
          <target state="translated">此印刷品</target>
        </trans-unit>
        <trans-unit id="345205710c1209079bdf05b4d146f25fe0a01f36" translate="yes" xml:space="preserve">
          <source>This prints:</source>
          <target state="translated">这个指纹。</target>
        </trans-unit>
        <trans-unit id="ebe525fb027f139b406ffe6decdd11bbf6d8b5bb" translate="yes" xml:space="preserve">
          <source>This programming style with async functions is provided here only for illustration, because it is a popular style in other programming languages. Using this style with Kotlin coroutines is &lt;strong&gt;strongly discouraged&lt;/strong&gt; for the reasons explained below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cda4b457c77664242055b4741cc46d64c55f08a1" translate="yes" xml:space="preserve">
          <source>This programming style with async functions is provided here only for illustration, because it is a popular style in other programming languages. Using this style with Kotlin coroutines is &lt;strong&gt;strongly discouraged&lt;/strong&gt; for the reasons that are explained below.</source>
          <target state="translated">具有异步功能的这种编程样式仅在此处提供说明，因为它是其他编程语言中的一种流行样式。&lt;strong&gt;强烈建议不要&lt;/strong&gt;将这种样式与Kotlin协程一起使用，原因如下。</target>
        </trans-unit>
        <trans-unit id="77b890076daadde689d1ec3897dcc482dac8e326" translate="yes" xml:space="preserve">
          <source>This property can be used in two cases:</source>
          <target state="translated">这个属性可以在两种情况下使用。</target>
        </trans-unit>
        <trans-unit id="ff03394cef9f3232cd16286e35c99b97f61a20fd" translate="yes" xml:space="preserve">
          <source>This property can't be used from normal code.</source>
          <target state="translated">此属性不能从普通代码中使用。</target>
        </trans-unit>
        <trans-unit id="c7c3d50d77ba7c2fef150fd01d7bd663fd6396e5" translate="yes" xml:space="preserve">
          <source>This property is currently not supported in Kotlin/JS.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2196c6e17a412a106531ad1fc581b412f9389ab" translate="yes" xml:space="preserve">
          <source>This property of a flow is called &lt;em&gt;context preservation&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5517f3de5c3954c1997a06c521c60c838cdab23" translate="yes" xml:space="preserve">
          <source>This protected method should be overridden to return the current reading of the time source expressed as a &lt;a href=&quot;../../kotlin/-double/index#kotlin.Double&quot;&gt;Double&lt;/a&gt; number in the unit specified by the &lt;a href=&quot;unit&quot;&gt;unit&lt;/a&gt; property.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28f6dba9afcf9e41a248ed22e9825e004644bd01" translate="yes" xml:space="preserve">
          <source>This protected method should be overridden to return the current reading of the time source expressed as a &lt;a href=&quot;../../kotlin/-long/index#kotlin.Long&quot;&gt;Long&lt;/a&gt; number in the unit specified by the &lt;a href=&quot;../-abstract-long-time-source/unit&quot;&gt;unit&lt;/a&gt; property.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8a502fcd862a7a6134a3c1a231924a5e92f7555" translate="yes" xml:space="preserve">
          <source>This protected method should be overridden to return the current reading of the time source expressed as a &lt;a href=&quot;../../kotlin/-long/index#kotlin.Long&quot;&gt;Long&lt;/a&gt; number in the unit specified by the &lt;a href=&quot;unit&quot;&gt;unit&lt;/a&gt; property.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aec1ca1351fa183afc05654031c5fff3d664e375" translate="yes" xml:space="preserve">
          <source>This protocol is designed for comfortable updates as no project can be blocked from updating its dependencies even if it's using a slightly outdated compiler.</source>
          <target state="translated">这个协议是为舒适的更新而设计的,因为即使项目使用的是稍微过时的编译器,也不会被阻止更新其依赖关系。</target>
        </trans-unit>
        <trans-unit id="98a9e8bab8deee99e0e21fcb3247e8a1511740b5" translate="yes" xml:space="preserve">
          <source>This publication does not include any artifacts and only references the other publications as its variants. However, it may need the sources and documentation artifacts if that is required by the repository. In that case, add those artifacts by using &lt;a href=&quot;https://docs.gradle.org/current/javadoc/org/gradle/api/publish/maven/MavenPublication.html#artifact-java.lang.Object-&quot;&gt;&lt;code&gt;artifact(...)&lt;/code&gt;&lt;/a&gt; in the publication's scope, which is accessed as shown above.</source>
          <target state="translated">该出版物不包含任何工件，仅引用其他出版物作为其变体。但是，如果存储库需要，则可能需要源和文档工件。在这种情况下，请使用出版物范围内的&lt;a href=&quot;https://docs.gradle.org/current/javadoc/org/gradle/api/publish/maven/MavenPublication.html#artifact-java.lang.Object-&quot;&gt; &lt;code&gt;artifact(...)&lt;/code&gt; &lt;/a&gt;添加这些工件，如上所示进行访问。</target>
        </trans-unit>
        <trans-unit id="e2515924de7501ee2f4c68fc0b725aaaf061557d" translate="yes" xml:space="preserve">
          <source>This quickly gets unwieldy, so you will typically &lt;em&gt;import&lt;/em&gt; the symbols you need. You can import a specific symbol:</source>
          <target state="translated">这很快变得很笨拙，因此通常您将&lt;em&gt;导入&lt;/em&gt;所需的符号。您可以导入特定的符号：</target>
        </trans-unit>
        <trans-unit id="b4727911dc96369eca10addebc256163a4abb387" translate="yes" xml:space="preserve">
          <source>This requires that the consumer's Gradle build can read Gradle module metadata, either using Gradle 5.3+ or explicitly enabling it by &lt;code&gt;enableFeaturePreview(&quot;GRADLE_METADATA&quot;)&lt;/code&gt; in &lt;code&gt;settings.gradle&lt;/code&gt;.</source>
          <target state="translated">这就需要消费者的摇篮构建可以阅读摇篮模块的元数据，或者使用摇篮5.3+或显式启用它由 &lt;code&gt;enableFeaturePreview(&quot;GRADLE_METADATA&quot;)&lt;/code&gt; 在 &lt;code&gt;settings.gradle&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e3811c08a3b736bc78dff85189aa76ac7adf599c" translate="yes" xml:space="preserve">
          <source>This returns &lt;code&gt;b.length&lt;/code&gt; if &lt;code&gt;b&lt;/code&gt; is not null, and &lt;em&gt;null&lt;/em&gt; otherwise. The type of this expression is &lt;code&gt;Int?&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;b&lt;/code&gt; 不为null，则返回 &lt;code&gt;b.length&lt;/code&gt; ，否则返回&lt;em&gt;null&lt;/em&gt;。此表达式的类型是 &lt;code&gt;Int?&lt;/code&gt; 。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="752e46575723521dd2b0e2f3643820dd84459a5c" translate="yes" xml:space="preserve">
          <source>This runs a 1'000'000 threads each of which adds to a common counter. My patience runs out before this program completes on my machine (definitely over a minute).</source>
          <target state="translated">这个程序会运行100万个线程,每个线程都会增加一个公共计数器。我的耐心在这个程序在我的机器上完成之前就耗尽了(绝对超过一分钟)。</target>
        </trans-unit>
        <trans-unit id="86208ae33ef90a5dcb8c41ac6a075a89ce88f8d7" translate="yes" xml:space="preserve">
          <source>This section covers basic coroutine concepts.</source>
          <target state="translated">本节包括基本的coroutine概念。</target>
        </trans-unit>
        <trans-unit id="75d5f867c8b73c01b71e379315dc5e2a4c6f94a7" translate="yes" xml:space="preserve">
          <source>This section covers coroutine cancellation and timeouts.</source>
          <target state="translated">本节介绍了outine取消和超时。</target>
        </trans-unit>
        <trans-unit id="1de34a1a4060ac4a9343482aadfbf40dd5028f41" translate="yes" xml:space="preserve">
          <source>This section covers exception handling and cancellation on exceptions. We already know that a cancelled coroutine throws &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-cancellation-exception/index.html&quot;&gt;CancellationException&lt;/a&gt; in suspension points and that it is ignored by the coroutines' machinery. Here we look at what happens if an exception is thrown during cancellation or multiple children of the same coroutine throw an exception.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7fd839d8f63682d12541a453824eb6d8c7ab4f81" translate="yes" xml:space="preserve">
          <source>This section covers exception handling and cancellation on exceptions. We already know that cancelled coroutine throws &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-cancellation-exception/index.html&quot;&gt;CancellationException&lt;/a&gt; in suspension points and that it is ignored by coroutines machinery. But what happens if an exception is thrown during cancellation or multiple children of the same coroutine throw an exception?</source>
          <target state="translated">本节介绍异常处理和异常的取消。我们已经知道，取消的协程会在挂起点上引发&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-cancellation-exception/index.html&quot;&gt;CancellationException&lt;/a&gt;，并且协程机制会忽略它。但是，如果在取消过程中引发异常，或者同一个协程的多个子级引发异常，会发生什么呢？</target>
        </trans-unit>
        <trans-unit id="dd1323da1dc057b96f757b1081629bfe17cfb809" translate="yes" xml:space="preserve">
          <source>This section covers various approaches to composition of suspending functions.</source>
          <target state="translated">本节介绍了悬浮功能的各种构成方法。</target>
        </trans-unit>
        <trans-unit id="a95364236d062d020a78b5720e48ac1fd0f74e43" translate="yes" xml:space="preserve">
          <source>This section provides steps for creating a multiplatform library. You can also complete the &lt;a href=&quot;../tutorials/mpp/multiplatform-library&quot;&gt;tutorial&lt;/a&gt; where you will create a multiplatform library, test it, and publish it to Maven.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0b801aac5ae1a9b9aa65ed84d940a1ebfabf5c1" translate="yes" xml:space="preserve">
          <source>This self-contained jar file can be passed directly to a JRE to run your application:</source>
          <target state="translated">这个自包含的jar文件可以直接传递给JRE来运行你的应用程序。</target>
        </trans-unit>
        <trans-unit id="223d9ca7ba6df0b968b70ef4903c89512ab178b6" translate="yes" xml:space="preserve">
          <source>This should create a folder &lt;code&gt;build/native/bin&lt;/code&gt; with two subfolders &lt;code&gt;debugExecutable&lt;/code&gt; and &lt;code&gt;releaseExecutable&lt;/code&gt; with the corresponding binary. By default, the binary is named the same as the project folder.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07b72134ade9a0b803e3da70c408db30a1a38134" translate="yes" xml:space="preserve">
          <source>This simplified example ensures that publications are only uploaded when &lt;code&gt;isMainHost=true&lt;/code&gt; is passed. This means that a publication that can be published from multiple platforms will be published only once &amp;ndash; from the main host.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3eff95c0ad7329dd98bdd50eb833ef0910fc787b" translate="yes" xml:space="preserve">
          <source>This simplified example ensures that the JVM, JS, and Kotlin metadata publications are only uploaded when &lt;code&gt;-PisLinux=true&lt;/code&gt; is passed to the build in the command line:</source>
          <target state="translated">这个简化的示例确保仅在将 &lt;code&gt;-PisLinux=true&lt;/code&gt; 传递到命令行中的构建时，才上载JVM，JS和Kotlin元数据发布：</target>
        </trans-unit>
        <trans-unit id="41a51abdee059894e1c3bfb1c72642c3da8b751d" translate="yes" xml:space="preserve">
          <source>This starts a new coroutine. By default, coroutines are run on a shared pool of threads. Threads still exist in a program based on coroutines, but one thread can run many coroutines, so there's no need for too many threads.</source>
          <target state="translated">这将启动一个新的coroutine,默认情况下,coroutine在共享线程池上运行。默认情况下,coroutine是在一个共享的线程池上运行的。在基于coroutine的程序中仍然存在线程,但一个线程可以运行许多coroutine,所以不需要太多的线程。</target>
        </trans-unit>
        <trans-unit id="08ae2339793360b19c579572a5e9dcd8e02beebb" translate="yes" xml:space="preserve">
          <source>This step helps synchronize your Xcode project with Kotlin Pod dependencies by calling &lt;code&gt;pod install&lt;/code&gt; for your &lt;code&gt;Podfile&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76c41d50702d4202e91d08f7ef8c0739fa6d0823" translate="yes" xml:space="preserve">
          <source>This syntax is called a &lt;em&gt;destructuring declaration&lt;/em&gt;. A destructuring declaration creates multiple variables at once. We have declared two new variables: &lt;code&gt;name&lt;/code&gt; and &lt;code&gt;age&lt;/code&gt;, and can use them independently:</source>
          <target state="translated">此语法称为&lt;em&gt;解构声明&lt;/em&gt;。销毁声明一次创建多个变量。我们已经声明了两个新变量： &lt;code&gt;name&lt;/code&gt; 和 &lt;code&gt;age&lt;/code&gt; ，并且可以独立使用它们：</target>
        </trans-unit>
        <trans-unit id="530a8c17c6739ef629eabdb94246db16d43922c7" translate="yes" xml:space="preserve">
          <source>This table says that when the compiler processes, for example, an expression &lt;code&gt;+a&lt;/code&gt;, it performs the following steps:</source>
          <target state="translated">该表表明，当编译器处理例如表达式 &lt;code&gt;+a&lt;/code&gt; 时，它将执行以下步骤：</target>
        </trans-unit>
        <trans-unit id="cca6caa135016bb5fe36c582797dd2583e1f3082" translate="yes" xml:space="preserve">
          <source>This takes about 10 seconds on my machine, so yes, coroutines do run in parallel.</source>
          <target state="translated">这在我的机器上大约需要10秒钟,所以是的,coroutines确实是并行运行的。</target>
        </trans-unit>
        <trans-unit id="215ff0a6c5e99998fdfa92a79eaf70ff28fc615e" translate="yes" xml:space="preserve">
          <source>This task copies both dependencies runtime files and the compilation output to the &lt;code&gt;web&lt;/code&gt; directory.</source>
          <target state="translated">此任务将依赖项运行时文件和编译输出都复制到 &lt;code&gt;web&lt;/code&gt; 目录。</target>
        </trans-unit>
        <trans-unit id="1a26679828d6c6d2c31183443afd2cce0f1abe38" translate="yes" xml:space="preserve">
          <source>This test will be automatically executed on the JVM target in addition to the common part.</source>
          <target state="translated">除了常见的部分外,这个测试将在JVM目标上自动执行。</target>
        </trans-unit>
        <trans-unit id="66487ce50428c7f10ee64de3817e29a9dd09d391" translate="yes" xml:space="preserve">
          <source>This time source returns its readings from a source of monotonic time when it is available in a target platform, and resorts to a non-monotonic time source otherwise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="422dc05df4ea784a9b658e3b358ccefed13a0844" translate="yes" xml:space="preserve">
          <source>This time we take a returned &lt;code&gt;char *&lt;/code&gt; from the &lt;code&gt;return_string&lt;/code&gt; function and turn it into a Kotlin string. For that we do the following in Kotlin:</source>
          <target state="translated">这次，我们从 &lt;code&gt;return_string&lt;/code&gt; 函数获取一个返回的 &lt;code&gt;char *&lt;/code&gt; 并将其转换为Kotlin字符串。为此，我们在Kotlin中执行以下操作：</target>
        </trans-unit>
        <trans-unit id="1bc095b457022b841cd86dbdae9f7dd06a0233ca" translate="yes" xml:space="preserve">
          <source>This time we will ask a C function to write us a C string to a given buffer. The function is called &lt;code&gt;copy_string&lt;/code&gt;. It takes a pointer to the location writing characters and the allowed buffer size. The function returns something to indicate if it has succeeded or failed. Let's assume &lt;code&gt;0&lt;/code&gt; means it succeeded, and the supplied buffer was big enough:</source>
          <target state="translated">这次，我们将要求C函数将C字符串写入给定的缓冲区。该函数称为 &lt;code&gt;copy_string&lt;/code&gt; 。它需要指向写入字符和允许的缓冲区大小的位置的指针。该函数返回一些内容以指示它是否成功。假设 &lt;code&gt;0&lt;/code&gt; 表示成功，并且提供的缓冲区足够大：</target>
        </trans-unit>
        <trans-unit id="82c6c3bd1da0d55221efcca2072d5e9cdb826610" translate="yes" xml:space="preserve">
          <source>This tutorial demonstrates how to create Kotlin Flow and debug it using IntelliJ IDEA.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c68ca0982e68f9e22974e99e2e822ed4b0d343c0" translate="yes" xml:space="preserve">
          <source>This tutorial demonstrates how to create Kotlin coroutines and debug them using IntelliJ IDEA.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9387511094971af8445fb83c09dde400b482b22" translate="yes" xml:space="preserve">
          <source>This tutorial demonstrates how to use IntelliJ IDEA for creating a Kotlin/Native application.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ebf218f1387966b47fc351969c1b8ff8c0f7190c" translate="yes" xml:space="preserve">
          <source>This tutorial demonstrates how to use IntelliJ IDEA for creating a console application.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe4c518bfe506edc227e9d14e1ef41199e094bec" translate="yes" xml:space="preserve">
          <source>This tutorial demonstrates how to use IntelliJ IDEA for creating a frontend application with Kotlin/JS for React.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95eb5f454522f97d35d22eb89071211f56ea5b5c" translate="yes" xml:space="preserve">
          <source>This tutorial describes how to use Kotlin Android Extensions to improve support for Android development.</source>
          <target state="translated">本教程介绍如何使用Kotlin Android Extensions来提高对Android开发的支持。</target>
        </trans-unit>
        <trans-unit id="54b32f69d1a441fb0920f9a2c8eb9ed0a6588065" translate="yes" xml:space="preserve">
          <source>This tutorial describes how to use in Kotlin popular Android frameworks and libraries that rely on annotation processing.</source>
          <target state="translated">本教程介绍了如何在Kotlin中使用流行的依赖注释处理的Android框架和库。</target>
        </trans-unit>
        <trans-unit id="98dac163941bb963709918b2eba82c9b82af15ef" translate="yes" xml:space="preserve">
          <source>This tutorial explains the basic usage of Kotlin for competitive programming.</source>
          <target state="translated">本教程讲解了Kotlin在竞技编程中的基本用法。</target>
        </trans-unit>
        <trans-unit id="d0f7acc9fd5623b0666fe34b54ba37696a87ee9a" translate="yes" xml:space="preserve">
          <source>This tutorial explains the different approaches to asynchronous programming</source>
          <target state="translated">本教程解释了异步编程的不同方法。</target>
        </trans-unit>
        <trans-unit id="b37aa099eaa69fb3a0a9c2ea81dc57defd40be24" translate="yes" xml:space="preserve">
          <source>This tutorial is designed both for competitive programmers that did not use Kotlin before and for Kotlin developers that did not participate in any competitive programming events before. It assumes the corresponding programming skills.</source>
          <target state="translated">本教程既是为以前没有使用过Kotlin的竞技程序员设计的,也是为以前没有参加过任何竞技编程活动的Kotlin开发人员设计的。它假设了相应的编程技能。</target>
        </trans-unit>
        <trans-unit id="6ab5e488d7caf8012aa22bda0a09bdd7f98d9861" translate="yes" xml:space="preserve">
          <source>This tutorial shows how to debug a Kotlin/JS project build by Gradle. If you are using Maven or IDEA, the recipes would be similar.</source>
          <target state="translated">本教程介绍了如何调试一个由Gradle构建的Kotlin/JS项目。如果你使用的是Maven或IDEA,那么配方也会类似。</target>
        </trans-unit>
        <trans-unit id="f9acc149373601d8ab69e64887e6e309b360247b" translate="yes" xml:space="preserve">
          <source>This tutorial shows the ways to run Kotlin code snippets in a lightweight manner without creating or modifying the whole project.</source>
          <target state="translated">本教程展示了在不创建或修改整个项目的情况下,以轻量级方式运行Kotlin代码片段的方法。</target>
        </trans-unit>
        <trans-unit id="946efbdf49896b1eceb2a440b208d6a7b7c887c4" translate="yes" xml:space="preserve">
          <source>This tutorial shows the ways to write and run Kotlin code snippets in a lightweight manner without creating entire applications.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b741e974e2ef9e2aadef771ec4ed4af6da26b1ed" translate="yes" xml:space="preserve">
          <source>This tutorial walks us through creating a Hello World application using the command line compiler.</source>
          <target state="translated">本教程将引导我们使用命令行编译器创建一个Hello World应用程序。</target>
        </trans-unit>
        <trans-unit id="9ef69a04e24828e3b4f1be864d64b99505227e64" translate="yes" xml:space="preserve">
          <source>This tutorial walks us through creating a Kotlin JavaScript library using the command line compiler.</source>
          <target state="translated">本教程引导我们使用命令行编译器创建一个Kotlin JavaScript库。</target>
        </trans-unit>
        <trans-unit id="7cbf690e869df1155e9df8254a2e24065f3c7742" translate="yes" xml:space="preserve">
          <source>This tutorial walks us through creating a simple Kotlin application for Android.</source>
          <target state="translated">本教程将带领我们创建一个简单的Android版Kotlin应用程序。</target>
        </trans-unit>
        <trans-unit id="262f778d62fb1c6728a7e17683a48adb22e2c354" translate="yes" xml:space="preserve">
          <source>This tutorial walks us through setting up a project using coroutines, and writing code that uses them.</source>
          <target state="translated">本教程将引导我们使用coroutines设置一个项目,并编写使用它们的代码。</target>
        </trans-unit>
        <trans-unit id="b761f80d7daf0f57c426b6c2c8f5551348835c06" translate="yes" xml:space="preserve">
          <source>This tutorial walks us through the process of creating a simple REST controller with Spring Boot</source>
          <target state="translated">本教程将引导我们使用Spring Boot创建一个简单的REST控制器的过程。</target>
        </trans-unit>
        <trans-unit id="d3c06d78974760f747dc344799aadb31e636411d" translate="yes" xml:space="preserve">
          <source>This tutorial walks us through the process of creating a simple controller using HttpServlet to display Hello World.</source>
          <target state="translated">本教程引导我们使用HttpServlet创建一个简单的控制器来显示Hello World的过程。</target>
        </trans-unit>
        <trans-unit id="917a46d0d52ec8a68291cefda5c1868408d5366b" translate="yes" xml:space="preserve">
          <source>This tutorial walks us through the process of using Java and Kotlin in a single IntelliJ IDEA project.</source>
          <target state="translated">本教程将带领我们在一个IntelliJ IDEA项目中使用Java和Kotlin的过程。</target>
        </trans-unit>
        <trans-unit id="5c37cdc48efb7900f24478fb914764b4ad25e974" translate="yes" xml:space="preserve">
          <source>This tutorial walks you through a series of exercises to get familiar with Kotlin.</source>
          <target state="translated">本教程将引导你通过一系列练习来熟悉Kotlin。</target>
        </trans-unit>
        <trans-unit id="fed85180abcbc65ba4b2af3d5f5d2d524508a6b7" translate="yes" xml:space="preserve">
          <source>This tutorial walks you through creating a simple Hello World application using IntelliJ IDEA.</source>
          <target state="translated">本教程指导您使用IntelliJ IDEA创建一个简单的Hello World应用程序。</target>
        </trans-unit>
        <trans-unit id="3a3a5550c3979eb75d3c935292c9198b690dcdbe" translate="yes" xml:space="preserve">
          <source>This tutorial walks you through the interactive learning with a set of Kotlin programming tasks.</source>
          <target state="translated">本教程通过一组Kotlin编程任务引导大家进行互动学习。</target>
        </trans-unit>
        <trans-unit id="1922851cbe5cc3d86c3c73d15c6f4bdffb8c9675" translate="yes" xml:space="preserve">
          <source>This tutorial will walk you through creating a simple Kotlin course with a set of programming tasks and integrated tests.</source>
          <target state="translated">本教程将引导你创建一个简单的Kotlin课程,其中包含一组编程任务和集成测试。</target>
        </trans-unit>
        <trans-unit id="c6030bef069b6977eab83078442b66dedd7712ad" translate="yes" xml:space="preserve">
          <source>This tutorials walks us through creating a simple Hello World application using Eclipse IDE</source>
          <target state="translated">本教程将引导我们使用Eclipse IDE创建一个简单的Hello World应用程序。</target>
        </trans-unit>
        <trans-unit id="1cba3a52b4e9e49248914c3506dd87812401b394" translate="yes" xml:space="preserve">
          <source>This type is used as a receiver type of the lambda function passed to the &lt;a href=&quot;../contract&quot;&gt;contract&lt;/a&gt; function.</source>
          <target state="translated">此类型用作传递给&lt;a href=&quot;../contract&quot;&gt;协定&lt;/a&gt;函数的lambda函数的接收器类型。</target>
        </trans-unit>
        <trans-unit id="d42addf558756322234c05ff9ff53ebc28a290b0" translate="yes" xml:space="preserve">
          <source>This value is used as a return value of &lt;a href=&quot;suspend-coroutine-or-return&quot;&gt;suspendCoroutineOrReturn&lt;/a&gt;&lt;code&gt;block&lt;/code&gt; argument to state that the execution was suspended and will not return any result immediately.</source>
          <target state="translated">该值用作&lt;a href=&quot;suspend-coroutine-or-return&quot;&gt;suspendCoroutineOrReturn &lt;/a&gt; &lt;code&gt;block&lt;/code&gt; 参数的返回值，以声明执行已被挂起并且不会立即返回任何结果。</target>
        </trans-unit>
        <trans-unit id="f268b965a48f4655e5367448b4016e6f76edf6f0" translate="yes" xml:space="preserve">
          <source>This value is used as a return value of &lt;a href=&quot;suspend-coroutine-unintercepted-or-return&quot;&gt;suspendCoroutineUninterceptedOrReturn&lt;/a&gt;&lt;code&gt;block&lt;/code&gt; argument to state that the execution was suspended and will not return any result immediately.</source>
          <target state="translated">该值用作&lt;a href=&quot;suspend-coroutine-unintercepted-or-return&quot;&gt;suspendCoroutineUninterceptedOrReturn &lt;/a&gt; &lt;code&gt;block&lt;/code&gt; 参数的返回值，以表明执行已被挂起并且不会立即返回任何结果。</target>
        </trans-unit>
        <trans-unit id="6e8f43b127da8dc0c4ddf32ba0afa9420b6890c9" translate="yes" xml:space="preserve">
          <source>This value needs to be smaller than &lt;a href=&quot;range-to#kotlin.ranges%24rangeTo%28kotlin.ranges.rangeTo.T%2C+kotlin.ranges.rangeTo.T%29%2Fthat&quot;&gt;that&lt;/a&gt; value, otherwise the returned range will be empty.</source>
          <target state="translated">该值必须小于&lt;a href=&quot;range-to#kotlin.ranges%24rangeTo%28kotlin.ranges.rangeTo.T%2C+kotlin.ranges.rangeTo.T%29%2Fthat&quot;&gt;该&lt;/a&gt;值，否则返回的范围将为空。</target>
        </trans-unit>
        <trans-unit id="2d268ef4eff4a4c02ff30a25a66e6ca340c2e614" translate="yes" xml:space="preserve">
          <source>This value needs to be smaller than &lt;a href=&quot;range-to#kotlin.ranges%24rangeTo(kotlin.ranges.rangeTo.T,%20kotlin.ranges.rangeTo.T)/that&quot;&gt;that&lt;/a&gt; value, otherwise the returned range will be empty.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a4e95d6779047f36ef44cebc8fe10ec0e5dbd2f" translate="yes" xml:space="preserve">
          <source>This way any value of type &lt;code&gt;CPointer&amp;lt;ByteVar&amp;gt;&lt;/code&gt; can be passed as an argument of &lt;code&gt;const char*&lt;/code&gt; type. If a Kotlin string should be passed, code like this could be used:</source>
          <target state="translated">这样，任何类型为 &lt;code&gt;CPointer&amp;lt;ByteVar&amp;gt;&lt;/code&gt; 都可以作为 &lt;code&gt;const char*&lt;/code&gt; 类型的参数传递。如果应该传递Kotlin字符串，则可以使用如下代码：</target>
        </trans-unit>
        <trans-unit id="98a5e105dc56eeee056d102244e8a0f5fed4f0c6" translate="yes" xml:space="preserve">
          <source>This way, if something goes wrong inside the code of &lt;code&gt;concurrentSum&lt;/code&gt; function and it throws an exception, all the coroutines that were launched in its scope are cancelled.</source>
          <target state="translated">这样，如果 &lt;code&gt;concurrentSum&lt;/code&gt; 函数的代码内部出现问题并引发异常，则将取消在其作用域中启动的所有协程。</target>
        </trans-unit>
        <trans-unit id="751432b1fc412bf87d1b4554a9034d2372594768" translate="yes" xml:space="preserve">
          <source>This way, if something goes wrong inside the code of the &lt;code&gt;concurrentSum&lt;/code&gt; function and it throws an exception, all the coroutines that were launched in its scope will be cancelled.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f17f9d1f7410fbad939ec9e37eb14f1a6139cb16" translate="yes" xml:space="preserve">
          <source>This will apply the Gradle &lt;code&gt;java&lt;/code&gt; plugin and configure the target to cooperate with it. Note that just applying the Java plugin without specifying &lt;code&gt;withJava()&lt;/code&gt; in a JVM target will have no effect on the target.</source>
          <target state="translated">这将应用Gradle &lt;code&gt;java&lt;/code&gt; 插件并配置目标与之合作。注意，仅应用Java插件而不在JVM目标中指定 &lt;code&gt;withJava()&lt;/code&gt; 不会对目标产生影响。</target>
        </trans-unit>
        <trans-unit id="5e9c760291236659fa80c3cad20690354472cf0c" translate="yes" xml:space="preserve">
          <source>This will assign &lt;code&gt;x&lt;/code&gt; to &lt;code&gt;z&lt;/code&gt; if &lt;code&gt;x&lt;/code&gt; is non-null, but if it is null, the entire function that contains this expression will stop and return &lt;code&gt;y&lt;/code&gt; (this works because &lt;code&gt;return&lt;/code&gt; is also an expression, and if it is evaluated, it evaluates its argument and then makes the containing function return the result).</source>
          <target state="translated">这将分配 &lt;code&gt;x&lt;/code&gt; 到 &lt;code&gt;z&lt;/code&gt; 如果 &lt;code&gt;x&lt;/code&gt; 不为null，但如果是空，包含此表达将停止并返回整个功能 &lt;code&gt;y&lt;/code&gt; （这工作，因为 &lt;code&gt;return&lt;/code&gt; 也是一个表达式，如果评估时，评估其参数，然后使包含函数返回结果）。</target>
        </trans-unit>
        <trans-unit id="e3c6e68d7f248b58990253f88430e5ca4c4c8e2b" translate="yes" xml:space="preserve">
          <source>This will automatically implement all the interface members of &lt;code&gt;PowerSource&lt;/code&gt; in &lt;code&gt;MotorVehicle&lt;/code&gt; by invoking the same member on &lt;code&gt;engine&lt;/code&gt;. This only works for properties that are declared in the constructor.</source>
          <target state="translated">通过在 &lt;code&gt;engine&lt;/code&gt; 上调用同一成员，这将自动在 &lt;code&gt;PowerSource&lt;/code&gt; 中实现 &lt;code&gt;MotorVehicle&lt;/code&gt; 的所有接口成员。这仅适用于在构造函数中声明的属性。</target>
        </trans-unit>
        <trans-unit id="e4c10956ebfa0383ee2f1e029c8feb69cf8fc5ac" translate="yes" xml:space="preserve">
          <source>This will raise a &lt;code&gt;ClassCastException&lt;/code&gt; if the object is not actually an instance of &lt;code&gt;Person&lt;/code&gt; or any of its subclasses. If you're not sure what &lt;code&gt;x&lt;/code&gt; is, but you're happy to get null if it's not a &lt;code&gt;Person&lt;/code&gt;, you can use &lt;code&gt;as?&lt;/code&gt;, which will return null if the cast fails. Note that the resulting type is &lt;code&gt;Person?&lt;/code&gt;:</source>
          <target state="translated">如果对象实际上不是 &lt;code&gt;Person&lt;/code&gt; 或其任何子类的实例，则将引发 &lt;code&gt;ClassCastException&lt;/code&gt; 。如果不确定 &lt;code&gt;x&lt;/code&gt; 是什么，但如果不是 &lt;code&gt;Person&lt;/code&gt; ，则很高兴获得null ，可以 &lt;code&gt;as?&lt;/code&gt; ，如果强制转换失败，它将返回null。请注意，结果类型为 &lt;code&gt;Person?&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="fa6b2b95ad5f670c5af166fa09cb0ec4fc6be37b" translate="yes" xml:space="preserve">
          <source>This works also for &lt;em&gt;var&lt;/em&gt;&amp;rsquo;s properties if you use a &lt;code&gt;MutableMap&lt;/code&gt; instead of read-only &lt;code&gt;Map&lt;/code&gt;:</source>
          <target state="translated">如果您使用 &lt;code&gt;MutableMap&lt;/code&gt; 而不是只读 &lt;code&gt;Map&lt;/code&gt; ,那么这也适用于&lt;em&gt;var&lt;/em&gt;的属性：</target>
        </trans-unit>
        <trans-unit id="dfbae76eefb17a295e772659a5df1b063a9b20dc" translate="yes" xml:space="preserve">
          <source>Those class names are always getting in the way. We can use static imports and get this:</source>
          <target state="translated">那些类名总是碍于情面。我们可以使用静态导入,得到这个。</target>
        </trans-unit>
        <trans-unit id="840686b21fe85a3d03fcebd9f6fe5d67ee5b8f5f" translate="yes" xml:space="preserve">
          <source>Though reflection may not be needed in many cases, we can still use it with a reified type parameter:</source>
          <target state="translated">虽然在很多情况下可能不需要反射,但我们仍然可以用一个重构的类型参数来使用它。</target>
        </trans-unit>
        <trans-unit id="db9c8e28b5db7e794581721a97a55d403ef96db4" translate="yes" xml:space="preserve">
          <source>Thread confinement coarse-grained</source>
          <target state="translated">粗粒度的螺纹封闭</target>
        </trans-unit>
        <trans-unit id="58c8dc7270e76e9fe5dcba1621b0a309ea2a0ff5" translate="yes" xml:space="preserve">
          <source>Thread confinement fine-grained</source>
          <target state="translated">细致的螺纹密闭</target>
        </trans-unit>
        <trans-unit id="07c0a8bbcccb40629ed6cd8852b0c2af35dea6b2" translate="yes" xml:space="preserve">
          <source>Thread-local data</source>
          <target state="translated">线程本地数据</target>
        </trans-unit>
        <trans-unit id="b51d97d48189b14ee90ab80ab5f1002db2ed52a4" translate="yes" xml:space="preserve">
          <source>Thread-safe data structures</source>
          <target state="translated">线程安全的数据结构</target>
        </trans-unit>
        <trans-unit id="8a77bfd3db44e0aeb0a80c2f055eea2ff97f89d4" translate="yes" xml:space="preserve">
          <source>ThreadLocal</source>
          <target state="translated">ThreadLocal</target>
        </trans-unit>
        <trans-unit id="5541d0b76d127f6a3c54bbc247ffcc1b6c2bbc25" translate="yes" xml:space="preserve">
          <source>Threading</source>
          <target state="translated">Threading</target>
        </trans-unit>
        <trans-unit id="54fc24f5a7668604be098318c177c182e63b5fa7" translate="yes" xml:space="preserve">
          <source>Threads are by far probably the most well-known approach to avoid applications from blocking.</source>
          <target state="translated">线程可能是目前最著名的避免应用阻塞的方法。</target>
        </trans-unit>
        <trans-unit id="c8cb6272d819adb1d7ec29aee37d20ed2b2cd093" translate="yes" xml:space="preserve">
          <source>Threads aren't always available. Some platforms, such as JavaScript do not even support threads</source>
          <target state="translated">线程并不总是可用。有些平台,如JavaScript甚至不支持线程。</target>
        </trans-unit>
        <trans-unit id="100ffacab3bbb22c877b7db046d6811ab68a4092" translate="yes" xml:space="preserve">
          <source>Threads aren't cheap. Threads require context switches which are costly.</source>
          <target state="translated">线程并不便宜。线程需要上下文切换,成本很高。</target>
        </trans-unit>
        <trans-unit id="ed5d4b963a60e738f823f980aab2e771fb9e0b19" translate="yes" xml:space="preserve">
          <source>Threads aren't easy. Debugging threads, avoiding race conditions are common problems we suffer in multi-threaded programming.</source>
          <target state="translated">线程并不容易。调试线程、避免竞赛条件是我们在多线程编程中常遇到的问题。</target>
        </trans-unit>
        <trans-unit id="dada4feb2387f68301b5e37c631ce74cff4d977a" translate="yes" xml:space="preserve">
          <source>Threads aren't infinite. The number of threads that can be launched is limited by the underlying operating system. In server-side applications, this could cause a major bottleneck.</source>
          <target state="translated">线程并不是无限的。可以启动的线程数量受到底层操作系统的限制。在服务器端应用中,这可能会造成重大瓶颈。</target>
        </trans-unit>
        <trans-unit id="ea7ecc8ef4eb25f7a1da622aee2bb4b90728e800" translate="yes" xml:space="preserve">
          <source>Through these platforms you can access the &lt;strong&gt;platform native code&lt;/strong&gt; (JVM, JS, and Native) and leverage all native capabilities.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8abf11297f412ee4fff55514bb434f634e293565" translate="yes" xml:space="preserve">
          <source>Throwable</source>
          <target state="translated">Throwable</target>
        </trans-unit>
        <trans-unit id="eac1fd32ab840fc388b25886124b82f77d7d2760" translate="yes" xml:space="preserve">
          <source>Throwing and catching</source>
          <target state="translated">扔和接</target>
        </trans-unit>
        <trans-unit id="866ed5ebf5c2f2a9c6597aa6906378e31d48e178" translate="yes" xml:space="preserve">
          <source>Thrown by cancellable suspending functions if the coroutine is cancelled while it is suspended. It indicates &lt;em&gt;normal&lt;/em&gt; cancellation of a coroutine.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9f4b0f30b3f06e61b21febef173645d29891305" translate="yes" xml:space="preserve">
          <source>Throws</source>
          <target state="translated">Throws</target>
        </trans-unit>
        <trans-unit id="b1b2da4ce29be6e42fd3a3a1d87f8fd7bd99c3f3" translate="yes" xml:space="preserve">
          <source>Throws an &lt;a href=&quot;-assertion-error/index#kotlin.AssertionError&quot;&gt;AssertionError&lt;/a&gt; calculated by &lt;a href=&quot;assert#kotlin%24assert%28kotlin.Boolean%2C+kotlin.Function0%28%28kotlin.Any%29%29%29%2FlazyMessage&quot;&gt;lazyMessage&lt;/a&gt; if the &lt;a href=&quot;assert#kotlin%24assert%28kotlin.Boolean%2C+kotlin.Function0%28%28kotlin.Any%29%29%29%2Fvalue&quot;&gt;value&lt;/a&gt; is false and runtime assertions have been enabled during compilation.</source>
          <target state="translated">如果&lt;a href=&quot;assert#kotlin%24assert%28kotlin.Boolean%2C+kotlin.Function0%28%28kotlin.Any%29%29%29%2Fvalue&quot;&gt;值为&lt;/a&gt; false且编译期间已启用运行时断言，则抛出由&lt;a href=&quot;assert#kotlin%24assert%28kotlin.Boolean%2C+kotlin.Function0%28%28kotlin.Any%29%29%29%2FlazyMessage&quot;&gt;lazyMessage&lt;/a&gt;计算的&lt;a href=&quot;-assertion-error/index#kotlin.AssertionError&quot;&gt;AssertionError&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="21712a0494f28f6a46c5535db142ea2522d8b30e" translate="yes" xml:space="preserve">
          <source>Throws an &lt;a href=&quot;-assertion-error/index#kotlin.AssertionError&quot;&gt;AssertionError&lt;/a&gt; calculated by &lt;a href=&quot;assert#kotlin%24assert%28kotlin.Boolean%2C+kotlin.Function0%28%28kotlin.Any%29%29%29%2FlazyMessage&quot;&gt;lazyMessage&lt;/a&gt; if the &lt;a href=&quot;assert#kotlin%24assert%28kotlin.Boolean%2C+kotlin.Function0%28%28kotlin.Any%29%29%29%2Fvalue&quot;&gt;value&lt;/a&gt; is false and runtime assertions have been enabled on the JVM using the &lt;em&gt;-ea&lt;/em&gt; JVM option.</source>
          <target state="translated">如果该&lt;a href=&quot;assert#kotlin%24assert%28kotlin.Boolean%2C+kotlin.Function0%28%28kotlin.Any%29%29%29%2Fvalue&quot;&gt;值为&lt;/a&gt; false且使用&lt;em&gt;-ea&lt;/em&gt; JVM选项在JVM上启用了运行时断言，则引发由&lt;a href=&quot;assert#kotlin%24assert%28kotlin.Boolean%2C+kotlin.Function0%28%28kotlin.Any%29%29%29%2FlazyMessage&quot;&gt;lazyMessage&lt;/a&gt;计算的&lt;a href=&quot;-assertion-error/index#kotlin.AssertionError&quot;&gt;AssertionError&lt;/a&gt;。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b88e532ebba6a290db595d7e93591bf93e58ec5d" translate="yes" xml:space="preserve">
          <source>Throws an &lt;a href=&quot;-assertion-error/index#kotlin.AssertionError&quot;&gt;AssertionError&lt;/a&gt; calculated by &lt;a href=&quot;assert#kotlin%24assert(kotlin.Boolean,%20kotlin.Function0((kotlin.Any)))/lazyMessage&quot;&gt;lazyMessage&lt;/a&gt; if the &lt;a href=&quot;assert#kotlin%24assert(kotlin.Boolean,%20kotlin.Function0((kotlin.Any)))/value&quot;&gt;value&lt;/a&gt; is false and runtime assertions have been enabled during compilation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a834d850910b82b32184bf20e615c66a32c33ffc" translate="yes" xml:space="preserve">
          <source>Throws an &lt;a href=&quot;-assertion-error/index#kotlin.AssertionError&quot;&gt;AssertionError&lt;/a&gt; calculated by &lt;a href=&quot;assert#kotlin%24assert(kotlin.Boolean,%20kotlin.Function0((kotlin.Any)))/lazyMessage&quot;&gt;lazyMessage&lt;/a&gt; if the &lt;a href=&quot;assert#kotlin%24assert(kotlin.Boolean,%20kotlin.Function0((kotlin.Any)))/value&quot;&gt;value&lt;/a&gt; is false and runtime assertions have been enabled on the JVM using the &lt;em&gt;-ea&lt;/em&gt; JVM option.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b187627b0474be6a63105d8fbe200f08b14f46f0" translate="yes" xml:space="preserve">
          <source>Throws an &lt;a href=&quot;-assertion-error/index#kotlin.AssertionError&quot;&gt;AssertionError&lt;/a&gt; if the &lt;a href=&quot;assert#kotlin%24assert%28kotlin.Boolean%29%2Fvalue&quot;&gt;value&lt;/a&gt; is false and runtime assertions have been enabled during compilation.</source>
          <target state="translated">如果该&lt;a href=&quot;assert#kotlin%24assert%28kotlin.Boolean%29%2Fvalue&quot;&gt;值为&lt;/a&gt; false且在编译期间已启用运行时断言，则引发&lt;a href=&quot;-assertion-error/index#kotlin.AssertionError&quot;&gt;AssertionError&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d8d5a9cbb5d90075a851ac67a508560060d907ea" translate="yes" xml:space="preserve">
          <source>Throws an &lt;a href=&quot;-assertion-error/index#kotlin.AssertionError&quot;&gt;AssertionError&lt;/a&gt; if the &lt;a href=&quot;assert#kotlin%24assert%28kotlin.Boolean%29%2Fvalue&quot;&gt;value&lt;/a&gt; is false and runtime assertions have been enabled on the JVM using the &lt;em&gt;-ea&lt;/em&gt; JVM option.</source>
          <target state="translated">如果该&lt;a href=&quot;assert#kotlin%24assert%28kotlin.Boolean%29%2Fvalue&quot;&gt;值为&lt;/a&gt; false且已使用&lt;em&gt;-ea&lt;/em&gt; JVM选项在JVM上启用了运行时断言，则引发&lt;a href=&quot;-assertion-error/index#kotlin.AssertionError&quot;&gt;AssertionError&lt;/a&gt;。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="877c528f0857e16d746ea6daff3b5297368a55b2" translate="yes" xml:space="preserve">
          <source>Throws an &lt;a href=&quot;-assertion-error/index#kotlin.AssertionError&quot;&gt;AssertionError&lt;/a&gt; if the &lt;a href=&quot;assert#kotlin%24assert(kotlin.Boolean)/value&quot;&gt;value&lt;/a&gt; is false and runtime assertions have been enabled during compilation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb0860bdd589a1bb034f027aa22414ee9971d985" translate="yes" xml:space="preserve">
          <source>Throws an &lt;a href=&quot;-assertion-error/index#kotlin.AssertionError&quot;&gt;AssertionError&lt;/a&gt; if the &lt;a href=&quot;assert#kotlin%24assert(kotlin.Boolean)/value&quot;&gt;value&lt;/a&gt; is false and runtime assertions have been enabled on the JVM using the &lt;em&gt;-ea&lt;/em&gt; JVM option.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6495db8a536c8d755d3c31cd2f1405c6a5089dde" translate="yes" xml:space="preserve">
          <source>Throws an &lt;a href=&quot;-illegal-argument-exception/index#kotlin.IllegalArgumentException&quot;&gt;IllegalArgumentException&lt;/a&gt; if the &lt;a href=&quot;require#kotlin%24require%28kotlin.Boolean%29%2Fvalue&quot;&gt;value&lt;/a&gt; is false.</source>
          <target state="translated">如果&lt;a href=&quot;require#kotlin%24require%28kotlin.Boolean%29%2Fvalue&quot;&gt;值为&lt;/a&gt; false，则引发&lt;a href=&quot;-illegal-argument-exception/index#kotlin.IllegalArgumentException&quot;&gt;IllegalArgumentException&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a435a6330bdfb93f8f0baf2519c326f8c8a67d8c" translate="yes" xml:space="preserve">
          <source>Throws an &lt;a href=&quot;-illegal-argument-exception/index#kotlin.IllegalArgumentException&quot;&gt;IllegalArgumentException&lt;/a&gt; if the &lt;a href=&quot;require#kotlin%24require(kotlin.Boolean)/value&quot;&gt;value&lt;/a&gt; is false.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="452d882ee13cc2478203bd62e2127715d9c6ce3d" translate="yes" xml:space="preserve">
          <source>Throws an &lt;a href=&quot;-illegal-argument-exception/index#kotlin.IllegalArgumentException&quot;&gt;IllegalArgumentException&lt;/a&gt; if the &lt;a href=&quot;require-not-null#kotlin%24requireNotNull%28kotlin.requireNotNull.T%29%2Fvalue&quot;&gt;value&lt;/a&gt; is null. Otherwise returns the not null value.</source>
          <target state="translated">如果该&lt;a href=&quot;require-not-null#kotlin%24requireNotNull%28kotlin.requireNotNull.T%29%2Fvalue&quot;&gt;值为&lt;/a&gt; null，则抛出&lt;a href=&quot;-illegal-argument-exception/index#kotlin.IllegalArgumentException&quot;&gt;IllegalArgumentException&lt;/a&gt;。否则，返回非null值。</target>
        </trans-unit>
        <trans-unit id="0dbf5201e6e48ab5572c5ef4e7b99a7cfc2a7333" translate="yes" xml:space="preserve">
          <source>Throws an &lt;a href=&quot;-illegal-argument-exception/index#kotlin.IllegalArgumentException&quot;&gt;IllegalArgumentException&lt;/a&gt; if the &lt;a href=&quot;require-not-null#kotlin%24requireNotNull(kotlin.requireNotNull.T?)/value&quot;&gt;value&lt;/a&gt; is null. Otherwise returns the not null value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d30f2afa782c5c47e8fd1fd37da6b472b4245324" translate="yes" xml:space="preserve">
          <source>Throws an &lt;a href=&quot;-illegal-argument-exception/index#kotlin.IllegalArgumentException&quot;&gt;IllegalArgumentException&lt;/a&gt; with the result of calling &lt;a href=&quot;require#kotlin%24require%28kotlin.Boolean%2C+kotlin.Function0%28%28kotlin.Any%29%29%29%2FlazyMessage&quot;&gt;lazyMessage&lt;/a&gt; if the &lt;a href=&quot;require#kotlin%24require%28kotlin.Boolean%2C+kotlin.Function0%28%28kotlin.Any%29%29%29%2Fvalue&quot;&gt;value&lt;/a&gt; is false.</source>
          <target state="translated">如果该&lt;a href=&quot;require#kotlin%24require%28kotlin.Boolean%2C+kotlin.Function0%28%28kotlin.Any%29%29%29%2Fvalue&quot;&gt;值为&lt;/a&gt; false，则引发&lt;a href=&quot;-illegal-argument-exception/index#kotlin.IllegalArgumentException&quot;&gt;IllegalArgumentException&lt;/a&gt;并导致调用&lt;a href=&quot;require#kotlin%24require%28kotlin.Boolean%2C+kotlin.Function0%28%28kotlin.Any%29%29%29%2FlazyMessage&quot;&gt;lazyMessage&lt;/a&gt;的结果。</target>
        </trans-unit>
        <trans-unit id="6af1ad354715d427817f522962505b9c2ca46b8d" translate="yes" xml:space="preserve">
          <source>Throws an &lt;a href=&quot;-illegal-argument-exception/index#kotlin.IllegalArgumentException&quot;&gt;IllegalArgumentException&lt;/a&gt; with the result of calling &lt;a href=&quot;require#kotlin%24require(kotlin.Boolean,%20kotlin.Function0((kotlin.Any)))/lazyMessage&quot;&gt;lazyMessage&lt;/a&gt; if the &lt;a href=&quot;require#kotlin%24require(kotlin.Boolean,%20kotlin.Function0((kotlin.Any)))/value&quot;&gt;value&lt;/a&gt; is false.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3e3dc9398319dc7d021d329ec499047c0ffa229" translate="yes" xml:space="preserve">
          <source>Throws an &lt;a href=&quot;-illegal-argument-exception/index#kotlin.IllegalArgumentException&quot;&gt;IllegalArgumentException&lt;/a&gt; with the result of calling &lt;a href=&quot;require-not-null#kotlin%24requireNotNull%28kotlin.requireNotNull.T%2C+kotlin.Function0%28%28kotlin.Any%29%29%29%2FlazyMessage&quot;&gt;lazyMessage&lt;/a&gt; if the &lt;a href=&quot;require-not-null#kotlin%24requireNotNull%28kotlin.requireNotNull.T%2C+kotlin.Function0%28%28kotlin.Any%29%29%29%2Fvalue&quot;&gt;value&lt;/a&gt; is null. Otherwise returns the not null value.</source>
          <target state="translated">如果该&lt;a href=&quot;require-not-null#kotlin%24requireNotNull%28kotlin.requireNotNull.T%2C+kotlin.Function0%28%28kotlin.Any%29%29%29%2Fvalue&quot;&gt;值为&lt;/a&gt; null，则抛出&lt;a href=&quot;-illegal-argument-exception/index#kotlin.IllegalArgumentException&quot;&gt;IllegalArgumentException&lt;/a&gt;并导致调用&lt;a href=&quot;require-not-null#kotlin%24requireNotNull%28kotlin.requireNotNull.T%2C+kotlin.Function0%28%28kotlin.Any%29%29%29%2FlazyMessage&quot;&gt;lazyMessage&lt;/a&gt;的结果。否则，返回非null值。</target>
        </trans-unit>
        <trans-unit id="1585605996fe54d528d4847469a1c01a292a3702" translate="yes" xml:space="preserve">
          <source>Throws an &lt;a href=&quot;-illegal-argument-exception/index#kotlin.IllegalArgumentException&quot;&gt;IllegalArgumentException&lt;/a&gt; with the result of calling &lt;a href=&quot;require-not-null#kotlin%24requireNotNull(kotlin.requireNotNull.T?,%20kotlin.Function0((kotlin.Any)))/lazyMessage&quot;&gt;lazyMessage&lt;/a&gt; if the &lt;a href=&quot;require-not-null#kotlin%24requireNotNull(kotlin.requireNotNull.T?,%20kotlin.Function0((kotlin.Any)))/value&quot;&gt;value&lt;/a&gt; is null. Otherwise returns the not null value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cde80ff370e1f63acd5ebfbb8e922a017c83fe9e" translate="yes" xml:space="preserve">
          <source>Throws an &lt;a href=&quot;-illegal-state-exception/index#kotlin.IllegalStateException&quot;&gt;IllegalStateException&lt;/a&gt; if the &lt;a href=&quot;check#kotlin%24check%28kotlin.Boolean%29%2Fvalue&quot;&gt;value&lt;/a&gt; is false.</source>
          <target state="translated">如果&lt;a href=&quot;check#kotlin%24check%28kotlin.Boolean%29%2Fvalue&quot;&gt;值为&lt;/a&gt; false，则引发&lt;a href=&quot;-illegal-state-exception/index#kotlin.IllegalStateException&quot;&gt;IllegalStateException&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ef2f3f8adf5e012243cd34b2702b7a2ac8adf662" translate="yes" xml:space="preserve">
          <source>Throws an &lt;a href=&quot;-illegal-state-exception/index#kotlin.IllegalStateException&quot;&gt;IllegalStateException&lt;/a&gt; if the &lt;a href=&quot;check#kotlin%24check(kotlin.Boolean)/value&quot;&gt;value&lt;/a&gt; is false.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="402cd2d9df6a156fba6fc0cc6697b5d76b649c05" translate="yes" xml:space="preserve">
          <source>Throws an &lt;a href=&quot;-illegal-state-exception/index#kotlin.IllegalStateException&quot;&gt;IllegalStateException&lt;/a&gt; if the &lt;a href=&quot;check-not-null#kotlin%24checkNotNull%28kotlin.checkNotNull.T%29%2Fvalue&quot;&gt;value&lt;/a&gt; is null. Otherwise returns the not null value.</source>
          <target state="translated">如果该&lt;a href=&quot;check-not-null#kotlin%24checkNotNull%28kotlin.checkNotNull.T%29%2Fvalue&quot;&gt;值为&lt;/a&gt; null，则抛出&lt;a href=&quot;-illegal-state-exception/index#kotlin.IllegalStateException&quot;&gt;IllegalStateException&lt;/a&gt;。否则，返回非null值。</target>
        </trans-unit>
        <trans-unit id="dda2799a06b523e6b176c9ee67f6d63f48ada3d8" translate="yes" xml:space="preserve">
          <source>Throws an &lt;a href=&quot;-illegal-state-exception/index#kotlin.IllegalStateException&quot;&gt;IllegalStateException&lt;/a&gt; if the &lt;a href=&quot;check-not-null#kotlin%24checkNotNull(kotlin.checkNotNull.T?)/value&quot;&gt;value&lt;/a&gt; is null. Otherwise returns the not null value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f113c02962407d7507fe9485b4da7237a47f7c4" translate="yes" xml:space="preserve">
          <source>Throws an &lt;a href=&quot;-illegal-state-exception/index#kotlin.IllegalStateException&quot;&gt;IllegalStateException&lt;/a&gt; with the given &lt;a href=&quot;error#kotlin%24error%28kotlin.Any%29%2Fmessage&quot;&gt;message&lt;/a&gt;.</source>
          <target state="translated">使用给定的&lt;a href=&quot;error#kotlin%24error%28kotlin.Any%29%2Fmessage&quot;&gt;消息&lt;/a&gt;引发&lt;a href=&quot;-illegal-state-exception/index#kotlin.IllegalStateException&quot;&gt;IllegalStateException&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5181608eaea2225525164d5696d71e611d6d7bd0" translate="yes" xml:space="preserve">
          <source>Throws an &lt;a href=&quot;-illegal-state-exception/index#kotlin.IllegalStateException&quot;&gt;IllegalStateException&lt;/a&gt; with the given &lt;a href=&quot;error#kotlin%24error(kotlin.Any)/message&quot;&gt;message&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a87a5cbfe4f8dd0bce93da8e99fc5031d54a4b66" translate="yes" xml:space="preserve">
          <source>Throws an &lt;a href=&quot;-illegal-state-exception/index#kotlin.IllegalStateException&quot;&gt;IllegalStateException&lt;/a&gt; with the result of calling &lt;a href=&quot;check#kotlin%24check%28kotlin.Boolean%2C+kotlin.Function0%28%28kotlin.Any%29%29%29%2FlazyMessage&quot;&gt;lazyMessage&lt;/a&gt; if the &lt;a href=&quot;check#kotlin%24check%28kotlin.Boolean%2C+kotlin.Function0%28%28kotlin.Any%29%29%29%2Fvalue&quot;&gt;value&lt;/a&gt; is false.</source>
          <target state="translated">如果&lt;a href=&quot;check#kotlin%24check%28kotlin.Boolean%2C+kotlin.Function0%28%28kotlin.Any%29%29%29%2Fvalue&quot;&gt;值为&lt;/a&gt; false，则引发&lt;a href=&quot;-illegal-state-exception/index#kotlin.IllegalStateException&quot;&gt;IllegalStateException&lt;/a&gt;并导致调用&lt;a href=&quot;check#kotlin%24check%28kotlin.Boolean%2C+kotlin.Function0%28%28kotlin.Any%29%29%29%2FlazyMessage&quot;&gt;lazyMessage&lt;/a&gt;的结果。</target>
        </trans-unit>
        <trans-unit id="f984d420014f0ad6416ec5b1ab125dd6010c5b27" translate="yes" xml:space="preserve">
          <source>Throws an &lt;a href=&quot;-illegal-state-exception/index#kotlin.IllegalStateException&quot;&gt;IllegalStateException&lt;/a&gt; with the result of calling &lt;a href=&quot;check#kotlin%24check(kotlin.Boolean,%20kotlin.Function0((kotlin.Any)))/lazyMessage&quot;&gt;lazyMessage&lt;/a&gt; if the &lt;a href=&quot;check#kotlin%24check(kotlin.Boolean,%20kotlin.Function0((kotlin.Any)))/value&quot;&gt;value&lt;/a&gt; is false.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a52512f1adf6d29a59645748fabb172d879e3685" translate="yes" xml:space="preserve">
          <source>Throws an &lt;a href=&quot;-illegal-state-exception/index#kotlin.IllegalStateException&quot;&gt;IllegalStateException&lt;/a&gt; with the result of calling &lt;a href=&quot;check-not-null#kotlin%24checkNotNull%28kotlin.checkNotNull.T%2C+kotlin.Function0%28%28kotlin.Any%29%29%29%2FlazyMessage&quot;&gt;lazyMessage&lt;/a&gt; if the &lt;a href=&quot;check-not-null#kotlin%24checkNotNull%28kotlin.checkNotNull.T%2C+kotlin.Function0%28%28kotlin.Any%29%29%29%2Fvalue&quot;&gt;value&lt;/a&gt; is null. Otherwise returns the not null value.</source>
          <target state="translated">如果该&lt;a href=&quot;check-not-null#kotlin%24checkNotNull%28kotlin.checkNotNull.T%2C+kotlin.Function0%28%28kotlin.Any%29%29%29%2Fvalue&quot;&gt;值为&lt;/a&gt; null，则抛出&lt;a href=&quot;-illegal-state-exception/index#kotlin.IllegalStateException&quot;&gt;IllegalStateException&lt;/a&gt;并导致调用&lt;a href=&quot;check-not-null#kotlin%24checkNotNull%28kotlin.checkNotNull.T%2C+kotlin.Function0%28%28kotlin.Any%29%29%29%2FlazyMessage&quot;&gt;lazyMessage&lt;/a&gt;的结果。否则，返回非null值。</target>
        </trans-unit>
        <trans-unit id="493d7b4fc94a4de0e97d67db438c813b7833a321" translate="yes" xml:space="preserve">
          <source>Throws an &lt;a href=&quot;-illegal-state-exception/index#kotlin.IllegalStateException&quot;&gt;IllegalStateException&lt;/a&gt; with the result of calling &lt;a href=&quot;check-not-null#kotlin%24checkNotNull(kotlin.checkNotNull.T?,%20kotlin.Function0((kotlin.Any)))/lazyMessage&quot;&gt;lazyMessage&lt;/a&gt; if the &lt;a href=&quot;check-not-null#kotlin%24checkNotNull(kotlin.checkNotNull.T?,%20kotlin.Function0((kotlin.Any)))/value&quot;&gt;value&lt;/a&gt; is null. Otherwise returns the not null value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4dd5a74a27ccc78ea75829f90e11af066deef725" translate="yes" xml:space="preserve">
          <source>Throws an &lt;a href=&quot;../kotlin/-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt; if the size of this list is less than 1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0dfa8cfada0f87002fce9e2dcf29d69386eb81f" translate="yes" xml:space="preserve">
          <source>Throws an &lt;a href=&quot;../kotlin/-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt; if the size of this list is less than 2.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc0636ec717eef51c36cc08b0d19404e2a1e901f" translate="yes" xml:space="preserve">
          <source>Throws an &lt;a href=&quot;../kotlin/-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt; if the size of this list is less than 3.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e916ab2f35fc79abd1560b46cce8cf83ff72163a" translate="yes" xml:space="preserve">
          <source>Throws an &lt;a href=&quot;../kotlin/-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt; if the size of this list is less than 4.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17cfbe66f161c701133c0656f5b1abbe3644c69f" translate="yes" xml:space="preserve">
          <source>Throws an &lt;a href=&quot;../kotlin/-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt; if the size of this list is less than 5.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4fb093191144e508e969bd08f6b07ef13c7da6e0" translate="yes" xml:space="preserve">
          <source>Throws an exception if the sequence is constrained to be iterated once and &lt;code&gt;iterator&lt;/code&gt; is invoked the second time.</source>
          <target state="translated">如果将序列限制为一次迭代，并且第二次调用 &lt;code&gt;iterator&lt;/code&gt; 则抛出异常。</target>
        </trans-unit>
        <trans-unit id="7fd78909be435341dfba595389f3fa1467854f4e" translate="yes" xml:space="preserve">
          <source>Throws an exception if this array is empty. If the array can be empty in an expected way, please use &lt;a href=&quot;reduce-indexed-or-null&quot;&gt;reduceIndexedOrNull&lt;/a&gt; instead. It returns &lt;code&gt;null&lt;/code&gt; when its receiver is empty.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8285a899ac5a29cc7129aa4da6958e875202fb46" translate="yes" xml:space="preserve">
          <source>Throws an exception if this array is empty. If the array can be empty in an expected way, please use &lt;a href=&quot;reduce-or-null&quot;&gt;reduceOrNull&lt;/a&gt; instead. It returns &lt;code&gt;null&lt;/code&gt; when its receiver is empty.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e1ce4459287d83d21368b2dc4cdc52b9cd0160c" translate="yes" xml:space="preserve">
          <source>Throws an exception if this array is empty. If the array can be empty in an expected way, please use &lt;a href=&quot;reduce-right-indexed-or-null&quot;&gt;reduceRightIndexedOrNull&lt;/a&gt; instead. It returns &lt;code&gt;null&lt;/code&gt; when its receiver is empty.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4b2f84f4e57b04b9edd9c87d2979e39d26f5771" translate="yes" xml:space="preserve">
          <source>Throws an exception if this array is empty. If the array can be empty in an expected way, please use &lt;a href=&quot;reduce-right-or-null&quot;&gt;reduceRightOrNull&lt;/a&gt; instead. It returns &lt;code&gt;null&lt;/code&gt; when its receiver is empty.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b185c5f4e93631e2a060ab41fb4eb57e4de681a" translate="yes" xml:space="preserve">
          <source>Throws an exception if this char sequence is empty. If the char sequence can be empty in an expected way, please use &lt;a href=&quot;reduce-indexed-or-null&quot;&gt;reduceIndexedOrNull&lt;/a&gt; instead. It returns &lt;code&gt;null&lt;/code&gt; when its receiver is empty.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef32dfbd1a922263c5c164f620e7b2908d21430d" translate="yes" xml:space="preserve">
          <source>Throws an exception if this char sequence is empty. If the char sequence can be empty in an expected way, please use &lt;a href=&quot;reduce-or-null&quot;&gt;reduceOrNull&lt;/a&gt; instead. It returns &lt;code&gt;null&lt;/code&gt; when its receiver is empty.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e93b6c2ea0c9c6c6ad13686a90f2bf85ab5f5baf" translate="yes" xml:space="preserve">
          <source>Throws an exception if this char sequence is empty. If the char sequence can be empty in an expected way, please use &lt;a href=&quot;reduce-right-indexed-or-null&quot;&gt;reduceRightIndexedOrNull&lt;/a&gt; instead. It returns &lt;code&gt;null&lt;/code&gt; when its receiver is empty.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4fd3822175bffcfa7e80b1f53ede5ab3ae2bc086" translate="yes" xml:space="preserve">
          <source>Throws an exception if this char sequence is empty. If the char sequence can be empty in an expected way, please use &lt;a href=&quot;reduce-right-or-null&quot;&gt;reduceRightOrNull&lt;/a&gt; instead. It returns &lt;code&gt;null&lt;/code&gt; when its receiver is empty.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eacd93615a6dd16e6f9a9d63ee869eefaa897d95" translate="yes" xml:space="preserve">
          <source>Throws an exception if this collection is empty. If the collection can be empty in an expected way, please use &lt;a href=&quot;reduce-indexed-or-null&quot;&gt;reduceIndexedOrNull&lt;/a&gt; instead. It returns &lt;code&gt;null&lt;/code&gt; when its receiver is empty.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7624ee5a82ead06e5c18d4b5b2178b988495c62d" translate="yes" xml:space="preserve">
          <source>Throws an exception if this collection is empty. If the collection can be empty in an expected way, please use &lt;a href=&quot;reduce-or-null&quot;&gt;reduceOrNull&lt;/a&gt; instead. It returns &lt;code&gt;null&lt;/code&gt; when its receiver is empty.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f601e98edd4457fbbb656d028259bf3599380762" translate="yes" xml:space="preserve">
          <source>Throws an exception if this list is empty. If the list can be empty in an expected way, please use &lt;a href=&quot;reduce-right-indexed-or-null&quot;&gt;reduceRightIndexedOrNull&lt;/a&gt; instead. It returns &lt;code&gt;null&lt;/code&gt; when its receiver is empty.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6b616691ee940145aebe0fc262a2f6d65461cd7" translate="yes" xml:space="preserve">
          <source>Throws an exception if this list is empty. If the list can be empty in an expected way, please use &lt;a href=&quot;reduce-right-or-null&quot;&gt;reduceRightOrNull&lt;/a&gt; instead. It returns &lt;code&gt;null&lt;/code&gt; when its receiver is empty.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4581922a0ef91d93af0368bead5bd7539b44ea3" translate="yes" xml:space="preserve">
          <source>Throws an exception if this sequence is empty. If the sequence can be empty in an expected way, please use &lt;a href=&quot;reduce-indexed-or-null&quot;&gt;reduceIndexedOrNull&lt;/a&gt; instead. It returns &lt;code&gt;null&lt;/code&gt; when its receiver is empty.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ce91e94c848fefcebcae40244d52f7890553ddb" translate="yes" xml:space="preserve">
          <source>Throws an exception if this sequence is empty. If the sequence can be empty in an expected way, please use &lt;a href=&quot;reduce-or-null&quot;&gt;reduceOrNull&lt;/a&gt; instead. It returns &lt;code&gt;null&lt;/code&gt; when its receiver is empty.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="802eb217aa06b1ddcf50385d8b88823ead2d004a" translate="yes" xml:space="preserve">
          <source>Throws an exception since enum constants cannot be cloned. This method prevents enum classes from inheriting from &lt;code&gt;Cloneable&lt;/code&gt;.</source>
          <target state="translated">由于无法克隆枚举常量，因此引发异常。此方法防止枚举类从 &lt;code&gt;Cloneable&lt;/code&gt; 继承。</target>
        </trans-unit>
        <trans-unit id="abf5b40e0b4f0a5382568a99833124d4e1e46035" translate="yes" xml:space="preserve">
          <source>Thus, if the layout filename is &lt;code&gt;activity_main.xml&lt;/code&gt;, we'd import &lt;code&gt;kotlinx.android.synthetic.main.activity_main.*&lt;/code&gt;.</source>
          <target state="translated">因此，如果布局文件名是 &lt;code&gt;activity_main.xml&lt;/code&gt; ，我们将导入 &lt;code&gt;kotlinx.android.synthetic.main.activity_main.*&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="97edcc8b1307ff786c44c31ec2579356e7a22d17" translate="yes" xml:space="preserve">
          <source>Thus, if you want an NPE, you can have it, but you have to ask for it explicitly, and it does not appear out of the blue.</source>
          <target state="translated">因此,如果你想要一个NPE,你可以拥有它,但你必须明确要求它,它不会突然出现。</target>
        </trans-unit>
        <trans-unit id="dd3fb291d3a706316d022aff145e9de544011b65" translate="yes" xml:space="preserve">
          <source>Thus, single quotes can not be used to form string literals.</source>
          <target state="translated">因此,不能用单引号来形成字符串字面。</target>
        </trans-unit>
        <trans-unit id="1b9124e1ec7c5edcf4abab648d63459254b7d7ee" translate="yes" xml:space="preserve">
          <source>Thus, the &lt;code&gt;last&lt;/code&gt; element is not always the same as the specified end value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3018655a2f36aad6ef9ad9471b91d569410cec76" translate="yes" xml:space="preserve">
          <source>Thus, you can create something resource manager-like by creating a class that implements &lt;code&gt;Closeable&lt;/code&gt;, does its setup work in &lt;code&gt;init&lt;/code&gt;, and does its cleanup work in &lt;code&gt;close()&lt;/code&gt;.</source>
          <target state="translated">因此，您可以通过创建一个实现 &lt;code&gt;Closeable&lt;/code&gt; 的类，类似于 &lt;code&gt;init&lt;/code&gt; 的设置工作以及采用 &lt;code&gt;close()&lt;/code&gt; 的清理工作的类来创建类似于资源管理器的对象。</target>
        </trans-unit>
        <trans-unit id="6f717771b6bc333649ebdd74853decf5175f1649" translate="yes" xml:space="preserve">
          <source>Ticker channel is a special rendezvous channel that produces &lt;code&gt;Unit&lt;/code&gt; every time given delay passes since last consumption from this channel. Though it may seem to be useless standalone, it is a useful building block to create complex time-based &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/produce.html&quot;&gt;produce&lt;/a&gt; pipelines and operators that do windowing and other time-dependent processing. Ticker channel can be used in &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.selects/select.html&quot;&gt;select&lt;/a&gt; to perform &quot;on tick&quot; action.</source>
          <target state="translated">股票行情通道是一种特殊的会合通道，自从该通道的最后一次消费以来，每经过给定的延迟，就会生成 &lt;code&gt;Unit&lt;/code&gt; 。尽管它看起来似乎是无用的，但它是创建复杂的基于时间的&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/produce.html&quot;&gt;生产&lt;/a&gt;管道和执行加窗及其他与时间相关的处理的运算符的有用构建块。股票行情通道可用于&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.selects/select.html&quot;&gt;选择&lt;/a&gt;以执行&amp;ldquo; 股票行情&amp;rdquo;操作。</target>
        </trans-unit>
        <trans-unit id="709221186863e6ea184e824b11c1140ada1e2ad5" translate="yes" xml:space="preserve">
          <source>Ticker channels</source>
          <target state="translated">报价频道</target>
        </trans-unit>
        <trans-unit id="63320b186f0d534224159af37ea2139273bd1f6c" translate="yes" xml:space="preserve">
          <source>Time unit representing one day, which is always equal to 24 hours.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="877ba4bc277c902e0734e2ffcb282d31130b4f5b" translate="yes" xml:space="preserve">
          <source>Time unit representing one hour.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e13f33001c6412bef1563d532ed0814ae7fe14e4" translate="yes" xml:space="preserve">
          <source>Time unit representing one microsecond, which is 1/1000 of a millisecond.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69bd96548a564e999c99e810765a0e91f82651be" translate="yes" xml:space="preserve">
          <source>Time unit representing one millisecond, which is 1/1000 of a second.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="596db628883d083bd5767a0e071af81c363164e2" translate="yes" xml:space="preserve">
          <source>Time unit representing one minute.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c55ed39b5dc095ccfcfc2f009b87f746b868a8d9" translate="yes" xml:space="preserve">
          <source>Time unit representing one nanosecond, which is 1/1000 of a microsecond.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9dbcaa261c78b418e4aebabb43ab10eb5d2c894" translate="yes" xml:space="preserve">
          <source>Time unit representing one second.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10572d800e81a954a70d12fcb00a40ac135136f2" translate="yes" xml:space="preserve">
          <source>TimeMark</source>
          <target state="translated">TimeMark</target>
        </trans-unit>
        <trans-unit id="6e9104aba3fe18e4dd8562ba5f52cb92ded067dc" translate="yes" xml:space="preserve">
          <source>TimeRanges</source>
          <target state="translated">TimeRanges</target>
        </trans-unit>
        <trans-unit id="c90348d5ff080b78282efd07b8b0ed4226890eee" translate="yes" xml:space="preserve">
          <source>TimeSource</source>
          <target state="translated">TimeSource</target>
        </trans-unit>
        <trans-unit id="eca969ef85583fca89468fa678b49acb2534e5b8" translate="yes" xml:space="preserve">
          <source>TimedValue</source>
          <target state="translated">TimedValue</target>
        </trans-unit>
        <trans-unit id="d4c45de0fe64ac43c72a798c67faaadadfaa1b90" translate="yes" xml:space="preserve">
          <source>Timeout</source>
          <target state="translated">Timeout</target>
        </trans-unit>
        <trans-unit id="799c2191675c2bb6c5c783e298421617f1390ce2" translate="yes" xml:space="preserve">
          <source>To &lt;a href=&quot;https://blog.jetbrains.com/kotlin/2017/01/kotlin-1-1-whats-coming-in-the-standard-library/&quot;&gt;prepare for Java 9 support&lt;/a&gt;, the extension functions and properties in the &lt;code&gt;kotlin-reflect.jar&lt;/code&gt; library have been moved to the package &lt;code&gt;kotlin.reflect.full&lt;/code&gt;. The names in the old package (&lt;code&gt;kotlin.reflect&lt;/code&gt;) are deprecated and will be removed in Kotlin 1.2. Note that the core reflection interfaces (such as &lt;code&gt;KClass&lt;/code&gt;) are part of the Kotlin standard library, not &lt;code&gt;kotlin-reflect&lt;/code&gt;, and are not affected by the move.</source>
          <target state="translated">为了&lt;a href=&quot;https://blog.jetbrains.com/kotlin/2017/01/kotlin-1-1-whats-coming-in-the-standard-library/&quot;&gt;准备对Java 9的支持&lt;/a&gt;， &lt;code&gt;kotlin-reflect.jar&lt;/code&gt; 库中的扩展功能和属性移到了package &lt;code&gt;kotlin.reflect.full&lt;/code&gt; 中。旧软件包（ &lt;code&gt;kotlin.reflect&lt;/code&gt; ）中的名称已弃用，并将在Kotlin 1.2中删除。请注意，核心反射接口（例如 &lt;code&gt;KClass&lt;/code&gt; ）是Kotlin标准库的一部分，而不是 &lt;code&gt;kotlin-reflect&lt;/code&gt; ，并且不受此移动的影响。</target>
        </trans-unit>
        <trans-unit id="05823a5d5a74d4953764cdf3ac4c6b3fb68f1e64" translate="yes" xml:space="preserve">
          <source>To Use</source>
          <target state="translated">使用方法</target>
        </trans-unit>
        <trans-unit id="9d9e0e01bc3681e891f7f867582c90865280f877" translate="yes" xml:space="preserve">
          <source>To accept and propagate the experimental status to your whole module, compile the module with the argument &lt;code&gt;-Xexperimental=org.mylibrary.ExperimentalMarker&lt;/code&gt;. In this case, &lt;em&gt;every declaration&lt;/em&gt; in the module becomes experimental. The use of the module requires the acceptance of its experimental status as well.</source>
          <target state="translated">要接受实验状态并将其传播到整个模块，请使用 &lt;code&gt;-Xexperimental=org.mylibrary.ExperimentalMarker&lt;/code&gt; 参数编译该模块。在这种情况下，模块中的&lt;em&gt;每个声明&lt;/em&gt;都将变为实验性的。使用该模块还需要接受其实验状态。</target>
        </trans-unit>
        <trans-unit id="c0b5cb313d227acb944e950971366b62de8d6de6" translate="yes" xml:space="preserve">
          <source>To accept the experimental status without propagation, compile the module with the argument &lt;code&gt;-Xuse-experimental&lt;/code&gt;, specifying the fully qualified name of the experimental API marker you use: &lt;code&gt;-Xuse-experimental=org.mylibrary.ExperimentalMarker&lt;/code&gt;. Compiling with this argument has the same effect as if every declaration in the module had the annotation&lt;code&gt;@UseExperimental(ExperimentalMarker::class)&lt;/code&gt;.</source>
          <target state="translated">要接受不传播的实验状态，请使用 &lt;code&gt;-Xuse-experimental&lt;/code&gt; 参数编译模块，并指定要使用的实验API标记的完全限定名称： &lt;code&gt;-Xuse-experimental=org.mylibrary.ExperimentalMarker&lt;/code&gt; 。使用此参数进行编译的效果与模块中的每个声明都具有注释 &lt;code&gt;@UseExperimental(ExperimentalMarker::class)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9903a558b00c4bc82f88c2dfad1d5c92c9e2ae3f" translate="yes" xml:space="preserve">
          <source>To accept the usage of multiple experimental APIs on the module level, add one of the described arguments for each experimental API marker used in your module.</source>
          <target state="translated">要在模块级别上接受多个实验性API的使用,请为您的模块中使用的每个实验性API标记添加所述参数之一。</target>
        </trans-unit>
        <trans-unit id="d162c0174f5af87401e6b5d45d66155192832d80" translate="yes" xml:space="preserve">
          <source>To access &lt;em&gt;this&lt;/em&gt; from an outer scope (a &lt;a href=&quot;classes&quot;&gt;class&lt;/a&gt;, or &lt;a href=&quot;extensions&quot;&gt;extension function&lt;/a&gt;, or labeled &lt;a href=&quot;lambdas#function-literals-with-receiver&quot;&gt;function literal with receiver&lt;/a&gt;) we write &lt;code&gt;this@label&lt;/code&gt; where &lt;code&gt;@label&lt;/code&gt; is a &lt;a href=&quot;returns&quot;&gt;label&lt;/a&gt; on the scope &lt;em&gt;this&lt;/em&gt; is meant to be from:</source>
          <target state="translated">要访问&lt;em&gt;这个&lt;/em&gt;外部范围（一&lt;a href=&quot;classes&quot;&gt;类&lt;/a&gt;，或&lt;a href=&quot;extensions&quot;&gt;扩展功能&lt;/a&gt;，或标记&lt;a href=&quot;lambdas#function-literals-with-receiver&quot;&gt;与接收机功能字面&lt;/a&gt;）我们写 &lt;code&gt;this@label&lt;/code&gt; 其中 &lt;code&gt;@label&lt;/code&gt; 是一个&lt;a href=&quot;returns&quot;&gt;标签&lt;/a&gt;上的范围&lt;em&gt;这&lt;/em&gt;意味着是从：</target>
        </trans-unit>
        <trans-unit id="5db6557812d02b15eefb7397c674770717b897fd" translate="yes" xml:space="preserve">
          <source>To access a property that is a member of a class, we qualify it:</source>
          <target state="translated">要访问一个属于类的成员的属性,我们对其进行限定。</target>
        </trans-unit>
        <trans-unit id="81410d36157afd9871ba5225faca2642fb141190" translate="yes" xml:space="preserve">
          <source>To access properties as first-class objects in Kotlin, we can also use the &lt;code&gt;::&lt;/code&gt; operator:</source>
          <target state="translated">要将属性作为Kotlin中的一流对象进行访问，我们还可以使用 &lt;code&gt;::&lt;/code&gt; 运算符：</target>
        </trans-unit>
        <trans-unit id="58a760c627562db97cdca1a84e7db3c27c2f629c" translate="yes" xml:space="preserve">
          <source>To access static members of a Java type that is &lt;a href=&quot;#mapped-types&quot;&gt;mapped&lt;/a&gt; to a Kotlin type, use the full qualified name of the Java type: &lt;code&gt;java.lang.Integer.bitCount(foo)&lt;/code&gt;.</source>
          <target state="translated">要访问&lt;a href=&quot;#mapped-types&quot;&gt;映射&lt;/a&gt;到Kotlin类型的Java类型的静态成员，请使用Java类型的全限定名称： &lt;code&gt;java.lang.Integer.bitCount(foo)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7529d2d95d23cbd6b23debe45e1e3095efe982cc" translate="yes" xml:space="preserve">
          <source>To achieve &lt;code&gt;mutable XOR global&lt;/code&gt; invariant, all globally visible state (currently, &lt;code&gt;object&lt;/code&gt; singletons and enums) are automatically frozen. If object freezing is not desired, a &lt;code&gt;kotlin.native.ThreadLocal&lt;/code&gt; annotation can be used, which will make the object state thread local, and so, mutable (but the changed state is not visible to other threads).</source>
          <target state="translated">为了实现 &lt;code&gt;mutable XOR global&lt;/code&gt; 不变性，所有全局可见状态（当前是 &lt;code&gt;object&lt;/code&gt; 单例和枚举）都将自动冻结。如果不需要冻结对象，则可以使用 &lt;code&gt;kotlin.native.ThreadLocal&lt;/code&gt; 批注，这将使对象状态线程处于局部状态，因此是可变的（但更改后的状态对其他线程不可见）。</target>
        </trans-unit>
        <trans-unit id="1019a589281c0c646b20946b4cd19b5c15e8fdaa" translate="yes" xml:space="preserve">
          <source>To activate DCE tool, add the following line to &lt;code&gt;build.gradle&lt;/code&gt;:</source>
          <target state="translated">要激活DCE工具，请将以下行添加到 &lt;code&gt;build.gradle&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="518dd8e0c3f079203e35eb4b3c3a2d8d28ec483f" translate="yes" xml:space="preserve">
          <source>To add a dependency on a library, set the dependency of the required &lt;a href=&quot;#dependency-types&quot;&gt;type&lt;/a&gt; (for example, &lt;code&gt;implementation&lt;/code&gt;) in the &lt;code&gt;dependencies&lt;/code&gt; block of the source sets DSL.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c4bb60ccc35accc967ef970dec8a3a413d9d346" translate="yes" xml:space="preserve">
          <source>To add a dependency on a library, set the dependency of the required &lt;a href=&quot;using-gradle#dependency-types&quot;&gt;type&lt;/a&gt; (for example, &lt;code&gt;implementation&lt;/code&gt;) in the &lt;code&gt;dependencies&lt;/code&gt; block of the source sets DSL.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7881622441c034d7bab9ec188cf250853bf301a" translate="yes" xml:space="preserve">
          <source>To add a dependency to a source set, use a &lt;code&gt;dependencies { ... }&lt;/code&gt; block of the source sets DSL. Four kinds of dependencies are supported:</source>
          <target state="translated">要向源集添加依赖项，请使用源集DSL 的 &lt;code&gt;dependencies { ... }&lt;/code&gt; 块。支持四种依赖项：</target>
        </trans-unit>
        <trans-unit id="1a499912e7035afeaf92f7261767aa556ac8c3f9" translate="yes" xml:space="preserve">
          <source>To add a new key-value pair to a mutable map, use &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-mutable-map/put&quot;&gt;&lt;code&gt;put()&lt;/code&gt;&lt;/a&gt;. When a new entry is put into a &lt;code&gt;LinkedHashMap&lt;/code&gt; (the default map implementation), it is added so that it comes last when iterating the map. In sorted maps, the positions of new elements are defined by the order of their keys.</source>
          <target state="translated">要将新的键值对添加到可变映射，请使用&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-mutable-map/put&quot;&gt; &lt;code&gt;put()&lt;/code&gt; &lt;/a&gt;。将新条目放入 &lt;code&gt;LinkedHashMap&lt;/code&gt; （默认地图实现）后，会添加该条目，以便在迭代地图时排在最后。在排序的地图中，新元素的位置由其键顺序定义。</target>
        </trans-unit>
        <trans-unit id="f2454f68b2510146a6d3830da5c71ddda2db8b87" translate="yes" xml:space="preserve">
          <source>To add a single element to a list or a set, use the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-mutable-list/add&quot;&gt;&lt;code&gt;add()&lt;/code&gt;&lt;/a&gt; function. The specified object is appended to the end of the collection.</source>
          <target state="translated">要将单个元素添加到列表或集合，请使用&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-mutable-list/add&quot;&gt; &lt;code&gt;add()&lt;/code&gt; &lt;/a&gt;函数。指定的对象将追加到集合的末尾。</target>
        </trans-unit>
        <trans-unit id="7cc1110c5b9a5333f0f0fec5eb2e00b218df46d2" translate="yes" xml:space="preserve">
          <source>To add elements to a specific position in a list, use &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-mutable-list/add&quot;&gt;&lt;code&gt;add()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/add-all&quot;&gt;&lt;code&gt;addAll()&lt;/code&gt;&lt;/a&gt; providing the position for element insertion as an additional argument. All elements that come after the position shift to the right.</source>
          <target state="translated">要将元素添加到列表中的特定位置，请使用&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-mutable-list/add&quot;&gt; &lt;code&gt;add()&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/add-all&quot;&gt; &lt;code&gt;addAll()&lt;/code&gt; &lt;/a&gt;提供元素插入的位置作为附加参数。位置之后的所有元素都向右移动。</target>
        </trans-unit>
        <trans-unit id="8035a3b6b37b3480851f2821e2b47d2393940de4" translate="yes" xml:space="preserve">
          <source>To add multiple entries at a time, use &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/put-all&quot;&gt;&lt;code&gt;putAll()&lt;/code&gt;&lt;/a&gt;. Its argument can be a &lt;code&gt;Map&lt;/code&gt; or a group of &lt;code&gt;Pair&lt;/code&gt;s: &lt;code&gt;Iterable&lt;/code&gt;, &lt;code&gt;Sequence&lt;/code&gt;, or &lt;code&gt;Array&lt;/code&gt;.</source>
          <target state="translated">要一次添加多个条目，请使用&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/put-all&quot;&gt; &lt;code&gt;putAll()&lt;/code&gt; &lt;/a&gt;。它的参数可以是 &lt;code&gt;Map&lt;/code&gt; 或 &lt;code&gt;Pair&lt;/code&gt; 的组： &lt;code&gt;Iterable&lt;/code&gt; ， &lt;code&gt;Sequence&lt;/code&gt; 或 &lt;code&gt;Array&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6aac6c02c5c8182c376328758ec65c08ad1e19d6" translate="yes" xml:space="preserve">
          <source>To add the Kotlin support to your Eclipse IDE, install the &lt;em&gt;Kotlin Plugin for Eclipse&lt;/em&gt;. We recommend installing the Kotlin plugin from &lt;a href=&quot;http://marketplace.eclipse.org/content/kotlin-plugin-eclipse&quot;&gt;Eclipse Marketplace&lt;/a&gt;. One option is to drag this button into a running Eclipse window:</source>
          <target state="translated">要将Kotlin支持添加到您的Eclipse IDE中，请安装&lt;em&gt;Kotlin Plugin for Eclipse&lt;/em&gt;。我们建议从&lt;a href=&quot;http://marketplace.eclipse.org/content/kotlin-plugin-eclipse&quot;&gt;Eclipse Marketplace&lt;/a&gt;安装Kotlin插件。一种选择是将此按钮拖动到正在运行的Eclipse窗口中：</target>
        </trans-unit>
        <trans-unit id="11458a551629eb8e637b1b4f455d800a9c36a1f1" translate="yes" xml:space="preserve">
          <source>To address this problem, in Kotlin 1.1 a special mechanism to control receiver scope was introduced.</source>
          <target state="translated">为了解决这个问题,在Kotlin 1.1中引入了一种特殊的机制来控制接收器的范围。</target>
        </trans-unit>
        <trans-unit id="fa01e838f66ea96e149d6c1d033b2d0ba7c11c23" translate="yes" xml:space="preserve">
          <source>To adjust the name for the JavaScript &lt;em&gt;module&lt;/em&gt; (which is generated in &lt;code&gt;build/js/packages/myModuleName&lt;/code&gt;), including the corresponding &lt;code&gt;.js&lt;/code&gt; and &lt;code&gt;.d.ts&lt;/code&gt; files, use the &lt;code&gt;moduleName&lt;/code&gt; option:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93364070d4707402d500a207978499a9a901b72c" translate="yes" xml:space="preserve">
          <source>To allow nulls, we can declare a variable as nullable string, written &lt;code&gt;String?&lt;/code&gt;:</source>
          <target state="translated">为了允许空值，我们可以将变量声明为可空字符串，写成 &lt;code&gt;String?&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="f2b28f33c9dfafdc6b47099300c488e134702926" translate="yes" xml:space="preserve">
          <source>To annotate the receiver parameter of an extension function, use the following syntax:</source>
          <target state="translated">要对扩展函数的接收器参数进行注释,请使用以下语法。</target>
        </trans-unit>
        <trans-unit id="27d0b2adae39bd08addf9e085ed30cd88ae2eee6" translate="yes" xml:space="preserve">
          <source>To apply a function to elements in the reverse order, use functions &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/reduce-right&quot;&gt;&lt;code&gt;reduceRight()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/fold-right&quot;&gt;&lt;code&gt;foldRight()&lt;/code&gt;&lt;/a&gt;. They work in a way similar to &lt;code&gt;fold()&lt;/code&gt; and &lt;code&gt;reduce()&lt;/code&gt; but start from the last element and then continue to previous. Note that when folding or reducing right, the operation arguments change their order: first goes the element, and then the accumulated value.</source>
          <target state="translated">要将函数以相反的顺序应用于元素，请使用函数&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/reduce-right&quot;&gt; &lt;code&gt;reduceRight()&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/fold-right&quot;&gt; &lt;code&gt;foldRight()&lt;/code&gt; &lt;/a&gt;。它们的工作方式类似于 &lt;code&gt;fold()&lt;/code&gt; 和 &lt;code&gt;reduce()&lt;/code&gt; ,但从最后一个元素开始，然后再继续到上一个。请注意，在折叠或右移时，操作参数会更改其顺序：首先移至元素，然后移至累加值。</target>
        </trans-unit>
        <trans-unit id="2a59cafd76f62ee4d0be26a47e36b2b9add63e94" translate="yes" xml:space="preserve">
          <source>To apply the &lt;code&gt;kotlin-multiplatform&lt;/code&gt; plugin, just add the following snippet into your build script:</source>
          <target state="translated">要应用 &lt;code&gt;kotlin-multiplatform&lt;/code&gt; 插件，只需将以下代码段添加到您的构建脚本中：</target>
        </trans-unit>
        <trans-unit id="3ca39dc59e8cc90057c5b6aa659388256e0056c5" translate="yes" xml:space="preserve">
          <source>To automatically trigger a re-build of your application after making changes to the source files, use the Gradle &lt;a href=&quot;https://docs.gradle.org/current/userguide/command_line_interface.html#sec:continuous_build&quot;&gt;continuous build&lt;/a&gt; feature:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93d5ab42155015ed266c58696481bdeab9ce4844" translate="yes" xml:space="preserve">
          <source>To avoid ambiguous results when strings in &lt;a href=&quot;find-any-of#kotlin.text%24findAnyOf%28kotlin.CharSequence%2C+kotlin.collections.Collection%28%28kotlin.String%29%29%2C+kotlin.Int%2C+kotlin.Boolean%29%2Fstrings&quot;&gt;strings&lt;/a&gt; have characters in common, this method proceeds from the beginning to the end of this string, and finds at each position the first element in &lt;a href=&quot;find-any-of#kotlin.text%24findAnyOf%28kotlin.CharSequence%2C+kotlin.collections.Collection%28%28kotlin.String%29%29%2C+kotlin.Int%2C+kotlin.Boolean%29%2Fstrings&quot;&gt;strings&lt;/a&gt; that matches this string at that position.</source>
          <target state="translated">为了避免模棱两可的结果时在字符串&lt;a href=&quot;find-any-of#kotlin.text%24findAnyOf%28kotlin.CharSequence%2C+kotlin.collections.Collection%28%28kotlin.String%29%29%2C+kotlin.Int%2C+kotlin.Boolean%29%2Fstrings&quot;&gt;的字符串&lt;/a&gt;在共同拥有的字符，该方法从一开始就进行到这个字符串的末尾，发现在每个位置中的第一个元素&lt;a href=&quot;find-any-of#kotlin.text%24findAnyOf%28kotlin.CharSequence%2C+kotlin.collections.Collection%28%28kotlin.String%29%29%2C+kotlin.Int%2C+kotlin.Boolean%29%2Fstrings&quot;&gt;的字符串&lt;/a&gt;，该字符串在该位置相匹配。</target>
        </trans-unit>
        <trans-unit id="91b39bd7e91bbd35306d062a5989d8160e42b8de" translate="yes" xml:space="preserve">
          <source>To avoid ambiguous results when strings in &lt;a href=&quot;find-any-of#kotlin.text%24findAnyOf(kotlin.CharSequence,%20kotlin.collections.Collection((kotlin.String)),%20kotlin.Int,%20kotlin.Boolean)/strings&quot;&gt;strings&lt;/a&gt; have characters in common, this method proceeds from the beginning to the end of this string, and finds at each position the first element in &lt;a href=&quot;find-any-of#kotlin.text%24findAnyOf(kotlin.CharSequence,%20kotlin.collections.Collection((kotlin.String)),%20kotlin.Int,%20kotlin.Boolean)/strings&quot;&gt;strings&lt;/a&gt; that matches this string at that position.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0112a7d95b0f1e5eac2132ba1ef497e36b55c4f" translate="yes" xml:space="preserve">
          <source>To avoid ambiguous results when strings in &lt;a href=&quot;find-last-any-of#kotlin.text%24findLastAnyOf%28kotlin.CharSequence%2C+kotlin.collections.Collection%28%28kotlin.String%29%29%2C+kotlin.Int%2C+kotlin.Boolean%29%2Fstrings&quot;&gt;strings&lt;/a&gt; have characters in common, this method proceeds from the end toward the beginning of this string, and finds at each position the first element in &lt;a href=&quot;find-last-any-of#kotlin.text%24findLastAnyOf%28kotlin.CharSequence%2C+kotlin.collections.Collection%28%28kotlin.String%29%29%2C+kotlin.Int%2C+kotlin.Boolean%29%2Fstrings&quot;&gt;strings&lt;/a&gt; that matches this string at that position.</source>
          <target state="translated">为了避免模棱两可的结果时在字符串&lt;a href=&quot;find-last-any-of#kotlin.text%24findLastAnyOf%28kotlin.CharSequence%2C+kotlin.collections.Collection%28%28kotlin.String%29%29%2C+kotlin.Int%2C+kotlin.Boolean%29%2Fstrings&quot;&gt;的字符串&lt;/a&gt;在共同拥有的字符，该方法从朝着这个字符串的开始端部进行，发现在每个位置中的第一个元素&lt;a href=&quot;find-last-any-of#kotlin.text%24findLastAnyOf%28kotlin.CharSequence%2C+kotlin.collections.Collection%28%28kotlin.String%29%29%2C+kotlin.Int%2C+kotlin.Boolean%29%2Fstrings&quot;&gt;的字符串&lt;/a&gt;，该字符串在该位置相匹配。</target>
        </trans-unit>
        <trans-unit id="313c30481943d6f382ca1f81ef0079a1e108b27b" translate="yes" xml:space="preserve">
          <source>To avoid ambiguous results when strings in &lt;a href=&quot;find-last-any-of#kotlin.text%24findLastAnyOf(kotlin.CharSequence,%20kotlin.collections.Collection((kotlin.String)),%20kotlin.Int,%20kotlin.Boolean)/strings&quot;&gt;strings&lt;/a&gt; have characters in common, this method proceeds from the end toward the beginning of this string, and finds at each position the first element in &lt;a href=&quot;find-last-any-of#kotlin.text%24findLastAnyOf(kotlin.CharSequence,%20kotlin.collections.Collection((kotlin.String)),%20kotlin.Int,%20kotlin.Boolean)/strings&quot;&gt;strings&lt;/a&gt; that matches this string at that position.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4027c8136b6286dfe349c3bde29fd950bfe158c1" translate="yes" xml:space="preserve">
          <source>To avoid ambiguous results when strings in &lt;a href=&quot;index-of-any#kotlin.text%24indexOfAny%28kotlin.CharSequence%2C+kotlin.collections.Collection%28%28kotlin.String%29%29%2C+kotlin.Int%2C+kotlin.Boolean%29%2Fstrings&quot;&gt;strings&lt;/a&gt; have characters in common, this method proceeds from the beginning to the end of this string, and finds at each position the first element in &lt;a href=&quot;index-of-any#kotlin.text%24indexOfAny%28kotlin.CharSequence%2C+kotlin.collections.Collection%28%28kotlin.String%29%29%2C+kotlin.Int%2C+kotlin.Boolean%29%2Fstrings&quot;&gt;strings&lt;/a&gt; that matches this string at that position.</source>
          <target state="translated">为了避免模棱两可的结果时在字符串&lt;a href=&quot;index-of-any#kotlin.text%24indexOfAny%28kotlin.CharSequence%2C+kotlin.collections.Collection%28%28kotlin.String%29%29%2C+kotlin.Int%2C+kotlin.Boolean%29%2Fstrings&quot;&gt;的字符串&lt;/a&gt;在共同拥有的字符，该方法从一开始就进行到这个字符串的末尾，发现在每个位置中的第一个元素&lt;a href=&quot;index-of-any#kotlin.text%24indexOfAny%28kotlin.CharSequence%2C+kotlin.collections.Collection%28%28kotlin.String%29%29%2C+kotlin.Int%2C+kotlin.Boolean%29%2Fstrings&quot;&gt;的字符串&lt;/a&gt;，该字符串在该位置相匹配。</target>
        </trans-unit>
        <trans-unit id="511a802d66276d56dea9179b2c2f2932520462fa" translate="yes" xml:space="preserve">
          <source>To avoid ambiguous results when strings in &lt;a href=&quot;index-of-any#kotlin.text%24indexOfAny(kotlin.CharSequence,%20kotlin.collections.Collection((kotlin.String)),%20kotlin.Int,%20kotlin.Boolean)/strings&quot;&gt;strings&lt;/a&gt; have characters in common, this method proceeds from the beginning to the end of this string, and finds at each position the first element in &lt;a href=&quot;index-of-any#kotlin.text%24indexOfAny(kotlin.CharSequence,%20kotlin.collections.Collection((kotlin.String)),%20kotlin.Int,%20kotlin.Boolean)/strings&quot;&gt;strings&lt;/a&gt; that matches this string at that position.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31bfe127214639414101a9ca7c2a589e0f9d8655" translate="yes" xml:space="preserve">
          <source>To avoid ambiguous results when strings in &lt;a href=&quot;last-index-of-any#kotlin.text%24lastIndexOfAny%28kotlin.CharSequence%2C+kotlin.collections.Collection%28%28kotlin.String%29%29%2C+kotlin.Int%2C+kotlin.Boolean%29%2Fstrings&quot;&gt;strings&lt;/a&gt; have characters in common, this method proceeds from the end toward the beginning of this string, and finds at each position the first element in &lt;a href=&quot;last-index-of-any#kotlin.text%24lastIndexOfAny%28kotlin.CharSequence%2C+kotlin.collections.Collection%28%28kotlin.String%29%29%2C+kotlin.Int%2C+kotlin.Boolean%29%2Fstrings&quot;&gt;strings&lt;/a&gt; that matches this string at that position.</source>
          <target state="translated">为了避免模棱两可的结果时在字符串&lt;a href=&quot;last-index-of-any#kotlin.text%24lastIndexOfAny%28kotlin.CharSequence%2C+kotlin.collections.Collection%28%28kotlin.String%29%29%2C+kotlin.Int%2C+kotlin.Boolean%29%2Fstrings&quot;&gt;的字符串&lt;/a&gt;在共同拥有的字符，该方法从朝着这个字符串的开始端部进行，发现在每个位置中的第一个元素&lt;a href=&quot;last-index-of-any#kotlin.text%24lastIndexOfAny%28kotlin.CharSequence%2C+kotlin.collections.Collection%28%28kotlin.String%29%29%2C+kotlin.Int%2C+kotlin.Boolean%29%2Fstrings&quot;&gt;的字符串&lt;/a&gt;，该字符串在该位置相匹配。</target>
        </trans-unit>
        <trans-unit id="98541eec86ea0f0ca7790dd22601b3805220f6d7" translate="yes" xml:space="preserve">
          <source>To avoid ambiguous results when strings in &lt;a href=&quot;last-index-of-any#kotlin.text%24lastIndexOfAny(kotlin.CharSequence,%20kotlin.collections.Collection((kotlin.String)),%20kotlin.Int,%20kotlin.Boolean)/strings&quot;&gt;strings&lt;/a&gt; have characters in common, this method proceeds from the end toward the beginning of this string, and finds at each position the first element in &lt;a href=&quot;last-index-of-any#kotlin.text%24lastIndexOfAny(kotlin.CharSequence,%20kotlin.collections.Collection((kotlin.String)),%20kotlin.Int,%20kotlin.Boolean)/strings&quot;&gt;strings&lt;/a&gt; that matches this string at that position.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6276ae19b8071911e89a3dcb94d020bccd844c9c" translate="yes" xml:space="preserve">
          <source>To avoid ambiguous results when strings in &lt;a href=&quot;split#kotlin.text%24split%28kotlin.CharSequence%2C+kotlin.Array%28%28kotlin.String%29%29%2C+kotlin.Boolean%2C+kotlin.Int%29%2Fdelimiters&quot;&gt;delimiters&lt;/a&gt; have characters in common, this method proceeds from the beginning to the end of this string, and matches at each position the first element in &lt;a href=&quot;split#kotlin.text%24split%28kotlin.CharSequence%2C+kotlin.Array%28%28kotlin.String%29%29%2C+kotlin.Boolean%2C+kotlin.Int%29%2Fdelimiters&quot;&gt;delimiters&lt;/a&gt; that is equal to a delimiter in this instance at that position.</source>
          <target state="translated">为了避免在&lt;a href=&quot;split#kotlin.text%24split%28kotlin.CharSequence%2C+kotlin.Array%28%28kotlin.String%29%29%2C+kotlin.Boolean%2C+kotlin.Int%29%2Fdelimiters&quot;&gt;定界符中的&lt;/a&gt;字符串具有共同的字符时导致模棱两可的结果，此方法从该字符串的开头到末尾进行，并在每个位置处匹配&lt;a href=&quot;split#kotlin.text%24split%28kotlin.CharSequence%2C+kotlin.Array%28%28kotlin.String%29%29%2C+kotlin.Boolean%2C+kotlin.Int%29%2Fdelimiters&quot;&gt;定界符&lt;/a&gt;中的第一个元素，该元素在此位置处等于该定界符。</target>
        </trans-unit>
        <trans-unit id="8d7e3e92f18e00c4c45e963dd6305eb6cda4267d" translate="yes" xml:space="preserve">
          <source>To avoid ambiguous results when strings in &lt;a href=&quot;split#kotlin.text%24split(kotlin.CharSequence,%20kotlin.Array((kotlin.String)),%20kotlin.Boolean,%20kotlin.Int)/delimiters&quot;&gt;delimiters&lt;/a&gt; have characters in common, this method proceeds from the beginning to the end of this string, and matches at each position the first element in &lt;a href=&quot;split#kotlin.text%24split(kotlin.CharSequence,%20kotlin.Array((kotlin.String)),%20kotlin.Boolean,%20kotlin.Int)/delimiters&quot;&gt;delimiters&lt;/a&gt; that is equal to a delimiter in this instance at that position.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35cbc5daa3fa4744579892d02b514b4f1f8fe190" translate="yes" xml:space="preserve">
          <source>To avoid ambiguous results when strings in &lt;a href=&quot;split-to-sequence#kotlin.text%24splitToSequence%28kotlin.CharSequence%2C+kotlin.Array%28%28kotlin.String%29%29%2C+kotlin.Boolean%2C+kotlin.Int%29%2Fdelimiters&quot;&gt;delimiters&lt;/a&gt; have characters in common, this method proceeds from the beginning to the end of this string, and finds at each position the first element in &lt;a href=&quot;split-to-sequence#kotlin.text%24splitToSequence%28kotlin.CharSequence%2C+kotlin.Array%28%28kotlin.String%29%29%2C+kotlin.Boolean%2C+kotlin.Int%29%2Fdelimiters&quot;&gt;delimiters&lt;/a&gt; that matches this string at that position.</source>
          <target state="translated">为了避免在&lt;a href=&quot;split-to-sequence#kotlin.text%24splitToSequence%28kotlin.CharSequence%2C+kotlin.Array%28%28kotlin.String%29%29%2C+kotlin.Boolean%2C+kotlin.Int%29%2Fdelimiters&quot;&gt;定界符中的&lt;/a&gt;字符串具有共同字符时导致模棱两可的结果，此方法从该字符串的开头到结尾进行处理，并在每个位置处找到与该字符串匹配的&lt;a href=&quot;split-to-sequence#kotlin.text%24splitToSequence%28kotlin.CharSequence%2C+kotlin.Array%28%28kotlin.String%29%29%2C+kotlin.Boolean%2C+kotlin.Int%29%2Fdelimiters&quot;&gt;定界符&lt;/a&gt;中的第一个元素。</target>
        </trans-unit>
        <trans-unit id="3b1eaf906ec2e97627b57ad449d3e9fea0f52ed9" translate="yes" xml:space="preserve">
          <source>To avoid ambiguous results when strings in &lt;a href=&quot;split-to-sequence#kotlin.text%24splitToSequence(kotlin.CharSequence,%20kotlin.Array((kotlin.String)),%20kotlin.Boolean,%20kotlin.Int)/delimiters&quot;&gt;delimiters&lt;/a&gt; have characters in common, this method proceeds from the beginning to the end of this string, and finds at each position the first element in &lt;a href=&quot;split-to-sequence#kotlin.text%24splitToSequence(kotlin.CharSequence,%20kotlin.Array((kotlin.String)),%20kotlin.Boolean,%20kotlin.Int)/delimiters&quot;&gt;delimiters&lt;/a&gt; that matches this string at that position.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4098083aa9fa1edbe4454946791bd3716c2341fe" translate="yes" xml:space="preserve">
          <source>To avoid an exception being thrown, one can use a &lt;em&gt;safe&lt;/em&gt; cast operator &lt;em&gt;as?&lt;/em&gt; that returns &lt;em&gt;null&lt;/em&gt; on failure:</source>
          <target state="translated">为了避免引发异常，可以使用&lt;em&gt;安全的&lt;/em&gt;强制转换运算符&lt;em&gt;作为？&lt;/em&gt;失败时返回&lt;em&gt;null&lt;/em&gt;：</target>
        </trans-unit>
        <trans-unit id="ff225a55ea176600b1d470fbc58e6bb3a657f71a" translate="yes" xml:space="preserve">
          <source>To avoid breaking the compatibility with such clients, compile your Kotlin code in the &lt;em&gt;compatibility mode&lt;/em&gt; by specifying the &lt;code&gt;-Xjvm-default=all-compatibility&lt;/code&gt; compiler option. In this case, all the code that uses the previous version will work fine with the new one. However, the compatibility mode adds some overhead to the resulting bytecode size.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba3e151dfa9ea7385c197541ad779f6d353044b8" translate="yes" xml:space="preserve">
          <source>To avoid duplicate publications of modules that can be built on several platforms (like JVM, JS, Kotlin metadata), configure the publishing tasks for these modules to run conditionally.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e17e4153a46063a7e951557055076fb55b29173" translate="yes" xml:space="preserve">
          <source>To avoid exceptions when retrieving element with non-existing positions, use safe variations of &lt;code&gt;elementAt()&lt;/code&gt;:</source>
          <target state="translated">为了避免在检索位置不存在的元素时出现异常，请使用 &lt;code&gt;elementAt()&lt;/code&gt; 的安全变体：</target>
        </trans-unit>
        <trans-unit id="7274268313d792eeb0ea9bf91f3d9337f0c66bb3" translate="yes" xml:space="preserve">
          <source>To avoid unchecked casts, you can redesign the program structure: in the example above, there could be interfaces &lt;code&gt;DictionaryReader&amp;lt;T&amp;gt;&lt;/code&gt; and &lt;code&gt;DictionaryWriter&amp;lt;T&amp;gt;&lt;/code&gt; with type-safe implementations for different types. You can introduce reasonable abstractions to move unchecked casts from calling code to the implementation details. Proper use of &lt;a href=&quot;generics#variance&quot;&gt;generic variance&lt;/a&gt; can also help.</source>
          <target state="translated">为了避免无限制的强制转换，您可以重新设计程序结构：在上面的示例中，可能存在 &lt;code&gt;DictionaryReader&amp;lt;T&amp;gt;&lt;/code&gt; 和 &lt;code&gt;DictionaryWriter&amp;lt;T&amp;gt;&lt;/code&gt; 接口，它们具有针对不同类型的类型安全的实现。您可以引入合理的抽象，以将未经检查的强制转换从调用代码移至实现细节。正确使用&lt;a href=&quot;generics#variance&quot;&gt;通用方差&lt;/a&gt;也可以有所帮助。</target>
        </trans-unit>
        <trans-unit id="86fda07e220a1d9d0906bbd1a8bf6f784d8a05be" translate="yes" xml:space="preserve">
          <source>To be eligible for the &lt;code&gt;tailrec&lt;/code&gt; modifier, a function must call itself as the last operation it performs. You cannot use tail recursion when there is more code after the recursive call, and you cannot use it within try/catch/finally blocks. Currently tail recursion is only supported in the JVM backend.</source>
          <target state="translated">为了有资格使用 &lt;code&gt;tailrec&lt;/code&gt; 修饰符，函数必须将自身作为执行的最后一个操作进行调用。如果在递归调用之后有更多代码，则不能使用尾递归，也不能在try / catch / finally块中使用它。当前，仅JVM后端支持尾部递归。</target>
        </trans-unit>
        <trans-unit id="26086ae134fdfd5e001fb5980e8bca3370532b03" translate="yes" xml:space="preserve">
          <source>To be eligible for the &lt;code&gt;tailrec&lt;/code&gt; modifier, a function must call itself as the last operation it performs. You cannot use tail recursion when there is more code after the recursive call, and you cannot use it within try/catch/finally blocks. Currently, tail recursion is supported by Kotlin for JVM and Kotlin/Native.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e77c612cc0ad3329a96be3d4bc330a4270facd79" translate="yes" xml:space="preserve">
          <source>To be fair, you'd get the same output in Python, but the mechanism would be different: both instances would start out without any attributes of their own (&lt;code&gt;age&lt;/code&gt; and &lt;code&gt;name&lt;/code&gt; would be attributes on the class), and the first printing would access the class attribute; only the assignment would cause an &lt;code&gt;age&lt;/code&gt; attribute to appear on &lt;code&gt;a&lt;/code&gt;. In Kotlin, there are no class properties in this example, and each instance starts out with both properties. If you need a class-level property, see the section on &lt;a href=&quot;objects-and-companion-objects#companion-objects&quot;&gt;companion objects&lt;/a&gt;.</source>
          <target state="translated">公平地说，您将在Python中获得相同的输出，但是机制会有所不同：两个实例开始时都没有它们自己的任何属性（ &lt;code&gt;age&lt;/code&gt; 和 &lt;code&gt;name&lt;/code&gt; 将是类的属性），并且第一个打印将访问class属性；只有分配会导致 &lt;code&gt;age&lt;/code&gt; 属性出现在 &lt;code&gt;a&lt;/code&gt; 。在Kotlin中，此示例中没有类属性，并且每个实例都从这两个属性开始。如果您需要一个类级别的属性，请参见关于&lt;a href=&quot;objects-and-companion-objects#companion-objects&quot;&gt;伴随对象&lt;/a&gt;的部分。</target>
        </trans-unit>
        <trans-unit id="6d58ecb9e55a69412f4f07d4a983e7c9fa7ff4a8" translate="yes" xml:space="preserve">
          <source>To begin debugging, let's navigate to the page and launch the developer tools of our browser (for example by right-clicking and selecting the &lt;em&gt;Inspect&lt;/em&gt; action). If our program is logging information to the console, we can navigate to the &lt;em&gt;Console&lt;/em&gt; tab to see this output. Depending on our browser and its developer tools, these logs will also reference the Kotlin source files they originate from:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5cad0364e908d8aa1ff84ca1d9136f4ad0e8a7e" translate="yes" xml:space="preserve">
          <source>To break a collection onto parts of a given size, use the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/chunked&quot;&gt;&lt;code&gt;chunked()&lt;/code&gt;&lt;/a&gt; function. &lt;code&gt;chunked()&lt;/code&gt; takes a single argument &amp;ndash; the size of the chunk &amp;ndash; and returns a &lt;code&gt;List&lt;/code&gt; of &lt;code&gt;List&lt;/code&gt;s of the given size. The first chunk starts from the first element and contains the &lt;code&gt;size&lt;/code&gt; elements, the second chunk holds the next &lt;code&gt;size&lt;/code&gt; elements, and so on. The last chunk may have a smaller size.</source>
          <target state="translated">要将集合分解为给定大小的部分，请使用&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/chunked&quot;&gt; &lt;code&gt;chunked()&lt;/code&gt; &lt;/a&gt;函数。 &lt;code&gt;chunked()&lt;/code&gt; 接受一个参数&amp;ndash;块的大小&amp;ndash;并返回给定大小的 &lt;code&gt;List&lt;/code&gt; 的 &lt;code&gt;List&lt;/code&gt; 。第一个块从第一个元素开始，包含 &lt;code&gt;size&lt;/code&gt; 元素，第二个块包含下一个 &lt;code&gt;size&lt;/code&gt; 元素，依此类推。最后一块可以具有较小的尺寸。</target>
        </trans-unit>
        <trans-unit id="c901a4737d7c3f04fc344e06625faf76eec8e9d6" translate="yes" xml:space="preserve">
          <source>To build a custom string representation, you can specify its parameters in function arguments &lt;code&gt;separator&lt;/code&gt;, &lt;code&gt;prefix&lt;/code&gt;, and &lt;code&gt;postfix&lt;/code&gt;. The resulting string will start with the &lt;code&gt;prefix&lt;/code&gt; and end with the &lt;code&gt;postfix&lt;/code&gt;. The &lt;code&gt;separator&lt;/code&gt; will come after each element except the last.</source>
          <target state="translated">要构建自定义字符串表示形式，您可以在函数参数 &lt;code&gt;separator&lt;/code&gt; ， &lt;code&gt;prefix&lt;/code&gt; 和 &lt;code&gt;postfix&lt;/code&gt; 指定其参数。结果字符串将以 &lt;code&gt;prefix&lt;/code&gt; 开头，并以 &lt;code&gt;postfix&lt;/code&gt; 结尾。该 &lt;code&gt;separator&lt;/code&gt; 会除了最后的两个元素。</target>
        </trans-unit>
        <trans-unit id="2719279869fab416ee4cd752ab3460ef98055407" translate="yes" xml:space="preserve">
          <source>To build and run your application on an emulator:</source>
          <target state="translated">要在模拟器上构建和运行你的应用程序。</target>
        </trans-unit>
        <trans-unit id="7150222f1a1fb391342d63f455f2076e7800770e" translate="yes" xml:space="preserve">
          <source>To build two-element windows, there is a separate function - &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/zip-with-next&quot;&gt;&lt;code&gt;zipWithNext()&lt;/code&gt;&lt;/a&gt;. It creates pairs of adjacent elements of the receiver collection. Note that &lt;code&gt;zipWithNext()&lt;/code&gt; doesn't break the collection into pairs; it creates a &lt;code&gt;Pair&lt;/code&gt; for &lt;em&gt;each&lt;/em&gt; element except the last one, so its result on &lt;code&gt;[1, 2, 3, 4]&lt;/code&gt; is &lt;code&gt;[[1, 2], [2, 3], [3, 4]]&lt;/code&gt;, not &lt;code&gt;[[1, 2&lt;/code&gt;], &lt;code&gt;[3, 4]]&lt;/code&gt;. &lt;code&gt;zipWithNext()&lt;/code&gt; can be called with a transformation function as well; it should take two elements of the receiver collection as arguments.</source>
          <target state="translated">要构建两个元素的窗口，有一个单独的函数&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/zip-with-next&quot;&gt; &lt;code&gt;zipWithNext()&lt;/code&gt; &lt;/a&gt;。它创建接收器集合的成对相邻元素。请注意， &lt;code&gt;zipWithNext()&lt;/code&gt; 不会将集合分成几对；它为除最后一个元素之外的&lt;em&gt;每个&lt;/em&gt;元素创建一个 &lt;code&gt;Pair&lt;/code&gt; ，因此其在 &lt;code&gt;[1, 2, 3, 4]&lt;/code&gt; 为 &lt;code&gt;[[1, 2], [2, 3], [3, 4]]&lt;/code&gt; ，而不是 &lt;code&gt;[[1, 2&lt;/code&gt; ]， &lt;code&gt;[3, 4]]&lt;/code&gt; 。 &lt;code&gt;zipWithNext()&lt;/code&gt; 也可以通过转换函数来调用；它应该以接收者集合的两个元素作为参数。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="8c83a6b42d390ab9398eaec7a8e407e01581218b" translate="yes" xml:space="preserve">
          <source>To call &lt;code&gt;fold&lt;/code&gt;, we need to pass it an &lt;a href=&quot;#instantiating-a-function-type&quot;&gt;instance of the function type&lt;/a&gt; as an argument, and lambda expressions (&lt;a href=&quot;#lambda-expressions-and-anonymous-functions&quot;&gt;described in more detail below&lt;/a&gt;) are widely used for this purpose at higher-order function call sites:</source>
          <target state="translated">要调用 &lt;code&gt;fold&lt;/code&gt; ，我们需要&lt;a href=&quot;#instantiating-a-function-type&quot;&gt;将函数类型的&lt;/a&gt;一个实例作为参数传递给它，并且lambda表达式（&lt;a href=&quot;#lambda-expressions-and-anonymous-functions&quot;&gt;在下面进行更详细的描述&lt;/a&gt;）为此在高阶函数调用站点中广泛使用：</target>
        </trans-unit>
        <trans-unit id="6580f39324c16c3fdd14fd9204c4e7b2dbc24353" translate="yes" xml:space="preserve">
          <source>To call a generic function, specify the type arguments at the call site &lt;strong&gt;after&lt;/strong&gt; the name of the function:</source>
          <target state="translated">要调用通用函数，请在函数名称&lt;strong&gt;后&lt;/strong&gt;的调用站点上指定类型参数：</target>
        </trans-unit>
        <trans-unit id="567fc2cf862c0915604df53cff04863a317488f7" translate="yes" xml:space="preserve">
          <source>To catch an exception, use the &lt;em&gt;try&lt;/em&gt;-expression:</source>
          <target state="translated">要捕获异常，请使用&lt;em&gt;try&lt;/em&gt; -expression：</target>
        </trans-unit>
        <trans-unit id="f8d7572362421bb5d6d9129ee1f644a5743bf60f" translate="yes" xml:space="preserve">
          <source>To change the names of generated accessor methods for properties without explicitly implemented getters and setters, you can use &lt;code&gt;@get:JvmName&lt;/code&gt; and &lt;code&gt;@set:JvmName&lt;/code&gt;:</source>
          <target state="translated">要更改没有显式实现的getter和setter的属性的已生成访问器方法的名称，可以使用 &lt;code&gt;@get:JvmName&lt;/code&gt; 和 &lt;code&gt;@set:JvmName&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="56c5976217a59b38e176bfb7f018f237783d8246" translate="yes" xml:space="preserve">
          <source>To check that tests are executed properly, we can add a file &lt;code&gt;src/test/kotlin/AppTest.kt&lt;/code&gt; and fill it with this content:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5fbf41ce5d5e2bab70a3b18ea06244281f42ad35" translate="yes" xml:space="preserve">
          <source>To check that your code passes your own test click the &lt;strong&gt;Check&lt;/strong&gt; icon at the top of &lt;strong&gt;Task Description&lt;/strong&gt; panel. If your code and test are correct, you will see the &lt;strong&gt;&quot;Congratulations!&quot;&lt;/strong&gt; text:</source>
          <target state="translated">要检查您的代码是否通过了您自己的测试，请单击&amp;ldquo; &lt;strong&gt;任务描述&amp;rdquo;&lt;/strong&gt;面板顶部的&amp;ldquo; &lt;strong&gt;检查&amp;rdquo;&lt;/strong&gt;图标。如果您的代码和测试正确，您将看到&lt;strong&gt;&amp;ldquo;恭喜！&amp;rdquo; &lt;/strong&gt;文本：&lt;strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="beef2a5f5b84a735eaf6763f186616f2da608682" translate="yes" xml:space="preserve">
          <source>To check the presence of an element in a collection, use the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/contains&quot;&gt;&lt;code&gt;contains()&lt;/code&gt;&lt;/a&gt; function. It returns &lt;code&gt;true&lt;/code&gt; if there is a collection element that &lt;code&gt;equals()&lt;/code&gt; the function argument. You can call &lt;code&gt;contains()&lt;/code&gt; in the operator form with the &lt;code&gt;in&lt;/code&gt; keyword.</source>
          <target state="translated">要检查集合中某个元素的存在，请使用&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/contains&quot;&gt; &lt;code&gt;contains()&lt;/code&gt; &lt;/a&gt;函数。如果存在 &lt;code&gt;equals()&lt;/code&gt; 函数参数的collection元素，则返回 &lt;code&gt;true&lt;/code&gt; 。您可以使用 &lt;code&gt;in&lt;/code&gt; 关键字以运算符形式调用 &lt;code&gt;contains()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bacf79d368ab6b699d2fdae207996c835a00695c" translate="yes" xml:space="preserve">
          <source>To check the presence of multiple instances together at once, call &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/contains-all&quot;&gt;&lt;code&gt;containsAll()&lt;/code&gt;&lt;/a&gt; with a collection of these instances as an argument.</source>
          <target state="translated">要一次检查多个实例的存在，请调用&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/contains-all&quot;&gt; &lt;code&gt;containsAll()&lt;/code&gt; &lt;/a&gt;并将这些实例的集合作为参数。</target>
        </trans-unit>
        <trans-unit id="bf01294073385c1601c163965354f1918a41a878" translate="yes" xml:space="preserve">
          <source>To check the stability status of different components of Kotlin (Kotlin/JVM, JS, Native, various libraries, etc), please consult &lt;a href=&quot;components-stability&quot;&gt;this link&lt;/a&gt;.</source>
          <target state="translated">要检查Kotlin的不同组件（Kotlin / JVM，JS，Native，各种库等）的稳定性状态，请查阅&lt;a href=&quot;components-stability&quot;&gt;此链接&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ff347228167cf9fc3db7b8ec20d8d867ef76b338" translate="yes" xml:space="preserve">
          <source>To check whether a &lt;code&gt;lateinit var&lt;/code&gt; has already been initialized, use &lt;code&gt;.isInitialized&lt;/code&gt; on the &lt;a href=&quot;reflection#property-references&quot;&gt;reference to that property&lt;/a&gt;:</source>
          <target state="translated">要检查 &lt;code&gt;lateinit var&lt;/code&gt; 是否已经初始化， &lt;code&gt;.isInitialized&lt;/code&gt; 在&lt;a href=&quot;reflection#property-references&quot;&gt;对该属性&lt;/a&gt;的引用上使用.isInitialized：</target>
        </trans-unit>
        <trans-unit id="a142fb50381952ec419c46ff01c1249b5d802db1" translate="yes" xml:space="preserve">
          <source>To choose between the different Kotlin/JS compiler options, set the key &lt;code&gt;kotlin.js.compiler&lt;/code&gt; in your &lt;code&gt;gradle.properties&lt;/code&gt; to &lt;code&gt;legacy&lt;/code&gt;, &lt;code&gt;ir&lt;/code&gt;, or &lt;code&gt;both&lt;/code&gt;. Alternatively, pass &lt;code&gt;LEGACY&lt;/code&gt;, &lt;code&gt;IR&lt;/code&gt;, or &lt;code&gt;BOTH&lt;/code&gt; to the &lt;code&gt;js&lt;/code&gt; function in your &lt;code&gt;build.gradle(.kts)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06e9d17e9ea9b86a000058cf4db743b9a4f8896c" translate="yes" xml:space="preserve">
          <source>To clearly separate the class header and body when the class header is long, either put a blank line following the class header (as in the example above), or put the opening curly brace on a separate line:</source>
          <target state="translated">当类头较长时,要清楚地将类头和正文分开,可以在类头后面空一行(如上面的例子),或者将开头的大括号另起一行。</target>
        </trans-unit>
        <trans-unit id="3e043d9080f48d9f8a9db312581f08dbc6b9e5fd" translate="yes" xml:space="preserve">
          <source>To collect all source sets participating in a compilation, including those added via the depends-on relation, one can use the property &lt;code&gt;allKotlinSourceSets&lt;/code&gt;.</source>
          <target state="translated">要收集所有参与编译的源集，包括通过依赖关系添加的源集，可以使用属性 &lt;code&gt;allKotlinSourceSets&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="803e7c1c7144d14a645ff4c12ca8fcfcbdd5adbe" translate="yes" xml:space="preserve">
          <source>To compile mixed code applications Kotlin compiler should be invoked before Java compiler. In maven terms that means kotlin-maven-plugin should be run before maven-compiler-plugin using the following method, making sure that the kotlin plugin is above the maven-compiler-plugin in your pom.xml file:</source>
          <target state="translated">为了编译混合代码的应用程序,Kotlin编译器应该在Java编译器之前被调用,在maven术语中,这意味着kotlin-maven-plugin应该在maven-compiler-plugin之前运行,使用以下方法确保kotlin插件在maven-compiler-plugin之上。在maven中,这意味着kotlin-maven-plugin应该在maven-compiler-plugin之前运行,使用以下方法,确保kotlin插件在pom.xml文件中的maven-compiler-plugin之上。</target>
        </trans-unit>
        <trans-unit id="db544e0e7056b8ab96d6dfe0f4c1cf8c1335597b" translate="yes" xml:space="preserve">
          <source>To compile mixed code applications Kotlin compiler should be invoked before Java compiler. In maven terms that means that &lt;code&gt;kotlin-maven-plugin&lt;/code&gt; should run before &lt;code&gt;maven-compiler-plugin&lt;/code&gt; using the following method. Make sure that the &lt;code&gt;kotlin&lt;/code&gt; plugin comes before the &lt;code&gt;maven-compiler-plugin&lt;/code&gt; in your &lt;code&gt;pom.xml&lt;/code&gt; file:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72988880fd1eb858d05ee3ce13bbc13e7e1bb020" translate="yes" xml:space="preserve">
          <source>To compile source code, specify the source directories in the</source>
          <target state="translated">要编译源码,请在</target>
        </trans-unit>
        <trans-unit id="05e8b41e40400d680ccd1fc7712decc5274ce096" translate="yes" xml:space="preserve">
          <source>To compile the application use the &lt;a href=&quot;https://github.com/JetBrains/kotlin/releases/tag/v1.4.10&quot;&gt;downloaded&lt;/a&gt; compiler to execute the following command:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4127356a573ae0646e7fc7abacf9ec61a4c1bfd" translate="yes" xml:space="preserve">
          <source>To compile your module in the explicit API mode, add the following lines to your Gradle build script:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37fdd621985c6aff13221b4e4aea16cc07ab8ee0" translate="yes" xml:space="preserve">
          <source>To configure DCE on the main source set, you can use the &lt;code&gt;runDceKotlinJs&lt;/code&gt; task (and corresponding &lt;code&gt;runDce&amp;lt;sourceSetName&amp;gt;KotlinJs&lt;/code&gt; for other source sets).</source>
          <target state="translated">要在主要源集上配置DCE，可以使用 &lt;code&gt;runDceKotlinJs&lt;/code&gt; 任务（对于其他源集，则使用相应的 &lt;code&gt;runDce&amp;lt;sourceSetName&amp;gt;KotlinJs&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="0fbb0879e62b32ffc14d1dc5aabab44fdf51b7ee" translate="yes" xml:space="preserve">
          <source>To configure a single task, use its name. Examples:</source>
          <target state="translated">要配置单个任务,请使用其名称。例子。</target>
        </trans-unit>
        <trans-unit id="31f760752d420596279600b4f50a8da617cd79a7" translate="yes" xml:space="preserve">
          <source>To configure additional Yarn features, place a &lt;code&gt;.yarnrc&lt;/code&gt; file in the root of your project. At build time, it gets picked up automatically.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75b4ad80b6e5b98a0167e62ef51d7159288b8634" translate="yes" xml:space="preserve">
          <source>To configure the IntelliJ formatter according to this style guide, please install Kotlin plugin version 1.2.20 or newer, go to &lt;strong&gt;Settings | Editor | Code Style | Kotlin&lt;/strong&gt;, click &lt;strong&gt;Set from&amp;hellip;&lt;/strong&gt; link in the upper right corner, and select &lt;strong&gt;Kotlin style guide&lt;/strong&gt; from the menu.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68df6e8c753963392486043995598199a7116aa3" translate="yes" xml:space="preserve">
          <source>To configure the IntelliJ formatter according to this style guide, please install Kotlin plugin version 1.2.20 or newer, go to Settings | Editor | Code Style | Kotlin, click on &quot;Set from&amp;hellip;&quot; link in the upper right corner, and select &quot;Predefined style / Kotlin style guide&quot; from the menu.</source>
          <target state="translated">要根据此样式指南配置IntelliJ格式化程序，请安装Kotlin插件版本1.2.20或更高版本，请转至&amp;ldquo;设置&amp;rdquo; |&amp;ldquo;设置&amp;rdquo;。编辑器代码样式| Kotlin，单击右上角的&amp;ldquo;从...设置&amp;rdquo;链接，然后从菜单中选择&amp;ldquo;预定义样式/ Kotlin样式指南&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="2c9d3b301661c08e8259cc3ab20ba4dbad19be49" translate="yes" xml:space="preserve">
          <source>To construct a duration use either the extension function &lt;a href=&quot;../to-duration&quot;&gt;toDuration&lt;/a&gt;, or the extension properties &lt;a href=&quot;../hours&quot;&gt;hours&lt;/a&gt;, &lt;a href=&quot;../minutes&quot;&gt;minutes&lt;/a&gt;, &lt;a href=&quot;../seconds&quot;&gt;seconds&lt;/a&gt;, and so on, available on &lt;a href=&quot;../../kotlin/-int/index#kotlin.Int&quot;&gt;Int&lt;/a&gt;, &lt;a href=&quot;../../kotlin/-long/index#kotlin.Long&quot;&gt;Long&lt;/a&gt;, and &lt;a href=&quot;../../kotlin/-double/index#kotlin.Double&quot;&gt;Double&lt;/a&gt; numeric types.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a84aa42a71bde94030fd28b49274ed212410ae73" translate="yes" xml:space="preserve">
          <source>To convert a Kotlin function to a pointer to a C function, &lt;code&gt;staticCFunction(::kotlinFunction)&lt;/code&gt; can be used. It is also able to provide the lambda instead of a function reference. The function or lambda must not capture any values.</source>
          <target state="translated">要将Kotlin函数转换为指向C函数的指针，可以使用 &lt;code&gt;staticCFunction(::kotlinFunction)&lt;/code&gt; 。它还能够提供lambda而不是函数引用。函数或lambda不得捕获任何值。</target>
        </trans-unit>
        <trans-unit id="3c44f554793ee378fe115edb9d2b77ef0a09d12f" translate="yes" xml:space="preserve">
          <source>To convert a file we simply provide the input file, and optionally an output directory. The command below will convert the file &lt;code&gt;jquery.d.ts&lt;/code&gt; in the current folder, which we've previously downloaded from the &lt;a href=&quot;https://github.com/DefinitelyTyped/DefinitelyTyped/blob/types/jquery/jquery.d.ts&quot;&gt;Definitely Typed repository&lt;/a&gt; to the output folder &lt;code&gt;headers&lt;/code&gt;:</source>
          <target state="translated">要转换文件，我们只需提供输入文件，还可以提供输出目录。下面的命令将转换文件 &lt;code&gt;jquery.d.ts&lt;/code&gt; 在当前文件夹，我们以前从下载的&lt;a href=&quot;https://github.com/DefinitelyTyped/DefinitelyTyped/blob/types/jquery/jquery.d.ts&quot;&gt;绝对键入的仓库&lt;/a&gt;到输出文件夹 &lt;code&gt;headers&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="969568decea2cdc2afa64668f60c6158428db0dd" translate="yes" xml:space="preserve">
          <source>To convert floating-point numbers to &lt;code&gt;Byte&lt;/code&gt; or &lt;code&gt;Short&lt;/code&gt;, use the two-step conversion: first, convert them to &lt;code&gt;Int&lt;/code&gt;, and then convert them again to the target type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53082c51d066700fb796c416707ace90c10e7442" translate="yes" xml:space="preserve">
          <source>To convert numeric values to different types, use &lt;a href=&quot;#explicit-conversions&quot;&gt;Explicit conversions&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09283e6df610a2666a552ab05ba081120d5fb799" translate="yes" xml:space="preserve">
          <source>To correctly import the dependencies into the Kotlin/Native module, the &lt;code&gt;Podfile&lt;/code&gt; must contain either &lt;a href=&quot;https://guides.cocoapods.org/syntax/podfile.html#use_modular_headers_bang&quot;&gt;&lt;code&gt;use_modular_headers!&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://guides.cocoapods.org/syntax/podfile.html#use_frameworks_bang&quot;&gt;&lt;code&gt;use_frameworks!&lt;/code&gt;&lt;/a&gt; directive.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="033c0e927137582a697794f54285b85aeb454fd5" translate="yes" xml:space="preserve">
          <source>To cover these (and other) cases, Kotlin supports &lt;em&gt;delegated properties&lt;/em&gt;:</source>
          <target state="translated">为了涵盖这些（和其他）情况，Kotlin支持&lt;em&gt;委托的属性&lt;/em&gt;：</target>
        </trans-unit>
        <trans-unit id="9d0229fd8c1088f563b4cf4e10d12c4379d2f726" translate="yes" xml:space="preserve">
          <source>To create a Kotlin scratch, click &lt;strong&gt;File | New | Scratch file&lt;/strong&gt; and select the &lt;strong&gt;Kotlin&lt;/strong&gt; type.</source>
          <target state="translated">要创建Kotlin临时&lt;strong&gt;文件&lt;/strong&gt;，请单击&lt;strong&gt;文件| &lt;/strong&gt;&lt;strong&gt;新增| &lt;/strong&gt;&lt;strong&gt;暂存文件，&lt;/strong&gt;然后选择&lt;strong&gt;Kotlin&lt;/strong&gt;类型。</target>
        </trans-unit>
        <trans-unit id="d2345a81dc6db58bf05fd03f469161c13a230da9" translate="yes" xml:space="preserve">
          <source>To create a Kotlin worksheet in a project directory, right-click the directory in the project tree and select &lt;strong&gt;New | Kotlin Worksheet&lt;/strong&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80ff78a98293894db61ee5daa488d414337b0f86" translate="yes" xml:space="preserve">
          <source>To create a Kotlin/JS project in IntelliJ IDEA, go to &lt;strong&gt;File | New | Project&lt;/strong&gt; and select &lt;strong&gt;Gradle | Kotlin/JS for browser&lt;/strong&gt; or &lt;strong&gt;Kotlin/JS for Node.js&lt;/strong&gt;. Be sure to clear the &lt;strong&gt;Java&lt;/strong&gt; checkbox. If you want to use the Kotlin DSL for Gradle, make sure to check the &lt;strong&gt;Kotlin DSL build script&lt;/strong&gt; option.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6469e95270452943ecc23557177165ada17e0d19" translate="yes" xml:space="preserve">
          <source>To create a collection with the same elements as an existing collection, you can use copying operations. Collection copying operations from the standard library create &lt;em&gt;shallow&lt;/em&gt; copy collections with references to the same elements. Thus, a change made to a collection element reflects in all its copies.</source>
          <target state="translated">要创建具有与现有集合相同的元素的集合，可以使用复制操作。标准库中的集合复制操作通过引用相同元素来创建&lt;em&gt;浅表&lt;/em&gt;复制集合。因此，对收集元素所做的更改会反映在其所有副本中。</target>
        </trans-unit>
        <trans-unit id="c93eeedd365f43d9e2553f0db590167b463ec502" translate="yes" xml:space="preserve">
          <source>To create a concrete type collection, such as an &lt;code&gt;ArrayList&lt;/code&gt; or &lt;code&gt;LinkedList&lt;/code&gt;, you can use the available constructors for these types. Similar constructors are available for implementations of &lt;code&gt;Set&lt;/code&gt; and &lt;code&gt;Map&lt;/code&gt;.</source>
          <target state="translated">要创建具体的类型集合，例如 &lt;code&gt;ArrayList&lt;/code&gt; 或 &lt;code&gt;LinkedList&lt;/code&gt; ，可以使用这些类型的可用构造函数。类似的构造函数可用于 &lt;code&gt;Set&lt;/code&gt; 和 &lt;code&gt;Map&lt;/code&gt; 的实现。</target>
        </trans-unit>
        <trans-unit id="10c83d8ce189917b93f0dd12f924ce0343c0f0cd" translate="yes" xml:space="preserve">
          <source>To create a course, go to &lt;strong&gt;Create New Course&lt;/strong&gt; from the &lt;strong&gt;Welcome Screen&lt;/strong&gt; or in the &lt;strong&gt;File Menu&lt;/strong&gt;, fill in the title, author and description:</source>
          <target state="translated">要创建课程，请从&amp;ldquo; &lt;strong&gt;欢迎屏幕&amp;rdquo;&lt;/strong&gt;进入&amp;ldquo; &lt;strong&gt;创建新课程&amp;rdquo;&lt;/strong&gt;，或在&amp;ldquo; &lt;strong&gt;文件&amp;rdquo;菜单中&lt;/strong&gt;，填写标题，作者和说明：&lt;strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b19b96489e64fb428b07b0d9e5f6b20ffaee0c76" translate="yes" xml:space="preserve">
          <source>To create a finite sequence with &lt;code&gt;generateSequence()&lt;/code&gt;, provide a function that returns &lt;code&gt;null&lt;/code&gt; after the last element you need.</source>
          <target state="translated">要使用 &lt;code&gt;generateSequence()&lt;/code&gt; 创建有限序列，请提供一个函数，该函数在需要的最后一个元素之后返回 &lt;code&gt;null&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="47b61d43a27903512a35c90e596534948c2b1dbf" translate="yes" xml:space="preserve">
          <source>To create a progression for iterating in reverse order, use &lt;code&gt;downTo&lt;/code&gt; instead of &lt;code&gt;..&lt;/code&gt; when defining the range for it.</source>
          <target state="translated">要创建以相反顺序进行迭代的进度，请在定义其范围时使用 &lt;code&gt;downTo&lt;/code&gt; 而不是 &lt;code&gt;..&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b47410847599f97a1134fa9ef445378b7a480550" translate="yes" xml:space="preserve">
          <source>To create a range for your class, call the &lt;code&gt;rangeTo()&lt;/code&gt; function on the range start value and provide the end value as an argument. &lt;code&gt;rangeTo()&lt;/code&gt; is often called in its operator form &lt;code&gt;..&lt;/code&gt;.</source>
          <target state="translated">要为您的类创建一个范围，请在范围起始值上调用 &lt;code&gt;rangeTo()&lt;/code&gt; 函数，并提供结束值作为参数。 &lt;code&gt;rangeTo()&lt;/code&gt; 通常被称为在其操作形式 &lt;code&gt;..&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ef350d13303167462d244e7352097ce6871c0d66" translate="yes" xml:space="preserve">
          <source>To create a self-contained Jar file containing the code from your module along with dependencies, include the following under &lt;code&gt;build-&amp;gt;plugins&lt;/code&gt; in your Maven pom.xml file, where &lt;code&gt;main.class&lt;/code&gt; is defined as a property and points to the main Kotlin or Java class:</source>
          <target state="translated">要创建包含模块代码和依赖项的自包含Jar文件，请在Maven pom.xml文件的 &lt;code&gt;build-&amp;gt;plugins&lt;/code&gt; 下包含以下内容，其中 &lt;code&gt;main.class&lt;/code&gt; 定义为属性，并指向主Kotlin或Java类：</target>
        </trans-unit>
        <trans-unit id="250688e8e0fbdc724cfa4d689a087f5e676490f2" translate="yes" xml:space="preserve">
          <source>To create a sequence, call the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.sequences/sequence-of&quot;&gt;&lt;code&gt;sequenceOf()&lt;/code&gt;&lt;/a&gt; function listing the elements as its arguments.</source>
          <target state="translated">要创建序列，请调用&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.sequences/sequence-of&quot;&gt; &lt;code&gt;sequenceOf()&lt;/code&gt; &lt;/a&gt;函数，将元素列为参数。</target>
        </trans-unit>
        <trans-unit id="ab5e0caabe6ba677095c9c30bc71be0a60a8ea76" translate="yes" xml:space="preserve">
          <source>To create a small Jar file containing just the code from your module, include the following under &lt;code&gt;build-&amp;gt;plugins&lt;/code&gt; in your Maven pom.xml file, where &lt;code&gt;main.class&lt;/code&gt; is defined as a property and points to the main Kotlin or Java class:</source>
          <target state="translated">要创建一个仅包含模块代码的Jar文件，请在Maven pom.xml文件的 &lt;code&gt;build-&amp;gt;plugins&lt;/code&gt; 下包含以下内容，其中 &lt;code&gt;main.class&lt;/code&gt; 定义为属性，并指向Kotlin或Java主类：</target>
        </trans-unit>
        <trans-unit id="e35af751d291871272ac5bf8d4ceb5925a4c895b" translate="yes" xml:space="preserve">
          <source>To create a target, use one of the preset functions, which are named according to the target platforms and optionally accept the target name and a configuring code block:</source>
          <target state="translated">要创建一个目标,请使用其中一个预设函数,该函数根据目标平台命名,并可选择接受目标名称和配置代码块。</target>
        </trans-unit>
        <trans-unit id="59c179a1054538f29e6f5790e866a02248610385" translate="yes" xml:space="preserve">
          <source>To create an array, we can use a library function &lt;code&gt;arrayOf()&lt;/code&gt; and pass the item values to it, so that &lt;code&gt;arrayOf(1, 2, 3)&lt;/code&gt; creates an array &lt;code&gt;[1, 2, 3]&lt;/code&gt;. Alternatively, the &lt;code&gt;arrayOfNulls()&lt;/code&gt; library function can be used to create an array of a given size filled with null elements.</source>
          <target state="translated">要创建一个数组，我们可以使用库函数 &lt;code&gt;arrayOf()&lt;/code&gt; 并将项目值传递给它，以便 &lt;code&gt;arrayOf(1, 2, 3)&lt;/code&gt; 创建一个数组 &lt;code&gt;[1, 2, 3]&lt;/code&gt; 。或者，可以使用 &lt;code&gt;arrayOfNulls()&lt;/code&gt; 库函数来创建给定大小的数组，该数组填充有null元素。</target>
        </trans-unit>
        <trans-unit id="9cc39e6db177eed985da184429e7d653e4d3e03b" translate="yes" xml:space="preserve">
          <source>To create an instance of &lt;a href=&quot;index&quot;&gt;Lazy&lt;/a&gt; use the &lt;a href=&quot;../lazy#kotlin%24lazy%28kotlin.Function0%28%28kotlin.lazy.T%29%29%29&quot;&gt;lazy&lt;/a&gt; function.</source>
          <target state="translated">要创建&lt;a href=&quot;index&quot;&gt;Lazy&lt;/a&gt;实例，请使用&lt;a href=&quot;../lazy#kotlin%24lazy%28kotlin.Function0%28%28kotlin.lazy.T%29%29%29&quot;&gt;lazy&lt;/a&gt;函数。</target>
        </trans-unit>
        <trans-unit id="f9b7dfa76d5d4f8a207e73e37c8aed978cc5e50d" translate="yes" xml:space="preserve">
          <source>To create an instance of &lt;a href=&quot;index&quot;&gt;Lazy&lt;/a&gt; use the &lt;a href=&quot;../lazy#kotlin%24lazy(kotlin.Function0((kotlin.lazy.T)))&quot;&gt;lazy&lt;/a&gt; function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="392ca62c20eb8ea21287252327b80e948e15e7f9" translate="yes" xml:space="preserve">
          <source>To create an instance of a class, we call the constructor as if it were a regular function:</source>
          <target state="translated">为了创建一个类的实例,我们像调用一个普通函数一样调用构造函数。</target>
        </trans-unit>
        <trans-unit id="5ececdd9ea1ec767cefb32bd8a4972a7f3db2e63" translate="yes" xml:space="preserve">
          <source>To create an object of an anonymous class that inherits from some type (or types), we write:</source>
          <target state="translated">要创建一个继承自某个类型(或多个类型)的匿名类的对象,我们写。</target>
        </trans-unit>
        <trans-unit id="66ccf1c80c7d0872003cb95567afdbb598a15cac" translate="yes" xml:space="preserve">
          <source>To create bindings for a new library, start by creating a &lt;code&gt;.def&lt;/code&gt; file. Structurally it's a simple property file, which looks like this:</source>
          <target state="translated">要为新库创建绑定， &lt;code&gt;.def&lt;/code&gt; 创建一个.def文件。从结构上讲，这是一个简单的属性文件，如下所示：</target>
        </trans-unit>
        <trans-unit id="53cb83a01be7750f4f13800e35fa2fb65a7ce331" translate="yes" xml:space="preserve">
          <source>To create or access several targets from multiple presets dynamically, you can use the &lt;code&gt;targetFromPreset&lt;/code&gt; function which accepts a preset (those are contained in the &lt;code&gt;kotlin.presets&lt;/code&gt; domain object collection) and, optionally, a target name and a configuration code block.</source>
          <target state="translated">要动态地从多个预设中创建或访问多个目标，可以使用 &lt;code&gt;targetFromPreset&lt;/code&gt; 函数，该函数接受一个预设（这些都包含在 &lt;code&gt;kotlin.presets&lt;/code&gt; 域对象集合中），以及（可选）一个目标名称和一个配置代码块。</target>
        </trans-unit>
        <trans-unit id="84204f67cf463ce0040ab94f394e112f27f7a64e" translate="yes" xml:space="preserve">
          <source>To create such channel use a factory method &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/ticker.html&quot;&gt;ticker&lt;/a&gt;. To indicate that no further elements are needed use &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/-receive-channel/cancel.html&quot;&gt;ReceiveChannel.cancel&lt;/a&gt; method on it.</source>
          <target state="translated">要创建这样的通道，请使用工厂方法&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/ticker.html&quot;&gt;代码&lt;/a&gt;。要表明不需要其他元素，请在其上使用&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/-receive-channel/cancel.html&quot;&gt;ReceiveChannel.cancel&lt;/a&gt;方法。</target>
        </trans-unit>
        <trans-unit id="7ca6e4021fa1f14db902d32b5e28e873b56dfed4" translate="yes" xml:space="preserve">
          <source>To create the hierarchical structure manually, introduce an intermediate source set that holds the shared code for several targets and create a structure of the source sets including the intermediate one.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f270c63c035ac76bc90800e7489ec199d1188bb4" translate="yes" xml:space="preserve">
          <source>To create the new file, the &lt;a href=&quot;create-temp-dir#kotlin.io%24createTempDir(kotlin.String,%20kotlin.String?,%20java.io.File?)/prefix&quot;&gt;prefix&lt;/a&gt; and the &lt;a href=&quot;create-temp-dir#kotlin.io%24createTempDir(kotlin.String,%20kotlin.String?,%20java.io.File?)/suffix&quot;&gt;suffix&lt;/a&gt; may first be adjusted to fit the limitations of the underlying platform.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed397e5c4869250a6fe4256b7633ea9b132cd1a7" translate="yes" xml:space="preserve">
          <source>To create the new file, the &lt;a href=&quot;create-temp-file#kotlin.io%24createTempFile(kotlin.String,%20kotlin.String?,%20java.io.File?)/prefix&quot;&gt;prefix&lt;/a&gt; and the &lt;a href=&quot;create-temp-file#kotlin.io%24createTempFile(kotlin.String,%20kotlin.String?,%20java.io.File?)/suffix&quot;&gt;suffix&lt;/a&gt; may first be adjusted to fit the limitations of the underlying platform.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e26d13b3d6d463e1b2fd03afc335d058a5d4673" translate="yes" xml:space="preserve">
          <source>To debug Kotlin in Google Chrome, you should use DevTools. Please, read the &lt;a href=&quot;https://developer.chrome.com/devtools&quot;&gt;official documentation&lt;/a&gt; to learn how to open and use DevTools.</source>
          <target state="translated">要在Google Chrome浏览器中调试Kotlin，应使用DevTools。请阅读&lt;a href=&quot;https://developer.chrome.com/devtools&quot;&gt;官方文档&lt;/a&gt;以了解如何打开和使用DevTools。</target>
        </trans-unit>
        <trans-unit id="e817cf98143421063f9dd49cbdf248b7b2518117" translate="yes" xml:space="preserve">
          <source>To debug Kotlin sources in the browser, you should tell the compiler to generate source map file. Add following lines to the Gradle configuration:</source>
          <target state="translated">要在浏览器中调试Kotlin源码,你应该告诉编译器生成源码映射文件。在Gradle配置中添加以下几行。</target>
        </trans-unit>
        <trans-unit id="f1c61d767cd604eae6780df09aa030d9d280b98c" translate="yes" xml:space="preserve">
          <source>To declare a function that is implemented in native (C or C++) code, you need to mark it with the &lt;code&gt;external&lt;/code&gt; modifier:</source>
          <target state="translated">要声明以本机（C或C ++）代码实现的功能，您需要使用 &lt;code&gt;external&lt;/code&gt; 修饰符对其进行标记：</target>
        </trans-unit>
        <trans-unit id="79e836524d01f43d3f368b1ec21e6a64cf0c9af7" translate="yes" xml:space="preserve">
          <source>To declare a functional interface in Kotlin, use the &lt;code&gt;fun&lt;/code&gt; modifier.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17984c774c9009532146abdfe4c1f92691dab870" translate="yes" xml:space="preserve">
          <source>To declare a sealed class, you put the &lt;code&gt;sealed&lt;/code&gt; modifier before the name of the class. A sealed class can have subclasses, but all of them must be declared in the same file as the sealed class itself. (Before Kotlin 1.1, the rules were even more strict: classes had to be nested inside the declaration of the sealed class).</source>
          <target state="translated">要声明一个密封的类，可以将 &lt;code&gt;sealed&lt;/code&gt; 修饰符放在该类的名称之前。密封类可以具有子类，但是所有子类必须与密封类本身在同一文件中声明。（在Kotlin 1.1之前，规则更加严格：类必须嵌套在密封类的声明中）。</target>
        </trans-unit>
        <trans-unit id="10a7f058c3df1eb894a755ea535860aa75893fea" translate="yes" xml:space="preserve">
          <source>To declare an explicit supertype, place the type after a colon in the class header:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c97ee402b691c80817117f378bd0349e4a8da26c" translate="yes" xml:space="preserve">
          <source>To declare an explicit supertype, we place the type after a colon in the class header:</source>
          <target state="translated">要声明一个显式的超类型,我们把类型放在类头的冒号后面。</target>
        </trans-unit>
        <trans-unit id="48ff93d55fe3658449347e35151be6b572c8736d" translate="yes" xml:space="preserve">
          <source>To declare an extension function, we need to prefix its name with a &lt;em&gt;receiver type&lt;/em&gt;, i.e. the type being extended. The following adds a &lt;code&gt;swap&lt;/code&gt; function to &lt;code&gt;MutableList&amp;lt;Int&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">要声明扩展功能，我们需要在其名称之前添加一个&lt;em&gt;接收器类型&lt;/em&gt;，即正在扩展的类型。以下将 &lt;code&gt;swap&lt;/code&gt; 函数添加到 &lt;code&gt;MutableList&amp;lt;Int&amp;gt;&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="a2675b642241372403d53ead59c356a1d8d22f48" translate="yes" xml:space="preserve">
          <source>To declare an npm dependency, pass its name and version to the &lt;code&gt;npm()&lt;/code&gt; function inside a dependency declaration. You can also specify one or multiple version range based on &lt;a href=&quot;https://docs.npmjs.com/misc/semver#versions&quot;&gt;npm's semver syntax&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e983a5d628747c6e88e300a187da5fef2223334" translate="yes" xml:space="preserve">
          <source>To declare final native binaries such as executables or shared libraries, use the &lt;code&gt;binaries&lt;/code&gt; property of a native target. This property represents a collection of native binaries built for this target in addition to the default &lt;code&gt;*.klib&lt;/code&gt; artifact and provides a set of methods for declaring and configuring them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1b32c095491287535a8ffbd23d718a4ec1e28de" translate="yes" xml:space="preserve">
          <source>To define a custom order for the collection sorting, you can provide your own &lt;code&gt;Comparator&lt;/code&gt;. To do this, call the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/sorted-with&quot;&gt;&lt;code&gt;sortedWith()&lt;/code&gt;&lt;/a&gt; function passing in your &lt;code&gt;Comparator&lt;/code&gt;. With this function, sorting strings by their length looks like this:</source>
          <target state="translated">要为集合排序定义自定义顺序，您可以提供自己的 &lt;code&gt;Comparator&lt;/code&gt; 。为此，请调用传入 &lt;code&gt;Comparator&lt;/code&gt; 的&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/sorted-with&quot;&gt; &lt;code&gt;sortedWith()&lt;/code&gt; &lt;/a&gt;函数。使用此功能，按字符串长度排序如下所示：</target>
        </trans-unit>
        <trans-unit id="76c4ad66d01d81d2c13dd0f6fd9cbde76bdd69dd" translate="yes" xml:space="preserve">
          <source>To define a custom progression step, use the &lt;code&gt;step&lt;/code&gt; function on a range.</source>
          <target state="translated">要定义自定义进度步骤，请在范围上使用 &lt;code&gt;step&lt;/code&gt; 功能。</target>
        </trans-unit>
        <trans-unit id="e3c595e055a9ae116f425f8291258d8dc6632df5" translate="yes" xml:space="preserve">
          <source>To define a natural order for a user-defined type, make the type an inheritor of &lt;code&gt;Comparable&lt;/code&gt;. This requires implementing the &lt;code&gt;compareTo()&lt;/code&gt; function. &lt;code&gt;compareTo()&lt;/code&gt; must take another object of the same type as an argument and return an integer value showing which object is greater:</source>
          <target state="translated">要为用户定义的类型定义自然顺序，请使该类型成为 &lt;code&gt;Comparable&lt;/code&gt; 的继承者。这需要实现 &lt;code&gt;compareTo()&lt;/code&gt; 函数。 &lt;code&gt;compareTo()&lt;/code&gt; 必须将另一个具有相同类型的对象作为参数，并返回一个整数值，显示哪个对象更大：</target>
        </trans-unit>
        <trans-unit id="97b3e94e6c163378ef995af60afef80476f27107" translate="yes" xml:space="preserve">
          <source>To define the target execution environment for a Kotlin/JS project, add the &lt;code&gt;js&lt;/code&gt; section with &lt;code&gt;browser {}&lt;/code&gt; or &lt;code&gt;nodejs {}&lt;/code&gt; inside.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15f6c4e9b412ce540337bf0f4670d3a11f889be0" translate="yes" xml:space="preserve">
          <source>To delegate a property to another property, use the proper &lt;code&gt;::&lt;/code&gt; qualifier in the delegate name, for example, &lt;code&gt;this::delegate&lt;/code&gt; or &lt;code&gt;MyClass::delegate&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9143cabd73a5291d802c769a81ee627bbb5733e" translate="yes" xml:space="preserve">
          <source>To denote the current &lt;em&gt;receiver&lt;/em&gt;, we use &lt;em&gt;this&lt;/em&gt; expressions:</source>
          <target state="translated">为了表示当前&lt;em&gt;接收者&lt;/em&gt;，我们使用&lt;em&gt;以下&lt;/em&gt;表达式：</target>
        </trans-unit>
        <trans-unit id="370aeed576ab8358f729a92b8f556723486b4edb" translate="yes" xml:space="preserve">
          <source>To deploy Kotlin applications on &lt;a href=&quot;https://www.heroku.com&quot;&gt;Heroku&lt;/a&gt;, you can follow the &lt;a href=&quot;https://devcenter.heroku.com/articles/getting-started-with-kotlin&quot;&gt;official Heroku tutorial&lt;/a&gt;.</source>
          <target state="translated">要在&lt;a href=&quot;https://www.heroku.com&quot;&gt;Heroku&lt;/a&gt;上部署Kotlin应用程序，您可以按照&lt;a href=&quot;https://devcenter.heroku.com/articles/getting-started-with-kotlin&quot;&gt;Heroku官方教程进行操作&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="df65bd88e8b911bd297cf79b50116d47f9582b7f" translate="yes" xml:space="preserve">
          <source>To deserialize an object from JSON, use the &lt;code&gt;decodeFromString()&lt;/code&gt; function:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9515ab87992626329f3209451ad10d94d57d9d91" translate="yes" xml:space="preserve">
          <source>To disable</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="771653f64e2b72ee994da136292e2bfcc37a8770" translate="yes" xml:space="preserve">
          <source>To disable the caching for all Kotlin tasks, set the system property flag &lt;code&gt;kotlin.caching.enabled&lt;/code&gt; to &lt;code&gt;false&lt;/code&gt; (run the build with the argument &lt;code&gt;-Dkotlin.caching.enabled=false&lt;/code&gt;).</source>
          <target state="translated">要禁用所有Kotlin任务的缓存，请将系统属性标志 &lt;code&gt;kotlin.caching.enabled&lt;/code&gt; 设置为 &lt;code&gt;false&lt;/code&gt; （使用参数 &lt;code&gt;-Dkotlin.caching.enabled=false&lt;/code&gt; 运行构建）。</target>
        </trans-unit>
        <trans-unit id="c87cd2c2540cd75daead1d75a0422fd2e77c8c87" translate="yes" xml:space="preserve">
          <source>To download and install your declared dependencies during build time, the plugin manages its own installation of the &lt;a href=&quot;https://yarnpkg.com/lang/en/&quot;&gt;Yarn&lt;/a&gt; package manager.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5fb61a8c9c6d11d2594861df1a6ec31dd25d8561" translate="yes" xml:space="preserve">
          <source>To eliminate the risk of such incompatibility being introduced by a change in &lt;strong&gt;non&lt;/strong&gt;-public API of a module, the public API inline functions are not allowed to use non-public-API declarations, i.e. &lt;code&gt;private&lt;/code&gt; and &lt;code&gt;internal&lt;/code&gt; declarations and their parts, in their bodies.</source>
          <target state="translated">为了消除由于模块的&lt;strong&gt;非&lt;/strong&gt;公共API的更改而引入这种不兼容性的风险，公共API内联函数不允许在其主体中使用非公共API声明，即 &lt;code&gt;private&lt;/code&gt; 和 &lt;code&gt;internal&lt;/code&gt; 声明及其部分。</target>
        </trans-unit>
        <trans-unit id="2defcf6d3a2e2a6242b791d65c0bc5e944e6db59" translate="yes" xml:space="preserve">
          <source>To enable Kotlin OSGi support you need to include &lt;code&gt;kotlin-osgi-bundle&lt;/code&gt; instead of regular Kotlin libraries. It is recommended to remove &lt;code&gt;kotlin-runtime&lt;/code&gt;, &lt;code&gt;kotlin-stdlib&lt;/code&gt; and &lt;code&gt;kotlin-reflect&lt;/code&gt; dependencies as &lt;code&gt;kotlin-osgi-bundle&lt;/code&gt; already contains all of them. You also should pay attention in case when external Kotlin libraries are included. Most regular Kotlin dependencies are not OSGi-ready, so you shouldn't use them and should remove them from your project.</source>
          <target state="translated">要启用Kotlin OSGi支持，您需要包括 &lt;code&gt;kotlin-osgi-bundle&lt;/code&gt; 而不是常规的Kotlin库。建议删除 &lt;code&gt;kotlin-runtime&lt;/code&gt; ， &lt;code&gt;kotlin-stdlib&lt;/code&gt; 和 &lt;code&gt;kotlin-reflect&lt;/code&gt; 依赖项，因为 &lt;code&gt;kotlin-osgi-bundle&lt;/code&gt; 已包含所有依赖项。如果还包括外部Kotlin库，您也应该注意。大多数常规Kotlin依赖项都不支持OSGi，因此您不应使用它们，而应将其从项目中删除。</target>
        </trans-unit>
        <trans-unit id="cfb7bf1512d4d94303eeac356cb8f8007e5c3e6b" translate="yes" xml:space="preserve">
          <source>To enable hierarchical project structure support, add the following to your &lt;code&gt;gradle.properties&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6eb3341f99fe9ebb8d9323c290933247870fe5f7" translate="yes" xml:space="preserve">
          <source>To enable incremental annotation processing, add this line to your &lt;code&gt;gradle.properties&lt;/code&gt; file:</source>
          <target state="translated">要启用增量注释处理，请将以下行添加到 &lt;code&gt;gradle.properties&lt;/code&gt; 文件中：</target>
        </trans-unit>
        <trans-unit id="884726c9e2c8978bb4071d284e17e9fc6968d458" translate="yes" xml:space="preserve">
          <source>To enable the Kotlin/JS IR backend, set the key &lt;code&gt;kotlin.js.compiler=ir&lt;/code&gt; in your &lt;code&gt;gradle.properties&lt;/code&gt;, or pass the &lt;code&gt;IR&lt;/code&gt; compiler type to the &lt;code&gt;js&lt;/code&gt; function of your Gradle build script:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fcb5bed9cc9f628e32c3756f1cd602e0e77263b5" translate="yes" xml:space="preserve">
          <source>To enable the hierarchical project structure along with the use of platform-dependent libraries in shared source sets, just add the following to your &lt;code&gt;gradle.properties&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b57d628cf85360ad8bd4a7930a8905edba4ddfa" translate="yes" xml:space="preserve">
          <source>To enable the hierarchy structure support, add the following flag to your &lt;code&gt;gradle.properties&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b35444a84ab9bdbb135466d1f0e26e106a076ce9" translate="yes" xml:space="preserve">
          <source>To enable the new JVM IR backend, specify an additional compiler option in your Gradle build script:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6dbd033e65a082aad28e5c2fcd37b8daf6829885" translate="yes" xml:space="preserve">
          <source>To enable this behavior you need to have &lt;code&gt;kotlin-stdlib-jdk7&lt;/code&gt; in your dependencies.</source>
          <target state="translated">要启用此行为，您需要在依赖 &lt;code&gt;kotlin-stdlib-jdk7&lt;/code&gt; 中包含kotlin-stdlib-jdk7。</target>
        </trans-unit>
        <trans-unit id="1b92d03d7ab798afc0052aefc2671aaf31759d48" translate="yes" xml:space="preserve">
          <source>To enable this, inline functions support &lt;em&gt;reified type parameters&lt;/em&gt;, so we can write something like this:</source>
          <target state="translated">为了实现这一点，内联函数支持经过&lt;em&gt;修饰的类型参数&lt;/em&gt;，因此我们可以编写如下代码：</target>
        </trans-unit>
        <trans-unit id="c78de63fcfaed2f5ca9f53b2c3f6f324dab90107" translate="yes" xml:space="preserve">
          <source>To enable trailing commas in the IntelliJ IDEA formatter, go to &lt;strong&gt;Settings | Editor | Code Style | Kotlin&lt;/strong&gt;, open the &lt;strong&gt;Other&lt;/strong&gt; tab and select the &lt;strong&gt;Use trailing comma&lt;/strong&gt; option.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46b021f78d5fbc98904919e312b9537ed7727e54" translate="yes" xml:space="preserve">
          <source>To enable usage of platform-dependent libraries in shared source sets, add the following to your &lt;code&gt;gradle.properties&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="492e1dcfc287eacc3fa568b6d7af38123a5111c3" translate="yes" xml:space="preserve">
          <source>To enjoy the new features in your Kotlin projects, update Gradle to the &lt;a href=&quot;https://gradle.org/releases/&quot;&gt;latest version&lt;/a&gt;. Multiplatform projects require Gradle 6.0 or later, while other Kotlin projects work with Gradle 5.4 or later.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eda2f16c079bedddcf43889e299a4aeef442f108" translate="yes" xml:space="preserve">
          <source>To ensure consistency and meaningful behavior of the generated code, data classes have to fulfill the following requirements:</source>
          <target state="translated">为了保证生成代码的一致性和有意义的行为,数据类必须满足以下要求。</target>
        </trans-unit>
        <trans-unit id="f7d11890fbe59d29f5f955e489a75b4c6f2d6120" translate="yes" xml:space="preserve">
          <source>To evaluate each particular expression in a scratch or a worksheet, run it with &lt;strong&gt;Use REPL&lt;/strong&gt; selected. The code will be executed the same way as in &lt;a href=&quot;#repl&quot;&gt;REPL&lt;/a&gt;: the code lines will run sequentially, providing results of each call. You can later refer to the results by the names &lt;code&gt;res*&lt;/code&gt; shown in the corresponding lines.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1915a0468ec60c04f19505bbcc82c60fb33083b3" translate="yes" xml:space="preserve">
          <source>To evaluate each particular expression in a scratch, run it with &lt;strong&gt;Use REPL&lt;/strong&gt; selected. The scratch will be executed the same way as in &lt;a href=&quot;#repl&quot;&gt;REPL&lt;/a&gt;: the code lines will run subsequently, providing results of each call. You can later refer to the results by the names &lt;code&gt;res*&lt;/code&gt; shown in the corresponding lines.</source>
          <target state="translated">要从头开始评估每个特定的表达式，请在选择&amp;ldquo; &lt;strong&gt;使用REPL&amp;rdquo;的情况下&lt;/strong&gt;运行它。从头开始将以与&lt;a href=&quot;#repl&quot;&gt;REPL中&lt;/a&gt;相同的方式执行：代码行将随后运行，并提供每个调用的结果。您以后可以通过相应行中显示的名称 &lt;code&gt;res*&lt;/code&gt; 引用结果。</target>
        </trans-unit>
        <trans-unit id="94918723afeacff1efa16ca8ab355a3ef8c400e9" translate="yes" xml:space="preserve">
          <source>To exclude default Kotlin libraries that comes as transitive dependencies you can use the following approach:</source>
          <target state="translated">要排除默认的Kotlin库作为转义的依赖关系,你可以使用以下方法。</target>
        </trans-unit>
        <trans-unit id="dfe13659cc9bfcece191e4b8535987313b947937" translate="yes" xml:space="preserve">
          <source>To exclude the standard library from external libraries (notice that &quot;star exclusion&quot; works in Maven 3 only):</source>
          <target state="translated">要从外部库中排除标准库(注意 &quot;星级排除 &quot;只在Maven 3中有效)。</target>
        </trans-unit>
        <trans-unit id="07af8a09aee36adfe68b2b0a1b6017022afe11a3" translate="yes" xml:space="preserve">
          <source>To facilitate this, Kotlin, as a statically typed programming language, uses a family of &lt;a href=&quot;#function-types&quot;&gt;function types&lt;/a&gt; to represent functions and provides a set of specialized language constructs, such as &lt;a href=&quot;#lambda-expressions-and-anonymous-functions&quot;&gt;lambda expressions&lt;/a&gt;.</source>
          <target state="translated">为了促进这一点，Kotlin作为一种静态类型的编程语言，使用一系列&lt;a href=&quot;#function-types&quot;&gt;函数类型&lt;/a&gt;来表示函数，并提供了一组专用的语言构造，例如&lt;a href=&quot;#lambda-expressions-and-anonymous-functions&quot;&gt;lambda表达式&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6f3dc2eba2ee9bd47ab354f073c6c2fcb6b42573" translate="yes" xml:space="preserve">
          <source>To filter collections by negative conditions, use &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/filter-not&quot;&gt;&lt;code&gt;filterNot()&lt;/code&gt;&lt;/a&gt;. It returns a list of elements for which the predicate yields &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">要按负面条件过滤集合，请使用&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/filter-not&quot;&gt; &lt;code&gt;filterNot()&lt;/code&gt; &lt;/a&gt;。它返回谓词产生 &lt;code&gt;false&lt;/code&gt; 的元素列表。</target>
        </trans-unit>
        <trans-unit id="70215058b180f374e26cdfcf334f5153e68b392f" translate="yes" xml:space="preserve">
          <source>To find an intersection between two collections (elements present in both of them), use &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/intersect&quot;&gt;&lt;code&gt;intersect()&lt;/code&gt;&lt;/a&gt;. To find collection elements not present in another collection, use &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/subtract&quot;&gt;&lt;code&gt;subtract()&lt;/code&gt;&lt;/a&gt;. Both these functions can be called in the infix form as well, for example, &lt;code&gt;a intersect b&lt;/code&gt;.</source>
          <target state="translated">要找到两个集合（两个集合中都存在元素）之间的交集，请使用&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/intersect&quot;&gt; &lt;code&gt;intersect()&lt;/code&gt; &lt;/a&gt;。要查找另一个集合中不存在的集合元素，请使用&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/subtract&quot;&gt; &lt;code&gt;subtract()&lt;/code&gt; &lt;/a&gt;。这两个函数也可以以中缀形式调用，例如， &lt;code&gt;a intersect b&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9c38d615ff41226343f4fd39898bb931c04a0136" translate="yes" xml:space="preserve">
          <source>To find out how to start using Kotlin for JavaScript, please refer to the &lt;a href=&quot;../tutorials/javascript/kotlin-to-javascript/kotlin-to-javascript&quot;&gt;tutorials&lt;/a&gt;.</source>
          <target state="translated">要了解如何开始使用Kotlin for JavaScript，请参阅&lt;a href=&quot;../tutorials/javascript/kotlin-to-javascript/kotlin-to-javascript&quot;&gt;教程&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e1b3025669d14b930eb88a22f129712b45d175de" translate="yes" xml:space="preserve">
          <source>To fix this, we have to declare objects of type &lt;code&gt;Source&amp;lt;? extends Object&amp;gt;&lt;/code&gt;, which is sort of meaningless, because we can call all the same methods on such a variable as before, so there's no value added by the more complex type. But the compiler does not know that.</source>
          <target state="translated">为了解决这个问题，我们必须声明 &lt;code&gt;Source&amp;lt;? extends Object&amp;gt;&lt;/code&gt; 类型的对象。扩展Object&amp;gt;，这毫无意义，因为我们可以像以前一样在变量上调用所有相同的方法，因此，更复杂的类型不会增加任何值。但是编译器不知道这一点。</target>
        </trans-unit>
        <trans-unit id="1c3ed2671d90a6fccce18fdda0d98b5b6f90b98a" translate="yes" xml:space="preserve">
          <source>To generate documentation for Kotlin projects, use &lt;a href=&quot;https://github.com/Kotlin/dokka&quot;&gt;Dokka&lt;/a&gt;; please refer to the &lt;a href=&quot;https://github.com/Kotlin/dokka/blob/master/README.md#using-the-gradle-plugin&quot;&gt;Dokka README&lt;/a&gt; for configuration instructions. Dokka supports mixed-language projects and can generate output in multiple formats, including standard JavaDoc.</source>
          <target state="translated">要生成Kotlin项目的文档，请使用&lt;a href=&quot;https://github.com/Kotlin/dokka&quot;&gt;Dokka&lt;/a&gt;；请参阅&lt;a href=&quot;https://github.com/Kotlin/dokka/blob/master/README.md#using-the-gradle-plugin&quot;&gt;Dokka自述文件&lt;/a&gt;以获取配置说明。Dokka支持混合语言项目，并且可以生成多种格式的输出，包括标准JavaDoc。</target>
        </trans-unit>
        <trans-unit id="4da5847f3384d7a88c1adee061594df4e30b80fc" translate="yes" xml:space="preserve">
          <source>To get a seeded instance of random generator use &lt;a href=&quot;index&quot;&gt;Random&lt;/a&gt; function.</source>
          <target state="translated">要获得随机生成器的种子实例，请使用&lt;a href=&quot;index&quot;&gt;随机&lt;/a&gt;函数。</target>
        </trans-unit>
        <trans-unit id="90b0958330415ed4272efd87321aab58607e2589" translate="yes" xml:space="preserve">
          <source>To get a set containing all elements that are contained at least in one of these collections use &lt;a href=&quot;union&quot;&gt;union&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7140ce3a3c50fbb1558d05a01072f6583b3697ee" translate="yes" xml:space="preserve">
          <source>To get a set containing all elements that are contained in both collections use &lt;a href=&quot;intersect&quot;&gt;intersect&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ebdc0fb5ea1aabe15241a38dfb2375efd0bbb23" translate="yes" xml:space="preserve">
          <source>To get started, first download and install the latest version of &lt;a href=&quot;http://www.jetbrains.com/idea/download/index.html&quot;&gt;IntelliJ IDEA&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="004366928e90c7cdc731785eae1ab45f89c2dc1a" translate="yes" xml:space="preserve">
          <source>To get started, install a recent version of IntelliJ IDEA. Kotlin is bundled with IntelliJ IDEA starting from version 15. You can download the free &lt;a href=&quot;http://www.jetbrains.com/idea/download/index.html&quot;&gt;Community Edition&lt;/a&gt; from &lt;a href=&quot;http://www.jetbrains.com&quot;&gt;JetBrains&lt;/a&gt;.</source>
          <target state="translated">首先，请安装最新版本的IntelliJ IDEA。从版本15开始，Kotlin与IntelliJ IDEA捆绑在一起。您可以从&lt;a href=&quot;http://www.jetbrains.com&quot;&gt;JetBrains&lt;/a&gt;下载免费的&lt;a href=&quot;http://www.jetbrains.com/idea/download/index.html&quot;&gt;Community Edition&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="19a5979eba55c06eb5e8ffc62a4e177ce4f4ab4b" translate="yes" xml:space="preserve">
          <source>To get started, install the latest version of &lt;a href=&quot;http://www.jetbrains.com/idea/download/index.html&quot;&gt;IntelliJ IDEA&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07b8c3b410c109db3527c629a1fbed9127661a08" translate="yes" xml:space="preserve">
          <source>To get started, install the latest version of &lt;a href=&quot;http://www.jetbrains.com/idea/download/index.html&quot;&gt;IntelliJ IDEA&lt;/a&gt;. The tutorial is applicable to both IntelliJ IDEA Community Edition and the Ultimate Edition.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94da0b750a9691183cd3aef14a71ddcee794f57c" translate="yes" xml:space="preserve">
          <source>To get the Kotlin class corresponding to a Java class, use the &lt;code&gt;.kotlin&lt;/code&gt; extension property:</source>
          <target state="translated">要获取与Java类相对应的Kotlin类，请使用 &lt;code&gt;.kotlin&lt;/code&gt; 扩展属性：</target>
        </trans-unit>
        <trans-unit id="03f3657fbd7420151d7cbee074c2f638231666dd" translate="yes" xml:space="preserve">
          <source>To get the pointer, &lt;code&gt;.cstr&lt;/code&gt; should be allocated in native memory, e.g.</source>
          <target state="translated">为了获得指针， &lt;code&gt;.cstr&lt;/code&gt; 应该在本地内存中分配，例如</target>
        </trans-unit>
        <trans-unit id="99f419fbdc788d8ad3548e218e2e9d1a31e1f757" translate="yes" xml:space="preserve">
          <source>To get the specified number of elements starting from the first, use the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/take&quot;&gt;&lt;code&gt;take()&lt;/code&gt;&lt;/a&gt; function. For getting the last elements, use &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/take-last&quot;&gt;&lt;code&gt;takeLast()&lt;/code&gt;&lt;/a&gt;. When called with a number larger than the collection size, both functions return the whole collection.</source>
          <target state="translated">要从第一个元素开始获取指定数量的元素，请使用&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/take&quot;&gt; &lt;code&gt;take()&lt;/code&gt; &lt;/a&gt;函数。要获取最后一个元素，请使用&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/take-last&quot;&gt; &lt;code&gt;takeLast()&lt;/code&gt; &lt;/a&gt;。当调用的数字大于集合的大小时，两个函数都将返回整个集合。</target>
        </trans-unit>
        <trans-unit id="60dea6b3d906532fe9c4d5b9272538f57b1ae918" translate="yes" xml:space="preserve">
          <source>To get the value of this duration expressed in a particular &lt;a href=&quot;../-duration-unit/index#kotlin.time.DurationUnit&quot;&gt;duration units&lt;/a&gt; use the functions &lt;a href=&quot;to-int&quot;&gt;toInt&lt;/a&gt;, &lt;a href=&quot;to-long&quot;&gt;toLong&lt;/a&gt;, and &lt;a href=&quot;to-double&quot;&gt;toDouble&lt;/a&gt; or the properties &lt;a href=&quot;in-hours&quot;&gt;inHours&lt;/a&gt;, &lt;a href=&quot;in-minutes&quot;&gt;inMinutes&lt;/a&gt;, &lt;a href=&quot;in-seconds&quot;&gt;inSeconds&lt;/a&gt;, &lt;a href=&quot;in-nanoseconds&quot;&gt;inNanoseconds&lt;/a&gt;, and so on.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c882c6a497d3655af358c59177443fd4abbe265" translate="yes" xml:space="preserve">
          <source>To handle this case, you can mark the property with the &lt;code&gt;lateinit&lt;/code&gt; modifier:</source>
          <target state="translated">要处理这种情况，可以使用 &lt;code&gt;lateinit&lt;/code&gt; 修饰符标记该属性：</target>
        </trans-unit>
        <trans-unit id="f184ea8aba5991e48a265c7b37cae24a3a756b30" translate="yes" xml:space="preserve">
          <source>To have a dependency-injected implementation generated for the type, annotate it with &lt;code&gt;@Component&lt;/code&gt;. The generated class will have the name of this type prepended with Dagger, like &lt;code&gt;DaggerCoffeeShop&lt;/code&gt; below:</source>
          <target state="translated">要为类型生成依赖项注入的实现，请使用 &lt;code&gt;@Component&lt;/code&gt; 对其进行注释。生成的类的名称将以Dagger &lt;code&gt;DaggerCoffeeShop&lt;/code&gt; ，例如下面的DaggerCoffeeShop：</target>
        </trans-unit>
        <trans-unit id="6137f5bb9dbee2ae27bbe242d627fd31058aa51b" translate="yes" xml:space="preserve">
          <source>To have the framework header written without generics, add the flag to the compiler config:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ecd027b7452270691e59717236b30ee0ecf96d4" translate="yes" xml:space="preserve">
          <source>To help removing deprecated API gradually, the property &lt;a href=&quot;level#kotlin.Deprecated%24level&quot;&gt;level&lt;/a&gt; could be used. Usually a gradual phase-out goes through the &quot;warning&quot;, then &quot;error&quot;, then &quot;hidden&quot; or &quot;removed&quot; stages:</source>
          <target state="translated">为了帮助逐渐删除已弃用的API，可以使用属性&lt;a href=&quot;level#kotlin.Deprecated%24level&quot;&gt;级别&lt;/a&gt;。通常，逐步淘汰会经历&amp;ldquo;警告&amp;rdquo;，&amp;ldquo;错误&amp;rdquo;，&amp;ldquo;隐藏&amp;rdquo;或&amp;ldquo;删除&amp;rdquo;阶段：</target>
        </trans-unit>
        <trans-unit id="8ad141ec6c84758415e74b2e6cc38c9b0d8e26a6" translate="yes" xml:space="preserve">
          <source>To help you become more familiar with scripting in Kotlin, we&amp;rsquo;ve prepared a &lt;a href=&quot;https://github.com/Kotlin/kotlin-script-examples&quot;&gt;project with examples&lt;/a&gt;. It contains examples of the standard scripts (&lt;code&gt;*.main.kts&lt;/code&gt;) and examples of uses of the Kotlin Scripting API and custom script definitions. Please give it a try and share your feedback using our &lt;a href=&quot;https://youtrack.jetbrains.com/issues/KT&quot;&gt;issue tracker&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc69b946016a4baffee197957d550f5dda1d3fad" translate="yes" xml:space="preserve">
          <source>To help you choose the right scope function for your case, we'll describe them in detail and provide usage recommendations. Technically, functions are interchangeable in many cases, so the examples show the conventions that define the common usage style.</source>
          <target state="translated">为了帮助您为您的案例选择合适的范围函数,我们将详细描述它们并提供使用建议。从技术上讲,函数在很多情况下是可以互换的,所以例子中展示了定义常见使用方式的约定。</target>
        </trans-unit>
        <trans-unit id="2dc9569e913e0a78f05976a0042b79260268c830" translate="yes" xml:space="preserve">
          <source>To help you choose the right scope function for your purpose, we provide the table of key differences between them.</source>
          <target state="translated">为了帮助您为您的目的选择合适的范围功能,我们提供了它们之间的关键差异表。</target>
        </trans-unit>
        <trans-unit id="f98ff3616d6d9c52fa18df7c42e1d78d8ba28ec6" translate="yes" xml:space="preserve">
          <source>To help you start using the new features of &lt;a href=&quot;#kotlin-multiplatform&quot;&gt;Kotlin multiplatform&lt;/a&gt; in existing projects, we publish the &lt;a href=&quot;migrating-multiplatform-project-to-14&quot;&gt;migration guide for multiplatform projects&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3bc65688182a6a956a218fa3a16959313490f82c" translate="yes" xml:space="preserve">
          <source>To import a Kotlin/Native module in an existing Xcode project:</source>
          <target state="translated">在现有的Xcode项目中导入一个Kotlin/Native模块。</target>
        </trans-unit>
        <trans-unit id="2c68721c967bf9f85180daa4363543c530c2e36a" translate="yes" xml:space="preserve">
          <source>To import this module in Kotlin, you have to write two Kotlin source files:</source>
          <target state="translated">要在Kotlin中导入这个模块,你必须编写两个Kotlin源文件。</target>
        </trans-unit>
        <trans-unit id="6c82d374c6d84bb2e142c6de52f1cf3dcc0306ae" translate="yes" xml:space="preserve">
          <source>To improve the behavior in such cases, Kotlin 1.3 introduces experimental mechanism called &lt;em&gt;contracts&lt;/em&gt;.</source>
          <target state="translated">为了改善这种情况下的行为，Kotlin 1.3引入了称为&lt;em&gt;合同的&lt;/em&gt;实验机制。</target>
        </trans-unit>
        <trans-unit id="2d833a47bb81067eedcf42dfefd225e6c4221741" translate="yes" xml:space="preserve">
          <source>To improve the speed of builds that use kapt, you can enable the &lt;a href=&quot;https://guides.gradle.org/using-the-worker-api/&quot;&gt;Gradle worker API&lt;/a&gt; for kapt tasks. Using the worker API lets Gradle run independent annotation processing tasks from a single project in parallel, which in some cases significantly decreases the execution time. However, running kapt with Gradle worker API enabled can result in increased memory consumption due to parallel execution.</source>
          <target state="translated">为了提高使用kapt的构建速度，您可以为Grap任务启用&lt;a href=&quot;https://guides.gradle.org/using-the-worker-api/&quot;&gt;Gradle worker API&lt;/a&gt;。使用worker API，Gradle可以并行运行来自单个项目的独立注释处理任务，这在某些情况下会大大减少执行时间。但是，在启用Gradle worker API的情况下运行kapt会由于并行执行而导致内存消耗增加。</target>
        </trans-unit>
        <trans-unit id="8bcf0aa09f38966cb24f42a40a86491a1cfa33e5" translate="yes" xml:space="preserve">
          <source>To improve the speed of object allocation, we now offer the &lt;a href=&quot;https://github.com/microsoft/mimalloc&quot;&gt;mimalloc&lt;/a&gt; memory allocator as an alternative to the system allocator. mimalloc works up to two times faster on some benchmarks. Currently, the usage of mimalloc in Kotlin/Native is experimental; you can switch to it using the &lt;code&gt;-Xallocator=mimalloc&lt;/code&gt; compiler option.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="068fdab62a2284b03b98013c61f3a69a95e920c0" translate="yes" xml:space="preserve">
          <source>To improve the times of incremental builds with kapt, it can use the Gradle &lt;a href=&quot;https://docs.gradle.org/current/userguide/java_plugin.html#sec:java_compile_avoidance&quot;&gt;compile avoidance&lt;/a&gt;. With compile avoidance enabled, Gradle can skip annotation processing when rebuilding a project. Particularly, annotation processing is skipped when:</source>
          <target state="translated">为了使用kapt改善增量构建的时间，它可以使用Gradle &lt;a href=&quot;https://docs.gradle.org/current/userguide/java_plugin.html#sec:java_compile_avoidance&quot;&gt;避免编译&lt;/a&gt;。启用避免编译功能后，Gradle可以在重建项目时跳过注释处理。特别是在以下情况下，将跳过注释处理：</target>
        </trans-unit>
        <trans-unit id="ccaf04d3ae02444add2457f45cff16183d2e8aae" translate="yes" xml:space="preserve">
          <source>To include &lt;code&gt;kotlin-osgi-bundle&lt;/code&gt; to a gradle project:</source>
          <target state="translated">要将 &lt;code&gt;kotlin-osgi-bundle&lt;/code&gt; 包含在gradle项目中：</target>
        </trans-unit>
        <trans-unit id="9a00cb17d9820854213a41158d7418355d4b5911" translate="yes" xml:space="preserve">
          <source>To include Java sources in the compilations of a JVM target, or to apply a Gradle plugin that requires the &lt;code&gt;java&lt;/code&gt; plugin to work, you need to explicitly enable Java support for the target:</source>
          <target state="translated">要将Java源代码包含在JVM目标的编译中，或应用要求 &lt;code&gt;java&lt;/code&gt; 插件起作用的Gradle插件，您需要显式启用对目标的Java支持：</target>
        </trans-unit>
        <trans-unit id="b1dd53e422fa19594e216fec42e7a9db9831a316" translate="yes" xml:space="preserve">
          <source>To include Java sources in the compilations of the JVM target, explicitly enable the Java language support for the target:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7860a6aaa1b42e9447caa0f0a8321e9d88a64124" translate="yes" xml:space="preserve">
          <source>To include the Kotlin OSGi bundle to a Maven project:</source>
          <target state="translated">在Maven项目中加入Kotlin OSGi bundle。</target>
        </trans-unit>
        <trans-unit id="077956d227f2aa6078ddf39bc8e4e3d8b94732b8" translate="yes" xml:space="preserve">
          <source>To inspect the bookkeeping details of the library</source>
          <target state="translated">检查图书馆的记账细节</target>
        </trans-unit>
        <trans-unit id="8c24292aeea43558882c36e9ecc631d06e7467b2" translate="yes" xml:space="preserve">
          <source>To install the library to the default location use</source>
          <target state="translated">要将库安装到默认位置,使用</target>
        </trans-unit>
        <trans-unit id="7ee91ac3540f1dbe83a27b16835cca72eb9b4a6e" translate="yes" xml:space="preserve">
          <source>To interop with platforms, use platform-specific versions of Kotlin. &lt;strong&gt;Platform-specific versions of Kotlin&lt;/strong&gt; (Kotlin/JVM, Kotlin/JS, Kotlin/Native) include extensions to the Kotlin language, and platform-specific libraries and tools.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24f6533d6772f8462ed0f43822595fdca8aa6a25" translate="yes" xml:space="preserve">
          <source>To iterate a number range which does not include its end element, use the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.ranges/until&quot;&gt;&lt;code&gt;until&lt;/code&gt;&lt;/a&gt; function:</source>
          <target state="translated">要迭代不包含其结束元素的数字范围，请使用&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.ranges/until&quot;&gt; &lt;code&gt;until&lt;/code&gt; &lt;/a&gt;功能：</target>
        </trans-unit>
        <trans-unit id="b66d0a5358d7d3838074096ed7a34f595b79a041" translate="yes" xml:space="preserve">
          <source>To iterate numbers in reverse order, use the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.ranges/down-to&quot;&gt;&lt;code&gt;downTo&lt;/code&gt;&lt;/a&gt; function instead of &lt;code&gt;..&lt;/code&gt;.</source>
          <target state="translated">要以相反的顺序迭代号码，使用&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.ranges/down-to&quot;&gt; &lt;code&gt;downTo&lt;/code&gt; &lt;/a&gt;功能，而不是 &lt;code&gt;..&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4de33c40021cd7f879768e42f24ff227ac1b5363" translate="yes" xml:space="preserve">
          <source>To iterate over a range of numbers, use a &lt;a href=&quot;ranges&quot;&gt;range expression&lt;/a&gt;:</source>
          <target state="translated">要遍历一个数字范围，请使用&lt;a href=&quot;ranges&quot;&gt;范围表达式&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="d257341caadaa79961255fe9fe80098ff7724e64" translate="yes" xml:space="preserve">
          <source>To keep certain declarations from elimination, add the &lt;code&gt;dceTask&lt;/code&gt; block to your Gradle build script and list the declarations as arguments of the &lt;code&gt;keep&lt;/code&gt; function. An argument must be the declaration's fully qualified name with the module name as a prefix: &lt;code&gt;moduleName.dot.separated.package.name.declarationName&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5aa43f6beeaee705b410de36d25fd9dd87b9df82" translate="yes" xml:space="preserve">
          <source>To learn more about &lt;code&gt;.yarnrc&lt;/code&gt;, please visit the &lt;a href=&quot;https://classic.yarnpkg.com/en/docs/yarnrc/&quot;&gt;official Yarn documentation&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d62030b7e0428ad66c98aff7d08903586325814" translate="yes" xml:space="preserve">
          <source>To learn more about how to write declarations, please refer to the &lt;a href=&quot;../../reference/js-interop&quot;&gt;&quot;Calling JavaScript from Kotlin&quot;&lt;/a&gt; section of the Kotlin documentation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3fab971a68e73bd96c01ec9495b8f9cd81816592" translate="yes" xml:space="preserve">
          <source>To learn more about the &lt;code&gt;kotlinx.html&lt;/code&gt; library, check out the &lt;a href=&quot;https://github.com/Kotlin/kotlinx.html/wiki/Getting-started&quot;&gt;GitHub Wiki&lt;/a&gt;, where you can find more information about how to &lt;a href=&quot;https://github.com/Kotlin/kotlinx.html/wiki/DOM-trees&quot;&gt;create elements&lt;/a&gt; without adding them to the DOM, &lt;a href=&quot;https://github.com/Kotlin/kotlinx.html/wiki/Events&quot;&gt;binding to events&lt;/a&gt; like &lt;code&gt;onClick&lt;/code&gt;, and examples on how to &lt;a href=&quot;https://github.com/Kotlin/kotlinx.html/wiki/Elements-CSS-classes&quot;&gt;apply CSS classes&lt;/a&gt; to your HTML elements, to name just a few.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab2aa40b87301860aff15bd0eb5882ddd4d76c11" translate="yes" xml:space="preserve">
          <source>To learn more about the available features in the new Kotlin/JS IR compiler and how to try it for your project, visit the &lt;a href=&quot;js-ir-compiler&quot;&gt;documentation&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04b14d4042668c912610980566cf53b4151424a6" translate="yes" xml:space="preserve">
          <source>To learn more about the different kinds of JS module and the distinctions between them, see &lt;a href=&quot;https://www.davidbcalhoun.com/2014/what-is-amd-commonjs-and-umd/&quot;&gt;this&lt;/a&gt; article.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e2d5b6189babe68891c536472cd400762b1bb85" translate="yes" xml:space="preserve">
          <source>To let the API users update their modules accordingly (remove the annotations from their code and recompile), mark the annotations as &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin/-deprecated/index&quot;&gt;&lt;code&gt;@Deprecated&lt;/code&gt;&lt;/a&gt; and provide the explanation in the deprecation message.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85b39f1ed38fbcb7ba7bf0ac158a30f9c142955c" translate="yes" xml:space="preserve">
          <source>To link to a library use the &lt;code&gt;-library &amp;lt;name&amp;gt;&lt;/code&gt; or &lt;code&gt;-l &amp;lt;name&amp;gt;&lt;/code&gt; flag. For example:</source>
          <target state="translated">要链接到库，请使用 &lt;code&gt;-library &amp;lt;name&amp;gt;&lt;/code&gt; 或 &lt;code&gt;-l &amp;lt;name&amp;gt;&lt;/code&gt; 标志。例如：</target>
        </trans-unit>
        <trans-unit id="5d43d923015e08ab71364c00b4d2a9fc351e1604" translate="yes" xml:space="preserve">
          <source>To link to another element (class, method, property or parameter), simply put its name in square brackets:</source>
          <target state="translated">要链接到另一个元素(类、方法、属性或参数),只需将其名称放在方括号内即可。</target>
        </trans-unit>
        <trans-unit id="04523bc3328b0c5397fbfdee046da0685d0fae03" translate="yes" xml:space="preserve">
          <source>To list library contents:</source>
          <target state="translated">要列出图书馆的内容。</target>
        </trans-unit>
        <trans-unit id="94d09a96d064da30ca57cf8cdc79fa8ea3d9ad9e" translate="yes" xml:space="preserve">
          <source>To maintain indentation in multiline strings, use &lt;code&gt;trimIndent&lt;/code&gt; when the resulting string does not require any internal indentation, or &lt;code&gt;trimMargin&lt;/code&gt; when internal indentation is required:</source>
          <target state="translated">为了保持多串压痕，使用 &lt;code&gt;trimIndent&lt;/code&gt; 时得到的字符串不需要任何内部凹陷，或 &lt;code&gt;trimMargin&lt;/code&gt; 当需要内部缩进：</target>
        </trans-unit>
        <trans-unit id="e12b1be94182f1503207932a398c53d947b434c0" translate="yes" xml:space="preserve">
          <source>To make Kotlin APIs work in Java we generate &lt;code&gt;Box&amp;lt;Super&amp;gt;&lt;/code&gt; as &lt;code&gt;Box&amp;lt;? extends Super&amp;gt;&lt;/code&gt; for covariantly defined &lt;code&gt;Box&lt;/code&gt; (or &lt;code&gt;Foo&amp;lt;? super Bar&amp;gt;&lt;/code&gt; for contravariantly defined &lt;code&gt;Foo&lt;/code&gt;) when it appears &lt;em&gt;as a parameter&lt;/em&gt;. When it's a return value, we don't generate wildcards, because otherwise Java clients will have to deal with them (and it's against the common Java coding style). Therefore, the functions from our example are actually translated as follows:</source>
          <target state="translated">为了使Kotlin API在Java中工作，我们将 &lt;code&gt;Box&amp;lt;Super&amp;gt;&lt;/code&gt; 成为 &lt;code&gt;Box&amp;lt;? extends Super&amp;gt;&lt;/code&gt; 当协变定义的 &lt;code&gt;Box&lt;/code&gt; &lt;em&gt;作为参数&lt;/em&gt;出现时，扩展Super&amp;gt;来表示协变定义的Box（或 &lt;code&gt;Foo&amp;lt;? super Bar&amp;gt;&lt;/code&gt; 表示相反定义的 &lt;code&gt;Foo&lt;/code&gt; ）。当它是一个返回值时，我们不会生成通配符，因为否则Java客户端将不得不处理通配符（这与常见的Java编码风格背道而驰）。因此，我们示例中的函数实际翻译如下：&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1aa213848d1f87a73fda0915bb91fbde0ccc8072" translate="yes" xml:space="preserve">
          <source>To make reading the input in competitive programming tasks like this more concise, you can have the following list of helper input-reading functions:</source>
          <target state="translated">为了使这样的竞争性编程任务中的输入读取更加简洁,你可以拥有以下的帮助性输入读取函数列表。</target>
        </trans-unit>
        <trans-unit id="9375e20c00ff62d1ddedd02075c0f25b2cc018c0" translate="yes" xml:space="preserve">
          <source>To make the compiler do this, we need to mark the &lt;code&gt;lock()&lt;/code&gt; function with the &lt;code&gt;inline&lt;/code&gt; modifier:</source>
          <target state="translated">为了使编译器执行此操作，我们需要使用 &lt;code&gt;inline&lt;/code&gt; 修饰符标记 &lt;code&gt;lock()&lt;/code&gt; 函数：</target>
        </trans-unit>
        <trans-unit id="27c1b74df654000c9e62d4a18ccabc7efde139c9" translate="yes" xml:space="preserve">
          <source>To make the compiler start controlling scopes we only have to annotate the types of all receivers used in the DSL with the same marker annotation. For instance, for HTML Builders we declare an annotation &lt;code&gt;@HTMLTagMarker&lt;/code&gt;:</source>
          <target state="translated">为了使编译器开始控制作用域，我们只需要使用相同的标记注释来注释DSL中使用的所有接收器的类型。例如，对于HTML Builders，我们声明一个 &lt;code&gt;@HTMLTagMarker&lt;/code&gt; 注释：</target>
        </trans-unit>
        <trans-unit id="e99e5ceb142555c1890edb23ec1da5ac2677e92d" translate="yes" xml:space="preserve">
          <source>To make the library complete we should write some tests, but we have three independent implementations and it is a waste of time to write duplicate tests for each one.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28e2c451a4401d778b575e3ce27ab0a72af2a6e7" translate="yes" xml:space="preserve">
          <source>To make the library complete we should write some tests, but we have three independent implementations and it is a waste of time to write duplicate tests for each one. The good thing about common code is that it can be covered with common tests, which later are compiled and executed on &lt;em&gt;every&lt;/em&gt; platform. All the bits for testing are already generated by the project Wizard.</source>
          <target state="translated">为了使库完整，我们应该编写一些测试，但是我们有三个独立的实现，并且为每个测试编写重复的测试很浪费时间。通用代码的好处是它可以被通用测试所覆盖，然后在&lt;em&gt;每个&lt;/em&gt;平台上编译和执行。用于测试的所有位已经由项目向导生成。</target>
        </trans-unit>
        <trans-unit id="1949bde1af891823df088c0dd9e543cd71be0c91" translate="yes" xml:space="preserve">
          <source>To make the users of annotations &lt;code&gt;@OptIn&lt;/code&gt; and &lt;code&gt;@RequiresOptIn&lt;/code&gt; aware of their experimental status, the compiler raises warnings when compiling the code with these annotations:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="942a849d5ea3976160d1c1dbff01132e386b6a13" translate="yes" xml:space="preserve">
          <source>To make this work, we should</source>
          <target state="translated">要做到这一点,我们应该</target>
        </trans-unit>
        <trans-unit id="c619d626cb3800fca0e85916c367e7240cf3f525" translate="yes" xml:space="preserve">
          <source>To make unsigned integers easier to use, Kotlin provides an ability to tag an integer literal with a suffix indicating a specific unsigned type (similarly to Float/Long):</source>
          <target state="translated">为了使无符号整数更容易使用,Kotlin提供了一种能力,可以给一个整数文字标记一个特定的无符号类型的后缀(类似于Float/Long)。</target>
        </trans-unit>
        <trans-unit id="c98bfc3140cd7bdf91e45deb511c924efadd9a92" translate="yes" xml:space="preserve">
          <source>To make your builds faster, you can enable incremental compilation for Maven (supported since Kotlin 1.1.2). In order to do that, define the &lt;code&gt;kotlin.compiler.incremental&lt;/code&gt; property:</source>
          <target state="translated">为了使构建更快，您可以为Maven启用增量编译（自Kotlin 1.1.2开始受支持）。为此，请定义 &lt;code&gt;kotlin.compiler.incremental&lt;/code&gt; 属性：</target>
        </trans-unit>
        <trans-unit id="2895b62f37c528355f502b2144c9b302d5145a42" translate="yes" xml:space="preserve">
          <source>To manually compile the application call the &lt;a href=&quot;https://github.com/JetBrains/kotlin/releases&quot;&gt;downloaded&lt;/a&gt; compiler and generate a &lt;code&gt;hello.kexe&lt;/code&gt; (Linux and macOS) or &lt;code&gt;hello.exe&lt;/code&gt; (Windows) binary file:</source>
          <target state="translated">要手动编译应用程序，请调用&lt;a href=&quot;https://github.com/JetBrains/kotlin/releases&quot;&gt;下载的&lt;/a&gt;编译器并生成 &lt;code&gt;hello.kexe&lt;/code&gt; （Linux和macOS）或 &lt;code&gt;hello.exe&lt;/code&gt; （Windows）二进制文件：</target>
        </trans-unit>
        <trans-unit id="b4f6cb9f672ef57783a6ef29cd59db4418575608" translate="yes" xml:space="preserve">
          <source>To mark an API element as experimental, annotate its declaration with your experimental marker annotation:</source>
          <target state="translated">要将一个 API 元素标记为实验性元素,请用您的实验性标记注解来注释其声明。</target>
        </trans-unit>
        <trans-unit id="cb122bda7a14229a5d1edd9ff546275f891b9d77" translate="yes" xml:space="preserve">
          <source>To merge two collections into one, use the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/union&quot;&gt;&lt;code&gt;union()&lt;/code&gt;&lt;/a&gt; function. It can be used in the infix form &lt;code&gt;a union b&lt;/code&gt;. Note that for ordered collections the order of the operands is important: in the resulting collection, the elements of the first operand go before the elements of the second.</source>
          <target state="translated">要将两个集合合并为一个，请使用&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/union&quot;&gt; &lt;code&gt;union()&lt;/code&gt; &lt;/a&gt;函数。可以将infix用作 &lt;code&gt;a union b&lt;/code&gt; 。请注意，对于有序集合，操作数的顺序很重要：在结果集合中，第一个操作数的元素位于第二个操作数的元素之前。</target>
        </trans-unit>
        <trans-unit id="44d5c2b36c84b91934a121e2f5ace6e150a12f1e" translate="yes" xml:space="preserve">
          <source>To mitigate such issues, functions using inline classes are &lt;em&gt;mangled&lt;/em&gt; by adding some stable hashcode to the function name. Therefore, &lt;code&gt;fun compute(x: UInt)&lt;/code&gt; will be represented as &lt;code&gt;public final void compute-&amp;lt;hashcode&amp;gt;(int x)&lt;/code&gt;, which solves the clash problem.</source>
          <target state="translated">为了缓解这些问题，使用内联类功能&lt;em&gt;错位&lt;/em&gt;加入一些稳定的哈希码函数名。因此， &lt;code&gt;fun compute(x: UInt)&lt;/code&gt; 将表示为 &lt;code&gt;public final void compute-&amp;lt;hashcode&amp;gt;(int x)&lt;/code&gt; ，从而解决了冲突问题。</target>
        </trans-unit>
        <trans-unit id="214eeb66f4dd4d1fbd2d9b25b399283f63731ef6" translate="yes" xml:space="preserve">
          <source>To mitigate this problem for the users of such bytecode processing tools, we&amp;rsquo;ve added a command-line option (&lt;code&gt;-Xnormalize-constructor-calls=MODE&lt;/code&gt;) that tells the compiler to generate more Java-like bytecode for such constructs. Here &lt;code&gt;MODE&lt;/code&gt; is one of:</source>
          <target state="translated">为了为此类字节码处理工具的用户减轻此问题，我们添加了一个命令行选项（ &lt;code&gt;-Xnormalize-constructor-calls=MODE&lt;/code&gt; ），该选项告诉编译器为此类构造生成更多类似于Java的字节码。这里 &lt;code&gt;MODE&lt;/code&gt; 是下列之一：</target>
        </trans-unit>
        <trans-unit id="d6aa0bdd277639961899c3f20d2977a244b12631" translate="yes" xml:space="preserve">
          <source>To mitigate this, when defining your generic classes, if the generic type should &lt;em&gt;never&lt;/em&gt; be null, provide a non-null type constraint:</source>
          <target state="translated">为了减轻这种情况，在定义泛型类时，如果泛型类型&lt;em&gt;永远不能&lt;/em&gt;为null，请提供非null类型约束：</target>
        </trans-unit>
        <trans-unit id="c1476847da392c83fd72508f4713555cdba4a150" translate="yes" xml:space="preserve">
          <source>To open the list of available courses, go to &lt;strong&gt;Browse Courses&lt;/strong&gt; on the &lt;strong&gt;Welcome Screen&lt;/strong&gt; or in the &lt;strong&gt;File Menu&lt;/strong&gt;. You can start with the &lt;a href=&quot;koans&quot;&gt;Kotlin Koans&lt;/a&gt;, a series of exercises created to get you familiar with the Kotlin Syntax:</source>
          <target state="translated">要打开可用课程列表，请在&amp;ldquo; &lt;strong&gt;欢迎&amp;rdquo;屏幕上&lt;/strong&gt;或&amp;ldquo; &lt;strong&gt;文件&amp;rdquo;菜单中&lt;/strong&gt;转到&amp;ldquo; &lt;strong&gt;浏览课程&lt;/strong&gt; &amp;rdquo; 。您可以从&lt;a href=&quot;koans&quot;&gt;Kotlin Koans&lt;/a&gt;开始，这是一系列让您熟悉Kotlin语法的练习：&lt;strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="10ddd6b6d4ee0835e4f821b2d4cf707d94c091da" translate="yes" xml:space="preserve">
          <source>To opt in to multiple APIs on the module level, add one of the described arguments for each opt-in requirement marker used in your module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f5b1117471b5f9bbedb587fe4ad37368bca070e" translate="yes" xml:space="preserve">
          <source>To opt-in without propagating, either annotate declarations with &lt;code&gt;@OptIn(ExperimentalUnsignedTypes::class)&lt;/code&gt; or pass &lt;code&gt;-Xopt-in=kotlin.ExperimentalUnsignedTypes&lt;/code&gt; to the compiler.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c9c6ae81e15d7660d42f1ec133505c23d5897c2" translate="yes" xml:space="preserve">
          <source>To overcome this restriction an &lt;code&gt;internal&lt;/code&gt; declaration can be annotated with the &lt;code&gt;@PublishedApi&lt;/code&gt; annotation:</source>
          <target state="translated">为了克服此限制，可以使用 &lt;code&gt;@PublishedApi&lt;/code&gt; 批注对 &lt;code&gt;internal&lt;/code&gt; 声明进行批注：</target>
        </trans-unit>
        <trans-unit id="a53373994c3982c9e9e8b4ff82c6886cee600271" translate="yes" xml:space="preserve">
          <source>To override &lt;code&gt;clone()&lt;/code&gt;, your class needs to extend &lt;code&gt;kotlin.Cloneable&lt;/code&gt;:</source>
          <target state="translated">要覆盖 &lt;code&gt;clone()&lt;/code&gt; ，您的类需要扩展 &lt;code&gt;kotlin.Cloneable&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="5e5ef664ee32f352aa2bb27af09f15aaa52406f6" translate="yes" xml:space="preserve">
          <source>To override &lt;code&gt;finalize()&lt;/code&gt;, all you need to do is simply declare it, without using the &lt;em&gt;override&lt;/em&gt; keyword:</source>
          <target state="translated">要覆盖 &lt;code&gt;finalize()&lt;/code&gt; ，您只需要声明它，而无需使用&lt;em&gt;override&lt;/em&gt;关键字：</target>
        </trans-unit>
        <trans-unit id="8b0eb1602de9391e417352c211eac3143269f17a" translate="yes" xml:space="preserve">
          <source>To override different methods with clashing Kotlin signatures, you can add a &lt;code&gt;@Suppress(&quot;CONFLICTING_OVERLOADS&quot;)&lt;/code&gt; annotation to the class.</source>
          <target state="translated">要使用冲突的Kotlin签名覆盖不同的方法，您可以在类中添加 &lt;code&gt;@Suppress(&quot;CONFLICTING_OVERLOADS&quot;)&lt;/code&gt; 批注。</target>
        </trans-unit>
        <trans-unit id="91bf99aec76b5996287fb77c5aef5099beb9bbf4" translate="yes" xml:space="preserve">
          <source>To pass an array of primitive values you can do the following in Kotlin:</source>
          <target state="translated">要传递一个基元值数组,你可以在Kotlin中执行以下操作。</target>
        </trans-unit>
        <trans-unit id="1e5025ef1a23d09437b26030660587370537de7f" translate="yes" xml:space="preserve">
          <source>To pass custom raw compiler arguments, you can use &lt;code&gt;&amp;lt;compilerarg&amp;gt;&lt;/code&gt; elements with either &lt;code&gt;value&lt;/code&gt; or &lt;code&gt;line&lt;/code&gt; attributes. This can be done within the &lt;code&gt;&amp;lt;kotlinc&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;kotlin2js&amp;gt;&lt;/code&gt;, and &lt;code&gt;&amp;lt;withKotlin&amp;gt;&lt;/code&gt; task elements, as follows:</source>
          <target state="translated">要传递自定义的原始编译器参数，可以将 &lt;code&gt;&amp;lt;compilerarg&amp;gt;&lt;/code&gt; 元素与 &lt;code&gt;value&lt;/code&gt; 或 &lt;code&gt;line&lt;/code&gt; 属性一起使用。这可以在 &lt;code&gt;&amp;lt;kotlinc&amp;gt;&lt;/code&gt; ， &lt;code&gt;&amp;lt;kotlin2js&amp;gt;&lt;/code&gt; 和 &lt;code&gt;&amp;lt;withKotlin&amp;gt;&lt;/code&gt; 任务元素中完成，如下所示：</target>
        </trans-unit>
        <trans-unit id="dc5a689b36d99998646f8c6f6cfcbfb516f9dfc2" translate="yes" xml:space="preserve">
          <source>To pass values that contain whitespaces, surround them with single (&lt;strong&gt;'&lt;/strong&gt;) or double (&lt;strong&gt;&quot;&lt;/strong&gt;) quotes. If a value contains quotation marks in it, escape them with a backslash (&lt;strong&gt;\&lt;/strong&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a66e06df579b1b23b91b1d16d9167a525f0b07ab" translate="yes" xml:space="preserve">
          <source>To perform a certain operation only for non-null values, you can use the safe call operator together with &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin/let&quot;&gt;&lt;code&gt;let&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">要仅对非空值执行某些操作，可以将安全调用运算符与&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin/let&quot;&gt; &lt;code&gt;let&lt;/code&gt; &lt;/a&gt;一起使用：</target>
        </trans-unit>
        <trans-unit id="ad4b6b2d80d98efbdc1e78464bd70bae937149d2" translate="yes" xml:space="preserve">
          <source>To perform operations on all keys or all values of a map, you can retrieve them from the properties &lt;code&gt;keys&lt;/code&gt; and &lt;code&gt;values&lt;/code&gt; accordingly. &lt;code&gt;keys&lt;/code&gt; is a set of all map keys and &lt;code&gt;values&lt;/code&gt; is a collection of all map values.</source>
          <target state="translated">要对地图的所有键或所有值执行操作，可以从属性 &lt;code&gt;keys&lt;/code&gt; 和 &lt;code&gt;values&lt;/code&gt; 相应地检索它们。 &lt;code&gt;keys&lt;/code&gt; 是所有映射键的集合， &lt;code&gt;values&lt;/code&gt; 是所有映射值的集合。</target>
        </trans-unit>
        <trans-unit id="b92bc0346854a9fa46aa79641f72238048fe6403" translate="yes" xml:space="preserve">
          <source>To prevent potential issues, the compiler warns users of such APIs about these conditions and requires them to opt in before using the API.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f51b0c422406c4232c8e54b63e979d8283484a9e" translate="yes" xml:space="preserve">
          <source>To prevent spoiling the global object, Kotlin creates an object that contains all Kotlin declarations from the current module. So if you name your module as &lt;code&gt;myModule&lt;/code&gt;, all declarations are available to JavaScript via &lt;code&gt;myModule&lt;/code&gt; object. For example:</source>
          <target state="translated">为了防止破坏全局对象，Kotlin创建了一个对象，该对象包含当前模块中的所有Kotlin声明。因此，如果您将模块命名为 &lt;code&gt;myModule&lt;/code&gt; ，则所有声明均可通过 &lt;code&gt;myModule&lt;/code&gt; 对象提供给JavaScript 。例如：</target>
        </trans-unit>
        <trans-unit id="bf0b70dea8387f3ebfae5a605f2eb84fae8ef787" translate="yes" xml:space="preserve">
          <source>To produce a library with the Kotlin/Native compiler use the &lt;code&gt;-produce library&lt;/code&gt; or &lt;code&gt;-p library&lt;/code&gt; flag. For example:</source>
          <target state="translated">要使用Kotlin / Native编译器生成库，请使用 &lt;code&gt;-produce library&lt;/code&gt; 或 &lt;code&gt;-p library&lt;/code&gt; 标志。例如：</target>
        </trans-unit>
        <trans-unit id="ffef4a8cd2a1229b2f11fc8babdeb98ccaf8e0db" translate="yes" xml:space="preserve">
          <source>To produce binaries with the Kotlin/Native compiler it's sufficient to use the &lt;code&gt;-g&lt;/code&gt; option on the command line.</source>
          <target state="translated">要使用Kotlin / Native编译器生成二进制文件，在命令行上使用 &lt;code&gt;-g&lt;/code&gt; 选项就足够了。</target>
        </trans-unit>
        <trans-unit id="bf705fafa9b67e24b379be9a50584f74e0e18d03" translate="yes" xml:space="preserve">
          <source>To propagate the opt-in requirement, annotate declarations that use unsigned integers with &lt;code&gt;@ExperimentalUnsignedTypes&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb410b553ff107b4b517f8f7d71063276da071a9" translate="yes" xml:space="preserve">
          <source>To provide a consistent experience when working with different container types, we&amp;rsquo;ve also added new functions for &lt;strong&gt;arrays&lt;/strong&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d3463a205e94a6afcbfd6330cbb565e26b9762f" translate="yes" xml:space="preserve">
          <source>To provide a custom equals check implementation, override the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin/-any/equals&quot;&gt;&lt;code&gt;equals(other: Any?): Boolean&lt;/code&gt;&lt;/a&gt; function. Functions with the same name and other signatures, like &lt;code&gt;equals(other: Foo)&lt;/code&gt;, don't affect equality checks with the operators &lt;code&gt;==&lt;/code&gt; and &lt;code&gt;!=&lt;/code&gt;.</source>
          <target state="translated">要提供自定义的equals check实现，请重写&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin/-any/equals&quot;&gt; &lt;code&gt;equals(other: Any?): Boolean&lt;/code&gt; &lt;/a&gt;函数。具有相同名称和其他签名的函数，例如 &lt;code&gt;equals(other: Foo)&lt;/code&gt; ，不影响使用运算符 &lt;code&gt;==&lt;/code&gt; 和 &lt;code&gt;!=&lt;/code&gt; 进行的相等性检查。</target>
        </trans-unit>
        <trans-unit id="6e836b4f2fc16da476cc12a9d2050e81e112acff" translate="yes" xml:space="preserve">
          <source>To provide access to user's native operating system services, &lt;code&gt;Kotlin/Native&lt;/code&gt; distribution includes a set of prebuilt libraries specific to each target. We call them &lt;strong&gt;Platform Libraries&lt;/strong&gt;.</source>
          <target state="translated">为了提供对用户本机操作系统服务的访问， &lt;code&gt;Kotlin/Native&lt;/code&gt; 发行版包括一组特定于每个目标的预构建库。我们称它们为&lt;strong&gt;平台库&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="31bd1e7079e9e4ecee7632836be44ddf7d329d26" translate="yes" xml:space="preserve">
          <source>To publish an Android library as a part of a multiplatform library, one needs to &lt;a href=&quot;#publishing-a-multiplatform-library&quot;&gt;setup publishing for the library&lt;/a&gt; and provide additional configuration for the Android library target.</source>
          <target state="translated">要将Android库发布为多平台库的一部分，需要&lt;a href=&quot;#publishing-a-multiplatform-library&quot;&gt;设置该库的发布&lt;/a&gt;并为Android库目标提供其他配置。</target>
        </trans-unit>
        <trans-unit id="ea7d8288d45b7d92cbec680fddd4a73d1135d188" translate="yes" xml:space="preserve">
          <source>To publish an Android library, you need to provide additional configuration.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ba7323e97d7a64aa36c1fb8b1ca290f8aaf3112" translate="yes" xml:space="preserve">
          <source>To refer to all or some particular compilations of a target, use the &lt;code&gt;compilations&lt;/code&gt; object collection. From &lt;code&gt;compilations&lt;/code&gt;, you can refer to a compilation by its name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d256a0c22e6d267c506acee2d9aeb1788f5b9b28" translate="yes" xml:space="preserve">
          <source>To refer to the object, we use its name directly:</source>
          <target state="translated">为了引用对象,我们直接使用其名称。</target>
        </trans-unit>
        <trans-unit id="6b8089bed090bdadd847bf36cd42b8f6183969d2" translate="yes" xml:space="preserve">
          <source>To remove an element at a specific position from a list, use the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-mutable-list/remove-at&quot;&gt;&lt;code&gt;removeAt()&lt;/code&gt;&lt;/a&gt; function providing the position as an argument. All indices of elements that come after the element being removed will decrease by one.</source>
          <target state="translated">要从列表中删除特定位置的元素，请使用&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-mutable-list/remove-at&quot;&gt; &lt;code&gt;removeAt()&lt;/code&gt; &lt;/a&gt;函数，将该位置作为参数。在元素被删除之后出现的所有元素索引将减少一。</target>
        </trans-unit>
        <trans-unit id="521b7c2bcc6979fed176a9238d544430e53c8f9c" translate="yes" xml:space="preserve">
          <source>To remove an element from a mutable collection, use the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/remove&quot;&gt;&lt;code&gt;remove()&lt;/code&gt;&lt;/a&gt; function. &lt;code&gt;remove()&lt;/code&gt; accepts the element value and removes one occurrence of this value.</source>
          <target state="translated">要从可变集合中删除元素，请使用&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/remove&quot;&gt; &lt;code&gt;remove()&lt;/code&gt; &lt;/a&gt;函数。 &lt;code&gt;remove()&lt;/code&gt; 接受元素值并删除该值的一次出现。</target>
        </trans-unit>
        <trans-unit id="3a5e20b686847f8b478f6ecb4aea9aa4a6082939" translate="yes" xml:space="preserve">
          <source>To remove an entry from a mutable map, use the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-mutable-map/remove&quot;&gt;&lt;code&gt;remove()&lt;/code&gt;&lt;/a&gt; function. When calling &lt;code&gt;remove()&lt;/code&gt;, you can pass either a key or a whole key-value-pair. If you specify both the key and value, the element with this key will be removed only if its value matches the second argument.</source>
          <target state="translated">要从可变映射中删除条目，请使用&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-mutable-map/remove&quot;&gt; &lt;code&gt;remove()&lt;/code&gt; &lt;/a&gt;函数。调用 &lt;code&gt;remove()&lt;/code&gt; 时，您可以传递键或整个键值对。如果同时指定键和值，则仅当其值与第二个参数匹配时，才会删除带有此键的元素。</target>
        </trans-unit>
        <trans-unit id="0521fbcd6fb6f9d94e609424eadc7933044f924e" translate="yes" xml:space="preserve">
          <source>To remove the library from the default repository use</source>
          <target state="translated">要从默认仓库中删除库,使用</target>
        </trans-unit>
        <trans-unit id="31c3d88842fee1685ad0d679c0db8a0fc174ec11" translate="yes" xml:space="preserve">
          <source>To remove the warning you have to opt in to the usage of experimental features by passing the argument &lt;code&gt;-XXLanguage:+InlineClasses&lt;/code&gt; to &lt;code&gt;kotlinc&lt;/code&gt;.</source>
          <target state="translated">要消除警告，您必须通过将参数 &lt;code&gt;-XXLanguage:+InlineClasses&lt;/code&gt; 传递给 &lt;code&gt;kotlinc&lt;/code&gt; 来选择使用实验性功能。</target>
        </trans-unit>
        <trans-unit id="0e630e1d578ed6510bfa59a81e36360f93345c8c" translate="yes" xml:space="preserve">
          <source>To remove the warning you have to opt in to the usage of this feature by passing the compiler argument &lt;code&gt;-Xinline-classes&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28a952e26ac563cedfa7c9f543249e0cc2d66483" translate="yes" xml:space="preserve">
          <source>To remove the warnings, add the compiler argument &lt;code&gt;-Xopt-in=kotlin.RequiresOptIn&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3f08203a0ddf6e6bc4f31d19032cdb3e04aee85" translate="yes" xml:space="preserve">
          <source>To remove the warnings, add the compiler argument &lt;code&gt;-Xuse-experimental=kotlin.Experimental&lt;/code&gt;.</source>
          <target state="translated">要删除警告，请添加编译器参数 &lt;code&gt;-Xuse-experimental=kotlin.Experimental&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d469d435bb3a113c1dd1088e7025b64a6a0198e5" translate="yes" xml:space="preserve">
          <source>To represent body of an external function. In most cases Kotlin does not require to provide bodies of external functions and properties, but if for some reason you want to (for example, due to limitation of your coding style guides), you should use &lt;code&gt;definedExternally&lt;/code&gt;.</source>
          <target state="translated">表示外部功能的主体。在大多数情况下，Kotlin不需要提供外部函数和属性的主体，但是如果出于某些原因（例如，由于编码样式指南的限制），则应使用 &lt;code&gt;definedExternally&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="19ce750db4ac36bdd72cdcddab7ef744528c90ce" translate="yes" xml:space="preserve">
          <source>To represent value of default argument.</source>
          <target state="translated">表示默认参数的值。</target>
        </trans-unit>
        <trans-unit id="14a14bea6684b1e554722af225128be0f57d25cd" translate="yes" xml:space="preserve">
          <source>To require an opt-in to using an API element, annotate its declaration with an opt-in requirement annotation:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54a0a9d97090503eaabc29843393d48b0c0faafe" translate="yes" xml:space="preserve">
          <source>To resolve ambiguities in exports (like overloads for functions with the same name), you can use the &lt;code&gt;@JsExport&lt;/code&gt; annotation together with &lt;code&gt;@JsName&lt;/code&gt; to specify the names for the generated and exported functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69457a99de832ac1adcb88dba9125bcc6ced4562" translate="yes" xml:space="preserve">
          <source>To retrieve the Java class of an object, use the &lt;code&gt;java&lt;/code&gt; extension property on a &lt;a href=&quot;reflection#class-references&quot;&gt;class reference&lt;/a&gt;:</source>
          <target state="translated">要检索对象的Java类，请在&lt;a href=&quot;reflection#class-references&quot;&gt;类引用&lt;/a&gt;上使用 &lt;code&gt;java&lt;/code&gt; 扩展属性：</target>
        </trans-unit>
        <trans-unit id="e9630cc244843d39b109cb4a4e7a2a47687f686a" translate="yes" xml:space="preserve">
          <source>To return a floating-point type, explicitly convert one of the arguments to a floating-point type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cab4ab009a9095119ec865716a0422fa20f520ff" translate="yes" xml:space="preserve">
          <source>To return to the pre-1.2 behavior, pass the flag &lt;code&gt;-Xno-exception-on-explicit-equals-for-boxed-null&lt;/code&gt; to the compiler.</source>
          <target state="translated">若要返回1.2之前的行为，请将标志 &lt;code&gt;-Xno-exception-on-explicit-equals-for-boxed-null&lt;/code&gt; 传递给编译器。</target>
        </trans-unit>
        <trans-unit id="5e0d2974dcfaa7063fb542a18d0b57f9a9db0a83" translate="yes" xml:space="preserve">
          <source>To run REPL in IntelliJ IDEA, open &lt;strong&gt;Tools | Kotlin | Kotlin REPL&lt;/strong&gt;.</source>
          <target state="translated">要在IntelliJ IDEA中运行REPL，请打开&amp;ldquo; &lt;strong&gt;工具&amp;rdquo; |&amp;ldquo;工具&amp;rdquo;。科特林| Kotlin REPL&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="c80c0585cded44d08003b71c290d1079d4069543" translate="yes" xml:space="preserve">
          <source>To run REPL in the OS command line, open &lt;strong&gt;/bin/kotlinc-jvm&lt;/strong&gt; from the directory of standalone Kotlin compiler.</source>
          <target state="translated">要在OS命令行中运行REPL，请从独立Kotlin编译器的目录中打开&lt;strong&gt;/ bin / kotlinc-jvm&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="3cc3c110a513b90b220f8954bf1227697a6710b3" translate="yes" xml:space="preserve">
          <source>To run a project, execute the standard lifecycle &lt;code&gt;run&lt;/code&gt; task, or the alias to which it corresponds:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7fd27594c6ae21992652c27028d51d29604dfae3" translate="yes" xml:space="preserve">
          <source>To run a script, we just pass the &lt;code&gt;-script&lt;/code&gt; option to the compiler with the corresponding script file.</source>
          <target state="translated">要运行脚本，我们只需将 &lt;code&gt;-script&lt;/code&gt; 选项和相应的脚本文件传递给编译器。</target>
        </trans-unit>
        <trans-unit id="e2cae558670745cc7ac9e88ece3ef0ebf63a7483" translate="yes" xml:space="preserve">
          <source>To run kapt with compile avoidance:</source>
          <target state="translated">运行kapt时要避免编译。</target>
        </trans-unit>
        <trans-unit id="7bfb5403dc626e7b616c00072ab7971dc81d2cec" translate="yes" xml:space="preserve">
          <source>To run tests for a particular target suitable for testing, run a test task &lt;code&gt;&amp;lt;targetName&amp;gt;Test&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65dc2975423668b7d149d3345dc1e61eeea66998" translate="yes" xml:space="preserve">
          <source>To run tests for all targets, run the &lt;code&gt;check&lt;/code&gt; task.</source>
          <target state="new"/>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
