<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="kotlin">
    <body>
      <group id="kotlin">
        <trans-unit id="5ac343906b9635efc6bc3ea707e0886b7e34f40a" translate="yes" xml:space="preserve">
          <source>The last element of the progression is calculated to find the maximum value not greater than the end value for a positive step or the minimum value not less than the end value for a negative step such that &lt;code&gt;(last - first) % step == 0&lt;/code&gt;.</source>
          <target state="translated">计算该级数的最后一个元素，以找到正步长的最大值不大于最终值或负步长的最小值不小于最终值，以使 &lt;code&gt;(last - first) % step == 0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="01b3b5a6efe68e4716a891433d6bbbed0351ca8d" translate="yes" xml:space="preserve">
          <source>The last line is invoking the function itself and passing as argument &lt;code&gt;kotlin&lt;/code&gt;, which refers to the standard library. This can be obtained in one of two ways:</source>
          <target state="translated">最后一行是调用函数本身并作为参数 &lt;code&gt;kotlin&lt;/code&gt; 传递，该参数引用标准库。可以通过以下两种方式之一来获得：</target>
        </trans-unit>
        <trans-unit id="538d53f2bc70104b650857f7bb5ca32765c9300b" translate="yes" xml:space="preserve">
          <source>The last list in the resulting list may have less elements than the given &lt;a href=&quot;chunked#kotlin.collections%24chunked%28kotlin.collections.Iterable%28%28kotlin.collections.chunked.T%29%29%2C+kotlin.Int%29%2Fsize&quot;&gt;size&lt;/a&gt;.</source>
          <target state="translated">结果列表中的最后一个列表的元素数可能少于给定的&lt;a href=&quot;chunked#kotlin.collections%24chunked%28kotlin.collections.Iterable%28%28kotlin.collections.chunked.T%29%29%2C+kotlin.Int%29%2Fsize&quot;&gt;大小&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="df81eba7c4b794145b48baa6539e2f2979a8d58f" translate="yes" xml:space="preserve">
          <source>The last list in the resulting sequence may have less elements than the given &lt;a href=&quot;chunked#kotlin.sequences%24chunked%28kotlin.sequences.Sequence%28%28kotlin.sequences.chunked.T%29%29%2C+kotlin.Int%29%2Fsize&quot;&gt;size&lt;/a&gt;.</source>
          <target state="translated">结果序列中的最后一个列表可能包含的元素少于给定&lt;a href=&quot;chunked#kotlin.sequences%24chunked%28kotlin.sequences.Sequence%28%28kotlin.sequences.chunked.T%29%29%2C+kotlin.Int%29%2Fsize&quot;&gt;大小的&lt;/a&gt;元素。</target>
        </trans-unit>
        <trans-unit id="19dcc0ec6fdfe1941cf804b7c1eaf5c5297a4c82" translate="yes" xml:space="preserve">
          <source>The last string in the resulting list may have less characters than the given &lt;a href=&quot;chunked#kotlin.text%24chunked%28kotlin.CharSequence%2C+kotlin.Int%29%2Fsize&quot;&gt;size&lt;/a&gt;.</source>
          <target state="translated">结果列表中的最后一个字符串的字符数可能少于给定的&lt;a href=&quot;chunked#kotlin.text%24chunked%28kotlin.CharSequence%2C+kotlin.Int%29%2Fsize&quot;&gt;大小&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5264566740d059c5fcc7247f9b4782bf04dc775d" translate="yes" xml:space="preserve">
          <source>The last string in the resulting sequence may have less characters than the given &lt;a href=&quot;chunked-sequence#kotlin.text%24chunkedSequence%28kotlin.CharSequence%2C+kotlin.Int%29%2Fsize&quot;&gt;size&lt;/a&gt;.</source>
          <target state="translated">结果序列中的最后一个字符串的字符数可能少于给定的&lt;a href=&quot;chunked-sequence#kotlin.text%24chunkedSequence%28kotlin.CharSequence%2C+kotlin.Int%29%2Fsize&quot;&gt;大小&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="34c76d76568703e916e3116e8326427af7debc51" translate="yes" xml:space="preserve">
          <source>The lastIndex is a read/write integer property of regular expressions that specifies the index at which to start the next match.</source>
          <target state="translated">lastIndex是正则表达式的一个读/写整数属性,指定了开始下一次匹配的索引。</target>
        </trans-unit>
        <trans-unit id="9d0eba273c11a973f53f6330c745e78d9f5b9345" translate="yes" xml:space="preserve">
          <source>The latter is called &lt;strong&gt;contravariance&lt;/strong&gt;, and you can only call methods that take String as an argument on &lt;code&gt;List&amp;lt;? super String&amp;gt;&lt;/code&gt; (e.g., you can call &lt;code&gt;add(String)&lt;/code&gt; or &lt;code&gt;set(int, String)&lt;/code&gt;), while if you call something that returns &lt;code&gt;T&lt;/code&gt; in &lt;code&gt;List&amp;lt;T&amp;gt;&lt;/code&gt;, you don't get a &lt;code&gt;String&lt;/code&gt;, but an &lt;code&gt;Object&lt;/code&gt;.</source>
          <target state="translated">后者称为&lt;strong&gt;convarivariance&lt;/strong&gt;，您只能调用将String作为 &lt;code&gt;List&amp;lt;? super String&amp;gt;&lt;/code&gt; 上的参数的方法。超级String&amp;gt;（例如，您可以调用 &lt;code&gt;add(String)&lt;/code&gt; 或 &lt;code&gt;set(int, String)&lt;/code&gt; ），而如果您调用在 &lt;code&gt;List&amp;lt;T&amp;gt;&lt;/code&gt; 中返回 &lt;code&gt;T&lt;/code&gt; 的 &lt;code&gt;Object&lt;/code&gt; ，则不会得到 &lt;code&gt;String&lt;/code&gt; ，而是Object。</target>
        </trans-unit>
        <trans-unit id="86eeb4f1664e3df8b781582839802549edf89327" translate="yes" xml:space="preserve">
          <source>The layout of a Kotlin multiplatform project is constructed out of the following building blocks:</source>
          <target state="translated">Kotlin多平台项目的布局是由以下构件构成的。</target>
        </trans-unit>
        <trans-unit id="dc4b69a6e38939f4509626db77c33dd8c679086f" translate="yes" xml:space="preserve">
          <source>The least significant 16 bits of the resulting &lt;code&gt;Int&lt;/code&gt; value are the same as the bits of this &lt;code&gt;Short&lt;/code&gt; value, whereas the most significant 16 bits are filled with the sign bit of this value.</source>
          <target state="translated">结果 &lt;code&gt;Int&lt;/code&gt; 值的最低16位与该 &lt;code&gt;Short&lt;/code&gt; 值的位相同，而最高16位用该值的符号位填充。</target>
        </trans-unit>
        <trans-unit id="4f0f34d38c4a4771a59f6d35fcaf5f32f9d5a113" translate="yes" xml:space="preserve">
          <source>The least significant 16 bits of the resulting &lt;code&gt;Int&lt;/code&gt; value are the same as the bits of this &lt;code&gt;UShort&lt;/code&gt; value, whereas the most significant 16 bits are filled with zeros.</source>
          <target state="translated">结果 &lt;code&gt;Int&lt;/code&gt; 值的最低16位与此 &lt;code&gt;UShort&lt;/code&gt; 值的位相同，而最高16位用零填充。</target>
        </trans-unit>
        <trans-unit id="db7d64a40964cbcc91041fe9c6abd3a6f883ba7c" translate="yes" xml:space="preserve">
          <source>The least significant 16 bits of the resulting &lt;code&gt;Long&lt;/code&gt; value are the same as the bits of this &lt;code&gt;Short&lt;/code&gt; value, whereas the most significant 48 bits are filled with the sign bit of this value.</source>
          <target state="translated">结果 &lt;code&gt;Long&lt;/code&gt; 值的最低有效16位与此 &lt;code&gt;Short&lt;/code&gt; 值的相同，而最高48位则用此值的符号位填充。</target>
        </trans-unit>
        <trans-unit id="96755580626f22c0780c08fafc24e52c9efd9ea9" translate="yes" xml:space="preserve">
          <source>The least significant 16 bits of the resulting &lt;code&gt;Long&lt;/code&gt; value are the same as the bits of this &lt;code&gt;UShort&lt;/code&gt; value, whereas the most significant 48 bits are filled with zeros.</source>
          <target state="translated">结果 &lt;code&gt;Long&lt;/code&gt; 值的最低有效16位与此 &lt;code&gt;UShort&lt;/code&gt; 值的位相同，而最高有效48位用零填充。</target>
        </trans-unit>
        <trans-unit id="805e1d578ae5895787cd7c80c9a6f84d9875cbdf" translate="yes" xml:space="preserve">
          <source>The least significant 16 bits of the resulting &lt;code&gt;UInt&lt;/code&gt; value are the same as the bits of this &lt;code&gt;Short&lt;/code&gt; value, whereas the most significant 16 bits are filled with the sign bit of this value.</source>
          <target state="translated">所得的 &lt;code&gt;UInt&lt;/code&gt; 值的最低有效16位与该 &lt;code&gt;Short&lt;/code&gt; 值的位相同，而最高有效的16位用该值的符号位填充。</target>
        </trans-unit>
        <trans-unit id="e2d7f90749fa8a275417e31e2a951b621f7bdd7e" translate="yes" xml:space="preserve">
          <source>The least significant 16 bits of the resulting &lt;code&gt;UInt&lt;/code&gt; value are the same as the bits of this &lt;code&gt;UShort&lt;/code&gt; value, whereas the most significant 16 bits are filled with zeros.</source>
          <target state="translated">所得 &lt;code&gt;UInt&lt;/code&gt; 值的最低有效16位与此 &lt;code&gt;UShort&lt;/code&gt; 值的位相同，而最高有效16位用零填充。</target>
        </trans-unit>
        <trans-unit id="382a5532019e821cafc1c9ca21454b43f1f91a60" translate="yes" xml:space="preserve">
          <source>The least significant 16 bits of the resulting &lt;code&gt;ULong&lt;/code&gt; value are the same as the bits of this &lt;code&gt;Short&lt;/code&gt; value, whereas the most significant 48 bits are filled with the sign bit of this value.</source>
          <target state="translated">得到的 &lt;code&gt;ULong&lt;/code&gt; 值的最低有效16位与该 &lt;code&gt;Short&lt;/code&gt; 值的位相同，而最高有效48位用该值的符号位填充。</target>
        </trans-unit>
        <trans-unit id="98d7b8a419dc2e1a1e55aeb89fee5123de4a6b5e" translate="yes" xml:space="preserve">
          <source>The least significant 16 bits of the resulting &lt;code&gt;ULong&lt;/code&gt; value are the same as the bits of this &lt;code&gt;UShort&lt;/code&gt; value, whereas the most significant 48 bits are filled with zeros.</source>
          <target state="translated">得到的 &lt;code&gt;ULong&lt;/code&gt; 值的最低有效16位与此 &lt;code&gt;UShort&lt;/code&gt; 值的位相同，而最高有效的48位用零填充。</target>
        </trans-unit>
        <trans-unit id="b511f5bcb1b166f6a21672ecd3a364142d43ef6e" translate="yes" xml:space="preserve">
          <source>The least significant 32 bits of the resulting &lt;code&gt;Long&lt;/code&gt; value are the same as the bits of this &lt;code&gt;Int&lt;/code&gt; value, whereas the most significant 32 bits are filled with the sign bit of this value.</source>
          <target state="translated">结果 &lt;code&gt;Long&lt;/code&gt; 值的最低有效32位与此 &lt;code&gt;Int&lt;/code&gt; 值的位相同，而最高有效32位则用此值的符号位填充。</target>
        </trans-unit>
        <trans-unit id="8552752324805690a09e930c3347d0b3b76fb45a" translate="yes" xml:space="preserve">
          <source>The least significant 32 bits of the resulting &lt;code&gt;Long&lt;/code&gt; value are the same as the bits of this &lt;code&gt;UInt&lt;/code&gt; value, whereas the most significant 32 bits are filled with zeros.</source>
          <target state="translated">得到的 &lt;code&gt;Long&lt;/code&gt; 值的最低有效32位与此 &lt;code&gt;UInt&lt;/code&gt; 值的位相同，而最高有效32位用零填充。</target>
        </trans-unit>
        <trans-unit id="13513c5d8d4b778bf7d2d02871ec67b342f92eb3" translate="yes" xml:space="preserve">
          <source>The least significant 32 bits of the resulting &lt;code&gt;ULong&lt;/code&gt; value are the same as the bits of this &lt;code&gt;Int&lt;/code&gt; value, whereas the most significant 32 bits are filled with the sign bit of this value.</source>
          <target state="translated">得到的 &lt;code&gt;ULong&lt;/code&gt; 值的最低有效32位与此 &lt;code&gt;Int&lt;/code&gt; 值的位相同，而最高有效32位则用该值的符号位填充。</target>
        </trans-unit>
        <trans-unit id="098196788f072e1b90241673f7cd1c8d4ddc487e" translate="yes" xml:space="preserve">
          <source>The least significant 32 bits of the resulting &lt;code&gt;ULong&lt;/code&gt; value are the same as the bits of this &lt;code&gt;UInt&lt;/code&gt; value, whereas the most significant 32 bits are filled with zeros.</source>
          <target state="translated">得到的 &lt;code&gt;ULong&lt;/code&gt; 值的最低有效32位与此 &lt;code&gt;UInt&lt;/code&gt; 值的位相同，而最高有效32位用零填充。</target>
        </trans-unit>
        <trans-unit id="1e95934eab4e475329950f2eb8e7a3a03516b89c" translate="yes" xml:space="preserve">
          <source>The least significant 8 bits of the resulting &lt;code&gt;Char&lt;/code&gt; code are the same as the bits of this &lt;code&gt;Byte&lt;/code&gt; value, whereas the most significant 8 bits are filled with the sign bit of this value.</source>
          <target state="translated">所得 &lt;code&gt;Char&lt;/code&gt; 代码的最低有效8位与此 &lt;code&gt;Byte&lt;/code&gt; 值的位相同，而最高有效8位用此值的符号位填充。</target>
        </trans-unit>
        <trans-unit id="1ccfa3d5b3f0d4c2cadb8ddee394a5e74b7f3fb0" translate="yes" xml:space="preserve">
          <source>The least significant 8 bits of the resulting &lt;code&gt;Int&lt;/code&gt; value are the same as the bits of this &lt;code&gt;Byte&lt;/code&gt; value, whereas the most significant 24 bits are filled with the sign bit of this value.</source>
          <target state="translated">结果 &lt;code&gt;Int&lt;/code&gt; 值的最低有效8位与此 &lt;code&gt;Byte&lt;/code&gt; 值的位相同，而最高有效的24位则用此值的符号位填充。</target>
        </trans-unit>
        <trans-unit id="682e9bb2df532a75f2a73fb4a8682c3fe53c3f6f" translate="yes" xml:space="preserve">
          <source>The least significant 8 bits of the resulting &lt;code&gt;Int&lt;/code&gt; value are the same as the bits of this &lt;code&gt;UByte&lt;/code&gt; value, whereas the most significant 24 bits are filled with zeros.</source>
          <target state="translated">结果 &lt;code&gt;Int&lt;/code&gt; 值的最低有效8位与此 &lt;code&gt;UByte&lt;/code&gt; 值的位相同，而最高有效的24位用零填充。</target>
        </trans-unit>
        <trans-unit id="740b8988c3d828c3ba10680439510f32d7f08bd4" translate="yes" xml:space="preserve">
          <source>The least significant 8 bits of the resulting &lt;code&gt;Long&lt;/code&gt; value are the same as the bits of this &lt;code&gt;Byte&lt;/code&gt; value, whereas the most significant 56 bits are filled with the sign bit of this value.</source>
          <target state="translated">结果 &lt;code&gt;Long&lt;/code&gt; 值的最低有效8位与此 &lt;code&gt;Byte&lt;/code&gt; 值的位相同，而最高有效56位用此值的符号位填充。</target>
        </trans-unit>
        <trans-unit id="f2986e4bdb9623eb7b0be806904f6c45008e66a1" translate="yes" xml:space="preserve">
          <source>The least significant 8 bits of the resulting &lt;code&gt;Long&lt;/code&gt; value are the same as the bits of this &lt;code&gt;UByte&lt;/code&gt; value, whereas the most significant 56 bits are filled with zeros.</source>
          <target state="translated">结果 &lt;code&gt;Long&lt;/code&gt; 值的最低有效8位与此 &lt;code&gt;UByte&lt;/code&gt; 值的位相同，而最高有效56位用零填充。</target>
        </trans-unit>
        <trans-unit id="da411f42fa8b3bbe7fd6d9ed1a7edbedcead90c8" translate="yes" xml:space="preserve">
          <source>The least significant 8 bits of the resulting &lt;code&gt;Short&lt;/code&gt; value are the same as the bits of this &lt;code&gt;Byte&lt;/code&gt; value, whereas the most significant 8 bits are filled with the sign bit of this value.</source>
          <target state="translated">结果的 &lt;code&gt;Short&lt;/code&gt; 值的最低有效8位与此 &lt;code&gt;Byte&lt;/code&gt; 值的位相同，而最高有效8位则用此值的符号位填充。</target>
        </trans-unit>
        <trans-unit id="dbca88370b969aea0b645fa67d458151bf144ef3" translate="yes" xml:space="preserve">
          <source>The least significant 8 bits of the resulting &lt;code&gt;Short&lt;/code&gt; value are the same as the bits of this &lt;code&gt;UByte&lt;/code&gt; value, whereas the most significant 8 bits are filled with zeros.</source>
          <target state="translated">结果的 &lt;code&gt;Short&lt;/code&gt; 值的最低有效8位与此 &lt;code&gt;UByte&lt;/code&gt; 值的位相同，而最高有效8位用零填充。</target>
        </trans-unit>
        <trans-unit id="0705f7403c9d4340ca48e777c703d467c71d6c8f" translate="yes" xml:space="preserve">
          <source>The least significant 8 bits of the resulting &lt;code&gt;UInt&lt;/code&gt; value are the same as the bits of this &lt;code&gt;Byte&lt;/code&gt; value, whereas the most significant 24 bits are filled with the sign bit of this value.</source>
          <target state="translated">结果 &lt;code&gt;UInt&lt;/code&gt; 值的最低有效8位与该 &lt;code&gt;Byte&lt;/code&gt; 值的位相同，而最高有效的24位用该值的符号位填充。</target>
        </trans-unit>
        <trans-unit id="e35a3b71a791931b3596ab2bd1edb46d9365dda1" translate="yes" xml:space="preserve">
          <source>The least significant 8 bits of the resulting &lt;code&gt;UInt&lt;/code&gt; value are the same as the bits of this &lt;code&gt;UByte&lt;/code&gt; value, whereas the most significant 24 bits are filled with zeros.</source>
          <target state="translated">结果 &lt;code&gt;UInt&lt;/code&gt; 值的最低有效8位与此 &lt;code&gt;UByte&lt;/code&gt; 值的位相同，而最高有效的24位用零填充。</target>
        </trans-unit>
        <trans-unit id="fbe359060636f5088c741be0b327d7d46254bbcd" translate="yes" xml:space="preserve">
          <source>The least significant 8 bits of the resulting &lt;code&gt;ULong&lt;/code&gt; value are the same as the bits of this &lt;code&gt;Byte&lt;/code&gt; value, whereas the most significant 56 bits are filled with the sign bit of this value.</source>
          <target state="translated">得到的 &lt;code&gt;ULong&lt;/code&gt; 值的最低有效8位与该 &lt;code&gt;Byte&lt;/code&gt; 值的位相同，而最高有效56位用该值的符号位填充。</target>
        </trans-unit>
        <trans-unit id="9d9c37d2ab226e9ed58e44937eac9a5c2afe8841" translate="yes" xml:space="preserve">
          <source>The least significant 8 bits of the resulting &lt;code&gt;ULong&lt;/code&gt; value are the same as the bits of this &lt;code&gt;UByte&lt;/code&gt; value, whereas the most significant 56 bits are filled with zeros.</source>
          <target state="translated">得到的 &lt;code&gt;ULong&lt;/code&gt; 值的最低有效8位与此 &lt;code&gt;UByte&lt;/code&gt; 值的位相同，而最高有效56位用零填充。</target>
        </trans-unit>
        <trans-unit id="573a497b93bab09d8947aa89f58fd5f36237628f" translate="yes" xml:space="preserve">
          <source>The least significant 8 bits of the resulting &lt;code&gt;UShort&lt;/code&gt; value are the same as the bits of this &lt;code&gt;Byte&lt;/code&gt; value, whereas the most significant 8 bits are filled with the sign bit of this value.</source>
          <target state="translated">结果 &lt;code&gt;UShort&lt;/code&gt; 值的最低有效8位与此 &lt;code&gt;Byte&lt;/code&gt; 值的位相同，而最高有效的8位则用该值的符号位填充。</target>
        </trans-unit>
        <trans-unit id="d49f6edce25857427bee05e2a6463c8f203f6aab" translate="yes" xml:space="preserve">
          <source>The least significant 8 bits of the resulting &lt;code&gt;UShort&lt;/code&gt; value are the same as the bits of this &lt;code&gt;UByte&lt;/code&gt; value, whereas the most significant 8 bits are filled with zeros.</source>
          <target state="translated">所得的 &lt;code&gt;UShort&lt;/code&gt; 值的最低有效8位与此 &lt;code&gt;UByte&lt;/code&gt; 值的位相同，而最高有效8位用零填充。</target>
        </trans-unit>
        <trans-unit id="1511f8695777128c7450dc6f9cc52fbdbfc512c7" translate="yes" xml:space="preserve">
          <source>The less obvious cases that belong to the &quot;grey area&quot; include handling corner cases differently, throwing an exception of a different type than before, changing behavior observable only through reflection, changes in undocumented/undefined behavior, renaming binary artifacts, etc. Sometimes such changes are very important and affect migration experience dramatically, sometimes they are insignificant.</source>
          <target state="translated">属于 &quot;灰色地带 &quot;的不太明显的情况包括:以不同的方式处理转角情况、抛出与之前不同类型的异常、改变只有通过反射才能观察到的行为、改变未记录/未定义的行为、重命名二进制工件等。有时这样的改变非常重要,会极大地影响迁移体验,有时则微不足道。</target>
        </trans-unit>
        <trans-unit id="dd894256ff253457e13d98fae75ab576481e876c" translate="yes" xml:space="preserve">
          <source>The library format</source>
          <target state="translated">图书馆格式</target>
        </trans-unit>
        <trans-unit id="c48fdef888f67d5a66f513cae58be8d045c058e0" translate="yes" xml:space="preserve">
          <source>The library has been created in the current directory:</source>
          <target state="translated">库已经在当前目录下创建。</target>
        </trans-unit>
        <trans-unit id="cff219119dad603b83453d082db1d0aa5cce3800" translate="yes" xml:space="preserve">
          <source>The lines returned do not include terminating line separators.</source>
          <target state="translated">返回的行数不包括终止行的分隔符。</target>
        </trans-unit>
        <trans-unit id="ecc031fda17a51efc3a0c6e7f3483a236bf69e52" translate="yes" xml:space="preserve">
          <source>The list of immediate supertypes of this class, in the order they are listed in the source code.</source>
          <target state="translated">该类的直属超类型列表,按照源代码中的顺序排列。</target>
        </trans-unit>
        <trans-unit id="e7cfcc4e5ebb2fa63d0c44bdcf02351c03c9e8d4" translate="yes" xml:space="preserve">
          <source>The list of the immediate subclasses if this class is a sealed class, or an empty list otherwise.</source>
          <target state="translated">如果这个类是一个密封的类,则直接子类的列表,否则为空列表。</target>
        </trans-unit>
        <trans-unit id="af028a3423820dfb61266857373312e6321072a9" translate="yes" xml:space="preserve">
          <source>The list of type parameters of this callable.</source>
          <target state="translated">该callable的类型参数列表。</target>
        </trans-unit>
        <trans-unit id="3983145b3c17efebd4ca1c3dd6839e784929aaa8" translate="yes" xml:space="preserve">
          <source>The list of type parameters of this class. This list does &lt;em&gt;not&lt;/em&gt; include type parameters of outer classes.</source>
          <target state="translated">此类的类型参数的列表。这份名单并&lt;em&gt;没有&lt;/em&gt;包括外部类的类型参数。</target>
        </trans-unit>
        <trans-unit id="7dd6f3d5d8e8c83c9d11a7ed45e7362cc872b1a5" translate="yes" xml:space="preserve">
          <source>The locking in this example is fine-grained, so it pays the price. However, it is a good choice for some situations where you absolutely must modify some shared state periodically, but there is no natural thread that this state is confined to.</source>
          <target state="translated">这个例子中的锁是细粒度的,所以它要付出代价。然而,对于某些情况来说,它是一个很好的选择,在这些情况下,你绝对必须周期性地修改一些共享状态,但没有一个自然线程可以限制这个状态。</target>
        </trans-unit>
        <trans-unit id="993a245cc6dcc5a6d2356a7f7d1259d26b6ea137" translate="yes" xml:space="preserve">
          <source>The loop variable(s), if any, must be declared outside of the &lt;code&gt;while&lt;/code&gt; loop, and are therefore available for inspection afterwards, at which point they will contain the value(s) that made the loop condition false.</source>
          <target state="translated">循环变量（如果有）必须在 &lt;code&gt;while&lt;/code&gt; 循环外声明，因此可以在以后检查，此时它们将包含使循环条件为假的值。</target>
        </trans-unit>
        <trans-unit id="f10abe77e5b16e3b7aa73cabd19e9ac919e5868d" translate="yes" xml:space="preserve">
          <source>The main code is straightforward:</source>
          <target state="translated">主代码简单明了。</target>
        </trans-unit>
        <trans-unit id="21b17843ae6bab256e1f2d7c26e40966048480db" translate="yes" xml:space="preserve">
          <source>The main code starts and connects the whole pipeline:</source>
          <target state="translated">主代码启动并连接整个管道。</target>
        </trans-unit>
        <trans-unit id="1415e580114f63d99c0e8622a1104c3c733c68ba" translate="yes" xml:space="preserve">
          <source>The main disadvantage of changing the code style in an existing project is that the blame/annotate VCS feature will point to irrelevant commits more often. While each VCS has some kind of way to deal with this problem (&lt;a href=&quot;https://www.jetbrains.com/help/idea/investigate-changes.html&quot;&gt;&quot;Annotate Previous Revision&quot;&lt;/a&gt; can be used in IntelliJ IDEA), it's important to decide if a new style is worth all the effort. The practice of separating reformatting commits from meaningful changes can help a lot with later investigations.</source>
          <target state="translated">更改现有项目中的代码样式的主要缺点是，怪怪/注释VCS功能将更频繁地指向无关的提交。尽管每个VCS都有某种方法可以解决此问题（IntelliJ IDEA中可以使用&lt;a href=&quot;https://www.jetbrains.com/help/idea/investigate-changes.html&quot;&gt;&amp;ldquo;注释以前的​​修订版&amp;rdquo;&lt;/a&gt;），但重要的是确定新样式是否值得所有努力。将重新格式化提交与有意义的更改分开的做法可为以后的调查提供很大帮助。</target>
        </trans-unit>
        <trans-unit id="f0255c27371bb337a0275ae99c66e66aefbb2cf2" translate="yes" xml:space="preserve">
          <source>The main function just launches a coroutine to print results of &lt;code&gt;switchMapDeferreds&lt;/code&gt; and sends some test data to it:</source>
          <target state="translated">主要功能只是启动协程以打印 &lt;code&gt;switchMapDeferreds&lt;/code&gt; 的结果并将一些测试数据发送给它：</target>
        </trans-unit>
        <trans-unit id="c0a11bc5688f898de97456dfcb543cf05d79b8a1" translate="yes" xml:space="preserve">
          <source>The main thread (that runs the &lt;code&gt;main()&lt;/code&gt; function) must wait until our coroutine completes, otherwise the program ends before &lt;code&gt;Hello&lt;/code&gt; is printed.</source>
          <target state="translated">主线程（运行 &lt;code&gt;main()&lt;/code&gt; 函数）必须等待我们的协程完成，否则程序将在打印 &lt;code&gt;Hello&lt;/code&gt; 之前结束。</target>
        </trans-unit>
        <trans-unit id="2c831066dd6087f2516b15d01bfb68e39b9bcf05" translate="yes" xml:space="preserve">
          <source>The maximum number of substrings to return. Zero by default means no limit is set.</source>
          <target state="translated">要返回的子串的最大数量。默认为零,表示没有设置限制。</target>
        </trans-unit>
        <trans-unit id="4e76f165176d7e28c6b59c285a7ee8af5a71fc72" translate="yes" xml:space="preserve">
          <source>The maximum radix available for conversion to and from strings.</source>
          <target state="translated">字符串转换的最大半径。</target>
        </trans-unit>
        <trans-unit id="38f9246447f2685e9dd36b4c8d7e0bf7ff2fb023" translate="yes" xml:space="preserve">
          <source>The maximum value in the range (inclusive).</source>
          <target state="translated">范围内的最大值(含)。</target>
        </trans-unit>
        <trans-unit id="cc9397547e8b9fc8e2131246f8cce9b80a975147" translate="yes" xml:space="preserve">
          <source>The maximum value of a Unicode code point. Kotlin/Native specific.</source>
          <target state="translated">Unicode码点的最大值。Kotlin/Native特有的。</target>
        </trans-unit>
        <trans-unit id="af496c450bf387c2b7d7ee0dc32c766b9f1b66c1" translate="yes" xml:space="preserve">
          <source>The maximum value of a Unicode high-surrogate code unit.</source>
          <target state="translated">Unicode高代码单位的最大值。</target>
        </trans-unit>
        <trans-unit id="68f9d655dde4db0c3b71fc09c97d0f87e103d52b" translate="yes" xml:space="preserve">
          <source>The maximum value of a Unicode low-surrogate code unit.</source>
          <target state="translated">Unicode低代码单位的最大值。</target>
        </trans-unit>
        <trans-unit id="0cb5887284a08dd04202e0863d133d8ed431392d" translate="yes" xml:space="preserve">
          <source>The maximum value of a Unicode surrogate code unit.</source>
          <target state="translated">Unicode代用码单位的最大值。</target>
        </trans-unit>
        <trans-unit id="ea009c16dc0030623058aff99eec7f7c7973366c" translate="yes" xml:space="preserve">
          <source>The maximum value of a character code unit.</source>
          <target state="translated">一个字符代码单位的最大值。</target>
        </trans-unit>
        <trans-unit id="dce9edb79f3aca5450e6dfb555e231182e2c5340" translate="yes" xml:space="preserve">
          <source>The meaning of a visibility modifier depends on whether it's applied to a top-level declaration or to a declaration inside a class. For top-level declarations:</source>
          <target state="translated">可见性修饰符的含义取决于它是应用于顶层声明还是应用于类中的声明。对于顶层声明。</target>
        </trans-unit>
        <trans-unit id="2f5715d8d7aab68289e0b8a47e46f1764f30f76e" translate="yes" xml:space="preserve">
          <source>The message explaining the deprecation and recommending an alternative API to use.</source>
          <target state="translated">解释弃用的信息,并推荐使用其他API。</target>
        </trans-unit>
        <trans-unit id="1d7af1b2ed876762350f57904a38e801662ebbf4" translate="yes" xml:space="preserve">
          <source>The meta-runner for Kotlin is available on &lt;a href=&quot;https://github.com/jonnyzzz/Kotlin.TeamCity&quot;&gt;GitHub&lt;/a&gt;. If using TeamCity 9 or above, we can now simply import that meta-runner from the TeamCity user interface</source>
          <target state="translated">&lt;a href=&quot;https://github.com/jonnyzzz/Kotlin.TeamCity&quot;&gt;GitHub上&lt;/a&gt;提供了Kotlin的元运行器。如果使用TeamCity 9或更高版本，我们现在可以简单地从TeamCity用户界面导入该元运行器</target>
        </trans-unit>
        <trans-unit id="cbb5d37dc4d790a9dba2a103cd7fc2ea1af9db2f" translate="yes" xml:space="preserve">
          <source>The minimum radix available for conversion to and from strings.</source>
          <target state="translated">可用于转换为字符串和从字符串转换的最小半径。</target>
        </trans-unit>
        <trans-unit id="3eb6b21e0f2a2eb117e5ca90292e6def24614862" translate="yes" xml:space="preserve">
          <source>The minimum value in the range.</source>
          <target state="translated">范围内的最小值。</target>
        </trans-unit>
        <trans-unit id="480df25e783a3ddb0c5eabcc07d40b9a21fd328e" translate="yes" xml:space="preserve">
          <source>The minimum value of a Unicode code point. Kotlin/Native specific.</source>
          <target state="translated">Unicode码点的最小值。Kotlin/Native特有的。</target>
        </trans-unit>
        <trans-unit id="c11b4b4a4cfd50662da801109ced72e7ef8083ad" translate="yes" xml:space="preserve">
          <source>The minimum value of a Unicode high-surrogate code unit.</source>
          <target state="translated">Unicode高代码单位的最小值。</target>
        </trans-unit>
        <trans-unit id="7a57e546e08f3cd66a3ed8cebd57f37a4137a78d" translate="yes" xml:space="preserve">
          <source>The minimum value of a Unicode low-surrogate code unit.</source>
          <target state="translated">Unicode低代码单位的最小值。</target>
        </trans-unit>
        <trans-unit id="47b523f1a39e9c9f7bda17fc85b300ab3e0da311" translate="yes" xml:space="preserve">
          <source>The minimum value of a Unicode surrogate code unit.</source>
          <target state="translated">Unicode代用码单位的最小值。</target>
        </trans-unit>
        <trans-unit id="e3fc4d1ab4988e695801daf57bd33d3f470c3668" translate="yes" xml:space="preserve">
          <source>The minimum value of a character code unit.</source>
          <target state="translated">一个字符代码单位的最小值。</target>
        </trans-unit>
        <trans-unit id="d80a9d6c0ddeb1216ece2df4cc2d7d63382408e4" translate="yes" xml:space="preserve">
          <source>The minimum value of a supplementary code point, &lt;code&gt;\u0x10000&lt;/code&gt;. Kotlin/Native specific.</source>
          <target state="translated">补充代码点的最小值 &lt;code&gt;\u0x10000&lt;/code&gt; 。Kotlin /本机特定。</target>
        </trans-unit>
        <trans-unit id="39042f06ab046e1bfc15de4ecf52d5a28eec3294" translate="yes" xml:space="preserve">
          <source>The modifier can be used on &lt;code&gt;var&lt;/code&gt; properties declared inside the body of a class (not in the primary constructor, and only when the property does not have a custom getter or setter) and, since Kotlin 1.2, for top-level properties and local variables. The type of the property or variable must be non-null, and it must not be a primitive type.</source>
          <target state="translated">修饰符可用于在类主体内声明的 &lt;code&gt;var&lt;/code&gt; 属性（不适用于主构造函数，并且仅在该属性没有自定义getter或setter时），并且自Kotlin 1.2起，用于顶级属性和局部变量。属性或变量的类型必须为非null，并且不能为原始类型。</target>
        </trans-unit>
        <trans-unit id="bb919d11f95900a1425b0a32e4257389d1fc669f" translate="yes" xml:space="preserve">
          <source>The most &quot;natural&quot; placement is in the object &lt;code&gt;nativeHeap&lt;/code&gt;. It corresponds to allocating native memory with &lt;code&gt;malloc&lt;/code&gt; and provides an additional &lt;code&gt;.free()&lt;/code&gt; operation to free allocated memory:</source>
          <target state="translated">最&amp;ldquo;自然&amp;rdquo;的放置在对象 &lt;code&gt;nativeHeap&lt;/code&gt; 中。它对应于使用 &lt;code&gt;malloc&lt;/code&gt; 分配本机内存，并提供了附加的 &lt;code&gt;.free()&lt;/code&gt; 操作来释放已分配的内存：</target>
        </trans-unit>
        <trans-unit id="0d14eba091c54d0c22e0562741651e98077e032c" translate="yes" xml:space="preserve">
          <source>The most basic reflection feature is getting the runtime reference to a Kotlin class. To obtain the reference to a statically known Kotlin class, you can use the &lt;em&gt;class literal&lt;/em&gt; syntax:</source>
          <target state="translated">最基本的反射功能是获取对Kotlin类的运行时引用。要获取对静态已知的Kotlin类的引用，可以使用&lt;em&gt;类文字&lt;/em&gt;语法：</target>
        </trans-unit>
        <trans-unit id="ae0dbb4ff6b4fc6cc9b694111494978916ff6daf" translate="yes" xml:space="preserve">
          <source>The most basic usage of enum classes is implementing type-safe enums:</source>
          <target state="translated">枚举类最基本的用法是实现类型安全的枚举。</target>
        </trans-unit>
        <trans-unit id="564a165b2993e039b868e117559d08b7cdc98e88" translate="yes" xml:space="preserve">
          <source>The most common kind of properties simply reads from (and maybe writes to) a backing field. On the other hand, with custom getters and setters one can implement any behaviour of a property. Somewhere in between, there are certain common patterns of how a property may work. A few examples: lazy values, reading from a map by a given key, accessing a database, notifying listener on access, etc.</source>
          <target state="translated">最常见的属性只是简单地从一个后备字段读取(也许还可以写入)。另一方面,通过自定义的getter和setter,可以实现属性的任何行为。在这两者之间,有一些常见的属性工作模式。几个例子:懒惰值、通过给定的键从地图中读取、访问数据库、在访问时通知监听器等等。</target>
        </trans-unit>
        <trans-unit id="d5cbdfb8e81de653dd867a75b87523ff1d242141" translate="yes" xml:space="preserve">
          <source>The most common type of constraint is an &lt;strong&gt;upper bound&lt;/strong&gt; that corresponds to Java's &lt;em&gt;extends&lt;/em&gt; keyword:</source>
          <target state="translated">最常见的约束类型是与Java的&lt;em&gt;extends&lt;/em&gt;关键字相对应的&lt;strong&gt;上限&lt;/strong&gt;：&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="368d747cfcb5fb4e353c85a7469dfacbb5453495" translate="yes" xml:space="preserve">
          <source>The most common way to create a collection is with the standard library functions &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/list-of&quot;&gt;&lt;code&gt;listOf&amp;lt;T&amp;gt;()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/set-of&quot;&gt;&lt;code&gt;setOf&amp;lt;T&amp;gt;()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/mutable-list-of&quot;&gt;&lt;code&gt;mutableListOf&amp;lt;T&amp;gt;()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/mutable-set-of&quot;&gt;&lt;code&gt;mutableSetOf&amp;lt;T&amp;gt;()&lt;/code&gt;&lt;/a&gt;. If you provide a comma-separated list of collection elements as arguments, the compiler detects the element type automatically. When creating empty collections, specify the type explicitly.</source>
          <target state="translated">创建集合的最常见方法是使用标准库函数&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/list-of&quot;&gt; &lt;code&gt;listOf&amp;lt;T&amp;gt;()&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/set-of&quot;&gt; &lt;code&gt;setOf&amp;lt;T&amp;gt;()&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/mutable-list-of&quot;&gt; &lt;code&gt;mutableListOf&amp;lt;T&amp;gt;()&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/mutable-set-of&quot;&gt; &lt;code&gt;mutableSetOf&amp;lt;T&amp;gt;()&lt;/code&gt; &lt;/a&gt;。如果提供逗号分隔的集合元素列表作为参数，则编译器将自动检测元素类型。创建空集合时，请明确指定类型。</target>
        </trans-unit>
        <trans-unit id="b853cf446ccffab0ecfd031a6ec9cd9f7555703c" translate="yes" xml:space="preserve">
          <source>The most notable change is in the continuation indentation policy. There's a nice idea to use the double indent for showing that a multi-line expression hasn't ended on the previous line. This is a very simple and general rule, but several Kotlin constructions look a bit awkward when they are formatted this way. In Kotlin Coding Conventions it's recommended to use a single indent in cases where the long continuation indent has been forced before</source>
          <target state="translated">最显著的变化是延续缩进政策。有一个很好的想法,就是使用双缩进来显示多行表达式没有在前一行结束。这是一个非常简单和通用的规则,但有几个Kotlin结构在采用这种格式时看起来有点尴尬。在 Kotlin 编码规范中,建议在长的延续缩进之前被强制缩进的情况下,使用单缩进。</target>
        </trans-unit>
        <trans-unit id="e8c58687aab400a3400843ec6513c56c72bdb694" translate="yes" xml:space="preserve">
          <source>The most obvious practical reason to cancel execution of a coroutine is because its execution time has exceeded some timeout. While you can manually track the reference to the corresponding &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/index.html&quot;&gt;Job&lt;/a&gt; and launch a separate coroutine to cancel the tracked one after delay, there is a ready to use &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/with-timeout.html&quot;&gt;withTimeout&lt;/a&gt; function that does it. Look at the following example:</source>
          <target state="translated">取消协程执行的最明显的实际原因是因为协程的执行时间已超过某个超时。虽然您可以手动跟踪对相应&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/index.html&quot;&gt;Job&lt;/a&gt;的引用并启动一个单独的协程以在延迟后取消所跟踪的协程，但是可以使用&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/with-timeout.html&quot;&gt;withTimeout&lt;/a&gt;函数来执行此操作。看下面的例子：</target>
        </trans-unit>
        <trans-unit id="d08f23af81c5dad7c4dca8d8027b602b0ab864b4" translate="yes" xml:space="preserve">
          <source>The most peculiar feature of &lt;code&gt;dynamic&lt;/code&gt; is that we are allowed to call &lt;strong&gt;any&lt;/strong&gt; property or function with any parameters on a &lt;code&gt;dynamic&lt;/code&gt; variable:</source>
          <target state="translated">&lt;code&gt;dynamic&lt;/code&gt; 的最独特的功能是允许我们使用 &lt;code&gt;dynamic&lt;/code&gt; 变量上的任何参数调用&lt;strong&gt;任何&lt;/strong&gt;属性或函数：</target>
        </trans-unit>
        <trans-unit id="3c05df95cb8e9db1a4f2601246ac944d5c8bd276" translate="yes" xml:space="preserve">
          <source>The multiplatform projects and multiplatform libraries are discussed in the &lt;a href=&quot;../../reference/multiplatform&quot;&gt;documentation&lt;/a&gt; too.</source>
          <target state="translated">&lt;a href=&quot;../../reference/multiplatform&quot;&gt;文档中&lt;/a&gt;还讨论了多平台项目和多平台库。</target>
        </trans-unit>
        <trans-unit id="6595e5fe1547363b463835d421622aad398ae9cc" translate="yes" xml:space="preserve">
          <source>The name contains the following parts (some of them may be empty):</source>
          <target state="translated">该名称包含以下部分(其中一些可能是空的):</target>
        </trans-unit>
        <trans-unit id="705b141c8de1d697224950845ea5a1b7afb58d54" translate="yes" xml:space="preserve">
          <source>The name of a class is usually a noun or a noun phrase explaining what the class &lt;em&gt;is&lt;/em&gt;: &lt;code&gt;List&lt;/code&gt;, &lt;code&gt;PersonReader&lt;/code&gt;.</source>
          <target state="translated">一个类的名称通常是一个名词或名词短语，用以解释该类&lt;em&gt;是&lt;/em&gt;什么： &lt;code&gt;List&lt;/code&gt; ， &lt;code&gt;PersonReader&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2218455df585d83e3681475aae4631f54b57ae59" translate="yes" xml:space="preserve">
          <source>The name of a class used by itself (not as a qualifier to another name) acts as a reference to the companion object of the class (whether named or not):</source>
          <target state="translated">一个类的名字本身使用(不是作为另一个名字的限定词),作为对该类的同伴对象(无论是否命名)的引用。</target>
        </trans-unit>
        <trans-unit id="07fe46086dbe239fd375c49037bb37bff00ee0c4" translate="yes" xml:space="preserve">
          <source>The name of a method is usually a verb or a verb phrase saying what the method &lt;em&gt;does&lt;/em&gt;: &lt;code&gt;close&lt;/code&gt;, &lt;code&gt;readPersons&lt;/code&gt;. The name should also suggest if the method is mutating the object or returning a new one. For instance &lt;code&gt;sort&lt;/code&gt; is sorting a collection in place, while &lt;code&gt;sorted&lt;/code&gt; is returning a sorted copy of the collection.</source>
          <target state="translated">方法的名称通常是动词或动词短语，表示方法的&lt;em&gt;作用&lt;/em&gt;： &lt;code&gt;close&lt;/code&gt; ， &lt;code&gt;readPersons&lt;/code&gt; 。该名称还应该建议该方法是在改变对象还是返回一个新对象。例如 &lt;code&gt;sort&lt;/code&gt; 是对集合进行 &lt;code&gt;sorted&lt;/code&gt; ，而sorted返回集合的排序副本。</target>
        </trans-unit>
        <trans-unit id="07c434a5d635392f2cc52f562338d62b0cd9ae9a" translate="yes" xml:space="preserve">
          <source>The name of the companion object can be omitted, in which case the name &lt;code&gt;Companion&lt;/code&gt; will be used:</source>
          <target state="translated">可以省略伴随对象的名称，在这种情况下，将使用名称 &lt;code&gt;Companion&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="ba35193d0490ae1490a81583acf93693abaa382e" translate="yes" xml:space="preserve">
          <source>The name of the file should describe what the code in the file does. Therefore, you should avoid using meaningless words such as &quot;Util&quot; in file names.</source>
          <target state="translated">文件的名称应该描述文件中的代码的作用。因此,你应该避免在文件名中使用 &quot;Util &quot;等无意义的词语。</target>
        </trans-unit>
        <trans-unit id="3aecf5d5ce4130f99667312567cec868e0f727ee" translate="yes" xml:space="preserve">
          <source>The name of the generated Java class can be changed using the &lt;code&gt;@JvmName&lt;/code&gt; annotation:</source>
          <target state="translated">可以使用 &lt;code&gt;@JvmName&lt;/code&gt; 批注来更改生成的Java类的名称：</target>
        </trans-unit>
        <trans-unit id="c5f1bfd2676f7023c48bd8f681608f158236c940" translate="yes" xml:space="preserve">
          <source>The name of the target (if specified) or the project</source>
          <target state="translated">目标名称(如果指定)或项目名称</target>
        </trans-unit>
        <trans-unit id="cbba3c187c456ab45b79f8154b1183097b8b2546" translate="yes" xml:space="preserve">
          <source>The name of this callable as it was declared in the source code. If the callable has no name, a special invented name is created. Nameless callables include:</source>
          <target state="translated">这个可调用的名称,因为它是在源代码中声明的。如果该可调用项没有名称,则会创建一个特殊的发明名称。无名可调用包括:</target>
        </trans-unit>
        <trans-unit id="688bb052b4a717479ab8663cafb721fc37d4378a" translate="yes" xml:space="preserve">
          <source>The name of this type parameter as it was declared in the source code.</source>
          <target state="translated">源代码中声明的该类型参数的名称。</target>
        </trans-unit>
        <trans-unit id="25f073ea1bd96da303a6eb4e8f3418d2fb774887" translate="yes" xml:space="preserve">
          <source>The names of Kotlin classes and interfaces are prefixed when imported to Objective-C. The prefix is derived from the framework name.</source>
          <target state="translated">Kotlin类和接口的名称在导入到Objective-C时是有前缀的。这个前缀是由框架名称衍生出来的。</target>
        </trans-unit>
        <trans-unit id="69675486a4053839ac9b38d8b7b0c3ec7c01c08b" translate="yes" xml:space="preserve">
          <source>The names of the tasks in Android Projects contain the &lt;a href=&quot;https://developer.android.com/studio/build/build-variants.html&quot;&gt;build variant&lt;/a&gt; names and follow the pattern &lt;code&gt;compile&amp;lt;BuildVariant&amp;gt;Kotlin&lt;/code&gt;, for example, &lt;code&gt;compileDebugKotlin&lt;/code&gt;, &lt;code&gt;compileReleaseUnitTestKotlin&lt;/code&gt;.</source>
          <target state="translated">Android项目中的任务名称包含&lt;a href=&quot;https://developer.android.com/studio/build/build-variants.html&quot;&gt;构建变体&lt;/a&gt;名称，并遵循模式 &lt;code&gt;compile&amp;lt;BuildVariant&amp;gt;Kotlin&lt;/code&gt; ，例如 &lt;code&gt;compileDebugKotlin&lt;/code&gt; ， &lt;code&gt;compileReleaseUnitTestKotlin&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b01e22b1729a53f5c38e9b03b567bbe208d510c5" translate="yes" xml:space="preserve">
          <source>The names of these tasks were created from the formula: &lt;code&gt;run[Debug|Release]Executable&amp;lt;target name&amp;gt;&lt;/code&gt;, where &lt;code&gt;target name&lt;/code&gt; is the capitalized target name that we specified in the &lt;code&gt;build.gradle.kts&lt;/code&gt;&lt;code&gt;build.gradle&lt;/code&gt; file out of our build, &lt;code&gt;&quot;native&quot;&lt;/code&gt; in our case. Let's run the task in the IDE. For that, let's open the Gradle Tool Window and find the task in the list:</source>
          <target state="translated">这些任务的名称是根据以下公式创建的： &lt;code&gt;run[Debug|Release]Executable&amp;lt;target name&amp;gt;&lt;/code&gt; ，其中 &lt;code&gt;target name&lt;/code&gt; 是我们在 &lt;code&gt;build.gradle.kts&lt;/code&gt; &lt;code&gt;build.gradle&lt;/code&gt; 文件中从构建中指定的大写目标名称，在我们的案例中为 &lt;code&gt;&quot;native&quot;&lt;/code&gt; 。让我们在IDE中运行任务。为此，让我们打开Gradle Tool窗口并在列表中找到任务：</target>
        </trans-unit>
        <trans-unit id="f0aa5ea5557fedda4c5d2598dc5dd22d0363ac01" translate="yes" xml:space="preserve">
          <source>The names should make it clear what the purpose of the entity is, so it's best to avoid using meaningless words (&lt;code&gt;Manager&lt;/code&gt;, &lt;code&gt;Wrapper&lt;/code&gt; etc.) in names.</source>
          <target state="translated">名称应清楚说明实体的用途，因此最好避免在名称中使用无意义的词（ &lt;code&gt;Manager&lt;/code&gt; ， &lt;code&gt;Wrapper&lt;/code&gt; 等）。</target>
        </trans-unit>
        <trans-unit id="73a31785499746e1755c5fd02e03d5e8b58c34d0" translate="yes" xml:space="preserve">
          <source>The native memory can be allocated using the &lt;code&gt;NativePlacement&lt;/code&gt; interface, e.g.</source>
          <target state="translated">可以使用 &lt;code&gt;NativePlacement&lt;/code&gt; 接口来分配本机内存，例如</target>
        </trans-unit>
        <trans-unit id="183994f4ebd6d698ee09d0ba15ca6b6ca68c9e19" translate="yes" xml:space="preserve">
          <source>The next lines are about providing linker and compiler options, which can vary depending on different target platforms. In our case, we are defining it for macOS (the &lt;code&gt;.osx&lt;/code&gt; suffix) and Linux (the &lt;code&gt;.linux&lt;/code&gt; suffix). Parameters without a suffix is also possible (e.g. &lt;code&gt;linkerOpts=&lt;/code&gt;) and will be applied to all platforms.</source>
          <target state="translated">接下来的几行是关于提供链接器和编译器选项的，这些选项可能会因不同的目标平台而异。在我们的例子中，我们定义它为MacOS（在 &lt;code&gt;.osx&lt;/code&gt; 后缀）和Linux（在 &lt;code&gt;.linux&lt;/code&gt; 后缀）。也可以不带后缀的参数（例如， &lt;code&gt;linkerOpts=&lt;/code&gt; ），并将这些参数应用于所有平台。</target>
        </trans-unit>
        <trans-unit id="5a6c6de321d2f0ef15a3d35472d5a5225a93083f" translate="yes" xml:space="preserve">
          <source>The next part of the &lt;code&gt;&amp;lt;Framework&amp;gt;/Headers/Demo.h&lt;/code&gt; contains number type mappings between Kotlin/Native and &lt;code&gt;NSNumber&lt;/code&gt;. We have the base class called &lt;code&gt;DemoNumber&lt;/code&gt; in Objective-C and &lt;code&gt;KotlinNumber&lt;/code&gt; in Swift. It extends &lt;code&gt;NSNumber&lt;/code&gt;. There are also child classes per Kotlin number type:</source>
          <target state="translated">&lt;code&gt;&amp;lt;Framework&amp;gt;/Headers/Demo.h&lt;/code&gt; 的下一部分包含Kotlin / Native和 &lt;code&gt;NSNumber&lt;/code&gt; 之间的数字类型映射。我们有一个叫做基类 &lt;code&gt;DemoNumber&lt;/code&gt; 在Objective-C和 &lt;code&gt;KotlinNumber&lt;/code&gt; 斯威夫特。它扩展了 &lt;code&gt;NSNumber&lt;/code&gt; 。每个Kotlin数字类型也有子类：</target>
        </trans-unit>
        <trans-unit id="cfe4a47831305057cc6388a57b9e77a3a7e3a7a8" translate="yes" xml:space="preserve">
          <source>The next part of the &lt;code&gt;libnative_api.h&lt;/code&gt; file contains definitions of the types that are used in the library:</source>
          <target state="translated">&lt;code&gt;libnative_api.h&lt;/code&gt; 文件的下一部分包含该库中使用的类型的定义：</target>
        </trans-unit>
        <trans-unit id="dc72aec2231c401cec520bbf86ad2595019584f0" translate="yes" xml:space="preserve">
          <source>The next step is going to prompt us on the Kotlin runtime library. By default the plugin selects the one that is associated to the currently installed version. Unless we want to create a different one, we can click Finish at this point after entering the project name and location.</source>
          <target state="translated">下一步会提示我们选择Kotlin运行时库。默认情况下,插件会选择与当前安装的版本相关联的那个库。除非我们想创建一个不同的,否则我们可以在此时输入项目名称和位置后点击完成。</target>
        </trans-unit>
        <trans-unit id="93716c2cabdff509bf9835ed635452819990ca4f" translate="yes" xml:space="preserve">
          <source>The next step is to call a C function pointer from a C pointer that we have from the &lt;code&gt;supply_fun()&lt;/code&gt; call:</source>
          <target state="translated">下一步是从 &lt;code&gt;supply_fun()&lt;/code&gt; 调用中的C指针中调用C函数指针：</target>
        </trans-unit>
        <trans-unit id="4c075c67c98b72698b50bde83417679cfcaad540" translate="yes" xml:space="preserve">
          <source>The next step is to compile our application. We already covered the basics of compiling a Kotlin/Native application from the command line in the &lt;a href=&quot;basic-kotlin-native-app&quot;&gt;A Basic Kotlin/Native application&lt;/a&gt; tutorial. The only difference in this case is that the &lt;code&gt;cinterop&lt;/code&gt; generated part is implicitly included into the build: Let's call the following command:</source>
          <target state="translated">下一步是编译我们的应用程序。我们已经在&lt;a href=&quot;basic-kotlin-native-app&quot;&gt;A Basic Kotlin / Native应用程序&lt;/a&gt;教程的命令行中介绍了编译Kotlin / Native应用程序的基础知识。在这种情况下，唯一的区别是 &lt;code&gt;cinterop&lt;/code&gt; 生成的部分隐式包含在构建中：让我们调用以下命令：</target>
        </trans-unit>
        <trans-unit id="29eb1a88978e11cb19e6153185329a8fdd184b9c" translate="yes" xml:space="preserve">
          <source>The next step is to create Greeting Data class that has two properties: &lt;em&gt;id&lt;/em&gt; and a &lt;em&gt;content&lt;/em&gt;</source>
          <target state="translated">下一步是创建具有两个属性的Greeting Data类：&lt;em&gt;id&lt;/em&gt;和&lt;em&gt;content&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f2ba2b214cfaccb2ec50010bfe1a0d121ee2cd4b" translate="yes" xml:space="preserve">
          <source>The next step is to create a Run Configuration in IntelliJ IDEA under Tomcat / Local which deploys the WAR and starts up Tomcat.</source>
          <target state="translated">下一步是在Tomcat/Local下的IntelliJ IDEA中创建一个运行配置,部署WAR并启动Tomcat。</target>
        </trans-unit>
        <trans-unit id="27ce517e143c3dea9eb55849f860e4c5596ec3f9" translate="yes" xml:space="preserve">
          <source>The next step is to decide which modules to configure (if the project has more than one module) and whether you want to add the runtime library to the project or use those provided by the current Kotlin plugin.</source>
          <target state="translated">下一步是决定要配置哪些模块(如果项目有多个模块的话),以及是将运行时库添加到项目中,还是使用当前Kotlin插件提供的模块。</target>
        </trans-unit>
        <trans-unit id="22779d3ccc120e4892af96a829245aa095780550" translate="yes" xml:space="preserve">
          <source>The non-abstract subclasses should represent the (complete) C data type and thus specify size and alignment. Each such subclass must have a companion object which is a &lt;a href=&quot;-type/index&quot;&gt;Type&lt;/a&gt;.</source>
          <target state="translated">非抽象子类应表示（完整的）C数据类型，从而指定大小和对齐方式。每个此类子类都必须具有一个&lt;a href=&quot;-type/index&quot;&gt;Type&lt;/a&gt;伴随对象。</target>
        </trans-unit>
        <trans-unit id="fc28129df689ae65c9fd83a31b9aa03dac9e8ced" translate="yes" xml:space="preserve">
          <source>The non-breaking space character</source>
          <target state="translated">不断裂的空间特征</target>
        </trans-unit>
        <trans-unit id="e8f00eeeaaa301ab094d387f05d45fa33541dead" translate="yes" xml:space="preserve">
          <source>The nullable version &lt;code&gt;Nothing?&lt;/code&gt; will be used by the compiler when something is initialized with null and there is no other type information. In &lt;code&gt;val x = null&lt;/code&gt;, the type of &lt;code&gt;x&lt;/code&gt; will be &lt;code&gt;Nothing?&lt;/code&gt;. This type does not have the &quot;never returns normally&quot; semantics; instead, the compiler knows that the value will always be null.</source>
          <target state="translated">可空版本 &lt;code&gt;Nothing?&lt;/code&gt; 当使用null初始化某些东西并且没有其他类型信息时，编译器将使用。在 &lt;code&gt;val x = null&lt;/code&gt; ，类型 &lt;code&gt;x&lt;/code&gt; 将是 &lt;code&gt;Nothing?&lt;/code&gt; 。此类型不具有&amp;ldquo;从不返回正常&amp;rdquo;语义；相反，编译器知道该值将始终为null。</target>
        </trans-unit>
        <trans-unit id="77363aca1573dd5dba20e28ad666c9c7fd83436a" translate="yes" xml:space="preserve">
          <source>The number is converted to a string and then the string is converted to a &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/math/BigDecimal.html&quot;&gt;BigDecimal&lt;/a&gt;.</source>
          <target state="translated">将数字转换为字符串，然后将字符串转换为&lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/math/BigDecimal.html&quot;&gt;BigDecimal&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="bc9979a04405cfcd09395aa075f56f352dfb5b1c" translate="yes" xml:space="preserve">
          <source>The number of bits used to represent a Char in a binary form.</source>
          <target state="translated">用来表示二进制形式的Char的位数。</target>
        </trans-unit>
        <trans-unit id="a5aabbd23fb87b74097e1ccd4055f0b183ecbf87" translate="yes" xml:space="preserve">
          <source>The number of bits used to represent an instance of Byte in a binary form.</source>
          <target state="translated">用来表示二进制形式的Byte实例的位数。</target>
        </trans-unit>
        <trans-unit id="0f9c3201d4f3bb80740106fd705fe9901bfc9490" translate="yes" xml:space="preserve">
          <source>The number of bits used to represent an instance of Int in a binary form.</source>
          <target state="translated">用来表示二进制形式的Int实例的位数。</target>
        </trans-unit>
        <trans-unit id="881c588a79332a9f90d40c26e737596c51909376" translate="yes" xml:space="preserve">
          <source>The number of bits used to represent an instance of Long in a binary form.</source>
          <target state="translated">用二进制形式表示Long实例的位数。</target>
        </trans-unit>
        <trans-unit id="3a2fa986a400a5de2289aa09e08c447c811e1ab0" translate="yes" xml:space="preserve">
          <source>The number of bits used to represent an instance of Short in a binary form.</source>
          <target state="translated">用来表示二进制形式的Short实例的位数。</target>
        </trans-unit>
        <trans-unit id="b557b6ad22e0d4a32e6ecf5e7c42a83086397f62" translate="yes" xml:space="preserve">
          <source>The number of bits used to represent an instance of UByte in a binary form.</source>
          <target state="translated">用来表示一个二进制形式的UByte实例的位数。</target>
        </trans-unit>
        <trans-unit id="04a46c8fcf471f6f7a2489fd5541b67d79b2dbba" translate="yes" xml:space="preserve">
          <source>The number of bits used to represent an instance of UInt in a binary form.</source>
          <target state="translated">用来表示二进制形式的UInt实例的位数。</target>
        </trans-unit>
        <trans-unit id="970f51f6cf41ca82dcda9c5384dd1584581a3241" translate="yes" xml:space="preserve">
          <source>The number of bits used to represent an instance of ULong in a binary form.</source>
          <target state="translated">用来表示一个二进制形式的ULong实例的位数。</target>
        </trans-unit>
        <trans-unit id="f405dad940dd8a9ba9986616021e6669d81ef332" translate="yes" xml:space="preserve">
          <source>The number of bits used to represent an instance of UShort in a binary form.</source>
          <target state="translated">用来表示二进制形式的UShort实例的位数。</target>
        </trans-unit>
        <trans-unit id="7fca3ee96d6d11e61b4e40ce8aef39bbd3166f00" translate="yes" xml:space="preserve">
          <source>The number of bytes used to represent a Char in a binary form.</source>
          <target state="translated">用来表示二进制形式的Char的字节数。</target>
        </trans-unit>
        <trans-unit id="d455af0205d71a29c80b7797e96f36f72c818b20" translate="yes" xml:space="preserve">
          <source>The number of bytes used to represent an instance of Byte in a binary form.</source>
          <target state="translated">用来表示二进制形式的Byte实例的字节数。</target>
        </trans-unit>
        <trans-unit id="012737f61c97912b11277e0542ab793fcecbd8f6" translate="yes" xml:space="preserve">
          <source>The number of bytes used to represent an instance of Int in a binary form.</source>
          <target state="translated">用来表示二进制形式的Int实例的字节数。</target>
        </trans-unit>
        <trans-unit id="ac50dee558bf2179b63147e5d4abcf881946deb1" translate="yes" xml:space="preserve">
          <source>The number of bytes used to represent an instance of Long in a binary form.</source>
          <target state="translated">用二进制形式表示Long实例的字节数。</target>
        </trans-unit>
        <trans-unit id="d47711ab000d6ab309cdde940a4d6cc83958bbb7" translate="yes" xml:space="preserve">
          <source>The number of bytes used to represent an instance of Short in a binary form.</source>
          <target state="translated">用来表示二进制形式的Short实例的字节数。</target>
        </trans-unit>
        <trans-unit id="5da103d9bfe814cb16e570a63e8fffdec6abede9" translate="yes" xml:space="preserve">
          <source>The number of bytes used to represent an instance of UByte in a binary form.</source>
          <target state="translated">用来表示二进制形式的UByte实例的字节数。</target>
        </trans-unit>
        <trans-unit id="7aa018571731f4dfc20dc2f2b40bc661649fe4df" translate="yes" xml:space="preserve">
          <source>The number of bytes used to represent an instance of UInt in a binary form.</source>
          <target state="translated">用来表示二进制形式的UInt实例的字节数。</target>
        </trans-unit>
        <trans-unit id="c4d88684784d0b5692fee9bc8fbbdcbfde1bb159" translate="yes" xml:space="preserve">
          <source>The number of bytes used to represent an instance of ULong in a binary form.</source>
          <target state="translated">用来表示一个二进制形式的ULong实例的字节数。</target>
        </trans-unit>
        <trans-unit id="de97fd8a16a598b6d753acf6fc495d892600d39e" translate="yes" xml:space="preserve">
          <source>The number of bytes used to represent an instance of UShort in a binary form.</source>
          <target state="translated">用来表示二进制形式的UShort实例的字节数。</target>
        </trans-unit>
        <trans-unit id="802421b7bac6f95ce971296bce66f238a1ca7ee6" translate="yes" xml:space="preserve">
          <source>The official docs also have a very cool example with a &lt;a href=&quot;../../reference/type-safe-builders&quot;&gt; DSL for constructing HTML documents&lt;/a&gt;.</source>
          <target state="translated">官方文档中还有一个非常酷的示例，其中包含&lt;a href=&quot;../../reference/type-safe-builders&quot;&gt;用于构造HTML文档&lt;/a&gt;的DSL。</target>
        </trans-unit>
        <trans-unit id="9824ffa4fbac1aa2ba4df2857cc7d27ae42fbdf3" translate="yes" xml:space="preserve">
          <source>The only target for which it is not available is &lt;a href=&quot;https://en.wikipedia.org/wiki/WebAssembly&quot;&gt;WebAssembly&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://en.wikipedia.org/wiki/WebAssembly&quot;&gt;WebAssembly&lt;/a&gt;是唯一无法使用的目标。</target>
        </trans-unit>
        <trans-unit id="20601b96604d0e7211b7510d021f94ac0577f4a7" translate="yes" xml:space="preserve">
          <source>The only thing left to do is compile our application (Build|Build Project), and once the JavaScript files have been generated, we can open the &lt;code&gt;index.html&lt;/code&gt; file in the browser and see the result in the console debug window.</source>
          <target state="translated">剩下要做的就是编译我们的应用程序（Build | Build Project），并且一旦生成了JavaScript文件，我们就可以在浏览器中打开 &lt;code&gt;index.html&lt;/code&gt; 文件，并在控制台调试窗口中查看结果。</target>
        </trans-unit>
        <trans-unit id="940b1bdb9d47159d1535cf808141916fc2b5f10e" translate="yes" xml:space="preserve">
          <source>The operation doesn't preserve copied file attributes such as creation/modification date, permissions, etc.</source>
          <target state="translated">该操作不保留复制的文件属性,如创建/修改日期、权限等。</target>
        </trans-unit>
        <trans-unit id="b9a452f893e9486c5fbe89e3c1a52b0da8c35684" translate="yes" xml:space="preserve">
          <source>The operation is &lt;em&gt;intermediate&lt;/em&gt; and &lt;em&gt;stateful&lt;/em&gt;.</source>
          <target state="translated">操作&lt;em&gt;中间&lt;/em&gt;和&lt;em&gt;有状态&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="64f2d6f436a63697c12d9826dd0b449a2c8ece4d" translate="yes" xml:space="preserve">
          <source>The operation is &lt;em&gt;intermediate&lt;/em&gt; and &lt;em&gt;stateless&lt;/em&gt;.</source>
          <target state="translated">该操作是&lt;em&gt;中间&lt;/em&gt;且&lt;em&gt;无状态的&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="2f74c9f051d5d0a5178895ef9787aac4f50f4820" translate="yes" xml:space="preserve">
          <source>The operation is &lt;em&gt;intermediate&lt;/em&gt; for this sequence and &lt;em&gt;terminal&lt;/em&gt; and &lt;em&gt;stateful&lt;/em&gt; for the &lt;a href=&quot;minus#kotlin.sequences%24minus%28kotlin.sequences.Sequence%28%28kotlin.sequences.minus.T%29%29%2C+kotlin.sequences.Sequence%28%28kotlin.sequences.minus.T%29%29%29%2Felements&quot;&gt;elements&lt;/a&gt; sequence.</source>
          <target state="translated">操作是&lt;em&gt;中间&lt;/em&gt;此序列和&lt;em&gt;终端&lt;/em&gt;和&lt;em&gt;有状态&lt;/em&gt;的&lt;a href=&quot;minus#kotlin.sequences%24minus%28kotlin.sequences.Sequence%28%28kotlin.sequences.minus.T%29%29%2C+kotlin.sequences.Sequence%28%28kotlin.sequences.minus.T%29%29%29%2Felements&quot;&gt;元素&lt;/a&gt;序列。</target>
        </trans-unit>
        <trans-unit id="f90173c5f7dc2e732f31878b5387f1009c2ad309" translate="yes" xml:space="preserve">
          <source>The operation is &lt;em&gt;terminal&lt;/em&gt;.</source>
          <target state="translated">操作是&lt;em&gt;终端&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="24cec715dc71cea63c8c77aa342afd935860c2d6" translate="yes" xml:space="preserve">
          <source>The operations on floating point numbers discussed in this section are:</source>
          <target state="translated">本节讨论的浮点数的操作有:。</target>
        </trans-unit>
        <trans-unit id="c81054e9fa59c990a7f0009d1471af7d0d80d085" translate="yes" xml:space="preserve">
          <source>The operator &lt;code&gt;plus&lt;/code&gt; provides a way to add key-value pair(s) to a read-only map producing a new map, however there was not a simple way to do the opposite: to remove a key from the map you have to resort to less straightforward ways to like &lt;code&gt;Map.filter()&lt;/code&gt; or &lt;code&gt;Map.filterKeys()&lt;/code&gt;. Now the operator &lt;code&gt;minus&lt;/code&gt; fills this gap. There are 4 overloads available: for removing a single key, a collection of keys, a sequence of keys and an array of keys.</source>
          <target state="translated">运算符 &lt;code&gt;plus&lt;/code&gt; 提供了一种将键值对添加到生成新图的只读图的方法，但是，没有相反的简单方法：从图上删除键不太喜欢 &lt;code&gt;Map.filter()&lt;/code&gt; 或 &lt;code&gt;Map.filterKeys()&lt;/code&gt; 的简单方法。现在，操作员 &lt;code&gt;minus&lt;/code&gt; 填补了这个空白。有4种重载可用：用于删除单个键，键集合，键序列和键数组。</target>
        </trans-unit>
        <trans-unit id="a3dfe13bda3af06c0e25457985a11e6db0a3ea90" translate="yes" xml:space="preserve">
          <source>The order of elements is an important aspect of certain collection types. For example, two lists of the same elements are not equal if their elements are ordered differently.</source>
          <target state="translated">元素的顺序是某些集合类型的一个重要方面。例如,由相同元素组成的两个列表,如果其元素的顺序不同,则不相等。</target>
        </trans-unit>
        <trans-unit id="97cb339b9434116a61ea466562966c5cfa7e6e7a" translate="yes" xml:space="preserve">
          <source>The order of operations execution is different as well: &lt;code&gt;Sequence&lt;/code&gt; performs all the processing steps one-by-one for every single element. In turn, &lt;code&gt;Iterable&lt;/code&gt; completes each step for the whole collection and then proceeds to the next step.</source>
          <target state="translated">操作执行的顺序也不同： &lt;code&gt;Sequence&lt;/code&gt; 对每个元素逐一执行所有处理步骤。反过来， &lt;code&gt;Iterable&lt;/code&gt; 完成整个集合的每个步骤，然后进行下一步。</target>
        </trans-unit>
        <trans-unit id="b74ff8ee45b0b8f3cea227a5cb8b0ca2512e0fa1" translate="yes" xml:space="preserve">
          <source>The output is:</source>
          <target state="translated">产出是:</target>
        </trans-unit>
        <trans-unit id="21b2e4b0974b9e68e9c52fc5e687c75f3f109501" translate="yes" xml:space="preserve">
          <source>The output it produces with &lt;code&gt;-Dkotlinx.coroutines.debug&lt;/code&gt; JVM option is similar to:</source>
          <target state="translated">它使用 &lt;code&gt;-Dkotlinx.coroutines.debug&lt;/code&gt; JVM选项生成的输出类似于：</target>
        </trans-unit>
        <trans-unit id="335f16bba6cd2578184d6190d9013ac4ec39e185" translate="yes" xml:space="preserve">
          <source>The output of a config script with &lt;code&gt;--libs&lt;/code&gt; will be passed as a &lt;code&gt;-linkedArgs&lt;/code&gt;&lt;code&gt;kotlinc&lt;/code&gt; flag value (quoted) when compiling.</source>
          <target state="translated">带有 &lt;code&gt;--libs&lt;/code&gt; 的配置脚本的输出将在编译时作为 &lt;code&gt;-linkedArgs&lt;/code&gt; &lt;code&gt;kotlinc&lt;/code&gt; 标志值（引用）传递。</target>
        </trans-unit>
        <trans-unit id="a335f7db5ad6c9bad17c284454dcaeefbd6be278" translate="yes" xml:space="preserve">
          <source>The output of this code is (with &lt;a href=&quot;https://github.com/Kotlin/kotlinx.coroutines/blob/master/docs/coroutine-context-and-dispatchers.md#debugging-coroutines-and-threads&quot;&gt;debug&lt;/a&gt;):</source>
          <target state="translated">此代码的输出是（带&lt;a href=&quot;https://github.com/Kotlin/kotlinx.coroutines/blob/master/docs/coroutine-context-and-dispatchers.md#debugging-coroutines-and-threads&quot;&gt;debug&lt;/a&gt;）：</target>
        </trans-unit>
        <trans-unit id="d91d0dd8fa3a619861392f5c074fea2d8db4eaf2" translate="yes" xml:space="preserve">
          <source>The output of this code is:</source>
          <target state="translated">该代码的输出是:</target>
        </trans-unit>
        <trans-unit id="647a971dfd3700d13cfdc057be9aa0bc71494501" translate="yes" xml:space="preserve">
          <source>The output of this code shows that the &lt;code&gt;filter()&lt;/code&gt; and &lt;code&gt;map()&lt;/code&gt; functions are called only when building the result list. So, you first see the line of text &lt;code&gt;&amp;ldquo;Lengths of..&amp;rdquo;&lt;/code&gt; and then the sequence processing starts. Note that for elements left after filtering, the map executes before filtering the next element. When the result size reaches 4, the processing stops because it's the largest possible size that &lt;code&gt;take(4)&lt;/code&gt; can return.</source>
          <target state="translated">此代码的输出显示仅在构建结果列表时才调用 &lt;code&gt;filter()&lt;/code&gt; 和 &lt;code&gt;map()&lt;/code&gt; 函数。因此，您首先看到文本行 &lt;code&gt;&amp;ldquo;Lengths of..&amp;rdquo;&lt;/code&gt; ，然后开始进行序列处理。请注意，对于过滤后剩余的元素，映射将在过滤下一个元素之前执行。当结果大小达到4时，处理将停止，因为它是 &lt;code&gt;take(4)&lt;/code&gt; 可以返回的最大大小。</target>
        </trans-unit>
        <trans-unit id="4914ca42a65eab132541007ef394cf246de086f7" translate="yes" xml:space="preserve">
          <source>The output of this code with &lt;code&gt;-Dkotlinx.coroutines.debug&lt;/code&gt; JVM option is:</source>
          <target state="translated">使用 &lt;code&gt;-Dkotlinx.coroutines.debug&lt;/code&gt; JVM选项的此代码的输出为：</target>
        </trans-unit>
        <trans-unit id="fdcf4102afb246d995583e41d5abf443dc9b24d6" translate="yes" xml:space="preserve">
          <source>The output of this example is:</source>
          <target state="translated">这个例子的输出是:</target>
        </trans-unit>
        <trans-unit id="d7f56deac4aeaab1be47a9075fd39d0cd515a13f" translate="yes" xml:space="preserve">
          <source>The output of this is a blank page that prints &lt;code&gt;Hello JavaScript!&lt;/code&gt; to the console.</source>
          <target state="translated">输出为空白页，其中打印 &lt;code&gt;Hello JavaScript!&lt;/code&gt; 到控制台。</target>
        </trans-unit>
        <trans-unit id="c7adcbeb9a00e6f9f8d55d348527ceb949cebeb0" translate="yes" xml:space="preserve">
          <source>The output should be:</source>
          <target state="translated">输出应该是:</target>
        </trans-unit>
        <trans-unit id="0b8e02788f842ec131e59334f158260f8f72ffc7" translate="yes" xml:space="preserve">
          <source>The output will be similar to the the following one, albeit the processor ids that receive each specific integer may be different:</source>
          <target state="translated">尽管接收每个特定整数的处理器ID可能不同,但输出将与下面的类似。</target>
        </trans-unit>
        <trans-unit id="b56500d82b30990e46ae5220b62e1c3f4e225003" translate="yes" xml:space="preserve">
          <source>The overriding constructor must have the same parameter names and types as the overridden one.</source>
          <target state="translated">覆盖的构造函数必须与被覆盖的构造函数具有相同的参数名称和类型。</target>
        </trans-unit>
        <trans-unit id="d0fd3de86e4826ba8c7cde26e87523bae54839bc" translate="yes" xml:space="preserve">
          <source>The packages from platform libraries are available by default. No special link flags need to be specified to use them. &lt;code&gt;Kotlin/Native&lt;/code&gt; compiler automatically detects which of the platform libraries have been accessed and automatically links the needed libraries.</source>
          <target state="translated">默认情况下，平台库中的软件包可用。无需指定特殊的链接标志即可使用它们。 &lt;code&gt;Kotlin/Native&lt;/code&gt; 编译器会自动检测已访问了哪些平台库，并自动链接所需的库。</target>
        </trans-unit>
        <trans-unit id="f9eac82235030e7e86a0bff236552f847d9867dd" translate="yes" xml:space="preserve">
          <source>The parameter is declared in a member function and one of the corresponding parameters in the super functions is optional.</source>
          <target state="translated">该参数在成员函数中声明,在超级函数中对应的参数之一是可选的。</target>
        </trans-unit>
        <trans-unit id="1a311c087dc5f415abb270981ad04ec98ba47164" translate="yes" xml:space="preserve">
          <source>The parameter must not &lt;a href=&quot;#variable-number-of-arguments-varargs&quot;&gt;accept variable number of arguments&lt;/a&gt; and must have no &lt;a href=&quot;#default-arguments&quot;&gt;default value&lt;/a&gt;.</source>
          <target state="translated">该参数不能&lt;a href=&quot;#variable-number-of-arguments-varargs&quot;&gt;接受可变数量的参数，&lt;/a&gt;并且必须没有&lt;a href=&quot;#default-arguments&quot;&gt;默认值&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="85604054f8838d2bde0848abdc31a44140b69283" translate="yes" xml:space="preserve">
          <source>The parameter of &lt;code&gt;@JsName&lt;/code&gt; is required to be a constant string literal which is a valid identifier. The compiler will report an error on any attempt to pass non-identifier string to &lt;code&gt;@JsName&lt;/code&gt;. The following example produces a compile-time error:</source>
          <target state="translated">&lt;code&gt;@JsName&lt;/code&gt; 的参数必须是常量字符串文字，它是有效的标识符。尝试将非标识符字符串传递给 &lt;code&gt;@JsName&lt;/code&gt; 时，编译器将报告错误。下面的示例产生一个编译时错误：</target>
        </trans-unit>
        <trans-unit id="d09d94c8171c7316821713755fce66dc3c85e74a" translate="yes" xml:space="preserve">
          <source>The parameter of &lt;code&gt;js&lt;/code&gt; is required to be a string constant. So, the following code is incorrect:</source>
          <target state="translated">&lt;code&gt;js&lt;/code&gt; 的参数必须为字符串常量。因此，以下代码不正确：</target>
        </trans-unit>
        <trans-unit id="64419b25b7715086a3a5cdbe138547b81a0a98a1" translate="yes" xml:space="preserve">
          <source>The parameter type of a function-typed parameter (the user is passing a function that can handle any &lt;code&gt;Fruit&lt;/code&gt;, and it will be given an &lt;code&gt;Apple&lt;/code&gt;)</source>
          <target state="translated">函数类型参数的参数类型（用户正在传递可以处理任何 &lt;code&gt;Fruit&lt;/code&gt; 的函数，并且它将获得 &lt;code&gt;Apple&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="6ef05f581070101fa2afecc255e98671537cdea0" translate="yes" xml:space="preserve">
          <source>The parameters and the return type are specified in the same way as for regular functions, except that the parameter types can be omitted if they can be inferred from context:</source>
          <target state="translated">参数和返回类型的指定方式与普通函数相同,只是如果可以从上下文中推断出参数类型,则可以省略。</target>
        </trans-unit>
        <trans-unit id="d2818a5f4b17e0f3d50df0846a19518863e09067" translate="yes" xml:space="preserve">
          <source>The parameters of &lt;code&gt;provideDelegate&lt;/code&gt; are the same as for &lt;code&gt;getValue&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;provideDelegate&lt;/code&gt; 的参数与 &lt;code&gt;getValue&lt;/code&gt; 相同：</target>
        </trans-unit>
        <trans-unit id="87e2c98795ae2a97eb179a3bb9ccc1f2e2c982d8" translate="yes" xml:space="preserve">
          <source>The passed type must satisfy all conditions of the &lt;code&gt;where&lt;/code&gt; clause simultaneously. In the above example, the &lt;code&gt;T&lt;/code&gt; type must implement &lt;em&gt;both&lt;/em&gt;&lt;code&gt;CharSequence&lt;/code&gt; and &lt;code&gt;Comparable&lt;/code&gt;.</source>
          <target state="translated">传递的类型必须同时满足 &lt;code&gt;where&lt;/code&gt; 子句的所有条件。在上面的例子中， &lt;code&gt;T&lt;/code&gt; 类型必须实现&lt;em&gt;两者&lt;/em&gt; &lt;code&gt;CharSequence&lt;/code&gt; 和 &lt;code&gt;Comparable&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0f70942d020a14104380fd6e7920e316921b42c6" translate="yes" xml:space="preserve">
          <source>The path refers to the default output location that IntelliJ IDEA uses when we compile the application. Below we'll see how to change this.</source>
          <target state="translated">这个路径指的是IntelliJ IDEA在我们编译应用程序时使用的默认输出位置。下面我们就来看看如何改变这个位置。</target>
        </trans-unit>
        <trans-unit id="38dc6771af81ffcbac99f06b8c7fb1ebccf80f9d" translate="yes" xml:space="preserve">
          <source>The pattern string of this regular expression.</source>
          <target state="translated">该正则表达式的模式字符串。</target>
        </trans-unit>
        <trans-unit id="1144f4eed1bc15fed420102b18cb1c4e49c25335" translate="yes" xml:space="preserve">
          <source>The pattern where a coroutine is producing a sequence of elements is quite common. This is a part of &lt;em&gt;producer-consumer&lt;/em&gt; pattern that is often found in concurrent code. You could abstract such a producer into a function that takes channel as its parameter, but this goes contrary to common sense that results must be returned from functions.</source>
          <target state="translated">协程产生一系列元素的模式非常普遍。这是通常在并发代码中发现的&lt;em&gt;生产者-消费者&lt;/em&gt;模式的一部分。您可以将这样的生产者抽象为以channel为参数的函数，但这与必须从函数返回结果的常识相反。</target>
        </trans-unit>
        <trans-unit id="0452bcbdd609690466ea082ea5af90749aa8dcc5" translate="yes" xml:space="preserve">
          <source>The placeholder &lt;code&gt;&amp;lt;...&amp;gt;&lt;/code&gt; should be replaced with one of the plugin names that can be found in further sections.</source>
          <target state="translated">占位符 &lt;code&gt;&amp;lt;...&amp;gt;&lt;/code&gt; 应该替换为可以在后续章节中找到的插件名称之一。</target>
        </trans-unit>
        <trans-unit id="02d885dcfef73f7197c98c6f94fc980ae42855f5" translate="yes" xml:space="preserve">
          <source>The plugin allows you to customize the pom generated for the publication with the &lt;code&gt;pom&lt;/code&gt; code block available for every component:</source>
          <target state="translated">该插件允许您使用每个组件可用的 &lt;code&gt;pom&lt;/code&gt; 代码块来自定义为发布生成的pom：</target>
        </trans-unit>
        <trans-unit id="73896d94724b0c15c533e7832f50fc2c5d439771" translate="yes" xml:space="preserve">
          <source>The plugin allows you to declare dependencies on files and other projects using traditional Gradle's mechanism of configurations. The plugin supports Kotlin multiplatform projects allowing you to declare the &lt;code&gt;expectedBy&lt;/code&gt; dependencies</source>
          <target state="translated">该插件使您可以使用传统的Gradle配置机制声明对文件和其他项目的依赖性。该插件支持科特林多项目让你申报 &lt;code&gt;expectedBy&lt;/code&gt; 依赖</target>
        </trans-unit>
        <trans-unit id="e2b8c11954d8c4f9f34c307b3e3ea0e12583e5af" translate="yes" xml:space="preserve">
          <source>The plugin builds a test executable for all the targets specified for the &lt;code&gt;test&lt;/code&gt; component. If the current host platform is included in this list the test running tasks are also created. To run tests, execute the standard lifecycle &lt;code&gt;check&lt;/code&gt; task:</source>
          <target state="translated">该插件为为 &lt;code&gt;test&lt;/code&gt; 组件指定的所有目标构建测试可执行文件。如果此列表中包含当前主机平台，则还将创建测试运行任务。要运行测试，请执行标准的生命周期 &lt;code&gt;check&lt;/code&gt; 任务：</target>
        </trans-unit>
        <trans-unit id="cbd612ac393a456f8773735c05ddbd5f91419396" translate="yes" xml:space="preserve">
          <source>The plugin creates a compilation task for each combination of the target, output kind, and build type. The tasks have the following naming convention:</source>
          <target state="translated">该插件为目标、输出类型和构建类型的每个组合创建一个编译任务。任务的命名约定如下。</target>
        </trans-unit>
        <trans-unit id="b7797d4ea1281347f08b98f3d1593b5740b623cc" translate="yes" xml:space="preserve">
          <source>The plugin is shipped with a customized version of the &lt;code&gt;kotlinx.serialization&lt;/code&gt; plugin. To use it you don't have to add new buildscript dependencies, just apply the plugins and add a dependency on the serialization library:</source>
          <target state="translated">该插件随附了 &lt;code&gt;kotlinx.serialization&lt;/code&gt; 插件的自定义版本。要使用它，您不必添加新的buildscript依赖项，只需应用插件并在序列化库上添加依赖项即可：</target>
        </trans-unit>
        <trans-unit id="a5b5cad9084adc7ffa681b4e8b7b6b009920bbab" translate="yes" xml:space="preserve">
          <source>The plugin option format is: &lt;code&gt;-P plugin:&amp;lt;plugin id&amp;gt;:&amp;lt;key&amp;gt;=&amp;lt;value&amp;gt;&lt;/code&gt;. Options can be repeated.</source>
          <target state="translated">插件选项格式为 &lt;code&gt;-P plugin:&amp;lt;plugin id&amp;gt;:&amp;lt;key&amp;gt;=&amp;lt;value&amp;gt;&lt;/code&gt; 。选项可以重复。</target>
        </trans-unit>
        <trans-unit id="4b96dd9cca135b083ee411ceef82d46edf74c104" translate="yes" xml:space="preserve">
          <source>The plugin specifies the following annotations: &lt;a href=&quot;http://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/stereotype/Component.html&quot;&gt;&lt;code&gt;@Component&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;http://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/scheduling/annotation/Async.html&quot;&gt;&lt;code&gt;@Async&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;http://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/transaction/annotation/Transactional.html&quot;&gt;&lt;code&gt;@Transactional&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;http://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/cache/annotation/Cacheable.html&quot;&gt;&lt;code&gt;@Cacheable&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://docs.spring.io/spring-boot/docs/current/api/org/springframework/boot/test/context/SpringBootTest.html&quot;&gt;&lt;code&gt;@SpringBootTest&lt;/code&gt;&lt;/a&gt;. Thanks to meta-annotations support classes annotated with &lt;a href=&quot;https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/context/annotation/Configuration.html&quot;&gt;&lt;code&gt;@Configuration&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/stereotype/Controller.html&quot;&gt;&lt;code&gt;@Controller&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/web/bind/annotation/RestController.html&quot;&gt;&lt;code&gt;@RestController&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/stereotype/Service.html&quot;&gt;&lt;code&gt;@Service&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/stereotype/Repository.html&quot;&gt;&lt;code&gt;@Repository&lt;/code&gt;&lt;/a&gt; are automatically opened since these annotations are meta-annotated with &lt;a href=&quot;http://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/stereotype/Component.html&quot;&gt;&lt;code&gt;@Component&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">该插件指定了以下注释：&lt;a href=&quot;http://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/stereotype/Component.html&quot;&gt; &lt;code&gt;@Component&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;http://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/scheduling/annotation/Async.html&quot;&gt; &lt;code&gt;@Async&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;http://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/transaction/annotation/Transactional.html&quot;&gt; &lt;code&gt;@Transactional&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;http://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/cache/annotation/Cacheable.html&quot;&gt; &lt;code&gt;@Cacheable&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;https://docs.spring.io/spring-boot/docs/current/api/org/springframework/boot/test/context/SpringBootTest.html&quot;&gt; &lt;code&gt;@SpringBootTest&lt;/code&gt; &lt;/a&gt;。由于元注释支持与注解的类&lt;a href=&quot;https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/context/annotation/Configuration.html&quot;&gt; &lt;code&gt;@Configuration&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/stereotype/Controller.html&quot;&gt; &lt;code&gt;@Controller&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/web/bind/annotation/RestController.html&quot;&gt; &lt;code&gt;@RestController&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/stereotype/Service.html&quot;&gt; &lt;code&gt;@Service&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/stereotype/Repository.html&quot;&gt; &lt;code&gt;@Repository&lt;/code&gt; &lt;/a&gt;会自动打开，因为这些注释是元注解为&lt;a href=&quot;http://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/stereotype/Component.html&quot;&gt; &lt;code&gt;@Component&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="422a0ed13a769b30fb09b25e92467921db8dd51b" translate="yes" xml:space="preserve">
          <source>The plugin uses the same notation as the compiler. By default, test component uses the same targets as specified for the main one.</source>
          <target state="translated">插件使用与编译器相同的符号。默认情况下,测试组件使用与主测试组件相同的目标。</target>
        </trans-unit>
        <trans-unit id="1f3c2f2fca540697d8f63e00a5a21435f0484957" translate="yes" xml:space="preserve">
          <source>The podspec generated includes a path to an output framework and script phases which automate building this framework during a build process of an Xcode project. Some fields of the podspec file can be configured using the &lt;code&gt;kotlin.cocoapods { ... }&lt;/code&gt; code block.</source>
          <target state="translated">生成的podspec包括输出框架的路径和脚本阶段，这些阶段在Xcode项目的构建过程中自动构建该框架。可以使用 &lt;code&gt;kotlin.cocoapods { ... }&lt;/code&gt; 代码块来配置podspec文件的某些字段。</target>
        </trans-unit>
        <trans-unit id="4f2f6c39a4cfc0d578583a59ccc054d34affa473" translate="yes" xml:space="preserve">
          <source>The pointer with an opaque type.</source>
          <target state="translated">具有不透明类型的指针。</target>
        </trans-unit>
        <trans-unit id="cac38148225622f1c3ccca3dceed3d6a499e0217" translate="yes" xml:space="preserve">
          <source>The possible values of &lt;a href=&quot;returns#kotlin.contracts.ContractBuilder%24returns%28kotlin.Any%29%2Fvalue&quot;&gt;value&lt;/a&gt; are limited to &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;false&lt;/code&gt; or &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;returns#kotlin.contracts.ContractBuilder%24returns%28kotlin.Any%29%2Fvalue&quot;&gt;value&lt;/a&gt;的可能值限制为 &lt;code&gt;true&lt;/code&gt; ， &lt;code&gt;false&lt;/code&gt; 或 &lt;code&gt;null&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="db453765e0a754bcf108983d99d14a9cceb4e257" translate="yes" xml:space="preserve">
          <source>The predicates in &lt;code&gt;filter()&lt;/code&gt; can only check the values of the elements. If you want to use element positions in the filter, use &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/filter-indexed&quot;&gt;&lt;code&gt;filterIndexed()&lt;/code&gt;&lt;/a&gt;. It takes a predicate with two arguments: the index and the value of an element.</source>
          <target state="translated">&lt;code&gt;filter()&lt;/code&gt; 中的谓词只能检查元素的值。如果要在过滤器中使用元素位置，请使用&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/filter-indexed&quot;&gt; &lt;code&gt;filterIndexed()&lt;/code&gt; &lt;/a&gt;。它带有两个参数的谓词：索引和元素的值。</target>
        </trans-unit>
        <trans-unit id="273bc9daf88463decafd479d30c651cc98374847" translate="yes" xml:space="preserve">
          <source>The prepared project sources can be directly downloaded from &lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-app-groovy-macos.zip&quot;&gt;GitHub&lt;/a&gt;. &lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-app-groovy-linux.zip&quot;&gt;GitHub&lt;/a&gt;. &lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-app-groovy-windows.zip&quot;&gt;GitHub&lt;/a&gt;. &lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-app-kotlin-macos.zip&quot;&gt;GitHub&lt;/a&gt;. &lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-app-kotlin-linux.zip&quot;&gt;GitHub&lt;/a&gt;. &lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-app-kotlin-windows.zip&quot;&gt;GitHub&lt;/a&gt;.</source>
          <target state="translated">准备好的项目源代码可以直接从&lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-app-groovy-macos.zip&quot;&gt;GitHub&lt;/a&gt;下载。&lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-app-groovy-linux.zip&quot;&gt;GitHub上&lt;/a&gt;。&lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-app-groovy-windows.zip&quot;&gt;GitHub上&lt;/a&gt;。&lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-app-kotlin-macos.zip&quot;&gt;GitHub上&lt;/a&gt;。&lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-app-kotlin-linux.zip&quot;&gt;GitHub上&lt;/a&gt;。&lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-app-kotlin-windows.zip&quot;&gt;GitHub上&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1cda211d823296d73d5059839d0f82ff49bb5da0" translate="yes" xml:space="preserve">
          <source>The prepared project sources can be directly downloaded from &lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-framework-groovy-macos-mac.zip&quot;&gt;GitHub&lt;/a&gt;. &lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-framework-kotlin-macos-mac.zip&quot;&gt;GitHub&lt;/a&gt;.</source>
          <target state="translated">准备好的项目源代码可以直接从&lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-framework-groovy-macos-mac.zip&quot;&gt;GitHub&lt;/a&gt;下载。&lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-framework-kotlin-macos-mac.zip&quot;&gt;GitHub上&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="83fad008770a134699f224ecf517dfb249b17b87" translate="yes" xml:space="preserve">
          <source>The prepared project sources can be directly downloaded from &lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-shared-lib-groovy-linux.zip&quot;&gt;GitHub&lt;/a&gt;. &lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-shared-lib-groovy-macos.zip&quot;&gt;GitHub&lt;/a&gt;. &lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-shared-lib-groovy-windows.zip&quot;&gt;GitHub&lt;/a&gt;. &lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-shared-lib-kotlin-linux.zip&quot;&gt;GitHub&lt;/a&gt;. &lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-shared-lib-kotlin-macos.zip&quot;&gt;GitHub&lt;/a&gt;. &lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-shared-lib-kotlin-windows.zip&quot;&gt;GitHub&lt;/a&gt;.</source>
          <target state="translated">准备好的项目源代码可以直接从&lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-shared-lib-groovy-linux.zip&quot;&gt;GitHub&lt;/a&gt;下载。&lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-shared-lib-groovy-macos.zip&quot;&gt;GitHub上&lt;/a&gt;。&lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-shared-lib-groovy-windows.zip&quot;&gt;GitHub上&lt;/a&gt;。&lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-shared-lib-kotlin-linux.zip&quot;&gt;GitHub上&lt;/a&gt;。&lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-shared-lib-kotlin-macos.zip&quot;&gt;GitHub上&lt;/a&gt;。&lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-shared-lib-kotlin-windows.zip&quot;&gt;GitHub上&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="47fbf2be0cf9555e26f724c9cc904699b4e6d2c6" translate="yes" xml:space="preserve">
          <source>The prepared project sources can be downloaded directly from &lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-app-groovy-macos-c.zip&quot;&gt;GitHub&lt;/a&gt;. &lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-app-groovy-linux-c.zip&quot;&gt;GitHub&lt;/a&gt;. &lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-app-groovy-windows-c.zip&quot;&gt;GitHub&lt;/a&gt;. &lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-app-kotlin-macos-c.zip&quot;&gt;GitHub&lt;/a&gt;. &lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-app-kotlin-linux-c.zip&quot;&gt;GitHub&lt;/a&gt;. &lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-app-kotlin-windows-c.zip&quot;&gt;GitHub&lt;/a&gt;.</source>
          <target state="translated">准备好的项目源可以直接从&lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-app-groovy-macos-c.zip&quot;&gt;GitHub&lt;/a&gt;下载。&lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-app-groovy-linux-c.zip&quot;&gt;GitHub上&lt;/a&gt;。&lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-app-groovy-windows-c.zip&quot;&gt;GitHub上&lt;/a&gt;。&lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-app-kotlin-macos-c.zip&quot;&gt;GitHub上&lt;/a&gt;。&lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-app-kotlin-linux-c.zip&quot;&gt;GitHub上&lt;/a&gt;。&lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-app-kotlin-windows-c.zip&quot;&gt;GitHub上&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0b884226386a575e859d8ba59646588a18cff524" translate="yes" xml:space="preserve">
          <source>The preset functions return an existing target if there is one. This can be used to configure an existing target:</source>
          <target state="translated">预设功能返回一个现有的目标(如果有)。这可以用来配置一个现有的目标。</target>
        </trans-unit>
        <trans-unit id="94b4a93f08efae43f49ccc9068c6ccc45a749339" translate="yes" xml:space="preserve">
          <source>The primary constructor cannot contain any code. Initialization code can be placed in &lt;strong&gt;initializer blocks&lt;/strong&gt;, which are prefixed with the &lt;em&gt;init&lt;/em&gt; keyword.</source>
          <target state="translated">主构造函数不能包含任何代码。可以将初始化代码放在&lt;strong&gt;初始化器块中&lt;/strong&gt;，这些&lt;strong&gt;块&lt;/strong&gt;以&lt;em&gt;init&lt;/em&gt;关键字为前缀。</target>
        </trans-unit>
        <trans-unit id="9fdf36149a4f79a1bb95fdb86a615c52def92e79" translate="yes" xml:space="preserve">
          <source>The primary constructor needs to have at least one parameter;</source>
          <target state="translated">主构造函数需要有至少一个参数。</target>
        </trans-unit>
        <trans-unit id="da3ee8bb58d5e5b4db4f578cf06329f7adf39108" translate="yes" xml:space="preserve">
          <source>The principles of Keeping the Language Modern and Comfortable Updates suggest that incompatible changes are sometimes necessary, but they should be introduced carefully. Our goal is to make the users aware of upcoming changes well in advance to let them migrate their code comfortably.</source>
          <target state="translated">保持语言的现代性和舒适更新的原则表明,不兼容的变化有时是必要的,但应该谨慎引入。我们的目标是让用户提前意识到即将到来的变化,让他们舒适地迁移他们的代码。</target>
        </trans-unit>
        <trans-unit id="8a9400005c3bca2486ac5d4f71c851ac612c4135" translate="yes" xml:space="preserve">
          <source>The problem</source>
          <target state="translated">问题</target>
        </trans-unit>
        <trans-unit id="9c66b2fe04efcfddbeb39708f916ac0b213e981b" translate="yes" xml:space="preserve">
          <source>The problem is that in Kotlin we can say &lt;code&gt;unboxBase(boxDerived(&quot;s&quot;))&lt;/code&gt;, but in Java that would be impossible, because in Java the class &lt;code&gt;Box&lt;/code&gt; is &lt;em&gt;invariant&lt;/em&gt; in its parameter &lt;code&gt;T&lt;/code&gt;, and thus &lt;code&gt;Box&amp;lt;Derived&amp;gt;&lt;/code&gt; is not a subtype of &lt;code&gt;Box&amp;lt;Base&amp;gt;&lt;/code&gt;. To make it work in Java we'd have to define &lt;code&gt;unboxBase&lt;/code&gt; as follows:</source>
          <target state="translated">问题是在Kotlin中我们可以说 &lt;code&gt;unboxBase(boxDerived(&quot;s&quot;))&lt;/code&gt; ，但是在Java中这是不可能的，因为在Java中，类 &lt;code&gt;Box&lt;/code&gt; 的参数 &lt;code&gt;T&lt;/code&gt; 是&lt;em&gt;不变的&lt;/em&gt;，因此 &lt;code&gt;Box&amp;lt;Derived&amp;gt;&lt;/code&gt; 不是子类型。的 &lt;code&gt;Box&amp;lt;Base&amp;gt;&lt;/code&gt; 。为了使其在Java中工作，我们必须定义 &lt;code&gt;unboxBase&lt;/code&gt; ，如下所示：</target>
        </trans-unit>
        <trans-unit id="d0d37636a32f4cdf2f104260760bfa7761da1ecf" translate="yes" xml:space="preserve">
          <source>The process of building and running the Kotlin application in Android Studio is exactly the same as with Java.</source>
          <target state="translated">在Android Studio中构建和运行Kotlin应用程序的过程与使用Java完全相同。</target>
        </trans-unit>
        <trans-unit id="5333ca5a84bee1fa54c6c2c65a4ed24b1d5a7d39" translate="yes" xml:space="preserve">
          <source>The programming model and APIs remain the same. We can continue to use loops, exception handling, etc. and there's no need to learn a complete set of new APIs</source>
          <target state="translated">编程模型和API保持不变。我们可以继续使用循环、异常处理等,不需要学习一套完整的新的API</target>
        </trans-unit>
        <trans-unit id="cbc23b45ec695a38d5e9af2e658da812853cfa4f" translate="yes" xml:space="preserve">
          <source>The progression starts with the &lt;a href=&quot;from-closed-range#kotlin.ranges.CharProgression.Companion%24fromClosedRange%28kotlin.Char%2C+kotlin.Char%2C+kotlin.Int%29%2FrangeStart&quot;&gt;rangeStart&lt;/a&gt; value and goes toward the &lt;a href=&quot;from-closed-range#kotlin.ranges.CharProgression.Companion%24fromClosedRange%28kotlin.Char%2C+kotlin.Char%2C+kotlin.Int%29%2FrangeEnd&quot;&gt;rangeEnd&lt;/a&gt; value not excluding it, with the specified &lt;a href=&quot;from-closed-range#kotlin.ranges.CharProgression.Companion%24fromClosedRange%28kotlin.Char%2C+kotlin.Char%2C+kotlin.Int%29%2Fstep&quot;&gt;step&lt;/a&gt;. In order to go backwards the &lt;a href=&quot;from-closed-range#kotlin.ranges.CharProgression.Companion%24fromClosedRange%28kotlin.Char%2C+kotlin.Char%2C+kotlin.Int%29%2Fstep&quot;&gt;step&lt;/a&gt; must be negative.</source>
          <target state="translated">进度以&lt;a href=&quot;from-closed-range#kotlin.ranges.CharProgression.Companion%24fromClosedRange%28kotlin.Char%2C+kotlin.Char%2C+kotlin.Int%29%2FrangeStart&quot;&gt;rangeStart&lt;/a&gt;值开始，并以指定的&lt;a href=&quot;from-closed-range#kotlin.ranges.CharProgression.Companion%24fromClosedRange%28kotlin.Char%2C+kotlin.Char%2C+kotlin.Int%29%2Fstep&quot;&gt;step&lt;/a&gt;朝向不排除它的&lt;a href=&quot;from-closed-range#kotlin.ranges.CharProgression.Companion%24fromClosedRange%28kotlin.Char%2C+kotlin.Char%2C+kotlin.Int%29%2FrangeEnd&quot;&gt;rangeEnd&lt;/a&gt;值。为了后退，&lt;a href=&quot;from-closed-range#kotlin.ranges.CharProgression.Companion%24fromClosedRange%28kotlin.Char%2C+kotlin.Char%2C+kotlin.Int%29%2Fstep&quot;&gt;步数&lt;/a&gt;必须为负。</target>
        </trans-unit>
        <trans-unit id="8d272fe15b8cfff505d8d535e47fe9213e3e4bb4" translate="yes" xml:space="preserve">
          <source>The progression starts with the &lt;a href=&quot;from-closed-range#kotlin.ranges.IntProgression.Companion%24fromClosedRange%28kotlin.Int%2C+kotlin.Int%2C+kotlin.Int%29%2FrangeStart&quot;&gt;rangeStart&lt;/a&gt; value and goes toward the &lt;a href=&quot;from-closed-range#kotlin.ranges.IntProgression.Companion%24fromClosedRange%28kotlin.Int%2C+kotlin.Int%2C+kotlin.Int%29%2FrangeEnd&quot;&gt;rangeEnd&lt;/a&gt; value not excluding it, with the specified &lt;a href=&quot;from-closed-range#kotlin.ranges.IntProgression.Companion%24fromClosedRange%28kotlin.Int%2C+kotlin.Int%2C+kotlin.Int%29%2Fstep&quot;&gt;step&lt;/a&gt;. In order to go backwards the &lt;a href=&quot;from-closed-range#kotlin.ranges.IntProgression.Companion%24fromClosedRange%28kotlin.Int%2C+kotlin.Int%2C+kotlin.Int%29%2Fstep&quot;&gt;step&lt;/a&gt; must be negative.</source>
          <target state="translated">进度以&lt;a href=&quot;from-closed-range#kotlin.ranges.IntProgression.Companion%24fromClosedRange%28kotlin.Int%2C+kotlin.Int%2C+kotlin.Int%29%2FrangeStart&quot;&gt;rangeStart&lt;/a&gt;值开始，并以指定的&lt;a href=&quot;from-closed-range#kotlin.ranges.IntProgression.Companion%24fromClosedRange%28kotlin.Int%2C+kotlin.Int%2C+kotlin.Int%29%2Fstep&quot;&gt;step&lt;/a&gt;朝向不排除它的&lt;a href=&quot;from-closed-range#kotlin.ranges.IntProgression.Companion%24fromClosedRange%28kotlin.Int%2C+kotlin.Int%2C+kotlin.Int%29%2FrangeEnd&quot;&gt;rangeEnd&lt;/a&gt;值。为了后退，&lt;a href=&quot;from-closed-range#kotlin.ranges.IntProgression.Companion%24fromClosedRange%28kotlin.Int%2C+kotlin.Int%2C+kotlin.Int%29%2Fstep&quot;&gt;步数&lt;/a&gt;必须为负。</target>
        </trans-unit>
        <trans-unit id="84ee7e5946067792bd4d0c03b228099a9bd9d9cd" translate="yes" xml:space="preserve">
          <source>The progression starts with the &lt;a href=&quot;from-closed-range#kotlin.ranges.LongProgression.Companion%24fromClosedRange%28kotlin.Long%2C+kotlin.Long%2C+kotlin.Long%29%2FrangeStart&quot;&gt;rangeStart&lt;/a&gt; value and goes toward the &lt;a href=&quot;from-closed-range#kotlin.ranges.LongProgression.Companion%24fromClosedRange%28kotlin.Long%2C+kotlin.Long%2C+kotlin.Long%29%2FrangeEnd&quot;&gt;rangeEnd&lt;/a&gt; value not excluding it, with the specified &lt;a href=&quot;from-closed-range#kotlin.ranges.LongProgression.Companion%24fromClosedRange%28kotlin.Long%2C+kotlin.Long%2C+kotlin.Long%29%2Fstep&quot;&gt;step&lt;/a&gt;. In order to go backwards the &lt;a href=&quot;from-closed-range#kotlin.ranges.LongProgression.Companion%24fromClosedRange%28kotlin.Long%2C+kotlin.Long%2C+kotlin.Long%29%2Fstep&quot;&gt;step&lt;/a&gt; must be negative.</source>
          <target state="translated">进度以&lt;a href=&quot;from-closed-range#kotlin.ranges.LongProgression.Companion%24fromClosedRange%28kotlin.Long%2C+kotlin.Long%2C+kotlin.Long%29%2FrangeStart&quot;&gt;rangeStart&lt;/a&gt;值开始，并以指定的&lt;a href=&quot;from-closed-range#kotlin.ranges.LongProgression.Companion%24fromClosedRange%28kotlin.Long%2C+kotlin.Long%2C+kotlin.Long%29%2Fstep&quot;&gt;step&lt;/a&gt;朝向不排除它的&lt;a href=&quot;from-closed-range#kotlin.ranges.LongProgression.Companion%24fromClosedRange%28kotlin.Long%2C+kotlin.Long%2C+kotlin.Long%29%2FrangeEnd&quot;&gt;rangeEnd&lt;/a&gt;值。为了后退，&lt;a href=&quot;from-closed-range#kotlin.ranges.LongProgression.Companion%24fromClosedRange%28kotlin.Long%2C+kotlin.Long%2C+kotlin.Long%29%2Fstep&quot;&gt;步数&lt;/a&gt;必须为负。</target>
        </trans-unit>
        <trans-unit id="8d8b7627f24846e9a31abff3ae25964002a498bf" translate="yes" xml:space="preserve">
          <source>The progression starts with the &lt;a href=&quot;from-closed-range#kotlin.ranges.UIntProgression.Companion%24fromClosedRange%28kotlin.UInt%2C+kotlin.UInt%2C+kotlin.Int%29%2FrangeStart&quot;&gt;rangeStart&lt;/a&gt; value and goes toward the &lt;a href=&quot;from-closed-range#kotlin.ranges.UIntProgression.Companion%24fromClosedRange%28kotlin.UInt%2C+kotlin.UInt%2C+kotlin.Int%29%2FrangeEnd&quot;&gt;rangeEnd&lt;/a&gt; value not excluding it, with the specified &lt;a href=&quot;from-closed-range#kotlin.ranges.UIntProgression.Companion%24fromClosedRange%28kotlin.UInt%2C+kotlin.UInt%2C+kotlin.Int%29%2Fstep&quot;&gt;step&lt;/a&gt;. In order to go backwards the &lt;a href=&quot;from-closed-range#kotlin.ranges.UIntProgression.Companion%24fromClosedRange%28kotlin.UInt%2C+kotlin.UInt%2C+kotlin.Int%29%2Fstep&quot;&gt;step&lt;/a&gt; must be negative.</source>
          <target state="translated">进度以&lt;a href=&quot;from-closed-range#kotlin.ranges.UIntProgression.Companion%24fromClosedRange%28kotlin.UInt%2C+kotlin.UInt%2C+kotlin.Int%29%2FrangeStart&quot;&gt;rangeStart&lt;/a&gt;值开始，并以指定的&lt;a href=&quot;from-closed-range#kotlin.ranges.UIntProgression.Companion%24fromClosedRange%28kotlin.UInt%2C+kotlin.UInt%2C+kotlin.Int%29%2Fstep&quot;&gt;step&lt;/a&gt;朝向不排除它的&lt;a href=&quot;from-closed-range#kotlin.ranges.UIntProgression.Companion%24fromClosedRange%28kotlin.UInt%2C+kotlin.UInt%2C+kotlin.Int%29%2FrangeEnd&quot;&gt;rangeEnd&lt;/a&gt;值。为了后退，&lt;a href=&quot;from-closed-range#kotlin.ranges.UIntProgression.Companion%24fromClosedRange%28kotlin.UInt%2C+kotlin.UInt%2C+kotlin.Int%29%2Fstep&quot;&gt;步数&lt;/a&gt;必须为负。</target>
        </trans-unit>
        <trans-unit id="bc7d38b12995812c4efea617bb206ec4460e9ccc" translate="yes" xml:space="preserve">
          <source>The progression starts with the &lt;a href=&quot;from-closed-range#kotlin.ranges.ULongProgression.Companion%24fromClosedRange%28kotlin.ULong%2C+kotlin.ULong%2C+kotlin.Long%29%2FrangeStart&quot;&gt;rangeStart&lt;/a&gt; value and goes toward the &lt;a href=&quot;from-closed-range#kotlin.ranges.ULongProgression.Companion%24fromClosedRange%28kotlin.ULong%2C+kotlin.ULong%2C+kotlin.Long%29%2FrangeEnd&quot;&gt;rangeEnd&lt;/a&gt; value not excluding it, with the specified &lt;a href=&quot;from-closed-range#kotlin.ranges.ULongProgression.Companion%24fromClosedRange%28kotlin.ULong%2C+kotlin.ULong%2C+kotlin.Long%29%2Fstep&quot;&gt;step&lt;/a&gt;. In order to go backwards the &lt;a href=&quot;from-closed-range#kotlin.ranges.ULongProgression.Companion%24fromClosedRange%28kotlin.ULong%2C+kotlin.ULong%2C+kotlin.Long%29%2Fstep&quot;&gt;step&lt;/a&gt; must be negative.</source>
          <target state="translated">进度以&lt;a href=&quot;from-closed-range#kotlin.ranges.ULongProgression.Companion%24fromClosedRange%28kotlin.ULong%2C+kotlin.ULong%2C+kotlin.Long%29%2FrangeStart&quot;&gt;rangeStart&lt;/a&gt;值开始，并以指定的&lt;a href=&quot;from-closed-range#kotlin.ranges.ULongProgression.Companion%24fromClosedRange%28kotlin.ULong%2C+kotlin.ULong%2C+kotlin.Long%29%2Fstep&quot;&gt;step&lt;/a&gt;朝向不排除它的&lt;a href=&quot;from-closed-range#kotlin.ranges.ULongProgression.Companion%24fromClosedRange%28kotlin.ULong%2C+kotlin.ULong%2C+kotlin.Long%29%2FrangeEnd&quot;&gt;rangeEnd&lt;/a&gt;值。为了后退，&lt;a href=&quot;from-closed-range#kotlin.ranges.ULongProgression.Companion%24fromClosedRange%28kotlin.ULong%2C+kotlin.ULong%2C+kotlin.Long%29%2Fstep&quot;&gt;步数&lt;/a&gt;必须为负。</target>
        </trans-unit>
        <trans-unit id="f35887cf67bb91d63b75657011139a4b8f31176b" translate="yes" xml:space="preserve">
          <source>The project file configures the C interop as an additional step of the build. Let's move the &lt;code&gt;interop.def&lt;/code&gt; file to the &lt;code&gt;src/nativeInterop/cinterop&lt;/code&gt; directory. Gradle recommends using conventions instead of configurations, for example, the source files are expected to be in the &lt;code&gt;src/nativeMain/kotlin&lt;/code&gt; folder. By default, all the symbols from C are imported to the &lt;code&gt;interop&lt;/code&gt; package, we may want to import the whole package in our &lt;code&gt;.kt&lt;/code&gt; files. Check out the &lt;a href=&quot;../../reference/building-mpp-with-gradle&quot;&gt;kotlin-multiplatform&lt;/a&gt; plugin documentation to learn about all the different ways you could configure it.</source>
          <target state="translated">项目文件将C互操作配置为构建的附加步骤。让我们将 &lt;code&gt;interop.def&lt;/code&gt; 文件移动到 &lt;code&gt;src/nativeInterop/cinterop&lt;/code&gt; 目录。 Gradle建议使用约定而不是配置，例如，源文件应位于 &lt;code&gt;src/nativeMain/kotlin&lt;/code&gt; 文件夹中。默认情况下，所有来自C的符号都导入到 &lt;code&gt;interop&lt;/code&gt; 包中，我们可能希望将整个包导入到我们的 &lt;code&gt;.kt&lt;/code&gt; 文件中。查看&lt;a href=&quot;../../reference/building-mpp-with-gradle&quot;&gt;kotlin-multiplatform&lt;/a&gt;插件文档，以了解配置它的所有不同方式。</target>
        </trans-unit>
        <trans-unit id="04a29f21fc01df00a35820fecf66f137da298242" translate="yes" xml:space="preserve">
          <source>The project is ready. The next step is to open it in IntelliJ IDEA. For advanced build scenarios, it is recommended to refer to the &lt;a href=&quot;../../reference/building-mpp-with-gradle#setting-up-a-multiplatform-project&quot;&gt;more detailed&lt;/a&gt; documentation.</source>
          <target state="translated">项目准备就绪。下一步是在IntelliJ IDEA中打开它。对于高级构建方案，建议参考&lt;a href=&quot;../../reference/building-mpp-with-gradle#setting-up-a-multiplatform-project&quot;&gt;更详细的&lt;/a&gt;文档。</target>
        </trans-unit>
        <trans-unit id="b358195ade68af7da060ed2c5bd98eb5f625c0a9" translate="yes" xml:space="preserve">
          <source>The project source roots</source>
          <target state="translated">项目源根</target>
        </trans-unit>
        <trans-unit id="6b692a2a5504099d52b9ee1d8cd9e82682b0438b" translate="yes" xml:space="preserve">
          <source>The project structure looks like this:</source>
          <target state="translated">项目结构是这样的。</target>
        </trans-unit>
        <trans-unit id="85001da371d8ff3d4160eee8edd3719f9a8a82c8" translate="yes" xml:space="preserve">
          <source>The project's source files are unchanged.</source>
          <target state="translated">项目的源文件没有变化。</target>
        </trans-unit>
        <trans-unit id="fe6d1020447b5badd7227ed9268d67a33471daca" translate="yes" xml:space="preserve">
          <source>The property that can be used as a placeholder for statements and values that are defined in JavaScript.</source>
          <target state="translated">可用作JavaScript中定义的语句和值的占位符的属性。</target>
        </trans-unit>
        <trans-unit id="fe5ea5ce74d05b50ab08ac3eaf5980cd10f01114" translate="yes" xml:space="preserve">
          <source>The property which this accessor is originated from.</source>
          <target state="translated">这个配件的来源的属性。</target>
        </trans-unit>
        <trans-unit id="f478ed7d5b12b6f5e34c37814b287211378258c6" translate="yes" xml:space="preserve">
          <source>The provisions of the &lt;a href=&quot;kotlin-evolution&quot;&gt;Kotlin evolution policy&lt;/a&gt; fully apply only to components that have reached Full Stability (FS). From that point on incompatible changes have to be approved by the Language Committee.</source>
          <target state="translated">&lt;a href=&quot;kotlin-evolution&quot;&gt;Kotlin进化政策&lt;/a&gt;的规定完全仅适用于已达到完全稳定性（FS）的组件。从那时起，不兼容的更改必须由语言委员会批准。</target>
        </trans-unit>
        <trans-unit id="4e0268d689de7d5f78e70c6cb1e82a66dc683856" translate="yes" xml:space="preserve">
          <source>The publication of this target is handled by the Kotlin plugin and doesn't require the steps that are specific to the Java plugin, such as manually creating a publication and configuring it as &lt;code&gt;from(components.java)&lt;/code&gt;.</source>
          <target state="translated">该目标的发布由Kotlin插件处理，不需要特定于Java插件的步骤，例如手动创建发布并将其配置为 &lt;code&gt;from(components.java)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="38341133c8abc06ea8b313769f8407419006fee4" translate="yes" xml:space="preserve">
          <source>The purpose of this code is to write out some text in the console. In order to use this from the browser, load it, preferably from inside an HTML page:</source>
          <target state="translated">这段代码的目的是在控制台中写出一些文本。为了在浏览器中使用,最好从HTML页面中加载它。</target>
        </trans-unit>
        <trans-unit id="dc84bc4a3671f7fd39fcbdb5d811a4f7dfb04fdc" translate="yes" xml:space="preserve">
          <source>The quickest way to try out C API mapping is to have all C declarations in the &lt;code&gt;interop.def&lt;/code&gt; file, without creating any &lt;code&gt;.h&lt;/code&gt; of &lt;code&gt;.c&lt;/code&gt; files at all. Then place the C declarations in a &lt;code&gt;.def&lt;/code&gt; file after the special &lt;code&gt;---&lt;/code&gt; separator line:</source>
          <target state="translated">尝试C API映射的最快的方法是在所有的C声明 &lt;code&gt;interop.def&lt;/code&gt; 文件，而不会产生任何 &lt;code&gt;.h&lt;/code&gt; 的 &lt;code&gt;.c&lt;/code&gt; 的所有文件。然后将C声明放在特殊的 &lt;code&gt;---&lt;/code&gt; 分隔符行之后的 &lt;code&gt;.def&lt;/code&gt; 文件中：</target>
        </trans-unit>
        <trans-unit id="086ba4582c0f9ff5d704a53067f7ea26f2bef36a" translate="yes" xml:space="preserve">
          <source>The range of indices in the input string where group was captured.</source>
          <target state="translated">输入字符串中捕获组的索引范围。</target>
        </trans-unit>
        <trans-unit id="d16563c64c4aedfc780b010fa9c5624f673175d2" translate="yes" xml:space="preserve">
          <source>The range of indices in the original string where match was captured.</source>
          <target state="translated">匹配的原始字符串中的索引范围。</target>
        </trans-unit>
        <trans-unit id="199d1e88f27ba9b05b8adc73d8d822df0cadd36a" translate="yes" xml:space="preserve">
          <source>The read-only collection types are &lt;a href=&quot;generics#variance&quot;&gt;covariant&lt;/a&gt;. This means that, if a &lt;code&gt;Rectangle&lt;/code&gt; class inherits from &lt;code&gt;Shape&lt;/code&gt;, you can use a &lt;code&gt;List&amp;lt;Rectangle&amp;gt;&lt;/code&gt; anywhere the &lt;code&gt;List&amp;lt;Shape&amp;gt;&lt;/code&gt; is required. In other words, the collection types have the same subtyping relationship as the element types. Maps are covariant on the value type, but not on the key type.</source>
          <target state="translated">只读的集合类型是&lt;a href=&quot;generics#variance&quot;&gt;covariant&lt;/a&gt;。这意味着，如果一个 &lt;code&gt;Rectangle&lt;/code&gt; 从类继承 &lt;code&gt;Shape&lt;/code&gt; ，你可以使用一个 &lt;code&gt;List&amp;lt;Rectangle&amp;gt;&lt;/code&gt; 的任何位置 &lt;code&gt;List&amp;lt;Shape&amp;gt;&lt;/code&gt; 是必需的。换句话说，集合类型与元素类型具有相同的子类型关系。映射在值类型上是协变的，但在键类型上不是。</target>
        </trans-unit>
        <trans-unit id="2ddb83b3e5eaf3228b8ed04e27d5be844d1ede7b" translate="yes" xml:space="preserve">
          <source>The reason we're seeing the actual output is because the call &lt;code&gt;curl_easy_perform&lt;/code&gt; prints the result to the standard output. We could hide this using &lt;code&gt;curl_easy_setopt&lt;/code&gt;.</source>
          <target state="translated">我们看到实际输出的原因是因为调用 &lt;code&gt;curl_easy_perform&lt;/code&gt; 将结果打印到标准输出。我们可以使用 &lt;code&gt;curl_easy_setopt&lt;/code&gt; 隐藏它。</target>
        </trans-unit>
        <trans-unit id="58ca5ea2bf2b7e6112a4ed6c521b74a4fb8e1b96" translate="yes" xml:space="preserve">
          <source>The reference is a value of type &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.reflect/-k-class/index&quot;&gt;KClass&lt;/a&gt;.</source>
          <target state="translated">引用是类型&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.reflect/-k-class/index&quot;&gt;KClass&lt;/a&gt;的值。</target>
        </trans-unit>
        <trans-unit id="225d32a1d2d879830740b8e0770ecbbb02de2cc7" translate="yes" xml:space="preserve">
          <source>The referenced value. Gets the value or sets the new value. If new value is not null, and &lt;code&gt;this&lt;/code&gt; is frozen - it must be frozen or permanent object.</source>
          <target state="translated">参考值。获取值或设置新值。如果新的值不为空，而 &lt;code&gt;this&lt;/code&gt; 是冷冻-它必须是冷冻或永久的对象。</target>
        </trans-unit>
        <trans-unit id="9e1c9e946585f6c5b784f91adc26c58c91e5a3c2" translate="yes" xml:space="preserve">
          <source>The referenced value. Gets the value or sets the new value. If new value is not null, it must be frozen or permanent object.</source>
          <target state="translated">引用的值。获取值或设置新值。如果新值不是null,则必须是冻结或永久对象。</target>
        </trans-unit>
        <trans-unit id="04f24df5fbabe6af37ab1161e95151a96c9196e9" translate="yes" xml:space="preserve">
          <source>The repositories where the library will be published are added via the &lt;code&gt;repositories&lt;/code&gt; block in the &lt;code&gt;publishing { ... }&lt;/code&gt; DSL, as explained in &lt;a href=&quot;https://docs.gradle.org/current/userguide/publishing_maven.html#publishing_maven:repositories&quot;&gt;Maven Publish Plugin. Repositories&lt;/a&gt;.</source>
          <target state="translated">如&lt;a href=&quot;https://docs.gradle.org/current/userguide/publishing_maven.html#publishing_maven:repositories&quot;&gt;Maven Publish Plugin&lt;/a&gt;中所述，将通过 &lt;code&gt;publishing { ... }&lt;/code&gt; DSL中的 &lt;code&gt;repositories&lt;/code&gt; 块添加将要发布库的存储库。仓库。</target>
        </trans-unit>
        <trans-unit id="7ffbb195d8e128e52d788e2edb39be54dd761c55" translate="yes" xml:space="preserve">
          <source>The rest of the procedure works in exactly the same way as in Java.</source>
          <target state="translated">存储过程的其余部分与Java中的工作方式完全相同。</target>
        </trans-unit>
        <trans-unit id="81a9c69ffb22a2342532cf8251cc7d0415b9dbb2" translate="yes" xml:space="preserve">
          <source>The result is an object which represents a reference to the property (the &quot;Platonic ideal&quot; property, not a property on a particular instance). There's a type hierarchy for property objects: the base interface is &lt;code&gt;KProperty&lt;/code&gt;, which lets you get metadata about the property, such as its name and type. If you want to use the property object to read or modify the property's value in an object, you need to use a subinterface that specifies what kind of property it is. Immutable properties typically are &lt;code&gt;KProperty1&amp;lt;R, V&amp;gt;&lt;/code&gt;, and mutable properties typically are &lt;code&gt;KMutableProperty1&amp;lt;R, V&amp;gt;&lt;/code&gt;. Both of these are generic interfaces, with &lt;code&gt;R&lt;/code&gt; being the receiver type (the type on which the property is declared, in this case &lt;code&gt;Person&lt;/code&gt;) and &lt;code&gt;V&lt;/code&gt; being the type of the property's value.</source>
          <target state="translated">结果是一个对象，该对象表示对该属性的引用（&amp;ldquo;柏拉图理想&amp;rdquo;属性，而不是特定实例上的属性）。属性对象有一个类型层次结构：基本接口是 &lt;code&gt;KProperty&lt;/code&gt; ，它使您可以获取有关属性的元数据，例如名称和类型。如果要使用属性对象读取或修改对象中属性的值，则需要使用一个子接口来指定它是什么类型的属性。不变属性通常是 &lt;code&gt;KProperty1&amp;lt;R, V&amp;gt;&lt;/code&gt; ，可变属性通常是 &lt;code&gt;KMutableProperty1&amp;lt;R, V&amp;gt;&lt;/code&gt; 。这两个都是通用接口，其中 &lt;code&gt;R&lt;/code&gt; 是接收方类型（在该属性上声明属性的类型，在这种情况下为 &lt;code&gt;Person&lt;/code&gt; ），而 &lt;code&gt;V&lt;/code&gt; 是属性值的类型。</target>
        </trans-unit>
        <trans-unit id="1a8aae926c8fa4cd902ab72788ba84f110e52d36" translate="yes" xml:space="preserve">
          <source>The result is computed as &lt;code&gt;r = this - (q * divisor)&lt;/code&gt; where &lt;code&gt;q&lt;/code&gt; is the quotient of division rounded to the nearest integer, &lt;code&gt;q = round(this / other)&lt;/code&gt;.</source>
          <target state="translated">计算结果为 &lt;code&gt;r = this - (q * divisor)&lt;/code&gt; ，其中 &lt;code&gt;q&lt;/code&gt; 是四舍五入到最接近整数的除法商， &lt;code&gt;q = round(this / other)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8346187656aa601c46c1b882160101b5d70d1783" translate="yes" xml:space="preserve">
          <source>The result is going to be:</source>
          <target state="translated">结果是要。</target>
        </trans-unit>
        <trans-unit id="f757614cb2200a5a31db5b9a50190e9f1a783287" translate="yes" xml:space="preserve">
          <source>The result is the same, but this code uses only non-blocking &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/delay.html&quot;&gt;delay&lt;/a&gt;. The main thread invoking &lt;code&gt;runBlocking&lt;/code&gt;&lt;em&gt;blocks&lt;/em&gt; until the coroutine inside &lt;code&gt;runBlocking&lt;/code&gt; completes.</source>
          <target state="translated">结果是相同的，但是此代码仅使用非阻塞&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/delay.html&quot;&gt;延迟&lt;/a&gt;。主线程调用 &lt;code&gt;runBlocking&lt;/code&gt; &lt;em&gt;块&lt;/em&gt;，直到内部的协同程序 &lt;code&gt;runBlocking&lt;/code&gt; 完成。</target>
        </trans-unit>
        <trans-unit id="80513416e38e21b1cd6b19983bdbc1cd0f8dbc1d" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;minus&lt;/code&gt; contains the elements of the original collection &lt;em&gt;except&lt;/em&gt; the elements from the second operand. If it's an element, &lt;code&gt;minus&lt;/code&gt; removes its &lt;em&gt;first&lt;/em&gt; occurrence; if it's a collection, &lt;em&gt;all&lt;/em&gt; occurrences of its elements are removed.</source>
          <target state="translated">&lt;code&gt;minus&lt;/code&gt; 的结果包含原始集合的元素，但第二个操作数中的元素&lt;em&gt;除外&lt;/em&gt;。如果它是一个元素， &lt;code&gt;minus&lt;/code&gt; 会删除它的&lt;em&gt;第一个&lt;/em&gt;匹配项。如果是集合，则删除&lt;em&gt;所有&lt;/em&gt;出现的元素。</target>
        </trans-unit>
        <trans-unit id="9f4386a5cc0897ae566404e34449e10c9271784f" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;plus&lt;/code&gt; contains the elements from the original collection &lt;em&gt;and&lt;/em&gt; from the second operand.</source>
          <target state="translated">&lt;code&gt;plus&lt;/code&gt; 的结果包含原始集合&lt;em&gt;和&lt;/em&gt;第二个操作数中的元素。</target>
        </trans-unit>
        <trans-unit id="ff8add7f5e14fd024c26ef191ab483a18b621fed" translate="yes" xml:space="preserve">
          <source>The result of the future computation. Blocks execution until the future is ready. Second attempt to get will result in an error.</source>
          <target state="translated">未来计算的结果。阻止执行,直到未来的计算准备好。第二次尝试获取将导致错误。</target>
        </trans-unit>
        <trans-unit id="b0a33939298c1573b79334a09954b9afb450d438" translate="yes" xml:space="preserve">
          <source>The result of this code is quite interesting, so we'll analyze it in mode detail:</source>
          <target state="translated">这段代码的结果是相当有趣的,所以我们将详细分析它的模式。</target>
        </trans-unit>
        <trans-unit id="a92982b6e3242403fa82d0db42fdb4534028b312" translate="yes" xml:space="preserve">
          <source>The result of this code is:</source>
          <target state="translated">该代码的结果是:</target>
        </trans-unit>
        <trans-unit id="ee6868c39ff4d2539255b06db5a2381813300a75" translate="yes" xml:space="preserve">
          <source>The result of this code:</source>
          <target state="translated">这个代码的结果。</target>
        </trans-unit>
        <trans-unit id="4844d20ae5c2024023a55c2b6b3214cb6ce72593" translate="yes" xml:space="preserve">
          <source>The resulting &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/util/SortedMap.html&quot;&gt;SortedMap&lt;/a&gt; determines the equality and order of keys according to their natural sorting order.</source>
          <target state="translated">生成的&lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/util/SortedMap.html&quot;&gt;SortedMap&lt;/a&gt;根据键的自然排序顺序确定键的相等性和顺序。</target>
        </trans-unit>
        <trans-unit id="8f890bef6e41ea49023cd4e145c9ac8e02777347" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Byte&lt;/code&gt; value has the same binary representation as this &lt;code&gt;UByte&lt;/code&gt; value.</source>
          <target state="translated">所得的 &lt;code&gt;Byte&lt;/code&gt; 值与此 &lt;code&gt;UByte&lt;/code&gt; 值具有相同的二进制表示形式。</target>
        </trans-unit>
        <trans-unit id="bcc21fce83c8a76fb70c4188dec066655dc99e5f" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Byte&lt;/code&gt; value is equal to &lt;code&gt;this.toInt().toByte()&lt;/code&gt;.</source>
          <target state="translated">生成的 &lt;code&gt;Byte&lt;/code&gt; 值等于 &lt;code&gt;this.toInt().toByte()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="500fd389152dfac3d3a3bdf516db69049b6112d1" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Byte&lt;/code&gt; value is represented by the least significant 8 bits of this &lt;code&gt;Int&lt;/code&gt; value.</source>
          <target state="translated">结果 &lt;code&gt;Byte&lt;/code&gt; 值由该 &lt;code&gt;Int&lt;/code&gt; 值的最低有效8位表示。</target>
        </trans-unit>
        <trans-unit id="f5d708d0dd756dc92bd87189470b9a3b0f187bad" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Byte&lt;/code&gt; value is represented by the least significant 8 bits of this &lt;code&gt;Long&lt;/code&gt; value.</source>
          <target state="translated">结果 &lt;code&gt;Byte&lt;/code&gt; 值由此 &lt;code&gt;Long&lt;/code&gt; 值的最低有效8位表示。</target>
        </trans-unit>
        <trans-unit id="f1c617d1ad1ce5e0250376516d3fc7acee8c76a7" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Byte&lt;/code&gt; value is represented by the least significant 8 bits of this &lt;code&gt;Short&lt;/code&gt; value.</source>
          <target state="translated">结果 &lt;code&gt;Byte&lt;/code&gt; 值由该 &lt;code&gt;Short&lt;/code&gt; 值的最低8位表示。</target>
        </trans-unit>
        <trans-unit id="3c0aa6565c5cc7948d96b6aa45e671f5d970085c" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Byte&lt;/code&gt; value is represented by the least significant 8 bits of this &lt;code&gt;UInt&lt;/code&gt; value. Note that the resulting &lt;code&gt;Byte&lt;/code&gt; value may be negative.</source>
          <target state="translated">结果 &lt;code&gt;Byte&lt;/code&gt; 值由该 &lt;code&gt;UInt&lt;/code&gt; 值的最低有效8位表示。请注意，结果 &lt;code&gt;Byte&lt;/code&gt; 值可能为负。</target>
        </trans-unit>
        <trans-unit id="dd46bb58530a520cf29001659a58a32130329b50" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Byte&lt;/code&gt; value is represented by the least significant 8 bits of this &lt;code&gt;ULong&lt;/code&gt; value. Note that the resulting &lt;code&gt;Byte&lt;/code&gt; value may be negative.</source>
          <target state="translated">结果 &lt;code&gt;Byte&lt;/code&gt; 值由该 &lt;code&gt;ULong&lt;/code&gt; 值的最低有效8位表示。请注意，结果 &lt;code&gt;Byte&lt;/code&gt; 值可能为负。</target>
        </trans-unit>
        <trans-unit id="f0796ad9fb92ce12d111b3b2e535fa3a4138ff67" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Byte&lt;/code&gt; value is represented by the least significant 8 bits of this &lt;code&gt;UShort&lt;/code&gt; value. Note that the resulting &lt;code&gt;Byte&lt;/code&gt; value may be negative.</source>
          <target state="translated">结果 &lt;code&gt;Byte&lt;/code&gt; 值由该 &lt;code&gt;UShort&lt;/code&gt; 值的最低有效8位表示。请注意，结果 &lt;code&gt;Byte&lt;/code&gt; 值可能为负。</target>
        </trans-unit>
        <trans-unit id="1dcececb10dcdcffc92e35f3fc84338088990b5d" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Char&lt;/code&gt; code is equal to this value reinterpreted as an unsigned number, i.e. it has the same binary representation as this &lt;code&gt;Short&lt;/code&gt;.</source>
          <target state="translated">所得的 &lt;code&gt;Char&lt;/code&gt; 代码等于将此值重新解释为无符号数字，即，它具有与此 &lt;code&gt;Short&lt;/code&gt; 相同的二进制表示形式。</target>
        </trans-unit>
        <trans-unit id="7d3990133293f18f718906ea26c50d316e7978f0" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Char&lt;/code&gt; code is represented by the least significant 16 bits of this &lt;code&gt;Int&lt;/code&gt; value.</source>
          <target state="translated">所得的 &lt;code&gt;Char&lt;/code&gt; 码由该 &lt;code&gt;Int&lt;/code&gt; 值的最低16位表示。</target>
        </trans-unit>
        <trans-unit id="8e5f25cf2555e851681e56711455629d8b96cc85" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Char&lt;/code&gt; code is represented by the least significant 16 bits of this &lt;code&gt;Long&lt;/code&gt; value.</source>
          <target state="translated">所得的 &lt;code&gt;Char&lt;/code&gt; 码由此 &lt;code&gt;Long&lt;/code&gt; 值的最低有效16位表示。</target>
        </trans-unit>
        <trans-unit id="7c93c7f205f664c42eb53e198c38febdd8681e8c" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Char&lt;/code&gt; value is equal to &lt;code&gt;this.toInt().toChar()&lt;/code&gt;.</source>
          <target state="translated">得到的 &lt;code&gt;Char&lt;/code&gt; 值等于 &lt;code&gt;this.toInt().toChar()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fb0bee6e823fc7a039aaeeb4e2cf6ccadd56cad2" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Double&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;Byte&lt;/code&gt;.</source>
          <target state="translated">得到的 &lt;code&gt;Double&lt;/code&gt; 值表示与此 &lt;code&gt;Byte&lt;/code&gt; 相同的数值。</target>
        </trans-unit>
        <trans-unit id="ec044076f69f3a9e4c8c326707b213be48dbdf4c" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Double&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;Float&lt;/code&gt;.</source>
          <target state="translated">得到的 &lt;code&gt;Double&lt;/code&gt; 值表示与此 &lt;code&gt;Float&lt;/code&gt; 相同的数值。</target>
        </trans-unit>
        <trans-unit id="413cc395d49c3c9b688aa7288d432c1583480097" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Double&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;Int&lt;/code&gt;.</source>
          <target state="translated">得到的 &lt;code&gt;Double&lt;/code&gt; 值表示与此 &lt;code&gt;Int&lt;/code&gt; 相同的数值。</target>
        </trans-unit>
        <trans-unit id="e04c116c448cef44fd49f1d1da49c8be72cf833e" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Double&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;Short&lt;/code&gt;.</source>
          <target state="translated">得到的 &lt;code&gt;Double&lt;/code&gt; 值表示与此 &lt;code&gt;Short&lt;/code&gt; 相同的数值。</target>
        </trans-unit>
        <trans-unit id="624ad9cad2fadf7c5df7034160380cba9b36827a" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Double&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;UByte&lt;/code&gt;.</source>
          <target state="translated">得到的 &lt;code&gt;Double&lt;/code&gt; 值表示与此 &lt;code&gt;UByte&lt;/code&gt; 相同的数值。</target>
        </trans-unit>
        <trans-unit id="e233d00009204b3d8e16f6c4faaeb29b610dd152" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Double&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;UInt&lt;/code&gt;.</source>
          <target state="translated">所得的 &lt;code&gt;Double&lt;/code&gt; 值表示与此 &lt;code&gt;UInt&lt;/code&gt; 相同的数值。</target>
        </trans-unit>
        <trans-unit id="be9fd1536c9016ec165d93e9e044c6403df23d59" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Double&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;UShort&lt;/code&gt;.</source>
          <target state="translated">得到的 &lt;code&gt;Double&lt;/code&gt; 值表示与此 &lt;code&gt;UShort&lt;/code&gt; 相同的数值。</target>
        </trans-unit>
        <trans-unit id="ae244f9a05312104462c229a2e3a4a4de64be4e1" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Float&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;Byte&lt;/code&gt;.</source>
          <target state="translated">最终的 &lt;code&gt;Float&lt;/code&gt; 值表示与此 &lt;code&gt;Byte&lt;/code&gt; 相同的数值。</target>
        </trans-unit>
        <trans-unit id="f8088fd36ea4c2c1efeb80cfa5d2e317eb476320" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Float&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;Short&lt;/code&gt;.</source>
          <target state="translated">产生的 &lt;code&gt;Float&lt;/code&gt; 值表示与此 &lt;code&gt;Short&lt;/code&gt; 相同的数值。</target>
        </trans-unit>
        <trans-unit id="f353ad75e4345f7f3c16a80f19361bddd53a4f67" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Float&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;UByte&lt;/code&gt;.</source>
          <target state="translated">最终的 &lt;code&gt;Float&lt;/code&gt; 值表示与此 &lt;code&gt;UByte&lt;/code&gt; 相同的数值。</target>
        </trans-unit>
        <trans-unit id="abac5ba157cb93c8f101ff3e6ab497cfac17749a" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Float&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;UShort&lt;/code&gt;.</source>
          <target state="translated">最终的 &lt;code&gt;Float&lt;/code&gt; 值表示与此 &lt;code&gt;UShort&lt;/code&gt; 相同的数值。</target>
        </trans-unit>
        <trans-unit id="9d03c1143daecc3b8a141860933f0a92adb18b37" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Int&lt;/code&gt; value has the same binary representation as this &lt;code&gt;UInt&lt;/code&gt; value.</source>
          <target state="translated">生成的 &lt;code&gt;Int&lt;/code&gt; 值与此 &lt;code&gt;UInt&lt;/code&gt; 值具有相同的二进制表示形式。</target>
        </trans-unit>
        <trans-unit id="6ff94aee825d38ae08d93f2ca58819f2a03d9747" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Int&lt;/code&gt; value is represented by the least significant 32 bits of this &lt;code&gt;Long&lt;/code&gt; value.</source>
          <target state="translated">结果 &lt;code&gt;Int&lt;/code&gt; 值由此 &lt;code&gt;Long&lt;/code&gt; 值的最低有效32位表示。</target>
        </trans-unit>
        <trans-unit id="7a5d4e0dea3c1513f10c80d1128e159e3a009787" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Int&lt;/code&gt; value is represented by the least significant 32 bits of this &lt;code&gt;ULong&lt;/code&gt; value. Note that the resulting &lt;code&gt;Int&lt;/code&gt; value may be negative.</source>
          <target state="translated">结果的 &lt;code&gt;Int&lt;/code&gt; 值由该 &lt;code&gt;ULong&lt;/code&gt; 值的最低有效32位表示。请注意，所得的 &lt;code&gt;Int&lt;/code&gt; 值可能为负。</target>
        </trans-unit>
        <trans-unit id="134cc45d29d5c0611e6038571857feed8853b0ee" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Int&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;Byte&lt;/code&gt;.</source>
          <target state="translated">得到的 &lt;code&gt;Int&lt;/code&gt; 值表示与此 &lt;code&gt;Byte&lt;/code&gt; 相同的数值。</target>
        </trans-unit>
        <trans-unit id="a8d60bc3ef88b39460060b7f8165763da80802bc" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Int&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;Short&lt;/code&gt;.</source>
          <target state="translated">得到的 &lt;code&gt;Int&lt;/code&gt; 值表示与此 &lt;code&gt;Short&lt;/code&gt; 相同的数值。</target>
        </trans-unit>
        <trans-unit id="12aaa5ec83610d73b4b2fc195902417a297ddd61" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Int&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;UByte&lt;/code&gt;.</source>
          <target state="translated">结果 &lt;code&gt;Int&lt;/code&gt; 值表示与此 &lt;code&gt;UByte&lt;/code&gt; 相同的数值。</target>
        </trans-unit>
        <trans-unit id="b30712342fda907bc49df4d10c136bbeeaaf708b" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Int&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;UShort&lt;/code&gt;.</source>
          <target state="translated">最终的 &lt;code&gt;Int&lt;/code&gt; 值表示与此 &lt;code&gt;UShort&lt;/code&gt; 相同的数值。</target>
        </trans-unit>
        <trans-unit id="25bcbeae5576ececd431ec0f451a2c7cf6bf73b4" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Long&lt;/code&gt; value has the same binary representation as this &lt;code&gt;ULong&lt;/code&gt; value.</source>
          <target state="translated">所得的 &lt;code&gt;Long&lt;/code&gt; 值与此 &lt;code&gt;ULong&lt;/code&gt; 值具有相同的二进制表示形式。</target>
        </trans-unit>
        <trans-unit id="e6a0efc4ac5c4b05735980342faa240209bf9353" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Long&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;Byte&lt;/code&gt;.</source>
          <target state="translated">得到的 &lt;code&gt;Long&lt;/code&gt; 值表示与此 &lt;code&gt;Byte&lt;/code&gt; 相同的数值。</target>
        </trans-unit>
        <trans-unit id="a30381cf3452bf71d4466b6a6a9c5a35e959654a" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Long&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;Int&lt;/code&gt;.</source>
          <target state="translated">得到的 &lt;code&gt;Long&lt;/code&gt; 值表示与此 &lt;code&gt;Int&lt;/code&gt; 相同的数值。</target>
        </trans-unit>
        <trans-unit id="7692c28294ebe4518a8808f192338ab899b5aeec" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Long&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;Short&lt;/code&gt;.</source>
          <target state="translated">得到的 &lt;code&gt;Long&lt;/code&gt; 值表示与此 &lt;code&gt;Short&lt;/code&gt; 相同的数值。</target>
        </trans-unit>
        <trans-unit id="60b7e7e3ba10c2b92827e84db685cc040e179ed1" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Long&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;UByte&lt;/code&gt;.</source>
          <target state="translated">得到的 &lt;code&gt;Long&lt;/code&gt; 值表示与此 &lt;code&gt;UByte&lt;/code&gt; 相同的数值。</target>
        </trans-unit>
        <trans-unit id="a95d7e6a557f4530d701aed1a8410d9b6e793205" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Long&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;UInt&lt;/code&gt;.</source>
          <target state="translated">得到的 &lt;code&gt;Long&lt;/code&gt; 值表示与此 &lt;code&gt;UInt&lt;/code&gt; 相同的数值。</target>
        </trans-unit>
        <trans-unit id="e900373f53d6267fd01ecf92bb2c5cb1fed9a7b7" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Long&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;UShort&lt;/code&gt;.</source>
          <target state="translated">得到的 &lt;code&gt;Long&lt;/code&gt; 值表示与此 &lt;code&gt;UShort&lt;/code&gt; 相同的数值。</target>
        </trans-unit>
        <trans-unit id="3866529acc183dc8b682af92a84909ec65bd5749" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Short&lt;/code&gt; value has the same binary representation as this &lt;code&gt;UShort&lt;/code&gt; value.</source>
          <target state="translated">所得的 &lt;code&gt;Short&lt;/code&gt; 值与此 &lt;code&gt;UShort&lt;/code&gt; 值具有相同的二进制表示形式。</target>
        </trans-unit>
        <trans-unit id="5ccfa5aff935ee9326f2b407c585467d126768e7" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Short&lt;/code&gt; value is equal to &lt;code&gt;this.toInt().toShort()&lt;/code&gt;.</source>
          <target state="translated">产生的 &lt;code&gt;Short&lt;/code&gt; 值等于 &lt;code&gt;this.toInt().toShort()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fb338e05b22f496cc978d6bf212ddabde5dd17a4" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Short&lt;/code&gt; value is represented by the least significant 16 bits of this &lt;code&gt;Int&lt;/code&gt; value.</source>
          <target state="translated">结果的 &lt;code&gt;Short&lt;/code&gt; 值由该 &lt;code&gt;Int&lt;/code&gt; 值的最低有效16位表示。</target>
        </trans-unit>
        <trans-unit id="27367d77acd56c6a1050bc0a49a57fcf2061de96" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Short&lt;/code&gt; value is represented by the least significant 16 bits of this &lt;code&gt;Long&lt;/code&gt; value.</source>
          <target state="translated">结果的 &lt;code&gt;Short&lt;/code&gt; 值由该 &lt;code&gt;Long&lt;/code&gt; 值的最低有效16位表示。</target>
        </trans-unit>
        <trans-unit id="0bc0fbdc70644d6d748c478656fa78e912cc16e6" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Short&lt;/code&gt; value is represented by the least significant 16 bits of this &lt;code&gt;UInt&lt;/code&gt; value. Note that the resulting &lt;code&gt;Short&lt;/code&gt; value may be negative.</source>
          <target state="translated">结果的 &lt;code&gt;Short&lt;/code&gt; 值由该 &lt;code&gt;UInt&lt;/code&gt; 值的最低有效16位表示。请注意，所得的 &lt;code&gt;Short&lt;/code&gt; 值可能为负。</target>
        </trans-unit>
        <trans-unit id="bb9494a50b8985a2d74ddd24ec83038bdcd4606a" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Short&lt;/code&gt; value is represented by the least significant 16 bits of this &lt;code&gt;ULong&lt;/code&gt; value. Note that the resulting &lt;code&gt;Short&lt;/code&gt; value may be negative.</source>
          <target state="translated">结果的 &lt;code&gt;Short&lt;/code&gt; 值由该 &lt;code&gt;ULong&lt;/code&gt; 值的最低有效16位表示。请注意，所得的 &lt;code&gt;Short&lt;/code&gt; 值可能为负。</target>
        </trans-unit>
        <trans-unit id="1fbe35f845af4aa0feff1d9060ab35a7c6fe3476" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Short&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;Byte&lt;/code&gt;.</source>
          <target state="translated">得到的 &lt;code&gt;Short&lt;/code&gt; 值表示与此 &lt;code&gt;Byte&lt;/code&gt; 相同的数值。</target>
        </trans-unit>
        <trans-unit id="62163dcead131c0bf0933b1342f420db3bc4bb8d" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Short&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;UByte&lt;/code&gt;.</source>
          <target state="translated">所得的 &lt;code&gt;Short&lt;/code&gt; 值表示与此 &lt;code&gt;UByte&lt;/code&gt; 相同的数值。</target>
        </trans-unit>
        <trans-unit id="26c6a5634d9e1d8b962bb6788ae67bc866b78e45" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;UByte&lt;/code&gt; value has the same binary representation as this &lt;code&gt;Byte&lt;/code&gt; value.</source>
          <target state="translated">所得的 &lt;code&gt;UByte&lt;/code&gt; 值与此 &lt;code&gt;Byte&lt;/code&gt; 值具有相同的二进制表示形式。</target>
        </trans-unit>
        <trans-unit id="11d5b691a4a978c7af952b604f7d065d5eac1305" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;UByte&lt;/code&gt; value is represented by the least significant 8 bits of this &lt;code&gt;Int&lt;/code&gt; value.</source>
          <target state="translated">所得的 &lt;code&gt;UByte&lt;/code&gt; 值由该 &lt;code&gt;Int&lt;/code&gt; 值的最低有效8位表示。</target>
        </trans-unit>
        <trans-unit id="5226c83d79204652c28eff49e7528cb1e99fe2d6" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;UByte&lt;/code&gt; value is represented by the least significant 8 bits of this &lt;code&gt;Long&lt;/code&gt; value.</source>
          <target state="translated">将所得 &lt;code&gt;UByte&lt;/code&gt; 值由这种的至少显著8位表示 &lt;code&gt;Long&lt;/code&gt; 值。</target>
        </trans-unit>
        <trans-unit id="726d8e3bdd3b093a08a44094c2cae4da994770da" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;UByte&lt;/code&gt; value is represented by the least significant 8 bits of this &lt;code&gt;Short&lt;/code&gt; value.</source>
          <target state="translated">将所得 &lt;code&gt;UByte&lt;/code&gt; 值由这种的至少显著8位表示 &lt;code&gt;Short&lt;/code&gt; 值。</target>
        </trans-unit>
        <trans-unit id="1dfb49e88d21be6bcb0f49bf822a5aaa6937a983" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;UByte&lt;/code&gt; value is represented by the least significant 8 bits of this &lt;code&gt;UInt&lt;/code&gt; value.</source>
          <target state="translated">所得的 &lt;code&gt;UByte&lt;/code&gt; 值由该 &lt;code&gt;UInt&lt;/code&gt; 值的最低有效8位表示。</target>
        </trans-unit>
        <trans-unit id="2686cc59be2588fb1dc986c8db1acdab514c552c" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;UByte&lt;/code&gt; value is represented by the least significant 8 bits of this &lt;code&gt;ULong&lt;/code&gt; value.</source>
          <target state="translated">所得的 &lt;code&gt;UByte&lt;/code&gt; 值由该 &lt;code&gt;ULong&lt;/code&gt; 值的最低有效8位表示。</target>
        </trans-unit>
        <trans-unit id="a5d21503bfa5cb9b99c854c368f0b66239678aba" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;UByte&lt;/code&gt; value is represented by the least significant 8 bits of this &lt;code&gt;UShort&lt;/code&gt; value.</source>
          <target state="translated">所得的 &lt;code&gt;UByte&lt;/code&gt; 值由该 &lt;code&gt;UShort&lt;/code&gt; 值的最低有效8位表示。</target>
        </trans-unit>
        <trans-unit id="4f3fe5211f1aea05bea1a841d6d73788aeeb2998" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;UInt&lt;/code&gt; value has the same binary representation as this &lt;code&gt;Int&lt;/code&gt; value.</source>
          <target state="translated">所得的 &lt;code&gt;UInt&lt;/code&gt; 值与此 &lt;code&gt;Int&lt;/code&gt; 值具有相同的二进制表示形式。</target>
        </trans-unit>
        <trans-unit id="66a1e76fd131680ad5406468e22ad3973f35ff4e" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;UInt&lt;/code&gt; value is represented by the least significant 32 bits of this &lt;code&gt;Long&lt;/code&gt; value.</source>
          <target state="translated">最终的 &lt;code&gt;UInt&lt;/code&gt; 值由此 &lt;code&gt;Long&lt;/code&gt; 值的最低有效32位表示。</target>
        </trans-unit>
        <trans-unit id="bc935cba2a00e8cc63899ff18d12438a89739380" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;UInt&lt;/code&gt; value is represented by the least significant 32 bits of this &lt;code&gt;ULong&lt;/code&gt; value.</source>
          <target state="translated">最终的 &lt;code&gt;UInt&lt;/code&gt; 值由该 &lt;code&gt;ULong&lt;/code&gt; 值的最低有效32位表示。</target>
        </trans-unit>
        <trans-unit id="9d9ba2608012da37a52b5b9b7da96f6d67796334" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;UInt&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;UByte&lt;/code&gt;.</source>
          <target state="translated">所得的 &lt;code&gt;UInt&lt;/code&gt; 值表示与此 &lt;code&gt;UByte&lt;/code&gt; 相同的数值。</target>
        </trans-unit>
        <trans-unit id="9ab12c98c1ea5502db93ef496727f7d48f4edc12" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;UInt&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;UShort&lt;/code&gt;.</source>
          <target state="translated">最终的 &lt;code&gt;UInt&lt;/code&gt; 值表示与此 &lt;code&gt;UShort&lt;/code&gt; 相同的数值。</target>
        </trans-unit>
        <trans-unit id="e00a9f9829597db51c5f5f105c5c613e61839318" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;ULong&lt;/code&gt; value has the same binary representation as this &lt;code&gt;Long&lt;/code&gt; value.</source>
          <target state="translated">所得的 &lt;code&gt;ULong&lt;/code&gt; 值与此 &lt;code&gt;Long&lt;/code&gt; 值具有相同的二进制表示形式。</target>
        </trans-unit>
        <trans-unit id="a5fe358a0a132b3d4ac886ee0067825836c972c3" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;ULong&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;UByte&lt;/code&gt;.</source>
          <target state="translated">得到的 &lt;code&gt;ULong&lt;/code&gt; 值表示与此 &lt;code&gt;UByte&lt;/code&gt; 相同的数值。</target>
        </trans-unit>
        <trans-unit id="1e225f6484184e1fd9b9a789c6be2168c16944f8" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;ULong&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;UInt&lt;/code&gt;.</source>
          <target state="translated">得到的 &lt;code&gt;ULong&lt;/code&gt; 值表示与此 &lt;code&gt;UInt&lt;/code&gt; 相同的数值。</target>
        </trans-unit>
        <trans-unit id="951d01157187c8755e4bb93be0ec662d70035ced" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;ULong&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;UShort&lt;/code&gt;.</source>
          <target state="translated">得到的 &lt;code&gt;ULong&lt;/code&gt; 值表示与此 &lt;code&gt;UShort&lt;/code&gt; 相同的数值。</target>
        </trans-unit>
        <trans-unit id="76c0754fefaa89b43d0e48e2d3b2efa1a3c37cac" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;UShort&lt;/code&gt; value has the same binary representation as this &lt;code&gt;Short&lt;/code&gt; value.</source>
          <target state="translated">所得的 &lt;code&gt;UShort&lt;/code&gt; 值与此 &lt;code&gt;Short&lt;/code&gt; 值具有相同的二进制表示形式。</target>
        </trans-unit>
        <trans-unit id="ed25489ad27c7ad2fa4a9e9ed8a17e177ed921a7" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;UShort&lt;/code&gt; value is represented by the least significant 16 bits of this &lt;code&gt;Int&lt;/code&gt; value.</source>
          <target state="translated">所得的 &lt;code&gt;UShort&lt;/code&gt; 值由该 &lt;code&gt;Int&lt;/code&gt; 值的最低有效16位表示。</target>
        </trans-unit>
        <trans-unit id="f42954d6785f3d5db6ef1809c504748ad3c8598b" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;UShort&lt;/code&gt; value is represented by the least significant 16 bits of this &lt;code&gt;Long&lt;/code&gt; value.</source>
          <target state="translated">结果 &lt;code&gt;UShort&lt;/code&gt; 值由该 &lt;code&gt;Long&lt;/code&gt; 值的最低有效16位表示。</target>
        </trans-unit>
        <trans-unit id="1457c7b3fcc5ff173b3ad803474b4e660273fb3a" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;UShort&lt;/code&gt; value is represented by the least significant 16 bits of this &lt;code&gt;UInt&lt;/code&gt; value.</source>
          <target state="translated">所得的 &lt;code&gt;UShort&lt;/code&gt; 值由该 &lt;code&gt;UInt&lt;/code&gt; 值的最低有效16位表示。</target>
        </trans-unit>
        <trans-unit id="f4cfae00353cb363d45d034bd2773a412889ab06" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;UShort&lt;/code&gt; value is represented by the least significant 16 bits of this &lt;code&gt;ULong&lt;/code&gt; value.</source>
          <target state="translated">所得的 &lt;code&gt;UShort&lt;/code&gt; 值由该 &lt;code&gt;ULong&lt;/code&gt; 值的最低有效16位表示。</target>
        </trans-unit>
        <trans-unit id="fd44eb3bc0245bda18586fe624c6aa7f2130c655" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;UShort&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;UByte&lt;/code&gt;.</source>
          <target state="translated">所得的 &lt;code&gt;UShort&lt;/code&gt; 值表示与此 &lt;code&gt;UByte&lt;/code&gt; 相同的数值。</target>
        </trans-unit>
        <trans-unit id="26ad7d1c46a7946f361222464d3fd9f54190f2e7" translate="yes" xml:space="preserve">
          <source>The resulting value is the closest &lt;code&gt;Double&lt;/code&gt; to this &lt;code&gt;Long&lt;/code&gt; value. In case when this &lt;code&gt;Long&lt;/code&gt; value is exactly between two &lt;code&gt;Double&lt;/code&gt;s, the one with zero at least significant bit of mantissa is selected.</source>
          <target state="translated">结果值是与此 &lt;code&gt;Long&lt;/code&gt; 值最接近的 &lt;code&gt;Double&lt;/code&gt; 。如果此 &lt;code&gt;Long&lt;/code&gt; 值恰好在两个 &lt;code&gt;Double&lt;/code&gt; 之间，则选择尾数至少为0的那个。</target>
        </trans-unit>
        <trans-unit id="492c13f0924f52f27eadd038e36be9a70c7d0f23" translate="yes" xml:space="preserve">
          <source>The resulting value is the closest &lt;code&gt;Double&lt;/code&gt; to this &lt;code&gt;ULong&lt;/code&gt; value. In case when this &lt;code&gt;ULong&lt;/code&gt; value is exactly between two &lt;code&gt;Double&lt;/code&gt;s, the one with zero at least significant bit of mantissa is selected.</source>
          <target state="translated">结果值是与此 &lt;code&gt;ULong&lt;/code&gt; 值最接近的 &lt;code&gt;Double&lt;/code&gt; 。如果此 &lt;code&gt;ULong&lt;/code&gt; 值恰好在两个 &lt;code&gt;Double&lt;/code&gt; 之间，则选择尾数至少为0的那个。</target>
        </trans-unit>
        <trans-unit id="fc0e588cba1b5e32b36bbd725d91a005e8eca137" translate="yes" xml:space="preserve">
          <source>The resulting value is the closest &lt;code&gt;Float&lt;/code&gt; to this &lt;code&gt;Double&lt;/code&gt; value. In case when this &lt;code&gt;Double&lt;/code&gt; value is exactly between two &lt;code&gt;Float&lt;/code&gt;s, the one with zero at least significant bit of mantissa is selected.</source>
          <target state="translated">结果值是最接近此 &lt;code&gt;Double&lt;/code&gt; 值的 &lt;code&gt;Float&lt;/code&gt; 。如果此 &lt;code&gt;Double&lt;/code&gt; 值恰好在两个 &lt;code&gt;Float&lt;/code&gt; 之间，则选择尾数至少为0的那个。</target>
        </trans-unit>
        <trans-unit id="1a94a9e0d2914f4ed72b19cd967f6325996af0de" translate="yes" xml:space="preserve">
          <source>The resulting value is the closest &lt;code&gt;Float&lt;/code&gt; to this &lt;code&gt;Int&lt;/code&gt; value. In case when this &lt;code&gt;Int&lt;/code&gt; value is exactly between two &lt;code&gt;Float&lt;/code&gt;s, the one with zero at least significant bit of mantissa is selected.</source>
          <target state="translated">结果值是最接近此 &lt;code&gt;Int&lt;/code&gt; 值的 &lt;code&gt;Float&lt;/code&gt; 。如果此 &lt;code&gt;Int&lt;/code&gt; 值恰好在两个 &lt;code&gt;Float&lt;/code&gt; 之间，则选择尾数至少为0的那个。</target>
        </trans-unit>
        <trans-unit id="4c34f885e332b614efeb077bdc9dc7f566d719ac" translate="yes" xml:space="preserve">
          <source>The resulting value is the closest &lt;code&gt;Float&lt;/code&gt; to this &lt;code&gt;Long&lt;/code&gt; value. In case when this &lt;code&gt;Long&lt;/code&gt; value is exactly between two &lt;code&gt;Float&lt;/code&gt;s, the one with zero at least significant bit of mantissa is selected.</source>
          <target state="translated">结果值是最接近此 &lt;code&gt;Long&lt;/code&gt; 值的 &lt;code&gt;Float&lt;/code&gt; 。如果此 &lt;code&gt;Long&lt;/code&gt; 值恰好在两个 &lt;code&gt;Float&lt;/code&gt; 之间，则选择尾数至少为0的那个。</target>
        </trans-unit>
        <trans-unit id="56778d0fa4ef4bd39c3c6c8e27df252ff267b86a" translate="yes" xml:space="preserve">
          <source>The resulting value is the closest &lt;code&gt;Float&lt;/code&gt; to this &lt;code&gt;UInt&lt;/code&gt; value. In case when this &lt;code&gt;UInt&lt;/code&gt; value is exactly between two &lt;code&gt;Float&lt;/code&gt;s, the one with zero at least significant bit of mantissa is selected.</source>
          <target state="translated">结果值是最接近此 &lt;code&gt;UInt&lt;/code&gt; 值的 &lt;code&gt;Float&lt;/code&gt; 。如果此 &lt;code&gt;UInt&lt;/code&gt; 值恰好在两个 &lt;code&gt;Float&lt;/code&gt; 之间，则选择至少零个有效尾数的那个。</target>
        </trans-unit>
        <trans-unit id="498957909e2b3c5b2a70150c6779dc9db0eb20c7" translate="yes" xml:space="preserve">
          <source>The resulting value is the closest &lt;code&gt;Float&lt;/code&gt; to this &lt;code&gt;ULong&lt;/code&gt; value. In case when this &lt;code&gt;ULong&lt;/code&gt; value is exactly between two &lt;code&gt;Float&lt;/code&gt;s, the one with zero at least significant bit of mantissa is selected.</source>
          <target state="translated">结果值是最接近此 &lt;code&gt;ULong&lt;/code&gt; 值的 &lt;code&gt;Float&lt;/code&gt; 。如果此 &lt;code&gt;ULong&lt;/code&gt; 值恰好在两个 &lt;code&gt;Float&lt;/code&gt; 之间，则选择至少零个有效尾数的零。</target>
        </trans-unit>
        <trans-unit id="65d14c2cdb6c9b143338a902f9c4de4c9b45f92f" translate="yes" xml:space="preserve">
          <source>The return type inference for anonymous functions works just like for normal functions: the return type is inferred automatically for anonymous functions with an expression body and has to be specified explicitly (or is assumed to be &lt;code&gt;Unit&lt;/code&gt;) for anonymous functions with a block body.</source>
          <target state="translated">匿名函数的返回类型推断的工作原理与普通函数一样：对于具有表达式主体的匿名函数，将自动推断返回类型，对于具有块主体的匿名函数，必须明确指定返回类型（或假定为 &lt;code&gt;Unit&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="dbab78ef44eaefb4e469bd1e51f4e8661d634cea" translate="yes" xml:space="preserve">
          <source>The return type of a function-typed return type (the user expects the returned function to return &lt;code&gt;Fruit&lt;/code&gt;, so it's okay if it really returns &lt;code&gt;Apple&lt;/code&gt;)</source>
          <target state="translated">函数类型的返回类型的返回类型（用户希望返回的函数返回 &lt;code&gt;Fruit&lt;/code&gt; ，因此，如果它确实返回 &lt;code&gt;Apple&lt;/code&gt; ,也可以）</target>
        </trans-unit>
        <trans-unit id="d8362d946ac99a87abd0521089565682c0510f07" translate="yes" xml:space="preserve">
          <source>The return type of a lambda expression is inferred from the type of the last expression inside it (or from the function type of the variable/parameter that the lambda expression is assigned to). If a lambda expression is passed as a function parameter (which is the ordinary use) or assigned to a variable with a declared type, Kotlin can infer the parameter types too, and you only need to specify their names:</source>
          <target state="translated">一个lambda表达式的返回类型是根据它里面最后一个表达式的类型来推断的(或者是根据lambda表达式分配给的变量/参数的函数类型)。如果一个lambda表达式作为函数参数传递(这是普通的用法),或者分配给一个有声明类型的变量,Kotlin也可以推断出参数类型,你只需要指定它们的名字。</target>
        </trans-unit>
        <trans-unit id="d7c260eb93497371636dc4de8fdb8ef84ac32045" translate="yes" xml:space="preserve">
          <source>The return value of &lt;code&gt;apply&lt;/code&gt; and &lt;code&gt;also&lt;/code&gt; is the context object itself. Hence, they can be included into call chains as &lt;em&gt;side steps&lt;/em&gt;: you can continue chaining function calls on the same object after them.</source>
          <target state="translated">&lt;code&gt;apply&lt;/code&gt; 和的返回值 &lt;code&gt;also&lt;/code&gt; 上下文对象本身。因此，它们可以作为&lt;em&gt;副步骤&lt;/em&gt;包含在调用链中：您可以在它们之后继续在同一对象上链接函数调用。</target>
        </trans-unit>
        <trans-unit id="6d324367f598aa028770dca0838f66177648fed1" translate="yes" xml:space="preserve">
          <source>The return value.</source>
          <target state="translated">返回值。</target>
        </trans-unit>
        <trans-unit id="046b6584c1bbd3a7a64857edece72cc830dec917" translate="yes" xml:space="preserve">
          <source>The returned instance uses the specified &lt;a href=&quot;lazy#kotlin%24lazy%28kotlin.Any%2C+kotlin.Function0%28%28kotlin.lazy.T%29%29%29%2Flock&quot;&gt;lock&lt;/a&gt; object to synchronize on. When the &lt;a href=&quot;lazy#kotlin%24lazy%28kotlin.Any%2C+kotlin.Function0%28%28kotlin.lazy.T%29%29%29%2Flock&quot;&gt;lock&lt;/a&gt; is not specified the instance uses itself to synchronize on, in this case do not synchronize from external code on the returned instance as it may cause accidental deadlock. Also this behavior can be changed in the future.</source>
          <target state="translated">返回的实例使用指定的&lt;a href=&quot;lazy#kotlin%24lazy%28kotlin.Any%2C+kotlin.Function0%28%28kotlin.lazy.T%29%29%29%2Flock&quot;&gt;锁定&lt;/a&gt;对象进行同步。如果未指定&lt;a href=&quot;lazy#kotlin%24lazy%28kotlin.Any%2C+kotlin.Function0%28%28kotlin.lazy.T%29%29%29%2Flock&quot;&gt;锁，&lt;/a&gt;则实例将使用自身进行同步，在这种情况下，请勿与返回的实例上的外部代码进行同步，因为这可能会导致意外的死锁。同样，将来可以更改此行为。</target>
        </trans-unit>
        <trans-unit id="97bfc2ca377533226a66b10393317b0a2f994fba" translate="yes" xml:space="preserve">
          <source>The returned list is empty if this char sequence contains less than two characters.</source>
          <target state="translated">如果这个字符序列包含的字符数少于两个,则返回的列表为空。</target>
        </trans-unit>
        <trans-unit id="d158c2273db93047119908af61efbbba35bd76f3" translate="yes" xml:space="preserve">
          <source>The returned list is empty if this collection contains less than two elements.</source>
          <target state="translated">如果这个集合包含的元素少于两个,则返回的列表为空。</target>
        </trans-unit>
        <trans-unit id="29bbad5c305945f97c70cd75ffccab450111f2ea" translate="yes" xml:space="preserve">
          <source>The returned map is serializable (JVM).</source>
          <target state="translated">返回的地图是可序列化的(JVM)。</target>
        </trans-unit>
        <trans-unit id="ec4d25dd41a10ce08bae955efed7031764938b43" translate="yes" xml:space="preserve">
          <source>The returned map is serializable.</source>
          <target state="translated">返回的地图是可序列化的。</target>
        </trans-unit>
        <trans-unit id="6f1137c5bd275e0d050f73fe1ffb45e6bc0fef52" translate="yes" xml:space="preserve">
          <source>The returned map preserves the entry iteration order of the keys produced from the original array.</source>
          <target state="translated">返回的映射保留了从原始数组产生的键的入口迭代顺序。</target>
        </trans-unit>
        <trans-unit id="aab8c4af63582433af11da060d436e3782362d9a" translate="yes" xml:space="preserve">
          <source>The returned map preserves the entry iteration order of the keys produced from the original char sequence.</source>
          <target state="translated">返回的映射保留了从原始char序列产生的键的入口迭代顺序。</target>
        </trans-unit>
        <trans-unit id="16f1a5aa5ffd50a8f9547783402bf7757df5025f" translate="yes" xml:space="preserve">
          <source>The returned map preserves the entry iteration order of the keys produced from the original collection.</source>
          <target state="translated">返回的映射保留了从原始集合产生的键的入口迭代顺序。</target>
        </trans-unit>
        <trans-unit id="19c068ac54b988c0d6076dddd8c2dbf4092708f6" translate="yes" xml:space="preserve">
          <source>The returned map preserves the entry iteration order of the keys produced from the original sequence.</source>
          <target state="translated">返回的映射保留了从原始序列产生的键的入口迭代顺序。</target>
        </trans-unit>
        <trans-unit id="f54f229a0ee8d8720d828fe3e27b2d2a6ca940bc" translate="yes" xml:space="preserve">
          <source>The returned map preserves the entry iteration order of the original array.</source>
          <target state="translated">返回的映射保留了原始数组的条目迭代顺序。</target>
        </trans-unit>
        <trans-unit id="918c726186d31885a03be5dd5847d194f356551f" translate="yes" xml:space="preserve">
          <source>The returned map preserves the entry iteration order of the original array. If any of two pairs would have the same key the last one gets added to the map.</source>
          <target state="translated">返回的映射保留了原始数组的条目迭代顺序。如果两个数组中的任何一个数组有相同的键,则最后一个数组会被添加到映射中。</target>
        </trans-unit>
        <trans-unit id="1331dc1f7dcbe48a5148654c3f9a9dd17b60c885" translate="yes" xml:space="preserve">
          <source>The returned map preserves the entry iteration order of the original char sequence.</source>
          <target state="translated">返回的映射保留了原始char序列的入口迭代顺序。</target>
        </trans-unit>
        <trans-unit id="566ed3a9dcb7ca74d4f2c70c6fdf84ac896debb5" translate="yes" xml:space="preserve">
          <source>The returned map preserves the entry iteration order of the original collection.</source>
          <target state="translated">返回的地图保留了原始集合的条目迭代顺序。</target>
        </trans-unit>
        <trans-unit id="2e469a2caf818c0835cee9e0a1babf1e2e3c07a5" translate="yes" xml:space="preserve">
          <source>The returned map preserves the entry iteration order of the original collection. If any of two pairs would have the same key the last one gets added to the map.</source>
          <target state="translated">返回的映射保留了原始集合的条目迭代顺序。如果任何两个对有相同的键,最后一个会被添加到映射中。</target>
        </trans-unit>
        <trans-unit id="4c19d30d5fb69c54a255c5b1e548f2fa56d3aefb" translate="yes" xml:space="preserve">
          <source>The returned map preserves the entry iteration order of the original map.</source>
          <target state="translated">返回的地图保留了原始地图的条目迭代顺序。</target>
        </trans-unit>
        <trans-unit id="f87204408405ad88a40594eff8f4867029a89b59" translate="yes" xml:space="preserve">
          <source>The returned map preserves the entry iteration order of the original map. The &lt;a href=&quot;plus#kotlin.collections%24plus%28kotlin.collections.Map%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%2C+kotlin.Pair%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%29%2Fpair&quot;&gt;pair&lt;/a&gt; is iterated in the end if it has a unique key.</source>
          <target state="translated">返回的地图保留了原始地图的输入迭代顺序。如果该&lt;a href=&quot;plus#kotlin.collections%24plus%28kotlin.collections.Map%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%2C+kotlin.Pair%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%29%2Fpair&quot;&gt;对&lt;/a&gt;具有唯一密钥，则最后对其进行迭代。</target>
        </trans-unit>
        <trans-unit id="8ff3f66b8173f81182161d671f67a90a7b9f8d74" translate="yes" xml:space="preserve">
          <source>The returned map preserves the entry iteration order of the original map. Those &lt;a href=&quot;plus#kotlin.collections%24plus%28kotlin.collections.Map%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%2C+kotlin.Array%28%28kotlin.Pair%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%29%29%29%2Fpairs&quot;&gt;pairs&lt;/a&gt; with unique keys are iterated in the end in the order of &lt;a href=&quot;plus#kotlin.collections%24plus%28kotlin.collections.Map%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%2C+kotlin.Array%28%28kotlin.Pair%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%29%29%29%2Fpairs&quot;&gt;pairs&lt;/a&gt; array.</source>
          <target state="translated">返回的地图保留了原始地图的输入迭代顺序。那些&lt;a href=&quot;plus#kotlin.collections%24plus%28kotlin.collections.Map%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%2C+kotlin.Array%28%28kotlin.Pair%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%29%29%29%2Fpairs&quot;&gt;对&lt;/a&gt;具有独特的键被迭代中的顺序结束&lt;a href=&quot;plus#kotlin.collections%24plus%28kotlin.collections.Map%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%2C+kotlin.Array%28%28kotlin.Pair%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%29%29%29%2Fpairs&quot;&gt;对&lt;/a&gt;数组。</target>
        </trans-unit>
        <trans-unit id="4c15bc5f538aa94ff9d36f2c463553e37bffffa8" translate="yes" xml:space="preserve">
          <source>The returned map preserves the entry iteration order of the original map. Those &lt;a href=&quot;plus#kotlin.collections%24plus%28kotlin.collections.Map%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%2C+kotlin.collections.Iterable%28%28kotlin.Pair%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%29%29%29%2Fpairs&quot;&gt;pairs&lt;/a&gt; with unique keys are iterated in the end in the order of &lt;a href=&quot;plus#kotlin.collections%24plus%28kotlin.collections.Map%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%2C+kotlin.collections.Iterable%28%28kotlin.Pair%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%29%29%29%2Fpairs&quot;&gt;pairs&lt;/a&gt; collection.</source>
          <target state="translated">返回的地图保留了原始地图的输入迭代顺序。最后，按照&lt;a href=&quot;plus#kotlin.collections%24plus%28kotlin.collections.Map%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%2C+kotlin.collections.Iterable%28%28kotlin.Pair%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%29%29%29%2Fpairs&quot;&gt;对&lt;/a&gt;集合的顺序对那些具有唯一密钥的&lt;a href=&quot;plus#kotlin.collections%24plus%28kotlin.collections.Map%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%2C+kotlin.collections.Iterable%28%28kotlin.Pair%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%29%29%29%2Fpairs&quot;&gt;对&lt;/a&gt;进行迭代。</target>
        </trans-unit>
        <trans-unit id="41524b28b32f1890886788ed586175d793500478" translate="yes" xml:space="preserve">
          <source>The returned map preserves the entry iteration order of the original map. Those &lt;a href=&quot;plus#kotlin.collections%24plus%28kotlin.collections.Map%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%2C+kotlin.sequences.Sequence%28%28kotlin.Pair%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%29%29%29%2Fpairs&quot;&gt;pairs&lt;/a&gt; with unique keys are iterated in the end in the order of &lt;a href=&quot;plus#kotlin.collections%24plus%28kotlin.collections.Map%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%2C+kotlin.sequences.Sequence%28%28kotlin.Pair%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%29%29%29%2Fpairs&quot;&gt;pairs&lt;/a&gt; sequence.</source>
          <target state="translated">返回的地图保留了原始地图的输入迭代顺序。最后，按照&lt;a href=&quot;plus#kotlin.collections%24plus%28kotlin.collections.Map%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%2C+kotlin.sequences.Sequence%28%28kotlin.Pair%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%29%29%29%2Fpairs&quot;&gt;对&lt;/a&gt;顺序的顺序对那些具有唯一密钥的&lt;a href=&quot;plus#kotlin.collections%24plus%28kotlin.collections.Map%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%2C+kotlin.sequences.Sequence%28%28kotlin.Pair%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%29%29%29%2Fpairs&quot;&gt;对&lt;/a&gt;进行迭代。</target>
        </trans-unit>
        <trans-unit id="af1ab049b7a80d37b426b5189d29b3d33630f886" translate="yes" xml:space="preserve">
          <source>The returned map preserves the entry iteration order of the original map. Those entries of another &lt;a href=&quot;plus#kotlin.collections%24plus%28kotlin.collections.Map%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%2C+kotlin.collections.Map%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%29%2Fmap&quot;&gt;map&lt;/a&gt; that are missing in this map are iterated in the end in the order of that &lt;a href=&quot;plus#kotlin.collections%24plus%28kotlin.collections.Map%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%2C+kotlin.collections.Map%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%29%2Fmap&quot;&gt;map&lt;/a&gt;.</source>
          <target state="translated">返回的地图保留了原始地图的输入迭代顺序。最后，按照该&lt;a href=&quot;plus#kotlin.collections%24plus%28kotlin.collections.Map%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%2C+kotlin.collections.Map%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%29%2Fmap&quot;&gt;映射&lt;/a&gt;的顺序对另一个&lt;a href=&quot;plus#kotlin.collections%24plus%28kotlin.collections.Map%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%2C+kotlin.collections.Map%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%29%2Fmap&quot;&gt;映射&lt;/a&gt;中缺少的条目进行迭代。</target>
        </trans-unit>
        <trans-unit id="048dcd341f30e50bd04dda11327a4ef88e0d2612" translate="yes" xml:space="preserve">
          <source>The returned map preserves the entry iteration order of the original sequence.</source>
          <target state="translated">返回的映射保留了原始序列的入口迭代顺序。</target>
        </trans-unit>
        <trans-unit id="bba2889b44a4cec09a40249a683767a797d71e14" translate="yes" xml:space="preserve">
          <source>The returned map preserves the entry iteration order of the original sequence. If any of two pairs would have the same key the last one gets added to the map.</source>
          <target state="translated">返回的映射保留了原始序列的条目迭代顺序。如果任何两对中有相同的键,最后一个会被添加到映射中。</target>
        </trans-unit>
        <trans-unit id="b48dc5da4ba5d84bf8f51570f1be30c9067ca36a" translate="yes" xml:space="preserve">
          <source>The returned map preserves the entry iteration order.</source>
          <target state="translated">返回的地图保留了条目迭代顺序。</target>
        </trans-unit>
        <trans-unit id="d70c61d5fb5764eefc41a239b3b607225317f588" translate="yes" xml:space="preserve">
          <source>The returned sequence is constrained to be iterated only once.</source>
          <target state="translated">返回的序列被约束为只能迭代一次。</target>
        </trans-unit>
        <trans-unit id="a79b9e6a21565ad6033f2ab5027e737873a51569" translate="yes" xml:space="preserve">
          <source>The returned sequence is empty if this sequence contains less than two elements.</source>
          <target state="translated">如果这个序列包含的元素少于两个,则返回的序列为空。</target>
        </trans-unit>
        <trans-unit id="7927ae1e5106eaeb7bb0b0dc1138826c33d1919c" translate="yes" xml:space="preserve">
          <source>The returned set preserves the element iteration order of the original array.</source>
          <target state="translated">返回的集合保留了原始数组的元素迭代顺序。</target>
        </trans-unit>
        <trans-unit id="8e820b287237249236a403161f0b70ed17d391a2" translate="yes" xml:space="preserve">
          <source>The returned set preserves the element iteration order of the original array. Those elements of the &lt;a href=&quot;union#kotlin.collections%24union%28kotlin.Array%28%28kotlin.collections.union.T%29%29%2C+kotlin.collections.Iterable%28%28kotlin.collections.union.T%29%29%29%2Fother&quot;&gt;other&lt;/a&gt; collection that are unique are iterated in the end in the order of the &lt;a href=&quot;union#kotlin.collections%24union%28kotlin.Array%28%28kotlin.collections.union.T%29%29%2C+kotlin.collections.Iterable%28%28kotlin.collections.union.T%29%29%29%2Fother&quot;&gt;other&lt;/a&gt; collection.</source>
          <target state="translated">返回的集合保留原始数组的元素迭代顺序。最后，以&lt;a href=&quot;union#kotlin.collections%24union%28kotlin.Array%28%28kotlin.collections.union.T%29%29%2C+kotlin.collections.Iterable%28%28kotlin.collections.union.T%29%29%29%2Fother&quot;&gt;另一个&lt;/a&gt;集合的顺序迭代&lt;a href=&quot;union#kotlin.collections%24union%28kotlin.Array%28%28kotlin.collections.union.T%29%29%2C+kotlin.collections.Iterable%28%28kotlin.collections.union.T%29%29%29%2Fother&quot;&gt;另一个&lt;/a&gt;集合中唯一的那些元素。</target>
        </trans-unit>
        <trans-unit id="b2b309c05bb0df5183017b60bb11949ef16cec12" translate="yes" xml:space="preserve">
          <source>The returned set preserves the element iteration order of the original char sequence.</source>
          <target state="translated">返回的集合保留了原始char序列的元素迭代顺序。</target>
        </trans-unit>
        <trans-unit id="77b699621c7e191100bcd082c9accf071cd60f08" translate="yes" xml:space="preserve">
          <source>The returned set preserves the element iteration order of the original collection.</source>
          <target state="translated">返回的集合保留了原始集合的元素迭代顺序。</target>
        </trans-unit>
        <trans-unit id="ed96aca660cbd3c3aee98cb1f013ac3448395f47" translate="yes" xml:space="preserve">
          <source>The returned set preserves the element iteration order of the original collection. Those elements of the &lt;a href=&quot;union#kotlin.collections%24union%28kotlin.collections.Iterable%28%28kotlin.collections.union.T%29%29%2C+kotlin.collections.Iterable%28%28kotlin.collections.union.T%29%29%29%2Fother&quot;&gt;other&lt;/a&gt; collection that are unique are iterated in the end in the order of the &lt;a href=&quot;union#kotlin.collections%24union%28kotlin.collections.Iterable%28%28kotlin.collections.union.T%29%29%2C+kotlin.collections.Iterable%28%28kotlin.collections.union.T%29%29%29%2Fother&quot;&gt;other&lt;/a&gt; collection.</source>
          <target state="translated">返回的集合保留原始集合的元素迭代顺序。最后，按照&lt;a href=&quot;union#kotlin.collections%24union%28kotlin.collections.Iterable%28%28kotlin.collections.union.T%29%29%2C+kotlin.collections.Iterable%28%28kotlin.collections.union.T%29%29%29%2Fother&quot;&gt;另一个&lt;/a&gt;集合的顺序迭代&lt;a href=&quot;union#kotlin.collections%24union%28kotlin.collections.Iterable%28%28kotlin.collections.union.T%29%29%2C+kotlin.collections.Iterable%28%28kotlin.collections.union.T%29%29%29%2Fother&quot;&gt;另一个&lt;/a&gt;集合中唯一的那些元素。</target>
        </trans-unit>
        <trans-unit id="b556a6977dd4e71f20e303d7d9385040d75f0ac7" translate="yes" xml:space="preserve">
          <source>The returned set preserves the element iteration order of the original sequence.</source>
          <target state="translated">返回的集合保留了原始序列的元素迭代顺序。</target>
        </trans-unit>
        <trans-unit id="eddbfc5096c56b9aafbe04f2e54352a74a62ad62" translate="yes" xml:space="preserve">
          <source>The returned set preserves the element iteration order of the original set.</source>
          <target state="translated">返回的集合保留了原集合的元素迭代顺序。</target>
        </trans-unit>
        <trans-unit id="4e9b4d20ac671bfe117e4f28b0081ad091c327b5" translate="yes" xml:space="preserve">
          <source>The returned set preserves the element iteration order.</source>
          <target state="translated">返回的集合保留了元素迭代顺序。</target>
        </trans-unit>
        <trans-unit id="7c0e13333db8789388b9d52adff49d100d5cf6ca" translate="yes" xml:space="preserve">
          <source>The returned value is &lt;code&gt;y&lt;/code&gt; such that &lt;code&gt;sinh(y) == x&lt;/code&gt;.</source>
          <target state="translated">返回值是 &lt;code&gt;y&lt;/code&gt; ，使得 &lt;code&gt;sinh(y) == x&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f0a819fc71728e449a1fa0a52b2d805fcb67dfe6" translate="yes" xml:space="preserve">
          <source>The returned value is &lt;code&gt;y&lt;/code&gt; such that &lt;code&gt;tanh(y) == x&lt;/code&gt;.</source>
          <target state="translated">返回值是 &lt;code&gt;y&lt;/code&gt; ，使得 &lt;code&gt;tanh(y) == x&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="38db1bb7310932e868d4c70216856f90e11179f2" translate="yes" xml:space="preserve">
          <source>The returned value is positive &lt;code&gt;y&lt;/code&gt; such that &lt;code&gt;cosh(y) == x&lt;/code&gt;.</source>
          <target state="translated">返回值是正 &lt;code&gt;y&lt;/code&gt; ，使得 &lt;code&gt;cosh(y) == x&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="92462ffebca930d13f4cb4aaee4b7842f4ea14de" translate="yes" xml:space="preserve">
          <source>The returned value of a &lt;em&gt;try&lt;/em&gt;-expression is either the last expression in the &lt;em&gt;try&lt;/em&gt; block or the last expression in the &lt;em&gt;catch&lt;/em&gt; block (or blocks). Contents of the &lt;em&gt;finally&lt;/em&gt; block do not affect the result of the expression.</source>
          <target state="translated">&lt;em&gt;try&lt;/em&gt; -expression 的返回值是&lt;em&gt;try&lt;/em&gt;块中的最后一个表达式或&lt;em&gt;catch&lt;/em&gt;块（或多个块）中的最后一个表达式。&lt;em&gt;finally&lt;/em&gt;块的内容不影响表达式的结果。</target>
        </trans-unit>
        <trans-unit id="261319d8fec52739ec6c832665ae3f7dbd0e5025" translate="yes" xml:space="preserve">
          <source>The root of the Kotlin class hierarchy. Every Kotlin class has &lt;a href=&quot;-any/index#kotlin.Any&quot;&gt;Any&lt;/a&gt; as a superclass.</source>
          <target state="translated">Kotlin类层次结构的根。每个Kotlin类都有&lt;a href=&quot;-any/index#kotlin.Any&quot;&gt;Any&lt;/a&gt;作为超类。</target>
        </trans-unit>
        <trans-unit id="a55ae833319a2f8e509e5aee918452e19eb747a8" translate="yes" xml:space="preserve">
          <source>The root of the Kotlin class hierarchy. Every Kotlin class has &lt;a href=&quot;index#kotlin.Any&quot;&gt;Any&lt;/a&gt; as a superclass.</source>
          <target state="translated">Kotlin类层次结构的根。每个Kotlin类都有&lt;a href=&quot;index#kotlin.Any&quot;&gt;Any&lt;/a&gt;作为超类。</target>
        </trans-unit>
        <trans-unit id="98512a74a1640b8252b93eb9be999aab21267c59" translate="yes" xml:space="preserve">
          <source>The runner will set the value for the property system.path.macro.KOTLIN.BUNDLED to the correct one based on the path settings from the IntelliJ IDEA project. However this value needs to be defined in TeamCity (and can be set to any value). Therefore we need to define it as a system variable.</source>
          <target state="translated">运行器将根据IntelliJ IDEA项目中的路径设置,将属性system.path.macro.KOTLIN.BUNDLED的值设置为正确的值。然而这个值需要在TeamCity中定义(可以设置为任何值)。因此我们需要将其定义为一个系统变量。</target>
        </trans-unit>
        <trans-unit id="578262526068b614504d1b18d76cf8dea19e1504" translate="yes" xml:space="preserve">
          <source>The same is available for maps with the functions &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/map-of&quot;&gt;&lt;code&gt;mapOf()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/mutable-map-of&quot;&gt;&lt;code&gt;mutableMapOf()&lt;/code&gt;&lt;/a&gt;. The map's keys and values are passed as &lt;code&gt;Pair&lt;/code&gt; objects (usually created with &lt;code&gt;to&lt;/code&gt; infix function).</source>
          <target state="translated">具有&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/mutable-map-of&quot;&gt; &lt;code&gt;mutableMapOf()&lt;/code&gt; &lt;/a&gt;和mutableMapOf（）函数的&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/map-of&quot;&gt; &lt;code&gt;mapOf()&lt;/code&gt; &lt;/a&gt;也可以使用此功能。映射的键和值作为 &lt;code&gt;Pair&lt;/code&gt; 对象（通常使用 &lt;code&gt;to&lt;/code&gt; infix函数创建）传递。</target>
        </trans-unit>
        <trans-unit id="25f5c97c541192ff226fb77118f20b9141f29a81" translate="yes" xml:space="preserve">
          <source>The same rules are used by the Kotlin/Native compiler to generate the &lt;code&gt;.h&lt;/code&gt; file for all platforms.</source>
          <target state="translated">Kotlin / Native编译器使用相同的规则为所有平台生成 &lt;code&gt;.h&lt;/code&gt; 文件。</target>
        </trans-unit>
        <trans-unit id="dac2ac98305c82e23b60095cae0d9b066592bfa3" translate="yes" xml:space="preserve">
          <source>The same set of functions (but without constants) is also available for &lt;code&gt;Float&lt;/code&gt; arguments.</source>
          <target state="translated">相同的函数集（但没有常量）也可用于 &lt;code&gt;Float&lt;/code&gt; 参数。</target>
        </trans-unit>
        <trans-unit id="afd6887219148439be70535c83e0ab200b27625e" translate="yes" xml:space="preserve">
          <source>The same syntax can be used to annotate the entire file. To do this, put an annotation with the target &lt;code&gt;file&lt;/code&gt; at the top level of a file, before the package directive or before all imports if the file is in the default package:</source>
          <target state="translated">可以使用相同的语法来注释整个文件。为此，请将注释与目标 &lt;code&gt;file&lt;/code&gt; 一起放在文件的最高级别，package指令之前或所有导入之前（如果该文件位于默认软件包中）：</target>
        </trans-unit>
        <trans-unit id="2ae227fcecaec9d7de3afec1996267608672f87b" translate="yes" xml:space="preserve">
          <source>The same syntax with omitted type arguments can be used for casts that do not take type arguments into account: &lt;code&gt;list as ArrayList&lt;/code&gt;.</source>
          <target state="translated">省略类型参数的语法可以用于不考虑类型参数的类型转换： &lt;code&gt;list as ArrayList&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="998fefac425fa7727b709de3b80c938ce507ca90" translate="yes" xml:space="preserve">
          <source>The same trick applies when we need to have a property &lt;code&gt;x&lt;/code&gt; alongside with a function &lt;code&gt;getX()&lt;/code&gt;:</source>
          <target state="translated">当我们需要同时具有属性 &lt;code&gt;x&lt;/code&gt; 和函数 &lt;code&gt;getX()&lt;/code&gt; 时，同样的技巧也适用：</target>
        </trans-unit>
        <trans-unit id="7028478d43f0e9046e167eadedccdd38efaac612" translate="yes" xml:space="preserve">
          <source>The same type parameter can be used in both covariant and contravariant projections (because it's the generic classes that are being projected, not the type parameter):</source>
          <target state="translated">相同的类型参数可以在共变和反变投影中使用(因为被投影的是泛类,而不是类型参数)。</target>
        </trans-unit>
        <trans-unit id="e34374077b9198e942d005d02c16935775597fa6" translate="yes" xml:space="preserve">
          <source>The scale of the result is the same as the scale of &lt;code&gt;this&lt;/code&gt; (divident), and for rounding the &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/math/RoundingMode.html#HALF_EVEN&quot;&gt;RoundingMode.HALF_EVEN&lt;/a&gt; rounding mode is used.</source>
          <target state="translated">结果的小数位数与 &lt;code&gt;this&lt;/code&gt; （小数）的小数位数相同，并且用于取&lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/math/RoundingMode.html#HALF_EVEN&quot;&gt;整RoundingMode.HALF_EVEN取&lt;/a&gt;整模式。</target>
        </trans-unit>
        <trans-unit id="f22bffdb314393bc05bae9820f09e84c2f28f7a7" translate="yes" xml:space="preserve">
          <source>The scope for yielding values of a &lt;a href=&quot;-sequence/index&quot;&gt;Sequence&lt;/a&gt; or an &lt;a href=&quot;../kotlin.collections/-iterator/index#kotlin.collections.Iterator&quot;&gt;Iterator&lt;/a&gt;, provides &lt;a href=&quot;-sequence-scope/yield&quot;&gt;yield&lt;/a&gt; and &lt;a href=&quot;-sequence-scope/yield-all&quot;&gt;yieldAll&lt;/a&gt; suspension functions.</source>
          <target state="translated">产生&lt;a href=&quot;-sequence/index&quot;&gt;Sequence&lt;/a&gt;或&lt;a href=&quot;../kotlin.collections/-iterator/index#kotlin.collections.Iterator&quot;&gt;Iterator的&lt;/a&gt;值的范围提供了&lt;a href=&quot;-sequence-scope/yield&quot;&gt;yield&lt;/a&gt;和&lt;a href=&quot;-sequence-scope/yield-all&quot;&gt;yieldAll&lt;/a&gt;暂停函数。</target>
        </trans-unit>
        <trans-unit id="4a3f3df589995633decc0a7530a1bb032d855ae5" translate="yes" xml:space="preserve">
          <source>The scope for yielding values of a &lt;a href=&quot;../-sequence/index&quot;&gt;Sequence&lt;/a&gt; or an &lt;a href=&quot;../../kotlin.collections/-iterator/index#kotlin.collections.Iterator&quot;&gt;Iterator&lt;/a&gt;, provides &lt;a href=&quot;yield&quot;&gt;yield&lt;/a&gt; and &lt;a href=&quot;yield-all&quot;&gt;yieldAll&lt;/a&gt; suspension functions.</source>
          <target state="translated">产生&lt;a href=&quot;../-sequence/index&quot;&gt;Sequence&lt;/a&gt;或&lt;a href=&quot;../../kotlin.collections/-iterator/index#kotlin.collections.Iterator&quot;&gt;Iterator的&lt;/a&gt;值的范围提供了&lt;a href=&quot;yield&quot;&gt;yield&lt;/a&gt;和&lt;a href=&quot;yield-all&quot;&gt;yieldAll&lt;/a&gt;暂停函数。</target>
        </trans-unit>
        <trans-unit id="a36f2feb54110b2ee9d15c70833427be6cae37ba" translate="yes" xml:space="preserve">
          <source>The scope for yielding values of a &lt;a href=&quot;../../kotlin.sequences/-sequence/index&quot;&gt;Sequence&lt;/a&gt; or an &lt;a href=&quot;../../kotlin.collections/-iterator/index#kotlin.collections.Iterator&quot;&gt;Iterator&lt;/a&gt;, provides &lt;a href=&quot;../../kotlin.sequences/-sequence-scope/yield&quot;&gt;yield&lt;/a&gt; and &lt;a href=&quot;../../kotlin.sequences/-sequence-scope/yield-all&quot;&gt;yieldAll&lt;/a&gt; suspension functions.</source>
          <target state="translated">产生&lt;a href=&quot;../../kotlin.sequences/-sequence/index&quot;&gt;Sequence&lt;/a&gt;或&lt;a href=&quot;../../kotlin.collections/-iterator/index#kotlin.collections.Iterator&quot;&gt;Iterator的&lt;/a&gt;值的范围提供了&lt;a href=&quot;../../kotlin.sequences/-sequence-scope/yield&quot;&gt;yield&lt;/a&gt;和&lt;a href=&quot;../../kotlin.sequences/-sequence-scope/yield-all&quot;&gt;yieldAll&lt;/a&gt;暂停函数。</target>
        </trans-unit>
        <trans-unit id="f47c36946d42e828300cda7cb035fe509918aa59" translate="yes" xml:space="preserve">
          <source>The scope functions differ by the result they return:</source>
          <target state="translated">范围函数因其返回的结果而不同。</target>
        </trans-unit>
        <trans-unit id="8f4977d6e6dad61eba46e51272eff7452a6f78a7" translate="yes" xml:space="preserve">
          <source>The scope functions do not introduce any new technical capabilities, but they can make your code more concise and readable.</source>
          <target state="translated">范围函数并没有引入任何新的技术能力,但它们可以使你的代码更加简洁和可读。</target>
        </trans-unit>
        <trans-unit id="5f41bf24b11179244ce6543e55a837627d8700cb" translate="yes" xml:space="preserve">
          <source>The second line is the &lt;code&gt;headerFilter&lt;/code&gt;. This is used to denote what exactly we want included. In C, when one file references another file with the &lt;code&gt;#include&lt;/code&gt; directive, all the headers are also included. Sometimes this may not be needed, and we can use this parameter, &lt;a href=&quot;https://en.wikipedia.org/wiki/Glob_(programming)&quot;&gt;using glob patterns&lt;/a&gt;, to fine tune things. Note, that &lt;code&gt;headerFilter&lt;/code&gt; is an optional argument and mostly only used when the library we're using is being installed as a system library, and we do not want to fetch external dependencies (such as system &lt;code&gt;stdint.h&lt;/code&gt; header) into our interop library. It may be important for both optimizing the library size and fixing potential conflicts between the system and the Kotlin/Native provided compilation environment.</source>
          <target state="translated">第二行是 &lt;code&gt;headerFilter&lt;/code&gt; 。这用来表示我们想要包含的内容。在C语言中，当一个文件使用 &lt;code&gt;#include&lt;/code&gt; 指令引用另一个文件时，还将包含所有标头。有时可能不需要这样做，我们可以使用&lt;a href=&quot;https://en.wikipedia.org/wiki/Glob_(programming)&quot;&gt;glob模式&lt;/a&gt;使用此参数来微调事物。请注意， &lt;code&gt;headerFilter&lt;/code&gt; 是一个可选参数，并且仅在将要使用的库作为系统库安装时才使用，并且我们不想将外部依赖项（例如系统 &lt;code&gt;stdint.h&lt;/code&gt; 标头）提取到我们的互操作库中。这对于优化库大小以及修复系统与Kotlin / Native提供的编译环境之间的潜在冲突都可能很重要。</target>
        </trans-unit>
        <trans-unit id="840619ade32a5f33b95550212b369e6072d8ca9d" translate="yes" xml:space="preserve">
          <source>The second list contains the second elements.</source>
          <target state="translated">第二个列表包含第二个元素。</target>
        </trans-unit>
        <trans-unit id="61c6cf9e9e7f1d565d89fe5986da63f4fbcd432b" translate="yes" xml:space="preserve">
          <source>The second observation, is that &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/on-receive-or-null.html&quot;&gt;onReceiveOrNull&lt;/a&gt; gets immediately selected when the channel is already closed.</source>
          <target state="translated">第二个观察结果是，当通道已经关闭时，&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/on-receive-or-null.html&quot;&gt;onReceiveOrNull&lt;/a&gt;立即被选择。</target>
        </trans-unit>
        <trans-unit id="90bb330cf5e09011380c337ab5bbdf9ebc55c7f5" translate="yes" xml:space="preserve">
          <source>The second step is to configure the framework search path of the produced binary. It is also known as &lt;code&gt;rpath&lt;/code&gt; or &lt;a href=&quot;https://en.wikipedia.org/wiki/Rpath&quot;&gt;run-time search path&lt;/a&gt;. The binary uses the path to look for the required frameworks. We do not recommend installing additional frameworks to the OS if it is not needed. We should understand the layout of our future application, for example, we may have the &lt;code&gt;Frameworks&lt;/code&gt; folder under the application bundle with all the frameworks we use. The &lt;code&gt;@rpath&lt;/code&gt; parameter can be configured in Xcode. We need to open the &lt;em&gt;project&lt;/em&gt; configuration and find the &lt;code&gt;Runpath Search Paths&lt;/code&gt; section. Here we specify the relative path to the compiled framework.</source>
          <target state="translated">第二步是配置生成的二进制文件的框架搜索路径。也称为 &lt;code&gt;rpath&lt;/code&gt; 或&lt;a href=&quot;https://en.wikipedia.org/wiki/Rpath&quot;&gt;运行时搜索路径&lt;/a&gt;。二进制文件使用该路径查找所需的框架。如果不需要，我们不建议在操作系统上安装其他框架。我们应该了解未来应用程序的布局，例如，在应用程序捆绑包中，我们可能会拥有所有使用的框架的 &lt;code&gt;Frameworks&lt;/code&gt; 文件夹。所述 &lt;code&gt;@rpath&lt;/code&gt; 参数可以在Xcode进行配置。我们需要打开&lt;em&gt;项目&lt;/em&gt;配置并找到&amp;ldquo; &lt;code&gt;Runpath Search Paths&lt;/code&gt; 部分。在这里，我们指定了已编译框架的相对路径。</target>
        </trans-unit>
        <trans-unit id="654406bf07807fb9a1c468fda5253d223f604a77" translate="yes" xml:space="preserve">
          <source>The second step is to then include the framework path into the &lt;code&gt;Framework Search Paths&lt;/code&gt; block of the &lt;code&gt;Build Settings&lt;/code&gt; section of the &lt;em&gt;target&lt;/em&gt; configuration page. It is possible to use &lt;code&gt;$(PROJECT_DIR)&lt;/code&gt; macro to simplify the setup.</source>
          <target state="translated">然后，第二步是将框架路径包括在&lt;em&gt;目标&lt;/em&gt;配置页面的&amp;ldquo; &lt;code&gt;Build Settings&lt;/code&gt; 部分的&amp;ldquo; &lt;code&gt;Framework Search Paths&lt;/code&gt; 块中。可以使用 &lt;code&gt;$(PROJECT_DIR)&lt;/code&gt; 宏来简化设置。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="18e3a3f25c81d64436deec2668dbca688024cd76" translate="yes" xml:space="preserve">
          <source>The second way is using typed getters. These getters allow one to access a binary of a certain type by its name prefix and build type.</source>
          <target state="translated">第二种方式是使用类型化的获取器。这些获取器允许人们通过其名称前缀和构建类型来访问某个类型的二进制。</target>
        </trans-unit>
        <trans-unit id="827737115fbde8c1114cdac2570a8c2c25e8999d" translate="yes" xml:space="preserve">
          <source>The sequence can be iterated multiple times, each time starting with &lt;a href=&quot;generate-sequence#kotlin.sequences%24generateSequence%28kotlin.sequences.generateSequence.T%2C+kotlin.Function1%28%28kotlin.sequences.generateSequence.T%2C+kotlin.sequences.generateSequence.T%29%29%29%2Fseed&quot;&gt;seed&lt;/a&gt;.</source>
          <target state="translated">该序列可以迭代多次，每次都以&lt;a href=&quot;generate-sequence#kotlin.sequences%24generateSequence%28kotlin.sequences.generateSequence.T%2C+kotlin.Function1%28%28kotlin.sequences.generateSequence.T%2C+kotlin.sequences.generateSequence.T%29%29%29%2Fseed&quot;&gt;seed&lt;/a&gt;开头。</target>
        </trans-unit>
        <trans-unit id="0eda5b13d201be08982eef0e6ce47fb43644a540" translate="yes" xml:space="preserve">
          <source>The sequence can be iterated multiple times.</source>
          <target state="translated">该序列可以多次迭代。</target>
        </trans-unit>
        <trans-unit id="0a85208253c6224f238363151292bff48ddafdf4" translate="yes" xml:space="preserve">
          <source>The sequence can be potentially infinite.</source>
          <target state="translated">序列可以是潜在的无限的。</target>
        </trans-unit>
        <trans-unit id="0e5675a51efa9f06e75cacd0d5cc4fa5944cc8f4" translate="yes" xml:space="preserve">
          <source>The sequence of values returned by the given iterator can be potentially infinite.</source>
          <target state="translated">给定迭代器返回的值序列可能是无限的。</target>
        </trans-unit>
        <trans-unit id="7d79c1f34f116fdb6c923fac302558f761c71524" translate="yes" xml:space="preserve">
          <source>The sequence operations can be classified into the following groups regarding their state requirements:</source>
          <target state="translated">序列操作按其状态要求可分为以下几组。</target>
        </trans-unit>
        <trans-unit id="30c4d2821891f6cd1d6f9f4ff92091f8670df4f6" translate="yes" xml:space="preserve">
          <source>The sequence processing goes like this:</source>
          <target state="translated">顺序处理是这样的。</target>
        </trans-unit>
        <trans-unit id="037cfea620d6aaba99a768d063c28b857dfd0b60" translate="yes" xml:space="preserve">
          <source>The sequence produces values until it encounters first &lt;code&gt;null&lt;/code&gt; value. If &lt;a href=&quot;generate-sequence#kotlin.sequences%24generateSequence%28kotlin.Function0%28%28kotlin.sequences.generateSequence.T%29%29%2C+kotlin.Function1%28%28kotlin.sequences.generateSequence.T%2C+kotlin.sequences.generateSequence.T%29%29%29%2FseedFunction&quot;&gt;seedFunction&lt;/a&gt; returns &lt;code&gt;null&lt;/code&gt;, an empty sequence is produced.</source>
          <target state="translated">该序列产生值，直到遇到第一个 &lt;code&gt;null&lt;/code&gt; 值。如果&lt;a href=&quot;generate-sequence#kotlin.sequences%24generateSequence%28kotlin.Function0%28%28kotlin.sequences.generateSequence.T%29%29%2C+kotlin.Function1%28%28kotlin.sequences.generateSequence.T%2C+kotlin.sequences.generateSequence.T%29%29%29%2FseedFunction&quot;&gt;seedFunction&lt;/a&gt;返回 &lt;code&gt;null&lt;/code&gt; ，那么将生成一个空序列。</target>
        </trans-unit>
        <trans-unit id="6f1a48a2bbbc690466820f3b0f0b43bc4de3e6e5" translate="yes" xml:space="preserve">
          <source>The sequence produces values until it encounters first &lt;code&gt;null&lt;/code&gt; value. If &lt;a href=&quot;generate-sequence#kotlin.sequences%24generateSequence%28kotlin.sequences.generateSequence.T%2C+kotlin.Function1%28%28kotlin.sequences.generateSequence.T%2C+kotlin.sequences.generateSequence.T%29%29%29%2Fseed&quot;&gt;seed&lt;/a&gt; is &lt;code&gt;null&lt;/code&gt;, an empty sequence is produced.</source>
          <target state="translated">该序列产生值，直到遇到第一个 &lt;code&gt;null&lt;/code&gt; 值。如果&lt;a href=&quot;generate-sequence#kotlin.sequences%24generateSequence%28kotlin.sequences.generateSequence.T%2C+kotlin.Function1%28%28kotlin.sequences.generateSequence.T%2C+kotlin.sequences.generateSequence.T%29%29%29%2Fseed&quot;&gt;seed&lt;/a&gt;为 &lt;code&gt;null&lt;/code&gt; ，则产生一个空序列。</target>
        </trans-unit>
        <trans-unit id="5a3082b192dc0701c42da2f86e13f788df24a0f1" translate="yes" xml:space="preserve">
          <source>The set of all possible types that can be substituted for a given type parameter may be restricted by &lt;strong&gt;generic constraints&lt;/strong&gt;.</source>
          <target state="translated">可以用给定类型参数替代的所有可能类型的集合可能受到&lt;strong&gt;通用约束的限制&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="bf0dd762f332fcd86a0727fbb8e23b4a1bb32f29" translate="yes" xml:space="preserve">
          <source>The set of options that were used to create this regular expression.</source>
          <target state="translated">用于创建该正则表达式的一组选项。</target>
        </trans-unit>
        <trans-unit id="459759855b3639a06e88e0e2596d7493a847d411" translate="yes" xml:space="preserve">
          <source>The set of target platforms is defined by a multiplatform library author, and they should provide all of the platform-specific implementations for the library. Adding new targets for a multiplatform library at the consumer's side is not supported.</source>
          <target state="translated">目标平台的集合是由多平台库作者定义的,他们应该为库提供所有特定平台的实现。不支持在消费者端为多平台库添加新目标。</target>
        </trans-unit>
        <trans-unit id="488655893b603c994560325ea4e7b1458229763b" translate="yes" xml:space="preserve">
          <source>The setter of this mutable property, used to change the value of the property.</source>
          <target state="translated">这个可变属性的设置者,用来改变属性的值。</target>
        </trans-unit>
        <trans-unit id="67fe2f456972c4ac12399f4f27262af0c978820f" translate="yes" xml:space="preserve">
          <source>The signature of &lt;code&gt;greet()&lt;/code&gt; is &lt;code&gt;KFunction2&amp;lt;Person, String, String&amp;gt;&lt;/code&gt; because it's a function on &lt;code&gt;Person&lt;/code&gt; that takes a &lt;code&gt;String&lt;/code&gt; and returns a &lt;code&gt;String&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;greet()&lt;/code&gt; 的签名为 &lt;code&gt;KFunction2&amp;lt;Person, String, String&amp;gt;&lt;/code&gt; 因为它是 &lt;code&gt;Person&lt;/code&gt; 上的一个函数，它接受 &lt;code&gt;String&lt;/code&gt; 并返回 &lt;code&gt;String&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3e351be319f91b0a3ca4911e8fb9da8a9528097a" translate="yes" xml:space="preserve">
          <source>The signature of a member function or an &lt;a href=&quot;extension-functionsproperties&quot;&gt;extension function&lt;/a&gt; begins with a &lt;em&gt;receiver&lt;/em&gt;: the type upon which the function can be invoked. For example, the signature of &lt;code&gt;toString()&lt;/code&gt; is &lt;code&gt;Any.() -&amp;gt; String&lt;/code&gt; - it can be called on any non-null object (the receiver), it takes no parameters, and it returns a &lt;code&gt;String&lt;/code&gt;. It is possible to write a lambda function with such a signature - this is called a &lt;em&gt;function literal with receiver&lt;/em&gt;, and is extremely useful for building DSLs.</source>
          <target state="translated">成员函数或&lt;a href=&quot;extension-functionsproperties&quot;&gt;扩展函数&lt;/a&gt;的签名从&lt;em&gt;接收方&lt;/em&gt;开始：可以在其上调用函数的类型。例如， &lt;code&gt;toString()&lt;/code&gt; 的签名为 &lt;code&gt;Any.() -&amp;gt; String&lt;/code&gt; 可以在任何非null对象（接收方）上调用它，不使用任何参数，并且返回 &lt;code&gt;String&lt;/code&gt; 。可以使用这样的签名编写一个lambda函数-这被称为&lt;em&gt;带有Receiver&lt;/em&gt;的&lt;em&gt;函数文字，&lt;/em&gt;对于构建DSL非常有用。</target>
        </trans-unit>
        <trans-unit id="aadf52185468aa82855f792813cb9471782e9fa0" translate="yes" xml:space="preserve">
          <source>The signature of the overriding function must exactly match the overridden one, except that the return type in the overriding function may be a subtype of the return type of the overridden function.</source>
          <target state="translated">覆盖函数的签名必须与被覆盖函数完全一致,但覆盖函数中的返回类型可以是被覆盖函数返回类型的子类型。</target>
        </trans-unit>
        <trans-unit id="0290c571ea3c6c1d4ef5f1279658ebad7901a082" translate="yes" xml:space="preserve">
          <source>The simple name of the class as it was declared in the source code, or &lt;code&gt;null&lt;/code&gt; if the class has no name (if, for example, it is an anonymous object literal).</source>
          <target state="translated">在源代码中声明的类的简单名称；如果该类没有名称（例如，如果它是一个匿名对象文字），则为 &lt;code&gt;null&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4a78d65e883965ba15ad1eec8e7ccc645ad6c9f8" translate="yes" xml:space="preserve">
          <source>The simplest version doesn't require any additional parameters and creates one binary for each build type. Currently there a two build types available: &lt;code&gt;DEBUG&lt;/code&gt; (produces a not optimized binary with a debug information) and &lt;code&gt;RELEASE&lt;/code&gt; (produces an optimized binary without debug information). Consequently the following snippet creates two executable binaries: debug and release.</source>
          <target state="translated">最简单的版本不需要任何其他参数，并为每种构建类型创建一个二进制文件。当前有两种构建类型可用： &lt;code&gt;DEBUG&lt;/code&gt; （产生带有调试信息的未优化的二进制文件）和 &lt;code&gt;RELEASE&lt;/code&gt; （产生没有调试信息的已优化的二进制文件）。因此，以下代码段创建了两个可执行二进制文件：debug和release。</target>
        </trans-unit>
        <trans-unit id="0e7b9b0dd8fa90a8e9f2b4ea99f92d60e815b8b9" translate="yes" xml:space="preserve">
          <source>The single immutable C value. It is self-contained and doesn't depend on native memory.</source>
          <target state="translated">单一不可改变的C值。它是自成一体的,不依赖于本机内存。</target>
        </trans-unit>
        <trans-unit id="d8e685c40e1d41520bbfb52a9a2cf6ce5cf4d2b1" translate="yes" xml:space="preserve">
          <source>The single-parent rule often becomes too limiting, as you'll often find commonalities between classes in different branches of a class hierarchy. These commonalities can be expressed in &lt;em&gt;interfaces&lt;/em&gt;.</source>
          <target state="translated">单亲规则通常变得过于局限，因为您经常会发现类层次结构不同分支中的类之间存在共性。这些共同点可以在&lt;em&gt;接口中&lt;/em&gt;表达。</target>
        </trans-unit>
        <trans-unit id="ad2d029e0bf9000bbb670b32b9cfbfdfb5c64ee2" translate="yes" xml:space="preserve">
          <source>The solution is a &lt;em&gt;delegated property&lt;/em&gt;, which allows you to specify the behavior of getting and setting a property (somewhat similar to implementing &lt;code&gt;__getattribute__()&lt;/code&gt; and &lt;code&gt;__setattribute__()&lt;/code&gt; in Python, but for one property at a time).</source>
          <target state="translated">该解决方案是一个&lt;em&gt;委托属性&lt;/em&gt;，它允许您指定获取和设置属性的行为（有点类似于在Python中实现 &lt;code&gt;__getattribute__()&lt;/code&gt; 和 &lt;code&gt;__setattribute__()&lt;/code&gt; ，但一次只设置一个属性）。</target>
        </trans-unit>
        <trans-unit id="02ba30e8a0350e3498389f6bdcc51b4d923322f5" translate="yes" xml:space="preserve">
          <source>The solution is to mark the targets with a custom attribute, which is taken into account by Gradle during dependency resolution. This, however, must be done on both the library author and the consumer sides, and it's the library author's responsibility to communicate the attribute and its possible values to the consumers.</source>
          <target state="translated">解决办法是用一个自定义属性来标记目标,Gradle在解决依赖关系的过程中会考虑到这个属性。然而,这必须在库作者和消费者两方面进行,库作者有责任将属性及其可能的值传达给消费者。</target>
        </trans-unit>
        <trans-unit id="4ce364ecc8aca93a0b9f937690067d3d1f6fcb4e" translate="yes" xml:space="preserve">
          <source>The sort is &lt;em&gt;stable&lt;/em&gt;. It means that equal elements preserve their order relative to each other after sorting.</source>
          <target state="translated">排序是&lt;em&gt;稳定的&lt;/em&gt;。这意味着相等的元素在排序后保留相对于彼此的顺序。</target>
        </trans-unit>
        <trans-unit id="563e0866ee26fde4dae779a523cc71b4cbb6977d" translate="yes" xml:space="preserve">
          <source>The source set names are case-sensitive. When referring to a default source set by its name, make sure the name prefix matches a target's name, for example, a source set &lt;code&gt;iosX64Main&lt;/code&gt; for a target &lt;code&gt;iosX64&lt;/code&gt;.</source>
          <target state="translated">源集名称区分大小写。当提到它的名字默认源设置，确保名称前缀与对象的名称，例如，源设置 &lt;code&gt;iosX64Main&lt;/code&gt; 为目标 &lt;code&gt;iosX64&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="11b3468dd6e9b05386099434c4ca46b0c2547522" translate="yes" xml:space="preserve">
          <source>The source sets DSL can be used to define these connections between the source sets:</source>
          <target state="translated">源集DSL可以用来定义这些源集之间的连接。</target>
        </trans-unit>
        <trans-unit id="5ee1552c884a6b1c888ad99542230488f493bca7" translate="yes" xml:space="preserve">
          <source>The source sets are configured within a &lt;code&gt;sourceSets { ... }&lt;/code&gt; block of the &lt;code&gt;kotlin { ... }&lt;/code&gt; extension:</source>
          <target state="translated">源集在 &lt;code&gt;kotlin { ... }&lt;/code&gt; 扩展的 &lt;code&gt;sourceSets { ... }&lt;/code&gt; 块内配置：</target>
        </trans-unit>
        <trans-unit id="d4cf592997fcfc68c560b9248ead3349afe2d7c1" translate="yes" xml:space="preserve">
          <source>The specification of the requirements to the delegated object can be found &lt;a href=&quot;delegated-properties#property-delegate-requirements&quot;&gt;below&lt;/a&gt;.</source>
          <target state="translated">可以在&lt;a href=&quot;delegated-properties#property-delegate-requirements&quot;&gt;下面&lt;/a&gt;找到对委托对象的要求的规范。</target>
        </trans-unit>
        <trans-unit id="63949c8dfec16ede4c20d9d3cd58cdaf9f88fafe" translate="yes" xml:space="preserve">
          <source>The standard JavaDoc generation plugin (&lt;code&gt;maven-javadoc-plugin&lt;/code&gt;) does not support Kotlin code. To generate documentation for Kotlin projects, use &lt;a href=&quot;https://github.com/Kotlin/dokka&quot;&gt;Dokka&lt;/a&gt;; please refer to the &lt;a href=&quot;https://github.com/Kotlin/dokka/blob/master/README.md#using-the-maven-plugin&quot;&gt;Dokka README&lt;/a&gt; for configuration instructions. Dokka supports mixed-language projects and can generate output in multiple formats, including standard JavaDoc.</source>
          <target state="translated">标准的JavaDoc生成插件（ &lt;code&gt;maven-javadoc-plugin&lt;/code&gt; ）不支持Kotlin代码。要生成Kotlin项目的文档，请使用&lt;a href=&quot;https://github.com/Kotlin/dokka&quot;&gt;Dokka&lt;/a&gt;；请参阅&lt;a href=&quot;https://github.com/Kotlin/dokka/blob/master/README.md#using-the-maven-plugin&quot;&gt;Dokka自述文件&lt;/a&gt;以获取配置说明。Dokka支持混合语言项目，并且可以生成多种格式的输出，包括标准JavaDoc。</target>
        </trans-unit>
        <trans-unit id="bb8d32cf58d6a52257e9ed55a0d5c90647cf240f" translate="yes" xml:space="preserve">
          <source>The standard library contains a group of extension functions that let you filter collections in a single call. These functions leave the original collection unchanged, so they are available for both &lt;a href=&quot;collections-overview#collection-types&quot;&gt;mutable and read-only&lt;/a&gt; collections. To operate the filtering result, you should assign it to a variable or chain the functions after filtering.</source>
          <target state="translated">标准库包含一组扩展功能，使您可以在单个调用中过滤集合。这些函数使原始集合保持不变，因此它们可用于&lt;a href=&quot;collections-overview#collection-types&quot;&gt;可变&lt;/a&gt;集合和只读集合。要操作过滤结果，应将其分配给变量或在过滤后链接函数。</target>
        </trans-unit>
        <trans-unit id="64cd7cca211b28854215461360962734eb107f4c" translate="yes" xml:space="preserve">
          <source>The standard library defines a function named &lt;a href=&quot;../../../api/latest/jvm/stdlib/kotlin.js/as-dynamic&quot;&gt;&lt;code&gt;asDynamic()&lt;/code&gt;&lt;/a&gt; which casts a value to the dynamic type. Given our previous example where we used jQuery to work with DOM elements, we can now combine this with &lt;code&gt;asDynamic()&lt;/code&gt; to then invoke &lt;code&gt;dataTable()&lt;/code&gt; on the result:</source>
          <target state="translated">标准库定义了一个名为&lt;a href=&quot;../../../api/latest/jvm/stdlib/kotlin.js/as-dynamic&quot;&gt; &lt;code&gt;asDynamic()&lt;/code&gt; &lt;/a&gt;的函数，该函数将值转换为动态类型。在前面的示例中，我们使用jQuery处理DOM元素，现在我们可以将其与 &lt;code&gt;asDynamic()&lt;/code&gt; 结合起来，然后在结果上调用 &lt;code&gt;dataTable()&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="2f92a5708c1e21664731222bd701621446c56d87" translate="yes" xml:space="preserve">
          <source>The standard library now provides a set of functions for element-by-element operations on arrays: comparison (&lt;code&gt;contentEquals&lt;/code&gt; and &lt;code&gt;contentDeepEquals&lt;/code&gt;), hash code calculation (&lt;code&gt;contentHashCode&lt;/code&gt; and &lt;code&gt;contentDeepHashCode&lt;/code&gt;), and conversion to a string (&lt;code&gt;contentToString&lt;/code&gt; and &lt;code&gt;contentDeepToString&lt;/code&gt;). They're supported both for the JVM (where they act as aliases for the corresponding functions in &lt;code&gt;java.util.Arrays&lt;/code&gt;) and for JS (where the implementation is provided in the Kotlin standard library).</source>
          <target state="translated">现在，标准库为数组的逐个元素操作提供了一组函数：比较（ &lt;code&gt;contentEquals&lt;/code&gt; 和 &lt;code&gt;contentDeepEquals&lt;/code&gt; ），哈希码计算（ &lt;code&gt;contentHashCode&lt;/code&gt; 和 &lt;code&gt;contentDeepHashCode&lt;/code&gt; ）以及转换为字符串（ &lt;code&gt;contentToString&lt;/code&gt; 和 &lt;code&gt;contentDeepToString&lt;/code&gt; ）。他们的JVM（他们作为别名在相应的功能均支持 &lt;code&gt;java.util.Arrays&lt;/code&gt; 中）和JS（其中在科特林标准库提供的实现）。</target>
        </trans-unit>
        <trans-unit id="4cd1337efd07a01ae50fb56677c92729c05a2ca9" translate="yes" xml:space="preserve">
          <source>The standard library provides &lt;code&gt;Pair&lt;/code&gt; and &lt;code&gt;Triple&lt;/code&gt;. In most cases, though, named data classes are a better design choice, because they make the code more readable by providing meaningful names for properties.</source>
          <target state="translated">标准库提供 &lt;code&gt;Pair&lt;/code&gt; 和 &lt;code&gt;Triple&lt;/code&gt; 。但是，在大多数情况下，命名数据类是更好的设计选择，因为命名属性为属性提供有意义的名称，使代码更易读。</target>
        </trans-unit>
        <trans-unit id="0fa7bf33e28a4e2133f3eb85b822f13a5861e747" translate="yes" xml:space="preserve">
          <source>The standard library provides us with a series of wrappers around DOM as well as functions to work with JavaScript, using static typing. What happens however when we want to use a library such as jQuery? Kotlin does not have its own &quot;header&quot; files for all the different libraries available on the JavaScript ecosystem however, TypeScript does. The &lt;a href=&quot;https://github.com/DefinitelyTyped/DefinitelyTyped/&quot;&gt;Definitely Typed repository&lt;/a&gt; provides us with a very large selection of header files.</source>
          <target state="translated">标准库为我们提供了一系列有关DOM的包装器以及使用静态类型与JavaScript配合使用的函数。但是，当我们想使用jQuery之类的库时会发生什么？对于JavaScript生态系统上可用的所有不同库，Kotlin没有自己的&amp;ldquo;标头&amp;rdquo;文件，但是TypeScript有。在&lt;a href=&quot;https://github.com/DefinitelyTyped/DefinitelyTyped/&quot;&gt;肯定类型化资料库&lt;/a&gt;为我们提供了一个非常大的选择的头文件。</target>
        </trans-unit>
        <trans-unit id="5b02aa301d08018505c67b11eafce33e20430963" translate="yes" xml:space="preserve">
          <source>The standard library uses coroutines to support &lt;em&gt;lazily generated sequences&lt;/em&gt; with &lt;code&gt;yield&lt;/code&gt; and &lt;code&gt;yieldAll&lt;/code&gt; functions. In such a sequence, the block of code that returns sequence elements is suspended after each element has been retrieved, and resumed when the next element is requested. Here's an example:</source>
          <target state="translated">标准库使用协程支持具有 &lt;code&gt;yield&lt;/code&gt; 和 &lt;code&gt;yieldAll&lt;/code&gt; 函数的&lt;em&gt;延迟生成的序列&lt;/em&gt;。在这样的序列中，返回序列元素的代码块在检索到每个元素之后将被挂起，并在请求下一个元素时恢复。这是一个例子：</target>
        </trans-unit>
        <trans-unit id="bd81d65292e2ed27e6a7bd7b3f70e04e3c6f5969" translate="yes" xml:space="preserve">
          <source>The status value in &lt;code&gt;@UnderMigration(status = ...)&lt;/code&gt; specifies how the compiler treats inappropriate usages of the annotated types in Kotlin (e.g. using a &lt;code&gt;@MyNullable&lt;/code&gt;-annotated type value as non-null):</source>
          <target state="translated">&lt;code&gt;@UnderMigration(status = ...)&lt;/code&gt; 的状态值指定编译器如何对待Kotlin中带注释类型的不当用法（例如，使用 &lt;code&gt;@MyNullable&lt;/code&gt; -带注释类型的值作为非null）：</target>
        </trans-unit>
        <trans-unit id="4dfa4a2af58e962d2e78195bb041069a8bfddba3" translate="yes" xml:space="preserve">
          <source>The step of the progression.</source>
          <target state="translated">进阶的步骤。</target>
        </trans-unit>
        <trans-unit id="e2561323722fd466eed7e84734bba0e2d9a0a20e" translate="yes" xml:space="preserve">
          <source>The step value must be positive. If you need to count downwards, use the inclusive &lt;code&gt;downTo&lt;/code&gt;:</source>
          <target state="translated">步长值必须为正。如果需要向下计数，请使用包含在内的 &lt;code&gt;downTo&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="ba5dcc36cf4e926283f2cf38c8b5b4a8a22b74ac" translate="yes" xml:space="preserve">
          <source>The subclass &lt;em&gt;inherits&lt;/em&gt; all members that exist in its superclass - both those that are directly defined in the superclass and the ones that the superclass itself has inherited. In this example, &lt;code&gt;Car&lt;/code&gt; contains the following members:</source>
          <target state="translated">子类&lt;em&gt;继承&lt;/em&gt;其超类中存在的所有成员-既直接在超类中定义的成员，也包括超类本身已继承的成员。在此示例中， &lt;code&gt;Car&lt;/code&gt; 包含以下成员：</target>
        </trans-unit>
        <trans-unit id="9587208b56b71c873bb976ba7dd19e63565c1783" translate="yes" xml:space="preserve">
          <source>The substring from the input string captured by this match.</source>
          <target state="translated">本次匹配所捕获的输入字符串的子串。</target>
        </trans-unit>
        <trans-unit id="ef9d4de4ce3f425feef1d92bfbe702742ff76fe2" translate="yes" xml:space="preserve">
          <source>The syntax is: &lt;code&gt;val/var &amp;lt;property name&amp;gt;: &amp;lt;Type&amp;gt; by &amp;lt;expression&amp;gt;&lt;/code&gt;. The expression after &lt;em&gt;by&lt;/em&gt; is the &lt;em&gt;delegate&lt;/em&gt;, because &lt;code&gt;get()&lt;/code&gt; (and &lt;code&gt;set()&lt;/code&gt;) corresponding to the property will be delegated to its &lt;code&gt;getValue()&lt;/code&gt; and &lt;code&gt;setValue()&lt;/code&gt; methods. Property delegates don&amp;rsquo;t have to implement any interface, but they have to provide a &lt;code&gt;getValue()&lt;/code&gt; function (and &lt;code&gt;setValue()&lt;/code&gt; &amp;mdash; for &lt;em&gt;var&lt;/em&gt;s). For example:</source>
          <target state="translated">语法为： &lt;code&gt;val/var &amp;lt;property name&amp;gt;: &amp;lt;Type&amp;gt; by &amp;lt;expression&amp;gt;&lt;/code&gt; 。&lt;em&gt;by&lt;/em&gt;之后的表达式是&lt;em&gt;委托&lt;/em&gt;，因为与该属性对应的 &lt;code&gt;get()&lt;/code&gt; （和 &lt;code&gt;set()&lt;/code&gt; ）将委托给其 &lt;code&gt;getValue()&lt;/code&gt; 和 &lt;code&gt;setValue()&lt;/code&gt; 方法。属性委托不必实现任何接口，但是必须提供 &lt;code&gt;getValue()&lt;/code&gt; 函数（和 &lt;code&gt;setValue()&lt;/code&gt; －用于&lt;em&gt;var&lt;/em&gt;）。例如：</target>
        </trans-unit>
        <trans-unit id="7f8b0e5f27ed7447035e9e8912fa4868135e5b36" translate="yes" xml:space="preserve">
          <source>The table below shows how Kotlin concepts are mapped to Swift/Objective-C and vice versa.</source>
          <target state="translated">下表显示了Kotlin概念如何映射到Swift/Objective-C,反之亦然。</target>
        </trans-unit>
        <trans-unit id="27aee67b81ecee081c926fb6403fc250a2669b58" translate="yes" xml:space="preserve">
          <source>The targets created from presets are added to the &lt;code&gt;kotlin.targets&lt;/code&gt; domain object collection, which can be used to access them by their names or configure all targets:</source>
          <target state="translated">从预设创建的目标将添加到 &lt;code&gt;kotlin.targets&lt;/code&gt; 域对象集合中，可用于按其名称访问它们或配置所有目标：</target>
        </trans-unit>
        <trans-unit id="ea834ff7223c20a4c037e26a9eaa3ee2e490ee75" translate="yes" xml:space="preserve">
          <source>The terminology is that &lt;code&gt;var&lt;/code&gt; declares a &lt;em&gt;mutable&lt;/em&gt; variable, and that &lt;code&gt;val&lt;/code&gt; declares a &lt;em&gt;read-only&lt;/em&gt; or &lt;em&gt;assign-once&lt;/em&gt; variable - so both kinds are called &lt;em&gt;variables&lt;/em&gt;.</source>
          <target state="translated">术语是 &lt;code&gt;var&lt;/code&gt; 声明了一个&lt;em&gt;可变&lt;/em&gt;变量，而 &lt;code&gt;val&lt;/code&gt; 声明了一个&lt;em&gt;只读&lt;/em&gt;或&lt;em&gt;一次分配&lt;/em&gt;变量-因此这两种都称为&lt;em&gt;变量&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="d2c1a93ffe9401881d7e0f5a7066475d9434f33d" translate="yes" xml:space="preserve">
          <source>The the &lt;a href=&quot;https://github.com/ilmat192/kotlin-native-serialization-sample&quot;&gt;example project&lt;/a&gt; for details.</source>
          <target state="translated">该&lt;a href=&quot;https://github.com/ilmat192/kotlin-native-serialization-sample&quot;&gt;示例项目&lt;/a&gt;中有详细信息。</target>
        </trans-unit>
        <trans-unit id="db0d4a97f9fddd6cc7f4a4e559ab92c9b243b3dc" translate="yes" xml:space="preserve">
          <source>The third option is for NPE-lovers: the not-null assertion operator (&lt;code&gt;!!&lt;/code&gt;) converts any value to a non-null type and throws an exception if the value is null. We can write &lt;code&gt;b!!&lt;/code&gt;, and this will return a non-null value of &lt;code&gt;b&lt;/code&gt; (e.g., a &lt;code&gt;String&lt;/code&gt; in our example) or throw an NPE if &lt;code&gt;b&lt;/code&gt; is null:</source>
          <target state="translated">第三个选项适用于NPE爱好者：非空断言运算符（ &lt;code&gt;!!&lt;/code&gt; ）将任何值转换为非空类型，如果该值为空，则引发异常。我们可以写 &lt;code&gt;b!!&lt;/code&gt; ，这将返回 &lt;code&gt;b&lt;/code&gt; 的非空值（例如，在我们的示例中为 &lt;code&gt;String&lt;/code&gt; ），或者如果 &lt;code&gt;b&lt;/code&gt; 为null 则抛出NPE ：</target>
        </trans-unit>
        <trans-unit id="328eee564065ef14869693e4097fdfb0bb1e1ca4" translate="yes" xml:space="preserve">
          <source>The three targets are created with the preset functions &lt;code&gt;jvm()&lt;/code&gt;, &lt;code&gt;js()&lt;/code&gt;, and &lt;code&gt;mingwX64()&lt;/code&gt; that provide some &lt;a href=&quot;#default-project-layout&quot;&gt;default configuration&lt;/a&gt;. There are presets for each of the &lt;a href=&quot;#supported-platforms&quot;&gt;supported platforms&lt;/a&gt;.</source>
          <target state="translated">这三个目标是使用提供一些&lt;a href=&quot;#default-project-layout&quot;&gt;默认配置&lt;/a&gt;的预设函数 &lt;code&gt;jvm()&lt;/code&gt; ， &lt;code&gt;js()&lt;/code&gt; 和 &lt;code&gt;mingwX64()&lt;/code&gt; 创建的。每个&lt;a href=&quot;#supported-platforms&quot;&gt;受支持的平台&lt;/a&gt;都有预设。</target>
        </trans-unit>
        <trans-unit id="3871e9aa2f804023caa55782736ddd2a4dee3be1" translate="yes" xml:space="preserve">
          <source>The two characters are the same (as compared by the == operator)</source>
          <target state="translated">这两个字符是一样的(通过==操作符进行比较)</target>
        </trans-unit>
        <trans-unit id="43727256131e4c09e21487921129d951e5403bce" translate="yes" xml:space="preserve">
          <source>The type &lt;a href=&quot;exceptions#the-nothing-type&quot;&gt;&lt;code&gt;Nothing&lt;/code&gt;&lt;/a&gt; is special, because it has no natural counterpart in Java. Indeed, every Java reference type, including &lt;code&gt;java.lang.Void&lt;/code&gt;, accepts &lt;code&gt;null&lt;/code&gt; as a value, and &lt;code&gt;Nothing&lt;/code&gt; doesn't accept even that. So, this type cannot be accurately represented in the Java world. This is why Kotlin generates a raw type where an argument of type &lt;code&gt;Nothing&lt;/code&gt; is used:</source>
          <target state="translated">&lt;a href=&quot;exceptions#the-nothing-type&quot;&gt; &lt;code&gt;Nothing&lt;/code&gt; &lt;/a&gt;类型是特殊的，因为它在Java中没有自然的对应物。实际上，每个Java引用类型（包括 &lt;code&gt;java.lang.Void&lt;/code&gt; ）都接受 &lt;code&gt;null&lt;/code&gt; 作为值，而 &lt;code&gt;Nothing&lt;/code&gt; 甚至不接受。因此，无法在Java世界中准确地表示这种类型。这就是为什么Kotlin生成使用 &lt;code&gt;Nothing&lt;/code&gt; 类型的参数的原始类型的原因：</target>
        </trans-unit>
        <trans-unit id="5840d7b86dbf1ab10e5032023a9859ef434e1278" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;Boolean&lt;/code&gt; represents booleans, and has two values: &lt;em&gt;true&lt;/em&gt; and &lt;em&gt;false&lt;/em&gt;.</source>
          <target state="translated">&lt;code&gt;Boolean&lt;/code&gt; 类型表示布尔值，并具有两个值：&lt;em&gt;true&lt;/em&gt;和&lt;em&gt;false&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="fdef02e2cbe116b674c3a5cab83d13e4789bcc49" translate="yes" xml:space="preserve">
          <source>The type argument &lt;code&gt;T&lt;/code&gt; of &lt;code&gt;CPointer&amp;lt;T&amp;gt;&lt;/code&gt; must be one of the &quot;lvalue&quot; types described above, e.g., the C type &lt;code&gt;struct S*&lt;/code&gt; is mapped to &lt;code&gt;CPointer&amp;lt;S&amp;gt;&lt;/code&gt;, &lt;code&gt;int8_t*&lt;/code&gt; is mapped to &lt;code&gt;CPointer&amp;lt;int_8tVar&amp;gt;&lt;/code&gt;, and &lt;code&gt;char**&lt;/code&gt; is mapped to &lt;code&gt;CPointer&amp;lt;CPointerVar&amp;lt;ByteVar&amp;gt;&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">类型参数 &lt;code&gt;T&lt;/code&gt; 的 &lt;code&gt;CPointer&amp;lt;T&amp;gt;&lt;/code&gt; 必须是上述的&amp;ldquo;左值&amp;rdquo;类型中的一种，例如，将C型 &lt;code&gt;struct S*&lt;/code&gt; 被映射到 &lt;code&gt;CPointer&amp;lt;S&amp;gt;&lt;/code&gt; ， &lt;code&gt;int8_t*&lt;/code&gt; 被映射到 &lt;code&gt;CPointer&amp;lt;int_8tVar&amp;gt;&lt;/code&gt; ，和 &lt;code&gt;char**&lt;/code&gt; 映射到 &lt;code&gt;CPointer&amp;lt;CPointerVar&amp;lt;ByteVar&amp;gt;&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="304e12f8621867e9197c2891cfb5db65d05e542f" translate="yes" xml:space="preserve">
          <source>The type arguments of generic function calls are also only checked at compile time. Inside the function bodies, the type parameters cannot be used for type checks, and type casts to type parameters (&lt;code&gt;foo as T&lt;/code&gt;) are unchecked. However, &lt;a href=&quot;inline-functions#reified-type-parameters&quot;&gt;reified type parameters&lt;/a&gt; of inline functions are substituted by the actual type arguments in the inlined function body at the call sites and thus can be used for type checks and casts, with the same restrictions for instances of generic types as described above.</source>
          <target state="translated">泛型函数调用的类型参数也仅在编译时检查。在函数体内，类型参数不能用于类型检查，并且对类型参数（ &lt;code&gt;foo as T&lt;/code&gt; ）的类型强制转换是未选中的。然而，&lt;a href=&quot;inline-functions#reified-type-parameters&quot;&gt;具体化类型参数&lt;/a&gt;的内联函数是由实际类型参数中在调用点内联函数体取代并且因此可用于类型检查和石膏，与如上所述的一般的类型的实例相同的限制。</target>
        </trans-unit>
        <trans-unit id="6d035411fbfdc1232561efb8b45fef51b9b3f1fe" translate="yes" xml:space="preserve">
          <source>The type of &lt;code&gt;safeDivide&lt;/code&gt; is &lt;code&gt;(Int, Int) -&amp;gt; Double&lt;/code&gt;. Note that unlike function type declarations, the parameter list of a lambda expression must not be enclosed in parentheses.</source>
          <target state="translated">&lt;code&gt;safeDivide&lt;/code&gt; 的类型是 &lt;code&gt;(Int, Int) -&amp;gt; Double&lt;/code&gt; 。请注意，与函数类型声明不同，lambda表达式的参数列表不得包含在括号中。</target>
        </trans-unit>
        <trans-unit id="c50d2b6bc67063abeddc4b2628733da7784a58f0" translate="yes" xml:space="preserve">
          <source>The type of a property, and the types that are used for the parameters and the return type of a function, must be &quot;at least as visible&quot; as the property/function itself. For example, a public function can't take a private type as a parameter.</source>
          <target state="translated">属性的类型,以及用于参数和函数返回类型的类型,必须与属性/函数本身 &quot;至少一样可见&quot;。例如,一个公共函数不能使用私有类型作为参数。</target>
        </trans-unit>
        <trans-unit id="8de1071b6667ea170a2315b344096736147854e4" translate="yes" xml:space="preserve">
          <source>The type of the &lt;code&gt;throw&lt;/code&gt; expression is the special type &lt;code&gt;Nothing&lt;/code&gt;. The type has no values and is used to mark code locations that can never be reached. In your own code, you can use &lt;code&gt;Nothing&lt;/code&gt; to mark a function that never returns:</source>
          <target state="translated">该类型的 &lt;code&gt;throw&lt;/code&gt; 表现是特殊类型 &lt;code&gt;Nothing&lt;/code&gt; 。该类型没有值，用于标记永远无法到达的代码位置。在您自己的代码中，可以使用 &lt;code&gt;Nothing&lt;/code&gt; 标记永不返回的函数：</target>
        </trans-unit>
        <trans-unit id="23c18621bf7101376cb4104c69faad184a7d75d0" translate="yes" xml:space="preserve">
          <source>The type of these expressions is the &lt;a href=&quot;exceptions#the-nothing-type&quot;&gt;Nothing type&lt;/a&gt;.</source>
          <target state="translated">这些表达式的&lt;a href=&quot;exceptions#the-nothing-type&quot;&gt;类型&lt;/a&gt;是Nothing类型。</target>
        </trans-unit>
        <trans-unit id="28dfc8e3403b9f6de19da78b037825e3337aa674" translate="yes" xml:space="preserve">
          <source>The type of values returned by this callable.</source>
          <target state="translated">该callable返回的值的类型。</target>
        </trans-unit>
        <trans-unit id="724404b217f8e33affca4710ff6d760dfbd8b8e9" translate="yes" xml:space="preserve">
          <source>The type safety checks that Kotlin performs for generic declaration usages are only done at compile time. At runtime, the instances of generic types do not hold any information about their actual type arguments. The type information is said to be &lt;em&gt;erased&lt;/em&gt;. For example, the instances of &lt;code&gt;Foo&amp;lt;Bar&amp;gt;&lt;/code&gt; and &lt;code&gt;Foo&amp;lt;Baz?&amp;gt;&lt;/code&gt; are erased to just &lt;code&gt;Foo&amp;lt;*&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Kotlin针对泛型声明用法执行的类型安全检查仅在编译时进行。在运行时，泛型类型的实例不保存有关其实际类型参数的任何信息。据说类型信息已被&lt;em&gt;擦除&lt;/em&gt;。例如， &lt;code&gt;Foo&amp;lt;Bar&amp;gt;&lt;/code&gt; 和 &lt;code&gt;Foo&amp;lt;Baz?&amp;gt;&lt;/code&gt; 实例被擦除为 &lt;code&gt;Foo&amp;lt;*&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bd9368e467f6513ce687f28529e6a3ccfb31bd57" translate="yes" xml:space="preserve">
          <source>The type specified after a colon is the &lt;strong&gt;upper bound&lt;/strong&gt;: only a subtype of &lt;code&gt;Comparable&amp;lt;T&amp;gt;&lt;/code&gt; may be substituted for &lt;code&gt;T&lt;/code&gt;. For example:</source>
          <target state="translated">冒号之后指定的类型是&lt;strong&gt;上界&lt;/strong&gt;：只有一个亚型 &lt;code&gt;Comparable&amp;lt;T&amp;gt;&lt;/code&gt; 可以取代 &lt;code&gt;T&lt;/code&gt; 。例如：</target>
        </trans-unit>
        <trans-unit id="195a81820ffdceacb4b4779278f03f44e25e239e" translate="yes" xml:space="preserve">
          <source>The type specified in the projection, or &lt;code&gt;null&lt;/code&gt; if this is a star projection.</source>
          <target state="translated">投影中指定的类型；如果是星型投影，则为 &lt;code&gt;null&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e184ade95bbad48da746688d8668a604f12d3467" translate="yes" xml:space="preserve">
          <source>The type with only one value: the &lt;code&gt;Unit&lt;/code&gt; object.</source>
          <target state="translated">只有一个值的类型： &lt;code&gt;Unit&lt;/code&gt; 对象。</target>
        </trans-unit>
        <trans-unit id="19328e2c828d83e68c896264bdfa85a39aa786f7" translate="yes" xml:space="preserve">
          <source>The type with only one value: the &lt;code&gt;Unit&lt;/code&gt; object. This type corresponds to the &lt;code&gt;void&lt;/code&gt; type in Java.</source>
          <target state="translated">只有一个值的类型： &lt;code&gt;Unit&lt;/code&gt; 对象。此类型对应于Java中的 &lt;code&gt;void&lt;/code&gt; 类型。</target>
        </trans-unit>
        <trans-unit id="7008246671a61ed2da63a9b1d753eac75888ec6a" translate="yes" xml:space="preserve">
          <source>The types inside the angle brackets are called &lt;em&gt;generic type parameters&lt;/em&gt;, which we will cover later. In short, it's a useful technique to make a class that is tied to another class (such as a container class, which is tied to its element class) applicable to many different classes.</source>
          <target state="translated">尖括号内的类型称为&lt;em&gt;通用类型参数&lt;/em&gt;，我们将在后面介绍。简而言之，使绑定到另一个类的类（例如，容器类，绑定到其元素类的类）适用于许多不同的类是一种有用的技术。</target>
        </trans-unit>
        <trans-unit id="3b16b6543fccfa319ed1bb173131c9217c5b8ccc" translate="yes" xml:space="preserve">
          <source>The usage from C is straightforward and uncomplicated. We create a &lt;code&gt;main.c&lt;/code&gt; file with the following code:</source>
          <target state="translated">C语言中的用法非常简单明了。我们使用以下代码创建一个 &lt;code&gt;main.c&lt;/code&gt; 文件：</target>
        </trans-unit>
        <trans-unit id="eda63df3b0cc777042c5e16e6a7e9e820a7f02bd" translate="yes" xml:space="preserve">
          <source>The usage is pretty similar to all-open.</source>
          <target state="translated">用法和全开很相似。</target>
        </trans-unit>
        <trans-unit id="d4460c6a02beaa088565d93296bf84c132fa91dd" translate="yes" xml:space="preserve">
          <source>The usage is the same to all-open and no-arg, except the fact that sam-with-receiver does not have any built-in presets, and you need to specify your own list of special-treated annotations.</source>
          <target state="translated">除了sam-with-receiver没有任何内置的预设之外,用法和all-open和no-arg是一样的,你需要自己指定特殊处理的注释列表。</target>
        </trans-unit>
        <trans-unit id="79d6496f32a4f62877c61deb0bd17640fe23059a" translate="yes" xml:space="preserve">
          <source>The use cases of different functions overlap, so that you can choose the functions based on the specific conventions used in your project or team.</source>
          <target state="translated">不同功能的用例有重叠,可以根据项目或团队的具体约定来选择功能。</target>
        </trans-unit>
        <trans-unit id="882548c8ded53fae119e86e0601fc1f2361824a2" translate="yes" xml:space="preserve">
          <source>The use-site variance specified in the projection, or &lt;code&gt;null&lt;/code&gt; if this is a star projection.</source>
          <target state="translated">投影中指定的使用地点差异；如果是星形投影，则为 &lt;code&gt;null&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f6253f8d51fcab2be72d37974c28482731bda531" translate="yes" xml:space="preserve">
          <source>The value being held by this class.</source>
          <target state="translated">该类所持有的价值。</target>
        </trans-unit>
        <trans-unit id="3c6df952c69c83c655c026cd3cab96c052641127" translate="yes" xml:space="preserve">
          <source>The value must be positive and &lt;a href=&quot;../../kotlin/-int/-m-a-x_-v-a-l-u-e#kotlin.Int.Companion%24MAX_VALUE&quot;&gt;Int.MAX_VALUE&lt;/a&gt; is used to specify an unlimited depth.</source>
          <target state="translated">该值必须为正，并且&lt;a href=&quot;../../kotlin/-int/-m-a-x_-v-a-l-u-e#kotlin.Int.Companion%24MAX_VALUE&quot;&gt;Int.MAX_VALUE&lt;/a&gt;用于指定无限深度。</target>
        </trans-unit>
        <trans-unit id="239f4ace7ed276249b435b6f6174eb7de8fef7a5" translate="yes" xml:space="preserve">
          <source>The value of captured group.</source>
          <target state="translated">捕获组的价值。</target>
        </trans-unit>
        <trans-unit id="af704602dd7474776e5b688f4b067018b5e41c89" translate="yes" xml:space="preserve">
          <source>The value of this variable.</source>
          <target state="translated">此变量的值。</target>
        </trans-unit>
        <trans-unit id="3aabcc212c1608210121013dee11f396d22f4fca" translate="yes" xml:space="preserve">
          <source>The variable containing a &lt;a href=&quot;-c-opaque-pointer&quot;&gt;COpaquePointer&lt;/a&gt;.</source>
          <target state="translated">包含&lt;a href=&quot;-c-opaque-pointer&quot;&gt;COpaquePointer&lt;/a&gt;的变量。</target>
        </trans-unit>
        <trans-unit id="e9b853cf2301d69ed0ca13dfc9180094e7f3e288" translate="yes" xml:space="preserve">
          <source>The version of the bytecode interface (naming conventions, signatures) of the class file annotated with this annotation.</source>
          <target state="translated">用该注解注释的类文件的字节码接口版本(命名惯例、签名)。</target>
        </trans-unit>
        <trans-unit id="1abfb175c8f11a4b2665f4fbd6b2ed384b7a75ef" translate="yes" xml:space="preserve">
          <source>The version of the metadata provided in the arguments of this annotation.</source>
          <target state="translated">本注解的参数中提供的元数据的版本。</target>
        </trans-unit>
        <trans-unit id="b210bbe6f64c596cb275d652b699dc315a1fc8bc" translate="yes" xml:space="preserve">
          <source>The very first part contains the standard C/C++ header and footer:</source>
          <target state="translated">第一部分包含标准的C/C++头和脚。</target>
        </trans-unit>
        <trans-unit id="13204b21b51f8144497368ed89b8d47c465b75a3" translate="yes" xml:space="preserve">
          <source>The visibility level only affects the &lt;em&gt;lexical visibility&lt;/em&gt; of the &lt;em&gt;symbol&lt;/em&gt; - i.e., where the compiler allows you to type out the symbol. It does not affect where &lt;em&gt;instances&lt;/em&gt; are used: for example, a public top-level function may well return an instance of a private class, as long as the return type doesn't mention the private class name but is instead a public base class of the private class (possibly &lt;code&gt;Any&lt;/code&gt;) or a public interface that the private class implements. When you &lt;a href=&quot;inheritance#subclassing&quot;&gt;subclass&lt;/a&gt; a class, its private members are also inherited by the subclass, but are not directly accessible there - however, if you call an inherited public function that happens to access a private member, that's fine.</source>
          <target state="translated">可见性级别仅影响&lt;em&gt;符号&lt;/em&gt;的&lt;em&gt;词法可见性&lt;/em&gt;，即，编译器允许您键入符号。它不会影响使用&lt;em&gt;实例的&lt;/em&gt;位置：例如，一个公共顶级函数很可能会返回一个私有类的实例，只要返回类型没有提及私有类的名称，而是一个私有的基类即可。私有类（可能是 &lt;code&gt;Any&lt;/code&gt; ）或私有类实现的公共接口。当您对一个类进行&lt;a href=&quot;inheritance#subclassing&quot;&gt;子&lt;/a&gt;类化时，子类也继承了它的私有成员，但是在那里不能直接访问它-但是，如果您调用碰巧访问私有成员的继承的公共函数，那很好。&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="be08405fa49b795ce8dcbbade59f22553916f972" translate="yes" xml:space="preserve">
          <source>The way in which we'd use this from JavaScript would be to call &lt;code&gt;dataTable()&lt;/code&gt; on the corresponding &lt;code&gt;&amp;lt;table&amp;gt;&lt;/code&gt; element</source>
          <target state="translated">我们将通过JavaScript使用此方法的方式是在相应的 &lt;code&gt;&amp;lt;table&amp;gt;&lt;/code&gt; 元素上调用 &lt;code&gt;dataTable()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="df6c92cd4ac7021995eb7f605c7d7406310257be" translate="yes" xml:space="preserve">
          <source>The way to refer to the context object</source>
          <target state="translated">引用上下文对象的方式</target>
        </trans-unit>
        <trans-unit id="db21ceeaa7842bb619c97af30e1e09b94faa6e61" translate="yes" xml:space="preserve">
          <source>The web site has a bunch of &lt;a href=&quot;https://kotlinlang.org/community/&quot;&gt;online resources&lt;/a&gt;, including &lt;a href=&quot;https://kotlin.link&quot;&gt;Kotlin Digests&lt;/a&gt; by community members, a &lt;a href=&quot;http://www.kotlinweekly.net&quot;&gt;newsletter&lt;/a&gt;, a &lt;a href=&quot;https://talkingkotlin.com&quot;&gt;podcast&lt;/a&gt; and more.</source>
          <target state="translated">该网站拥有大量&lt;a href=&quot;https://kotlinlang.org/community/&quot;&gt;在线资源&lt;/a&gt;，包括社区成员的&lt;a href=&quot;https://kotlin.link&quot;&gt;Kotlin Digests&lt;/a&gt;，&lt;a href=&quot;http://www.kotlinweekly.net&quot;&gt;新闻通讯&lt;/a&gt;，&lt;a href=&quot;https://talkingkotlin.com&quot;&gt;播客&lt;/a&gt;等等。</target>
        </trans-unit>
        <trans-unit id="ffaad4042bec05249e2007ea2e2a7c01e5b1b264" translate="yes" xml:space="preserve">
          <source>Then add the respective dependencies using the &lt;code&gt;kapt&lt;/code&gt; configuration in your &lt;code&gt;dependencies&lt;/code&gt; block:</source>
          <target state="translated">然后在您的 &lt;code&gt;dependencies&lt;/code&gt; 块中使用 &lt;code&gt;kapt&lt;/code&gt; 配置添加相应的依赖关系：</target>
        </trans-unit>
        <trans-unit id="3d3dd4715a6e839facb3a4bc6c2872f8802ec4b8" translate="yes" xml:space="preserve">
          <source>Then follow the wizard steps. You'll have a &lt;code&gt;build.gradle&lt;/code&gt; file created with Kotlin configured according to &lt;a href=&quot;../../reference/using-gradle&quot;&gt;this document&lt;/a&gt;. Make sure it's configured for Kotlin 1.3 or higher.</source>
          <target state="translated">然后按照向导步骤。您将拥有一个Kotlin创建的 &lt;code&gt;build.gradle&lt;/code&gt; 文件，&lt;a href=&quot;../../reference/using-gradle&quot;&gt;该文件&lt;/a&gt;根据此文档进行配置。确保将其配置为Kotlin 1.3或更高版本。</target>
        </trans-unit>
        <trans-unit id="9ed3e436c4ee364169e1bdacb724480b6ae120b2" translate="yes" xml:space="preserve">
          <source>Then follow the wizard steps. You'll have a &lt;code&gt;pom.xml&lt;/code&gt; file created with Kotlin configured according to &lt;a href=&quot;../../reference/using-maven&quot;&gt;this document&lt;/a&gt;. Make sure it's configured for Kotlin 1.3 or higher.</source>
          <target state="translated">然后按照向导步骤。您将拥有一个根据&lt;a href=&quot;../../reference/using-maven&quot;&gt;本文档&lt;/a&gt;配置Kotlin创建的 &lt;code&gt;pom.xml&lt;/code&gt; 文件。确保将其配置为Kotlin 1.3或更高版本。</target>
        </trans-unit>
        <trans-unit id="10cfe3c1803900b3459055c1fdedb21ced35e4cd" translate="yes" xml:space="preserve">
          <source>Then run the &lt;code&gt;cinterop&lt;/code&gt; tool with something like this (note that for host libraries that are not included in the sysroot search paths, headers may be needed):</source>
          <target state="translated">然后使用以下内容运行 &lt;code&gt;cinterop&lt;/code&gt; 工具（请注意，对于sysroot搜索路径中未包含的主机库，可能需要标头）：</target>
        </trans-unit>
        <trans-unit id="5581239ffa3d854f1837127435e240d49f122ba5" translate="yes" xml:space="preserve">
          <source>Then specify the list of SAM-with-receiver annotations:</source>
          <target state="translated">然后指定SAM-with-receiver注释的列表。</target>
        </trans-unit>
        <trans-unit id="9b78fa9ef8a36ffde61cb8bc4f298109afadcbee" translate="yes" xml:space="preserve">
          <source>Then specify the list of annotations that will make classes open:</source>
          <target state="translated">然后指定将使类打开的注释列表。</target>
        </trans-unit>
        <trans-unit id="fd73374c27e0a874f2f41c35f033bfc599a82d6b" translate="yes" xml:space="preserve">
          <source>Then specify the list of no-arg annotations:</source>
          <target state="translated">然后指定无参数注释的列表。</target>
        </trans-unit>
        <trans-unit id="0ef92249fe5f505a551a8b463644321da779af43" translate="yes" xml:space="preserve">
          <source>Then we can have several processor coroutines. In this example, they just print their id and received number:</source>
          <target state="translated">那么我们可以有几个处理器的coroutine。在这个例子中,它们只是打印自己的id和收到的号码。</target>
        </trans-unit>
        <trans-unit id="490b87ea6044ef60c21b2e7783571a7d77df8b12" translate="yes" xml:space="preserve">
          <source>Then we define a function that launches an actor using an &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/actor.html&quot;&gt;actor&lt;/a&gt; coroutine builder:</source>
          <target state="translated">然后，我们定义一个使用&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/actor.html&quot;&gt;actor&lt;/a&gt;协程生成器启动actor的函数：</target>
        </trans-unit>
        <trans-unit id="843feae1b1434f20428d159db5d3289af1525e9c" translate="yes" xml:space="preserve">
          <source>Then, for each &lt;a href=&quot;https://developer.android.com/studio/build/build-variants#sourcesets&quot;&gt;Android source set&lt;/a&gt; compiled by the variants, a Kotlin source set is created under that source set name prepended by the target name, like Kotlin source set &lt;code&gt;androidDebug&lt;/code&gt; for an Android source set &lt;code&gt;debug&lt;/code&gt; and the Kotlin target named &lt;code&gt;android&lt;/code&gt;. These Kotlin source sets are added to the variants compilations accordingly.</source>
          <target state="translated">然后，对于由变体编译的每个&lt;a href=&quot;https://developer.android.com/studio/build/build-variants#sourcesets&quot;&gt;Android源集&lt;/a&gt;，将在目标名称前的源集名称下创建Kotlin源集，例如Android源集 &lt;code&gt;debug&lt;/code&gt; 的 Kotlin源集 &lt;code&gt;androidDebug&lt;/code&gt; 和名为 &lt;code&gt;android&lt;/code&gt; 的Kotlin目标。这些Kotlin源集会相应地添加到变体编辑中。</target>
        </trans-unit>
        <trans-unit id="68562aa9b0f180cb0bf47fd690042cd2286c6294" translate="yes" xml:space="preserve">
          <source>Then, it would be perfectly safe to store a reference to an instance of &lt;code&gt;Source&amp;lt;String&amp;gt;&lt;/code&gt; in a variable of type &lt;code&gt;Source&amp;lt;Object&amp;gt;&lt;/code&gt; &amp;ndash; there are no consumer-methods to call. But Java does not know this, and still prohibits it:</source>
          <target state="translated">然后，将对 &lt;code&gt;Source&amp;lt;String&amp;gt;&lt;/code&gt; 实例的引用存储在类型为 &lt;code&gt;Source&amp;lt;Object&amp;gt;&lt;/code&gt; 的变量中将是绝对安全的&amp;ndash;没有要调用的使用方方法。但是Java不知道这一点，并且仍然禁止它：</target>
        </trans-unit>
        <trans-unit id="d673d7a939528ccf7977db751d0c7bd0f923bb89" translate="yes" xml:space="preserve">
          <source>Then, once a target is added, default compilations are created for it:</source>
          <target state="translated">然后,一旦添加了一个目标,就会为其创建默认的编译。</target>
        </trans-unit>
        <trans-unit id="a7b51b664e8983298e6dc346e7c7dc0b18863813" translate="yes" xml:space="preserve">
          <source>Then, some time later the deprecation level is raised to &lt;a href=&quot;../-deprecation-level/-e-r-r-o-r#kotlin.DeprecationLevel.ERROR&quot;&gt;DeprecationLevel.ERROR&lt;/a&gt;, so that no new Kotlin code can be compiled using the deprecated API.</source>
          <target state="translated">然后，过一会儿，弃用级别将提高到&lt;a href=&quot;../-deprecation-level/-e-r-r-o-r#kotlin.DeprecationLevel.ERROR&quot;&gt;DeprecationLevel.ERROR&lt;/a&gt;，以便使用弃用的API无法编译新的Kotlin代码。</target>
        </trans-unit>
        <trans-unit id="b6377e7d0f06e408f80f03d549dd08ce8d9b969c" translate="yes" xml:space="preserve">
          <source>Then, the only thing we want to ensure is that &lt;code&gt;copy()&lt;/code&gt; does not do any bad things. We want to prohibit it from &lt;strong&gt;writing&lt;/strong&gt; to &lt;code&gt;from&lt;/code&gt;, and we can:</source>
          <target state="translated">然后，我们唯一要确保的是 &lt;code&gt;copy()&lt;/code&gt; 不会做任何不好的事情。我们想从禁止其&lt;strong&gt;写入&lt;/strong&gt;到 &lt;code&gt;from&lt;/code&gt; ，我们可以：</target>
        </trans-unit>
        <trans-unit id="2e04f4cdf39ff6bfe2fd15e1cdcb551eff15e642" translate="yes" xml:space="preserve">
          <source>There are a few courses available for Kotlin, including a &lt;a href=&quot;https://www.pluralsight.com/courses/kotlin-getting-started&quot;&gt;Pluralsight Kotlin Course&lt;/a&gt; by Kevin Jones, an &lt;a href=&quot;http://shop.oreilly.com/product/0636920052982.do&quot;&gt;O&amp;rsquo;Reilly Course&lt;/a&gt; by Hadi Hariri and an &lt;a href=&quot;http://petersommerhoff.com/dev/kotlin/kotlin-beginner-tutorial/&quot;&gt;Udemy Kotlin Course&lt;/a&gt; by Peter Sommerhoff.</source>
          <target state="translated">Kotlin有一些可用的课程，包括Kevin Jones 的&lt;a href=&quot;https://www.pluralsight.com/courses/kotlin-getting-started&quot;&gt;Pluralsight Kotlin &lt;/a&gt;&lt;a href=&quot;http://shop.oreilly.com/product/0636920052982.do&quot;&gt;课程&lt;/a&gt;，Hadi Hariri 的O'Reilly课程和Peter Sommerhoff 的&lt;a href=&quot;http://petersommerhoff.com/dev/kotlin/kotlin-beginner-tutorial/&quot;&gt;Udemy Kotlin课程&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7aeb1151dcad680105c7a075482911c8fc7a00f6" translate="yes" xml:space="preserve">
          <source>There are a lot of built-in extension functions/properties in Kotlin - for example, &lt;code&gt;map()&lt;/code&gt;, &lt;code&gt;filter()&lt;/code&gt;, and the rest of the framework for processing collections in a functional manner is built using extension functions.</source>
          <target state="translated">Kotlin中有很多内置的扩展功能/属性-例如 &lt;code&gt;map()&lt;/code&gt; ， &lt;code&gt;filter()&lt;/code&gt; 和使用扩展功能构建其余用于以功能方式处理集合的框架。</target>
        </trans-unit>
        <trans-unit id="24f819fcebc7b01f0f49b06a15eca941aac602cd" translate="yes" xml:space="preserve">
          <source>There are already &lt;a href=&quot;https://kotlinlang.org/docs/books.html&quot;&gt;a number of books&lt;/a&gt; available for Kotlin, including &lt;a href=&quot;https://www.manning.com/books/kotlin-in-action&quot;&gt;Kotlin in Action&lt;/a&gt; which is by Kotlin team members Dmitry Jemerov and Svetlana Isakova, &lt;a href=&quot;https://leanpub.com/kotlin-for-android-developers&quot;&gt;Kotlin for Android Developers&lt;/a&gt; targeted at Android developers.</source>
          <target state="translated">Kotlin 已经&lt;a href=&quot;https://kotlinlang.org/docs/books.html&quot;&gt;有许多&lt;/a&gt;可用的书籍，其中包括&lt;a href=&quot;https://www.manning.com/books/kotlin-in-action&quot;&gt;Kotlin&lt;/a&gt;团队成员Dmitry Jemerov和&lt;a href=&quot;https://leanpub.com/kotlin-for-android-developers&quot;&gt;Kotlin的&lt;/a&gt; Svetlana Isakova，由Kotlin团队成员Dmitry Jemerov和Android开发人员针对Android开发人员编写。</target>
        </trans-unit>
        <trans-unit id="cafdda410a7a8fb3e86649e5eeda1f41cb52882f" translate="yes" xml:space="preserve">
          <source>There are also functions for creating collections without any elements: &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/empty-list&quot;&gt;&lt;code&gt;emptyList()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/empty-set&quot;&gt;&lt;code&gt;emptySet()&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/empty-map&quot;&gt;&lt;code&gt;emptyMap()&lt;/code&gt;&lt;/a&gt;. When creating empty collections, you should specify the type of elements that the collection will hold.</source>
          <target state="translated">还有一些用于创建不带任何元素的集合的函数：&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/empty-list&quot;&gt; &lt;code&gt;emptyList()&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/empty-set&quot;&gt; &lt;code&gt;emptySet()&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/empty-map&quot;&gt; &lt;code&gt;emptyMap()&lt;/code&gt; &lt;/a&gt;。创建空集合时，应指定集合将包含的元素类型。</target>
        </trans-unit>
        <trans-unit id="843241bb0f5eb80f440f0b1b3622ce9c95598c3b" translate="yes" xml:space="preserve">
          <source>There are also functions for retrieving the smallest and the largest elements by certain selector function or custom &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin/-comparator/index&quot;&gt;&lt;code&gt;Comparator&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">还有一些通过某些选择器功能或自定义&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin/-comparator/index&quot;&gt; &lt;code&gt;Comparator&lt;/code&gt; &lt;/a&gt;检索最小和最大元素的函数：</target>
        </trans-unit>
        <trans-unit id="4888d99de496e5f2812e2d42599de7f621ae0a73" translate="yes" xml:space="preserve">
          <source>There are also functions that narrow the element type by filtering elements of a given type:</source>
          <target state="translated">还有一些函数可以通过过滤给定类型的元素来缩小元素类型。</target>
        </trans-unit>
        <trans-unit id="22fc645d90366ef3cbd36340e10852155ba93121" translate="yes" xml:space="preserve">
          <source>There are also many recordings of &lt;a href=&quot;http://kotlinlang.org/community/talks.html&quot;&gt;Kotlin talks&lt;/a&gt; available on YouTube and Vimeo.</source>
          <target state="translated">YouTube和Vimeo上还有许多&lt;a href=&quot;http://kotlinlang.org/community/talks.html&quot;&gt;Kotlin演讲的&lt;/a&gt;录音。</target>
        </trans-unit>
        <trans-unit id="e4606566df8d7d15d5ed6bd46e8178f7ee899fb7" translate="yes" xml:space="preserve">
          <source>There are also more specific types:</source>
          <target state="translated">还有一些比较特殊的类型。</target>
        </trans-unit>
        <trans-unit id="06489c1e98a1df08c22af1c2c8a1f880cc0522a9" translate="yes" xml:space="preserve">
          <source>There are also some tools available to convert between Kotlin and C strings manually:</source>
          <target state="translated">也有一些工具可以在Kotlin和C字符串之间手动转换。</target>
        </trans-unit>
        <trans-unit id="5da1b83a877bec99a63204ac23c3a863bcc7d2fe" translate="yes" xml:space="preserve">
          <source>There are also the following type qualifiers in the C language: &lt;code&gt;const&lt;/code&gt;, &lt;code&gt;volatile&lt;/code&gt;, &lt;code&gt;restruct&lt;/code&gt;, &lt;code&gt;atomic&lt;/code&gt;.</source>
          <target state="translated">在C语言中，还有以下类型限定符： &lt;code&gt;const&lt;/code&gt; ， &lt;code&gt;volatile&lt;/code&gt; ， &lt;code&gt;restruct&lt;/code&gt; ， &lt;code&gt;atomic&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d1856539b37f6f362e28eec082e8282bf62fdd7b" translate="yes" xml:space="preserve">
          <source>There are also two specific ways for filtering maps: by keys and by values. For each way, there is a function: &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/filter-keys&quot;&gt;&lt;code&gt;filterKeys()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/filter-values&quot;&gt;&lt;code&gt;filterValues()&lt;/code&gt;&lt;/a&gt;. Both return a new map of entries which match the given predicate. The predicate for &lt;code&gt;filterKeys()&lt;/code&gt; checks only the element keys, the one for &lt;code&gt;filterValues()&lt;/code&gt; checks only values.</source>
          <target state="translated">还有两种用于过滤地图的特定方法：按键和按值。对于每种方式，都有一个函数：&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/filter-keys&quot;&gt; &lt;code&gt;filterKeys()&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/filter-values&quot;&gt; &lt;code&gt;filterValues()&lt;/code&gt; &lt;/a&gt;。两者均返回与给定谓词匹配的新条目映射。谓词 &lt;code&gt;filterKeys()&lt;/code&gt; 仅检查元件按键，一个用于 &lt;code&gt;filterValues()&lt;/code&gt; 仅检查值。</target>
        </trans-unit>
        <trans-unit id="250044abbac1d0cc39bffb2b00e37419c1aa5fa8" translate="yes" xml:space="preserve">
          <source>There are also useful aliases for retrieving the first and the last element of the collection: &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/first&quot;&gt;&lt;code&gt;first()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/last&quot;&gt;&lt;code&gt;last()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">还有一些有用的别名来检索集合的第一个和最后一个元素：&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/first&quot;&gt; &lt;code&gt;first()&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/last&quot;&gt; &lt;code&gt;last()&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f989069ff2a0fc8bbd7269050d48a2e9c89946af" translate="yes" xml:space="preserve">
          <source>There are certain common kinds of properties, that, though we can implement them manually every time we need them, would be very nice to implement once and for all, and put into a library. Examples include:</source>
          <target state="translated">有一些常见的属性,虽然我们可以在每次需要的时候手动实现,但如果能一次性实现,并放入库中,那就再好不过了。例子包括:</target>
        </trans-unit>
        <trans-unit id="e9d07a2b7a0e6a37bb57f8fc3823505798a41626" translate="yes" xml:space="preserve">
          <source>There are certain rules that define write operations on maps:</source>
          <target state="translated">有一些规则定义了对地图的写操作。</target>
        </trans-unit>
        <trans-unit id="2a3a36051a175f99aacc43b0a72a065674774e2a" translate="yes" xml:space="preserve">
          <source>There are couple of observations to make out of it.</source>
          <target state="translated">从中可以看出几个问题。</target>
        </trans-unit>
        <trans-unit id="fd050ce9dc8260feb80b7e8ad7e70f3ec42e69f1" translate="yes" xml:space="preserve">
          <source>There are exactly four instances of this class, named &lt;code&gt;ContentKind.TOPIC&lt;/code&gt;, and so on. Instances of this class can be compared to each other with &lt;code&gt;==&lt;/code&gt; and &lt;code&gt;!=&lt;/code&gt;, and you can get all the allowable values with &lt;code&gt;ContentKind.values()&lt;/code&gt;. You can also tack on more information to each instance if you need:</source>
          <target state="translated">该类有四个实例，分别称为 &lt;code&gt;ContentKind.TOPIC&lt;/code&gt; ，依此类推。可以使用 &lt;code&gt;==&lt;/code&gt; 和 &lt;code&gt;!=&lt;/code&gt; 将此类的实例相互比较，并且可以使用 &lt;code&gt;ContentKind.values()&lt;/code&gt; 获得所有允许的值。如果需要，您还可以为每个实例提供更多信息：</target>
        </trans-unit>
        <trans-unit id="f927ac2e11471dbf3b5e6b2ee718ccfcd881bb02" translate="yes" xml:space="preserve">
          <source>There are many approaches to this problem, and in Kotlin we take a very flexible one by providing &lt;a href=&quot;https://en.wikipedia.org/wiki/Coroutine&quot;&gt;Coroutine&lt;/a&gt; support at the language level and delegating most of the functionality to libraries, much in line with Kotlin's philosophy.</source>
          <target state="translated">解决此问题的方法很多，在Kotlin中，我们通过在语言级别提供&lt;a href=&quot;https://en.wikipedia.org/wiki/Coroutine&quot;&gt;Coroutine&lt;/a&gt;支持并将大部分功能委托给库来采取非常灵活的方法，这与Kotlin的哲学非常一致。</target>
        </trans-unit>
        <trans-unit id="a0366ee935c5394b522c3fe877f29b4f014a964b" translate="yes" xml:space="preserve">
          <source>There are many more platform libraries available for host and cross-compilation targets. &lt;code&gt;Kotlin/Native&lt;/code&gt; distribution provides access to &lt;code&gt;OpenGL&lt;/code&gt;, &lt;code&gt;zlib&lt;/code&gt; and other popular native libraries on applicable platforms.</source>
          <target state="translated">还有更多的平台库可用于宿主和交叉编译目标。 &lt;code&gt;Kotlin/Native&lt;/code&gt; 发行版提供对 &lt;code&gt;OpenGL&lt;/code&gt; ， &lt;code&gt;zlib&lt;/code&gt; 和适用平台上其他流行的本机库的访问。</target>
        </trans-unit>
        <trans-unit id="ef27dee02c48c1f5d014bbb6297ef36468bd6491" translate="yes" xml:space="preserve">
          <source>There are multiple ways to compile Kotlin to JavaScript. The recommended approach is to use Gradle; if desired, you can also build JavaScript projects directly from IntelliJ IDEA, use Maven, or compile the code manually from the command line. To learn more about how to compile to JavaScript please see the corresponding tutorials:</source>
          <target state="translated">有多种方法可以将Kotlin编译成JavaScript。推荐的方法是使用Gradle;如果需要,你也可以直接从IntelliJ IDEA中构建JavaScript项目,使用Maven,或者从命令行手动编译代码。要了解更多关于如何编译成JavaScript的信息,请看相应的教程。</target>
        </trans-unit>
        <trans-unit id="655afcf98b929642faf68faf52cca26e671f04f6" translate="yes" xml:space="preserve">
          <source>There are no &lt;code&gt;**kwargs&lt;/code&gt; in Kotlin, but you can define optional parameters with default values, and you may choose to name some or all of the parameters when you call the function (whether they've got default values or not). A parameter with a default value must still specify its type explicitly. Like in Python, the named arguments can be reordered at will at the call site:</source>
          <target state="translated">Kotlin 中没有 &lt;code&gt;**kwargs&lt;/code&gt; kwarg，但是您可以定义具有默认值的可选参数，并且在调用函数时可以选择命名部分或全部参数（无论它们是否具有默认值）。具有默认值的参数仍必须明确指定其类型。像在Python中一样，可以在调用站点随意重新命名命名的参数：</target>
        </trans-unit>
        <trans-unit id="577ed2c21e3c8a21c4f57421503fea8126403589" translate="yes" xml:space="preserve">
          <source>There are no automatic conversions to boolean and thus no concept of truthy and falsy: checks for zero, empty, or null must be done explicitly with &lt;code&gt;==&lt;/code&gt; or &lt;code&gt;!=&lt;/code&gt;. Most collection types have an &lt;code&gt;isEmpty()&lt;/code&gt; and an &lt;code&gt;isNotEmpty()&lt;/code&gt; function.</source>
          <target state="translated">没有自动转换为布尔值的方法，因此也没有&amp;ldquo;真假&amp;rdquo;的概念：必须使用 &lt;code&gt;==&lt;/code&gt; 或 &lt;code&gt;!=&lt;/code&gt; 明确进行零，空或null的检查。大多数集合类型具有 &lt;code&gt;isEmpty()&lt;/code&gt; 和 &lt;code&gt;isNotEmpty()&lt;/code&gt; 函数。</target>
        </trans-unit>
        <trans-unit id="0173c0164165dfc2326b31145c73366a6b9e4caf" translate="yes" xml:space="preserve">
          <source>There are now separate versions of the standard library supporting the new JDK APIs added in Java 7 and 8. If you need access to the new APIs, use &lt;code&gt;kotlin-stdlib-jre7&lt;/code&gt; and &lt;code&gt;kotlin-stdlib-jre8&lt;/code&gt; maven artifacts instead of the standard &lt;code&gt;kotlin-stdlib&lt;/code&gt;. These artifacts are tiny extensions on top of &lt;code&gt;kotlin-stdlib&lt;/code&gt; and they bring it to your project as a transitive dependency.</source>
          <target state="translated">现在，有标准库的单独版本支持在Java 7和8中添加的新JDK API。如果需要访问新API，请使用 &lt;code&gt;kotlin-stdlib-jre7&lt;/code&gt; 和 &lt;code&gt;kotlin-stdlib-jre8&lt;/code&gt; maven构件代替标准 &lt;code&gt;kotlin-stdlib&lt;/code&gt; 。这些工件是 &lt;code&gt;kotlin-stdlib&lt;/code&gt; 之上的微小扩展，它们作为传递依赖项将其带入您的项目。</target>
        </trans-unit>
        <trans-unit id="4f69b73bfcd710307d7869f79c049d0bc960833d" translate="yes" xml:space="preserve">
          <source>There are several ways to obtain an instance of a function type:</source>
          <target state="translated">有几种方法可以获得函数类型的实例。</target>
        </trans-unit>
        <trans-unit id="bfb4470f4c8ab69e441c59ca19feae2c36a172f6" translate="yes" xml:space="preserve">
          <source>There are several ways to override the default setting:</source>
          <target state="translated">有几种方法可以覆盖默认设置。</target>
        </trans-unit>
        <trans-unit id="3ea08a710ccd5abee84ca77d28377d406d442756" translate="yes" xml:space="preserve">
          <source>There are some limitations:</source>
          <target state="translated">有一些限制。</target>
        </trans-unit>
        <trans-unit id="060bb5e1464bf104cc44e53612c8d8eb0e6d472c" translate="yes" xml:space="preserve">
          <source>There are target presets that one can apply using the preset functions, as shown above, for the following target platforms:</source>
          <target state="translated">有一些目标预设,可以使用预设功能来应用,如上图所示,适用于以下目标平台。</target>
        </trans-unit>
        <trans-unit id="7df642de78432a3520c5b5afd68e2c605c1c315a" translate="yes" xml:space="preserve">
          <source>There are the following kinds of literal constants for integral values:</source>
          <target state="translated">积分值的文字常数有以下几种。</target>
        </trans-unit>
        <trans-unit id="f4373b7b309c5120a0c7bdb4b6efb5a4594f35b5" translate="yes" xml:space="preserve">
          <source>There are three coroutines. The main coroutine (#1) &amp;ndash; &lt;code&gt;runBlocking&lt;/code&gt; one, and two coroutines computing deferred values &lt;code&gt;a&lt;/code&gt; (#2) and &lt;code&gt;b&lt;/code&gt; (#3). They are all executing in the context of &lt;code&gt;runBlocking&lt;/code&gt; and are confined to the main thread. The output of this code is:</source>
          <target state="translated">有三个协程。主协程（＃1）&amp;ndash; &lt;code&gt;runBlocking&lt;/code&gt; 一个协程，两个协程计算递延值 &lt;code&gt;a&lt;/code&gt; （＃2）和 &lt;code&gt;b&lt;/code&gt; （＃3）。它们都在 &lt;code&gt;runBlocking&lt;/code&gt; 上下文中执行，并且仅限于主线程。此代码的输出是：</target>
        </trans-unit>
        <trans-unit id="f684c90b5c1cc2b45ec708952abe326e96395793" translate="yes" xml:space="preserve">
          <source>There are too many companies using Kotlin to list, but some more visible companies that have publicly declared usage of Kotlin, be this via blog posts, GitHub repositories or talks include &lt;a href=&quot;https://medium.com/square-corner-blog/square-open-source-loves-kotlin-c57c21710a17&quot;&gt;Square&lt;/a&gt;, &lt;a href=&quot;https://www.youtube.com/watch?v=mDpnc45WwlI&quot;&gt;Pinterest&lt;/a&gt;, &lt;a href=&quot;https://m.signalvnoise.com/how-we-made-basecamp-3s-android-app-100-kotlin-35e4e1c0ef12&quot;&gt;Basecamp&lt;/a&gt; or &lt;a href=&quot;https://docs.corda.net/releases/release-M9.2/further-notes-on-kotlin.html&quot;&gt;Corda&lt;/a&gt;.</source>
          <target state="translated">有太多使用Kotlin进行上市的公司，但是一些公开宣布使用Kotlin的知名公司（包括博客文章，GitHub仓库或座谈会）包括&lt;a href=&quot;https://medium.com/square-corner-blog/square-open-source-loves-kotlin-c57c21710a17&quot;&gt;Square&lt;/a&gt;，&lt;a href=&quot;https://www.youtube.com/watch?v=mDpnc45WwlI&quot;&gt;Pinterest&lt;/a&gt;，&lt;a href=&quot;https://m.signalvnoise.com/how-we-made-basecamp-3s-android-app-100-kotlin-35e4e1c0ef12&quot;&gt;Basecamp&lt;/a&gt;或&lt;a href=&quot;https://docs.corda.net/releases/release-M9.2/further-notes-on-kotlin.html&quot;&gt;Corda&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="26ea8b64f47f54b93f794f79bdbd7ea265251dad" translate="yes" xml:space="preserve">
          <source>There are two approaches to making computation code cancellable. The first one is to periodically invoke a suspending function that checks for cancellation. There is a &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/yield.html&quot;&gt;yield&lt;/a&gt; function that is a good choice for that purpose. The other one is to explicitly check the cancellation status. Let us try the latter approach.</source>
          <target state="translated">有两种方法可以使计算代码可取消。第一个是定期调用检查取消的挂起函数。为此，有一个&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/yield.html&quot;&gt;yield&lt;/a&gt;函数是一个不错的选择。另一个是显式检查取消状态。让我们尝试后一种方法。</target>
        </trans-unit>
        <trans-unit id="cdb0e62ebdac6496d2a6cecaea4c9ddd6a113e2b" translate="yes" xml:space="preserve">
          <source>There are two functions for which the compiler gives same name in JavaScript, you can mark one with &lt;code&gt;@JsName(...)&lt;/code&gt; to prevent the compiler from reporting error.</source>
          <target state="translated">编译器在JavaScript中使用两个相同的函数来命名，您可以使用 &lt;code&gt;@JsName(...)&lt;/code&gt; 标记一个，以防止编译器报告错误。</target>
        </trans-unit>
        <trans-unit id="538a207adbe54f7fe71914302d366f642c584d32" translate="yes" xml:space="preserve">
          <source>There are two possible ways to opt-in for unsigned types: with marking your API as experimental too, or without doing that.</source>
          <target state="translated">有两种可能的方式来选择加入无符号类型:将你的API也标记为实验性的,或者不这样做。</target>
        </trans-unit>
        <trans-unit id="86b3923915c4ddd4dd399b02f1d436b8dc853f8d" translate="yes" xml:space="preserve">
          <source>There can be different modes of stability depending of how quickly a component is evolving:</source>
          <target state="translated">根据组件的发展速度,可以有不同的稳定模式。</target>
        </trans-unit>
        <trans-unit id="0b3f1a4d9ad65e8f5f359abf2fed82920c3beef2" translate="yes" xml:space="preserve">
          <source>There have been many approaches to solving this problem, including:</source>
          <target state="translated">解决这个问题的方法有很多,包括:</target>
        </trans-unit>
        <trans-unit id="c4dc29b34f77a8368125ef8d384ca8b6bfbe8472" translate="yes" xml:space="preserve">
          <source>There is a &lt;code&gt;kotlin.root.example.Clazz&lt;/code&gt; field that represents the &lt;code&gt;Clazz&lt;/code&gt; from Kotlin. The &lt;code&gt;Clazz#memberFunction&lt;/code&gt; is accessible with the &lt;code&gt;memberFunction&lt;/code&gt; field. The only difference is that the &lt;code&gt;memberFunction&lt;/code&gt; accepts a &lt;code&gt;this&lt;/code&gt; reference as the first parameter. The C language does not support objects, and this is the reason to pass a &lt;code&gt;this&lt;/code&gt; pointer explicitly.</source>
          <target state="translated">有一个 &lt;code&gt;kotlin.root.example.Clazz&lt;/code&gt; 表示场 &lt;code&gt;Clazz&lt;/code&gt; 从科特林。在 &lt;code&gt;Clazz#memberFunction&lt;/code&gt; 与访问 &lt;code&gt;memberFunction&lt;/code&gt; 领域。唯一的区别是 &lt;code&gt;memberFunction&lt;/code&gt; 接受 &lt;code&gt;this&lt;/code&gt; 引用作为第一个参数。C语言不支持对象，这就是显式传递 &lt;code&gt;this&lt;/code&gt; 指针的原因。</target>
        </trans-unit>
        <trans-unit id="725365acc046d2774e785fd58198ecf73c6aec56" translate="yes" xml:space="preserve">
          <source>There is a better solution. We can use structured concurrency in our code. Instead of launching coroutines in the &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-global-scope/index.html&quot;&gt;GlobalScope&lt;/a&gt;, just like we usually do with threads (threads are always global), we can launch coroutines in the specific scope of the operation we are performing.</source>
          <target state="translated">有更好的解决方案。我们可以在代码中使用结构化并发。像我们通常在线程中一样（线程始终是全局的），而不是在&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-global-scope/index.html&quot;&gt;GlobalScope&lt;/a&gt;中启动协程，我们可以在正在执行的操作的特定范围内启动协程。</target>
        </trans-unit>
        <trans-unit id="f4b1300b6ec8e15e33a7b0dfe89c4e2e11e628f0" translate="yes" xml:space="preserve">
          <source>There is a bunch of new extensions on the String class to convert it to a number without throwing an exception on invalid number: &lt;code&gt;String.toIntOrNull(): Int?&lt;/code&gt;, &lt;code&gt;String.toDoubleOrNull(): Double?&lt;/code&gt; etc.</source>
          <target state="translated">String类上有很多新扩展，可以将其转换为数字，而不会在无效数字上引发异常： &lt;code&gt;String.toIntOrNull(): Int?&lt;/code&gt; ， &lt;code&gt;String.toDoubleOrNull(): Double?&lt;/code&gt; 等等</target>
        </trans-unit>
        <trans-unit id="7e33e2bb2c0c45c94e894d38130281f13150c4a3" translate="yes" xml:space="preserve">
          <source>There is a constructor in the &lt;code&gt;Clazz&lt;/code&gt; field (aka &lt;code&gt;kotlin.root.example.Clazz.Clazz&lt;/code&gt;), which is the constructor function to create an instance of the &lt;code&gt;Clazz&lt;/code&gt;.</source>
          <target state="translated">有一个在构造函数 &lt;code&gt;Clazz&lt;/code&gt; 字段（又名 &lt;code&gt;kotlin.root.example.Clazz.Clazz&lt;/code&gt; ），这是构造函数来创建的实例 &lt;code&gt;Clazz&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b8e6c9d338e18c01513c4cf42dbec9a1ab61f7aa" translate="yes" xml:space="preserve">
          <source>There is a convenient coroutine builder named &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/produce.html&quot;&gt;produce&lt;/a&gt; that makes it easy to do it right on producer side, and an extension function &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/consume-each.html&quot;&gt;consumeEach&lt;/a&gt;, that replaces a &lt;code&gt;for&lt;/code&gt; loop on the consumer side:</source>
          <target state="translated">有一个名为方便协同程序生成器&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/produce.html&quot;&gt;产生&lt;/a&gt;，可以很容易把事情做对的制片方和扩展功能&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/consume-each.html&quot;&gt;consumeEach&lt;/a&gt;，替换上 &lt;code&gt;for&lt;/code&gt; 消费者一方循环：</target>
        </trans-unit>
        <trans-unit id="2dc05473a597a891dd992cdcf3cb31ec48971266" translate="yes" xml:space="preserve">
          <source>There is a laziness option to &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/async.html&quot;&gt;async&lt;/a&gt; using an optional &lt;code&gt;start&lt;/code&gt; parameter with a value of &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-start/-l-a-z-y.html&quot;&gt;CoroutineStart.LAZY&lt;/a&gt;. It starts coroutine only when its result is needed by some &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-deferred/await.html&quot;&gt;await&lt;/a&gt; or if a &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/start.html&quot;&gt;start&lt;/a&gt; function is invoked. Run the following example:</source>
          <target state="translated">有一个懒惰选项&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/async.html&quot;&gt;异步&lt;/a&gt;使用可选的 &lt;code&gt;start&lt;/code&gt; 参数与值&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-start/-l-a-z-y.html&quot;&gt;CoroutineStart.LAZY&lt;/a&gt;。仅在&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-deferred/await.html&quot;&gt;等待&lt;/a&gt;其结果或调用&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/start.html&quot;&gt;启动&lt;/a&gt;函数时，它才启动协程。运行以下示例：</target>
        </trans-unit>
        <trans-unit id="64fbf3e4d33c3845151425fcbae0bd95c1ac7ffc" translate="yes" xml:space="preserve">
          <source>There is a nice piece of syntactic sugar that lets you do this: &lt;em&gt;extension functions&lt;/em&gt; and &lt;em&gt;extension properties&lt;/em&gt;. They look like regular member functions/properties, but they are defined outside of any class - yet they reference the class name and can use &lt;code&gt;this&lt;/code&gt;. However, they can only use visible members of the class (typically just the public ones). Behind the scenes, they get compiled down to regular functions that take the target instance as a parameter.</source>
          <target state="translated">有一个不错的语法糖可以让您做到这一点：&lt;em&gt;扩展功能&lt;/em&gt;和&lt;em&gt;扩展属性&lt;/em&gt;。它们看起来像常规成员函数/属性，但是它们在任何类之外定义-但是它们引用了类名并且可以使用 &lt;code&gt;this&lt;/code&gt; 。但是，他们只能使用该类的可见成员（通常仅是公共成员）。在幕后，它们被编译为以目标实例为参数的常规函数​​。</target>
        </trans-unit>
        <trans-unit id="56a1a93e9823bbcbe462dd3f2561922740df0cc6" translate="yes" xml:space="preserve">
          <source>There is also &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.sync/with-lock.html&quot;&gt;withLock&lt;/a&gt; extension function that conveniently represents &lt;code&gt;mutex.lock(); try { ... } finally { mutex.unlock() }&lt;/code&gt; pattern:</source>
          <target state="translated">还有一个&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.sync/with-lock.html&quot;&gt;withLock&lt;/a&gt;扩展功能，可以方便地表示 &lt;code&gt;mutex.lock(); try { ... } finally { mutex.unlock() }&lt;/code&gt; 模式：</target>
        </trans-unit>
        <trans-unit id="5482d8805716b35d94ddb1402c557dc6720d3835" translate="yes" xml:space="preserve">
          <source>There is also a pair of functions that take a predicate and search for elements matching it:</source>
          <target state="translated">还有一对函数,取一个谓词并搜索与之匹配的元素。</target>
        </trans-unit>
        <trans-unit id="40c042439b9082c369e4da946808b3cddd767bd9" translate="yes" xml:space="preserve">
          <source>There is an &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/actor.html&quot;&gt;actor&lt;/a&gt; coroutine builder that conveniently combines actor's mailbox channel into its scope to receive messages from and combines the send channel into the resulting job object, so that a single reference to the actor can be carried around as its handle.</source>
          <target state="translated">有一个&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/actor.html&quot;&gt;actor&lt;/a&gt;协程生成器，可以方便地将actor的邮箱通道合并到其作用域中，以从中接收消息，并将send通道合并到结果作业对象中，以便可以随身携带对actor的单个引用作为其句柄。</target>
        </trans-unit>
        <trans-unit id="b44464d4de5fbd249cc21009c9fb2f52893bbcce" translate="yes" xml:space="preserve">
          <source>There is an optimization that removes redundant arrays creation in such cases, which prevents performance degradation. The single-argument form produces warnings in Kotlin 1.2 and is to be dropped in Kotlin 1.3.</source>
          <target state="translated">有一个优化,在这种情况下,可以去除冗余数组的创建,从而防止性能下降。单参数形式在 Kotlin 1.2 中会产生警告,在 Kotlin 1.3 中会被删除。</target>
        </trans-unit>
        <trans-unit id="6a4b4c7df274b19d3bf5dccee93fd3962d578245" translate="yes" xml:space="preserve">
          <source>There is an option to publish variants grouped by the product flavor, so that the outputs of the different build types are placed in a single module, with the build type becoming a classifier for the artifacts (the release build type is still published with no classifier). This mode is disabled by default and can be enabled as follows:</source>
          <target state="translated">有一个选项可以按产品风味分组发布变体,这样不同构建类型的输出就会被放置在一个模块中,构建类型就会成为工件的分类器(发布的构建类型仍然是没有分类器的)。该模式默认是禁用的,可以按以下方式启用。</target>
        </trans-unit>
        <trans-unit id="6a3b908fffabfbd0bb64797382bd07626137ec3f" translate="yes" xml:space="preserve">
          <source>There is common misconception that making a variable &lt;code&gt;volatile&lt;/code&gt; solves concurrency problem. Let us try it:</source>
          <target state="translated">常见的误解是，使变量 &lt;code&gt;volatile&lt;/code&gt; 可解决并发问题。让我们尝试一下：</target>
        </trans-unit>
        <trans-unit id="5eb09ee69535cf6dda53683554e0ee16259161ba" translate="yes" xml:space="preserve">
          <source>There is no dedicated type in C language for strings. A developer knows from a method signature or the documentation, whether a given &lt;code&gt;char *&lt;/code&gt; means a C string in the context. Strings in the C language are null-terminated, a trailing zero character &lt;code&gt;\0&lt;/code&gt; is added at the end of a bytes sequence to mark a string termination. Usually, &lt;a href=&quot;https://en.wikipedia.org/wiki/UTF-8&quot;&gt;UTF-8 encoded strings&lt;/a&gt; are used. The UTF-8 encoding uses variable width characters, and it is backward compatible with &lt;a href=&quot;https://en.wikipedia.org/wiki/ASCII&quot;&gt;ASCII&lt;/a&gt;. Kotlin/Native uses UTF-8 character encoding by default.</source>
          <target state="translated">C语言中没有用于字符串的专用类型。开发人员从方法签名或文档中知道，给定的 &lt;code&gt;char *&lt;/code&gt; 在上下文中是否表示C字符串。 C语言中的字符串以空字符结尾，在字节序列的末尾添加一个结尾的零字符 &lt;code&gt;\0&lt;/code&gt; ，以标记字符串的结尾。通常，使用&lt;a href=&quot;https://en.wikipedia.org/wiki/UTF-8&quot;&gt;UTF-8编码的字符串&lt;/a&gt;。 UTF-8编码使用可变宽度的字符，并且与&lt;a href=&quot;https://en.wikipedia.org/wiki/ASCII&quot;&gt;ASCII&lt;/a&gt;向后兼容。 Kotlin / Native默认使用UTF-8字符编码。</target>
        </trans-unit>
        <trans-unit id="50408f344ff56fd13407ed98b66fe0baaa2ef0c5" translate="yes" xml:space="preserve">
          <source>There is no longer an exception when running this code:</source>
          <target state="translated">运行这段代码时,不再有异常。</target>
        </trans-unit>
        <trans-unit id="edef4e6315a2b596a0ca3836f2b3be1feee84974" translate="yes" xml:space="preserve">
          <source>There is no meaning attached to values in this class, it can be used for any purpose. Pair exhibits value semantics, i.e. two pairs are equal if both components are equal.</source>
          <target state="translated">在这个类中,值没有附加的意义,它可以用于任何目的。Pair表现出值的语义,即如果两个成分都相等,那么两个对就相等。</target>
        </trans-unit>
        <trans-unit id="0049a565ebb0e6780625b95d2507e4c5901c80a7" translate="yes" xml:space="preserve">
          <source>There is no meaning attached to values in this class, it can be used for any purpose. Triple exhibits value semantics, i.e. two triples are equal if all three components are equal. An example of decomposing it into values:</source>
          <target state="translated">在这个类中,值没有附加任何意义,它可以用于任何目的。三元组表现出值的语义,即如果三个成分都相等,则两个三元组就相等。将其分解为值的一个例子。</target>
        </trans-unit>
        <trans-unit id="1dd7b0fcce3d3026dd4903ea1dcae2ace7aba63b" translate="yes" xml:space="preserve">
          <source>There is no namespaces support in C, so the Kotlin/Native compiler generates long names to avoid any possible clashes with other symbols in the existing native project.</source>
          <target state="translated">C语言中不支持命名空间,所以Kotlin/Native编译器会生成长名,以避免与现有本地项目中的其他符号发生任何可能的冲突。</target>
        </trans-unit>
        <trans-unit id="8859e68bee06f71aa7ff22831dc050e526d2f13b" translate="yes" xml:space="preserve">
          <source>There is no need to handle the case of misformatted input in competitive programming. In competitive programming, an input format is always precisely specified and the actual input cannot deviate from the input specification in the problem statement. That's what the null-assertion operator &lt;code&gt;!!&lt;/code&gt; essentially does &amp;mdash; it asserts that the input string is present and throws an exception otherwise. Likewise, the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.text/to-int&quot;&gt;String.toInt()&lt;/a&gt; function throws an exception if the input string is not an integer.</source>
          <target state="translated">在竞争性编程中，无需处理格式错误的输入。在竞争性编程中，始终精确指定输入格式，并且实际输入不能偏离问题说明中的输入规范。这就是null断言运算符 &lt;code&gt;!!&lt;/code&gt; 本质上是这样做的-它断言输入字符串存在，否则抛出异常。同样，如果输入字符串不是整数，则&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.text/to-int&quot;&gt;String.toInt（）&lt;/a&gt;函数将引发异常。</target>
        </trans-unit>
        <trans-unit id="e914e64115449100ebfd64599edfd2968cff02a7" translate="yes" xml:space="preserve">
          <source>There is now a large number of &lt;a href=&quot;building-mpp-with-gradle#supported-platforms&quot;&gt;preset platform configurations&lt;/a&gt; for different supported platforms.</source>
          <target state="translated">现在，存在针对不同支持平台的大量&lt;a href=&quot;building-mpp-with-gradle#supported-platforms&quot;&gt;预设平台配置&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9b648b3a77b4b2e5fa4527e728e2d5fe0ae2a410" translate="yes" xml:space="preserve">
          <source>There is one important semantic difference between object expressions and object declarations:</source>
          <target state="translated">对象表达式和对象声明之间有一个重要的语义区别。</target>
        </trans-unit>
        <trans-unit id="8fd6b73de53838cea1717936197f551e12e9d247" translate="yes" xml:space="preserve">
          <source>There is one more way to search elements in lists &amp;ndash; &lt;a href=&quot;https://en.wikipedia.org/wiki/Binary_search_algorithm&quot;&gt;binary search&lt;/a&gt;. It works significantly faster than other built-in search functions but &lt;em&gt;requires the list to be &lt;a href=&quot;collection-ordering&quot;&gt;sorted&lt;/a&gt;&lt;/em&gt; in ascending order according to a certain ordering: natural or another one provided in the function parameter. Otherwise, the result is undefined.</source>
          <target state="translated">搜索列表中元素的另一种方法是&lt;a href=&quot;https://en.wikipedia.org/wiki/Binary_search_algorithm&quot;&gt;二进制搜索&lt;/a&gt;。它的工作速度明显快于其他内置搜索功能，但&lt;em&gt;要求列表&lt;a href=&quot;collection-ordering&quot;&gt;&lt;/a&gt;&lt;/em&gt;按照某种顺序（自然或功能参数中提供的另一个&lt;em&gt;顺序）&lt;/em&gt;以升序排序。否则，结果是不确定的。</target>
        </trans-unit>
        <trans-unit id="c4497244354ad07743aea06bad3f15a18c72b5c2" translate="yes" xml:space="preserve">
          <source>There is still something to be desired for practical usage of coroutines. When we use &lt;code&gt;GlobalScope.launch&lt;/code&gt;, we create a top-level coroutine. Even though it is light-weight, it still consumes some memory resources while it runs. If we forget to keep a reference to the newly launched coroutine it still runs. What if the code in the coroutine hangs (for example, we erroneously delay for too long), what if we launched too many coroutines and ran out of memory? Having to manually keep references to all the launched coroutines and &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/join.html&quot;&gt;join&lt;/a&gt; them is error-prone.</source>
          <target state="translated">协程的实际使用仍需要一些东西。当使用 &lt;code&gt;GlobalScope.launch&lt;/code&gt; 时，我们将创建一个顶级协程。即使它很轻巧，它在运行时仍会消耗一些内存资源。如果我们忘记保留对新发布的协程的引用，它将继续运行。如果协程中的代码挂起（例如，我们错误地延迟了太长时间），怎么办？如果启动太多协程并用完了内存怎么办？必须手动保留对所有已启动协程的引用并&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/join.html&quot;&gt;加入&lt;/a&gt;它们是容易出错的。</target>
        </trans-unit>
        <trans-unit id="98631247ce5d35bfa57c2de9453651ac4adc252b" translate="yes" xml:space="preserve">
          <source>There may be zero or more &lt;em&gt;catch&lt;/em&gt; blocks. &lt;em&gt;finally&lt;/em&gt; block may be omitted. However at least one &lt;em&gt;catch&lt;/em&gt; or &lt;em&gt;finally&lt;/em&gt; block should be present.</source>
          <target state="translated">可能有零个或多个&lt;em&gt;捕获&lt;/em&gt;块。&lt;em&gt;最终&lt;/em&gt;块可以省略。但是，至少应有一个&lt;em&gt;抓钩&lt;/em&gt;或&lt;em&gt;最后&lt;/em&gt;一个挡块。</target>
        </trans-unit>
        <trans-unit id="f116d6d19440fd947335171cc03cdab27f6adc4e" translate="yes" xml:space="preserve">
          <source>There will be a property named &lt;code&gt;hello&lt;/code&gt;:</source>
          <target state="translated">将有一个名为 &lt;code&gt;hello&lt;/code&gt; 的属性：</target>
        </trans-unit>
        <trans-unit id="def4b70b1b61bdf7178a471139f991f3029fb44c" translate="yes" xml:space="preserve">
          <source>There will only ever be one instance of this class, and the instance (which is created the first time it is accessed, in a thread-safe manner) has got the same name as the class:</source>
          <target state="translated">这个类永远只有一个实例,而且这个实例(在第一次访问时以线程安全的方式创建)的名字与这个类相同。</target>
        </trans-unit>
        <trans-unit id="6f9f7587a2e090ad5e29fbff32347947646d8531" translate="yes" xml:space="preserve">
          <source>There's a little bit of runtime overhead associated with lambda functions: they are really objects, so they must be instantiated, and (like other functions) calling them takes a little bit of time too. If we use the &lt;code&gt;inline&lt;/code&gt; keyword on a function, we tell the compiler to &lt;em&gt;inline&lt;/em&gt; both the function and its lambda parameters (if any) - that is, the compiler will copy the code of the function (and its lambda parameters) into &lt;em&gt;every&lt;/em&gt; callsite, thus eliminating the overhead of both the lambda instantiation and the calling of the function and the lambdas. This will happen unconditionally, unlike in C and C++, where &lt;code&gt;inline&lt;/code&gt; is more of a hint to the compiler. This will cause the size of the compiled code to grow, but it may be worth it for certain small but frequently-called functions.</source>
          <target state="translated">Lambda函数有一些运行时开销：它们实际上是对象，因此必须实例化它们，并且（与其他函数一样）调用它们也需要一点时间。如果我们在函数上使用 &lt;code&gt;inline&lt;/code&gt; 关键字，则会告诉编译器&lt;em&gt;内联&lt;/em&gt;函数和其lambda参数（如果有）-也就是说，编译器会将函数的代码（及其lambda参数）复制到&lt;em&gt;每个&lt;/em&gt;调用站点中，这样就消除了lambda实例化以及函数和lambda调用的开销。这将无条件发生，这与C和C ++中的 &lt;code&gt;inline&lt;/code&gt; 对编译器来说更多的是提示。这将导致已编译代码的大小增加，但是对于某些较小但经常调用的函数可能值得这样做。</target>
        </trans-unit>
        <trans-unit id="1db5770d8b83e30706aed362d9428bb0d8466fab" translate="yes" xml:space="preserve">
          <source>There's a vast collection of functional programming-style operations available in the &lt;a href=&quot;../../../api/latest/jvm/stdlib/kotlin.collections/index&quot;&gt;&lt;code&gt;kotlin.collections&lt;/code&gt; package&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../../../api/latest/jvm/stdlib/kotlin.collections/index&quot;&gt; &lt;code&gt;kotlin.collections&lt;/code&gt; 包中&lt;/a&gt;提供了大量功能编程风格的操作。</target>
        </trans-unit>
        <trans-unit id="202786b020b9056a1534a505736791f80248ba7e" translate="yes" xml:space="preserve">
          <source>There's no 64 bit integer number in JavaScript, so &lt;code&gt;kotlin.Long&lt;/code&gt; is not mapped to any JavaScript object, it's emulated by a Kotlin class.</source>
          <target state="translated">JavaScript中没有64位整数，因此 &lt;code&gt;kotlin.Long&lt;/code&gt; 不会映射到任何JavaScript对象，而是由Kotlin类模拟的。</target>
        </trans-unit>
        <trans-unit id="9178e1d163a2f07f63e80e90e8b72e40666cb6be" translate="yes" xml:space="preserve">
          <source>There's no such syntax in Kotlin. However, in Kotlin we have &lt;code&gt;companion&lt;/code&gt; objects. Kotlin treats companion objects of &lt;code&gt;external&lt;/code&gt; class in a special way: instead of expecting an object, it assumes members of companion objects to be members of the class itself. To describe &lt;code&gt;MyClass&lt;/code&gt; from the example above, you can write:</source>
          <target state="translated">Kotlin中没有这样的语法。但是，在Kotlin中，我们有 &lt;code&gt;companion&lt;/code&gt; 对象。Kotlin 以一种特殊的方式对待 &lt;code&gt;external&lt;/code&gt; 类的同伴对象：与其期望一个对象，不如假设一个同伴对象的成员是该类本身的成员。为了从上面的示例描述 &lt;code&gt;MyClass&lt;/code&gt; ，您可以编写：</target>
        </trans-unit>
        <trans-unit id="918d499d192390404b8163b61ae9ad18a046a4a8" translate="yes" xml:space="preserve">
          <source>There's two forms of using &lt;code&gt;definedExternally&lt;/code&gt;:</source>
          <target state="translated">有两种使用 &lt;code&gt;definedExternally&lt;/code&gt; 的形式：</target>
        </trans-unit>
        <trans-unit id="1d27760789bc7d15f7cae3944fffbd1ed1e60b2e" translate="yes" xml:space="preserve">
          <source>Therefore if the &lt;a href=&quot;write#kotlin.concurrent%24write%28java.util.concurrent.locks.ReentrantReadWriteLock%2C+kotlin.Function0%28%28kotlin.concurrent.write.T%29%29%29%2Faction&quot;&gt;action&lt;/a&gt; inside write lock has been initiated by checking some condition, the condition must be rechecked inside the &lt;a href=&quot;write#kotlin.concurrent%24write%28java.util.concurrent.locks.ReentrantReadWriteLock%2C+kotlin.Function0%28%28kotlin.concurrent.write.T%29%29%29%2Faction&quot;&gt;action&lt;/a&gt; to avoid possible races.</source>
          <target state="translated">因此，如果&lt;a href=&quot;write#kotlin.concurrent%24write%28java.util.concurrent.locks.ReentrantReadWriteLock%2C+kotlin.Function0%28%28kotlin.concurrent.write.T%29%29%29%2Faction&quot;&gt;动作&lt;/a&gt;写锁内已通过检查一些条件启动，条件必须在内部重新检查&lt;a href=&quot;write#kotlin.concurrent%24write%28java.util.concurrent.locks.ReentrantReadWriteLock%2C+kotlin.Function0%28%28kotlin.concurrent.write.T%29%29%29%2Faction&quot;&gt;行动&lt;/a&gt;，以避免可能的比赛。</target>
        </trans-unit>
        <trans-unit id="0f17bb5adc41c5c7eefa8d167c2c05552954588a" translate="yes" xml:space="preserve">
          <source>Therefore, the two following snippets are equivalent:</source>
          <target state="translated">因此,以下两个片段是等价的。</target>
        </trans-unit>
        <trans-unit id="b2fcfe97b28b6d55545bf13f39eacf58d2cbb997" translate="yes" xml:space="preserve">
          <source>Therefore, there is no general way to check whether an instance of a generic type was created with certain type arguments at runtime, and the compiler &lt;a href=&quot;typecasts#type-erasure-and-generic-type-checks&quot;&gt;prohibits such &lt;em&gt;is&lt;/em&gt;-checks&lt;/a&gt;.</source>
          <target state="translated">因此，没有通用的方法来检查在运行时是否使用某些类型参数创建了泛型类型的实例，并且编译器&lt;a href=&quot;typecasts#type-erasure-and-generic-type-checks&quot;&gt;禁止使用&lt;em&gt;is&lt;/em&gt; -checks&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ba4578c0908f499a877e6e75a3e1e8fb6ca14fec" translate="yes" xml:space="preserve">
          <source>These &lt;a href=&quot;typecasts#unchecked-casts&quot;&gt;unchecked casts&lt;/a&gt; can be used when type safety is implied by the high-level program logic but cannot be inferred directly by the compiler. The compiler issues a warning on unchecked casts, and at runtime, only the non-generic part is checked (equivalent to &lt;code&gt;foo as List&amp;lt;*&amp;gt;&lt;/code&gt;).</source>
          <target state="translated">当高级程序逻辑隐含类型安全性但编译器无法直接推断出类型安全性时，可以使用这些&lt;a href=&quot;typecasts#unchecked-casts&quot;&gt;未经检查的强制转换&lt;/a&gt;。编译器会在未检查的强制转换上发出警告，并且在运行时仅检查非通用部分（相当于 &lt;code&gt;foo as List&amp;lt;*&amp;gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="dd3d3ea77431105543bdd1015eeb929086add1c8" translate="yes" xml:space="preserve">
          <source>These abstract classes can be used as base classes when implementing Kotlin collection classes. For implementing read-only collections there are &lt;code&gt;AbstractCollection&lt;/code&gt;, &lt;code&gt;AbstractList&lt;/code&gt;, &lt;code&gt;AbstractSet&lt;/code&gt; and &lt;code&gt;AbstractMap&lt;/code&gt;, and for mutable collections there are &lt;code&gt;AbstractMutableCollection&lt;/code&gt;, &lt;code&gt;AbstractMutableList&lt;/code&gt;, &lt;code&gt;AbstractMutableSet&lt;/code&gt; and &lt;code&gt;AbstractMutableMap&lt;/code&gt;. On JVM these abstract mutable collections inherit most of their functionality from JDK's abstract collections.</source>
          <target state="translated">在实现Kotlin集合类时，可以将这些抽象类用作基类。为了实现只读集合，有 &lt;code&gt;AbstractCollection&lt;/code&gt; ， &lt;code&gt;AbstractList&lt;/code&gt; ， &lt;code&gt;AbstractSet&lt;/code&gt; 和 &lt;code&gt;AbstractMap&lt;/code&gt; ；对于可变集合，有 &lt;code&gt;AbstractMutableCollection&lt;/code&gt; ， &lt;code&gt;AbstractMutableList&lt;/code&gt; ， &lt;code&gt;AbstractMutableSet&lt;/code&gt; 和 &lt;code&gt;AbstractMutableMap&lt;/code&gt; 。在JVM上，这些抽象可变集合从JDK的抽象集合继承了大多数功能。</target>
        </trans-unit>
        <trans-unit id="aae55c4083a74f1ac27e26d5124083a7a6b3b4cb" translate="yes" xml:space="preserve">
          <source>These are the &lt;a href=&quot;#default-project-layout&quot;&gt;default source set names&lt;/a&gt; for the production and test sources for the targets configured above. The source sets &lt;code&gt;commonMain&lt;/code&gt; and &lt;code&gt;commonTest&lt;/code&gt; are included into production and test compilations, respectively, of all targets. Note that the dependencies for common source sets &lt;code&gt;commonMain&lt;/code&gt; and &lt;code&gt;commonTest&lt;/code&gt; are the common artifacts, and the platform libraries go to the source sets of the specific targets.</source>
          <target state="translated">这些是上面配置的目标的生产和测试源的&lt;a href=&quot;#default-project-layout&quot;&gt;默认源集名称&lt;/a&gt;。源集 &lt;code&gt;commonMain&lt;/code&gt; 和 &lt;code&gt;commonTest&lt;/code&gt; 分别包含在所有目标的生产和测试编译中。请注意，公共源集 &lt;code&gt;commonMain&lt;/code&gt; 和 &lt;code&gt;commonTest&lt;/code&gt; 的依赖项是公共工件，平台库转到特定目标的源集。</target>
        </trans-unit>
        <trans-unit id="6c67dd2d501b6f7860e7b47d523d2ae61bab43e4" translate="yes" xml:space="preserve">
          <source>These are three general-purpose extension functions applicable to any receiver.</source>
          <target state="translated">这是三个适用于任何接收器的通用扩展功能。</target>
        </trans-unit>
        <trans-unit id="4a99a063b2c797ffc59fde5538599b9e6760c083" translate="yes" xml:space="preserve">
          <source>These considerations lead to the following rules. A covariant type parameter &lt;code&gt;T&lt;/code&gt; (which the user of an object might think is &lt;code&gt;Fruit&lt;/code&gt;, while the object in reality is tied to &lt;code&gt;Apple&lt;/code&gt;) may be used as:</source>
          <target state="translated">这些考虑导致以下规则。协变类型参数 &lt;code&gt;T&lt;/code&gt; （对象的用户可能认为它是 &lt;code&gt;Fruit&lt;/code&gt; ，而实际上该对象与 &lt;code&gt;Apple&lt;/code&gt; 绑定）可以用作：</target>
        </trans-unit>
        <trans-unit id="e8a12f370f83960d4f7413fab1b904c1e1f23ab2" translate="yes" xml:space="preserve">
          <source>These declarations look clear. All &lt;code&gt;char *&lt;/code&gt; pointers are turned into &lt;code&gt;str: CValuesRef&amp;lt;ByteVar&amp;gt;?&lt;/code&gt; for parameters and to &lt;code&gt;CPointer&amp;lt;ByteVar&amp;gt;?&lt;/code&gt; in return types. Kotlin turns &lt;code&gt;char&lt;/code&gt; type into &lt;code&gt;kotlin.Byte&lt;/code&gt; type, as it is usually an 8-bit signed value.</source>
          <target state="translated">这些声明看起来很清楚。所有 &lt;code&gt;char *&lt;/code&gt; 指针都转换为 &lt;code&gt;str: CValuesRef&amp;lt;ByteVar&amp;gt;?&lt;/code&gt; 参数和 &lt;code&gt;CPointer&amp;lt;ByteVar&amp;gt;?&lt;/code&gt; 返回类型。Kotlin将 &lt;code&gt;char&lt;/code&gt; 类型转换为 &lt;code&gt;kotlin.Byte&lt;/code&gt; 类型，因为它通常是一个8位带符号的值。</target>
        </trans-unit>
        <trans-unit id="53e4257de1ac9420719572d5eaf311fafd22b5c2" translate="yes" xml:space="preserve">
          <source>These features are not considered production ready yet, so you need to turn on the &lt;em&gt;experimental mode&lt;/em&gt; in &lt;code&gt;build.gradle&lt;/code&gt; in order to use them:</source>
          <target state="translated">这些功能尚未被考虑用于生产环境，因此您需要在 &lt;code&gt;build.gradle&lt;/code&gt; 中打开&lt;em&gt;实验模式&lt;/em&gt;才能使用它们：</target>
        </trans-unit>
        <trans-unit id="e6b05d8f5b89932c0c2ddc8328889d3567a05266" translate="yes" xml:space="preserve">
          <source>These functions can also be used for converting collections to other types, for example, build a set from a list or vice versa.</source>
          <target state="translated">这些函数也可以用于将集合转换为其他类型,例如,从列表中建立一个集合或反之。</target>
        </trans-unit>
        <trans-unit id="d5e9c8cae28543e16ef49eb2054cfc4937ef3fcf" translate="yes" xml:space="preserve">
          <source>These functions can be used for easy copying of maps:</source>
          <target state="translated">这些功能可以用来方便复制地图。</target>
        </trans-unit>
        <trans-unit id="2a7f12885b59bbc14ccabadd6389a34cf6ff8eb2" translate="yes" xml:space="preserve">
          <source>These functions can be used to find the lowest and greatest of two or three given values, where values are primitive numbers or &lt;code&gt;Comparable&lt;/code&gt; objects. There is also an overload of each function that take an additional &lt;code&gt;Comparator&lt;/code&gt; instance, if you want to compare objects that are not comparable themselves.</source>
          <target state="translated">这些函数可用于查找两个或三个给定值中的最小和最大值，其中值是原始数或 &lt;code&gt;Comparable&lt;/code&gt; 对象。如果您要比较本身不具有可比性的对象，则每个函数还有一个额外的 &lt;code&gt;Comparator&lt;/code&gt; 实例会重载。</target>
        </trans-unit>
        <trans-unit id="8f7f5c9e85694705edbe3da3b621cafe8f2795f3" translate="yes" xml:space="preserve">
          <source>These functions deal with Kotlin/Native objects. Call the &lt;code&gt;DisposeStablePointer&lt;/code&gt; to release a Kotlin object and &lt;code&gt;DisposeString&lt;/code&gt; to release a Kotlin String, which has the &lt;code&gt;char*&lt;/code&gt; type in C. It is possible to use the &lt;code&gt;IsInstance&lt;/code&gt; function to check if a Kotlin type or a &lt;code&gt;libnative_KNativePtr&lt;/code&gt; is an instance of another type. The actual set of operations generated depends on the actual usages.</source>
          <target state="translated">这些功能处理Kotlin / Native对象。调用 &lt;code&gt;DisposeStablePointer&lt;/code&gt; 释放科特林对象和 &lt;code&gt;DisposeString&lt;/code&gt; 释放科特林字符串，其具有 &lt;code&gt;char*&lt;/code&gt; 类型C.它是能够使用 &lt;code&gt;IsInstance&lt;/code&gt; 函数来检查科特林型或 &lt;code&gt;libnative_KNativePtr&lt;/code&gt; 是另一种类型的一个实例。生成的实际操作集取决于实际用法。</target>
        </trans-unit>
        <trans-unit id="ebcfd0ed6c7e90830065d9ee1e014161378d5e50" translate="yes" xml:space="preserve">
          <source>These include &lt;a href=&quot;reflection#bound-function-and-property-references-since-11&quot;&gt;bound callable references&lt;/a&gt; that point to a member of a particular instance: &lt;code&gt;foo::toString&lt;/code&gt;.</source>
          <target state="translated">这些包括指向特定实例成员的&lt;a href=&quot;reflection#bound-function-and-property-references-since-11&quot;&gt;绑定可调用引用&lt;/a&gt;： &lt;code&gt;foo::toString&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="341a2ef673574a4668acee83662de92778d835b1" translate="yes" xml:space="preserve">
          <source>These operators only work with the function &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin/-any/equals&quot;&gt;&lt;code&gt;equals(other: Any?): Boolean&lt;/code&gt;&lt;/a&gt;, which can be overridden to provide custom equality check implementation. Any other function with the same name (like &lt;code&gt;equals(other: Foo)&lt;/code&gt;) will not be called.</source>
          <target state="translated">这些运算符仅与&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin/-any/equals&quot;&gt; &lt;code&gt;equals(other: Any?): Boolean&lt;/code&gt; &lt;/a&gt;函数一起使用，可以重写以提供自定义相等性检查实现。具有相同名称的任何其他函数（例如 &lt;code&gt;equals(other: Foo)&lt;/code&gt; ）都不会被调用。</target>
        </trans-unit>
        <trans-unit id="04c64c9fdc4ddbb026d14664db7dfcf575773eab" translate="yes" xml:space="preserve">
          <source>These options have nearly the same effect as clang's &lt;code&gt;-fembed-bitcode&lt;/code&gt;/&lt;code&gt;-fembed-bitcode-marker&lt;/code&gt; and swiftc's &lt;code&gt;-embed-bitcode&lt;/code&gt;/&lt;code&gt;-embed-bitcode-marker&lt;/code&gt;.</source>
          <target state="translated">这些选项与clang的 &lt;code&gt;-fembed-bitcode&lt;/code&gt; / &lt;code&gt;-fembed-bitcode-marker&lt;/code&gt; 和swiftc的 &lt;code&gt;-embed-bitcode&lt;/code&gt; / &lt;code&gt;-embed-bitcode-marker&lt;/code&gt; 具有几乎相同的效果。</target>
        </trans-unit>
        <trans-unit id="42a0b78cb4e25be9e1f6ef7cf3d39eb3e781050e" translate="yes" xml:space="preserve">
          <source>These tasks are defined in the &lt;em&gt;kotlin-ant.jar&lt;/em&gt; library which is located in the &lt;em&gt;lib&lt;/em&gt; folder for the &lt;a href=&quot;https://github.com/JetBrains/kotlin/releases/tag/v1.3.41&quot;&gt;Kotlin Compiler&lt;/a&gt; Ant version 1.8.2+ is required.</source>
          <target state="translated">这些任务在&lt;em&gt;kotlin-ant.jar&lt;/em&gt;库中定义，该库位于&lt;a href=&quot;https://github.com/JetBrains/kotlin/releases/tag/v1.3.41&quot;&gt;Kotlin Compiler&lt;/a&gt; Ant版本1.8.2+ 的&lt;em&gt;lib&lt;/em&gt;文件夹中。</target>
        </trans-unit>
        <trans-unit id="1d0ae43a71338a23e33d7f8aec6b35c87860e63a" translate="yes" xml:space="preserve">
          <source>These transformations can also be applied to &lt;code&gt;Sequence&amp;lt;T&amp;gt;&lt;/code&gt;, which is similar to Python's generators and allows for lazy evaluation. If you have a huge list and you want to process it lazily, you can call &lt;code&gt;asSequence()&lt;/code&gt; on it.</source>
          <target state="translated">这些转换也可以应用于 &lt;code&gt;Sequence&amp;lt;T&amp;gt;&lt;/code&gt; ，它类似于Python的生成器，并允许进行惰性求值。如果您有一个庞大的列表，并且想要懒惰地处理它，则可以在其上调用 &lt;code&gt;asSequence()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="03f364964cb20dc479a4f5003a2a44d235abdb7a" translate="yes" xml:space="preserve">
          <source>These two functions can not be defined side-by-side, because their JVM signatures are the same: &lt;code&gt;filterValid(Ljava/util/List;)Ljava/util/List;&lt;/code&gt;. If we really want them to have the same name in Kotlin, we can annotate one (or both) of them with &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.jvm/-jvm-name/index&quot;&gt;&lt;code&gt;@JvmName&lt;/code&gt;&lt;/a&gt; and specify a different name as an argument:</source>
          <target state="translated">这两个函数不能并排定义，因为它们的JVM签名是相同的： &lt;code&gt;filterValid(Ljava/util/List;)Ljava/util/List;&lt;/code&gt; 。如果我们确实希望它们在Kotlin中具有相同的名称，则可以使用&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.jvm/-jvm-name/index&quot;&gt; &lt;code&gt;@JvmName&lt;/code&gt; &lt;/a&gt;注释其中一个（或两个），并指定其他名称作为参数：</target>
        </trans-unit>
        <trans-unit id="921fb3d0fcc9e0673ab266d259447beb1dbfed2e" translate="yes" xml:space="preserve">
          <source>These two options let you choose the proper function depending on what you do next in your code.</source>
          <target state="translated">这两个选项可以让你根据你接下来在代码中的操作选择合适的函数。</target>
        </trans-unit>
        <trans-unit id="5dbdf5173288dba5a705ae6e593e7cbdf4691ea2" translate="yes" xml:space="preserve">
          <source>These types are used to map boxed Kotlin number types into Objective-C and Swift. In Swift, we may simply call the constructor to create an instance, e.g. &lt;code&gt;KotlinLong(value: 42)&lt;/code&gt;.</source>
          <target state="translated">这些类型用于将装箱的Kotlin数字类型映射到Objective-C和Swift。在Swift中，我们可以简单地调用构造函数来创建一个实例，例如 &lt;code&gt;KotlinLong(value: 42)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c780ae4d91e6b3d59d657bd21738eface7e6d706" translate="yes" xml:space="preserve">
          <source>These types have a special notation that corresponds to the signatures of the functions, i.e. their parameters and return values:</source>
          <target state="translated">这些类型有一个特殊的符号,对应于函数的签名,即它们的参数和返回值。</target>
        </trans-unit>
        <trans-unit id="49301d7c0ca361c41d110b3bca3a6ef2c53c1486" translate="yes" xml:space="preserve">
          <source>They also can be used in return statements of functions returning the context object.</source>
          <target state="translated">它们也可以用于返回上下文对象的函数的返回语句中。</target>
        </trans-unit>
        <trans-unit id="6e6ad519d848a011249fae6e51a09e8caed4ec20" translate="yes" xml:space="preserve">
          <source>They can't be passed as reified type arguments.</source>
          <target state="translated">它们不能作为重构类型参数传递。</target>
        </trans-unit>
        <trans-unit id="9f968b20031a0c4e81acc38a3f23bdedaba5b962" translate="yes" xml:space="preserve">
          <source>They can't be used in class literal expressions (i.e. &lt;code&gt;I::class&lt;/code&gt;).</source>
          <target state="translated">它们不能用于类文字表达式（即 &lt;code&gt;I::class&lt;/code&gt; ）中。</target>
        </trans-unit>
        <trans-unit id="2f0701452411de1234771e67765d254ade0b6df7" translate="yes" xml:space="preserve">
          <source>They can't be used on the right hand side of &lt;code&gt;is&lt;/code&gt; checks.</source>
          <target state="translated">它们不能在 &lt;code&gt;is&lt;/code&gt; 支票的右侧使用。</target>
        </trans-unit>
        <trans-unit id="398723a13324bec77451c1ae01057e1ef7af3705" translate="yes" xml:space="preserve">
          <source>They must be member functions or &lt;a href=&quot;extensions&quot;&gt;extension functions&lt;/a&gt;;</source>
          <target state="translated">它们必须是成员函数或&lt;a href=&quot;extensions&quot;&gt;扩展函数&lt;/a&gt; ;</target>
        </trans-unit>
        <trans-unit id="d532a698fc6a89ca0085db59fd5aa194790955a6" translate="yes" xml:space="preserve">
          <source>They must have a single parameter;</source>
          <target state="translated">它们必须有一个单一的参数。</target>
        </trans-unit>
        <trans-unit id="4df440c5a2dac5df94e2c6decf7738ac3f8470ab" translate="yes" xml:space="preserve">
          <source>Third value.</source>
          <target state="translated">第三值:</target>
        </trans-unit>
        <trans-unit id="65054a6c60d19f99f3ba82de08ae0a53fc9c01d3" translate="yes" xml:space="preserve">
          <source>This API can be used to group a collection by key and fold each group simultaneously. For example, it can be used to count the number of words starting with each letter:</source>
          <target state="translated">这个API可以用来按键对一个集合进行分组,并同时折叠每个组。例如,它可以用来计算以每个字母开头的单词数量。</target>
        </trans-unit>
        <trans-unit id="c5e92a8ba9a486d6b6f5f3bfcee1ee9e16e21ffe" translate="yes" xml:space="preserve">
          <source>This Expression</source>
          <target state="translated">这种表达方式</target>
        </trans-unit>
        <trans-unit id="39d8e7ef05f8d1193ddfe60ed385361228082346" translate="yes" xml:space="preserve">
          <source>This allows the Java Persistence API (JPA) to instantiate a class although it doesn't have the zero-parameter constructor from Kotlin or Java point of view (see the description of &lt;code&gt;kotlin-jpa&lt;/code&gt; plugin &lt;a href=&quot;compiler-plugins#jpa-support&quot;&gt;below&lt;/a&gt;).</source>
          <target state="translated">尽管从Kotlin或Java的角度来看，它没有零参数构造函数，但它允许Java Persistence API（JPA）实例化一个类（请参阅&lt;a href=&quot;compiler-plugins#jpa-support&quot;&gt;下面&lt;/a&gt;的 &lt;code&gt;kotlin-jpa&lt;/code&gt; 插件说明）。</target>
        </trans-unit>
        <trans-unit id="262a7c17763f126ac70f16b74664e0c2732654ca" translate="yes" xml:space="preserve">
          <source>This allows the user code to not pass an extra &lt;a href=&quot;-coroutine-context/index&quot;&gt;CoroutineContext&lt;/a&gt; parameter in basic coroutine builders like &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental/launch.html&quot;&gt;launch&lt;/a&gt; and &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental/async.html&quot;&gt;async&lt;/a&gt;, but still provide easy access to coroutine context.</source>
          <target state="translated">这允许用户代码在基本的协程构建器（如&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental/launch.html&quot;&gt;launch&lt;/a&gt;和&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental/async.html&quot;&gt;async）中&lt;/a&gt;不传递额外的&lt;a href=&quot;-coroutine-context/index&quot;&gt;CoroutineContext&lt;/a&gt;参数，但仍提供对协程上下文的轻松访问。</target>
        </trans-unit>
        <trans-unit id="eb2da247bb9f320229aba7d44d4da4813d52b5e8" translate="yes" xml:space="preserve">
          <source>This allows us to write:</source>
          <target state="translated">这样我们就可以写。</target>
        </trans-unit>
        <trans-unit id="2943eee5e149bda0a3b90788c4e427a3f77fb555" translate="yes" xml:space="preserve">
          <source>This also a reason why, in these examples, &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-exception-handler/index.html&quot;&gt;CoroutineExceptionHandler&lt;/a&gt; is always installed to a coroutine that is created in &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-global-scope/index.html&quot;&gt;GlobalScope&lt;/a&gt;. It does not make sense to install an exception handler to a coroutine that is launched in the scope of the main &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/run-blocking.html&quot;&gt;runBlocking&lt;/a&gt;, since the main coroutine is going to be always cancelled when its child completes with exception despite the installed handler.</source>
          <target state="translated">这也是为什么在这些示例中，始终将&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-exception-handler/index.html&quot;&gt;CoroutineExceptionHandler&lt;/a&gt;安装到在&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-global-scope/index.html&quot;&gt;GlobalScope中&lt;/a&gt;创建的协程的原因。将异常处理程序安装到在主&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/run-blocking.html&quot;&gt;runBlocking&lt;/a&gt;范围内启动的协程中没有意义，因为尽管已安装了处理程序，但当其子级异常完成时，主协程将始终被取消。</target>
        </trans-unit>
        <trans-unit id="369f2b1361dad7365016272a8691f3b6c2f5f7b0" translate="yes" xml:space="preserve">
          <source>This also works in &lt;a href=&quot;multi-declarations&quot;&gt;destructuring declarations&lt;/a&gt;:</source>
          <target state="translated">这也适用于&lt;a href=&quot;multi-declarations&quot;&gt;销毁声明&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="7624b3ac5961056978ec90a7581d578f33bbbb61" translate="yes" xml:space="preserve">
          <source>This annotation indicates what exceptions should be declared by a function when compiled to a JVM method.</source>
          <target state="translated">这个注解指出了在编译到JVM方法时,函数应该声明哪些异常。</target>
        </trans-unit>
        <trans-unit id="3b67d7593eb58defe040aee620d9f9dc5b7b870b" translate="yes" xml:space="preserve">
          <source>This annotation indicates what exceptions should be declared by a function when compiled to a platform method.</source>
          <target state="translated">这个注解指出了在编译成平台方法时,函数应该声明哪些异常。</target>
        </trans-unit>
        <trans-unit id="53852272acd887d2ace151213b2a79c6186dd5ad" translate="yes" xml:space="preserve">
          <source>This annotation is intended for &lt;em&gt;rare cases&lt;/em&gt; when API designer needs to hide Kotlin-specific target from Java API while keeping it a part of Kotlin API so the resulting API is idiomatic for both languages.</source>
          <target state="translated">此注释适用于&lt;em&gt;极少数情况，&lt;/em&gt;当API设计人员需要从Java API中隐藏Kotlin特定的目标，同时又将其保留为Kotlin API的一部分时，这样生成的API对于两种语言都是惯用的。</target>
        </trans-unit>
        <trans-unit id="f7ff9954f76ed995dd9da4bc5f1699538f3cd9e5" translate="yes" xml:space="preserve">
          <source>This annotation is only applicable to &lt;code&gt;expect&lt;/code&gt; annotation classes in multi-platform projects and marks that class as &quot;optional&quot;. Optional expected class is allowed to have no corresponding actual class on the platform. Optional annotations can only be used to annotate something, not as types in signatures. If an optional annotation has no corresponding actual class on a platform, the annotation entries where it's used are simply erased when compiling code on that platform.</source>
          <target state="translated">该批注仅适用于多平台项目中的 &lt;code&gt;expect&lt;/code&gt; 批注类，并将该类标记为&amp;ldquo;可选&amp;rdquo;。可选的预期类别允许在平台上没有相应的实际类别。可选注释只能用于注释某些内容，而不能用作签名中的类型。如果可选注释在平台上没有对应的实际类，则在该平台上编译代码时，将仅删除使用该注释的条目。</target>
        </trans-unit>
        <trans-unit id="c1b9122ad4cc089c09a766a63290941217a27add" translate="yes" xml:space="preserve">
          <source>This annotation is present on any class file produced by the Kotlin compiler and is read by the compiler and reflection. Parameters have very short JVM names on purpose: these names appear in all generated class files, and we'd like to reduce their size.</source>
          <target state="translated">这个注解存在于Kotlin编译器生成的任何类文件上,并被编译器和反射读取。参数的JVM名称非常短是有目的的:这些名称出现在所有生成的类文件中,我们希望减少它们的大小。</target>
        </trans-unit>
        <trans-unit id="08e24e4cbc4d173492beb5ffd4d4ddb94a113383" translate="yes" xml:space="preserve">
          <source>This annotation marks the standard library API that is considered experimental and is not subject to the &lt;a href=&quot;../../../../../../docs/reference/evolution/components-stability&quot;&gt;general compatibility guarantees&lt;/a&gt; given for the standard library: the behavior of such API may be changed or the API may be removed completely in any further release.</source>
          <target state="translated">此批注标记了被认为是实验性的标准库API，不受标准库所&lt;a href=&quot;../../../../../../docs/reference/evolution/components-stability&quot;&gt;提供&lt;/a&gt;的一般兼容性保证的约束：此类API的行为可能会更改，或者在任何后续发行版中都可能会完全删除该API。</target>
        </trans-unit>
        <trans-unit id="400bdfa2156af296817e663103c3f69c483eb8d7" translate="yes" xml:space="preserve">
          <source>This annotation marks the standard library API that is considered experimental and is not subject to the &lt;a href=&quot;../../../../../docs/reference/evolution/components-stability&quot;&gt;general compatibility guarantees&lt;/a&gt; given for the standard library: the behavior of such API may be changed or the API may be removed completely in any further release.</source>
          <target state="translated">此批注标记了被认为是实验性的标准库API，不受标准库所&lt;a href=&quot;../../../../../docs/reference/evolution/components-stability&quot;&gt;提供&lt;/a&gt;的一般兼容性保证的约束：此类API的行为可能会更改，或者在任何后续发行版中都可能会完全删除该API。</target>
        </trans-unit>
        <trans-unit id="4a3b2ae9c5594175372b79e16080724e6e8baa3b" translate="yes" xml:space="preserve">
          <source>This approach requires a series of changes in how we program, in particular</source>
          <target state="translated">这种方法需要我们改变一系列的编程方式,尤其是</target>
        </trans-unit>
        <trans-unit id="caabd1756e7a5fe69a248020021b58534dfbff4d" translate="yes" xml:space="preserve">
          <source>This behavior is correct but it can be very inconvenient for some libraries. So it is possible to specify in the &lt;code&gt;.def&lt;/code&gt; file which of the included headers are to be imported. The separate declarations from other headers can also be imported in case of direct dependencies.</source>
          <target state="translated">此行为是正确的，但对于某些库来说可能非常不便。因此，可以在 &lt;code&gt;.def&lt;/code&gt; 文件中指定要导入的包括哪些标头。在直接依赖的情况下，也可以导入与其他标头分开的声明。</target>
        </trans-unit>
        <trans-unit id="c6b0989aa993ac0e544c959f288dcd6e31817be1" translate="yes" xml:space="preserve">
          <source>This behavior is similar to &lt;a href=&quot;extensions&quot;&gt;extension functions&lt;/a&gt;, which also allow you to access the members of the receiver object inside the body of the function.</source>
          <target state="translated">此行为类似于&lt;a href=&quot;extensions&quot;&gt;扩展功能&lt;/a&gt;，该扩展功能还允许您访问函数主体内的接收器对象的成员。</target>
        </trans-unit>
        <trans-unit id="e20a24097999574b06c858b7503368f6bbdeb55a" translate="yes" xml:space="preserve">
          <source>This callback method should call one of these two methods:</source>
          <target state="translated">这个回调方法应该调用这两个方法中的一个。</target>
        </trans-unit>
        <trans-unit id="216d2a3ecca96db5ee19a6d39eef11e98c9f0bf5" translate="yes" xml:space="preserve">
          <source>This can be effectively combined with other idioms, leading to shorter code. E.g. with the &lt;em&gt;when&lt;/em&gt;-expression:</source>
          <target state="translated">这可以与其他惯用法有效地结合在一起，从而缩短代码长度。例如，&lt;em&gt;当when&lt;/em&gt;表达式：</target>
        </trans-unit>
        <trans-unit id="a3b4ad6a40906907f86d5ceb0160f0fc35e4272e" translate="yes" xml:space="preserve">
          <source>This can be useful for creating &lt;a href=&quot;../kotlin.collections/-map/index#kotlin.collections.Map&quot;&gt;Map&lt;/a&gt; literals with less noise, for example:</source>
          <target state="translated">这对于创建噪声较小的&lt;a href=&quot;../kotlin.collections/-map/index#kotlin.collections.Map&quot;&gt;Map&lt;/a&gt;文字很有用，例如：</target>
        </trans-unit>
        <trans-unit id="7e1ff87841658b954b989c8097e33f6cc0f4c4fa" translate="yes" xml:space="preserve">
          <source>This check is only available for the properties that are lexically accessible, i.e. declared in the same type or in one of the outer types, or at top level in the same file.</source>
          <target state="translated">该检查仅对词法上可访问的属性有效,即在同一类型或外类型之一中声明,或在同一文件的顶层声明。</target>
        </trans-unit>
        <trans-unit id="b8e6d8ea08a6d2f26902035e61567b7b01f67c89" translate="yes" xml:space="preserve">
          <source>This class cannot be either co- or contravariant in &lt;code&gt;T&lt;/code&gt;. And this imposes certain inflexibilities. Consider the following function:</source>
          <target state="translated">此类不能在 &lt;code&gt;T&lt;/code&gt; 中是协变或逆变的。这会带来一定的灵活性。考虑以下功能：</target>
        </trans-unit>
        <trans-unit id="cfa1db139b7b160a14b6c47d1a1495d378da6d44" translate="yes" xml:space="preserve">
          <source>This class is experimental itself and can only be used with the compiler argument &lt;code&gt;-Xuse-experimental=kotlin.Experimental&lt;/code&gt;.</source>
          <target state="translated">此类本身是实验性的，只能与编译器参数 &lt;code&gt;-Xuse-experimental=kotlin.Experimental&lt;/code&gt; 一起使用。</target>
        </trans-unit>
        <trans-unit id="f5fdf32c20c754f3849efeb2ffb6fd9fe85ddd31" translate="yes" xml:space="preserve">
          <source>This class is intended to help implementing read-only lists so it doesn't support concurrent modification tracking.</source>
          <target state="translated">这个类是为了帮助实现只读列表,所以不支持并发修改跟踪。</target>
        </trans-unit>
        <trans-unit id="3649d86d1c264225e25ee01e6d003c299727a7d0" translate="yes" xml:space="preserve">
          <source>This class is intended to help implementing read-only sets so it doesn't support concurrent modification tracking.</source>
          <target state="translated">这个类是为了帮助实现只读集,所以不支持并发修改跟踪。</target>
        </trans-unit>
        <trans-unit id="d10d84799d8bbf78fb0535ad9184c4c6ada6aa07" translate="yes" xml:space="preserve">
          <source>This class is intended to implement different file traversal methods. It allows to iterate through all files inside a given directory.</source>
          <target state="translated">该类旨在实现不同的文件遍历方法。它允许遍历给定目录内的所有文件。</target>
        </trans-unit>
        <trans-unit id="322e62ea251e48658a034c9b427e81ba230bb5e9" translate="yes" xml:space="preserve">
          <source>This class provides a way to create a stable handle to any Kotlin object. After &lt;a href=&quot;-stable-ref/as-c-pointer&quot;&gt;converting to CPointer&lt;/a&gt; it can be safely passed to native code e.g. to be received in a Kotlin callback.</source>
          <target state="translated">此类提供了一种创建任何Kotlin对象的稳定句柄的方法。后&lt;a href=&quot;-stable-ref/as-c-pointer&quot;&gt;转换成CPointer&lt;/a&gt;它可以安全地传递给本机代码，例如在科特林回调接收。</target>
        </trans-unit>
        <trans-unit id="a36e06591e999a4c0d4c4171fd2c0675fb1b16fc" translate="yes" xml:space="preserve">
          <source>This class provides a way to create a stable handle to any Kotlin object. After &lt;a href=&quot;../../kotlinx.cinterop/-stable-ref/as-c-pointer&quot;&gt;converting to CPointer&lt;/a&gt; it can be safely passed to native code e.g. to be received in a Kotlin callback.</source>
          <target state="translated">此类提供了一种创建任何Kotlin对象的稳定句柄的方法。后&lt;a href=&quot;../../kotlinx.cinterop/-stable-ref/as-c-pointer&quot;&gt;转换成CPointer&lt;/a&gt;它可以安全地传递给本机代码，例如在科特林回调接收。</target>
        </trans-unit>
        <trans-unit id="f9ba51153ea7889b4c1f1704d375fc98842fa90a" translate="yes" xml:space="preserve">
          <source>This class provides a way to create a stable handle to any Kotlin object. After &lt;a href=&quot;as-c-pointer&quot;&gt;converting to CPointer&lt;/a&gt; it can be safely passed to native code e.g. to be received in a Kotlin callback.</source>
          <target state="translated">此类提供了一种创建任何Kotlin对象的稳定句柄的方法。后&lt;a href=&quot;as-c-pointer&quot;&gt;转换成CPointer&lt;/a&gt;它可以安全地传递给本机代码，例如在科特林回调接收。</target>
        </trans-unit>
        <trans-unit id="3de458f3166219b6408ccb11d5d011e7dedd5974" translate="yes" xml:space="preserve">
          <source>This code calculates the fixpoint of cosine, which is a mathematical constant. It simply calls Math.cos repeatedly starting at 1.0 until the result doesn't change any more, yielding a result of 0.7390851332151611 for the specified &lt;code&gt;eps&lt;/code&gt; precision. The resulting code is equivalent to this more traditional style:</source>
          <target state="translated">此代码计算余弦的定点，这是一个数学常数。它只是从1.0开始重复调用Math.cos，直到结果不再改变为止，对于指定的 &lt;code&gt;eps&lt;/code&gt; 精度，结果为0.7390851332151611 。生成的代码等效于这种更传统的样式：</target>
        </trans-unit>
        <trans-unit id="1c9fb24eb61454c344b8e7f5093f2e83751a14fd" translate="yes" xml:space="preserve">
          <source>This code specifies an action to be performed on the &quot;hello&quot; button click. Note that with lambdas this code looks rather concise written directly in Kotlin:</source>
          <target state="translated">这段代码指定了点击 &quot;hello &quot;按钮时要执行的操作。请注意,如果使用lambdas,这段代码看起来相当简洁,直接用Kotlin写的。</target>
        </trans-unit>
        <trans-unit id="f097f6de0cc3b7d0fc741d38a1eac67ae2fca6f2" translate="yes" xml:space="preserve">
          <source>This code will launch a long-running operation without blocking the main thread. The &lt;code&gt;preparePost&lt;/code&gt; is what's called a &lt;code&gt;suspendable function&lt;/code&gt;, thus the keyword &lt;code&gt;suspend&lt;/code&gt; prefixing it. What this means as stated above, is that the function will execute, pause execution and resume at some point in time.</source>
          <target state="translated">此代码将启动长时间运行的操作，而不会阻塞主线程。该 &lt;code&gt;preparePost&lt;/code&gt; 是什么叫做 &lt;code&gt;suspendable function&lt;/code&gt; ，因此关键字 &lt;code&gt;suspend&lt;/code&gt; 前缀它。如上所述，这意味着该函数将在某个时间点执行，暂停执行并恢复。</target>
        </trans-unit>
        <trans-unit id="940a39107db356b9719bbf9342038d41ba48b8c2" translate="yes" xml:space="preserve">
          <source>This code works slower, but we still don't get &quot;Counter = 100000&quot; at the end, because volatile variables guarantee linearizable (this is a technical term for &quot;atomic&quot;) reads and writes to the corresponding variable, but do not provide atomicity of larger actions (increment in our case).</source>
          <target state="translated">这段代码的工作速度较慢,但我们在最后仍然没有得到 &quot;Counter=100000&quot;,因为volatile变量保证了对相应变量的可线性化(这是 &quot;原子 &quot;的技术术语)读写,但不提供较大动作(在我们的例子中是增量)的原子性。</target>
        </trans-unit>
        <trans-unit id="19e35196b450d82e8abc869e0b8d2aedd7f24d49" translate="yes" xml:space="preserve">
          <source>This code works very slowly, because it does &lt;em&gt;fine-grained&lt;/em&gt; thread-confinement. Each individual increment switches from multi-threaded &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-dispatchers/-default.html&quot;&gt;Dispatchers.Default&lt;/a&gt; context to the single-threaded context using &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/with-context.html&quot;&gt;withContext(counterContext)&lt;/a&gt; block.</source>
          <target state="translated">这段代码的工作速度非常慢，因为它&lt;em&gt;可以进行细粒度的&lt;/em&gt;线程约束。每个单独的增量都使用&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/with-context.html&quot;&gt;withContext（counterContext）&lt;/a&gt;块从多线程&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-dispatchers/-default.html&quot;&gt;Dispatchers.Default&lt;/a&gt;上下文切换到单线程上下文。</target>
        </trans-unit>
        <trans-unit id="d15be2d04edeeec0e153a44e5ef98d0f0d439b37" translate="yes" xml:space="preserve">
          <source>This collection has size of &lt;code&gt;groupCount + 1&lt;/code&gt; where &lt;code&gt;groupCount&lt;/code&gt; is the count of groups in the regular expression. Groups are indexed from 1 to &lt;code&gt;groupCount&lt;/code&gt; and group with the index 0 corresponds to the entire match.</source>
          <target state="translated">该集合的大小为 &lt;code&gt;groupCount + 1&lt;/code&gt; ，其中 &lt;code&gt;groupCount&lt;/code&gt; 是正则表达式中的组数。组从1到 &lt;code&gt;groupCount&lt;/code&gt; 进行索引，索引为0的组与整个匹配相对应。</target>
        </trans-unit>
        <trans-unit id="c28fcaf55859958d617c24c43acf5fe9a19ed1ae" translate="yes" xml:space="preserve">
          <source>This command will produce a &lt;code&gt;png.klib&lt;/code&gt; compiled library and &lt;code&gt;png-build/kotlin&lt;/code&gt; directory containing Kotlin source code for the library.</source>
          <target state="translated">该命令将生成一个 &lt;code&gt;png.klib&lt;/code&gt; 编译的库以及包含该库的Kotlin源代码的 &lt;code&gt;png-build/kotlin&lt;/code&gt; 目录。</target>
        </trans-unit>
        <trans-unit id="31a6ce4f29e9c4d59e89de3b53b3a11728189b63" translate="yes" xml:space="preserve">
          <source>This contract specifies that:</source>
          <target state="translated">本合同规定:</target>
        </trans-unit>
        <trans-unit id="d6dc362cdb3af439d7414c31776e978f9f9881cd" translate="yes" xml:space="preserve">
          <source>This convention, along with &lt;a href=&quot;#passing-a-lambda-to-the-last-parameter&quot;&gt;passing a lambda expression outside parentheses&lt;/a&gt;, allows for &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/bb308959.aspx&quot;&gt;LINQ-style&lt;/a&gt; code:</source>
          <target state="translated">该约定以及&lt;a href=&quot;#passing-a-lambda-to-the-last-parameter&quot;&gt;在括号外传递lambda表达式&lt;/a&gt;，允许使用&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/bb308959.aspx&quot;&gt;LINQ样式的&lt;/a&gt;代码：</target>
        </trans-unit>
        <trans-unit id="78e5afd48b07123042fcce6bdde782478e4769ee" translate="yes" xml:space="preserve">
          <source>This could be an issue for Java-interoperability, so Kotlin 1.3 introduces the &lt;code&gt;@JvmDefault&lt;/code&gt; annotation. Methods, annotated with this annotation will be generated as &lt;code&gt;default&lt;/code&gt; methods for JVM:</source>
          <target state="translated">这可能是Java互操作性的问题，因此Kotlin 1.3引入了 &lt;code&gt;@JvmDefault&lt;/code&gt; 注释。带有此注释的方法将作为JVM的 &lt;code&gt;default&lt;/code&gt; 方法生成：</target>
        </trans-unit>
        <trans-unit id="b179e178b1137230407a1019e7d8b4984a1d071b" translate="yes" xml:space="preserve">
          <source>This creates the &lt;code&gt;kotlin&lt;/code&gt; extension at the top level. You can then access it in the build script for:</source>
          <target state="translated">这将在顶层创建 &lt;code&gt;kotlin&lt;/code&gt; 扩展。然后，您可以在构建脚本中访问它：</target>
        </trans-unit>
        <trans-unit id="91b0596f729477e16cacda10e4665e91b4d05e3b" translate="yes" xml:space="preserve">
          <source>This document covers some details of Kotlin/Native interoperability with Swift/Objective-C.</source>
          <target state="translated">本文档涵盖了Kotlin/Native与Swift/Objective-C互操作的一些细节。</target>
        </trans-unit>
        <trans-unit id="50a7c9e10c5c72d9392130bc3068411c0b41a1c1" translate="yes" xml:space="preserve">
          <source>This document explains the structure of &lt;a href=&quot;multiplatform&quot;&gt;Kotlin multiplatform projects&lt;/a&gt; and describes how those are configured and built using Gradle.</source>
          <target state="translated">本文档说明了&lt;a href=&quot;multiplatform&quot;&gt;Kotlin跨平台项目&lt;/a&gt;的结构，并介绍了如何使用Gradle配置和构建这些项目。</target>
        </trans-unit>
        <trans-unit id="21394d0363d5df965c799770727e7adbc3c6c279" translate="yes" xml:space="preserve">
          <source>This effect is specified in the &lt;code&gt;contract { }&lt;/code&gt; block by attaching a boolean expression to another &lt;a href=&quot;-simple-effect/index&quot;&gt;SimpleEffect&lt;/a&gt; effect with the function &lt;a href=&quot;-simple-effect/implies&quot;&gt;SimpleEffect.implies&lt;/a&gt;.</source>
          <target state="translated">通过将布尔表达式附加到具有功能&lt;a href=&quot;-simple-effect/implies&quot;&gt;SimpleEffect.implies的&lt;/a&gt;另一个&lt;a href=&quot;-simple-effect/index&quot;&gt;SimpleEffect&lt;/a&gt;效果，可以在 &lt;code&gt;contract { }&lt;/code&gt; 块中指定此效果。</target>
        </trans-unit>
        <trans-unit id="6e955cd6c26356181a1bb5fce56a8a7425848e09" translate="yes" xml:space="preserve">
          <source>This example can be also rewritten in a more idiomatic way, using &lt;code&gt;runBlocking&lt;/code&gt; to wrap the execution of the main function:</source>
          <target state="translated">也可以使用 &lt;code&gt;runBlocking&lt;/code&gt; 封装主要函数的执行，以更惯用的方式重写此示例：</target>
        </trans-unit>
        <trans-unit id="fea137e1d1b8bae0357ac3e28f43d2dbd0615f21" translate="yes" xml:space="preserve">
          <source>This example completes in less than a second for me, but it prints some arbitrary number, because some coroutines don't finish before &lt;code&gt;main()&lt;/code&gt; prints the result. Let's fix that.</source>
          <target state="translated">对于我来说，该示例在不到一秒钟的时间内完成了，但是它打印了一些任意数字，因为某些协程在 &lt;code&gt;main()&lt;/code&gt; 打印结果之前没有完成。让我们修复它。</target>
        </trans-unit>
        <trans-unit id="3176985b1c6580c82570c99ec00af4e47e3fca5d" translate="yes" xml:space="preserve">
          <source>This example uses the utility function &lt;code&gt;startActivity&lt;/code&gt; creating an intent with no data and starting a new activity, which comes from the &lt;a href=&quot;https://github.com/Kotlin/anko&quot;&gt;Anko&lt;/a&gt; library. To pass some data, you can say &lt;code&gt;startActivity&amp;lt;OtherActivity&amp;gt;(&quot;KEY&quot; to &quot;VALUE&quot;)&lt;/code&gt;.</source>
          <target state="translated">本示例使用实用程序函数 &lt;code&gt;startActivity&lt;/code&gt; 创建一个无数据的意图，并启动一个来自&lt;a href=&quot;https://github.com/Kotlin/anko&quot;&gt;Anko&lt;/a&gt;库的新活动。要传递一些数据，您可以说 &lt;code&gt;startActivity&amp;lt;OtherActivity&amp;gt;(&quot;KEY&quot; to &quot;VALUE&quot;)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6017ffad0436bb8b6025573c2ab986b658552870" translate="yes" xml:space="preserve">
          <source>This example will print &quot;c&quot;, because the extension function being called depends only on the declared type of the parameter &lt;code&gt;c&lt;/code&gt;, which is the &lt;code&gt;C&lt;/code&gt; class.</source>
          <target state="translated">这个例子将打印&amp;ldquo;C&amp;rdquo;，因为被称为扩展函数仅依赖于声明的类型的参数的 &lt;code&gt;c&lt;/code&gt; ，这是 &lt;code&gt;C&lt;/code&gt; 类。</target>
        </trans-unit>
        <trans-unit id="133008c5d984069ce6a34613c275871c4f01bd7c" translate="yes" xml:space="preserve">
          <source>This extension allows to use instances of Lazy for property delegation: &lt;code&gt;val property: String by lazy { initializer }&lt;/code&gt;</source>
          <target state="translated">此扩展允许使用Lazy的实例进行属性委派： &lt;code&gt;val property: String by lazy { initializer }&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8d46e174deee6bd3f88e10604b91fb9b63428622" translate="yes" xml:space="preserve">
          <source>This extension is chosen only for invocation with old-named parameters. Replace parameter names with the same as those of &lt;a href=&quot;../kotlin/-char-sequence/sub-sequence#kotlin.CharSequence%24subSequence%28kotlin.Int%2C+kotlin.Int%29&quot;&gt;CharSequence.subSequence&lt;/a&gt;.</source>
          <target state="translated">选择此扩展名仅用于使用旧名称的参数进行调用。将参数名称替换为与&lt;a href=&quot;../kotlin/-char-sequence/sub-sequence#kotlin.CharSequence%24subSequence%28kotlin.Int%2C+kotlin.Int%29&quot;&gt;CharSequence.subSequence&lt;/a&gt;相同的名称。</target>
        </trans-unit>
        <trans-unit id="04d1f02c756f7e0904c6b3ffc69c7b6618cd5516" translate="yes" xml:space="preserve">
          <source>This extension on &lt;code&gt;Map&lt;/code&gt; returns an existing value corresponding to the given key or throws an exception, mentioning which key was not found. If the map was produced with &lt;code&gt;withDefault&lt;/code&gt;, this function will return the default value instead of throwing an exception.</source>
          <target state="translated">&lt;code&gt;Map&lt;/code&gt; 上的此扩展名返回与给定键相对应的现有值，或引发异常，并提及未找到哪个键。如果映射是使用 &lt;code&gt;withDefault&lt;/code&gt; 生成的，则此函数将返回默认值，而不是引发异常。</target>
        </trans-unit>
        <trans-unit id="179023ec810ea92c988e87fc2b985af8aad37762" translate="yes" xml:space="preserve">
          <source>This feature is available since Kotlin 1.3.40.</source>
          <target state="translated">这个功能从Kotlin 1.3.40开始就有了。</target>
        </trans-unit>
        <trans-unit id="291f1aee064b4993bae1bca7498ed1b391616e9f" translate="yes" xml:space="preserve">
          <source>This function can be implemented to produce more precise result for &lt;a href=&quot;expm1#kotlin.math%24expm1%28kotlin.Double%29%2Fx&quot;&gt;x&lt;/a&gt; near zero.</source>
          <target state="translated">可以实现该功能以针对&lt;a href=&quot;expm1#kotlin.math%24expm1%28kotlin.Double%29%2Fx&quot;&gt;x&lt;/a&gt;接近零产生更精确的结果。</target>
        </trans-unit>
        <trans-unit id="3b2cb2dc1fab6dcfdc4a04073763dbc01b226107" translate="yes" xml:space="preserve">
          <source>This function can be implemented to produce more precise result for &lt;a href=&quot;ln1p#kotlin.math%24ln1p%28kotlin.Double%29%2Fx&quot;&gt;x&lt;/a&gt; near zero.</source>
          <target state="translated">可以实现该功能以针对&lt;a href=&quot;ln1p#kotlin.math%24ln1p%28kotlin.Double%29%2Fx&quot;&gt;x&lt;/a&gt;接近零产生更精确的结果。</target>
        </trans-unit>
        <trans-unit id="8ea77ed3f5037a0baac9478b8da01da4e51178e3" translate="yes" xml:space="preserve">
          <source>This function can be implemented to produce more precise result for &lt;a href=&quot;ln1p#kotlin.math%24ln1p%28kotlin.Float%29%2Fx&quot;&gt;x&lt;/a&gt; near zero.</source>
          <target state="translated">可以实现该功能以针对&lt;a href=&quot;ln1p#kotlin.math%24ln1p%28kotlin.Float%29%2Fx&quot;&gt;x&lt;/a&gt;接近零产生更精确的结果。</target>
        </trans-unit>
        <trans-unit id="15d8b3c4e3fae3fdf6c4d98c18ebe217e09dc09b" translate="yes" xml:space="preserve">
          <source>This function ensures that if we see such an object during freezing attempt - freeze fails and &lt;a href=&quot;-freezing-exception/index&quot;&gt;FreezingException&lt;/a&gt; is thrown.</source>
          <target state="translated">此函数可确保如果我们在尝试冻结期间看到此类对象，则会冻结失败并引发&lt;a href=&quot;-freezing-exception/index&quot;&gt;FreezingException&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b1cc74a9da98228f1c9d06844410d709b18bb49c" translate="yes" xml:space="preserve">
          <source>This function ensures that if we see such an object during freezing attempt - freeze fails and &lt;a href=&quot;../../kotlin.native.concurrent/-freezing-exception/index&quot;&gt;FreezingException&lt;/a&gt; is thrown.</source>
          <target state="translated">此函数可确保如果我们在尝试冻结期间看到此类对象，则会冻结失败并引发&lt;a href=&quot;../../kotlin.native.concurrent/-freezing-exception/index&quot;&gt;FreezingException&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8266b16f93bf335043fb8a8f2352b33ede13a56f" translate="yes" xml:space="preserve">
          <source>This function is &lt;em&gt;unchecked&lt;/em&gt;. Repeated invocation of any resume function on the resulting continuation corrupts the state machine of the coroutine and may result in arbitrary behaviour or exception.</source>
          <target state="translated">此功能&lt;em&gt;未选中&lt;/em&gt;。在结果延续上重复调用任何恢复函数会破坏协程的状态机，并可能导致任意行为或异常。</target>
        </trans-unit>
        <trans-unit id="655c266532fc9da4c9f83fafc0352f21cfdf4913" translate="yes" xml:space="preserve">
          <source>This function is designed to be used from inside of &lt;a href=&quot;suspend-coroutine-unintercepted-or-return&quot;&gt;suspendCoroutineUninterceptedOrReturn&lt;/a&gt; to resume the execution of the suspended coroutine using a reference to the suspending function.</source>
          <target state="translated">该函数被设计为从&lt;a href=&quot;suspend-coroutine-unintercepted-or-return&quot;&gt;suspendCoroutineUninterceptedOrReturn&lt;/a&gt;内部使用，以通过使用对suspend函数的引用来恢复暂停的协程的执行。</target>
        </trans-unit>
        <trans-unit id="a73c80e70840d67f98f7e02bc949060c1aff0a7a" translate="yes" xml:space="preserve">
          <source>This function is shorthand for &lt;code&gt;fold(onSuccess = { null }, onFailure = { it })&lt;/code&gt; (see &lt;a href=&quot;../../kotlin.collections/fold&quot;&gt;fold&lt;/a&gt;).</source>
          <target state="translated">该函数是 &lt;code&gt;fold(onSuccess = { null }, onFailure = { it })&lt;/code&gt; 简写（请参阅&lt;a href=&quot;../../kotlin.collections/fold&quot;&gt;fold&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="6bebf395da4954e0241f8b8cedacdd2c2c071a5d" translate="yes" xml:space="preserve">
          <source>This function is shorthand for &lt;code&gt;getOrElse { defaultValue }&lt;/code&gt; (see &lt;a href=&quot;../kotlin.collections/get-or-else&quot;&gt;getOrElse&lt;/a&gt;).</source>
          <target state="translated">此函数是 &lt;code&gt;getOrElse { defaultValue }&lt;/code&gt; 简写（请参见&lt;a href=&quot;../kotlin.collections/get-or-else&quot;&gt;getOrElse&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="036653325111157e1e020b5f2e95ce39aee0befd" translate="yes" xml:space="preserve">
          <source>This function is shorthand for &lt;code&gt;getOrElse { null }&lt;/code&gt; (see &lt;a href=&quot;../../kotlin.collections/get-or-else&quot;&gt;getOrElse&lt;/a&gt;) or &lt;code&gt;fold(onSuccess = { it }, onFailure = { null })&lt;/code&gt; (see &lt;a href=&quot;../../kotlin.collections/fold&quot;&gt;fold&lt;/a&gt;).</source>
          <target state="translated">此函数是 &lt;code&gt;getOrElse { null }&lt;/code&gt; （请参见&lt;a href=&quot;../../kotlin.collections/get-or-else&quot;&gt;getOrElse&lt;/a&gt;）或 &lt;code&gt;fold(onSuccess = { it }, onFailure = { null })&lt;/code&gt; （请参见&lt;a href=&quot;../../kotlin.collections/fold&quot;&gt;fold&lt;/a&gt;）的简写形式。</target>
        </trans-unit>
        <trans-unit id="0cd6600313d79bdb9ccb1177f047f415c30785ec" translate="yes" xml:space="preserve">
          <source>This function is shorthand for &lt;code&gt;getOrElse { throw it }&lt;/code&gt; (see &lt;a href=&quot;../kotlin.collections/get-or-else&quot;&gt;getOrElse&lt;/a&gt;).</source>
          <target state="translated">此函数是 &lt;code&gt;getOrElse { throw it }&lt;/code&gt; 简写（请参阅&lt;a href=&quot;../kotlin.collections/get-or-else&quot;&gt;getOrElse&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="2764ff2fd2235b064886b62fb3ea52722744061e" translate="yes" xml:space="preserve">
          <source>This function is supposed to copy items from one array to another. Let's try to apply it in practice:</source>
          <target state="translated">这个函数应该是将一个数组中的项目复制到另一个数组中。让我们试着在实践中应用它。</target>
        </trans-unit>
        <trans-unit id="e946cda58e67ec0857646809f4c7cd966c6aa3b4" translate="yes" xml:space="preserve">
          <source>This function may simply return original &lt;a href=&quot;intercept-continuation#kotlin.coroutines.ContinuationInterceptor%24interceptContinuation%28kotlin.coroutines.Continuation%28%28kotlin.coroutines.ContinuationInterceptor.interceptContinuation.T%29%29%29%2Fcontinuation&quot;&gt;continuation&lt;/a&gt; if it does not want to intercept this particular continuation.</source>
          <target state="translated">该功能可以简单地返回原来的&lt;a href=&quot;intercept-continuation#kotlin.coroutines.ContinuationInterceptor%24interceptContinuation%28kotlin.coroutines.Continuation%28%28kotlin.coroutines.ContinuationInterceptor.interceptContinuation.T%29%29%29%2Fcontinuation&quot;&gt;延续&lt;/a&gt;，如果它不希望拦截这个特殊的延续。</target>
        </trans-unit>
        <trans-unit id="e37e9fc156176e563d05b6de34d613400e3a03e7" translate="yes" xml:space="preserve">
          <source>This function returns unintercepted continuation. Invocation of &lt;code&gt;resume(Unit)&lt;/code&gt; starts coroutine immediately in the invoker's call stack without going through the ContinuationInterceptor that might be present in the completion's CoroutineContext. It is the invoker's responsibility to ensure that a proper invocation context is established. Note that &lt;a href=&quot;create-coroutine-unintercepted#kotlin.coroutines.intrinsics%24createCoroutineUnintercepted%28kotlin.coroutines.SuspendFunction0%28%28kotlin.coroutines.intrinsics.createCoroutineUnintercepted.T%29%29%2C+kotlin.coroutines.Continuation%28%28kotlin.coroutines.intrinsics.createCoroutineUnintercepted.T%29%29%29%2Fcompletion&quot;&gt;completion&lt;/a&gt; of this function may get invoked in an arbitrary context.</source>
          <target state="translated">此函数返回无中断的延续。调用 &lt;code&gt;resume(Unit)&lt;/code&gt; 会立即在调用者的调用堆栈中启动协程，而无需经过可能存在于完成的CoroutineContext中的ContinuationInterceptor。调用者有责任确保建立正确的调用上下文。注意，可以在任意上下文中调用此功能的&lt;a href=&quot;create-coroutine-unintercepted#kotlin.coroutines.intrinsics%24createCoroutineUnintercepted%28kotlin.coroutines.SuspendFunction0%28%28kotlin.coroutines.intrinsics.createCoroutineUnintercepted.T%29%29%2C+kotlin.coroutines.Continuation%28%28kotlin.coroutines.intrinsics.createCoroutineUnintercepted.T%29%29%29%2Fcompletion&quot;&gt;完成&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="83c7cfd05c8eea06ab4db27704a1d5249d155e3e" translate="yes" xml:space="preserve">
          <source>This function returns unintercepted continuation. Invocation of &lt;code&gt;resume(Unit)&lt;/code&gt; starts coroutine immediately in the invoker's call stack without going through the ContinuationInterceptor that might be present in the completion's CoroutineContext. It is the invoker's responsibility to ensure that a proper invocation context is established. Note that &lt;a href=&quot;create-coroutine-unintercepted#kotlin.coroutines.intrinsics%24createCoroutineUnintercepted%28kotlin.coroutines.SuspendFunction1%28%28kotlin.coroutines.intrinsics.createCoroutineUnintercepted.R%2C+kotlin.coroutines.intrinsics.createCoroutineUnintercepted.T%29%29%2C+kotlin.coroutines.intrinsics.createCoroutineUnintercepted.R%2C+kotlin.coroutines.Continuation%28%28kotlin.coroutines.intrinsics.createCoroutineUnintercepted.T%29%29%29%2Fcompletion&quot;&gt;completion&lt;/a&gt; of this function may get invoked in an arbitrary context.</source>
          <target state="translated">此函数返回无中断的延续。调用 &lt;code&gt;resume(Unit)&lt;/code&gt; 会立即在调用者的调用堆栈中启动协程，而无需经过可能存在于完成的CoroutineContext中的ContinuationInterceptor。调用者有责任确保建立正确的调用上下文。注意，可以在任意上下文中调用此功能的&lt;a href=&quot;create-coroutine-unintercepted#kotlin.coroutines.intrinsics%24createCoroutineUnintercepted%28kotlin.coroutines.SuspendFunction1%28%28kotlin.coroutines.intrinsics.createCoroutineUnintercepted.R%2C+kotlin.coroutines.intrinsics.createCoroutineUnintercepted.T%29%29%2C+kotlin.coroutines.intrinsics.createCoroutineUnintercepted.R%2C+kotlin.coroutines.Continuation%28%28kotlin.coroutines.intrinsics.createCoroutineUnintercepted.T%29%29%29%2Fcompletion&quot;&gt;完成&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c273643758adbf26e0358f1c22929439c83656d2" translate="yes" xml:space="preserve">
          <source>This function shall be used on the immediate result of &lt;a href=&quot;create-coroutine-unintercepted#kotlin.coroutines.intrinsics%24createCoroutineUnintercepted%28kotlin.coroutines.SuspendFunction0%28%28kotlin.coroutines.intrinsics.createCoroutineUnintercepted.T%29%29%2C+kotlin.coroutines.Continuation%28%28kotlin.coroutines.intrinsics.createCoroutineUnintercepted.T%29%29%29&quot;&gt;createCoroutineUnintercepted&lt;/a&gt; or &lt;a href=&quot;suspend-coroutine-unintercepted-or-return&quot;&gt;suspendCoroutineUninterceptedOrReturn&lt;/a&gt;, in which case it checks for &lt;a href=&quot;../kotlin.coroutines/-continuation-interceptor/index&quot;&gt;ContinuationInterceptor&lt;/a&gt; in the continuation's &lt;a href=&quot;../kotlin.coroutines/-continuation/context&quot;&gt;context&lt;/a&gt;, invokes &lt;a href=&quot;../kotlin.coroutines/-continuation-interceptor/intercept-continuation&quot;&gt;ContinuationInterceptor.interceptContinuation&lt;/a&gt;, caches and returns the result.</source>
          <target state="translated">此函数应在&lt;a href=&quot;create-coroutine-unintercepted#kotlin.coroutines.intrinsics%24createCoroutineUnintercepted%28kotlin.coroutines.SuspendFunction0%28%28kotlin.coroutines.intrinsics.createCoroutineUnintercepted.T%29%29%2C+kotlin.coroutines.Continuation%28%28kotlin.coroutines.intrinsics.createCoroutineUnintercepted.T%29%29%29&quot;&gt;createCoroutineUnintercepted&lt;/a&gt;或&lt;a href=&quot;suspend-coroutine-unintercepted-or-return&quot;&gt;suspendCoroutineUninterceptedOrReturn&lt;/a&gt;的立即结果上使用，在这种情况下，它将在延续的&lt;a href=&quot;../kotlin.coroutines/-continuation/context&quot;&gt;上下文中&lt;/a&gt;检查&lt;a href=&quot;../kotlin.coroutines/-continuation-interceptor/index&quot;&gt;ContinuationInterceptor&lt;/a&gt;，调用&lt;a href=&quot;../kotlin.coroutines/-continuation-interceptor/intercept-continuation&quot;&gt;ContinuationInterceptor.interceptContinuation&lt;/a&gt;，缓存并返回结果。</target>
        </trans-unit>
        <trans-unit id="2b0e3ac4cd4df41a67feb4ab61ba294bec022bac" translate="yes" xml:space="preserve">
          <source>This function takes one parameter named &lt;code&gt;init&lt;/code&gt;, which is itself a function. The type of the function is &lt;code&gt;HTML.() -&amp;gt; Unit&lt;/code&gt;, which is a &lt;em&gt;function type with receiver&lt;/em&gt;. This means that we need to pass an instance of type &lt;code&gt;HTML&lt;/code&gt; (a &lt;em&gt;receiver&lt;/em&gt;) to the function, and we can call members of that instance inside the function. The receiver can be accessed through the &lt;em&gt;this&lt;/em&gt; keyword:</source>
          <target state="translated">此函数采用一个名为 &lt;code&gt;init&lt;/code&gt; 的参数，该参数本身就是一个函数。函数的类型是 &lt;code&gt;HTML.() -&amp;gt; Unit&lt;/code&gt; ，这是&lt;em&gt;带有接收器&lt;/em&gt;的&lt;em&gt;函数类型&lt;/em&gt;。这意味着我们需要将 &lt;code&gt;HTML&lt;/code&gt; 类型的实例（&lt;em&gt;接收器&lt;/em&gt;）传递给函数，并且可以在函数内部调用该实例的成员。可以通过&lt;em&gt;以下&lt;/em&gt;关键字访问接收方：</target>
        </trans-unit>
        <trans-unit id="675aeac2a918c6d6c8b4beafdddac2cf6431511b" translate="yes" xml:space="preserve">
          <source>This illustrates several important points:</source>
          <target state="translated">这说明了几个重要的问题。</target>
        </trans-unit>
        <trans-unit id="42ded97c96158badfa6b51ddc24bd9a63c6cca70" translate="yes" xml:space="preserve">
          <source>This implementation doesn't provide a way to manage capacity, as backing JS array is resizeable itself. There is no speed advantage to pre-allocating array sizes in JavaScript, so this implementation does not include any of the capacity and &quot;growth increment&quot; concepts.</source>
          <target state="translated">这个实现并没有提供管理容量的方法,因为支持JS数组本身是可以调整大小的。在JavaScript中预分配数组大小在速度上没有优势,所以这个实现不包含任何容量和 &quot;增长增量 &quot;的概念。</target>
        </trans-unit>
        <trans-unit id="691ede82b3af6046b7651a9c02f4605eaa3ba130" translate="yes" xml:space="preserve">
          <source>This implementation makes no guarantees regarding the order of enumeration of &lt;a href=&quot;../-abstract-mutable-map/keys#kotlin.collections.AbstractMutableMap%24keys&quot;&gt;keys&lt;/a&gt;, &lt;a href=&quot;../-abstract-mutable-map/values#kotlin.collections.AbstractMutableMap%24values&quot;&gt;values&lt;/a&gt; and &lt;a href=&quot;entries#kotlin.collections.HashMap%24entries&quot;&gt;entries&lt;/a&gt; collections.</source>
          <target state="translated">此实现不保证&lt;a href=&quot;../-abstract-mutable-map/keys#kotlin.collections.AbstractMutableMap%24keys&quot;&gt;键&lt;/a&gt;，&lt;a href=&quot;../-abstract-mutable-map/values#kotlin.collections.AbstractMutableMap%24values&quot;&gt;值&lt;/a&gt;和&lt;a href=&quot;entries#kotlin.collections.HashMap%24entries&quot;&gt;条目&lt;/a&gt;集合的枚举顺序。</target>
        </trans-unit>
        <trans-unit id="8ddc3e7d274cee12068e4ad892df6635b0d1615a" translate="yes" xml:space="preserve">
          <source>This implementation preserves the insertion order of elements during the iteration.</source>
          <target state="translated">本实施例在迭代过程中保留了元素的插入顺序。</target>
        </trans-unit>
        <trans-unit id="1edd274f6c90be7cfea12d2c044bc4232b280a23" translate="yes" xml:space="preserve">
          <source>This implicit default value is used when the original map doesn't contain a value for the key specified and a value is obtained with &lt;a href=&quot;get-value&quot;&gt;Map.getValue&lt;/a&gt; function, for example when properties are delegated to the map.</source>
          <target state="translated">当原始地图不包含指定键的值并且使用&lt;a href=&quot;get-value&quot;&gt;Map.getValue&lt;/a&gt;函数获取值时（例如，将属性委派给地图时），将使用此隐式默认值。</target>
        </trans-unit>
        <trans-unit id="410788a84e729541585bfe744595e36fe672b2b8" translate="yes" xml:space="preserve">
          <source>This implies a different way to approach problems and quite a significant shift from what we're using to when writing synchronous code. One benefit as opposed to Futures is that given its ported to so many platforms, generally we can find a consistent API experience no matter what we use it, be it C#, Java, JavaScript, or any other language where Rx is available.</source>
          <target state="translated">这意味着一种不同的处理问题的方式,与我们在编写同步代码时使用的方式有相当大的转变。相对于Futures的一个好处是,鉴于其被移植到了这么多的平台上,一般来说,无论我们使用什么,无论是C#、Java、JavaScript,还是其他任何可以使用Rx的语言,我们都可以找到一致的API体验。</target>
        </trans-unit>
        <trans-unit id="b300e1ecd05ef9cda9c0ccf69cc9b5755628a6bd" translate="yes" xml:space="preserve">
          <source>This imposes certain risks of binary incompatibility caused by changes in the module that declares an inline function in case the calling module is not re-compiled after the change.</source>
          <target state="translated">这就存在一定的二进制不兼容风险,因为声明内联函数的模块发生变化,万一调用模块在变化后没有重新编译,就会造成二进制不兼容。</target>
        </trans-unit>
        <trans-unit id="1c39f73f8778c781fa84c78bdda94d474dac7b9e" translate="yes" xml:space="preserve">
          <source>This in principle feels like a much more elegant solution, but once again has several issues:</source>
          <target state="translated">这在原则上感觉是一个更优雅的解决方案,但又有几个问题。</target>
        </trans-unit>
        <trans-unit id="2dca6747771b3b10d5fd08415bf950f46bdea92f" translate="yes" xml:space="preserve">
          <source>This interface is implemented by floating point ranges returned by &lt;a href=&quot;../range-to&quot;&gt;Float.rangeTo&lt;/a&gt; and &lt;a href=&quot;../range-to&quot;&gt;Double.rangeTo&lt;/a&gt; operators to achieve IEEE-754 comparison order instead of total order of floating point numbers.</source>
          <target state="translated">此接口由&lt;a href=&quot;../range-to&quot;&gt;Float.rangeTo&lt;/a&gt;和&lt;a href=&quot;../range-to&quot;&gt;Double.rangeTo&lt;/a&gt;运算符返回的浮点范围实现，以实现IEEE-754比较顺序，而不是浮点数的总顺序。</target>
        </trans-unit>
        <trans-unit id="b9b5668de562d41a3eb7fb59a1bae495ad743bbf" translate="yes" xml:space="preserve">
          <source>This interface is likely to be handled by compiler magic and shouldn't be subtyped by arbitrary classes.</source>
          <target state="translated">这个接口很可能被编译器的魔法处理,不应该被任意类子类型化。</target>
        </trans-unit>
        <trans-unit id="60e87d87b4ef52673d6b6accbe785d16a04f37c9" translate="yes" xml:space="preserve">
          <source>This is a guide on core features of &lt;code&gt;kotlinx.coroutines&lt;/code&gt; with a series of examples, divided up into different topics.</source>
          <target state="translated">这是有关 &lt;code&gt;kotlinx.coroutines&lt;/code&gt; 核心功能的指南，提供了一系列示例，分为不同主题。</target>
        </trans-unit>
        <trans-unit id="c933ba19b81dc6ad55a2c69193b755c303d2100a" translate="yes" xml:space="preserve">
          <source>This is a little better, but we have no or little help from the powerful code completion of the IDE. It would be so much better if we could say:</source>
          <target state="translated">这样做是好了一点,但是我们没有或者说没有得到IDE强大的代码完成的帮助。如果我们能说,那就好多了。</target>
        </trans-unit>
        <trans-unit id="da401b98d9be6d7ebaac9172cbd4241fbf6ba27c" translate="yes" xml:space="preserve">
          <source>This is also a way to write unit tests for suspending functions:</source>
          <target state="translated">这也是为暂停函数编写单元测试的一种方式。</target>
        </trans-unit>
        <trans-unit id="64ed768079e9d5cbdb933e9c19824b5132acfb30" translate="yes" xml:space="preserve">
          <source>This is an experimental API. Given a class for a compiled Kotlin lambda or a function expression, returns a &lt;a href=&quot;../-k-function/index#kotlin.reflect.KFunction&quot;&gt;KFunction&lt;/a&gt; instance providing introspection capabilities for that lambda or function expression and its parameters. Not all features are currently supported, in particular KCallable.call and KCallable.callBy will fail at the moment.</source>
          <target state="translated">这是一个实验性的API。给定已编译Kotlin lambda或函数表达式的类，则返回&lt;a href=&quot;../-k-function/index#kotlin.reflect.KFunction&quot;&gt;KFunction&lt;/a&gt;实例，该实例为该lambda或函数表达式及其参数提供自省功能。当前尚不支持所有功能，尤其是KCallable.call和KCallable.callBy目前将失败。</target>
        </trans-unit>
        <trans-unit id="109dcae61144497c38fcb7128f4fde954a0b0dab" translate="yes" xml:space="preserve">
          <source>This is an experimental API. Given a class for a compiled Kotlin lambda or a function expression, returns a &lt;a href=&quot;../kotlin.reflect/-k-function/index#kotlin.reflect.KFunction&quot;&gt;KFunction&lt;/a&gt; instance providing introspection capabilities for that lambda or function expression and its parameters. Not all features are currently supported, in particular KCallable.call and KCallable.callBy will fail at the moment.</source>
          <target state="translated">这是一个实验性的API。给定已编译Kotlin lambda或函数表达式的类，则返回&lt;a href=&quot;../kotlin.reflect/-k-function/index#kotlin.reflect.KFunction&quot;&gt;KFunction&lt;/a&gt;实例，该实例为该lambda或函数表达式及其参数提供自省功能。当前尚不支持所有功能，尤其是KCallable.call和KCallable.callBy目前将失败。</target>
        </trans-unit>
        <trans-unit id="1275ac7243b73ff90c0cce870f1cace4805d6b9b" translate="yes" xml:space="preserve">
          <source>This is an experimental API. Given a class for a compiled Kotlin lambda or a function expression, returns a &lt;a href=&quot;index#kotlin.reflect.KFunction&quot;&gt;KFunction&lt;/a&gt; instance providing introspection capabilities for that lambda or function expression and its parameters. Not all features are currently supported, in particular KCallable.call and KCallable.callBy will fail at the moment.</source>
          <target state="translated">这是一个实验性的API。给定已编译Kotlin lambda或函数表达式的类，则返回&lt;a href=&quot;index#kotlin.reflect.KFunction&quot;&gt;KFunction&lt;/a&gt;实例，该实例为该lambda或函数表达式及其参数提供自省功能。当前尚不支持所有功能，尤其是KCallable.call和KCallable.callBy目前将失败。</target>
        </trans-unit>
        <trans-unit id="bbf054c69a799b1f208427023936248eccf48ba6" translate="yes" xml:space="preserve">
          <source>This is because we are not inside any coroutine. We can use delay if we wrap it into &lt;code&gt;runBlocking {}&lt;/code&gt; that starts a coroutine and waits until it's done:</source>
          <target state="translated">这是因为我们不在任何协程内部。如果将延迟包装到 &lt;code&gt;runBlocking {}&lt;/code&gt; 协程并等待完成的runBlocking {}中，则可以使用延迟：</target>
        </trans-unit>
        <trans-unit id="89a3c5e95e199bf51561c58886a8d92c513c9cea" translate="yes" xml:space="preserve">
          <source>This is called an &lt;em&gt;object declaration&lt;/em&gt;, and it always has a name following the &lt;em&gt;object&lt;/em&gt; keyword. Just like a variable declaration, an object declaration is not an expression, and cannot be used on the right hand side of an assignment statement.</source>
          <target state="translated">这称为&lt;em&gt;对象声明&lt;/em&gt;，它始终在&lt;em&gt;object&lt;/em&gt;关键字之后有一个名称。就像变量声明一样，对象声明也不是表达式，并且不能在赋值语句的右侧使用。</target>
        </trans-unit>
        <trans-unit id="0f25f0b9ab280fe3c292330ad8e1771dad21395c" translate="yes" xml:space="preserve">
          <source>This is completely legitimate Kotlin code. You can play with this code online (modify it and run in the browser) &lt;a href=&quot;https://play.kotlinlang.org/byExample/09_Kotlin_JS/06_HtmlBuilder&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">这是完全合法的Kotlin代码。您可以在&lt;a href=&quot;https://play.kotlinlang.org/byExample/09_Kotlin_JS/06_HtmlBuilder&quot;&gt;此处&lt;/a&gt;在线使用此代码（对其进行修改并在浏览器中运行）。</target>
        </trans-unit>
        <trans-unit id="0e75165bd6c0c435e57a13f622ac0560e9f8aea5" translate="yes" xml:space="preserve">
          <source>This is equivalent to</source>
          <target state="translated">这相当于</target>
        </trans-unit>
        <trans-unit id="f1b5d12f5c0ad6b8f02b5702175b995f5f4555de" translate="yes" xml:space="preserve">
          <source>This is how the package &lt;code&gt;com.example.html&lt;/code&gt; is defined (only the elements used in the example above). It builds an HTML tree. It makes heavy use of &lt;a href=&quot;extensions&quot;&gt;extension functions&lt;/a&gt; and &lt;a href=&quot;lambdas#function-literals-with-receiver&quot;&gt;lambdas with receiver&lt;/a&gt;.</source>
          <target state="translated">这就是 &lt;code&gt;com.example.html&lt;/code&gt; 包的定义方式（仅上述示例中使用的元素）。它构建一个HTML树。它大量使用&lt;a href=&quot;extensions&quot;&gt;扩展功能&lt;/a&gt;和&lt;a href=&quot;lambdas#function-literals-with-receiver&quot;&gt;带有接收器的lambda&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="eb4b287b1edf1ba23dd84510aa2e475b62f2bf92" translate="yes" xml:space="preserve">
          <source>This is how the same function looks without the standard library functions:</source>
          <target state="translated">这就是同样的函数在没有标准库函数的情况下的样子。</target>
        </trans-unit>
        <trans-unit id="be45b011252e2fb8cf7402a94a29a95e7994751a" translate="yes" xml:space="preserve">
          <source>This is not applicable when you compile your Kotlin module to JavaScript module (see &lt;a href=&quot;js-modules&quot;&gt;JavaScript Modules&lt;/a&gt; for more information on this). In this case there won't be a wrapper object, instead, declarations will be exposed as a JavaScript module of a corresponding kind. For example, in case of CommonJS you should write:</source>
          <target state="translated">当您将Kotlin模块编译为JavaScript模块时，此方法不适用（有关此信息，请参阅&lt;a href=&quot;js-modules&quot;&gt;JavaScript模块&lt;/a&gt;）。在这种情况下，将没有包装对象，相反，声明将作为相应类型的JavaScript模块公开。例如，对于CommonJS，您应该编写：</target>
        </trans-unit>
        <trans-unit id="16ae8412e011bd154f0f6ed0d14afcc433a50b3b" translate="yes" xml:space="preserve">
          <source>This is not required when using Kotlin Gradle plugin 1.1.1 and above with the &lt;a href=&quot;https://docs.gradle.org/current/userguide/plugins.html#sec:plugins_block&quot;&gt;Gradle plugins DSL&lt;/a&gt;, and with &lt;a href=&quot;https://github.com/gradle/kotlin-dsl&quot;&gt;Gradle Kotlin DSL&lt;/a&gt;.</source>
          <target state="translated">当将Kotlin Gradle插件1.1.1及更高版本与&lt;a href=&quot;https://docs.gradle.org/current/userguide/plugins.html#sec:plugins_block&quot;&gt;Gradle插件DSL&lt;/a&gt;以及&lt;a href=&quot;https://github.com/gradle/kotlin-dsl&quot;&gt;Gradle Kotlin DSL&lt;/a&gt;结合使用时，不需要这样做。</target>
        </trans-unit>
        <trans-unit id="04267f944435e1968a98920e69ed6ee93ce59d4b" translate="yes" xml:space="preserve">
          <source>This is one expression in all three languages:</source>
          <target state="translated">这是三种语言中的一种表述。</target>
        </trans-unit>
        <trans-unit id="6b9969b7447679a0aefde827887c1e2aff85957c" translate="yes" xml:space="preserve">
          <source>This is one expression in both Kotlin (because the first line doesn't parse on its own) and JavaScript, and doesn't parse in Python:</source>
          <target state="translated">这在Kotlin(因为第一行自己不解析)和JavaScript中都是一个表达式,在Python中不解析。</target>
        </trans-unit>
        <trans-unit id="0e08018d2743eaf233d0fdb2fc751af52fc3dee8" translate="yes" xml:space="preserve">
          <source>This is only the beginning and a small example of Kotlin code sharing between iOS and Android (and other platforms) with Kotlin, Kotlin/Native and Kotlin multiplatform projects. The same approach works for real applications, independent of their size or complexity.</source>
          <target state="translated">这只是iOS和Android(以及其他平台)之间Kotlin代码共享的一个开始和小例子,有Kotlin、Kotlin/Native和Kotlin多平台项目。同样的方法也适用于真实的应用程序,无论其大小或复杂程度如何。</target>
        </trans-unit>
        <trans-unit id="556b42ba8780522a3f90da067d375baba3a8ad1d" translate="yes" xml:space="preserve">
          <source>This is particularly important for Android developers, since the compiler can now correctly analyze generic &lt;code&gt;findViewById&lt;/code&gt; calls in Android API level 26:</source>
          <target state="translated">这对于Android开发人员尤其重要，因为编译器现在可以正确分析Android API级别26中的常规 &lt;code&gt;findViewById&lt;/code&gt; 调用：</target>
        </trans-unit>
        <trans-unit id="995a44882385c48d93df496a6a80eaaa6c26f44a" translate="yes" xml:space="preserve">
          <source>This is provided only for convenience; you don't have to extend this interface as long as your property delegate has methods with the same signatures.</source>
          <target state="translated">这只是为了方便而提供的,只要你的属性委托人有相同签名的方法,你就不必扩展这个接口。</target>
        </trans-unit>
        <trans-unit id="64b2fb3aa48fe9872cab0264ea29aacf2838772b" translate="yes" xml:space="preserve">
          <source>This is the JS code generated for the Kotlin code above (the &lt;code&gt;main&lt;/code&gt; function). Let's have a closer look at it.</source>
          <target state="translated">这是为上面的Kotlin代码（ &lt;code&gt;main&lt;/code&gt; 功能）生成的JS代码。让我们仔细看看。</target>
        </trans-unit>
        <trans-unit id="61af108c05fdc7b4a1413c5ee9cd9367a036a611" translate="yes" xml:space="preserve">
          <source>This is the fastest solution for this particular problem. It works for plain counters, collections, queues and other standard data structures and basic operations on them. However, it does not easily scale to complex state or to complex operations that do not have ready-to-use thread-safe implementations.</source>
          <target state="translated">这是解决这个特殊问题的最快方案。它适用于普通计数器、集合、队列和其他标准数据结构以及对它们的基本操作。然而,它不容易扩展到复杂的状态或没有现成的线程安全实现的复杂操作。</target>
        </trans-unit>
        <trans-unit id="fa369ec473906917e945918ae4ca55d8b5858ee4" translate="yes" xml:space="preserve">
          <source>This is the last tutorial in the series. The first tutorial of the series is &lt;a href=&quot;mapping-primitive-data-types-from-c&quot;&gt;Mapping Primitive Data Types from C&lt;/a&gt;. There are also &lt;a href=&quot;mapping-struct-union-types-from-c&quot;&gt;Mapping Struct and Union Types from C&lt;/a&gt; and &lt;a href=&quot;mapping-function-pointers-from-c&quot;&gt;Mapping Function Pointers from C&lt;/a&gt; tutorials.</source>
          <target state="translated">这是本系列的最后一篇教程。该系列的第一个教程是&lt;a href=&quot;mapping-primitive-data-types-from-c&quot;&gt;从C映射原始数据类型&lt;/a&gt;。也有&lt;a href=&quot;mapping-function-pointers-from-c&quot;&gt;C&lt;/a&gt;教程中的&lt;a href=&quot;mapping-struct-union-types-from-c&quot;&gt;Mapping Struct和Union Type&lt;/a&gt;和C教程中的Mapping Function Pointer。</target>
        </trans-unit>
        <trans-unit id="db342e5eb9179bc09fc429165b10a1574cb68d62" translate="yes" xml:space="preserve">
          <source>This is the main feature of inline classes, which inspired the name &quot;inline&quot;: data of the class is &quot;inlined&quot; into its usages (similar to how content of &lt;a href=&quot;inline-functions&quot;&gt;inline functions&lt;/a&gt; is inlined to call sites).</source>
          <target state="translated">这是内联类的主要特征，它启发了&amp;ldquo;内联&amp;rdquo;的名称：该类的数据被&amp;ldquo;内联&amp;rdquo;到其用法中（类似于&lt;a href=&quot;inline-functions&quot;&gt;内联函数的&lt;/a&gt;内容内联到调用站点的方式）。</target>
        </trans-unit>
        <trans-unit id="e191f2b52800fbe76b7db487772b3a907bdf44b0" translate="yes" xml:space="preserve">
          <source>This is the second post in the series. The very first tutorial of the series is &lt;a href=&quot;mapping-primitive-data-types-from-c&quot;&gt;Mapping Primitive Data Types from C&lt;/a&gt;. There are also the &lt;a href=&quot;mapping-function-pointers-from-c&quot;&gt;Mapping Function Pointers from C&lt;/a&gt; and &lt;a href=&quot;mapping-strings-from-c&quot;&gt;Mapping Strings from C&lt;/a&gt; tutorials.</source>
          <target state="translated">这是该系列的第二篇文章。该系列的第一个教程是&lt;a href=&quot;mapping-primitive-data-types-from-c&quot;&gt;从C映射原始数据类型&lt;/a&gt;。还有&lt;a href=&quot;mapping-function-pointers-from-c&quot;&gt;C语言&lt;/a&gt;的Mapping Function Pointer和&lt;a href=&quot;mapping-strings-from-c&quot;&gt;C语言&lt;/a&gt;教程的Mapping Strings。</target>
        </trans-unit>
        <trans-unit id="9d714ceb3667c2a2d840d8a543c7e66ce3d058a3" translate="yes" xml:space="preserve">
          <source>This is the third post in the series. The very first tutorial is &lt;a href=&quot;mapping-primitive-data-types-from-c&quot;&gt;Mapping Primitive Data Types from C&lt;/a&gt;. There are also &lt;a href=&quot;mapping-struct-union-types-from-c&quot;&gt;Mapping Struct and Union Types from C&lt;/a&gt; and &lt;a href=&quot;mapping-strings-from-c&quot;&gt;Mapping Strings from C&lt;/a&gt; tutorials.</source>
          <target state="translated">这是该系列的第三篇文章。第一个教程是&lt;a href=&quot;mapping-primitive-data-types-from-c&quot;&gt;从C映射原始数据类型&lt;/a&gt;。也有&lt;a href=&quot;mapping-strings-from-c&quot;&gt;C&lt;/a&gt;教程中的&lt;a href=&quot;mapping-struct-union-types-from-c&quot;&gt;Mapping Struct和Union Type&lt;/a&gt;和C教程中的Mapping Strings。</target>
        </trans-unit>
        <trans-unit id="f2ad8f555f0fd0b81fe583ef82f57587da754391" translate="yes" xml:space="preserve">
          <source>This is twice as fast, because we have concurrent execution of two coroutines. Note that concurrency with coroutines is always explicit.</source>
          <target state="translated">这是速度的两倍,因为我们有两个coroutine的并发执行。注意,coroutine的并发总是显式的。</target>
        </trans-unit>
        <trans-unit id="92b4fd5ae8a5154b1a5e18bb911000880c41554c" translate="yes" xml:space="preserve">
          <source>This lets Android Studio know that the kotlin directory is a source root, so when the project model is loaded into the IDE it will be properly recognized. Alternatively, you can put Kotlin classes in the Java source directory, typically located in &lt;code&gt;src/main/java&lt;/code&gt;.</source>
          <target state="translated">这使Android Studio知道kotlin目录是源根目录，因此当将项目模型加载到IDE中时，它将被正确识别。另外，您可以将Kotlin类放在Java源目录中，该目录通常位于 &lt;code&gt;src/main/java&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="736ca34cfc08c91c8fd20715eb24479a73c79bdf" translate="yes" xml:space="preserve">
          <source>This library is published to Bintray JCenter repository, so let us add it:</source>
          <target state="translated">该库已发布到Bintray JCenter库中,让我们来添加它。</target>
        </trans-unit>
        <trans-unit id="898c5a35f84b96626909c79797c0f501c038d6e4" translate="yes" xml:space="preserve">
          <source>This list has size of &lt;code&gt;groupCount + 1&lt;/code&gt; where &lt;code&gt;groupCount&lt;/code&gt; is the count of groups in the regular expression. Groups are indexed from 1 to &lt;code&gt;groupCount&lt;/code&gt; and group with the index 0 corresponds to the entire match.</source>
          <target state="translated">此列表的大小为 &lt;code&gt;groupCount + 1&lt;/code&gt; ，其中 &lt;code&gt;groupCount&lt;/code&gt; 是正则表达式中的组数。组从1到 &lt;code&gt;groupCount&lt;/code&gt; 进行索引，索引为0的组与整个匹配相对应。</target>
        </trans-unit>
        <trans-unit id="4bdb3ec74f6932b33fd8d2d9d59b4f6dd5cdc88a" translate="yes" xml:space="preserve">
          <source>This marker distinguishes the experimental contract declaration API and is used to opt-in for that feature when declaring contracts of user functions.</source>
          <target state="translated">这个标记区分了实验性的合同声明API,用于在声明用户函数的合同时选择加入该功能。</target>
        </trans-unit>
        <trans-unit id="180f1cb299276ef1bdc5f464e18d2794e7d742af" translate="yes" xml:space="preserve">
          <source>This may be useful in the following cases:</source>
          <target state="translated">这在以下情况下可能有用:</target>
        </trans-unit>
        <trans-unit id="13bd4b9a1ff3829dff4d0473f506ce883108b5a3" translate="yes" xml:space="preserve">
          <source>This means that there's a library in the classpath which does not depend on the Kotlin standard library as a Gradle/Maven dependency, but is distributed in the same artifact with it (i.e. has it &lt;em&gt;bundled&lt;/em&gt;). Such a library may cause issues because standard build tools do not consider it an instance of the Kotlin standard library, thus it's not subject to the dependency version resolution mechanisms, and you can end up with several versions of the same library in the classpath. Consider contacting the authors of such a library and suggesting to use the Gradle/Maven dependency instead.</source>
          <target state="translated">这意味着在类路径中有一个库，该库不依赖Kotlin标准库作为Gradle / Maven依赖项，而是与它一起分布在同一工件中（即，将其&lt;em&gt;捆绑在一起&lt;/em&gt;）。这样的库可能会引起问题，因为标准构建工具不会将其视为Kotlin标准库的实例，因此它不受依赖版本解析机制的影响，并且最终可以在类路径中获得同一库的多个版本。考虑联系此类库的作者，并建议改用Gradle / Maven依赖项。</target>
        </trans-unit>
        <trans-unit id="6cde525aeab8f8f490a4ed99ff83215b05165a70" translate="yes" xml:space="preserve">
          <source>This means that you have a dependency on libraries of different versions, for example the 1.1 standard library and the 1.0 reflection library. To prevent subtle errors at runtime, we recommend you to use the same version of all Kotlin libraries. In this case, consider adding an explicit dependency on the 1.1 reflection library.</source>
          <target state="translated">这意味着你对不同版本的库有依赖性,例如1.1标准库和1.0反射库。为了防止在运行时出现微妙的错误,我们建议你使用所有Kotlin库的相同版本。在这种情况下,可以考虑在1.1反射库上添加一个显式依赖。</target>
        </trans-unit>
        <trans-unit id="17a60d9a927ab40397189c8d1b96e5f7c53d044e" translate="yes" xml:space="preserve">
          <source>This means that you're using the Kotlin compiler 1.1 against the standard or reflection library of version 1.0. This can be handled in different ways:</source>
          <target state="translated">这意味着你使用的Kotlin编译器1.1是针对1.0版本的标准库或反射库。这可以用不同的方式来处理。</target>
        </trans-unit>
        <trans-unit id="77369f21aef42d741a8e7d6c6dac5c006f439aba" translate="yes" xml:space="preserve">
          <source>This means you can call &lt;code&gt;myFunWithOptionalArgs&lt;/code&gt; with one required argument and two optional arguments (their default values are calculated by some JavaScript code).</source>
          <target state="translated">这意味着您可以使用一个必需的参数和两个可选的参数（它们的默认值由某些JavaScript代码计算）来调用 &lt;code&gt;myFunWithOptionalArgs&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="448a85fa82c5ef71170374be3303b1bc78bb209c" translate="yes" xml:space="preserve">
          <source>This meta-annotation determines that an annotation is a part of public API and therefore should be included in the generated documentation for the element to which the annotation is applied.</source>
          <target state="translated">这个元注解决定了注解是公共API的一部分,因此应该包含在应用注解的元素的生成文档中。</target>
        </trans-unit>
        <trans-unit id="5c594f1e41ee531a1ebc1db1a8ef8742f5fcd14a" translate="yes" xml:space="preserve">
          <source>This meta-annotation determines that an annotation is applicable twice or more on a single code element</source>
          <target state="translated">该元注解确定一个注解在一个代码元素上适用两次或两次以上。</target>
        </trans-unit>
        <trans-unit id="71d0203916dcd2ae084a69342802dae5c434f881" translate="yes" xml:space="preserve">
          <source>This meta-annotation determines whether an annotation is stored in binary output and visible for reflection. By default, both are true.</source>
          <target state="translated">该元注解决定了注解是否存储在二进制输出中,以及是否对反射可见。默认情况下,两者都为真。</target>
        </trans-unit>
        <trans-unit id="a36fadd37607b67a90a001f3c5a13ec3d8698650" translate="yes" xml:space="preserve">
          <source>This meta-annotation indicates the kinds of code elements which are possible targets of an annotation.</source>
          <target state="translated">这个元注解指出了可能成为注解目标的代码元素的种类。</target>
        </trans-unit>
        <trans-unit id="5733089c709664ede5e39a2892f4d97391a8d9f0" translate="yes" xml:space="preserve">
          <source>This method accepts values of &lt;a href=&quot;../kotlin/-short/index#kotlin.Short&quot;&gt;Short&lt;/a&gt; type in range &lt;code&gt;0x00..0xff&lt;/code&gt;, other values are prohibited.</source>
          <target state="translated">此方法接受 &lt;code&gt;0x00..0xff&lt;/code&gt; 范围内的&lt;a href=&quot;../kotlin/-short/index#kotlin.Short&quot;&gt;Short&lt;/a&gt;类型的值，禁止使用其他值。</target>
        </trans-unit>
        <trans-unit id="a75948e2d8c32738a31fd96217f7586ee79f04f4" translate="yes" xml:space="preserve">
          <source>This method allows to use destructuring declarations when working with maps, for example:</source>
          <target state="translated">此方法允许在处理地图时使用解构声明,例如。</target>
        </trans-unit>
        <trans-unit id="5a64298e1d3ab705d641d81b81fea403c6aa3318" translate="yes" xml:space="preserve">
          <source>This method allows to use the &lt;code&gt;x in map&lt;/code&gt; syntax for checking whether an object is contained in the map.</source>
          <target state="translated">此方法允许使用 &lt;code&gt;x in map&lt;/code&gt; 的x语法检查地图中是否包含对象。</target>
        </trans-unit>
        <trans-unit id="96f4999c28f30d3489635a82f469652d71846c62" translate="yes" xml:space="preserve">
          <source>This method guarantees not to put the value into the map if the key is already there, but the &lt;a href=&quot;get-or-put#kotlin.collections%24getOrPut%28java.util.concurrent.ConcurrentMap%28%28kotlin.collections.getOrPut.K%2C+kotlin.collections.getOrPut.V%29%29%2C+kotlin.collections.getOrPut.K%2C+kotlin.Function0%28%28kotlin.collections.getOrPut.V%29%29%29%2FdefaultValue&quot;&gt;defaultValue&lt;/a&gt; function may be invoked even if the key is already in the map.</source>
          <target state="translated">如果键已经在映射中，则此方法保证不将值放入映射中，但是即使键已在映射中，也可以调用&lt;a href=&quot;get-or-put#kotlin.collections%24getOrPut%28java.util.concurrent.ConcurrentMap%28%28kotlin.collections.getOrPut.K%2C+kotlin.collections.getOrPut.V%29%29%2C+kotlin.collections.getOrPut.K%2C+kotlin.Function0%28%28kotlin.collections.getOrPut.V%29%29%29%2FdefaultValue&quot;&gt;defaultValue&lt;/a&gt;函数。</target>
        </trans-unit>
        <trans-unit id="083648bbf3b66e12f1c5e5fd3afa3ff2914dd084" translate="yes" xml:space="preserve">
          <source>This method is not recommended on huge files.</source>
          <target state="translated">对于巨大的文件,不建议使用这种方法。</target>
        </trans-unit>
        <trans-unit id="ecd5e6ce22de7239fac178cb06d85481149c22bf" translate="yes" xml:space="preserve">
          <source>This method is not recommended on huge files. It has an internal limitation of 2 GB byte array size.</source>
          <target state="translated">在巨大的文件上不推荐使用这种方法。它的内部限制是2GB的字节阵列大小。</target>
        </trans-unit>
        <trans-unit id="ecfd9cc7f27ed3b4efbb7dd03aebaf75912a636e" translate="yes" xml:space="preserve">
          <source>This method is not recommended on huge files. It has an internal limitation of 2 GB file size.</source>
          <target state="translated">此方法不推荐用于巨大的文件。它的内部限制是2GB的文件大小。</target>
        </trans-unit>
        <trans-unit id="43901fb40d645ef2b68c677a55d2f926ea8ed530" translate="yes" xml:space="preserve">
          <source>This method is redeclared as abstract, because it's not implemented in the base class, so it must be always overridden in the concrete mutable collection implementation.</source>
          <target state="translated">这个方法被重新声明为抽象的,因为它没有在基类中实现,所以它必须在具体的可变集合实现中始终被重写。</target>
        </trans-unit>
        <trans-unit id="f25f95428ac465fef329ee7b3944fdbec35af43f" translate="yes" xml:space="preserve">
          <source>This mode should not be used unless the &lt;a href=&quot;../-lazy/index&quot;&gt;Lazy&lt;/a&gt; instance is guaranteed never to be initialized from more than one thread.</source>
          <target state="translated">除非保证永不从多个线程初始化&lt;a href=&quot;../-lazy/index&quot;&gt;Lazy&lt;/a&gt;实例，否则不应使用此模式。</target>
        </trans-unit>
        <trans-unit id="6446cf4cb49ffcb2caf4afcf619d26541516a151" translate="yes" xml:space="preserve">
          <source>This name can be used to access the binary:</source>
          <target state="translated">这个名字可以用来访问二进制。</target>
        </trans-unit>
        <trans-unit id="acb387fd4daeff721899d12634f06c3c11719a1e" translate="yes" xml:space="preserve">
          <source>This now works much faster and produces correct result.</source>
          <target state="translated">现在工作速度更快,并产生正确的结果。</target>
        </trans-unit>
        <trans-unit id="08d7f6ce5ec74ffd1dae5f3e2a4e554fa93562ae" translate="yes" xml:space="preserve">
          <source>This page contains the current coding style for the Kotlin language.</source>
          <target state="translated">本页包含当前Kotlin语言的编码风格。</target>
        </trans-unit>
        <trans-unit id="3b0d3b6a365feefc5bf2639481a27bf15df77f32" translate="yes" xml:space="preserve">
          <source>This plugin only works for Kotlin files so it is recommended to keep Kotlin and Java files separate (in case if the same project contains Java files). As with targeting the JVM, if not using the default convention, you should specify the source folder using &lt;em&gt;sourceSets&lt;/em&gt;:</source>
          <target state="translated">该插件仅适用于Kotlin文件，因此建议将Kotlin和Java文件分开（以防同一项目包含Java文件）。与定位JVM一样，如果不使用默认约定，则应使用&lt;em&gt;sourceSets&lt;/em&gt;指定源文件夹：</target>
        </trans-unit>
        <trans-unit id="2d1dbfb5aeb4d13de4e43c69f4da833e8295308f" translate="yes" xml:space="preserve">
          <source>This podspec file can be referenced from a &lt;a href=&quot;https://guides.cocoapods.org/using/the-podfile.html&quot;&gt;Podfile&lt;/a&gt; of an Xcode project. After that the framework built from the Kotlin/Native module can be used from this Xcode project. If necessary, this framework is automatically rebuilt during Xcode build process.</source>
          <target state="translated">可以从Xcode项目的&lt;a href=&quot;https://guides.cocoapods.org/using/the-podfile.html&quot;&gt;Podfile&lt;/a&gt;中引用此podspec文件。之后，可以从此Xcode项目中使用从Kotlin / Native模块构建的框架。如有必要，可以在Xcode构建过程中自动重建此框架。</target>
        </trans-unit>
        <trans-unit id="30a2879d5d48273acab2ab3a9f22c1edf08032e3" translate="yes" xml:space="preserve">
          <source>This prints</source>
          <target state="translated">此印刷品</target>
        </trans-unit>
        <trans-unit id="345205710c1209079bdf05b4d146f25fe0a01f36" translate="yes" xml:space="preserve">
          <source>This prints:</source>
          <target state="translated">这个指纹。</target>
        </trans-unit>
        <trans-unit id="cda4b457c77664242055b4741cc46d64c55f08a1" translate="yes" xml:space="preserve">
          <source>This programming style with async functions is provided here only for illustration, because it is a popular style in other programming languages. Using this style with Kotlin coroutines is &lt;strong&gt;strongly discouraged&lt;/strong&gt; for the reasons that are explained below.</source>
          <target state="translated">具有异步功能的这种编程样式仅在此处提供说明，因为它是其他编程语言中的一种流行样式。&lt;strong&gt;强烈建议不要&lt;/strong&gt;将这种样式与Kotlin协程一起使用，原因如下。</target>
        </trans-unit>
        <trans-unit id="77b890076daadde689d1ec3897dcc482dac8e326" translate="yes" xml:space="preserve">
          <source>This property can be used in two cases:</source>
          <target state="translated">这个属性可以在两种情况下使用。</target>
        </trans-unit>
        <trans-unit id="ff03394cef9f3232cd16286e35c99b97f61a20fd" translate="yes" xml:space="preserve">
          <source>This property can't be used from normal code.</source>
          <target state="translated">此属性不能从普通代码中使用。</target>
        </trans-unit>
        <trans-unit id="aec1ca1351fa183afc05654031c5fff3d664e375" translate="yes" xml:space="preserve">
          <source>This protocol is designed for comfortable updates as no project can be blocked from updating its dependencies even if it's using a slightly outdated compiler.</source>
          <target state="translated">这个协议是为舒适的更新而设计的,因为即使项目使用的是稍微过时的编译器,也不会被阻止更新其依赖关系。</target>
        </trans-unit>
        <trans-unit id="98a9e8bab8deee99e0e21fcb3247e8a1511740b5" translate="yes" xml:space="preserve">
          <source>This publication does not include any artifacts and only references the other publications as its variants. However, it may need the sources and documentation artifacts if that is required by the repository. In that case, add those artifacts by using &lt;a href=&quot;https://docs.gradle.org/current/javadoc/org/gradle/api/publish/maven/MavenPublication.html#artifact-java.lang.Object-&quot;&gt;&lt;code&gt;artifact(...)&lt;/code&gt;&lt;/a&gt; in the publication's scope, which is accessed as shown above.</source>
          <target state="translated">该出版物不包含任何工件，仅引用其他出版物作为其变体。但是，如果存储库需要，则可能需要源和文档工件。在这种情况下，请使用出版物范围内的&lt;a href=&quot;https://docs.gradle.org/current/javadoc/org/gradle/api/publish/maven/MavenPublication.html#artifact-java.lang.Object-&quot;&gt; &lt;code&gt;artifact(...)&lt;/code&gt; &lt;/a&gt;添加这些工件，如上所示进行访问。</target>
        </trans-unit>
        <trans-unit id="e2515924de7501ee2f4c68fc0b725aaaf061557d" translate="yes" xml:space="preserve">
          <source>This quickly gets unwieldy, so you will typically &lt;em&gt;import&lt;/em&gt; the symbols you need. You can import a specific symbol:</source>
          <target state="translated">这很快变得很笨拙，因此通常您将&lt;em&gt;导入&lt;/em&gt;所需的符号。您可以导入特定的符号：</target>
        </trans-unit>
        <trans-unit id="b4727911dc96369eca10addebc256163a4abb387" translate="yes" xml:space="preserve">
          <source>This requires that the consumer's Gradle build can read Gradle module metadata, either using Gradle 5.3+ or explicitly enabling it by &lt;code&gt;enableFeaturePreview(&quot;GRADLE_METADATA&quot;)&lt;/code&gt; in &lt;code&gt;settings.gradle&lt;/code&gt;.</source>
          <target state="translated">这就需要消费者的摇篮构建可以阅读摇篮模块的元数据，或者使用摇篮5.3+或显式启用它由 &lt;code&gt;enableFeaturePreview(&quot;GRADLE_METADATA&quot;)&lt;/code&gt; 在 &lt;code&gt;settings.gradle&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e3811c08a3b736bc78dff85189aa76ac7adf599c" translate="yes" xml:space="preserve">
          <source>This returns &lt;code&gt;b.length&lt;/code&gt; if &lt;code&gt;b&lt;/code&gt; is not null, and &lt;em&gt;null&lt;/em&gt; otherwise. The type of this expression is &lt;code&gt;Int?&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;b&lt;/code&gt; 不为null，则返回 &lt;code&gt;b.length&lt;/code&gt; ，否则返回&lt;em&gt;null&lt;/em&gt;。此表达式的类型是 &lt;code&gt;Int?&lt;/code&gt; 。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="752e46575723521dd2b0e2f3643820dd84459a5c" translate="yes" xml:space="preserve">
          <source>This runs a 1'000'000 threads each of which adds to a common counter. My patience runs out before this program completes on my machine (definitely over a minute).</source>
          <target state="translated">这个程序会运行100万个线程,每个线程都会增加一个公共计数器。我的耐心在这个程序在我的机器上完成之前就耗尽了(绝对超过一分钟)。</target>
        </trans-unit>
        <trans-unit id="86208ae33ef90a5dcb8c41ac6a075a89ce88f8d7" translate="yes" xml:space="preserve">
          <source>This section covers basic coroutine concepts.</source>
          <target state="translated">本节包括基本的coroutine概念。</target>
        </trans-unit>
        <trans-unit id="75d5f867c8b73c01b71e379315dc5e2a4c6f94a7" translate="yes" xml:space="preserve">
          <source>This section covers coroutine cancellation and timeouts.</source>
          <target state="translated">本节介绍了outine取消和超时。</target>
        </trans-unit>
        <trans-unit id="7fd839d8f63682d12541a453824eb6d8c7ab4f81" translate="yes" xml:space="preserve">
          <source>This section covers exception handling and cancellation on exceptions. We already know that cancelled coroutine throws &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-cancellation-exception/index.html&quot;&gt;CancellationException&lt;/a&gt; in suspension points and that it is ignored by coroutines machinery. But what happens if an exception is thrown during cancellation or multiple children of the same coroutine throw an exception?</source>
          <target state="translated">本节介绍异常处理和异常的取消。我们已经知道，取消的协程会在挂起点上引发&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-cancellation-exception/index.html&quot;&gt;CancellationException&lt;/a&gt;，并且协程机制会忽略它。但是，如果在取消过程中引发异常，或者同一个协程的多个子级引发异常，会发生什么呢？</target>
        </trans-unit>
        <trans-unit id="dd1323da1dc057b96f757b1081629bfe17cfb809" translate="yes" xml:space="preserve">
          <source>This section covers various approaches to composition of suspending functions.</source>
          <target state="translated">本节介绍了悬浮功能的各种构成方法。</target>
        </trans-unit>
        <trans-unit id="c0b801aac5ae1a9b9aa65ed84d940a1ebfabf5c1" translate="yes" xml:space="preserve">
          <source>This self-contained jar file can be passed directly to a JRE to run your application:</source>
          <target state="translated">这个自包含的jar文件可以直接传递给JRE来运行你的应用程序。</target>
        </trans-unit>
        <trans-unit id="3eff95c0ad7329dd98bdd50eb833ef0910fc787b" translate="yes" xml:space="preserve">
          <source>This simplified example ensures that the JVM, JS, and Kotlin metadata publications are only uploaded when &lt;code&gt;-PisLinux=true&lt;/code&gt; is passed to the build in the command line:</source>
          <target state="translated">这个简化的示例确保仅在将 &lt;code&gt;-PisLinux=true&lt;/code&gt; 传递到命令行中的构建时，才上载JVM，JS和Kotlin元数据发布：</target>
        </trans-unit>
        <trans-unit id="41a51abdee059894e1c3bfb1c72642c3da8b751d" translate="yes" xml:space="preserve">
          <source>This starts a new coroutine. By default, coroutines are run on a shared pool of threads. Threads still exist in a program based on coroutines, but one thread can run many coroutines, so there's no need for too many threads.</source>
          <target state="translated">这将启动一个新的coroutine,默认情况下,coroutine在共享线程池上运行。默认情况下,coroutine是在一个共享的线程池上运行的。在基于coroutine的程序中仍然存在线程,但一个线程可以运行许多coroutine,所以不需要太多的线程。</target>
        </trans-unit>
        <trans-unit id="76c41d50702d4202e91d08f7ef8c0739fa6d0823" translate="yes" xml:space="preserve">
          <source>This syntax is called a &lt;em&gt;destructuring declaration&lt;/em&gt;. A destructuring declaration creates multiple variables at once. We have declared two new variables: &lt;code&gt;name&lt;/code&gt; and &lt;code&gt;age&lt;/code&gt;, and can use them independently:</source>
          <target state="translated">此语法称为&lt;em&gt;解构声明&lt;/em&gt;。销毁声明一次创建多个变量。我们已经声明了两个新变量： &lt;code&gt;name&lt;/code&gt; 和 &lt;code&gt;age&lt;/code&gt; ，并且可以独立使用它们：</target>
        </trans-unit>
        <trans-unit id="530a8c17c6739ef629eabdb94246db16d43922c7" translate="yes" xml:space="preserve">
          <source>This table says that when the compiler processes, for example, an expression &lt;code&gt;+a&lt;/code&gt;, it performs the following steps:</source>
          <target state="translated">该表表明，当编译器处理例如表达式 &lt;code&gt;+a&lt;/code&gt; 时，它将执行以下步骤：</target>
        </trans-unit>
        <trans-unit id="cca6caa135016bb5fe36c582797dd2583e1f3082" translate="yes" xml:space="preserve">
          <source>This takes about 10 seconds on my machine, so yes, coroutines do run in parallel.</source>
          <target state="translated">这在我的机器上大约需要10秒钟,所以是的,coroutines确实是并行运行的。</target>
        </trans-unit>
        <trans-unit id="215ff0a6c5e99998fdfa92a79eaf70ff28fc615e" translate="yes" xml:space="preserve">
          <source>This task copies both dependencies runtime files and the compilation output to the &lt;code&gt;web&lt;/code&gt; directory.</source>
          <target state="translated">此任务将依赖项运行时文件和编译输出都复制到 &lt;code&gt;web&lt;/code&gt; 目录。</target>
        </trans-unit>
        <trans-unit id="1a26679828d6c6d2c31183443afd2cce0f1abe38" translate="yes" xml:space="preserve">
          <source>This test will be automatically executed on the JVM target in addition to the common part.</source>
          <target state="translated">除了常见的部分外,这个测试将在JVM目标上自动执行。</target>
        </trans-unit>
        <trans-unit id="422dc05df4ea784a9b658e3b358ccefed13a0844" translate="yes" xml:space="preserve">
          <source>This time we take a returned &lt;code&gt;char *&lt;/code&gt; from the &lt;code&gt;return_string&lt;/code&gt; function and turn it into a Kotlin string. For that we do the following in Kotlin:</source>
          <target state="translated">这次，我们从 &lt;code&gt;return_string&lt;/code&gt; 函数获取一个返回的 &lt;code&gt;char *&lt;/code&gt; 并将其转换为Kotlin字符串。为此，我们在Kotlin中执行以下操作：</target>
        </trans-unit>
        <trans-unit id="1bc095b457022b841cd86dbdae9f7dd06a0233ca" translate="yes" xml:space="preserve">
          <source>This time we will ask a C function to write us a C string to a given buffer. The function is called &lt;code&gt;copy_string&lt;/code&gt;. It takes a pointer to the location writing characters and the allowed buffer size. The function returns something to indicate if it has succeeded or failed. Let's assume &lt;code&gt;0&lt;/code&gt; means it succeeded, and the supplied buffer was big enough:</source>
          <target state="translated">这次，我们将要求C函数将C字符串写入给定的缓冲区。该函数称为 &lt;code&gt;copy_string&lt;/code&gt; 。它需要指向写入字符和允许的缓冲区大小的位置的指针。该函数返回一些内容以指示它是否成功。假设 &lt;code&gt;0&lt;/code&gt; 表示成功，并且提供的缓冲区足够大：</target>
        </trans-unit>
        <trans-unit id="95eb5f454522f97d35d22eb89071211f56ea5b5c" translate="yes" xml:space="preserve">
          <source>This tutorial describes how to use Kotlin Android Extensions to improve support for Android development.</source>
          <target state="translated">本教程介绍如何使用Kotlin Android Extensions来提高对Android开发的支持。</target>
        </trans-unit>
        <trans-unit id="54b32f69d1a441fb0920f9a2c8eb9ed0a6588065" translate="yes" xml:space="preserve">
          <source>This tutorial describes how to use in Kotlin popular Android frameworks and libraries that rely on annotation processing.</source>
          <target state="translated">本教程介绍了如何在Kotlin中使用流行的依赖注释处理的Android框架和库。</target>
        </trans-unit>
        <trans-unit id="98dac163941bb963709918b2eba82c9b82af15ef" translate="yes" xml:space="preserve">
          <source>This tutorial explains the basic usage of Kotlin for competitive programming.</source>
          <target state="translated">本教程讲解了Kotlin在竞技编程中的基本用法。</target>
        </trans-unit>
        <trans-unit id="d0f7acc9fd5623b0666fe34b54ba37696a87ee9a" translate="yes" xml:space="preserve">
          <source>This tutorial explains the different approaches to asynchronous programming</source>
          <target state="translated">本教程解释了异步编程的不同方法。</target>
        </trans-unit>
        <trans-unit id="b37aa099eaa69fb3a0a9c2ea81dc57defd40be24" translate="yes" xml:space="preserve">
          <source>This tutorial is designed both for competitive programmers that did not use Kotlin before and for Kotlin developers that did not participate in any competitive programming events before. It assumes the corresponding programming skills.</source>
          <target state="translated">本教程既是为以前没有使用过Kotlin的竞技程序员设计的,也是为以前没有参加过任何竞技编程活动的Kotlin开发人员设计的。它假设了相应的编程技能。</target>
        </trans-unit>
        <trans-unit id="6ab5e488d7caf8012aa22bda0a09bdd7f98d9861" translate="yes" xml:space="preserve">
          <source>This tutorial shows how to debug a Kotlin/JS project build by Gradle. If you are using Maven or IDEA, the recipes would be similar.</source>
          <target state="translated">本教程介绍了如何调试一个由Gradle构建的Kotlin/JS项目。如果你使用的是Maven或IDEA,那么配方也会类似。</target>
        </trans-unit>
        <trans-unit id="f9acc149373601d8ab69e64887e6e309b360247b" translate="yes" xml:space="preserve">
          <source>This tutorial shows the ways to run Kotlin code snippets in a lightweight manner without creating or modifying the whole project.</source>
          <target state="translated">本教程展示了在不创建或修改整个项目的情况下,以轻量级方式运行Kotlin代码片段的方法。</target>
        </trans-unit>
        <trans-unit id="b741e974e2ef9e2aadef771ec4ed4af6da26b1ed" translate="yes" xml:space="preserve">
          <source>This tutorial walks us through creating a Hello World application using the command line compiler.</source>
          <target state="translated">本教程将引导我们使用命令行编译器创建一个Hello World应用程序。</target>
        </trans-unit>
        <trans-unit id="9ef69a04e24828e3b4f1be864d64b99505227e64" translate="yes" xml:space="preserve">
          <source>This tutorial walks us through creating a Kotlin JavaScript library using the command line compiler.</source>
          <target state="translated">本教程引导我们使用命令行编译器创建一个Kotlin JavaScript库。</target>
        </trans-unit>
        <trans-unit id="7cbf690e869df1155e9df8254a2e24065f3c7742" translate="yes" xml:space="preserve">
          <source>This tutorial walks us through creating a simple Kotlin application for Android.</source>
          <target state="translated">本教程将带领我们创建一个简单的Android版Kotlin应用程序。</target>
        </trans-unit>
        <trans-unit id="262f778d62fb1c6728a7e17683a48adb22e2c354" translate="yes" xml:space="preserve">
          <source>This tutorial walks us through setting up a project using coroutines, and writing code that uses them.</source>
          <target state="translated">本教程将引导我们使用coroutines设置一个项目,并编写使用它们的代码。</target>
        </trans-unit>
        <trans-unit id="b761f80d7daf0f57c426b6c2c8f5551348835c06" translate="yes" xml:space="preserve">
          <source>This tutorial walks us through the process of creating a simple REST controller with Spring Boot</source>
          <target state="translated">本教程将引导我们使用Spring Boot创建一个简单的REST控制器的过程。</target>
        </trans-unit>
        <trans-unit id="d3c06d78974760f747dc344799aadb31e636411d" translate="yes" xml:space="preserve">
          <source>This tutorial walks us through the process of creating a simple controller using HttpServlet to display Hello World.</source>
          <target state="translated">本教程引导我们使用HttpServlet创建一个简单的控制器来显示Hello World的过程。</target>
        </trans-unit>
        <trans-unit id="917a46d0d52ec8a68291cefda5c1868408d5366b" translate="yes" xml:space="preserve">
          <source>This tutorial walks us through the process of using Java and Kotlin in a single IntelliJ IDEA project.</source>
          <target state="translated">本教程将带领我们在一个IntelliJ IDEA项目中使用Java和Kotlin的过程。</target>
        </trans-unit>
        <trans-unit id="5c37cdc48efb7900f24478fb914764b4ad25e974" translate="yes" xml:space="preserve">
          <source>This tutorial walks you through a series of exercises to get familiar with Kotlin.</source>
          <target state="translated">本教程将引导你通过一系列练习来熟悉Kotlin。</target>
        </trans-unit>
        <trans-unit id="fed85180abcbc65ba4b2af3d5f5d2d524508a6b7" translate="yes" xml:space="preserve">
          <source>This tutorial walks you through creating a simple Hello World application using IntelliJ IDEA.</source>
          <target state="translated">本教程指导您使用IntelliJ IDEA创建一个简单的Hello World应用程序。</target>
        </trans-unit>
        <trans-unit id="3a3a5550c3979eb75d3c935292c9198b690dcdbe" translate="yes" xml:space="preserve">
          <source>This tutorial walks you through the interactive learning with a set of Kotlin programming tasks.</source>
          <target state="translated">本教程通过一组Kotlin编程任务引导大家进行互动学习。</target>
        </trans-unit>
        <trans-unit id="1922851cbe5cc3d86c3c73d15c6f4bdffb8c9675" translate="yes" xml:space="preserve">
          <source>This tutorial will walk you through creating a simple Kotlin course with a set of programming tasks and integrated tests.</source>
          <target state="translated">本教程将引导你创建一个简单的Kotlin课程,其中包含一组编程任务和集成测试。</target>
        </trans-unit>
        <trans-unit id="c6030bef069b6977eab83078442b66dedd7712ad" translate="yes" xml:space="preserve">
          <source>This tutorials walks us through creating a simple Hello World application using Eclipse IDE</source>
          <target state="translated">本教程将引导我们使用Eclipse IDE创建一个简单的Hello World应用程序。</target>
        </trans-unit>
        <trans-unit id="1cba3a52b4e9e49248914c3506dd87812401b394" translate="yes" xml:space="preserve">
          <source>This type is used as a receiver type of the lambda function passed to the &lt;a href=&quot;../contract&quot;&gt;contract&lt;/a&gt; function.</source>
          <target state="translated">此类型用作传递给&lt;a href=&quot;../contract&quot;&gt;协定&lt;/a&gt;函数的lambda函数的接收器类型。</target>
        </trans-unit>
        <trans-unit id="d42addf558756322234c05ff9ff53ebc28a290b0" translate="yes" xml:space="preserve">
          <source>This value is used as a return value of &lt;a href=&quot;suspend-coroutine-or-return&quot;&gt;suspendCoroutineOrReturn&lt;/a&gt;&lt;code&gt;block&lt;/code&gt; argument to state that the execution was suspended and will not return any result immediately.</source>
          <target state="translated">该值用作&lt;a href=&quot;suspend-coroutine-or-return&quot;&gt;suspendCoroutineOrReturn &lt;/a&gt; &lt;code&gt;block&lt;/code&gt; 参数的返回值，以声明执行已被挂起并且不会立即返回任何结果。</target>
        </trans-unit>
        <trans-unit id="f268b965a48f4655e5367448b4016e6f76edf6f0" translate="yes" xml:space="preserve">
          <source>This value is used as a return value of &lt;a href=&quot;suspend-coroutine-unintercepted-or-return&quot;&gt;suspendCoroutineUninterceptedOrReturn&lt;/a&gt;&lt;code&gt;block&lt;/code&gt; argument to state that the execution was suspended and will not return any result immediately.</source>
          <target state="translated">该值用作&lt;a href=&quot;suspend-coroutine-unintercepted-or-return&quot;&gt;suspendCoroutineUninterceptedOrReturn &lt;/a&gt; &lt;code&gt;block&lt;/code&gt; 参数的返回值，以表明执行已被挂起并且不会立即返回任何结果。</target>
        </trans-unit>
        <trans-unit id="6e8f43b127da8dc0c4ddf32ba0afa9420b6890c9" translate="yes" xml:space="preserve">
          <source>This value needs to be smaller than &lt;a href=&quot;range-to#kotlin.ranges%24rangeTo%28kotlin.ranges.rangeTo.T%2C+kotlin.ranges.rangeTo.T%29%2Fthat&quot;&gt;that&lt;/a&gt; value, otherwise the returned range will be empty.</source>
          <target state="translated">该值必须小于&lt;a href=&quot;range-to#kotlin.ranges%24rangeTo%28kotlin.ranges.rangeTo.T%2C+kotlin.ranges.rangeTo.T%29%2Fthat&quot;&gt;该&lt;/a&gt;值，否则返回的范围将为空。</target>
        </trans-unit>
        <trans-unit id="9a4e95d6779047f36ef44cebc8fe10ec0e5dbd2f" translate="yes" xml:space="preserve">
          <source>This way any value of type &lt;code&gt;CPointer&amp;lt;ByteVar&amp;gt;&lt;/code&gt; can be passed as an argument of &lt;code&gt;const char*&lt;/code&gt; type. If a Kotlin string should be passed, code like this could be used:</source>
          <target state="translated">这样，任何类型为 &lt;code&gt;CPointer&amp;lt;ByteVar&amp;gt;&lt;/code&gt; 都可以作为 &lt;code&gt;const char*&lt;/code&gt; 类型的参数传递。如果应该传递Kotlin字符串，则可以使用如下代码：</target>
        </trans-unit>
        <trans-unit id="98a5e105dc56eeee056d102244e8a0f5fed4f0c6" translate="yes" xml:space="preserve">
          <source>This way, if something goes wrong inside the code of &lt;code&gt;concurrentSum&lt;/code&gt; function and it throws an exception, all the coroutines that were launched in its scope are cancelled.</source>
          <target state="translated">这样，如果 &lt;code&gt;concurrentSum&lt;/code&gt; 函数的代码内部出现问题并引发异常，则将取消在其作用域中启动的所有协程。</target>
        </trans-unit>
        <trans-unit id="f17f9d1f7410fbad939ec9e37eb14f1a6139cb16" translate="yes" xml:space="preserve">
          <source>This will apply the Gradle &lt;code&gt;java&lt;/code&gt; plugin and configure the target to cooperate with it. Note that just applying the Java plugin without specifying &lt;code&gt;withJava()&lt;/code&gt; in a JVM target will have no effect on the target.</source>
          <target state="translated">这将应用Gradle &lt;code&gt;java&lt;/code&gt; 插件并配置目标与之合作。注意，仅应用Java插件而不在JVM目标中指定 &lt;code&gt;withJava()&lt;/code&gt; 不会对目标产生影响。</target>
        </trans-unit>
        <trans-unit id="5e9c760291236659fa80c3cad20690354472cf0c" translate="yes" xml:space="preserve">
          <source>This will assign &lt;code&gt;x&lt;/code&gt; to &lt;code&gt;z&lt;/code&gt; if &lt;code&gt;x&lt;/code&gt; is non-null, but if it is null, the entire function that contains this expression will stop and return &lt;code&gt;y&lt;/code&gt; (this works because &lt;code&gt;return&lt;/code&gt; is also an expression, and if it is evaluated, it evaluates its argument and then makes the containing function return the result).</source>
          <target state="translated">这将分配 &lt;code&gt;x&lt;/code&gt; 到 &lt;code&gt;z&lt;/code&gt; 如果 &lt;code&gt;x&lt;/code&gt; 不为null，但如果是空，包含此表达将停止并返回整个功能 &lt;code&gt;y&lt;/code&gt; （这工作，因为 &lt;code&gt;return&lt;/code&gt; 也是一个表达式，如果评估时，评估其参数，然后使包含函数返回结果）。</target>
        </trans-unit>
        <trans-unit id="e3c6e68d7f248b58990253f88430e5ca4c4c8e2b" translate="yes" xml:space="preserve">
          <source>This will automatically implement all the interface members of &lt;code&gt;PowerSource&lt;/code&gt; in &lt;code&gt;MotorVehicle&lt;/code&gt; by invoking the same member on &lt;code&gt;engine&lt;/code&gt;. This only works for properties that are declared in the constructor.</source>
          <target state="translated">通过在 &lt;code&gt;engine&lt;/code&gt; 上调用同一成员，这将自动在 &lt;code&gt;PowerSource&lt;/code&gt; 中实现 &lt;code&gt;MotorVehicle&lt;/code&gt; 的所有接口成员。这仅适用于在构造函数中声明的属性。</target>
        </trans-unit>
        <trans-unit id="e4c10956ebfa0383ee2f1e029c8feb69cf8fc5ac" translate="yes" xml:space="preserve">
          <source>This will raise a &lt;code&gt;ClassCastException&lt;/code&gt; if the object is not actually an instance of &lt;code&gt;Person&lt;/code&gt; or any of its subclasses. If you're not sure what &lt;code&gt;x&lt;/code&gt; is, but you're happy to get null if it's not a &lt;code&gt;Person&lt;/code&gt;, you can use &lt;code&gt;as?&lt;/code&gt;, which will return null if the cast fails. Note that the resulting type is &lt;code&gt;Person?&lt;/code&gt;:</source>
          <target state="translated">如果对象实际上不是 &lt;code&gt;Person&lt;/code&gt; 或其任何子类的实例，则将引发 &lt;code&gt;ClassCastException&lt;/code&gt; 。如果不确定 &lt;code&gt;x&lt;/code&gt; 是什么，但如果不是 &lt;code&gt;Person&lt;/code&gt; ，则很高兴获得null ，可以 &lt;code&gt;as?&lt;/code&gt; ，如果强制转换失败，它将返回null。请注意，结果类型为 &lt;code&gt;Person?&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="fa6b2b95ad5f670c5af166fa09cb0ec4fc6be37b" translate="yes" xml:space="preserve">
          <source>This works also for &lt;em&gt;var&lt;/em&gt;&amp;rsquo;s properties if you use a &lt;code&gt;MutableMap&lt;/code&gt; instead of read-only &lt;code&gt;Map&lt;/code&gt;:</source>
          <target state="translated">如果您使用 &lt;code&gt;MutableMap&lt;/code&gt; 而不是只读 &lt;code&gt;Map&lt;/code&gt; ,那么这也适用于&lt;em&gt;var&lt;/em&gt;的属性：</target>
        </trans-unit>
        <trans-unit id="dfbae76eefb17a295e772659a5df1b063a9b20dc" translate="yes" xml:space="preserve">
          <source>Those class names are always getting in the way. We can use static imports and get this:</source>
          <target state="translated">那些类名总是碍于情面。我们可以使用静态导入,得到这个。</target>
        </trans-unit>
        <trans-unit id="840686b21fe85a3d03fcebd9f6fe5d67ee5b8f5f" translate="yes" xml:space="preserve">
          <source>Though reflection may not be needed in many cases, we can still use it with a reified type parameter:</source>
          <target state="translated">虽然在很多情况下可能不需要反射,但我们仍然可以用一个重构的类型参数来使用它。</target>
        </trans-unit>
        <trans-unit id="db9c8e28b5db7e794581721a97a55d403ef96db4" translate="yes" xml:space="preserve">
          <source>Thread confinement coarse-grained</source>
          <target state="translated">粗粒度的螺纹封闭</target>
        </trans-unit>
        <trans-unit id="58c8dc7270e76e9fe5dcba1621b0a309ea2a0ff5" translate="yes" xml:space="preserve">
          <source>Thread confinement fine-grained</source>
          <target state="translated">细致的螺纹密闭</target>
        </trans-unit>
        <trans-unit id="07c0a8bbcccb40629ed6cd8852b0c2af35dea6b2" translate="yes" xml:space="preserve">
          <source>Thread-local data</source>
          <target state="translated">线程本地数据</target>
        </trans-unit>
        <trans-unit id="b51d97d48189b14ee90ab80ab5f1002db2ed52a4" translate="yes" xml:space="preserve">
          <source>Thread-safe data structures</source>
          <target state="translated">线程安全的数据结构</target>
        </trans-unit>
        <trans-unit id="8a77bfd3db44e0aeb0a80c2f055eea2ff97f89d4" translate="yes" xml:space="preserve">
          <source>ThreadLocal</source>
          <target state="translated">ThreadLocal</target>
        </trans-unit>
        <trans-unit id="5541d0b76d127f6a3c54bbc247ffcc1b6c2bbc25" translate="yes" xml:space="preserve">
          <source>Threading</source>
          <target state="translated">Threading</target>
        </trans-unit>
        <trans-unit id="54fc24f5a7668604be098318c177c182e63b5fa7" translate="yes" xml:space="preserve">
          <source>Threads are by far probably the most well-known approach to avoid applications from blocking.</source>
          <target state="translated">线程可能是目前最著名的避免应用阻塞的方法。</target>
        </trans-unit>
        <trans-unit id="c8cb6272d819adb1d7ec29aee37d20ed2b2cd093" translate="yes" xml:space="preserve">
          <source>Threads aren't always available. Some platforms, such as JavaScript do not even support threads</source>
          <target state="translated">线程并不总是可用。有些平台,如JavaScript甚至不支持线程。</target>
        </trans-unit>
        <trans-unit id="100ffacab3bbb22c877b7db046d6811ab68a4092" translate="yes" xml:space="preserve">
          <source>Threads aren't cheap. Threads require context switches which are costly.</source>
          <target state="translated">线程并不便宜。线程需要上下文切换,成本很高。</target>
        </trans-unit>
        <trans-unit id="ed5d4b963a60e738f823f980aab2e771fb9e0b19" translate="yes" xml:space="preserve">
          <source>Threads aren't easy. Debugging threads, avoiding race conditions are common problems we suffer in multi-threaded programming.</source>
          <target state="translated">线程并不容易。调试线程、避免竞赛条件是我们在多线程编程中常遇到的问题。</target>
        </trans-unit>
        <trans-unit id="dada4feb2387f68301b5e37c631ce74cff4d977a" translate="yes" xml:space="preserve">
          <source>Threads aren't infinite. The number of threads that can be launched is limited by the underlying operating system. In server-side applications, this could cause a major bottleneck.</source>
          <target state="translated">线程并不是无限的。可以启动的线程数量受到底层操作系统的限制。在服务器端应用中,这可能会造成重大瓶颈。</target>
        </trans-unit>
        <trans-unit id="8abf11297f412ee4fff55514bb434f634e293565" translate="yes" xml:space="preserve">
          <source>Throwable</source>
          <target state="translated">Throwable</target>
        </trans-unit>
        <trans-unit id="eac1fd32ab840fc388b25886124b82f77d7d2760" translate="yes" xml:space="preserve">
          <source>Throwing and catching</source>
          <target state="translated">扔和接</target>
        </trans-unit>
        <trans-unit id="f9f4b0f30b3f06e61b21febef173645d29891305" translate="yes" xml:space="preserve">
          <source>Throws</source>
          <target state="translated">Throws</target>
        </trans-unit>
        <trans-unit id="b1b2da4ce29be6e42fd3a3a1d87f8fd7bd99c3f3" translate="yes" xml:space="preserve">
          <source>Throws an &lt;a href=&quot;-assertion-error/index#kotlin.AssertionError&quot;&gt;AssertionError&lt;/a&gt; calculated by &lt;a href=&quot;assert#kotlin%24assert%28kotlin.Boolean%2C+kotlin.Function0%28%28kotlin.Any%29%29%29%2FlazyMessage&quot;&gt;lazyMessage&lt;/a&gt; if the &lt;a href=&quot;assert#kotlin%24assert%28kotlin.Boolean%2C+kotlin.Function0%28%28kotlin.Any%29%29%29%2Fvalue&quot;&gt;value&lt;/a&gt; is false and runtime assertions have been enabled during compilation.</source>
          <target state="translated">如果&lt;a href=&quot;assert#kotlin%24assert%28kotlin.Boolean%2C+kotlin.Function0%28%28kotlin.Any%29%29%29%2Fvalue&quot;&gt;值为&lt;/a&gt; false且编译期间已启用运行时断言，则抛出由&lt;a href=&quot;assert#kotlin%24assert%28kotlin.Boolean%2C+kotlin.Function0%28%28kotlin.Any%29%29%29%2FlazyMessage&quot;&gt;lazyMessage&lt;/a&gt;计算的&lt;a href=&quot;-assertion-error/index#kotlin.AssertionError&quot;&gt;AssertionError&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="21712a0494f28f6a46c5535db142ea2522d8b30e" translate="yes" xml:space="preserve">
          <source>Throws an &lt;a href=&quot;-assertion-error/index#kotlin.AssertionError&quot;&gt;AssertionError&lt;/a&gt; calculated by &lt;a href=&quot;assert#kotlin%24assert%28kotlin.Boolean%2C+kotlin.Function0%28%28kotlin.Any%29%29%29%2FlazyMessage&quot;&gt;lazyMessage&lt;/a&gt; if the &lt;a href=&quot;assert#kotlin%24assert%28kotlin.Boolean%2C+kotlin.Function0%28%28kotlin.Any%29%29%29%2Fvalue&quot;&gt;value&lt;/a&gt; is false and runtime assertions have been enabled on the JVM using the &lt;em&gt;-ea&lt;/em&gt; JVM option.</source>
          <target state="translated">如果该&lt;a href=&quot;assert#kotlin%24assert%28kotlin.Boolean%2C+kotlin.Function0%28%28kotlin.Any%29%29%29%2Fvalue&quot;&gt;值为&lt;/a&gt; false且使用&lt;em&gt;-ea&lt;/em&gt; JVM选项在JVM上启用了运行时断言，则引发由&lt;a href=&quot;assert#kotlin%24assert%28kotlin.Boolean%2C+kotlin.Function0%28%28kotlin.Any%29%29%29%2FlazyMessage&quot;&gt;lazyMessage&lt;/a&gt;计算的&lt;a href=&quot;-assertion-error/index#kotlin.AssertionError&quot;&gt;AssertionError&lt;/a&gt;。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b187627b0474be6a63105d8fbe200f08b14f46f0" translate="yes" xml:space="preserve">
          <source>Throws an &lt;a href=&quot;-assertion-error/index#kotlin.AssertionError&quot;&gt;AssertionError&lt;/a&gt; if the &lt;a href=&quot;assert#kotlin%24assert%28kotlin.Boolean%29%2Fvalue&quot;&gt;value&lt;/a&gt; is false and runtime assertions have been enabled during compilation.</source>
          <target state="translated">如果该&lt;a href=&quot;assert#kotlin%24assert%28kotlin.Boolean%29%2Fvalue&quot;&gt;值为&lt;/a&gt; false且在编译期间已启用运行时断言，则引发&lt;a href=&quot;-assertion-error/index#kotlin.AssertionError&quot;&gt;AssertionError&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d8d5a9cbb5d90075a851ac67a508560060d907ea" translate="yes" xml:space="preserve">
          <source>Throws an &lt;a href=&quot;-assertion-error/index#kotlin.AssertionError&quot;&gt;AssertionError&lt;/a&gt; if the &lt;a href=&quot;assert#kotlin%24assert%28kotlin.Boolean%29%2Fvalue&quot;&gt;value&lt;/a&gt; is false and runtime assertions have been enabled on the JVM using the &lt;em&gt;-ea&lt;/em&gt; JVM option.</source>
          <target state="translated">如果该&lt;a href=&quot;assert#kotlin%24assert%28kotlin.Boolean%29%2Fvalue&quot;&gt;值为&lt;/a&gt; false且已使用&lt;em&gt;-ea&lt;/em&gt; JVM选项在JVM上启用了运行时断言，则引发&lt;a href=&quot;-assertion-error/index#kotlin.AssertionError&quot;&gt;AssertionError&lt;/a&gt;。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6495db8a536c8d755d3c31cd2f1405c6a5089dde" translate="yes" xml:space="preserve">
          <source>Throws an &lt;a href=&quot;-illegal-argument-exception/index#kotlin.IllegalArgumentException&quot;&gt;IllegalArgumentException&lt;/a&gt; if the &lt;a href=&quot;require#kotlin%24require%28kotlin.Boolean%29%2Fvalue&quot;&gt;value&lt;/a&gt; is false.</source>
          <target state="translated">如果&lt;a href=&quot;require#kotlin%24require%28kotlin.Boolean%29%2Fvalue&quot;&gt;值为&lt;/a&gt; false，则引发&lt;a href=&quot;-illegal-argument-exception/index#kotlin.IllegalArgumentException&quot;&gt;IllegalArgumentException&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="452d882ee13cc2478203bd62e2127715d9c6ce3d" translate="yes" xml:space="preserve">
          <source>Throws an &lt;a href=&quot;-illegal-argument-exception/index#kotlin.IllegalArgumentException&quot;&gt;IllegalArgumentException&lt;/a&gt; if the &lt;a href=&quot;require-not-null#kotlin%24requireNotNull%28kotlin.requireNotNull.T%29%2Fvalue&quot;&gt;value&lt;/a&gt; is null. Otherwise returns the not null value.</source>
          <target state="translated">如果该&lt;a href=&quot;require-not-null#kotlin%24requireNotNull%28kotlin.requireNotNull.T%29%2Fvalue&quot;&gt;值为&lt;/a&gt; null，则抛出&lt;a href=&quot;-illegal-argument-exception/index#kotlin.IllegalArgumentException&quot;&gt;IllegalArgumentException&lt;/a&gt;。否则，返回非null值。</target>
        </trans-unit>
        <trans-unit id="d30f2afa782c5c47e8fd1fd37da6b472b4245324" translate="yes" xml:space="preserve">
          <source>Throws an &lt;a href=&quot;-illegal-argument-exception/index#kotlin.IllegalArgumentException&quot;&gt;IllegalArgumentException&lt;/a&gt; with the result of calling &lt;a href=&quot;require#kotlin%24require%28kotlin.Boolean%2C+kotlin.Function0%28%28kotlin.Any%29%29%29%2FlazyMessage&quot;&gt;lazyMessage&lt;/a&gt; if the &lt;a href=&quot;require#kotlin%24require%28kotlin.Boolean%2C+kotlin.Function0%28%28kotlin.Any%29%29%29%2Fvalue&quot;&gt;value&lt;/a&gt; is false.</source>
          <target state="translated">如果该&lt;a href=&quot;require#kotlin%24require%28kotlin.Boolean%2C+kotlin.Function0%28%28kotlin.Any%29%29%29%2Fvalue&quot;&gt;值为&lt;/a&gt; false，则引发&lt;a href=&quot;-illegal-argument-exception/index#kotlin.IllegalArgumentException&quot;&gt;IllegalArgumentException&lt;/a&gt;并导致调用&lt;a href=&quot;require#kotlin%24require%28kotlin.Boolean%2C+kotlin.Function0%28%28kotlin.Any%29%29%29%2FlazyMessage&quot;&gt;lazyMessage&lt;/a&gt;的结果。</target>
        </trans-unit>
        <trans-unit id="e3e3dc9398319dc7d021d329ec499047c0ffa229" translate="yes" xml:space="preserve">
          <source>Throws an &lt;a href=&quot;-illegal-argument-exception/index#kotlin.IllegalArgumentException&quot;&gt;IllegalArgumentException&lt;/a&gt; with the result of calling &lt;a href=&quot;require-not-null#kotlin%24requireNotNull%28kotlin.requireNotNull.T%2C+kotlin.Function0%28%28kotlin.Any%29%29%29%2FlazyMessage&quot;&gt;lazyMessage&lt;/a&gt; if the &lt;a href=&quot;require-not-null#kotlin%24requireNotNull%28kotlin.requireNotNull.T%2C+kotlin.Function0%28%28kotlin.Any%29%29%29%2Fvalue&quot;&gt;value&lt;/a&gt; is null. Otherwise returns the not null value.</source>
          <target state="translated">如果该&lt;a href=&quot;require-not-null#kotlin%24requireNotNull%28kotlin.requireNotNull.T%2C+kotlin.Function0%28%28kotlin.Any%29%29%29%2Fvalue&quot;&gt;值为&lt;/a&gt; null，则抛出&lt;a href=&quot;-illegal-argument-exception/index#kotlin.IllegalArgumentException&quot;&gt;IllegalArgumentException&lt;/a&gt;并导致调用&lt;a href=&quot;require-not-null#kotlin%24requireNotNull%28kotlin.requireNotNull.T%2C+kotlin.Function0%28%28kotlin.Any%29%29%29%2FlazyMessage&quot;&gt;lazyMessage&lt;/a&gt;的结果。否则，返回非null值。</target>
        </trans-unit>
        <trans-unit id="cde80ff370e1f63acd5ebfbb8e922a017c83fe9e" translate="yes" xml:space="preserve">
          <source>Throws an &lt;a href=&quot;-illegal-state-exception/index#kotlin.IllegalStateException&quot;&gt;IllegalStateException&lt;/a&gt; if the &lt;a href=&quot;check#kotlin%24check%28kotlin.Boolean%29%2Fvalue&quot;&gt;value&lt;/a&gt; is false.</source>
          <target state="translated">如果&lt;a href=&quot;check#kotlin%24check%28kotlin.Boolean%29%2Fvalue&quot;&gt;值为&lt;/a&gt; false，则引发&lt;a href=&quot;-illegal-state-exception/index#kotlin.IllegalStateException&quot;&gt;IllegalStateException&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="402cd2d9df6a156fba6fc0cc6697b5d76b649c05" translate="yes" xml:space="preserve">
          <source>Throws an &lt;a href=&quot;-illegal-state-exception/index#kotlin.IllegalStateException&quot;&gt;IllegalStateException&lt;/a&gt; if the &lt;a href=&quot;check-not-null#kotlin%24checkNotNull%28kotlin.checkNotNull.T%29%2Fvalue&quot;&gt;value&lt;/a&gt; is null. Otherwise returns the not null value.</source>
          <target state="translated">如果该&lt;a href=&quot;check-not-null#kotlin%24checkNotNull%28kotlin.checkNotNull.T%29%2Fvalue&quot;&gt;值为&lt;/a&gt; null，则抛出&lt;a href=&quot;-illegal-state-exception/index#kotlin.IllegalStateException&quot;&gt;IllegalStateException&lt;/a&gt;。否则，返回非null值。</target>
        </trans-unit>
        <trans-unit id="7f113c02962407d7507fe9485b4da7237a47f7c4" translate="yes" xml:space="preserve">
          <source>Throws an &lt;a href=&quot;-illegal-state-exception/index#kotlin.IllegalStateException&quot;&gt;IllegalStateException&lt;/a&gt; with the given &lt;a href=&quot;error#kotlin%24error%28kotlin.Any%29%2Fmessage&quot;&gt;message&lt;/a&gt;.</source>
          <target state="translated">使用给定的&lt;a href=&quot;error#kotlin%24error%28kotlin.Any%29%2Fmessage&quot;&gt;消息&lt;/a&gt;引发&lt;a href=&quot;-illegal-state-exception/index#kotlin.IllegalStateException&quot;&gt;IllegalStateException&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a87a5cbfe4f8dd0bce93da8e99fc5031d54a4b66" translate="yes" xml:space="preserve">
          <source>Throws an &lt;a href=&quot;-illegal-state-exception/index#kotlin.IllegalStateException&quot;&gt;IllegalStateException&lt;/a&gt; with the result of calling &lt;a href=&quot;check#kotlin%24check%28kotlin.Boolean%2C+kotlin.Function0%28%28kotlin.Any%29%29%29%2FlazyMessage&quot;&gt;lazyMessage&lt;/a&gt; if the &lt;a href=&quot;check#kotlin%24check%28kotlin.Boolean%2C+kotlin.Function0%28%28kotlin.Any%29%29%29%2Fvalue&quot;&gt;value&lt;/a&gt; is false.</source>
          <target state="translated">如果&lt;a href=&quot;check#kotlin%24check%28kotlin.Boolean%2C+kotlin.Function0%28%28kotlin.Any%29%29%29%2Fvalue&quot;&gt;值为&lt;/a&gt; false，则引发&lt;a href=&quot;-illegal-state-exception/index#kotlin.IllegalStateException&quot;&gt;IllegalStateException&lt;/a&gt;并导致调用&lt;a href=&quot;check#kotlin%24check%28kotlin.Boolean%2C+kotlin.Function0%28%28kotlin.Any%29%29%29%2FlazyMessage&quot;&gt;lazyMessage&lt;/a&gt;的结果。</target>
        </trans-unit>
        <trans-unit id="a52512f1adf6d29a59645748fabb172d879e3685" translate="yes" xml:space="preserve">
          <source>Throws an &lt;a href=&quot;-illegal-state-exception/index#kotlin.IllegalStateException&quot;&gt;IllegalStateException&lt;/a&gt; with the result of calling &lt;a href=&quot;check-not-null#kotlin%24checkNotNull%28kotlin.checkNotNull.T%2C+kotlin.Function0%28%28kotlin.Any%29%29%29%2FlazyMessage&quot;&gt;lazyMessage&lt;/a&gt; if the &lt;a href=&quot;check-not-null#kotlin%24checkNotNull%28kotlin.checkNotNull.T%2C+kotlin.Function0%28%28kotlin.Any%29%29%29%2Fvalue&quot;&gt;value&lt;/a&gt; is null. Otherwise returns the not null value.</source>
          <target state="translated">如果该&lt;a href=&quot;check-not-null#kotlin%24checkNotNull%28kotlin.checkNotNull.T%2C+kotlin.Function0%28%28kotlin.Any%29%29%29%2Fvalue&quot;&gt;值为&lt;/a&gt; null，则抛出&lt;a href=&quot;-illegal-state-exception/index#kotlin.IllegalStateException&quot;&gt;IllegalStateException&lt;/a&gt;并导致调用&lt;a href=&quot;check-not-null#kotlin%24checkNotNull%28kotlin.checkNotNull.T%2C+kotlin.Function0%28%28kotlin.Any%29%29%29%2FlazyMessage&quot;&gt;lazyMessage&lt;/a&gt;的结果。否则，返回非null值。</target>
        </trans-unit>
        <trans-unit id="4fb093191144e508e969bd08f6b07ef13c7da6e0" translate="yes" xml:space="preserve">
          <source>Throws an exception if the sequence is constrained to be iterated once and &lt;code&gt;iterator&lt;/code&gt; is invoked the second time.</source>
          <target state="translated">如果将序列限制为一次迭代，并且第二次调用 &lt;code&gt;iterator&lt;/code&gt; 则抛出异常。</target>
        </trans-unit>
        <trans-unit id="802eb217aa06b1ddcf50385d8b88823ead2d004a" translate="yes" xml:space="preserve">
          <source>Throws an exception since enum constants cannot be cloned. This method prevents enum classes from inheriting from &lt;code&gt;Cloneable&lt;/code&gt;.</source>
          <target state="translated">由于无法克隆枚举常量，因此引发异常。此方法防止枚举类从 &lt;code&gt;Cloneable&lt;/code&gt; 继承。</target>
        </trans-unit>
        <trans-unit id="abf5b40e0b4f0a5382568a99833124d4e1e46035" translate="yes" xml:space="preserve">
          <source>Thus, if the layout filename is &lt;code&gt;activity_main.xml&lt;/code&gt;, we'd import &lt;code&gt;kotlinx.android.synthetic.main.activity_main.*&lt;/code&gt;.</source>
          <target state="translated">因此，如果布局文件名是 &lt;code&gt;activity_main.xml&lt;/code&gt; ，我们将导入 &lt;code&gt;kotlinx.android.synthetic.main.activity_main.*&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="97edcc8b1307ff786c44c31ec2579356e7a22d17" translate="yes" xml:space="preserve">
          <source>Thus, if you want an NPE, you can have it, but you have to ask for it explicitly, and it does not appear out of the blue.</source>
          <target state="translated">因此,如果你想要一个NPE,你可以拥有它,但你必须明确要求它,它不会突然出现。</target>
        </trans-unit>
        <trans-unit id="dd3fb291d3a706316d022aff145e9de544011b65" translate="yes" xml:space="preserve">
          <source>Thus, single quotes can not be used to form string literals.</source>
          <target state="translated">因此,不能用单引号来形成字符串字面。</target>
        </trans-unit>
        <trans-unit id="3018655a2f36aad6ef9ad9471b91d569410cec76" translate="yes" xml:space="preserve">
          <source>Thus, you can create something resource manager-like by creating a class that implements &lt;code&gt;Closeable&lt;/code&gt;, does its setup work in &lt;code&gt;init&lt;/code&gt;, and does its cleanup work in &lt;code&gt;close()&lt;/code&gt;.</source>
          <target state="translated">因此，您可以通过创建一个实现 &lt;code&gt;Closeable&lt;/code&gt; 的类，类似于 &lt;code&gt;init&lt;/code&gt; 的设置工作以及采用 &lt;code&gt;close()&lt;/code&gt; 的清理工作的类来创建类似于资源管理器的对象。</target>
        </trans-unit>
        <trans-unit id="6f717771b6bc333649ebdd74853decf5175f1649" translate="yes" xml:space="preserve">
          <source>Ticker channel is a special rendezvous channel that produces &lt;code&gt;Unit&lt;/code&gt; every time given delay passes since last consumption from this channel. Though it may seem to be useless standalone, it is a useful building block to create complex time-based &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/produce.html&quot;&gt;produce&lt;/a&gt; pipelines and operators that do windowing and other time-dependent processing. Ticker channel can be used in &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.selects/select.html&quot;&gt;select&lt;/a&gt; to perform &quot;on tick&quot; action.</source>
          <target state="translated">股票行情通道是一种特殊的会合通道，自从该通道的最后一次消费以来，每经过给定的延迟，就会生成 &lt;code&gt;Unit&lt;/code&gt; 。尽管它看起来似乎是无用的，但它是创建复杂的基于时间的&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/produce.html&quot;&gt;生产&lt;/a&gt;管道和执行加窗及其他与时间相关的处理的运算符的有用构建块。股票行情通道可用于&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.selects/select.html&quot;&gt;选择&lt;/a&gt;以执行&amp;ldquo; 股票行情&amp;rdquo;操作。</target>
        </trans-unit>
        <trans-unit id="709221186863e6ea184e824b11c1140ada1e2ad5" translate="yes" xml:space="preserve">
          <source>Ticker channels</source>
          <target state="translated">报价频道</target>
        </trans-unit>
        <trans-unit id="6e9104aba3fe18e4dd8562ba5f52cb92ded067dc" translate="yes" xml:space="preserve">
          <source>TimeRanges</source>
          <target state="translated">TimeRanges</target>
        </trans-unit>
        <trans-unit id="d4c45de0fe64ac43c72a798c67faaadadfaa1b90" translate="yes" xml:space="preserve">
          <source>Timeout</source>
          <target state="translated">Timeout</target>
        </trans-unit>
        <trans-unit id="799c2191675c2bb6c5c783e298421617f1390ce2" translate="yes" xml:space="preserve">
          <source>To &lt;a href=&quot;https://blog.jetbrains.com/kotlin/2017/01/kotlin-1-1-whats-coming-in-the-standard-library/&quot;&gt;prepare for Java 9 support&lt;/a&gt;, the extension functions and properties in the &lt;code&gt;kotlin-reflect.jar&lt;/code&gt; library have been moved to the package &lt;code&gt;kotlin.reflect.full&lt;/code&gt;. The names in the old package (&lt;code&gt;kotlin.reflect&lt;/code&gt;) are deprecated and will be removed in Kotlin 1.2. Note that the core reflection interfaces (such as &lt;code&gt;KClass&lt;/code&gt;) are part of the Kotlin standard library, not &lt;code&gt;kotlin-reflect&lt;/code&gt;, and are not affected by the move.</source>
          <target state="translated">为了&lt;a href=&quot;https://blog.jetbrains.com/kotlin/2017/01/kotlin-1-1-whats-coming-in-the-standard-library/&quot;&gt;准备对Java 9的支持&lt;/a&gt;， &lt;code&gt;kotlin-reflect.jar&lt;/code&gt; 库中的扩展功能和属性移到了package &lt;code&gt;kotlin.reflect.full&lt;/code&gt; 中。旧软件包（ &lt;code&gt;kotlin.reflect&lt;/code&gt; ）中的名称已弃用，并将在Kotlin 1.2中删除。请注意，核心反射接口（例如 &lt;code&gt;KClass&lt;/code&gt; ）是Kotlin标准库的一部分，而不是 &lt;code&gt;kotlin-reflect&lt;/code&gt; ，并且不受此移动的影响。</target>
        </trans-unit>
        <trans-unit id="05823a5d5a74d4953764cdf3ac4c6b3fb68f1e64" translate="yes" xml:space="preserve">
          <source>To Use</source>
          <target state="translated">使用方法</target>
        </trans-unit>
        <trans-unit id="9d9e0e01bc3681e891f7f867582c90865280f877" translate="yes" xml:space="preserve">
          <source>To accept and propagate the experimental status to your whole module, compile the module with the argument &lt;code&gt;-Xexperimental=org.mylibrary.ExperimentalMarker&lt;/code&gt;. In this case, &lt;em&gt;every declaration&lt;/em&gt; in the module becomes experimental. The use of the module requires the acceptance of its experimental status as well.</source>
          <target state="translated">要接受实验状态并将其传播到整个模块，请使用 &lt;code&gt;-Xexperimental=org.mylibrary.ExperimentalMarker&lt;/code&gt; 参数编译该模块。在这种情况下，模块中的&lt;em&gt;每个声明&lt;/em&gt;都将变为实验性的。使用该模块还需要接受其实验状态。</target>
        </trans-unit>
        <trans-unit id="c0b5cb313d227acb944e950971366b62de8d6de6" translate="yes" xml:space="preserve">
          <source>To accept the experimental status without propagation, compile the module with the argument &lt;code&gt;-Xuse-experimental&lt;/code&gt;, specifying the fully qualified name of the experimental API marker you use: &lt;code&gt;-Xuse-experimental=org.mylibrary.ExperimentalMarker&lt;/code&gt;. Compiling with this argument has the same effect as if every declaration in the module had the annotation&lt;code&gt;@UseExperimental(ExperimentalMarker::class)&lt;/code&gt;.</source>
          <target state="translated">要接受不传播的实验状态，请使用 &lt;code&gt;-Xuse-experimental&lt;/code&gt; 参数编译模块，并指定要使用的实验API标记的完全限定名称： &lt;code&gt;-Xuse-experimental=org.mylibrary.ExperimentalMarker&lt;/code&gt; 。使用此参数进行编译的效果与模块中的每个声明都具有注释 &lt;code&gt;@UseExperimental(ExperimentalMarker::class)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9903a558b00c4bc82f88c2dfad1d5c92c9e2ae3f" translate="yes" xml:space="preserve">
          <source>To accept the usage of multiple experimental APIs on the module level, add one of the described arguments for each experimental API marker used in your module.</source>
          <target state="translated">要在模块级别上接受多个实验性API的使用,请为您的模块中使用的每个实验性API标记添加所述参数之一。</target>
        </trans-unit>
        <trans-unit id="d162c0174f5af87401e6b5d45d66155192832d80" translate="yes" xml:space="preserve">
          <source>To access &lt;em&gt;this&lt;/em&gt; from an outer scope (a &lt;a href=&quot;classes&quot;&gt;class&lt;/a&gt;, or &lt;a href=&quot;extensions&quot;&gt;extension function&lt;/a&gt;, or labeled &lt;a href=&quot;lambdas#function-literals-with-receiver&quot;&gt;function literal with receiver&lt;/a&gt;) we write &lt;code&gt;this@label&lt;/code&gt; where &lt;code&gt;@label&lt;/code&gt; is a &lt;a href=&quot;returns&quot;&gt;label&lt;/a&gt; on the scope &lt;em&gt;this&lt;/em&gt; is meant to be from:</source>
          <target state="translated">要访问&lt;em&gt;这个&lt;/em&gt;外部范围（一&lt;a href=&quot;classes&quot;&gt;类&lt;/a&gt;，或&lt;a href=&quot;extensions&quot;&gt;扩展功能&lt;/a&gt;，或标记&lt;a href=&quot;lambdas#function-literals-with-receiver&quot;&gt;与接收机功能字面&lt;/a&gt;）我们写 &lt;code&gt;this@label&lt;/code&gt; 其中 &lt;code&gt;@label&lt;/code&gt; 是一个&lt;a href=&quot;returns&quot;&gt;标签&lt;/a&gt;上的范围&lt;em&gt;这&lt;/em&gt;意味着是从：</target>
        </trans-unit>
        <trans-unit id="5db6557812d02b15eefb7397c674770717b897fd" translate="yes" xml:space="preserve">
          <source>To access a property that is a member of a class, we qualify it:</source>
          <target state="translated">要访问一个属于类的成员的属性,我们对其进行限定。</target>
        </trans-unit>
        <trans-unit id="81410d36157afd9871ba5225faca2642fb141190" translate="yes" xml:space="preserve">
          <source>To access properties as first-class objects in Kotlin, we can also use the &lt;code&gt;::&lt;/code&gt; operator:</source>
          <target state="translated">要将属性作为Kotlin中的一流对象进行访问，我们还可以使用 &lt;code&gt;::&lt;/code&gt; 运算符：</target>
        </trans-unit>
        <trans-unit id="58a760c627562db97cdca1a84e7db3c27c2f629c" translate="yes" xml:space="preserve">
          <source>To access static members of a Java type that is &lt;a href=&quot;#mapped-types&quot;&gt;mapped&lt;/a&gt; to a Kotlin type, use the full qualified name of the Java type: &lt;code&gt;java.lang.Integer.bitCount(foo)&lt;/code&gt;.</source>
          <target state="translated">要访问&lt;a href=&quot;#mapped-types&quot;&gt;映射&lt;/a&gt;到Kotlin类型的Java类型的静态成员，请使用Java类型的全限定名称： &lt;code&gt;java.lang.Integer.bitCount(foo)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7529d2d95d23cbd6b23debe45e1e3095efe982cc" translate="yes" xml:space="preserve">
          <source>To achieve &lt;code&gt;mutable XOR global&lt;/code&gt; invariant, all globally visible state (currently, &lt;code&gt;object&lt;/code&gt; singletons and enums) are automatically frozen. If object freezing is not desired, a &lt;code&gt;kotlin.native.ThreadLocal&lt;/code&gt; annotation can be used, which will make the object state thread local, and so, mutable (but the changed state is not visible to other threads).</source>
          <target state="translated">为了实现 &lt;code&gt;mutable XOR global&lt;/code&gt; 不变性，所有全局可见状态（当前是 &lt;code&gt;object&lt;/code&gt; 单例和枚举）都将自动冻结。如果不需要冻结对象，则可以使用 &lt;code&gt;kotlin.native.ThreadLocal&lt;/code&gt; 批注，这将使对象状态线程处于局部状态，因此是可变的（但更改后的状态对其他线程不可见）。</target>
        </trans-unit>
        <trans-unit id="1019a589281c0c646b20946b4cd19b5c15e8fdaa" translate="yes" xml:space="preserve">
          <source>To activate DCE tool, add the following line to &lt;code&gt;build.gradle&lt;/code&gt;:</source>
          <target state="translated">要激活DCE工具，请将以下行添加到 &lt;code&gt;build.gradle&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="a7881622441c034d7bab9ec188cf250853bf301a" translate="yes" xml:space="preserve">
          <source>To add a dependency to a source set, use a &lt;code&gt;dependencies { ... }&lt;/code&gt; block of the source sets DSL. Four kinds of dependencies are supported:</source>
          <target state="translated">要向源集添加依赖项，请使用源集DSL 的 &lt;code&gt;dependencies { ... }&lt;/code&gt; 块。支持四种依赖项：</target>
        </trans-unit>
        <trans-unit id="1a499912e7035afeaf92f7261767aa556ac8c3f9" translate="yes" xml:space="preserve">
          <source>To add a new key-value pair to a mutable map, use &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-mutable-map/put&quot;&gt;&lt;code&gt;put()&lt;/code&gt;&lt;/a&gt;. When a new entry is put into a &lt;code&gt;LinkedHashMap&lt;/code&gt; (the default map implementation), it is added so that it comes last when iterating the map. In sorted maps, the positions of new elements are defined by the order of their keys.</source>
          <target state="translated">要将新的键值对添加到可变映射，请使用&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-mutable-map/put&quot;&gt; &lt;code&gt;put()&lt;/code&gt; &lt;/a&gt;。将新条目放入 &lt;code&gt;LinkedHashMap&lt;/code&gt; （默认地图实现）后，会添加该条目，以便在迭代地图时排在最后。在排序的地图中，新元素的位置由其键顺序定义。</target>
        </trans-unit>
        <trans-unit id="f2454f68b2510146a6d3830da5c71ddda2db8b87" translate="yes" xml:space="preserve">
          <source>To add a single element to a list or a set, use the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-mutable-list/add&quot;&gt;&lt;code&gt;add()&lt;/code&gt;&lt;/a&gt; function. The specified object is appended to the end of the collection.</source>
          <target state="translated">要将单个元素添加到列表或集合，请使用&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-mutable-list/add&quot;&gt; &lt;code&gt;add()&lt;/code&gt; &lt;/a&gt;函数。指定的对象将追加到集合的末尾。</target>
        </trans-unit>
        <trans-unit id="7cc1110c5b9a5333f0f0fec5eb2e00b218df46d2" translate="yes" xml:space="preserve">
          <source>To add elements to a specific position in a list, use &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-mutable-list/add&quot;&gt;&lt;code&gt;add()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/add-all&quot;&gt;&lt;code&gt;addAll()&lt;/code&gt;&lt;/a&gt; providing the position for element insertion as an additional argument. All elements that come after the position shift to the right.</source>
          <target state="translated">要将元素添加到列表中的特定位置，请使用&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-mutable-list/add&quot;&gt; &lt;code&gt;add()&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/add-all&quot;&gt; &lt;code&gt;addAll()&lt;/code&gt; &lt;/a&gt;提供元素插入的位置作为附加参数。位置之后的所有元素都向右移动。</target>
        </trans-unit>
        <trans-unit id="8035a3b6b37b3480851f2821e2b47d2393940de4" translate="yes" xml:space="preserve">
          <source>To add multiple entries at a time, use &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/put-all&quot;&gt;&lt;code&gt;putAll()&lt;/code&gt;&lt;/a&gt;. Its argument can be a &lt;code&gt;Map&lt;/code&gt; or a group of &lt;code&gt;Pair&lt;/code&gt;s: &lt;code&gt;Iterable&lt;/code&gt;, &lt;code&gt;Sequence&lt;/code&gt;, or &lt;code&gt;Array&lt;/code&gt;.</source>
          <target state="translated">要一次添加多个条目，请使用&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/put-all&quot;&gt; &lt;code&gt;putAll()&lt;/code&gt; &lt;/a&gt;。它的参数可以是 &lt;code&gt;Map&lt;/code&gt; 或 &lt;code&gt;Pair&lt;/code&gt; 的组： &lt;code&gt;Iterable&lt;/code&gt; ， &lt;code&gt;Sequence&lt;/code&gt; 或 &lt;code&gt;Array&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6aac6c02c5c8182c376328758ec65c08ad1e19d6" translate="yes" xml:space="preserve">
          <source>To add the Kotlin support to your Eclipse IDE, install the &lt;em&gt;Kotlin Plugin for Eclipse&lt;/em&gt;. We recommend installing the Kotlin plugin from &lt;a href=&quot;http://marketplace.eclipse.org/content/kotlin-plugin-eclipse&quot;&gt;Eclipse Marketplace&lt;/a&gt;. One option is to drag this button into a running Eclipse window:</source>
          <target state="translated">要将Kotlin支持添加到您的Eclipse IDE中，请安装&lt;em&gt;Kotlin Plugin for Eclipse&lt;/em&gt;。我们建议从&lt;a href=&quot;http://marketplace.eclipse.org/content/kotlin-plugin-eclipse&quot;&gt;Eclipse Marketplace&lt;/a&gt;安装Kotlin插件。一种选择是将此按钮拖动到正在运行的Eclipse窗口中：</target>
        </trans-unit>
        <trans-unit id="11458a551629eb8e637b1b4f455d800a9c36a1f1" translate="yes" xml:space="preserve">
          <source>To address this problem, in Kotlin 1.1 a special mechanism to control receiver scope was introduced.</source>
          <target state="translated">为了解决这个问题,在Kotlin 1.1中引入了一种特殊的机制来控制接收器的范围。</target>
        </trans-unit>
        <trans-unit id="93364070d4707402d500a207978499a9a901b72c" translate="yes" xml:space="preserve">
          <source>To allow nulls, we can declare a variable as nullable string, written &lt;code&gt;String?&lt;/code&gt;:</source>
          <target state="translated">为了允许空值，我们可以将变量声明为可空字符串，写成 &lt;code&gt;String?&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="f2b28f33c9dfafdc6b47099300c488e134702926" translate="yes" xml:space="preserve">
          <source>To annotate the receiver parameter of an extension function, use the following syntax:</source>
          <target state="translated">要对扩展函数的接收器参数进行注释,请使用以下语法。</target>
        </trans-unit>
        <trans-unit id="27d0b2adae39bd08addf9e085ed30cd88ae2eee6" translate="yes" xml:space="preserve">
          <source>To apply a function to elements in the reverse order, use functions &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/reduce-right&quot;&gt;&lt;code&gt;reduceRight()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/fold-right&quot;&gt;&lt;code&gt;foldRight()&lt;/code&gt;&lt;/a&gt;. They work in a way similar to &lt;code&gt;fold()&lt;/code&gt; and &lt;code&gt;reduce()&lt;/code&gt; but start from the last element and then continue to previous. Note that when folding or reducing right, the operation arguments change their order: first goes the element, and then the accumulated value.</source>
          <target state="translated">要将函数以相反的顺序应用于元素，请使用函数&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/reduce-right&quot;&gt; &lt;code&gt;reduceRight()&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/fold-right&quot;&gt; &lt;code&gt;foldRight()&lt;/code&gt; &lt;/a&gt;。它们的工作方式类似于 &lt;code&gt;fold()&lt;/code&gt; 和 &lt;code&gt;reduce()&lt;/code&gt; ,但从最后一个元素开始，然后再继续到上一个。请注意，在折叠或右移时，操作参数会更改其顺序：首先移至元素，然后移至累加值。</target>
        </trans-unit>
        <trans-unit id="2a59cafd76f62ee4d0be26a47e36b2b9add63e94" translate="yes" xml:space="preserve">
          <source>To apply the &lt;code&gt;kotlin-multiplatform&lt;/code&gt; plugin, just add the following snippet into your build script:</source>
          <target state="translated">要应用 &lt;code&gt;kotlin-multiplatform&lt;/code&gt; 插件，只需将以下代码段添加到您的构建脚本中：</target>
        </trans-unit>
        <trans-unit id="93d5ab42155015ed266c58696481bdeab9ce4844" translate="yes" xml:space="preserve">
          <source>To avoid ambiguous results when strings in &lt;a href=&quot;find-any-of#kotlin.text%24findAnyOf%28kotlin.CharSequence%2C+kotlin.collections.Collection%28%28kotlin.String%29%29%2C+kotlin.Int%2C+kotlin.Boolean%29%2Fstrings&quot;&gt;strings&lt;/a&gt; have characters in common, this method proceeds from the beginning to the end of this string, and finds at each position the first element in &lt;a href=&quot;find-any-of#kotlin.text%24findAnyOf%28kotlin.CharSequence%2C+kotlin.collections.Collection%28%28kotlin.String%29%29%2C+kotlin.Int%2C+kotlin.Boolean%29%2Fstrings&quot;&gt;strings&lt;/a&gt; that matches this string at that position.</source>
          <target state="translated">为了避免模棱两可的结果时在字符串&lt;a href=&quot;find-any-of#kotlin.text%24findAnyOf%28kotlin.CharSequence%2C+kotlin.collections.Collection%28%28kotlin.String%29%29%2C+kotlin.Int%2C+kotlin.Boolean%29%2Fstrings&quot;&gt;的字符串&lt;/a&gt;在共同拥有的字符，该方法从一开始就进行到这个字符串的末尾，发现在每个位置中的第一个元素&lt;a href=&quot;find-any-of#kotlin.text%24findAnyOf%28kotlin.CharSequence%2C+kotlin.collections.Collection%28%28kotlin.String%29%29%2C+kotlin.Int%2C+kotlin.Boolean%29%2Fstrings&quot;&gt;的字符串&lt;/a&gt;，该字符串在该位置相匹配。</target>
        </trans-unit>
        <trans-unit id="d0112a7d95b0f1e5eac2132ba1ef497e36b55c4f" translate="yes" xml:space="preserve">
          <source>To avoid ambiguous results when strings in &lt;a href=&quot;find-last-any-of#kotlin.text%24findLastAnyOf%28kotlin.CharSequence%2C+kotlin.collections.Collection%28%28kotlin.String%29%29%2C+kotlin.Int%2C+kotlin.Boolean%29%2Fstrings&quot;&gt;strings&lt;/a&gt; have characters in common, this method proceeds from the end toward the beginning of this string, and finds at each position the first element in &lt;a href=&quot;find-last-any-of#kotlin.text%24findLastAnyOf%28kotlin.CharSequence%2C+kotlin.collections.Collection%28%28kotlin.String%29%29%2C+kotlin.Int%2C+kotlin.Boolean%29%2Fstrings&quot;&gt;strings&lt;/a&gt; that matches this string at that position.</source>
          <target state="translated">为了避免模棱两可的结果时在字符串&lt;a href=&quot;find-last-any-of#kotlin.text%24findLastAnyOf%28kotlin.CharSequence%2C+kotlin.collections.Collection%28%28kotlin.String%29%29%2C+kotlin.Int%2C+kotlin.Boolean%29%2Fstrings&quot;&gt;的字符串&lt;/a&gt;在共同拥有的字符，该方法从朝着这个字符串的开始端部进行，发现在每个位置中的第一个元素&lt;a href=&quot;find-last-any-of#kotlin.text%24findLastAnyOf%28kotlin.CharSequence%2C+kotlin.collections.Collection%28%28kotlin.String%29%29%2C+kotlin.Int%2C+kotlin.Boolean%29%2Fstrings&quot;&gt;的字符串&lt;/a&gt;，该字符串在该位置相匹配。</target>
        </trans-unit>
        <trans-unit id="4027c8136b6286dfe349c3bde29fd950bfe158c1" translate="yes" xml:space="preserve">
          <source>To avoid ambiguous results when strings in &lt;a href=&quot;index-of-any#kotlin.text%24indexOfAny%28kotlin.CharSequence%2C+kotlin.collections.Collection%28%28kotlin.String%29%29%2C+kotlin.Int%2C+kotlin.Boolean%29%2Fstrings&quot;&gt;strings&lt;/a&gt; have characters in common, this method proceeds from the beginning to the end of this string, and finds at each position the first element in &lt;a href=&quot;index-of-any#kotlin.text%24indexOfAny%28kotlin.CharSequence%2C+kotlin.collections.Collection%28%28kotlin.String%29%29%2C+kotlin.Int%2C+kotlin.Boolean%29%2Fstrings&quot;&gt;strings&lt;/a&gt; that matches this string at that position.</source>
          <target state="translated">为了避免模棱两可的结果时在字符串&lt;a href=&quot;index-of-any#kotlin.text%24indexOfAny%28kotlin.CharSequence%2C+kotlin.collections.Collection%28%28kotlin.String%29%29%2C+kotlin.Int%2C+kotlin.Boolean%29%2Fstrings&quot;&gt;的字符串&lt;/a&gt;在共同拥有的字符，该方法从一开始就进行到这个字符串的末尾，发现在每个位置中的第一个元素&lt;a href=&quot;index-of-any#kotlin.text%24indexOfAny%28kotlin.CharSequence%2C+kotlin.collections.Collection%28%28kotlin.String%29%29%2C+kotlin.Int%2C+kotlin.Boolean%29%2Fstrings&quot;&gt;的字符串&lt;/a&gt;，该字符串在该位置相匹配。</target>
        </trans-unit>
        <trans-unit id="31bfe127214639414101a9ca7c2a589e0f9d8655" translate="yes" xml:space="preserve">
          <source>To avoid ambiguous results when strings in &lt;a href=&quot;last-index-of-any#kotlin.text%24lastIndexOfAny%28kotlin.CharSequence%2C+kotlin.collections.Collection%28%28kotlin.String%29%29%2C+kotlin.Int%2C+kotlin.Boolean%29%2Fstrings&quot;&gt;strings&lt;/a&gt; have characters in common, this method proceeds from the end toward the beginning of this string, and finds at each position the first element in &lt;a href=&quot;last-index-of-any#kotlin.text%24lastIndexOfAny%28kotlin.CharSequence%2C+kotlin.collections.Collection%28%28kotlin.String%29%29%2C+kotlin.Int%2C+kotlin.Boolean%29%2Fstrings&quot;&gt;strings&lt;/a&gt; that matches this string at that position.</source>
          <target state="translated">为了避免模棱两可的结果时在字符串&lt;a href=&quot;last-index-of-any#kotlin.text%24lastIndexOfAny%28kotlin.CharSequence%2C+kotlin.collections.Collection%28%28kotlin.String%29%29%2C+kotlin.Int%2C+kotlin.Boolean%29%2Fstrings&quot;&gt;的字符串&lt;/a&gt;在共同拥有的字符，该方法从朝着这个字符串的开始端部进行，发现在每个位置中的第一个元素&lt;a href=&quot;last-index-of-any#kotlin.text%24lastIndexOfAny%28kotlin.CharSequence%2C+kotlin.collections.Collection%28%28kotlin.String%29%29%2C+kotlin.Int%2C+kotlin.Boolean%29%2Fstrings&quot;&gt;的字符串&lt;/a&gt;，该字符串在该位置相匹配。</target>
        </trans-unit>
        <trans-unit id="6276ae19b8071911e89a3dcb94d020bccd844c9c" translate="yes" xml:space="preserve">
          <source>To avoid ambiguous results when strings in &lt;a href=&quot;split#kotlin.text%24split%28kotlin.CharSequence%2C+kotlin.Array%28%28kotlin.String%29%29%2C+kotlin.Boolean%2C+kotlin.Int%29%2Fdelimiters&quot;&gt;delimiters&lt;/a&gt; have characters in common, this method proceeds from the beginning to the end of this string, and matches at each position the first element in &lt;a href=&quot;split#kotlin.text%24split%28kotlin.CharSequence%2C+kotlin.Array%28%28kotlin.String%29%29%2C+kotlin.Boolean%2C+kotlin.Int%29%2Fdelimiters&quot;&gt;delimiters&lt;/a&gt; that is equal to a delimiter in this instance at that position.</source>
          <target state="translated">为了避免在&lt;a href=&quot;split#kotlin.text%24split%28kotlin.CharSequence%2C+kotlin.Array%28%28kotlin.String%29%29%2C+kotlin.Boolean%2C+kotlin.Int%29%2Fdelimiters&quot;&gt;定界符中的&lt;/a&gt;字符串具有共同的字符时导致模棱两可的结果，此方法从该字符串的开头到末尾进行，并在每个位置处匹配&lt;a href=&quot;split#kotlin.text%24split%28kotlin.CharSequence%2C+kotlin.Array%28%28kotlin.String%29%29%2C+kotlin.Boolean%2C+kotlin.Int%29%2Fdelimiters&quot;&gt;定界符&lt;/a&gt;中的第一个元素，该元素在此位置处等于该定界符。</target>
        </trans-unit>
        <trans-unit id="35cbc5daa3fa4744579892d02b514b4f1f8fe190" translate="yes" xml:space="preserve">
          <source>To avoid ambiguous results when strings in &lt;a href=&quot;split-to-sequence#kotlin.text%24splitToSequence%28kotlin.CharSequence%2C+kotlin.Array%28%28kotlin.String%29%29%2C+kotlin.Boolean%2C+kotlin.Int%29%2Fdelimiters&quot;&gt;delimiters&lt;/a&gt; have characters in common, this method proceeds from the beginning to the end of this string, and finds at each position the first element in &lt;a href=&quot;split-to-sequence#kotlin.text%24splitToSequence%28kotlin.CharSequence%2C+kotlin.Array%28%28kotlin.String%29%29%2C+kotlin.Boolean%2C+kotlin.Int%29%2Fdelimiters&quot;&gt;delimiters&lt;/a&gt; that matches this string at that position.</source>
          <target state="translated">为了避免在&lt;a href=&quot;split-to-sequence#kotlin.text%24splitToSequence%28kotlin.CharSequence%2C+kotlin.Array%28%28kotlin.String%29%29%2C+kotlin.Boolean%2C+kotlin.Int%29%2Fdelimiters&quot;&gt;定界符中的&lt;/a&gt;字符串具有共同字符时导致模棱两可的结果，此方法从该字符串的开头到结尾进行处理，并在每个位置处找到与该字符串匹配的&lt;a href=&quot;split-to-sequence#kotlin.text%24splitToSequence%28kotlin.CharSequence%2C+kotlin.Array%28%28kotlin.String%29%29%2C+kotlin.Boolean%2C+kotlin.Int%29%2Fdelimiters&quot;&gt;定界符&lt;/a&gt;中的第一个元素。</target>
        </trans-unit>
        <trans-unit id="4098083aa9fa1edbe4454946791bd3716c2341fe" translate="yes" xml:space="preserve">
          <source>To avoid an exception being thrown, one can use a &lt;em&gt;safe&lt;/em&gt; cast operator &lt;em&gt;as?&lt;/em&gt; that returns &lt;em&gt;null&lt;/em&gt; on failure:</source>
          <target state="translated">为了避免引发异常，可以使用&lt;em&gt;安全的&lt;/em&gt;强制转换运算符&lt;em&gt;作为？&lt;/em&gt;失败时返回&lt;em&gt;null&lt;/em&gt;：</target>
        </trans-unit>
        <trans-unit id="9e17e4153a46063a7e951557055076fb55b29173" translate="yes" xml:space="preserve">
          <source>To avoid exceptions when retrieving element with non-existing positions, use safe variations of &lt;code&gt;elementAt()&lt;/code&gt;:</source>
          <target state="translated">为了避免在检索位置不存在的元素时出现异常，请使用 &lt;code&gt;elementAt()&lt;/code&gt; 的安全变体：</target>
        </trans-unit>
        <trans-unit id="7274268313d792eeb0ea9bf91f3d9337f0c66bb3" translate="yes" xml:space="preserve">
          <source>To avoid unchecked casts, you can redesign the program structure: in the example above, there could be interfaces &lt;code&gt;DictionaryReader&amp;lt;T&amp;gt;&lt;/code&gt; and &lt;code&gt;DictionaryWriter&amp;lt;T&amp;gt;&lt;/code&gt; with type-safe implementations for different types. You can introduce reasonable abstractions to move unchecked casts from calling code to the implementation details. Proper use of &lt;a href=&quot;generics#variance&quot;&gt;generic variance&lt;/a&gt; can also help.</source>
          <target state="translated">为了避免无限制的强制转换，您可以重新设计程序结构：在上面的示例中，可能存在 &lt;code&gt;DictionaryReader&amp;lt;T&amp;gt;&lt;/code&gt; 和 &lt;code&gt;DictionaryWriter&amp;lt;T&amp;gt;&lt;/code&gt; 接口，它们具有针对不同类型的类型安全的实现。您可以引入合理的抽象，以将未经检查的强制转换从调用代码移至实现细节。正确使用&lt;a href=&quot;generics#variance&quot;&gt;通用方差&lt;/a&gt;也可以有所帮助。</target>
        </trans-unit>
        <trans-unit id="86fda07e220a1d9d0906bbd1a8bf6f784d8a05be" translate="yes" xml:space="preserve">
          <source>To be eligible for the &lt;code&gt;tailrec&lt;/code&gt; modifier, a function must call itself as the last operation it performs. You cannot use tail recursion when there is more code after the recursive call, and you cannot use it within try/catch/finally blocks. Currently tail recursion is only supported in the JVM backend.</source>
          <target state="translated">为了有资格使用 &lt;code&gt;tailrec&lt;/code&gt; 修饰符，函数必须将自身作为执行的最后一个操作进行调用。如果在递归调用之后有更多代码，则不能使用尾递归，也不能在try / catch / finally块中使用它。当前，仅JVM后端支持尾部递归。</target>
        </trans-unit>
        <trans-unit id="e77c612cc0ad3329a96be3d4bc330a4270facd79" translate="yes" xml:space="preserve">
          <source>To be fair, you'd get the same output in Python, but the mechanism would be different: both instances would start out without any attributes of their own (&lt;code&gt;age&lt;/code&gt; and &lt;code&gt;name&lt;/code&gt; would be attributes on the class), and the first printing would access the class attribute; only the assignment would cause an &lt;code&gt;age&lt;/code&gt; attribute to appear on &lt;code&gt;a&lt;/code&gt;. In Kotlin, there are no class properties in this example, and each instance starts out with both properties. If you need a class-level property, see the section on &lt;a href=&quot;objects-and-companion-objects#companion-objects&quot;&gt;companion objects&lt;/a&gt;.</source>
          <target state="translated">公平地说，您将在Python中获得相同的输出，但是机制会有所不同：两个实例开始时都没有它们自己的任何属性（ &lt;code&gt;age&lt;/code&gt; 和 &lt;code&gt;name&lt;/code&gt; 将是类的属性），并且第一个打印将访问class属性；只有分配会导致 &lt;code&gt;age&lt;/code&gt; 属性出现在 &lt;code&gt;a&lt;/code&gt; 。在Kotlin中，此示例中没有类属性，并且每个实例都从这两个属性开始。如果您需要一个类级别的属性，请参见关于&lt;a href=&quot;objects-and-companion-objects#companion-objects&quot;&gt;伴随对象&lt;/a&gt;的部分。</target>
        </trans-unit>
        <trans-unit id="d5cad0364e908d8aa1ff84ca1d9136f4ad0e8a7e" translate="yes" xml:space="preserve">
          <source>To break a collection onto parts of a given size, use the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/chunked&quot;&gt;&lt;code&gt;chunked()&lt;/code&gt;&lt;/a&gt; function. &lt;code&gt;chunked()&lt;/code&gt; takes a single argument &amp;ndash; the size of the chunk &amp;ndash; and returns a &lt;code&gt;List&lt;/code&gt; of &lt;code&gt;List&lt;/code&gt;s of the given size. The first chunk starts from the first element and contains the &lt;code&gt;size&lt;/code&gt; elements, the second chunk holds the next &lt;code&gt;size&lt;/code&gt; elements, and so on. The last chunk may have a smaller size.</source>
          <target state="translated">要将集合分解为给定大小的部分，请使用&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/chunked&quot;&gt; &lt;code&gt;chunked()&lt;/code&gt; &lt;/a&gt;函数。 &lt;code&gt;chunked()&lt;/code&gt; 接受一个参数&amp;ndash;块的大小&amp;ndash;并返回给定大小的 &lt;code&gt;List&lt;/code&gt; 的 &lt;code&gt;List&lt;/code&gt; 。第一个块从第一个元素开始，包含 &lt;code&gt;size&lt;/code&gt; 元素，第二个块包含下一个 &lt;code&gt;size&lt;/code&gt; 元素，依此类推。最后一块可以具有较小的尺寸。</target>
        </trans-unit>
        <trans-unit id="c901a4737d7c3f04fc344e06625faf76eec8e9d6" translate="yes" xml:space="preserve">
          <source>To build a custom string representation, you can specify its parameters in function arguments &lt;code&gt;separator&lt;/code&gt;, &lt;code&gt;prefix&lt;/code&gt;, and &lt;code&gt;postfix&lt;/code&gt;. The resulting string will start with the &lt;code&gt;prefix&lt;/code&gt; and end with the &lt;code&gt;postfix&lt;/code&gt;. The &lt;code&gt;separator&lt;/code&gt; will come after each element except the last.</source>
          <target state="translated">要构建自定义字符串表示形式，您可以在函数参数 &lt;code&gt;separator&lt;/code&gt; ， &lt;code&gt;prefix&lt;/code&gt; 和 &lt;code&gt;postfix&lt;/code&gt; 指定其参数。结果字符串将以 &lt;code&gt;prefix&lt;/code&gt; 开头，并以 &lt;code&gt;postfix&lt;/code&gt; 结尾。该 &lt;code&gt;separator&lt;/code&gt; 会除了最后的两个元素。</target>
        </trans-unit>
        <trans-unit id="2719279869fab416ee4cd752ab3460ef98055407" translate="yes" xml:space="preserve">
          <source>To build and run your application on an emulator:</source>
          <target state="translated">要在模拟器上构建和运行你的应用程序。</target>
        </trans-unit>
        <trans-unit id="7150222f1a1fb391342d63f455f2076e7800770e" translate="yes" xml:space="preserve">
          <source>To build two-element windows, there is a separate function - &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/zip-with-next&quot;&gt;&lt;code&gt;zipWithNext()&lt;/code&gt;&lt;/a&gt;. It creates pairs of adjacent elements of the receiver collection. Note that &lt;code&gt;zipWithNext()&lt;/code&gt; doesn't break the collection into pairs; it creates a &lt;code&gt;Pair&lt;/code&gt; for &lt;em&gt;each&lt;/em&gt; element except the last one, so its result on &lt;code&gt;[1, 2, 3, 4]&lt;/code&gt; is &lt;code&gt;[[1, 2], [2, 3], [3, 4]]&lt;/code&gt;, not &lt;code&gt;[[1, 2&lt;/code&gt;], &lt;code&gt;[3, 4]]&lt;/code&gt;. &lt;code&gt;zipWithNext()&lt;/code&gt; can be called with a transformation function as well; it should take two elements of the receiver collection as arguments.</source>
          <target state="translated">要构建两个元素的窗口，有一个单独的函数&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/zip-with-next&quot;&gt; &lt;code&gt;zipWithNext()&lt;/code&gt; &lt;/a&gt;。它创建接收器集合的成对相邻元素。请注意， &lt;code&gt;zipWithNext()&lt;/code&gt; 不会将集合分成几对；它为除最后一个元素之外的&lt;em&gt;每个&lt;/em&gt;元素创建一个 &lt;code&gt;Pair&lt;/code&gt; ，因此其在 &lt;code&gt;[1, 2, 3, 4]&lt;/code&gt; 为 &lt;code&gt;[[1, 2], [2, 3], [3, 4]]&lt;/code&gt; ，而不是 &lt;code&gt;[[1, 2&lt;/code&gt; ]， &lt;code&gt;[3, 4]]&lt;/code&gt; 。 &lt;code&gt;zipWithNext()&lt;/code&gt; 也可以通过转换函数来调用；它应该以接收者集合的两个元素作为参数。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="8c83a6b42d390ab9398eaec7a8e407e01581218b" translate="yes" xml:space="preserve">
          <source>To call &lt;code&gt;fold&lt;/code&gt;, we need to pass it an &lt;a href=&quot;#instantiating-a-function-type&quot;&gt;instance of the function type&lt;/a&gt; as an argument, and lambda expressions (&lt;a href=&quot;#lambda-expressions-and-anonymous-functions&quot;&gt;described in more detail below&lt;/a&gt;) are widely used for this purpose at higher-order function call sites:</source>
          <target state="translated">要调用 &lt;code&gt;fold&lt;/code&gt; ，我们需要&lt;a href=&quot;#instantiating-a-function-type&quot;&gt;将函数类型的&lt;/a&gt;一个实例作为参数传递给它，并且lambda表达式（&lt;a href=&quot;#lambda-expressions-and-anonymous-functions&quot;&gt;在下面进行更详细的描述&lt;/a&gt;）为此在高阶函数调用站点中广泛使用：</target>
        </trans-unit>
        <trans-unit id="6580f39324c16c3fdd14fd9204c4e7b2dbc24353" translate="yes" xml:space="preserve">
          <source>To call a generic function, specify the type arguments at the call site &lt;strong&gt;after&lt;/strong&gt; the name of the function:</source>
          <target state="translated">要调用通用函数，请在函数名称&lt;strong&gt;后&lt;/strong&gt;的调用站点上指定类型参数：</target>
        </trans-unit>
        <trans-unit id="567fc2cf862c0915604df53cff04863a317488f7" translate="yes" xml:space="preserve">
          <source>To catch an exception, use the &lt;em&gt;try&lt;/em&gt;-expression:</source>
          <target state="translated">要捕获异常，请使用&lt;em&gt;try&lt;/em&gt; -expression：</target>
        </trans-unit>
        <trans-unit id="f8d7572362421bb5d6d9129ee1f644a5743bf60f" translate="yes" xml:space="preserve">
          <source>To change the names of generated accessor methods for properties without explicitly implemented getters and setters, you can use &lt;code&gt;@get:JvmName&lt;/code&gt; and &lt;code&gt;@set:JvmName&lt;/code&gt;:</source>
          <target state="translated">要更改没有显式实现的getter和setter的属性的已生成访问器方法的名称，可以使用 &lt;code&gt;@get:JvmName&lt;/code&gt; 和 &lt;code&gt;@set:JvmName&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="5fbf41ce5d5e2bab70a3b18ea06244281f42ad35" translate="yes" xml:space="preserve">
          <source>To check that your code passes your own test click the &lt;strong&gt;Check&lt;/strong&gt; icon at the top of &lt;strong&gt;Task Description&lt;/strong&gt; panel. If your code and test are correct, you will see the &lt;strong&gt;&quot;Congratulations!&quot;&lt;/strong&gt; text:</source>
          <target state="translated">要检查您的代码是否通过了您自己的测试，请单击&amp;ldquo; &lt;strong&gt;任务描述&amp;rdquo;&lt;/strong&gt;面板顶部的&amp;ldquo; &lt;strong&gt;检查&amp;rdquo;&lt;/strong&gt;图标。如果您的代码和测试正确，您将看到&lt;strong&gt;&amp;ldquo;恭喜！&amp;rdquo; &lt;/strong&gt;文本：&lt;strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="beef2a5f5b84a735eaf6763f186616f2da608682" translate="yes" xml:space="preserve">
          <source>To check the presence of an element in a collection, use the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/contains&quot;&gt;&lt;code&gt;contains()&lt;/code&gt;&lt;/a&gt; function. It returns &lt;code&gt;true&lt;/code&gt; if there is a collection element that &lt;code&gt;equals()&lt;/code&gt; the function argument. You can call &lt;code&gt;contains()&lt;/code&gt; in the operator form with the &lt;code&gt;in&lt;/code&gt; keyword.</source>
          <target state="translated">要检查集合中某个元素的存在，请使用&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/contains&quot;&gt; &lt;code&gt;contains()&lt;/code&gt; &lt;/a&gt;函数。如果存在 &lt;code&gt;equals()&lt;/code&gt; 函数参数的collection元素，则返回 &lt;code&gt;true&lt;/code&gt; 。您可以使用 &lt;code&gt;in&lt;/code&gt; 关键字以运算符形式调用 &lt;code&gt;contains()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bacf79d368ab6b699d2fdae207996c835a00695c" translate="yes" xml:space="preserve">
          <source>To check the presence of multiple instances together at once, call &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/contains-all&quot;&gt;&lt;code&gt;containsAll()&lt;/code&gt;&lt;/a&gt; with a collection of these instances as an argument.</source>
          <target state="translated">要一次检查多个实例的存在，请调用&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/contains-all&quot;&gt; &lt;code&gt;containsAll()&lt;/code&gt; &lt;/a&gt;并将这些实例的集合作为参数。</target>
        </trans-unit>
        <trans-unit id="bf01294073385c1601c163965354f1918a41a878" translate="yes" xml:space="preserve">
          <source>To check the stability status of different components of Kotlin (Kotlin/JVM, JS, Native, various libraries, etc), please consult &lt;a href=&quot;components-stability&quot;&gt;this link&lt;/a&gt;.</source>
          <target state="translated">要检查Kotlin的不同组件（Kotlin / JVM，JS，Native，各种库等）的稳定性状态，请查阅&lt;a href=&quot;components-stability&quot;&gt;此链接&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ff347228167cf9fc3db7b8ec20d8d867ef76b338" translate="yes" xml:space="preserve">
          <source>To check whether a &lt;code&gt;lateinit var&lt;/code&gt; has already been initialized, use &lt;code&gt;.isInitialized&lt;/code&gt; on the &lt;a href=&quot;reflection#property-references&quot;&gt;reference to that property&lt;/a&gt;:</source>
          <target state="translated">要检查 &lt;code&gt;lateinit var&lt;/code&gt; 是否已经初始化， &lt;code&gt;.isInitialized&lt;/code&gt; 在&lt;a href=&quot;reflection#property-references&quot;&gt;对该属性&lt;/a&gt;的引用上使用.isInitialized：</target>
        </trans-unit>
        <trans-unit id="06e9d17e9ea9b86a000058cf4db743b9a4f8896c" translate="yes" xml:space="preserve">
          <source>To clearly separate the class header and body when the class header is long, either put a blank line following the class header (as in the example above), or put the opening curly brace on a separate line:</source>
          <target state="translated">当类头较长时,要清楚地将类头和正文分开,可以在类头后面空一行(如上面的例子),或者将开头的大括号另起一行。</target>
        </trans-unit>
        <trans-unit id="3e043d9080f48d9f8a9db312581f08dbc6b9e5fd" translate="yes" xml:space="preserve">
          <source>To collect all source sets participating in a compilation, including those added via the depends-on relation, one can use the property &lt;code&gt;allKotlinSourceSets&lt;/code&gt;.</source>
          <target state="translated">要收集所有参与编译的源集，包括通过依赖关系添加的源集，可以使用属性 &lt;code&gt;allKotlinSourceSets&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="803e7c1c7144d14a645ff4c12ca8fcfcbdd5adbe" translate="yes" xml:space="preserve">
          <source>To compile mixed code applications Kotlin compiler should be invoked before Java compiler. In maven terms that means kotlin-maven-plugin should be run before maven-compiler-plugin using the following method, making sure that the kotlin plugin is above the maven-compiler-plugin in your pom.xml file:</source>
          <target state="translated">为了编译混合代码的应用程序,Kotlin编译器应该在Java编译器之前被调用,在maven术语中,这意味着kotlin-maven-plugin应该在maven-compiler-plugin之前运行,使用以下方法确保kotlin插件在maven-compiler-plugin之上。在maven中,这意味着kotlin-maven-plugin应该在maven-compiler-plugin之前运行,使用以下方法,确保kotlin插件在pom.xml文件中的maven-compiler-plugin之上。</target>
        </trans-unit>
        <trans-unit id="72988880fd1eb858d05ee3ce13bbc13e7e1bb020" translate="yes" xml:space="preserve">
          <source>To compile source code, specify the source directories in the</source>
          <target state="translated">要编译源码,请在</target>
        </trans-unit>
        <trans-unit id="37fdd621985c6aff13221b4e4aea16cc07ab8ee0" translate="yes" xml:space="preserve">
          <source>To configure DCE on the main source set, you can use the &lt;code&gt;runDceKotlinJs&lt;/code&gt; task (and corresponding &lt;code&gt;runDce&amp;lt;sourceSetName&amp;gt;KotlinJs&lt;/code&gt; for other source sets).</source>
          <target state="translated">要在主要源集上配置DCE，可以使用 &lt;code&gt;runDceKotlinJs&lt;/code&gt; 任务（对于其他源集，则使用相应的 &lt;code&gt;runDce&amp;lt;sourceSetName&amp;gt;KotlinJs&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="0fbb0879e62b32ffc14d1dc5aabab44fdf51b7ee" translate="yes" xml:space="preserve">
          <source>To configure a single task, use its name. Examples:</source>
          <target state="translated">要配置单个任务,请使用其名称。例子。</target>
        </trans-unit>
        <trans-unit id="68df6e8c753963392486043995598199a7116aa3" translate="yes" xml:space="preserve">
          <source>To configure the IntelliJ formatter according to this style guide, please install Kotlin plugin version 1.2.20 or newer, go to Settings | Editor | Code Style | Kotlin, click on &quot;Set from&amp;hellip;&quot; link in the upper right corner, and select &quot;Predefined style / Kotlin style guide&quot; from the menu.</source>
          <target state="translated">要根据此样式指南配置IntelliJ格式化程序，请安装Kotlin插件版本1.2.20或更高版本，请转至&amp;ldquo;设置&amp;rdquo; |&amp;ldquo;设置&amp;rdquo;。编辑器代码样式| Kotlin，单击右上角的&amp;ldquo;从...设置&amp;rdquo;链接，然后从菜单中选择&amp;ldquo;预定义样式/ Kotlin样式指南&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="a84aa42a71bde94030fd28b49274ed212410ae73" translate="yes" xml:space="preserve">
          <source>To convert a Kotlin function to a pointer to a C function, &lt;code&gt;staticCFunction(::kotlinFunction)&lt;/code&gt; can be used. It is also able to provide the lambda instead of a function reference. The function or lambda must not capture any values.</source>
          <target state="translated">要将Kotlin函数转换为指向C函数的指针，可以使用 &lt;code&gt;staticCFunction(::kotlinFunction)&lt;/code&gt; 。它还能够提供lambda而不是函数引用。函数或lambda不得捕获任何值。</target>
        </trans-unit>
        <trans-unit id="3c44f554793ee378fe115edb9d2b77ef0a09d12f" translate="yes" xml:space="preserve">
          <source>To convert a file we simply provide the input file, and optionally an output directory. The command below will convert the file &lt;code&gt;jquery.d.ts&lt;/code&gt; in the current folder, which we've previously downloaded from the &lt;a href=&quot;https://github.com/DefinitelyTyped/DefinitelyTyped/blob/types/jquery/jquery.d.ts&quot;&gt;Definitely Typed repository&lt;/a&gt; to the output folder &lt;code&gt;headers&lt;/code&gt;:</source>
          <target state="translated">要转换文件，我们只需提供输入文件，还可以提供输出目录。下面的命令将转换文件 &lt;code&gt;jquery.d.ts&lt;/code&gt; 在当前文件夹，我们以前从下载的&lt;a href=&quot;https://github.com/DefinitelyTyped/DefinitelyTyped/blob/types/jquery/jquery.d.ts&quot;&gt;绝对键入的仓库&lt;/a&gt;到输出文件夹 &lt;code&gt;headers&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="033c0e927137582a697794f54285b85aeb454fd5" translate="yes" xml:space="preserve">
          <source>To cover these (and other) cases, Kotlin supports &lt;em&gt;delegated properties&lt;/em&gt;:</source>
          <target state="translated">为了涵盖这些（和其他）情况，Kotlin支持&lt;em&gt;委托的属性&lt;/em&gt;：</target>
        </trans-unit>
        <trans-unit id="9d0229fd8c1088f563b4cf4e10d12c4379d2f726" translate="yes" xml:space="preserve">
          <source>To create a Kotlin scratch, click &lt;strong&gt;File | New | Scratch file&lt;/strong&gt; and select the &lt;strong&gt;Kotlin&lt;/strong&gt; type.</source>
          <target state="translated">要创建Kotlin临时&lt;strong&gt;文件&lt;/strong&gt;，请单击&lt;strong&gt;文件| &lt;/strong&gt;&lt;strong&gt;新增| &lt;/strong&gt;&lt;strong&gt;暂存文件，&lt;/strong&gt;然后选择&lt;strong&gt;Kotlin&lt;/strong&gt;类型。</target>
        </trans-unit>
        <trans-unit id="6469e95270452943ecc23557177165ada17e0d19" translate="yes" xml:space="preserve">
          <source>To create a collection with the same elements as an existing collection, you can use copying operations. Collection copying operations from the standard library create &lt;em&gt;shallow&lt;/em&gt; copy collections with references to the same elements. Thus, a change made to a collection element reflects in all its copies.</source>
          <target state="translated">要创建具有与现有集合相同的元素的集合，可以使用复制操作。标准库中的集合复制操作通过引用相同元素来创建&lt;em&gt;浅表&lt;/em&gt;复制集合。因此，对收集元素所做的更改会反映在其所有副本中。</target>
        </trans-unit>
        <trans-unit id="c93eeedd365f43d9e2553f0db590167b463ec502" translate="yes" xml:space="preserve">
          <source>To create a concrete type collection, such as an &lt;code&gt;ArrayList&lt;/code&gt; or &lt;code&gt;LinkedList&lt;/code&gt;, you can use the available constructors for these types. Similar constructors are available for implementations of &lt;code&gt;Set&lt;/code&gt; and &lt;code&gt;Map&lt;/code&gt;.</source>
          <target state="translated">要创建具体的类型集合，例如 &lt;code&gt;ArrayList&lt;/code&gt; 或 &lt;code&gt;LinkedList&lt;/code&gt; ，可以使用这些类型的可用构造函数。类似的构造函数可用于 &lt;code&gt;Set&lt;/code&gt; 和 &lt;code&gt;Map&lt;/code&gt; 的实现。</target>
        </trans-unit>
        <trans-unit id="10c83d8ce189917b93f0dd12f924ce0343c0f0cd" translate="yes" xml:space="preserve">
          <source>To create a course, go to &lt;strong&gt;Create New Course&lt;/strong&gt; from the &lt;strong&gt;Welcome Screen&lt;/strong&gt; or in the &lt;strong&gt;File Menu&lt;/strong&gt;, fill in the title, author and description:</source>
          <target state="translated">要创建课程，请从&amp;ldquo; &lt;strong&gt;欢迎屏幕&amp;rdquo;&lt;/strong&gt;进入&amp;ldquo; &lt;strong&gt;创建新课程&amp;rdquo;&lt;/strong&gt;，或在&amp;ldquo; &lt;strong&gt;文件&amp;rdquo;菜单中&lt;/strong&gt;，填写标题，作者和说明：&lt;strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b19b96489e64fb428b07b0d9e5f6b20ffaee0c76" translate="yes" xml:space="preserve">
          <source>To create a finite sequence with &lt;code&gt;generateSequence()&lt;/code&gt;, provide a function that returns &lt;code&gt;null&lt;/code&gt; after the last element you need.</source>
          <target state="translated">要使用 &lt;code&gt;generateSequence()&lt;/code&gt; 创建有限序列，请提供一个函数，该函数在需要的最后一个元素之后返回 &lt;code&gt;null&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="47b61d43a27903512a35c90e596534948c2b1dbf" translate="yes" xml:space="preserve">
          <source>To create a progression for iterating in reverse order, use &lt;code&gt;downTo&lt;/code&gt; instead of &lt;code&gt;..&lt;/code&gt; when defining the range for it.</source>
          <target state="translated">要创建以相反顺序进行迭代的进度，请在定义其范围时使用 &lt;code&gt;downTo&lt;/code&gt; 而不是 &lt;code&gt;..&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b47410847599f97a1134fa9ef445378b7a480550" translate="yes" xml:space="preserve">
          <source>To create a range for your class, call the &lt;code&gt;rangeTo()&lt;/code&gt; function on the range start value and provide the end value as an argument. &lt;code&gt;rangeTo()&lt;/code&gt; is often called in its operator form &lt;code&gt;..&lt;/code&gt;.</source>
          <target state="translated">要为您的类创建一个范围，请在范围起始值上调用 &lt;code&gt;rangeTo()&lt;/code&gt; 函数，并提供结束值作为参数。 &lt;code&gt;rangeTo()&lt;/code&gt; 通常被称为在其操作形式 &lt;code&gt;..&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ef350d13303167462d244e7352097ce6871c0d66" translate="yes" xml:space="preserve">
          <source>To create a self-contained Jar file containing the code from your module along with dependencies, include the following under &lt;code&gt;build-&amp;gt;plugins&lt;/code&gt; in your Maven pom.xml file, where &lt;code&gt;main.class&lt;/code&gt; is defined as a property and points to the main Kotlin or Java class:</source>
          <target state="translated">要创建包含模块代码和依赖项的自包含Jar文件，请在Maven pom.xml文件的 &lt;code&gt;build-&amp;gt;plugins&lt;/code&gt; 下包含以下内容，其中 &lt;code&gt;main.class&lt;/code&gt; 定义为属性，并指向主Kotlin或Java类：</target>
        </trans-unit>
        <trans-unit id="250688e8e0fbdc724cfa4d689a087f5e676490f2" translate="yes" xml:space="preserve">
          <source>To create a sequence, call the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.sequences/sequence-of&quot;&gt;&lt;code&gt;sequenceOf()&lt;/code&gt;&lt;/a&gt; function listing the elements as its arguments.</source>
          <target state="translated">要创建序列，请调用&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.sequences/sequence-of&quot;&gt; &lt;code&gt;sequenceOf()&lt;/code&gt; &lt;/a&gt;函数，将元素列为参数。</target>
        </trans-unit>
        <trans-unit id="ab5e0caabe6ba677095c9c30bc71be0a60a8ea76" translate="yes" xml:space="preserve">
          <source>To create a small Jar file containing just the code from your module, include the following under &lt;code&gt;build-&amp;gt;plugins&lt;/code&gt; in your Maven pom.xml file, where &lt;code&gt;main.class&lt;/code&gt; is defined as a property and points to the main Kotlin or Java class:</source>
          <target state="translated">要创建一个仅包含模块代码的Jar文件，请在Maven pom.xml文件的 &lt;code&gt;build-&amp;gt;plugins&lt;/code&gt; 下包含以下内容，其中 &lt;code&gt;main.class&lt;/code&gt; 定义为属性，并指向Kotlin或Java主类：</target>
        </trans-unit>
        <trans-unit id="e35af751d291871272ac5bf8d4ceb5925a4c895b" translate="yes" xml:space="preserve">
          <source>To create a target, use one of the preset functions, which are named according to the target platforms and optionally accept the target name and a configuring code block:</source>
          <target state="translated">要创建一个目标,请使用其中一个预设函数,该函数根据目标平台命名,并可选择接受目标名称和配置代码块。</target>
        </trans-unit>
        <trans-unit id="59c179a1054538f29e6f5790e866a02248610385" translate="yes" xml:space="preserve">
          <source>To create an array, we can use a library function &lt;code&gt;arrayOf()&lt;/code&gt; and pass the item values to it, so that &lt;code&gt;arrayOf(1, 2, 3)&lt;/code&gt; creates an array &lt;code&gt;[1, 2, 3]&lt;/code&gt;. Alternatively, the &lt;code&gt;arrayOfNulls()&lt;/code&gt; library function can be used to create an array of a given size filled with null elements.</source>
          <target state="translated">要创建一个数组，我们可以使用库函数 &lt;code&gt;arrayOf()&lt;/code&gt; 并将项目值传递给它，以便 &lt;code&gt;arrayOf(1, 2, 3)&lt;/code&gt; 创建一个数组 &lt;code&gt;[1, 2, 3]&lt;/code&gt; 。或者，可以使用 &lt;code&gt;arrayOfNulls()&lt;/code&gt; 库函数来创建给定大小的数组，该数组填充有null元素。</target>
        </trans-unit>
        <trans-unit id="9cc39e6db177eed985da184429e7d653e4d3e03b" translate="yes" xml:space="preserve">
          <source>To create an instance of &lt;a href=&quot;index&quot;&gt;Lazy&lt;/a&gt; use the &lt;a href=&quot;../lazy#kotlin%24lazy%28kotlin.Function0%28%28kotlin.lazy.T%29%29%29&quot;&gt;lazy&lt;/a&gt; function.</source>
          <target state="translated">要创建&lt;a href=&quot;index&quot;&gt;Lazy&lt;/a&gt;实例，请使用&lt;a href=&quot;../lazy#kotlin%24lazy%28kotlin.Function0%28%28kotlin.lazy.T%29%29%29&quot;&gt;lazy&lt;/a&gt;函数。</target>
        </trans-unit>
        <trans-unit id="392ca62c20eb8ea21287252327b80e948e15e7f9" translate="yes" xml:space="preserve">
          <source>To create an instance of a class, we call the constructor as if it were a regular function:</source>
          <target state="translated">为了创建一个类的实例,我们像调用一个普通函数一样调用构造函数。</target>
        </trans-unit>
        <trans-unit id="5ececdd9ea1ec767cefb32bd8a4972a7f3db2e63" translate="yes" xml:space="preserve">
          <source>To create an object of an anonymous class that inherits from some type (or types), we write:</source>
          <target state="translated">要创建一个继承自某个类型(或多个类型)的匿名类的对象,我们写。</target>
        </trans-unit>
        <trans-unit id="66ccf1c80c7d0872003cb95567afdbb598a15cac" translate="yes" xml:space="preserve">
          <source>To create bindings for a new library, start by creating a &lt;code&gt;.def&lt;/code&gt; file. Structurally it's a simple property file, which looks like this:</source>
          <target state="translated">要为新库创建绑定， &lt;code&gt;.def&lt;/code&gt; 创建一个.def文件。从结构上讲，这是一个简单的属性文件，如下所示：</target>
        </trans-unit>
        <trans-unit id="53cb83a01be7750f4f13800e35fa2fb65a7ce331" translate="yes" xml:space="preserve">
          <source>To create or access several targets from multiple presets dynamically, you can use the &lt;code&gt;targetFromPreset&lt;/code&gt; function which accepts a preset (those are contained in the &lt;code&gt;kotlin.presets&lt;/code&gt; domain object collection) and, optionally, a target name and a configuration code block.</source>
          <target state="translated">要动态地从多个预设中创建或访问多个目标，可以使用 &lt;code&gt;targetFromPreset&lt;/code&gt; 函数，该函数接受一个预设（这些都包含在 &lt;code&gt;kotlin.presets&lt;/code&gt; 域对象集合中），以及（可选）一个目标名称和一个配置代码块。</target>
        </trans-unit>
        <trans-unit id="84204f67cf463ce0040ab94f394e112f27f7a64e" translate="yes" xml:space="preserve">
          <source>To create such channel use a factory method &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/ticker.html&quot;&gt;ticker&lt;/a&gt;. To indicate that no further elements are needed use &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/-receive-channel/cancel.html&quot;&gt;ReceiveChannel.cancel&lt;/a&gt; method on it.</source>
          <target state="translated">要创建这样的通道，请使用工厂方法&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/ticker.html&quot;&gt;代码&lt;/a&gt;。要表明不需要其他元素，请在其上使用&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/-receive-channel/cancel.html&quot;&gt;ReceiveChannel.cancel&lt;/a&gt;方法。</target>
        </trans-unit>
        <trans-unit id="9e26d13b3d6d463e1b2fd03afc335d058a5d4673" translate="yes" xml:space="preserve">
          <source>To debug Kotlin in Google Chrome, you should use DevTools. Please, read the &lt;a href=&quot;https://developer.chrome.com/devtools&quot;&gt;official documentation&lt;/a&gt; to learn how to open and use DevTools.</source>
          <target state="translated">要在Google Chrome浏览器中调试Kotlin，应使用DevTools。请阅读&lt;a href=&quot;https://developer.chrome.com/devtools&quot;&gt;官方文档&lt;/a&gt;以了解如何打开和使用DevTools。</target>
        </trans-unit>
        <trans-unit id="e817cf98143421063f9dd49cbdf248b7b2518117" translate="yes" xml:space="preserve">
          <source>To debug Kotlin sources in the browser, you should tell the compiler to generate source map file. Add following lines to the Gradle configuration:</source>
          <target state="translated">要在浏览器中调试Kotlin源码,你应该告诉编译器生成源码映射文件。在Gradle配置中添加以下几行。</target>
        </trans-unit>
        <trans-unit id="f1c61d767cd604eae6780df09aa030d9d280b98c" translate="yes" xml:space="preserve">
          <source>To declare a function that is implemented in native (C or C++) code, you need to mark it with the &lt;code&gt;external&lt;/code&gt; modifier:</source>
          <target state="translated">要声明以本机（C或C ++）代码实现的功能，您需要使用 &lt;code&gt;external&lt;/code&gt; 修饰符对其进行标记：</target>
        </trans-unit>
        <trans-unit id="17984c774c9009532146abdfe4c1f92691dab870" translate="yes" xml:space="preserve">
          <source>To declare a sealed class, you put the &lt;code&gt;sealed&lt;/code&gt; modifier before the name of the class. A sealed class can have subclasses, but all of them must be declared in the same file as the sealed class itself. (Before Kotlin 1.1, the rules were even more strict: classes had to be nested inside the declaration of the sealed class).</source>
          <target state="translated">要声明一个密封的类，可以将 &lt;code&gt;sealed&lt;/code&gt; 修饰符放在该类的名称之前。密封类可以具有子类，但是所有子类必须与密封类本身在同一文件中声明。（在Kotlin 1.1之前，规则更加严格：类必须嵌套在密封类的声明中）。</target>
        </trans-unit>
        <trans-unit id="c97ee402b691c80817117f378bd0349e4a8da26c" translate="yes" xml:space="preserve">
          <source>To declare an explicit supertype, we place the type after a colon in the class header:</source>
          <target state="translated">要声明一个显式的超类型,我们把类型放在类头的冒号后面。</target>
        </trans-unit>
        <trans-unit id="48ff93d55fe3658449347e35151be6b572c8736d" translate="yes" xml:space="preserve">
          <source>To declare an extension function, we need to prefix its name with a &lt;em&gt;receiver type&lt;/em&gt;, i.e. the type being extended. The following adds a &lt;code&gt;swap&lt;/code&gt; function to &lt;code&gt;MutableList&amp;lt;Int&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">要声明扩展功能，我们需要在其名称之前添加一个&lt;em&gt;接收器类型&lt;/em&gt;，即正在扩展的类型。以下将 &lt;code&gt;swap&lt;/code&gt; 函数添加到 &lt;code&gt;MutableList&amp;lt;Int&amp;gt;&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="f1b32c095491287535a8ffbd23d718a4ec1e28de" translate="yes" xml:space="preserve">
          <source>To define a custom order for the collection sorting, you can provide your own &lt;code&gt;Comparator&lt;/code&gt;. To do this, call the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/sorted-with&quot;&gt;&lt;code&gt;sortedWith()&lt;/code&gt;&lt;/a&gt; function passing in your &lt;code&gt;Comparator&lt;/code&gt;. With this function, sorting strings by their length looks like this:</source>
          <target state="translated">要为集合排序定义自定义顺序，您可以提供自己的 &lt;code&gt;Comparator&lt;/code&gt; 。为此，请调用传入 &lt;code&gt;Comparator&lt;/code&gt; 的&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/sorted-with&quot;&gt; &lt;code&gt;sortedWith()&lt;/code&gt; &lt;/a&gt;函数。使用此功能，按字符串长度排序如下所示：</target>
        </trans-unit>
        <trans-unit id="76c4ad66d01d81d2c13dd0f6fd9cbde76bdd69dd" translate="yes" xml:space="preserve">
          <source>To define a custom progression step, use the &lt;code&gt;step&lt;/code&gt; function on a range.</source>
          <target state="translated">要定义自定义进度步骤，请在范围上使用 &lt;code&gt;step&lt;/code&gt; 功能。</target>
        </trans-unit>
        <trans-unit id="e3c595e055a9ae116f425f8291258d8dc6632df5" translate="yes" xml:space="preserve">
          <source>To define a natural order for a user-defined type, make the type an inheritor of &lt;code&gt;Comparable&lt;/code&gt;. This requires implementing the &lt;code&gt;compareTo()&lt;/code&gt; function. &lt;code&gt;compareTo()&lt;/code&gt; must take another object of the same type as an argument and return an integer value showing which object is greater:</source>
          <target state="translated">要为用户定义的类型定义自然顺序，请使该类型成为 &lt;code&gt;Comparable&lt;/code&gt; 的继承者。这需要实现 &lt;code&gt;compareTo()&lt;/code&gt; 函数。 &lt;code&gt;compareTo()&lt;/code&gt; 必须将另一个具有相同类型的对象作为参数，并返回一个整数值，显示哪个对象更大：</target>
        </trans-unit>
        <trans-unit id="e9143cabd73a5291d802c769a81ee627bbb5733e" translate="yes" xml:space="preserve">
          <source>To denote the current &lt;em&gt;receiver&lt;/em&gt;, we use &lt;em&gt;this&lt;/em&gt; expressions:</source>
          <target state="translated">为了表示当前&lt;em&gt;接收者&lt;/em&gt;，我们使用&lt;em&gt;以下&lt;/em&gt;表达式：</target>
        </trans-unit>
        <trans-unit id="370aeed576ab8358f729a92b8f556723486b4edb" translate="yes" xml:space="preserve">
          <source>To deploy Kotlin applications on &lt;a href=&quot;https://www.heroku.com&quot;&gt;Heroku&lt;/a&gt;, you can follow the &lt;a href=&quot;https://devcenter.heroku.com/articles/getting-started-with-kotlin&quot;&gt;official Heroku tutorial&lt;/a&gt;.</source>
          <target state="translated">要在&lt;a href=&quot;https://www.heroku.com&quot;&gt;Heroku&lt;/a&gt;上部署Kotlin应用程序，您可以按照&lt;a href=&quot;https://devcenter.heroku.com/articles/getting-started-with-kotlin&quot;&gt;Heroku官方教程进行操作&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="771653f64e2b72ee994da136292e2bfcc37a8770" translate="yes" xml:space="preserve">
          <source>To disable the caching for all Kotlin tasks, set the system property flag &lt;code&gt;kotlin.caching.enabled&lt;/code&gt; to &lt;code&gt;false&lt;/code&gt; (run the build with the argument &lt;code&gt;-Dkotlin.caching.enabled=false&lt;/code&gt;).</source>
          <target state="translated">要禁用所有Kotlin任务的缓存，请将系统属性标志 &lt;code&gt;kotlin.caching.enabled&lt;/code&gt; 设置为 &lt;code&gt;false&lt;/code&gt; （使用参数 &lt;code&gt;-Dkotlin.caching.enabled=false&lt;/code&gt; 运行构建）。</target>
        </trans-unit>
        <trans-unit id="5fb61a8c9c6d11d2594861df1a6ec31dd25d8561" translate="yes" xml:space="preserve">
          <source>To eliminate the risk of such incompatibility being introduced by a change in &lt;strong&gt;non&lt;/strong&gt;-public API of a module, the public API inline functions are not allowed to use non-public-API declarations, i.e. &lt;code&gt;private&lt;/code&gt; and &lt;code&gt;internal&lt;/code&gt; declarations and their parts, in their bodies.</source>
          <target state="translated">为了消除由于模块的&lt;strong&gt;非&lt;/strong&gt;公共API的更改而引入这种不兼容性的风险，公共API内联函数不允许在其主体中使用非公共API声明，即 &lt;code&gt;private&lt;/code&gt; 和 &lt;code&gt;internal&lt;/code&gt; 声明及其部分。</target>
        </trans-unit>
        <trans-unit id="2defcf6d3a2e2a6242b791d65c0bc5e944e6db59" translate="yes" xml:space="preserve">
          <source>To enable Kotlin OSGi support you need to include &lt;code&gt;kotlin-osgi-bundle&lt;/code&gt; instead of regular Kotlin libraries. It is recommended to remove &lt;code&gt;kotlin-runtime&lt;/code&gt;, &lt;code&gt;kotlin-stdlib&lt;/code&gt; and &lt;code&gt;kotlin-reflect&lt;/code&gt; dependencies as &lt;code&gt;kotlin-osgi-bundle&lt;/code&gt; already contains all of them. You also should pay attention in case when external Kotlin libraries are included. Most regular Kotlin dependencies are not OSGi-ready, so you shouldn't use them and should remove them from your project.</source>
          <target state="translated">要启用Kotlin OSGi支持，您需要包括 &lt;code&gt;kotlin-osgi-bundle&lt;/code&gt; 而不是常规的Kotlin库。建议删除 &lt;code&gt;kotlin-runtime&lt;/code&gt; ， &lt;code&gt;kotlin-stdlib&lt;/code&gt; 和 &lt;code&gt;kotlin-reflect&lt;/code&gt; 依赖项，因为 &lt;code&gt;kotlin-osgi-bundle&lt;/code&gt; 已包含所有依赖项。如果还包括外部Kotlin库，您也应该注意。大多数常规Kotlin依赖项都不支持OSGi，因此您不应使用它们，而应将其从项目中删除。</target>
        </trans-unit>
        <trans-unit id="6eb3341f99fe9ebb8d9323c290933247870fe5f7" translate="yes" xml:space="preserve">
          <source>To enable incremental annotation processing, add this line to your &lt;code&gt;gradle.properties&lt;/code&gt; file:</source>
          <target state="translated">要启用增量注释处理，请将以下行添加到 &lt;code&gt;gradle.properties&lt;/code&gt; 文件中：</target>
        </trans-unit>
        <trans-unit id="6dbd033e65a082aad28e5c2fcd37b8daf6829885" translate="yes" xml:space="preserve">
          <source>To enable this behavior you need to have &lt;code&gt;kotlin-stdlib-jdk7&lt;/code&gt; in your dependencies.</source>
          <target state="translated">要启用此行为，您需要在依赖 &lt;code&gt;kotlin-stdlib-jdk7&lt;/code&gt; 中包含kotlin-stdlib-jdk7。</target>
        </trans-unit>
        <trans-unit id="1b92d03d7ab798afc0052aefc2671aaf31759d48" translate="yes" xml:space="preserve">
          <source>To enable this, inline functions support &lt;em&gt;reified type parameters&lt;/em&gt;, so we can write something like this:</source>
          <target state="translated">为了实现这一点，内联函数支持经过&lt;em&gt;修饰的类型参数&lt;/em&gt;，因此我们可以编写如下代码：</target>
        </trans-unit>
        <trans-unit id="eda2f16c079bedddcf43889e299a4aeef442f108" translate="yes" xml:space="preserve">
          <source>To ensure consistency and meaningful behavior of the generated code, data classes have to fulfill the following requirements:</source>
          <target state="translated">为了保证生成代码的一致性和有意义的行为,数据类必须满足以下要求。</target>
        </trans-unit>
        <trans-unit id="1915a0468ec60c04f19505bbcc82c60fb33083b3" translate="yes" xml:space="preserve">
          <source>To evaluate each particular expression in a scratch, run it with &lt;strong&gt;Use REPL&lt;/strong&gt; selected. The scratch will be executed the same way as in &lt;a href=&quot;#repl&quot;&gt;REPL&lt;/a&gt;: the code lines will run subsequently, providing results of each call. You can later refer to the results by the names &lt;code&gt;res*&lt;/code&gt; shown in the corresponding lines.</source>
          <target state="translated">要从头开始评估每个特定的表达式，请在选择&amp;ldquo; &lt;strong&gt;使用REPL&amp;rdquo;的情况下&lt;/strong&gt;运行它。从头开始将以与&lt;a href=&quot;#repl&quot;&gt;REPL中&lt;/a&gt;相同的方式执行：代码行将随后运行，并提供每个调用的结果。您以后可以通过相应行中显示的名称 &lt;code&gt;res*&lt;/code&gt; 引用结果。</target>
        </trans-unit>
        <trans-unit id="94918723afeacff1efa16ca8ab355a3ef8c400e9" translate="yes" xml:space="preserve">
          <source>To exclude default Kotlin libraries that comes as transitive dependencies you can use the following approach:</source>
          <target state="translated">要排除默认的Kotlin库作为转义的依赖关系,你可以使用以下方法。</target>
        </trans-unit>
        <trans-unit id="dfe13659cc9bfcece191e4b8535987313b947937" translate="yes" xml:space="preserve">
          <source>To exclude the standard library from external libraries (notice that &quot;star exclusion&quot; works in Maven 3 only):</source>
          <target state="translated">要从外部库中排除标准库(注意 &quot;星级排除 &quot;只在Maven 3中有效)。</target>
        </trans-unit>
        <trans-unit id="07af8a09aee36adfe68b2b0a1b6017022afe11a3" translate="yes" xml:space="preserve">
          <source>To facilitate this, Kotlin, as a statically typed programming language, uses a family of &lt;a href=&quot;#function-types&quot;&gt;function types&lt;/a&gt; to represent functions and provides a set of specialized language constructs, such as &lt;a href=&quot;#lambda-expressions-and-anonymous-functions&quot;&gt;lambda expressions&lt;/a&gt;.</source>
          <target state="translated">为了促进这一点，Kotlin作为一种静态类型的编程语言，使用一系列&lt;a href=&quot;#function-types&quot;&gt;函数类型&lt;/a&gt;来表示函数，并提供了一组专用的语言构造，例如&lt;a href=&quot;#lambda-expressions-and-anonymous-functions&quot;&gt;lambda表达式&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6f3dc2eba2ee9bd47ab354f073c6c2fcb6b42573" translate="yes" xml:space="preserve">
          <source>To filter collections by negative conditions, use &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/filter-not&quot;&gt;&lt;code&gt;filterNot()&lt;/code&gt;&lt;/a&gt;. It returns a list of elements for which the predicate yields &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">要按负面条件过滤集合，请使用&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/filter-not&quot;&gt; &lt;code&gt;filterNot()&lt;/code&gt; &lt;/a&gt;。它返回谓词产生 &lt;code&gt;false&lt;/code&gt; 的元素列表。</target>
        </trans-unit>
        <trans-unit id="70215058b180f374e26cdfcf334f5153e68b392f" translate="yes" xml:space="preserve">
          <source>To find an intersection between two collections (elements present in both of them), use &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/intersect&quot;&gt;&lt;code&gt;intersect()&lt;/code&gt;&lt;/a&gt;. To find collection elements not present in another collection, use &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/subtract&quot;&gt;&lt;code&gt;subtract()&lt;/code&gt;&lt;/a&gt;. Both these functions can be called in the infix form as well, for example, &lt;code&gt;a intersect b&lt;/code&gt;.</source>
          <target state="translated">要找到两个集合（两个集合中都存在元素）之间的交集，请使用&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/intersect&quot;&gt; &lt;code&gt;intersect()&lt;/code&gt; &lt;/a&gt;。要查找另一个集合中不存在的集合元素，请使用&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/subtract&quot;&gt; &lt;code&gt;subtract()&lt;/code&gt; &lt;/a&gt;。这两个函数也可以以中缀形式调用，例如， &lt;code&gt;a intersect b&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9c38d615ff41226343f4fd39898bb931c04a0136" translate="yes" xml:space="preserve">
          <source>To find out how to start using Kotlin for JavaScript, please refer to the &lt;a href=&quot;../tutorials/javascript/kotlin-to-javascript/kotlin-to-javascript&quot;&gt;tutorials&lt;/a&gt;.</source>
          <target state="translated">要了解如何开始使用Kotlin for JavaScript，请参阅&lt;a href=&quot;../tutorials/javascript/kotlin-to-javascript/kotlin-to-javascript&quot;&gt;教程&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e1b3025669d14b930eb88a22f129712b45d175de" translate="yes" xml:space="preserve">
          <source>To fix this, we have to declare objects of type &lt;code&gt;Source&amp;lt;? extends Object&amp;gt;&lt;/code&gt;, which is sort of meaningless, because we can call all the same methods on such a variable as before, so there's no value added by the more complex type. But the compiler does not know that.</source>
          <target state="translated">为了解决这个问题，我们必须声明 &lt;code&gt;Source&amp;lt;? extends Object&amp;gt;&lt;/code&gt; 类型的对象。扩展Object&amp;gt;，这毫无意义，因为我们可以像以前一样在变量上调用所有相同的方法，因此，更复杂的类型不会增加任何值。但是编译器不知道这一点。</target>
        </trans-unit>
        <trans-unit id="1c3ed2671d90a6fccce18fdda0d98b5b6f90b98a" translate="yes" xml:space="preserve">
          <source>To generate documentation for Kotlin projects, use &lt;a href=&quot;https://github.com/Kotlin/dokka&quot;&gt;Dokka&lt;/a&gt;; please refer to the &lt;a href=&quot;https://github.com/Kotlin/dokka/blob/master/README.md#using-the-gradle-plugin&quot;&gt;Dokka README&lt;/a&gt; for configuration instructions. Dokka supports mixed-language projects and can generate output in multiple formats, including standard JavaDoc.</source>
          <target state="translated">要生成Kotlin项目的文档，请使用&lt;a href=&quot;https://github.com/Kotlin/dokka&quot;&gt;Dokka&lt;/a&gt;；请参阅&lt;a href=&quot;https://github.com/Kotlin/dokka/blob/master/README.md#using-the-gradle-plugin&quot;&gt;Dokka自述文件&lt;/a&gt;以获取配置说明。Dokka支持混合语言项目，并且可以生成多种格式的输出，包括标准JavaDoc。</target>
        </trans-unit>
        <trans-unit id="4da5847f3384d7a88c1adee061594df4e30b80fc" translate="yes" xml:space="preserve">
          <source>To get a seeded instance of random generator use &lt;a href=&quot;index&quot;&gt;Random&lt;/a&gt; function.</source>
          <target state="translated">要获得随机生成器的种子实例，请使用&lt;a href=&quot;index&quot;&gt;随机&lt;/a&gt;函数。</target>
        </trans-unit>
        <trans-unit id="004366928e90c7cdc731785eae1ab45f89c2dc1a" translate="yes" xml:space="preserve">
          <source>To get started, install a recent version of IntelliJ IDEA. Kotlin is bundled with IntelliJ IDEA starting from version 15. You can download the free &lt;a href=&quot;http://www.jetbrains.com/idea/download/index.html&quot;&gt;Community Edition&lt;/a&gt; from &lt;a href=&quot;http://www.jetbrains.com&quot;&gt;JetBrains&lt;/a&gt;.</source>
          <target state="translated">首先，请安装最新版本的IntelliJ IDEA。从版本15开始，Kotlin与IntelliJ IDEA捆绑在一起。您可以从&lt;a href=&quot;http://www.jetbrains.com&quot;&gt;JetBrains&lt;/a&gt;下载免费的&lt;a href=&quot;http://www.jetbrains.com/idea/download/index.html&quot;&gt;Community Edition&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="94da0b750a9691183cd3aef14a71ddcee794f57c" translate="yes" xml:space="preserve">
          <source>To get the Kotlin class corresponding to a Java class, use the &lt;code&gt;.kotlin&lt;/code&gt; extension property:</source>
          <target state="translated">要获取与Java类相对应的Kotlin类，请使用 &lt;code&gt;.kotlin&lt;/code&gt; 扩展属性：</target>
        </trans-unit>
        <trans-unit id="03f3657fbd7420151d7cbee074c2f638231666dd" translate="yes" xml:space="preserve">
          <source>To get the pointer, &lt;code&gt;.cstr&lt;/code&gt; should be allocated in native memory, e.g.</source>
          <target state="translated">为了获得指针， &lt;code&gt;.cstr&lt;/code&gt; 应该在本地内存中分配，例如</target>
        </trans-unit>
        <trans-unit id="99f419fbdc788d8ad3548e218e2e9d1a31e1f757" translate="yes" xml:space="preserve">
          <source>To get the specified number of elements starting from the first, use the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/take&quot;&gt;&lt;code&gt;take()&lt;/code&gt;&lt;/a&gt; function. For getting the last elements, use &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/take-last&quot;&gt;&lt;code&gt;takeLast()&lt;/code&gt;&lt;/a&gt;. When called with a number larger than the collection size, both functions return the whole collection.</source>
          <target state="translated">要从第一个元素开始获取指定数量的元素，请使用&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/take&quot;&gt; &lt;code&gt;take()&lt;/code&gt; &lt;/a&gt;函数。要获取最后一个元素，请使用&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/take-last&quot;&gt; &lt;code&gt;takeLast()&lt;/code&gt; &lt;/a&gt;。当调用的数字大于集合的大小时，两个函数都将返回整个集合。</target>
        </trans-unit>
        <trans-unit id="7c882c6a497d3655af358c59177443fd4abbe265" translate="yes" xml:space="preserve">
          <source>To handle this case, you can mark the property with the &lt;code&gt;lateinit&lt;/code&gt; modifier:</source>
          <target state="translated">要处理这种情况，可以使用 &lt;code&gt;lateinit&lt;/code&gt; 修饰符标记该属性：</target>
        </trans-unit>
        <trans-unit id="f184ea8aba5991e48a265c7b37cae24a3a756b30" translate="yes" xml:space="preserve">
          <source>To have a dependency-injected implementation generated for the type, annotate it with &lt;code&gt;@Component&lt;/code&gt;. The generated class will have the name of this type prepended with Dagger, like &lt;code&gt;DaggerCoffeeShop&lt;/code&gt; below:</source>
          <target state="translated">要为类型生成依赖项注入的实现，请使用 &lt;code&gt;@Component&lt;/code&gt; 对其进行注释。生成的类的名称将以Dagger &lt;code&gt;DaggerCoffeeShop&lt;/code&gt; ，例如下面的DaggerCoffeeShop：</target>
        </trans-unit>
        <trans-unit id="3ecd027b7452270691e59717236b30ee0ecf96d4" translate="yes" xml:space="preserve">
          <source>To help removing deprecated API gradually, the property &lt;a href=&quot;level#kotlin.Deprecated%24level&quot;&gt;level&lt;/a&gt; could be used. Usually a gradual phase-out goes through the &quot;warning&quot;, then &quot;error&quot;, then &quot;hidden&quot; or &quot;removed&quot; stages:</source>
          <target state="translated">为了帮助逐渐删除已弃用的API，可以使用属性&lt;a href=&quot;level#kotlin.Deprecated%24level&quot;&gt;级别&lt;/a&gt;。通常，逐步淘汰会经历&amp;ldquo;警告&amp;rdquo;，&amp;ldquo;错误&amp;rdquo;，&amp;ldquo;隐藏&amp;rdquo;或&amp;ldquo;删除&amp;rdquo;阶段：</target>
        </trans-unit>
        <trans-unit id="bc69b946016a4baffee197957d550f5dda1d3fad" translate="yes" xml:space="preserve">
          <source>To help you choose the right scope function for your case, we'll describe them in detail and provide usage recommendations. Technically, functions are interchangeable in many cases, so the examples show the conventions that define the common usage style.</source>
          <target state="translated">为了帮助您为您的案例选择合适的范围函数,我们将详细描述它们并提供使用建议。从技术上讲,函数在很多情况下是可以互换的,所以例子中展示了定义常见使用方式的约定。</target>
        </trans-unit>
        <trans-unit id="2dc9569e913e0a78f05976a0042b79260268c830" translate="yes" xml:space="preserve">
          <source>To help you choose the right scope function for your purpose, we provide the table of key differences between them.</source>
          <target state="translated">为了帮助您为您的目的选择合适的范围功能,我们提供了它们之间的关键差异表。</target>
        </trans-unit>
        <trans-unit id="3bc65688182a6a956a218fa3a16959313490f82c" translate="yes" xml:space="preserve">
          <source>To import a Kotlin/Native module in an existing Xcode project:</source>
          <target state="translated">在现有的Xcode项目中导入一个Kotlin/Native模块。</target>
        </trans-unit>
        <trans-unit id="2c68721c967bf9f85180daa4363543c530c2e36a" translate="yes" xml:space="preserve">
          <source>To import this module in Kotlin, you have to write two Kotlin source files:</source>
          <target state="translated">要在Kotlin中导入这个模块,你必须编写两个Kotlin源文件。</target>
        </trans-unit>
        <trans-unit id="6c82d374c6d84bb2e142c6de52f1cf3dcc0306ae" translate="yes" xml:space="preserve">
          <source>To improve the behavior in such cases, Kotlin 1.3 introduces experimental mechanism called &lt;em&gt;contracts&lt;/em&gt;.</source>
          <target state="translated">为了改善这种情况下的行为，Kotlin 1.3引入了称为&lt;em&gt;合同的&lt;/em&gt;实验机制。</target>
        </trans-unit>
        <trans-unit id="2d833a47bb81067eedcf42dfefd225e6c4221741" translate="yes" xml:space="preserve">
          <source>To improve the speed of builds that use kapt, you can enable the &lt;a href=&quot;https://guides.gradle.org/using-the-worker-api/&quot;&gt;Gradle worker API&lt;/a&gt; for kapt tasks. Using the worker API lets Gradle run independent annotation processing tasks from a single project in parallel, which in some cases significantly decreases the execution time. However, running kapt with Gradle worker API enabled can result in increased memory consumption due to parallel execution.</source>
          <target state="translated">为了提高使用kapt的构建速度，您可以为Grap任务启用&lt;a href=&quot;https://guides.gradle.org/using-the-worker-api/&quot;&gt;Gradle worker API&lt;/a&gt;。使用worker API，Gradle可以并行运行来自单个项目的独立注释处理任务，这在某些情况下会大大减少执行时间。但是，在启用Gradle worker API的情况下运行kapt会由于并行执行而导致内存消耗增加。</target>
        </trans-unit>
        <trans-unit id="068fdab62a2284b03b98013c61f3a69a95e920c0" translate="yes" xml:space="preserve">
          <source>To improve the times of incremental builds with kapt, it can use the Gradle &lt;a href=&quot;https://docs.gradle.org/current/userguide/java_plugin.html#sec:java_compile_avoidance&quot;&gt;compile avoidance&lt;/a&gt;. With compile avoidance enabled, Gradle can skip annotation processing when rebuilding a project. Particularly, annotation processing is skipped when:</source>
          <target state="translated">为了使用kapt改善增量构建的时间，它可以使用Gradle &lt;a href=&quot;https://docs.gradle.org/current/userguide/java_plugin.html#sec:java_compile_avoidance&quot;&gt;避免编译&lt;/a&gt;。启用避免编译功能后，Gradle可以在重建项目时跳过注释处理。特别是在以下情况下，将跳过注释处理：</target>
        </trans-unit>
        <trans-unit id="ccaf04d3ae02444add2457f45cff16183d2e8aae" translate="yes" xml:space="preserve">
          <source>To include &lt;code&gt;kotlin-osgi-bundle&lt;/code&gt; to a gradle project:</source>
          <target state="translated">要将 &lt;code&gt;kotlin-osgi-bundle&lt;/code&gt; 包含在gradle项目中：</target>
        </trans-unit>
        <trans-unit id="9a00cb17d9820854213a41158d7418355d4b5911" translate="yes" xml:space="preserve">
          <source>To include Java sources in the compilations of a JVM target, or to apply a Gradle plugin that requires the &lt;code&gt;java&lt;/code&gt; plugin to work, you need to explicitly enable Java support for the target:</source>
          <target state="translated">要将Java源代码包含在JVM目标的编译中，或应用要求 &lt;code&gt;java&lt;/code&gt; 插件起作用的Gradle插件，您需要显式启用对目标的Java支持：</target>
        </trans-unit>
        <trans-unit id="7860a6aaa1b42e9447caa0f0a8321e9d88a64124" translate="yes" xml:space="preserve">
          <source>To include the Kotlin OSGi bundle to a Maven project:</source>
          <target state="translated">在Maven项目中加入Kotlin OSGi bundle。</target>
        </trans-unit>
        <trans-unit id="077956d227f2aa6078ddf39bc8e4e3d8b94732b8" translate="yes" xml:space="preserve">
          <source>To inspect the bookkeeping details of the library</source>
          <target state="translated">检查图书馆的记账细节</target>
        </trans-unit>
        <trans-unit id="8c24292aeea43558882c36e9ecc631d06e7467b2" translate="yes" xml:space="preserve">
          <source>To install the library to the default location use</source>
          <target state="translated">要将库安装到默认位置,使用</target>
        </trans-unit>
        <trans-unit id="24f6533d6772f8462ed0f43822595fdca8aa6a25" translate="yes" xml:space="preserve">
          <source>To iterate a number range which does not include its end element, use the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.ranges/until&quot;&gt;&lt;code&gt;until&lt;/code&gt;&lt;/a&gt; function:</source>
          <target state="translated">要迭代不包含其结束元素的数字范围，请使用&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.ranges/until&quot;&gt; &lt;code&gt;until&lt;/code&gt; &lt;/a&gt;功能：</target>
        </trans-unit>
        <trans-unit id="b66d0a5358d7d3838074096ed7a34f595b79a041" translate="yes" xml:space="preserve">
          <source>To iterate numbers in reverse order, use the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.ranges/down-to&quot;&gt;&lt;code&gt;downTo&lt;/code&gt;&lt;/a&gt; function instead of &lt;code&gt;..&lt;/code&gt;.</source>
          <target state="translated">要以相反的顺序迭代号码，使用&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.ranges/down-to&quot;&gt; &lt;code&gt;downTo&lt;/code&gt; &lt;/a&gt;功能，而不是 &lt;code&gt;..&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4de33c40021cd7f879768e42f24ff227ac1b5363" translate="yes" xml:space="preserve">
          <source>To iterate over a range of numbers, use a &lt;a href=&quot;ranges&quot;&gt;range expression&lt;/a&gt;:</source>
          <target state="translated">要遍历一个数字范围，请使用&lt;a href=&quot;ranges&quot;&gt;范围表达式&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="85b39f1ed38fbcb7ba7bf0ac158a30f9c142955c" translate="yes" xml:space="preserve">
          <source>To link to a library use the &lt;code&gt;-library &amp;lt;name&amp;gt;&lt;/code&gt; or &lt;code&gt;-l &amp;lt;name&amp;gt;&lt;/code&gt; flag. For example:</source>
          <target state="translated">要链接到库，请使用 &lt;code&gt;-library &amp;lt;name&amp;gt;&lt;/code&gt; 或 &lt;code&gt;-l &amp;lt;name&amp;gt;&lt;/code&gt; 标志。例如：</target>
        </trans-unit>
        <trans-unit id="5d43d923015e08ab71364c00b4d2a9fc351e1604" translate="yes" xml:space="preserve">
          <source>To link to another element (class, method, property or parameter), simply put its name in square brackets:</source>
          <target state="translated">要链接到另一个元素(类、方法、属性或参数),只需将其名称放在方括号内即可。</target>
        </trans-unit>
        <trans-unit id="04523bc3328b0c5397fbfdee046da0685d0fae03" translate="yes" xml:space="preserve">
          <source>To list library contents:</source>
          <target state="translated">要列出图书馆的内容。</target>
        </trans-unit>
        <trans-unit id="94d09a96d064da30ca57cf8cdc79fa8ea3d9ad9e" translate="yes" xml:space="preserve">
          <source>To maintain indentation in multiline strings, use &lt;code&gt;trimIndent&lt;/code&gt; when the resulting string does not require any internal indentation, or &lt;code&gt;trimMargin&lt;/code&gt; when internal indentation is required:</source>
          <target state="translated">为了保持多串压痕，使用 &lt;code&gt;trimIndent&lt;/code&gt; 时得到的字符串不需要任何内部凹陷，或 &lt;code&gt;trimMargin&lt;/code&gt; 当需要内部缩进：</target>
        </trans-unit>
        <trans-unit id="e12b1be94182f1503207932a398c53d947b434c0" translate="yes" xml:space="preserve">
          <source>To make Kotlin APIs work in Java we generate &lt;code&gt;Box&amp;lt;Super&amp;gt;&lt;/code&gt; as &lt;code&gt;Box&amp;lt;? extends Super&amp;gt;&lt;/code&gt; for covariantly defined &lt;code&gt;Box&lt;/code&gt; (or &lt;code&gt;Foo&amp;lt;? super Bar&amp;gt;&lt;/code&gt; for contravariantly defined &lt;code&gt;Foo&lt;/code&gt;) when it appears &lt;em&gt;as a parameter&lt;/em&gt;. When it's a return value, we don't generate wildcards, because otherwise Java clients will have to deal with them (and it's against the common Java coding style). Therefore, the functions from our example are actually translated as follows:</source>
          <target state="translated">为了使Kotlin API在Java中工作，我们将 &lt;code&gt;Box&amp;lt;Super&amp;gt;&lt;/code&gt; 成为 &lt;code&gt;Box&amp;lt;? extends Super&amp;gt;&lt;/code&gt; 当协变定义的 &lt;code&gt;Box&lt;/code&gt; &lt;em&gt;作为参数&lt;/em&gt;出现时，扩展Super&amp;gt;来表示协变定义的Box（或 &lt;code&gt;Foo&amp;lt;? super Bar&amp;gt;&lt;/code&gt; 表示相反定义的 &lt;code&gt;Foo&lt;/code&gt; ）。当它是一个返回值时，我们不会生成通配符，因为否则Java客户端将不得不处理通配符（这与常见的Java编码风格背道而驰）。因此，我们示例中的函数实际翻译如下：&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1aa213848d1f87a73fda0915bb91fbde0ccc8072" translate="yes" xml:space="preserve">
          <source>To make reading the input in competitive programming tasks like this more concise, you can have the following list of helper input-reading functions:</source>
          <target state="translated">为了使这样的竞争性编程任务中的输入读取更加简洁,你可以拥有以下的帮助性输入读取函数列表。</target>
        </trans-unit>
        <trans-unit id="9375e20c00ff62d1ddedd02075c0f25b2cc018c0" translate="yes" xml:space="preserve">
          <source>To make the compiler do this, we need to mark the &lt;code&gt;lock()&lt;/code&gt; function with the &lt;code&gt;inline&lt;/code&gt; modifier:</source>
          <target state="translated">为了使编译器执行此操作，我们需要使用 &lt;code&gt;inline&lt;/code&gt; 修饰符标记 &lt;code&gt;lock()&lt;/code&gt; 函数：</target>
        </trans-unit>
        <trans-unit id="27c1b74df654000c9e62d4a18ccabc7efde139c9" translate="yes" xml:space="preserve">
          <source>To make the compiler start controlling scopes we only have to annotate the types of all receivers used in the DSL with the same marker annotation. For instance, for HTML Builders we declare an annotation &lt;code&gt;@HTMLTagMarker&lt;/code&gt;:</source>
          <target state="translated">为了使编译器开始控制作用域，我们只需要使用相同的标记注释来注释DSL中使用的所有接收器的类型。例如，对于HTML Builders，我们声明一个 &lt;code&gt;@HTMLTagMarker&lt;/code&gt; 注释：</target>
        </trans-unit>
        <trans-unit id="28e2c451a4401d778b575e3ce27ab0a72af2a6e7" translate="yes" xml:space="preserve">
          <source>To make the library complete we should write some tests, but we have three independent implementations and it is a waste of time to write duplicate tests for each one. The good thing about common code is that it can be covered with common tests, which later are compiled and executed on &lt;em&gt;every&lt;/em&gt; platform. All the bits for testing are already generated by the project Wizard.</source>
          <target state="translated">为了使库完整，我们应该编写一些测试，但是我们有三个独立的实现，并且为每个测试编写重复的测试很浪费时间。通用代码的好处是它可以被通用测试所覆盖，然后在&lt;em&gt;每个&lt;/em&gt;平台上编译和执行。用于测试的所有位已经由项目向导生成。</target>
        </trans-unit>
        <trans-unit id="942a849d5ea3976160d1c1dbff01132e386b6a13" translate="yes" xml:space="preserve">
          <source>To make this work, we should</source>
          <target state="translated">要做到这一点,我们应该</target>
        </trans-unit>
        <trans-unit id="c619d626cb3800fca0e85916c367e7240cf3f525" translate="yes" xml:space="preserve">
          <source>To make unsigned integers easier to use, Kotlin provides an ability to tag an integer literal with a suffix indicating a specific unsigned type (similarly to Float/Long):</source>
          <target state="translated">为了使无符号整数更容易使用,Kotlin提供了一种能力,可以给一个整数文字标记一个特定的无符号类型的后缀(类似于Float/Long)。</target>
        </trans-unit>
        <trans-unit id="c98bfc3140cd7bdf91e45deb511c924efadd9a92" translate="yes" xml:space="preserve">
          <source>To make your builds faster, you can enable incremental compilation for Maven (supported since Kotlin 1.1.2). In order to do that, define the &lt;code&gt;kotlin.compiler.incremental&lt;/code&gt; property:</source>
          <target state="translated">为了使构建更快，您可以为Maven启用增量编译（自Kotlin 1.1.2开始受支持）。为此，请定义 &lt;code&gt;kotlin.compiler.incremental&lt;/code&gt; 属性：</target>
        </trans-unit>
        <trans-unit id="2895b62f37c528355f502b2144c9b302d5145a42" translate="yes" xml:space="preserve">
          <source>To manually compile the application call the &lt;a href=&quot;https://github.com/JetBrains/kotlin/releases&quot;&gt;downloaded&lt;/a&gt; compiler and generate a &lt;code&gt;hello.kexe&lt;/code&gt; (Linux and macOS) or &lt;code&gt;hello.exe&lt;/code&gt; (Windows) binary file:</source>
          <target state="translated">要手动编译应用程序，请调用&lt;a href=&quot;https://github.com/JetBrains/kotlin/releases&quot;&gt;下载的&lt;/a&gt;编译器并生成 &lt;code&gt;hello.kexe&lt;/code&gt; （Linux和macOS）或 &lt;code&gt;hello.exe&lt;/code&gt; （Windows）二进制文件：</target>
        </trans-unit>
        <trans-unit id="b4f6cb9f672ef57783a6ef29cd59db4418575608" translate="yes" xml:space="preserve">
          <source>To mark an API element as experimental, annotate its declaration with your experimental marker annotation:</source>
          <target state="translated">要将一个 API 元素标记为实验性元素,请用您的实验性标记注解来注释其声明。</target>
        </trans-unit>
        <trans-unit id="cb122bda7a14229a5d1edd9ff546275f891b9d77" translate="yes" xml:space="preserve">
          <source>To merge two collections into one, use the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/union&quot;&gt;&lt;code&gt;union()&lt;/code&gt;&lt;/a&gt; function. It can be used in the infix form &lt;code&gt;a union b&lt;/code&gt;. Note that for ordered collections the order of the operands is important: in the resulting collection, the elements of the first operand go before the elements of the second.</source>
          <target state="translated">要将两个集合合并为一个，请使用&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/union&quot;&gt; &lt;code&gt;union()&lt;/code&gt; &lt;/a&gt;函数。可以将infix用作 &lt;code&gt;a union b&lt;/code&gt; 。请注意，对于有序集合，操作数的顺序很重要：在结果集合中，第一个操作数的元素位于第二个操作数的元素之前。</target>
        </trans-unit>
        <trans-unit id="44d5c2b36c84b91934a121e2f5ace6e150a12f1e" translate="yes" xml:space="preserve">
          <source>To mitigate such issues, functions using inline classes are &lt;em&gt;mangled&lt;/em&gt; by adding some stable hashcode to the function name. Therefore, &lt;code&gt;fun compute(x: UInt)&lt;/code&gt; will be represented as &lt;code&gt;public final void compute-&amp;lt;hashcode&amp;gt;(int x)&lt;/code&gt;, which solves the clash problem.</source>
          <target state="translated">为了缓解这些问题，使用内联类功能&lt;em&gt;错位&lt;/em&gt;加入一些稳定的哈希码函数名。因此， &lt;code&gt;fun compute(x: UInt)&lt;/code&gt; 将表示为 &lt;code&gt;public final void compute-&amp;lt;hashcode&amp;gt;(int x)&lt;/code&gt; ，从而解决了冲突问题。</target>
        </trans-unit>
        <trans-unit id="214eeb66f4dd4d1fbd2d9b25b399283f63731ef6" translate="yes" xml:space="preserve">
          <source>To mitigate this problem for the users of such bytecode processing tools, we&amp;rsquo;ve added a command-line option (&lt;code&gt;-Xnormalize-constructor-calls=MODE&lt;/code&gt;) that tells the compiler to generate more Java-like bytecode for such constructs. Here &lt;code&gt;MODE&lt;/code&gt; is one of:</source>
          <target state="translated">为了为此类字节码处理工具的用户减轻此问题，我们添加了一个命令行选项（ &lt;code&gt;-Xnormalize-constructor-calls=MODE&lt;/code&gt; ），该选项告诉编译器为此类构造生成更多类似于Java的字节码。这里 &lt;code&gt;MODE&lt;/code&gt; 是下列之一：</target>
        </trans-unit>
        <trans-unit id="d6aa0bdd277639961899c3f20d2977a244b12631" translate="yes" xml:space="preserve">
          <source>To mitigate this, when defining your generic classes, if the generic type should &lt;em&gt;never&lt;/em&gt; be null, provide a non-null type constraint:</source>
          <target state="translated">为了减轻这种情况，在定义泛型类时，如果泛型类型&lt;em&gt;永远不能&lt;/em&gt;为null，请提供非null类型约束：</target>
        </trans-unit>
        <trans-unit id="c1476847da392c83fd72508f4713555cdba4a150" translate="yes" xml:space="preserve">
          <source>To open the list of available courses, go to &lt;strong&gt;Browse Courses&lt;/strong&gt; on the &lt;strong&gt;Welcome Screen&lt;/strong&gt; or in the &lt;strong&gt;File Menu&lt;/strong&gt;. You can start with the &lt;a href=&quot;koans&quot;&gt;Kotlin Koans&lt;/a&gt;, a series of exercises created to get you familiar with the Kotlin Syntax:</source>
          <target state="translated">要打开可用课程列表，请在&amp;ldquo; &lt;strong&gt;欢迎&amp;rdquo;屏幕上&lt;/strong&gt;或&amp;ldquo; &lt;strong&gt;文件&amp;rdquo;菜单中&lt;/strong&gt;转到&amp;ldquo; &lt;strong&gt;浏览课程&lt;/strong&gt; &amp;rdquo; 。您可以从&lt;a href=&quot;koans&quot;&gt;Kotlin Koans&lt;/a&gt;开始，这是一系列让您熟悉Kotlin语法的练习：&lt;strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5c9c6ae81e15d7660d42f1ec133505c23d5897c2" translate="yes" xml:space="preserve">
          <source>To overcome this restriction an &lt;code&gt;internal&lt;/code&gt; declaration can be annotated with the &lt;code&gt;@PublishedApi&lt;/code&gt; annotation:</source>
          <target state="translated">为了克服此限制，可以使用 &lt;code&gt;@PublishedApi&lt;/code&gt; 批注对 &lt;code&gt;internal&lt;/code&gt; 声明进行批注：</target>
        </trans-unit>
        <trans-unit id="a53373994c3982c9e9e8b4ff82c6886cee600271" translate="yes" xml:space="preserve">
          <source>To override &lt;code&gt;clone()&lt;/code&gt;, your class needs to extend &lt;code&gt;kotlin.Cloneable&lt;/code&gt;:</source>
          <target state="translated">要覆盖 &lt;code&gt;clone()&lt;/code&gt; ，您的类需要扩展 &lt;code&gt;kotlin.Cloneable&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="5e5ef664ee32f352aa2bb27af09f15aaa52406f6" translate="yes" xml:space="preserve">
          <source>To override &lt;code&gt;finalize()&lt;/code&gt;, all you need to do is simply declare it, without using the &lt;em&gt;override&lt;/em&gt; keyword:</source>
          <target state="translated">要覆盖 &lt;code&gt;finalize()&lt;/code&gt; ，您只需要声明它，而无需使用&lt;em&gt;override&lt;/em&gt;关键字：</target>
        </trans-unit>
        <trans-unit id="8b0eb1602de9391e417352c211eac3143269f17a" translate="yes" xml:space="preserve">
          <source>To override different methods with clashing Kotlin signatures, you can add a &lt;code&gt;@Suppress(&quot;CONFLICTING_OVERLOADS&quot;)&lt;/code&gt; annotation to the class.</source>
          <target state="translated">要使用冲突的Kotlin签名覆盖不同的方法，您可以在类中添加 &lt;code&gt;@Suppress(&quot;CONFLICTING_OVERLOADS&quot;)&lt;/code&gt; 批注。</target>
        </trans-unit>
        <trans-unit id="91bf99aec76b5996287fb77c5aef5099beb9bbf4" translate="yes" xml:space="preserve">
          <source>To pass an array of primitive values you can do the following in Kotlin:</source>
          <target state="translated">要传递一个基元值数组,你可以在Kotlin中执行以下操作。</target>
        </trans-unit>
        <trans-unit id="1e5025ef1a23d09437b26030660587370537de7f" translate="yes" xml:space="preserve">
          <source>To pass custom raw compiler arguments, you can use &lt;code&gt;&amp;lt;compilerarg&amp;gt;&lt;/code&gt; elements with either &lt;code&gt;value&lt;/code&gt; or &lt;code&gt;line&lt;/code&gt; attributes. This can be done within the &lt;code&gt;&amp;lt;kotlinc&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;kotlin2js&amp;gt;&lt;/code&gt;, and &lt;code&gt;&amp;lt;withKotlin&amp;gt;&lt;/code&gt; task elements, as follows:</source>
          <target state="translated">要传递自定义的原始编译器参数，可以将 &lt;code&gt;&amp;lt;compilerarg&amp;gt;&lt;/code&gt; 元素与 &lt;code&gt;value&lt;/code&gt; 或 &lt;code&gt;line&lt;/code&gt; 属性一起使用。这可以在 &lt;code&gt;&amp;lt;kotlinc&amp;gt;&lt;/code&gt; ， &lt;code&gt;&amp;lt;kotlin2js&amp;gt;&lt;/code&gt; 和 &lt;code&gt;&amp;lt;withKotlin&amp;gt;&lt;/code&gt; 任务元素中完成，如下所示：</target>
        </trans-unit>
        <trans-unit id="a66e06df579b1b23b91b1d16d9167a525f0b07ab" translate="yes" xml:space="preserve">
          <source>To perform a certain operation only for non-null values, you can use the safe call operator together with &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin/let&quot;&gt;&lt;code&gt;let&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">要仅对非空值执行某些操作，可以将安全调用运算符与&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin/let&quot;&gt; &lt;code&gt;let&lt;/code&gt; &lt;/a&gt;一起使用：</target>
        </trans-unit>
        <trans-unit id="ad4b6b2d80d98efbdc1e78464bd70bae937149d2" translate="yes" xml:space="preserve">
          <source>To perform operations on all keys or all values of a map, you can retrieve them from the properties &lt;code&gt;keys&lt;/code&gt; and &lt;code&gt;values&lt;/code&gt; accordingly. &lt;code&gt;keys&lt;/code&gt; is a set of all map keys and &lt;code&gt;values&lt;/code&gt; is a collection of all map values.</source>
          <target state="translated">要对地图的所有键或所有值执行操作，可以从属性 &lt;code&gt;keys&lt;/code&gt; 和 &lt;code&gt;values&lt;/code&gt; 相应地检索它们。 &lt;code&gt;keys&lt;/code&gt; 是所有映射键的集合， &lt;code&gt;values&lt;/code&gt; 是所有映射值的集合。</target>
        </trans-unit>
        <trans-unit id="f51b0c422406c4232c8e54b63e979d8283484a9e" translate="yes" xml:space="preserve">
          <source>To prevent spoiling the global object, Kotlin creates an object that contains all Kotlin declarations from the current module. So if you name your module as &lt;code&gt;myModule&lt;/code&gt;, all declarations are available to JavaScript via &lt;code&gt;myModule&lt;/code&gt; object. For example:</source>
          <target state="translated">为了防止破坏全局对象，Kotlin创建了一个对象，该对象包含当前模块中的所有Kotlin声明。因此，如果您将模块命名为 &lt;code&gt;myModule&lt;/code&gt; ，则所有声明均可通过 &lt;code&gt;myModule&lt;/code&gt; 对象提供给JavaScript 。例如：</target>
        </trans-unit>
        <trans-unit id="bf0b70dea8387f3ebfae5a605f2eb84fae8ef787" translate="yes" xml:space="preserve">
          <source>To produce a library with the Kotlin/Native compiler use the &lt;code&gt;-produce library&lt;/code&gt; or &lt;code&gt;-p library&lt;/code&gt; flag. For example:</source>
          <target state="translated">要使用Kotlin / Native编译器生成库，请使用 &lt;code&gt;-produce library&lt;/code&gt; 或 &lt;code&gt;-p library&lt;/code&gt; 标志。例如：</target>
        </trans-unit>
        <trans-unit id="ffef4a8cd2a1229b2f11fc8babdeb98ccaf8e0db" translate="yes" xml:space="preserve">
          <source>To produce binaries with the Kotlin/Native compiler it's sufficient to use the &lt;code&gt;-g&lt;/code&gt; option on the command line.</source>
          <target state="translated">要使用Kotlin / Native编译器生成二进制文件，在命令行上使用 &lt;code&gt;-g&lt;/code&gt; 选项就足够了。</target>
        </trans-unit>
        <trans-unit id="1d3463a205e94a6afcbfd6330cbb565e26b9762f" translate="yes" xml:space="preserve">
          <source>To provide a custom equals check implementation, override the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin/-any/equals&quot;&gt;&lt;code&gt;equals(other: Any?): Boolean&lt;/code&gt;&lt;/a&gt; function. Functions with the same name and other signatures, like &lt;code&gt;equals(other: Foo)&lt;/code&gt;, don't affect equality checks with the operators &lt;code&gt;==&lt;/code&gt; and &lt;code&gt;!=&lt;/code&gt;.</source>
          <target state="translated">要提供自定义的equals check实现，请重写&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin/-any/equals&quot;&gt; &lt;code&gt;equals(other: Any?): Boolean&lt;/code&gt; &lt;/a&gt;函数。具有相同名称和其他签名的函数，例如 &lt;code&gt;equals(other: Foo)&lt;/code&gt; ，不影响使用运算符 &lt;code&gt;==&lt;/code&gt; 和 &lt;code&gt;!=&lt;/code&gt; 进行的相等性检查。</target>
        </trans-unit>
        <trans-unit id="6e836b4f2fc16da476cc12a9d2050e81e112acff" translate="yes" xml:space="preserve">
          <source>To provide access to user's native operating system services, &lt;code&gt;Kotlin/Native&lt;/code&gt; distribution includes a set of prebuilt libraries specific to each target. We call them &lt;strong&gt;Platform Libraries&lt;/strong&gt;.</source>
          <target state="translated">为了提供对用户本机操作系统服务的访问， &lt;code&gt;Kotlin/Native&lt;/code&gt; 发行版包括一组特定于每个目标的预构建库。我们称它们为&lt;strong&gt;平台库&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="31bd1e7079e9e4ecee7632836be44ddf7d329d26" translate="yes" xml:space="preserve">
          <source>To publish an Android library as a part of a multiplatform library, one needs to &lt;a href=&quot;#publishing-a-multiplatform-library&quot;&gt;setup publishing for the library&lt;/a&gt; and provide additional configuration for the Android library target.</source>
          <target state="translated">要将Android库发布为多平台库的一部分，需要&lt;a href=&quot;#publishing-a-multiplatform-library&quot;&gt;设置该库的发布&lt;/a&gt;并为Android库目标提供其他配置。</target>
        </trans-unit>
        <trans-unit id="d256a0c22e6d267c506acee2d9aeb1788f5b9b28" translate="yes" xml:space="preserve">
          <source>To refer to the object, we use its name directly:</source>
          <target state="translated">为了引用对象,我们直接使用其名称。</target>
        </trans-unit>
        <trans-unit id="6b8089bed090bdadd847bf36cd42b8f6183969d2" translate="yes" xml:space="preserve">
          <source>To remove an element at a specific position from a list, use the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-mutable-list/remove-at&quot;&gt;&lt;code&gt;removeAt()&lt;/code&gt;&lt;/a&gt; function providing the position as an argument. All indices of elements that come after the element being removed will decrease by one.</source>
          <target state="translated">要从列表中删除特定位置的元素，请使用&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-mutable-list/remove-at&quot;&gt; &lt;code&gt;removeAt()&lt;/code&gt; &lt;/a&gt;函数，将该位置作为参数。在元素被删除之后出现的所有元素索引将减少一。</target>
        </trans-unit>
        <trans-unit id="521b7c2bcc6979fed176a9238d544430e53c8f9c" translate="yes" xml:space="preserve">
          <source>To remove an element from a mutable collection, use the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/remove&quot;&gt;&lt;code&gt;remove()&lt;/code&gt;&lt;/a&gt; function. &lt;code&gt;remove()&lt;/code&gt; accepts the element value and removes one occurrence of this value.</source>
          <target state="translated">要从可变集合中删除元素，请使用&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/remove&quot;&gt; &lt;code&gt;remove()&lt;/code&gt; &lt;/a&gt;函数。 &lt;code&gt;remove()&lt;/code&gt; 接受元素值并删除该值的一次出现。</target>
        </trans-unit>
        <trans-unit id="3a5e20b686847f8b478f6ecb4aea9aa4a6082939" translate="yes" xml:space="preserve">
          <source>To remove an entry from a mutable map, use the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-mutable-map/remove&quot;&gt;&lt;code&gt;remove()&lt;/code&gt;&lt;/a&gt; function. When calling &lt;code&gt;remove()&lt;/code&gt;, you can pass either a key or a whole key-value-pair. If you specify both the key and value, the element with this key will be removed only if its value matches the second argument.</source>
          <target state="translated">要从可变映射中删除条目，请使用&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-mutable-map/remove&quot;&gt; &lt;code&gt;remove()&lt;/code&gt; &lt;/a&gt;函数。调用 &lt;code&gt;remove()&lt;/code&gt; 时，您可以传递键或整个键值对。如果同时指定键和值，则仅当其值与第二个参数匹配时，才会删除带有此键的元素。</target>
        </trans-unit>
        <trans-unit id="0521fbcd6fb6f9d94e609424eadc7933044f924e" translate="yes" xml:space="preserve">
          <source>To remove the library from the default repository use</source>
          <target state="translated">要从默认仓库中删除库,使用</target>
        </trans-unit>
        <trans-unit id="31c3d88842fee1685ad0d679c0db8a0fc174ec11" translate="yes" xml:space="preserve">
          <source>To remove the warning you have to opt in to the usage of experimental features by passing the argument &lt;code&gt;-XXLanguage:+InlineClasses&lt;/code&gt; to &lt;code&gt;kotlinc&lt;/code&gt;.</source>
          <target state="translated">要消除警告，您必须通过将参数 &lt;code&gt;-XXLanguage:+InlineClasses&lt;/code&gt; 传递给 &lt;code&gt;kotlinc&lt;/code&gt; 来选择使用实验性功能。</target>
        </trans-unit>
        <trans-unit id="d3f08203a0ddf6e6bc4f31d19032cdb3e04aee85" translate="yes" xml:space="preserve">
          <source>To remove the warnings, add the compiler argument &lt;code&gt;-Xuse-experimental=kotlin.Experimental&lt;/code&gt;.</source>
          <target state="translated">要删除警告，请添加编译器参数 &lt;code&gt;-Xuse-experimental=kotlin.Experimental&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d469d435bb3a113c1dd1088e7025b64a6a0198e5" translate="yes" xml:space="preserve">
          <source>To represent body of an external function. In most cases Kotlin does not require to provide bodies of external functions and properties, but if for some reason you want to (for example, due to limitation of your coding style guides), you should use &lt;code&gt;definedExternally&lt;/code&gt;.</source>
          <target state="translated">表示外部功能的主体。在大多数情况下，Kotlin不需要提供外部函数和属性的主体，但是如果出于某些原因（例如，由于编码样式指南的限制），则应使用 &lt;code&gt;definedExternally&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="19ce750db4ac36bdd72cdcddab7ef744528c90ce" translate="yes" xml:space="preserve">
          <source>To represent value of default argument.</source>
          <target state="translated">表示默认参数的值。</target>
        </trans-unit>
        <trans-unit id="69457a99de832ac1adcb88dba9125bcc6ced4562" translate="yes" xml:space="preserve">
          <source>To retrieve the Java class of an object, use the &lt;code&gt;java&lt;/code&gt; extension property on a &lt;a href=&quot;reflection#class-references&quot;&gt;class reference&lt;/a&gt;:</source>
          <target state="translated">要检索对象的Java类，请在&lt;a href=&quot;reflection#class-references&quot;&gt;类引用&lt;/a&gt;上使用 &lt;code&gt;java&lt;/code&gt; 扩展属性：</target>
        </trans-unit>
        <trans-unit id="cab4ab009a9095119ec865716a0422fa20f520ff" translate="yes" xml:space="preserve">
          <source>To return to the pre-1.2 behavior, pass the flag &lt;code&gt;-Xno-exception-on-explicit-equals-for-boxed-null&lt;/code&gt; to the compiler.</source>
          <target state="translated">若要返回1.2之前的行为，请将标志 &lt;code&gt;-Xno-exception-on-explicit-equals-for-boxed-null&lt;/code&gt; 传递给编译器。</target>
        </trans-unit>
        <trans-unit id="5e0d2974dcfaa7063fb542a18d0b57f9a9db0a83" translate="yes" xml:space="preserve">
          <source>To run REPL in IntelliJ IDEA, open &lt;strong&gt;Tools | Kotlin | Kotlin REPL&lt;/strong&gt;.</source>
          <target state="translated">要在IntelliJ IDEA中运行REPL，请打开&amp;ldquo; &lt;strong&gt;工具&amp;rdquo; |&amp;ldquo;工具&amp;rdquo;。科特林| Kotlin REPL&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="c80c0585cded44d08003b71c290d1079d4069543" translate="yes" xml:space="preserve">
          <source>To run REPL in the OS command line, open &lt;strong&gt;/bin/kotlinc-jvm&lt;/strong&gt; from the directory of standalone Kotlin compiler.</source>
          <target state="translated">要在OS命令行中运行REPL，请从独立Kotlin编译器的目录中打开&lt;strong&gt;/ bin / kotlinc-jvm&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="7fd27594c6ae21992652c27028d51d29604dfae3" translate="yes" xml:space="preserve">
          <source>To run a script, we just pass the &lt;code&gt;-script&lt;/code&gt; option to the compiler with the corresponding script file.</source>
          <target state="translated">要运行脚本，我们只需将 &lt;code&gt;-script&lt;/code&gt; 选项和相应的脚本文件传递给编译器。</target>
        </trans-unit>
        <trans-unit id="e2cae558670745cc7ac9e88ece3ef0ebf63a7483" translate="yes" xml:space="preserve">
          <source>To run kapt with compile avoidance:</source>
          <target state="translated">运行kapt时要避免编译。</target>
        </trans-unit>
        <trans-unit id="58d7a0df7bd3a304f110999cd04f5328dff8bc19" translate="yes" xml:space="preserve">
          <source>To run the application, right-click somewhere in the main file and select &lt;strong&gt;Run As | Kotlin Application&lt;/strong&gt;.</source>
          <target state="translated">要运行该应用程序，请右键单击主文件中的某个位置，然后选择&lt;strong&gt;&amp;ldquo;运行方式| Kotlin应用程序&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="2e4d15311fa7cd994c8e9ce22c145ce856d694db" translate="yes" xml:space="preserve">
          <source>To save your course as a zip file, go to &lt;strong&gt;Course Creator -&amp;gt; Generate Course Archive&lt;/strong&gt; action. The generated archive can be opened via the &lt;strong&gt;Browse Courses&lt;/strong&gt; available from the &lt;strong&gt;Welcome Screen&lt;/strong&gt; and in the &lt;strong&gt;File Menu&lt;/strong&gt; with the &lt;strong&gt;Import Course&lt;/strong&gt; icon:</source>
          <target state="translated">要将课程另存为zip文件，请转到&amp;ldquo; &lt;strong&gt;课程创建者&amp;rdquo;-&amp;gt;&amp;ldquo;生成课程存档&amp;rdquo;&lt;/strong&gt;操作。可以通过&lt;strong&gt;欢迎屏幕中&lt;/strong&gt;可用的&lt;strong&gt;浏览课程&lt;/strong&gt;以及带有&lt;strong&gt;导入课程&lt;/strong&gt;图标的&lt;strong&gt;文件菜单&lt;/strong&gt;打开生成的档案：&lt;strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="36a621d8894a43c60f62b88c51e7aa345450af8d" translate="yes" xml:space="preserve">
          <source>To search an element in a sorted list, call the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/binary-search&quot;&gt;&lt;code&gt;binarySearch()&lt;/code&gt;&lt;/a&gt; function passing the value as an argument. If such an element exists, the function returns its index; otherwise, it returns &lt;code&gt;(-insertionPoint - 1)&lt;/code&gt; where &lt;code&gt;insertionPoint&lt;/code&gt; is the index where this element should be inserted so that the list remains sorted. If there is more than one element with the given value, the search can return any of their indices.</source>
          <target state="translated">要搜索排序列表中的元素，请调用将该值作为参数传递的&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/binary-search&quot;&gt; &lt;code&gt;binarySearch()&lt;/code&gt; &lt;/a&gt;函数。如果存在这样的元素，则函数返回其索引；否则，它返回 &lt;code&gt;(-insertionPoint - 1)&lt;/code&gt; 其中 &lt;code&gt;insertionPoint&lt;/code&gt; 就是这个元素应当被插入，使得列表保持排序的索引。如果有多个具有给定值的元素，则搜索可以返回其任何索引。</target>
        </trans-unit>
        <trans-unit id="680ca05ae718e68cfb1629f08e49b399fcda4d93" translate="yes" xml:space="preserve">
          <source>To see the full Gradle script check out the source of the project on GitHub.</source>
          <target state="translated">要查看完整的Gradle脚本,请查看GitHub上的项目源代码。</target>
        </trans-unit>
        <trans-unit id="06d76d8df652a0954c4314eb6cd119fb4f22f648" translate="yes" xml:space="preserve">
          <source>To select module system when compiling via Gradle, you should set &lt;code&gt;moduleKind&lt;/code&gt; property, i.e.</source>
          <target state="translated">要在通过Gradle进行编译时选择模块系统，应设置 &lt;code&gt;moduleKind&lt;/code&gt; 属性，即</target>
        </trans-unit>
        <trans-unit id="16681c84550456d5ff8bc73b03434df79d115f43" translate="yes" xml:space="preserve">
          <source>To select module system when compiling via Maven, you should set &lt;code&gt;moduleKind&lt;/code&gt; configuration property, i.e. your &lt;code&gt;pom.xml&lt;/code&gt; should look like this:</source>
          <target state="translated">要在通过Maven进行编译时选择模块系统，应设置 &lt;code&gt;moduleKind&lt;/code&gt; 配置属性，即 &lt;code&gt;pom.xml&lt;/code&gt; 应如下所示：</target>
        </trans-unit>
        <trans-unit id="5dfb90c4357595726b2e826922df2d26c2c78269" translate="yes" xml:space="preserve">
          <source>To setup a multiplatform project from scratch in a Gradle project, first apply the &lt;code&gt;kotlin-multiplatform&lt;/code&gt; plugin to the project by adding the following to the beginning of the &lt;code&gt;build.gradle&lt;/code&gt; file:</source>
          <target state="translated">要从零开始在Gradle项目中设置多平台项目，请首先在 &lt;code&gt;build.gradle&lt;/code&gt; 文件的开头添加以下内容，将 &lt;code&gt;kotlin-multiplatform&lt;/code&gt; 插件应用于该项目：</target>
        </trans-unit>
        <trans-unit id="c7e47d17458659905c4f2f62bdab7488ae50c7a1" translate="yes" xml:space="preserve">
          <source>To skip automatic conversion and ensure raw pointers are used in the bindings, a &lt;code&gt;noStringConversion&lt;/code&gt; statement in the &lt;code&gt;.def&lt;/code&gt; file could be used, i.e.</source>
          <target state="translated">要跳过自动转换并确保在绑定中使用原始指针，可以使用 &lt;code&gt;.def&lt;/code&gt; 文件中的 &lt;code&gt;noStringConversion&lt;/code&gt; 语句，即</target>
        </trans-unit>
        <trans-unit id="db6bb94ddd68466610ca12cc204d3d3c6bd7dd12" translate="yes" xml:space="preserve">
          <source>To solve such issues, Kotlin introduces a special kind of class called an &lt;code&gt;inline class&lt;/code&gt;, which is declared by placing an &lt;code&gt;inline&lt;/code&gt; modifier before the name of the class:</source>
          <target state="translated">为了解决这些问题，Kotlin引入了一种特殊的类，称为 &lt;code&gt;inline class&lt;/code&gt; ，该类通过在类名之前放置一个 &lt;code&gt;inline&lt;/code&gt; 修饰符来声明：</target>
        </trans-unit>
        <trans-unit id="c6edca763e12c6292a414b20b65eaba5f53f467b" translate="yes" xml:space="preserve">
          <source>To specify a visibility of the primary constructor of a class, use the following syntax (note that you need to add an explicit &lt;em&gt;constructor&lt;/em&gt; keyword):</source>
          <target state="translated">要指定类的主要构造函数的可见性，请使用以下语法（请注意，您需要添加一个显式的&lt;em&gt;构造函数&lt;/em&gt;关键字）：</target>
        </trans-unit>
        <trans-unit id="419bcc45449c9e2a7d1fb4c22599e33f123b758a" translate="yes" xml:space="preserve">
          <source>To specify additional compilation options, use the &lt;code&gt;kotlinOptions&lt;/code&gt; property of a Kotlin compilation task.</source>
          <target state="translated">要指定其他编译选项，请使用Kotlin编译任务的 &lt;code&gt;kotlinOptions&lt;/code&gt; 属性。</target>
        </trans-unit>
        <trans-unit id="0ac203e68342bc2b26ca6bd486204285a11e36be" translate="yes" xml:space="preserve">
          <source>To specify that a function type is &lt;a href=&quot;null-safety#nullable-types-and-non-null-types&quot;&gt;nullable&lt;/a&gt;, use parentheses: &lt;code&gt;((Int, Int) -&amp;gt; Int)?&lt;/code&gt;.</source>
          <target state="translated">要指定函数类型为&lt;a href=&quot;null-safety#nullable-types-and-non-null-types&quot;&gt;可&lt;/a&gt;为空，请使用括号： &lt;code&gt;((Int, Int) -&amp;gt; Int)?&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e57f72b9d262e6ee5d6ce2e784cc4119575a7e41" translate="yes" xml:space="preserve">
          <source>To start executing the created coroutine, invoke &lt;code&gt;resume(Unit)&lt;/code&gt; on the returned &lt;a href=&quot;-continuation/index&quot;&gt;Continuation&lt;/a&gt; instance. The &lt;a href=&quot;create-coroutine#kotlin.coroutines%24createCoroutine%28kotlin.coroutines.SuspendFunction0%28%28kotlin.coroutines.createCoroutine.T%29%29%2C+kotlin.coroutines.Continuation%28%28kotlin.coroutines.createCoroutine.T%29%29%29%2Fcompletion&quot;&gt;completion&lt;/a&gt; continuation is invoked when the coroutine completes with a result or an exception. Subsequent invocation of any resume function on the resulting continuation will produce an &lt;a href=&quot;../kotlin/-illegal-state-exception/index#kotlin.IllegalStateException&quot;&gt;IllegalStateException&lt;/a&gt;.</source>
          <target state="translated">要开始执行创建的协程，请在返回的&lt;a href=&quot;-continuation/index&quot;&gt;Continuation&lt;/a&gt;实例上调用 &lt;code&gt;resume(Unit)&lt;/code&gt; 。在&lt;a href=&quot;create-coroutine#kotlin.coroutines%24createCoroutine%28kotlin.coroutines.SuspendFunction0%28%28kotlin.coroutines.createCoroutine.T%29%29%2C+kotlin.coroutines.Continuation%28%28kotlin.coroutines.createCoroutine.T%29%29%29%2Fcompletion&quot;&gt;完成&lt;/a&gt;当协程与结果或异常结束连续被调用。随后在结果延续上调用任何resume函数将产生&lt;a href=&quot;../kotlin/-illegal-state-exception/index#kotlin.IllegalStateException&quot;&gt;IllegalStateException&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="29211ac1a181cd4bb3901bb410d7de3d38f88156" translate="yes" xml:space="preserve">
          <source>To start executing the created coroutine, invoke &lt;code&gt;resume(Unit)&lt;/code&gt; on the returned &lt;a href=&quot;-continuation/index&quot;&gt;Continuation&lt;/a&gt; instance. The &lt;a href=&quot;create-coroutine#kotlin.coroutines%24createCoroutine%28kotlin.coroutines.SuspendFunction1%28%28kotlin.coroutines.createCoroutine.R%2C+kotlin.coroutines.createCoroutine.T%29%29%2C+kotlin.coroutines.createCoroutine.R%2C+kotlin.coroutines.Continuation%28%28kotlin.coroutines.createCoroutine.T%29%29%29%2Fcompletion&quot;&gt;completion&lt;/a&gt; continuation is invoked when the coroutine completes with a result or an exception. Subsequent invocation of any resume function on the resulting continuation will produce an &lt;a href=&quot;../kotlin/-illegal-state-exception/index#kotlin.IllegalStateException&quot;&gt;IllegalStateException&lt;/a&gt;.</source>
          <target state="translated">要开始执行创建的协程，请在返回的&lt;a href=&quot;-continuation/index&quot;&gt;Continuation&lt;/a&gt;实例上调用 &lt;code&gt;resume(Unit)&lt;/code&gt; 。在&lt;a href=&quot;create-coroutine#kotlin.coroutines%24createCoroutine%28kotlin.coroutines.SuspendFunction1%28%28kotlin.coroutines.createCoroutine.R%2C+kotlin.coroutines.createCoroutine.T%29%29%2C+kotlin.coroutines.createCoroutine.R%2C+kotlin.coroutines.Continuation%28%28kotlin.coroutines.createCoroutine.T%29%29%29%2Fcompletion&quot;&gt;完成&lt;/a&gt;当协程与结果或异常结束连续被调用。随后在结果延续上调用任何resume函数将产生&lt;a href=&quot;../kotlin/-illegal-state-exception/index#kotlin.IllegalStateException&quot;&gt;IllegalStateException&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b715c677cb96aa31e520707c8bf7a084527dde6c" translate="yes" xml:space="preserve">
          <source>To start executing the created coroutine, invoke &lt;code&gt;resume(Unit)&lt;/code&gt; on the returned &lt;a href=&quot;-continuation/index&quot;&gt;Continuation&lt;/a&gt; instance. The &lt;a href=&quot;create-coroutine#kotlin.coroutines.experimental%24createCoroutine%28kotlin.coroutines.SuspendFunction0%28%28kotlin.coroutines.experimental.createCoroutine.T%29%29%2C+kotlin.coroutines.experimental.Continuation%28%28kotlin.coroutines.experimental.createCoroutine.T%29%29%29%2Fcompletion&quot;&gt;completion&lt;/a&gt; continuation is invoked when coroutine completes with result or exception. Repeated invocation of any resume function on the resulting continuation produces &lt;a href=&quot;../kotlin/-illegal-state-exception/index#kotlin.IllegalStateException&quot;&gt;IllegalStateException&lt;/a&gt;.</source>
          <target state="translated">要开始执行创建的协程，请在返回的&lt;a href=&quot;-continuation/index&quot;&gt;Continuation&lt;/a&gt;实例上调用 &lt;code&gt;resume(Unit)&lt;/code&gt; 。在&lt;a href=&quot;create-coroutine#kotlin.coroutines.experimental%24createCoroutine%28kotlin.coroutines.SuspendFunction0%28%28kotlin.coroutines.experimental.createCoroutine.T%29%29%2C+kotlin.coroutines.experimental.Continuation%28%28kotlin.coroutines.experimental.createCoroutine.T%29%29%29%2Fcompletion&quot;&gt;完成&lt;/a&gt;时，协程与结果或异常结束连续被调用。在结果延续上重复调用任何恢复函数都会产生&lt;a href=&quot;../kotlin/-illegal-state-exception/index#kotlin.IllegalStateException&quot;&gt;IllegalStateException&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7ae9d4ba7899cbe4180b0d690d30390847f2291f" translate="yes" xml:space="preserve">
          <source>To start executing the created coroutine, invoke &lt;code&gt;resume(Unit)&lt;/code&gt; on the returned &lt;a href=&quot;-continuation/index&quot;&gt;Continuation&lt;/a&gt; instance. The &lt;a href=&quot;create-coroutine#kotlin.coroutines.experimental%24createCoroutine%28kotlin.coroutines.SuspendFunction1%28%28kotlin.coroutines.experimental.createCoroutine.R%2C+kotlin.coroutines.experimental.createCoroutine.T%29%29%2C+kotlin.coroutines.experimental.createCoroutine.R%2C+kotlin.coroutines.experimental.Continuation%28%28kotlin.coroutines.experimental.createCoroutine.T%29%29%29%2Fcompletion&quot;&gt;completion&lt;/a&gt; continuation is invoked when coroutine completes with result or exception. Repeated invocation of any resume function on the resulting continuation produces &lt;a href=&quot;../kotlin/-illegal-state-exception/index#kotlin.IllegalStateException&quot;&gt;IllegalStateException&lt;/a&gt;.</source>
          <target state="translated">要开始执行创建的协程，请在返回的&lt;a href=&quot;-continuation/index&quot;&gt;Continuation&lt;/a&gt;实例上调用 &lt;code&gt;resume(Unit)&lt;/code&gt; 。在&lt;a href=&quot;create-coroutine#kotlin.coroutines.experimental%24createCoroutine%28kotlin.coroutines.SuspendFunction1%28%28kotlin.coroutines.experimental.createCoroutine.R%2C+kotlin.coroutines.experimental.createCoroutine.T%29%29%2C+kotlin.coroutines.experimental.createCoroutine.R%2C+kotlin.coroutines.experimental.Continuation%28%28kotlin.coroutines.experimental.createCoroutine.T%29%29%29%2Fcompletion&quot;&gt;完成&lt;/a&gt;时，协程与结果或异常结束连续被调用。在结果延续上重复调用任何恢复函数都会产生&lt;a href=&quot;../kotlin/-illegal-state-exception/index#kotlin.IllegalStateException&quot;&gt;IllegalStateException&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="dfc6df82451691b1971099e0817380884cac3aec" translate="yes" xml:space="preserve">
          <source>To start executing the created coroutine, invoke &lt;code&gt;resume(Unit)&lt;/code&gt; on the returned Continuation instance. The &lt;a href=&quot;create-coroutine-unchecked#kotlin.coroutines.experimental.intrinsics%24createCoroutineUnchecked%28kotlin.coroutines.SuspendFunction0%28%28kotlin.coroutines.experimental.intrinsics.createCoroutineUnchecked.T%29%29%2C+kotlin.coroutines.experimental.Continuation%28%28kotlin.coroutines.experimental.intrinsics.createCoroutineUnchecked.T%29%29%29%2Fcompletion&quot;&gt;completion&lt;/a&gt; continuation is invoked when coroutine completes with result or exception.</source>
          <target state="translated">要开始执行创建的协程，请在返回的Continuation实例上调用 &lt;code&gt;resume(Unit)&lt;/code&gt; 。在&lt;a href=&quot;create-coroutine-unchecked#kotlin.coroutines.experimental.intrinsics%24createCoroutineUnchecked%28kotlin.coroutines.SuspendFunction0%28%28kotlin.coroutines.experimental.intrinsics.createCoroutineUnchecked.T%29%29%2C+kotlin.coroutines.experimental.Continuation%28%28kotlin.coroutines.experimental.intrinsics.createCoroutineUnchecked.T%29%29%29%2Fcompletion&quot;&gt;完成&lt;/a&gt;时，协程与结果或异常结束连续被调用。</target>
        </trans-unit>
        <trans-unit id="e102b42121057a6878b15b2e0b7a9abdd7059c88" translate="yes" xml:space="preserve">
          <source>To start executing the created coroutine, invoke &lt;code&gt;resume(Unit)&lt;/code&gt; on the returned Continuation instance. The &lt;a href=&quot;create-coroutine-unchecked#kotlin.coroutines.experimental.intrinsics%24createCoroutineUnchecked%28kotlin.coroutines.SuspendFunction1%28%28kotlin.coroutines.experimental.intrinsics.createCoroutineUnchecked.R%2C+kotlin.coroutines.experimental.intrinsics.createCoroutineUnchecked.T%29%29%2C+kotlin.coroutines.experimental.intrinsics.createCoroutineUnchecked.R%2C+kotlin.coroutines.experimental.Continuation%28%28kotlin.coroutines.experimental.intrinsics.createCoroutineUnchecked.T%29%29%29%2Fcompletion&quot;&gt;completion&lt;/a&gt; continuation is invoked when coroutine completes with result or exception.</source>
          <target state="translated">要开始执行创建的协程，请在返回的Continuation实例上调用 &lt;code&gt;resume(Unit)&lt;/code&gt; 。在&lt;a href=&quot;create-coroutine-unchecked#kotlin.coroutines.experimental.intrinsics%24createCoroutineUnchecked%28kotlin.coroutines.SuspendFunction1%28%28kotlin.coroutines.experimental.intrinsics.createCoroutineUnchecked.R%2C+kotlin.coroutines.experimental.intrinsics.createCoroutineUnchecked.T%29%29%2C+kotlin.coroutines.experimental.intrinsics.createCoroutineUnchecked.R%2C+kotlin.coroutines.experimental.Continuation%28%28kotlin.coroutines.experimental.intrinsics.createCoroutineUnchecked.T%29%29%29%2Fcompletion&quot;&gt;完成&lt;/a&gt;时，协程与结果或异常结束连续被调用。</target>
        </trans-unit>
        <trans-unit id="a74d51560d5c774d1a56f8d84a208e43206f3604" translate="yes" xml:space="preserve">
          <source>To start executing the created coroutine, invoke &lt;code&gt;resume(Unit)&lt;/code&gt; on the returned Continuation instance. The &lt;a href=&quot;create-coroutine-unintercepted#kotlin.coroutines.intrinsics%24createCoroutineUnintercepted%28kotlin.coroutines.SuspendFunction0%28%28kotlin.coroutines.intrinsics.createCoroutineUnintercepted.T%29%29%2C+kotlin.coroutines.Continuation%28%28kotlin.coroutines.intrinsics.createCoroutineUnintercepted.T%29%29%29%2Fcompletion&quot;&gt;completion&lt;/a&gt; continuation is invoked when coroutine completes with result or exception.</source>
          <target state="translated">要开始执行创建的协程，请在返回的Continuation实例上调用 &lt;code&gt;resume(Unit)&lt;/code&gt; 。在&lt;a href=&quot;create-coroutine-unintercepted#kotlin.coroutines.intrinsics%24createCoroutineUnintercepted%28kotlin.coroutines.SuspendFunction0%28%28kotlin.coroutines.intrinsics.createCoroutineUnintercepted.T%29%29%2C+kotlin.coroutines.Continuation%28%28kotlin.coroutines.intrinsics.createCoroutineUnintercepted.T%29%29%29%2Fcompletion&quot;&gt;完成&lt;/a&gt;时，协程与结果或异常结束连续被调用。</target>
        </trans-unit>
        <trans-unit id="aa80d28b000c404e7e7471739dc834ced4e443ec" translate="yes" xml:space="preserve">
          <source>To start executing the created coroutine, invoke &lt;code&gt;resume(Unit)&lt;/code&gt; on the returned Continuation instance. The &lt;a href=&quot;create-coroutine-unintercepted#kotlin.coroutines.intrinsics%24createCoroutineUnintercepted%28kotlin.coroutines.SuspendFunction1%28%28kotlin.coroutines.intrinsics.createCoroutineUnintercepted.R%2C+kotlin.coroutines.intrinsics.createCoroutineUnintercepted.T%29%29%2C+kotlin.coroutines.intrinsics.createCoroutineUnintercepted.R%2C+kotlin.coroutines.Continuation%28%28kotlin.coroutines.intrinsics.createCoroutineUnintercepted.T%29%29%29%2Fcompletion&quot;&gt;completion&lt;/a&gt; continuation is invoked when coroutine completes with result or exception.</source>
          <target state="translated">要开始执行创建的协程，请在返回的Continuation实例上调用 &lt;code&gt;resume(Unit)&lt;/code&gt; 。在&lt;a href=&quot;create-coroutine-unintercepted#kotlin.coroutines.intrinsics%24createCoroutineUnintercepted%28kotlin.coroutines.SuspendFunction1%28%28kotlin.coroutines.intrinsics.createCoroutineUnintercepted.R%2C+kotlin.coroutines.intrinsics.createCoroutineUnintercepted.T%29%29%2C+kotlin.coroutines.intrinsics.createCoroutineUnintercepted.R%2C+kotlin.coroutines.Continuation%28%28kotlin.coroutines.intrinsics.createCoroutineUnintercepted.T%29%29%29%2Fcompletion&quot;&gt;完成&lt;/a&gt;时，协程与结果或异常结束连续被调用。</target>
        </trans-unit>
        <trans-unit id="e2482fe90c75c3748aeac1be942111f81e932b33" translate="yes" xml:space="preserve">
          <source>To start the course, go to &lt;strong&gt;View -&amp;gt; Tool Windows -&amp;gt; Project&lt;/strong&gt;. You will find a course plan, the list of lessons. Every lesson has a set of tasks and code exercises you need to solve. Start with the very first one:</source>
          <target state="translated">要开始该课程，请转到&lt;strong&gt;查看-&amp;gt;工具窗口-&amp;gt;项目&lt;/strong&gt;。您会找到一个课程计划，课程列表。每节课都有您需要解决的一组任务和代码练习。从第一个开始：</target>
        </trans-unit>
        <trans-unit id="5f3ceec14c1433cf322f7865c09a18312ccb1945" translate="yes" xml:space="preserve">
          <source>To start with, we'll need a Microsoft Visual C++ compiler installed that supports a x64_64 target. The easiest way to do this is to have a version of Microsoft Visual Studio installed on a Windows machine.</source>
          <target state="translated">首先,我们需要安装一个支持x64_64目标的Microsoft Visual C++编译器。最简单的方法是在Windows机器上安装一个Microsoft Visual Studio的版本。</target>
        </trans-unit>
        <trans-unit id="66185b084e5432ac45a03abd883161f880e5f11e" translate="yes" xml:space="preserve">
          <source>To switch to the old behavior, pass the fallback flag &lt;code&gt;-Xno-receiver-assertions&lt;/code&gt; to the compiler.</source>
          <target state="translated">要切换到旧的行为，请将后备标志 &lt;code&gt;-Xno-receiver-assertions&lt;/code&gt; 传递给编译器。</target>
        </trans-unit>
        <trans-unit id="cc3b8fe9e3a75acdfca2d542f5fc3f0b9c8e0c32" translate="yes" xml:space="preserve">
          <source>To switch to the old smart casts behavior, pass the fallback flag &lt;code&gt;-Xlegacy-smart-cast-after-try&lt;/code&gt; as the compiler argument. It will become deprecated in Kotlin 1.3.</source>
          <target state="translated">要切换到旧的智能强制转换行为，请将后备标志 &lt;code&gt;-Xlegacy-smart-cast-after-try&lt;/code&gt; 作为编译器参数传递。它会在Kotlin 1.3中弃用。</target>
        </trans-unit>
        <trans-unit id="3ee56f12e381a099c59880a6823066a60e9d50df" translate="yes" xml:space="preserve">
          <source>To take all the elements except a given number of first or last elements, call the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/drop&quot;&gt;&lt;code&gt;drop()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/drop-last&quot;&gt;&lt;code&gt;dropLast()&lt;/code&gt;&lt;/a&gt; functions respectively.</source>
          <target state="translated">要获取除给定数量的第一个或最后一个元素以外的所有元素，请分别调用&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/drop&quot;&gt; &lt;code&gt;drop()&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/drop-last&quot;&gt; &lt;code&gt;dropLast()&lt;/code&gt; &lt;/a&gt;函数。</target>
        </trans-unit>
        <trans-unit id="ca844ba87cff8c023079c9be62782b3a3fde8a97" translate="yes" xml:space="preserve">
          <source>To target the JVM, apply the Kotlin JVM plugin. Starting with Kotlin 1.1.1, the plugin can be applied using the &lt;a href=&quot;https://docs.gradle.org/current/userguide/plugins.html#sec:plugins_block&quot;&gt;Gradle plugins DSL&lt;/a&gt;:</source>
          <target state="translated">要定位JVM，请应用Kotlin JVM插件。从Kotlin 1.1.1开始，可以使用&lt;a href=&quot;https://docs.gradle.org/current/userguide/plugins.html#sec:plugins_block&quot;&gt;Gradle插件DSL&lt;/a&gt;应用该插件：</target>
        </trans-unit>
        <trans-unit id="089288f0ea4e442474ea533e687f95ceb53b919e" translate="yes" xml:space="preserve">
          <source>To tell Kotlin that a certain declaration is written in pure JavaScript, you should mark it with &lt;code&gt;external&lt;/code&gt; modifier. When the compiler sees such a declaration, it assumes that the implementation for the corresponding class, function or property is provided by the developer, and therefore does not try to generate any JavaScript code from the declaration. This means that you should omit bodies of &lt;code&gt;external&lt;/code&gt; declarations. For example:</source>
          <target state="translated">要告诉Kotlin某个声明是用纯JavaScript编写的，您应该使用 &lt;code&gt;external&lt;/code&gt; 修饰符对其进行标记。当编译器看到这样的声明时，它假定开发人员提供了相应类，函数或属性的实现，因此不会尝试从该声明生成任何JavaScript代码。这意味着您应该省略 &lt;code&gt;external&lt;/code&gt; 声明的主体。例如：</target>
        </trans-unit>
        <trans-unit id="13b684242eb1261a088744c1edd0d98430ef5246" translate="yes" xml:space="preserve">
          <source>To tell Kotlin that an &lt;code&gt;external&lt;/code&gt; class, package, function or property is a JavaScript module, you can use &lt;code&gt;@JsModule&lt;/code&gt; annotation. Consider you have the following CommonJS module called &quot;hello&quot;:</source>
          <target state="translated">要告诉Kotlin &lt;code&gt;external&lt;/code&gt; 类，包，函数或属性是JavaScript模块，可以使用 &lt;code&gt;@JsModule&lt;/code&gt; 批注。考虑您具有以下称为&amp;ldquo; hello&amp;rdquo;的CommonJS模块：</target>
        </trans-unit>
        <trans-unit id="9709dd3d7713138256dbb958ab241135af68f988" translate="yes" xml:space="preserve">
          <source>To test it, we'll use a simple async function that resolves to a specified string after a specified time:</source>
          <target state="translated">为了测试它,我们将使用一个简单的异步函数,在指定时间后解析到一个指定的字符串。</target>
        </trans-unit>
        <trans-unit id="1b99a15ae02c59db4c41dbf465be5149eb5f7541" translate="yes" xml:space="preserve">
          <source>To throw an exception object, use the &lt;em&gt;throw&lt;/em&gt;-expression:</source>
          <target state="translated">要抛出异常对象，请使用&lt;em&gt;throw&lt;/em&gt; -expression：</target>
        </trans-unit>
        <trans-unit id="374704e123399146f9a10acdf418e1645171dca5" translate="yes" xml:space="preserve">
          <source>To unwrap the reference:</source>
          <target state="translated">要解开参考文献:</target>
        </trans-unit>
        <trans-unit id="a91c18bfe059c0da75a37ebc4ffaf3efe0d2e769" translate="yes" xml:space="preserve">
          <source>To unzip a list of pairs, call &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/unzip&quot;&gt;&lt;code&gt;unzip()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">要解压缩对列表，请调用&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/unzip&quot;&gt; &lt;code&gt;unzip()&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d8bf5ffe82f149520490d0887cef3348767dda39" translate="yes" xml:space="preserve">
          <source>To use a property, we simply refer to it by name, as if it were a field in Java:</source>
          <target state="translated">要使用一个属性,我们只需用名字来引用它,就像它是Java中的一个字段一样。</target>
        </trans-unit>
        <trans-unit id="213ffc2b7aa1496be9528a577f9f8df930989d35" translate="yes" xml:space="preserve">
          <source>To use an EAP build instead, we need to specify its version in &lt;code&gt;ext.kotlin_version&lt;/code&gt; and add the corresponding repository to the &lt;code&gt;buildscript&lt;/code&gt; section (usually EAP builds are located on &lt;a href=&quot;https://bintray.com/kotlin&quot;&gt;Bintray&lt;/a&gt;)</source>
          <target state="translated">要改用EAP构建，我们需要在 &lt;code&gt;ext.kotlin_version&lt;/code&gt; 中指定其版本，并将相应的存储库添加到 &lt;code&gt;buildscript&lt;/code&gt; 部分（通常EAP构建位于&lt;a href=&quot;https://bintray.com/kotlin&quot;&gt;Bintray上&lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="95905a2dc80cd98916ed0f8c91572f9ae392d28e" translate="yes" xml:space="preserve">
          <source>To use an experimental API in all functions and classes in a file, add the file-level annotation &lt;code&gt;@file:UseExperimental&lt;/code&gt; to the top of the file before the package specification and imports.</source>
          <target state="translated">要在文件的所有函数和类中使用实验性API ，请在文件包规范和导入之前，在文件顶部添加文件级注释 &lt;code&gt;@file:UseExperimental&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="905c85d4c4dbeeb5849e639296b6ff9051d12bf0" translate="yes" xml:space="preserve">
          <source>To use classes or functions from a project in the scratch, import them into the scratch file as usual with the &lt;code&gt;import&lt;/code&gt; statement. Then write your code and run it with the appropriate module selected in &lt;strong&gt;Use classpath of module&lt;/strong&gt; list. To rebuild the module automatically before running the scratch, select &lt;strong&gt;Make before Run&lt;/strong&gt;.</source>
          <target state="translated">要从头开始使用项目中的类或函数，请照常使用 &lt;code&gt;import&lt;/code&gt; 语句将它们导入到头文件中。然后编写代码并&lt;strong&gt;使用&lt;/strong&gt;在&amp;ldquo; &lt;strong&gt;使用模块的类路径&amp;rdquo;&lt;/strong&gt;列表中选择的相应模块运行它。要在运行暂存器之前自动重建模块，&lt;strong&gt;请&lt;/strong&gt;选择&lt;strong&gt;&amp;ldquo;运行前制作&amp;rdquo;&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="7e6f898d3fd804cbaaa8f5e41eecb4b87b3f095b" translate="yes" xml:space="preserve">
          <source>To use it with Kotlin configure annotation processing dependency using &lt;code&gt;kapt&lt;/code&gt;:</source>
          <target state="translated">要将其与Kotlin一起使用，请使用 &lt;code&gt;kapt&lt;/code&gt; 配置注释处理依赖项：</target>
        </trans-unit>
        <trans-unit id="a24de3bc480fd74ef920d5e8c2200b8ea53a9381" translate="yes" xml:space="preserve">
          <source>To use such an extension outside its declaring package, we need to import it at the call site:</source>
          <target state="translated">要在其声明包之外使用这样的扩展,我们需要在调用站点导入它。</target>
        </trans-unit>
        <trans-unit id="f45da6c5e75b429df6c944cb1a348aa71eac1487" translate="yes" xml:space="preserve">
          <source>To use the Gradle worker API for parallel execution of kapt tasks, add this line to your &lt;code&gt;gradle.properties&lt;/code&gt; file:</source>
          <target state="translated">要使用Gradle worker API并行执行kapt任务，请将此行添加到 &lt;code&gt;gradle.properties&lt;/code&gt; 文件中：</target>
        </trans-unit>
        <trans-unit id="f4b36ae1fba60b209f3facc66006c1d59e359e4b" translate="yes" xml:space="preserve">
          <source>To use the library just</source>
          <target state="translated">要使用图书馆,只需</target>
        </trans-unit>
        <trans-unit id="f8b6262cd9dc8c43d7c667ac936a5f2566f2a0e4" translate="yes" xml:space="preserve">
          <source>To use these dependencies from a Kotlin code, import a package &lt;code&gt;cocoapods.&amp;lt;library-name&amp;gt;&lt;/code&gt;. In the example above, it's &lt;code&gt;cocoapods.AFNetworking&lt;/code&gt;.</source>
          <target state="translated">要使用Kotlin代码中的这些依赖项，请导入包 &lt;code&gt;cocoapods.&amp;lt;library-name&amp;gt;&lt;/code&gt; 。在上面的示例中，它是 &lt;code&gt;cocoapods.AFNetworking&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="29ce373f521a913b58c57c24b3da2c509d708a6c" translate="yes" xml:space="preserve">
          <source>To verify that your code is formatted according to the style guide, go to the inspection settings and enable the &quot;Kotlin | Style issues | File is not formatted according to project settings&quot; inspection. Additional inspections that verify other issues described in the style guide (such as naming conventions) are enabled by default.</source>
          <target state="translated">要验证你的代码是否按照样式指南进行了格式化,请进入检查设置并启用 &quot;Kotlin | 样式问题 | 文件未按照项目设置进行格式化 &quot;检查。默认情况下,会启用额外的检查来验证样式指南中描述的其他问题(例如命名约定)。</target>
        </trans-unit>
        <trans-unit id="b6747c485a8043bd5cfaa965ac1719dda893a066" translate="yes" xml:space="preserve">
          <source>To wrap the reference:</source>
          <target state="translated">要包涵参考。</target>
        </trans-unit>
        <trans-unit id="4fc60ef5d69079c451ea67854c51808d9ec41c01" translate="yes" xml:space="preserve">
          <source>Tooling</source>
          <target state="translated">Tooling</target>
        </trans-unit>
        <trans-unit id="4fa8cc860c52b268dc6a3adcde7305e9415db5bb" translate="yes" xml:space="preserve">
          <source>Tools</source>
          <target state="translated">Tools</target>
        </trans-unit>
        <trans-unit id="a2b342afe760f02175e18eb57be53d77e5b4d945" translate="yes" xml:space="preserve">
          <source>Tools for Android Development</source>
          <target state="translated">Android开发工具</target>
        </trans-unit>
        <trans-unit id="933c173dc4997663d3dd2b639f726f17d399abb1" translate="yes" xml:space="preserve">
          <source>Top level/global variables of non-primitive types are by default accessible in the main thread (i.e., the thread which initialized &lt;em&gt;Kotlin/Native&lt;/em&gt; runtime first) only. Access from another thread will lead to an &lt;code&gt;IncorrectDereferenceException&lt;/code&gt; being thrown. To make such variables accessible in other threads, you can use either the &lt;code&gt;@ThreadLocal&lt;/code&gt; annotation, and mark the value thread local or &lt;code&gt;@SharedImmutable&lt;/code&gt;, which will make the value frozen and accessible from other threads.</source>
          <target state="translated">默认情况下，非基本类型的顶级/全局变量只能在主线程（即，首先初始化&lt;em&gt;Kotlin / Native&lt;/em&gt;运行时的线程）中访问。来自另一个线程的访问将导致引发 &lt;code&gt;IncorrectDereferenceException&lt;/code&gt; 。若要使此类变量可在其他线程中访问，可以使用 &lt;code&gt;@ThreadLocal&lt;/code&gt; 批注，并将值thread标记为local或 &lt;code&gt;@SharedImmutable&lt;/code&gt; ，这将使该值冻结并可以从其他线程访问。</target>
        </trans-unit>
        <trans-unit id="d10164060fa5359f1cc0440621a4aa0561a65a4b" translate="yes" xml:space="preserve">
          <source>Top-level Kotlin functions and properties are accessible as members of special classes. Each Kotlin file is translated into such a class. E.g.</source>
          <target state="translated">顶级的Kotlin函数和属性可以作为特殊类的成员来访问。每个Kotlin文件都会被翻译成这样一个类。例如</target>
        </trans-unit>
        <trans-unit id="2b1be77aa458090db17874852b17692b274f4c30" translate="yes" xml:space="preserve">
          <source>Top-level functions and properties</source>
          <target state="translated">顶层功能和属性</target>
        </trans-unit>
        <trans-unit id="73a9d7257a50c4b586e17a750a9b120479406586" translate="yes" xml:space="preserve">
          <source>Top-level variables:</source>
          <target state="translated">顶层变量:</target>
        </trans-unit>
        <trans-unit id="093982a5b38ce32bb690b5df5afe9cfb58db39b3" translate="yes" xml:space="preserve">
          <source>Top-level, or member of an &lt;a href=&quot;object-declarations#object-declarations&quot;&gt;&lt;em&gt;object&lt;/em&gt; declaration&lt;/a&gt; or &lt;a href=&quot;object-declarations#companion-objects&quot;&gt;a &lt;em&gt;companion object&lt;/em&gt;&lt;/a&gt;.</source>
          <target state="translated">顶级或成员的的&lt;a href=&quot;object-declarations#object-declarations&quot;&gt;&lt;em&gt;对象&lt;/em&gt;申报&lt;/a&gt;或&lt;a href=&quot;object-declarations#companion-objects&quot;&gt;一个&lt;em&gt;同伴对象&lt;/em&gt;&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e3f139abb7a549a1210b36f7dbf89215ad6c9902" translate="yes" xml:space="preserve">
          <source>Touch</source>
          <target state="translated">Touch</target>
        </trans-unit>
        <trans-unit id="86c192cdf813e67ab4284db18cce6c47a873de77" translate="yes" xml:space="preserve">
          <source>TrackEventInit</source>
          <target state="translated">TrackEventInit</target>
        </trans-unit>
        <trans-unit id="24c733cfc9ff52310bfeff0739e9d84bd974f090" translate="yes" xml:space="preserve">
          <source>Training Partners</source>
          <target state="translated">培训伙伴</target>
        </trans-unit>
        <trans-unit id="62000f6d60c7b6da6e48acb50b9e4d2454c263e3" translate="yes" xml:space="preserve">
          <source>TransferMode</source>
          <target state="translated">TransferMode</target>
        </trans-unit>
        <trans-unit id="d685ad7c59aeb1945ef867b52857539b62c1b81c" translate="yes" xml:space="preserve">
          <source>Transformations</source>
          <target state="translated">Transformations</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
